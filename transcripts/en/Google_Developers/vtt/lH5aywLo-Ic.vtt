WEBVTT
Kind: captions
Language: en

00:11:26.381 --> 00:11:29.014
DevTools: State of the Union

00:11:32.495 --> 00:11:41.260
 2017.   State of the Union 
2017. 

00:27:08.076 --> 00:27:11.695
 State of the June 2017

00:27:15.318 --> 00:27:17.736
 with Paul Irish. 

00:27:25.804 --> 00:27:34.330
.       

00:27:49.554 --> 00:27:51.554
 State of the Union with Paul 
Irish

00:31:03.147 --> 00:31:06.093
    PAUL IRISH:  All right.  How
 is it going?  Good morning.  

00:31:06.094 --> 00:31:08.845
All right.  Today I want to 
share with you some of the stuff

00:31:09.328 --> 00:31:12.747
 we've been doing on the Chrome 
DevTools team in the past year. 

00:31:13.203 --> 00:31:18.928
 speak a moment for the Chrome 
DevTools team, we have been --  

00:31:18.929 --> 00:31:25.315
is really to deliver you the 
tools to enable you to be 

00:31:25.682 --> 00:31:28.800
productive.  Can I get the 
speaker notes right over here on

00:31:29.350 --> 00:31:33.432
 the left side?  It's going to 
be great.  It's even better.  

00:31:33.433 --> 00:31:43.389
The good words.  We will do it. 
 going to be good.  I'll 

00:31:43.550 --> 00:31:45.550
just dance. 

00:31:47.897 --> 00:31:51.170
 Until -- all right, all right, 
all right.  Are we good?  

00:31:51.347 --> 00:31:57.836
Uh-huh.  Uh-huh.  Uh-huh.right. 
 Can we come back to this 

00:31:57.837 --> 00:32:05.306
machine right quick?  This guy 
right here?  Love it.  Love it. 

00:32:05.556 --> 00:32:07.556
 All right. 

00:32:10.754 --> 00:32:15.654
 So whoo.  Thank you.  Today I 
want to share with you some of 

00:32:15.655 --> 00:32:19.720
the good stuff we've been doing 
the last year on the DevTools 

00:32:19.962 --> 00:32:23.805
team, and to speak for the team 
we want to enable you and equip 

00:32:23.806 --> 00:32:27.774
you with the tools to make you a
 productive developer. means 

00:32:27.775 --> 00:32:31.635
powerful tooling to understand 
and improve your application.  

00:32:31.636 --> 00:32:35.205
We want that experience to be 
fun, too, and delightful.  So 

00:32:35.206 --> 00:32:40.629
today we're going to cover a few
 things.  your scripts, 

00:32:40.762 --> 00:32:44.222
performance, auditing for 
excellence and look at

00:32:47.882 --> 00:32:54.033
 Node.js and Headless.  We talk 
off with debugging and console 

00:32:54.203 --> 00:32:56.181
ergonomics.  The console is part
 of the core experience.  You 

00:32:56.182 --> 00:32:59.967
spent a lot of time there, so we
 enjoy investing these work 

00:33:00.198 --> 00:33:04.064
flows, so these are a few things
 we noticed that might need some

00:33:04.616 --> 00:33:08.658
 sprucing up a little bit.  So 
the console, right?  I'm going 

00:33:08.659 --> 00:33:13.690
to show you object previews and 
some new, improved autocomplete.

00:33:16.783 --> 00:33:20.836
  on previews, we'll show a 
video.  This is an object and 

00:33:20.837 --> 00:33:25.300
exploring it and this is a bunch
 of network requests.  It's an 

00:33:25.455 --> 00:33:29.010
array of objects and to hunt 
around and find the one object 

00:33:29.298 --> 00:33:32.482
I'm looking for, it takes a bit 
of work, right?  Same thing 

00:33:32.610 --> 00:33:37.152
here.  I'm clicking around.  
just wondering, you know, maybe 

00:33:37.153 --> 00:33:40.644
that we could provide this a 
little bit more proactively, and

00:33:41.117 --> 00:33:44.514
 so we're going to switch over 
to what it looks like now.  this

00:33:44.759 --> 00:33:49.015
 object, open it up, and now 
when you click on open it, so we

00:33:49.126 --> 00:33:52.875
 get the previews of all the 
child objects immediately.  So 

00:33:52.876 --> 00:33:57.807
just instantly browse, and you 
see all the subproperties, and 

00:33:57.808 --> 00:34:01.086
you're in a good state of 
knowing immediately what's 

00:34:01.087 --> 00:34:04.063
happening inside the DL.  All 
right.  So that subject 

00:34:04.752 --> 00:34:08.856
previews, and that's another 
view of that.  On the left we've

00:34:09.073 --> 00:34:12.566
 got what it was last week, to 
be honest, but in today's Chrome

00:34:12.997 --> 00:34:16.061
 canary, you see something more 
like this.  So an array of 

00:34:16.247 --> 00:34:18.741
arrays, and now you get to see 
exactly what is in there without

00:34:18.872 --> 00:34:23.873
 having to click in all the 
time.  This is good stuff. 

00:34:24.344 --> 00:34:29.687
right.  Yeah.  I like it.  I 
like it.  It's good.  All right.

00:34:30.057 --> 00:34:33.787
 going to show you some 
autocomplete stuff.  I'm coming 

00:34:34.132 --> 00:34:40.126
over here to my machine, take a 
sip of water.  We're going to 

00:34:40.332 --> 00:34:45.945
pop open to the console.  All 
right.  So we're here in the 

00:34:46.370 --> 00:34:52.642
console, and I'll bring it in on
 about blank solid page.  Now, 

00:34:52.643 --> 00:34:55.844
you're at the console, and you 
like to type things.  We want to

00:34:56.202 --> 00:34:59.803
 make sure it's very fast for 
you to get completions so that 

00:34:59.804 --> 00:35:04.555
you are able to do the work that
 you want to do.  I'm going to 

00:35:04.556 --> 00:35:10.211
look at document and we'll look 
at document.head, and now I want

00:35:10.408 --> 00:35:16.059
 to make sure that -- I want to 
look at the child nodes, okay?  

00:35:16.060 --> 00:35:23.064
So I search over to child's 
nodes. out, now, at this point 

00:35:23.210 --> 00:35:25.636
auto completion as I type it in 
because we know what document 

00:35:25.637 --> 00:35:30.086
head is, right?  Then we reach a
 point where we type in download

00:35:30.204 --> 00:35:34.571
 to zero, and we've done this 
array access, right?  Now, when 

00:35:34.572 --> 00:35:37.980
we do dollar zero, then all of a
 sudden the completions, they 

00:35:38.297 --> 00:35:41.684
used to completely fail.  So I'm
 happy to report that now you 

00:35:42.163 --> 00:35:45.275
have a period where like no 
problem, array access.  You got 

00:35:45.276 --> 00:35:53.079
the completions, too.  Now, 
another one.  Let's say that you

00:35:54.023 --> 00:35:59.409
 have an object.  The object 
looks maybe like this guy.  So 

00:36:00.269 --> 00:36:02.881
the properties have dashes, and 
so you might know where I'm 

00:36:03.718 --> 00:36:07.879
going with this.  If -- I'll 
switch this over.  If we take 

00:36:08.560 --> 00:36:15.457
this and now we run this in the 
console, then classes.net, but I

00:36:15.741 --> 00:36:18.511
 can't because there's dashes, 
right?  Not a problem.  Square 

00:36:18.683 --> 00:36:23.033
back to notation.  No big deal. 
 back will make sure you have 

00:36:23.034 --> 00:36:28.012
the key names right here, too.  
So good stuff.  We can do a 

00:36:28.013 --> 00:36:30.858
little better.  You might be 
more on the bleeding edge of 

00:36:30.859 --> 00:36:34.130
things and the new side.  So 
let's take this object here of 

00:36:34.298 --> 00:36:38.256
classes, and we're going to make
 it a map, all right?  We do map

00:36:39.039 --> 00:36:42.651
 equals new map and we're going 
to use object at entries.  I 

00:36:42.652 --> 00:36:46.911
think this is ES7 even, so 
objects at entries and new map. 

00:36:47.224 --> 00:36:51.259
 create a map of the exact same 
information.  Now we do map.get 

00:36:51.260 --> 00:36:54.943
and open up the pa REN, and 
there are keys, too.  Making 

00:36:54.944 --> 00:36:59.406
sure you have all the data right
 at your fingertips.  All right.

00:36:59.407 --> 00:37:03.834
  while we're in the console, 
sometimes we spend a little bit 

00:37:03.971 --> 00:37:07.580
more time typing something out 
than we actually thought.  We 

00:37:07.581 --> 00:37:11.724
create not just a one-liner and 
we're like, there's some work to

00:37:12.032 --> 00:37:19.370
 do.  We'll type out this 
function.  I call it a log.  

00:37:19.371 --> 00:37:24.868
just say args and we'll open up 
the bracket.  I want to do a 

00:37:25.620 --> 00:37:31.527
function.  Do I hit shift enter 
so it doesn't evaluate.  I don't

00:37:31.528 --> 00:37:35.267
 want it to error.  Don't worry 
about it any.  We're going to 

00:37:35.268 --> 00:37:38.783
give you a new line and indent 
and, you're in a good place.  

00:37:38.784 --> 00:37:45.372
Type in console 1 and do the arg
s and log it out and enter 

00:37:45.572 --> 00:37:49.223
again.  We know you're not done.
  We close off the brace.  fix 

00:37:49.224 --> 00:37:53.155
the indentation and enter it one
 more and evaluate it. right.  

00:37:53.156 --> 00:37:57.758
That's good.  Now we have a nice
 multi--line console aware of 

00:37:57.759 --> 00:38:00.496
what's happening and is not 
going to evaluate something 

00:38:01.201 --> 00:38:06.307
that's obviously incorrect.   
this console, too, has some 

00:38:06.308 --> 00:38:11.381
upgrades.  Syntax highlighting. 
 not here a year ago.   other 

00:38:11.382 --> 00:38:16.230
text editor features.  I hit 
command D and can do multiple 

00:38:16.231 --> 00:38:18.977
selections and change what I 
need right there inside the 

00:38:20.686 --> 00:38:23.745
console.  All right.  this is 
some of the cool stuff in the 

00:38:23.954 --> 00:38:29.128
console.  Thank you, thank you. 
 Now I'm going to switch gears a

00:38:29.129 --> 00:38:37.366
 little bit and talk about asing
 NUS JavaScript, right?  Do you 

00:38:37.367 --> 00:38:43.012
write a lot of asynchronous 
JavaScript?  Me too.  Do you use

00:38:43.647 --> 00:38:47.949
 Promises?  Yes, Promises all 
the time.  What it be like if we

00:38:48.392 --> 00:38:53.903
 didn't have them.  nice, but on
 the other hand, debugging 

00:38:54.026 --> 00:38:58.871
Promises, not as much fun 
really, is it?  So I want to 

00:38:58.872 --> 00:39:00.907
talk a little bit about

00:39:04.412 --> 00:39:08.242
 async debugging and show it 
with a trio of examples.  We 

00:39:08.243 --> 00:39:12.893
come back over here, and I like 
the about blank page.  This is 

00:39:13.060 --> 00:39:18.335
good. I'm going to look at these
 snippets.  Okay.  So here we 

00:39:18.336 --> 00:39:24.839
got a snippet here.  Zoom out 
just a tad.  All right.  So this

00:39:25.261 --> 00:39:30.173
 snippet.  We start out with a 
job.  A job runs, and we call a 

00:39:30.389 --> 00:39:32.944
process.  In the process we 
logout a little bit and get some

00:39:33.523 --> 00:39:37.998
 data.  We print that.  It's 
just logs.  We finish up, and I 

00:39:37.999 --> 00:39:42.221
got a debugger statement here so
 that I break, right?  

00:39:42.222 --> 00:39:44.547
Synchronous execution flow, 
we're good.  I'm going to run 

00:39:45.239 --> 00:39:48.701
this.  This is a snippet, so I 
can click this button or hit 

00:39:48.702 --> 00:39:54.537
command enter, and we're good.  
Well, we do have a reference 

00:39:54.649 --> 00:39:58.827
error, so we're not perfectly 
good, but if I just put that in 

00:40:00.264 --> 00:40:10.226
there, then I think we're good. 
 Okay.  It was an unnecessary 

00:40:10.491 --> 00:40:14.034
adjustment.  No big deal.  We 
look over the call stack.  Okay.

00:40:14.035 --> 00:40:21.862
  Call stack.  We start off at 
anonymous at the substantiation 

00:40:21.863 --> 00:40:25.356
of the job function.  Process is
 called and we go in and finish 

00:40:25.357 --> 00:40:28.303
and end up there.  This should 
be straightforward, right?  

00:40:28.304 --> 00:40:32.668
We're good.  We're good.  All 
right.   we have that other way,

00:40:32.820 --> 00:40:37.523
 we're going to take it up a 
number of so we're going from 

00:40:37.524 --> 00:40:39.524
synchronous to asink,

00:40:41.962 --> 00:40:48.736
 A sync so we use async await.  
Now we call job but we 

00:40:48.737 --> 00:40:52.545
introduced a little sleep 
function, just delay a few 

00:40:52.546 --> 00:40:55.666
milliseconds.  Now inside a 
process we log out, but we'll 

00:40:56.045 --> 00:41:02.294
sleep.  We'll go fetch a fan 
icon and print out that result 

00:41:02.295 --> 00:41:05.562
and sleep a little more and 
finish, okay? 

00:41:12.922 --> 00:41:17.480
 Let's try that owl and run 
that.  We pause.   difference 

00:41:17.481 --> 00:41:22.238
here is that we have the same 
four call frames in the stack 

00:41:22.239 --> 00:41:24.726
and they're pointing them at the
 same location, but in the 

00:41:24.727 --> 00:41:29.638
middle of this we have this 
asynchronous hop, because going 

00:41:29.639 --> 00:41:36.916
from job over to this call point
 in finish we had an 

00:41:36.917 --> 00:41:41.724
asynchronous operation.  process
 all of these are asynchronous, 

00:41:41.869 --> 00:41:49.601
sleep, print, and sleep again, 
right?  So this also works and 

00:41:49.602 --> 00:41:55.380
makes sense, but Promises, how I
 think a few more of us these 

00:41:55.381 --> 00:42:01.602
days are doing async work, so 
I'll switch over to that.  Same 

00:42:01.603 --> 00:42:05.477
basic approach, but with 
processes inside the job we do 

00:42:05.478 --> 00:42:09.748
resolve and go over here and 
inside process we have a Promise

00:42:09.749 --> 00:42:15.873
 resolve, sleep, fetch, get the 
result, sleep, finish, right?   

00:42:15.874 --> 00:42:21.551
run that.  The call stack again 
four call frames here, but two 

00:42:21.552 --> 00:42:26.289
asynchronous hops in there.  the
 important thing here is that we

00:42:26.290 --> 00:42:31.979
 are able to show the history of
 why we got here.   these are 

00:42:31.980 --> 00:42:37.134
kind of toy examples, but in the
 real world things get a bit 

00:42:37.135 --> 00:42:42.429
more complex.  So this is a 
slightly more real world stack. 

00:42:42.673 --> 00:42:48.050
 This is just the immediate 
stack of five synchronous call 

00:42:48.185 --> 00:42:52.971
frames, and it looks like 
something coming from J query.  

00:42:52.972 --> 00:42:58.132
There's not a lot of context, 
but if we have asynchronous 

00:42:58.133 --> 00:43:00.803
stacks enabled and have that 
feature behind the call stack, 

00:43:00.804 --> 00:43:07.126
then it looks more like this.  
Taller stack, but it gives us 

00:43:07.127 --> 00:43:10.242
much more context, so even at 
the bottom you see this came 

00:43:10.243 --> 00:43:14.261
from an event handler into 
submit handler and submit data. 

00:43:14.613 --> 00:43:18.195
 I know even at the top it 
doesn't really communicate much.

00:43:18.741 --> 00:43:24.518
 why this actually happened.  
Right?  This is increasingly the

00:43:24.869 --> 00:43:30.248
 default look of stacks, and in 
the browser we have many short 

00:43:30.249 --> 00:43:34.387
spurts of synchronous work held 
together by asynchronous 

00:43:35.138 --> 00:43:38.467
operations.  So like set 
time-out, request animation 

00:43:38.746 --> 00:43:46.095
frame, Promises, plenty of other
 APIs and not mention reacts new

00:43:46.511 --> 00:43:50.119
 core algorithm fiber.  This is 
designed to break up big chunks 

00:43:50.120 --> 00:43:54.662
of work into small chunks of 
work.  The browser is

00:43:58.638 --> 00:44:02.453
 all about async any.  Just a 
look at how this is in reality, 

00:44:02.454 --> 00:44:07.898
this is a view of all of the 
async operations happening over 

00:44:07.899 --> 00:44:12.505
the course of a quarter of a 
second, and we're taking all the

00:44:13.198 --> 00:44:16.319
 asynchronous operations and 
rendering them as little arrows.

00:44:16.604 --> 00:44:20.306
 don't expect you to get a lot 
out of this, but suffice it to 

00:44:20.307 --> 00:44:24.506
say it's busy.  There's a lot 
going on.  DevTools is able to 

00:44:24.507 --> 00:44:29.065
track what is going on from one 
call frame asynchronous hop over

00:44:29.273 --> 00:44:32.707
 to the next.  We think it's 
imperative for the tools to 

00:44:32.840 --> 00:44:36.242
communicate why you arrived at a
 specific call frame.  So to 

00:44:36.243 --> 00:44:39.461
pull this off, we had to do a 
lot of work under the hood, so 

00:44:39.462 --> 00:44:43.987
we instrumented all of the 
browser points where async any 

00:44:44.175 --> 00:44:48.453
emerges, the timers and rafts 
and promises.  We work closely 

00:44:48.454 --> 00:44:52.190
with the team and we track all 
the asynchronous execution hooks

00:44:52.397 --> 00:44:56.234
 so that we can from the 
entirety of the program 

00:44:56.235 --> 00:45:00.099
execution way to the beginning 
-- back to the beginning of the 

00:45:00.100 --> 00:45:04.281
page load.  In order to pull it 
off and do it efficiently at 

00:45:04.409 --> 00:45:07.209
scale, we needed to do some 
work, because we were really 

00:45:07.210 --> 00:45:10.097
driven to flip the switch on 
this feature making it from 

00:45:10.098 --> 00:45:13.494
something that was like an often
 checked box in the corner to 

00:45:13.495 --> 00:45:15.806
something that everyone should 
just get for free all the time. 

00:45:16.869 --> 00:45:20.788
 there's no reason to collect, 
you know, expensive snapshots 

00:45:22.828 --> 00:45:27.086
from the VM, replay execution or
 like switching into another 

00:45:27.571 --> 00:45:31.231
tool.  What this really means is
 stopping at any point of your 

00:45:31.650 --> 00:45:34.971
program execution shows you the 
complete asynchronous history of

00:45:35.107 --> 00:45:39.649
 how you got there.  It's right 
there at your fingertips. 

00:45:42.984 --> 00:45:46.421
 Okay. cool.  What does this 
actually enable?  I'm going to 

00:45:46.422 --> 00:45:49.738
show you.  I have three new 
features I'm going to show to 

00:45:50.056 --> 00:45:56.044
you, continue to point, inline 
breakpoints and step into async.

00:45:57.587 --> 00:45:59.960
 to do that, we come back to the
 same demos. 

00:46:06.145 --> 00:46:11.882
 The synchronous one.  Place a 
breakpoint here on line 8, and 

00:46:11.883 --> 00:46:16.013
we're just going to start the 
execution.  We pause.  going to 

00:46:16.014 --> 00:46:19.939
hit step over, because I want to
 work my way down, result, print

00:46:20.079 --> 00:46:23.509
 the result, okay?  At this 
point I can inspect the result. 

00:46:23.826 --> 00:46:32.682
 Okay.   Perfect.  This is a 
common debugging scenario.   it 

00:46:32.683 --> 00:46:36.427
over to the asynchronous world. 
 So here I'll place the 

00:46:37.009 --> 00:46:43.216
breakpoint, I'll run, pause, and
 now I step over. get a step 

00:46:43.484 --> 00:46:49.118
over, and this time all of this 
work is asynchronous, but we're 

00:46:49.119 --> 00:46:53.720
still able to use the nice 
convenience of stepover.  We 

00:46:53.721 --> 00:46:57.412
made that a synchronous 
debugging experience feel like 

00:46:57.413 --> 00:47:04.993
it was synchronous.   step over,
 so it works great with sync 

00:47:04.994 --> 00:47:10.307
code and with 088 sync, but we 
often do this a lot of times, 

00:47:10.308 --> 00:47:13.183
either you step over or you'll 
be like, you know what?  I'm 

00:47:13.184 --> 00:47:16.971
here on this log.   line, and I 
want to jump down to this.  I 

00:47:16.972 --> 00:47:21.721
set a breakpoint right now and 
play execution, you know, but it

00:47:22.023 --> 00:47:24.893
 happens a lot.  We wanted to 
make sure there was a bit more 

00:47:24.894 --> 00:47:28.703
of a convenient shortcut for 
this, so that's continued to 

00:47:28.855 --> 00:47:32.093
point.  Now if you're paused.   
down the command key or control 

00:47:32.267 --> 00:47:35.731
key, and we're going to 
highlight in blue a few 

00:47:36.115 --> 00:47:37.906
destinations inside this 
function that are available for 

00:47:37.907 --> 00:47:42.317
you to just jump to.  So when 
you click on one of these 

00:47:42.491 --> 00:47:45.834
destinations, we're going to 
allow the execution to go 

00:47:45.835 --> 00:47:48.483
forward and pause you right 
there.  So I'll do that.  I'll 

00:47:48.620 --> 00:47:53.383
just click on this print.  And 
we just let the execution go 

00:47:53.999 --> 00:47:57.034
forward.  Now I'm paused here, 
and, of course, I can just 

00:47:57.035 --> 00:48:00.557
inspect this response.  It's a 
little bit of a convenience.  

00:48:08.830 --> 00:48:14.675
Now, Promises, okay.  I'll pause
 here and step over and step 

00:48:14.676 --> 00:48:18.086
over again.  What do you think? 
 I mean, how do you feel about 

00:48:18.087 --> 00:48:23.844
me stepping over at this point? 
 It's like, yeah, what happens? 

00:48:24.827 --> 00:48:30.168
 Well, we just jump to right the
 end, and we're now exiting with

00:48:30.314 --> 00:48:35.538
 the return value of a promise. 
 None of this work has happened 

00:48:35.795 --> 00:48:41.233
yet.  what?  I don't know.  So 
we don't have the power of async

00:48:41.351 --> 00:48:46.080
 await and the nice convenience 
of step over, and that's not 

00:48:46.081 --> 00:48:51.738
going to work for us.  We want 
to have this power. we actually 

00:48:51.739 --> 00:48:55.826
thought about this and figured 
maybe there's another way we can

00:48:56.213 --> 00:49:03.963
 do this.  And that led us to 
inline breakpoints.  So now -- 

00:49:03.964 --> 00:49:08.588
what I really want is I really 
just want to pause like here, 

00:49:08.589 --> 00:49:11.390
you know?  I want to see what 
this result is.  I want to pause

00:49:11.513 --> 00:49:16.081
 here, so I'm just going to put 
my breakpoint on 14.  We're 

00:49:16.082 --> 00:49:20.770
going to highlight a few areas 
in that line where we can 

00:49:21.637 --> 00:49:24.510
actually pause.  So, you know 
what?  That spot right there, I 

00:49:24.704 --> 00:49:28.264
turn that on and flip that one 
off, and now when I go forward, 

00:49:28.265 --> 00:49:32.869
I start off there, and I 
continue execution.  Now I pause

00:49:33.245 --> 00:49:37.072
 inside of that function, and 
now I can inspect the result 

00:49:37.073 --> 00:49:39.073
like I want.  That's good. 

00:49:42.465 --> 00:49:47.448
 That works. honest, if you use 
promises as much as I am, you 

00:49:47.449 --> 00:49:50.970
will be doing this all the time.
 again, we're like we could make

00:49:51.111 --> 00:49:56.246
 a little more of a convenience 
function.  We want to pull this 

00:49:56.247 --> 00:50:02.652
off with a single gesture, so 
I'll break.  Now this time I'll 

00:50:02.653 --> 00:50:06.334
hold down control or command 
again, and now there's the blue 

00:50:06.583 --> 00:50:09.192
destinations, but there's green 
destinations.  green means, I'm 

00:50:09.193 --> 00:50:12.345
going to step into this 
asynchronous function, so this 

00:50:12.346 --> 00:50:17.644
time I'm going to step into this
 result, print, result and now I

00:50:17.645 --> 00:50:21.694
 am paused inside of this 
function and I can inspect the 

00:50:21.695 --> 00:50:25.747
result just like that.  So 
single gesture or handling the 

00:50:25.748 --> 00:50:34.017
step into async. right, guys.  
So there's a lot of stuff in the

00:50:34.820 --> 00:50:38.213
 asynchronous debugs, and I'm 
really excited about it.  I know

00:50:38.338 --> 00:50:41.081
 that's a lot.  going to switch 
gears a little bit and talk 

00:50:41.082 --> 00:50:45.199
about performance, okay?  Now 
when we talk to our users and we

00:50:45.335 --> 00:50:49.137
 ask questions like, all right, 
when you guys work on 

00:50:49.285 --> 00:50:54.464
performance, what sort of panels
 do you use?  do you use?  Do 

00:50:54.465 --> 00:51:01.413
you use the profiles panel?  
Time line panel?  Yes.  Good.  

00:51:01.414 --> 00:51:04.970
Network panel?  Yeah.  
Obviously, there's a few things,

00:51:05.155 --> 00:51:10.274
 and admittedly the tools are a 
little distributed.  We're 

00:51:10.591 --> 00:51:13.895
talking about browser 
performance here where the 

00:51:13.896 --> 00:51:17.844
completion of a JavaScript file 
downloading immediately leads to

00:51:17.988 --> 00:51:20.828
 main thread work, and it's 
critical to see that connection.

00:51:21.930 --> 00:51:26.031
 the JavaScript finishes 
executing, the browser 

00:51:26.032 --> 00:51:29.770
calculates the layout and sends 
off pixels to the screen.  This 

00:51:29.771 --> 00:51:34.231
pipeline is very integrated, so 
we knew we needed a single 

00:51:34.232 --> 00:51:37.561
integrated tool to visualize the
 entire picture.  So that's led 

00:51:37.562 --> 00:51:42.737
us to the performance panel.   
So I'm going to show you a 

00:51:42.738 --> 00:51:45.984
little bit of the performance 
panel in action.  To do that, 

00:51:45.985 --> 00:51:49.802
come back to my browser, clear 
those out.  We're just going to 

00:51:49.803 --> 00:51:55.729
look at the home page of Nest 
just for fun.  open the 

00:51:55.906 --> 00:52:01.069
DevTools.  Now, this is the 
performance panel.  have 

00:52:01.070 --> 00:52:05.696
screenshots enabled and that 
seems good.  I want to capture a

00:52:06.751 --> 00:52:09.871
 profile of the reload of the 
page, just the load.  So I'll 

00:52:09.872 --> 00:52:13.006
hit that one button, and what 
we're going to do is capture the

00:52:13.142 --> 00:52:18.100
 entire thing, and we'll stop it
 automatically whether the -- 

00:52:18.101 --> 00:52:22.315
when the page is done loading.  
So I have stuff on the screen.  

00:52:22.316 --> 00:52:25.929
Sure.  Up on the top is a little
 overview and film strip.  I can

00:52:26.003 --> 00:52:29.999
 kind of drag my mouse along and
 see screenshots on the page as 

00:52:30.000 --> 00:52:33.926
it loaded.  Go from just the 
very top bar to a little bit 

00:52:34.051 --> 00:52:38.558
more, these images, the text.  
Like I said, we want to see how 

00:52:38.559 --> 00:52:45.111
this worked, so I'll just zoom 
in on everything up to, yeah, 

00:52:45.112 --> 00:52:47.860
where things start looking good.
  Of course, the page load 

00:52:47.861 --> 00:52:52.871
starts with some network 
requests.  So I'm going to open 

00:52:52.872 --> 00:52:58.335
up network and zoom in.  This is
 our HTML and some JavaScript 

00:52:58.336 --> 00:53:04.912
and some style sheets and so on.
  This JavaScript catches my 

00:53:05.214 --> 00:53:09.442
eye.  So the network connection 
goes out waiting for the bytes, 

00:53:09.443 --> 00:53:14.323
and then it starts downloading 
right here.  So it's 

00:53:14.492 --> 00:53:17.412
downloading, downloading, 
downloading, all right?  What 

00:53:17.413 --> 00:53:21.576
happens when this file stops 
downloading?  Well, stops 

00:53:21.577 --> 00:53:24.583
downloading right here, the main
 thread gets it right here, and 

00:53:24.584 --> 00:53:30.319
then look at this.  thread.  
Evaluate script web components 

00:53:30.583 --> 00:53:33.762
bundle.  Yeah.  makes sense.  
Okay.  So it's a nice connection

00:53:33.955 --> 00:53:38.865
 between the network and the 
main thread, so we see that work

00:53:39.088 --> 00:53:44.118
 there.  just going to look to 
the right.  Okay.  We do it, and

00:53:44.297 --> 00:53:47.313
 some other things happen.  Soon
 enough the browser calculates 

00:53:47.314 --> 00:53:51.653
what it's going to look like.  
recalculates style and layout 

00:53:51.654 --> 00:53:54.851
and paint.  I imagine somewhere 
around here it will shift these 

00:53:54.852 --> 00:53:58.892
pixeling to the screen.  So now 
you can open up the frames 

00:53:59.215 --> 00:54:02.780
track, and in the frames track 
we have just the screenshots of 

00:54:02.781 --> 00:54:05.857
what was happening on the page 
just positioned exactly where it

00:54:06.296 --> 00:54:11.033
 actually happened, so now I can
 see, well, this was when, yeah,

00:54:11.167 --> 00:54:16.104
 we got the top bar with the 
little Nest logo at the top.   

00:54:16.105 --> 00:54:20.931
That's something.  I expected 
more, to be honest. just scroll 

00:54:20.932 --> 00:54:24.662
to the right a little bit.  
Okay, there we go.  now we got 

00:54:24.663 --> 00:54:32.173
these images, and then the text.
  Okay.  The fact that the text 

00:54:32.174 --> 00:54:36.739
took a little more time, it 
leads me to an idea.  I bet that

00:54:37.041 --> 00:54:40.160
 we're dealing with web fonts 
here, and we're waiting for the 

00:54:40.161 --> 00:54:45.909
web fonts to download.   -- 
well, open up network.  Zoom out

00:54:46.112 --> 00:54:50.907
 a little bit. bet you that web 
fonts just finished downloading,

00:54:51.290 --> 00:54:57.793
 so I zoom out and scroll over 
here.  Well, yeah.  I spot them 

00:54:57.969 --> 00:55:03.850
here.  We have at least the WAF 
files of light and regular and 

00:55:03.851 --> 00:55:06.559
these are just completed.  Once 
they completed, then the browser

00:55:06.675 --> 00:55:11.130
 had a chance to recalculate the
 style, which it needs to do, 

00:55:11.131 --> 00:55:14.583
and layout, and then we could 
ship the frame.  We have this 

00:55:14.584 --> 00:55:18.119
nice integrated view from the 
beginnings of network requests 

00:55:18.120 --> 00:55:22.804
to pixels on the screen.  Now, 
some of you who might have used 

00:55:22.805 --> 00:55:27.317
the profile panel to do 
JavaScript development, I want 

00:55:27.318 --> 00:55:30.698
to orient you with what we have 
here.  My collapse again is the 

00:55:30.929 --> 00:55:34.078
network.  On the main thread 
we're dealing with just over 

00:55:34.079 --> 00:55:39.408
time what is happening.  you 
look for what consumed the most 

00:55:39.409 --> 00:55:44.130
time at an aggregate view, 
right?  So we zoom out and open 

00:55:44.131 --> 00:55:48.420
up the bottom and the bottom up 
view.  The bottom up view is a 

00:55:48.421 --> 00:55:52.588
summary of everything that took 
time sorted by its own 

00:55:53.341 --> 00:55:55.936
self-time.  Here we can see, 
well, there was some JavaScript 

00:55:55.937 --> 00:55:59.726
on the page that took a little 
bit of time.  The function E, 

00:56:00.483 --> 00:56:04.267
yeah, not so -- he was a little 
slow, I guess, and R also not so

00:56:04.933 --> 00:56:08.557
 fast.  So E and R, watch 
yourself.  The other important 

00:56:08.558 --> 00:56:12.128
thing is you see this in 
context.  The browser was doing 

00:56:12.129 --> 00:56:15.924
a bunch of other work, right?  
It was compiling scripts and 

00:56:15.925 --> 00:56:19.719
laying it out and recalculates 
style.  You get to understand 

00:56:19.720 --> 00:56:22.868
that maybe E isn't so bad after 
all.  Maybe I need to make sure 

00:56:22.869 --> 00:56:26.154
I need to recalculate style a 
little less or lay things out 

00:56:26.155 --> 00:56:33.849
less or make those take less 
time.  Pro tip, fewer down 

00:56:33.850 --> 00:56:39.411
elements will help this one.  
Anyways, that's a good, quick 

00:56:39.412 --> 00:56:44.520
look at the performance panel.  
We hope you dig it.   did that. 

00:56:45.232 --> 00:56:49.648
 The fastest code in the 
browser, we're talking about 

00:56:49.882 --> 00:56:53.579
profiles, right?  The fastest 
code is the code that never even

00:56:54.058 --> 00:56:58.081
 runs, and better yet, the 
fastest code is the code that 

00:56:58.082 --> 00:57:02.728
isn't even downloaded.  So we're
 thinking about that and 

00:57:03.297 --> 00:57:05.313
wondering, what if we could 
provide you with a better view 

00:57:05.314 --> 00:57:08.598
of what is actually being used 
in the page?  That's led us to 

00:57:08.599 --> 00:57:11.898
the coverage profiler.  I'm 
going to give you a short video 

00:57:11.899 --> 00:57:17.836
of how this worked.  All right. 
 a little app that I made, and 

00:57:17.837 --> 00:57:21.778
we're going to scroll down to 
the bottom and open up inside 

00:57:21.779 --> 00:57:24.952
the drawers menu, the coverage 
panel.  At this point, we can 

00:57:24.953 --> 00:57:27.538
just hit record and start 
collecting data.  We're going to

00:57:27.738 --> 00:57:31.944
 get instant data, especially 
from our CSS, because we know 

00:57:31.945 --> 00:57:34.643
what's applying to the page 
right now.  Here we actually 

00:57:34.996 --> 00:57:38.545
see, you know, all of the 
selectors, and which selectors 

00:57:38.546 --> 00:57:44.083
have already matched the page.  
 that haven't are in red.  Now, 

00:57:44.084 --> 00:57:47.751
select focus, there's no 
drop-down focused.  Let's try 

00:57:47.752 --> 00:57:53.798
it.  We're going to click in and
 hit tab, and that red ruler 

00:57:53.799 --> 00:57:56.703
went to green.  Instant, live 
updates here over in the 

00:57:56.704 --> 00:58:01.229
coverage panel. JavaScript is 
also available now.  This is the

00:58:01.545 --> 00:58:06.160
 JavaScript file.  Half of it is
 unused, which isn't great.  We 

00:58:06.600 --> 00:58:12.006
look down, and if there's a get 
trips function, it's not 

00:58:12.135 --> 00:58:16.454
executed.  It feels like it 
should be.  All right?  Well, we

00:58:16.455 --> 00:58:19.555
 could just try it out.  We're 
going to select a schedule and 

00:58:19.556 --> 00:58:26.808
go from San Francisco down here 
to Mountainview, and yeah.  All 

00:58:28.510 --> 00:58:32.746
right.  Drop down the 50% unused
 to just 10% unused, which is 

00:58:32.975 --> 00:58:35.732
good.  You're making good use of
 all the bytes.  So the coverage

00:58:37.365 --> 00:58:40.856
 profiler gives you this sort of
 insight.  Armed with this data 

00:58:40.857 --> 00:58:46.400
you can go to town.  The red, 
unused bytes, they are not your 

00:58:46.534 --> 00:58:50.227
friend.  They are not your 
user's friend either.  Don't 

00:58:50.228 --> 00:58:58.419
send users red bytes.  Nobody 
likes them.  Check it out, the 

00:58:58.420 --> 00:59:04.066
coverage profiler.  Then again 
-- thanks, thanks.  Then again, 

00:59:04.067 --> 00:59:08.508
sometimes all the bytes that 
you're running on a page are, 

00:59:08.509 --> 00:59:15.739
you know, not necessarily yours.
  They're someone else's and 

00:59:16.038 --> 00:59:19.551
third-party code.  When you see 
a big waterfall -- a network 

00:59:19.552 --> 00:59:24.336
waterfall of a big site, you're 
like, a lot of stuff going on.  

00:59:24.678 --> 00:59:28.154
this?  This is, you know, a 
challenge.  You should know 

00:59:28.155 --> 00:59:32.161
exactly what's happening on the 
site and who it is.  So it's all

00:59:32.636 --> 00:59:35.656
 about attribution.  We thought 
about this, and we have a new 

00:59:35.657 --> 00:59:40.056
feature to though you.  Try this
 out in Chrome Canary now, and 

00:59:40.578 --> 00:59:43.789
it's third-party attribution.  
command palette is a great place

00:59:43.790 --> 00:59:47.485
 to turn this on.  Command, 
shift, P and type in third-party

00:59:47.834 --> 00:59:52.159
 and type in badges.  Flip this 
on.  Once you have this on, you 

00:59:52.160 --> 00:59:55.080
go over to something like the 
network panel.  Now next to the 

00:59:55.081 --> 01:00:00.390
network requests, we throw a 
little badge next to it.  So 

01:00:00.391 --> 01:00:03.529
next to the file name we say 
something like DC.  When you 

01:00:03.530 --> 01:00:09.954
click on DC, it's DoubleClick.  
 GA badge.  That's Google 

01:00:10.101 --> 01:00:13.675
Analytics.  We're doing this for
 a lot of different third-party 

01:00:13.804 --> 01:00:18.453
code.  Ads, analytics, tracking,
 all sorts of stuff.  This is 

01:00:18.454 --> 01:00:21.885
available in other places, too, 
so in the console you have logs 

01:00:22.743 --> 01:00:26.291
or errors and you're like who is
 this coming from?  VM script I 

01:00:26.292 --> 01:00:29.894
don't know.  That doesn't tell 
me much.  We tag it there too 

01:00:29.895 --> 01:00:32.706
and put the badges in and find 
out.  Also over in the time line

01:00:32.885 --> 01:00:37.089
 you can take that bottom-up 
view and group it by product and

01:00:37.250 --> 01:00:40.131
 see, okay, it looks like 
they're spending a lot of time 

01:00:40.132 --> 01:00:48.418
on my main thread.  It's cool, 
yeah.   That is good.  All 

01:00:48.538 --> 01:00:53.348
right.  So let me come back 
here.  Yeah, it's good.  We got 

01:00:53.349 --> 01:00:59.543
a good amount of data in here.  
 over 1400 different projects, 

01:00:59.674 --> 01:01:03.433
products, and that means over 
5,000 domains that we're keeping

01:01:03.651 --> 01:01:09.406
 track of and showing.  The data
 is just kind of built in there,

01:01:09.665 --> 01:01:13.369
 but we have a link report 
mismatch.  anything looks fishy 

01:01:13.370 --> 01:01:16.702
to you, click it and report it 
to us.  to make sure the data is

01:01:17.586 --> 01:01:23.517
 super useful to you and as 
accurate as we can be.  We 

01:01:23.518 --> 01:01:26.636
covered debugging and 
performance insights, but 

01:01:26.783 --> 01:01:29.587
there's other key actions in the
 work flow, and we added some 

01:01:29.933 --> 01:01:32.657
features there.  I think you'll 
like them.  Some good stuff.  

01:01:32.793 --> 01:01:37.419
one, cookie editing.  You can 
view cookies for a while and not

01:01:37.702 --> 01:01:41.634
 edit cookies.  I know you're 
excited about this one, yes.  a 

01:01:41.635 --> 01:01:44.577
long time coming.  We have 
cookie editing, and we're good 

01:01:45.093 --> 01:01:53.597
now.  Okay, okay.  Next one is a
 good one.  Change tracking. 

01:01:53.598 --> 01:01:57.628
often you get this case, right? 
 You're editing the CSS and 

01:01:57.629 --> 01:02:01.626
tweaking something.  You make a 
bunch of changes.  At this point

01:02:01.766 --> 01:02:06.434
 you have it to where you want 
it to look like.  You lost track

01:02:06.702 --> 01:02:09.911
 of the changes you made so down
 in the drawer you can open it 

01:02:10.107 --> 01:02:13.827
up.  We give you a dif of all 
the changes you made file by 

01:02:13.828 --> 01:02:15.828
file.  Yeah.  Thanks. 

01:02:17.991 --> 01:02:23.979
  experiment as of today.  We'll
 be turning it on in Canary by 

01:02:23.980 --> 01:02:29.520
defaults Monday.  let's do that.
  Okay, good.  All right.  

01:02:29.679 --> 01:02:34.826
Screenshots.  yeah.  Check this 
out.  So we're looking at the 

01:02:34.827 --> 01:02:37.590
Google store, right?  You want 
to take a screenshot of the 

01:02:37.723 --> 01:02:42.099
page.  We use that command 
power, command, shift P and type

01:02:42.213 --> 01:02:48.683
 in s the screenshot and 
captures it and we can open it 

01:02:48.684 --> 01:02:51.951
up, boom, easy.  It's good and 
it's been there for a little 

01:02:51.952 --> 01:02:55.605
bit.  I can do better.  We're 
going to open up the device 

01:02:55.819 --> 01:02:58.797
menu, and we can do the same 
thing there.  What I like to do 

01:02:58.798 --> 01:03:02.419
is I like to turn on the device 
frame and get that nice art 

01:03:02.569 --> 01:03:05.300
around it.  Then you capture a 
screenshot, and you have that 

01:03:05.301 --> 01:03:08.855
good look.  It looks good in 
presentations, puppies and dogs 

01:03:09.012 --> 01:03:14.032
are alley impressed with that.  
them.  There's one more that I 

01:03:14.033 --> 01:03:19.166
like even more.  The full-size 
screenshot where you get the 

01:03:19.167 --> 01:03:25.388
full page, capture it and now 
single ping, full resolution. 

01:03:30.054 --> 01:03:34.207
 Yeah.  I'm right there with 
you.  I'm right there with you. 

01:03:35.170 --> 01:03:42.204
 All right.  There's one more.  
I had to sneak it in. resolving.

01:03:42.205 --> 01:03:45.644
  Sometimes you put a breakpoint
 on a page and change it around,

01:03:45.645 --> 01:03:48.583
 and all of a sudden it's not on
 the line you meant for it to be

01:03:48.709 --> 01:03:52.684
 on, right?  That's kind of a 
pain.  we'll do that here.  I 

01:03:52.685 --> 01:03:56.401
place this breakpoint and put it
 on -- put the break points on 

01:03:56.402 --> 01:04:00.534
construct select.  Now I go in 
my editor and move things around

01:04:00.714 --> 01:04:04.698
 and adding a log.  A comeback 
that's there, but whether I 

01:04:05.077 --> 01:04:08.410
refresh, it's in the first run 
function, different things, and 

01:04:08.411 --> 01:04:15.892
it's not where I left it.  No. 
right.  Now, you'll see this 

01:04:15.893 --> 01:04:19.442
Canary, beta, and it's refresh. 
 keep the position.  We track 

01:04:19.443 --> 01:04:21.917
where that was, and even if you 
change things around a little 

01:04:22.075 --> 01:04:26.505
bit, we make sure that the 
breakpoint stays on the same 

01:04:26.506 --> 01:04:30.402
line.  All right.  Yeah, it's 
good.  Not going to work all the

01:04:30.706 --> 01:04:34.501
 time.  If you completely change
 things, we'll lose track, but 

01:04:34.656 --> 01:04:38.723
we're doing our best.  I wanted 
to share with you one of my 

01:04:38.724 --> 01:04:42.632
favorite parts here.  It's good.
 the past year and a half, 

01:04:42.633 --> 01:04:47.765
personally I've been working on 
the Lighthouse Project.  is 

01:04:47.766 --> 01:04:50.007
great and gives you insight into
 what's happening and 

01:04:50.008 --> 01:04:53.767
improvements to make, right?  
It's available as a Chrome 

01:04:54.078 --> 01:04:58.706
extension, command line app, a 
node module.  Access it in a 

01:04:58.707 --> 01:05:05.404
variety of ways, but we knew 
there was value in having it 

01:05:05.405 --> 01:05:09.644
integrated into the work flow.  
This is what it looks like with 

01:05:09.645 --> 01:05:12.999
the DevTools presentation.  We 
look at core experiments as an 

01:05:13.670 --> 01:05:18.914
example.  Pop open the DevTools,
 and we go to the audits panel. 

01:05:19.078 --> 01:05:22.701
 It's refreshed a little bit.  
We go down and run an audit.  We

01:05:22.702 --> 01:05:27.480
 do the full audit of 
everything.   point we emulate a

01:05:28.495 --> 01:05:33.034
 next 5X and throttling network 
and CPU to slow it down a little

01:05:33.215 --> 01:05:36.074
 more like a phone.  We're 
looking at a lot of things.  

01:05:36.075 --> 01:05:38.646
looking at the load performance 
and capturing a bunch of 

01:05:38.647 --> 01:05:45.010
different metrics.  at things 
like accessible, how much it is 

01:05:45.011 --> 01:05:48.212
and all that, and then we get 
the report in the DevTools.  A 

01:05:48.213 --> 01:05:54.672
few things going on with this 
site.  went outside, and not so 

01:05:54.673 --> 01:05:59.154
good for them.  The HPS had some
 good stuff.  In the performance

01:05:59.271 --> 01:06:02.541
 section, a flip strip and some 
of the high-quality metrics you 

01:06:02.542 --> 01:06:06.875
might have heard about.  First 
interactive and how those line 

01:06:06.876 --> 01:06:10.735
up against the screenshots and 
other things like image 

01:06:10.918 --> 01:06:14.258
optimization.  We give you an 
idea how much value you get out 

01:06:14.259 --> 01:06:17.144
of the recommendations.  You 
don't have to guess and be like,

01:06:17.900 --> 01:06:22.012
 it wasn't that impactful.  
Thank you, thank you.  I'll show

01:06:22.168 --> 01:06:28.982
 WRUNWRUN -- one more thing 
while I'm at it.  I ran it on 

01:06:28.983 --> 01:06:33.643
the Google home page.  The 
accessibility results were 

01:06:33.766 --> 01:06:37.267
interesting.  we're in DevTools,
 when you cover over the Node 

01:06:37.401 --> 01:06:40.351
results, we highlight it over 
there.  You can click through 

01:06:40.352 --> 01:06:43.351
and inspect it.  Do it again 
with a Klor-Con TRAS, so now a 

01:06:43.352 --> 01:06:46.992
few things it looks like in the 
fooder that don't hit the 

01:06:46.993 --> 01:06:53.117
Klor-Con TRAS  -- con TRAGS mark
 and we see the actual elements 

01:06:53.118 --> 01:06:58.770
we talk about.  The integration 
between the insight of 

01:06:58.771 --> 01:07:00.771
Lighthouse and DevTools together
 brings a lot 

01:07:03.497 --> 01:07:09.560
of power.  I've saved a 
developer favorite until  

01:07:09.821 --> 01:07:12.919
browsers, they enable you to 
create automated tools that can 

01:07:12.920 --> 01:07:15.726
run in a variety of different 
settings.  People do a lot of 

01:07:15.727 --> 01:07:19.680
things with this.  Text 
extraction, screenshots and 

01:07:19.681 --> 01:07:23.638
performance testing, security 
testing, unit testing.  Everyone

01:07:24.234 --> 01:07:27.747
 here, raise your hand if you 
use a Headless browser of some 

01:07:27.876 --> 01:07:32.071
sort. of course.  A lot of 
things.  WOOECH seen  -- we've 

01:07:32.072 --> 01:07:37.203
seen this happening for the 
longest time, us on the Chrome 

01:07:37.204 --> 01:07:40.044
team want to provide a 
contribution to that scenarios 

01:07:40.045 --> 01:07:43.826
and those work flows, and so 
today we're happy to officially 

01:07:44.578 --> 01:07:47.696
announce the availability of 
Chrome Headless.  Chrome 

01:07:47.697 --> 01:07:54.007
Headless works great on all iOS
s, Linux and Mac and windows and

01:07:54.331 --> 01:08:01.797
 works great in windows and 
Chrome 60.  This enables quite a

01:08:01.983 --> 01:08:05.613
 bit.  There's a lot to come.   
for instance, is on the way and 

01:08:05.614 --> 01:08:08.411
we're excited about this.  Right
 now things are a little 

01:08:08.900 --> 01:08:12.652
low-level, and they will be 
higher level APIs coming soon.  

01:08:12.653 --> 01:08:16.982
There's a big, flour richinging 
developer community around 

01:08:16.983 --> 01:08:21.058
chrome Headless right now, and 
it's prime API, which is the 

01:08:21.059 --> 01:08:23.265
DevTools protocol.  If you're 
curious about this, check it 

01:08:23.403 --> 01:08:28.600
out.  There's a great blog post 
from Eric about Chrome Headless 

01:08:28.601 --> 01:08:31.631
to get you started with how it 
works and all the tools 

01:08:31.632 --> 01:08:37.707
available right now.  All right.
 thing.  No JS.  Who here 

01:08:37.708 --> 01:08:43.609
develops with Node?  Yeah, yeah.
 too.  There's a lot going on.  

01:08:43.610 --> 01:08:50.419
Last year -- a year ago here we 
announced that Node.js could be 

01:08:50.420 --> 01:08:54.124
debugged and profiled with 
DevTools.  We announced a pull 

01:08:54.125 --> 01:08:57.744
request that enable them -- pull
 request is submitted when 

01:08:57.745 --> 01:09:00.457
you're like, we'll announce 
that, because that's what we 

01:09:00.647 --> 01:09:05.272
got.  Soon enough, yes, the poor
 request got merged into a 

01:09:05.537 --> 01:09:09.638
Node.js, and it shipped.  No 
we're in a great place.  A lot 

01:09:09.639 --> 01:09:14.114
of us developers spend time in 
the browser and in Node, and we 

01:09:14.115 --> 01:09:18.066
want to make sure that the 
experience in debugs Node is 

01:09:18.605 --> 01:09:21.376
good.  I want to show you 
improvements to the work flow we

01:09:21.693 --> 01:09:25.161
 made and to contrast it to 
debugging two years ago is good.

01:09:26.400 --> 01:09:32.024
 so good.  All right.  I'll show
 you a little bit of stuff here.

01:09:32.025 --> 01:09:38.139
  Okay.  Now, I'm actually just 
going to be -- this is how I 

01:09:38.140 --> 01:09:42.900
debug Lighthouse when I work on 
it.  I'll bring back open this 

01:09:43.085 --> 01:09:47.878
browser.  This one.  Yeah, 
great.  Now, I'll do something 

01:09:47.879 --> 01:09:54.134
like this, this command, right? 
 and I'm going to run this 

01:09:54.135 --> 01:09:58.392
script but anyways, the 
important thing is inspect 

01:09:58.583 --> 01:10:01.115
brick.  It says I'm going to 
start inspection, and I want to 

01:10:01.116 --> 01:10:05.386
put a breakpoint on the very 
beginning, okay?  Otherwise I'm 

01:10:05.387 --> 01:10:11.453
running Lighthouse.  First thing
 is I hit enter.  The URL pops 

01:10:11.591 --> 01:10:15.674
out and you see this and you're 
like okay, well, I guess I'll 

01:10:15.838 --> 01:10:19.182
copy and paste it.  You 
certainly can, but there are 

01:10:19.183 --> 01:10:25.475
better ways.  One better way is 
we can type in about inspect, 

01:10:25.476 --> 01:10:29.869
and we see this panel.  And the 
best one here that I recommend 

01:10:30.135 --> 01:10:34.811
you clicking instead of this 
shiny-looking guy is the 

01:10:35.328 --> 01:10:39.340
dedicated DevTools for Node.   
this window is going to be 

01:10:39.341 --> 01:10:44.064
dedicated to just Node, so you 
can see immediately we broke on 

01:10:44.065 --> 01:10:47.074
the program execution, and I 
again, have all the power I 

01:10:47.651 --> 01:10:53.129
need.  I can continue to step in
 and just go crazy.  So that's 

01:10:53.370 --> 01:11:00.540
good.  We can do a little bit 
better.  All right.  Now, at 

01:11:00.541 --> 01:11:04.277
this time I'm thinking it would 
be good if I didn't have to 

01:11:04.403 --> 01:11:09.470
remember that URL about inspect 
every single time, and this 

01:11:09.471 --> 01:11:12.723
functionality was available to 
me in a bit more of an immediate

01:11:13.011 --> 01:11:18.360
 place where I spend a lot of my
 time.  Now I'm going to open up

01:11:18.895 --> 01:11:26.405
 DevTools.  When I run this 
command again, I don't know if 

01:11:26.406 --> 01:11:29.517
you spotted this.  Right up next
 to the inspect element icon is 

01:11:29.518 --> 01:11:35.535
a new one.  A little green Node 
icon that snuck in there right 

01:11:35.675 --> 01:11:41.847
there.  We detected a debugle 
node.  If you want to debug 

01:11:42.052 --> 01:11:50.207
that, we have you right here.   
pop open that same dedicated 

01:11:50.208 --> 01:11:53.834
DevTools for Node window.  The 
cool thing about this dedicated 

01:11:54.026 --> 01:11:57.871
window, I love this, is you 
know, okay this works, and I'm 

01:11:57.872 --> 01:12:01.760
debugging and do what I need.  
Okay, I found a bug, so now I 

01:12:01.761 --> 01:12:08.640
need to, you know, fix a bug.  
I'm changing things. need to 

01:12:08.641 --> 01:12:13.629
like run it again, and so run it
 again.  Because we have that 

01:12:13.630 --> 01:12:17.760
dedicated window, it's like, 
hey, I'm right here.  I got you.

01:12:17.761 --> 01:12:21.168
  I'll pop right back open, so 
it's always there and 

01:12:21.584 --> 01:12:25.201
connecting.  Even if you have to
 restart Node, you have one 

01:12:25.202 --> 01:12:29.459
single window and that will take
 care of you the entire time. 

01:12:30.627 --> 01:12:36.246
right.  So I have to stop there.
  There we go.  Okay.  You guys 

01:12:36.247 --> 01:12:41.311
have made it.  We've covered a 
lot.  We've covered a bunch of 

01:12:41.312 --> 01:12:45.702
new features in DevTools from 
that great new experience with 

01:12:45.703 --> 01:12:48.745
object previews, the 
autocomplete in the console and 

01:12:48.746 --> 01:12:52.784
all the asynchronous debugging 
goodies and performance panel 

01:12:53.116 --> 01:12:57.540
coverage, third-party 
attribution, Chrome Headless, 

01:12:57.726 --> 01:13:00.642
Node.  All sorts of good stuff. 
 If you like this kind of thing,

01:13:00.931 --> 01:13:06.632
 follow us on Twitter.  Great 
docs updated regularly, and if 

01:13:06.633 --> 01:13:10.907
ever you have bugs, we 
definitely want to know.  If you

01:13:10.908 --> 01:13:13.465
 have future requests, we want 
to know.  Any feedback about 

01:13:13.466 --> 01:13:19.512
your work flow and the things 
that work for you.  N

01:13:19.770 --> 01:13:23.316
ewbug.CR.com is where you can 
find us.  That's it from me. 

01:13:23.317 --> 01:13:26.929
guys very much.  I appreciate 
it.  Applause )

01:13:41.336 --> 01:13:46.571
 Our next session will be past, 
presents and future of Machine 

01:13:46.572 --> 01:13:50.819
Learning moderated by Diane 
green.  This session will begin 

01:13:50.820 --> 01:13:52.820
at 

01:13:56.198 --> 01:13:58.198
9:30. 

01:33:56.902 --> 01:34:03.125
 Please well an amazing panel of
 AI experts moderated by Diane 

01:34:04.145 --> 01:34:06.145
Greene. 

01:34:17.790 --> 01:34:22.080
 Hi, everybody. Diane Greene, 
and I run Google's phenomenal 

01:34:23.199 --> 01:34:28.398
Cloud.  I'm on the board of 
alpha bit and I'm proceeded to 

01:34:28.399 --> 01:34:35.530
be here moderating this panel of
 just absolute leading experts, 

01:34:36.217 --> 01:34:39.653
leading researchers and experts 
in artificial intelligence and 

01:34:39.654 --> 01:34:45.293
Machine Learning.  We're going 
to structure our panel talking 

01:34:45.294 --> 01:34:49.619
about past, present and future, 
closing with some personal 

01:34:50.422 --> 01:34:55.175
reflections on the industry and 
our careers.  Before I do that, 

01:34:55.176 --> 01:35:02.233
I'm just going to quickly 
introduce everybody.  First is 

01:35:02.234 --> 01:35:07.713
Francois B  and she's the 
principal scientist at Google 

01:35:07.714 --> 01:35:10.698
and leading of speech 
recognition at Google.  

01:35:10.699 --> 01:35:12.699
everybody

01:35:15.833 --> 01:35:17.833
 uses. 

01:35:21.046 --> 01:35:28.733
 is Lee, and she's the chief 
scientist of Google Cloud 

01:35:28.900 --> 01:35:33.286
bringing AI/ML to companies all 
over the world.  Also head of 

01:35:33.501 --> 01:35:41.402
Stanford's AI lab and inventor 
of the I am NAJ net challenge 

01:35:41.403 --> 01:35:44.056
that contributed to developments
 and she's a champion of 

01:35:44.057 --> 01:35:52.689
S.T.E.M.AI and the founder of AI
 for All.  Next is Fernando V

01:35:54.254 --> 01:36:00.306
iegas, and she's a computational
 designer.  She focused on the 

01:36:00.307 --> 01:36:03.936
scientific and collaborative 
aspects of information 

01:36:04.071 --> 01:36:08.605
visualization, co-leads the big 
picture data visualization 

01:36:09.341 --> 01:36:14.601
group.  She's part of Google 
Brain and known for her 

01:36:15.365 --> 01:36:18.433
visualization-based artwork, 
which is part of the permanent 

01:36:18.620 --> 01:36:22.161
collection of the museum of 
modern art in New York. 

01:36:26.858 --> 01:36:32.427
 And then let me introduce DAF 
fee Color, who is the chief 

01:36:32.428 --> 01:36:37.716
computing officer at calico 
labs, which is a part of 

01:36:38.109 --> 01:36:43.272
alphabit, working to give people
 longer and healthier lives.  

01:36:43.273 --> 01:36:46.313
She spent 18 years at Stanford

01:36:50.660 --> 01:36:55.432
 and led the AI group there and 
co-founded Coser

01:37:01.399 --> 01:37:08.735
a for open online courses.  
Daphne was one of the "Time" 

01:37:09.064 --> 01:37:13.694
magazine's most influential 
people in 2012 and won a 

01:37:13.695 --> 01:37:16.696
MacArthur award and won a prize 
for computing, she's a member of

01:37:16.697 --> 01:37:21.465
 the academies of arts and 
sciences and engineering.  are 

01:37:21.466 --> 01:37:23.466
just some of the proof points of
 her excellence. 

01:37:29.886 --> 01:37:35.403
 So we'll start with a 
historical perspective, and 

01:37:35.529 --> 01:37:39.611
Daphne, as one of the most 
prominent and prolific authors 

01:37:39.612 --> 01:37:44.282
of Machine Learning research 
papers, can you give us your 

01:37:44.283 --> 01:37:49.751
perspective on how we've 
transitioned to Deep Learning?  

01:37:49.752 --> 01:37:56.443
I think the Deep Learning rev 
NUGS  -- revolution is exciting 

01:37:56.444 --> 01:38:00.578
enabler in so many real world 
problems, but that revolution 

01:38:00.579 --> 01:38:04.218
came out of an outgrowth of a 
lot of Machine Learning research

01:38:04.354 --> 01:38:08.330
 that led up to it.  So prior to
 Deep Learning, there were 

01:38:08.331 --> 01:38:12.924
probably about 10 or 15 years of
 very hard work in developing 

01:38:12.925 --> 01:38:18.703
models that were maybe more 
handcrafted that required a lot 

01:38:18.704 --> 01:38:20.721
more thought and prior 
knowledge.  You really had to 

01:38:20.722 --> 01:38:24.704
think through the specifics of 
the model and how it relates to 

01:38:24.705 --> 01:38:27.844
the domain.  When you don't have
 a lot of data, you have to 

01:38:27.974 --> 01:38:32.149
replace that with a lot of human
 intuition on how the model 

01:38:32.150 --> 01:38:35.865
ought to be constructed.  As 
we've gotten more and more data 

01:38:35.866 --> 01:38:40.738
in certain domains, text and 
images being, I think, the two 

01:38:40.739 --> 01:38:44.828
primary examples and speech, of 
course, as well, we've started 

01:38:44.829 --> 01:38:51.132
to replace a lot of that need 
for human insight with more and 

01:38:51.133 --> 01:38:58.492
more data that counterbalances 
that.  techniques developed in 

01:38:58.493 --> 01:39:03.028
those 10 to 15 years are still 
pivotal today, both in the 

01:39:03.029 --> 01:39:06.564
methods themselves.  Those 
optimization algorithms 

01:39:06.565 --> 01:39:10.409
developed over the last 10 to 15
 years are still a key component

01:39:10.700 --> 01:39:14.172
 of what enables Deep Learning 
to be successful.  I think that 

01:39:14.173 --> 01:39:17.808
while we might like to think 
that Big Data is at this point 

01:39:17.809 --> 01:39:21.189
the solution to everything, it's
 a solution in certain domain 

01:39:21.363 --> 01:39:26.715
areas, but in others we still 
are unfortunately are in the 

01:39:26.716 --> 01:39:33.221
medium or sometimes small data 
regime.  There's still a need 

01:39:33.222 --> 01:39:38.574
for balancing human intuition 
about the domain with the data 

01:39:38.575 --> 01:39:40.850
we're acquiring and coming up w
ith a model that incorporates 

01:39:40.851 --> 01:39:49.006
the best of both.  you.   also 
get your perspective?  You run 

01:39:49.007 --> 01:39:54.758
the Stanford AI Lab, and your 
image network was Seminole, and 

01:39:54.759 --> 01:39:58.783
now you -- now you look at 
bringing AI to every company in 

01:39:58.784 --> 01:40:02.770
the world.  What is going on 
with this transition?  Right.  

01:40:02.771 --> 01:40:06.169
Thank you, Diane.  Just a little
 bit of a historical perspective

01:40:07.038 --> 01:40:11.142
 that AI in all sciences of 
human civilization is actually a

01:40:11.418 --> 01:40:16.580
 very young field.  We're about 
60 years old.  The very question

01:40:16.924 --> 01:40:21.911
 of the quest for intelligence 
in my opinion is what's at the 

01:40:21.912 --> 01:40:26.038
root of AI's inspiration, and 
that dates back since the 

01:40:26.039 --> 01:40:30.963
beginning of the dawn of 
civilization.  So about 60 years

01:40:30.964 --> 01:40:35.957
 ago when machines started to 
compute and calculate at that 

01:40:35.958 --> 01:40:42.225
time very simple arithmetics, 
already thinkers like Alan 

01:40:42.358 --> 01:40:46.697
TURing challenged humanity with 
the question, can machines 

01:40:46.838 --> 01:40:51.210
think?  Can machines have 
intelligence?  About 60 years 

01:40:51.211 --> 01:40:56.610
ago leading scientist like 
minimum SKI and John McCarthy 

01:40:57.141 --> 01:41:00.032
get together and really jump 
started a field that today we 

01:41:00.193 --> 01:41:04.790
know as AI.  The AI that the 
founding fathers saw was very 

01:41:04.791 --> 01:41:11.684
different technically 60 years 
ago.  It was the same core 

01:41:11.833 --> 01:41:17.609
dreams, which is making machines
 to learn, to reason, to think, 

01:41:18.029 --> 01:41:24.308
to perceive, to speak, to 
communicate.  AI has gone 

01:41:24.309 --> 01:41:28.401
through several waves of 
technical development from first

01:41:29.334 --> 01:41:33.440
 order logic to expert systems 
to the early waves of Machine 

01:41:33.441 --> 01:41:37.832
Learning to today the Deep 
Learning revolution.  I would 

01:41:37.833 --> 01:41:44.372
say the past 60 years I call it 
the individual AI or AI 

01:41:44.549 --> 01:41:50.157
individual.  It's the 60 years 
where as a field we laid the 

01:41:50.158 --> 01:41:55.342
foundation of the questions we 
ask, the subfields that are 

01:41:55.343 --> 01:42:01.081
essential to AI's quest like 
robotics, computer vision, 

01:42:01.082 --> 01:42:06.210
Natural Language processing, 
speech processing, and so on.  

01:42:06.211 --> 01:42:11.510
the way we measure the progress,
 understand our data, and 

01:42:11.511 --> 01:42:18.528
discovery the tool sets.  So 
around 2010, around that time 

01:42:18.529 --> 01:42:23.883
thanks to the convergence of the
 maturing of statistical Machine

01:42:23.884 --> 01:42:29.436
 Learning tools, the convergence
 of Big Data brought to you by 

01:42:29.437 --> 01:42:33.640
the Internet and by the sensors 
and the convergence of 

01:42:33.891 --> 01:42:38.316
computing, the Morse law carried
 us to much better hardware.  

01:42:38.317 --> 01:42:44.113
three pillars came together and 
lifted AI from the individual 

01:42:44.114 --> 01:42:52.420
stage into what I call the inviv
 stage.  It's where AI is making

01:42:52.634 --> 01:42:57.348
 a real impact to the world.  
It's just the beginning.  Every 

01:42:57.349 --> 01:43:02.120
single industry that is at Cloud
 and Google we see is going 

01:43:02.121 --> 01:43:07.824
through a transformation because
 of data, because of AI and 

01:43:07.825 --> 01:43:13.594
Machine Learning.  This is what 
I see as the historical moment 

01:43:13.595 --> 01:43:20.309
that AI is going to impact and 
TRNZ  transform the field.  I 

01:43:20.310 --> 01:43:23.314
want to say it's just the 
beginning.   and the 

01:43:23.315 --> 01:43:28.071
technologies we have developed 
in the field of AI is really the

01:43:28.290 --> 01:43:36.674
 first few drops of water in the
 vast ocean of what AI can do.  

01:43:36.675 --> 01:43:41.260
We cannot overpromise this, but 
there should be tremendous 

01:43:41.261 --> 01:43:48.359
excitement that we can do a lot 
of more work to make this A I

01:43:51.949 --> 01:43:59.105
 invivo happen.  Companies put 
VISHT YAL renditions in the 

01:43:59.358 --> 01:44:04.027
Cloud, and they use AI to do 
things nobody ever thought was 

01:44:04.330 --> 01:44:07.753
possible.  AI is being used 
everywhere.  Not just in the 

01:44:08.426 --> 01:44:12.700
Cloud.  So thank you.  If we 
dive a little deeper, Francois, 

01:44:13.144 --> 01:44:19.279
you've been at the frontier of 
speech recognition, and now in 

01:44:19.280 --> 01:44:22.814
application speech recognition 
is becoming almost common place.

01:44:24.228 --> 01:44:27.912
 take us through that 
transition?  Certainly.  I j

01:44:28.233 --> 01:44:32.110
oined Google about 12 years ago,
 and a bunch of us came with 

01:44:32.111 --> 01:44:36.426
this vision of doing something 
useful and fun with speech 

01:44:36.741 --> 01:44:39.628
recognition.  Speech recognition
 had been around for quite a 

01:44:39.878 --> 01:44:43.775
while.  All of us had some 
background in the field, but we 

01:44:43.934 --> 01:44:47.927
we wanted to do something fun, 
and that was hard because speech

01:44:48.636 --> 01:44:53.724
 wasn't the quality it is now.  
 started with fairly limited 

01:44:53.725 --> 01:44:57.257
products where the task of 
recognizing what the person says

01:44:57.508 --> 01:45:01.626
 wasn't too, too complicated to 
where we're just trying to push 

01:45:01.627 --> 01:45:04.477
the envelope a little bit but 
not too much, right?  We needed 

01:45:04.478 --> 01:45:08.300
to bring it to a place where the
 product was successful enough 

01:45:08.301 --> 01:45:12.636
that people would want to use 
our applications and then we 

01:45:12.637 --> 01:45:17.409
could start, you know, folding 
data into the models and keep it

01:45:17.589 --> 01:45:22.681
 writing from there.  So we 
build what we called Google 4.1.

01:45:22.682 --> 01:45:25.326
  I don't remember if any of you
 remember that, but it was a 

01:45:25.327 --> 01:45:28.345
phone application.  You would 
call a number, and it said say 

01:45:28.346 --> 01:45:31.116
what city and state.  You would 
say what you were interested in,

01:45:31.382 --> 01:45:33.968
 and then it would ask you about
 the business that you were 

01:45:33.969 --> 01:45:36.248
interested in.  You would say 
that name, and then it would 

01:45:36.249 --> 01:45:41.909
offer to connect you to that in 
that city and state.  So, again,

01:45:42.045 --> 01:45:46.585
 picture that.  It's 12 years 
ago, and there's no iPhone, no 

01:45:46.586 --> 01:45:49.734
Android phone, right?  All you 
have is that flip phone that you

01:45:50.068 --> 01:45:55.126
 put to your ear.  So it was 
very basic.  Fortunately, 

01:45:55.127 --> 01:45:58.822
leadership at Google was real 
visionary about this technology 

01:45:58.823 --> 01:46:06.586
and really encouraged us to push
 the boundaries as much as we 

01:46:06.846 --> 01:46:10.059
could.  successful with the 
first application, but then the 

01:46:10.060 --> 01:46:13.651
iPhone and Android phone came, a
nd everything changed obviously.

01:46:13.652 --> 01:46:16.408
  Now there was visual feedback,
 so we started to think about 

01:46:16.409 --> 01:46:20.833
other applications and that was 
voice search, so Google search 

01:46:20.834 --> 01:46:26.200
by voice, and we started to do 
dictation and having a little 

01:46:26.201 --> 01:46:30.187
microphone in every possible 
entry point in your phone so you

01:46:30.188 --> 01:46:34.422
 could do everything with your 
voice.  More recently we've 

01:46:34.423 --> 01:46:39.327
moved into trying to enable 
speech recognition within your 

01:46:39.328 --> 01:46:46.667
home with devices like Google 
Home because people are asking 

01:46:46.668 --> 01:46:50.903
for more and more tasks to be 
fulfilled through voice, that 

01:46:50.904 --> 01:46:55.551
was a really good entry point 
into the whole Assistant story 

01:46:55.552 --> 01:46:59.230
where instead of just enabling 
you to do very small things with

01:46:59.607 --> 01:47:03.512
 your voice, now you can ask 
questions and phrase them in 

01:47:03.513 --> 01:47:07.635
Natural Language and you can get
 really Google to be your 

01:47:07.636 --> 01:47:11.851
Assistant without the 
cumbersome, you know, physical 

01:47:11.970 --> 01:47:15.762
keyboard input.  Thank you. 

01:47:19.807 --> 01:47:21.807
  you said you want Democrat

01:47:24.349 --> 01:47:27.155
ized data Ville

01:47:31.314 --> 01:47:35.477
 visualization.  WLAR the needs 
for that and how has that 

01:47:35.655 --> 01:47:41.402
evolved?  Yeah.  So I've started
 -- I started working in data 

01:47:41.403 --> 01:47:43.802
visualization over ten years 
ago, and when I did, it was much

01:47:43.930 --> 01:47:49.087
 different.  It was much harder 
to do data visualization. 

01:47:49.088 --> 01:47:53.448
machines were not nearly as 
good.  And there wasn't as much 

01:47:53.449 --> 01:47:57.769
data out there that was publicly
 available.  That started to 

01:47:58.087 --> 01:48:03.645
change, and now we find 
ourselves in an environment 

01:48:03.646 --> 01:48:07.505
where people are interacting 
with data visualization sort of 

01:48:07.982 --> 01:48:10.998
everywhere.  It's really 
exciting.  It's been amazing to 

01:48:11.292 --> 01:48:15.319
see like journalism take on data
 visualization and talk about 

01:48:16.805 --> 01:48:20.208
really complex stories.  When 
they talk about statistics, we 

01:48:20.209 --> 01:48:23.446
always joke that data 
visualization is sort of the 

01:48:23.597 --> 01:48:27.273
gateway drug to statistics.  
like you're doing statistics 

01:48:27.274 --> 01:48:32.018
without even noticing that you 
are because we're just visually 

01:48:32.019 --> 01:48:36.712
so good at picking up patterns 
and outliers and so forth.  Data

01:48:37.377 --> 01:48:45.855
 visualization has been on this 
trend of becoming more Democrati

01:48:46.012 --> 01:48:50.905
zed, and I really believe that 
people have -- we have been 

01:48:50.906 --> 01:48:55.032
increasing people's ability to 
take in data and numerous see, 

01:48:55.033 --> 01:49:00.204
and so data visualization has 
had a role to play in that.  In 

01:49:00.205 --> 01:49:06.869
terms of AI, it's been really 
interesting because we saw a 

01:49:06.870 --> 01:49:11.002
major jump when, you know, Jeff 
Hinton and colleagues proposed 

01:49:11.003 --> 01:49:19.139
the first sort of blockbuster 
visualization for AI.  TSNE.  a 

01:49:19.140 --> 01:49:24.054
technique that allows you -- one
 of the big challenges with AI 

01:49:24.055 --> 01:49:29.549
and Machine Learning, these are 
systems that work in very high 

01:49:29.550 --> 01:49:34.509
dimension al spaces, and those 
are hard for us at humans to 

01:49:34.619 --> 01:49:38.179
understand.  So visualization is
 one way to sort of peak and try

01:49:38.342 --> 01:49:42.250
 to understand what's happening 
in these systems.  These 

01:49:43.449 --> 01:49:48.147
techniques, such as the one that
 Jeff Hinton developed, allows 

01:49:48.148 --> 01:49:52.070
us to sort of understand how 
things are clustering together, 

01:49:52.071 --> 01:49:56.004
what are the relationships 
between different concepts, and 

01:49:56.005 --> 01:50:00.317
how these systems are sort of 
resolving the data that they're 

01:50:00.533 --> 01:50:04.796
ingesting?  I would say that's a
 major -- those major problem 

01:50:04.797 --> 01:50:08.743
and the beginning as she was 
saying, I feel like we're in the

01:50:09.019 --> 01:50:13.844
 beginning of this relationship 
between how visualization can 

01:50:13.976 --> 01:50:15.976
help AI. 

01:50:17.285 --> 01:50:21.238
 Thank you.  we're going to 
switch to a slightly more 

01:50:21.239 --> 01:50:25.674
technical set of answers to 
what's going on in the present. 

01:50:26.724 --> 01:50:29.353
 Francois, maybe we'll start 
with you in talking about speech

01:50:30.148 --> 01:50:34.882
 recognition technologies and 
what have the transitions been, 

01:50:34.883 --> 01:50:38.703
and what were the challenges and
 what are they today?  How have 

01:50:38.704 --> 01:50:45.032
the challenges evolved?  Yeah, 
sure.   is very complex, right? 

01:50:45.322 --> 01:50:50.600
 It's difficult to recognize 
what you're saying. one of us 

01:50:50.601 --> 01:50:55.793
has a different voice and 
accent.  We speak in different 

01:50:55.794 --> 01:51:00.374
environments, so all of that 
contributes to the richness of 

01:51:00.375 --> 01:51:04.005
the voice.  I think mostly for 
that reason, speech recognition 

01:51:04.006 --> 01:51:07.541
has always been based on Machine
 Learning.  hasn't been or not 

01:51:07.542 --> 01:51:11.381
much of an earlier phase that 
wasn't Machine Learning-based.  

01:51:11.382 --> 01:51:14.041
It's just that the type of 
Machine Learning has been 

01:51:14.042 --> 01:51:19.136
evolving over time.  We kept 
making progress in the field for

01:51:19.488 --> 01:51:25.256
 the last three decades, but I 
think one inflection point has 

01:51:25.257 --> 01:51:30.710
been the adoption of neural 
networks.  has happened maybe 

01:51:30.711 --> 01:51:39.845
eight years ago or so.  Maybe a 
little bit less.  But the early 

01:51:39.846 --> 01:51:42.922
research in speech recognition 
using neural networks happened a

01:51:43.368 --> 01:51:46.842
 long time before.  There was a 
lot of activity in the field.  a

01:51:47.346 --> 01:51:52.178
 lot of promising results, 
however, there wasn't a compute 

01:51:52.179 --> 01:51:58.720
support to really make it 
happen.  So no networks were 

01:51:58.721 --> 01:52:02.766
abandoned for a while, and 
speech recognition kept 

01:52:02.767 --> 01:52:06.572
improving with basic methods and
 whatnot.  And then when we 

01:52:07.443 --> 01:52:12.073
started to really involve deep 
neural nets, it was bigger from 

01:52:12.074 --> 01:52:16.674
an engineering viewpoint.  We 
had to deal with latency issues,

01:52:16.825 --> 01:52:21.344
 with size and training 
capabilities and so on.  when 

01:52:21.345 --> 01:52:25.119
deep neural networks became a 
reality when we launched them 

01:52:25.120 --> 01:52:28.347
whether we really had them in 
production, that's opened the 

01:52:28.348 --> 01:52:32.351
path to a whole bunch of other 
improvements, because now we 

01:52:32.622 --> 01:52:36.599
have the capability of having 
that complex machinery there 

01:52:36.600 --> 01:52:41.413
behind the technology, and so we
 could move very quickly from 

01:52:41.414 --> 01:52:46.118
one neural architecture to the 
next. we started to look into 

01:52:46.255 --> 01:52:50.348
recurrent neural networks such 
as STM, and we looked into con

01:52:53.792 --> 01:53:00.535
 VOE LUGSal NURT networks so CTC
 based and modeling and new 

01:53:00.536 --> 01:53:05.023
implementations coming out.  
Google Home we have the neural 

01:53:05.024 --> 01:53:10.141
beam forming.   happening is 
that the move into the neural 

01:53:10.142 --> 01:53:16.129
network space has opened these 
incredible capabilities for 

01:53:16.130 --> 01:53:20.485
innovating the core technology 
that powers our systems and 

01:53:21.333 --> 01:53:25.121
keeps optimizing and, you know, 
giving all of you in whichever 

01:53:25.360 --> 01:53:30.602
language you're speaking the 
best possible accuracy we can.  

01:53:30.748 --> 01:53:35.853
Okay.  Neural nets for speech 
recognition to neural nets for 

01:53:35.999 --> 01:53:40.542
extending lives and making us 
healthier.  A fairly open-ended 

01:53:40.543 --> 01:53:46.187
question for you, Daphne.  Why 
did Calico need one of the top 

01:53:46.188 --> 01:53:52.629
researchers in the world in 
molecular biology and Machine 

01:53:52.630 --> 01:53:58.515
Learning as the chief computing 
officer?  doing over there?  

01:53:58.516 --> 01:54:01.932
Many you may not know of Calico 
because we've been under the 

01:54:02.104 --> 01:54:08.274
radar.  Calico is one of the 
Alphabit companies out of 

01:54:08.411 --> 01:54:11.162
Google.  It aims to understand 
the problem of aging and to help

01:54:11.309 --> 01:54:13.947
 people live longer and 
healthier lives.  When you look 

01:54:13.948 --> 01:54:18.046
at aging, you realize that it's 
actually the single largest risk

01:54:18.604 --> 01:54:22.330
 factor for death.  I know that 
seems kind of funny when you 

01:54:22.331 --> 01:54:26.678
think about it, but it's true 
for almost every disease that 

01:54:26.679 --> 01:54:30.664
happens after the age of 40.  As
 you grow older, year after year

01:54:31.928 --> 01:54:35.523
 the risk for that disease 
increases exponentially every 

01:54:35.658 --> 01:54:40.511
year, whether it be diabetes or 
cardiovascular disease or 

01:54:40.887 --> 01:54:45.153
cancer.  All of these increase 
expo NENTSally.  No one knows 

01:54:45.154 --> 01:54:48.112
where that is.  Why after year 
of life after the age of 40 puts

01:54:48.864 --> 01:54:52.531
 us at an increased risk for 
each disease?  In order to 

01:54:52.989 --> 01:54:59.171
understand that, we really need 
to  study the biological system 

01:54:59.172 --> 01:55:01.777
that is exhibit aging at the 
molecular level all the way 

01:55:01.778 --> 01:55:04.898
through the systems level and 
figure out what it is that's 

01:55:05.130 --> 01:55:09.496
causing us to age, because, you 
know, I don't think we'll live 

01:55:09.769 --> 01:55:13.533
forever.  Maybe we can live 
longer and healthier by 

01:55:13.921 --> 01:55:19.507
interventions.  One of our 
earliest scientists Cynthia 

01:55:19.508 --> 01:55:25.835
Kenyan who came over to Calico 
showed with a single gene 

01:55:26.024 --> 01:55:29.383
mutation, you can extend the 
life span by 30% to 50%, and not

01:55:29.518 --> 01:55:33.926
 only does the worm live longer,
 but like a healthy, young worm 

01:55:33.927 --> 01:55:39.770
in terms of reproductsive health
 and movement and so on.  Can we

01:55:39.955 --> 01:55:44.938
 do something like that to allow
 humans to live healthier?  That

01:55:44.939 --> 01:55:48.999
 would be really cool, but in 
order to do that we have 

01:55:49.000 --> 01:55:53.183
understanding we still need to 
gain.  In order to do that, we 

01:55:53.184 --> 01:55:58.572
need to gather data about all 
the age.  Yeast, worms, flies, 

01:55:58.840 --> 01:56:02.570
mice, humans age.  What do we 
all have in common at the 

01:56:02.721 --> 01:56:05.476
molecular level?  Fortunately, 
scientists have been able over 

01:56:05.477 --> 01:56:10.142
the last 20 years to devise a 
whole slew of measurement 

01:56:10.143 --> 01:56:14.524
modalites that allow us to get 
an understanding or at least 

01:56:14.869 --> 01:56:21.135
data regarding systems as they 
age.  That includes things like 

01:56:21.136 --> 01:56:25.055
sequencing and microfluiditytics
 at the low level and images all

01:56:25.225 --> 01:56:29.175
 the way through to things like 
track devices that track 

01:56:29.176 --> 01:56:33.639
movement and allow us wearables 
to track movement and see how 

01:56:34.042 --> 01:56:39.170
systems change as they age.  No 
human being has the capability 

01:56:39.171 --> 01:56:43.416
to put together data at these 
different modalities that range 

01:56:43.417 --> 01:56:48.314
all the way from subcellular to 
entire human populations.  All 

01:56:48.315 --> 01:56:55.053
these different modalities that 
include DNA and RNA and mass 

01:56:55.054 --> 01:57:00.778
spec and imaging and so on, all 
the time scales from the 

01:57:01.083 --> 01:57:05.687
subcellular scales to the scales
 from an entire human life span,

01:57:05.821 --> 01:57:10.103
 how do you put them together 
for a coherent picture of what 

01:57:10.104 --> 01:57:12.845
makes us age and what 
interventions are likely to be 

01:57:12.846 --> 01:57:15.086
the most successful to slow the 
aging process and making it 

01:57:15.852 --> 01:57:19.815
better.   ability to interpret 
the data and make use of it 

01:57:19.816 --> 01:57:24.212
really requires a true 
partnership between the 

01:57:24.213 --> 01:57:28.869
scientists who are collecting 
and getting untuitions about 

01:57:28.870 --> 01:57:33.213
these processes and the Machine 
Learning people who can help 

01:57:33.214 --> 01:57:36.205
construct models that can 
synthesize and put it together. 

01:57:36.514 --> 01:57:41.421
 Neither of these communities 
can be successful on its own.  I

01:57:41.422 --> 01:57:45.220
 was one of the fortunate people
 that entered the field in its 

01:57:45.221 --> 01:57:49.325
very early stages.  I work in 
the field of computation 

01:57:49.326 --> 01:57:53.603
alibiology since the early 2000
s.  You can say that I'm native 

01:57:53.604 --> 01:57:56.219
in the language of Machine 
Learning.  You can say that I 

01:57:56.220 --> 01:58:01.882
have a fluency in the biological
 language, and as such it allows

01:58:02.027 --> 01:58:06.391
 me to work the scientists at 
Calico to create a true 

01:58:06.392 --> 01:58:08.776
partnership between the two 
disciplines and build models 

01:58:08.777 --> 01:58:12.367
that as I mentioned earlier are 
so important to combine the best

01:58:12.487 --> 01:58:18.334
 of both worlds, the best of Big
 Data but the best of human 

01:58:18.513 --> 01:58:21.380
intuition.  Biology is so 
complex that I don't think that 

01:58:21.381 --> 01:58:25.302
even with amounts of data we're 
collecting today we'll be able 

01:58:25.303 --> 01:58:29.470
to reconstruct biology deNovo 
from data alone.  You need the 

01:58:29.862 --> 01:58:33.871
data, but you also new the 
intuition of the best 

01:58:34.361 --> 01:58:38.143
scientists.  By work together at
 a place like Calico, we can get

01:58:38.275 --> 01:58:43.370
 some of those insights as well 
as some of enormous amounts of 

01:58:43.371 --> 01:58:46.121
data currently collected and 
I'll come back to that later to 

01:58:46.267 --> 01:58:50.525
really construct and end up 
understanding the biology of 

01:58:50.526 --> 01:58:53.875
aging and at the same time try 
and predict which interventions 

01:58:57.989 --> 01:59:02.339
 Thank you, DAF fee.  I feel we 
should pause.  A lot of profound

01:59:02.630 --> 01:59:04.630
 thinking. 

01:59:05.838 --> 01:59:11.039
 Hang onto your hats.  We jump 
back to vision and Faye Faye, 

01:59:11.040 --> 01:59:14.116
just the other day you were 
quoted in tech crunch saying 

01:59:14.117 --> 01:59:20.160
vision is the killer app of AI. 
 So what mean by that?  What 

01:59:20.161 --> 01:59:24.881
does it mean to Democrat
Democratize AI and what does 

01:59:24.882 --> 01:59:30.032
that have to do with the Cloud? 
 I was trying to be provocative.

01:59:30.033 --> 01:59:34.738
  The quote is while many people
 are asking for the killer app 

01:59:34.739 --> 01:59:37.925
of computer vision, I would say 
the killer vision is the killer 

01:59:37.926 --> 01:59:43.449
app of AI.  So let me qualify 
that for -- by two reasons.  The

01:59:43.717 --> 01:59:50.113
 first reason comes from nature.
  540 million years ago a 

01:59:50.114 --> 01:59:56.136
remarkable event happened in 
animal evolution.  For some odd 

01:59:56.958 --> 02:00:03.289
reason, the number of animal 
species went from very few 

02:00:03.290 --> 02:00:08.199
simple species to an explosive 
increase of the variety and the 

02:00:08.333 --> 02:00:14.079
types of animals.  It was 
considered the big Ben of 

02:00:14.080 --> 02:00:20.188
evolution or the cam BREE YA 
explosion, and zoologists were 

02:00:20.189 --> 02:00:25.285
puzzled for many decades why it 
happened.  Recently a very 

02:00:25.624 --> 02:00:33.068
convincing and FROM  prominent 
theory conjectured it was the 

02:00:33.069 --> 02:00:37.071
concept of eyes.  When eyes 
first developed in animals, 

02:00:37.072 --> 02:00:42.055
suddenly the animals -- the 
animal life became proactive.  

02:00:42.056 --> 02:00:46.442
predators and preys and the 
whole evolution just changed.  

02:00:46.612 --> 02:00:51.443
540 million years later, humans 
are the most intelligent visual 

02:00:51.558 --> 02:00:55.662
animals.  In fact, nature 
devoted half the her brain for 

02:00:55.663 --> 02:01:01.019
visual processing because of its
 importance.  So that's one 

02:01:01.020 --> 02:01:05.420
thread of one evidence.  Another
 piece of evidence comes from 

02:01:05.421 --> 02:01:09.816
technology and the world we live
 in.  If you look at our 

02:01:09.817 --> 02:01:14.180
Internet today where data is 
awash, YouTube alone seeing 

02:01:15.344 --> 02:01:21.669
300-plus hours of videos 
uploaded every single minute.  

02:01:21.670 --> 02:01:26.441
It's estimated more than 80% of 
the entire cyberspace is in some

02:01:26.660 --> 02:01:33.506
 kind of pixel form.  Look at 
the sensors.  The biggest data 

02:01:33.507 --> 02:01:38.506
form that sensors capture are in
 some kind of images, whether 

02:01:38.507 --> 02:01:42.098
it's visible spectrum or a 
spectrum outside of visible 

02:01:42.386 --> 02:01:47.182
lights.  From biology labs to 
hospitals, from self-driving 

02:01:47.183 --> 02:01:52.041
cars to surveillance cameras, 
everywhere the pixel format, 

02:01:52.042 --> 02:01:56.954
data and pixel format is the 
most invaluable data for 

02:01:56.955 --> 02:02:01.480
consumers and companies.  At 
Cloud I had the chance to talk 

02:02:01.481 --> 02:02:08.683
to a lot of customers.  I have 
been all about the demand of 

02:02:08.684 --> 02:02:13.449
image recognition and video 
processing and analytics.  It's 

02:02:13.450 --> 02:02:17.709
an exciting time for vision.  
Similar to speech recognition 

02:02:17.710 --> 02:02:23.912
thanks to the progress of deep 
neural net.   really taken off 

02:02:23.913 --> 02:02:29.082
as a field and has made a lot of
 progress.  In the past ten 

02:02:29.793 --> 02:02:34.594
years, between 2010 and -- seven
 years to 2017, I would say that

02:02:34.944 --> 02:02:38.612
 the biggest progress in 
computer vision is the basic 

02:02:38.613 --> 02:02:43.154
perception tasks.  Object 
recognition, image tagging, 

02:02:43.155 --> 02:02:47.605
object detection. already have 
-- you see products coming out 

02:02:47.606 --> 02:02:51.313
of it.   and pedestrian 
detection in self-driving cars 

02:02:51.442 --> 02:02:56.799
and all this.  The next phasing 
investing in computer vision 

02:02:56.957 --> 02:03:01.703
technology, in my opinion, is 
really vision plus X.  Vision is

02:03:02.360 --> 02:03:06.422
 so fundamental in 
communications and language, how

02:03:06.990 --> 02:03:15.071
 do we speak stories?  How do we
 tag and index videos so the 

02:03:15.072 --> 02:03:18.049
connection and interplay between
 vision and language is going to

02:03:18.050 --> 02:03:24.582
 be extremely interesting.  Then
 vision in biological sciences, 

02:03:25.397 --> 02:03:28.393
whether we're -- the through-put
 of data coming from biology and

02:03:28.895 --> 02:03:35.688
 health care and medicine in 
vision form is phenomenal.  Be 

02:03:35.689 --> 02:03:40.022
it radiology or laboratories, 
and I think there's a huge 

02:03:40.289 --> 02:03:45.224
opportunity for vision to play. 
 last example I want to also 

02:03:45.225 --> 02:03:50.754
give is robotics.  Vision 
speaking as a researcher, there 

02:03:50.755 --> 02:03:55.915
is a lot of excitement now 
happening in the area of vision 

02:03:56.628 --> 02:04:03.125
and robotics.  We've been doing 
robotics as long as AI existed 

02:04:03.784 --> 02:04:06.729
and robots are still not where 
they are.  To a large extent, 

02:04:06.730 --> 02:04:11.603
it's because of its primitive 
perception system, and I think 

02:04:11.604 --> 02:04:17.138
vision can play a huge role.  So
 basically I do think vision is 

02:04:17.139 --> 02:04:22.067
one of the most important 
elements of machine intelligence

02:04:23.053 --> 02:04:26.419
 and also for the transformation
 of enterprise and companie

02:04:30.415 --> 02:04:32.415
 Thank you. 

02:04:36.578 --> 02:04:41.336
 I need to be careful because 
we're running out of time.  So 

02:04:42.653 --> 02:04:47.453
Fernando, how does vision and 
visualization help Machine 

02:04:47.454 --> 02:04:50.370
Learning and maybe to save time,
 you could from that go into 

02:04:50.371 --> 02:04:54.770
where you see the future of 
where you can take the 

02:04:54.771 --> 02:05:00.677
visualization.  Sure.  To 
piggyback on her answer here, we

02:05:00.678 --> 02:05:04.633
 have this amazingly 
sophisticated vision system.  We

02:05:04.777 --> 02:05:06.886
 might as well use it to 
understand what these machines 

02:05:07.092 --> 02:05:11.596
are doing, right?  So Machine 
Learning runs on tons of data, 

02:05:11.597 --> 02:05:16.970
tons of statistics and 
probability.  It turns out the 

02:05:16.971 --> 02:05:20.279
data visualization can be a 
secret weapon in trying to 

02:05:20.449 --> 02:05:23.391
understand what's happening, and
 why do we care?  We should care

02:05:23.576 --> 02:05:28.746
 because of a bunch of different
 reasons.  One is interpretive 

02:05:29.006 --> 02:05:32.427
ability.  Can you interpret 
what's coming out of your 

02:05:32.819 --> 02:05:36.361
models?  Second is debugability.
 understanding what's happening 

02:05:36.362 --> 02:05:40.577
with your models will allow you 
to then debug them.   finally 

02:05:40.578 --> 02:05:44.390
there's also education.  Visual
ization is already playing an 

02:05:44.391 --> 02:05:47.658
important role when it comes to 
education about Machine 

02:05:47.804 --> 02:05:52.221
Learning.  I also have a final 
education piece there that I'm 

02:05:52.222 --> 02:05:57.020
very excited about, which is 
when we start to understand 

02:05:57.143 --> 02:05:59.845
better, when we use 
visualization to understand 

02:05:59.846 --> 02:06:02.865
better what the systems are 
doing, then can we learn from 

02:06:03.187 --> 02:06:08.695
them?  Can we become better 
professionals, better domain 

02:06:08.696 --> 02:06:12.159
experts in whatever?  If I'm a 
doctor, if I'm an architect, 

02:06:12.262 --> 02:06:17.281
whatever it is, how can I learn 
from these very specific systems

02:06:17.694 --> 02:06:21.951
 and then be better as a 
professional?  Another thing 

02:06:22.094 --> 02:06:25.454
about visualization that I think
 is really powerful and really 

02:06:25.455 --> 02:06:30.160
important to keep track of is 
the fact by using visualization,

02:06:30.288 --> 02:06:35.235
 we're always keeping the human 
in the loop.  Right?  And that 

02:06:35.236 --> 02:06:40.055
is huge, and as we build 
autonomous system, we want to 

02:06:40.056 --> 02:06:43.375
make sure they're behaving well,
 so visualization is helpful 

02:06:43.565 --> 02:06:47.284
there.  I want to tell you a 
quick antidote about a moment, 

02:06:47.444 --> 02:06:50.377
scientific moment when 
visualization showed us 

02:06:50.378 --> 02:06:54.362
something we didn't know before 
about a Machine Learning system.

02:06:56.135 --> 02:07:00.950
 year Google deployed its 
multi-lingual translate system, 

02:07:01.138 --> 02:07:04.611
right?  It was great.  It was 
this really exciting moment of 

02:07:04.612 --> 02:07:08.219
just putting a ton of different 
languages in one system and 

02:07:08.804 --> 02:07:13.692
having the system somehow figure
 out how to translate from every

02:07:13.693 --> 02:07:20.363
 pair of languages.  The extra 
BOENT  bonus it did what was 

02:07:20.364 --> 02:07:22.364
called zero shot translation 
where it was able to translate 

02:07:23.024 --> 02:07:27.134
from pairs of languages they had
 not necessarily seen before.  

02:07:27.135 --> 02:07:30.815
So one of the fundamental 
research questions that the 

02:07:30.816 --> 02:07:37.984
experts doing those systems had 
was how is the system resolving 

02:07:37.985 --> 02:07:43.998
this space of multi-lingual 
data?  Is this system creating 

02:07:43.999 --> 02:07:47.376
something that looks kind of 
like, you know, a model over 

02:07:47.377 --> 02:07:50.917
here for English and a model 
over here for Spanish and 

02:07:50.918 --> 02:07:55.619
another one for Portuguese?  the
 system doing something very 

02:07:55.620 --> 02:07:59.261
different where it kind of mixes
 everything up in the same 

02:07:59.983 --> 02:08:04.198
spaces, and it's maybe learning 
something about the semantics 

02:08:04.199 --> 02:08:08.205
and the meaning of words and not
 necessarily what language it 

02:08:08.206 --> 02:08:11.612
comes from other what language 
I'm translating to.  So what we 

02:08:11.613 --> 02:08:15.710
did is we built a visualization 
to look into this.  The really 

02:08:15.898 --> 02:08:21.399
excited point was when we 
started seeing that we visualize

02:08:21.796 --> 02:08:26.828
visualized sentences translated 
into different languages.  The 

02:08:26.829 --> 02:08:31.125
really exciting thing is whether
 we saw clusters of sentences in

02:08:31.296 --> 02:08:34.666
 these different languages show 
up together.  So if I have a 

02:08:34.667 --> 02:08:38.269
sentence that I'm translating 
from Portuguese to Spanish to 

02:08:38.410 --> 02:08:43.427
English and vice versa, all of 
those representations showed up 

02:08:43.428 --> 02:08:45.685
clustered together.  Then 
another sentence here.  With all

02:08:45.879 --> 02:08:49.198
 the clusters of all the 
languages, and so in other 

02:08:49.199 --> 02:08:54.446
words, what did we find out?  We
 found out that the system was 

02:08:54.447 --> 02:08:59.067
not partitioning the space into 
different languages.  The system

02:08:59.304 --> 02:09:04.166
 was coming up with a unique 
representation of those multiple

02:09:04.999 --> 02:09:08.477
 languages.  So in other words, 
we saw the first signs of a 

02:09:08.832 --> 02:09:14.633
universal language of something 
that we call intraLing what.  

02:09:14.796 --> 02:09:17.948
amazing.  It was almost as if we
 had run this multi-lingual 

02:09:17.949 --> 02:09:21.525
system through an MRI, and we're
 like, whoa, these are the 

02:09:21.784 --> 02:09:24.982
results.  The other thing that 
the visualization allowed us to 

02:09:24.983 --> 02:09:29.664
do was to look at neighborhoods 
that didn't look very well 

02:09:29.665 --> 02:09:33.623
resolved where a little language
 was kind of hanging out by 

02:09:34.015 --> 02:09:36.587
itself.  Those were translations
 that were not good and not high

02:09:36.768 --> 02:09:41.425
 quality.  So what that tells us
 is that the geometry of these 

02:09:41.426 --> 02:09:45.502
spaces is meaningful, and if you
 have a neighborhood sort of 

02:09:45.503 --> 02:09:48.730
hanging out in the periphery by 
itself, you might want to look 

02:09:48.731 --> 02:09:52.061
at it and debug your system, 
right?  So these kind of 

02:09:52.825 --> 02:09:57.298
superpowers you can have in 
understanding and making things 

02:09:58.227 --> 02:10:01.819
better, making things work 
better.  And for the future, one

02:10:01.820 --> 02:10:07.891
 of the things I'm really 
excited about is sort of goes 

02:10:07.892 --> 02:10:15.156
hand in hand with something that
 Fefe is a true add vote 

02:10:15.157 --> 02:10:18.898
indicate for is Democratizing 
AI.  Visualization and other 

02:10:19.166 --> 02:10:23.338
techniques, but I truly believe 
the more different kinds of 

02:10:23.480 --> 02:10:27.556
people we bring into the fold of
 ML, the better off we're going 

02:10:27.557 --> 02:10:34.187
to be.  Right now, AI still 
feels very engineering centric, 

02:10:34.188 --> 02:10:37.153
and I'm curious what will happen
 when we bring in designers, 

02:10:38.523 --> 02:10:41.838
UXers, scientists that we're 
bringing in?  What are the 

02:10:41.839 --> 02:10:45.254
different possibilities and what
 are the different solutions 

02:10:45.255 --> 02:10:49.565
that we even thought about that 
we can then start exploring. 

02:10:55.340 --> 02:11:00.125
  I feel like I should ask you 
how is data visual aization 

02:11:00.126 --> 02:11:02.411
going to help speech 
recognition, but I wanted to ask

02:11:02.572 --> 02:11:05.681
 you about as data gets more 
complex, we had all this labeled

02:11:05.965 --> 02:11:10.679
 data for the training models, 
and we do more personalization. 

02:11:10.974 --> 02:11:15.226
 is the technology going, and 
what challenges are you excited 

02:11:15.484 --> 02:11:20.087
about?  It's very interesting.  
Each time we jump into a new 

02:11:20.088 --> 02:11:24.869
problem in speech recognition, 
we really have to focus on it in

02:11:24.997 --> 02:11:29.249
 a sense, you know, when we 
start working on YouTube kits, 

02:11:29.250 --> 02:11:32.875
for example, which was a YouTube
 space for children, we really 

02:11:32.876 --> 02:11:36.744
had to focus on those young 
voices that don't speak the same

02:11:36.883 --> 02:11:41.684
 way we do and don't have the 
same pitch range or same way of 

02:11:41.685 --> 02:11:48.468
chopping words to take this deep
 breath and a burst of speech.  

02:11:48.469 --> 02:11:52.307
We had to focus on it, and we 
found a way to fold back that 

02:11:52.308 --> 02:11:55.429
learning into our generic model 
so that Google Home, for 

02:11:55.611 --> 02:11:59.410
example, would work with your 
children as well as it does with

02:11:59.411 --> 02:12:04.405
 you.  Google Home itself was 
all a new environment where we 

02:12:04.406 --> 02:12:10.860
had to collect new data.  When 
that data is available to you, 

02:12:10.861 --> 02:12:14.280
you can fold it into the models 
and keep training.  The first 

02:12:14.281 --> 02:12:17.546
time you want to launch a Google
 Home device, you don't have it,

02:12:17.658 --> 02:12:21.980
 right?  So we did a lot of 
simulations, taking data, adding

02:12:22.137 --> 02:12:26.017
 noise of different types, doing
 different types of 

02:12:26.018 --> 02:12:30.883
reverberation on the data.  
Indeed, we used massive amounts 

02:12:30.884 --> 02:12:35.891
of data.  We tribed tens of 
thousands of hours of speech and

02:12:36.139 --> 02:12:38.987
 multiply it with the 
simulations.  If you do the 

02:12:39.248 --> 02:12:44.159
math, it averages to something 
like, you know, a handful of 

02:12:44.160 --> 02:12:49.331
speech that we can fold into a 
model.  So just massive amounts.

02:12:49.332 --> 02:12:53.984
  I think it is very interesting
 to think about how that scales 

02:12:53.985 --> 02:12:59.845
to more problems with different 
acoustic characteristics but to 

02:12:59.846 --> 02:13:04.416
different languages.  If I can 
ask you guys how many speak 

02:13:04.417 --> 02:13:08.303
another language than English?  
Right.  see all the hands are 

02:13:09.009 --> 02:13:11.911
raising, so we really want to 
make our technology available to

02:13:12.089 --> 02:13:15.224
 all of you in your own 
language, and if you think of 

02:13:15.417 --> 02:13:20.226
it, it's a massive problem.  How
 do you do that?  Do we build 

02:13:20.227 --> 02:13:23.286
one recognizer that works for 
all of us?  Are we going to do 

02:13:23.287 --> 02:13:27.544
like we do now, one per 
language.  How about dialects, 

02:13:27.665 --> 02:13:31.421
then, and how are we going to do
 it when we have a language 

02:13:31.422 --> 02:13:36.148
that's a fairly small pocket of 
individuals.  So if you ask 

02:13:36.149 --> 02:13:40.503
linguists they will tell you 
that there's 6,000, 7,000 

02:13:40.504 --> 02:13:44.696
languages in the world.  tell 
you that there are about 1,000 

02:13:44.697 --> 02:13:50.918
of them, actually 1342 they say 
that have more than a 100,000 

02:13:51.098 --> 02:13:58.266
speakers.  that's a lot, right? 
 If we want really going into 

02:13:58.267 --> 02:14:01.706
deep internationalization and 
serve all the languages that 

02:14:01.707 --> 02:14:08.899
have big populations on Earth, 
it's going to require a lot of 

02:14:08.900 --> 02:14:11.539
creativity on the Machine 
Learning side to manage to share

02:14:12.936 --> 02:14:17.673
 data among languages known from
 other languages and so on.  

02:14:17.674 --> 02:14:21.088
It's really exciting and there's
 a ton of work to do in that 

02:14:21.345 --> 02:14:29.554
domain.   agree.  It's super 
exciting.  Thank you.  going to 

02:14:29.555 --> 02:14:34.424
go a little over so we have time
 to hear about the future from 

02:14:34.425 --> 02:14:37.448
Faye Faye and Daphne.  Faye 
Faye, what excites you about 

02:14:37.449 --> 02:14:44.292
what's possible going forward?  
 excites me about what's 

02:14:44.293 --> 02:14:48.573
possible going forward, let me 
just say one dimension.  I 

02:14:48.574 --> 02:14:51.737
genuinely believe AI is one of 
the driving forces of the fourth

02:14:52.428 --> 02:14:55.216
 industrial revolution.  It's 
just the beginning, but it has 

02:14:55.217 --> 02:15:01.741
the potential to transform so 
the way humans live, work, 

02:15:02.433 --> 02:15:08.321
communicate, and one favorite 
line I heard from a philosopher 

02:15:08.322 --> 02:15:11.772
is there's no independent 
machine values.  Machine values 

02:15:11.773 --> 02:15:17.212
are human values.  So one thing 
that really excites me is to 

02:15:17.650 --> 02:15:23.469
include the diverse 
technologyists in the field of 

02:15:23.763 --> 02:15:26.976
AI to build the future together.

02:15:30.049 --> 02:15:32.049
 we have that diversity of 
representation in the field of 

02:15:32.226 --> 02:15:35.013
AI technology, we will build the
 technology that is for the 

02:15:35.014 --> 02:15:41.923
entire humanity, not just a 
slice of it.  You have a lot of 

02:15:41.924 --> 02:15:49.347
credibility when you say that.  
And Daphne, the intersection of 

02:15:49.348 --> 02:15:54.114
biology and computing and 
everything else you've done.  

02:15:54.115 --> 02:15:57.447
When I look at the progress that
 Machine Learning has made over 

02:15:57.448 --> 02:16:02.885
the last five to ten years and 
as a long-time AI researcher, if

02:16:03.109 --> 02:16:07.845
 you asked me even five years 
ago, will computers be able to 

02:16:07.846 --> 02:16:13.717
caption images without any kind 
of prior knowledge, just in the 

02:16:13.718 --> 02:16:17.320
same quality a human would, 
maybe in 20 years.  With the 

02:16:17.321 --> 02:16:20.857
work of Faye Faye and others, 
we've been able to reach that 

02:16:20.858 --> 02:16:23.808
milestone way sooner than I 
would have expected.  The reason

02:16:24.017 --> 02:16:30.987
 I move back to biology from 
that is because we hi that knee 

02:16:30.988 --> 02:16:33.630
in the curve in biology.  When 
you look at the current 

02:16:34.002 --> 02:16:38.264
predictions, there was a paper 
published in 2015 called Big 

02:16:38.467 --> 02:16:44.756
Data, astronomical or genomal?  
It looks at the number of human 

02:16:44.946 --> 02:16:47.855
genome sequence, which is a very
 limited part of biological data

02:16:48.341 --> 02:16:51.649
 captured.  You look at the 
historical trend, and that 

02:16:51.650 --> 02:16:54.312
amount doubles every seven 
months, which makes it about 

02:16:54.313 --> 02:16:58.509
twice as fast as Moore's law.  
you look at 2025 and you project

02:16:58.633 --> 02:17:03.865
 that line, the number of human 
genomes sequenced by 2025 will 

02:17:03.866 --> 02:17:06.994
be on a conservative projection 
1 hundred 

02:17:10.556 --> 02:17:14.718
 million and on historical 
trendses with 2 bill Kwon.  

02:17:14.719 --> 02:17:19.642
That's just sequence.  doesn't 
count R and A and whole body 

02:17:19.643 --> 02:17:28.031
images and cellular imaging.  So
 we're at the cusp of the 

02:17:28.032 --> 02:17:30.263
beginning to understands the 
most complex system that we've 

02:17:30.780 --> 02:17:33.814
encountered, which is that of a 
biological system.  What makes 

02:17:33.815 --> 02:17:37.674
us alive?  What forces us to 
die?  So I think with that 

02:17:37.675 --> 02:17:42.661
amount of data and the 
techniques the Machine Learning 

02:17:42.662 --> 02:17:45.104
has developed and will continue 
to develop, we have an 

02:17:45.361 --> 02:17:51.011
opportunity to transform this 
science in this way.  I'm 

02:17:51.012 --> 02:17:54.615
excited to bring them to 
communities together to make 

02:17:54.616 --> 02:17:56.616
that possible.  

02:17:59.755 --> 02:18:05.224
 There's clearly so much more 
that we could sit and listen to 

02:18:05.225 --> 02:18:10.531
here.   a phenomenally 
interesting and inspiring panel.

02:18:12.497 --> 02:18:16.399
 very  Thank you, Diane.  
Terrific. 

02:31:01.267 --> 02:31:03.267
 Good morning, everyone. 

02:31:05.168 --> 02:31:11.198
 Doan cheer us.  Cheer the next 
speakers.  I'm representing the 

02:31:11.199 --> 02:31:13.223
platform on Android and this is

02:31:16.274 --> 02:31:21.288
 Andrey.  We have very special 
speakers.  We're excited about 

02:31:21.289 --> 02:31:26.298
this official announcement of 
Kotlin.  We both love it.  We 

02:31:26.299 --> 02:31:29.928
don't want to take more time 
from the SPEESHGZ of honor, so 

02:31:29.929 --> 02:31:31.929
without further adieu, there 
they are. 

02:31:35.921 --> 02:31:37.921
 Applause )

02:31:44.375 --> 02:31:48.738
    HADI HARIRI:  Hello, 
everyone.  That's nice.  So you 

02:31:48.974 --> 02:31:51.444
know I was thinking the other 
day the first time that I ever 

02:31:51.764 --> 02:31:55.064
did a talk in Kotlin, it was l
ike four and a half years ago, 

02:31:55.065 --> 02:32:01.008
and they gave me a room for 900 
people and 7 people showed up.  

02:32:01.009 --> 02:32:04.111
it's kind of nice to see more of
 you show up today.  Thank you. 

02:32:04.242 --> 02:32:06.242
 Applause )

02:32:12.722 --> 02:32:15.565
    HADI HARIRI:  I've around 30
 minutes, actually a little bit 

02:32:15.716 --> 02:32:20.253
let, 28 minutes to give you a 
whirlwind tour of Kotlin.  I'm 

02:32:20.254 --> 02:32:22.981
not going to cover the entire 
language.  I'm going to show you

02:32:23.208 --> 02:32:27.412
 as much as I possible can and 
how you can use it and where it 

02:32:27.413 --> 02:32:31.657
provides some benefits, okay?   
to do it all with live coding, 

02:32:31.658 --> 02:32:36.286
so if it goes terribly wrong, 
there's a Google video -- a 

02:32:36.287 --> 02:32:39.143
YouTube video of this as well.  
You can watch that.   So we 

02:32:39.144 --> 02:32:43.005
start with something very simple
 you've already seen, data 

02:32:43.745 --> 02:32:49.524
class.  And I'm in a file called
 main, right?  So I create a new

02:32:49.525 --> 02:32:53.973
 type called money, and it has 
an amount of type Nth.  Don't 

02:32:53.974 --> 02:32:59.885
say anything now.  It has a 
currency of type string, okay?  

02:32:59.886 --> 02:33:02.752
And this is both properties, and
 they're going to be read-only 

02:33:02.970 --> 02:33:05.385
properties, so this is something
 that you're already familiar 

02:33:05.583 --> 02:33:08.080
with.  It's essentially a data 
class.  Let's go ahead and 

02:33:08.636 --> 02:33:15.884
compare that to a Java one that 
I have done earlier.  So split 

02:33:16.024 --> 02:33:20.583
vertically.  Let's get the job 
money up.  Let's go down this 

02:33:20.849 --> 02:33:25.732
side.  Java money, so there you 
go.  That's the equivalent of 

02:33:25.733 --> 02:33:32.935
what I just have written, right?
 is a data class that providers 

02:33:33.277 --> 02:33:37.074
two.  They're immutable, so 
they're read-only, and this data

02:33:37.213 --> 02:33:42.410
 mod fire gives me the two 
string.  It gives me the clone, 

02:33:42.411 --> 02:33:47.034
which in Kotlin is called copy. 
 It's doing the equals and the 

02:33:47.035 --> 02:33:50.070
hash code.  That's great, 
brilliant, but why do I need 

02:33:50.762 --> 02:33:54.085
that?  Any good IDE generates 
that for me.  It's true, it 

02:33:54.317 --> 02:33:56.962
does.  The problem is that's 
code you have to maintain.  time

02:33:57.095 --> 02:33:59.774
 you add a new property, you 
have to go back and change that 

02:33:59.922 --> 02:34:03.720
code.  The other issues you have
 is you don't know, in fact, if 

02:34:03.721 --> 02:34:10.597
that code is the standard stuff 
that you're -- that ID has 

02:34:10.598 --> 02:34:13.845
generated for you or you tweaked
 it a little bit, okay?  It's 

02:34:13.846 --> 02:34:16.858
not just about saving on typing 
on the first line.  Right.  Now 

02:34:16.859 --> 02:34:20.555
I go ahead and create a function
 main.  Let's close this guy 

02:34:20.556 --> 02:34:24.632
over here.  And this is like the
 top entry point of Kotlin, so 

02:34:24.633 --> 02:34:28.838
you have a public static void 
main in a class.  You don't need

02:34:28.839 --> 02:34:31.956
 that Kotlin.  In Kotlin you can
 put everything in the top 

02:34:32.083 --> 02:34:38.208
level.  kind of like JavaScript 
in a good way.  You don't have 

02:34:38.209 --> 02:34:42.251
to -- and just I want to 
reiterate.  Every function and 

02:34:42.252 --> 02:34:45.910
everything I show you today I 
add it in the file as a top 

02:34:46.129 --> 02:34:48.427
level thing, but that doesn't 
mean that you don't have any 

02:34:48.428 --> 02:34:53.476
more member functions.   any 
class, even a data class can 

02:34:53.477 --> 02:35:00.712
have member functions but for 
brevity, it's top level, okay?  

02:35:00.713 --> 02:35:03.811
I create a new instance of money
 and we call it, for example, 

02:35:03.812 --> 02:35:08.250
tickets and I'll say money, 100,
 and it's going to be dollars, 

02:35:08.443 --> 02:35:13.852
right?  And I'll get into the 
explicit type here, but 

02:35:13.853 --> 02:35:17.445
essentially what I'm doing is 
typing, for instance.  So Kotlin

02:35:17.618 --> 02:35:22.593
 is strong in it, and isasmuch 
as it can infer, it will for 

02:35:22.932 --> 02:35:30.125
you.  say, for example, popcorn.
  say tickets, copy, right?  

02:35:30.126 --> 02:35:34.039
that's what that's going to do, 
basically copy the previous one 

02:35:34.040 --> 02:35:38.290
for me, and all of the 
properties.  So if I don't pass 

02:35:38.291 --> 02:35:42.665
any parameters in, it's going to
 just take the same values as it

02:35:42.791 --> 02:35:48.298
 has before, okay?  I can pass 
on a new parameter.  In Spain 

02:35:48.299 --> 02:35:51.438
popcorn is seven times the price
 of the entry of the cinema, so 

02:35:51.685 --> 02:35:57.230
that's 500 euros, right?  Now I 
can do things like, for 

02:35:57.367 --> 02:36:07.047
instance, if tickets is not 
equal to popcorn, then paren 

02:36:07.399 --> 02:36:11.170
line, they are different, right?
 what this is doing is a 

02:36:11.171 --> 02:36:14.046
property comparison one by one. 
 not doing a point of 

02:36:14.163 --> 02:36:16.698
comparison.  For point of 
comparisons, we have the triple 

02:36:17.195 --> 02:36:19.665
equal, right?  Different to 
JavaScript, there isn't like a 

02:36:19.666 --> 02:36:23.373
chart of 600 different positions
 you have to remember.  So this,

02:36:23.490 --> 02:36:29.968
 by the way, firm ligature, so 
don't get confused with that.   

02:36:29.969 --> 02:36:36.229
introduce a new symbol. go ahead
 and run this.  I get they are 

02:36:36.361 --> 02:36:40.376
different, and if I change this 
to 100 and I put this as dollars

02:36:41.235 --> 02:36:44.748
 and I run this, it's going to 
say to you that nothing, because

02:36:44.893 --> 02:36:49.102
 they are the same, okay?  Now, 
one of the features we keep 

02:36:49.103 --> 02:36:52.408
boosting about is the 
interaction between Java and 

02:36:52.749 --> 02:36:56.983
Kotlin.  We have this Java money
 one over here, so I'll create 

02:36:56.984 --> 02:37:04.062
an instance of it.  Java money 
equals Java money, and it will 

02:37:04.063 --> 02:37:09.847
be 100 and dollars.  If I do 
Java money, you can see that I 

02:37:09.848 --> 02:37:13.809
don't have any getters.  What I 
do have is a getter, so I can do

02:37:13.936 --> 02:37:20.137
 get amount, but if I write get 
amount completed, the IDs 

02:37:20.425 --> 02:37:23.510
replace that for property.  We 
don't have getters and setters. 

02:37:23.951 --> 02:37:28.158
 just have properties, so that's
 consuming Java from Kotlin, and

02:37:28.346 --> 02:37:33.403
 if I go over to the Java over 
here and let's go ahead and 

02:37:33.404 --> 02:37:40.067
create a public site, so I have 
to declare the type.  equals new

02:37:40.452 --> 02:37:50.379
 money, 100 dollars and okay.  
That's the other thing.  The 

02:37:50.380 --> 02:37:52.783
semi colon in Kotlin are 
optional, and the reason they're

02:37:53.139 --> 02:37:56.563
 optional is so that you can 
have endless arguments over 

02:37:56.564 --> 02:38:01.895
whether you should use them or 
not.  We're trying to compete 

02:38:01.896 --> 02:38:09.358
with JavaScript there.   Now I 
use a Kotlin type from Java, so 

02:38:09.359 --> 02:38:15.140
I get the getters and setters so
 it depends how you use it.  

02:38:15.270 --> 02:38:20.441
Okay?  different Java files and 
Kotlin files in a similar 

02:38:20.442 --> 02:38:22.666
project working similarly 
without any issues.  Let's go 

02:38:22.667 --> 02:38:26.387
ahead and create some functions.
 I'm going to create a suction 

02:38:26.388 --> 02:38:31.705
called send payment that takes 
money, and money.  It's going to

02:38:33.293 --> 02:38:37.393
 print line the money out.  Of 
course, we have string, so I can

02:38:38.650 --> 02:38:43.879
 say sending money.amount and 
you don't have to calibrations 

02:38:43.880 --> 02:38:47.002
if it's just a single property 
you paste in.  Now I can call 

02:38:47.003 --> 02:38:53.726
this and say, send payment 
tickets.   Kotlin, we also have 

02:38:53.727 --> 02:38:57.424
-- one thing here.  I'm not 
defining the return type, okay? 

02:38:57.801 --> 02:39:01.110
 default it's unit, which is 
kind of like void but it's not. 

02:39:01.763 --> 02:39:06.640
 actually an object which is 
essentially a single instance of

02:39:06.812 --> 02:39:10.712
 an object, and if it is a unit,
 you don't have to put it there,

02:39:11.064 --> 02:39:17.740
 right?  So I'm going to add a 
new parameter here and say with 

02:39:17.741 --> 02:39:21.898
message and this is a string.   
default parameters. here notice 

02:39:21.899 --> 02:39:24.966
there's no compilation error 
because I made a parameter.  

02:39:24.967 --> 02:39:28.212
This saves a lot in terms of 
overloading member functions, 

02:39:28.608 --> 02:39:31.517
right?  I can just have 
different parameters and do what

02:39:32.340 --> 02:39:37.173
 I want, and you can have 
multiple default parameters and 

02:39:37.174 --> 02:39:40.450
you can alternate which one you 
want to parse in, you can also 

02:39:41.115 --> 02:39:47.663
do named parameters.  In fact, I
 could say message equals good 

02:39:48.241 --> 02:39:53.198
luck, and money equals tickets. 
 This is kind of useful as well 

02:39:53.199 --> 02:39:58.042
when you are using --  to Legacy
 code, for example, and some 

02:39:58.043 --> 02:40:04.142
function that you can modify and
 it has 600 parameters and 500 

02:40:04.143 --> 02:40:09.498
of them are true and false.  It 
gives you an insight into what 

02:40:09.744 --> 02:40:11.744
parameters I'm parsing in

02:40:15.279 --> 02:40:21.914
 in every position.  Okay.  I 
love it when people crap -- 

02:40:22.233 --> 02:40:24.233
clap.  Laughter )

02:40:30.391 --> 02:40:33.234
 three tee I'm thinking to 
myself, this is going well. 

02:40:38.144 --> 02:40:41.050
with Kotlin is whether we have 
functions that are really, 

02:40:41.539 --> 02:40:45.628
really easy, like essentially 
returning a single value, you 

02:40:45.629 --> 02:40:51.357
can just do single expression 
functions.  So I omit the return

02:40:52.696 --> 02:40:56.754
 type.  I just return the actual
 function that I want to do, 

02:40:57.161 --> 02:41:00.826
okay?  So, in fact, this is like
 the concept of expression comes

02:41:00.949 --> 02:41:04.901
 in many places in Kotlin.  For 
instance, let's create a 

02:41:05.201 --> 02:41:07.164
function called convert to 
dollars.  Convert to dollars, 

02:41:07.165 --> 02:41:10.316
and this is going to take money.

02:41:14.744 --> 02:41:17.983
 we're going to do is here 
Wednesday, so that's essentially

02:41:18.111 --> 02:41:27.064
 a case, right?  So when money 
currency is dollars, then we do 

02:41:28.196 --> 02:41:31.919
return, money as is, right?  I 
don't need to do anything.  If 

02:41:31.920 --> 02:41:38.605
it's euros, then what I do is 
return, and we're going to do 

02:41:38.606 --> 02:41:45.122
money amount times -- sorry.  I 
have to create a new instance.  

02:41:45.123 --> 02:41:52.882
Money and then it's going to be 
money amount times big decimal 

02:41:53.634 --> 02:42:01.214
1.10 and then that's going to be
 dollars.  Right?  And a legal 

02:42:01.414 --> 02:42:07.346
argument exception, not the 
currency you're interested in.  

02:42:08.423 --> 02:42:12.071
 So this you can actually treat 
as an expression.  I can remove 

02:42:12.072 --> 02:42:15.316
this return over here, remove 
this return over here, put it 

02:42:15.317 --> 02:42:22.118
just here, and then this just 
makes the when always return an 

02:42:22.273 --> 02:42:25.855
expression.  You can remove the 
return here, in fact, and remove

02:42:26.255 --> 02:42:30.827
 the money here and remove that 
there and you get a single 

02:42:31.293 --> 02:42:35.875
expression.  Okay?   function.  
One thing you notice here is 

02:42:35.876 --> 02:42:39.623
this is giving me an error 
because this is, you know, I'm 

02:42:39.624 --> 02:42:43.414
trying to operate a big decimal 
with an end, so we're going to 

02:42:43.415 --> 02:42:47.772
go and refactor this and call it
 big decimal.  Okay?  Talking 

02:42:47.773 --> 02:42:57.628
about big decimal -- oh, here we
 go.  Big decimal, 100 and big

02:42:57.993 --> 02:43:00.302
 decimal.  I love typing big 
decimal.  I

02:43:03.322 --> 02:43:08.295
 love it.  Okay?  we've got this
 over here.   if you look at 

02:43:08.296 --> 02:43:11.988
actually big decimal, to if I 
create a new big decimal, we'll 

02:43:11.989 --> 02:43:17.538
call it BD1 equals big decimal 
100, you can see the BD1 gives 

02:43:17.539 --> 02:43:21.026
me a bunch of functions like 
divide and multiply and all of 

02:43:21.027 --> 02:43:25.365
these things.  What if I do 
something like a percent?  I 

02:43:25.366 --> 02:43:31.459
want to do a percentage of big 
decimal.   inherits from that 

02:43:31.460 --> 02:43:35.058
and create your own version and 
have all of these things.  

02:43:35.059 --> 02:43:38.622
Kotlin one of the things we 
added is extension functions, 

02:43:38.623 --> 02:43:42.081
which means you take any class 
or type and extend it.  I can 

02:43:42.082 --> 02:43:45.755
take a function of big decimal 
and put the name of the class I 

02:43:45.756 --> 02:43:49.130
want to extend and want to do a 
percent.  What is the percentage

02:43:49.478 --> 02:43:55.241
 that I want to do, for example,
 and an integer.  Let's see.   

02:43:55.242 --> 02:44:00.553
an extension function, it's 
going fob an instance of that 

02:44:00.554 --> 02:44:02.139
class, of that object, right?  
So I can use that and reference 

02:44:02.140 --> 02:44:09.039
that with this, and I say this 
multiplied by the percentage, 

02:44:09.040 --> 02:44:14.277
and then this awrapped in a big 
decimal again, percentage, and 

02:44:14.278 --> 02:44:21.526
then that divide and then 
another big decimal 100.  What's

02:44:21.903 --> 02:44:23.903
 wrong with this?  should be

02:44:26.896 --> 02:44:30.935
 percentage.  So percentage.  
Okay?  So now what happens is 

02:44:30.936 --> 02:44:38.318
that on BD1 I have percentage.  
Okay?  I can do percent 7, and 

02:44:38.319 --> 02:44:42.109
that would give me 7%.  That 
extension function gets included

02:44:42.535 --> 02:44:47.206
 anywhere where it's defined in 
the package, right?  Here in 

02:44:47.207 --> 02:44:51.074
case I have it there, and that 
will be included there.  You can

02:44:51.348 --> 02:44:54.781
 create extension functions.  
The standard library consists of

02:44:54.942 --> 02:44:58.405
 a whole bunch of extension 
functions.  We'll take it one 

02:44:58.406 --> 02:45:06.113
step further. extends RG, a 
integer.  I say fund in percent 

02:45:06.114 --> 02:45:10.148
of and here we do the reverse.  
So I want like 10% of something,

02:45:10.838 --> 02:45:15.976
 right?  I'll say, money, for 
instance, I want 10% of money.  

02:45:15.977 --> 02:45:22.718
going to return the -- see.  It 
will return money, right?  Then 

02:45:22.719 --> 02:45:27.815
it will be amounts multiplied, 
and then here it references the 

02:45:27.816 --> 02:45:32.310
actual instance, so it will be 
this and again this has to be 

02:45:32.311 --> 02:45:34.311
wrapped in 

02:45:35.685 --> 02:45:41.517
big decimal.  And then divide by
 100, okay?  I think I got that 

02:45:41.880 --> 02:45:43.890
in the right order.  If the 
implementation is wrong, it 

02:45:43.891 --> 02:45:50.832
doesn't matter.  Who cares.   
now what I can do is go like 

02:45:51.082 --> 02:45:59.838
this.  7% of big decimal 100.  
Okay?  No, sorry.  Money.  I can

02:46:00.092 --> 02:46:02.092
 do money.  No,

02:46:03.954 --> 02:46:06.029
 don't clap yet.  Money -- let's
 just take the money I have.  7%

02:46:06.384 --> 02:46:15.795
 of popcorn, okay?  Nice?  
Applause )    HADI HARIRI:  

02:46:15.796 --> 02:46:19.041
Let's do something nicer.  I 
want to do something like this. 

02:46:19.228 --> 02:46:22.935
 I want to do 7% of popcorn.  
That would be nice.  You can do 

02:46:23.060 --> 02:46:28.934
that.  You see that wiggly 
there, alt, enter, add and fix. 

02:46:29.051 --> 02:46:34.320
 There you go.  Any extension 
function that has a single pa  

02:46:34.321 --> 02:46:38.053
parameter can be called in an 
fix notation and I add it over 

02:46:38.284 --> 02:46:41.295
there.  This is some of the 
things that allow you now with 

02:46:41.296 --> 02:46:45.600
Kotlin to create the whole DSL 
approach to things.  Right.  one

02:46:46.385 --> 02:46:50.449
 thing that I hated doing here 
is all of this big decimal. a 

02:46:50.869 --> 02:46:53.899
pain, all right?  In Kotlin when
 you wanted to create a value of

02:46:54.096 --> 02:46:58.174
 type long, you can say long 
100L, and that will be a type 

02:46:58.392 --> 02:47:02.932
long.  I know it would be 
awesome if I can do BD2 equals 

02:47:03.932 --> 02:47:06.624
100BD, but you can't.  We don't 
have that built in.  What we do 

02:47:06.625 --> 02:47:10.832
in Kotlin is called extension 
properties, so they're exactly 

02:47:10.833 --> 02:47:15.977
like extension functions except 
them extends with properties.  I

02:47:16.304 --> 02:47:22.949
 could do something like .BD, 
right?  And now -- yeah.  So now

02:47:23.175 --> 02:47:26.302
 -- see it says, do you want to 
create an extension property on 

02:47:26.303 --> 02:47:30.500
type integer?  Yes.  So this is 
going to return a big decimal.  

02:47:31.819 --> 02:47:39.773
Right?  And then here I'm going 
to do return, big decimal, and 

02:47:40.195 --> 02:47:44.028
this, which is the instance, 
right?  I can, in fact, convert 

02:47:44.029 --> 02:47:47.672
this to an expression to make it
 easier, right?  There you go.  

02:47:47.673 --> 02:47:54.905
Now I have 100.BD.  When I pass 
that in, it looks much nicer 

02:47:54.906 --> 02:47:58.534
than big did hes ma'am.  I can 
do 100.BD,

02:48:03.528 --> 02:48:07.048
 okay?  One other thing around 
functions you can do is there 

02:48:07.732 --> 02:48:10.454
are certainly operators that you
 can extends.  You can extend 

02:48:10.455 --> 02:48:13.208
the plus operator, and what I'm 
going to do is I'm going to type

02:48:13.406 --> 02:48:17.184
 this out.  I have a nice little
 thingy that did that for me.  

02:48:17.185 --> 02:48:21.719
how fast I am at typing?  So 
what I've done is now override 

02:48:21.874 --> 02:48:29.008
the plus operator for money.  So
 now I can say how costs equals 

02:48:29.460 --> 02:48:34.303
tickets plus popcorn, right?  
allows me to add two monetary 

02:48:34.542 --> 02:48:37.793
amounts, okay?  You can do that 
with plus, mine, multiply, a

02:48:43.241 --> 02:48:47.441
 bunch of built-in conventions 
to follow for certain operators 

02:48:43.241 --> 02:48:45.007
that allow you to do that.  
Okay.  So we've been creating a 

02:48:45.008 --> 02:48:48.633
whole bunch of types here, and 
let any go ahead and delete all 

02:48:48.634 --> 02:48:52.184
this stuff so we can focus.  
We've been creating a BUFRNL of 

02:48:52.185 --> 02:48:55.440
types here.  Notice in the types
 I created I never actually 

02:48:55.441 --> 02:49:03.074
specified the type.  can.  So I 
can do, for instance, train 

02:49:04.062 --> 02:49:07.531
costs, for example, the train is
 of type money, and then 

02:49:07.532 --> 02:49:12.855
initialize it to some new value,
 right?  100.BD and then 

02:49:12.856 --> 02:49:17.633
dollars.  Now, if I go ahead and
 do train equals now, it's going

02:49:17.818 --> 02:49:22.168
 to give me an error, and it 
will give me two errors.  is 

02:49:22.169 --> 02:49:25.646
because that's a mutable 
variable, so I can fix that.  I 

02:49:25.647 --> 02:49:29.999
made this mutable.  You see the 
ID underlines it, so it wants to

02:49:30.289 --> 02:49:33.064
 point out that this is really 
something you have to shy away 

02:49:33.551 --> 02:49:38.742
from.  We don't it enforce 
immutability but derecommend it.

02:49:39.077 --> 02:49:45.062
 the lites and things are 
immutable by default.  I can't 

02:49:45.394 --> 02:49:49.590
assign now in Kotlin, because it
 tries to get rid of the pointer

02:49:49.735 --> 02:49:52.576
 exception by saying types 
aren't by default, right?  There

02:49:52.577 --> 02:49:55.977
 are times to have a type that 
is knowledgeable for whatever 

02:49:56.162 --> 02:49:58.895
reason, you're bored, and you 
can add a question mark and then

02:49:59.108 --> 02:50:03.143
 that will give you the ability 
to assign null to that type, 

02:50:03.299 --> 02:50:06.942
right?  Normally whether you 
work with Kotlin, you don't want

02:50:07.161 --> 02:50:13.051
 to do this.  You don't want to 
have null types.  Since we 

02:50:13.180 --> 02:50:16.030
interact with Java, it can be 
null.  If I create a function 

02:50:16.169 --> 02:50:18.169
here that is, for 

02:50:21.441 --> 02:50:25.815
instance, Java money and that 
takes Java money and does 

02:50:25.816 --> 02:50:31.460
whatever with it, right?  Let's 
say I do print line, 

02:50:33.630 --> 02:50:41.179
money.amount is valid, so this 
can be now -- if it's called by 

02:50:41.180 --> 02:50:44.812
an instance, a function that for
 example is returning this time,

02:50:44.952 --> 02:50:47.673
 it could be null.  You can 
indicate that by adding the 

02:50:47.674 --> 02:50:52.359
question mark.   do that, you 
can see that the IDE gives you 

02:50:52.360 --> 02:50:57.714
an error. safe operators or 
double exclamation mark is valid

02:50:58.075 --> 02:51:01.355
 here.  an all-reference 
exception.  There's two ways to 

02:51:01.356 --> 02:51:04.880
solve T. First of all, you can 
say for example money not now 

02:51:04.881 --> 02:51:10.402
and then do if not now then go 
ahead and operate with it.  Put 

02:51:10.403 --> 02:51:16.586
this one upstairs in there, 
okay?  That's one way.  Or the 

02:51:16.587 --> 02:51:19.783
shorter way is just to use the 
safe operator or Elvis operator,

02:51:19.915 --> 02:51:23.716
 which is over here.  So now we 
just say if money is not null, 

02:51:23.717 --> 02:51:27.765
then do something.  Now, if you 
want to have fun, you can also 

02:51:27.766 --> 02:51:31.524
do that.  That says I know it's 
null, but I want to shoot myself

02:51:31.718 --> 02:51:36.112
 in the foot, okay?  You got to 
be careful with that, because a 

02:51:36.977 --> 02:51:42.000
lot of times when people start 
with Kotlin, they get little 

02:51:42.001 --> 02:51:44.538
squiggles over here.  They don't
 know if it's null because I 

02:51:44.539 --> 02:51:48.126
want it to not be null, so I'm 
not going to handle the case now

02:51:48.266 --> 02:51:51.944
 so I'll do that.  They run the 
app, and they're like, wait a 

02:51:52.094 --> 02:51:58.985
minute, UGSD Kotlin got rid of 
exceptions.  Yes.  Okay.  What 

02:51:59.124 --> 02:52:02.831
else?  Right.  So let's switch 
to other stuff like higher order

02:52:03.627 --> 02:52:06.424
 functions.  You're all familiar
 with a higher order function, 

02:52:06.425 --> 02:52:10.263
which is basically a function 
that takes a function and 

02:52:10.457 --> 02:52:13.319
returns a function.  We have 
those in Kotlin.  We can say 

02:52:13.320 --> 02:52:17.915
find e-mails, and list of users 
and then I create a new 

02:52:18.040 --> 02:52:20.349
function.  I'm passing a 
function here, right?  A 

02:52:20.350 --> 02:52:27.247
function that takes a string and
 returns a bullion, okay?  This 

02:52:27.248 --> 02:52:32.424
is probably going to return a 
list of users.  This is 

02:52:32.714 --> 02:52:37.239
filtering a list of users, 
right?  I'll do this later.  To 

02:52:37.240 --> 02:52:41.500
do later, okay?  This to do, by 
the way, is built in.  You can 

02:52:41.501 --> 02:52:46.174
use it instead of nonimplemented
 error, and it does an 

02:52:46.175 --> 02:52:50.672
additional thing we won't get 
into.  is actually very nice in 

02:52:50.673 --> 02:52:54.527
Kotlin.  We wouldn't cover that 
now.   nothing to

02:52:58.494 --> 02:53:05.030
 worry about.  I just made that 
up.  Okay.  Thank you.  So now 

02:53:05.031 --> 02:53:09.556
how do I use this?  find the 
e-mails, right?  say, I actually

02:53:09.683 --> 02:53:17.011
 have a user.  Let's create some
 users here.  Users from JSON, 

02:53:17.012 --> 02:53:20.819
so this is actually -- this is 
actually a function that I have 

02:53:20.976 --> 02:53:25.501
ready, which is using JSON to 
read some music from a file, and

02:53:25.677 --> 02:53:30.786
 this is a typical data class 
you've seen.  also got a class 

02:53:30.787 --> 02:53:36.313
of -- with aproperty role, okay?
  So now I can do users, and 

02:53:36.314 --> 02:53:38.314
then I'll pass

02:53:39.539 --> 02:53:39.696
 in that function.  I can pass 
in the name function by using 

02:53:39.697 --> 02:53:43.325
the quote-unquote research, or I
 can pass in the Lambda.  In 

02:53:43.898 --> 02:53:49.174
Kotlin, lamb BA follows this 
syntax.  parse in the PRAR meter

02:53:49.341 --> 02:53:53.326
 name, and they say the 
parameter name ends with.com.  

02:53:53.327 --> 02:53:58.366
So I'm going a list of users 
that end with .com.  Now, when 

02:53:58.367 --> 02:54:03.789
you have a single parameter in 
Kotlin, you can actually admit 

02:54:03.790 --> 02:54:07.486
having to explicitly mention it 
and replace it with it, okay?  

02:54:07.487 --> 02:54:11.795
So similar to that, you can just
 use it.  The other thing in 

02:54:11.921 --> 02:54:14.768
Kotlin, when the last parameter 
to a function is another 

02:54:14.960 --> 02:54:21.349
function, you can actually not 
include it in the brackets.  So 

02:54:21.350 --> 02:54:26.458
it feels a little bit like it's 
outside.  This is, again, one of

02:54:26.771 --> 02:54:31.262
 the characters that allowed new
 DSLs and do it like multi-line.

02:54:31.263 --> 02:54:35.488
  you look at fine e-mails, it 
can feel like it's part of the 

02:54:35.631 --> 02:54:39.918
language, but it isn't.  It's 
actually a function.  When we 

02:54:40.421 --> 02:54:47.712
implemented a sync  --  with 
co-rootings, if you're familiar 

02:54:47.713 --> 02:54:51.945
with C sharp, it does the same 
thing with keywords in the 

02:54:52.070 --> 02:54:56.020
language.  In Kotlin they're 
just functions.  That gives you 

02:54:56.021 --> 02:54:59.081
the flexibility of decides how 
to do different things.  You 

02:54:59.082 --> 02:55:01.619
don't have to do all of these 
things, because they're all 

02:55:01.620 --> 02:55:06.191
built in.  For example, if I say
 .com users, I say users filter,

02:55:06.451 --> 02:55:10.101
 and you can see as I complete 
this it actually opts for the 

02:55:10.259 --> 02:55:16.267
version of including out of the 
parameter.  So I can say the 

02:55:16.268 --> 02:55:23.195
e-mail ends with dot com and I 
can sort by

02:55:27.311 --> 02:55:36.546
 it.ID and map that to a pair of
 it.e-mail and it.user name.  

02:55:36.929 --> 02:55:41.501
Okay?  So all of these functions
 are actually built into the 

02:55:41.502 --> 02:55:44.392
small standard library.  You 
won't have problems on Android 

02:55:44.393 --> 02:55:48.397
and it's very small.  They're 
extension functions on top of 

02:55:48.558 --> 02:55:51.582
collections. collections, right?
  So you have all of those 

02:55:51.583 --> 02:55:55.565
functional things that, you 
know, are very in fashion these

02:55:58.825 --> 02:56:00.825
 days.  And so

02:56:05.430 --> 02:56:12.155
 gives me a paren.  Instead of 
doing paren it 2 so map e-mail 

02:56:12.156 --> 02:56:16.814
to user name.  Guess what it is?
 just an end fix function that 

02:56:16.815 --> 02:56:20.288
creates a pair, okay?  Now, 
sometimes I don't want to go 

02:56:20.402 --> 02:56:23.389
through the whole map.  I just 
want to, for example, say get 

02:56:23.390 --> 02:56:25.919
back a single element.  What you
 can also

02:56:29.268 --> 02:56:33.208
 do is destructure data classes 
in Kotlin.  So I could do 

02:56:33.209 --> 02:56:37.268
something like ID, user name, 
and e-mail, okay?  And then I 

02:56:37.425 --> 02:56:41.541
can just like, you know, use the
 ID.  This is great, but then 

02:56:41.542 --> 02:56:44.665
the ID complains and says this 
variable is never used.  In that

02:56:44.786 --> 02:56:51.953
 case you can replace that with 
an underscore, right?  So there 

02:56:51.954 --> 02:56:55.438
you go.  You can destruct the 
value you want.  Replace it on 

02:56:55.439 --> 02:57:00.362
the score, and you're good to 
go.  Right.  What else can I 

02:57:00.363 --> 02:57:04.201
show you?  I have other code 
here.  If you're familiar with 

02:57:04.202 --> 02:57:09.399
the concept of a gentleman Bray 
YIK data types, it's a type one 

02:57:10.388 --> 02:57:15.579
time of another.  For instance, 
a bullion.  In Kotlin we do that

02:57:15.936 --> 02:57:19.277
 with classes, but let me do an 
open here.  Notice the first 

02:57:19.984 --> 02:57:23.327
thing here is that user result 
is giving me an error.  By 

02:57:23.328 --> 02:57:26.216
defaulting Kotlin, you can't in
herit from classes.  All classes

02:57:26.569 --> 02:57:31.222
 are essentially final.   
inherit from classes, use the 

02:57:31.223 --> 02:57:39.245
open mod fire, right?  Now, I 
used the seal, and this is 

02:57:39.246 --> 02:57:43.035
saying this is the hierarchy 
user result has.  not any other 

02:57:43.036 --> 02:57:47.981
class anywhere that is go to 
inhair from user results.  

02:57:47.982 --> 02:57:53.037
Everything that inherits has to 
be in the same fire, or you can 

02:57:53.038 --> 02:57:57.611
make these subclasses so I can 
move this up there and this 

02:57:57.612 --> 02:58:01.365
would be a subclass.  Then I 
have to prefix it with user 

02:58:01.645 --> 02:58:10.447
results, right?   Now, I've just
 created it as a class outside, 

02:58:10.448 --> 02:58:14.875
so why would I want to do this? 
 Because it looks good.  No.  

02:58:14.876 --> 02:58:20.056
This is actually good because 
when you do some things, you 

02:58:20.057 --> 02:58:23.304
invoke a function and you're 
like okay, if it's successful 

02:58:23.305 --> 02:58:26.941
FSHGS I want to return a value. 
 If it's not, I pass in a 

02:58:27.104 --> 02:58:29.558
message.  You get this THIEP 
that contains the values that 

02:58:29.559 --> 02:58:31.989
you want to return whether it's 
successful.  It contains the 

02:58:31.990 --> 02:58:35.418
types you return when there's a 
message and you have to figure 

02:58:35.419 --> 02:58:40.261
out the semantics of which 
properties applied to an error 

02:58:40.262 --> 02:58:46.048
situation and non-error 
situation, or just throw in an 

02:58:46.049 --> 02:58:47.251
exception.  In this case you can
 use a function that basically 

02:58:47.252 --> 02:58:51.848
returns two types.  Based on the
 result, two do different 

02:58:51.979 --> 02:58:57.747
things. for instance, when -- 
create an instance of the value 

02:58:57.748 --> 02:59:02.954
result equals user results.  
Sorry.  Retrieve users.  Okay.  

02:59:02.955 --> 02:59:05.348
So now I can do when

02:59:08.720 --> 02:59:12.291
 result is success, then we're 
going to do, for instance -- we 

02:59:12.292 --> 02:59:19.762
get the result, and then we do 
users for each.  each

02:59:22.395 --> 02:59:30.589
, print line, the name, okay?  
User name.  And then we do a 

02:59:30.590 --> 02:59:39.443
failure result, print line, 
result, dot message, okay?  So 

02:59:39.444 --> 02:59:42.247
now based on the result, based 
on the type that is returned to 

02:59:42.810 --> 02:59:46.678
me, I can do different things.  
notice one thing over here that 

02:59:46.679 --> 02:59:48.952
this is going green.  I don't 
know if you see it on the big 

02:59:49.079 --> 02:59:53.071
screen, but this went green. a 
smart cast, and that's another 

02:59:53.072 --> 02:59:57.402
thing in Kotlin.  You saw that 
when I was doing the now check 

02:59:57.403 --> 03:00:00.199
that said this is not nulled 
because it's smart casting.  You

03:00:00.471 --> 03:00:04.428
 don't have to be over here 
again and say, you know, I know 

03:00:04.429 --> 03:00:07.922
that this is of type success.  
Let me go ahead and cast this to

03:00:08.045 --> 03:00:12.954
 type success to access the 
property.  The compiler will do 

03:00:12.955 --> 03:00:17.354
that for you.  what the 
smartcasting is. but not least 

03:00:17.355 --> 03:00:21.448
before I hand it off to Andrey, 
a lot of things you've seen with

03:00:21.621 --> 03:00:27.938
 the filter map, all of those 
things, those are essentially 

03:00:27.939 --> 03:00:31.821
eager evaluation, right?  We 
also have the availability to do

03:00:31.939 --> 03:00:36.172
 lazy evaluations.  So I can 
generate sequence and then have 

03:00:36.804 --> 03:00:44.812
something, for instance, 1.  And
 then here we'll do it times 10.

03:00:44.813 --> 03:00:53.344
  then we'll do values, right? I
 say values take 

03:00:55.051 --> 03:01:01.871
10, and then for each print line
 it.   this is essentially 

03:01:02.069 --> 03:01:06.456
creating a sequence, a generator
 that is infinite, it won't stop

03:01:06.661 --> 03:01:10.481
 and start at 1 and multiply by 
10.  I'm saying that I want to 

03:01:10.482 --> 03:01:13.913
take 10 elements and then print 
them out.  What it will do is 

03:01:14.437 --> 03:01:20.580
basically consume that until it 
hits of ten.  It printed out -- 

03:01:20.581 --> 03:01:28.204
It prints out a beautiful 
Christmas tree.  one-sided.  

03:01:28.341 --> 03:01:32.027
Okay?   whatever.  And it stops 
there, and anything that you 

03:01:32.028 --> 03:01:35.906
have like, for example, the 
users that we had, you know, 

03:01:37.385 --> 03:01:43.028
users from JSON, users.JSON, you
 can say as sequence and 

03:01:43.029 --> 03:01:45.759
converted into lazy evaluation 
as well.  Okay?  That's all we 

03:01:45.760 --> 03:01:49.773
have the time to show you today.
 there's way more to the 

03:01:49.927 --> 03:01:52.012
language.  Go online and learn 
everything about it, and thank 

03:01:52.013 --> 03:01:56.490
you very much.  I'll hand it off
 to Andrey.  Applause )

03:02:01.477 --> 03:02:04.576
    ANDREY BRESLAV:  Thank you, 
Hadi.  Hello, everybody.  As you

03:02:05.099 --> 03:02:09.115
 see, Kotlin already has many 
things in store, but I'm the 

03:02:09.116 --> 03:02:11.807
nasty person who adds new 
features before you learn the 

03:02:11.808 --> 03:02:15.156
existing ones.  So I tell you 
stories now, but I need to find 

03:02:15.968 --> 03:02:20.822
a clicker.  Do you have a 
clicker?  No.  Okay.  Okay.  So 

03:02:20.823 --> 03:02:24.291
I'll be telling stories without 
a clicker.  So my job here is to

03:02:24.731 --> 03:02:27.882
 tell you about what we're going
 to have in the future versions 

03:02:28.339 --> 03:02:30.441
of Kotlin.  Thank you very much.

03:02:33.568 --> 03:02:39.356
 And first big thing we're 
working on now is platforms, 

03:02:39.524 --> 03:02:41.524
supporting different platforms. 

03:02:45.790 --> 03:02:51.353
 compiles to the code same as 
the Java language.  We can run a

03:02:51.490 --> 03:02:55.689
 server on the desktop and 
Android.   the same byte code 

03:02:56.174 --> 03:02:59.383
everywhere.  This is why we can 
run old verges of Android as 

03:02:59.569 --> 03:03:04.735
well as new ones.  The story 
doesn't end there.  We add new 

03:03:04.736 --> 03:03:10.932
platforms and recently we added 
-- the guy doesn't like 

03:03:11.086 --> 03:03:14.458
platforms.  Recently we added 
JavaScript, which means Kotlin 

03:03:14.926 --> 03:03:18.026
can now compile to JavaScript 
code and run in the browser or 

03:03:18.161 --> 03:03:24.833
on no GS.  So now we support 
three major very popular Virtual

03:03:25.024 --> 03:03:30.017
 Machines, JVM, Android, Dole 
DRIK and JavaScript.  There are 

03:03:30.018 --> 03:03:33.776
many use cases where a Virtual 
Machine is not practical or 

03:03:33.777 --> 03:03:40.851
simply unavailable.  For 
example, for iOS, Virtual 

03:03:40.852 --> 03:03:44.166
Machines are severely 
restricted.  For a small 

03:03:44.305 --> 03:03:47.942
embedded system, VM doesn't fit 
in or a Linux command line tool,

03:03:48.072 --> 03:03:53.778
 the VN will be a starting tool 
for too long.  It's a no-go 

03:03:53.943 --> 03:04:00.462
there.  That's why we work on 
cull Lynn native.  It's a t

03:04:00.586 --> 03:04:06.814
echnology preview.  There we use
 LVM to compile Kotlin down to 

03:04:06.815 --> 03:04:10.360
native code that runs on 
different platforms.  Currently 

03:04:10.361 --> 03:04:19.130
we expect iOS, Linux and Mac and
 Windows is in the works.  This 

03:04:19.275 --> 03:04:25.955
is with the vision with Kotlin 
when it can run inside every 

03:04:26.139 --> 03:04:29.510
component on any platform you 
like.  Think full stack web 

03:04:29.511 --> 03:04:33.972
applications with the server and
 the client both written in 

03:04:34.583 --> 03:04:38.091
Kotlin, or use code between 
multiple platforms, Android and 

03:04:38.330 --> 03:04:42.093
iOS, for example, or mix of the 
two previous use cases and get a

03:04:42.492 --> 03:04:47.836
 real multi-platform scenario.  
our vision for Kotlin is having 

03:04:47.837 --> 03:04:51.879
different modules in the same 
project compiled to different 

03:04:52.086 --> 03:04:55.893
platforms.  Of course, you want 
to share code there, right?  If 

03:04:55.894 --> 03:04:58.863
you support so many different 
things, you want to run the same

03:04:59.029 --> 03:05:03.393
 code in different places.  
We're working on making that 

03:05:03.659 --> 03:05:05.659
possible. 

03:05:08.397 --> 03:05:12.227
 There is a very important 
thing.  Recently many try to 

03:05:12.228 --> 03:05:17.414
unify platforms and this is the 
least common denominator when 

03:05:17.415 --> 03:05:20.760
you take things available on all
 platforms.  You're stuck with a

03:05:21.027 --> 03:05:24.261
 minimal interface, and that's 
something we don't want to have 

03:05:24.411 --> 03:05:29.976
there.  We want to be able to 
use all the platform like the 

03:05:29.977 --> 03:05:32.868
newest version of Android or 
something else as much as you 

03:05:33.226 --> 03:05:37.344
like.  If you want to share 
code, only then you have to 

03:05:37.345 --> 03:05:41.361
resort to some common APIs.  So 
the idea there is you have a 

03:05:41.362 --> 03:05:45.890
common module with lots of 
business logic and stuff.  It 

03:05:45.891 --> 03:05:48.995
works side by side with a 
platform-specific model written 

03:05:49.540 --> 03:05:53.162
in Kotlin.  Those two can talk 
to each other.  When you need to

03:05:53.314 --> 03:05:56.564
 leverage the platform API and 
when you need use the common 

03:05:56.725 --> 03:06:05.515
code.  So take away here, our 
future is multi-platform.   -- 

03:06:07.362 --> 03:06:14.783
Applause )    ANDREY BRESLAV:  
Next big thing is coroutines.  

03:06:14.784 --> 03:06:21.278
The rational is  needs to write 
a SIRNG NUS code, right?  The 

03:06:21.279 --> 03:06:27.915
world is too big for sequential 
execution.  It's a reality, but 

03:06:27.916 --> 03:06:33.962
it's hard, right?  Who has 
written a synchronous code?  Not

03:06:34.135 --> 03:06:36.903
 so many hands.  Those that 
don't actually will be doing 

03:06:36.904 --> 03:06:46.502
this very soon.  The problem is 
it's hard to write the code or 

03:06:46.503 --> 03:06:49.377
it was hard before languages 
supported you in doing that, 

03:06:49.378 --> 03:06:53.188
because language helps a lot.  
What we have with coroutines in 

03:06:53.189 --> 03:07:01.037
cot up Lynn, you write the 
asynchronous code as synchronous

03:07:01.184 --> 03:07:04.731
 code.  Things like that, right?
  It's the same things you're 

03:07:04.732 --> 03:07:11.385
using with coroutines for aSING
chronous code so the language 

03:07:11.386 --> 03:07:16.240
keeps tracks of everything and 
you don't have to express any 

03:07:16.241 --> 03:07:22.128
intricate control flow in the 
code.  No callbacks and fancy, 

03:07:22.129 --> 03:07:24.815
functional structures.  It's 
just plain old

03:07:28.571 --> 03:07:34.159
 sequential-looking code.  Isn't
 it cool?  Thank you.  Yes.  The

03:07:34.453 --> 03:07:41.294
 idea with coroutines is that 
you basically have the same 

03:07:41.295 --> 03:07:46.985
abstraction for asynchronous and
 sing NUS.  It's a night 

03:07:46.986 --> 03:07:50.311
metaphor to think of them as 
three threads.  Here's the code 

03:07:50.312 --> 03:07:54.172
example I show you.  Basically 
very many things traditional 

03:07:54.173 --> 03:07:59.166
down with threads can be down 
with coroutines, but they're 

03:07:59.167 --> 03:08:06.498
extremely cheap.  I have a code 
that creates 1 hundred,000 KWARN

03:08:06.941 --> 03:08:13.522
 tees in parallel.  Each one 
waits for one and returns one.  

03:08:16.188 --> 03:08:19.789
 completes in one second -- 
almost one second, because all 

03:08:19.790 --> 03:08:21.790
the

03:08:23.361 --> 03:08:25.834
 coroutines wait in parallel, of
 course.  If you try to do this 

03:08:25.835 --> 03:08:32.332
with threads, it doesn't work.  
100,000 threads don't fit into 

03:08:32.457 --> 03:08:36.177
memory.  That's with.  With 
coroutines it's a win-win 

03:08:36.334 --> 03:08:39.092
situation.  You get lots of 
performance, so it's very 

03:08:39.310 --> 03:08:42.953
efficient and the code is 
simple.  Take away here.  Check 

03:08:42.954 --> 03:08:44.954
out 

03:08:46.685 --> 03:08:52.482
coroutinesbecause our future 
will likely be more asynchronous

03:08:53.248 --> 03:08:56.269
 than the present.  to learn 
more about Kotlin, check out our

03:08:56.474 --> 03:08:59.903
 website, and we have a section 
for Android and also we have a 

03:09:00.390 --> 03:09:04.460
question and answer session 
right after this talk.  So come 

03:09:04.461 --> 03:09:09.081
over to the developer sandbox 
section C, myself and Hadi will 

03:09:09.082 --> 03:09:15.974
be answering questions there.  
very much for your attention.  

03:09:16.297 --> 03:09:18.297
Applause )

03:09:47.100 --> 03:09:56.075
 .        

03:30:49.724 --> 03:30:55.242
 Hello, everyone.  How is it 
going?   So this session is 

03:30:55.243 --> 03:30:57.596
going to be a little different 
right? 

03:31:02.259 --> 03:31:06.777
 We should introduce ourselves. 
 I'm Paul and he's Jake.  We're 

03:31:06.778 --> 03:31:11.412
doing web stuff for a while so 
we wrote a quiz that looks at 

03:31:11.413 --> 03:31:15.277
the wonderful corners of the 
web.  We'll difficult into the

03:31:18.969 --> 03:31:25.026
 answers to help you in your 
projects for apps.  Of course, 

03:31:25.027 --> 03:31:30.196
the quiz inside is a PWA.  Get 
your laptops and smartphones 

03:31:30.370 --> 03:31:35.531
ready, because we're going to 
play the BIG WEB QUIZ.  Oh, yes.

03:31:43.659 --> 03:31:50.908
  did take six hours.  Worth 
every minute.  If you want to 

03:31:50.909 --> 03:31:56.787
play along, go to bigwebquiz.com
 and log in with your Google 

03:31:57.141 --> 03:32:05.441
account.   where we panic about 
the server falling down.  We 

03:32:05.442 --> 03:32:09.579
tested that.  With a little 
luck, it should be okay.  Your 

03:32:09.580 --> 03:32:13.635
laptop screwed up on the stage 
last year.  It's the new laptop.

03:32:13.636 --> 03:32:17.881
  The first time I presented 
from it.  It's going to be fine.

03:32:17.882 --> 03:32:23.307
  Is everyone logged in?  Is 
that sort of thing working?   

03:32:23.706 --> 03:32:27.368
up.  We're winning.  Last time 
we did it people were shaking 

03:32:27.369 --> 03:32:34.189
their heads and we were like, 
what do we do now?  Blind panic.

03:32:34.190 --> 03:32:37.964
 LEWIS:  We're going to show the
 top players at the end of the 

03:32:37.965 --> 03:32:41.620
game and points throughout and 
only with your permission.  If 

03:32:41.621 --> 03:32:44.254
you want appear on the 
leaderboard click on the avatar 

03:32:44.255 --> 03:32:50.265
and click appear on leaderboard.
  If you phoned in six to come 

03:32:50.266 --> 03:32:53.463
here instead, don't opt in 
because your massive face might 

03:32:53.464 --> 03:32:57.730
give away things a little bit.  
Of course, no quiz is complete 

03:32:57.731 --> 03:33:00.865
without a grand prize.  
Unfortunately, unfortunately the

03:33:02.871 --> 03:33:08.570
 organizers of Google I/O said 
we can't have our own give-away 

03:33:08.571 --> 03:33:12.791
but we came up with a 
compromise.  What if our prize 

03:33:12.792 --> 03:33:16.570
was of such low quality that 
winning it would kind of feel 

03:33:16.571 --> 03:33:22.069
like losing?   play the BIG WEB 
QUIZ OP into the leaderboard and

03:33:22.367 --> 03:33:26.263
 use your web knowledge to make 
it into the top three, you're 

03:33:26.264 --> 03:33:28.936
the proud owner of the official 
BIG WEB 

03:33:36.365 --> 03:33:38.365
QUIZ mouse pad. 

03:33:41.781 --> 03:33:47.960
 Oh, yeah.   get the mouse pad. 
 Irish is sold separately.   

03:33:47.961 --> 03:33:50.459
watching this on the live 
stream, hello.  Feel free to 

03:33:50.460 --> 03:33:54.727
play along as well.  You can't 
win the mouse pad, 

03:33:55.030 --> 03:33:59.497
unfortunately.  There's a delay,
 right?  About 30 seconds behind

03:33:59.875 --> 03:34:02.995
 reality.  You need to watch for
 the questions appearing on your

03:34:03.152 --> 03:34:06.871
 device as the question may end 
before the video makes its way 

03:34:06.872 --> 03:34:11.000
to you.  If you're watching this
 on the live stream now, we 

03:34:11.001 --> 03:34:13.193
probably started the first 
question already because we do 

03:34:13.194 --> 03:34:19.100
that in 30 seconds and you're 
living in the future right now. 

03:34:19.218 --> 03:34:23.374
 We don't want to confuse you.  
Maybe sure everything is 

03:34:23.726 --> 03:34:27.767
working.  Let's see if it works.
  Devices at the ready. comes 

03:34:27.768 --> 03:34:29.768
the

03:34:31.715 --> 03:34:37.151
 does PWA stand for?  Is it 
progressive web app, produced 

03:34:37.152 --> 03:34:42.605
with angular, partially wheeled 
automobile or perfectly 

03:34:42.606 --> 03:34:48.636
waterproofed anorak.  The 
question should be appearing on 

03:34:48.637 --> 03:34:51.909
your phones now.  Pick the 
answer you think is correct and 

03:34:51.910 --> 03:34:56.184
hit submit.  Very important that
 you hit submit.   you do that, 

03:34:56.185 --> 03:34:59.296
let's see how the results are 
looking.  So what we see here is

03:34:59.297 --> 03:35:03.276
 the percentage of you picking 
each answer.  However, the order

03:35:03.556 --> 03:35:08.707
 is randomized compared to your 
devices, it may not be in the 

03:35:08.708 --> 03:35:12.823
same order.   see you're all 
converging on one particular 

03:35:13.001 --> 03:35:17.627
answer.  Wonder which one that 
might be?  Should we Clowe the 

03:35:17.946 --> 03:35:24.280
question? BALD:  We close the 
question in three,  it is.  Oh, 

03:35:24.407 --> 03:35:30.749
okay.  So produced with angular.
  That's interesting. 

03:35:34.076 --> 03:35:37.942
 Obviously, someone hasn't 
really thought about it in the 

03:35:34.076 --> 03:35:38.406
session yet.  The correct answer
 is, of course, progressive web 

03:35:38.613 --> 03:35:42.321
app.  We didn't award points for
 that question, since it's just 

03:35:42.459 --> 03:35:44.678
practice.  One thing we want to 
stress is you have to hit that 

03:35:44.679 --> 03:35:50.071
submit button once you pick the 
answer. else we don't find about

03:35:50.245 --> 03:35:56.050
 it.  During our rehearsal, 
colleagues didn't realize that. 

03:35:56.769 --> 03:36:00.916
  fix the problem, we thought 
we'd gather tape over it with 

03:36:00.917 --> 03:36:05.362
this slide and press the button.
  Just read the instructions.  

03:36:05.363 --> 03:36:07.927
Everybody knows what they're 
doing, so let's get serious now,

03:36:08.095 --> 03:36:11.449
 I think.  From now on each 
question will award a maximum of

03:36:11.724 --> 03:36:19.063
 four points.  That's a nice 
number.  Power of two.  We kick 

03:36:19.064 --> 03:36:23.075
it on with a deep dive into 
loading stuff.  If you want to 

03:36:23.076 --> 03:36:26.562
build a app, you need to limit 
the time from the user clicking 

03:36:26.563 --> 03:36:30.129
link and having your app on the 
screen using it.  This is the 

03:36:30.546 --> 03:36:33.647
difference between a fast app 
and slow app, of course.  

03:36:33.648 --> 03:36:38.303
Ideally a progressive web app 
should load bit by bit.  Some 

03:36:38.304 --> 03:36:41.204
loading techniques get in the 
way of pausing and paints and 

03:36:41.205 --> 03:36:43.205
that can result in the

03:36:45.966 --> 03:36:49.052
 browser downloading stuff and 
once everything is downloaded, 

03:36:49.498 --> 03:36:56.358
tah-dah, there's a big reveal.  
BAZ for the user staring at a 

03:36:56.359 --> 03:37:00.611
wide screen wondering if it's 
downloaded.  This improves the 

03:37:00.612 --> 03:37:03.285
perception of performance 
because things appear much 

03:37:03.478 --> 03:37:08.316
sooner.  This is good as well, 
because they can create the 

03:37:08.317 --> 03:37:11.342
elements which is much faster 
than all the downloads in one 

03:37:11.343 --> 03:37:14.012
stop and all of the parsing in a
 separate step.  That brings us 

03:37:14.013 --> 03:37:19.078
to the next question.  So 
devices at the ready.  Here it 

03:37:19.525 --> 03:37:23.649
comes.  Which of the following 
script elements blocks the 

03:37:23.995 --> 03:37:26.166
parser while the script 
downloads. 

03:37:29.245 --> 03:37:34.060
 The normal script time there 
and a script with defer and a 

03:37:34.061 --> 03:37:36.061
script with A

03:37:38.221 --> 03:37:45.343
 sync and async that's false.  
You get points for those true 

03:37:45.344 --> 03:37:50.462
and not for those false.  You 
get four points fully right and 

03:37:50.463 --> 03:37:53.695
two points for half right.  It 
might be somewhere in the 

03:37:53.845 --> 03:37:57.461
middle.  You can submit as many 
times if you want.  If you 

03:37:57.462 --> 03:38:00.043
change your mind at the last 
second, do that and hit the s

03:38:01.185 --> 03:38:04.302
ubmit button.  Let's look at the
 voting.  How are things going? 

03:38:04.864 --> 03:38:08.285
 Already we've got a spread of 
answers.  We have two that 

03:38:08.286 --> 03:38:12.589
you're confident on and two less
 confident on.  You've had 

03:38:12.590 --> 03:38:13.641
enough time to guess, so if you 
haven't guessed already, guess 

03:38:13.642 --> 03:38:20.029
but we're going to lock the 
question.  Three, two, one, lock

03:38:20.180 --> 03:38:26.073
 it.   think a normal script 
element and async will do the 

03:38:26.396 --> 03:38:31.018
same.  The correct answer?  It's
 just that one.  the normal 

03:38:31.262 --> 03:38:34.922
script.  There's happy people 
and less happy people.  Although

03:38:35.132 --> 03:38:40.634
 it was a multi-select only one 
was correct.  Scripts are awful 

03:38:40.635 --> 03:38:44.902
by defaults.  They block parsing
 download and execute.  Deferred

03:38:45.978 --> 03:38:48.548
 to async scripts don't block 
the parser while they download. 

03:38:48.677 --> 03:38:53.291
 The difference between the two 
when they execute.  They always 

03:38:54.936 --> 03:38:58.015
execute in the order they 
discover this.  Async scripts 

03:38:58.016 --> 03:39:00.080
execute as soon as they 
download, and that means they 

03:39:00.081 --> 03:39:02.081
can learn in DAFRNT

03:39:03.870 --> 03:39:08.060
 -- a different order.  It was 
in the list.  It ignores the 

03:39:08.061 --> 03:39:14.270
value completely.  So you say 
that AC equals false is true 

03:39:14.271 --> 03:39:19.062
which I adore.  That's true.  
That's true of most HTML stuff. 

03:39:19.717 --> 03:39:25.052
 either there or not.   is where
 you can set things to be false.

03:39:25.053 --> 03:39:29.384
  Let's talk about when to use 
the right one, which one is 

03:39:29.581 --> 03:39:33.231
best.  Having the script execute
 in any order is probably risky,

03:39:33.807 --> 03:39:37.920
 because if you have five async 
scripts, you have 120 different 

03:39:37.921 --> 03:39:43.513
permanent YAGSs of execution 
order.  If one causes failure, 

03:39:43.514 --> 03:39:47.226
you don't know where you're at. 
 That's a tricky bug to 

03:39:47.402 --> 03:39:54.215
reproduce and resolve.  They run
 a PROO  predictable time in 

03:39:54.463 --> 03:39:57.761
order. you have a long article 
and your script is to enhance 

03:39:57.762 --> 03:40:01.108
the button, it's a big waste of 
time to download to enhance the 

03:40:01.109 --> 03:40:07.832
little button at the top there. 
 JavaScript blocks the parser.  

03:40:07.833 --> 03:40:15.823
So async could cause in the 
middle of the page load.   

03:40:15.824 --> 03:40:19.855
answer is really depends.  Test 
it and do whatever gives the 

03:40:19.856 --> 03:40:25.556
best user experience.  Tools not
 rules is a guiding principle 

03:40:25.821 --> 03:40:28.911
here.  At the end of the 
question, we will show a set of 

03:40:28.912 --> 03:40:32.007
links to resources and 
documentation for the things 

03:40:32.008 --> 03:40:35.618
that we've been talking about in
 case you don't believe us or 

03:40:35.619 --> 03:40:39.552
want to learn more about a 
particular area.  We've 

03:40:39.553 --> 03:40:42.073
discussing these scripts here, 
but they're old and have been 

03:40:42.074 --> 03:40:46.601
around for years.  There is a 
new way to load JavaScript.  

03:40:46.602 --> 03:40:52.099
Scripts can be loaded as modules
 and this makes it a bit 

03:40:52.535 --> 03:40:56.209
different.  Module scripts are 
internal resources or inline 

03:40:56.210 --> 03:41:01.267
like normal scripts.  exciting 
thing is use import statements 

03:41:01.268 --> 03:41:04.829
to load scripts.  supported in 
safari in the stable version 

03:41:04.830 --> 03:41:10.813
right now, but it's behind the 
flag in Chrome, Firefox and 

03:41:10.975 --> 03:41:15.246
Edge.  I think it's the best way
 to load script.  On that note, 

03:41:15.247 --> 03:41:20.150
here comes a really cruel 
question.  Devices at the ready.

03:41:20.151 --> 03:41:25.430
  Here we According to the 
specification, which of the 

03:41:25.431 --> 03:41:30.383
folks scripts executes first?  
been practicing it backstage in 

03:41:30.384 --> 03:41:37.671
his hotel room.  awkward.  So we
 have type people module and 

03:41:37.672 --> 03:41:42.567
defer with something in line.  
Which one executes first.  What 

03:41:42.568 --> 03:41:49.195
are you saying so far?  There's 
a debate around two answers.  

03:41:49.196 --> 03:41:54.428
It's fairly -- If you haven't 
guessed already, get a guess in.

03:41:54.736 --> 03:42:01.102
 close the question in three, 
two, one.  It's closed.   what 

03:42:01.103 --> 03:42:04.753
we are saying here, some think 
script 1 will execute first, 

03:42:04.754 --> 03:42:08.315
which makes sense in terms of 
numbers.  It's the first number.

03:42:08.988 --> 03:42:12.579
 That's how we write the 
questions.   think script two 

03:42:12.580 --> 03:42:17.880
which isn't the first number.  
The answer, though, it is script

03:42:18.053 --> 03:42:22.332
 3.  Oh, yes.  Someone is very 
happy at the front there

03:42:25.683 --> 03:42:28.897
 okay.  Here's why that is.  The
 way scripts block execution by 

03:42:28.898 --> 03:42:32.781
default while they download, 
that was a bad design mistake.  

03:42:32.782 --> 03:42:35.450
module scripts have a different 
default and are deferred.  The 

03:42:35.451 --> 03:42:39.269
same goes for inline module 
scripts, and this is pretty new.

03:42:39.270 --> 03:42:43.486
  Regular inline scripts cannot 
be deferred, so in this case the

03:42:44.197 --> 03:42:48.156
 attribute is totally ignored 
making it a normal script that 

03:42:48.157 --> 03:42:53.365
executes immediately first.  You
 can use async as well and it 

03:42:53.366 --> 03:42:57.433
can excould you tell us as soon 
as all the imports download.  

03:42:57.434 --> 03:43:01.579
This is important, but not 
fetching it at all is better.  

03:43:01.580 --> 03:43:06.338
We'll take a dive into caching 
stuff, and there are two we're 

03:43:06.339 --> 03:43:09.032
interested in here.  When the 
page fetches something, it looks

03:43:09.259 --> 03:43:17.342
 for a match in the HTBC cash.  
It makes a connection and says, 

03:43:17.343 --> 03:43:21.970
it's this old and shaped.  The 
server can say no, no, don't use

03:43:22.125 --> 03:43:26.504
 that.  a newer version, or it 
sends back a tiny messages 

03:43:26.505 --> 03:43:29.528
saying you're good to use what 
you've got.  If that happens, 

03:43:29.773 --> 03:43:33.105
they send it back to the page.  
 however, the browser makes a 

03:43:33.106 --> 03:43:37.731
fetch and finds a result in the 
HTBC cash but this time it 

03:43:37.732 --> 03:43:42.246
doesn't need to vault date so it
 uses it and doesn't ask the 

03:43:42.247 --> 03:43:48.549
server at all.  That's faster 
for small assets makes the 

03:43:48.864 --> 03:43:53.481
request is the majority of the 
work.   to use it is the cash 

03:43:53.482 --> 03:43:58.726
control response header which 
takes a variety of values.   

03:43:58.921 --> 03:44:03.922
variety. what they are and what 
they do?   didn't.  at the 

03:44:04.054 --> 03:44:09.873
ready.  Here is the next 
question.  This one.  does the 

03:44:09.874 --> 03:44:15.085
header as a response header say 
to do?  put this in the cache?  

03:44:15.086 --> 03:44:19.230
it mean cache it, but you can 
only use it after server 

03:44:19.231 --> 03:44:24.034
validation or cache it and use 
it without server validation for

03:44:26.968 --> 03:44:31.324
 31,536 seconds, which is a 
year. Let's look at the votes.  

03:44:31.325 --> 03:44:39.738
I love it.   on two of them.  
That's exciting.  Some happy and

03:44:39.739 --> 03:44:41.739
 some sad and some

03:44:43.663 --> 03:44:53.171
 confused.  in.  Lock it in.   
you say cache it but

03:44:54.112 --> 03:44:57.502
 you can use it after a 
validation or use it without 

03:44:57.503 --> 03:45:04.093
validation some of you are 
saying.  The answer is, of 

03:45:04.094 --> 03:45:10.497
course, it is you can use it 
without server validate.  Some 

03:45:10.618 --> 03:45:13.530
think it must validate.  That 
would be weird.  It means that 

03:45:13.531 --> 03:45:19.720
the browser once revalidate once
 it expires.  If it's under that

03:45:19.875 --> 03:45:25.616
 age, it can use it without 
checking in with the server.  

03:45:25.617 --> 03:45:33.914
what about this  --  does cache 
instead of using no revalidate. 

03:45:35.235 --> 03:45:40.920
  question, same answer.  Look 
at the voting.  It's easy, 

03:45:41.271 --> 03:45:44.304
right?  We have a 50/50 
situation between two of them.  

03:45:44.305 --> 03:45:48.082
One is winning.  good.  A lot 
concentrating faces in the 

03:45:48.204 --> 03:45:53.148
audience, which makes me very 
happy on the inside.  We're 

03:45:53.149 --> 03:45:59.555
closing the question in three, 
two, one. closed.  Right.  Okay.

03:45:59.556 --> 03:46:06.011
  So we say no cache would mean 
do not put this in the cache.  

03:46:06.012 --> 03:46:13.665
The answer is cache it, but you 
can only use it after server 

03:46:13.970 --> 03:46:19.824
validation.   what some of you 
think no cache is no cache.  

03:46:19.825 --> 03:46:22.825
That's shorthand, so the 
additional Max age is 

03:46:23.003 --> 03:46:26.244
acknowledged.  No cache means 
the browser may use the cache 

03:46:26.245 --> 03:46:29.147
but has to check with the server
 first.  We don't know why 

03:46:29.148 --> 03:46:31.774
they're named like this.  They 
had a lot of features and good 

03:46:31.775 --> 03:46:34.892
names for them, and then they 
put them in a bag and picked 

03:46:34.893 --> 03:46:43.429
them out at random.  This 
happens to involve naming things

03:46:43.640 --> 03:46:47.812
 with cache validation.   
destined to fail.  Like we said,

03:46:47.967 --> 03:46:52.274
 it's best to avoid a request if
 possible, so for some resources

03:46:54.021 --> 03:46:59.386
 treat it as a useable.  Let 
that cache for as long as you 

03:46:59.562 --> 03:47:02.744
can, which is a year.  If you 
wanted to update this resource, 

03:47:02.745 --> 03:47:06.285
you need to change the URL.  
There are a lot of build system 

03:47:06.286 --> 03:47:11.395
tools that help with, one of 
which is web pack.  They all 

03:47:11.396 --> 03:47:17.392
have their own.   plenty of 
them.  Not all is immutable.  

03:47:17.393 --> 03:47:20.734
page that the user visits 
directly.  In this case it's 

03:47:20.735 --> 03:47:24.301
best to use no cache.  That 
means that the browser will 

03:47:24.302 --> 03:47:29.164
check in with the server first. 
 you have private data, tell the

03:47:29.872 --> 03:47:34.003
 browser not to start at all, 
which is working quite a while 

03:47:34.279 --> 03:47:41.426
well.  That came out at the 
right time.  If you've given an 

03:47:41.427 --> 03:47:46.319
untrustworthy person the cache, 
you have bigger problems.  

03:47:46.320 --> 03:47:52.502
People say it's just paranoia.  
 a caching problem we see around

03:47:52.612 --> 03:47:55.505
 the web and leads to weird 
behaviors, because sometimes one

03:47:55.506 --> 03:47:59.856
 of the benefits of avoiding it 
the go going to the network, but

03:47:59.857 --> 03:48:04.560
 haven't set up the build 
system. go with regular URLs 

03:48:04.561 --> 03:48:09.997
like script JS and XPT  expect 
it to change over time and they 

03:48:09.998 --> 03:48:14.853
take a guess.  How does a couple
 of hours sound?  Two hours 

03:48:14.854 --> 03:48:18.598
soundses like a good compromise.
 really isn't.  We see it on 

03:48:18.599 --> 03:48:23.295
static services as well.  Don't 
do this.  Here's why.  Let's say

03:48:23.483 --> 03:48:26.766
 you serve some JavaScript and 
tell it to cache for two hours. 

03:48:27.705 --> 03:48:31.028
 download the lot, right, and 
they have the resources on the 

03:48:31.029 --> 03:48:35.610
cache and on the page.  So far 
so good.  It's all working.  say

03:48:35.790 --> 03:48:41.198
 an hour later you update your H
TML in JavaScript so there's 

03:48:41.199 --> 03:48:45.028
version 2, now.  You don't 
change the URLs.  You browse 

03:48:45.029 --> 03:48:48.306
around the web and the browser 
decides I've had enough of those

03:48:48.548 --> 03:48:51.782
 two and it removes it.  Maybe 
you think why would the browser 

03:48:51.783 --> 03:48:58.457
do that?  The browser can remove
 whenever it wants to. it wants 

03:48:58.458 --> 03:49:02.598
space back.  That's the Max age 
from the point downloaded you 

03:49:02.599 --> 03:49:06.555
can get them out of sync and 
they expire at different points.

03:49:06.556 --> 03:49:09.812
  They get the CSS from the cash
 within the two hours, but the 

03:49:09.813 --> 03:49:12.744
other assets come from the 
network.  There you have version

03:49:13.134 --> 03:49:17.181
 2 of your HTML and JavaScript, 
but you're still on version 1 of

03:49:17.182 --> 03:49:23.740
 the CSS.   result could be fine
 and get away with, maybe, or 

03:49:23.741 --> 03:49:29.248
end it with broken and styled 
stuff.  It's a big gamble and 

03:49:29.249 --> 03:49:34.208
hard to figure out why if it 
breaks.  Either use no cache or 

03:49:34.631 --> 03:49:40.246
immutable resources with a year 
of caching.  Another part of 

03:49:40.247 --> 03:49:45.315
page load is timing.  resources 
start downloading pretty late.  

03:49:45.316 --> 03:49:51.320
The most common is web fonts I 
would say.  They're defined in 

03:49:51.321 --> 03:49:54.169
your CSS including how to 
download them and where to use 

03:49:54.878 --> 03:49:59.577
them.  Once they downloaded CSS 
is performs a recount on the 

03:49:59.797 --> 03:50:04.803
page.  At this point it 
discovers a web fonts  font for 

03:50:04.804 --> 03:50:08.387
one or more paragraphs on the 
page.  The browser lays out the 

03:50:08.388 --> 03:50:12.773
page and paints it, but this 
misses the text that needs the 

03:50:12.774 --> 03:50:17.471
web font.   seen this.  We saw 
this really, really.  I just 

03:50:17.472 --> 03:50:21.225
wanted to read it.  It's pretty 
frustrating, right?  Once the 

03:50:21.226 --> 03:50:24.377
font has downloaded, the browser
 performs again and paints the 

03:50:24.378 --> 03:50:30.756
page this time with the text 
using the web font.   isn't 

03:50:30.964 --> 03:50:33.465
optimal.  It starts to download 
so late and the result is the 

03:50:33.795 --> 03:50:36.852
user is left without content.  
the content on the device and 

03:50:36.853 --> 03:50:43.572
they refuse to download it and 
refuse to paint it.   improve 

03:50:43.573 --> 03:50:47.058
things a lot.  With this in the 
head of the document you need 

03:50:47.746 --> 03:50:50.607
the resource to load the page.  
download happens in parallel 

03:50:50.608 --> 03:50:56.839
with the CSS.  You see the time 
between the download is 

03:50:57.184 --> 03:50:59.729
massively reduced, and that 
means the user gets content 

03:51:00.003 --> 03:51:04.447
quicker, which is great.   you 
use the preload, it's stored in 

03:51:04.448 --> 03:51:10.293
a special preload cache until 
the browser needs it.  We have 

03:51:10.294 --> 03:51:16.138
the preload cache and there's 
another.  In ATV2 the browser 

03:51:16.139 --> 03:51:19.393
can ask the server for something
 and here it is.  Also here's 

03:51:19.394 --> 03:51:25.545
some other stuff you -- this is 
called ACTB2 push.  It sends out

03:51:25.720 --> 03:51:28.313
 an additional response and 
information the browser needs 

03:51:28.314 --> 03:51:32.827
for when to use the responses.  
is, this cache, it's a 

03:51:32.828 --> 03:51:35.095
completely different cache from 
the other two, which brings us 

03:51:35.096 --> 03:51:40.400
to our next question.  Devices 
at the ready.  Which cache does 

03:51:41.202 --> 03:51:47.145
the browser check first?  Is it 
the push cache, the preload 

03:51:47.146 --> 03:51:53.280
cache or HTTP cache.  I didn't 
know this until talking to the 

03:51:53.281 --> 03:51:57.786
networks team.  This is what we 
see here.   answer more than

03:52:00.952 --> 03:52:05.810
 others.  The confidence is 
waning, Jake.  Hit that submit 

03:52:05.952 --> 03:52:10.525
button.  We're closing the 
question.  Three, two, one.  

03:52:10.652 --> 03:52:18.185
closed.  Oh, the HTTP cache is 
winning that one.   answer among

03:52:18.677 --> 03:52:21.808
 Googlers when we did rehearsal.
  Just like the Googlers, wrong.

03:52:21.809 --> 03:52:26.625
  The correct answer is the 
preload cache.   As you can see,

03:52:26.759 --> 03:52:30.192
 some of these questions are 
deliberately obscure, so really 

03:52:30.193 --> 03:52:36.588
do not feel bad if you get them 
wrong.  A Googler was in a 

03:52:37.139 --> 03:52:40.827
rehearsal.   all fired, by the 
way.  They don't work here 

03:52:41.103 --> 03:52:43.934
anymore.  If you end up with a 
top score, it means you didn't 

03:52:43.935 --> 03:52:49.425
learn a lot from this talk.  You
 wasted your time.  Unless you 

03:52:49.598 --> 03:52:53.005
win the mouse pad.  That's 
desirable prize.  I'm glad they 

03:52:53.554 --> 03:52:57.078
didn't applaud that. cache is in
 play here, and it's pretty 

03:52:57.079 --> 03:53:01.815
complicated but knowing the 
stuff helps to prevent loads of 

03:53:01.816 --> 03:53:08.817
weird bugs.  browser fetches it 
as normal to the server and it 

03:53:08.818 --> 03:53:11.898
ends up in the memory cache 
alongside the page.  The things 

03:53:11.899 --> 03:53:17.201
to note is your preloaded stuff 
comes from the HTTP cache, but 

03:53:17.202 --> 03:53:19.935
also since it sits with the 
page, other pages don't use it. 

03:53:20.538 --> 03:53:24.122
 They may have their own preload
 caches, but one page doesn't 

03:53:24.123 --> 03:53:30.216
use another page.   pointsless 
for another page and maybe the 

03:53:30.217 --> 03:53:36.935
next page.  page has its own 
preload cache.  The cash sits 

03:53:36.936 --> 03:53:40.400
with the connection, and that 
makes it pretty difficult to 

03:53:40.664 --> 03:53:44.568
preload because two pages share 
it so they can share the same 

03:53:44.569 --> 03:53:51.340
push cache.  Things for one page
 may be consumed by another. 

03:53:51.341 --> 03:53:57.987
That's pretty complicated.  You 
can push something the user has 

03:53:57.988 --> 03:54:04.905
in their cache.  No browser does
 that yet.  The answer to the 

03:54:04.906 --> 03:54:08.764
actual question, it checks the 
preload cache first and the HTTP

03:54:08.911 --> 03:54:14.275
 cache and then the push  That's
 it.  a good thing to keep in 

03:54:14.397 --> 03:54:18.427
mind.  It's a bit out there, but
 at the same time if you find 

03:54:18.428 --> 03:54:20.697
you've got weird behaviors, it's
 good to know where to start

03:54:24.101 --> 03:54:29.023
 I think HTTP is powerful and 
low level and many cases preload

03:54:29.231 --> 03:54:37.442
 is a simpler, more reliable St.
 Louis and  -- and DevTools are 

03:54:37.698 --> 03:54:42.099
available.   we look at the 
leaderboard?  Let's see how 

03:54:42.100 --> 03:54:48.950
you're doing.  Oh.  One person 
is in the lead at the moment.  A

03:54:49.791 --> 03:54:59.667
ndreiis first at 20 points.  
We're only halfway through.  CSS

03:55:00.032 --> 03:55:03.471
 and rendering, that might be 
your thing and might be your 

03:55:03.472 --> 03:55:09.235
time to shine.   talk a little 
about rendering.  are important 

03:55:09.236 --> 03:55:11.491
to communicate to the user and 
they look really cool.  We've 

03:55:11.492 --> 03:55:15.340
had a lot of fun with animation 
so far.  Badly performing 

03:55:15.341 --> 03:55:19.107
animation can be really jarring,
 often worse than any animation 

03:55:19.108 --> 03:55:23.795
at all. Modern browsers have 
compositing, and this means they

03:55:23.911 --> 03:55:27.463
 take an particular element and 
temporarily isolates it into its

03:55:27.669 --> 03:55:30.817
 own layer.  If the conditions 
are correct, the browser does 

03:55:30.818 --> 03:55:36.064
this automatically for 
animation.  It minimizing it as 

03:55:36.065 --> 03:55:39.271
the browser doesn't keep 
repainting the thing behind the 

03:55:39.272 --> 03:55:42.955
element doing the animation.  At
 the end of the animation, it 

03:55:42.956 --> 03:55:45.702
can merge down and FLAPTen that 
content back with the other 

03:55:45.703 --> 03:55:54.284
content on the page.  As Paul 
said, it needs to be correct to 

03:55:54.815 --> 03:55:59.335
happen.  We're animating a 
circle in the SVG.  Which will 

03:55:59.336 --> 03:56:08.900
be deposited in Chrome 57.  Is 
it center X, center X transform 

03:56:08.901 --> 03:56:16.058
and transform and opacity.   
like your quiz How do you vote 

03:56:16.182 --> 03:56:20.441
now?  Strong feelings, free of 
them and less confident with one

03:56:20.442 --> 03:56:22.879
 of them.  Get a guess in if you
 haven't already.  We're going 

03:56:22.880 --> 03:56:28.281
to close the question in three, 
two, one.  Don't forget to hit 

03:56:29.811 --> 03:56:33.771
submit.  So we have a transform 
there, so yeah, that's the 

03:56:33.899 --> 03:56:38.857
transform.  The correct answer 
is none

03:56:43.444 --> 03:56:48.371
 of them.  That's cruel, isn't 
it?  I know.  For implementation

03:56:48.503 --> 03:56:52.448
 in Chrome today, it's fair to 
say we'd love to see it change, 

03:56:52.449 --> 03:56:57.105
compositing never happens for 
elements inside of an SVG 

03:56:57.263 --> 03:56:59.491
element.  This means your 
animations are going to paint as

03:56:59.647 --> 03:57:03.075
 a flat, single layer every 
frame. 

03:57:06.564 --> 03:57:12.605
 Edge and Firefox support but 
Chrome does not.  Is it 

03:57:12.606 --> 03:57:17.476
something we're looking at?  
We'll post a link to the Chrome 

03:57:18.039 --> 03:57:27.353
book.  That's SVG. talk about 
your standard issue dom.  Which 

03:57:27.354 --> 03:57:30.431
of the following automations can
 be deposited in Chrome 57.  Is 

03:57:30.432 --> 03:57:35.717
it margin left, within 
transform, transform or opacity.

03:57:35.718 --> 03:57:43.346
  Can I XHENDZ commend you on 
your quiz voice?  Let's look at 

03:57:43.347 --> 03:57:47.815
the voting.  Similar kind of 
feel to last time, I'd say.  

03:57:47.816 --> 03:57:51.315
People are holding onto their 
previous answers.  Will it pay 

03:57:51.316 --> 03:58:00.797
off for them?  It's a bold play.
  Three, two, one.  We close.  

03:58:00.798 --> 03:58:06.707
The margin left is less 
confident on.  The correct 

03:58:06.708 --> 03:58:08.708
answer is, of course,

03:58:10.910 --> 03:58:16.252
 three.  That was a good show.  
 that transitions on opacity 

03:58:16.253 --> 03:58:20.411
will transform.  If you declare 
the animation up front using 

03:58:20.945 --> 03:58:23.668
CSS, the browser can probably 
move the whole thing away from 

03:58:23.669 --> 03:58:31.481
the main thread.  It can 
continue junk-free even if it's 

03:58:31.867 --> 03:58:35.380
busy.  If it's deposited it may 
have a frame by frame dependency

03:58:35.633 --> 03:58:39.047
 on the main spread.  
Absolutely.  correct answer of 

03:58:39.048 --> 03:58:42.339
with two seconds, transform two 
seconds is one of these.  Sure, 

03:58:42.340 --> 03:58:46.535
the element was going to get so 
late if you animate transform.  

03:58:47.645 --> 03:58:52.875
 true.  If you animate width, 
even if something has its own 

03:58:53.000 --> 03:58:57.499
layer, you will trigger the 
layout and paint per frame.  

03:58:57.500 --> 03:59:04.429
These are bound pieces of word. 
 It's true they're faster in 

03:59:04.430 --> 03:59:08.318
layers of paint.  You try to do 
layout and paint per frame is 

03:59:08.319 --> 03:59:13.064
not normally fast on a 
smartphone.  In fact, layout is 

03:59:17.268 --> 03:59:20.932
scoped to the DON dom, that's 
what you have.  That's not what 

03:59:20.933 --> 03:59:24.348
you want from animation.   have 
to stick to transforms and 

03:59:24.349 --> 03:59:28.407
opacity and animate the 
properties.  Just because an 

03:59:28.408 --> 03:59:31.446
element has its own layer 
doesn't mean it's safe to start 

03:59:31.792 --> 03:59:33.792
animating properties like left 
or margin or something like 

03:59:34.081 --> 03:59:37.850
that.  Let's switch to 
event-based animation and get 

03:59:37.851 --> 03:59:43.895
JavaScript in there as well.  Is
 this your favorite?   really 

03:59:43.896 --> 03:59:47.383
enjoy this one.  You have an 
element with no transform and 

03:59:47.384 --> 03:59:53.098
the following code.  According 
to the specification, what 

03:59:53.207 --> 03:59:59.867
happens next?  What's going on? 
Does it transform?  We have a 

03:59:59.868 --> 04:00:04.568
position on transform, and we 
set it to 100 pixels and it 

04:00:04.569 --> 04:00:11.730
slides to the left and right or 
snap to 100 pixels.  Let's see 

04:00:11.731 --> 04:00:14.173
how people are voting.  There's 
one answer that people -- what's

04:00:14.704 --> 04:00:17.840
 interesting is two answers are 
unpopular, and I thought would 

04:00:18.338 --> 04:00:20.610
have been significantly less 
popular than any of them.  Turns

04:00:22.112 --> 04:00:27.840
 out not.  Get a guess in if you
 haven't already.  Hit submit.  

04:00:27.841 --> 04:00:32.623
closing the question in 3, 2, 1.
  You're locked in.  

04:00:32.898 --> 04:00:42.406
Interesting.  people think it  
does the Maceren

04:00:42.963 --> 04:00:45.735
a.  You have given up on the 
quiz.  One of the highest scores

04:00:45.887 --> 04:00:49.193
 in HEE herselfal was the design
 advocate, and he's just making 

04:00:49.194 --> 04:00:54.922
random guesses.   anymore.  The 
correct answer, of course, when 

04:00:54.923 --> 04:01:00.188
it appears on the screen, it 
slides to the right.  Now, Paul,

04:01:00.359 --> 04:01:05.246
 I did maps at school, and I was
 led to believe that 200 is a 

04:01:05.247 --> 04:01:10.594
bigger number than 100.  
Therefore moving from 100 to 200

04:01:10.746 --> 04:01:16.107
 would be to the left.  While I 
agree with you, you did say 

04:01:16.295 --> 04:01:19.966
maths, and I think it will be 
math.  I don't know.  It's 

04:01:20.314 --> 04:01:26.022
Matttics so the abelieve YAGS is
 maths is my strong opinion.  

04:01:26.190 --> 04:01:29.527
America, I could live with it, 
but then you took the S you 

04:01:29.528 --> 04:01:35.892
saved and you put it on the end 
of Lego.  Legos, the toy is 

04:01:36.147 --> 04:01:40.280
Lego.  Legos is an island off 
the coast of Spain

04:01:44.624 --> 04:01:54.036
 probably.  Let's move on.  does
 it slide to the right?  

04:01:54.037 --> 04:01:57.444
Browsers try to reduce the 
workload, and they run event 

04:01:57.445 --> 04:02:01.655
call backs.  At the end the 
renders pass begins and they 

04:02:01.656 --> 04:02:07.181
take stock of any style changes.
  By that point that translate 

04:02:07.182 --> 04:02:11.021
into 200 pixels has been written
 over by 100 pixels. the browser

04:02:11.177 --> 04:02:13.928
 is concerned, the animation 
should be from no transform at 

04:02:13.929 --> 04:02:18.893
all to 100 pixels.  When the 
frame is shipped, it will slide 

04:02:18.894 --> 04:02:26.082
to the right.  Thousand the dom 
layer sees it, we do it before 

04:02:26.083 --> 04:02:31.705
it takes note of it, right?  
Exactly.  If we slide from the 

04:02:31.706 --> 04:02:38.666
right to left, it takes hold 
before we overwrite it to 100 

04:02:39.089 --> 04:02:42.636
pixels.  that in mind, here's 
the next question.  You have an 

04:02:42.637 --> 04:02:45.963
element with no transform.  It's
 the same question, really, and 

04:02:45.964 --> 04:02:49.774
the difference is we have that 
final transform wrapped inside a

04:02:50.062 --> 04:02:54.384
 request animation frame.  Does 
it slide to the right?  Does is 

04:02:54.385 --> 04:02:59.492
it slide to the left?  Does is 
it snap to 100 pixels and does 

04:02:59.493 --> 04:03:04.479
it feel only sadness?  Basically
 a web developer.  Let's see how

04:03:04.607 --> 04:03:10.450
 you are voting.  We're less 
sure this time dividing the room

04:03:10.583 --> 04:03:13.886
 except for one particular 
answer.  Guess a guess in if you

04:03:14.003 --> 04:03:16.381
 haven't already.  We're closing
 the question in three, two, 

04:03:16.382 --> 04:03:18.382
one.

04:03:19.858 --> 04:03:24.432
 locked in.  So what do we see 
here.  Pretty much equal 

04:03:24.523 --> 04:03:27.795
guessing.  That tends to happen 
with this quiz at this point.  

04:03:27.796 --> 04:03:33.014
just spread out evenly among the
 non-ridiculous answers.  The 

04:03:33.015 --> 04:03:39.347
correct answer, though, is once 
again it slides to the right.  

04:03:39.595 --> 04:03:43.352
Watch, tah-dah!   Tell me why. 

04:03:47.606 --> 04:03:52.611
  the transforms are 200 pixels 
and thought we waited a frame 

04:03:52.612 --> 04:03:58.234
and set it to 100 pixels.  
Surely it took hold and we 

04:03:58.455 --> 04:04:02.099
animated.  But, no, the spec 
says once again things should be

04:04:02.100 --> 04:04:06.008
 different to them.   the same 
as before.  The event callback 

04:04:06.009 --> 04:04:10.242
is part of a task, and we get to
 the rendering bits of the event

04:04:10.622 --> 04:04:14.676
 loop and that is animation 
callbacks and they think about 

04:04:14.677 --> 04:04:18.084
styles and such doing the actual
 painting because they happen 

04:04:18.085 --> 04:04:22.146
before the calculation, the net 
result is the same.  We overrate

04:04:22.283 --> 04:04:25.756
 the value before the style 
system sees it. talk about what 

04:04:25.757 --> 04:04:32.252
we can do then if we wanted to 
solve this. apply is to not call

04:04:32.711 --> 04:04:36.732
 request animation frame but 
call it twice.  Take that in and

04:04:38.143 --> 04:04:43.515
 injoy that.  If you request an 
animation callback while it's 

04:04:43.670 --> 04:04:46.719
running, they will run in the 
next event loop, which would 

04:04:46.720 --> 04:04:49.959
mean you have something at 200 
pixels before transferring to 

04:04:50.225 --> 04:04:56.327
100 pixels.  The downside is you
 have ridiculous-looking code 

04:04:56.528 --> 04:05:00.656
and in extra frame.  In Safari 
you wait two frames because they

04:05:01.030 --> 04:05:07.096
 don't follow the specs.  They 
follow the expectations.   we 

04:05:07.097 --> 04:05:10.746
thought Chrome was buggy.  CR 
bug and everything.  Perhaps you

04:05:10.856 --> 04:05:13.842
 don't want to do so this kind 
of ridiculous double wrapping 

04:05:13.843 --> 04:05:19.504
and you want to force that style
 recalculation to happen 

04:05:19.649 --> 04:05:22.359
synchronously.  You see it 
transform before it changes to 

04:05:22.708 --> 04:05:28.666
100 pixels.  SHA we have a 
question on that?  Here it says 

04:05:28.876 --> 04:05:34.561
answering this here to force a 
synchronous update in Chrome 57.

04:05:35.201 --> 04:05:39.163
 width and get computed style in
 a text.  Select all that apply.

04:05:39.164 --> 04:05:44.426
  Multi-select one.  Let's see 
how people are voting.  We're 

04:05:44.427 --> 04:05:48.581
confident on one of them, unsure
 about two of them.  One of them

04:05:48.769 --> 04:05:53.178
 is out of room.  It's kind of 
REEZing.  We close the question 

04:05:53.179 --> 04:05:58.876
in a couple of seconds so take a
 guess if you haven't already.  

04:06:00.491 --> 04:06:05.964
button.  It's done.  That could 
be the style there being the 

04:06:05.965 --> 04:06:09.006
most popular of all the answers.

04:06:14.703 --> 04:06:20.550
 The correct answer is anything 
but get computed style.  Here's 

04:06:20.783 --> 04:06:25.562
why.  browser starts off knowing
 the layout of every element.  

04:06:25.563 --> 04:06:29.233
they need to know that stuff to 
draw what you saw on the frame 

04:06:29.374 --> 04:06:34.130
before.  Translate X to 200 
pixels meaning the browser's 

04:06:34.131 --> 04:06:36.401
calculations aren't up to date. 
 That isn't a problem because 

04:06:36.402 --> 04:06:39.952
the browser recomputes 
everything to update the 

04:06:40.427 --> 04:06:44.731
rendering.  If we call get 
bounding clients in a width or 

04:06:45.496 --> 04:06:48.471
text, they will to recalculate 
it synchronously in order to 

04:06:48.794 --> 04:06:53.153
give you the correct answer.   
you ask for the width of an 

04:06:53.283 --> 04:06:55.912
element, the browser has to 
figure out what changed and then

04:06:56.089 --> 04:07:00.912
 and only then does it give you 
the answer.  All the correct 

04:07:00.913 --> 04:07:04.469
answers cause that to happen.  
The most surprising one is in a 

04:07:04.643 --> 04:07:08.922
text.  In a text it has a layout
 dependency because it won't 

04:07:08.923 --> 04:07:11.743
give you the text of the inner 
elements and has dependencies on

04:07:12.120 --> 04:07:20.075
 line layout as well.  Five five
   JAKE ARCHIBALD:  Five the 

04:07:20.217 --> 04:07:25.858
problem is they have heavyweight
 options.  Not per frame in the 

04:07:26.478 --> 04:07:33.798
previous example.  Since they 
scale, they push it back.  You 

04:07:33.799 --> 04:07:38.534
have to wait a few milliseconds.
 he'd like to do is avoid 

04:07:38.535 --> 04:07:41.605
calculating layout if possible, 
which we can do with get 

04:07:41.606 --> 04:07:44.096
computed style.  You might have 
noticed that wasn't one of the 

04:07:44.097 --> 04:07:47.120
correct answers, and that's 
because things are ever so 

04:07:47.121 --> 04:07:52.851
slightly nuanced here.  You 
might think get computer style 

04:07:52.852 --> 04:07:56.469
captures the styles.  No, 
whether it's cold, but it's not.

04:07:58.074 --> 04:08:01.525
 if you do the styles before 
checking a property. style 

04:08:01.526 --> 04:08:07.150
subject, you get the second 
value and not the first.  This 

04:08:07.151 --> 04:08:10.126
blew my mind first.  The styles 
aren't computes when you call 

04:08:10.127 --> 04:08:13.008
the big get computer styles 
function, they're computed when 

04:08:13.009 --> 04:08:18.170
you access one of the properties
 of the object it returns.  So 

04:08:18.171 --> 04:08:22.206
work around this weirdness, you 
have get computer style and

04:08:26.146 --> 04:08:27.594
 access one of the properties 
like transform.  In the question

04:08:27.595 --> 04:08:35.916
 we didn't transform it.  This 
is a nice and imperative API to 

04:08:35.917 --> 04:08:41.222
do animations and make use of 
compositng and everything. 

04:08:41.514 --> 04:08:45.355
animations, not great support 
out there.  It's basically 

04:08:45.356 --> 04:08:51.621
partial SAPT in Chrome and 
Firefox.  It's not in Edge or 

04:08:51.835 --> 04:08:55.611
Safari.  While it is an option, 
you probably use get computed 

04:08:55.612 --> 04:08:59.489
style for the time being.  With 
both network and rendering 

04:08:59.490 --> 04:09:07.642
people hopefully fairly happy, 
but it isn't over  Let's bring 

04:09:07.643 --> 04:09:08.231
on the the quick fire round, the
 silly questions that didn't fit

04:09:08.232 --> 04:09:13.470
 into the narrative of the talk 
anyway.  Pretty much.  first one

04:09:13.707 --> 04:09:22.547
 of these.  Ready?  go.  Quick 
fire is quick.  happens with

04:09:25.191 --> 04:09:27.229
 foo? 

04:09:30.281 --> 04:09:35.963
 Get an answer in quickly.  We 
have one answer that's popular. 

04:09:36.162 --> 04:09:38.748
 Take a guess because we close 
the question in three, two, one.

04:09:38.749 --> 04:09:44.180
  called quick fire for a 
reason.  200 pixels is the most 

04:09:44.181 --> 04:09:49.883
popular answer there.  According
 to the CSS spec, here we go.  

04:09:51.986 --> 04:09:56.142
al GOE HIMENT fight is to figure
 out the tentative height.  If 

04:09:56.143 --> 04:10:00.523
it's bigger reduce it.  A bit 
smaller than min height, grow 

04:10:00.645 --> 04:10:06.756
it.   no idea what you said.  It
 means minimum high always wins.

04:10:06.757 --> 04:10:09.974
  Another quick fire question.  
This is my favorite.  After 

04:10:09.975 --> 04:10:16.480
running this code, which of the 
following is set to 1?  We have 

04:10:16.481 --> 04:10:25.498
the 8 array and we set a bunch 
of items there to one.   

04:10:25.499 --> 04:10:28.845
suggestion is one or more may 
not work.  an answer in quickly.

04:10:28.846 --> 04:10:33.465
  Big thanks to the team.  We 
didn't know anything about it.  

04:10:33.466 --> 04:10:35.466
Judging by the spread of 
answers, you know nothing about 

04:10:35.566 --> 04:10:38.677
it.  It's fine.  We're all 
friends here.  great.  We're 

04:10:38.678 --> 04:10:43.103
locking it in in three, two, 
one.  There we go. 

04:10:46.626 --> 04:10:49.821
 Okay.  Who knows.  The correct 
answers, though, here they come 

04:10:49.822 --> 04:10:55.612
from the server, which is 
getting slow.  There we go.  1.9

04:10:56.041 --> 04:11:01.324
 and 1 point north.    pretty 
weird.  When you do this kind of

04:11:01.633 --> 04:11:06.689
 thing and assign with a string,
 JavaScript needs to solve if 

04:11:06.690 --> 04:11:12.498
you prescribe to a property of 
the product or an array.  It's 

04:11:12.499 --> 04:11:16.281
treated like array and so is 
strings if it's a representation

04:11:16.531 --> 04:11:24.457
 of a number.  When I first 
heard that, I had no idea that 

04:11:24.781 --> 04:11:31.093
meant.  What is this about?  .9 
is not an key no, ma'am Cal 

04:11:32.158 --> 04:11:36.645
representation.   will treat it 
as a property assignment and 

04:11:36.646 --> 04:11:43.528
that's fine.  Say for 1.0.  1.1 
is the representation of 1.1 so 

04:11:43.652 --> 04:11:50.772
JS treats it as a number.  It 
trials to assign to the 1.1 item

04:11:50.939 --> 04:11:55.683
 of the array.  It's silently 
acknowledged.  Why TROE an 

04:11:55.937 --> 04:12:00.580
error.  The same for 1.2 and 
same kind of deal.   to the last

04:12:00.784 --> 04:12:04.271
 question.  We're going to move 
on if any clicker continues to 

04:12:04.929 --> 04:12:09.419
work.  That makes me happier. at
 the ready.  Here we go.  Five 

04:12:09.420 --> 04:12:16.192
how many elements are created?  
Plus equal, plus equal, plus 

04:12:16.352 --> 04:12:20.140
equal.  How many elements does 
it create.  Let's see how 

04:12:20.141 --> 04:12:27.667
they're voting.  Quick firing.  
We have two strong answers and 

04:12:27.668 --> 04:12:31.459
two people are DMISive.  We 
close in three, two, one.  We 

04:12:31.460 --> 04:12:38.781
are closed.  So we saw 4 and 1 
are the most popular answers of 

04:12:38.782 --> 04:12:42.258
the room.  The correct answer, 
of course,

04:12:47.176 --> 04:12:51.552
 Why is this, then?  When you 
use plus equals and it's 

04:12:52.062 --> 04:12:54.583
equivalent.  It's a read and 
write.  So if we expand this out

04:12:54.734 --> 04:13:00.375
 further, we create 1, 2, 3, 4, 
5, 6, 7, 8, 9, 10 elements.  

04:13:00.376 --> 04:13:09.898
There you go.  There you go.  
to, you can insert HTML which is

04:13:11.466 --> 04:13:17.029
 ancient.  Thank you, Internet 
Explore for her R the API.  

04:13:17.030 --> 04:13:20.790
We'll do the final question of 
the whole quiz now.  might be my

04:13:20.926 --> 04:13:25.139
 favorite, this one.  Given this
 chunk of HTML, which resources 

04:13:25.140 --> 04:13:31.309
are requested?  We've got an 
image of a source and excellent 

04:13:31.310 --> 04:13:37.583
and a script of a source and the
 preload.  It's select many, so 

04:13:37.584 --> 04:13:42.489
select all that you think apply.
 One, two, three, and four.  

04:13:42.490 --> 04:13:46.763
Let's see the answers.  A real 
spread here.  kind of confident.

04:13:46.764 --> 04:13:52.646
  Wow. anyone else see that?  a 
large amount of bird mess that 

04:13:52.647 --> 04:13:55.396
just landed right in front of 
us.  That is incredible

04:13:57.900 --> 04:13:59.841
incredible.  Someone didn't pick
 the right answer in the last 

04:13:59.842 --> 04:14:03.608
round.  Fair enough.  Okay.  I'm
 going to step back a little 

04:14:03.802 --> 04:14:05.802
bit. going to close the question
 in three, 

04:14:09.471 --> 04:14:17.237
 it goes.  So a sort of spread 
there of the answers.   ones 

04:14:17.238 --> 04:14:22.000
actually are requested.  so 
good.  

04:14:25.473 --> 04:14:27.473
    JAKE ARCHIBALD:  It is just 
one.  I don't know how many 

04:14:27.478 --> 04:14:33.986
spotted what was going on here. 
 Even though it's an IMADE image

04:14:34.336 --> 04:14:40.786
 it's a AMD image, so this 
downloads.  This uses script, so

04:14:41.179 --> 04:14:45.642
 the browser just ignores it and
 doesn't download. like that 

04:14:46.097 --> 04:14:51.130
one.  Have you noticed that that
 code highlight has all but 

04:14:51.435 --> 04:14:55.981
gone.  Why has it changed?  In 
HTML script elements cannot be 

04:14:56.486 --> 04:14:59.050
self-closing. doesn't work.  You
 have to close scripts with a 

04:14:59.051 --> 04:15:01.051
proper closing script tag. 

04:15:05.527 --> 04:15:10.552
 The browser are those two 
LIFRNG  link elements in 

04:15:10.553 --> 04:15:15.548
JavaScript and throw an error.  
Sorry, not sorry.   sorry.  This

04:15:15.549 --> 04:15:19.232
 is it.  The moment we have been
 waiting almost 45 minutes for. 

04:15:19.521 --> 04:15:27.725
 are the winners of the mouse 
pad?  Let's find out.  Oh.  

04:15:28.524 --> 04:15:32.332
Betts.  Congratulations.  All 
three of you have won the mouse 

04:15:32.498 --> 04:15:36.939
pad.  A big round of applause to
 the three winners.  this 

04:15:37.047 --> 04:15:40.328
session, find us and come to the
 front with our phone and prove 

04:15:40.329 --> 04:15:45.390
you did get that score.  BIG WEB
 QUIZ has a detail behind the 

04:15:45.391 --> 04:15:48.567
questions we asked today.  With 
that, it's been a pleasure and a

04:15:48.725 --> 04:15:51.993
 blast.  so much for playing 
along.  Thank you, 

04:15:55.835 --> 04:15:57.835
Applause )

