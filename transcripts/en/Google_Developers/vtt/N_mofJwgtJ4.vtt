WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.540
IAN BARBER: If any of you worry
there's no space at the

00:00:03.540 --> 00:00:04.710
front, there's plenty.

00:00:04.710 --> 00:00:06.980
Feel free to move.

00:00:06.980 --> 00:00:07.920
So my name's Ian.

00:00:07.920 --> 00:00:10.282
I'm a developer advocate
with Google+.

00:00:10.282 --> 00:00:14.010
And I'm going to talk today
a little bit about using

00:00:14.010 --> 00:00:16.950
authentication systems for
multiple providers in your

00:00:16.950 --> 00:00:21.610
code without having it turn into
a giant ball of hay that

00:00:21.610 --> 00:00:24.480
you don't want to deal with.

00:00:24.480 --> 00:00:29.310
Hopefully over the last day and
a half, you've seen some

00:00:29.310 --> 00:00:32.360
things about sign-in in general,
maybe Tim Bray's

00:00:32.360 --> 00:00:35.150
identity talk yesterday.

00:00:35.150 --> 00:00:38.630
And you'll know that sign-in
is difficult.

00:00:38.630 --> 00:00:42.800
It's very easy to make a fragile
implementation of

00:00:42.800 --> 00:00:47.440
identity, of passwords, of
dealing with account recovery,

00:00:47.440 --> 00:00:48.860
things like two-factor auth.

00:00:48.860 --> 00:00:50.430
It's complicated.

00:00:50.430 --> 00:00:52.420
And it's nice that you
can defer that.

00:00:52.420 --> 00:00:55.190
You can hand that off to some
other party who's got the

00:00:55.190 --> 00:00:58.220
engineering, who's got the
privacy and the security teams

00:00:58.220 --> 00:00:59.360
to look after it.

00:00:59.360 --> 00:01:02.190
So I think social

00:01:02.190 --> 00:01:03.330
authentication is a good thing.

00:01:03.330 --> 00:01:06.300
I think third party identity
providers are a good thing.

00:01:06.300 --> 00:01:08.450
But it doesn't necessarily
follow that it's a good thing

00:01:08.450 --> 00:01:12.030
to have multiple providers
on, right?

00:01:12.030 --> 00:01:13.640
You can easily get into a
situation where you have

00:01:13.640 --> 00:01:16.035
hundreds of buttons, and no
one wants to deal with it.

00:01:16.035 --> 00:01:19.710
But I think it is worth
considering adding more than

00:01:19.710 --> 00:01:23.120
one identity provider
to your application.

00:01:23.120 --> 00:01:25.660
I think there's a reason that
it's good for you, and there's

00:01:25.660 --> 00:01:27.000
a reason that it's good
for the users.

00:01:27.000 --> 00:01:29.590
For the users, it gives
them choice.

00:01:29.590 --> 00:01:31.240
And that choice is valuable.

00:01:31.240 --> 00:01:35.390
That choice allows them to
choose the one they're most

00:01:35.390 --> 00:01:38.120
familiar with, choose the
one that works for them.

00:01:38.120 --> 00:01:41.270
But it also allows them to
express a facet of their

00:01:41.270 --> 00:01:42.590
personality.

00:01:42.590 --> 00:01:44.870
We don't all use the internet
in the same way.

00:01:44.870 --> 00:01:47.720
And we don't all use every
service in the same way.

00:01:47.720 --> 00:01:50.320
I have certain friends on
certain sites and certain

00:01:50.320 --> 00:01:53.350
networks, and certain interests
that I post there.

00:01:53.350 --> 00:01:57.190
If I can sign into your app
with the network that most

00:01:57.190 --> 00:02:00.510
closely aligns to my interest,
I can express myself more

00:02:00.510 --> 00:02:02.070
accurately.

00:02:02.070 --> 00:02:06.990
As a developer, the big gain is
that these days, identity

00:02:06.990 --> 00:02:08.370
providers don't just
provide identity.

00:02:08.370 --> 00:02:09.520
They provide services.

00:02:09.520 --> 00:02:12.940
And you get access to those
APIs for users as well.

00:02:12.940 --> 00:02:18.030
So it's valuable even if you
have a user who is connected

00:02:18.030 --> 00:02:21.970
to connect an extra network to
have ways of getting into

00:02:21.970 --> 00:02:25.050
additional systems so that you
can enhance your application,

00:02:25.050 --> 00:02:27.270
so that you can add more
services, so that you can do

00:02:27.270 --> 00:02:30.120
things which are a bit
more interesting.

00:02:30.120 --> 00:02:31.660
Now adding an identity
provider isn't

00:02:31.660 --> 00:02:33.070
actually that hard.

00:02:33.070 --> 00:02:36.640
And if you just went out and
tried to implement Google+

00:02:36.640 --> 00:02:41.580
Sign-In or Facebook or Twitter
or LinkedIn or whoever, you'd

00:02:41.580 --> 00:02:43.260
get it done in a reasonably
short time.

00:02:43.260 --> 00:02:46.770
It's somewhere between
days and a few weeks.

00:02:46.770 --> 00:02:52.825
But it's very, very easy to
spread knowledge of how a user

00:02:52.825 --> 00:02:55.710
is created throughout your
system and end up in a case

00:02:55.710 --> 00:02:58.440
where changing it then
becomes tricky.

00:02:58.440 --> 00:03:01.660
When there's an API change, when
there is a newer version

00:03:01.660 --> 00:03:04.420
of something, it becomes
complicated to do so.

00:03:04.420 --> 00:03:07.740
It becomes complicated
to think about it.

00:03:07.740 --> 00:03:10.650
So what I think we need to think
about when we're talking

00:03:10.650 --> 00:03:15.030
about multiple providers is
roughly these four things.

00:03:15.030 --> 00:03:18.220
We have to think about how the
user is authorized and

00:03:18.220 --> 00:03:19.490
authenticated.

00:03:19.490 --> 00:03:22.530
We have to think about what are
the capabilities of the

00:03:22.530 --> 00:03:24.440
various systems we're
integrating with.

00:03:24.440 --> 00:03:27.430
What's shared, and what's
different, what's special.

00:03:27.430 --> 00:03:29.960
We have to think about the
data model on our side.

00:03:29.960 --> 00:03:33.110
And we have to think about the
story for the user side.

00:03:33.110 --> 00:03:35.920
I'm not saying the user
interface or the user

00:03:35.920 --> 00:03:36.520
experience.

00:03:36.520 --> 00:03:40.590
Those are things which have been
covered elsewhere and are

00:03:40.590 --> 00:03:42.090
well worth spending time on.

00:03:42.090 --> 00:03:44.540
But I mean, why does
the user sign in?

00:03:44.540 --> 00:03:46.990
What is the mechanism
they are using?

00:03:46.990 --> 00:03:48.960
Why are they going to go
and press this button?

00:03:48.960 --> 00:03:49.970
What do they get out of it?

00:03:49.970 --> 00:03:52.570
Telling that story is an
important part of it, and

00:03:52.570 --> 00:03:57.440
having a feel for what signing
in means in your application.

00:03:57.440 --> 00:04:01.110
So when I say authorization,
I mean OAuth.

00:04:01.110 --> 00:04:05.340
OAuth is the dominant pattern
for authorizing access to

00:04:05.340 --> 00:04:09.730
services online, on
the web at least.

00:04:09.730 --> 00:04:11.770
And OAuth is very, very
well established.

00:04:11.770 --> 00:04:15.220
OAuth 2.0, standardized, lots
of good implementations.

00:04:15.220 --> 00:04:17.610
Most providers now are working
with OAuth 2.0.

00:04:17.610 --> 00:04:18.769
There are some with
OAuth 1.0, though.

00:04:18.769 --> 00:04:20.440
Twitter, I think, is
a notable example.

00:04:20.440 --> 00:04:23.070
But mostly, it's moved
to OAuth 2.0.

00:04:23.070 --> 00:04:28.900
But OAuth is like giving the
keys to your house to a real

00:04:28.900 --> 00:04:31.650
estate agent to show
people around.

00:04:31.650 --> 00:04:33.420
Those people can come
to your house.

00:04:33.420 --> 00:04:34.910
They can see what's there.

00:04:34.910 --> 00:04:36.720
But they don't know
who you are.

00:04:36.720 --> 00:04:38.760
They just have access.

00:04:38.760 --> 00:04:41.380
So on top of OAuth,
we need to layer a

00:04:41.380 --> 00:04:44.220
service to give us identity.

00:04:44.220 --> 00:04:46.920
And in fact, there's
standardization happening in

00:04:46.920 --> 00:04:48.250
that area as well.

00:04:48.250 --> 00:04:52.410
From the OpenID group, there's
OpenID Connect, which is

00:04:52.410 --> 00:04:56.410
adding standardized identity
services which you can call

00:04:56.410 --> 00:04:58.920
with OAuth authorization.

00:04:58.920 --> 00:05:00.360
And we're involved in it.

00:05:00.360 --> 00:05:01.570
Facebook are involved in it.

00:05:01.570 --> 00:05:03.770
A lot of the big systems
are moving that way.

00:05:03.770 --> 00:05:06.030
And I think that combination
of OAuth 2.0 and OpenID

00:05:06.030 --> 00:05:07.970
Connect is very, very
interesting.

00:05:07.970 --> 00:05:09.990
There's a lot of very valuable
and powerful concepts that

00:05:09.990 --> 00:05:10.820
come out of it.

00:05:10.820 --> 00:05:13.670
And you'll see those spread
through more of the more

00:05:13.670 --> 00:05:17.075
recent systems and services.

00:05:17.075 --> 00:05:19.820
But if you you've done OAuth 2.0
before, you might think of

00:05:19.820 --> 00:05:21.630
a flow something like this.

00:05:21.630 --> 00:05:22.280
There's an app.

00:05:22.280 --> 00:05:24.250
It generates a URL.

00:05:24.250 --> 00:05:26.340
User clicks on the URL,
goes to the provider,

00:05:26.340 --> 00:05:28.750
authenticates, comes back.

00:05:28.750 --> 00:05:31.280
Sends a code to the
application.

00:05:31.280 --> 00:05:33.560
The application then exchanges
it with an identity provider.

00:05:33.560 --> 00:05:34.470
Straightforward, right?

00:05:34.470 --> 00:05:35.870
And this is well covered
by libraries.

00:05:35.870 --> 00:05:37.750
There's tons of libraries out
here who will do OAuth

00:05:37.750 --> 00:05:39.340
exchange for you.

00:05:39.340 --> 00:05:42.410
But even on the web, it's
not that simple.

00:05:42.410 --> 00:05:44.590
If you look at more modern
implementations, like Google+

00:05:44.590 --> 00:05:47.220
Sign-In, like Facebook's
client-side sign-in, you'll

00:05:47.220 --> 00:05:49.570
see they don't actually
redirect the user.

00:05:49.570 --> 00:05:51.840
They spin up an iframe.

00:05:51.840 --> 00:05:55.230
And in the iframe, the user
communicates directly with the

00:05:55.230 --> 00:05:56.930
identity provider.

00:05:56.930 --> 00:06:00.530
And then they communicate with
that iframe via the HTML5 post

00:06:00.530 --> 00:06:01.670
message API.

00:06:01.670 --> 00:06:02.450
That's really cool.

00:06:02.450 --> 00:06:03.330
It's faster.

00:06:03.330 --> 00:06:06.080
You get bi-directional
origin verification.

00:06:06.080 --> 00:06:09.640
You get an ability to do things
like seamlessly sign

00:06:09.640 --> 00:06:11.405
the user in when they
visit a site.

00:06:11.405 --> 00:06:12.530
You like those things.

00:06:12.530 --> 00:06:14.750
But it means this flow
isn't quite right.

00:06:14.750 --> 00:06:16.460
On mobile, it's even worse.

00:06:16.460 --> 00:06:19.750
On mobile, we have the
same flow, maybe.

00:06:19.750 --> 00:06:22.310
But how we actually deal
with that varies.

00:06:22.310 --> 00:06:25.310
Perhaps we'd want to bring a
browser up in the application.

00:06:25.310 --> 00:06:29.600
That could be a WebView in
Android or a UIWebView in iOS.

00:06:29.600 --> 00:06:31.450
We'll have that flow,
and that will work.

00:06:31.450 --> 00:06:33.440
But that's a terrible experience
for the users.

00:06:33.440 --> 00:06:34.830
They definitely don't
have a cookie.

00:06:34.830 --> 00:06:36.230
So they're going to have
to type in their

00:06:36.230 --> 00:06:37.600
username and password.

00:06:37.600 --> 00:06:39.310
And when they do that,
they can't see where

00:06:39.310 --> 00:06:40.020
they're typing it into.

00:06:40.020 --> 00:06:41.680
They can't see the URL bar.

00:06:41.680 --> 00:06:43.850
They can't check the
certificate.

00:06:43.850 --> 00:06:47.400
So maybe it's better to send
them to the system browser.

00:06:47.400 --> 00:06:48.380
They may have cookies there.

00:06:48.380 --> 00:06:49.160
That's great.

00:06:49.160 --> 00:06:51.290
And they can check
the certificate.

00:06:51.290 --> 00:06:52.980
They can see where they are.

00:06:52.980 --> 00:06:54.320
And that helps.

00:06:54.320 --> 00:06:55.020
It's a better experience.

00:06:55.020 --> 00:06:57.720
But the user can still kind
of decide to go and

00:06:57.720 --> 00:06:59.530
do something else.

00:06:59.530 --> 00:07:02.700
So in a lot of cases, it's
actually nicer to authenticate

00:07:02.700 --> 00:07:04.380
via another application.

00:07:04.380 --> 00:07:08.450
If you try and sign in on iOS
with Google+, we'll actually

00:07:08.450 --> 00:07:11.180
take you to the Google+
iOS app.

00:07:11.180 --> 00:07:12.260
And you'll sign in there.

00:07:12.260 --> 00:07:14.120
And that's great because when
you have a nice, fast consent

00:07:14.120 --> 00:07:17.110
screen, you're pretty much
guaranteed to be signed in to

00:07:17.110 --> 00:07:18.410
the actual application.

00:07:18.410 --> 00:07:20.330
And there's no other
navigation.

00:07:20.330 --> 00:07:22.110
You're not going to go off and
look at a bookmark bar or

00:07:22.110 --> 00:07:23.910
something like that.

00:07:23.910 --> 00:07:26.430
And of course, you could have
the actual authentication in

00:07:26.430 --> 00:07:28.360
the device itself.

00:07:28.360 --> 00:07:31.360
And that's something like the
account manager on Android or

00:07:31.360 --> 00:07:34.760
the Social Framework on iOS,
where the accounts live with

00:07:34.760 --> 00:07:36.340
the device.

00:07:36.340 --> 00:07:39.520
And all of these complicate
how we implement even a

00:07:39.520 --> 00:07:41.890
straightforward flow.

00:07:41.890 --> 00:07:45.950
So what we're trying to get
to is something like this.

00:07:45.950 --> 00:07:49.240
People don't use your
app to sign in.

00:07:49.240 --> 00:07:50.560
They sign in to use your app.

00:07:50.560 --> 00:07:52.920
They sign in to get value
out of your app.

00:07:52.920 --> 00:07:55.960
And that's all happening up in
the controllers, in a standard

00:07:55.960 --> 00:07:56.630
sort of MVC pattern.

00:07:56.630 --> 00:07:58.070
The controllers and the users.

00:07:58.070 --> 00:08:00.920
The UI, it's the UX, it's the
logic of what it's doing.

00:08:00.920 --> 00:08:04.360
You don't want to be thinking
in there about how your user

00:08:04.360 --> 00:08:07.270
came to be, about the process
of identification.

00:08:07.270 --> 00:08:10.960
You just want to think about
what you can do with the user.

00:08:10.960 --> 00:08:14.770
So what we want is for that
user to be generic--

00:08:14.770 --> 00:08:17.980
well, specific to your app, but
generic to the provider--

00:08:17.980 --> 00:08:20.000
and useful.

00:08:20.000 --> 00:08:23.745
Down here, though, is where the
actual user is generated.

00:08:23.745 --> 00:08:25.720
That happens in the identity
providers.

00:08:25.720 --> 00:08:28.290
You know they're going to have
to actually sign in there.

00:08:28.290 --> 00:08:30.400
And we don't want that leaking
all the way into the

00:08:30.400 --> 00:08:30.910
controller.

00:08:30.910 --> 00:08:33.539
So we need to put some
layer in between.

00:08:33.539 --> 00:08:36.409
And that's the idea that really
underpins everything

00:08:36.409 --> 00:08:37.090
I'm going to talk about.

00:08:37.090 --> 00:08:39.299
If you take one thing away,
just take that away.

00:08:39.299 --> 00:08:42.289
Try and separate the
provisioning of identity from

00:08:42.289 --> 00:08:46.860
the usage of the user that
has been identified.

00:08:46.860 --> 00:08:48.820
So I've got some code
examples in here.

00:08:48.820 --> 00:08:52.680
And don't worry if you wonder--
you know, you want to

00:08:52.680 --> 00:08:54.270
note some things
or take photos.

00:08:54.270 --> 00:08:56.430
All of the slides will
be online afterwards.

00:08:56.430 --> 00:08:58.670
The video for this talk
will be on YouTube.

00:08:58.670 --> 00:08:59.940
And there is code in here.

00:08:59.940 --> 00:09:02.810
I've got a bit of PHP for the
web, a bit of Java for Android

00:09:02.810 --> 00:09:04.540
and a bit of Objective-C
for iOS.

00:09:04.540 --> 00:09:06.790
But little sample apps will
all be up on GitHub

00:09:06.790 --> 00:09:07.220
afterwards.

00:09:07.220 --> 00:09:11.060
So don't feel like you have
to follow every line.

00:09:11.060 --> 00:09:13.430
But this is kind of what we
want to be able to do.

00:09:13.430 --> 00:09:15.600
We want to be able to
just get a user.

00:09:15.600 --> 00:09:16.360
If I got a user?

00:09:16.360 --> 00:09:17.540
No.

00:09:17.540 --> 00:09:18.960
If I don't, redirect them.

00:09:18.960 --> 00:09:20.460
If I do, use them.

00:09:20.460 --> 00:09:21.250
I just get the name.

00:09:21.250 --> 00:09:22.180
I activate it.

00:09:22.180 --> 00:09:25.440
I don't have to think about
how this user came to be.

00:09:25.440 --> 00:09:27.630
I just have to use it.

00:09:27.630 --> 00:09:29.350
So to do that, we
need to mediate

00:09:29.350 --> 00:09:31.230
access to these things.

00:09:31.230 --> 00:09:34.290
Down this side is roughly
the user's flow if

00:09:34.290 --> 00:09:35.460
they're not logged in.

00:09:35.460 --> 00:09:37.560
They'll come to some part of
your application where they

00:09:37.560 --> 00:09:38.500
need to be logged in.

00:09:38.500 --> 00:09:41.410
They'll be redirected to a login
controller to choose

00:09:41.410 --> 00:09:43.000
their sign-in provider.

00:09:43.000 --> 00:09:45.760
Then something will happen,
depending on the provider.

00:09:45.760 --> 00:09:48.960
And eventually, they'll come
back to the callback, where

00:09:48.960 --> 00:09:51.610
they will be given
back that code.

00:09:51.610 --> 00:09:53.720
They will be given back
some kind of token.

00:09:53.720 --> 00:09:56.680
And we will need to bring that
back into the application and

00:09:56.680 --> 00:09:57.970
sign them in.

00:09:57.970 --> 00:09:59.235
In between, we have this
authenticator.

00:09:59.235 --> 00:10:03.120
And the authenticator is
handling all of the identity

00:10:03.120 --> 00:10:05.350
stuff for the vast majority
of our app.

00:10:05.350 --> 00:10:08.370
In our sample apps, there's
probably more identity code

00:10:08.370 --> 00:10:08.930
than anything else.

00:10:08.930 --> 00:10:11.550
But in reality, the vast
majority of your code should

00:10:11.550 --> 00:10:14.080
be business code, should be
doing what you want it to do.

00:10:14.080 --> 00:10:16.310
So we can get the
user from here.

00:10:16.310 --> 00:10:18.990
We can list the providers so
that we can create the sign-in

00:10:18.990 --> 00:10:20.160
options for them.

00:10:20.160 --> 00:10:23.040
We can take the response from
the outside world and route it

00:10:23.040 --> 00:10:24.700
to the appropriate provider.

00:10:24.700 --> 00:10:28.250
And in all of these cases, we
don't want to have to know

00:10:28.250 --> 00:10:31.850
which each provider is--

00:10:31.850 --> 00:10:33.800
what they're doing,
how they work.

00:10:33.800 --> 00:10:35.070
We want it to be hidden.

00:10:35.070 --> 00:10:36.840
So we need an interface.

00:10:36.840 --> 00:10:39.910
We need to separate the generic
parts of going through

00:10:39.910 --> 00:10:42.510
a sign-in process, checking
whether the user is

00:10:42.510 --> 00:10:45.620
authenticated, signing them in,
verifying that response to

00:10:45.620 --> 00:10:47.770
make sure they're the
user we expect.

00:10:47.770 --> 00:10:49.350
And we need to provide a user.

00:10:49.350 --> 00:10:50.150
That's at the heart of it.

00:10:50.150 --> 00:10:51.770
If we can't provide
a user, we're not

00:10:51.770 --> 00:10:53.080
doing anything useful.

00:10:53.080 --> 00:10:56.390
But then for each individual
provider, we need to implement

00:10:56.390 --> 00:11:00.480
a specific strategy of how to
go and do those things for

00:11:00.480 --> 00:11:01.580
this provider.

00:11:01.580 --> 00:11:04.140
So we have an interface.

00:11:04.140 --> 00:11:07.000
It's how we decompose things
in an OO system.

00:11:07.000 --> 00:11:09.760
We have an interface which
defines exactly that thing.

00:11:09.760 --> 00:11:10.730
These are the functions.

00:11:10.730 --> 00:11:14.330
Now this is PHP, and it's the
web, and it's a slightly noddy

00:11:14.330 --> 00:11:17.120
demo example, so I'm just
getting a markup and getting

00:11:17.120 --> 00:11:18.920
script to actually
do the request.

00:11:18.920 --> 00:11:22.510
You might prefer to get a URL
or to return an object or to

00:11:22.510 --> 00:11:25.370
return a reference
to a template.

00:11:25.370 --> 00:11:26.950
There's 100 different
ways of doing it.

00:11:26.950 --> 00:11:29.070
But the general idea is, you're
going to need something

00:11:29.070 --> 00:11:31.360
that will initiate
the process.

00:11:31.360 --> 00:11:34.730
And that's what that does
in this example.

00:11:34.730 --> 00:11:38.100
So even for a nice,
standards-compliant, OAuth 2.0

00:11:38.100 --> 00:11:40.080
implementation like
GitHub, there's

00:11:40.080 --> 00:11:42.520
things that are specific.

00:11:42.520 --> 00:11:45.430
GitHub have a certain way of
dealing with redirect URIs

00:11:45.430 --> 00:11:47.310
that's not necessarily
the same way every

00:11:47.310 --> 00:11:48.360
other provider does.

00:11:48.360 --> 00:11:50.400
So we need to take that
into consideration.

00:11:50.400 --> 00:11:53.620
They also have their own URLs
for getting a token in the

00:11:53.620 --> 00:11:54.350
OAuth flow.

00:11:54.350 --> 00:11:57.530
They have their own URLs
for exchanging--

00:11:57.530 --> 00:11:59.590
for sending the user
to so that they can

00:11:59.590 --> 00:12:00.830
actually sign in.

00:12:00.830 --> 00:12:02.440
And we want to encapsulate
all that.

00:12:02.440 --> 00:12:03.820
So we have logic like this.

00:12:03.820 --> 00:12:09.610
This is just going to create a
token to avoid CSRF attacks.

00:12:09.610 --> 00:12:13.445
Put that into a URL along with
our client ID, our identifier

00:12:13.445 --> 00:12:17.800
of which application we are with
GitHub, our state value

00:12:17.800 --> 00:12:20.840
there, and the URL we'd like
users to be redirected to

00:12:20.840 --> 00:12:21.690
afterwards.

00:12:21.690 --> 00:12:22.770
All of this is private.

00:12:22.770 --> 00:12:25.350
All of this stays inside
our GitHub class.

00:12:25.350 --> 00:12:27.770
The external surface area
is getting markup.

00:12:27.770 --> 00:12:29.760
And in this case, we're just
going to return a button.

00:12:29.760 --> 00:12:31.515
It's a thing someone
can click.

00:12:31.515 --> 00:12:32.760
It's not complex.

00:12:32.760 --> 00:12:35.500
We just get that URL, whack
it into some HTML,

00:12:35.500 --> 00:12:37.440
someone clicks it, fine.

00:12:37.440 --> 00:12:38.500
When they've done that,
they're going

00:12:38.500 --> 00:12:39.650
to go away to GitHub.

00:12:39.650 --> 00:12:42.670
They'll approve this
access, hopefully.

00:12:42.670 --> 00:12:45.410
And when they come back, they're
going to come back

00:12:45.410 --> 00:12:46.240
with a code.

00:12:46.240 --> 00:12:48.200
That code is going to be sent
to our authenticator.

00:12:48.200 --> 00:12:50.215
Our authenticator is going to
work out which provider it

00:12:50.215 --> 00:12:52.080
needs to go to and
send it to that.

00:12:52.080 --> 00:12:55.350
And at that point, we
need to verify it.

00:12:55.350 --> 00:12:57.345
So in this case, we're going
to do a token exchange.

00:12:57.345 --> 00:13:00.840
And we're going to look at the
results of the token that

00:13:00.840 --> 00:13:01.310
comes back.

00:13:01.310 --> 00:13:03.390
So we take the short-lived
code we're given.

00:13:03.390 --> 00:13:04.590
We send it off to GitHub.

00:13:04.590 --> 00:13:05.990
We get back an access token.

00:13:05.990 --> 00:13:07.910
And we can look at that and see
what we can do with it.

00:13:07.910 --> 00:13:10.920
For example, we can go and get
the user's profile so we know

00:13:10.920 --> 00:13:11.570
their name.

00:13:11.570 --> 00:13:13.275
We know they are.

00:13:13.275 --> 00:13:16.040
Now if we do this with Google+,
we probably want to

00:13:16.040 --> 00:13:17.080
do it a little bit
differently.

00:13:17.080 --> 00:13:20.540
In Google+, we'd like to use
this nice JavaScript

00:13:20.540 --> 00:13:21.380
postMessage flow.

00:13:21.380 --> 00:13:23.180
So the markup isn't a link.

00:13:23.180 --> 00:13:26.440
It's this tag, which has the
g-signing class on it.

00:13:26.440 --> 00:13:29.420
And that's going to generate a
button that's going to trigger

00:13:29.420 --> 00:13:31.700
a JavaScript callback
once they click it.

00:13:31.700 --> 00:13:34.250
And then we can send the
response of that callback back

00:13:34.250 --> 00:13:35.210
to our server.

00:13:35.210 --> 00:13:37.170
So in this case, the user isn't
getting redirected.

00:13:37.170 --> 00:13:39.030
We're handling that through
JavaScript.

00:13:39.030 --> 00:13:41.810
But the same end result
kind of happens.

00:13:41.810 --> 00:13:44.740
Some information comes back to
our server, and we need to

00:13:44.740 --> 00:13:46.300
validate it.

00:13:46.300 --> 00:13:49.030
So we can send it through to our
validate function, which

00:13:49.030 --> 00:13:50.570
looks a bit like this.

00:13:50.570 --> 00:13:51.850
Same idea.

00:13:51.850 --> 00:13:54.000
Exchange token, get the
user's profile.

00:13:54.000 --> 00:13:58.750
In this case, we can use the
Google PHP API client library

00:13:58.750 --> 00:14:00.170
to do that for us.

00:14:00.170 --> 00:14:02.690
But in either case, we
don't have to care.

00:14:02.690 --> 00:14:03.540
We've done that.

00:14:03.540 --> 00:14:04.600
We've got that information.

00:14:04.600 --> 00:14:06.970
We can generate a user and
return it, and our controller

00:14:06.970 --> 00:14:08.580
code just deals with the user.

00:14:08.580 --> 00:14:12.080
Doesn't have to think about
how that user came to be.

00:14:12.080 --> 00:14:15.610
But in our little example, I
was just getting the name.

00:14:15.610 --> 00:14:17.890
And the name's not
very interesting.

00:14:17.890 --> 00:14:20.970
We want to do more interesting
things with the APIs we've

00:14:20.970 --> 00:14:23.630
exposed by signing in
with a provider.

00:14:23.630 --> 00:14:27.200
And that's tricky because when
we're doing that, we need to

00:14:27.200 --> 00:14:29.650
think about what specific
functionality

00:14:29.650 --> 00:14:32.240
each provider provides.

00:14:32.240 --> 00:14:34.270
There's very little that is
shared between everyone you

00:14:34.270 --> 00:14:36.240
could sign in with.

00:14:36.240 --> 00:14:38.390
All we need to do, though, is
to think about what we're

00:14:38.390 --> 00:14:42.240
trying to do rather than how
we're actually doing it.

00:14:42.240 --> 00:14:44.010
If you imagine you had a section
on a site that had a

00:14:44.010 --> 00:14:47.490
kind of "Recommended For You,"
and there was a provider that

00:14:47.490 --> 00:14:51.690
returned an interest list, and
that was a list of entries in

00:14:51.690 --> 00:14:54.360
a database in some graph
database somewhere that said

00:14:54.360 --> 00:14:57.100
what you were interested in or
a list of entities that you

00:14:57.100 --> 00:14:59.855
were interested in, and you were
extracting tags out of

00:14:59.855 --> 00:15:01.230
that and using those
tags to look up

00:15:01.230 --> 00:15:03.200
content in your database.

00:15:03.200 --> 00:15:06.750
If you model it mentally as,
I get that information from

00:15:06.750 --> 00:15:08.200
there, you're limited.

00:15:08.200 --> 00:15:09.340
You can only do it with them.

00:15:09.340 --> 00:15:12.060
If you think about, I just need
a list of tags, then you

00:15:12.060 --> 00:15:14.430
can do it a number of
different ways.

00:15:14.430 --> 00:15:16.480
You could get those tags
by looking at a social

00:15:16.480 --> 00:15:17.530
bookmarking site.

00:15:17.530 --> 00:15:19.610
You could get it from posts
or hashtags on a social

00:15:19.610 --> 00:15:20.530
networking site.

00:15:20.530 --> 00:15:21.530
You could go and look
at someone's

00:15:21.530 --> 00:15:23.280
YouTube watch history.

00:15:23.280 --> 00:15:25.190
Once you think about it in terms
of the feature you're

00:15:25.190 --> 00:15:28.260
actually trying to provide, you
then have the flexibility

00:15:28.260 --> 00:15:31.010
to implement it different ways
with different providers.

00:15:31.010 --> 00:15:33.825
It's the same idea of separating
and abstraction

00:15:33.825 --> 00:15:37.340
there and not leaking the
details of that provider

00:15:37.340 --> 00:15:39.640
through to your application.

00:15:39.640 --> 00:15:41.750
So that means we need to
represent the user.

00:15:41.750 --> 00:15:44.680
And we do that, again, with an
interface because each of

00:15:44.680 --> 00:15:47.230
these providers is going to
return their own concrete user

00:15:47.230 --> 00:15:50.590
object which provides
this interface.

00:15:50.590 --> 00:15:51.700
So we've got the name.

00:15:51.700 --> 00:15:53.610
We've got the provider ID.

00:15:53.610 --> 00:15:55.870
We've got whether they can
do a certain feature.

00:15:55.870 --> 00:15:58.430
And we've got signOut and
disconnect so we can obey the

00:15:58.430 --> 00:16:00.790
various rules for various
networks on what options

00:16:00.790 --> 00:16:02.235
should be given to users.

00:16:02.235 --> 00:16:05.570
But you'll note that we've made
a decision here which is

00:16:05.570 --> 00:16:10.350
a little bit subtle in that this
user has a provider and a

00:16:10.350 --> 00:16:13.160
ID, just the one.

00:16:13.160 --> 00:16:15.335
We've made the decision that
what's happening here is you

00:16:15.335 --> 00:16:19.300
are signing in, not
signing up.

00:16:19.300 --> 00:16:21.530
And both models are common.

00:16:21.530 --> 00:16:24.450
When you sign in, there is a
one-to-one mapping between an

00:16:24.450 --> 00:16:28.080
identity provider account and
an application account.

00:16:28.080 --> 00:16:32.230
When you sign up, there is a
many-to-one mapping between

00:16:32.230 --> 00:16:36.270
identity providers and
a single app account.

00:16:36.270 --> 00:16:38.980
So each case is valid.

00:16:38.980 --> 00:16:40.260
Each case is a reasonable
thing.

00:16:40.260 --> 00:16:44.380
I can sign in with GitHub and
be me and sign in as Google+

00:16:44.380 --> 00:16:47.970
and be me, or I can sign in with
those two networks and be

00:16:47.970 --> 00:16:49.785
two different users
on the system.

00:16:49.785 --> 00:16:51.460
It depends on what
you're doing.

00:16:51.460 --> 00:16:54.820
And communicating this is part
of what the user story is,

00:16:54.820 --> 00:16:58.460
making them understand what's
valuable for them.

00:16:58.460 --> 00:17:00.230
But who is the user, anyway?

00:17:00.230 --> 00:17:02.550
What are we actually storing?

00:17:02.550 --> 00:17:04.910
What are we actually
working with?

00:17:04.910 --> 00:17:08.069
A lot of the time when people
implement a provider, they

00:17:08.069 --> 00:17:10.700
take the ID, and they stick it
in the database column, and

00:17:10.700 --> 00:17:11.819
they're done.

00:17:11.819 --> 00:17:13.290
And that's bad.

00:17:13.290 --> 00:17:15.140
Because when you do that, you've
coupled yourself to

00:17:15.140 --> 00:17:15.660
that provider.

00:17:15.660 --> 00:17:19.119
As soon as you add another
one, that ID is no longer

00:17:19.119 --> 00:17:20.630
enough information.

00:17:20.630 --> 00:17:25.260
You need to always store a
tuple, a pair of the provider

00:17:25.260 --> 00:17:27.619
and the provider user ID.

00:17:27.619 --> 00:17:29.980
So in this case, this is Google
and my Google ID,

00:17:29.980 --> 00:17:33.110
Facebook and my Facebook ID,
LinkedIn and my LinkedIn ID.

00:17:33.110 --> 00:17:34.880
Those are all identifiers.

00:17:34.880 --> 00:17:38.350
And I can have multiple of those
referring to the same

00:17:38.350 --> 00:17:41.620
app user if I want to.

00:17:41.620 --> 00:17:45.260
And this is why things like
upgrade are not a problem.

00:17:45.260 --> 00:17:47.780
If you already had an OAuth 2.0
login, and you wanted to

00:17:47.780 --> 00:17:50.820
go to Google+ Sign-In, it's
not a problem because the

00:17:50.820 --> 00:17:52.630
provider is still Google.

00:17:52.630 --> 00:17:54.790
The user ID is still
that user ID.

00:17:54.790 --> 00:17:56.630
It's just a different way
of getting there.

00:17:56.630 --> 00:17:59.260
And thinking about it that way
means that you don't have to

00:17:59.260 --> 00:18:02.490
worry about the exact strategy
being used to sign a user in.

00:18:02.490 --> 00:18:04.930
If you use a completely
different system on mobile

00:18:04.930 --> 00:18:07.780
than you do on the web, as long
as it results in that

00:18:07.780 --> 00:18:09.970
pair, you know it's
the same user.

00:18:09.970 --> 00:18:11.350
And that's great.

00:18:11.350 --> 00:18:14.300
Now the other thing people
look at is email.

00:18:14.300 --> 00:18:17.650
And email is often used to
combine accounts, which feels

00:18:17.650 --> 00:18:18.910
like a good thing.

00:18:18.910 --> 00:18:21.360
But it's tricky.

00:18:21.360 --> 00:18:25.080
When you have an email address,
you have some

00:18:25.080 --> 00:18:26.070
knowledge about that user.

00:18:26.070 --> 00:18:28.010
That user probably had
that email address.

00:18:28.010 --> 00:18:30.530
Most providers will do
some verification.

00:18:30.530 --> 00:18:33.690
But the verification is likely
to be point in time.

00:18:33.690 --> 00:18:37.800
So at some point, the identity
provider sent an

00:18:37.800 --> 00:18:38.730
email to that address.

00:18:38.730 --> 00:18:39.900
The user clicked the email.

00:18:39.900 --> 00:18:41.280
They had that address then.

00:18:41.280 --> 00:18:44.230
But particularly with corporate
email, with email on

00:18:44.230 --> 00:18:47.900
free providers, sometimes
things get reused.

00:18:47.900 --> 00:18:51.580
Sometimes email belongs
to a different person.

00:18:51.580 --> 00:18:54.270
But it doesn't mean that all the
other identities that have

00:18:54.270 --> 00:18:56.960
been associated with that
email get invalidated.

00:18:56.960 --> 00:19:03.530
So it can be a little risky
at times to rely on email.

00:19:03.530 --> 00:19:07.660
The OpenID Connect spec actually
says, do not assume

00:19:07.660 --> 00:19:09.305
email to be a unique
identifier.

00:19:09.305 --> 00:19:13.150
It is totally fine for an
identity provider to return an

00:19:13.150 --> 00:19:14.500
email address--

00:19:14.500 --> 00:19:16.990
the same email address-- for
two different accounts.

00:19:16.990 --> 00:19:19.560
You should always look for
that ID and that provider

00:19:19.560 --> 00:19:20.600
identification.

00:19:20.600 --> 00:19:23.220
That's the most reliable way
of dealing with them.

00:19:23.220 --> 00:19:26.330
But the way of having multiple
accounts is nice.

00:19:26.330 --> 00:19:30.050
So the Android code is in the
GitHub repo, the sort of

00:19:30.050 --> 00:19:31.700
sample we're working with.

00:19:31.700 --> 00:19:33.840
That has this basic idea.

00:19:33.840 --> 00:19:36.500
You can sign in, and there's a
bunch of features, pretty much

00:19:36.500 --> 00:19:38.040
the same as PHP.

00:19:38.040 --> 00:19:40.710
And when you sign in, we enable
the features that go

00:19:40.710 --> 00:19:42.400
with that network.

00:19:42.400 --> 00:19:45.410
But at this point,
we've created an

00:19:45.410 --> 00:19:46.620
app account as well.

00:19:46.620 --> 00:19:48.810
That's why it can say, thank
you for using our app.

00:19:48.810 --> 00:19:50.610
Because it knows I'm new.

00:19:50.610 --> 00:19:54.260
I have local state to go with
my identity provider state.

00:19:54.260 --> 00:19:57.630
And that means I can attach
other identity

00:19:57.630 --> 00:19:59.250
providers as well.

00:19:59.250 --> 00:20:02.390
And then I get more features
available to me because those

00:20:02.390 --> 00:20:04.740
providers provide additional
features.

00:20:04.740 --> 00:20:07.140
And this pattern is very, very
common in the real world.

00:20:07.140 --> 00:20:10.700
This is TuneIn Radio, The Fancy,
and Banjo, all who

00:20:10.700 --> 00:20:12.610
implement pretty much
this structure.

00:20:12.610 --> 00:20:15.230
And you'll see it in
many, many apps.

00:20:15.230 --> 00:20:17.970
All of them allowing you to
map multiple identity

00:20:17.970 --> 00:20:20.440
providers to a single
user account.

00:20:20.440 --> 00:20:22.590
And that means you need to think
about how the data is

00:20:22.590 --> 00:20:24.560
structured differently.

00:20:24.560 --> 00:20:27.150
You can't think about
one table of a user.

00:20:27.150 --> 00:20:30.280
You have to have a separation
between the identity provider

00:20:30.280 --> 00:20:31.610
and the user.

00:20:31.610 --> 00:20:33.760
And it's many-to-one.

00:20:33.760 --> 00:20:35.970
This is good, though, because
once you have this second

00:20:35.970 --> 00:20:39.800
table that has the provider user
ID, you can then key data

00:20:39.800 --> 00:20:40.740
against it.

00:20:40.740 --> 00:20:43.300
So if you retrieve some
information, you can put it

00:20:43.300 --> 00:20:46.850
into another table keyed against
the provider user ID.

00:20:46.850 --> 00:20:49.470
Which means if you need to
disconnect a user, and you

00:20:49.470 --> 00:20:52.140
have to follow data deletion
rules, it's easy.

00:20:52.140 --> 00:20:54.440
You just look up everything
attached to that ID.

00:20:54.440 --> 00:20:58.610
If you have to expire a cache
after a certain amount of

00:20:58.610 --> 00:21:00.110
time, then it's easy.

00:21:00.110 --> 00:21:03.180
You just look up everything
connected to that ID.

00:21:03.180 --> 00:21:05.910
So having this separation makes
it easier to structure

00:21:05.910 --> 00:21:08.040
your applications and structure
the data retrieved

00:21:08.040 --> 00:21:13.050
from your applications and the
provenance of that data.

00:21:13.050 --> 00:21:15.020
So to do this, we're going
to do things a little bit

00:21:15.020 --> 00:21:15.540
differently.

00:21:15.540 --> 00:21:16.810
We've still got the
same basic model.

00:21:16.810 --> 00:21:18.760
We've got our authenticator
layer in the middle.

00:21:18.760 --> 00:21:20.460
Though in this case, it's
going to be a fragment.

00:21:20.460 --> 00:21:24.030
We've got our providers, which
are going to be fairly dumb.

00:21:24.030 --> 00:21:26.230
And we've got our activity.

00:21:26.230 --> 00:21:30.730
But we know that our providers
are going to want to hold a

00:21:30.730 --> 00:21:32.010
little bit more state.

00:21:32.010 --> 00:21:35.050
We'd like our providers to be
able to be signed in, so that

00:21:35.050 --> 00:21:37.700
when you go in and attach
them, if you've already

00:21:37.700 --> 00:21:40.900
authenticated with that app in
that device, it's quick.

00:21:40.900 --> 00:21:42.160
It's a quick thing to do.

00:21:42.160 --> 00:21:45.740
So it speeds the process
for the user.

00:21:45.740 --> 00:21:47.590
And we know we're going to
have to pass around some

00:21:47.590 --> 00:21:48.120
information.

00:21:48.120 --> 00:21:50.540
Activity results are going to
have to flow all the way back

00:21:50.540 --> 00:21:53.570
from the outside world, if it's
going out to the system

00:21:53.570 --> 00:21:55.620
browser, back in to
our provider.

00:21:55.620 --> 00:21:56.930
But it's roughly
the same idea.

00:21:56.930 --> 00:21:59.130
We're sending information
back to be verified.

00:21:59.130 --> 00:22:02.380
And when we're done, we
send the user back.

00:22:02.380 --> 00:22:04.650
But there's an extra
complication in it.

00:22:04.650 --> 00:22:07.340
In this middle layer, we
don't just send the

00:22:07.340 --> 00:22:08.950
user straight back.

00:22:08.950 --> 00:22:10.240
It's the same as in PHP.

00:22:10.240 --> 00:22:12.660
We have a user created
in our provider.

00:22:12.660 --> 00:22:14.670
But we don't just send
it straight back

00:22:14.670 --> 00:22:16.950
out to our main activity.

00:22:16.950 --> 00:22:20.510
Instead, we have this account
user concept, because we need

00:22:20.510 --> 00:22:24.110
to be able to deal
with those cases.

00:22:24.110 --> 00:22:28.000
We need to be able to go, does
this identity provider user

00:22:28.000 --> 00:22:29.760
map to an account user?

00:22:29.760 --> 00:22:33.800
Does it map to an account user
when one is already signed in?

00:22:33.800 --> 00:22:34.860
Is it the same user?

00:22:34.860 --> 00:22:38.140
We need to consider that state
before we return anything.

00:22:38.140 --> 00:22:40.970
And we won't return anything
until we've resolved it into a

00:22:40.970 --> 00:22:45.180
central reliable application
user.

00:22:45.180 --> 00:22:47.040
So it's pretty straightforward
for our activities.

00:22:47.040 --> 00:22:48.180
They get to do things
like this.

00:22:48.180 --> 00:22:49.290
They get a callback.

00:22:49.290 --> 00:22:50.115
They can get the name.

00:22:50.115 --> 00:22:51.140
They can test the features.

00:22:51.140 --> 00:22:53.500
They can see if the
user's new.

00:22:53.500 --> 00:22:54.390
Simple.

00:22:54.390 --> 00:22:57.030
They don't have to
do much at all.

00:22:57.030 --> 00:23:00.180
Our sign-in user, however, has
to do a lot more work.

00:23:00.180 --> 00:23:03.690
Rather than just being an
interface, it's now a concrete

00:23:03.690 --> 00:23:06.800
object because it needs to carry
with it information.

00:23:06.800 --> 00:23:10.030
It needs to carry with it the
provider data for all of the

00:23:10.030 --> 00:23:11.640
providers that are attached.

00:23:11.640 --> 00:23:13.595
Previously, that was
kind of built in.

00:23:13.595 --> 00:23:15.680
If you had a Google user,
that Google user

00:23:15.680 --> 00:23:16.730
came with that data.

00:23:16.730 --> 00:23:19.350
In this case, we want to attach
Google data or LinkedIn

00:23:19.350 --> 00:23:21.980
data or Facebook data into
the same object.

00:23:21.980 --> 00:23:23.640
And we need access
to a database.

00:23:23.640 --> 00:23:26.760
Now in this case, this is
just a local SQLite.

00:23:26.760 --> 00:23:31.620
In reality you'd probably be
using Cinque to sync down to a

00:23:31.620 --> 00:23:34.950
web service somewhere or other
kind of communication.

00:23:34.950 --> 00:23:37.150
And your user store would
be on a server.

00:23:37.150 --> 00:23:39.990
But the basic concept
is similar.

00:23:39.990 --> 00:23:43.330
You're going to have this
representation of a user

00:23:43.330 --> 00:23:45.280
stored away in a database.

00:23:45.280 --> 00:23:48.560
So to add a provider, all we
need to do is put their

00:23:48.560 --> 00:23:51.920
information into that hash we
defined earlier, and then, if

00:23:51.920 --> 00:23:56.700
the user ID is null-- and that
ID, that mId, is the account

00:23:56.700 --> 00:23:58.590
user ID, is the app user ID.

00:23:58.590 --> 00:23:59.690
It's not a provider one.

00:23:59.690 --> 00:24:02.660
That's why there's just an
ID no matching provider.

00:24:02.660 --> 00:24:04.830
If it's null, we're going
to then go and

00:24:04.830 --> 00:24:06.080
retrieve a user ID.

00:24:06.080 --> 00:24:09.060
Say, has this user signed
in with this provider?

00:24:09.060 --> 00:24:10.990
If they have, great.

00:24:10.990 --> 00:24:11.940
We know who this is.

00:24:11.940 --> 00:24:12.900
We can go with it.

00:24:12.900 --> 00:24:15.210
If they haven't, we
can create a user.

00:24:15.210 --> 00:24:17.080
And that's when we can
set the IsNew flag.

00:24:17.080 --> 00:24:19.375
We know we've had to build
a user for this.

00:24:19.375 --> 00:24:22.230
And all that's doing is just
insert some reads on those

00:24:22.230 --> 00:24:24.610
database tables.

00:24:24.610 --> 00:24:26.100
And then it's easy.

00:24:26.100 --> 00:24:28.720
Dealing with things like
features, all the features are

00:24:28.720 --> 00:24:30.980
is just a set of features
provided by

00:24:30.980 --> 00:24:32.240
each connected provider.

00:24:32.240 --> 00:24:34.440
So we just loop over the
providers we have in our

00:24:34.440 --> 00:24:36.980
object, and we can test
them to see, do you

00:24:36.980 --> 00:24:37.940
provide this feature?

00:24:37.940 --> 00:24:39.590
If you do, I'm good to go.

00:24:39.590 --> 00:24:40.660
Very simple for our object.

00:24:40.660 --> 00:24:43.710
And note, it doesn't have to
know anything about who these

00:24:43.710 --> 00:24:44.120
providers are.

00:24:44.120 --> 00:24:47.790
The user never has to care about
who the providers are.

00:24:47.790 --> 00:24:50.440
They just follow
the interface.

00:24:50.440 --> 00:24:53.540
So you don't have to leak that
provider-specific code into

00:24:53.540 --> 00:24:56.510
anywhere else in your
application.

00:24:56.510 --> 00:24:58.880
But the provider-specific code
gets to be relatively

00:24:58.880 --> 00:24:59.930
straightforward as well.

00:24:59.930 --> 00:25:02.800
You don't have to do too much
with it because it doesn't

00:25:02.800 --> 00:25:06.950
have to carry much more than
just its general state.

00:25:06.950 --> 00:25:10.040
So when we want to attempt to
sign in, to see if we've got a

00:25:10.040 --> 00:25:12.360
connection using Facebook,
we can just use the

00:25:12.360 --> 00:25:15.350
openActiveSession call with
allowLoginUI set to false.

00:25:15.350 --> 00:25:17.050
So that's that middle
parameter there.

00:25:17.050 --> 00:25:19.640
And that means, we'll try and
see whether we have a valid

00:25:19.640 --> 00:25:20.810
Facebook session running.

00:25:20.810 --> 00:25:23.270
If we do, cool.

00:25:23.270 --> 00:25:24.960
We've gotten a user account
ready to go.

00:25:24.960 --> 00:25:27.680
So if the user taps on us, we
can immediately serve it.

00:25:27.680 --> 00:25:29.110
If not, fine.

00:25:29.110 --> 00:25:30.360
We'll just leave it.

00:25:30.360 --> 00:25:33.030
In the sign-in, though, where
a user action has been

00:25:33.030 --> 00:25:35.310
requested, we make the same
call but with that

00:25:35.310 --> 00:25:37.160
allowLoginUI set to true.

00:25:37.160 --> 00:25:39.120
So we'll actively go
and make a call.

00:25:39.120 --> 00:25:42.890
We'll actively present dialogue
to the users for them

00:25:42.890 --> 00:25:44.300
to sign in with.

00:25:44.300 --> 00:25:46.210
It's precisely the same
with Google+.

00:25:46.210 --> 00:25:48.970
When we go in, we have
a connect call.

00:25:48.970 --> 00:25:50.960
That's going to connect to
Google Play services.

00:25:50.960 --> 00:25:52.580
That's where our authentication
has

00:25:52.580 --> 00:25:53.740
kind of been held.

00:25:53.740 --> 00:25:55.480
We go to Google Play services.

00:25:55.480 --> 00:25:56.910
We see whether we're
signed in.

00:25:56.910 --> 00:25:59.850
If we're not, we're going to get
a call back with an error.

00:25:59.850 --> 00:26:02.990
And that error can be resolved
into an intent which will

00:26:02.990 --> 00:26:04.690
display some dialogue
to the user.

00:26:04.690 --> 00:26:06.050
So we just won't do that.

00:26:06.050 --> 00:26:08.900
When the user signs in, we know
they've taken an action.

00:26:08.900 --> 00:26:11.840
So we can display that dialogue
to them and let them

00:26:11.840 --> 00:26:14.780
sign in and let them
authenticate with us.

00:26:14.780 --> 00:26:15.750
So that's fine.

00:26:15.750 --> 00:26:18.930
And most of the time, we're
in a really easy state.

00:26:18.930 --> 00:26:22.190
The user goes to the choose
a page, taps a sign-in, an

00:26:22.190 --> 00:26:24.880
account is created or looked
up, and there we are.

00:26:24.880 --> 00:26:27.900
We have an identity provider
and an app account.

00:26:27.900 --> 00:26:31.310
You come back another day,
or another user comes in,

00:26:31.310 --> 00:26:33.680
identity provider account,
app account, great.

00:26:33.680 --> 00:26:37.660
But sometimes you've
got this situation.

00:26:37.660 --> 00:26:40.730
And then the top user signs
in with the same identity

00:26:40.730 --> 00:26:44.880
provider, the same identity
provider account, which now

00:26:44.880 --> 00:26:46.520
maps to a second account.

00:26:46.520 --> 00:26:48.400
We've now got a conflict.

00:26:48.400 --> 00:26:51.550
And what we do with that depends
on the application and

00:26:51.550 --> 00:26:53.190
what you want to do with it.

00:26:53.190 --> 00:26:55.940
Most of the time,
you can go, ah,

00:26:55.940 --> 00:26:57.850
these users don't conflict.

00:26:57.850 --> 00:26:59.320
We can just merge them.

00:26:59.320 --> 00:27:01.620
Whether that's something the
user would be involved with or

00:27:01.620 --> 00:27:02.715
not, that's up to you.

00:27:02.715 --> 00:27:03.760
But you know they've
signed in.

00:27:03.760 --> 00:27:04.940
You know they have
authenticated

00:27:04.940 --> 00:27:06.240
on both these systems.

00:27:06.240 --> 00:27:07.300
So they have access.

00:27:07.300 --> 00:27:09.880
So you can choose to merge
it if you want.

00:27:09.880 --> 00:27:12.470
And that's roughly
what we do here.

00:27:12.470 --> 00:27:14.090
We just present a dialogue
to the user.

00:27:14.090 --> 00:27:16.040
Hey, this user already exists.

00:27:16.040 --> 00:27:19.000
But we can have those
map to the same app

00:27:19.000 --> 00:27:20.110
account if you want.

00:27:20.110 --> 00:27:22.270
Do you want to merge, or
do you want to switch?

00:27:22.270 --> 00:27:23.660
Because maybe you'd just
like to be this

00:27:23.660 --> 00:27:25.250
other user right now.

00:27:25.250 --> 00:27:26.870
We can give them that option.

00:27:26.870 --> 00:27:28.720
But sometimes we can't.

00:27:28.720 --> 00:27:31.350
It's easy to think of cases, but
there's likely to be more

00:27:31.350 --> 00:27:34.710
app-specific cases in your
application, where there are

00:27:34.710 --> 00:27:36.720
things between accounts
that don't allow them

00:27:36.720 --> 00:27:37.960
to be merged well.

00:27:37.960 --> 00:27:41.260
In this case, imagine there was
a third identity provider

00:27:41.260 --> 00:27:44.800
connected, and on that third
identity provider, two

00:27:44.800 --> 00:27:47.440
different users were
signed in.

00:27:47.440 --> 00:27:49.820
In that case, we couldn't
combine them.

00:27:49.820 --> 00:27:52.080
We can't merge those accounts
automatically.

00:27:52.080 --> 00:27:53.720
But we can still prompt
the user.

00:27:53.720 --> 00:27:56.000
They've done a legitimate action
by signing in with

00:27:56.000 --> 00:27:56.770
another provider.

00:27:56.770 --> 00:27:58.580
They genuinely have
access to that.

00:27:58.580 --> 00:28:00.640
We just can't fix the
situation for them.

00:28:00.640 --> 00:28:02.760
So we can just say to them, hey,
do you want to switch?

00:28:02.760 --> 00:28:05.610
Or just cancel, stay
where you are.

00:28:05.610 --> 00:28:09.250
And all of that is mediated
by this authenticator.

00:28:09.250 --> 00:28:12.160
All of that is mediated in the
fragment, in this middle

00:28:12.160 --> 00:28:15.780
layer, without needing to
know about the provider.

00:28:15.780 --> 00:28:16.790
We can go in.

00:28:16.790 --> 00:28:19.380
We can see, is the
user ID null?

00:28:19.380 --> 00:28:21.760
If it is, we just take that
user, whatever's been given to

00:28:21.760 --> 00:28:23.430
us by a provider.

00:28:23.430 --> 00:28:26.850
If it isn't null, then
is it the same as the

00:28:26.850 --> 00:28:27.800
user that's come in?

00:28:27.800 --> 00:28:30.350
So I've signed in
with Google+.

00:28:30.350 --> 00:28:31.670
I've signed in with Facebook.

00:28:31.670 --> 00:28:33.530
Both look up to the
same app user.

00:28:33.530 --> 00:28:34.520
It just connects the accounts.

00:28:34.520 --> 00:28:35.946
It doesn't have to
do anything.

00:28:35.946 --> 00:28:39.570
If that's not true, then
can I merge the users?

00:28:39.570 --> 00:28:41.530
What logic is required
to test that?

00:28:41.530 --> 00:28:44.180
That logic doesn't have to
involve knowing anything about

00:28:44.180 --> 00:28:45.140
who the providers are.

00:28:45.140 --> 00:28:47.770
It can just be testing, is there
a conflict between these

00:28:47.770 --> 00:28:49.120
two sets of providers?

00:28:49.120 --> 00:28:51.020
And it can be doing
application-specific

00:28:51.020 --> 00:28:51.870
information.

00:28:51.870 --> 00:28:54.700
But again, we don't have to look
into the provider to see

00:28:54.700 --> 00:28:57.450
how to do this.

00:28:57.450 --> 00:29:01.870
So I wanted to give you one
other way of looking at this

00:29:01.870 --> 00:29:04.730
kind of problem.

00:29:04.730 --> 00:29:08.900
Which is the idea that having
state for the identity

00:29:08.900 --> 00:29:13.820
provider user separate than
having application state is

00:29:13.820 --> 00:29:15.370
kind of beneficial.

00:29:15.370 --> 00:29:19.200
And you can use that to handle a
whole bunch of applications.

00:29:19.200 --> 00:29:21.850
So you might think of
a TV Guide that

00:29:21.850 --> 00:29:23.310
lives on a tablet app.

00:29:23.310 --> 00:29:26.740
TV Guide, different family
members want to see their

00:29:26.740 --> 00:29:28.280
chosen shows.

00:29:28.280 --> 00:29:29.950
But they don't-- it's
not secret, right?

00:29:29.950 --> 00:29:31.660
They just don't want to see
the other person's.

00:29:31.660 --> 00:29:32.890
They want be able to switch.

00:29:32.890 --> 00:29:34.160
So that means it's an
identity problem.

00:29:34.160 --> 00:29:35.710
You need to know who they are.

00:29:35.710 --> 00:29:39.240
But you don't really care
about separating

00:29:39.240 --> 00:29:40.080
that data too much.

00:29:40.080 --> 00:29:42.080
You just want to make sure they
only see the stuff they

00:29:42.080 --> 00:29:43.260
want to see.

00:29:43.260 --> 00:29:45.265
So you can build something
like this.

00:29:45.265 --> 00:29:46.910
And this is in iOS.

00:29:46.910 --> 00:29:47.830
And we've just got our screen.

00:29:47.830 --> 00:29:48.310
It's anonymous.

00:29:48.310 --> 00:29:50.110
You can tap Choose Account.

00:29:50.110 --> 00:29:51.510
When you choose account,
you get a

00:29:51.510 --> 00:29:53.810
list of attached accounts.

00:29:53.810 --> 00:29:55.570
In this case, there's
my Facebook account

00:29:55.570 --> 00:29:56.220
and a Twitter account.

00:29:56.220 --> 00:29:57.790
And Google+ isn't signed in.

00:29:57.790 --> 00:29:58.645
So I tap Google+.

00:29:58.645 --> 00:29:59.890
And then I sign in.

00:29:59.890 --> 00:30:01.550
I go through the regular flow.

00:30:01.550 --> 00:30:03.940
So even though these two
providers were signed in, that

00:30:03.940 --> 00:30:05.720
doesn't automatically sign
me in to the app.

00:30:05.720 --> 00:30:06.600
I have to choose.

00:30:06.600 --> 00:30:10.130
I have to go through
an account chooser.

00:30:10.130 --> 00:30:12.080
Once I do it, I'm signed
in, and I can use the

00:30:12.080 --> 00:30:13.000
application as me.

00:30:13.000 --> 00:30:15.317
But if I want to change, I just
hit Choose Account and

00:30:15.317 --> 00:30:16.210
can switch again.

00:30:16.210 --> 00:30:17.760
This is very much like
the fast account

00:30:17.760 --> 00:30:19.160
switching in Gmail--

00:30:19.160 --> 00:30:21.120
in the Gmail app, where
you can choose what

00:30:21.120 --> 00:30:22.280
you're using it is.

00:30:22.280 --> 00:30:24.030
That's a really valuable
model.

00:30:24.030 --> 00:30:27.530
And it brings home the point
that identity doesn't have to

00:30:27.530 --> 00:30:31.670
be like this huge lock and key
way of getting into systems.

00:30:31.670 --> 00:30:35.440
It can be anything that helps
the user use your application,

00:30:35.440 --> 00:30:38.020
helps them get what they
need out of it.

00:30:38.020 --> 00:30:41.230
So in this case, to keep it
lightweight, rather than have

00:30:41.230 --> 00:30:43.280
the view controller know
anything about our

00:30:43.280 --> 00:30:46.630
authentication layer in the
middle, I thought, why not use

00:30:46.630 --> 00:30:47.340
a message bus?

00:30:47.340 --> 00:30:50.990
And in iOS, NSNotification
Center is the sort of standard

00:30:50.990 --> 00:30:51.550
way of doing it.

00:30:51.550 --> 00:30:54.840
On Android, you could use any
EventBus type library.

00:30:54.840 --> 00:30:56.750
Otto Square is a good one.

00:30:56.750 --> 00:30:59.820
And in this case, the
user might go

00:30:59.820 --> 00:31:00.790
to the account chooser.

00:31:00.790 --> 00:31:01.600
The account chooser will

00:31:01.600 --> 00:31:03.140
communicate with the providers.

00:31:03.140 --> 00:31:06.260
If the user taps on one of them,
they just signal the

00:31:06.260 --> 00:31:08.470
authenticator which puts
a message onto the bus.

00:31:08.470 --> 00:31:10.340
And anyone that happens to be
listening that wants to know

00:31:10.340 --> 00:31:11.540
about it, knows.

00:31:11.540 --> 00:31:13.820
Very cheap, very
easy switching.

00:31:13.820 --> 00:31:17.980
Subscribing is as simple as
registering an observer of

00:31:17.980 --> 00:31:20.850
yourself with
kUserStatusNotification.

00:31:20.850 --> 00:31:22.960
That's just the message type
you want to listen for.

00:31:22.960 --> 00:31:25.030
And checkUser is the function
that should be called when the

00:31:25.030 --> 00:31:26.750
message comes in.

00:31:26.750 --> 00:31:29.230
And publishing is pretty
much the same.

00:31:29.230 --> 00:31:32.370
So we don't have to know
about what's going on

00:31:32.370 --> 00:31:35.430
between those two.

00:31:35.430 --> 00:31:37.340
And in this case, we
need the identity

00:31:37.340 --> 00:31:38.940
provider to hold state.

00:31:38.940 --> 00:31:42.540
It has to know whether it's
signed in because that doesn't

00:31:42.540 --> 00:31:44.380
mean that we're signed into
the app with that user.

00:31:44.380 --> 00:31:46.670
It just means they're
available.

00:31:46.670 --> 00:31:49.500
So each of our identity
providers, when you sign in,

00:31:49.500 --> 00:31:50.870
may already have a user.

00:31:50.870 --> 00:31:52.810
They can return it right away.

00:31:52.810 --> 00:31:55.050
You want to track
that separately.

00:31:55.050 --> 00:31:58.100
And then if the user
signed in, we can

00:31:58.100 --> 00:31:59.490
actually prompt some UI.

00:31:59.490 --> 00:32:00.550
We can bring something up.

00:32:00.550 --> 00:32:03.280
And in fact, this is from
an example with Twitter.

00:32:03.280 --> 00:32:07.480
So with Twitter, we're using the
built-in integration into

00:32:07.480 --> 00:32:11.260
the OS with the Social Framework
in iOS 5 and 6.

00:32:11.260 --> 00:32:12.340
So we can go in.

00:32:12.340 --> 00:32:15.190
We can request from the account
store accounts of type

00:32:15.190 --> 00:32:17.410
Twitter, see if we're
granted access.

00:32:17.410 --> 00:32:19.910
If we are, we can retrieve
that user.

00:32:19.910 --> 00:32:21.640
Now we'll do that either way.

00:32:21.640 --> 00:32:25.290
We'll do that if we've started
the app right away, and we'll

00:32:25.290 --> 00:32:27.020
do it when the user
taps Sign In.

00:32:27.020 --> 00:32:29.760
If we've started the app right
away, and the user has

00:32:29.760 --> 00:32:32.810
previously granted access, and
we retrieve a user, we won't

00:32:32.810 --> 00:32:33.490
do anything with it.

00:32:33.490 --> 00:32:35.620
We'll just keep it locally.

00:32:35.620 --> 00:32:37.670
And then when they sign
in, we return it.

00:32:37.670 --> 00:32:40.790
If this is happening once
they've already--

00:32:40.790 --> 00:32:42.110
once they've tapped
the button, we

00:32:42.110 --> 00:32:43.310
know it's a user action.

00:32:43.310 --> 00:32:45.950
So down here, we'll actually
take that user and return it

00:32:45.950 --> 00:32:47.270
back to our object.

00:32:47.270 --> 00:32:49.520
But again, wrapped in an
interface, wrapped in a way

00:32:49.520 --> 00:32:52.390
that means the actual view
controller doesn't have to

00:32:52.390 --> 00:32:55.450
understand how that identity
was provisioned.

00:32:55.450 --> 00:32:57.090
They just have to use it.

00:32:57.090 --> 00:32:59.130
Google+, pretty much
the same thing.

00:32:59.130 --> 00:33:01.230
We return the user if we
have it available.

00:33:01.230 --> 00:33:04.480
Otherwise, we just call the
authenticate method on the

00:33:04.480 --> 00:33:06.810
shared instance of the
GPPSignIn object.

00:33:06.810 --> 00:33:07.480
Very straightforward.

00:33:07.480 --> 00:33:12.360
And that will kick off
the process for us.

00:33:12.360 --> 00:33:19.500
So I kind hope that's given you
some ideas about ways you

00:33:19.500 --> 00:33:22.510
can think about combining
different providers.

00:33:22.510 --> 00:33:27.500
It doesn't have to be all or
nothing incredibly complex

00:33:27.500 --> 00:33:27.780
integration.

00:33:27.780 --> 00:33:30.250
It can be simple and
lightweight, and you can just

00:33:30.250 --> 00:33:31.270
let users choose.

00:33:31.270 --> 00:33:34.310
And I hope it gives you some
ideas about benefits.

00:33:34.310 --> 00:33:36.270
I appreciate it is difficult.

00:33:36.270 --> 00:33:39.980
If you are doing a situation
where you're merging multiple

00:33:39.980 --> 00:33:42.400
identity provider accounts onto
a single app account,

00:33:42.400 --> 00:33:43.590
there are edge cases.

00:33:43.590 --> 00:33:44.370
There are conflicts.

00:33:44.370 --> 00:33:45.670
And you'll have to
resolve those.

00:33:45.670 --> 00:33:47.270
And that will take time.

00:33:47.270 --> 00:33:50.300
But if done right, I do believe
that it will not just

00:33:50.300 --> 00:33:51.620
give your users a better
experience.

00:33:51.620 --> 00:33:53.230
It will actually help the
structure of your

00:33:53.230 --> 00:33:53.940
applications.

00:33:53.940 --> 00:33:57.490
It'll help you provide a good
system and a scalable system

00:33:57.490 --> 00:33:59.890
that is going to be flexible
when demands come up for you

00:33:59.890 --> 00:34:01.870
to change it, for you to change
versions, for you to

00:34:01.870 --> 00:34:05.420
upgrade, or to add
new providers.

00:34:05.420 --> 00:34:07.680
So that's about it for me.

00:34:07.680 --> 00:34:10.810
We'll do-- got a few minutes
for questions.

00:34:10.810 --> 00:34:15.550
But I'll be at the Google+
sandbox on the second floor

00:34:15.550 --> 00:34:17.310
afterwards if you
have any more.

00:34:17.310 --> 00:34:19.940
If you're interested in this
kind of thing, Eric Sachs from

00:34:19.940 --> 00:34:22.449
our Identity team wrote a
really good document on

00:34:22.449 --> 00:34:24.280
running a login system with
an account chooser.

00:34:24.280 --> 00:34:25.909
It's kind of web-centric.

00:34:25.909 --> 00:34:28.800
But the concepts and ideas
are fantastic.

00:34:28.800 --> 00:34:30.630
And it's really, really helpful
if you want to think

00:34:30.630 --> 00:34:32.460
about this in more detail.

00:34:32.460 --> 00:34:34.800
If you're interested in Google+
Sign-In, all of the

00:34:34.800 --> 00:34:38.610
documentation is on
developers.google.com/+, and

00:34:38.610 --> 00:34:39.780
there's sessions on it today.

00:34:39.780 --> 00:34:41.969
We had Android earlier.

00:34:41.969 --> 00:34:45.540
IOS at the end of the day
with XT and Silvano.

00:34:45.540 --> 00:34:48.710
We've got web with Ade up
next in here, I think.

00:34:48.710 --> 00:34:51.260
And then there's a few other
sessions on things like best

00:34:51.260 --> 00:34:55.620
practices and how to integrate
throughout the day.

00:34:55.620 --> 00:34:57.700
All of the code for this talk,
if you are interested in it,

00:34:57.700 --> 00:34:58.690
is on GitHub.

00:34:58.690 --> 00:35:01.950
Or it will be as soon as I go
and make the repo public.

00:35:01.950 --> 00:35:03.960
And that is at that URL.

00:35:03.960 --> 00:35:04.960
And that's about it for me.

00:35:04.960 --> 00:35:05.739
Thank you.

00:35:05.739 --> 00:35:11.370
[APPLAUSE]

00:35:11.370 --> 00:35:12.070
IAN BARBER: Yeah,
so questions.

00:35:12.070 --> 00:35:14.850
And as this gentleman has, if
you could come to the mic if

00:35:14.850 --> 00:35:16.850
you have questions, just so that
they're on the recording,

00:35:16.850 --> 00:35:17.700
that'd be great.

00:35:17.700 --> 00:35:18.080
AUDIENCE: Thanks, Ian.

00:35:18.080 --> 00:35:19.780
It was a very practical
discussion.

00:35:19.780 --> 00:35:21.180
I really appreciate it.

00:35:21.180 --> 00:35:22.910
Yesterday, in Tim Bray's talk
in the morning, I saw

00:35:22.910 --> 00:35:24.730
something really interesting,
something I didn't really

00:35:24.730 --> 00:35:26.470
think you could do.

00:35:26.470 --> 00:35:29.380
He logged in to a demo
app that he'd written

00:35:29.380 --> 00:35:31.420
in Ruby with Google+.

00:35:31.420 --> 00:35:36.305
Then he set a preference, logged
out, and then logged in

00:35:36.305 --> 00:35:38.730
to it again with Facebook, and
it recognized that he was the

00:35:38.730 --> 00:35:40.500
same person both ways.

00:35:40.500 --> 00:35:43.440
And I'm kind of curious can you
give some practical advice

00:35:43.440 --> 00:35:45.690
on how to do stuff like that?

00:35:45.690 --> 00:35:49.270
IAN BARBER: Tim's actually
just over there.

00:35:49.270 --> 00:35:53.440
So I don't know-- how did you
do it in your example?

00:35:53.440 --> 00:35:54.634
TIM BRAY: Well, exactly
what you said.

00:35:54.634 --> 00:35:58.550
There's a layer of abstraction
in there that auto-merges

00:35:58.550 --> 00:36:01.450
these people if it detects
they're the same person.

00:36:01.450 --> 00:36:04.631
Now I confess that because this
was a cheap demo app, I

00:36:04.631 --> 00:36:05.770
used email.

00:36:05.770 --> 00:36:07.570
Which is bad.

00:36:07.570 --> 00:36:07.890
IAN BARBER: Yeah.

00:36:07.890 --> 00:36:10.490
So yeah, Tim was just saying
that it's exactly

00:36:10.490 --> 00:36:11.020
that kind of thing.

00:36:11.020 --> 00:36:12.160
He auto-merged people.

00:36:12.160 --> 00:36:14.550
And in that case, he used the
email address as the key.

00:36:14.550 --> 00:36:17.290
But it's finding an identifier
and using that

00:36:17.290 --> 00:36:18.160
to go back and forth.

00:36:18.160 --> 00:36:20.830
I think there's a lot of
different ways you can do it.

00:36:20.830 --> 00:36:24.030
And though I might say email
address is a problem in some

00:36:24.030 --> 00:36:26.540
cases, there are some cases
where you don't actually care

00:36:26.540 --> 00:36:28.010
that much, right?

00:36:28.010 --> 00:36:31.920
If you just want a lightweight
way, and you're not that

00:36:31.920 --> 00:36:33.820
bothered if some other
user gets access to

00:36:33.820 --> 00:36:36.020
it, it might be fine.

00:36:36.020 --> 00:36:37.990
And there's loads of legitimate
cases for that,

00:36:37.990 --> 00:36:39.760
where you do want something
a bit lighter.

00:36:39.760 --> 00:36:42.320
So there's always tradeoffs.

00:36:42.320 --> 00:36:44.210
There's always what do you want
to do, and what the level

00:36:44.210 --> 00:36:46.595
of confidentiality and security
and functionality you

00:36:46.595 --> 00:36:47.845
need to provide is.

00:36:57.770 --> 00:37:00.130
TIM BRAY: Whereas it's a bad
practice to rely on the email

00:37:00.130 --> 00:37:03.670
address, it's also probably not
a good practice to ignore

00:37:03.670 --> 00:37:05.800
the case when you happen to
get two that are the same.

00:37:05.800 --> 00:37:07.920
A very reasonable course of
action might be something you

00:37:07.920 --> 00:37:10.040
suggested to us, which is to pop
up a dialogue, saying, oh,

00:37:10.040 --> 00:37:13.500
hey, you're just signing in
as Tim Bray on Facebook.

00:37:13.500 --> 00:37:15.490
And I noticed you've been
signing in as Tim Bray as

00:37:15.490 --> 00:37:17.260
Google for the last
three weeks.

00:37:17.260 --> 00:37:19.400
Would you like to merge these?

00:37:19.400 --> 00:37:20.850
That's a very reasonable
course of action.

00:37:20.850 --> 00:37:22.500
IAN BARBER: Yeah, absolutely.

00:37:22.500 --> 00:37:23.610
That's a really good point.

00:37:23.610 --> 00:37:27.660
I think one of the subtleties
that tends to come into it

00:37:27.660 --> 00:37:31.770
which when you've got things
like multiple sign-in, is what

00:37:31.770 --> 00:37:33.210
do you do when users
kind of forget what

00:37:33.210 --> 00:37:34.040
they signed in with?

00:37:34.040 --> 00:37:35.540
And so that kind of
case really helps,

00:37:35.540 --> 00:37:36.770
if you can go, hmm.

00:37:36.770 --> 00:37:38.830
You're a new user, but you
look like this user.

00:37:38.830 --> 00:37:39.890
Are you really them?

00:37:39.890 --> 00:37:41.830
And then give them the
option to merge.

00:37:41.830 --> 00:37:44.900
Luke Wroblewski actually had a
really interesting model he

00:37:44.900 --> 00:37:47.750
did where you could start typing
in your email address,

00:37:47.750 --> 00:37:50.160
and it would show you which
providers you've signed in

00:37:50.160 --> 00:37:52.950
with, which obviously could
be a privacy leak.

00:37:52.950 --> 00:37:54.790
So it's something you have to
think about whether that fits

00:37:54.790 --> 00:37:55.140
for your app.

00:37:55.140 --> 00:37:57.720
But it was a really nice idea
where you could start typing

00:37:57.720 --> 00:37:59.630
things in and go, oh
yeah, that's me.

00:37:59.630 --> 00:38:02.650
So that they hint which the user
should use if you do have

00:38:02.650 --> 00:38:03.900
that situation.

00:38:06.280 --> 00:38:07.260
Cool.

00:38:07.260 --> 00:38:08.740
Is there any other questions?

00:38:08.740 --> 00:38:11.650
Otherwise, I think
that's about it.

00:38:11.650 --> 00:38:12.630
OK, thank you very much.

00:38:12.630 --> 00:38:14.130
[APPLAUSE]

