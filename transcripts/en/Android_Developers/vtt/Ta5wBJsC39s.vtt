WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.480
[MUSIC PLAYING]

00:00:04.470 --> 00:00:05.970
CHET HAASE: Hello, everyone.

00:00:05.970 --> 00:00:09.540
Welcome to Kotlin
Under the covers?

00:00:09.540 --> 00:00:10.260
Under the Hood.

00:00:10.260 --> 00:00:10.810
ROMAIN GUY: Under the Hood.

00:00:10.810 --> 00:00:12.720
CHET HAASE: We've called
it many, many names.

00:00:12.720 --> 00:00:14.400
We'll call it this
one right now.

00:00:14.400 --> 00:00:17.600
We want to look at the way
some of the features and Kotlin

00:00:17.600 --> 00:00:18.100
work.

00:00:18.100 --> 00:00:19.080
I'm Chet Haase.

00:00:19.080 --> 00:00:20.820
ROMAIN GUY: And I'm Romain Guy.

00:00:20.820 --> 00:00:22.392
CHET HAASE: And
let's do this thing.

00:00:22.392 --> 00:00:24.600
ROMAIN GUY: Yeah, and we
gave this talk before, like,

00:00:24.600 --> 00:00:26.200
a few weeks ago in France.

00:00:26.200 --> 00:00:27.900
The difference is,
today we have people

00:00:27.900 --> 00:00:29.725
from JetBrains in the audience.

00:00:29.725 --> 00:00:32.040
So we're probably going to
say something very stupid.

00:00:32.040 --> 00:00:35.513
So feel free to yell
at us, it's fine.

00:00:35.513 --> 00:00:37.930
CHET HAASE: Yeah, so we'll see
if we were actually correct

00:00:37.930 --> 00:00:38.888
when we wrote the talk.

00:00:38.888 --> 00:00:41.240
So Kotlin, very
awesome language.

00:00:41.240 --> 00:00:42.010
Very cool.

00:00:42.010 --> 00:00:43.360
Lots of interesting features.

00:00:43.360 --> 00:00:45.880
ROMAIN GUY: You're doing it
again, you're taking my slide.

00:00:45.880 --> 00:00:46.520
CHET HAASE: Are you going to--

00:00:46.520 --> 00:00:47.020
go ahead.

00:00:47.020 --> 00:00:47.980
ROMAIN GUY: So Chet
has this issue.

00:00:47.980 --> 00:00:49.990
In the speaker notes right
here, it says my name

00:00:49.990 --> 00:00:51.530
and he starts talking.

00:00:51.530 --> 00:00:53.847
And he keeps telling
my slides every time.

00:00:53.847 --> 00:00:55.180
All right, so Kotlin is awesome.

00:00:55.180 --> 00:00:56.570
Who's using Kotlin here?

00:00:56.570 --> 00:00:57.235
AUDIENCE: Whoo!

00:00:57.235 --> 00:00:57.860
AUDIENCE: Whoo!

00:00:57.860 --> 00:00:58.940
ROMAIN GUY: All right,
so we don't really

00:00:58.940 --> 00:01:01.090
have to convince you
that Kotlin is great.

00:01:01.090 --> 00:01:04.580
But just in case, it's concise,
you have less boilerplate,

00:01:04.580 --> 00:01:06.920
you get powerful extension
libraries, we write our own.

00:01:06.920 --> 00:01:09.790
There's a bunch of AndroidX
or Jetpack extension libraries

00:01:09.790 --> 00:01:12.450
for various APIs
platform on that.

00:01:12.450 --> 00:01:14.200
Fully compatible with
the Java programming

00:01:14.200 --> 00:01:16.357
language, and therefore,
the Andriod APIs,

00:01:16.357 --> 00:01:18.940
which makes it very easy for you
to adopt in your application.

00:01:18.940 --> 00:01:20.890
And it has a lot of
modern language features,

00:01:20.890 --> 00:01:21.770
like coroutines.

00:01:21.770 --> 00:01:23.980
Chet, what are coroutines?

00:01:23.980 --> 00:01:25.820
CHET HAASE: Things.

00:01:25.820 --> 00:01:27.680
ROMAIN GUY: All right.

00:01:27.680 --> 00:01:30.880
And it's always evolving.

00:01:30.880 --> 00:01:34.690
CHET HAASE: But some of these
magical things in Kotlin

00:01:34.690 --> 00:01:36.660
really are magical
and mysterious.

00:01:36.660 --> 00:01:38.530
How do those things
work, especially

00:01:38.530 --> 00:01:41.110
since we're compiling
down to the same byte

00:01:41.110 --> 00:01:44.750
code that runs other languages
that don't have these features.

00:01:44.750 --> 00:01:46.007
So how does that stuff work?

00:01:46.007 --> 00:01:47.590
So that's the whole
point of the talk.

00:01:47.590 --> 00:01:50.170
Take a look on the inside
and see what's going on.

00:01:50.170 --> 00:01:53.553
We're going to take a look at
two different things right now.

00:01:53.553 --> 00:01:55.720
Today, we're going to look
at how these things work.

00:01:55.720 --> 00:01:57.512
And we're also going
to show you some tools

00:01:57.512 --> 00:01:59.050
to use to get this information.

00:01:59.050 --> 00:02:01.595
Basically, the tools that we
used to discover this stuff.

00:02:01.595 --> 00:02:03.220
We're not going to
do it in that order,

00:02:03.220 --> 00:02:05.012
we're going to do it
in this order instead.

00:02:05.012 --> 00:02:06.560
So first, we'll talk
about the tools.

00:02:06.560 --> 00:02:08.930
And then we'll talk
about the features.

00:02:08.930 --> 00:02:10.703
So tools.

00:02:10.703 --> 00:02:11.620
ROMAIN GUY: All right.

00:02:11.620 --> 00:02:12.950
So there are two
tools you can use.

00:02:12.950 --> 00:02:14.860
The first one is looking
at the Kotlin bytecode,

00:02:14.860 --> 00:02:16.240
there's a special tool for that.

00:02:16.240 --> 00:02:18.160
IntelliJ and Android studio.

00:02:18.160 --> 00:02:19.920
And the second one,
part of the same tool,

00:02:19.920 --> 00:02:22.420
is you can convert the bytecode
back to the Java programming

00:02:22.420 --> 00:02:25.390
language, which sometimes is
very helpful to understand

00:02:25.390 --> 00:02:26.150
what's going on.

00:02:26.150 --> 00:02:28.970
So you don't have to
decipher bytecode yourself.

00:02:28.970 --> 00:02:30.660
Finally, the memory profilers.

00:02:30.660 --> 00:02:33.250
So not about the bytecode
itself, but sometimes some

00:02:33.250 --> 00:02:35.818
of this languages features
may create allocations,

00:02:35.818 --> 00:02:37.360
which may or may
not matter depending

00:02:37.360 --> 00:02:39.330
on what you're doing, what
kind of code you're writing.

00:02:39.330 --> 00:02:41.920
Which is a useful tool to know
about in general, not just

00:02:41.920 --> 00:02:44.350
in the context of this talk.

00:02:44.350 --> 00:02:47.340
So here's an example,
primitive types

00:02:47.340 --> 00:02:49.400
are handled a little
bit differently.

00:02:49.400 --> 00:02:52.960
So in Kotlin when you say
this, var i0 equals 5,

00:02:52.960 --> 00:02:56.380
obviously you're declaring
an Int So capital I -nt.

00:02:56.380 --> 00:02:58.630
It's non-nullable,
so it cannot be null.

00:02:58.630 --> 00:03:02.055
And it's equivalent to the
lowercase "int" in the Java

00:03:02.055 --> 00:03:02.930
programming language.

00:03:02.930 --> 00:03:04.720
So it is still primitive type.

00:03:04.720 --> 00:03:07.030
Now if you specify the
types yourself, same thing.

00:03:07.030 --> 00:03:09.700
It's an int, it's a primitive
type in the Java programming

00:03:09.700 --> 00:03:10.960
language.

00:03:10.960 --> 00:03:12.990
But if you declare
it as nullable,

00:03:12.990 --> 00:03:15.490
the only way we can handle that,
with the current run times,

00:03:15.490 --> 00:03:17.890
is that it has to
become the Int?

00:03:17.890 --> 00:03:20.110
Type in Kotlin, which
becomes the capital I,

00:03:20.110 --> 00:03:22.338
Integer type in the Java
programming language.

00:03:22.338 --> 00:03:24.380
And certainly, it's not
a primitive type anymore,

00:03:24.380 --> 00:03:25.680
it's a full-blown object.

00:03:25.680 --> 00:03:27.447
And this can have consequences.

00:03:27.447 --> 00:03:29.530
CHET HAASE: So how do we
find out stuff like that?

00:03:29.530 --> 00:03:32.320
Well as he said, one of the
ways that we can do that

00:03:32.320 --> 00:03:33.530
is by looking at bytecodes.

00:03:33.530 --> 00:03:35.890
So let's look at some now.

00:03:35.890 --> 00:03:38.890
[LAUGHTER]

00:03:38.890 --> 00:03:41.920
That's pretty self-explanatory,
so let's move on to something

00:03:41.920 --> 00:03:42.800
else.

00:03:42.800 --> 00:03:45.040
So in IntelliJ, there
are different ways

00:03:45.040 --> 00:03:46.720
to look at bytecode,
but fortunately, we

00:03:46.720 --> 00:03:50.650
have tools integrated
directly into Android Studio,

00:03:50.650 --> 00:03:51.610
into the IDE.

00:03:51.610 --> 00:03:53.710
If you go up in the
Menu, you can say, yeah,

00:03:53.710 --> 00:03:56.780
show me that bytecode, and then
you get this viewer over here.

00:03:56.780 --> 00:03:59.630
So if you'll look carefully
in the editor on the left,

00:03:59.630 --> 00:04:02.110
you'll see that the cursor is
on a particular line of code,

00:04:02.110 --> 00:04:04.390
and then it highlights
the equivalent bytecode

00:04:04.390 --> 00:04:06.203
on the right to show
you what's going on.

00:04:06.203 --> 00:04:07.870
Some of the information
in the bytecode,

00:04:07.870 --> 00:04:09.580
it gets a little noisy in there.

00:04:09.580 --> 00:04:11.500
There's metadata to tell
you what line that's

00:04:11.500 --> 00:04:14.480
associated with, a
little extra information.

00:04:14.480 --> 00:04:16.149
But there's a couple
of instructions,

00:04:16.149 --> 00:04:20.587
in particular, which are the
actual bytecode instructions.

00:04:20.587 --> 00:04:22.420
And then there is another
way of doing this.

00:04:22.420 --> 00:04:24.650
On the command line, you
can use Java p instead

00:04:24.650 --> 00:04:27.760
and that'll spit out a file
that you can take a look at,

00:04:27.760 --> 00:04:28.973
nicely formatted bytecode.

00:04:28.973 --> 00:04:30.640
Just a different way
to do it that's not

00:04:30.640 --> 00:04:32.170
integrated into the IDE.

00:04:32.170 --> 00:04:34.420
So for the code that we
were looking at before,

00:04:34.420 --> 00:04:35.890
you have this var i0.

00:04:35.890 --> 00:04:38.260
We haven't told it it's
going to use type inference,

00:04:38.260 --> 00:04:40.120
but it's set to be
this integer value.

00:04:40.120 --> 00:04:41.037
So what's going on?

00:04:41.037 --> 00:04:43.370
We have a little bit of
metadata about the line numbers.

00:04:43.370 --> 00:04:46.850
And then it says, bipush
of the value of 25.

00:04:46.850 --> 00:04:49.090
So it's going to take
that value, 25, extended

00:04:49.090 --> 00:04:50.800
to an integer, push
it onto the stack,

00:04:50.800 --> 00:04:52.930
and then it's going to
pull it back off the stack

00:04:52.930 --> 00:04:54.580
and it's going to
store an integer

00:04:54.580 --> 00:04:56.870
into the first variable.

00:04:56.870 --> 00:05:00.070
So integer store, and then
we go on the second line,

00:05:00.070 --> 00:05:01.390
we're not using type inference.

00:05:01.390 --> 00:05:02.260
We've actually said, no.

00:05:02.260 --> 00:05:02.760
No.

00:05:02.760 --> 00:05:04.240
We want you to be on int.

00:05:04.240 --> 00:05:06.190
We're going to assign
you the value 78.

00:05:06.190 --> 00:05:07.120
Same thing happens.

00:05:07.120 --> 00:05:09.345
We're going to push a 78
extended to an integer

00:05:09.345 --> 00:05:09.970
onto the stack.

00:05:09.970 --> 00:05:11.710
We're going to pull
that off, store it

00:05:11.710 --> 00:05:14.380
into the second
integer variable.

00:05:14.380 --> 00:05:16.060
And then for the
third case, where

00:05:16.060 --> 00:05:17.770
we have this
nullable type, we've

00:05:17.770 --> 00:05:22.690
got i2, that's going to be a
nullable int of a value of 14.

00:05:22.690 --> 00:05:24.170
First step is going
to be the same.

00:05:24.170 --> 00:05:26.020
We're going to
push byte extended

00:05:26.020 --> 00:05:27.880
to integer onto the stack.

00:05:27.880 --> 00:05:29.680
But then, we're going
to call the method,

00:05:29.680 --> 00:05:31.510
we're going to call
Integer.valueOf,

00:05:31.510 --> 00:05:33.160
which looks like this.

00:05:33.160 --> 00:05:37.090
It takes in a primitive int
type and it returns an integer.

00:05:37.090 --> 00:05:38.590
So in the middle
of that, it's going

00:05:38.590 --> 00:05:40.780
to box it into an
integer type, creating

00:05:40.780 --> 00:05:42.410
that object on the fly.

00:05:42.410 --> 00:05:44.110
And then return
the integer type.

00:05:44.110 --> 00:05:46.660
And then instead of storing
an integer into a variable,

00:05:46.660 --> 00:05:48.970
it's going to store a
reference to the object

00:05:48.970 --> 00:05:51.590
that we've created.

00:05:51.590 --> 00:05:53.795
So if you don't enjoy
reading bytecode

00:05:53.795 --> 00:05:55.170
it's really not
that complicated.

00:05:55.170 --> 00:05:56.450
ROMAIN GUY: You're
doing it again.

00:05:56.450 --> 00:05:56.760
CHET HAASE: What's that?

00:05:56.760 --> 00:05:58.000
ROMAIN GUY: This is my
name on the speaker notes.

00:05:58.000 --> 00:05:59.875
CHET HAASE: That's why
I was introducing you.

00:05:59.875 --> 00:06:01.692
Romain is going to
tell you what to do.

00:06:01.692 --> 00:06:02.650
ROMAIN GUY: Keep going.

00:06:02.650 --> 00:06:04.327
You started it.

00:06:04.327 --> 00:06:06.910
CHET HAASE: So if you don't want
to read all of that bytecode,

00:06:06.910 --> 00:06:08.480
it's actually pretty
straightforward.

00:06:08.480 --> 00:06:10.120
There's some simple
reference docs out there

00:06:10.120 --> 00:06:11.287
that you can take a look at.

00:06:11.287 --> 00:06:13.162
You're pushing, your
popping, you're setting.

00:06:13.162 --> 00:06:14.829
But if you don't want
to deal with that,

00:06:14.829 --> 00:06:17.230
there is an easier way,
especially a more concise way,

00:06:17.230 --> 00:06:19.610
to see what's actually going on.

00:06:19.610 --> 00:06:21.915
And for that you would
use the bytecode--

00:06:21.915 --> 00:06:23.040
ROMAIN GUY: No, keep going.

00:06:23.040 --> 00:06:23.435
CHET HAASE: --Decompiler.

00:06:23.435 --> 00:06:23.830
ROMAIN GUY: It's fine.

00:06:23.830 --> 00:06:24.310
CHET HAASE: You want me to keep?

00:06:24.310 --> 00:06:24.880
ROMAIN GUY: No, keep going.

00:06:24.880 --> 00:06:25.090
CHET HAASE: All right.

00:06:25.090 --> 00:06:26.890
Rest of the
presentation is mine.

00:06:26.890 --> 00:06:27.470
Here we go.

00:06:27.470 --> 00:06:28.820
ROMAIN GUY: I'll go over there.

00:06:28.820 --> 00:06:29.820
CHET HAASE: What's that?

00:06:29.820 --> 00:06:30.910
ROMAIN GUY: I'll be over there.

00:06:30.910 --> 00:06:31.510
CHET HAASE: All right.

00:06:31.510 --> 00:06:31.810
So

00:06:31.810 --> 00:06:32.310
[LAUGHTER]

00:06:32.310 --> 00:06:34.628
let's say you've got
this code-- could you go

00:06:34.628 --> 00:06:35.920
a little bit further, actually?

00:06:35.920 --> 00:06:36.420
[LAUGHTER]

00:06:36.420 --> 00:06:38.020
So you've got this code.

00:06:38.020 --> 00:06:40.040
You have the bytecode
representation over there.

00:06:40.040 --> 00:06:41.790
And if you look at the
top of that window,

00:06:41.790 --> 00:06:43.930
you've got this button
that says Decompile.

00:06:43.930 --> 00:06:47.230
So you click on that thing,
and then in your editor window,

00:06:47.230 --> 00:06:50.290
you'll be shown some
Java programming language

00:06:50.290 --> 00:06:52.660
code that looks more like this.

00:06:52.660 --> 00:06:55.180
So you got the bytecode
fairly verbose.

00:06:55.180 --> 00:06:58.360
All the things going on, each
of the lines of Kotlin code

00:06:58.360 --> 00:07:00.580
may expand to several
lines of bytecode

00:07:00.580 --> 00:07:01.930
along with the metadata.

00:07:01.930 --> 00:07:05.200
Or you can see this fairly
terse Java code instead.

00:07:05.200 --> 00:07:06.833
You see, basically,
straightforward

00:07:06.833 --> 00:07:07.750
things going on there.

00:07:07.750 --> 00:07:10.300
You have some int values, you
have some integer values that

00:07:10.300 --> 00:07:15.360
got auto boxed, and then we're
printing out the values there.

00:07:15.360 --> 00:07:17.778
Just like that.

00:07:17.778 --> 00:07:19.570
You want to talk about
the Memory Profiler?

00:07:19.570 --> 00:07:20.700
ROMAIN GUY: No, 'cause
it says you're name.

00:07:20.700 --> 00:07:21.290
CHET HAASE: It does.

00:07:21.290 --> 00:07:21.750
ROMAIN GUY: OK, so--

00:07:21.750 --> 00:07:23.300
CHET HAASE: I'm going to talk
about the Memory Profiler,

00:07:23.300 --> 00:07:23.880
there.

00:07:23.880 --> 00:07:27.072
The third approach that we have,
using the tools to find out

00:07:27.072 --> 00:07:28.530
what's going on,
is to actually see

00:07:28.530 --> 00:07:31.810
what's going on with allocations
in collections in the system.

00:07:31.810 --> 00:07:34.710
So one of my favorite tools,
when I joined the team

00:07:34.710 --> 00:07:37.290
and for many years
after that, was--

00:07:37.290 --> 00:07:38.320
oh, is this proof?

00:07:38.320 --> 00:07:39.820
ROMAIN GUY: I'm
going to tweet that.

00:07:39.820 --> 00:07:42.120
[LAUGHTER]

00:07:42.120 --> 00:07:43.650
CHET HAASE: Allocation Tracker.

00:07:43.650 --> 00:07:46.530
Allocation Tracker was a tool
that you would run in DDMS

00:07:46.530 --> 00:07:48.937
and you would start it
at some point in time

00:07:48.937 --> 00:07:50.520
and you would use
the app for a while.

00:07:50.520 --> 00:07:52.353
And then you would stop
it and it would say,

00:07:52.353 --> 00:07:55.180
here are all the objects that
were allocated on the fly.

00:07:55.180 --> 00:07:57.390
And then you could click
on any of those instances,

00:07:57.390 --> 00:07:58.890
and it will show
you the call stack.

00:07:58.890 --> 00:08:01.770
Really powerful, really useful,
wasn't integrated in with any

00:08:01.770 --> 00:08:03.000
of the rest of the tools.

00:08:03.000 --> 00:08:04.875
So, kind of a pain to
get to, a lot of people

00:08:04.875 --> 00:08:07.470
didn't even know it was there
because actually finding

00:08:07.470 --> 00:08:08.740
it was a little bit tricky.

00:08:08.740 --> 00:08:13.320
So now we have Memory Profiling
directly integrated into the ID

00:08:13.320 --> 00:08:16.020
with the rest of the profilers
that have come online in Studio

00:08:16.020 --> 00:08:17.770
in the last few years.

00:08:17.770 --> 00:08:20.760
So this also allows you to
track memory usage over time,

00:08:20.760 --> 00:08:23.400
you can see how big the
heap is at any given time,

00:08:23.400 --> 00:08:25.770
you can see when Garbage
Collections happen,

00:08:25.770 --> 00:08:27.690
and what happened
because of those,

00:08:27.690 --> 00:08:30.068
and you can catch leaks,
which is really powerful.

00:08:30.068 --> 00:08:31.860
This is another thing
that, yes, we allowed

00:08:31.860 --> 00:08:33.419
you to do it on Android.

00:08:33.419 --> 00:08:38.760
But oh man, did we require you
to jump through a lot of heaps.

00:08:38.760 --> 00:08:41.490
You would dump a heap and
you would transcode that

00:08:41.490 --> 00:08:42.580
into a different format.

00:08:42.580 --> 00:08:44.130
And you would use
some external tool

00:08:44.130 --> 00:08:47.460
and then you'd walked through
this amazingly complex set

00:08:47.460 --> 00:08:48.705
of information.

00:08:48.705 --> 00:08:50.580
Now, all of that stuff
is integrated directly

00:08:50.580 --> 00:08:51.330
into the ID.

00:08:51.330 --> 00:08:54.660
And after all of this, it
allows you to track allocations,

00:08:54.660 --> 00:08:56.470
and that's what we
care about today.

00:08:56.470 --> 00:09:00.960
So I wrote this
code all by myself.

00:09:00.960 --> 00:09:01.890
Really simple thing.

00:09:01.890 --> 00:09:03.550
We've got this
nullable int value.

00:09:03.550 --> 00:09:05.550
You've got a tight loop
in there, in the method,

00:09:05.550 --> 00:09:07.020
we're going 0 to 10,000.

00:09:07.020 --> 00:09:09.480
So 10,001 times is going
to whip through the loop

00:09:09.480 --> 00:09:11.262
and it's going to set.

00:09:11.262 --> 00:09:12.720
We know that that's
going to end up

00:09:12.720 --> 00:09:19.650
being a capital I integer value
set from the primitive I loop

00:09:19.650 --> 00:09:20.760
value that we've got.

00:09:20.760 --> 00:09:23.850
So we can click on this in
the lower left of the IDE.

00:09:23.850 --> 00:09:27.420
You've got this little toolbar
of little tools you can run.

00:09:27.420 --> 00:09:29.040
If you click on the
Profiler, you'll

00:09:29.040 --> 00:09:31.510
get something that
looks like this.

00:09:31.510 --> 00:09:33.910
It shows you all the profilers
that we currently offer.

00:09:33.910 --> 00:09:36.600
You've got CPU, you got the
Memory that we'll look into,

00:09:36.600 --> 00:09:39.953
you've got Networking, and
you've got Battery Power Usage.

00:09:39.953 --> 00:09:41.370
So if you click
on the Memory one,

00:09:41.370 --> 00:09:43.560
it expands to take over
the whole screen there.

00:09:43.560 --> 00:09:45.340
And you can see heap
usage over time.

00:09:45.340 --> 00:09:48.130
Now, what we really care about
here is, what happened there?

00:09:48.130 --> 00:09:48.630
Right?

00:09:48.630 --> 00:09:50.130
I don't care when
it's not changing.

00:09:50.130 --> 00:09:53.880
What I care is, what caused it
to actually bump up allocations

00:09:53.880 --> 00:09:56.220
in heap usage and why was that?

00:09:56.220 --> 00:09:58.350
So you can drag the
cursor along there.

00:09:58.350 --> 00:10:00.960
You can select this window of
time to see what's going on.

00:10:00.960 --> 00:10:02.400
And just like
Allocation Tracker,

00:10:02.400 --> 00:10:06.270
you can see all of the things
that were allocated down below.

00:10:06.270 --> 00:10:08.070
And you can see
that, in fact, there

00:10:08.070 --> 00:10:11.550
are a bunch of capital I
integers they got allocated.

00:10:11.550 --> 00:10:15.780
In fact, there
are exactly 9,873.

00:10:15.780 --> 00:10:17.190
Which is weird.

00:10:17.190 --> 00:10:19.950
We're in a loop going
through 10,001 times,

00:10:19.950 --> 00:10:23.560
why do we not have 10,001
allocations going on?

00:10:23.560 --> 00:10:28.890
So there's the loop and
that, for some reason,

00:10:28.890 --> 00:10:34.290
didn't equal 10,001
allocations and it's

00:10:34.290 --> 00:10:36.540
because of this caching
logic that we have.

00:10:36.540 --> 00:10:38.790
When the runtime
starts up, it knows

00:10:38.790 --> 00:10:42.180
that most applications are going
to need some integer values.

00:10:42.180 --> 00:10:48.150
And so it caches values
from negative 128 up to 127,

00:10:48.150 --> 00:10:49.240
puts them in a cache.

00:10:49.240 --> 00:10:52.770
And now when anybody asks
for a value for one of those,

00:10:52.770 --> 00:10:54.180
it's just going to return that.

00:10:54.180 --> 00:10:56.130
It's already been
created as an integer,

00:10:56.130 --> 00:10:57.720
it's not being
boxed and allocated

00:10:57.720 --> 00:11:00.030
on the fly, which means
the only values that

00:11:00.030 --> 00:11:03.090
are going to be allocated
are outside of that region.

00:11:03.090 --> 00:11:09.540
Which turns out 10,001 minus
128 is going to be 9,873.

00:11:09.540 --> 00:11:11.370
Has nothing to do
with this talk,

00:11:11.370 --> 00:11:12.780
I thought it was interesting.

00:11:12.780 --> 00:11:16.440
So the one that we care
about are the capital

00:11:16.440 --> 00:11:18.515
I integer allocations.

00:11:18.515 --> 00:11:20.640
So we're going to click on
that, and that brings up

00:11:20.640 --> 00:11:22.860
another window that shows
each of those individual

00:11:22.860 --> 00:11:25.470
allocations, when they
happen, and what was going on.

00:11:25.470 --> 00:11:28.590
We can click on one of those and
just like Allocation Tracker,

00:11:28.590 --> 00:11:30.370
it pops up the call stack.

00:11:30.370 --> 00:11:32.430
And from that, we determine
that, in fact, that

00:11:32.430 --> 00:11:35.130
was being allocated because of
the boxing operation that was

00:11:35.130 --> 00:11:36.813
happening in that tight loop.

00:11:36.813 --> 00:11:38.730
ROMAIN GUY: Let's talk
about language feature.

00:11:38.730 --> 00:11:39.706
AUDIENCE: Whoo!

00:11:39.706 --> 00:11:42.430
[APPLAUSE]

00:11:42.430 --> 00:11:43.680
ROMAIN GUY: I appreciate this.

00:11:43.680 --> 00:11:44.722
Thank you for the cheers.

00:11:44.722 --> 00:11:46.440
But maybe wait until the end.

00:11:46.440 --> 00:11:47.640
[LAUGHTER]

00:11:47.640 --> 00:11:49.570
CHET HAASE: Do you mind
if I take this one?

00:11:49.570 --> 00:11:51.480
ROMAIN GUY: Yeah, I do actually.

00:11:51.480 --> 00:11:52.850
I can just leave if you want.

00:11:52.850 --> 00:11:55.952
Anyway, enums, your
favorite topic.

00:11:55.952 --> 00:11:57.410
So please use enums
but we're going

00:11:57.410 --> 00:11:58.860
to talk about them anyway.

00:11:58.860 --> 00:12:02.110
So here's an enum I wrote,
all by myself as well, called

00:12:02.110 --> 00:12:02.610
Blend Mode.

00:12:02.610 --> 00:12:05.110
We have some values, it doesn't
really matter what they are.

00:12:05.110 --> 00:12:06.930
And here's how I'm
using the enum.

00:12:06.930 --> 00:12:09.510
I'm using a one
statement, effectively

00:12:09.510 --> 00:12:12.390
the equivalent of a switch in
the Java programming language.

00:12:12.390 --> 00:12:13.798
And for every
value of the enum I

00:12:13.798 --> 00:12:16.090
call a function, that doesn't
really matter what we do.

00:12:16.090 --> 00:12:17.715
What's interesting
is what happens when

00:12:17.715 --> 00:12:19.030
we look at the dried bytecode.

00:12:19.030 --> 00:12:21.700
So here's what it looks like.

00:12:21.700 --> 00:12:25.890
The first thing it does, it's
called this GETSTATIC up code.

00:12:25.890 --> 00:12:29.880
It accesses the [INAUDIBLE],,
so that's the square bracket

00:12:29.880 --> 00:12:32.890
with the capital I at the end.

00:12:32.890 --> 00:12:35.740
So it's filled in a
classical BlendingKt$WhenM

00:12:35.740 --> 00:12:39.180
appings.$EnumSwitchMapping$0.

00:12:39.180 --> 00:12:42.150
I never wrote a classical
called this in my code,

00:12:42.150 --> 00:12:43.260
but there it is.

00:12:43.260 --> 00:12:44.927
And then what's
interesting, is after it

00:12:44.927 --> 00:12:48.180
gets this array, it's invokes
the ordinal method on the enum

00:12:48.180 --> 00:12:49.410
value itself.

00:12:49.410 --> 00:12:51.100
And then it does a IALOAD.

00:12:51.100 --> 00:12:55.210
So IALOAD takes the output
of the ordinal method call,

00:12:55.210 --> 00:12:59.640
and then use that as an index in
the array that we just fetched.

00:12:59.640 --> 00:13:01.143
And finally, does
the actual switch.

00:13:01.143 --> 00:13:03.060
So it doesn't switch on
the enum value itself,

00:13:03.060 --> 00:13:06.130
its first goes through
another intermediate array.

00:13:06.130 --> 00:13:08.720
And we're going to look at
what this array looks like,

00:13:08.720 --> 00:13:09.910
and then that's our code.

00:13:09.910 --> 00:13:12.472
So here's what the
[INAUDIBLE] looks like.

00:13:12.472 --> 00:13:14.430
So what's interesting
here, is that this is not

00:13:14.430 --> 00:13:15.780
specific to Kotlin.

00:13:15.780 --> 00:13:17.610
The Java programming
language compiler

00:13:17.610 --> 00:13:19.260
will also do the same thing.

00:13:19.260 --> 00:13:21.380
But it's still
interesting to look at it.

00:13:21.380 --> 00:13:23.130
So the code that gets
generated does this.

00:13:23.130 --> 00:13:24.720
There's this special
mapping class

00:13:24.720 --> 00:13:28.200
that contains an array that has
the same length as the number

00:13:28.200 --> 00:13:30.770
of enum values that you
have in the enum class

00:13:30.770 --> 00:13:31.920
that you declare.

00:13:31.920 --> 00:13:35.520
And then, the static
[INAUDIBLE] code, this array

00:13:35.520 --> 00:13:37.860
is populated with the
values of the enums

00:13:37.860 --> 00:13:41.850
and some special constants
generated by the compiler.

00:13:41.850 --> 00:13:44.520
So what happens if we create
another method in our code

00:13:44.520 --> 00:13:47.070
that does another
when on the enum?

00:13:47.070 --> 00:13:49.140
So we do a when
the same order, we

00:13:49.140 --> 00:13:51.037
switch over all the
values of the enum.

00:13:51.037 --> 00:13:52.620
If you go back to
the generated class,

00:13:52.620 --> 00:13:54.787
we can see there's a second
array that was generated

00:13:54.787 --> 00:13:56.610
and it's also
populated with enum

00:13:56.610 --> 00:13:59.090
values in some magic
constants by the compiler.

00:13:59.090 --> 00:14:00.900
And actually, you can
see that those two

00:14:00.900 --> 00:14:02.323
arrays are exactly the same.

00:14:02.323 --> 00:14:03.990
They're the same
length and they contain

00:14:03.990 --> 00:14:06.630
exactly the same mappings.

00:14:06.630 --> 00:14:09.600
But if we use the enum
once again in a when.

00:14:09.600 --> 00:14:12.060
And this time, we
declare the enum values

00:14:12.060 --> 00:14:14.490
in a different order and we
look at the generated code,

00:14:14.490 --> 00:14:17.280
we have a third array, as
expected, also the same length,

00:14:17.280 --> 00:14:19.870
but the mapping's now different.

00:14:19.870 --> 00:14:21.360
I believe the
reason the compilers

00:14:21.360 --> 00:14:25.092
do this is that if you change
the enum, the code that

00:14:25.092 --> 00:14:27.300
was compiled before with
the old version of the enum,

00:14:27.300 --> 00:14:29.990
will still work so they
need this indirection.

00:14:29.990 --> 00:14:32.400
What becomes interesting is,
obviously most of the time,

00:14:32.400 --> 00:14:34.280
you will never need
to care about this.

00:14:34.280 --> 00:14:36.300
You should have a
lot of when on enums

00:14:36.300 --> 00:14:37.860
in performance critical code.

00:14:37.860 --> 00:14:41.070
You're going to have extra code
that gets initialized that runs

00:14:41.070 --> 00:14:42.480
out in [INAUDIBLE] in time.

00:14:42.480 --> 00:14:45.015
And you have this extra happy
memory, but most of time,

00:14:45.015 --> 00:14:46.670
you don't need to
care about this.

00:14:46.670 --> 00:14:48.508
Use enums.

00:14:48.508 --> 00:14:50.550
CHET HAASE: All right,
let's talk about laziness.

00:14:50.550 --> 00:14:51.970
I know a lot about this.

00:14:51.970 --> 00:14:54.420
It's a very common pattern
in software to say,

00:14:54.420 --> 00:14:56.328
I may need to
allocate this thing.

00:14:56.328 --> 00:14:57.870
But it's going to
cause a lot of work

00:14:57.870 --> 00:15:00.287
and maybe I don't want those
allocations in the background

00:15:00.287 --> 00:15:03.550
work to happen to do that
because maybe the code won't

00:15:03.550 --> 00:15:04.050
need it.

00:15:04.050 --> 00:15:05.460
So we'll do it lazily.

00:15:05.460 --> 00:15:07.230
We'll do it sometime later.

00:15:07.230 --> 00:15:09.810
So the manual approach
looks like this.

00:15:09.810 --> 00:15:12.510
So caveat, really
stupid example.

00:15:12.510 --> 00:15:15.218
Nobody should ever do this just
to avoid allocating an int,

00:15:15.218 --> 00:15:16.510
no matter how it's implemented.

00:15:16.510 --> 00:15:17.910
ROMAIN GUY: It is a
very stupid example.

00:15:17.910 --> 00:15:19.577
CHET HAASE: It is a
very stupid example,

00:15:19.577 --> 00:15:22.320
there is a very real example
that is almost as stupid,

00:15:22.320 --> 00:15:25.050
which is code that
we actually saw.

00:15:25.050 --> 00:15:28.300
Which did lazy allocation
for a Rect object,

00:15:28.300 --> 00:15:32.220
which is just four times
less stupid than this.

00:15:32.220 --> 00:15:34.650
So allocating 4 integers,
but for some reason,

00:15:34.650 --> 00:15:35.910
they wanted to do it lazily.

00:15:35.910 --> 00:15:37.840
Because why allocate
if you don't need to?

00:15:37.840 --> 00:15:38.490
Right?

00:15:38.490 --> 00:15:41.010
So, bear with me,
so we have this int.

00:15:41.010 --> 00:15:43.440
We're going to set
it equal to 573.

00:15:43.440 --> 00:15:45.380
But, maybe nobody is
going to need this,

00:15:45.380 --> 00:15:47.130
so we're going to
make it lazy instead.

00:15:47.130 --> 00:15:48.755
So we're going to
have a private member

00:15:48.755 --> 00:15:49.860
variable that's nullable.

00:15:49.860 --> 00:15:51.235
Now, part of the
problem here is,

00:15:51.235 --> 00:15:53.310
we know from the earlier
example is, well,

00:15:53.310 --> 00:15:55.975
now we have something that could
have been a primitive but now

00:15:55.975 --> 00:15:58.350
all of a sudden we've made it
an object-type instead just

00:15:58.350 --> 00:15:59.910
because we want
to set it to null.

00:15:59.910 --> 00:16:03.893
But anyway, you've got this
private member variable

00:16:03.893 --> 00:16:05.310
and then you have
the actual thing

00:16:05.310 --> 00:16:06.720
that they're going to access.

00:16:06.720 --> 00:16:09.422
And you say, OK, when they
actually call the getter,

00:16:09.422 --> 00:16:10.380
we'll see if it's null.

00:16:10.380 --> 00:16:11.797
And that's the
trigger to say, OK,

00:16:11.797 --> 00:16:14.610
now actually set the value of
this thing and return the value

00:16:14.610 --> 00:16:15.295
and you're done.

00:16:15.295 --> 00:16:17.670
Next time they ask for it,
it's already allocated and set

00:16:17.670 --> 00:16:19.030
and you don't have
to worry about it.

00:16:19.030 --> 00:16:20.988
That's the general
approach, I'm sure we've all

00:16:20.988 --> 00:16:22.620
done this hundreds
of times, hopefully,

00:16:22.620 --> 00:16:24.870
for less stupid
examples than this one.

00:16:24.870 --> 00:16:28.710
All right, this is what it
looks like at the Java level,

00:16:28.710 --> 00:16:30.390
this is essentially
what it compiles to.

00:16:30.390 --> 00:16:32.840
If we look at the
decomplied bytecode,

00:16:32.840 --> 00:16:35.430
it looks exactly as the
way we would expect it to.

00:16:35.430 --> 00:16:39.570
You've got the same thing
going on with ints and integers

00:16:39.570 --> 00:16:41.480
and it's doing the
right thing there.

00:16:41.480 --> 00:16:43.963
But, there's a better way
to do this with Kotlin.

00:16:43.963 --> 00:16:45.380
There's an automatic
approach that

00:16:45.380 --> 00:16:47.300
takes exactly one line of code.

00:16:47.300 --> 00:16:49.430
Isn't that much better to use?

00:16:49.430 --> 00:16:52.640
Say, by lazy, we'll
set it to 574.

00:16:52.640 --> 00:16:54.710
So it doesn't get set to
anything until someone

00:16:54.710 --> 00:16:56.000
asks for the first time.

00:16:56.000 --> 00:16:58.670
And then it goes
through some operations

00:16:58.670 --> 00:17:01.760
to actually allocate and
return this value of 574.

00:17:01.760 --> 00:17:05.000
And the question is, what
operations does it go through?

00:17:05.000 --> 00:17:09.349
So, I should explain
first, lazy is implemented

00:17:09.349 --> 00:17:12.520
using property
delegates in Kotlin

00:17:12.520 --> 00:17:16.790
and it's this generic mechanism
they have for delegating logic

00:17:16.790 --> 00:17:17.470
somewhere else.

00:17:17.470 --> 00:17:19.940
So when someone asks
for this variable,

00:17:19.940 --> 00:17:22.369
I want you to run this
logic over here and return

00:17:22.369 --> 00:17:23.910
other information from there.

00:17:23.910 --> 00:17:27.200
The other background piece
of information is properties.

00:17:27.200 --> 00:17:29.480
Properties in
Kotlin do much more

00:17:29.480 --> 00:17:32.180
than properties in the Java
programming language, which

00:17:32.180 --> 00:17:35.390
means, if you're going to access
information on a property using

00:17:35.390 --> 00:17:38.300
reflection, well, how does
that work through the bytecode

00:17:38.300 --> 00:17:42.270
since Java programming language
doesn't have that capability?

00:17:42.270 --> 00:17:44.240
Well, Kotlin needed
to add capabilities

00:17:44.240 --> 00:17:46.130
so that when you
use a reflection

00:17:46.130 --> 00:17:49.490
it will go through
their additional stuff

00:17:49.490 --> 00:17:51.620
to actually get that
extra bit of information

00:17:51.620 --> 00:17:52.490
from their property.

00:17:52.490 --> 00:17:55.280
So they created this
class called K Property.

00:17:55.280 --> 00:17:58.380
And now if you use reflection
on a Kotlin property,

00:17:58.380 --> 00:18:01.567
it can go through the K Property
and get that extra information

00:18:01.567 --> 00:18:02.150
that it needs.

00:18:02.150 --> 00:18:05.720
So that's the background, here's
what's going on inside of lazy.

00:18:05.720 --> 00:18:08.780
First of all, when you say,
by lazy, it automatically

00:18:08.780 --> 00:18:10.550
creates an array.

00:18:10.550 --> 00:18:13.310
Allocation brain should say,
oh, there's an allocation.

00:18:13.310 --> 00:18:15.110
So you've got this
K Property array

00:18:15.110 --> 00:18:17.870
where it's going to set up the
information for getting things

00:18:17.870 --> 00:18:20.840
from this Kotlin specific
property reflection mechanism

00:18:20.840 --> 00:18:21.608
that they have.

00:18:21.608 --> 00:18:23.150
So we've got the
array, and the array

00:18:23.150 --> 00:18:26.090
consists of one item, which is
this K Property that they've

00:18:26.090 --> 00:18:28.820
set up specifically for
this lazy property you've

00:18:28.820 --> 00:18:29.690
told it about.

00:18:29.690 --> 00:18:30.810
You've got the class name.

00:18:30.810 --> 00:18:32.150
You've got the type.

00:18:32.150 --> 00:18:33.882
And that's basically
it, you've got

00:18:33.882 --> 00:18:35.090
the name of the thing, right?

00:18:35.090 --> 00:18:38.630
So it sets us up array plus an
allocation of the K Property

00:18:38.630 --> 00:18:40.190
inside of it.

00:18:40.190 --> 00:18:42.060
Then it sets up this
call internally,

00:18:42.060 --> 00:18:43.880
this is, sort of,
initialization time code.

00:18:43.880 --> 00:18:45.680
It says, OK, there's
this lazy thing

00:18:45.680 --> 00:18:48.140
that's going to return
a class of type lazy,

00:18:48.140 --> 00:18:50.940
and from that, we
can get the value.

00:18:50.940 --> 00:18:53.583
So when you call the
getter on that property,

00:18:53.583 --> 00:18:55.250
it's going to call
into this code, which

00:18:55.250 --> 00:18:57.800
is going to call a get
value on that lazy object.

00:18:57.800 --> 00:19:00.290
And then it's going to
call int value on that.

00:19:00.290 --> 00:19:04.100
All of this could bottom
out in reflection code

00:19:04.100 --> 00:19:05.990
to go get it from
K Property, which

00:19:05.990 --> 00:19:09.620
is even worse than the
allocations we've seen so far.

00:19:09.620 --> 00:19:13.160
At the end of all of this, you
may end up in reflection code

00:19:13.160 --> 00:19:15.180
just to get an integer value.

00:19:15.180 --> 00:19:16.820
However, because of
extension methods,

00:19:16.820 --> 00:19:19.250
they're more clever than that
and they actually spit out

00:19:19.250 --> 00:19:23.450
this extension
method that says, oh,

00:19:23.450 --> 00:19:25.310
if they're using the
lazy class then we're

00:19:25.310 --> 00:19:27.140
just going to call
this function instead.

00:19:27.140 --> 00:19:29.900
So no need for reflection
even though K Properties stuff

00:19:29.900 --> 00:19:32.773
was set up and has
reflection capabilities,

00:19:32.773 --> 00:19:34.190
we're not using
that aspect of it.

00:19:34.190 --> 00:19:36.260
Instead, it will just
call into this method

00:19:36.260 --> 00:19:38.810
and get the value,
which is this.

00:19:38.810 --> 00:19:40.820
Simpler than
reflection, however,

00:19:40.820 --> 00:19:43.220
couple of conditions to
check, and a synchronized

00:19:43.220 --> 00:19:45.560
block in there, just
to get this int value

00:19:45.560 --> 00:19:47.600
from this very stupid
example I've written.

00:19:47.600 --> 00:19:50.060
In addition to that,
when all of this is setup

00:19:50.060 --> 00:19:53.360
we go through initialization
code, which in bytecode looks

00:19:53.360 --> 00:19:54.310
something like this.

00:19:54.310 --> 00:19:56.870
So, basically, whenever
you get into this

00:19:56.870 --> 00:19:58.910
and initialize this
object, this is

00:19:58.910 --> 00:20:01.880
what gets emitted on your
behalf under the hood just

00:20:01.880 --> 00:20:03.950
to save an allocation
of an integer object.

00:20:03.950 --> 00:20:06.410
As I said, stupid
example, but real example

00:20:06.410 --> 00:20:09.410
is people doing it for small
data structures like Rect.

00:20:09.410 --> 00:20:10.890
So lazy is awesome.

00:20:10.890 --> 00:20:13.410
It's really cool that you can
do this in one line of code.

00:20:13.410 --> 00:20:15.710
And if you have a
complicated data structure,

00:20:15.710 --> 00:20:17.930
or a lot of complicated
object, when it gets set up

00:20:17.930 --> 00:20:20.810
and if it is not going to be
used very often, totally worth

00:20:20.810 --> 00:20:21.890
considering.

00:20:21.890 --> 00:20:25.995
For avoiding the allocation
of a simple int, probably not.

00:20:25.995 --> 00:20:28.370
ROMAIN GUY: So now let's take
a look at unsigned numbers.

00:20:28.370 --> 00:20:30.530
So this is a new
experimental feature

00:20:30.530 --> 00:20:33.980
that was introduced
in the Kotlin 1.3.

00:20:33.980 --> 00:20:39.680
So Java has mostly sign
numbers and Kotlin is finally

00:20:39.680 --> 00:20:42.110
bringing unsigned numbers,
which can be very useful when

00:20:42.110 --> 00:20:43.310
you do graphics code.

00:20:43.310 --> 00:20:46.670
For instance, when you
have a width and height,

00:20:46.670 --> 00:20:48.405
unsigned very useful as we know.

00:20:48.405 --> 00:20:49.780
As a type check
that's you're not

00:20:49.780 --> 00:20:51.530
going to get a negative
value, which would

00:20:51.530 --> 00:20:52.730
make no sense for dimension.

00:20:52.730 --> 00:20:55.070
So if you enable this
experimental feature,

00:20:55.070 --> 00:20:57.810
here's how you can use
the unsigned numbers.

00:20:57.810 --> 00:21:02.060
You can use the U suffix to
declare a type to be unsigned.

00:21:02.060 --> 00:21:03.740
And under the hood,
they're implemented

00:21:03.740 --> 00:21:06.160
using another experimental
feature called Inline Classes

00:21:06.160 --> 00:21:07.970
and we're going to take a
closer look at Inline Classes

00:21:07.970 --> 00:21:08.940
in a little bit.

00:21:08.940 --> 00:21:10.815
But first, let's take
a look at this example.

00:21:10.815 --> 00:21:13.190
So I declared two
unsigned numbers,

00:21:13.190 --> 00:21:15.150
and then I just add them.

00:21:15.150 --> 00:21:16.550
So what happens?

00:21:16.550 --> 00:21:19.513
So every unsigned number
is just an integer

00:21:19.513 --> 00:21:21.680
that's pushed on the stack
and storing the variable.

00:21:21.680 --> 00:21:24.290
So here, there's nothing
interesting to see.

00:21:24.290 --> 00:21:27.170
And when we add them, we just
load those two variables.

00:21:27.170 --> 00:21:30.530
We call the IADD up
code in bytecode,

00:21:30.530 --> 00:21:33.860
which is just the addition
of two integers, which

00:21:33.860 --> 00:21:35.360
are normally sine.

00:21:35.360 --> 00:21:36.860
But generally, they
were very clever

00:21:36.860 --> 00:21:39.590
and they realized that because
of the way that sine numbers

00:21:39.590 --> 00:21:41.640
and sine integers are
included, it actually

00:21:41.640 --> 00:21:42.870
works with unsigned as well.

00:21:42.870 --> 00:21:45.972
So They didn't have to
create anything new,

00:21:45.972 --> 00:21:47.430
you just use the
existing bytecode,

00:21:47.430 --> 00:21:49.230
everything happens at
their language level.

00:21:49.230 --> 00:21:50.980
The only thing that's
really bizarre here,

00:21:50.980 --> 00:21:53.130
is that we invoke a
static function called

00:21:53.130 --> 00:21:55.780
UInt.constructor-impl.

00:21:55.780 --> 00:21:59.860
And you can see that it takes an
integer and returns an integer.

00:21:59.860 --> 00:22:03.180
So if we look at the [INAUDIBLE]
function to see what it does,

00:22:03.180 --> 00:22:05.160
that's where things get
a little surprising.

00:22:05.160 --> 00:22:08.700
And I'm sure the JetBrains folks
would know why it does this.

00:22:08.700 --> 00:22:09.940
I have no idea.

00:22:09.940 --> 00:22:13.390
So we have this function, takes
an integer, returns an integer,

00:22:13.390 --> 00:22:14.640
and here's the implementation.

00:22:14.640 --> 00:22:16.890
It loads the perimeter
that you give it,

00:22:16.890 --> 00:22:18.630
and then it returns it.

00:22:18.630 --> 00:22:20.610
And that's it.

00:22:20.610 --> 00:22:24.910
So I don't know why it's there,
it's maybe for the debugger

00:22:24.910 --> 00:22:26.370
so you can break on it.

00:22:26.370 --> 00:22:28.165
But other than that,

00:22:28.165 --> 00:22:30.540
I know that the [INAUDIBLE]
or the ahead of time compiler

00:22:30.540 --> 00:22:32.430
will get rid of it or
probably [INAUDIBLE]..

00:22:32.430 --> 00:22:33.530
So we don't need to
worry about this.

00:22:33.530 --> 00:22:36.090
It's just a little strange that
we have this extra bytecode

00:22:36.090 --> 00:22:36.828
for no reason.

00:22:36.828 --> 00:22:38.370
So if we look at
the other operators,

00:22:38.370 --> 00:22:40.480
we saw that the addition
is just implemented

00:22:40.480 --> 00:22:43.440
with the existing up code, add,
same thing for the subtraction,

00:22:43.440 --> 00:22:45.190
same thing with
the multiplication.

00:22:45.190 --> 00:22:47.520
So only when you do a
division that Kotlin

00:22:47.520 --> 00:22:52.020
has to invoke a special static
method because divisions

00:22:52.020 --> 00:22:53.140
works differently.

00:22:53.140 --> 00:22:54.640
So there's more
code that runs here.

00:22:54.640 --> 00:22:57.810
So most of the time, unsigned
numbers are basically free.

00:22:57.810 --> 00:23:00.548
So you should feel
free to use them.

00:23:00.548 --> 00:23:02.340
Now let's look at what
happens when you try

00:23:02.340 --> 00:23:03.570
to print one of those numbers.

00:23:03.570 --> 00:23:05.528
Basically, when you try
to call toString on it.

00:23:05.528 --> 00:23:08.250
So here I have a signed
number and an unsigned number

00:23:08.250 --> 00:23:09.480
and I print them both.

00:23:09.480 --> 00:23:12.070
For first, let's look
at the sign number.

00:23:12.070 --> 00:23:14.220
So we have this variable
called z, it's equal to 42

00:23:14.220 --> 00:23:17.680
and we call println on it.

00:23:17.680 --> 00:23:19.180
So that's exactly
what we expect.

00:23:19.180 --> 00:23:21.850
But when we use the unsigned
number, instead of printing it

00:23:21.850 --> 00:23:25.830
directly, because the digital
printing line in the runtime

00:23:25.830 --> 00:23:27.990
does not know about
unsigned numbers,

00:23:27.990 --> 00:23:29.890
we have to go through
something else.

00:23:29.890 --> 00:23:32.170
And because the unsigned
numbers are implemented using

00:23:32.170 --> 00:23:34.050
inline classes we have box.

00:23:34.050 --> 00:23:36.870
So we called this
function called box-impl.

00:23:36.870 --> 00:23:39.360
It takes our unsigned
integers and wrap it

00:23:39.360 --> 00:23:41.880
into an instance of
a class called Uint.

00:23:41.880 --> 00:23:44.410
And that gets passed
to println because UInt

00:23:44.410 --> 00:23:46.520
has a toString method
that's implemented

00:23:46.520 --> 00:23:48.250
and does the right thing.

00:23:48.250 --> 00:23:50.100
So even if you use
unsigned numbers

00:23:50.100 --> 00:23:51.560
and they are most
of the time free,

00:23:51.560 --> 00:23:53.310
you can end up doing
boxing and therefore,

00:23:53.310 --> 00:23:56.610
allocation fairly easily if
you just add them to a string,

00:23:56.610 --> 00:23:57.650
for instance.

00:23:57.650 --> 00:23:59.280
CHET HAASE: Let's
talk about ranges.

00:23:59.280 --> 00:24:02.250
One of the curious things
that a lot of programmers

00:24:02.250 --> 00:24:04.950
hit when they see Kotlin for
the first time is the for loops.

00:24:04.950 --> 00:24:07.500
They, kind of, look for the
syntax that they always knew

00:24:07.500 --> 00:24:10.990
from Java or C or C++
or other languages.

00:24:10.990 --> 00:24:12.090
And it's not that.

00:24:12.090 --> 00:24:15.900
Instead all of the for
loops work with ranges.

00:24:15.900 --> 00:24:17.680
And there are many
ways to do this.

00:24:17.680 --> 00:24:20.250
So you could say,
for i in this range

00:24:20.250 --> 00:24:24.870
of 0 to 10 inclusive or
exclusive until you get to 10.

00:24:24.870 --> 00:24:27.548
Or you could just say, repeat
the following operation,

00:24:27.548 --> 00:24:28.590
give it the lambda there.

00:24:28.590 --> 00:24:30.490
Or you could put the
range on the front.

00:24:30.490 --> 00:24:34.290
These all look the same to me,
modulo that off by one error

00:24:34.290 --> 00:24:37.440
that we have in the second one.

00:24:37.440 --> 00:24:39.690
It turns out they're kind
of different under the hood.

00:24:39.690 --> 00:24:41.857
So that first one works the
way that we would think.

00:24:41.857 --> 00:24:44.100
It's, basically,
equivalent of the for loop

00:24:44.100 --> 00:24:46.560
we would expect in Java.

00:24:46.560 --> 00:24:48.030
Second one same
thing, except we're

00:24:48.030 --> 00:24:50.257
not going all the way
to the last value there.

00:24:50.257 --> 00:24:52.840
Same thing for the third, like
all straightforward iterations.

00:24:52.840 --> 00:24:56.250
But the way the last
one is implemented

00:24:56.250 --> 00:24:57.190
is a little different.

00:24:57.190 --> 00:24:59.273
Instead, we're going to
create an iterable object.

00:24:59.273 --> 00:25:01.450
We're going to create
an int range object,

00:25:01.450 --> 00:25:03.810
and then going to use the
iteration mechanism, which

00:25:03.810 --> 00:25:07.590
seems a little bit heavyweight
for just having flip the range

00:25:07.590 --> 00:25:08.730
to the front there.

00:25:08.730 --> 00:25:10.530
Not a big deal,
but kind of curious

00:25:10.530 --> 00:25:12.650
that they're all quite
different under the hood.

00:25:15.160 --> 00:25:17.730
ROMAIN GUY: So in the
traditional for loop

00:25:17.730 --> 00:25:19.380
with other languages
you can easily

00:25:19.380 --> 00:25:21.260
increment the counter
by more than one,

00:25:21.260 --> 00:25:22.260
so everything plus plus.

00:25:22.260 --> 00:25:23.563
You can say, plus equal 2.

00:25:23.563 --> 00:25:25.230
And the way you do
this in Kotlin is you

00:25:25.230 --> 00:25:29.230
can use the step operator
or infix function.

00:25:29.230 --> 00:25:33.510
So in that case, you're going
to go from 0 to 10 inclusive

00:25:33.510 --> 00:25:36.390
and we wanted to increment
by 2, we'd say step 2.

00:25:36.390 --> 00:25:38.910
And I would expect the code
to look exactly the same as

00:25:38.910 --> 00:25:41.290
before, but we get this instead.

00:25:41.290 --> 00:25:44.700
So just by adding "step" the
transition and the compiler

00:25:44.700 --> 00:25:45.840
basically disappears.

00:25:45.840 --> 00:25:48.160
And instead we have
to create a range.

00:25:48.160 --> 00:25:49.890
We have to create
this in progression

00:25:49.890 --> 00:25:52.170
and then the compiler
calls get first, get last,

00:25:52.170 --> 00:25:54.840
and get step, which are in
this [INAUDIBLE] constant.

00:25:54.840 --> 00:25:56.723
So it's not entirely necessary.

00:25:56.723 --> 00:25:58.140
And then we have
a while loop that

00:25:58.140 --> 00:26:00.390
makes sure that we do it
the right number of times.

00:26:00.390 --> 00:26:01.980
And it also happens
if you said, step

00:26:01.980 --> 00:26:04.285
1, which makes no sense to me.

00:26:04.285 --> 00:26:06.660
But assuming it's a missing
optimization in the compiler.

00:26:06.660 --> 00:26:08.568
CHET HAASE: That
first step is a doozy.

00:26:08.568 --> 00:26:10.110
ROMAIN GUY: Right,
so inline classes,

00:26:10.110 --> 00:26:12.180
I touched on those
a little bit when I

00:26:12.180 --> 00:26:13.660
talked about unsigned numbers.

00:26:13.660 --> 00:26:16.620
So inline classes are
where to wrap a type 1

00:26:16.620 --> 00:26:17.910
field effectively.

00:26:17.910 --> 00:26:20.680
And the point of inline
classes, as the name suggests,

00:26:20.680 --> 00:26:22.350
is that they disappear
at compile time.

00:26:22.350 --> 00:26:24.135
So that with unsigned
numbers there

00:26:24.135 --> 00:26:26.760
are a classical UInts but really
when you look at the bytecode,

00:26:26.760 --> 00:26:28.870
all you see in the end
is just an integer.

00:26:28.870 --> 00:26:31.830
So here, I created my own
inline class called, Color.

00:26:31.830 --> 00:26:35.250
And wraps an integer, because
color is often defined

00:26:35.250 --> 00:26:36.870
as an integer or Android.

00:26:36.870 --> 00:26:38.910
And I've created
custom properties

00:26:38.910 --> 00:26:41.780
to be able to extract the red,
green, blue, ans alpha channels

00:26:41.780 --> 00:26:44.630
from the int without having
to do that dance myself

00:26:44.630 --> 00:26:46.430
every time.

00:26:46.430 --> 00:26:49.710
So now, if we try to use
that inline class ourselves,

00:26:49.710 --> 00:26:51.260
I created a print
function that just

00:26:51.260 --> 00:26:54.260
formats a string using
the different channels

00:26:54.260 --> 00:26:55.080
of the color.

00:26:55.080 --> 00:26:57.580
And I create and instance at
the bottom in my main function.

00:26:57.580 --> 00:27:00.343
I called the printColor
function and just declare.

00:27:00.343 --> 00:27:01.760
And here's what
the bytecode looks

00:27:01.760 --> 00:27:02.910
like in the main function.

00:27:02.910 --> 00:27:05.740
So first, we push a
constant on the stack,

00:27:05.740 --> 00:27:07.910
it's that weird long
number that corresponds

00:27:07.910 --> 00:27:10.640
to the [? Higgs ?] additional
value that you saw in the code.

00:27:10.640 --> 00:27:13.280
And then we invoke that
color, that "constructor-impl"

00:27:13.280 --> 00:27:13.980
function.

00:27:13.980 --> 00:27:15.550
And you can see
it's signature, it

00:27:15.550 --> 00:27:18.440
takes an int, which is expected
because we wrap an integer

00:27:18.440 --> 00:27:19.850
and it returns an integer.

00:27:19.850 --> 00:27:22.250
So it's exactly what was
happening with unsigned

00:27:22.250 --> 00:27:24.320
before, we saw that this
constructor actually

00:27:24.320 --> 00:27:25.190
doesn't do anything.

00:27:25.190 --> 00:27:27.510
Just takes the input and
just returns it directly.

00:27:27.510 --> 00:27:28.813
So there's nothing to see here.

00:27:28.813 --> 00:27:30.980
What's interesting is what
happened to my printColor

00:27:30.980 --> 00:27:31.700
function.

00:27:31.700 --> 00:27:33.975
So in my source code,
is take color instance.

00:27:33.975 --> 00:27:35.600
Well, you can see
here, now it's called

00:27:35.600 --> 00:27:38.180
printColor- some
weird name, it's

00:27:38.180 --> 00:27:39.650
probably a hash of something.

00:27:39.650 --> 00:27:41.600
Instead of taking an
instance of color,

00:27:41.600 --> 00:27:43.280
it takes an integer directly.

00:27:43.280 --> 00:27:45.080
So the compiler
rewrote the function

00:27:45.080 --> 00:27:49.640
to work directly on the
primitive type I was wrapping.

00:27:49.640 --> 00:27:52.330
That said, sometimes inline
classes are not free,

00:27:52.330 --> 00:27:54.120
we saw that with
toString earlier.

00:27:54.120 --> 00:27:57.300
And the same thing can
happen with the == operator.

00:27:57.300 --> 00:28:00.700
So here, I create two
instances of my color class

00:28:00.700 --> 00:28:02.780
and I just called, I want
to print whether or not

00:28:02.780 --> 00:28:03.560
they are equal.

00:28:03.560 --> 00:28:05.100
And I do it in two
different ways.

00:28:05.100 --> 00:28:07.940
First, we use == and
then we do .equals.

00:28:07.940 --> 00:28:11.430
And those should be equivalent,
they should be the same thing.

00:28:11.430 --> 00:28:14.590
However, when we look at the
bytecode, here's what happens.

00:28:14.590 --> 00:28:18.350
So when I do a == b, first
we load one of the variables,

00:28:18.350 --> 00:28:22.610
I think it's b, then
we call "box-impl".

00:28:22.610 --> 00:28:25.880
And you can see that call
generating a color instance

00:28:25.880 --> 00:28:27.380
from that integer.

00:28:27.380 --> 00:28:30.540
Then we do the same thing
again for the a variable.

00:28:30.540 --> 00:28:32.570
And then finally, we
invoke a static function

00:28:32.570 --> 00:28:37.010
called, areEqual, that's
an intrinsic in the Kotlin

00:28:37.010 --> 00:28:38.060
standard library.

00:28:38.060 --> 00:28:40.533
So just to be able to compare
our two integers that we know

00:28:40.533 --> 00:28:42.950
are there, because we saw that
the compiler sometimes it's

00:28:42.950 --> 00:28:44.680
smart enough to get
rid of the class,

00:28:44.680 --> 00:28:47.030
we just boxed it back
into actual objects.

00:28:47.030 --> 00:28:49.730
We created to allocations just
to be able to compare those two

00:28:49.730 --> 00:28:52.090
integer values.

00:28:52.090 --> 00:28:55.680
If you call a.equals(b),
things are a little different.

00:28:55.680 --> 00:28:59.718
We load one of the variables
and we box the other one.

00:28:59.718 --> 00:29:01.260
So instead of having
two allocations,

00:29:01.260 --> 00:29:02.770
we have only one allocation.

00:29:02.770 --> 00:29:06.350
And instead here, we're calling
a method called, "equals-impl"

00:29:06.350 --> 00:29:07.460
on the color class.

00:29:07.460 --> 00:29:10.110
And you can see it takes
an integer and an object.

00:29:10.110 --> 00:29:13.160
So if you're gonna use inline
classes and you don't care

00:29:13.160 --> 00:29:15.820
about no ability, in the
[INAUDIBLE] instance,

00:29:15.820 --> 00:29:18.200
you're gonna locate half
as many objects if you say,

00:29:18.200 --> 00:29:21.680
a.equals(b) instead of a == b.

00:29:21.680 --> 00:29:23.930
CHET HAASE: Take a
quick look at arrays.

00:29:23.930 --> 00:29:27.500
The implementation
depends very much

00:29:27.500 --> 00:29:30.470
on little subtle differences
and how you declare things.

00:29:30.470 --> 00:29:32.930
So here we're going
to call intArrayOf

00:29:32.930 --> 00:29:34.873
and we pass in these things.

00:29:34.873 --> 00:29:36.290
And it's going to
say, yep, here's

00:29:36.290 --> 00:29:38.730
a primitive array that
contains those things.

00:29:38.730 --> 00:29:40.303
Or it we could say,
arrayOf and we're

00:29:40.303 --> 00:29:41.720
going to pass
through these things

00:29:41.720 --> 00:29:44.095
that we know that Kotlin is
really good at type inference

00:29:44.095 --> 00:29:46.820
and these are obviously
ints it says, yep,

00:29:46.820 --> 00:29:49.190
here's your integer array.

00:29:49.190 --> 00:29:51.230
Or we can say,
give me a IntArray

00:29:51.230 --> 00:29:54.500
and actually ask for
this thing specifically.

00:29:54.500 --> 00:29:58.970
And then it does the right thing
with a little bit more code.

00:29:58.970 --> 00:30:02.030
We're, basically, initializing
it inside the lambda there,

00:30:02.030 --> 00:30:05.500
and it creates that primitive
IntArray to whip through that.

00:30:05.500 --> 00:30:08.060
ROMAIN GUY: All right,
So with lambdas there's

00:30:08.060 --> 00:30:10.968
one [INAUDIBLE] case that can
be a little bit tricky in.

00:30:10.968 --> 00:30:13.010
And we just recorded the
but podcast this morning

00:30:13.010 --> 00:30:16.075
with the Pocket Casts folks,
and Tor mentioned that.

00:30:16.075 --> 00:30:17.450
CHET HAASE: You
just leaked that.

00:30:17.450 --> 00:30:17.730
ROMAIN GUY: Yeah.

00:30:17.730 --> 00:30:17.830
CHET HAASE: Uh-oh.

00:30:17.830 --> 00:30:19.130
ROMAIN GUY: So what
you're going to see

00:30:19.130 --> 00:30:20.660
is a possible
programming mistake.

00:30:20.660 --> 00:30:22.285
Thankfully, we have
a [INAUDIBLE] check

00:30:22.285 --> 00:30:24.410
in androids for the
ones who are against it.

00:30:24.410 --> 00:30:27.950
So for instance, a class
written in the Java programming

00:30:27.950 --> 00:30:30.410
language, it's a
widget of some kind.

00:30:30.410 --> 00:30:33.030
And you can register listeners,
so we have this interface,

00:30:33.030 --> 00:30:35.750
it has a single abstract
method, it's a sim.

00:30:35.750 --> 00:30:38.120
You can add a listener, you
can remove the listener,

00:30:38.120 --> 00:30:41.580
and you can ask how in
listeners are registered.

00:30:41.580 --> 00:30:43.590
Now let's try to use
this from Kotlin.

00:30:43.590 --> 00:30:46.040
So first of all, we
instantiate our widgets.

00:30:46.040 --> 00:30:48.590
Then I create my
listener as a lambda.

00:30:48.590 --> 00:30:52.790
And if we go back, our single
abstract method takes a widget

00:30:52.790 --> 00:30:55.940
instance as a parameter
So we create a lambda that

00:30:55.940 --> 00:30:58.850
matches this signature,
it takes a widget

00:30:58.850 --> 00:31:01.070
and then we do something
with it, we print it.

00:31:01.070 --> 00:31:02.945
Then I call addListener
on my widget

00:31:02.945 --> 00:31:07.670
and then I print the number of
listeners that are registered.

00:31:07.670 --> 00:31:10.170
And finally, I try to remove
that listener and a printed

00:31:10.170 --> 00:31:12.125
number of listeners
that are registered.

00:31:15.885 --> 00:31:17.510
So what's going to
happen is that, when

00:31:17.510 --> 00:31:19.260
we print a number of
listeners after adding it,

00:31:19.260 --> 00:31:20.990
it's going to say there's 1
listener, that's completely

00:31:20.990 --> 00:31:21.490
expected.

00:31:21.490 --> 00:31:24.780
But after calling remove, the
number of listeners is still 1.

00:31:24.780 --> 00:31:26.600
The remove did not work.

00:31:26.600 --> 00:31:28.183
And to understand
why it doesn't work.

00:31:28.183 --> 00:31:29.600
We have to look
at the code that's

00:31:29.600 --> 00:31:30.710
generated by the compiler.

00:31:30.710 --> 00:31:32.800
So here's what it looks like.

00:31:32.800 --> 00:31:34.940
Our listener, because
it's a lambda,

00:31:34.940 --> 00:31:37.325
it becomes a function
1 type internally.

00:31:37.325 --> 00:31:39.200
And the function 1 is
effectively your lambda

00:31:39.200 --> 00:31:41.090
that there's one parameter.

00:31:41.090 --> 00:31:43.040
But because that
type is function 1,

00:31:43.040 --> 00:31:45.550
it is not the listener of
type of which it expects.

00:31:45.550 --> 00:31:47.900
So the compiler generates
this extra class

00:31:47.900 --> 00:31:51.590
called Widget_Listener that
is of the type listener

00:31:51.590 --> 00:31:52.730
that we expect.

00:31:52.730 --> 00:31:55.760
And it passes it our
function 1, our lambda,

00:31:55.760 --> 00:31:58.440
so it wraps it into
something else.

00:31:58.440 --> 00:32:01.850
And it's that other object that
gets passed to addListener.

00:32:01.850 --> 00:32:04.160
And you can probably guess
what's coming up next,

00:32:04.160 --> 00:32:06.770
when we remove listener
with our lambda,

00:32:06.770 --> 00:32:09.350
it gets wrapped again
with a different instance.

00:32:09.350 --> 00:32:11.450
So we're trying to remove
a different listener,

00:32:11.450 --> 00:32:13.620
and so we actually
leaked our listener.

00:32:13.620 --> 00:32:15.680
And this is the
kind of stuff that's

00:32:15.680 --> 00:32:17.900
Android Studio will
warn you against.

00:32:17.900 --> 00:32:19.230
And the fix is fairly easy.

00:32:19.230 --> 00:32:21.980
You just have to be specific
about the type of your lambda.

00:32:21.980 --> 00:32:24.260
Just say, it is
a Widget.Listener

00:32:24.260 --> 00:32:27.082
and don't just use
the naked lambda form.

00:32:27.082 --> 00:32:29.540
CHET HAASE: So let's take a
look at how extension functions

00:32:29.540 --> 00:32:31.550
actually work under the hood.

00:32:31.550 --> 00:32:34.040
So you have this simple
class that I've defined.

00:32:34.040 --> 00:32:36.680
Again, I wrote this
code all by myself.

00:32:36.680 --> 00:32:38.750
We have a Superclass and
then we have a Subclass,

00:32:38.750 --> 00:32:40.880
which extends that Superclass.

00:32:40.880 --> 00:32:41.390
Awesome.

00:32:41.390 --> 00:32:43.510
Then we have a couple
of extension methods

00:32:43.510 --> 00:32:45.260
that we've defined,
one on the Superclass,

00:32:45.260 --> 00:32:46.497
one on the Subclass.

00:32:46.497 --> 00:32:48.080
And they print out
this value, or they

00:32:48.080 --> 00:32:50.270
return the string
value that indicates

00:32:50.270 --> 00:32:52.490
which one was actually called.

00:32:52.490 --> 00:32:54.050
So the superInstance,
we say, Yep,

00:32:54.050 --> 00:32:55.940
give me one of those
Superclass objects.

00:32:55.940 --> 00:32:58.440
Subclass, give me one of
those Subclass objects.

00:32:58.440 --> 00:33:01.190
And then we have one
where it is a Subclass

00:33:01.190 --> 00:33:04.340
but we cast it to a Superclass.

00:33:04.340 --> 00:33:06.110
And then the question
is, what happens

00:33:06.110 --> 00:33:09.373
when we call getIdentifier
on each of these things?

00:33:09.373 --> 00:33:10.790
And then we have
one more example,

00:33:10.790 --> 00:33:13.400
where instead of pre-casting
it, we're casting it at runtime

00:33:13.400 --> 00:33:14.610
through a Superclass.

00:33:14.610 --> 00:33:18.225
So the question is, when we call
getIdentifier on the SuperVal

00:33:18.225 --> 00:33:18.725
we get--

00:33:21.250 --> 00:33:22.503
anybody awake?

00:33:22.503 --> 00:33:23.170
AUDIENCE: Super!

00:33:23.170 --> 00:33:24.170
CHET HAASE: There we go!

00:33:24.170 --> 00:33:25.230
What a super answer.

00:33:25.230 --> 00:33:27.330
All right, how
about the next one?

00:33:27.330 --> 00:33:28.160
AUDIENCE: Sub.

00:33:28.160 --> 00:33:29.535
CHET HAASE: All
right, thank you.

00:33:29.535 --> 00:33:30.762
And number three?

00:33:30.762 --> 00:33:31.940
AUDIENCE: Sub.

00:33:31.940 --> 00:33:33.340
CHET HAASE: Wrong.

00:33:33.340 --> 00:33:34.160
Sorry.

00:33:34.160 --> 00:33:34.660
Super.

00:33:34.660 --> 00:33:36.743
So this is the one that's
a little bit surprising.

00:33:36.743 --> 00:33:38.480
And finally, the
last one is the same.

00:33:38.480 --> 00:33:41.350
So it is a Subclass, what
is actually going on?

00:33:41.350 --> 00:33:44.890
Like, shouldn't it be calling
that method on the Subclass?

00:33:44.890 --> 00:33:48.220
It's because of the
implementation these things.

00:33:48.220 --> 00:33:50.508
So if we look at the
decomplied bytecode,

00:33:50.508 --> 00:33:52.050
this is what we've
got. getIdentifier

00:33:52.050 --> 00:33:54.640
is now a static
method and it takes

00:33:54.640 --> 00:33:56.950
an instance of Superclass.

00:33:56.950 --> 00:34:00.600
Same thing for sub, the
getIdentifier on the Subclass

00:34:00.600 --> 00:34:01.100
object.

00:34:01.100 --> 00:34:04.930
So that means that when we call
it with a Superclass object,

00:34:04.930 --> 00:34:08.139
we end up in the one that
takes a Superclass type.

00:34:08.139 --> 00:34:11.889
Same thing for sub, and same
thing for sub cast as super,

00:34:11.889 --> 00:34:15.100
we have told the type system
this is a Superclass no matter

00:34:15.100 --> 00:34:17.080
how we actually
created it, so it's

00:34:17.080 --> 00:34:20.440
going to call getIdentifier
that takes a Superclass instead.

00:34:20.440 --> 00:34:24.318
And same thing for the thing
that's cast at runtime.

00:34:24.318 --> 00:34:25.610
ROMAIN GUY: Default parameters.

00:34:25.610 --> 00:34:27.398
It's a very handy
function in Kotlin.

00:34:27.398 --> 00:34:29.440
You can specify default
value for your parameters

00:34:29.440 --> 00:34:31.090
and then you can use
either name parameters

00:34:31.090 --> 00:34:32.949
to invoke them or just
omit the parameters

00:34:32.949 --> 00:34:35.260
and rely on the compiler
to do the right thing.

00:34:35.260 --> 00:34:37.210
So here, I have a
very useful method.

00:34:37.210 --> 00:34:39.639
It takes two floats
and just adds them

00:34:39.639 --> 00:34:40.719
and returns the results.

00:34:43.239 --> 00:34:45.219
Chet, where the rest of the--

00:34:45.219 --> 00:34:47.020
oh, sorry.

00:34:47.020 --> 00:34:48.590
Wrong side.

00:34:48.590 --> 00:34:49.090
All right.

00:34:49.090 --> 00:34:50.722
So here's the code
that gets generated.

00:34:50.722 --> 00:34:53.139
So from that code that we have
that take default parameter

00:34:53.139 --> 00:34:55.540
values, we have a
new static function

00:34:55.540 --> 00:34:58.510
that was created that just takes
our two floats with our default

00:34:58.510 --> 00:35:00.790
values, because we
generated bytecode,

00:35:00.790 --> 00:35:04.010
and it just adds them
and returns the results.

00:35:04.010 --> 00:35:06.760
But there's another
method that was created.

00:35:06.760 --> 00:35:09.020
So it takes two
floats, as we expect,

00:35:09.020 --> 00:35:11.650
and then it also takes
an integer and an object.

00:35:11.650 --> 00:35:13.990
As far as I can tell, the
object is always set to null,

00:35:13.990 --> 00:35:14.880
so I'm not sure why it's there.

00:35:14.880 --> 00:35:17.110
It's probably to tag those
methods in a way or another.

00:35:17.110 --> 00:35:19.568
I should ask JetBrains, they
will probably know the answer.

00:35:19.568 --> 00:35:22.180
And the integer is
actually a bit field,

00:35:22.180 --> 00:35:26.770
where every bit tells the method
which parameters you did not

00:35:26.770 --> 00:35:28.550
specify at the call site.

00:35:28.550 --> 00:35:30.730
So you can see here, when
we check the first bit

00:35:30.730 --> 00:35:34.390
var 2 and 1, if it's set,
that means that we did not

00:35:34.390 --> 00:35:35.842
specify a value.

00:35:35.842 --> 00:35:37.300
So we use the
default value that we

00:35:37.300 --> 00:35:38.620
specified on the Kotlin site.

00:35:38.620 --> 00:35:41.080
And then we do this for
everybody parameter,

00:35:41.080 --> 00:35:43.780
and at the end we invoke
the actual function

00:35:43.780 --> 00:35:46.660
that's at the top.

00:35:46.660 --> 00:35:50.740
What's interesting, because it's
an integer I was wondering--

00:35:50.740 --> 00:35:52.690
there's only 32
bits, so what happens

00:35:52.690 --> 00:35:54.505
when you have 33 parameters?

00:35:54.505 --> 00:35:56.630
And we're going to take a
look at that in a moment.

00:35:56.630 --> 00:35:58.912
But just here are some
examples of how it works.

00:35:58.912 --> 00:36:00.370
So if I called my
function directly

00:36:00.370 --> 00:36:03.730
without specifying any
values, the Kotlin complier

00:36:03.730 --> 00:36:05.530
would just use the
default value, 0.

00:36:05.530 --> 00:36:07.738
And then for the bit field,
you have to off set three

00:36:07.738 --> 00:36:09.192
so the bit 1 and 2 are set.

00:36:09.192 --> 00:36:10.900
And it's going to use
the default values.

00:36:10.900 --> 00:36:13.030
If I specified the
first parameter,

00:36:13.030 --> 00:36:15.400
we see our value as the
first parameter, which is 0.

00:36:15.400 --> 00:36:16.775
For the second
one, the bit field

00:36:16.775 --> 00:36:19.960
is set to 2 because the
second parameter is not set.

00:36:19.960 --> 00:36:22.217
Same thing when you specify
only the second parameter.

00:36:22.217 --> 00:36:24.550
And then, of course, if you
specified the two parameters

00:36:24.550 --> 00:36:27.130
we call directly the function
that does the actual work

00:36:27.130 --> 00:36:28.420
and we skip all those checks.

00:36:28.420 --> 00:36:30.700
So we have only 32
bits, what happened

00:36:30.700 --> 00:36:34.060
when we create a function
that has 33 parameters?

00:36:34.060 --> 00:36:36.130
You should probably not
do that in your code.

00:36:36.130 --> 00:36:38.630
But just in case, a double
check for you what happen.

00:36:38.630 --> 00:36:40.687
Honestly, I was
expecting the compiler

00:36:40.687 --> 00:36:42.270
to just say nope,
too many parameters.

00:36:42.270 --> 00:36:43.630
I can't do that.

00:36:43.630 --> 00:36:45.980
What it does, it
creates two integers,

00:36:45.980 --> 00:36:47.890
so it just adds a
second bit field

00:36:47.890 --> 00:36:50.230
and it's going to look at
the bits in both bit fields.

00:36:50.230 --> 00:36:52.900
CHET HAASE: Because what's
better than a bit field?

00:36:52.900 --> 00:36:54.010
Two bit fields.

00:36:54.010 --> 00:36:54.993
[LAUGHTER]

00:36:54.993 --> 00:36:55.910
ROMAIN GUY: All right.

00:36:55.910 --> 00:36:56.450
Finally, coroutines.

00:36:56.450 --> 00:36:57.670
We only have three
more slides, so we're

00:36:57.670 --> 00:36:59.253
going to go through
this very quickly.

00:36:59.253 --> 00:37:01.200
How many of you use coroutines?

00:37:01.200 --> 00:37:01.700
OK.

00:37:01.700 --> 00:37:04.925
So sorry for those of you who
don't know how coroutines work,

00:37:04.925 --> 00:37:06.550
I'm not going to
explain that too much.

00:37:06.550 --> 00:37:08.830
But, basically, so you
have a suspend function,

00:37:08.830 --> 00:37:11.140
that means you can do
heavy work in there

00:37:11.140 --> 00:37:13.750
and here I call a
function called delay.

00:37:13.750 --> 00:37:15.280
We are assembling heavy work.

00:37:15.280 --> 00:37:17.620
Then I launch
coroutine, so we print

00:37:17.620 --> 00:37:20.530
that I'm launching a coroutine
and then I called launch.

00:37:20.530 --> 00:37:23.440
I call my suspend function
twice, so compute and compute.

00:37:23.440 --> 00:37:25.660
And finally, I print
"Exiting coroutine".

00:37:25.660 --> 00:37:27.460
So if we don't run
this program we're

00:37:27.460 --> 00:37:29.210
going to see the
falling out [INAUDIBLE]..

00:37:29.210 --> 00:37:31.330
We're launching the
coroutine with computing,

00:37:31.330 --> 00:37:33.455
that's our suspend function,
we're computing again.

00:37:33.455 --> 00:37:35.800
That's our suspend
function, we exit.

00:37:35.800 --> 00:37:38.090
Coroutines are implemented
using state machines.

00:37:38.090 --> 00:37:40.870
So if you look at the
code that's generated,

00:37:40.870 --> 00:37:42.715
it's going to look
something like this.

00:37:42.715 --> 00:37:44.590
There's going to be an
invokeSuspend function

00:37:44.590 --> 00:37:46.150
generated somewhere.

00:37:46.150 --> 00:37:48.580
And at the top there's a
switch on an internal field,

00:37:48.580 --> 00:37:50.620
so that function is
inside the class.

00:37:50.620 --> 00:37:52.750
And switches on the
field called label.

00:37:52.750 --> 00:37:56.560
And label is basically where you
are in coroutine state machine.

00:37:56.560 --> 00:37:59.510
So every suspend function
you call in the coroutine

00:37:59.510 --> 00:38:02.000
will be a state in
the state machine.

00:38:02.000 --> 00:38:05.860
So here you can see, we switch
on label, and indicate 0,

00:38:05.860 --> 00:38:07.270
we set the label
to 1, that means

00:38:07.270 --> 00:38:09.380
we advance to the next state.

00:38:09.380 --> 00:38:11.980
And we call our first instance
of the compute function.

00:38:11.980 --> 00:38:14.890
When those suspend functions
return a magic value called

00:38:14.890 --> 00:38:17.463
suspended, we return
from the state machine,

00:38:17.463 --> 00:38:19.380
that means that the
coroutine has to be paused

00:38:19.380 --> 00:38:22.710
and we have to come back later
when we can resume execution.

00:38:22.710 --> 00:38:25.790
And again, you look at the
other states or when this is 1,

00:38:25.790 --> 00:38:29.600
we advanced a state to 2 we
call computer a second time

00:38:29.600 --> 00:38:31.340
and we return for a suspended.

00:38:31.340 --> 00:38:34.483
So what I did is, I took
the bytecode of that,

00:38:34.483 --> 00:38:35.900
and the bytecode
starts like this,

00:38:35.900 --> 00:38:38.025
and I hacked it to add this.

00:38:38.025 --> 00:38:39.900
You don't need to
understand what it's doing,

00:38:39.900 --> 00:38:41.317
but, basically,
all I wanted to do

00:38:41.317 --> 00:38:44.480
was print the current state
of the coroutine of the state

00:38:44.480 --> 00:38:47.490
machine and rerun the program
to see what's going on.

00:38:47.490 --> 00:38:49.580
So this was the original
outputs and when

00:38:49.580 --> 00:38:52.950
I print this label field,
this is what it looks like.

00:38:52.950 --> 00:38:55.660
So we launched the coroutine,
we enter the state machine.

00:38:55.660 --> 00:38:56.570
The state is 0.

00:38:56.570 --> 00:38:58.970
We call compute after
suspend function.

00:38:58.970 --> 00:39:01.250
We return because
we're suspended.

00:39:01.250 --> 00:39:04.820
And then, at some point later,
we reenter the state machine,

00:39:04.820 --> 00:39:07.508
now the state is 1, we invoke
compute, we reach 1 again,

00:39:07.508 --> 00:39:09.800
we come back into the state
machine with the live state

00:39:09.800 --> 00:39:11.690
and then finally, we
exit the coroutine.

00:39:11.690 --> 00:39:13.908
So again, you should not
worry about this too much

00:39:13.908 --> 00:39:14.450
in your code.

00:39:14.450 --> 00:39:15.725
You use coroutines,
they're amazing.

00:39:15.725 --> 00:39:17.267
It's just very
interesting to go look

00:39:17.267 --> 00:39:18.800
at the bytecode
and the deride code

00:39:18.800 --> 00:39:21.370
to better understand
how they work.

00:39:21.370 --> 00:39:24.813
What looks magical, how
it works under the hood.

00:39:24.813 --> 00:39:27.230
And with that, you have 30
seconds, Chet, so [INAUDIBLE]..

00:39:27.230 --> 00:39:28.250
CHET HAASE: i guess
I'm gonna wrap up.

00:39:28.250 --> 00:39:31.355
So the question is, should you
actually care about this stuff?

00:39:31.355 --> 00:39:33.730
We've given a couple of talks
in the last couple of years

00:39:33.730 --> 00:39:34.370
and said, you know what?

00:39:34.370 --> 00:39:36.230
The runtime has
gotten so much better,

00:39:36.230 --> 00:39:39.290
stop worrying about all the
allocation and deallocation

00:39:39.290 --> 00:39:39.980
stuff.

00:39:39.980 --> 00:39:43.320
We told you early days of
Android, avoid allocations.

00:39:43.320 --> 00:39:46.220
Now, do the right thing for
your code and your APIs.

00:39:46.220 --> 00:39:48.210
So the question is,
did we lie to you?

00:39:48.210 --> 00:39:49.130
And the answer is, no.

00:39:49.130 --> 00:39:50.630
Actually, we were
telling the truth,

00:39:50.630 --> 00:39:51.810
that is still good advice.

00:39:51.810 --> 00:39:54.530
However-- oh, yeah.

00:39:54.530 --> 00:39:56.930
And there is the advice,
allocation, collections, always

00:39:56.930 --> 00:39:57.430
fine.

00:39:57.430 --> 00:39:59.323
But it's good to
actually understand

00:39:59.323 --> 00:40:00.490
what's going on in the hood.

00:40:00.490 --> 00:40:02.960
If you are trying to be
lazy about allocating

00:40:02.960 --> 00:40:05.780
even a Rect object, that's
not the right approach.

00:40:05.780 --> 00:40:06.380
Right?

00:40:06.380 --> 00:40:08.010
It probably doesn't matter.

00:40:08.010 --> 00:40:10.850
But isn't it nice to actually
know what's going on?

00:40:10.850 --> 00:40:14.087
And especially if you're
in an inner loop somewhere,

00:40:14.087 --> 00:40:15.920
maybe you actually don't
want that overhead,

00:40:15.920 --> 00:40:16.920
maybe it doesn't matter.

00:40:16.920 --> 00:40:19.070
On the other hand, if
you can save it in a case

00:40:19.070 --> 00:40:21.200
where it actually
matters in a loop,

00:40:21.200 --> 00:40:23.190
that's probably a good thing.

00:40:23.190 --> 00:40:24.540
And that is it.

00:40:24.540 --> 00:40:25.040
Thank you.

00:40:25.040 --> 00:40:25.640
[APPLAUSE]

00:40:25.640 --> 00:40:28.990
[MUSIC PLAYING]

