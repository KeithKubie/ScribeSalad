WEBVTT
Kind: captions
Language: en

00:00:00.499 --> 00:00:02.009
Hi, my name's Greg Littlefield.

00:00:02.009 --> 00:00:03.520
I'm an engineer at Workiva.

00:00:03.520 --> 00:00:05.520
And today, I'm going to
be talking about getting

00:00:05.520 --> 00:00:08.290
the most out of React in Dart.

00:00:08.290 --> 00:00:09.950
For this presentation,
first I'm going

00:00:09.950 --> 00:00:12.390
to go over a little
bit of background

00:00:12.390 --> 00:00:15.040
around Workiva's use
of React and Dart,

00:00:15.040 --> 00:00:17.720
and probably answer the question
that most of you have-- why

00:00:17.720 --> 00:00:19.660
React and Dart.

00:00:19.660 --> 00:00:22.007
Then I'm going to give
a quick intro to React,

00:00:22.007 --> 00:00:23.840
to help those of you
not familiar with React

00:00:23.840 --> 00:00:25.240
to get your feet
wet a little bit

00:00:25.240 --> 00:00:28.360
and understand the concepts
I'll be going over.

00:00:28.360 --> 00:00:31.225
Then I'm going to go over
the initial frustrations

00:00:31.225 --> 00:00:32.600
that we encountered
when we first

00:00:32.600 --> 00:00:34.420
started using React and Dart.

00:00:34.420 --> 00:00:38.060
And finally the good
stuff-- solving those issues

00:00:38.060 --> 00:00:41.190
and allieving those frustrations
using our new library

00:00:41.190 --> 00:00:42.390
that we've called OverReact.

00:00:42.390 --> 00:00:46.750
Great name, thank
our PM for that.

00:00:46.750 --> 00:00:51.410
So first, background-- at
Workiva, our first application

00:00:51.410 --> 00:00:54.080
was actually written
in Flash back in 2008.

00:00:54.080 --> 00:00:58.200
Eventually we migrated to
writing newer applications

00:00:58.200 --> 00:01:00.190
and new features in HTML5.

00:01:00.190 --> 00:01:02.710
We started with Angular
1.0 and jQuery, and then

00:01:02.710 --> 00:01:05.040
we eventually made
our way to React.

00:01:05.040 --> 00:01:05.970
We really liked React.

00:01:05.970 --> 00:01:09.150
We like the declarative
nature of rendering views.

00:01:09.150 --> 00:01:11.280
We like a uni-directional
data flow.

00:01:11.280 --> 00:01:13.890
And we started writing
a lot of UI in React.

00:01:13.890 --> 00:01:16.640
Then we stumbled upon
Dart, and we really

00:01:16.640 --> 00:01:19.200
liked the powerful
developer tools, how fast

00:01:19.200 --> 00:01:21.170
we could develop with it.

00:01:21.170 --> 00:01:23.450
We really wanted to put
the two together and get

00:01:23.450 --> 00:01:27.840
the best of both worlds,
and be able to continue

00:01:27.840 --> 00:01:30.310
taking advantage of all
of the existing React code

00:01:30.310 --> 00:01:31.910
that we had written.

00:01:31.910 --> 00:01:35.830
So we decided to use
React and Dart together.

00:01:35.830 --> 00:01:38.620
A little bit of
context on me-- I'm

00:01:38.620 --> 00:01:42.400
on the UI Platform
team at Workiva,

00:01:42.400 --> 00:01:46.560
and we're tasked with supporting
a number of product teams--

00:01:46.560 --> 00:01:48.740
alongside some other
platform teams--

00:01:48.740 --> 00:01:51.440
and creating reusable
UI components for all

00:01:51.440 --> 00:01:53.340
those product teams to use.

00:01:53.340 --> 00:01:56.360
When we first started
writing React in Dart,

00:01:56.360 --> 00:01:58.614
we found it kind of cumbersome.

00:01:58.614 --> 00:02:00.780
A lot of the stuff that
I'll be talking about today,

00:02:00.780 --> 00:02:05.370
like OverReact, is the result
of us improving that workflow

00:02:05.370 --> 00:02:08.270
and building upon that.

00:02:08.270 --> 00:02:10.669
So now a quick intro on React.

00:02:10.669 --> 00:02:13.230
Quick show of hands, how
many of you have used React

00:02:13.230 --> 00:02:17.370
or are familiar with
the basic tenets of it?

00:02:17.370 --> 00:02:20.250
OK, so we got some, not
everyone, so that's cool.

00:02:20.250 --> 00:02:22.510
Glad I have this section.

00:02:22.510 --> 00:02:24.320
React is centered
around components.

00:02:24.320 --> 00:02:27.570
There's DOM components
and custom components.

00:02:27.570 --> 00:02:30.550
You can see this is a
JSX representation of it.

00:02:30.550 --> 00:02:34.210
That's probably one of
the more popular syntaxes

00:02:34.210 --> 00:02:36.390
to consume React components.

00:02:36.390 --> 00:02:37.980
You can see, for
DOM components, it

00:02:37.980 --> 00:02:41.070
looks pretty similar
to standard HTML.

00:02:41.070 --> 00:02:44.960
You're passing in attributes,
or Key-value pairs,

00:02:44.960 --> 00:02:47.650
and then you're nesting
components within each other.

00:02:47.650 --> 00:02:50.400
For custom components, it
pretty much looks the same way.

00:02:50.400 --> 00:02:52.150
You can nest components
within each other,

00:02:52.150 --> 00:02:55.140
and you can specify
data by passing

00:02:55.140 --> 00:02:58.070
in these Key-value pairs
that look like attributes.

00:03:02.170 --> 00:03:05.700
Both forms eventually
render as HTML.

00:03:05.700 --> 00:03:07.900
DOM components get
translated directly.

00:03:07.900 --> 00:03:09.830
And then custom
components get translated

00:03:09.830 --> 00:03:15.990
into the virtual DOM, and
then into rendered HTML.

00:03:15.990 --> 00:03:19.850
So again, a custom component
encapsulates virtual DOM

00:03:19.850 --> 00:03:21.990
rendering, and it can
also include UI behavior.

00:03:21.990 --> 00:03:26.260
You can bind event handlers,
and do other things on it.

00:03:26.260 --> 00:03:29.070
Then the data that's passed
into components in React

00:03:29.070 --> 00:03:30.880
is referred to as props.

00:03:30.880 --> 00:03:34.660
And that's represented as
Key-value pairs, or a map.

00:03:34.660 --> 00:03:36.900
That data is immutable
to the component,

00:03:36.900 --> 00:03:39.110
so that can only be
updated when whatever

00:03:39.110 --> 00:03:41.079
is rendering it re-renders it.

00:03:41.079 --> 00:03:42.620
And the component
doesn't really have

00:03:42.620 --> 00:03:44.580
a say in updating that data.

00:03:44.580 --> 00:03:48.070
That's very core to the
React uni-directional data

00:03:48.070 --> 00:03:51.120
flow mental model.

00:03:51.120 --> 00:03:52.560
Components can also have state.

00:03:52.560 --> 00:03:58.970
This is another kind of
data that a component uses.

00:03:58.970 --> 00:04:02.050
It's maintained by the
component itself, though.

00:04:02.050 --> 00:04:03.850
The component itself
can mutate that data

00:04:03.850 --> 00:04:07.980
and manage it in response to
either user input, or server

00:04:07.980 --> 00:04:11.020
calls, or other external things.

00:04:11.020 --> 00:04:13.590
And then together, ideally,
only props and the state

00:04:13.590 --> 00:04:16.560
make up the rendered
output of components.

00:04:16.560 --> 00:04:20.279
Pure components, really
idiomatic React components,

00:04:20.279 --> 00:04:22.210
are only going to
use props and state.

00:04:22.210 --> 00:04:25.370
And their render method, which
generates a virtual DOM which

00:04:25.370 --> 00:04:28.900
then gets passed to React.

00:04:28.900 --> 00:04:29.970
I talked about Render.

00:04:29.970 --> 00:04:33.160
Render is one of the many
lifecycle methods in React.

00:04:33.160 --> 00:04:38.799
It's actually the only
required lifecycle method.

00:04:38.799 --> 00:04:41.340
There's a whole bunch of other
ones relating to the component

00:04:41.340 --> 00:04:44.680
bootstrapping, or mounting
and then receiving new data.

00:04:44.680 --> 00:04:46.450
I'm not really going
to get into those.

00:04:46.450 --> 00:04:50.540
All we're going to
worry about is render.

00:04:50.540 --> 00:04:52.900
Now let's talk about our
initial frustrations.

00:04:52.900 --> 00:04:55.470
Now that we know
how React works,

00:04:55.470 --> 00:04:59.510
we can kind of understand why
these things were frustrating.

00:04:59.510 --> 00:05:02.170
At Workiva, when we first
started using React and Dart,

00:05:02.170 --> 00:05:05.460
we used this library called
React-Dart on puppets React.

00:05:05.460 --> 00:05:08.720
This is a wrapper on top of
the React JavaScript library.

00:05:08.720 --> 00:05:12.040
What this wrapper does is
proxies lifecycle methods

00:05:12.040 --> 00:05:16.040
in React JavaScript code, and
exposes them via Dart API.

00:05:16.040 --> 00:05:18.900
So you can write actual
React JavaScript components

00:05:18.900 --> 00:05:21.925
with a Dart API, and it's all
backed by the React JavaScript

00:05:21.925 --> 00:05:22.425
library.

00:05:26.480 --> 00:05:29.720
This is how you would
consume a component in Dart

00:05:29.720 --> 00:05:30.890
using React-Dart.

00:05:30.890 --> 00:05:33.900
You can see it has the same
basic structure as the JSX.

00:05:33.900 --> 00:05:36.210
You're specifying data
as Key-value pairs,

00:05:36.210 --> 00:05:38.600
and you're nesting components.

00:05:38.600 --> 00:05:40.760
But we don't have
that JSX syntax.

00:05:40.760 --> 00:05:43.350
And actually, you can do the
same thing in JavaScript.

00:05:43.350 --> 00:05:46.470
If you don't want to
transpile your code from JSX

00:05:46.470 --> 00:05:49.990
to JavaScript, you can just
use those component factories

00:05:49.990 --> 00:05:52.930
directly, invoke them,
pass in the map of data,

00:05:52.930 --> 00:05:55.090
and then nest the
components inside.

00:05:55.090 --> 00:05:57.830
React-dart actually looks
really similar to React(JS),

00:05:57.830 --> 00:05:59.970
and using them is very similar.

00:05:59.970 --> 00:06:02.320
One thing to point
out though, is

00:06:02.320 --> 00:06:04.670
that in React(JS),
you can specify

00:06:04.670 --> 00:06:06.500
props using identifiers.

00:06:06.500 --> 00:06:08.585
You can use identifiers
as the keys and maps.

00:06:08.585 --> 00:06:10.270
Because in JavaScript
there's sort

00:06:10.270 --> 00:06:13.630
of a duality between
properties and Key-value pairs,

00:06:13.630 --> 00:06:15.880
maps and objects are
really the same thing.

00:06:15.880 --> 00:06:18.160
In Dart, that's not the case.

00:06:18.160 --> 00:06:21.380
In order to best
represent props and parity

00:06:21.380 --> 00:06:24.860
behavior of being able to merge
different props maps together,

00:06:24.860 --> 00:06:28.650
and be able to forward
certain props and not others,

00:06:28.650 --> 00:06:31.900
React-Dart went with map to best
represent that data structure.

00:06:31.900 --> 00:06:33.590
And I think that
was a good call.

00:06:33.590 --> 00:06:36.430
Just know that in React-Dart,
you do have to use string keys,

00:06:36.430 --> 00:06:38.630
whereas in JavaScript,
you could use string keys,

00:06:38.630 --> 00:06:42.470
but you could just use
an identifier instead.

00:06:42.470 --> 00:06:46.830
The problem with that is that we
can't get great static analysis

00:06:46.830 --> 00:06:48.200
on these Key-value pairs.

00:06:48.200 --> 00:06:50.330
I mean-- we can get
static analysis,

00:06:50.330 --> 00:06:54.410
and that will tell us if we
did something syntactically

00:06:54.410 --> 00:06:57.050
incorrect, but if we do
something semantically

00:06:57.050 --> 00:07:01.010
incorrect, then it's not really
going to tell us ahead of time.

00:07:01.010 --> 00:07:02.380
So what does that mean?

00:07:02.380 --> 00:07:04.590
Here's some examples of that.

00:07:04.590 --> 00:07:06.750
First, I've got a
custom button component

00:07:06.750 --> 00:07:08.300
and I want to make it green.

00:07:08.300 --> 00:07:11.790
So I'm going to set
the color prop on it

00:07:11.790 --> 00:07:13.680
and pass in the green skin.

00:07:13.680 --> 00:07:16.620
And it's not green.

00:07:16.620 --> 00:07:22.710
So maybe I forgot the API,
or I misremembered it,

00:07:22.710 --> 00:07:25.490
but color isn't the right
prop to make the button

00:07:25.490 --> 00:07:27.540
green-- to set that skin.

00:07:27.540 --> 00:07:30.460
And since color is not
used by the component,

00:07:30.460 --> 00:07:32.780
it's just going to
get ignored and passed

00:07:32.780 --> 00:07:35.826
through as an extraneous prop.

00:07:35.826 --> 00:07:37.450
If you set that prop,
you're not really

00:07:37.450 --> 00:07:39.660
going to get an indication
of why it's not working.

00:07:39.660 --> 00:07:43.210
You're just going to know
that it's not working.

00:07:43.210 --> 00:07:45.580
In this case, we would have
wanted to use the skin prop,

00:07:45.580 --> 00:07:47.960
and then that works correctly.

00:07:47.960 --> 00:07:51.960
A similar error is if you
mistype the skin prop,

00:07:51.960 --> 00:07:54.026
you could have a typo
in that string key,

00:07:54.026 --> 00:07:56.400
and it wouldn't give you an
indication that it was wrong,

00:07:56.400 --> 00:08:00.120
and you'd think that you did it
right, but it just won't work.

00:08:00.120 --> 00:08:01.850
So that can also be
frustrating, that you

00:08:01.850 --> 00:08:05.210
don't get typo checking.

00:08:05.210 --> 00:08:08.800
Another issue you can
run into is if your prop

00:08:08.800 --> 00:08:10.677
is of the wrong type.

00:08:10.677 --> 00:08:12.260
In this case, we
have a button, and we

00:08:12.260 --> 00:08:13.770
want to wire up
an onClick Handler

00:08:13.770 --> 00:08:15.360
so that when we
click it, it prints

00:08:15.360 --> 00:08:17.620
a message to the console.

00:08:17.620 --> 00:08:19.930
When we render that,
it actually works.

00:08:19.930 --> 00:08:23.000
But when we go to click on
it, we get a type error.

00:08:23.000 --> 00:08:26.620
The onClick handler expects
to have one argument

00:08:26.620 --> 00:08:28.290
it passes through the event.

00:08:28.290 --> 00:08:30.000
So when we give
it a function that

00:08:30.000 --> 00:08:33.320
doesn't take any arguments,
when Dart invokes that,

00:08:33.320 --> 00:08:34.880
we get this error.

00:08:34.880 --> 00:08:38.690
To resolve that, we
would add an event

00:08:38.690 --> 00:08:41.120
as a parameter to that method.

00:08:41.120 --> 00:08:44.569
That's a case where, even after
you run and bootstrap your app,

00:08:44.569 --> 00:08:46.110
you still won't know
that it's wrong.

00:08:46.110 --> 00:08:47.943
You have to go and
actually click the button

00:08:47.943 --> 00:08:50.690
to figure out that you made
a mistake, which is not

00:08:50.690 --> 00:08:52.030
a great development experience.

00:08:55.040 --> 00:08:56.860
Similarly, inside
of a component,

00:08:56.860 --> 00:09:00.660
when you're rendering the
encapsulated virtual DOM,

00:09:00.660 --> 00:09:05.620
you have to use those string
keys to access those props.

00:09:05.620 --> 00:09:08.775
So what we ended up doing,
just as a de facto standard

00:09:08.775 --> 00:09:12.640
inside Workiva, is we would
proxy these Key-value pairs

00:09:12.640 --> 00:09:15.030
with these getters that we
had defined in the component.

00:09:15.030 --> 00:09:17.670
So we'd be able to get a
little bit of static analysis

00:09:17.670 --> 00:09:19.649
and strong typing
inside the component.

00:09:19.649 --> 00:09:21.190
But we still didn't
have that when we

00:09:21.190 --> 00:09:22.780
were consuming the component.

00:09:22.780 --> 00:09:30.690
And we also still ran the risk
of mismatching it with a key

00:09:30.690 --> 00:09:34.070
that the consumer is
actually using to render it.

00:09:34.070 --> 00:09:36.240
We also started doing
that with state.

00:09:36.240 --> 00:09:38.092
And we ended up with
all these getters

00:09:38.092 --> 00:09:39.550
at the top of our
component, and it

00:09:39.550 --> 00:09:42.630
was really hard to tell what
data was coming from state

00:09:42.630 --> 00:09:45.120
and what data was
coming from props.

00:09:45.120 --> 00:09:47.840
That made it really hard
to reason about the data

00:09:47.840 --> 00:09:49.690
flow within the component.

00:09:49.690 --> 00:09:51.920
It just made
unreadable components.

00:09:51.920 --> 00:09:53.670
And then similarly
with state, we

00:09:53.670 --> 00:10:00.420
had to use those string
keys, and that wasn't ideal.

00:10:00.420 --> 00:10:04.780
So we thought, this
could be "Dartier".

00:10:04.780 --> 00:10:08.320
So what we came up with is
a library called OverReact.

00:10:11.770 --> 00:10:15.800
OverReact is a layer that sits
atop of React-Dart and React,

00:10:15.800 --> 00:10:18.880
and better adapts that
API for use in Dart.

00:10:18.880 --> 00:10:23.020
It just makes it easier
to use React and Dart.

00:10:23.020 --> 00:10:25.010
One of the big things
that it provides

00:10:25.010 --> 00:10:29.040
is statically declared
React UI components.

00:10:29.040 --> 00:10:31.880
You can declare your props
and state in a static way

00:10:31.880 --> 00:10:35.750
and get analysis
support for those.

00:10:35.750 --> 00:10:37.740
It was built with
re-usability in mind.

00:10:37.740 --> 00:10:39.202
Again, I'm on the
UI platform team,

00:10:39.202 --> 00:10:40.660
and a lot of what
we were doing was

00:10:40.660 --> 00:10:43.430
building reusable components.

00:10:43.430 --> 00:10:45.040
So we kind of baked
in some features

00:10:45.040 --> 00:10:46.780
to make that easier
on ourselves.

00:10:46.780 --> 00:10:48.370
And we think that
will help others

00:10:48.370 --> 00:10:51.220
make reusable components too.

00:10:51.220 --> 00:10:54.470
It's also production-ready.

00:10:54.470 --> 00:10:57.850
It's being used in a number of
Workiva apps and production,

00:10:57.850 --> 00:10:59.910
and has been for a
while, so we're pretty

00:10:59.910 --> 00:11:02.250
confident in it's stability.

00:11:02.250 --> 00:11:04.910
It's also open-source, and
we just released it, I think,

00:11:04.910 --> 00:11:06.020
a couple days ago.

00:11:06.020 --> 00:11:08.190
So we're really excited
to get out there.

00:11:08.190 --> 00:11:11.400
And here's the link
to this great site

00:11:11.400 --> 00:11:13.972
our team-lead put together.

00:11:13.972 --> 00:11:16.430
And I will re-link to that at
the end of the slideshow too.

00:11:16.430 --> 00:11:19.100
But definitely check
out those docs.

00:11:19.100 --> 00:11:21.320
Before I get into
the details, I really

00:11:21.320 --> 00:11:25.390
want to communicate some
of the design decisions

00:11:25.390 --> 00:11:28.310
that guided us while we
were building this library.

00:11:28.310 --> 00:11:31.770
First, we wanted to utilize Dart
analyzer to its full potential.

00:11:31.770 --> 00:11:33.530
As you saw, those
issues that you

00:11:33.530 --> 00:11:35.960
can run into when you're
using string keys can be super

00:11:35.960 --> 00:11:38.080
frustrating when developing.

00:11:38.080 --> 00:11:40.966
And we weren't getting the
most out of the great Dart

00:11:40.966 --> 00:11:42.590
tooling that was
available to us, so we

00:11:42.590 --> 00:11:44.800
want to make sure we did that.

00:11:44.800 --> 00:11:47.920
Second, we wanted to preserve
React principles and patterns.

00:11:47.920 --> 00:11:50.800
We didn't want to create
a whole new framework.

00:11:50.800 --> 00:11:52.670
We didn't want to
diverge from React.

00:11:52.670 --> 00:11:56.090
We just wanted to take React and
make it easier to use in Dart,

00:11:56.090 --> 00:11:57.950
so that way we
can take advantage

00:11:57.950 --> 00:12:00.900
of all of React's
community, all of it

00:12:00.900 --> 00:12:04.780
existing documentations and
blog posts and libraries,

00:12:04.780 --> 00:12:08.834
and all of it's upcoming
developments and new features.

00:12:11.980 --> 00:12:14.500
Finally, we wanted to keep
the workflow fast and simple.

00:12:14.500 --> 00:12:16.060
We don't want a
lot of Boilerplate.

00:12:16.060 --> 00:12:19.160
We wanted to keep declaring
components simple and easy.

00:12:22.810 --> 00:12:25.130
So we've seen the
syntax of JSX, and we've

00:12:25.130 --> 00:12:27.140
seen the syntax of React-Dart.

00:12:27.140 --> 00:12:30.730
Now here is the
syntax of OverReact.

00:12:30.730 --> 00:12:33.900
You can see it has the same
basic structure, where you're

00:12:33.900 --> 00:12:35.820
nesting components
within each other,

00:12:35.820 --> 00:12:37.930
and you're specifying
these Key-value pairs,

00:12:37.930 --> 00:12:40.310
but it looks quite
a bit different.

00:12:40.310 --> 00:12:45.040
So let's focus in on this
one specific example,

00:12:45.040 --> 00:12:50.510
break it down, and see what's
actually going on here.

00:12:50.510 --> 00:12:53.000
First, what happens when I'm
consuming this custom button

00:12:53.000 --> 00:12:55.840
component, is I invoke
the button function

00:12:55.840 --> 00:12:57.750
to create a new builder.

00:12:57.750 --> 00:13:00.820
And then on this builder, I
can use these typed setters

00:13:00.820 --> 00:13:02.920
to add prop Key-value pairs.

00:13:02.920 --> 00:13:07.620
In this case, I'm setting the id
prop to the demo_button value.

00:13:07.620 --> 00:13:10.660
I can cascade these using
Dart's "dot dot" syntax

00:13:10.660 --> 00:13:13.890
to add as many props
as I want all in line.

00:13:13.890 --> 00:13:16.685
Then finally, I wrap up that
expression of the builder,

00:13:16.685 --> 00:13:18.560
and then I invoke it
with the children I want

00:13:18.560 --> 00:13:20.480
to nest inside that component.

00:13:20.480 --> 00:13:25.030
Then that returns a virtual
DOM instance of my button.

00:13:25.030 --> 00:13:27.460
And that's it.

00:13:27.460 --> 00:13:29.600
The first thing
about this syntax

00:13:29.600 --> 00:13:33.190
is that it's such a joy
to work with in an IDE,

00:13:33.190 --> 00:13:37.610
compared to the old
string key method.

00:13:37.610 --> 00:13:40.897
First, if you try and use a
prop that's not available,

00:13:40.897 --> 00:13:42.980
you're going to get a
static analysis error saying

00:13:42.980 --> 00:13:45.630
that that prop isn't declared.

00:13:45.630 --> 00:13:47.330
If you go to fix it,
you will actually

00:13:47.330 --> 00:13:49.080
get an auto-complete
list of all the props

00:13:49.080 --> 00:13:52.490
that are available along
with the doc comments.

00:13:52.490 --> 00:13:55.670
That makes your APIs a
lot more discoverable.

00:13:55.670 --> 00:14:00.220
A lot of developers don't
tend to learn better

00:14:00.220 --> 00:14:02.150
by just exploring
the API's instead

00:14:02.150 --> 00:14:06.690
of reading a bunch of docs,
so this makes it a lot easier.

00:14:06.690 --> 00:14:10.920
You can also optionally type
these props-- these setters.

00:14:10.920 --> 00:14:13.500
In this case, we get an error
saying that this function has

00:14:13.500 --> 00:14:14.610
one too many arguments.

00:14:14.610 --> 00:14:16.520
So we can just go
and add that, and not

00:14:16.520 --> 00:14:18.590
have to wait until we click our
button to figure out that there

00:14:18.590 --> 00:14:19.600
is a problem with it.

00:14:22.400 --> 00:14:25.330
This Fluent interface we sought
for custom components is also

00:14:25.330 --> 00:14:27.500
available for all of
the DOM components,

00:14:27.500 --> 00:14:30.014
corresponding to all
of the DOM elements.

00:14:30.014 --> 00:14:31.430
In this case, we
have a text area,

00:14:31.430 --> 00:14:35.940
and we're setting some
DOM attribute props on it.

00:14:35.940 --> 00:14:37.390
So we have all
the DOM components

00:14:37.390 --> 00:14:41.310
that are available and
React-Dart, and in React.

00:14:41.310 --> 00:14:43.770
And then we also have
all of the DOM props

00:14:43.770 --> 00:14:46.220
that you can set
on a DOM component.

00:14:46.220 --> 00:14:48.080
I can't remember all
of these, especially

00:14:48.080 --> 00:14:50.770
the weird camelcasing
that some of them have,

00:14:50.770 --> 00:14:54.200
like tabIndex is camelcased
when it's not an HTML attribute.

00:14:54.200 --> 00:14:55.490
I can't remember that.

00:14:55.490 --> 00:14:57.860
So having the auto-complete
is really valuable

00:14:57.860 --> 00:15:00.140
to make sure you're not
mistyping something.

00:15:03.080 --> 00:15:05.550
Like I showed before, this
works with custom components,

00:15:05.550 --> 00:15:07.000
but something I
wanted to call out

00:15:07.000 --> 00:15:10.720
is what we call
Ubiquitous DOM Props.

00:15:10.720 --> 00:15:15.250
What we found when my team was
building all of these custom

00:15:15.250 --> 00:15:17.410
components is there
were a set of DOM props

00:15:17.410 --> 00:15:22.820
that consumers wanted to add
to our components all the time.

00:15:22.820 --> 00:15:25.660
They wanted to set a custom
ID or bind some custom event

00:15:25.660 --> 00:15:27.170
Handler.

00:15:27.170 --> 00:15:33.480
What we ended up doing is, baked
into the base builder class,

00:15:33.480 --> 00:15:37.750
we have props like id, tabIndex,
title, style, className,

00:15:37.750 --> 00:15:40.910
as well as all of the
event handlers declared

00:15:40.910 --> 00:15:44.140
on that builder so that, when
you're declaring a custom

00:15:44.140 --> 00:15:45.770
component, all you
have to do is pass

00:15:45.770 --> 00:15:49.150
through all of the
unconsumed props

00:15:49.150 --> 00:15:52.070
to your rendered DOM component.

00:15:52.070 --> 00:15:55.200
Then you'll just get all those
props passing through for free,

00:15:55.200 --> 00:15:57.960
you don't really have
to re-declare them.

00:15:57.960 --> 00:16:02.632
So that makes your components
a bit more reusable.

00:16:02.632 --> 00:16:04.340
We've seen these typed
setters in action,

00:16:04.340 --> 00:16:06.440
but how do they actually work?

00:16:06.440 --> 00:16:10.450
The idea behind this is to
take a MapView class, which

00:16:10.450 --> 00:16:13.180
is a Dart class that
wraps around a map

00:16:13.180 --> 00:16:15.160
and implements a map interface.

00:16:15.160 --> 00:16:17.500
You Can use it wherever
a map can be used,

00:16:17.500 --> 00:16:20.220
but you can also tack on
additional functionality.

00:16:20.220 --> 00:16:23.190
In this case, we've added
typed getters and setters

00:16:23.190 --> 00:16:26.950
that proxy these Key-value
pairs and props and state.

00:16:26.950 --> 00:16:30.410
So when they set the setter,
it adds that Key-value pair.

00:16:30.410 --> 00:16:34.509
And when we access the
getter, it reads it.

00:16:34.509 --> 00:16:36.050
We initially were
doing this by hand,

00:16:36.050 --> 00:16:37.770
and it proved to
be kind of tedious.

00:16:37.770 --> 00:16:40.930
We could still mistype
things, and it was a pain.

00:16:40.930 --> 00:16:44.820
So of course we went to Code
Generation to do that for us,

00:16:44.820 --> 00:16:46.530
right now via Pub
transformer, but I

00:16:46.530 --> 00:16:51.510
could see it being a Bazel
build step eventually.

00:16:51.510 --> 00:16:55.110
But to declare a
statically declared

00:16:55.110 --> 00:16:59.360
prop, you just declare a
field, and then the transformer

00:16:59.360 --> 00:17:01.800
or synthesizes that to
getters and setters.

00:17:01.800 --> 00:17:09.970
And because in all of the
use cases of the props,

00:17:09.970 --> 00:17:12.660
fields behave the same
way as getters and setters

00:17:12.660 --> 00:17:14.550
do to the Dart analyzers,
so we're actually

00:17:14.550 --> 00:17:17.800
able to analyze the
pre-transformed code,

00:17:17.800 --> 00:17:19.869
and get analysis
on this, and not

00:17:19.869 --> 00:17:23.109
have to run the generation
step, and analyze

00:17:23.109 --> 00:17:25.766
that to verify that our
application is correct.

00:17:28.910 --> 00:17:31.144
What does it look like to
declare a custom component,

00:17:31.144 --> 00:17:32.560
now that we've
seen all the parts?

00:17:32.560 --> 00:17:35.430
How does this all come together?

00:17:35.430 --> 00:17:38.170
So first, we have a factory.

00:17:38.170 --> 00:17:41.190
And this is a
function variable that

00:17:41.190 --> 00:17:43.640
constructs UI props
instances, and gives us

00:17:43.640 --> 00:17:45.050
instances of those builders.

00:17:45.050 --> 00:17:46.920
And this is the entrypoint
to the component.

00:17:46.920 --> 00:17:49.210
This is what your
consumers are going to use

00:17:49.210 --> 00:17:51.570
when they're rendering them.

00:17:51.570 --> 00:17:54.710
And we have our UI props
class, which is the builder,

00:17:54.710 --> 00:17:56.770
and it's also a map.

00:17:56.770 --> 00:18:00.140
It has the typed getters
and setters for convenience,

00:18:00.140 --> 00:18:03.810
but it also can be used
wherever a map can be used.

00:18:03.810 --> 00:18:06.870
What's nice about this is
it makes these props classes

00:18:06.870 --> 00:18:09.690
backwards-compatible with
all the React-Dart APIs that

00:18:09.690 --> 00:18:13.100
take Map, because it is a Map.

00:18:13.100 --> 00:18:15.460
And then finally, we
have the component

00:18:15.460 --> 00:18:18.580
which contains all of the
rendering and lifecycle logic.

00:18:18.580 --> 00:18:21.210
And it also has typed
access to props and state.

00:18:21.210 --> 00:18:24.280
So just like you use those
setters to set the props when

00:18:24.280 --> 00:18:25.920
you're consuming
the component, you

00:18:25.920 --> 00:18:29.450
use the getters to read
them within the component.

00:18:29.450 --> 00:18:31.820
You'll see that we have
these annotations on all

00:18:31.820 --> 00:18:34.270
of these classes, and that's
what the transformer uses

00:18:34.270 --> 00:18:38.900
as hooks to define the
component declaration,

00:18:38.900 --> 00:18:40.750
and to do that code generation.

00:18:43.740 --> 00:18:46.140
You can see that
the UI props class

00:18:46.140 --> 00:18:49.560
is used as generic parameters
in UIfactory and UIcomponent.

00:18:49.560 --> 00:18:52.620
And that's what allows the
component-specific typing

00:18:52.620 --> 00:18:53.823
to be analyzed properly.

00:18:56.680 --> 00:19:01.030
So from that, the transformer
first takes the UIprops class

00:19:01.030 --> 00:19:04.240
and synthesizes all those
getters and setters.

00:19:04.240 --> 00:19:08.436
Then after that, it does some
wiring up of the UIProps class

00:19:08.436 --> 00:19:09.810
to the factory
and the component.

00:19:09.810 --> 00:19:12.800
There's a bunch of stuff that
needs to happen under the hood.

00:19:12.800 --> 00:19:17.080
You have to register a component
with the React-Dart factory.

00:19:17.080 --> 00:19:21.754
There's also some weird
stuff around constructors

00:19:21.754 --> 00:19:23.420
that we didn't want
to put on consumers.

00:19:23.420 --> 00:19:26.050
So basically, to
minimize Boilerplate,

00:19:26.050 --> 00:19:32.200
we just kept the
UIProps, UIFactory,

00:19:32.200 --> 00:19:35.470
and UIComponent declaration as
is and had the transformer do

00:19:35.470 --> 00:19:38.060
all of the heavy lifting.

00:19:38.060 --> 00:19:40.850
There's a big section
in our read-me

00:19:40.850 --> 00:19:44.060
that goes into more detail
about how this actually works.

00:19:44.060 --> 00:19:46.280
And I wish I could get into
it in this presentation,

00:19:46.280 --> 00:19:47.070
but I don't have time.

00:19:47.070 --> 00:19:49.111
So if you're interested,
definitely check it out.

00:19:49.111 --> 00:19:51.480
I think it's really cool I'm
biased, though, because I'm

00:19:51.480 --> 00:19:52.354
the one who wrote it.

00:19:52.354 --> 00:19:57.270
So anyway, for now, just know
that you add the OverReact

00:19:57.270 --> 00:19:58.917
transformer to your
pubspec, and then

00:19:58.917 --> 00:20:00.500
all of the components
that you declare

00:20:00.500 --> 00:20:04.480
will get transformed under
the hood and on the fly, too.

00:20:04.480 --> 00:20:07.150
That's the great thing
about pub transformers.

00:20:07.150 --> 00:20:09.370
So now that we've seen
how to build components,

00:20:09.370 --> 00:20:10.570
let's actually do it.

00:20:10.570 --> 00:20:12.390
Let's build a component.

00:20:12.390 --> 00:20:15.087
What I want to build
is a counter component,

00:20:15.087 --> 00:20:16.670
because I think
computers can probably

00:20:16.670 --> 00:20:19.440
count better than I can.

00:20:19.440 --> 00:20:21.610
This counter component
is going to be a button

00:20:21.610 --> 00:20:24.170
that, when I click on it, it's
going to increment the count.

00:20:24.170 --> 00:20:26.600
You get the gist of it.

00:20:26.600 --> 00:20:29.480
First, I'm going to
add some rendering

00:20:29.480 --> 00:20:31.820
logic to my component.

00:20:31.820 --> 00:20:35.710
I'm going to add a container,
and then render a button,

00:20:35.710 --> 00:20:37.910
and just wire up ana
onClick Handler that I'll

00:20:37.910 --> 00:20:40.520
stub out for now.

00:20:40.520 --> 00:20:42.460
And you can see it
does what we expect,

00:20:42.460 --> 00:20:44.860
it's a button that
doesn't do anything.

00:20:44.860 --> 00:20:47.360
Now let's add some props to
make this component a little bit

00:20:47.360 --> 00:20:49.270
more configurable.

00:20:49.270 --> 00:20:53.760
I'm going to add props
to allow the consumer

00:20:53.760 --> 00:20:55.980
to specify the initial
count, the initial state

00:20:55.980 --> 00:20:58.600
that the component
will start counting at,

00:20:58.600 --> 00:21:00.310
and also the amount
that it will count

00:21:00.310 --> 00:21:02.140
by when you click the button.

00:21:02.140 --> 00:21:05.420
So I've just declare these
as fields in the props class,

00:21:05.420 --> 00:21:09.230
and I've typed them as INTs

00:21:09.230 --> 00:21:12.290
And then, in the component,
I can take the props,

00:21:12.290 --> 00:21:14.170
and I can read
them and do props.

00:21:14.170 --> 00:21:16.800
incrementAmount and
string interpolate

00:21:16.800 --> 00:21:18.710
that in my button text.

00:21:18.710 --> 00:21:21.200
And because, again,
we've used counter props

00:21:21.200 --> 00:21:24.660
as a generic parameter, we
get typed access to props.

00:21:24.660 --> 00:21:27.890
So anything that's declared
in props, we can just do dot

00:21:27.890 --> 00:21:32.420
and it'll auto-complete
and analyze properly.

00:21:32.420 --> 00:21:37.920
If we pass in a initial count of
1, then it renders as expected.

00:21:37.920 --> 00:21:40.350
Now, since we want the
component to update itself,

00:21:40.350 --> 00:21:42.420
we need to declare some state.

00:21:42.420 --> 00:21:45.190
In this case, I've
made a new state class

00:21:45.190 --> 00:21:48.930
and swapped out the base
class from UIComponent

00:21:48.930 --> 00:21:50.470
to UIStateful component.

00:21:50.470 --> 00:21:52.730
This allows us to add this
generic parameter so we

00:21:52.730 --> 00:21:54.350
get typed access to this state.

00:22:01.160 --> 00:22:04.200
In the state, we're going to
declare a currentCount field,

00:22:04.200 --> 00:22:05.750
and that will be
a state Key-value

00:22:05.750 --> 00:22:08.760
pair that keeps track of the
current count of the button.

00:22:08.760 --> 00:22:10.520
So now we can consume that.

00:22:10.520 --> 00:22:12.790
You'll see in the
container, or string

00:22:12.790 --> 00:22:14.490
interpolating
state.currentCount--

00:22:14.490 --> 00:22:17.350
just like we did with props--
so we can display these

00:22:17.350 --> 00:22:18.870
or what the current count is.

00:22:18.870 --> 00:22:23.450
Then also we are setting up the
initial state of the component.

00:22:23.450 --> 00:22:25.440
We're initializing
the currentCount state

00:22:25.440 --> 00:22:28.680
to the initial count
specified in props.

00:22:28.680 --> 00:22:31.950
You'll see that I'm using
this new state method,

00:22:31.950 --> 00:22:33.700
and this is a convenience
method that'll

00:22:33.700 --> 00:22:36.530
just give you a new instance
of the counter state.

00:22:36.530 --> 00:22:39.300
So that gives you
basically an empty map

00:22:39.300 --> 00:22:41.600
that you can cascade
Key-value pairs on.

00:22:41.600 --> 00:22:44.670
And then you can return that
to getInitialState() and React

00:22:44.670 --> 00:22:47.550
will wire up that
initial state properly.

00:22:47.550 --> 00:22:50.710
And finally, let's do the fun
stuff and mutate the state.

00:22:50.710 --> 00:22:52.970
In React, the way
that you mutate state

00:22:52.970 --> 00:22:56.220
is that you pass in
a map into setState,

00:22:56.220 --> 00:22:58.610
and it merges that map
on the existing state,

00:22:58.610 --> 00:23:00.540
overwriting any values.

00:23:00.540 --> 00:23:03.160
So in this case, we're going
to call setState, create

00:23:03.160 --> 00:23:05.250
a new map, and set
the count on it

00:23:05.250 --> 00:23:07.920
to the current count
plus the increment.

00:23:07.920 --> 00:23:10.280
That new count
Key-Value pair is going

00:23:10.280 --> 00:23:12.010
to overwrite the existing one.

00:23:12.010 --> 00:23:14.771
And then the component is going
to re-render with the updated

00:23:14.771 --> 00:23:15.270
state.

00:23:18.080 --> 00:23:19.740
And after that, we're all done.

00:23:19.740 --> 00:23:22.090
Let's see if it works.

00:23:22.090 --> 00:23:23.470
And it works.

00:23:23.470 --> 00:23:25.126
Awesome.

00:23:25.126 --> 00:23:29.050
[APPLAUSE]

00:23:29.050 --> 00:23:31.530
And so you'll see that we've
set initialCount to Zero

00:23:31.530 --> 00:23:33.160
and the increment to one.

00:23:33.160 --> 00:23:37.180
We can also configure those,
and it will work as expected.

00:23:37.180 --> 00:23:40.090
For the sake of this
demo, I didn't include it,

00:23:40.090 --> 00:23:43.170
but you can add default
values for these props

00:23:43.170 --> 00:23:45.170
so that you don't have
to specify them any time.

00:23:45.170 --> 00:23:46.660
They'll fallback
to default values.

00:23:46.660 --> 00:23:52.210
But for the sake of simplicity,
I just left that out

00:23:52.210 --> 00:23:55.340
Some other cool things relating
to OverReact-- OverReact

00:23:55.340 --> 00:23:57.050
has a bunch of
other cool features.

00:23:57.050 --> 00:23:58.970
Besides component
declaration, we've

00:23:58.970 --> 00:24:03.170
got CSS class named building,
with a very Dart-like API,

00:24:03.170 --> 00:24:08.680
similar to the classNames
utility bundled with React(JS),

00:24:08.680 --> 00:24:11.370
but it's got one more
feature that it doesn't have.

00:24:11.370 --> 00:24:12.870
We got typed checking.

00:24:12.870 --> 00:24:15.480
That's something that wasn't
possible in React-Dart,

00:24:15.480 --> 00:24:17.190
but is possible in
JavaScript-- being

00:24:17.190 --> 00:24:19.550
able to tell whether
a VDOM instance is

00:24:19.550 --> 00:24:23.020
a type of a certain component
that's useful for conditionally

00:24:23.020 --> 00:24:26.780
rendering passed-in children,
and also generic callback

00:24:26.780 --> 00:24:27.530
chaining.

00:24:27.530 --> 00:24:30.830
Something I also wanted
to call out is testing.

00:24:30.830 --> 00:24:33.670
With React-Dart, there
is a wrapper currently

00:24:33.670 --> 00:24:37.100
for ReactTestUtils, which is
a test utility suite bundled

00:24:37.100 --> 00:24:42.220
with a React that allows you
to simulate events, and query

00:24:42.220 --> 00:24:44.830
for different components,
and get data about them.

00:24:44.830 --> 00:24:47.370
So that all works with
React-Dart, and with OverReact.

00:24:47.370 --> 00:24:50.710
But we do have a set
OverReact test utilities

00:24:50.710 --> 00:24:53.570
that we've made to make that
process a little bit easier,

00:24:53.570 --> 00:24:57.774
and add some stuff that
ReactTestUtils doesn't have.

00:24:57.774 --> 00:24:59.940
I know that that's coming
soon, but in the meantime,

00:24:59.940 --> 00:25:03.600
you can still test with this
using just React-Dart test

00:25:03.600 --> 00:25:05.806
utils.

00:25:05.806 --> 00:25:07.430
I couldn't come all
this way to Germany

00:25:07.430 --> 00:25:09.520
without mentioning some
other Workiva packages.,

00:25:09.520 --> 00:25:11.311
but these really are
relevant to OverReact.

00:25:11.311 --> 00:25:14.470
One of them is w_flux,
which implements

00:25:14.470 --> 00:25:16.760
the uni-directional
data flow model that was

00:25:16.760 --> 00:25:19.200
inspired by Flux and RefluxJS.

00:25:19.200 --> 00:25:22.430
We use this a lot internally
to manage the data flow

00:25:22.430 --> 00:25:23.390
within our apps.

00:25:23.390 --> 00:25:25.490
And it integrates
great with OverReact.

00:25:25.490 --> 00:25:28.320
There's actually a flux
UIComponent in OverReact

00:25:28.320 --> 00:25:32.870
that automatically
declares actions and store.

00:25:32.870 --> 00:25:35.540
And when the store triggers,
it will automatically

00:25:35.540 --> 00:25:38.460
re-render your component, so
that's very well integrated.

00:25:38.460 --> 00:25:43.060
We also used dart_dev to
run our tests and coverage,

00:25:43.060 --> 00:25:44.902
and that makes it easier.

00:25:44.902 --> 00:25:46.840
We use that in OverReact.

00:25:46.840 --> 00:25:50.840
There's a bunch more packages
at workiva.github.io.

00:25:50.840 --> 00:25:52.566
We love to open-source
stuff when we can,

00:25:52.566 --> 00:25:53.690
give back to the community.

00:25:53.690 --> 00:25:57.780
So expect to see
more at that site.

00:25:57.780 --> 00:26:04.647
So again, here's the link to the
beautiful docs site, our repo.

00:26:04.647 --> 00:26:06.480
If you have any questions
about any of this,

00:26:06.480 --> 00:26:08.530
feel free to come grab
me after this talk,

00:26:08.530 --> 00:26:10.180
or open up a GitHub issue.

00:26:10.180 --> 00:26:11.490
We're very responsive.

00:26:11.490 --> 00:26:13.250
If there's something
that you don't like,

00:26:13.250 --> 00:26:17.070
or if you have an idea, idea
for an improvement, a bug,

00:26:17.070 --> 00:26:18.260
just file a GitHub issue.

00:26:18.260 --> 00:26:20.621
We'll be really
responsive on that.

00:26:20.621 --> 00:26:22.120
And if you want a
direct line, there

00:26:22.120 --> 00:26:24.120
is my email, or my team's email.

00:26:24.120 --> 00:26:28.580
And give React and Dart a shot.

00:26:28.580 --> 00:26:30.410
Thank you.

