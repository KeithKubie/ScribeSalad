WEBVTT
Kind: captions
Language: en

00:00:00.890 --> 00:00:02.130
SETH LADD: OK, welcome
everyone.

00:00:02.130 --> 00:00:03.820
Thanks very much for coming.

00:00:03.820 --> 00:00:07.180
This is What's New with Dart:
Your First-Class Upgrade to

00:00:07.180 --> 00:00:08.050
Web Development.

00:00:08.050 --> 00:00:08.870
My name is Seth Ladd.

00:00:08.870 --> 00:00:11.000
I'm a Developer Advocate
with the Dart team.

00:00:11.000 --> 00:00:11.900
JUSTIN FAGNANI: And I'm
Justin Fagnani.

00:00:11.900 --> 00:00:13.740
I'm an engineer on the
Dart team working

00:00:13.740 --> 00:00:15.000
on tools and libraries.

00:00:15.000 --> 00:00:18.680
And I also help internal
teams move to Dart.

00:00:18.680 --> 00:00:20.270
SETH LADD: All right, real
quick, what is Dart?

00:00:20.270 --> 00:00:21.930
Well, Dart is much more
than a language.

00:00:21.930 --> 00:00:24.810
It's also a set of rich
libraries, very productive

00:00:24.810 --> 00:00:27.160
tools, fast run-times like
a virtual machine.

00:00:27.160 --> 00:00:30.690
But probably most importantly,
Dart compiles the JavaScript.

00:00:30.690 --> 00:00:32.850
So you could write a Dart app,
compile it down to modern

00:00:32.850 --> 00:00:34.900
JavaScript, and run
it across modern

00:00:34.900 --> 00:00:35.960
browsers like this today.

00:00:35.960 --> 00:00:37.760
We like to think of Dart
as a batteries

00:00:37.760 --> 00:00:40.920
included package for you.

00:00:40.920 --> 00:00:43.520
OK, so this is a real-life story
from a developer just

00:00:43.520 --> 00:00:44.200
like you guys out there.

00:00:44.200 --> 00:00:44.900
He works for a bank.

00:00:44.900 --> 00:00:46.870
He has to write a
lot of web apps.

00:00:46.870 --> 00:00:47.860
So he's telling me.

00:00:47.860 --> 00:00:48.650
This is true.

00:00:48.650 --> 00:00:50.630
He's saying, OK, the other day I
was asked to build a new web

00:00:50.630 --> 00:00:52.490
app for my internal customers.

00:00:52.490 --> 00:00:55.000
So hi, I want to build
a web app.

00:00:55.000 --> 00:00:58.560
First off, you need to go get
require.js because you need

00:00:58.560 --> 00:00:59.770
some sense of modularity.

00:00:59.770 --> 00:01:02.770
He needed to get Backbone
because he needs some sense of

00:01:02.770 --> 00:01:04.569
client-side infrastructure.

00:01:04.569 --> 00:01:06.250
He needed to get Backbone
Marionette because, of course,

00:01:06.250 --> 00:01:08.170
he needs some extra
functionality.

00:01:08.170 --> 00:01:10.100
He needed to get jQuery
because every web

00:01:10.100 --> 00:01:11.310
project uses jQuery.

00:01:11.310 --> 00:01:14.000
Whether you like it or not,
somebody uses it.

00:01:14.000 --> 00:01:16.130
He needed to get Modernizr
because he needed to do

00:01:16.130 --> 00:01:17.210
feature detection.

00:01:17.210 --> 00:01:20.760
He needed to get moment.js
because he needed to deal with

00:01:20.760 --> 00:01:22.620
dates, parsing dates,
formatting dates.

00:01:22.620 --> 00:01:24.620
He needed to then get dest
templates because he needed

00:01:24.620 --> 00:01:28.040
some solution for client-side
templates.

00:01:28.040 --> 00:01:30.160
He needed to get PhantomJS
because he needed some sense

00:01:30.160 --> 00:01:32.330
of browser-based testing.

00:01:32.330 --> 00:01:34.000
Then he needed to get Jasmine
because he needed to actually

00:01:34.000 --> 00:01:35.530
write those tests.

00:01:35.530 --> 00:01:38.090
Then when he's got this
teetering pile here, of course

00:01:38.090 --> 00:01:39.960
then he finds out that every
one of these projects has a

00:01:39.960 --> 00:01:41.800
completely different set
of formatted docs.

00:01:41.800 --> 00:01:43.810
So you got to find those
and read those and

00:01:43.810 --> 00:01:45.190
figure those out.

00:01:45.190 --> 00:01:48.180
And then, he needed to finally
integrate this entire pile

00:01:48.180 --> 00:01:50.750
here to make some semblance
of a working system.

00:01:50.750 --> 00:01:53.350
An interesting thing here
though, is that not only do

00:01:53.350 --> 00:01:54.600
you actually have to wire
it all together.

00:01:54.600 --> 00:01:57.710
But some of these solutions
offer duplicate answers to the

00:01:57.710 --> 00:01:58.310
same problem.

00:01:58.310 --> 00:01:59.690
So you've got to
reconcile that.

00:01:59.690 --> 00:02:03.770
So after he built this kind of
teetering pile here, quote, "I

00:02:03.770 --> 00:02:06.750
just want to build web apps."

00:02:06.750 --> 00:02:09.449
So then he found the Dart
project-- true story.

00:02:09.449 --> 00:02:12.260
He was able to replace the
teetering pile with simply

00:02:12.260 --> 00:02:16.100
just the Dart SDK and three
packages that he could just

00:02:16.100 --> 00:02:17.440
download with our
package manager.

00:02:17.440 --> 00:02:20.500
And quote, "Thanks to Dart,
things are consistent and

00:02:20.500 --> 00:02:21.290
clear."

00:02:21.290 --> 00:02:23.540
So this is a good example of a
real-life story of a small

00:02:23.540 --> 00:02:25.890
team, a team that needs to
move fast, and their

00:02:25.890 --> 00:02:26.910
experience using Dart.

00:02:26.910 --> 00:02:29.260
But that's an external
small team.

00:02:29.260 --> 00:02:31.610
Justin, how's our internal
teams doing?

00:02:31.610 --> 00:02:33.600
JUSTIN FAGNANI: So like I
mentioned, I help internal

00:02:33.600 --> 00:02:35.280
teams adopt Dart.

00:02:35.280 --> 00:02:38.970
And at Google, we build
a few web apps.

00:02:38.970 --> 00:02:40.880
And some of them
are quite big.

00:02:40.880 --> 00:02:43.700
To give you an idea of how big
they are, our teams can be

00:02:43.700 --> 00:02:45.630
from dozens to hundreds
of engineers.

00:02:45.630 --> 00:02:48.420
And we can easily have millions
of lines of code.

00:02:48.420 --> 00:02:50.910
And over the years, our
engineers have determined that

00:02:50.910 --> 00:02:53.100
they need tools to help them
manage this complexity.

00:02:53.100 --> 00:02:55.630
And basically, maintain their
sanity to be able to work with

00:02:55.630 --> 00:02:58.070
such large amounts of
code in large teams.

00:02:58.070 --> 00:03:01.120
So they've built tools like
GWT and Closure and Soy.

00:03:01.120 --> 00:03:05.500
And these tools do different
things to help them guarantee

00:03:05.500 --> 00:03:07.540
correctness and behavior
of the applications.

00:03:07.540 --> 00:03:10.820
They introduce modularity
and structure, classes.

00:03:10.820 --> 00:03:12.190
Maybe some type checking.

00:03:12.190 --> 00:03:15.580
GWT introduces Java as
the source language.

00:03:15.580 --> 00:03:17.510
And these tools have been very
successful in that they help

00:03:17.510 --> 00:03:20.070
teams write these complex
apps and actually get

00:03:20.070 --> 00:03:21.220
them out the door.

00:03:21.220 --> 00:03:23.370
But they have some downsides.

00:03:23.370 --> 00:03:26.770
In particular, all JavaScript
at Google is compiled.

00:03:26.770 --> 00:03:29.450
And this means that we've
introduced a compiler into the

00:03:29.450 --> 00:03:30.800
development workflow.

00:03:30.800 --> 00:03:33.750
And that can significantly
slow things down.

00:03:33.750 --> 00:03:36.620
With these large apps, the
compilers can take a long time

00:03:36.620 --> 00:03:40.190
to run while you're trying
to develop your app.

00:03:40.190 --> 00:03:43.300
So we've started moving
some teams to Dart.

00:03:43.300 --> 00:03:46.280
And with Dart, we tried
to fix that problem.

00:03:46.280 --> 00:03:48.730
SETH LADD: I want to point out
real quick that this is real

00:03:48.730 --> 00:03:49.820
feedback from internal teams.

00:03:49.820 --> 00:03:52.320
24 minutes, sometimes,
to see a change.

00:03:52.320 --> 00:03:55.230
Can you imagine iterating at
24-minutes per change?

00:03:55.230 --> 00:03:56.260
JUSTIN FAGNANI: I've
done that.

00:03:56.260 --> 00:03:57.125
SETH LADD: Surely
we can better.

00:03:57.125 --> 00:03:57.410
JUSTIN FAGNANI: Right.

00:03:57.410 --> 00:03:59.660
So surely we could do better.

00:03:59.660 --> 00:04:02.670
So what we've done with Dart
is we've tried to address

00:04:02.670 --> 00:04:03.190
these issues.

00:04:03.190 --> 00:04:06.260
To fix some of the problems
with the structure and the

00:04:06.260 --> 00:04:10.000
semantics of the language, but
also not have the downsides.

00:04:10.000 --> 00:04:12.740
So here we have a chart that
kind of shows some different

00:04:12.740 --> 00:04:14.140
projects out there
that are compiled

00:04:14.140 --> 00:04:15.570
to JavaScript projects.

00:04:15.570 --> 00:04:18.029
So we have GWT and
Closure here.

00:04:18.029 --> 00:04:19.529
I'm sure you guys have heard
of CoffeeScript.

00:04:19.529 --> 00:04:22.130
And also, Microsoft has their
own compile to JS project

00:04:22.130 --> 00:04:23.330
called TypeScript.

00:04:23.330 --> 00:04:25.670
And we've kind of roughly said
whether or not they hurt and

00:04:25.670 --> 00:04:28.000
help on these different
dimensions.

00:04:28.000 --> 00:04:30.640
And we feel like Dart is finally
a solution that we

00:04:30.640 --> 00:04:32.240
have that helps on
every dimension.

00:04:32.240 --> 00:04:34.880
It actually improves the
development cycle, while also

00:04:34.880 --> 00:04:38.340
giving teams the safety and
semantic improvements that

00:04:38.340 --> 00:04:38.670
they require.

00:04:38.670 --> 00:04:39.680
SETH LADD: One thing I want
to point out on this slide

00:04:39.680 --> 00:04:41.200
actually, I think it's really
important to understand this

00:04:41.200 --> 00:04:43.090
requires compilation
for development.

00:04:43.090 --> 00:04:46.870
Notice how Dart does not require
compilation for your

00:04:46.870 --> 00:04:48.510
very fast iteration development
cycles.

00:04:48.510 --> 00:04:52.420
We'll see how we make that
possible in a little bit.

00:04:52.420 --> 00:04:53.120
OK, cool.

00:04:53.120 --> 00:04:55.690
So before we jump into all the
what's new across the whole

00:04:55.690 --> 00:04:56.380
Dart platform--

00:04:56.380 --> 00:04:58.210
and there's a lot-- we want to
give you a quick lightning

00:04:58.210 --> 00:05:01.210
tour across the syntax,
semantics, and structure that

00:05:01.210 --> 00:05:03.470
Dart offers so we can show you
a bunch of code samples

00:05:03.470 --> 00:05:04.980
throughout the talk.

00:05:04.980 --> 00:05:06.230
Let's start with the syntax.

00:05:06.230 --> 00:05:08.150
First up, very familiar
classes,

00:05:08.150 --> 00:05:09.830
semicolons, curly braces.

00:05:09.830 --> 00:05:11.470
I think everyone can
read this code.

00:05:11.470 --> 00:05:12.240
Dart's very terse.

00:05:12.240 --> 00:05:14.150
We like to say it's
ceremony free.

00:05:14.150 --> 00:05:15.360
Here's a good example here.

00:05:15.360 --> 00:05:17.340
What do you always do in
constructors, but this.x

00:05:17.340 --> 00:05:19.580
equals x, this.y equals
y, et cetera.

00:05:19.580 --> 00:05:20.930
This is getting boring.

00:05:20.930 --> 00:05:23.990
So instead you can say if the
constructor parameter name is

00:05:23.990 --> 00:05:27.030
the same as the name of the
field, you can simply say

00:05:27.030 --> 00:05:28.960
this.strength here
in this case.

00:05:28.960 --> 00:05:31.120
Eliminates some of the ceremony
or boilerplate that

00:05:31.120 --> 00:05:33.800
you typically have in
other languages.

00:05:33.800 --> 00:05:35.980
Name constructors, one of my
favorite features here.

00:05:35.980 --> 00:05:37.310
Obviously, methods you
can name pretty much

00:05:37.310 --> 00:05:38.170
whatever you want.

00:05:38.170 --> 00:05:40.240
But constructors, typically,
are always named

00:05:40.240 --> 00:05:41.110
the name of the class.

00:05:41.110 --> 00:05:43.160
That's a little bit
constraining, so Dart offers

00:05:43.160 --> 00:05:43.930
name constructors.

00:05:43.930 --> 00:05:47.790
Here, I can say new hug.bear
and set up a bear hug.

00:05:47.790 --> 00:05:49.190
It's very clear.

00:05:49.190 --> 00:05:51.760
I totally understand what I'm
creating when I use these name

00:05:51.760 --> 00:05:53.730
constructors.

00:05:53.730 --> 00:05:55.110
Dart has operator overriding.

00:05:55.110 --> 00:05:58.050
Here's a good example of that.

00:05:58.050 --> 00:06:00.430
Named, optional parameters,
another one of my favorite

00:06:00.430 --> 00:06:00.990
features here.

00:06:00.990 --> 00:06:03.310
So the curly braces here turn
on a couple things.

00:06:03.310 --> 00:06:05.050
First, this becomes an
optional parameter.

00:06:05.050 --> 00:06:07.230
So you may or may not--
or you can or cannot

00:06:07.230 --> 00:06:08.950
pass a parameter there.

00:06:08.950 --> 00:06:11.610
It's name that I understand
what this number is.

00:06:11.610 --> 00:06:12.660
So hands.

00:06:12.660 --> 00:06:14.870
And I get a default
value of one.

00:06:14.870 --> 00:06:17.670
So again, features that normal
scripting languages have, Dart

00:06:17.670 --> 00:06:19.930
has as well.

00:06:19.930 --> 00:06:21.420
Some of my other favorite
features here-- fat arrow

00:06:21.420 --> 00:06:24.820
syntax for your simple one-line
functions here.

00:06:24.820 --> 00:06:27.580
This is just syntactic sugar
for curly brace return

00:06:27.580 --> 00:06:29.000
expression curly brace.

00:06:29.000 --> 00:06:32.150
Dart uses one-line functions
a lot, especially in inline

00:06:32.150 --> 00:06:33.420
anonymous functions.

00:06:33.420 --> 00:06:35.200
So they're really
useful there.

00:06:35.200 --> 00:06:37.090
And finally, string
interpolation.

00:06:37.090 --> 00:06:40.860
A very simple way to build up
strings based on variables or

00:06:40.860 --> 00:06:42.110
expressions.

00:06:43.850 --> 00:06:47.650
JUSTIN FAGNANI: OK, but Dart
isn't all just syntax

00:06:47.650 --> 00:06:48.550
improvements.

00:06:48.550 --> 00:06:51.000
Dart is its own language and
it has its own semantics.

00:06:51.000 --> 00:06:53.620
And I'm sure some of you have
heard of the JavaScript wats

00:06:53.620 --> 00:06:55.400
out there, or these surprising
moments.

00:06:55.400 --> 00:06:55.740
Wat.

00:06:55.740 --> 00:06:56.530
SETH LADD: Wat.

00:06:56.530 --> 00:06:57.530
JUSTIN FAGNANI: In JavaScript.

00:06:57.530 --> 00:06:58.960
Or the Java puzzlers.

00:06:58.960 --> 00:07:01.460
So these are confusing
parts of the language

00:07:01.460 --> 00:07:02.510
we're familiar with.

00:07:02.510 --> 00:07:05.490
And we try to improve on that,
too, and turn our wats into

00:07:05.490 --> 00:07:08.260
some kind of atomic rock
dinosaur thing.

00:07:08.260 --> 00:07:09.490
But awesomeness in general.

00:07:09.490 --> 00:07:10.510
SETH LADD: I want the
one on the right.

00:07:10.510 --> 00:07:11.110
JUSTIN FAGNANI: Yes, me too.

00:07:11.110 --> 00:07:13.214
It looks more fun.

00:07:13.214 --> 00:07:13.980
SETH LADD: That one's scary.

00:07:13.980 --> 00:07:14.230
JUSTIN FAGNANI: OK.

00:07:14.230 --> 00:07:16.300
Some examples of semantic
improvements.

00:07:16.300 --> 00:07:18.450
Just real quick, only
true is truthy.

00:07:18.450 --> 00:07:20.840
So you don't have to guess what
values are going to be

00:07:20.840 --> 00:07:21.630
true or false.

00:07:21.630 --> 00:07:23.860
Basically, true is true, false
is false, and everything else

00:07:23.860 --> 00:07:25.830
is what it is.

00:07:25.830 --> 00:07:26.890
We got rid of undefined.

00:07:26.890 --> 00:07:28.390
There's only null.

00:07:28.390 --> 00:07:29.750
That fixes a lot of problems.

00:07:29.750 --> 00:07:33.450
There's no type coercion with
equalities checks or operators

00:07:33.450 --> 00:07:34.270
or other things like that.

00:07:34.270 --> 00:07:37.720
So the language is more
predictable in a lot of ways.

00:07:37.720 --> 00:07:39.580
Some other examples.

00:07:39.580 --> 00:07:43.430
So in JavaScript, if you access
a property that isn't

00:07:43.430 --> 00:07:47.950
available on an object, you
will get undefined.

00:07:47.950 --> 00:07:48.950
So that can be a problem.

00:07:48.950 --> 00:07:50.960
If you have a typo, you don't
necessarily know it.

00:07:50.960 --> 00:07:52.610
You just get an undefined
value.

00:07:52.610 --> 00:07:54.120
So in Dart, we changed this.

00:07:54.120 --> 00:07:54.670
We fixed it.

00:07:54.670 --> 00:07:55.950
And what do you think
happens here, Seth?

00:07:55.950 --> 00:07:57.240
SETH LADD: Well, hopefully a
clear and consistent and

00:07:57.240 --> 00:07:58.370
logical error.

00:07:58.370 --> 00:08:00.830
JUSTIN FAGNANI: Well, that's
exactly right.

00:08:00.830 --> 00:08:04.070
If you access a missing property
on an object in Dart,

00:08:04.070 --> 00:08:06.830
you get a NoSuchMethodError
because Dart knows it doesn't

00:08:06.830 --> 00:08:09.310
exist because it wasn't
declared.

00:08:09.310 --> 00:08:10.370
Let's look at list access.

00:08:10.370 --> 00:08:13.800
So here we have an empty list
and we're accessing the 99th

00:08:13.800 --> 00:08:14.910
element of an empty list.

00:08:14.910 --> 00:08:17.150
So we're way out of range.

00:08:17.150 --> 00:08:18.250
What do you think happens
here, Seth?

00:08:18.250 --> 00:08:19.070
SETH LADD: Hopefully
a clear and

00:08:19.070 --> 00:08:20.540
consistent and logical error.

00:08:20.540 --> 00:08:21.040
JUSTIN FAGNANI: Amazing.

00:08:21.040 --> 00:08:22.200
You're right again.

00:08:22.200 --> 00:08:24.520
Here, you get a range error,
like you would expect.

00:08:24.520 --> 00:08:27.860
This has a number of benefits
to your program and the VM.

00:08:27.860 --> 00:08:29.720
Next, let's talk about scope.

00:08:29.720 --> 00:08:33.100
So JavaScript, as you might
know, has function scope.

00:08:33.100 --> 00:08:35.960
And it hoists the function
declarations to

00:08:35.960 --> 00:08:37.309
the top of the function.

00:08:37.309 --> 00:08:41.100
So here we have two variables
with the same name "foo." One

00:08:41.100 --> 00:08:43.760
of them is a top-level scope and
the other one is inside of

00:08:43.760 --> 00:08:46.160
this block here, inside
the if statement.

00:08:46.160 --> 00:08:49.140
So when we print foo here, how
do we know which one is going

00:08:49.140 --> 00:08:50.160
to be printed?

00:08:50.160 --> 00:08:52.800
Well, so we call this method
here and it's going to print

00:08:52.800 --> 00:08:53.260
something, Seth.

00:08:53.260 --> 00:08:54.110
What do you think it prints?

00:08:54.110 --> 00:08:56.020
SETH LADD: Hopefully, due
to the logical static

00:08:56.020 --> 00:08:56.310
[? analysis ?]

00:08:56.310 --> 00:08:58.650
I can do with my own eyes
here, top-level.

00:08:58.650 --> 00:09:00.200
JUSTIN FAGNANI: Seth
is a ringer.

00:09:00.200 --> 00:09:02.390
Yes, it does print top-level.

00:09:02.390 --> 00:09:06.380
So these things are less
confusing, less surprising and

00:09:06.380 --> 00:09:08.360
better for development.

00:09:08.360 --> 00:09:09.130
This also.

00:09:09.130 --> 00:09:10.910
So we have lexically
scoped this.

00:09:10.910 --> 00:09:13.590
This is bound to a
lexical scope.

00:09:13.590 --> 00:09:16.050
You always know what this
is going to refer to.

00:09:16.050 --> 00:09:19.810
In DOM programming, for example,
the "this" pointer of

00:09:19.810 --> 00:09:22.340
an event handler actually refers
to the function that's

00:09:22.340 --> 00:09:24.930
the event handler, not the
object that you're in when you

00:09:24.930 --> 00:09:25.770
define that function.

00:09:25.770 --> 00:09:28.580
And there's libraries that
try to fix this.

00:09:28.580 --> 00:09:30.370
But in Dart, we've just gone
ahead and fixed it for you.

00:09:30.370 --> 00:09:34.320
So in this case, this refers
to our instance of awesome

00:09:34.320 --> 00:09:35.420
button and it calls
the right method.

00:09:35.420 --> 00:09:38.700
And it's just very
unsurprising.

00:09:38.700 --> 00:09:40.490
SETH LADD: OK, so that
was the syntax, a

00:09:40.490 --> 00:09:41.550
little bit of the semantics.

00:09:41.550 --> 00:09:42.760
Let's talk about
the structure.

00:09:42.760 --> 00:09:45.030
Now, we've seen functions and
classes, and we'll see some of

00:09:45.030 --> 00:09:47.120
these other features like
mixins in a little bit.

00:09:47.120 --> 00:09:48.410
So let's talk about libraries.

00:09:48.410 --> 00:09:51.360
Dart has a really nice way to
bunch up your code into

00:09:51.360 --> 00:09:52.630
reusable chunks we
call libraries.

00:09:52.630 --> 00:09:54.030
Here's an example here.

00:09:54.030 --> 00:09:55.190
This is a single file.

00:09:55.190 --> 00:09:57.700
You simply declare that a file
is a library using library

00:09:57.700 --> 00:09:59.180
games here in this case.

00:09:59.180 --> 00:10:00.970
You can import other
libraries.

00:10:00.970 --> 00:10:03.440
Dart:math comes from
the Dart SDK.

00:10:03.440 --> 00:10:06.060
players.dart is another Dart
file, so we can pull in other

00:10:06.060 --> 00:10:07.900
files as libraries as well.

00:10:07.900 --> 00:10:11.080
And a feature I really like is
you can put, say, multiple

00:10:11.080 --> 00:10:14.350
classes, top-level functions
all in the same file.

00:10:14.350 --> 00:10:16.670
So it gives you a very flexible
way to organize not

00:10:16.670 --> 00:10:18.200
only just where you want
to put your classes and

00:10:18.200 --> 00:10:21.100
functions, but also how you want
to structure them on the

00:10:21.100 --> 00:10:21.650
file system.

00:10:21.650 --> 00:10:23.270
But everything falls
inside a library.

00:10:23.270 --> 00:10:24.950
You can then import them
and reuse them.

00:10:27.520 --> 00:10:29.360
OK, that was a lightning tour.

00:10:29.360 --> 00:10:31.020
Let's look at some
of what's new.

00:10:31.020 --> 00:10:33.610
We'll start with the language.

00:10:33.610 --> 00:10:36.260
All right, here's a common thing
that you always do, say,

00:10:36.260 --> 00:10:37.552
working with a DOM.

00:10:37.552 --> 00:10:40.330
You want to create a new button
and set up the state of

00:10:40.330 --> 00:10:41.000
that button--

00:10:41.000 --> 00:10:43.660
ID, text, classes,
click handlers.

00:10:43.660 --> 00:10:44.720
Well, in this particular
case, I've

00:10:44.720 --> 00:10:46.680
repeated button six times.

00:10:46.680 --> 00:10:47.700
That's a lot.

00:10:47.700 --> 00:10:50.450
Well, taking a cue from
Smalltalk, we've introduced

00:10:50.450 --> 00:10:51.760
method cascades.

00:10:51.760 --> 00:10:54.370
And in this example here, I've
eliminate the repetition of

00:10:54.370 --> 00:10:56.590
the variable button.

00:10:56.590 --> 00:10:57.950
See the double dots here?

00:10:57.950 --> 00:11:00.470
All of these expressions are
applied to this very first

00:11:00.470 --> 00:11:02.710
expression here new
ButtonElement.

00:11:02.710 --> 00:11:06.170
I've eliminated most of the
occurrences of button here.

00:11:06.170 --> 00:11:07.590
I like this for builder
type APIs.

00:11:07.590 --> 00:11:10.010
It makes it just more
clear and concise.

00:11:10.010 --> 00:11:12.800
But we can do a little bit
better, because all of these

00:11:12.800 --> 00:11:16.010
different cascades roll up to
this first expression here.

00:11:16.010 --> 00:11:18.150
I can actually eliminate
the need to

00:11:18.150 --> 00:11:20.070
introduce a new variable.

00:11:20.070 --> 00:11:23.120
So here you can see I can add
this new button element to the

00:11:23.120 --> 00:11:25.620
children of this parent element
and initialize its

00:11:25.620 --> 00:11:27.920
state all within the
same call here.

00:11:27.920 --> 00:11:29.270
This is really--

00:11:29.270 --> 00:11:32.130
JUSTIN FAGNANI: One great thing
about this is that it

00:11:32.130 --> 00:11:33.560
turns every API into
a builder API.

00:11:33.560 --> 00:11:35.680
So you don't have to
preemptively return this from

00:11:35.680 --> 00:11:37.920
all your methods in order
to have a fluent API.

00:11:37.920 --> 00:11:40.670
In Dart, every API becomes
fluent and it's universal

00:11:40.670 --> 00:11:41.920
across the board
and consistent.

00:11:45.190 --> 00:11:45.860
OK.

00:11:45.860 --> 00:11:48.330
So let's talk about another
great new language feature

00:11:48.330 --> 00:11:49.890
called mixins.

00:11:49.890 --> 00:11:54.090
So mixin is something that
languages, like Newspeak and

00:11:54.090 --> 00:11:57.880
Smalltalk have, and it's a way
to share code without using

00:11:57.880 --> 00:11:58.640
inheritance.

00:11:58.640 --> 00:12:00.840
You might be familiar with the
maxim, composition over

00:12:00.840 --> 00:12:02.170
inheritance.

00:12:02.170 --> 00:12:04.100
And the idea is that there's
problems if you try to share

00:12:04.100 --> 00:12:05.940
code exclusively through
inheritance.

00:12:05.940 --> 00:12:07.400
You can only have
one super-class.

00:12:07.400 --> 00:12:10.020
So it might not be a class you
actually want to extend.

00:12:10.020 --> 00:12:12.270
So in the last year, Dart's
added mixins.

00:12:12.270 --> 00:12:15.000
And let's take our hug example
from before and let's say we

00:12:15.000 --> 00:12:16.930
want to save it to a database.

00:12:16.930 --> 00:12:18.990
A typical solution to this is
you extend some kind of

00:12:18.990 --> 00:12:21.010
persistable base class.

00:12:21.010 --> 00:12:21.800
But that has a lot
of problems.

00:12:21.800 --> 00:12:24.080
You might want to extend some
other class, actually.

00:12:24.080 --> 00:12:26.510
So what you're interested in
here is the behavior, not

00:12:26.510 --> 00:12:28.950
necessarily the inheritance
hierarchy.

00:12:28.950 --> 00:12:31.660
Hug is not actually
a persistable.

00:12:31.660 --> 00:12:33.530
It has the persistable
behavior.

00:12:33.530 --> 00:12:35.750
So you don't want to pollute
your inheritance tree.

00:12:35.750 --> 00:12:38.430
Instead, what you want to do
is just add this behavior.

00:12:38.430 --> 00:12:40.790
You want to compose it or slide
it in from the side--

00:12:40.790 --> 00:12:42.490
the persistable behavior.

00:12:42.490 --> 00:12:44.080
So what does this look like?

00:12:44.080 --> 00:12:48.070
Well, up top here we have our
abstract class persistable.

00:12:48.070 --> 00:12:50.890
And in save and load, we defined
the behavior we want,

00:12:50.890 --> 00:12:53.430
the implementations in the
dot, dot, dots there.

00:12:53.430 --> 00:12:56.250
And we require that classes
that implement persistable

00:12:56.250 --> 00:12:57.740
implement this toJson method.

00:12:57.740 --> 00:13:00.000
Once they do that, save and load
can use that method in

00:13:00.000 --> 00:13:01.980
order to implement
their behavior.

00:13:01.980 --> 00:13:04.840
So down here in our hug class,
we're going to use the brand

00:13:04.840 --> 00:13:07.490
new keyboard with to say that we
want to mix in the behavior

00:13:07.490 --> 00:13:09.810
from persistable into
our hug class.

00:13:09.810 --> 00:13:12.130
And then you'll notice that we
define that toJson class,

00:13:12.130 --> 00:13:13.860
which is used by the
other methods.

00:13:13.860 --> 00:13:16.230
And in the bottom here, you can
see that we call the save

00:13:16.230 --> 00:13:18.120
method that's been
added to hug.

00:13:18.120 --> 00:13:20.810
It's not inheritance and it
behaves as you would expect.

00:13:20.810 --> 00:13:24.510
So this is a great way to
compose classes together.

00:13:24.510 --> 00:13:26.790
You also notice that persistable
is just a class.

00:13:26.790 --> 00:13:28.870
We don't have a mixin keyword.

00:13:28.870 --> 00:13:30.410
So that's just a few
restrictions.

00:13:30.410 --> 00:13:32.270
If your class extends object
and it doesn't have a

00:13:32.270 --> 00:13:35.290
constructor, then you can
use it as a mixin.

00:13:35.290 --> 00:13:37.740
And some of these restrictions
might go away over time.

00:13:40.572 --> 00:13:43.406
Oh, we had animations.

00:13:43.406 --> 00:13:43.850
All right.

00:13:43.850 --> 00:13:46.540
SETH LADD: Another new
feature are metadata.

00:13:46.540 --> 00:13:47.540
Here's a good example.

00:13:47.540 --> 00:13:51.160
You can use metadata with the
at symbol here, @deprecated.

00:13:51.160 --> 00:13:53.730
And that gives really good
feedback to, say, tools.

00:13:53.730 --> 00:13:56.110
In this case, the Dart Editor,
he can look at @deprecated,

00:13:56.110 --> 00:13:58.760
and then visually indicate the
functions or methods that are

00:13:58.760 --> 00:14:00.250
deprecated.

00:14:00.250 --> 00:14:02.990
The nice thing about metadata
in Dart though, is you can

00:14:02.990 --> 00:14:04.500
define your own metadata.

00:14:04.500 --> 00:14:06.340
Here's a good example of an
in-progress feature we're

00:14:06.340 --> 00:14:09.730
working on, lazy load libraries,
that uses const

00:14:09.730 --> 00:14:12.090
objects as metadata
annotations.

00:14:12.090 --> 00:14:14.040
Let's try to walk through
some of this code.

00:14:14.040 --> 00:14:15.950
So first we're going to declare
that the library

00:14:15.950 --> 00:14:17.090
itself is deferred.

00:14:17.090 --> 00:14:20.230
We're creating a const
object, const lazy.

00:14:20.230 --> 00:14:22.690
We can then use that lazy
const object to mark the

00:14:22.690 --> 00:14:26.260
import as lazy as shown here.

00:14:26.260 --> 00:14:29.710
Then, we can call load on that
lazy const object, the

00:14:29.710 --> 00:14:32.350
deferred library, and use a
Future to wait for that

00:14:32.350 --> 00:14:33.880
library to finish loading.

00:14:33.880 --> 00:14:36.930
Then, we can use the features
and functionality from that

00:14:36.930 --> 00:14:40.630
library inside of the future.

00:14:40.630 --> 00:14:44.740
Now, our tools can read these
metadata annotations here and

00:14:44.740 --> 00:14:48.190
say, take in Dart applications
spread across multiple files.

00:14:48.190 --> 00:14:50.840
Pipe them through dart2js,
which can look for these

00:14:50.840 --> 00:14:53.740
metadata annotations and spit
out a single JavaScript file

00:14:53.740 --> 00:14:54.810
for the bulk of the app.

00:14:54.810 --> 00:14:56.540
And then, another JavaScript
file for

00:14:56.540 --> 00:14:58.180
that lazy loaded library.

00:14:58.180 --> 00:15:01.200
This is a great deployment time
tool for you to choose

00:15:01.200 --> 00:15:03.510
how and when you want to load in
the different components of

00:15:03.510 --> 00:15:04.760
your application.

00:15:06.960 --> 00:15:09.090
JUSTIN FAGNANI: OK, so that's
what's new in the language.

00:15:09.090 --> 00:15:10.450
Let's talk next about
the libraries.

00:15:10.450 --> 00:15:13.050
There's been a lot of great
developments in the last year.

00:15:13.050 --> 00:15:15.530
First, let's talk about the
number one question that we

00:15:15.530 --> 00:15:17.990
get asked with Dart
is, can I use

00:15:17.990 --> 00:15:19.330
existing JavaScript libraries?

00:15:19.330 --> 00:15:21.220
Can I integrate with JavaScript
in some way?

00:15:21.220 --> 00:15:22.670
And the answer is yes.

00:15:22.670 --> 00:15:25.860
We do this through our
JavaScript interop package.

00:15:25.860 --> 00:15:29.030
Now, Dart can exist in two
different worlds, really.

00:15:29.030 --> 00:15:31.030
We have this Dart to JS world,
where everything is compiled

00:15:31.030 --> 00:15:32.070
to JavaScript.

00:15:32.070 --> 00:15:34.360
And also, in Dartium, we have
a world where there's two

00:15:34.360 --> 00:15:35.900
different VMs.

00:15:35.900 --> 00:15:38.560
And so you don't always have
direct access to the objects.

00:15:38.560 --> 00:15:40.770
So the way JavaScript interop
works is that

00:15:40.770 --> 00:15:41.890
we use proxy objects.

00:15:41.890 --> 00:15:43.950
And these proxy objects
represent an object that's in

00:15:43.950 --> 00:15:45.400
the other environment.

00:15:45.400 --> 00:15:47.040
And the calls are forwarded,
data is

00:15:47.040 --> 00:15:49.900
serialized as necessary.

00:15:49.900 --> 00:15:51.030
So let's show an example.

00:15:51.030 --> 00:15:54.840
So here we're using the JS
package with the prefix js.

00:15:54.840 --> 00:15:57.760
We have code up top in Dart and
down below in JavaScript.

00:15:57.760 --> 00:16:00.710
And we're going to use an
imaginary charts API.

00:16:00.710 --> 00:16:02.620
You can see that the code looks
very, very similar.

00:16:02.620 --> 00:16:05.390
In the first line, here we're
just stashing a reference to

00:16:05.390 --> 00:16:06.880
the API object.

00:16:06.880 --> 00:16:09.420
In the second line, we need
to create some data.

00:16:09.420 --> 00:16:12.590
Because our charts API is a
JavaScript API and we need the

00:16:12.590 --> 00:16:15.390
data to be a JavaScript array,
we simply pass a Dart array to

00:16:15.390 --> 00:16:18.380
this function that creates a
JavaScript array out of it.

00:16:18.380 --> 00:16:20.580
And then in the third line
here, we want to

00:16:20.580 --> 00:16:21.770
create a new chart.

00:16:21.770 --> 00:16:24.490
The way you do this from the
Dart world is you say, I want

00:16:24.490 --> 00:16:25.360
to create a new proxy.

00:16:25.360 --> 00:16:26.740
And you tell it what constructor
and what

00:16:26.740 --> 00:16:28.090
arguments to use.

00:16:28.090 --> 00:16:29.530
A little bit different,
but looks very

00:16:29.530 --> 00:16:31.290
similar to the line below.

00:16:31.290 --> 00:16:33.630
And then finally, chart
is now a proxy to

00:16:33.630 --> 00:16:34.840
a JavaScript object.

00:16:34.840 --> 00:16:37.500
And now you can interact with
it in a way that looks very

00:16:37.500 --> 00:16:38.910
much like any other
Dart object.

00:16:38.910 --> 00:16:41.780
And in fact, looks identical
to the JavaScript below.

00:16:41.780 --> 00:16:45.010
So with a JS interop package,
you can use JavaScript APIs.

00:16:45.010 --> 00:16:48.880
This is very important for
existing applications.

00:16:48.880 --> 00:16:51.190
SETH LADD: Another new library
we've been working on over the

00:16:51.190 --> 00:16:54.580
past year is our Mirror-based
reflection library.

00:16:54.580 --> 00:16:57.620
With mirror-based reflection,
you can do source code and

00:16:57.620 --> 00:16:58.730
run-time reflection.

00:16:58.730 --> 00:17:01.530
That is, you can load up a bunch
of source code and use

00:17:01.530 --> 00:17:03.320
mirrors to ask questions
about it.

00:17:03.320 --> 00:17:05.839
You can also, at run-time, ask
questions about the structure

00:17:05.839 --> 00:17:06.770
of your app.

00:17:06.770 --> 00:17:11.060
You can use mirrors to reflect
on both classes and instances.

00:17:11.060 --> 00:17:13.880
And you can introspect, say what
fields do you have, what

00:17:13.880 --> 00:17:16.990
construction do you have, and
invoke methods on those

00:17:16.990 --> 00:17:18.960
objects dynamically.

00:17:18.960 --> 00:17:19.780
How might we use this?

00:17:19.780 --> 00:17:22.869
Well, here's an example of
creating a logging proxy.

00:17:22.869 --> 00:17:25.329
Say I have some client code that
wants to call Hello on

00:17:25.329 --> 00:17:28.300
some object, but I wanted to go
through a proxy that logs

00:17:28.300 --> 00:17:29.530
all these calls.

00:17:29.530 --> 00:17:30.920
So it's going to hit
proxy first.

00:17:30.920 --> 00:17:33.050
He's going to print out some
sort of logging statement.

00:17:33.050 --> 00:17:35.380
Then he's going to delegate
the actual Hello call back

00:17:35.380 --> 00:17:37.230
down to the true delegate
object.

00:17:37.230 --> 00:17:40.530
Let's see how we do this with
mirrors and reflection.

00:17:40.530 --> 00:17:42.960
So first up, import the
Dart mirrors library.

00:17:42.960 --> 00:17:46.150
It comes to you from
the Dart SDK.

00:17:46.150 --> 00:17:49.000
Next, use the top-level function
reflect to reflect on

00:17:49.000 --> 00:17:53.340
the delegate object and get
back an instance mirror.

00:17:53.340 --> 00:17:57.090
Next, now remember if you call
a getter or function on an

00:17:57.090 --> 00:17:59.340
object and that doesn't
exist, you'll get a

00:17:59.340 --> 00:18:00.130
noSuchMethodError.

00:18:00.130 --> 00:18:03.050
It's Nice clear, and concise.

00:18:03.050 --> 00:18:05.550
You can actually implement
noSuchMethod here and capture

00:18:05.550 --> 00:18:07.300
those calls and do something
dynamic and

00:18:07.300 --> 00:18:08.200
interesting with it.

00:18:08.200 --> 00:18:10.210
In this case, we're going to do
that to capture all calls

00:18:10.210 --> 00:18:13.110
going through our
logging proxy.

00:18:13.110 --> 00:18:14.600
Before we actually delegate,
let's go ahead and

00:18:14.600 --> 00:18:15.800
log that call out.

00:18:15.800 --> 00:18:17.210
We'll just print it
out very easily.

00:18:17.210 --> 00:18:20.240
And then, using that instance
mirror itself, we can delegate

00:18:20.240 --> 00:18:24.130
the original call that came in
from noSuchMethod and pipe it

00:18:24.130 --> 00:18:26.410
into the actual delegate
itself.

00:18:26.410 --> 00:18:29.330
This is a really nice way to
deal with run-time dynamic

00:18:29.330 --> 00:18:33.210
programs using noSuchMethod
and mirrors.

00:18:33.210 --> 00:18:34.420
Here's the example.

00:18:34.420 --> 00:18:37.330
We're going to create a login
proxy wrap greeter.

00:18:37.330 --> 00:18:39.360
We're going to call the Hello
method on what we

00:18:39.360 --> 00:18:40.310
think is the greeter.

00:18:40.310 --> 00:18:42.300
But of course, it's going
through logging proxy.

00:18:42.300 --> 00:18:43.680
Two things will be
printed out.

00:18:43.680 --> 00:18:45.220
First, the symbol Hello
was called.

00:18:45.220 --> 00:18:46.870
That comes from the
logging proxy.

00:18:46.870 --> 00:18:48.860
And then, Hello that comes from
the greeter because we

00:18:48.860 --> 00:18:53.280
delegated that call back
down to the delegate.

00:18:53.280 --> 00:18:54.710
JUSTIN FAGNANI: All right, let's
talk about something

00:18:54.710 --> 00:18:56.880
that's very important for web
programming, which is

00:18:56.880 --> 00:18:58.830
asynchronous APIs
and asynchronous

00:18:58.830 --> 00:19:00.540
programming in Dart.

00:19:00.540 --> 00:19:03.940
So Dart's had some facilities
for asynchronous programming

00:19:03.940 --> 00:19:05.270
and they've been greatly
expanded in the

00:19:05.270 --> 00:19:07.740
new Dart Async library.

00:19:07.740 --> 00:19:10.150
First of all, why is async
programming so important?

00:19:10.150 --> 00:19:12.290
Why is it such a big
deal for Dart?

00:19:12.290 --> 00:19:14.740
Well, the web is full of
asynchronous APIs.

00:19:14.740 --> 00:19:17.530
These are the APIs that when
you invoke them, they don't

00:19:17.530 --> 00:19:19.370
block your program and they
go do some work in the

00:19:19.370 --> 00:19:19.880
background.

00:19:19.880 --> 00:19:22.370
Or maybe they wait for some
event to happen and they need

00:19:22.370 --> 00:19:23.890
to notify your program
when they're done,

00:19:23.890 --> 00:19:25.070
so they take a callback.

00:19:25.070 --> 00:19:27.460
And when they've loaded some
data or a user clicks on a

00:19:27.460 --> 00:19:30.120
button or something, the
callback is invoked.

00:19:30.120 --> 00:19:32.940
If you need to perform some data
after that, then you need

00:19:32.940 --> 00:19:34.210
to call another--

00:19:34.210 --> 00:19:36.360
perform another asynchronous
operation after that, you need

00:19:36.360 --> 00:19:38.950
to call another API in the
callback and then register

00:19:38.950 --> 00:19:40.070
another callback.

00:19:40.070 --> 00:19:42.500
You end up with these nested
callbacks, which leads us to

00:19:42.500 --> 00:19:45.490
what is known as
callback hell.

00:19:45.490 --> 00:19:48.570
Well, with Dart, we've tried
to add features to the

00:19:48.570 --> 00:19:50.970
libraries that make your life
easier and lead you from

00:19:50.970 --> 00:19:53.300
callback hell to callback
nirvana, or

00:19:53.300 --> 00:19:54.550
callback tropical beach.

00:19:54.550 --> 00:19:55.270
SETH LADD: Beautiful beach.

00:19:55.270 --> 00:19:56.550
JUSTIN FAGNANI: Yeah.

00:19:56.550 --> 00:19:58.920
And we do this with futures
and streams.

00:19:58.920 --> 00:20:01.560
So first, let's take
a look at futures.

00:20:01.560 --> 00:20:05.420
So a future is a promise that
there will be some value

00:20:05.420 --> 00:20:07.400
delivered to you at some
time in the future.

00:20:07.400 --> 00:20:09.640
In fact, in JavaScript
libraries, the concept is

00:20:09.640 --> 00:20:11.080
often called promises.

00:20:11.080 --> 00:20:13.570
So first, let's look at a
callback example here.

00:20:13.570 --> 00:20:17.010
DoStuff is an asynchronous
method.

00:20:17.010 --> 00:20:19.270
It takes as a first argument a
callback that will be invoked

00:20:19.270 --> 00:20:19.770
when it's done.

00:20:19.770 --> 00:20:23.450
And as its second optional
method, an error handler.

00:20:23.450 --> 00:20:25.550
So this is what a callback-based
API would look

00:20:25.550 --> 00:20:26.390
like in Dart.

00:20:26.390 --> 00:20:29.950
And as you can see, even with
a simple one-level deep no

00:20:29.950 --> 00:20:32.435
nesting, it's already looking
a little complicated.

00:20:32.435 --> 00:20:34.610
Well, with futures, what you
do is instead of taking a

00:20:34.610 --> 00:20:36.370
callback, you return a future.

00:20:36.370 --> 00:20:38.800
And this future object has
a very consistent way of

00:20:38.800 --> 00:20:40.760
registering the callback
in the error handler.

00:20:40.760 --> 00:20:43.060
All futures are the
same class.

00:20:43.060 --> 00:20:44.360
They all do this the same way.

00:20:44.360 --> 00:20:46.280
And you can see it already
looks a little cleaner.

00:20:46.280 --> 00:20:50.560
But because futures chain, they
return themselves, you

00:20:50.560 --> 00:20:52.370
can make this look
even simpler.

00:20:52.370 --> 00:20:54.230
You don't actually have to store
the future in a value.

00:20:54.230 --> 00:20:55.500
And in fact, in Dart,
you often see code

00:20:55.500 --> 00:20:56.520
that looks like this.

00:20:56.520 --> 00:20:58.140
You call an asynchronous
method.

00:20:58.140 --> 00:21:00.350
You register a handler and
you register a callback.

00:21:00.350 --> 00:21:02.170
And it looks very sequential.

00:21:02.170 --> 00:21:03.940
SETH LADD: We should point out
here that handle and handle

00:21:03.940 --> 00:21:05.570
errors themselves
are functions.

00:21:05.570 --> 00:21:07.830
So we can pass in a function
right into these callbacks

00:21:07.830 --> 00:21:10.720
without dealing with a whole
one-line or multiple line,

00:21:10.720 --> 00:21:11.760
like what you see on the left.

00:21:11.760 --> 00:21:14.290
JUSTIN FAGNANI: Exactly.

00:21:14.290 --> 00:21:16.730
All right, now let's look at
something where we have more

00:21:16.730 --> 00:21:18.140
than one level of nesting.

00:21:18.140 --> 00:21:20.680
So here's an imaginary cat
service, because we all know

00:21:20.680 --> 00:21:24.580
the internet basically exists
for trading cat pictures.

00:21:24.580 --> 00:21:27.290
So the first step we do here
is we get some cat data.

00:21:27.290 --> 00:21:28.780
And once we get the cat
data, we're going to

00:21:28.780 --> 00:21:29.740
want to go get a picture.

00:21:29.740 --> 00:21:31.290
And then once we have the
picture, we're going to want

00:21:31.290 --> 00:21:32.330
to rotate it and some work.

00:21:32.330 --> 00:21:33.960
These are all asynchronous
calls.

00:21:33.960 --> 00:21:37.570
And finally, four levels deep,
we do the work we wanted to.

00:21:37.570 --> 00:21:39.650
And you can already see that the
control flow here is hard

00:21:39.650 --> 00:21:42.860
to follow because it's based on
the nesting and where the

00:21:42.860 --> 00:21:43.980
arguments are.

00:21:43.980 --> 00:21:45.110
But it gets even worse.

00:21:45.110 --> 00:21:47.540
Now imagine you want to
do error handling.

00:21:47.540 --> 00:21:50.140
And if these methods each take
an error handler, than the

00:21:50.140 --> 00:21:50.940
error handlers get a little bit

00:21:50.940 --> 00:21:52.900
separated from the callbacks.

00:21:52.900 --> 00:21:55.250
And if there's actually real
work being done in these, if

00:21:55.250 --> 00:21:56.870
they're not just one-liners,
this becomes very

00:21:56.870 --> 00:21:58.500
complicated to follow.

00:21:58.500 --> 00:22:01.070
But if you imagine the same
example with futures, it

00:22:01.070 --> 00:22:02.400
becomes much simpler.

00:22:02.400 --> 00:22:04.660
With futures, the errors are
propagated through them and

00:22:04.660 --> 00:22:05.720
you can chain them
with different

00:22:05.720 --> 00:22:07.090
asynchronous calls in a row.

00:22:07.090 --> 00:22:09.830
And you can make that same
nested callback structure look

00:22:09.830 --> 00:22:11.470
like a sequence of events.

00:22:11.470 --> 00:22:15.340
So this is where futures start
to show some big advantages in

00:22:15.340 --> 00:22:16.890
terms of clarity of the code.

00:22:16.890 --> 00:22:18.720
SETH LADD: When you say the
error is propagated-- so an

00:22:18.720 --> 00:22:20.950
error or exception can
happen at any one of

00:22:20.950 --> 00:22:22.000
these calls to then.

00:22:22.000 --> 00:22:24.220
It will bubble down to
that one catch error.

00:22:24.220 --> 00:22:24.510
JUSTIN FAGNANI: Exactly.

00:22:24.510 --> 00:22:26.670
You don't have to register
multiple error handlers.

00:22:26.670 --> 00:22:29.160
It's almost like a try catch
block, but asynchronously.

00:22:31.770 --> 00:22:33.010
OK, so that's not all, right?

00:22:33.010 --> 00:22:35.910
So futures are nice and
consistent and they clean up

00:22:35.910 --> 00:22:37.620
the code structure
a little bit.

00:22:37.620 --> 00:22:39.120
But futures also compose.

00:22:39.120 --> 00:22:41.490
Future is like our first-class
concept of, there will be a

00:22:41.490 --> 00:22:42.300
value in the future.

00:22:42.300 --> 00:22:45.180
And you can write utilities
that deal in futures.

00:22:45.180 --> 00:22:47.290
And one of the most basic
utilities is just waiting for

00:22:47.290 --> 00:22:48.970
things to happen in parallel.

00:22:48.970 --> 00:22:51.550
So future has a static method on
it called wait, which takes

00:22:51.550 --> 00:22:52.970
a list of other futures.

00:22:52.970 --> 00:22:54.950
It waits for them all to
complete and returns a new

00:22:54.950 --> 00:22:56.230
future when it's done.

00:22:56.230 --> 00:22:59.340
And so this is a very easy way
to wait for parallel items.

00:22:59.340 --> 00:23:01.850
You can imagine in JavaScript,
you usually have to keep some

00:23:01.850 --> 00:23:04.440
kind of counter of how many
callbacks have finished, and

00:23:04.440 --> 00:23:06.735
update them, and error handling
becomes difficult.

00:23:06.735 --> 00:23:08.150
Well, here it's all
done for you.

00:23:08.150 --> 00:23:09.570
You just give it a
list of futures.

00:23:09.570 --> 00:23:11.090
Here we're getting two
pictures and we

00:23:11.090 --> 00:23:12.130
want to blend them.

00:23:12.130 --> 00:23:16.520
And we still have an error
handler down at the bottom.

00:23:16.520 --> 00:23:18.475
So we work with both pictures.

00:23:18.475 --> 00:23:19.720
I'll go back.

00:23:19.720 --> 00:23:22.180
And notice that the error
handler will work on the

00:23:22.180 --> 00:23:23.840
future that are happening
in parallel and

00:23:23.840 --> 00:23:27.190
every subsequent operation.

00:23:27.190 --> 00:23:29.210
OK, so futures have been around
for a little while, but

00:23:29.210 --> 00:23:31.570
what's really new in
Dart is streams.

00:23:31.570 --> 00:23:32.770
So futures only fire once.

00:23:32.770 --> 00:23:35.390
But you also have to worry about
repeating events, things

00:23:35.390 --> 00:23:39.890
like user interaction with
the UI and I/O. So

00:23:39.890 --> 00:23:41.280
streams are the new thing.

00:23:41.280 --> 00:23:43.750
And they are the repeating
analog to future.

00:23:43.750 --> 00:23:46.720
And in the Dart libraries,
because we get to start fresh,

00:23:46.720 --> 00:23:49.570
nearly all repeating events
in Dart are streams.

00:23:49.570 --> 00:23:53.620
You should see very, very, if
any, little callback-based

00:23:53.620 --> 00:23:54.370
APIs anymore.

00:23:54.370 --> 00:23:55.620
SETH LADD: I think that's
an excellent point.

00:23:55.620 --> 00:23:59.320
With futures and streams, we
bake them across the APIs and

00:23:59.320 --> 00:24:00.460
libraries we've built.

00:24:00.460 --> 00:24:04.210
So everything from, say, opening
files to XML HTTP

00:24:04.210 --> 00:24:07.830
request, to get user media, to
the file I/O, the directories.

00:24:07.830 --> 00:24:08.360
JUSTIN FAGNANI: All your
basic DOM events.

00:24:08.360 --> 00:24:09.800
SETH LADD: All this now is
futures and streams.

00:24:09.800 --> 00:24:12.220
And you get that because we bake
it into the SDK for you.

00:24:12.220 --> 00:24:13.550
JUSTIN FAGNANI: And because we
got to start fresh with the

00:24:13.550 --> 00:24:15.650
libraries, too.

00:24:15.650 --> 00:24:17.440
So let's take a look
at an example.

00:24:17.440 --> 00:24:19.860
Here, we're going to look at
the documentation for the

00:24:19.860 --> 00:24:20.590
element class.

00:24:20.590 --> 00:24:23.040
This is the base class for
all the HTML elements.

00:24:23.040 --> 00:24:25.210
And you can see that there's
this line here that says

00:24:25.210 --> 00:24:27.720
onKeyPress is a property
that's a

00:24:27.720 --> 00:24:29.140
stream of keyboard events.

00:24:29.140 --> 00:24:29.910
So what does that mean?

00:24:29.910 --> 00:24:33.850
It means that we can do a query
here for a text area.

00:24:33.850 --> 00:24:36.990
And we can access this
onKeyPress property and call

00:24:36.990 --> 00:24:40.570
listen, which is very much
like then on a future.

00:24:40.570 --> 00:24:43.140
The function given to listen
will be invoked every time

00:24:43.140 --> 00:24:44.430
that there's a keypress
event and it will

00:24:44.430 --> 00:24:45.980
be given that event.

00:24:45.980 --> 00:24:48.450
So here we simply turn our key
press event into a string and

00:24:48.450 --> 00:24:48.940
print it out.

00:24:48.940 --> 00:24:53.180
So this'll print char equals
wherever we happen to type.

00:24:53.180 --> 00:24:54.360
But streams do a lot more.

00:24:54.360 --> 00:24:55.930
They have a very,
very rich API.

00:24:55.930 --> 00:24:57.300
You can filter the events.

00:24:57.300 --> 00:24:58.390
You can transform them.

00:24:58.390 --> 00:25:00.610
You can turn streams into
futures by getting the first

00:25:00.610 --> 00:25:03.100
or last element in a stream.

00:25:03.100 --> 00:25:05.130
So here's an example where
we want to get

00:25:05.130 --> 00:25:06.440
our keypress event.

00:25:06.440 --> 00:25:09.720
And let's say we only care about
events that are actually

00:25:09.720 --> 00:25:12.390
keys on the keyboard that
you can type and read.

00:25:12.390 --> 00:25:14.100
So you might want to want these
to get rid of control

00:25:14.100 --> 00:25:15.400
characters and things.

00:25:15.400 --> 00:25:17.440
So here, we can just
filter the stream.

00:25:17.440 --> 00:25:19.910
And we use some range filter
to say these are our valid

00:25:19.910 --> 00:25:20.770
characters.

00:25:20.770 --> 00:25:24.240
And this returns a new stream,
where we can call listen or

00:25:24.240 --> 00:25:27.180
more transformation
methods on.

00:25:27.180 --> 00:25:29.730
And next we're going
to call map.

00:25:29.730 --> 00:25:32.580
And what map does is it takes
every element, every event in

00:25:32.580 --> 00:25:34.760
the stream and it turns it into
some new kind of event

00:25:34.760 --> 00:25:36.520
and creates a new stream
out of that.

00:25:36.520 --> 00:25:37.840
So here we're going to
map and turn our

00:25:37.840 --> 00:25:40.690
keyboard events into strings.

00:25:40.690 --> 00:25:42.960
Finally, let's say we're only
concerned with the very first

00:25:42.960 --> 00:25:45.680
keypress in our text
area here.

00:25:45.680 --> 00:25:47.690
So we can call first on the
stream and that returns us a

00:25:47.690 --> 00:25:51.760
future now, which returns
a value when that

00:25:51.760 --> 00:25:53.090
key is first pressed.

00:25:53.090 --> 00:25:54.960
And then we call then
like we did before.

00:25:54.960 --> 00:25:56.070
And we can print out
that the first

00:25:56.070 --> 00:25:57.720
character is that character.

00:25:57.720 --> 00:25:59.370
And you can see that this
reads really nice.

00:25:59.370 --> 00:26:01.360
And because streams are so
common across the libraries,

00:26:01.360 --> 00:26:03.220
you'll be able to see and
recognize these patterns

00:26:03.220 --> 00:26:04.650
across Dart code bases.

00:26:07.710 --> 00:26:09.790
Finally, this is a relatively
short talk.

00:26:09.790 --> 00:26:12.950
So we don't have enough time,
nearly enough time to go to

00:26:12.950 --> 00:26:14.590
HTML and web components.

00:26:14.590 --> 00:26:17.430
There is a talk later at 3:30
PM with Emily and Seth.

00:26:17.430 --> 00:26:20.900
And they're going to go deep
into the new developments in

00:26:20.900 --> 00:26:23.800
HTML and web components and how
you develop rich complex

00:26:23.800 --> 00:26:25.530
UIs in Dart.

00:26:25.530 --> 00:26:28.030
A lot of changes in the last
year is that we've Dartified

00:26:28.030 --> 00:26:29.440
the HTML library.

00:26:29.440 --> 00:26:32.590
It follows Dart idioms, uses
Dart collections, and gives

00:26:32.590 --> 00:26:34.620
you some jQuery-like
functionality.

00:26:34.620 --> 00:26:36.590
We also have Web UI, which
is our custom elements

00:26:36.590 --> 00:26:37.630
implementation.

00:26:37.630 --> 00:26:40.470
We've done things like gotten
rid of vendor prefixes so you

00:26:40.470 --> 00:26:42.580
can just use one method call.

00:26:42.580 --> 00:26:44.900
So that's at 3:30
PM in this room.

00:26:44.900 --> 00:26:47.020
Yeah.

00:26:47.020 --> 00:26:47.620
SETH LADD: OK, cool.

00:26:47.620 --> 00:26:49.230
Let's look at what's new
across the tools

00:26:49.230 --> 00:26:51.600
and ecosystem here.

00:26:51.600 --> 00:26:53.230
Well, one thing that's really
important to point-- and we

00:26:53.230 --> 00:26:54.730
alluded to do this earlier--

00:26:54.730 --> 00:26:57.630
is that the development cycle in
Dart is very, very fast and

00:26:57.630 --> 00:26:58.790
very quick and iterative.

00:26:58.790 --> 00:27:00.820
This is important for web
developers who are used to

00:27:00.820 --> 00:27:02.240
simply making a change
and hitting

00:27:02.240 --> 00:27:03.210
Reload in their browser.

00:27:03.210 --> 00:27:04.610
They want to see that
change immediately.

00:27:04.610 --> 00:27:06.740
They don't want to be slowed
down by any sort of compile

00:27:06.740 --> 00:27:09.630
time process during the bulk
of their development.

00:27:09.630 --> 00:27:11.150
So I'm happy to say that
with Dartium--

00:27:11.150 --> 00:27:13.440
it's a special build of Chromium
with the Dart Virtual

00:27:13.440 --> 00:27:14.800
Machine embedded inside--

00:27:14.800 --> 00:27:17.670
we can deliver those very fast,
no compiles required,

00:27:17.670 --> 00:27:19.350
edit/reload cycles.

00:27:19.350 --> 00:27:21.350
So typically the flow will
look something like this.

00:27:21.350 --> 00:27:23.190
The feature
[? bugging section ?]

00:27:23.190 --> 00:27:25.040
throughout the bulk of the
development, you're simply

00:27:25.040 --> 00:27:27.070
writing code, hitting
Reload in Dartium.

00:27:27.070 --> 00:27:28.940
Boom, you see the change
right away.

00:27:28.940 --> 00:27:31.050
Only right at the very end--
and this is what we've been

00:27:31.050 --> 00:27:34.000
told by real users of Dart.

00:27:34.000 --> 00:27:37.280
Only at the very end will they
introduce dart2js, compile

00:27:37.280 --> 00:27:39.710
their application into
JavaScript, and test on all of

00:27:39.710 --> 00:27:40.750
the browsers.

00:27:40.750 --> 00:27:43.270
So this is really,
really nice.

00:27:43.270 --> 00:27:44.790
We've also been working
on a standalone

00:27:44.790 --> 00:27:46.060
editor called Dart Editor.

00:27:46.060 --> 00:27:48.240
This is built from the ground
up, built on the Eclipse

00:27:48.240 --> 00:27:50.720
platform, to give you features
and functionalities you're

00:27:50.720 --> 00:27:52.830
used to when you develop
code and apps on

00:27:52.830 --> 00:27:53.710
all the other platforms.

00:27:53.710 --> 00:27:54.830
Things like refactoring.

00:27:54.830 --> 00:27:58.260
Things like jump to definition,
inline types, a

00:27:58.260 --> 00:27:59.330
nice problems view.

00:27:59.330 --> 00:28:00.480
The list goes on and on.

00:28:00.480 --> 00:28:02.750
This is the kind of productive
developments experience that

00:28:02.750 --> 00:28:05.535
you like when you deal with code
as you grow from 1 to 10,

00:28:05.535 --> 00:28:08.320
to 1,000 to, to, say, 500 or a
million lines of code, which

00:28:08.320 --> 00:28:10.740
is not unheard of when you build
the kind of apps users

00:28:10.740 --> 00:28:12.000
are demanding.

00:28:12.000 --> 00:28:14.590
But if Eclipse is in your bag,
that's OK, because we've also

00:28:14.590 --> 00:28:16.100
got plug-ins for VIM.

00:28:16.100 --> 00:28:18.800
An actual plug-in for Eclipse
as opposed to Dart Editor,

00:28:18.800 --> 00:28:20.360
which is a standalone editor.

00:28:20.360 --> 00:28:21.740
Plug-ins for Sublime.

00:28:21.740 --> 00:28:24.010
And our friends IntelliJ
and WebStorm--

00:28:24.010 --> 00:28:25.830
they're actually up there in
the Chrome booth-- can show

00:28:25.830 --> 00:28:27.220
off their Dart plug-in
as well.

00:28:27.220 --> 00:28:29.750
So hopefully we've got a choice
for you across whatever

00:28:29.750 --> 00:28:31.880
editor you are working with.

00:28:31.880 --> 00:28:33.500
Now, we'd love to show a demo of
this, but we have something

00:28:33.500 --> 00:28:35.880
really new and exciting to
show you guys in terms of

00:28:35.880 --> 00:28:36.580
editing Dart.

00:28:36.580 --> 00:28:40.790
We're happy to announce the
relaunch of try.dartlang.org

00:28:40.790 --> 00:28:41.950
that our team's been
working on.

00:28:41.950 --> 00:28:44.410
We've taken the dart2js
compiler, compiled it with

00:28:44.410 --> 00:28:47.500
itself into JavaScript, put it
in a browser, and given you

00:28:47.500 --> 00:28:49.930
the ability to write Dart code
and see it live without having

00:28:49.930 --> 00:28:50.620
to install anything.

00:28:50.620 --> 00:28:51.330
So let's see.

00:28:51.330 --> 00:28:51.920
Let's take a look.

00:28:51.920 --> 00:28:52.580
JUSTIN FAGNANI: All right.

00:28:52.580 --> 00:28:53.830
Let's check it out.

00:28:55.970 --> 00:28:58.440
OK, so this is try.dartlang.org.

00:28:58.440 --> 00:29:02.330
As Seth mentioned, this is
using dart2js, which has

00:29:02.330 --> 00:29:04.740
compiled itself to be able
to run in the browser.

00:29:04.740 --> 00:29:07.080
So this is the same compiler
that the editor and the

00:29:07.080 --> 00:29:09.030
command line applications use.

00:29:09.030 --> 00:29:10.840
So here we have a simple
little text editor.

00:29:10.840 --> 00:29:12.770
Notice we have some syntax
highlighting happening here

00:29:12.770 --> 00:29:14.170
because of dart2js.

00:29:14.170 --> 00:29:18.290
We're going to change this
to Hello Google I/O.

00:29:18.290 --> 00:29:20.400
And notice it's compiling
on the fly.

00:29:20.400 --> 00:29:21.640
And there we go.

00:29:21.640 --> 00:29:22.960
We see the output.

00:29:22.960 --> 00:29:24.455
Also notice that this is
running in Firefox.

00:29:24.455 --> 00:29:30.140
So it's important to note how
critical dart2js is to the

00:29:30.140 --> 00:29:32.860
deployment step here, and how
much it enables Dart to run on

00:29:32.860 --> 00:29:34.440
all of the modern web.

00:29:34.440 --> 00:29:36.660
SETH LADD: Nice improvements
also is this works offline.

00:29:36.660 --> 00:29:37.970
This works on your iPad.

00:29:37.970 --> 00:29:39.965
And you can also edit
HTML apps as well.

00:29:39.965 --> 00:29:42.570
So very nicely way for you to
try Dart, and then go pick an

00:29:42.570 --> 00:29:44.210
editing experience that
works for you.

00:29:47.590 --> 00:29:49.070
OK, what else in tools
and ecosystem?

00:29:49.070 --> 00:29:51.800
Well, we have a nice unit
test library that

00:29:51.800 --> 00:29:52.650
comes out of the box.

00:29:52.650 --> 00:29:54.750
We also have a mock library
that comes out of the box.

00:29:54.750 --> 00:29:56.470
Here's a quick code sample
here at the top

00:29:56.470 --> 00:29:57.250
for our unit test.

00:29:57.250 --> 00:29:59.300
It looks familiar and I think
a lot of other unit test

00:29:59.300 --> 00:30:01.300
frameworks you might
have seen before.

00:30:01.300 --> 00:30:03.810
Also, happy to announce that
we a headless version of

00:30:03.810 --> 00:30:05.450
Chromium we call dump
render tree.

00:30:05.450 --> 00:30:10.150
But this allows you to run
HTML-based Dart tests in a

00:30:10.150 --> 00:30:11.440
headless browser.

00:30:11.440 --> 00:30:13.860
And say, then take that and
wire it into continuous

00:30:13.860 --> 00:30:17.140
integration services, like
Drone.io, who have native

00:30:17.140 --> 00:30:20.140
support for Dart and this
headless Chrome.

00:30:20.140 --> 00:30:23.270
So you can check in your code
into Bitpocket or GitHub, fire

00:30:23.270 --> 00:30:26.790
off a change which Drone.io
picks up, runs all of your

00:30:26.790 --> 00:30:29.530
tests from the command line,
runs all of your HTML tests or

00:30:29.530 --> 00:30:32.200
web tests in this headless
Chrome and reports back to you

00:30:32.200 --> 00:30:32.950
how everything's working.

00:30:32.950 --> 00:30:36.300
So you now start to see this
nice chain for really rich

00:30:36.300 --> 00:30:39.920
end-to-end development
experience.

00:30:39.920 --> 00:30:42.050
Also, been working on a
package manager, we

00:30:42.050 --> 00:30:43.375
affectionately call
Pub because you

00:30:43.375 --> 00:30:44.550
play darts in a pub.

00:30:44.550 --> 00:30:47.570
And with Pub, you can download
packages, manage the

00:30:47.570 --> 00:30:50.920
dependencies and the updates,
publish your own packages to

00:30:50.920 --> 00:30:54.290
Pub, and browse around
pub.dartlang.org, which is our

00:30:54.290 --> 00:30:57.280
hosting service, where there's
already over 200 packages out

00:30:57.280 --> 00:31:00.660
there ranging everything from
database drivers, to MVC

00:31:00.660 --> 00:31:04.190
frameworks, to encryption, to
parsers, game libraries, the

00:31:04.190 --> 00:31:05.310
list goes on and on and on.

00:31:05.310 --> 00:31:08.420
It's very easy for you guys to
publish your own packages into

00:31:08.420 --> 00:31:09.330
Pub as well.

00:31:09.330 --> 00:31:11.590
Pub works with our central
hosting service here.

00:31:11.590 --> 00:31:12.620
[? Git, ?]

00:31:12.620 --> 00:31:13.450
local file system.

00:31:13.450 --> 00:31:16.200
Very easy for you to reuse
and send out and share

00:31:16.200 --> 00:31:19.640
functionalities across
Dart apps.

00:31:19.640 --> 00:31:23.180
We're also really happy to
announce that the Flash Pro,

00:31:23.180 --> 00:31:27.000
the really rich animation
engine, game engine, or game

00:31:27.000 --> 00:31:31.300
editing tool from Adobe now can
export your animations and

00:31:31.300 --> 00:31:32.880
games to Dart.

00:31:32.880 --> 00:31:35.030
You can see a demo of this
up at our booth up

00:31:35.030 --> 00:31:36.160
in the Chrome area.

00:31:36.160 --> 00:31:37.600
So real quickly, you
don't have to

00:31:37.600 --> 00:31:38.690
write any action script.

00:31:38.690 --> 00:31:40.990
You can use the really rich
editing experience of the

00:31:40.990 --> 00:31:43.750
stage and the timeline and all
the asset managements of Flash

00:31:43.750 --> 00:31:46.430
Pro and go through their toolkit
here and export that

00:31:46.430 --> 00:31:49.380
all out to Dart code
and HTML5 APIs.

00:31:49.380 --> 00:31:51.790
Which means you can use their
really slick tools here, And

00:31:51.790 --> 00:31:54.160
then deploy that across the
modern web without any

00:31:54.160 --> 00:31:55.140
plug-ins at all.

00:31:55.140 --> 00:31:56.270
So if you guys are interested
in this, come

00:31:56.270 --> 00:31:57.520
check this out upstairs.

00:31:59.880 --> 00:32:02.990
JUSTIN FAGNANI: OK, next let's
talk about things that are

00:32:02.990 --> 00:32:05.260
very important to
web developers--

00:32:05.260 --> 00:32:09.000
size and speed, or
performance.

00:32:09.000 --> 00:32:13.440
So the web has gone on a
continuous evolution path

00:32:13.440 --> 00:32:14.310
since it started.

00:32:14.310 --> 00:32:16.773
And one of the things that's
happened with JavaScript is

00:32:16.773 --> 00:32:20.540
that it initially enabled the
very first client-side apps.

00:32:20.540 --> 00:32:22.590
And JavaScript wasn't that
fast, but then JavaScript

00:32:22.590 --> 00:32:23.860
became faster.

00:32:23.860 --> 00:32:27.720
With the advent of fast VMs
like V8, applications that

00:32:27.720 --> 00:32:29.880
started rivaling desktop
applications were

00:32:29.880 --> 00:32:31.300
now suddenly possible.

00:32:31.300 --> 00:32:33.750
And the applications grew
to use this performance.

00:32:33.750 --> 00:32:36.210
So as all the VMs out there
got faster and faster, the

00:32:36.210 --> 00:32:39.380
applications took advantage of
that and became more complex.

00:32:39.380 --> 00:32:41.640
So we see this continual
advancement and

00:32:41.640 --> 00:32:44.180
power-hungriness of
applications.

00:32:44.180 --> 00:32:45.270
So we don't see that ending.

00:32:45.270 --> 00:32:47.360
Performance is still
important.

00:32:47.360 --> 00:32:49.970
Another reason why performance
really, really matters is

00:32:49.970 --> 00:32:51.180
because of mobile.

00:32:51.180 --> 00:32:54.170
Now, on your laptop you have a
fairly large battery, or on

00:32:54.170 --> 00:32:55.940
your desktop you're plugged
into the wall.

00:32:55.940 --> 00:32:57.500
But on your phone or your
tablet, you actually don't

00:32:57.500 --> 00:32:58.790
have that large of a battery.

00:32:58.790 --> 00:33:01.810
If you last a day, that
might be a good day.

00:33:01.810 --> 00:33:03.890
And performance directly
impacts that.

00:33:03.890 --> 00:33:06.670
The faster your application is,
the less CPU it's using,

00:33:06.670 --> 00:33:08.850
that means the less battery
it's using.

00:33:08.850 --> 00:33:12.360
Even a 10% increase in battery
life is a significant

00:33:12.360 --> 00:33:12.890
improvement.

00:33:12.890 --> 00:33:14.430
So this really matters.

00:33:14.430 --> 00:33:20.560
And yeah, so what we like to say
is that every performance

00:33:20.560 --> 00:33:23.310
improvement is a battery
improvement.

00:33:23.310 --> 00:33:25.160
So first let's talk about
dart2js here in

00:33:25.160 --> 00:33:26.390
terms of our tools.

00:33:26.390 --> 00:33:29.880
So as we said, the dart2js is
responsible for compiling Dart

00:33:29.880 --> 00:33:31.460
to JavaScript.

00:33:31.460 --> 00:33:33.660
Quickly, the way this works
is that we pull in your

00:33:33.660 --> 00:33:36.300
application and all the
libraries it imports.

00:33:36.300 --> 00:33:39.020
We run it through all the
optimizations and compilation

00:33:39.020 --> 00:33:42.550
steps that dart2js does to
minify your application.

00:33:42.550 --> 00:33:45.810
And then, we output a JavaScript
file, the compiled

00:33:45.810 --> 00:33:47.670
version of your app.

00:33:47.670 --> 00:33:49.480
SETH LADD: We also output a
source map to enable really

00:33:49.480 --> 00:33:52.560
easy debugging, which maps the
original Dart code to the

00:33:52.560 --> 00:33:53.610
compiled JavaScript code.

00:33:53.610 --> 00:33:55.950
And your Chrome DevTools can
read all that, so when set a

00:33:55.950 --> 00:33:58.660
break point in your Chrome
DevTools, it's actually

00:33:58.660 --> 00:34:00.850
setting a breakpoint from the
Dart code and mapping to the

00:34:00.850 --> 00:34:01.470
Javascript code.

00:34:01.470 --> 00:34:03.140
JUSTIN FAGNANI: Which also
works in browsers like

00:34:03.140 --> 00:34:06.700
Firefox, and I believe, IE.

00:34:06.700 --> 00:34:09.179
OK, so let's look at some of the
generated JavaScript, so

00:34:09.179 --> 00:34:11.870
you can see a little bit about
what the compiler is doing.

00:34:11.870 --> 00:34:13.310
So here's a very
simple example.

00:34:13.310 --> 00:34:16.179
We have a Dart program that's
using the HTML library and it

00:34:16.179 --> 00:34:18.860
Defines a simple class, person,
and then it uses that

00:34:18.860 --> 00:34:22.020
class in some simple way
in the main method.

00:34:22.020 --> 00:34:26.340
So here's a JavaScript output
that the dart2js has produced.

00:34:26.340 --> 00:34:28.950
And you can see that it actually
is very readable and

00:34:28.950 --> 00:34:32.250
kind of corresponds logically
to the Dart source code.

00:34:32.250 --> 00:34:35.080
In fact, in this case, there's
like a one-to-one

00:34:35.080 --> 00:34:37.219
correspondence between the lines
of Dart and the lines of

00:34:37.219 --> 00:34:39.110
JavaScript.

00:34:39.110 --> 00:34:41.464
But like we mentioned, Dart
has minification.

00:34:41.464 --> 00:34:44.020
And it has tree shaking, which
is dead code elimination.

00:34:44.020 --> 00:34:46.850
So it's important to produce the
smallest application sizes

00:34:46.850 --> 00:34:47.800
as possible.

00:34:47.800 --> 00:34:50.429
So when you turn minification
on, you can see that as part

00:34:50.429 --> 00:34:53.800
of the compilation process, we
renamed variables and inline

00:34:53.800 --> 00:34:55.800
functions and do interesting
things here to give you the

00:34:55.800 --> 00:34:58.860
most compact JavaScript
possible.

00:34:58.860 --> 00:35:00.400
SETH LADD: So Justin mentioned
tree shaking.

00:35:00.400 --> 00:35:01.340
Well, what's tree shaking?

00:35:01.340 --> 00:35:03.240
So if you look at the marketing
material, pretty

00:35:03.240 --> 00:35:05.150
much every JavaScript library
out there, the first and

00:35:05.150 --> 00:35:07.580
foremost thing they tell
you is how small it is.

00:35:07.580 --> 00:35:10.160
Instead, I, as a developer, care
how good it is and how it

00:35:10.160 --> 00:35:11.140
can help me.

00:35:11.140 --> 00:35:12.720
Well, you shouldn't have to
worry about how small the

00:35:12.720 --> 00:35:13.350
libraries are.

00:35:13.350 --> 00:35:14.540
You should let the tools
handle that kind

00:35:14.540 --> 00:35:15.420
of stuff for you.

00:35:15.420 --> 00:35:16.320
Here's an example here.

00:35:16.320 --> 00:35:17.650
Here's an application.

00:35:17.650 --> 00:35:20.110
You've written the stuff on your
left here and it pulls in

00:35:20.110 --> 00:35:22.040
a library-- the library
in the yellow.

00:35:22.040 --> 00:35:24.840
And one of your functions calls
just one function from

00:35:24.840 --> 00:35:26.480
the yellow library.

00:35:26.480 --> 00:35:28.480
And there's no reason why you
should have to pull in all

00:35:28.480 --> 00:35:30.770
that baggage if you can
determine only the functions

00:35:30.770 --> 00:35:34.120
or the features that you
actually need in your app.

00:35:34.120 --> 00:35:36.430
Well, dart2js performs a
tree-shaking functionality,

00:35:36.430 --> 00:35:38.810
which takes all the
dependencies, all the imports,

00:35:38.810 --> 00:35:41.960
all the libraries and can look
at the program and say, OK,

00:35:41.960 --> 00:35:45.120
these are the bits you actually
use and produce just

00:35:45.120 --> 00:35:47.210
the code that is required
to run your app.

00:35:47.210 --> 00:35:49.290
Notice how you don't have these
leaf nodes that you

00:35:49.290 --> 00:35:50.530
never actually call.

00:35:50.530 --> 00:35:54.030
This is another reason why
dart2js can produce smaller,

00:35:54.030 --> 00:35:55.280
faster output for you.

00:35:57.640 --> 00:35:58.650
JUSTIN FAGNANI: Let's
talk about the

00:35:58.650 --> 00:36:01.120
performance of the Dart VM.

00:36:01.120 --> 00:36:05.970
So if you saw Lars and Casper's
talk, they went into

00:36:05.970 --> 00:36:08.220
great detail about why
the VM is faster.

00:36:08.220 --> 00:36:11.880
But real quickly, Dart has more
explicit and static and

00:36:11.880 --> 00:36:13.370
declarative structure.

00:36:13.370 --> 00:36:15.830
This allows the VM to be
braver and make smarter

00:36:15.830 --> 00:36:16.650
optimizations.

00:36:16.650 --> 00:36:18.660
And it allows the VM
to be simpler.

00:36:18.660 --> 00:36:20.620
We have real arrays
and real classes.

00:36:20.620 --> 00:36:23.340
You can invoke a method without
having to call the

00:36:23.340 --> 00:36:26.765
prototype chain to see if the
method has changed at all.

00:36:26.765 --> 00:36:30.800
So these things allow the VM
to be much faster already.

00:36:30.800 --> 00:36:35.670
And in addition to that, we're
able to use more of your CPU.

00:36:35.670 --> 00:36:39.160
So we've added SIMD extensions,
recently, to Dart.

00:36:39.160 --> 00:36:41.930
If you look at a modern CPU, a
significant portion of the die

00:36:41.930 --> 00:36:45.070
is dedicated to these vector
processors, these SIMD

00:36:45.070 --> 00:36:46.130
processors.

00:36:46.130 --> 00:36:49.390
This is an ARM CPU and you can
see that almost a third of the

00:36:49.390 --> 00:36:52.470
CPU is dedicated to the neon
and vector operations.

00:36:52.470 --> 00:36:54.650
SETH LADD: Yeah, traditional web
programming today can not

00:36:54.650 --> 00:36:57.530
unlock the full capabilities
of your CPU.

00:36:57.530 --> 00:36:58.400
And that's a real shame.

00:36:58.400 --> 00:37:01.730
And so the Dart VM says, yeah,
let's give you this power.

00:37:01.730 --> 00:37:03.710
JUSTIN FAGNANI: So how does
that performance actually

00:37:03.710 --> 00:37:04.440
manifest itself?

00:37:04.440 --> 00:37:07.990
Well, we have a few benchmarks
that we've been publishing.

00:37:07.990 --> 00:37:11.800
And you can see the blue bar
here is the Dart VM.

00:37:11.800 --> 00:37:14.340
And yes, higher is better.

00:37:14.340 --> 00:37:17.060
And so you can see on these
performance benchmarks here

00:37:17.060 --> 00:37:20.670
that the VM has been beating
handwritten JavaScript.

00:37:20.670 --> 00:37:23.540
And in fact, on the array
tracing example, it's almost

00:37:23.540 --> 00:37:24.980
two times as fast.

00:37:24.980 --> 00:37:27.630
And if you notice over here on
the left, on the Delta Blue

00:37:27.630 --> 00:37:30.700
benchmark, there are cases
where dart2js actually

00:37:30.700 --> 00:37:33.330
produces faster code than
handwritten JavaScript because

00:37:33.330 --> 00:37:35.360
of the optimizations
it's able to make.

00:37:35.360 --> 00:37:38.010
So here in Delta Blue, dart2js
is a little bit faster than

00:37:38.010 --> 00:37:38.640
JavaScript.

00:37:38.640 --> 00:37:40.160
SETH LADD: We should point out
that Dart is not even yet a

00:37:40.160 --> 00:37:43.860
1.0 production release and we're
still doing pretty good.

00:37:43.860 --> 00:37:45.440
But we have more work to go.

00:37:45.440 --> 00:37:47.720
JUSTIN FAGNANI: I think V8 has a
four or five-year head start

00:37:47.720 --> 00:37:50.750
on the Dart VM.

00:37:50.750 --> 00:37:53.150
OK, now, Seth.

00:37:53.150 --> 00:37:53.690
SETH LADD: Sure.

00:37:53.690 --> 00:37:54.440
Let's talk about this one.

00:37:54.440 --> 00:37:57.650
So the nice thing is these
charts here are all running on

00:37:57.650 --> 00:37:59.110
this beefy MacBook Pro.

00:37:59.110 --> 00:38:01.790
This guy's got like 87 cores
and 52 gigs of RAM.

00:38:01.790 --> 00:38:03.220
So of course, these numbers
are going to look really

00:38:03.220 --> 00:38:04.110
impressive.

00:38:04.110 --> 00:38:06.350
But does it translate down to
mobile, which is what we're

00:38:06.350 --> 00:38:08.660
all going to be developing
by this time next year?

00:38:08.660 --> 00:38:11.480
So happy to say that yes, the
same kind of performance

00:38:11.480 --> 00:38:14.010
characteristics when you use
the Dart VM as opposed to

00:38:14.010 --> 00:38:16.660
handwritten code does
translate over.

00:38:16.660 --> 00:38:19.920
So this is running on Chrome for
Android with the Dart VM

00:38:19.920 --> 00:38:22.010
embedded inside on
an x86 phone.

00:38:22.010 --> 00:38:23.960
You can see here the yellow
is handwritten JavaScript.

00:38:23.960 --> 00:38:26.450
The middle guy is
just Dart VM.

00:38:26.450 --> 00:38:31.230
And then the big tall blue bar
is Dart VM having ported the

00:38:31.230 --> 00:38:34.330
NBody simulation over to use
the SIMD instructions.

00:38:34.330 --> 00:38:37.470
So every performance matters
on mobile phones.

00:38:37.470 --> 00:38:39.180
As Justin said, it's all
about battery there.

00:38:39.180 --> 00:38:40.940
So you'll see the same
gains, even on the

00:38:40.940 --> 00:38:42.190
little devices here.

00:38:44.700 --> 00:38:47.350
JUSTIN FAGNANI: This basically
covers what we have for you

00:38:47.350 --> 00:38:49.370
for new stuff, but there's
so much more.

00:38:49.370 --> 00:38:51.120
There's a lot of things we
didn't get to cover.

00:38:51.120 --> 00:38:52.730
SETH LADD: We asked for the
three-hour slot and they

00:38:52.730 --> 00:38:53.375
didn't give it to us.

00:38:53.375 --> 00:38:54.520
JUSTIN FAGNANI: Yeah,
the keynote.

00:38:54.520 --> 00:38:57.120
We could have filled
the keynote.

00:38:57.120 --> 00:38:59.500
So we have an entire server-side
story with Dart.

00:38:59.500 --> 00:39:01.660
It's very similar to Node and
we have an I/O library.

00:39:01.660 --> 00:39:03.620
As Seth mentioned
earlier, we have

00:39:03.620 --> 00:39:05.540
extensive testing libraries.

00:39:05.540 --> 00:39:08.890
We also have a concurrency and
safety story in isolates that

00:39:08.890 --> 00:39:09.840
we didn't get to cover.

00:39:09.840 --> 00:39:11.270
And a lot more stuff.

00:39:11.270 --> 00:39:14.650
So you should really find
out more about Dart.

00:39:14.650 --> 00:39:15.700
SETH LADD: How do you find
out more about it?

00:39:15.700 --> 00:39:18.980
Well, many different ways
for you to try out Dart.

00:39:18.980 --> 00:39:22.235
Download the Dart SDK and the
Dart Editor from dartlang.org.

00:39:22.235 --> 00:39:24.780
We're active on Google+ and
Twitter, et cetera.

00:39:24.780 --> 00:39:26.350
We're also on GitHub as well.

00:39:26.350 --> 00:39:28.560
So we've received many patches
from the community in

00:39:28.560 --> 00:39:29.240
[? poll requests. ?]

00:39:29.240 --> 00:39:30.910
We have external committers
as well.

00:39:30.910 --> 00:39:32.520
We're active on Stack
Overflow.

00:39:32.520 --> 00:39:34.220
And it's important to
understand, Dart is an open

00:39:34.220 --> 00:39:35.110
source project.

00:39:35.110 --> 00:39:37.030
BSD license, very permissive.

00:39:37.030 --> 00:39:39.480
And so it's easy for you guys
to get involved in any

00:39:39.480 --> 00:39:40.980
different way that works
for you guys.

00:39:40.980 --> 00:39:42.560
JUSTIN FAGNANI: We've broken
up a lot of the smaller

00:39:42.560 --> 00:39:44.910
projects into their own
repositories on GitHub.

00:39:44.910 --> 00:39:47.050
And we've had a lot of external
contributors come in

00:39:47.050 --> 00:39:49.720
that way because it's very
easy to get started.

00:39:49.720 --> 00:39:52.410
SETH LADD: Lots more about Dart
here at I/O. Later today,

00:39:52.410 --> 00:39:53.680
the Dart HTML talk.

00:39:53.680 --> 00:39:54.650
Definitely check that out.

00:39:54.650 --> 00:39:55.870
We have a Code lab on Friday.

00:39:55.870 --> 00:39:58.060
So if you want to get your hands
dirty here working with

00:39:58.060 --> 00:40:00.130
all the latest and greatest,
join us on Friday.

00:40:00.130 --> 00:40:01.940
We'll be at office
hours as well.

00:40:01.940 --> 00:40:03.460
And the demo booth, you
can see a lot of

00:40:03.460 --> 00:40:06.170
this stuff in action.

00:40:06.170 --> 00:40:08.090
So to sum it up, what's
the main takeaway?

00:40:08.090 --> 00:40:10.020
Well, Dart-- we've got a
stable language now.

00:40:10.020 --> 00:40:12.320
We have stable core libraries.

00:40:12.320 --> 00:40:15.290
Dart compiles a JavaScript and
runs across modern browsers.

00:40:15.290 --> 00:40:17.240
And it's really been an
involved platform now.

00:40:17.240 --> 00:40:18.560
We've been out for, what?

00:40:18.560 --> 00:40:21.220
Almost two years, one
and a half years?

00:40:21.220 --> 00:40:23.660
We've gotten tons of feedback
from external developers,

00:40:23.660 --> 00:40:25.850
internal customers, external
customers.

00:40:25.850 --> 00:40:27.040
They've been telling
us what they like,

00:40:27.040 --> 00:40:27.460
what they don't like.

00:40:27.460 --> 00:40:28.450
We've put that all in.

00:40:28.450 --> 00:40:30.790
And so what you see today is
a nice evolved platform.

00:40:30.790 --> 00:40:32.180
And Google is committed
to Dart.

00:40:32.180 --> 00:40:36.140
We have internal high-priority
projects inside using Dart.

00:40:36.140 --> 00:40:39.620
And we're going to see this,
so that you can make it--

00:40:39.620 --> 00:40:41.330
Dart is ready for your app.

00:40:41.330 --> 00:40:42.660
That's the main point here.

00:40:42.660 --> 00:40:46.460
Hopefully you liked
what you saw.

00:40:46.460 --> 00:40:49.150
And we'll be around to answer a
lot of your questions here.

00:40:49.150 --> 00:40:50.510
I think we can probably take
one or two questions.

00:40:50.510 --> 00:40:52.060
But we'll be up at
the office hours

00:40:52.060 --> 00:40:53.220
immediately after this talk.

00:40:53.220 --> 00:40:54.860
And we'd love to hear what
you guys are building.

00:40:54.860 --> 00:40:58.820
So with that, we're all set.

00:40:58.820 --> 00:40:59.185
JUSTIN FAGNANI: Thanks.

00:40:59.185 --> 00:40:59.895
SETH LADD: Thank you.

00:40:59.895 --> 00:41:08.640
[APPLAUSE]

00:41:08.640 --> 00:41:10.000
SETH LADD: We could take
a question or two

00:41:10.000 --> 00:41:10.910
if anyone has any.

00:41:10.910 --> 00:41:12.480
OK, cool.

00:41:12.480 --> 00:41:15.610
AUDIENCE: Do you think we'll
see Dart on App Engine?

00:41:15.610 --> 00:41:17.260
SETH LADD: I would personally
love to see that happen.

00:41:17.260 --> 00:41:19.380
There's a bug in the issue
tracker for App Engine.

00:41:19.380 --> 00:41:23.606
Go ahead and star that
and let them know.

00:41:23.606 --> 00:41:24.050
OK.

00:41:24.050 --> 00:41:24.325
Thanks.

00:41:24.325 --> 00:41:25.400
We'll be around here.

00:41:25.400 --> 00:41:26.650
Thank you.

