WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.778
[MUSIC PLAYING]

00:00:05.600 --> 00:00:08.200
LEON NICHOLLS: Hi, everyone.

00:00:08.200 --> 00:00:10.190
NANDINI STOCKER: Hi, everybody.

00:00:10.190 --> 00:00:13.000
Let's talk about one
of the hardest parts

00:00:13.000 --> 00:00:16.900
of designing a spoken dialogue
between a human and a computer.

00:00:16.900 --> 00:00:19.224
LEON NICHOLLS: How to
handle so-called "errors."

00:00:19.224 --> 00:00:20.890
NANDINI STOCKER: Now,
before we dive in,

00:00:20.890 --> 00:00:24.250
any good conversation starts
by knowing who's talking.

00:00:24.250 --> 00:00:25.630
I'm Nandini Stocker.

00:00:25.630 --> 00:00:27.380
LEON NICHOLLS: And
I'm Leon Nicholls.

00:00:27.380 --> 00:00:29.860
NANDINI STOCKER: Leon is a
developer relations engineer

00:00:29.860 --> 00:00:32.020
for Google Assistant apps.

00:00:32.020 --> 00:00:34.630
LEON NICHOLLS: And Nandini
leads the conversation design

00:00:34.630 --> 00:00:36.350
outreach for Actions on Google.

00:00:39.174 --> 00:00:40.590
NANDINI STOCKER:
Our two teams are

00:00:40.590 --> 00:00:44.040
responsible for most
of the resources

00:00:44.040 --> 00:00:47.190
that you'll find on the Actions
on Google public website,

00:00:47.190 --> 00:00:50.910
where we show developers
how they can design, build,

00:00:50.910 --> 00:00:53.284
and deploy their apps
for the Google Assistant.

00:00:53.284 --> 00:00:55.450
LEON NICHOLLS: Now, you can
implement the techniques

00:00:55.450 --> 00:00:57.300
we will show you
today using tools

00:00:57.300 --> 00:01:00.780
like API.AI through-- for
fulfillment logic in your code,

00:01:00.780 --> 00:01:02.730
or as a combination of those.

00:01:02.730 --> 00:01:06.090
By the way, API.AI is a
tool for creating apps

00:01:06.090 --> 00:01:07.991
for the Google Assistant.

00:01:10.700 --> 00:01:13.760
Now, we want to help
developers create

00:01:13.760 --> 00:01:16.760
great conversational
experiences.

00:01:16.760 --> 00:01:21.410
The best way to do that is by
considering the design first

00:01:21.410 --> 00:01:24.020
and working in tight
collaboration between designers

00:01:24.020 --> 00:01:28.070
and developers, I trade on that
design within the capabilities

00:01:28.070 --> 00:01:30.050
of the platform.

00:01:30.050 --> 00:01:32.540
NANDINI STOCKER: Now, in
human-to-human conversations,

00:01:32.540 --> 00:01:35.572
hesitations and corrections
happen all the time.

00:01:35.572 --> 00:01:37.280
We just did a little
bit of it ourselves.

00:01:37.280 --> 00:01:37.820
LEON NICHOLLS: Yeah, right.

00:01:37.820 --> 00:01:39.403
NANDINI STOCKER: We
might do it again,

00:01:39.403 --> 00:01:40.971
and we'll just blame
it on the talk.

00:01:40.971 --> 00:01:43.220
LEON NICHOLLS: Now, in
human-to-computer interactions,

00:01:43.220 --> 00:01:44.390
they do too.

00:01:44.390 --> 00:01:47.784
But in the form of timeouts
and recognition errors.

00:01:47.784 --> 00:01:49.200
NANDINI STOCKER:
The difference is

00:01:49.200 --> 00:01:51.920
that humans can take
cues from each other

00:01:51.920 --> 00:01:55.130
to get back on
track in real time.

00:01:55.130 --> 00:01:57.710
LEON NICHOLLS: But with
a simulated conversation,

00:01:57.710 --> 00:01:59.990
the corrections need
to be pre-planned,

00:01:59.990 --> 00:02:01.950
and that's not an easy task.

00:02:01.950 --> 00:02:04.850
NANDINI STOCKER: So the only
way to course correct in advance

00:02:04.850 --> 00:02:09.530
and still maintain a natural,
comfortable dialogue is

00:02:09.530 --> 00:02:11.930
to plan for them as if
they were any other turn

00:02:11.930 --> 00:02:14.635
in the conversation.

00:02:14.635 --> 00:02:16.010
LEON NICHOLLS:
Now, here are some

00:02:16.010 --> 00:02:18.320
of the terms we use when
talking about errors

00:02:18.320 --> 00:02:21.014
in voice interfaces.

00:02:21.014 --> 00:02:23.180
NANDINI STOCKER: One of the
first things to remember

00:02:23.180 --> 00:02:25.640
is that there's a
difference between

00:02:25.640 --> 00:02:29.540
the technical conditions and
events that trigger and respond

00:02:29.540 --> 00:02:33.530
to these errors and all
the user scenarios that

00:02:33.530 --> 00:02:35.900
are happening at the same time.

00:02:35.900 --> 00:02:37.670
So any number of
things could go wrong

00:02:37.670 --> 00:02:40.250
from the user's perspective,
so for any number of reasons.

00:02:42.744 --> 00:02:44.160
LEON NICHOLLS:
Now, we'll show you

00:02:44.160 --> 00:02:46.890
how keeping both of these
perspectives in mind

00:02:46.890 --> 00:02:49.755
will be really key to your
conversation repair strategy.

00:02:52.525 --> 00:02:54.150
NANDINI STOCKER:
Otherwise, it's pretty

00:02:54.150 --> 00:02:56.700
easy to become
either too simplistic

00:02:56.700 --> 00:02:59.790
or with a basic strategy of
just apologizing and asking

00:02:59.790 --> 00:03:02.040
the same question
over and over again,

00:03:02.040 --> 00:03:05.610
or being overly prescriptive
and formulaic in your approach.

00:03:08.150 --> 00:03:11.750
LEON NICHOLLS: Now, for
example, here's a formula that's

00:03:11.750 --> 00:03:14.330
really common, and
often both into a lot

00:03:14.330 --> 00:03:16.774
of tools and defaults.

00:03:16.774 --> 00:03:19.190
NANDINI STOCKER: But this often
translates, unfortunately,

00:03:19.190 --> 00:03:21.680
into a user having to
be asked, effectively,

00:03:21.680 --> 00:03:24.140
for the same piece
of information,

00:03:24.140 --> 00:03:30.340
with very little variation
3, 4, 5, or even 6 times.

00:03:30.340 --> 00:03:33.490
LEON NICHOLLS: So that leads
to a really stiff experience,

00:03:33.490 --> 00:03:35.677
but also a very
frustrating one for users.

00:03:35.677 --> 00:03:37.510
NANDINI STOCKER: It's
important to note also

00:03:37.510 --> 00:03:39.670
that user impressions
on how they're

00:03:39.670 --> 00:03:42.640
formed in that moment when
they're going through an error

00:03:42.640 --> 00:03:45.580
is not just about the
interaction itself

00:03:45.580 --> 00:03:48.640
that they're going through,
it frames how people feel

00:03:48.640 --> 00:03:50.800
as a whole about the
technology, something

00:03:50.800 --> 00:03:54.130
that we really care
about changing.

00:03:54.130 --> 00:03:56.470
So in fact, we've
asked people how

00:03:56.470 --> 00:03:58.900
they feel when
recognition doesn't work,

00:03:58.900 --> 00:04:02.440
and they have negative,
visceral reactions.

00:04:02.440 --> 00:04:04.810
And they can't always place why.

00:04:04.810 --> 00:04:08.280
So one of the reasons is because
people are using their voice.

00:04:08.280 --> 00:04:11.640
Voice is one of the primary
markers of our identity.

00:04:11.640 --> 00:04:17.360
And so it feels extra personal
when something goes wrong.

00:04:17.360 --> 00:04:19.930
So let's dive in and
see how we can handle

00:04:19.930 --> 00:04:22.060
these with a new paradigm.

00:04:22.060 --> 00:04:25.180
LEON NICHOLLS: So we're going
to show you how so-called error

00:04:25.180 --> 00:04:26.860
events could be
handled and treated,

00:04:26.860 --> 00:04:28.594
not treated as its cases.

00:04:28.594 --> 00:04:30.010
NANDINI STOCKER:
So instead, we're

00:04:30.010 --> 00:04:32.740
going to leverage users'
innate expectations

00:04:32.740 --> 00:04:36.190
about how natural conversations
are supposed to work and create

00:04:36.190 --> 00:04:41.020
opportunities for more
meaningful interactions.

00:04:41.020 --> 00:04:45.590
LEON NICHOLLS: So that means for
any given prompt to your user,

00:04:45.590 --> 00:04:47.860
you have to be thinking
of all of the things that

00:04:47.860 --> 00:04:50.457
could go wrong in that moment.

00:04:50.457 --> 00:04:52.540
NANDINI STOCKER: But you
could still break it down

00:04:52.540 --> 00:04:55.360
into two paths to the problem.

00:04:55.360 --> 00:04:58.540
Either you didn't get any
input, and usually that's

00:04:58.540 --> 00:05:00.070
because the user
didn't say anything

00:05:00.070 --> 00:05:03.880
or because they were too quiet
to be picked up by the mic.

00:05:03.880 --> 00:05:06.730
Or it could be
that you got input,

00:05:06.730 --> 00:05:08.680
but you just weren't
prepared to handle it.

00:05:11.184 --> 00:05:12.850
LEON NICHOLLS: In the
underlying system,

00:05:12.850 --> 00:05:16.570
these two categories can be
addressed as either no inputs

00:05:16.570 --> 00:05:18.460
or no matches.

00:05:18.460 --> 00:05:20.650
NANDINI STOCKER: But as
part of this new paradigm,

00:05:20.650 --> 00:05:23.620
we're not going to start there.

00:05:23.620 --> 00:05:25.990
It pays to look at
how you can eliminate

00:05:25.990 --> 00:05:28.900
the bulk of your errors
right off the top

00:05:28.900 --> 00:05:31.630
with some preventative
strategies.

00:05:31.630 --> 00:05:33.340
Now, first of all,
you want to use

00:05:33.340 --> 00:05:36.370
the power of spoken
language to your advantage

00:05:36.370 --> 00:05:38.800
by using well-crafted
intuitive language

00:05:38.800 --> 00:05:41.200
in your prompt structure
and prevent errors

00:05:41.200 --> 00:05:42.830
in the first place.

00:05:42.830 --> 00:05:45.220
So there's a great talk
tomorrow about this

00:05:45.220 --> 00:05:47.680
by the godfather of
voice-user interface design

00:05:47.680 --> 00:05:52.480
James Giangola, must not miss.

00:05:52.480 --> 00:05:55.270
LEON NICHOLLS: Otherwise, look
at how you can prevent errors

00:05:55.270 --> 00:05:58.630
by being prepared to handle
specific types of requests,

00:05:58.630 --> 00:06:02.306
but with more robust strategies.

00:06:02.306 --> 00:06:03.430
NANDINI STOCKER: All right.

00:06:03.430 --> 00:06:06.060
So your first
preventative strategy.

00:06:06.060 --> 00:06:09.360
Be ready to provide
help in the moment.

00:06:09.360 --> 00:06:11.450
So this usually means
being ready for--

00:06:11.450 --> 00:06:13.910
to handle if someone asks
to hear something again,

00:06:13.910 --> 00:06:16.760
or they express their
confusion maybe more

00:06:16.760 --> 00:06:19.190
explicitly by saying
something like, I'm not sure,

00:06:19.190 --> 00:06:21.020
or why do you want to know?

00:06:21.020 --> 00:06:23.700
So let's look at how
we implement that.

00:06:23.700 --> 00:06:26.320
Oh, I--

00:06:26.320 --> 00:06:29.140
LEON NICHOLLS: So we need to
be able to first categorize

00:06:29.140 --> 00:06:34.120
these responses, and then
add logic to handle them.

00:06:34.120 --> 00:06:36.730
Some of the main
concepts in API.AI

00:06:36.730 --> 00:06:40.090
include agents, which can be
described as natural language

00:06:40.090 --> 00:06:42.460
understanding modules for apps.

00:06:42.460 --> 00:06:46.330
Agents consist of intents,
which respond to particular user

00:06:46.330 --> 00:06:49.390
inputs, and context,
which are the ways

00:06:49.390 --> 00:06:52.120
to prioritize those
intents as they are

00:06:52.120 --> 00:06:54.112
invoked during a conversation.

00:06:54.112 --> 00:06:55.570
NANDINI STOCKER:
So during the many

00:06:55.570 --> 00:06:57.790
back and forth turns
in your conversation,

00:06:57.790 --> 00:07:01.210
each of the user responses
will map to an intent.

00:07:01.210 --> 00:07:02.920
So like you see
here, a few key ones

00:07:02.920 --> 00:07:04.490
are repeat, help, and quit.

00:07:07.010 --> 00:07:09.560
LEON NICHOLLS: So here's a help
intent we created in API.AI.

00:07:11.981 --> 00:07:14.480
NANDINI STOCKER: Notice how
it's not just the global command

00:07:14.480 --> 00:07:14.840
help.

00:07:14.840 --> 00:07:16.610
That's not the only
thing we're handling.

00:07:16.610 --> 00:07:19.760
All the things a user
might say to ask for help.

00:07:19.760 --> 00:07:21.316
How you respond to
those, of course,

00:07:21.316 --> 00:07:22.940
will depend on your
strategy, and we'll

00:07:22.940 --> 00:07:24.315
show you a little
bit about that.

00:07:24.315 --> 00:07:26.090
But perhaps you
give them a hint,

00:07:26.090 --> 00:07:28.294
or you might ask them a
follow-up question to make

00:07:28.294 --> 00:07:29.585
sure they're ready to continue.

00:07:33.150 --> 00:07:34.630
LEON NICHOLLS: To
make that work,

00:07:34.630 --> 00:07:37.290
we have to add additional
intents for the user's

00:07:37.290 --> 00:07:41.585
yes-no responses to that help
prompt, like you see here.

00:07:41.585 --> 00:07:44.610
NANDINI STOCKER: So
OK, next immediately I

00:07:44.610 --> 00:07:46.320
want to jump in
and find out, how

00:07:46.320 --> 00:07:48.660
do I make it even more
relevant in that moment?

00:07:48.660 --> 00:07:50.580
Maybe by playing
some dynamic data,

00:07:50.580 --> 00:07:53.370
like if I want to include
a variable, for example.

00:07:53.370 --> 00:07:54.210
LEON NICHOLLS: Sure.

00:07:54.210 --> 00:07:56.787
So you can do that
using fulfillment.

00:07:56.787 --> 00:07:57.870
NANDINI STOCKER: So great.

00:07:57.870 --> 00:08:00.160
So as you can see,
in this example

00:08:00.160 --> 00:08:02.580
is some dynamic info
about the game length

00:08:02.580 --> 00:08:07.090
ends the question with asking
if the user wants to continue.

00:08:07.090 --> 00:08:10.800
So now they're actually
listening for a yes-no answer

00:08:10.800 --> 00:08:13.320
to the help question itself.

00:08:13.320 --> 00:08:14.490
LEON NICHOLLS: Yes.

00:08:14.490 --> 00:08:16.680
And we can dynamically
set a context

00:08:16.680 --> 00:08:19.530
to ensure that the user's
yes-no response is handled

00:08:19.530 --> 00:08:21.830
by the yes-no help intents.

00:08:21.830 --> 00:08:24.450
NANDINI STOCKER: But-- so
if the user got the help

00:08:24.450 --> 00:08:26.160
they needed when
they heard that,

00:08:26.160 --> 00:08:28.350
and they didn't say yes
or no, but they just

00:08:28.350 --> 00:08:32.010
answered the original question
before they asked for help.

00:08:32.010 --> 00:08:34.659
So we wouldn't want that
to trigger an error.

00:08:34.659 --> 00:08:36.929
Otherwise, we've sort
of defeated the purpose

00:08:36.929 --> 00:08:37.590
to begin with.

00:08:37.590 --> 00:08:38.715
LEON NICHOLLS: Yeah, right.

00:08:38.715 --> 00:08:41.100
So we don't have to worry
about that since the other game

00:08:41.100 --> 00:08:45.817
intents are still available, and
we'll handle it if that happens

00:08:45.817 --> 00:08:46.650
NANDINI STOCKER: OK.

00:08:46.650 --> 00:08:48.630
So that's Help, and
some of the questions

00:08:48.630 --> 00:08:50.510
that come up in the
moment like repeat.

00:08:50.510 --> 00:08:54.720
So it's a pretty big prevention
strategy out of the way.

00:08:54.720 --> 00:08:59.010
Another very basic strategy
is to prevent frustrating

00:08:59.010 --> 00:09:03.090
back and forth is to simply
make it easy for users to leave.

00:09:03.090 --> 00:09:06.930
So they might need to stop
for a variety of reasons.

00:09:06.930 --> 00:09:08.850
So being prepared
for that is not

00:09:08.850 --> 00:09:12.946
only key to preventing errors,
but it's the right thing to do.

00:09:12.946 --> 00:09:14.820
LEON NICHOLLS: Also, it
can be an opportunity

00:09:14.820 --> 00:09:16.110
for reengagement.

00:09:16.110 --> 00:09:18.570
For example, perhaps
let them know

00:09:18.570 --> 00:09:21.720
how to come back, or pick
up where they left off,

00:09:21.720 --> 00:09:22.980
if that's an option.

00:09:22.980 --> 00:09:26.340
But without being annoying.

00:09:26.340 --> 00:09:27.930
NANDINI STOCKER: So we need to--

00:09:27.930 --> 00:09:31.010
for this, we need to create
another intent for quit, right?

00:09:31.010 --> 00:09:34.740
LEON NICHOLLS: Yeah, so start
by anticipating all the ways

00:09:34.740 --> 00:09:36.450
the user might want to leave.

00:09:36.450 --> 00:09:39.390
So just like Help, which
phrases you might choose

00:09:39.390 --> 00:09:41.170
depend on the context.

00:09:41.170 --> 00:09:43.200
NANDINI STOCKER: So for
this game example here,

00:09:43.200 --> 00:09:45.630
you can see we've added
some custom phrases that

00:09:45.630 --> 00:09:47.340
are appropriate for
a game, like "stop

00:09:47.340 --> 00:09:50.340
the game," or "stop playing."

00:09:50.340 --> 00:09:53.160
And just like Help, we
want to make the response

00:09:53.160 --> 00:09:55.830
to user more meaningful,
and since it is a game,

00:09:55.830 --> 00:09:57.360
I want to give them
the satisfaction

00:09:57.360 --> 00:10:00.402
of knowing their score
where they've left off.

00:10:00.402 --> 00:10:02.610
LEON NICHOLLS: Yeah, so like
we showed you with Help,

00:10:02.610 --> 00:10:04.318
if you want to include
a variable, that's

00:10:04.318 --> 00:10:05.770
where fulfillment comes in.

00:10:05.770 --> 00:10:08.530
And so here you can
see our quit intent,

00:10:08.530 --> 00:10:12.995
and we're giving the user the
score before saying goodbye.

00:10:12.995 --> 00:10:14.620
NANDINI STOCKER: So
to give you an idea

00:10:14.620 --> 00:10:17.340
of just how these
prevention strategies are

00:10:17.340 --> 00:10:20.640
so critical to catching
things in context

00:10:20.640 --> 00:10:23.460
and why that matters so
much is take a couple user

00:10:23.460 --> 00:10:26.220
responses that really
mean something different

00:10:26.220 --> 00:10:28.750
depending on the situation.

00:10:28.750 --> 00:10:32.430
Take for example, I
don't know and I give up.

00:10:32.430 --> 00:10:34.920
So in most contexts,
I don't know means--

00:10:34.920 --> 00:10:37.110
it's just another
way of saying help.

00:10:37.110 --> 00:10:40.180
But if you're playing a game,
that may or may not hold true.

00:10:40.180 --> 00:10:42.330
So for example, on
the one hand, you

00:10:42.330 --> 00:10:44.280
could have a game
where the user maybe

00:10:44.280 --> 00:10:46.140
wants to know a little
more about the rules,

00:10:46.140 --> 00:10:48.190
and they're not
familiar with it.

00:10:48.190 --> 00:10:51.660
So in that case, sure, "I
don't know" means help,

00:10:51.660 --> 00:10:53.370
like any other context.

00:10:53.370 --> 00:10:55.770
But if it's a
familiar mental model,

00:10:55.770 --> 00:10:59.880
like guessing game or
trivia, where the user says,

00:10:59.880 --> 00:11:02.250
I don't know, or I
give up, it might just

00:11:02.250 --> 00:11:05.080
mean they want the answer
so they can move on.

00:11:05.080 --> 00:11:08.940
So in which case, it's
literally the opposite of quit.

00:11:08.940 --> 00:11:12.510
It means, let's keep playing.

00:11:12.510 --> 00:11:15.040
LEON NICHOLLS: Now, this might
mean breaking up your help

00:11:15.040 --> 00:11:18.270
or I don't know phrases
into different contexts.

00:11:18.270 --> 00:11:19.920
Take two games we've
been working on.

00:11:19.920 --> 00:11:24.060
In our number guessing game,
Number Genie, here on the left,

00:11:24.060 --> 00:11:27.060
I give up is part
of the quit intent.

00:11:27.060 --> 00:11:29.430
But with the trivia
game on the right,

00:11:29.430 --> 00:11:32.540
I give up is part of
the I don't know intent.

00:11:32.540 --> 00:11:36.135
This lets the user skip giving
an answer to the question.

00:11:36.135 --> 00:11:37.260
NANDINI STOCKER: All right.

00:11:37.260 --> 00:11:38.970
So another way--

00:11:38.970 --> 00:11:40.646
LEON NICHOLLS: Oops.

00:11:40.646 --> 00:11:42.270
NANDINI STOCKER:
Another way to prevent

00:11:42.270 --> 00:11:45.810
errors is to use the built-in
capabilities of the platform.

00:11:45.810 --> 00:11:49.932
So we've just announced
several of these at I/O.

00:11:49.932 --> 00:11:51.640
LEON NICHOLLS: So our
tools and libraries

00:11:51.640 --> 00:11:55.300
support common needed actions
called Conversation Helpers.

00:11:55.300 --> 00:11:58.450
Now, these have been crafted to
follow best design practices,

00:11:58.450 --> 00:12:00.490
and also to handle errors.

00:12:00.490 --> 00:12:02.340
So we recommend
that you use these

00:12:02.340 --> 00:12:05.885
so you don't have to
create them for yourself.

00:12:05.885 --> 00:12:07.010
NANDINI STOCKER: All right.

00:12:07.010 --> 00:12:09.200
So that's a lot of
deceptively simple,

00:12:09.200 --> 00:12:12.320
but often overlooked error
prevention strategies.

00:12:12.320 --> 00:12:14.660
Those should help your
users feel more in control

00:12:14.660 --> 00:12:16.310
of the interaction overall.

00:12:16.310 --> 00:12:19.129
Now let's get to the
unavoidable stuff.

00:12:19.129 --> 00:12:20.670
LEON NICHOLLS: So
as we said earlier,

00:12:20.670 --> 00:12:24.320
even in conversations between
humans, hesitations and repair

00:12:24.320 --> 00:12:25.410
happen.

00:12:25.410 --> 00:12:29.360
And as we know, speech
recognition isn't perfect.

00:12:29.360 --> 00:12:32.494
So when it doesn't work, let's
call those errors for now.

00:12:32.494 --> 00:12:34.910
NANDINI STOCKER: So we've got
a couple of great strategies

00:12:34.910 --> 00:12:36.410
coming up where
we-- it'll make them

00:12:36.410 --> 00:12:40.010
feel a little less like errors
per se, and more like new turns

00:12:40.010 --> 00:12:41.780
in the dialog, like
we've been promising.

00:12:41.780 --> 00:12:43.370
But before we show
you that, we think

00:12:43.370 --> 00:12:47.149
it is important to see what it
looks like when you do start

00:12:47.149 --> 00:12:47.690
from scratch.

00:12:50.260 --> 00:12:52.960
LEON NICHOLLS: We'll look at
our basic errors, the no inputs

00:12:52.960 --> 00:12:53.920
and no matches.

00:12:56.560 --> 00:12:59.080
If you create a new
agent in API.AI,

00:12:59.080 --> 00:13:02.620
you get two default intents
as a starting point.

00:13:02.620 --> 00:13:05.140
The agent will start by
greeting you with the default

00:13:05.140 --> 00:13:08.350
welcome intent, and if
you don't say anything,

00:13:08.350 --> 00:13:11.710
it'll hit a couple of
no inputs and give up.

00:13:11.710 --> 00:13:15.400
If you do respond,
you'll hit a no match.

00:13:15.400 --> 00:13:16.990
NANDINI STOCKER:
So you're saying

00:13:16.990 --> 00:13:18.970
that starting from
scratch, we have

00:13:18.970 --> 00:13:22.270
a clean slate of only errors.

00:13:22.270 --> 00:13:23.770
LEON NICHOLLS: Yeah.

00:13:23.770 --> 00:13:26.050
So let's take a look
at how the default

00:13:26.050 --> 00:13:28.840
agent handles no inputs.

00:13:28.840 --> 00:13:31.510
We're going to play a video
of me invoking the agent

00:13:31.510 --> 00:13:32.680
on a Google Home, and--

00:13:32.680 --> 00:13:32.882
[VIDEO PLAYBACK]

00:13:32.882 --> 00:13:33.370
- Sure, here is--

00:13:33.370 --> 00:13:34.057
LEON NICHOLLS: --not
saying anything.

00:13:34.057 --> 00:13:36.320
- --the test version
of default action.

00:13:36.320 --> 00:13:38.967
- Hi.

00:13:38.967 --> 00:13:40.800
- I couldn't hear
what you've just said.

00:13:40.800 --> 00:13:41.300
- Hi.

00:13:44.845 --> 00:13:46.571
- I couldn't hear
what you've just said.

00:13:46.571 --> 00:13:47.070
- Hi.

00:13:50.755 --> 00:13:53.584
- Sorry, I can't help.

00:13:53.584 --> 00:13:54.440
[END PLAYBACK]

00:13:54.440 --> 00:13:56.960
NANDINI STOCKER:
And for no matches?

00:13:56.960 --> 00:13:59.160
LEON NICHOLLS: For no
matches, well, that

00:13:59.160 --> 00:14:01.970
would invoke the default
fallback intent, which

00:14:01.970 --> 00:14:05.960
has a set of static responses
that are selected randomly

00:14:05.960 --> 00:14:07.970
to respond to the user.

00:14:07.970 --> 00:14:10.400
NANDINI STOCKER: So
anything the user says

00:14:10.400 --> 00:14:12.800
will go to the default
fallback intent.

00:14:12.800 --> 00:14:14.810
So let's take a look at that.

00:14:14.810 --> 00:14:15.560
LEON NICHOLLS: OK.

00:14:15.560 --> 00:14:16.190
Let's do that.

00:14:16.190 --> 00:14:20.654
So we have another video, and
that force-invoking agent.

00:14:20.654 --> 00:14:21.320
[VIDEO PLAYBACK]

00:14:21.320 --> 00:14:24.400
- Go to default action.

00:14:24.400 --> 00:14:24.900
- Sure.

00:14:24.900 --> 00:14:28.140
Here is the test version
of default action.

00:14:28.140 --> 00:14:29.220
- Hello.

00:14:29.220 --> 00:14:31.485
- Hi.

00:14:31.485 --> 00:14:32.730
- I missed what you said.

00:14:32.730 --> 00:14:33.960
Say it again.

00:14:33.960 --> 00:14:34.845
- I said, "Hi."

00:14:37.321 --> 00:14:37.820
- Sorry.

00:14:37.820 --> 00:14:38.861
Could you say that again?

00:14:38.861 --> 00:14:41.140
[ELEPHANT NOISE]

00:14:43.060 --> 00:14:44.910
I didn't get that.

00:14:44.910 --> 00:14:48.269
- I'm trying to greet you.

00:14:48.269 --> 00:14:49.310
- Can you say that again?

00:14:49.310 --> 00:14:51.730
[DOG BARKING]

00:14:54.640 --> 00:14:56.180
What was that?

00:14:56.180 --> 00:14:57.935
- Hmm, I said, "Hi."

00:15:01.300 --> 00:15:02.376
- I didn't get that.

00:15:02.376 --> 00:15:03.250
Can you say it again?

00:15:03.250 --> 00:15:06.172
[CAT MEOWING]

00:15:09.100 --> 00:15:11.800
What was that?

00:15:11.800 --> 00:15:15.240
- Why do I have
to repeat myself?

00:15:15.240 --> 00:15:17.870
- Sorry, what was that?

00:15:17.870 --> 00:15:18.840
- OK.

00:15:18.840 --> 00:15:20.560
Goodbye.

00:15:20.560 --> 00:15:21.480
[END PLAYBACK]

00:15:21.480 --> 00:15:22.800
LEON NICHOLLS: OK.

00:15:22.800 --> 00:15:25.780
So as you see, the
conversation never ends.

00:15:25.780 --> 00:15:27.670
And if you want to
change that, you

00:15:27.670 --> 00:15:30.874
have to add a custom intent to
handle the first user response.

00:15:30.874 --> 00:15:32.290
NANDINI STOCKER:
Obviously, that's

00:15:32.290 --> 00:15:34.390
no way to hold a
conversation, and we

00:15:34.390 --> 00:15:37.400
do have a lot of built-ins
that you can add.

00:15:37.400 --> 00:15:39.940
But it's important
to start from that

00:15:39.940 --> 00:15:42.950
just to see how it works if
you were to start from scratch,

00:15:42.950 --> 00:15:45.820
so that all of the things that
we show you next will start--

00:15:45.820 --> 00:15:47.630
will make sense and connect.

00:15:47.630 --> 00:15:50.500
LEON NICHOLLS: Otherwise, API.AI
does provide some sample data

00:15:50.500 --> 00:15:53.680
and pre-built agents
for common use cases

00:15:53.680 --> 00:15:55.840
that you could
start with instead.

00:15:55.840 --> 00:15:59.290
And we're always looking at
ways to improve the tools better

00:15:59.290 --> 00:16:00.140
by default.

00:16:00.140 --> 00:16:01.640
NANDINI STOCKER:
So in the meantime,

00:16:01.640 --> 00:16:03.400
we'll use that as a
baseline and explore

00:16:03.400 --> 00:16:05.150
some more targeted solutions.

00:16:05.150 --> 00:16:05.900
LEON NICHOLLS: OK.

00:16:08.880 --> 00:16:11.855
Now let's take the case of
when no input is triggered.

00:16:11.855 --> 00:16:13.230
NANDINI STOCKER:
So here remember

00:16:13.230 --> 00:16:16.050
that the user either
actually didn't say anything,

00:16:16.050 --> 00:16:19.050
or perhaps they got
distracted, or they

00:16:19.050 --> 00:16:20.292
didn't hear the question.

00:16:20.292 --> 00:16:22.500
Maybe they were listening,
they didn't understand it,

00:16:22.500 --> 00:16:24.960
and they're just waiting to
hear what it would do next.

00:16:24.960 --> 00:16:27.120
But it could also
be that they started

00:16:27.120 --> 00:16:30.270
talking during the prompt and
then stopped talking right

00:16:30.270 --> 00:16:34.500
when the mic started listening.

00:16:34.500 --> 00:16:36.990
LEON NICHOLLS: So how
do we design for that?

00:16:36.990 --> 00:16:38.700
NANDINI STOCKER:
Well, for no inputs,

00:16:38.700 --> 00:16:41.640
you probably need
to consider first

00:16:41.640 --> 00:16:45.160
if you even need the answer
to get to the next step.

00:16:45.160 --> 00:16:48.750
So how you react
should really consider

00:16:48.750 --> 00:16:52.560
why the user didn't respond, all
those reasons I talked about.

00:16:52.560 --> 00:16:55.920
So it's a new turn in
the dialog, therefore

00:16:55.920 --> 00:16:56.820
an opportunity.

00:16:59.322 --> 00:17:01.030
LEON NICHOLLS: Now,
we have some examples

00:17:01.030 --> 00:17:03.610
that show the difference
it makes to your wording,

00:17:03.610 --> 00:17:06.460
depending on how
hard you want to try

00:17:06.460 --> 00:17:11.079
and how much help you
assume the user needs.

00:17:11.079 --> 00:17:14.140
NANDINI STOCKER: So when you
write reprompts for no input,

00:17:14.140 --> 00:17:16.480
you should keep
them contextually.

00:17:16.480 --> 00:17:18.099
But that doesn't
necessarily mean

00:17:18.099 --> 00:17:21.380
repeating the exact
same question verbatim.

00:17:21.380 --> 00:17:23.319
So maybe you just
need to reframe it

00:17:23.319 --> 00:17:25.630
or reword it just slightly.

00:17:25.630 --> 00:17:28.450
Or maybe you could use
that as an opportunity

00:17:28.450 --> 00:17:30.235
to answer an unasked question.

00:17:33.050 --> 00:17:36.350
And as far as--

00:17:36.350 --> 00:17:39.340
and as for how many
times you want to try,

00:17:39.340 --> 00:17:41.230
maybe you don't
want to belabor it,

00:17:41.230 --> 00:17:43.960
and maybe you just want
to gracefully exit.

00:17:43.960 --> 00:17:46.210
But for most cases,
you could make

00:17:46.210 --> 00:17:49.120
use of some sort
of default pattern.

00:17:49.120 --> 00:17:54.460
Right now the default is three,
but maybe it might change.

00:17:54.460 --> 00:17:57.730
And find out-- just
specify what you want it

00:17:57.730 --> 00:17:59.570
to say for each of those three.

00:17:59.570 --> 00:18:02.570
So that's a design
strategy for no inputs.

00:18:02.570 --> 00:18:05.530
Let's look at-- let's take
a look at how to implement.

00:18:05.530 --> 00:18:06.280
LEON NICHOLLS: OK.

00:18:06.280 --> 00:18:09.700
So as I mentioned earlier,
the default API.AI--

00:18:09.700 --> 00:18:12.790
by default, API.AI handles
the no inputs for you

00:18:12.790 --> 00:18:14.980
by using a list of
standard prompts.

00:18:14.980 --> 00:18:18.940
Now, to change these prompts
to be domain specific,

00:18:18.940 --> 00:18:21.580
you need to implement your
own fulfillment logic.

00:18:21.580 --> 00:18:24.490
Now, as part of our SDK
for developing actions,

00:18:24.490 --> 00:18:27.250
we provide a Node.js
client library

00:18:27.250 --> 00:18:31.000
that makes it really
easy to do that.

00:18:31.000 --> 00:18:34.090
The client library API lets you
specify the no input prompts,

00:18:34.090 --> 00:18:36.170
like these, I didn't
hear a number.

00:18:36.170 --> 00:18:37.110
Are you still there?

00:18:37.110 --> 00:18:38.267
What's your guess?

00:18:38.267 --> 00:18:40.600
NANDINI STOCKER: And the
conversation automatically ends

00:18:40.600 --> 00:18:42.610
after that third, final prompt.

00:18:42.610 --> 00:18:44.680
So for example,
we can stop here.

00:18:44.680 --> 00:18:45.700
Let's play again soon.

00:18:45.700 --> 00:18:46.825
That's how we're ending it.

00:18:50.400 --> 00:18:53.250
Now let's look at the biggest
opportunity for creative error

00:18:53.250 --> 00:18:56.259
handling, no matches.

00:18:56.259 --> 00:18:58.050
LEON NICHOLLS: So just
like with no inputs,

00:18:58.050 --> 00:18:59.990
deciding whether
you use the default

00:18:59.990 --> 00:19:04.010
fallback for your no matches
or something more targeted

00:19:04.010 --> 00:19:06.200
should be based on the
kind interactions you're

00:19:06.200 --> 00:19:07.577
designing for.

00:19:07.577 --> 00:19:09.410
NANDINI STOCKER: Again,
you need to consider

00:19:09.410 --> 00:19:11.180
if the answer is even needed.

00:19:11.180 --> 00:19:13.460
And if it is, you
have to consider

00:19:13.460 --> 00:19:18.630
the user's situation and even
the sequence of questions.

00:19:18.630 --> 00:19:20.930
And if you don't need
it, that's where you also

00:19:20.930 --> 00:19:24.414
might decide to just move
on, pivot, or gracefully end.

00:19:24.414 --> 00:19:26.580
LEON NICHOLLS: So that seems
like a lot to consider,

00:19:26.580 --> 00:19:29.407
so where do we start?

00:19:29.407 --> 00:19:31.240
NANDINI STOCKER: So
during any conversation,

00:19:31.240 --> 00:19:32.948
it's important to stop
and look at what's

00:19:32.948 --> 00:19:34.130
happening in each turn.

00:19:34.130 --> 00:19:37.220
So usually, in one
turn in the dialog,

00:19:37.220 --> 00:19:40.010
one participant is usually
the owner of the information

00:19:40.010 --> 00:19:41.870
that the other
person is seeking.

00:19:41.870 --> 00:19:44.090
So depending on the
context of the question

00:19:44.090 --> 00:19:46.880
and which side of
the conversation

00:19:46.880 --> 00:19:49.310
has that information,
the strategy will vary.

00:19:49.310 --> 00:19:53.270
So let me show you three
examples of why this matters.

00:19:53.270 --> 00:19:56.450
In this question, the
app knows the answer,

00:19:56.450 --> 00:19:58.430
and the user is guessing.

00:19:58.430 --> 00:20:01.410
But they do have a good mental
model of what's expected,

00:20:01.410 --> 00:20:04.670
so potential errors are
at a pretty low cost.

00:20:04.670 --> 00:20:07.641
If they don't know or they
need help, they're likely--

00:20:07.641 --> 00:20:09.890
it's just that they don't
know how the game is played,

00:20:09.890 --> 00:20:12.664
or maybe they want to know
how many guesses they have,

00:20:12.664 --> 00:20:14.330
or like we said
earlier, maybe they just

00:20:14.330 --> 00:20:17.910
want to give up and
have you tell them.

00:20:17.910 --> 00:20:23.350
But take this question for
a reservation exchange.

00:20:23.350 --> 00:20:26.930
Here, only the user
knows the actual answer.

00:20:26.930 --> 00:20:28.730
But you can make some
logic assumptions,

00:20:28.730 --> 00:20:30.532
like expecting a certain range.

00:20:30.532 --> 00:20:32.240
And most of the time,
the answer you know

00:20:32.240 --> 00:20:35.220
will probably be something
like 20 or fewer people.

00:20:35.220 --> 00:20:38.240
So if the user needs help
or says, I don't know,

00:20:38.240 --> 00:20:40.620
then the strategy you
can use depends, again,

00:20:40.620 --> 00:20:45.060
on how critical that answer is
to continue to the next step.

00:20:45.060 --> 00:20:48.530
So take a third example
where both sides are trying

00:20:48.530 --> 00:20:50.420
to match on shared knowledge.

00:20:50.420 --> 00:20:53.570
Well, both sides are supposed
to know the answer, anyway.

00:20:53.570 --> 00:20:55.340
But especially in
this type of scenario

00:20:55.340 --> 00:20:58.820
where it's likely some sort
of gate-keeping mechanism,

00:20:58.820 --> 00:21:00.560
the user may or
may not know what

00:21:00.560 --> 00:21:04.340
it is, or they want to know, why
do you need this information?

00:21:04.340 --> 00:21:06.050
Why are you even asking me this?

00:21:06.050 --> 00:21:08.180
And so for those
types of situations,

00:21:08.180 --> 00:21:14.090
they're much more likely to need
in-context help to continue.

00:21:14.090 --> 00:21:16.460
LEON NICHOLLS: So a
good strategy here

00:21:16.460 --> 00:21:18.480
is to consider it
context by context

00:21:18.480 --> 00:21:21.839
and offer up what might be
more useful in that moment.

00:21:21.839 --> 00:21:22.880
NANDINI STOCKER: Exactly.

00:21:22.880 --> 00:21:25.580
So whatever is
most likely to keep

00:21:25.580 --> 00:21:28.940
the conversation moving
forward is what you would use

00:21:28.940 --> 00:21:31.460
to decide on how to reprompt.

00:21:31.460 --> 00:21:34.640
LEON NICHOLLS: So how do
we decide on the wording?

00:21:34.640 --> 00:21:36.892
NANDINI STOCKER: I'm
glad you asked, Leon.

00:21:36.892 --> 00:21:38.600
Well, first of all,
there's nothing wrong

00:21:38.600 --> 00:21:42.230
with having a few generic
fallback messages.

00:21:42.230 --> 00:21:45.260
So we call these
rapid reprompts.

00:21:45.260 --> 00:21:47.619
Users often just need
some sort of quick signal

00:21:47.619 --> 00:21:49.910
to indicate that you didn't
pick up what they-- exactly

00:21:49.910 --> 00:21:51.650
what they said the first time.

00:21:51.650 --> 00:21:54.680
However, this
strategy only works

00:21:54.680 --> 00:21:57.900
if you are listening for the
right things to begin with.

00:21:57.900 --> 00:22:00.320
So if you aren't catching
what they said the first time

00:22:00.320 --> 00:22:03.080
and you don't catch it even
when they repeat themselves,

00:22:03.080 --> 00:22:06.215
you can imagine how that gets
pretty tiresome pretty quickly.

00:22:09.027 --> 00:22:10.610
LEON NICHOLLS: So
you need to consider

00:22:10.610 --> 00:22:13.880
the user's situational context
for each and every question

00:22:13.880 --> 00:22:14.766
carefully.

00:22:14.766 --> 00:22:15.890
NANDINI STOCKER: Of course.

00:22:15.890 --> 00:22:20.090
So it often means asking
maybe another way.

00:22:20.090 --> 00:22:25.190
Sometimes it even means breaking
down the question into parts.

00:22:25.190 --> 00:22:26.810
Maybe even you're
listening for both,

00:22:26.810 --> 00:22:28.640
but you might just
ask for one, just

00:22:28.640 --> 00:22:31.940
to move the
conversation forward.

00:22:31.940 --> 00:22:34.460
Now, depending on how important,
again, the information

00:22:34.460 --> 00:22:38.780
is that you're asking for, you
can also make use of escalating

00:22:38.780 --> 00:22:42.170
detail to let users in on,
what is it you need from them,

00:22:42.170 --> 00:22:44.240
and why are you
asking, again, to keep

00:22:44.240 --> 00:22:48.450
the conversation moving, and
answer that unasked question.

00:22:48.450 --> 00:22:52.040
And finally, depending
on your app's persona

00:22:52.040 --> 00:22:54.620
and how assertive
it is, you may also

00:22:54.620 --> 00:22:57.740
decide to be proactive and
take control of the situation.

00:22:59.562 --> 00:23:01.020
LEON NICHOLLS: So
let's look at how

00:23:01.020 --> 00:23:03.240
you go about implementing
some of these more

00:23:03.240 --> 00:23:04.750
robust strategies.

00:23:04.750 --> 00:23:07.170
First of all, it will require
implementing fulfullment

00:23:07.170 --> 00:23:09.640
for the default fallback intent.

00:23:09.640 --> 00:23:12.660
Now, the fulfillment logic will
then create these responses

00:23:12.660 --> 00:23:16.299
dynamically in code.

00:23:16.299 --> 00:23:18.340
NANDINI STOCKER: The core
implementation strategy

00:23:18.340 --> 00:23:21.910
we recommend is to
track user progress,

00:23:21.910 --> 00:23:25.720
lay out your reprompts,
and like they say, when

00:23:25.720 --> 00:23:29.860
you love something, you've
got to know when to let it go.

00:23:29.860 --> 00:23:32.290
So for the apps that
we've built together,

00:23:32.290 --> 00:23:35.800
our code logic uses counters
and various session variables

00:23:35.800 --> 00:23:39.366
to keep track of
the user's progress.

00:23:39.366 --> 00:23:41.740
LEON NICHOLLS: For example,
here is the fulfillment logic

00:23:41.740 --> 00:23:45.130
for Number Genie where
we use a counter to track

00:23:45.130 --> 00:23:48.250
how many times the user provided
a response that was handled

00:23:48.250 --> 00:23:50.470
by the default fallback intent.

00:23:50.470 --> 00:23:53.830
Now, our client library
for the fulfillment logic

00:23:53.830 --> 00:23:58.802
provides a way to store
data within a user session.

00:23:58.802 --> 00:24:00.760
NANDINI STOCKER: You'll
then use those counters

00:24:00.760 --> 00:24:04.600
to build a dynamic
reprompt strategy,

00:24:04.600 --> 00:24:08.050
using both a combination of
generic fallback sometimes

00:24:08.050 --> 00:24:10.180
and context-sensitive
approaches, like we

00:24:10.180 --> 00:24:13.260
talked about earlier.

00:24:13.260 --> 00:24:16.150
LEON NICHOLLS: Now, in API.AI,
the default fallback intent

00:24:16.150 --> 00:24:20.260
can be a starting point with a
minimum set of basic reprompts.

00:24:20.260 --> 00:24:23.170
Here we have a set of
default rapid reprompts

00:24:23.170 --> 00:24:25.900
that just provide a
catch-all anywhere,

00:24:25.900 --> 00:24:30.370
and we'll reprompt the user
to say their response again.

00:24:30.370 --> 00:24:32.800
NANDINI STOCKER: From there,
you can change those default

00:24:32.800 --> 00:24:34.190
to suit your app.

00:24:34.190 --> 00:24:36.710
So you might just want
to add more to that list,

00:24:36.710 --> 00:24:39.739
and add a few different
rapid reprompts.

00:24:39.739 --> 00:24:41.530
LEON NICHOLLS: The
agent will then randomly

00:24:41.530 --> 00:24:44.320
select from your prompts
whenever a no match

00:24:44.320 --> 00:24:46.750
event is triggered.

00:24:46.750 --> 00:24:48.250
NANDINI STOCKER:
But like we said,

00:24:48.250 --> 00:24:51.302
sometimes you might want to
pivot and ask the question

00:24:51.302 --> 00:24:52.510
a little differently, though.

00:24:52.510 --> 00:24:56.002
So a rapid reprompt
might not be enough.

00:24:56.002 --> 00:24:57.460
LEON NICHOLLS: So
in this instance,

00:24:57.460 --> 00:24:59.860
for example, we
created a game, and we

00:24:59.860 --> 00:25:02.260
wanted to use the
default handler

00:25:02.260 --> 00:25:05.560
to ask a yes-no question,
whether the user was

00:25:05.560 --> 00:25:07.120
done playing.

00:25:07.120 --> 00:25:10.090
It's still generic
and catch-all,

00:25:10.090 --> 00:25:14.820
but we've customized it to
fit the strategy of our game.

00:25:14.820 --> 00:25:17.410
NANDINI STOCKER: But to
get users back on track,

00:25:17.410 --> 00:25:21.890
you actually might want your
reprompt to not be generic.

00:25:21.890 --> 00:25:23.890
So you want to reprompt
with a lot more context,

00:25:23.890 --> 00:25:27.264
like some of those
examples we showed you.

00:25:27.264 --> 00:25:29.180
LEON NICHOLLS: So to
plan for the logic needed

00:25:29.180 --> 00:25:32.420
to implement the
context-sensitive reprompts,

00:25:32.420 --> 00:25:36.650
it really helps to see them
mapped out ahead of time.

00:25:36.650 --> 00:25:40.490
in some user journeys
and sample dialogs first.

00:25:40.490 --> 00:25:43.250
For example, when I walk through
the journeys Nandini wrote

00:25:43.250 --> 00:25:47.600
for Number Genie, they drove
what variables and states

00:25:47.600 --> 00:25:52.490
needed to be tracked in
the app fulfillment logic.

00:25:52.490 --> 00:25:53.930
NANDINI STOCKER:
And each time you

00:25:53.930 --> 00:25:57.440
reprompt, look for opportunities
to add some variability

00:25:57.440 --> 00:25:59.520
or reframe the question.

00:25:59.520 --> 00:26:02.450
So this will lend more
naturalness to the dialog

00:26:02.450 --> 00:26:05.390
and help users sometimes
not even realize they are

00:26:05.390 --> 00:26:06.940
experiencing an error per se.

00:26:09.740 --> 00:26:12.230
LEON NICHOLLS: So to reframe
the question you asked,

00:26:12.230 --> 00:26:15.460
we can use a feature in API.AI
that allows you to tag intents

00:26:15.460 --> 00:26:18.030
with labels called context.

00:26:18.030 --> 00:26:22.870
Here is one that is tagged
with the GetTime context.

00:26:22.870 --> 00:26:25.120
NANDINI STOCKER: And this
is the fulfillment logic

00:26:25.120 --> 00:26:28.740
with the default fallback
intent for the GetTime context

00:26:28.740 --> 00:26:31.940
and what it looks like.

00:26:31.940 --> 00:26:34.750
LEON NICHOLLS: So these can
also be statically assigned

00:26:34.750 --> 00:26:37.480
in API.AI's web GUI
for each intent.

00:26:37.480 --> 00:26:39.610
For example, here's
a list of intents

00:26:39.610 --> 00:26:42.190
we designed for a trivia game.

00:26:42.190 --> 00:26:44.350
Notice all the
expected user responses

00:26:44.350 --> 00:26:48.130
we handle using many different
things intents, including help,

00:26:48.130 --> 00:26:50.760
quit, and restart.

00:26:50.760 --> 00:26:52.510
NANDINI STOCKER: Now,
let's say you wanted

00:26:52.510 --> 00:26:54.700
to combine both strategies.

00:26:54.700 --> 00:26:57.280
We can show you how to
implement both together

00:26:57.280 --> 00:27:01.052
in a more escalating
reprompt strategy.

00:27:01.052 --> 00:27:02.510
LEON NICHOLLS: Now,
from experience

00:27:02.510 --> 00:27:05.270
we know that rapid
reprompts work.

00:27:05.270 --> 00:27:08.330
But we also know, depending
on the user scenario,

00:27:08.330 --> 00:27:11.519
we might want to pivot
off to another error.

00:27:11.519 --> 00:27:14.060
NANDINI STOCKER: So to do that,
you'll need to keep a counter

00:27:14.060 --> 00:27:17.650
and increase it every
time the user response

00:27:17.650 --> 00:27:21.594
is handled by that
fallback intent.

00:27:21.594 --> 00:27:23.510
LEON NICHOLLS: So here's
the fulfillment logic

00:27:23.510 --> 00:27:28.520
for the default fallback
intent for our trivia game.

00:27:28.520 --> 00:27:33.650
Notice how we use a counter that
is stored in the session data.

00:27:33.650 --> 00:27:36.740
NANDINI STOCKER: For the first
time the intent is invoked,

00:27:36.740 --> 00:27:40.130
we provide a rapid reprompt
by using the client

00:27:40.130 --> 00:27:43.020
library ask function.

00:27:43.020 --> 00:27:45.410
And for the second
time, we respond

00:27:45.410 --> 00:27:46.510
with a fallback response.

00:27:49.100 --> 00:27:51.070
LEON NICHOLLS: Now,
obviously, that escalation

00:27:51.070 --> 00:27:52.416
shouldn't go on forever.

00:27:52.416 --> 00:27:54.290
NANDINI STOCKER: When
it comes to no matches,

00:27:54.290 --> 00:27:57.125
know when to give up.

00:27:57.125 --> 00:27:59.500
LEON NICHOLLS: Now, after
you've tried a couple of times,

00:27:59.500 --> 00:28:02.930
once the counter goes
above a threshold,

00:28:02.930 --> 00:28:05.064
bow out of the
conversation gracefully.

00:28:05.064 --> 00:28:06.730
NANDINI STOCKER: Now,
how you word that,

00:28:06.730 --> 00:28:12.202
again, precisely,
depends on your persona.

00:28:12.202 --> 00:28:13.910
LEON NICHOLLS: So back
to the trivia game

00:28:13.910 --> 00:28:16.130
default fallback intent handler.

00:28:16.130 --> 00:28:19.940
When the user response triggers
the intent for the third time,

00:28:19.940 --> 00:28:23.960
we provide a fallback prompt,
and then end the conversation

00:28:23.960 --> 00:28:27.280
by using the client
library tell function.

00:28:27.280 --> 00:28:28.780
NANDINI STOCKER:
However, of course,

00:28:28.780 --> 00:28:30.770
if the conversation
with the user

00:28:30.770 --> 00:28:33.440
recovers and another
intent is invoked,

00:28:33.440 --> 00:28:35.360
like we talked about
earlier, if they actually

00:28:35.360 --> 00:28:40.370
answer the question, then it's
not a default fallback intent.

00:28:40.370 --> 00:28:44.520
Then we reset that
counter value.

00:28:44.520 --> 00:28:46.586
LEON NICHOLLS: Now, those
were just the basics.

00:28:46.586 --> 00:28:47.960
NANDINI STOCKER:
Just the basics.

00:28:47.960 --> 00:28:48.751
LEON NICHOLLS: Yep.

00:28:48.751 --> 00:28:51.270
So from here, you
can find lots of ways

00:28:51.270 --> 00:28:55.301
to step up your conversation
repair game even more.

00:28:55.301 --> 00:28:56.550
NANDINI STOCKER: I feel like--

00:28:56.550 --> 00:28:58.770
yeah-- but wait, there's more.

00:28:58.770 --> 00:29:03.870
So one way is to
inherently disguise errors.

00:29:03.870 --> 00:29:07.680
So by adding naturalness
and variability to make

00:29:07.680 --> 00:29:10.720
the entire conversation
feel more engaging.

00:29:10.720 --> 00:29:12.420
So the key is that
it doesn't just

00:29:12.420 --> 00:29:16.590
apply to your error prompts,
but all the other prompts

00:29:16.590 --> 00:29:17.944
everywhere else.

00:29:17.944 --> 00:29:19.860
LEON NICHOLLS: So this
is one of the many ways

00:29:19.860 --> 00:29:23.370
that designing with a particular
persona in mind for your app

00:29:23.370 --> 00:29:25.214
comes in really handy.

00:29:25.214 --> 00:29:27.380
NANDINI STOCKER: So we keep
hinting at this persona,

00:29:27.380 --> 00:29:30.360
so we'll show you one
example of what we mean.

00:29:30.360 --> 00:29:33.750
So for example, in the trivia
game we've been working on,

00:29:33.750 --> 00:29:35.620
we use a teacher persona.

00:29:35.620 --> 00:29:38.760
His name is Mr.
Montgomery, which

00:29:38.760 --> 00:29:41.130
we-- he would be the
type of character that

00:29:41.130 --> 00:29:44.550
is super encouraging, and
he really wants you-- you

00:29:44.550 --> 00:29:45.230
got this.

00:29:45.230 --> 00:29:49.070
That's his-- you know,
he's a teacher, right?

00:29:49.070 --> 00:29:50.950
LEON NICHOLLS: So
to give you an idea,

00:29:50.950 --> 00:29:55.200
our teacher has over
50 ways of saying,

00:29:55.200 --> 00:29:56.880
you got the answer right.

00:29:56.880 --> 00:29:59.910
NANDINI STOCKER: And over
30 ways to prop you up

00:29:59.910 --> 00:30:00.930
if you got it wrong.

00:30:03.570 --> 00:30:07.560
Also, again, this is
stepping up your game.

00:30:07.560 --> 00:30:09.460
Use threading techniques.

00:30:09.460 --> 00:30:12.360
So in spoken dialogue
between humans,

00:30:12.360 --> 00:30:15.360
elements of a conversation
are woven together

00:30:15.360 --> 00:30:17.490
in a coherent thread.

00:30:17.490 --> 00:30:20.880
And that includes both
context and the way

00:30:20.880 --> 00:30:24.180
the conversation
evolves over time.

00:30:24.180 --> 00:30:26.850
So this type of
threading, it helps

00:30:26.850 --> 00:30:29.814
us keep track of that
conversational flow.

00:30:29.814 --> 00:30:31.230
LEON NICHOLLS:
Now, you would have

00:30:31.230 --> 00:30:34.320
to write the prompts that
thread together well,

00:30:34.320 --> 00:30:36.330
but pragmatically
speaking, you need

00:30:36.330 --> 00:30:40.210
to support that flow in
some underlying framework.

00:30:40.210 --> 00:30:43.410
And that will use tracking,
context, and counters, just

00:30:43.410 --> 00:30:46.440
like we've talked about before.

00:30:46.440 --> 00:30:49.340
NANDINI STOCKER: So to support
variability in threading,

00:30:49.340 --> 00:30:52.457
you could build a robust list
of prompts and randomize them.

00:30:52.457 --> 00:30:55.040
LEON NICHOLLS: And you can scale
that to any number of prompts

00:30:55.040 --> 00:30:56.124
without changing the code.

00:30:56.124 --> 00:30:57.956
NANDINI STOCKER: If you
can randomize three,

00:30:57.956 --> 00:30:59.210
you can randomize 103.

00:30:59.210 --> 00:31:00.530
LEON NICHOLLS: Yep.

00:31:00.530 --> 00:31:02.071
NANDINI STOCKER:
The prompts can also

00:31:02.071 --> 00:31:06.260
be concatenated to create a
large number of permutations.

00:31:06.260 --> 00:31:08.120
LEON NICHOLLS: And you
can add dynamic value

00:31:08.120 --> 00:31:09.950
by formatting your
prompts with variables

00:31:09.950 --> 00:31:11.854
that are replaced at runtime.

00:31:11.854 --> 00:31:13.520
NANDINI STOCKER: And
to prevent the user

00:31:13.520 --> 00:31:16.100
from hearing the same
prompts and sequence,

00:31:16.100 --> 00:31:18.800
you can remember which
prompts you've played,

00:31:18.800 --> 00:31:20.870
and avoid them when
you're randomly

00:31:20.870 --> 00:31:23.631
picking next from the list.

00:31:23.631 --> 00:31:25.880
LEON NICHOLLS: You can also
track the number of errors

00:31:25.880 --> 00:31:29.950
and in what sequence they occur.

00:31:29.950 --> 00:31:33.050
NANDINI STOCKER: Finally,
after you've deployed your app,

00:31:33.050 --> 00:31:36.000
your error-handling
approach doesn't stop there.

00:31:36.000 --> 00:31:38.400
So you should check in with
what your users are doing,

00:31:38.400 --> 00:31:41.490
and you can adjust your
strategy, if needed.

00:31:41.490 --> 00:31:44.160
LEON NICHOLLS: Now, API.AI
provides a training feature,

00:31:44.160 --> 00:31:47.600
which allows you to track
which user responses are not

00:31:47.600 --> 00:31:49.479
being met by intent.

00:31:49.479 --> 00:31:51.770
Now, this feedback could be
used to expand your support

00:31:51.770 --> 00:31:53.210
for the user queries.

00:31:53.210 --> 00:31:56.870
It can also give you hints
on what new intents might

00:31:56.870 --> 00:31:59.810
need to be added to your app.

00:31:59.810 --> 00:32:02.240
NANDINI STOCKER: So
one powerful notion

00:32:02.240 --> 00:32:06.500
to remember is that users who
are not encountering errors

00:32:06.500 --> 00:32:09.650
should feel the benefit
of progressing through,

00:32:09.650 --> 00:32:12.050
so that when an
error is encountered,

00:32:12.050 --> 00:32:13.880
they don't feel derailed.

00:32:13.880 --> 00:32:17.030
So also, it's proven
that reminding

00:32:17.030 --> 00:32:22.250
them how far they've gotten or
that they don't how far to go

00:32:22.250 --> 00:32:24.590
will help them
get back on track.

00:32:24.590 --> 00:32:25.520
OK.

00:32:25.520 --> 00:32:27.680
That's enough
strategies for now.

00:32:27.680 --> 00:32:29.570
Let's look at these in action.

00:32:29.570 --> 00:32:31.160
LEON NICHOLLS: OK.

00:32:31.160 --> 00:32:34.010
So we're going to show you a
demo of Number Genie, which

00:32:34.010 --> 00:32:35.840
we designed and built together.

00:32:35.840 --> 00:32:39.110
And it's available as
a sample on our site.

00:32:41.700 --> 00:32:44.270
NANDINI STOCKER: So we
chose a number guessing game

00:32:44.270 --> 00:32:48.650
because we felt like
you guys as developers,

00:32:48.650 --> 00:32:50.851
you could mentally map
a number guessing game.

00:32:50.851 --> 00:32:52.850
And you can sort of picture
some of the concepts

00:32:52.850 --> 00:32:54.120
we've been talking about.

00:32:54.120 --> 00:32:58.390
So we've built-in a
hidden developer mode.

00:32:58.390 --> 00:32:59.470
This game is public.

00:32:59.470 --> 00:33:01.980
You're welcome to try this out.

00:33:01.980 --> 00:33:03.800
And I'm going to
pray to the demo gods

00:33:03.800 --> 00:33:06.302
that they don't smite me here.

00:33:06.302 --> 00:33:07.760
But there's a hidden
developer mode

00:33:07.760 --> 00:33:12.140
in which we can set the number
that the genie is thinking of.

00:33:12.140 --> 00:33:14.420
And we're going to
guess around it, so

00:33:14.420 --> 00:33:16.365
that you can hear
some of the strategies

00:33:16.365 --> 00:33:17.240
that we talked about.

00:33:17.240 --> 00:33:18.640
All right.

00:33:18.640 --> 00:33:20.036
OK.

00:33:20.036 --> 00:33:22.010
Hey, Google.

00:33:22.010 --> 00:33:24.750
Let's talk to Number
Genie about 21.

00:33:29.464 --> 00:33:30.130
SPEAKER 1: Sure.

00:33:30.130 --> 00:33:32.170
Here's Number Genie.

00:33:32.170 --> 00:33:34.030
SPEAKER 2: Welcome
back to Number Genie.

00:33:34.030 --> 00:33:36.610
I'm thinking of a
number from 0 to 100.

00:33:36.610 --> 00:33:38.430
What's your first guess?

00:33:38.430 --> 00:33:41.100
NANDINI STOCKER: 50.

00:33:41.100 --> 00:33:42.510
SPEAKER 2: It's lower than 50.

00:33:42.510 --> 00:33:43.732
Have another guess.

00:33:43.732 --> 00:33:44.690
NANDINI STOCKER: Uh, 0.

00:33:47.251 --> 00:33:48.750
SPEAKER 2: I see
what you did there.

00:33:48.750 --> 00:33:51.032
But no, it's higher than 0.

00:33:51.032 --> 00:33:51.865
NANDINI STOCKER: 30.

00:33:56.444 --> 00:33:57.860
SPEAKER 2: I didn't
hear a number.

00:33:59.952 --> 00:34:00.785
NANDINI STOCKER: 30.

00:34:03.199 --> 00:34:04.490
SPEAKER 2: You're getting warm.

00:34:04.490 --> 00:34:05.840
It's lower than 30.

00:34:05.840 --> 00:34:07.700
Have another guess.

00:34:07.700 --> 00:34:10.070
NANDINI STOCKER: 17.

00:34:10.070 --> 00:34:12.111
SPEAKER 2: It's so
close, but not quite.

00:34:12.111 --> 00:34:12.944
NANDINI STOCKER: 19.

00:34:15.560 --> 00:34:16.969
SPEAKER 2: It's higher than 19.

00:34:16.969 --> 00:34:18.682
What's your next guess?

00:34:18.682 --> 00:34:19.515
NANDINI STOCKER: 20.

00:34:23.409 --> 00:34:26.530
SPEAKER 2: Are you done
playing Number Genie?

00:34:26.530 --> 00:34:28.462
NANDINI STOCKER: No.

00:34:28.462 --> 00:34:29.170
SPEAKER 2: Great.

00:34:29.170 --> 00:34:31.111
What's your next guess?

00:34:31.111 --> 00:34:31.944
NANDINI STOCKER: 21.

00:34:34.545 --> 00:34:37.323
[CHIMES]

00:34:38.005 --> 00:34:38.880
SPEAKER 2: Well done.

00:34:38.880 --> 00:34:39.380
[APPLAUSE]

00:34:39.380 --> 00:34:40.650
It is indeed 21.

00:34:40.650 --> 00:34:42.935
Want to play again?

00:34:42.935 --> 00:34:44.060
NANDINI STOCKER: No thanks.

00:34:44.060 --> 00:34:44.810
LEON NICHOLLS: OK.

00:34:44.810 --> 00:34:50.429
So now, it's really interesting
to see the interaction.

00:34:50.429 --> 00:34:55.692
But you know, a number guessing
game is deceptively simple.

00:34:55.692 --> 00:34:57.150
If you just think
about it, there's

00:34:57.150 --> 00:34:58.830
comparing a number and a guess.

00:34:58.830 --> 00:35:02.970
But it can be designed to be
delightful by adding layers

00:35:02.970 --> 00:35:05.897
of tracking in the game logic.

00:35:05.897 --> 00:35:08.230
NANDINI STOCKER: So let's
look real quick under the hood

00:35:08.230 --> 00:35:11.914
at the fulfillment
logic of Number Genie.

00:35:11.914 --> 00:35:13.330
LEON NICHOLLS:
Now, we track a lot

00:35:13.330 --> 00:35:15.400
of things in the conversation.

00:35:15.400 --> 00:35:17.860
Notice that we use a
counter for fallbacks.

00:35:17.860 --> 00:35:20.170
NANDINI STOCKER: We also
track the number of guesses,

00:35:20.170 --> 00:35:23.140
the value of the previous
guess, and how many times

00:35:23.140 --> 00:35:24.640
the user gives the same answer.

00:35:27.460 --> 00:35:29.070
LEON NICHOLLS: Now,
we also consider

00:35:29.070 --> 00:35:32.286
how far away the user's
guess is from the answer.

00:35:32.286 --> 00:35:33.660
NANDINI STOCKER:
As the user gets

00:35:33.660 --> 00:35:38.035
closer to the answer, in
which the demo didn't work,

00:35:38.035 --> 00:35:41.430
we provide rapid reprompts
and encouraging sounds.

00:35:41.430 --> 00:35:43.500
So try it out
yourself, and you'll

00:35:43.500 --> 00:35:45.400
see there's a few
hidden gems in there,

00:35:45.400 --> 00:35:46.530
and the way it reprompts.

00:35:46.530 --> 00:35:48.090
And it throws in
a few sounds when

00:35:48.090 --> 00:35:51.540
you're getting a little
closer, a little far away.

00:35:51.540 --> 00:35:53.040
LEON NICHOLLS: Now,
we also remember

00:35:53.040 --> 00:35:56.859
if we gave the user a hint in
what direction the answer is.

00:35:56.859 --> 00:35:58.650
NANDINI STOCKER: And
we changed the prompts

00:35:58.650 --> 00:36:01.710
and tracked when the user
followed or ignored our hints.

00:36:01.710 --> 00:36:02.910
Be sure to try that out too.

00:36:04.610 --> 00:36:06.110
LEON NICHOLLS: Now,
here you can see

00:36:06.110 --> 00:36:07.950
some of the prompts
we use in the game.

00:36:07.950 --> 00:36:10.910
We dynamically provide values
for the variable characters

00:36:10.910 --> 00:36:16.370
in the prompts based on the
user input and the game state.

00:36:16.370 --> 00:36:18.260
NANDINI STOCKER: So
I hope we've shown

00:36:18.260 --> 00:36:21.620
you a foundation of building
your conversation repair

00:36:21.620 --> 00:36:22.700
strategy.

00:36:22.700 --> 00:36:25.310
We talked a little bit about
the types of error events

00:36:25.310 --> 00:36:28.310
to plan for, how to use
built-ins and other existing

00:36:28.310 --> 00:36:31.170
tool features to
implement in your design,

00:36:31.170 --> 00:36:35.000
and prevent the bulk of errors
by anticipating and tracking

00:36:35.000 --> 00:36:38.700
user progress in context.

00:36:38.700 --> 00:36:40.760
LEON NICHOLLS: But the
key to any strategy

00:36:40.760 --> 00:36:43.600
for creating a
conversational experience,

00:36:43.600 --> 00:36:46.210
especially for when
things go wrong,

00:36:46.210 --> 00:36:49.926
is to step back, and look
at the user's situation.

00:36:49.926 --> 00:36:51.550
NANDINI STOCKER:
Don't create dead ends

00:36:51.550 --> 00:36:52.690
when something didn't work.

00:36:52.690 --> 00:36:55.555
So remember, it doesn't have
to be treated as an error.

00:36:58.285 --> 00:36:59.910
LEON NICHOLLS: Now,
there are more docs

00:36:59.910 --> 00:37:03.510
and resources available on our
site, including white papers

00:37:03.510 --> 00:37:05.127
and a design checklist.

00:37:05.127 --> 00:37:07.710
NANDINI STOCKER: Which includes
an entire list of conversation

00:37:07.710 --> 00:37:09.660
repair check items.

00:37:09.660 --> 00:37:12.270
Also, take a look at
the sample apps that we

00:37:12.270 --> 00:37:13.820
have open source in GitHub.

00:37:16.357 --> 00:37:18.190
LEON NICHOLLS: There's
also a lot more talks

00:37:18.190 --> 00:37:21.280
about conversation
design tomorrow, as well

00:37:21.280 --> 00:37:23.710
as Office Hours, so you can
talk to some of our teams.

00:37:28.330 --> 00:37:31.720
And because we think some
of the best strategies

00:37:31.720 --> 00:37:34.150
will come from you,
we want to hear all

00:37:34.150 --> 00:37:36.372
about what you come up with.

00:37:36.372 --> 00:37:38.080
NANDINI STOCKER: So
as you saw yesterday,

00:37:38.080 --> 00:37:41.620
we announced the Actions on
Google Developer Challenge.

00:37:41.620 --> 00:37:44.260
We had a little part in that.

00:37:44.260 --> 00:37:46.180
Remember that when
you're creating yours

00:37:46.180 --> 00:37:51.480
that any winning app probably
will have a killer conversation

00:37:51.480 --> 00:37:54.760
repair strategy at
its core, right?

00:37:54.760 --> 00:37:57.815
LEON NICHOLLS: And we can't
wait to see what you create.

00:37:57.815 --> 00:37:58.940
NANDINI STOCKER: Thank you.

00:37:58.940 --> 00:37:59.856
LEON NICHOLLS: Thanks.

00:37:59.856 --> 00:38:00.724
[APPLAUSE]

00:38:00.724 --> 00:38:04.900
[MUSIC PLAYING]

