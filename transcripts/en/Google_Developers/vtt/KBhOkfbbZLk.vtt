WEBVTT
Kind: captions
Language: en

00:00:01.586 --> 00:00:03.960
MANFRED ZABARAUSKAS: Hello
and welcome to Less Code, More

00:00:03.960 --> 00:00:05.940
Services, Better Android Apps.

00:00:05.940 --> 00:00:07.090
Thanks so much for coming.

00:00:07.090 --> 00:00:09.670
I know we have a lot of great
sessions to choose from.

00:00:09.670 --> 00:00:13.000
So we're both honored that
you are coming to ours.

00:00:13.000 --> 00:00:14.040
My name's Manfred.

00:00:14.040 --> 00:00:16.610
I'm a product manager
working at the intersection

00:00:16.610 --> 00:00:19.154
of Android Studio
and Google Cloud.

00:00:19.154 --> 00:00:20.320
JATIN LODHIA: And I'm Jatin.

00:00:20.320 --> 00:00:23.870
I'm an Android engineer working
on sync and authentication.

00:00:23.870 --> 00:00:26.180
And one of my
really good passions

00:00:26.180 --> 00:00:28.680
is basically having
seamless transition

00:00:28.680 --> 00:00:30.572
of users across
multiple devices.

00:00:30.572 --> 00:00:32.280
MANFRED ZABARAUSKAS:
And that is actually

00:00:32.280 --> 00:00:35.890
particularly important in
today's multi-device world.

00:00:35.890 --> 00:00:38.760
So it doesn't matter if
you're writing an Android

00:00:38.760 --> 00:00:41.550
game or a simple
task management app,

00:00:41.550 --> 00:00:43.930
your users are
expecting their data

00:00:43.930 --> 00:00:46.560
to be persistent
across multiple devices

00:00:46.560 --> 00:00:49.026
and to be accessed
from anywhere.

00:00:49.026 --> 00:00:50.650
In this session we're
going to show you

00:00:50.650 --> 00:00:53.140
how to build mobile
apps which use

00:00:53.140 --> 00:00:57.080
both new and existing Google
technologies to simplify Cloud

00:00:57.080 --> 00:00:59.910
Datastorage,
online/offline interaction,

00:00:59.910 --> 00:01:02.670
and synchronization
across multiple devices.

00:01:02.670 --> 00:01:05.920
Throughout the session, you'll
see how Android Studio tooling

00:01:05.920 --> 00:01:07.940
makes these tasks
straightforward

00:01:07.940 --> 00:01:11.620
and allows you to bring the full
power of Google Cloud Platform

00:01:11.620 --> 00:01:12.800
to your apps.

00:01:12.800 --> 00:01:15.080
So we hope that we're
going to come away equipped

00:01:15.080 --> 00:01:18.870
with new tools and new skills
to make your Android apps better

00:01:18.870 --> 00:01:21.000
than ever without
having to write

00:01:21.000 --> 00:01:23.620
hundreds of lines of code.

00:01:23.620 --> 00:01:26.900
So the fact is that most of
the interesting applications

00:01:26.900 --> 00:01:29.380
nowadays are powered by Cloud.

00:01:29.380 --> 00:01:33.560
According to EDC
research, around 83%

00:01:33.560 --> 00:01:36.010
of mobile app
developers last year

00:01:36.010 --> 00:01:39.880
were planning to execute
some code on the Cloud.

00:01:39.880 --> 00:01:45.260
And as early as in 2012,
already 63% of app developers

00:01:45.260 --> 00:01:49.520
were using some sort
of Cloud storage APIs.

00:01:49.520 --> 00:01:53.330
Now the main reason for that is
because we're all developers.

00:01:53.330 --> 00:01:56.690
And we want to make our
applications more engaging.

00:01:56.690 --> 00:01:59.210
And this might involve
using some data that's

00:01:59.210 --> 00:02:00.290
changing rapidly.

00:02:00.290 --> 00:02:03.920
So think about
whether-- or in my case,

00:02:03.920 --> 00:02:07.530
think about today's
basketball scores.

00:02:07.530 --> 00:02:09.639
Or you might want to store
data that's just simply

00:02:09.639 --> 00:02:11.510
too large to store
on the device.

00:02:11.510 --> 00:02:16.110
So think about a sample of
every song in the world, right?

00:02:16.110 --> 00:02:18.220
It's not going to
fit on the device.

00:02:18.220 --> 00:02:20.930
And then we also want to
make the data synchronized

00:02:20.930 --> 00:02:25.060
across all of the devices
that your users might have.

00:02:25.060 --> 00:02:26.860
So might be a phone, a tablet.

00:02:26.860 --> 00:02:31.670
And if I add a task into a task
management app on my phone,

00:02:31.670 --> 00:02:33.950
I want the same task to
be available on the tablet

00:02:33.950 --> 00:02:36.270
as well.

00:02:36.270 --> 00:02:41.610
So when you get one of these
crazy and exciting ideas,

00:02:41.610 --> 00:02:43.440
you want to focus
on the core idea.

00:02:43.440 --> 00:02:46.530
You don't want to worry
about servers, load balancer

00:02:46.530 --> 00:02:49.650
configurations, content
distribution networks, and so

00:02:49.650 --> 00:02:51.100
on.

00:02:51.100 --> 00:02:53.940
Now the good thing is that
a lot of this complexity

00:02:53.940 --> 00:02:57.190
is handled for you by Google
Cloud Endpoints, which

00:02:57.190 --> 00:03:00.290
allow you to build powerful
backend APIs in a very

00:03:00.290 --> 00:03:02.080
simple way.

00:03:02.080 --> 00:03:05.410
So you can use familiar tools
and skills like Android Studio

00:03:05.410 --> 00:03:08.970
and Java to develop not
only your Android apps,

00:03:08.970 --> 00:03:11.610
but the backends
for them as well.

00:03:11.610 --> 00:03:13.950
And you can start
communicating with your app

00:03:13.950 --> 00:03:17.890
really, really easily by calling
the client libraries which

00:03:17.890 --> 00:03:22.060
are produced for your
backend from the Android app.

00:03:22.060 --> 00:03:25.230
And then finally, as
your application grows,

00:03:25.230 --> 00:03:28.230
you're backend is also
going to scale automatically

00:03:28.230 --> 00:03:31.530
because under the hood it's
actually powered by Google App

00:03:31.530 --> 00:03:34.680
Engine which comes with
its own auto-scaling and

00:03:34.680 --> 00:03:37.220
high-availability guarantees.

00:03:37.220 --> 00:03:40.600
So here's a typical architecture
of a Cloud Endpoints powered

00:03:40.600 --> 00:03:41.290
app.

00:03:41.290 --> 00:03:43.660
On the right hand side,
you have the backend,

00:03:43.660 --> 00:03:45.570
which is running on
Google App Engine.

00:03:45.570 --> 00:03:47.400
And then on the
left hand side, you

00:03:47.400 --> 00:03:51.380
have the clients, which might
be JavaScript, Android, iOS.

00:03:51.380 --> 00:03:53.980
And these clients are using
Cloud Endpoint clients

00:03:53.980 --> 00:03:57.170
libraries to communicate
with the backend.

00:03:57.170 --> 00:03:58.930
This might seem a
little bit complicated

00:03:58.930 --> 00:04:00.280
from the first slide.

00:04:00.280 --> 00:04:05.000
But in reality Cloud Endpoints
define a very simple workflow.

00:04:05.000 --> 00:04:07.880
So you start by writing
the endpoint, which

00:04:07.880 --> 00:04:12.280
is the actual code which you
want to run in the backend.

00:04:12.280 --> 00:04:14.910
And essentially all
that it is, it's

00:04:14.910 --> 00:04:18.370
a simple Java class with
a couple of annotations.

00:04:18.370 --> 00:04:22.070
So here I have my endpoint
class, and towards the middle

00:04:22.070 --> 00:04:24.820
of the snippet I
have a method, sayHi.

00:04:24.820 --> 00:04:28.240
It takes a string name and it
returns the response Hi, name.

00:04:28.240 --> 00:04:29.290
Very simple.

00:04:29.290 --> 00:04:33.400
Now I annotate my endpoint
class with an API annotation.

00:04:33.400 --> 00:04:36.150
So I give it the name, myAPI.

00:04:36.150 --> 00:04:38.430
And then, similarly,
I give the annotation

00:04:38.430 --> 00:04:41.220
to the method which I want
to run in the backend.

00:04:41.220 --> 00:04:42.500
And I give it the name, sayHi.

00:04:42.500 --> 00:04:46.120
So myAPI, sayHi.

00:04:46.120 --> 00:04:49.550
Once that is done I
can literally just

00:04:49.550 --> 00:04:53.607
deploy this Java class of
Google App Engine backend.

00:04:53.607 --> 00:04:55.690
And by the way, I don't
have to worry about things

00:04:55.690 --> 00:04:58.630
like spending up App Engine
instances and things like that.

00:04:58.630 --> 00:05:02.430
Google Cloud Endpoints take
care of all of that for me.

00:05:02.430 --> 00:05:04.080
I deploy that to
the backend and it

00:05:04.080 --> 00:05:07.250
starts running on
Google's infrastructure.

00:05:07.250 --> 00:05:09.120
And then finally,
once that is done,

00:05:09.120 --> 00:05:12.730
you can start calling the
strongly-typed mobile optimized

00:05:12.730 --> 00:05:15.470
clients libraries
from your mobile app

00:05:15.470 --> 00:05:19.030
which are derived from these
annotation which you just

00:05:19.030 --> 00:05:20.260
put in the code.

00:05:20.260 --> 00:05:22.590
So here's the same example.

00:05:22.590 --> 00:05:26.500
If you remember I give the API
name, myAPI, and method, sayHi.

00:05:26.500 --> 00:05:29.270
And this is a screenshot
from Android Studio where

00:05:29.270 --> 00:05:32.460
you can see a myAPI
object exposed

00:05:32.460 --> 00:05:34.870
which has a sayHi method.

00:05:34.870 --> 00:05:38.400
All of these libraries which
I can call from Android Client

00:05:38.400 --> 00:05:42.500
were generated just from
those simple annotations.

00:05:42.500 --> 00:05:45.330
So at this point I'm actually
going to hand it over

00:05:45.330 --> 00:05:48.680
to Jatin, who's going to give
us a simple example of how

00:05:48.680 --> 00:05:52.744
to add the backend like
that from Android Studio.

00:05:52.744 --> 00:05:54.160
JATIN LODHIA: All
right, I already

00:05:54.160 --> 00:05:58.440
have Android Studio open
with project in there.

00:05:58.440 --> 00:06:01.630
And what I'm going to do
is add them back into this.

00:06:01.630 --> 00:06:03.680
It is going to be simple,
a couple of steps.

00:06:03.680 --> 00:06:06.460
And then after that,
I'm going to run this.

00:06:06.460 --> 00:06:09.510
Run the server locally and
then hit it with a browser

00:06:09.510 --> 00:06:11.990
and show you that you
can actually hit it,

00:06:11.990 --> 00:06:17.100
and what it can do with
it during deeper fazes.

00:06:17.100 --> 00:06:22.360
So let's go and click
here, new module.

00:06:22.360 --> 00:06:24.100
Select endpoint module.

00:06:24.100 --> 00:06:25.510
Say next.

00:06:25.510 --> 00:06:27.385
Let's name our backend, backend.

00:06:30.830 --> 00:06:32.520
Pretty original.

00:06:32.520 --> 00:06:34.100
So what you can
see here is that it

00:06:34.100 --> 00:06:37.520
created a folder named backend.

00:06:37.520 --> 00:06:39.820
And it has the
exact same classes

00:06:39.820 --> 00:06:43.150
which Manfred just mentioned.

00:06:43.150 --> 00:06:45.370
So you can see my
endpoints here.

00:06:45.370 --> 00:06:49.700
And it's basically the endpoint
which we are going to show you,

00:06:49.700 --> 00:06:53.690
and it uses something called
my bean, which is a bean.

00:06:53.690 --> 00:06:56.800
And this bean is
used for sending

00:06:56.800 --> 00:07:00.260
data between the
client and the server.

00:07:00.260 --> 00:07:03.660
So if we would quickly run
this-- If we click run,

00:07:03.660 --> 00:07:06.080
it's going to start
off a server here.

00:07:06.080 --> 00:07:10.390
If you look at the gradle
file-- OK, there you go.

00:07:10.390 --> 00:07:13.050
And we're going to
hit local host 80.80.

00:07:13.050 --> 00:07:16.300
The server is already up and on.

00:07:16.300 --> 00:07:19.010
What you see here is
an index.html file

00:07:19.010 --> 00:07:22.480
which was auto-generated
for my Endpoints.

00:07:22.480 --> 00:07:28.770
And if we write in I/O
Session here, and see.

00:07:28.770 --> 00:07:29.370
Hello.

00:07:29.370 --> 00:07:31.790
The server is going to respond
with Hi, I/O session, which

00:07:31.790 --> 00:07:37.240
is the response which server
was supposed to give us.

00:07:37.240 --> 00:07:39.070
One of the awesome
parts over here

00:07:39.070 --> 00:07:41.380
is if you look at
this, the little tab,

00:07:41.380 --> 00:07:43.670
it's called Endpoints
API Explorer.

00:07:43.670 --> 00:07:45.280
We click through it.

00:07:45.280 --> 00:07:47.330
It's going to take you
to a dashboard which

00:07:47.330 --> 00:07:51.500
is going to show you all of the
APIs present on your server.

00:07:51.500 --> 00:07:52.930
You can see my API over here.

00:07:52.930 --> 00:07:57.350
If you click through this
It'll list you all the methods

00:07:57.350 --> 00:07:58.610
your API has.

00:07:58.610 --> 00:08:00.380
In this case, it's sayHi.

00:08:00.380 --> 00:08:03.060
If you click through that
you'll see a form there.

00:08:03.060 --> 00:08:06.600
This form is used to create
a request right from your web

00:08:06.600 --> 00:08:07.740
browser.

00:08:07.740 --> 00:08:13.220
And let's say-- let's
enter Manfred's name here.

00:08:13.220 --> 00:08:14.750
And execute.

00:08:14.750 --> 00:08:17.110
So the server is going
to return Hi, Manfred.

00:08:17.110 --> 00:08:18.630
But if you look
at the bottom half

00:08:18.630 --> 00:08:21.800
of the screen you can see
the exact request which

00:08:21.800 --> 00:08:24.440
was sent to the server
and the exact response

00:08:24.440 --> 00:08:26.010
the server sent back.

00:08:26.010 --> 00:08:28.190
And you can see how
it was structured,

00:08:28.190 --> 00:08:29.800
which is really
important if you need

00:08:29.800 --> 00:08:31.216
to debug something
in your server.

00:08:33.799 --> 00:08:37.980
Let's see if we can actually
have a demo here which--

00:08:37.980 --> 00:08:39.140
like an example.

00:08:39.140 --> 00:08:40.223
MANFRED ZABARAUSKAS: Yeah.

00:08:40.223 --> 00:08:42.643
I mean, by all means,
let's do an example.

00:08:42.643 --> 00:08:44.059
We're going to
show you how to use

00:08:44.059 --> 00:08:46.840
Cloud Endpoints
in your actual app

00:08:46.840 --> 00:08:49.310
to make it a bit more engaging.

00:08:49.310 --> 00:08:52.370
Some of you might have seen
this app at the keynote earlier

00:08:52.370 --> 00:08:53.376
yesterday.

00:08:53.376 --> 00:08:55.000
Essentially, it's a
very simple Android

00:08:55.000 --> 00:08:58.560
app which lets me to record
my path, distance, speed,

00:08:58.560 --> 00:09:03.280
elevation, as I run, jog, bike,
do anything else outdoors.

00:09:03.280 --> 00:09:05.600
And in this screenshot you
can see one of my walks

00:09:05.600 --> 00:09:08.440
earlier today around
the Google campus.

00:09:08.440 --> 00:09:10.610
While the app is
pretty cool already,

00:09:10.610 --> 00:09:12.640
me and Jatin had
a few good ideas

00:09:12.640 --> 00:09:15.260
on how we could make
it a bit more engaging.

00:09:15.260 --> 00:09:16.450
So here's one.

00:09:16.450 --> 00:09:19.220
When I go for a jog
I often get bored

00:09:19.220 --> 00:09:21.780
by always taking the same route.

00:09:21.780 --> 00:09:24.940
Wouldn't it be cool if when I
clicked on the track button,

00:09:24.940 --> 00:09:26.630
down right in the
corner, it would

00:09:26.630 --> 00:09:30.920
show me an interesting location
within my jogging radius

00:09:30.920 --> 00:09:36.200
so that I could get both
fit, and see something new.

00:09:36.200 --> 00:09:39.040
Something like that, right.

00:09:39.040 --> 00:09:42.980
So Jatin, how would one
go about putting together

00:09:42.980 --> 00:09:45.950
an endponts backend which
does something like this?

00:09:45.950 --> 00:09:48.830
JATIN LODHIA: Sure, I can
show it to you in a minute.

00:09:48.830 --> 00:09:51.020
So I already have this
project open here,

00:09:51.020 --> 00:09:55.040
and we already did some
changes to the My Endpoints API

00:09:55.040 --> 00:09:58.480
to return us the correct
response we wanted.

00:09:58.480 --> 00:10:01.360
So I will walk you through
the code which-- the changes

00:10:01.360 --> 00:10:02.430
which we made.

00:10:02.430 --> 00:10:06.160
So let's look at the
server side code first.

00:10:06.160 --> 00:10:08.650
So if you remember we had
the class name, MyEndpoints.

00:10:08.650 --> 00:10:10.150
We renamed it to
SuggestAPIEndpoint.

00:10:12.680 --> 00:10:16.710
Now within this, we
change the name of the API

00:10:16.710 --> 00:10:22.740
to Suggest instead of myAPI,
and we renamed the method name

00:10:22.740 --> 00:10:24.810
to Destination.

00:10:24.810 --> 00:10:27.812
Now this method takes in two
variables, two parameters,

00:10:27.812 --> 00:10:30.600
the latitude and the longitude.

00:10:30.600 --> 00:10:32.230
And what we're
going to do here is

00:10:32.230 --> 00:10:34.790
take these two
latitudes and longitudes

00:10:34.790 --> 00:10:40.792
and figure out this random
point nearby and return that.

00:10:40.792 --> 00:10:42.500
And along with that,
we are going to slap

00:10:42.500 --> 00:10:47.100
on a quick description
of what that point is.

00:10:47.100 --> 00:10:50.390
And we pick that from one of
the three static description

00:10:50.390 --> 00:10:52.150
we have.

00:10:52.150 --> 00:10:55.820
If you notice, we also
change the bean here.

00:10:55.820 --> 00:10:57.890
We just renamed it
to DestinationBean

00:10:57.890 --> 00:11:00.360
and we added a few
more data to it.

00:11:00.360 --> 00:11:04.000
So if you click
through it, the bean

00:11:04.000 --> 00:11:06.970
contains the new latitude
and longitude along

00:11:06.970 --> 00:11:08.930
with a description.

00:11:08.930 --> 00:11:11.920
So once the server
sends back this bean,

00:11:11.920 --> 00:11:13.500
the client will
receive the bean,

00:11:13.500 --> 00:11:16.750
and the client's stub is
going to give this bean back

00:11:16.750 --> 00:11:19.280
to your application.

00:11:19.280 --> 00:11:23.220
Let's look at the changes we
made in the application code.

00:11:23.220 --> 00:11:27.410
We added a new class called
endpoints AsyncTask, which

00:11:27.410 --> 00:11:30.410
is an asynchronous AsyncTask
provided by Android.

00:11:30.410 --> 00:11:32.700
And in the constructor
of this class

00:11:32.700 --> 00:11:36.340
we created a stub for our API.

00:11:36.340 --> 00:11:39.500
If you remember, we
named the API Suggest,

00:11:39.500 --> 00:11:43.550
so the stub which was created
is also named Suggest.

00:11:43.550 --> 00:11:48.750
And once we have the stub-- here
we call the method destination

00:11:48.750 --> 00:11:51.610
on it, pass it the current
latitude and longitude

00:11:51.610 --> 00:11:54.550
of the device, and
we call execute.

00:11:54.550 --> 00:11:58.130
So the execute method returns
us the destination bean

00:11:58.130 --> 00:12:00.680
returned from the server.

00:12:00.680 --> 00:12:04.450
And this is what is returned
back from the class.

00:12:04.450 --> 00:12:06.985
And the UI takes care
of looking at this bean

00:12:06.985 --> 00:12:09.560
and displaying it on our device.

00:12:09.560 --> 00:12:12.110
Lets quickly run
this on our device.

00:12:12.110 --> 00:12:15.100
I'm going to click
play here, which

00:12:15.100 --> 00:12:17.640
is going to compile
the code and ship it

00:12:17.640 --> 00:12:19.130
to my device, which
is right here.

00:12:19.130 --> 00:12:22.780
Let's switch over
to the projector.

00:12:22.780 --> 00:12:28.470
So the app should soon
come up over here as soon

00:12:28.470 --> 00:12:30.950
as the compilation is done
and it pushes the app.

00:12:34.960 --> 00:12:37.910
There you go.

00:12:37.910 --> 00:12:40.500
All right.

00:12:40.500 --> 00:12:45.491
We are near Mission and 4th,
and Marconi Center here.

00:12:45.491 --> 00:12:45.990
OK.

00:12:48.510 --> 00:12:50.010
We're going to hit
the track button

00:12:50.010 --> 00:12:52.132
and this is supposed to
go and hit our server.

00:12:52.132 --> 00:12:53.590
The server is going
to respond back

00:12:53.590 --> 00:12:55.740
with an interesting
destination nearby.

00:12:59.480 --> 00:13:01.010
There you go.

00:13:01.010 --> 00:13:02.210
If we zoom out.

00:13:02.210 --> 00:13:03.874
There it is.

00:13:03.874 --> 00:13:05.459
Oh, the world's
deepest rabbit hole.

00:13:05.459 --> 00:13:06.500
MANFRED ZABARAUSKAS: Wow!

00:13:06.500 --> 00:13:07.510
Cool.

00:13:07.510 --> 00:13:09.798
All right, this is a
good time to clap, guys.

00:13:09.798 --> 00:13:13.622
[APPLAUSE]

00:13:13.622 --> 00:13:14.580
All right.

00:13:14.580 --> 00:13:17.230
Thanks, Jatin.

00:13:17.230 --> 00:13:19.990
So the keenest of
you can actually

00:13:19.990 --> 00:13:22.150
try to deduce the
probability of what

00:13:22.150 --> 00:13:24.457
are the chances to
get the same message.

00:13:24.457 --> 00:13:26.040
And it was one out
of three because we

00:13:26.040 --> 00:13:28.050
had three static descriptions.

00:13:28.050 --> 00:13:30.684
All right, so let me move on.

00:13:30.684 --> 00:13:32.100
Let me just quickly
summarize what

00:13:32.100 --> 00:13:34.080
we've seen so far
in the session.

00:13:34.080 --> 00:13:37.390
You've seen that Jatin
used Java plus Android

00:13:37.390 --> 00:13:40.630
Studio to the write the
code both for the backend

00:13:40.630 --> 00:13:42.684
and for his Android app.

00:13:42.684 --> 00:13:44.600
And then you've seen
that Cloud Endpoints took

00:13:44.600 --> 00:13:46.960
care of almost all
of the plumbing.

00:13:46.960 --> 00:13:50.570
So object serialization,
deserialization, compression,

00:13:50.570 --> 00:13:54.560
encryption using SSL, generating
client libraries, all of that

00:13:54.560 --> 00:13:56.940
was taken care of
by Cloud Endpoints.

00:13:56.940 --> 00:13:58.760
And that's great for
us as developers,

00:13:58.760 --> 00:14:01.750
but it's actually really
good for our users as well.

00:14:01.750 --> 00:14:05.090
So the fact that all the JSON
objects are automatically

00:14:05.090 --> 00:14:07.480
compressed as they
go over the wire

00:14:07.480 --> 00:14:10.960
means that our apps use minimal
amount of networking, which

00:14:10.960 --> 00:14:13.440
in turn increases
the battery life.

00:14:13.440 --> 00:14:19.290
And similarly, the fact that all
the data is encrypted using SSL

00:14:19.290 --> 00:14:21.170
means that your
user's information

00:14:21.170 --> 00:14:24.270
is secure, and so on.

00:14:24.270 --> 00:14:26.280
So finally, the
fact that endpoints

00:14:26.280 --> 00:14:28.790
backends are deployed
on Google App Engine

00:14:28.790 --> 00:14:32.430
means that your apps stay
responsive and available

00:14:32.430 --> 00:14:36.380
as your user base grows since
your app can actually now

00:14:36.380 --> 00:14:39.290
take advantage of Google's
infrastructure and Google's

00:14:39.290 --> 00:14:41.620
data centers across the world.

00:14:41.620 --> 00:14:44.740
OK, so all of that's pretty
cool, but at this point,

00:14:44.740 --> 00:14:46.460
let me switch gears a bit.

00:14:46.460 --> 00:14:48.980
There are many cases
when you don't actually

00:14:48.980 --> 00:14:51.860
need to run custom
code in the backend

00:14:51.860 --> 00:14:55.550
to make your applications
more engaging.

00:14:55.550 --> 00:14:58.840
In many cases, all you want
to do is to make sure that

00:14:58.840 --> 00:15:02.960
your app does not suffer
from what I call "app-nesia."

00:15:02.960 --> 00:15:04.620
And that's basically
a disease that

00:15:04.620 --> 00:15:07.600
causes your app to
forget it's users.

00:15:07.600 --> 00:15:10.800
So by a show of hands, how
many of you at some point

00:15:10.800 --> 00:15:13.230
have reinstalled an
app and discovered

00:15:13.230 --> 00:15:16.850
that it forgot something about
you, like user preferences

00:15:16.850 --> 00:15:19.400
or might be the game save state?

00:15:19.400 --> 00:15:21.960
Quite a few of you.

00:15:21.960 --> 00:15:27.010
So last year, we announced Cloud
Save, a game save storage API

00:15:27.010 --> 00:15:30.790
with the goal of never
having your users to have

00:15:30.790 --> 00:15:34.150
repeat the same level in a game.

00:15:34.150 --> 00:15:38.030
Now, this year, we're very
happy to announce a new API

00:15:38.030 --> 00:15:41.910
for all Android app
developers called Google Cloud

00:15:41.910 --> 00:15:45.650
Save for Android, which makes
it really easy to store user's

00:15:45.650 --> 00:15:48.750
data in the cloud,
and to synchronize it

00:15:48.750 --> 00:15:51.690
across all of the users devices.

00:15:51.690 --> 00:15:54.210
This new API is
really useful when

00:15:54.210 --> 00:15:56.430
you want to store
some structured data.

00:15:56.430 --> 00:15:59.250
It might be some applications
specific preferences.

00:15:59.250 --> 00:16:01.940
Like if I have a
stock portfolio app

00:16:01.940 --> 00:16:03.647
and I want to add
the stock ticker,

00:16:03.647 --> 00:16:06.230
and I want the same stock ticker
to be available for the users

00:16:06.230 --> 00:16:09.850
across all of the devices,
you can use Cloud Save.

00:16:09.850 --> 00:16:11.640
Furthermore, you
can actually use

00:16:11.640 --> 00:16:14.910
it to store any generic
structured user data.

00:16:14.910 --> 00:16:19.350
So tasks in a task management
app or planned journey

00:16:19.350 --> 00:16:22.270
in the travel planning app.

00:16:22.270 --> 00:16:25.040
And the really great
thing about this new API

00:16:25.040 --> 00:16:28.870
is that it requires
zero backend programing.

00:16:28.870 --> 00:16:32.760
So all you do is, you write
the client side code to store

00:16:32.760 --> 00:16:36.185
and query data, and then
the backend for your app

00:16:36.185 --> 00:16:37.520
is fully managed by Google.

00:16:40.120 --> 00:16:43.190
And the other thing that
I'm really excited about

00:16:43.190 --> 00:16:48.100
is we still have access to
all of your user's data.

00:16:48.100 --> 00:16:50.370
So if you want to run
some statistical analysis

00:16:50.370 --> 00:16:54.290
to get a better insight into how
your users are using the app,

00:16:54.290 --> 00:16:58.940
or if you want to run some
big data tools like BigQuery

00:16:58.940 --> 00:17:02.270
to aggregate the data and
expose it via some sort of web

00:17:02.270 --> 00:17:06.349
dashboard, you have
full access to it.

00:17:06.349 --> 00:17:08.930
And then finally,
this API is ideally

00:17:08.930 --> 00:17:11.540
suited for the
mobile device world.

00:17:11.540 --> 00:17:14.970
So as your user's data
is saved in the backend.

00:17:14.970 --> 00:17:19.200
It's automatically
synchronized across all

00:17:19.200 --> 00:17:21.280
of the user's devices.

00:17:21.280 --> 00:17:23.750
And you don't have to
write a single line of code

00:17:23.750 --> 00:17:25.444
to handle them.

00:17:25.444 --> 00:17:27.319
So some of you in the
audience might actually

00:17:27.319 --> 00:17:29.693
be worrying that there's going
to be a lot of coordinator

00:17:29.693 --> 00:17:32.790
cases to handle the
offline scenario.

00:17:32.790 --> 00:17:35.570
You don't have to worry
about that either.

00:17:35.570 --> 00:17:39.030
Even if the connection is
lost as soon as the app is

00:17:39.030 --> 00:17:42.210
downloaded, it's going
to work just fine.

00:17:42.210 --> 00:17:45.880
And the data is going to be
automatically synchronized

00:17:45.880 --> 00:17:49.080
immediately after your
app comes back online.

00:17:49.080 --> 00:17:51.950
And you won't have to
write a single line of code

00:17:51.950 --> 00:17:54.170
to do that either.

00:17:54.170 --> 00:17:56.210
So anyway, I think
at this point I

00:17:56.210 --> 00:17:58.650
might have sold it just enough.

00:17:58.650 --> 00:18:00.880
I'm going to hand it
over back to Jatin, who's

00:18:00.880 --> 00:18:04.210
going to give you more technical
details about Cloud Save.

00:18:04.210 --> 00:18:06.780
JATIN LODHIA:
Thank you, Manfred.

00:18:06.780 --> 00:18:10.500
So with increasing
popularity of Android,

00:18:10.500 --> 00:18:13.180
users have been buying
more and more devices.

00:18:13.180 --> 00:18:16.890
So nowadays users
have multiple devices.

00:18:16.890 --> 00:18:21.340
For example, in this case, if
they have a phone and a tablet,

00:18:21.340 --> 00:18:22.830
and there's an issue here.

00:18:22.830 --> 00:18:25.470
With standalone apps
you end up either

00:18:25.470 --> 00:18:29.080
having to figure out how to
sync the data across the two,

00:18:29.080 --> 00:18:32.924
or you will have to deal
with having fragmented data

00:18:32.924 --> 00:18:35.340
across two different devices,
which is a pretty sucky user

00:18:35.340 --> 00:18:36.710
experience.

00:18:36.710 --> 00:18:41.510
With Cloud Save we provide
you a solution to figure,

00:18:41.510 --> 00:18:44.390
due to synchronize data
across multiple devices,

00:18:44.390 --> 00:18:49.070
and at the same time have the
data be stored in the backend.

00:18:49.070 --> 00:18:51.890
This allows you to
focus on your app

00:18:51.890 --> 00:18:54.110
and trying to figure out
the logic of your app,

00:18:54.110 --> 00:18:56.950
whereas we take care of
all the details regarding

00:18:56.950 --> 00:19:01.160
synchronization and
sorting in the cloud.

00:19:01.160 --> 00:19:03.720
The best part about this
is that all this data

00:19:03.720 --> 00:19:05.680
is stored in your project.

00:19:05.680 --> 00:19:08.540
It's your developer
console project

00:19:08.540 --> 00:19:10.030
where the data gets stored.

00:19:10.030 --> 00:19:12.090
Which means that you
have full access to this,

00:19:12.090 --> 00:19:15.330
you have full
ownership of the data.

00:19:15.330 --> 00:19:16.760
What does this mean for you?

00:19:16.760 --> 00:19:20.120
Well, it means that you can
have queries run on this data.

00:19:20.120 --> 00:19:22.270
Or you can have dashboards
running on this data.

00:19:22.270 --> 00:19:24.910
You can expose this
data to the user.

00:19:24.910 --> 00:19:29.130
And when your app becomes really
successful-- and just in case,

00:19:29.130 --> 00:19:32.720
if you make a bug and
there's a data corruption.

00:19:32.720 --> 00:19:33.720
Bear with me.

00:19:33.720 --> 00:19:37.360
I know this doesn't happen, but
just in case, if it happens,

00:19:37.360 --> 00:19:39.790
you can go back, have
a small App Engine

00:19:39.790 --> 00:19:45.050
app which runs our MapReduce
and fix the data on the backend.

00:19:45.050 --> 00:19:48.620
So it basically provides
you a wholesome,

00:19:48.620 --> 00:19:52.380
[INAUDIBLE] data on your end.

00:19:52.380 --> 00:19:54.290
Now in the next
few slides we are

00:19:54.290 --> 00:19:58.520
going to show you what the API
looks like and how to use this.

00:19:58.520 --> 00:20:02.390
But to do this, we're going to
take the help of our WalkShare

00:20:02.390 --> 00:20:06.860
app as an example and step you
through different parts of it.

00:20:06.860 --> 00:20:10.260
And we'll show you a
demo also at the end.

00:20:10.260 --> 00:20:13.670
Now, before we go into
this, let me remind you

00:20:13.670 --> 00:20:16.500
that WalkShare app stores
two types of things.

00:20:16.500 --> 00:20:19.080
One is the trail on
which you walked.

00:20:19.080 --> 00:20:23.400
And as a part of the trail,
there are multiple waypoints.

00:20:23.400 --> 00:20:25.150
So there's a trail.

00:20:27.790 --> 00:20:30.600
A group of waypoints
belong to a trail.

00:20:30.600 --> 00:20:33.450
Now Cloud Save,
we have something

00:20:33.450 --> 00:20:36.660
called an entity which forms
the unit of our stored data

00:20:36.660 --> 00:20:37.910
structure.

00:20:37.910 --> 00:20:41.590
And it also forms a
unit of sync for us.

00:20:41.590 --> 00:20:43.270
So for those of you
who have already

00:20:43.270 --> 00:20:48.100
used Datastore from Cloud,
this measures the data sources

00:20:48.100 --> 00:20:49.040
entity.

00:20:49.040 --> 00:20:51.350
For those of you who
haven't used that,

00:20:51.350 --> 00:20:53.540
let me show you
what it looks like.

00:20:53.540 --> 00:20:57.230
An entity has a key.

00:20:57.230 --> 00:21:03.030
And this key is formed of two
parts-- a kind and a name.

00:21:03.030 --> 00:21:05.010
Kind is something like a class.

00:21:05.010 --> 00:21:08.620
And you can have
multiple entities

00:21:08.620 --> 00:21:11.070
sitting in the same
class, like a group.

00:21:11.070 --> 00:21:15.780
And the name is a unique
identifier within this class.

00:21:15.780 --> 00:21:19.870
So once you have an entity,
you can set properties on it.

00:21:19.870 --> 00:21:23.460
And these properties
can have different types

00:21:23.460 --> 00:21:25.300
from a list of types we support.

00:21:25.300 --> 00:21:32.530
For example, strings, binaries,
booleans, and many more.

00:21:32.530 --> 00:21:34.010
We also support
lists, by the way.

00:21:38.290 --> 00:21:41.610
You can have as many entities
as you want and store them.

00:21:41.610 --> 00:21:44.610
And we encourage you to
have smaller entities.

00:21:44.610 --> 00:21:47.400
Smaller entities make
better sync performance.

00:21:47.400 --> 00:21:49.750
And at the same time,
you have less amount

00:21:49.750 --> 00:21:54.090
of conflicts when you
try to save something.

00:21:54.090 --> 00:21:56.230
We'll come back to conflicts
a little bit later.

00:21:56.230 --> 00:21:59.070
Before that, I want to show
you a little bit other things

00:21:59.070 --> 00:22:00.980
we provide via Cloud Save.

00:22:00.980 --> 00:22:04.760
So we also have built-in
user authentication.

00:22:04.760 --> 00:22:06.480
What does it mean?

00:22:06.480 --> 00:22:10.090
All we have to do is let
the user select an account

00:22:10.090 --> 00:22:11.930
that they want to
use, and then you

00:22:11.930 --> 00:22:14.000
can pass that account to us.

00:22:14.000 --> 00:22:15.720
We take care of authentication.

00:22:15.720 --> 00:22:19.530
We take care of partitioning
your data based on the user.

00:22:19.530 --> 00:22:22.160
And we make sure that one
user cannot access another

00:22:22.160 --> 00:22:23.890
user's data.

00:22:23.890 --> 00:22:26.280
And by the way, all this
data and the data structure

00:22:26.280 --> 00:22:28.280
in the backend, is
already visible to you,

00:22:28.280 --> 00:22:32.350
so you have full power over it.

00:22:32.350 --> 00:22:35.380
Currently, we only
support Google accounts.

00:22:35.380 --> 00:22:39.549
But in future, we do plan to
have more than Google accounts

00:22:39.549 --> 00:22:41.965
as the authentication systems
or authentication providers.

00:22:44.940 --> 00:22:49.850
Let's talk about where the
API exists and how to use it.

00:22:49.850 --> 00:22:53.820
We provide Cloud Save as a
part of Google Play services.

00:22:53.820 --> 00:22:55.520
And for those you
who have already

00:22:55.520 --> 00:22:59.720
used Google Play services,
you already know what this is.

00:22:59.720 --> 00:23:02.120
For those of you who
have not used it,

00:23:02.120 --> 00:23:05.310
let me just give you a brief
explanation of what this is.

00:23:05.310 --> 00:23:08.950
Google API Client
is a stub, or it's

00:23:08.950 --> 00:23:12.840
a client-side stub which
is provided to you,

00:23:12.840 --> 00:23:15.530
or is present as a
part of your app.

00:23:15.530 --> 00:23:18.640
And it helps you talk to
services inside Google Play

00:23:18.640 --> 00:23:20.240
services.

00:23:20.240 --> 00:23:23.550
All you have to do is create
a Google API client using

00:23:23.550 --> 00:23:27.030
its builder, add the
APIs you want to use.

00:23:27.030 --> 00:23:30.910
So in this particular case,
it's CloudSaveManager.API.

00:23:30.910 --> 00:23:33.766
Then add a scope,
add the account

00:23:33.766 --> 00:23:36.705
which the user selected,
and add a few callbacks.

00:23:39.600 --> 00:23:44.450
Now an interesting part
about Android Studio

00:23:44.450 --> 00:23:46.835
is that Android
Studio sort of creates

00:23:46.835 --> 00:23:49.150
this boilerplate code for you.

00:23:49.150 --> 00:23:51.520
So all you've got to do
is right-click on the app,

00:23:51.520 --> 00:23:53.470
select Google, Google
Play Services activity,

00:23:53.470 --> 00:23:55.420
and enable Cloud Save.

00:23:55.420 --> 00:23:57.200
So if you enable
Cloud Save it'll

00:23:57.200 --> 00:24:00.070
already created an activity
called Google Play services

00:24:00.070 --> 00:24:05.780
activity which has the Google
API client already in there

00:24:05.780 --> 00:24:08.070
created for you with
the correct API.

00:24:08.070 --> 00:24:11.600
It already has a few callbacks,
like generic callbacks,

00:24:11.600 --> 00:24:14.450
and it's pretty easy
to start off with.

00:24:17.380 --> 00:24:20.030
We work pretty hard to
keep the API simple.

00:24:20.030 --> 00:24:23.690
And, believe me, it's pretty
hard to keep things simple.

00:24:27.550 --> 00:24:30.200
The reason behind
keeping an API simple

00:24:30.200 --> 00:24:33.120
is that we believe that
the simpler the API is,

00:24:33.120 --> 00:24:36.550
the easier it is
for you to use it.

00:24:36.550 --> 00:24:38.340
So as a part of
this API, we provide

00:24:38.340 --> 00:24:41.110
you a few simple
methods, namely save,

00:24:41.110 --> 00:24:44.710
delete, query and requestSync.

00:24:44.710 --> 00:24:49.090
At this point, let me note
that requestSync is only

00:24:49.090 --> 00:24:54.260
provided to you so that in
case your app needs to provide

00:24:54.260 --> 00:24:57.670
something like refresh
button to your users,

00:24:57.670 --> 00:25:01.080
then you can use this
method, wire the button.

00:25:01.080 --> 00:25:04.400
Otherwise, you don't need
to think about sync at all.

00:25:04.400 --> 00:25:07.830
We take care of syncing
everything in the backend--

00:25:07.830 --> 00:25:09.120
or in the background.

00:25:09.120 --> 00:25:11.980
And you don't need
to think about when

00:25:11.980 --> 00:25:15.010
to sync, when not to sync,
or anything about it.

00:25:15.010 --> 00:25:18.085
It's provided only if you want
to expose this to the user.

00:25:20.770 --> 00:25:23.310
Let's drill down
into one of the APIs.

00:25:23.310 --> 00:25:25.930
Let's say you want
to save some data.

00:25:25.930 --> 00:25:27.850
All you have to do
is create the list

00:25:27.850 --> 00:25:34.060
of entities you want to save,
then call CloudSaveManager.save

00:25:34.060 --> 00:25:37.730
and provide it the API
client, and also provide it

00:25:37.730 --> 00:25:39.840
the list of entities
you want to save.

00:25:39.840 --> 00:25:41.180
And that's it.

00:25:41.180 --> 00:25:44.060
It's going to return
you a pending result.

00:25:44.060 --> 00:25:46.580
And this pending result
is like a future object

00:25:46.580 --> 00:25:48.820
where you can either
set a callback,

00:25:48.820 --> 00:25:52.370
so when the result arrives,
the callback will be called,

00:25:52.370 --> 00:25:55.260
or you can just call the
blocking record of it,

00:25:55.260 --> 00:25:59.120
and you can wait for
the result to come back.

00:25:59.120 --> 00:26:01.630
Once you have stored
this data, the next thing

00:26:01.630 --> 00:26:03.160
is you want to read it.

00:26:03.160 --> 00:26:06.960
So for reading data, we provide
a very simple but effective

00:26:06.960 --> 00:26:08.590
querying API.

00:26:08.590 --> 00:26:11.790
As part of that API, we provide
you an object called query

00:26:11.790 --> 00:26:14.590
where you can set filters.

00:26:14.590 --> 00:26:19.390
Now let us see what kind
of filters there are.

00:26:19.390 --> 00:26:22.170
You can set a list
of keys as filters.

00:26:22.170 --> 00:26:24.569
So if you already know what
entities you want to fetch

00:26:24.569 --> 00:26:26.110
and you already have
the keys for it,

00:26:26.110 --> 00:26:29.130
you can just set the
keys in the filters

00:26:29.130 --> 00:26:33.490
and it will return you entities
belonging to those keys.

00:26:33.490 --> 00:26:37.050
There's another filter
which is, you can set kind.

00:26:37.050 --> 00:26:39.570
You can say, give
me all the entities

00:26:39.570 --> 00:26:42.270
which belong to this
particular kind.

00:26:42.270 --> 00:26:44.910
In our case, it can be something
like, give me all entities

00:26:44.910 --> 00:26:48.110
where the kind is waypoints.

00:26:48.110 --> 00:26:51.080
And then you also have
filters based on properties.

00:26:51.080 --> 00:26:54.650
So you can say, give
me all the entities

00:26:54.650 --> 00:26:58.420
which have property with
name equals something,

00:26:58.420 --> 00:27:01.290
and the value equals blah.

00:27:01.290 --> 00:27:06.000
Let's take an example with
respect to WalkShare app.

00:27:06.000 --> 00:27:07.830
You have a list of trails.

00:27:07.830 --> 00:27:10.762
When you want to display the
trail, you click on the trail

00:27:10.762 --> 00:27:12.220
and then you need
all the waypoints

00:27:12.220 --> 00:27:13.880
belonging to that trail.

00:27:13.880 --> 00:27:17.640
You need to query all the
waypoints at that point.

00:27:17.640 --> 00:27:20.930
What we have done here is that
we created a query object.

00:27:20.930 --> 00:27:23.940
We set the kind as waypoint.

00:27:23.940 --> 00:27:29.810
And we set the property as trail
ID equals the ID of the trail.

00:27:29.810 --> 00:27:33.470
And then we called
CloudSaveManager.query.

00:27:33.470 --> 00:27:35.740
We pass in the API
client and we pass

00:27:35.740 --> 00:27:37.960
in the query object
we just created.

00:27:37.960 --> 00:27:41.880
This returns a pending result,
and as I explained earlier,

00:27:41.880 --> 00:27:43.900
it's like a future object.

00:27:48.400 --> 00:27:50.140
Once we have written, we read.

00:27:50.140 --> 00:27:51.760
But how about conflicts?

00:27:54.467 --> 00:27:56.300
All of you would already
know what conflicts

00:27:56.300 --> 00:27:59.330
are, but let me give a quick
idea of what's happening here.

00:27:59.330 --> 00:28:01.540
When you have multiple
devices both of them

00:28:01.540 --> 00:28:02.940
read the same entity.

00:28:02.940 --> 00:28:06.597
One tries to write, the server
says good, you are good to go.

00:28:06.597 --> 00:28:08.680
The other tries to write,
and the server says hey,

00:28:08.680 --> 00:28:10.440
there's a conflict.

00:28:10.440 --> 00:28:14.120
Now how do we handle
conflicts when they arise?

00:28:14.120 --> 00:28:14.780
It's simple.

00:28:14.780 --> 00:28:17.140
We just let you handle it.

00:28:17.140 --> 00:28:21.100
[LAUGHTER]

00:28:21.100 --> 00:28:24.760
But in order to do that, we
do provide you a lot of help

00:28:24.760 --> 00:28:26.980
and a lot of structure.

00:28:26.980 --> 00:28:30.674
What we have here is something
called BaseEventService.

00:28:30.674 --> 00:28:32.340
You just have to
implement this service.

00:28:32.340 --> 00:28:34.380
And as a part of this
service we provide

00:28:34.380 --> 00:28:36.840
you a method called onConflict.

00:28:36.840 --> 00:28:40.620
This method receives
three parameters,

00:28:40.620 --> 00:28:42.630
three different versions
of the same entity

00:28:42.630 --> 00:28:45.140
which was under conflict.

00:28:45.140 --> 00:28:48.700
The first is local, which is
the local version which you just

00:28:48.700 --> 00:28:49.470
wrote.

00:28:49.470 --> 00:28:50.640
Second is the base.

00:28:50.640 --> 00:28:52.320
And the third is remote.

00:28:52.320 --> 00:28:56.650
Remote is the version
which the server has.

00:28:56.650 --> 00:29:00.580
Now the base entity is basically
the least common ancestor

00:29:00.580 --> 00:29:03.754
of the two, local and remote.

00:29:03.754 --> 00:29:05.170
Which means that
you basically can

00:29:05.170 --> 00:29:07.550
do a three-way merge over here.

00:29:07.550 --> 00:29:11.320
Once you resolve it, you
return back the resolved entity

00:29:11.320 --> 00:29:14.020
and we take care of
storing the resolved entity

00:29:14.020 --> 00:29:15.160
in the local database.

00:29:15.160 --> 00:29:17.560
And as soon as
it's done, we also

00:29:17.560 --> 00:29:20.520
sync it across all
the devices for you.

00:29:20.520 --> 00:29:23.690
You don't have to think about
how to sync it, how store it,

00:29:23.690 --> 00:29:24.310
and stuff.

00:29:27.260 --> 00:29:30.090
Now we're trying to keep
it as simple as possible.

00:29:30.090 --> 00:29:32.590
To do that, we shoved
all the boilerplate code

00:29:32.590 --> 00:29:35.140
inside the BaseEventService.

00:29:35.140 --> 00:29:40.030
And we also provide you
some tools for doing Diffs,

00:29:40.030 --> 00:29:43.820
so that given two entities, you
can use the tool to get a Diff.

00:29:43.820 --> 00:29:50.570
And after that, we also provide
you a simple three-way merge.

00:29:50.570 --> 00:29:54.750
So using this, if the conflict
is not a complicated conflict,

00:29:54.750 --> 00:29:58.370
it will resolve it for you.

00:29:58.370 --> 00:30:00.370
If your app is more
complex and if it

00:30:00.370 --> 00:30:04.927
needs to have more complex
solution for the conflict,

00:30:04.927 --> 00:30:06.010
then you can do that, too.

00:30:06.010 --> 00:30:08.259
Because you already have the
three different versions,

00:30:08.259 --> 00:30:11.060
you can do your own
three-way merge.

00:30:11.060 --> 00:30:13.990
And at the same time,
because the resolution

00:30:13.990 --> 00:30:16.750
is happening at an
entity level, you

00:30:16.750 --> 00:30:21.940
have a pretty good context
of what the entity means

00:30:21.940 --> 00:30:23.520
or what the data is.

00:30:23.520 --> 00:30:26.980
So with that context you can
actually do a much better

00:30:26.980 --> 00:30:31.220
merge yourself, a
much smarter merge.

00:30:31.220 --> 00:30:34.710
Now last but not the
least, sync optimizations.

00:30:34.710 --> 00:30:37.260
Because the sync happens
in the background

00:30:37.260 --> 00:30:40.360
we have the benefit
of batching things.

00:30:40.360 --> 00:30:42.170
So we do try to do that.

00:30:42.170 --> 00:30:47.090
We try to batch
things up so that we

00:30:47.090 --> 00:30:49.590
have a better
performance on battery.

00:30:49.590 --> 00:30:51.920
We also take care of push
notifications for you,

00:30:51.920 --> 00:30:55.160
which means that whenever
there's a change in the server

00:30:55.160 --> 00:30:58.300
we'll send a notification
to all the devices

00:30:58.300 --> 00:31:01.500
and the devices will
sync to this new data.

00:31:01.500 --> 00:31:04.810
We're also aware of Wi-Fi
versus cellular network, which

00:31:04.810 --> 00:31:06.810
means that, depending
on which network

00:31:06.810 --> 00:31:08.990
we are on we'll
either go full-blast

00:31:08.990 --> 00:31:12.251
or we can throttle back.

00:31:12.251 --> 00:31:14.000
At this point let's
see if we can actually

00:31:14.000 --> 00:31:15.640
have a quick example.

00:31:15.640 --> 00:31:18.020
MANFRED ZABARAUSKAS: Absolutely.

00:31:18.020 --> 00:31:19.410
Quick stretch break.

00:31:19.410 --> 00:31:22.180
I know you guys are like--
Your seats are not comfortable,

00:31:22.180 --> 00:31:24.030
so if you want to
move the shoulders

00:31:24.030 --> 00:31:26.830
or stretch back a bit,
take a little break.

00:31:26.830 --> 00:31:29.580
We're going to do
an example of how

00:31:29.580 --> 00:31:33.580
to use Cloud Save
to basically take

00:31:33.580 --> 00:31:36.360
the data from the mobile
phone-- I finish the jog,

00:31:36.360 --> 00:31:39.110
I have the track on my phone.

00:31:39.110 --> 00:31:42.450
I want that same track to be
saved on my Cloud Save backend

00:31:42.450 --> 00:31:45.420
so that when I come back
home, I pick up my tablet,

00:31:45.420 --> 00:31:47.340
and I see the same track there.

00:31:47.340 --> 00:31:48.850
So let's see, how
can we do this?

00:31:51.810 --> 00:31:56.700
Here's a class in
Android Studio.

00:31:56.700 --> 00:31:57.810
There it is.

00:31:57.810 --> 00:32:00.860
Cold storage adaptor.

00:32:00.860 --> 00:32:02.640
WalkShare app was
using this class

00:32:02.640 --> 00:32:04.990
to save data on
the local storage.

00:32:04.990 --> 00:32:07.060
So it has three methods,
save to storage,

00:32:07.060 --> 00:32:09.830
read trails from storage,
read waypoint from storage.

00:32:09.830 --> 00:32:13.130
What we've done is, we've blown
away the local storage code

00:32:13.130 --> 00:32:15.770
and we've added Cloud
Save Manager calls.

00:32:15.770 --> 00:32:17.870
We take the Google
API client, which

00:32:17.870 --> 00:32:20.530
is generated by Android
Studio, and entities

00:32:20.530 --> 00:32:22.730
that we want to
save, and we pass it

00:32:22.730 --> 00:32:24.188
to
GoogleCloudSaveManager.savecall.

00:32:25.740 --> 00:32:28.730
Similarly, to get
trails from storage

00:32:28.730 --> 00:32:32.320
we form the query using
the stuff that Jatin just

00:32:32.320 --> 00:32:36.100
described in the slides and we
call CloudSaveManager.query.

00:32:36.100 --> 00:32:37.340
As simple as that.

00:32:37.340 --> 00:32:42.710
Let me actually run this app on
the phone and see what happens.

00:32:42.710 --> 00:32:45.010
I know this is a bit of,
like, electromagnetic storm

00:32:45.010 --> 00:32:48.150
in the building so,
fingers crossed.

00:32:48.150 --> 00:32:49.880
OK.

00:32:49.880 --> 00:32:54.570
The bits are flying across
the USB cable from the laptop

00:32:54.570 --> 00:32:57.130
to the phone, and there we go.

00:32:57.130 --> 00:32:58.240
OK.

00:32:58.240 --> 00:33:00.970
Just to show you
the history tab,

00:33:00.970 --> 00:33:04.300
there's a single
track in the history

00:33:04.300 --> 00:33:07.650
and this is actually
from the earlier today.

00:33:07.650 --> 00:33:13.480
And if I start the tracking,
tracking first time.

00:33:13.480 --> 00:33:15.840
Stop the tracking.

00:33:15.840 --> 00:33:17.660
Switch back to the history tab.

00:33:17.660 --> 00:33:18.160
Woo-hoo!

00:33:18.160 --> 00:33:19.430
Two tracks.

00:33:19.430 --> 00:33:22.060
To prove you guys
that this is not magic

00:33:22.060 --> 00:33:25.030
and trickery, let me switch
to a Cloud Datastore.

00:33:29.410 --> 00:33:32.070
Here's the list of all the
entities in the datastore.

00:33:32.070 --> 00:33:35.920
Right now there's nothing,
so I refresh the query.

00:33:35.920 --> 00:33:36.430
Woo-hoo!

00:33:36.430 --> 00:33:37.707
Two tracks.

00:33:37.707 --> 00:33:42.090
[APPLAUSE]

00:33:42.090 --> 00:33:43.140
Thank you very much.

00:33:43.140 --> 00:33:47.400
And one final clap
opportunity is,

00:33:47.400 --> 00:33:48.969
Jatin, if you
refresh your tablet,

00:33:48.969 --> 00:33:51.260
let's see if we can get the
same tracks on your tablet.

00:33:51.260 --> 00:33:52.980
JATIN LODHIA: We kept
the tablet clean.

00:33:52.980 --> 00:33:54.110
We didn't refresh anything.

00:33:54.110 --> 00:33:55.620
Now we're going top refresh it.

00:33:55.620 --> 00:33:57.300
It's empty right now.

00:33:57.300 --> 00:33:58.240
Refresh.

00:33:58.240 --> 00:33:59.460
Go back to the thing.

00:33:59.460 --> 00:34:02.270
Come back to the history.

00:34:02.270 --> 00:34:02.770
Nice.

00:34:02.770 --> 00:34:03.970
There it is.

00:34:03.970 --> 00:34:06.180
[APPLAUSE]

00:34:06.180 --> 00:34:07.930
MANFRED ZABARAUSKAS:
Thanks so much, guys.

00:34:07.930 --> 00:34:11.090
You're very generous.

00:34:11.090 --> 00:34:12.820
Let me just, super
quickly, summarize

00:34:12.820 --> 00:34:14.420
what we've seen so far.

00:34:14.420 --> 00:34:17.290
You've seen that all of the
code that I touched in Android

00:34:17.290 --> 00:34:20.989
Studio was client-side code,
so no backend programming

00:34:20.989 --> 00:34:22.150
was involved.

00:34:22.150 --> 00:34:26.530
We still had access to the
data using Cloud Datastore.

00:34:26.530 --> 00:34:29.710
And as Jatin described
earlier, Cloud Save

00:34:29.710 --> 00:34:32.889
comes with really good online
and offline scenario support,

00:34:32.889 --> 00:34:36.230
so things like conflict
resolution, background

00:34:36.230 --> 00:34:39.010
synchronization,
knowledge whether you're

00:34:39.010 --> 00:34:43.270
on cellular connection
or Wi-Fi, and so on.

00:34:43.270 --> 00:34:47.340
Today we're excited to open
Cloud Save via early access

00:34:47.340 --> 00:34:51.330
program to a limited
set of initial users.

00:34:51.330 --> 00:34:54.050
If you want to help us to
make Cloud Save for Android

00:34:54.050 --> 00:34:57.296
even better please use
the link above to sign up.

00:34:57.296 --> 00:34:59.420
We're very much interested
in hearing your feedback

00:34:59.420 --> 00:35:03.540
and suggestions on how we
could improve Cloud Save even

00:35:03.540 --> 00:35:06.770
further before we release
it to a wider audience.

00:35:06.770 --> 00:35:09.270
And if you want to get more
information about Cloud

00:35:09.270 --> 00:35:12.090
Endpoints, which we've shown in
the first half of the session,

00:35:12.090 --> 00:35:14.490
we've put together an
end-to-end backend code

00:35:14.490 --> 00:35:17.920
lab which you can just
take it at your own pace

00:35:17.920 --> 00:35:19.610
when you go back home.

00:35:19.610 --> 00:35:22.890
And if you want to take your
idea even beyond the feature

00:35:22.890 --> 00:35:27.940
that Cloud Endpoints provide,
go to g.co/cloudstarterpack

00:35:27.940 --> 00:35:32.050
and enter promo code GoogleIO
to get $500 credit for Google

00:35:32.050 --> 00:35:33.355
Cloud Platform.

00:35:33.355 --> 00:35:34.730
All right, so
that's all we have.

00:35:34.730 --> 00:35:36.320
I thank you very
much, and we're going

00:35:36.320 --> 00:35:37.653
to open the floor for questions.

00:35:43.161 --> 00:35:45.160
AUDIENCE: Can you bring
the previous slide back?

00:35:45.160 --> 00:35:48.108
MANFRED ZABARAUSKAS: Absolutely.

00:35:48.108 --> 00:35:51.990
The one with the $500 or?

00:35:51.990 --> 00:35:53.170
Oh yeah.

00:35:57.526 --> 00:36:00.190
AUDIENCE: Can you go
to the next one now?

00:36:00.190 --> 00:36:03.520
MANFRED ZABARAUSKAS: We still
will have a few phones up so,

00:36:03.520 --> 00:36:04.820
going four going three--

00:36:04.820 --> 00:36:05.640
JATIN LODHIA: While
you take that picture

00:36:05.640 --> 00:36:07.120
I'll take a picture for you.

00:36:07.120 --> 00:36:09.299
[LAUGHTER]

00:36:09.299 --> 00:36:10.590
MANFRED ZABARAUSKAS: Going two.

00:36:10.590 --> 00:36:11.505
Going one.

00:36:15.400 --> 00:36:16.675
Still a few folks, sorry.

00:36:26.650 --> 00:36:28.960
Good for eye is not
amazing for cell phones.

00:36:32.055 --> 00:36:34.430
For those of you who are still
trying to get the picture,

00:36:34.430 --> 00:36:38.000
these lines will be posted
when the trail is published

00:36:38.000 --> 00:36:41.860
and recorded so you'll have
the opportunity there as well.

00:36:41.860 --> 00:36:44.010
All right, and the $500 slide.

00:36:44.010 --> 00:36:46.090
There it is.

00:36:46.090 --> 00:36:48.150
OK, yes, a question.

00:36:48.150 --> 00:36:50.715
AUDIENCE: Two questions.

00:36:50.715 --> 00:36:53.050
One is, how do you
support sharing data

00:36:53.050 --> 00:36:54.760
across multiple users?

00:36:54.760 --> 00:37:00.790
And then two is, what about
sharing on non-Android devices?

00:37:00.790 --> 00:37:04.080
JATIN LODHIA: Basically, the
sharing across multiple users

00:37:04.080 --> 00:37:06.480
is not there yet.

00:37:06.480 --> 00:37:09.990
It will probably be a
feature in the future,

00:37:09.990 --> 00:37:11.282
but it's not present right now.

00:37:11.282 --> 00:37:12.864
MANFRED ZABARAUSKAS:
Having said that,

00:37:12.864 --> 00:37:15.050
the data is stored in
the Cloud Datastore,

00:37:15.050 --> 00:37:17.200
so if you're using-- the
first half of the session,

00:37:17.200 --> 00:37:19.110
if you're using Cloud
Endpoints, then you

00:37:19.110 --> 00:37:21.630
can basically expose
an endpoint which

00:37:21.630 --> 00:37:24.670
uses basically
Datastore operations.

00:37:24.670 --> 00:37:26.230
Wire App Engine
backend, and then you

00:37:26.230 --> 00:37:28.700
can just expose data that way.

00:37:28.700 --> 00:37:31.930
And then, second
question was support

00:37:31.930 --> 00:37:34.870
for non-Android devices.

00:37:34.870 --> 00:37:37.770
Good news is that
it's on our radar.

00:37:37.770 --> 00:37:40.390
Bad news is that I cannot give
you the exact date at this

00:37:40.390 --> 00:37:40.890
point.

00:37:47.102 --> 00:37:48.560
AUDIENCE: I was
wondering, is there

00:37:48.560 --> 00:37:52.329
any listeners for
when the sync happens?

00:37:52.329 --> 00:37:53.870
JATIN LODHIA: Is
there any listeners?

00:37:53.870 --> 00:37:54.369
Yes.

00:37:54.369 --> 00:37:58.590
So there is basically something,
an API called onRemoteChange,

00:37:58.590 --> 00:38:01.500
put in the base intent
service, BaseEventService,

00:38:01.500 --> 00:38:04.760
and it lets you know as
soon as an entity changes.

00:38:04.760 --> 00:38:06.830
And it gives you a list
of entities that changed.

00:38:06.830 --> 00:38:09.080
MANFRED ZABARAUSKAS: Sorry,
I was unfair to that side.

00:38:09.080 --> 00:38:10.995
two questions from
that side now.

00:38:10.995 --> 00:38:12.880
AUDIENCE: The form
on the sign-up page

00:38:12.880 --> 00:38:14.480
is not publicly shared.

00:38:14.480 --> 00:38:16.360
MANFRED ZABARAUSKAS:
Oh, that's a bummer.

00:38:16.360 --> 00:38:16.660
OK.

00:38:16.660 --> 00:38:16.990
Let me--

00:38:16.990 --> 00:38:18.698
AUDIENCE: Is there a
form we can fill out

00:38:18.698 --> 00:38:20.079
to get it shared to us?

00:38:20.079 --> 00:38:21.120
MANFRED ZABARAUSKAS: Yes.

00:38:21.120 --> 00:38:24.280
Basically, as soon as
I leave the podium,

00:38:24.280 --> 00:38:25.250
I'll take care of that.

00:38:25.250 --> 00:38:27.730
Thank you very much.

00:38:27.730 --> 00:38:28.960
One more question.

00:38:28.960 --> 00:38:31.500
AUDIENCE: Is there a
way to purge local data

00:38:31.500 --> 00:38:38.650
and then later restore it so
you don't fill up locally?

00:38:38.650 --> 00:38:44.790
JATIN LODHIA: Is there a
way to purge local data.

00:38:44.790 --> 00:38:50.810
We do cache everything
locally so, not yet.

00:38:50.810 --> 00:38:55.797
Because we want your app to
be able to run online as well

00:38:55.797 --> 00:38:58.380
as offline, so as soon as a user
doesn't have data connection,

00:38:58.380 --> 00:39:01.070
they should be able
to use the app still.

00:39:01.070 --> 00:39:04.495
So that in the goal
of this service.

00:39:04.495 --> 00:39:05.370
AUDIENCE: OK, thanks.

00:39:08.370 --> 00:39:10.892
MANFRED ZABARAUSKAS: That side.

00:39:10.892 --> 00:39:12.850
AUDIENCE: So I know how
to use that data store,

00:39:12.850 --> 00:39:17.250
and I know it has some quirks,
especially around indexing.

00:39:17.250 --> 00:39:20.980
If you want to query on two
properties at the same time,

00:39:20.980 --> 00:39:23.110
you have to generate
a double index.

00:39:23.110 --> 00:39:25.122
How do you guys handle that?

00:39:25.122 --> 00:39:25.705
Automatically?

00:39:29.871 --> 00:39:31.120
JATIN LODHIA: On the back end?

00:39:31.120 --> 00:39:34.190
Is your question
about the Android or?

00:39:34.190 --> 00:39:36.130
You running Android.

00:39:36.130 --> 00:39:42.230
AUDIENCE: With Cloud Save, if
I'm querying on two properties,

00:39:42.230 --> 00:39:43.890
how are you going
to handle that?

00:39:43.890 --> 00:39:45.889
JATIN LODHIA: We don't
have the same constraints

00:39:45.889 --> 00:39:46.770
as App Engine does.

00:39:46.770 --> 00:39:49.060
We don't have to go through
a huge amount of data.

00:39:49.060 --> 00:39:51.730
It's just one users
data for one app,

00:39:51.730 --> 00:39:58.170
so we can easily, smartly do
filtering inside the data.

00:39:58.170 --> 00:40:00.610
It's not a huge amount of
data we have to go through,

00:40:00.610 --> 00:40:01.310
so we can do it.

00:40:01.310 --> 00:40:02.266
AUDIENCE: So you
filter in memory?

00:40:02.266 --> 00:40:03.057
JATIN LODHIA: Yeah.

00:40:03.057 --> 00:40:05.640
AUDIENCE: OK, thanks.

00:40:05.640 --> 00:40:08.790
AUDIENCE: What's the storage
mechanism on the client side?

00:40:08.790 --> 00:40:10.920
Is it file based
or SQLite based?

00:40:10.920 --> 00:40:13.120
JATIN LODHIA: It's SQLite based.

00:40:13.120 --> 00:40:16.210
AUDIENCE: And you guys handle
completely the CRUD on that?

00:40:16.210 --> 00:40:17.050
JATIN LODHIA: Yes.

00:40:17.050 --> 00:40:18.670
I'm sorry, we handle
completely what, on that?

00:40:18.670 --> 00:40:19.461
AUDIENCE: The CRUD.

00:40:19.461 --> 00:40:20.700
Create, read, update, delete.

00:40:20.700 --> 00:40:21.450
JATIN LODHIA: Yes.

00:40:25.540 --> 00:40:27.547
AUDIENCE: Do we, for
Android Cloud Store,

00:40:27.547 --> 00:40:29.880
does that start out free and
you just pay for App Engine

00:40:29.880 --> 00:40:33.150
when you start adding more Logic
and other access to the cloud,

00:40:33.150 --> 00:40:35.127
or is that always kind
of a subscription thing?

00:40:35.127 --> 00:40:36.960
MANFRED ZABARAUSKAS:
You mean on Cloud Save?

00:40:36.960 --> 00:40:38.210
AUDIENCE: Yeah, sorry.

00:40:38.210 --> 00:40:38.830
Cloud Save.

00:40:38.830 --> 00:40:40.870
MANFRED ZABARAUSKAS:
So basically,

00:40:40.870 --> 00:40:44.290
when you join the
Early Access program,

00:40:44.290 --> 00:40:47.530
we're going to give you a
free quota for every user,

00:40:47.530 --> 00:40:49.130
of your every app.

00:40:49.130 --> 00:40:53.210
Having said that, one of the
reasons why we're trying it out

00:40:53.210 --> 00:40:56.520
first as an early access
program is to figure out

00:40:56.520 --> 00:40:59.990
what that quota limit should
be when we roll it out

00:40:59.990 --> 00:41:01.310
to a wider audience.

00:41:01.310 --> 00:41:04.135
AUDIENCE: So it'll always be
kind of a free small data quota

00:41:04.135 --> 00:41:06.125
and then you just pay
for heavy-use apps?

00:41:06.125 --> 00:41:07.750
MANFRED ZABARAUSKAS:
So at this moment,

00:41:07.750 --> 00:41:09.680
the details are not
finalized in terms

00:41:09.680 --> 00:41:12.070
of how it's going to be handled.

00:41:12.070 --> 00:41:14.760
At the moment for early
access program, yes.

00:41:14.760 --> 00:41:16.660
But, you know,
we're trying to make

00:41:16.660 --> 00:41:19.500
sure what makes most sense and
kind of what's best for you

00:41:19.500 --> 00:41:20.440
guys.

00:41:20.440 --> 00:41:23.270
AUDIENCE: Thank you.

00:41:23.270 --> 00:41:25.330
AUDIENCE: And then,
two questions.

00:41:25.330 --> 00:41:34.410
Is the Google Cloud storage
built on top of the endpoints?

00:41:34.410 --> 00:41:39.510
And are the endpoints-- is there
like a JavaScript interface?

00:41:39.510 --> 00:41:43.700
When you compile
that API method,

00:41:43.700 --> 00:41:48.220
is it a rest interface or
is there any library that?

00:41:51.037 --> 00:41:52.870
MANFRED ZABARAUSKAS:
Yes and yes, basically.

00:41:52.870 --> 00:41:57.040
Endpoints have JavaScript client
libraries which get generated

00:41:57.040 --> 00:42:00.270
and kind of
strongly-- they learn

00:42:00.270 --> 00:42:02.500
those annotations
which you provide.

00:42:02.500 --> 00:42:04.070
So from those
annotations, you can

00:42:04.070 --> 00:42:07.410
generate iOS client libraries,
Android client libraries,

00:42:07.410 --> 00:42:09.690
that's basically what we've
seen in the demo, and then

00:42:09.690 --> 00:42:10.311
JavaScript.

00:42:10.311 --> 00:42:11.810
I don't know if you
remember, it was

00:42:11.810 --> 00:42:15.500
like of the relatively fine
point, when the web UI was

00:42:15.500 --> 00:42:20.060
generated automatically, enter
the name, press hello button,

00:42:20.060 --> 00:42:23.340
and then there was Hi,
IO session at the top.

00:42:23.340 --> 00:42:26.850
That was basically calling the
JavaScript client libraries,

00:42:26.850 --> 00:42:30.210
which were generated for
that particular back-up.

00:42:30.210 --> 00:42:32.810
And then regarding the
second question, yes.

00:42:32.810 --> 00:42:36.070
It automatically
generates a RESTful API

00:42:36.070 --> 00:42:37.720
from those annotations.

00:42:37.720 --> 00:42:40.140
And so if you
basically want to call

00:42:40.140 --> 00:42:44.300
that using some other things you
have to parcel adjacent objects

00:42:44.300 --> 00:42:47.130
and things like that, but you
still have full access to them.

00:42:47.130 --> 00:42:49.840
JATIN LODHIA: To answer your
first question, the Cloud save.

00:42:49.840 --> 00:42:54.000
It uses a special API
we created for doing

00:42:54.000 --> 00:42:56.400
a more optimized sync.

00:42:56.400 --> 00:42:58.770
AUDIENCE: OK, so
it wouldn't have--

00:42:58.770 --> 00:43:01.200
You couldn't use
these other access

00:43:01.200 --> 00:43:03.780
methods to work with Cloud Save?

00:43:03.780 --> 00:43:05.590
JATIN LODHIA: We could have.

00:43:05.590 --> 00:43:09.570
We just have other
infrastructure inside so--

00:43:12.500 --> 00:43:15.600
AUDIENCE: For larger assets
like JPEGs and stuff,

00:43:15.600 --> 00:43:17.150
if I have lots of
those, I should

00:43:17.150 --> 00:43:20.232
use this for the metadata
and something else for those?

00:43:20.232 --> 00:43:21.440
MANFRED ZABARAUSKAS: Correct.

00:43:21.440 --> 00:43:23.710
And a good place
to do that would

00:43:23.710 --> 00:43:28.050
be using Google Cloud Storage,
so the big object storage.

00:43:28.050 --> 00:43:29.540
And then expose an endpoint.

00:43:29.540 --> 00:43:31.730
Using kind of the first
half of this session,

00:43:31.730 --> 00:43:35.250
expose the endpoint which
just transmits the JPEG.

00:43:35.250 --> 00:43:39.190
AUDIENCE: So it looks you guys
support some spatial queries,

00:43:39.190 --> 00:43:40.120
like proximity.

00:43:40.120 --> 00:43:41.920
But can you give more details?

00:43:41.920 --> 00:43:43.460
Like what other kinds?

00:43:43.460 --> 00:43:46.355
You know, like
bounds or polygons?

00:43:49.004 --> 00:43:51.420
MANFRED ZABARAUSKAS: Yeah, so
if I understand the question

00:43:51.420 --> 00:43:54.430
correctly, it relates
to, how did we

00:43:54.430 --> 00:43:57.029
put the marker close
to the location?

00:43:57.029 --> 00:43:57.570
AUDIENCE: No.

00:43:57.570 --> 00:44:00.451
For example, I can
store points, right?

00:44:00.451 --> 00:44:00.950
Lat/Longs.

00:44:00.950 --> 00:44:02.158
MANFRED ZABARAUSKAS: Correct.

00:44:02.158 --> 00:44:05.200
AUDIENCE: And I could say hey,
can you grab me the nearest,

00:44:05.200 --> 00:44:07.527
like within 10 mile
radius, all of the points.

00:44:07.527 --> 00:44:08.610
MANFRED ZABARAUSKAS: Yeah.

00:44:08.610 --> 00:44:12.140
So what we had done there is
actually a custom backend code

00:44:12.140 --> 00:44:14.690
so you can literally
do whatever you want.

00:44:14.690 --> 00:44:18.720
For this actual demo, we
just generated the point

00:44:18.720 --> 00:44:21.210
to kind of randomly
within the radius.

00:44:21.210 --> 00:44:23.380
Don't tell that to anyone.

00:44:23.380 --> 00:44:24.520
I'm kidding.

00:44:24.520 --> 00:44:27.040
You'll see in the code, if
you watch the recording,

00:44:27.040 --> 00:44:31.360
it was just generated kind of
randomly within a mile radius

00:44:31.360 --> 00:44:32.580
around the current location.

00:44:32.580 --> 00:44:35.270
AUDIENCE: So you cannot
store geometry points

00:44:35.270 --> 00:44:37.450
on the database?

00:44:37.450 --> 00:44:38.770
JATIN LODHIA: You can.

00:44:38.770 --> 00:44:39.380
MANFRED ZABARAUSKAS:
You totally can.

00:44:39.380 --> 00:44:41.280
It's just we didn't use
it for this session.

00:44:41.280 --> 00:44:42.935
AUDIENCE: All right, Thanks.

00:44:42.935 --> 00:44:44.560
MANFRED ZABARAUSKAS:
One last question.

00:44:44.560 --> 00:44:46.990
AUDIENCE: So for the
L developer preview

00:44:46.990 --> 00:44:49.890
they introduced what
seemed like a new lifecycle

00:44:49.890 --> 00:44:52.050
to optimize battery use.

00:44:52.050 --> 00:44:54.840
Is this plugged into some of
the things from project Volta?

00:44:54.840 --> 00:44:57.000
Or you guys usually sync
adapters, kind of like,

00:44:57.000 --> 00:44:57.775
in the old way?

00:44:57.775 --> 00:44:59.650
JATIN LODHIA: Right now
we use sync adapters.

00:44:59.650 --> 00:45:05.270
And we do plan to use-- We
do actually use the new,

00:45:05.270 --> 00:45:07.840
it's called Task Scheduler,
GCM Task Scheduler--

00:45:07.840 --> 00:45:09.840
network [INAUDIBLE] I think.

00:45:09.840 --> 00:45:12.670
We do use that
for certain things

00:45:12.670 --> 00:45:16.700
which need us to delay
a sync in the future.

00:45:16.700 --> 00:45:20.210
AUDIENCE: Will this shift
over to the Volta approach

00:45:20.210 --> 00:45:22.564
going forward?

00:45:22.564 --> 00:45:23.480
JATIN LODHIA: Depends.

00:45:23.480 --> 00:45:26.220
When we need to
write, we would like

00:45:26.220 --> 00:45:29.210
to write as soon as
the network is up.

00:45:29.210 --> 00:45:32.220
So we would use the
Volta approach for it.

00:45:32.220 --> 00:45:36.880
But when we need to sync, based
on the remote notifications,

00:45:36.880 --> 00:45:38.877
we already have the
network up because we just

00:45:38.877 --> 00:45:39.960
received the notification.

00:45:39.960 --> 00:45:42.190
We just need to do a
sync at that point.

00:45:42.190 --> 00:45:44.377
So then it will
use a sync monitor.

00:45:44.377 --> 00:45:45.210
AUDIENCE: Thank you.

00:45:45.210 --> 00:45:45.510
MANFRED ZABARAUSKAS: All right.

00:45:45.510 --> 00:45:46.010
Cool.

00:45:46.010 --> 00:45:46.710
Thanks, guys.

00:45:46.710 --> 00:45:48.260
[APPLAUSE]

