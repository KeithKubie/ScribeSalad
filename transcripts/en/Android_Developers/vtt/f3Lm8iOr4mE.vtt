WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.440
[GOOGLE LOGO MUSIC]

00:00:04.320 --> 00:00:05.570
NICK BUTCHER: Hello, everyone.

00:00:05.570 --> 00:00:08.125
And welcome to my talk
today, Motional Intelligence.

00:00:08.125 --> 00:00:11.000
Where I'm going to tell you
all about how to build smarter

00:00:11.000 --> 00:00:12.980
animations.

00:00:12.980 --> 00:00:14.208
My name is Nick Butcher.

00:00:14.208 --> 00:00:15.500
And if this would click onward.

00:00:18.448 --> 00:00:19.023
Hello.

00:00:19.023 --> 00:00:19.690
AUDIENCE: Hello.

00:00:19.690 --> 00:00:21.940
NICK BUTCHER: Here we go.

00:00:21.940 --> 00:00:23.020
My name is Nick Butcher.

00:00:23.020 --> 00:00:26.110
I am an engineer on the Android
Developer Relations team.

00:00:26.110 --> 00:00:28.850
And I focus mostly on UI
design and development.

00:00:28.850 --> 00:00:32.570
So I spent a lot of
time on the main thread.

00:00:32.570 --> 00:00:34.550
I'm going to go through
a lot of code today.

00:00:34.550 --> 00:00:35.050
This is IO.

00:00:35.050 --> 00:00:36.580
That's what you want, right?

00:00:36.580 --> 00:00:39.040
But don't worry about
taking photos of the slides

00:00:39.040 --> 00:00:42.010
or worrying about
referring back later.

00:00:42.010 --> 00:00:44.525
All of this talk is going to
be uploaded later to this URL

00:00:44.525 --> 00:00:46.150
or if you're watching
on the recording,

00:00:46.150 --> 00:00:48.940
you can find it
right now, hopefully.

00:00:48.940 --> 00:00:50.410
So you can follow
along and they'll

00:00:50.410 --> 00:00:52.720
be gifs of codes and everything.

00:00:52.720 --> 00:00:56.470
So, today, I want to talk
to you about animations.

00:00:56.470 --> 00:01:01.150
I think animations are super
important, #animationsmatter.

00:01:01.150 --> 00:01:03.460
Often, I think animations
are thought of as delight,

00:01:03.460 --> 00:01:04.930
or polish, or
something sprinkled

00:01:04.930 --> 00:01:06.962
on at the end of the
development process.

00:01:06.962 --> 00:01:08.420
And I think that's
a massive shame.

00:01:08.420 --> 00:01:09.670
And I think that
contributes to the reason

00:01:09.670 --> 00:01:12.003
why they're often the first
things on the chopping block

00:01:12.003 --> 00:01:16.370
when the time is tight and
features are crunching.

00:01:16.370 --> 00:01:19.550
Animations, I think are
really important for usability

00:01:19.550 --> 00:01:20.450
of your application.

00:01:20.450 --> 00:01:22.940
They can explain a state
change so that the user

00:01:22.940 --> 00:01:24.690
knows what's going on.

00:01:24.690 --> 00:01:26.330
They can establish
a spatial model

00:01:26.330 --> 00:01:29.330
so that you have a sense of
place within the application.

00:01:29.330 --> 00:01:31.740
Or they can hint at how
you can interact with them.

00:01:31.740 --> 00:01:33.840
So they're very
important, in my opinion.

00:01:33.840 --> 00:01:37.220
But I think animations are
currently under threat.

00:01:37.220 --> 00:01:38.720
And that's due to
changes in the way

00:01:38.720 --> 00:01:41.450
that we are architecting
our applications.

00:01:41.450 --> 00:01:43.550
So there's a movement
towards having

00:01:43.550 --> 00:01:45.800
the controller of
your application

00:01:45.800 --> 00:01:47.450
be outside of the
view layer, right?

00:01:47.450 --> 00:01:49.250
And something like
a view model then

00:01:49.250 --> 00:01:52.280
publishes a state
of the application.

00:01:52.280 --> 00:01:55.400
So the UI model, view state,
whatever you might call it,

00:01:55.400 --> 00:01:58.400
is essentially the entire
state of your application

00:01:58.400 --> 00:02:02.197
needed to render on the screen.

00:02:02.197 --> 00:02:03.780
And as things change
in your back end,

00:02:03.780 --> 00:02:06.030
say a network request comes
in or the user performs

00:02:06.030 --> 00:02:09.930
an interaction, this updates
the state in your view model

00:02:09.930 --> 00:02:13.190
and they publish a new
version of this UI statement.

00:02:13.190 --> 00:02:15.440
There's lots of benefits to
this kind of architecture.

00:02:15.440 --> 00:02:17.565
Such as being able to reason
about the entire state

00:02:17.565 --> 00:02:19.863
of your application at once,
or easier testing, and so

00:02:19.863 --> 00:02:20.530
on and so forth.

00:02:20.530 --> 00:02:21.780
But I'm not going to
go into those today.

00:02:21.780 --> 00:02:24.240
I'll encourage you to check
out uni-directional data

00:02:24.240 --> 00:02:27.710
flow or patterns, such as MPI.

00:02:27.710 --> 00:02:29.730
Or even libraries,
such as Mavericks,

00:02:29.730 --> 00:02:32.610
or Mobius for helping
to implement this.

00:02:32.610 --> 00:02:35.130
What I do when I talk
about is the observers

00:02:35.130 --> 00:02:37.450
of this stream of
data at the other end.

00:02:37.450 --> 00:02:39.550
So when you get these
stream of UI models,

00:02:39.550 --> 00:02:42.720
you then need to bind
it into your views

00:02:42.720 --> 00:02:46.810
to set these values, to set
up the state of your views.

00:02:46.810 --> 00:02:49.030
Now, having the
stream of UI models

00:02:49.030 --> 00:02:50.590
is kind of like a pure function.

00:02:50.590 --> 00:02:53.550
You want to have this pure
input and perform an action.

00:02:53.550 --> 00:02:56.410
It essentially wants
to be very stateless.

00:02:56.410 --> 00:03:00.250
On the other side, animations
essentially, are very stateful.

00:03:00.250 --> 00:03:02.620
They want to know
all about setting

00:03:02.620 --> 00:03:04.810
a value from one value
to another value,

00:03:04.810 --> 00:03:06.633
over a period of time.

00:03:06.633 --> 00:03:08.800
So this, I think, is the
ultimate tension right now.

00:03:08.800 --> 00:03:10.450
With this move to
this new architecture

00:03:10.450 --> 00:03:13.780
it's becoming harder
to join these two state

00:03:13.780 --> 00:03:16.420
lessons stateful worlds.

00:03:16.420 --> 00:03:20.158
So today, I want to focus in on
some tools and some techniques

00:03:20.158 --> 00:03:21.700
that you can use in
your applications

00:03:21.700 --> 00:03:24.753
right now in order to
enable you to do animations.

00:03:24.753 --> 00:03:26.170
Because I think
that it's a shame.

00:03:26.170 --> 00:03:27.790
I think a lot of
people are finding

00:03:27.790 --> 00:03:29.470
it hard to kind of
square the circle.

00:03:29.470 --> 00:03:31.990
To kind of marry
these two models.

00:03:31.990 --> 00:03:34.450
And as such, I think
animations are under threat.

00:03:37.080 --> 00:03:39.120
So to look at these
tools and techniques,

00:03:39.120 --> 00:03:42.140
let's start off with a
simple minimum viable screen.

00:03:42.140 --> 00:03:44.320
Where we have some
kind of log on form.

00:03:44.320 --> 00:03:46.850
And when you hit log
on, and crucially, I

00:03:46.850 --> 00:03:48.680
want to hide the
Login button and show

00:03:48.680 --> 00:03:49.940
some kind of progress spinner.

00:03:49.940 --> 00:03:51.482
But I don't want it
just to blink out

00:03:51.482 --> 00:03:53.600
of visibility and change.

00:03:53.600 --> 00:03:58.460
I want it to animate out and
the spinner to animate in.

00:03:58.460 --> 00:04:00.678
So the UI model, the
state for the screen,

00:04:00.678 --> 00:04:01.970
might look something like this.

00:04:01.970 --> 00:04:04.387
A simple data class with a
couple of booleans about what's

00:04:04.387 --> 00:04:06.490
going on.

00:04:06.490 --> 00:04:09.410
And you can then bind
this into your view layer,

00:04:09.410 --> 00:04:12.760
to your application, using
some kind of library functions

00:04:12.760 --> 00:04:13.530
like this.

00:04:13.530 --> 00:04:15.640
Where set visibility
in this static well,

00:04:15.640 --> 00:04:17.800
before we animate it, to
something very simple,

00:04:17.800 --> 00:04:19.600
like setting the
views visibility

00:04:19.600 --> 00:04:21.850
and based on that boolean state.

00:04:21.850 --> 00:04:25.840
So how can we animate
something like this?

00:04:25.840 --> 00:04:29.040
So, an initial kind of
naive way to do this,

00:04:29.040 --> 00:04:30.690
might be something
like this, where

00:04:30.690 --> 00:04:33.780
we're just running an
animation to, in this example,

00:04:33.780 --> 00:04:35.730
fade in a view.

00:04:35.730 --> 00:04:38.700
Or when we're fading it out,
we have to, of course, set

00:04:38.700 --> 00:04:39.720
the visibility to gone.

00:04:39.720 --> 00:04:41.280
Because otherwise,
the button stays

00:04:41.280 --> 00:04:43.720
present in the hierarchy
receiving touches and so forth.

00:04:43.720 --> 00:04:44.400
So we all know this.

00:04:44.400 --> 00:04:45.120
We're all androiders.

00:04:45.120 --> 00:04:46.495
We have to use
the ALPHA property

00:04:46.495 --> 00:04:49.230
and then set the
visibility, as well.

00:04:49.230 --> 00:04:51.200
But doing something
like this might

00:04:51.200 --> 00:04:53.450
yield interesting results.

00:04:53.450 --> 00:04:55.990
Like for example, just doing
that it's actually running.

00:04:55.990 --> 00:04:58.310
And you can see every time
I do a key strike here,

00:04:58.310 --> 00:05:00.488
you see the spinner kind
of like shows up briefly

00:05:00.488 --> 00:05:01.280
and then fades out.

00:05:01.280 --> 00:05:02.758
Which is not what I wanted.

00:05:02.758 --> 00:05:04.550
Or if I managed to
actually finish the form

00:05:04.550 --> 00:05:06.848
and hit the login button,
we see some weirdness

00:05:06.848 --> 00:05:08.640
going on where they're
kind of overlapping.

00:05:08.640 --> 00:05:10.682
And then, all of the
sudden, both views are gone.

00:05:10.682 --> 00:05:12.890
I'm like, what's going on there?

00:05:12.890 --> 00:05:15.380
Essentially, what is going
on is with this model,

00:05:15.380 --> 00:05:18.347
where lots of updates have
been published at once,

00:05:18.347 --> 00:05:20.180
you can get into some
corner cases which you

00:05:20.180 --> 00:05:22.790
have to consider ahead of time.

00:05:22.790 --> 00:05:24.290
And I actually would
like to propose

00:05:24.290 --> 00:05:26.070
three kind of
principles, or tenants,

00:05:26.070 --> 00:05:28.753
which would make a good
animation in this world.

00:05:28.753 --> 00:05:30.920
Which are that they should
be reentrant, continuous,

00:05:30.920 --> 00:05:32.370
and smooth.

00:05:32.370 --> 00:05:33.720
Let's look at each of these.

00:05:33.720 --> 00:05:36.290
So the first, reentrant, is
a fancy computer science word

00:05:36.290 --> 00:05:39.020
for essentially
that your function

00:05:39.020 --> 00:05:42.820
should be able to be interrupted
and called again at any time.

00:05:42.820 --> 00:05:45.320
So essentially, we're saying,
if it was in this state, where

00:05:45.320 --> 00:05:47.540
a new model can be
published at any time

00:05:47.540 --> 00:05:50.760
and you're observing it, if
you're running animations,

00:05:50.760 --> 00:05:52.700
which also take
a period of time,

00:05:52.700 --> 00:05:56.180
you need to be prepared for
a model being published.

00:05:56.180 --> 00:05:58.350
And while the animation
is still running,

00:05:58.350 --> 00:06:02.150
you need to be able to
respond to them safely.

00:06:02.150 --> 00:06:04.062
The second one is continuous.

00:06:04.062 --> 00:06:06.020
And if you look at this
example of an animation

00:06:06.020 --> 00:06:10.253
here where this view is changing
scale and color as I touch it.

00:06:10.253 --> 00:06:12.920
I think it looks fine if I touch
it and it scales to completion.

00:06:12.920 --> 00:06:15.140
I let go and it scales
back to normal state.

00:06:15.140 --> 00:06:16.810
But if I touch kind
of rapidly, you

00:06:16.810 --> 00:06:20.300
can see it's jumping
in scale and color.

00:06:20.300 --> 00:06:23.255
And this kind of
discontinuity is very jarring.

00:06:23.255 --> 00:06:26.250
It can be very kind of abrupt,
this change to our users.

00:06:26.250 --> 00:06:29.430
Which doesn't lead to a very
pleasant user experience.

00:06:29.430 --> 00:06:32.570
Essentially, animations
are all about smoothly

00:06:32.570 --> 00:06:34.190
changing a value over time.

00:06:34.190 --> 00:06:36.213
That's kind of what
an animation is.

00:06:36.213 --> 00:06:38.630
If we're not kind of prepared
for this new value coming in

00:06:38.630 --> 00:06:40.520
at a certain time,
you can have something

00:06:40.520 --> 00:06:42.638
like this, where we're
midway through one curve

00:06:42.638 --> 00:06:44.180
and then suddenly
we jump and we have

00:06:44.180 --> 00:06:47.990
this discontinuity, which
leads to the most poor user

00:06:47.990 --> 00:06:50.350
experience.

00:06:50.350 --> 00:06:53.625
And the last tenant I want to
propose is one of smoothness.

00:06:53.625 --> 00:06:55.250
And by which I mean,
take this example,

00:06:55.250 --> 00:06:57.625
where I'm animating a view
to either the top left

00:06:57.625 --> 00:07:00.530
or top right, depending
on pushing this button.

00:07:00.530 --> 00:07:02.900
If now I hit the top
right button twice,

00:07:02.900 --> 00:07:05.930
you can see it slows down
and then animates again.

00:07:05.930 --> 00:07:10.160
Because a new event came in,
it kicked off a new animation.

00:07:10.160 --> 00:07:12.950
But because each animation
had the same duration,

00:07:12.950 --> 00:07:17.360
it leads to this kind of like
discontinuity in the velocity.

00:07:17.360 --> 00:07:18.080
So it slows down.

00:07:18.080 --> 00:07:20.103
And this kind of looks
kind of terrible.

00:07:20.103 --> 00:07:22.520
Similarly, if I try and retarget
it so it's going one way,

00:07:22.520 --> 00:07:24.160
and then I send it
off to the left,

00:07:24.160 --> 00:07:26.900
to the left then to the
right, you can see it just

00:07:26.900 --> 00:07:31.330
kind of stops suddenly and
then reverses direction.

00:07:31.330 --> 00:07:35.150
Now, nothing in the real world
has this instantaneous change

00:07:35.150 --> 00:07:36.230
in direction or velocity.

00:07:36.230 --> 00:07:40.020
And so this feels
very unnatural to us.

00:07:40.020 --> 00:07:43.173
So let's look at solving
these problems in our code.

00:07:43.173 --> 00:07:45.590
So first up, let's take a look
at that continuous property

00:07:45.590 --> 00:07:47.510
that it jumped midway through.

00:07:47.510 --> 00:07:50.330
And you can see here that I've
kind of made some assumptions.

00:07:50.330 --> 00:07:51.830
That when you want
to show something

00:07:51.830 --> 00:07:53.670
that I'm going to
animate its visibility,

00:07:53.670 --> 00:07:54.587
it's ALPHA properties.

00:07:54.587 --> 00:07:57.483
So from zero to
one or one to zero.

00:07:57.483 --> 00:07:59.150
So this is kind of
making the assumption

00:07:59.150 --> 00:08:00.450
of the current value.

00:08:00.450 --> 00:08:02.480
What we can do with
animators instead,

00:08:02.480 --> 00:08:04.140
is just remove
that initial value.

00:08:04.140 --> 00:08:07.660
So just say animate
to this value.

00:08:07.660 --> 00:08:10.370
And the way the object animator
and property system works

00:08:10.370 --> 00:08:13.040
is the property
here, ALPHA, both

00:08:13.040 --> 00:08:15.350
tells you how to set
the kind of animated

00:08:15.350 --> 00:08:18.210
value on the view, as well,
but also offers how to get it.

00:08:18.210 --> 00:08:19.790
So if you omit
the from value, it

00:08:19.790 --> 00:08:21.897
will read the
views current ALPHA

00:08:21.897 --> 00:08:23.980
and it'll start from there,
which is what we want.

00:08:23.980 --> 00:08:26.050
We don't want the
value to jump around.

00:08:26.050 --> 00:08:27.812
So that was easily solved.

00:08:27.812 --> 00:08:29.770
But let's take a look at
the reentrant problem.

00:08:29.770 --> 00:08:32.038
That's slightly thornier.

00:08:32.038 --> 00:08:33.580
So the reentrant
property essentially

00:08:33.580 --> 00:08:36.250
is that we want to be able
to call this at any time

00:08:36.250 --> 00:08:38.590
and not have any kind of side
effects lingering around.

00:08:38.590 --> 00:08:40.720
So, essentially, what we need to
do is clean up after ourselves.

00:08:40.720 --> 00:08:42.970
We need to kind of cancel
any running animation that's

00:08:42.970 --> 00:08:44.450
going on.

00:08:44.450 --> 00:08:46.475
But, if you look
at this code here,

00:08:46.475 --> 00:08:48.850
we're not actually holding a
reference to the animations,

00:08:48.850 --> 00:08:49.030
right?

00:08:49.030 --> 00:08:51.160
We just create them,
and call start, and then

00:08:51.160 --> 00:08:51.940
forget about them.

00:08:51.940 --> 00:08:55.050
There's no reference
held onto it.

00:08:55.050 --> 00:08:58.290
So what we can do is fix that.

00:08:58.290 --> 00:09:00.900
Actually, first,
before that, then let's

00:09:00.900 --> 00:09:02.970
not run an animation
if we don't need to.

00:09:02.970 --> 00:09:05.870
So in that instance, where I
was typing, typing, typing.

00:09:05.870 --> 00:09:07.410
And it was all
those times saying,

00:09:07.410 --> 00:09:10.188
I want the spinner
to be invisible.

00:09:10.188 --> 00:09:11.730
It was always running
that animation.

00:09:11.730 --> 00:09:13.980
But we want to actually
skip that animation

00:09:13.980 --> 00:09:14.870
if you don't need to.

00:09:14.870 --> 00:09:17.720
So here, what we're simply doing
is saying, if we are targeting,

00:09:17.720 --> 00:09:19.470
if we're going to
go fade out to zero,

00:09:19.470 --> 00:09:22.550
if it's already faded out, just
return early, so bail early.

00:09:22.550 --> 00:09:26.000
So short circuit the method.

00:09:26.000 --> 00:09:30.700
But if we wanted to cancel
a running animation that's

00:09:30.700 --> 00:09:32.278
kind of like mid
progress, then we

00:09:32.278 --> 00:09:33.820
need to kind of
store it somewhere so

00:09:33.820 --> 00:09:37.230
that we can have access to
the animator to cancel it.

00:09:37.230 --> 00:09:40.460
Such that when a new
invocation comes around,

00:09:40.460 --> 00:09:44.080
we can cancel any running
animations before setting up

00:09:44.080 --> 00:09:45.677
the new animation.

00:09:45.677 --> 00:09:46.510
So we could do this.

00:09:46.510 --> 00:09:47.140
We could store it somewhere.

00:09:47.140 --> 00:09:48.348
But where would you store it?

00:09:48.348 --> 00:09:50.920
These functions are essentially
kind of pure functions,

00:09:50.920 --> 00:09:52.690
as kind of static.

00:09:52.690 --> 00:09:56.620
So the only option really is
to store it in the view itself.

00:09:56.620 --> 00:09:59.693
But view already offers
such a method for this.

00:09:59.693 --> 00:10:02.110
It actually has something
called a view property animator.

00:10:02.110 --> 00:10:04.780
Which is [INAUDIBLE] term
would call, View to Animate.

00:10:04.780 --> 00:10:09.620
Which allows you to get
access to retrieve any running

00:10:09.620 --> 00:10:10.990
animations.

00:10:10.990 --> 00:10:13.300
So if we swap out our code
from using object animator

00:10:13.300 --> 00:10:16.420
to using
ViewPropertyAnimator instead,

00:10:16.420 --> 00:10:18.620
then we get some of
these properties.

00:10:18.620 --> 00:10:22.090
So what happens here is when
you call view to animate,

00:10:22.090 --> 00:10:23.830
if there's already
an animation running

00:10:23.830 --> 00:10:26.650
over that same property,
it will be canceled for us.

00:10:26.650 --> 00:10:28.780
And then the new
animation will be run.

00:10:28.780 --> 00:10:31.360
So that's exactly what we want.

00:10:31.360 --> 00:10:34.000
Even more,
ViewPropertyAnimator offers

00:10:34.000 --> 00:10:37.630
this with end action API,
which takes a runable.

00:10:37.630 --> 00:10:41.560
So the cool thing about
this is this action

00:10:41.560 --> 00:10:44.800
will only be invoked if the
animation runs to completion.

00:10:44.800 --> 00:10:47.020
It won't be invoked if
the animation is canceled.

00:10:47.020 --> 00:10:50.800
So if a new value comes in, then
the old animation is canceled.

00:10:50.800 --> 00:10:53.770
And the action only
runs if it completes,

00:10:53.770 --> 00:10:57.930
which is exactly the kind
of properties that we want.

00:10:57.930 --> 00:11:00.630
There's still a few problems
with the system here, though.

00:11:00.630 --> 00:11:02.943
So what happens if we're
midway through an animation?

00:11:02.943 --> 00:11:04.360
Well, we just said
that it's going

00:11:04.360 --> 00:11:07.350
to cancel the previous
animation and run a new one.

00:11:07.350 --> 00:11:09.960
So that's going to violate
our smooth property

00:11:09.960 --> 00:11:12.720
because if we're already
animating the right target

00:11:12.720 --> 00:11:15.560
value and a new value comes in,
it will still kind of cancel

00:11:15.560 --> 00:11:16.590
it and start again.

00:11:16.590 --> 00:11:20.540
So you'll get this kind
of stutter change in it.

00:11:20.540 --> 00:11:23.020
We could, for example,
store the current value

00:11:23.020 --> 00:11:26.540
that the animator is running,
is currently animating to.

00:11:26.540 --> 00:11:28.620
And if a new update to
the same value comes in,

00:11:28.620 --> 00:11:30.252
we could perhaps,
skip that update.

00:11:30.252 --> 00:11:32.210
But that's not going to
help us out in the case

00:11:32.210 --> 00:11:34.940
where we're trying to retarget
to a new value that comes in.

00:11:34.940 --> 00:11:37.610
We wait for an animation.

00:11:37.610 --> 00:11:40.612
So how are we going to solve
this problem of smoothness?

00:11:40.612 --> 00:11:42.320
And there's actually
a library out there,

00:11:42.320 --> 00:11:43.695
which I think a
lot of developers

00:11:43.695 --> 00:11:45.570
haven't really paid
much attention to,

00:11:45.570 --> 00:11:50.043
which is the physics based
property and animation system.

00:11:50.043 --> 00:11:51.710
And I think maybe
people have skipped it

00:11:51.710 --> 00:11:53.690
because we look at
some of the samples,

00:11:53.690 --> 00:11:56.360
or demos, or even our
developer documentation here.

00:11:56.360 --> 00:11:58.460
And they see things like
these bouncy animations

00:11:58.460 --> 00:12:01.790
and think, hey, that's fine if
I want to make a bouncy effect.

00:12:01.790 --> 00:12:05.540
But it's not for me for
general UI animation.

00:12:05.540 --> 00:12:08.090
That's a shame because you can
actually very easily turn off

00:12:08.090 --> 00:12:09.290
the bounciness.

00:12:09.290 --> 00:12:12.777
And what's left is a very
powerful physics-based system,

00:12:12.777 --> 00:12:14.360
which has a number
of properties which

00:12:14.360 --> 00:12:15.777
are useful for
these kind of cases

00:12:15.777 --> 00:12:18.538
that we're trying to solve.

00:12:18.538 --> 00:12:21.080
So, for example, if we return
to our square going to the left

00:12:21.080 --> 00:12:24.950
or right and we run it
with a physics based spring

00:12:24.950 --> 00:12:27.408
system underneath,
because it has

00:12:27.408 --> 00:12:28.700
a physics system underneath it.

00:12:28.700 --> 00:12:30.440
When you retarget
it to a new value,

00:12:30.440 --> 00:12:32.727
it maintains things, like
the velocity, for you.

00:12:32.727 --> 00:12:34.310
And it gives us these
properties we're

00:12:34.310 --> 00:12:37.547
looking for where if you try
and go to the same place twice,

00:12:37.547 --> 00:12:38.630
it maintains the velocity.

00:12:38.630 --> 00:12:40.550
Even though it's
starting a new animation.

00:12:40.550 --> 00:12:43.610
Or if you retarget to
another destination,

00:12:43.610 --> 00:12:45.780
it slows down and
changes direction very,

00:12:45.780 --> 00:12:50.775
very smoothly by maintaining
the velocity for you.

00:12:50.775 --> 00:12:52.150
So you haven't
looked at springs,

00:12:52.150 --> 00:12:55.450
the API looks very similar
to the animated system,

00:12:55.450 --> 00:12:58.780
where you have a
subject being animated,

00:12:58.780 --> 00:13:01.460
a property which you want to
animate, hit the translation

00:13:01.460 --> 00:13:05.580
X, a target value, and
then you call start on it.

00:13:05.580 --> 00:13:07.280
But, for me, the
real power comes

00:13:07.280 --> 00:13:09.500
when instead of using
start, you use this animate

00:13:09.500 --> 00:13:11.840
to final position API.

00:13:11.840 --> 00:13:14.210
What this does is if the
animation isn't started,

00:13:14.210 --> 00:13:15.950
it will just kick it off.

00:13:15.950 --> 00:13:20.040
But, crucially, if an
animation is running,

00:13:20.040 --> 00:13:21.380
then it will retarget it.

00:13:21.380 --> 00:13:24.740
And this will do that magic of
maintaining the velocity for us

00:13:24.740 --> 00:13:28.140
and updating the target value.

00:13:28.140 --> 00:13:30.880
So the key thing there was
if the animation was already

00:13:30.880 --> 00:13:31.380
running.

00:13:31.380 --> 00:13:33.890
So we want something like
that view property animator

00:13:33.890 --> 00:13:36.110
we saw before, which
held onto a reference

00:13:36.110 --> 00:13:38.930
to any running animation,
such that we can access it,

00:13:38.930 --> 00:13:41.590
and cancel it, or update it.

00:13:41.590 --> 00:13:45.770
But, unfortunately, view doesn't
have a get spring method,

00:13:45.770 --> 00:13:48.570
or like animate has, so
that you can return you

00:13:48.570 --> 00:13:50.670
to a handy one of these.

00:13:50.670 --> 00:13:52.850
So let's build one.

00:13:52.850 --> 00:13:54.518
And so this is an
extension property

00:13:54.518 --> 00:13:56.310
I've been playing with,
extension function,

00:13:56.310 --> 00:13:59.480
excuse me, adding on view.

00:13:59.480 --> 00:14:01.407
Whereby you posit a
property, a view property,

00:14:01.407 --> 00:14:02.240
you want to animate.

00:14:02.240 --> 00:14:04.700
Such things like, translation
x, or ALPHA, or so on.

00:14:04.700 --> 00:14:07.280
And it will return you
a spring animation.

00:14:07.280 --> 00:14:10.700
And what I do is I
stash the running spring

00:14:10.700 --> 00:14:14.000
as a tag on the view,
so it can hold onto it.

00:14:14.000 --> 00:14:18.310
So going for it here, what I do
is I map the property to a key,

00:14:18.310 --> 00:14:20.090
such that you can
store it in the tag,

00:14:20.090 --> 00:14:22.670
and then try and retrieve it
from the view's tag system.

00:14:22.670 --> 00:14:24.087
So if there's one
already running,

00:14:24.087 --> 00:14:25.400
we'll get access to that.

00:14:25.400 --> 00:14:27.770
Or if there isn't
one already set up,

00:14:27.770 --> 00:14:30.560
already stored, then we'll
create a new spring animation

00:14:30.560 --> 00:14:34.110
and store it in the views
tag, and then return it.

00:14:34.110 --> 00:14:36.380
So a handy little,
small extension function

00:14:36.380 --> 00:14:38.690
like this that
helps you get access

00:14:38.690 --> 00:14:41.140
to a spring for a given view.

00:14:41.140 --> 00:14:43.700
And what that means is that
we can, at the call site,

00:14:43.700 --> 00:14:45.830
have a nice clean
something like this.

00:14:45.830 --> 00:14:49.790
Well, we just do view.spring
for the translation x.

00:14:49.790 --> 00:14:52.640
And, crucially, this will
either return you a new spring

00:14:52.640 --> 00:14:56.070
animation or one
that's already running,

00:14:56.070 --> 00:14:57.660
which is exactly what we want.

00:14:57.660 --> 00:15:01.380
And then we can use that
animator final position syntax

00:15:01.380 --> 00:15:03.950
to update your
running animation.

00:15:03.950 --> 00:15:06.590
So what might this look
like in our binding function

00:15:06.590 --> 00:15:08.040
that we're talking about?

00:15:08.040 --> 00:15:10.400
So, here we are, we are using
the ViewPropertyAnimator.

00:15:10.400 --> 00:15:12.800
We can sub this out using
the extension function.

00:15:12.800 --> 00:15:16.160
And grab access, or
create a new spring,

00:15:16.160 --> 00:15:19.568
and animate it to the
final value that we want.

00:15:19.568 --> 00:15:21.110
The eagle eyed
amongst you might have

00:15:21.110 --> 00:15:23.540
noticed I kind of regressed
in functionality there.

00:15:23.540 --> 00:15:25.520
We lost the end listener.

00:15:25.520 --> 00:15:27.260
You can of course,
still do this.

00:15:27.260 --> 00:15:30.600
This Spring animation system
has listeners, as well.

00:15:30.600 --> 00:15:32.470
So, here, we can add
this endless notice

00:15:32.470 --> 00:15:35.880
set the visibility
to gone at the end.

00:15:35.880 --> 00:15:37.400
But there's a slight
caveat in that,

00:15:37.400 --> 00:15:39.980
in order to remove a listener,
which we would have to do,

00:15:39.980 --> 00:15:43.250
but at first, ahead of time,
you need a hard reference to it.

00:15:43.250 --> 00:15:45.950
You can't just call clear or
any such method like this.

00:15:45.950 --> 00:15:49.998
So we need to
store the listener.

00:15:49.998 --> 00:15:52.040
Again, I'm using the view
tag here as a handy way

00:15:52.040 --> 00:15:55.550
to stash it in the view,
such that before setting up

00:15:55.550 --> 00:16:00.010
a new animation, we can cancel
any previous end listeners.

00:16:00.010 --> 00:16:00.805
So it's a bit of--

00:16:00.805 --> 00:16:02.722
tag, that you have
to be a bit careful,

00:16:02.722 --> 00:16:04.180
the way you write
these animations.

00:16:04.180 --> 00:16:07.690
That you have to be careful that
they are reentrant, especially.

00:16:07.690 --> 00:16:10.330
But the nice thing is that
you can write these functions,

00:16:10.330 --> 00:16:12.470
there's only like a handful
these functions you need to do.

00:16:12.470 --> 00:16:14.887
You need to write one for like
ALPHA, one for translation,

00:16:14.887 --> 00:16:16.860
one for scale,
whatever it might be.

00:16:16.860 --> 00:16:18.753
And you stash them
in the library.

00:16:18.753 --> 00:16:20.920
And then you can use them
throughout your code base.

00:16:20.920 --> 00:16:22.120
Use them in a number of places.

00:16:22.120 --> 00:16:23.578
You just write them
a couple times,

00:16:23.578 --> 00:16:27.553
end correctly, and then
use them throughout.

00:16:27.553 --> 00:16:28.970
Now, looking at
springs, I've kind

00:16:28.970 --> 00:16:30.637
of simplified the
creation a little bit.

00:16:30.637 --> 00:16:33.467
So just like when you create
an object animator or viewport

00:16:33.467 --> 00:16:35.300
animator, you're probably
customizing things

00:16:35.300 --> 00:16:37.997
like the interpolation
or the duration.

00:16:37.997 --> 00:16:39.830
And Springs don't really
have those concepts

00:16:39.830 --> 00:16:40.820
because they're physics based.

00:16:40.820 --> 00:16:42.903
They have kind of things
that describe the physics

00:16:42.903 --> 00:16:44.210
system underneath it.

00:16:44.210 --> 00:16:47.060
So, as such, you probably want
to do like customize the spring

00:16:47.060 --> 00:16:50.405
forces to set the damping
ratio and the stiffness.

00:16:50.405 --> 00:16:52.280
So the damping ratio
controls that bounciness

00:16:52.280 --> 00:16:53.300
we just talked about.

00:16:53.300 --> 00:16:57.050
And the stiffness controls
how fast the spring

00:16:57.050 --> 00:16:59.795
moves to equilibrium state.

00:16:59.795 --> 00:17:01.170
So if you don't
set these, you'll

00:17:01.170 --> 00:17:02.550
get these default values.

00:17:02.550 --> 00:17:05.740
And these kind of like medium
bouncy, or medium stiffness,

00:17:05.740 --> 00:17:09.140
which is kind of what we
saw in the example before.

00:17:09.140 --> 00:17:10.890
But I found this in
kind of default values

00:17:10.890 --> 00:17:13.020
that are generally
applicable for UI work.

00:17:13.020 --> 00:17:16.050
So I added these to
the extension function

00:17:16.050 --> 00:17:20.849
to make it very easy to get
this default behavior that

00:17:20.849 --> 00:17:22.020
works well for most cases.

00:17:22.020 --> 00:17:24.150
So turning off the
bounciness altogether

00:17:24.150 --> 00:17:26.861
and sending a slightly
higher stiffness ratio.

00:17:26.861 --> 00:17:28.319
But because the
default parameters,

00:17:28.319 --> 00:17:29.670
it makes it super
easy that you can just

00:17:29.670 --> 00:17:31.680
pass an alternate
value at the call site.

00:17:31.680 --> 00:17:33.690
If you want to customize
the animation to make

00:17:33.690 --> 00:17:36.820
it slightly snappier,
for example.

00:17:36.820 --> 00:17:39.710
So to give you a
real example of this,

00:17:39.710 --> 00:17:42.745
we're going to take a look at
a RecyclerView ItemAnimator.

00:17:42.745 --> 00:17:44.870
So RecyclerView does a lot
of stuff for you, right?

00:17:44.870 --> 00:17:48.110
So using DiffUtil, and fine
grained adapter updates,

00:17:48.110 --> 00:17:50.288
it'll give you free
animations, essentially.

00:17:50.288 --> 00:17:51.830
So in this example,
I've got the grid

00:17:51.830 --> 00:17:52.970
and then when I hit
the shuffle button,

00:17:52.970 --> 00:17:54.562
it's moving some items around.

00:17:54.562 --> 00:17:56.270
So this is with the
default ItemAnimator.

00:17:56.270 --> 00:17:59.660
And you can see it's got
that kind of discontinuous,

00:17:59.660 --> 00:18:01.040
or not very smooth--

00:18:01.040 --> 00:18:03.290
so it is continuous,
but not very smooth,

00:18:03.290 --> 00:18:05.420
animations when items come in.

00:18:05.420 --> 00:18:08.400
We can sort this out for this
kind of spring based system.

00:18:08.400 --> 00:18:10.820
And we can see that when item,
the new updates, come in,

00:18:10.820 --> 00:18:14.090
you can see that they smoothly
animate the final place.

00:18:14.090 --> 00:18:16.880
And this might seem like a
kind of toy example for slides.

00:18:16.880 --> 00:18:18.470
But this is probably quite
close to what's actually

00:18:18.470 --> 00:18:19.428
happening in your apps.

00:18:19.428 --> 00:18:21.440
How many apps grab
stuff from the internet

00:18:21.440 --> 00:18:23.183
and shove it into
a RecyclerView.

00:18:23.183 --> 00:18:25.850
And, you know, this is obviously
like an asynchronous operation.

00:18:25.850 --> 00:18:27.500
So updates can come
in at any time.

00:18:27.500 --> 00:18:30.980
Or maybe you scroll and new
information is coming in.

00:18:30.980 --> 00:18:33.800
By kind of thinking about and
making the animations that

00:18:33.800 --> 00:18:36.320
happen when this asynchronous
data kind of comes

00:18:36.320 --> 00:18:38.870
back as smooth as
possible, you can really

00:18:38.870 --> 00:18:42.590
kind of improve the user
experience in your app.

00:18:42.590 --> 00:18:45.470
And so this is a kind of
a slight simplification

00:18:45.470 --> 00:18:48.510
of the code because extending
default ItemAnimator

00:18:48.510 --> 00:18:50.460
is a little bit involved.

00:18:50.460 --> 00:18:53.803
But, essentially, it comes down
to setting up some translations

00:18:53.803 --> 00:18:55.970
on some views and then,
when you went to animate it,

00:18:55.970 --> 00:18:58.565
you just animate those
translations back down to zero.

00:18:58.565 --> 00:19:01.190
So we just used that exact same
extension function we looked up

00:19:01.190 --> 00:19:04.430
before to create or grab
an already running spring

00:19:04.430 --> 00:19:06.590
animation over the
translation properties

00:19:06.590 --> 00:19:08.215
and animate them down to zero.

00:19:08.215 --> 00:19:09.590
And this is,
essentially, what it

00:19:09.590 --> 00:19:12.633
gets to give you that kind
of nice smooth behavior.

00:19:12.633 --> 00:19:14.300
And I'll put this in
gifs in case anyone

00:19:14.300 --> 00:19:17.130
wants to take a look.

00:19:17.130 --> 00:19:19.440
So we just looked at
kind of general approach

00:19:19.440 --> 00:19:21.270
to how to animate
few properties.

00:19:21.270 --> 00:19:23.220
But view properties
aren't the only things

00:19:23.220 --> 00:19:24.595
that you want to
animate and have

00:19:24.595 --> 00:19:27.400
respond to kind of new
states of your application.

00:19:27.400 --> 00:19:29.580
Let's go and take a
look at a few classes

00:19:29.580 --> 00:19:31.080
that you should be
aware of that can

00:19:31.080 --> 00:19:34.110
help you to do this in other
parts of your application.

00:19:34.110 --> 00:19:38.160
So, drawables, for example,
often want to set their state.

00:19:38.160 --> 00:19:39.660
But you don't always
want that to be

00:19:39.660 --> 00:19:40.980
just kind of a static state.

00:19:40.980 --> 00:19:43.243
You sometimes want to
animate those changes.

00:19:43.243 --> 00:19:44.910
I think everyone is
familiar, hopefully,

00:19:44.910 --> 00:19:46.980
with this stateless
drawable class.

00:19:46.980 --> 00:19:50.400
So you can define in a check
state, I want this drawable,

00:19:50.400 --> 00:19:52.470
and, in an unchecked state,
I want that drawable.

00:19:52.470 --> 00:19:53.970
But I don't think
as many people are

00:19:53.970 --> 00:19:56.330
super familiar with the
animated version of this.

00:19:56.330 --> 00:19:59.065
So this was introduced
in LOLLIPOP API 21.

00:19:59.065 --> 00:20:00.460
But it's also part of Jetpacks.

00:20:00.460 --> 00:20:02.510
So you can use it back to '16.

00:20:02.510 --> 00:20:05.550
And so this lets you, in
addition to those [INAUDIBLE]

00:20:05.550 --> 00:20:07.800
states, it lets you
name the states in order

00:20:07.800 --> 00:20:10.140
that you can provide a
transition when moving

00:20:10.140 --> 00:20:12.000
between any of those states.

00:20:12.000 --> 00:20:13.710
And these transitions
the drawable here

00:20:13.710 --> 00:20:16.950
can be in the form of an
animated vector drawable,

00:20:16.950 --> 00:20:18.045
or an animation drawable.

00:20:18.045 --> 00:20:21.630
Kind of like a frame sequence.

00:20:21.630 --> 00:20:23.710
So, then, the calling
code becomes super simple.

00:20:23.710 --> 00:20:25.110
So in your binding,
you just have

00:20:25.110 --> 00:20:28.680
to set, say the check state,
to something in your UI model.

00:20:28.680 --> 00:20:30.450
And the class itself,
under the hood,

00:20:30.450 --> 00:20:34.350
will take care of running the
transition that you defined

00:20:34.350 --> 00:20:35.423
for it.

00:20:35.423 --> 00:20:36.840
So this looks
something like this.

00:20:36.840 --> 00:20:39.270
So this is from the Android
Developer summer application

00:20:39.270 --> 00:20:41.140
where you're tapping
the start and rather

00:20:41.140 --> 00:20:43.910
than it just changing, you get
this kind of scale animation.

00:20:43.910 --> 00:20:46.103
That can be used like
pretty much everywhere

00:20:46.103 --> 00:20:47.020
you can use drawables.

00:20:47.020 --> 00:20:49.020
So in the bottom
navigation view,

00:20:49.020 --> 00:20:51.460
for example, when you
select a section that

00:20:51.460 --> 00:20:54.360
gets into the checked
or selected state,

00:20:54.360 --> 00:20:56.735
I forget which, gets set
and we can set a transition

00:20:56.735 --> 00:20:58.110
for running between
those states.

00:20:58.110 --> 00:21:01.530
These nice little animations,
as you enter the state.

00:21:01.530 --> 00:21:03.810
And all of this is
completely declarative.

00:21:03.810 --> 00:21:05.820
So all I have to
do is set the icon

00:21:05.820 --> 00:21:08.430
to an AnimatedStateListDrawable,
like this.

00:21:08.430 --> 00:21:09.600
And I'll get this behavior.

00:21:09.600 --> 00:21:12.250
I don't have to maintain the
state or worry about what state

00:21:12.250 --> 00:21:12.750
it was in.

00:21:12.750 --> 00:21:14.500
It will get canceled
for me or the new one

00:21:14.500 --> 00:21:17.150
will get set for
me, automatically.

00:21:17.150 --> 00:21:18.900
And we can actually
extend these behaviors

00:21:18.900 --> 00:21:22.140
and produce some quite
powerful effects.

00:21:22.140 --> 00:21:27.030
So this is the book,
reserve a spot,

00:21:27.030 --> 00:21:29.550
button from the Google I/O
application, which, I guess,

00:21:29.550 --> 00:21:32.190
everyone in this room
has probably used.

00:21:32.190 --> 00:21:34.140
So like reserving
a spot in a session

00:21:34.140 --> 00:21:35.910
is quite a critical
action, right?

00:21:35.910 --> 00:21:39.040
We don't want to just update the
UI optimistically and say, hey,

00:21:39.040 --> 00:21:40.830
you got a ticket, when
you might not have.

00:21:40.830 --> 00:21:43.200
We want to actually
do a network request

00:21:43.200 --> 00:21:46.600
and confirm that you got a seat
before we tell people that.

00:21:46.600 --> 00:21:49.252
Or, that you know, if you're
being wait listed or something.

00:21:49.252 --> 00:21:51.210
So you know, there's
quite a lot of information

00:21:51.210 --> 00:21:52.982
being communicated
in this button.

00:21:52.982 --> 00:21:54.690
But this is actually
[INAUDIBLE] entirely

00:21:54.690 --> 00:21:58.250
by a single
AnimatedStateListDrawable.

00:21:58.250 --> 00:22:02.010
And so you can see
here that we have

00:22:02.010 --> 00:22:04.812
some states in there that have
the different drawable states.

00:22:04.812 --> 00:22:06.520
But you might be
looking at and thinking,

00:22:06.520 --> 00:22:08.400
what state reserved
or state wait listed?

00:22:08.400 --> 00:22:10.540
I've never seen those on
Android classes before.

00:22:10.540 --> 00:22:12.540
That's because, I'm not
sure how many people are

00:22:12.540 --> 00:22:14.415
familiar with the fact,
that you can actually

00:22:14.415 --> 00:22:16.350
add your own states,
two views, which

00:22:16.350 --> 00:22:18.852
can be super powerful if
you want to then use it

00:22:18.852 --> 00:22:20.310
in conjunction with
this technique,

00:22:20.310 --> 00:22:21.840
like an
AnimatedStateListDrawable.

00:22:21.840 --> 00:22:25.470
So this can then power
running the right transition

00:22:25.470 --> 00:22:29.860
whenever you set one of your
custom states onto a view.

00:22:29.860 --> 00:22:31.720
And the way you do
this is, it looks

00:22:31.720 --> 00:22:34.840
quite similar to defining custom
attributes for a custom view.

00:22:34.840 --> 00:22:39.760
You can define it in at as file,
the states you want to support.

00:22:39.760 --> 00:22:42.490
And then we actually wrapped
up this behavior into an enum

00:22:42.490 --> 00:22:44.170
because there were a few
things we wanted to change

00:22:44.170 --> 00:22:45.520
when the button changes state.

00:22:45.520 --> 00:22:49.613
So not just the state that's
kind of this attribute state,

00:22:49.613 --> 00:22:51.280
but also we wanted
to change the content

00:22:51.280 --> 00:22:52.660
description or
some text that gets

00:22:52.660 --> 00:22:53.785
displayed with the buttons.

00:22:53.785 --> 00:22:55.680
We wrap this all up
into a enum of states

00:22:55.680 --> 00:23:00.340
and setting the attributes
of a state, as well

00:23:00.340 --> 00:23:02.080
as these other things.

00:23:02.080 --> 00:23:06.760
Then we extend the AppCompat
button, image button class,

00:23:06.760 --> 00:23:09.873
in this case, and do
a couple of things.

00:23:09.873 --> 00:23:11.290
First, we expose
a property, which

00:23:11.290 --> 00:23:12.820
is one of these enum values.

00:23:12.820 --> 00:23:14.950
And crucially, in that
whenever that changes,

00:23:14.950 --> 00:23:17.290
we call refresh drawable state.

00:23:17.290 --> 00:23:19.430
This is your hook into the
view system to say, hey,

00:23:19.430 --> 00:23:20.650
my state has changed.

00:23:20.650 --> 00:23:23.650
And that, in turn, will
kick off the later updates

00:23:23.650 --> 00:23:26.445
to actually run the transitions.

00:23:26.445 --> 00:23:27.820
The other thing
you have to do is

00:23:27.820 --> 00:23:30.098
you have to override on
create drawable state, which

00:23:30.098 --> 00:23:32.140
is essentially how you're
telling the system what

00:23:32.140 --> 00:23:34.220
state you are currently in.

00:23:34.220 --> 00:23:36.880
So here you have to call this
merge, drawable states method,

00:23:36.880 --> 00:23:38.750
and pass in your current state.

00:23:38.750 --> 00:23:40.630
This is the kind of
attribute resource, which

00:23:40.630 --> 00:23:42.260
if I expand it out
from the enum value,

00:23:42.260 --> 00:23:47.420
is this inter array of the
state that you're currently in.

00:23:47.420 --> 00:23:51.050
So, by doing this, we can get
some pretty powerful behavior.

00:23:51.050 --> 00:23:55.970
So we can have these transitions
between all these given states.

00:23:55.970 --> 00:23:59.528
But, as you saw, you know,
this can get quite a lot

00:23:59.528 --> 00:24:01.070
because there's six
different states.

00:24:01.070 --> 00:24:03.110
If you want to be able
to animate between each

00:24:03.110 --> 00:24:04.610
and every one of those
states, you basically

00:24:04.610 --> 00:24:05.930
end it with an m by n problem.

00:24:05.930 --> 00:24:10.400
So you'd have to kind of define
36 different transitions, which

00:24:10.400 --> 00:24:12.120
sounds pretty hard.

00:24:12.120 --> 00:24:14.120
So what we did
instead, is we had

00:24:14.120 --> 00:24:16.520
a policy of always going
through an intermediary state,

00:24:16.520 --> 00:24:18.728
this pending state, where
you see the hourglass going

00:24:18.728 --> 00:24:19.700
round and round.

00:24:19.700 --> 00:24:24.050
So, as such, if you want to go
from reservable to reserved,

00:24:24.050 --> 00:24:26.300
you always go through
this intermediary state.

00:24:26.300 --> 00:24:29.480
And that in fact, cut down
the number of transitions

00:24:29.480 --> 00:24:32.900
that we had to run from
m by n to just 2 n.

00:24:32.900 --> 00:24:35.330
So we only had to write
12 animated vectors.

00:24:35.330 --> 00:24:37.760
Luckily, I like writing
animated vectors.

00:24:37.760 --> 00:24:42.680
And if you're lucky enough to
be running on API 23 or beyond,

00:24:42.680 --> 00:24:45.600
as your main SDK, then
you can use the platforms

00:24:45.600 --> 00:24:47.790
AnimatedVectorDrawable
class instead of the support

00:24:47.790 --> 00:24:50.990
libraries one, which
also supports reversing.

00:24:50.990 --> 00:24:53.400
So you can only right n just
six different transitions

00:24:53.400 --> 00:24:55.690
and have them reverse when
going in the opposite direction.

00:24:55.690 --> 00:24:57.982
But I guess most people aren't
in that world, just yet.

00:25:00.113 --> 00:25:01.780
One note about doing
this kind of thing,

00:25:01.780 --> 00:25:04.360
is that we wanted to have this
nice intermediate state, where

00:25:04.360 --> 00:25:06.940
it's, like, animating
the hourglass.

00:25:06.940 --> 00:25:11.110
One current limitation of the
animated vector drawable class

00:25:11.110 --> 00:25:15.280
is that you can't set a repeat
count on an animators set.

00:25:15.280 --> 00:25:18.360
You can only set it on Leaf
animator, object animators.

00:25:18.360 --> 00:25:21.130
So here where I'm saying that
the repeat counts as minus 1,

00:25:21.130 --> 00:25:22.420
which is infinite.

00:25:22.420 --> 00:25:24.125
So it is infinitely animate.

00:25:24.125 --> 00:25:26.500
You have to be able to structure
animations in such a way

00:25:26.500 --> 00:25:29.390
to achieve this.

00:25:29.390 --> 00:25:31.310
So how does the
AnimatedStateListDrawable

00:25:31.310 --> 00:25:33.770
help us to get into these
kind of goals, which

00:25:33.770 --> 00:25:36.240
I set out for my animations?

00:25:36.240 --> 00:25:38.010
They only really tick
one box for me here.

00:25:38.010 --> 00:25:38.760
They're reentrant.

00:25:38.760 --> 00:25:40.680
So it maintains
the state for me.

00:25:40.680 --> 00:25:43.498
So, if I enter into a new
state, it will cancel everything

00:25:43.498 --> 00:25:45.290
and it will start the
new transition for me

00:25:45.290 --> 00:25:46.810
automatically.

00:25:46.810 --> 00:25:48.470
It is neither
continuous or smooth.

00:25:48.470 --> 00:25:51.180
So it won't kind of halfway
through an animation,

00:25:51.180 --> 00:25:54.410
do some kind of magic to
move from that halfway state

00:25:54.410 --> 00:25:56.690
to the end state you've defined.

00:25:56.690 --> 00:25:59.960
But I think this is pretty
useful for a class which

00:25:59.960 --> 00:26:00.650
is out the box.

00:26:00.650 --> 00:26:02.525
You don't have to write
any code essentially,

00:26:02.525 --> 00:26:04.550
you just have to provide
different transitions

00:26:04.550 --> 00:26:06.260
between the states.

00:26:06.260 --> 00:26:08.870
So it's a really handy class
to have in you're tool belt

00:26:08.870 --> 00:26:13.700
if you need to animate the
transition of drawables.

00:26:13.700 --> 00:26:16.180
Closely related, or similar
conceptually, to animator

00:26:16.180 --> 00:26:18.140
drawable is the
StateListAnimator,

00:26:18.140 --> 00:26:20.678
which actually does some
of the things for views.

00:26:20.678 --> 00:26:22.220
So, for example, in
this application,

00:26:22.220 --> 00:26:25.028
I have some kind of
friendly conversation.

00:26:25.028 --> 00:26:26.570
And when you select
a single comment,

00:26:26.570 --> 00:26:28.237
I wanted to have this
kind of transition

00:26:28.237 --> 00:26:30.980
where I animate the
elevation and the background

00:26:30.980 --> 00:26:34.140
color of the selected comment.

00:26:34.140 --> 00:26:36.740
And this is entirely
declaratively powered

00:26:36.740 --> 00:26:39.300
by the StateListAnimator class.

00:26:39.300 --> 00:26:41.390
So a StateListAnimator
is essentially

00:26:41.390 --> 00:26:43.220
a selector where
within each item

00:26:43.220 --> 00:26:45.530
tag, within each item,
which is a given state,

00:26:45.530 --> 00:26:48.857
you can define these child
animations to be run.

00:26:48.857 --> 00:26:50.690
I don't know why it's
not animated selector,

00:26:50.690 --> 00:26:52.940
but it is a selector, anyway.

00:26:52.940 --> 00:26:55.010
So, here, you can see I
am running an animation

00:26:55.010 --> 00:26:57.620
over the background color and
the translationZ property,

00:26:57.620 --> 00:27:00.332
whenever you go into
a certain state.

00:27:00.332 --> 00:27:01.790
And here, I just
want to point out,

00:27:01.790 --> 00:27:03.373
you don't have to
create your own view

00:27:03.373 --> 00:27:04.790
states if you do not need them.

00:27:04.790 --> 00:27:08.240
So here, we just reused the
Android activated state, which

00:27:08.240 --> 00:27:10.100
is available on every view.

00:27:10.100 --> 00:27:12.457
So while defining custom view
states is super powerful,

00:27:12.457 --> 00:27:14.540
if you have multiple states
you want to move in to

00:27:14.540 --> 00:27:17.120
and you want it to be more
meaningful and semantic,

00:27:17.120 --> 00:27:21.300
you can just reuse some
of the Android states.

00:27:21.300 --> 00:27:25.630
So StateListAnimator, how does
this kind of score on a chart?

00:27:25.630 --> 00:27:27.417
So just like an
AnimatedStateListDrawable,

00:27:27.417 --> 00:27:29.250
it's reentrant, so it'll
maintain the state.

00:27:29.250 --> 00:27:30.720
So if your new state
comes in, it'll

00:27:30.720 --> 00:27:32.512
cancel anything that
was previously running

00:27:32.512 --> 00:27:34.380
and move you into the new state.

00:27:34.380 --> 00:27:35.760
It's kind of semi continuous.

00:27:35.760 --> 00:27:37.580
I'll give it like
half a mark here.

00:27:37.580 --> 00:27:38.700
And it really comes
down to the fact

00:27:38.700 --> 00:27:40.617
that it's just running
these object animators.

00:27:40.617 --> 00:27:42.750
And, just like we
looked at before,

00:27:42.750 --> 00:27:44.830
you can provide a from
value and a to value.

00:27:44.830 --> 00:27:47.700
So just by admitting
the from value,

00:27:47.700 --> 00:27:50.760
it will try and query the
current value in order

00:27:50.760 --> 00:27:51.490
to run it.

00:27:51.490 --> 00:27:53.790
But I said try because
this is, essentially,

00:27:53.790 --> 00:27:55.780
a kind of reflection
based approach.

00:27:55.780 --> 00:27:59.770
So view has a get
translationZ method on it.

00:27:59.770 --> 00:28:01.440
So it can query
the translationZ.

00:28:01.440 --> 00:28:02.970
And it will then
say, translationZ

00:28:02.970 --> 00:28:04.740
will be continuous.

00:28:04.740 --> 00:28:08.040
But there is no get background
color method on view.

00:28:08.040 --> 00:28:10.680
Essentially, there is a set
background color method,

00:28:10.680 --> 00:28:13.140
which is a convenience method,
that almost takes that color

00:28:13.140 --> 00:28:14.910
and coerces it into
a colored drawable

00:28:14.910 --> 00:28:16.530
and sets a colored
drawable in view.

00:28:16.530 --> 00:28:18.817
But there's no get it for it.

00:28:18.817 --> 00:28:20.400
So you have to be a
bit careful about,

00:28:20.400 --> 00:28:21.900
if you want to make
this continuous,

00:28:21.900 --> 00:28:24.390
about using properties
which are animatable.

00:28:24.390 --> 00:28:25.890
That you can read
the current value,

00:28:25.890 --> 00:28:27.598
in order to get this
continuous property.

00:28:29.815 --> 00:28:31.440
And the last thing
I want to talk about

00:28:31.440 --> 00:28:34.910
is an approach to doing
custom view animation.

00:28:34.910 --> 00:28:37.710
So let's walk through an
example of what I mean by that.

00:28:37.710 --> 00:28:40.190
So in the Google I/O
application again,

00:28:40.190 --> 00:28:43.387
we have this filter screen where
you can customize the schedule

00:28:43.387 --> 00:28:45.220
to see the topics that
you're interested in.

00:28:45.220 --> 00:28:48.620
You're just interested in
Android and sessions, right?

00:28:48.620 --> 00:28:51.680
And so this is a
custom view because we

00:28:51.680 --> 00:28:54.170
want to have complete control
over the rendering of it.

00:28:54.170 --> 00:28:56.860
And there's a few things
going on with this animation.

00:28:56.860 --> 00:29:00.770
So, when you select it,
there's the color circle

00:29:00.770 --> 00:29:03.740
that both increases in size, as
well as we animate its center

00:29:03.740 --> 00:29:06.150
to be in the center of the chip.

00:29:06.150 --> 00:29:07.790
We estimate the text position.

00:29:07.790 --> 00:29:09.770
And then we also scale
up the drawable, which

00:29:09.770 --> 00:29:13.230
is that clear x on the side.

00:29:13.230 --> 00:29:15.680
So you could think of a way
of writing this as a custom

00:29:15.680 --> 00:29:17.308
animation, whereby
you create animators

00:29:17.308 --> 00:29:19.100
for each of those things
which is changing.

00:29:19.100 --> 00:29:21.320
When you run those
animations individually.

00:29:21.320 --> 00:29:23.570
So an animation for
the circle radius.

00:29:23.570 --> 00:29:25.557
One for the circle center.

00:29:25.557 --> 00:29:27.890
And then you could perhaps
put them into an animated set

00:29:27.890 --> 00:29:30.980
and try and control them and
orchestrate them like that.

00:29:30.980 --> 00:29:33.530
But, instead, the way we
went for this is we instead

00:29:33.530 --> 00:29:36.470
have a single progress
property, which is just

00:29:36.470 --> 00:29:39.680
a Float which runs from 0 to 1.

00:29:39.680 --> 00:29:42.140
And we just run a
single animation

00:29:42.140 --> 00:29:44.630
over that progress property.

00:29:44.630 --> 00:29:46.820
And then what we do is
we drive the rendering

00:29:46.820 --> 00:29:48.750
to query that progress property.

00:29:48.750 --> 00:29:51.800
So for the circle radius, for
example, we say, what radius

00:29:51.800 --> 00:29:54.600
should I be from between this
start value and that end value

00:29:54.600 --> 00:29:55.475
for a given progress?

00:29:55.475 --> 00:29:57.440
And if you haven't seen
a lerp function before,

00:29:57.440 --> 00:29:58.815
it's a very common
animation kind

00:29:58.815 --> 00:30:00.890
of utility, which means
linearly interpolate,

00:30:00.890 --> 00:30:02.220
which will do just that.

00:30:02.220 --> 00:30:04.640
So between this value and this
value for a given progress,

00:30:04.640 --> 00:30:05.348
what should I be?

00:30:07.790 --> 00:30:11.190
And the key takeaway
here is that if you have

00:30:11.190 --> 00:30:13.180
this single progress function.

00:30:13.180 --> 00:30:16.170
And then you can just
animate it very easily.

00:30:16.170 --> 00:30:17.670
So you can hook
this up to a spring,

00:30:17.670 --> 00:30:19.890
like we looked at before,
and have this entirely

00:30:19.890 --> 00:30:23.160
be continuous and smooth by
running spring animations

00:30:23.160 --> 00:30:25.402
and be able to retarget
it to something else,

00:30:25.402 --> 00:30:27.860
rather than having to try and
orchestrate multiple animator

00:30:27.860 --> 00:30:29.550
sets, which can be a pain.

00:30:29.550 --> 00:30:31.980
Or you could hook
this up to a gesture

00:30:31.980 --> 00:30:34.860
perhaps and do something
responding, an animation

00:30:34.860 --> 00:30:35.910
responding to a scroll.

00:30:35.910 --> 00:30:37.285
Or even hook this
up to something

00:30:37.285 --> 00:30:39.888
like motion layout, which lets
you animate a custom property

00:30:39.888 --> 00:30:40.930
based on scroll position.

00:30:45.170 --> 00:30:47.990
So those are my three
tenants I think that make up

00:30:47.990 --> 00:30:50.270
a good animation that
is going to survive

00:30:50.270 --> 00:30:53.030
in this kind of reactive world.

00:30:53.030 --> 00:30:56.252
But this is really an
ordered list for me.

00:30:56.252 --> 00:30:58.460
Essentially, you can think
of it as crafted hierarchy

00:30:58.460 --> 00:31:01.580
of animation needs,
where being reentrant

00:31:01.580 --> 00:31:03.230
is kind of about correctness.

00:31:03.230 --> 00:31:06.170
If you aren't reentrant,
if you're animations

00:31:06.170 --> 00:31:09.610
aren't cancelable and
work in the right way

00:31:09.610 --> 00:31:11.270
so it can be
recalled, then you're

00:31:11.270 --> 00:31:13.220
going to end up in
the incorrect state.

00:31:13.220 --> 00:31:14.947
So this is like table stakes.

00:31:14.947 --> 00:31:17.030
You have to get this right
in order for animations

00:31:17.030 --> 00:31:19.960
to survive in this
reactive world.

00:31:19.960 --> 00:31:21.460
Continuous is all
about, I think,

00:31:21.460 --> 00:31:23.000
having a smoother
user experience.

00:31:23.000 --> 00:31:25.060
So values don't
jump unexpectedly,

00:31:25.060 --> 00:31:26.960
which can be very jarring.

00:31:26.960 --> 00:31:29.500
And smoothness is almost like
this stretch goal for me.

00:31:29.500 --> 00:31:31.510
It's like the icing on the cake.

00:31:31.510 --> 00:31:33.970
That rather than just
having things abruptly

00:31:33.970 --> 00:31:35.960
change velocity and
change direction,

00:31:35.960 --> 00:31:37.840
then it could be a
much nicer experience

00:31:37.840 --> 00:31:39.920
to have it do it
in a smooth manner.

00:31:39.920 --> 00:31:42.070
But I think it's worth
striving for because what's

00:31:42.070 --> 00:31:43.330
the point of animating
it if you're just

00:31:43.330 --> 00:31:44.590
going to kind of half ass it.

00:31:47.630 --> 00:31:52.480
And so that's my conclusion.

00:31:52.480 --> 00:31:55.270
I think it'll be a shame if we,
in this reactive world, if we

00:31:55.270 --> 00:31:56.827
were just to give
up on animations.

00:31:56.827 --> 00:31:58.660
And I think that these
principles can really

00:31:58.660 --> 00:32:02.240
help you hold them in mind in
making better animated apps.

00:32:02.240 --> 00:32:03.370
Thanks very much.

00:32:03.370 --> 00:32:06.420
[GOOGLE LOGO MUSIC]

