WEBVTT
Kind: captions
Language: en

00:00:00.250 --> 00:00:01.208
DAWID OSTROWSKI: Hello.

00:00:01.208 --> 00:00:02.250
Hello, everybody.

00:00:02.250 --> 00:00:04.660
Good afternoon.

00:00:04.660 --> 00:00:06.817
My name is Dawid
Ostrowski, and I'm

00:00:06.817 --> 00:00:08.650
a program manager in
the developer relations

00:00:08.650 --> 00:00:10.010
team at Google.

00:00:10.010 --> 00:00:11.970
And over the next
45 minutes, together

00:00:11.970 --> 00:00:15.490
with two Google Developer
experts, Toys Benyossef

00:00:15.490 --> 00:00:20.780
and Etienne Caron,
we'll make you

00:00:20.780 --> 00:00:24.105
more aware of various challenges
that developers have while

00:00:24.105 --> 00:00:26.340
building apps for billions.

00:00:26.340 --> 00:00:30.210
But rather than talking about
scalability or actual user

00:00:30.210 --> 00:00:33.090
acquisition, we'll
take a step back,

00:00:33.090 --> 00:00:36.270
making sure our apps can
at least, potentially,

00:00:36.270 --> 00:00:38.930
provide the proper user
experience to a billion

00:00:38.930 --> 00:00:41.000
of users.

00:00:41.000 --> 00:00:43.610
We will take into
account huge diversity

00:00:43.610 --> 00:00:45.940
of users around the
world, as well as topics

00:00:45.940 --> 00:00:49.610
like connectivity,
device capabilities, data

00:00:49.610 --> 00:00:53.570
cost, battery
consumption, and content.

00:00:53.570 --> 00:00:56.400
We'll be presenting
you with tools

00:00:56.400 --> 00:00:57.990
and discussing
real-life examples

00:00:57.990 --> 00:01:00.700
showcasing implementation
best practices,

00:01:00.700 --> 00:01:04.269
as well as areas for improvement
in highly visible apps

00:01:04.269 --> 00:01:05.766
from Google Play.

00:01:05.766 --> 00:01:10.310
I would also like to invite you
to our space in the Spaces app.

00:01:10.310 --> 00:01:13.420
Natalie, who is in my team, she
will be interacting with you

00:01:13.420 --> 00:01:15.010
over there.

00:01:15.010 --> 00:01:17.700
So let's start.

00:01:17.700 --> 00:01:20.600
Probably every developer
who creates a new product

00:01:20.600 --> 00:01:23.340
dreams about its
worldwide adoption.

00:01:23.340 --> 00:01:26.790
Success is often defined
by hundreds of thousands

00:01:26.790 --> 00:01:29.150
or millions of users.

00:01:29.150 --> 00:01:31.070
But what about billions?

00:01:31.070 --> 00:01:34.360
Is such thing possible?

00:01:34.360 --> 00:01:35.730
Yes, it is.

00:01:35.730 --> 00:01:39.110
Just take a look on those
randomly-selected apps-- Google

00:01:39.110 --> 00:01:48.720
Search, YouTube, Chrome, Maps,
Gmail, and of course, Android.

00:01:48.720 --> 00:01:52.380
Each of these Google products
is used by over a billion users

00:01:52.380 --> 00:01:53.810
worldwide.

00:01:53.810 --> 00:01:56.500
And what's probably quite
important to many of you

00:01:56.500 --> 00:01:58.680
here in this room, when
I mentioned Android,

00:01:58.680 --> 00:02:00.910
I didn't just mean
the operating system.

00:02:00.910 --> 00:02:04.710
I meant actually, over a
billion of 30-day active users

00:02:04.710 --> 00:02:06.430
of Google Play.

00:02:06.430 --> 00:02:12.100
Luckily, all of those products
serve as a platform for you

00:02:12.100 --> 00:02:14.720
to reach billions.

00:02:14.720 --> 00:02:17.660
Your billions.

00:02:17.660 --> 00:02:18.650
So is it possible?

00:02:18.650 --> 00:02:19.150
Yes.

00:02:19.150 --> 00:02:20.310
Is it easy?

00:02:20.310 --> 00:02:21.760
No.

00:02:21.760 --> 00:02:24.140
Established markets are
saturated with apps,

00:02:24.140 --> 00:02:27.190
while emerging markets
have challenges

00:02:27.190 --> 00:02:30.240
that developers around the
world are not always aware.

00:02:30.240 --> 00:02:32.920
So even if your app
went ultra-viral

00:02:32.920 --> 00:02:35.910
or you spent massive amounts
of budgets on promotion,

00:02:35.910 --> 00:02:40.730
chances are your app might
not be providing them

00:02:40.730 --> 00:02:42.850
with the experience
that would convert them

00:02:42.850 --> 00:02:44.700
into regular customers.

00:02:44.700 --> 00:02:46.460
Why?

00:02:46.460 --> 00:02:50.600
Well, did you realize that over
half of the users in the world

00:02:50.600 --> 00:02:55.690
still might experience your
app through a 2G connection?

00:02:55.690 --> 00:02:57.460
Or that data plans
in some countries,

00:02:57.460 --> 00:03:02.560
they can cost upwards of
10% of their monthly income?

00:03:02.560 --> 00:03:05.990
Maybe you thought that most
of the people on the internet

00:03:05.990 --> 00:03:07.250
actually speak English?

00:03:07.250 --> 00:03:13.530
Well, actually, 74% of the
online population does not.

00:03:13.530 --> 00:03:16.670
At Google, we are more and
more aware of use cases

00:03:16.670 --> 00:03:18.340
like those just mentioned.

00:03:18.340 --> 00:03:21.180
Our mission is to make the
world's information universally

00:03:21.180 --> 00:03:23.090
accessible and useful.

00:03:23.090 --> 00:03:25.200
And while we believe
that users have

00:03:25.200 --> 00:03:28.100
the same fundamental needs--
keeping in touch with friends,

00:03:28.100 --> 00:03:31.560
being more productive at work,
and so on-- the environment

00:03:31.560 --> 00:03:36.710
in which they are coming
online might be different.

00:03:36.710 --> 00:03:38.550
That's why we have
launched various efforts,

00:03:38.550 --> 00:03:41.100
internally and
externally, that aim

00:03:41.100 --> 00:03:43.400
at providing the best
experience, regardless

00:03:43.400 --> 00:03:45.620
of the user's
connectivity issues,

00:03:45.620 --> 00:03:49.800
data plan limitations,
or language they speak.

00:03:49.800 --> 00:03:52.860
One of the examples is
offline mode for Google Maps.

00:03:52.860 --> 00:03:58.080
Now you can download all of
area of the world to the phone,

00:03:58.080 --> 00:04:00.320
and the next time there
is no connectivity

00:04:00.320 --> 00:04:03.890
like underground garage
or the country road,

00:04:03.890 --> 00:04:06.510
Maps will work seamlessly.

00:04:06.510 --> 00:04:09.910
Whereas before you could
simply browse the Maps offline,

00:04:09.910 --> 00:04:12.240
now you can get driving
directions, turn-by-turn turn

00:04:12.240 --> 00:04:14.330
directions, and
information about places,

00:04:14.330 --> 00:04:19.029
like opening hours or ratings.

00:04:19.029 --> 00:04:20.740
Another example,
in some countries,

00:04:20.740 --> 00:04:24.430
including Indonesia and India,
we launched YouTube Offline,

00:04:24.430 --> 00:04:26.360
{} [? when ?] actually,
in the mobile app,

00:04:26.360 --> 00:04:29.230
when you are signed in, you are
able to download some movies

00:04:29.230 --> 00:04:32.800
to watch offline
later-- up to 48 hours.

00:04:32.800 --> 00:04:35.440
Also in India and
Indonesia, we introduced

00:04:35.440 --> 00:04:38.760
lighter and streamlined
search results

00:04:38.760 --> 00:04:40.410
and optimized web pages.

00:04:40.410 --> 00:04:42.220
On average, they
load up to four times

00:04:42.220 --> 00:04:47.170
faster than the original ones
and they use 80% less data.

00:04:47.170 --> 00:04:50.100
As our users' overall
experience became faster,

00:04:50.100 --> 00:04:52.320
we saw also 50%
increase in traffic

00:04:52.320 --> 00:04:55.630
to those optimized pages.

00:04:55.630 --> 00:04:57.230
It's also very
important that you

00:04:57.230 --> 00:04:59.930
can have a great experience
online, regardless of language

00:04:59.930 --> 00:05:01.360
the users speak.

00:05:01.360 --> 00:05:07.140
With Google Translate, we
help with more over than 500

00:05:07.140 --> 00:05:14.660
million users every month to do
translations in 103 languages.

00:05:14.660 --> 00:05:19.020
And we estimate that
with these 103 languages,

00:05:19.020 --> 00:05:23.510
we are reaching 99% of
the online population.

00:05:23.510 --> 00:05:25.990
So building for
billions is a challenge.

00:05:25.990 --> 00:05:28.590
But we worked hard, we collected
feedback, analyzed data,

00:05:28.590 --> 00:05:30.340
and learned a lot.

00:05:30.340 --> 00:05:32.260
Now we are sharing
those insights

00:05:32.260 --> 00:05:34.350
with the broader developers
community in the form

00:05:34.350 --> 00:05:37.010
of an easy-to-use checklist.

00:05:37.010 --> 00:05:38.890
You can find guidelines,
recommendations,

00:05:38.890 --> 00:05:42.420
and best practices, for
both Android and the web,

00:05:42.420 --> 00:05:46.410
at
developers.google.com/billions.

00:05:46.410 --> 00:05:49.290
And remember, by adapting
those best practices,

00:05:49.290 --> 00:05:50.810
you are not only
opening your app

00:05:50.810 --> 00:05:53.020
for new users in
emerging markets,

00:05:53.020 --> 00:05:56.010
but also providing a much
better user experience for those

00:05:56.010 --> 00:05:58.900
in established markets.

00:05:58.900 --> 00:06:02.090
So that was a glimpse of
Google effort in the matter,

00:06:02.090 --> 00:06:04.530
but what about the
developers out there?

00:06:04.530 --> 00:06:07.600
How do they deal with limited
connectivity, varying device

00:06:07.600 --> 00:06:12.430
capabilities, data cost, battery
consumption, and localization?

00:06:12.430 --> 00:06:14.200
To answer to that
question, I would

00:06:14.200 --> 00:06:16.640
like to invite on stage
Royi Benyossef, who

00:06:16.640 --> 00:06:19.890
is a program manager at Samsung
Innovation Center in Tel Aviv--

00:06:19.890 --> 00:06:24.090
[APPLAUSE AND CHEERS]

00:06:24.090 --> 00:06:26.965
--and Etienne Caron, mobile
developer lead that Shopify,

00:06:26.965 --> 00:06:27.715
based in Montreal.

00:06:27.715 --> 00:06:29.514
[APPLAUSE  AND CHEERS]

00:06:29.514 --> 00:06:30.014
[?

00:06:30.014 --> 00:06:31.223
ROYI BENYOSSEF: Thank you. ?]

00:06:31.223 --> 00:06:32.805
DAWID OSTROWSKI:
They are both members

00:06:32.805 --> 00:06:34.770
of Google Developer
Experts Program, which I'm

00:06:34.770 --> 00:06:36.760
very proud to lead globally.

00:06:36.760 --> 00:06:38.780
The experts program-- thank you.

00:06:38.780 --> 00:06:40.560
The experts program
is a global network

00:06:40.560 --> 00:06:43.730
of over 400 recognized
and influential technology

00:06:43.730 --> 00:06:46.940
professionals experiencing
Google technologies,

00:06:46.940 --> 00:06:48.680
as well as outstanding
specialists

00:06:48.680 --> 00:06:51.610
in product strategy,
marketing, and design.

00:06:51.610 --> 00:06:54.920
They distinguish themselves
by frequently speaking

00:06:54.920 --> 00:06:58.680
at conferences, sharing
their experience and passion

00:06:58.680 --> 00:07:02.130
by publishing videos,
tutorials, writing code samples,

00:07:02.130 --> 00:07:05.160
mentoring developers and
startups, and much more.

00:07:05.160 --> 00:07:09.050
Experts are verified by both
Google and the community,

00:07:09.050 --> 00:07:12.380
and they are acknowledged
through a public directory.

00:07:12.380 --> 00:07:15.050
They benefit from easier
access to Google product teams,

00:07:15.050 --> 00:07:19.350
are invited to exclusive events
and projects like this one,

00:07:19.350 --> 00:07:22.420
and they participate in early
access programs, trusted tester

00:07:22.420 --> 00:07:23.500
programs, and so on.

00:07:23.500 --> 00:07:26.920
Some have opportunities
to indirectly shape

00:07:26.920 --> 00:07:30.110
the future of some of
the Google products

00:07:30.110 --> 00:07:34.560
by participating in feedback
sessions and custom advisory

00:07:34.560 --> 00:07:35.480
boards.

00:07:35.480 --> 00:07:38.750
Thanks to their support,
developers, startups,

00:07:38.750 --> 00:07:40.930
and technology companies
around the world

00:07:40.930 --> 00:07:44.920
create, build, and
shape high-quality apps.

00:07:44.920 --> 00:07:46.890
So without further ado,
I'm leaving you now

00:07:46.890 --> 00:07:48.494
with our top experts.

00:07:48.494 --> 00:07:49.976
Thank you.

00:07:49.976 --> 00:07:54.920
[APPLAUSE AND CHEERS]

00:07:54.920 --> 00:07:56.740
ETIENNE CARON: Hello, everybody.

00:07:56.740 --> 00:07:58.850
So we're going to talk
about connectivity.

00:07:58.850 --> 00:08:00.900
And as developers,
we usually work

00:08:00.900 --> 00:08:02.480
in an ideal environment, right?

00:08:02.480 --> 00:08:04.084
The network is solid.

00:08:04.084 --> 00:08:06.000
We're going to test on
somewhat recent devices

00:08:06.000 --> 00:08:07.730
that we bought locally.

00:08:07.730 --> 00:08:10.760
And truth be told, we
often have a limited idea

00:08:10.760 --> 00:08:13.300
of who are actual
end users are or what

00:08:13.300 --> 00:08:15.737
their day-to-day
environment is really like.

00:08:15.737 --> 00:08:18.320
Typically, we're only going to
come down from our ivory towers

00:08:18.320 --> 00:08:22.220
when we start getting
reviews that look like this.

00:08:22.220 --> 00:08:24.420
And when these reviews
start flying in,

00:08:24.420 --> 00:08:26.234
the damage is already done.

00:08:26.234 --> 00:08:28.400
So we're going to explore
today how to engineer apps

00:08:28.400 --> 00:08:30.820
more suited to the real world.

00:08:30.820 --> 00:08:32.990
At a very high level, the
approach breaks down as

00:08:32.990 --> 00:08:34.029
follows.

00:08:34.029 --> 00:08:35.820
So you're going to want
to surface problems

00:08:35.820 --> 00:08:38.709
by simulating the real world
as far as closely as possible.

00:08:38.709 --> 00:08:41.000
You're going to want to
diagnose the problem by looking

00:08:41.000 --> 00:08:42.210
at its symptoms.

00:08:42.210 --> 00:08:44.460
And then we're going to talk
about problem-solving and

00:08:44.460 --> 00:08:46.790
prevention techniques.

00:08:46.790 --> 00:08:48.890
So let's start talking
about actual connectivity.

00:08:48.890 --> 00:08:52.420
The real world, obviously,
is a very complicated place.

00:08:52.420 --> 00:08:54.070
And in the real
world, connectivity

00:08:54.070 --> 00:08:55.550
is an unreliable thing.

00:08:55.550 --> 00:08:58.360
So think about your users
on a train, in the subway,

00:08:58.360 --> 00:09:00.150
or going up in an elevator.

00:09:00.150 --> 00:09:03.310
Is your app really always
going to behave reliably?

00:09:03.310 --> 00:09:05.695
What about when one
out of three server

00:09:05.695 --> 00:09:08.520
calls fail and times out?

00:09:08.520 --> 00:09:09.920
So let's find out.

00:09:09.920 --> 00:09:13.790
We need to see how our
apps perform under stress.

00:09:13.790 --> 00:09:16.300
So first, we're going to
want to slow things down.

00:09:16.300 --> 00:09:18.630
Android emulators
allow developers

00:09:18.630 --> 00:09:22.740
to simulate a various range of
different network bandwidths,

00:09:22.740 --> 00:09:26.310
from full WiFi all
the way down to GDSM.

00:09:26.310 --> 00:09:28.250
By writing a few
functional tests

00:09:28.250 --> 00:09:31.590
and exercising those over a
comprehensive range of emulator

00:09:31.590 --> 00:09:35.630
setups, we should be able
to find out fairly quickly

00:09:35.630 --> 00:09:37.850
if our app misbehaves
in certain situations

00:09:37.850 --> 00:09:40.370
and when network calls
start timing out.

00:09:40.370 --> 00:09:41.900
The problem here,
that we're still

00:09:41.900 --> 00:09:44.990
working in fairly
ideal lab conditions.

00:09:44.990 --> 00:09:46.710
We don't just want
a slow network,

00:09:46.710 --> 00:09:49.390
we need a flaky one,
and that usually

00:09:49.390 --> 00:09:53.790
involves a debugging proxy
such as Charles, for example.

00:09:53.790 --> 00:09:56.810
Charles allows you to limit the
bandwidth and the reliability

00:09:56.810 --> 00:09:58.430
of your network connection.

00:09:58.430 --> 00:10:01.600
With this type of tool, you can
control the round trip latency,

00:10:01.600 --> 00:10:04.830
cause packet fragmentation,
random connection failures,

00:10:04.830 --> 00:10:06.920
and just degrade the
overall network quality

00:10:06.920 --> 00:10:09.100
however you see fit.

00:10:09.100 --> 00:10:11.320
After running our apps
through those gauntlets,

00:10:11.320 --> 00:10:13.570
we now have data to
work with, right?

00:10:13.570 --> 00:10:16.870
Likely we're going to have a
nice list of issues to work on.

00:10:16.870 --> 00:10:18.680
We now need to
investigate and find out

00:10:18.680 --> 00:10:22.620
what the root causes
of these issues are.

00:10:22.620 --> 00:10:25.020
When investigating, we can
start by taking a little peek

00:10:25.020 --> 00:10:27.400
at the Android Studio
Network Monitoring Overview.

00:10:27.400 --> 00:10:30.100
It gives us a nice idea of
what actual communications are

00:10:30.100 --> 00:10:31.062
going on.

00:10:31.062 --> 00:10:32.770
This gives us hints,
but obviously, we're

00:10:32.770 --> 00:10:35.090
going to want more
detail very quickly.

00:10:35.090 --> 00:10:38.800
Again, a debugging proxy like
Charles is very useful here.

00:10:38.800 --> 00:10:40.800
As mentioned, you can use
it to inject flakiness

00:10:40.800 --> 00:10:42.425
in your network calls,
but you can also

00:10:42.425 --> 00:10:44.790
see detail, what was
sent over the wire,

00:10:44.790 --> 00:10:48.694
the timings involved, and if
you have the right certificates

00:10:48.694 --> 00:10:50.110
configured on your
device, you can

00:10:50.110 --> 00:10:52.930
start inspecting the actual
SSL and encrypted packets that

00:10:52.930 --> 00:10:55.600
go through.

00:10:55.600 --> 00:10:59.390
Stetho is actually another
very good diagnostic tool.

00:10:59.390 --> 00:11:01.220
It will allow you,
amongst other things,

00:11:01.220 --> 00:11:03.530
to analyze the network
communications.

00:11:03.530 --> 00:11:05.820
You can see the exact
timeline of requests again,

00:11:05.820 --> 00:11:09.820
the size, completion time, all
of this from within Chrome.

00:11:09.820 --> 00:11:11.360
One of the big
advantage with Stetho

00:11:11.360 --> 00:11:14.210
is that you don't need to
set up special certificates

00:11:14.210 --> 00:11:17.870
on your device and
all that extra work,

00:11:17.870 --> 00:11:20.070
since you're actually
logging information straight

00:11:20.070 --> 00:11:22.460
from the device.

00:11:22.460 --> 00:11:25.550
Stress testing reveals and
surfaces potential problems

00:11:25.550 --> 00:11:28.350
and issues with our apps,
and diagnostics gives us

00:11:28.350 --> 00:11:31.520
the information we need to get
to the root cause and solve it.

00:11:31.520 --> 00:11:34.640
But ultimately, we'd like
to harden our application

00:11:34.640 --> 00:11:36.370
and architecture
it in such a way

00:11:36.370 --> 00:11:40.390
that we'll be able to handle
whatever we get thrown at.

00:11:40.390 --> 00:11:42.440
So knowing that
network connectivity

00:11:42.440 --> 00:11:45.790
is a transient
thing, and whenever

00:11:45.790 --> 00:11:48.610
a feature of our
application relies on that,

00:11:48.610 --> 00:11:51.030
we're going to need a
strategy to gracefully degrade

00:11:51.030 --> 00:11:53.300
the performance and
the feature set.

00:11:53.300 --> 00:11:55.960
The end goal is really to try
to avoid surprising your users

00:11:55.960 --> 00:11:58.520
and to stay consistent.

00:11:58.520 --> 00:12:01.240
So let's see this concept
at work with a real app.

00:12:01.240 --> 00:12:03.260
MakeMyTrip is an
application that allows you

00:12:03.260 --> 00:12:06.940
to book flights, hotel, rail
tickets, and holiday vacation

00:12:06.940 --> 00:12:08.300
packages.

00:12:08.300 --> 00:12:11.110
We can see an example here how
it handles connectivity loss

00:12:11.110 --> 00:12:12.880
when trying to book a flight.

00:12:12.880 --> 00:12:14.502
We get clear and
concise messaging

00:12:14.502 --> 00:12:15.960
with a call-to-action
to the users.

00:12:15.960 --> 00:12:17.820
So that's nice.

00:12:17.820 --> 00:12:19.750
There's a couple other
screens for MakeMyTrip.

00:12:19.750 --> 00:12:21.940
Again, we have nice
clear messaging

00:12:21.940 --> 00:12:23.980
with a cute cartoon character.

00:12:23.980 --> 00:12:25.750
So that hits all
the right marks.

00:12:25.750 --> 00:12:27.990
There is the question of
keeping your error messaging

00:12:27.990 --> 00:12:28.490
consistent.

00:12:28.490 --> 00:12:30.990
And that's actually fairly hard.

00:12:30.990 --> 00:12:33.170
To achieve consistent
messaging, you

00:12:33.170 --> 00:12:36.580
need to take a step back
and look at your app

00:12:36.580 --> 00:12:39.320
at a higher abstraction
level from the get-go.

00:12:39.320 --> 00:12:41.920
So say we're going to work
with a simple movie listing

00:12:41.920 --> 00:12:44.230
app with three basic use cases.

00:12:44.230 --> 00:12:46.634
We're going to have a list of
movies, of nearby theaters,

00:12:46.634 --> 00:12:48.550
and we're going to be
able to purchase tickets

00:12:48.550 --> 00:12:51.150
straight from our app.

00:12:51.150 --> 00:12:53.940
What can we still offer if
we lose the network here?

00:12:53.940 --> 00:12:57.750
So let's apply a few of
these ideas to our example.

00:12:57.750 --> 00:13:00.560
We can definitely, using
a cached copy of data,

00:13:00.560 --> 00:13:03.150
we can provide partial
functionality for all the movie

00:13:03.150 --> 00:13:05.640
theatre listings, obviously.

00:13:05.640 --> 00:13:08.720
Then, we can prevent users from
starting certain use cases,

00:13:08.720 --> 00:13:10.720
such as ticket purchasing.

00:13:10.720 --> 00:13:14.750
But what happens if we lose
connectivity during a purchase?

00:13:14.750 --> 00:13:16.830
We could always kick the
user out of the flow,

00:13:16.830 --> 00:13:20.410
but that's going to lead to lost
sales and annoyed users, right?

00:13:20.410 --> 00:13:24.180
So let's try to find a way
of gracefully degrading that.

00:13:24.180 --> 00:13:26.900
For the sake of example again,
let's imagine the simple ticket

00:13:26.900 --> 00:13:28.590
purchasing flow.

00:13:28.590 --> 00:13:31.040
Finding a number of tickets
available for the selected

00:13:31.040 --> 00:13:32.850
movie showing is the first step.

00:13:32.850 --> 00:13:34.870
Then we're going to
have the selection

00:13:34.870 --> 00:13:37.690
of the number of desired
tickets to put a hold on them

00:13:37.690 --> 00:13:39.240
for, say, five minutes.

00:13:39.240 --> 00:13:41.740
Then the user is going
to complete the purchase.

00:13:41.740 --> 00:13:45.130
If we take the first of
these flows and focus on it,

00:13:45.130 --> 00:13:47.370
this is an example,
it's the golden path.

00:13:47.370 --> 00:13:50.110
But obviously, we're going to
need to handle errors here.

00:13:50.110 --> 00:13:52.200
So we're going to want to
be able to say try again

00:13:52.200 --> 00:13:54.484
later if an error comes up.

00:13:54.484 --> 00:13:55.900
But that's still
pretty irritating

00:13:55.900 --> 00:13:58.422
if the network is kind
of flaky around our area.

00:13:58.422 --> 00:13:59.880
Chances are high
the users are just

00:13:59.880 --> 00:14:02.410
going to give up on
the purchase, right?

00:14:02.410 --> 00:14:04.760
So you can make the flow
more solid by simply

00:14:04.760 --> 00:14:07.280
retrying the server
calls when possible.

00:14:07.280 --> 00:14:09.370
You're going to want to
be smart about retries.

00:14:09.370 --> 00:14:11.400
Consider using
exponential backoff logic

00:14:11.400 --> 00:14:12.484
in the right places.

00:14:12.484 --> 00:14:13.900
I definitely
encourage people here

00:14:13.900 --> 00:14:17.390
to explore something called
RXJava, a very fairly

00:14:17.390 --> 00:14:20.880
popular library, to solve
that kind of problem.

00:14:20.880 --> 00:14:24.060
When a request, for example,
finally does timeout or fail

00:14:24.060 --> 00:14:26.640
after, say, 10 attempts,
like on this diagram,

00:14:26.640 --> 00:14:28.600
consider giving control
back to the users

00:14:28.600 --> 00:14:32.100
by giving them a try again or
give up dialogue of some sort.

00:14:32.100 --> 00:14:35.460
Or if you're clever about
saving transaction state, what

00:14:35.460 --> 00:14:37.870
you could do is give
users a way to complete

00:14:37.870 --> 00:14:39.840
the purchase at a later time.

00:14:39.840 --> 00:14:43.124
That saves the user a lot
of work and offering a way

00:14:43.124 --> 00:14:44.540
to complete the
transaction later,

00:14:44.540 --> 00:14:46.440
when the network
comes back up, people

00:14:46.440 --> 00:14:47.920
are going to appreciate that.

00:14:47.920 --> 00:14:51.220
So a very simple example,
obviously, but the key concepts

00:14:51.220 --> 00:14:52.500
are as follows.

00:14:52.500 --> 00:14:53.810
Think about the big picture.

00:14:53.810 --> 00:14:55.950
To avoid surprising
your users, be

00:14:55.950 --> 00:14:58.990
consistent in when you
surface connectivity errors.

00:14:58.990 --> 00:15:01.672
Try to say the same
messaging all over the app,

00:15:01.672 --> 00:15:03.380
keep the same messaging
all over the app.

00:15:03.380 --> 00:15:06.500
And when an error
does actually occur,

00:15:06.500 --> 00:15:08.510
try to save your
users' work and allow

00:15:08.510 --> 00:15:12.510
them to complete any given
flow later, if possible.

00:15:12.510 --> 00:15:14.860
Let's look at another
offline example.

00:15:14.860 --> 00:15:16.930
Practo is an app that
brings health and fitness

00:15:16.930 --> 00:15:18.260
to your phone.

00:15:18.260 --> 00:15:22.260
You can use it to save and share
your health records or book

00:15:22.260 --> 00:15:25.470
a doctor's appointment and find
a clinic, things like that.

00:15:25.470 --> 00:15:27.400
Practo, in this case,
partially supports

00:15:27.400 --> 00:15:29.670
finding a local clinic,
even if you're offline.

00:15:29.670 --> 00:15:32.140
So that's actually great
value for end users, right?

00:15:32.140 --> 00:15:34.100
Especially when you're
looking for a consult.

00:15:34.100 --> 00:15:35.870
If you don't have the
network, you still

00:15:35.870 --> 00:15:39.370
need a doctor, that's
actually pretty awesome.

00:15:39.370 --> 00:15:42.180
Don't hesitate to be aggressive
with the offline caching

00:15:42.180 --> 00:15:42.820
of your data.

00:15:42.820 --> 00:15:44.590
Even if it's not
the freshest, it

00:15:44.590 --> 00:15:47.130
can provide really
great value for users

00:15:47.130 --> 00:15:50.350
when connectivity is hard
to come by for a relatively

00:15:50.350 --> 00:15:52.800
low development cost.

00:15:52.800 --> 00:15:56.160
Ultimately, connectivity
is still the game-changer.

00:15:56.160 --> 00:15:59.250
So consider that if the
internet is not available,

00:15:59.250 --> 00:16:01.470
it's not the end of
networking, at all.

00:16:01.470 --> 00:16:03.110
Modern mobile
devices will give us

00:16:03.110 --> 00:16:05.260
a ton of multiple
connectivity stacks,

00:16:05.260 --> 00:16:09.680
so we could use WiFi Direct to
create an ad hoc mesh network.

00:16:09.680 --> 00:16:12.750
Or you can use Bluetooth to
share files between devices.

00:16:12.750 --> 00:16:16.390
So if your transactional and
domain logic supports it,

00:16:16.390 --> 00:16:18.630
you'll be able to bring
great value to users,

00:16:18.630 --> 00:16:20.880
even if you measure
network latency in days

00:16:20.880 --> 00:16:23.320
instead of milliseconds.

00:16:23.320 --> 00:16:26.410
In the same vein, don't
disregard MMS and SMS.

00:16:26.410 --> 00:16:30.060
In remote areas, even slow
network can be lifesavers.

00:16:30.060 --> 00:16:32.150
For years, nurses
in remote locations

00:16:32.150 --> 00:16:34.380
where doctors were
not available have

00:16:34.380 --> 00:16:36.070
been sending photos
of actual wounds

00:16:36.070 --> 00:16:38.270
to doctors for a prognosis.

00:16:38.270 --> 00:16:40.851
So then, that provides
awesome value,

00:16:40.851 --> 00:16:42.350
even though people
are really remote

00:16:42.350 --> 00:16:44.760
and you don't have a
fancy network around.

00:16:44.760 --> 00:16:46.350
So the better we get
to know our users

00:16:46.350 --> 00:16:48.180
and the infrastructure
available to them,

00:16:48.180 --> 00:16:50.770
the better we can serve them.

00:16:50.770 --> 00:16:53.330
HotelOGA is a hotel
booking management app

00:16:53.330 --> 00:16:56.270
and is a great example of
using an alternative networking

00:16:56.270 --> 00:16:57.240
solution.

00:16:57.240 --> 00:16:59.090
They developed a
strategic partnership

00:16:59.090 --> 00:17:02.670
with African multinational
telecommunications companies,

00:17:02.670 --> 00:17:06.410
and this allowed them to
provide dedicated data-only SIMS

00:17:06.410 --> 00:17:07.970
to their users.

00:17:07.970 --> 00:17:10.619
Their app also works
offline and supports SMS

00:17:10.619 --> 00:17:12.200
as a fallback communication.

00:17:12.200 --> 00:17:15.202
So now I'm going to
hand it off to Royi.

00:17:15.202 --> 00:17:19.050
[APPLAUSE AND CHEERS]

00:17:19.050 --> 00:17:21.290
ROYI BENYOSSEF: Don't
worry, he's coming back.

00:17:21.290 --> 00:17:22.920
Hi.

00:17:22.920 --> 00:17:23.920
Hello, everybody.

00:17:23.920 --> 00:17:25.950
OK, so after we
discuss connectivity,

00:17:25.950 --> 00:17:28.410
let's discuss the cost of it.

00:17:28.410 --> 00:17:30.770
All applications,
modern applications,

00:17:30.770 --> 00:17:33.750
require connectivity and
connectivity costs money,

00:17:33.750 --> 00:17:36.790
at least when you're on a
metered network like LTE

00:17:36.790 --> 00:17:40.860
or 3G or anything that you
need to buy a data plan for.

00:17:40.860 --> 00:17:43.100
Let's consider the data
plan like a battery,

00:17:43.100 --> 00:17:45.660
only you charge it with your
wallet instead of your wall

00:17:45.660 --> 00:17:46.650
socket.

00:17:46.650 --> 00:17:49.750
Now, there's no real analytics
about how much is too much,

00:17:49.750 --> 00:17:52.990
but their are pain points
to notice and patterns

00:17:52.990 --> 00:17:54.540
to notice, as well.

00:17:54.540 --> 00:17:56.484
So app size is important.

00:17:56.484 --> 00:17:57.400
It makes a difference.

00:17:57.400 --> 00:17:57.740
Why?

00:17:57.740 --> 00:17:59.340
Because if you see
an application that

00:17:59.340 --> 00:18:02.440
is 50 megabytes and
you're on 2G and it

00:18:02.440 --> 00:18:05.990
cost 10% of your yearly
paycheck, it is most likely

00:18:05.990 --> 00:18:07.640
you will not
download that on 3G.

00:18:07.640 --> 00:18:09.560
You'll wait for WiFi.

00:18:09.560 --> 00:18:10.630
Same goes for updates.

00:18:10.630 --> 00:18:14.550
People will delay updates
if they think it's too big,

00:18:14.550 --> 00:18:16.080
and they might not
get the updates.

00:18:16.080 --> 00:18:19.620
And we all know as developers,
updates are important.

00:18:19.620 --> 00:18:24.970
So let's start with dieting,
code trimming, third party

00:18:24.970 --> 00:18:27.470
libraries-- to be
exact, borrowed code.

00:18:27.470 --> 00:18:30.600
Most of us take these
libraries, which are very big,

00:18:30.600 --> 00:18:32.690
and we only use 10% of them.

00:18:32.690 --> 00:18:34.885
So the smart thing
to do is to carve out

00:18:34.885 --> 00:18:36.260
what you're actually
using, which

00:18:36.260 --> 00:18:38.580
is a good pattern altogether,
because then you'll

00:18:38.580 --> 00:18:40.040
know what you're relying on.

00:18:40.040 --> 00:18:42.600
And it also helps to
reduce the amount of code.

00:18:42.600 --> 00:18:44.640
Code duplicates, as
well, is a big problem.

00:18:44.640 --> 00:18:48.020
So use Lint to find the code
duplicates and refactor them,

00:18:48.020 --> 00:18:50.886
and you'll save 90%
percent of that.

00:18:50.886 --> 00:18:53.010
Moving on to something a
little bit more fattening,

00:18:53.010 --> 00:18:57.930
which are images, and it's also
a lot easier to maintain them.

00:18:57.930 --> 00:19:01.150
For instance, use Lint to
find all the unused images

00:19:01.150 --> 00:19:02.430
in your applications.

00:19:02.430 --> 00:19:04.890
You would not believe the
amount of data you'll save here,

00:19:04.890 --> 00:19:07.120
the amount of space.

00:19:07.120 --> 00:19:10.780
Also, take your .png and .jpg
files and put them through

00:19:10.780 --> 00:19:13.910
online compressing and
optimization engines.

00:19:13.910 --> 00:19:17.450
Most of the size of your .jpg's
and .png files are metadata

00:19:17.450 --> 00:19:20.800
that the user cannot see, like
where was the picture taken

00:19:20.800 --> 00:19:22.240
or who took the picture.

00:19:22.240 --> 00:19:24.800
If you reduce that,
you might reduce up

00:19:24.800 --> 00:19:26.590
to 90% of the image size.

00:19:26.590 --> 00:19:28.930
So do that.

00:19:28.930 --> 00:19:31.970
You can also go ahead and
use more progressive formats,

00:19:31.970 --> 00:19:34.880
such as vector drawables
or nine-patches.

00:19:34.880 --> 00:19:37.290
Or you can either eliminate
resources altogether

00:19:37.290 --> 00:19:39.790
by tinting, which is
taking a list of icons

00:19:39.790 --> 00:19:42.020
and then coloring them
in various colors,

00:19:42.020 --> 00:19:46.200
or using the dynamic resource
content coloring, which

00:19:46.200 --> 00:19:47.610
is the palette API.

00:19:47.610 --> 00:19:49.700
If you're not familiar
with these concepts,

00:19:49.700 --> 00:19:53.380
then where were you in
the last 2 and 1/2 years?

00:19:53.380 --> 00:19:56.000
Last but not least,
you can compress.

00:19:56.000 --> 00:19:58.570
Just use the-- I can't
remember the name--

00:19:58.570 --> 00:20:01.230
ProGuard, which is
also cyber secure

00:20:01.230 --> 00:20:03.630
but also compresses the size.

00:20:03.630 --> 00:20:06.120
So we've got the
diet all figured out.

00:20:06.120 --> 00:20:08.320
Let's go to day-to-day usage.

00:20:08.320 --> 00:20:11.020
Network usage has one
golden rule, which

00:20:11.020 --> 00:20:13.180
is the same as in all dieting.

00:20:13.180 --> 00:20:14.730
Simply think about
everything you're

00:20:14.730 --> 00:20:18.650
putting into your mouth--
downloading, sorry.

00:20:18.650 --> 00:20:20.620
Never download anything twice.

00:20:20.620 --> 00:20:22.795
If you're polling and just
taking down information,

00:20:22.795 --> 00:20:24.980
it is most likely you're
downloading something more

00:20:24.980 --> 00:20:27.700
than once and that's wrong.

00:20:27.700 --> 00:20:29.200
There are many
patterns that you can

00:20:29.200 --> 00:20:31.480
use that help you know
exactly what changed

00:20:31.480 --> 00:20:35.630
and when it changed, like
GCM Downward Messaging

00:20:35.630 --> 00:20:39.540
or like staleness headers
in the server side,

00:20:39.540 --> 00:20:42.980
or difs in the server
side, et cetera.

00:20:42.980 --> 00:20:46.260
So use them in order to
never download it twice.

00:20:46.260 --> 00:20:47.820
Be conscious of network type.

00:20:47.820 --> 00:20:49.350
For instance, if
you're on a WiFi--

00:20:49.350 --> 00:20:51.940
since we're discussing price
here-- if you're on a WiFi,

00:20:51.940 --> 00:20:53.090
download everything.

00:20:53.090 --> 00:20:55.620
Cache everything.

00:20:55.620 --> 00:20:58.660
On 3G, be much
cheaper with your data

00:20:58.660 --> 00:21:01.380
and only download what
the user has asked for

00:21:01.380 --> 00:21:02.510
and what they can see.

00:21:02.510 --> 00:21:05.190
That just makes perfect
sense, and you have handlers

00:21:05.190 --> 00:21:08.590
inside Android to give
you pretty much all of it.

00:21:08.590 --> 00:21:09.580
Optimized backend.

00:21:09.580 --> 00:21:11.220
Backend has a lot of power here.

00:21:11.220 --> 00:21:14.470
Most backend programmers
are like programmers,

00:21:14.470 --> 00:21:15.970
which means they're lazy.

00:21:15.970 --> 00:21:18.740
Simply tell them how
much it would benefit

00:21:18.740 --> 00:21:22.220
if you would change the API
to fit only what the user sees

00:21:22.220 --> 00:21:25.660
at any given time, and how
much it saves in radio time,

00:21:25.660 --> 00:21:27.410
and I can guarantee
they will not listen

00:21:27.410 --> 00:21:28.868
and you have to go
to their bosses.

00:21:28.868 --> 00:21:30.810
But still, you'll
make a good argument.

00:21:30.810 --> 00:21:32.360
And if we're talking
about backend,

00:21:32.360 --> 00:21:35.880
let's also try and use
new and exciting stuff

00:21:35.880 --> 00:21:40.880
like flat buffers or
like GCM or like difs,

00:21:40.880 --> 00:21:42.332
or like staleness headers.

00:21:42.332 --> 00:21:44.040
They'd like playing
with that because you

00:21:44.040 --> 00:21:46.930
like playing with new stuff, so
they should like it, as well.

00:21:46.930 --> 00:21:50.440
And you'll save not only
battery and data cost,

00:21:50.440 --> 00:21:52.420
you also save
[? tie ?] performance.

00:21:52.420 --> 00:21:54.160
Facebook and Google,
with flatbuffers,

00:21:54.160 --> 00:21:58.210
have reduced time with loading
their own apps from up to 90%,

00:21:58.210 --> 00:22:00.354
so not even data cost.

00:22:00.354 --> 00:22:01.770
Now let's go to
something a little

00:22:01.770 --> 00:22:03.780
bit different, which
is battery consumption.

00:22:03.780 --> 00:22:06.960
It's almost exactly the
same, with a key difference.

00:22:06.960 --> 00:22:08.550
The cost here is implicit.

00:22:08.550 --> 00:22:11.130
You cannot-- it's not money
coming out of your pocket,

00:22:11.130 --> 00:22:13.720
but it does have a cost,
and let me show you how.

00:22:13.720 --> 00:22:16.920
I'm in my office, 9:00 AM,
putting the phone in my pocket

00:22:16.920 --> 00:22:20.190
and I'm working on emails
or whatever it is that I do.

00:22:20.190 --> 00:22:22.060
At 11:00, I check
my phone to see

00:22:22.060 --> 00:22:25.680
if I have any calls or messages,
and I see two sad things.

00:22:25.680 --> 00:22:27.970
One of which, I got no
messages and no calls

00:22:27.970 --> 00:22:30.380
because I have no friends,
and the second thing is,

00:22:30.380 --> 00:22:33.480
is that I lost 37% of battery.

00:22:33.480 --> 00:22:35.140
That's an actual
case, by the way.

00:22:35.140 --> 00:22:37.710
So there's a problem here.

00:22:37.710 --> 00:22:39.240
Battery is life for most people.

00:22:39.240 --> 00:22:40.950
People live on their phones.

00:22:40.950 --> 00:22:42.930
So we have to be
conscientious of that.

00:22:42.930 --> 00:22:44.640
Now, let's talk
about the tools that

00:22:44.640 --> 00:22:47.010
will help you, as good
Android developers,

00:22:47.010 --> 00:22:50.110
help me, as the user, avoid
these kind of situations.

00:22:50.110 --> 00:22:52.120
So first of all,
the best example

00:22:52.120 --> 00:22:53.580
out there is the
battery historian.

00:22:53.580 --> 00:22:56.410
It's not that new anymore
and it's very helpful.

00:22:56.410 --> 00:23:00.590
It tells you exactly what
portion of your application

00:23:00.590 --> 00:23:04.520
service thread activity,
used what energy

00:23:04.520 --> 00:23:08.310
non-efficient hardware device,
like the GPU or the CPU

00:23:08.310 --> 00:23:12.090
or the kernel or the job
schedule or whatever.

00:23:12.090 --> 00:23:13.340
Let's take an example.

00:23:13.340 --> 00:23:17.100
This is the application known
as MakeMyTrip, which Etienne

00:23:17.100 --> 00:23:19.000
already introduced you to.

00:23:19.000 --> 00:23:21.860
You can see the amount of
data that's applied to you.

00:23:21.860 --> 00:23:23.960
You'd know If the
device was rebooted,

00:23:23.960 --> 00:23:26.220
you know how much time
the CPU is running.

00:23:26.220 --> 00:23:28.740
If you have WiFi, how
much time did you scan?

00:23:28.740 --> 00:23:30.610
What's the signal strength?

00:23:30.610 --> 00:23:32.430
Temperature, which
I have no idea why,

00:23:32.430 --> 00:23:34.670
but I'm guessing
[? Lonnie ?] can explain,

00:23:34.670 --> 00:23:36.042
et cetera, et cetera, et cetera.

00:23:36.042 --> 00:23:37.500
There's a lot of
data here that you

00:23:37.500 --> 00:23:40.660
can use in order to help
you know what's going on.

00:23:40.660 --> 00:23:44.520
And just give a quick round of
applause for this amazing 1/8

00:23:44.520 --> 00:23:47.710
of 1% result for a full
[? night-er. ?] MakeMyTrip--

00:23:47.710 --> 00:23:50.271
I don't know if you
were here, but kudos.

00:23:50.271 --> 00:23:50.770
OK.

00:23:50.770 --> 00:23:53.000
You can actually
applaud if you want to.

00:23:53.000 --> 00:23:56.110
Second thing does not
really involve around you,

00:23:56.110 --> 00:23:57.757
but what you need
to be aware of.

00:23:57.757 --> 00:23:59.840
Doze and standby-- and if
you don't know what that

00:23:59.840 --> 00:24:03.680
is, please, get up, go outside.

00:24:03.680 --> 00:24:07.460
But there are tools that were
implemented in Lollipop that

00:24:07.460 --> 00:24:11.150
are helping the device
[? save ?] itself from you,

00:24:11.150 --> 00:24:14.450
and you need to comply to
it, in order to be graceful

00:24:14.450 --> 00:24:15.600
and to work with it.

00:24:15.600 --> 00:24:17.010
The tests are fairly easy.

00:24:17.010 --> 00:24:21.750
You simply plug in the device,
turn on your application,

00:24:21.750 --> 00:24:24.417
turn the screen
off, and then plug

00:24:24.417 --> 00:24:27.630
in these bash commands, which
are pretty straightforward.

00:24:27.630 --> 00:24:30.430
Then you turn the
screen on-- OK,

00:24:30.430 --> 00:24:32.690
it's not that simple but
they are simple commands,

00:24:32.690 --> 00:24:35.580
it's just a lot to remember--
and then you see an example.

00:24:35.580 --> 00:24:36.410
This is Rounds.

00:24:36.410 --> 00:24:39.970
Rounds is a beautifully-made
video calls application

00:24:39.970 --> 00:24:42.140
that has handled--
this is a real test.

00:24:42.140 --> 00:24:44.370
We did an animated GIF.

00:24:44.370 --> 00:24:46.924
Handled it, well, beautifully.

00:24:46.924 --> 00:24:48.590
And again, round of
applause for Rounds,

00:24:48.590 --> 00:24:50.881
because I see their CDO right
here, and he's going to--

00:24:50.881 --> 00:24:54.110
[APPLAUSE AND CHEERS]

00:24:54.110 --> 00:24:55.280
Same thing goes for doze.

00:24:55.280 --> 00:24:56.700
That was standby, this is doze.

00:24:56.700 --> 00:24:59.680
Almost the same test, only
different batch command.

00:24:59.680 --> 00:25:02.420
Same result, they did
their job just right.

00:25:02.420 --> 00:25:03.300
It's possible.

00:25:03.300 --> 00:25:05.020
It's plausible.

00:25:05.020 --> 00:25:07.620
OK, moving on.

00:25:07.620 --> 00:25:08.420
Radio.

00:25:08.420 --> 00:25:10.630
Radio is the thing
that you use in order

00:25:10.630 --> 00:25:13.370
to access the internet, so
you need to be careful with it

00:25:13.370 --> 00:25:15.840
because it drinks
a lot of juice.

00:25:15.840 --> 00:25:19.940
[COUGHS] Sorry, that's
why I'm with the speaker.

00:25:19.940 --> 00:25:23.150
So it comes to a saying
that I like to say,

00:25:23.150 --> 00:25:25.070
which nobody understands,
but I'm on stage,

00:25:25.070 --> 00:25:26.240
so you have to hear it.

00:25:26.240 --> 00:25:28.200
Let sleeping radios lie.

00:25:28.200 --> 00:25:29.020
What do I mean?

00:25:29.020 --> 00:25:30.561
These are the
practices that you need

00:25:30.561 --> 00:25:33.160
to use in order to save
your radio and your battery.

00:25:33.160 --> 00:25:35.610
So the first thing
is, use batch calls,

00:25:35.610 --> 00:25:37.980
meaning that you can use
either Job Schedule, which

00:25:37.980 --> 00:25:41.590
was introduced in Android 6,0,
or GCM network manager, which

00:25:41.590 --> 00:25:44.110
is exactly the same thing,
only backward-compatible

00:25:44.110 --> 00:25:47.520
for all apps that have Google
Play services from version-- I

00:25:47.520 --> 00:25:48.510
have no idea.

00:25:48.510 --> 00:25:49.420
Google it.

00:25:49.420 --> 00:25:51.720
Or Sync Adapter, which
does exactly the same thing

00:25:51.720 --> 00:25:54.410
all the way back, but it's
a little bit too complex.

00:25:54.410 --> 00:25:56.600
It's not too complex, but
a little bit more complex

00:25:56.600 --> 00:25:57.190
to implement.

00:25:57.190 --> 00:26:00.320
So if you do not have
access to these devices,

00:26:00.320 --> 00:26:01.880
use Sync Adapter.

00:26:01.880 --> 00:26:03.540
It's plausible, again.

00:26:03.540 --> 00:26:05.250
And it will batch
the calls together

00:26:05.250 --> 00:26:08.080
so you would not call the
radio all the time, only

00:26:08.080 --> 00:26:12.540
in specific maintenance
windows, which saves battery.

00:26:12.540 --> 00:26:14.050
Never download anything twice.

00:26:14.050 --> 00:26:17.370
Returning back, you remember we
talked about it in data cost?

00:26:17.370 --> 00:26:18.930
So again, same thing.

00:26:18.930 --> 00:26:22.610
Progressive server client
scheme, changing the API,

00:26:22.610 --> 00:26:27.130
using downward GCM data, or
using GCM to update what's

00:26:27.130 --> 00:26:28.610
changed, if it's small enough.

00:26:28.610 --> 00:26:30.780
All of them are viable examples.

00:26:30.780 --> 00:26:33.750
But the most important
thing is, stop polling.

00:26:33.750 --> 00:26:38.260
Polling is the worst,
the worst thing

00:26:38.260 --> 00:26:39.570
you can do in an application.

00:26:39.570 --> 00:26:43.040
And there are so many patterns
you can use, so just, please,

00:26:43.040 --> 00:26:45.792
for me, for you, no, I
don't-- for the children.

00:26:45.792 --> 00:26:46.500
I'm just kidding.

00:26:46.500 --> 00:26:47.260
[LAUGHTER]

00:26:47.260 --> 00:26:50.822
OK, so after we optimize
the actual request

00:26:50.822 --> 00:26:52.530
and the backend side
and everything else,

00:26:52.530 --> 00:26:53.821
let's just listen to the users.

00:26:53.821 --> 00:26:56.690
You have enough handlers
and listeners telling you

00:26:56.690 --> 00:26:59.200
if the user actually
wants your data right now.

00:26:59.200 --> 00:27:02.220
So if the screen is off, it is
most likely that the user just

00:27:02.220 --> 00:27:03.280
doesn't care.

00:27:03.280 --> 00:27:05.296
If it's plugged into
the electricity,

00:27:05.296 --> 00:27:07.920
you can do whatever you want to,
because the battery will never

00:27:07.920 --> 00:27:08.419
run out.

00:27:08.419 --> 00:27:11.010
But if it's not, and you
know the battery level,

00:27:11.010 --> 00:27:12.700
and it's low, and
you're the difference

00:27:12.700 --> 00:27:18.070
between a brick and a
working phone, don't update.

00:27:18.070 --> 00:27:20.170
You have activity recognition,
which is wonderful

00:27:20.170 --> 00:27:22.840
because it's not only telling
you if the user is present

00:27:22.840 --> 00:27:25.030
or not, it tells you context.

00:27:25.030 --> 00:27:27.370
Because if you're
a traffic app, it

00:27:27.370 --> 00:27:30.250
makes perfect sense to
update more while on the go,

00:27:30.250 --> 00:27:33.280
but it doesn't make any
sense to update news scores

00:27:33.280 --> 00:27:34.650
while someone is driving.

00:27:34.650 --> 00:27:38.620
So context is key here and it
gives you a lot of information.

00:27:38.620 --> 00:27:41.300
OK, now I'm handing
over the clicker

00:27:41.300 --> 00:27:43.629
again for device capabilities.

00:27:43.629 --> 00:27:44.295
Please welcome--

00:27:48.820 --> 00:27:50.990
ETIENNE CARON: All
right, so, let's talk

00:27:50.990 --> 00:27:52.390
about device capabilities.

00:27:52.390 --> 00:27:55.020
Android runs on a multitude
of different devices.

00:27:55.020 --> 00:27:57.170
That's no surprise
to anyone here.

00:27:57.170 --> 00:28:00.060
There's different OS
versions, screen densities,

00:28:00.060 --> 00:28:02.900
processing power,
memory storage-- all

00:28:02.900 --> 00:28:05.660
that stuff can be very different
from one device to the next.

00:28:05.660 --> 00:28:07.590
So when going global,
your user's device

00:28:07.590 --> 00:28:11.047
will likely be very different
from one instance to the next.

00:28:11.047 --> 00:28:12.630
You're going to need
to have your apps

00:28:12.630 --> 00:28:15.050
optimized and flexible,
and ready to handle

00:28:15.050 --> 00:28:17.220
all these different use cases.

00:28:17.220 --> 00:28:19.170
So another thing to
consider, about 5

00:28:19.170 --> 00:28:22.890
of the 7 billion people on
Earth do not understand English.

00:28:22.890 --> 00:28:25.550
Localizing an app can be
very challenging, especially

00:28:25.550 --> 00:28:27.390
if you didn't plan for it.

00:28:27.390 --> 00:28:29.610
So think of the
different character sets,

00:28:29.610 --> 00:28:33.080
of right to left languages,
and strings, once translated,

00:28:33.080 --> 00:28:35.930
can end up 50%
longer, especially

00:28:35.930 --> 00:28:37.360
with French and German.

00:28:37.360 --> 00:28:39.940
So once translated, your
carefully designed UI

00:28:39.940 --> 00:28:41.890
could very likely break.

00:28:41.890 --> 00:28:45.040
So what can we do to catch
issues before we release?

00:28:45.040 --> 00:28:48.080
Well, emulators allow us, again,
to configure various screen

00:28:48.080 --> 00:28:50.960
sizes, changes in disk size,
change in memory configuration,

00:28:50.960 --> 00:28:52.160
and the locale settings.

00:28:52.160 --> 00:28:55.210
So all of this is great
for testing your UX.

00:28:55.210 --> 00:28:57.590
But no emulator covers
all the different hardware

00:28:57.590 --> 00:29:00.090
configurations that you're
probably going to see.

00:29:00.090 --> 00:29:02.310
Think about the different
hardware and the software

00:29:02.310 --> 00:29:05.880
drivers, or x86
versus Arm, OpenGL3,

00:29:05.880 --> 00:29:09.220
those things are usually
not available in emulators.

00:29:09.220 --> 00:29:11.690
They can't tell us
with 100% accuracy

00:29:11.690 --> 00:29:15.484
how our app will actually
perform on the real hardware.

00:29:15.484 --> 00:29:17.150
So ideally, you're
going to want to test

00:29:17.150 --> 00:29:19.260
your app on real devices.

00:29:19.260 --> 00:29:22.500
One approach is to build
your own hardware test lab.

00:29:22.500 --> 00:29:25.927
That's usually fairly expensive
and time-consuming when

00:29:25.927 --> 00:29:28.010
you think about maintaining
those devices-- making

00:29:28.010 --> 00:29:31.660
sure they're up, handling the
random crashes, and et cetera.

00:29:31.660 --> 00:29:35.380
So consider using a testing
lab service such as,

00:29:35.380 --> 00:29:37.810
for example, Google's
Cloud Test Labs.

00:29:37.810 --> 00:29:40.110
Between emulators or
devices testing labs,

00:29:40.110 --> 00:29:43.540
we are now close to
real-world conditions.

00:29:43.540 --> 00:29:46.820
So we're ready to test and
start hunting for issues.

00:29:46.820 --> 00:29:49.320
For UI and UX testing,
it's challenging

00:29:49.320 --> 00:29:51.580
to completely
automate the process.

00:29:51.580 --> 00:29:54.000
How do you write a test that
validates if a screen is

00:29:54.000 --> 00:29:55.650
actually legible?

00:29:55.650 --> 00:29:57.100
Or really usable?

00:29:57.100 --> 00:30:00.600
Or that the translated UIs
actually still make sense?

00:30:00.600 --> 00:30:04.220
That's where human intervention
is most likely needed.

00:30:04.220 --> 00:30:07.220
You might be thinking, wait,
if I multiply screen densities

00:30:07.220 --> 00:30:09.950
by orientation and then
again by the number

00:30:09.950 --> 00:30:15.750
of locales I'm going to support,
yeah, that is a lot of screens.

00:30:15.750 --> 00:30:19.660
But if you have the proper
UX integration tests,

00:30:19.660 --> 00:30:22.130
and that you exercise
most of your UI,

00:30:22.130 --> 00:30:24.420
you can actually take
screenshots of those UIs

00:30:24.420 --> 00:30:27.430
as you go on the different
devices that you're testing on

00:30:27.430 --> 00:30:29.380
and you provide
those to your QA.

00:30:29.380 --> 00:30:31.470
If you run a dif
tools on these images,

00:30:31.470 --> 00:30:33.550
once somebody has
validated an image,

00:30:33.550 --> 00:30:35.940
you only will need to look it
over again once it actually

00:30:35.940 --> 00:30:38.170
changes and you detect a delta.

00:30:38.170 --> 00:30:41.570
That makes things a
lot more manageable.

00:30:41.570 --> 00:30:43.585
Benchmarks can allow you
to monitor performance

00:30:43.585 --> 00:30:45.810
and execution time of your app.

00:30:45.810 --> 00:30:48.360
So even if you can't run them
off of the physical device,

00:30:48.360 --> 00:30:51.740
by keeping the actual
benchmark historical data,

00:30:51.740 --> 00:30:55.000
you can raise alarms when
runtimes change significantly

00:30:55.000 --> 00:30:57.044
from one version to the next.

00:30:57.044 --> 00:30:58.460
Of course, this
means you're going

00:30:58.460 --> 00:31:00.840
to need to keep that
history the first place.

00:31:00.840 --> 00:31:02.430
An actual, easy
way to do this is

00:31:02.430 --> 00:31:05.620
to use your favorite metrics
or analytics tool platform.

00:31:05.620 --> 00:31:08.560
Using that data, then you
can write all those tests,

00:31:08.560 --> 00:31:10.540
create alarms, or
even fail the test

00:31:10.540 --> 00:31:13.045
if the numbers are
starting to look bad.

00:31:13.045 --> 00:31:14.920
It's worth noting here,
on the slide you see,

00:31:14.920 --> 00:31:18.640
that there is a dumpsys gfxinfo
info adb command in there.

00:31:18.640 --> 00:31:20.200
That one's very
valuable when you

00:31:20.200 --> 00:31:22.380
want to monitor the
actual performance

00:31:22.380 --> 00:31:25.720
of the rendering of the app.

00:31:25.720 --> 00:31:27.410
So given the range
of screen sizes

00:31:27.410 --> 00:31:29.420
your app is going
to be running on,

00:31:29.420 --> 00:31:32.310
your layouts will be
anything but static.

00:31:32.310 --> 00:31:34.580
And that's really nothing new.

00:31:34.580 --> 00:31:37.460
Web designers have been
dealing with this forever.

00:31:37.460 --> 00:31:39.685
So consider exploring
all that great literature

00:31:39.685 --> 00:31:43.320
on responsive web design,
and draw inspiration from it.

00:31:43.320 --> 00:31:44.700
Think of Bruce Lee, basically.

00:31:44.700 --> 00:31:49.310
Your layouts and content
needs to be like water.

00:31:49.310 --> 00:31:51.090
And also, don't
feel forced to write

00:31:51.090 --> 00:31:52.920
one layout to rule them all.

00:31:52.920 --> 00:31:55.722
Don't forget, you have all
these local specific classifiers

00:31:55.722 --> 00:31:57.305
that we see here on
the slide that you

00:31:57.305 --> 00:31:59.780
can use to create exceptions
to handle those [? corner ?]

00:31:59.780 --> 00:32:00.530
cases.

00:32:00.530 --> 00:32:02.290
You can do stuff
that-- you can change

00:32:02.290 --> 00:32:04.665
the layout for certain languages
which are just taking up

00:32:04.665 --> 00:32:09.110
too much space, or accommodate
the different widths of screen

00:32:09.110 --> 00:32:11.570
et cetera.

00:32:11.570 --> 00:32:14.420
And here are some of the
most important strategies

00:32:14.420 --> 00:32:16.930
to follow when you want to
do responsive layouts and

00:32:16.930 --> 00:32:18.180
responsive design.

00:32:18.180 --> 00:32:21.160
So alternate your layouts,
try to reuse your ViewGroups

00:32:21.160 --> 00:32:22.300
and Fragments.

00:32:22.300 --> 00:32:24.650
Localize the layouts when
necessary, think about left

00:32:24.650 --> 00:32:26.990
to right-- that might
change some of those layouts

00:32:26.990 --> 00:32:28.720
pretty drastically.

00:32:28.720 --> 00:32:30.330
Material Design
Metrics and Keylines

00:32:30.330 --> 00:32:32.840
are a really a nice
tool to be aware of here

00:32:32.840 --> 00:32:36.130
when you want to do
responsive design.

00:32:36.130 --> 00:32:39.950
Use relative, percent layouts,
dp's and sp's for text.

00:32:39.950 --> 00:32:41.080
Never use px, please.

00:32:41.080 --> 00:32:42.690
It's for your own good.

00:32:42.690 --> 00:32:45.410
Nine-patches are nice and
SVGs and a vector drawables

00:32:45.410 --> 00:32:49.450
are a very nice tool, as well,
when you want to do responsive.

00:32:49.450 --> 00:32:52.480
For memory, I'm going
to keep it short.

00:32:52.480 --> 00:32:53.960
Simply avoid the pitfalls.

00:32:53.960 --> 00:32:57.250
Image loading is a scary place,
usually, and leaking context

00:32:57.250 --> 00:32:59.770
is typically the one that
everybody gets wrong.

00:32:59.770 --> 00:33:03.390
So keeping in usage on-- keeping
an eye on all that memory

00:33:03.390 --> 00:33:06.480
is very important, so consider
using a tool like LeakCanary

00:33:06.480 --> 00:33:11.970
to detect the leaks early and
keep things simple for you.

00:33:11.970 --> 00:33:13.400
Then there's localization.

00:33:13.400 --> 00:33:14.710
We've touched on it.

00:33:14.710 --> 00:33:18.050
So this is a well-known quote
by French Canadian philosopher,

00:33:18.050 --> 00:33:20.890
which roughly translates
to the following.

00:33:20.890 --> 00:33:23.060
You'll notice it's
actually longer in English

00:33:23.060 --> 00:33:25.100
than it was in French,
in this case, but anyway.

00:33:25.100 --> 00:33:27.220
Proper localization
is actually super-hard

00:33:27.220 --> 00:33:29.242
and this is one of
the areas you're

00:33:29.242 --> 00:33:30.950
going to need to apply
some tender loving

00:33:30.950 --> 00:33:34.379
care if you really want
to reach a wider audience.

00:33:34.379 --> 00:33:36.170
So these are the big
challenges right here.

00:33:36.170 --> 00:33:39.200
We've talked about the
string length variance.

00:33:39.200 --> 00:33:42.030
Think about things like numbers,
dates, and time formatting

00:33:42.030 --> 00:33:44.510
that will change,
depending on your locale.

00:33:44.510 --> 00:33:46.464
So will your currencies.

00:33:46.464 --> 00:33:47.880
You might have
currencies that are

00:33:47.880 --> 00:33:49.770
going to be used in
different locales, as well.

00:33:49.770 --> 00:33:52.103
You're going to have different
rounding rules, depending

00:33:52.103 --> 00:33:54.680
on the countries, so remember
that locales are a language

00:33:54.680 --> 00:33:57.790
and country, and think
of localization QA

00:33:57.790 --> 00:34:00.370
and think about it
early in the process.

00:34:00.370 --> 00:34:02.969
You want to catch that time
where the translators are

00:34:02.969 --> 00:34:05.010
actually sending you
machine translations instead

00:34:05.010 --> 00:34:07.150
of human translations
and charging you for it.

00:34:07.150 --> 00:34:10.130
How will you know if you don't
speak Japanese, for example?

00:34:10.130 --> 00:34:12.550
So you need to think about
all those QA factors.

00:34:12.550 --> 00:34:14.480
They're very important.

00:34:14.480 --> 00:34:18.026
So we're going to pass
over to Royi again, thanks.

00:34:18.026 --> 00:34:20.510
[APPLAUSE AND CHEERS]

00:34:20.510 --> 00:34:22.210
ROYI BENYOSSEF:
Hear it for Etienne.

00:34:22.210 --> 00:34:25.850
OK, so I know we've dropped
a lot of information on you

00:34:25.850 --> 00:34:30.239
and we're running low on time,
but this is the last segment

00:34:30.239 --> 00:34:31.900
and it's probably
the most important,

00:34:31.900 --> 00:34:33.274
because it's the
one that's being

00:34:33.274 --> 00:34:36.750
left behind most of the time.

00:34:36.750 --> 00:34:38.500
How do we diagnose content?

00:34:38.500 --> 00:34:40.300
It sounds almost irrational.

00:34:40.300 --> 00:34:43.420
OK, Android was
kind enough to have

00:34:43.420 --> 00:34:47.723
a lot of tools in two groups--
on device or hosted devices.

00:34:47.723 --> 00:34:49.389
Now because we don't
have a lot of time,

00:34:49.389 --> 00:34:52.120
I'm going to do it real quickly,
so if there's a tool that you

00:34:52.120 --> 00:34:55.630
don't know about, tough for
you because most of them been

00:34:55.630 --> 00:34:57.340
around for five years or longer.

00:34:57.340 --> 00:34:59.570
So let's start with strict mode.

00:34:59.570 --> 00:35:03.740
Strict mode simply does a border
on the skin of an application

00:35:03.740 --> 00:35:07.090
if you're doing too much
work on the UI thread.

00:35:07.090 --> 00:35:08.440
Simple as that.

00:35:08.440 --> 00:35:10.750
If we look at an example,
with this GO-JEK, which

00:35:10.750 --> 00:35:13.930
is a location-based services
application out of Indonesia,

00:35:13.930 --> 00:35:15.749
and it's a beautiful
application,

00:35:15.749 --> 00:35:17.790
you can see it's completely
compliant because you

00:35:17.790 --> 00:35:21.610
see absolutely no red border
and trust me, strict mode is on.

00:35:21.610 --> 00:35:24.700
So kudos, guys, if you're here.

00:35:24.700 --> 00:35:27.980
Profile GPU rendering
means that it tells you

00:35:27.980 --> 00:35:31.850
how long it takes to render
each frames in four paths, which

00:35:31.850 --> 00:35:35.350
are creating display lists,
syncing the render thread,

00:35:35.350 --> 00:35:37.500
issuing the display list,
and swapping the buffers.

00:35:37.500 --> 00:35:40.160
And if it means nothing to
you, go talk to [? Ron, ?]

00:35:40.160 --> 00:35:41.980
I don't know.

00:35:41.980 --> 00:35:44.780
Here's an example with Myntra
that we talked about before.

00:35:44.780 --> 00:35:46.000
Beautiful material design.

00:35:46.000 --> 00:35:48.540
I'm going to say it a few
times, I love the app.

00:35:48.540 --> 00:35:51.010
It's a e-commerce app.

00:35:51.010 --> 00:35:53.500
The problem is, is that
you see the graph below

00:35:53.500 --> 00:35:55.830
and most of the time
it's over the threshold

00:35:55.830 --> 00:35:57.900
and then you see
peaks where it janks.

00:35:57.900 --> 00:35:59.832
That's exactly
what's wrong with it.

00:35:59.832 --> 00:36:02.100
Just imagine how this
wonderful looking app

00:36:02.100 --> 00:36:05.052
would look better if it
was completely performant.

00:36:05.052 --> 00:36:07.480
Debug GPU overdraw
is very important

00:36:07.480 --> 00:36:09.340
because it's telling
you how many times you

00:36:09.340 --> 00:36:13.230
draw each pixels, which tells
you what is the GPU overhead.

00:36:13.230 --> 00:36:17.640
Well, you cannot avoid all
overdraw, but lower is better.

00:36:17.640 --> 00:36:20.480
So MakeMyTrip, which
we did mention before,

00:36:20.480 --> 00:36:21.660
again looks great.

00:36:21.660 --> 00:36:24.060
And as you can see--
first of all, in settings,

00:36:24.060 --> 00:36:25.140
it's not transparent.

00:36:25.140 --> 00:36:26.510
It's a good thing to show.

00:36:26.510 --> 00:36:29.640
MakeMyTrip is almost transparent
and it does so wonderfully.

00:36:29.640 --> 00:36:32.880
But the navigation drawer
is almost completely red,

00:36:32.880 --> 00:36:34.490
and I hope it's
because they used

00:36:34.490 --> 00:36:37.890
the wrong third-party library,
so guys, check this out.

00:36:37.890 --> 00:36:39.510
The funny thing is, is this one.

00:36:39.510 --> 00:36:40.800
Look at the scrolling.

00:36:40.800 --> 00:36:43.390
It will scroll down and you'll
see that the images become

00:36:43.390 --> 00:36:44.830
redder as they go.

00:36:44.830 --> 00:36:47.470
This just streams
get view issues,

00:36:47.470 --> 00:36:49.030
and it's a perfect
example of how

00:36:49.030 --> 00:36:51.130
you can find performance
issues in get

00:36:51.130 --> 00:36:53.600
views which are completely
implicit to the tools.

00:36:53.600 --> 00:36:55.380
So guys, check it out.

00:36:55.380 --> 00:36:58.270
Otherwise, this app
is just beautiful.

00:36:58.270 --> 00:37:00.770
Host Tools, layout
and hierarchy.

00:37:00.770 --> 00:37:01.660
Hierarchy Viewer.

00:37:01.660 --> 00:37:05.390
Is there anybody who doesn't
know Hierarchy Viewer?

00:37:05.390 --> 00:37:05.890
Excellent.

00:37:05.890 --> 00:37:06.910
Moving on.

00:37:06.910 --> 00:37:09.630
Now, GoRide, which
we mentioned earlier,

00:37:09.630 --> 00:37:10.780
is a wonderful example.

00:37:10.780 --> 00:37:11.450
I love this app.

00:37:11.450 --> 00:37:13.680
It's beautiful, it's
clear, but in this screen,

00:37:13.680 --> 00:37:15.610
they have 14 layers.

00:37:15.610 --> 00:37:18.560
Which means that on my device,
which was powerful and modern,

00:37:18.560 --> 00:37:19.820
everything was great.

00:37:19.820 --> 00:37:24.540
But if you think of a lower-end
device or an older device,

00:37:24.540 --> 00:37:29.680
it might jank as hell,
so I would check that.

00:37:29.680 --> 00:37:32.450
Method and event
profiling has Systrace,

00:37:32.450 --> 00:37:35.420
which is putting the events
in the system in a timeline,

00:37:35.420 --> 00:37:37.180
and it's very, very helpful.

00:37:37.180 --> 00:37:39.910
It also has Traceview,
which has trace mode, which

00:37:39.910 --> 00:37:42.711
traces the method calls,
or it can check out

00:37:42.711 --> 00:37:44.460
through a limited time,
which is something

00:37:44.460 --> 00:37:46.590
that's called sample mode.

00:37:46.590 --> 00:37:54.630
I'm examining Practo,
sorry, with Systrace,

00:37:54.630 --> 00:37:56.650
because it looks smooth
enough on my device

00:37:56.650 --> 00:37:59.430
but you can see all
that information.

00:37:59.430 --> 00:38:01.050
You can also see the frames.

00:38:01.050 --> 00:38:05.260
Notice that the frames
are right on on the place

00:38:05.260 --> 00:38:06.700
where they painted.

00:38:06.700 --> 00:38:10.320
So Systrace actually said
that one of these frame

00:38:10.320 --> 00:38:14.870
was delayed due to the fact
that it use too much UI

00:38:14.870 --> 00:38:16.380
thread-blocking
over other threads,

00:38:16.380 --> 00:38:19.000
and it had a problem with
background thread priorities,

00:38:19.000 --> 00:38:21.079
so it was delayed
and caused jank.

00:38:21.079 --> 00:38:21.745
This is perfect.

00:38:21.745 --> 00:38:23.700
It actually tells you
what you're doing wrong

00:38:23.700 --> 00:38:25.750
and how to fix it.

00:38:25.750 --> 00:38:27.990
Allocations and
memory profiles are

00:38:27.990 --> 00:38:30.800
very important because
allocations are very important.

00:38:30.800 --> 00:38:32.220
Now, you have three main tools.

00:38:32.220 --> 00:38:34.110
You have the allocation
tracker, which

00:38:34.110 --> 00:38:36.582
is best if you have jank
in specific animations

00:38:36.582 --> 00:38:38.040
and you don't know
how to solve it.

00:38:38.040 --> 00:38:39.630
It will tell you
exactly what to do.

00:38:39.630 --> 00:38:42.940
You have MAT that helps
you find memory leaks.

00:38:42.940 --> 00:38:44.750
And you have Memory
Monitor, which

00:38:44.750 --> 00:38:47.450
puts a visual representation
of heap usage,

00:38:47.450 --> 00:38:49.360
and it's very
helpful for runtime.

00:38:49.360 --> 00:38:53.380
This is an example,
again, for MakeMyTrip.

00:38:53.380 --> 00:38:54.250
A wonderful example.

00:38:54.250 --> 00:38:56.610
We don't have time to go
into it, but trust me,

00:38:56.610 --> 00:38:58.420
it tells you a lot.

00:38:58.420 --> 00:38:59.830
So let's talk about pain point.

00:38:59.830 --> 00:39:02.170
If you have a problem
with UI responsiveness,

00:39:02.170 --> 00:39:03.700
pay attention to
your allocations.

00:39:03.700 --> 00:39:05.990
Use the memory
allocation tracker,

00:39:05.990 --> 00:39:07.790
because if you're
allocating too much,

00:39:07.790 --> 00:39:11.670
you're just starting
the CPU and GPU.

00:39:11.670 --> 00:39:13.760
UI should not be
dependent on loading.

00:39:13.760 --> 00:39:16.180
Decouple rendering from
connectivity is important.

00:39:16.180 --> 00:39:19.640
Use caching for this, use all
kinds of pattern for this.

00:39:19.640 --> 00:39:21.520
Simply put them apart.

00:39:21.520 --> 00:39:23.860
It does not need to
impact one another.

00:39:23.860 --> 00:39:25.072
Use the GPU correctly.

00:39:25.072 --> 00:39:27.280
If you do not know if you're
using the GPU correctly,

00:39:27.280 --> 00:39:28.050
that's wonderful.

00:39:28.050 --> 00:39:30.390
Use the rendering
agent and the overdraw

00:39:30.390 --> 00:39:31.950
to know if you're
using it correctly

00:39:31.950 --> 00:39:35.120
and you're using hardware
acceleration correctly.

00:39:35.120 --> 00:39:36.720
Moving onto UX.

00:39:36.720 --> 00:39:37.960
UX is even more important.

00:39:37.960 --> 00:39:41.380
Your app could be absolutely
performant but still terrible.

00:39:41.380 --> 00:39:44.780
So here are few patterns to
help you not be terrible.

00:39:44.780 --> 00:39:47.170
Material design is a
good place to start.

00:39:47.170 --> 00:39:49.070
It alleviates a lot of aches.

00:39:49.070 --> 00:39:51.570
You really need to know what
you're doing if you're stepping

00:39:51.570 --> 00:39:54.990
out of material design, and
I cannot stress this enough.

00:39:54.990 --> 00:39:57.340
Cover all end and empty cases.

00:39:57.340 --> 00:39:59.030
If there's a reason
that you do not

00:39:59.030 --> 00:40:00.720
have content on
your screen, it has

00:40:00.720 --> 00:40:04.790
to be apparent as to why, with
a clear message, and preferably

00:40:04.790 --> 00:40:07.920
a nice animation to make
the people feel better,

00:40:07.920 --> 00:40:10.770
a call-to-action so that
they'll know what to do,

00:40:10.770 --> 00:40:12.810
and the way to do it on screen.

00:40:12.810 --> 00:40:14.239
So for instance, GO-JEK again.

00:40:14.239 --> 00:40:15.030
Now, they're right.

00:40:15.030 --> 00:40:17.820
I had no items in in
progress or completed.

00:40:17.820 --> 00:40:18.920
They're absolutely right.

00:40:18.920 --> 00:40:21.930
But to put a blank
screen tells me nothing.

00:40:21.930 --> 00:40:24.370
It's just kind of disappointing.

00:40:24.370 --> 00:40:27.240
On the other hand, Rounds have
a wonderful screen telling me

00:40:27.240 --> 00:40:28.910
that I don't have any chats yet.

00:40:28.910 --> 00:40:31.151
It's nice and colorful,
it has a button for me

00:40:31.151 --> 00:40:33.650
to start a new chat, and they're
giving me a call-to-action.

00:40:33.650 --> 00:40:34.430
Wait for it.

00:40:34.430 --> 00:40:35.720
Start new chat.

00:40:35.720 --> 00:40:38.210
I actually know what's going
on and what I need to do,

00:40:38.210 --> 00:40:39.550
and that's perfect.

00:40:39.550 --> 00:40:41.790
This example I don't have
time for because Etienne

00:40:41.790 --> 00:40:43.690
already mentioned
it, so we're moving

00:40:43.690 --> 00:40:45.910
on to avoiding
deprecated patterns.

00:40:45.910 --> 00:40:47.920
I see a lot of
applications that I'm

00:40:47.920 --> 00:40:50.650
reviewing that are
using the overflow menu,

00:40:50.650 --> 00:40:53.160
the dashboard pattern,
the action bar.

00:40:53.160 --> 00:40:54.660
They're old.

00:40:54.660 --> 00:40:56.927
We stopped using them because
users don't like them,

00:40:56.927 --> 00:40:59.010
because they're cumbersome,
because they're dated.

00:40:59.010 --> 00:41:00.090
Stop using them.

00:41:00.090 --> 00:41:02.420
You have plenty of
new things to go.

00:41:02.420 --> 00:41:04.240
Practo, again, is a
wonderful application.

00:41:04.240 --> 00:41:06.380
Almost everything is
elegant and correct.

00:41:06.380 --> 00:41:07.910
But they're using
the overflow menu

00:41:07.910 --> 00:41:11.246
on my phone that has
Android N. It's not even M.

00:41:11.246 --> 00:41:13.090
And it looks dated.

00:41:13.090 --> 00:41:14.240
It's only text.

00:41:14.240 --> 00:41:17.700
While MakeMyTrip, look at how
colorful and wonderful that is.

00:41:17.700 --> 00:41:20.140
I think it speaks volumes.

00:41:20.140 --> 00:41:21.760
Last but not least--
and I'm not going

00:41:21.760 --> 00:41:23.176
to give an example
because I don't

00:41:23.176 --> 00:41:25.590
have time-- is find
out the places that

00:41:25.590 --> 00:41:26.610
has a lot of friction.

00:41:26.610 --> 00:41:30.190
Smooth them out by
understanding the users

00:41:30.190 --> 00:41:32.690
and putting something
to make them

00:41:32.690 --> 00:41:34.220
understand what's going on.

00:41:34.220 --> 00:41:38.610
So now, I'm calling Dawid again
to wrap things up and mention

00:41:38.610 --> 00:41:39.791
other stuff.

00:41:39.791 --> 00:41:44.996
[APPLAUSE AND CHEERS]

00:41:44.996 --> 00:41:46.370
DAWID OSTROWSKI:
Thank you, Royi.

00:41:46.370 --> 00:41:47.360
Thank you, Royi.

00:41:47.360 --> 00:41:49.430
That's all that we have
prepared for you today.

00:41:49.430 --> 00:41:52.690
I hope you now are much more
interested in topics that

00:41:52.690 --> 00:41:55.050
affect users around the world.

00:41:55.050 --> 00:41:59.310
Connectivity, data cost,
battery consumption,

00:41:59.310 --> 00:42:01.849
device capabilities,
and content.

00:42:01.849 --> 00:42:03.390
If you would like
to learn even more,

00:42:03.390 --> 00:42:06.560
please attend other sessions
on building apps for billions.

00:42:06.560 --> 00:42:08.160
The one focused on
the [? web ?] will

00:42:08.160 --> 00:42:11.190
be tomorrow at 10:00 AM,
followed by the Android one

00:42:11.190 --> 00:42:12.890
at 3:00 PM.

00:42:12.890 --> 00:42:17.120
Please don't forget to go to
developers.google.com/billions

00:42:17.120 --> 00:42:19.810
to make yourself familiar with
the details and recommendations

00:42:19.810 --> 00:42:20.727
and best practices.

00:42:20.727 --> 00:42:23.310
If you would like to learn more
about Google Developer Experts

00:42:23.310 --> 00:42:27.830
Program, just go to
developers.google.com/experts.

00:42:27.830 --> 00:42:30.220
Thanks a lot for listening,
and have a great evening.

00:42:30.220 --> 00:42:31.420
Thank you, Royi and Etienne.

00:42:31.420 --> 00:42:31.920
Thank you.

00:42:31.920 --> 00:42:34.120
[APPLAUSE AND CHEERS]

00:42:34.120 --> 00:42:38.070
[MUSIC PLAYING]

