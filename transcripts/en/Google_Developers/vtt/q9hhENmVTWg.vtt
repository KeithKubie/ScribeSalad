WEBVTT
Kind: captions
Language: en

00:00:01.400 --> 00:00:03.367
Norton:
Hi, everyone.

00:00:03.367 --> 00:00:07.868
So welcome to the second
in the Google Web Toolkit track.

00:00:07.868 --> 00:00:09.501
I'm Kelly Norton.

00:00:09.501 --> 00:00:12.133
As you might imagine,
I'm a software engineer

00:00:12.133 --> 00:00:14.100
also working
on the Google Web Toolkit.

00:00:14.100 --> 00:00:16.467
I also have a particular
interest in browser performance

00:00:16.467 --> 00:00:20.467
and particularly
visualizing

00:00:20.467 --> 00:00:24.934
the performance data
in browsers.

00:00:24.934 --> 00:00:27.968
So since GWT
was released in 2006,

00:00:27.968 --> 00:00:29.767
there really have been
two parallel stories

00:00:29.767 --> 00:00:34.000
that have been
forming around GWT.

00:00:34.000 --> 00:00:36.501
One tells about using
the Java language

00:00:36.501 --> 00:00:38.100
to build Ajax sites,

00:00:38.100 --> 00:00:41.467
and using all the tools
that are available

00:00:41.467 --> 00:00:44.400
to the Java
runtime language.

00:00:44.400 --> 00:00:47.067
The second one
is about taking the effort

00:00:47.067 --> 00:00:49.234
that you might
put into one heroic effort,

00:00:49.234 --> 00:00:51.501
one single
Ajax application,

00:00:51.501 --> 00:00:53.567
and actually investing
that effort

00:00:53.567 --> 00:00:55.234
back into the tools.

00:00:55.234 --> 00:00:57.200
So instead of getting
just, you know,

00:00:57.200 --> 00:00:59.834
one app that pushes
the envelope

00:00:59.834 --> 00:01:01.534
in what you can do
in the browser,

00:01:01.534 --> 00:01:03.601
you actually begin to raise
the ceiling

00:01:03.601 --> 00:01:04.934
in what's possible.

00:01:04.934 --> 00:01:09.100
Now, with browsers,
performance has always been

00:01:09.100 --> 00:01:10.601
one of those huge ceilings

00:01:10.601 --> 00:01:13.033
that it's hard
to push through,

00:01:13.033 --> 00:01:15.033
you know, when you start
considering applications

00:01:15.033 --> 00:01:17.868
like the applications
we want to develop these days.

00:01:17.868 --> 00:01:21.901
So this talk is in part
about some of the things

00:01:21.901 --> 00:01:25.501
that we're doing
with Google Web Toolkit

00:01:25.501 --> 00:01:29.601
to try to push through
that ceiling.

00:01:29.601 --> 00:01:32.300
As you can imagine,

00:01:32.300 --> 00:01:34.000
that's an effort
that deals a lot

00:01:34.000 --> 00:01:35.901
with a lot of small
pieces of time--

00:01:35.901 --> 00:01:38.734
measuring and looking at
a lot of small pieces of time--

00:01:38.734 --> 00:01:40.501
milliseconds,
in fact.

00:01:40.501 --> 00:01:42.334
But what I hope in the first
segment of this talk

00:01:42.334 --> 00:01:43.701
is that I'll convince you

00:01:43.701 --> 00:01:46.434
that that's an effort
that your users will notice.

00:01:46.434 --> 00:01:50.234
So what we're actually
gonna talk about today is--

00:01:50.234 --> 00:01:51.734
First is why worry
about performance?

00:01:51.734 --> 00:01:53.133
This is an answer
that everyone here

00:01:53.133 --> 00:01:55.133
probably has a good an--

00:01:55.133 --> 00:01:56.367
is a question
that everyone here

00:01:56.367 --> 00:01:58.267
probably has a good answer
for already,

00:01:58.267 --> 00:02:00.334
however, I'm going to
give you my answer.

00:02:00.334 --> 00:02:01.567
Maybe you'll like it,

00:02:01.567 --> 00:02:04.200
maybe you'll stick with
your answer.

00:02:04.200 --> 00:02:07.834
After that,
GWT is tools.

00:02:07.834 --> 00:02:10.701
So we've always said
that there was a set of things

00:02:10.701 --> 00:02:12.667
that would just be
taken care of for you.

00:02:12.667 --> 00:02:13.868
There's a lot of tedium

00:02:13.868 --> 00:02:16.267
in making well-performing
web apps,

00:02:16.267 --> 00:02:19.267
and GWT tries very hard
to take the tedium out.

00:02:19.267 --> 00:02:20.367
At least some of it.

00:02:20.367 --> 00:02:22.901
However, while it
would be really cool

00:02:22.901 --> 00:02:24.667
if GWT could just
do everything for you,

00:02:24.667 --> 00:02:26.100
we don't anticipate
getting there

00:02:26.100 --> 00:02:27.701
until, like,
GWT 1.3 or something,

00:02:27.701 --> 00:02:29.701
so I'll actually
talk about four things

00:02:29.701 --> 00:02:31.367
that you should
do yourself

00:02:31.367 --> 00:02:34.133
to help your apps
perform better.

00:02:34.133 --> 00:02:35.367
So let's jump right in.

00:02:35.367 --> 00:02:36.834
Why worry
about performance?

00:02:36.834 --> 00:02:39.634
Okay, so I'll tell you,
I have a bias,

00:02:39.634 --> 00:02:40.968
but I think it is true.

00:02:40.968 --> 00:02:42.267
The main reason you need
to worry about performance

00:02:42.267 --> 00:02:44.734
is it's
a usability concern.

00:02:44.734 --> 00:02:46.601
When developers
talk about--

00:02:46.601 --> 00:02:48.567
developers talk
about performance--

00:02:48.567 --> 00:02:49.968
When you start
talking about users,

00:02:49.968 --> 00:02:51.901
you're actually
talking about delay.

00:02:51.901 --> 00:02:54.534
Well, it turns out that
we've been studying delays--

00:02:54.534 --> 00:02:56.300
how humans react
to delays in computers

00:02:56.300 --> 00:02:58.267
since, like, the 1960s,

00:02:58.267 --> 00:02:59.601
and we even like
some numbers

00:02:59.601 --> 00:03:01.801
that we've had since
the 1980s.

00:03:01.801 --> 00:03:03.834
And so I'm gonna share
three of these numbers

00:03:03.834 --> 00:03:08.033
that I think are really key
as you develop your own apps.

00:03:08.033 --> 00:03:11.133
So I call this a simple model
for how delay affects us.

00:03:11.133 --> 00:03:13.100
The first one,
which is my favorite,

00:03:13.100 --> 00:03:15.334
is 100 milliseconds.

00:03:15.334 --> 00:03:17.834
So 100 milliseconds
is the time required

00:03:17.834 --> 00:03:19.400
to get a screen updated

00:03:19.400 --> 00:03:22.000
so the user sees it
as instantaneous.

00:03:22.000 --> 00:03:23.534
Now, I'll show you
an example in a minute

00:03:23.534 --> 00:03:26.434
where 100 milliseconds
is not even enough.

00:03:26.434 --> 00:03:28.033
In fact, 100 milliseconds
is the limit.

00:03:28.033 --> 00:03:30.067
All these numbers I'm gonna
show you are upper limits.

00:03:30.067 --> 00:03:32.534
So 100 milliseconds
is the limit

00:03:32.534 --> 00:03:33.834
at which you update
a screen

00:03:33.834 --> 00:03:35.334
and people see it
as instantaneous.

00:03:35.334 --> 00:03:37.234
This is actually highly
relevant

00:03:37.234 --> 00:03:38.567
if you're doing animations,

00:03:38.567 --> 00:03:40.934
or if you're doing
direct manipulation techniques

00:03:40.934 --> 00:03:42.434
like drag and drop.

00:03:42.434 --> 00:03:45.067
Now the second number
is one second.

00:03:45.067 --> 00:03:48.434
So at one second,
a user notices a pause.

00:03:48.434 --> 00:03:49.601
However, there's still

00:03:49.601 --> 00:03:51.734
a nice cause and effect
relationship.

00:03:51.734 --> 00:03:54.567
They click on something,
and something happens.

00:03:54.567 --> 00:03:56.267
It's still
the same single task.

00:03:56.267 --> 00:03:57.834
A lot of people say
this is the limit

00:03:57.834 --> 00:04:00.300
at which you should
consider giving feedback.

00:04:00.300 --> 00:04:01.534
If you're gonna have
something that's gonna

00:04:01.534 --> 00:04:03.300
take longer than
one second to update,

00:04:03.300 --> 00:04:04.968
you should consider
an extra device

00:04:04.968 --> 00:04:07.968
for giving feedback
in your applications.

00:04:07.968 --> 00:04:11.534
And then the final
number here is ten seconds.

00:04:11.534 --> 00:04:14.968
So ten seconds is sort of
a disruptive time.

00:04:14.968 --> 00:04:16.767
And of course these
are all average numbers.

00:04:16.767 --> 00:04:19.167
I mean, some people
may abandon quickly,

00:04:19.167 --> 00:04:21.801
some people may
stay around all day.

00:04:21.801 --> 00:04:25.234
It varies by individual
and a lot of other factors.

00:04:25.234 --> 00:04:26.501
But this is a point
at which

00:04:26.501 --> 00:04:28.534
disruption can start
to occur.

00:04:28.534 --> 00:04:30.567
And, you know,
people go do other things

00:04:30.567 --> 00:04:32.467
like issue some more
complaints

00:04:32.467 --> 00:04:35.167
about the Facebook design.

00:04:35.167 --> 00:04:37.567
But beyond that,
I mean,

00:04:37.567 --> 00:04:39.000
we know that users notice.

00:04:39.000 --> 00:04:43.067
We know that they notice
delays in user interfaces.

00:04:43.067 --> 00:04:44.801
I mean, and the people
in this room

00:04:44.801 --> 00:04:47.434
have probably,
in their experience,

00:04:47.434 --> 00:04:49.200
described something
as just being sluggish--

00:04:49.200 --> 00:04:51.801
perhaps you used a more
sophisticated word like "janky."

00:04:51.801 --> 00:04:53.801
But you can notice.

00:04:53.801 --> 00:04:55.100
You noticed when things

00:04:55.100 --> 00:04:57.200
weren't responding
the way you expected it to.

00:04:57.200 --> 00:04:58.834
The real irony in this
is the whole reason

00:04:58.834 --> 00:05:00.267
we're doing these
Ajax applications

00:05:00.267 --> 00:05:03.200
is we aim to give users
more control.

00:05:03.200 --> 00:05:06.000
And it's funny that
we would then take them away

00:05:06.000 --> 00:05:09.601
by adding different
delays like updating--

00:05:09.601 --> 00:05:11.133
like running a bunch
of JavaScript code,

00:05:11.133 --> 00:05:13.400
and, you know,
not returning quickly enough.

00:05:13.400 --> 00:05:14.934
But in fact it goes beyond

00:05:14.934 --> 00:05:18.033
just noticing
that things are sluggish.

00:05:18.033 --> 00:05:19.334
In fact, there have
been some studies

00:05:19.334 --> 00:05:23.000
that show that when you add
latency into the mix,

00:05:23.000 --> 00:05:25.968
people actually start
to evaluate the content

00:05:25.968 --> 00:05:27.834
as being lower quality.

00:05:27.834 --> 00:05:29.901
And if you're interested in
the full details of that study,

00:05:29.901 --> 00:05:32.067
there's a link
at the bottom,

00:05:32.067 --> 00:05:33.634
and I think the slides
will be available.

00:05:33.634 --> 00:05:35.334
Pretty sure they will.

00:05:35.334 --> 00:05:36.901
Okay, so--

00:05:36.901 --> 00:05:39.734
But, you know, don't just
trust my judgment,

00:05:39.734 --> 00:05:42.501
let's actually try
a little experiment here.

00:05:42.501 --> 00:05:45.100
So very simple
interaction here.

00:05:45.100 --> 00:05:48.434
Something you've surely
seen in a Web app,

00:05:48.434 --> 00:05:50.734
just a simple
hover highlight, right?

00:05:50.734 --> 00:05:51.934
So I'm gonna take this,

00:05:51.934 --> 00:05:54.234
and we're gonna try it
with no delay.

00:05:54.234 --> 00:05:55.601
And clearly
it's keeping up, right?

00:05:55.601 --> 00:05:57.634
I mean, it's no
problem here.

00:05:57.634 --> 00:06:00.033
So let's actually
throw in 25 milliseconds.

00:06:00.033 --> 00:06:02.868
Now at 25 milliseconds
it's still keeping up.

00:06:02.868 --> 00:06:05.000
I mean, maybe if you have
the eyes of an eagle

00:06:05.000 --> 00:06:07.501
you can discern
some delay.

00:06:07.501 --> 00:06:08.901
But at 50 milliseconds--

00:06:08.901 --> 00:06:11.534
Now remember I said the limit
here is 100 milliseconds,

00:06:11.534 --> 00:06:13.534
but at 50 milliseconds
you start to see

00:06:13.534 --> 00:06:16.167
that we're not quite
keeping up.

00:06:16.167 --> 00:06:17.567
At 100 milliseconds,

00:06:17.567 --> 00:06:21.634
I don't care what kind of night
you had,

00:06:21.634 --> 00:06:24.367
this isn't keeping up.

00:06:24.367 --> 00:06:26.934
So it just goes to show you
that, you know,

00:06:26.934 --> 00:06:28.667
even with these numbers,
you look at the maxes,

00:06:28.667 --> 00:06:31.267
there are still interactions
that happen in Web apps

00:06:31.267 --> 00:06:33.534
that are very common,
in fact,

00:06:33.534 --> 00:06:35.567
for which even
100 milliseconds

00:06:35.567 --> 00:06:38.267
is not fast enough.

00:06:38.267 --> 00:06:40.734
Okay, so hopefully that was
a really quick way--

00:06:40.734 --> 00:06:42.734
if you weren't convinced
that performance is important,

00:06:42.734 --> 00:06:45.434
hopefully that was a little bit
of a way to convince you.

00:06:45.434 --> 00:06:46.701
Now, let's talk about

00:06:46.701 --> 00:06:49.434
four things GWT does for you
performance-wise.

00:06:49.434 --> 00:06:50.868
So the first thing,

00:06:50.868 --> 00:06:52.033
we've always said

00:06:52.033 --> 00:06:54.868
GWT produces fast
JavaScript code.

00:06:54.868 --> 00:06:56.200
A lot of people,

00:06:56.200 --> 00:06:57.734
when they heard that GWT was
a compiler,

00:06:57.734 --> 00:06:58.934
they assumed that

00:06:58.934 --> 00:07:01.367
it just did
a straight, loyal translation

00:07:01.367 --> 00:07:05.167
from Java to the closest
JavaScript code out there.

00:07:05.167 --> 00:07:06.467
That couldn't be
further from the truth.

00:07:06.467 --> 00:07:09.167
The GWT compiler is, in fact,
an optimizing compiler,

00:07:09.167 --> 00:07:10.434
and I'll tell you
some of the--

00:07:10.434 --> 00:07:12.968
just a few techniques it does
in just a minute.

00:07:12.968 --> 00:07:15.968
What you actually see on
the screen

00:07:15.968 --> 00:07:17.133
are some benchmarks--

00:07:17.133 --> 00:07:19.400
the results
from some benchmarks.

00:07:19.400 --> 00:07:21.234
These are--

00:07:21.234 --> 00:07:23.067
We actually took
some of the SunSpider tests,

00:07:23.067 --> 00:07:24.601
which are benchmarks
you find

00:07:24.601 --> 00:07:25.968
in the Web kit rendering
engine

00:07:25.968 --> 00:07:27.634
for their JavaScript engine,
we ported over to Java.

00:07:27.634 --> 00:07:30.534
The reason why we did this
is because the only way

00:07:30.534 --> 00:07:32.834
to really improve
performance-wise

00:07:32.834 --> 00:07:34.934
is to measure things.

00:07:34.934 --> 00:07:38.067
And so we decided that,
well, if we're gonna actually

00:07:38.067 --> 00:07:40.567
make the claim
that GWT can produce

00:07:40.567 --> 00:07:43.868
faster JavaScript code
than you would write by hand,

00:07:43.868 --> 00:07:45.934
we should probably
actually check this.

00:07:45.934 --> 00:07:47.601
And continue
to check this,

00:07:47.601 --> 00:07:50.200
and as we make changes
we should continue to make sure

00:07:50.200 --> 00:07:53.367
that it continues
to hold on its promise.

00:07:53.367 --> 00:07:54.501
And as you can see,

00:07:54.501 --> 00:07:56.434
it does pretty well here
on its promise

00:07:56.434 --> 00:07:57.968
with the ones
I've highlighted.

00:07:57.968 --> 00:08:01.200
And I'll show you
some more in just a second.

00:08:01.200 --> 00:08:03.634
So GWT is in yellow.

00:08:03.634 --> 00:08:04.934
The bar in blue

00:08:04.934 --> 00:08:08.133
is actually
the hand-written JavaScript

00:08:08.133 --> 00:08:09.501
taken directly
out of the test

00:08:09.501 --> 00:08:10.968
and then run
through an obfuscator

00:08:10.968 --> 00:08:15.100
just to sort of
do apples to apples.

00:08:15.100 --> 00:08:16.267
And you see
we do quite well.

00:08:16.267 --> 00:08:18.767
However, we don't
win 'em all.

00:08:18.767 --> 00:08:20.234
I mean, we--

00:08:20.234 --> 00:08:23.534
In fact, the access-binary-trees
benchmark

00:08:23.534 --> 00:08:24.701
revealed an opportunity.

00:08:24.701 --> 00:08:25.901
I mean, this is
the whole reason

00:08:25.901 --> 00:08:28.234
why we were doing
the benchmarks in general.

00:08:28.234 --> 00:08:29.701
It revealed
an opportunity to speed up

00:08:29.701 --> 00:08:32.367
the way we translate

00:08:32.367 --> 00:08:34.200
Java constructors
in JavaScript.

00:08:34.200 --> 00:08:35.801
But the great thing,
and one thing I'll try

00:08:35.801 --> 00:08:37.200
to continue to remind you,

00:08:37.200 --> 00:08:39.033
is that GWT is
a set of tools.

00:08:39.033 --> 00:08:42.334
So this is now an issue
in our issue checker.

00:08:42.334 --> 00:08:44.167
It should be fixed
by GWT 2.0,

00:08:44.167 --> 00:08:46.634
and a speedup
is just a compile away.

00:08:46.634 --> 00:08:50.968
So as we get faster,
your apps get faster.

00:08:50.968 --> 00:08:52.501
So how do we do that?

00:08:52.501 --> 00:08:54.234
Well,
it's funny because

00:08:54.234 --> 00:08:56.801
I actually steal
this quote from online.

00:08:56.801 --> 00:08:58.167
We cheat,

00:08:58.167 --> 00:09:00.067
and we're quite proud of
the fact that we cheat.

00:09:00.067 --> 00:09:03.200
We cheat on the user's behalf,
in fact.

00:09:03.200 --> 00:09:04.367
One of the things
we do--

00:09:04.367 --> 00:09:05.868
and I'll just talk
about three things here,

00:09:05.868 --> 00:09:08.567
three techniques
that the GWT compiler uses

00:09:08.567 --> 00:09:09.667
that we get
a lot of bang for,

00:09:09.667 --> 00:09:12.667
particularly
in these benchmarks.

00:09:12.667 --> 00:09:15.834
The first one
is inlining.

00:09:15.834 --> 00:09:18.934
So that's just
simply a technique

00:09:18.934 --> 00:09:20.834
where you take
a method body and you just

00:09:20.834 --> 00:09:23.000
move it into all the places
where it's called,

00:09:23.000 --> 00:09:24.033
the call sites.

00:09:24.033 --> 00:09:26.734
Here's a really
simple example.

00:09:26.734 --> 00:09:28.667
It should be pretty
self-explanatory

00:09:28.667 --> 00:09:31.000
what this code does--
you create a new circle.

00:09:31.000 --> 00:09:33.100
I read Josh Bloch's talk,
so he recommended

00:09:33.100 --> 00:09:35.901
that I declare this as the
interface on the left-hand side.

00:09:35.901 --> 00:09:37.734
I do that.

00:09:37.734 --> 00:09:39.467
The GWT compiler sees,
but yeah,

00:09:39.467 --> 00:09:42.267
you told me it was
a shape,

00:09:42.267 --> 00:09:43.434
but in fact it's
a circle.

00:09:43.434 --> 00:09:44.767
I know that.

00:09:44.767 --> 00:09:47.501
Given the fact that I know
that it's now a circle,

00:09:47.501 --> 00:09:49.868
I actually know
the implementation for area.

00:09:49.868 --> 00:09:53.067
And so you see
in the last line

00:09:53.067 --> 00:09:54.868
it actually saw,

00:09:54.868 --> 00:09:56.467
well, the implementation
for area,

00:09:56.467 --> 00:09:57.701
I'll just put that
in there.

00:09:57.701 --> 00:10:00.834
And in fact, this other
method call widget.setText

00:10:00.834 --> 00:10:02.133
I'll go ahead
and inline that as well,

00:10:02.133 --> 00:10:03.868
and you can tell
that this is actually

00:10:03.868 --> 00:10:05.534
an indication
for the Mozilla browser.

00:10:05.534 --> 00:10:08.234
'Cause I think as Bruce
highlighted in his talk,

00:10:08.234 --> 00:10:11.033
we compile specifically
for the user agent.

00:10:11.033 --> 00:10:12.534
So it inlines
both of these.

00:10:12.534 --> 00:10:15.334
Now it's cool because these
calls have now been sped up.

00:10:15.334 --> 00:10:17.200
In some cases,
considerably.

00:10:17.200 --> 00:10:20.300
But the other big thing
is the methods get text and--

00:10:20.300 --> 00:10:22.200
sorry, the methods
"get area" and "set text"

00:10:22.200 --> 00:10:23.567
have been
completely eliminated.

00:10:23.567 --> 00:10:25.501
No need to even
put 'em in the source.

00:10:25.501 --> 00:10:27.267
We don't need 'em anymore.

00:10:27.267 --> 00:10:29.968
The other big thing
that we got a big bang for

00:10:29.968 --> 00:10:32.267
is a technique
called string interning,

00:10:32.267 --> 00:10:34.934
which is just
a long way of saying

00:10:34.934 --> 00:10:37.100
we take all the strings
in your application,

00:10:37.100 --> 00:10:38.767
we remove all
the duplicates,

00:10:38.767 --> 00:10:41.000
we put 'em in
a global table.

00:10:41.000 --> 00:10:43.234
The reason why
this one is important

00:10:43.234 --> 00:10:46.734
is because there are
certain JavaScript engines

00:10:46.734 --> 00:10:50.434
that have garbage collector
implementations

00:10:50.434 --> 00:10:51.701
that weren't really
intended for

00:10:51.701 --> 00:10:54.801
the apps we're writing,

00:10:54.801 --> 00:10:57.067
notably Internet Explorer.

00:10:57.067 --> 00:10:59.501
Now when you do
an inline function

00:10:59.501 --> 00:11:01.267
inside of a JavaScript--

00:11:01.267 --> 00:11:02.400
sorry, you do
an inline string load

00:11:02.400 --> 00:11:03.901
alongside
a JavaScript function,

00:11:03.901 --> 00:11:06.367
it actually causes
extra objects to get created,

00:11:06.367 --> 00:11:10.334
which in turn tends
to wake up the beast,

00:11:10.334 --> 00:11:12.033
which is
the garbage collector,

00:11:12.033 --> 00:11:14.133
which slows down
your runtime performance.

00:11:14.133 --> 00:11:15.534
So just by doing
this trick alone,

00:11:15.534 --> 00:11:19.133
we get a really nice
speed-up in J-Script,

00:11:19.133 --> 00:11:20.534
Internet Explorer's
engine,

00:11:20.534 --> 00:11:23.100
and it helps on other
engines as well.

00:11:23.100 --> 00:11:25.701
Now the last technique
gets the award

00:11:25.701 --> 00:11:27.801
as the fanciest-sounding
one.

00:11:27.801 --> 00:11:29.868
There are a number
of words for it,

00:11:29.868 --> 00:11:32.734
but I tend to call it
method de-virtualization.

00:11:32.734 --> 00:11:34.067
It sounds really
complicated,

00:11:34.067 --> 00:11:36.434
but basically what it is
is I take an instance method,

00:11:36.434 --> 00:11:40.334
I see that,
in this particular case,

00:11:40.334 --> 00:11:45.334
because I'm writing here
against an interface,

00:11:45.334 --> 00:11:46.934
and when you're writing
against an interface, I mean,

00:11:46.934 --> 00:11:49.968
usually that would
be a runtime dispatch.

00:11:49.968 --> 00:11:51.701
So you go, ah, well,
it's an interface,

00:11:51.701 --> 00:11:53.734
and this interface
has this method getText,

00:11:53.734 --> 00:11:55.801
so at runtime I actually
have to look and see,

00:11:55.801 --> 00:11:57.300
oh, well,
the getText method

00:11:57.300 --> 00:12:00.367
for this particular subclass
is here and I'll call that.

00:12:00.367 --> 00:12:01.968
Well, it turns out
that since GWT

00:12:01.968 --> 00:12:05.200
does this whole
program optimization,

00:12:05.200 --> 00:12:06.701
we actually see
all the subclasses,

00:12:06.701 --> 00:12:07.868
so in a lot of cases

00:12:07.868 --> 00:12:09.801
we actually know
at compile time

00:12:09.801 --> 00:12:11.367
that's actually the method
you're gonna call,

00:12:11.367 --> 00:12:14.567
which eliminates all this need
for runtime dispatch,

00:12:14.567 --> 00:12:16.801
and in turn we go,
eh, might as well

00:12:16.801 --> 00:12:18.234
not even make it
an instance method

00:12:18.234 --> 00:12:20.534
'cause when you translate
these things to JavaScript,

00:12:20.534 --> 00:12:22.434
the way you do this
virtual dispatch

00:12:22.434 --> 00:12:25.601
is that you assign objects
on the prototype chain,

00:12:25.601 --> 00:12:28.567
which means that at runtime
it has to walk a list

00:12:28.567 --> 00:12:31.534
looking for the method
that it needs to dispatch to.

00:12:31.534 --> 00:12:32.834
No need to do it.

00:12:32.834 --> 00:12:35.133
We already know what method
it's gonna dispatch to.

00:12:35.133 --> 00:12:38.067
So we basically translate it
to a static method.

00:12:38.067 --> 00:12:40.067
Now once we translate
to a static method,

00:12:40.067 --> 00:12:41.601
and one of
the other big things

00:12:41.601 --> 00:12:43.133
you get out of method
de-virtualization

00:12:43.133 --> 00:12:45.767
is it just unlocks more
opportunities for inlining.

00:12:45.767 --> 00:12:47.100
And in fact, in this case,

00:12:47.100 --> 00:12:49.734
I've stopped short of where
the GWT compiler would.

00:12:49.734 --> 00:12:51.133
When it got to
the JavaScript level,

00:12:51.133 --> 00:12:53.701
it would've just easily
inlined the body of this method

00:12:53.701 --> 00:12:54.868
everywhere it was called.

00:12:54.868 --> 00:12:56.501
I mean, it's short,
and it's been--

00:12:56.501 --> 00:12:59.734
particularly when you
obfuscate the names here.

00:12:59.734 --> 00:13:04.300
Okay, second thing we do.

00:13:04.300 --> 00:13:05.634
So in GWT 1.4,

00:13:05.634 --> 00:13:08.534
we introduced this notion
of image bundles,

00:13:08.534 --> 00:13:10.767
which was a really
cool concept.

00:13:10.767 --> 00:13:13.200
It basically meant
that in your app

00:13:13.200 --> 00:13:15.834
you could declare all the images
that you were gonna use,

00:13:15.834 --> 00:13:18.067
all the images you're gonna
use for button faces,

00:13:18.067 --> 00:13:19.133
all the images
you're gonna use

00:13:19.133 --> 00:13:22.634
for just any of
the treatment in the UI,

00:13:22.634 --> 00:13:27.434
and what the GWT compiler
would do is it would--

00:13:27.434 --> 00:13:28.801
when it actually
ran the compile,

00:13:28.801 --> 00:13:30.167
it would see
all the images and resources,

00:13:30.167 --> 00:13:34.000
pick them up, and distill it
into a single image.

00:13:34.000 --> 00:13:36.400
The reason
it did this is because

00:13:36.400 --> 00:13:38.667
one of the number one rules

00:13:38.667 --> 00:13:41.167
for speeding up
your app load time

00:13:41.167 --> 00:13:43.467
is just to simply reduce
the number of http requests.

00:13:43.467 --> 00:13:45.701
So if you can take all these
tiny, little images

00:13:45.701 --> 00:13:48.434
in an application,
assemble them into one image,

00:13:48.434 --> 00:13:51.834
you could actually get
a considerable speed-up.

00:13:51.834 --> 00:13:53.167
And we really
like that technique.

00:13:53.167 --> 00:13:56.467
In fact, we actually did
a heuristic bin packing

00:13:56.467 --> 00:13:59.200
to try to even get the image
down a little bit smaller.

00:13:59.200 --> 00:14:00.767
And we really
like that technique.

00:14:00.767 --> 00:14:02.033
The only things
we didn't like

00:14:02.033 --> 00:14:04.167
was the fact that
we still had all this CSS.

00:14:04.167 --> 00:14:05.634
And when you have CSS,

00:14:05.634 --> 00:14:08.067
it always has these
little images inside of it,

00:14:08.067 --> 00:14:10.634
and these are
extra http requests.

00:14:10.634 --> 00:14:12.968
So we decided for GWT 2.0

00:14:12.968 --> 00:14:14.834
to generalize this
even further,

00:14:14.834 --> 00:14:16.100
and so we've
come up with this

00:14:16.100 --> 00:14:19.267
more general notion
on this client bundle.

00:14:19.267 --> 00:14:21.901
And you can tell by this
Web Kit inspector graph

00:14:21.901 --> 00:14:24.734
that you can see the huge,
green blob there of CSS.

00:14:24.734 --> 00:14:26.400
That's what we wanted
to get rid of.

00:14:26.400 --> 00:14:28.400
So what does
this look like?

00:14:28.400 --> 00:14:30.234
So this is just
a really simple snippet.

00:14:30.234 --> 00:14:33.100
and by the way, client bundle
is not just relevant to CSS.

00:14:33.100 --> 00:14:35.667
It actually covers
all the static resources

00:14:35.667 --> 00:14:37.000
in your application.

00:14:37.000 --> 00:14:39.834
If you have static text
that you're using as data,

00:14:39.834 --> 00:14:43.033
you can actually include that
in a client bundle.

00:14:43.033 --> 00:14:45.234
You can add PDFs
as download--

00:14:45.234 --> 00:14:47.167
pretty much anything
that's static.

00:14:47.167 --> 00:14:49.000
And the nice thing
about it is

00:14:49.000 --> 00:14:51.200
as with anything
that comes out of the compiler,

00:14:51.200 --> 00:14:54.000
it's given a nice hash name
so that you can

00:14:54.000 --> 00:14:57.033
cache that thing
optimally.

00:14:57.033 --> 00:14:58.701
But to focus on the CSS
for a minute,

00:14:58.701 --> 00:15:00.067
you see here we have
a really simple example.

00:15:00.067 --> 00:15:04.300
We declare a couple of images,
giving it an attribute,

00:15:04.300 --> 00:15:05.868
pointing at
a particular resource

00:15:05.868 --> 00:15:07.734
that it'll find on disk.

00:15:07.734 --> 00:15:10.901
And then the last one
we declare a CSS resource,

00:15:10.901 --> 00:15:13.234
and we point it
to a CSS file.

00:15:13.234 --> 00:15:14.434
Now if you look at
the CSS file,

00:15:14.434 --> 00:15:17.067
it has a few extra things
in it.

00:15:17.067 --> 00:15:18.501
The first thing
you'll notice is that

00:15:18.501 --> 00:15:19.634
there's actually
an "if statement"

00:15:19.634 --> 00:15:23.400
that is using
a deferred binding property.

00:15:23.400 --> 00:15:25.567
In this case,
the browser.

00:15:25.567 --> 00:15:27.033
so we can actually
write "if statements"

00:15:27.033 --> 00:15:29.601
around particular
user agents.

00:15:29.601 --> 00:15:32.200
The second thing
is that there's this sprite,

00:15:32.200 --> 00:15:33.634
so rather than
having image bundles,

00:15:33.634 --> 00:15:35.601
which previously couldn't
take on these images

00:15:35.601 --> 00:15:37.567
that were down in CSS,

00:15:37.567 --> 00:15:41.801
we now have sprites
in the CSS which can handle

00:15:41.801 --> 00:15:44.167
both the images
that you're gonna use

00:15:44.167 --> 00:15:47.801
in the Java code
directly,

00:15:47.801 --> 00:15:49.000
and the images that

00:15:49.000 --> 00:15:51.234
you're going to use in CSS
altogether.

00:15:51.234 --> 00:15:53.567
And it can bundle
them all together.

00:15:53.567 --> 00:15:56.267
So once you have
your CSS bundled,

00:15:56.267 --> 00:15:58.033
what does that unlock?

00:15:58.033 --> 00:15:59.534
So the first thing is

00:15:59.534 --> 00:16:01.267
the CSS associated with
the application,

00:16:01.267 --> 00:16:04.067
not only can it
be made smaller,

00:16:04.067 --> 00:16:06.734
but the download for the CSS
can actually be eliminated.

00:16:06.734 --> 00:16:08.434
Because you can now take
the string resource

00:16:08.434 --> 00:16:10.434
that is the CSS and you can
actually move it directly

00:16:10.434 --> 00:16:12.167
in the compiled code.

00:16:12.167 --> 00:16:13.267
So you've gotten rid of

00:16:13.267 --> 00:16:15.467
the download for the CSS
altogether.

00:16:15.467 --> 00:16:16.968
The other thing is--

00:16:16.968 --> 00:16:19.901
Something that's very important
to GWT developers, obviously,

00:16:19.901 --> 00:16:22.868
is that if you have
a missing resource,

00:16:22.868 --> 00:16:24.334
it will tell you.

00:16:24.334 --> 00:16:26.167
So that little error icon

00:16:26.167 --> 00:16:27.334
that you have on
the error dialogue

00:16:27.334 --> 00:16:28.834
that you didn't
think to test,

00:16:28.834 --> 00:16:30.133
that happens to be in

00:16:30.133 --> 00:16:31.467
the wrong place
or misnamed the disk,

00:16:31.467 --> 00:16:34.400
you actually find that out
in compile time.

00:16:34.400 --> 00:16:37.000
The other thing is
doing this, you're able to--

00:16:37.000 --> 00:16:38.434
it runs through
the compiler,

00:16:38.434 --> 00:16:40.200
so you're able to do
a lot of the dead stripping

00:16:40.200 --> 00:16:43.901
that you get from other parts
of your code base.

00:16:43.901 --> 00:16:47.100
Another thing is much like
the JavaScript code,

00:16:47.100 --> 00:16:49.567
you now can
download CSS code

00:16:49.567 --> 00:16:51.868
that is directly
targeted at your browser.

00:16:51.868 --> 00:16:53.400
This is pretty big because

00:16:53.400 --> 00:16:55.534
many of the CSS hacks
that people use

00:16:55.534 --> 00:16:57.934
introduce CSS selectors

00:16:57.934 --> 00:16:59.634
that are actually
quite expensive,

00:16:59.634 --> 00:17:00.968
and they can actually have

00:17:00.968 --> 00:17:04.367
another simple effect
on runtime performance.

00:17:04.367 --> 00:17:07.801
And in fact, for images,
many of the images

00:17:07.801 --> 00:17:10.133
can actually be
turned into data urls,

00:17:10.133 --> 00:17:15.300
and can also be sent down
in your compiled output.

00:17:15.300 --> 00:17:18.534
So in fact it is possible
to write an application

00:17:18.534 --> 00:17:20.400
that is fully styled
in GWT 2.0,

00:17:20.400 --> 00:17:23.334
and never fetch any CSS
or any images.

00:17:23.334 --> 00:17:28.567
You only get the host page
and the compiled script.

00:17:30.400 --> 00:17:32.501
Okay, third thing.

00:17:32.501 --> 00:17:36.200
Third thing is this new feature,
code splitting.

00:17:36.200 --> 00:17:37.968
So we had a lot
of people telling us,

00:17:37.968 --> 00:17:41.434
"my app is getting
very large and I have--

00:17:41.434 --> 00:17:43.934
"I don't really put much
on the screen when I start.

00:17:43.934 --> 00:17:46.634
"What I would really love to do
is just load just what I need

00:17:46.634 --> 00:17:48.167
"for the first screen,

00:17:48.167 --> 00:17:50.334
"and then I want to load
the rest of the app

00:17:50.334 --> 00:17:52.033
later when I need it."

00:17:52.033 --> 00:17:53.667
And we thought
that was a good model.

00:17:53.667 --> 00:17:56.300
But, you know, we had this
monolithic compilation,

00:17:56.300 --> 00:17:58.234
which we were getting
a lot of good impact out of,

00:17:58.234 --> 00:18:00.901
and we really wanted
to keep that in place.

00:18:00.901 --> 00:18:02.067
So we found something

00:18:02.067 --> 00:18:05.234
that actually satisfies
both camps here.

00:18:05.234 --> 00:18:07.968
Now let me start by showing you
the effect we get out of it.

00:18:07.968 --> 00:18:09.868
So the big, red bar
you see up here

00:18:09.868 --> 00:18:11.434
is just a really
simple representation

00:18:11.434 --> 00:18:15.334
of how long it takes
to load our showcase example

00:18:15.334 --> 00:18:16.567
over a very slow
connection.

00:18:16.567 --> 00:18:17.868
We're actually using
a proxy here

00:18:17.868 --> 00:18:21.000
to simulate
a slow connection in GWT 1.6.

00:18:21.000 --> 00:18:24.534
So in this case, the app
weighs in at about 285 k.

00:18:24.534 --> 00:18:27.267
It's about 19 seconds
to load the application.

00:18:27.267 --> 00:18:29.267
Now one of the first things
we did, of course,

00:18:29.267 --> 00:18:30.601
when we got
code splitting working

00:18:30.601 --> 00:18:33.067
is we went and we updated
showcase.

00:18:33.067 --> 00:18:34.734
Now updating showcase,
as I'll show you,

00:18:34.734 --> 00:18:35.801
was pretty simple.

00:18:35.801 --> 00:18:36.934
We actually didn't
change anything

00:18:36.934 --> 00:18:38.434
logically
in the application.

00:18:38.434 --> 00:18:40.434
In fact, we just turned
a number of synchronous calls

00:18:40.434 --> 00:18:43.400
into asynchronous calls,
and we tested it.

00:18:43.400 --> 00:18:44.601
And here's what we got.

00:18:44.601 --> 00:18:48.100
So the split version,
the initial download,

00:18:48.100 --> 00:18:50.467
shrank by about 40%.

00:18:50.467 --> 00:18:52.267
The load time
shrank by about 40%.

00:18:52.267 --> 00:18:54.167
But the really
cool thing here is that

00:18:54.167 --> 00:18:58.033
even in just trying to get
the data to present to you,

00:18:58.033 --> 00:19:01.133
I did the initial download,
and clicked on the first link,

00:19:01.133 --> 00:19:04.434
and got the second fragment
before the original version

00:19:04.434 --> 00:19:06.067
would have even
finished loading.

00:19:06.067 --> 00:19:07.434
So I think
that's a testament

00:19:07.434 --> 00:19:10.634
to how effective
this technique actually is.

00:19:10.634 --> 00:19:13.400
So what does it actually
look like to do this?

00:19:13.400 --> 00:19:15.968
It's really straightforward.

00:19:15.968 --> 00:19:19.334
Obviously you have to load code,
so we want to--

00:19:19.334 --> 00:19:21.968
any time when you need to load
something from the server,

00:19:21.968 --> 00:19:23.534
we actually want that
to be asynchronous

00:19:23.534 --> 00:19:25.200
for a number
of good reasons.

00:19:25.200 --> 00:19:26.634
It is the right thing
to do in the browser.

00:19:26.634 --> 00:19:28.434
So we turn this
into an asynchronous call.

00:19:28.434 --> 00:19:30.100
You give it a call back.

00:19:30.100 --> 00:19:33.400
Previously, you would've called
here openSettingsView,

00:19:33.400 --> 00:19:35.467
now you just wrap it
in asynchronous callback.

00:19:35.467 --> 00:19:39.367
This code is now
being split by the compiler.

00:19:39.367 --> 00:19:42.334
Now what does it mean
to be split?

00:19:42.334 --> 00:19:44.100
Well, it's actually
pretty cool.

00:19:44.100 --> 00:19:46.901
It takes everything that is
inside of that callback,

00:19:46.901 --> 00:19:49.100
and it treats that
as sort of a code island.

00:19:49.100 --> 00:19:54.200
And it analyzes
the actual dependencies,

00:19:54.200 --> 00:19:55.200
looking at what
you would need

00:19:55.200 --> 00:19:57.267
to run that little
island of code,

00:19:57.267 --> 00:19:59.868
given what you've
already previously loaded

00:19:59.868 --> 00:20:02.000
by all the other
split points you've hit.

00:20:02.000 --> 00:20:04.167
So it actually generates
a lot of little code fragments

00:20:04.167 --> 00:20:06.501
that are specifically
tailored

00:20:06.501 --> 00:20:11.701
to where you're at
in the application.

00:20:11.701 --> 00:20:13.501
So this is a really
cool technique.

00:20:13.501 --> 00:20:14.834
And, you know,

00:20:14.834 --> 00:20:18.200
as you'll see throughout
this conference,

00:20:18.200 --> 00:20:20.267
we have a lot
of internal users

00:20:20.267 --> 00:20:23.968
who are using this
to great effect.

00:20:23.968 --> 00:20:25.801
And in fact, if you want
some good patterns

00:20:25.801 --> 00:20:27.033
on how to use this,

00:20:27.033 --> 00:20:30.567
you should see Ray Ryan's
talk.

00:20:30.567 --> 00:20:31.567
Okay.

00:20:31.567 --> 00:20:33.934
The fourth thing
is that GWT

00:20:33.934 --> 00:20:37.734
interoperates
with JavaScript at no cost.

00:20:37.734 --> 00:20:41.000
So the classic example
of this is our DOM library.

00:20:41.000 --> 00:20:43.734
So we did have a lot of people
who wanted to write in Java,

00:20:43.734 --> 00:20:46.100
but what they really wanted to
do was they understood the DOM,

00:20:46.100 --> 00:20:50.534
they knew how to write against
all the existing DOM APIs,

00:20:50.534 --> 00:20:53.200
they really just wanted a way
to use both of them together.

00:20:53.200 --> 00:20:57.701
So in GWT 1.5,
we created this.

00:20:57.701 --> 00:20:59.734
We created a DOM library
that allows you to basically

00:20:59.734 --> 00:21:01.467
write what you would
write in JavaScript,

00:21:01.467 --> 00:21:04.567
except it's all type-safe,
and of course,

00:21:04.567 --> 00:21:06.267
given the fact
that you have types,

00:21:06.267 --> 00:21:07.934
and the GWT compiler
can see all the types,

00:21:07.934 --> 00:21:09.367
you actually get
all the optimizations

00:21:09.367 --> 00:21:11.334
that are generally available

00:21:11.334 --> 00:21:13.133
to all the rest of
your Java code.

00:21:13.133 --> 00:21:15.868
Now usually when
you do language interop,

00:21:15.868 --> 00:21:19.834
you end up with these wrapper
objects for various reasons.

00:21:19.834 --> 00:21:22.701
And so the real magic here
is that in GWT,

00:21:22.701 --> 00:21:26.067
you actually can operate
directly on a JavaScript object.

00:21:26.067 --> 00:21:29.200
And in fact, this is what
the DOM libraries use.

00:21:29.200 --> 00:21:32.267
but it's not something
that we withhold from ourselves.

00:21:32.267 --> 00:21:33.767
You can actually use it
in your own code.

00:21:33.767 --> 00:21:36.200
One of the classic
examples is JSON.

00:21:36.200 --> 00:21:39.200
So say you need to handle that
JSON object listed at the top,

00:21:39.200 --> 00:21:43.901
in your client code, you get
back a JavaScript object.

00:21:43.901 --> 00:21:46.901
Now, I can cast that JavaScript
object to a person,

00:21:46.901 --> 00:21:48.601
and I can use that.

00:21:48.601 --> 00:21:49.834
What's actually
happening here

00:21:49.834 --> 00:21:51.234
is that I've declared
a Java object,

00:21:51.234 --> 00:21:52.901
and I've basically said,
"Look, compiler,

00:21:52.901 --> 00:21:55.734
I promise that
this Java object

00:21:55.734 --> 00:21:57.067
will represent some object

00:21:57.067 --> 00:21:59.501
at runtime, and I want
you to just overlay it.

00:21:59.501 --> 00:22:01.467
Just completely
overlay the type.

00:22:01.467 --> 00:22:03.734
So it's actually
a strongly-typed Java object

00:22:03.734 --> 00:22:07.534
that overlays a completely
untyped object at runtime.

00:22:07.534 --> 00:22:10.734
So this is really nice
'cause it unlocks opportunities

00:22:10.734 --> 00:22:12.367
like you saw
with the DOM libraries,

00:22:12.367 --> 00:22:14.501
and it also unlocks
the ability

00:22:14.501 --> 00:22:16.033
to handle JSON
very efficiently.

00:22:16.033 --> 00:22:17.901
In fact, you can sort of
decide how efficiently

00:22:17.901 --> 00:22:21.167
you want to handle JSON
by how paranoid you want to be

00:22:21.167 --> 00:22:24.834
in checking whether
properties exist.

00:22:24.834 --> 00:22:29.100
We typically just return
the properties directly.

00:22:29.100 --> 00:22:30.667
And at runtime,
of course,

00:22:30.667 --> 00:22:32.601
you get just property
accesses,

00:22:32.601 --> 00:22:36.501
not calls to wrappers,
and not methods.

00:22:36.501 --> 00:22:39.334
And of course this
is actually, you know,

00:22:39.334 --> 00:22:40.567
available through
the inliner,

00:22:40.567 --> 00:22:43.467
so all this gets
inlined as well.

00:22:43.467 --> 00:22:46.534
Okay, so that's
four things GWT does for you.

00:22:46.534 --> 00:22:47.634
But like I said,
I wanted to give you

00:22:47.634 --> 00:22:49.167
four things you should
do for yourself

00:22:49.167 --> 00:22:50.501
when you're creating
your GWT apps

00:22:50.501 --> 00:22:54.300
to make them
as performant as possible.

00:22:54.300 --> 00:22:55.801
The first thing,

00:22:55.801 --> 00:23:01.734
and it's probably
the biggest issue we diagnose,

00:23:01.734 --> 00:23:04.100
is that it makes sense
that you would use widgets

00:23:04.100 --> 00:23:07.200
as the basic building blocks
of your applications,

00:23:07.200 --> 00:23:08.701
but when you start
to get larger apps,

00:23:08.701 --> 00:23:10.467
it doesn't necessarily fit
that you would want

00:23:10.467 --> 00:23:12.801
everything on the screen
to be a widget.

00:23:12.801 --> 00:23:14.467
It turns out
that because GWT

00:23:14.467 --> 00:23:17.400
does a great job
of bookkeeping

00:23:17.400 --> 00:23:20.200
to try to make sure you don't
introduce memory leaks.

00:23:20.200 --> 00:23:21.801
That can actually add--

00:23:21.801 --> 00:23:23.300
When you get a huge
widget hierarchy,

00:23:23.300 --> 00:23:25.000
that can actually
add a little bit

00:23:25.000 --> 00:23:29.167
to the time it requires to
build up and tear down your UI.

00:23:29.167 --> 00:23:34.334
In fact, the two common misuses
of widgets that I'd highlight

00:23:34.334 --> 00:23:36.267
are a lot of people

00:23:36.267 --> 00:23:38.167
use a lot of nested widgets
for layout.

00:23:38.167 --> 00:23:41.033
This is, in fact,
something that we may have

00:23:41.033 --> 00:23:42.834
accidentally encouraged
by the introduction

00:23:42.834 --> 00:23:45.400
of vertical
and horizontal panel,

00:23:45.400 --> 00:23:47.434
but when you get
to very large apps,

00:23:47.434 --> 00:23:48.734
that can be a bit
of a problem.

00:23:48.734 --> 00:23:51.501
The second thing is
is that when you have widgets

00:23:51.501 --> 00:23:54.834
that contain children,
you actually don't--

00:23:54.834 --> 00:23:56.901
There are techniques
to avoid

00:23:56.901 --> 00:23:59.734
having each of those children
be a widget themselves.

00:23:59.734 --> 00:24:02.334
Because in most cases
they just need to handle events,

00:24:02.334 --> 00:24:04.167
and there's
a way to do that.

00:24:04.167 --> 00:24:06.901
Now I'll show you two easy
workarounds for both of these.

00:24:06.901 --> 00:24:08.767
But first, let's handle
the general question,

00:24:08.767 --> 00:24:13.267
which is, "How do I decide
if I need a widget?"

00:24:13.267 --> 00:24:15.501
So it's actually
really easy.

00:24:15.501 --> 00:24:18.767
The whole core of widgets
are about event handling.

00:24:18.767 --> 00:24:22.100
So if you have a thing
on the screen

00:24:22.100 --> 00:24:24.000
that doesn't actually
need to receive an event,

00:24:24.000 --> 00:24:25.734
you actually
don't need a widget.

00:24:25.734 --> 00:24:29.267
As I'll show you, there are
some alternatives there.

00:24:29.267 --> 00:24:34.167
Now, even if you do
need to receive events,

00:24:34.167 --> 00:24:36.934
there's actually some cases
where you can allow

00:24:36.934 --> 00:24:38.267
a widget higher up
in the hierarchy

00:24:38.267 --> 00:24:40.067
to receive those events
on your behalf,

00:24:40.067 --> 00:24:43.200
and delegate back to you,
or delegate to a piece of code

00:24:43.200 --> 00:24:45.133
that handles
those events for you.

00:24:45.133 --> 00:24:46.834
And I'll show you
an example of that.

00:24:46.834 --> 00:24:48.767
And then if you're satisfied,

00:24:48.767 --> 00:24:50.067
both of these
are quite mature.

00:24:50.067 --> 00:24:53.434
Sure, this is probably a case
where you need a widget.

00:24:53.434 --> 00:24:54.901
Now the thing I said about

00:24:54.901 --> 00:24:57.934
a widget that has
child widgets,

00:24:57.934 --> 00:25:00.000
that's really important
if you have a widget

00:25:00.000 --> 00:25:01.701
that has an unbounded
set of child widgets.

00:25:01.701 --> 00:25:03.000
And I'm thinking
about a tree here.

00:25:03.000 --> 00:25:05.467
If you have a tree,
you really have to be careful

00:25:05.467 --> 00:25:08.501
about putting widgets
inside of a tree.

00:25:08.501 --> 00:25:10.534
Just because you
don't often know.

00:25:10.534 --> 00:25:11.934
Especially if that tree is
data-driven, you don't often

00:25:11.934 --> 00:25:15.067
know how large
it's gonna grow.

00:25:15.067 --> 00:25:18.901
And building up an unbounded
set of child widgets

00:25:18.901 --> 00:25:20.767
at runtime when you
don't know how long it is.

00:25:20.767 --> 00:25:22.133
That's effectively
saying,

00:25:22.133 --> 00:25:24.501
"I don't know how long
it takes my app to load."

00:25:24.501 --> 00:25:26.734
But I'll show you
a way around that.

00:25:26.734 --> 00:25:28.000
So the first thing.

00:25:28.000 --> 00:25:29.534
I'd mentioned the first
common mistake

00:25:29.534 --> 00:25:33.901
was you use a lot of nested
widgets to do layout.

00:25:33.901 --> 00:25:36.067
It turns out there's
a really simple technique.

00:25:36.067 --> 00:25:37.334
There are a lot of techniques
to get around this,

00:25:37.334 --> 00:25:39.834
but one of the ones
that I try to use here

00:25:39.834 --> 00:25:41.968
is just simply
using an HTML panel.

00:25:41.968 --> 00:25:44.100
Use an HTML panel,

00:25:44.100 --> 00:25:47.200
you create the--

00:25:47.200 --> 00:25:48.601
you basically put
the HTML in there

00:25:48.601 --> 00:25:50.133
you need
to do your layout,

00:25:50.133 --> 00:25:51.767
and then strategically
inside of here,

00:25:51.767 --> 00:25:53.934
you actually put
an I.D. for where

00:25:53.934 --> 00:25:55.968
you want to embed
another widget.

00:25:55.968 --> 00:25:57.367
Now, if you look
at an HTML panel,

00:25:57.367 --> 00:26:00.033
there's an overload
for the add method

00:26:00.033 --> 00:26:02.200
that actually takes
one of these I.D.s.

00:26:02.200 --> 00:26:04.801
So you're able
to just slip your widget

00:26:04.801 --> 00:26:07.234
into this DOM structure
that you've created.

00:26:07.234 --> 00:26:09.501
Now the other big thing
about using this technique

00:26:09.501 --> 00:26:11.868
is instead of
building up the DOM

00:26:11.868 --> 00:26:14.300
using document.createElement,

00:26:14.300 --> 00:26:16.234
it actually uses
inner HTML,

00:26:16.234 --> 00:26:18.133
which, in most cases,

00:26:18.133 --> 00:26:20.334
and in some cases can be
considerably faster,

00:26:20.334 --> 00:26:22.267
it turns out that
when you use inner HTML,

00:26:22.267 --> 00:26:24.868
you actually skip
an entire step.

00:26:24.868 --> 00:26:28.067
When you use
DOM.createElement,

00:26:28.067 --> 00:26:29.400
what in fact you're doing
is you're saying,

00:26:29.400 --> 00:26:30.734
"create me
an element,

00:26:30.734 --> 00:26:33.667
"but also give me an API wrapper
in the JavaScript engine

00:26:33.667 --> 00:26:35.501
'cause I'm gonna need
to do things to it."

00:26:35.501 --> 00:26:37.334
When you pass something
to the parser,

00:26:37.334 --> 00:26:40.567
it goes in the HTML tokenizer,
it creates DOM elements.

00:26:40.567 --> 00:26:42.734
There's no need for it
to expose any of those.

00:26:42.734 --> 00:26:44.200
The JavaScript engine--
as a result,

00:26:44.200 --> 00:26:46.734
you actually reduce the number
of objects you create

00:26:46.734 --> 00:26:48.634
when you do it this way.

00:26:48.634 --> 00:26:51.567
So that's another big advantage
of this technique.

00:26:51.567 --> 00:26:54.400
Now I promised a workaround
for the second misuse.

00:26:54.400 --> 00:26:57.834
And that is you have this
widget, and it has children,

00:26:57.834 --> 00:27:00.033
and you might be
inclined to say, well--

00:27:00.033 --> 00:27:02.534
and imagine this widget--

00:27:02.534 --> 00:27:05.601
I have a very simple panel
in this case,

00:27:05.601 --> 00:27:07.200
and it needs a header
and a body.

00:27:07.200 --> 00:27:09.400
And in each of this
header and the body

00:27:09.400 --> 00:27:11.501
I need to be able
to click on it.

00:27:11.501 --> 00:27:13.234
Now, I might be
inclined to just

00:27:13.234 --> 00:27:15.868
create child widgets
underneath here,

00:27:15.868 --> 00:27:18.834
and then handle events directly
in those child widgets,

00:27:18.834 --> 00:27:20.267
but it's really
unnecessary here,

00:27:20.267 --> 00:27:21.601
and in fact that
would just cause

00:27:21.601 --> 00:27:23.334
a little bit more work
I would have to do

00:27:23.334 --> 00:27:26.133
'cause I would have to build up
these additional widgets.

00:27:26.133 --> 00:27:27.634
So instead,

00:27:27.634 --> 00:27:31.367
I use something
that is inherent in the browser,

00:27:31.367 --> 00:27:32.667
and that's event bubbling.

00:27:32.667 --> 00:27:35.701
So if I click on an element
in the DOM tree,

00:27:35.701 --> 00:27:37.033
the events that receive

00:27:37.033 --> 00:27:41.767
actually traverse back up
to its parent nodes,

00:27:41.767 --> 00:27:44.267
and you can use this,
in fact, in GWT widget,

00:27:44.267 --> 00:27:47.667
so in this case,
I created a click ender,

00:27:47.667 --> 00:27:48.834
but I created it
on my widget,

00:27:48.834 --> 00:27:51.100
which is intended to be
the parent widget here.

00:27:51.100 --> 00:27:53.767
And I can actually--
when I receive the onClick,

00:27:53.767 --> 00:27:55.200
I actually get
something that tells me

00:27:55.200 --> 00:27:56.467
what the target
of that click was,

00:27:56.467 --> 00:27:59.567
and then I can use that
information to then decide

00:27:59.567 --> 00:28:02.601
which of these sub elements
was actually clicked on,

00:28:02.601 --> 00:28:05.767
and then I can
delegate appropriately

00:28:05.767 --> 00:28:08.434
to run the appropriate code
for that click handler.

00:28:08.434 --> 00:28:12.167
All without--avoiding creating
these two extra widgets.

00:28:12.167 --> 00:28:14.234
Now this is such
a common problem

00:28:14.234 --> 00:28:18.334
that we have a lot of people
asking us about it.

00:28:18.334 --> 00:28:21.334
They say it's taking too long
for an app to load.

00:28:21.334 --> 00:28:24.000
It happened enough
that we created a little tool

00:28:24.000 --> 00:28:26.734
called
InspectorWidget.

00:28:26.734 --> 00:28:30.467
And all this does is it allows
you to take a live GWT app--

00:28:30.467 --> 00:28:33.000
it's a bookmarklet--

00:28:33.000 --> 00:28:34.734
take a live app,
you click on the bookmarklet,

00:28:34.734 --> 00:28:38.000
and it'll allow you to traverse
the widget hierarchy

00:28:38.000 --> 00:28:39.968
in hopes of finding
some of these cases

00:28:39.968 --> 00:28:42.133
where you can
eliminate widgets.

00:28:42.133 --> 00:28:44.267
So we use this
a lot of times internally,

00:28:44.267 --> 00:28:47.200
and I decided to just throw it
up on a Google co-project.

00:28:47.200 --> 00:28:49.334
The code is not there yet, but
I'll put it up later this week.

00:28:49.334 --> 00:28:50.667
However,
the bookmarklet is there

00:28:50.667 --> 00:28:52.834
if you guys
want to try it.

00:28:52.834 --> 00:28:55.834
Okay. Second thing
you should do for yourself.

00:28:55.834 --> 00:28:57.934
Now, when you're
writing client code,

00:28:57.934 --> 00:28:59.634
particularly client code
that runs on the web,

00:28:59.634 --> 00:29:01.968
there's always this
sort of trade off,

00:29:01.968 --> 00:29:03.467
this fighting
back and forth between--

00:29:03.467 --> 00:29:05.701
What I really want to do
is I'm writing a big app,

00:29:05.701 --> 00:29:07.033
so I want to put all these
checks in my code.

00:29:07.033 --> 00:29:09.167
I want to make sure,
you know, I have this method,

00:29:09.167 --> 00:29:10.501
and I've assumed
all throughout it

00:29:10.501 --> 00:29:13.100
that the first parameter
is not null,

00:29:13.100 --> 00:29:14.734
and I really just
want to put a check,

00:29:14.734 --> 00:29:19.000
but the problem is
if I put the check in there,

00:29:19.000 --> 00:29:21.501
then it's code
I have to run.

00:29:21.501 --> 00:29:23.501
But we're actually talking
about a set of tools again,

00:29:23.501 --> 00:29:25.534
so with GWT
you actually have--

00:29:25.534 --> 00:29:28.367
You can get the best
of both worlds for this.

00:29:28.367 --> 00:29:29.868
And I actually
encourage people

00:29:29.868 --> 00:29:32.901
to use this advantage
just to its fullest.

00:29:32.901 --> 00:29:36.234
Recognize the fact
that you have

00:29:36.234 --> 00:29:37.601
a time when
you're debugging the app,

00:29:37.601 --> 00:29:38.767
recognize that
you have a time

00:29:38.767 --> 00:29:40.367
when you're running
the app for users,

00:29:40.367 --> 00:29:42.601
make a strong separation
between them.

00:29:42.601 --> 00:29:47.267
Now this is actually
sort of an example of--

00:29:47.267 --> 00:29:48.434
This is a related example

00:29:48.434 --> 00:29:50.000
that basically points to
a pattern

00:29:50.000 --> 00:29:52.634
that we've all sort of
used from the Java world.

00:29:52.634 --> 00:29:56.200
But it's not really
applicable for programming

00:29:56.200 --> 00:29:59.234
for a client
that runs on the Web.

00:29:59.234 --> 00:30:01.067
How likely is it that

00:30:01.067 --> 00:30:02.501
you have a user
who's gonna do something

00:30:02.501 --> 00:30:04.467
about your index
out of bounds exception?

00:30:04.467 --> 00:30:05.868
Probably not.

00:30:05.868 --> 00:30:08.267
What you really want to know
is that something happened.

00:30:08.267 --> 00:30:11.601
You don't actually
want to give them

00:30:11.601 --> 00:30:13.400
the string that's
involved here.

00:30:13.400 --> 00:30:16.901
So this is
usually an error

00:30:16.901 --> 00:30:18.834
that you actually
want to catch a debug time.

00:30:18.834 --> 00:30:20.467
You actually
don't want to know

00:30:20.467 --> 00:30:22.734
that it was exactly
an index out of bounds exception

00:30:22.734 --> 00:30:25.467
when the user's running it.

00:30:25.467 --> 00:30:28.400
So what we advise instead
of throwing exceptions,

00:30:28.400 --> 00:30:29.734
in many cases,

00:30:29.734 --> 00:30:32.868
is that you actually
just use assertions.

00:30:32.868 --> 00:30:35.400
So assertions are turned on
by default in hosted mode.

00:30:35.400 --> 00:30:36.667
You can turn them on
in web mode

00:30:36.667 --> 00:30:40.300
by passing the "-ea" flag.

00:30:40.300 --> 00:30:41.467
And one of the things
you'll notice

00:30:41.467 --> 00:30:42.767
is that once you
put an assert in here,

00:30:42.767 --> 00:30:46.400
this of course disappears
in a release build.

00:30:46.400 --> 00:30:48.901
And again, this is code
you don't have to run.

00:30:48.901 --> 00:30:50.901
Plus this method
which previously probably

00:30:50.901 --> 00:30:53.901
could not have been inlined
is now available to the inliner.

00:30:53.901 --> 00:30:57.734
So this doesn't apply
everywhere, of course.

00:30:57.734 --> 00:30:59.334
You have to
use discretion,

00:30:59.334 --> 00:31:01.467
but you should be
aware of the separation

00:31:01.467 --> 00:31:03.767
between doing debugs,
doing release.

00:31:03.767 --> 00:31:06.968
In fact, any time
I create a new application,

00:31:06.968 --> 00:31:09.801
the first thing I do is I go in
and I create two modules.

00:31:09.801 --> 00:31:13.434
I create the debug module,
and I create the release module.

00:31:13.434 --> 00:31:16.200
The debug module I use deferred
binding to its fullest

00:31:16.200 --> 00:31:17.968
to try to create
a bunch of tools

00:31:17.968 --> 00:31:21.767
that will help me to keep tabs
on how fast the app is.

00:31:21.767 --> 00:31:24.567
I particularly use it
for performance-related things.

00:31:24.567 --> 00:31:27.367
And, you know,
straightforward way to do this.

00:31:27.367 --> 00:31:30.300
I defined a deferred
binding property

00:31:30.300 --> 00:31:32.100
in this case
called app.config.

00:31:32.100 --> 00:31:33.734
It has both
release and debug.

00:31:33.734 --> 00:31:36.200
And you can see I continue
to find some properties here

00:31:36.200 --> 00:31:37.467
to have
different things

00:31:37.467 --> 00:31:39.901
when I'm in debug mode
versus release mode,

00:31:39.901 --> 00:31:43.067
and I'm careful that the
implementations for release mode

00:31:43.067 --> 00:31:44.567
are just empty
implementations.

00:31:44.567 --> 00:31:46.834
So, you know,
whenever the compiler

00:31:46.834 --> 00:31:48.601
tries to build
the release build,

00:31:48.601 --> 00:31:50.901
it just sees empty
implementations of methods,

00:31:50.901 --> 00:31:52.801
which it just gets rid of.

00:31:52.801 --> 00:31:54.567
And then of course
I create the debug module,

00:31:54.567 --> 00:31:56.300
which just turns
all this stuff on.

00:31:56.300 --> 00:31:57.968
Now, just to give you
a little example

00:31:57.968 --> 00:32:01.801
of some things
that we've used it for...

00:32:01.801 --> 00:32:04.934
So debug consoles are,
of course, one of these.

00:32:04.934 --> 00:32:08.834
Writing to Firebug console
is another thing.

00:32:08.834 --> 00:32:12.234
Even little notifications of
when things are taking too long.

00:32:12.234 --> 00:32:14.701
Now these are really important
because if you don't actually

00:32:14.701 --> 00:32:17.300
address performance problems
on a day-to-day basis,

00:32:17.300 --> 00:32:19.167
it often gets very hard
to track them down

00:32:19.167 --> 00:32:20.567
if you wait to the end.

00:32:20.567 --> 00:32:22.200
It's certainly easier
to find a performance problem

00:32:22.200 --> 00:32:24.968
when you know it's
in one of two commits

00:32:24.968 --> 00:32:26.300
than it is
when you know that

00:32:26.300 --> 00:32:28.968
it's in one of the last
three months' commits.

00:32:28.968 --> 00:32:31.667
So we use this
to great effect,

00:32:31.667 --> 00:32:33.968
and I would advise this
as well that you go ahead

00:32:33.968 --> 00:32:35.667
and very early get set up

00:32:35.667 --> 00:32:37.300
with a debug mode
and a release mode,

00:32:37.300 --> 00:32:39.534
and use that
to its fullest.

00:32:39.534 --> 00:32:41.901
Okay, so the third thing
you should do

00:32:41.901 --> 00:32:45.767
is what I call
avoid forcing layout.

00:32:45.767 --> 00:32:49.033
So this is a little graph
you're looking at.

00:32:49.033 --> 00:32:50.334
I wanted to do
a little experiment

00:32:50.334 --> 00:32:51.834
and I felt it
would be interesting.

00:32:51.834 --> 00:32:55.367
You guys are probably aware
of some DOM properties--

00:32:55.367 --> 00:32:58.267
offsetLeft, offsetTop,
offsetHeight, offsetWidth--

00:32:58.267 --> 00:32:59.901
these are all things
in a DOM API.

00:32:59.901 --> 00:33:03.000
What they're asking for
are certain measurements

00:33:03.000 --> 00:33:05.133
about a particular
DOM element.

00:33:05.133 --> 00:33:06.968
So I wanted to take
a highly optimized application--

00:33:06.968 --> 00:33:08.400
in this case,
Google Calendar.

00:33:08.400 --> 00:33:10.234
I knew that these guys
had been very careful

00:33:10.234 --> 00:33:11.968
in the way they
wrote this application.

00:33:11.968 --> 00:33:13.167
And I wanted to look at

00:33:13.167 --> 00:33:15.267
every time offsetHeight
was called.

00:33:15.267 --> 00:33:19.200
And then I wanted to see
how long it took each time.

00:33:19.200 --> 00:33:21.667
Well, it called it 18 times
in the time that I ran the app,

00:33:21.667 --> 00:33:25.200
you know, I basically opened
a few very large calendars,

00:33:25.200 --> 00:33:28.334
closed them...

00:33:28.334 --> 00:33:32.601
And among those 18, the range
was from 1/2 a millisecond

00:33:32.601 --> 00:33:33.834
to 85 milliseconds.

00:33:33.834 --> 00:33:35.868
Now you remember
I started with some times

00:33:35.868 --> 00:33:37.334
that I thought
were important,

00:33:37.334 --> 00:33:39.467
and if you're considering
this 85 milliseconds.

00:33:39.467 --> 00:33:42.234
I mean, certainly when
we did that little demo,

00:33:42.234 --> 00:33:43.868
we were sluggish
by 50 milliseconds,

00:33:43.868 --> 00:33:46.267
so I've just blown
my entire time required

00:33:46.267 --> 00:33:51.334
to remain interactive
on one property access.

00:33:51.334 --> 00:33:56.701
So it's really hard
to write against this

00:33:56.701 --> 00:33:59.234
'cause you oftentimes
don't know

00:33:59.234 --> 00:34:02.434
how long a particular call
is going to take.

00:34:02.434 --> 00:34:06.801
So I'll give you some simple
techniques around this,

00:34:06.801 --> 00:34:08.300
but first,
let's answer the question.

00:34:08.300 --> 00:34:09.434
Why does it do this?

00:34:09.434 --> 00:34:10.934
Why does it take
an unbearable amount of time

00:34:10.934 --> 00:34:13.601
to call a piece
of the DOM API?

00:34:13.601 --> 00:34:15.467
So this is a screenshot
from an internal tool

00:34:15.467 --> 00:34:18.100
that my team works on,

00:34:18.100 --> 00:34:19.534
and this should
answer the question.

00:34:19.534 --> 00:34:20.734
So when you call
offsetHeight,

00:34:20.734 --> 00:34:22.934
even though it looks
like a property access,

00:34:22.934 --> 00:34:24.667
it's not actually
a property access.

00:34:24.667 --> 00:34:26.334
You're actually running
the layout engine

00:34:26.334 --> 00:34:27.501
whenever you do this.

00:34:27.501 --> 00:34:28.801
And in fact, you know,
in this case,

00:34:28.801 --> 00:34:30.734
it's ten milliseconds
to call offsetHeight.

00:34:30.734 --> 00:34:32.067
We spend about
three milliseconds

00:34:32.067 --> 00:34:33.868
doing style
recalculations for CSS,

00:34:33.868 --> 00:34:35.267
And then we spent
the rest of the time

00:34:35.267 --> 00:34:36.901
actually doing layout,

00:34:36.901 --> 00:34:38.467
traversing the render tree
to get the--

00:34:38.467 --> 00:34:41.801
to figure out what
the size of everything is.

00:34:41.801 --> 00:34:44.067
Because the browser may not
know at that time

00:34:44.067 --> 00:34:47.234
what offsetHeight is, so it
has to go in and compute it.

00:34:47.234 --> 00:34:49.033
So some techniques
to avoid this.

00:34:49.033 --> 00:34:51.601
Some techniques to make sure
that, you know,

00:34:51.601 --> 00:34:53.367
really these
techniques are about--

00:34:53.367 --> 00:34:57.667
Well, the top technique
is about avoiding it altogether.

00:34:57.667 --> 00:35:01.467
To the extent that you can,
try to actually use CSS alone.

00:35:01.467 --> 00:35:04.167
We refer to this
as imperative layout.

00:35:04.167 --> 00:35:07.067
So you use this--

00:35:07.067 --> 00:35:09.033
try to use the things
that are available in CSS

00:35:09.033 --> 00:35:11.234
so you don't ever
have to run the CSS code

00:35:11.234 --> 00:35:12.801
to try to ask for
one of these measurements

00:35:12.801 --> 00:35:15.100
to accidentally
slow down your app.

00:35:15.100 --> 00:35:18.133
So anywhere you can,
try to stay in CSS.

00:35:18.133 --> 00:35:22.667
If you do have to access
some of these properties,

00:35:22.667 --> 00:35:24.534
the order becomes
very important.

00:35:24.534 --> 00:35:25.968
It turns out that
many of the browsers

00:35:25.968 --> 00:35:27.667
are actually quite lazy.

00:35:27.667 --> 00:35:29.667
You do something
that invalidates

00:35:29.667 --> 00:35:32.534
some style
in part of the DOM,

00:35:32.534 --> 00:35:33.868
it won't actually
update the style

00:35:33.868 --> 00:35:35.167
until you ask
for the property.

00:35:35.167 --> 00:35:37.968
As a result, many cases
it's actually better

00:35:37.968 --> 00:35:41.100
to avoid interleaving things
that will invalidate the style.

00:35:41.100 --> 00:35:42.901
So here's a really
simple example.

00:35:42.901 --> 00:35:44.601
So say I have two widgets.

00:35:44.601 --> 00:35:46.968
If I do this order
where I take widgetA,

00:35:46.968 --> 00:35:48.300
I set the StyleName,

00:35:48.300 --> 00:35:50.267
which sets the class name
under the hood,

00:35:50.267 --> 00:35:52.501
which invalidates
the style,

00:35:52.501 --> 00:35:55.334
and then I immediately
call getAbsoluteLeft.

00:35:55.334 --> 00:35:57.334
Well, that's gonna
cause my layout to update.

00:35:57.334 --> 00:36:00.033
Well, then if I turn around
and set the StyleName again,

00:36:00.033 --> 00:36:03.601
setting the class name,
invalidating the style,

00:36:03.601 --> 00:36:05.434
and then I call
AbsoluteLeft again,

00:36:05.434 --> 00:36:08.868
well, I've just caused
two of those long--

00:36:08.868 --> 00:36:10.467
in this case,
probably offset left--

00:36:10.467 --> 00:36:13.133
I've caused two of those
long calls to happen,

00:36:13.133 --> 00:36:14.367
where if I had
just arranged it

00:36:14.367 --> 00:36:17.834
where I invalidated
the style twice up front,

00:36:17.834 --> 00:36:22.501
and then asked
for getAbsoluteLeft

00:36:22.501 --> 00:36:25.267
later together,

00:36:25.267 --> 00:36:27.667
then I would've
done much better,

00:36:27.667 --> 00:36:29.234
and then I probably
would've only gotten

00:36:29.234 --> 00:36:33.067
one long property access
instead of two.

00:36:33.067 --> 00:36:36.234
So unfortunately,

00:36:36.234 --> 00:36:38.267
these things are often
extremely hard to spot.

00:36:38.267 --> 00:36:40.234
This is actually a hole
in the developer's story.

00:36:40.234 --> 00:36:41.667
We're actually
working on some tools.

00:36:41.667 --> 00:36:44.667
I hope we can actually
get those out at some point.

00:36:44.667 --> 00:36:48.434
Okay, so the final thing.

00:36:48.434 --> 00:36:52.200
The final thing I'm gonna
talk about is RPC-related.

00:36:52.200 --> 00:36:55.000
Now I like to make
the joke a lot of times

00:36:55.000 --> 00:36:57.501
that some people mistakenly
thought the "R" in RPC

00:36:57.501 --> 00:37:00.501
stood for "replication."

00:37:00.501 --> 00:37:02.000
GWT RPC is kind of cool

00:37:02.000 --> 00:37:04.200
in that it can handle
arbitrary object graphs.

00:37:04.200 --> 00:37:07.000
But the truth is you actually
don't really need that a lot.

00:37:07.000 --> 00:37:09.767
Most of the time
you really want

00:37:09.767 --> 00:37:12.133
to just send over exactly
what's on the screen,

00:37:12.133 --> 00:37:13.400
and people don't really look

00:37:13.400 --> 00:37:15.667
at large, hierarchical graphs
in a single view.

00:37:15.667 --> 00:37:17.434
I mean, we usually
lead something

00:37:17.434 --> 00:37:20.501
that could be made lazy
so that you can view these.

00:37:20.501 --> 00:37:22.801
And in fact we've
sometimes seen apps

00:37:22.801 --> 00:37:26.300
where the application start time
was completely dominated

00:37:26.300 --> 00:37:27.701
by deserializing data.

00:37:27.701 --> 00:37:30.100
They were moving over
so much data

00:37:30.100 --> 00:37:31.901
that it was actually
just the time it takes

00:37:31.901 --> 00:37:36.567
to get it off the RPC payload
and turned into Java objects

00:37:36.567 --> 00:37:39.200
was actually dominating
the app startup.

00:37:39.200 --> 00:37:40.901
So try to avoid that.

00:37:40.901 --> 00:37:43.868
Instead, return only
what is visible to the user.

00:37:43.868 --> 00:37:47.300
Actually, tailor your RPC
services to only give the things

00:37:47.300 --> 00:37:48.968
that are gonna be
on the screen.

00:37:48.968 --> 00:37:50.133
I have a really simple
example

00:37:50.133 --> 00:37:53.701
to demonstrate a choice here.

00:37:53.701 --> 00:37:55.934
So imagine
that we have this--

00:37:55.934 --> 00:37:57.634
Imagine we have an application
that has articles.

00:37:57.634 --> 00:38:01.000
Articles, as you might imagine,
consist of a title,

00:38:01.000 --> 00:38:02.567
a date they were
published on,

00:38:02.567 --> 00:38:04.934
and then some
relatively large content.

00:38:04.934 --> 00:38:09.667
Right, this is maybe the entire
contents of a blog article.

00:38:09.667 --> 00:38:13.968
So I could design
my RPC objects like this,

00:38:13.968 --> 00:38:15.567
I mean, this is the most
straightforward way.

00:38:15.567 --> 00:38:17.801
I would just create all those
things inside of the object,

00:38:17.801 --> 00:38:22.467
I would create
one remote service interface,

00:38:22.467 --> 00:38:24.334
and I would just return
a list of articles,

00:38:24.334 --> 00:38:25.834
and I would display them.

00:38:25.834 --> 00:38:27.000
But more than likely,

00:38:27.000 --> 00:38:28.367
I'm gonna have this list
of articles

00:38:28.367 --> 00:38:30.567
that's gonna consist
of just the date and the title,

00:38:30.567 --> 00:38:31.634
and not the content.

00:38:31.634 --> 00:38:33.133
Well, if I design
it this way,

00:38:33.133 --> 00:38:36.701
obviously I'm sending over
a lot of unnecessary baggage

00:38:36.701 --> 00:38:38.801
in that first RPC request.

00:38:38.801 --> 00:38:40.067
I'm actually sending over
the content.

00:38:40.067 --> 00:38:43.000
Now it is true that I may
need the content later,

00:38:43.000 --> 00:38:45.100
however it is also true
that I don't need it right now,

00:38:45.100 --> 00:38:46.634
and it is also true
that users

00:38:46.634 --> 00:38:49.200
are unlikely to click
on all these articles,

00:38:49.200 --> 00:38:50.367
and therefore
they don't need

00:38:50.367 --> 00:38:52.567
the content
for every one of them.

00:38:52.567 --> 00:38:57.067
So instead, you know,
a better approach here

00:38:57.067 --> 00:38:59.601
would be to--and there are
a number of ways to do this.

00:38:59.601 --> 00:39:03.300
In fact, I'll plug
Ray Ryan's talk again.

00:39:03.300 --> 00:39:04.601
He has some great ways
to do this.

00:39:04.601 --> 00:39:06.601
In fact, once you start
doing this there are

00:39:06.601 --> 00:39:09.434
other concerns that come up
that I'll mention.

00:39:09.434 --> 00:39:13.868
So instead of actually
moving the content,

00:39:13.868 --> 00:39:16.601
let's just relieve
the content out of payload.

00:39:16.601 --> 00:39:17.701
And we'll add another method

00:39:17.701 --> 00:39:20.334
to get the content
asynchronously.

00:39:20.334 --> 00:39:21.667
So now we can get
exactly what we want

00:39:21.667 --> 00:39:23.167
for the list of articles,

00:39:23.167 --> 00:39:24.834
and the content is available

00:39:24.834 --> 00:39:26.567
at another asynchronous
callback

00:39:26.567 --> 00:39:28.133
at any time we need it.

00:39:28.133 --> 00:39:29.434
Now, like I said,
that opens up

00:39:29.434 --> 00:39:31.434
all sorts of questions
about caching.

00:39:31.434 --> 00:39:32.968
There are great ways
to do that.

00:39:32.968 --> 00:39:36.033
You can create objects to hide
all the stuff inside of,

00:39:36.033 --> 00:39:38.267
encapsulate it nicely,

00:39:38.267 --> 00:39:41.501
and these sort
of techniques work quite well

00:39:41.501 --> 00:39:44.567
architecting
your application.

00:39:44.567 --> 00:39:47.133
All right, so I may have been
going a little fast,

00:39:47.133 --> 00:39:48.968
but that's it,
that's it.

00:39:48.968 --> 00:39:50.300
I'm gonna take
questions after this,

00:39:50.300 --> 00:39:52.167
but first remind you the four
things GWT does for you.

00:39:52.167 --> 00:39:54.367
Produces fast
JavaScript code.

00:39:54.367 --> 00:39:57.033
Loads your non-code
resources quickly.

00:39:57.033 --> 00:39:59.767
Splits your code elegantly
with the new code splitter.

00:39:59.767 --> 00:40:01.701
Interoperates
with JavaScript at no cost.

00:40:01.701 --> 00:40:04.033
By the way, if you want to see--
plug another talk--

00:40:04.033 --> 00:40:06.567
Ray Cromwell has a really nice
talk about a library--

00:40:06.567 --> 00:40:08.300
he's been working
on GWT query--

00:40:08.300 --> 00:40:11.701
that makes really
bizarre and cool use

00:40:11.701 --> 00:40:15.834
out of the overlay types
that I mentioned earlier.

00:40:15.834 --> 00:40:17.868
And then four things
you should do for yourself.

00:40:17.868 --> 00:40:19.501
Avoid unnecessary widgets.

00:40:19.501 --> 00:40:23.100
Try to keep your widget
hierarchies as slim as possible.

00:40:23.100 --> 00:40:24.868
Use debug builds
effectively.

00:40:24.868 --> 00:40:27.734
Go ahead and set up those debug
versus release early,

00:40:27.734 --> 00:40:29.634
and use them
to great effect.

00:40:29.634 --> 00:40:30.968
And share the tools

00:40:30.968 --> 00:40:34.767
if you come up with really good
tools for debug mode.

00:40:34.767 --> 00:40:37.133
And finally,
avoid forcing layout.

00:40:37.133 --> 00:40:39.300
I showed you some tricks
for doing that.

00:40:39.300 --> 00:40:42.300
And fetch only what
you want to show in RPC.

00:40:42.300 --> 00:40:45.234
If you missed the link
to InspectorWidget, it's there.

00:40:45.234 --> 00:40:47.701
And so feel free
to use that as you wish.

00:40:47.701 --> 00:40:49.434
And I'm happy
to take questions.

00:40:49.434 --> 00:40:52.701
I think we still have
a lot of time left, actually.

00:40:52.701 --> 00:40:55.634
[applause]

00:40:58.100 --> 00:41:00.167
If you have questions,
please go to the mic,

00:41:00.167 --> 00:41:02.601
because the last time I tried
to repeat someone's question

00:41:02.601 --> 00:41:04.200
it was terrible.

00:41:04.200 --> 00:41:06.467
I got it all wrong.

00:41:06.467 --> 00:41:08.167
audience member:
Hi, there. Thanks.

00:41:08.167 --> 00:41:11.968
With the ability
to bundle code-like images,

00:41:11.968 --> 00:41:14.801
or I recently learned even
CSS code and various things,

00:41:14.801 --> 00:41:17.934
can you bundle JavaScript code
in there as well?

00:41:17.934 --> 00:41:19.868
Norton:
You could, actually.

00:41:19.868 --> 00:41:21.334
The trick is--

00:41:21.334 --> 00:41:24.033
Yeah, yeah, actually you could
bundle it as a text resource,

00:41:24.033 --> 00:41:26.367
you would just have to eval it,
would be the trick.

00:41:26.367 --> 00:41:30.400
Yeah, but that
would work.

00:41:30.400 --> 00:41:33.868
audience member: You talked
about avoiding nesting widgets

00:41:33.868 --> 00:41:38.334
by using HTML panel
and using I.D.s,

00:41:38.334 --> 00:41:39.534
but those I.D.s
are all

00:41:39.534 --> 00:41:40.934
in the same global shared
namespace, right?

00:41:40.934 --> 00:41:42.434
Norton: Yes.

00:41:42.434 --> 00:41:44.901
audience member: So if you've
got a pretty complex HTML layout

00:41:44.901 --> 00:41:46.601
with a lot of I.D.s,

00:41:46.601 --> 00:41:48.434
and then you got a dynamically
generated tool

00:41:48.434 --> 00:41:50.400
with some function that makes
them unique and stick them in,

00:41:50.400 --> 00:41:51.934
it can get kind of
messy, maybe,

00:41:51.934 --> 00:41:53.367
with a lot of pluses
between your strings,

00:41:53.367 --> 00:41:54.701
and it just looks ugly.

00:41:54.701 --> 00:41:57.367
Is there any tricks or patterns
to clean that up?

00:41:57.367 --> 00:42:02.033
Norton: I mean, so there are
a couple answers to that.

00:42:02.033 --> 00:42:03.767
When you do
that technique,

00:42:03.767 --> 00:42:05.267
yes, you have to be careful
about your names.

00:42:05.267 --> 00:42:09.567
They have to be
globally unique.

00:42:09.567 --> 00:42:12.901
So you do have to pay
attention to that.

00:42:12.901 --> 00:42:15.133
I mean, you can actually
remove I.D.s if you want.

00:42:15.133 --> 00:42:16.534
That actually works.

00:42:16.534 --> 00:42:19.734
That's not quite
as elegant as you'd like.

00:42:19.734 --> 00:42:21.100
audience member:
You mean remove I.D.s?

00:42:21.100 --> 00:42:22.634
Norton:
Once you actually create

00:42:22.634 --> 00:42:24.434
an HTML panel
with the I.D.s set,

00:42:24.434 --> 00:42:26.133
and then you can actually
remove those I.D.s

00:42:26.133 --> 00:42:27.267
once you have the widgets
attached to 'em.

00:42:27.267 --> 00:42:28.400
That actually works,

00:42:28.400 --> 00:42:29.567
but you have to be
really careful with it,

00:42:29.567 --> 00:42:31.400
'cause it can--
subtle bugs can creep in

00:42:31.400 --> 00:42:34.167
if you miss getting
rid of an I.D.

00:42:34.167 --> 00:42:36.501
One of the things
is that once--

00:42:36.501 --> 00:42:37.667
If you were here
for Bruce's talk,

00:42:37.667 --> 00:42:40.334
I think a discussion
about UI Binder came up.

00:42:40.334 --> 00:42:43.033
So what people once
knew as declarative UI,

00:42:43.033 --> 00:42:46.601
which was sort of
an XML templating language,

00:42:46.601 --> 00:42:49.534
which basically does
the HTML panel trick for you

00:42:49.534 --> 00:42:52.400
just by declaring
a template.

00:42:52.400 --> 00:42:53.801
Once that's available,

00:42:53.801 --> 00:42:55.701
it takes care of
a lot of those concerns.

00:42:55.701 --> 00:42:56.934
Sometimes you can
actually--

00:42:56.934 --> 00:42:58.467
If you just have
a ton of I.D.s,

00:42:58.467 --> 00:43:00.968
sometimes you can actually
switch it on its head,

00:43:00.968 --> 00:43:04.367
and you can--

00:43:04.367 --> 00:43:06.234
instead of doing
inner HTML,

00:43:06.234 --> 00:43:08.234
you can sort of
create the elements

00:43:08.234 --> 00:43:10.601
using
document.createElement.,

00:43:10.601 --> 00:43:15.534
and create a widget
that holds all these.

00:43:15.534 --> 00:43:21.200
But usually you just try to be
careful with the names.

00:43:21.200 --> 00:43:22.667
It's sort of a balancing act.
Do you have something?

00:43:22.667 --> 00:43:24.767
audience member:
[indistinct]

00:43:24.767 --> 00:43:26.234
Norton: Oh, yes.
Oh, yes, that's right.

00:43:26.234 --> 00:43:28.234
There is actually a method
for generating I.D.s

00:43:28.234 --> 00:43:29.601
in an HTML panel too,

00:43:29.601 --> 00:43:31.901
and to the extent
that you can use that.

00:43:31.901 --> 00:43:34.234
That's really
helpful as well.

00:43:34.234 --> 00:43:35.734
audience member: Thanks.

00:43:35.734 --> 00:43:36.868
another audience member:
Just a question about

00:43:36.868 --> 00:43:39.234
the fetch
what you can show with RPC.

00:43:39.234 --> 00:43:40.667
Norton:
What's that?

00:43:40.667 --> 00:43:43.033
audience member: Fetch only
what you can show with RPC.

00:43:43.033 --> 00:43:46.267
So let's say you have one page,
and there's, like,

00:43:46.267 --> 00:43:49.701
two pages that they're
potentially going to access.

00:43:49.701 --> 00:43:52.934
So now if we only
fetch the first page,

00:43:52.934 --> 00:43:54.534
then all of a sudden
we're probably stuck

00:43:54.534 --> 00:43:56.901
with the one second
response time

00:43:56.901 --> 00:44:00.067
for them going
to the next page.

00:44:00.067 --> 00:44:02.834
So I just wonder if there's
any balance in that,

00:44:02.834 --> 00:44:06.434
especially Web 2.0
applications

00:44:06.434 --> 00:44:09.968
that want to appear more like
desktop applications.

00:44:09.968 --> 00:44:12.634
Norton: Yeah,
so if you switch from--

00:44:12.634 --> 00:44:14.868
If you actually do
a full-page refresh,

00:44:14.868 --> 00:44:16.367
then yeah, you have to
take it on.

00:44:16.367 --> 00:44:18.434
It turns out
that since you're actually

00:44:18.434 --> 00:44:20.367
just sending
it out with RPC,

00:44:20.367 --> 00:44:23.067
a lot of times you can actually
send a good bit of the data

00:44:23.067 --> 00:44:25.100
if you mean by switching pages
you're actually

00:44:25.100 --> 00:44:27.701
just getting the next payload
and updating it.

00:44:27.701 --> 00:44:31.667
Now, another thing
you could do is...

00:44:31.667 --> 00:44:33.033
particularly if you're
on an application

00:44:33.033 --> 00:44:36.067
where your use patterns
are someone loads it up,

00:44:36.067 --> 00:44:37.934
they spend some time
reading

00:44:37.934 --> 00:44:40.000
or, you know,
using the page,

00:44:40.000 --> 00:44:44.100
and then they later go to--
they later get more data,

00:44:44.100 --> 00:44:45.434
then you can actually load

00:44:45.434 --> 00:44:46.634
during idle time
if you're careful.

00:44:46.634 --> 00:44:48.467
Now, the one trick
there is that--

00:44:48.467 --> 00:44:50.901
or the one risk is that
you begin loading something

00:44:50.901 --> 00:44:52.133
just when they
change something

00:44:52.133 --> 00:44:53.567
in a completely
different direction,

00:44:53.567 --> 00:44:57.467
but if you have fairly--
if you have good user patterns,

00:44:57.467 --> 00:44:59.767
then, you know,
you track those user patterns,

00:44:59.767 --> 00:45:02.701
sometimes you can actually
get the content you needed

00:45:02.701 --> 00:45:06.300
for the highly probable
next action

00:45:06.300 --> 00:45:08.567
in the idle time.

00:45:12.300 --> 00:45:13.868
audience member:
In your benchmarking,

00:45:13.868 --> 00:45:15.567
how do you get
accurate timing

00:45:15.567 --> 00:45:17.300
for Windows Internet
Explorer?

00:45:17.300 --> 00:45:19.534
I understand
the time resolution

00:45:19.534 --> 00:45:22.067
is, like, 15 milliseconds
on Windows.

00:45:22.067 --> 00:45:24.267
Norton: We're--

00:45:24.267 --> 00:45:26.667
so you can probably tell
from some of the tools

00:45:26.667 --> 00:45:29.100
we're instrumenting pretty
deeply into the browser,

00:45:29.100 --> 00:45:32.534
so for instance,
for Internet Explorer,

00:45:32.534 --> 00:45:35.234
we're actually getting
low-level calls

00:45:35.234 --> 00:45:37.067
in calling
the multimedia timers.

00:45:37.067 --> 00:45:40.868
So we're getting nice,
good timing on those.

00:45:40.868 --> 00:45:43.667
That's part
of the reason why--

00:45:43.667 --> 00:45:46.901
that's part of the reason
why I didn't show

00:45:46.901 --> 00:45:49.000
a lot of those things running
everywhere, because, you know,

00:45:49.000 --> 00:45:52.868
you have to get
the instrumentation in place.

00:45:55.000 --> 00:45:56.300
Yeah.

00:45:56.300 --> 00:45:59.234
audience member:
I have a crazy question for you.

00:45:59.234 --> 00:46:00.701
I've been wondering
for a long time

00:46:00.701 --> 00:46:02.234
why someone
doesn't do this,

00:46:02.234 --> 00:46:04.901
and you guys have the biggest
opportunity to actually do it,

00:46:04.901 --> 00:46:10.000
which is suppose someone
writes their whole app in GWT,

00:46:10.000 --> 00:46:11.868
so it's written
basically in Java,

00:46:11.868 --> 00:46:16.434
and then the browser, you know,
that's maybe, say, Chrome,

00:46:16.434 --> 00:46:21.033
and the user agent
is one of the fields of HTTP,

00:46:21.033 --> 00:46:23.868
so Chrome browser talks to a
back-end that's running in GWT,

00:46:23.868 --> 00:46:26.868
and Chrome browser says,
"hey, I need a web page,

00:46:26.868 --> 00:46:29.667
[whispers]
but psst, we're Google, okay?"

00:46:29.667 --> 00:46:33.033
And the GWT site says,
"I hear you want a web page,

00:46:33.033 --> 00:46:36.000
[whispers]
but hey, we're Google too."

00:46:36.000 --> 00:46:37.601
And, you know,
and it says,

00:46:37.601 --> 00:46:41.100
"Don't tell anybody,
but look.

00:46:41.100 --> 00:46:44.701
"Instead of
all that Web crap,

00:46:44.701 --> 00:46:46.901
here's the byte codes
for the Java."

00:46:46.901 --> 00:46:48.701
And just send that over,
and the Chrome browser says,

00:46:48.701 --> 00:46:50.767
"Okay, I'll just
run that instead."

00:46:50.767 --> 00:46:53.434
Get rid of the whole browser,
and we have a world

00:46:53.434 --> 00:46:56.434
where people go to web pages
and they are apps.

00:46:56.434 --> 00:46:57.634
Norton: Right.

00:46:57.634 --> 00:46:58.634
audience member:
I'm sure I'm not

00:46:58.634 --> 00:47:00.167
the first person
to think of this,

00:47:00.167 --> 00:47:04.300
but it almost seems
possible now, actually.

00:47:04.300 --> 00:47:06.167
Could you comment?

00:47:06.167 --> 00:47:08.667
Norton: It does seem possible.
We've talked a lot about it.

00:47:08.667 --> 00:47:13.167
It's unclear what the balancing
act is there between--

00:47:13.167 --> 00:47:15.667
I mean, you know,
so you take VMs, I mean,

00:47:15.667 --> 00:47:19.601
the V8 guys are doing
a pretty good job with that VM,

00:47:19.601 --> 00:47:21.334
so it's possible.

00:47:21.334 --> 00:47:23.367
I don't know.
Maybe it'll happen.

00:47:23.367 --> 00:47:24.734
Just not sure.

00:47:24.734 --> 00:47:26.868
I mean, certainly we've had
discussions about it,

00:47:26.868 --> 00:47:28.868
and we think
it's pretty cool too,

00:47:28.868 --> 00:47:30.200
but I don't know.

00:47:30.200 --> 00:47:31.534
I don't know that
I can comment too much.

00:47:31.534 --> 00:47:34.334
I just don't--
I think it's a cool world.

00:47:34.334 --> 00:47:35.667
audience member: Do you think
it would really be a win?

00:47:35.667 --> 00:47:37.434
'Cause it would defeat
a few other things.

00:47:37.434 --> 00:47:39.601
You'd have to have,
you know--

00:47:39.601 --> 00:47:40.901
You no longer
have generic tools

00:47:40.901 --> 00:47:42.067
that can, say,
look at your HTML

00:47:42.067 --> 00:47:43.400
and, say, feed it to
a search engine

00:47:43.400 --> 00:47:44.934
with a bunch of keywords.

00:47:44.934 --> 00:47:47.300
You wouldn't be able
to display it to people

00:47:47.300 --> 00:47:48.701
who can't read
by reading it to them

00:47:48.701 --> 00:47:50.467
or letting them search,
you know.

00:47:50.467 --> 00:47:52.734
So you'd have to
implement all that too.

00:47:52.734 --> 00:47:55.334
Norton:
Yeah, and it'd take

00:47:55.334 --> 00:48:00.267
a lot of consideration
from a user standpoint too.

00:48:00.267 --> 00:48:03.434
Whether JVMs are installed
and whatnot.

00:48:03.434 --> 00:48:05.133
I guess it could be
baked in, but...

00:48:05.133 --> 00:48:09.067
audience member:
Oh, I see. Okay, sure.

00:48:09.067 --> 00:48:13.000
another audience member: Sort of
a related question to that,

00:48:13.000 --> 00:48:15.734
kind of.

00:48:15.734 --> 00:48:17.601
But you have done a lot of
low-level instrumentation

00:48:17.601 --> 00:48:18.901
on browsers like
you talked about

00:48:18.901 --> 00:48:21.968
and the screenshots
you showed.

00:48:21.968 --> 00:48:24.167
And one of the things
I know, Kelly, you found

00:48:24.167 --> 00:48:26.801
is that it's not actually
the JavaScript code

00:48:26.801 --> 00:48:29.033
that's necessarily
limiting anymore,

00:48:29.033 --> 00:48:32.701
it's actually the other stuff,
like all the DOM, you know,

00:48:32.701 --> 00:48:35.534
and CSS manipulation
and layout and so on.

00:48:35.534 --> 00:48:36.868
So as you've looked at it,

00:48:36.868 --> 00:48:38.667
and I've seen
you personally

00:48:38.667 --> 00:48:41.467
look at these things
very deeply,

00:48:41.467 --> 00:48:44.234
what are the things
that surprised you the most?

00:48:44.234 --> 00:48:45.701
The sort of things
that are done

00:48:45.701 --> 00:48:47.667
all the time
in the Web that,

00:48:47.667 --> 00:48:48.968
when you do it a lot,

00:48:48.968 --> 00:48:52.167
have wildly varying behavior
in different browsers,

00:48:52.167 --> 00:48:56.467
or things that seemed innocuous
that had really bad effects.

00:48:56.467 --> 00:48:58.868
Norton: Actually there's a
really good one, and that is--

00:48:58.868 --> 00:49:00.200
It is surprising.

00:49:00.200 --> 00:49:03.000
So I showed you offsetHeight
taking a long time.

00:49:03.000 --> 00:49:04.100
It turns out that
the time--

00:49:04.100 --> 00:49:06.367
Not only is it the time
to take a variable

00:49:06.367 --> 00:49:08.467
across the state
your DOM in,

00:49:08.467 --> 00:49:10.667
that number
is actually affected

00:49:10.667 --> 00:49:14.868
quite a bit by the CSS styles
that are active.

00:49:14.868 --> 00:49:17.767
And in fact, you can actually
see that number climb up

00:49:17.767 --> 00:49:20.000
if you start to introduce
more descendant selectors.

00:49:20.000 --> 00:49:22.467
Descendant selectors
are pretty expensive

00:49:22.467 --> 00:49:25.667
because effectively how
they work in many browsers

00:49:25.667 --> 00:49:29.133
is they go and find
the thing you declare

00:49:29.133 --> 00:49:30.601
on the far
right-hand side first,

00:49:30.601 --> 00:49:34.100
and then they have to walk up
to see if they can satisfy--

00:49:34.100 --> 00:49:37.534
see if they can satisfy
the selector as it goes up.

00:49:37.534 --> 00:49:40.567
Now there are certain
descendant selectors

00:49:40.567 --> 00:49:42.367
like the universal
selector,

00:49:42.367 --> 00:49:43.801
which basically says
"match everything."

00:49:43.801 --> 00:49:44.901
If you think about
what that means,

00:49:44.901 --> 00:49:46.267
that means that okay,

00:49:46.267 --> 00:49:47.968
what you're telling the browser
is take every element.

00:49:47.968 --> 00:49:50.000
Now walk up the tree,
and tell me

00:49:50.000 --> 00:49:52.334
if it satisfies
the selector.

00:49:52.334 --> 00:49:54.968
Since those styles
have to be taken into account

00:49:54.968 --> 00:49:57.200
in order to answer things
like offsetHeight,

00:49:57.200 --> 00:49:59.901
you actually see that they do
have an effect on these times.

00:49:59.901 --> 00:50:01.434
That was actually
one of the surprising things.

00:50:01.434 --> 00:50:04.200
And the other surprising thing
is it tends to affect,

00:50:04.200 --> 00:50:06.300
counter-intuitively,
some DOM calls

00:50:06.300 --> 00:50:08.667
that you wouldn't even
have thought it would affect.

00:50:08.667 --> 00:50:11.934
Like we see calls
to cloneNode go up

00:50:11.934 --> 00:50:13.467
because of CSS
style matching.

00:50:13.467 --> 00:50:16.434
We're not quite sure
why in some browsers

00:50:16.434 --> 00:50:19.534
they actually apply styles
whenever you do a cloneNode

00:50:19.534 --> 00:50:21.567
when it's not attached
to the DOM yet,

00:50:21.567 --> 00:50:23.834
but we actually see
the times for that go up.

00:50:23.834 --> 00:50:29.067
So many things like that
have been surprising.

00:50:29.067 --> 00:50:31.467
Yeah, I mean, I think
that's the biggest thing.

00:50:31.467 --> 00:50:33.534
I can't think
of anything else.

00:50:33.534 --> 00:50:34.634
Yeah, there's a lot of

00:50:34.634 --> 00:50:37.100
surprisingly good data
inside there.

00:50:37.100 --> 00:50:38.400
Oh, actually there's
another interesting one,

00:50:38.400 --> 00:50:39.534
and that is--

00:50:39.534 --> 00:50:41.601
I showed you the example
with invalidating styles

00:50:41.601 --> 00:50:42.701
and sort of
flip-flopping.

00:50:42.701 --> 00:50:44.734
Well, it turns out on--

00:50:44.734 --> 00:50:46.400
It turns out that
we found some evidence

00:50:46.400 --> 00:50:48.367
on Internet Explorer.

00:50:48.367 --> 00:50:51.400
For tables, there's actually
a table cache,

00:50:51.400 --> 00:50:55.334
a table layout cache,
and if you set className,

00:50:55.334 --> 00:50:57.467
you invalidate
the table layout cache.

00:50:57.467 --> 00:50:59.067
If you're just trying
to update

00:50:59.067 --> 00:51:02.234
a background in that table,

00:51:02.234 --> 00:51:03.734
and you just
setStyle.background,

00:51:03.734 --> 00:51:07.934
you actually don't invalidate
the table layout cache.

00:51:07.934 --> 00:51:09.434
So there's some
interesting stuff

00:51:09.434 --> 00:51:11.467
in the instrumentation
we're doing.

00:51:11.467 --> 00:51:14.067
And that example, for instance,
would be counter-intuitive

00:51:14.067 --> 00:51:16.501
and would actually
go against some device

00:51:16.501 --> 00:51:18.601
that has been, you know,
industry standard

00:51:18.601 --> 00:51:19.767
that you would
set class names

00:51:19.767 --> 00:51:24.100
to avoid causing so many
reflows in browsers.

00:51:24.100 --> 00:51:26.467
That would actually be
a device that was--

00:51:26.467 --> 00:51:31.234
that ran counter to that, so.

00:51:31.234 --> 00:51:36.000
audience member: Related to
avoiding unnecessary widgets--

00:51:36.000 --> 00:51:38.834
To me that--just to start
implementing that

00:51:38.834 --> 00:51:41.000
seems like it's gonna
make more and more code

00:51:41.000 --> 00:51:43.667
that's hard to maintain
because you're

00:51:43.667 --> 00:51:47.934
dumping a lot of your
object orient into text.

00:51:47.934 --> 00:51:50.667
Why aren't y--
but the r--

00:51:50.667 --> 00:51:52.434
The question
I came up with was

00:51:52.434 --> 00:51:55.000
why aren't you guys
creating more widgets

00:51:55.000 --> 00:51:57.167
that implement
some of this stuff

00:51:57.167 --> 00:51:59.200
so you could give
a broader set of widgets

00:51:59.200 --> 00:52:01.868
that could handle more
of these low-level things?

00:52:01.868 --> 00:52:04.067
Norton:
So the good answer is we are.

00:52:04.067 --> 00:52:06.467
And in fact, the UI Binder
that we talked about,

00:52:06.467 --> 00:52:07.667
which is sort of
the declarative markup,

00:52:07.667 --> 00:52:09.467
is intended
for exactly that.

00:52:09.467 --> 00:52:11.267
We had the same
observation.

00:52:11.267 --> 00:52:13.133
We're like, okay,
it's kind of distressing

00:52:13.133 --> 00:52:15.267
that in order
to make things faster,

00:52:15.267 --> 00:52:16.400
having to move things
into strings--

00:52:16.400 --> 00:52:17.934
we hate moving things
into strings.

00:52:17.934 --> 00:52:20.601
It runs against
everything in our core--

00:52:20.601 --> 00:52:22.434
and so that's the reason
why we're trying

00:52:22.434 --> 00:52:25.634
to create these other tools
that are in fact checked,

00:52:25.634 --> 00:52:27.701
and will, you know,
do the right thing at runtime.

00:52:27.701 --> 00:52:29.200
So that stuff is coming,

00:52:29.200 --> 00:52:31.367
and it is definitely
on our minds.

00:52:31.367 --> 00:52:35.300
So right now, if you have to
do these things by hand,

00:52:35.300 --> 00:52:38.000
you know, we tend to
do them carefully,

00:52:38.000 --> 00:52:39.334
and we, you know,

00:52:39.334 --> 00:52:42.234
tend to use,
a lot of times, generators.

00:52:42.234 --> 00:52:45.234
GWT generators, which may be
a foreign concept.

00:52:45.234 --> 00:52:49.033
If it is, there's information
on the website,

00:52:49.033 --> 00:52:51.801
but that's also a good way
to handle a lot of these things.

00:52:51.801 --> 00:52:56.901
An advanced method,
but it's available.

00:52:56.901 --> 00:52:59.167
Any other questions?

00:52:59.167 --> 00:53:01.367
All right,
thank you guys.

00:53:01.367 --> 00:53:04.300
[applause]

