WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.562
[MUSIC PLAYING]

00:00:04.562 --> 00:00:05.520
IAN LAKE: Hi, everyone.

00:00:05.520 --> 00:00:06.420
My name is Ian lake.

00:00:06.420 --> 00:00:08.420
DANIEL SANTIAGO RIVERA:
Hi, I'm Daniel Santiago.

00:00:08.420 --> 00:00:10.677
BEN WEISS: And I'm Ben Weiss.

00:00:10.677 --> 00:00:13.010
IAN LAKE: We're here to talk
about a little thing called

00:00:13.010 --> 00:00:15.120
navigation.

00:00:15.120 --> 00:00:17.150
What is navigation?

00:00:17.150 --> 00:00:21.110
If you're here for Google Maps,
you're not in the right talk

00:00:21.110 --> 00:00:24.320
because today we'll be talking
specifically about the Jetpack

00:00:24.320 --> 00:00:26.090
NAVIGATION component.

00:00:26.090 --> 00:00:29.820
Now when we say component,
what does that actually mean?

00:00:29.820 --> 00:00:32.439
Well, let's look at what the
mission statement for Jetpack

00:00:32.439 --> 00:00:34.220
Navigation actually is.

00:00:34.220 --> 00:00:39.650
It's a suite of libraries,
tooling, and guidance

00:00:39.650 --> 00:00:42.080
that provide a robust
navigation framework

00:00:42.080 --> 00:00:44.030
for in-app navigation.

00:00:44.030 --> 00:00:47.270
So a very specific goal is kind
of that in-app navigation--

00:00:47.270 --> 00:00:49.430
that navigation
between screens--

00:00:49.430 --> 00:00:51.770
and provide more than
just the libraries,

00:00:51.770 --> 00:00:55.820
but also tooling and guidance
to go along with that.

00:00:55.820 --> 00:01:00.920
I think it's best to explain
navigation with a sample app.

00:01:00.920 --> 00:01:03.500
Here, we're going to
build a trivia app.

00:01:03.500 --> 00:01:07.670
Because I'm a Googler, it
of course has chat built in.

00:01:07.670 --> 00:01:11.270
We have a chat list that has
all of your conversations.

00:01:11.270 --> 00:01:14.000
Then, of course, a chat fragment
which will actually have

00:01:14.000 --> 00:01:16.240
the actual conversation itself.

00:01:16.240 --> 00:01:17.960
And of course, a profile.

00:01:17.960 --> 00:01:21.230
All these will be available
via a navigation drawer

00:01:21.230 --> 00:01:23.720
on our main activity.

00:01:23.720 --> 00:01:26.480
We chose fragments
here because they

00:01:26.480 --> 00:01:27.950
provide a really
good integration

00:01:27.950 --> 00:01:30.300
with other architecture
components, like view models

00:01:30.300 --> 00:01:32.260
and lifecycle.

00:01:32.260 --> 00:01:35.030
To kind of actually
make this all work,

00:01:35.030 --> 00:01:39.680
we're putting all of these
fragments in a NavHostFragment.

00:01:39.680 --> 00:01:41.810
This is the thing that
navigation provides

00:01:41.810 --> 00:01:44.420
for you, which is basically
the container where

00:01:44.420 --> 00:01:48.010
as we swap between these
different screens in our app,

00:01:48.010 --> 00:01:50.480
the NavHostFragment is
what's actually going to be

00:01:50.480 --> 00:01:53.930
that container in your layout.

00:01:53.930 --> 00:01:57.410
What do we actually need to
build out this sample app?

00:01:57.410 --> 00:01:59.300
Its a 40 minute talk.

00:01:59.300 --> 00:02:01.160
We're going to go fast.

00:02:01.160 --> 00:02:03.240
We have a navigation
graph, itself.

00:02:03.240 --> 00:02:07.280
This is the map of
your app, and it

00:02:07.280 --> 00:02:11.090
has four fragment
destinations-- our four screens.

00:02:11.090 --> 00:02:13.490
Then of course, we're going
to have a menu, and that'll

00:02:13.490 --> 00:02:16.820
be for setting up our side
navigation-- our navigation

00:02:16.820 --> 00:02:21.370
view, with what items
we want in that list.

00:02:21.370 --> 00:02:24.920
Then we have our layout
for our activity, which

00:02:24.920 --> 00:02:27.730
is going to have a drawer
layout for our side nav,

00:02:27.730 --> 00:02:31.800
a toolbar for our top app bar,
and then our NavHost fragment,

00:02:31.800 --> 00:02:35.390
which is actually going to be
the main content of our app.

00:02:35.390 --> 00:02:38.060
And then lastly, we just need
an activity to kind of tie

00:02:38.060 --> 00:02:40.070
all those things together.

00:02:40.070 --> 00:02:41.990
What does this
actually look like?

00:02:41.990 --> 00:02:45.890
First, we'll start
with the graph.

00:02:45.890 --> 00:02:48.180
We wanted deep integration
in the tooling.

00:02:48.180 --> 00:02:51.700
So in Android Studio--

00:02:51.700 --> 00:02:56.160
3.4 and 3.5-- we have
a navigation editor.

00:02:56.160 --> 00:02:58.820
So besides being able
to do things in xml,

00:02:58.820 --> 00:03:01.990
and also programmatically
if you're up for that,

00:03:01.990 --> 00:03:04.640
you'll also get a visual
editor where we can actually

00:03:04.640 --> 00:03:09.980
see the structure of our whole
app here with all the pieces,

00:03:09.980 --> 00:03:12.020
and all the links
between each one.

00:03:12.020 --> 00:03:16.400
For example, between the
chat list and the chat.

00:03:16.400 --> 00:03:17.690
Next, for our menu.

00:03:17.690 --> 00:03:19.250
It's all very kind
of basic stuff--

00:03:19.250 --> 00:03:22.040
IDs, icons, and
titles for each one.

00:03:22.040 --> 00:03:24.740
But the important
part here is we'll

00:03:24.740 --> 00:03:30.680
use the same IDs as we put
in our navigation graph.

00:03:30.680 --> 00:03:34.070
This is what will let navigation
tie these things together

00:03:34.070 --> 00:03:36.500
automatically.

00:03:36.500 --> 00:03:38.400
Now of course, for
our actual layout.

00:03:38.400 --> 00:03:42.060
We've stripped out a few
layout widths and heights,

00:03:42.060 --> 00:03:43.490
so don't try and compile this.

00:03:43.490 --> 00:03:45.310
But that's all the
important bits.

00:03:45.310 --> 00:03:47.490
Specifically, has
one important bit,

00:03:47.490 --> 00:03:50.720
which is the actual
NavHost fragment itself.

00:03:50.720 --> 00:03:53.020
Here, we'll just put it
directly in our layout--

00:03:53.020 --> 00:03:55.220
NavHost fragment-- and
here's where we'll actually

00:03:55.220 --> 00:03:58.970
use that AppNav graph
to tie that to the graph

00:03:58.970 --> 00:04:01.640
that we created in our xml.

00:04:01.640 --> 00:04:05.270
Then to look up our navigation
view for that side nav,

00:04:05.270 --> 00:04:09.000
we'll just attach the same
menu that we built here.

00:04:09.000 --> 00:04:11.120
Now what we really need
is just the activity

00:04:11.120 --> 00:04:14.420
that binds all these
things together.

00:04:14.420 --> 00:04:17.810
We've made it really easy from
anywhere in your activity,

00:04:17.810 --> 00:04:19.880
as well as anywhere
in a fragment, as well

00:04:19.880 --> 00:04:22.700
as any view within
that whole hierarchy

00:04:22.700 --> 00:04:25.280
to get an instance of
your NavController.

00:04:25.280 --> 00:04:29.030
So, call an extension
for findNavController

00:04:29.030 --> 00:04:32.840
with just the ID of
your NavHost fragment.

00:04:32.840 --> 00:04:35.930
Of course, if you're using
the Java programming language,

00:04:35.930 --> 00:04:38.060
then you'll be able
to use a static method

00:04:38.060 --> 00:04:40.340
to do the exact same thing.

00:04:40.340 --> 00:04:42.530
Once we have this
NavController--

00:04:42.530 --> 00:04:45.620
this thing that is powering
all of navigation--

00:04:45.620 --> 00:04:47.842
what do we actually do with it?

00:04:47.842 --> 00:04:49.050
We can do a couple of things.

00:04:49.050 --> 00:04:52.670
One, we can set up our
toolbar at the top.

00:04:52.670 --> 00:04:56.990
What we'll do here is
use appBarConfiguration.

00:04:56.990 --> 00:04:59.150
This is kind of
that figuring out

00:04:59.150 --> 00:05:01.310
what that top app
bar is supposed

00:05:01.310 --> 00:05:03.000
to do in the first place.

00:05:03.000 --> 00:05:05.830
And the first thing we want
to do is make sure that all

00:05:05.830 --> 00:05:07.930
of those top level
destinations--

00:05:07.930 --> 00:05:10.540
those three things in
our navigation view--

00:05:10.540 --> 00:05:13.120
are all kind of at the
same visual hierarchy.

00:05:13.120 --> 00:05:15.700
We pass on the list here,
and those are the ones

00:05:15.700 --> 00:05:18.130
that won't show an up arrow.

00:05:18.130 --> 00:05:21.280
They're all at the same
visual hierarchy level.

00:05:21.280 --> 00:05:23.830
We want to make sure we tell
navigation oh, these three

00:05:23.830 --> 00:05:26.140
destinations are important.

00:05:26.140 --> 00:05:30.310
Then, we're going to pass in
the actual drawer layout itself.

00:05:30.310 --> 00:05:32.740
This is the key that
says when you're

00:05:32.740 --> 00:05:34.480
on one of those top
level destinations,

00:05:34.480 --> 00:05:36.850
instead of showing
no icon at all,

00:05:36.850 --> 00:05:38.350
you want to show
that hamburger icon

00:05:38.350 --> 00:05:41.770
so that users know that they
can pull out the drawer.

00:05:41.770 --> 00:05:44.730
And then, with that
appBarConfiguration setup,

00:05:44.730 --> 00:05:47.540
all we call is
.setupWithNavController,

00:05:47.540 --> 00:05:50.350
another Kotlin extension
on the toolbar here.

00:05:50.350 --> 00:05:54.970
Now, as we navigate
between screens of our app,

00:05:54.970 --> 00:05:58.010
we're automatically updating
the title in the toolbar.

00:05:58.010 --> 00:06:00.437
We're automatically
changing the icon,

00:06:00.437 --> 00:06:02.020
and there's nothing
else we need to do

00:06:02.020 --> 00:06:04.840
to hook up to get the
correct up behavior,

00:06:04.840 --> 00:06:06.550
to get the correct label.

00:06:06.550 --> 00:06:08.800
It's all kind of built
into this functionality,

00:06:08.800 --> 00:06:13.000
because we've set up our
appBarConfiguration correctly.

00:06:13.000 --> 00:06:15.310
Similarly, for our
navigation view,

00:06:15.310 --> 00:06:16.870
it's the same type of thing.

00:06:16.870 --> 00:06:19.840
We have just another
setup with NavController.

00:06:19.840 --> 00:06:23.985
Now, whenever you click on
something in your side nav,

00:06:23.985 --> 00:06:26.110
it's automatically going
to go to the right screen,

00:06:26.110 --> 00:06:29.200
because we used that
same ID in the menu,

00:06:29.200 --> 00:06:30.940
and at the navigation graph.

00:06:30.940 --> 00:06:33.340
Similarly, the
selected item is always

00:06:33.340 --> 00:06:38.590
going to stay in-sync with
where you're at in the graph.

00:06:38.590 --> 00:06:41.410
Now we don't need to
focus on anything else.

00:06:41.410 --> 00:06:44.920
But we built a lot of things.

00:06:44.920 --> 00:06:46.670
We never need to touch
our activity again.

00:06:46.670 --> 00:06:48.820
But how do we actually
put this all together?

00:06:48.820 --> 00:06:51.470
Well, it started with
the common library,

00:06:51.470 --> 00:06:53.170
and this is where
they actually have

00:06:53.170 --> 00:06:56.500
the runtime equivalent
of navigation graphs

00:06:56.500 --> 00:06:59.680
and all of the kind
of base components.

00:06:59.680 --> 00:07:04.720
On top of that is the actual
navigation runtime library.

00:07:04.720 --> 00:07:06.550
This is kind of that
thing that provides

00:07:06.550 --> 00:07:10.000
the actual NavController itself.

00:07:10.000 --> 00:07:12.520
But on top of that,
we realized, OK.

00:07:12.520 --> 00:07:15.280
That's kind of the
core pieces, but we

00:07:15.280 --> 00:07:17.550
want to build a few things.

00:07:17.550 --> 00:07:20.350
A lot of people
do use fragments.

00:07:20.350 --> 00:07:24.160
They are probably one of
the most popular APIs--

00:07:24.160 --> 00:07:30.010
not from a popularity, but
from a usage perspective.

00:07:30.010 --> 00:07:31.888
We wanted something
out of the box,

00:07:31.888 --> 00:07:34.180
and especially that integration
with other architecture

00:07:34.180 --> 00:07:36.250
components was really important.

00:07:36.250 --> 00:07:38.710
We have the NavHost
fragment, and the ability

00:07:38.710 --> 00:07:44.140
to use fragment destinations in
a navigation fragment library.

00:07:44.140 --> 00:07:46.750
Similarly, if you're using
those material components

00:07:46.750 --> 00:07:50.350
like toolbars, and
other things, then we

00:07:50.350 --> 00:07:53.590
have a navigation UI, which
is what provides the app bar

00:07:53.590 --> 00:07:57.220
configuration, and all these
setup with NavController items.

00:07:57.220 --> 00:08:00.170
These top two items
are totally optional.

00:08:00.170 --> 00:08:02.890
If you want to go off the
rails and do something totally

00:08:02.890 --> 00:08:05.290
different, we do
support all of that

00:08:05.290 --> 00:08:08.500
as well, just using
navigation runtime.

00:08:08.500 --> 00:08:11.680
And of course,
because it's 2019,

00:08:11.680 --> 00:08:15.070
we have ktx versions
of all of these.

00:08:15.070 --> 00:08:17.200
Kotlin extensions for
all of these things

00:08:17.200 --> 00:08:20.830
as well as a Kotlin DSL for
building navigation graphs,

00:08:20.830 --> 00:08:25.330
and many other features
if you're using Kotlin.

00:08:25.330 --> 00:08:28.420
We talked a little bit
about the library side,

00:08:28.420 --> 00:08:31.510
and saw the navigation editor,
but we also have more tooling

00:08:31.510 --> 00:08:33.260
integration as well.

00:08:33.260 --> 00:08:36.309
So being able to integrate
in with manifest merger,

00:08:36.309 --> 00:08:39.940
so you don't have to write
intent filters for deep links.

00:08:39.940 --> 00:08:42.789
We can build that for
you out of the deep links

00:08:42.789 --> 00:08:45.040
you put in your
navigation graph.

00:08:45.040 --> 00:08:48.400
Similarly, we also have a Safe
Args Gradle plugin, which we'll

00:08:48.400 --> 00:08:50.380
talk about more in detail.

00:08:50.380 --> 00:08:53.200
That really makes it easy
to move between destinations

00:08:53.200 --> 00:08:56.002
in a type-safe way.

00:08:56.002 --> 00:08:58.210
And of course, we also talked
about the guidance side

00:08:58.210 --> 00:08:58.857
of things.

00:08:58.857 --> 00:09:00.940
One of the things that was
really important for us

00:09:00.940 --> 00:09:04.300
is to not just throw a
library over the wall,

00:09:04.300 --> 00:09:08.050
but instead really talk to
our internal design teams,

00:09:08.050 --> 00:09:10.300
and other teams
outside of Google,

00:09:10.300 --> 00:09:12.640
say, what actually
works for developers?

00:09:12.640 --> 00:09:16.570
How can we make a consistent
experience across everyone?

00:09:16.570 --> 00:09:19.450
And that really came up
with a lot of the guidance,

00:09:19.450 --> 00:09:21.640
and a lot of the
documentation that we provide.

00:09:21.640 --> 00:09:26.050
We have quite a few pages
on developer.android.com

00:09:26.050 --> 00:09:29.290
that really go into
the details on not only

00:09:29.290 --> 00:09:32.360
how to use navigation,
but also some of the why,

00:09:32.360 --> 00:09:34.570
and some the reasonings
behind things,

00:09:34.570 --> 00:09:37.060
and the ways to really
kind of set it up

00:09:37.060 --> 00:09:40.150
in a consistent way
across every app.

00:09:40.150 --> 00:09:43.840
Also, we have worked with
DevRel and other organizations

00:09:43.840 --> 00:09:46.060
to make sure that
you have good getting

00:09:46.060 --> 00:09:49.330
started points
with our Code Lab.

00:09:49.330 --> 00:09:51.460
The documentation was
a really big focus

00:09:51.460 --> 00:09:55.090
for the navigation stable
release last month,

00:09:55.090 --> 00:10:00.650
but it also is a big focus for
our Navigation 2.1 release,

00:10:00.650 --> 00:10:02.560
which is in alpha right now.

00:10:02.560 --> 00:10:06.510
One of the things in there
was dialogue destinations.

00:10:06.510 --> 00:10:08.950
In addition to using
full screen fragments,

00:10:08.950 --> 00:10:11.460
now you can use a
dialogue destination

00:10:11.460 --> 00:10:16.530
and then you can
navigate to a dialogue.

00:10:16.530 --> 00:10:19.890
It's supported out of the
box by NavHost fragment,

00:10:19.890 --> 00:10:22.710
just like fragment
destinations, and allows

00:10:22.710 --> 00:10:25.650
you to use all the same
actions and arguments

00:10:25.650 --> 00:10:28.820
as you would for any
other kind of destination.

00:10:28.820 --> 00:10:30.570
What does this
look like in code?

00:10:30.570 --> 00:10:34.140
Instead of just using the
fragment tag for a fragment,

00:10:34.140 --> 00:10:38.360
now we can use a dialog
tag for a dialog.

00:10:38.360 --> 00:10:39.960
That's pretty easy, right?

00:10:39.960 --> 00:10:41.610
Same type of things
are supported.

00:10:41.610 --> 00:10:43.710
If you have arguments--
for example here,

00:10:43.710 --> 00:10:48.300
we have an error message for
our error dialog fragment.

00:10:48.300 --> 00:10:53.112
Those all still work, just
like any other destination.

00:10:53.112 --> 00:10:54.570
Another feature
that we were really

00:10:54.570 --> 00:10:57.090
excited about for
Navigation 2.1 was

00:10:57.090 --> 00:10:59.340
integration with ViewModels.

00:10:59.340 --> 00:11:02.760
ViewModels are an architecture
component about saving data

00:11:02.760 --> 00:11:05.190
across configuration changes.

00:11:05.190 --> 00:11:07.440
With the new safe
state ViewModels,

00:11:07.440 --> 00:11:11.160
even saving things across
process death and recreation.

00:11:11.160 --> 00:11:13.260
But we realized
there was something

00:11:13.260 --> 00:11:16.290
that needed to happen in
between the activities

00:11:16.290 --> 00:11:20.340
scope, i.e. the entire
app, as well as just

00:11:20.340 --> 00:11:22.680
the individual fragment level.

00:11:22.680 --> 00:11:26.910
Now you can actually scope
things to a navigation graph.

00:11:26.910 --> 00:11:28.690
Let's take a look at
what that looks like.

00:11:28.690 --> 00:11:31.110
Here's our four
destinations that we had.

00:11:31.110 --> 00:11:34.020
Now we want to add
an on-boarding flow.

00:11:34.020 --> 00:11:39.060
Our on-boarding flow is welcome,
setup, and find friends,

00:11:39.060 --> 00:11:42.210
because of course, we got to
connect to all of our friends

00:11:42.210 --> 00:11:46.620
with a totally incompatible
proprietary API.

00:11:46.620 --> 00:11:48.900
But for these things,
we want to share

00:11:48.900 --> 00:11:50.520
data between these fragments.

00:11:50.520 --> 00:11:54.480
So by encapsulating this
in an on-boarding graph--

00:11:54.480 --> 00:11:57.540
a nested graph--
we actually have

00:11:57.540 --> 00:12:00.990
a way of attaching information
at the graph level,

00:12:00.990 --> 00:12:04.440
rather than just at
the destination level.

00:12:04.440 --> 00:12:05.970
What does this look like?

00:12:05.970 --> 00:12:12.480
We can just use a by
navViewModels Kotlin property

00:12:12.480 --> 00:12:15.330
delegate to actually
get an instance

00:12:15.330 --> 00:12:17.940
of our on-boarding
ViewModel from any one

00:12:17.940 --> 00:12:21.240
of the destinations
within that graph.

00:12:21.240 --> 00:12:25.860
Now of course, there's a static
method for Java users, as well.

00:12:25.860 --> 00:12:28.710
So it totally works on both.

00:12:28.710 --> 00:12:30.330
Then, we can do
whatever we want.

00:12:30.330 --> 00:12:33.660
In this case, when
setup is complete,

00:12:33.660 --> 00:12:37.050
we save the user ID
into our ViewModel.

00:12:37.050 --> 00:12:40.170
That allows our next
fragment to then

00:12:40.170 --> 00:12:43.840
get an instance of that
exact same ViewModel,

00:12:43.840 --> 00:12:45.840
even if you've
done configuration

00:12:45.840 --> 00:12:48.760
changes across things, and then
extract that information out

00:12:48.760 --> 00:12:49.260
of it.

00:12:49.260 --> 00:12:51.360
Or maybe you do
something more useful,

00:12:51.360 --> 00:12:53.280
because this is a toy
example for slides.

00:12:56.070 --> 00:12:59.040
These are all kind of based
on a lot of what we built

00:12:59.040 --> 00:13:01.950
for navigation stables release.

00:13:01.950 --> 00:13:05.250
One of the things I was most
excited for was Safe Args.

00:13:05.250 --> 00:13:07.440
And to talk more about
Safe Args, here's Danny.

00:13:07.440 --> 00:13:08.940
DANIEL SANTIAGO
RIVERA: Thanks, Ian.

00:13:08.940 --> 00:13:15.880
[APPLAUSE]

00:13:15.880 --> 00:13:19.420
Like Ian mentioned, Safe
Args is a gradle plugin

00:13:19.420 --> 00:13:22.990
that basically complements
the navigation library.

00:13:22.990 --> 00:13:25.600
It basically graphs
your navigation file,

00:13:25.600 --> 00:13:28.660
analyzes them, and
generates some code for you

00:13:28.660 --> 00:13:30.880
to use your
application to help you

00:13:30.880 --> 00:13:35.570
safely pass arguments, and
navigate to valid destinations.

00:13:35.570 --> 00:13:38.740
Now you might be wondering,
why did we create a Safe Args,

00:13:38.740 --> 00:13:41.320
or why would you
even use Safe Args?

00:13:41.320 --> 00:13:43.390
After all, it's an
optional plugin,

00:13:43.390 --> 00:13:45.640
but we highly recommend
that you use it.

00:13:45.640 --> 00:13:48.130
The main reason is that
some of the checks that

00:13:48.130 --> 00:13:51.950
are performed at runtime now
get to be done at compile time.

00:13:51.950 --> 00:13:55.750
So this means you get to do
factorization as you work

00:13:55.750 --> 00:13:58.750
with your navigation graph.

00:13:58.750 --> 00:14:00.670
Because it generates
code, it means

00:14:00.670 --> 00:14:03.100
it can leverage some
of the assistant tools

00:14:03.100 --> 00:14:04.750
in Android Studio, for example.

00:14:04.750 --> 00:14:08.050
Autocomplete will kick in
when you're trying to use it.

00:14:08.050 --> 00:14:10.240
And again, because
it generates code,

00:14:10.240 --> 00:14:15.310
it means it transforms your
types in your navigation

00:14:15.310 --> 00:14:19.190
argument to actual types
in the language system.

00:14:19.190 --> 00:14:22.525
Let's take a look at it, and how
to use it and the kind of code

00:14:22.525 --> 00:14:23.740
it generates.

00:14:23.740 --> 00:14:26.330
We're back to the
shop application.

00:14:26.330 --> 00:14:28.000
We've got our new requirement.

00:14:28.000 --> 00:14:30.710
Our bosses-- as usual--
give us more work.

00:14:30.710 --> 00:14:33.610
This time, when we
click on the thumbnail

00:14:33.610 --> 00:14:36.620
on one of the chat lists,
we get to go to a profile.

00:14:36.620 --> 00:14:39.250
So now we have two
destinations that we

00:14:39.250 --> 00:14:41.350
can get from our chat list.

00:14:41.350 --> 00:14:45.700
If we take a look at how we
have defined our chat list

00:14:45.700 --> 00:14:48.970
destination, as usual,
you define the fragment

00:14:48.970 --> 00:14:52.600
that it uses, and the two
arrows that come out of it

00:14:52.600 --> 00:14:54.730
are the two actions
that we have,

00:14:54.730 --> 00:14:58.420
and these are the two
destinations that you

00:14:58.420 --> 00:15:01.348
would use to get out of it.

00:15:01.348 --> 00:15:02.890
Now we are on our
chat list frontman.

00:15:02.890 --> 00:15:04.740
We're trying to hook
things together.

00:15:04.740 --> 00:15:06.520
We're implementing
our profile image.

00:15:06.520 --> 00:15:09.100
Click listener, we
have a NavController.

00:15:09.100 --> 00:15:13.060
And usually, you would
navigate using your action.

00:15:13.060 --> 00:15:16.390
This is how you would do a
normal navigation usually,

00:15:16.390 --> 00:15:17.750
without Safe Args.

00:15:17.750 --> 00:15:21.370
But with Safe Args, instead you
will use the generated code.

00:15:21.370 --> 00:15:25.450
You would use this class called,
ChatListFragmentDirections.

00:15:25.450 --> 00:15:26.560
We'll see it in a bit.

00:15:26.560 --> 00:15:29.320
But the cool thing here is
as you're trying to use it,

00:15:29.320 --> 00:15:31.000
the ID kicks in,
and you actually

00:15:31.000 --> 00:15:34.000
have autocomplete on
the ballot actions

00:15:34.000 --> 00:15:37.640
that you can take
from this destination.

00:15:37.640 --> 00:15:40.090
Now what does Safe
Args actually generate?

00:15:40.090 --> 00:15:44.440
For each destination, it'll
generate a directions class,

00:15:44.440 --> 00:15:48.250
and this class basically has
functions for the value actions

00:15:48.250 --> 00:15:50.290
that you can take.

00:15:50.290 --> 00:15:53.440
These functions also
actually have parameters,

00:15:53.440 --> 00:15:57.880
and these parameters are
based on the arguments

00:15:57.880 --> 00:15:59.188
that you have in your action.

00:15:59.188 --> 00:16:00.730
And if they have
default values, they

00:16:00.730 --> 00:16:04.150
will show it here as default
value, as you can see.

00:16:04.150 --> 00:16:07.450
This is how we make sure that
by calling this function,

00:16:07.450 --> 00:16:09.280
and passing the
right parameters,

00:16:09.280 --> 00:16:13.960
you will be able to receive them
on the other side correctly.

00:16:13.960 --> 00:16:16.030
Safe Args also
generates a second set

00:16:16.030 --> 00:16:20.020
of classes which we
call, the Args classes.

00:16:20.020 --> 00:16:22.720
We navigate it now to
the profile frontmen,

00:16:22.720 --> 00:16:24.220
and we want to
parse the arguments.

00:16:24.220 --> 00:16:26.590
We will use what we call,
the profile frontmen

00:16:26.590 --> 00:16:29.510
args, and generate a
class by the Safe Args.

00:16:29.510 --> 00:16:31.030
And this is just
a beta class that

00:16:31.030 --> 00:16:33.700
contains your actual
types of your arguments.

00:16:33.700 --> 00:16:36.340
But as you can see, it has
these two methods-- tobundle,

00:16:36.340 --> 00:16:37.900
frombundle.

00:16:37.900 --> 00:16:44.410
You would use these methods
to actually get the Args out.

00:16:44.410 --> 00:16:47.080
But using this method
is how we basically

00:16:47.080 --> 00:16:51.340
take the responsibility
from you from using bundles.

00:16:51.340 --> 00:16:53.120
Even better, if
you're using Kotlin,

00:16:53.120 --> 00:16:55.960
we also have this
extension legacy function

00:16:55.960 --> 00:16:59.940
by Nav Args, which
helps you get those Args

00:16:59.940 --> 00:17:03.610
and start assessing that
data pretty quickly.

00:17:03.610 --> 00:17:07.030
Now you might have noticed
that the generated code is

00:17:07.030 --> 00:17:09.640
in Kotlin, and that's because
Safe Args will actually

00:17:09.640 --> 00:17:12.550
generate both Java
and Kotlin code.

00:17:12.550 --> 00:17:14.319
Some people were pretty
excited about it.

00:17:14.319 --> 00:17:17.250
They stopped pressing
the shift button.

00:17:19.859 --> 00:17:23.410
Now if we use the plugin, you
just go to your build a gradle,

00:17:23.410 --> 00:17:25.530
apply the plugin with the ID.

00:17:25.530 --> 00:17:29.280
Using this ID will
generate the Java code,

00:17:29.280 --> 00:17:31.590
but using the Kotlin
version of the ID

00:17:31.590 --> 00:17:34.110
will generate the Kotlin code.

00:17:34.110 --> 00:17:37.680
Pretty straightforward.

00:17:37.680 --> 00:17:39.930
Why did we decide
to generate Kotlin?

00:17:39.930 --> 00:17:41.650
There's two main benefits.

00:17:41.650 --> 00:17:43.060
One is [INAUDIBLE] performance.

00:17:43.060 --> 00:17:44.983
If you have a
Kotlin-only app, then

00:17:44.983 --> 00:17:46.650
generate the Kotlin
code, that means you

00:17:46.650 --> 00:17:48.180
don't have [INAUDIBLE] sources.

00:17:48.180 --> 00:17:51.840
And the second is that we get
to use idiomatic Kotlin code.

00:17:51.840 --> 00:17:53.760
In the Java version
of the generator code,

00:17:53.760 --> 00:17:55.140
we have builders.

00:17:55.140 --> 00:17:59.130
But in the Kotlin version,
we have data classes

00:17:59.130 --> 00:18:01.860
with primary constructor that
you can use name arguments

00:18:01.860 --> 00:18:03.040
and default arguments.

00:18:03.040 --> 00:18:05.250
So that's pretty nice,
because their data classes,

00:18:05.250 --> 00:18:07.650
you also have things like
copy, hashcode, and those kinds

00:18:07.650 --> 00:18:12.130
of things for your arguments.

00:18:12.130 --> 00:18:17.280
Now whether the plugin
generates Kotlin or Java code,

00:18:17.280 --> 00:18:20.910
it doesn't mean a lot if we
don't support a lot of types.

00:18:20.910 --> 00:18:23.220
So we started out supporting
the [INAUDIBLE] type,

00:18:23.220 --> 00:18:26.010
and as we got
closer to stable, we

00:18:26.010 --> 00:18:29.390
were able to add support for
parcelable, serializable,

00:18:29.390 --> 00:18:29.940
and enum.

00:18:29.940 --> 00:18:33.443
So if you have actions
that have arguments

00:18:33.443 --> 00:18:34.860
that are parcelable
and enums, you

00:18:34.860 --> 00:18:38.050
can use those with
the new documentation.

00:18:38.050 --> 00:18:41.290
We actually have a pretty table
with all of this information.

00:18:41.290 --> 00:18:44.160
You can look up there
how the syntax looks,

00:18:44.160 --> 00:18:47.010
whether it supports a file,
default values or not,

00:18:47.010 --> 00:18:49.710
nullable and things like that.

00:18:49.710 --> 00:18:52.110
[INAUDIBLE] is pretty
good when you're

00:18:52.110 --> 00:18:54.990
trying to work with a
tightly coupled graph,

00:18:54.990 --> 00:18:58.650
but sometimes you might need
to have a more deep couple

00:18:58.650 --> 00:18:59.640
navigation graph.

00:18:59.640 --> 00:19:02.755
And Ben here will talk to you
a little bit more about that.

00:19:02.755 --> 00:19:03.630
BEN WEISS: Thank you.

00:19:03.630 --> 00:19:09.710
[APPLAUSE]

00:19:09.710 --> 00:19:13.320
Modularizing applications has
become increasingly important,

00:19:13.320 --> 00:19:15.800
especially since last year,
we announced the Android app

00:19:15.800 --> 00:19:16.400
bundle.

00:19:16.400 --> 00:19:19.070
And this year, with
dynamic feature modules

00:19:19.070 --> 00:19:21.020
being generally
available, we will

00:19:21.020 --> 00:19:25.010
see a lot more applications
that will be modularized.

00:19:25.010 --> 00:19:29.240
This not only reflects to your
application while you develop

00:19:29.240 --> 00:19:31.760
it, but it allows you-- with
dynamic feature modules--

00:19:31.760 --> 00:19:35.275
to actually ship parts of your
application to your users.

00:19:35.275 --> 00:19:37.400
A couple of the benefits
that are on modularization

00:19:37.400 --> 00:19:40.610
during development are that you
can cut down your build times

00:19:40.610 --> 00:19:41.960
by creating distinct modules.

00:19:41.960 --> 00:19:45.740
Also, you can separate
the concerns within those.

00:19:45.740 --> 00:19:50.030
Separation of concerns
also is around navigation.

00:19:50.030 --> 00:19:55.070
Navigation library
supports modularization.

00:19:55.070 --> 00:19:57.170
Let's talk a little bit
about how you can split up

00:19:57.170 --> 00:19:59.210
your graph while you
break up your application

00:19:59.210 --> 00:20:00.200
into distinct modules.

00:20:04.340 --> 00:20:07.140
We saw this graph grow
over this presentation,

00:20:07.140 --> 00:20:10.760
and we have a couple of-- if
you look at the Design Editor

00:20:10.760 --> 00:20:11.270
here--

00:20:11.270 --> 00:20:16.070
we have a home graph, which
also has the arrow dialog.

00:20:16.070 --> 00:20:18.680
We have a chat list,
we have the chat,

00:20:18.680 --> 00:20:20.430
and we have the
profile, as well.

00:20:20.430 --> 00:20:22.400
Also, we have a
nested graph in here.

00:20:22.400 --> 00:20:25.190
We can break this
up in multiple ways.

00:20:25.190 --> 00:20:27.530
What we are doing here
is we are breaking up

00:20:27.530 --> 00:20:31.190
this graph into several
distinct libraries.

00:20:31.190 --> 00:20:34.590
We will still continue to
have one application module.

00:20:34.590 --> 00:20:37.310
We will have a home module,
a chat, and a profile.

00:20:37.310 --> 00:20:40.010
We'll just take that away, and
put it into a distinct graph,

00:20:40.010 --> 00:20:42.410
in a distinct library
module, as well.

00:20:46.790 --> 00:20:49.700
If you take a look at
this navigation file,

00:20:49.700 --> 00:20:53.540
it's really, really tricky
to see what's going on here.

00:20:53.540 --> 00:20:55.950
This is already a very
simplified example,

00:20:55.950 --> 00:20:58.310
if you have a real world app
you can keep on scrolling

00:20:58.310 --> 00:21:01.050
with these for a long time.

00:21:01.050 --> 00:21:05.390
So what we do instead is we just
break it up into the modules.

00:21:05.390 --> 00:21:09.620
We take out the
relevant destinations,

00:21:09.620 --> 00:21:12.340
and put those into
the files where

00:21:12.340 --> 00:21:15.400
they are going to be used.

00:21:15.400 --> 00:21:18.950
We do that for each of the
modules that we are creating.

00:21:18.950 --> 00:21:21.530
As you can see, each of
that has a start destination

00:21:21.530 --> 00:21:22.820
that we're able to jump into.

00:21:27.910 --> 00:21:32.410
Then, we include
these in the graph

00:21:32.410 --> 00:21:35.500
that we are hosting in
the application itself.

00:21:35.500 --> 00:21:37.540
All the modules
that we have created

00:21:37.540 --> 00:21:40.150
can be included in that.

00:21:40.150 --> 00:21:42.220
The way this works
is, using the include

00:21:42.220 --> 00:21:46.630
tag that has been around
since we launched navigation.

00:21:46.630 --> 00:21:50.650
You simply include the graph
that we have started out here.

00:21:50.650 --> 00:21:53.290
This goes alongside each
other navigation destination

00:21:53.290 --> 00:21:54.340
that already exists.

00:21:54.340 --> 00:21:59.980
You can have nested graphs, or
any other destination in here.

00:21:59.980 --> 00:22:03.395
This is really cool when
you have independent graphs,

00:22:03.395 --> 00:22:05.020
and you want to
navigate between those.

00:22:05.020 --> 00:22:06.740
That's great.

00:22:06.740 --> 00:22:10.870
But what if you want to move
from one graph to another?

00:22:10.870 --> 00:22:14.080
Our chat app has grown.

00:22:14.080 --> 00:22:16.467
We have a profile
fragment, but also we

00:22:16.467 --> 00:22:17.800
want to have friends in the app.

00:22:17.800 --> 00:22:20.290
We want to make sure that we
have the friend list there,

00:22:20.290 --> 00:22:20.870
as well.

00:22:20.870 --> 00:22:24.910
And since you can navigate from
the profile to the friend list,

00:22:24.910 --> 00:22:27.520
we have that in
the profile graph.

00:22:27.520 --> 00:22:31.030
So what you can do
here with ID, is

00:22:31.030 --> 00:22:34.930
you can simply reference
the chat graph and the start

00:22:34.930 --> 00:22:36.190
destination here.

00:22:36.190 --> 00:22:38.440
But that will only
lead us so far.

00:22:38.440 --> 00:22:41.950
Actually, what we would like to
have is we want to go straight.

00:22:41.950 --> 00:22:45.100
If we click on the friend
list, what we want to do

00:22:45.100 --> 00:22:47.840
is we want to go straight
to the chat fragment,

00:22:47.840 --> 00:22:49.803
and being able to chat
directly with a friend,

00:22:49.803 --> 00:22:51.220
rather than going
to the chat list

00:22:51.220 --> 00:22:53.650
first, and then
jumping in there.

00:22:53.650 --> 00:22:55.780
With IDs-- like I
said-- it's not only

00:22:55.780 --> 00:22:59.890
possible to jump directly to the
start destination of the graph.

00:22:59.890 --> 00:23:04.690
That's why with Navigation
2.1 we have enabled navigation

00:23:04.690 --> 00:23:08.800
by URIs so you can use deep
links to navigate directly

00:23:08.800 --> 00:23:14.520
to destinations, even
across graph boundaries.

00:23:14.520 --> 00:23:18.440
How this works is
you remove your ID,

00:23:18.440 --> 00:23:20.870
and declare deepLink
in here with a URI

00:23:20.870 --> 00:23:24.860
that can host the
parameter for user ID,

00:23:24.860 --> 00:23:27.590
so you can jump directly
into the user fragment

00:23:27.590 --> 00:23:31.440
and can start chatting with
your friends right away.

00:23:31.440 --> 00:23:33.065
So you no longer have
to hold onto IDs.

00:23:33.065 --> 00:23:34.732
You no longer-- in
the modularized app--

00:23:34.732 --> 00:23:36.620
would have to have
them in a shared space.

00:23:36.620 --> 00:23:39.380
Instead of that,
you have your URIs

00:23:39.380 --> 00:23:43.527
that you can share
across the application.

00:23:43.527 --> 00:23:45.860
And within a friend list
fragment, what we then would do

00:23:45.860 --> 00:23:48.440
is we simply build up
the URI and navigate

00:23:48.440 --> 00:23:50.097
to our destination.

00:23:56.440 --> 00:23:58.500
Another problem
that we came across

00:23:58.500 --> 00:24:00.822
is when you navigate--
not within an app that

00:24:00.822 --> 00:24:03.030
has library modules, but
one that has dynamic feature

00:24:03.030 --> 00:24:03.553
modules.

00:24:03.553 --> 00:24:05.970
The question around here is,
where are we going with this?

00:24:10.410 --> 00:24:12.090
As you can see,
dynamic feature modules

00:24:12.090 --> 00:24:14.215
have a bit of a different
way that the dependencies

00:24:14.215 --> 00:24:15.780
are on one another.

00:24:15.780 --> 00:24:16.950
They can depend on the app.

00:24:16.950 --> 00:24:20.310
It's really tricky to navigate
between those features

00:24:20.310 --> 00:24:22.740
when it comes to
modules that are not

00:24:22.740 --> 00:24:24.485
on device in particular.

00:24:24.485 --> 00:24:26.610
Dynamic feature modules
can be installed initially,

00:24:26.610 --> 00:24:29.460
or can be downloaded later on.

00:24:29.460 --> 00:24:33.570
We've heard questions around
this over the past year,

00:24:33.570 --> 00:24:36.930
and we thought about
it, and we have

00:24:36.930 --> 00:24:40.650
started to work on a new
library that is extending

00:24:40.650 --> 00:24:42.420
the navigation library.

00:24:42.420 --> 00:24:45.210
That will allow you to
intercept navigating

00:24:45.210 --> 00:24:47.580
to separate destinations.

00:24:47.580 --> 00:24:51.310
Then, if the module that we're
looking for is not installed,

00:24:51.310 --> 00:24:54.000
it will take care of all
the downloading for that,

00:24:54.000 --> 00:24:57.210
provides you with a
couple of callbacks

00:24:57.210 --> 00:25:01.140
to either provide your own
UI while it's downloading,

00:25:01.140 --> 00:25:04.480
or with a default safe version
for you to use as well.

00:25:04.480 --> 00:25:06.730
And then once the module
is downloaded and ready,

00:25:06.730 --> 00:25:08.940
it will continue navigating.

00:25:08.940 --> 00:25:12.360
If the modules installed
initially, all what it does

00:25:12.360 --> 00:25:16.500
is it directs you directly
to your target destination.

00:25:16.500 --> 00:25:20.040
We just looked in a bit
of the future what's

00:25:20.040 --> 00:25:22.820
in store for navigation.

00:25:22.820 --> 00:25:25.320
And to talk a little bit more
about the bigger picture here,

00:25:25.320 --> 00:25:27.834
let me invite back Ian.

00:25:27.834 --> 00:25:33.133
[APPLAUSE]

00:25:33.133 --> 00:25:34.050
IAN LAKE: Thanks, Ben.

00:25:34.050 --> 00:25:36.780
I'm really excited about the
dynamic feature navigation,

00:25:36.780 --> 00:25:39.550
and looking forward to
seeing that later this year.

00:25:39.550 --> 00:25:41.190
But I wanted to talk
a little bit more

00:25:41.190 --> 00:25:44.400
generally about just where
we're going with navigation.

00:25:44.400 --> 00:25:49.110
I realized it took us a while to
get to that 1.0 stable release,

00:25:49.110 --> 00:25:51.600
but from now on
what we're trying

00:25:51.600 --> 00:25:54.730
to move towards is a much
faster iteration time.

00:25:54.730 --> 00:25:59.520
So the time between the first
alpha and the first release,

00:25:59.520 --> 00:26:01.740
to beta, to RC, to stable.

00:26:01.740 --> 00:26:04.200
We realized that not
everyone is happy

00:26:04.200 --> 00:26:07.920
using the latest alpha release.

00:26:07.920 --> 00:26:10.290
Sometimes, a little
bit of that stability--

00:26:10.290 --> 00:26:14.130
or at least the word, stable,
or the lack of the word, alpha--

00:26:14.130 --> 00:26:16.530
can really help
win over PMs, who

00:26:16.530 --> 00:26:20.570
aren't as familiar with what
alpha means for navigation.

00:26:20.570 --> 00:26:24.240
We're really trying to focus on
just a small set of features.

00:26:24.240 --> 00:26:26.260
What we talked about
today were the core

00:26:26.260 --> 00:26:28.710
of the features
in navigation 2.1.

00:26:28.710 --> 00:26:32.130
At this point we're saying,
no, let's cut it off here,

00:26:32.130 --> 00:26:35.020
and let's go towards
beta and RC and stable

00:26:35.020 --> 00:26:37.800
now, rather than
continuing to add features

00:26:37.800 --> 00:26:39.190
over and over again.

00:26:39.190 --> 00:26:42.600
But that doesn't mean that we're
not working on more things.

00:26:42.600 --> 00:26:45.210
There's certainly a lot
more-- the dynamic feature

00:26:45.210 --> 00:26:46.900
navigator is one thing.

00:26:46.900 --> 00:26:50.070
But we're also really
looking at your feedback.

00:26:50.070 --> 00:26:53.520
We have, and we use, the
issuetracker.google.com

00:26:53.520 --> 00:26:56.660
extensively, particularly
for navigation.

00:26:56.660 --> 00:26:59.310
And all these counts here are
actually the number of stars

00:26:59.310 --> 00:27:02.952
that you all have given
for navigation features.

00:27:02.952 --> 00:27:04.410
We can see, we've
done pretty good.

00:27:04.410 --> 00:27:06.660
We fixed a fair few of them.

00:27:06.660 --> 00:27:09.420
Some of these are actually
fixed in navigation 2.1,

00:27:09.420 --> 00:27:11.550
based on your feedback.

00:27:11.550 --> 00:27:13.680
But there's still
a few more to do.

00:27:13.680 --> 00:27:18.810
And if it's not in 2.1, it's
going to be in 2.2, or 2.3

00:27:18.810 --> 00:27:19.920
as we go through things.

00:27:19.920 --> 00:27:21.330
We realize some
of these things--

00:27:21.330 --> 00:27:25.020
like multiple backstacks--
are very highly requested.

00:27:25.020 --> 00:27:27.420
And they do mean that
we also need to work

00:27:27.420 --> 00:27:28.930
on the underlying library.

00:27:28.930 --> 00:27:30.838
So for example, that one--

00:27:30.838 --> 00:27:32.880
we should probably get
that working in fragments,

00:27:32.880 --> 00:27:34.830
and then working in
navigation, as well.

00:27:34.830 --> 00:27:37.240
That's certainly bigger efforts.

00:27:37.240 --> 00:27:39.570
But it's something that
we're dedicated to do,

00:27:39.570 --> 00:27:41.790
and something that
we think that would

00:27:41.790 --> 00:27:47.340
be great to have out to all
of you in the near future.

00:27:47.340 --> 00:27:49.110
I'd really like to continue.

00:27:49.110 --> 00:27:51.180
If you have more
feature requests,

00:27:51.180 --> 00:27:54.570
bug reports, anything,
please let us know.

00:27:54.570 --> 00:27:57.120
If we can find an
issue for it already,

00:27:57.120 --> 00:27:59.100
we're certainly happy
to look at that.

00:27:59.100 --> 00:28:02.730
But your stars really do drive
the future of navigation.

00:28:02.730 --> 00:28:09.380
[MUSIC PLAYING]

