WEBVTT
Kind: captions
Language: en

00:06:06.083 --> 00:06:08.083
In-app navigation:  Principals

00:06:15.463 --> 00:06:18.388
Principles and recommendations
Navigation:  Principles and 

00:06:18.389 --> 00:06:20.389
Recommendations.

00:20:23.071 --> 00:20:26.998
At this time please find your 
seat.  Our session will begin 

00:20:26.999 --> 00:20:28.999
soon.

00:23:28.020 --> 00:23:31.930
&gt;&gt; Good morning.  Thanks for 
getting up early to be here 

00:23:36.875 --> 00:23:38.875
with us even despite the fact 
that some 

00:23:40.167 --> 00:23:42.167
of our thunder may have been 
stolen by 

00:23:43.427 --> 00:23:45.661
the 3 or 4 presentations before 
this that demoed the navigation 

00:23:45.662 --> 00:23:48.339
editor.  We have time to go into
a little more 

00:23:52.251 --> 00:23:54.508
detail than any of the previous 
presentations so there's a lot 

00:23:54.509 --> 00:23:56.509
of good material here.

00:23:58.374 --> 00:24:00.374
I'm Lukas Bergstrom and with me 
I have 

00:24:04.137 --> 00:24:06.572
Ian and Sergey who built the 
navigation component.  

00:24:06.573 --> 00:24:09.420
Navigation if you think about it
is a prop that pretty much every

00:24:09.421 --> 00:24:13.296
app on Android has to solve but 
until now we haven't really 

00:24:13.297 --> 00:24:15.962
given you anything to do that 
with other than start activity 

00:24:17.373 --> 00:24:19.373
which for various reasons is not
the 

00:24:21.048 --> 00:24:23.048
best way to go about that.  

00:24:25.119 --> 00:24:26.960
So if you think about our job of
making Android development 

00:24:26.961 --> 00:24:28.961
easier, navigation 

00:24:31.965 --> 00:24:34.211
was a common problem with no 
real solution and that means 

00:24:34.212 --> 00:24:36.685
that there are a lot of things 
that you have to solve on your 

00:24:36.686 --> 00:24:38.686
own.

00:24:40.549 --> 00:24:43.005
And those range from how to 
commit fragment transactions, 

00:24:43.006 --> 00:24:45.006
hopefully without 

00:24:47.272 --> 00:24:48.930
throwing an exception, how to 
test the navigation is happening

00:24:48.931 --> 00:24:50.931
correctly and 

00:24:52.635 --> 00:24:54.635
that the right things are 
happening when 

00:24:56.918 --> 00:24:58.755
navigation occurs, how to map 
deep links to various places in 

00:24:58.756 --> 00:25:03.022
your app and how to deep those 
deep link schemes up to date as 

00:25:03.023 --> 00:25:05.023
your app navigational structure 
chaels.

00:25:07.519 --> 00:25:09.754
Passing arguments from place to 
place.  Again we don't give you 

00:25:09.755 --> 00:25:11.991
a type safe way to do that 
today.

00:25:15.275 --> 00:25:17.099
How to make sure that up and 
back take users to the right 

00:25:17.100 --> 00:25:19.558
places particularly in sort of 
more difficult situations 

00:25:23.020 --> 00:25:24.843
like someone deep linking deep 
into your app's navigation 

00:25:24.844 --> 00:25:26.844
hierarchy.

00:25:28.367 --> 00:25:30.212
And so what this means is by the
time you finish solving these 

00:25:30.213 --> 00:25:32.462
problems, you typically have 
gone 1 of 2 directions.

00:25:36.074 --> 00:25:37.097
You've either written 60% of a 
navigation framework or you've 

00:25:37.098 --> 00:25:39.098
got a lot 

00:25:42.181 --> 00:25:44.206
of error prone boilerplate 
everywhere a nave gags needs to 

00:25:44.207 --> 00:25:46.448
happen in your app.  You have a 
bunch of parallel lines in 

00:25:49.996 --> 00:25:51.627
your code involving these 
problems and the whole structure

00:25:51.628 --> 00:25:53.628
is very brittle.  Oh, sorry.

00:25:57.111 --> 00:25:59.959
And individually these problems 
are pretty tractible but if you 

00:25:59.960 --> 00:26:02.643
look at a real world example you
can see that they can get pretty

00:26:02.644 --> 00:26:04.644
hairy.

00:26:05.692 --> 00:26:07.692
So say that I have an item 
screen 

00:26:09.919 --> 00:26:11.919
saved in my app and

00:26:15.290 --> 00:26:17.572
it's accessible via deep link 
but if someone navigated to the 

00:26:17.573 --> 00:26:21.731
screen opening the app from the 
home screen they would have a 

00:26:21.732 --> 00:26:23.732
couple other screens on the back
stack.

00:26:26.236 --> 00:26:27.860
So hitting it up we want them to
take it not out of the app from 

00:26:27.861 --> 00:26:29.861
the screen, 

00:26:31.109 --> 00:26:33.145
we want them to go to the 
category screen and then the 

00:26:33.146 --> 00:26:35.788
home screen.  If someone deep 
links into the app we 

00:26:40.291 --> 00:26:42.291
need to synthesize these screens
and add 

00:26:43.341 --> 00:26:45.413
them to the up stack before 
showing the screen.  It's when 

00:26:45.414 --> 00:26:48.140
you're in the middle of writing 
the code to do this to 

00:26:50.377 --> 00:26:52.377
synthesize these screens and add
them to 

00:26:53.464 --> 00:26:55.497
the up and back stack but only 
on a deep link, that's when you 

00:26:55.498 --> 00:26:57.756
start to feel like maybe you're 
solving a failure of the 

00:26:59.182 --> 00:27:01.182
framework.

00:27:02.281 --> 00:27:05.546
So it helps all problems like 
that that we are launching 

00:27:05.547 --> 00:27:08.421
navigation.  What we are giving 
you us a visual 

00:27:11.701 --> 00:27:13.326
tool that let's you edit the 
navigation graph of your app 

00:27:13.327 --> 00:27:15.327
which is represented in XML.

00:27:18.849 --> 00:27:21.115
And that let's you define a set 
of available navigation actions,

00:27:21.116 --> 00:27:25.819
arguments you can pass from 
place to place, things like 

00:27:25.820 --> 00:27:28.475
visual transitions and a single 
navigate call activates all that

00:27:28.476 --> 00:27:30.476
at run time.  

00:27:33.182 --> 00:27:36.040
And so last but not least that 
means one thing you never have 

00:27:36.041 --> 00:27:38.041
to worry about 

00:27:39.856 --> 00:27:41.856
again is torching

00:27:43.826 --> 00:27:45.892
is touching a fragment 
transaction with your bare 

00:27:45.893 --> 00:27:48.955
hands.  [Applause]. 
So the navigation graph is 

00:27:48.956 --> 00:27:50.956
essentially 

00:27:52.014 --> 00:27:54.072
just a set of what are the 
possible destinations people can

00:27:54.073 --> 00:27:56.745
reach in my app and those 
usually correspond to screens 

00:27:57.959 --> 00:27:59.959
but not always.

00:28:01.634 --> 00:28:03.634
So you can have the navigation 

00:28:04.773 --> 00:28:06.773
controller just changing the 
contents of 

00:28:07.811 --> 00:28:10.687
a smaller part of the screen, 
but it's a set of navigation 

00:28:10.688 --> 00:28:13.557
destinations and the actions 
that link them.  And the actions

00:28:13.558 --> 00:28:15.558
really represent how you can get
from place to place.

00:28:18.253 --> 00:28:20.911
So to actually navigate from 
point A to point B in an app, 

00:28:20.912 --> 00:28:26.426
you're going to call the correct
navigation action at run time.  

00:28:29.484 --> 00:28:31.484
So let's look at what this looks
like 

00:28:32.535 --> 00:28:34.535
and let's switch over to the 
demo.  Okay.

00:28:36.593 --> 00:28:38.633
So what we see here is a set of 
navigation destinations and 

00:28:38.634 --> 00:28:42.695
these are fragment destinations 
although other options are 

00:28:42.696 --> 00:28:44.696
possible.

00:28:46.816 --> 00:28:50.473
And the lines connecting them 
are arrow heads are actions.  

00:28:50.474 --> 00:28:52.474
And those actions actually 
generate 

00:28:53.771 --> 00:28:55.771
methods you can call at run 
time.

00:28:57.852 --> 00:29:00.705
This whole thing is backed by 
XML as you all know and love.

00:29:03.787 --> 00:29:06.635
And the XML and the navigation 
editor have the same set of 

00:29:06.636 --> 00:29:08.636
capabilities so you can use 
either one.  

00:29:10.964 --> 00:29:13.001
We are going to add a screen 
here.  And what you're seeing is

00:29:13.002 --> 00:29:17.271
a set of available activities 
and fragments in my app.  Okay.

00:29:20.994 --> 00:29:22.456
So we just added an option for 
them to actually answer this 

00:29:22.457 --> 00:29:24.457
question successfully and win 
the game so now we 

00:29:27.951 --> 00:29:29.951
are going to add an action to 
navigate to that screen.

00:29:33.092 --> 00:29:38.023
Great.  And so that navigation 
action has a bunch of options 

00:29:38.024 --> 00:29:40.476
that you can set, obviously.  We
are going to talk about those a 

00:29:42.955 --> 00:29:47.443
little bit more.  For now we are
going to do one thing.  We are 

00:29:47.444 --> 00:29:50.101
going to say if they have gotten
to this congratulations screen, 

00:29:51.557 --> 00:29:54.214
that means the game is over.  So
hitting back shouldn't take them

00:29:56.990 --> 00:29:58.990
back into a game that no longer 
exists.

00:30:00.436 --> 00:30:02.436
So what that means is we want to
on 

00:30:06.427 --> 00:30:08.435
that action say let's pop to the
match screen and that means I'm 

00:30:08.436 --> 00:30:10.436
going to pop off everything on 
the back stack in 

00:30:13.742 --> 00:30:16.011
between this destination and the
match screen.  So when the user 

00:30:16.012 --> 00:30:18.012
gets to the congratulations 
screen, when they hit 

00:30:21.102 --> 00:30:24.784
back, they're just going to go 
straight to the match screen.  

00:30:24.785 --> 00:30:26.603
So a lot of other options I can 
set but I'll just talk about 

00:30:26.604 --> 00:30:29.481
that for now.  
Let's go back and look at the 

00:30:31.757 --> 00:30:33.757
congratulations screen again.

00:30:35.623 --> 00:30:37.856
One other thing to mention, the 
key thing that is set here is 

00:30:37.857 --> 00:30:39.857
the fragment class.

00:30:41.527 --> 00:30:43.527
And that's what is actually 
instantiated a run time.

00:30:46.462 --> 00:30:48.909
And we see layout previews here 
because the navigation editor 

00:30:48.910 --> 00:30:50.910
know 

00:30:52.391 --> 00:30:54.391
what's layout is associated with
that 

00:30:55.459 --> 00:30:57.292
navigation graph, because it 
knows, I can double click on 

00:30:57.293 --> 00:31:00.138
that fragment destination to get
here into the layout editor.

00:31:03.639 --> 00:31:06.281
Great.  And everything that I've
just done 

00:31:09.802 --> 00:31:11.634
here adding this new destination
to the navigation graph, an 

00:31:11.635 --> 00:31:16.141
action changing what the pop 
behavior of that action is, all 

00:31:16.142 --> 00:31:18.142
this stuff I can also do 
programatically at run time.

00:31:23.037 --> 00:31:25.037
So navigation editor, XML

00:31:26.977 --> 00:31:28.977
or programatic all work just 
fine.  Great. 

00:31:30.032 --> 00:31:32.673
And now I'm going to hand this 
off to Ian to walk you through 

00:31:32.674 --> 00:31:35.331
some more detail.  
&gt;&gt; IAN LAKE:  So the first 

00:31:35.332 --> 00:31:37.332
question that 

00:31:38.625 --> 00:31:40.625
might come to mind is wow this 
is a 

00:31:42.647 --> 00:31:43.971
totally new way of structuring 
the UI and it brings up this 

00:31:43.972 --> 00:31:45.972
question 

00:31:47.635 --> 00:31:51.132
immediately so what is my 
activity actually meant to do?  

00:31:51.133 --> 00:31:53.386
Every kind of app has a 
different starting point from 

00:31:53.387 --> 00:31:55.387
where you guys are 

00:31:58.477 --> 00:32:01.353
right now or maybe as of two 
days ago on how you kind of 

00:32:01.354 --> 00:32:04.399
struck your UI of your app.  
Some may be very activity heavy,

00:32:06.032 --> 00:32:08.032
fragment heavy, very much in a 
different system.

00:32:10.531 --> 00:32:12.153
All those are certainly valid 
places to be but we are moving 

00:32:12.154 --> 00:32:14.613
towards a model where the 
activity is more just an entry 

00:32:17.045 --> 00:32:19.510
point into your app rather than 
the activity being the owner of 

00:32:19.511 --> 00:32:21.511
the content 

00:32:23.233 --> 00:32:25.511
of your app it's actually just 
what is going to store that 

00:32:25.512 --> 00:32:27.512
global state.

00:32:30.639 --> 00:32:32.639
So the global navigationss, 
navigation 

00:32:34.297 --> 00:32:36.593
drawings, you're still using an 
action bore, those are things 

00:32:36.594 --> 00:32:38.594
that activities 

00:32:39.659 --> 00:32:41.659
manage but it delegates to what 
we call a nav host for content.

00:32:44.617 --> 00:32:46.617
So our nice super simple 
activity here.

00:32:51.601 --> 00:32:53.601
We have a action bar on the top,
a bottom nav on the bot.

00:32:56.368 --> 00:32:58.200
This is our nav host n the world
of navigation when you navigate 

00:32:58.201 --> 00:33:02.069
between different destinations 
in your app we are replacing 

00:33:02.070 --> 00:33:04.109
everything inside that box so 
you have that global navigation 

00:33:07.314 --> 00:33:09.314
outside of that and we have 
hooks that you can 

00:33:13.124 --> 00:33:16.399
hook that up to stay in sync 
with the actual nav host.  What 

00:33:16.400 --> 00:33:19.265
does a super simple version of 
this look like?  If you are 

00:33:19.266 --> 00:33:21.266
using fragment ors 

00:33:22.266 --> 00:33:24.266
destinations

00:33:25.801 --> 00:33:27.801
s you'll want to your our nav 
host 

00:33:28.816 --> 00:33:30.816
fragment

00:33:35.060 --> 00:33:37.923
.  You do this by including the 
navigation fragment dependency. 

00:33:37.924 --> 00:33:39.602
If you're using a totally 
different kind of destination it

00:33:39.603 --> 00:33:41.603
will probable I also have a 
different kind of nav host 

00:33:44.660 --> 00:33:49.841
that you add here.  But for now 
post fragment we set up a few 

00:33:49.842 --> 00:33:51.842
convenience methods.

00:33:52.900 --> 00:33:55.137
The ability to set what 
navigation graph you're using in

00:33:55.138 --> 00:33:58.607
XML so you don't need to do 
anything programatically to set 

00:33:58.608 --> 00:34:01.056
it up.  It will just go to the 
start 

00:34:04.737 --> 00:34:07.589
destination of your graph by 
default.  For fragments we can 

00:34:07.590 --> 00:34:10.663
hook this up to the system back 
button so we offer a method to 

00:34:10.664 --> 00:34:12.664
do exactly that.

00:34:14.544 --> 00:34:16.372
So you don't have to override on
that specifically for 

00:34:16.373 --> 00:34:18.373
navigation.

00:34:19.707 --> 00:34:21.538
We will hook up all that stuff 
using the magic of fragments 

00:34:21.539 --> 00:34:24.597
through this default nav host 
option. 

00:34:26.858 --> 00:34:29.101
That means that our activity 
actually gets to be two lines of

00:34:29.102 --> 00:34:31.102
code.

00:34:32.766 --> 00:34:35.215
It would be two lines but it 
doesn't fit horizontally on the 

00:34:35.216 --> 00:34:37.216
slide.

00:34:39.513 --> 00:34:41.513
But all we need to do is just 
inflate 

00:34:46.281 --> 00:34:48.281
our layout, set content view and
hook up the up button.

00:34:50.641 --> 00:34:52.260
Because you told us about this 
structure of your graph, in this

00:34:52.261 --> 00:34:54.261
case we 

00:34:55.673 --> 00:34:57.673
are using

00:35:01.100 --> 00:35:03.100
a column extension method that 
allows 

00:35:05.412 --> 00:35:08.875
us to find the navigation 
controller bypassing in the ID. 

00:35:08.876 --> 00:35:11.764
And that gives us access to 
navigate up.  And navigate up is

00:35:11.765 --> 00:35:16.471
going to do the right thing 
based on your navigation graph. 

00:35:16.472 --> 00:35:18.472
You done need to actually do a 
lot of 

00:35:19.906 --> 00:35:22.422
extra work't need to actually do
a lot of extra work here by 

00:35:22.423 --> 00:35:24.423
giving us your graph.  We are 
able to do this for you.

00:35:27.314 --> 00:35:29.026
But for most apps just having a 
single thing is not actually 

00:35:29.027 --> 00:35:31.868
what you have.  Maybe you have 
something a little bit more.  

00:35:35.759 --> 00:35:38.605
So we have kind of set up a 
second dependency, navigation-ui

00:35:38.606 --> 00:35:42.897
which is really just a set of 
static methods that connect your

00:35:42.898 --> 00:35:45.731
navigation component with some 
of the material design 

00:35:45.732 --> 00:35:47.732
components.

00:35:48.830 --> 00:35:50.830
Some of the things like bottom 
nav and 

00:35:51.961 --> 00:35:53.961
things that are very much in 
that global 

00:35:55.789 --> 00:35:57.789
navigation space but of course

00:36:00.218 --> 00:36:03.065
it's 2018 so we have KTX one 
that changes those static 

00:36:03.066 --> 00:36:05.066
methods into 

00:36:07.379 --> 00:36:09.379
extension methods so it's really
easy 

00:36:11.269 --> 00:36:13.291
for users to integrate to your 
app and have navigation feel 

00:36:13.292 --> 00:36:15.292
just like it's something that 
exists.  

00:36:19.054 --> 00:36:21.054
Of so what does this look likeSo
what does this look like?

00:36:22.746 --> 00:36:24.746
If we make our activity a little
bit 

00:36:25.794 --> 00:36:28.240
more complicated, add a Toolbar 
on the top and a bottom 

00:36:28.241 --> 00:36:33.331
navigation view.  We still have 
the same app menu that you had 

00:36:33.332 --> 00:36:35.332
before on a bottom navigation 

00:36:37.001 --> 00:36:38.219
view but what we do to hook 
those things up it takes two 

00:36:38.220 --> 00:36:43.706
parts.  One, your menu here is 
actually going to be using the 

00:36:43.707 --> 00:36:48.287
same ID's that you've had on 
each destination.  Each 

00:36:48.288 --> 00:36:50.288
destination has a unique ID and 

00:36:51.567 --> 00:36:53.567
we can use those same ID's on 
your menu items.

00:36:57.493 --> 00:37:00.130
So that build an implicit link 
of if you click the home menu 

00:37:00.131 --> 00:37:02.794
item you're going to go to the 
home destination of your app.

00:37:05.857 --> 00:37:07.747
In cold we are going to set up 
our action bore using our tool 

00:37:07.748 --> 00:37:09.748
bore.

00:37:10.822 --> 00:37:12.872
And we can do the same find nav 
controller to get our access to 

00:37:12.873 --> 00:37:14.873
the nav controller object.

00:37:17.655 --> 00:37:19.655
And then we just have a column 

00:37:20.911 --> 00:37:22.911
extension for activity that 
allows you 

00:37:24.002 --> 00:37:26.002
to set up bar with nav 
controller.

00:37:27.042 --> 00:37:29.042
This does quite a bit of magic.

00:37:31.666 --> 00:37:33.912
What it's doing is receiving 
events on when you navigated in 

00:37:33.913 --> 00:37:39.408
your nav controller and using 
the labels that you set up in 

00:37:39.409 --> 00:37:43.485
your navigation graph to update 
the title of your action bar.  

00:37:43.486 --> 00:37:45.314
We also have another helper 
method if you're using a drawer 

00:37:45.315 --> 00:37:50.054
layout to automatically change 
it from a hamburger button into 

00:37:50.055 --> 00:37:52.055
a back arrow based on what 
destination you're on. 

00:37:53.514 --> 00:37:55.514
Really those helpful patterns to
make 

00:37:58.613 --> 00:38:00.613
sure those things stay in sync. 

00:38:03.597 --> 00:38:06.059
Similarly for the bottom nav you
call set up and redo the two-way

00:38:06.060 --> 00:38:11.384
thinking here.  As you click on 
things in the bottom nav it will

00:38:11.385 --> 00:38:13.823
change the graph and do the 
correct transition based on the 

00:38:13.824 --> 00:38:19.109
material guidelines as well as 
as you navigate between your app

00:38:19.110 --> 00:38:21.110
if you have separate buttons it 
will update the selected item 

00:38:23.993 --> 00:38:25.993
in the bottom navigation.

00:38:30.550 --> 00:38:32.550
So this givers this gives us a 
lot of 

00:38:34.020 --> 00:38:35.450
power but not everyone is using 
prebuilt components that another

00:38:35.451 --> 00:38:38.323
team did.  You have your own 
custom UI.

00:38:41.376 --> 00:38:44.044
We have to go deeper into what 
nav controller actually gives 

00:38:44.045 --> 00:38:47.155
us.  You have a button, you want
it to go somewhere.

00:38:51.240 --> 00:38:54.710
We have the convenience method, 
create on click listener.  You 

00:38:54.711 --> 00:38:56.711
give it the ID of where you want

00:38:58.196 --> 00:38:59.830
it to go, what action you want 
it to trigger and we will do all

00:38:59.831 --> 00:39:02.511
the work for you.  This is 
perhaps a little too magical 

00:39:06.176 --> 00:39:08.176
so you can unroll it just a 
little bit.  

00:39:08.443 --> 00:39:09.500
In this case we are using 
another extension method on 

00:39:09.501 --> 00:39:11.501
view.

00:39:13.158 --> 00:39:15.158
So from any view that's been 
created 

00:39:16.618 --> 00:39:18.618
by nav controller, you can 
actually get 

00:39:19.869 --> 00:39:21.869
a reference to your nav 
controller just 

00:39:23.147 --> 00:39:25.147
by calling find nav controller 
as you 

00:39:27.287 --> 00:39:29.287
might expect and use that nav 
controller 

00:39:30.546 --> 00:39:32.775
to call navigate and just 
navigate to an ID of a 

00:39:32.776 --> 00:39:34.427
destination or an action in your
graph. 

00:39:34.428 --> 00:39:37.875
That's it.  Under the covers 
this navigate is actually doing 

00:39:37.876 --> 00:39:42.197
a lot of work.  So the nav 
controller is talking to what we

00:39:42.198 --> 00:39:44.198
call a Navigator.

00:39:45.409 --> 00:39:47.409
So

00:39:51.003 --> 00:39:56.119
So for fragments we are talking 
to a fragment Navigator.  It's 

00:39:56.120 --> 00:39:58.120
going to build all of the 
fragment transactions for you.

00:40:01.016 --> 00:40:03.866
It's going to do all the things 
you told us to do by putting 

00:40:03.867 --> 00:40:06.358
that information in your 
navigation graph.

00:40:11.273 --> 00:40:13.273
So if you have had pop up, it's 
going 

00:40:14.543 --> 00:40:16.774
to do all that stuff, 
transitions, all that in this 

00:40:16.775 --> 00:40:18.775
one line of code.

00:40:20.077 --> 00:40:21.496
All of it can be either 
programatically or something 

00:40:21.497 --> 00:40:23.497
that you 

00:40:24.594 --> 00:40:26.594
determine ahead of time as part 
of your navigation graph.  

00:40:28.467 --> 00:40:30.467
But for a lot of these kinds of 
places 

00:40:31.716 --> 00:40:34.187
it's not actually just a 
navigate.  You have some 

00:40:34.188 --> 00:40:36.188
information to pass to the next 
source.

00:40:37.675 --> 00:40:39.675
So for this we need to pass a 
bundle of information.

00:40:43.218 --> 00:40:45.896
Here we are passing a string and
an int and using our nice 

00:40:45.897 --> 00:40:47.897
helpful bundle 

00:40:48.899 --> 00:40:51.222
from AndroidKtx and it works.  
It's fine.

00:40:54.492 --> 00:40:56.492
This is really useful for a lot 
of 

00:40:57.764 --> 00:40:59.764
things but at the same point 
it's not very safe.

00:41:01.029 --> 00:41:04.128
If you do a miss type here, what
are you going to do?  We want to

00:41:04.129 --> 00:41:05.547
make this a lot easier so we 
will talk about what we did 

00:41:05.548 --> 00:41:07.548
here. 

00:41:12.106 --> 00:41:15.783
&gt;&gt; We build something called 
safe Args Gradle plugin.  First 

00:41:15.784 --> 00:41:18.213
let's see what they're trying to
resolve.  Let's go back to our 

00:41:18.214 --> 00:41:20.214
sample.

00:41:22.939 --> 00:41:24.939
Our fragment where we tried to 
negate 

00:41:28.309 --> 00:41:30.309
actually requires us the best 
screen name argument.

00:41:32.584 --> 00:41:34.608
Best category which has integer 
type.  Let's go back to the 

00:41:34.609 --> 00:41:37.071
calling site.  Well in our 
slides we made everything 

00:41:37.473 --> 00:41:39.473
correctly.

00:41:41.092 --> 00:41:43.092
We passed

00:41:45.370 --> 00:41:47.370
screen, but actually

00:41:50.531 --> 00:41:52.372
you can forget the best screen 
name.  It's a result in run time

00:41:52.373 --> 00:41:54.373
exception.

00:41:55.860 --> 00:41:57.860
It's super easy to fix but it's 
still 

00:41:58.879 --> 00:42:02.846
annoying.  I don't know.  Okay.

00:42:08.413 --> 00:42:10.413
Now we have this navigation 
graph.

00:42:12.682 --> 00:42:14.106
Let's put all our navigation 
there including the arguments 

00:42:14.107 --> 00:42:16.107
for destinations.

00:42:18.584 --> 00:42:20.584
Let's see how it looks in XML.  
And super simple.

00:42:24.508 --> 00:42:26.508
We just specify your argument 
name, 

00:42:27.714 --> 00:42:29.714
its type

00:42:34.112 --> 00:42:36.365
.  And this allows us to build 
two links that once you have an 

00:42:36.366 --> 00:42:38.366
action that lists 

00:42:42.094 --> 00:42:44.094
to this fragment or other action
or 

00:42:47.631 --> 00:42:49.631
activity, we can check and make 
the best proper argument also.

00:42:52.904 --> 00:42:54.369
So let's take a look at how its.
So let's take a look at how it 

00:42:54.370 --> 00:42:57.216
looks. 
Now we use this special object 

00:42:57.217 --> 00:42:59.217
which 

00:43:01.500 --> 00:43:04.137
instead of passing ID in a 
bundle, of course internally the

00:43:04.138 --> 00:43:06.179
subject incorporates the same ID
and same 

00:43:09.846 --> 00:43:11.846
arguments but to get this object
we use 

00:43:13.301 --> 00:43:15.301
home fragment direction class, 
it's generated for you.

00:43:21.033 --> 00:43:24.361
It's just a fragment name plus 
static directions.  It has 

00:43:24.362 --> 00:43:26.362
static methods for this 
destination.

00:43:30.230 --> 00:43:32.230
And those static methods may 
have required arguments.

00:43:35.564 --> 00:43:37.564
In our case it makes us the best
home 

00:43:39.242 --> 00:43:41.242
argument there and later it can 
set up 

00:43:42.304 --> 00:43:44.602
your other additional arguments.
And then everything is type 

00:43:44.603 --> 00:43:49.482
safe. 
And after that it's super 

00:43:49.483 --> 00:43:51.483
simple.

00:43:52.693 --> 00:43:54.693
You have

00:43:56.703 --> 00:43:58.703
this, it's Args class.

00:44:00.570 --> 00:44:02.570
For our case is help fragment 
Args.

00:44:03.838 --> 00:44:05.475
And it's all your arguments that
you defined in a type set 

00:44:05.476 --> 00:44:07.476
manner.

00:44:09.392 --> 00:44:11.392
And for this small improvement 
we go 

00:44:14.693 --> 00:44:15.493
to the bigger one which is deep 
links.  

00:44:15.494 --> 00:44:20.650
&gt;&gt; IAN LAKE:  Yes.  Deep links 
are traditionally something that

00:44:20.651 --> 00:44:22.680
Android has supported for a long
time.

00:44:26.961 --> 00:44:29.637
You can take over a web URL, as 
well as deep linking a super 

00:44:29.638 --> 00:44:32.118
useful for notifications and 
things like that to link back 

00:44:32.119 --> 00:44:34.119
into your app.

00:44:35.615 --> 00:44:37.869
But it gets a lot more 
complicated as you get a more 

00:44:37.870 --> 00:44:40.108
complicated app like how you 
structure these things and how 

00:44:40.109 --> 00:44:44.860
you say all right I need to 
build a notification, what is 

00:44:44.861 --> 00:44:48.926
all of the code that is needed 
to actually get into the correct

00:44:48.927 --> 00:44:50.927
place in my app and pass the 
right kind of information here?

00:44:54.676 --> 00:44:56.676
So for navigation we really made
deep 

00:44:58.558 --> 00:45:00.558
linking a kind of class citizen 
in our structure.  

00:45:02.420 --> 00:45:04.420
So there's really two kinds of 
deep links.

00:45:06.488 --> 00:45:08.488
The explicit kind, these are the

00:45:09.764 --> 00:45:11.764
things like for notifications, 
app 

00:45:13.035 --> 00:45:15.035
shortcuts, app widgets tan new 
actions and slices.

00:45:16.902 --> 00:45:21.420
Things that you create and are 
usually pending and tent based. 

00:45:21.421 --> 00:45:23.421
These are things you're passing 
to 

00:45:24.905 --> 00:45:27.159
another app or system to say I 
want to go to this specific 

00:45:27.160 --> 00:45:29.196
place in my app.  The implicit 
side of things are more 

00:45:33.620 --> 00:45:37.389
around the web URLs and custom 
scheme URLs.  These are the 

00:45:37.390 --> 00:45:40.263
other apps triggering your app 
to launch.  We handle both of 

00:45:40.264 --> 00:45:45.576
these for navigation.  
For explicit deep links we have 

00:45:45.577 --> 00:45:47.577
nav deep 

00:45:52.127 --> 00:45:53.359
link builder and its sole goal 
in life is to deep link to a 

00:45:53.360 --> 00:45:59.306
specific destination in your 
navigation graph by its ID.  

00:45:59.307 --> 00:46:01.953
It's easy to say but a little 
bit harder to make sure that all

00:46:01.954 --> 00:46:03.954
works in the system. 

00:46:05.413 --> 00:46:07.064
But if we create a nav deep link
builder, you create it with 

00:46:07.065 --> 00:46:10.730
context, give it your graph, 
destination, any arguments you 

00:46:10.731 --> 00:46:12.731
have, and then you can 

00:46:13.764 --> 00:46:15.764
just

00:46:19.362 --> 00:46:22.211
call create pending intent.  We 
are doing all the work to create

00:46:22.212 --> 00:46:26.737
it within your graph and your 
parent activities as well.  And 

00:46:26.738 --> 00:46:29.202
we are going to pass that along 
and create the correct intent 

00:46:29.203 --> 00:46:32.112
that gives you to the right 
place when you trigger this 

00:46:32.113 --> 00:46:36.457
intent.  And then you just pass 
it through to your notification.

00:46:38.292 --> 00:46:40.118
You don't actually need to do 
more than this to get all the 

00:46:40.119 --> 00:46:45.421
correct behavior.  
For implicit deep links these 

00:46:45.422 --> 00:46:50.558
are again links to web URLs.  So
in this case instead of it being

00:46:52.402 --> 00:46:54.028
something that you create 
programatically it's information

00:46:54.029 --> 00:46:59.328
you include in your navigation 
graph.  So here we are adding a 

00:46:59.329 --> 00:47:01.329
deep link 

00:47:02.990 --> 00:47:04.415
element just like we added the 
arguments and actions to our 

00:47:04.416 --> 00:47:07.891
graph, these are just a deep 
link.  And of course all of this

00:47:07.892 --> 00:47:10.787
individual editor as part of the
products for a destination. 

00:47:15.622 --> 00:47:17.780
And it's really just as simple 
as an app on your URI.

00:47:22.616 --> 00:47:25.158
This is a static URI which is 
boring and dumb.

00:47:28.447 --> 00:47:30.447
So we of course support some 
wild cards.

00:47:32.101 --> 00:47:34.101
So if you want to do a dot star 
for a 

00:47:35.105 --> 00:47:39.672
wild for a wild card, totally 
supported.  If you wanted to 

00:47:39.673 --> 00:47:41.673
fill in the argument 

00:47:43.979 --> 00:47:45.979
for your destination you can use
curly 

00:47:49.089 --> 00:47:51.089
braces and we will parse the URL
for you 

00:47:52.789 --> 00:47:55.636
and extract those values and 
give them to you.  Now you can 

00:47:55.637 --> 00:47:57.637
get those directly from 

00:47:59.094 --> 00:48:00.962
your URL and not have to reparse
things like you already know 

00:48:00.963 --> 00:48:02.963
what this is 

00:48:03.972 --> 00:48:05.119
suppose.  Like, you already know
what this is supposed to be.  

00:48:05.120 --> 00:48:07.120
Similarly you can combine the 
two.

00:48:11.452 --> 00:48:13.452
If you want the make more 
complicated patterns, you can.

00:48:15.549 --> 00:48:18.191
We also have auto verify.  We 
wanted to make sure that you can

00:48:18.192 --> 00:48:20.489
do the same kind of thing if 
you're using navigation as well.

00:48:26.186 --> 00:48:28.186
And note here that we left off 
the 

00:48:29.191 --> 00:48:31.701
HTTP, HTTPS.  Here we are doing 
both.

00:48:36.382 --> 00:48:38.382
We are saying HTTP, HTTPS.

00:48:40.650 --> 00:48:42.650
You can't really control the 
URLs that 

00:48:45.551 --> 00:48:47.988
other apps -- maybe they 
accidently took the S off your 

00:48:47.989 --> 00:48:50.029
URL but we still want to support
both of those just as a 

00:48:52.467 --> 00:48:54.467
convenience method instead of 
having two lines. 

00:48:54.710 --> 00:48:57.379
And of course it also works with
custom schemes.  So if you have 

00:48:57.380 --> 00:48:59.380
your own scheme, they 

00:49:01.043 --> 00:49:03.917
use set ups specifically for 
your app, you can also attach 

00:49:03.918 --> 00:49:05.918
those to deep links.  

00:49:07.984 --> 00:49:09.984
Now the best part is we kind of 
worked 

00:49:12.691 --> 00:49:13.910
across the tool space so besides
just the navigation editor we 

00:49:13.911 --> 00:49:15.911
also worked 

00:49:17.791 --> 00:49:20.679
with the manifest merger team.  
You can add a single nav graph 

00:49:20.680 --> 00:49:22.680
element 

00:49:23.699 --> 00:49:25.517
to your activity in your 
manifest pointing to your graph 

00:49:25.518 --> 00:49:29.834
and all the deep links in that 
graph will then get expanded out

00:49:29.835 --> 00:49:31.835
to be the correct intent filter.
We'll build all those for you.

00:49:35.374 --> 00:49:37.374
And if you go to the manifest 
merger 

00:49:38.590 --> 00:49:40.590
view in

00:49:42.729 --> 00:49:45.215
in Android Studio you see the 
exact line.  So this means that 

00:49:45.216 --> 00:49:47.449
we now have a single source of 
truth in your 

00:49:51.113 --> 00:49:53.113
navigation graph that you know 
this is 

00:49:55.592 --> 00:49:57.214
not going to get out of out of 
sync with what you expect, it's 

00:49:57.215 --> 00:49:59.215
not going to get 

00:50:00.446 --> 00:50:01.907
out have sync when you change 
your argument names and XML 

00:50:01.908 --> 00:50:06.001
file.  This is one central place
to do things and we think it's a

00:50:06.002 --> 00:50:08.002
lot easier for 

00:50:09.043 --> 00:50:11.043
basically all of the implicit 
deep link kind of cases. 

00:50:12.298 --> 00:50:14.298
Of course we do do things where 
this is 

00:50:16.588 --> 00:50:22.336
all action view URLs as they 
would be for web URLs.  You can 

00:50:22.337 --> 00:50:25.401
see it added directly to the 
line.  If you have multiple of 

00:50:25.402 --> 00:50:29.685
them it will tell you what line,
if you have multiple graphs 

00:50:29.686 --> 00:50:32.598
associated with different 
activities those will all work 

00:50:32.599 --> 00:50:36.476
just fine.  
So one of the other subjects 

00:50:36.477 --> 00:50:38.477
that is 

00:50:40.097 --> 00:50:43.030
really important to all of our 
architecture component is 

00:50:43.656 --> 00:50:45.656
testing.

00:50:46.750 --> 00:50:48.190
Testing navigation is very hard 
and this is something that we 

00:50:48.191 --> 00:50:53.127
are going to continue to look at
over the alpha period.  We 

00:50:53.128 --> 00:50:56.643
really want all of your feedback
as well.  But I wanted to 

00:50:56.644 --> 00:50:59.078
discuss what we think testing in
a navigation world should look 

00:50:59.079 --> 00:51:01.079
like.  

00:51:04.974 --> 00:51:06.974
So a lot of it is if all of the 
links 

00:51:09.896 --> 00:51:11.896
between your destinations are 
through 

00:51:13.654 --> 00:51:15.654
navigation, then it's a lot 
easier to 

00:51:16.939 --> 00:51:18.939
test a destination in isolation.

00:51:20.812 --> 00:51:23.675
You can test each destination by
itself and then test just the 

00:51:23.676 --> 00:51:25.676
out going 

00:51:26.732 --> 00:51:29.654
edges or the incoming arguments 
and not have to deal with oh did

00:51:29.655 --> 00:51:33.745
it actually do the right 
fragment transaction?  Because 

00:51:33.746 --> 00:51:38.262
we could test that just at the 
navigation controller level.  So

00:51:38.263 --> 00:51:41.130
this is something that we are 
going to spend a lot more time 

00:51:41.131 --> 00:51:43.131
on and in the fragment talk 
yesterday we actually 

00:51:45.616 --> 00:51:47.447
talked about really trying to 
make fragments themselves much 

00:51:47.448 --> 00:51:51.778
more testable in isolation so 
it's kind of a package deal 

00:51:51.779 --> 00:51:53.779
where we are trying to build 

00:51:55.875 --> 00:51:57.875
testing into navigation 
controller and 

00:51:58.959 --> 00:52:00.959
also trying to build testable 
destinations as well. 

00:52:00.990 --> 00:52:02.990
So you might be interested to do
something right now.

00:52:05.620 --> 00:52:07.620
So

00:52:11.403 --> 00:52:13.241
if you want to test, oh when I 
navigate to something, does it 

00:52:13.242 --> 00:52:15.242
go to the right place?

00:52:19.360 --> 00:52:21.360
We actually have a ad on 
navigation list inner.

00:52:27.805 --> 00:52:29.805
You can get a call back of oh 
did you 

00:52:31.063 --> 00:52:33.063
go to the right place when I 
clicked this button.

00:52:35.360 --> 00:52:37.590
This is one method we found 
successful in testing things 

00:52:37.591 --> 00:52:39.591
completely black box outside of 
things.

00:52:41.862 --> 00:52:43.862
If you want to inject a nav 
controller 

00:52:45.319 --> 00:52:47.596
or use any other method those 
are also valid ways of kind of 

00:52:47.597 --> 00:52:50.041
setting things up. 
So what can you play with today?

00:52:56.780 --> 00:52:59.916
What can you play with -- you 
must have looked at it, right?  

00:52:59.917 --> 00:53:06.241
It is in alpha right now.  1.00 
alpha 01.  Giving ourselves a 

00:53:06.242 --> 00:53:08.242
long runway of bug fixes and 
improvements here.

00:53:12.295 --> 00:53:14.820
And it really comes down to two 
main artifacts, the navigation 

00:53:16.448 --> 00:53:18.448
fragment which includes the 
navigation 

00:53:20.511 --> 00:53:22.946
run time dependency as a 
transitive dependency and also 

00:53:22.947 --> 00:53:25.207
the nav host fragment and fract 
Navigator that you 

00:53:29.926 --> 00:53:31.926
need to use destinations.

00:53:34.009 --> 00:53:36.009
And for every one of the 
dependencies 

00:53:37.893 --> 00:53:39.893
for navigation, we have a dash 
KTX version of them.

00:53:44.607 --> 00:53:47.077
So we really tried to make Colin
a first class citizen, 

00:53:47.078 --> 00:53:51.353
especially if you are doing 
programmatic graph construction 

00:53:51.354 --> 00:53:54.003
like say you're reading your 
whole navigation graph from a 

00:53:57.424 --> 00:53:59.424
server we have

00:54:00.655 --> 00:54:02.655
a call a call in DSL.

00:54:05.811 --> 00:54:07.811
So there's more

00:54:08.965 --> 00:54:10.965
to do and I'll have Lukas talk 
about where we go. 

00:54:12.665 --> 00:54:14.665
&gt;&gt; LUKAS BERGSTROM:  Are are 
going to 

00:54:17.795 --> 00:54:20.854
need and troid studio preview 
canary 3.14.  Please do download

00:54:20.855 --> 00:54:25.533
it and try it out.  There's a 
lot of great stuff there.  This 

00:54:25.534 --> 00:54:27.599
is obviously going to become a 
really core part of not just 

00:54:31.624 --> 00:54:34.520
architecture components but 
jetpack overall.

00:54:39.014 --> 00:54:41.014
We took a blank sheet of paper, 
what 

00:54:43.672 --> 00:54:45.672
do we want the and Droid

00:54:47.640 --> 00:54:50.483
the Android developer experience
to be.  Creating a new project 

00:54:50.484 --> 00:54:52.484
in Android 

00:54:54.158 --> 00:54:56.408
Studio is going to by default 
start you up in the nav editor 

00:54:56.409 --> 00:54:58.409
and it should be a pretty great 
world.  

00:55:00.914 --> 00:55:02.914
And jetpack is available for you
to try right now.

00:55:06.845 --> 00:55:09.715
It's right now it's sort of got 
a much nicer introduction to 

00:55:09.716 --> 00:55:11.716
what all the key 

00:55:12.797 --> 00:55:14.797
pieces of Android development 
are so 

00:55:17.289 --> 00:55:19.143
it's a much easier on ramp and 
we are looking forward to 

00:55:19.144 --> 00:55:23.428
expanding this story over time. 
There are more talks for you to 

00:55:23.429 --> 00:55:25.429
go to.

00:55:28.560 --> 00:55:30.560
A lot more detail on AndroidKtx 
and paging.

00:55:32.216 --> 00:55:34.216
Paging in particular is a really
cool 

00:55:36.516 --> 00:55:37.952
deep library that does a lot for
you by tieing together different

00:55:37.953 --> 00:55:39.953
pieces of 

00:55:41.016 --> 00:55:43.858
architecture component and 
jetpack.  If you ever have a 

00:55:43.859 --> 00:55:45.859
list view with more 

00:55:46.912 --> 00:55:49.195
stuff than you can hold in 
memory at any given time you 

00:55:49.196 --> 00:55:51.259
really want to go to this 
pageing talk.  

00:55:52.899 --> 00:55:55.144
And we want your feedback.  We 
want your feedback on this 

00:55:55.145 --> 00:55:59.451
session, first of all but more 
importantly we want your 

00:55:59.452 --> 00:56:01.893
feedback on the navigation 
component.  The reason that we 

00:56:01.894 --> 00:56:04.336
are launching to alpha is not 
because we think that this 

00:56:08.046 --> 00:56:10.685
is sort of really untested and 
untried.  We have done a lot of 

00:56:10.686 --> 00:56:12.686
prerelease testing of this.

00:56:14.159 --> 00:56:16.826
But we are launching it to alpha
because we want to get a lot of 

00:56:16.827 --> 00:56:18.827
feedback 

00:56:20.518 --> 00:56:22.170
from the community before we 
lock down on the API and switch 

00:56:22.171 --> 00:56:24.171
over the beta.

00:56:25.231 --> 00:56:27.900
This is a great time for to you 
try it out, tell us what works 

00:56:27.901 --> 00:56:29.901
for us, tell us what doesn't.

00:56:31.381 --> 00:56:32.819
Either communicate with us 
directly or on our publication 

00:56:32.820 --> 00:56:37.508
tracker.  We would love to hear 
from your.  Your feedback has 

00:56:37.509 --> 00:56:41.446
been critical in every point of 
this journey in making sure we 

00:56:41.447 --> 00:56:43.272
are attacking the right problems
at the right solutions so please

00:56:43.273 --> 00:56:46.941
do try it out and tell us what 
you think.  

00:56:47.361 --> 00:56:50.563
Thank you.  
[Applause]

00:57:10.778 --> 00:57:12.778
.                          

00:57:28.072 --> 00:57:30.306
(Standing by).

00:58:45.690 --> 00:58:47.729
.
&gt;&gt; Thank you for joining this 

00:58:47.730 --> 00:58:49.730
session.

00:58:54.484 --> 00:58:56.927
Grand Am bass doors will assist 
you guiding you through the 

00:58:56.928 --> 00:59:00.609
exits.  If you've registered for
the next session in this room we

00:59:00.610 --> 00:59:03.673
ask that you clear the room and 
return via the registration line

00:59:03.674 --> 00:59:08.569
outside.  Thank you.   

00:59:23.937 --> 00:59:24.763
.  
.  

00:59:24.764 --> 00:59:25.802
.  
.  

00:59:25.803 --> 00:59:27.022
.  
.  

00:59:27.023 --> 00:59:29.023
.  
.

00:59:38.616 --> 00:59:40.616
" Real time caption

00:59:45.185 --> 00:59:47.185
Realtime captioning on this

00:59:49.283 --> 00:59:51.564
screen" Realtime captioning on 
this screen" .

01:00:12.793 --> 01:00:14.793
.  
.

01:00:22.867 --> 01:00:24.867
What's now in Android security.

01:00:30.061 --> 01:00:32.512
New in Android Security.   

01:16:37.144 --> 01:16:39.144
 .

01:16:40.358 --> 01:16:41.246
&gt;&gt; Welcome.  Please fill in the 
seats near the front of the 

01:16:41.247 --> 01:16:43.247
room.  Thank you.

01:16:46.145 --> 01:16:50.145
&gt;&gt; Welcome.  Please fill in the 
seats near the front of the 

01:16:46.145 --> 01:16:48.145
room.  Thank you.

01:19:33.781 --> 01:19:35.606
.
&gt;&gt; At this time please find your

01:19:35.607 --> 01:19:40.280
seat.  Our session will begin 
soon.    

01:19:40.281 --> 01:19:44.414
&gt;&gt; At this time please find your
seat.  Our session will begin 

01:19:40.281 --> 01:19:42.281
soon.

01:22:41.242 --> 01:22:43.242
and 

01:22:45.965 --> 01:22:48.825
welcome to the Android P edition
of what is new in Android 

01:22:48.826 --> 01:22:52.890
security.  My name is Dave.  In 
a few minutes I'll hand over to 

01:22:56.523 --> 01:22:59.221
Xiaowen who is the lead security
product manager for the Android 

01:22:59.222 --> 01:23:03.379
platform.  We have a lot of 
ground to cover so we will start

01:23:03.380 --> 01:23:05.613
with a brief state of the union 
on Android security and jump 

01:23:05.614 --> 01:23:08.471
into all the really cool things 
we have been 

01:23:11.882 --> 01:23:13.882
working on Android security over
the 

01:23:15.312 --> 01:23:17.312
past year and launching here at 
Android 

01:23:19.859 --> 01:23:23.123
P including secure hardware 
support, integrity and privacy. 

01:23:23.124 --> 01:23:25.124
State of the union, let's talk a

01:23:26.134 --> 01:23:28.824
little bit about what the 
Android security strategy looks 

01:23:28.825 --> 01:23:31.670
like.  There are three main 
pillars.

01:23:36.657 --> 01:23:38.657
First, Google play protect.

01:23:39.869 --> 01:23:43.823
This is the malware and security
services.  The second is 

01:23:43.824 --> 01:23:45.824
platform engineering.

01:23:48.103 --> 01:23:50.103
These are the corp operating 
system 

01:23:51.562 --> 01:23:53.562
defenses that we built into 
Android to 

01:23:55.581 --> 01:23:57.581
improve security systems such

01:23:59.726 --> 01:24:01.726
as SE Linux, encryption, lots of
other features.

01:24:03.593 --> 01:24:08.903
The third pillar is the security
development life cycle.  These 

01:24:08.904 --> 01:24:10.904
are all the programs we put in 

01:24:12.621 --> 01:24:15.511
place to ensure a consistent 
high quality level for security 

01:24:15.512 --> 01:24:17.512
across the Android ecosystem.

01:24:19.566 --> 01:24:21.393
Things like testing 
infrastructure, also includes 

01:24:21.394 --> 01:24:23.634
our security patching programs. 
We have been working really hard

01:24:23.635 --> 01:24:26.904
on that. 
A couple of things, we have been

01:24:26.905 --> 01:24:28.905
trying 

01:24:31.045 --> 01:24:33.045
to make Android just easier to 
patch.

01:24:37.362 --> 01:24:39.362
Google, we have a pretty steady 
track 

01:24:41.230 --> 01:24:43.230
record delivering those patches 
to market.

01:24:45.714 --> 01:24:47.714
And so making Android more 
modular 

01:24:49.416 --> 01:24:52.893
with projects like treble really
help contribute to that.  We 

01:24:52.894 --> 01:24:55.778
also head on working security 
patching into our OEM 

01:24:55.779 --> 01:24:58.425
agreements.  This will really be
a massive lead to 

01:25:03.113 --> 01:25:05.113
a massive increase in a number 
of 

01:25:06.755 --> 01:25:09.025
devices and users receiving 
regular security patches so we 

01:25:09.026 --> 01:25:11.026
are excited about that. 

01:25:12.888 --> 01:25:14.157
But there are a couple of 
philosophical Principles that 

01:25:14.158 --> 01:25:16.158
underlie everything we do when 
it comes to security.

01:25:18.646 --> 01:25:20.646
We believe in transparency and 

01:25:22.127 --> 01:25:24.562
openness because that breeds 
confidence and it breeds trust.

01:25:28.018 --> 01:25:30.477
Conversely a closed platform, 
secrecy, that breeds distrust 

01:25:30.478 --> 01:25:34.349
but there's a really important 
security advantage to being 

01:25:34.350 --> 01:25:39.445
open.  Today's model devices are
faced with really sophisticated 

01:25:39.446 --> 01:25:42.090
attack threats.  When you have 
billions of users it's 

01:25:45.345 --> 01:25:45.953
an attractive target so it 
deserves the strongest possible 

01:25:45.954 --> 01:25:47.954
defense.

01:25:50.442 --> 01:25:52.442
With a closed platform the 
defenders 

01:25:55.142 --> 01:25:57.142
are the employees of the ones 
that own the platform.

01:25:58.648 --> 01:26:00.648
We have thousands of owners 
waking up 

01:26:01.937 --> 01:26:04.576
every morning thinking of how to
best protect us, we have 

01:26:04.577 --> 01:26:06.577
security teams who 

01:26:08.040 --> 01:26:10.040
work closely with Google on 
protecting 

01:26:13.043 --> 01:26:15.043
Android and its users.  We have 
security teams helping to 

01:26:15.088 --> 01:26:17.088
protect Android.

01:26:18.362 --> 01:26:20.362
We have the worldwide open 
source 

01:26:21.460 --> 01:26:25.131
Linux community contributing to 
Android security every day.  We 

01:26:25.132 --> 01:26:27.981
have the academic research 
community which prefer working 

01:26:27.982 --> 01:26:29.982
on open platforms. 

01:26:32.060 --> 01:26:34.060
So this is a mass force 
multiplier in protection.

01:26:35.565 --> 01:26:37.565
As operating systems have 
matured, the 

01:26:39.421 --> 01:26:41.259
power of open has become evident
to the point where today the 

01:26:41.260 --> 01:26:43.260
protective 

01:26:44.966 --> 01:26:47.000
capabilities of Android are now 
on par with any other global 

01:26:47.001 --> 01:26:51.469
platform and I believe the power
of open will accelerate those 

01:26:51.470 --> 01:26:54.949
protective capabilities for our 
users going forward.  The other 

01:26:54.950 --> 01:26:57.018
really important philosophy that
underlies our strategy is 

01:26:58.663 --> 01:27:03.580
measurability.  We always look 
for objective independent 

01:27:03.581 --> 01:27:05.836
measurements to help not only 
inform the work we do to insure 

01:27:05.837 --> 01:27:09.099
we are investing in the right 
directions but also to measure 

01:27:09.100 --> 01:27:14.438
progress.  So one example you 
see here is the incidence of 

01:27:14.439 --> 01:27:16.439
malware or potentially 

01:27:18.336 --> 01:27:20.336
harmful applications we call PHA
on devices.

01:27:21.411 --> 01:27:23.411
The bottom curve are devices 
that load 

01:27:26.046 --> 01:27:28.280
only from play, and the top 
curve are devices that load from

01:27:28.281 --> 01:27:30.333
sources other than play.  You 
can see over time it has been 

01:27:32.977 --> 01:27:35.023
reducing across all users so we 
are committed to protecting 

01:27:35.024 --> 01:27:37.260
users regardless of where they 
get their applications from.

01:27:40.511 --> 01:27:41.309
But this is due, this 
improvement is due to many 

01:27:41.310 --> 01:27:44.777
things. 
It's locking down APIs and 

01:27:44.778 --> 01:27:47.004
permissions over time or 
constantly looking at that 

01:27:50.281 --> 01:27:52.281
and investing in the malware 
detection engine itself.

01:27:54.995 --> 01:27:57.299
Today 60% of malware is detected
through Machine Learning and 

01:27:57.300 --> 01:27:59.948
that's one area of a big 
investment for us. 

01:28:04.671 --> 01:28:06.671
Over the past year we had a 50% 

01:28:07.775 --> 01:28:09.038
reduction of PHA on play.  We 
are happy with the progress but 

01:28:09.039 --> 01:28:14.154
we are not content with where we
stand today.  Although I would 

01:28:14.155 --> 01:28:18.633
say the odds of loading a PHA 
from play business the same as 

01:28:18.634 --> 01:28:20.634
being struck from lightning so 

01:28:22.709 --> 01:28:24.951
it is a safe place to live on 
your mobile life while we are 

01:28:24.952 --> 01:28:27.193
going to continue to invest 
tremendously in this area. 

01:28:29.218 --> 01:28:31.468
Another really important 
measurement is the overall 

01:28:31.469 --> 01:28:33.897
ability of the operating system 
to protect itself against 

01:28:34.103 --> 01:28:36.103
exploitation.

01:28:38.382 --> 01:28:41.039
In any complex product there are
going to be bugs but there's no 

01:28:41.040 --> 01:28:45.924
reason why bugs have to lead to 
exploitation to harm users so we

01:28:45.925 --> 01:28:48.371
worked hard on building features
and improvements that make 

01:28:49.791 --> 01:28:52.686
Android much more difficult and 
expensive to exploit.  

01:28:54.328 --> 01:28:56.328
How do you measure how well 
you're doing?

01:28:59.000 --> 01:29:01.000
Well, lots of people want to 
purchase exploits.

01:29:02.278 --> 01:29:06.445
There's a vibrant market for 
that.  As exploits get more 

01:29:06.446 --> 01:29:09.548
difficult the law of supply and 
demand, the prices are going to 

01:29:09.549 --> 01:29:15.246
go up.  We watch the pricing 
over time and there's a number 

01:29:15.247 --> 01:29:17.247
of different markets you can 
look at.

01:29:20.951 --> 01:29:23.198
On the left side you see the 
device manufacturer's rewards 

01:29:23.199 --> 01:29:26.053
programs.  Google is paying out 
the highest rewards this the 

01:29:26.054 --> 01:29:28.054
industry.

01:29:29.914 --> 01:29:31.914
Another market are the elite 
hacking contests.

01:29:34.642 --> 01:29:36.642
You can see on the graph on the 
right 

01:29:37.921 --> 01:29:40.758
the price of Android has risen 
to the point where now the most 

01:29:40.759 --> 01:29:45.081
recent event a few months ago 
the pricing for Android is on 

01:29:45.082 --> 01:29:48.177
par with other platforms. 
If you haven't seen the results,

01:29:48.178 --> 01:29:51.888
Android performed right well in 
that event.  Another market is 

01:29:51.889 --> 01:29:56.765
the great market.  Independent 
researchers and brokers who will

01:29:56.766 --> 01:30:00.012
sell exploits to the highest 
bidder.  This is a little harder

01:30:00.013 --> 01:30:02.013
to track but 

01:30:03.271 --> 01:30:05.271
we have connections to a lot of 
researchers and the price of 

01:30:08.012 --> 01:30:09.460
exploitation on Android is now 
as high or higher than any other

01:30:09.461 --> 01:30:13.321
platform. 
So this is really great.  We are

01:30:13.322 --> 01:30:15.322
happy with progress but we 

01:30:16.371 --> 01:30:19.073
continue to invest in all these 
areas.  Now let's switch gears 

01:30:19.074 --> 01:30:23.975
and talk about some of the new 
emerging features in Android P 

01:30:23.976 --> 01:30:25.976
starting with Android protected 
confirmation.

01:30:29.703 --> 01:30:31.703
So the problem here is in 
today's 

01:30:32.961 --> 01:30:35.412
secure mobility we use mobile 
devices much more than we ever 

01:30:35.413 --> 01:30:38.047
did before but there's still a 
ceiling of trust that we haven't

01:30:38.048 --> 01:30:40.048
quite broken through.

01:30:41.747 --> 01:30:43.747
We don't vote for Prime Minister
or president from our phones.

01:30:47.189 --> 01:30:49.189
We don't program

01:30:54.363 --> 01:30:57.293
don't program critical medical 
diseases medical devices from 

01:30:57.294 --> 01:30:59.294
our phones.

01:31:01.143 --> 01:31:02.778
I'll talk about a few use cases,
medical, financial and 

01:31:02.779 --> 01:31:04.779
enterprise but 

01:31:06.856 --> 01:31:08.856
the key innovation is protected 

01:31:10.093 --> 01:31:12.359
confirmation is the first time 
that we now have the ability to 

01:31:12.360 --> 01:31:17.038
execute a high assurance 
transaction, a user transaction 

01:31:17.039 --> 01:31:19.281
completely within secure 
hardware, running in a trusted 

01:31:19.282 --> 01:31:23.134
execution environment or TE, 
that runs separate from the main

01:31:23.135 --> 01:31:25.135
operating system.

01:31:26.795 --> 01:31:31.068
So how does it work?  So an 
application developer, say 

01:31:33.513 --> 01:31:35.513
you're a medical company that is

01:31:37.645 --> 01:31:39.645
developing a solution for people
with 

01:31:41.516 --> 01:31:43.516
diabetes so you're managing an 
insulin pump.

01:31:44.780 --> 01:31:47.418
The application will enable the 
user to select two insulin units

01:31:47.419 --> 01:31:49.419
and call the 

01:31:51.113 --> 01:31:53.342
protection API to transmit that 
data to the secure hardware area

01:31:53.343 --> 01:31:58.143
where a completely independent 
trusted user interface will 

01:31:58.144 --> 01:32:00.144
execute.  The interface you see 
here on the 

01:32:03.558 --> 01:32:05.558
screen shows the two insulin 
units, the 

01:32:07.048 --> 01:32:09.289
user confirms it by pressing a 
button.  It's guarded in this 

01:32:09.290 --> 01:32:14.591
area.  And the entire 
transaction is signed using a 

01:32:14.592 --> 01:32:16.592
transcriptd key that never 
leaves that security area.

01:32:20.709 --> 01:32:23.560
This provides higher assurance 
to the relying party that the 

01:32:23.561 --> 01:32:25.584
integrity of this data was not 
corrupted even if you had 

01:32:30.076 --> 01:32:31.090
root level malware it cannot 
corrupt the integrity of that 

01:32:31.091 --> 01:32:33.091
transaction. 
So in code this is really easy.

01:32:37.395 --> 01:32:39.395
We use the standard Android key 
store API.

01:32:41.256 --> 01:32:43.256
We have this new method to set a
flag confirmation required.

01:32:45.557 --> 01:32:47.557
We create the confirmation 
dialogue 

01:32:50.258 --> 01:32:52.258
using the confirmation dialogue 
API and 

01:32:54.881 --> 01:32:57.590
use the method to transfer 
control where the user will 

01:32:58.608 --> 01:33:00.608
interact with that special 
screen.  Really easy. 

01:33:02.694 --> 01:33:04.694
So we have a number of launch 
partner 

01:33:05.941 --> 01:33:07.941
whose have been working closely 
with us on this technology.

01:33:11.255 --> 01:33:13.255
They have been building 
prototypes.

01:33:15.523 --> 01:33:17.602
Big foot medical is a program 
that works on solutions for 

01:33:17.603 --> 01:33:19.603
people with diabetes.

01:33:22.935 --> 01:33:24.935
The user is looking at the 
glucose 

01:33:27.815 --> 01:33:30.464
level deciding I want to inject 
one and a half insulin units and

01:33:30.465 --> 01:33:32.465
calls the API 

01:33:33.468 --> 01:33:35.468
to invoke the interface.

01:33:39.646 --> 01:33:42.284
The user confirms and only then 
will the insulin pump administer

01:33:42.285 --> 01:33:44.285
that dose.

01:33:47.164 --> 01:33:49.241
In the medical side we have 
royal bank Canada that is 

01:33:49.242 --> 01:33:51.688
working to integrate protected 
confirmations into their 

01:33:52.117 --> 01:33:55.592
application.  I don't have a 
video for this one but you can 

01:33:55.593 --> 01:33:58.020
track left the right this 
application is moving a person 

01:33:58.021 --> 01:34:00.021
to person financial transfer.

01:34:02.096 --> 01:34:04.096
We see we are going to send 
$1,500 to ravy.

01:34:05.580 --> 01:34:09.233
The application invokes the 
protected confirmation's API.  

01:34:09.234 --> 01:34:11.494
The user confirms 1500.  1500 
can't be changed to 15,000.

01:34:14.752 --> 01:34:16.752
The relying party on the other 
end has 

01:34:18.023 --> 01:34:20.023
high confidence that we intended
to send 

01:34:21.107 --> 01:34:23.107
ravy $1,500 and the transaction 
goes through. 

01:34:24.784 --> 01:34:26.648
Duo security is a firm that is 
working on strong enterprise 

01:34:26.649 --> 01:34:28.649
authentication.

01:34:31.140 --> 01:34:33.140
Imagine you're logging into your

01:34:35.157 --> 01:34:38.112
Chromebook and it launchs a 
second factor authentication to 

01:34:38.113 --> 01:34:40.113
your phone.

01:34:41.578 --> 01:34:44.061
The duo security's application 
comes up and asks for 

01:34:44.062 --> 01:34:47.313
confirmation but then there's a 
second level confirmation using 

01:34:47.314 --> 01:34:49.314
the protected confirmation API 

01:34:50.353 --> 01:34:53.193
that provides again higher level
of assurance for the enterprise 

01:34:53.194 --> 01:34:56.863
that it is the device and user 
and location that is expected 

01:34:56.864 --> 01:35:00.325
for that authentication.  
So there are a lot of other 

01:35:00.326 --> 01:35:02.326
launch partners we worked 
closely with on this.

01:35:07.682 --> 01:35:09.682
on this.

01:35:13.626 --> 01:35:15.626
Proks to me is doing proximal 
based authentication.

01:35:20.293 --> 01:35:22.293
I would like to throw a shout 
out

01:35:26.332 --> 01:35:28.332
to qual com.

01:35:29.391 --> 01:35:31.391
Protected confirmation requires 
a deep 

01:35:33.462 --> 01:35:35.102
integration at the hardware 
level, it's optional for P so it

01:35:35.103 --> 01:35:40.247
requires a supported Android P 
device.  We are breaking through

01:35:40.248 --> 01:35:42.248
that last 

01:35:43.300 --> 01:35:45.732
ceiling of assurance in mobility
so it's very exciting.  

01:35:47.182 --> 01:35:50.052
There's a lot more to talk 
about.  I would like to call up 

01:35:50.053 --> 01:35:53.119
Xiaowen to take us through this 
story.  (Applause). 

01:35:55.561 --> 01:35:59.288
&gt;&gt; XIAOWEN XIN:  Thanks, Dave.  
Good morning, everyone.  And I'm

01:35:59.289 --> 01:36:01.324
really excited to be here to 
talk about a lot more of the 

01:36:01.325 --> 01:36:03.325
security 

01:36:05.499 --> 01:36:07.499
and privacy features that we 
built into Android P.

01:36:09.349 --> 01:36:12.024
As Dave mentioned security 
hardware is a huge focus area 

01:36:12.025 --> 01:36:14.541
for us because it can provide 
defenses against attacks that 

01:36:17.430 --> 01:36:19.430
software alone is not sufficient
to 

01:36:20.434 --> 01:36:23.002
handle.  Another API, another 
feature that we 

01:36:28.323 --> 01:36:30.812
are making in Android P is 
leveraging secure hardware also.

01:36:35.677 --> 01:36:38.201
So why do we need stronger 
protection?  Google pay is a 

01:36:38.202 --> 01:36:40.269
great example here.  We are 
working closely with them on 

01:36:42.300 --> 01:36:43.947
this P feature and they're going
to launch with it later this 

01:36:43.948 --> 01:36:46.008
year.  Consider their security 
goal n the 

01:36:49.662 --> 01:36:51.700
traditional transit use case 
they need to make sure that your

01:36:51.701 --> 01:36:56.638
transit card and only your card 
can be used to pay for your bus 

01:36:56.639 --> 01:36:59.087
ride so your transit card has 
your account information, a lot 

01:36:59.088 --> 01:37:01.088
of secrets in there that 
represents your account.

01:37:03.983 --> 01:37:05.983
Now the transit card is made 
using a 

01:37:07.858 --> 01:37:09.858
security element inside of it so
it's 

01:37:12.759 --> 01:37:14.759
hard to break into it and 
extract secrets.

01:37:16.840 --> 01:37:18.255
Android pay transit is working 
to replace that card with your 

01:37:18.256 --> 01:37:22.357
phone.  We need to make sure we 
provide the same security 

01:37:22.358 --> 01:37:24.811
guarantees which that is your 
secrets cannot be extracted out 

01:37:24.812 --> 01:37:28.688
of your phone and put to another
phone.  To pay for your bus ride

01:37:28.689 --> 01:37:30.689
you must present your phone.

01:37:32.359 --> 01:37:35.011
A great solution here is use 
secure hardware.  

01:37:38.664 --> 01:37:43.171
Now Google pay transit is one 
example.  Payments is another.  

01:37:43.172 --> 01:37:44.593
In all of these use cases you 
want to make sure that your 

01:37:44.594 --> 01:37:48.711
phone and only your phone can 
make that transaction.  There 

01:37:48.712 --> 01:37:50.969
are quite a few other examples 
where we benefit from stronger 

01:37:50.970 --> 01:37:52.970
protect from private keys.

01:37:55.838 --> 01:37:57.838
For example, if you have high 
value 

01:37:59.708 --> 01:38:01.536
Cloud data, if you're an 
enterprise or financial 

01:38:01.537 --> 01:38:04.207
institution you want to make 
sure that all requests, all data

01:38:04.208 --> 01:38:08.102
access is coming from a known 
phone or phone that you trust 

01:38:08.103 --> 01:38:10.541
and that phone is identified by 
a private key.

01:38:13.601 --> 01:38:15.887
Also if you have high value 
local data, let's say your 

01:38:15.888 --> 01:38:17.888
password manage, 

01:38:20.152 --> 01:38:22.152
you're storing passwords locally
on disk 

01:38:23.411 --> 01:38:25.411
then you may want to protect it 
again with a private key.

01:38:29.662 --> 01:38:31.662
How do we provide stronger

01:38:34.749 --> 01:38:39.336
protection for private keys?  
There are exacting standards 

01:38:39.337 --> 01:38:43.248
certifyd by professional labs to
be resistant to hardware 

01:38:43.249 --> 01:38:47.325
tampering.  Phones are starting 
to incorporate that exact 

01:38:47.326 --> 01:38:49.326
hardware directly into the 

01:38:52.046 --> 01:38:53.259
phone so your phone can replace 
your transit card or credit 

01:38:53.260 --> 01:38:55.260
card.

01:38:59.365 --> 01:39:01.210
With Android P we are now 
exposing APIs so all 

01:39:01.211 --> 01:39:03.222
applications on Android can take
advantage of this tamper 

01:39:03.223 --> 01:39:05.223
resistant 

01:39:07.956 --> 01:39:11.207
hardware on compatible devices. 
Specifically we are adding a new

01:39:11.208 --> 01:39:14.075
type of key store called 
strongbox.

01:39:17.533 --> 01:39:19.533
Strongbox is built using tamper 

01:39:20.591 --> 01:39:22.591
resistant hardware security 
elements 

01:39:26.078 --> 01:39:29.192
that has isolated CPU, RAM and 
secure storage.  It makes it so 

01:39:29.193 --> 01:39:33.167
that it's resistant to shared 
resource attacks.  For example, 

01:39:33.168 --> 01:39:35.711
many of the high profile 
hardware attacks we heard about 

01:39:39.165 --> 01:39:41.165
recently, strongbox is resistant
to 

01:39:42.688 --> 01:39:44.920
those as well as timing attacks 
as well as physical attacks. 

01:39:44.921 --> 01:39:49.598
So when we look at the key store
types that are available on 

01:39:49.599 --> 01:39:51.599
Android there are 

01:39:52.666 --> 01:39:54.666
now three types of key store.

01:40:00.197 --> 01:40:02.437
On older Android devices key 
store was implemented using it 

01:40:02.438 --> 01:40:04.438
directly.

01:40:08.057 --> 01:40:08.536
Even when now devices it was 
using the TE, trusted execution 

01:40:08.537 --> 01:40:10.537
environment.

01:40:13.445 --> 01:40:14.865
Now we are providing strongbox 
that can run alongside together 

01:40:14.866 --> 01:40:16.866
with the existing key store and 
the TE.

01:40:21.413 --> 01:40:23.856
Strongbox is resistant to the 
widest variety of attacks and 

01:40:23.857 --> 01:40:25.857
well suitd if you 

01:40:27.315 --> 01:40:29.315
have a use case that requires 
strong 

01:40:31.127 --> 01:40:35.877
protection for your private 
keys.  It does require new 

01:40:35.878 --> 01:40:40.144
hardware.  
To use strongbox it's fairly 

01:40:40.551 --> 01:40:42.551
straightforward.

01:40:45.068 --> 01:40:47.068
When you create your key store 
key set a new flag.

01:40:48.559 --> 01:40:50.559
If a device supports strongbox 
then 

01:40:51.618 --> 01:40:53.618
everything succeeds and it goes 
well.

01:40:57.521 --> 01:40:59.521
If not, you will get an 
unavailable exception.

01:41:02.616 --> 01:41:04.616
It uses tamper resistant 
hardware and 

01:41:05.687 --> 01:41:08.124
this is the first time that we 
are offering a generic API to 

01:41:08.125 --> 01:41:13.009
access the type of secure 
hardware for key management.  

01:41:13.010 --> 01:41:15.658
This feature as well as the 
protected confirmation API are 

01:41:15.659 --> 01:41:19.314
really pushing the boundary for 
security hardware support on 

01:41:19.315 --> 01:41:21.787
mobile and we are really excited
about the use cases that this 

01:41:21.788 --> 01:41:23.788
enable also.

01:41:29.388 --> 01:41:31.224
So protecting your private key 
is one thing that apps need to 

01:41:31.225 --> 01:41:33.225
do.

01:41:34.299 --> 01:41:36.299
Another is to make sure that the
right user is present.

01:41:39.082 --> 01:41:41.082
When you look at a typical 
Android 

01:41:43.858 --> 01:41:45.858
device the most likely security 
incident 

01:41:47.869 --> 01:41:49.149
to happen to that device is not 
malware but rather getting lost 

01:41:49.150 --> 01:41:53.390
or stolen so a locked screen is 
very important for Android, make

01:41:53.391 --> 01:41:56.249
sure you set a lock screen.  And
also an app developer make sure 

01:41:58.288 --> 01:42:02.353
you gain sensitive access on 
user authentication.   

01:42:05.625 --> 01:42:07.656
So in Android P we added a few 
different features to help ad 

01:42:07.657 --> 01:42:09.657
developers do that 

01:42:13.141 --> 01:42:15.985
starting with key guard bound 
keys.  Key guard bound keys are 

01:42:15.986 --> 01:42:17.986
key store 

01:42:19.254 --> 01:42:21.254
keys that are well suited for 
protecting 

01:42:22.513 --> 01:42:24.513
data that you store on the 
device.

01:42:25.994 --> 01:42:27.994
Key guard bound keys have their 

01:42:29.052 --> 01:42:31.339
functionality tied to the key 
guard so the keys can be used to

01:42:31.340 --> 01:42:34.239
encrypt data at any time and 
decrypt data only when the 

01:42:36.077 --> 01:42:38.077
device is unlocked.

01:42:39.153 --> 01:42:40.790
The life cycle of the keys are 
tied to the life cycle of the 

01:42:40.791 --> 01:42:45.264
lock screen.  If you have very 
sensitive confidential 

01:42:45.265 --> 01:42:47.265
enterprise data or private 

01:42:49.691 --> 01:42:51.691
health and fitness data you 
might want

01:42:53.705 --> 01:42:56.150
to encrypt it with a key guard 
bound key before you store to 

01:42:56.151 --> 01:43:00.611
disk.  It's now a little bit 
harder for an attacker to access

01:43:00.612 --> 01:43:03.291
the sensitive data.   

01:43:06.542 --> 01:43:08.373
To use a key guard bound key 
it's also fairly straightforward

01:43:08.374 --> 01:43:11.251
when you create your key store 
key set a flag to require 

01:43:16.777 --> 01:43:18.777
that the squeeze the device be 
unlocked.

01:43:20.033 --> 01:43:22.033
When you create your object you 
can 

01:43:24.254 --> 01:43:26.254
create it for encryption

01:43:28.588 --> 01:43:32.459
at any time and for decryption 
when the device is unlocked.  

01:43:32.460 --> 01:43:34.460
What if your device had been 
properly 

01:43:36.625 --> 01:43:37.342
unlocked but you want the check 
user authentication one for time

01:43:37.343 --> 01:43:39.343
let's say before a sensitive 
action like a payment happens.

01:43:43.261 --> 01:43:45.261
This is where a biometric prompt
comes in.

01:43:47.278 --> 01:43:49.278
It's our replacement

01:43:50.734 --> 01:43:53.241
for fingerprint manage.  
Fingerprint manage has a few 

01:43:53.853 --> 01:43:55.853
limitations.

01:43:56.916 --> 01:43:58.916
One is it only works for 
fingerprint.

01:44:01.594 --> 01:44:03.594
A lot of devices today are 
starting to 

01:44:05.318 --> 01:44:07.347
support face, iris and other 
modalities.  We do support more 

01:44:07.348 --> 01:44:10.880
than just fingerprint.  And it 
will automatically pick the 

01:44:12.701 --> 01:44:14.701
right modality for that user for
that device.  

01:44:16.782 --> 01:44:19.436
Another benefit of biometric 
prompt is it uses standard 

01:44:19.437 --> 01:44:21.437
system UI which is really nice 
when user experience 

01:44:24.325 --> 01:44:27.003
perspective to show the user 
standard UI when they're making 

01:44:27.004 --> 01:44:29.004
security relevant decisions.

01:44:31.499 --> 01:44:33.539
Also it sets us up well for 
future advances in sensor 

01:44:33.540 --> 01:44:35.540
technology when you 

01:44:36.545 --> 01:44:39.460
have an indisplay fingerprint 
sensor, it 

01:44:43.151 --> 01:44:45.151
tells you where to put your 
finger.  

01:44:47.876 --> 01:44:49.876
We know that biometric prompt is
quite 

01:44:51.296 --> 01:44:53.296
different from fingerprint 
manager and 

01:44:54.640 --> 01:44:57.508
so to ease the main of migration
we are also providing a support 

01:44:57.509 --> 01:44:59.509
library and so apps will be able
to call one API in 

01:45:01.770 --> 01:45:03.770
that support library and that 
will use 

01:45:04.770 --> 01:45:06.770
biometric

01:45:07.917 --> 01:45:09.917
prompt.  

01:45:14.450 --> 01:45:16.450
To use biometric prompts, create
the 

01:45:17.768 --> 01:45:19.768
further object and pass the 
title and 

01:45:22.035 --> 01:45:24.035
subtitle of properties then call
the 

01:45:25.864 --> 01:45:27.864
authentic to show

01:45:29.401 --> 01:45:31.401
the authentication prompt.

01:45:34.906 --> 01:45:37.868
We ask you use the crypto object
to user

01:45:43.941 --> 01:45:47.003
to user authorization is proper.
Now, what if the user is going 

01:45:47.004 --> 01:45:49.004
to your website in Chrome?

01:45:53.474 --> 01:45:55.474
How do you authenticate them 
there

01:45:58.404 --> 01:46:00.404
?  Coming later this year in Q 
four 

01:46:03.104 --> 01:46:05.144
Chrome on Android will support 
web op N which means if the user

01:46:05.145 --> 01:46:07.145
is going to your 

01:46:09.236 --> 01:46:11.236
website they can use their log 
screen or 

01:46:12.975 --> 01:46:14.975
biometric signals to 
authenticate to your use site.

01:46:18.130 --> 01:46:20.130
If you like to buy things on the
web 

01:46:22.236 --> 01:46:24.236
pay pal has a demo running where
you can 

01:46:26.346 --> 01:46:29.946
use your fingerprint to 
authenticate to PayPal and to 

01:46:26.346 --> 01:46:28.346
make your purchase.

01:46:29.706 --> 01:46:31.706
It's more

01:46:33.085 --> 01:46:34.705
convenient than typing in your 
password every time you make a 

01:46:34.706 --> 01:46:39.194
purchase.  To summarize several 
different methods we talked 

01:46:39.195 --> 01:46:41.195
about to gain access based on 

01:46:42.475 --> 01:46:44.475
authentication, first with key 
guard 

01:46:46.128 --> 01:46:48.603
bound keys you can tie data 
access to the life cycle of the 

01:46:48.604 --> 01:46:50.604
lock screen.

01:46:51.673 --> 01:46:53.673
If the user already unlocked the

01:46:55.791 --> 01:46:59.257
screen you can use biometric 
prompt to show system UI.  And 

01:46:59.258 --> 01:47:02.113
if the user is going to your 
website instead of your native 

01:47:02.114 --> 01:47:04.114
app you 

01:47:05.522 --> 01:47:07.522
can use web

01:47:11.414 --> 01:47:16.298
web auth.  Now that you 
determined it's the right user, 

01:47:16.299 --> 01:47:18.299
let's talk about integrity.

01:47:21.193 --> 01:47:23.193
A lot of apps need to make sure 
that 

01:47:24.675 --> 01:47:26.334
the integrity of the data and 
the integrity of the device 

01:47:26.335 --> 01:47:28.335
they're running on.

01:47:29.807 --> 01:47:32.340
In Android P to help you protect
the integrity of your data in 

01:47:32.341 --> 01:47:34.341
transit we are 

01:47:38.064 --> 01:47:40.903
going to require TLS by default.
If the system will throw an 

01:47:40.904 --> 01:47:42.904
exception 

01:47:44.574 --> 01:47:46.574
if the app sends data in the 
clear.

01:47:47.635 --> 01:47:49.635
Using TLS should be a no-brainer

01:47:50.725 --> 01:47:53.183
because it protects the privacy 
of your users and protects your 

01:47:53.184 --> 01:47:55.184
content from 

01:47:57.059 --> 01:47:59.059
being modified in transit, 
whether it's 

01:48:01.966 --> 01:48:03.966
unwanted adds or tracking 
identifiers or 

01:48:05.225 --> 01:48:07.225
to exploit a weakness in your 
app.

01:48:08.689 --> 01:48:10.689
You should always incrept.

01:48:12.547 --> 01:48:14.599
You can still opt out in 
specific domains by updating 

01:48:14.600 --> 01:48:16.600
your network security configure.

01:48:20.301 --> 01:48:22.746
Do visit the website on the 
slide.  Now before you run off 

01:48:22.747 --> 01:48:24.989
to change your code we have one 
more piece of good news.

01:48:29.257 --> 01:48:31.100
For a lot of apps care about 
cryptographic compliance because

01:48:31.101 --> 01:48:34.565
it's important in regulated 
industries tan government.  

01:48:39.035 --> 01:48:41.477
So we are really happy that what
is used to security SSL traffic 

01:48:41.478 --> 01:48:43.478
on Android.

01:48:46.113 --> 01:48:48.113
Recently we received

01:48:49.812 --> 01:48:51.812
CAVP certificates for many 
approved 

01:48:53.490 --> 01:48:55.490
algorithms so this means

01:48:56.764 --> 01:48:58.764
that developers

01:49:02.671 --> 01:49:04.671
s have automatic fips 
compliance.

01:49:06.265 --> 01:49:08.100
Another topic in the integrity 
section is how do I make sure 

01:49:08.101 --> 01:49:10.396
that the device has not been 
tampered with?

01:49:13.661 --> 01:49:15.661
The device itself is still 
healthy?

01:49:18.539 --> 01:49:21.458
In Android O we introduced key 
attestation which allows you to 

01:49:21.459 --> 01:49:23.459
get a 

01:49:24.509 --> 01:49:26.339
signed statement from the secure
hardware itself about the state 

01:49:26.340 --> 01:49:28.340
of the 

01:49:30.614 --> 01:49:33.457
device and about the property of
your private keys.  It can tell 

01:49:33.458 --> 01:49:35.906
you whether the device passed 
verified boot, whether it's 

01:49:38.173 --> 01:49:40.832
running a recent security patch,
whether your private keys are 

01:49:40.833 --> 01:49:42.833
protected by TE or strongbox.

01:49:44.555 --> 01:49:46.555
Another thing that key 
attestation 

01:49:50.467 --> 01:49:52.467
will return to you is the firm 
wear hash 

01:49:54.341 --> 01:49:56.341
that the device is running.

01:49:59.038 --> 01:50:02.076
Think of this as transparency 
enabled verified.  What this 

01:50:02.077 --> 01:50:04.077
means if you're running a 

01:50:05.171 --> 01:50:07.171
firm way test that is the same 
as a 

01:50:10.266 --> 01:50:12.797
known good version you are 
running a bit for bit version so

01:50:12.798 --> 01:50:14.798
that's a 

01:50:17.628 --> 01:50:21.209
powerful thing to know about 
when you're running.  To know 

01:50:21.210 --> 01:50:23.210
that operating system you're 

01:50:24.267 --> 01:50:26.267
running is an exact good copy of
a known version.

01:50:29.315 --> 01:50:31.346
To users of the safety net 
attestation API, it will call 

01:50:31.347 --> 01:50:32.970
the platform under the hood.  So
you will be able to take 

01:50:32.971 --> 01:50:35.611
advantage of this without any 
changes to your code.  

01:50:39.514 --> 01:50:41.586
Now in some cases if you want to
get more information from the 

01:50:41.587 --> 01:50:43.587
API than what 

01:50:46.720 --> 01:50:48.720
is returned by safety you can 
still call directly.  

01:50:51.012 --> 01:50:53.045
Now last but certainly not 
least, privacy.  Privacy is an 

01:50:53.046 --> 01:50:56.101
important area to security.  We 
actually talked about privacy 

01:50:56.102 --> 01:50:58.102
quite 

01:50:59.160 --> 01:51:01.160
a bit already when we talked 
about the 

01:51:02.252 --> 01:51:04.924
TLS by default feature coming in
Android.  But there are a few 

01:51:04.925 --> 01:51:06.925
other privacy 

01:51:07.987 --> 01:51:10.427
features that are in Android P 
that we want to cover now.  

01:51:12.491 --> 01:51:14.491
First this is probably one of my
favorite features.

01:51:16.263 --> 01:51:18.263
Sensor access only in the 
foreground.

01:51:20.809 --> 01:51:22.809
In Android P running on an 
Android P 

01:51:24.087 --> 01:51:26.087
device regardless of your API 
level if 

01:51:27.777 --> 01:51:29.827
your app is in the background 
and idle you will no longer be 

01:51:29.828 --> 01:51:31.828
able to access the 

01:51:32.913 --> 01:51:35.762
camera, microphone or sensors.  
This behavior is slightly 

01:51:35.763 --> 01:51:39.627
different based on the exact 
characteristics of the API 

01:51:39.628 --> 01:51:42.277
you're targeting.  With the 
microphone API you will get 

01:51:44.729 --> 01:51:46.974
silence when you try to access 
microphone from the background 

01:51:46.975 --> 01:51:48.975
in idle.

01:51:51.467 --> 01:51:53.467
With a camera API it will behave
as if 

01:51:54.505 --> 01:51:56.505
you were preempted by a higher 
priority camera clients.

01:52:03.143 --> 01:52:04.177
With the sensors it's whether 
it's continuously or via call 

01:52:04.178 --> 01:52:06.178
back.

01:52:08.947 --> 01:52:08.992
If the app is in the background 
you can no longer access data 

01:52:08.993 --> 01:52:10.993
from sensors.

01:52:12.366 --> 01:52:14.366
If you need to access the camera

01:52:18.574 --> 01:52:19.397
, microphone or sensors create a
foreground service with a 

01:52:19.398 --> 01:52:21.152
persistent user notification.  
That gives users more control 

01:52:21.153 --> 01:52:25.012
and transparency into which apps
have access to their sensors at 

01:52:25.013 --> 01:52:27.013
that time. 

01:52:31.106 --> 01:52:33.106
To start a foreground service 
create 

01:52:34.998 --> 01:52:37.866
that notification first and 
start thetory ground method and 

01:52:37.867 --> 01:52:40.568
pass it to that notification. 
All right.

01:52:45.909 --> 01:52:48.141
Besides background access to 
sensors, restricted background 

01:52:48.142 --> 01:52:53.489
access to sensors we added a lot
more control over your data.  

01:52:53.490 --> 01:52:55.490
Android is the first major 

01:52:57.566 --> 01:52:59.622
operatingtism to have DNS over 
TLS support built right in.

01:53:04.075 --> 01:53:06.370
Your queries will be passed to a
source of your choice.

01:53:12.769 --> 01:53:14.769
Now if your default DNS already 

01:53:16.052 --> 01:53:18.052
supports we will automatically 
encrypt your data.

01:53:21.387 --> 01:53:25.279
We did this in collaboration 
with alphabet jigsaw team.  We 

01:53:25.280 --> 01:53:27.280
are looking forward to many new 
developments here. 

01:53:28.950 --> 01:53:30.950
Another cool feature we added in
Android 

01:53:33.193 --> 01:53:34.859
P in the privacy space is lock 
down mode.  It's useful if 

01:53:34.860 --> 01:53:36.860
you're in a situation 

01:53:39.988 --> 01:53:41.988
where you may temporarily lose 
access to your device.

01:53:44.484 --> 01:53:46.484
Let's say you need to hand it 
over in a security check point.

01:53:48.354 --> 01:53:50.607
You can put it in lock down mode
which is in a state where all 

01:53:50.608 --> 01:53:54.672
your knowledge factors can be 
used to lock down the device.

01:53:59.580 --> 01:54:01.580
Your fingerprint biometrics will
be disabled.

01:54:04.276 --> 01:54:06.705
Notifications will no longer 
show on the lock screen.  You 

01:54:06.706 --> 01:54:08.749
have higher assurances on the 
security of the lock screen when

01:54:08.750 --> 01:54:10.750
the 

01:54:12.365 --> 01:54:14.365
device is temporarily out of 
sight. 

01:54:15.130 --> 01:54:17.352
So that was a quick overview of 
the features that are coming 

01:54:17.353 --> 01:54:21.027
with Android P.  There's a lot 
more that we didn't have time to

01:54:21.028 --> 01:54:23.028
cover.

01:54:27.309 --> 01:54:29.309
So please do give us your 
feedback

01:54:31.595 --> 01:54:35.404
and send us an e-mail.  
Thank you for coming and have a 

01:54:35.405 --> 01:54:37.405
great day.  

01:54:39.024 --> 01:54:41.024
(Applause)

01:54:42.323 --> 01:54:42.515
. 
.  

01:54:42.516 --> 01:54:43.329
.  
.  

01:54:43.330 --> 01:54:44.143
.  
.  

01:54:44.144 --> 01:54:44.773
.  
.  

01:54:44.774 --> 01:54:46.004
.  
.  

01:54:46.005 --> 01:54:50.100
.   

01:54:54.747 --> 01:54:56.747
"Realtime

01:54:58.315 --> 01:55:00.315
captioning on this screen" .

01:55:02.195 --> 01:55:05.293
.   
.

01:55:07.494 --> 01:55:09.494
&gt;&gt; Thank you for joining this 
session.

01:55:12.831 --> 01:55:14.831
Grand ambassadors will assist 
you 

01:55:17.739 --> 01:55:20.388
getting you through the exists. 
If you registered for the next 

01:55:22.676 --> 01:55:24.676
session, we ask that you clear 
the room 

01:55:25.748 --> 01:55:27.748
and return via the registration 
line outside.  Thank you.

01:55:40.263 --> 01:55:44.263
in this room, we ask that you 
clear the room and return via 

01:55:40.263 --> 01:55:42.263
the registration line outside.  
Thank you.

01:58:08.472 --> 01:58:09.482
.  
.  

01:58:09.483 --> 01:58:11.483
.  
.

01:58:21.714 --> 01:58:23.952
.  

01:58:29.790 --> 01:58:31.790
Personalize actions for the 
Google

01:58:34.105 --> 01:58:36.105
Assistant

01:58:47.914 --> 01:58:48.322
.  
.  

01:58:48.323 --> 01:58:50.323
.

02:16:38.509 --> 02:16:40.746
.
&gt;&gt; Welcome.  Please fill in the 

02:16:40.747 --> 02:16:42.747
seats near the front of the 
room.  Thank you.

02:19:34.823 --> 02:19:37.476
.
&gt;&gt; At this time please find your

02:19:37.477 --> 02:19:39.477
seat.  Our session will begin 
soon.

02:22:22.197 --> 02:22:24.197
.
&gt;&gt; Hello.

02:22:28.567 --> 02:22:29.794
Welcome to personalize actions 
for the Google Assistant.  

02:22:29.795 --> 02:22:31.795
Thanks for being here.  I'm 
Silvano Luciani.

02:22:35.124 --> 02:22:37.164
I work in the assistance and 
actions on Google developer 

02:22:37.165 --> 02:22:39.165
relations team. 

02:22:42.472 --> 02:22:44.472
&gt;&gt; ADAM DAWES:  My name is Adam 
Dawes.

02:22:46.915 --> 02:22:48.915
We build identity tools for 
developers.  

02:22:49.934 --> 02:22:51.855
&gt;&gt; SILVANO LUCIANI:  In the next
half hour we are going to 

02:22:51.856 --> 02:22:53.856
provide to you some 

02:22:56.727 --> 02:22:59.396
of the functionality that Google
provides to you.  Why is it 

02:22:59.397 --> 02:23:01.397
important to personalize your 
action?

02:23:04.118 --> 02:23:06.118
And let's start by looking at 
the Google Assistant.

02:23:07.799 --> 02:23:09.799
This is the assistive technology
that 

02:23:11.071 --> 02:23:13.071
is at the center of an ecosystem
of more 

02:23:14.140 --> 02:23:16.356
than 500 -- sorry, million 
devices.  And it's there to help

02:23:16.357 --> 02:23:18.357
users to get things done.

02:23:21.284 --> 02:23:23.284
Things like listening to music 
or 

02:23:26.488 --> 02:23:28.518
playing some games, get informed
by watching some news, learn new

02:23:28.519 --> 02:23:30.519
recipes and so on.

02:23:33.055 --> 02:23:35.111
Actions in Google is the 
platform that allows you to 

02:23:35.112 --> 02:23:37.953
extend the Assistant.  You can 
add your on actions so you can 

02:23:40.401 --> 02:23:42.423
provide help for a knowledge 
domain where you think you are 

02:23:42.424 --> 02:23:45.314
an expert and you can provide 
value to the user. 

02:23:46.947 --> 02:23:48.947
You can connect with new users 
across 

02:23:50.615 --> 02:23:52.872
all the devices that we have 
seen and you can innovate by 

02:23:52.873 --> 02:23:57.386
adding conversational interface 
that can make some of the tasks 

02:23:57.387 --> 02:23:59.626
very easy, just a straight voice
command. 

02:24:02.481 --> 02:24:04.118
So thinking about this there are
two aspects where it's important

02:24:04.119 --> 02:24:06.385
to personalize your action.

02:24:09.891 --> 02:24:12.589
Aspect number one is for some of
the things you might want to do 

02:24:12.590 --> 02:24:17.274
like for example present music 
that a user can listen to to be 

02:24:17.275 --> 02:24:19.275
entertained, if you know 

02:24:21.552 --> 02:24:22.561
more about the preference and 
the tastes you can provide them 

02:24:22.562 --> 02:24:24.562
with music that will be more in 
line with their 

02:24:28.671 --> 02:24:32.764
expectation and fulfill their 
intent in a better way.  We have

02:24:32.765 --> 02:24:34.820
seen your actions can be 
involved across different 

02:24:34.821 --> 02:24:36.821
devices so you 

02:24:40.542 --> 02:24:43.388
want to be able if the user 
expressed preferences for 

02:24:43.389 --> 02:24:46.049
example as a speaker, honor 
those preferences when they 

02:24:46.050 --> 02:24:48.050
start 

02:24:50.598 --> 02:24:53.107
another conversation with on a 
different device like a 

02:24:53.108 --> 02:24:55.379
smartphone will you will be able
to provide a better experience 

02:24:58.419 --> 02:24:59.677
because now you can show visuals
to provide a better output to 

02:24:59.678 --> 02:25:01.678
the user. 

02:25:03.737 --> 02:25:05.737
So we are going to look at three
main 

02:25:07.433 --> 02:25:10.086
packets thats that already was 
mentioned.  The first one is 

02:25:10.087 --> 02:25:12.752
what is the platform providing 
to us so that we can learn 

02:25:16.420 --> 02:25:18.882
something more about the 
Assistant user.  Then we see how

02:25:18.883 --> 02:25:23.995
we can store this information in
the current conversation we have

02:25:23.996 --> 02:25:25.996
with the user or all the 

02:25:27.100 --> 02:25:29.116
conversation we might have with 
the user which means future 

02:25:29.117 --> 02:25:31.117
conversation and conversation on
different devices.

02:25:34.408 --> 02:25:38.080
Finally Adam will talk about 
adding identity to your action. 

02:25:38.081 --> 02:25:40.130
That can be a requirement where 
cases for example where the user

02:25:40.131 --> 02:25:45.280
wants to know where the next 
payment for a certain service is

02:25:45.281 --> 02:25:47.558
due, if you are the service 
provider you need to know who 

02:25:47.559 --> 02:25:49.559
they are 

02:25:51.217 --> 02:25:52.844
on your system, you need to 
authenticate them so you can 

02:25:52.845 --> 02:25:55.740
receive the correct information 
for their account. 

02:25:58.159 --> 02:26:00.159
So starting from learning more 
about the 

02:26:02.202 --> 02:26:04.202
Assistant users I'm going to 
introduce helper intents.

02:26:06.990 --> 02:26:07.598
Helper intents are a core 
concept of the Assistant 

02:26:07.599 --> 02:26:09.599
platform.

02:26:11.216 --> 02:26:13.216
You can request

02:26:14.971 --> 02:26:16.971
to the Assistant conversation so
it can 

02:26:18.597 --> 02:26:20.597
perform special tasks on your 
behalf.

02:26:24.754 --> 02:26:27.191
Some of the special tasks, you 
can ask to transfer the 

02:26:27.192 --> 02:26:31.285
conversation if you start the 
conversation on a smart speaker 

02:26:31.286 --> 02:26:33.286
you want to show a visual to the

02:26:34.586 --> 02:26:35.595
user, you can ask the 
conversation to be transferred 

02:26:35.596 --> 02:26:37.596
to a phone or added device 

02:26:38.666 --> 02:26:40.744
that can show the visual or you 
can even deep link into an 

02:26:40.745 --> 02:26:42.745
Android app if for 

02:26:44.990 --> 02:26:46.990
example the user has

02:26:48.777 --> 02:26:50.403
has requested a task that 
doesn't provide a good user 

02:26:50.404 --> 02:26:53.476
experience with a voice 
interface.  

02:26:55.493 --> 02:26:57.493
In this talk we are going to 
look at a 

02:26:59.781 --> 02:27:00.998
subset of the helpers that allow
you to obtain information from 

02:27:00.999 --> 02:27:04.077
the user.  This information can 
be two different types.

02:27:08.367 --> 02:27:11.238
One is you can ask to the user 
the consent for the assistant to

02:27:11.239 --> 02:27:15.755
share some information with your
action like the user name or the

02:27:15.756 --> 02:27:18.431
device location.  The location 
of the device where the 

02:27:19.255 --> 02:27:21.255
conversation is happening. 

02:27:23.541 --> 02:27:25.770
Date and time and place and 
location are a way of asking an 

02:27:25.771 --> 02:27:27.771
input to the user.

02:27:36.138 --> 02:27:37.137
I need a date for you, if, for 
example, your actions allow 

02:27:37.138 --> 02:27:39.138
users to 

02:27:46.158 --> 02:27:47.270
book services and you want to 
know when they want the service 

02:27:47.271 --> 02:27:49.349
or a place or location if you 
are arranging a delivery and you

02:27:49.350 --> 02:27:51.206
want to know where the deliver 
the transaction.  So starting 

02:27:51.207 --> 02:27:53.207
from the first one, how can we 
get the user name?

02:27:56.709 --> 02:27:58.947
In this slide what you see on 
your left is a simulation of a 

02:27:58.948 --> 02:28:00.948
conversation I 

02:28:02.202 --> 02:28:03.826
did on a test app that I wrote 
and on the right you can see 

02:28:03.827 --> 02:28:09.121
some of the code from our node.
js client library.  It's not the

02:28:09.122 --> 02:28:11.122
complete code from the 

02:28:12.404 --> 02:28:14.650
action, it's just what is 
relevant to what I'm showing.  

02:28:14.651 --> 02:28:17.716
And you can see how it works. 
First ask the permission, the 

02:28:17.717 --> 02:28:22.628
permission to get the name of 
the user.  And you provide the 

02:28:22.629 --> 02:28:24.891
context, that it's very 
important.  Because with the 

02:28:24.892 --> 02:28:26.916
context you are explaining to 
the user why you need the 

02:28:29.975 --> 02:28:32.012
name, how is your service going 
to be better if you obtain that 

02:28:32.013 --> 02:28:34.244
information.  So in this case 
I'm telling them hey I 

02:28:38.168 --> 02:28:40.168
want to address you by your 
name. 

02:28:40.406 --> 02:28:42.406
In the Assistant they cover the 

02:28:44.130 --> 02:28:46.130
conversation, ask the user can I
share this information?

02:28:48.233 --> 02:28:50.233
If it's a positive rely you get 
access 

02:28:51.320 --> 02:28:53.365
and you can use it to greet the 
user by the name.  If not, you 

02:28:53.366 --> 02:28:56.027
need to deal with it.  A 
knowledge that they didn't want 

02:28:56.028 --> 02:29:00.110
to share the information with 
you, try to provide the best 

02:29:00.111 --> 02:29:02.111
service that you can. 

02:29:04.787 --> 02:29:08.271
This next slide is showing to 
you the row JSON API.  If you're

02:29:08.272 --> 02:29:10.512
not using the client library and
instead you're using the 

02:29:13.601 --> 02:29:15.601
conversation webhook, this is 
how you question the permission.

02:29:16.449 --> 02:29:18.449
You can see the intent name is 
action 

02:29:19.734 --> 02:29:21.551
intent of permission and then 
there's a pack of parameters 

02:29:21.552 --> 02:29:23.552
that can go.

02:29:25.222 --> 02:29:27.222
They are different for every 
helper intent.

02:29:28.829 --> 02:29:30.829
And they are

02:29:31.956 --> 02:29:33.390
defined saying this request 
might contain this type of 

02:29:33.391 --> 02:29:37.284
field.  And you can see the 
context explain using I want 

02:29:37.285 --> 02:29:39.285
that information.  

02:29:41.370 --> 02:29:42.798
This is showing you in the 
following request that you 

02:29:42.799 --> 02:29:46.879
received from the Assistant if 
the user consented to give you 

02:29:46.880 --> 02:29:49.760
access to the information, this 
is how you receive it.  

02:29:51.844 --> 02:29:54.290
Location is very similar because
it's exactly the same intent, 

02:29:54.291 --> 02:29:56.291
it's an intent that is called 
permission.

02:29:59.549 --> 02:30:01.549
And

02:30:02.549 --> 02:30:04.817
again the aft is asking the user
can I share the location of your

02:30:04.818 --> 02:30:09.996
device with the action?  If the 
user replies yes, you get access

02:30:09.997 --> 02:30:12.828
to the location and now in this 
case you could resolve the 

02:30:12.829 --> 02:30:16.570
latitude and longitude to the 
place where they are and then 

02:30:16.571 --> 02:30:19.260
try something that it's near 
that location.   

02:30:22.525 --> 02:30:24.363
JSON is pretty similar, it's 
just only like a different value

02:30:24.364 --> 02:30:28.279
for the type of permission that 
we are asking.  And one thing 

02:30:28.280 --> 02:30:30.280
that you can notice now 

02:30:32.380 --> 02:30:34.438
is permission is an array which 
means if you want to ask for 

02:30:34.439 --> 02:30:38.294
both the name and location at 
the same time, you can do it.  

02:30:38.295 --> 02:30:42.800
You can just ask for multiple 
permissions in that array.   

02:30:46.274 --> 02:30:48.274
This is how you get the location
if the 

02:30:51.405 --> 02:30:56.718
user consents to give it to you.
Now date, time is different.  In

02:30:56.719 --> 02:30:58.719
this case we are not anymore 
asking 

02:30:59.793 --> 02:31:01.210
the user if the Assistant can 
share some information with our 

02:31:01.211 --> 02:31:03.211
action.

02:31:04.677 --> 02:31:07.137
We are directly asking the user 
can you give me a date, a date 

02:31:07.138 --> 02:31:09.138
value?

02:31:10.822 --> 02:31:12.822
And the most powerful thing when
you 

02:31:14.495 --> 02:31:17.166
do this through the Assistant is
we can resolve ways of 

02:31:17.167 --> 02:31:21.239
specifying the date that are not
just the date format.  So if you

02:31:21.240 --> 02:31:23.240
look at the example, when would 
you like to reserve the table?

02:31:29.801 --> 02:31:31.801
I reply tomorrow.

02:31:34.178 --> 02:31:38.444
The Assistant says what tomorrow
is to the time we are having the

02:31:34.178 --> 02:31:35.974
conversation.  
Another thing you might notice 

02:31:35.975 --> 02:31:37.992
in this case we have three 
prongs, an initial 

02:31:41.689 --> 02:31:43.740
prong that is the reason why we 
want to ask that information but

02:31:43.741 --> 02:31:45.741
there's also a 

02:31:47.440 --> 02:31:49.440
date and time additional prong 
that the 

02:31:50.709 --> 02:31:51.735
Assistant uses if it gets only 
parts of the information that 

02:31:51.736 --> 02:31:53.736
you need from the user.

02:31:55.048 --> 02:31:56.873
So if I only specify a date like
in the case of the example where

02:31:56.874 --> 02:31:59.158
I just said tomorrow, the 
Assistant will ask 

02:32:03.630 --> 02:32:05.915
what time using the prompt that 
you specify.  Once you have that

02:32:05.916 --> 02:32:07.916
information you can 

02:32:09.851 --> 02:32:14.132
access it in the case of node.js
client library.  

02:32:15.771 --> 02:32:18.626
Again, not very different.  Thp 
is the JSON.

02:32:22.649 --> 02:32:24.649
So what is changing is just

02:32:25.967 --> 02:32:27.967
the parameters you are passing 
when you 

02:32:30.530 --> 02:32:33.201
are asked for this helper and 
the value you get.  It's a 

02:32:33.202 --> 02:32:35.202
little longer because you have 
the date part and the time part.

02:32:36.511 --> 02:32:38.767
The last helper is the place and
location helper.

02:32:42.473 --> 02:32:45.135
Again, this is not anymore 
asking the user can I share your

02:32:45.136 --> 02:32:47.136
current location with the 
action.

02:32:49.414 --> 02:32:53.692
It's asking the user give me a 
place, give me a location.  

02:32:53.693 --> 02:32:55.693
Again, you can see that if you 
use 

02:32:58.487 --> 02:32:59.118
this helper we can resolve 
things like the public name of a

02:32:59.119 --> 02:33:03.820
place.  For example, when the 
action asks where would you like

02:33:03.821 --> 02:33:05.821
to pick it up?

02:33:09.928 --> 02:33:11.928
And I reply Shoreline am 
theatre, what 

02:33:14.605 --> 02:33:18.068
you get is the whole address.  
Not a lot of difference again.  

02:33:18.069 --> 02:33:20.069
You already know this API.

02:33:22.417 --> 02:33:24.654
It's all -- it's a very familiar
API by now.  The only things 

02:33:24.655 --> 02:33:28.349
that are changing are the type 
of parameters you can send along

02:33:28.350 --> 02:33:30.350
with helper and the name of the 
helper itself.

02:33:39.020 --> 02:33:41.099
And the request in this case you
got a little more info because 

02:33:41.100 --> 02:33:44.771
you have the address, the public
name and some more stuff.  

02:33:46.007 --> 02:33:48.044
Why is it not going?  Okay. 

02:33:52.157 --> 02:33:53.125
In this example where you have 
side to side two different 

02:33:53.126 --> 02:33:56.655
situations.  The first one is 
the place.  We have seen how we 

02:33:56.656 --> 02:33:58.656
can resolve a 

02:34:00.472 --> 02:34:02.472
public place, you ask

02:34:04.453 --> 02:34:05.878
for a Shoreline Amphitheater, 
you get the address.  But it's 

02:34:05.879 --> 02:34:10.200
showing a location.  A location 
is something that a user defines

02:34:10.201 --> 02:34:12.257
and it's private to them.  For 
example my home or my workplace.

02:34:14.902 --> 02:34:16.902
And so in the example on the 
right 

02:34:18.979 --> 02:34:20.979
when I ask work, the Assistant 
requests 

02:34:22.905 --> 02:34:25.161
again another type of consent 
which is can I share with the 

02:34:25.162 --> 02:34:27.162
action what work is for you?

02:34:29.257 --> 02:34:31.257
And only if the user says yes, 
then 

02:34:32.340 --> 02:34:34.340
you can get that address. 

02:34:37.378 --> 02:34:39.378
If you want to see more about 
helpers we 

02:34:45.632 --> 02:34:48.704
have a sample, GitHub dot 
com/actions-on Google.  It shows

02:34:48.705 --> 02:34:54.404
all the helpers that are 
available on the platform.  

02:34:55.851 --> 02:34:57.682
There's information that can be 
useful that we can find in every

02:34:57.683 --> 02:35:01.377
request without the need of 
requesting any specific helper.

02:35:06.484 --> 02:35:09.573
The first one is just there and 
it's called last seen.  It's 

02:35:09.574 --> 02:35:12.854
just the time stamp of the last 
interaction with the user.  The 

02:35:12.855 --> 02:35:14.481
first time the user has an 
interaction with the action it 

02:35:14.482 --> 02:35:19.010
will be undefined.  After that 
you will always have the time 

02:35:19.011 --> 02:35:21.011
stamp of the last interaction.  
This means you can use it, for 

02:35:21.889 --> 02:35:24.140
example, to greet them 
differently.  You can just say 

02:35:24.141 --> 02:35:26.141
welcome the first 

02:35:28.982 --> 02:35:30.982
time and then if the time stamp

02:35:32.437 --> 02:35:34.437
is is available, you can say 
welcome.

02:35:37.347 --> 02:35:39.678
You can do more complex stuff.  
You can calculate how much time 

02:35:39.679 --> 02:35:44.153
passed since the last time they 
visited you and depending on 

02:35:44.154 --> 02:35:46.154
whether you consider that 

02:35:47.606 --> 02:35:49.232
range to be short or long time 
you can reengage with them in a 

02:35:49.233 --> 02:35:52.326
different way. 
The other one that is 

02:35:52.327 --> 02:35:54.327
interesting for 

02:35:55.800 --> 02:35:57.800
all of you that have Android 
apps that 

02:36:00.550 --> 02:36:02.374
allow users to purchase or 
subscribe to entitlements, you 

02:36:02.375 --> 02:36:04.375
can connect your 

02:36:07.129 --> 02:36:08.954
action to an Android app, it's 
just in the verification that 

02:36:08.955 --> 02:36:10.955
you actually own the Android 
app.

02:36:12.700 --> 02:36:14.700
And all the entitlements that 
that 

02:36:15.769 --> 02:36:18.427
user bought on the Android app 
and Play will be available in 

02:36:18.428 --> 02:36:20.428
every request.  This is an 
example of how you would see it.

02:36:23.938 --> 02:36:25.938
In this case I'm just giving you
an JSON 

02:36:28.825 --> 02:36:30.825
example because in the client 
library we 

02:36:32.151 --> 02:36:37.046
built the JavaScript object that
contains this information.  What

02:36:37.047 --> 02:36:39.047
about storing information in the
conversation?

02:36:41.530 --> 02:36:43.974
We said that it's important that
we can do it so we can give a 

02:36:43.975 --> 02:36:47.235
more personalized experience 
inside a conversation but also 

02:36:47.236 --> 02:36:50.909
across all the different 
conversations that the user can 

02:36:50.910 --> 02:36:54.176
have with your action.  
The first concept that I like to

02:36:55.806 --> 02:36:58.297
introduce to you is the 
conversation token.  The 

02:36:58.298 --> 02:37:00.963
conversation token, it's 
available only if you're using 

02:37:00.964 --> 02:37:02.964
an action SDK action.

02:37:05.258 --> 02:37:07.258
And it's a field of the response
and 

02:37:08.538 --> 02:37:10.538
the request defined in the 
conversation webhook API.

02:37:13.221 --> 02:37:15.221
It's just a screen like if you 
write 

02:37:16.725 --> 02:37:17.749
to it we will send back what 
you've written in the next 

02:37:17.750 --> 02:37:19.983
request.  If you change it we 
will do it again.

02:37:29.172 --> 02:37:29.785
The main catch is it's value is 
always initialized to an empty 

02:37:29.786 --> 02:37:32.229
screen.  It's always the current
conversation 

02:37:35.541 --> 02:37:36.973
and all the values you stored in
there will be cleared when the 

02:37:36.974 --> 02:37:41.869
conversation ends.  You can use 
it for improvements when those 

02:37:41.870 --> 02:37:43.870
improvements make sense only in 

02:37:45.480 --> 02:37:47.480
the like cycle of the current 
conversation that you're having.

02:37:48.675 --> 02:37:52.572
One example of how to write the 
value, in the first case I'm 

02:37:52.573 --> 02:37:54.804
just writing a simple string.  
In the second case what I'm 

02:37:54.805 --> 02:37:56.805
doing 

02:37:58.468 --> 02:38:00.767
because I want to use a more 
structure approach I'm 

02:38:00.768 --> 02:38:02.768
serializeing the JSON object to 
a screen so I can get a 

02:38:05.035 --> 02:38:07.035
representation that contains an 
object.

02:38:13.244 --> 02:38:15.244
Dialogue flow you don't have 
access to 

02:38:16.314 --> 02:38:18.314
the conversation token but the 
same 

02:38:21.194 --> 02:38:23.457
functionality with a more 
powerful abstraction called 

02:38:23.458 --> 02:38:28.559
output context.  You can have 
more than one output context.  

02:38:28.560 --> 02:38:31.441
Each one has a name and you can 
identify the name, you can set 

02:38:31.442 --> 02:38:35.731
the lifespan in terms of 
conversation for which that data

02:38:35.732 --> 02:38:37.565
will be available and it 
provides an interface that gives

02:38:37.566 --> 02:38:39.566
you access the a structured 
value.

02:38:42.491 --> 02:38:44.491
To see an example of an output 
context 

02:38:46.158 --> 02:38:49.003
you can see an output context at
an array, it's identified by a 

02:38:49.004 --> 02:38:51.004
very long time.

02:38:52.279 --> 02:38:54.279
The lifetime count is five turns
in 

02:38:55.552 --> 02:38:57.552
this case and I'm writing an 
object for 

02:39:01.010 --> 02:39:03.010
what are the value that I want 
to store in this context. 

02:39:04.489 --> 02:39:06.489
To use the client library and 
node.

02:39:08.571 --> 02:39:10.600
js we give you the best of both 
worlds.  We provide you an 

02:39:10.601 --> 02:39:14.064
obstruction, you write whatever 
you want to the object.  And 

02:39:14.065 --> 02:39:16.065
depending on whether your action

02:39:19.619 --> 02:39:22.041
is an action SDK or dialogue 
flow we use the conversation 

02:39:22.042 --> 02:39:24.042
token in one case or the output 
context in the other. 

02:39:25.554 --> 02:39:27.379
To see an example of how you 
could use it, let's say you have

02:39:27.380 --> 02:39:29.380
some music that you want to 
play.

02:39:31.701 --> 02:39:34.167
The user asks I want to listen 
to some music.  You can ask them

02:39:34.168 --> 02:39:39.327
do you want a random genre?  A 
specific genre?  If they give 

02:39:39.328 --> 02:39:42.994
you one, you can save it for the
rest of the conversation.  You 

02:39:42.995 --> 02:39:44.995
can keep giving them music 
coming from that genre.

02:39:48.335 --> 02:39:51.181
And you can also have a counter 
where you count how many songs 

02:39:51.182 --> 02:39:53.826
for that genre you've been given
to the user and when 

02:39:57.092 --> 02:39:59.120
they reach a certain point let's
say ten songs you ask do you 

02:39:59.121 --> 02:40:02.991
still want this genre or do you 
want to change?  

02:40:05.077 --> 02:40:07.759
In some other cases the 
conversation token doesn't work 

02:40:07.760 --> 02:40:09.997
because let's say you want to 
store the preferences for an 

02:40:12.225 --> 02:40:14.225
action that is giving you 
weather 

02:40:15.711 --> 02:40:17.711
forecast and you want to save 
the zip or 

02:40:19.801 --> 02:40:20.619
area code to identify the area 
for where they want the 

02:40:20.620 --> 02:40:22.620
forecast.

02:40:23.716 --> 02:40:25.756
If you save this in a 
conversation token that value is

02:40:25.757 --> 02:40:28.628
lost at the next conversation.  
So you would be asking again 

02:40:28.629 --> 02:40:31.707
what is your zip?  And that's 
not a good experience.  

02:40:35.730 --> 02:40:37.821
And that's when user storage 
comes into play.

02:40:41.101 --> 02:40:42.801
This slide is exactly the same 
API of conversation token so you

02:40:42.802 --> 02:40:46.055
already know how to use this.  
It's a field of response 

02:40:46.056 --> 02:40:48.056
request, it's 

02:40:49.065 --> 02:40:51.065
a string, you can write just a 
string or 

02:40:52.208 --> 02:40:53.668
serialize a structured data.  We
will recirculate it across all 

02:40:53.669 --> 02:40:58.808
the conversation that you're 
having with the user.  Future 

02:40:58.809 --> 02:41:00.809
conversation, conversation on 
different devices. 

02:41:03.268 --> 02:41:05.268
The main difference is the 
content can 

02:41:06.764 --> 02:41:09.864
be clear only by the app itself 
or by the usered only by the app

02:41:09.865 --> 02:41:11.865
itself or by the user.  And we 
will see it in a couple of 

02:41:11.977 --> 02:41:15.225
slides. 
So this is exactly the same 

02:41:15.226 --> 02:41:18.901
example that I had for the 
conversation token.  The only 

02:41:18.902 --> 02:41:22.152
thing that has changed is the 
name of the field.  Now I'm 

02:41:22.153 --> 02:41:24.153
using user storage and that 

02:41:25.616 --> 02:41:27.616
means I have access to a bigger 
lifespan. 

02:41:29.698 --> 02:41:32.390
Going back to the example of 
storing, now that we store it in

02:41:32.391 --> 02:41:34.391
the user 

02:41:35.508 --> 02:41:37.549
storage, if I started this 
conversation on a smart speaker,

02:41:37.550 --> 02:41:40.398
save the zip, the moment I asked
for the forecast from my 

02:41:43.453 --> 02:41:45.503
phone the action will know the 
zip code and won't need to ask 

02:41:45.504 --> 02:41:47.981
for it again.  
That's it.

02:41:51.066 --> 02:41:53.066
This is how you clear the value.

02:41:54.157 --> 02:41:56.582
If you're using the client 
library you set the value of the

02:41:56.583 --> 02:42:01.555
storage to an empty object and 
we clear it for you.  Last thing

02:42:01.556 --> 02:42:06.072
I have to say about the user 
storage is very important.  This

02:42:06.073 --> 02:42:08.531
is mostly like a cookie and so 
there are some countries that 

02:42:08.532 --> 02:42:10.532
have 

02:42:12.021 --> 02:42:13.862
strong regulations about 
obtaining consent from the user 

02:42:13.863 --> 02:42:18.359
before you can save or read data
from the user storage.  So if 

02:42:18.360 --> 02:42:21.225
you operate in one of these 
countries, make sure that you 

02:42:21.226 --> 02:42:23.226
use the 

02:42:25.362 --> 02:42:27.618
helper that is a helper that 
allows you to ask something to 

02:42:27.619 --> 02:42:29.619
the user and get a 

02:42:31.921 --> 02:42:33.921
yes or no question

02:42:35.595 --> 02:42:37.595
no request before you start 
writing from the user storage.

02:42:40.920 --> 02:42:41.943
Now it's time for Adam to talk 
about identity.  (Applause). 

02:42:41.944 --> 02:42:43.944
&gt;&gt; ADAM DAWES:  Thank you 
Silvano.

02:42:46.501 --> 02:42:48.527
User storage is a terrific 
feature to hold state and build 

02:42:48.528 --> 02:42:50.528
continuity with the user across 
multiple conversations.

02:42:54.644 --> 02:42:57.141
It works a lot like a cookie or 
HTML5 might in a browser but we 

02:42:57.142 --> 02:43:01.031
know that isn't always enough so
let me talk a little bit about 

02:43:01.032 --> 02:43:03.693
how you can use identity to 
further deepen your experience 

02:43:03.694 --> 02:43:06.353
with the user. 
So the first thing that you get 

02:43:06.354 --> 02:43:08.395
with identity is you get to know
who the user is.

02:43:11.648 --> 02:43:13.689
You get to know her name, her 
e-mail address and you get 

02:43:13.690 --> 02:43:15.690
access to her profile picture.

02:43:17.209 --> 02:43:19.055
This allows you to build a 
direct relationship with the 

02:43:19.056 --> 02:43:21.056
user where you can 

02:43:22.948 --> 02:43:25.414
engage her via e-mail outside of
the context of using your app.  

02:43:25.415 --> 02:43:27.658
The next thing that identity 
provides is 

02:43:30.754 --> 02:43:33.187
the ability to have a consistent
experience across multiple 

02:43:33.188 --> 02:43:37.464
devices and on different 
platforms.  So with user storage

02:43:37.465 --> 02:43:42.352
you're able to keep applications
state and user preferences but 

02:43:42.353 --> 02:43:44.353
all that data is stored 

02:43:46.136 --> 02:43:47.185
in Google's Cloud and only 
available to your conversational

02:43:47.186 --> 02:43:50.162
action.  
But with identity, now you can 

02:43:50.163 --> 02:43:53.042
store all of the user's data on 
your own back end.

02:43:56.579 --> 02:43:59.215
And whether or not the user 
comes back via your mobile app, 

02:43:59.216 --> 02:44:02.897
the web or your conversational 
action, you'll be able to re-set

02:44:02.898 --> 02:44:04.898
the state for the user and get 

02:44:06.783 --> 02:44:09.223
her going where she left off the
last time she used your service.

02:44:11.653 --> 02:44:14.100
Finally with identity now that 
you have all her data stored on 

02:44:14.101 --> 02:44:19.453
your back end identity can now 
help you secure that data so 

02:44:19.454 --> 02:44:22.322
only the user has access to it 
and nobody else does. 

02:44:25.628 --> 02:44:27.244
So the actions on Google 
platform has supported identity 

02:44:27.245 --> 02:44:32.993
from the very beginning with 
OAuth based account linking but 

02:44:32.994 --> 02:44:35.441
the problem that we found is 
that when a user engages with 

02:44:35.442 --> 02:44:39.914
your action via voice, the only 
way to be able to do that 

02:44:39.915 --> 02:44:41.915
account linking 

02:44:43.130 --> 02:44:47.886
experience was to punt the user 
to the phone and get the user to

02:44:47.887 --> 02:44:49.887
go to your website, log in and 
complete the linking experience.

02:44:53.824 --> 02:44:55.824
These kinds of cross device 
flows are 

02:44:58.691 --> 02:45:00.691
super difficult and as you can 
imagine 

02:45:01.767 --> 02:45:04.404
the conversion rate is pretty 
low.  That's why we are super 

02:45:04.405 --> 02:45:06.405
excited to 

02:45:09.203 --> 02:45:11.668
announce the developerer preview
for the Google sign in for 

02:45:11.669 --> 02:45:13.669
Assistant.

02:45:14.960 --> 02:45:16.960
You sign into your app 
completely via 

02:45:19.483 --> 02:45:21.524
voice without needing to leave 
the context of the conversation.

02:45:25.411 --> 02:45:27.891
And like Google sine in on other
platforms woor are able to 

02:45:27.892 --> 02:45:33.197
automatically log users in if 
they previously used your 

02:45:33.198 --> 02:45:35.198
service on a different device or

02:45:37.021 --> 02:45:39.110
another platformSign in on other
platforms woor are able to 

02:45:39.111 --> 02:45:42.844
automatically log users in if 
they previously used your 

02:45:39.111 --> 02:45:41.111
service on a different device or
another platform.

02:45:43.227 --> 02:45:45.483
It comes in two different 
developer modes.

02:45:51.223 --> 02:45:53.223
In multi platform this provides 
a seem 

02:45:54.681 --> 02:45:56.681
less voice base experience for 
Google 

02:46:00.024 --> 02:46:02.660
user yet still maintains a path 
for users that registered with 

02:46:02.661 --> 02:46:07.179
your service with another 
identity.  For Assistant only 

02:46:07.180 --> 02:46:09.180
developers we are 

02:46:11.515 --> 02:46:14.159
especially excited about what 
Google sign in for a Assistant 

02:46:14.160 --> 02:46:18.026
is going to be able to do.  We 
heard you that identity and 

02:46:18.027 --> 02:46:20.880
account linking is a heavy lift 
just to get 

02:46:24.399 --> 02:46:26.399
started on the platform.

02:46:29.035 --> 02:46:31.035
Now for Google sign in for 
Assistant you're able to rely 

02:46:35.195 --> 02:46:37.195
completely on Google

02:46:39.110 --> 02:46:41.110
to manage identity.

02:46:42.938 --> 02:46:44.938
Let's take a look at how one of 
these 

02:46:45.954 --> 02:46:47.954
Assistant only developers 
planning on using the tool.

02:46:51.103 --> 02:46:52.744
Starbutter AI was founded by 
four self-described personal 

02:46:52.745 --> 02:46:54.745
finance geeks 

02:46:55.798 --> 02:46:58.089
who love to argue with each 
other about the best way to 

02:46:58.090 --> 02:47:00.090
manage their personal 

02:47:01.585 --> 02:47:04.229
finances and look for financial 
services products.  They all 

02:47:04.230 --> 02:47:06.230
found themselves with a similar 
experience where they're friends

02:47:09.479 --> 02:47:11.479
and families would

02:47:13.428 --> 02:47:15.868
would inundate them with 
questions about the best credit 

02:47:15.869 --> 02:47:19.484
cards or how to get a mortgage. 
They realized the best way to 

02:47:23.745 --> 02:47:26.421
recommend financial services 
products was to get to know the 

02:47:26.422 --> 02:47:28.422
user you there a question and 
answer dialogue.

02:47:31.936 --> 02:47:34.392
They are invested so big into AI
and building on the Assistant 

02:47:34.393 --> 02:47:36.393
platform.

02:47:38.613 --> 02:47:42.194
Just last year they won an award
for being one of the top actions

02:47:42.195 --> 02:47:44.195
ton Assistant platform.

02:47:45.669 --> 02:47:47.918
But to offer advice that will 
keep users coming back again and

02:47:47.919 --> 02:47:49.919
again, 

02:47:51.588 --> 02:47:53.588
Starbutter really needs a user's
identity.

02:47:55.289 --> 02:47:57.532
Last week we gave them access to
Google Sign in for the Assistant

02:47:57.533 --> 02:47:59.533
so 

02:48:00.735 --> 02:48:02.735
let's look at their demo app.

02:48:07.573 --> 02:48:11.773
on the Assistant platform.  But 
to offer advice that will keep 

02:48:07.573 --> 02:48:11.573
users coming back again and 
again, Starbutter really needs a

02:48:07.573 --> 02:48:11.773
user's identity.  Last week we 
gave them access to Google Sign 

02:48:07.573 --> 02:48:11.173
in for the Assistant so let's 
look at their demo app. 

02:48:07.573 --> 02:48:09.573
.

02:48:12.542 --> 02:48:16.408
&gt;&gt; Talk to mortgage helper 
demo&gt;&gt; Talk to mortgage helper 

02:48:12.542 --> 02:48:15.418
demo. 
&gt;&gt; All right.  Getting the test 

02:48:15.419 --> 02:48:17.419
version of mortgage helper demo.

02:48:21.130 --> 02:48:23.130
&gt;&gt; Hi, I'm Morgan.

02:48:24.625 --> 02:48:26.044
I analyze millions of data 
points to find you the best 

02:48:26.045 --> 02:48:28.297
mortgage.  Want to compare loan 
offers or 

02:48:31.611 --> 02:48:33.611
calculate how much you can 
borrow?

02:48:36.442 --> 02:48:38.442
&gt;&gt; Calculate how much I can 
borrow. 

02:48:40.807 --> 02:48:42.807
&gt;&gt; To compare home loan offers 
I'll need 

02:48:44.077 --> 02:48:47.791
your basic intoe to create a new
mortgage helper demo account.  

02:48:47.792 --> 02:48:50.647
If you want more details say 
tell me more.  Can I have your 

02:48:50.648 --> 02:48:53.314
name, e-mail address and pro 
tile picture from Google?  

02:48:55.150 --> 02:48:57.150
&gt;&gt; ADAM DAWES:  Yes. 

02:49:02.200 --> 02:49:04.030
&gt;&gt; Great, Alix I've created a 
new mortgage helper demo account

02:49:04.031 --> 02:49:08.522
using your Google a couldn't.  
Are you purchasing a property or

02:49:11.586 --> 02:49:13.586
refinancing a property you 
already own?  

02:49:14.017 --> 02:49:16.017
&gt;&gt; ADAM DAWES:  Wasn't that so 
much better.

02:49:17.294 --> 02:49:19.747
The user was able to create an 
account without leaving the 

02:49:19.748 --> 02:49:22.247
context of their conversation.  
Let's look behind the scenes at 

02:49:22.248 --> 02:49:27.180
what I guess what is going on.

02:49:31.241 --> 02:49:33.241
Google Sign in for the Assistant

02:49:34.709 --> 02:49:36.709
operates like all others other 
the platform.

02:49:39.829 --> 02:49:41.829
You went to get to get 
information 

02:49:43.975 --> 02:49:45.975
about who the user is.

02:49:48.238 --> 02:49:49.668
If the user says yes then we 
generate an ID token and hand it

02:49:49.669 --> 02:49:51.669
back to your client.  

02:49:54.781 --> 02:49:56.781
Now let's take a look at one of 
these ID tokens.

02:49:57.904 --> 02:50:00.763
An ID token is adjustment a JSON
web token and that's basically a

02:50:00.764 --> 02:50:02.764
dictionary 

02:50:04.208 --> 02:50:06.672
of JSON which is 
cryptographiccly signed by 

02:50:06.673 --> 02:50:08.517
Google so you can be sure that 
the information inside the token

02:50:08.518 --> 02:50:11.391
is authentic.  Inside the token 
you'll see all of the 

02:50:13.642 --> 02:50:15.642
information that you need in 
order to be 

02:50:17.961 --> 02:50:19.806
able to make a decision about 
whether the link the account or 

02:50:19.807 --> 02:50:21.807
create a new account for the 
user.

02:50:24.740 --> 02:50:26.740
That includes the user's name, 
profile 

02:50:31.071 --> 02:50:33.329
picture and e-mail e-mail 
address.  You'll also notice at 

02:50:33.330 --> 02:50:35.330
the top of the 

02:50:36.595 --> 02:50:39.240
screen there's the AUD field, 
short for audience.  This is 

02:50:39.241 --> 02:50:42.138
also a super important field 
because that pretexts the 

02:50:42.139 --> 02:50:44.590
security of the user's data.  
It's what prevents another app 

02:50:44.591 --> 02:50:46.591
from 

02:50:49.290 --> 02:50:51.290
getting an ID token for that 
Google user 

02:50:53.901 --> 02:50:54.737
and replaying that token against
your backend to get access to 

02:50:54.738 --> 02:50:57.824
that user's data.  
Let's look at what Starbutter 

02:50:57.825 --> 02:50:59.825
had to do to get this set up.

02:51:03.585 --> 02:51:04.398
The first thing they needed to 
do was go to the actions on 

02:51:04.399 --> 02:51:08.328
Google developer console and go 
to the identity and account 

02:51:08.329 --> 02:51:14.071
linking section.  There they can
figure that they used Google 

02:51:14.072 --> 02:51:17.014
Sign in as their linking type.  
Next they need to update their 

02:51:17.015 --> 02:51:21.700
action.  So first they need to 
initialize their client ID, this

02:51:21.701 --> 02:51:23.969
is what comes back in the 
audience and protects the user's

02:51:24.398 --> 02:51:29.099
data.  And then they need to 
find the right time to be able 

02:51:29.100 --> 02:51:31.742
to ask the user to log in and 
provide consent to give their 

02:51:32.368 --> 02:51:34.368
account information. 

02:51:36.828 --> 02:51:39.108
Now Starbutter did that 
relatively early and you're 

02:51:39.109 --> 02:51:43.804
going to want to be thoughtful 
about why you do this.  It's not

02:51:43.805 --> 02:51:46.445
best practice to immediately ask
the user to sign in when they 

02:51:46.446 --> 02:51:49.497
open your action so think about 
that carefully.

02:51:53.380 --> 02:51:55.380
The last thing that Starbutter 
needed 

02:51:56.649 --> 02:51:58.649
to do was to handle the 
resolution.

02:52:00.139 --> 02:52:01.779
The user can agree to provide 
their profile information or 

02:52:01.780 --> 02:52:03.780
they can decide not to.

02:52:05.654 --> 02:52:07.893
If they agree, then we will be 
able to return that whole set of

02:52:07.894 --> 02:52:09.894
JSON that comes 

02:52:11.784 --> 02:52:14.631
back in the ID token and then 
you'll be able to extract the 

02:52:14.632 --> 02:52:16.632
user's e-mail 

02:52:18.310 --> 02:52:20.310
address or their Google 
identifier and 

02:52:21.358 --> 02:52:23.358
you can start keying data on 
your 

02:52:24.433 --> 02:52:27.107
backend based on that user's 
identity.  If the user decides 

02:52:27.108 --> 02:52:29.108
not to provide 

02:52:30.378 --> 02:52:34.498
that information you're going to
want to handle that gracefully. 

02:52:34.499 --> 02:52:36.499
You want to explain the benefit 
of logging in.

02:52:38.391 --> 02:52:40.842
If they still don't want to 
share their information, you 

02:52:40.843 --> 02:52:42.843
will try to 

02:52:45.974 --> 02:52:47.974
forward the conversation to be 
useful to 

02:52:49.420 --> 02:52:51.420
the user to the user even if you
don't know who they are.

02:52:54.979 --> 02:52:57.264
The multi-platform developer 
wants to be able to support two 

02:52:57.265 --> 02:52:59.265
types of users 

02:53:01.342 --> 02:53:03.588
both the Google user as well as 
any user who may have registered

02:53:03.589 --> 02:53:05.589
with their 

02:53:08.686 --> 02:53:10.514
service given another identify 
provider like Microsoft or out 

02:53:10.515 --> 02:53:14.996
look.  They need to have that 
path to able to connect to data 

02:53:14.997 --> 02:53:16.997
for both user types.

02:53:18.714 --> 02:53:21.168
I understand it may feel like a 
little bit of a caveat that only

02:53:21.169 --> 02:53:26.098
Google users are able to get 
that voice based account linking

02:53:26.099 --> 02:53:28.099
experience but it's still going 

02:53:31.336 --> 02:53:33.336
to be Sumer impactful for your
super impactful for your action.

02:53:34.712 --> 02:53:36.545
We know you invested a lot of 
time and energy so we want to 

02:53:36.546 --> 02:53:38.985
make sure that we bring as many 
users through that front door.

02:53:43.852 --> 02:53:44.471
So by having Google users get in
streamlined voice experience, 

02:53:44.472 --> 02:53:47.347
that's going to bring many more 
users to enjoy 

02:53:51.008 --> 02:53:53.058
all the benefits that your 
action provides. 

02:53:55.499 --> 02:53:57.741
So let's take another look at an
action that is on multiple 

02:53:57.742 --> 02:53:59.742
platform also.

02:54:01.015 --> 02:54:03.015
This is Itcher.

02:54:04.064 --> 02:54:06.064
Their goal in life is to answer 
that 

02:54:07.357 --> 02:54:11.438
age old question what movie or 
TV show should I watch tonight? 

02:54:11.439 --> 02:54:14.098
They built a personalized 
recommendation available on iOS,

02:54:17.184 --> 02:54:19.184
Android, web and the Assistant 
platform 

02:54:27.646 --> 02:54:28.630
and they offered many ways to 
sign in, Google, face, even 

02:54:28.631 --> 02:54:30.631
Twitter.

02:54:32.839 --> 02:54:34.839
Itcher needs a user's identity.

02:54:36.679 --> 02:54:40.079
They can't store user as likes, 
dislikes, and make 

02:54:36.679 --> 02:54:42.382
recommendations without having a
consistent experience across 

02:54:42.383 --> 02:54:45.051
time and across across devices.

02:54:50.171 --> 02:54:53.677
Here is their demo app. 
&gt;&gt; Talk to Itcher. 

02:54:54.283 --> 02:54:56.283
&gt;&gt; Okay.

02:54:57.548 --> 02:54:59.548
Let's get the test version of 
Itcher. 

02:55:00.805 --> 02:55:01.425
&gt;&gt; To get started I need your 
basic info to personalize your 

02:55:01.426 --> 02:55:06.316
experience.  If you want more 
detail, say tell me more.  Can I

02:55:06.317 --> 02:55:08.317
have your name, e-mail address, 

02:55:09.377 --> 02:55:11.601
and profile picture from Google?
&gt;&gt; Yes. 

02:55:14.256 --> 02:55:17.154
&gt;&gt; Great.  So now I can check to
see if you have an account with 

02:55:17.155 --> 02:55:21.862
us.  Just a sek.  I found your 
account, al liks.

02:55:24.979 --> 02:55:26.979
Your account is now linked to 
Google. 

02:55:28.150 --> 02:55:31.136
&gt;&gt; Hi, this is Itcher.  I can 
give

02:55:37.179 --> 02:55:39.184
you movies, TV shows.  How can I
help?  

02:55:39.390 --> 02:55:41.710
&gt;&gt; ADAM DAWES:  That was a much,
much better experience.  We were

02:55:41.711 --> 02:55:43.711
able to detect whether or not 

02:55:45.386 --> 02:55:47.386
al liks had an account with 
Itcher and 

02:55:48.581 --> 02:55:50.079
seamlessly makeAlix had an 
account with Itcher and 

02:55:50.080 --> 02:55:52.080
seamlessly make the experience.

02:55:53.747 --> 02:55:55.747
How does Itcher make that 
experience 

02:55:57.021 --> 02:55:59.021
with Google Sign in for 
Assistant?

02:56:00.439 --> 02:56:02.439
They need

02:56:03.547 --> 02:56:05.547
to go to the Google developer

02:56:07.064 --> 02:56:09.064
console.

02:56:10.559 --> 02:56:12.396
Next they do exactly like 
Starbutter, find the right time 

02:56:12.397 --> 02:56:16.090
in the conversation to ask the 
user to sign in.  And then this 

02:56:16.091 --> 02:56:18.091
is where things get a little bit
different.

02:56:20.417 --> 02:56:23.279
So in that interaction we went 
and we went to do a discovery to

02:56:23.280 --> 02:56:25.310
whether or not that account 
already exists.

02:56:28.771 --> 02:56:30.771
In order to make that happen, 

02:56:33.665 --> 02:56:35.765
Starbutter and the food both app
created a separate rest API from

02:56:35.766 --> 02:56:38.628
their conversational action 
fulfillment end point. 

02:56:41.316 --> 02:56:43.316
So we called this end point the 
token 

02:56:44.779 --> 02:56:46.779
end point and it allows us to do
account discovery and creation.

02:56:48.657 --> 02:56:50.281
So the way the logic of this end
point works is pretty 

02:56:50.282 --> 02:56:54.163
straightforward.  We ask the 
user whether or not they want to

02:56:54.164 --> 02:56:56.164
sign in to the app.

02:56:58.856 --> 02:57:01.125
If they say yes then we generate
ID token and send to it the 

02:57:01.126 --> 02:57:03.126
token end point.

02:57:05.615 --> 02:57:08.472
Food both validates the ID token
and extract the user's e-mail 

02:57:08.473 --> 02:57:10.473
address and do 

02:57:11.742 --> 02:57:13.742
a look up on their account 
database.

02:57:14.806 --> 02:57:16.675
If they find that user already 
exists they link the account by 

02:57:16.676 --> 02:57:18.676
taking the 

02:57:21.011 --> 02:57:23.011
Google identifier and storing 
that for 

02:57:25.653 --> 02:57:28.006
the user and also generate their
own own credential and return it

02:57:28.007 --> 02:57:30.007
to Google.

02:57:31.880 --> 02:57:33.880
Google will store that 
credential and 

02:57:36.194 --> 02:57:38.194
return it in every conversation 
back to the food bot app.

02:57:40.689 --> 02:57:43.163
If in that look up on whether or
not that user already exists, 

02:57:43.164 --> 02:57:45.164
that user 

02:57:47.020 --> 02:57:48.858
doesn't exist, then food bot 
will return an error saying I 

02:57:48.859 --> 02:57:50.859
never heard of that user. 

02:57:53.809 --> 02:57:55.809
So then what Google does is we 
look up 

02:57:56.866 --> 02:57:58.700
food bot settings and see if 
they want to support account 

02:57:58.701 --> 02:58:02.396
creation via voice.  Not all 
apps want to do that.  Sometimes

02:58:02.397 --> 02:58:04.397
the registration process 
requires that they gather more 

02:58:06.273 --> 02:58:07.746
information than just the name 
and e-mail address or maybe they

02:58:07.747 --> 02:58:12.065
want to make sure that the user 
is really evaluated their 

02:58:12.066 --> 02:58:14.066
privacy policy and terms of 
service.

02:58:15.528 --> 02:58:17.560
But if they do decide they want 
to do voice based account 

02:58:17.561 --> 02:58:21.437
creation then we will ask the 
user do you want to create an 

02:58:21.438 --> 02:58:23.694
account with food bot?  If the 
user says yes, we will then 

02:58:26.672 --> 02:58:28.672
again hit the token end point 
and the 

02:58:30.672 --> 02:58:32.110
token end points will again 
validate the request is coming 

02:58:32.111 --> 02:58:35.595
from Google and extract the 
name, e-mail address and profile

02:58:35.596 --> 02:58:38.223
picture and store that 
information as a new user in 

02:58:38.224 --> 02:58:40.500
their user database and they 
will also create a 

02:58:43.580 --> 02:58:46.060
token and return that to Google 
to store and then respond with 

02:58:46.061 --> 02:58:49.369
every turn of conversation to 
keep that context. 

02:58:53.028 --> 02:58:55.719
Now if food bot decides they 
don't want to do voice based 

02:58:55.720 --> 02:58:57.720
account creation or the user 
decides they don't want to 

02:58:59.397 --> 02:59:01.397
create new account, they want to
log 

02:59:02.656 --> 02:59:04.656
into their existing account that
might 

02:59:06.315 --> 02:59:08.315
be based on Yahoo or Microsoft 
identity, 

02:59:10.140 --> 02:59:12.140
then we fall back

02:59:18.564 --> 02:59:20.564
to the regular O aupt base add 
based 

02:59:21.775 --> 02:59:26.165
account flowth based account 
flow.  This ensures all Google 

02:59:26.166 --> 02:59:28.166
users have this streamlined 
experience. 

02:59:29.455 --> 02:59:31.455
So that's pretty much it.

02:59:35.143 --> 02:59:37.143
It's really easy the take 
advantage of

02:59:39.530 --> 02:59:41.530
of Google Sign in for the 
Assistant.

02:59:44.025 --> 02:59:46.025
The developer preview is 
available today.

02:59:48.663 --> 02:59:51.437
Go and check out the actions on 
Google developer docs and look 

02:59:51.438 --> 02:59:55.697
for the identity section.  
Now as a recap, Silvano talked 

02:59:55.698 --> 02:59:57.698
to you 

02:59:59.388 --> 03:00:01.024
about how you can build a more 
personalized experience with the

03:00:01.025 --> 03:00:05.508
user by using helper intents to 
get permission to get the user's

03:00:05.509 --> 03:00:07.509
name, location, and time.

03:00:09.366 --> 03:00:12.237
He also talked about how to use 
the request info to see when the

03:00:12.238 --> 03:00:15.126
user last used your action and 
whether or not the 

03:00:19.404 --> 03:00:21.858
user is already purchased info 
from your service via the play 

03:00:21.859 --> 03:00:24.734
store.  Next he talked about how
to store 

03:00:28.762 --> 03:00:31.273
information and build build 
continuity with the user.

03:00:35.413 --> 03:00:37.413
And then I led you through how 
you can 

03:00:39.448 --> 03:00:41.448
use Google Sign in

03:00:43.578 --> 03:00:45.578
for Assistant.

03:00:48.255 --> 03:00:50.281
And for actions only developers,
now they don't even need to have

03:00:50.282 --> 03:00:54.388
their own account system. 
So we know your time is very 

03:00:54.389 --> 03:00:57.454
available.  We would love to 
hear what you thought of our 

03:00:57.455 --> 03:00:59.455
presentation.

03:01:00.942 --> 03:01:03.614
So please navigate back to the 
I/O schedule, find this session 

03:01:03.615 --> 03:01:05.615
and give us a rating.  

03:01:08.562 --> 03:01:10.562
And if you want more 
information, please 

03:01:11.961 --> 03:01:13.961
go online, we have t

03:01:15.925 --> 03:01:18.792
we have got helpful docs that 
describe Silvano's experiences 

03:01:18.793 --> 03:01:20.793
and best practices 

03:01:21.851 --> 03:01:23.851
and you can learn more about 
Google Sign in for Assistant.

03:01:26.414 --> 03:01:28.414
We will also be across the way 
at the 

03:01:30.233 --> 03:01:32.233
Assistant code lab and

03:01:34.618 --> 03:01:36.618
igloo tent so please come and 
ask us questions.  

03:01:38.869 --> 03:01:40.869
(Applause)

03:01:42.232 --> 03:01:42.641
. 
.  

03:01:42.642 --> 03:01:44.272
.  
.  

03:01:44.273 --> 03:01:45.084
.  
.  

03:01:45.085 --> 03:01:45.901
.  
.  

03:01:45.902 --> 03:01:47.345
.  
.  

03:01:47.346 --> 03:01:49.346
.

03:01:58.376 --> 03:01:58.772
"Realtime captioning on this 
screen" . 

03:01:58.773 --> 03:02:00.773
.  
.

03:02:19.019 --> 03:02:20.438
.
&gt;&gt; Thank you for joining this 

03:02:20.439 --> 03:02:22.439
session.

03:02:26.555 --> 03:02:28.163
Grand ambassadors will assist 
you with moving to the next 

03:02:28.164 --> 03:02:32.486
session.  If you registered for 
a session in this room, we ask 

03:02:32.487 --> 03:02:34.487
that you clear the 

03:02:35.746 --> 03:02:37.746
room and return through the line
outside.  Thank you.

03:03:12.354 --> 03:03:14.354
Intro to Machine Learning on 
Google Cloud platform.

03:03:18.909 --> 03:03:20.909
Platform.

03:03:25.872 --> 03:03:26.685
.  
.  

03:03:26.686 --> 03:03:27.528
.  
.  

03:03:27.529 --> 03:03:29.529
.  

03:03:32.609 --> 03:03:34.671
Intro to Machine Learning on 
Google Cloud platform. 

03:03:34.672 --> 03:03:36.331
.
&gt;&gt; Thank you for joining this 

03:03:36.332 --> 03:03:38.332
session.

03:03:39.986 --> 03:03:41.815
Grand ambassadors will assist 
with directing you through the 

03:03:41.816 --> 03:03:44.674
designated exists.  We will be 
making room for those who 

03:03:46.102 --> 03:03:48.750
registered for the next session.
If you registered for the next 

03:03:48.751 --> 03:03:50.751
session 

03:03:52.410 --> 03:03:54.410
in this room, we ask that you 
clear the 

03:03:56.146 --> 03:03:57.771
room and return via the 
registration line outside.  

03:03:57.772 --> 03:03:59.772
Thank you.

03:04:04.190 --> 03:04:07.683
.  
Intro to Machine Learning on 

03:04:07.684 --> 03:04:09.684
Google Cloud platform.

03:04:12.988 --> 03:04:14.988
Platform.

03:06:11.615 --> 03:06:13.615
.

03:16:31.512 --> 03:16:34.162
.
&gt;&gt; Welcome.  Please fill in the 

03:16:34.163 --> 03:16:36.163
seats near the front of the 
room.  Thank you.

03:16:40.275 --> 03:16:41.896
.  
.  

03:16:41.897 --> 03:16:43.897
.

03:16:47.903 --> 03:16:51.588
Intro to Machine Learning on 
Google Cloud platform.

03:16:55.266 --> 03:16:57.266
Platform.

03:19:35.530 --> 03:19:37.785
.
&gt;&gt; At this time please find your

03:19:37.786 --> 03:19:40.058
seat.  Our session will begin 
soon.

03:22:35.016 --> 03:22:37.016
&gt;&gt; SARA ROBINSON:  Hello.  
Everyone.

03:22:39.714 --> 03:22:41.137
Welcome to intro to Machine 
Learning on Google Cloud 

03:22:41.138 --> 03:22:43.694
platform.  I'm Sara Robinson.

03:22:47.771 --> 03:22:49.771
I'm a developer advocate and I 
focus on Machine Learning.

03:22:52.838 --> 03:22:57.590
You can find me on Twitter at S 
Rob tweets.  Machine Learning 

03:22:57.591 --> 03:22:59.591
involves teaching 

03:23:01.038 --> 03:23:03.724
computers to recognize patterns 
in the same ways that our brains

03:23:03.725 --> 03:23:05.725
do.

03:23:07.382 --> 03:23:10.023
It's hard to distinguish between
a cat and dog but much more 

03:23:10.024 --> 03:23:14.552
difficult for a machine to do 
the same thing.  I'm going to 

03:23:14.553 --> 03:23:16.553
focus on supervised learning.

03:23:21.087 --> 03:23:28.621
This is when during training you
give your model labeled input.  

03:23:28.622 --> 03:23:30.622
The amount that we know about 
how our 

03:23:31.683 --> 03:23:33.707
model works is going to depend 
on the tool we choose to use for

03:23:33.708 --> 03:23:37.407
the job and the type of Machine 
Learning problem we are trying 

03:23:37.408 --> 03:23:39.909
to solve.  So that was a high 
level overview but 

03:23:43.775 --> 03:23:45.600
how do we get from input to 
description?  Again this is 

03:23:45.601 --> 03:23:47.601
going to depend on the type of 
Machine Learning problem we are 

03:23:47.861 --> 03:23:49.861
trying to solve.

03:23:50.937 --> 03:23:53.587
So in the left side saying 
you're solving a generic task 

03:23:53.588 --> 03:23:58.709
that someone already solved 
before.  You don't need to start

03:23:58.710 --> 03:24:00.710
from scratch.

03:24:03.196 --> 03:24:05.196
Let's say you're solving a 
custom task 

03:24:06.688 --> 03:24:08.688
specific to your data set.

03:24:11.976 --> 03:24:13.976
More specifically let's think of
this 

03:24:15.674 --> 03:24:17.674
in terms of image 
classification.

03:24:19.582 --> 03:24:21.582
Let's say you want to label this
picture as a cat.

03:24:23.960 --> 03:24:26.786
We can use one of these 
pretrained models.  We don't 

03:24:26.787 --> 03:24:28.787
need to start from scratch.

03:24:29.889 --> 03:24:31.889
Let's say this cat's name is 
Chloe, 

03:24:34.988 --> 03:24:36.647
this is our cat, and we want to 
identify her across our entire 

03:24:36.648 --> 03:24:38.648
image library.

03:24:40.541 --> 03:24:43.233
We need to train a model using 
our own data from scratch so it 

03:24:43.234 --> 03:24:45.234
can differentiate Chloe from 
other cats.

03:24:48.139 --> 03:24:50.607
Let's say we want our model to 
return a bounding box showing 

03:24:50.608 --> 03:24:52.608
where she is in that picture.

03:24:54.118 --> 03:24:56.118
We need to train a model on our 
own data. 

03:24:58.408 --> 03:25:00.234
Let's also think about this in 
terms of a natural language 

03:25:00.235 --> 03:25:02.235
processing problem.

03:25:04.158 --> 03:25:06.158
So let's say we have this text 
from 

03:25:07.227 --> 03:25:08.252
one of my tweets and I want to 
extract parts of speech from 

03:25:08.253 --> 03:25:12.536
that text.  This is a common 
natural language processing task

03:25:12.537 --> 03:25:14.625
so I don't need to start from 
scratch.

03:25:19.344 --> 03:25:21.390
I can utilize an exampleing 
model.  Let's say I want to take

03:25:21.391 --> 03:25:25.887
the same tweet and I want my 
model to know this is a tweet 

03:25:25.888 --> 03:25:28.800
about programming and more 
specifically it's a tweet about 

03:25:28.801 --> 03:25:30.801
Google Cloud.

03:25:32.272 --> 03:25:34.753
I'm going to need to train my 
model on thoughts of tweets so 

03:25:34.754 --> 03:25:36.754
they can generate 

03:25:38.140 --> 03:25:41.467
these predictions.  Many people 
see the term Machine Learning 

03:25:41.468 --> 03:25:43.724
and are scared off.  They think 
it's something only for experts.

03:25:46.360 --> 03:25:48.360
If you look back about 60 years 
ago this is definitely the case.

03:25:49.870 --> 03:25:51.870
This is a picture of the first 
neural 

03:25:54.351 --> 03:25:56.803
network invented in 1957 and 
this was a device that 

03:25:56.804 --> 03:25:59.894
demonstrated an ability to 
identify different shapes.  Back

03:25:59.895 --> 03:26:01.895
then if you wanted to work on 

03:26:04.340 --> 03:26:06.931
Machine Learning, you needed 
access to extensive academic and

03:26:06.932 --> 03:26:12.264
computing resources.  If we fast
forward to today we can see in 

03:26:12.265 --> 03:26:14.265
the last 5 or 10 years the 
number of 

03:26:16.174 --> 03:26:18.712
products of Google using Machine
Learning has grown dramatically.

03:26:19.728 --> 03:26:22.678
At Google we want to put Machine
Learning into the hands of any 

03:26:22.679 --> 03:26:26.785
developer and data scientist 
with a computer and Machine 

03:26:26.786 --> 03:26:28.786
Learning problem they want to 
solve and that's all of you.

03:26:32.923 --> 03:26:34.923
We don't Machine Learning should
be something for only experts.

03:26:38.875 --> 03:26:40.875
Make you're using a framework 
like 

03:26:43.397 --> 03:26:45.397
Scikit learn, maybe writing your
code in 

03:26:47.345 --> 03:26:49.345
Jupiter notebooks, maybe you're 

03:26:50.669 --> 03:26:52.509
experimenting with different 
models,ing proofs of concept or 

03:26:52.510 --> 03:26:54.510
scaling for production?

03:26:56.385 --> 03:26:58.012
What I want you to take away is 
no matter what your existing 

03:26:58.013 --> 03:27:03.388
Machine Learning toolkit is, we 
have something for you on Google

03:27:03.389 --> 03:27:05.389
cloud plat form.

03:27:07.481 --> 03:27:09.481
We have a whole speck room of 
Machine Learning products.

03:27:13.032 --> 03:27:14.466
On the left we have products 
targeted toward application 

03:27:14.467 --> 03:27:16.955
developers.  You need little to 
know Machine Learning 

03:27:16.956 --> 03:27:18.956
experience.

03:27:20.024 --> 03:27:22.024
On the right we have products 
targeted 

03:27:23.837 --> 03:27:25.940
more towards data scientists and
Machine Learning practitioners.

03:27:30.645 --> 03:27:32.645
First APIs that give you access 
to 

03:27:33.934 --> 03:27:36.400
pretrained models with a single 
rest API request.  As we move 

03:27:36.401 --> 03:27:38.401
through the middle we have a new
product which I'm super excited 

03:27:41.086 --> 03:27:43.754
about that we announced earlier 
this year in January called 

03:27:43.755 --> 03:27:45.755
AutoML.

03:27:51.566 --> 03:27:53.566
The first is Auto ML vision.

03:27:54.632 --> 03:27:56.720
Without requiring you to write 
any of the model code.  As we 

03:27:56.721 --> 03:27:58.749
move further to the right 
towards more custom models you 

03:27:58.750 --> 03:28:00.750
want to 

03:28:01.911 --> 03:28:04.611
build your model in TensorFlow, 
we have a service called Cloud 

03:28:04.612 --> 03:28:08.140
Machine Learning engine to let 
you train and serve your model 

03:28:08.141 --> 03:28:10.141
at scale. 

03:28:12.243 --> 03:28:14.243
Then a couple months ago we 
announced an 

03:28:17.273 --> 03:28:19.273
open source project

03:28:21.061 --> 03:28:23.061
called Kubernetes flow.  Let's 
say you have a Machine Learning 

03:28:25.161 --> 03:28:27.161
framework other than TensorFlow 
and you 

03:28:28.639 --> 03:28:30.639
want to run it on GCP.

03:28:34.207 --> 03:28:36.207
You can use it on Google control

03:28:37.224 --> 03:28:39.224
engine

03:28:42.394 --> 03:28:44.394
or Kubernetes.

03:28:49.219 --> 03:28:51.219
On Google clout On Google Cloud 
plat 

03:28:52.923 --> 03:28:54.923
form we have five APIs, that let
you 

03:28:57.658 --> 03:28:59.658
analyze images, converting audio
to text, translating that text.

03:29:02.344 --> 03:29:04.778
I'm going to show you cloud 
vision.  This is everything that

03:29:04.779 --> 03:29:06.779
vision API let's you do.

03:29:08.894 --> 03:29:10.894
At its core the vision API 
provides label detention.

03:29:15.057 --> 03:29:17.057
For this image it might return 
elephant, animal.

03:29:21.387 --> 03:29:23.266
Web detection will search the 
web for similar images and give 

03:29:23.267 --> 03:29:25.267
you labels on what it finds.

03:29:30.257 --> 03:29:32.544
OCR, optical character 
recognition, it let's you find 

03:29:32.545 --> 03:29:35.394
text, tells where you the text 
is and what language it's in.

03:29:41.785 --> 03:29:43.785
Logo detection, landmark 
detection, 

03:29:46.274 --> 03:29:49.024
crop hints and explicit content 
detect.  This is what a request 

03:29:49.025 --> 03:29:51.064
to the vision API looks like.  
You don't need to know anything 

03:29:51.065 --> 03:29:53.065
about 

03:29:55.762 --> 03:29:57.762
how that pretrained model works 
under the hood.

03:29:59.450 --> 03:30:01.450
You pass it in Google Cloud 
storage or 

03:30:03.524 --> 03:30:05.524
the basic encode Ed image and 
tell it 

03:30:07.024 --> 03:30:09.024
what types of feature detection 
it you 

03:30:10.508 --> 03:30:12.561
want it it to run.  I have an 
example in python here.

03:30:17.828 --> 03:30:19.828
I created image

03:30:21.143 --> 03:30:23.143
image annotateor client.

03:30:25.015 --> 03:30:26.649
ML kit, if you want to use ML 
kit for Firebase you can call 

03:30:26.650 --> 03:30:30.932
the vision API from Android or 
iOS app and this is an example 

03:30:30.933 --> 03:30:35.195
of calling it in swift.  
So I don't like to get too far 

03:30:35.196 --> 03:30:37.196
into a 

03:30:38.865 --> 03:30:40.865
talk without showing a live demo
so if we can switch to the demo.

03:30:43.208 --> 03:30:45.208
What we have here is the product
page for the vision API.

03:30:46.690 --> 03:30:48.690
We can upload images and see 
what the vision API responds.

03:30:50.802 --> 03:30:53.671
I'm going to upload an image.  
This is a selfie I took seeing 

03:30:54.487 --> 03:30:56.487
Hamilton.  I live in New York.

03:31:00.481 --> 03:31:02.481
Excited to score tickets to 
Hamilton.

03:31:04.920 --> 03:31:08.559
Let's see what we get back here.
Cranking.  Live demos.  You 

03:31:08.560 --> 03:31:10.560
never now.  There we go.

03:31:13.094 --> 03:31:14.942
We can see that it found my face
in the image so it's able to 

03:31:14.943 --> 03:31:19.630
identify where my face is, 
different features in my face 

03:31:19.631 --> 03:31:24.322
and detect emotion.  We can see 
joy is very likely here.  I was 

03:31:24.323 --> 03:31:26.820
super excited to be seeing 
Hamilton.  What I didn't notice 

03:31:26.821 --> 03:31:28.821
at first about this is it has 
text in it.

03:31:31.370 --> 03:31:33.400
When I sent it to the vision API
I didn't know there was text 

03:31:33.401 --> 03:31:35.401
here but we 

03:31:36.490 --> 03:31:38.313
can see it's able to abstract 
take play bill text from my 

03:31:38.314 --> 03:31:43.704
image.  Finally in the browser 
we can see the entire JSON 

03:31:43.705 --> 03:31:45.705
response we get back from the 
vision API.

03:31:48.803 --> 03:31:51.677
This is a great way to try out 
the API.  Before you start 

03:31:51.678 --> 03:31:54.550
writing code, see the response 
you get back and I'll provide a 

03:31:55.380 --> 03:31:58.706
link at the end.  That is the 
vision API.  If we can go back 

03:31:58.707 --> 03:32:00.952
to the slides. 
Next I want to talk about the 

03:32:00.953 --> 03:32:06.076
natural language API which let's
you analyze text with a single 

03:32:06.077 --> 03:32:08.077
rest API request.

03:32:09.365 --> 03:32:12.423
First it let's you extract key 
entitys from text.  It also 

03:32:12.424 --> 03:32:14.424
let's you tells you whether your
text is positive or negative.

03:32:18.407 --> 03:32:20.446
And if you want to get more into
the linguistic details of your 

03:32:20.447 --> 03:32:24.580
text you can use the syntax 
analysis method.  And then 

03:32:24.581 --> 03:32:26.581
content classification.

03:32:29.115 --> 03:32:30.343
It will classify your text into 
over 700 different categories we

03:32:30.344 --> 03:32:32.344
have available. 

03:32:34.846 --> 03:32:36.846
Here is python codes to call the
natural language API.

03:32:40.004 --> 03:32:42.844
It's going to look similar to 
the API vision code we saw on 

03:32:42.845 --> 03:32:46.752
the previous page.  We send in 
our text and get back the result

03:32:46.753 --> 03:32:49.613
from the model.  Let's jump to a
demo of the natural language 

03:32:49.614 --> 03:32:54.141
API.  
So again this is our products 

03:32:54.142 --> 03:32:56.213
page for the natural language 
API and here we can 

03:32:59.493 --> 03:33:00.922
enter text directly in this 
textbook and see what the 

03:33:00.923 --> 03:33:02.923
natural language API responds.

03:33:06.455 --> 03:33:09.308
I'm going to say I loved Google 
I/O but the ML talk was just 

03:33:09.309 --> 03:33:11.752
okay.  
We will see what it says.

03:33:15.430 --> 03:33:18.301
This is a review I might find on
a session.  Let's say I wanted 

03:33:18.302 --> 03:33:21.180
to extract key entities and see 
what the sentiment was.

03:33:25.704 --> 03:33:28.995
It extracted two entities and we
get a score for each.  The score

03:33:28.996 --> 03:33:31.440
is a value from negative 1 to 1 
that will tell us overall how 

03:33:33.072 --> 03:33:35.072
positive or negative is the 
sentiment in this entity.

03:33:37.985 --> 03:33:41.452
Google I/O got 0.8.  We even get
a link to the Wikipedia page.

03:33:48.435 --> 03:33:49.863
ML talk got a neutral score 
score zero, because it was just 

03:33:49.864 --> 03:33:54.168
okay.  And we can look at the 
syntax and details, see which 

03:33:54.169 --> 03:33:57.292
words depend on other words, get
the parts of speech for all the 

03:33:57.293 --> 03:34:02.554
words in our text.  And if our 
text was longer than 20 words we

03:34:02.555 --> 03:34:05.017
can make use of this content 
categorization feature which you

03:34:05.018 --> 03:34:07.018
can try 

03:34:10.361 --> 03:34:12.602
in the browser and see a list of
all the categories for that.  

03:34:12.603 --> 03:34:14.603
That is the natural language 
API. 

03:34:16.317 --> 03:34:18.317
If we can go back to the slides.

03:34:19.821 --> 03:34:21.442
I'll talk briefly about 
companies using these APIs in 

03:34:21.443 --> 03:34:23.443
production.

03:34:25.551 --> 03:34:27.551
Giphy is a website that let's 
you 

03:34:28.554 --> 03:34:30.554
search

03:34:31.896 --> 03:34:33.896
for giphs.

03:34:37.793 --> 03:34:39.793
It adds search by text 
functionality 

03:34:42.032 --> 03:34:44.032
to all their

03:34:46.326 --> 03:34:48.326
gif

03:34:54.110 --> 03:34:56.110
.  Hurst

03:35:02.617 --> 03:35:06.691
.  Descript let's you transcribe
meetings and interviews.  So all

03:35:06.692 --> 03:35:08.692
of these three companies are 
using just one API.

03:35:11.173 --> 03:35:12.395
We also have seen a lot of 
examples of companies combining 

03:35:12.396 --> 03:35:14.396
different Machine 

03:35:16.018 --> 03:35:18.018
Learning API

03:35:26.182 --> 03:35:28.182
s so seenit ace I crowd sourcedd
video.

03:35:29.800 --> 03:35:31.800
They use

03:35:33.956 --> 03:35:35.956
video intelligence, speech and 
natural language.

03:35:38.065 --> 03:35:40.065
Maslo is an audio journaling 
app, you 

03:35:42.376 --> 03:35:45.252
can enter your journal entries 
through audio and they're using 

03:35:45.253 --> 03:35:47.253
speech API to 

03:35:48.956 --> 03:35:50.956
extract audio and letting you 
give 

03:35:54.269 --> 03:35:55.089
insights about your journal 
entries and they're storing the 

03:35:55.090 --> 03:35:57.783
data.  So that is the natural 
language API.  

03:35:59.614 --> 03:36:01.614
So all of the products I've 
talked about 

03:36:04.954 --> 03:36:07.608
so far have abstracted that 
model for you.  A lot of times 

03:36:07.609 --> 03:36:09.609
when I present on APIs 

03:36:11.299 --> 03:36:13.299
people ask me those APIs sound 
great but 

03:36:16.011 --> 03:36:19.478
what if I want to train them on 
my own custom data.  This is 

03:36:19.479 --> 03:36:21.479
AutoML Vision.

03:36:23.146 --> 03:36:24.990
This loets you train an image 
classification model on your own

03:36:24.991 --> 03:36:27.250
image data.  This is best seen 
with a demo.

03:36:32.515 --> 03:36:34.515
For this demo let's say that

03:36:35.665 --> 03:36:37.665
I'm a meteorologist.

03:36:39.156 --> 03:36:41.627
I want to pro dekt whether 
trends and flight plans from 

03:36:41.628 --> 03:36:43.628
images of clouds.

03:36:44.722 --> 03:36:46.757
Can we use the Cloud to analyze 
clouds?  And as I have learned 

03:36:46.758 --> 03:36:52.058
there's many, many different 
types of clouds.  And they all 

03:36:52.059 --> 03:36:55.572
indicate different weather 
patterns.  So when I first 

03:36:55.573 --> 03:36:59.441
started thinking about this demo
I thought maybe I should try the

03:36:59.442 --> 03:37:01.442
vision API first and see what I 
get back.

03:37:05.387 --> 03:37:07.387
So as humans if you look at 
these two 

03:37:08.867 --> 03:37:10.906
images it's obvious to us these 
are completely different types 

03:37:10.907 --> 03:37:12.907
of clouds.

03:37:15.153 --> 03:37:20.120
We wouldn't know spl wouldn't 
know specifically what times of 

03:37:20.121 --> 03:37:22.201
clouds these images were but 
nothing as specific as cloud 

03:37:22.202 --> 03:37:24.202
types for these images.

03:37:26.166 --> 03:37:28.271
Even for these images of 
different clouds we get back 

03:37:28.272 --> 03:37:31.116
pretty similar labels, sky, 
cloud, blue, et cetera. 

03:37:34.326 --> 03:37:36.326
So this is where AutoML Vision 
comes in handy.

03:37:40.821 --> 03:37:42.821
It provides a UI to help with 
every 

03:37:44.930 --> 03:37:46.930
step from imparting the data, 
labeling, 

03:37:48.387 --> 03:37:50.387
training it and generating pro 
additions.

03:37:55.507 --> 03:37:56.802
The best way to see it is by 
jumporting the data, labeling, 

03:37:56.803 --> 03:38:01.003
training it and generating pro 
additions.  The best way to see 

03:37:56.803 --> 03:37:58.803
it is by jumping to a demo.

03:38:00.835 --> 03:38:04.744
Here we have the UU for AutoML 
Vision.  We import the data.

03:38:09.096 --> 03:38:11.096
We put our images in Google 
cloud 

03:38:12.710 --> 03:38:18.331
storage and create a CSV where 
the first column is the URL of 

03:38:18.332 --> 03:38:20.332
the image and the next column is
the 

03:38:22.148 --> 03:38:24.148
label of of that image.

03:38:26.454 --> 03:38:28.454
Then we upload our images and 
move over the the labeling tab.

03:38:32.775 --> 03:38:36.057
In this model I have five 
different types of clouds.  You 

03:38:36.058 --> 03:38:39.740
can see how many images I have 
for each one.  AutoML Vision 

03:38:39.741 --> 03:38:41.741
only requires ten labels 

03:38:44.451 --> 03:38:46.451
but they recommend at least 100 
for high quality predictions.

03:38:49.163 --> 03:38:51.163
The next step is to review my 
image labels.

03:38:52.238 --> 03:38:54.332
I can see all my cloud pictures 
here, see what label they are.

03:38:57.791 --> 03:39:00.632
This this one is incorrect I can
go in here and switch it out.  

03:39:00.633 --> 03:39:02.633
Let's say that I didn't have 
time to 

03:39:03.735 --> 03:39:06.636
label my data set or I have a 
massive image data set, I didn't

03:39:06.637 --> 03:39:08.637
have time to label it.

03:39:11.363 --> 03:39:13.261
I can make use of this human 
labeling service that will label

03:39:13.262 --> 03:39:17.937
your images for you and in just 
a couple days you'll get back a 

03:39:17.938 --> 03:39:21.996
label image data set. 
The next part is to train your 

03:39:21.997 --> 03:39:23.997
model.

03:39:25.045 --> 03:39:28.497
And you can choose between a 
base or advanced model.  I'll 

03:39:28.498 --> 03:39:31.373
talk about that more in a 
moment.  To train it all you do 

03:39:31.374 --> 03:39:34.248
is press this train button, 
simple as that. 

03:39:36.480 --> 03:39:38.184
Once your model is trained 
you'll get an e-mail and the 

03:39:38.185 --> 03:39:40.429
next thing you want to do is see
how this model performed using 

03:39:42.281 --> 03:39:44.732
some common Machine Learning 
metrics.  So I'm not going to go

03:39:44.733 --> 03:39:47.586
into all of them here but I do 
want the highlight 

03:39:52.150 --> 03:39:54.166
the confusion matrix.  If it 
looks confusing call it a 

03:39:56.170 --> 03:40:01.217
confusion matrix.  For a good 
confusion matrix we want to 

03:40:04.499 --> 03:40:06.499
see a strong diagonal from top 
to left.

03:40:07.564 --> 03:40:09.564
It split our images for us into 
training and testing.

03:40:11.652 --> 03:40:13.495
It took most of our images, used
those to train and model and 

03:40:13.496 --> 03:40:18.009
reserved a subset of our images 
to see how the model performed 

03:40:18.010 --> 03:40:20.010
on images it had never seen 
before.

03:40:21.894 --> 03:40:24.362
What this is telling us is for 
all of our cloud images in our 

03:40:24.363 --> 03:40:26.363
test set our 

03:40:28.665 --> 03:40:30.665
model was able to identify 76% 
of them correctly.

03:40:32.519 --> 03:40:35.591
On the train tab you saw the 
base and advance models.  I've 

03:40:35.592 --> 03:40:39.314
trained both so we are looking 
at the advance model here.  I 

03:40:39.315 --> 03:40:41.157
can use the UI to see how 
different versions of my model 

03:40:41.158 --> 03:40:44.222
performed and compare it.  
So we would expect that the 

03:40:44.223 --> 03:40:47.501
advanced model would perform 
better across the board so let's

03:40:47.502 --> 03:40:52.190
take a look.  It looks like it 
did indeed perform a lot better 

03:40:52.191 --> 03:40:54.191
for most all of the categories 
here.

03:40:57.532 --> 03:40:59.532
23% increase for this 1, 11% for
this one.

03:41:02.289 --> 03:41:04.545
Hey, wait, if we look at our 
Alto stratus images it did worse

03:41:04.546 --> 03:41:06.546
on that.

03:41:07.665 --> 03:41:09.750
What this is pointing out is 
there may be problems with our 

03:41:09.751 --> 03:41:14.631
training immamgs here so the 
advance model did a better job 

03:41:14.632 --> 03:41:17.348
of identifying where there's 
problems with our training data 

03:41:17.349 --> 03:41:20.218
sesmt our model is only as good 
as the training data we give it.

03:41:25.575 --> 03:41:27.575
14% of our Alto stratus clouds 
are 

03:41:28.796 --> 03:41:30.796
being miss labeled

03:41:36.832 --> 03:41:38.832
as cume lus clouds

03:41:40.592 --> 03:41:42.592
ulous clouds.

03:41:45.746 --> 03:41:47.746
These are pretty confusing 
images.

03:41:50.489 --> 03:41:52.117
This can identify where I need 
too go back and improve my 

03:41:52.118 --> 03:41:54.118
training data.

03:41:57.636 --> 03:42:00.867
The next part is generating 
predictions on new data.  I'm 

03:42:00.868 --> 03:42:05.001
going to take this go back and 
improve my training data.  The 

03:42:00.868 --> 03:42:02.700
next part is generating 
predictions on new data.  I'm 

03:42:02.701 --> 03:42:04.701
going to take this image of a 

03:42:05.803 --> 03:42:08.324
sirus cloud and see what our 
model predicts.  It has never 

03:42:08.325 --> 03:42:10.556
seen this image before.  It 
wasn't used during training and 

03:42:10.557 --> 03:42:12.557
we 

03:42:14.997 --> 03:42:16.997
will seal how it perform

03:42:20.994 --> 03:42:24.994
cirrus cloud and see what our 
model predicts.  It has never 

03:42:20.994 --> 03:42:24.994
seen this image before.  It 
wasn't used during training and 

03:42:20.994 --> 03:42:22.994
we will see how it performs.

03:42:24.486 --> 03:42:26.793
So the UI is one way you can 
generate predictions once your 

03:42:26.794 --> 03:42:29.880
model has been trained.  Chances
are you probably want to build 

03:42:31.303 --> 03:42:33.303
an app that's going to query 
your 

03:42:35.013 --> 03:42:35.834
trained model and there's a 
couple different ways to do 

03:42:35.835 --> 03:42:40.346
this.  I want the highlight the 
vision API here.  If you 

03:42:40.347 --> 03:42:43.028
remember the vision API request 
from a couple slides back you'll

03:42:43.029 --> 03:42:45.029
notice this doesn't look much 
different.

03:42:49.332 --> 03:42:51.332
All I need to add is this custom

03:42:53.228 --> 03:42:54.667
detection label parameter and I 
get an ID for that trained model

03:42:54.668 --> 03:42:58.154
that only I have access to or 
anybody that I shared my project

03:42:58.155 --> 03:43:00.155
with.  

03:43:01.419 --> 03:43:03.676
If I have an app that is just 
detecting whether or not there's

03:43:03.677 --> 03:43:05.677
a Cloud and image 

03:43:07.575 --> 03:43:09.575
but then say I want to upgrade 
my app, I 

03:43:11.821 --> 03:43:13.821
don't have to change much at all
about my app architecture.

03:43:17.133 --> 03:43:18.459
I just need to modify the 
request JSON a little bit.  So 

03:43:18.460 --> 03:43:22.988
that is auto ML vision.  If we 
can go back to the slides.  A 

03:43:22.989 --> 03:43:25.245
little bit about companies that 
are using Auto ML vision and 

03:43:25.246 --> 03:43:29.916
have been part of the alpha.  
Disney is the first example.  

03:43:29.917 --> 03:43:32.167
They trained a model on 
different Disney characters, 

03:43:32.168 --> 03:43:34.200
product categories and colors 
and they're integrating that 

03:43:38.094 --> 03:43:40.094
into their search engine to give
users more accurate results.

03:43:43.034 --> 03:43:45.034
Urban outfiters have a similar 
use case.

03:43:48.135 --> 03:43:50.135
They train a model to create 
different 

03:43:51.142 --> 03:43:53.142
set of

03:43:54.769 --> 03:43:56.598
product attributes and are using
it to give users better search 

03:43:56.599 --> 03:43:58.599
results.

03:43:59.649 --> 03:44:03.177
The last example is zoological 
society of London.  They have 

03:44:03.178 --> 03:44:05.622
cameras deploy all over the wild
and they built a model to 

03:44:07.889 --> 03:44:09.537
automatically tag all the 
wildlife they're seeing across 

03:44:09.538 --> 03:44:14.293
those cameras so they don't need
someone to manually review it.  

03:44:14.294 --> 03:44:16.952
So the two products I've talked 
about so 

03:44:20.235 --> 03:44:21.038
far the APIs and AutoML have 
entirely abstracted the model 

03:44:21.039 --> 03:44:25.355
from us.  We don't know anything
about how that model works under

03:44:25.356 --> 03:44:27.821
the hood but let's say you have 
a more custom prediction task 

03:44:30.091 --> 03:44:32.775
that is specific to your data 
set or use case.  One example is

03:44:32.776 --> 03:44:34.776
let's say you have just 

03:44:35.865 --> 03:44:37.294
launched a new product at your 
company, you're seeing it posted

03:44:37.295 --> 03:44:41.168
on social media and you want to 
identify where in an image that 

03:44:41.169 --> 03:44:43.232
product is located.  You are 
need to train a model on your 

03:44:44.232 --> 03:44:46.232
own data to do that.

03:44:47.322 --> 03:44:49.322
Lelts say you have a lot of 
blogs come 

03:44:50.787 --> 03:44:52.787
in and you want to analyze those
logs to 

03:44:54.617 --> 03:44:58.149
find am nomlys in your 
application.  We have two tools 

03:44:58.150 --> 03:45:02.854
to help you do this.  TensorFlow
for building your models and 

03:45:02.855 --> 03:45:04.883
Machine Learning engine for 
training and serving those 

03:45:04.884 --> 03:45:09.401
models at scale.  
So from the beginning the Google

03:45:09.402 --> 03:45:13.115
brain team wanted everyone in 
the industry to be able to 

03:45:13.116 --> 03:45:15.116
benefit from all the Machine 
Learning products so they made 

03:45:18.225 --> 03:45:20.225
TensorFlow an open source 
project on 

03:45:23.547 --> 03:45:25.547
GitHub and up take has been 
phenomenal.

03:45:26.821 --> 03:45:29.288
It has over 90,000 GitHub stars.
It just crossed over 13 million 

03:45:29.289 --> 03:45:33.764
down loads.  Because it's open 
sourced you can train and serve 

03:45:33.765 --> 03:45:38.761
your TensorFlow models anywhere.
So once you built your 

03:45:38.762 --> 03:45:40.762
TensorFlow model you need to 
think about training it and 

03:45:43.288 --> 03:45:46.984
then generating predictions at 
scale also known as serving.  So

03:45:46.985 --> 03:45:49.012
if you're app becomes a major 
hit, you're getting thoulgs of 

03:45:49.013 --> 03:45:51.102
prediction requests per minute 
you need to find a 

03:45:55.517 --> 03:45:55.999
way to serve that model at scale
sands of prediction requests per

03:45:56.000 --> 03:45:58.000
minute you need to find a way to
serve that model at scale.

03:45:59.905 --> 03:46:00.932
Because TensorFlow is over 
source you can train them 

03:46:00.933 --> 03:46:02.933
anywhere but this is 

03:46:04.810 --> 03:46:07.710
about Google Cloud platform.  On
Cloud machine engine learning 

03:46:07.711 --> 03:46:09.711
you 

03:46:12.336 --> 03:46:17.571
can run distributed training 
with GPUs and TPUs.  You can 

03:46:17.572 --> 03:46:20.385
also deploy your trained model 
to Machine Learning engine and 

03:46:20.386 --> 03:46:22.386
then use 

03:46:24.093 --> 03:46:26.178
the ML engine API to access 
scalable online and batch 

03:46:26.179 --> 03:46:28.254
prediction for your model.  One 
of the great things is there's 

03:46:28.255 --> 03:46:33.199
no lock in.  Let's say I want to
make use of ML engine for 

03:46:33.200 --> 03:46:35.873
training my model but then I 
want to download my model and 

03:46:35.874 --> 03:46:37.874
service it someplace else.

03:46:40.186 --> 03:46:41.415
That's easy to do and I can do 
the reverse as well.  I'm going 

03:46:41.416 --> 03:46:43.416
to talk about two different 

03:46:47.729 --> 03:46:49.729
times of custom models using 
tvrs.

03:46:50.871 --> 03:46:53.156
The first is transfer learning 
which let's us update an xating 

03:46:53.157 --> 03:46:57.664
trained model use our own data 
and then talking about training 

03:46:57.665 --> 03:46:59.665
a model from scratch using only 
your data.

03:47:03.837 --> 03:47:06.123
So transfer learning is great if
you need a custom model but 

03:47:06.124 --> 03:47:08.124
don't have enough training data.

03:47:13.454 --> 03:47:15.454
It let's you utilize an existing

03:47:16.509 --> 03:47:19.438
retrained model to do something 
similar to what we are trying to

03:47:19.439 --> 03:47:21.439
do and take the 

03:47:24.759 --> 03:47:26.397
weights of that and take a 
couple of layers with our own 

03:47:26.398 --> 03:47:28.398
training data.  

03:47:32.216 --> 03:47:34.216
So I wanted to build an end to 
end 

03:47:35.676 --> 03:47:37.676
example showing how to train a 
model and building an app.

03:47:39.974 --> 03:47:41.974
I know a little bit of swift so 
I 

03:47:43.915 --> 03:47:45.915
decided to build an iOS app.

03:47:47.730 --> 03:47:49.730
You upload a picture of your 
pet, it's 

03:47:52.256 --> 03:47:55.098
able to detect where the pet is 
in the image and what type of 

03:47:55.099 --> 03:47:57.099
breed it's.

03:48:00.146 --> 03:48:02.146
There's a library of top of 
TensorFlow 

03:48:04.180 --> 03:48:08.380
to let you do object detection 
which is identifying a bounding 

03:48:04.180 --> 03:48:08.076
box.  I trained the model on 
Machine Learning engine.

03:48:11.167 --> 03:48:13.438
And then I used a couple of 
Firebase APIs to build a front 

03:48:13.439 --> 03:48:18.803
end for my app.  This is a full 
architecture diagram.  IOS 

03:48:18.804 --> 03:48:21.716
client is actually a pretty tlin
client.  What it's doing is it's

03:48:21.717 --> 03:48:23.955
uploading images to closed 
storage for Firebase 

03:48:27.659 --> 03:48:29.487
and I've got a cloud function 
that is on that bucket so that 

03:48:29.488 --> 03:48:31.488
function is going to 

03:48:32.741 --> 03:48:34.741
be triggered any time a image is
uploaded.

03:48:38.524 --> 03:48:40.424
It sendss to Machine Learning 
engine for prediction and the 

03:48:40.425 --> 03:48:43.101
prediction I get back is going 
to be a confidence value, 

03:48:48.449 --> 03:48:50.916
label and bounding box detail 
for where that pet is in my 

03:48:50.917 --> 03:48:52.917
image.

03:48:53.965 --> 03:48:55.965
I store the metadata in fire 
store. 

03:48:57.016 --> 03:49:00.502
Here is an example showing how 
the front end works.  So this is

03:49:00.503 --> 03:49:02.503
a screen shot of fire store.

03:49:04.988 --> 03:49:06.484
We can see when ever my image 
data is uploaded to fire store I

03:49:06.485 --> 03:49:09.537
write the new image with the box
around it to a Cloud storage 

03:49:09.538 --> 03:49:14.026
bucket.  
So that was an example of 

03:49:14.027 --> 03:49:16.027
transfer 

03:49:17.298 --> 03:49:19.298
learning learning.

03:49:21.849 --> 03:49:23.849
Say we have a custom task and 
can 

03:49:25.112 --> 03:49:27.112
build enough data entirely from 
scratch.

03:49:28.988 --> 03:49:30.988
This is a demi of a model that 
predicts the price of wine.

03:49:33.098 --> 03:49:35.098
Can we predict the price?

03:49:36.573 --> 03:49:37.414
This is what an example input 
and prediction for a model would

03:49:37.415 --> 03:49:39.415
be.

03:49:41.527 --> 03:49:43.995
One reason this is well-suited 
for Machine Learning is I can't 

03:49:43.996 --> 03:49:45.687
write rules to determine what 
the price of this wine should 

03:49:45.688 --> 03:49:47.688
be.

03:49:50.935 --> 03:49:52.935
I can't say any wine with

03:49:54.706 --> 03:49:57.796
the vanilla in the description 
is going to be a cheap wine.  So

03:49:57.797 --> 03:50:00.472
I want to see if I can build a 
Machine Learning model to 

03:50:00.473 --> 03:50:03.929
extract insights from that data.
Because I'm training this model 

03:50:03.930 --> 03:50:08.839
from scratch there's no existing
model out there that does 

03:50:08.840 --> 03:50:10.840
exactly this task.

03:50:13.169 --> 03:50:15.815
I'm going to need a lot of data.
I use Kaggle.  It's part of 

03:50:15.816 --> 03:50:19.725
Google.  If you're new to 
Machine Learning and looking for

03:50:19.726 --> 03:50:22.685
interesting data sets to play 
around with I recommend checking

03:50:24.700 --> 03:50:26.713
out Kaggle.  It has a wine 
review data set.

03:50:30.651 --> 03:50:32.840
I found this on 150,000 
different kinds of wine.  For 

03:50:32.841 --> 03:50:36.707
each wine it has a lot of data 
on description, the points 

03:50:32.841 --> 03:50:37.715
rating, the price, et cetera.  
I'm just using the description, 

03:50:37.716 --> 03:50:41.445
the variety and the price for 
this model.  

03:50:43.718 --> 03:50:45.360
The next step is to choose API 
I'm going the use to build my 

03:50:45.361 --> 03:50:48.825
model which TensorFlow API and 
the type of model I want to use.

03:50:53.053 --> 03:50:57.436
So I chose to use the Tf.Keras 
API.

03:51:01.104 --> 03:51:03.568
And the TensorFlow API includes 
a full implementation of Keras.

03:51:06.826 --> 03:51:08.826
It makes it easy for us to 
define the layers of our model.

03:51:10.709 --> 03:51:12.709
You can also use a lower level 

03:51:13.810 --> 03:51:15.810
TensorFlow API.

03:51:17.653 --> 03:51:19.653
So I chose to use the tf.

03:51:23.064 --> 03:51:26.320
Keras API and chose to build a 
wide and deep model.  It's a 

03:51:26.321 --> 03:51:28.778
fans way of saying I'm going to 
represent the inputs to my model

03:51:28.779 --> 03:51:30.779
in two different ways.

03:51:32.479 --> 03:51:34.742
A linear model, that's the wide 
part.  That's good at memorizing

03:51:37.381 --> 03:51:39.381
relationships between inputs.

03:51:42.307 --> 03:51:44.146
And a deep neural net which is 
good at generalizing data it 

03:51:44.147 --> 03:51:46.147
hasn't seen before.

03:51:50.293 --> 03:51:52.760
The input to our wide model is 
going to be sparse around the 

03:51:52.761 --> 03:51:54.761
input to the 

03:51:57.258 --> 03:51:59.258
deep is going to be dense 
embedding vectors.

03:52:00.716 --> 03:52:03.408
This is all using the Keras 
functional API to define the 

03:52:03.409 --> 03:52:06.313
wide model.  I'm going the use 
what is called a bag of words 

03:52:06.314 --> 03:52:11.003
representation.  What this does 
is takes all the words that 

03:52:11.004 --> 03:52:12.475
occur across all my wine 
descriptions and I'm going to 

03:52:12.476 --> 03:52:16.985
choose the top -- I choose to 
use the top 12,000 because this 

03:52:16.986 --> 03:52:18.986
is a hyper parameter you can 
tune.

03:52:20.058 --> 03:52:22.058
Each input to my model is going 
to be 

03:52:24.337 --> 03:52:26.365
at 12,000 element vector with 
ones and zeros indicating 

03:52:26.366 --> 03:52:28.366
whether or not the word 

03:52:30.652 --> 03:52:32.652
from my vocabulary is present in
this description.

03:52:33.923 --> 03:52:36.400
This wide model just takes into 
account whether or not this word

03:52:36.401 --> 03:52:40.891
from my vocabulary is present in
that specific description.  This

03:52:40.892 --> 03:52:42.892
type of input is going to look 
like this.

03:52:44.818 --> 03:52:46.818
It's going to be a 12,000 
element bag of words vector.

03:52:50.742 --> 03:52:52.742
The way I'm representing my 
variety, 

03:52:54.837 --> 03:52:56.837
this is going to be a 40 element
one hot 

03:52:59.537 --> 03:53:01.785
vector with each index and the 
vector corresponding to a 

03:53:01.786 --> 03:53:04.839
different variety of wine.  I'm 
going to output to my model 

03:53:06.268 --> 03:53:08.268
indicating what the price of 
that wine is. 

03:53:09.750 --> 03:53:11.750
If I just wanted to use the wide
model I 

03:53:14.416 --> 03:53:16.416
can take the wide model I have 
here, run

03:53:19.289 --> 03:53:21.289
run training and evaluation on 
it using 

03:53:23.815 --> 03:53:25.815
Keras but I fund better accuracy
using wide and deep.

03:53:28.853 --> 03:53:30.474
Word em betting let's us define 
the relationships between words 

03:53:30.475 --> 03:53:34.934
in vector space.  Words that are
similar to each other are going 

03:53:34.935 --> 03:53:36.935
to be closer together in vector 
space.

03:53:39.280 --> 03:53:41.143
There's lots of reading out 
there so I'm not going to focus 

03:53:41.144 --> 03:53:43.144
on the details.

03:53:44.974 --> 03:53:46.974
I can choose

03:53:48.105 --> 03:53:50.951
the dimensionality of that 
space.  In this case you can see

03:53:50.952 --> 03:53:52.952
I used an eight dimensional 
embedding space.

03:53:56.339 --> 03:54:00.007
I obviously can't feed the text 
directly into my model.  I need 

03:54:00.008 --> 03:54:02.008
to put night a format that my 
model can understand.

03:54:03.884 --> 03:54:05.755
I encoded each word as an 
integer.  This what is the input

03:54:05.756 --> 03:54:07.756
to my deep model is going to 
look like.

03:54:10.892 --> 03:54:13.138
The inputs need to be the same 
lengths but not all my 

03:54:13.139 --> 03:54:15.591
description are the same Lindt. 
None of my descriptions are 

03:54:15.592 --> 03:54:17.641
longer than 170 words.

03:54:22.618 --> 03:54:26.897
If they're shorter I'll tack 
that vectors with zeros.  We are

03:54:26.898 --> 03:54:28.898
still predicting the price. 

03:54:33.153 --> 03:54:34.683
Using the Keras functional API 
it's relatively straightforward 

03:54:34.684 --> 03:54:37.673
to combine

03:54:41.213 --> 03:54:43.213
the outputs and my combined 
model.

03:54:44.677 --> 03:54:46.677
I choose to do Machine Learning 
engine.

03:54:49.822 --> 03:54:53.145
First is to package and put it 
in Google Cloud storage.  I put 

03:54:53.146 --> 03:54:55.146
it in trainer director.

03:54:57.237 --> 03:54:59.237
I put my wine in data directory 
and 

03:55:00.502 --> 03:55:01.543
have this defining the 
dependencies that my model is 

03:55:01.544 --> 03:55:03.544
going to use.

03:55:04.812 --> 03:55:06.812
To run that training job I can 
use G 

03:55:09.099 --> 03:55:11.951
Cloud which is our Google Cloud 
CLI for interacting with a 

03:55:11.952 --> 03:55:13.952
number of different Google Cloud
products.

03:55:19.143 --> 03:55:22.138
I save my model file which is a 
binary file to Google cloud 

03:55:22.139 --> 03:55:24.139
storage.

03:55:25.230 --> 03:55:29.830
Let's see a demo of generating 
some predictions on that model. 

03:55:29.831 --> 03:55:31.831
I'm going to use a tool called 
co-lab 

03:55:33.230 --> 03:55:35.230
and this is

03:55:37.597 --> 03:55:39.634
a cloud hosted Jupiter notebook.
What I've done is saved that 

03:55:39.635 --> 03:55:41.635
model 

03:55:44.554 --> 03:55:47.407
file in Google Cloud storage and
now I'm going to save 

03:55:47.408 --> 03:55:50.285
predictions.  Here we are just 
imparting libraries 

03:55:53.335 --> 03:55:55.335
we are going to use, I'm loading
my 

03:55:56.404 --> 03:55:59.715
model, next step is to load the 
tokenizeer from my model.  This 

03:55:59.716 --> 03:56:02.157
is just an index associating all
the words in my vocabulary with 

03:56:02.158 --> 03:56:04.158
a number 

03:56:05.653 --> 03:56:07.757
and I'm loading my variety and 
coder, too.  I'm going to ignore

03:56:07.758 --> 03:56:12.260
that warning.  Here I'm going to
load in some raw data.  What I 

03:56:12.261 --> 03:56:14.737
have here is data on five 
different wines.  I've got the 

03:56:14.738 --> 03:56:17.595
description, the variety and the
associated price for each of 

03:56:18.012 --> 03:56:20.679
these wines.  
And I wanted to show you what 

03:56:20.680 --> 03:56:23.984
the input looks like for each of
these.  Now we need to encode 

03:56:23.985 --> 03:56:27.706
each of those into the wide and 
deep format that our model is 

03:56:27.707 --> 03:56:30.172
expecting.  We have this 
vocabulary look up.

03:56:33.716 --> 03:56:35.960
I'm printing a subset of it 
here.  This is going to be 

03:56:35.961 --> 03:56:41.444
12,000 elements long for the top
12,000 words in our vocabulary 

03:56:41.445 --> 03:56:43.445
and Keras has utilitys to 

03:56:45.342 --> 03:56:48.226
help us extract those top words.
And each index corresponding to 

03:56:48.227 --> 03:56:51.543
a different variety.  Let's see 
what the input to our wide model

03:56:51.544 --> 03:56:55.003
looks like. 
So the finish thing is our text.

03:56:57.460 --> 03:57:00.326
This is a bag of words vector.  
It's a 12,000 element vector 

03:57:00.327 --> 03:57:02.632
with zeros and ones indicating 
the presence 

03:57:06.322 --> 03:57:08.322
or absence of different words in
the vocabulary.

03:57:11.665 --> 03:57:14.928
I believe that first wine was a 
pinot noir.  We can confirm yes 

03:57:14.929 --> 03:57:20.273
that was.  So that's the input 
to our wide model.  Our deep 

03:57:20.274 --> 03:57:22.340
model we are just encoding all 
the words from that first 

03:57:25.361 --> 03:57:27.361
description as integers and 
padding it with zeros.

03:57:30.565 --> 03:57:33.457
All I need to do to generate 
predictions on Keras model is 

03:57:33.458 --> 03:57:37.321
called dot predict.  What I'm 
doing here is now going to loop 

03:57:37.322 --> 03:57:39.352
through those predictions and 
see how the model performed 

03:57:39.353 --> 03:57:42.199
compared to the actual price.  
We can see it did a pretty good 

03:57:42.200 --> 03:57:44.720
job on the first 1, 46 compared 
to 48.

03:57:49.476 --> 03:57:52.370
This one was about $30 off but 
it was still able to understand 

03:57:52.371 --> 03:57:56.838
it was a higher priced wine and 
it did pretty well on the rest 

03:57:56.839 --> 03:57:59.516
of these as well.  I'll have a 
link to this at the end.

03:58:02.976 --> 03:58:04.193
You can go to this URL, enter 
your own wine descriptions and 

03:58:04.194 --> 03:58:06.194
see how the model perform also. 

03:58:08.073 --> 03:58:10.073
If we can go back to the slides 
I'll 

03:58:11.388 --> 03:58:13.659
talk about a few companies using
TensorFlow and Machine Learning.

03:58:17.669 --> 03:58:19.669
The first example is

03:58:22.639 --> 03:58:24.639
is Rolls-Royce

03:58:30.316 --> 03:58:32.316
.  Oh cado is the UK's largest 
grocery delivery service.

03:58:34.601 --> 03:58:36.601
They got tons of customer 
support e-mails every day.

03:58:40.115 --> 03:58:42.115
They built a model to predict 
whether 

03:58:43.192 --> 03:58:45.650
the e-mail requires an urgent 
response or no response at all.

03:58:48.907 --> 03:58:50.741
Airbus has built a custom image 
classification model to identify

03:58:50.742 --> 03:58:52.742
things 

03:58:54.769 --> 03:58:56.935
in satellite I imagery.  So I 
know I covered a ton of 

03:58:57.370 --> 03:58:59.370
different products.

03:59:01.710 --> 03:59:03.336
I wanted to give you a summary 
of what resources all these 

03:59:03.337 --> 03:59:07.293
products require.  These are 
four resources I thought of that

03:59:07.294 --> 03:59:10.164
you need to solve a Machine 
Learning problem.  There's 

03:59:10.165 --> 03:59:12.165
probably more that I don't have 
on here.

03:59:16.740 --> 03:59:18.567
Training data, mobile code, 
training and serving 

03:59:18.568 --> 03:59:20.850
infrastructure and overall how 
long is this task going to take 

03:59:20.851 --> 03:59:25.141
you?  So if you look at our 
Machine Learning APIs, great 

03:59:25.142 --> 03:59:28.615
thing about these you don't need
any training data.  You can 

03:59:28.616 --> 03:59:31.068
start generating prediction on 
one image.  You don't need to 

03:59:31.069 --> 03:59:33.069
write any of the 

03:59:34.733 --> 03:59:36.733
model code you don't need to 
provide any 

03:59:37.737 --> 03:59:39.883
serving or serving 
infrastructure and you can 

03:59:41.750 --> 03:59:43.750
probably get started with these 
in less than a day.

03:59:46.682 --> 03:59:49.116
The cool thing about AutoML is 
you will be providing your own 

03:59:49.117 --> 03:59:51.117
training data.  It will take a 
little more time 

03:59:53.850 --> 03:59:55.850
because you would need to spend 
time 

03:59:58.284 --> 04:00:00.284
processing images, uploading 
them

04:00:02.469 --> 04:00:04.469
to the cloud and maybe labeling 
them.

04:00:06.568 --> 04:00:09.458
And finally if we think about a 
custom model TensorFlow running 

04:00:09.459 --> 04:00:11.497
on Cloud ML engine you would 
need a lot of training 

04:00:14.609 --> 04:00:16.240
data, you will have to write a 
lot of the model code yourself 

04:00:16.241 --> 04:00:18.241
and you would think about 
whether you want to run your 

04:00:21.004 --> 04:00:23.004
training and service jobs on 
premise, 

04:00:24.452 --> 04:00:26.085
and obviously this process will 
take a little bit more time. 

04:00:26.086 --> 04:00:28.333
Finally if you remember only 
three 

04:00:32.627 --> 04:00:34.627
things from this presentation, 
first 

04:00:36.052 --> 04:00:38.052
thing you can use

04:00:40.081 --> 04:00:44.374
a pretrained API to accomplish 
common Machine Learning tasks.  

04:00:44.375 --> 04:00:46.621
Second thing, if you want to 
build an image classification 

04:00:46.622 --> 04:00:48.622
API, train on your 

04:00:49.889 --> 04:00:51.932
own data, use AutoML Vision.  
I'm interested to hear if you 

04:00:51.933 --> 04:00:53.933
have a 

04:00:54.980 --> 04:00:57.263
specific use case for Auto ML 
vision.  Find me afterwards.

04:01:01.180 --> 04:01:03.180
I'll be in the Cloud sandbox 
area.

04:01:05.858 --> 04:01:09.583
You can build a TensorFlow model
with your own data.  So here is 

04:01:09.584 --> 04:01:11.828
a lot of great resources 
covering everything I talked 

04:01:11.829 --> 04:01:16.520
about today.  I'll let you take 
a picture of that slide.  

04:01:20.198 --> 04:01:21.437
The video will also be up after 
so you can grab it from there as

04:01:21.438 --> 04:01:23.887
well.  And that's all I've got. 
Thank you. 

04:01:26.911 --> 04:01:29.450
(Applause). 
.  

04:01:29.451 --> 04:01:30.691
.  
.  

04:01:30.692 --> 04:01:32.520
.  
.  

04:01:32.521 --> 04:01:33.542
.  
.  

04:01:33.543 --> 04:01:38.222
.  
.   

04:01:44.471 --> 04:01:46.512
"Realtime captioning on this 
screen" .  

04:01:46.513 --> 04:01:48.513
.  
.

04:01:56.986 --> 04:01:59.092
.
&gt;&gt; Thank you for joining this 

04:01:59.093 --> 04:02:03.236
session.  Grand ambassadors will
assist with directing you 

04:02:03.237 --> 04:02:06.539
through the designated exits.  
We will be making room for those

04:02:06.540 --> 04:02:09.875
who registered for the next 
session.  If you've registered 

04:02:09.876 --> 04:02:11.876
for the next 

04:02:14.178 --> 04:02:16.178
session in this room, we ask 
that you 

04:02:18.708 --> 04:02:19.113
please clear the room and return
via the registration line 

04:02:19.114 --> 04:02:21.114
outside.  Thank you.

05:06:24.266 --> 05:06:26.266
.

05:06:27.285 --> 05:06:29.285
&gt;&gt;

05:06:31.408 --> 05:06:32.223
.  
.  

05:06:32.224 --> 05:06:35.912
.   
.  

05:06:35.913 --> 05:06:37.913
.

05:06:45.354 --> 05:06:47.389
What's new with constraint 
layout and 

05:06:50.410 --> 05:06:52.410
Android studio design tools.

05:07:02.132 --> 05:07:02.737
New With Constraint Layout and 
Android Studio Design Tools 

05:07:02.738 --> 05:07:04.738
.

05:16:30.546 --> 05:16:33.199
.
&gt;&gt; Welcome.  Please fill in the 

05:16:33.200 --> 05:16:35.200
seats near the front of the 
room.  Thank you.

05:19:24.073 --> 05:19:27.332
At this time please find your 
seat.  Our session will begin 

05:19:27.333 --> 05:19:29.333
soon.

05:22:06.343 --> 05:22:07.812
.  
.  

05:22:07.813 --> 05:22:08.844
.  
.  

05:22:08.845 --> 05:22:10.845
.  
.

05:22:33.354 --> 05:22:35.354
.
&gt;&gt; Hi.  

05:22:37.977 --> 05:22:41.587
(Applause).
&gt;&gt; All right.  So good 

05:22:41.588 --> 05:22:43.588
afternoon, everyone.

05:22:48.637 --> 05:22:50.637
My name Nick has Nicholas

05:22:55.630 --> 05:23:01.354
.  You might have noticed we 
released a really cool -- there 

05:23:01.355 --> 05:23:05.416
was a session this morning, it's
on YouTube, check it out.  It's 

05:23:05.417 --> 05:23:07.417
really cool.  

05:23:10.932 --> 05:23:12.932
So we are going to talk about 
the walk 

05:23:15.826 --> 05:23:17.826
we have been walking on this 
past year, 

05:23:19.864 --> 05:23:22.593
specifically we will focus on 
sample data and we will also 

05:23:22.594 --> 05:23:24.594
talk 

05:23:26.453 --> 05:23:28.453
about constraint layout 2.2 and 
what is coming up with these 

05:23:28.500 --> 05:23:30.735
libraries.  First for the 
section on the layout 

05:23:37.862 --> 05:23:38.667
editor, Vadim will present for 
you.  

05:23:38.668 --> 05:23:40.668
&gt;&gt; VADIM CAEN:  Thank you.  Hi, 
everyone.

05:23:43.354 --> 05:23:46.225
To start with we are going to 
talk about layout editor.

05:23:49.297 --> 05:23:51.333
It's a graphical cool without 
having to write any XML and it's

05:23:51.334 --> 05:23:53.334
supposed to make you more 
productive.

05:23:56.876 --> 05:23:59.307
So what is nice with the layout 
editor it also works with your 

05:23:59.308 --> 05:24:01.308
custom views.

05:24:04.819 --> 05:24:06.819
So if in your code you have a 
custom 

05:24:09.510 --> 05:24:11.988
view, the nice thing is that any
custom view from your project 

05:24:11.989 --> 05:24:13.989
will appear in the Palette.

05:24:15.438 --> 05:24:17.438
Our goal is to make you more 
productive.

05:24:18.953 --> 05:24:20.953
We added some nice features this
year to do so.

05:24:22.803 --> 05:24:28.343
The first one I want to talk 
about is the conversion.  So if 

05:24:28.344 --> 05:24:30.344
you right click on a view you'll

05:24:31.416 --> 05:24:34.109
see the conversion option that 
will make this pop up appear and

05:24:34.110 --> 05:24:36.110
you'll be able to 

05:24:37.131 --> 05:24:39.131
select

05:24:41.413 --> 05:24:47.134
one of the constraint component.
And this view is contextual so 

05:24:47.135 --> 05:24:49.135
if you 

05:24:50.200 --> 05:24:52.200
right click on a view which is 
not a 

05:24:55.330 --> 05:24:57.330
view group it will show some 
non-view group views.

05:24:58.796 --> 05:25:00.796
The next thing I want to talk 
about is 

05:25:02.805 --> 05:25:04.805
the navigation between included 
layout

05:25:07.341 --> 05:25:09.578
.  If you double click on the 
component it will jump 

05:25:09.579 --> 05:25:11.579
automatically.

05:25:14.063 --> 05:25:16.063
And if you jump to the arrow it 
will jump back.

05:25:18.145 --> 05:25:20.145
This is handy to be fast between
layouts.  

05:25:23.610 --> 05:25:25.610
The layout editor

05:25:27.587 --> 05:25:29.587
is really for constraint layout 
and 

05:25:31.441 --> 05:25:33.476
constraint layout is a great 
layout.  You might not want to 

05:25:33.477 --> 05:25:35.477
write all your XML by hand.

05:25:39.205 --> 05:25:41.205
What you should do instead is 
take all 

05:25:42.665 --> 05:25:43.683
the menus we have in the layout 
editor to generate this XML for 

05:25:43.684 --> 05:25:45.924
you.  Again, right click on the 
view and 

05:25:49.174 --> 05:25:50.999
then you can use the -- align 
any of the top option to choose 

05:25:51.000 --> 05:25:55.704
your option.  We have many of 
them so feel free to check them 

05:25:55.705 --> 05:25:57.705
after this session and it's 

05:25:59.180 --> 05:26:01.180
going to be make you more 
productive.

05:26:02.428 --> 05:26:05.080
Most of you be probably 
populating your layout, you have

05:26:05.081 --> 05:26:07.081
data from the 

05:26:09.915 --> 05:26:12.239
internet and you want to 
populate them.

05:26:16.125 --> 05:26:18.549
To serve this issue Diego will 
talk about sample layout.  

05:26:21.222 --> 05:26:23.222
&gt;&gt; DIEGO PEREZ:  Before we talk 
about 

05:26:25.552 --> 05:26:27.552
sample layout let's talk about 
the tools attributes.

05:26:29.609 --> 05:26:31.609
You actually use them to give 

05:26:32.615 --> 05:26:35.950
information to the Android 
studio.  We are not going to 

05:26:35.951 --> 05:26:37.951
talk about all of 

05:26:39.223 --> 05:26:41.094
them but let's cover one 
example.  You probably have seen

05:26:41.095 --> 05:26:43.095
this.

05:26:45.108 --> 05:26:47.629
So in your string file you get a
warning 

05:26:52.749 --> 05:26:55.807
saying you haven't translated in
a particular stream.  That's it,

05:26:55.808 --> 05:26:58.696
the error is gone.  But there 
might be situation where you 

05:26:59.287 --> 05:27:02.971
don't want this.  It could be 
it's the name of the application

05:27:02.972 --> 05:27:04.972
and you don't want the 

05:27:06.436 --> 05:27:07.647
translate it in every single 
language, only certain 

05:27:07.648 --> 05:27:09.648
languages.

05:27:10.901 --> 05:27:12.901
You can basically tell look I 
know 

05:27:14.978 --> 05:27:16.619
about the server but I don't 
want you to tell me about it 

05:27:16.620 --> 05:27:20.479
because it's fine.  So that is 
one example.  There are many 

05:27:20.480 --> 05:27:23.335
others.  But what we want to 
talk about now is 

05:27:27.604 --> 05:27:29.604
actually design time attributes.

05:27:31.138 --> 05:27:33.138
This is the tools attributes 
that I talked about.  

05:27:35.211 --> 05:27:37.044
There are additional information
and content to the layout 

05:27:37.045 --> 05:27:39.045
editor.  Let's see one example.

05:27:41.114 --> 05:27:43.114
So in this case what we have is 
we created our Toolbar.

05:27:46.431 --> 05:27:48.522
We had to keep the layout on its
own so we use constraint layout.

05:27:50.793 --> 05:27:52.793
This is how it will look.

05:27:54.690 --> 05:27:56.930
What you can see is the Toolbar 
without any context but you done

05:27:56.931 --> 05:28:01.013
see the layout so you don't know
how it going to look.  So there 

05:28:01.014 --> 05:28:03.014
is something we can do.

05:28:05.932 --> 05:28:07.972
You can again tell the layout 
editor this layout is going to 

05:28:07.973 --> 05:28:09.973
be included in this other layout
here.

05:28:13.503 --> 05:28:15.746
So using this attribute to show.
We are letting the layout know 

05:28:15.747 --> 05:28:17.747
that we 

05:28:18.806 --> 05:28:20.806
want to embed this header into 
the main layout.

05:28:22.703 --> 05:28:24.703
And that way we can see the 
context so 

05:28:26.413 --> 05:28:28.229
now when we have editing we know
if the colors match we can tweak

05:28:28.230 --> 05:28:30.230
our design and 

05:28:31.687 --> 05:28:33.687
see how every chain impacts our 
layout.  

05:28:35.775 --> 05:28:38.225
And the best thing is again you 
can do it -- you can edit it 

05:28:38.226 --> 05:28:41.934
right there.  You don't have to 
see with that blank space or 

05:28:41.935 --> 05:28:43.935
anything like that.

05:28:45.389 --> 05:28:47.389
Let's see another interesting 
use of this.

05:28:49.465 --> 05:28:51.465
When you have the text view this
is 

05:28:53.323 --> 05:28:56.787
usually what you get so you have
hello world and that's it.  But 

05:28:56.788 --> 05:28:59.028
you can tell to the layout 
editor that you know this is 

05:28:59.029 --> 05:29:05.361
going to look different and do 
you that but using the tools.  

05:29:05.362 --> 05:29:09.022
In in case we are replacing both
the text and the text color.  

05:29:09.023 --> 05:29:10.650
And we are telling the layout 
editor at run time this is going

05:29:10.651 --> 05:29:12.651
to look different.

05:29:15.525 --> 05:29:18.682
And we are good to see how this 
is very useful.  

05:29:21.539 --> 05:29:23.539
When you are in the recycler 
view this 

05:29:25.157 --> 05:29:29.128
is what you get by default.  You
can see how it's laid out but 

05:29:29.129 --> 05:29:36.246
it's not very useful.  It's just
a list of elements with a lot of

05:29:36.247 --> 05:29:38.247
empty space.

05:29:39.299 --> 05:29:41.946
We can use the tools attributes,
you basically let the layout 

05:29:41.947 --> 05:29:47.302
editor know.  This is the layout
that I'm going to use.  You have

05:29:47.303 --> 05:29:50.568
probably seen list item many 
times, very simple.  You can say

05:29:50.569 --> 05:29:52.569
we can do other things.

05:29:53.628 --> 05:29:55.293
We can tell the layout editor 
how is this going to look with 

05:29:55.294 --> 05:29:59.363
five elements?  All these things
you usually cannot do them in 

05:29:59.364 --> 05:30:02.215
the layout editor because these 
are things that happen at run 

05:30:02.216 --> 05:30:04.216
time so usually the source of 
information for a 

05:30:08.535 --> 05:30:11.788
recycler view is an adapter.  It
might depend on many things.  

05:30:11.789 --> 05:30:13.789
So doing this you give us 
context and 

05:30:17.113 --> 05:30:19.167
then the layout editor will 
render correctly similar to what

05:30:19.168 --> 05:30:21.168
you have in run time.

05:30:23.874 --> 05:30:25.874
So let's now go into sample 
data.

05:30:28.359 --> 05:30:31.019
Sample data was introduced in 3.
0.  It helps you to actually 

05:30:31.020 --> 05:30:35.488
populate data that is not 
available at this time.  So in 

05:30:35.489 --> 05:30:38.168
this case what we are doing is 
telling the layout editor that I

05:30:38.169 --> 05:30:40.863
want to use the theme property 
and get the data 

05:30:46.172 --> 05:30:48.172
from this data source which we 
call a sample.

05:30:49.443 --> 05:30:52.106
And that data source is simply a
file with a list of colors that 

05:30:52.107 --> 05:30:54.950
you see there.  
So what happens in the design 

05:30:54.951 --> 05:30:58.627
time is the layout editor will 
get a different color for every 

05:30:58.628 --> 05:31:01.677
item.  So that looks better.  
But we can do more.

05:31:04.730 --> 05:31:06.730
So let's see how you create that
file.

05:31:08.382 --> 05:31:10.382
You go to your project, new, 
sample 

05:31:12.669 --> 05:31:15.549
data directory and that's how we
create the directory what we are

05:31:15.550 --> 05:31:18.417
going to put every data serve 
that we have.

05:31:21.897 --> 05:31:23.897
We want colors so new file and 
then we 

05:31:29.037 --> 05:31:30.672
name it and we just put the list
of colors and that's it.  It's 

05:31:30.673 --> 05:31:34.371
that simple.  Now you can use it
in any property.  

05:31:36.650 --> 05:31:38.717
So this is one of the types of 
data sources that you can use in

05:31:38.718 --> 05:31:43.219
sample data.  So it's basically 
a list of colors.  You can have 

05:31:43.220 --> 05:31:45.220
lists of any kind of that 

05:31:46.274 --> 05:31:49.123
you want like regular text and 
just replace it.  But you can 

05:31:49.124 --> 05:31:51.372
have other things more 
interesting like you can have 

05:31:53.422 --> 05:31:56.286
dimensions, so if you have 
dimensions using the tools 

05:31:56.287 --> 05:31:58.325
attributes you can to the layout
editor I want to use this 

05:32:00.794 --> 05:32:03.444
dimension and I wants it to be 
different for every item and you

05:32:03.445 --> 05:32:06.702
can do that using sample data.  
We also have other types of data

05:32:07.357 --> 05:32:09.357
sources.  You can have images.

05:32:12.858 --> 05:32:14.918
You're create it in a similar 
way.  Instead of a file you 

05:32:14.919 --> 05:32:19.602
create a director and drop all 
your images in there.  And 

05:32:19.603 --> 05:32:22.050
recycler view will get a 
different image for every item 

05:32:22.051 --> 05:32:25.983
so it's very simple. 
The last part I want to tell you

05:32:25.984 --> 05:32:29.668
about is JSON files.  JSON files
is a similar way to the 

05:32:33.946 --> 05:32:35.789
list that we had before but it 
allows to do something, you can 

05:32:35.790 --> 05:32:37.790
have all your data together in 
one place.

05:32:41.096 --> 05:32:43.376
You can add maybe context about 
why a particular item is like 

05:32:43.377 --> 05:32:45.377
that or you can 

05:32:49.933 --> 05:32:51.543
even get a sample from your AVI 
and put it into your sample 

05:32:51.544 --> 05:32:53.544
data.

05:32:55.013 --> 05:32:57.013
We have a list of notes.

05:33:00.304 --> 05:33:02.304
We have a title and an album.

05:33:04.262 --> 05:33:05.681
You can reference any of those 
elements.  Let's see how to do 

05:33:05.682 --> 05:33:07.745
that.  In this case what we are 
telling the 

05:33:11.011 --> 05:33:13.011
layout editor is I want you to 
replace 

05:33:15.509 --> 05:33:17.509
text of design time and do it 
with the 

05:33:18.551 --> 05:33:22.218
name of the JSON file and then 
the node that we saw before.  In

05:33:22.219 --> 05:33:25.676
this case we are doing it with 
title and album.  Remember this 

05:33:25.677 --> 05:33:28.993
will change depending on the 
name of the JSON file.  It 

05:33:28.994 --> 05:33:31.023
doesn't even need to be called 
JSON.  If you don't want to 

05:33:31.024 --> 05:33:33.024
provide your own 

05:33:34.496 --> 05:33:36.757
data sources, Android studio 
will also provide -- it already 

05:33:36.758 --> 05:33:38.758
comes with a set 

05:33:40.228 --> 05:33:43.477
of predefined ones so you don't 
have to create your own.  We 

05:33:43.478 --> 05:33:45.478
give you a set of them, we give 
you 

05:33:46.933 --> 05:33:48.933
names, and we also give you a 
set of images.

05:33:50.418 --> 05:33:52.499
For example you can use Avatars 
and you don't need to create 

05:33:52.500 --> 05:33:54.763
images.  You can just use the 
ones that we give you.

05:33:58.002 --> 05:34:00.443
Again, how to use that is very 
similar.  The only difference 

05:34:00.444 --> 05:34:02.444
that you can see 

05:34:03.928 --> 05:34:05.928
here is we added tools of the 
data source.

05:34:08.398 --> 05:34:10.398
Instead of being a sample now is
a tool sample.

05:34:13.668 --> 05:34:15.668
Using

05:34:17.805 --> 05:34:19.694
syntax completion you can see 
all the data sources we have.  

05:34:19.695 --> 05:34:21.695
In 3.2 we added new features.

05:34:24.040 --> 05:34:26.040
So everything we saw was already

05:34:29.156 --> 05:34:31.156
available in 3 L3 L.

05:34:33.473 --> 05:34:35.473
.

05:34:36.754 --> 05:34:39.010
&gt;&gt; Sample data is a great tool 
so we decided to put a UI on top

05:34:39.011 --> 05:34:42.487
of it.  So what does it look 
like?  I'm sure most of you 

05:34:42.488 --> 05:34:45.361
already did that so we have 
image view.

05:34:50.823 --> 05:34:52.823
You're taking it from the pallet
and the pallet.

05:34:56.035 --> 05:34:58.035
Since you started your project 
you 

05:34:59.226 --> 05:35:01.226
only have

05:35:02.963 --> 05:35:04.963
the launcher icon available.

05:35:06.192 --> 05:35:08.192
You have the sample data and you
can 

05:35:09.292 --> 05:35:11.292
pick any resource data from your
project.

05:35:12.956 --> 05:35:14.374
So now our image looks better 
and we can see it in our 

05:35:14.375 --> 05:35:16.375
recycler view.  

05:35:18.233 --> 05:35:20.233
But what if you want to make 
some change to this sample data?

05:35:23.530 --> 05:35:25.530
What if I want to use one simple
image for myself?

05:35:30.027 --> 05:35:32.027
We introduced in 3.2 a new 
design time helper.

05:35:35.794 --> 05:35:37.794
So here I'm going to uncheck and
this 

05:35:39.466 --> 05:35:40.499
will give me the ability to 
select only one image from my 

05:35:40.500 --> 05:35:47.638
set.  And I can try it out with 
any e-mail from this set.  But 

05:35:47.639 --> 05:35:49.466
now let's say we want to give it
another look and pick images 

05:35:49.467 --> 05:35:51.467
from another data set.

05:35:54.770 --> 05:35:57.437
So we can just use this and 
select another data set and here

05:35:57.438 --> 05:36:02.518
we go, our recycler view has a 
brand new look so it's nice to 

05:36:02.519 --> 05:36:06.681
preview what it would look like.
So you can always jump back to 

05:36:06.682 --> 05:36:08.682
the resource picker and there's 
a full set 

05:36:11.825 --> 05:36:13.825
of resources available by 
clicking the 

05:36:16.321 --> 05:36:18.360
button on the bottom of the pop 
up.  And the same options are 

05:36:18.361 --> 05:36:21.006
available.  If you select a 
sample data on the 

05:36:24.607 --> 05:36:26.688
resource picker it will populate
design image so it will be 

05:36:26.689 --> 05:36:30.957
removed at one time.  
We have the same design time 

05:36:30.958 --> 05:36:32.958
helper for text view.

05:36:35.031 --> 05:36:37.031
So here I'm just selecting 
different 

05:36:38.319 --> 05:36:40.319
sets for each view and as you 
can see on 

05:36:42.215 --> 05:36:45.196
the recycler view each item is 
taking one instance of each own 

05:36:45.197 --> 05:36:50.625
set for each item.  And finally 
we have also added this 

05:36:57.524 --> 05:36:59.524
feature for recycler view

05:37:02.466 --> 05:37:06.527
.  You can just jump back to the
file and preview your changes.  

05:37:06.528 --> 05:37:08.349
All the design time attributes 
are automatically populated so 

05:37:08.350 --> 05:37:12.432
you don't have to do anything 
and take full advantage of 

05:37:12.433 --> 05:37:14.433
sample data.  

05:37:16.542 --> 05:37:17.972
But it's even more helpful if 
you use it with constraint 

05:37:17.973 --> 05:37:20.874
layout.  Nicholas is going to 
come on stage and 

05:37:25.353 --> 05:37:27.353
do a deep dive with constraint 
layout.

05:37:30.047 --> 05:37:33.535
&gt;&gt; NICHOLAS ROARD:  We released 
constraint layouts officially 

05:37:33.536 --> 05:37:36.407
last year.  So if you don't know
about it, it's a 

05:37:39.908 --> 05:37:41.908
library that allows you to 
create your interfaces.

05:37:43.421 --> 05:37:45.888
And we tried to use flat 
hierarchies which is coming very

05:37:45.889 --> 05:37:47.889
handy for automations.

05:37:50.637 --> 05:37:54.717
It's compatible essentially 
everywhere.  It's small. .

05:37:58.547 --> 05:38:00.547
It comes with

05:38:01.840 --> 05:38:03.840
a great UI builder.  Please try 
to use it.

05:38:07.750 --> 05:38:09.790
It's something we are working 
onto help make your life easier.

05:38:15.480 --> 05:38:17.480
We release it constraint layout 
1.2 last year.

05:38:20.744 --> 05:38:24.665
You can set up your0 last year. 
You can set up your UI, there's 

05:38:24.666 --> 05:38:26.666
a lot of capabilities here.

05:38:30.592 --> 05:38:32.219
And there's some helper object 
like guidelines to help you set 

05:38:32.220 --> 05:38:34.220
up your screen.

05:38:35.485 --> 05:38:37.485
So it's already very full set of
features.

05:38:41.195 --> 05:38:45.276
But a month ago we related 
constraint layout 1.1 with a lot

05:38:45.277 --> 05:38:47.277
of fixes, improvements, new 

05:38:49.092 --> 05:38:54.907
features, now ways of increasing
your layout.  There's one which 

05:38:54.908 --> 05:38:56.908
allows you to 

05:38:58.127 --> 05:38:59.542
position an element relative to 
a set of elements so whatever 

05:38:59.543 --> 05:39:01.543
the position and 

05:39:02.598 --> 05:39:03.622
dimension of those elements that
element on the right is going to

05:39:03.623 --> 05:39:07.093
position correctly.  
So essentially with constraint 

05:39:07.094 --> 05:39:12.387
layout 1.1 we have really 
flexible layout, something that 

05:39:12.388 --> 05:39:15.270
should essentially lept you 
express any UI.

05:39:20.179 --> 05:39:21.161
And you can just add to it yourt
you express any UI.  And you can

05:39:21.162 --> 05:39:23.162
just add to it your 

05:39:24.383 --> 05:39:26.383
project, we are now shifting so 
it 

05:39:28.280 --> 05:39:30.280
should be very easy for you to 
use it.

05:39:32.403 --> 05:39:34.846
But I think a lot of you here or
in this room to hear me talk 

05:39:34.847 --> 05:39:36.847
about 

05:39:37.856 --> 05:39:39.856
constraint layout

05:39:41.596 --> 05:39:44.906
are in this room to hear me talk
about constraint layout 2.0.  

05:39:44.907 --> 05:39:47.808
It's a great base.  It gives 
flexibility that you need to 

05:39:50.660 --> 05:39:53.525
create a UI and comes with a UI 
builder. 

05:39:56.174 --> 05:39:59.679
One of the concepts was the 
concept of helper object.  

05:39:59.680 --> 05:40:01.680
Object that even though you can 

05:40:03.168 --> 05:40:05.882
manipulate them into the UI 
builder, they do not appear on 

05:40:05.883 --> 05:40:08.346
your screen when you run the 
application but essentially 

05:40:11.406 --> 05:40:13.657
they help you create your UI so 
one of them is the guideline 

05:40:13.658 --> 05:40:15.658
object, the 

05:40:19.830 --> 05:40:21.830
designer typically specifies a 
UI with 

05:40:24.923 --> 05:40:27.571
horizontal lines, well you can 
simply replicate those in your 

05:40:27.572 --> 05:40:32.096
UI so it's a lot easier to set 
up your screen.  With 1.1 we 

05:40:32.097 --> 05:40:34.979
have the barrier I talked about.
And what is nice with those 

05:40:34.980 --> 05:40:39.935
helper objects we have for them 
in the UI builder so you can 

05:40:39.936 --> 05:40:41.936
manipulate them and 

05:40:43.009 --> 05:40:45.077
add elements to those helper 
objects in the component tree by

05:40:45.078 --> 05:40:48.560
dragging elements into them.  
Something you might not realize 

05:40:48.561 --> 05:40:50.561
is that 

05:40:53.860 --> 05:40:55.860
those helpers objects are not 
gibberish.

05:40:58.329 --> 05:41:00.329
They keep reference to the views
so we 

05:41:01.385 --> 05:41:03.614
still keep the view tree very 
flat.  Because they're just 

05:41:03.615 --> 05:41:06.261
references we can have one 
object being referenced in 

05:41:07.276 --> 05:41:09.276
multiple helpers.

05:41:10.851 --> 05:41:13.509
And very interesting for us.

05:41:19.059 --> 05:41:21.059
You can think about the helpers 
a way 

05:41:22.118 --> 05:41:24.118
of keeping a reference to a 
bunch of 

05:41:25.524 --> 05:41:27.524
views, you can still get flat 
hierarchy 

05:41:32.290 --> 05:41:34.545
and the helper gives you a way 
of encapsulating.  2.

05:41:39.383 --> 05:41:41.558
0 woe are going to expose those 
helpere are going to expose 

05:41:41.559 --> 05:41:43.559
those helpers.  If you have a 
person on your project 

05:41:47.900 --> 05:41:49.900
similar to what we have with 
custom 

05:41:51.315 --> 05:41:54.417
views they will be able to 
present.  We calculated three 

05:41:54.418 --> 05:41:56.418
board categories for the helper.

05:42:00.319 --> 05:42:02.581
One category is layout 
manipulation.  Helper that is 

05:42:02.582 --> 05:42:09.785
going to help you increase 
create a layout.  Another is 

05:42:09.786 --> 05:42:15.278
going to help you after the 
layout is done so post layout.  

05:42:15.279 --> 05:42:17.279
And we have helpers because 
helpers 

05:42:18.320 --> 05:42:20.998
are views or can be views as 
well, helpers that we can use to

05:42:20.999 --> 05:42:22.999
do some specific rendering.

05:42:26.978 --> 05:42:30.233
For the virtual layouts there's 
a concept that we are really 

05:42:30.234 --> 05:42:32.234
keen on.

05:42:33.686 --> 05:42:34.748
The idea is that the helper is 
going to set the constraint for 

05:42:34.749 --> 05:42:36.749
you.

05:42:38.017 --> 05:42:41.287
The simplest example I can think
of is a linear helper.  If you 

05:42:41.288 --> 05:42:43.288
created a chain in constraint 

05:42:44.341 --> 05:42:46.172
layout one that will allow you 
to do exactly the same thing but

05:42:46.173 --> 05:42:51.705
you manipulate it like the 
layouts, for instance.  The only

05:42:51.706 --> 05:42:53.706
difference is you have all 

05:42:54.788 --> 05:42:57.473
the features that chains provide
you.  The way you use them it's 

05:42:57.474 --> 05:43:01.738
very easy.  It's a normal view. 
You can constrain the view 

05:43:01.739 --> 05:43:06.851
itself but the only thing you 
need here is that list of ID's 

05:43:06.852 --> 05:43:11.415
that you reference.  
We have a virtual layout that we

05:43:11.416 --> 05:43:13.416
launch with 2.

05:43:17.332 --> 05:43:21.414
2 that essentially implements 
the flex box layout semantics.  

05:43:21.415 --> 05:43:22.837
Those are pretty useful but at 
the same time I think pretty 

05:43:22.838 --> 05:43:24.838
expected.

05:43:29.188 --> 05:43:31.188
We come up with additional use 
cases.

05:43:32.521 --> 05:43:34.521
So one example of post layout 
object 

05:43:35.528 --> 05:43:37.528
is

05:43:39.271 --> 05:43:41.301
a flying object.  You can 
reference this object with a 

05:43:43.590 --> 05:43:45.590
flying decorator and that's all.

05:43:48.688 --> 05:43:50.688
So no code, it's purely 
derivative, 

05:43:52.167 --> 05:43:54.824
add that to your file, reference
that object and it will animate 

05:43:54.825 --> 05:43:57.276
on first launch.  We have 
another object that's very 

05:44:01.363 --> 05:44:03.363
powerful and layers, essentially
a lot of things.

05:44:08.520 --> 05:44:10.520
It It has a set of views and 
apply 

05:44:11.552 --> 05:44:13.393
operation to them so there's a 
bunch of graphic operation that 

05:44:13.394 --> 05:44:15.394
you can apply and 

05:44:16.404 --> 05:44:18.404
we will do the math.

05:44:24.818 --> 05:44:27.755
You can also set it up so it 
takes by default the views it 

05:44:27.756 --> 05:44:29.998
references and you can set up a 
background very easily that way.

05:44:32.437 --> 05:44:34.290
Another use case that will be 
supposed you can use the layer a

05:44:34.291 --> 05:44:36.291
little bit like 

05:44:39.394 --> 05:44:41.031
you would use layers in 
graphical photo editors to a 

05:44:41.032 --> 05:44:43.032
bunch of layers to specify 

05:44:44.128 --> 05:44:46.994
your elements and when you are 
okay with those elements 

05:44:46.995 --> 05:44:48.995
constraints you can lock 

05:44:51.020 --> 05:44:53.557
that layer and be sure to modify
them.  So it's a very powerful 

05:44:53.558 --> 05:44:56.617
helper. 
Here is a quick example on how 

05:44:56.618 --> 05:44:58.618
it would 

05:45:01.333 --> 05:45:03.333
look by drawing a back ground.

05:45:07.203 --> 05:45:09.203
And we set the constraint 
manually

05:45:13.563 --> 05:45:16.220
.  Just to prove that we have a 
flat tree, we can apply this 

05:45:16.221 --> 05:45:18.221
operation that 

05:45:20.241 --> 05:45:22.241
I'm talking about and everything
will

05:45:23.640 --> 05:45:25.640
just go but the background stays
where it is.  

05:45:28.483 --> 05:45:30.483
Another

05:45:32.487 --> 05:45:35.759
useful decorator is circular 
reveal.  It does what it says.  

05:45:35.760 --> 05:45:37.760
The typical effect that you've 
been 

05:45:40.659 --> 05:45:42.489
familiar with with design, if I 
press the button, the 

05:45:42.490 --> 05:45:44.490
interesting thing here 

05:45:47.129 --> 05:45:49.265
is that you notice that it only 
applies to the element 

05:45:49.266 --> 05:45:51.266
reference.

05:45:53.793 --> 05:45:56.875
We have the ones that are not 
referenced.  We did not apply to

05:45:56.876 --> 05:45:58.876
them f you play 

05:46:00.129 --> 05:46:02.129
with circular reveal you see 
it's a bit tricky to do that.

05:46:04.626 --> 05:46:06.626
Interesting here as well we are 
not 

05:46:08.687 --> 05:46:10.687
creating our own circular 
reveal, we are 

05:46:11.693 --> 05:46:16.326
justing into just using the 
normal circular reveal.  It's a 

05:46:16.327 --> 05:46:18.327
way to use your layouts. 

05:46:20.824 --> 05:46:23.526
So on that same idea we have 
decorators that are helperss 

05:46:23.527 --> 05:46:25.527
that are here to draw things.

05:46:30.041 --> 05:46:31.054
And same things we reference use
and you can draw something with 

05:46:31.055 --> 05:46:33.055
it.  

05:46:37.015 --> 05:46:39.538
So that's confusing in terms of 
what type of affect you can get 

05:46:39.539 --> 05:46:41.539
with that.

05:46:44.424 --> 05:46:46.424
You may want an affect like 
that, like a lava lamp affect.

05:46:49.934 --> 05:46:52.197
And what you see is the result 
of that affect will depend on 

05:46:52.198 --> 05:46:54.198
the position of 

05:46:56.093 --> 05:46:57.523
those blobs but the final 
rendering has to take into 

05:46:57.524 --> 05:47:01.830
account all of them.  And that 
would normally be very difficult

05:47:01.831 --> 05:47:04.068
to achieve.  You can think about
it that way, you 

05:47:07.945 --> 05:47:09.945
have a canvas that you paint on.

05:47:12.010 --> 05:47:14.063
You'll have actually some image 
views that are essentially 

05:47:14.064 --> 05:47:16.064
sitting on top of 

05:47:18.334 --> 05:47:19.971
that and they're normal image 
views, normal views, you can 

05:47:19.972 --> 05:47:23.039
apply the usual things.  But we 
put them on background to be 

05:47:27.126 --> 05:47:29.174
transparent and then we use a 
decorator to draw the 

05:47:29.175 --> 05:47:31.463
background.  You can easily get 
an affect like that.

05:47:36.513 --> 05:47:38.513
A little slower, there you goep 
you go. 

05:47:40.989 --> 05:47:42.989
Just to show you

05:47:44.515 --> 05:47:46.515
the bots are correct we still 
have our images.

05:47:47.778 --> 05:47:49.778
Another type of decorator is the
bottom panel decorator.

05:47:52.881 --> 05:47:55.747
Let's say that you may have 
created by using a chain, very 

05:47:55.748 --> 05:47:57.830
easy.  If you like to set a 
background on 

05:48:01.499 --> 05:48:03.499
those objects and maybe change 
the colors.

05:48:06.218 --> 05:48:09.042
You can simply apply this 
decorator.  And because we can 

05:48:09.043 --> 05:48:13.734
do a little more interesting 
stuff here, I can show you what 

05:48:13.735 --> 05:48:16.407
it may look like when you click 
on those buttons. 

05:48:19.727 --> 05:48:21.727
So just to give you an idea of 
the type 

05:48:24.597 --> 05:48:26.597
of effects you can get with 
decorator

05:48:33.416 --> 05:48:35.416
s, so I'm clicking on this, I 
can press 

05:48:37.496 --> 05:48:39.496
that, I press is and there's a 
circular reveal.

05:48:43.057 --> 05:48:45.321
Just to give you an idea of what
you can do.  What is very 

05:48:45.322 --> 05:48:47.322
interesting here is that 

05:48:50.251 --> 05:48:52.251
if you look at it in studio and 
if I 

05:48:53.305 --> 05:48:55.305
zoom under component tree, you 
will 

05:48:58.406 --> 05:49:00.406
notice that actually we mostly 
adjust 

05:49:01.678 --> 05:49:03.911
views and just a bunch of 
helpers.  There's actually no 

05:49:03.912 --> 05:49:05.912
code here so it's 

05:49:07.792 --> 05:49:09.792
a really useful addition to try 
to 

05:49:14.190 --> 05:49:16.190
really separate the field with 
the 

05:49:18.676 --> 05:49:20.676
actual -- your actual data and 
your actual application.

05:49:23.798 --> 05:49:25.798
So to summarize with the 
helpers, you 

05:49:29.257 --> 05:49:32.205
can tag your views with those, 
you can encapsulate and it's all

05:49:33.005 --> 05:49:35.005
declarative.

05:49:38.658 --> 05:49:40.658
You have been probably playing 
with

05:49:41.765 --> 05:49:44.600
constraints on the constraint 
layout 1.1.  And if you switch 

05:49:44.601 --> 05:49:46.601
between two of those states, you
can animate them.

05:49:50.477 --> 05:49:51.736
So that's verystates on the 
constraint layout 1.1.  And if 

05:49:51.737 --> 05:49:53.562
you switch between two of those 
states, you can animate them.  

05:49:53.563 --> 05:49:55.563
So that's very nice but 
initiating 

05:49:57.467 --> 05:49:59.907
those things is a little 
cumbersome.  So in 2.

05:50:03.774 --> 05:50:06.221
0 we will have a separate file 
that let's you specify states 

05:50:06.222 --> 05:50:08.222
because that's basically what 
they are.

05:50:14.118 --> 05:50:15.859
I have a layout that is 
different pre presentation, 

05:50:15.860 --> 05:50:17.860
different states.

05:50:20.506 --> 05:50:23.239
So the way you would use them is
by description.

05:50:28.548 --> 05:50:30.548
You condense by state ID and 
that's it.

05:50:32.002 --> 05:50:34.429
One nice thing is that you can 
specify a region when a specific

05:50:34.430 --> 05:50:36.430
constraint set is going to be 
applied.

05:50:39.672 --> 05:50:41.795
And by plugging that into 
onconfiguration changed, I'm 

05:50:41.796 --> 05:50:44.233
showing that on the Chromebook, 
you'll see 

05:50:47.949 --> 05:50:49.949
automatically depending on the 
size of 

05:50:51.855 --> 05:50:53.855
the Window will switch layouts.

05:50:55.968 --> 05:50:58.573
If you want a little more fancy,
you can on the prelayout change 

05:50:58.574 --> 05:51:01.656
plug transition manager and it 
will animate the layout 

05:51:01.657 --> 05:51:03.657
transition. 

05:51:06.180 --> 05:51:08.451
So I think we have devices, 
Chrome books, es that's the type

05:51:08.452 --> 05:51:10.452
of use case 

05:51:12.875 --> 05:51:13.117
that it's going to be more and 
morethat's the type of use case 

05:51:13.118 --> 05:51:15.118
that it's going to be more and 
more useful. 

05:51:19.226 --> 05:51:21.474
So to quickly recap on 
constraint layout, we have the 

05:51:21.475 --> 05:51:23.475
helpers, we have the 

05:51:25.946 --> 05:51:27.946
virtual layouts and decorators, 
we also 

05:51:30.066 --> 05:51:32.704
have stuff I haven't talked 
about like for manipulating the 

05:51:32.705 --> 05:51:34.705
constraints 

05:51:36.110 --> 05:51:38.110
directly and we have

05:51:40.383 --> 05:51:42.383
motion layouts.

05:51:46.123 --> 05:51:48.419
I'm happy to introduce John.  
&gt;&gt; JOHN HOFORD:  Thanks.

05:51:52.671 --> 05:51:54.671
I'm excited to show you

05:51:55.827 --> 05:51:57.827
guys motion layout.

05:51:58.893 --> 05:52:00.893
So let's kind of get into it.

05:52:02.345 --> 05:52:04.345
It starts off with a sub class 
of 

05:52:07.035 --> 05:52:09.664
constraint layout called motion 
layout.  It's a layout that has 

05:52:09.665 --> 05:52:12.309
all the properties of constraint
layout but the 

05:52:16.610 --> 05:52:19.463
whole trick with animateing 
between two constraint sets, 

05:52:19.464 --> 05:52:21.464
that will be done for 

05:52:23.085 --> 05:52:26.425
you by emotionally motion 
layout.  If you have two 

05:52:26.426 --> 05:52:30.908
constraint sets it will switch 
between them and animate between

05:52:30.909 --> 05:52:32.909
them by itself.

05:52:36.416 --> 05:52:38.416
But notice because it's a 
constraint 

05:52:40.866 --> 05:52:43.405
layout, you can actually use the
helpers that were shown there.

05:52:46.719 --> 05:52:48.719
But it also provides you with 
the 

05:52:52.407 --> 05:52:54.407
ability to edit the custom 
attributes of the system.

05:52:56.307 --> 05:52:58.307
So notice the blue light there, 
it's 

05:52:59.767 --> 05:53:01.767
changing because it's a custom 
attribute in the system.

05:53:04.458 --> 05:53:06.281
So constraint sets now can have 
custom attributes, allows to you

05:53:06.282 --> 05:53:08.282
animate anything.

05:53:13.664 --> 05:53:15.664
One of the other things that it 
does is 

05:53:17.528 --> 05:53:19.528
it allows you to control on 
touch directly.

05:53:20.991 --> 05:53:22.991
So it will manage your touch 
events by 

05:53:24.654 --> 05:53:26.890
tracking your velocity of your 
finger and matching it to other 

05:53:26.891 --> 05:53:28.891
velocity of 

05:53:31.225 --> 05:53:33.856
views in the system and 
naturally give you a smooth 

05:53:33.857 --> 05:53:36.288
transition between them by a 
touch.  

05:53:42.399 --> 05:53:44.399
We also support helpers because 
it's a constraint layout.

05:53:47.667 --> 05:53:52.667
Nicholas just showed they're 
there, too.  They can work 

05:53:52.668 --> 05:53:55.303
together and apart. 
Now let's change the transition 

05:53:55.304 --> 05:53:59.584
a little bit.  We want to move 
the eye into the middle of the 

05:53:59.585 --> 05:54:01.819
screen but if we look closely 
there's a bit of a problem here.

05:54:05.927 --> 05:54:07.927
You see the arrow clashes with 
the eye.

05:54:09.187 --> 05:54:12.881
We have to fix that.  The way we
do that is a feature we call key

05:54:12.882 --> 05:54:15.728
frames.  Essentially if we have 
a beginning and 

05:54:19.397 --> 05:54:22.029
an end of a path, we can distort
the path by adding a key frame.

05:54:26.328 --> 05:54:29.393
Once we add the key frame, it 
will avoid the path.   

05:54:30.822 --> 05:54:32.822
Which is pretty cool. 

05:54:34.713 --> 05:54:36.740
So now we have a motion scene.  
It has constraint sets.

05:54:41.853 --> 05:54:44.913
It has on touch, key frames, 
custom attributes.  

05:54:48.357 --> 05:54:50.803
With a little flag on your 
device you can see the path of 

05:54:50.804 --> 05:54:53.879
all the objects you've set on 
it.  So you can understand what 

05:54:53.880 --> 05:54:56.536
all your views are doing on 
device.

05:55:07.171 --> 05:55:09.171
So one of the nice things we 
support is 

05:55:12.889 --> 05:55:14.889
nesting of constraint sets of 
motion layouts.

05:55:17.988 --> 05:55:19.988
In this particular example we 
have two 

05:55:22.057 --> 05:55:24.057
views being animated by a third 
view.

05:55:27.045 --> 05:55:29.677
They're both constraint motion 
layouts and they're being being 

05:55:29.678 --> 05:55:31.678
driven by a 

05:55:33.335 --> 05:55:35.335
third emotionally

05:55:36.822 --> 05:55:38.822
motion layout.

05:55:40.486 --> 05:55:42.486
The top view is a fade to black 
but 

05:55:44.171 --> 05:55:46.437
this is an animated view that 
was custom written by Nicholas 

05:55:46.438 --> 05:55:48.438
that is being driven 

05:55:51.945 --> 05:55:52.752
by a motion layout because it 
implements on progress method.  

05:55:52.753 --> 05:55:55.191
So you can drag your own custom 

05:55:59.499 --> 05:56:01.499
animations directly from motion 
layout.  

05:56:04.807 --> 05:56:07.283
So one of the things it's really
good at is synchronizing 

05:56:07.284 --> 05:56:12.177
motions.  Anything that is very 
complex sequences of many things

05:56:12.178 --> 05:56:17.049
moving on the screen it will 
handle it and will also allow 

05:56:17.050 --> 05:56:19.527
you to interact with it with the
touch.

05:56:22.575 --> 05:56:25.214
So we added one more thing to 
the system, something we call 

05:56:25.215 --> 05:56:27.215
cycles.

05:56:28.509 --> 05:56:30.509
This is the ability to build 
into the 

05:56:31.740 --> 05:56:33.740
key frames

05:56:36.441 --> 05:56:38.441
s on sill

05:56:42.173 --> 05:56:44.173
s on sill

05:56:49.721 --> 05:56:51.721
oscillatetory cycles.

05:56:54.434 --> 05:56:56.468
I can take one and have it roll 
because it's oscillated.

05:57:00.538 --> 05:57:01.351
Or I can have a different 
effect, it can bounce along the 

05:57:01.352 --> 05:57:03.352
edge.

05:57:05.240 --> 05:57:07.688
I got bored and had that one 
flying around.  [Laughter]. 

05:57:10.338 --> 05:57:12.372
Another typical example you put 
a little shake at the end.  

05:57:15.020 --> 05:57:17.020
So now one of the cool things is
we build editors.

05:57:21.368 --> 05:57:23.205
So we are building an editor for
that thing.  We call it the 

05:57:23.206 --> 05:57:25.206
motion editor.

05:57:26.466 --> 05:57:28.466
It's part of the design surface.

05:57:30.941 --> 05:57:32.975
But now you'll be able to do 
those edits directly in the 

05:57:32.976 --> 05:57:34.976
design surface.

05:57:37.255 --> 05:57:39.255
So kind of to take you through 
how you 

05:57:43.588 --> 05:57:45.588
would do that in the design 
surface, 

05:57:48.933 --> 05:57:50.933
based on constraint layout you 
just just 

05:57:53.605 --> 05:57:55.605
create your constraints for your
first 

05:57:57.263 --> 05:57:59.300
constraint set, switch to the 
second, edit constraints for the

05:57:59.301 --> 05:58:01.976
second set.  If you hit play it 
will show the 

05:58:05.038 --> 05:58:07.038
animation between those two 
constraint sets.

05:58:08.717 --> 05:58:10.357
There's a check box to enable 
showing you the path so now you 

05:58:10.358 --> 05:58:14.427
can see the path.  But how would
you add a key frame?  

05:58:16.870 --> 05:58:18.870
Just position the cursor where 
you want 

05:58:20.750 --> 05:58:22.750
it, add the type of key frame 
that you 

05:58:25.026 --> 05:58:27.512
want to add, and you can just 
distort the position by 

05:58:27.513 --> 05:58:29.513
selecting the key frame and 
moving it around on this screen.

05:58:33.428 --> 05:58:37.088
Let's do that one more time so 
you can see it.

05:58:40.962 --> 05:58:42.962
Just select a position, any 
position, 

05:58:47.095 --> 05:58:49.095
create a key frame, and then we 
just 

05:58:50.334 --> 05:58:52.334
move it

05:58:57.893 --> 05:59:01.584
it.  So here is much more 
complex motions.  All animated.

05:59:06.714 --> 05:59:08.714
This has quite a few key frames 
in it 

05:59:11.212 --> 05:59:12.236
designed to let you set 
transparency on some things, 

05:59:12.237 --> 05:59:14.237
move them around.

05:59:15.923 --> 05:59:17.923
But it all worked in the IDE.  
Thank you.  

05:59:20.547 --> 05:59:22.547
(Applause)

05:59:32.041 --> 05:59:34.041
.
&gt;&gt; So one last thing.

05:59:36.935 --> 05:59:38.935
You probably are here to try all
those things.

05:59:40.822 --> 05:59:42.822
So a lot of that is actually 3.
2.

05:59:44.132 --> 05:59:46.132
All the sample data we showed 
you, all 

05:59:47.973 --> 05:59:49.973
the current integration with 1.
1, go, try it out.

05:59:53.706 --> 05:59:55.706
We released

05:59:57.841 --> 05:59:59.841
canary 14 model this Tuesday so 
give it a try.

06:00:02.125 --> 06:00:04.175
The library with emotionallyout 
we are doing it in a few days 

06:00:04.176 --> 06:00:06.176
hopefully.

06:00:07.248 --> 06:00:09.688
And motion editor it's an on 
going but we are excited about 

06:00:09.689 --> 06:00:11.689
it.

06:00:14.590 --> 06:00:16.590
So think about it, there is 
codelabs 

06:00:17.593 --> 06:00:19.593
as well

06:00:21.302 --> 06:00:24.145
for the Chromeos resize.  We 
also want to hear from you in 

06:00:24.359 --> 06:00:29.871
general.  We are reachable, but 
for this particular session 

06:00:29.872 --> 06:00:31.872
there's feedback you can fill.

06:00:33.954 --> 06:00:34.982
We also have an office hour this
after even when after the 

06:00:34.983 --> 06:00:39.051
session.  Please come see us.  
That completes our talk.  Thank 

06:00:39.052 --> 06:00:42.318
you, very much.  
(Applause). 

06:00:42.319 --> 06:00:43.355
.  
.  

06:00:43.356 --> 06:00:45.793
.  
.  

06:00:45.794 --> 06:00:47.220
.  
.  

06:00:47.221 --> 06:00:49.221
.  
.

06:01:11.741 --> 06:01:13.574
.
&gt;&gt; Thank you for joining this 

06:01:13.575 --> 06:01:15.575
session.

06:01:17.047 --> 06:01:19.047
Grand ambassadors will assist 
with 

06:01:20.500 --> 06:01:23.456
helping you move.  If you 
registered for the next session 

06:01:26.922 --> 06:01:28.922
in this room we ask that you 
clear the 

06:01:31.032 --> 06:01:32.049
room and enter via the 
registration line outside.  

06:01:32.050 --> 06:01:34.050
Thank you.

06:01:35.547 --> 06:01:36.154
.  
.  

06:01:36.155 --> 06:01:37.174
.  
.  

06:01:37.175 --> 06:01:39.175
.

06:06:34.859 --> 06:06:36.859
Paging with recycler view

06:06:40.551 --> 06:06:42.551
:  Managing

06:06:46.543 --> 06:06:48.543
infinite lists with recycler 
view and 

06:06:50.155 --> 06:06:52.155
paging  

06:06:54.709 --> 06:06:57.168
With Recycler View:  Managing 
Infinite Lists With Recycler 

06:06:57.169 --> 06:06:59.169
View and Paging   

06:16:21.943 --> 06:16:24.427
.
&gt;&gt; Welcome.  Please fill in the 

06:16:24.428 --> 06:16:27.710
seats near the front of the 
room.  Thank you.  

06:16:34.113 --> 06:16:35.379
room.  Thank you.  

06:19:13.669 --> 06:19:15.669
Page with recycler view:  
Managing 

06:19:17.597 --> 06:19:19.597
infinite lists with recycler 
view and paging.

06:19:26.996 --> 06:19:28.996
.

06:19:30.900 --> 06:19:33.947
&gt;&gt; At this time please find your
your seat.  Our session will 

06:19:33.948 --> 06:19:35.948
begin soon.

06:22:49.760 --> 06:22:52.016
&gt;&gt; CHRIS CRAIK:  Hey, I'm Chris 
Craik 

06:22:57.519 --> 06:22:59.519
from the Android framework team.

06:23:02.240 --> 06:23:04.920
&gt;&gt; YIGIT BOYAR:  My name is 
Yigit.  I also work with the 

06:23:04.921 --> 06:23:07.164
framework team.  Today we are 
going talk take about 

06:23:10.172 --> 06:23:12.910
managing infinite lists and 
recycler view.

06:23:16.585 --> 06:23:18.417
Pretty much every app as a list 
of something they want to 

06:23:18.418 --> 06:23:20.870
display.  Let's see how you 
would model a list like this.

06:23:24.122 --> 06:23:26.122
So you'll have a view model but 
keep 

06:23:27.387 --> 06:23:30.470
the list of items so it survives
configuration change.  You put 

06:23:30.471 --> 06:23:32.735
your data into database so that 
your application works off line.

06:23:37.404 --> 06:23:39.427
And of course you have some 
component where you pull the 

06:23:39.428 --> 06:23:42.475
data from.  
Usually data is dynamic, it 

06:23:42.476 --> 06:23:44.476
changes.

06:23:48.214 --> 06:23:50.214
So how does this change the 
database 

06:23:53.957 --> 06:23:55.797
to return live data list of 
things or observeible list of 

06:23:55.798 --> 06:23:57.798
things so you can have updates?

06:24:01.061 --> 06:24:03.061
For instance, if you put the 
updated

06:24:05.835 --> 06:24:07.835
version of records from your 
database 

06:24:09.948 --> 06:24:11.948
and realizes this a query 
observing this 

06:24:14.083 --> 06:24:16.083
table, let me reveal the result,
fast 

06:24:17.330 --> 06:24:19.330
forward the the view model and 
you can 

06:24:21.202 --> 06:24:24.103
pull from the view model and 
update the animations.  This 

06:24:24.104 --> 06:24:27.350
looks cool but there is actual a
a problem here.  There's 

06:24:27.351 --> 06:24:29.182
something we don't like.  To 
better understand the issue 

06:24:29.183 --> 06:24:33.920
let's look at the interaction 
between the database and the UI.

06:24:37.841 --> 06:24:40.722
When I mention that database is 
going to reveal the result, it 

06:24:40.723 --> 06:24:42.723
is going to 

06:24:43.800 --> 06:24:45.640
reveal all of the results so if 
you ask for the users ordered by

06:24:45.641 --> 06:24:47.641
their last name 

06:24:48.910 --> 06:24:50.910
and if you have 10,000 users, 
it's going 

06:24:53.877 --> 06:24:56.573
to create 10,000 users, pats 
over to the UI and it's very 

06:24:56.574 --> 06:24:59.455
inefficient because user only 
sees 8 to 10 items, why would 

06:25:03.667 --> 06:25:04.917
you create 10,000 items?  So we 
don't like it.  We want to 

06:25:04.918 --> 06:25:06.918
change this. 
What are we looking for here?

06:25:12.683 --> 06:25:14.683
First we like that convenience, 
it's 

06:25:16.554 --> 06:25:18.554
so nice to tell the database 
give me a 

06:25:21.277 --> 06:25:22.921
live list of user, we want to 
handle multiple layers, be able 

06:25:22.922 --> 06:25:24.922
to bring the data from the 
server, put in the 

06:25:28.658 --> 06:25:31.094
database and the UI and this 
should be very easy to 

06:25:31.095 --> 06:25:33.095
implement.  We want it to be 
fast.

06:25:35.205 --> 06:25:36.978
We don't want to do any big 
chunk of work.  It should be 

06:25:36.979 --> 06:25:38.979
efficient.  

06:25:41.199 --> 06:25:43.029
We want it to be life cycle 
aware so if user is not looking 

06:25:43.030 --> 06:25:45.030
at the screen it shouldn't do 
any work.

06:25:47.743 --> 06:25:51.644
Last but not least we want it 
tot be flexible.  Everyone has 

06:25:51.645 --> 06:25:54.737
their different API, different 
data structures.  Our solutions 

06:25:54.738 --> 06:25:56.738
should work with all of those 
things.  

06:25:58.906 --> 06:26:00.906
Now if you go back to our first 
example, 

06:26:02.661 --> 06:26:04.661
how do we implement these lists 
if we don't use paging?

06:26:08.662 --> 06:26:10.662
If you're

06:26:12.954 --> 06:26:15.612
using, you return it to your 
live list of users.  You hold 

06:26:15.613 --> 06:26:17.613
the reference to it and serve it
to your UI.

06:26:21.143 --> 06:26:23.996
Your activity you would use this
list but if you're not following

06:26:23.997 --> 06:26:28.343
our releases closely you may not
have heard about it.  This works

06:26:28.344 --> 06:26:30.344
on that one. 

06:26:31.596 --> 06:26:34.879
List adapter is a recycler view 
adapter that displays a list.  

06:26:34.880 --> 06:26:37.738
So if you have the recycler view
on the right, when you call the 

06:26:37.739 --> 06:26:40.387
list adapter it just displays 
it.

06:26:45.078 --> 06:26:46.920
The nice thing is if you call 
the same with a different list 

06:26:46.921 --> 06:26:49.357
it's going to calculate the 
difference between these 

06:26:55.163 --> 06:26:59.229
two lists on a background and 
update the UI with the correct 

06:26:55.163 --> 06:26:57.163
animations.

06:26:58.498 --> 06:27:00.498
It's available in recycler view 
27.

06:27:02.829 --> 06:27:04.455
1 and same function exists in 
the async list differ. 

06:27:04.456 --> 06:27:07.936
Okay.  Let's go back to our 
example.  We have our adapter.

06:27:10.980 --> 06:27:12.980
We observe the live data, send 
the list to the adapter.

06:27:16.897 --> 06:27:19.601
When we see the adepter we need 
to give it a call back.  It has 

06:27:19.602 --> 06:27:22.245
two functions.  First it can 
check if two items are 

06:27:25.339 --> 06:27:27.339
equal identically and other one 
checks 

06:27:28.386 --> 06:27:35.107
whether checks whether their 
contents are equal or not.  

06:27:38.400 --> 06:27:40.679
Once you have that you can call 
the get item function, obtain 

06:27:40.680 --> 06:27:42.911
the item in the list and do 
whatever you want with it.

06:27:46.747 --> 06:27:48.747
Super simple.  

06:27:50.474 --> 06:27:53.349
&gt;&gt; CHRIS CRAIK:  We have seen 
what that looks like but you 

06:27:53.350 --> 06:27:56.630
also started with with this is 
not good enough.  Let's see what

06:27:56.631 --> 06:28:00.113
it looks like when using a new 
paging library.  The most 

06:28:00.114 --> 06:28:02.153
important component of the 
paging library is the page list.

06:28:09.457 --> 06:28:11.457
This is a list that load data in
pages asynchronouslily.

06:28:18.657 --> 06:28:22.590
It's backed by a data source, 
swaps it in, and updates the 

06:28:18.657 --> 06:28:20.657
list.

06:28:24.702 --> 06:28:26.702
So this serves as a replacement 
to the 

06:28:30.676 --> 06:28:34.942
list in all the examples we have
done before.  We have this view 

06:28:30.676 --> 06:28:32.676
model.

06:28:33.700 --> 06:28:37.700
Let's swap out the list with a 
page list and go back to our 

06:28:33.700 --> 06:28:35.700
Dao.

06:28:36.716 --> 06:28:38.716
We want to ask our Dao can you 
give me 

06:28:39.771 --> 06:28:43.034
a live data of a page list but 
there's an issue with this.  So 

06:28:43.035 --> 06:28:45.090
if we look over at what the data
looks like on the database side,

06:28:45.091 --> 06:28:50.587
you could imagine paging this in
one way and you could imagine 

06:28:50.588 --> 06:28:52.821
paging this in a different way. 
There's an interesting decision 

06:28:52.822 --> 06:28:54.822
here, 

06:28:57.732 --> 06:28:59.361
you showing large items or tiny 
items where you want to have a 

06:28:59.362 --> 06:29:01.362
lot at once?

06:29:02.835 --> 06:29:04.921
The page needs to be 
configurable to serve every 

06:29:04.922 --> 06:29:06.922
app's needs.

06:29:08.377 --> 06:29:10.377
So instead room can produce this
data 

06:29:14.482 --> 06:29:16.722
source that back pages it that 
way it can access it and load 

06:29:16.723 --> 06:29:18.723
the data directly into the page 
list.

06:29:23.676 --> 06:29:25.077
Because we say we want multiple 
of them, we want something that 

06:29:25.078 --> 06:29:28.724
is observable.  We create a new 
data source. 

06:29:28.938 --> 06:29:30.938
All right.

06:29:32.207 --> 06:29:34.207
So instead of the live data page
list, 

06:29:36.126 --> 06:29:38.969
what the user Dao provides us 
here is a data source factory 

06:29:38.970 --> 06:29:41.435
keyed off of imageer because we 
are using positions. 

06:29:46.335 --> 06:29:48.573
So we go back to our view model 
here and define how are we going

06:29:48.574 --> 06:29:50.574
to load this data?  It's not 
much code.

06:29:53.875 --> 06:29:56.114
We just say get the data source 
factory and use this live page 

06:29:56.115 --> 06:29:59.176
list builder class from the 
library to create a live data.

06:30:03.197 --> 06:30:06.140
The minimum amount of data you 
need to pass is page size.

06:30:09.200 --> 06:30:13.543
Here we have 30.  Now all the 
repository changes are done.  

06:30:13.544 --> 06:30:15.544
Let's go to the activity.

06:30:17.233 --> 06:30:19.883
So now we are using list adapter
before.  You change this into a 

06:30:19.884 --> 06:30:21.884
page list adapter.

06:30:26.231 --> 06:30:28.231
It's the exact same thing as 
list adapter.

06:30:31.306 --> 06:30:33.155
It's loading the pages as 
content is internally loading 

06:30:33.156 --> 06:30:35.156
those page list. 

06:30:36.197 --> 06:30:38.226
So if we look at how we 
implement this list adapter 

06:30:38.227 --> 06:30:40.227
though, we would have to 

06:30:42.106 --> 06:30:44.106
switch over the new page list 
adapter 

06:30:46.788 --> 06:30:49.245
and use the exact same dif code.
The only thing that changes is 

06:30:49.246 --> 06:30:53.759
the user object becomes nullible
and we will get into why in just

06:30:53.760 --> 06:30:56.607
a little bit. 
So let's go through how you can 

06:30:56.608 --> 06:31:00.466
do further configuration because
we don't stop at just page size.

06:31:03.525 --> 06:31:05.525
So the code that we showed 
before 

06:31:06.996 --> 06:31:08.996
creating a live page list 
builder you 

06:31:10.064 --> 06:31:12.106
can just pass a minimum page 
size and that's the minimum 

06:31:12.107 --> 06:31:14.751
amount of data you need to pass 
but you can also create a 

06:31:18.023 --> 06:31:20.023
configuration object where you 
can declare more.

06:31:21.275 --> 06:31:23.527
You might set an initial load 
size hint.  This suggests the 

06:31:23.528 --> 06:31:28.824
initial load is larger to make 
that initial load avoid initial 

06:31:28.825 --> 06:31:32.722
page stretches immediately after
you've fetched it.  Another 

06:31:32.723 --> 06:31:34.723
thing you can change is 

06:31:35.732 --> 06:31:39.260
pre-Fitch prefetch distance.  
You can configure this.

06:31:42.315 --> 06:31:44.137
You can also control place 
holders which are an important 

06:31:44.138 --> 06:31:46.993
part of this library so let's 
start talking about those.

06:31:53.956 --> 06:31:56.222
Place holders false is the 
expectation you might have where

06:31:56.223 --> 06:31:59.683
you load the page, the recycler 
view has access to the number of

06:31:59.684 --> 06:32:02.745
items you've loaded and you have
a big scroll bar.  The user can 

06:32:02.746 --> 06:32:04.746
scroll through it.

06:32:07.235 --> 06:32:09.235
Once they get to the bottom, 
there's no more data.

06:32:11.500 --> 06:32:13.957
Once the page loads the scroll 
bar jumps.  We also support a 

06:32:13.958 --> 06:32:15.958
completely different type of 
paging.

06:32:18.864 --> 06:32:20.864
If you asked for place holders 
and 

06:32:22.129 --> 06:32:24.129
this is the default, we will 
present the list like this.

06:32:25.630 --> 06:32:28.286
The scroll bar is smaller and 
that's because we are presenting

06:32:28.287 --> 06:32:31.965
the entire data set immediately.
As the user scrolls down you'll 

06:32:31.966 --> 06:32:35.854
see there are unloaded items and
those are presented as nuls in 

06:32:35.855 --> 06:32:38.517
the adapter.  These items as the
data eventually 

06:32:42.038 --> 06:32:44.038
loads, display and you'll get a 
nice animation from that. 

06:32:46.334 --> 06:32:48.978
So let's talk about place 
holders, they don't work 

06:32:48.979 --> 06:32:53.451
everywhere but we think they're 
useful in a lot of cases.  The 

06:32:53.452 --> 06:32:56.120
user can control past what is 
loaded.  They don't have to hit 

06:32:56.121 --> 06:32:58.121
a block at the end because you 
don't have anymore data yet.

06:33:01.656 --> 06:33:03.890
The scroll bar looks correct and
you can use fast scrollers very 

06:33:03.891 --> 06:33:08.199
easily because you have the 
entire data set presented to the

06:33:08.200 --> 06:33:11.058
recycler view so you can jump 
anywhere.  And another nice 

06:33:11.059 --> 06:33:13.059
feature is you don't 

06:33:15.587 --> 06:33:17.587
have to implement the loading 
spinner at 

06:33:22.528 --> 06:33:24.528
the bottom because the users can
see

06:33:26.748 --> 06:33:29.420
it and know the item is still 
loading.  It's important that 

06:33:29.421 --> 06:33:31.859
your items stay the same size.  
If you can't guess what the item

06:33:33.678 --> 06:33:35.678
height is going to be before you
have 

06:33:41.246 --> 06:33:43.246
content, the cross animation 
doesn't look great.

06:33:49.402 --> 06:33:51.907
The adapter have to handle null 
items.  And then your data 

06:33:51.908 --> 06:33:53.908
source has to be 

06:33:55.040 --> 06:33:57.040
able to count items.  If you're 
using something that is 

06:34:00.190 --> 06:34:02.190
loading data from say the 
network, your 

06:34:03.459 --> 06:34:05.459
back end may not be able to 
provide a precise count.

06:34:06.918 --> 06:34:08.918
So we have been talking about 
live 

06:34:12.467 --> 06:34:14.467
data thus far but as Yigit 
introduced we 

06:34:16.318 --> 06:34:18.318
also want to support our RxJava 
developers.

06:34:19.385 --> 06:34:21.385
You may want to produce an 
observable 

06:34:22.701 --> 06:34:24.124
and we provide the class Rx 
paged list builder to do exactly

06:34:24.125 --> 06:34:26.760
that.  You can change the return
type here 

06:34:29.821 --> 06:34:31.821
use an Rx page list builder and 

06:34:32.821 --> 06:34:34.821
specifically

06:34:38.807 --> 06:34:40.807
request observable or flowible 
out of it.  

06:34:42.711 --> 06:34:44.951
Now let's go under the hood 
because we have shown how small 

06:34:44.952 --> 06:34:49.267
of a code change this can be to 
change the paging library but 

06:34:49.268 --> 06:34:51.708
how does that work underneath?  
Here on the left you have the 

06:34:53.161 --> 06:34:55.366
repository that represents the 
data loading portion of your 

06:34:55.367 --> 06:34:57.444
application and then on the 
right you have the view 

06:35:02.280 --> 06:35:04.280
model which is how it 
communicates to the UI.

06:35:06.062 --> 06:35:08.062
Inside the repository we want to

06:35:10.541 --> 06:35:12.541
produce something that will push
updates to the UI.

06:35:15.248 --> 06:35:17.248
When you call live paged list 
builder.

06:35:19.703 --> 06:35:21.703
build, we want the producer side
as well.

06:35:22.963 --> 06:35:24.963
Once someone starts observing 
that 

06:35:26.227 --> 06:35:28.887
live data we will create a new 
page list because that's the way

06:35:28.888 --> 06:35:30.888
we start passing information 
down this pipeline and to do 

06:35:33.808 --> 06:35:35.808
that we create a new data source
out of 

06:35:37.274 --> 06:35:39.274
the factory that it's able to 
produce.

06:35:40.323 --> 06:35:42.841
To pass this page list over we 
want don't want to send an empty

06:35:42.842 --> 06:35:45.104
list.  We would like to load 
data first and 

06:35:49.585 --> 06:35:51.814
we do that on a background 
thread, initialize the data and 

06:35:51.815 --> 06:35:53.815
create a page list out of it.

06:35:56.921 --> 06:35:58.962
The first page list we produced 
has data only in the very front.

06:36:04.009 --> 06:36:06.009
We can send that to the UI 
thread

06:36:07.790 --> 06:36:10.450
.  Submit this to the adapter 
and adapter can start presenting

06:36:10.451 --> 06:36:12.451
those items.

06:36:13.517 --> 06:36:15.751
We might need to load more data 
so the page list internally will

06:36:15.752 --> 06:36:17.752
trigger a data load from its 
data source.

06:36:20.740 --> 06:36:22.740
And append that data directly to
the page list. 

06:36:25.440 --> 06:36:26.645
Now the cross fade animation 
occurs because we have signaled 

06:36:26.646 --> 06:36:28.646
the recycler 

06:36:29.907 --> 06:36:31.907
view that these new items are 
updated 

06:36:33.682 --> 06:36:35.682
again but what happens

06:36:38.234 --> 06:36:41.882
when if the database says this 
table has been validated 

06:36:41.883 --> 06:36:45.795
something changed, we invalidate
it so let's look at what happens

06:36:45.796 --> 06:36:48.437
in order to start pushing those 
updates from the other side. 

06:36:48.438 --> 06:36:53.156
So on the other side of things 
we can see the database had an 

06:36:53.157 --> 06:36:55.157
item added to 

06:36:56.198 --> 06:36:58.198
it, that's why we invalidated 
the 

06:36:59.466 --> 06:37:01.466
previous data source and the 
producer 

06:37:02.509 --> 06:37:06.821
side is listening to the signal 
to say we need a new page list. 

06:37:06.822 --> 06:37:08.822
We can create a new page list to
send over.

06:37:10.306 --> 06:37:12.321
When we load the initial data we
are careful to initialize that 

06:37:12.322 --> 06:37:14.322
based on the 

06:37:17.471 --> 06:37:20.351
loading position that was 
signaled by the adapter.

06:37:23.684 --> 06:37:30.650
We send that over to the UI.   
And now we submit list again.  

06:37:30.651 --> 06:37:32.651
Because these are two different 
lists 

06:37:33.936 --> 06:37:35.936
and we really don't want to call
notify 

06:37:39.833 --> 06:37:41.833
data set changed we compute

06:37:47.835 --> 06:37:50.070
an a synchronous dif.  
Immediately you get a new item 

06:37:50.071 --> 06:37:54.994
showing up and we only have to 
do the minimal amount of UI work

06:37:54.995 --> 06:37:58.045
to bind and show the new item. 
So fundamentally under the hood 

06:37:58.046 --> 06:38:02.765
we do a lot of trickery to make 
this work but from the outside 

06:38:02.766 --> 06:38:04.766
we try and make it look as close
as possible to a live data of a 

06:38:06.422 --> 06:38:09.514
list because this is a really 
nice experience.  It let's you 

06:38:09.515 --> 06:38:11.515
keep your UI really simple and 
avoid all the information 

06:38:15.456 --> 06:38:17.525
about paging on that side and 
let you configure and construct 

06:38:17.526 --> 06:38:19.526
your flow in one place from the 
repository.

06:38:23.255 --> 06:38:25.255
The page list adapter let's you 
handle 

06:38:26.682 --> 06:38:27.952
the new pages lists as they flow
in and the internal updates of 

06:38:27.953 --> 06:38:29.953
the paged list as it loads.

06:38:32.427 --> 06:38:34.054
. 
&gt;&gt; YIGIT BOYAR:  Let's talk 

06:38:34.055 --> 06:38:36.055
about data sources.

06:38:37.724 --> 06:38:39.358
So imagine that page list is a 
list of implementation that 

06:38:39.359 --> 06:38:42.065
works with a data source and we 
have different types of data 

06:38:42.066 --> 06:38:44.066
sources.

06:38:47.179 --> 06:38:49.179
You can have a positional data 
source, 

06:38:51.049 --> 06:38:53.049
an item keep data source and 
page keep data source.

06:38:55.089 --> 06:39:00.696
Let's start with with positional
data source.  If you have the 

06:39:00.697 --> 06:39:02.988
data locally but user may want 
to jump into arbitrary 

06:39:05.234 --> 06:39:07.234
positions, positional data 
source is your best option.

06:39:10.098 --> 06:39:15.899
This is actually what uses 
behind the scenes.  If you have 

06:39:15.900 --> 06:39:17.900
a data source you extend 

06:39:20.547 --> 06:39:22.547
this position data source clause

06:39:23.906 --> 06:39:25.906
and specify the type of items.

06:39:27.840 --> 06:39:29.840
Let's look at an example.

06:39:31.928 --> 06:39:34.363
Zoom out, go to the bird's eye 
view and have a data source.

06:39:38.396 --> 06:39:40.396
The very first time

06:39:42.483 --> 06:39:44.483
time come to the recycler view

06:39:48.318 --> 06:39:50.973
, page size, start position and 
load size which is usually 

06:39:50.974 --> 06:39:52.974
larger than the page size 
because you want to have more 

06:39:58.152 --> 06:40:00.811
items at the beginning and 
whether place holders are 

06:40:00.812 --> 06:40:04.865
enabled or not.  Our data source
will return the data, tell us 

06:40:04.866 --> 06:40:06.866
where the data starts and it 

06:40:08.201 --> 06:40:10.201
will give us total number of 
items in the data source. 

06:40:12.172 --> 06:40:14.172
Based on that we will start 
displaying 

06:40:16.834 --> 06:40:18.792
the data but also display the 
place the place holders so the 

06:40:18.793 --> 06:40:24.083
size of the page is equal to the
total number of items in the 

06:40:24.084 --> 06:40:26.084
data source.

06:40:29.234 --> 06:40:31.234
As soon as user starts 
scrolling, it's 

06:40:33.377 --> 06:40:36.047
going to run out of data and 
call this on the positional data

06:40:36.048 --> 06:40:38.048
source, the start 

06:40:39.517 --> 06:40:41.517
position of the first item is 
missing, 

06:40:42.609 --> 06:40:44.652
and page size, and get the new 
data appended to the list. 

06:40:50.457 --> 06:40:52.457
So in this case use the fast 
scroller 

06:40:53.524 --> 06:40:55.524
and jumps into a position where 
we don't have data yet.

06:40:58.672 --> 06:41:00.740
When this happens it won't call 
the data source position.

06:41:04.694 --> 06:41:06.561
With a recycler view we load 
that page so we can display to 

06:41:06.562 --> 06:41:08.562
the user.

06:41:09.860 --> 06:41:12.309
This is where positional data 
sources is really good if user 

06:41:12.310 --> 06:41:14.156
can jump into arbitrary 
positions.  You never block 

06:41:14.157 --> 06:41:16.157
them.  Let's say something 
happened in the 

06:41:20.518 --> 06:41:23.190
database so we will get a new 
data source.  Each data source 

06:41:23.191 --> 06:41:25.191
represents a snapshot of the 
data.

06:41:27.495 --> 06:41:29.731
So we get this new one, we 
create new pages for it and load

06:41:29.732 --> 06:41:31.732
the initial page 

06:41:32.770 --> 06:41:35.284
from this data source based on 
where user is in the previous 

06:41:35.285 --> 06:41:39.353
one.  We will bring this one as 
always on a background thread 

06:41:39.354 --> 06:41:41.404
and calculate the difference 
between these two lists and 

06:41:43.245 --> 06:41:46.519
update the recycler view with 
the correct animations.  

06:41:50.592 --> 06:41:52.592
Second one is the item keyed 
data source.

06:41:54.104 --> 06:41:56.104
Imagine you have data like a 
list with some names.

06:41:57.982 --> 06:41:59.606
If you look at the page out of 
this, you can identify the items

06:41:59.607 --> 06:42:04.546
before this page by using the 
first item in the list and then 

06:42:04.547 --> 06:42:06.547
the next page by using the last 
item in the list.

06:42:08.610 --> 06:42:10.299
Basically every item can 
identify a page after or before 

06:42:10.300 --> 06:42:13.377
it.  
If your data source is like that

06:42:13.378 --> 06:42:15.378
you 

06:42:16.437 --> 06:42:18.259
should implement the item keep 
data source clause.  You provide

06:42:18.260 --> 06:42:22.350
the key type.  In this case we 
are using names so string and 

06:42:22.351 --> 06:42:27.695
item type in the list.  
Let's get an example.  So first 

06:42:27.696 --> 06:42:29.696
time you come to the recycler 

06:42:33.560 --> 06:42:35.560
view, let's call

06:42:37.526 --> 06:42:39.526
the load initial method, request

06:42:42.629 --> 06:42:44.629
initial key, request load size 
and place 

06:42:47.516 --> 06:42:51.829
holders enabled.  Data source 
will only return this data, it's

06:42:51.830 --> 06:42:55.328
not going to count it because 
there's no place holders.  As 

06:42:55.329 --> 06:42:57.806
soon as users start scrolling we
will extract a key from the last

06:42:57.807 --> 06:42:59.807
item we 

06:43:01.313 --> 06:43:03.331
have and call the data source 
load after method to load that 

06:43:03.332 --> 06:43:05.332
other page.

06:43:08.406 --> 06:43:10.406
Similarly as user keeps 
scrolling

06:43:11.509 --> 06:43:13.509
and then loads another page the 
same way. 

06:43:16.205 --> 06:43:17.633
Now at this point let's say the 
data is coming from the 

06:43:17.634 --> 06:43:20.885
database, similarly something 
has changed so we lost that data

06:43:20.886 --> 06:43:22.886
source.  Minimal data.

06:43:27.620 --> 06:43:30.043
We will get the new data source 
by recreating new page list, we 

06:43:30.044 --> 06:43:32.044
are going to extract the key 
from one of the items 

06:43:35.074 --> 06:43:39.258
that is currently visible in the
recycler view and load the page 

06:43:39.259 --> 06:43:41.259
from this new data source.

06:43:42.314 --> 06:43:44.750
And we get that page, we 
understand these are pages, we 

06:43:44.751 --> 06:43:46.751
will calculate the 

06:43:47.816 --> 06:43:49.816
dif and update the UI with the 
correct animations. 

06:43:51.300 --> 06:43:53.300
Now, we don't have the data on 
top 

06:43:54.757 --> 06:43:56.757
anymore so if user tries to 
scroll up we need more data.

06:44:02.099 --> 06:44:04.099
Same thing, you just take the 
key from 

06:44:06.633 --> 06:44:08.477
the last item, call load, get 
that page appended to the page 

06:44:08.478 --> 06:44:10.478
list and now user can scroll 
upwards.

06:44:14.165 --> 06:44:16.165
This is always lazy, always 
reactive.  

06:44:16.825 --> 06:44:19.455
Third one is the page keyed data
source.  This is a really common

06:44:19.456 --> 06:44:21.933
way of paging especially on the 
server side APIs.

06:44:26.228 --> 06:44:28.528
Your client sends a question and
when the response comes from the

06:44:28.529 --> 06:44:30.529
server it 

06:44:31.630 --> 06:44:33.630
include the data and also 
includes 

06:44:35.457 --> 06:44:38.020
pointers for the next and 
previous keys.  

06:44:42.339 --> 06:44:45.003
So if you have a data source 
like that you should implement 

06:44:45.004 --> 06:44:47.004
the page key data 

06:44:49.075 --> 06:44:50.295
source, specify the type of keys
using the pointers and item 

06:44:50.296 --> 06:44:52.550
type.  Let's look at an example.

06:44:56.387 --> 06:44:58.387
First time user comes

06:44:59.485 --> 06:45:01.485
comes, we called load initial, 
give it 

06:45:05.673 --> 06:45:07.673
a size and ask whether place 
holders enabled or not.

06:45:10.589 --> 06:45:13.445
We will assume disabled, easier.
And then the data source turns 

06:45:13.446 --> 06:45:15.446
the 

06:45:16.526 --> 06:45:18.966
data but also gives us pointers 
for the previous key and the 

06:45:18.967 --> 06:45:21.882
next page key. 
Let me start displaying it.

06:45:25.554 --> 06:45:27.554
If user scrolls, we need more 
contact 

06:45:29.034 --> 06:45:31.907
so we are going to call the load
after method, use the key that 

06:45:31.908 --> 06:45:35.388
was returned in the previous 
request to get the next page 

06:45:35.389 --> 06:45:37.389
from the data source.

06:45:42.525 --> 06:45:45.138
Now this next page comes with a 
field called adjacent page key.

06:45:48.188 --> 06:45:50.188
It's like a list of pages. 

06:45:53.082 --> 06:45:55.323
You take that, user can scroll. 
Now the difference in this data 

06:45:55.324 --> 06:45:57.324
source 

06:45:59.403 --> 06:46:01.403
is how we have the invaldation.

06:46:03.098 --> 06:46:05.098
Hit the refresh button on the 
screen, 

06:46:06.624 --> 06:46:08.055
we will get the new data source,
but in the load initial method 

06:46:08.056 --> 06:46:10.056
there's no key anymore.

06:46:12.383 --> 06:46:15.234
This is because I mentioned it's
like a link list so if the 

06:46:15.235 --> 06:46:17.317
previous list is invalid, links 
in the list doesn't mean 

06:46:17.718 --> 06:46:23.226
anything.  So always need to log
the very first page again and 

06:46:23.227 --> 06:46:25.464
display to the UI.  This is 
usually not a problem in 

06:46:28.169 --> 06:46:30.656
practice because you only do 
this if user does swipe to 

06:46:30.657 --> 06:46:32.657
refresh so they're already on 
top of the list.

06:46:38.215 --> 06:46:39.453
the list. 
&gt;&gt; CHRIS CRAIK:  You talked 

06:46:39.454 --> 06:46:41.454
through what 

06:46:43.299 --> 06:46:45.299
we might see

06:46:48.934 --> 06:46:50.934
implementing a data source but 
what if 

06:46:55.092 --> 06:46:57.162
we want multiple sources at 
once.  You can page from your 

06:46:57.163 --> 06:46:59.644
back end that you have with all 
the benefits of the local cache.

06:47:01.895 --> 06:47:03.895
You can have a really nice off 
line 

06:47:05.353 --> 06:47:06.578
support, you can resume quickly 
if the application has been 

06:47:06.579 --> 06:47:08.579
killed and 

06:47:10.263 --> 06:47:12.924
restarted and you can minimize 
network traffic by taking 

06:47:12.925 --> 06:47:16.989
advantage of data already on 
device.  Let's look at how this 

06:47:16.990 --> 06:47:21.055
might look compared to what we 
were showing before with a 

06:47:21.056 --> 06:47:23.298
single source of data.  How does
the network fit into the system?

06:47:26.620 --> 06:47:28.467
One way that we could do this is
we could say well the network is

06:47:28.468 --> 06:47:30.468
my source 

06:47:31.523 --> 06:47:33.550
of data when I'm connected and 
the database is my source when 

06:47:33.551 --> 06:47:36.412
I'm not.  If I'm connected I 
page data from the 

06:47:39.670 --> 06:47:42.666
network and if I'm not I page 
data from the database.  

06:47:43.665 --> 06:47:43.916
The one problem there is that 
you don't have anything storing 

06:47:43.917 --> 06:47:46.743
data in your database even when 
you're loading a 

06:47:51.006 --> 06:47:53.464
network but it's pretty easy as 
a side affect you can load into 

06:47:53.465 --> 06:47:56.543
the database.  However there's a
couple problems that are 

06:47:56.544 --> 06:47:58.834
important to discuss.  This 
switching model has the first 

06:47:59.035 --> 06:48:04.745
problem.  This connected state 
is really over simplifying.  In 

06:48:04.746 --> 06:48:06.386
reality individual requests to 
your servers can succeed and 

06:48:06.387 --> 06:48:08.387
fail and a user 

06:48:10.484 --> 06:48:12.755
that is connected like 20%, some
of the packets go through, that 

06:48:12.756 --> 06:48:14.756
really doesn't fit nicely into 
this model.

06:48:17.040 --> 06:48:18.921
The other big problem is we are 
not using local data when it's 

06:48:18.922 --> 06:48:23.876
present.  Let's go about looking
at a different way to do this.  

06:48:23.877 --> 06:48:28.791
So what if instead we just 
monitor the database and use 

06:48:28.792 --> 06:48:30.792
that as our local 

06:48:32.223 --> 06:48:34.223
single source of truth.

06:48:36.197 --> 06:48:36.227
What we can do is say well the 
only times I need to load data 

06:48:36.228 --> 06:48:40.729
is when the database tells me 
it's out of data.  I can use 

06:48:40.730 --> 06:48:42.730
that as a signal to load more 
data from the network, store it 

06:48:46.845 --> 06:48:48.845
into the database, and then I 
have my entire solution built.

06:48:50.921 --> 06:48:51.947
I just load data when I need to 
but I can present only the 

06:48:51.948 --> 06:48:55.050
database which makes things a 
lot simpler.  

06:48:59.376 --> 06:49:01.816
So we get the benefits of 
consistent data presentation, we

06:49:01.817 --> 06:49:03.817
have a similar 

06:49:05.709 --> 06:49:07.709
process but this degrades on 
failures.

06:49:10.401 --> 06:49:12.658
If your user is in in 20% 
connected state you can use all 

06:49:12.659 --> 06:49:14.659
the data you have 

06:49:17.378 --> 06:49:18.207
locally and try and fetch or 
retry when the network is 

06:49:18.208 --> 06:49:22.560
around.  Potentially you might 
say this doesn't keep my data 

06:49:22.561 --> 06:49:24.561
fresh.

06:49:25.840 --> 06:49:27.840
An easy way to work around that 
is say 

06:49:31.173 --> 06:49:33.237
when ever anyone starts new data
we start a new fresh.  And 

06:49:33.238 --> 06:49:35.238
that's especially important 
usually when you have frequently

06:49:35.941 --> 06:49:40.652
updating data. 
So in that proposed model here 

06:49:40.653 --> 06:49:45.001
that we saw we need an out of 
data signal from the database 

06:49:45.002 --> 06:49:47.265
because the rest of that we 
basically already built in the 

06:49:47.266 --> 06:49:49.266
first few slides.

06:49:50.788 --> 06:49:52.211
So when we have that signal we 
can trigger loads from the 

06:49:52.212 --> 06:49:56.513
network directly into the 
database and the UI doesn't have

06:49:56.514 --> 06:50:00.005
to enter into any of that. 
So paging built exactly this 

06:50:00.006 --> 06:50:02.006
signal for 

06:50:03.273 --> 06:50:05.551
exactly this reason and we call 
the the boundary call back.  

06:50:05.552 --> 06:50:07.552
Let's look at what that might 
look like. 

06:50:08.819 --> 06:50:10.451
The first most important part of
the boundary call back that you 

06:50:10.452 --> 06:50:12.452
implement is 

06:50:13.519 --> 06:50:15.568
that you pass it to -- you want 
to provide it two different 

06:50:15.569 --> 06:50:19.423
sources of data, the database 
and the network, because that's 

06:50:19.424 --> 06:50:21.424
its job.  

06:50:23.505 --> 06:50:27.986
So the important call back we 
have here is on I'm end loaded. 

06:50:27.987 --> 06:50:29.841
The last item of the database 
has been loaded from the paged 

06:50:29.842 --> 06:50:32.280
list and if there's more from 
the network it's time to load 

06:50:32.281 --> 06:50:35.626
it.  
So the first thing that we do in

06:50:38.701 --> 06:50:41.149
response to this is over run the
network thread, request the 

06:50:41.150 --> 06:50:43.386
service hey give me more data.  
In this particular case we are 

06:50:43.387 --> 06:50:45.387
using 

06:50:46.447 --> 06:50:49.109
the item at the end to feed 
which data we need more of 

06:50:49.110 --> 06:50:51.821
because we are in an item key 
case similar to the item key 

06:50:53.047 --> 06:50:55.047
data source that you saw before.

06:50:59.627 --> 06:51:01.627
Now if that request is 
successful we we 

06:51:04.393 --> 06:51:05.816
simply jump over the the 
database thread, insert that 

06:51:05.817 --> 06:51:08.269
data and we are basically done. 
We connected that signal that we

06:51:09.897 --> 06:51:11.897
needed and now we added network 
to 

06:51:14.187 --> 06:51:16.225
something that was purely 
database.  It's possible when 

06:51:16.226 --> 06:51:18.226
the database is 

06:51:19.236 --> 06:51:23.051
being invalidated locally for 
multiple add end signals to 

06:51:23.052 --> 06:51:25.934
trigger.  You can protect this 
with a simple 

06:51:29.215 --> 06:51:31.215
boolean to say if I'm already 
loading, don't try. 

06:51:32.905 --> 06:51:34.905
And then we can re-set that at 
the end.

06:51:37.227 --> 06:51:39.227
So using boundary call back is 
pretty simple.

06:51:41.494 --> 06:51:43.494
You can add this in your Rx page
list 

06:51:44.585 --> 06:51:46.585
builder and that gives you the 
database 

06:51:47.888 --> 06:51:50.748
plus network solution all 
isolated in that one call back. 

06:51:50.749 --> 06:51:52.749
Let's talk about what the paging
library is.

06:51:55.162 --> 06:51:56.386
So the paging library provides 
paging from database network and

06:51:56.387 --> 06:52:00.461
importantly both as we just saw 
and it can load that data 

06:52:00.462 --> 06:52:02.462
directly into recycler view.  

06:52:04.772 --> 06:52:06.772
It extends this live data of 
lists, this 

06:52:08.031 --> 06:52:10.892
observable list pattern that we 
like because it keeps our UI 

06:52:10.893 --> 06:52:14.963
simple and let's us contain all 
the complex logic on one side.  

06:52:14.964 --> 06:52:16.964
It's configurable.

06:52:20.876 --> 06:52:22.876
We have configurable load size, 

06:52:23.880 --> 06:52:25.880
pre-Fitch

06:52:26.983 --> 06:52:29.228
and place holders.  1.

06:52:35.545 --> 06:52:37.545
0 was just released so

06:52:39.871 --> 06:52:41.871
so please try and give it a 
spin.  

06:52:43.363 --> 06:52:45.595
&gt;&gt; YIGIT BOYAR:  Where to go 
next?  We will provide more 

06:52:45.596 --> 06:52:49.290
details and more samples here.  
We have an amazing code lab.

06:52:52.335 --> 06:52:53.559
You can change it out in the 
code lab area or you can try it 

06:52:53.560 --> 06:52:55.560
online.

06:52:58.866 --> 06:53:00.866
We also have have samples on 
GitHub 

06:53:02.163 --> 06:53:04.647
where we implement different 
data sources and you can compare

06:53:04.648 --> 06:53:08.727
and contrast the behavior have 
different data sources and you 

06:53:08.728 --> 06:53:10.728
can also see how you can handle 

06:53:12.804 --> 06:53:14.804
things like errors, retries.

06:53:17.284 --> 06:53:19.284
But if you have been sitting 
here for 

06:53:20.551 --> 06:53:22.551
the last 30 minutes and 
wondering 

06:53:26.461 --> 06:53:29.019
whether these two guys never 
heard about cursors, rest assure

06:53:29.020 --> 06:53:35.214
we did hear about that.  What we
wanted to use initially when we 

06:53:35.215 --> 06:53:37.215
started this project because we 

06:53:39.488 --> 06:53:42.158
already have cursor adapters, 
courseier takes care of all the 

06:53:42.159 --> 06:53:44.159
work, right?  Wrong.

06:53:45.870 --> 06:53:47.870
It's very unpredictable and 

06:53:50.556 --> 06:53:55.132
unefficient in your cursor 
becomess locked.  Be very 

06:53:55.133 --> 06:53:57.133
careful.

06:53:59.136 --> 06:54:01.136
Room and paging together avoids 
this 

06:54:04.171 --> 06:54:05.227
problem because we create much 
smaller queries not to rely on 

06:54:05.228 --> 06:54:07.228
the paging 

06:54:10.724 --> 06:54:12.724
behavior of cursors.

06:54:14.034 --> 06:54:15.684
There's an amazing blog post 
about this that you can watch 

06:54:15.685 --> 06:54:18.940
the link.  We will post it after
the talk.  It's amazing.

06:54:22.435 --> 06:54:24.435
Cursor as paging is not the 
right way to the paging.

06:54:26.905 --> 06:54:30.034
We did it wrong.  
&gt;&gt; CHRIS CRAIK:  Did it wrong 

06:54:30.035 --> 06:54:33.131
ten years ago at least.  
&gt;&gt; YIGIT BOYAR:  Ten years ago. 

06:54:33.132 --> 06:54:35.132
But it's not me.  Okay.

06:54:38.479 --> 06:54:40.479
[Laughter] so paging is part of 
Jetpack.

06:54:43.921 --> 06:54:47.959
Our new initiative to accelerate
Android development.  We have 

06:54:47.960 --> 06:54:52.674
great many talks at this I/O.  
This was the last one.  If you 

06:54:52.675 --> 06:54:55.588
were not able to go all the 
sessions check everything on 

06:54:55.589 --> 06:54:57.589
YouTube, it's recorded.

06:54:59.855 --> 06:55:01.284
And you can learning about 
Jetpack on our website.  Thank 

06:55:01.285 --> 06:55:03.285
you.

06:55:04.689 --> 06:55:06.689
(Applause)

06:55:29.522 --> 06:55:31.173
.
&gt;&gt; Thank you for joining this 

06:55:31.174 --> 06:55:35.526
session.  Grand ambassadors will
assist with directing you 

06:55:35.527 --> 06:55:38.209
through the designated exits.  
We will be making room for those

06:55:38.210 --> 06:55:42.312
who registered for the next 
session.  If you registered for 

06:55:42.313 --> 06:55:46.602
the next session in this room we
ask that you please clear the 

06:55:46.603 --> 06:55:48.226
room and return via the 
registration line outside.  

06:55:48.227 --> 06:55:50.227
Thank you.

06:56:48.197 --> 06:56:50.197
Distributed TensorFlow training.

06:56:57.310 --> 06:56:59.310
Training  

07:02:19.885 --> 07:02:23.885
Distributed TensorFlow Training 

07:11:53.536 --> 07:11:55.536
. 

07:12:04.603 --> 07:12:06.603
Distributed TensorFlow training.

07:12:10.578 --> 07:12:12.578
Training  

07:16:38.071 --> 07:16:40.575
.
&gt;&gt; Welcome.  Please fill in the 

07:16:40.576 --> 07:16:42.576
seats near the front of the 
room.  Thank you.

07:16:52.849 --> 07:16:54.849
Disputed TensorFlow training.

07:17:00.531 --> 07:17:02.531
Training  

07:19:12.341 --> 07:19:14.341
Eps

07:19:21.851 --> 07:19:24.288
.
&gt;&gt; At this time please find your

07:19:24.289 --> 07:19:27.596
seat.  Our session will begin 
soon.   

07:19:38.439 --> 07:19:40.439
Distributed TensorFlow Training.

07:22:20.888 --> 07:22:26.004
.
&gt;&gt; Hello, everyone.  Welcome.  

07:22:26.005 --> 07:22:28.005
What a busy last few days this 
has been.

07:22:29.894 --> 07:22:32.549
Thank you for being with us 
until the very end.  My name is 

07:22:32.550 --> 07:22:35.391
Priya.  
&gt;&gt; ANJALI SRIDHAR:  And I'm 

07:22:35.392 --> 07:22:37.392
Anjali.  
&gt;&gt; PRIYA GUPTA:  We are on the 

07:22:37.835 --> 07:22:39.835
TensorFlow team.

07:22:42.345 --> 07:22:45.193
We are so excited to be here 
today to tell you about 

07:22:45.194 --> 07:22:50.926
distributed TensorFlow training.
Let me grab the clicker.  Okay. 

07:22:50.927 --> 07:22:53.570
Hopefully most of you know what 
TensorFlow is.  It's an open 

07:22:53.571 --> 07:22:55.571
source Machine Learning 

07:22:59.271 --> 07:23:01.271
framework used extensively both 
inside and outside Google.

07:23:04.387 --> 07:23:05.603
For example if you're trying the
smart compose feature that was 

07:23:05.604 --> 07:23:09.482
launched a couple days ago, that
feature uses TensorFlow.  

07:23:12.985 --> 07:23:14.985
TensorFlow allows you to build, 
train 

07:23:18.685 --> 07:23:20.926
and predict using neural such as
this.  In training we learned 

07:23:20.927 --> 07:23:24.400
the parameters of the network 
using data.  

07:23:27.051 --> 07:23:29.051
Training complex neural networks
with 

07:23:30.521 --> 07:23:32.521
large amounts of data with often
take a 

07:23:33.834 --> 07:23:35.834
long time n the graph you can 
see the 

07:23:38.270 --> 07:23:40.614
training time on the X axis and 
the accuracy of predictions on 

07:23:40.615 --> 07:23:43.611
the Y axis

07:23:47.148 --> 07:23:49.821
.  As you can see, it took more 
than 80 hours to get to 75% 

07:23:49.822 --> 07:23:55.348
accuracy.  If you have some 
experience running complex 

07:23:55.349 --> 07:23:57.809
Machine Learning models this 
might sound rather familiar to 

07:23:57.810 --> 07:23:59.810
you and 

07:24:00.870 --> 07:24:02.870
it might make you feel something
like this.

07:24:05.552 --> 07:24:07.613
If you're training takes only a 
few minutes to a few hours 

07:24:07.614 --> 07:24:11.327
you'll be productive and happy 
and you can try out new ideas 

07:24:11.328 --> 07:24:13.328
faster.

07:24:14.371 --> 07:24:16.438
When it starts the take a few 
days, maybe you can manage and 

07:24:16.439 --> 07:24:20.912
run a few things in parallel.  
When it starts to take a few 

07:24:20.913 --> 07:24:22.913
weeks 

07:24:23.956 --> 07:24:25.987
your progress will slow down and
it becomes expensive to try out 

07:24:25.988 --> 07:24:27.988
every new idea.

07:24:30.954 --> 07:24:31.754
And when it starts to take more 
than a month I think it's not 

07:24:31.755 --> 07:24:33.755
even worth thinking about.

07:24:36.843 --> 07:24:38.843
And this is not an exaggeration.

07:24:41.943 --> 07:24:43.943
Training complex models can take
up to 

07:24:45.603 --> 07:24:49.480
a week on a single but powerful 
GPU like a Tesla P 100.  

07:24:52.120 --> 07:24:54.120
So natural question to ask is 
how can we make training fast?

07:24:56.693 --> 07:24:58.693
There are a number of things you
can try.

07:25:00.380 --> 07:25:04.452
You can use the faster 
accelerators such as a TPU.  I'm

07:25:04.453 --> 07:25:06.453
sure you've heard all about them
in the last couple of days here.

07:25:10.960 --> 07:25:15.693
Your input pipeline might be the
bottle neck.  There are a number

07:25:15.694 --> 07:25:19.750
of guidelines on the TensorFlow 
website that you can try and 

07:25:19.751 --> 07:25:21.751
improve the performance or your 
training.

07:25:23.050 --> 07:25:24.879
In this talk we will talks on 
distributed training that is 

07:25:24.880 --> 07:25:27.568
running training in parallel on 
multiple devices 

07:25:32.887 --> 07:25:33.919
such as CPUs, GPUs, or TPUs in 
order to make your training 

07:25:33.920 --> 07:25:36.155
faster. 
With the techniques that we will

07:25:36.156 --> 07:25:38.156
talk about in this talk, you can
bring down 

07:25:41.074 --> 07:25:43.074
your training time from weeks to
hours 

07:25:45.983 --> 07:25:49.445
with just a few lines of code 
and a few powerful GPUs.  In the

07:25:49.446 --> 07:25:52.193
graph you can see the images per
second processed while training 

07:25:52.194 --> 07:25:55.882
an image recognition model.  As 
you can see as we increase the 

07:25:58.771 --> 07:26:00.771
number of GPUs from 1 to 4 to 8,
the 

07:26:02.643 --> 07:26:04.643
images per second process can 
almost double every time.

07:26:11.333 --> 07:26:14.292
We will come back to these 
performance numbers later.  

07:26:14.293 --> 07:26:16.564
Before we get into the details 
of scaling in TensorFlow, first 

07:26:16.565 --> 07:26:18.565
I want to 

07:26:20.069 --> 07:26:21.116
cover a few high level concepts 
and architectures in distributed

07:26:21.117 --> 07:26:23.117
training.

07:26:25.666 --> 07:26:29.399
This will give us a strong 
foundation to understand the 

07:26:25.666 --> 07:26:27.666
various solutions.

07:26:30.669 --> 07:26:33.664
As you're focused on training 
today, let's take a look at what

07:26:33.665 --> 07:26:37.539
a typical training loop looks 
like.  Let's say you have a 

07:26:37.540 --> 07:26:39.540
simple model like 

07:26:41.010 --> 07:26:43.010
this with a couple of hidden 
layers, 

07:26:46.274 --> 07:26:49.173
each layer has a bunch of of 
weights and biases also called 

07:26:50.212 --> 07:26:52.212
trainable variables.

07:26:53.467 --> 07:26:55.502
A training step begins with 
processing on the input data but

07:26:55.503 --> 07:26:57.751
then feeds this input into the 
model and computes the 

07:27:00.817 --> 07:27:03.481
productions in the forward pass.
We then compare the productions 

07:27:03.482 --> 07:27:05.482
with 

07:27:06.944 --> 07:27:08.944
the input label and compare -- 
compute the locals.

07:27:12.424 --> 07:27:14.424
Then in the backward pass we 
compute

07:27:16.170 --> 07:27:18.216
the gradient and finally we 
update the models using the 

07:27:18.217 --> 07:27:20.217
gradient.

07:27:21.635 --> 07:27:23.635
This

07:27:25.295 --> 07:27:27.295
is known as one training step.

07:27:28.544 --> 07:27:31.184
It repeats until you reach the 
desired accuracy.  Let's say you

07:27:31.185 --> 07:27:33.641
begin your training with a 
simple machine under your desk 

07:27:33.642 --> 07:27:35.642
with a multi-core CPU.

07:27:38.720 --> 07:27:41.369
Luckily TensorFlow handles 
scaling for you automatically.

07:27:45.046 --> 07:27:47.046
Next you may speed up by adding 
an 

07:27:48.499 --> 07:27:50.499
accelerator to your machine but 

07:27:51.568 --> 07:27:53.568
distributed training you can go 
even further.

07:27:55.827 --> 07:27:56.848
You can go from one machine with
a single device to one machine 

07:27:56.849 --> 07:27:58.849
with 

07:27:59.896 --> 07:28:02.132
multiple devices and finally to 
multiple machines with possibly 

07:28:02.133 --> 07:28:06.017
multiple devices each connected 
over the network.  

07:28:08.867 --> 07:28:10.867
With a number of techniques 
eventually 

07:28:11.925 --> 07:28:14.169
it's possible to scale to 
hundreds of devices and that's 

07:28:14.170 --> 07:28:16.170
what we do in a lot 

07:28:17.636 --> 07:28:20.023
of Google systems.  In the rest 
of this talk we will use 

07:28:23.271 --> 07:28:25.695
the terms device, worker or 
accelerator to refer to 

07:28:25.696 --> 07:28:27.696
processing units such as GPUs or
TPUs.  

07:28:30.985 --> 07:28:32.985
So how does distributed training
work?

07:28:34.054 --> 07:28:35.886
There are a number of ways to go
about when you think about 

07:28:35.887 --> 07:28:39.598
distributing your training.  
What approach you pick depends 

07:28:39.599 --> 07:28:44.867
on tb size of your model, the 
amount of training data you 

07:28:44.868 --> 07:28:46.868
have, and the 

07:28:47.876 --> 07:28:50.576
available devices.  The most 
common architecture and 

07:28:54.668 --> 07:28:58.366
distributed training is what is 
known as data parallelism.  In 

07:28:58.367 --> 07:29:00.821
data parallelism we run the same
model and computation on each 

07:29:00.822 --> 07:29:06.344
worker but with a different 
slice of the input data.  Each 

07:29:06.345 --> 07:29:08.345
device computes the loss and 

07:29:10.824 --> 07:29:12.824
gradient, uses gradients to 
updates the model parameters.

07:29:14.688 --> 07:29:16.719
And the updated model is used in
the next round of computation.  

07:29:16.720 --> 07:29:20.365
There are two common approaches 
within you think about how do 

07:29:20.366 --> 07:29:22.366
you update the 

07:29:23.628 --> 07:29:25.628
models using these gradients.

07:29:27.562 --> 07:29:30.003
The first approach is what is 
known as async parameter server 

07:29:30.004 --> 07:29:32.004
approach.

07:29:34.491 --> 07:29:36.491
In this approach we designate 
some 

07:29:37.552 --> 07:29:39.552
devices as parameter servers as 
shown in blue here.

07:29:41.413 --> 07:29:43.413
These servers hold the 
parameters of the model.

07:29:44.887 --> 07:29:46.917
Others are designated as 
workers, as shown in green leer.

07:29:50.383 --> 07:29:52.839
Workers do the bulk of the 
computation.  Each worker 

07:29:52.840 --> 07:29:54.840
fetches the parameters 

07:29:58.675 --> 07:30:00.673
from the parameter server, it 
then computes the loss and 

07:30:00.674 --> 07:30:05.684
gradients, sends the gradients 
back to the parameter server 

07:30:05.685 --> 07:30:07.687
which then updates the models 
parameters using these 

07:30:07.688 --> 07:30:09.659
gradients.  
Each worker does this 

07:30:09.660 --> 07:30:13.917
independently so this allows us 
to scale this approach to a 

07:30:13.918 --> 07:30:16.163
large number of workers.  This 
has worked well for many models 

07:30:20.220 --> 07:30:23.090
in Google where training workers
might be preempted by high 

07:30:23.091 --> 07:30:25.091
priority production 

07:30:26.372 --> 07:30:28.031
jobs or where there's asymmetry 
between the workers or where 

07:30:28.032 --> 07:30:31.759
machines might go down for 
regular maintenance.  And all of

07:30:31.760 --> 07:30:33.808
this doesn't hurt the scaling 
because the workers are not 

07:30:34.826 --> 07:30:38.101
waiting on each other.  
The down side of this approach, 

07:30:38.102 --> 07:30:40.102
however, 

07:30:41.759 --> 07:30:44.435
is that workers can get out of 
sync, they're computing their 

07:30:44.436 --> 07:30:46.436
gradients on 

07:30:47.515 --> 07:30:49.959
stale parameter values and this 
can delay convergence.  

07:30:54.052 --> 07:30:58.522
The second approach is what is 
known as synchronous allreduce. 

07:30:58.523 --> 07:31:00.523
This has become more common with
the 

07:31:02.648 --> 07:31:04.733
rise of fast accelerators such 
as TPUs or GPUs.  In this 

07:31:04.734 --> 07:31:07.611
approach each worker has a copy 
of parameters on its own, there 

07:31:07.612 --> 07:31:09.661
are no special parameter 
servers.

07:31:13.328 --> 07:31:15.328
Each worker computes the loss 
and 

07:31:17.362 --> 07:31:19.362
gradients based on a subset of 
training samples.

07:31:22.219 --> 07:31:24.272
Once gradients are computed the 
workers communicate among 

07:31:24.273 --> 07:31:27.251
themselves to propagate the 
gradients and update the model 

07:31:27.252 --> 07:31:29.252
parameters.

07:31:30.931 --> 07:31:33.818
All the workers are synchronized
which means the next round of 

07:31:33.819 --> 07:31:35.819
computation doesn't begin until 
each worker received 

07:31:38.900 --> 07:31:40.900
the updated gradients and 
updateed this model. 

07:31:41.130 --> 07:31:43.130
When you have fast devices in a 

07:31:44.621 --> 07:31:46.859
controlled environment, the 
variants of set time between the

07:31:46.860 --> 07:31:49.758
different workers can be small. 
When combined with strong 

07:31:51.617 --> 07:31:53.617
communication links between the 

07:31:56.707 --> 07:31:57.719
different devices, over all 
overhead or synchronization can 

07:31:57.720 --> 07:32:02.389
be small.  When ever practical 
this approach can lead to faster

07:32:02.390 --> 07:32:05.261
conversions.   

07:32:09.333 --> 07:32:11.333
A class of algorithms called 
allreduce 

07:32:12.783 --> 07:32:13.800
can be used to efficiently 
combine the gradients across the

07:32:13.801 --> 07:32:15.801
different workers.

07:32:20.160 --> 07:32:22.160
By adding them up and then 
copying them 

07:32:25.604 --> 07:32:27.604
to the different workers, it's a
fused

07:32:30.747 --> 07:32:32.747
algorithm that can be very 
efficient.  

07:32:36.087 --> 07:32:38.763
There are many allreduce 
algorithms available depending 

07:32:38.764 --> 07:32:39.980
on the time of communication 
available between the different 

07:32:39.981 --> 07:32:41.981
workers.

07:32:45.111 --> 07:32:47.111
One common algorithm is what is 
known as ring allreduce.

07:32:50.823 --> 07:32:52.823
Each worker sends gradients and 

07:32:55.040 --> 07:32:57.040
receives gradients from

07:32:58.746 --> 07:33:00.746
its predecessor.

07:33:02.025 --> 07:33:04.657
At the end of of the algorithm 
each worker has received a copy 

07:33:04.658 --> 07:33:08.145
of the combined gradient.   

07:33:13.779 --> 07:33:15.779
Ring allreduce uses network 
Bandwidth optimally.

07:33:18.127 --> 07:33:20.996
It can also overlap the gradient
computation at lower layers in 

07:33:20.997 --> 07:33:25.315
the network with transmission of
gradients at the higher layers 

07:33:25.316 --> 07:33:30.407
which means it can further 
reduce the training time.  Ring 

07:33:30.408 --> 07:33:32.408
allreduce is just one approach 

07:33:33.425 --> 07:33:35.425
and

07:33:37.895 --> 07:33:40.797
one approach.  We have a team in
Google working on 

07:33:45.286 --> 07:33:46.305
fast implementations of 
allreduce for various device 

07:33:46.306 --> 07:33:48.306
topologys.

07:33:50.440 --> 07:33:53.088
The bottom line is allreduce can
be fast when working with 

07:33:53.089 --> 07:33:55.144
multiple devices on a single 
machine or a small number of 

07:33:55.561 --> 07:33:57.817
machines.  

07:34:01.063 --> 07:34:03.298
So given these two architectures
and data parallelisms you may be

07:34:03.299 --> 07:34:07.378
wondering which approach should 
you pick.  There isn't one right

07:34:07.379 --> 07:34:11.728
answer.  Parameter server 
approach is preferable if you 

07:34:11.729 --> 07:34:13.729
have a large number of 

07:34:15.604 --> 07:34:18.041
not so powerful or not so 
reliable machines.  If you have 

07:34:18.042 --> 07:34:20.088
a large cluster of machines with
just CPUs.

07:34:26.536 --> 07:34:28.536
The synchronous allreduce 
approach is

07:34:34.446 --> 07:34:35.890
is preferible if you have -- 
parameter server approach has 

07:34:35.891 --> 07:34:37.891
been around for a 

07:34:40.375 --> 07:34:41.990
while and has been supported 
well.  TPUs use allreduce 

07:34:41.991 --> 07:34:44.870
approach out of the box.  
In the next section of this talk

07:34:44.871 --> 07:34:47.759
we will show you how you can 
scale your training 

07:34:51.778 --> 07:34:52.901
using the allreduce approach on 
multiple GPUs with just a few 

07:34:52.902 --> 07:34:58.016
lines of code.  
Before I get into that I just 

07:34:58.017 --> 07:35:02.928
want to mention another type of 
distributed training known as 

07:35:02.929 --> 07:35:04.929
model parallelism that you may 
have heard of.  

07:35:07.055 --> 07:35:09.055
A simple way to think about 
model 

07:35:10.103 --> 07:35:12.766
parallelism is when your model 
is so big that it doesn't fit in

07:35:12.767 --> 07:35:14.767
the memory of one device so you 
divide the model into 

07:35:17.865 --> 07:35:19.287
smaller parts and through those 
computations on different 

07:35:19.288 --> 07:35:23.802
workers with the same training 
samples.  For example, you could

07:35:23.803 --> 07:35:25.803
put different 

07:35:27.327 --> 07:35:30.188
layers of your model on 
different devices.  These 

07:35:30.189 --> 07:35:32.227
however most devices have big 
enough memory that most models 

07:35:32.228 --> 07:35:35.898
can fit in their memory.  So in 
the rest of this talk we will 

07:35:38.739 --> 07:35:40.739
continue to focus on data 
parallelism.

07:35:49.143 --> 07:35:51.143
Let's see how you can do this 
TensorFlow.

07:35:52.545 --> 07:35:54.545
As I already

07:35:57.320 --> 07:35:58.540
mentions we are going to focus 
on multiple GPUs with the 

07:35:58.541 --> 07:36:03.121
allreduce architecture.  I'm 
pleased to introduce the new 

07:36:05.154 --> 07:36:07.154
distribution strategy API.

07:36:08.210 --> 07:36:10.448
This allows you to distribute 
your training in TensorFlow with

07:36:10.449 --> 07:36:12.449
very little modification to your
code.

07:36:15.554 --> 07:36:17.554
The distribution strategy API 
you no 

07:36:18.810 --> 07:36:21.473
longer need to place your ops or
parameters on specific devices. 

07:36:21.474 --> 07:36:23.921
You don't need to worry about 
structuring your modeling in a 

07:36:23.922 --> 07:36:25.922
way that 

07:36:27.614 --> 07:36:29.243
the gradients or losses across 
devices are aggregated 

07:36:29.244 --> 07:36:32.499
correctly.  Distribution 
strategy does that for you.

07:36:35.957 --> 07:36:37.957
It is easy to use and fast to 
train.  

07:36:41.596 --> 07:36:44.125
Now let's look at some code to 
see how you can do this API.  

07:36:44.126 --> 07:36:46.568
In our example we are going to 
be using 

07:36:50.229 --> 07:36:52.229
TensorFlow's high level API call
estimator.

07:36:57.178 --> 07:37:01.311
If you've used this API before 
you might be familiar with the 

07:36:57.178 --> 07:36:59.178
following 

07:37:05.211 --> 07:37:06.177
snippet of code to create a 
custom estimator.  It requires 

07:37:06.178 --> 07:37:08.178
three argument also.

07:37:10.224 --> 07:37:10.241
The first one is a function that
defines your model so defines 

07:37:10.242 --> 07:37:12.378
the parameters of your model, 
how you compute the loss and the

07:37:12.379 --> 07:37:15.843
gradients and how you update the
model's parameters.  The second 

07:37:15.844 --> 07:37:18.506
argument is the directory where 
you wants to persist the state 

07:37:18.507 --> 07:37:21.407
of your model.  And the third 
argument is a 

07:37:30.136 --> 07:37:32.136
configuration call run con fig 
where you can specify things.

07:37:34.453 --> 07:37:36.453
In this case we used the default
run config.

07:37:38.145 --> 07:37:40.145
Wujs you create the estimator 
you can 

07:37:41.183 --> 07:37:42.619
start your training by kaug the 
train method with the input 

07:37:42.620 --> 07:37:45.056
function that provides your 
training data.

07:37:48.562 --> 07:37:50.562
Given this code to do the 
training on 

07:37:52.620 --> 07:37:55.267
one device, how can you change 
it to run on multiple GPUs?   

07:38:00.165 --> 07:38:02.606
You simply need to add one line 
of code.  Something called 

07:38:02.607 --> 07:38:07.088
mirrored strategy and pass it to
the run config.  That's all the 

07:38:07.089 --> 07:38:12.434
code changes you need to scale 
this code to multiple GPUs.  

07:38:12.435 --> 07:38:15.100
Mirrored strategy is a type of 
distribution strategy API that I

07:38:15.101 --> 07:38:17.101
just mentioned.

07:38:19.190 --> 07:38:21.190
For this API you don't need to 
make 

07:38:22.261 --> 07:38:23.270
any changes to your model 
function or input function or 

07:38:23.271 --> 07:38:28.158
training loop.  You don't need 
to specify your devices.  If you

07:38:28.159 --> 07:38:30.389
want to run on all available 
devices it will automatically 

07:38:30.390 --> 07:38:35.298
detect that and run your 
training on all available GPUs. 

07:38:35.299 --> 07:38:37.299
So that's it.  Those are all the
code changes you need.

07:38:41.616 --> 07:38:46.313
This API is available and you 
can try it out today.   

07:38:49.355 --> 07:38:51.355
Let me quickly talk about what 
mirror strategy does.

07:38:54.093 --> 07:38:56.155
Mirrored strategy implements the
synchronous allreduce 

07:38:56.156 --> 07:38:58.156
architecture that we talked 
about out of the box for you.

07:39:01.485 --> 07:39:05.971
In mirrored strategy the model's
parameters are mirrored across 

07:39:05.972 --> 07:39:07.972
devices hence the name mirrored 
strategy.

07:39:10.675 --> 07:39:13.144
Each device computes the last 
end gradient based on a subset 

07:39:13.145 --> 07:39:15.145
of the input data.

07:39:16.598 --> 07:39:18.643
The gradients are aggregated 
across the workers using an 

07:39:18.644 --> 07:39:21.295
allreduce algorithm that is 
appropriate for your device 

07:39:21.691 --> 07:39:25.772
topology.  
As I already mentioned with 

07:39:25.773 --> 07:39:30.079
mirrored strategy you don't need
to make any changes to your 

07:39:30.080 --> 07:39:32.080
model or your training loop.

07:39:34.799 --> 07:39:35.820
This is because we have changed 
line components of TensorFlow to

07:39:35.821 --> 07:39:37.821
be distribution aware.

07:39:41.566 --> 07:39:43.566
For example, optimizer, 
summaries, et cetera.

07:39:45.978 --> 07:39:48.417
You don't need to make any 
changes to your input function 

07:39:48.418 --> 07:39:50.418
as long as you're 

07:39:52.335 --> 07:39:55.589
using the recommended TensorFlow
data set API.  You can save with

07:39:55.590 --> 07:39:58.022
within or no distribution 
strategy and resume with 

07:39:59.038 --> 07:40:01.678
another.  And summaries work as 
expected as well 

07:40:05.396 --> 07:40:07.396
so you can continue to visualize
your 

07:40:08.403 --> 07:40:10.403
training

07:40:15.000 --> 07:40:19.097
in TensorFlow.  
I'll now hand it off to Anjali 

07:40:19.098 --> 07:40:21.098
to show 

07:40:23.180 --> 07:40:25.440
you cool demos and performance 
numbers.  (Applause). 

07:40:29.087 --> 07:40:31.129
&gt;&gt; ANJALI SRIDHAR:  Thanks, 
Priya, for the great 

07:40:31.130 --> 07:40:36.210
introduction to mirrored 
strategy.  Before we run the 

07:40:36.211 --> 07:40:38.864
demo, let's get familiar with a 
few configurations.

07:40:43.190 --> 07:40:45.190
I'm going to be running the res 
net 50 

07:40:46.192 --> 07:40:48.192
model from

07:40:49.919 --> 07:40:51.919
the TensorFlow model garden.

07:40:53.398 --> 07:40:55.398
It uses fit connections for 
every gradient flow.

07:41:00.581 --> 07:41:02.581
The TensorFlow model garden is a
repo 

07:41:03.626 --> 07:41:06.509
where there are a collection of 
gardens.  If you're new to 

07:41:06.510 --> 07:41:10.623
TensorFlow this is a great 
resource to start with.  I'm 

07:41:10.624 --> 07:41:12.870
going to be using the image net 
data set as input to model 

07:41:12.871 --> 07:41:18.369
training.  It's a collection of 
over a million images that have 

07:41:18.370 --> 07:41:20.370
been categorized into a 
thousands labels.  

07:41:23.034 --> 07:41:25.034
I'm going

07:41:30.991 --> 07:41:34.682
to intansate the N 1 standard 
and Tesla V 100.  Let's run the 

07:41:34.683 --> 07:41:36.683
demo now.

07:41:38.541 --> 07:41:40.541
As I mentioned I'm creating an N
1 

07:41:43.491 --> 07:41:45.491
standard instance attaching 
eight in 

07:41:48.128 --> 07:41:50.128
video Tesla V

07:41:55.725 --> 07:41:57.725
Nvidia Tesla V 100.

07:41:58.859 --> 07:42:00.859
To run our TensorFlow model we 
need to 

07:42:01.908 --> 07:42:03.908
install a few drivers and 
packages and 

07:42:05.581 --> 07:42:07.581
here is a gist with all the 
commands required.

07:42:08.907 --> 07:42:10.960
I'm going to make this public so
you can set up an instance 

07:42:10.961 --> 07:42:13.818
yourself and try running the 
model. 

07:42:16.488 --> 07:42:18.488
Let's open an SSH connection to 
the 

07:42:19.958 --> 07:42:22.397
instance by clicking on a button
here.  This should bring up a 

07:42:22.398 --> 07:42:24.398
terminal like this.

07:42:26.049 --> 07:42:28.080
I've already cloned the garden 
model repo.  We are going to be 

07:42:28.081 --> 07:42:30.081
running this 

07:42:33.754 --> 07:42:35.754
command inside the res net 
director

07:42:41.675 --> 07:42:43.675
.  We are are going to run the 
image net main fail.

07:42:50.686 --> 07:42:51.690
A model director is going to 
point  Batch size of 1024 or 128

07:42:51.691 --> 07:42:53.691
per GPU.

07:42:58.697 --> 07:43:00.682
to the bucket.  We point our 
data director to the SSD disk 

07:43:00.683 --> 07:43:02.720
writ has the image net data set 
and the number of GPUs is eight 

07:43:02.721 --> 07:43:04.764
of which we want to be able to 
train you're model. 

07:43:09.232 --> 07:43:11.885
So lets run this model now.  
Let's take a look at some of the

07:43:11.886 --> 07:43:13.886
code 

07:43:15.358 --> 07:43:17.188
changes that are involved to 
change the res net model 

07:43:17.189 --> 07:43:21.105
function.  This is the res net 
main function in the garden 

07:43:21.106 --> 07:43:23.106
model repo.

07:43:27.613 --> 07:43:30.107
First we instantiate the 
strategy and pass it to the run 

07:43:31.736 --> 07:43:33.736
config.

07:43:34.799 --> 07:43:36.799
We create an estimator object 
with the 

07:43:40.021 --> 07:43:42.021
run config and then

07:43:44.375 --> 07:43:46.625
and those are all the code 
changes you need to distribute 

07:43:46.626 --> 07:43:49.088
the res net model.  Let's go 
back and see how our training is

07:43:49.089 --> 07:43:51.142
going. 

07:43:55.582 --> 07:43:57.582
So we have run for a few hundred
steps.

07:43:59.390 --> 07:44:04.116
At the bottom of the screen you 
could see the metrics.  Let's 

07:44:04.117 --> 07:44:06.955
look at tensor board.  This is 
from a run where I've run the 

07:44:09.962 --> 07:44:13.456
model for 90 thousands steps.  
The orange and red lines are the

07:44:15.907 --> 07:44:17.907
training and evaluation losses.

07:44:19.981 --> 07:44:21.981
So as the number of steps very 
you see the loss decreasing.

07:44:24.923 --> 07:44:27.168
Let's look at evaluation 
accuracy and 

07:44:31.644 --> 07:44:33.644
this is when we are training res
net 50 over eight GPUs.

07:44:36.111 --> 07:44:38.111
Around 91,000 steps we are able 
to achieve a 75% accuracy.

07:44:41.259 --> 07:44:43.259
Let's see what this looks like 
when we 

07:44:46.323 --> 07:44:48.582
write on a single GPU so let's 
toggle the tensor board buttons 

07:44:48.583 --> 07:44:51.430
on the left and look at the lost
cause.

07:44:55.118 --> 07:44:57.118
So the blue lines are one GPU 
and red and orange are eight.

07:45:00.023 --> 07:45:02.251
You can see the loss doesn't 
decrease as rapidly as it does 

07:45:02.252 --> 07:45:04.252
with eight GPUs.

07:45:05.692 --> 07:45:07.692
Here are

07:45:10.275 --> 07:45:16.208
the evaluation accuracy codes.  
Let's compare using wall time.  

07:45:16.209 --> 07:45:20.492
So we run the same model nor the
same amount of time.  And when 

07:45:20.493 --> 07:45:23.355
we run it over multiple GPUs we 
are able to achieve higher 

07:45:23.356 --> 07:45:25.356
accuracy 

07:45:26.369 --> 07:45:31.201
facility accuracy faster or 
train our model faster. 

07:45:33.676 --> 07:45:35.676
Let's look at a few performance 

07:45:37.609 --> 07:45:41.316
benchmarks on the DGX one.  It's
a machine on which1.  It's a 

07:45:41.317 --> 07:45:43.317
machine on which we run deep 
learning models.

07:45:45.000 --> 07:45:47.846
We are running mixed precision 
training with a batch size of 

07:45:47.847 --> 07:45:49.847
256.

07:45:52.143 --> 07:45:54.143
It also has V 100 GPUs.

07:45:57.008 --> 07:45:59.252
So the graph shows X axis the 
number of GPUs on the X axis and

07:45:59.253 --> 07:46:03.526
images per second on the Y axis.
As we go from one GPU to eight 

07:46:03.527 --> 07:46:05.527
we are 

07:46:06.770 --> 07:46:09.451
able to achieve a speed up of 7 
X. 8 we are able to achieve a 

07:46:09.452 --> 07:46:12.504
speed up of 7 X.  And this is 
performance right out of the box

07:46:12.505 --> 07:46:16.972
with no tuning.  We are actively
working on improving performance

07:46:16.973 --> 07:46:18.973
so that you're able to 

07:46:21.029 --> 07:46:22.073
achieve more speed up and get 
more images per second when you 

07:46:22.074 --> 07:46:24.312
distribute your model across 
multiple GPUs.

07:46:30.490 --> 07:46:32.331
So far we have been talking 
about the core part of model 

07:46:32.332 --> 07:46:35.999
training and distributing your 
model using mirrored strategy.

07:46:40.059 --> 07:46:42.059
Let's say now you deployed your 
model on multiple GPUs.

07:46:43.137 --> 07:46:45.778
You're going to expect to see 
the same kind of boost in images

07:46:45.779 --> 07:46:50.682
per second when do you that but 
you may not be able to view as 

07:46:50.683 --> 07:46:52.683
many images the second as xarld 
to one GPU.

07:46:56.417 --> 07:46:58.640
You may not see the boost in 
performance and the reason for 

07:46:58.641 --> 07:47:00.641
that is 

07:47:02.103 --> 07:47:06.369
often the input pipelinecompared
to one GPU.  You may not see the

07:47:02.103 --> 07:47:05.969
boost in performance and the 
reason for that is often the 

07:47:02.103 --> 07:47:04.103
input pipeline.

07:47:05.569 --> 07:47:07.569
Run you run your model on a 
single GPU 

07:47:10.264 --> 07:47:12.715
the input pipeline is 
preprocessing the data and 

07:47:12.716 --> 07:47:14.716
making it available for 
training.

07:47:16.327 --> 07:47:20.180
But GPUs process and compute 
data much faster than a CPU.  

07:47:20.181 --> 07:47:22.830
This means that when you 
distribute your model across 

07:47:22.831 --> 07:47:24.931
multiple GPUs, the input 
pipeline is often not able to 

07:47:24.932 --> 07:47:26.932
keep up with the training.  

07:47:31.072 --> 07:47:33.103
It quickly becomes a bottle 
neck.  For the rest of the talk 

07:47:33.104 --> 07:47:35.104
I'm going to 

07:47:37.784 --> 07:47:39.784
show you how TensorFlow makes it
easy 

07:47:44.367 --> 07:47:47.648
for you to use data to build 
efficient input pipelines.  

07:47:50.709 --> 07:47:52.709
Here is a simple input pipeline 
for res net 50.

07:47:58.197 --> 07:48:00.197
We are going to use TF.

07:48:02.196 --> 07:48:07.485
data APIs.  When you have lots 
of data and different data 

07:48:07.486 --> 07:48:09.543
formats and you want to perform 
complex transformations on this 

07:48:13.366 --> 07:48:15.366
data you want to be using

07:48:17.096 --> 07:48:22.246
tf.data APIs to build your 
pipeline.  First get the list of

07:48:22.247 --> 07:48:26.525
input files that contain your 
image and labels.  Then we are 

07:48:26.526 --> 07:48:28.526
going to read these files 

07:48:30.189 --> 07:48:33.048
use the tf record data set 
reader.  We are going to shuffle

07:48:33.049 --> 07:48:35.049
the records.

07:48:36.102 --> 07:48:37.938
Repeat them a few times 
depending on if you want to run 

07:48:37.939 --> 07:48:39.939
your model for a 

07:48:43.132 --> 07:48:45.132
couple of epochs and finally 
apply a map transformation.

07:48:46.759 --> 07:48:48.759
This

07:48:50.685 --> 07:48:52.685
process transformation center, 
and 

07:48:56.845 --> 07:48:58.845
finally batch the input and into
a batch size that you desire.

07:49:11.077 --> 07:49:13.077
The input pipeline can be 
thought of

07:49:15.611 --> 07:49:17.840
as an ETL process as an ETL 
process.  In the extract phase 

07:49:17.841 --> 07:49:20.482
we are reading from storage.

07:49:27.693 --> 07:49:29.693
In the transform phase we are 
applying 

07:49:34.667 --> 07:49:34.713
the different transformations.  
And finally in the load phase we

07:49:34.714 --> 07:49:37.665
are providing this process data 
to the accelerator for training.

07:49:38.885 --> 07:49:40.885
So how does this apply to the 
example that we just saw?

07:49:45.434 --> 07:49:47.434
In the extract phase we list the
files 

07:49:49.258 --> 07:49:51.771
and read it using the tf.

07:49:56.214 --> 07:49:58.214
data record data set

07:50:00.549 --> 07:50:02.549
.  And finally in the load phase
we tell 

07:50:07.190 --> 07:50:09.190
TensorFlow how to grab the data 
from the 

07:50:11.251 --> 07:50:13.251
data set.  

07:50:14.736 --> 07:50:16.736
This is what our input pipeline 
looks like.

07:50:18.769 --> 07:50:20.775
We have the action the extract, 
transform and load phases 

07:50:20.776 --> 07:50:22.776
happening sequentially.  This 
means when the CPU is busy 

07:50:25.666 --> 07:50:28.954
preprocessing the data the 
accelerator is idle.  When the 

07:50:28.955 --> 07:50:30.955
accelerateor is training the 
model the CPU is idle.

07:50:34.982 --> 07:50:36.982
But the different phases of the 
ETL 

07:50:39.010 --> 07:50:41.010
process use different hardware 
sources.

07:50:47.501 --> 07:50:49.501
.  The training happens on the 
accelerator.

07:50:52.374 --> 07:50:54.374
So if we can parallelize these 

07:50:57.245 --> 07:50:59.956
different phases, then we can 
have the preprocessing of data 

07:50:59.957 --> 07:51:04.048
on the CPU with training of the 
model on the GPU.  This is 

07:51:04.049 --> 07:51:06.049
called pipelining.

07:51:07.731 --> 07:51:09.978
So we can use pipelining and 
some parallelizeation techniques

07:51:09.979 --> 07:51:11.979
to build 

07:51:13.681 --> 07:51:16.125
more efficient input pipelines. 
Let's look at a few of these 

07:51:16.126 --> 07:51:18.159
techniques.  

07:51:21.812 --> 07:51:23.812
First you can parallelize file 
reading.

07:51:25.330 --> 07:51:27.193
Let's say you have a lot of data
across the cloud storage 

07:51:27.194 --> 07:51:29.194
service.

07:51:31.891 --> 07:51:33.891
You want to read multiple files 
in 

07:51:38.194 --> 07:51:40.194
parallel and you can do this use

07:51:42.570 --> 07:51:44.570
can the num parallel reads.

07:51:46.651 --> 07:51:48.651
This allows you to increase your
effective.

07:51:50.327 --> 07:51:52.327
We can also parallelize map 
function 

07:51:53.333 --> 07:51:56.420
for transformations.  The 
different transformation for the

07:52:01.528 --> 07:52:03.528
map function by using the num 
parallel calls argument.

07:52:07.460 --> 07:52:09.460
Typically the argument may 
provide a 

07:52:10.924 --> 07:52:13.153
number of calls of the CPU.   

07:52:17.180 --> 07:52:19.180
And finally you want

07:52:24.996 --> 07:52:28.057
to call pre-fetch at the end of 
your pipeline.  You can buffer 

07:52:28.058 --> 07:52:32.165
data for the next training step 
while the accelerator is still 

07:52:32.166 --> 07:52:36.270
training the current step.   

07:52:39.962 --> 07:52:42.812
This is what we had before.  And
this is what we can get an 

07:52:43.616 --> 07:52:45.616
improvement on.  

07:52:48.092 --> 07:52:50.523
Here the different phases of the
input pipeline are happening in 

07:52:50.524 --> 07:52:52.524
parallel with training.

07:52:58.441 --> 07:53:00.441
We are able to see the CPU is

07:53:02.024 --> 07:53:04.024
preprocessing data in step two 
while 

07:53:06.101 --> 07:53:08.101
the training step is still in 
step one.

07:53:10.944 --> 07:53:13.897
The training time is now a 
maximum of preprocessing and 

07:53:13.898 --> 07:53:16.973
training on the accelerator.  As
you can see the accelerator is 

07:53:20.890 --> 07:53:22.890
still not 100% utilized.

07:53:24.755 --> 07:53:28.151
There are few advanced 
techniques that improve this.  

07:53:32.276 --> 07:53:34.914
We can use fused transformation 
ops for some of these API calls.

07:53:39.850 --> 07:53:41.850
Shuffle and repeat, for example,
can 

07:53:42.861 --> 07:53:44.861
be replaced by fused op.

07:53:50.462 --> 07:53:52.462
So this parallelizes buffering,

07:53:53.642 --> 07:53:55.642
epoch and plus one.

07:53:59.573 --> 07:54:03.873
We can also replace map and 
batch with equivalent fused op. 

07:54:03.874 --> 07:54:05.874
This parallelizes the map 

07:54:07.148 --> 07:54:09.148
transformation with adding the 
input tensors to batch.

07:54:11.620 --> 07:54:16.095
With these techniques we are 
able to process data much faster

07:54:16.096 --> 07:54:18.096
and make t 

07:54:19.582 --> 07:54:22.473
available to the accelerator for
training and improve the 

07:54:22.474 --> 07:54:24.474
training speed.

07:54:25.587 --> 07:54:29.653
it available to the accelerator 
for training and improve the 

07:54:25.587 --> 07:54:29.876
training speed. 
 I hope this gives you a good 

07:54:29.877 --> 07:54:31.877
idea of 

07:54:36.398 --> 07:54:38.469
how you can use APIs to build 
efficient input pipelines when 

07:54:38.470 --> 07:54:43.579
you train your model.   
So far we have been talking 

07:54:43.580 --> 07:54:49.310
about training on a single 
machine and multiple devices.  

07:54:49.311 --> 07:54:51.311
What if you wanted to train on 
multiple machines?

07:54:54.633 --> 07:54:56.633
You can use the estimators train
and evaluate API.

07:54:59.193 --> 07:55:01.836
Train and evaluate API using the
async parameter server approach.

07:55:07.123 --> 07:55:09.123
This API is used widely within 
Google 

07:55:10.183 --> 07:55:13.434
and it scales well to a large 
number of machines.  Here is a 

07:55:13.435 --> 07:55:15.435
link to the API where you can 
learn more on how to use it.

07:55:28.174 --> 07:55:30.174
We are also excited to be 
working on a 

07:55:32.186 --> 07:55:34.186
number of new distribution

07:55:35.672 --> 07:55:38.731
strategies.  We are working on a
multi machine mirrored strategy.

07:55:42.755 --> 07:55:43.691
We are also working on adding 
distribution strategy support to

07:55:43.692 --> 07:55:45.692
TPUs 

07:55:47.093 --> 07:55:50.377
and directly in tf.Keras.  In 
this talk we talked about the 

07:55:52.205 --> 07:55:54.677
different concepts related to 
distributed training 

07:55:54.678 --> 07:55:56.678
architectures and API.

07:56:00.416 --> 07:56:02.042
When you go home today here are 
three things to keep in mind 

07:56:02.043 --> 07:56:06.748
when you train your model.  
Distribute your training to make

07:56:06.749 --> 07:56:08.749
it faster.

07:56:11.880 --> 07:56:17.361
To do this, you want to use 
distribution strategy APIs.  

07:56:17.362 --> 07:56:19.362
They're easy to use and fast.

07:56:27.911 --> 07:56:29.911
Input pipeline performance is 
important

07:56:31.683 --> 07:56:33.683
.  

07:56:37.039 --> 07:56:39.706
Here are a few TensorFlow 
resources.  First we have the 

07:56:39.707 --> 07:56:41.707
distribution strategy API.

07:56:43.791 --> 07:56:45.791
You can try using mirrored 
strategy to 

07:56:48.314 --> 07:56:50.314
train your model across multiple
GPUs.  

07:56:52.812 --> 07:56:54.439
Here is a link to the res net 50
model garden example so you can 

07:56:54.440 --> 07:56:56.440
try running this example.

07:56:59.158 --> 07:57:01.158
It has mirrored strategy API 
support enabled.  

07:57:03.198 --> 07:57:05.198
Here is a link also to the input
pipe 

07:57:06.213 --> 07:57:08.213
lin

07:57:10.005 --> 07:57:12.005
performance guide which has more
techniques you can use to build 

07:57:12.084 --> 07:57:14.084
efficient pipelines.

07:57:15.752 --> 07:57:17.752
And here is the link to the gist
that I mentioned in the demo.

07:57:20.033 --> 07:57:22.033
You can try setting up your on 

07:57:25.187 --> 07:57:27.187
instance and running the res net
50 model garden example.

07:57:29.878 --> 07:57:35.409
So this is a combined effort 
involving a lot of folks on the 

07:57:35.410 --> 07:57:37.648
TensorFlow team and we are 
really excited to be heading in 

07:57:37.845 --> 07:57:42.764
this direction.  We are happy to
take questions off line near the

07:57:42.765 --> 07:57:45.039
community meet up spot.  Thank 
you for attending our talk and 

07:57:47.091 --> 07:57:49.091
we hope you had a great I/O.  

07:57:50.307 --> 07:57:52.307
(Applause)

07:57:56.068 --> 07:57:58.068
. 

07:58:00.095 --> 07:58:02.095
(Session concluded)

