WEBVTT
Kind: captions
Language: en

00:00:03.080 --> 00:00:04.910
RAPH LEVIEN: I'm
Raph Levien, and I'm

00:00:04.910 --> 00:00:06.292
on the Android UI Toolkit team.

00:00:06.292 --> 00:00:07.750
And, I'm going to
talk to you today

00:00:07.750 --> 00:00:09.870
about Android textual layout.

00:00:09.870 --> 00:00:12.760
And I hope you'll find
this an interesting talk,

00:00:12.760 --> 00:00:15.330
and I hope you brought
lots of questions as well.

00:00:15.330 --> 00:00:18.560
And I'm happy to try to address
those after the session,

00:00:18.560 --> 00:00:21.222
and also at office
hours this afternoon.

00:00:23.930 --> 00:00:26.140
So I'm going to talk
about-- it's kind

00:00:26.140 --> 00:00:29.150
a grab bag of a bunch of
different topics around text

00:00:29.150 --> 00:00:31.304
and typography on Android.

00:00:31.304 --> 00:00:33.220
I'm going to talk about
some of the challenges

00:00:33.220 --> 00:00:34.960
and opportunities.

00:00:34.960 --> 00:00:37.880
Just a little bit of an
introduction to material

00:00:37.880 --> 00:00:41.380
design, which I'm sure everybody
here is quite familiar with.

00:00:41.380 --> 00:00:45.275
Then I'm going to go into some
of the details about the Roboto

00:00:45.275 --> 00:00:47.620
2.0 and Noto fonts,
and especially

00:00:47.620 --> 00:00:50.340
the kind of more recent
changes around these

00:00:50.340 --> 00:00:52.520
to better support
international typography.

00:00:52.520 --> 00:00:56.160
A huge amount of the work that
we do on the Android UI Toolkit

00:00:56.160 --> 00:00:59.260
team is supporting all of
the languages of the world,

00:00:59.260 --> 00:01:01.270
or most of them.

00:01:01.270 --> 00:01:03.520
Then I'm going to go into
some of the really, I think,

00:01:03.520 --> 00:01:09.500
exciting newer features around
open type typography control,

00:01:09.500 --> 00:01:11.560
and high-quality
paragraph layout,

00:01:11.560 --> 00:01:15.490
which rolled out in
Lollipop and Marshmallow .

00:01:15.490 --> 00:01:18.150
So what are some of the
challenges and opportunities?

00:01:18.150 --> 00:01:21.310
I mean, I come from
a print background.

00:01:21.310 --> 00:01:25.120
And doing typography
on mobile is

00:01:25.120 --> 00:01:28.134
extremely different than
doing typography in print.

00:01:28.134 --> 00:01:30.550
There are some things in common,
but there are some things

00:01:30.550 --> 00:01:32.420
that are really different.

00:01:32.420 --> 00:01:39.230
You have to be very focused
on the performance of the text

00:01:39.230 --> 00:01:41.840
stack, because you've got
only so much battery and only

00:01:41.840 --> 00:01:42.860
so much RAM.

00:01:42.860 --> 00:01:45.460
But you really do have very
powerful compute resources.

00:01:45.460 --> 00:01:48.270
You've got multi-core,
multi-gigahertz processes

00:01:48.270 --> 00:01:49.100
in there.

00:01:49.100 --> 00:01:51.390
So if you want to do
sophisticated, advanced

00:01:51.390 --> 00:01:55.260
typography, you do have the
compute power to do that.

00:01:55.260 --> 00:01:58.770
60 frames a second is
absolutely a requirement.

00:01:58.770 --> 00:02:01.810
And this is, again, both a
challenge and an opportunity.

00:02:01.810 --> 00:02:04.540
That you can do these
really rich animations,

00:02:04.540 --> 00:02:07.780
and transitions and do this
kind of interactive motion

00:02:07.780 --> 00:02:10.639
typography that
really is completely

00:02:10.639 --> 00:02:12.560
impossible in a
print background.

00:02:12.560 --> 00:02:14.330
But you have to
make everything fit

00:02:14.330 --> 00:02:17.410
in that 16-millisecond budget.

00:02:17.410 --> 00:02:19.040
You've got a very small screen.

00:02:19.040 --> 00:02:21.380
And this has some
interesting challenges

00:02:21.380 --> 00:02:23.000
in how you create
your layouts, how

00:02:23.000 --> 00:02:26.340
you do the paragraph layout.

00:02:26.340 --> 00:02:29.100
But a flip side, again,
is that on modern devices

00:02:29.100 --> 00:02:31.710
you have this very
high resolution.

00:02:31.710 --> 00:02:34.210
Then, as I mentioned,
we have this requirement

00:02:34.210 --> 00:02:37.344
to support all of the
languages of the world, all

00:02:37.344 --> 00:02:38.510
of the scripts of the world.

00:02:38.510 --> 00:02:40.920
But we have a lot of
really good resources

00:02:40.920 --> 00:02:45.190
both in fonts and typography
control of how you do that.

00:02:45.190 --> 00:02:47.386
And then I'm going
to talk about some

00:02:47.386 --> 00:02:49.010
of the line-breaking
improvements, some

00:02:49.010 --> 00:02:50.960
of the paragraph-improvements
in Marshmallow.

00:02:50.960 --> 00:02:53.370
And those were really
motivated by a need

00:02:53.370 --> 00:02:58.240
to get this working in very
small screens like watch faces.

00:02:58.240 --> 00:03:00.560
So I'm going to just
kind of introduce

00:03:00.560 --> 00:03:03.410
this concept of the advance
of display technology.

00:03:03.410 --> 00:03:05.120
This was the first
mobile device I ever

00:03:05.120 --> 00:03:07.100
had when I was 12 years old.

00:03:07.100 --> 00:03:09.420
And I mean, as you
can see, it's got

00:03:09.420 --> 00:03:13.632
a lot of the elements of
a modern mobile device.

00:03:13.632 --> 00:03:17.770
It even has a really
nice big keyboard.

00:03:17.770 --> 00:03:22.230
But the display technology in
this generation of technology

00:03:22.230 --> 00:03:24.230
is kind of the bare
minimum that you need

00:03:24.230 --> 00:03:26.120
to get text displayed at all.

00:03:26.120 --> 00:03:29.720
And I think that that
evolution kind of carried

00:03:29.720 --> 00:03:31.710
that there was a very
primitive approach

00:03:31.710 --> 00:03:35.490
to just get that the
letters drawn on the screen,

00:03:35.490 --> 00:03:37.980
and not really think
about typography.

00:03:37.980 --> 00:03:39.670
Another good thing
about this screenshot

00:03:39.670 --> 00:03:42.470
is you get some sense of the
difference in computing power

00:03:42.470 --> 00:03:46.510
available today as back then.

00:03:46.510 --> 00:03:50.060
So you know before
I worked on Android,

00:03:50.060 --> 00:03:53.990
I was working on Google
web fonts, Google Fonts.

00:03:53.990 --> 00:03:58.020
And the upper left corner is
kind of your classic laptop

00:03:58.020 --> 00:03:58.880
or desktop screen.

00:03:58.880 --> 00:04:00.960
And this really
ruled what we did.

00:04:00.960 --> 00:04:03.590
That you have a very
small number of pixels

00:04:03.590 --> 00:04:05.550
to represent the text.

00:04:05.550 --> 00:04:07.190
And you have a
lot of constraints

00:04:07.190 --> 00:04:10.900
in how the letter-forms
map into those pixels.

00:04:10.900 --> 00:04:13.020
And that also
includes the spacing.

00:04:13.020 --> 00:04:16.662
You see very poor-- the A and
P are crunched up together,

00:04:16.662 --> 00:04:18.620
and the P and O are
separated, because you only

00:04:18.620 --> 00:04:21.360
have so many pixels
and so much precision.

00:04:21.360 --> 00:04:25.190
But as you go into more
modern display technology,

00:04:25.190 --> 00:04:27.540
you have so many more pixels.

00:04:27.540 --> 00:04:30.660
And so on the upper right,
you have a 4K monitor, which

00:04:30.660 --> 00:04:33.840
is starting to replace laptops.

00:04:33.840 --> 00:04:35.680
And on the lower
left, this isn't even

00:04:35.680 --> 00:04:37.000
the most recent device.

00:04:37.000 --> 00:04:41.120
This is a two-year-old
device and it has 468 ppi.

00:04:41.120 --> 00:04:44.140
And you probably can't
even see the pixels here.

00:04:44.140 --> 00:04:47.580
And then comparing that to,
for example, an inkjet printer,

00:04:47.580 --> 00:04:49.800
you actually have-- on
these mobile devices,

00:04:49.800 --> 00:04:53.410
you have a much higher
precision, higher quality

00:04:53.410 --> 00:04:56.950
representation of the
shapes of the letter forms

00:04:56.950 --> 00:04:58.210
and the spaces between them.

00:04:58.210 --> 00:05:00.480
So it really enables typography.

00:05:00.480 --> 00:05:05.220
And all four of these
screen shots or captures

00:05:05.220 --> 00:05:09.220
are of the same
12-point Times Roman.

00:05:09.220 --> 00:05:11.260
And so this is what we
have to work with today.

00:05:11.260 --> 00:05:12.440
This is our lead device.

00:05:12.440 --> 00:05:13.620
The Nexus 6P.

00:05:13.620 --> 00:05:17.190
It's an Amazing device, and
it has an amazing screen

00:05:17.190 --> 00:05:19.680
to match the overall device.

00:05:19.680 --> 00:05:21.950
It's 515 ppi.

00:05:21.950 --> 00:05:25.060
One of the ways I think
about screen resolution

00:05:25.060 --> 00:05:29.390
is when "Star Trek"-- when they
were doing the "Star Trek" TV

00:05:29.390 --> 00:05:32.360
show, they had a book that
had all of the specifications

00:05:32.360 --> 00:05:34.510
for all the technology,
like how many terajoules

00:05:34.510 --> 00:05:36.050
were in a phaser pulse.

00:05:36.050 --> 00:05:38.710
And one of the
specifications is,

00:05:38.710 --> 00:05:41.400
what is the resolution
of these little devices

00:05:41.400 --> 00:05:42.900
that people are carrying around?

00:05:42.900 --> 00:05:45.215
And the answer is 400 dpi.

00:05:45.215 --> 00:05:47.640
So we've blown way
past "Star Trek".

00:05:50.550 --> 00:05:53.000
So I mean, as I
say, everybody here

00:05:53.000 --> 00:05:54.250
knows about material design.

00:05:54.250 --> 00:05:55.650
This'll just touch on it.

00:05:55.650 --> 00:05:58.900
That the UX Team-- it started
really about two years ago

00:05:58.900 --> 00:06:02.250
that they were looking at these
kind of more powerful devices,

00:06:02.250 --> 00:06:03.760
higher-quality
display technologies.

00:06:03.760 --> 00:06:07.650
And they were really thinking,
if we were redesigning this

00:06:07.650 --> 00:06:10.420
from scratch-- if we
really could do anything,

00:06:10.420 --> 00:06:12.230
what would we do?

00:06:12.230 --> 00:06:15.270
And the result of
that exploration

00:06:15.270 --> 00:06:18.670
really synthesized into
a set of guidelines,

00:06:18.670 --> 00:06:22.500
into a coherent design
language that incorporates

00:06:22.500 --> 00:06:23.860
many different elements.

00:06:23.860 --> 00:06:26.770
It incorporates colors.

00:06:26.770 --> 00:06:29.850
It incorporates the
material metaphors

00:06:29.850 --> 00:06:34.060
with paper and kind of a
three-dimensional effect.

00:06:34.060 --> 00:06:37.180
And it also
incorporates typography.

00:06:37.180 --> 00:06:41.990
And so one of the sections
in the material design

00:06:41.990 --> 00:06:43.410
spec I really recommend.

00:06:43.410 --> 00:06:48.780
It's very-- it has a
lot of good information

00:06:48.780 --> 00:06:51.760
and a lot of good guidance
about how to do to typography

00:06:51.760 --> 00:06:53.430
within material design.

00:06:53.430 --> 00:06:55.390
And of course,
another part of that

00:06:55.390 --> 00:07:00.430
is a much greater, expanded
palette of different weights

00:07:00.430 --> 00:07:03.870
and of different sizes,
and how you kind of use

00:07:03.870 --> 00:07:04.850
the weight and size.

00:07:04.850 --> 00:07:07.670
Instead of having just one
size of text, one weight,

00:07:07.670 --> 00:07:09.980
use this to indicate
the structure

00:07:09.980 --> 00:07:14.070
of your app, the structure of
the information in your app.

00:07:14.070 --> 00:07:18.730
So the cornerstone of
typography in material design

00:07:18.730 --> 00:07:20.530
is the Roboto 2.0 typeface.

00:07:20.530 --> 00:07:23.650
And so this was an update
that happened in Lollipop.

00:07:23.650 --> 00:07:25.790
And you know, it
was pretty subtle.

00:07:25.790 --> 00:07:28.370
A lot of people probably
didn't even notice it,

00:07:28.370 --> 00:07:31.520
but there was actually a
lot going on in this update.

00:07:31.520 --> 00:07:34.350
So one of the things is the
expanded Unicode coverage.

00:07:34.350 --> 00:07:37.470
It actually increased
by a factor of three.

00:07:37.470 --> 00:07:40.730
And we have full
support for Unicode 8.0

00:07:40.730 --> 00:07:44.010
for Latin, Greek,
and Cyrillic scripts.

00:07:44.010 --> 00:07:49.090
And that covers a lot of the
languages in the world that

00:07:49.090 --> 00:07:52.380
are maybe less familiar to us--
like the African languages use

00:07:52.380 --> 00:07:55.940
a lot of unusual
Latin characters.

00:07:55.940 --> 00:07:58.030
We also expanded the
weights and styles

00:07:58.030 --> 00:07:59.220
that we ship on the device.

00:07:59.220 --> 00:08:02.140
So we're doing thin, light,
regular, medium, bold,

00:08:02.140 --> 00:08:02.740
and black.

00:08:02.740 --> 00:08:06.562
So there's a tremendous
palette of the visual effects

00:08:06.562 --> 00:08:07.270
that you can get.

00:08:07.270 --> 00:08:09.590
And all of those
include true italics.

00:08:09.590 --> 00:08:11.590
And we also have a
family of condensed,

00:08:11.590 --> 00:08:15.020
which is better for better
information density,

00:08:15.020 --> 00:08:17.300
and also can give
you some contrast--

00:08:17.300 --> 00:08:23.060
two different styles that you
can work with in your app.

00:08:23.060 --> 00:08:27.030
In addition, the Roboto 2.0
font is completely open source.

00:08:27.030 --> 00:08:30.960
And that includes not just
the final TrueType font files,

00:08:30.960 --> 00:08:32.179
but the entire bill chain.

00:08:32.179 --> 00:08:35.860
So you can go in there and
customize it, and play with it,

00:08:35.860 --> 00:08:37.049
and send us pull requests.

00:08:37.049 --> 00:08:40.120
And we really treat
almost everything

00:08:40.120 --> 00:08:46.080
we do in a very
open source manner.

00:08:46.080 --> 00:08:48.600
So the design updated as well.

00:08:48.600 --> 00:08:51.230
And this is just a little
bit of a before and after.

00:08:51.230 --> 00:08:53.480
And you can see it's
a little subtle,

00:08:53.480 --> 00:08:56.450
but there's kind
of a stiff sides

00:08:56.450 --> 00:08:59.330
to some of the characters,
like a capital O.

00:08:59.330 --> 00:09:02.590
that has become a more
refined, gentle curve.

00:09:02.590 --> 00:09:05.010
Some of the shapes were
maybe a little bit unusual,

00:09:05.010 --> 00:09:07.760
like the Ks and the
capital R. And those

00:09:07.760 --> 00:09:09.790
have become kind of
more simplified and more

00:09:09.790 --> 00:09:10.860
streamlined.

00:09:10.860 --> 00:09:14.090
And we also went from
a square dot on the I's

00:09:14.090 --> 00:09:16.050
and J's to a round dot.

00:09:16.050 --> 00:09:17.540
So it's just--
it's an evolution.

00:09:17.540 --> 00:09:24.020
It's a more refined form of
the original kind of design.

00:09:24.020 --> 00:09:28.390
It's very central to Android
and very central, of course,

00:09:28.390 --> 00:09:30.830
to material design.

00:09:30.830 --> 00:09:33.470
So I talked about the
global reach of Android.

00:09:33.470 --> 00:09:36.610
We talk a lot about
the next billion users.

00:09:36.610 --> 00:09:42.880
And there are-- like we
heard in the previous talk

00:09:42.880 --> 00:09:46.480
about how do you reach them
through the Play Store console,

00:09:46.480 --> 00:09:48.250
but there's also a
lot that you have

00:09:48.250 --> 00:09:51.270
to do with a presentation
of text and language

00:09:51.270 --> 00:09:52.700
in these devices.

00:09:52.700 --> 00:09:54.790
So again, Roboto
2.0 dramatically

00:09:54.790 --> 00:09:56.990
increases the Unicode coverage.

00:09:56.990 --> 00:09:58.750
And you can see this
is just a sample.

00:09:58.750 --> 00:10:03.140
This is just one of the pages
of kind of additional extended

00:10:03.140 --> 00:10:04.430
Latin characters.

00:10:04.430 --> 00:10:05.850
And another thing
I'll point out,

00:10:05.850 --> 00:10:08.320
just for this
slide, some-- if you

00:10:08.320 --> 00:10:12.480
look kind of near the middle,
towards the left-hand side,

00:10:12.480 --> 00:10:17.700
you see some Os with some
doubly-stacked accents.

00:10:17.700 --> 00:10:21.000
And that's a very common
pattern in a lot of languages,

00:10:21.000 --> 00:10:23.560
but not European languages
that we're used to.

00:10:23.560 --> 00:10:26.600
So you see it in Vietnamese and
some of these other languages.

00:10:26.600 --> 00:10:29.530
So you really-- when
you're designing your apps,

00:10:29.530 --> 00:10:31.320
when you're testing
your apps, you really

00:10:31.320 --> 00:10:34.020
need to be careful
to test them in some

00:10:34.020 --> 00:10:36.190
of these other languages
to make sure that you've

00:10:36.190 --> 00:10:37.770
got enough vertical space.

00:10:37.770 --> 00:10:42.100
This is kind of one
the real key takeaways.

00:10:42.100 --> 00:10:43.850
That if you just
design in English,

00:10:43.850 --> 00:10:44.892
you've got these letters.

00:10:44.892 --> 00:10:46.558
They don't have
anything going on above,

00:10:46.558 --> 00:10:48.230
they don't have
anything going on below.

00:10:48.230 --> 00:10:53.640
But that is not the experience
of millions-- hundreds

00:10:53.640 --> 00:10:56.690
of millions of people
around the world.

00:10:56.690 --> 00:10:59.250
So in addition to Latin,
Greek, and Cyrillic,

00:10:59.250 --> 00:11:01.790
there's this huge diversity
of other languages.

00:11:01.790 --> 00:11:04.660
And in fact, this is the list
of scripts, not even languages.

00:11:04.660 --> 00:11:07.960
There's many scripts that
support multiple languages.

00:11:07.960 --> 00:11:10.510
These are the Noto
scripts that we're

00:11:10.510 --> 00:11:11.880
supporting in Marshmallow.

00:11:11.880 --> 00:11:16.690
So it really is a huge expansion
compared with previous versions

00:11:16.690 --> 00:11:17.690
of Android.

00:11:17.690 --> 00:11:21.820
And it really covers a very
large fraction of the languages

00:11:21.820 --> 00:11:23.750
that are spoken in the world.

00:11:23.750 --> 00:11:26.550
And so here are three scripts
that I just kind of picked out

00:11:26.550 --> 00:11:28.880
as representative.

00:11:28.880 --> 00:11:31.400
I find these just
really beautiful.

00:11:31.400 --> 00:11:35.540
And you can see a tension
between classical forms,

00:11:35.540 --> 00:11:38.870
but also trying to make them
consistent with the kind

00:11:38.870 --> 00:11:43.180
of clean Roboto design.

00:11:43.180 --> 00:11:45.640
And so I think these
three are either

00:11:45.640 --> 00:11:48.690
new in either
Marshmallow or Lollipop.

00:11:51.330 --> 00:11:56.410
So then, in addition to this
kind of large set of scripts,

00:11:56.410 --> 00:11:58.940
CJK-- Chinese,
Japanese, and Korean--

00:11:58.940 --> 00:12:03.980
represent a very large
fraction of the users

00:12:03.980 --> 00:12:07.140
of Android, a lot of
the users in the world.

00:12:07.140 --> 00:12:11.530
And so in Lollipop, we
launched Noto CJK, which

00:12:11.530 --> 00:12:13.940
is a joint project with Adobe.

00:12:13.940 --> 00:12:15.760
So it's also out there.

00:12:15.760 --> 00:12:18.246
They released it
as Source Han Sans.

00:12:18.246 --> 00:12:19.870
And that's also an
open source project.

00:12:19.870 --> 00:12:20.660
And it has a tracker.

00:12:20.660 --> 00:12:21.430
It's very active.

00:12:21.430 --> 00:12:27.880
People find issues and
it's being revised.

00:12:27.880 --> 00:12:32.710
And in addition to just the
fonts, that project also

00:12:32.710 --> 00:12:36.140
kind of brought with it
a higher-quality render

00:12:36.140 --> 00:12:39.250
for something called
CFF-- Compact Font Format.

00:12:39.250 --> 00:12:42.110
And this is based
on the Adobe code,

00:12:42.110 --> 00:12:44.830
but it's now been open sourced,
so it's part of FreeType.

00:12:44.830 --> 00:12:49.460
So you can go look at the code,
use that in your own projects

00:12:49.460 --> 00:12:50.710
as well.

00:12:50.710 --> 00:12:53.880
So Noto CJK is a very
ambitious project

00:12:53.880 --> 00:12:57.580
that really is designed to
be a comprehensive support

00:12:57.580 --> 00:13:01.100
font to support all of CJK.

00:13:01.100 --> 00:13:07.140
And that includes the
different local forms.

00:13:07.140 --> 00:13:10.010
So there's a difference between
simplified and traditional

00:13:10.010 --> 00:13:10.900
Chinese.

00:13:10.900 --> 00:13:12.560
Those are different
from Japanese,

00:13:12.560 --> 00:13:14.320
and then there are
some glyphs that

00:13:14.320 --> 00:13:15.510
appear different in Korean.

00:13:15.510 --> 00:13:17.720
And it's very important
to these users

00:13:17.720 --> 00:13:20.100
to see the correct
form in their language.

00:13:20.100 --> 00:13:25.000
If you see it wrong, it's just--
it really is a polish problem.

00:13:25.000 --> 00:13:27.460
So notice CJK has
a unified design.

00:13:27.460 --> 00:13:30.050
There's like a consistent--
there are some releases

00:13:30.050 --> 00:13:32.620
that we've done where the
Chinese and Japanese really

00:13:32.620 --> 00:13:36.100
don't look like they're part
of the same family of fonts.

00:13:36.100 --> 00:13:39.610
And in Noto CJK, we really
have a unified design,

00:13:39.610 --> 00:13:41.580
but we have the
different variants

00:13:41.580 --> 00:13:44.770
in the different regions.

00:13:44.770 --> 00:13:47.850
So no discussion of
text is complete today

00:13:47.850 --> 00:13:50.350
without talking about a Emoji.

00:13:50.350 --> 00:13:54.680
And we really treat
Emoji as a type of text.

00:13:54.680 --> 00:13:57.400
So an app doesn't have
to do anything special.

00:13:57.400 --> 00:14:02.070
An app doesn't have to say, oh
show me some color images here,

00:14:02.070 --> 00:14:03.230
or something like that.

00:14:03.230 --> 00:14:06.430
You just represent text and you
ask for the text to be drawn

00:14:06.430 --> 00:14:08.570
or in a text view or edited.

00:14:08.570 --> 00:14:12.340
And it just automatically
shows up using this color font

00:14:12.340 --> 00:14:16.740
technology, which is now
standardized in OpenType 1.7.

00:14:16.740 --> 00:14:18.370
And there are
actually many tools--

00:14:18.370 --> 00:14:22.890
many font editors,
actually, will create fonts

00:14:22.890 --> 00:14:24.470
in this Emoji form.

00:14:24.470 --> 00:14:29.370
So if you want to-- or I should
say in a color-font form,

00:14:29.370 --> 00:14:34.250
whether it's used for Emoji
or not is really up to you.

00:14:34.250 --> 00:14:38.320
And you can incorporate these
custom fonts in your app

00:14:38.320 --> 00:14:42.990
and get color representation
of either Emoji or text,

00:14:42.990 --> 00:14:45.560
just by dropping in the font.

00:14:45.560 --> 00:14:48.380
This also supports
flags and keycaps.

00:14:48.380 --> 00:14:52.450
It's a more expanded
set of Emoji.

00:14:52.450 --> 00:14:54.950
And one of the new
APIs-- I should say this

00:14:54.950 --> 00:14:58.180
is a Marshmallow API--
in a lot of apps,

00:14:58.180 --> 00:15:01.540
you want to know what Emoji
are present, because you

00:15:01.540 --> 00:15:02.540
want to make a decision.

00:15:02.540 --> 00:15:06.890
Do you present this as a
palette for users to choose?

00:15:06.890 --> 00:15:08.630
And this has always
been a problem,

00:15:08.630 --> 00:15:11.530
because different phones will
have different Emoji sets.

00:15:11.530 --> 00:15:14.872
And as we're upgrading,
it's hard to know,

00:15:14.872 --> 00:15:16.080
is this Emoji present or not?

00:15:16.080 --> 00:15:20.000
Or does this flag exist, in
the case of the flag Emoji?

00:15:20.000 --> 00:15:22.320
And so we've got this new
API that will tell you.

00:15:22.320 --> 00:15:23.100
It's very fast.

00:15:23.100 --> 00:15:25.360
And we really
recommend-- we really

00:15:25.360 --> 00:15:27.260
want you to be using
has glyphs so you

00:15:27.260 --> 00:15:33.130
know what Emoji are on your
device, what you can use.

00:15:33.130 --> 00:15:34.920
So then I want to
talk about some

00:15:34.920 --> 00:15:36.590
of the typography features.

00:15:36.590 --> 00:15:38.080
We've really been
expanding this.

00:15:38.080 --> 00:15:40.850
The goal-- my goal,
certainly-- is

00:15:40.850 --> 00:15:45.680
to make Android typography match
what you can do on the web.

00:15:45.680 --> 00:15:48.420
And match what you can do,
not just in print, but really

00:15:48.420 --> 00:15:49.270
high-quality print.

00:15:49.270 --> 00:15:51.228
And so I'll walk you
through some of the things

00:15:51.228 --> 00:15:53.586
that we do here.

00:15:53.586 --> 00:15:55.210
I'll just go through
this list and then

00:15:55.210 --> 00:15:56.800
I'll show some examples.

00:15:56.800 --> 00:15:58.480
We have kerning and ligatures.

00:15:58.480 --> 00:16:03.110
We've actually had those
since, I think, JellyBean-MR2.

00:16:03.110 --> 00:16:04.414
But now, there's more control.

00:16:04.414 --> 00:16:06.080
So if you want to
turn those on and off,

00:16:06.080 --> 00:16:08.300
there's fine-grained
control to do that.

00:16:08.300 --> 00:16:14.160
We have this font feature
settings attribute

00:16:14.160 --> 00:16:17.960
where you really can go in and
control the OpenType features.

00:16:17.960 --> 00:16:20.370
I'll give you several
examples of that.

00:16:20.370 --> 00:16:22.440
And that's using a
CSS-compatible syntax.

00:16:22.440 --> 00:16:26.490
So we want to make this stuff
so if your designers are used

00:16:26.490 --> 00:16:29.390
to controlling
typography on the web,

00:16:29.390 --> 00:16:31.680
we want to make kind
of impedance mismatch

00:16:31.680 --> 00:16:33.410
as smooth as possible.

00:16:33.410 --> 00:16:36.950
So you can just
take that knowledge

00:16:36.950 --> 00:16:38.195
and apply it to Android apps.

00:16:38.195 --> 00:16:40.320
And then this is a little
bit more technical thing,

00:16:40.320 --> 00:16:44.660
but we use OpenType integrally
to give you these localized

00:16:44.660 --> 00:16:47.610
forms that there are many
languages certainly not

00:16:47.610 --> 00:16:49.760
just the Chinese,
Japanese and Korean,

00:16:49.760 --> 00:16:52.570
where there's going to be
some subtle differences.

00:16:52.570 --> 00:16:54.860
The same basic script,
but differences in the way

00:16:54.860 --> 00:16:55.870
it's presented.

00:16:55.870 --> 00:16:58.000
And we use OpenType
to control that.

00:16:58.000 --> 00:17:01.480
And I'll talk a little
bit also about what

00:17:01.480 --> 00:17:05.069
you want to do in your app
to make that work perfectly.

00:17:05.069 --> 00:17:06.220
So kerning and ligature.

00:17:06.220 --> 00:17:10.280
So the fi ligature is a little
controversial in Roboto.

00:17:10.280 --> 00:17:12.250
Not everybody loves this.

00:17:12.250 --> 00:17:15.710
But it is definitely
a sign of kind

00:17:15.710 --> 00:17:19.520
of more sophisticated
typography that you don't just

00:17:19.520 --> 00:17:21.579
put the letters,
that in some cases

00:17:21.579 --> 00:17:23.400
you have these
combinations, and you

00:17:23.400 --> 00:17:25.690
have a specifically drawing
glyph that represents

00:17:25.690 --> 00:17:27.210
more than one letter.

00:17:27.210 --> 00:17:31.190
And this is certainly--
this exists in Roboto.

00:17:31.190 --> 00:17:35.420
And it's a very important
part, especially in Sara fonts.

00:17:35.420 --> 00:17:37.490
You really need those
ligatures for the font

00:17:37.490 --> 00:17:38.550
to display correctly.

00:17:38.550 --> 00:17:42.550
So if again, as you're using
custom fonts in your app,

00:17:42.550 --> 00:17:44.170
you want those ligatures.

00:17:44.170 --> 00:17:45.850
And the same is
true for kerning.

00:17:45.850 --> 00:17:47.600
You almost never want
to turn this off.

00:17:47.600 --> 00:17:49.391
The only time you might
want to turn it off

00:17:49.391 --> 00:17:51.560
is if you've got some kind
of technical alignment,

00:17:51.560 --> 00:17:54.800
where things need to have the
consistent width, no matter

00:17:54.800 --> 00:17:57.090
what the characters are.

00:17:57.090 --> 00:18:00.590
But in any case, as of
m, with the font feature

00:18:00.590 --> 00:18:04.060
setting attribute,
you can control these.

00:18:04.060 --> 00:18:06.450
These are actually implemented
as OpenType features.

00:18:06.450 --> 00:18:09.150
And as with any
OpenType feature,

00:18:09.150 --> 00:18:11.910
you can turn it on or off
with font feature settings.

00:18:11.910 --> 00:18:14.080
And that's actually
a Lollipop Plus API.

00:18:17.990 --> 00:18:20.190
Another kind of
great hidden feature

00:18:20.190 --> 00:18:23.290
is the use of proportional
in old-style numbers.

00:18:23.290 --> 00:18:26.570
And these are really
important for a more refined,

00:18:26.570 --> 00:18:28.570
sophisticated typography.

00:18:28.570 --> 00:18:31.120
That the default
numbers are basically

00:18:31.120 --> 00:18:34.380
the same size as capitals, And,
they're all the same width.

00:18:34.380 --> 00:18:36.850
And being the same width
is really important,

00:18:36.850 --> 00:18:39.560
if you've got some kind
of animated display.

00:18:39.560 --> 00:18:41.650
You don't want it to be
juddering back and forth,

00:18:41.650 --> 00:18:44.140
or if you've got kind of a
tabular presentation of numbers

00:18:44.140 --> 00:18:45.140
like a spreadsheet.

00:18:45.140 --> 00:18:47.570
But it's not always
the prettiest display.

00:18:47.570 --> 00:18:49.280
And if you're
doing running text,

00:18:49.280 --> 00:18:52.040
if you're doing
paragraphs of text,

00:18:52.040 --> 00:18:56.060
then proportional may be a more
subtle change, where you just

00:18:56.060 --> 00:18:58.800
give the one a
little bit narrower,

00:18:58.800 --> 00:19:00.804
so you don't have all
this space around it.

00:19:00.804 --> 00:19:03.470
And then if you're really trying
to do something that looks more

00:19:03.470 --> 00:19:05.860
like a book, something
that looks more

00:19:05.860 --> 00:19:07.980
like traditional
typography, then you've

00:19:07.980 --> 00:19:10.430
got these old-style figures.

00:19:10.430 --> 00:19:12.470
And those are in Roboto 2.0.

00:19:12.470 --> 00:19:14.050
Those are present
in the font and you

00:19:14.050 --> 00:19:15.960
use the Android font
feature settings

00:19:15.960 --> 00:19:18.900
to select P-Num,
proportional numbers,

00:19:18.900 --> 00:19:21.400
or O-Num, old-style figures.

00:19:21.400 --> 00:19:25.500
And again, highly recommended
if you're bringing custom fonts

00:19:25.500 --> 00:19:30.780
into your app that you have
the complete access to all

00:19:30.780 --> 00:19:34.750
of the OpenType
features in those fonts.

00:19:34.750 --> 00:19:38.240
And this is, again, an
[? L-Plus ?] feature.

00:19:38.240 --> 00:19:42.270
Another feature that
I think is really

00:19:42.270 --> 00:19:47.110
a powerful tool for bringing
more sophisticated design

00:19:47.110 --> 00:19:50.240
to apps is control
over letter spacing.

00:19:50.240 --> 00:19:51.860
So there's a default
letter spacing.

00:19:51.860 --> 00:19:56.200
It's really tuned
for legibility.

00:19:56.200 --> 00:19:58.960
People are getting
information on their phone.

00:19:58.960 --> 00:20:01.210
They need to be able
to read it quickly.

00:20:01.210 --> 00:20:04.324
And that's what the default
letter spacing is tuned for.

00:20:04.324 --> 00:20:05.740
But if you've got
something that's

00:20:05.740 --> 00:20:08.340
kind of larger,
more of a branding

00:20:08.340 --> 00:20:12.340
and less of a
functional element,

00:20:12.340 --> 00:20:17.120
then spacing it a little tighter
might kind of highlight that.

00:20:17.120 --> 00:20:19.730
And then you can
also use wide spacing

00:20:19.730 --> 00:20:23.550
as maybe a form of emphasis,
or just bringing a little bit

00:20:23.550 --> 00:20:25.950
more breath to your design.

00:20:25.950 --> 00:20:29.180
So you have-- you're
no longer stuck

00:20:29.180 --> 00:20:33.260
with just the default spacing
that's set in your font.

00:20:33.260 --> 00:20:36.600
And again that's an
[? L-Plus ?] feature.

00:20:36.600 --> 00:20:39.430
So in Marshmallow,
this is really

00:20:39.430 --> 00:20:42.600
one of the things I'm
most excited about.

00:20:42.600 --> 00:20:47.350
That we really stepped
up the paragraph layout.

00:20:47.350 --> 00:20:51.905
And the old algorithm kind
of used-- you fill up a line,

00:20:51.905 --> 00:20:53.530
and then when once
you get to the point

00:20:53.530 --> 00:20:56.500
where the line is full then
you just break at the word

00:20:56.500 --> 00:20:58.180
boundary, and you keep going.

00:20:58.180 --> 00:21:02.540
But in Marshmallow, we have this
high-quality paragraph layout

00:21:02.540 --> 00:21:03.620
mode.

00:21:03.620 --> 00:21:06.600
And it incorporates a couple
of different elements.

00:21:06.600 --> 00:21:09.650
It incorporates
automatic hyphenation.

00:21:09.650 --> 00:21:11.520
And it also incorporates
this concept

00:21:11.520 --> 00:21:13.120
of whole-paragraph optimization.

00:21:13.120 --> 00:21:17.820
So it kind of moves pieces
around to get a best score.

00:21:17.820 --> 00:21:21.820
To get-- there's kind of
a score that tells you

00:21:21.820 --> 00:21:23.295
what is the quality
of this layout.

00:21:23.295 --> 00:21:24.920
And it's really trying
to optimize that

00:21:24.920 --> 00:21:26.760
across the entire paragraph.

00:21:26.760 --> 00:21:28.670
Both of these
algorithms are based

00:21:28.670 --> 00:21:32.780
on Tech, which is a
print typography package.

00:21:32.780 --> 00:21:34.360
It has a very long history.

00:21:34.360 --> 00:21:41.590
And high-end, print-publishing
tools use this same approach.

00:21:41.590 --> 00:21:44.490
But the parameters, you know,
when do you use hyphens?

00:21:44.490 --> 00:21:45.990
Hyphens are a little bit weird.

00:21:45.990 --> 00:21:49.430
People are not used to seeing
them on a mobile device.

00:21:49.430 --> 00:21:52.810
There are some contexts where
they make a lot of sense,

00:21:52.810 --> 00:21:55.095
like if you're displaying
an e-book for example.

00:21:55.095 --> 00:21:56.470
And there are some
where maybe it

00:21:56.470 --> 00:21:59.260
makes a little less sense
like UI strings or maybe chat

00:21:59.260 --> 00:21:59.760
messages.

00:21:59.760 --> 00:22:02.300
People are not used to
seeing hyphens there.

00:22:02.300 --> 00:22:04.120
So we tuned the parameters.

00:22:04.120 --> 00:22:06.630
It's heuristics.

00:22:06.630 --> 00:22:13.680
And we kind of chose these
so that-- a couple of things

00:22:13.680 --> 00:22:14.800
that people are noticing.

00:22:14.800 --> 00:22:18.260
That if you hyphenate, and
you break a partial word

00:22:18.260 --> 00:22:22.290
onto the last line,
that is really weird.

00:22:22.290 --> 00:22:25.670
That's something that people
have a negative reaction to.

00:22:25.670 --> 00:22:29.410
So there's a parameter in
the tuning that kind of

00:22:29.410 --> 00:22:31.260
doesn't do that very often.

00:22:31.260 --> 00:22:33.900
But on the other hand,
one of the reasons

00:22:33.900 --> 00:22:35.547
why you want to do
this hyphenation

00:22:35.547 --> 00:22:37.630
and want to do this
high-quality paragraph layout,

00:22:37.630 --> 00:22:40.330
is you want better
information density.

00:22:40.330 --> 00:22:42.130
This is especially
important when

00:22:42.130 --> 00:22:43.890
you have very narrow
settings, like--

00:22:43.890 --> 00:22:47.470
and especially true on very
small screens like watch faces.

00:22:47.470 --> 00:22:51.090
That if you break a word,
and you leave a huge amount

00:22:51.090 --> 00:22:53.450
of empty space, that's waste.

00:22:53.450 --> 00:22:56.110
That's an opportunity that
you could have used that space

00:22:56.110 --> 00:22:57.890
to present information.

00:22:57.890 --> 00:23:02.650
So we really look at this
question of would hyphenation

00:23:02.650 --> 00:23:08.260
bring you end lines down to n
-1 by doing the hyphenation?

00:23:08.260 --> 00:23:10.940
And in that case, we say yes.

00:23:10.940 --> 00:23:11.900
You do want that.

00:23:11.900 --> 00:23:13.780
You don't want to
waste that space.

00:23:13.780 --> 00:23:16.010
You want more
information density

00:23:16.010 --> 00:23:17.840
and that increases
the chance that you'll

00:23:17.840 --> 00:23:19.440
get a hyphen on there.

00:23:19.440 --> 00:23:23.620
So this is kind of
a different tuning

00:23:23.620 --> 00:23:25.170
than you would
expect for something

00:23:25.170 --> 00:23:28.080
like print typography, which is
where there's kind of the most

00:23:28.080 --> 00:23:31.930
tradition of doing hyphenation.

00:23:31.930 --> 00:23:35.980
So one of the other things we
looked at is this question,

00:23:35.980 --> 00:23:39.590
do we want to have an opt-in,
where your apps says, yes.

00:23:39.590 --> 00:23:41.270
I want high-quality mode.

00:23:41.270 --> 00:23:44.290
But maybe it's
considered expensive.

00:23:44.290 --> 00:23:48.730
It's too slow to run, or we
don't want to always have it.

00:23:48.730 --> 00:23:51.424
But we tried turning it on
across the entire system

00:23:51.424 --> 00:23:53.340
as a default. And we
really liked what we saw.

00:23:53.340 --> 00:23:56.930
I mean, you want a
higher-quality presentation

00:23:56.930 --> 00:23:59.120
of paragraphs.

00:23:59.120 --> 00:24:02.020
Of course, if it is
not right for your app,

00:24:02.020 --> 00:24:06.839
then please turn it off or
control the tuning parameters.

00:24:06.839 --> 00:24:09.130
But we also had to do a lot
of work on the performance.

00:24:09.130 --> 00:24:12.080
So it's doing a lot more work.

00:24:12.080 --> 00:24:13.930
There's a lot more
sophistication

00:24:13.930 --> 00:24:15.710
that's going on in there.

00:24:15.710 --> 00:24:19.670
But overall, the amount of time
that it spends drawing text

00:24:19.670 --> 00:24:20.980
is about the same as Lollipop.

00:24:20.980 --> 00:24:23.190
There's some use
cases that are faster.

00:24:23.190 --> 00:24:26.460
There's some where it's-- where
maybe some of the benchmarks

00:24:26.460 --> 00:24:28.010
where we've gone backwards.

00:24:28.010 --> 00:24:33.590
But we've really tried to make
that usable for everybody.

00:24:33.590 --> 00:24:36.600
And so here's a kind
of a demo of the kind

00:24:36.600 --> 00:24:39.350
of profound difference that
you can see, that you really

00:24:39.350 --> 00:24:44.380
see on the left-hand side, which
is the Pre-M paragraph layout.

00:24:44.380 --> 00:24:47.610
And you can still get to this
by setting break strategy equals

00:24:47.610 --> 00:24:50.050
simple in your XML.

00:24:50.050 --> 00:24:54.485
But you see these huge gaps
where the word conversation,

00:24:54.485 --> 00:24:55.110
it doesn't fit.

00:24:55.110 --> 00:24:57.600
So OK, it just goes
to the next line.

00:24:57.600 --> 00:25:00.580
And with the
high-quality layout,

00:25:00.580 --> 00:25:02.410
it says, OK we can
hyphenate that.

00:25:02.410 --> 00:25:04.160
And we can actually
get this block of text

00:25:04.160 --> 00:25:06.652
that's very clean.

00:25:09.760 --> 00:25:11.890
It really looks much
more like a book

00:25:11.890 --> 00:25:15.492
and less like kind of
computer text display.

00:25:15.492 --> 00:25:16.950
And on the right-hand
side, you can

00:25:16.950 --> 00:25:19.620
see it's actually pretty
eager to use hyphens.

00:25:19.620 --> 00:25:20.930
And that's a control.

00:25:20.930 --> 00:25:25.640
There's a default, which
is a little less eager.

00:25:25.640 --> 00:25:29.520
It uses hyphens when they really
improve the density, when you

00:25:29.520 --> 00:25:31.920
really improve those huge gaps.

00:25:31.920 --> 00:25:35.520
And then there's this setting
of full hyphenation frequency

00:25:35.520 --> 00:25:38.120
equals full, which is really
appropriate if you are

00:25:38.120 --> 00:25:39.560
displaying paragraphs of text.

00:25:39.560 --> 00:25:41.700
If you've got an app
like an e-book reader

00:25:41.700 --> 00:25:44.490
where you're really
displaying paragraphs,

00:25:44.490 --> 00:25:48.000
then we really recommend using
full instead of the default.

00:25:48.000 --> 00:25:50.280
And if you want to
turn hyphenation off,

00:25:50.280 --> 00:25:52.110
you can actually mix and match.

00:25:52.110 --> 00:25:54.490
You can have a
high-quality strategy,

00:25:54.490 --> 00:25:57.360
in terms of the optimization
of where the line breaks go,

00:25:57.360 --> 00:25:58.400
but just no hyphens.

00:25:58.400 --> 00:25:59.490
And that's another option.

00:26:02.270 --> 00:26:06.740
In the same kind of increase
control, enhanced control

00:26:06.740 --> 00:26:10.950
over line breaking,
we were looking

00:26:10.950 --> 00:26:14.020
at this particular problem--
a very common pattern

00:26:14.020 --> 00:26:15.610
for UI strings.

00:26:15.610 --> 00:26:17.850
You've got a string
that just doesn't quite

00:26:17.850 --> 00:26:21.470
fit into this space, into
the width of the set.

00:26:21.470 --> 00:26:24.750
And then you get this word,
you know UI strings are often

00:26:24.750 --> 00:26:25.250
very short.

00:26:25.250 --> 00:26:28.050
So this happens like quite a lot
where you just have one line,

00:26:28.050 --> 00:26:30.040
but you have like one
or maybe two words

00:26:30.040 --> 00:26:31.260
that go to the second line.

00:26:31.260 --> 00:26:32.530
And it just doesn't look nice.

00:26:32.530 --> 00:26:37.380
It's not a very pleasing visual
presentation of this text.

00:26:37.380 --> 00:26:41.100
So you can select break
strategy equals balanced.

00:26:41.100 --> 00:26:44.240
And that tries to line it
up so that all of the lines

00:26:44.240 --> 00:26:48.289
are the same-- are
roughly the same length.

00:26:48.289 --> 00:26:50.830
In a traditional paragraph, you
try and get all of the lines,

00:26:50.830 --> 00:26:52.850
except for the last,
the same length.

00:26:52.850 --> 00:26:55.350
But balance just really
just tweaks that one thing.

00:26:55.350 --> 00:26:57.500
And so it's just make
this whole thing line up.

00:26:57.500 --> 00:26:59.480
This is based--
again, for designers

00:26:59.480 --> 00:27:01.060
who are familiar
with web technology,

00:27:01.060 --> 00:27:04.750
this is based on Adobe's
proposal for text wrap balance.

00:27:04.750 --> 00:27:06.630
That hasn't become a standard.

00:27:06.630 --> 00:27:08.920
I don't think it's
widely shipping yet.

00:27:08.920 --> 00:27:13.240
But again, we're trying to
make the design of typography

00:27:13.240 --> 00:27:19.020
on Android similar to the design
of typography for the web.

00:27:19.020 --> 00:27:21.740
So I wanted to
also-- I mentioned,

00:27:21.740 --> 00:27:24.670
when I was talking about
the different languages

00:27:24.670 --> 00:27:29.260
and the kind of different things
that we do to change the way we

00:27:29.260 --> 00:27:32.720
present text, that
this is really

00:27:32.720 --> 00:27:34.980
one of the most important
things that apps can do

00:27:34.980 --> 00:27:39.640
is to get the locale of the
text that the app is displaying

00:27:39.640 --> 00:27:42.630
correct, because if
it's wrong, things

00:27:42.630 --> 00:27:45.450
will be-- you'll still
get the text displayed,

00:27:45.450 --> 00:27:46.930
but things will be degraded.

00:27:46.930 --> 00:27:48.490
They won't be as nice.

00:27:48.490 --> 00:27:53.430
They won't be as polished, as if
you set that locale correctly.

00:27:53.430 --> 00:27:55.270
So there's three
different ways that

00:27:55.270 --> 00:27:58.550
locale all flows into
text in Android--

00:27:58.550 --> 00:28:00.440
in Android framework text.

00:28:00.440 --> 00:28:04.140
There's the settings,
which are system-wide,

00:28:04.140 --> 00:28:06.930
which control a default locale.

00:28:06.930 --> 00:28:09.140
And of course, this
is their fault.

00:28:09.140 --> 00:28:11.430
This is what happens if
you don't do anything.

00:28:11.430 --> 00:28:14.830
And you hope it's right,
but unfortunately, there

00:28:14.830 --> 00:28:17.230
are a bunch of cases--
mostly when you

00:28:17.230 --> 00:28:19.160
have multilingual users.

00:28:19.160 --> 00:28:22.600
In America there aren't any,
but in the rest of the world,

00:28:22.600 --> 00:28:25.730
there's a lot of people that
speak more than one language.

00:28:25.730 --> 00:28:30.420
And so the language that
they're viewing the app in,

00:28:30.420 --> 00:28:32.390
the language that
they're interacting,

00:28:32.390 --> 00:28:36.760
that they're maybe looking
at user content might not be,

00:28:36.760 --> 00:28:39.750
might not match the
system setting app.

00:28:39.750 --> 00:28:43.440
So we have a set text
locale API, which

00:28:43.440 --> 00:28:45.530
you can use on a text view.

00:28:45.530 --> 00:28:47.710
And if you know, if
you have metadata,

00:28:47.710 --> 00:28:51.660
if your server knows the
language that that text is,

00:28:51.660 --> 00:28:55.340
then we strongly recommend that
you set text locale on the text

00:28:55.340 --> 00:28:58.850
queue that displays that text,
so that the locale is correctly

00:28:58.850 --> 00:28:59.910
identified.

00:28:59.910 --> 00:29:03.590
And then this may be a
little bit more specialized,

00:29:03.590 --> 00:29:05.330
for something like a
translate app, where

00:29:05.330 --> 00:29:07.020
you may have a
single string that

00:29:07.020 --> 00:29:08.500
contains multiple languages.

00:29:08.500 --> 00:29:10.820
It might say the
translation of this word

00:29:10.820 --> 00:29:13.470
into this other language
is some other word.

00:29:13.470 --> 00:29:17.150
And you might have a
language that's just a span.

00:29:17.150 --> 00:29:19.450
And for that, we have
got a locale span

00:29:19.450 --> 00:29:23.300
and you can set that on
just the text in your app

00:29:23.300 --> 00:29:25.779
that represents that span.

00:29:25.779 --> 00:29:26.820
So what does a locale do?

00:29:26.820 --> 00:29:28.820
I mean like I've said,
it's important to set it.

00:29:28.820 --> 00:29:29.760
But what happens?

00:29:29.760 --> 00:29:33.210
How does that actually control
the way text is displayed?

00:29:33.210 --> 00:29:36.650
And before JellyBean, there
was no difference at all.

00:29:36.650 --> 00:29:38.390
Text just displayed.

00:29:38.390 --> 00:29:40.950
But in Marshmallow,
there's four different ways

00:29:40.950 --> 00:29:43.650
that locale affects the
presentation of text.

00:29:43.650 --> 00:29:46.370
It changes the
font that's chosen.

00:29:46.370 --> 00:29:48.800
And that's especially
important for distinguishing

00:29:48.800 --> 00:29:52.240
between traditional
and simplified Chinese,

00:29:52.240 --> 00:29:54.760
as well as Japanese and Korean.

00:29:54.760 --> 00:29:57.440
Those are different
fonts that are unified.

00:29:57.440 --> 00:30:01.060
It affects this local
OpenType feature look up,

00:30:01.060 --> 00:30:04.300
so that there are differences
in Devanagari script

00:30:04.300 --> 00:30:07.150
between Hindi and Marathi.

00:30:07.150 --> 00:30:10.440
And it makes sure that
you get the correct forms

00:30:10.440 --> 00:30:13.630
of those letters, things
like Persian numerals

00:30:13.630 --> 00:30:17.990
and so on or not-- well, Persian
numerals are complicated,

00:30:17.990 --> 00:30:22.250
but the point is that if
you know the language,

00:30:22.250 --> 00:30:24.580
then setting it will
get the correct look

00:30:24.580 --> 00:30:27.560
ups to happen on the font.

00:30:27.560 --> 00:30:30.330
The locale also
affects line breaking.

00:30:30.330 --> 00:30:32.294
There are some
languages where deciding

00:30:32.294 --> 00:30:34.210
where the boundaries are
between words-- where

00:30:34.210 --> 00:30:35.710
you can break the
line-- is actually

00:30:35.710 --> 00:30:37.480
kind of a complex question.

00:30:37.480 --> 00:30:39.900
Thai is the most
common, certainly,

00:30:39.900 --> 00:30:42.230
that you'll see where
there's no spaces.

00:30:42.230 --> 00:30:45.090
And so you really, in the case
of Thai, you need a dictionary.

00:30:45.090 --> 00:30:47.360
You need to say,
this is the word,

00:30:47.360 --> 00:30:49.850
so that I know where the
boundaries of the words are.

00:30:49.850 --> 00:30:52.595
And that is completely
reliant on knowing

00:30:52.595 --> 00:30:53.470
what the language is.

00:30:53.470 --> 00:30:56.940
If you just put Thai text
through, but don't identify

00:30:56.940 --> 00:30:59.680
that the language is Thai,
then it gets confused

00:30:59.680 --> 00:31:03.460
and you get in line breaks in
potentially very bad places

00:31:03.460 --> 00:31:05.950
that don't line up
with words at all.

00:31:05.950 --> 00:31:08.530
And then of course,
lastly, now that we

00:31:08.530 --> 00:31:11.430
have automatic
hyphenation, that knowing

00:31:11.430 --> 00:31:17.500
which dictionary of patterns
to use depends on the language.

00:31:17.500 --> 00:31:19.300
And this is, like
most of the things

00:31:19.300 --> 00:31:23.250
that I just talked about are
kind of more exotic languages

00:31:23.250 --> 00:31:24.370
to this audience.

00:31:24.370 --> 00:31:27.150
But automatic hyphenation
is important between,

00:31:27.150 --> 00:31:29.860
for example,
Norwegian and English.

00:31:29.860 --> 00:31:32.660
They're both in the
same script, but if you

00:31:32.660 --> 00:31:35.760
use the wrong patterns, you'll
get you'll get weird hyphens.

00:31:35.760 --> 00:31:40.600
And then like there's-- how do
you know what the language is?

00:31:40.600 --> 00:31:43.460
And fortunately there is
an open source library.

00:31:43.460 --> 00:31:46.880
I mean, this is actually
mostly developed by Google,

00:31:46.880 --> 00:31:47.810
but it's out there.

00:31:47.810 --> 00:31:50.660
The Compact Language
Detector library,

00:31:50.660 --> 00:31:53.460
which is now in
its second version.

00:31:53.460 --> 00:31:55.960
It's open source and is designed
to be very performant, very

00:31:55.960 --> 00:31:56.460
fast.

00:31:56.460 --> 00:31:58.760
It's not a huge
dependency to take on.

00:31:58.760 --> 00:32:02.530
So if you've got an app where
you're displaying messages,

00:32:02.530 --> 00:32:04.360
and you really don't
have the metadata,

00:32:04.360 --> 00:32:07.650
you don't know where it came
from, what that language is,

00:32:07.650 --> 00:32:10.890
but you want to ensure that
it's displayed with the highest

00:32:10.890 --> 00:32:12.840
quality-- and of
course, that metadata

00:32:12.840 --> 00:32:15.340
can be really useful for
lots of other things--

00:32:15.340 --> 00:32:19.270
then we really do recommend
this compact language detector.

00:32:19.270 --> 00:32:24.550
And that'll-- you pipe the
output of that into set-text

00:32:24.550 --> 00:32:25.380
locale.

00:32:25.380 --> 00:32:29.750
And that really improves
the quality of your display.

00:32:29.750 --> 00:32:33.630
So that's kind of all of the
prepared topics that I had.

00:32:33.630 --> 00:32:36.400
I want to open it
up to questions.

00:32:36.400 --> 00:32:38.595
I'm happy to answer
any questions you have.

00:32:38.595 --> 00:32:40.460
And please wait for
the mic to come to you.

00:32:54.420 --> 00:32:57.890
AUDIENCE: On the
topic of custom fonts,

00:32:57.890 --> 00:33:02.380
so you doesn't dance via
simple view, such as text view,

00:33:02.380 --> 00:33:05.890
but it's pretty difficult to
do for framework UI classes

00:33:05.890 --> 00:33:09.074
such this such as like
navigation view or toolbar.

00:33:09.074 --> 00:33:11.240
Is there a recommended
way by the frameworks

00:33:11.240 --> 00:33:14.750
team to achieve like custom
fonts globally within your app?

00:33:14.750 --> 00:33:17.870
RAPH LEVIEN: Yeah,
that's a good question.

00:33:17.870 --> 00:33:24.360
I don't think we have a
mechanism for applying

00:33:24.360 --> 00:33:26.949
a font globally across the app.

00:33:26.949 --> 00:33:28.740
So unfortunately, I
think that is something

00:33:28.740 --> 00:33:32.720
that you have to do with code.

00:33:32.720 --> 00:33:36.340
But that's something that
we're interested in looking

00:33:36.340 --> 00:33:37.390
at, making easier.

00:33:40.610 --> 00:33:43.020
AUDIENCE: I get a lot
of requests from design

00:33:43.020 --> 00:33:48.295
for situations where they
want the text to be exactly

00:33:48.295 --> 00:33:50.670
this size-- possibly because
it's aligning with an image,

00:33:50.670 --> 00:33:51.700
or something like that.

00:33:55.130 --> 00:33:57.850
What I'd really like to do
is have the text shrink down,

00:33:57.850 --> 00:34:00.960
if it's in, say, a language
that has more text there.

00:34:00.960 --> 00:34:03.045
What is your
recommendation for that?

00:34:03.045 --> 00:34:05.740
RAPH LEVIEN: That's a
very common request.

00:34:05.740 --> 00:34:09.400
And we do not have support in
the framework for that yet.

00:34:09.400 --> 00:34:12.320
It is something that we
are really looking at.

00:34:12.320 --> 00:34:14.520
There are a number of
open-source libraries.

00:34:14.520 --> 00:34:17.840
One of the reasons that we
haven't implemented something

00:34:17.840 --> 00:34:19.969
like that-- I looked at it.

00:34:19.969 --> 00:34:22.120
And one of the problems
that you get into,

00:34:22.120 --> 00:34:24.892
is that you get, kind
of, how do you specify

00:34:24.892 --> 00:34:26.100
what that behavior should be?

00:34:26.100 --> 00:34:28.120
So you just specify, kind
of, one point in there

00:34:28.120 --> 00:34:30.639
where you want it to
be exactly that size.

00:34:30.639 --> 00:34:32.650
But there's a lot
of other use cases

00:34:32.650 --> 00:34:34.381
where people are
trying to-- you know,

00:34:34.381 --> 00:34:35.880
because you're
trying to line it up,

00:34:35.880 --> 00:34:37.989
basically, with other
graphic elements.

00:34:37.989 --> 00:34:40.380
There's a lot of other cases
where people are just mostly

00:34:40.380 --> 00:34:41.489
concerned about making it fit.

00:34:41.489 --> 00:34:43.120
So they want kind
of different logic.

00:34:43.120 --> 00:34:44.920
They want something
that says, make it

00:34:44.920 --> 00:34:47.350
a standard size make it 14sp.

00:34:47.350 --> 00:34:48.350
Unless that doesn't fit.

00:34:48.350 --> 00:34:50.190
And then we--
whoops, excuse me--

00:34:50.190 --> 00:34:53.040
and then we want to have it
shrink down to some other size.

00:34:53.040 --> 00:34:56.139
But we don't want to have it
shrink down to below eight,

00:34:56.139 --> 00:34:58.200
because then it
becomes illegible.

00:34:58.200 --> 00:35:00.720
So you get use cases
where specifying

00:35:00.720 --> 00:35:04.600
how you want that behavior to
scale is kind of complicated.

00:35:04.600 --> 00:35:09.189
And that's kind of-- if and
when we do implement something

00:35:09.189 --> 00:35:10.730
like that in the
framework, we really

00:35:10.730 --> 00:35:15.030
need to make sure that we
cover the range of behavior

00:35:15.030 --> 00:35:16.690
in a way that makes sense.

00:35:16.690 --> 00:35:20.470
Until then, I'm not
going to recommend

00:35:20.470 --> 00:35:22.380
any specific
open-source library,

00:35:22.380 --> 00:35:24.590
but there's a bunch
of them out there.

00:35:24.590 --> 00:35:26.840
And it's likely that
there's something

00:35:26.840 --> 00:35:28.420
that just
sub-classes-- you know,

00:35:28.420 --> 00:35:30.776
text view and overlays
that behavior.

00:35:30.776 --> 00:35:33.400
That there's-- it's likely that
there's something that will fit

00:35:33.400 --> 00:35:34.121
what you need.

00:35:36.887 --> 00:35:38.840
AUDIENCE: Early
on, I saw a mention

00:35:38.840 --> 00:35:41.495
for CSS styles being
applied to text.

00:35:41.495 --> 00:35:43.370
Is that something that's
done through styles?

00:35:43.370 --> 00:35:45.732
Or is it through the
use of HTML text?

00:35:45.732 --> 00:35:46.690
RAPH LEVIEN: OK.

00:35:46.690 --> 00:35:49.760
So I'm sorry if
that was misleading.

00:35:49.760 --> 00:35:53.940
It's not CSS styles in general
that we're applying to text.

00:35:53.940 --> 00:35:56.560
That there are
specific attributes,

00:35:56.560 --> 00:36:00.690
there are specific parameters
and that we're-- and in that

00:36:00.690 --> 00:36:03.640
particular slide, I was talking
about font-feature settings.

00:36:03.640 --> 00:36:06.670
And it's like the syntax,
because specifying

00:36:06.670 --> 00:36:09.040
all these OpenType features
is kind of a complex thing.

00:36:09.040 --> 00:36:11.750
It's not just like a number
or something like that.

00:36:11.750 --> 00:36:15.050
And so we adapted
the syntax from CSS.

00:36:15.050 --> 00:36:16.660
It is compatible with CSS.

00:36:16.660 --> 00:36:20.050
So if you have that particular
feature, other features

00:36:20.050 --> 00:36:22.550
that we've got like
letter spacing, the name

00:36:22.550 --> 00:36:24.850
of the feature, the
meaning of the future,

00:36:24.850 --> 00:36:27.280
we're trying to make
it consistent with CSS.

00:36:27.280 --> 00:36:32.080
But we haven't implemented a
web browser in Android framework

00:36:32.080 --> 00:36:32.790
text.

00:36:32.790 --> 00:36:37.960
You can use web view, but
that's-- there is not a generic

00:36:37.960 --> 00:36:39.180
CSS translator.

00:36:39.180 --> 00:36:40.940
It's just the
specific features that

00:36:40.940 --> 00:36:45.908
are low impedance or
compatible with CSS.

00:36:49.760 --> 00:36:51.960
AUDIENCE: What is
the performance cost

00:36:51.960 --> 00:36:55.657
of the high-quality text layout
strategy with hyphenation?

00:36:55.657 --> 00:36:57.990
For example if you like want
to actually change the text

00:36:57.990 --> 00:36:59.630
view contents, so
what is that going

00:36:59.630 --> 00:37:01.570
to cost you at lay out time?

00:37:01.570 --> 00:37:04.840
RAPH LEVIEN: Well,
measuring text performance

00:37:04.840 --> 00:37:05.860
is really complex.

00:37:05.860 --> 00:37:11.730
I mean the order of
magnitude is that it's

00:37:11.730 --> 00:37:15.660
about the same as
simple text in Lollipop.

00:37:15.660 --> 00:37:20.920
So it's doing more work, but
we actually took a wrench to it

00:37:20.920 --> 00:37:24.110
and did a lot of optimizations
to make it go faster.

00:37:24.110 --> 00:37:26.110
There's going to be some
specific cases that are

00:37:26.110 --> 00:37:27.496
going to be a little slower.

00:37:27.496 --> 00:37:29.120
There's other cases,
like for if you're

00:37:29.120 --> 00:37:31.150
editing a very large
buffer, that it's

00:37:31.150 --> 00:37:33.280
going to be a lot
faster, because we really

00:37:33.280 --> 00:37:37.690
did a lot of them performance
improvement in that area.

00:37:37.690 --> 00:37:40.550
So ultimately, if you're really
concerned about performance--

00:37:40.550 --> 00:37:43.670
like if you've profiled your
app and you've said oh my god,

00:37:43.670 --> 00:37:46.336
I'm spending all of this
time doing the layout

00:37:46.336 --> 00:37:47.460
of the high-quality layout.

00:37:47.460 --> 00:37:51.320
And if you've decided that
the visual improvement of that

00:37:51.320 --> 00:37:54.370
is not worth it in your app,
then by all means set simple.

00:37:54.370 --> 00:37:59.080
We have not come across-- I
can't really think of any apps

00:37:59.080 --> 00:38:00.645
that I know of,
either first party

00:38:00.645 --> 00:38:03.020
or third party, where people
have felt a need to do that.

00:38:03.020 --> 00:38:06.310
But it's certainly an
option and we will continue

00:38:06.310 --> 00:38:07.580
to improve the performance.

00:38:07.580 --> 00:38:11.260
This is a very
important area for us.

00:38:11.260 --> 00:38:12.996
It's got to not jank.

00:38:12.996 --> 00:38:16.680
AUDIENCE: Also, will there be
a support library for this?

00:38:16.680 --> 00:38:17.350
RAPH LEVIEN: No.

00:38:17.350 --> 00:38:18.820
Unfortunately, a
lot of the stuff

00:38:18.820 --> 00:38:21.380
that happens in framework
text is at such a low level

00:38:21.380 --> 00:38:24.420
that you can't really fill
it in with a support library.

00:38:34.670 --> 00:38:35.664
AUDIENCE: Hi.

00:38:35.664 --> 00:38:37.080
I know better than
to ask you what

00:38:37.080 --> 00:38:38.705
you guys are going
to do in the future,

00:38:38.705 --> 00:38:42.890
but I wanted to ask a
little about static layout

00:38:42.890 --> 00:38:48.160
and the new method that lets you
set custom margins per line--

00:38:48.160 --> 00:38:49.272
RAPH LEVIEN: Yes.

00:38:49.272 --> 00:38:51.760
AUDIENCE: I know it's not
ready to do full wrapping

00:38:51.760 --> 00:38:54.000
around a path, which is
what I imagined when I first

00:38:54.000 --> 00:38:54.625
heard about it.

00:38:54.625 --> 00:38:56.680
But I am wondering,
what were you guys

00:38:56.680 --> 00:38:58.430
imagining when you added it?

00:38:58.430 --> 00:39:00.060
Is it just the
circular watch face,

00:39:00.060 --> 00:39:01.810
or is there something
else cool I could do

00:39:01.810 --> 00:39:02.950
about it that I don't know yet?

00:39:02.950 --> 00:39:03.480
RAPH LEVIEN: Oh, great!

00:39:03.480 --> 00:39:03.980
No.

00:39:03.980 --> 00:39:07.260
And that's a slide that
almost happened in this talk,

00:39:07.260 --> 00:39:09.020
and I wanted to keep
it simple, because I

00:39:09.020 --> 00:39:15.420
wanted to talk about things that
would be for most developers.

00:39:15.420 --> 00:39:18.800
So certainly the circular watch
face-- so maybe I should just

00:39:18.800 --> 00:39:23.920
explain that there's
layers of the text stack

00:39:23.920 --> 00:39:27.170
where text view is the one
that most of you interact with.

00:39:27.170 --> 00:39:30.600
But underneath the text
view is static layout.

00:39:30.600 --> 00:39:33.050
And static layout does
a lot of the things

00:39:33.050 --> 00:39:35.610
around line breaking
and paragraph layout.

00:39:35.610 --> 00:39:37.810
And then below that is
draw text and the kind

00:39:37.810 --> 00:39:39.520
of very low-level APIs.

00:39:39.520 --> 00:39:41.730
And in static layout,
we have a new method

00:39:41.730 --> 00:39:44.680
that lets you adjust
the shape by controlling

00:39:44.680 --> 00:39:46.700
indents on the paragraph.

00:39:46.700 --> 00:39:49.290
And so yes, the watch
face was absolutely

00:39:49.290 --> 00:39:50.890
a motivation for that.

00:39:50.890 --> 00:39:52.490
We are seeing
other applications.

00:39:52.490 --> 00:39:54.610
People are adopting
it in cases where

00:39:54.610 --> 00:39:58.290
people are doing custom
views, rather than

00:39:58.290 --> 00:39:59.710
just relying on text view.

00:39:59.710 --> 00:40:01.650
One of the really nice
ones is when you just

00:40:01.650 --> 00:40:03.775
get to flow around an image,
where you're basically

00:40:03.775 --> 00:40:08.890
doing something like
a web-style float.

00:40:08.890 --> 00:40:13.610
And it is possible to do your
own-- to kind of roll your own.

00:40:13.610 --> 00:40:16.540
If you've got a
path, to figure out--

00:40:16.540 --> 00:40:18.950
based on the knowledge
of line heights and stuff

00:40:18.950 --> 00:40:21.470
like that-- to figure
out what the indents are.

00:40:21.470 --> 00:40:25.900
I think you'll see this
continue to evolve.

00:40:25.900 --> 00:40:31.070
Clearly, it makes sense to do
a higher-level feature that

00:40:31.070 --> 00:40:34.780
has kind of easier to
use, is not so low-level.

00:40:34.780 --> 00:40:37.195
But unfortunately,
it is not there yet.

00:40:42.160 --> 00:40:44.580
Any other questions?

00:40:44.580 --> 00:40:45.080
All right.

00:40:45.080 --> 00:40:47.490
Well, thank you so
much for coming.

