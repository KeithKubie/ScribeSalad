WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:02.960
Before we can make precise
statements about what is and

00:00:02.960 --> 00:00:06.320
is not computable, we need to
define what we mean by computation.

00:00:07.390 --> 00:00:10.110
We'll start with the notion of
some kind of machine or computer.

00:00:10.110 --> 00:00:13.600
And this machine takes in an input and

00:00:13.600 --> 00:00:18.410
after some finite amount of time
produces an output, or so we hope.

00:00:18.410 --> 00:00:22.170
In this lesson, we'll focus on the input
and output parts of this picture.

00:00:22.170 --> 00:00:25.640
And postpone the mathematical
definition of the machine itself.

00:00:25.640 --> 00:00:29.980
The input is formed from an alphabet,
which is a finite set of symbols or

00:00:29.980 --> 00:00:31.170
characters.

00:00:31.170 --> 00:00:32.509
The finite part is important.

00:00:33.820 --> 00:00:35.450
So if I wanted to use binary,

00:00:35.450 --> 00:00:38.830
my alphabet would consist of
the two symbols, 0 and 1.

00:00:38.830 --> 00:00:43.270
For genetic sequences
it's typical to use A, C,

00:00:43.270 --> 00:00:48.120
G, T which stand for the four possible
nucleotides in a DNA sequence.

00:00:49.120 --> 00:00:53.070
In practical applications, we often
use ASCII or Unicode for our alphabet.

00:00:54.720 --> 00:00:56.920
Now creating a new symbol for
every possible input and

00:00:56.920 --> 00:00:59.530
output would not be very convenient.

00:00:59.530 --> 00:01:05.319
So, instead, we use finite sequences
of symbols which we call strings.

00:01:05.319 --> 00:01:10.110
For example,
over the alphabet sigma we might have

00:01:10.110 --> 00:01:14.270
the string 1010,
which might represent the number 10.

00:01:14.270 --> 00:01:19.110
Or over our alphabet gamma,
we might have the string x = AACAG,

00:01:21.690 --> 00:01:24.560
which might represent
part of a DNA sequence.

00:01:24.560 --> 00:01:28.120
We notate the empty sequence,
which doesn't have any symbols in it.

00:01:28.120 --> 00:01:30.180
With the special character, Epsilon.

00:01:30.180 --> 00:01:33.720
Sometimes we will talk about
machines having string outputs,

00:01:33.720 --> 00:01:35.450
just like the inputs.

00:01:35.450 --> 00:01:38.740
But more often than not the output
will just be binary, an up or

00:01:38.740 --> 00:01:42.060
down decision about some
property of the input.

00:01:42.060 --> 00:01:47.130
So we might think about the machine
as just turning on one of two lights.

00:01:47.130 --> 00:01:50.330
Either one for accept or one for reject.

00:01:50.330 --> 00:01:52.610
Once the machine has finished computing.

00:01:52.610 --> 00:01:56.710
With these rules, an important type
becomes a collection of strings.

00:01:56.710 --> 00:01:59.700
Maybe it's the set of strings that
some particular machine accepts.

00:02:00.710 --> 00:02:02.890
Or maybe we're trying
to design a machine so

00:02:02.890 --> 00:02:06.990
that it accepts strings in
a certain set and no others.

00:02:06.990 --> 00:02:10.210
Or maybe we're asking if it's
even possible to design a machine

00:02:10.210 --> 00:02:14.590
that accepts everything in some
particular set of strings and no others.

00:02:14.590 --> 00:02:17.710
In all these cases, it's a set of
strings that we're talking about.

00:02:17.710 --> 00:02:21.150
So, it makes sense to give
this type its own name.

00:02:21.150 --> 00:02:24.040
We call a set of strings a Language.

00:02:24.040 --> 00:02:29.118
For example, a Language could be a list
of names, Charles {'Charles', 'Lance'}.

00:02:29.118 --> 00:02:33.390
It could be the set of binary
strings that represent even numbers.

00:02:33.390 --> 00:02:36.780
Notice that this set is infinite,
or it could be the empty set.

00:02:37.790 --> 00:02:40.510
Any set of strings over
an alphabet is a language.

