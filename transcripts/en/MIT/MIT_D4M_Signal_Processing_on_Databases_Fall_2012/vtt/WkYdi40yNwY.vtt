WEBVTT
Kind: captions
Language: en

00:00:00.040 --> 00:00:02.410
The following content is
provided under a Creative

00:00:02.410 --> 00:00:03.790
Commons license.

00:00:03.790 --> 00:00:06.030
Your support will help
MIT OpenCourseWare

00:00:06.030 --> 00:00:10.110
continue to offer high quality
educational resources for free.

00:00:10.110 --> 00:00:12.680
To make a donation or to
view additional materials

00:00:12.680 --> 00:00:16.496
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.496 --> 00:00:17.120
at ocw.mit.edu.

00:00:22.020 --> 00:00:28.760
PROFESSOR: So again, we go here
back up to the Examples, Intro,

00:00:28.760 --> 00:00:31.902
Group Theory, start it up.

00:00:59.620 --> 00:01:02.639
And then our first
example is group theory 1,

00:01:02.639 --> 00:01:03.680
and it just goes through.

00:01:03.680 --> 00:01:06.620
And basically, I came up
with a way in a spreadsheet

00:01:06.620 --> 00:01:09.540
to define the functions
I was looking at,

00:01:09.540 --> 00:01:11.570
and then start creating
combinations of them,

00:01:11.570 --> 00:01:15.700
and then do very simple
tests on associativity

00:01:15.700 --> 00:01:17.450
and [? distribution ?]
and all that stuff.

00:01:17.450 --> 00:01:19.240
If you actually look
at the tests I do,

00:01:19.240 --> 00:01:22.070
you might blanch
and be like, really?

00:01:22.070 --> 00:01:23.240
You said that?

00:01:23.240 --> 00:01:25.449
You declared that it
was fully associative?

00:01:25.449 --> 00:01:27.990
It's not like I went in and did
formal proofs for everything.

00:01:27.990 --> 00:01:31.360
I just did some very
quick numerical tests.

00:01:31.360 --> 00:01:36.020
The semi-ring test actually
takes a while here,

00:01:36.020 --> 00:01:39.936
as you can see.

00:01:39.936 --> 00:01:41.310
And this will take
a minute here.

00:01:45.380 --> 00:01:46.480
It appears to be hanging.

00:01:46.480 --> 00:01:47.540
Oh, no, it's not.

00:01:47.540 --> 00:01:49.790
Good.

00:01:49.790 --> 00:01:52.635
We'll let it go through that.

00:01:52.635 --> 00:02:00.080
In fact, while it does that,
we can look at-- basically,

00:02:00.080 --> 00:02:00.882
these are inputs.

00:02:10.400 --> 00:02:13.560
So basically, I
have my different--

00:02:13.560 --> 00:02:15.050
what I call the key function.

00:02:15.050 --> 00:02:17.960
I have union and
intersection, and then

00:02:17.960 --> 00:02:22.320
I have the three possible
conditions-- v1 less than v2,

00:02:22.320 --> 00:02:25.370
v1 equal to v2, v1
greater than v2,

00:02:25.370 --> 00:02:27.180
and then essentially,
the different types

00:02:27.180 --> 00:02:32.620
of operators, the results
that can occur from those.

00:02:32.620 --> 00:02:37.021
And so this is a CSV
file, and we read it

00:02:37.021 --> 00:02:38.520
in as [? associative ?]
[INAUDIBLE].

00:02:38.520 --> 00:02:40.470
And so it looks
like a spreadsheet,

00:02:40.470 --> 00:02:45.070
and I can actually have
columns named v1 less than v1.

00:02:45.070 --> 00:02:45.850
Very powerful.

00:02:45.850 --> 00:02:49.620
And in fact, I'm even
able to pass that column

00:02:49.620 --> 00:02:53.890
into the Matlab Eval function
and have it actually execute

00:02:53.890 --> 00:02:55.540
it, which is nice.

00:02:55.540 --> 00:03:01.980
So I can actually have code
in my column or row names,

00:03:01.980 --> 00:03:04.980
and then have
operations performed

00:03:04.980 --> 00:03:06.510
based on that,
which is, I think,

00:03:06.510 --> 00:03:10.190
a nice thing that you
can do when you allow

00:03:10.190 --> 00:03:11.750
strings to be in your set.

00:03:11.750 --> 00:03:15.290
Likewise, Matlab will formally
parse nan as nan and plus

00:03:15.290 --> 00:03:18.675
minus inf as minus inf, and so
I can get all that functionality

00:03:18.675 --> 00:03:20.050
out of there,
which is very nice.

00:03:26.080 --> 00:03:28.435
And then it goes
through-- let's see here.

00:03:32.460 --> 00:03:34.845
And these are just different
tests that we do on those.

00:03:43.055 --> 00:03:44.740
STUDENT: Is nan a
special character?

00:03:47.730 --> 00:03:48.970
PROFESSOR: Not a number.

00:03:48.970 --> 00:03:52.070
Yeah, I kind of--
I use that as-- it

00:03:52.070 --> 00:03:54.230
has a lot of the
properties of null

00:03:54.230 --> 00:03:56.080
when you add it to
different functions.

00:03:56.080 --> 00:04:03.120
So I'm using that for that,
and it works out pretty well.

00:04:03.120 --> 00:04:08.910
So it's IEEE failure state modes
or whatever it's-- it appears

00:04:08.910 --> 00:04:10.366
like that.

00:04:10.366 --> 00:04:13.340
I can't remember if there is
a plus nan and negative nan

00:04:13.340 --> 00:04:14.190
as well.

00:04:14.190 --> 00:04:15.130
No.

00:04:15.130 --> 00:04:16.180
It's just nan, yeah.

00:04:19.070 --> 00:04:21.459
And then actually,
it goes through here,

00:04:21.459 --> 00:04:26.650
and I think-- these are just
various ways of inputting--

00:04:26.650 --> 00:04:29.730
these are different values,
different little spreadsheets

00:04:29.730 --> 00:04:32.640
that you can make for
exploring these different types

00:04:32.640 --> 00:04:33.250
of things.

00:04:33.250 --> 00:04:35.570
And you can just write
them as little CSV files.

00:04:35.570 --> 00:04:37.080
Very useful.

00:04:37.080 --> 00:04:39.617
On Instruct here.

00:04:39.617 --> 00:04:41.700
I do apologize for the
length of time it's taking.

00:04:41.700 --> 00:04:46.280
I think having the QuickTime
video recording going

00:04:46.280 --> 00:04:49.280
at the same time is
causing the poor computer

00:04:49.280 --> 00:04:52.665
to sweat a little bit more
than it does normally.

00:04:52.665 --> 00:04:54.233
It usually doesn't
take this long.

00:05:01.360 --> 00:05:04.440
Outputs that it
comes up with-- it

00:05:04.440 --> 00:05:05.920
basically writes all these out.

00:05:09.460 --> 00:05:11.540
Look here.

00:05:11.540 --> 00:05:17.540
This shows-- I ask it
to basically generate

00:05:17.540 --> 00:05:19.000
all those 200 pairs.

00:05:19.000 --> 00:05:22.459
So for each key and whatever,
it can go and generate

00:05:22.459 --> 00:05:23.000
those for me.

00:05:23.000 --> 00:05:26.680
So I create this little thing,
and it goes through and creates

00:05:26.680 --> 00:05:28.950
this whole function, and
then writes that out as a CSV

00:05:28.950 --> 00:05:30.410
itself, which is
very convenient.

00:05:30.410 --> 00:05:31.890
Again, these are
things you can do.

00:05:31.890 --> 00:05:34.580
I think this is the one
where we came up with all the

00:05:34.580 --> 00:05:36.030
[? fields. ?] Oh, yeah.

00:05:36.030 --> 00:05:38.357
It doesn't really fit there.

00:05:38.357 --> 00:05:40.440
But you can see these are
the pairs that it found,

00:05:40.440 --> 00:05:42.880
and it shows this is
the zero operator.

00:05:42.880 --> 00:05:46.380
And again, this is all done
with D4M kinds of values

00:05:46.380 --> 00:05:49.150
that it can store
different types of things.

00:05:49.150 --> 00:05:52.210
This is how we made all the
tables that are in there.

00:05:52.210 --> 00:05:53.820
Oh, it's writing out results.

00:05:53.820 --> 00:05:54.810
That means it's done.

00:05:58.790 --> 00:06:00.030
There we go.

00:06:00.030 --> 00:06:01.650
And so the main
one I want to show

00:06:01.650 --> 00:06:05.640
you is that we [? read in ?]
that function, func range,

00:06:05.640 --> 00:06:07.352
and we permuted it.

00:06:07.352 --> 00:06:14.370
And if we do display
full afunc, you

00:06:14.370 --> 00:06:18.500
can see there is the full
combination of values

00:06:18.500 --> 00:06:19.950
as we saw there.

00:06:19.950 --> 00:06:22.250
So there's really
nothing here for you.

00:06:22.250 --> 00:06:25.080
It's not I expect
you to go using

00:06:25.080 --> 00:06:27.210
D4M to do group theory things.

00:06:27.210 --> 00:06:29.180
That's not really the
point of these examples.

00:06:29.180 --> 00:06:30.370
I did.

00:06:30.370 --> 00:06:32.510
It's more just
showing that you can--

00:06:32.510 --> 00:06:36.040
when you go into this
larger space, problems

00:06:36.040 --> 00:06:38.340
that you might not solve
linear algebraically,

00:06:38.340 --> 00:06:40.425
all the sudden,
it's like, oh yeah,

00:06:40.425 --> 00:06:43.310
if I have strings and
other types of things,

00:06:43.310 --> 00:06:44.950
it really opens up
the flexibility.

00:06:44.950 --> 00:06:47.490
I thought that was very
neat that you could do this.

00:06:47.490 --> 00:06:49.480
It just handled the
data very nicely

00:06:49.480 --> 00:06:54.240
and without any real difficulty.

00:06:54.240 --> 00:06:57.540
So with that, that's
the end of this lecture.

00:06:57.540 --> 00:06:59.950
I don't know if there's
any final questions

00:06:59.950 --> 00:07:02.441
before we proceed.

00:07:02.441 --> 00:07:02.940
All right.

00:07:02.940 --> 00:07:03.910
Very good.

00:07:03.910 --> 00:07:06.410
And please, if you haven't
signed up on the sheet,

00:07:06.410 --> 00:07:08.390
please do so.

00:07:08.390 --> 00:07:10.300
Thank you very much.

