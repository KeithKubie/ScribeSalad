WEBVTT
Kind: captions
Language: en

00:00:00.030 --> 00:00:05.969
The thing you used to dread more than anything else was to take these out of the box in which you

00:00:06.399 --> 00:00:07.470
carefully stacked them up

00:00:07.470 --> 00:00:11.720
and then accidentally dropped them on the floor. There is no quicker way

00:00:12.180 --> 00:00:17.240
to discover what n factorial means when you start trying to put them back together in the right order

00:00:17.250 --> 00:00:18.020
 

00:00:18.039 --> 00:00:23.489
Armed only with your knowledge of ALGOL programs and which order these things must have occurred in

00:00:27.160 --> 00:00:31.769
We have here in the department a legacy deck of punch cards

00:00:31.769 --> 00:00:32.980
 

00:00:32.980 --> 00:00:36.029
dating at my best guess from about

00:00:37.149 --> 00:00:40.378
1971 it was left behind by a

00:00:41.739 --> 00:00:47.399
Statistic student of that era can act in it just is like a blast from the past

00:00:47.399 --> 00:00:48.160
 

00:00:48.160 --> 00:00:54.000
We'll put this on the classic black background provided by the cover of an iPad

00:00:54.000 --> 00:00:56.189
What could be better old meets new?

00:00:57.120 --> 00:01:00.900
At the top of the deck we used to have to put a colored card

00:01:01.560 --> 00:01:06.860
Basically stating who we were and what this job was about

00:01:06.860 --> 00:01:11.820
Now I think the first thing to draw your attention to on any sample of these cards is

00:01:13.080 --> 00:01:18.900
You look at them against the light and if you remember that a card reader is reading

00:01:19.560 --> 00:01:22.340
vertically to get its characters [boom]

00:01:23.350 --> 00:01:30.150
Run like that not horizontally... The most amazing thing you then discover which threw me for a while because I'd rather forgotten

00:01:30.150 --> 00:01:35.519
It works like this is that if you now put the card down on a black background

00:01:36.189 --> 00:01:40.889
And will use another card as a ruler just look what happens every single

00:01:41.560 --> 00:01:43.180
character and

00:01:43.180 --> 00:01:45.180
if you look very carefully as

00:01:45.780 --> 00:01:47.840
well as the whole pattern

00:01:48.610 --> 00:01:56.219
That denotes a character it can also be printed out at the top of the card although the printing Ribbon was pretty faded without

00:01:57.070 --> 00:01:58.840
these

00:01:58.840 --> 00:02:01.680
nevermind every single character has got a

00:02:02.020 --> 00:02:09.760
different hole punch pattern but there's never more than two holes that are punched. Now that might seem very strange

00:02:09.940 --> 00:02:14.600
and as I say I gave me a jolt at all. How on Earth does that get

00:02:15.160 --> 00:02:20.310
converted into a character code which is going to be a bit pattern representing an ASCII character

00:02:20.310 --> 00:02:23.640
or whatever you can't just port ASCII

00:02:24.180 --> 00:02:28.800
character punching down here if you did you get into all sorts of problems.

00:02:29.160 --> 00:02:32.660
Because some ASCII characters have got lots of one bits in them

00:02:32.670 --> 00:02:38.320
and if the situation is that you chose that every one bit was a hole

00:02:39.430 --> 00:02:43.409
some characters would make this thing look like confetti. It would be like having a

00:02:44.230 --> 00:02:50.700
terraform... you know the [beasts] [only] [holes]... that the actual mechanical substrate of the card will be very fragile

00:02:50.889 --> 00:02:53.459
So this is the reason that there are

00:02:54.340 --> 00:02:59.280
various choices of two holes here out of 11 rows in total

00:02:59.829 --> 00:03:01.780
and that gives enough

00:03:01.780 --> 00:03:03.780
combinations to give a

00:03:04.900 --> 00:03:06.900
unique code for

00:03:07.080 --> 00:03:09.080
a fairly limited

00:03:09.340 --> 00:03:11.360
alphabet admittedly, but it works

00:03:12.240 --> 00:03:16.180
So perhaps another thing to point out is that these are

00:03:17.440 --> 00:03:19.980
cards for an

00:03:20.560 --> 00:03:23.980
ICL 1900 computer which was mentioned in the previous video

00:03:24.549 --> 00:03:26.728
The ICL 1900 series

00:03:27.489 --> 00:03:33.059
internally did not hold its characters in 8 bits as would be done

00:03:33.060 --> 00:03:35.759
nowadays. It held them in 6 bits

00:03:36.400 --> 00:03:41.760
So pretty well all of you out there are familiar with the fact that nowadays if you like

00:03:42.480 --> 00:03:44.380
the standard

00:03:44.380 --> 00:03:47.320
for years has been that you have a computer

00:03:47.859 --> 00:03:50.429
whose integers are held in 32 bits?

00:03:50.620 --> 00:03:56.009
but if you want those 32 bit entities called words are broken up into

00:03:56.709 --> 00:03:58.709
four 8-bit bytes

00:03:59.139 --> 00:04:06.749
Nowadays, it's the bytes that are addressed not the words and that particular architecture of byte address machines been

00:04:06.970 --> 00:04:10.559
optionally groupable into longer units to hold either

00:04:10.780 --> 00:04:18.659
instructions or integers or whatever that really did start with IBM mainframes they were the first to go in for byte addressing and 8-bit bytes

00:04:19.720 --> 00:04:25.889
ICL on the other hand did not have 32-bit words with four 8-bit characters it had

00:04:26.470 --> 00:04:33.300
24-bit words with four 6-bit characters. Why are here you cry the answer is it's cheaper

00:04:33.690 --> 00:04:37.320
You've got rather less memory to provide rather

00:04:38.050 --> 00:04:43.229
simpler adders to do you only need 6-bit adder circuitry not 8-bit adder circuitry and

00:04:43.870 --> 00:04:45.700
it's as simple as that

00:04:45.700 --> 00:04:53.680
LCL could make their computers a little bit cheaper than IBM although they were arguably as well a little bit slower and so on

00:04:54.240 --> 00:04:58.600
So this is what these hole punchings are all about.

00:04:59.140 --> 00:05:01.140
They are equating

00:05:01.510 --> 00:05:08.279
by specialized circuitry in the card reader to it being able to recognize these patterns and say oh

00:05:08.380 --> 00:05:14.550
That's the 6 bit character such-and-such, and it will put that into a temporary file behind the scenes

00:05:15.420 --> 00:05:21.660
Now when you're preparing these card decks you really did have to take huge care

00:05:22.540 --> 00:05:28.720
First of all the yellow card announces that this is a job for the computer to do - big surprise there

00:05:29.220 --> 00:05:30.660
There's a NUPMS

00:05:30.660 --> 00:05:38.010
They're Nottingham (?) University Physics and Maths I think that stands for. This is ken's identifier

00:05:38.010 --> 00:05:41.039
PMSKA for Ken Akin (?), and I think this thing at the end

00:05:41.590 --> 00:05:46.830
announces the global terminator for this deck of cards which will come right at the bottom for our [perros]

00:05:47.860 --> 00:05:49.270
Okay

00:05:49.270 --> 00:05:52.289
Then there's a little piece of job control here

00:05:53.110 --> 00:05:59.520
basically saying I want the Nottingham (?) University EXECutive program which was our own sort of

00:06:00.190 --> 00:06:04.499
homebrew addition to ICL's GEORGE operating system

00:06:05.020 --> 00:06:09.449
And you notice at the end here. It says BY C in this

00:06:10.240 --> 00:06:12.360
added module to the operating system

00:06:12.490 --> 00:06:14.490
You could say how desperately

00:06:14.530 --> 00:06:22.290
urgent this job was or not. You were given a certain number of notional pounds to spend every month for every user.

00:06:22.600 --> 00:06:26.820
And you could opt to spend less money and have it run at low priority

00:06:27.700 --> 00:06:30.210
But you could either spend it by a which means

00:06:30.210 --> 00:06:31.720
I want the job doing right now

00:06:31.720 --> 00:06:37.919
Or you could say I'll go overnight and you were charged as a much lower rate. The next card we see here

00:06:39.599 --> 00:06:46.069
announces that this is an ALGOL job, the following cards will be in the ALGOL language

00:06:46.800 --> 00:06:48.800
So this is a signal to the operating system

00:06:49.199 --> 00:06:55.968
though to read all this in but when it's been read in it has to be fed in to the ALGOL compiler and the

00:06:56.550 --> 00:06:59.449
operating system knows where that's kept you don't

00:06:59.969 --> 00:07:01.080
unlike

00:07:01.080 --> 00:07:07.669
Unix Linux, whatever these days you don't get very close to the operating system. It's there

00:07:09.360 --> 00:07:11.840
It doesn't do much for you except run your jobs

00:07:11.840 --> 00:07:13.840
You just have to trust to it more or less

00:07:13.919 --> 00:07:18.109
Notice here for those of you at all familiar with things like ALGOL and Pascal

00:07:18.110 --> 00:07:24.740
It's beginning to look fairly sensible: BEGIN. That's a reserved word in the ALGOL language

00:07:24.740 --> 00:07:27.440
It's a bit like open curly-brace ("{") in C

00:07:27.750 --> 00:07:31.940
But ALGOL use BEGIN and END instead of 
open curly ("{") and closed curly ("}")

00:07:32.430 --> 00:07:37.909
Notice that it's signaled as being a reserved special word because it uses prime or

00:07:38.370 --> 00:07:41.659
Single quote symbols, it's quote begin quote ('BEGIN')

00:07:42.180 --> 00:07:46.609
Quote procedure quote ('PROCEDURE'). That's another reserved word in the ALGOL language

00:07:46.610 --> 00:07:52.250
And it's defining this procedure E01AAA with these

00:07:52.700 --> 00:07:53.860
formal parameters

00:07:53.860 --> 00:08:00.760
or arguments. 
There we are then you're sitting in front of a card punch you type in just like you would do on a

00:08:01.020 --> 00:08:05.000
ordinary keyboard these days except this thing is electromechanical

00:08:05.250 --> 00:08:11.959
So it's going to splash splash splash splash all the time. Every character you hit is punching out holes

00:08:12.330 --> 00:08:18.560
electromechanically and at the same time is hammering out a typewriter record on the top of

00:08:18.900 --> 00:08:22.699
exactly what all these holes mean.
Every time you hit the return key

00:08:23.909 --> 00:08:28.519
whereas even on the dumb terminal you find the cursor going zonk back from

00:08:29.430 --> 00:08:32.359
from the right hand side of the screen to the left as you look at it

00:08:32.519 --> 00:08:36.948
what would happen when you hit return on one of these is that the card would as if by magic?

00:08:37.560 --> 00:08:44.929
Be taken away from the punching station and propelled
I think with sort of compressed air to a catcher tray

00:08:44.940 --> 00:08:49.399
So one after another you would build up a stack of cards in order

00:08:49.970 --> 00:08:51.680
That would later be fed into the machine

00:08:51.680 --> 00:08:52.440
 

00:08:52.440 --> 00:08:59.299
So when it's all completed and of course the advantage is with having these things written out on top if you could see any mistakes on

00:08:59.300 --> 00:09:04.789
a quick scan through you can always punch another card and replace the bad card with a good card

00:09:05.280 --> 00:09:11.569
You would end up with a job to be submitted can stack is a particularly short one

00:09:11.760 --> 00:09:18.650
It just seemed to be running this routine and using it to generate a small amount of data to be printed out

00:09:18.650 --> 00:09:24.499
So there we are, a very very small job.
In order to stay sane

00:09:25.110 --> 00:09:27.110
what you need to do is the following?

00:09:27.360 --> 00:09:34.460
First of all decide whether your card punch like to have these beveled corners at the top left or top right

00:09:35.340 --> 00:09:43.280
Faintly recall that ICL and IBM probably did them different ways around, but that was the thing to help you get your cards aligned and

00:09:44.160 --> 00:09:46.820
stop you turning one accidentally upside down and

00:09:47.910 --> 00:09:50.420
thereby reading in the wrong hole pattern in the wrong order

00:09:51.180 --> 00:09:54.410
You used to make sure the bevels were

00:09:55.200 --> 00:09:58.099
in place and like that, so that's one

00:09:58.770 --> 00:10:00.480
self-protection mechanism

00:10:00.480 --> 00:10:08.060
Another one that was optionally available on some better quality card punches with support at the far right of the card

00:10:08.490 --> 00:10:12.979
typically, I think in columns 72 to 80 because these are 80-columned cards

00:10:13.530 --> 00:10:20.089
You could put a sequencing number here, okay? You can have them automatically sequence the numbered as you

00:10:20.700 --> 00:10:28.129
punch them out on the card punch
The thing you used to dread more than anything else was to take these out of the box

00:10:28.470 --> 00:10:33.020
in which you carefully stacked them up and then accidentally dropped them on the floor

00:10:33.660 --> 00:10:40.489
There is no quicker way to discover what n factorial means when you start trying to put them back together in the right order

00:10:41.280 --> 00:10:46.729
armed only with your knowledge of ALGOL programs and which order these things must have occurred in

00:10:47.070 --> 00:10:52.640
So all sorts of subterfuge is used to be used, but the best was to have them

00:10:53.370 --> 00:10:58.580
numbered if possible and then if you could afford one of these things that were actually

00:10:58.830 --> 00:11:05.399
card collecting machines where if you put in a randomized of cards they could electromechanically sort them for you

00:11:05.399 --> 00:11:11.249
I can't recall I ever used one of those perhaps. I was careful enough or perhaps the university couldn't afford one

00:11:11.250 --> 00:11:15.959
I don't know. 
Another common trick to use which I'm actually port

00:11:16.720 --> 00:11:21.089
marker pen markings at the top of these if you did or you wrote a word here

00:11:21.089 --> 00:11:27.359
You could get them broadly back in the correct order by just making your patterns at the top look

00:11:27.759 --> 00:11:33.659
correct and get them back in roughly the way they should have been. So here we have you see a much

00:11:34.240 --> 00:11:36.130
more substantial

00:11:36.130 --> 00:11:39.179
ALGOL job, I think most of this is programmed

00:11:39.180 --> 00:11:42.719
there's a little bit of data at the bottom.
-So would you have one of these cards for every line?

00:11:42.940 --> 00:11:44.999
would that be kind of...
- Every line of the program?

00:11:45.000 --> 00:11:49.139
Yeah, would have a card.
-Line and you could only fit one line for your copy.

00:11:49.209 --> 00:11:54.359
-Yeah, yeah, one lamp guard. 
Right at the end of this lodge of stuff

00:11:54.759 --> 00:11:57.929
Let's put it down here as a separate card of its own

00:11:58.540 --> 00:12:04.349
you see that magic word END and that is the final end of the program

00:12:04.839 --> 00:12:09.809
And just as in other languages you're open ("{") and closed curly braces ("}") can be nested inside each other

00:12:10.149 --> 00:12:14.969
So also in ALGOL the BEGIN END blocks could be nested inside one another

00:12:16.269 --> 00:12:22.078
So that END then is the final card of the program

00:12:22.180 --> 00:12:26.579
But then look what happens you get a full asterisks card

00:12:27.910 --> 00:12:35.459
The four asterisks is a marker to say that's the end of my program, but there's still another section of my stuff to come

00:12:36.069 --> 00:12:42.179
After four asterisks you give the reserved word DATA and this is such a simple program

00:12:42.180 --> 00:12:47.279
I think from what I can make out it takes these three integers here and

00:12:47.800 --> 00:12:50.130
uses them to generate yet more data

00:12:50.560 --> 00:12:55.979
which will be of use in some other programs, so 
that is it. There's the data

00:12:56.139 --> 00:13:02.639
that's the end of the pack. If you had a program that generated more data for input to another program a

00:13:02.949 --> 00:13:09.299
favorite thing you could do was to specify in your job control at the very top that what you would like is

00:13:10.149 --> 00:13:16.439
not just a line printer output of your answers, but to punch out another deck of cards

00:13:17.200 --> 00:13:21.689
For use in putting it into some other program later on

00:13:22.300 --> 00:13:26.880
-So that basically provides you with a set of data to use with a different [program]

00:13:26.950 --> 00:13:31.349
Yes, and you might say well, why not just pocket in a disk file

00:13:31.990 --> 00:13:36.750
You've got to remember. This is the early seventies. You did not have a personal

00:13:37.390 --> 00:13:39.509
allocation of files on disk

00:13:40.240 --> 00:13:43.109
Yes, then would be a disk backing up this computer

00:13:43.300 --> 00:13:45.539
But use entirely by the operating system

00:13:45.910 --> 00:13:52.529
Full of temporary files holding your jobs for you, feeding them in an order and all that, but in the very early days

00:13:52.810 --> 00:13:58.079
You in person did not get a personal account to hold your files

00:13:58.329 --> 00:14:02.099
You wanted to run something later on then you had to print it out

00:14:02.620 --> 00:14:05.700
So whereas nowadays a lot of you know

00:14:06.519 --> 00:14:12.179
if you want to punch out date for use another program you can either use a Unix pipe and pipe it

00:14:12.339 --> 00:14:17.909
directly into another program or you can use the Unix greater than symbol and send it into a file

00:14:18.520 --> 00:14:23.999
Much more complicated in these days you had to announce ahead of time that you would be punching out

00:14:24.220 --> 00:14:26.220
results as well as printing them out

00:14:31.329 --> 00:14:34.949
That's interesting. What would a computer do with a hanging Chad?

00:14:35.649 --> 00:14:39.029
The admission of Richard Stallman's name was not intentional

00:14:39.029 --> 00:14:41.639
I was thinking of him actually as I spoke

00:14:42.010 --> 00:14:46.169
I was tempted for a while and many of my friends told me to try this on with you

00:14:46.170 --> 00:14:47.129
But maybe not

00:14:47.129 --> 00:14:49.860
It would tend that the compressed air

00:14:50.110 --> 00:14:54.329
is a lot of compressed air used in these machines to move the cars through very quickly

