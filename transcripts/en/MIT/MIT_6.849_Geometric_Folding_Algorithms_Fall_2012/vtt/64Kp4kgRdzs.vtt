WEBVTT
Kind: captions
Language: en

00:00:03.310 --> 00:00:05.620
PROFESSOR: All right,
let's get started.

00:00:05.620 --> 00:00:09.470
We are continuing our
theme of folding polygons

00:00:09.470 --> 00:00:14.520
into convex polyhedra.

00:00:14.520 --> 00:00:18.050
Let's do a quick
reminder, we're talking

00:00:18.050 --> 00:00:22.845
about gluing up the boundary
of a polygon to itself.

00:00:29.030 --> 00:00:35.640
And we were representing that
with gluing trees last time.

00:00:35.640 --> 00:00:39.214
So I want to do an actual
example of a gluing tree.

00:00:39.214 --> 00:00:40.630
So this is how you
make a cube out

00:00:40.630 --> 00:00:42.975
of a cross, my favorite example.

00:00:45.910 --> 00:00:49.400
And a valid gluing,
it's an Alexandroff

00:00:49.400 --> 00:00:51.256
gluing because it
has no crossing, so

00:00:51.256 --> 00:00:52.380
its topologically a sphere.

00:00:52.380 --> 00:00:54.410
Everything is glued
to everything.

00:00:54.410 --> 00:00:58.200
And it never glues more
than 360 degrees of material

00:00:58.200 --> 00:00:58.910
to any point.

00:00:58.910 --> 00:01:02.180
In fact, it's going to
be 270 at every point,

00:01:02.180 --> 00:01:06.210
because that's the curvature
of every vertex of a cube.

00:01:06.210 --> 00:01:11.927
And the gluing tree was, if we
sort of turned this inside out

00:01:11.927 --> 00:01:14.260
and think of the polygon as
being on the outside instead

00:01:14.260 --> 00:01:17.650
of the inside, it's really
hard to see here how to convert

00:01:17.650 --> 00:01:20.340
that into a gluing tree,
though you can do it.

00:01:20.340 --> 00:01:23.057
It's the way that
these arrows nest.

00:01:23.057 --> 00:01:25.140
But it's a little easier
to think of on the sphere

00:01:25.140 --> 00:01:27.348
or on the polyhedron, because
then turning inside out

00:01:27.348 --> 00:01:28.670
is just upside down.

00:01:28.670 --> 00:01:29.980
It's not a big deal.

00:01:29.980 --> 00:01:38.042
So if we look at where
the cut are on the cube,

00:01:38.042 --> 00:01:40.280
it looks something like this.

00:01:40.280 --> 00:01:41.874
That should be a cross.

00:01:41.874 --> 00:01:43.290
This is the top
of the cross, this

00:01:43.290 --> 00:01:44.730
is the bottom of the cross.

00:01:44.730 --> 00:01:47.420
It goes around the back side.

00:01:47.420 --> 00:01:50.640
So then the gluing tree is
essentially this doubled.

00:01:50.640 --> 00:01:53.690
If we walk around the
outside of the cuts,

00:01:53.690 --> 00:01:55.310
that is the gluing tree.

00:01:55.310 --> 00:01:59.680
So I can see, there's this
segment, then this segment,

00:01:59.680 --> 00:02:02.460
then that segment.

00:02:02.460 --> 00:02:09.789
Then we're back here,
then we go up one, two,

00:02:09.789 --> 00:02:10.810
and then we turn around.

00:02:10.810 --> 00:02:15.000
That's a leaf, and so it's
going to look like this weird h

00:02:15.000 --> 00:02:16.530
shape.

00:02:16.530 --> 00:02:19.855
And these are vertices.

00:02:26.290 --> 00:02:29.760
That's right, all of
these should be vertices.

00:02:29.760 --> 00:02:32.820
And locally you can see, ah,
this is a 90 degree angle.

00:02:32.820 --> 00:02:34.530
This is actually the
top of the cross,

00:02:34.530 --> 00:02:36.924
remember the polygon
is now out here.

00:02:36.924 --> 00:02:38.340
That's going to
be the top across.

00:02:38.340 --> 00:02:40.120
This is where it turns,
it gets a little confusing

00:02:40.120 --> 00:02:41.500
because of the
way I've drawn it.

00:02:41.500 --> 00:02:42.640
Here's the bottom of the cross.

00:02:42.640 --> 00:02:43.806
Those parts are easy to see.

00:02:43.806 --> 00:02:46.050
The rest is little awkward.

00:02:46.050 --> 00:02:47.790
But for algorithms,
this is a great way

00:02:47.790 --> 00:02:48.860
to think about things.

00:02:48.860 --> 00:02:51.380
And also for proving bounds
and how many different ways

00:02:51.380 --> 00:02:54.300
to fold, it's really useful
to think about gluing trees.

00:02:54.300 --> 00:02:56.330
Of course, all of these
views are equivalent,

00:02:56.330 --> 00:02:59.840
but a lot of things will
be easier to analyze here.

00:02:59.840 --> 00:03:02.300
So, clear?

00:03:02.300 --> 00:03:07.860
Let me first tell you what
we're going to prove today.

00:03:07.860 --> 00:03:15.760
We're going to do combinatorial
bounds and algorithms

00:03:15.760 --> 00:03:17.093
for all of this.

00:03:20.460 --> 00:03:21.790
And let's see.

00:03:21.790 --> 00:03:28.370
So I want general gluings,
general situation,

00:03:28.370 --> 00:03:35.390
edge-to-edge gluings, and a
particular kind of polygon

00:03:35.390 --> 00:03:36.573
called bounded sharpness.

00:03:44.120 --> 00:03:46.110
And then I want two columns.

00:03:49.610 --> 00:03:52.112
The first question is, how
many gluings are there?

00:03:52.112 --> 00:03:54.320
And whenever we get a bound
on the number of gluings,

00:03:54.320 --> 00:03:56.680
we're also going to get
an enumeration algorithm.

00:03:59.287 --> 00:04:00.620
Remember, there are three goals.

00:04:00.620 --> 00:04:01.786
The first goal was decision.

00:04:01.786 --> 00:04:03.280
Is there any folding?

00:04:03.280 --> 00:04:07.070
Second goal was enumeration,
give me all the foldings.

00:04:07.070 --> 00:04:09.210
And third goal was
counting, I think.

00:04:09.210 --> 00:04:12.985
How many different
solutions are there?

00:04:12.985 --> 00:04:19.290
For [INAUDIBLE], this is mainly
about decision and enumeration.

00:04:19.290 --> 00:04:21.040
And this number
of gluings, that's

00:04:21.040 --> 00:04:23.540
the combinatorial problem.

00:04:23.540 --> 00:04:25.490
So it turns out, for
everything the we'll do,

00:04:25.490 --> 00:04:27.180
these two have the same answer.

00:04:27.180 --> 00:04:29.050
So I'm going to put
it in one column.

00:04:29.050 --> 00:04:30.430
But sometimes for
a decision, you

00:04:30.430 --> 00:04:33.740
can do it a little faster
than enumerating them.

00:04:33.740 --> 00:04:37.920
In particular, because
the number of gluings

00:04:37.920 --> 00:04:40.394
can be exponential.

00:04:40.394 --> 00:04:42.560
We saw last time that it
could actually be infinite.

00:04:42.560 --> 00:04:44.320
I'm going to fix
that, don't worry.

00:04:44.320 --> 00:04:45.700
We'll make it finite.

00:04:45.700 --> 00:04:47.940
And then the right
bound is exponential.

00:04:47.940 --> 00:04:50.760
There's upper and lower
bounds of two to the theta n.

00:04:54.833 --> 00:05:00.106
And also here, bounded
sharpness is interesting

00:05:00.106 --> 00:05:01.105
because it's polynomial.

00:05:04.490 --> 00:05:05.890
And so this is also polynomial.

00:05:18.600 --> 00:05:22.900
The one result here that
is not tight is this one.

00:05:22.900 --> 00:05:26.089
It's an open question whether
for the general setup, the most

00:05:26.089 --> 00:05:28.005
interesting scenario,
just give you a polygon,

00:05:28.005 --> 00:05:29.910
is there any gluing?

00:05:29.910 --> 00:05:32.860
The best algorithm we
know is exponential,

00:05:32.860 --> 00:05:35.250
even to decide whether
there's a gluing.

00:05:35.250 --> 00:05:37.270
So I put a star
there to say that.

00:05:37.270 --> 00:05:38.179
It is not tight.

00:05:38.179 --> 00:05:40.220
The open problem is, can
you do it in polynomial?

00:05:40.220 --> 00:05:46.090
I suspect yes, but we worked on
it a long time ago and failed.

00:05:46.090 --> 00:05:49.130
For the special case of
edge-to-edge gluings, which

00:05:49.130 --> 00:05:51.630
is when you only glue
whole edges of the polygons

00:05:51.630 --> 00:05:58.682
to other whole edges, there is
a n to the order one algorithm.

00:05:58.682 --> 00:06:00.640
You can think of this as
an edge-to-edge gluing

00:06:00.640 --> 00:06:02.360
if you imagine this
as being two edges.

00:06:02.360 --> 00:06:04.450
If I actually draw
a vertex there,

00:06:04.450 --> 00:06:06.284
then this is an
edge-to-edge gluing.

00:06:06.284 --> 00:06:08.450
And then there's a polynomial
algorithm to tell you,

00:06:08.450 --> 00:06:09.550
is there any folding?

00:06:12.310 --> 00:06:14.705
If you want to list all
of the gluings though,

00:06:14.705 --> 00:06:16.330
you need exponential
time because there

00:06:16.330 --> 00:06:18.870
can be exponentially many.

00:06:18.870 --> 00:06:21.250
But everything except
this one result

00:06:21.250 --> 00:06:22.936
is the best you could hope for.

00:06:22.936 --> 00:06:25.800
Bounded sharpness
is a natural sense

00:06:25.800 --> 00:06:29.310
in which this exponential
is kind of cheating.

00:06:29.310 --> 00:06:32.150
Let's see, let me tell you
about bounded sharpness.

00:06:42.420 --> 00:06:47.610
I want to bound how sharp an
angle can be in a polygon.

00:06:47.610 --> 00:06:50.530
This is a really sharp angle.

00:06:50.530 --> 00:07:00.120
If every angle-- is that
actually the sharpness I want?

00:07:00.120 --> 00:07:01.700
Actually, no.

00:07:01.700 --> 00:07:06.470
Sorry, I'm getting
inside out already.

00:07:06.470 --> 00:07:09.685
Actually, what I care
about are reflex vertices.

00:07:12.990 --> 00:07:16.010
I don't want to have a
super big angles here.

00:07:16.010 --> 00:07:20.410
So if every angle
is at least 360

00:07:20.410 --> 00:07:29.910
minus some epsilon--
for a constant epsilon--

00:07:29.910 --> 00:07:32.120
then I call my polygon
bounded sharpness.

00:07:34.640 --> 00:07:37.160
If your polygon has
bounded sharpness,

00:07:37.160 --> 00:07:40.320
we get a polynomial bound
on the number of gluings

00:07:40.320 --> 00:07:42.940
and a polynomial algorithm
to list all the gluings.

00:07:42.940 --> 00:07:46.350
This is really the sense in
which this is all practical.

00:07:46.350 --> 00:07:49.930
Give me a polygon that's going
to have some sharpest angle,

00:07:49.930 --> 00:07:53.160
call that the bound.

00:07:53.160 --> 00:07:55.790
If epsilon gets really tiny, if
your reflex angles get really

00:07:55.790 --> 00:07:58.850
close to 360, then
this bound will go up.

00:07:58.850 --> 00:08:04.340
But as long as you're not
too extreme, you're all set.

00:08:08.370 --> 00:08:11.850
I mean less than or
equal to, yes, thank you.

00:08:15.200 --> 00:08:17.015
Yeah, that would
be a weird polygon

00:08:17.015 --> 00:08:19.150
if all the angles were so big.

00:08:19.150 --> 00:08:21.270
I think that doesn't exist.

00:08:21.270 --> 00:08:24.540
So for example, convex polygons
always have bounded sharpness.

00:08:24.540 --> 00:08:28.250
Epsilon is 180 in
that situation.

00:08:28.250 --> 00:08:30.390
So, that's good.

00:08:34.120 --> 00:08:35.870
I told you about
edge-to-edge gluings.

00:08:35.870 --> 00:08:37.950
Just glue whole
edges to whole edges.

00:08:37.950 --> 00:08:41.049
What I haven't really told you
is how we made this finite,

00:08:41.049 --> 00:08:42.630
so let me go to that.

00:08:42.630 --> 00:08:45.290
And when I say
gluings here, I really

00:08:45.290 --> 00:08:52.580
mean a combinatorial
type of gluing,

00:08:52.580 --> 00:08:54.750
because we had rolling belts.

00:08:54.750 --> 00:08:59.796
So there were infinitely
many actual gluings,

00:08:59.796 --> 00:09:01.420
but I'm going to
think of most of those

00:09:01.420 --> 00:09:04.350
as being the same thing and
just distinguish essentially

00:09:04.350 --> 00:09:07.490
what the gluing tree looks
like combinatorially.

00:09:07.490 --> 00:09:09.336
So let me define that.

00:09:09.336 --> 00:09:15.190
The first part is what I call
the abstract gluing tree.

00:09:19.310 --> 00:09:22.070
So this is just what the
picture looks like in general.

00:09:22.070 --> 00:09:26.780
So for example, the one
over there-- the cube--

00:09:26.780 --> 00:09:31.010
combinatorially the
tree looks like this.

00:09:31.010 --> 00:09:35.620
It has four leaves and a kind
of wishbone configuration.

00:09:35.620 --> 00:09:38.150
So I'm not trying to measure
the lengths or anything, just

00:09:38.150 --> 00:09:43.580
that's the abstract
picture, no metric.

00:09:43.580 --> 00:09:46.570
And then the second
part is I'm going

00:09:46.570 --> 00:09:56.330
to specify which polygon
vertices and edges are where.

00:10:22.310 --> 00:10:25.310
And I'm going to specify that
at things called junctions.

00:10:25.310 --> 00:10:29.230
So in particular, at
leaves I want to say,

00:10:29.230 --> 00:10:32.740
oh this is vertex one.

00:10:32.740 --> 00:10:36.340
At places like this, where
three edges come together,

00:10:36.340 --> 00:10:39.570
I want to specify for each
one, oh this is vertex two,

00:10:39.570 --> 00:10:44.594
this is edge eight, this
is vertex 10, whatever.

00:10:44.594 --> 00:10:45.760
I'm making up these numbers.

00:10:45.760 --> 00:10:47.260
They don't necessarily
correspond,

00:10:47.260 --> 00:10:49.880
but they should appear in order
because this is the polygon

00:10:49.880 --> 00:10:52.190
after all, just
warped inside out.

00:10:55.670 --> 00:10:57.590
Also this one.

00:10:57.590 --> 00:11:01.330
Also, I didn't really draw
this picture big enough,

00:11:01.330 --> 00:11:03.950
but if I have two parts
of the gluing tree

00:11:03.950 --> 00:11:06.790
where a vertex glues
against something--

00:11:06.790 --> 00:11:09.600
it could be another vertex
or it could be an edge--

00:11:09.600 --> 00:11:12.250
I also consider those junctions.

00:11:12.250 --> 00:11:15.780
So junctions are going
to be all the vertices--

00:11:15.780 --> 00:11:17.850
the only exception is when
there's an edge gluing

00:11:17.850 --> 00:11:20.040
to an edge, I don't
consider that a junction

00:11:20.040 --> 00:11:22.081
because there's going to
be fairly many of those.

00:11:22.081 --> 00:11:23.260
I want there to be finite.

00:11:23.260 --> 00:11:25.550
So everything of
degree one, everything

00:11:25.550 --> 00:11:27.950
of degree three or
more, for degree two

00:11:27.950 --> 00:11:30.890
there has to be at
least one vertex.

00:11:30.890 --> 00:11:40.940
So degree not equal to 2,
or at least one vertex.

00:11:40.940 --> 00:11:42.310
Those are junctions.

00:11:42.310 --> 00:11:44.550
For each I'm going to
mark where they are.

00:11:44.550 --> 00:11:47.930
That's part of my abstract
gluing tree, specifying where

00:11:47.930 --> 00:11:49.680
the junctures are, how
they're configured.

00:11:49.680 --> 00:11:52.871
And then for each
one, wherever there's

00:11:52.871 --> 00:11:54.370
part of the polygon
coming together,

00:11:54.370 --> 00:11:56.982
I specify which vertex
or edge is coming there.

00:11:56.982 --> 00:11:58.440
Now when I specify
an edge, I don't

00:11:58.440 --> 00:12:01.340
say what point on the edge,
because that could be infinite.

00:12:01.340 --> 00:12:03.740
There could be a whole range
of points, there could be.

00:12:03.740 --> 00:12:06.990
We'll worry about that later.

00:12:06.990 --> 00:12:10.310
I just specify that
edge eight is there.

00:12:10.310 --> 00:12:12.840
So this is what I call
combinatorial type of gluing.

00:12:12.840 --> 00:12:15.680
And in this case, there are
only finitely many gluings,

00:12:15.680 --> 00:12:20.070
finitely many types, but
it can be exponential.

00:12:20.070 --> 00:12:22.540
It's still big, just
not quite as big.

00:12:33.620 --> 00:12:35.620
So just to get
warmed up a little,

00:12:35.620 --> 00:12:39.790
let's prove this exponential
upper bound that is only 2

00:12:39.790 --> 00:12:41.181
to the order n.

00:12:41.181 --> 00:12:42.680
That will in
particular convince you

00:12:42.680 --> 00:12:44.995
that there's only
finitely many of these,

00:12:44.995 --> 00:12:47.895
although I think that's probably
obvious that it's finite.

00:12:47.895 --> 00:12:50.020
It's conceivable it could
be more than exponential.

00:12:55.220 --> 00:12:57.664
This is not a particularly
exciting bound,

00:12:57.664 --> 00:12:59.580
but we're going to use
a lot of the same ideas

00:12:59.580 --> 00:13:03.170
in the other proofs, in
particular this one which

00:13:03.170 --> 00:13:04.655
is more interesting.

00:13:09.700 --> 00:13:15.380
I want to look at
leaves of my tree.

00:13:15.380 --> 00:13:20.630
And we have to remember back
to the previous lecture, who

00:13:20.630 --> 00:13:23.080
can be at the leaves?

00:13:23.080 --> 00:13:26.880
Well, if could be a vertex
or it could be an edge.

00:13:26.880 --> 00:13:29.230
When it was an edge, we
called it a fold point.

00:13:29.230 --> 00:13:31.240
When we folded in the
middle of an edge--

00:13:31.240 --> 00:13:35.390
so here's an edge of
the polygon and I end up

00:13:35.390 --> 00:13:39.030
subdividing it and gluing
the edge onto itself-- right

00:13:39.030 --> 00:13:41.710
there is 180 degrees
of curvature.

00:13:41.710 --> 00:13:44.520
Total amount of
curvature is 720,

00:13:44.520 --> 00:13:47.370
therefore I only
have-- I can't count,

00:13:47.370 --> 00:13:49.420
I'm jetlagged-- four of them.

00:13:49.420 --> 00:13:52.200
At most four fold points.

00:13:52.200 --> 00:13:54.560
Everybody else is a vertex.

00:13:54.560 --> 00:13:59.285
So if I have n vertices, I
have at most n plus 4 leaves.

00:14:03.880 --> 00:14:05.970
That's already feeling good.

00:14:05.970 --> 00:14:08.640
I pull a rabbit out
of a hat and tell you

00:14:08.640 --> 00:14:11.060
that if I have only
n plus 4 leaves,

00:14:11.060 --> 00:14:15.070
there are 2 to the order n
trees on that many leaves.

00:14:20.970 --> 00:14:25.580
Actually, I should be
a little more careful.

00:14:25.580 --> 00:14:28.560
If I can bound the number
of nodes in the tree,

00:14:28.560 --> 00:14:31.060
then I'll get an exponential
bound on the number of trees.

00:14:31.060 --> 00:14:34.039
And that will be part one,
the abstract gluing tree.

00:14:34.039 --> 00:14:36.580
But right now I have a bound on
the number of leaves, not the

00:14:36.580 --> 00:14:37.530
number of nodes.

00:14:37.530 --> 00:14:39.720
And there's a difference
here, because if you

00:14:39.720 --> 00:14:43.300
have a tree which has
a whole bunch of degree

00:14:43.300 --> 00:14:52.770
2 vertices, then that would be
bad, because I only have two

00:14:52.770 --> 00:14:55.770
leaves I have
arbitrarily many nodes.

00:14:55.770 --> 00:15:00.190
But every time I have one
of these degree 2 nodes,

00:15:00.190 --> 00:15:03.160
we already threw away
the degree 2 nodes that

00:15:03.160 --> 00:15:05.579
had no vertices at them, because
there are infinitely many

00:15:05.579 --> 00:15:06.870
of those and those don't count.

00:15:06.870 --> 00:15:12.340
So once we throw that away,
the only degree two junctions

00:15:12.340 --> 00:15:15.117
are the ones that have a vertex,
which is why-- these dots are

00:15:15.117 --> 00:15:17.200
supposed to be the actual
vertices of the polygon.

00:15:17.200 --> 00:15:19.530
So it might be an edge here,
it might be an edge there.

00:15:19.530 --> 00:15:21.660
There's at least one
vertex at each of them.

00:15:21.660 --> 00:15:25.460
So the total number of nodes
here is indeed order n.

00:15:25.460 --> 00:15:28.740
I mean, it's probably actually
at most n plus 4 again.

00:15:28.740 --> 00:15:31.470
But if we're sloppy you say,
well the number of leaves

00:15:31.470 --> 00:15:32.450
is at most n plus 4.

00:15:32.450 --> 00:15:37.310
The number of degree
2 nodes is at most n.

00:15:37.310 --> 00:15:39.290
Then there could be
some degree three nodes.

00:15:39.290 --> 00:15:41.440
It's also at most
n plus 4 in total,

00:15:41.440 --> 00:15:44.470
or n is all I care about.

00:15:44.470 --> 00:15:46.390
You could be more
careful and figure out

00:15:46.390 --> 00:15:47.340
what the consonant is.

00:15:47.340 --> 00:15:51.690
But we get from this,
this is order n nodes.

00:15:54.530 --> 00:15:57.470
And once you have that the tree
has a linear number of nodes,

00:15:57.470 --> 00:16:01.220
I'll tell you this is one of
the [? Kadhalan ?] problems,

00:16:01.220 --> 00:16:03.470
that there's only 2
the order n such trees.

00:16:03.470 --> 00:16:06.900
But that's only part one
of the combinatorial type

00:16:06.900 --> 00:16:07.600
of the gluing.

00:16:07.600 --> 00:16:10.580
We also have to worry about
which vertices are where.

00:16:13.540 --> 00:16:15.980
I want to show that that
is only exponential.

00:16:24.150 --> 00:16:29.110
So imagine at this
point you've fixed

00:16:29.110 --> 00:16:30.910
the combinatorial
structure of the tree,

00:16:30.910 --> 00:16:33.720
but you have no
idea what's what.

00:16:33.720 --> 00:16:37.430
So in particular,
at these points--

00:16:37.430 --> 00:16:41.450
and maybe also you've
defined some degree 2

00:16:41.450 --> 00:16:43.340
junctions, which you
know are supposed

00:16:43.340 --> 00:16:48.410
to have at least one vertex--
the first thing I want

00:16:48.410 --> 00:16:51.150
to specify is, for each
of these little dots that

00:16:51.150 --> 00:16:56.910
come together-- these are the
junctions-- is it a vertex,

00:16:56.910 --> 00:16:59.510
or is it an edge?

00:16:59.510 --> 00:17:01.570
So that's just binary
information for each one.

00:17:01.570 --> 00:17:03.220
I'll fill it in, say
if it's a vertex,

00:17:03.220 --> 00:17:05.900
I'll leave it open
if it's an edge.

00:17:05.900 --> 00:17:08.990
In fact, I know that at
most one edge comes together

00:17:08.990 --> 00:17:09.550
at any point.

00:17:09.550 --> 00:17:13.140
Otherwise, you'd have too
much material glued there.

00:17:13.140 --> 00:17:15.975
So maybe it looks
something like this.

00:17:15.975 --> 00:17:18.590
It could be a fold point,
maybe another fold point.

00:17:22.640 --> 00:17:24.040
Something like that.

00:17:24.040 --> 00:17:26.755
So that coloring, black
and white, there's only 2

00:17:26.755 --> 00:17:30.030
to the order and such colorings.

00:17:30.030 --> 00:17:36.240
Call it a vertex edge
coloring, because again there's

00:17:36.240 --> 00:17:37.940
order n dots.

00:17:37.940 --> 00:17:41.870
Each one, there's two choices,
black or white, vertex or edge.

00:17:45.610 --> 00:17:47.720
And now what we
really care about

00:17:47.720 --> 00:17:50.360
is where the vertices,
because remember, this

00:17:50.360 --> 00:17:53.330
is the polygon in order.

00:17:53.330 --> 00:17:57.600
So if I could tell you, let's
say which vertex is vertex one?

00:17:57.600 --> 00:18:00.990
Maybe this vertex is vertex one.

00:18:00.990 --> 00:18:04.240
Then I know this is vertex two,
I know this is vertex three,

00:18:04.240 --> 00:18:06.310
I know this is edge
three or whichever

00:18:06.310 --> 00:18:09.600
edge connects V3 three and V4.

00:18:09.600 --> 00:18:11.690
This is also edge
three, and so on.

00:18:11.690 --> 00:18:15.210
I could just walk around
and label them in order.

00:18:15.210 --> 00:18:18.380
All I needed to do is
know where vertex one is.

00:18:18.380 --> 00:18:21.680
There's only n
possibilities for that.

00:18:28.040 --> 00:18:31.540
There's n filled circles, which
are where the vertices are.

00:18:31.540 --> 00:18:34.910
One of them is V1, so there's
only n choices for it.

00:18:34.910 --> 00:18:40.340
You multiply all of these
things together, n times 2

00:18:40.340 --> 00:18:42.390
to the order n, times
2 to the order n,

00:18:42.390 --> 00:18:44.670
that result is 2 to
the some other order n.

00:18:47.320 --> 00:18:50.380
That's total number of choices.

00:18:50.380 --> 00:18:55.059
So that's a rough
but fine upper bound.

00:18:55.059 --> 00:18:56.850
I'm not going to try
to tune this constant.

00:18:56.850 --> 00:18:57.970
I guess it would
be an open problem

00:18:57.970 --> 00:18:59.761
to get a really good
bound on the constant.

00:18:59.761 --> 00:19:01.840
I'm not sure if even
one has been worked out,

00:19:01.840 --> 00:19:04.660
but what I will show you is
that this is pretty much tight,

00:19:04.660 --> 00:19:07.140
so you can't hope to do
much better than this

00:19:07.140 --> 00:19:10.750
because there's a 2 to
the omega n lower bound

00:19:10.750 --> 00:19:14.455
on the number of gluings.

00:19:17.220 --> 00:19:21.170
And that is this crazy example.

00:19:21.170 --> 00:19:24.860
I'll draw it also on the board.

00:19:24.860 --> 00:19:26.410
It's a little tricky to draw.

00:19:26.410 --> 00:19:32.500
It's a very spiky star,
something like that.

00:19:32.500 --> 00:19:45.090
So I have e points, and n
spikes, n convex corners.

00:19:45.090 --> 00:19:47.420
The convex angle,
I think, is alpha.

00:19:47.420 --> 00:19:49.772
Let me match the notation.

00:19:49.772 --> 00:19:52.060
Yes, convex angle is alpha.

00:19:52.060 --> 00:19:56.060
The reflex angle here is
beta, but otherwise it's

00:19:56.060 --> 00:19:57.020
completely symmetric.

00:19:57.020 --> 00:19:59.530
So all the reflex
angles are beta,

00:19:59.530 --> 00:20:01.616
all the convex angles are alpha.

00:20:01.616 --> 00:20:03.630
I have n spikes.

00:20:03.630 --> 00:20:09.730
I want these points--
it's hard to draw,

00:20:09.730 --> 00:20:13.450
but I want them to be very,
very close to the center.

00:20:13.450 --> 00:20:14.920
Take the limit.

00:20:14.920 --> 00:20:18.680
In the limit, alpha is 0.

00:20:18.680 --> 00:20:23.835
So alpha is going to be some
very tiny amount epsilon.

00:20:23.835 --> 00:20:24.335
Beta.

00:20:27.280 --> 00:20:30.690
What's the limit of beta?

00:20:30.690 --> 00:20:32.920
180, 360?

00:20:32.920 --> 00:20:35.080
No, it's not 360.

00:20:35.080 --> 00:20:36.160
That's what's important.

00:20:39.210 --> 00:20:44.520
360 times 1 minus
1 over n, yeah.

00:20:44.520 --> 00:20:46.680
It's like 360 minus 360 over n.

00:20:51.050 --> 00:20:54.170
Believe it or not,
this is a big number,

00:20:54.170 --> 00:20:56.380
in that it doesn't
depend on epsilon.

00:20:56.380 --> 00:21:00.599
So it's going to be, what,
a little bit smaller--

00:21:00.599 --> 00:21:02.140
going to be some
minus epsilon prime.

00:21:02.140 --> 00:21:04.170
But I really don't care
about the epsilons.

00:21:04.170 --> 00:21:06.620
They're kind of irrelevant.

00:21:06.620 --> 00:21:10.140
Let me just cross them out,
but they're really there.

00:21:10.140 --> 00:21:17.180
So alpha is basically 0, beta
is a chunk less than 360.

00:21:17.180 --> 00:21:22.120
What this means is in the limit
I can take one of these alphas

00:21:22.120 --> 00:21:25.147
and glue it into
one of the betas,

00:21:25.147 --> 00:21:26.605
and it will still
be less than 360.

00:21:26.605 --> 00:21:29.270
In fact I could
glue n of the alpha.

00:21:29.270 --> 00:21:34.017
I could glue all of these
spikes into one of these gaps.

00:21:34.017 --> 00:21:35.975
Remember, the limiting
picture looks like this.

00:21:39.062 --> 00:21:40.270
That's maybe more convincing.

00:21:40.270 --> 00:21:42.520
It doesn't look that way here.

00:21:42.520 --> 00:21:43.940
This is nothing.

00:21:43.940 --> 00:21:47.380
Of course, I can fit arbitrarily
many of them into this gap

00:21:47.380 --> 00:21:50.750
and it will still
sum to less than 360.

00:21:50.750 --> 00:21:54.200
So this is kind of the key
to why this example works.

00:21:56.960 --> 00:22:00.740
I've got tons a room for alphas
in the complement of betas.

00:22:04.680 --> 00:22:09.390
Now, I would like to make
this not only an exponential

00:22:09.390 --> 00:22:11.700
lower bound on the
general case, but also

00:22:11.700 --> 00:22:13.960
on the edge-to-edge
case, because that's

00:22:13.960 --> 00:22:16.460
a little bit stronger to say
even edge-to-edge gluings there

00:22:16.460 --> 00:22:17.880
can be exponentially many.

00:22:17.880 --> 00:22:21.860
To do that, I'm going to
take the midpoint of one

00:22:21.860 --> 00:22:24.600
of the edges, call
that a vertex,

00:22:24.600 --> 00:22:29.590
and take the perimeter antipode,
which is like here hopefully,

00:22:29.590 --> 00:22:30.404
more or less.

00:22:30.404 --> 00:22:32.570
So I want the left parameter
and the right perimeter

00:22:32.570 --> 00:22:35.930
to be equal, also
call that a vertex.

00:22:35.930 --> 00:22:38.351
And now one thing we know how
to do is perimeter halving.

00:22:38.351 --> 00:22:40.850
Now, we were only supposed to
do perimeter halving on convex

00:22:40.850 --> 00:22:43.850
polygons, but it turns out it
will work on this polygon too.

00:22:43.850 --> 00:22:46.826
So I'm going to glue this
half edge to this half edge,

00:22:46.826 --> 00:22:48.950
then I'm going to glue this
edge to this edge, then

00:22:48.950 --> 00:22:51.770
this one to this one, and so on.

00:22:51.770 --> 00:22:54.550
So just do that gluing.

00:22:54.550 --> 00:22:58.660
And the only thing
to worry about

00:22:58.660 --> 00:23:00.350
is that you glue
two betas together.

00:23:00.350 --> 00:23:01.940
That would be more than 360.

00:23:01.940 --> 00:23:05.680
Anything else, beta to any
number of alpha's is OK.

00:23:05.680 --> 00:23:09.344
At this point it is really
helpful to draw a gluing tree,

00:23:09.344 --> 00:23:10.830
so let me do that.

00:23:25.410 --> 00:23:30.560
So gluing tree for
perimeter halving is path.

00:23:30.560 --> 00:23:35.224
And do I give these guys
names, probably x and y?

00:23:35.224 --> 00:23:37.110
Yeah, that's what
I would call them,

00:23:37.110 --> 00:23:40.580
so naturally that's
what I called them.

00:23:40.580 --> 00:23:44.350
We have x over here,
we have y over here.

00:23:44.350 --> 00:23:46.690
And then we have the
perimeter in between.

00:23:46.690 --> 00:23:48.420
So let's just
check what happens.

00:23:48.420 --> 00:23:51.090
Here we get an
alpha on one side--

00:23:51.090 --> 00:23:54.805
I'm going to say the right
side is the bottom, let's say.

00:23:54.805 --> 00:23:56.430
I'm not going to try
to think about it.

00:23:56.430 --> 00:24:00.695
So there's an alpha,
and that meets a beta.

00:24:00.695 --> 00:24:02.320
And then it just
alternates from there.

00:24:02.320 --> 00:24:05.850
There's an alpha, it meets a
beta, but on the other side.

00:24:05.850 --> 00:24:09.400
And a beta meets
an alpha and so on.

00:24:09.400 --> 00:24:14.940
At the end, it's probably the
reverse, like alpha, beta.

00:24:14.940 --> 00:24:19.200
I've drawn it up
here at the very top.

00:24:19.200 --> 00:24:23.560
The alpha's red, betas are black
so you can distinguish them.

00:24:23.560 --> 00:24:26.340
But that's clearly an OK gluing
because it's just one alpha

00:24:26.340 --> 00:24:27.180
gluing to one beta.

00:24:27.180 --> 00:24:31.040
We know we can glue tons
of alphas into one beta.

00:24:31.040 --> 00:24:32.097
That's one gluing.

00:24:32.097 --> 00:24:33.930
The fun part is that
there are exponentially

00:24:33.930 --> 00:24:38.500
many of these gluings which look
like this, where you take some

00:24:38.500 --> 00:24:43.080
of the betas and turn
them into leaves,

00:24:43.080 --> 00:24:45.610
kind of squeeze them out.

00:24:45.610 --> 00:24:48.430
And the result is that
you get two alphas gluing

00:24:48.430 --> 00:24:50.720
to a beta, which is fine.

00:24:50.720 --> 00:24:52.630
The beta glues to
itself, which is fine.

00:24:52.630 --> 00:24:54.470
I mean, it's a vertex.

00:24:54.470 --> 00:24:58.060
It's comforting that it
has an angle almost 360.

00:24:58.060 --> 00:25:00.800
Therefore, there's very little
curvature out at that leaf,

00:25:00.800 --> 00:25:02.670
but we don't really
need to check that.

00:25:02.670 --> 00:25:06.060
It is just necessary
for this to work.

00:25:06.060 --> 00:25:10.560
Of course, beta is less
than 360 by itself.

00:25:10.560 --> 00:25:12.720
Here's an example where I
squeezed two of the betas

00:25:12.720 --> 00:25:15.270
right next to each
other, then three alpha's

00:25:15.270 --> 00:25:18.130
come together and
glue to a beta.

00:25:18.130 --> 00:25:21.480
But what's nice is we don't
have to think about the polygon.

00:25:21.480 --> 00:25:23.020
We just think about
the gluing tree.

00:25:23.020 --> 00:25:28.450
And we say, well if
I pull this down-- so

00:25:28.450 --> 00:25:31.530
I end up with
that-- that's going

00:25:31.530 --> 00:25:34.550
to be just fine as long as
I also pull one on the top.

00:25:34.550 --> 00:25:36.900
I have to squeeze the
same number of betas

00:25:36.900 --> 00:25:38.400
on the top and the
bottom, otherwise

00:25:38.400 --> 00:25:39.820
these links won't match up.

00:25:39.820 --> 00:25:43.690
As long as I do that,
I get a valid gluing.

00:25:43.690 --> 00:25:49.990
So what I'm going to do,
I have n betas total.

00:25:49.990 --> 00:25:55.300
So I have n over
2 betas on the top

00:25:55.300 --> 00:25:59.650
and n over 2 betas
on the bottom.

00:25:59.650 --> 00:26:08.020
I'm going to squeeze n over
4 on the top and n over 4

00:26:08.020 --> 00:26:10.510
on the bottom, so half of them.

00:26:16.160 --> 00:26:18.520
That way the lengths
will match up,

00:26:18.520 --> 00:26:22.130
and I happen to know there's
a lot of ways to do this.

00:26:22.130 --> 00:26:27.620
The actual number is n over
2 choose n over 4 for the top

00:26:27.620 --> 00:26:28.950
and the same for the bottom.

00:26:28.950 --> 00:26:31.760
So it's this
squared, and I'm just

00:26:31.760 --> 00:26:33.960
going to tell you that
is 2 to the theta n.

00:26:37.140 --> 00:26:42.090
Actually, I think you
can be pretty precise.

00:26:42.090 --> 00:26:43.150
Can you?

00:26:43.150 --> 00:26:44.510
I've forgotten.

00:26:44.510 --> 00:26:50.410
Isn't n choose n over
2-- it's very close to 2

00:26:50.410 --> 00:26:53.104
to the n over 2, I believe.

00:26:53.104 --> 00:26:55.660
Is that right?

00:26:55.660 --> 00:26:58.010
But not exactly, yeah.

00:26:58.010 --> 00:27:00.181
All right, I'm
going to be sloppy.

00:27:00.181 --> 00:27:01.760
It's 2 to the theta n.

00:27:01.760 --> 00:27:03.860
You could figure out what
the constant is there.

00:27:03.860 --> 00:27:09.450
I think I have a bound
written down, maybe.

00:27:09.450 --> 00:27:11.980
Oh, it is the power of 2, yeah.

00:27:11.980 --> 00:27:14.675
It is equal, I believe,
according to my notes.

00:27:17.990 --> 00:27:21.470
So this is going
to be 2 to the n

00:27:21.470 --> 00:27:25.415
over 4 squared, which is
2 to the n over 2 exactly.

00:27:30.250 --> 00:27:30.844
Yeah?

00:27:30.844 --> 00:27:31.760
AUDIENCE: [INAUDIBLE]?

00:27:37.260 --> 00:27:39.930
PROFESSOR: I only am allowed
to squeeze betas, not alphas.

00:27:39.930 --> 00:27:42.650
But I can do whatever pattern I
want on the top and separately

00:27:42.650 --> 00:27:45.150
any pattern I want
on the bottom.

00:27:45.150 --> 00:27:47.100
Because what's key
is by squeezing

00:27:47.100 --> 00:27:51.350
betas I preserve the parity,
because when I squeeze away

00:27:51.350 --> 00:27:53.280
a beta I bring two
alphas together.

00:27:53.280 --> 00:27:56.089
So the parity and who's matching
whom on the top and the bottom

00:27:56.089 --> 00:27:56.880
is always the same.

00:27:56.880 --> 00:27:58.220
And the beta on
the top will always

00:27:58.220 --> 00:28:00.270
be matching some number
of alpha's on the bottom,

00:28:00.270 --> 00:28:01.887
and vice versa.

00:28:01.887 --> 00:28:03.970
So it doesn't matter what
pattern I do on the top,

00:28:03.970 --> 00:28:05.360
or what pattern I
do on the bottom.

00:28:05.360 --> 00:28:07.110
It just matters they
have the same length,

00:28:07.110 --> 00:28:09.987
so I arbitrarily chose
them to both be n over 4.

00:28:09.987 --> 00:28:11.570
Well, it wasn't
arbitrary, but I chose

00:28:11.570 --> 00:28:12.790
it to be that
because I knew there

00:28:12.790 --> 00:28:13.960
would be a lot of those choices.

00:28:13.960 --> 00:28:15.043
There are more, of course.

00:28:15.043 --> 00:28:18.680
Really I should sum this
over all choices of n over 4,

00:28:18.680 --> 00:28:21.200
but this is good enough.

00:28:21.200 --> 00:28:23.325
That summation would not
improve the bound by much.

00:28:30.870 --> 00:28:32.340
So that's sort of the bad news.

00:28:32.340 --> 00:28:33.910
These are really nasty polygons.

00:28:33.910 --> 00:28:35.960
They have exponentially
many gluings.

00:28:35.960 --> 00:28:43.640
For fun, we actually
did this for small n.

00:28:43.640 --> 00:28:45.230
It's been a while.

00:28:45.230 --> 00:28:48.440
This was some time ago
that we made all these.

00:28:48.440 --> 00:28:50.260
I think it actually
was before 2002,

00:28:50.260 --> 00:28:52.980
but that was when
the paper appeared.

00:28:52.980 --> 00:28:56.390
So here is a four
star, and these

00:28:56.390 --> 00:28:59.430
are I think all of
the possible gluings.

00:28:59.430 --> 00:29:01.650
Maybe just some of
them, it's been awhile,

00:29:01.650 --> 00:29:02.960
I could think about it.

00:29:05.815 --> 00:29:07.940
Not drawn as gluing trees
here, but drawn as actual

00:29:07.940 --> 00:29:08.898
gulings on the polygon.

00:29:08.898 --> 00:29:10.820
Here instead of
drawing the gluings

00:29:10.820 --> 00:29:13.280
on the outside, which
is how they happen

00:29:13.280 --> 00:29:15.404
in the gluing three, I've
drawn them on the inside,

00:29:15.404 --> 00:29:16.870
just because it's
easier to draw.

00:29:16.870 --> 00:29:18.530
And then we built
them in the same way

00:29:18.530 --> 00:29:20.988
that I built one like I showed
you last time, where we just

00:29:20.988 --> 00:29:24.030
took a polygon, started
taping edges together,

00:29:24.030 --> 00:29:27.740
and these are the
roughly taped versions.

00:29:27.740 --> 00:29:30.122
And then you guess where
the crease signs are,

00:29:30.122 --> 00:29:32.080
and then you can draw
the crease lines on here.

00:29:32.080 --> 00:29:34.142
And two of them
are drawn sort of

00:29:34.142 --> 00:29:36.350
worked out where exactly
the crease lines have to be,

00:29:36.350 --> 00:29:40.030
according to getting all
the edge links to match.

00:29:40.030 --> 00:29:41.600
And then you can
make your polygons.

00:29:41.600 --> 00:29:47.082
That is n equals 4,
then we did n equals 8.

00:29:47.082 --> 00:29:49.165
I guess we want n to be
even here for convenience.

00:29:51.750 --> 00:29:54.740
And there's more, although
still not a huge number.

00:29:54.740 --> 00:30:01.410
I think these are the top sides
and these are the bottom sides.

00:30:01.410 --> 00:30:03.700
And you can see, in some
cases it was a little tricky

00:30:03.700 --> 00:30:05.700
to tell where the creases
are, because they were

00:30:05.700 --> 00:30:08.130
almost flat or possibly
actually exactly flat.

00:30:08.130 --> 00:30:10.060
Like here they are flat.

00:30:10.060 --> 00:30:11.540
But it's a fun exercise.

00:30:11.540 --> 00:30:14.097
You can, whenever you
have these gluings,

00:30:14.097 --> 00:30:15.180
reconstruct the polyhedra.

00:30:15.180 --> 00:30:18.180
Of course now that we have
algorithms for Alexandroff's

00:30:18.180 --> 00:30:21.230
theorem, we could try plugging
these into the programs

00:30:21.230 --> 00:30:26.290
and they should give us exact 3D
polyhedra, from which we could

00:30:26.290 --> 00:30:29.252
figure out where the
crease lines are.

00:30:29.252 --> 00:30:32.640
It would be a fun, small,
mini-project, I guess,

00:30:32.640 --> 00:30:33.290
to do that.

00:30:33.290 --> 00:30:34.900
This is all from ages ago.

00:30:37.800 --> 00:30:44.140
At this point I want to move
on to this result, which

00:30:44.140 --> 00:30:44.910
is the good news.

00:30:44.910 --> 00:30:47.118
This is sort of bad news
that there are exponentially

00:30:47.118 --> 00:30:49.910
many different gluings.

00:30:49.910 --> 00:30:52.425
It's not so bad in that at
least we can enumerate them

00:30:52.425 --> 00:30:53.550
in the same amount of time.

00:30:53.550 --> 00:30:54.934
We'll get to that later.

00:30:54.934 --> 00:30:56.600
While we're in the
combinatorial streak,

00:30:56.600 --> 00:30:58.380
I want to prove
that there's only

00:30:58.380 --> 00:31:00.790
a polynomial number
of combinatorially

00:31:00.790 --> 00:31:04.250
distinct gluings for
bounded sharpness polygons.

00:31:04.250 --> 00:31:07.050
So of course, this
star polygon does not

00:31:07.050 --> 00:31:08.510
have bounded sharpness.

00:31:08.510 --> 00:31:14.160
We set beta to be very,
very close to 360.

00:31:14.160 --> 00:31:16.830
It may be worth talking
about this a little bit,

00:31:16.830 --> 00:31:21.020
because it wasn't exactly 360.

00:31:21.020 --> 00:31:24.870
It was bounded away from 360 by
this value of 360 divided by n.

00:31:24.870 --> 00:31:26.910
Now I said that
was a big number,

00:31:26.910 --> 00:31:30.680
because it was much,
much bigger than alpha.

00:31:30.680 --> 00:31:32.780
Bigger than n times
alpha even, because I

00:31:32.780 --> 00:31:35.410
can make alpha very close to 0.

00:31:35.410 --> 00:31:37.420
But it is not what we
call bounded sharpness.

00:31:37.420 --> 00:31:41.120
Bounded sharpness was 360
minus a constant-- I really

00:31:41.120 --> 00:31:44.070
shouldn't have called it
epsilon because it's confusing.

00:31:44.070 --> 00:31:47.540
Let me call it gamma just
got another Greek letter.

00:31:50.310 --> 00:31:51.810
Gamma is not arbitrarily small.

00:31:51.810 --> 00:31:56.780
It is a constant value, whereas
over here it's not constant.

00:31:56.780 --> 00:32:00.640
It's a constant divided
by n, that's sub-constant.

00:32:00.640 --> 00:32:03.740
So this is not bounded
sharpness, just to check.

00:32:03.740 --> 00:32:07.830
But if we have all the
reflex angles, at most 360

00:32:07.830 --> 00:32:10.410
minus an actual
constant bigger than 0,

00:32:10.410 --> 00:32:12.400
then we can get a
polynomial bound

00:32:12.400 --> 00:32:15.740
on the number of combinatorially
distinct gluings.

00:32:15.740 --> 00:32:17.167
So let me show that to you.

00:32:43.494 --> 00:32:45.410
Here's the cool thing
about bounded sharpness.

00:32:53.190 --> 00:32:57.100
How many leaves can
the gluing tree have?

00:32:57.100 --> 00:33:01.150
Each leaf is either an edge,
like it's a fold point.

00:33:01.150 --> 00:33:05.120
In that case, the
curvature is 180 degrees.

00:33:05.120 --> 00:33:07.310
Or it's a vertex.

00:33:07.310 --> 00:33:12.050
If it's a vertex, the
curvature at that point

00:33:12.050 --> 00:33:16.094
is 360 minus the
angle at that point.

00:33:16.094 --> 00:33:22.020
360 minus the angle,
let's call it alpha.

00:33:22.020 --> 00:33:24.980
Now, we know that every
angle alpha is at most 360

00:33:24.980 --> 00:33:27.040
minus gamma.

00:33:27.040 --> 00:33:35.470
So if this is going to be
at least 360 minus gamma,

00:33:35.470 --> 00:33:36.390
which is just gamma.

00:33:39.070 --> 00:33:43.540
So every vertex, every
leaf of the tree,

00:33:43.540 --> 00:33:46.370
has curvature at least gamma.

00:33:46.370 --> 00:33:48.100
Gamma is a constant.

00:33:48.100 --> 00:33:58.450
Total curvature is 720, exactly.

00:33:58.450 --> 00:34:05.150
Therefore, the number
of leaves is at most 720

00:34:05.150 --> 00:34:09.480
over gamma, which is a constant.

00:34:12.880 --> 00:34:14.780
That's going to help.

00:34:14.780 --> 00:34:18.625
We don't have to worry
about trees with n leaves.

00:34:18.625 --> 00:34:20.000
We only have to
worry about trees

00:34:20.000 --> 00:34:23.679
with 20 leaves, some
constant number of leaves.

00:34:23.679 --> 00:34:28.090
Again, as the bound on sharpness
goes down, the number of leaves

00:34:28.090 --> 00:34:31.560
will go up in this
inverse proportional way,

00:34:31.560 --> 00:34:33.690
but it's a constant.

00:34:33.690 --> 00:34:37.400
So at least for part
one, we're golden.

00:34:37.400 --> 00:34:39.370
I mean, the number
of gluing trees,

00:34:39.370 --> 00:34:43.060
I said over here-- where is it?

00:34:43.060 --> 00:34:45.440
If I have n nodes
in my tree, I'll

00:34:45.440 --> 00:34:48.900
only have 2 to
the order n trees.

00:34:48.900 --> 00:34:51.090
So if I can reduce the
number of nodes in my tree,

00:34:51.090 --> 00:34:53.173
I will reduce the number
of trees correspondingly.

00:34:56.940 --> 00:34:59.000
If there's only a
constant number of nodes,

00:34:59.000 --> 00:35:00.983
there will be a constant
number of trees.

00:35:00.983 --> 00:35:03.880
It doesn't matter that a
constant gets exponentiated,

00:35:03.880 --> 00:35:06.520
it'll still be constant.

00:35:06.520 --> 00:35:08.570
So that's good news,
except we bounded again

00:35:08.570 --> 00:35:11.410
the number of leaves,
not the number of nodes.

00:35:11.410 --> 00:35:14.460
So we have to be a
little bit careful,

00:35:14.460 --> 00:35:23.240
because in particular we can
have degree 2 junctions, which

00:35:23.240 --> 00:35:25.400
are real junctions--
they might look like this

00:35:25.400 --> 00:35:27.820
where a vertex comes to an edge.

00:35:27.820 --> 00:35:30.100
There's got to be
about n of those,

00:35:30.100 --> 00:35:32.250
because the vertices
have to be somewhere.

00:35:32.250 --> 00:35:36.150
We're saying there aren't
very many at the leaves.

00:35:36.150 --> 00:35:38.580
And therefore, at the degree
three and higher junctions,

00:35:38.580 --> 00:35:40.559
there can't be very many.

00:35:40.559 --> 00:35:42.100
Maybe I haven't said
this, but if you

00:35:42.100 --> 00:35:44.150
have a tree with
L leaves, you'll

00:35:44.150 --> 00:35:49.210
only have at most L internal
nodes, branching nodes.

00:35:49.210 --> 00:35:52.710
But degree two nodes, there
could be arbitrarily many.

00:35:52.710 --> 00:35:59.510
So what we come to is, if
I have L leaves in a tree,

00:35:59.510 --> 00:36:03.055
then I'll only get 2
to the order L gluings.

00:36:03.055 --> 00:36:04.305
This is what we need to prove.

00:36:08.622 --> 00:36:10.080
It will tell us
that in particular,

00:36:10.080 --> 00:36:11.770
if we have a constant
number of leaves,

00:36:11.770 --> 00:36:14.730
as comes from the
bounded sharpens case,

00:36:14.730 --> 00:36:17.900
I will get-- constant
number of gluings?

00:36:17.900 --> 00:36:20.480
That's not right.

00:36:20.480 --> 00:36:25.020
There's some polynomial
on n times 2 to the order

00:36:25.020 --> 00:36:31.280
L. Ah, that's why.

00:36:36.090 --> 00:36:38.060
I should look at my
notes occasionally.

00:36:38.060 --> 00:36:39.940
The right bound to
n to the order L.

00:36:39.940 --> 00:36:43.210
In fact, what I wrote
is an open problem.

00:36:43.210 --> 00:36:48.420
I think maybe it's n to the
order 1 times 2 to the order L.

00:36:48.420 --> 00:36:52.386
This is what you'd call a fixed
parameter tractable bound,

00:36:52.386 --> 00:36:53.760
but no such upper
bound is known.

00:36:53.760 --> 00:36:55.926
That might be fun to work
on in the problem session.

00:36:55.926 --> 00:36:58.250
It might not be difficult,
just at the time

00:36:58.250 --> 00:37:00.000
I didn't know those
bounds were important.

00:37:03.070 --> 00:37:05.720
So we still have
to prove this, n

00:37:05.720 --> 00:37:15.840
to the order L. This is the
part where my notes are wrong.

00:37:21.207 --> 00:37:23.290
Here's the idea, we have
a small number of leaves,

00:37:23.290 --> 00:37:26.200
we're worried about
these degree 2 junctions.

00:37:26.200 --> 00:37:30.420
But I claim, actually
there isn't a lot going on.

00:37:33.690 --> 00:37:35.550
Because one of the
great things we can do,

00:37:35.550 --> 00:37:38.890
over here we said for
every dot, was it a vertex

00:37:38.890 --> 00:37:39.715
or was it an edge?

00:37:42.640 --> 00:37:46.490
We can't afford that anymore,
because there's n dots still.

00:37:46.490 --> 00:37:48.880
We can't afford
2 to the order n.

00:37:48.880 --> 00:37:51.680
Where we can afford it is at
the leaves, because there's only

00:37:51.680 --> 00:37:55.220
L of those, and at
the branching nodes.

00:37:55.220 --> 00:37:59.320
So everything except
these degree 2 problems

00:37:59.320 --> 00:38:00.580
we could specify.

00:38:00.580 --> 00:38:03.180
And really we could
specify anything we want.

00:38:03.180 --> 00:38:07.040
So yeah, we could specify, is
it a vertex or is it an edge?

00:38:07.040 --> 00:38:12.644
But we could make
life even easier-- hm,

00:38:12.644 --> 00:38:14.800
I have an idea for
solving this open problem.

00:38:14.800 --> 00:38:17.530
Do I want to solve it right now?

00:38:17.530 --> 00:38:18.520
Yeah, let's do it.

00:38:22.610 --> 00:38:25.126
Let me think for a second.

00:38:25.126 --> 00:38:26.910
I think that's going to work.

00:38:26.910 --> 00:38:29.160
OK, cool, cool.

00:38:29.160 --> 00:38:31.240
I needed to rewrite
these notes anyway,

00:38:31.240 --> 00:38:34.560
so I might as well
prove a stronger result.

00:38:34.560 --> 00:38:36.600
All right, so let
me draw a picture.

00:38:42.287 --> 00:38:44.870
There's branching nodes, and I
surely draw one of these longer

00:38:44.870 --> 00:38:47.300
so I can say, oh there's some
degree two junctions here.

00:38:47.300 --> 00:38:49.640
Those are annoying,
ignore those.

00:38:49.640 --> 00:38:52.950
For everything else-- the
leaves and the branching

00:38:52.950 --> 00:38:56.530
nodes-- I'm going to specify
the same binary thing.

00:38:56.530 --> 00:38:58.990
Is it a vertex,
or is it an edge?

00:38:58.990 --> 00:39:02.160
But now there's only
order L of them.

00:39:02.160 --> 00:39:05.610
There's L leaves, so there's at
most L minus 1 internal nodes.

00:39:05.610 --> 00:39:09.710
Each of them has some
degree, but the total number

00:39:09.710 --> 00:39:14.510
of these dots will be order
L if I ignore the degree 2.

00:39:14.510 --> 00:39:23.320
So that's 2 to the order
L vertex edge colorings,

00:39:23.320 --> 00:39:30.570
just like before
except now with L,

00:39:30.570 --> 00:39:37.420
of leaves and branching nodes.

00:39:37.420 --> 00:39:39.023
Oh, I see the problem.

00:39:39.023 --> 00:39:39.523
Darn it.

00:39:44.730 --> 00:39:48.240
What I'd like to do is mimic
the same proof and say, well

00:39:48.240 --> 00:39:53.141
choose where V1 is and then
just label them around.

00:39:53.141 --> 00:39:54.640
There's a problem
with that, though.

00:39:54.640 --> 00:39:55.530
Say V1 is here.

00:39:58.460 --> 00:39:59.840
Where's V2?

00:39:59.840 --> 00:40:02.430
Well, maybe this is an
edge, maybe this is an edge.

00:40:02.430 --> 00:40:03.960
This, I have no idea.

00:40:03.960 --> 00:40:05.030
Is it an edge?

00:40:05.030 --> 00:40:06.310
Is it a vertex?

00:40:06.310 --> 00:40:07.860
I can't tell.

00:40:07.860 --> 00:40:11.230
At degree 2 junctions,
I have a problem.

00:40:11.230 --> 00:40:13.770
That's kind of annoying.

00:40:13.770 --> 00:40:18.670
To fix that-- and so this is
still going to be open, alas.

00:40:18.670 --> 00:40:23.870
To fix that I need to-- I
really want to know which dot

00:40:23.870 --> 00:40:28.090
is which vertex for
reasons to be determined.

00:40:28.090 --> 00:40:30.750
But in particular, that
is part of number two.

00:40:33.980 --> 00:40:41.460
So I'm just going to give
up and say, well there's

00:40:41.460 --> 00:40:45.805
2n different things that they
could be, n vertices and edges.

00:40:48.940 --> 00:40:52.230
Do I want to do it that way?

00:40:52.230 --> 00:40:57.830
Maybe n choose order L. I'm
just going to write down

00:40:57.830 --> 00:41:01.790
wherever I have a filled dot--
I guess this one is not filled.

00:41:01.790 --> 00:41:04.191
Maybe this one's filled, filled.

00:41:04.191 --> 00:41:06.690
I just going to write down,
what is the vertex number there?

00:41:06.690 --> 00:41:17.480
This is maybe V3, V5,
V20, V21, whatever,

00:41:17.480 --> 00:41:19.490
for each of the filled
dots among the vertices

00:41:19.490 --> 00:41:23.850
that I can see, ignoring again
the degree two junctions.

00:41:23.850 --> 00:41:26.965
There's order L of them.

00:41:26.965 --> 00:41:31.041
I just going to for each one
pick out one of the labels.

00:41:31.041 --> 00:41:33.000
Again, the order is
determined, so this

00:41:33.000 --> 00:41:34.560
is the right number of them.

00:41:34.560 --> 00:41:40.270
And this is n to
the order L at most.

00:41:40.270 --> 00:41:42.187
So this is where I'm
being a bit wasteful.

00:41:42.187 --> 00:41:44.270
It would be interesting
to try to get around that.

00:41:47.300 --> 00:41:49.455
This was actual
vertex labelings.

00:41:56.040 --> 00:41:59.200
So now, among the
vertices I can see--

00:41:59.200 --> 00:42:02.490
the degree three
junctions, and the leaves,

00:42:02.490 --> 00:42:05.069
and higher degree
junctions-- I know

00:42:05.069 --> 00:42:06.360
which vertices are glued there.

00:42:06.360 --> 00:42:10.325
I can also figure out
which edges are glued there

00:42:10.325 --> 00:42:14.716
by similar labeling, although
I don't think I actually care.

00:42:14.716 --> 00:42:19.610
No, I probably care, because
it's part of number 2.

00:42:19.610 --> 00:42:23.110
So I do have to also label
the open circles which

00:42:23.110 --> 00:42:25.150
edge is there.

00:42:25.150 --> 00:42:28.890
But a similar bound holds.

00:42:28.890 --> 00:42:29.405
What's left?

00:42:33.560 --> 00:42:35.676
What's left are the
degree 2 vertices.

00:42:35.676 --> 00:42:37.050
I don't know
anything about them.

00:42:40.690 --> 00:42:47.330
This is particularly tricky
when I have some edge here.

00:42:47.330 --> 00:42:49.190
But let's first
think about the case

00:42:49.190 --> 00:42:53.990
where I have a
vertex, add a leaf,

00:42:53.990 --> 00:42:58.140
and I have these
degree two junctions.

00:42:58.140 --> 00:43:01.392
And I don't know which edge
is here, which vertex is here.

00:43:01.392 --> 00:43:03.100
In this case, because
everything's small,

00:43:03.100 --> 00:43:04.350
I might be able to figure out.

00:43:04.350 --> 00:43:07.960
But here, where's the
V3 to V4 transition?

00:43:07.960 --> 00:43:10.900
Could be here, or
it could be here.

00:43:10.900 --> 00:43:13.040
It could be here.

00:43:13.040 --> 00:43:16.330
I can't afford to figure it out.

00:43:16.330 --> 00:43:20.720
Fortunately, I don't
have to figure it out.

00:43:20.720 --> 00:43:21.580
It's not so obvious.

00:43:21.580 --> 00:43:23.920
From this picture you
can't see what's going on,

00:43:23.920 --> 00:43:26.520
but this came from a polygon.

00:43:26.520 --> 00:43:30.290
This is an actual vertex,
this is an actual vertex.

00:43:30.290 --> 00:43:37.450
So this edge length is the
total perimeter from V3 to V5

00:43:37.450 --> 00:43:39.690
along the polygon.

00:43:39.690 --> 00:43:43.040
I know how long that is.

00:43:43.040 --> 00:43:48.760
So also if that was
going clockwise from V3

00:43:48.760 --> 00:43:50.322
around the polygon--
actually, that's

00:43:50.322 --> 00:43:52.030
probably counter-clockwise
in the polygon

00:43:52.030 --> 00:43:53.420
because everything's inside out.

00:43:53.420 --> 00:43:57.255
If I go the other way--
let's be relative-- from V3,

00:43:57.255 --> 00:44:00.560
I can measure out
the same length.

00:44:00.560 --> 00:44:02.520
So in fact, I have
some polygon-- maybe

00:44:02.520 --> 00:44:04.050
it looks like this, whatever.

00:44:04.050 --> 00:44:11.270
I go from V3 to V5, and I
measure out that length.

00:44:11.270 --> 00:44:14.470
And I go the other
way from V3, and I

00:44:14.470 --> 00:44:17.910
know this is getting
glued to that.

00:44:17.910 --> 00:44:23.770
So I know where the vertices
are from the lengths.

00:44:23.770 --> 00:44:26.270
I can figure out exactly
what this picture must

00:44:26.270 --> 00:44:28.314
be when I have-- in
this case, I happen

00:44:28.314 --> 00:44:30.230
to maybe get a vertex
going to another vertex.

00:44:30.230 --> 00:44:34.310
In general, probably get some
vertex gluing to some edge,

00:44:34.310 --> 00:44:35.992
and maybe vice versa.

00:44:35.992 --> 00:44:38.200
But if I can figure out
exactly what that pattern is,

00:44:38.200 --> 00:44:42.660
I can figure out the
label of these guys,

00:44:42.660 --> 00:44:46.015
because I know exactly
what's happening there.

00:44:46.015 --> 00:44:46.640
So that's good.

00:44:46.640 --> 00:44:54.920
If it's a vertex to vertex edge
in the gluing tree like this,

00:44:54.920 --> 00:44:58.460
I can figure out everything
between that pair.

00:45:08.486 --> 00:45:10.737
Is that enough?

00:45:10.737 --> 00:45:11.236
Almost.

00:45:17.800 --> 00:45:22.116
So if I have a leaf where
this is a vertex, which

00:45:22.116 --> 00:45:26.260
I was usually denoting
by a filled circle,

00:45:26.260 --> 00:45:27.700
I have various
degree 2 junctions

00:45:27.700 --> 00:45:31.500
which I ignore until I get
to a degree three or higher

00:45:31.500 --> 00:45:33.600
junction.

00:45:33.600 --> 00:45:37.420
Now at this place,
even just looking

00:45:37.420 --> 00:45:40.990
at this dot and this dot,
I know at least one of them

00:45:40.990 --> 00:45:41.830
must be a vertex.

00:45:41.830 --> 00:45:45.440
Because I can't glue two edges
together plus other stuff.

00:45:45.440 --> 00:45:46.610
I can glue at most one edge.

00:45:46.610 --> 00:45:48.810
So maybe this one's an
edge, like in the picture

00:45:48.810 --> 00:45:50.360
that we did before.

00:45:50.360 --> 00:45:51.830
But one of them
has to be a vertex.

00:45:51.830 --> 00:45:54.770
And then I can figure out
exactly what's happening there,

00:45:54.770 --> 00:45:56.720
because I have this
vertex to vertex thing.

00:45:56.720 --> 00:45:57.770
And I know the labels.

00:45:57.770 --> 00:46:01.884
I know this is V5 and
this is V13, whatever.

00:46:01.884 --> 00:46:04.050
I know exactly what's
happening on the right side, I

00:46:04.050 --> 00:46:05.560
measure backwards, I
know exactly what's

00:46:05.560 --> 00:46:07.770
happening on the left side
and who's going to what.

00:46:07.770 --> 00:46:10.350
So that determines everything.

00:46:10.350 --> 00:46:15.910
The problem is when
I have an edge here,

00:46:15.910 --> 00:46:18.370
because then I don't know
where it is along the edge.

00:46:18.370 --> 00:46:20.917
I can't measure lengths
anymore, somewhere

00:46:20.917 --> 00:46:22.000
in the middle of the edge.

00:46:24.890 --> 00:46:33.010
And indeed, if I have
something like this,

00:46:33.010 --> 00:46:35.690
where all of these angles--
I mean this for example

00:46:35.690 --> 00:46:41.030
is in a convex polygon, this
could be a perimeter halving--

00:46:41.030 --> 00:46:43.520
and it's not determined
what's happening here

00:46:43.520 --> 00:46:46.860
because this is a rolling belt.

00:46:46.860 --> 00:46:48.730
I'll show you how
undetermined it is.

00:46:48.730 --> 00:46:52.110
Suppose you have a bunch
of vertices like this,

00:46:52.110 --> 00:46:58.690
and then some
vertices like this.

00:46:58.690 --> 00:47:02.970
Depending on where I
bend around for E5,

00:47:02.970 --> 00:47:04.950
these guys could be here.

00:47:04.950 --> 00:47:07.980
They could be here,
or here, or here.

00:47:07.980 --> 00:47:12.720
They could be in the
middle straddling this.

00:47:12.720 --> 00:47:17.720
In fact, there are about
n squared different places

00:47:17.720 --> 00:47:20.780
where these guys could be,
relative to these guys.

00:47:20.780 --> 00:47:24.370
Because there's going to be n
transitions from-- if this is n

00:47:24.370 --> 00:47:28.500
and this is n-- n transitions
from this versus that guy,

00:47:28.500 --> 00:47:30.880
then n transitions from
these versus that guy,

00:47:30.880 --> 00:47:35.530
n transitions versus that
guy, total of about n squared.

00:47:35.530 --> 00:47:39.440
Actually if this is n and this
is n, it's exactly n squared.

00:47:39.440 --> 00:47:41.690
So we're not quite
done, but I claim

00:47:41.690 --> 00:47:44.220
that there's really only
order n squared left.

00:47:44.220 --> 00:47:46.020
It's always from
the rolling belts.

00:47:46.020 --> 00:47:51.370
We know from last time there's
at most three rolling belts,

00:47:51.370 --> 00:47:54.050
so at most quadratic per belt.

00:47:54.050 --> 00:47:59.660
So total outcome is
polynomial for what's

00:47:59.660 --> 00:48:02.980
left, what we haven't specified,
for how the degree 2 vertices

00:48:02.980 --> 00:48:03.520
behave.

00:48:03.520 --> 00:48:05.710
These are all
degree 2 junctions.

00:48:05.710 --> 00:48:09.676
It's here, or they're
here, we don't know.

00:48:09.676 --> 00:48:13.040
So if you want to get the full
specification of what's where,

00:48:13.040 --> 00:48:14.657
you do all this work.

00:48:14.657 --> 00:48:16.240
And then for the
degree two junctions,

00:48:16.240 --> 00:48:18.712
you have to deal with
the rolling belts.

00:48:18.712 --> 00:48:20.170
The way to prove
this is say, well,

00:48:20.170 --> 00:48:23.190
if I have a leaf that's a
vertex, I can get rid of it

00:48:23.190 --> 00:48:24.510
and induct.

00:48:24.510 --> 00:48:27.020
In the end, I'll have
at most four leaves

00:48:27.020 --> 00:48:29.440
because there's at
most four fold points.

00:48:29.440 --> 00:48:32.810
So I have a constant
number of leaves.

00:48:32.810 --> 00:48:34.400
You look at each
belt, each of them

00:48:34.400 --> 00:48:40.020
is quadratic and polynomial.

00:48:40.020 --> 00:48:41.870
If you work out the
bounds here-- we've

00:48:41.870 --> 00:48:43.670
tried to be a little
more precise--

00:48:43.670 --> 00:48:49.880
you could prove an overall
bound of n to the 2L minus 2

00:48:49.880 --> 00:48:50.580
for L leaves.

00:48:53.220 --> 00:48:56.330
And we have slightly better
bounds for L equals 4

00:48:56.330 --> 00:49:02.370
and L equals 3, but
that's pretty good.

00:49:02.370 --> 00:49:05.910
But the proof I gave is
at least n to the order L.

00:49:05.910 --> 00:49:09.770
We could n to the order L
count different things here,

00:49:09.770 --> 00:49:12.210
and then some N to the
constant at the end.

00:49:18.200 --> 00:49:20.330
This ends the
combinatorial part.

00:49:20.330 --> 00:49:22.820
Now we're going to
get to algorithms.

00:49:22.820 --> 00:49:25.420
So we've proved all
of these things.

00:49:25.420 --> 00:49:27.070
Exponential upper
and lower bounds

00:49:27.070 --> 00:49:29.290
for the general case
and edge-to-edge case,

00:49:29.290 --> 00:49:32.800
and polynomial for
bounded sharpness,

00:49:32.800 --> 00:49:35.750
or when you have a reasonable
number of leaves in your tree.

00:50:08.300 --> 00:50:14.940
I'm going to start with this
edge-to-edge gluing algorithm.

00:50:32.140 --> 00:50:39.350
This is going to use a technique
called dynamic programming,

00:50:39.350 --> 00:50:43.590
which some of you have seen
before, some of you haven't.

00:50:43.590 --> 00:50:45.190
It's a very simple idea.

00:50:45.190 --> 00:50:46.720
You take your
problem that you want

00:50:46.720 --> 00:50:48.900
to solve-- which is
I have a polygon--

00:50:48.900 --> 00:50:52.146
and you split it up
into sub-problems.

00:50:52.146 --> 00:50:54.830
You solve each of
the sub-problems,

00:50:54.830 --> 00:50:57.570
and one of the sub-problems
is actually the whole problem,

00:50:57.570 --> 00:50:59.500
and then you're done.

00:50:59.500 --> 00:51:02.080
In our case, a
sub-problem is going

00:51:02.080 --> 00:51:05.950
to be some sub-chain
from one vertex

00:51:05.950 --> 00:51:09.250
to another vertex
of the polygon.

00:51:15.680 --> 00:51:18.640
So I have some
polygon, and I just

00:51:18.640 --> 00:51:26.060
look at some interval of
the boundary from VI to VJ.

00:51:26.060 --> 00:51:31.730
And the idea is, well suppose
that VI is glued to VJ.

00:51:31.730 --> 00:51:34.070
How many different
ways, or how should I

00:51:34.070 --> 00:51:35.170
glue the part in between?

00:51:38.540 --> 00:51:40.549
How should I glue
this into itself?

00:51:40.549 --> 00:51:42.090
Because there's no
crossings, there's

00:51:42.090 --> 00:51:45.900
going to be no gluings
from inside to outside.

00:51:45.900 --> 00:51:47.510
So that's the sub-problem.

00:51:47.510 --> 00:51:53.700
And of course if I say from
the interval from V1 to V1,

00:51:53.700 --> 00:51:55.500
that is the entire problem.

00:51:55.500 --> 00:51:57.440
Of course V1 is glued to V1.

00:51:57.440 --> 00:52:02.980
So in particular, the
V1 to V1 sub-problem

00:52:02.980 --> 00:52:05.740
is what we want to solve.

00:52:05.740 --> 00:52:08.549
So this is our goal.

00:52:08.549 --> 00:52:10.090
So I'm going to tell
you how to solve

00:52:10.090 --> 00:52:11.756
all of these sub-problems,
and therefore

00:52:11.756 --> 00:52:13.960
how to solve what we
actually want to solve.

00:52:13.960 --> 00:52:17.530
That's dynamic programming.

00:52:17.530 --> 00:52:22.992
So let's try to solve one of
these sub-problems, VI to VJ.

00:52:22.992 --> 00:52:24.200
How are we going to solve it?

00:52:27.710 --> 00:52:31.900
So I'm going to draw a picture.

00:52:31.900 --> 00:52:33.789
It looks like this.

00:52:33.789 --> 00:52:35.580
This is now thinking
about the gluing tree,

00:52:35.580 --> 00:52:39.070
so the polygon's on
the outside here.

00:52:39.070 --> 00:52:41.960
That's one of the main reasons
gluing trees were developed,

00:52:41.960 --> 00:52:43.450
just to describe this algorithm.

00:52:43.450 --> 00:52:45.540
This algorthim's
actually quite old,

00:52:45.540 --> 00:52:49.030
1996 by [INAUDIBLE]
and [INAUDIBLE].

00:52:49.030 --> 00:52:51.970
The edge-to-edge case was
before I joined this group.

00:52:51.970 --> 00:52:55.104
And then later together
we did the general case,

00:52:55.104 --> 00:52:57.145
unbounded sharpness, which
is what we'll do next.

00:52:59.737 --> 00:53:01.320
So this is at the
heart of everything.

00:53:01.320 --> 00:53:04.170
So we have VO to
VJ glued together.

00:53:04.170 --> 00:53:07.620
We want to know how to
glue together the rest.

00:53:07.620 --> 00:53:11.290
Well, maybe some vertices
get glued in here in addition

00:53:11.290 --> 00:53:15.890
to VI and VJ, maybe not.

00:53:15.890 --> 00:53:18.610
Let's think about what
gets glued to this edge.

00:53:18.610 --> 00:53:21.629
There's the edge
from VI to VI plus 1.

00:53:21.629 --> 00:53:23.420
And this is an edge-to-edge
gluing, so what

00:53:23.420 --> 00:53:25.280
gets glued there
is an actual edge.

00:53:27.790 --> 00:53:28.820
What edge could it be?

00:53:28.820 --> 00:53:33.256
Some edge over here, I
don't know which one.

00:53:33.256 --> 00:53:34.950
The power of the
dynamic programming

00:53:34.950 --> 00:53:36.330
is you don't need to know.

00:53:36.330 --> 00:53:41.490
It's some edge, VK, VK
plus 1 gets glued there.

00:53:44.920 --> 00:53:47.710
There's only one of them,
it's out there somewhere.

00:53:47.710 --> 00:53:49.406
It has to have
matching edge length,

00:53:49.406 --> 00:53:51.280
but there could be many
choices, all of which

00:53:51.280 --> 00:53:52.363
have matching edge length.

00:53:52.363 --> 00:53:54.220
Maybe all the edge
lengths are the same,

00:53:54.220 --> 00:54:05.550
but there's at most n
choices for that edge.

00:54:05.550 --> 00:54:08.940
It's actually at most J
minus I choices plus 1.

00:54:08.940 --> 00:54:12.716
But there's at most
n edges in here,

00:54:12.716 --> 00:54:14.590
so there's at most n
different possibilities.

00:54:14.590 --> 00:54:16.820
Just try them all.

00:54:16.820 --> 00:54:18.640
Think about all of them.

00:54:18.640 --> 00:54:20.910
I haven't said here whether
I'm doing-- or I have?

00:54:20.910 --> 00:54:22.962
I guess I've been pointing here.

00:54:22.962 --> 00:54:25.170
I really want to do both of
these algorithms at once,

00:54:25.170 --> 00:54:28.210
but I'll start with this
one, which is just find

00:54:28.210 --> 00:54:30.130
all the gluings in
exponential time, which

00:54:30.130 --> 00:54:31.880
is optimal in the worst
case because there

00:54:31.880 --> 00:54:33.296
can be exponentially
many outputs.

00:54:37.330 --> 00:54:41.020
So try all n choices
for VK VK plus 1.

00:54:41.020 --> 00:54:43.410
What happens when
I do one of them?

00:54:43.410 --> 00:54:44.570
I might choose one of them.

00:54:49.570 --> 00:55:00.190
Well, the new picture will
be-- so the topological picture

00:55:00.190 --> 00:55:03.400
is I still have VI glued to VJ.

00:55:06.000 --> 00:55:13.020
Then I also have here VK and
VI plus 1 glued together.

00:55:13.020 --> 00:55:18.339
And I have VI also
glued to VK plus 1.

00:55:18.339 --> 00:55:20.130
Now it's possible
actually VK plus 1 and VJ

00:55:20.130 --> 00:55:22.864
are the same thing, in which
case there's no loop here.

00:55:22.864 --> 00:55:24.530
And that's the case
when no extra vertex

00:55:24.530 --> 00:55:25.710
got glued in there.

00:55:25.710 --> 00:55:29.266
But this is the
generic situation.

00:55:29.266 --> 00:55:33.140
If this is link 0, then
these guys are the same.

00:55:33.140 --> 00:55:36.530
So really what I have now are
two different sub-problems.

00:55:36.530 --> 00:55:41.520
There's this thing, which
is VI plus 1, dot, dot, VK.

00:55:41.520 --> 00:55:45.685
And there's this one which
is VK plus 1 dot, dot, VJ.

00:55:48.760 --> 00:55:50.370
The idea with the
sub-problems is

00:55:50.370 --> 00:55:52.120
to solve the
sub-problems in order

00:55:52.120 --> 00:55:54.540
by increasing chain length.

00:55:54.540 --> 00:55:57.020
So start with very short ones.

00:55:57.020 --> 00:55:59.860
And I saw longer and longer
ones using the previous results.

00:55:59.860 --> 00:56:02.160
If I've already
computed the answers

00:56:02.160 --> 00:56:04.976
to VK plus 1 to VJ
because that is smaller

00:56:04.976 --> 00:56:06.350
than the original--
look, there's

00:56:06.350 --> 00:56:08.480
two edges fewer at least.

00:56:08.480 --> 00:56:11.130
This thing is at least 2
smaller than the original chain

00:56:11.130 --> 00:56:12.720
because here's two edges.

00:56:12.720 --> 00:56:14.520
So I wanted to solve VI to VJ.

00:56:14.520 --> 00:56:17.690
I guessed what VK
to VK plus 1 was,

00:56:17.690 --> 00:56:20.174
meaning I tried all the
possibilities for each one.

00:56:20.174 --> 00:56:22.340
I say, well what are all
the possibilities for this?

00:56:22.340 --> 00:56:24.620
What are all the
possibilities for this?

00:56:24.620 --> 00:56:26.340
Take the cross-product.

00:56:26.340 --> 00:56:28.500
Just multiply those
sets together.

00:56:28.500 --> 00:56:30.750
Those are all the
possible gluings.

00:56:30.750 --> 00:56:32.050
And then I sum that.

00:56:32.050 --> 00:56:38.380
I take all the options for
all the different values of K.

00:56:38.380 --> 00:56:40.010
And that's it.

00:56:40.010 --> 00:56:44.024
That output is all
the possible gluings.

00:56:44.024 --> 00:56:45.690
So this should actually
give another way

00:56:45.690 --> 00:56:47.600
to prove that the number
of different gluings

00:56:47.600 --> 00:56:51.960
is only exponential, but this is
just for the edge-to-edge case.

00:56:55.710 --> 00:56:58.270
Maybe I should write that down.

00:56:58.270 --> 00:57:10.020
So we have for each
choice of K output--

00:57:10.020 --> 00:57:18.660
let's say, and for each
solution to the smaller

00:57:18.660 --> 00:57:21.280
sub-problem VK plus 1 to VJ.

00:57:21.280 --> 00:57:36.187
And then for each solution
to VK plus 1 to VK output.

00:57:36.187 --> 00:57:37.020
This is very simple.

00:57:37.020 --> 00:57:40.190
This is just a product
over various things.

00:57:40.190 --> 00:57:45.610
There's only order
n choices here.

00:57:45.610 --> 00:57:47.690
This thing, it depends
how many solutions there

00:57:47.690 --> 00:57:51.860
are to those sub-problems, but
it's the product of the two.

00:57:51.860 --> 00:57:56.970
And then that's
the total output.

00:57:56.970 --> 00:58:00.050
Believe me, this runs
in exponential time.

00:58:00.050 --> 00:58:01.726
That's not very hard to prove.

00:58:01.726 --> 00:58:03.100
What's interesting
is we can make

00:58:03.100 --> 00:58:06.830
the same algorithm with
a little bit of tweaking

00:58:06.830 --> 00:58:09.280
get a polynomial time
decision algorithm.

00:58:12.080 --> 00:58:14.010
That's cool.

00:58:14.010 --> 00:58:18.170
How do we make it a
polynomial decision algorithm?

00:58:18.170 --> 00:58:21.350
I can't afford to store every
solution for every sub-problem

00:58:21.350 --> 00:58:23.220
because there can be
exponentially many.

00:58:23.220 --> 00:58:26.555
So I only get to store one
solution for every sub-problem.

00:58:29.280 --> 00:58:30.470
So this is the great idea.

00:58:36.370 --> 00:58:55.830
Let's say for each sub-problem,
let's say VI to VK only store

00:58:55.830 --> 00:59:01.990
the solution that
minimizes the amount

00:59:01.990 --> 00:59:04.170
of stuff glued into VI VJ.

00:59:10.260 --> 00:59:17.440
So the sum of the
angles glued at VI,

00:59:17.440 --> 00:59:22.190
which is the same thing as
VJ because they are already

00:59:22.190 --> 00:59:24.270
glued together.

00:59:24.270 --> 00:59:25.810
That's what we were told.

00:59:25.810 --> 00:59:27.840
So I had many choices here.

00:59:27.840 --> 00:59:31.080
I had all the choices for
K. I had all the choices

00:59:31.080 --> 00:59:32.054
for up here.

00:59:32.054 --> 00:59:33.470
I had all the
choices for up here.

00:59:33.470 --> 00:59:36.011
Well actually now I'm just going
to think about one choice up

00:59:36.011 --> 00:59:38.190
here, which is what
is the choice that

00:59:38.190 --> 00:59:40.600
minimizes the angle glued here?

00:59:40.600 --> 00:59:42.260
And what is the
choice over here that

00:59:42.260 --> 00:59:44.650
minimizes the angle glued there?

00:59:44.650 --> 00:59:45.800
Why the minimum?

00:59:45.800 --> 00:59:48.140
Because some of these are wrong.

00:59:48.140 --> 00:59:52.270
I should actually say
output if it's Alexandroff.

00:59:52.270 --> 00:59:54.490
We only want to output
Alexandroff gluings.

00:59:54.490 --> 00:59:56.050
We only want to
output gluings where

00:59:56.050 --> 00:59:58.530
the total sum of the angles
is less than or equal to 360.

00:59:58.530 --> 01:00:03.070
I need to check
that for every one.

01:00:03.070 --> 01:00:06.260
If I want to have the most
chance of it being Alexandroff,

01:00:06.260 --> 01:00:09.020
if I got the least possible
angle glued here and glued

01:00:09.020 --> 01:00:11.530
here, that's my best
hope of it working.

01:00:11.530 --> 01:00:14.700
Now I still have flexibility,
which is I get to choose k.

01:00:14.700 --> 01:00:17.580
There's still n choices
for k, but everything else

01:00:17.580 --> 01:00:19.510
is determined at that point.

01:00:19.510 --> 01:00:23.730
Once I fix K I see, well
does this work, yes or no?

01:00:23.730 --> 01:00:26.560
If it works, that
gives me one candidate

01:00:26.560 --> 01:00:28.719
for how much material
gets glued here.

01:00:28.719 --> 01:00:30.260
It could be a lot,
could be a little.

01:00:30.260 --> 01:00:33.480
I try for all K, I
take the smallest one.

01:00:33.480 --> 01:00:37.010
So it's the same loop, except
there's no four loops here.

01:00:37.010 --> 01:00:38.750
It's just for every
choice of K, I

01:00:38.750 --> 01:00:42.490
look at the solution to VK plus
1 to VJ, the solution for VI

01:00:42.490 --> 01:00:43.860
plus 1 to VK.

01:00:43.860 --> 01:00:46.250
If it's Alexandroff,
I don't output it.

01:00:46.250 --> 01:00:50.710
But I check, is it the best
solution so far in terms

01:00:50.710 --> 01:00:55.150
of the total angle
glued of VI and VJ.

01:00:55.150 --> 01:00:57.720
I keep looping until I
find the very best one,

01:00:57.720 --> 01:00:59.600
and I output that one.

01:00:59.600 --> 01:01:03.550
That would be the
solution that I store.

01:01:03.550 --> 01:01:08.700
The result is, the running
time is actually polynomial,

01:01:08.700 --> 01:01:12.930
because the number of
sub-problems-- a sub-problem

01:01:12.930 --> 01:01:14.880
is determined by two vertices.

01:01:14.880 --> 01:01:16.800
There's only n of
these, n of these.

01:01:16.800 --> 01:01:21.040
So the number of
sub-problems is n squared.

01:01:21.040 --> 01:01:28.540
For each sub-problem I need to
look at order n choices for K.

01:01:28.540 --> 01:01:31.270
And so the total
running time is n

01:01:31.270 --> 01:01:37.950
squared times n,
which is n cubed.

01:01:37.950 --> 01:01:39.630
And that will tell
you if there's

01:01:39.630 --> 01:01:42.120
any hope of anything
working, if there's

01:01:42.120 --> 01:01:46.980
any gluing this will find
one, because it's always

01:01:46.980 --> 01:01:53.842
trying to minimize the angles
that get glued together

01:01:53.842 --> 01:01:54.800
That's is edge-to-edge.

01:02:00.030 --> 01:02:01.520
Now we can generalize.

01:02:01.520 --> 01:02:04.790
It's a little bit
messy, but we can

01:02:04.790 --> 01:02:07.060
generalize to arbitrary gluings.

01:02:12.770 --> 01:02:15.150
Let me sketch a little
bit how that goes.

01:02:22.030 --> 01:02:27.450
So we've seen now this result
for algorithms and this result

01:02:27.450 --> 01:02:28.800
for algorithms.

01:02:28.800 --> 01:02:31.000
And now I'm going to tell
you about this result.

01:02:31.000 --> 01:02:33.170
I wish there was a result
here to tell you about,

01:02:33.170 --> 01:02:33.921
but there isn't.

01:02:33.921 --> 01:02:36.420
So this last part that I did
where the decision algorithm is

01:02:36.420 --> 01:02:39.160
very efficient, we don't
know how to generalize that

01:02:39.160 --> 01:02:42.065
to the general case,
arbitrary gluings.

01:02:42.065 --> 01:02:43.440
This only works
for edge-to-edge.

01:02:43.440 --> 01:02:46.060
We assumed a whole
edge, VK VK plus 1

01:02:46.060 --> 01:02:49.480
was glued to VI VI plus 1.

01:02:49.480 --> 01:02:52.190
But the enumeration
part where we said,

01:02:52.190 --> 01:02:53.810
oh just give me
all the solutions,

01:02:53.810 --> 01:02:55.100
that we can get to work.

01:02:55.100 --> 01:02:58.250
It's just slightly
more complicated.

01:02:58.250 --> 01:03:04.770
Let me tell you how it
gets more complicated.

01:03:04.770 --> 01:03:10.930
So one difference is that there
are more kinds of sub-problems,

01:03:10.930 --> 01:03:12.930
this is the heart
of the problem.

01:03:12.930 --> 01:03:18.510
We have the VI to VJ sub-problem
just like before, that's easy.

01:03:18.510 --> 01:03:23.550
And then we have the
VI to EJ sub-problem.

01:03:23.550 --> 01:03:28.830
So this one was VI was glued to
VJ, very clear what that means.

01:03:28.830 --> 01:03:33.455
Here we have VI is
glued to an edge EJ.

01:03:36.190 --> 01:03:39.880
The trouble with that is we
don't know where on the edge

01:03:39.880 --> 01:03:41.200
it's glued.

01:03:41.200 --> 01:03:45.220
It's somewhere on the edge.

01:03:45.220 --> 01:03:48.200
This is where
things get trickier.

01:03:48.200 --> 01:03:49.750
And there's also
the symmetric case,

01:03:49.750 --> 01:03:51.805
of course, where it's EI to VJ.

01:03:51.805 --> 01:03:53.430
But we don't really
need to worry about

01:03:53.430 --> 01:03:54.305
that, it's symmetric.

01:04:02.670 --> 01:04:05.080
So what does a
solution look like?

01:04:09.310 --> 01:04:12.560
So before, a solution
was an entire gluing.

01:04:12.560 --> 01:04:15.602
Now, because the
gluings can be infinite.

01:04:15.602 --> 01:04:17.560
There can be infinitely
many different gluings.

01:04:17.560 --> 01:04:20.050
I can't actually list
every one explicitly.

01:04:20.050 --> 01:04:22.140
I've actually got to
explain ranges of gluings

01:04:22.140 --> 01:04:24.880
if I have any hope of
capturing all of them.

01:04:24.880 --> 01:04:28.050
So what a solution
is going to look like

01:04:28.050 --> 01:04:40.226
is the combinatorial type of the
gluing, which was this stuff.

01:04:40.226 --> 01:04:41.600
You have an abstract
gluing tree,

01:04:41.600 --> 01:04:43.770
you get which vertices
glue to what edges.

01:04:43.770 --> 01:04:45.930
So you have pretty
much the whole picture,

01:04:45.930 --> 01:04:49.710
just not exactly where each
vertex is glued to which edge.

01:04:49.710 --> 01:04:55.010
Then I also will tell
you a total angle

01:04:55.010 --> 01:05:05.822
of material glued at VI so far.

01:05:05.822 --> 01:05:07.280
In both these cases,
I want to know

01:05:07.280 --> 01:05:11.320
how much stuff in
my gluing at VI

01:05:11.320 --> 01:05:14.500
so I can tell whether
it's Alexandroff.

01:05:14.500 --> 01:05:22.760
And then in the case where I
glue a vertex to an edge, what

01:05:22.760 --> 01:05:24.760
I'm going to do is
give you an interval.

01:05:28.535 --> 01:05:33.020
The Interval's always
going to be starting at 0,

01:05:33.020 --> 01:05:38.260
and going to some
value x. x is less than

01:05:38.260 --> 01:05:42.815
or equal to the length
of the edge, VJ.

01:05:46.510 --> 01:05:50.420
And this is the interval along
the edge where VI can glue.

01:05:53.510 --> 01:05:55.790
So I'm going to tell
you an actual interval

01:05:55.790 --> 01:06:00.320
here from the edge EJ.

01:06:00.320 --> 01:06:02.420
As long as you glue VI
to somewhere between

01:06:02.420 --> 01:06:04.810
there and there,
this stuff works.

01:06:04.810 --> 01:06:06.980
Whatever I specified
works over there.

01:06:06.980 --> 01:06:08.330
You can't go beyond some point.

01:06:15.897 --> 01:06:17.230
That will turn out to be enough.

01:06:32.420 --> 01:06:39.750
So while there's the VI to VJ
case, it's less interesting.

01:06:39.750 --> 01:06:43.110
Let's think about now if
I want to actually solve

01:06:43.110 --> 01:06:50.075
the VI to EJ case.

01:06:53.370 --> 01:06:55.130
What could happen?

01:06:55.130 --> 01:06:57.620
Before there was
only one-- we looked

01:06:57.620 --> 01:07:02.200
at what glues VI to VI
plus 1 and it was one edge.

01:07:02.200 --> 01:07:05.149
It was a little
easier to think about.

01:07:05.149 --> 01:07:06.690
Let's not think
about the whole edge,

01:07:06.690 --> 01:07:11.410
but let's think about locally
what happens just after VI.

01:07:11.410 --> 01:07:13.480
Something gets glued there.

01:07:13.480 --> 01:07:15.999
Now it could be EJ
actually gets glued there.

01:07:15.999 --> 01:07:17.290
It could be we continue gluing.

01:07:17.290 --> 01:07:19.380
That's kind of like
zipping, although not

01:07:19.380 --> 01:07:21.650
exactly what we were
calling zipping before.

01:07:21.650 --> 01:07:27.200
Here I call it
zipping, good choice.

01:07:27.200 --> 01:07:30.620
So one option is that you
zip for a little while.

01:07:30.620 --> 01:07:32.440
Now, how long would you zip?

01:07:32.440 --> 01:07:33.930
A couple options.

01:07:33.930 --> 01:07:35.760
You zip until you
hit a vertex, you

01:07:35.760 --> 01:07:38.240
can't stop in the
middle of two edges.

01:07:38.240 --> 01:07:40.160
So maybe you hit a
vertex here first,

01:07:40.160 --> 01:07:41.630
maybe you hit a
vertex here first,

01:07:41.630 --> 01:07:44.520
and the next vertex
here is farther away.

01:07:44.520 --> 01:07:46.450
So there's two pictures.

01:07:46.450 --> 01:07:48.841
Let me draw the two pictures.

01:07:48.841 --> 01:07:51.205
It could be hit you
hit VI plus 1 first.

01:07:56.320 --> 01:07:58.690
So here's EJ.

01:07:58.690 --> 01:08:04.020
It could be you hit
the vertex of EJ first.

01:08:11.330 --> 01:08:13.380
In this case, you
get a sub-problem

01:08:13.380 --> 01:08:16.550
which is VI plus 1 to EJ.

01:08:16.550 --> 01:08:18.910
These are glued to each other.

01:08:18.910 --> 01:08:21.560
In this case, you get
this vertex, which I think

01:08:21.560 --> 01:08:28.830
is VJ gets glued to the
edge EI, which is just

01:08:28.830 --> 01:08:33.460
the symmetric case I
was talking about here.

01:08:33.460 --> 01:08:37.319
Edge EI is glued to Vertex VJ.

01:08:37.319 --> 01:08:38.819
So those are smaller
sub-problems.

01:08:38.819 --> 01:08:40.964
You solve those, and
then from that you

01:08:40.964 --> 01:08:42.630
will see whether this
actually gives you

01:08:42.630 --> 01:08:44.700
a solution to the
original sub-problem

01:08:44.700 --> 01:08:47.250
you wanted to solve.

01:08:47.250 --> 01:08:48.670
That's the zip case.

01:08:48.670 --> 01:08:52.220
There's another case
which we call tug.

01:08:55.689 --> 01:08:59.720
In the tug case-- so
that was supposing,

01:08:59.720 --> 01:09:03.590
we'll maybe nothing
else gets glued in here.

01:09:03.590 --> 01:09:06.439
But maybe another vertex gets
glued in there, that's the tug.

01:09:06.439 --> 01:09:09.750
To pick a vertex, I pull it in.

01:09:09.750 --> 01:09:17.149
So in that case we get
a picture like this.

01:09:20.770 --> 01:09:24.880
So here's EJ, here's
VI, and now there's

01:09:24.880 --> 01:09:29.060
some other vertex VK
that gets glued in there.

01:09:29.060 --> 01:09:29.779
Which vertex?

01:09:29.779 --> 01:09:32.252
I don't know, try them all.

01:09:32.252 --> 01:09:33.960
Just like before,
before we were choosing

01:09:33.960 --> 01:09:35.566
an edge that gets glued in.

01:09:35.566 --> 01:09:37.149
Now it's not necessarily
a whole edge,

01:09:37.149 --> 01:09:41.020
but if there's any
vertex that glues in,

01:09:41.020 --> 01:09:42.720
pick who's the next one.

01:09:42.720 --> 01:09:46.930
And now I get a sub-problem
here which is VI to VK.

01:09:46.930 --> 01:09:53.210
I get a sub-problem
here which is VK to EJ.

01:09:53.210 --> 01:09:56.610
I solve each of those, I
take the cross-product,

01:09:56.610 --> 01:10:01.680
I do that for all values
of K just like I did here,

01:10:01.680 --> 01:10:03.680
except the labels have
changed a little bit,

01:10:03.680 --> 01:10:04.970
and I find all the outputs.

01:10:04.970 --> 01:10:09.390
And again, you can show that
it's exponential time at most.

01:10:09.390 --> 01:10:13.990
So that's an algorithm.

01:10:13.990 --> 01:10:19.750
Now, it's exponential time,
but really it's not so bad

01:10:19.750 --> 01:10:24.680
because it's at most
cubic like we had before.

01:10:24.680 --> 01:10:26.360
But we're doing
extra work, which

01:10:26.360 --> 01:10:31.900
is something like the
number of gluings dealt

01:10:31.900 --> 01:10:37.590
with at each stage
per sub-problem.

01:10:37.590 --> 01:10:41.310
Now, it's not just the
number of actual solutions,

01:10:41.310 --> 01:10:44.150
because we generate
all possible solutions

01:10:44.150 --> 01:10:46.370
and then check whether
they're Alexandroff.

01:10:46.370 --> 01:10:50.940
So if you have some example that
happens to be unique in the way

01:10:50.940 --> 01:10:54.240
that it glues up, this bound
will not actually be very good.

01:10:54.240 --> 01:10:56.120
It's still going to
consider lots of options.

01:10:56.120 --> 01:11:02.730
But in the case of
bounded sharpness,

01:11:02.730 --> 01:11:05.275
where the number of gluings
is only polynomial--

01:11:05.275 --> 01:11:07.290
and it's polynomial
for a strong reason

01:11:07.290 --> 01:11:10.320
that the trees can't
get very complicated--

01:11:10.320 --> 01:11:13.290
then we can actually turn this
into a polynomial algorithm.

01:11:13.290 --> 01:11:15.880
This will be n cubed
times that bound.

01:11:15.880 --> 01:11:19.064
As long as your polygon
is bounded sharpness,

01:11:19.064 --> 01:11:21.730
you can show that at every stage
of course the number of gluings

01:11:21.730 --> 01:11:24.107
will also be polynomial.

01:11:24.107 --> 01:11:25.690
And so then even the
number of gluings

01:11:25.690 --> 01:11:27.773
you have to consider and
check will be polynomial.

01:11:27.773 --> 01:11:29.970
So the whole thing will
be polynomial time,

01:11:29.970 --> 01:11:33.720
that is this result
and this result.

01:11:36.810 --> 01:11:39.042
So if your polygon is
vaguely reasonable,

01:11:39.042 --> 01:11:40.750
this is actually a
really good algorithm.

01:11:40.750 --> 01:11:42.208
This algorithm has
been implemented

01:11:42.208 --> 01:11:45.990
by two groups, one
[INAUDIBLE] in mathematica

01:11:45.990 --> 01:11:48.952
and another [INAUDIBLE],
which sadly is not--

01:11:48.952 --> 01:11:50.660
his implementation
used to be on the web,

01:11:50.660 --> 01:11:53.400
I can't find it anymore.

01:11:53.400 --> 01:11:56.640
But you get either
implementation,

01:11:56.640 --> 01:11:58.160
plug-in your
polygon, and it just

01:11:58.160 --> 01:12:00.850
lists all the possible gluings.

01:12:00.850 --> 01:12:03.390
So that's all the
theory for today.

01:12:03.390 --> 01:12:06.110
Now I want to show you a whole
bunch of gluings for fun.

01:12:06.110 --> 01:12:08.810
Once you have all the stuff,
we have these programs,

01:12:08.810 --> 01:12:10.670
you get to play.

01:12:10.670 --> 01:12:16.890
So our first play is not that.

01:12:16.890 --> 01:12:18.800
That was the last play.

01:12:18.800 --> 01:12:20.330
First thing, we saw this before.

01:12:20.330 --> 01:12:23.090
I'll just remind you
what it looks like

01:12:23.090 --> 01:12:25.440
and tell you a little bit
about what's going on here.

01:12:25.440 --> 01:12:28.660
So this was the cube.

01:12:28.660 --> 01:12:31.130
And then it's eventually
going to fold into a cross.

01:12:31.130 --> 01:12:33.360
The real study here is
for the Latin Cross--

01:12:33.360 --> 01:12:35.710
which is the picture
I keep drawing

01:12:35.710 --> 01:12:39.790
at the beginning of lecture and
which will now be unfolded--

01:12:39.790 --> 01:12:44.280
what other convex polyhedra
can you glue that polygon into?

01:12:44.280 --> 01:12:47.670
So it's like you're not
told what the creases are.

01:12:47.670 --> 01:12:50.940
You just want to look at
gluings, the resulting creases.

01:12:50.940 --> 01:12:53.774
This is one convex
polyhedron you can make.

01:12:53.774 --> 01:12:56.190
This is something that can
come from Alexandroff's theorem

01:12:56.190 --> 01:12:59.780
that you actually get a flat,
doubly-covered convex polygon.

01:12:59.780 --> 01:13:03.320
It's technically a polyhedron,
according to Alexandroff.

01:13:03.320 --> 01:13:07.800
These are all edge-to-edge
gluings if the length two edges

01:13:07.800 --> 01:13:11.070
are actually subdivided
into two length one edges.

01:13:11.070 --> 01:13:14.400
And this video only enumerates
the edge-to-edge gluings,

01:13:14.400 --> 01:13:17.355
because at this point we only
had the edge-to-edge algorithm.

01:13:17.355 --> 01:13:20.090
I forget, this video
is '98, I think.

01:13:20.090 --> 01:13:23.690
This algorithm was in '96, so
they had just implemented that.

01:13:23.690 --> 01:13:25.136
And then that's when I joined.

01:13:25.136 --> 01:13:27.260
I was just starting out as
a grad student and said,

01:13:27.260 --> 01:13:29.030
OK let's make a video.

01:13:29.030 --> 01:13:30.140
That would be cool.

01:13:30.140 --> 01:13:33.160
So I think there's one more.

01:13:33.160 --> 01:13:35.410
And this is the only
one where we actually

01:13:35.410 --> 01:13:37.380
have the animations.

01:13:37.380 --> 01:13:39.505
This octahedron, this
was tricky to find,

01:13:39.505 --> 01:13:40.880
beceause at this
point there were

01:13:40.880 --> 01:13:42.920
no algorithms for
Alexandroff's theorem.

01:13:42.920 --> 01:13:46.080
So we found it by taking
a piece of cardboard,

01:13:46.080 --> 01:13:48.470
gluing it up,
getting a protractor,

01:13:48.470 --> 01:13:50.350
and measuring all
the dihedral angles,

01:13:50.350 --> 01:13:51.600
and then typing them in.

01:13:51.600 --> 01:13:54.170
And Lo and behold,
in that animation

01:13:54.170 --> 01:13:58.090
they don't perfectly close
up, but it's very close,

01:13:58.090 --> 01:14:00.110
up to the measurement
error of the protractor.

01:14:00.110 --> 01:14:01.975
So for edge-to-edge
gluings, there

01:14:01.975 --> 01:14:03.642
are exactly five
convex polyhedra

01:14:03.642 --> 01:14:04.850
you can make from that cross.

01:14:08.729 --> 01:14:10.520
But if you allow
non-edge-to-edge gluings--

01:14:10.520 --> 01:14:13.130
and so some years later when
we came up with that algorithm

01:14:13.130 --> 01:14:16.710
and implemented it, we
discovered there are 85 gluings

01:14:16.710 --> 01:14:17.870
of the cross.

01:14:17.870 --> 01:14:20.300
This is only six of them.

01:14:20.300 --> 01:14:22.260
We're going to do it
starting with the cube,

01:14:22.260 --> 01:14:26.130
and then we're going to go
in increasing order of faces.

01:14:26.130 --> 01:14:30.000
So there's two flat,
doubly-covered quadrilaterals.

01:14:30.000 --> 01:14:32.730
They're different.

01:14:32.730 --> 01:14:35.030
Then there is a bunch of
tetrahedra that you can make.

01:14:35.030 --> 01:14:36.071
None of them are regular.

01:14:36.071 --> 01:14:40.540
One of them was edge-to-edge,
I think it might be this one.

01:14:40.540 --> 01:14:43.880
I think there's some more
tetrahedra at the top there.

01:14:43.880 --> 01:14:46.390
The blue labels here
say what they are.

01:14:46.390 --> 01:14:48.650
For each one of
these we taped up

01:14:48.650 --> 01:14:50.470
the-- we knew what
the gluing was.

01:14:50.470 --> 01:14:53.512
We taped it up, and
then we played with it

01:14:53.512 --> 01:14:55.470
until we figured out,
this must be the creases.

01:14:55.470 --> 01:14:57.344
Then we actually drew
in that create pattern,

01:14:57.344 --> 01:15:00.192
folded it up, and verified
that is the right answer.

01:15:00.192 --> 01:15:01.900
Because again, at this
point no algorithm

01:15:01.900 --> 01:15:04.260
for Alexandroff's theorem.

01:15:04.260 --> 01:15:05.200
More tetrahedra.

01:15:05.200 --> 01:15:07.610
Here we get to the
five-sided polyhedra.

01:15:07.610 --> 01:15:10.730
I think this one is edge-to-edge
and is in the video.

01:15:10.730 --> 01:15:14.119
It's a little hard to
tell from the-- actually,

01:15:14.119 --> 01:15:15.410
you can tell from the pictures.

01:15:15.410 --> 01:15:17.240
Here there's two sevens.

01:15:17.240 --> 01:15:18.580
That means seven glued to seven.

01:15:18.580 --> 01:15:20.500
That means this is a
fold point, this edge

01:15:20.500 --> 01:15:21.630
is glued to that edge.

01:15:21.630 --> 01:15:24.050
Over here, every edge
has only one label,

01:15:24.050 --> 01:15:26.000
where again this is
considered two edges.

01:15:26.000 --> 01:15:27.500
So this was the
edge-to-edge gluing.

01:15:32.490 --> 01:15:34.350
I think a couple more slides.

01:15:34.350 --> 01:15:36.590
We get another
pentahedron and then

01:15:36.590 --> 01:15:42.990
starting to get hexahedra other
than the cube, lots of them.

01:15:42.990 --> 01:15:44.340
Then we start getting octahedra.

01:15:44.340 --> 01:15:46.940
The last one in the
video was octahedron.

01:15:46.940 --> 01:15:51.141
It's not this one, this
one has some fold points.

01:15:51.141 --> 01:15:54.050
It must be-- these
are all octahedra,

01:15:54.050 --> 01:15:56.272
so it's one of these.

01:15:56.272 --> 01:15:58.640
This guy.

01:15:58.640 --> 01:16:01.220
Of course, it's hard to
tell from a static image,

01:16:01.220 --> 01:16:04.910
but yeah, obviously that was
the octahedron from the video.

01:16:04.910 --> 01:16:05.975
And that is all.

01:16:05.975 --> 01:16:08.740
So actually, there's only
23 distinct polyhedra

01:16:08.740 --> 01:16:12.680
you can make, but you can
make them out of 85 gluings.

01:16:12.680 --> 01:16:14.260
So 85 gluings.

01:16:14.260 --> 01:16:18.330
If one of them is symmetric,
the cube is symmetric.

01:16:18.330 --> 01:16:19.650
So that's one.

01:16:19.650 --> 01:16:22.500
And then the other
84, there's everything

01:16:22.500 --> 01:16:25.170
and its reflectional
inverse, because this polygon

01:16:25.170 --> 01:16:26.660
is symmetric.

01:16:26.660 --> 01:16:31.860
So it's 84 divided by 2,
which is 42, a good number.

01:16:31.860 --> 01:16:37.680
42 actual honest
gluings plus the cube.

01:16:37.680 --> 01:16:40.276
But those 42 gluings,
a lot of them

01:16:40.276 --> 01:16:42.150
generate the same
polyhedron, because there's

01:16:42.150 --> 01:16:44.710
only 23 distinct
polyhedra in the end.

01:16:44.710 --> 01:16:46.490
I don't have it here,
it's on my web page.

01:16:46.490 --> 01:16:48.290
You could look up
all 85, and it says

01:16:48.290 --> 01:16:50.000
which ones are the
same as which ones.

01:16:50.000 --> 01:16:51.500
And it was a real surprise
when we were building them.

01:16:51.500 --> 01:16:53.130
It was like, wait
this looks identical

01:16:53.130 --> 01:16:54.546
to this other
polyhedron, and it's

01:16:54.546 --> 01:16:56.280
glued in a very different way.

01:16:56.280 --> 01:16:58.550
Sort of an extrasymmetry
of that polyhedron,

01:16:58.550 --> 01:16:59.960
as opposed to the cross itself.

01:16:59.960 --> 01:17:00.880
It was pretty cool.

01:17:03.510 --> 01:17:06.740
An interesting
thing to note here

01:17:06.740 --> 01:17:13.810
is that we only bisect
the edges, right?

01:17:13.810 --> 01:17:16.190
There's a lot of
edge-to-edge stuff,

01:17:16.190 --> 01:17:18.890
and then some of the
edges get cut in half.

01:17:18.890 --> 01:17:21.710
And in this case actually, they
look mostly like fold points,

01:17:21.710 --> 01:17:24.170
but that's not always the case.

01:17:24.170 --> 01:17:28.970
It turns out, if you have a
polygon were all the edge links

01:17:28.970 --> 01:17:33.600
are the same like this and
you look at non-edge-to-edge

01:17:33.600 --> 01:17:35.496
gluings, and there
are no rolling belts--

01:17:35.496 --> 01:17:36.870
because if there's
rolling belts,

01:17:36.870 --> 01:17:39.370
it's infinite because you're
not going to have anything like

01:17:39.370 --> 01:17:40.030
this.

01:17:40.030 --> 01:17:46.890
Then it suffices to
subdivide every edge in half.

01:17:46.890 --> 01:17:49.070
And then every non-edge-to-edge
gluing will become

01:17:49.070 --> 01:17:50.540
an edge-to-edge gluing.

01:17:50.540 --> 01:17:55.740
This is called the [INAUDIBLE]
half-length theorem

01:17:55.740 --> 01:17:56.687
in our book.

01:17:56.687 --> 01:17:58.270
It was proved by
this guy [INAUDIBLE],

01:17:58.270 --> 01:18:01.070
who was one of the
implementers of the algorithms

01:18:01.070 --> 01:18:03.070
for enumerating
all these gluings.

01:18:03.070 --> 01:18:04.230
And he proved it afterward.

01:18:04.230 --> 01:18:06.100
The code doesn't actually
exploit that fact,

01:18:06.100 --> 01:18:07.200
but it's kind of neat.

01:18:07.200 --> 01:18:09.330
All you have to worry
about are half edges

01:18:09.330 --> 01:18:12.900
in this case where all the
edge links are the same.

01:18:12.900 --> 01:18:13.990
All right, that's a cross.

01:18:13.990 --> 01:18:15.705
And it's kind of
maybe even surprising

01:18:15.705 --> 01:18:18.810
that there's only finitely
many different gluings,

01:18:18.810 --> 01:18:21.970
but there's no way to
get a rolling belt here.

01:18:21.970 --> 01:18:24.795
Let's look at-- oh, here
are all the polyhedra

01:18:24.795 --> 01:18:28.680
in a pretty 3D form.

01:18:28.680 --> 01:18:31.240
Here is a polygon
which is convex.

01:18:31.240 --> 01:18:33.270
It is the equilateral triangle.

01:18:33.270 --> 01:18:35.900
And so, no surprise, there
a rolling belts here.

01:18:35.900 --> 01:18:38.450
But here's the picture of
how all the rolling belts fit

01:18:38.450 --> 01:18:39.040
together.

01:18:39.040 --> 01:18:41.400
In principle, you can
extract this picture

01:18:41.400 --> 01:18:44.160
from this algorithm.

01:18:44.160 --> 01:18:47.070
Although combined with an
algorithm for Alexandroff's

01:18:47.070 --> 01:18:48.609
theorem, that's the tricky part.

01:18:48.609 --> 01:18:50.150
So you have some
very simple gluings,

01:18:50.150 --> 01:18:51.490
like could could fold
the triangle in half,

01:18:51.490 --> 01:18:53.140
get this doubly-covered
triangle,

01:18:53.140 --> 01:18:54.680
you can make a
regular tetrahedron,

01:18:54.680 --> 01:18:57.230
or you can fold the triangle
into a flat doubly-covered

01:18:57.230 --> 01:18:59.152
rectangle like at the top.

01:18:59.152 --> 01:19:00.985
And then there are
rolling belts in between.

01:19:00.985 --> 01:19:03.170
So this is one
rolling belt, this

01:19:03.170 --> 01:19:04.710
is another possible
rolling belt,

01:19:04.710 --> 01:19:06.960
another possible rolling
belt each with a gluing tree.

01:19:06.960 --> 01:19:08.730
They're not all drawn here.

01:19:08.730 --> 01:19:11.290
And this is sort of
the topology of all

01:19:11.290 --> 01:19:15.720
of the possible gluings you
could make, which is nice.

01:19:15.720 --> 01:19:20.000
So a triangle is
relatively simple.

01:19:20.000 --> 01:19:24.740
The square is a little messier.

01:19:24.740 --> 01:19:28.400
There's again a bunch of
particularly nice gluings

01:19:28.400 --> 01:19:34.390
like the [INAUDIBLE], the
folding in half one way,

01:19:34.390 --> 01:19:38.820
folding in half the other
way, making a letter,

01:19:38.820 --> 01:19:42.340
and some tetrahedra that
are just drawn here.

01:19:42.340 --> 01:19:44.221
They're in the middle.

01:19:44.221 --> 01:19:45.970
And then there's these
crazy rolling belts

01:19:45.970 --> 01:19:47.120
for how they fit together.

01:19:47.120 --> 01:19:51.100
So this is in unit square
all the different gluings.

01:19:51.100 --> 01:19:55.050
And one of the fun things,
some of them are octahedra,

01:19:55.050 --> 01:19:59.930
I have a list here.

01:19:59.930 --> 01:20:03.020
But I don't know actually
which one of these belts

01:20:03.020 --> 01:20:03.830
has the octahedra.

01:20:03.830 --> 01:20:05.540
It might be a couple of them.

01:20:05.540 --> 01:20:10.300
And it turns out, for octahedra
they actually figured out

01:20:10.300 --> 01:20:13.470
an algorithm just for octahedra
to solve Alexandroff's theorem.

01:20:13.470 --> 01:20:17.040
This is again before
Alexandroff theorem algorithms.

01:20:17.040 --> 01:20:19.710
And they wanted to compute, well
if I take all these polyhdra,

01:20:19.710 --> 01:20:21.660
which one has the
maximum volume?

01:20:21.660 --> 01:20:23.630
So if I take a
square paper, what's

01:20:23.630 --> 01:20:26.560
the maximum volume
shape you can make?

01:20:26.560 --> 01:20:30.900
And there it is.

01:20:30.900 --> 01:20:33.950
It's kind of fun.

01:20:33.950 --> 01:20:35.820
One of those octahedra.

01:20:35.820 --> 01:20:41.010
And this is a prettier picture
of-- so here they actually

01:20:41.010 --> 01:20:43.080
computed all the polyhedra.

01:20:43.080 --> 01:20:45.100
Obviously not all
infinitely many of them,

01:20:45.100 --> 01:20:48.360
but various snapshots
along each rolling belt.

01:20:48.360 --> 01:20:50.550
And each of these
rolling belts corresponds

01:20:50.550 --> 01:20:52.960
to one of the circles over here.

01:20:56.400 --> 01:20:57.790
And that's it.

01:20:57.790 --> 01:21:00.370
Any questions?

01:21:00.370 --> 01:21:03.250
So that's the end
of fun with gluings.

01:21:03.250 --> 01:21:06.770
We'll look at other kinds of
gluing problems next class.

