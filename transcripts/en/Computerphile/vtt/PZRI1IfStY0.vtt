WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.500
People expect computers to be 
entirely accurate and precise with numbers.

00:00:04.600 --> 00:00:07.320
You know, you grow up with calculators.
You expect that if you type in:

00:00:07.320 --> 00:00:11.880
"0.1 + 0.2", you expect it to come out to "0.3".

00:00:12.000 --> 00:00:15.440
And sooner or later 
every programmer, as they're learning,

00:00:15.440 --> 00:00:19.300
tries something like that. 
And they type it into a programming language.

00:00:19.460 --> 00:00:24.660
Something like "0.1 + 0.2",
and they will hit Enter,

00:00:24.660 --> 00:00:30.400
and what the computer will give them
is something like "0.300000000...1".

00:00:30.400 --> 00:00:34.640
And at that point, they will have started 
to learn about floating point numbers,

00:00:34.640 --> 00:00:37.260
and they will be starting to tear their hair out.

00:00:39.480 --> 00:00:42.960
Floating point numbers are 
essentially scientific notation.

00:00:43.120 --> 00:00:47.580
For the uninitiated, let's say
you're an astrophysicist,

00:00:47.620 --> 00:00:49.680
and you have the speed of light,

00:00:49.680 --> 00:00:53.880
which is this enormous number with eight 0s after it.

00:00:54.040 --> 00:00:56.360
And you want to multiply it by a tiny distance.

00:00:56.540 --> 00:00:59.280
It doesn't really matter what we're measuring here, 
it's just a big number and a small number.

00:00:59.440 --> 00:01:04.160
Let's say, 0.00000015.

00:01:04.160 --> 00:01:08.640
Let's say you want to multiply these two together.
(I may have made this a bit deliberately easy.)

00:01:08.640 --> 00:01:12.140
You could try and do some 
really complicated maths and work it all out,

00:01:12.140 --> 00:01:15.140
but you don't need to.
Because in scientific notation,

00:01:15.320 --> 00:01:19.020
this is 3 times 10 to the 8,

00:01:19.360 --> 00:01:23.780
and this one is 1.5 times 10 to the -7.

00:01:23.780 --> 00:01:27.360
So you don't need to do anything particularly complicated to multiply these two together.

00:01:27.420 --> 00:01:31.780
All you have to do is multiply these,
which is 4.5,

00:01:31.920 --> 00:01:35.720
and then add these exponents together here.

00:01:35.880 --> 00:01:40.460
So, 8 add -7, eight minus seven 
means that's 1.

00:01:40.460 --> 00:01:46.340
So we'll have 4.5 times 10 to the 1, 
or 4.5 times 10, or 45.

00:01:46.500 --> 00:01:51.420
Brilliant. That's much easier than 
trying to actually handle large numbers.

00:01:51.580 --> 00:01:54.960
And it also brings us to 
the concept of significant figures.

00:01:54.980 --> 00:01:58.460
Because the speed of light isn't
exactly 3 times 10 to the 8.

00:01:58.460 --> 00:02:04.020
It's 2.997[something], and there's 
a lot of digits on the end of there

00:02:04.160 --> 00:02:07.080
which don't really matter 
for everyday calculations.

00:02:07.140 --> 00:02:10.160
We round it up. We say it's 3 times 10 to the 8.

00:02:10.300 --> 00:02:15.640
Or maybe, for being precise, 
we say it's 2.997 times 10 to the 8,

00:02:15.640 --> 00:02:18.400
but we don't really worry 
about the numbers beyond that.

00:02:18.400 --> 00:02:21.940
Hold that thought. 
So, we'll come back to significant digits later.

00:02:21.940 --> 00:02:25.660
The two main advantages to floating point 
are speed and efficiency.

00:02:25.660 --> 00:02:28.760
Speed, because floating point 
has been built over many, many years.

00:02:28.760 --> 00:02:32.460
It is now lightning fast 
for computers to deal with.

00:02:32.540 --> 00:02:35.620
And efficiency, because 
it can deal with really big numbers --

00:02:35.620 --> 00:02:38.440
massive numbers, "size of the universe" numbers --

00:02:38.440 --> 00:02:41.600
and really small numbers -- 
"size of an atom" numbers --

00:02:41.740 --> 00:02:44.100
without needing enormous amounts of space.

00:02:44.100 --> 00:02:48.300
If you had a format that needed 
to include the size of the universe

00:02:48.300 --> 00:02:54.520
and the size of an atom, you'd need 
so many zeroes stored on both ends

00:02:54.520 --> 00:02:58.320
or you'd need something particularly 
complicated for a computer to work out

00:02:58.360 --> 00:03:03.300
that it would either be really inefficient, 
storing one number as a megabyte,

00:03:03.300 --> 00:03:07.180
or you would need something that would be
really fiddly for a computer

00:03:07.180 --> 00:03:10.760
to work out as it tries to place 
all the zeroes and the numbers everywhere.

00:03:10.760 --> 00:03:13.740
Let's talk about base 10. 
Let's talk about us - people.

00:03:13.740 --> 00:03:17.140
(Let's talk about the lights being on 
all of a sudden. That's weird.)

00:03:17.300 --> 00:03:21.900
In base 10, in our normal human numbers,

00:03:21.900 --> 00:03:24.080
so you know ten digits - base 10,

00:03:24.080 --> 00:03:27.780
we have hundreds, tens, and units.
You learn that in primary school.

00:03:27.780 --> 00:03:33.300
And over here, you have tenths, 
hundredths, and thousandths.

00:03:33.300 --> 00:03:39.160
So if you want to say "one tenth" in decimal,
you say "0.1",

00:03:39.180 --> 00:03:41.400
and that's normal, and that's natural.

00:03:41.400 --> 00:03:45.020
Base 2, on the other hand, binary..., computers..., they don't do that.

00:03:45.020 --> 00:03:48.460
Because what they see are fours, twos, and ones.

00:03:48.500 --> 00:03:52.920
And then over here: halves, quarters, eighths and sixteenths.

00:03:52.920 --> 00:03:54.900
There's no 0.1 in there.

00:03:55.100 --> 00:04:04.560
In fact, 0.1 in binary is "0.00011", 
and that "0011" is recurring.

00:04:04.680 --> 00:04:11.260
It's actually 0.00011001100110011... 
all the way to infinity.

00:04:11.260 --> 00:04:15.320
Which is interesting, 
because 32-bit computers,

00:04:15.320 --> 00:04:17.760
the ones we generally use,
(we've moved a bit on now)

00:04:17.760 --> 00:04:22.940
32-bit computers only store 23 significant digits.

00:04:23.200 --> 00:04:25.260
They also store where the decimal point is.

00:04:25.380 --> 00:04:30.300
They basically do scientific notation in base 2.
That's what floating point is.

00:04:30.300 --> 00:04:34.180
So they say, "All right, so we've got 
this long binary number,

00:04:34.180 --> 00:04:38.220
times 2 to the something."

00:04:38.220 --> 00:04:40.980
And that's a problem. 
Because what it loses is precision.

00:04:40.980 --> 00:04:43.160
It doesn't understand recursion.

00:04:43.160 --> 00:04:45.920
I have an analogy for that in base 10:

00:04:46.040 --> 00:04:49.640
if you try to write "a third" as a decimal, we go:

00:04:49.640 --> 00:04:55.300
hundreds, tens, units, tenths, hundredths, thousandths,

00:04:55.300 --> 00:05:03.020
and then, we try and do this and we end up with
0.333333333... recurring.

00:05:03.020 --> 00:05:06.860
Now imagine you don't understand 
recurring numbers, like a computer,

00:05:06.860 --> 00:05:09.720
like scientific notation 
if you take away that recursion,

00:05:09.720 --> 00:05:12.640
like floating point arithmetic doesn't.

00:05:12.640 --> 00:05:14.920
So this is where we bring everything together.

00:05:14.920 --> 00:05:23.220
If you're in base 10, if you're in decimal,
let's say you have 1/3 + 1/3 + 1/3.

00:05:23.280 --> 00:05:28.020
As humans we go, "Well that's 0.3 recurring,
plus 0.3 recurring,

00:05:28.020 --> 00:05:30.700
plus 0.3 recurring, which is 1."

00:05:30.700 --> 00:05:34.020
But say you're a computer 
and you don't understand recursion,

00:05:34.040 --> 00:05:38.020
because floating point math 
is essentially significant figures.

00:05:38.200 --> 00:05:43.680
So a computer would look at that and go,
"0.333333333...

00:05:44.700 --> 00:05:47.300
plus 333..., plus 333...", 
and it will say,

00:05:47.300 --> 00:05:53.300
"Well, a third plus a third plus a third.
Total it to 0.99999999..."

00:05:53.300 --> 00:05:57.700
But after a while, you'll stop. 
Because you've run out of digits.

00:05:57.700 --> 00:06:02.340
What you've just got there 
is a floating point rounding error.

00:06:02.460 --> 00:06:07.040
Let's take it down again to base 2. 
Let's do 1/10 + 2/10.

00:06:07.040 --> 00:06:14.520
Which is 0.00011001100110011...
Oh! We've run out of digits!

00:06:14.520 --> 00:06:20.700
Because floating point arithmetic 
on 32-bit computers only stores 23 digits.

00:06:20.780 --> 00:06:29.340
And then you try and add 2/10, which is
0.001100110011...

00:06:29.340 --> 00:06:32.300
I'm not going to try and do that maths,
because it's going to take ages

00:06:32.300 --> 00:06:36.240
but what happens is exactly the same
as back here.

00:06:36.240 --> 00:06:41.800
After 23 digits in 32-bit arithmetic
(I think we've got 56 on 64-bit computers)

00:06:41.800 --> 00:06:44.800
it cuts. 
It doesn't understand recurring,

00:06:44.820 --> 00:06:49.600
which means that floating point looks at 
1/10 + 2/10, what you just typed in,

00:06:49.600 --> 00:06:55.720
"0.1 + 0.2" in decimal, 
and it says that 1/10 + 2/10

00:06:55.720 --> 00:06:59.320
does NOT quite equal 3/10.

00:06:59.320 --> 00:07:03.120
Because, to its mind, it doesn't.

00:07:03.160 --> 00:07:06.220
For nearly all cases, it IS close enough.

00:07:06.220 --> 00:07:10.960
In most cases, you don't need 
more than 23 binary digits of precision.

00:07:10.960 --> 00:07:13.180
If you do, you go to 64-bit.

00:07:13.180 --> 00:07:17.960
If you are doing a 3D game and you need to know 
where to point something on the screen,

00:07:17.960 --> 00:07:22.200
it doesn't matter if it's 1/100000 of a pixel out

00:07:22.200 --> 00:07:24.080
because it will be in the right place.

00:07:24.080 --> 00:07:28.300
And if you're doing big calculations, 
it doesn't matter if a tiny, tiny, tiny fraction --

00:07:28.300 --> 00:07:31.100
something smaller than a molecule -- is out,

00:07:31.100 --> 00:07:33.540
because it will look more or less right:

00:07:33.540 --> 00:07:39.340
right beyond any precision or tolerance 
that the real world could possibly manage.

00:07:39.380 --> 00:07:42.940
But it means that if you're dealing with currency, 
and you say that

00:07:42.940 --> 00:07:50.740
you are adding 10p (or £0.1) to 20p, 
every programmer hits this sooner or later,

00:07:50.740 --> 00:07:52.560
we just go like that. That's easy.

00:07:52.700 --> 00:07:58.140
A computer will come back and say, 
"That's actually... that many pence."

00:07:58.140 --> 00:08:02.600
And in these particular human things, 
we will notice the error

00:08:02.600 --> 00:08:06.500
because suddenly to us
it's very, very obvious.

00:08:07.100 --> 00:08:10.560
That's the problem with floating point. 
To fix that, by the way, if you're doing currency,

00:08:10.560 --> 00:08:13.860
you either use a decimal type 
in more advanced programming languages

00:08:13.880 --> 00:08:18.560
or you just store everything as an integer 
in terms of pence, cents, or whatever

00:08:18.680 --> 00:08:20.900
and then divide by 100 at the end.

00:08:20.900 --> 00:08:24.000
Floating point is something 
that really, really confuses a lot of people.

00:08:24.000 --> 00:08:28.420
It's tough to get your head around
until you realize that it is just scientific notation.

00:08:28.420 --> 00:08:33.640
It's the same thing that we learned 
in maths class at school, only in base 2.

00:08:33.640 --> 00:08:36.500
It's halves and quarters and eighths,

00:08:36.500 --> 00:08:41.820
and once you crack that, once you realize that 
it's storing a set length of number

00:08:41.820 --> 00:08:46.660
and then working out where the decimal point could be
and it's just significant figures,

00:08:46.740 --> 00:08:49.540
it starts to become a lot easier.
And you start to realize,

00:08:49.560 --> 00:08:55.880
"Oh, that's why if i type 0.1 + 0.2, what I get isn't 0.3."

