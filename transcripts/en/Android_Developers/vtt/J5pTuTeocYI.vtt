WEBVTT
Kind: captions
Language: en

00:00:04.320 --> 00:00:06.750
MALE SPEAKER: Welcome to another
Android Developer Lab.

00:00:09.430 --> 00:00:11.200
So thanks for joining us.

00:00:11.200 --> 00:00:13.280
We are running three
minutes late.

00:00:13.280 --> 00:00:14.180
But that's OK.

00:00:14.180 --> 00:00:17.800
Hopefully that's given you
enough time to join.

00:00:17.800 --> 00:00:22.220
So with that being said, let's
get started with the news.

00:00:22.220 --> 00:00:26.010
The first bit of news
is really exciting.

00:00:26.010 --> 00:00:27.630
And we're really proud of it.

00:00:27.630 --> 00:00:32.560
The Nexus 7 tablet has won
gadget and tablet of the year.

00:00:32.560 --> 00:00:36.950
So that's really awesome,
really fantastic.

00:00:36.950 --> 00:00:40.840
We couldn't be prouder of the
Android engineering team, as

00:00:40.840 --> 00:00:42.030
well as our partners ASUS.

00:00:42.030 --> 00:00:45.480
And other than being a great
tablet for consumers to use,

00:00:45.480 --> 00:00:48.070
it's a fantastic development
tablet, too.

00:00:48.070 --> 00:00:53.210
So yeah, we're really,
really happy.

00:00:53.210 --> 00:00:55.510
All right, moving onto more
developer-specific news.

00:00:55.510 --> 00:00:58.970
We launched our trials
for subscriptions.

00:00:58.970 --> 00:01:03.260
So now you get a period
where you can try the

00:01:03.260 --> 00:01:04.640
subscription app--

00:01:04.640 --> 00:01:07.350
not just magazines,
but even apps.

00:01:07.350 --> 00:01:10.200
You can trial it for a little
while before the user has to

00:01:10.200 --> 00:01:12.260
commit to purchasing it.

00:01:12.260 --> 00:01:17.080
So this is a great way for users
to get a taste of the

00:01:17.080 --> 00:01:19.040
app before they purchase it.

00:01:19.040 --> 00:01:21.450
And we think it's going to
be really beneficial for

00:01:21.450 --> 00:01:23.440
developers.

00:01:23.440 --> 00:01:27.660
The next thing is that this
week has been tablet week.

00:01:27.660 --> 00:01:29.190
Well, we said it
was last week.

00:01:29.190 --> 00:01:31.890
And we certainly started
off with it, and our

00:01:31.890 --> 00:01:33.410
European team as well.

00:01:33.410 --> 00:01:36.060
We published some materials
this week.

00:01:36.060 --> 00:01:38.810
So first was the blog, the
Android developers' blog.

00:01:38.810 --> 00:01:42.430
And we talked about building
quality tablet apps.

00:01:42.430 --> 00:01:47.960
It also had a link to our
developer portal called

00:01:47.960 --> 00:01:49.750
Building Quality Apps.

00:01:49.750 --> 00:01:52.650
And so on that Building Quality
Apps, there's actually

00:01:52.650 --> 00:01:53.490
three sections.

00:01:53.490 --> 00:01:55.415
And one of them specializes
on tablets.

00:01:58.290 --> 00:02:01.030
It has a checklist to say, well,
this is what makes a

00:02:01.030 --> 00:02:02.460
quality tablet app.

00:02:02.460 --> 00:02:06.370
So for those of you that are
building phone apps and not

00:02:06.370 --> 00:02:09.449
building tablet apps, now is
the best time to get in.

00:02:09.449 --> 00:02:14.150
Last week's a ADL+ covered
fragments, which are really a

00:02:14.150 --> 00:02:18.040
fundamental piece of building
apps for phones and tablets.

00:02:18.040 --> 00:02:21.330
So if you haven't seen it
already, you should definitely

00:02:21.330 --> 00:02:24.370
view last week's ADL+ app, and
then go along with this new

00:02:24.370 --> 00:02:26.520
checklist that we've
published.

00:02:26.520 --> 00:02:28.200
Next slide, please.

00:02:28.200 --> 00:02:32.100
And over to you Anirudh.

00:02:32.100 --> 00:02:33.680
ANIRUDH DEWANI: Hi guys.

00:02:33.680 --> 00:02:37.070
So for today's talk, we are
going to cover Connectivity

00:02:37.070 --> 00:02:38.900
APIs, for Jelly Bean.

00:02:41.770 --> 00:02:43.690
And we're going to announce
something really exciting at

00:02:43.690 --> 00:02:46.640
the end of the presentation,
unconnected with the API, so

00:02:46.640 --> 00:02:48.920
stay tuned.

00:02:48.920 --> 00:02:52.780
So what we're going to look at
is, what are connectivity

00:02:52.780 --> 00:02:55.560
APIs, and what's new
with Jelly Bean.

00:02:55.560 --> 00:02:59.160
So basically, these are a set
of wireless APIs, and they

00:02:59.160 --> 00:03:01.790
enable devices to communicate
between each other.

00:03:01.790 --> 00:03:04.300
So they can communicate
with the cloud.

00:03:04.300 --> 00:03:07.960
And that's about using your
regular Wi-Fi to connect to

00:03:07.960 --> 00:03:10.280
your service on the cloud
and pull data.

00:03:10.280 --> 00:03:12.170
And they can also talk
to each other.

00:03:12.170 --> 00:03:16.060
So some of these technologies
that can enable this kind of

00:03:16.060 --> 00:03:18.990
communication on Wi-Fi,
Bluetooth, and Android Beam,

00:03:18.990 --> 00:03:20.240
which is built on
top of of NFC.

00:03:23.250 --> 00:03:25.730
And these have existed
since ICS.

00:03:25.730 --> 00:03:26.760
We had Android Beam.

00:03:26.760 --> 00:03:30.430
And then Wi-Fi and Bluetooth
have done that much before.

00:03:30.430 --> 00:03:34.870
So in terms of what's new for
Jelly Bean, we introduced

00:03:34.870 --> 00:03:37.830
something called Wi-Fi Direct
Service Discovery and Network

00:03:37.830 --> 00:03:38.550
Service Discovery.

00:03:38.550 --> 00:03:42.120
And these are the two topics
we'll cover in detail.

00:03:42.120 --> 00:03:45.860
With the launch of ICS, we
introduced Wi-Fi Direct, which

00:03:45.860 --> 00:03:49.250
is a peer-to-peer technology
for connecting devices.

00:03:49.250 --> 00:03:51.420
And with Jelly Bean, we've kind
of introduced Service

00:03:51.420 --> 00:03:53.820
Discovery along with Wi-Fi.

00:03:53.820 --> 00:03:57.830
So first look at
what Wi-Fi is.

00:03:57.830 --> 00:04:00.660
Like I mentioned, it
allows peers--

00:04:00.660 --> 00:04:03.900
which is devices within
their Wi-Fi range--

00:04:03.900 --> 00:04:06.080
to find and discover
each other.

00:04:06.080 --> 00:04:09.250
And once they discover each
other, they perform discovery.

00:04:09.250 --> 00:04:12.320
They are able to connect and
then use sockets for

00:04:12.320 --> 00:04:13.570
transferring data.

00:04:16.000 --> 00:04:21.970
And it's kind of interesting,
because the Wi-Fi range is

00:04:21.970 --> 00:04:24.250
much larger than the
Bluetooth range.

00:04:24.250 --> 00:04:26.230
And also the connection
is high-speed

00:04:26.230 --> 00:04:27.310
connection with Wi-Fi.

00:04:27.310 --> 00:04:31.890
So it is a very interesting
and fast way of connecting

00:04:31.890 --> 00:04:33.275
high-speed connections
between devices.

00:04:36.980 --> 00:04:41.310
Which brings us to the new APIs
in Jelly Bean, which is

00:04:41.310 --> 00:04:43.260
Wi-Fi Service Discovery.

00:04:43.260 --> 00:04:47.010
So with regular Wi-Fi Direct,
which was introduced in ICS,

00:04:47.010 --> 00:04:48.390
you could connect to devices.

00:04:48.390 --> 00:04:51.480
And once you connect, you
first perform discovery.

00:04:51.480 --> 00:04:55.390
And once a discovery is done,
you get the network details of

00:04:55.390 --> 00:04:57.930
the other device, which is the
IP address to connect to.

00:04:57.930 --> 00:05:00.170
And then you connect
to the device.

00:05:00.170 --> 00:05:03.725
Once you connect to the device,
your application sort

00:05:03.725 --> 00:05:07.170
of has to publish the services
available through the

00:05:07.170 --> 00:05:08.420
application.

00:05:11.190 --> 00:05:12.990
If your app is a game--

00:05:12.990 --> 00:05:14.300
a Market Play game--

00:05:14.300 --> 00:05:17.755
so only when the other device
was able to connect to you,

00:05:17.755 --> 00:05:22.290
you can say hey, I have
multiplayer lobby available.

00:05:22.290 --> 00:05:25.850
And this is how you start
exchanging data with me.

00:05:25.850 --> 00:05:29.810
So this was actually a very
good user experience, that

00:05:29.810 --> 00:05:31.970
you'd have to connect to devices
to figure out what

00:05:31.970 --> 00:05:34.050
services are available.

00:05:34.050 --> 00:05:36.370
So that's where the Wi-Fi
Service Discovery comes in--

00:05:36.370 --> 00:05:38.220
Wi-Fi Direct Services
Discovery.

00:05:38.220 --> 00:05:41.910
And it's a pre-association
discovery.

00:05:41.910 --> 00:05:46.330
So you can actually find
services before establishing

00:05:46.330 --> 00:05:50.210
or associating yourself to the
AP, which is the access point.

00:05:50.210 --> 00:05:52.400
So you can figure out what
services are available.

00:05:52.400 --> 00:05:55.420
And if you're interested, you
can connect to a particular

00:05:55.420 --> 00:05:58.630
device which is hosting that
service, or the app that is

00:05:58.630 --> 00:06:01.690
hosting that service
on the device.

00:06:01.690 --> 00:06:03.160
So the devices--

00:06:03.160 --> 00:06:05.190
and this comes from
Wi-Fi direct--

00:06:05.190 --> 00:06:08.210
the devices are not connected to
a network, or don't have to

00:06:08.210 --> 00:06:09.930
be connected to a network.

00:06:09.930 --> 00:06:13.840
You do not have to have an
existing Wi-Fi network

00:06:13.840 --> 00:06:15.610
around-- a classic router-based

00:06:15.610 --> 00:06:17.390
access point around.

00:06:17.390 --> 00:06:21.500
The devices can just connect to
each other whenever they're

00:06:21.500 --> 00:06:23.690
near the Wi-Fi range
of each other.

00:06:23.690 --> 00:06:26.700
Which basically means, before
they're assigned an IP address

00:06:26.700 --> 00:06:29.930
on the network, they are able
to discover each other.

00:06:29.930 --> 00:06:34.950
They discover the services and
the device itself, and then if

00:06:34.950 --> 00:06:37.220
interested in the service,
establish a connection.

00:06:37.220 --> 00:06:40.590
So this actually leads to
a really improved user

00:06:40.590 --> 00:06:42.190
experience.

00:06:42.190 --> 00:06:45.060
So you browse printing services
find transfer

00:06:45.060 --> 00:06:46.900
services that are available
nearby.

00:06:46.900 --> 00:06:49.137
And then you connect to a
device that you want to.

00:07:03.600 --> 00:07:08.740
OK, some of the key APIs
for Wi-Fi P2P are--

00:07:08.740 --> 00:07:13.614
sorry, we've got a video
feed from someone--

00:07:13.614 --> 00:07:14.100
let me see.

00:07:14.100 --> 00:07:16.530
MALE SPEAKER: Are we getting
some echo, Anirudh?

00:07:23.060 --> 00:07:26.850
ANIRUDH DEWANI: So some of the
key APIs available as part of

00:07:26.850 --> 00:07:31.470
the Wi-Fi P2P Service
Discovery APIs are--

00:07:31.470 --> 00:07:33.110
and these are the
objects listed--

00:07:33.110 --> 00:07:36.620
there's a Wi-Fi P2P service
info which encapsulates a

00:07:36.620 --> 00:07:38.840
Wi-Fi P2P service.

00:07:38.840 --> 00:07:41.360
And P2P here stands
for peer-to-peer,

00:07:41.360 --> 00:07:43.000
which is Wi-Fi direct.

00:07:43.000 --> 00:07:45.250
So there's a Wi-Fi direct
service involved which

00:07:45.250 --> 00:07:50.130
encapsulates a service which
you want to publish.

00:07:50.130 --> 00:07:52.890
Then there's a service
request.

00:07:52.890 --> 00:07:55.870
And then there are two
specializations of these,

00:07:55.870 --> 00:07:57.960
service request and
service info.

00:07:57.960 --> 00:07:59.180
One is a DNS SD--

00:07:59.180 --> 00:08:01.920
this is DNS-based service
discovery.

00:08:01.920 --> 00:08:04.620
And the other one is UPnP, and
that is a popular Universal

00:08:04.620 --> 00:08:07.460
Plug-and-Play protocol that
you find in a lot of media

00:08:07.460 --> 00:08:10.090
devices and peer and their
compliant devices.

00:08:10.090 --> 00:08:15.900
And this is specialized for
media technologies like

00:08:15.900 --> 00:08:19.050
rendering and publishing streams
of audio and video.

00:08:19.050 --> 00:08:23.870
So there's a specialization
for DNS space service, and

00:08:23.870 --> 00:08:25.570
UPnP-based service.

00:08:29.260 --> 00:08:33.159
So now we're going to get a bit
more technical and take a

00:08:33.159 --> 00:08:36.340
look at coding and some code
snippets to see how does this

00:08:36.340 --> 00:08:38.350
actually work.

00:08:38.350 --> 00:08:41.100
So the first thing you want to
do from device A, which is the

00:08:41.100 --> 00:08:44.860
first device that's interested
in connecting, or is

00:08:44.860 --> 00:08:47.550
interested in being part of a
peer-to-peer exchange, will

00:08:47.550 --> 00:08:48.330
publish a service.

00:08:48.330 --> 00:08:50.740
So before you can actually
connect to a service, you need

00:08:50.740 --> 00:08:53.500
to publish a service.

00:08:53.500 --> 00:08:56.670
So you create a local
service object.

00:08:56.670 --> 00:09:00.440
And what you do is you
have an instance name

00:09:00.440 --> 00:09:01.520
and a service type.

00:09:01.520 --> 00:09:03.570
So the instance name is
something that your

00:09:03.570 --> 00:09:04.240
application is.

00:09:04.240 --> 00:09:08.260
So this could be test, or
myChat or myPnPService.

00:09:08.260 --> 00:09:13.360
And then there is a service
type, which is a standard name

00:09:13.360 --> 00:09:14.300
that's followed.

00:09:14.300 --> 00:09:19.000
And this list of names are
registered with IANA, which is

00:09:19.000 --> 00:09:22.030
body that manages the
service types.

00:09:22.030 --> 00:09:25.830
And so if you're publishing a
service that's not already

00:09:25.830 --> 00:09:29.860
included as part of the IANA
services, you can register

00:09:29.860 --> 00:09:33.030
your service type with
the IANA body then

00:09:33.030 --> 00:09:34.500
use a service type.

00:09:34.500 --> 00:09:39.100
So this would typically be
something, for example, for

00:09:39.100 --> 00:09:41.270
chat service, we use something
called presence.

00:09:41.270 --> 00:09:44.250
And presence is the name for
chat service so your service

00:09:44.250 --> 00:09:47.360
type will be presence.

00:09:47.360 --> 00:09:51.140
And similarly, there are names
for printing and for other

00:09:51.140 --> 00:09:52.900
network services.

00:09:52.900 --> 00:09:56.310
So what we've seen is, you're
able to create a

00:09:56.310 --> 00:09:57.470
local service object.

00:09:57.470 --> 00:10:00.960
And then you register this local
service with the Wi-Fi

00:10:00.960 --> 00:10:03.080
P2P manager.

00:10:03.080 --> 00:10:07.940
Wi-Fi P2P manager is a system
utility that's a frame of

00:10:07.940 --> 00:10:11.460
class that's available to you,
just like the connectivity

00:10:11.460 --> 00:10:12.780
manager or the telephony
manager.

00:10:12.780 --> 00:10:15.890
You say
contacts.getSystemService and

00:10:15.890 --> 00:10:18.770
then you say Wi-Fi P2P manager,
and you get a handle

00:10:18.770 --> 00:10:20.020
to the manager object.

00:10:24.620 --> 00:10:28.090
So we've seen the part of where
a device is able to

00:10:28.090 --> 00:10:28.890
publish a service.

00:10:28.890 --> 00:10:31.110
Now, on the peer device which
actually wants to use the

00:10:31.110 --> 00:10:34.040
service or consume the service,
you will create a

00:10:34.040 --> 00:10:37.360
service discovery request.

00:10:37.360 --> 00:10:40.170
And then you will go ahead and
perform a service discovery.

00:10:40.170 --> 00:10:43.470
So first you create an
associated object that

00:10:43.470 --> 00:10:45.770
describes your request.

00:10:45.770 --> 00:10:49.470
Basically you have some fields
that we will look into.

00:10:49.470 --> 00:10:51.440
And then you ask the
Wi-Fi P2P manager

00:10:51.440 --> 00:10:52.852
to perform the discovery.

00:10:57.210 --> 00:10:59.482
So when you're implementing
this in Android, the first

00:10:59.482 --> 00:11:02.600
thing is let's set some
of the permissions.

00:11:02.600 --> 00:11:05.590
You need a change Wi-Fi state
and an access Wi-Fi state

00:11:05.590 --> 00:11:06.740
permission.

00:11:06.740 --> 00:11:08.470
Actually you need internet
permission.

00:11:08.470 --> 00:11:11.100
It's not because we are
going to exchange

00:11:11.100 --> 00:11:14.180
data off the internet.

00:11:14.180 --> 00:11:17.010
It's only because we are going
to use sockets to communicate

00:11:17.010 --> 00:11:18.110
between the devices.

00:11:18.110 --> 00:11:21.076
And the sockets main
permission is

00:11:21.076 --> 00:11:23.800
typed to sockets usage.

00:11:23.800 --> 00:11:25.600
So you would require
this permission as

00:11:25.600 --> 00:11:26.950
well in your manifest.

00:11:30.080 --> 00:11:34.360
So now, at a code level, these
are the snippets of code.

00:11:34.360 --> 00:11:38.310
And it's pretty easy
to write this code.

00:11:38.310 --> 00:11:41.880
Just do three lines
per operation

00:11:41.880 --> 00:11:44.810
that you want to perform.

00:11:44.810 --> 00:11:47.330
So the first thing to
do to add as a peer

00:11:47.330 --> 00:11:48.430
adding a local service.

00:11:48.430 --> 00:11:51.210
So here's the service class that
we talked about earlier

00:11:51.210 --> 00:11:52.390
as a key API.

00:11:52.390 --> 00:11:55.410
This is Wi-Fi P2P DNS
service info.

00:11:55.410 --> 00:11:58.210
And we just use a static
initializer on

00:11:58.210 --> 00:11:59.790
that same new instance.

00:11:59.790 --> 00:12:02.430
And the two things that you
are looking at, the

00:12:02.430 --> 00:12:06.160
parameters, they are
the instance name

00:12:06.160 --> 00:12:07.080
and the service type.

00:12:07.080 --> 00:12:10.540
So the instance name is our
instance of a service, which

00:12:10.540 --> 00:12:12.460
is _test here.

00:12:12.460 --> 00:12:17.380
And because it's a kind of chat
m we are using a standard

00:12:17.380 --> 00:12:18.760
name for the chat service.

00:12:18.760 --> 00:12:21.320
And notice the naming
convention here.

00:12:21.320 --> 00:12:24.160
This is followed for all the
services type for all

00:12:24.160 --> 00:12:25.140
DNS-based services.

00:12:25.140 --> 00:12:28.480
So it's underscore service type,
underscore the protocol

00:12:28.480 --> 00:12:30.890
it's going to follow
on the network.

00:12:30.890 --> 00:12:33.100
So the third thing is
really interesting.

00:12:33.100 --> 00:12:34.190
It's record.

00:12:34.190 --> 00:12:38.020
And this is a DNS
text recorder.

00:12:38.020 --> 00:12:40.590
And this is also pretty much
standard, and this gathers

00:12:40.590 --> 00:12:42.950
additional metadata about
your service.

00:12:42.950 --> 00:12:46.630
So for example, if it's a chat
service, along with saying

00:12:46.630 --> 00:12:50.080
that you have a chat service,
you also want to say that, as

00:12:50.080 --> 00:12:53.650
a user, I am available to chat
at this point of time, or I am

00:12:53.650 --> 00:12:55.150
busy and I cannot chat.

00:12:55.150 --> 00:12:58.100
So the service is available,
but you are busy.

00:12:58.100 --> 00:12:59.740
And you cannot respond
to chat messages.

00:12:59.740 --> 00:13:03.880
So DNS TXTRECORD is
a key value thing.

00:13:03.880 --> 00:13:05.610
And this is where you can
publish some additional

00:13:05.610 --> 00:13:08.205
metadata about your service.

00:13:08.205 --> 00:13:11.230
You can keep publishing these
records, which these records

00:13:11.230 --> 00:13:12.760
can change over time.

00:13:12.760 --> 00:13:14.560
So your service is published.

00:13:14.560 --> 00:13:16.050
And it's available as
a chat service.

00:13:16.050 --> 00:13:19.500
And then you can keep pushing
the DNS TXTRECORD, saying, I'm

00:13:19.500 --> 00:13:21.210
available at this point
of time, I'm not

00:13:21.210 --> 00:13:22.460
available, I'm busy.

00:13:26.500 --> 00:13:30.370
So once you've done that, we
add the local service.

00:13:30.370 --> 00:13:33.670
And the mManager object that
you'll see here is the Wi-Fi

00:13:33.670 --> 00:13:35.030
P2P manager.

00:13:35.030 --> 00:13:37.140
And then you add this
local service.

00:13:37.140 --> 00:13:39.190
And there is a callback.

00:13:39.190 --> 00:13:42.785
Many operations or almost all
operations of Wi-Fi P2P direct

00:13:42.785 --> 00:13:47.670
and DNS network service
discovery are asynchronous.

00:13:47.670 --> 00:13:49.810
And you always register
a callback

00:13:49.810 --> 00:13:52.910
for success or failure.

00:13:52.910 --> 00:13:54.430
So this is a standard
template for all

00:13:54.430 --> 00:14:01.290
operations of service discovery.

00:14:01.290 --> 00:14:05.260
So we instituted a service info
object, which had our

00:14:05.260 --> 00:14:08.490
instance name and service type
on the DNS TXTRECORD.

00:14:08.490 --> 00:14:11.690
And so once we've created that,
we go ahead and say

00:14:11.690 --> 00:14:14.380
myManager.addLocalService.

00:14:14.380 --> 00:14:17.145
And as soon as you do that, your
service is published over

00:14:17.145 --> 00:14:20.190
the Wi-Fi network.

00:14:20.190 --> 00:14:22.350
And in case there is an editor,
you can handle that

00:14:22.350 --> 00:14:24.440
error and show appropriate
messages to the user.

00:14:29.040 --> 00:14:32.810
So like I said, all the
operations are asynchronous.

00:14:32.810 --> 00:14:35.220
So every time you perform an
operation, you're going to

00:14:35.220 --> 00:14:38.830
pass a callback or register for
an action listener, like a

00:14:38.830 --> 00:14:40.670
success/failure.

00:14:40.670 --> 00:14:43.400
And because it's asynchronous
in nature, you don't have to

00:14:43.400 --> 00:14:46.340
worry about where you're
placing this call.

00:14:46.340 --> 00:14:47.860
It can be in your main thread.

00:14:47.860 --> 00:14:50.480
The underlying network call is
always off the main thread.

00:14:50.480 --> 00:14:54.150
So you don't have to worry about
writing asynchronous.

00:14:54.150 --> 00:14:56.880
So it's in task and placing
these calls.

00:14:56.880 --> 00:15:00.730
They're inherently
asynchronous.

00:15:00.730 --> 00:15:04.335
So we've now published
a service with those

00:15:04.335 --> 00:15:05.585
two lines of code.

00:15:07.480 --> 00:15:13.250
So the other peer that's in
present been consuming where

00:15:13.250 --> 00:15:17.030
your app is running, if it wants
to discover the nearby

00:15:17.030 --> 00:15:20.940
service and connect to it, it
first needs to create a DNS as

00:15:20.940 --> 00:15:25.240
the service response listener,
which basically is a callback

00:15:25.240 --> 00:15:29.090
that has one method that says
onDnsSdServiceAvailable.

00:15:29.090 --> 00:15:31.000
And we talked about UPnP.

00:15:31.000 --> 00:15:34.370
And this is the same kind of
mechanism that we follow

00:15:34.370 --> 00:15:35.410
around for UPnP.

00:15:35.410 --> 00:15:38.290
So when there's a UPnP service
available, you would see

00:15:38.290 --> 00:15:41.030
onPnpServiceAvailable
with a UPnP

00:15:41.030 --> 00:15:42.550
service response listener.

00:15:42.550 --> 00:15:47.590
So this is a callback-- the
method around the anonymous

00:15:47.590 --> 00:15:51.240
implementation there is called
when the framework is

00:15:51.240 --> 00:15:52.785
available to discover
a service.

00:15:52.785 --> 00:15:55.200
When the Android device
discovers a service, it's

00:15:55.200 --> 00:15:56.670
going to give you a
callback there.

00:15:56.670 --> 00:16:01.580
So the first thing you do is
you initiate a service

00:16:01.580 --> 00:16:03.250
response listener.

00:16:03.250 --> 00:16:04.660
And you set it in
the managers.

00:16:04.660 --> 00:16:08.350
So you say, Wi-Fi P2P
manager, here is my

00:16:08.350 --> 00:16:10.490
service response listener.

00:16:10.490 --> 00:16:12.105
In case there is a service,
call me back.

00:16:18.040 --> 00:16:20.970
So we've set our response
listener.

00:16:20.970 --> 00:16:23.590
And then what we want
to do is actually

00:16:23.590 --> 00:16:24.890
create a service request.

00:16:24.890 --> 00:16:26.180
This, once again, if
you remember, is

00:16:26.180 --> 00:16:27.540
one of the key APIs.

00:16:27.540 --> 00:16:33.787
So you will say, use the Wi-Fi
P2P service request object to

00:16:33.787 --> 00:16:34.780
get a new instance--

00:16:34.780 --> 00:16:36.370
again, a static initializer
there.

00:16:36.370 --> 00:16:40.360
And once you're able to get a
service request, you add the

00:16:40.360 --> 00:16:42.880
service request to the
Wi-Fi P2P manager.

00:16:42.880 --> 00:16:44.890
And again, there's an
asynchronous callback

00:16:44.890 --> 00:16:46.300
success/failure.

00:16:46.300 --> 00:16:48.340
Once this is done, you actually
go ahead and perform

00:16:48.340 --> 00:16:51.020
discovery by saying
mManager.discoverServices.

00:16:51.020 --> 00:16:54.430
And then this is when the
firmware actually starts

00:16:54.430 --> 00:16:55.860
discovering the services.

00:16:55.860 --> 00:16:57.710
You've already registered
a response listener.

00:16:57.710 --> 00:16:59.850
You've given your
service request.

00:16:59.850 --> 00:17:01.890
And now the framework is able
to perform discovery.

00:17:01.890 --> 00:17:04.790
And if it finds something, it's
able to callback on your

00:17:04.790 --> 00:17:06.040
interfaces.

00:17:11.050 --> 00:17:15.560
So once the DNS SD service is
available, you will also see

00:17:15.560 --> 00:17:18.460
the Wi-Fi P2P device object
along with it.

00:17:18.460 --> 00:17:22.079
This is basically a structure
that has details about the

00:17:22.079 --> 00:17:25.540
peer IP and the other
connection details.

00:17:25.540 --> 00:17:28.369
And this is when you can
actually go ahead and form a

00:17:28.369 --> 00:17:28.900
network connection.

00:17:28.900 --> 00:17:32.970
So you're able to query
the Wi-Fi P2P

00:17:32.970 --> 00:17:34.620
manager for nearby services.

00:17:34.620 --> 00:17:37.680
And suppose you find the service
of maybe a printing

00:17:37.680 --> 00:17:39.550
service, or maybe a chat
service that you

00:17:39.550 --> 00:17:41.090
want connect to.

00:17:41.090 --> 00:17:44.220
At this point of time-- which is
after performing discovery,

00:17:44.220 --> 00:17:48.310
and the thing that gives you a
callback on your interface--

00:17:48.310 --> 00:17:50.380
you can now receive the
connection details and go

00:17:50.380 --> 00:17:54.200
ahead and connect with
other device.

00:17:54.200 --> 00:17:57.680
And this basically means
initiating an access point

00:17:57.680 --> 00:18:01.420
association, and so once this
is done you're on the same

00:18:01.420 --> 00:18:01.970
network now.

00:18:01.970 --> 00:18:05.950
You get assigned IP addresses
on the same network, at the

00:18:05.950 --> 00:18:07.630
same Wi-Fi P2P network.

00:18:07.630 --> 00:18:11.760
And once this is done, you're
able to open sockets because

00:18:11.760 --> 00:18:13.185
you're on the same
network now.

00:18:13.185 --> 00:18:15.700
You can open TCP sockets and
start exchanging data, which

00:18:15.700 --> 00:18:17.070
is your app data.

00:18:17.070 --> 00:18:19.320
So what the framework is
really giving you is a

00:18:19.320 --> 00:18:25.870
mechanism, it's sort of a
framework for discovering and

00:18:25.870 --> 00:18:27.120
consuming other services.

00:18:31.300 --> 00:18:34.830
So this was completely Wi-Fi
P2P, which is based on a Wi-Fi

00:18:34.830 --> 00:18:37.390
peer-to-peer network.

00:18:37.390 --> 00:18:39.870
So the condition there was,
there doesn't have to be an

00:18:39.870 --> 00:18:40.960
existing network.

00:18:40.960 --> 00:18:43.680
Two devices capable of Wi-Fi
P2P direct will find each

00:18:43.680 --> 00:18:46.390
other, discover the
services, and go.

00:18:46.390 --> 00:18:49.596
And the other thing is, the
other API that we just linked

00:18:49.596 --> 00:18:51.040
with network service
discovery.

00:18:51.040 --> 00:18:56.230
And this is basically based on
the fact that you're already

00:18:56.230 --> 00:18:59.280
part of the network that
you want to join

00:18:59.280 --> 00:18:59.930
and discover services.

00:18:59.930 --> 00:19:03.330
So you're connected to
the network already.

00:19:03.330 --> 00:19:06.680
In this network, you want to
discover services which are

00:19:06.680 --> 00:19:08.520
available in your
local network.

00:19:08.520 --> 00:19:11.300
So this is pretty similar to
Bonjour, if you've worked with

00:19:11.300 --> 00:19:12.990
Bonjour on the Apple systems.

00:19:12.990 --> 00:19:16.860
Or there are other Zeroconf
networking solutions available

00:19:16.860 --> 00:19:18.470
on DNS and other platforms.

00:19:18.470 --> 00:19:22.930
And this is basically bringing
the same Multicast DNS-based

00:19:22.930 --> 00:19:25.480
service discovery to Android.

00:19:25.480 --> 00:19:27.530
And we call it network
service discovery.

00:19:31.160 --> 00:19:34.530
And like I mentioned, it's
different from Wi-Fi Direct,

00:19:34.530 --> 00:19:38.240
because Wi-Fi Direct we didn't
really need the network.

00:19:38.240 --> 00:19:39.830
And this is when you're
actually logged

00:19:39.830 --> 00:19:42.980
in to a local network.

00:19:42.980 --> 00:19:46.840
Suppose you bring your device
to your workplace and you

00:19:46.840 --> 00:19:51.470
connect to your corporate
internet, and you have some

00:19:51.470 --> 00:19:54.562
printers available and you
want to print maybe some

00:19:54.562 --> 00:19:59.870
document, some PDF from
your mobile phone.

00:19:59.870 --> 00:20:02.520
And many other printers
understand what is network

00:20:02.520 --> 00:20:04.360
service discovery and
Multicast DNS.

00:20:04.360 --> 00:20:08.080
So you can discover these
printing services available

00:20:08.080 --> 00:20:11.250
and then go ahead and print
after you are able to make the

00:20:11.250 --> 00:20:12.500
connection.

00:20:14.280 --> 00:20:19.370
And again, file sharing is one
of the big things on the local

00:20:19.370 --> 00:20:24.690
network, and multiplayer gaming
is really useful and

00:20:24.690 --> 00:20:28.060
can really benefit from
technologies like Wi-Fi, P2P

00:20:28.060 --> 00:20:29.895
Direct, and network
service discovery.

00:20:34.340 --> 00:20:38.400
So we're going to technical
details of how it works.

00:20:38.400 --> 00:20:41.415
In this case, you will
create something a

00:20:41.415 --> 00:20:42.665
registration listener.

00:20:44.900 --> 00:20:47.780
This is the device that's
publishing a service.

00:20:47.780 --> 00:20:49.855
This may already be an existing
device on the

00:20:49.855 --> 00:20:52.260
network, or it may be an
Android device which is

00:20:52.260 --> 00:20:54.296
offering maybe a multiplayer
gaming

00:20:54.296 --> 00:20:57.870
lobby, or a chat service.

00:20:57.870 --> 00:21:00.730
And this is how to go ahead
and publish its service.

00:21:00.730 --> 00:21:03.280
So you create something called
the registration listener.

00:21:03.280 --> 00:21:09.070
And in terms of DNS-based
network service discovery, we

00:21:09.070 --> 00:21:11.880
call it registration instead of
saying publishing a service

00:21:11.880 --> 00:21:12.640
on the network.

00:21:12.640 --> 00:21:15.090
So naming convention
is followed here.

00:21:15.090 --> 00:21:17.930
So you register your service on
the network by creating a

00:21:17.930 --> 00:21:19.470
callback for registration
listener.

00:21:19.470 --> 00:21:22.920
And then you, again, have this
whole same kind of details.

00:21:22.920 --> 00:21:25.570
You have the instance on
the service the type.

00:21:25.570 --> 00:21:27.540
And the service type is
compliant with IANA.

00:21:31.940 --> 00:21:34.420
And so here is some code.

00:21:34.420 --> 00:21:37.870
Basically it's, again, a
callback on anonymous

00:21:37.870 --> 00:21:40.540
implementation of registration
listener, which has some

00:21:40.540 --> 00:21:43.370
standard methods, which is
your service has been

00:21:43.370 --> 00:21:43.580
registered--

00:21:43.580 --> 00:21:46.940
onServiceRegistered,
onRegistrationFailed,

00:21:46.940 --> 00:21:50.220
onServiceUnregisered, and
onUnregistrationFailed.

00:21:50.220 --> 00:21:53.640
So the framework is going to
call any of these methods,

00:21:53.640 --> 00:21:57.130
depending on what really
happened with your request.

00:21:57.130 --> 00:22:01.030
So you can listen to these
notifications and show the

00:22:01.030 --> 00:22:02.910
proper URL go-ahead
with actually

00:22:02.910 --> 00:22:04.160
connecting to devices.

00:22:07.630 --> 00:22:10.460
So once you've created a
registration listener, what

00:22:10.460 --> 00:22:12.870
you want to create is a
description for your service.

00:22:12.870 --> 00:22:15.220
And again, we use something
called NSD service info.

00:22:15.220 --> 00:22:18.340
The class is similar to those we
looked at earlier as Wi-Fi

00:22:18.340 --> 00:22:20.200
P2P service info.

00:22:20.200 --> 00:22:23.685
So the NSD service info here,
we set the service name, the

00:22:23.685 --> 00:22:25.830
service type, and the network
port it's going to run on.

00:22:25.830 --> 00:22:28.230
Because we are already in the
network, we can specify what

00:22:28.230 --> 00:22:30.110
port my service will run on.

00:22:30.110 --> 00:22:33.710
And you get a handle to NSD
manager, same as Wi-Fi P2P

00:22:33.710 --> 00:22:35.440
Direct and other system
services.

00:22:35.440 --> 00:22:38.140
You say Context.getSystemService
and

00:22:38.140 --> 00:22:40.060
get a handle to NSD manager.

00:22:40.060 --> 00:22:43.135
And once again the manager
handle, you create a

00:22:43.135 --> 00:22:44.050
registration listener.

00:22:44.050 --> 00:22:46.810
And you can say, register my
service, here is the info of

00:22:46.810 --> 00:22:49.230
the service, and here is
registration listener, which

00:22:49.230 --> 00:22:52.733
is the callback where the
framework will call you back

00:22:52.733 --> 00:22:55.510
depending on what goes
on with your request.

00:22:55.510 --> 00:22:58.900
So with this, now you've
registered your server.

00:22:58.900 --> 00:23:01.600
So as you can see it's just two,
three lines of code per

00:23:01.600 --> 00:23:03.315
operation, and it's pretty
easy to implement.

00:23:06.110 --> 00:23:10.540
So now you've registered your
service on the network.

00:23:10.540 --> 00:23:16.690
Or a DNS-based network NSD
service you've registered.

00:23:16.690 --> 00:23:19.260
And now you want to discover
those services.

00:23:19.260 --> 00:23:22.290
So what really happens behind
the scene is Multicast DNS

00:23:22.290 --> 00:23:23.460
technologies involved here.

00:23:23.460 --> 00:23:25.990
And you're listening to
a network broadcast.

00:23:25.990 --> 00:23:31.280
And using some framework APIs,
you can filter out what

00:23:31.280 --> 00:23:34.870
services you want to consume
or do not want to consume.

00:23:34.870 --> 00:23:37.040
And again, it's asynchronous
API just

00:23:37.040 --> 00:23:39.430
like Wi-Fi P2P Direct.

00:23:39.430 --> 00:23:41.680
All the operations are performed
off the main thread.

00:23:41.680 --> 00:23:45.940
So you could make your
call-in here.

00:23:45.940 --> 00:23:49.440
So just like registration
listener, when you're

00:23:49.440 --> 00:23:51.380
discovering services you
create something like

00:23:51.380 --> 00:23:52.800
discovery listener.

00:23:52.800 --> 00:23:57.190
And this will be used to
initiate service discovery.

00:23:57.190 --> 00:24:01.190
Again, as you would have
guessed, it's a callback which

00:24:01.190 --> 00:24:04.610
the framework is going to use
to call you back when it's

00:24:04.610 --> 00:24:05.860
able to find something
for you.

00:24:05.860 --> 00:24:07.540
So there is onDiscoveryStarted--

00:24:07.540 --> 00:24:10.790
the framework has started
discovering services.

00:24:10.790 --> 00:24:12.880
Again, time to update your
UR, tell the user

00:24:12.880 --> 00:24:14.280
about locating service.

00:24:14.280 --> 00:24:18.162
You're finding finding services
of OnServiceFound.

00:24:18.162 --> 00:24:20.900
You get the callback with the
service info, what that

00:24:20.900 --> 00:24:22.220
service is.

00:24:22.220 --> 00:24:24.390
And this is where you can
perform [INAUDIBLE].

00:24:24.390 --> 00:24:26.692
If you're not interested in
connecting to the service you

00:24:26.692 --> 00:24:28.320
can reroute the service.

00:24:28.320 --> 00:24:30.650
And there's some other callbacks
when the service is

00:24:30.650 --> 00:24:34.236
lost, suppose the device goes
out of network or goes down.

00:24:34.236 --> 00:24:35.540
You get the service lost.

00:24:38.150 --> 00:24:40.980
Discovery is sort of
an ongoing process.

00:24:40.980 --> 00:24:41.990
[INAUDIBLE].

00:24:41.990 --> 00:24:45.000
So you can actually request
the framework to stop

00:24:45.000 --> 00:24:46.500
discovering.

00:24:46.500 --> 00:24:49.890
And that's when you get the
callback on discovery stop.

00:24:49.890 --> 00:24:53.420
And some other callbacks, if
something failed, discovery

00:24:53.420 --> 00:24:55.061
will stop discovery
fail, you get a

00:24:55.061 --> 00:24:57.690
couple of other callbacks.

00:24:57.690 --> 00:25:03.250
So now you've created a
discovery listener.

00:25:03.250 --> 00:25:06.500
And what that means now is
to request discovery.

00:25:06.500 --> 00:25:10.180
So you'd see an NSD manager
dot discover services.

00:25:10.180 --> 00:25:11.710
Here is my discovery listener.

00:25:11.710 --> 00:25:14.706
And you get the callbacks when
the framework has an update

00:25:14.706 --> 00:25:18.530
for you, which is a table to
perform discovery and find

00:25:18.530 --> 00:25:19.590
some service, or it failed.

00:25:19.590 --> 00:25:22.010
It gives you a callback on
your discovery listener.

00:25:25.530 --> 00:25:29.905
So all good, if the framework is
able to find your service.

00:25:33.080 --> 00:25:35.700
And this is on the callback
onServiceFollow.

00:25:35.700 --> 00:25:38.860
When it's able to do that, you
initiate something called a

00:25:38.860 --> 00:25:43.240
resolve listener, which is to
find network details of the

00:25:43.240 --> 00:25:45.380
peer so that you can connect.

00:25:45.380 --> 00:25:50.200
So the resolve listener will
have callbacks again when the

00:25:50.200 --> 00:25:52.070
framework is the able to resolve
the service for you,

00:25:52.070 --> 00:25:54.890
which is to resolve
the IP for you.

00:25:54.890 --> 00:25:58.480
And then you call the framework
once you create the

00:25:58.480 --> 00:26:02.240
resolve listener and provide
them implementation, you call

00:26:02.240 --> 00:26:04.390
NSD manager to resolve
service.

00:26:04.390 --> 00:26:06.100
And that's it.

00:26:06.100 --> 00:26:10.690
You get the IP details of the
device of the network machine

00:26:10.690 --> 00:26:12.200
that's publishing the service.

00:26:12.200 --> 00:26:15.090
And it's time for you
now to connect.

00:26:15.090 --> 00:26:18.440
And the connection is basically
sockets, like we

00:26:18.440 --> 00:26:19.480
discussed earlier.

00:26:19.480 --> 00:26:20.890
You're on the network.

00:26:20.890 --> 00:26:23.300
And if the service is
TCP-based, you get a

00:26:23.300 --> 00:26:24.550
TCP-software or datagram.

00:26:28.190 --> 00:26:34.040
So to summarize, we've looked at
two new key APIs, which we

00:26:34.040 --> 00:26:35.710
like to call connectivity
APIs.

00:26:35.710 --> 00:26:40.330
And these are Wi-Fi P2P service
discovery and Wi-Fi

00:26:40.330 --> 00:26:43.250
Direct service discovery and
network service discovery.

00:26:43.250 --> 00:26:48.245
So Wi-Fi P2P service discovery
protocol has a DNS and support

00:26:48.245 --> 00:26:49.955
for UPnP implementation.

00:26:53.234 --> 00:26:57.930
The thing about UPnP balance,
it's closely tied up with,

00:26:57.930 --> 00:27:00.910
associated with the DLNA
protocol that's used between

00:27:00.910 --> 00:27:03.080
many devices.

00:27:03.080 --> 00:27:08.210
Your HD televisions, your
PlayStations, your Xboxes--

00:27:08.210 --> 00:27:08.670
a lot of media--

00:27:08.670 --> 00:27:12.380
DVD players, Blu-Ray players,
they're using DLNA protocol to

00:27:12.380 --> 00:27:14.050
share and see media.

00:27:14.050 --> 00:27:18.370
So one device is acting as
a streaming device that's

00:27:18.370 --> 00:27:19.090
streaming the media.

00:27:19.090 --> 00:27:22.925
The other acts as a renderer and
is able to show what the

00:27:22.925 --> 00:27:24.130
other device is streaming.

00:27:24.130 --> 00:27:29.420
And this is while working on top
of DLNA, UPnP protocols.

00:27:29.420 --> 00:27:33.200
So Wi-Fi P2P service discovery
provides you the ability to

00:27:33.200 --> 00:27:35.695
connect and publish
these services.

00:27:35.695 --> 00:27:40.000
You could the media renderer
or you could share media.

00:27:40.000 --> 00:27:43.390
And then there is network
service discovery, which is

00:27:43.390 --> 00:27:46.700
sort of a Zeroconf networking
thing that's

00:27:46.700 --> 00:27:49.560
sort similar to Bonjour.

00:27:49.560 --> 00:27:51.890
And then you're able
to find DNS-based

00:27:51.890 --> 00:27:55.010
services on the network.

00:27:55.010 --> 00:27:58.750
And with this you can find
services when you're not

00:27:58.750 --> 00:28:02.470
connected to the network using
Wi-Fi P2P Direct, and when you

00:28:02.470 --> 00:28:03.970
are connected to
a network using

00:28:03.970 --> 00:28:06.800
network service discovery.

00:28:06.800 --> 00:28:11.680
So this brings us to the end
of the presentation here.

00:28:11.680 --> 00:28:12.920
MALE SPEAKER: Thanks, Anirudh.

00:28:12.920 --> 00:28:17.900
So Anirudh's obviously covered
a lot of things today about

00:28:17.900 --> 00:28:21.350
all the options that you have
when it comes to connectivity

00:28:21.350 --> 00:28:23.190
on Android.

00:28:23.190 --> 00:28:25.550
And we think that the
capability is great.

00:28:25.550 --> 00:28:29.290
And what we'd like to see is
more people use it and sort of

00:28:29.290 --> 00:28:33.510
impress us to show us what are
the creative things you can

00:28:33.510 --> 00:28:34.420
come up with.

00:28:34.420 --> 00:28:36.320
So today I would like to
announce something new that

00:28:36.320 --> 00:28:37.980
we're doing.

00:28:37.980 --> 00:28:40.720
We're calling it a
ADL+ experiments.

00:28:40.720 --> 00:28:42.820
And we're going to launch our
first experiment today.

00:28:42.820 --> 00:28:47.280
So what ADL+ experiments is, is
it's a plus page that you

00:28:47.280 --> 00:28:48.910
should go ahead and circle.

00:28:48.910 --> 00:28:51.330
And this announcement that we're
just doing right now, we

00:28:51.330 --> 00:28:53.190
will be making the same
announcement on the

00:28:53.190 --> 00:28:54.990
plus page as well.

00:28:54.990 --> 00:28:59.940
So ADL+ experiments is a way for
you to get involved with

00:28:59.940 --> 00:29:01.440
the things that we present.

00:29:01.440 --> 00:29:04.940
And today, we're launching our
first experiment, which is

00:29:04.940 --> 00:29:08.020
based on the connectivity
APIs that Anirudh has

00:29:08.020 --> 00:29:10.420
presented for us.

00:29:10.420 --> 00:29:12.760
So the goal is very
simple, actually.

00:29:12.760 --> 00:29:14.780
You're tasked with building
a cool app.

00:29:14.780 --> 00:29:17.810
This is obviously optional for
you, whether you want to get

00:29:17.810 --> 00:29:18.480
involved or not.

00:29:18.480 --> 00:29:21.310
But we think this is a really
great way to showcase your

00:29:21.310 --> 00:29:24.160
talents to the rest of the
developer community.

00:29:24.160 --> 00:29:25.690
So build a cool app.

00:29:25.690 --> 00:29:28.400
Come up with some great
concept using these

00:29:28.400 --> 00:29:31.620
connectivity APIs, and then what
you should do is share

00:29:31.620 --> 00:29:35.770
that APK with the plus
ADL experiments page.

00:29:35.770 --> 00:29:39.990
So just send us a link to the
APK-- a download link, whether

00:29:39.990 --> 00:29:44.460
it's Google Drive, or Dropbox,
or any other sort of service

00:29:44.460 --> 00:29:46.080
that you may use.

00:29:46.080 --> 00:29:50.690
And when you share with us, tell
us what the app is, and,

00:29:50.690 --> 00:29:52.930
more importantly,
how to use it.

00:29:52.930 --> 00:29:55.540
And tell us what makes
it special.

00:29:55.540 --> 00:29:57.840
You can choose to share the
source code if you want,

00:29:57.840 --> 00:30:02.530
whether you're using a GitHub
repository or otherwise,

00:30:02.530 --> 00:30:04.480
Google code, for example.

00:30:04.480 --> 00:30:06.780
And yeah, we'll take a look.

00:30:09.800 --> 00:30:13.690
And this program in itself is
quite an experiment, where

00:30:13.690 --> 00:30:15.200
we're launching it for
the first time.

00:30:15.200 --> 00:30:18.170
So it's a way for you to
showcase your talents.

00:30:18.170 --> 00:30:22.180
It's a way to sort of energize
the community.

00:30:22.180 --> 00:30:24.870
And by all means, you
can collaborate.

00:30:24.870 --> 00:30:26.600
So send us the submissions.

00:30:26.600 --> 00:30:31.700
We put a cutoff date of
the 30th of October.

00:30:31.700 --> 00:30:33.660
And feel free to send
the before then.

00:30:33.660 --> 00:30:36.190
As we get submissions, we're
going to go through them.

00:30:36.190 --> 00:30:41.840
And after that cutoff, the
incentive for you is we'll

00:30:41.840 --> 00:30:45.230
pick a handful that we think
are really, really nice.

00:30:45.230 --> 00:30:48.340
And we will highlight
these apps.

00:30:48.340 --> 00:30:49.880
So it will drive some
downloads to you.

00:30:49.880 --> 00:30:53.550
But more importantly, we'd like
to invite you to a future

00:30:53.550 --> 00:30:56.750
ADL+, so you can tell us how
you built the app, what

00:30:56.750 --> 00:30:59.750
challenges you had, and
have other people ask

00:30:59.750 --> 00:31:01.400
questions as well.

00:31:01.400 --> 00:31:04.940
So try and utilize these topics
that we're presenting.

00:31:04.940 --> 00:31:07.660
And yeah, that's ADL+
experiments.

00:31:07.660 --> 00:31:11.070
Anirudh, is there anything
you want to add to that?

00:31:11.070 --> 00:31:14.060
ANIRUDH DEWANI: Just for this
specific topic, if you want to

00:31:14.060 --> 00:31:16.330
learn more, there is an Android
training available

00:31:16.330 --> 00:31:18.710
called Connecting Devices
Wirelessly.

00:31:18.710 --> 00:31:21.605
And this can help you with your
first experiment, so go

00:31:21.605 --> 00:31:22.130
ahead and take a look.

00:31:22.130 --> 00:31:26.280
It's published on our Android
Developer site.

00:31:26.280 --> 00:31:27.960
MALE SPEAKER: So hopefully this
means that people are

00:31:27.960 --> 00:31:30.860
going to start submitting
apps, some work

00:31:30.860 --> 00:31:31.610
that they're doing.

00:31:31.610 --> 00:31:33.390
And these things don't need
to be complete apps.

00:31:33.390 --> 00:31:36.690
They don't need to be published,
necessarily.

00:31:36.690 --> 00:31:39.160
If they're published on
Play, that's great.

00:31:39.160 --> 00:31:42.305
But these can be just tech
demos, effectively, where

00:31:42.305 --> 00:31:46.520
you're showcasing something
cool that you're doing.

00:31:46.520 --> 00:31:48.790
We love this developer
community.

00:31:48.790 --> 00:31:50.750
And we're trying to see how
we can get you more

00:31:50.750 --> 00:31:53.550
involved in the ADL+.

00:31:53.550 --> 00:31:55.490
So ADL experiments--

00:31:55.490 --> 00:31:59.580
we really hope you engage,
because it means that if you

00:31:59.580 --> 00:32:02.050
find this sort of thing useful
then we'll do more of these

00:32:02.050 --> 00:32:03.500
experiments in the future.

00:32:03.500 --> 00:32:05.800
So we're going to talk about
this or mention ADL

00:32:05.800 --> 00:32:08.870
experiments every week up
until that code cutoff.

00:32:08.870 --> 00:32:13.000
And then in a future ADL+, we'll
try and showcase some of

00:32:13.000 --> 00:32:15.850
these apps and see if
we can bring the

00:32:15.850 --> 00:32:18.030
developers on as well.

00:32:18.030 --> 00:32:25.480
So with that, we shall move on
to Q&amp;A. We have one person

00:32:25.480 --> 00:32:27.900
that's live on the Hangout
at the moment

00:32:27.900 --> 00:32:29.540
who hasn't said anything.

00:32:29.540 --> 00:32:33.500
But did you have any questions
to us before we shift to the

00:32:33.500 --> 00:32:34.750
moderator page?

00:32:39.370 --> 00:32:41.060
Doesn't look like it.

00:32:41.060 --> 00:32:42.670
That's OK.

00:32:42.670 --> 00:32:47.250
So we have a couple of questions
on moderator.

00:32:47.250 --> 00:32:49.310
I'll read out the first one.

00:32:49.310 --> 00:32:54.170
"I get errors from ICS users
with MapActivity.

00:32:54.170 --> 00:32:56.560
An exception which is
basically a no class

00:32:56.560 --> 00:32:58.530
definition exception found.

00:32:58.530 --> 00:33:01.230
Android.security.MessageDigest.

00:33:01.230 --> 00:33:04.670
If I Google the error, people
say that it's a problem

00:33:04.670 --> 00:33:08.380
because an older version of
MapAPI is on the device.

00:33:08.380 --> 00:33:09.890
How do I solve the problem?

00:33:09.890 --> 00:33:16.060
The target SDK is version 16."

00:33:16.060 --> 00:33:18.760
So I had a look at this.

00:33:18.760 --> 00:33:23.680
And there's a handful of cases
where this has been reported

00:33:23.680 --> 00:33:24.930
on Stack Overflow.

00:33:26.990 --> 00:33:29.350
I wanted to ask you,
you said ICS users.

00:33:29.350 --> 00:33:32.090
But on those Stack Overflow
threads, there were people

00:33:32.090 --> 00:33:34.760
with Ice Cream Sandwich devices
that were saying hey,

00:33:34.760 --> 00:33:36.010
this works fine for me.

00:33:36.010 --> 00:33:38.360
I don't have problems
with this APK.

00:33:38.360 --> 00:33:40.590
So I must admit, this
is an issue that I

00:33:40.590 --> 00:33:42.390
haven't heard of before.

00:33:42.390 --> 00:33:44.140
I'd love to get down to
the bottom of it.

00:33:44.140 --> 00:33:46.130
So this is Mackan from Sweden.

00:33:46.130 --> 00:33:49.170
And I apologize if I messed
up the pronunciation.

00:33:49.170 --> 00:33:52.670
But please reach out
to me on Google+.

00:33:52.670 --> 00:33:55.260
And let's see if we can
diagnose it further.

00:33:55.260 --> 00:33:58.900
I'm interested in knowing
whether the devices that you

00:33:58.900 --> 00:34:03.610
were testing on, is there
something special about them?

00:34:03.610 --> 00:34:08.989
Are they normal Ice Cream
Sandwich devices that you buy

00:34:08.989 --> 00:34:12.320
from a shop or from
your Telco?

00:34:12.320 --> 00:34:14.610
Or are they running
custom ROMs?

00:34:14.610 --> 00:34:17.730
Is there a chance that these
devices don't have the Google

00:34:17.730 --> 00:34:22.370
services on them because they're
running a custom

00:34:22.370 --> 00:34:24.940
version of the platform or
something along those lines?

00:34:24.940 --> 00:34:29.000
And more importantly, are you
saying every single Ice Cream

00:34:29.000 --> 00:34:32.139
Sandwich device is struggling
to run this APK?

00:34:32.139 --> 00:34:33.690
So please reach out to me.

00:34:33.690 --> 00:34:35.429
I'd love to follow up further.

00:34:35.429 --> 00:34:38.340
Anirudh, did you want to
add anything to that?

00:34:38.340 --> 00:34:40.920
ANIRUDH DEWANI: No, I think just
give us some more info

00:34:40.920 --> 00:34:43.620
and we'll be able to help you.

00:34:43.620 --> 00:34:45.440
MALE SPEAKER: Yeah, we should
definitely try and get to the

00:34:45.440 --> 00:34:47.760
bottom of this.

00:34:47.760 --> 00:34:49.499
So next question.

00:34:52.100 --> 00:34:54.400
"I'm new to Android development
and don't know how

00:34:54.400 --> 00:34:57.160
to design and develop any app.

00:34:57.160 --> 00:34:59.660
Could you please give me some
references from where I can

00:34:59.660 --> 00:35:03.110
learn about the environment
setup and app development?

00:35:03.110 --> 00:35:04.510
Thanks."

00:35:04.510 --> 00:35:07.736
So this is Harshad from
Mumbai, India.

00:35:07.736 --> 00:35:11.140
Look, the best place to start
is developer.android.com.

00:35:11.140 --> 00:35:12.440
There's a section
called develop.

00:35:12.440 --> 00:35:14.180
And there's a getting
started guide there.

00:35:14.180 --> 00:35:17.540
It shows you how to download
the SDK, how to set it up.

00:35:17.540 --> 00:35:20.680
And it even has some sample
apps that help you sort of

00:35:20.680 --> 00:35:22.850
build the tutorials there.

00:35:22.850 --> 00:35:24.760
So developer.android.com--

00:35:24.760 --> 00:35:28.070
it's the place where you'll
find all of our tools.

00:35:28.070 --> 00:35:29.543
It's where you'll find all
of our documentation.

00:35:32.090 --> 00:35:34.690
If you have any sort of specific
questions, you should

00:35:34.690 --> 00:35:36.860
definitely be posting
to Stack Overflow

00:35:36.860 --> 00:35:38.310
using the Android tag.

00:35:38.310 --> 00:35:40.990
And you'll have a huge
community of Android

00:35:40.990 --> 00:35:45.350
developers that'll be just ready
and willing to help you.

00:35:45.350 --> 00:35:48.130
The important thing is that your
question is very broad.

00:35:48.130 --> 00:35:49.750
You're saying, hey look, I don't
know how to design or

00:35:49.750 --> 00:35:51.360
develop any app.

00:35:51.360 --> 00:35:54.190
It's really important to just
get your hands dirty.

00:35:54.190 --> 00:35:55.680
Stop playing with the
tutorial, start

00:35:55.680 --> 00:35:57.180
writing sample apps.

00:35:57.180 --> 00:35:59.620
And in the beginning
it may be hard.

00:35:59.620 --> 00:36:02.690
You may feel like, hey this is
not a very high quality app.

00:36:02.690 --> 00:36:03.450
That's OK.

00:36:03.450 --> 00:36:04.890
That's how you learn.

00:36:04.890 --> 00:36:08.130
And that's really
the focus of it.

00:36:08.130 --> 00:36:09.810
Next question.

00:36:09.810 --> 00:36:13.860
"Can I retrieve data from the
Google Maps API so I can use

00:36:13.860 --> 00:36:18.890
it for my location-based service
application that I'm

00:36:18.890 --> 00:36:22.670
developing?" This is Prisy
from Philippines.

00:36:22.670 --> 00:36:24.760
Anirudh, do you want
to take this one?

00:36:24.760 --> 00:36:26.390
ANIRUDH DEWANI: Yes.

00:36:26.390 --> 00:36:30.110
So the API that's available is
called Google Places API.

00:36:30.110 --> 00:36:32.203
And that's what you would
probably like to use with your

00:36:32.203 --> 00:36:33.650
location-based sources
available.

00:36:33.650 --> 00:36:36.260
You can use this API.

00:36:36.260 --> 00:36:37.610
It's a rest-based API.

00:36:37.610 --> 00:36:39.530
And there is a token you need.

00:36:39.530 --> 00:36:43.020
So what you need to do is go
to your developer console,

00:36:43.020 --> 00:36:47.160
which is
code.google.com/api/console.

00:36:47.160 --> 00:36:50.140
This is where you create a
project whenever you're trying

00:36:50.140 --> 00:36:52.840
to use any of the APIs there.

00:36:52.840 --> 00:36:55.640
So there, you need to enable
Google Places API.

00:36:55.640 --> 00:36:57.140
And I think there is
some quota that's

00:36:57.140 --> 00:36:58.590
available to you free.

00:36:58.590 --> 00:37:00.490
And then you need
to pay beyond a

00:37:00.490 --> 00:37:01.740
certain number of requests.

00:37:01.740 --> 00:37:03.110
So if you're just trying
out, you could

00:37:03.110 --> 00:37:06.400
probably try it for free.

00:37:06.400 --> 00:37:08.630
And the Google Places
API is there.

00:37:08.630 --> 00:37:11.020
And if you go to our
developer website,

00:37:11.020 --> 00:37:14.730
developers.google.com, you can
look up the service reference,

00:37:14.730 --> 00:37:17.630
and all the API reference,
and the different clients

00:37:17.630 --> 00:37:20.180
available to you if
you do have a

00:37:20.180 --> 00:37:21.810
Google Java client library.

00:37:21.810 --> 00:37:27.160
And yes, you can pretty much
use the Places API.

00:37:27.160 --> 00:37:32.610
And if I remember correctly, I
think Reto Meier, one of our

00:37:32.610 --> 00:37:33.950
advocates-- you probably
know him--

00:37:33.950 --> 00:37:37.210
he published a tutorial on
location-based services.

00:37:37.210 --> 00:37:40.720
And he also shared the
sample source code.

00:37:40.720 --> 00:37:43.140
So if you just look up the
history of the archives of

00:37:43.140 --> 00:37:46.420
Android blog, you will probably
find this tutorial.

00:37:46.420 --> 00:37:51.000
And he is using Places API
there to fetch places of

00:37:51.000 --> 00:37:54.240
interest for another
location-based service,

00:37:54.240 --> 00:37:56.860
basically allowing users to
check it when they want.

00:37:56.860 --> 00:38:00.560
So go ahead and there's a lot
of samples of complete

00:38:00.560 --> 00:38:01.490
applications that you
search in there.

00:38:01.490 --> 00:38:04.740
So you'll find a lot of sample
code there on how to use

00:38:04.740 --> 00:38:07.430
Google Places API.

00:38:07.430 --> 00:38:09.740
MALE SPEAKER: Cool, thank you.

00:38:09.740 --> 00:38:11.840
So the final question.

00:38:11.840 --> 00:38:15.680
"Why can't the Google Play store
send back the install

00:38:15.680 --> 00:38:19.770
referrers back either at the
Google Play developer console

00:38:19.770 --> 00:38:21.870
or through an API?

00:38:21.870 --> 00:38:23.290
Currently the in-device install

00:38:23.290 --> 00:38:25.780
referrer process is broken.

00:38:25.780 --> 00:38:29.160
We have big product marketing
plans around that feature."

00:38:29.160 --> 00:38:32.670
And that's from Gopinath
in Bangalore, India.

00:38:32.670 --> 00:38:36.138
Do you want to take this
one as well, Anirudh?

00:38:36.138 --> 00:38:37.090
ANIRUDH DEWANI: Yeah.

00:38:37.090 --> 00:38:42.750
So I don't really know if
it's not available.

00:38:42.750 --> 00:38:45.330
And if it's not available, I
would say that this is a

00:38:45.330 --> 00:38:48.340
feature request we can
take up to our team.

00:38:48.340 --> 00:38:51.230
So just hang on to your big
product marketing plans before

00:38:51.230 --> 00:38:52.610
it's released.

00:38:52.610 --> 00:38:55.910
And I'm not even sure if it's
going to be released yet.

00:38:55.910 --> 00:38:58.646
We will just take your feedback
to our product team

00:38:58.646 --> 00:39:01.000
and see how they want
to prioritize this.

00:39:01.000 --> 00:39:04.550
MALE SPEAKER: I was under the
impression that definitely we

00:39:04.550 --> 00:39:06.020
do support referrers.

00:39:06.020 --> 00:39:10.080
But I think the key thing here
might be that in the question

00:39:10.080 --> 00:39:15.010
he mentions about the in-device
experience-- or

00:39:15.010 --> 00:39:17.460
on-device I think is
what he meant--

00:39:17.460 --> 00:39:19.210
that the referral process
might be broken.

00:39:19.210 --> 00:39:22.010
Because if you do it by the
web, I'm pretty sure that

00:39:22.010 --> 00:39:23.620
process works pretty well.

00:39:23.620 --> 00:39:25.630
And I'd be surprised
if it didn't

00:39:25.630 --> 00:39:27.460
translate well to the device.

00:39:30.430 --> 00:39:36.470
Yeah, let us look that up for
you and run that past our team

00:39:36.470 --> 00:39:38.780
and see if we get a response.

00:39:38.780 --> 00:39:41.200
So please do reach out to either
Anirudh and myself.

00:39:41.200 --> 00:39:44.980
And we're going to look
up the answer anyway.

00:39:44.980 --> 00:39:49.540
But there's no way for us to
contact you directly here.

00:39:49.540 --> 00:39:52.320
So yeah, we'll do that.

00:39:52.320 --> 00:39:54.380
Just so you know, this question
I think is a fairly

00:39:54.380 --> 00:39:55.070
new question.

00:39:55.070 --> 00:39:56.530
It wasn't there a couple
of hours ago.

00:39:56.530 --> 00:39:59.850
So we haven't had the
opportunity to have an answer

00:39:59.850 --> 00:40:01.100
ready for this one.

00:40:03.570 --> 00:40:09.370
I haven't seen any further
questions on moderator.

00:40:09.370 --> 00:40:11.370
Are there any questions
on the thread where

00:40:11.370 --> 00:40:13.750
we've hosted this?

00:40:13.750 --> 00:40:15.500
Felix, could you just
check the--

00:40:20.830 --> 00:40:22.080
we're just checking
the thread.

00:40:24.490 --> 00:40:26.400
Nope, there doesn't
seem to be.

00:40:26.400 --> 00:40:29.010
Well, thank you for
joining us.

00:40:29.010 --> 00:40:32.140
We mentioned before that we
were announcing something.

00:40:32.140 --> 00:40:33.640
And it was ADL experiments.

00:40:33.640 --> 00:40:36.240
It's really for developers to
get their hands dirty with

00:40:36.240 --> 00:40:38.300
this stuff.

00:40:38.300 --> 00:40:39.710
So we hope that's
useful for you.

00:40:39.710 --> 00:40:43.740
It's exciting for us, because
we get to see some of the

00:40:43.740 --> 00:40:48.370
creativity the developers
come up with when

00:40:48.370 --> 00:40:49.985
using these new APIs.

00:40:49.985 --> 00:40:52.170
So thanks, Anirudh, for
presenting connectivity.

00:40:52.170 --> 00:40:56.040
And thanks to all of
you for tuning in.

00:40:56.040 --> 00:40:58.250
So that's us signing
off for this week.

00:40:58.250 --> 00:41:00.160
We'll catch you next week.

00:41:00.160 --> 00:41:01.390
ANIRUDH DEWANI: See you, guys.

00:41:01.390 --> 00:41:02.640
MALE SPEAKER: See you later.

