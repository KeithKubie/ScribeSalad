WEBVTT
Kind: captions
Language: en

00:00:07.520 --> 00:00:10.510
&gt;&gt;Joel Webber: Good afternoon.
My name is Joel Webber on the Google Web Toolkit

00:00:10.510 --> 00:00:11.510
team.

00:00:11.510 --> 00:00:13.780
&gt;&gt;Adam Schuck: And hi. I'm Adam Schuck from
Sydney, Australia.

00:00:13.780 --> 00:00:15.121
I work on Google Wave.

00:00:15.121 --> 00:00:19.369
&gt;&gt;Joel Webber: We're going to talk a little
bit today about performance in GWT and as

00:00:19.369 --> 00:00:22.039
it applies to the learning's of the Google
Wave team.

00:00:22.039 --> 00:00:27.340
Also, don't forget, there is a live Wave going
on at the following bit.ly link if you're

00:00:27.340 --> 00:00:29.590
not already there.
There's been a little turbulence there, but

00:00:29.590 --> 00:00:32.080
it should be sorted out now.

00:00:32.080 --> 00:00:37.780
&gt;&gt;Adam Schuck: Okay. So you're all sitting
in the audience today, and you're obviously

00:00:37.780 --> 00:00:40.829
interested in performance, but it's important
to know, why does it matter?

00:00:40.829 --> 00:00:45.960
Why architect for performance?
Well, it turns out, speed of your application

00:00:45.960 --> 00:00:49.370
really matters.
Users want a fast application.

00:00:49.370 --> 00:00:53.940
And we've certainly seen this with Google.com.
We've learned the faster it is, the more people

00:00:53.940 --> 00:00:58.920
use it.
Typically, we talk in three powers of ten

00:00:58.920 --> 00:01:03.980
in terms of time limits that matter when you're
writing a web application; point one of a

00:01:03.980 --> 00:01:09.100
second, one second, and ten seconds.
And these are rough guidelines of important

00:01:09.100 --> 00:01:12.600
times that you want to keep.
"Point one of a second" is what you want to

00:01:12.600 --> 00:01:17.450
do if you want the application to feel instantaneous.
So, if your user is typing, everything should

00:01:17.450 --> 00:01:22.939
happen in less than a tenth of a second.
"One second" is what you want if the user's

00:01:22.939 --> 00:01:28.119
flow of thought should stay uninterrupted.
So, if I'm clicking some buttons and anything

00:01:28.119 --> 00:01:31.289
takes longer than one second, I might get
a little bit distracted.

00:01:31.289 --> 00:01:34.689
One second's important there.
And "ten seconds" is what you really want

00:01:34.689 --> 00:01:37.920
to do if you want to keep the user's attention
focused.

00:01:37.920 --> 00:01:43.389
So, if anything in your application takes
longer than ten seconds, "I've already Alt-tabbed;

00:01:43.389 --> 00:01:48.590
I'm checking Face book; watching videos on
YouTube; change. Oh, it's finally loaded.

00:01:48.590 --> 00:01:53.590
What was I doing again?" Ten seconds is a
really good guideline that, if anything in

00:01:53.590 --> 00:01:56.990
your application takes longer than that…what
was I talking about again?

00:01:56.990 --> 00:01:58.139
&gt;&gt;Joel Webber: Exactly.

00:01:58.139 --> 00:01:59.289
&gt;&gt;Adam Schuck: Exactly.

00:01:59.289 --> 00:02:02.999
&gt;&gt;Joel Webber: So, we're going to talk about
this, because I mentioned earlier, from two

00:02:02.999 --> 00:02:07.209
perspectives: myself working on GWT, perspective
of the tool builder.

00:02:07.209 --> 00:02:11.400
That is, what can we do to make GWT faster,
either through the compiler or through its

00:02:11.400 --> 00:02:14.430
libraries, so that your app is faster with
you doing little or no work?

00:02:14.430 --> 00:02:19.000
&gt;&gt;Adam Schuck: And I'll be presenting from
the Google Wave perspective.

00:02:19.000 --> 00:02:23.680
Google Wave, if you weren't already aware,
is build in GWT.

00:02:23.680 --> 00:02:27.900
And we put a lot of work into making our application
faster.

00:02:27.900 --> 00:02:31.310
We know we have a long way to go, but we're
a lot faster than we used to be.

00:02:31.310 --> 00:02:35.610
And I'll give a demo of that in a second.
But, the reason that the two of us are here

00:02:35.610 --> 00:02:40.310
on stage today is because the GWT team and
the Wave teams work very closely together.

00:02:40.310 --> 00:02:45.030
We both absolutely believe in the importance
of speed.

00:02:45.030 --> 00:02:49.620
And, as a result, whenever we discover something,
we share it with the GWT team and vice versa.

00:02:49.620 --> 00:02:54.450
So we're trying to help…together… make
GWT better, so you don't have to worry about

00:02:54.450 --> 00:02:57.280
these problems.
And for those of you who haven't actually

00:02:57.280 --> 00:03:03.340
seen Google Wave since Google I/O last year,
maybe you haven't dusted off your accounts

00:03:03.340 --> 00:03:07.810
you received.
Just a quick reminder, Hands up in the crowd

00:03:07.810 --> 00:03:11.790
if you've ever opened a really large wave
in Google Wave.

00:03:11.790 --> 00:03:17.370
Okay. Keep your arm up if you found it slow.
Wow, people who didn't even have their hand

00:03:17.370 --> 00:03:19.980
up before put their hands up for that.
[laughing]

00:03:19.980 --> 00:03:22.590
&gt;&gt;Joel Webber: That's because they never succeeded
in opening the Wave.

00:03:22.590 --> 00:03:25.660
&gt;&gt;Adam Schuck: Bingo, okay. I should have
said "attempted."

00:03:25.660 --> 00:03:29.480
Okay. You all know the problem.
I am about to do a magic trick, which, for

00:03:29.480 --> 00:03:32.730
some of you, you'll be surprised at; I'm going
to try and open.

00:03:32.730 --> 00:03:35.610
And, of course, I've made an offering to the
demo gods today.

00:03:35.610 --> 00:03:37.120
&gt;&gt;Joel Webber: My fingers are crossed.

00:03:37.120 --> 00:03:43.250
&gt;&gt;Adam Schuck: This wave has 370 messages
in it, and I'm going to click -- 3-2-1.

00:03:43.250 --> 00:03:46.570
[click] That was less than a second, right?

00:03:46.570 --> 00:03:47.570
&gt;&gt;Joel Webber: Within a second. It's close.

00:03:47.570 --> 00:03:51.810
&gt;&gt;Adam Schuck: All right. Put your hand back
up if that's not fast enough for you.

00:03:51.810 --> 00:03:53.900
Good. We're going to make it faster for all
of you.

00:03:53.900 --> 00:03:57.150
It's not fast enough for me.
I forgot to put my hand up as well.

00:03:57.150 --> 00:04:02.540
So, we've done a lot of work previously that
would actually grind your browser to a halt.

00:04:02.540 --> 00:04:05.370
It would take a long time before you could
even see the content.

00:04:05.370 --> 00:04:08.770
So we're going to talk a little bit about
some of the tricks that we've been using to

00:04:08.770 --> 00:04:09.900
try and make Wave faster.

00:04:09.900 --> 00:04:13.319
&gt;&gt;Joel Webber: So we're going to talk about
this from four perspectives.

00:04:13.319 --> 00:04:16.489
There's really four major parts you need to
consider when you're trying to make your app

00:04:16.489 --> 00:04:18.720
fast.
First is "start up", right? We're talking

00:04:18.720 --> 00:04:20.739
about web apps.
Web apps need to start fast.

00:04:20.739 --> 00:04:23.569
That's what we expect of them.
When they don't, that's bad.

00:04:23.569 --> 00:04:27.090
And people typically won't stay with an app
that doesn't start fast, especially if they're

00:04:27.090 --> 00:04:31.990
new to it.
"Fetching data"… these are web applications.

00:04:31.990 --> 00:04:34.990
Therefore, they're distributed in practically
all real instances.

00:04:34.990 --> 00:04:39.389
Distributed networks are typically slow.
The Internet is certainly, is often quite

00:04:39.389 --> 00:04:42.020
slow.
And you don't want to fetch more data than

00:04:42.020 --> 00:04:46.590
you need or too often.
"Rendering", talking about the web browser.

00:04:46.590 --> 00:04:51.639
Web browser has pretty unusual performance
characteristics, and you need to get data

00:04:51.639 --> 00:04:55.680
on the screen fast.
Then, "user interactions," these are the things

00:04:55.680 --> 00:04:59.960
that fall into that 100 millisecond or point
one of a second limit that Adam talked about

00:04:59.960 --> 00:05:03.120
earlier that, if you don't fall into that
range, your app feels sluggish.

00:05:03.120 --> 00:05:07.000
You may have heard the word "sluggish" a lot
if you were here this morning for Kelly Norton's

00:05:07.000 --> 00:05:09.590
talk.
People think sluggish apps feel bad.

00:05:09.590 --> 00:05:13.349
They think they're low quality.
They just don't feel right.

00:05:13.349 --> 00:05:15.520
And then, Adam's going to talk a little bit
about performance measurement.

00:05:15.520 --> 00:05:18.479
That is, once you've got your app as fast
as you want it to be, or at least under some

00:05:18.479 --> 00:05:20.990
reasonable threshold, you're released. You
want to keep it fast.

00:05:20.990 --> 00:05:23.039
When you make it faster, you want to keep
it faster.

00:05:23.039 --> 00:05:26.400
So you want to catch regressions.

00:05:26.400 --> 00:05:33.009
&gt;&gt;Adam Schuck: Okay. So we mentioned four
main areas where your application can be faster.

00:05:33.009 --> 00:05:37.279
The first of these is "start up."
You want your application to load quickly.

00:05:37.279 --> 00:05:41.240
And by "quickly," we mean, much less time
than ten seconds. Oops.

00:05:41.240 --> 00:05:42.639
&gt;&gt;Joel Webber: Sorry.

00:05:42.639 --> 00:05:46.479
&gt;&gt;Adam Schuck: [chuckle] We're competing.
"Concurrency control presently not as good

00:05:46.479 --> 00:05:50.180
as Google Wave." Who would have thought?
Okay, start up.

00:05:50.180 --> 00:05:53.379
Where does the time go when you're starting
up your application?

00:05:53.379 --> 00:05:58.720
There's four main places. Fetching the script.
So, if I have a really bad dial-up network

00:05:58.720 --> 00:06:02.460
connection, it can take a lot of time to download
the JavaScript.

00:06:02.460 --> 00:06:07.509
Secondly, "evaluating the script."
So, if I have a slow computer, it might take

00:06:07.509 --> 00:06:12.419
awhile for the browser to evaluate this JavaScript
that I've just downloaded.

00:06:12.419 --> 00:06:16.589
"Fetching the initial data." So now, "Okay,
we've started up the application.

00:06:16.589 --> 00:06:21.020
We've evaluated it.
Now, we need to know what, in Wave's case,

00:06:21.020 --> 00:06:25.759
what waves do they have in their inbox?
What are their contacts? What are their folders?

00:06:25.759 --> 00:06:29.111
Etc.
And once we've done that, of course, "building

00:06:29.111 --> 00:06:32.199
the application structure."
So we need to put all the panels in place,

00:06:32.199 --> 00:06:35.289
wire everything up, get a communication channel
running.

00:06:35.289 --> 00:06:42.439
All of these four things in your start-up
sequence can add up to quite a slow start-up.

00:06:42.439 --> 00:06:47.479
Let's look at what a typical out-of-the-box
GWT start-up sequence looks like.

00:06:47.479 --> 00:06:51.850
We're looking at four roundtrips.
Four roundtrips, which, for people who live

00:06:51.850 --> 00:06:57.590
in Australia, can actually add up.
There we go. Another Aussie, hurray! [laughing]

00:06:57.590 --> 00:07:02.889
It can really add up if you have a high-latency
connection.

00:07:02.889 --> 00:07:06.529
Now, the four roundtrips.
First one is, we download the host page.

00:07:06.529 --> 00:07:12.960
So this is initial HTML creates the structure.
Secondly, GWT, we download what's called a

00:07:12.960 --> 00:07:17.189
"selection script."
This script in the browser figures out what

00:07:17.189 --> 00:07:21.310
browser are they using, what language do they
want to talk, etc.

00:07:21.310 --> 00:07:25.839
Now, we know exactly what version of your
application we want to download.

00:07:25.839 --> 00:07:30.499
So now I know, "Okay. Let's download the French
Safari version of Google Wave."

00:07:30.499 --> 00:07:34.580
Once we've done that, then we actually fetch
that version of JavaScript.

00:07:34.580 --> 00:07:37.330
We evaluate it.
So, if there's a lot of JavaScript, takes

00:07:37.330 --> 00:07:42.419
awhile to evaluate, especially on a slow machine.
Now that we've finally done that, we've got

00:07:42.419 --> 00:07:48.339
the communication channel up and running.
Only now can we start fetching the actual

00:07:48.339 --> 00:07:53.190
data, so, the inbox, the contacts etc.
And that, of course, requires roundtrip, not

00:07:53.190 --> 00:07:56.069
just to your front end, but all the way through
your back end.

00:07:56.069 --> 00:08:03.280
This adds up to quite a bit of time.
Turns out, we can do a lot better than this.

00:08:03.280 --> 00:08:06.719
We can actually reduce the four roundtrips
down to two roundtrips.

00:08:06.719 --> 00:08:10.110
And we can actually do one, but I'll tell
you why that's not actually better.

00:08:10.110 --> 00:08:16.009
So, first optimization we make is, instead
of downloading the selection script and, in

00:08:16.009 --> 00:08:21.899
the browser, figuring out what version of
your GWT application to run; rather, we base

00:08:21.899 --> 00:08:27.170
off the http headers of your first request
which version we should serve.

00:08:27.170 --> 00:08:34.050
So, the server, the front end can say, "Aha!
We now know from the user agent they're using

00:08:34.050 --> 00:08:37.790
Safari."
And we can use various http headers to figure

00:08:37.790 --> 00:08:41.620
out, "Aha! They're in France."
Maybe we know their user ID from the cookies,

00:08:41.620 --> 00:08:44.940
etc.
So we know they prefer using the Swiss French

00:08:44.940 --> 00:08:48.720
etc.
So we save one round trip there.

00:08:48.720 --> 00:08:55.200
And second to that, we also kick off downloading
the initial data in parallel.

00:08:55.200 --> 00:09:00.030
So, instead of waiting for everything to start
up, we start downloading. While we're fetching

00:09:00.030 --> 00:09:06.880
the JavaScript, we start fetching the initial
data. Note that we didn't bundle the JavaScript

00:09:06.880 --> 00:09:11.610
into that very first download.
And the reason we don't want to do that is

00:09:11.610 --> 00:09:17.840
because your application will typically change
on a weekly basis, whereas that initial HTML

00:09:17.840 --> 00:09:22.600
page will probably change every time you request.
And so, the JavaScript caches a lot better

00:09:22.600 --> 00:09:26.370
this way.
And, in this particular example, you see the

00:09:26.370 --> 00:09:31.820
initial data actually returns to the browser
before the JavaScript is up and running, which

00:09:31.820 --> 00:09:34.580
is great.
It means the second the JavaScript is ready,

00:09:34.580 --> 00:09:39.850
we can show a completely loaded application.
So that's using two roundtrips.

00:09:39.850 --> 00:09:44.990
And note that we don't want to have to wait
for the communication channel, the RPC channel,

00:09:44.990 --> 00:09:49.140
to be up and running.
So we send down the data to the browser in

00:09:49.140 --> 00:09:54.660
a lightweight format, perhaps Json.
So that's how we can really speed things up

00:09:54.660 --> 00:09:55.660
in your start-up sequence.

00:09:55.660 --> 00:10:03.350
&gt;&gt;Joel Webber: So, I'm going to tell you a
little bit about code splitting.

00:10:03.350 --> 00:10:09.340
Now, Adam just told you how you can reduce
the number of http requests intrinsic to your

00:10:09.340 --> 00:10:12.550
start-up process.
That's certainly going to make a good bit

00:10:12.550 --> 00:10:15.090
of difference.
But then, we have another problem. We have

00:10:15.090 --> 00:10:17.510
applications.
People tend to like to add more features to

00:10:17.510 --> 00:10:21.010
applications, and applications that have more
features tend to get bigger.

00:10:21.010 --> 00:10:25.130
As you may know, GWT is a monolithic compiler,
tends to compile all of your app as one big

00:10:25.130 --> 00:10:28.270
ball of JavaScript that you then have to download
to the client.

00:10:28.270 --> 00:10:31.260
Well, if that thing is growing without bound,
you're eventually going to hit a brick wall.

00:10:31.260 --> 00:10:36.790
It's going to get really, really slow on start-up.
So, with the Wave team's input and a strong

00:10:36.790 --> 00:10:38.560
desire, we came up with --

00:10:38.560 --> 00:10:39.560
&gt;&gt;Adam Schuck: -- very strong.
[laughing]

00:10:39.560 --> 00:10:43.080
&gt;&gt;Joel Webber: -- very strong desire. We came
up with what we called code splitting.

00:10:43.080 --> 00:10:47.100
This is a compiler.
It is semi-automated, but it is driven by

00:10:47.100 --> 00:10:51.430
the compiler. A way of splitting your application
into multiple chunks automatically.

00:10:51.430 --> 00:10:56.360
So you have to define as "split points." These
are the places where the compiler is allowed

00:10:56.360 --> 00:10:58.530
to split them up.
So, split up fragments so that the user can

00:10:58.530 --> 00:11:05.090
take a small hitch during that time.
But then, from there on out, it optimizes

00:11:05.090 --> 00:11:09.530
everything automatically.
Your goal is to have one fragment that contains

00:11:09.530 --> 00:11:14.600
no more than is strictly needed for your initial
view – whatever, whatever's visible in your

00:11:14.600 --> 00:11:19.370
initial page, or set-up of your application.
And to show a quick demo of that, we're going

00:11:19.370 --> 00:11:20.840
to go to the --

00:11:20.840 --> 00:11:21.940
&gt;&gt;Adam Schuck: --showcase.

00:11:21.940 --> 00:11:25.900
&gt;&gt;Joel Webber: -- simple GWT showcase example.
And this is a bit of a contrived example,

00:11:25.900 --> 00:11:31.570
because the showcase is naturally divided
into a million little pages. Well, 30 or 40,

00:11:31.570 --> 00:11:34.780
let's say.
And what Adam's showing here is the network

00:11:34.780 --> 00:11:42.500
graph from Chrome where initially we see this
Indi 5 blob here is the initial page, which

00:11:42.500 --> 00:11:48.040
contains really common code and enough code
to get the first page displayed. In this case,

00:11:48.040 --> 00:11:52.870
that one checkbox sample.
From there on out, it will fetch subsequent

00:11:52.870 --> 00:11:54.840
fragments.
And this app has been really aggressively

00:11:54.840 --> 00:11:57.950
split up more to demonstrate the point.
You wouldn't probably split it up quite this

00:11:57.950 --> 00:12:01.230
fine-grained in practice.
But the idea is that, anything that's not

00:12:01.230 --> 00:12:04.870
needed immediately gets fetched later.
So, in this case, there are a few things that

00:12:04.870 --> 00:12:08.070
get fetched fairly early on.
So, what Adam's going to do is, click another

00:12:08.070 --> 00:12:11.760
spot in here that will show us a different
sample that was not downloaded, that was not

00:12:11.760 --> 00:12:14.530
part of original code.
And, if you watch the network graph on the

00:12:14.530 --> 00:12:18.590
right as he does this, you'll see there is
a --

00:12:18.590 --> 00:12:23.090
&gt;&gt;Adam Schuck: -- P-N-G. I haven't actually
clicked basic texture.

00:12:23.090 --> 00:12:24.100
So let's click this.

00:12:24.100 --> 00:12:27.860
&gt;&gt;Joel Webber: Okay, just down at the bottom,
we fetched two new fragments.

00:12:27.860 --> 00:12:30.100
Once again, because this is slightly over
split up.

00:12:30.100 --> 00:12:35.130
But again, it's just a demonstration.
This allows you to build an app that is essentially

00:12:35.130 --> 00:12:38.560
of arbitrary complexity.
As long as you can wait on the compile times;

00:12:38.560 --> 00:12:42.830
yeah, it's been known that it can get a little
slow, but we rather you wait than your users

00:12:42.830 --> 00:12:45.110
wait.
So you can build really large apps, really

00:12:45.110 --> 00:12:49.530
complex apps, and still keep the start-up
very fast.

00:12:49.530 --> 00:12:58.450
&gt;&gt;Adam Schuck: Okay, and from the Wave point
of view, as Joel mentioned, we were adamant

00:12:58.450 --> 00:13:01.250
that we didn't want to have to stop adding
new features to Wave--

00:13:01.250 --> 00:13:02.371
&gt;&gt;Joel Webber: --and they were adding a lot.

00:13:02.371 --> 00:13:03.800
&gt;&gt;Adam Schuck: We were adding a lot of features.
[laughing]

00:13:03.800 --> 00:13:07.230
Maybe we should have stopped.
But, we kept adding features, and the code

00:13:07.230 --> 00:13:10.430
just kept growing.
And we really felt it's important that users

00:13:10.430 --> 00:13:16.120
only see the exact code you need for the exact
features that we're showing upfront.

00:13:16.120 --> 00:13:20.500
We heavily optimized our start-up sequence
so that we show a loaded inbox first.

00:13:20.500 --> 00:13:24.680
We believe perceived latency is the most important
thing to optimize for.

00:13:24.680 --> 00:13:28.190
Users should get the impression the application
is loading fast.

00:13:28.190 --> 00:13:34.140
And in our opinion, we decided, we want people
to be able to read their new content as quickly

00:13:34.140 --> 00:13:36.580
as possible.
Perhaps we'll change that to optimize for

00:13:36.580 --> 00:13:40.510
showing individual waves later.
But, we've currently structured our code to

00:13:40.510 --> 00:13:44.891
optimize for a full inbox.
And if you try and do something like this,

00:13:44.891 --> 00:13:49.000
you're trying to reduce the amount of code
that needs to be downloaded to start your

00:13:49.000 --> 00:13:53.800
application. the first question you're going
to ask is, "What is actually in that initial

00:13:53.800 --> 00:13:59.071
download?" And there's a really neat tool
created by the GWT to answer our question,

00:13:59.071 --> 00:14:05.360
[chuckle] of course, called "compile reports."
And I've got one lying around right here.

00:14:05.360 --> 00:14:11.991
So here's a compile report for Google Wave.
And you'll actually see the initial download

00:14:11.991 --> 00:14:15.880
size is quite large.
We actually found this gives better performance

00:14:15.880 --> 00:14:19.490
in our particular case.
To Joel's point of download everything you

00:14:19.490 --> 00:14:23.870
need to see what you want the user to see
upfront.

00:14:23.870 --> 00:14:28.650
And we're talking roughly three megabytes
full-code size, less than a meg initial download.

00:14:28.650 --> 00:14:35.060
That's huge, but bear in mind that's pre-compression.
And GWT code does compress very well.

00:14:35.060 --> 00:14:41.200
And you can click on this link here, "report,"
and see exactly what is in your initial download.

00:14:41.200 --> 00:14:46.980
So I can see here Java.util is the number
one contributor by size as a package, and

00:14:46.980 --> 00:14:51.600
it contributes 37k.
I can see there's a search panel.

00:14:51.600 --> 00:14:54.490
That's a relief.
We're trying to show the search panel, the

00:14:54.490 --> 00:14:59.650
inbox, as quickly as possible.
And we can see, aha! You know, the contacts

00:14:59.650 --> 00:15:03.500
panel is not loaded.
That is part of the contacts panel, but it's

00:15:03.500 --> 00:15:06.610
just some resources.
It's not the full contacts panel.

00:15:06.610 --> 00:15:11.430
So we can see how much these things contribute.
And your next question after, "What is in

00:15:11.430 --> 00:15:16.970
the initial download?" will be, "Why is it
in the initial download?" And to give an example,

00:15:16.970 --> 00:15:24.940
if I click on "framed panel" here, it shows
me exactly what java classes, are in the initial

00:15:24.940 --> 00:15:31.090
download, and how big they are.
And the exact call stack from your on-module

00:15:31.090 --> 00:15:37.770
load all the way through to the class.
So this is a really useful tool for identifying

00:15:37.770 --> 00:15:44.680
"why", not just "what", is in your initial
download.

00:15:44.680 --> 00:15:49.740
Also, to talk a little bit more about Wave
start-up sequence, we mentioned it's important

00:15:49.740 --> 00:15:55.650
to fetch your initial data as quickly as possible
in parallel, in fact, to loading your JavaScript.

00:15:55.650 --> 00:16:02.260
So we have a very good idea of what information
the user wants in their initial start-up of

00:16:02.260 --> 00:16:05.720
the Google Wave Client.
We anticipate this on the servers.

00:16:05.720 --> 00:16:10.310
And we start, we use transfer encoding of
chunk on the server, and we start sending

00:16:10.310 --> 00:16:14.480
small amounts of information up to the browser
as it is available.

00:16:14.480 --> 00:16:20.040
And what we could do there, so we have "contact
starter," "inbox starter," "wave data," we

00:16:20.040 --> 00:16:24.440
can send this all up when we get it.
But note that you actually block the client

00:16:24.440 --> 00:16:29.580
if it has to evaluate that JavaScript.
So rather, what we found we do, because we're

00:16:29.580 --> 00:16:34.050
optimizing for an inbox loading quickly, is
we send that particular piece of data quick,

00:16:34.050 --> 00:16:38.750
and then, everything else as we get it.
As mentioned, we code split to optimize for

00:16:38.750 --> 00:16:46.270
an initial download that shows an inbox.
And overall, our results in the last six months

00:16:46.270 --> 00:16:51.110
that we've been thinking about this problem,
we've made the median two seconds, it used

00:16:51.110 --> 00:16:57.530
to be five seconds; and for all of our users
in Africa or Australia, 90th percentile, it

00:16:57.530 --> 00:17:02.670
used to be 16 seconds, now, its 7 seconds.
These are ballparks.

00:17:02.670 --> 00:17:07.809
And you can see now, we are within that 10
second time limit that I mentioned as being

00:17:07.809 --> 00:17:10.900
so important.
And, of course, we're doing more work to make

00:17:10.900 --> 00:17:13.880
this faster.
We want to reduce that code size.

00:17:13.880 --> 00:17:19.839
&gt;&gt;Joel Webber: So earlier, Adam mentioned
optimization of the start-up process; reducing

00:17:19.839 --> 00:17:23.319
http requests by doing script selection on
the server.

00:17:23.319 --> 00:17:27.589
This is one thing that was built by another
team within Google that's used by Wave in

00:17:27.589 --> 00:17:31.070
a number of products.
And we're going to be open sourcing this as

00:17:31.070 --> 00:17:34.290
soon as time permits, so you won't have to
roll your own custom link in order to do this

00:17:34.290 --> 00:17:36.600
yourself.
And we'll bring that into GWT proper so you

00:17:36.600 --> 00:17:43.820
can all take advantage of it.
So, second point, fetching data.

00:17:43.820 --> 00:17:48.970
Again, as I mentioned, the…fetching data…we're
talking about over the Internet.

00:17:48.970 --> 00:17:53.480
Internet is slow, or it's always slower than
you want it to be at least.

00:17:53.480 --> 00:17:55.740
There's really two things this boils down
to.

00:17:55.740 --> 00:18:00.850
There is, fetching data you don't need, that
is, fetching more data than is needed to actually

00:18:00.850 --> 00:18:03.559
display what the user is looking for and needs
to see.

00:18:03.559 --> 00:18:07.980
And there's fetching it in too many http requests.
The latter is a subtle point that, if you

00:18:07.980 --> 00:18:13.550
fetch a small amount of data spread out over
a lot of http requests, then it's still going

00:18:13.550 --> 00:18:17.560
to be slow, because the http overhead is eating
you alive.

00:18:17.560 --> 00:18:21.430
So, you have to consider both of these things
and have different strategies for dealing

00:18:21.430 --> 00:18:25.200
with them.
First one is a little subtle.

00:18:25.200 --> 00:18:31.580
It's not as simple to deal with.
If you've ever built client-server applications,

00:18:31.580 --> 00:18:36.090
like LAN applications, say back in the early
90s when Google was doing that, you tended

00:18:36.090 --> 00:18:39.770
to sort of have a 2-tiered process, right?
You have a database in the back end; you have

00:18:39.770 --> 00:18:41.761
a really chatty communication on the front
end.

00:18:41.761 --> 00:18:43.970
You munge all the data and display it in the
UI.

00:18:43.970 --> 00:18:46.770
That was at least very common.
It's fairly easy to do.

00:18:46.770 --> 00:18:49.660
Problem with that is that it's chatty.
You download a lot of data you don't need

00:18:49.660 --> 00:18:55.730
typically, and that doesn't work so well for
the Internet.

00:18:55.730 --> 00:19:02.550
So, what we found really works well as a strategy
is to design your RPC system, be it RPC Json,

00:19:02.550 --> 00:19:07.850
fetch or whatever, to support the UI directly.
Make sure the UI can ask questions of the

00:19:07.850 --> 00:19:12.860
server in terms that will give it precisely
what it needs and no more.

00:19:12.860 --> 00:19:18.490
Don't fetch anything you don't need.
Be careful of types. If you're used to GWT

00:19:18.490 --> 00:19:22.040
RPC system, it's really nice, because it's
automated. It will walk your reference graph

00:19:22.040 --> 00:19:27.160
and figure out how to download all the objects
referenced by another object and so forth

00:19:27.160 --> 00:19:31.340
transitively, but that can also lead to situations
where you download stuff you didn't realize

00:19:31.340 --> 00:19:36.000
because it's being so helpful that it sent
a bunch of stuff so that it satisfies all

00:19:36.000 --> 00:19:37.770
the references.
You have to be careful with that.

00:19:37.770 --> 00:19:43.010
So watch your payload size and watch which
object you're sending out over the wires.

00:19:43.010 --> 00:19:49.500
Sometimes it makes sense to use specialized
DTOs to the client, that may not be the same

00:19:49.500 --> 00:19:54.550
ones you use in the back end, so that you
don't trigger this problem.

00:19:54.550 --> 00:19:59.340
The other issue, as I mentioned before, is
the http requests.

00:19:59.340 --> 00:20:05.750
So, this is a super-simplified version or
imaginative version of the Wave Client server

00:20:05.750 --> 00:20:08.640
protocol.
It doesn't actually work this way for reasons

00:20:08.640 --> 00:20:15.300
that will become clear in a moment.
Now, you might say, "Well, I'll just have

00:20:15.300 --> 00:20:20.420
each piece of my UI talk to an RPC interface,
get data that it needs from the back end."

00:20:20.420 --> 00:20:26.940
This is written in terms of the GWT RPC semantics
roughly, but the same thing applies no matter

00:20:26.940 --> 00:20:29.860
what you're using: Json, XML, or what have
you.

00:20:29.860 --> 00:20:34.900
The problem with this is that, very often,
a single user interaction leads to a bunch

00:20:34.900 --> 00:20:37.780
of requests.
And the reason this happens is that you say,

00:20:37.780 --> 00:20:44.660
imagine I'm in wave, I click on a wave.
I've got to fetch the header, to display that.

00:20:44.660 --> 00:20:47.800
I've got to fetch the wave itself, so I can
display that.

00:20:47.800 --> 00:20:53.660
But also, because I want to keep the rest
of the UI up to date, I use this opportunity

00:20:53.660 --> 00:20:59.660
also go fetch the status of my contacts.
I have to fetch the inbox, an updated version

00:20:59.660 --> 00:21:02.110
of the inbox perhaps, that's deltas, or what
have you.

00:21:02.110 --> 00:21:05.540
You get the idea.
I'm fetching a bunch of stuff from one user

00:21:05.540 --> 00:21:10.960
interaction. Well, this would translate into
four http requests, and they can get serialized

00:21:10.960 --> 00:21:13.010
because mini-browsers have a 2-connection
limit.

00:21:13.010 --> 00:21:18.100
Even the modern browsers will have a 2-connection
limit on the slow connection so they don't

00:21:18.100 --> 00:21:20.679
saturate the link.
So that ends up being really, really bad in

00:21:20.679 --> 00:21:24.429
practice when your UI has, it really has two
problems, one, it's slow.

00:21:24.429 --> 00:21:27.300
Two, it feels really slow, because these things
come in at different rates.

00:21:27.300 --> 00:21:30.030
So, this pops in, that pops in, that pops
in, that pops in.

00:21:30.030 --> 00:21:33.210
The whole UI kind of jiggles and feels awkward
and sluggish.

00:21:33.210 --> 00:21:40.570
The easy way to fix this, well, relatively
easy, is to actually restructure your RPC

00:21:40.570 --> 00:21:46.650
interface such that you break it into "request
object" and "response objects."

00:21:46.650 --> 00:21:50.630
You build a single interface, at least for
the purpose of most of the UI, that allows

00:21:50.630 --> 00:21:54.950
you to batch all of those requests.
So, all the different parts of the UI that

00:21:54.950 --> 00:22:00.700
need information will populate an array of
request objects, array of list request objects,

00:22:00.700 --> 00:22:05.260
go to the server, server processes all those,
sends back the response objects, and the piece

00:22:05.260 --> 00:22:10.640
of code doing the transfer goes off and farms
those responses off of the appropriate parts

00:22:10.640 --> 00:22:15.190
of the UI.
And a really simple way of doing this is simply

00:22:15.190 --> 00:22:18.200
to use a deferred command.
If you're more familiar with JavaScript, it's

00:22:18.200 --> 00:22:21.720
equivalent to using "set timeout zero," more
or less.

00:22:21.720 --> 00:22:26.410
And that allows you to aggregate your requests
based on a single user interaction.

00:22:26.410 --> 00:22:30.230
The idea is that a deferred command will run
after the current event handler is done, which

00:22:30.230 --> 00:22:33.580
almost invariably corresponds to a single
user action.

00:22:33.580 --> 00:22:37.710
And when that thing fires, you take all the
requests that have been batched up by different

00:22:37.710 --> 00:22:41.240
parts of the UI, and it fires them off to
the server to be handled.

00:22:41.240 --> 00:22:44.610
That allows the server to optimize things,
so like hot database connections and so forth

00:22:44.610 --> 00:22:48.059
can be used for all these different requests
being made.

00:22:48.059 --> 00:22:51.110
And it allows the different parts of the UI
to be written independently, because they

00:22:51.110 --> 00:22:55.890
all just use this simple add request interface
to get their data.

00:22:55.890 --> 00:23:00.600
They don't need to know about each other,
which keeps your code simpler.

00:23:00.600 --> 00:23:07.000
And that can lead to, again, a single http
request for user action, which is your goal.

00:23:07.000 --> 00:23:14.620
Okay, third part, rendering.
Again, we're talking about a web browser here,

00:23:14.620 --> 00:23:17.690
unusual performance characteristic, even the
best of them.

00:23:17.690 --> 00:23:23.179
And when your rendering is slow, you really
run into two problems.

00:23:23.179 --> 00:23:27.000
One, you run into all the problems that come
with being slow, "You just don't want your

00:23:27.000 --> 00:23:28.820
app to be slow.
Your users won't like it."

00:23:28.820 --> 00:23:32.610
But also, on the rendering side, on the client
side, you block your UI thread.

00:23:32.610 --> 00:23:36.080
And that's particularly bad because, on most
browsers, that means that user can't even

00:23:36.080 --> 00:23:40.250
switch tabs off from Windows.
And they can't do anything. They can't click

00:23:40.250 --> 00:23:44.490
the back button; they can't close the window
until that action is free.

00:23:44.490 --> 00:23:49.510
So if you have something rendering taking
several seconds, which is not unheard of if

00:23:49.510 --> 00:23:51.690
you're not careful, then it's a really, really
bad user experience.

00:23:51.690 --> 00:23:55.590
And that's what Kelly Norton's talk was referring
to, the sluggishness; really, really important

00:23:55.590 --> 00:23:58.500
thing to avoid.
This happens really in two places.

00:23:58.500 --> 00:24:03.080
When you're creating widgets and you're getting
data on to the screen.

00:24:03.080 --> 00:24:07.010
"Creating widgets" really means creating the
scaffolding, a place where you're going to

00:24:07.010 --> 00:24:10.750
put all your data, and then, there's actually
populating the data.

00:24:10.750 --> 00:24:14.550
And really, when I say "widgets," I'm specifically
referring to GWT widgets.

00:24:14.550 --> 00:24:19.950
The same thing applies for JavaScript widgets
and so forth, but I'll speak in terms of widgets.

00:24:19.950 --> 00:24:22.490
And there's two cases where you end up with
widgets that you don't need.

00:24:22.490 --> 00:24:27.340
Either you create them too early, that is,
you've created widgets that are not visible

00:24:27.340 --> 00:24:31.429
yet, and therefore, they were a waste of time.
You could have amortized that and created

00:24:31.429 --> 00:24:33.770
them when they were needed.
And you've created ones you didn't need at

00:24:33.770 --> 00:24:37.660
all.
So, things, creating widgets that do simple

00:24:37.660 --> 00:24:43.220
things like "layout," I'll go more into detail
on how you can deal with this later, is often

00:24:43.220 --> 00:24:45.550
unnecessary.
You can just simply get away with standard

00:24:45.550 --> 00:24:46.750
HTML.
It's often easier as well.

00:24:46.750 --> 00:24:53.820
And a simple case, so, I mentioned earlier
about where I'm going to go, creating widgets

00:24:53.820 --> 00:24:57.380
too early.
So if you imagine a simple case of a tab panel.

00:24:57.380 --> 00:24:59.929
Got five tabs.
You've got one thing that's visible, four

00:24:59.929 --> 00:25:03.570
things by definition not visible initially,
four things that I probably shouldn't have

00:25:03.570 --> 00:25:07.400
created yet.
A really simple pattern for this.

00:25:07.400 --> 00:25:10.520
If I just say "lazy initialization," you can
probably guess what I mean and figure out

00:25:10.520 --> 00:25:14.110
how to do it.
There is a lazy panel that is a simple way

00:25:14.110 --> 00:25:17.000
of doing this that's built-in, but the pattern
is very, very easy to imagine.

00:25:17.000 --> 00:25:19.580
Just wait until something is shown, then create
the widget.

00:25:19.580 --> 00:25:26.630
And, in fact, there's a large hierarchy of
widgets that can make a huge difference.

00:25:26.630 --> 00:25:32.600
So, I also mentioned that you should avoid
creating widgets that you simply don't need.

00:25:32.600 --> 00:25:37.460
And the reason widgets are slow, I say they're
slow. They're slow relative to their HTML

00:25:37.460 --> 00:25:42.400
counterparts, is because they do extra work.
They do extra work to deal with event handling,

00:25:42.400 --> 00:25:44.460
then you've got memory leaks, so forth and
so on.

00:25:44.460 --> 00:25:46.880
And if you don't need it, then there's no
reason to run that code.

00:25:46.880 --> 00:25:52.000
I often like to say, "The fastest code is
the code you never run."

00:25:52.000 --> 00:25:54.920
Only widgets that actually need to handle
events really even need to exist.

00:25:54.920 --> 00:25:57.030
And in some cases, even those don't need to
exist.

00:25:57.030 --> 00:26:01.090
So, if you can aggregate event handling at
a higher level, at an outer widget that contains

00:26:01.090 --> 00:26:05.490
some simpler constructs inside. We use this
in things like "tree" and some of the table

00:26:05.490 --> 00:26:08.590
widgets.
Then, you can optimize the creation of these

00:26:08.590 --> 00:26:16.510
things a lot further.
And there is an easy way now to create HTML

00:26:16.510 --> 00:26:20.080
elements for widgets where you may have used
widgets before in UiBinder.

00:26:20.080 --> 00:26:26.660
I'll cover that very briefly and go into more
detail later.

00:26:26.660 --> 00:26:32.780
So, use your I binder to replace widgets with
HTML, again, often the easier thing to do.

00:26:32.780 --> 00:26:38.700
In GWT 2.1, we have added a series, or are
in the process of adding a series, of cell-based

00:26:38.700 --> 00:26:41.401
lists trees and tables.
We call these "data presentation widgets."

00:26:41.401 --> 00:26:45.950
You may have seen Bruce Johnson demonstrate
these this morning.

00:26:45.950 --> 00:26:50.100
These are extremely fast waves during your
large collections of data.

00:26:50.100 --> 00:26:54.549
Because, oftentimes, if you're talking about
a "table" or "tree" or something like that,

00:26:54.549 --> 00:26:56.090
all the individual items are actually very
simple.

00:26:56.090 --> 00:26:58.890
There's no reason to use heavyweight widgets
for all of those.

00:26:58.890 --> 00:27:00.450
I won't go into great detail on this right
now, but tomorrow morning, Ray Ryan and myself

00:27:00.450 --> 00:27:05.640
are giving a talk describing these in much
more detail on how you can use them in your

00:27:05.640 --> 00:27:11.910
apps to speed them up drastically.
So UiBinder, for those not familiar, this

00:27:11.910 --> 00:27:18.809
is a simple XML structure that we introduced
in 2.0 that allows you to use XML to describe

00:27:18.809 --> 00:27:21.150
what would normally have been a lot of Java
boilerplate.

00:27:21.150 --> 00:27:24.340
But a side effect of this is, it also makes
it really easy to mix widgets with HTML elements,

00:27:24.340 --> 00:27:28.790
so you just create HTML if that's what you
want.

00:27:28.790 --> 00:27:35.540
It also makes it easier to mix CSS with your
widgets, associate them directly, and also

00:27:35.540 --> 00:27:39.950
avoid slow CSS patterns.
So, things like descendant selectors, in this

00:27:39.950 --> 00:27:42.300
case here, you see a div at the link of a
descendant selector.

00:27:42.300 --> 00:27:49.760
That can be an extremely slow pattern to match.
This structure, which I'll show in a moment,

00:27:49.760 --> 00:27:53.880
really makes it easy to avoid these kinds
of cases, which are very common in traditional

00:27:53.880 --> 00:27:54.880
CSS.

00:27:54.880 --> 00:27:58.830
&gt;&gt;Adam Schuck: And aside from the performance
benefits of using UiBinder, there's also a

00:27:58.830 --> 00:28:02.460
really nice code cleanliness quality to using
UiBinder.

00:28:02.460 --> 00:28:08.970
The Google Wave team, we proudly boasted a
4,000-line CSS file which nobody, one person

00:28:08.970 --> 00:28:13.430
in the team, knew how it worked and everyone
else feared deeply.

00:28:13.430 --> 00:28:19.970
And I think we managed to very successfully
carve that up into lots of 50-line CSS files

00:28:19.970 --> 00:28:24.040
scattered throughout our code base, living
in the same package as the code that uses

00:28:24.040 --> 00:28:27.730
them.
This also has the added performance benefit

00:28:27.730 --> 00:28:33.100
of; they get pulled down with code-splitting
at the exact point in time that they're used.

00:28:33.100 --> 00:28:36.809
So code cleanliness and performance working
together.

00:28:36.809 --> 00:28:39.960
It's really great.
They're not competing goals in this particular

00:28:39.960 --> 00:28:43.230
example.
What you're looking at here is an actual UiBinder

00:28:43.230 --> 00:28:47.210
template from Google Waves code base.
This is a contact.

00:28:47.210 --> 00:28:51.020
So the little avatar image with the person
speaking.

00:28:51.020 --> 00:28:56.870
And using UiBinder, we can pull all this CSS
in place and connect this up to our Java.

00:28:56.870 --> 00:28:58.520
And Joel's going to tell us how.

00:28:58.520 --> 00:29:05.180
&gt;&gt;Joel Webber: So two things to note here.
There won't be a pop quiz; you don't have

00:29:05.180 --> 00:29:08.380
to memorize this.
What I've highlighted first here is, you notice

00:29:08.380 --> 00:29:12.730
these UI field attributes.
What these do is describe how you're actually

00:29:12.730 --> 00:29:16.970
going to bind the individual elements created
for you into your code.

00:29:16.970 --> 00:29:20.410
Because you could've simply write something
like this with an interHTML call, put it in

00:29:20.410 --> 00:29:23.730
text in your Java code, but it's really hard
to actually get the elements back out again

00:29:23.730 --> 00:29:27.030
once they've been created.
UiBinder automates this process.

00:29:27.030 --> 00:29:32.080
And while there are no leaf widgets in this
case, there could be widgets mixed into this.

00:29:32.080 --> 00:29:36.169
So you might have, if you had a G: button
element as a leaf in here, that would work

00:29:36.169 --> 00:29:41.130
as well.
So, it'll again, allows you to mix them freely.

00:29:41.130 --> 00:29:46.330
This allows you to, in this case here, you'll
notice because they're all HTML elements,

00:29:46.330 --> 00:29:49.620
it allows you to quickly get references to
the pieces you need so that you can populate

00:29:49.620 --> 00:29:53.080
them with data.
But there are no widgets in here, because

00:29:53.080 --> 00:29:56.750
the only events that are handled are mouse
and click events at the top level.

00:29:56.750 --> 00:30:01.660
So that's just handled in the outermost widget:
keeps it simple, keeps it fast.

00:30:01.660 --> 00:30:05.930
The other thing I mentioned earlier is CSS.
So this uses standard class attributes for

00:30:05.930 --> 00:30:10.740
binding CSS to elements.
Same thing goes if you're binding it to widgets

00:30:10.740 --> 00:30:17.840
and I've got this G-style element right here.
It's part of the same file even though they're

00:30:17.840 --> 00:30:22.790
separate boxes.
These are individual rules. They're all simple

00:30:22.790 --> 00:30:27.220
rules, a single class selector, that are extremely
fast to match.

00:30:27.220 --> 00:30:31.480
So you're not angering the CSS performance
gods by making complex selectors.

00:30:31.480 --> 00:30:35.720
And UiBinder takes care of the process of
obfuscating and name spacing these things

00:30:35.720 --> 00:30:39.470
so they don't conflict with one another.
So, you can have something called "dot name"

00:30:39.470 --> 00:30:43.390
and not worry about somebody in some other
team in another continent who after creating

00:30:43.390 --> 00:30:48.010
another "dot name" which conflicts and causes
your UI to do strange things.

00:30:48.010 --> 00:30:53.470
&gt;&gt;Adam Schuck: So UiBinder, very good for
both performance and cleanliness of code.

00:30:53.470 --> 00:30:55.960
So there's really no excuse not to use them.

00:30:55.960 --> 00:30:58.260
&gt;&gt;Joel Webber: Per this virtue is the pit
of success.

00:30:58.260 --> 00:31:00.420
Where doing the easy thing is the fast thing
or the correct thing.

00:31:00.420 --> 00:31:02.770
&gt;&gt;Adam Schuck: All right. Shall we demo?

00:31:02.770 --> 00:31:04.620
&gt;&gt;Joel Webber: We shall.

00:31:04.620 --> 00:31:05.620
&gt;&gt;Adam Schuck: Okay.

00:31:05.620 --> 00:31:08.419
&gt;&gt;Joel Webber: Okay. So, you may have seen
this enormously fascinating application at

00:31:08.419 --> 00:31:13.950
the keynote this morning.
What's really fascinating about this app is

00:31:13.950 --> 00:31:18.530
not that it's about expense reports, sort
of a dry subject.

00:31:18.530 --> 00:31:25.650
What's fascinating about it is that it's fast,
assuming that my application hasn't cooled

00:31:25.650 --> 00:31:29.700
down in the meantime.
Here we go. It's normally fast.

00:31:29.700 --> 00:31:33.789
That's app engine. That's not the GWT side.
I'm not speaking about app engine.

00:31:33.789 --> 00:31:41.080
It is…importantly, there are practically
no widgets in this demo.

00:31:41.080 --> 00:31:45.669
There are, I think the last count, there are
approximately 25 total widgets for the core

00:31:45.669 --> 00:31:49.090
string superstructure for a couple of the
individual elements.

00:31:49.090 --> 00:31:53.289
But the rest of it is all rendered using the
new list tables, trees, data presentation

00:31:53.289 --> 00:31:58.900
widgets we're adding in 2.1.
And what this allows you to do importantly

00:31:58.900 --> 00:32:02.120
is things like this, that we probably would
not have even bothered to try before because

00:32:02.120 --> 00:32:05.210
it would be too slow using a complex widget
structure.

00:32:05.210 --> 00:32:09.179
So as I type here, you'll notice that it is
highlighting as I type.

00:32:09.179 --> 00:32:14.660
That seems like a reasonable thing to desire.
I'm sure UI guys would love it, but it would

00:32:14.660 --> 00:32:18.760
have been a pain before.
This now is extremely fast to render.

00:32:18.760 --> 00:32:26.630
And there's no reason that you should worry
about any complexity in your UI using these.

00:32:26.630 --> 00:32:31.720
It should always be reasonably performing,
in this case extremely fast.

00:32:31.720 --> 00:32:38.220
This also brings us to another question that
has come up a lot is …should I? Let's say,

00:32:38.220 --> 00:32:40.770
I'm writing an app.
I'm finding that it's getting kind of slow.

00:32:40.770 --> 00:32:44.679
I'm using a lot of widgets, getting slow.
And I'm starting to wonder if maybe I should

00:32:44.679 --> 00:32:49.710
be rendering my HTML on the server.
You know, that seems like a really complex

00:32:49.710 --> 00:32:53.030
thing to do, but it's a question that often
comes up.

00:32:53.030 --> 00:32:59.360
And it may have been true at one point.
Now, what we've found is that, when we moved,

00:32:59.360 --> 00:33:03.259
when we built these widgets, they're carefully
optimized to use in their HTML web wherever

00:33:03.259 --> 00:33:07.482
possible, optimized string manipulations and
so forth.

00:33:07.482 --> 00:33:10.160
In a way that you don't have to be exposed.
So you don't have to worry about it.

00:33:10.160 --> 00:33:15.539
And we found, in the vast majority of cases,
it is at least as fast as rendering static

00:33:15.539 --> 00:33:20.370
HTML from the server without the added network
overhead.

00:33:20.370 --> 00:33:24.470
And in many cases, it actually outruns downloading
HTML from the server.

00:33:24.470 --> 00:33:29.790
The only cases where we found where it really,
where it can still come out behind, is either

00:33:29.790 --> 00:33:35.250
when you're talking about progressively rendering
static HTML; but that only applies to your

00:33:35.250 --> 00:33:38.059
first page.
So if you have a page that has extremely high-latency

00:33:38.059 --> 00:33:43.690
requirements, you can render it from the server,
sort of decorate the HTML and so forth.

00:33:43.690 --> 00:33:45.330
But that really only helps you on the first
page.

00:33:45.330 --> 00:33:51.490
After that, you're still working on the Client.
And the other case is when you have extremely

00:33:51.490 --> 00:33:56.669
complex calculations going on to produce the
actual HTML that you're rendering.

00:33:56.669 --> 00:34:00.030
That really only comes up in rare cases.
I think Wave has a few of them when it comes

00:34:00.030 --> 00:34:02.870
to Wave rendering.
And I've seen a couple of other apps.

00:34:02.870 --> 00:34:05.100
But usually, you should almost never start
there.

00:34:05.100 --> 00:34:09.159
You should almost always begrudgingly move
any kind of rendering to the server.

00:34:09.159 --> 00:34:14.500
This pretty much takes care of the vast majority
of those cases as far as we can tell, so far.

00:34:14.500 --> 00:34:19.730
&gt;&gt;Adam Schuck: And the Wave team is looking
into using a server side rendering approach.

00:34:19.730 --> 00:34:23.280
We definitely think, as mentioned, the start-up
sequence; you've got to do two JavaScript

00:34:23.280 --> 00:34:27.770
roundtrips to get the data.
If you can really just send down HTML and

00:34:27.770 --> 00:34:31.810
go "set HTML" on the page.
And then, when JavaScript is fired up, swap

00:34:31.810 --> 00:34:35.899
in some content.
We do believe that we can get some performance

00:34:35.899 --> 00:34:36.899
gains.

00:34:36.899 --> 00:34:39.100
&gt;&gt;Joel Webber: But again, do that begrudgingly.
It's a lot of work.

00:34:39.100 --> 00:34:40.100
&gt;&gt;Adam Schuck: We're doing it begrudgingly.
[laughing]

00:34:40.100 --> 00:34:41.340
It's a lot of work.

00:34:41.340 --> 00:34:46.440
&gt;&gt;Joel Webber: One other thing to set stage
for is, what I usually refer to as "on-demand

00:34:46.440 --> 00:34:49.510
rendering" or "on-the-draw widgets" if you
will.

00:34:49.510 --> 00:34:54.240
Often referred to as "infinite scrolling."
The idea is to render only what's literally

00:34:54.240 --> 00:34:56.770
on the screen.
So if you have a large scrollable area, you

00:34:56.770 --> 00:35:01.010
fake out the scrollable part, and then, you
render elements or widgets as they are, as

00:35:01.010 --> 00:35:04.340
they come into view.
And we haven't actually implemented this yet

00:35:04.340 --> 00:35:09.990
except in some internal demos; but this sets
the stage for doing that quickly and efficiently.

00:35:09.990 --> 00:35:14.170
So, we think this will make a huge difference
for really, really large collections.

00:35:14.170 --> 00:35:19.810
And Wave has implemented it for both the inbox
or search view, so, all the items that you

00:35:19.810 --> 00:35:23.340
see in that scrolling view.
And also, for Waves themselves.

00:35:23.340 --> 00:35:28.950
So waves that are 3 or 400 blips long.
If you rendered all of those upfront, it would

00:35:28.950 --> 00:35:31.660
be fairly slow, as you've probably seen in
the past.

00:35:31.660 --> 00:35:35.550
But now, it's much, much faster as a result
of rendering only the visible elements.

00:35:35.550 --> 00:35:40.840
&gt;&gt;Adam Schuck: That's right. So we're seeing,
we calculate roughly a 4x improvement.

00:35:40.840 --> 00:35:46.690
And statistically, that's looking at the averages.
So we've got very different sizes of waves.

00:35:46.690 --> 00:35:52.010
But, now we really do, it's much faster if
you want to jump to the end of a wave as I

00:35:52.010 --> 00:35:56.450
showed you previously at the start of this
talk, because we don't worry about rendering

00:35:56.450 --> 00:36:01.130
all the content in a linear order.
Okay. If I may?

00:36:01.130 --> 00:36:02.830
&gt;&gt;Joel Webber: You may.

00:36:02.830 --> 00:36:07.080
&gt;&gt;Adam Schuck: So, we're now up to the fourth
of the four areas where we think you can improve

00:36:07.080 --> 00:36:09.460
your application's performance.
So we've talked about start-up.

00:36:09.460 --> 00:36:13.570
We've talked about fetching the data, we've
talked about rendering.

00:36:13.570 --> 00:36:21.650
Now to talk about another one of these sub-tenth
of a second hot spots: user interactions.

00:36:21.650 --> 00:36:26.070
When a user is interacting directly with your
application, clicking buttons, typing, we're

00:36:26.070 --> 00:36:29.010
really shooting at that tenth of a second
barrier.

00:36:29.010 --> 00:36:32.280
And there's a great talk, in fact, if you
attended the Speed Tracer talk this morning,

00:36:32.280 --> 00:36:36.260
you learned it's a really great deep dive
into this topic.

00:36:36.260 --> 00:36:41.790
We're going to stay somewhat high-level.
And these interactions, there's a few places

00:36:41.790 --> 00:36:46.440
where time can build up.
Slow event handlers, so, we block the UI thread.

00:36:46.440 --> 00:36:51.961
So if we do too much processing while we're
handling the UI, it could potentially take

00:36:51.961 --> 00:36:55.460
more than a tenth of a second.
Click events, if I click, I want to see a

00:36:55.460 --> 00:36:58.330
change immediately.
That's what I'm used to.

00:36:58.330 --> 00:37:03.310
Mouse events, if I'm dragging, hovering, you
don't want that "sluggishness" as we're using

00:37:03.310 --> 00:37:07.680
the word.
Key events: typing, navigation, and also window

00:37:07.680 --> 00:37:11.310
resizes, all these things you should make
them fast.

00:37:11.310 --> 00:37:17.500
One general tip is, if there is a browser
feature, rather than you having to write code,

00:37:17.500 --> 00:37:20.910
use it.
Turns out, writing less code also means it's

00:37:20.910 --> 00:37:25.560
going to be faster.
So we're moving towards using CSS animations,

00:37:25.560 --> 00:37:30.790
for example, rather than JavaScript.
And a lot of the new GWT widgets are doing

00:37:30.790 --> 00:37:38.670
exactly that, which is, relying on clever
CSS positioning rules to improve the performance.

00:37:38.670 --> 00:37:43.359
[pause]
We're talking about perceived latency.

00:37:43.359 --> 00:37:47.599
So you want to keep the application feeling
responsive at all points in time.

00:37:47.599 --> 00:37:53.560
And remember, even though you're writing your
code in Java using GWT, you are actually in

00:37:53.560 --> 00:37:59.560
fact in a single-threaded environment.
What this means is that, if you want an event

00:37:59.560 --> 00:38:04.690
to be processed, I click a button.
If you're still doing some JavaScript processing,

00:38:04.690 --> 00:38:07.090
we have to wait for this processing to be
complete.

00:38:07.090 --> 00:38:11.619
So it's best to parcel your JavaScript into
lots of small fragments so that we can keep

00:38:11.619 --> 00:38:14.520
the application responsive at all points in
time.

00:38:14.520 --> 00:38:20.820
And if you look at this diagram I have here.
And if you don't mind zooming in on a few

00:38:20.820 --> 00:38:23.890
things.
This is from our experiments we found that

00:38:23.890 --> 00:38:30.890
the on-mouse-down event tends to trigger before
the on-mouse-up event by half a second.

00:38:30.890 --> 00:38:34.910
So there's a really easy optimization to make
there.

00:38:34.910 --> 00:38:39.430
Do processing on on-mouse-down rather than
on-mouse-up and you'll give people the impression

00:38:39.430 --> 00:38:44.160
everything's half a second faster just by
switching the event you use.

00:38:44.160 --> 00:38:46.970
Okay?
And another important trick which we use throughout

00:38:46.970 --> 00:38:54.940
the wave user interface is what we call "optimistic
UI," optimistic user interface, where we assume

00:38:54.940 --> 00:38:58.640
everything is going to work.
If I type, we assume it will correctly get

00:38:58.640 --> 00:39:05.650
persisted to the server; it worked.
Rather than roundtrip, update, okay, we managed

00:39:05.650 --> 00:39:08.470
to persist it.
Now, show it to the user.

00:39:08.470 --> 00:39:11.680
It's a really good tip for all of you to use
in your applications.

00:39:11.680 --> 00:39:16.560
Give the user the impression that everything
worked and give them buttons like "undo" or

00:39:16.560 --> 00:39:20.930
"error notifications" after the fact.
That way, you're optimizing for the case where

00:39:20.930 --> 00:39:23.900
everything works.
If you're writing a good application, everything

00:39:23.900 --> 00:39:29.720
will work fast.
And one way to do this is to use GWT's deferred

00:39:29.720 --> 00:39:33.590
command.
That way, if I click a button, we do the thing

00:39:33.590 --> 00:39:38.150
that it associates with.
So, if I'm typing in Wave, show the text.

00:39:38.150 --> 00:39:43.850
And in a deferred command, because we need
the browser to update; we need to yield to

00:39:43.850 --> 00:39:49.260
the browser to refresh.
Now, we send off requests and use a batching

00:39:49.260 --> 00:39:52.500
approach as Joel mentioned.
So, really keep the application feeling as

00:39:52.500 --> 00:39:57.480
responsive as possible by deferring any kind
of busy work, anything that will take longer

00:39:57.480 --> 00:39:59.820
than a tenth of a second.

00:39:59.820 --> 00:40:04.690
&gt;&gt;Joel Webber: The other thing that Adam mentioned
a moment ago was leaning on the browser, leaning

00:40:04.690 --> 00:40:06.900
on native code.
If you don't have to write it, that's also

00:40:06.900 --> 00:40:09.910
good.
And leaning on native code is always faster.

00:40:09.910 --> 00:40:15.780
So resizing, again, we resize a panel within
something like Wave, or resize the window

00:40:15.780 --> 00:40:19.740
itself.
If that's sluggish, the app feels awkward

00:40:19.740 --> 00:40:21.280
and uncomfortable.
It just doesn't feel good.

00:40:21.280 --> 00:40:26.730
And in GWT 2.0, we introduced these layout
panels that actually lean on these process

00:40:26.730 --> 00:40:31.580
very heavily and very carefully so that you
can get predictable layout that is also very,

00:40:31.580 --> 00:40:36.030
very fast.
We won't go in deep dive on that right now,

00:40:36.030 --> 00:40:39.640
but again, tomorrow morning's talk, we'll
go into that in quite some detail.

00:40:39.640 --> 00:40:43.170
You should definitely be using these.
It helps you move your standards mode and

00:40:43.170 --> 00:40:47.490
it helps you keep things fast.
And it makes your life a lot easier.

00:40:47.490 --> 00:40:52.641
&gt;&gt;Adam Schuck: Okay, so we've told you four
places and some tips on how to make your application

00:40:52.641 --> 00:40:56.700
much faster.
Now, here's a hypothetical.

00:40:56.700 --> 00:41:01.370
You spend a few months; you use Speed Tracer
and some great tools; you figure out exactly

00:41:01.370 --> 00:41:05.339
why your application is slow; you make it
faster.

00:41:05.339 --> 00:41:10.570
And somehow, another developer on your team
touches one line of code, and the initial

00:41:10.570 --> 00:41:16.089
download doubles in size or clicks are being
handled irresponsibly.

00:41:16.089 --> 00:41:19.609
This is not that hypothetical.
This happened very much on the Google Wave

00:41:19.609 --> 00:41:22.580
team.
And we learned our lesson hopefully so none

00:41:22.580 --> 00:41:25.839
of you have to make the exact same mistake
as us.

00:41:25.839 --> 00:41:29.490
Things will get slower unless you are paying
attention to them.

00:41:29.490 --> 00:41:33.080
So it's very important that you to do latency-regression
testing.

00:41:33.080 --> 00:41:37.720
Have, most of you would have TVs in your office
showing the state of your continuous build;

00:41:37.720 --> 00:41:42.109
it's green or it's red.
It's just as important to track how fast your

00:41:42.109 --> 00:41:45.271
application is.
So, the two main areas you want to track,

00:41:45.271 --> 00:41:49.430
plot your download size.
As we mentioned, if you have a slow Internet

00:41:49.430 --> 00:41:52.830
connection, the size actually does make a
big difference.

00:41:52.830 --> 00:41:56.400
Plot your initial size, so we care about start-up
time.

00:41:56.400 --> 00:42:00.950
But also your total to see if there's any
ridiculous jumps in how much code is being

00:42:00.950 --> 00:42:05.160
added, any inefficient JavaScript.
And then, the other aspect is measure.

00:42:05.160 --> 00:42:10.180
Actually measure the performance in milliseconds,
in seconds, of your application.

00:42:10.180 --> 00:42:15.690
For Wave, we care about the Client loading
fast, waves opening fast, search performing

00:42:15.690 --> 00:42:20.810
quickly. There's a lot of other things, but
really, it's best to focus on a small number

00:42:20.810 --> 00:42:26.220
of key metrics for your application.
And measure them both in production conditions,

00:42:26.220 --> 00:42:29.860
what your user's experience.
It's important to note, you don't want your

00:42:29.860 --> 00:42:33.280
whole team saying, "Yeah, it's fast."
And all your users saying, "Wow, it's slow

00:42:33.280 --> 00:42:35.570
today."
So it's really important you know what your

00:42:35.570 --> 00:42:40.450
users are feeling; and also, lab conditions.
And I'll explain why in a second.

00:42:40.450 --> 00:42:46.010
Plotting your download size, very important.
As mentioned earlier, Wave team, we love adding

00:42:46.010 --> 00:42:50.100
new features.
So up, up, up, up, up, up, when our initial

00:42:50.100 --> 00:42:53.760
download.
Then we politely ask the GWT team to create

00:42:53.760 --> 00:42:58.270
code-splitting for us.
And much later, you see a sharp drop.

00:42:58.270 --> 00:43:04.240
And actually later on, we found out it's not
optimal to just make it as small as possible,

00:43:04.240 --> 00:43:08.180
because we want the inbox to be optimized.
The other interesting thing in this chart,

00:43:08.180 --> 00:43:12.970
the other reason you want to track it, it's
not just to celebrate whenever it goes down,

00:43:12.970 --> 00:43:17.000
but whenever you spot a regression.
So if Joel just zooms in on this little hill

00:43:17.000 --> 00:43:20.060
we have here.
Somebody in our team accidentally checked

00:43:20.060 --> 00:43:27.530
in an Adobe Photoshop PNG with all the layers.
Rather than a nice, compressed, crushed PNG

00:43:27.530 --> 00:43:29.640
file.
We noticed this on the chart. Everyone went,

00:43:29.640 --> 00:43:33.440
"Why did it go up?"
"Aha! We know now." We made it go down.

00:43:33.440 --> 00:43:38.310
So it's great to track this, because you find
when you make mistakes, and we're all human

00:43:38.310 --> 00:43:41.170
here.
It's much better to set up the system; rather

00:43:41.170 --> 00:43:48.070
than assume you're not going to make mistakes
and trust each other, dare I say it.

00:43:48.070 --> 00:43:52.220
Timing is very important.
So, it's important to track what your users

00:43:52.220 --> 00:43:55.260
feel.
And you can see, it's a noisy data.

00:43:55.260 --> 00:43:59.570
But we're looking at here, creation of a wave
from the search panel.

00:43:59.570 --> 00:44:07.240
And when we rolled out this on-demand rendering,
we saw a sharp drop, which is great.

00:44:07.240 --> 00:44:12.440
It's really useful to see this information,
because every week you get to see a jump in

00:44:12.440 --> 00:44:17.480
your chart, and you go, "Aha! We're faster."
Everyone rejoices, pop open a few beers, and

00:44:17.480 --> 00:44:21.670
everyone's happy.
Then, the next question comes, "Why is it

00:44:21.670 --> 00:44:26.650
faster?" And everyone puts up their hand and
says, "It's because of what I did."

00:44:26.650 --> 00:44:30.460
Why does this happen?
Because we only push a new version of our

00:44:30.460 --> 00:44:36.990
application every week, so, we don't actually
know why it got faster, why it got slower.

00:44:36.990 --> 00:44:41.120
And it's very important to know what your
users are experiencing, but the next question

00:44:41.120 --> 00:44:45.900
can't be answered by this data.
This is why we do lab timings.

00:44:45.900 --> 00:44:51.030
So, we actually track, we run every hour in
a controlled environment.

00:44:51.030 --> 00:44:55.520
We open waves 20 times in an average data
and get medians.

00:44:55.520 --> 00:44:58.710
And what you're looking at here is the client
load inquirim.

00:44:58.710 --> 00:45:03.349
This is in a controlled environment.
So, pretty close to "runs every time somebody

00:45:03.349 --> 00:45:08.760
commits code," which is important.
And we can see here…the chart went up.

00:45:08.760 --> 00:45:13.020
Somebody made our client load ten percent
slower.

00:45:13.020 --> 00:45:17.440
In the old days, we'd find this out one week
later when we got those big charts.

00:45:17.440 --> 00:45:21.720
Now, we know exactly what happened.
Somebody does a binary search, runs a test

00:45:21.720 --> 00:45:26.109
in the lab.
"Aha!" And then, a little bit later, we fix

00:45:26.109 --> 00:45:28.950
the regression; really important to track
this.

00:45:28.950 --> 00:45:32.930
This is how you keep your application fast
once you've made it fast.

00:45:32.930 --> 00:45:38.869
And the other point of interest in the top
right chart is, this is Wave-opening Chrome.

00:45:38.869 --> 00:45:42.050
So it's good news when it goes up, because
we fix it.

00:45:42.050 --> 00:45:45.310
And it's good news when it goes down, because
we made something faster.

00:45:45.310 --> 00:45:49.840
And now, when we're celebrating on a Friday
afternoon that we made everything faster and

00:45:49.840 --> 00:45:52.910
someone looks around the room, only one person
gets to put their hand up.

00:45:52.910 --> 00:45:56.820
So we now know who's going to fix bugs and
we know who gets the credit.

00:45:56.820 --> 00:46:01.520
And turns out, motivating people in your team,
if you just measure something, it's going

00:46:01.520 --> 00:46:04.950
to get faster.
That's just something we've noticed on the

00:46:04.950 --> 00:46:10.440
Wave team.
Some other tools that are really interesting.

00:46:10.440 --> 00:46:13.250
Speed Tracer, if you went to the talk this
morning, you'll have seen.

00:46:13.250 --> 00:46:16.300
It's a really fantastic profiler.
Look into it.

00:46:16.300 --> 00:46:21.450
If you missed the talk, watch it on YouTube.
Great for deep diving on the rendering and

00:46:21.450 --> 00:46:25.430
user-interaction type behavior.
So, we have user events.

00:46:25.430 --> 00:46:29.010
And I believe all of the links for everything
I've talked about and Joel has talked about

00:46:29.010 --> 00:46:33.359
today will be in the Wave.
So you don't need to furiously write down

00:46:33.359 --> 00:46:37.940
URLs if you are.
We also have GWT Inspector widget.

00:46:37.940 --> 00:46:40.760
As Joel mentioned, widgets are bad in general.

00:46:40.760 --> 00:46:42.300
&gt;&gt;Joel Webber: -- in large quantities.

00:46:42.300 --> 00:46:44.760
&gt;&gt;Adam Schuck: In large quantities, widgets
are bad.

00:46:44.760 --> 00:46:49.250
So this is a useful little bookmarklet to
tell you how many widgets you have in your

00:46:49.250 --> 00:46:52.600
application.
If you feel like a laugh, point this at Google

00:46:52.600 --> 00:46:55.060
Wave.
It's actually orders of magnitude larger than

00:46:55.060 --> 00:46:57.810
it should be.
We know we have room for improvement.

00:46:57.810 --> 00:47:03.550
And Google Page Speed: a great Firefox plug
in helps you improve your start-up performance.

00:47:03.550 --> 00:47:08.170
It tells you things like caching, G zipping,
headers, sending cookies.

00:47:08.170 --> 00:47:13.839
This is a nice little useful tool to improve
your page speed. And we have time.

00:47:13.839 --> 00:47:14.890
&gt;&gt;Joel Webber: We have time.

00:47:14.890 --> 00:47:18.030
&gt;&gt;Adam Schuck: Great.
So, I'll give you a quick sample of what we

00:47:18.030 --> 00:47:22.820
actually measure if I can find it.
I believe it's this one. Here we go.

00:47:22.820 --> 00:47:28.930
So. I mentioned we do lab timings.
We like to measure how quickly waves open.

00:47:28.930 --> 00:47:35.890
And we have a special mode of our client which
we run using Selenium.

00:47:35.890 --> 00:47:40.320
The automated script clicks speed tests and
runs all these various tests.

00:47:40.320 --> 00:47:50.700
And we're going to start opening a large wave,
which, let's see, it has 620 odd participants.

00:47:50.700 --> 00:47:54.280
Which is more than we recommend putting on
your waves -- not just for performance reasons,

00:47:54.280 --> 00:47:57.600
but if you actually want to get any work done,
that's a lot of people.

00:47:57.600 --> 00:48:02.369
And it's got 175 messages in it.
And we run this test every hour.

00:48:02.369 --> 00:48:07.000
We get 20 samples.
We extract the data from this.

00:48:07.000 --> 00:48:10.740
This is what it looks like for Wave to run
lab timings.

00:48:10.740 --> 00:48:17.390
And I'll stop there. Great. [pause]

00:48:17.390 --> 00:48:22.680
&gt;&gt;Joel Webber: Couple of odds and ends to
wrap up.

00:48:22.680 --> 00:48:26.410
I mentioned before that we work really hard
to do things within GWT, so that you don't

00:48:26.410 --> 00:48:30.690
have to do anything.
Usually, those take the form of compiler optimizations

00:48:30.690 --> 00:48:33.310
or library optimizations.
In the case of the compiler optimization,

00:48:33.310 --> 00:48:38.640
we try to make those default, wherever humanly
possible, so you don't have a rat's nest of

00:48:38.640 --> 00:48:41.580
GCT-style command line options.
More recently, we've started discovering some

00:48:41.580 --> 00:48:46.230
that have this property that they are incorrect,
but in a way you probably don't care about,

00:48:46.230 --> 00:48:52.050
violate Java semantics in minor ways, but
they invariably make your apps smaller and/or

00:48:52.050 --> 00:48:54.780
faster.
Those we've had to deal with wrong with tax

00:48:54.780 --> 00:48:59.329
options so we don't inadvertently break your
code, which I think you would probably not

00:48:59.329 --> 00:49:01.630
prefer.
And as we discover more, we'll keep adding

00:49:01.630 --> 00:49:04.390
those.
And as we discover more, we will obviously

00:49:04.390 --> 00:49:07.110
document those so that you can take advantage
of them.

00:49:07.110 --> 00:49:12.570
And if you were in Ray's talk earlier, I believe
it was just last hour, he goes into some detail

00:49:12.570 --> 00:49:15.570
on that.
And if not, I would definitely recommend checking

00:49:15.570 --> 00:49:18.570
it out on YouTube.
There's some really interesting stuff going

00:49:18.570 --> 00:49:24.521
on in the compiler.
So again, to recap, four things you need to

00:49:24.521 --> 00:49:29.300
think about: your app needs to start fast,
you need to get data fast, you need to get

00:49:29.300 --> 00:49:33.830
it on the screen fast, and you need to keep
fine-grained user interactions fast…snappy.

00:49:33.830 --> 00:49:39.390
&gt;&gt;Adam Schuck: And now that you've made it
fast, keep it fast; measure it, really track

00:49:39.390 --> 00:49:45.640
it, and celebrate when your charts go up as
well as when they go down.

00:49:45.640 --> 00:49:46.640
Thank you very much.

00:49:46.640 --> 00:49:47.980
[Applause]

00:49:47.980 --> 00:50:00.200
&gt;&gt;Adam Schuck: Okay. We're now going to take
some questions both from the microphones if

00:50:00.200 --> 00:50:05.080
you're in this room, and we're also going
to use the Wave, which hopefully has some

00:50:05.080 --> 00:50:11.550
questions lined up for us.
[pause] Any questions? Nope. All right.

00:50:11.550 --> 00:50:15.500
Then we're going to go for the microphone.

00:50:15.500 --> 00:50:19.240
&gt;&gt;Joel Webber: We apologize. Dory, the moderator,
did a bit of a face-plant there.

00:50:19.240 --> 00:50:22.710
So, but feel free to ask with the mic. And
do go to the mics please.

00:50:22.710 --> 00:50:24.660
It's much easier for the recording.

00:50:24.660 --> 00:50:30.280
Male #1: Concerning using the CSS files in
Client Bundle?

00:50:30.280 --> 00:50:31.280
&gt;&gt;Joel Webber: Mhmm…

00:50:31.280 --> 00:50:33.849
&gt;&gt;Male #1: My observation, I've played around
with it some.

00:50:33.849 --> 00:50:40.001
It seems like it makes using existing tools
like Firebug or other tools where you can

00:50:40.001 --> 00:50:44.930
edit your CSS on the fly a little more difficult.
What's your experience with that?

00:50:44.930 --> 00:50:48.770
And how have you gotten around that?
We solve problems like with Firebugs.

00:50:48.770 --> 00:50:53.210
If we have CSS problems, we'll play with it,
and I find it a little harder to do that with

00:50:53.210 --> 00:50:54.210
it.

00:50:54.210 --> 00:50:55.210
&gt;&gt;Joel Webber: Mhhmm--

00:50:55.210 --> 00:50:56.210
&gt;&gt;Adam Schuck:--Mhhmm... So from the Wave
perspective?

00:50:56.210 --> 00:50:57.210
&gt;&gt;Male #1: Yeah.

00:50:57.210 --> 00:50:59.030
&gt;&gt;Adam Schuck: Ok, that's actually an interesting
question.

00:50:59.030 --> 00:51:07.109
So, of course, there are a few flags you can
parse into GWT that allow you to leave the

00:51:07.109 --> 00:51:11.760
CSS unobfuscated. So there's that.
And that does allow you to play with it in

00:51:11.760 --> 00:51:18.750
hosted mode in the time it takes to refresh.
But we have found also in practice that using

00:51:18.750 --> 00:51:23.780
it, GWT, in conjunction with Firebug, with
developer tools, very helpful.

00:51:23.780 --> 00:51:27.030
It's much quicker to iterate directly on the
HTML.

00:51:27.030 --> 00:51:31.780
So that's been our experience.
But the GWT team is working very hard to try

00:51:31.780 --> 00:51:35.480
and improve the cycle between actually changing
the source code.

00:51:35.480 --> 00:51:40.200
&gt;&gt;Joel Webber: Right, yes. We recognize the
dev mode, hosted mode, AP call, is definitely

00:51:40.200 --> 00:51:43.310
slower than it should be and we're definitely
working very hard on that.

00:51:43.310 --> 00:51:47.470
But also as Adam said, don't forget to, I
don't recall off the top of my head.

00:51:47.470 --> 00:51:50.840
Do look at the docs.
But if you pass in the unobfuscated flag.

00:51:50.840 --> 00:51:55.430
I believe it's either a flag or a module you
need to include.

00:51:55.430 --> 00:51:58.560
That will turn off obfuscation of the CSS
names, which makes it a lot easier to track

00:51:58.560 --> 00:52:04.140
the back and forth between, let's say firebug
editing and the original source.

00:52:04.140 --> 00:52:06.300
Not as easy as we'd like it to be and we're
looking into ways to make that better, but

00:52:06.300 --> 00:52:08.970
we recognize your pain there. Certainly.

00:52:08.970 --> 00:52:15.290
&gt;&gt;Male #2: Yes, I am creating a software application
data -- was going to pull about 5,000 names

00:52:15.290 --> 00:52:18.510
from the database.
And so that, you know, like in your example

00:52:18.510 --> 00:52:23.200
you just type it in, it pulls the names up.
I know you guys say "Stay away from widget

00:52:23.200 --> 00:52:24.910
as much as possible," and I've been trying
to do that.

00:52:24.910 --> 00:52:25.910
&gt;&gt;Joel Webber: --Right.

00:52:25.910 --> 00:52:30.661
&gt;&gt;Male #2: But what I've been using Json to
pull, to do a serial from the server.

00:52:30.661 --> 00:52:36.849
And it's been, the performance has been okay.
I haven't used the Speed Tracer to check it

00:52:36.849 --> 00:52:37.849
yet, but I will.

00:52:37.849 --> 00:52:38.849
&gt;&gt;Joel Webber: --Right.

00:52:38.849 --> 00:52:42.790
&gt;&gt;Male #2: But I wanted to make sure that,
is that the best recommended option where

00:52:42.790 --> 00:52:49.470
you're pulling such a large amount of names?
And also, if it isn't, what do you recommend

00:52:49.470 --> 00:52:54.570
using to pull like a large database down and
where they'll appear as soon as you type them

00:52:54.570 --> 00:52:55.570
in?

00:52:55.570 --> 00:53:00.570
&gt;&gt;Joel Webber: So, two things I'd say.
One, most of the serialization formats with

00:53:00.570 --> 00:53:05.579
the possible exception of XML, but don't quote
me on that, I'm not positive, are roughly

00:53:05.579 --> 00:53:08.330
equivalent in performance, at least in the
same order of magnitude.

00:53:08.330 --> 00:53:13.720
So using Json over GWT RPC over XML over protocol
buffer, swift, whatever; they're going to

00:53:13.720 --> 00:53:17.720
put you in relatively similar place in terms
of the amount of data.

00:53:17.720 --> 00:53:21.360
The piece of, the place where you really have
leverage is in how much data you actually

00:53:21.360 --> 00:53:25.220
send at a time.
The problem with all these formats is, you

00:53:25.220 --> 00:53:28.730
can't stream them.
You can't say, "Parse the first 37 of these"

00:53:28.730 --> 00:53:31.230
unless you actually break it up.
And the only place where you can realistically

00:53:31.230 --> 00:53:35.140
do that is on the server, because something
like Json isn't like parsed JavaScript, right?

00:53:35.140 --> 00:53:41.190
So you can't parse partway through, or at
least not the way browser is built.

00:53:41.190 --> 00:53:47.901
So I would say basically, one, split it up.
So you're not requesting really large chunks.

00:53:47.901 --> 00:53:51.089
And also, really large chunks take a long
time to process in addition to being, taking

00:53:51.089 --> 00:53:56.410
longer to download.
Split it up, and if you are trying to do something

00:53:56.410 --> 00:54:01.359
like type-ahead search, in that sample right
there, that was all client side.

00:54:01.359 --> 00:54:07.099
Now, that particular sample also does server
side search, but only when you actually hit

00:54:07.099 --> 00:54:11.020
the enter key.
Typically, on the amount of data that you

00:54:11.020 --> 00:54:14.730
can actually display on the screen there,
you'd have to work pretty hard to make it

00:54:14.730 --> 00:54:17.339
slow to implement something like that type-ahead
search.

00:54:17.339 --> 00:54:22.579
As long as your data is indexed or ordered
in the right way.

00:54:22.579 --> 00:54:28.951
So, as long as you just limit it to the amount
of data that you can actually get on the screen,

00:54:28.951 --> 00:54:31.820
the actual work that you're doing.
You'll typically stay within pretty reasonable

00:54:31.820 --> 00:54:35.550
limits. It's only when you get into processing
thousands and thousands of things that you

00:54:35.550 --> 00:54:36.560
really get into problems.
And that's the case you want to avoid.

00:54:36.560 --> 00:54:37.560
&gt;&gt;Male #2: Okay, yah.

00:54:37.560 --> 00:54:38.560
&gt;&gt;Joel Webber: I hope that makes sense.

00:54:38.560 --> 00:54:39.560
&gt;&gt;Male #2: Thank you.

00:54:39.560 --> 00:54:43.869
&gt;&gt;Adam Schuck: Definitely optimizing to avoid
the network request if you can.

00:54:43.869 --> 00:54:44.980
&gt;&gt;Joel Webber: Right here…

00:54:44.980 --> 00:54:49.990
&gt;&gt;Male #3 I have a question about, you show
the example where the search filter. You type

00:54:49.990 --> 00:54:54.770
a couple of characters in and it would highlight
the right records.

00:54:54.770 --> 00:54:58.160
I understand how, if you have a lot of widgets,
it would take a long time to load.

00:54:58.160 --> 00:54:59.329
&gt;&gt;Joel Webber: Mhhmm-

00:54:59.329 --> 00:55:05.420
&gt;&gt;Male #3: How does it become slow if you
have a lot of widgets by doing that kind of

00:55:05.420 --> 00:55:09.380
filtering or typing it in, "highlights," and
then, hitting "enter", and then you end up

00:55:09.380 --> 00:55:12.440
with only those records.
How is having a lot of widgets? I feel like

00:55:12.440 --> 00:55:15.920
it's intuitively understandable, but maybe
a little more detail.

00:55:15.920 --> 00:55:18.020
Why is it slow in that way if you have a lot
of widgets?

00:55:18.020 --> 00:55:21.390
&gt;&gt;Joel Webber: Well, there's really two ways
that can get slow.

00:55:21.390 --> 00:55:26.831
One is the main thing is the things you would
expect to be fast in a browser, things like,

00:55:26.831 --> 00:55:31.420
I don't know, "set text" often aren't when
they're called in large numbers.

00:55:31.420 --> 00:55:35.990
So, couple of cases, like if you saw Kelly's
talk earlier this morning about…I think

00:55:35.990 --> 00:55:40.470
there was a case where he managed to create
a table that triggered layout thousands of

00:55:40.470 --> 00:55:43.460
times.
Things just get slow for freakish and bizarre

00:55:43.460 --> 00:55:46.990
reasons.
And what these new widgets that we've built

00:55:46.990 --> 00:55:52.230
allow you to do is to, they are designed in
such a way they give us the opportunity to

00:55:52.230 --> 00:55:54.420
do the things that we actually know to be
fast.

00:55:54.420 --> 00:56:00.050
In this case, it involves aggregating all
those changes into a single interHTML call.

00:56:00.050 --> 00:56:05.710
If that is the fastest thing to do.
And we're working on optimizing for all the

00:56:05.710 --> 00:56:09.050
various cases that come up.
You know, if I change 3 rows as opposed to

00:56:09.050 --> 00:56:12.730
27 of them.
You know, there might be a crossover.

00:56:12.730 --> 00:56:16.400
It might be faster to actually go set the
individual text, for example.

00:56:16.400 --> 00:56:23.330
But it gives us the leverage to do it in the
right place in the right time in a way that

00:56:23.330 --> 00:56:24.490
won't anger the layout gods, for example.

00:56:24.490 --> 00:56:27.060
&gt;&gt;Male #3: By keeping it HTML-centered?

00:56:27.060 --> 00:56:32.160
&gt;&gt;Joel Webber: Right. By using interHTML where
that actually, where we determined that that's

00:56:32.160 --> 00:56:36.130
the fastest thing.
That's typically the reason, especially on

00:56:36.130 --> 00:56:40.980
older browsers where they typically optimize
for static HTML rendering.

00:56:40.980 --> 00:56:46.470
&gt;&gt;Male #4: You mentioned "infinite scroll"
and the idea of having, I guess, what load

00:56:46.470 --> 00:56:49.869
is just what you see it.
Is that something that Google Web Toolkit

00:56:49.869 --> 00:56:53.000
does for us or is that still on us to set
that up?

00:56:53.000 --> 00:56:57.330
&gt;&gt;Joel Webber: It will as soon as I whip my
hacked-up demos into shape. [laugh]

00:56:57.330 --> 00:57:01.750
It's certainly implementable right now.
It's just a little bit like brain surgery.

00:57:01.750 --> 00:57:05.930
But, the point, one of the major points, of
building these widgets, is that it allows

00:57:05.930 --> 00:57:09.369
us to do that in a really optimal way.
So this is sort of the first step.

00:57:09.369 --> 00:57:13.369
I wanted to make sure we got these things
done before we try to tackle that problem.

00:57:13.369 --> 00:57:17.800
Because using …tackling that problem on
top of large numbers of widgets just wouldn't

00:57:17.800 --> 00:57:22.569
be as effective.
So, look for some demos once the dust settles

00:57:22.569 --> 00:57:28.440
after IO and after we get 2.1 out the door
that will start to address this problem.

00:57:28.440 --> 00:57:32.450
We're going to try and if you may have noticed,
if you're following our trunk, we've added

00:57:32.450 --> 00:57:37.780
this Bike Shed Directory where we can put
totally unfinished, half-baked code and samples

00:57:37.780 --> 00:57:38.930
and things like that.
We'll definitely be doing that work in the

00:57:38.930 --> 00:57:39.930
open in there.

00:57:39.930 --> 00:57:40.930
&gt;&gt;Male #4: Thank you.

00:57:40.930 --> 00:57:45.240
&gt;&gt;Adam Schuck: I think we might just have
time for our last two questions.

00:57:45.240 --> 00:57:50.630
&gt;&gt;Male #5: Okay. Yeah, towards the beginning
of the call, you mentioned that it's possible

00:57:50.630 --> 00:57:54.350
to look at the header information on the server
side and then send back just the skip that's

00:57:54.350 --> 00:57:57.001
necessary.
I was also looking for something like that

00:57:57.001 --> 00:58:00.980
for HTML 5 application caches where you need
to know exactly the file name.

00:58:00.980 --> 00:58:08.260
So my question is, is there any utility or
library or something that lets you map the

00:58:08.260 --> 00:58:10.750
user agent name to the appropriate script
name?

00:58:10.750 --> 00:58:12.210
&gt;&gt;Joel Webber: Right.

00:58:12.210 --> 00:58:17.490
&gt;&gt;Adam Schuck: So we're not doing this yet
for Wave, but there are other applications

00:58:17.490 --> 00:58:21.290
within Google that are doing exactly what
you said, selecting the correct version.

00:58:21.290 --> 00:58:27.920
I believe that is done in a different way
on the client side, but I'm not actually sure.

00:58:27.920 --> 00:58:32.180
I have to get back to you on that one.
But definitely, it is on the roadmap for GWT

00:58:32.180 --> 00:58:38.920
to get this service side selection mechanism.
And, of course, an associated app cache mechanism

00:58:38.920 --> 00:58:40.494
out into the open source so that everyone
can use it.

00:58:40.494 --> 00:58:41.494
&gt;&gt;Joel Webber: Right.

00:58:41.494 --> 00:58:45.180
&gt;&gt;Adam Schuck: Because this is not just a
benefit to Google; it's a benefit to anyone

00:58:45.180 --> 00:58:48.050
using GWT.
And there's no point in me telling you about

00:58:48.050 --> 00:58:49.680
it if you can't use it.

00:58:49.680 --> 00:58:54.150
&gt;&gt;Joel Webber: Right. Basically, as soon as
we get the server side selection script ready

00:58:54.150 --> 00:58:58.780
for use, anything else that involves affecting
user agent on the server would naturally flow

00:58:58.780 --> 00:59:02.290
from there.
So that's sort of the first step.

00:59:02.290 --> 00:59:07.609
&gt;&gt;Male #6: I may misunderstood, but I saw
an example in the beginning so you'd request

00:59:07.609 --> 00:59:13.520
data before anything is loaded in the browser?
So how does it know that it needs data?

00:59:13.520 --> 00:59:15.500
&gt;&gt;Joel Webber: I'm sorry, could you repeat
the question?

00:59:15.500 --> 00:59:22.020
&gt;&gt;Male #6: In the beginning you saw that well,
used to be four calls now there are two calls

00:59:22.020 --> 00:59:25.450
and it looks like data was requested with
the first page

00:59:25.450 --> 00:59:26.570
&gt;&gt;Adam Schuck: Mhmm…

00:59:26.570 --> 00:59:31.150
&gt;&gt;Male #6: and then returned asynchronously.
So, how did it know that it needed that data?

00:59:31.150 --> 00:59:33.170
&gt;&gt;Adam Schuck: How did we know the user had--?

00:59:33.170 --> 00:59:36.070
&gt;&gt;Male #6: --Yeah, because the user is not
smoldered so?

00:59:36.070 --> 00:59:40.150
&gt;&gt;Adam Schuck: Okay.
So in the Wave example, we are assuming the

00:59:40.150 --> 00:59:44.980
user is already authenticated.
So we know exactly which user it is and we

00:59:44.980 --> 00:59:48.150
know that we're going to download the inbox.
Is that the question you're asking?

00:59:48.150 --> 00:59:50.240
&gt;&gt;Joel Webber: Using cookies, in other words.

00:59:50.240 --> 00:59:55.460
&gt;&gt;Male #6: So, how can it? So, before anything
is loaded in the browser, you can't just request

00:59:55.460 --> 00:59:56.460
data, is it?

00:59:56.460 --> 00:59:59.690
&gt;&gt;Adam Schuck: So it's the very first request
for the HTML page.

00:59:59.690 --> 01:00:06.510
&gt;&gt;Joel Webber: Right. Specifically what they're
doing, if I understand you correctly, is that,

01:00:06.510 --> 01:00:12.180
because the request comes with a cookie for
the outer HTML page, it starts sending back

01:00:12.180 --> 01:00:17.190
the, it starts fetching from the back end
and then sending back the initial data as

01:00:17.190 --> 01:00:22.810
part of the actual outer HTML page.
So, while that page is still streaming down,

01:00:22.810 --> 01:00:26.420
because of the way that the start-up semantics
of HTML and JavaScript, you can start running

01:00:26.420 --> 01:00:29.490
scripts even though the page isn't fully downloaded
and takes advantage of that.

01:00:29.490 --> 01:00:30.490
&gt;&gt;Male #6: Mhmm.

01:00:30.490 --> 01:00:33.490
&gt;&gt;Joel Webber: So the page download actually
takes a long time as its streaming back results.

01:00:33.490 --> 01:00:38.150
But, the script requests and other kinds of
start-up code can be running while that data

01:00:38.150 --> 01:00:39.150
is streaming.

01:00:39.150 --> 01:00:40.150
&gt;&gt;Adam Schuck: --That's right.

01:00:40.150 --> 01:00:43.650
&gt;&gt;Joel Webber: --That also allows you to wash
out the cost of construction of UI and everything

01:00:43.650 --> 01:00:47.000
like that as well.
Like, all of that can take place during that

01:00:47.000 --> 01:00:48.000
streaming.

01:00:48.000 --> 01:00:52.250
&gt;&gt;Adam Schuck: I'd highly recommend actually
pulling up Firebug or Chrome developer tools

01:00:52.250 --> 01:00:57.630
and looking how Wave starts up and just see
how we use the initial HTML page, reuse it

01:00:57.630 --> 01:00:58.630
for the data as well as to download the JavaScript.
Okay, we're out of time.

01:00:58.630 --> 01:01:00.109
&gt;&gt;Joel Webber: Thanks everybody.

01:01:00.109 --> 01:01:02.569
&gt;&gt;Adam Schuck: Thank you very much.

01:01:02.569 --> 01:01:02.979
[applause]

