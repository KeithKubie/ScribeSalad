WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.718
[LOGO MUSIC]

00:00:03.778 --> 00:00:06.320
GURU SOMADDER: We are going to
be talking about the streaming

00:00:06.320 --> 00:00:10.100
tech behind Stadia as well
as behind Project Stream

00:00:10.100 --> 00:00:14.790
and show you why that tech
works as well as it did.

00:00:14.790 --> 00:00:17.118
I'm Guru Somadder, an
engineering leader at Google

00:00:17.118 --> 00:00:18.660
and part of the team
that brought you

00:00:18.660 --> 00:00:20.970
Project Stream and now Stadia.

00:00:20.970 --> 00:00:24.090
I came into cloud gaming
almost by accident, an accident

00:00:24.090 --> 00:00:27.250
that I'm still trying to recover
from eight years and counting.

00:00:27.250 --> 00:00:29.347
I also spent a decade
and a half building care

00:00:29.347 --> 00:00:31.590
at great networking products.

00:00:31.590 --> 00:00:32.702
ROB MCCOOL: Hi, I'm Rob.

00:00:32.702 --> 00:00:34.410
I'm the tech lead on
our streaming system

00:00:34.410 --> 00:00:36.270
and my background is
in network servers

00:00:36.270 --> 00:00:38.105
for the web and structured AI.

00:00:38.105 --> 00:00:40.650
I started working on
cloud gaming in 2007

00:00:40.650 --> 00:00:42.300
when a friend called
me and said, dude,

00:00:42.300 --> 00:00:43.180
you got to see this.

00:00:43.180 --> 00:00:45.840
And a lot of people do that,
but this time they were right.

00:00:45.840 --> 00:00:47.903
I took a two year
detour in 2012 to work

00:00:47.903 --> 00:00:49.320
through the semantic
understanding

00:00:49.320 --> 00:00:51.690
systems in Google search.

00:00:51.690 --> 00:00:52.765
Hey, I'm Khaled.

00:00:52.765 --> 00:00:54.390
I've been our product
manager at Google

00:00:54.390 --> 00:00:57.850
for about five years with a
background in game development,

00:00:57.850 --> 00:01:00.150
most recently on Project
Stream and now Stadia.

00:01:03.820 --> 00:01:05.820
GURU SOMADDER: So we are
part of an internal sub

00:01:05.820 --> 00:01:08.320
team that we call playability.

00:01:08.320 --> 00:01:11.380
It is a measure of the
overall quality of gameplay

00:01:11.380 --> 00:01:14.160
as perceived by players.

00:01:14.160 --> 00:01:16.890
And there are many variables
that affect playability,

00:01:16.890 --> 00:01:18.840
the game being played,
the environment

00:01:18.840 --> 00:01:21.060
it is being played in, the
controls, that display,

00:01:21.060 --> 00:01:22.620
and many more.

00:01:22.620 --> 00:01:25.740
Our team is focused on ensuring
that the experience delivered

00:01:25.740 --> 00:01:28.710
by Stadia is
consistent, enjoyable,

00:01:28.710 --> 00:01:30.690
and as exact in it's
delivery as that

00:01:30.690 --> 00:01:33.605
intended by the developer
of a particular title.

00:01:33.605 --> 00:01:35.730
This means we are focused
on designing and building

00:01:35.730 --> 00:01:38.100
our real time great
adaptation and streaming

00:01:38.100 --> 00:01:40.680
infrastructure, also
known as the streamer,

00:01:40.680 --> 00:01:43.500
building the API sent tools
that allow you to interface

00:01:43.500 --> 00:01:45.750
with our platform, and
of course, in optimizing

00:01:45.750 --> 00:01:49.410
the player's overall gameplay
experience all at a Google

00:01:49.410 --> 00:01:51.630
scale.

00:01:51.630 --> 00:01:53.220
As our team was
being formed, we were

00:01:53.220 --> 00:01:55.890
given what would be considered
a pretty straightforward goal,

00:01:55.890 --> 00:01:57.840
deliver the best
gaming experience.

00:01:57.840 --> 00:01:59.620
Simple, right?

00:01:59.620 --> 00:02:02.412
Well, as it turns
out, not so much,

00:02:02.412 --> 00:02:04.620
especially as we are trying
to establish a completely

00:02:04.620 --> 00:02:06.600
new avenue of gaming.

00:02:06.600 --> 00:02:09.030
In this talk we want to
walk you through our journey

00:02:09.030 --> 00:02:12.858
and our efforts in
achieving that goal.

00:02:12.858 --> 00:02:14.650
So here's what we are
going to cover today.

00:02:14.650 --> 00:02:16.150
We know that not
everybody here is

00:02:16.150 --> 00:02:18.150
conversant with the problem
space and challenges

00:02:18.150 --> 00:02:19.290
of cloud gaming.

00:02:19.290 --> 00:02:21.000
So we going to
talk and establish

00:02:21.000 --> 00:02:22.650
some common understanding.

00:02:22.650 --> 00:02:24.780
We'll talk about the
extensive research

00:02:24.780 --> 00:02:27.690
we took to understand this
space, the streamer, which

00:02:27.690 --> 00:02:30.630
is the realization of that
research, Project Stream,

00:02:30.630 --> 00:02:32.610
we chose a wide
scale test for it.

00:02:32.610 --> 00:02:34.980
And finally, wrap up
with some of the APIs

00:02:34.980 --> 00:02:39.560
and tools we have available
for even deeper optimization.

00:02:39.560 --> 00:02:43.730
But first, some background to
establish common understanding.

00:02:43.730 --> 00:02:46.190
To be successful, a
cloud gaming system

00:02:46.190 --> 00:02:48.870
has to satisfy three
fundamental requirements.

00:02:48.870 --> 00:02:51.800
It has to be real time,
consistent, and exact.

00:02:51.800 --> 00:02:54.890
Players expect the game
to react to their input

00:02:54.890 --> 00:02:58.730
with expected changes in a
natural and real time manner.

00:02:58.730 --> 00:03:00.800
It must also provide a
consistent experience

00:03:00.800 --> 00:03:03.680
across a variety of
player environments.

00:03:03.680 --> 00:03:05.120
And it must provide
an experience

00:03:05.120 --> 00:03:11.260
that is exact in its delivery
as that game developer intended.

00:03:11.260 --> 00:03:13.740
So how is this different from
your typical video streaming

00:03:13.740 --> 00:03:15.480
service like YouTube?

00:03:15.480 --> 00:03:17.640
To better understand
that, let's look at one

00:03:17.640 --> 00:03:19.980
possible and greatly
simplified architecture

00:03:19.980 --> 00:03:23.400
for that use for
passive video streaming.

00:03:23.400 --> 00:03:25.260
Media to be transmitted
is typically

00:03:25.260 --> 00:03:27.270
hosted in remote
data centers and can

00:03:27.270 --> 00:03:31.320
take advantage of offline
encoding and optimizations.

00:03:31.320 --> 00:03:33.630
Communication and
transmission is typically

00:03:33.630 --> 00:03:36.360
done over a reliable
protocol like HDTV

00:03:36.360 --> 00:03:38.580
sent in 2 to 10 second chunks.

00:03:38.580 --> 00:03:42.250
Real time latency is
less of a consideration.

00:03:42.250 --> 00:03:45.010
Junk nature also lends
itself really well

00:03:45.010 --> 00:03:48.490
to standard internet
caches along the way.

00:03:48.490 --> 00:03:52.000
Clients fetch content on
demand and cache as needed.

00:03:52.000 --> 00:03:55.600
These caches make the client
playback smooth and very

00:03:55.600 --> 00:03:59.130
resilient to network failures.

00:03:59.130 --> 00:04:00.660
So how is cloud
gaming different?

00:04:00.660 --> 00:04:02.480
First of all, it's
interactive, which

00:04:02.480 --> 00:04:04.340
means that latency
requirements are simply

00:04:04.340 --> 00:04:07.970
too stringent to allow
buffering of any kind.

00:04:07.970 --> 00:04:11.130
We also cannot afford any
computationally intensive bit

00:04:11.130 --> 00:04:14.300
stream compression to
accomplish quality.

00:04:14.300 --> 00:04:17.790
The open world nature of games
also makes caching of content

00:04:17.790 --> 00:04:21.800
they provide simply not
possible or very difficult.

00:04:21.800 --> 00:04:25.040
And network impairments
can be highly visible

00:04:25.040 --> 00:04:27.220
and must be avoided
at all costs.

00:04:27.220 --> 00:04:31.130
A cloud gaming platform must
maintain an optimal experience

00:04:31.130 --> 00:04:34.380
under all possible conditions.

00:04:34.380 --> 00:04:36.930
So what does your typical cloud
gaming platform look like?

00:04:36.930 --> 00:04:39.920
Well, it possibly looks
like something like this.

00:04:39.920 --> 00:04:42.410
Games are hosted in
remote data centers.

00:04:42.410 --> 00:04:44.060
Players typically
have 10 clients

00:04:44.060 --> 00:04:47.330
that, by themselves, are not
capable of hosting such games

00:04:47.330 --> 00:04:49.970
or providing the unique
experiences enabled by a cloud

00:04:49.970 --> 00:04:51.520
gaming platform.

00:04:51.520 --> 00:04:56.030
A game's raw audio and video
are taken and coded packetized

00:04:56.030 --> 00:04:59.150
and streamed over the internet
all under the watchful eyes

00:04:59.150 --> 00:05:01.900
of a real time data
repetition engine.

00:05:01.900 --> 00:05:04.380
This process reverses
on the client side.

00:05:04.380 --> 00:05:06.310
You depacketize,
decode, and send it

00:05:06.310 --> 00:05:08.410
to the display or
the controller.

00:05:08.410 --> 00:05:10.960
In a similar manner, a
player's input and voice

00:05:10.960 --> 00:05:13.390
are taken and sent
to the remote game.

00:05:13.390 --> 00:05:17.010
Of course, all of this is
happening in real time.

00:05:17.010 --> 00:05:18.990
So why is all this so difficult?

00:05:18.990 --> 00:05:21.740
Well, key to be
successful at cloud gaming

00:05:21.740 --> 00:05:23.900
is to be able to deliver
a consistent player

00:05:23.900 --> 00:05:25.980
experience at scale.

00:05:25.980 --> 00:05:29.905
This means scaling across the
entire spectrum of endpoints,

00:05:29.905 --> 00:05:32.030
being able to deal with
their hardware and software

00:05:32.030 --> 00:05:34.460
fragmentation and
non-uniformity.

00:05:34.460 --> 00:05:36.380
Scaling across all
locations that players

00:05:36.380 --> 00:05:40.260
access the service, and scaling
across all network types,

00:05:40.260 --> 00:05:42.910
whether they are wired,
wireless, lossy, or have

00:05:42.910 --> 00:05:44.195
variable or high latency.

00:05:46.348 --> 00:05:48.390
So what's the first thing
that comes to your mind

00:05:48.390 --> 00:05:50.960
when you think
about cloud gaming?

00:05:50.960 --> 00:05:52.430
What about latency?

00:05:52.430 --> 00:05:54.290
Well, let's talk about latency.

00:05:54.290 --> 00:05:56.990
We have spent a lot of time
doing extensive research

00:05:56.990 --> 00:05:59.060
on the effects of latency.

00:05:59.060 --> 00:06:00.650
Here are some examples.

00:06:00.650 --> 00:06:02.960
Typical HDMI
transfers to your TV

00:06:02.960 --> 00:06:06.440
take anywhere between
16 to 33 milliseconds.

00:06:06.440 --> 00:06:08.630
Typical monitor refresh
rates are on the order

00:06:08.630 --> 00:06:10.930
of 4 to 16 milliseconds.

00:06:10.930 --> 00:06:14.810
USB ports for peripherals
range from the order

00:06:14.810 --> 00:06:16.650
of 8 milliseconds.

00:06:16.650 --> 00:06:19.520
Even in the USB pooling
case, gaming peripherals

00:06:19.520 --> 00:06:21.560
provide specialized
hardware and software

00:06:21.560 --> 00:06:27.100
that try to mitigate this
latency, but it is not zero.

00:06:27.100 --> 00:06:30.450
So did you walk into a
talk on neurosciences?

00:06:30.450 --> 00:06:31.060
Nope.

00:06:31.060 --> 00:06:33.280
This is all about
cloud gaming still.

00:06:33.280 --> 00:06:36.310
But here are some interesting
findings from a neuroscience's

00:06:36.310 --> 00:06:40.780
publication by SJ Tarp in 2001,
characterizing the effects

00:06:40.780 --> 00:06:43.630
of a brain and nervous system.

00:06:43.630 --> 00:06:46.180
It takes at least 13
milliseconds for you

00:06:46.180 --> 00:06:48.100
to process visual stimuli.

00:06:48.100 --> 00:06:51.550
It takes anywhere between
70 to 180 milliseconds

00:06:51.550 --> 00:06:53.770
for your brain's command
to reach your fingers.

00:06:53.770 --> 00:06:56.880
Yes, even you have latency.

00:06:56.880 --> 00:06:58.920
And here is another
example, all of you

00:06:58.920 --> 00:07:01.590
have seen lightning
and heard thunder.

00:07:01.590 --> 00:07:04.480
But you know that light
travels fast, really fast,

00:07:04.480 --> 00:07:06.780
186,000 miles per second.

00:07:06.780 --> 00:07:09.570
But did you know that we
use that to our advantage?

00:07:09.570 --> 00:07:12.480
It takes less time for a
packet from a map data center

00:07:12.480 --> 00:07:15.210
to reach you than it takes
for your brain's command

00:07:15.210 --> 00:07:16.770
to reach your fingers.

00:07:16.770 --> 00:07:19.590
Mitigating the effects
of latency is key.

00:07:19.590 --> 00:07:23.670
Our goal is to make it
imperceptible to players.

00:07:23.670 --> 00:07:25.980
Visual fidelity is
another challenge.

00:07:25.980 --> 00:07:27.810
Fundamentally,
it's because we are

00:07:27.810 --> 00:07:30.150
trying to maintain a fine
balance between quality

00:07:30.150 --> 00:07:32.790
and responsiveness,
but in real time.

00:07:32.790 --> 00:07:34.410
To understand cloud
gaming, you need

00:07:34.410 --> 00:07:36.780
to understand the impact
of codecs and encoders

00:07:36.780 --> 00:07:39.390
and decoders and
select them wisely.

00:07:39.390 --> 00:07:42.150
Codecs typically need
a significant amount

00:07:42.150 --> 00:07:44.310
of implementation
specific optimizations

00:07:44.310 --> 00:07:47.950
to maintain both real time
quality and responsiveness.

00:07:47.950 --> 00:07:50.940
Encoders convert media
based on the selected

00:07:50.940 --> 00:07:53.520
codec and the encode strategy.

00:07:53.520 --> 00:07:55.860
But they are inherently
laggy and they

00:07:55.860 --> 00:07:58.260
overshoot or
undershoot by design

00:07:58.260 --> 00:08:00.060
to maintain optimal quality.

00:08:00.060 --> 00:08:02.850
And finally, decoders
take this converted media

00:08:02.850 --> 00:08:05.100
and convert them back
into a format consumable

00:08:05.100 --> 00:08:07.080
by playback devices.

00:08:07.080 --> 00:08:09.240
But this is challenging
on many fronts.

00:08:09.240 --> 00:08:11.790
Decoder landscape is
fragmented and non-uniform.

00:08:11.790 --> 00:08:16.050
Chipsets driver compatibility
and capability and performance.

00:08:16.050 --> 00:08:20.310
Consistently dealing with
this is key for scaling.

00:08:20.310 --> 00:08:21.990
So here is a practical
example of how

00:08:21.990 --> 00:08:23.340
this plays out in real life.

00:08:23.340 --> 00:08:26.310
As you can see, the demands
for a menu navigation where

00:08:26.310 --> 00:08:28.620
the game is running at a
much higher frame rate,

00:08:28.620 --> 00:08:30.390
but not as visually
rich, is very

00:08:30.390 --> 00:08:34.289
different from a visually rich
cinematic scene that is usually

00:08:34.289 --> 00:08:35.789
running at a low frame rate.

00:08:35.789 --> 00:08:39.030
Imagine you are flipping between
your menu and this in a game

00:08:39.030 --> 00:08:40.500
and imagine the
encoder of it needs

00:08:40.500 --> 00:08:42.960
to maintain consistent
quality but able

00:08:42.960 --> 00:08:46.310
to deal with this in real time.

00:08:46.310 --> 00:08:48.310
And of course, networking
is a challenge, right?

00:08:48.310 --> 00:08:50.080
You need to deal with
network impairments.

00:08:50.080 --> 00:08:51.910
You need to deal with
competing traffic.

00:08:51.910 --> 00:08:55.610
You need to deal with real time
and mitigate this in real time.

00:08:55.610 --> 00:08:58.510
For example, if your family
starts watching YouTube,

00:08:58.510 --> 00:09:01.770
you need to be able to get
your fair share of bandwidth.

00:09:01.770 --> 00:09:05.320
And unlike dash players, we
cannot take advantage of client

00:09:05.320 --> 00:09:06.760
sized buffers.

00:09:06.760 --> 00:09:09.880
And so lost concealment and
mitigation is very tough

00:09:09.880 --> 00:09:12.260
and you need to head this off.

00:09:12.260 --> 00:09:15.180
And if this was not
enough, gameplay ability

00:09:15.180 --> 00:09:17.070
adds a whole new
dimension of complexity

00:09:17.070 --> 00:09:20.650
to this affected by
the game, the player,

00:09:20.650 --> 00:09:22.950
and of course, the
underlying network.

00:09:22.950 --> 00:09:25.830
As can be seen by a paper
published by S Vang and S Day

00:09:25.830 --> 00:09:30.120
in 2009 on cloud
gaming playability,

00:09:30.120 --> 00:09:33.300
the factors affecting it are
both subjective and objective.

00:09:33.300 --> 00:09:37.380
Frame rate, resolution,
bandwidth, delay, quality,

00:09:37.380 --> 00:09:40.115
smoothness, all play into it.

00:09:40.115 --> 00:09:41.490
So now I am going
to hand it over

00:09:41.490 --> 00:09:43.020
to Khaled, who is
going to walk you

00:09:43.020 --> 00:09:44.770
through the next
phase of our journey.

00:09:44.770 --> 00:09:47.130
The foundational research
that forms the basis

00:09:47.130 --> 00:09:48.450
of our cloud gaming platform.

00:09:51.933 --> 00:09:54.600
KHALED ABDEL RAHMAN: So with all
the different factors affecting

00:09:54.600 --> 00:09:58.410
playability, we really wanted to
understand gameplay experiences

00:09:58.410 --> 00:10:00.450
from a data driven perspective.

00:10:00.450 --> 00:10:02.070
And while we did
understand a lot

00:10:02.070 --> 00:10:04.710
about what makes for a good
game or a good experience

00:10:04.710 --> 00:10:07.050
in general, we really
wanted to dig deeper

00:10:07.050 --> 00:10:09.680
into the science of it all.

00:10:09.680 --> 00:10:11.260
We decided to
start running tests

00:10:11.260 --> 00:10:13.330
across a wide
variety of conditions

00:10:13.330 --> 00:10:15.160
for each of the
factors identified

00:10:15.160 --> 00:10:17.080
as affecting playability.

00:10:17.080 --> 00:10:20.500
We analyzed industry accepted
techniques based on MOS,

00:10:20.500 --> 00:10:22.690
or mean opinion
score, as guidance

00:10:22.690 --> 00:10:24.920
for evaluation in these tests.

00:10:24.920 --> 00:10:26.710
And we use it as our
subjective measure

00:10:26.710 --> 00:10:28.760
of quality of experience.

00:10:28.760 --> 00:10:32.110
In most of our studies players
had either a short form

00:10:32.110 --> 00:10:34.030
or long form play
session, followed

00:10:34.030 --> 00:10:37.240
by a quick survey where they
rated the experience on a one

00:10:37.240 --> 00:10:38.350
to five scale.

00:10:38.350 --> 00:10:40.570
And they were also able to
give us free form feedback

00:10:40.570 --> 00:10:41.680
when needed.

00:10:41.680 --> 00:10:43.870
And for each game
we tested, we also

00:10:43.870 --> 00:10:46.300
did a baseline study
in which we identified

00:10:46.300 --> 00:10:50.080
thresholds at which the game
itself is considered good.

00:10:50.080 --> 00:10:53.230
The baseline studies always
ran with the highest possible

00:10:53.230 --> 00:10:56.380
graphics settings at the
highest possible frame rate.

00:10:56.380 --> 00:10:58.750
And in its most
basic form, our goal

00:10:58.750 --> 00:11:00.920
was to deliver a
better experience

00:11:00.920 --> 00:11:04.180
but do so in a browser even
when the local machine we're

00:11:04.180 --> 00:11:08.790
comparing to is a
$6,000 max backed PC.

00:11:08.790 --> 00:11:11.430
So we isolated our research
into the factors that

00:11:11.430 --> 00:11:13.350
are relevant to our platform.

00:11:13.350 --> 00:11:16.410
Items like different available
bandwidth, different codecs,

00:11:16.410 --> 00:11:18.660
and games running at
different frame rates.

00:11:18.660 --> 00:11:20.430
And while each of
these factors have

00:11:20.430 --> 00:11:23.670
had different weighted impact
on the overall experience,

00:11:23.670 --> 00:11:26.100
together they had a
significantly higher

00:11:26.100 --> 00:11:27.730
correlation.

00:11:27.730 --> 00:11:29.430
So the research
needed to experiment

00:11:29.430 --> 00:11:31.810
with each of these
factors individually,

00:11:31.810 --> 00:11:33.690
as well as in conditions
where they were

00:11:33.690 --> 00:11:36.450
interacting with each other.

00:11:36.450 --> 00:11:38.220
And we did a lot of research.

00:11:38.220 --> 00:11:39.960
We built custom
tooling that allowed

00:11:39.960 --> 00:11:43.170
us to simulate a variety
of network conditions, test

00:11:43.170 --> 00:11:46.020
different prototypes, different
rate adaptation techniques,

00:11:46.020 --> 00:11:47.960
codecs, and infrastructures.

00:11:47.960 --> 00:11:50.550
And our approach to
testing was two pronged.

00:11:50.550 --> 00:11:52.500
The first is in
controlled environments

00:11:52.500 --> 00:11:54.120
with applied variables.

00:11:54.120 --> 00:11:56.280
This happened in one
of our many labs.

00:11:56.280 --> 00:11:59.100
It involves hands
on guided testing.

00:11:59.100 --> 00:12:01.260
And we worked with
over 1,500 players

00:12:01.260 --> 00:12:04.170
to test tens of thousands
of structured gameplay

00:12:04.170 --> 00:12:07.520
prior to Project
Stream's launch.

00:12:07.520 --> 00:12:11.030
For the second approach we
looked at wider scale testing.

00:12:11.030 --> 00:12:13.160
And we utilized the
wide gaming community

00:12:13.160 --> 00:12:15.080
that we have working at Google.

00:12:15.080 --> 00:12:17.360
And we asked them to
just play on the platform

00:12:17.360 --> 00:12:20.510
and use it just like they
would with anything else.

00:12:20.510 --> 00:12:23.510
This allowed us to gather
proper feedback about the end

00:12:23.510 --> 00:12:27.260
to end experience from a
variety of endpoints, network

00:12:27.260 --> 00:12:29.360
conditions, and locations.

00:12:29.360 --> 00:12:31.340
And for Assassin's
Creed alone, we

00:12:31.340 --> 00:12:35.570
were able to do A/B tests on
some 24,000 hours of gameplay

00:12:35.570 --> 00:12:37.100
prior to launch.

00:12:37.100 --> 00:12:39.550
This was by far one of
the biggest resources

00:12:39.550 --> 00:12:41.750
that we had at our disposal.

00:12:41.750 --> 00:12:44.720
And we can't thank the Googlers
that participated enough

00:12:44.720 --> 00:12:46.990
for their help and feedback.

00:12:46.990 --> 00:12:49.640
So delving deeper
into what we tested.

00:12:49.640 --> 00:12:51.800
Latency is the
first word we hear

00:12:51.800 --> 00:12:54.440
when we say we're working
on game streaming.

00:12:54.440 --> 00:12:58.490
And the case you're wondering,
yes, we did a lot of research

00:12:58.490 --> 00:12:59.900
about latency.

00:12:59.900 --> 00:13:03.260
And as a matter of fact, we
have constant weekly research

00:13:03.260 --> 00:13:06.950
sessions about every single
aspect of latency, in addition

00:13:06.950 --> 00:13:08.780
to our wider scale testing.

00:13:08.780 --> 00:13:13.340
And of course, you will never,
ever, ever experienced anything

00:13:13.340 --> 00:13:16.560
like this on our platform.

00:13:16.560 --> 00:13:18.260
So to understand
latency, we first

00:13:18.260 --> 00:13:21.650
need to understand its impact
within different games, genres,

00:13:21.650 --> 00:13:23.390
and mechanics.

00:13:23.390 --> 00:13:25.910
It's important to note
different mechanics have

00:13:25.910 --> 00:13:29.510
different latency requirements
even within the same game.

00:13:29.510 --> 00:13:32.900
And even the same mechanic
across two different titles

00:13:32.900 --> 00:13:36.820
can have wildly different
behaviors and requirements.

00:13:36.820 --> 00:13:39.010
On the other hand,
latency perception

00:13:39.010 --> 00:13:41.980
is also closely tied to the
player's level of experience

00:13:41.980 --> 00:13:43.690
with a particular title.

00:13:43.690 --> 00:13:46.720
A casual player can
fully enjoy a sports game

00:13:46.720 --> 00:13:48.700
without significant
latency perception

00:13:48.700 --> 00:13:52.700
even when we dialed those
numbers up to absurd levels.

00:13:52.700 --> 00:13:55.030
On the other hand, a
more experienced player

00:13:55.030 --> 00:13:58.420
might be looking to do some
skill shots, special passes,

00:13:58.420 --> 00:14:01.900
and things that are not feasible
at high or inconsistent latency

00:14:01.900 --> 00:14:03.610
levels.

00:14:03.610 --> 00:14:06.790
So we tested multiple games,
genres, and mechanics.

00:14:06.790 --> 00:14:08.830
And we did so across
a wide audience

00:14:08.830 --> 00:14:11.440
of casual and
experienced players.

00:14:11.440 --> 00:14:13.510
We started mimicking
network impairments

00:14:13.510 --> 00:14:16.390
that affect gameplay and
asking players to rate

00:14:16.390 --> 00:14:20.160
the experience without
telling them what was active.

00:14:20.160 --> 00:14:21.990
And our targets
naturally started

00:14:21.990 --> 00:14:24.780
aligning with the mechanics
that had the highest temporal

00:14:24.780 --> 00:14:27.360
and spatial precision
required by the most

00:14:27.360 --> 00:14:29.460
skilled of foot players.

00:14:29.460 --> 00:14:31.500
And over the course
of the research,

00:14:31.500 --> 00:14:33.600
we not only
understood the details

00:14:33.600 --> 00:14:35.790
of how latency
impacted gameplay,

00:14:35.790 --> 00:14:38.910
but we also defined our
own window of operation.

00:14:38.910 --> 00:14:41.160
The exact values
we need to target

00:14:41.160 --> 00:14:43.920
where we can receive an
input, run a game loop,

00:14:43.920 --> 00:14:46.200
deliver a frame to end endpoint.

00:14:46.200 --> 00:14:49.380
And then the green shaded
zone that you see here

00:14:49.380 --> 00:14:53.070
from tests like these, informed
our decision on rate adaptation

00:14:53.070 --> 00:14:57.310
and encoding behaviors, which
Rob will talk about later.

00:14:57.310 --> 00:15:00.390
Another example pillar we
delved into is video quality.

00:15:00.390 --> 00:15:02.880
And while it doesn't come
up as much as latency

00:15:02.880 --> 00:15:04.590
when we talk about
game streaming,

00:15:04.590 --> 00:15:07.080
you can see that it
correlates directly

00:15:07.080 --> 00:15:10.170
with an overall quality
of a gameplay session.

00:15:10.170 --> 00:15:12.450
Within the general
area of video itself,

00:15:12.450 --> 00:15:15.660
there are also multiple
factors that impact quality.

00:15:15.660 --> 00:15:18.750
Using different codecs has a
media and well-known impact

00:15:18.750 --> 00:15:21.900
and quality, we
ultimately decided on VP 9

00:15:21.900 --> 00:15:24.810
as our primary codec, providing
scalability, as well as

00:15:24.810 --> 00:15:27.180
high quality 4K performance.

00:15:27.180 --> 00:15:30.690
And then bitrate itself is
another one of those factors.

00:15:30.690 --> 00:15:33.870
In general, higher bitrate
mean higher visual fidelity

00:15:33.870 --> 00:15:35.430
on most codecs.

00:15:35.430 --> 00:15:39.030
But in reality, any
research into bitrate

00:15:39.030 --> 00:15:42.690
must also take into account
screen size, the resolution,

00:15:42.690 --> 00:15:45.570
frame rate, and every
other encoder variable.

00:15:45.570 --> 00:15:50.190
And while we do look at generic
metrics like PSNR and SSIM,

00:15:50.190 --> 00:15:53.730
we were really more interested
in the player specific impact.

00:15:53.730 --> 00:15:56.310
And we started wondering what
would that impact be when

00:15:56.310 --> 00:15:58.250
we're tweaking those variables?

00:15:58.250 --> 00:16:01.180
And a lot of times these
results were expected.

00:16:01.180 --> 00:16:03.240
But other times they
were surprising.

00:16:03.240 --> 00:16:06.780
Like how 30 FBS sometimes
performed better

00:16:06.780 --> 00:16:08.520
at lower bitrates.

00:16:08.520 --> 00:16:12.690
While that didn't end up meaning
that we'd drop the 30 FBS when

00:16:12.690 --> 00:16:15.060
the bitrate available
is lower, it

00:16:15.060 --> 00:16:17.640
did push us to
explore that solution

00:16:17.640 --> 00:16:19.560
and eventually come up
with different things

00:16:19.560 --> 00:16:21.600
like dynamic resolution
switching that

00:16:21.600 --> 00:16:24.300
would ensure a smooth
60 FBS gameplay,

00:16:24.300 --> 00:16:27.420
as well as sustained
high fidelity.

00:16:27.420 --> 00:16:30.230
So you noticed there that
a result on video quality

00:16:30.230 --> 00:16:33.710
did not immediately imply that
the overall gameplay is better,

00:16:33.710 --> 00:16:37.140
nor that the overall quality of
a gameplay session is better.

00:16:37.140 --> 00:16:39.590
So the example from
before, video quality

00:16:39.590 --> 00:16:42.350
mattered a lot in the
overall experience, but so

00:16:42.350 --> 00:16:46.080
did a high frame rate, smooth
gameplay, and low latency.

00:16:46.080 --> 00:16:48.050
If video quality
was the only factor

00:16:48.050 --> 00:16:50.840
that we're looking into
then 24 FBS might prove

00:16:50.840 --> 00:16:54.020
to be more cinematic and
taking seconds to buffer

00:16:54.020 --> 00:16:56.450
would not be an issue at all.

00:16:56.450 --> 00:16:58.160
The biggest takeaway
from our research

00:16:58.160 --> 00:17:01.580
was window targets for each
of our playability factors.

00:17:01.580 --> 00:17:03.710
As you saw, some
of these variables

00:17:03.710 --> 00:17:06.050
are directly proportional,
while others,

00:17:06.050 --> 00:17:09.440
like video quality and latency,
are inversely proportional.

00:17:09.440 --> 00:17:11.869
And, collectively,
all of these factors

00:17:11.869 --> 00:17:13.550
together contribute
to the quality

00:17:13.550 --> 00:17:15.440
of a gameplay experience.

00:17:15.440 --> 00:17:17.839
The challenge is to
deliver an experience

00:17:17.839 --> 00:17:21.470
in which each factor stays
within their defined window.

00:17:21.470 --> 00:17:24.770
A delicate balance that
allows you to deliver a data

00:17:24.770 --> 00:17:27.940
validated excellent gaming
experience to a player.

00:17:27.940 --> 00:17:29.690
Rob will be telling
you about the streamer

00:17:29.690 --> 00:17:31.100
and how we achieve that balance.

00:17:37.808 --> 00:17:38.850
ROB MCCOOL: Hi everybody.

00:17:38.850 --> 00:17:40.130
Let's talk about the streamer.

00:17:40.130 --> 00:17:41.880
But, before we begin,
I'd like to clear up

00:17:41.880 --> 00:17:42.950
some misconceptions.

00:17:42.950 --> 00:17:44.990
There've been some
rumors floating around.

00:17:44.990 --> 00:17:47.600
First thing is we don't
utilize quantum entanglement

00:17:47.600 --> 00:17:49.280
in the implantation
of this system.

00:17:49.280 --> 00:17:53.480
There is no spooky action
at a distance in Stadia yet.

00:17:53.480 --> 00:17:56.980
So that means that our
latencies are strictly non-zero.

00:17:56.980 --> 00:17:58.850
Second, we have
not yet found a way

00:17:58.850 --> 00:18:01.580
to channel tachions through
either copper or fiber

00:18:01.580 --> 00:18:02.300
conduits.

00:18:02.300 --> 00:18:05.520
Tachions are, of course for
you sci-fi geeks, particles

00:18:05.520 --> 00:18:07.020
that move backwards in time.

00:18:07.020 --> 00:18:12.940
So our latencies is are
still strictly non-negative.

00:18:12.940 --> 00:18:14.690
Finally, we support
many different network

00:18:14.690 --> 00:18:18.590
types, many open standards,
but we do not support RFC 1149.

00:18:18.590 --> 00:18:19.587
Who's got 1149?

00:18:19.587 --> 00:18:21.170
You got your phones
out, I can see it.

00:18:21.170 --> 00:18:22.670
Come on, somebody.

00:18:22.670 --> 00:18:26.240
IP over avian carriers,
pigeons, geese, stuff like that.

00:18:26.240 --> 00:18:28.630
We tried it, huge mess.

00:18:28.630 --> 00:18:31.130
The facilities department still
won't return my phone calls.

00:18:31.130 --> 00:18:32.450
It was an April Fool's
joke, look it up.

00:18:32.450 --> 00:18:33.250
It's fun.

00:18:33.250 --> 00:18:35.780
Anyway, the streamer
is a delivery engine

00:18:35.780 --> 00:18:37.670
that's purpose built
for game streaming.

00:18:37.670 --> 00:18:39.530
It's a program that
runs alongside the game

00:18:39.530 --> 00:18:41.160
and takes information
from the client,

00:18:41.160 --> 00:18:43.570
as well as from Google's
content delivery network.

00:18:43.570 --> 00:18:45.320
And it makes real time
decisions about how

00:18:45.320 --> 00:18:48.758
to maximize quality while
keeping latency imperceptible.

00:18:48.758 --> 00:18:51.050
It's built on open standards,
such as web arts you see,

00:18:51.050 --> 00:18:53.570
and supports many platforms,
including browsers, living room

00:18:53.570 --> 00:18:55.310
devices, and mobile phones.

00:18:55.310 --> 00:18:57.560
Today I'm going to talk about
rate adaptation for game

00:18:57.560 --> 00:18:58.430
streaming.

00:18:58.430 --> 00:18:59.990
We continually
monitor and estimate

00:18:59.990 --> 00:19:02.660
current network conditions,
such as bandwidth, packet loss,

00:19:02.660 --> 00:19:03.500
and delay.

00:19:03.500 --> 00:19:05.690
And we adapt the games
transmitter and media stream

00:19:05.690 --> 00:19:08.170
accordingly in real time.

00:19:08.170 --> 00:19:10.680
So cloud game streaming
is a complex system

00:19:10.680 --> 00:19:12.660
and has many actors
and many variables that

00:19:12.660 --> 00:19:14.035
are not directly observable.

00:19:14.035 --> 00:19:16.410
How many people have played
a real time strategy game out

00:19:16.410 --> 00:19:16.650
here?

00:19:16.650 --> 00:19:17.160
Warcraft?

00:19:17.160 --> 00:19:17.730
StarCraft?

00:19:17.730 --> 00:19:18.060
Somebody.

00:19:18.060 --> 00:19:18.810
Yeah, there we go.

00:19:18.810 --> 00:19:19.360
We got some.

00:19:19.360 --> 00:19:21.360
All right, so if you've
played a game like that,

00:19:21.360 --> 00:19:22.920
there's a mechanic
called fog of war

00:19:22.920 --> 00:19:24.545
where you can't see
something until you

00:19:24.545 --> 00:19:26.250
send a unit to go observe it.

00:19:26.250 --> 00:19:28.020
Cloud gaming is actually
a lot like that.

00:19:28.020 --> 00:19:31.200
There's a bunch of information,
but you haven't seen it

00:19:31.200 --> 00:19:32.220
until you go observe it.

00:19:32.220 --> 00:19:34.860
And you don't know if it's
changed since the last time you

00:19:34.860 --> 00:19:35.530
looked at it.

00:19:35.530 --> 00:19:37.473
And just like a real
time strategy game,

00:19:37.473 --> 00:19:39.140
you have to make
decisions all the time.

00:19:39.140 --> 00:19:40.350
What are you going to focus on?

00:19:40.350 --> 00:19:41.790
Are you going to
focus on economy?

00:19:41.790 --> 00:19:43.540
Are you going to
focus on units of war?

00:19:43.540 --> 00:19:45.540
And gaming, are you're
going to focus on quality

00:19:45.540 --> 00:19:46.860
or are you going to
focus on latency?

00:19:46.860 --> 00:19:48.720
Because if you don't
have enough bandwidth

00:19:48.720 --> 00:19:51.460
and you focus on quality,
you can fall behind.

00:19:51.460 --> 00:19:53.700
So there isn't a
single right answer.

00:19:53.700 --> 00:19:56.610
There is no single optimization
to make the perfect cloud

00:19:56.610 --> 00:19:58.440
gaming streaming technology.

00:19:58.440 --> 00:20:01.080
It's always balancing
a series of trade offs.

00:20:01.080 --> 00:20:03.480
So if you improve one
thing, oftentimes it

00:20:03.480 --> 00:20:05.530
comes at the expense
of another thing.

00:20:05.530 --> 00:20:07.810
So the solution is not
an elegant algorithm

00:20:07.810 --> 00:20:10.200
that you can describe with a
few lines of Greek symbols,

00:20:10.200 --> 00:20:11.880
maybe get a master's
thesis out of it.

00:20:11.880 --> 00:20:13.600
It looks very different.

00:20:13.600 --> 00:20:16.140
So the right algorithm is
an important foundation.

00:20:16.140 --> 00:20:19.020
So speaking a real time
strategy games, how many people

00:20:19.020 --> 00:20:21.300
in here have ever implemented
path finding in a game?

00:20:21.300 --> 00:20:22.080
There's got to be somebody.

00:20:22.080 --> 00:20:22.610
There we go.

00:20:22.610 --> 00:20:23.520
We got some.

00:20:23.520 --> 00:20:26.160
All right, so when you
implement path finding,

00:20:26.160 --> 00:20:28.590
you have to start with the
foundation of a good algorithm.

00:20:28.590 --> 00:20:31.450
A star tends to be one of
the ones that people use.

00:20:31.450 --> 00:20:32.830
So, once you
implement it though,

00:20:32.830 --> 00:20:34.580
you'll find there's a
bunch of edge cases.

00:20:34.580 --> 00:20:36.270
You've got units
walking into walls.

00:20:36.270 --> 00:20:38.430
You've got different
things happening.

00:20:38.430 --> 00:20:40.900
The algorithm needs
a little bit of help.

00:20:40.900 --> 00:20:43.980
So you put A star together,
you add some other algorithms,

00:20:43.980 --> 00:20:45.840
you throw in some
heuristics and then

00:20:45.840 --> 00:20:48.310
you have a working product.

00:20:48.310 --> 00:20:50.580
So let's talk about why
Google is uniquely positioned

00:20:50.580 --> 00:20:52.560
to solve these sorts
of complex, messy,

00:20:52.560 --> 00:20:55.260
and honestly, sometimes
very ugly problems.

00:20:55.260 --> 00:20:58.247
Search shaped Google's
culture very substantially.

00:20:58.247 --> 00:21:00.330
Many of the approaches
that search uses, including

00:21:00.330 --> 00:21:04.110
blending many algorithms, using
heuristics, the use of humans

00:21:04.110 --> 00:21:07.440
as well as automated metrics
to evaluate quality, modeling

00:21:07.440 --> 00:21:10.680
complex, real world
situations with machine usable

00:21:10.680 --> 00:21:13.557
simplifications, predictive
systems, and reinforcement

00:21:13.557 --> 00:21:16.140
learning are all things that are
vital to creating a streaming

00:21:16.140 --> 00:21:17.190
platform.

00:21:17.190 --> 00:21:19.110
Search follows the
same algorithm pattern

00:21:19.110 --> 00:21:20.460
I've described elsewhere.

00:21:20.460 --> 00:21:22.530
So do we have any page
rank fans out here?

00:21:22.530 --> 00:21:24.490
Come on, Google I/O,
give it up for page rank.

00:21:24.490 --> 00:21:24.990
Let's go.

00:21:24.990 --> 00:21:26.440
I got a couple, all right.

00:21:26.440 --> 00:21:29.110
So page rank is
actually very simple.

00:21:29.110 --> 00:21:31.830
It's a very powerful, very
easy to define algorithm.

00:21:31.830 --> 00:21:33.370
And it's an
important foundation.

00:21:33.370 --> 00:21:35.260
It's been that way
for a long time.

00:21:35.260 --> 00:21:39.163
But it's not enough to
use page rank by itself.

00:21:39.163 --> 00:21:40.830
You have to combine
it with other things

00:21:40.830 --> 00:21:43.300
to make it work
across all situations.

00:21:43.300 --> 00:21:44.940
So balance is important as well.

00:21:44.940 --> 00:21:47.220
In search you can
tune for precision,

00:21:47.220 --> 00:21:49.540
in which case, you'll
filter out relevant results

00:21:49.540 --> 00:21:51.582
but you'll be sure that
everything you're showing

00:21:51.582 --> 00:21:52.200
is correct.

00:21:52.200 --> 00:21:54.120
Or you can focus
on recall, where

00:21:54.120 --> 00:21:56.160
you show them a lot of
results, but some of them

00:21:56.160 --> 00:21:57.370
might be wrong.

00:21:57.370 --> 00:21:59.700
So, just like path
finding or cloud gaming,

00:21:59.700 --> 00:22:00.660
you have to balance.

00:22:00.660 --> 00:22:03.003
You have to go into the
middle and find what

00:22:03.003 --> 00:22:04.170
you want your product to be.

00:22:04.170 --> 00:22:05.400
Search is the same way.

00:22:05.400 --> 00:22:07.570
Google has a lot of
experience with this.

00:22:07.570 --> 00:22:10.580
And that's part of
cloud gaming too.

00:22:10.580 --> 00:22:12.760
So how do we create a
cloud gaming engine?

00:22:12.760 --> 00:22:15.370
So first we have to choose
an algorithm as a foundation.

00:22:15.370 --> 00:22:17.560
And in a few minutes
I'll tell you about that.

00:22:17.560 --> 00:22:18.750
Next, we have to balance.

00:22:18.750 --> 00:22:20.370
So one of the important
balancing acts

00:22:20.370 --> 00:22:22.090
is latency versus quality.

00:22:22.090 --> 00:22:24.340
What Guru likes to say is
that if all you care about

00:22:24.340 --> 00:22:26.020
is quality, you can do that.

00:22:26.020 --> 00:22:28.090
Just stream one
frame per second.

00:22:28.090 --> 00:22:31.120
Your latency will be horrific,
but it's going to look good.

00:22:31.120 --> 00:22:33.400
If all you care about
is latency, just stream

00:22:33.400 --> 00:22:35.410
at 2 megabits all the time.

00:22:35.410 --> 00:22:36.890
Quality is going
to be horrendous,

00:22:36.890 --> 00:22:38.920
but man, it'll be
real responsive.

00:22:38.920 --> 00:22:41.210
So we have to find
some middle ground,

00:22:41.210 --> 00:22:42.520
and that's the balancing act.

00:22:42.520 --> 00:22:44.755
We have to use incomplete
and noisy signals

00:22:44.755 --> 00:22:46.900
to determine what's
happening and then make

00:22:46.900 --> 00:22:49.460
a choice for what to do
based on that information.

00:22:49.460 --> 00:22:51.070
But you don't always
have to take away

00:22:51.070 --> 00:22:53.560
from one thing you want
to increase another thing.

00:22:53.560 --> 00:22:55.690
Technology improvements
are a rising tide

00:22:55.690 --> 00:22:57.010
that lift all boats.

00:22:57.010 --> 00:22:59.170
If you consider the
improvements like a new video

00:22:59.170 --> 00:23:01.960
codec, such as AV1,
then with this codec

00:23:01.960 --> 00:23:04.600
you can achieve better
quality for the same bitrates

00:23:04.600 --> 00:23:08.650
and that improves the
experience across the board.

00:23:08.650 --> 00:23:11.580
So here's a basic overview
of how video encoders work

00:23:11.580 --> 00:23:14.040
and what different types
of video frames there are.

00:23:14.040 --> 00:23:16.080
In order to use the
lowest number of bits,

00:23:16.080 --> 00:23:18.090
a video encoder will
first send a frame

00:23:18.090 --> 00:23:19.780
that has everything in it.

00:23:19.780 --> 00:23:22.530
And then after that, it will
send only what's changed.

00:23:22.530 --> 00:23:24.317
These full friends
are called I-frames,

00:23:24.317 --> 00:23:26.650
and they're like the jpg
images that your digital camera

00:23:26.650 --> 00:23:28.200
or your phone can produce.

00:23:28.200 --> 00:23:30.180
They're very large,
so after that encoders

00:23:30.180 --> 00:23:32.220
produce frames that
contain only differences

00:23:32.220 --> 00:23:33.755
from the frames before them.

00:23:33.755 --> 00:23:35.130
Those are called
P-frames and you

00:23:35.130 --> 00:23:37.770
can continue to display the
video as long as you don't

00:23:37.770 --> 00:23:39.570
lose any of those P-frames.

00:23:39.570 --> 00:23:41.400
If you lose one, you
have to set an I-frame

00:23:41.400 --> 00:23:43.098
to start decoding again.

00:23:43.098 --> 00:23:44.640
There is another
type of frame called

00:23:44.640 --> 00:23:46.860
a B-frame, which
can't be decoded

00:23:46.860 --> 00:23:49.170
until some frame in
the future arrives.

00:23:49.170 --> 00:23:50.940
And using those would
increase our latency

00:23:50.940 --> 00:23:53.970
to perceptible levels and
so we can't use those.

00:23:53.970 --> 00:23:56.800
So encoders actually have
a really hard job to do.

00:23:56.800 --> 00:24:00.120
So as an example, imagine
you're in the menu in the game

00:24:00.120 --> 00:24:02.683
and then you choose the
action to start the game.

00:24:02.683 --> 00:24:05.100
And then you press a button
and the whole screen explodes.

00:24:05.100 --> 00:24:08.280
And there's glass shards and
there's fire and explosions,

00:24:08.280 --> 00:24:11.660
and maybe there's, like, an
epic guitar chord going bram--

00:24:11.660 --> 00:24:13.800
OK, that's not important
to this discussion.

00:24:13.800 --> 00:24:16.770
But those videos are
called scene cuts.

00:24:16.770 --> 00:24:20.850
And the encoder has to produce
a steady stream regardless

00:24:20.850 --> 00:24:23.910
of whether the stream changed
a little or it changed a lot.

00:24:23.910 --> 00:24:27.545
And so in order to preserve
consistent visual quality,

00:24:27.545 --> 00:24:28.920
the encoder is
allowed to produce

00:24:28.920 --> 00:24:31.800
frames that are sometimes
larger and sometimes smaller.

00:24:31.800 --> 00:24:33.600
Tuning that behavior
is extremely

00:24:33.600 --> 00:24:35.460
important for cloud gaming.

00:24:35.460 --> 00:24:38.910
So many encoders also include
powerful computationally

00:24:38.910 --> 00:24:41.610
expensive and very
slow pre-analysis steps

00:24:41.610 --> 00:24:44.550
that try to figure out the
best encoding strategy.

00:24:44.550 --> 00:24:47.160
One of the more prevalent
approaches to that

00:24:47.160 --> 00:24:50.460
is to encode a frame multiple
times with multiple strategies

00:24:50.460 --> 00:24:52.350
and then pick the
right one afterwards.

00:24:52.350 --> 00:24:55.290
And at the extreme case, the
people who encode Blu-rays

00:24:55.290 --> 00:24:57.930
will actually have a
combinatorial explosion,

00:24:57.930 --> 00:25:00.420
where they'll try all of
the different possibilities.

00:25:00.420 --> 00:25:02.400
And then they'll walk
a path between them

00:25:02.400 --> 00:25:05.820
to get the best possible quality
at the lowest possible bitrate.

00:25:05.820 --> 00:25:07.650
So they have weeks to do that.

00:25:07.650 --> 00:25:10.600
By comparison, we have a
handful of milliseconds.

00:25:10.600 --> 00:25:13.200
So we have to be really,
really careful about the types

00:25:13.200 --> 00:25:17.720
of analysis that we enable and
which things that we don't.

00:25:17.720 --> 00:25:20.300
So here's my simplified overview
of how a network actually

00:25:20.300 --> 00:25:21.480
fits together.

00:25:21.480 --> 00:25:24.360
There are many hops between an
edge data center and a player.

00:25:24.360 --> 00:25:26.610
Our data centers have to be
on the edge of the network

00:25:26.610 --> 00:25:29.140
as close as possible to the
players, because as Guru

00:25:29.140 --> 00:25:31.460
mentioned, speed of
light does factor

00:25:31.460 --> 00:25:33.470
into our latency calculations.

00:25:33.470 --> 00:25:35.540
The network consists
of a heterogeneous set

00:25:35.540 --> 00:25:37.250
of interconnected devices.

00:25:37.250 --> 00:25:40.010
Each of these devices has
their own characteristics

00:25:40.010 --> 00:25:42.030
and their own
buffering strategies.

00:25:42.030 --> 00:25:44.030
The connections between
each of these components

00:25:44.030 --> 00:25:46.830
each have a capacity that's
measured in bits per second.

00:25:46.830 --> 00:25:48.500
And they span a
physical distance which

00:25:48.500 --> 00:25:50.510
introduces a minimum latency.

00:25:50.510 --> 00:25:53.232
Each device also typically has
a buffer attached to it in order

00:25:53.232 --> 00:25:55.690
to absorb packets that can't
yet be sent because the linked

00:25:55.690 --> 00:25:56.953
speed is too slow.

00:25:56.953 --> 00:25:58.370
Some of these
buffers are shallow,

00:25:58.370 --> 00:26:00.632
such as the ones in data
centers, and some are deep.

00:26:00.632 --> 00:26:02.840
The deep ones led to a term
that was popular a little

00:26:02.840 --> 00:26:05.420
while back of a phenomenon
called buffer bloat.

00:26:05.420 --> 00:26:07.850
When these buffers
fill, that's congestion.

00:26:07.850 --> 00:26:10.490
Because packets are waiting in
buffers and not being sent so

00:26:10.490 --> 00:26:11.720
you get latency.

00:26:11.720 --> 00:26:14.240
If these buffers overflow,
then packets are lost

00:26:14.240 --> 00:26:15.890
and they have to
be retransmitted.

00:26:15.890 --> 00:26:19.070
So on the receiver side, we
use Web RTC extensions provided

00:26:19.070 --> 00:26:22.420
by our team in Sweden to disable
buffering and displacient

00:26:22.420 --> 00:26:24.260
things as soon as they arrive.

00:26:24.260 --> 00:26:26.600
For our application and
control and congestion

00:26:26.600 --> 00:26:29.245
to keep the buffering as
low as possible is vital.

00:26:29.245 --> 00:26:30.620
We'll see in the
following slides

00:26:30.620 --> 00:26:33.360
a couple of strategies
for doing this.

00:26:33.360 --> 00:26:35.610
So here's one of the more
prevalent congestion control

00:26:35.610 --> 00:26:36.870
schemes on the internet today.

00:26:36.870 --> 00:26:38.010
It's called CUBIC.

00:26:38.010 --> 00:26:40.170
It's actually very old.

00:26:40.170 --> 00:26:42.495
But it's very prevalent,
because it works very well.

00:26:42.495 --> 00:26:44.620
There are some complexities
to the way it operates,

00:26:44.620 --> 00:26:47.413
but for the purposes of this
discussion, the way it operates

00:26:47.413 --> 00:26:49.830
is that it keeps increasing
the transmission rate until it

00:26:49.830 --> 00:26:51.330
causes packet loss.

00:26:51.330 --> 00:26:53.970
When it sees that, it dials
back its rate a little bit

00:26:53.970 --> 00:26:57.620
and then chooses that
as its steady state.

00:26:57.620 --> 00:27:00.460
So it's kind of like a bull
in a China shop that way.

00:27:00.460 --> 00:27:02.600
Many odd video
streaming sites like you

00:27:02.600 --> 00:27:05.600
still use TCP with a CUBIC
congestion control algorithm.

00:27:05.600 --> 00:27:07.160
But if we use this
for cloud gaming

00:27:07.160 --> 00:27:08.210
it would be catastrophic.

00:27:08.210 --> 00:27:10.400
Because every time
we cause packet loss,

00:27:10.400 --> 00:27:12.320
the player would
experience a frozen frame

00:27:12.320 --> 00:27:13.778
until they could
restore a picture.

00:27:13.778 --> 00:27:15.740
And that would take
hundreds of milliseconds.

00:27:15.740 --> 00:27:17.600
CUBIC is a relatively
old algorithm,

00:27:17.600 --> 00:27:19.520
but it's obviously a
good one for its purposes

00:27:19.520 --> 00:27:20.970
since it's still in use.

00:27:20.970 --> 00:27:24.180
In the next slide, we'll see
something more appropriate.

00:27:24.180 --> 00:27:27.500
So let's turn the clock
back, way back to the 1980s.

00:27:27.500 --> 00:27:29.310
I was still playing with GI Joe.

00:27:29.310 --> 00:27:31.640
I was saving the
world from Cobra.

00:27:31.640 --> 00:27:34.250
There was a computer
scientist named Van Jacobsen,

00:27:34.250 --> 00:27:37.740
and he was saving the internet
from congestion collapse.

00:27:37.740 --> 00:27:39.350
I think I had more fun though.

00:27:39.350 --> 00:27:40.670
So Van works at Google now.

00:27:40.670 --> 00:27:42.800
And what Van realized
is that CUBIC

00:27:42.800 --> 00:27:44.690
was developed at a
time when routers

00:27:44.690 --> 00:27:46.430
had much smaller buffers.

00:27:46.430 --> 00:27:48.740
Packet loss as a signal
makes a lot of sense

00:27:48.740 --> 00:27:50.983
only if your
buffers are shallow.

00:27:50.983 --> 00:27:53.150
So, in recent years, he's
developed a new congestion

00:27:53.150 --> 00:27:55.580
control scheme called BBR,
which stands for bottleneck

00:27:55.580 --> 00:27:57.350
bandwidth and round trip time.

00:27:57.350 --> 00:28:01.170
BBR works by using delay as a
signal instead of packet loss.

00:28:01.170 --> 00:28:02.780
So you first transmit
below the speed

00:28:02.780 --> 00:28:05.072
of the slowest link in the
chain, called the bottleneck

00:28:05.072 --> 00:28:05.750
bandwidth.

00:28:05.750 --> 00:28:08.167
And then you keep transmitting
higher and higher bit rates

00:28:08.167 --> 00:28:09.348
until the RTT increases.

00:28:09.348 --> 00:28:11.390
Now you know that you've
started filling a buffer

00:28:11.390 --> 00:28:13.223
and you've reached the
bottleneck bandwidth.

00:28:13.223 --> 00:28:15.530
You choose that as your
steady state transmission

00:28:15.530 --> 00:28:18.590
and you keep the latency
low while utilizing the link

00:28:18.590 --> 00:28:19.902
as best as you can.

00:28:19.902 --> 00:28:21.860
So this is actually very
close to what we need.

00:28:21.860 --> 00:28:23.900
BBR balances right at
the edge of inducing

00:28:23.900 --> 00:28:25.430
buffering but not beyond.

00:28:25.430 --> 00:28:27.350
So we get the best
possible bit rate

00:28:27.350 --> 00:28:30.800
while keeping the
latency imperceptible.

00:28:30.800 --> 00:28:33.200
So let's look at the traditional
streaming media system

00:28:33.200 --> 00:28:34.783
that Khaled and Guru
mentioned, called

00:28:34.783 --> 00:28:37.670
DASH, dynamic adaptive
streaming over HTTP.

00:28:37.670 --> 00:28:41.090
DASH is a very resilient, very
versatile, very widespread

00:28:41.090 --> 00:28:42.050
technology.

00:28:42.050 --> 00:28:43.880
It's agnostic in
latency increases,

00:28:43.880 --> 00:28:45.980
it's stable in many
different adverse situations,

00:28:45.980 --> 00:28:48.950
such as network migration
from Wi-Fi to cellular.

00:28:48.950 --> 00:28:51.020
And it splits the
video and audio

00:28:51.020 --> 00:28:53.180
into a set of chunks,
usually timed at intervals

00:28:53.180 --> 00:28:54.650
of 5 to 10 seconds.

00:28:54.650 --> 00:28:56.660
Each of these chunks is
transmitted in a burst

00:28:56.660 --> 00:28:58.010
at the maximum line speed.

00:28:58.010 --> 00:29:00.080
So that means that even
if your video is only

00:29:00.080 --> 00:29:04.820
encoded at 10 megabits, it'll
send bursts of 150, 150, 150,

00:29:04.820 --> 00:29:07.062
if your line supports
a speed like that.

00:29:07.062 --> 00:29:09.020
When the network can't
deliver data fast enough

00:29:09.020 --> 00:29:11.780
for the client to buffer it,
then a re-buffering event

00:29:11.780 --> 00:29:12.590
occurs.

00:29:12.590 --> 00:29:15.560
DASH players will then change
to a lower bitrate stream,

00:29:15.560 --> 00:29:17.060
but these quality
changes tend to be

00:29:17.060 --> 00:29:19.010
at a relatively coarse
time interval measured

00:29:19.010 --> 00:29:20.870
in tens of seconds usually.

00:29:20.870 --> 00:29:23.510
DASH streams also have to
be seekable and then contain

00:29:23.510 --> 00:29:24.470
frequent I-frames.

00:29:24.470 --> 00:29:27.998
You can see that as orange
lines on the graph over there.

00:29:27.998 --> 00:29:29.540
All of these
characteristics are very

00:29:29.540 --> 00:29:30.890
inappropriate for cloud gaming.

00:29:30.890 --> 00:29:33.830
So let's look at what's
more appropriate.

00:29:33.830 --> 00:29:36.520
So here we see how a cloud
gaming engine actually works

00:29:36.520 --> 00:29:38.410
during good network conditions.

00:29:38.410 --> 00:29:40.840
We can see that at each frame
the congestion controller

00:29:40.840 --> 00:29:43.120
is requesting a
specific target bitrate.

00:29:43.120 --> 00:29:44.720
It chooses the
target based on what

00:29:44.720 --> 00:29:46.720
it perceives as the current
state of the network

00:29:46.720 --> 00:29:48.460
buffers along the path.

00:29:48.460 --> 00:29:50.980
Unlike DASH, P-frames
are used consistently

00:29:50.980 --> 00:29:52.770
unless something bad happens.

00:29:52.770 --> 00:29:54.610
I-frames are sent only
on demand and they're

00:29:54.610 --> 00:29:56.200
tuned to be very
small, so there is

00:29:56.200 --> 00:29:58.120
a small quality hit for that.

00:29:58.120 --> 00:30:00.820
The controller is constantly
adjusting the target bitrate

00:30:00.820 --> 00:30:03.010
based on per packet
feedback signals that arrive

00:30:03.010 --> 00:30:04.540
from the receiver device.

00:30:04.540 --> 00:30:07.030
The controller uses a
variety of filters, models,

00:30:07.030 --> 00:30:07.720
and other tools.

00:30:07.720 --> 00:30:09.670
And then synthesizes
them into a model

00:30:09.670 --> 00:30:12.580
of the available bandwidth
and chooses a target bitrate

00:30:12.580 --> 00:30:13.930
for the video encoder.

00:30:13.930 --> 00:30:16.460
So when buffers are filling,
like near the fifth frame

00:30:16.460 --> 00:30:19.030
in this example, the
controller notices and reduces

00:30:19.030 --> 00:30:21.280
its transmission rate
to drain the buffers.

00:30:21.280 --> 00:30:23.920
Unlike a traditional
congestion control algorithm,

00:30:23.920 --> 00:30:28.090
our congestion controller must
track media frames, not bytes.

00:30:28.090 --> 00:30:29.950
Because if it was
to track bytes only,

00:30:29.950 --> 00:30:32.010
it might delay the second
half of the video frame

00:30:32.010 --> 00:30:33.260
in the middle of transmitting.

00:30:33.260 --> 00:30:36.690
And then that would
introduce latency.

00:30:36.690 --> 00:30:39.670
So here we see an example
of something bad happening.

00:30:39.670 --> 00:30:41.880
So the congestion controller
is taking swift action

00:30:41.880 --> 00:30:43.210
to remediate it.

00:30:43.210 --> 00:30:45.690
So in this case, near
the transmission of tram

00:30:45.690 --> 00:30:48.878
frames 3 and 4, a competing
flow has filled the buffers

00:30:48.878 --> 00:30:50.670
despite our attempts
to reduce transmission

00:30:50.670 --> 00:30:54.750
rate from 20 megabits to 15
megabits to 12 megabits to 6.

00:30:54.750 --> 00:30:57.523
We find that at frame 5 we've
just lost too many packets.

00:30:57.523 --> 00:30:59.190
And we can't restore
them quickly enough

00:30:59.190 --> 00:31:01.410
to preserve
imperceptible latency.

00:31:01.410 --> 00:31:03.570
So we must request an
I-frame to drain the buffers

00:31:03.570 --> 00:31:06.618
and restore full quality
experience at frame 6.

00:31:06.618 --> 00:31:08.160
The congestion
controller has to deal

00:31:08.160 --> 00:31:10.493
with many different situations,
many different networks,

00:31:10.493 --> 00:31:12.210
and many different
receiver devices.

00:31:12.210 --> 00:31:13.710
And it has to deal
with them blindly

00:31:13.710 --> 00:31:16.450
without explicit information
as to what's going on.

00:31:16.450 --> 00:31:18.540
So it uses this model to
preserve a high quality

00:31:18.540 --> 00:31:21.770
experience with
imperceptible latency.

00:31:21.770 --> 00:31:24.230
So Google's experience
designing algorithms, modeling

00:31:24.230 --> 00:31:26.540
extremely complex
situations in code,

00:31:26.540 --> 00:31:28.580
and working at scale
with millisecond latency

00:31:28.580 --> 00:31:30.350
puts us in an ideal
position to enable

00:31:30.350 --> 00:31:31.920
this experience for players.

00:31:31.920 --> 00:31:34.970
We tune at the millisecond and
sometimes microsecond level

00:31:34.970 --> 00:31:38.090
and make timely informed choices
to keep latency imperceptible

00:31:38.090 --> 00:31:39.890
while maximizing quality.

00:31:39.890 --> 00:31:42.320
We blend many different
signals, models, feedback,

00:31:42.320 --> 00:31:45.080
active learning, and sensors,
in a tight feedback loop

00:31:45.080 --> 00:31:47.660
to produce a precisely
tuned experience.

00:31:47.660 --> 00:31:49.910
We work closely with our
hardware and video encoders

00:31:49.910 --> 00:31:52.190
to tune their operation in
a network aware and network

00:31:52.190 --> 00:31:53.360
sensitive matter.

00:31:53.360 --> 00:31:55.360
We use predictive models
and advanced algorithms

00:31:55.360 --> 00:31:57.890
to know what to expect on
chaotic Wi-Fi and mobile

00:31:57.890 --> 00:31:59.840
networks and prepare
for it, while not

00:31:59.840 --> 00:32:02.635
overreacting or acting with
excessive conservatism.

00:32:02.635 --> 00:32:04.010
And now Guru is
going to tell you

00:32:04.010 --> 00:32:08.954
about the infrastructure
that enables this experience.

00:32:08.954 --> 00:32:10.708
We're behind a little bit.

00:32:10.708 --> 00:32:11.250
We're behind.

00:32:11.250 --> 00:32:12.333
GURU SOMADDER: Thanks Rob.

00:32:12.333 --> 00:32:14.490
So you've heard about our
extensive user research

00:32:14.490 --> 00:32:17.010
and morse tachions
and carrier pigeons,

00:32:17.010 --> 00:32:19.280
also known as a
streaming infrastructure.

00:32:19.280 --> 00:32:21.780
Now let's talk about what makes
the underlying foundation so

00:32:21.780 --> 00:32:23.222
strong.

00:32:23.222 --> 00:32:24.930
Everything you have
seen and heard so far

00:32:24.930 --> 00:32:26.370
is built on Google's
three pillars

00:32:26.370 --> 00:32:29.850
of excellence, unparalleled
infrastructure that

00:32:29.850 --> 00:32:32.650
controls the player's
experience end to end.

00:32:32.650 --> 00:32:34.620
We've also been making
continuous investments

00:32:34.620 --> 00:32:38.770
in technologies, like hardware,
data processing, EIN security.

00:32:38.770 --> 00:32:41.700
And, finally, over the years,
we have built the blueprint

00:32:41.700 --> 00:32:44.760
to launch products that
allow our partners to succeed

00:32:44.760 --> 00:32:49.480
all with a 10x mentality
towards inventing the future.

00:32:49.480 --> 00:32:50.940
As you can see
from this map, this

00:32:50.940 --> 00:32:54.150
is a representation of Google's
network infrastructure.

00:32:54.150 --> 00:32:56.370
These represent
internet exchanges.

00:32:56.370 --> 00:32:57.600
We have 90 of them.

00:32:57.600 --> 00:33:02.100
100 interconnection facilities
worldwide, and more than 7,500

00:33:02.100 --> 00:33:05.820
edge nodes deployed deep inside
network operators and ISPs.

00:33:05.820 --> 00:33:07.650
These are located
close to players

00:33:07.650 --> 00:33:11.996
and enable us to provide a
consistent experience at scale.

00:33:11.996 --> 00:33:15.750
Our cloud gaming platform
also leverages our continuing

00:33:15.750 --> 00:33:17.430
technology investments.

00:33:17.430 --> 00:33:19.380
Hardware acceleration
technologies

00:33:19.380 --> 00:33:22.590
that offset diminishing
returns of Moore's law,

00:33:22.590 --> 00:33:25.500
leveraging data across Google
services for deep insight

00:33:25.500 --> 00:33:29.050
into player latency for an
optimal player experience,

00:33:29.050 --> 00:33:32.280
and, finally, machine learning
to improve all aspects of game

00:33:32.280 --> 00:33:33.570
development.

00:33:33.570 --> 00:33:36.960
It's not just our technology
but how we apply it

00:33:36.960 --> 00:33:39.510
that gives us a unique
ability to build

00:33:39.510 --> 00:33:42.960
an always on, always available,
and highly secure cloud gaming

00:33:42.960 --> 00:33:44.930
platform.

00:33:44.930 --> 00:33:47.360
And, finally, ingrained
into all of this

00:33:47.360 --> 00:33:51.460
is Google's DNA to scale, what
Google engineering is built on.

00:33:51.460 --> 00:33:53.750
We have an unparalleled
ability and willingness

00:33:53.750 --> 00:33:55.280
to throw some of
our best engineers

00:33:55.280 --> 00:33:57.830
at the toughest problems
building on an existing

00:33:57.830 --> 00:33:58.860
culture of success.

00:33:58.860 --> 00:34:02.300
For example, YouTube,
maps, photos.

00:34:02.300 --> 00:34:03.890
We also have world
class end point

00:34:03.890 --> 00:34:08.719
reach to players on the web, in
the living room, and on mobile.

00:34:08.719 --> 00:34:10.580
And, finally, Google
over the years

00:34:10.580 --> 00:34:14.179
has invented and deeply
influenced a wide range

00:34:14.179 --> 00:34:21.050
of internet protocols and
algorithms, HDMI5, Quick, RTC,

00:34:21.050 --> 00:34:23.449
VP9, and BBR.

00:34:23.449 --> 00:34:25.670
To sum up our cloud
gaming platform

00:34:25.670 --> 00:34:29.420
is built using some of the same
core concepts, best practices

00:34:29.420 --> 00:34:32.300
and technologies that
power some of our most

00:34:32.300 --> 00:34:34.514
successful and
scalable products.

00:34:34.514 --> 00:34:36.139
I'm now going to hand
it over to Khaled

00:34:36.139 --> 00:34:38.960
to continue on with the rest
of the journey, Project Stream.

00:34:41.556 --> 00:34:43.639
KHALED ABDEL RAHMAN: So
after getting our streamer

00:34:43.639 --> 00:34:46.070
into a solid state,
our natural next step

00:34:46.070 --> 00:34:50.639
was to test it out, validate
it, and optimize where needed.

00:34:50.639 --> 00:34:53.429
Assassin's Creed was
the perfect test.

00:34:53.429 --> 00:34:55.290
It had a wide variety
of environments,

00:34:55.290 --> 00:34:57.490
meaning varying
bitrate requirements.

00:34:57.490 --> 00:34:59.310
It had a ton of
different mechanics,

00:34:59.310 --> 00:35:01.690
meaning varying
latency requirements.

00:35:01.690 --> 00:35:03.660
And there was a ton of
excitement for the game.

00:35:03.660 --> 00:35:05.350
Everyone wanted to play it.

00:35:05.350 --> 00:35:09.090
So we would be able to get a
broad audience across the US.

00:35:09.090 --> 00:35:12.780
Internally, we wanted to make
things out of Project Stream.

00:35:12.780 --> 00:35:14.940
We wanted to test and
improve our streamer.

00:35:14.940 --> 00:35:17.610
And we wanted to be hands on
with an optimization phase

00:35:17.610 --> 00:35:21.540
that developers go through
and build the tools for it.

00:35:21.540 --> 00:35:23.560
So upon receiving the
first bill of the game,

00:35:23.560 --> 00:35:26.510
we were pretty impressed
with the overall quality.

00:35:26.510 --> 00:35:29.140
We were excited to have a
title at this particular stage

00:35:29.140 --> 00:35:30.460
in development.

00:35:30.460 --> 00:35:32.530
We wanted to try
so many new things

00:35:32.530 --> 00:35:34.690
and luckily we got
the chance to do so.

00:35:34.690 --> 00:35:38.260
The Ubisoft team in particular
was very collaborative and open

00:35:38.260 --> 00:35:40.270
to exploring these ideas.

00:35:40.270 --> 00:35:43.180
And our team had always
been a fast moving one,

00:35:43.180 --> 00:35:44.920
but we were also
very much grounded

00:35:44.920 --> 00:35:47.020
and research validated results.

00:35:47.020 --> 00:35:49.750
So we made sure that both
our platform optimization

00:35:49.750 --> 00:35:52.480
and our developer tools
came from hands on

00:35:52.480 --> 00:35:55.960
and world validated results.

00:35:55.960 --> 00:35:58.560
Some of the more
interesting results involved

00:35:58.560 --> 00:36:01.500
manipulating perceptual
quality, with which

00:36:01.500 --> 00:36:03.270
all synthetic
benchmarks showcased

00:36:03.270 --> 00:36:04.380
would have no improvement.

00:36:04.380 --> 00:36:07.350
But every tested player
said that they did.

00:36:07.350 --> 00:36:09.030
And another exciting
thing to note

00:36:09.030 --> 00:36:11.700
was, because our
platform was live,

00:36:11.700 --> 00:36:13.470
it can constantly improve.

00:36:13.470 --> 00:36:17.010
So we were able to do A/B tests,
not just before we launched,

00:36:17.010 --> 00:36:18.990
but also after we launched.

00:36:18.990 --> 00:36:21.630
And, eventually we improved
the visual fidelity

00:36:21.630 --> 00:36:25.200
while the game was live, meaning
that players one day logged

00:36:25.200 --> 00:36:27.420
in to play their game
and their experience

00:36:27.420 --> 00:36:30.390
was just better without
the need for any updates

00:36:30.390 --> 00:36:33.610
or any disruption
of the service.

00:36:33.610 --> 00:36:35.420
We ended up with
really good results

00:36:35.420 --> 00:36:37.400
and an overwhelming response.

00:36:37.400 --> 00:36:39.670
But in reality what
we were excited

00:36:39.670 --> 00:36:42.670
about most was what we
were able to achieve

00:36:42.670 --> 00:36:44.770
and how the Project
Stream is now

00:36:44.770 --> 00:36:46.480
allowing us to scale
to the platform

00:36:46.480 --> 00:36:47.550
you now know as Stadia.

00:36:51.520 --> 00:36:54.130
Through Project Stream we were
able to learn and eventually

00:36:54.130 --> 00:36:56.650
improve our streamer,
now capable of higher

00:36:56.650 --> 00:36:59.470
quality at lower
bitrates, faster network

00:36:59.470 --> 00:37:03.190
adaptability, 4K, HDR,
and surround sound,

00:37:03.190 --> 00:37:04.880
amongst other things.

00:37:04.880 --> 00:37:07.300
On the other hand,
we expanded our tools

00:37:07.300 --> 00:37:09.763
to include the playability
toolkit for optimization.

00:37:09.763 --> 00:37:11.680
I'm going to give you a
quick overview of some

00:37:11.680 --> 00:37:13.520
of these tools.

00:37:13.520 --> 00:37:15.850
So we did make sure that
our platform provides

00:37:15.850 --> 00:37:19.960
an excellent experience as
is, but a natural extension

00:37:19.960 --> 00:37:23.320
was to provide tooling for
developers that wanted a bit

00:37:23.320 --> 00:37:27.860
more of a deeper optimization or
customization on the platform.

00:37:27.860 --> 00:37:31.070
At the center of our
tools is our test client.

00:37:31.070 --> 00:37:33.230
From a developer portal
you're able to launch

00:37:33.230 --> 00:37:35.540
any build of your game,
and you can immediately

00:37:35.540 --> 00:37:39.530
access a wide variety of
tools directly through the UI.

00:37:39.530 --> 00:37:42.020
Some of the tools here
include network emulation,

00:37:42.020 --> 00:37:44.960
where you can try a different
network impairments yourself,

00:37:44.960 --> 00:37:47.210
like different DSL
and Wi-Fi models

00:37:47.210 --> 00:37:50.610
and see the behavior under
different network conditions.

00:37:50.610 --> 00:37:53.450
Another utility available
is a quick capture tool,

00:37:53.450 --> 00:37:56.690
allowing you to record video
of a rendered, encoded, and

00:37:56.690 --> 00:37:59.370
decoded frame at the same time.

00:37:59.370 --> 00:38:02.450
This allows you to debug
the entire video pipeline

00:38:02.450 --> 00:38:03.030
in one click.

00:38:06.230 --> 00:38:08.660
So quickly going over
some of our APIs,

00:38:08.660 --> 00:38:11.810
the stream profile APIs allows
you to set encoder preferences

00:38:11.810 --> 00:38:14.600
for your title,
this aligns directly

00:38:14.600 --> 00:38:17.440
with what we noticed while
launching Project Stream.

00:38:17.440 --> 00:38:21.720
Assassin's Creed really relied
heavily on encode utilization.

00:38:21.720 --> 00:38:24.380
And we've made three
profiles available so far

00:38:24.380 --> 00:38:26.670
with the intent to provide
more in the future,

00:38:26.670 --> 00:38:30.930
including custom profiles with
full encoder settings exposed.

00:38:30.930 --> 00:38:33.630
The MediaStream API
gives you direct access

00:38:33.630 --> 00:38:36.990
to all relevant values from
the stream in real time--

00:38:36.990 --> 00:38:40.080
things like current
resolution, RTT, and more.

00:38:40.080 --> 00:38:43.410
This can be used to dynamically
adjust behavior or mechanics as

00:38:43.410 --> 00:38:45.320
needed.

00:38:45.320 --> 00:38:47.880
The stream capabilities
API sends a signal

00:38:47.880 --> 00:38:49.980
about the particular
endpoint being used

00:38:49.980 --> 00:38:52.410
and all of its
relevant capabilities.

00:38:52.410 --> 00:38:54.780
This allows for some
amazing play anywhere

00:38:54.780 --> 00:38:56.910
experiences, where
you can seamlessly

00:38:56.910 --> 00:39:00.300
move between a less capable
device and a full setup that

00:39:00.300 --> 00:39:03.750
has HDR and surround sound
within the same session.

00:39:03.750 --> 00:39:06.690
The game would be able to auto
detect it, switch these modes

00:39:06.690 --> 00:39:10.000
on, on a suspend and resume.

00:39:10.000 --> 00:39:12.020
The frame token API,
on the other hand,

00:39:12.020 --> 00:39:14.170
allows you to associate
a delivered frame

00:39:14.170 --> 00:39:16.150
with a particular
input, allowing

00:39:16.150 --> 00:39:18.250
for easier
compensation mechanics

00:39:18.250 --> 00:39:19.630
similar to what
you might be used

00:39:19.630 --> 00:39:22.840
to from traditional
multiplayer games.

00:39:22.840 --> 00:39:25.980
So these were just a few of
the many, many APIs and tools

00:39:25.980 --> 00:39:28.380
we provide as part
of this toolkit.

00:39:28.380 --> 00:39:30.630
We've been working
for years to make

00:39:30.630 --> 00:39:33.330
sure our streamer has
unparalleled performance,

00:39:33.330 --> 00:39:36.270
able to provide excellent
experiences for players

00:39:36.270 --> 00:39:37.660
at scale.

00:39:37.660 --> 00:39:40.050
We've also made sure
that a lot of these tools

00:39:40.050 --> 00:39:41.970
are at your disposal,
allowing you

00:39:41.970 --> 00:39:43.860
to take full advantage
of our platform

00:39:43.860 --> 00:39:46.980
and deliver your true
vision for your game.

00:39:46.980 --> 00:39:50.490
We're so excited for you to join
us in this new era for gaming.

00:39:50.490 --> 00:39:53.450
Please apply to be a
developer today at Stadia.dev.

00:39:53.450 --> 00:39:57.400
[LOGO MUSIC]

