WEBVTT
Kind: captions
Language: en

00:00:07.339 --> 00:00:13.340
&gt;&gt;Boris Smus: All right. Hey, folks, good
to see so many people in the room. Can everyone

00:00:13.340 --> 00:00:18.650
hear me fine?
Great. So my name is Boris Smus. I'm an engineer

00:00:18.650 --> 00:00:23.640
in the Chrome developer relations team. And
this talk is called Fast User Interface for

00:00:23.640 --> 00:00:30.570
the cross-device Web. So before talking about
this, let me motivate the subject a little

00:00:30.570 --> 00:00:36.239
bit. Who cares?
And I care and you should care because this

00:00:36.239 --> 00:00:41.270
is the current state of mobile internet usage
compared to desktop internet usage. So you

00:00:41.270 --> 00:00:48.380
can see the projected cross-over point for
when mobile becomes more used, and this is

00:00:48.380 --> 00:00:55.000
sometime around 2013, 2014. This is all internet
use, so not just Web. The Web is currently

00:00:55.000 --> 00:01:02.510
about 10% of all -- mobile Web is about 10%
of all Web usage and it's been doubling every

00:01:02.510 --> 00:01:11.280
year, so expect this to change very drastically.
Note that I call the talk cross-device, and

00:01:11.280 --> 00:01:17.189
not mobile, because the term mobile is a little
bit overloaded. Does it include tablets?

00:01:17.189 --> 00:01:21.590
Does it include other kinds of devices like
TVs, cars, et cetera?

00:01:21.590 --> 00:01:24.279
And what is the opposite of mobile?
Stationary?

00:01:24.279 --> 00:01:29.369
Desktop?
Not clear. So I'm not going to jump into pedantic

00:01:29.369 --> 00:01:35.859
discussions about this. Instead, clearly,
this is not a mobile device, so this is a

00:01:35.859 --> 00:01:42.259
desktop, and many people still think of this
as the target for the Web. But, in fact, the

00:01:42.259 --> 00:01:48.009
Web looks a lot more like this. We have a
mass of devices that all access -- that all

00:01:48.009 --> 00:01:53.969
expect Web content to serve correctly for
them, tablets, SmartPhones, et cetera, it's

00:01:53.969 --> 00:01:59.630
very complex landscape, and it's only going
to get more complex and more interesting with

00:01:59.630 --> 00:02:07.099
future interactions that can include gestural
UIs, handtracking, full body tracking, et

00:02:07.099 --> 00:02:13.940
cetera, or audio input. So how can we talk
about this broad topic?

00:02:13.940 --> 00:02:18.299
There are still a set of common issues that
we need to tackle for all of these problems

00:02:18.299 --> 00:02:24.390
that I've discussed. We have a wide variety
of form factors, as you saw a couple of slides

00:02:24.390 --> 00:02:29.599
ago. In addition we have CPUs and networks
that are much, much slower and much less predictable

00:02:29.599 --> 00:02:35.189
in many cases on mobile devices. We need to
deal with new kinds of input, specifically

00:02:35.189 --> 00:02:40.390
touch and multi-touch, and we have issues
with developing when your host machine is

00:02:40.390 --> 00:02:45.730
not your target machine. So I'll talk more
about that, in addition. So this is -- these

00:02:45.730 --> 00:02:51.790
are all issues, but they're also -- this is
also a outline for the rest of the talk. So

00:02:51.790 --> 00:02:57.700
let's jump right in into the form factor question.
And how do we support multiple devices that

00:02:57.700 --> 00:03:05.909
access our site?
First extreme is we simply create one version.

00:03:05.909 --> 00:03:11.150
And some people do this. Some of the examples
of sites that do -- that take this approach

00:03:11.150 --> 00:03:17.640
are shown here. We have -- you can see text
that's not very clearly readable. It's very

00:03:17.640 --> 00:03:23.760
small on a mobile device. Text that's being
cut off because the developers didn't intend

00:03:23.760 --> 00:03:29.489
it to be used on such a screen, or in this
last example, we have actually two versions,

00:03:29.489 --> 00:03:33.459
one of which says the device doesn't work
on your phone, or the application doesn't

00:03:33.459 --> 00:03:39.379
work on your phone. Sorry. So this is not
a very good extreme to be at. The other opposite

00:03:39.379 --> 00:03:46.370
end of the spectrum is to create a version
for each device, so we have here a very incomplete

00:03:46.370 --> 00:03:52.249
list of sound devices in the market and you
can simply say, okay, let's develop a version

00:03:52.249 --> 00:03:56.689
for each. You can see this has ten devices,
there's probably hundreds, maybe thousands

00:03:56.689 --> 00:04:01.209
of devices out there. It's simply not feasible
to do this, especially if you take into account

00:04:01.209 --> 00:04:05.749
the number of browsers that exists on some
platforms. For example, Android supports a

00:04:05.749 --> 00:04:11.469
wide variety of browsers. So we need to find
some sort of middle ground, keeping in mind

00:04:11.469 --> 00:04:16.620
this tradeoff that the more versions you create
the better each one can be from a user experience

00:04:16.620 --> 00:04:23.220
perspective but the more effort it will require.
So the question then is where can we save

00:04:23.220 --> 00:04:27.680
some effort?
And how can we make this a -- how can we make

00:04:27.680 --> 00:04:35.830
a better decision what to build?
So we have two sort of axes to choose from.

00:04:35.830 --> 00:04:44.639
We have platforms and form factors. Let's
talk about platforms. So native platforms,

00:04:44.639 --> 00:04:51.000
this is a bit of an aside, they provide human
interface guidelines and UI frameworks, so

00:04:51.000 --> 00:04:56.509
this is on the -- on the right, example of
a human interface guideline for Android, it

00:04:56.509 --> 00:05:01.820
provides a set of common UI controls and the
corresponding UI framework makes it really

00:05:01.820 --> 00:05:08.280
easy to build that kind of UI for a developer.
So the point of this is to make it -- to have

00:05:08.280 --> 00:05:13.539
developers fall into a pit of success by default.
If you try to do this sort of thing on the

00:05:13.539 --> 00:05:22.050
Web, as some people have, you quickly run
into problems, so emulating native UIs is

00:05:22.050 --> 00:05:28.430
a perilous path. It's hard to implement. You're
going to be always slightly off and look and/or

00:05:28.430 --> 00:05:34.830
feel, and even once you've done this painstaking
effort that some people have taken, you still

00:05:34.830 --> 00:05:40.500
have to repeat that same process on every
other platform that you want to support. So

00:05:40.500 --> 00:05:44.979
if you want to read more about some pour soul
that did this, you should check out this guy's

00:05:44.979 --> 00:05:49.230
blog post. It's very detailed and good. He
goes into details like you can see a little

00:05:49.230 --> 00:05:57.430
bit of diagonal artifact here in the CSS version
of this platform. So that kind of level of

00:05:57.430 --> 00:06:03.580
detail. So generally speaking platform differences
vary -- platform differences are both small,

00:06:03.580 --> 00:06:09.419
so we can have different styles for buttons,
but some of them may appear bigger, for example,

00:06:09.419 --> 00:06:15.150
the placement of navigation bar, the Android
human interface guideline says to place it

00:06:15.150 --> 00:06:21.060
at the top of the screen whereas the IOS one
places it on the bottom. Fairly major change,

00:06:21.060 --> 00:06:25.940
but it's important to note that these are
differences that -- or, sorry, these are rules

00:06:25.940 --> 00:06:31.330
that are meant to be broken, and in many cases
are. So on Android many applications place

00:06:31.330 --> 00:06:36.569
the tool bar on the bottom, whereas on IOS
for example, on iPad the guidelines actually

00:06:36.569 --> 00:06:44.039
say to place it on the top. If we look at
form factor differences, though, these are

00:06:44.039 --> 00:06:48.940
much bigger. We have completely different
usage patterns, phones that you hold with

00:06:48.940 --> 00:06:55.599
one hand, and tablets that you hold with two.
Major variations in screen real estate. So

00:06:55.599 --> 00:07:03.240
these form factor differences I would say
trump platform differences, so as a first

00:07:03.240 --> 00:07:08.300
cut, and I'm not saying that this is perfect
for your application, we can consider having

00:07:08.300 --> 00:07:18.879
multiple versions of our site, and compromise
to phone, tablet and desktop, just as a starting

00:07:18.879 --> 00:07:24.110
point. So how do we actually build this?
We build this -- there's two possible angles

00:07:24.110 --> 00:07:28.349
to come at it from. We can start from single
version and make tweaks -- diversion tweaks

00:07:28.349 --> 00:07:34.120
to that version, or we can say up front we're
going to build three versions and serve the

00:07:34.120 --> 00:07:42.599
correct one. So the first version, many of
you are probably familiar with CSS media queries.

00:07:42.599 --> 00:07:49.420
In case you're not, it's an easy way to tweak
your CSS style sheets depending on properties

00:07:49.420 --> 00:07:55.979
of your device. So here I have a media query
which says if the screen is less than 1,000

00:07:55.979 --> 00:08:03.550
pixels, then hide the side bar. So this is
pretty straightforward, and is used to create

00:08:03.550 --> 00:08:13.050
websites that look like this. So here is a
German design magazine, and you can see, as

00:08:13.050 --> 00:08:23.320
I resize the page, the styling changes subtly.
You will see -- you'll notice also that Chrome

00:08:23.320 --> 00:08:28.970
has a minimum size. Let me show you a cool
trick that you can -- you may not know. I

00:08:28.970 --> 00:08:35.169
can actually resize the page using the developer
tools. Resize it back to the correct size

00:08:35.169 --> 00:08:41.980
here. Switch over to Dev Tools, and I will
override device metrics here and pick the

00:08:41.980 --> 00:08:49.440
resolution that I want. Just set it to 320
by 480, and you can see I've sized it down

00:08:49.440 --> 00:08:56.160
-- I couldn't use Chrome natively -- or sorry,
I couldn't resize Chrome to be this small.

00:08:56.160 --> 00:09:06.350
You can get a good preview of how these sites
look like using this feature. But there's

00:09:06.350 --> 00:09:11.260
limitations to this approach, right?
We're talking here about a shared DOM, shared

00:09:11.260 --> 00:09:17.060
JavaScript and simply tweaking the CSS. So
if we want to make big changes between form

00:09:17.060 --> 00:09:23.260
factors such as this example here where we
have Gmail native apps for Android, you can

00:09:23.260 --> 00:09:28.720
imagine the pain that you would have to go
through to use this same HTML and create these

00:09:28.720 --> 00:09:36.010
separate layouts. A lot of CSS tweaks, a lot
of hidden content, a lot of conditional CSS

00:09:36.010 --> 00:09:41.120
for the various -- for the two form factors.
Also, since we have shared JavaScript in this

00:09:41.120 --> 00:09:50.840
case, how do we load additional functionality?
So one middle ground here, between these -- between

00:09:50.840 --> 00:09:56.510
the two extremes of one version and separate
versions completely is using media queries

00:09:56.510 --> 00:10:02.970
in JavaScript, we can do this with the window
of match media call, and this lets you evaluate

00:10:02.970 --> 00:10:07.600
arbitrary media queries as in this sample,
you can see I'm evaluating this media query

00:10:07.600 --> 00:10:15.420
and I'm seeing if it matches or not. You can
also listen for changes with this event listener,

00:10:15.420 --> 00:10:21.520
syntax, and here in this example, I'm listening
for the orientation media query, and as soon

00:10:21.520 --> 00:10:27.070
as that changes, if I switch from portrait
to landscape, this will fire, and I can respond

00:10:27.070 --> 00:10:36.500
to that. It's a much nicer way of going about
things using orientation change.

00:10:36.500 --> 00:10:42.590
But if we want to completely separate the
two -- separate the versions that we want

00:10:42.590 --> 00:10:49.600
to create, we can take an approach like this.
This is really simple code that basically

00:10:49.600 --> 00:10:55.150
says default to a desk -- to the desktop version,
then check for touch support, if there's touch

00:10:55.150 --> 00:10:59.970
support and the screen is small, is there
a phone version, otherwise if the screen is

00:10:59.970 --> 00:11:07.100
large but touch is still enabled, serve the
tablet. So here we need to figure out how

00:11:07.100 --> 00:11:11.790
to know if there's touch or not. Right now
there's not a really good way of doing this

00:11:11.790 --> 00:11:18.490
on the open Web. So we can use modernizr or
other feature detection libraries to do this

00:11:18.490 --> 00:11:26.520
sort of thing. So modernizr.touch will return
true if touch is enabled. But we have media

00:11:26.520 --> 00:11:31.080
queries that are coming through the pipe.
They're not implemented anywhere yet. We have

00:11:31.080 --> 00:11:38.271
hover and pointer media queries which are
used to distinguish between pointer or mouse

00:11:38.271 --> 00:11:46.870
pointer type input and touch input. The other
question here is how do we know what's small

00:11:46.870 --> 00:11:50.520
enough?
Where do we draw the line between phones and

00:11:50.520 --> 00:11:54.110
tablets?
So we can evaluate the media query, but where

00:11:54.110 --> 00:12:04.190
do we set this boundary?
So here is a -- on the right -- diagram of

00:12:04.190 --> 00:12:10.890
various mobile devices and their resolutions
in CSS pixels, so it's important here for

00:12:10.890 --> 00:12:16.480
this discussion to remember that, CSS pixels
are not the same as device pixels. CSS pixels

00:12:16.480 --> 00:12:25.960
are scaled to the -- they're scaled by the
device pixel ratio to be virtually sized,

00:12:25.960 --> 00:12:32.550
essentially, so the history here is when Apple
released iPhone 4, they had doubled the resolution

00:12:32.550 --> 00:12:37.120
of both dimensions, creating four times as
many pixels on the screen. So if they did

00:12:37.120 --> 00:12:42.300
nothing about this, then sites would render
at half size, so they introduced this notion

00:12:42.300 --> 00:12:49.850
of device pixel ratio, and sites render the
same way on iPhone 4 and iPhone 3, and other

00:12:49.850 --> 00:12:55.200
device vendors have been embracing this and
providing device pixel ratios sometimes of

00:12:55.200 --> 00:13:04.070
2, sometimes of 1.5, sometimes somewhat irrational
numbers so it's a little bit interesting and

00:13:04.070 --> 00:13:10.790
you should definitely be aware of this -- this
concept. So if we take a look at the diagram,

00:13:10.790 --> 00:13:17.000
we can say, well, let's just draw the line
at, let's see, 400, somewhere between 400

00:13:17.000 --> 00:13:21.980
and 600, that's pretty straightforward, right?
But we should remember that all these devices

00:13:21.980 --> 00:13:26.980
have landscape mode as well, in which case
width becomes height, height becomes width.

00:13:26.980 --> 00:13:33.720
So the actual picture is something more like
this, if we take a look at the max of the

00:13:33.720 --> 00:13:38.430
two dimensions for phones and they're meant
for tablets, so we can draw the line roughly

00:13:38.430 --> 00:13:44.650
at 650 pixels, and this will work most of
the time with some exceptions. For example,

00:13:44.650 --> 00:13:53.360
some -- some tablets in portrait mode, in
this case will get the phone version. So if

00:13:53.360 --> 00:13:57.410
you're specifying multiple versions of your
site, you may be sharing a URL or you may

00:13:57.410 --> 00:14:04.510
have separate URLs. If you have separate URLs,
then you can declaratively define all the

00:14:04.510 --> 00:14:08.920
versions of your site in your head section,
and you can do that with the link rel equals

00:14:08.920 --> 00:14:15.650
alternate and the idea here is you specify
the URLs and the associated media queries

00:14:15.650 --> 00:14:20.840
for each of these versions. This is good for
crawlers that are indexing your site so that

00:14:20.840 --> 00:14:27.390
they can know which versions exist and to
crawl them with these different settings.

00:14:27.390 --> 00:14:32.700
So one thing that you might want to do is
based on these versions that you've declared

00:14:32.700 --> 00:14:40.580
up front, redirect correctly. So the Web doesn't
do this for you, so I worked on a project

00:14:40.580 --> 00:14:46.310
called device.js which tries to formalize
this approach, and what it does is it parses

00:14:46.310 --> 00:14:52.420
the link alternates in your head section,
matches the media queries and then redirects

00:14:52.420 --> 00:15:00.040
you to the right version, if necessary. So
let me quickly show you how this works. So

00:15:00.040 --> 00:15:07.370
I'll -- I'll load up a really simple application.
This is a fake to do list. Now, if I send

00:15:07.370 --> 00:15:27.500
it over to Chrome, on my phone, and switch
it, switch the camera here, let me just load

00:15:27.500 --> 00:15:41.120
it up... one second... all right. Okay. So
I've -- I've loaded the same exact URL on

00:15:41.120 --> 00:15:47.440
both devices, here I've been redirected to
the phone version. Let me do that again. I'll

00:15:47.440 --> 00:16:33.490
try loading to desktop version. Sorry. Hmmm...
it's going to work, trust me. Could you guys

00:16:33.490 --> 00:16:34.490
turn off your internet?
[chuckling]

00:16:34.490 --> 00:16:37.110
&gt;&gt;Boris Smus: I should have done that Steve
Jobs thing.

00:16:37.110 --> 00:16:58.910
[ Laughter ]
&gt;&gt;Boris Smus: Thanks. Let's try this one.

00:16:58.910 --> 00:17:08.439
The pipes are clogged. It's terrible. Ah,
amazing. Watch this. It's loading. So the

00:17:08.439 --> 00:17:18.470
same URL loaded a completely different version,
so let me just show you for comparison here,

00:17:18.470 --> 00:17:24.589
the desktop version, the phone version, so
it's useful to still provide a fall-back mechanism

00:17:24.589 --> 00:17:29.300
so that you're able to specify a different
version if you prefer it, so device.js does

00:17:29.300 --> 00:17:35.169
that as well, and here if I switch to layout
-- landscape mode, I may actually prefer the

00:17:35.169 --> 00:17:42.350
tablet version, so if I pick it, then I can
override the default version that was served

00:17:42.350 --> 00:17:49.510
to me and this will eventually load, so we
can move on for now. So for more details about

00:17:49.510 --> 00:17:56.870
this project, take a look at the GitHub page,
and you're welcome to collaborate with me

00:17:56.870 --> 00:18:03.720
on it, so that's the clientside story, so
we've taken a look at both of these approaches,

00:18:03.720 --> 00:18:10.799
separate versions and one shared version,
but the client has performance penalties for

00:18:10.799 --> 00:18:16.530
doing redirection, so if we do a redirect
that costs somewhere between 100 and 1,000

00:18:16.530 --> 00:18:22.539
milliseconds, on the server we can save on
that redirection in some cases, so the only

00:18:22.539 --> 00:18:27.620
problem with the server is we have much less
features than we do on the client. We don't

00:18:27.620 --> 00:18:33.179
have JavaScript. We don't have media queries.
All we have is a user agent string, and this

00:18:33.179 --> 00:18:40.350
string gets sent with every request, so the
server can decide what to do with this. You

00:18:40.350 --> 00:18:45.990
can see it's a bit of a mess, so this is what
Chrome for Android user agent string looks

00:18:45.990 --> 00:18:52.159
like, and this is pretty much as complicated
as most other browsers. You can see there's

00:18:52.159 --> 00:18:58.480
mentions of pretty much every single browser
that has ever existed. I'm exaggerating. But

00:18:58.480 --> 00:19:03.980
it's kind of a messy thing to deal with. Let
me show you a couple of tools that can make

00:19:03.980 --> 00:19:10.980
this a bit easier. Firstly, let me show you
how pervasive this use is of user agent strings

00:19:10.980 --> 00:19:18.070
on the net. So here is YouTube. If I open
Dev Tools, and I'll turn off this screen scaling

00:19:18.070 --> 00:19:23.520
device metrics feature that I had before.
I can override the user agent, so why don't

00:19:23.520 --> 00:19:30.519
I set it to Galaxy Nexus on Android 402, you'll
notice the device metrics have been set for

00:19:30.519 --> 00:19:36.679
me, automatically, based on a little database
that you just send the developer tools, but

00:19:36.679 --> 00:19:43.740
when I over -- when I reload the page here,
now I've -- I've used a new -- I've reset

00:19:43.740 --> 00:19:49.230
my user agent header and YouTube has sent
me a completely different version of the page,

00:19:49.230 --> 00:19:55.190
so just for comparison, this is the mobile
version, and if I reload, I just the regular

00:19:55.190 --> 00:20:00.610
YouTube version, it's a completely separate
page, so many, many Web properties use this

00:20:00.610 --> 00:20:09.679
service side detection and redirect you without
you even knowing. So how do they do it?

00:20:09.679 --> 00:20:17.309
Generally, they have some sort of device database.
These are typically large databases of known

00:20:17.309 --> 00:20:22.110
user agents and their capabilities and what
device databases do is they try to find the

00:20:22.110 --> 00:20:30.870
closest known UA and give you information
based on your client. So a couple of them

00:20:30.870 --> 00:20:36.620
are device applets in WURFL. They have drawbacks
in that they're nonfree for commercial use.

00:20:36.620 --> 00:20:42.779
They come in two flavors, typically, one as
an API service, so you can make a request

00:20:42.779 --> 00:20:48.779
every time you get a new client connected
and ask a service somewhere else in the Cloud

00:20:48.779 --> 00:20:54.509
what that user agent is, or you can set it
up yourself, but it's not that simple to do,

00:20:54.509 --> 00:21:02.289
so that's the state-of-the-art right now.
And just to recap this multiple versions idea.

00:21:02.289 --> 00:21:08.379
If you're separating your versions upfront,
I would recommend to start with device.js

00:21:08.379 --> 00:21:13.419
or some other similar solution in the client,
measure performance overhead, see if that

00:21:13.419 --> 00:21:20.440
performance of mobile or of clientside redirection
is too high, and if that penalty is too high,

00:21:20.440 --> 00:21:27.769
then switch to user side. So at this point
you're probably thinking this guy is telling

00:21:27.769 --> 00:21:35.639
me to create multiple versions of my app.
This is terrible. I'm not going to do this.

00:21:35.639 --> 00:21:40.100
And I am probably -- I'm thinking you're probably
using a model view controller or if not, you

00:21:40.100 --> 00:21:46.610
should be. So if you don't know what this
pattern is, it is a way to separate the presentation

00:21:46.610 --> 00:21:53.220
layer of your code from the structure and
data logic, business logic of your application.

00:21:53.220 --> 00:22:01.580
So with a cross-device approach, we can simply
swap out the views, create form factor specific

00:22:01.580 --> 00:22:11.050
views and serve them to the various devices
sharing a lot of code. Okay. So that's the

00:22:11.050 --> 00:22:15.850
story for multiple versions, single versions.
Let's talk about some technical things about

00:22:15.850 --> 00:22:22.960
building a great UI. Firstly, what makes a
great UI?

00:22:22.960 --> 00:22:30.159
On the Web, on the mobile Web, I would say
single page sites are examples of that. Some

00:22:30.159 --> 00:22:35.870
features of single page sites are limited
zooming so the user gets text that's readable

00:22:35.870 --> 00:22:40.890
immediately, they don't have to pinch zoom
around. Fixed headers and footers. So content

00:22:40.890 --> 00:22:46.289
that scrolls independently of one another
or having a header placed that's fixed to

00:22:46.289 --> 00:22:53.179
the viewport as opposed to content, and smooth
transitions, animations between states as

00:22:53.179 --> 00:23:04.139
well as just loading links. The most basic
fundament mobile thing to do is the viewport,

00:23:04.139 --> 00:23:10.000
viewport is a virtual viewing area that's
scaled down to your phones or your mobile

00:23:10.000 --> 00:23:16.720
device's display, and you can configure this
viewport by setting the metatag called viewport

00:23:16.720 --> 00:23:23.440
inside your head, and by default it's set
to something ridiculous, like 980 pixels,

00:23:23.440 --> 00:23:30.370
which is wider than most devices. You can
configure it by setting its width to some

00:23:30.370 --> 00:23:38.850
value, but if you set it to a fixed value,
say 320 pixels, that won't work on many devices

00:23:38.850 --> 00:23:44.749
that aren't 320 pixels wide and you will have
the problem of when you switch from landscape

00:23:44.749 --> 00:23:50.190
or from portrait to landscape, text will be
scaled in interesting ways, so the best practice

00:23:50.190 --> 00:23:55.419
here, at minimum, at minimum, is to set the
width to be the device width, which evaluates

00:23:55.419 --> 00:24:00.850
to be the current width for your device in
its current orientation. And you can see without

00:24:00.850 --> 00:24:08.240
a viewport the text is hardly readable on
the left. With a viewport set as I recommend,

00:24:08.240 --> 00:24:15.240
it's much more readable and everyone is happy.
We can take this one step further and prevent

00:24:15.240 --> 00:24:23.390
zooming entirely to sort of be closer to the
user experience of a mobile -- native mobile

00:24:23.390 --> 00:24:28.929
application. We can do this by setting initial
minimum and maximum scale to 1. Just adding

00:24:28.929 --> 00:24:33.679
that to the viewport, and know that you should
separate these directives with commas, not

00:24:33.679 --> 00:24:40.539
semi colons, a lot of Web samples on the Web
use semi colons unfortunately, that is not

00:24:40.539 --> 00:24:46.870
the standard thing to do. Also avoid user
scalable equals no or supplement it with these

00:24:46.870 --> 00:24:53.519
media queries, or, sorry, these content directives,
because it's not supported in Chrome -- user

00:24:53.519 --> 00:25:00.240
scalable, no, is not supported in Android
-- other Android browsers and some other that

00:25:00.240 --> 00:25:09.389
I've tested. So generally speaking, on the
mobile Web, or on any Web, anywhere, really,

00:25:09.389 --> 00:25:16.429
we want our animations to be smooth, and what
this means is we want -- we want them to be

00:25:16.429 --> 00:25:23.820
approaching the limits of human perception,
so 60 frames per second is the animation refresh

00:25:23.820 --> 00:25:30.080
rate above which we can't really tell the
difference, so on mobile devices, this is

00:25:30.080 --> 00:25:35.909
hard, because we have CPUs that are far less
powerful than desktops, and because of this

00:25:35.909 --> 00:25:39.740
we want to utilize hardware acceleration as
much as possible because these devices come

00:25:39.740 --> 00:25:47.529
with pretty powerful CPUs, so an example of
this, to keep an element fixed in relation

00:25:47.529 --> 00:25:52.019
to scrolling of content, the old style way
of doing this, you would position something

00:25:52.019 --> 00:25:58.070
absolutely, listen to scroll events and then
kind of jitter as you try to reposition your

00:25:58.070 --> 00:26:04.690
element every time you scroll. With position
fixed, what you're essentially saying is you're

00:26:04.690 --> 00:26:13.789
telling your GPU that this is a separate layer
and composite in a -- composite it separate

00:26:13.789 --> 00:26:22.610
from my CPU, and this is a much more, much
less janky experience, and much more smooth.

00:26:22.610 --> 00:26:29.940
Similar -- similar tactic applies for scrolling.
Often we want sub element scrolling, so an

00:26:29.940 --> 00:26:39.279
example here is Gmail. Or any two pane tablet
application. So we have a list view and a

00:26:39.279 --> 00:26:45.409
content view on the right, and we can enable
independent scrolling of elements with overflow

00:26:45.409 --> 00:26:53.379
auto, so this is old news. The new thing here
is Webkit overflow scrolling.

00:26:53.379 --> 00:26:58.860
This is a custom Webkit property which works
on IOS and Chrome for Android and it essentially

00:26:58.860 --> 00:27:06.419
forces hardware accelerated scrolling. Let
me quickly show you a demo here. So I'll send

00:27:06.419 --> 00:27:09.539
this -- these are beautiful Chrome ponies.
Chronies?

00:27:09.539 --> 00:27:25.240
I'm not sure. So I'm going to load this on
the device. Mobile Web scrolling. I'm going

00:27:25.240 --> 00:27:40.070
to load it on both devices. See which one
is faster. It's going to be a race. So you

00:27:40.070 --> 00:27:56.799
can watch them race. Anyway, while it's loading,
the idea here is here with overflow hidden,

00:27:56.799 --> 00:28:02.429
we see we can't scroll this region at all,
I'm trying to scroll, we can't. Overflow auto

00:28:02.429 --> 00:28:08.039
is scrolling, but with this Webkit overflow
scrolling touch edition, we get really, really

00:28:08.039 --> 00:28:14.860
fast scrolling on mobile devices, and this
is what I'm trying to show you with this demo,

00:28:14.860 --> 00:28:30.980
and unfortunately it doesn't seem to want
to work. That's too bad. Okay, well, hopefully

00:28:30.980 --> 00:28:46.169
it will load eventually. Okay. So scrolling.
Often we want to go beyond scrolling and have

00:28:46.169 --> 00:28:51.460
transformations of an arbitrary nature, animations,
et cetera, and we still want this to be as

00:28:51.460 --> 00:28:58.009
fast as possible. 60 frames a second. A key
thing here is being able to position elements

00:28:58.009 --> 00:29:04.580
arbitrarily on the screen. You would use position
absolute to do this, but this isn't slow and

00:29:04.580 --> 00:29:10.049
takes the software path -- or this isn't fast,
and takes the software path, so the hardware

00:29:10.049 --> 00:29:14.881
accelerated approach, which is very useful
on mobile, is to use the WebKit transform

00:29:14.881 --> 00:29:21.700
and the WebKit translate -- I'm sorry, WebKit
transform and translate transformations, this

00:29:21.700 --> 00:29:28.200
will trigger hardware accelerated rendering,
especially with translate 3D, this gives a

00:29:28.200 --> 00:29:34.860
hint to the GPU that, hey, you're doing something
fancy and probably GPU mode should be enabled.

00:29:34.860 --> 00:29:40.360
You can of course also do rotations and scales
in this fashion, and it looks like our demo

00:29:40.360 --> 00:29:45.850
has loaded, which is great, so let me switch
back to the projector here for both screens.

00:29:45.850 --> 00:29:53.649
We have our beautiful ponies, as you would
expect. As I scroll hidden -- attempt to scroll

00:29:53.649 --> 00:29:59.409
the hidden view, nothing works. Auto, you
can see it's scrolling. But it's kind of janky,

00:29:59.409 --> 00:30:06.600
I don't know if you can notice that on the
projector. Compare that to this.

00:30:06.600 --> 00:30:07.840
So this is what you get.
[ Laughter ]

00:30:07.840 --> 00:30:11.740
&gt;&gt;Boris Smus: Thanks, guys, this is what you
get with the WebKit overflowing scrolling

00:30:11.740 --> 00:30:19.200
touch. So on -- on Chrome for Android, this
is the -- basically the smoothness that you

00:30:19.200 --> 00:30:27.960
get, on iOS. You end up with -- with bounceback
effects. And inertial scrolling as well.

00:30:27.960 --> 00:30:35.929
So we'll do questions after.
So as I go into the next section, I'm going

00:30:35.929 --> 00:30:41.600
to preload this.
So in addition to regular transforms, we can

00:30:41.600 --> 00:30:47.690
do more advanced things. As I alluded, we
can do 3D transformations, we can apply perspective

00:30:47.690 --> 00:30:54.659
as well. Even arbitrary matrices, as in this
example here, if you are into linear algebra.

00:30:54.659 --> 00:31:02.470
And we can let CSS interpolate between the
various animation states by using the transition

00:31:02.470 --> 00:31:09.320
property and here we are transitioning between
-- or say -- sorry, we're transitioning the

00:31:09.320 --> 00:31:14.419
transform property, we're specifying its length
of time, one second, and an easing function

00:31:14.419 --> 00:31:23.919
as well. So these -- both the transition and
the transform property need vendor prefixes.

00:31:23.919 --> 00:31:43.109
So unfortunately the demo here is still loading.
But ... I'm gonna ... just gonna hope that

00:31:43.109 --> 00:31:45.889
it will load eventually.
Okay. We'll get back to that. We'll have reason

00:31:45.889 --> 00:31:50.990
to revisit.
So I talked a lot about output here. Let's

00:31:50.990 --> 00:32:00.030
talk about input. So for decades, 20, 30 years,
more, more than that, this has been the input

00:32:00.030 --> 00:32:09.559
mode of computing. Mouse and keyboard. And
for quite a long time, even into mobile, we've

00:32:09.559 --> 00:32:16.230
had very similar input devices. This is a
pretty new Blackberry with keyboard and essentially

00:32:16.230 --> 00:32:24.409
a mouse-like implement.
So the current state is much more interesting.

00:32:24.409 --> 00:32:29.129
Multi-touch pretty much changed the game completely.
And one thing that I want to emphasize here

00:32:29.129 --> 00:32:36.049
is touch is not the same as mouse. It's completely
different. There's no hover state in touch.

00:32:36.049 --> 00:32:41.080
There are multiple touch points. Input is
far less precise. You don't get the pixel

00:32:41.080 --> 00:32:46.879
accuracy of a mouse. And going forward, fingers
aren't just coordinates, but they also have

00:32:46.879 --> 00:32:54.769
shape and in the future we have all sorts
of interesting possibilities. Pressure input,

00:32:54.769 --> 00:33:00.779
haptic feedback, et cetera. Touch interface,
as I'm sure you are all familiar with, have

00:33:00.779 --> 00:33:05.010
essential building blocks. These are very
simple gestures. Well, they range from simple

00:33:05.010 --> 00:33:10.779
ones like tap and double tap to more complex
one like pinch-zoom and rotation and we can

00:33:10.779 --> 00:33:18.010
do all of these things on the Web using the
touch events. So here we have touchmove, touchstart

00:33:18.010 --> 00:33:21.269
and touchend.
These are pretty similar to their mouse equivalents,

00:33:21.269 --> 00:33:28.370
except instead of single coordinates, we have
lists of touches on the screen. There's a

00:33:28.370 --> 00:33:34.230
spec and you can read more about this.
So one of the first things that you'll notice

00:33:34.230 --> 00:33:41.200
is the browser has its own touch behavior.
So like I mentioned earlier, pinch-zoom is

00:33:41.200 --> 00:33:47.549
one of them, scrolling is another, tap switching
as you probably saw in the keynote this morning

00:33:47.549 --> 00:33:52.239
between tabs when you slide out from the side
of the bevel on some browsers and you can

00:33:52.239 --> 00:33:59.019
override some of these behaviors using the
event prevent default call in JavaScript.

00:33:59.019 --> 00:34:05.899
In IE it's a little bit different, you can
specify touch action none, this is IE 10,

00:34:05.899 --> 00:34:11.639
and you can even specify which specific kinds
of interactions to disable. So you can say

00:34:11.639 --> 00:34:19.450
enable no touch interactions by default or
you can say only enable pinch-zooms or only

00:34:19.450 --> 00:34:25.160
enable scrolls.
Touch performance is an interesting topic

00:34:25.160 --> 00:34:32.220
because as a Web developer, if you are not
creating touch specific input, you end up

00:34:32.220 --> 00:34:37.160
having events that are very heavily delayed.
The reason for this is, for example, if you

00:34:37.160 --> 00:34:44.360
do a double tap, the browser needs to decide
if it's a zoom gesture or if it's a click.

00:34:44.360 --> 00:34:49.390
So it waits for 300 milliseconds to wait for
that second tap and then if there's no other

00:34:49.390 --> 00:34:53.640
tap, it emits a click.
So this is not great, 300 milliseconds is

00:34:53.640 --> 00:34:59.370
definitely visible. You can see the delay
and the -- the workaround for this is to use

00:34:59.370 --> 00:35:05.640
touchend. Touchend will fire right away. As
soon as you release your finger from the screen

00:35:05.640 --> 00:35:10.570
and there's a nice guide about this on Google
developer docs.

00:35:10.570 --> 00:35:18.110
The other consideration here is with multi-touch,
events often come in very quickly, much faster

00:35:18.110 --> 00:35:24.350
than 60 frames per second. If you are touching
your screen with many fingers, every single

00:35:24.350 --> 00:35:29.770
finger will fire at whatever that rate is.
And if you draw, as soon as you handle the

00:35:29.770 --> 00:35:36.830
event, you will end up just having too many
things rendering at the same time and this

00:35:36.830 --> 00:35:44.170
will be very bad for your performance.
So the solution for this is to create separate

00:35:44.170 --> 00:35:51.430
handlers for input handling and create a separate
animation thread. Or animation timer in this

00:35:51.430 --> 00:35:54.100
case.
So here I'm doing exactly that. I've got a

00:35:54.100 --> 00:36:01.860
set interval call and the touch rendering
code goes here. We can do even better in Chrome

00:36:01.860 --> 00:36:09.070
for Android and Chrome and Safari and probably
other browsers, we just requestAnimationFrame.

00:36:09.070 --> 00:36:15.950
What this does is it's essentially a polite
request to the browser for animation frame

00:36:15.950 --> 00:36:24.810
so it aims to -- to fire roughly 60 to -- 60
times a second. But if something is overloading

00:36:24.810 --> 00:36:30.191
the -- the machine or the device, then it
scales back in an elegant way and you can

00:36:30.191 --> 00:36:35.980
get as smooth of an animation as you possible
can.

00:36:35.980 --> 00:36:40.320
So with this, let me show you an example of
that.

00:36:40.320 --> 00:36:46.260
Style switch over. The demo is already loaded.
That's awesome!

00:36:46.260 --> 00:36:51.981
So for this particular demo, I'm using a requestAnimationFrame
and the transitions and transforms that I

00:36:51.981 --> 00:37:00.380
talked about earlier, to have this pretty
smooth transition experience between multiple

00:37:00.380 --> 00:37:06.511
screens. So you can see it follows my finger
pretty closely. And when I let go, the transition

00:37:06.511 --> 00:37:14.170
will fire. And the content just shows up.
So this is using requestAnimationFrame WebKit

00:37:14.170 --> 00:37:20.600
transforms and transitions.
I also have another demo that I'm going to

00:37:20.600 --> 00:37:32.180
start loading now.
And I'll get to that in a second as soon as

00:37:32.180 --> 00:37:37.080
it loads.
So let's talk about some of the problems with

00:37:37.080 --> 00:37:44.070
-- with touch input.
The first is how do we handle both gracefully?

00:37:44.070 --> 00:37:51.790
Right? What if we want to support both?
This right now is not very pleasant. So what

00:37:51.790 --> 00:37:58.170
we end up with is two essentially completely
different input methods. Mouse and touch.

00:37:58.170 --> 00:38:04.050
And what we might do is we can extract the
positions of the relevant input. And then

00:38:04.050 --> 00:38:10.610
just relay them to a common handler. This
-- eh ... it's unnecessary boilerplate. It's

00:38:10.610 --> 00:38:16.820
not something that you want to do every single
time. So instead -- well, we'll talk about

00:38:16.820 --> 00:38:21.330
solutions to this in a second.
The other problem before I talk about solutions,

00:38:21.330 --> 00:38:25.820
is gestures are difficult. You saw that list
of gestures that I showed you that are common

00:38:25.820 --> 00:38:32.410
for mobile devices, but doing such a thing
without gesture events, which are only available

00:38:32.410 --> 00:38:40.830
on iOS, is pretty hard. So here's a pinch-zoom
snippet that recognizes the pinch-zoom gesture.

00:38:40.830 --> 00:38:48.140
It's a lot of code. And doing this every time
you want to pinch-zoom just is not reasonable.

00:38:48.140 --> 00:38:59.310
So Microsoft has a -- has an input model that
they're planning on using for metro. It's

00:38:59.310 --> 00:39:06.520
called MSPointer. And the idea is to consolidate
input, to consolidate mouse, touch and pointer

00:39:06.520 --> 00:39:11.640
into one single type.
And, of course, you can still distinguish

00:39:11.640 --> 00:39:18.170
between mouse and touch with -- with an event
property and it's a really nice idea. I like

00:39:18.170 --> 00:39:22.430
it a lot.
The problem is, with the current proposal,

00:39:22.430 --> 00:39:26.370
it's essentially just another input mechanism
to deal with. So now you have the mouse handler,

00:39:26.370 --> 00:39:33.460
the touch handler and the MSPointer handler
and it's just not necessarily great.

00:39:33.460 --> 00:39:39.860
So pointer.js is a project that I worked on
to try to consolidate this input problem between

00:39:39.860 --> 00:39:45.710
browsers. Using a similar idea as MSPointer
events except to take all of these different

00:39:45.710 --> 00:39:52.410
event models and make an abstraction layer
around them to make it really easy for developers.

00:39:52.410 --> 00:40:00.990
So let me show you this in action.
And here I have a -- a space shooter. And

00:40:00.990 --> 00:40:07.160
actually let me show you this on the device
instead. So this is a -- this is a demo that

00:40:07.160 --> 00:40:13.570
was created by a friend of mine called Seb
and you can see it's essentially just a -- a

00:40:13.570 --> 00:40:18.130
space shooter thing demo. It's kind of neat
because you can place your control anywhere

00:40:18.130 --> 00:40:23.240
you want and then just shoot on the -- anywhere
on the right side of the screen.

00:40:23.240 --> 00:40:30.600
So this is using pointerevents. One of the
benefits of this, it was initially using just

00:40:30.600 --> 00:40:37.910
touchevents. So on the desktop nothing would
work at all. With pointerevents, though, I

00:40:37.910 --> 00:40:45.410
can have essentially the same experience in
-- on both mouse and touch input. So this

00:40:45.410 --> 00:40:56.070
is a quick and straightforward pointer example.
Pointer.js also aspires to have gesture recognizers

00:40:56.070 --> 00:41:00.920
on top of the consolidated input model. For
more details about this, check out the project

00:41:00.920 --> 00:41:14.900
page on GitHub.
So let me quickly talk about mobile Web development.

00:41:14.900 --> 00:41:24.750
One second.
So I've been trying to show you some features

00:41:24.750 --> 00:41:32.240
of the Chrome developer tools as we go. And,
of course, the easiest path to getting started

00:41:32.240 --> 00:41:36.960
with mobile development is to emulate it on
the desktop. You don't have to deal with extra

00:41:36.960 --> 00:41:42.570
devices. You don't have any of that headache
of trying to -- having to touch around all

00:41:42.570 --> 00:41:49.280
of the time. So it's nice. And I have shown
you how to emulate screen size, how to override

00:41:49.280 --> 00:41:59.550
the User-Agent string and let me just show
you one more thing ... 

00:41:59.550 --> 00:42:06.430
this is part of the mobile Chrome experiments
that you may or may not have seen. If you

00:42:06.430 --> 00:42:10.530
haven't seen it, check it out, it's on the
second floor in the Chrome booth. So this

00:42:10.530 --> 00:42:17.100
is a Chrome experiment. And it's essentially
a scroll view. With a twist.

00:42:17.100 --> 00:42:21.780
So to show you the twist, I have to scroll,
but you'll notice here that it's using touchevents.

00:42:21.780 --> 00:42:28.830
And when I try to scroll, nothing works. So
let me open up devtools.

00:42:28.830 --> 00:42:35.980
And show you a cool feature that's very useful.
I can emulate touchevents. So what this will

00:42:35.980 --> 00:42:46.080
do, when I reload the page, and switch back
to it, now when I mouse around these mouse

00:42:46.080 --> 00:42:50.850
events are being translated into touches,
so instead of a mouse down I get a touch start,

00:42:50.850 --> 00:42:56.980
et cetera. You can see this is using again
requestAnimationFrame and Hakim here has a

00:42:56.980 --> 00:43:03.490
whole bunch of cool effects to just give you
a sense of how performant you can have these

00:43:03.490 --> 00:43:09.050
nice transitions. On both Chrome and -- it
works just great on Chrome for Android as

00:43:09.050 --> 00:43:15.760
well. You should check it out in the Chrome
experiments booth.

00:43:15.760 --> 00:43:23.220
So that's -- that's some Chrome devtools features.
You can also emulate multi-touch events on

00:43:23.220 --> 00:43:33.150
the Mac. And this is a fun little project
that I worked on. It requires a bit of setup.

00:43:33.150 --> 00:43:39.500
But once you've got it set up, then you can
-- you can essentially create multi-touch

00:43:39.500 --> 00:43:47.740
prototyping, you can do multi-touch prototyping
on any Mac with a magic touch track pad. So

00:43:47.740 --> 00:43:53.190
here you can see I've got a single touch that's
coming from my Mac track pad and I can do

00:43:53.190 --> 00:43:58.290
multiple touches, too.
And I can do this arbitrarily. So it's kind

00:43:58.290 --> 00:44:02.180
of cool if you're doing complex multi-touch
interactions. This game is just like a fruit

00:44:02.180 --> 00:44:06.370
ninja clone that I whipped up, except with
browsers. It doesn't really make sense. You

00:44:06.370 --> 00:44:10.540
hit a blink tag and you get a 406. [Laughter
]

00:44:10.540 --> 00:44:18.930
&gt;&gt;Boris Smus: Right? Anyway, so that's multi-touch.
And, of course, you want to test on your device,

00:44:18.930 --> 00:44:23.540
ultimately. You can do these emulations, you
can use these tricks, but ultimately you need

00:44:23.540 --> 00:44:29.420
to test on your device. And Chrome for Android
has great support for remote debugging, and

00:44:29.420 --> 00:44:33.480
we have plenty of resources about that. In
the interest of time I won't burden you, but

00:44:33.480 --> 00:44:38.040
you should check it out. And I will make these
slides available afterward.

00:44:38.040 --> 00:44:43.800
So thank you all for listening. We've got
some time for questions.

00:44:43.800 --> 00:44:50.440
And, um ... so, yeah, right, we have microphones
on both sides. So feel free to ask anything

00:44:50.440 --> 00:44:57.290
and I'll be available in the Chrome area as
well afterward.

00:44:57.290 --> 00:45:06.860
[ Applause ]
&gt;&gt;&gt; You -- I guess the mic is off. There we

00:45:06.860 --> 00:45:07.860
go.
&gt;&gt;Boris Smus: I think it's on.

00:45:07.860 --> 00:45:13.710
&gt;&gt;&gt; You showed examples of how to get the
GPU hardware acceleration enabled. Why don't

00:45:13.710 --> 00:45:18.580
those turn on by defaults? Why do you have
to play tricks to get it to work reasonably?

00:45:18.580 --> 00:45:27.180
&gt;&gt;Boris Smus: Right, this is -- I agree -- a
problem that we are tackling currently. So

00:45:27.180 --> 00:45:32.760
the Chrome GPU team is working very hard to
try to make these -- to try to make more of

00:45:32.760 --> 00:45:39.931
the rendering part of the GPU pipeline, essentially.
So like you are saying, part of the problem

00:45:39.931 --> 00:45:44.270
is you don't really know which tricks will
render GPU mode, which ones won't, it's very

00:45:44.270 --> 00:45:49.670
implicit. And generally, of course, the whole
rendering path should be done on the GPU as

00:45:49.670 --> 00:45:52.560
much as possible. So GPU team is definitely
looking at this and trying to optimize it

00:45:52.560 --> 00:45:57.600
as much as possible. It's on my radar.
&gt;&gt;&gt; All right.

00:45:57.600 --> 00:46:03.900
&gt;&gt;Boris Smus: Yes, go ahead.
&gt;&gt;&gt; If you are trying to emulate more of a

00:46:03.900 --> 00:46:10.480
mobile native experience, the address bar
gets in the way or -- and is there anything

00:46:10.480 --> 00:46:14.370
more elegant than just scroll one pixel when
your app starts up?

00:46:14.370 --> 00:46:20.700
&gt;&gt;Boris Smus: Um, yeah. So -- right, as you
are saying, the current hacks are around using

00:46:20.700 --> 00:46:26.350
Scroll 2, which is a JavaScript function that
you just call and say scroll to the top and

00:46:26.350 --> 00:46:34.940
in most browsers, in some browsers, it will
hide the location bar. We're working on evaluating

00:46:34.940 --> 00:46:38.690
what a full screen API might look like. So
this is an example of there's an open Web

00:46:38.690 --> 00:46:45.390
API that lets you make a browser go into full-screen
mode. So this would be a nice application.

00:46:45.390 --> 00:46:51.531
That said, right now in Chrome for Android,
we have an Omnibox that's always there. There's

00:46:51.531 --> 00:46:58.640
good reasons for that as well. Just if you
have your URL bar always present, it's an

00:46:58.640 --> 00:47:01.970
indication that you are in the browser, you
are not being phished, you know exactly where

00:47:01.970 --> 00:47:07.890
you are, and it's also very easy to navigate
away, like, to any other page.

00:47:07.890 --> 00:47:16.220
Oftentimes on iOS I'll have hard time getting
back to the URL bar, especially if someone

00:47:16.220 --> 00:47:18.640
is overriding the default scrolling behavior.
&gt;&gt;&gt; I see.

00:47:18.640 --> 00:47:24.550
&gt;&gt;Boris Smus: It's hard to get back. So ... but,
yeah, I agree, it's totally a hack.

00:47:24.550 --> 00:47:27.360
&gt;&gt;&gt; Should be a new GitHub project for you.
Fullscreen.js --

00:47:27.360 --> 00:47:32.470
&gt;&gt;Boris Smus: Thanks. Yes?
&gt;&gt;&gt; I was just wondering, you were always

00:47:32.470 --> 00:47:38.070
saying it's important on iOS and on Chrome
for Android. What about stock browser that

00:47:38.070 --> 00:47:41.650
gets shipped?
&gt;&gt;Boris Smus: Right. So the stock browser

00:47:41.650 --> 00:47:48.350
on Ice Cream Sandwich is actually quite good.
And there's a lot of -- there are many features

00:47:48.350 --> 00:47:56.170
that are supported on it that I discussed
today. Don't quote me, I believe requestAnimationFrame

00:47:56.170 --> 00:48:00.760
maybe. Anyway the inertial scrolling certainly
is.

00:48:00.760 --> 00:48:09.120
So -- yeah. Thanks.
&gt;&gt;&gt; I was curious. So we provide a third-party

00:48:09.120 --> 00:48:15.480
widget that you can embed on your page. So
we don't have control over things like the

00:48:15.480 --> 00:48:20.140
meta tags, some of the stuff that you showed.
I'm kind of curious, we were thinking of using

00:48:20.140 --> 00:48:25.310
the new implementation of position fixed to
allow our chat box to show up.

00:48:25.310 --> 00:48:28.880
&gt;&gt;Boris Smus: Yep.
&gt;&gt;&gt; But you don't get kind of zoom fixed on

00:48:28.880 --> 00:48:33.410
it. So when you zoom in, then like eventually
this position fix thing just takes over the

00:48:33.410 --> 00:48:35.670
whole screen.
&gt;&gt;Boris Smus: Yep.

00:48:35.670 --> 00:48:39.280
&gt;&gt;&gt; Anything new that we could take advantage
of?

00:48:39.280 --> 00:48:43.400
&gt;&gt;Boris Smus: Yeah, it's a good question.
Position fixed is a little interesting if

00:48:43.400 --> 00:48:49.800
you don't have control over the fixed viewport.
Because it -- it actually varies quite a bit

00:48:49.800 --> 00:48:54.740
in its behavior depending on the browser.
So, yeah, I think you have a pretty unique

00:48:54.740 --> 00:49:00.730
case in that you're like a third period JavaScript
plug-in. I can't think of anything off the

00:49:00.730 --> 00:49:05.960
top of my head that you could do that with.
Maybe we should talk offline.

00:49:05.960 --> 00:49:11.500
&gt;&gt;&gt; Sure thing.
&gt;&gt;Boris Smus: Great, thanks. All right? No

00:49:11.500 --> 00:49:15.160
other questions? Find me later, I'll be hanging
out in the Chrome booth.

