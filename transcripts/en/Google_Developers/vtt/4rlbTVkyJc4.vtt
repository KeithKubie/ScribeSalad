WEBVTT
Kind: captions
Language: en

00:00:11.610 --> 00:00:14.610
MALTE UBL: Welcome everybody, to
our talk about How We Make

00:00:14.610 --> 00:00:15.880
JavaScript Widgets Scream.

00:00:15.880 --> 00:00:17.400
My name is Malte.

00:00:17.400 --> 00:00:18.960
JOHN HJELMSTAD: And my name
is John Hjelmstad.

00:00:18.960 --> 00:00:21.130
We're going to be talking a
little bit about the Google+

00:00:21.130 --> 00:00:23.710
widget stack, some of the
extensibility issues that we

00:00:23.710 --> 00:00:27.310
faced during it, and how we have
implemented a number of

00:00:27.310 --> 00:00:29.110
different optimizations for
it to make it much more

00:00:29.110 --> 00:00:29.690
performant.

00:00:29.690 --> 00:00:32.100
Malte will start.

00:00:32.100 --> 00:00:34.230
MALTE UBL: So those are some
of our widgets that we're

00:00:34.230 --> 00:00:35.520
going to talk about.

00:00:35.520 --> 00:00:36.750
You're probably familiar
with them.

00:00:36.750 --> 00:00:39.280
There's the +1 button and
the Share button.

00:00:39.280 --> 00:00:42.720
And they're supposed to go
on developers' site.

00:00:42.720 --> 00:00:45.190
And one of them actually is the
Google Developers site,

00:00:45.190 --> 00:00:46.920
which you probably all know.

00:00:46.920 --> 00:00:49.190
And it's just another site on
the internet, just like you

00:00:49.190 --> 00:00:53.290
guys can put a +1 button
on it, like this one.

00:00:53.290 --> 00:00:56.650
And so we just want to
contextualize it a bit.

00:00:56.650 --> 00:00:57.740
We're software engineers.

00:00:57.740 --> 00:00:59.420
You guys are all software
engineers.

00:00:59.420 --> 00:01:02.580
And we find it important
that the thing is cool

00:01:02.580 --> 00:01:04.709
and fast and awesome.

00:01:04.709 --> 00:01:08.450
So we want to share with you
guys the things we did to make

00:01:08.450 --> 00:01:11.820
it really, really nice,
just to kind of

00:01:11.820 --> 00:01:12.740
contextualize this thing.

00:01:12.740 --> 00:01:16.190
So earlier this year, we
announced that there's over 5

00:01:16.190 --> 00:01:18.570
billion impressions
per day, which we

00:01:18.570 --> 00:01:19.550
think is kind of awesome.

00:01:19.550 --> 00:01:21.800
It's nice to work on
a system like that.

00:01:21.800 --> 00:01:26.340
I didn't actually do the math,
really, but it's a couple

00:01:26.340 --> 00:01:29.530
billion square centimeters
of real estate

00:01:29.530 --> 00:01:31.130
on your sites, right?

00:01:31.130 --> 00:01:36.490
And just imagine, it takes a
second, so that's maybe, like,

00:01:36.490 --> 00:01:40.040
5 billion seconds of load time
to websites across the web.

00:01:40.040 --> 00:01:42.910
Hopefully not, but it could be
like that, so it's kind of an

00:01:42.910 --> 00:01:45.190
important thing.

00:01:45.190 --> 00:01:48.630
And so I just wanted to
talk a little bit,

00:01:48.630 --> 00:01:49.490
like how they work.

00:01:49.490 --> 00:01:52.950
And obviously you guys probably
know this, but just

00:01:52.950 --> 00:01:53.960
from the high level.

00:01:53.960 --> 00:01:57.200
So you start out by putting
some markup on your site.

00:01:57.200 --> 00:01:58.450
Like this &lt;div
class="g-plusone"&gt;.

00:02:00.940 --> 00:02:05.700
And then we go and [? find ?]
this and we create an iframe.

00:02:05.700 --> 00:02:10.870
This iframe displays the actual
widget, and the reason

00:02:10.870 --> 00:02:14.940
why we need it is because first
of all, users are locked

00:02:14.940 --> 00:02:17.610
in and they can click it, and
they get annotations.

00:02:17.610 --> 00:02:21.530
But we don't want the external
site to ever know what person

00:02:21.530 --> 00:02:23.890
that is, because that would
be bad for their privacy.

00:02:23.890 --> 00:02:27.530
The other thing is, we don't
want evil hackers to do

00:02:27.530 --> 00:02:31.360
automated clicks on the widget,
so we do it inside our

00:02:31.360 --> 00:02:34.430
iframe sandbox on a
different domain.

00:02:34.430 --> 00:02:38.030
And hopefully, altogether,
we get some profit.

00:02:38.030 --> 00:02:44.400
So there's one interesting
concept that is important for

00:02:44.400 --> 00:02:46.050
many things in our
talks, and that's

00:02:46.050 --> 00:02:48.000
Bootstrap JavaScript files.

00:02:48.000 --> 00:02:52.180
And so it's this thing
that's under

00:02:52.180 --> 00:02:55.860
apis.google.com/js/plusone.js.

00:02:55.860 --> 00:02:58.090
And it's a tiny file.

00:02:58.090 --> 00:03:00.850
It has a short cache timeout,
which allows us to roll out

00:03:00.850 --> 00:03:02.090
changes really fast.

00:03:02.090 --> 00:03:04.440
And then there's more JavaScript
coming later, and

00:03:04.440 --> 00:03:06.760
this JavaScript might
be kind of big.

00:03:06.760 --> 00:03:08.970
So that's on infinite
cache time.

00:03:08.970 --> 00:03:10.390
This is on short cache time.

00:03:10.390 --> 00:03:12.860
So that's what a Bootstrap
file is.

00:03:12.860 --> 00:03:15.180
It has no relation to the
Twitter Bootstrap project,

00:03:15.180 --> 00:03:17.380
which maybe you guys know.

00:03:17.380 --> 00:03:20.750
It's how I made this slide, on
[? Fire ?] and Web Inspector.

00:03:20.750 --> 00:03:22.580
Anyway.

00:03:22.580 --> 00:03:23.780
But so much for that.

00:03:23.780 --> 00:03:26.380
And now we're going to talk
about performance in general.

00:03:26.380 --> 00:03:27.740
JOHN HJELMSTAD: Yeah, so a
couple words on performance

00:03:27.740 --> 00:03:30.940
that are probably a little bit
obvious but also just give us

00:03:30.940 --> 00:03:33.640
a little bit of a mental
framework for how we conceive

00:03:33.640 --> 00:03:34.990
of widgets overall.

00:03:34.990 --> 00:03:37.720
I mean, it's been said a
thousand times that at Google,

00:03:37.720 --> 00:03:38.650
we're obsessed about speed.

00:03:38.650 --> 00:03:39.860
And there's a reason
that's the case.

00:03:39.860 --> 00:03:43.360
I mean, I think everybody is,
or to some degree, ought to.

00:03:43.360 --> 00:03:45.610
Fast websites are much
more engaging.

00:03:45.610 --> 00:03:47.680
They behave as you anticipate
and expect.

00:03:47.680 --> 00:03:51.600
They're seen as more
professional.

00:03:51.600 --> 00:03:52.930
You get a lot more click-through
and all the

00:03:52.930 --> 00:03:54.950
other good metrics
that you want.

00:03:54.950 --> 00:03:57.940
One thing that we need to
recognize is that if you add

00:03:57.940 --> 00:04:00.210
anything to a page, whether it's
a small div, a little bit

00:04:00.210 --> 00:04:02.670
of text, some JavaScript,
CSS, anything--

00:04:02.670 --> 00:04:04.390
the page will gain weight.

00:04:04.390 --> 00:04:08.200
And so the way that we need to
conceive of this, really, is

00:04:08.200 --> 00:04:10.990
in terms of the social widget
value system, as it were.

00:04:10.990 --> 00:04:13.130
And it's again, fairly
obvious--

00:04:13.130 --> 00:04:15.140
MALTE UBL: Actually, we don't,
but it sounds good.

00:04:15.140 --> 00:04:16.790
JOHN HJELMSTAD: Fair enough.

00:04:16.790 --> 00:04:19.360
But basically, I mean, for
anything that you do--

00:04:19.360 --> 00:04:21.720
and again, fairly
straightforward-- you need to

00:04:21.720 --> 00:04:23.650
make sure that whatever
awesomeness you're adding to

00:04:23.650 --> 00:04:27.270
the page-- the engagement, the
click-through, the ability to

00:04:27.270 --> 00:04:29.010
interact with friends,
whatever--

00:04:29.010 --> 00:04:32.110
needs to be greater in value
than the additional amount of

00:04:32.110 --> 00:04:35.950
time that it takes to make
that happen, which is, of

00:04:35.950 --> 00:04:39.032
course, the overall topic
of conversation.

00:04:39.032 --> 00:04:39.460
MALTE UBL: Yeah.

00:04:39.460 --> 00:04:42.130
Whenever you talk about
performance, it's very, very

00:04:42.130 --> 00:04:44.850
important that measurement
is like the core part.

00:04:44.850 --> 00:04:48.250
So never do anything before you
know you're actually slow.

00:04:48.250 --> 00:04:53.610
And so there's many ways to do
measurements, and one of the

00:04:53.610 --> 00:04:55.590
most important one is the
objective measurements.

00:04:55.590 --> 00:05:00.640
And actually, Google Analytics
provides very nice tools that

00:05:00.640 --> 00:05:03.120
give you info about your
site's performance.

00:05:03.120 --> 00:05:05.370
And you can do custom tracking,
where you say, I

00:05:05.370 --> 00:05:07.900
want to know how fast, in the
real world, it is actually

00:05:07.900 --> 00:05:09.880
from here to there.

00:05:09.880 --> 00:05:12.260
So that gives you real numbers
in the real world, and you can

00:05:12.260 --> 00:05:13.930
tell whether you're
fast or slow.

00:05:13.930 --> 00:05:15.490
And this link--

00:05:15.490 --> 00:05:17.510
I'm going to share the
slides later on--

00:05:17.510 --> 00:05:20.530
points to the page on Google
Analytics that shows you how

00:05:20.530 --> 00:05:21.360
to do this.

00:05:21.360 --> 00:05:22.910
Then there's perceived
performance, which we're going

00:05:22.910 --> 00:05:24.800
to talk about a lot today.

00:05:24.800 --> 00:05:26.760
It's not as easy to measure,
but it's really important.

00:05:26.760 --> 00:05:28.660
So how fast does it seem?

00:05:28.660 --> 00:05:30.570
And you get that through
indirect metrics.

00:05:30.570 --> 00:05:34.410
So if you make your site faster
and your conversion

00:05:34.410 --> 00:05:36.550
rate goes up, that's an indirect
metric of how you

00:05:36.550 --> 00:05:39.920
could see what the impact of
perceived performance is.

00:05:39.920 --> 00:05:42.700
And obviously, you can do things
like ask users and ask

00:05:42.700 --> 00:05:44.580
QA, hey, how does it feel?

00:05:44.580 --> 00:05:47.690
And the last pillar, obviously,
is the raw metal

00:05:47.690 --> 00:05:50.490
benchmarking, which should
be the last thing you do.

00:05:50.490 --> 00:05:53.200
But at some point you want
to know, what am I

00:05:53.200 --> 00:05:53.960
spending time on?

00:05:53.960 --> 00:05:56.700
And you do that with
benchmarking tools and

00:05:56.700 --> 00:05:59.420
profiling tools.

00:05:59.420 --> 00:06:00.570
This is how we do this.

00:06:00.570 --> 00:06:03.660
So the metrics are--

00:06:03.660 --> 00:06:05.120
I just made them up.

00:06:05.120 --> 00:06:06.850
But the actions and
the variable is

00:06:06.850 --> 00:06:07.630
something we track.

00:06:07.630 --> 00:06:10.830
So for the +1 button, there's
this thing called Widget

00:06:10.830 --> 00:06:12.790
Display Time, which we find
really important.

00:06:12.790 --> 00:06:16.380
It's the time from starting to
load until making it to pop up

00:06:16.380 --> 00:06:17.220
on the page.

00:06:17.220 --> 00:06:19.950
And so there's some median

00:06:19.950 --> 00:06:22.570
milliseconds, how long it takes.

00:06:22.570 --> 00:06:26.220
And that's interesting, so
we track this and see

00:06:26.220 --> 00:06:27.480
how we do over time.

00:06:27.480 --> 00:06:29.375
And sometimes, some engineer
has an idea.

00:06:29.375 --> 00:06:30.750
Like, what could you do?

00:06:30.750 --> 00:06:33.050
And that's when we
do experiments.

00:06:33.050 --> 00:06:35.370
Really important.

00:06:35.370 --> 00:06:37.170
Known as basically
A/B testing.

00:06:37.170 --> 00:06:38.410
You can do more variants.

00:06:38.410 --> 00:06:40.600
But what we do is, we have
this awesome idea.

00:06:40.600 --> 00:06:42.620
We implement it, and then we
roll it out to a subset of

00:06:42.620 --> 00:06:46.440
your users and see which of
the ones does better.

00:06:46.440 --> 00:06:47.910
And it's not always--

00:06:47.910 --> 00:06:49.430
sometimes intuition is wrong.

00:06:49.430 --> 00:06:54.070
But these objective measures
will tell you which one is

00:06:54.070 --> 00:06:55.880
better, and then that's
the one you launch

00:06:55.880 --> 00:06:58.290
and that you take.

00:06:58.290 --> 00:07:01.470
One thing that we use all the
time, now that we know we're

00:07:01.470 --> 00:07:03.250
slow, is this Chrome
Timeline View.

00:07:03.250 --> 00:07:05.880
Who knows about this?

00:07:05.880 --> 00:07:07.660
So it's part of the
Chrome dev tools.

00:07:07.660 --> 00:07:10.610
And I think it's not
used very much.

00:07:10.610 --> 00:07:13.750
So you record how your page
loads, and then you have all

00:07:13.750 --> 00:07:14.530
these things.

00:07:14.530 --> 00:07:17.890
Sending a request, CSS
calculations, JavaScript

00:07:17.890 --> 00:07:20.340
evaluation, all those
things are in kind

00:07:20.340 --> 00:07:21.750
of a waterfall graph.

00:07:21.750 --> 00:07:24.960
And that's where we go and see,
hmm, what is this doing?

00:07:24.960 --> 00:07:27.680
Could maybe two things
happen in parallel?

00:07:27.680 --> 00:07:31.040
And so this is the main
tool that you--

00:07:31.040 --> 00:07:35.140
when your site is slow, you want
to use this to see what

00:07:35.140 --> 00:07:37.980
you're spending time on.

00:07:37.980 --> 00:07:39.660
JOHN HJELMSTAD: So what are the
themes that we are trying

00:07:39.660 --> 00:07:42.720
to run through this entire talk
about some of the things

00:07:42.720 --> 00:07:45.460
that we think about when trying
to optimize performance

00:07:45.460 --> 00:07:48.660
and make sure that
we are correct in

00:07:48.660 --> 00:07:49.430
implementing anything.

00:07:49.430 --> 00:07:50.470
So Steve Satter--

00:07:50.470 --> 00:07:53.240
this is somebody that many
people have heard about.

00:07:53.240 --> 00:07:55.320
He works at Google and he's
been, for the past decade or

00:07:55.320 --> 00:07:58.710
so, advocating a number of web
performance best practices.

00:07:58.710 --> 00:08:01.870
Among them, and ones that we
particularly focus on, are, as

00:08:01.870 --> 00:08:04.250
Malte said, measure everything
that you do.

00:08:04.250 --> 00:08:07.800
Make sure that you can reduce as
HTTP requests as possible,

00:08:07.800 --> 00:08:10.660
because they are expensive,
particularly on mobile, but in

00:08:10.660 --> 00:08:13.620
pretty much every environment.

00:08:13.620 --> 00:08:16.920
Maybe even worse when you
have DNS lookups and SSL

00:08:16.920 --> 00:08:17.950
handshakes.

00:08:17.950 --> 00:08:20.220
If you can, do everything
async, which of course,

00:08:20.220 --> 00:08:23.790
actually, to some extent
balances off of performance,

00:08:23.790 --> 00:08:26.010
in that you are by definition
yielding.

00:08:26.010 --> 00:08:29.440
But it's great because you can
take advantage of async

00:08:29.440 --> 00:08:31.630
capabilities in the browser,
of course, to load multiple

00:08:31.630 --> 00:08:33.360
resources in parallel.

00:08:33.360 --> 00:08:35.549
And as well, you're being
essentially nicer to your

00:08:35.549 --> 00:08:38.390
containing context, particularly
in our sense, for

00:08:38.390 --> 00:08:42.799
widgets, in that we yield to
whichever containing page's

00:08:42.799 --> 00:08:44.830
code exists.

00:08:44.830 --> 00:08:46.790
A corollary to that is,
do as much as you

00:08:46.790 --> 00:08:48.810
possibly can in parallel.

00:08:48.810 --> 00:08:51.190
It's a fairly basic tenet, but
if you can load multiple

00:08:51.190 --> 00:08:53.010
resources, do so.

00:08:53.010 --> 00:08:54.650
CSS, JavaScript--

00:08:54.650 --> 00:08:56.790
to the extent that you can
maintain semantics.

00:08:56.790 --> 00:08:59.490
And lastly, Malte talked a
little bit earlier about

00:08:59.490 --> 00:09:00.720
perception.

00:09:00.720 --> 00:09:04.200
That's a much more semantic
concept that we tried to weave

00:09:04.200 --> 00:09:06.830
through our observation in our
analysis of the way that

00:09:06.830 --> 00:09:10.100
widgets work, and it's
very context-specific

00:09:10.100 --> 00:09:11.700
for any given product.

00:09:11.700 --> 00:09:13.260
But the idea being--

00:09:13.260 --> 00:09:16.520
typically, people, of course,
see an application first and

00:09:16.520 --> 00:09:18.610
then later interact with
certain components.

00:09:18.610 --> 00:09:22.300
And you can instrument to
various degrees of specificity

00:09:22.300 --> 00:09:24.320
to find out what's
most likely.

00:09:24.320 --> 00:09:27.160
Is the user more likely to
start searching first?

00:09:27.160 --> 00:09:28.730
So you'd preload that code.

00:09:28.730 --> 00:09:31.210
Hover over this particular
element?

00:09:31.210 --> 00:09:32.790
Preload that code.

00:09:32.790 --> 00:09:34.530
And then deal with some
balances there.

00:09:34.530 --> 00:09:38.630
So just a couple more words
about some of these concepts.

00:09:38.630 --> 00:09:44.600
Reducing HTTP cost is valuable
because it reduces DNS lookups

00:09:44.600 --> 00:09:46.650
cached in the OS
and/or browser.

00:09:46.650 --> 00:09:48.510
Likewise, SSL.

00:09:48.510 --> 00:09:51.250
Some ways to do this, of course,
are to either just

00:09:51.250 --> 00:09:55.390
combine JavaScript libraries
together, combined images

00:09:55.390 --> 00:09:59.010
together using CSS spriting,
or even inline resources.

00:09:59.010 --> 00:10:01.780
Now, there's some balances
there, and we'll be talking

00:10:01.780 --> 00:10:05.670
about that a little bit later,
in that you might reduce

00:10:05.670 --> 00:10:09.240
caching, but at the benefit of
having fewer cache lookups in

00:10:09.240 --> 00:10:11.550
the browser and possibly
cache misses.

00:10:11.550 --> 00:10:14.220
And as well, new-ish
technologies, although they

00:10:14.220 --> 00:10:16.400
are becoming more widely
deployed, such as SPDY in

00:10:16.400 --> 00:10:16.950
particular.

00:10:16.950 --> 00:10:19.060
MHTML is relatively new, too.

00:10:19.060 --> 00:10:22.850
These allow multiple resources
from the same domain, even if

00:10:22.850 --> 00:10:26.330
they're not explicitly combined,
to share the same

00:10:26.330 --> 00:10:28.770
requests underneath the pipe.

00:10:28.770 --> 00:10:30.730
So maximizing parallelization--

00:10:30.730 --> 00:10:32.690
and we just mentioned before.

00:10:32.690 --> 00:10:34.010
Load scripts asynchronously.

00:10:34.010 --> 00:10:35.225
Preload as much as can.

00:10:35.225 --> 00:10:37.600
If you know you're going to be
loading an image at some point

00:10:37.600 --> 00:10:39.775
and it doesn't cost you that
much, asynchronously load in

00:10:39.775 --> 00:10:42.010
the background, you'll have
a cache it right there.

00:10:42.010 --> 00:10:45.310
And in the case of widgets in
particular, I mentioned, we

00:10:45.310 --> 00:10:47.700
always make sure that we play as
nicely as possible with the

00:10:47.700 --> 00:10:48.520
containing page.

00:10:48.520 --> 00:10:49.950
Don't leak symbols.

00:10:49.950 --> 00:10:53.170
Make sure to have an async
embed snippet.

00:10:53.170 --> 00:10:55.680
And load whatever resources
you possibly can

00:10:55.680 --> 00:10:58.690
asynchronously, because
JavaScript, of course, is

00:10:58.690 --> 00:11:02.340
single-threaded and you're going
to essentially block CPU

00:11:02.340 --> 00:11:06.460
compilation and execution
of code while you do so.

00:11:06.460 --> 00:11:08.820
Lastly, I said a couple words on
optimizing for perception,

00:11:08.820 --> 00:11:10.910
so I don't need to go over
that too much again.

00:11:10.910 --> 00:11:12.750
But really just to understand
your product.

00:11:12.750 --> 00:11:15.530
Take a look into what needs to
happen first, what the user

00:11:15.530 --> 00:11:17.710
will perceive as being
really fast.

00:11:17.710 --> 00:11:18.640
And do that first.

00:11:18.640 --> 00:11:21.310
And do whatever else
you can lazily.

00:11:21.310 --> 00:11:24.150
MALTE UBL: So having talked
about the best practices that

00:11:24.150 --> 00:11:27.460
are fundamental to all the
optimizations that we did,

00:11:27.460 --> 00:11:30.140
there was this one thing that
kind of surprised us.

00:11:30.140 --> 00:11:34.980
And going there, it's that
JavaScript compilation is

00:11:34.980 --> 00:11:36.320
really slow.

00:11:36.320 --> 00:11:40.350
And you see all those talks
about JavaScript performance

00:11:40.350 --> 00:11:44.810
and it's going up like crazy,
but many applications actually

00:11:44.810 --> 00:11:47.460
don't do that much JavaScript,
but they load lots of it.

00:11:47.460 --> 00:11:50.560
And so what happens when you
load JavaScript is you have to

00:11:50.560 --> 00:11:53.620
parse it, you have to compile
it, and then you execute it.

00:11:53.620 --> 00:11:57.620
And especially in our case, but
doubt it's too uncommon,

00:11:57.620 --> 00:11:59.690
is that this last
execution part

00:11:59.690 --> 00:12:00.780
isn't really that important.

00:12:00.780 --> 00:12:03.000
Where we spend lots of time
is this first part.

00:12:03.000 --> 00:12:07.100
And just for the ballpark,
roughly one millisecond is

00:12:07.100 --> 00:12:10.230
spent per kilobyte of JavaScript
compilation.

00:12:10.230 --> 00:12:12.790
Might not seem a lot, but
imagine that you have a

00:12:12.790 --> 00:12:15.910
megabyte of JavaScript, which
isn't all that uncommon

00:12:15.910 --> 00:12:18.670
nowadays, especially because
this is the size after

00:12:18.670 --> 00:12:19.680
gzipping, right?

00:12:19.680 --> 00:12:20.980
So not the network size.

00:12:20.980 --> 00:12:23.200
It's the actual size on disk.

00:12:23.200 --> 00:12:26.450
And so that takes a
second to load.

00:12:26.450 --> 00:12:27.810
And it's fully blocking.

00:12:27.810 --> 00:12:30.630
In all currently released
browsers, when you compile

00:12:30.630 --> 00:12:33.470
JavaScript, you do nothing
else in [INAUDIBLE].

00:12:33.470 --> 00:12:35.930
And that's something that we're
going to spend lots of

00:12:35.930 --> 00:12:37.180
time on, this talk.

00:12:39.740 --> 00:12:40.805
John?

00:12:40.805 --> 00:12:42.770
JOHN HJELMSTAD: So let's talk
about how the +1 button is

00:12:42.770 --> 00:12:45.160
actually loaded and some of the
steps associated with it,

00:12:45.160 --> 00:12:48.080
some of the requirements that we
had at the very beginning.

00:12:48.080 --> 00:12:50.030
We'll be the first to admit that
we didn't start out as

00:12:50.030 --> 00:12:51.570
quickly as we really
wanted to.

00:12:51.570 --> 00:12:54.800
And the reason is that we
started out with a six-step

00:12:54.800 --> 00:12:58.390
waterfall, each of which
corresponded to some

00:12:58.390 --> 00:13:02.730
requirement that we had in
making the widget work, which

00:13:02.730 --> 00:13:04.920
extended to all other widgets
after that, too.

00:13:04.920 --> 00:13:07.490
So we diagrammed this here,
and you'll be seeing this

00:13:07.490 --> 00:13:09.900
graph throughout the course
of the discussion.

00:13:09.900 --> 00:13:11.810
So you start with,
as Malte said

00:13:11.810 --> 00:13:15.760
earlier, a Bootstrap script.

00:13:15.760 --> 00:13:18.130
It's responsible for driving
everything else.

00:13:18.130 --> 00:13:20.140
We chose to make it as
simple as possible.

00:13:20.140 --> 00:13:23.000
So there's as few semantics as
possible associated with that

00:13:23.000 --> 00:13:23.980
particular snippet.

00:13:23.980 --> 00:13:25.360
Fewer things to go wrong.

00:13:25.360 --> 00:13:28.020
That, in turn, in order to be
nice, essentially, to our

00:13:28.020 --> 00:13:30.800
containing context, loaded
some JavaScript

00:13:30.800 --> 00:13:33.850
asynchronously, which was
responsible for our parsing

00:13:33.850 --> 00:13:36.820
widget markup, converting it
into iframes, installing event

00:13:36.820 --> 00:13:39.570
handlers for hovers and
confirms, various other

00:13:39.570 --> 00:13:42.110
semantics, which
drew an iframe.

00:13:42.110 --> 00:13:45.000
The iframe is what the
button actually is.

00:13:45.000 --> 00:13:48.520
Internally, it loads the second
half, essentially, the

00:13:48.520 --> 00:13:51.210
in-iframe component of the
cross-domain communication

00:13:51.210 --> 00:13:54.790
libraries for hover and confirm
behavior, click

00:13:54.790 --> 00:13:58.880
behavior, and the like, as
well as CSS imagery and,

00:13:58.880 --> 00:14:02.480
obviously, the HTML that
comprises the button itself.

00:14:02.480 --> 00:14:04.930
And then at the very end is
another interesting step that

00:14:04.930 --> 00:14:07.210
is not totally intuitive.

00:14:07.210 --> 00:14:10.340
We had the button signal
back to its parent to

00:14:10.340 --> 00:14:11.800
say, hey, I'm ready.

00:14:11.800 --> 00:14:13.230
All is well and good.

00:14:13.230 --> 00:14:15.240
And the reason we do that is
that if anything goes wrong--

00:14:15.240 --> 00:14:17.470
there's a network stack issue,
there's something wrong on our

00:14:17.470 --> 00:14:19.350
side, there's a
misconfiguration, anything--

00:14:19.350 --> 00:14:22.950
we don't want essentially for
every page that has +1 buttons

00:14:22.950 --> 00:14:24.420
and others to look
really ugly.

00:14:24.420 --> 00:14:27.510
We would prefer to show nothing
than to show a small

00:14:27.510 --> 00:14:31.670
404, 500, or what have you.

00:14:31.670 --> 00:14:34.790
So from here, we're going to
go on to describing how we

00:14:34.790 --> 00:14:38.210
will take all these
requirements, maintain them,

00:14:38.210 --> 00:14:41.180
optimize for perception, and
make sure that we minimize the

00:14:41.180 --> 00:14:43.740
amount of time associated for
the most important things to

00:14:43.740 --> 00:14:46.300
occur as possible.

00:14:46.300 --> 00:14:49.230
MALTE UBL: Yeah, and the first
thing, which we called "ping,"

00:14:49.230 --> 00:14:53.340
is focusing on this last bit
of the waterfall, and in

00:14:53.340 --> 00:14:56.720
particular, the part that we
call "render via parent,"

00:14:56.720 --> 00:14:58.720
which happens at the very end.

00:14:58.720 --> 00:15:03.010
As John said, it's important
to avoid us

00:15:03.010 --> 00:15:05.270
ever showing bad things.

00:15:05.270 --> 00:15:09.000
So again, we loaded
the iframe.

00:15:09.000 --> 00:15:10.470
Now we know there's
no problem.

00:15:10.470 --> 00:15:11.250
It's all good.

00:15:11.250 --> 00:15:12.320
We can show it.

00:15:12.320 --> 00:15:16.300
Then we load, parse, and compile
lots of JavaScript.

00:15:16.300 --> 00:15:18.630
And then we tell the parent
page to show us.

00:15:18.630 --> 00:15:23.590
Now, it's not really entirely
unobvious that you could kind

00:15:23.590 --> 00:15:27.740
of change this and say, why
don't we tell, when we loaded

00:15:27.740 --> 00:15:31.320
the iframe, the parent page
right away if we now are kind

00:15:31.320 --> 00:15:32.850
of ready to draw.

00:15:32.850 --> 00:15:35.800
And then after that, do the
loading, parsing, and

00:15:35.800 --> 00:15:36.730
compilation.

00:15:36.730 --> 00:15:39.900
So basically giving the
browser the control

00:15:39.900 --> 00:15:41.370
over when to render.

00:15:41.370 --> 00:15:45.990
And that turns out to give
quite a bit of benefit in

00:15:45.990 --> 00:15:48.660
loading, nicely visualized
on here.

00:15:48.660 --> 00:15:51.830
So basically, all this last
part of your waterfall is

00:15:51.830 --> 00:15:56.310
being shaved off the time that
we took for the earlier widget

00:15:56.310 --> 00:15:58.500
display time.

00:15:58.500 --> 00:16:02.930
Going back to the waterfall,
there's still the same steps,

00:16:02.930 --> 00:16:07.860
but the last part kind of
switched around, and now the

00:16:07.860 --> 00:16:10.410
final step, the rendering
via parent, is

00:16:10.410 --> 00:16:12.780
one step up the waterfall.

00:16:12.780 --> 00:16:14.190
JOHN HJELMSTAD: And a quick
corollary to what Malte is

00:16:14.190 --> 00:16:18.290
saying as well, earlier, Malte
describe the widget display

00:16:18.290 --> 00:16:20.320
time metric that we track.

00:16:20.320 --> 00:16:24.290
It's interesting to note that
when we do this exchange of

00:16:24.290 --> 00:16:26.370
when we actually signal to
render via parent, what we're

00:16:26.370 --> 00:16:29.980
really doing is optimizing for
when the widget shows up.

00:16:29.980 --> 00:16:32.590
Now when it's able to receive
full interaction is

00:16:32.590 --> 00:16:34.100
a slight bit later.

00:16:34.100 --> 00:16:36.640
Now the slight bit later really
multiplies, in terms of

00:16:36.640 --> 00:16:39.870
the snappiness and the feel of
the button on the page, and

00:16:39.870 --> 00:16:43.570
it's extremely rare for
people within the--

00:16:43.570 --> 00:16:46.500
[INAUDIBLE] within that
additional savings in metric

00:16:46.500 --> 00:16:50.240
to actually conceive of what the
page is, say I want to +1

00:16:50.240 --> 00:16:52.600
it, annotate it or whatever, get
down there, mouse over it,

00:16:52.600 --> 00:16:53.310
and click it.

00:16:53.310 --> 00:16:55.480
It makes no perceptible
difference, and so the

00:16:55.480 --> 00:16:56.920
trade-off is very much
worth it to us.

00:16:56.920 --> 00:17:02.520
So from there, we took a look at
what it would take actually

00:17:02.520 --> 00:17:04.069
to scale our platform.

00:17:04.069 --> 00:17:06.780
So we've got this one snippet
and we made a conscious

00:17:06.780 --> 00:17:09.510
product decision that when we
wanted to support the + Share

00:17:09.510 --> 00:17:14.800
button, and actually before
that, the Google+ badge, we

00:17:14.800 --> 00:17:16.910
noticed that we were
getting slower.

00:17:16.910 --> 00:17:19.609
And the obvious reason for
that, when you give it a

00:17:19.609 --> 00:17:22.740
little bit of thought, is that
the Bootstrap was dumb.

00:17:22.740 --> 00:17:25.490
All it did was just say, well,
I need to load some code that

00:17:25.490 --> 00:17:31.130
can support +1 and Google+
badge and + Share button.

00:17:31.130 --> 00:17:34.760
So that payload just continued
to get larger and larger, and

00:17:34.760 --> 00:17:38.360
of course, that ends up being
blocking in terms of its

00:17:38.360 --> 00:17:39.480
parsing and compilation.

00:17:39.480 --> 00:17:43.170
One millisecond, in the median,
we found for those

00:17:43.170 --> 00:17:45.790
stages, per kilobyte.

00:17:45.790 --> 00:17:47.940
And so we found that we were
getting slower and slower.

00:17:47.940 --> 00:17:50.710
We really wanted to make sure
that we scale accordingly.

00:17:50.710 --> 00:17:53.880
So we made the Bootstrap
a little bit smarter.

00:17:53.880 --> 00:17:57.940
It's, again, a pretty
straightforward concept.

00:17:57.940 --> 00:18:01.630
In the initial phase, is the JS
payload is responsible for

00:18:01.630 --> 00:18:05.690
parsing the  or &lt;div
class ="g-plusone"&gt;

00:18:05.690 --> 00:18:08.360
or equivalent markup.

00:18:08.360 --> 00:18:10.550
We moved that onto
the bottled.

00:18:10.550 --> 00:18:12.810
And we made a sporadic decision
as well to make all

00:18:12.810 --> 00:18:15.740
markup look, template-wise,
exactly the same.

00:18:15.740 --> 00:18:17.650
It's either a  or
.

00:18:20.240 --> 00:18:24.650
So the code associated with
that is extremely stable,

00:18:24.650 --> 00:18:27.360
which is an important benefit.

00:18:27.360 --> 00:18:30.790
And B, it's extremely small
and compact to write.

00:18:30.790 --> 00:18:34.150
And so at this point, the
bootloader simply just finds

00:18:34.150 --> 00:18:35.000
whatever's on the page.

00:18:35.000 --> 00:18:39.450
It says, I found a +1 button
only, or + Share button only.

00:18:39.450 --> 00:18:41.670
I'm just going to load what's
necessary for that, thereby

00:18:41.670 --> 00:18:45.660
making the JS payload necessary
to work with it that

00:18:45.660 --> 00:18:46.910
much smaller.

00:18:49.010 --> 00:18:53.490
MALTE UBL: Yeah. and this was
not our most exciting part of

00:18:53.490 --> 00:18:55.890
the presentation, because
the waterfall still

00:18:55.890 --> 00:18:57.280
looks kind of the same.

00:18:57.280 --> 00:18:59.530
But now we go into the next
optimization, which kind of

00:18:59.530 --> 00:19:01.300
fell out of the last one.

00:19:01.300 --> 00:19:03.310
And we call that Bootstrap
rendering.

00:19:03.310 --> 00:19:06.020
And now we focus on those
first three parts of the

00:19:06.020 --> 00:19:06.960
waterfall--

00:19:06.960 --> 00:19:11.360
the Bootstrap, the JS
payload, the iframe.

00:19:11.360 --> 00:19:14.990
So going back to that picture,
we load the Bootstrap, load

00:19:14.990 --> 00:19:19.520
the payload, load the
iframe, show it.

00:19:19.520 --> 00:19:23.380
Now we added the logic to kind
of discover those tags that

00:19:23.380 --> 00:19:27.110
signal which widgets are on
a page to the Bootstrap.

00:19:27.110 --> 00:19:29.870
And then we had the
brilliant idea--

00:19:29.870 --> 00:19:32.710
why don't we teach the Bootstrap
to actually inject

00:19:32.710 --> 00:19:34.250
the iframes?

00:19:34.250 --> 00:19:37.360
It wasn't that easy, because
weird URLS had to be

00:19:37.360 --> 00:19:41.070
constructed, so we had to do
quite some work to make our

00:19:41.070 --> 00:19:42.740
platform more uniform.

00:19:42.740 --> 00:19:47.180
But this has a quite big
impact on the thing.

00:19:47.180 --> 00:19:48.950
And I want to show this here.

00:19:48.950 --> 00:19:54.250
Basically, we always had this
JS loading, but it's now no

00:19:54.250 --> 00:19:55.770
longer on the critical path.

00:19:55.770 --> 00:19:59.220
So the Bootstrap goes and loads
the widget iframe, and

00:19:59.220 --> 00:20:01.480
as soon as that's there,
we can be shown.

00:20:01.480 --> 00:20:05.440
And it's no longer strictly
bound to the JS

00:20:05.440 --> 00:20:06.180
on the other page.

00:20:06.180 --> 00:20:11.490
And especially, it doesn't wait
for that to load to load

00:20:11.490 --> 00:20:12.740
the widget.

00:20:14.750 --> 00:20:16.630
Really, really big win.

00:20:16.630 --> 00:20:21.830
Looking here, the waterfall
starts to get smaller.

00:20:21.830 --> 00:20:25.700
So there used to be those two
things, and now the JavaScript

00:20:25.700 --> 00:20:27.520
payload is completely
eliminated from

00:20:27.520 --> 00:20:28.940
the critical path.

00:20:28.940 --> 00:20:35.650
And that's quite a big
difference from before.

00:20:35.650 --> 00:20:36.100
JOHN HJELMSTAD: Definitely.

00:20:36.100 --> 00:20:38.440
And it's still worth noting,
going back to the theme I

00:20:38.440 --> 00:20:39.910
actually mentioned with respect
to Ping, that what

00:20:39.910 --> 00:20:44.990
we're doing again is making the
observation that seeing it

00:20:44.990 --> 00:20:48.030
is done in order of magnitude,
and in fact, many orders of

00:20:48.030 --> 00:20:50.710
magnitude, to no surprise in our
particular case-- and of

00:20:50.710 --> 00:20:54.170
course, like I said before,
every product is semantic.

00:20:54.170 --> 00:20:56.820
You need to know how it's
interacted with.

00:20:56.820 --> 00:21:00.100
You see a button and have to
really cohere what it does

00:21:00.100 --> 00:21:01.330
before you actually
interact with it.

00:21:01.330 --> 00:21:03.940
So when we implemented this,
we made sure to add

00:21:03.940 --> 00:21:06.830
instrumentation to know exactly
how long it takes

00:21:06.830 --> 00:21:09.270
until the full suite of
interaction is possible.

00:21:09.270 --> 00:21:12.110
Because we're still loading
that JavaScript payload

00:21:12.110 --> 00:21:13.650
asynchronously to make sure that
when you hover over the

00:21:13.650 --> 00:21:19.070
button, you get the possible
Share box or the confirmation

00:21:19.070 --> 00:21:20.710
dialog, and all that
sort of stuff.

00:21:20.710 --> 00:21:25.290
And so from here, we moved on
inside the iframe, and took

00:21:25.290 --> 00:21:30.315
note, as yet another corollary,
that not all +1

00:21:30.315 --> 00:21:33.780
buttons, Share buttons, or
Google+ badges actually get

00:21:33.780 --> 00:21:35.540
any interaction.

00:21:35.540 --> 00:21:37.420
But they still provide a
tremendous amount of value.

00:21:37.420 --> 00:21:40.450
A button says eight
people +1'd it.

00:21:40.450 --> 00:21:44.310
Perhaps there's an annotation
that shows you which of your

00:21:44.310 --> 00:21:45.560
friends happened to do so.

00:21:45.560 --> 00:21:47.240
That has value on its own.

00:21:47.240 --> 00:21:49.840
But if you never interact with
it, why are you even doing the

00:21:49.840 --> 00:21:51.130
cross-domain communication?

00:21:51.130 --> 00:21:53.600
Why are you actually parsing and
compiling, in particular,

00:21:53.600 --> 00:21:55.520
the JavaScript inside
the button?

00:21:55.520 --> 00:21:57.120
So this is an interesting
technique that can be

00:21:57.120 --> 00:21:59.640
generalized in situations in
which this is the case.

00:21:59.640 --> 00:22:02.560
And we call it "lazy JS
evaluation." We wait until a

00:22:02.560 --> 00:22:05.300
signal of intent comes from
the user in the form of a

00:22:05.300 --> 00:22:09.720
mouseover, or a touchstart on
mobile devices, and the like,

00:22:09.720 --> 00:22:12.770
that we actually need to
evaluate JavaScript.

00:22:12.770 --> 00:22:17.310
So before, our chart
looks as described.

00:22:17.310 --> 00:22:18.180
We're loading the widget.

00:22:18.180 --> 00:22:19.540
Inside, it's got
a bunch of JS.

00:22:19.540 --> 00:22:22.420
And that JS just immediately
is parsed and compiled.

00:22:22.420 --> 00:22:25.170
This adds nontrivial cost to
the browser in that it's

00:22:25.170 --> 00:22:28.320
blocking whatever else is going
on that particular time.

00:22:28.320 --> 00:22:30.560
Afterwards we signal
to show the widget.

00:22:30.560 --> 00:22:33.290
What we taught the
code to do is

00:22:33.290 --> 00:22:35.590
represented by this snippet.

00:22:35.590 --> 00:22:38.160
This is not our exact code,
but it really does get--

00:22:38.160 --> 00:22:39.640
MALTE UBL: We don't use
jQuery, but this is

00:22:39.640 --> 00:22:40.420
pseudo-jQuery.

00:22:40.420 --> 00:22:40.850
JOHN HJELMSTAD: Yes.

00:22:40.850 --> 00:22:44.070
But it does get at the nature of
what it is that we're doing

00:22:44.070 --> 00:22:46.430
within the buttons.

00:22:46.430 --> 00:22:48.450
So we're loading some JS inside
of it, represented here

00:22:48.450 --> 00:22:49.970
by /some/file.

00:22:49.970 --> 00:22:54.200
And basically we say, hey, load
this as a string via XHR,

00:22:54.200 --> 00:22:58.900
and only once that string is
loaded do we, on window, bind

00:22:58.900 --> 00:23:01.790
these various events in the
capture phase on the top-most

00:23:01.790 --> 00:23:03.800
element, which is, of
course, window.

00:23:03.800 --> 00:23:07.150
And we say, on mouseover,
touchstart, keydown--

00:23:07.150 --> 00:23:09.680
and click, actually, just
to be complete--

00:23:09.680 --> 00:23:11.910
only then should you
synchronously evaluate

00:23:11.910 --> 00:23:12.890
JavaScript.

00:23:12.890 --> 00:23:17.690
And it turns out that because we
are capturing these events

00:23:17.690 --> 00:23:20.100
at the top-most element and
then they bubble down, and

00:23:20.100 --> 00:23:22.780
we're evaluating the code
synchronously, we only

00:23:22.780 --> 00:23:27.890
actually parse and compile,
via eval, and evaluate the

00:23:27.890 --> 00:23:29.120
code at that time.

00:23:29.120 --> 00:23:32.900
It turns out to be pretty
notable win, and this is

00:23:32.900 --> 00:23:36.020
especially true in situations
in which you

00:23:36.020 --> 00:23:36.850
have multiple widgets.

00:23:36.850 --> 00:23:39.540
But we found, to our surprise,
it's true when you have only

00:23:39.540 --> 00:23:43.510
one on the page, because you're
being nicer to the page

00:23:43.510 --> 00:23:46.920
context, whatever it might
happen to be, and you're

00:23:46.920 --> 00:23:50.570
scaling a lot better with
respect to your widget itself.

00:23:50.570 --> 00:23:53.140
So here, we have the
description of

00:23:53.140 --> 00:23:54.270
kind of what's happening.

00:23:54.270 --> 00:23:55.930
It becomes much more conditional
and there's some

00:23:55.930 --> 00:23:56.820
complexity added here.

00:23:56.820 --> 00:23:58.900
Malte will talk about that
in a little bit.

00:23:58.900 --> 00:24:02.225
Maybe you parse and compile the
JS, but if you don't, you

00:24:02.225 --> 00:24:03.470
know you didn't need to.

00:24:03.470 --> 00:24:05.120
There was never any interaction
in the first

00:24:05.120 --> 00:24:08.390
place, which we found to be more
surprisingly beneficial

00:24:08.390 --> 00:24:09.580
than you might even expect.

00:24:09.580 --> 00:24:11.870
And like I said, it scales
extremely well.

00:24:11.870 --> 00:24:14.250
You could have hundreds of +1
buttons on the page, and they

00:24:14.250 --> 00:24:17.305
don't take up hundreds of
parse-and-compile cycles in

00:24:17.305 --> 00:24:20.366
the browser, irrespective of
what JS engine happens to be

00:24:20.366 --> 00:24:21.260
running them.

00:24:21.260 --> 00:24:25.055
So afterwards, you don't even
have the parse and compile in

00:24:25.055 --> 00:24:26.550
the majority case.

00:24:26.550 --> 00:24:30.460
Again, that's specific to
widgets, but it could apply to

00:24:30.460 --> 00:24:32.030
quite a few other applications
as well.

00:24:32.030 --> 00:24:35.300
MALTE UBL: One thing to note
here is that previously, when

00:24:35.300 --> 00:24:38.180
you had lots of +1 buttons on a
page, they could get really

00:24:38.180 --> 00:24:39.590
slow and could use
lots of memory.

00:24:39.590 --> 00:24:41.730
So this saves on that.

00:24:41.730 --> 00:24:43.330
It's still kind of hard--

00:24:43.330 --> 00:24:46.910
if you put a hundred iframes on
a single page, the browsers

00:24:46.910 --> 00:24:48.710
still don't like that because
they allocate

00:24:48.710 --> 00:24:50.100
quite a bit of memory.

00:24:50.100 --> 00:24:52.830
But one example would be Google
Reader, where you

00:24:52.830 --> 00:24:55.510
scroll down and it constantly,
as content

00:24:55.510 --> 00:24:57.280
comes in, adds +1 buttons.

00:24:57.280 --> 00:25:01.650
So these pages really gain
from this optimization,

00:25:01.650 --> 00:25:04.810
because the frame rate doesn't
drop while JavaScript is being

00:25:04.810 --> 00:25:07.010
compiled as the widgets
come into view.

00:25:10.290 --> 00:25:14.360
Now, we move on to an
optimization which isn't as

00:25:14.360 --> 00:25:18.230
important for the request flow,
but which is kind of

00:25:18.230 --> 00:25:20.360
interesting and we still
wanted to mention it.

00:25:20.360 --> 00:25:22.440
And it's for the case where you
have lots of widgets on a

00:25:22.440 --> 00:25:25.420
page and they might get quite
a lot of interaction.

00:25:25.420 --> 00:25:28.960
And in that case, they still
have all their own JavaScript

00:25:28.960 --> 00:25:30.490
because they're independent.

00:25:30.490 --> 00:25:35.110
And so we came up with a
technique that we call

00:25:35.110 --> 00:25:39.570
code-sharing that kind of makes
lots of widgets on a

00:25:39.570 --> 00:25:42.870
page be able to share
the same code.

00:25:42.870 --> 00:25:46.270
So I mentioned this
page, which I made

00:25:46.270 --> 00:25:47.520
using copy and paste.

00:25:50.370 --> 00:25:53.530
So it has 112 iframes.

00:25:53.530 --> 00:25:56.550
At some point, we actually
loaded two JavaScript files on

00:25:56.550 --> 00:26:01.556
each iframe, so that's 224 JS
requests, which is kind of

00:26:01.556 --> 00:26:03.330
suboptimal.

00:26:03.330 --> 00:26:09.420
So we changed it to a
different technique.

00:26:09.420 --> 00:26:11.480
But what this does--

00:26:11.480 --> 00:26:13.970
the first widget loads,
parses, and compiles

00:26:13.970 --> 00:26:16.330
JavaScript and it executes it.

00:26:16.330 --> 00:26:18.580
The second widget comes in,
loads, parses, and compiles

00:26:18.580 --> 00:26:20.530
JavaScript and executes it.

00:26:20.530 --> 00:26:22.640
Kind of not cool.

00:26:22.640 --> 00:26:26.860
So we came up with the 113th
iframe, kind of this shared

00:26:26.860 --> 00:26:27.810
loader iframe.

00:26:27.810 --> 00:26:31.060
So every time you would go a
widget, it loads this second

00:26:31.060 --> 00:26:34.060
hidden iframe that's actually
responsible for providing the

00:26:34.060 --> 00:26:35.010
JavaScript.

00:26:35.010 --> 00:26:40.960
And so we have widget 1 and
widget 2, and they both take

00:26:40.960 --> 00:26:46.340
their sources from
the same iframe.

00:26:46.340 --> 00:26:48.760
Now, there's many ways
to implement this.

00:26:48.760 --> 00:26:52.080
And it's actually quite a common
technique at Google.

00:26:52.080 --> 00:26:56.270
We created a way that's actually
quite interesting

00:26:56.270 --> 00:27:00.020
also for all you guys, because
it's generalizable to every

00:27:00.020 --> 00:27:00.870
piece of JavaScript.

00:27:00.870 --> 00:27:02.770
And I'm going to show
how it works.

00:27:02.770 --> 00:27:04.920
So this is some random
JavaScript.

00:27:04.920 --> 00:27:10.000
var d = "none" and then
document.getElementById,

00:27:10.000 --> 00:27:11.350
querySelector and
style.display.

00:27:11.350 --> 00:27:12.950
So don't worry about it.

00:27:12.950 --> 00:27:14.750
Random JavaScript.

00:27:14.750 --> 00:27:19.020
So who's a JavaScript expert?

00:27:19.020 --> 00:27:20.860
All right.

00:27:20.860 --> 00:27:22.240
I'm going do a transformation.

00:27:22.240 --> 00:27:23.860
I'm going to add window.

00:27:23.860 --> 00:27:27.140
in front of the perceived global
variable document.

00:27:27.140 --> 00:27:29.480
So JavaScript in the
browser doesn't

00:27:29.480 --> 00:27:32.040
actually have double variables.

00:27:32.040 --> 00:27:33.940
At least, they're not
as important.

00:27:33.940 --> 00:27:37.440
They're all actually properties
of window.

00:27:37.440 --> 00:27:41.720
So you can go through a
JavaScript file and find all

00:27:41.720 --> 00:27:44.000
the references to global
variables,

00:27:44.000 --> 00:27:46.360
and then prefix window..

00:27:46.360 --> 00:27:48.050
Does it make sense?

00:27:48.050 --> 00:27:50.780
Kind of, right?

00:27:50.780 --> 00:27:54.130
So window isn't actually
a magic variable.

00:27:54.130 --> 00:27:56.780
You can wrap your script
in a function--

00:27:56.780 --> 00:27:58.270
I call it javaScriptCallback--

00:27:58.270 --> 00:28:00.890
and provide window as
a local variable.

00:28:00.890 --> 00:28:08.540
So now, suddenly, your file has
become this thing that can

00:28:08.540 --> 00:28:09.990
get a window injected.

00:28:09.990 --> 00:28:13.020
So you can use the same
JavaScript that you only parse

00:28:13.020 --> 00:28:15.770
and compile once and apply
it to different scopes.

00:28:15.770 --> 00:28:17.640
And that's what's being
done down here.

00:28:17.640 --> 00:28:20.880
So javaScriptCallback is being
called twice, once with the

00:28:20.880 --> 00:28:23.180
iframe1 and once with
the iframe2.

00:28:23.180 --> 00:28:26.690
So what this does-- it takes
any concealed bit of

00:28:26.690 --> 00:28:30.590
JavaScript that you could come
up with and transforms it into

00:28:30.590 --> 00:28:34.040
a form that can be applied
to as many window

00:28:34.040 --> 00:28:35.380
contexts as you want.

00:28:35.380 --> 00:28:38.150
So there's nothing that a
programmer has to do.

00:28:38.150 --> 00:28:39.760
It works with all JavaScript.

00:28:39.760 --> 00:28:45.210
Now, this is implemented in
Closure Compiler, which is an

00:28:45.210 --> 00:28:48.150
open-source project release
for Google.

00:28:48.150 --> 00:28:50.210
So there's no manual
transformation involved.

00:28:50.210 --> 00:28:52.270
Nobody has to write window.

00:28:52.270 --> 00:28:53.680
and can never forget it.

00:28:53.680 --> 00:28:56.080
It's just being done
automatically to every single

00:28:56.080 --> 00:28:57.510
global variable.

00:28:57.510 --> 00:29:00.430
Notably except window itself.

00:29:00.430 --> 00:29:02.010
Anyway.

00:29:02.010 --> 00:29:05.010
So what this does, essentially,
is still, for the

00:29:05.010 --> 00:29:07.290
first widget, it says, you
know, I kind of need this

00:29:07.290 --> 00:29:10.300
file, and it's being loaded, and
you parse and compile it

00:29:10.300 --> 00:29:11.230
and you execute it.

00:29:11.230 --> 00:29:16.130
But the second widget, when it
wants the same JavaScript, all

00:29:16.130 --> 00:29:19.130
this parsing and compilation
phase is not being needed

00:29:19.130 --> 00:29:20.340
because you already have it.

00:29:20.340 --> 00:29:22.380
And you just apply the same
JavaScript-- boom--

00:29:22.380 --> 00:29:27.130
to the second window, which,
again, and similar to the lazy

00:29:27.130 --> 00:29:32.745
JS optimization, considerably
minimizes the weight that you

00:29:32.745 --> 00:29:37.840
get as widgets are being added
to the page, which, again, is

00:29:37.840 --> 00:29:40.370
kind of a win.

00:29:40.370 --> 00:29:42.920
Dorky.

00:29:42.920 --> 00:29:43.360
Yeah.

00:29:43.360 --> 00:29:44.870
And that was that.

00:29:44.870 --> 00:29:46.560
Now we'll move on
to CSS inlining.

00:29:46.560 --> 00:29:50.050
JOHN HJELMSTAD: Yeah, as a quick
aside, actually somewhat

00:29:50.050 --> 00:29:52.490
related to the transformation
Malte's describing with

00:29:52.490 --> 00:29:58.350
respect to circumscribing all
global references under

00:29:58.350 --> 00:30:00.930
window, there's another
compiler pass--

00:30:00.930 --> 00:30:01.630
just if you happen to be

00:30:01.630 --> 00:30:03.490
interested in Closure Compiler--

00:30:03.490 --> 00:30:08.186
that rescopes all implicit
global variables, like var(X)

00:30:08.186 --> 00:30:11.100
= 1, to a namespace.

00:30:11.100 --> 00:30:13.670
We use that to avoid polluting
the namespace space of the

00:30:13.670 --> 00:30:14.720
containing page that
you're on.

00:30:14.720 --> 00:30:15.530
It's called--

00:30:15.530 --> 00:30:17.070
do you remember what?

00:30:17.070 --> 00:30:18.370
MALTE UBL: Rescope
Global Symbols.

00:30:18.370 --> 00:30:18.680
JOHN HJELMSTAD: Right.

00:30:18.680 --> 00:30:21.000
For anybody interested, look
for Rescope Global Symbols

00:30:21.000 --> 00:30:21.800
under Closure Compiler.

00:30:21.800 --> 00:30:25.310
It's an interesting technique
if you have the issue of

00:30:25.310 --> 00:30:27.110
accidentally adding way
too many symbols

00:30:27.110 --> 00:30:29.950
to the global namespace.

00:30:29.950 --> 00:30:33.540
So from there, we are pivoting
to our last optimization that

00:30:33.540 --> 00:30:35.500
we're going to be talking about
today, which again, is

00:30:35.500 --> 00:30:36.780
within the iframe.

00:30:36.780 --> 00:30:39.650
And this one is more of a pure
experiment, and we haven't

00:30:39.650 --> 00:30:41.450
actually fully rolled it
out nor figured out the

00:30:41.450 --> 00:30:43.680
particulars of when
it's most optimal.

00:30:43.680 --> 00:30:46.460
But it's an interesting one
because it involves a number

00:30:46.460 --> 00:30:46.840
of tradeoffs.

00:30:46.840 --> 00:30:50.490
And I mentioned at the beginning
of the talk that

00:30:50.490 --> 00:30:53.330
reducing the number of HTTP
round-trip or HTTPS

00:30:53.330 --> 00:30:56.110
round-trips is incredibly
important.

00:30:56.110 --> 00:30:58.600
In our case, we've got a
small amount of CSS.

00:30:58.600 --> 00:31:01.050
It's about 2 kilobytes or so.

00:31:01.050 --> 00:31:04.680
It references some sprites, but
it doesn't do a whole lot.

00:31:04.680 --> 00:31:09.350
And we noticed a growing body
of suggestion literature on

00:31:09.350 --> 00:31:12.370
the web and blog posts
suggesting, particularly if

00:31:12.370 --> 00:31:15.070
you have a small CSS
file, it might be

00:31:15.070 --> 00:31:16.260
beneficial to inline it.

00:31:16.260 --> 00:31:17.770
So we're starting to experiment
with that, and we

00:31:17.770 --> 00:31:20.680
actually have founder early
results that it, in fact, is.

00:31:20.680 --> 00:31:24.950
Now, this is a classic tradeoff,
as mentioned before.

00:31:24.950 --> 00:31:27.510
And so one of the big tradeoffs
is the fact that

00:31:27.510 --> 00:31:32.170
you, if you get a low cache hit
rate, you're using more

00:31:32.170 --> 00:31:34.900
network bandwidth and you're
getting essentially,

00:31:34.900 --> 00:31:40.790
obviously, a lower hit rate by
definition in the browser.

00:31:40.790 --> 00:31:43.800
In our particular case, we have
N billion impressions for

00:31:43.800 --> 00:31:46.770
+1 buttons and the various
others per day.

00:31:46.770 --> 00:31:49.900
And it seems like only 2
kilobytes of CSS, but it turns

00:31:49.900 --> 00:31:52.760
out to translate to
2 Terabytes a day.

00:31:52.760 --> 00:31:55.340
So it's particularly relevant to
us to figure out the right

00:31:55.340 --> 00:31:56.050
variables here.

00:31:56.050 --> 00:31:58.080
Now, the tradeoffs
are described

00:31:58.080 --> 00:31:59.540
right here pretty easily.

00:31:59.540 --> 00:32:01.620
And it's pretty classic, and
this applies to just about any

00:32:01.620 --> 00:32:03.470
resource you'd like to inline.

00:32:03.470 --> 00:32:05.830
But inlining itself, obviously
bad for caching.

00:32:05.830 --> 00:32:09.710
If you have a great cache
hit rate, and our CSS is

00:32:09.710 --> 00:32:10.760
infinitely cached.

00:32:10.760 --> 00:32:14.125
You'd expect, somebody goes to
a page with a +1 button or +

00:32:14.125 --> 00:32:16.310
Share, they go to another
one, boom.

00:32:16.310 --> 00:32:17.170
It's already going
to be there.

00:32:17.170 --> 00:32:19.530
Why would you cost
the additional

00:32:19.530 --> 00:32:22.330
2kb on the next request?

00:32:22.330 --> 00:32:25.260
Well, the reason is that you
guaranteed that there are

00:32:25.260 --> 00:32:28.060
fewer HTTP requests in the cases
where you've got a poor

00:32:28.060 --> 00:32:28.490
cache hit rate.

00:32:28.490 --> 00:32:32.000
And we noticed, anecdotally,
that the hit rate is

00:32:32.000 --> 00:32:33.430
particularly bad.

00:32:33.430 --> 00:32:35.820
And we suspect that this
is particularly

00:32:35.820 --> 00:32:36.670
suboptimal on mobile.

00:32:36.670 --> 00:32:37.980
So it's something to
experiment with.

00:32:37.980 --> 00:32:40.250
And the reasons for that
being the case on

00:32:40.250 --> 00:32:41.950
mobile are fairly obvious.

00:32:41.950 --> 00:32:46.760
Smaller devices, smaller caches,
various different

00:32:46.760 --> 00:32:50.400
policies in effect on
different browsers.

00:32:50.400 --> 00:32:53.360
But the good news about it is
that you end up, again, with a

00:32:53.360 --> 00:32:54.980
definitional shorter
waterfall.

00:32:54.980 --> 00:32:58.940
So who knows exactly
if it's a win?

00:32:58.940 --> 00:33:02.590
But like I say, in the mean,
we have found it to be so,

00:33:02.590 --> 00:33:05.540
particularly in pages where
there's only one +1

00:33:05.540 --> 00:33:06.250
button on the page.

00:33:06.250 --> 00:33:08.410
You know that you're at least
not sharing that same resource

00:33:08.410 --> 00:33:10.510
across multiple on the page.

00:33:10.510 --> 00:33:13.380
So it's an interesting one, and
I'd suggest people look

00:33:13.380 --> 00:33:16.810
online, literally just CSS
inlining and various other

00:33:16.810 --> 00:33:19.490
related searches to find
out the particulars.

00:33:19.490 --> 00:33:22.560
But in our particular case, we
found that because we will

00:33:22.560 --> 00:33:25.010
never be blocking on
that HTTP request--

00:33:25.010 --> 00:33:27.480
very expensive on mobile as well
as more likely to occur

00:33:27.480 --> 00:33:29.360
on mobile--

00:33:29.360 --> 00:33:33.100
that it results in an overall
win in terms of performance

00:33:33.100 --> 00:33:34.450
for our platform.

00:33:34.450 --> 00:33:36.590
So in the end, we end up having

00:33:36.590 --> 00:33:39.080
pretty much this waterfall.

00:33:39.080 --> 00:33:40.420
We've got the Bootstrap.

00:33:40.420 --> 00:33:42.460
It plops an iframe onto the
page and that iframe has a

00:33:42.460 --> 00:33:45.010
tiny bit of inline CSS
that says, render me

00:33:45.010 --> 00:33:46.130
because I know I'm safe.

00:33:46.130 --> 00:33:48.720
The iframe itself
has CSS inlined.

00:33:48.720 --> 00:33:51.520
It doesn't currently have the
image inline, but that's yet

00:33:51.520 --> 00:33:54.030
another thing that you can do by
spriting and inlining that,

00:33:54.030 --> 00:33:57.060
and we'll have to figure that
one out at some point.

00:33:57.060 --> 00:34:00.750
And in about as short a time
as possible, given our

00:34:00.750 --> 00:34:05.370
requirement to have a very
simple integration snippet,

00:34:05.370 --> 00:34:06.760
you end up seeing the button.

00:34:06.760 --> 00:34:08.159
And we're fairly happy
about that.

00:34:08.159 --> 00:34:09.620
We've seen notable win.

00:34:09.620 --> 00:34:12.920
And we, again, have
instrumentation that shows

00:34:12.920 --> 00:34:16.100
that the amount of delay
introduced, in terms of the

00:34:16.100 --> 00:34:18.690
tradeoff, in terms of
interaction, has not affected

00:34:18.690 --> 00:34:19.900
any of our additional metrics.

00:34:19.900 --> 00:34:21.100
So that's particularly
salient.

00:34:21.100 --> 00:34:23.449
So just to review--

00:34:23.449 --> 00:34:24.650
this is where we started.

00:34:24.650 --> 00:34:26.190
We had six stages.

00:34:26.190 --> 00:34:28.840
And it's interesting to kind
of walk through them one by

00:34:28.840 --> 00:34:31.989
one, as we have, and point out
how some of them are really

00:34:31.989 --> 00:34:36.199
not specifically required
upon further analysis.

00:34:36.199 --> 00:34:41.659
So it really, really does
shorten things quite a lot.

00:34:41.659 --> 00:34:44.060
MALTE UBL: So coming
full circle.

00:34:44.060 --> 00:34:48.409
So we showed you, basically
opened our books, what we

00:34:48.409 --> 00:34:52.429
spent our last, basically, year
on, how we optimized the

00:34:52.429 --> 00:34:55.260
load speed of the +1 button in
particular, and all the other

00:34:55.260 --> 00:34:59.790
widgets as kind of a second
effect of the same

00:34:59.790 --> 00:35:00.850
optimization.

00:35:00.850 --> 00:35:04.680
We just wanted to talk really
quickly about how you can

00:35:04.680 --> 00:35:07.830
basically use kind of the same
techniques for your app or

00:35:07.830 --> 00:35:09.330
application, whatever
you build.

00:35:09.330 --> 00:35:11.670
Hopefully it's in HTML.

00:35:11.670 --> 00:35:14.330
And we kind of assume you
already follow best practices,

00:35:14.330 --> 00:35:16.750
because that's kind
of boring, right?

00:35:16.750 --> 00:35:20.010
You all know this quote, Donald
Knuth-- "Premature

00:35:20.010 --> 00:35:24.090
optimization is the root of all
evil." I mentioned this

00:35:24.090 --> 00:35:27.270
before, but don't go in and
implement, like, lazy

00:35:27.270 --> 00:35:32.790
JavaScript evaluation for your
site if your site has large

00:35:32.790 --> 00:35:35.340
banners on it and that's why
it's slow, and not because you

00:35:35.340 --> 00:35:38.130
have written your own little
jQuery application.

00:35:38.130 --> 00:35:39.320
So yeah.

00:35:39.320 --> 00:35:44.000
Kind of measure and see where
you're slow, which the next

00:35:44.000 --> 00:35:46.370
slide is about as well.

00:35:46.370 --> 00:35:49.010
I talked about how you can
use Google Analytics.

00:35:49.010 --> 00:35:52.250
When you go back and have the
slides, there's the link where

00:35:52.250 --> 00:35:53.540
you can check out how
you can do this.

00:35:53.540 --> 00:35:56.160
It's not very much use,
but it's very cool.

00:35:56.160 --> 00:35:57.480
It's something you have
to implement yourself.

00:35:57.480 --> 00:35:59.810
So it gives you all these
metrics by default, but you

00:35:59.810 --> 00:36:05.320
can use it to see how your
customers in production load

00:36:05.320 --> 00:36:08.090
your site, by defining moments
on the page are

00:36:08.090 --> 00:36:09.850
important for you.

00:36:09.850 --> 00:36:13.820
So you get metrics on
how fast those are.

00:36:13.820 --> 00:36:17.680
And then there is the Chrome
Timeline View that I talked

00:36:17.680 --> 00:36:22.050
about earlier, which shows
you what your site is

00:36:22.050 --> 00:36:23.440
spending time on.

00:36:23.440 --> 00:36:27.110
And it's very interesting to
check out your site and see,

00:36:27.110 --> 00:36:29.680
huh, maybe these two things
could happen parallel or it

00:36:29.680 --> 00:36:32.620
could combine these resources.

00:36:32.620 --> 00:36:35.885
Or maybe you see that you're
first loading a JavaScript

00:36:35.885 --> 00:36:38.220
file, then a CSS file, and it
makes sense to switch them

00:36:38.220 --> 00:36:39.800
around because then they're
in parallel--

00:36:39.800 --> 00:36:40.800
stuff like that.

00:36:40.800 --> 00:36:44.930
And what I wanted to point out
is that there is actually a

00:36:44.930 --> 00:36:48.290
talk about real world web
performance optimization

00:36:48.290 --> 00:36:51.720
measurement that's like actually
spending more time on

00:36:51.720 --> 00:36:52.750
this than we are.

00:36:52.750 --> 00:36:57.090
And it's tomorrow at the same
time as this one in Room 8.

00:36:57.090 --> 00:36:58.380
And you should really
check it out.

00:37:01.850 --> 00:37:04.600
Don't want to spend too much
time, but this is like--

00:37:04.600 --> 00:37:05.960
if you remember anything,
right?

00:37:05.960 --> 00:37:07.780
Reduce your HTTP requests.

00:37:07.780 --> 00:37:12.100
It's what, unfortunately,
things spend time on.

00:37:12.100 --> 00:37:16.450
Like, we try to fix it with
SPDY, but still, HTTP requests

00:37:16.450 --> 00:37:17.760
have to go away.

00:37:17.760 --> 00:37:20.020
You go to Chrome Network
View, see why am I

00:37:20.020 --> 00:37:22.100
doing all this crap?

00:37:22.100 --> 00:37:24.820
And can two of those
become one?

00:37:24.820 --> 00:37:28.390
And can I maybe cache more?

00:37:28.390 --> 00:37:30.650
This is something we did, for
example, for the CSS inlining

00:37:30.650 --> 00:37:35.470
for the widget detection, to
just get fewer bytes on the

00:37:35.470 --> 00:37:39.330
wire and fewer things happening
after another.

00:37:39.330 --> 00:37:41.350
Parallelizing if possible.

00:37:41.350 --> 00:37:43.490
Again, you go into Chrome
Timeline View.

00:37:43.490 --> 00:37:51.540
You see, hmm, I downloaded an
image, and other image, and a

00:37:51.540 --> 00:37:53.660
JavaScript file, and then they
kind of depend on each other,

00:37:53.660 --> 00:37:56.340
and then the JavaScript
file loads an iframe.

00:37:56.340 --> 00:37:56.910
Stuff like that.

00:37:56.910 --> 00:37:58.450
It happens on every site.

00:37:58.450 --> 00:38:02.060
So is there a way we can maybe
predict what you have to do

00:38:02.060 --> 00:38:05.220
later and start it early
in a fashion-- and

00:38:05.220 --> 00:38:07.020
that's usually async--

00:38:07.020 --> 00:38:08.210
that it doesn't block?

00:38:08.210 --> 00:38:10.880
Our Bootstrap rendering
approach did this.

00:38:10.880 --> 00:38:13.560
The code-sharing thing as well--
as it parallelizes

00:38:13.560 --> 00:38:17.320
JavaScript execution
across iframes.

00:38:17.320 --> 00:38:19.010
And yeah.

00:38:19.010 --> 00:38:21.240
We talked about this as well.

00:38:21.240 --> 00:38:22.830
Optimize for perception.

00:38:22.830 --> 00:38:26.190
I don't have to repeat it, but
really, really, really think

00:38:26.190 --> 00:38:27.020
about your site.

00:38:27.020 --> 00:38:31.380
What is the important part that
is super necessary for

00:38:31.380 --> 00:38:36.040
the site to show so the user
thinks it's loading?

00:38:36.040 --> 00:38:41.200
And try to write your site in a
way that this is the things

00:38:41.200 --> 00:38:44.000
that can be loaded
independently, and then only

00:38:44.000 --> 00:38:47.860
once that happens, maybe, do the
harder work that you would

00:38:47.860 --> 00:38:49.100
like to avoid.

00:38:49.100 --> 00:38:53.350
Obviously, our Ping stuff, the
lazy JS evaluation things--

00:38:53.350 --> 00:38:59.190
they really make hard tradeoffs
of moving stuff to

00:38:59.190 --> 00:39:03.240
the back by improving the time
it takes to really show the

00:39:03.240 --> 00:39:05.420
first couple bytes.

00:39:05.420 --> 00:39:09.682
And all of that together, we
hope we moved things forward a

00:39:09.682 --> 00:39:10.290
little bit.

00:39:10.290 --> 00:39:13.390
I hope you guys enjoy having
slightly faster +1

00:39:13.390 --> 00:39:14.650
buttons on your site.

00:39:14.650 --> 00:39:15.750
And that's it.

00:39:15.750 --> 00:39:16.630
Thank you.

00:39:16.630 --> 00:39:16.920
JOHN HJELMSTAD: Thank you.

00:39:16.920 --> 00:39:23.251
[APPLAUSE]

00:39:23.251 --> 00:39:24.815
JOHN HJELMSTAD: So
any questions?

00:39:31.400 --> 00:39:32.780
AUDIENCE: I've got a couple
of questions.

00:39:32.780 --> 00:39:37.640
One, the mantra that you
introduced at the beginning of

00:39:37.640 --> 00:39:40.540
having a Bootstrap file that's
really small and doesn't cache

00:39:40.540 --> 00:39:43.750
very long, and then having
your bigger file that you

00:39:43.750 --> 00:39:46.440
change a lot be infinitely
cached?

00:39:46.440 --> 00:39:50.970
It seems like by teaching the
Bootstrap how to draw iframes

00:39:50.970 --> 00:39:54.200
and whatnot, all you really
did was use a different

00:39:54.200 --> 00:39:56.830
technique there and decide that
it wasn't really useful

00:39:56.830 --> 00:39:58.090
to have the two files.

00:39:58.090 --> 00:39:59.420
Am I following that
incorrectly?

00:39:59.420 --> 00:40:01.140
JOHN HJELMSTAD: No, that's
roughly it, actually.

00:40:01.140 --> 00:40:04.360
I mean, we made the observation
that the parsing

00:40:04.360 --> 00:40:06.630
phase, first of all, we designed
to be as simple as

00:40:06.630 --> 00:40:07.460
humanly possible.

00:40:07.460 --> 00:40:09.980
So it was wasteful for it to
be in the async payload to

00:40:09.980 --> 00:40:10.780
begin with.

00:40:10.780 --> 00:40:12.760
And that's a tradeoff we could
make, as well, right?

00:40:12.760 --> 00:40:16.610
Like we don't really need to
capitalize on that higher

00:40:16.610 --> 00:40:18.720
cache hit rate, to the extent
that we get it, actually.

00:40:18.720 --> 00:40:22.420
Because I noted that CSS on a
cache rate was not even all

00:40:22.420 --> 00:40:25.700
that great, and the
JS is larger.

00:40:25.700 --> 00:40:28.520
And so it's a principle tradeoff
that you need to make

00:40:28.520 --> 00:40:28.930
at that point.

00:40:28.930 --> 00:40:31.180
It does, in fact, make our
bootloader a little larger.

00:40:31.180 --> 00:40:34.890
Now in our particular case, it
was fortunate that we looked

00:40:34.890 --> 00:40:36.230
into the bootloader and--

00:40:36.230 --> 00:40:38.650
something we didn't mention,
but we looked at it very

00:40:38.650 --> 00:40:41.770
carefully and closely and just
ripped out everything we

00:40:41.770 --> 00:40:45.130
didn't strictly need, made it
way smaller, and then once

00:40:45.130 --> 00:40:46.880
again inflated it to where
it was before.

00:40:46.880 --> 00:40:50.120
So the needle didn't move
with respect to that.

00:40:50.120 --> 00:40:54.560
And it's also worth noting, just
as a quick aside, that we

00:40:54.560 --> 00:40:57.980
have experimented with but
haven't actually deployed some

00:40:57.980 --> 00:41:00.310
techniques associated with
figuring out ways for the

00:41:00.310 --> 00:41:03.370
bootloader's cache timeout to be
much, much longer, which of

00:41:03.370 --> 00:41:06.060
course has its own tradeoffs,
because the bootloader needs

00:41:06.060 --> 00:41:09.580
to be able to expire when you
have new code coming out, when

00:41:09.580 --> 00:41:13.030
you have bug fixes, new
features, whatever.

00:41:13.030 --> 00:41:15.480
But the technique which I just
think is interesting--

00:41:15.480 --> 00:41:18.150
I'll say it very briefly, but I
don't want to deep-dive too

00:41:18.150 --> 00:41:19.900
much-- is you extend
your cache time.

00:41:19.900 --> 00:41:23.620
You add a tiny bit of code that
basically opens an iframe

00:41:23.620 --> 00:41:27.250
that then opens another iframe
to your own JS file, which

00:41:27.250 --> 00:41:30.050
then does a JS force reload.

00:41:30.050 --> 00:41:30.670
High level.

00:41:30.670 --> 00:41:34.600
But what it essentially allows
you to do is force evict,

00:41:34.600 --> 00:41:38.210
using JavaScript, a cache
line from the browser.

00:41:38.210 --> 00:41:41.947
So we may play around with
that one as well at some

00:41:41.947 --> 00:41:43.290
point, but so far it hasn't
been critical path.

00:41:43.290 --> 00:41:45.640
MALTE UBL: One thing to mention
is that the payload

00:41:45.640 --> 00:41:47.480
does more than just
draw widget.

00:41:47.480 --> 00:41:51.990
You mouseover and it shows
hovers, shows Share boxes.

00:41:51.990 --> 00:41:53.950
So that's all stuff
that you don't

00:41:53.950 --> 00:41:55.520
necessarily need to draw.

00:41:55.520 --> 00:42:00.830
So there's, basically, some
stuff moved from the payload

00:42:00.830 --> 00:42:03.280
to the Bootstrap, but it's the
stuff that's in the critical

00:42:03.280 --> 00:42:05.260
path, as John said.

00:42:05.260 --> 00:42:06.380
It didn't increase
the overall--

00:42:06.380 --> 00:42:07.130
JOHN HJELMSTAD: That's
is very good point.

00:42:07.130 --> 00:42:10.280
The parts that we moved in were
very much a minority.

00:42:10.280 --> 00:42:13.290
The vast majority of it is the
complex positioning logic and

00:42:13.290 --> 00:42:16.920
iframe communication logic and
authentication logic and so

00:42:16.920 --> 00:42:19.690
on, having to do with the hovers
and interaction stuff.

00:42:19.690 --> 00:42:20.790
AUDIENCE: So that's missing from
your waterfall because

00:42:20.790 --> 00:42:22.835
it's not critical path, but
that part is still there?

00:42:22.835 --> 00:42:23.120
MALTE UBL: Right.

00:42:23.120 --> 00:42:23.900
JOHN HJELMSTAD: Exactly.

00:42:23.900 --> 00:42:27.070
AUDIENCE: And the second part of
your waterfall, you moved--

00:42:27.070 --> 00:42:30.590
at the beginning, you said that
you wanted to confirm

00:42:30.590 --> 00:42:32.260
that everything loaded correctly
before you drew the

00:42:32.260 --> 00:42:34.630
button so you don't end up with
an unstyled button or

00:42:34.630 --> 00:42:36.560
something like that showing
up on the page.

00:42:36.560 --> 00:42:38.280
AUDIENCE: And it seems that
moving your confirmation

00:42:38.280 --> 00:42:40.390
before you've confirmed that
the CSS and JavaScript have

00:42:40.390 --> 00:42:41.980
downloaded defeats the
point of doing that.

00:42:41.980 --> 00:42:44.180
MALTE UBL: That's not-- so
it's not entirely true.

00:42:44.180 --> 00:42:47.060
Basically, the highest
risk of not loading

00:42:47.060 --> 00:42:48.520
is the widget itself.

00:42:48.520 --> 00:42:52.140
So this happened recently to
another social network.

00:42:52.140 --> 00:42:56.120
And you kind of want
to avoid this.

00:42:56.120 --> 00:43:00.030
So when you're able to load
this widget, we're super

00:43:00.030 --> 00:43:03.680
confident that we're able to
eventually download the CSS.

00:43:03.680 --> 00:43:07.360
And if that actually doesn't
happen, then I mean, that's a

00:43:07.360 --> 00:43:08.180
whole different point.

00:43:08.180 --> 00:43:11.100
But it's something we're very
much not worried about.

00:43:11.100 --> 00:43:14.850
So we know we are able
to deliver the widget

00:43:14.850 --> 00:43:16.410
and we can show it.

00:43:16.410 --> 00:43:17.940
AUDIENCE: Thank you.

00:43:17.940 --> 00:43:19.400
JOHN HJELMSTAD: Thanks.

00:43:19.400 --> 00:43:20.570
AUDIENCE: Hey.

00:43:20.570 --> 00:43:22.220
So it makes sense to always

00:43:22.220 --> 00:43:24.040
asynchronously load the Bootstrap.

00:43:24.040 --> 00:43:25.310
That makes perfect sense.

00:43:25.310 --> 00:43:29.120
The question is, there's no
native method built into the

00:43:29.120 --> 00:43:33.140
Bootstrap for when it's all
set up having the callback

00:43:33.140 --> 00:43:36.930
injected into it from
the end user.

00:43:36.930 --> 00:43:38.990
And while there are ways,
certainly, to kind of handle

00:43:38.990 --> 00:43:40.560
on the front end-- there's weird
cross-browser stuff.

00:43:40.560 --> 00:43:43.070
And I guess if you're trying to
promote best practices to

00:43:43.070 --> 00:43:46.070
any web developer out there,
anyone who's, say, explicitly

00:43:46.070 --> 00:43:47.640
rendering their tags or
anything, it feels like it

00:43:47.640 --> 00:43:51.160
might be pretty simple to add
just that single callback, for

00:43:51.160 --> 00:43:52.650
Load Ready or something.

00:43:52.650 --> 00:43:55.770
MALTE UBL: So there's many
ways to do this.

00:43:55.770 --> 00:43:59.010
The one I prefer is the way
Google Analytics handles the

00:43:59.010 --> 00:44:03.870
same problem, where they use
this JavaScript array that you

00:44:03.870 --> 00:44:07.880
push on to, which then later,
as the payload arrives, gets

00:44:07.880 --> 00:44:10.470
upgraded to the actual thing
that does the work.

00:44:10.470 --> 00:44:14.130
And this thing that you kind
of queued gets done.

00:44:14.130 --> 00:44:15.910
But yeah.

00:44:15.910 --> 00:44:18.190
So it's certainly something
that we could consider.

00:44:18.190 --> 00:44:19.260
AUDIENCE: That'd be
awesome, yeah.

00:44:19.260 --> 00:44:21.270
JOHN HJELMSTAD: I mean, the
onload support that we do have

00:44:21.270 --> 00:44:23.380
right now, if you load
plusone.js--

00:44:23.380 --> 00:44:24.400
MALTE UBL: Don't mention it!

00:44:24.400 --> 00:44:25.510
It's ugly!

00:44:25.510 --> 00:44:26.990
JOHN HJELMSTAD: It works
in two different ways.

00:44:26.990 --> 00:44:28.130
The ugly way--

00:44:28.130 --> 00:44:31.680
which I will acknowledge-- is
you just stick in an onload

00:44:31.680 --> 00:44:34.090
parameter which is a function
name that is assumed to be in

00:44:34.090 --> 00:44:36.170
the global namespace, sanitized
and whatnot, and it

00:44:36.170 --> 00:44:36.920
will execute that.

00:44:36.920 --> 00:44:39.910
Obviously that's worse for
caching across your own page

00:44:39.910 --> 00:44:42.580
loads and those of others,
even within the 30-minute

00:44:42.580 --> 00:44:45.010
current cache timeout
of the Bootstrap.

00:44:45.010 --> 00:44:48.150
But there is a default onload
function, too, called

00:44:48.150 --> 00:44:52.060
gapi_loaded, which will be
sought, and if it exists, it

00:44:52.060 --> 00:44:55.100
will be executed once the
payload is executed.

00:44:55.100 --> 00:44:59.030
So that actually is not
deleterious to a performance

00:44:59.030 --> 00:44:59.470
in that way.

00:44:59.470 --> 00:45:00.510
AUDIENCE: And it's called
gapi-dot-loaded?

00:45:00.510 --> 00:45:01.210
Interesting.

00:45:01.210 --> 00:45:02.350
JOHN HJELMSTAD:
Gapi-underscore-loaded.

00:45:02.350 --> 00:45:02.760
AUDIENCE: Underscore-loaded.

00:45:02.760 --> 00:45:06.000
And is that in the documentation
at all, for--?

00:45:06.000 --> 00:45:06.640
JOHN HJELMSTAD: I hope so.

00:45:06.640 --> 00:45:08.100
But it's probably
way down there.

00:45:08.100 --> 00:45:09.250
We try to make our
documentation

00:45:09.250 --> 00:45:10.430
as simple as possible.

00:45:10.430 --> 00:45:11.660
AUDIENCE: I was looking
around just today.

00:45:11.660 --> 00:45:12.770
I don't think it is in there.

00:45:12.770 --> 00:45:14.420
So that would be helpful--

00:45:14.420 --> 00:45:15.110
JOHN HJELMSTAD: Very helpful.

00:45:15.110 --> 00:45:15.980
I would agree with that.

00:45:15.980 --> 00:45:16.290
AUDIENCE: Thank you.

00:45:16.290 --> 00:45:16.460
Cool, thanks.

00:45:16.460 --> 00:45:17.710
JOHN HJELMSTAD: Thanks.

00:45:19.560 --> 00:45:24.420
AUDIENCE: I was curious about
code manageability about it.

00:45:24.420 --> 00:45:27.130
I mean, when you start to do too
many techniques, it starts

00:45:27.130 --> 00:45:31.780
to make a unique custom solution
for the widget.

00:45:31.780 --> 00:45:34.360
Is there any techniques or
things that you do if you're

00:45:34.360 --> 00:45:38.370
having to change out HTML that
conflicts too much with the

00:45:38.370 --> 00:45:40.980
inline CSS?

00:45:40.980 --> 00:45:44.770
Any tips or tricks that you do
in order to make it more

00:45:44.770 --> 00:45:45.910
manageable?

00:45:45.910 --> 00:45:46.650
MALTE UBL: So first
of all, there's

00:45:46.650 --> 00:45:47.870
definitely tradeoffs involved.

00:45:47.870 --> 00:45:51.470
So I think lazy JS is the most
extreme one, because it's

00:45:51.470 --> 00:45:55.480
essentially, you say, you cannot
do anything anymore

00:45:55.480 --> 00:45:56.700
when you load.

00:45:56.700 --> 00:45:59.760
And when your project manager
comes, you know, I have this

00:45:59.760 --> 00:46:01.190
awesome idea.

00:46:01.190 --> 00:46:02.260
I want to do this
when you load.

00:46:02.260 --> 00:46:05.060
And then, oh, well, kinda
we can't anymore.

00:46:05.060 --> 00:46:05.940
So it's a big tradeoff.

00:46:05.940 --> 00:46:07.150
It also makes it much
more complex.

00:46:07.150 --> 00:46:10.250
It makes it, like, from a script
tag to this, like,

00:46:10.250 --> 00:46:14.190
process of getting source
code, much more complex.

00:46:14.190 --> 00:46:16.210
And it's hard.

00:46:16.210 --> 00:46:17.990
And this is why we
say measure.

00:46:17.990 --> 00:46:19.410
Because there is complexity
in it.

00:46:19.410 --> 00:46:21.790
There's no silver bullet
to solve this.

00:46:21.790 --> 00:46:29.790
But if you know there would be
this possible optimization and

00:46:29.790 --> 00:46:33.130
it's worth for you-- and the
model of whether something is

00:46:33.130 --> 00:46:35.460
worth it for you might
be different.

00:46:35.460 --> 00:46:37.190
When you're in an online
store, where it's super

00:46:37.190 --> 00:46:39.530
important that people can shop,
maybe there's some pages

00:46:39.530 --> 00:46:41.140
where you would never do this
optimization because they're

00:46:41.140 --> 00:46:42.420
just not as important.

00:46:42.420 --> 00:46:48.400
And for us, having all these
billions impressions per day,

00:46:48.400 --> 00:46:51.480
there's often this thing where
this optimization which you

00:46:51.480 --> 00:46:55.120
would never usually do becomes
kind of worth it, which is why

00:46:55.120 --> 00:46:57.770
I kind of enjoy this job.

00:46:57.770 --> 00:46:59.710
JOHN HJELMSTAD: It would be nice
if there was some like

00:46:59.710 --> 00:47:02.060
cool engineering trick or
something that we had.

00:47:02.060 --> 00:47:05.405
But when it comes down to it,
it's the much more boring sort

00:47:05.405 --> 00:47:07.100
of suggestions, like,
make sure you

00:47:07.100 --> 00:47:09.210
document it really well.

00:47:09.210 --> 00:47:12.620
And in our particular case,
we're building multiple

00:47:12.620 --> 00:47:13.900
different types of widgets.

00:47:13.900 --> 00:47:16.000
Build them all on the same
templates, the same platform,

00:47:16.000 --> 00:47:19.350
the same whatever, so at least
they all work the same way.

00:47:19.350 --> 00:47:20.690
And then, you know, automated
tests and

00:47:20.690 --> 00:47:21.520
all the boring stuff.

00:47:21.520 --> 00:47:23.510
AUDIENCE: Yeah, I mean, it'd be
real cool if you'd say, OK,

00:47:23.510 --> 00:47:26.340
here's a preprocessor that
handles all this.

00:47:26.340 --> 00:47:28.320
You write it one way and
redo all this for you.

00:47:28.320 --> 00:47:28.673
JOHN HJELMSTAD: Yeah.

00:47:28.673 --> 00:47:29.380
And that has to change how
it works internally.

00:47:29.380 --> 00:47:31.450
MALTE UBL: I talked about
the code-sharing, right?

00:47:31.450 --> 00:47:33.840
Most of this, like
the lazy stuff--

00:47:33.840 --> 00:47:35.980
It's very transparent
to the JavaScript.

00:47:35.980 --> 00:47:39.650
The JavaScript doesn't know it's
being optimized this way

00:47:39.650 --> 00:47:40.550
with the code-sharing.

00:47:40.550 --> 00:47:42.000
Again, because it's a
transformation in the

00:47:42.000 --> 00:47:43.940
compiler, the JavaScript
doesn't have to be

00:47:43.940 --> 00:47:44.970
written in the way.

00:47:44.970 --> 00:47:50.760
So these are actually examples
where we kind of took the

00:47:50.760 --> 00:47:52.530
framework and the infrastructure
[? layer ?] and

00:47:52.530 --> 00:47:53.640
solved this problem.

00:47:53.640 --> 00:47:57.630
So with the code-sharing, you
can tell the developer, you

00:47:57.630 --> 00:47:59.210
cannot access window directly.

00:47:59.210 --> 00:48:01.020
You cannot access document
directly.

00:48:01.020 --> 00:48:02.960
You always have to go through
this indirection.

00:48:02.960 --> 00:48:05.770
And if you do this
from the start,

00:48:05.770 --> 00:48:07.900
it's also a cool decision.

00:48:07.900 --> 00:48:12.530
But with this, it's basically
like, it's an infrastructure

00:48:12.530 --> 00:48:15.360
thing that solves this problem
once and for all and makes it

00:48:15.360 --> 00:48:17.460
usable for everybody.

00:48:17.460 --> 00:48:19.690
And it's open source,
so it's like--

00:48:19.690 --> 00:48:22.100
JOHN HJELMSTAD: The perhaps
amusing, perhaps just

00:48:22.100 --> 00:48:24.220
straightforward expression we've
used for it is, we try

00:48:24.220 --> 00:48:26.360
for everything to be as much
a semantic identity

00:48:26.360 --> 00:48:28.420
transform as possible.

00:48:28.420 --> 00:48:31.210
Lazy JS is not, which is why it
was one of the more complex

00:48:31.210 --> 00:48:32.010
ones for us.

00:48:32.010 --> 00:48:33.430
Inlining CSS--

00:48:33.430 --> 00:48:36.730
on the back-end we've got a
template, and it says, load

00:48:36.730 --> 00:48:42.740
this URL, in a link rel
or whatever tag.

00:48:42.740 --> 00:48:46.560
And literally, there's just a
little if block that says spit

00:48:46.560 --> 00:48:49.400
out that or do a back-end
request to the server that

00:48:49.400 --> 00:48:52.030
would have spat that out,
and inline the result.

00:48:52.030 --> 00:48:55.820
So to the extent that you
don't have weird caching

00:48:55.820 --> 00:48:58.200
issues or whatever, and that
your URLs are stable and the

00:48:58.200 --> 00:49:00.310
content is stable, it works
exactly the same

00:49:00.310 --> 00:49:01.700
way, in that respect.

00:49:01.700 --> 00:49:02.070
AUDIENCE: OK.

00:49:02.070 --> 00:49:02.710
Thanks.

00:49:02.710 --> 00:49:03.960
JOHN HJELMSTAD: Yep.

00:49:05.710 --> 00:49:06.890
MALTE UBL: Last question.

00:49:06.890 --> 00:49:07.230
AUDIENCE: Hi.

00:49:07.230 --> 00:49:08.760
Matt from Olark here.

00:49:08.760 --> 00:49:11.565
So we have something similar,
where we have a chat box that

00:49:11.565 --> 00:49:12.960
we embed on people's websites.

00:49:12.960 --> 00:49:16.280
So one thing we're considering
for some new things that we're

00:49:16.280 --> 00:49:18.700
doing is using localStorage
to do caching.

00:49:18.700 --> 00:49:20.770
I'm just kind of curious if you
guys considered that, and

00:49:20.770 --> 00:49:22.795
if maybe you ran into some
issues with it and that's why

00:49:22.795 --> 00:49:26.150
you're kind of still sticking
with typical caching.

00:49:26.150 --> 00:49:27.140
MALTE UBL: Yes.

00:49:27.140 --> 00:49:28.750
JOHN HJELMSTAD: The
answer's yes.

00:49:28.750 --> 00:49:30.470
We have experimented with
it and certainly

00:49:30.470 --> 00:49:31.250
thought a lot about it.

00:49:31.250 --> 00:49:32.570
MALTE UBL: Here's the thing.

00:49:32.570 --> 00:49:35.480
For in-widget, for inside
the iframe, it's doable.

00:49:35.480 --> 00:49:38.210
We don't want to do this on the
containing page because we

00:49:38.210 --> 00:49:38.690
don't own it.

00:49:38.690 --> 00:49:41.010
We would spam their
localStorage.

00:49:41.010 --> 00:49:44.970
So within the context,
not a very good idea.

00:49:44.970 --> 00:49:46.730
But yes.

00:49:46.730 --> 00:49:49.010
Inside the iframe, we haven't
implemented it.

00:49:49.010 --> 00:49:51.580
But it's very interesting
because it gives you much,

00:49:51.580 --> 00:49:54.150
much more control over
your caching.

00:49:54.150 --> 00:49:56.183
So yes, I think it's
a very good idea.

00:49:56.183 --> 00:49:56.950
AUDIENCE: OK, cool.

00:49:56.950 --> 00:49:58.420
JOHN HJELMSTAD: Did you want to
give any words about shared

00:49:58.420 --> 00:49:59.700
workers and whatnot?

00:49:59.700 --> 00:50:00.050
MALTE UBL: Yes.

00:50:00.050 --> 00:50:00.420
Oh, yeah.

00:50:00.420 --> 00:50:02.060
I wanted to use shared
workers for this.

00:50:02.060 --> 00:50:03.400
See, we have this thing
in the background--

00:50:03.400 --> 00:50:07.420
it only exists in Chrome.

00:50:07.420 --> 00:50:09.890
It can be accessed
by every domain.

00:50:09.890 --> 00:50:12.430
Every single iframe,
every single tab.

00:50:12.430 --> 00:50:14.330
And basically, it would
provide [? Java ?]

00:50:14.330 --> 00:50:14.420
[? for ?]

00:50:14.420 --> 00:50:14.610
[? you. ?]

00:50:14.610 --> 00:50:15.350
It would ask it for it.

00:50:15.350 --> 00:50:17.670
So we'd never have HTTP
requests, basically.

00:50:17.670 --> 00:50:19.540
And you would have guaranteed
in-memory caching.

00:50:19.540 --> 00:50:21.210
So that's my favorite--

00:50:21.210 --> 00:50:22.750
JOHN HJELMSTAD: And most
importantly, in-memory caching

00:50:22.750 --> 00:50:26.280
tied to one ID rather than
however many sites that you

00:50:26.280 --> 00:50:29.090
happen to be on exploding
the cache size.

00:50:29.090 --> 00:50:31.070
MALTE UBL: But Chrome only.

00:50:31.070 --> 00:50:32.220
AUDIENCE: That's called
shared worker?

00:50:32.220 --> 00:50:33.700
JOHN HJELMSTAD: Shared worker.

00:50:33.700 --> 00:50:36.180
It's like a Web Worker, only
that when you instantiate it

00:50:36.180 --> 00:50:39.120
and there's already one
on the same URL, you

00:50:39.120 --> 00:50:40.175
get the same one.

00:50:40.175 --> 00:50:40.970
AUDIENCE: Oh, OK.

00:50:40.970 --> 00:50:41.840
Very cool.

00:50:41.840 --> 00:50:43.250
And one other question,
I was curious--

00:50:43.250 --> 00:50:46.202
we're also looking at
using data URIs.

00:50:46.202 --> 00:50:48.000
And I'm curious-- have you guys
experimented with that

00:50:48.000 --> 00:50:50.140
much, and are there
disadvantages to that as well?

00:50:50.140 --> 00:50:51.630
MALTE UBL: no, we haven't yet.

00:50:51.630 --> 00:50:56.480
We think about it for delivering
the image with the

00:50:56.480 --> 00:50:58.640
CSS, and we're currently not.

00:50:58.640 --> 00:51:02.040
One thing we actually do-- we're
kind of cheating, and we

00:51:02.040 --> 00:51:04.990
haven't mentioned this today--
but the Bootstrap makes a

00:51:04.990 --> 00:51:08.230
request to the image
file, which is

00:51:08.230 --> 00:51:10.570
never drawn to anything.

00:51:10.570 --> 00:51:12.685
So it's guaranteed to be
in cache by the time

00:51:12.685 --> 00:51:14.130
the widget is drawn.

00:51:14.130 --> 00:51:16.245
And I think that's probably
even a better idea than to

00:51:16.245 --> 00:51:18.990
inline it, because that's
a lot of traffic.

00:51:18.990 --> 00:51:22.030
JOHN HJELMSTAD: And obviously,
that interrelates with

00:51:22.030 --> 00:51:25.680
inlining CSS, in that if we
basically explode the inline

00:51:25.680 --> 00:51:28.350
sprite into a bunch of data URIs
in the CSS file, then it

00:51:28.350 --> 00:51:29.380
becomes inline.

00:51:29.380 --> 00:51:32.580
Then that tradeoff becomes less
tilted in favor because

00:51:32.580 --> 00:51:36.480
the CSS is larger
at that point.

00:51:36.480 --> 00:51:36.820
AUDIENCE: Cool.

00:51:36.820 --> 00:51:37.540
MALTE UBL: All right, thanks.

00:51:37.540 --> 00:51:39.040
JOHN HJELMSTAD: Thanks.

00:51:39.040 --> 00:51:43.035
[APPLAUSE]

