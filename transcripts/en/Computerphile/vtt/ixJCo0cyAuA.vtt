WEBVTT
Kind: captions
Language: en-GB

00:00:00.000 --> 00:00:05.640
There's plenty of superb anecdotes
about the history of the byte and and so on.

00:00:05.640 --> 00:00:09.510
I suppose the earlier question which, if

00:00:09.510 --> 00:00:14.190
we want to go right back to ground zero:
"Who invented the word 'bit' "? A chap at -

00:00:14.190 --> 00:00:18.869
guess where - Bell Labs.
John Tukey. [He] worked with Shannon and

00:00:18.869 --> 00:00:24.240
others. I think it was he who, in a
paper in 1947, actually uttered the word

00:00:24.240 --> 00:00:30.000
'bit' rather than 'binary digit' for the
first time. 

00:00:30.000 --> 00:00:37.680
So, how big should your groupings of bits be 
to hold the numbers you were interested in? 
And this is the

00:00:37.680 --> 00:00:46.770
key to it all. Early computers were word
based. Later on, the idea of the byte came

00:00:46.770 --> 00:00:52.559
to be - not synonymous - but associated with:
'... what's the amount of storage we'd have

00:00:52.559 --> 00:00:58.230
to set aside for holding a character'? But,
y' know, real programmers aren't

00:00:58.230 --> 00:01:06.479
bothered with waffly bits of text! They want
*numbers*. The obsession, with the

00:01:06.479 --> 00:01:11.310
early computer pioneers, was very much:
"We're gonna build these things because

00:01:11.310 --> 00:01:15.299
they're interesting in their own right - 
electronic general-purpose computers - but

00:01:15.299 --> 00:01:21.259
what we really want to do is serious applied 
mathematics,  engineering,

00:01:21.259 --> 00:01:27.540
quantum chemistry, computer science, x-ray
crystallography, radio astronomy. All good

00:01:27.540 --> 00:01:33.689
solid, scientific, things which need
guaranteed decimal [places of] accuracy.

00:01:33.689 --> 00:01:38.100
So, remembering the rule of 3.322 -
which I don't have on my

00:01:38.100 --> 00:01:42.000
T-shirt this time - sorry about that.
&gt;&gt; SOUND TRACK OF VIDEO INSERT 
 " ... and if anybody wants to produce a

00:01:42.000 --> 00:01:49.860
T-shirt with that on, I might even buy one ....
&gt;&gt; DFB: 3.322 is the multiplying factor for 
how much more binary

00:01:49.860 --> 00:01:58.290
circuitry you need in your Arithmetic
unit of your computer, to be able to do

00:01:58.290 --> 00:02:03.930
things in binary arithmetic rather than
decimal arithmetic. [For] the logic bits of the

00:02:03.930 --> 00:02:07.979
computer, it's a no-brainer: it's yes/no
decisions, so proper binary is fine there.

00:02:07.979 --> 00:02:13.860
But why not use decimal integers [for arithmetic] ? 
Well, using decimal integers - 

00:02:13.860 --> 00:02:17.670
we can point to a previous video on this - 
it's fine but you've got to stabilise

00:02:17.670 --> 00:02:23.130
10 different voltages, for 10
different levels of decimal digit. You've

00:02:23.130 --> 00:02:28.080
only got 2 to stabilise for binary. It's
much simpler to build in binary, but you

00:02:28.080 --> 00:02:32.940
have to accept you will need 
3.322... whatever, times the amount of

00:02:32.940 --> 00:02:37.770
binary components, to do arithmetic, than
you would using decimal. OK, so that's

00:02:37.770 --> 00:02:41.760
accepted then: we build in binary.
But for [high] school use you were taught how

00:02:41.760 --> 00:02:47.220
to use logs to do your multiplies, with
4 decimal digits of accuracy. Babbage

00:02:47.220 --> 00:02:51.630
and others wanted at least 10 digits. In
fact, I've not got them here at home

00:02:51.630 --> 00:02:55.590
they're at work, I've actually got 10-digit 
log tables - quite a big thick book

00:02:55.590 --> 00:03:00.510
of them. So, if 10 digits was deemed to be
a pretty decent starting point, multiply

00:03:00.510 --> 00:03:07.200
by 3.322 and you can see [that] by the
time you got to something like 33 - 36 bit

00:03:07.200 --> 00:03:11.820
for safety maybe - groupings, you're
beginning to get the 10 decimal digits

00:03:11.820 --> 00:03:17.459
of accuracy that you want. So, you look at
EDSAC, a first generation computer which

00:03:17.459 --> 00:03:23.370
we've been talking about. EDSAC's only
got an 18-bit word of which 17 bits are

00:03:23.370 --> 00:03:29.430
useful. But by the time - if you could only 'glue'
two of those [words] together in some way, you're up to

00:03:29.430 --> 00:03:34.769
35, 36 bits. Now you're talking! That's
getting us the accuracy we want. However,

00:03:34.769 --> 00:03:39.120
at greater expense of course - 
contemporaneously as we now know with

00:03:39.120 --> 00:03:43.920
EDSAC, was the EDVAC. They went for 40
bits straight away. So they didn't have

00:03:43.920 --> 00:03:48.690
to double up the locations. [It was]  more
expensive to build, of course, but 40 bits...?

00:03:48.690 --> 00:03:54.300
Fine - that will get you 10, or 12 possibly,
decimal digits. Even when I came to do my

00:03:54.300 --> 00:04:01.860
work - early work - on quantum chemistry, all
along you were aware of not wanting to

00:04:01.860 --> 00:04:09.239
lose precision on your decimal digit
calculations, and taking great care about

00:04:09.239 --> 00:04:15.959
rounding errors and stuff like this. I once 
looked at some exam. papers for the

00:04:15.959 --> 00:04:19.200
Cambridge Diploma, because for many years
- from about the early 50s onwards -

00:04:19.200 --> 00:04:24.810
Cambridge did a postgraduate Diploma in
Computing. Yeah, based around the EDSAC,

00:04:24.810 --> 00:04:28.890
You went there -- a lot of [now]
famous computer scientists 'converted

00:04:28.890 --> 00:04:32.880
themselves', if you like, by doing the
Cambridge Diploma. An awful lot of those

00:04:32.880 --> 00:04:37.800
Diploma papers were numerical analysis!
There was the odd question in there

00:04:37.800 --> 00:04:43.590
which was ... Shock! Horror! ... *non-numerical*,
covering things like algorithms for the

00:04:43.590 --> 00:04:48.090
Travelling Salesman problem. But then the
next question would be, y'know [fictitious example]

00:04:48.090 --> 00:04:53.520
How would you invert a Householder Normal
matrix, of dimension 20 x 20, in

00:04:53.520 --> 00:04:58.500
the minimal number of operations without
losing decimal precision in the 5th

00:04:58.500 --> 00:05:01.940
decimal point"?  All this kind of stuff.
That was the background:

00:05:01.940 --> 00:05:06.720
scientists, mathematicians and engineers
built computers and they built them to

00:05:06.720 --> 00:05:11.970
do hardcore numeric calculations. So, was
that all there was to it?

00:05:11.970 --> 00:05:20.280
No. On the sidelines, and treated quite
honestly - and shamefacedly I say this in

00:05:20.280 --> 00:05:25.980
many ways - with a bit of derision, was
Commercial Computing and the company, as

00:05:25.980 --> 00:05:30.360
I'm sure you all know, that was
instrumental in leading the way with

00:05:30.360 --> 00:05:35.610
that was IBM. IBM, for years and years and
years, was the biggest computer company

00:05:35.610 --> 00:05:39.720
in the world. It's probably
still in the top ten, but I'm guessing

00:05:39.720 --> 00:05:44.310
that Microsoft Apple and Google will be
bigger than IBM, in terms of revenues,

00:05:44.310 --> 00:05:51.750
nowadays. Yeah, IBM, of course, had got the
best part of almost a cent ...  no half a

00:05:51.750 --> 00:05:57.510
century - a good half a century of lead, in
using punched cards as a means of

00:05:57.510 --> 00:06:02.700
holding data. And even though the
machinery that sorted them, collated them

00:06:02.700 --> 00:06:07.440
and could even do elementary additions
and subtractions of the codes that were

00:06:07.440 --> 00:06:11.820
on the cards ... IBM was the market leader 
by a mile.

00:06:11.820 --> 00:06:16.530
Others tried to get in on the act and
get a little bit of the action - and they did.

00:06:16.530 --> 00:06:25.170
But the industry leader was IBM. So IBM
understood about real [commercial] data. OK then,

00:06:25.170 --> 00:06:30.720
so they were the right people to
basically start saying: "You look at these

00:06:30.720 --> 00:06:35.160
computers now [1950s era] and how they handle
characters. It's pathetic!"

00:06:35.160 --> 00:06:39.480
And it is [was]. Because you can go back to our EDSAC

00:06:39.480 --> 00:06:44.460
video about how to print "HI" but it
doesn't matter whether printing out "HI"

00:06:44.460 --> 00:06:51.390
or "HELLO WORLD". You look at the way that
these early computers did characters and

00:06:51.390 --> 00:06:56.610
it was absolutely suboptimal.
The story was well if you don't want to

00:06:56.610 --> 00:07:01.470
fill up your word with lots and lots of
bits that real scientists use you could

00:07:01.470 --> 00:07:06.170
always fill up a subset of your word
with maybe 5 bits for a Baudot code, or

00:07:06.170 --> 00:07:10.350
invent your own 6-bit code to stop
having to use figure-shift and letter

00:07:10.350 --> 00:07:15.870
shift? Turn it from 32 possibilities to 64? 
So 5- or 6-bit

00:07:15.870 --> 00:07:21.120
characters were common. But some people
started to say: "Well, you always go on

00:07:21.120 --> 00:07:25.380
about memory being so massively expensive 
[in those days] and so precious, and yet on

00:07:25.380 --> 00:07:31.080
EDSAC you're saying: 'well it's 5-bit
character'. So you can economize, can you,

00:07:31.080 --> 00:07:36.540
by squeezing three 5-bit characters
into a 17-bit word'?  "No! why would

00:07:36.540 --> 00:07:40.680
you do that? It'd be hell to get them
out again.  You'd have to do bit shifts

00:07:40.680 --> 00:07:45.180
and all sorts, you'd slow things down". So,
when you look on an early machines like

00:07:45.180 --> 00:07:50.340
EDSAC it uses 5-bit characters in
the middle of an 18-bit word and the

00:07:50.340 --> 00:07:53.190
rest of the 13 bits just don't do
anything.

00:07:53.190 --> 00:07:57.780
IBM came along and said: "Look, here's the
story. For those of you that have got lots of money

00:07:57.780 --> 00:08:03.690
- and don't mind spending it - we have the
perfect solution. Stop making the Word be

00:08:03.690 --> 00:08:09.480
your minimum addressable unit. Address the 
characters [that can be packed inside it] individually,

00:08:09.480 --> 00:08:13.800
and in order to keep things clean, and to
allow for future expansion, don't mess

00:08:13.800 --> 00:08:19.460
about with multiples of 2 - like 6-bit
characters. Let's be brave and say:

00:08:19.460 --> 00:08:27.270
' Right. 8-bit characters !'. Now for a while
before all this came about, people had

00:08:27.270 --> 00:08:31.470
been calling groups of bits of arbitrary
size 5 bits, 6 bits, [they had]  been calling

00:08:31.470 --> 00:08:36.750
them 'bytes. But IBM proposed to
standardize on the word 'byte' being an

00:08:36.750 --> 00:08:42.419
8-bit entity. And here's the win-win
situation: for those of you mad

00:08:42.419 --> 00:08:48.360
mathematicians and engineers, we can
arrange the hardware to regard

00:08:48.360 --> 00:08:53.470
groups of four of those [Bytes]  as being a
32-bit Word. It's a win-win.

00:08:53.470 --> 00:08:58.930
IBM can dominate not only [byte based] commercial
computing but can also make a reasonably

00:08:58.930 --> 00:09:01.750
good showing, because of the sheer speed
of their hardware

00:09:01.750 --> 00:09:08.680
at great expense, in scientific computing
as well. So, people said: "Oh! great idea.

00:09:08.680 --> 00:09:13.690
Oh wow! yes that is ... you know, now that
we've all got more money and can afford

00:09:13.690 --> 00:09:17.800
more expensive things ... that is a sensible
way to do it. Without a doubt". So, the idea

00:09:17.800 --> 00:09:22.000
was absolutely spot-on,
You choose a byte width which is a power

00:09:22.000 --> 00:09:29.220
of two and then you arrange to be able
to put together groupings of bytes that

00:09:29.220 --> 00:09:35.590
form something sensible and bigger for
macho types who want to do real number

00:09:35.590 --> 00:09:40.540
arithmetic. So, everything in the garden is
lovely. You've got 32 bits you've got 8 bits.

00:09:40.540 --> 00:09:45.370
it was almost "end of story" but not quite.

00:09:45.370 --> 00:09:53.620
Because although IBM did very nicely
with things like the 370/195

00:09:53.620 --> 00:09:59.140
and so on, at being a pretty good
mainstream scientific computer, they

00:09:59.140 --> 00:10:04.210
didn't really go for chasing the market
at the very [scientific] top end . Because there just

00:10:04.210 --> 00:10:08.980
wasn't enough in it for them. They made
megabucks off their commercial database

00:10:08.980 --> 00:10:15.130
customers. So, right at the top end, you
get alternative solutions emerging, which

00:10:15.130 --> 00:10:20.140
are still with us today, started off with
a company called CDC and the brilliant

00:10:20.140 --> 00:10:26.050
hardware engineer called Seymour Cray
And [your] ears will say: "Cray?! he left CDC

00:10:26.050 --> 00:10:30.850
eventually?" Yeah, he did and he formed Cray
computers. So, yes, at the supercomputer

00:10:30.850 --> 00:10:36.820
end of things there was an alternative
market, but IBM - solidly there in the

00:10:36.820 --> 00:10:44.440
middle - said: "We do commercial, and we do
scientific. We rule the world!" And I think

00:10:44.440 --> 00:10:50.620
they were remarkably prescient.  and they,
even at the other end, foresaw it and

00:10:50.620 --> 00:10:54.970
tried to get it right, but failed. But
maybe this will have to be another video?

00:10:54.970 --> 00:10:59.170
Because it does complete the story.
It's "What about people who wanted something

00:10:59.170 --> 00:11:04.740
even cheaper than a 16-bit PDP-11?"
They wanted an 8-bit micro. IBM saw that

00:11:04.740 --> 00:11:08.970
coming and tried to get in there and
dominate it. But for reasons we half

00:11:08.970 --> 00:11:13.320
understand - but [which] can be revealed if
there's enough demand - they did lose

00:11:13.320 --> 00:11:17.400
control of that one.

