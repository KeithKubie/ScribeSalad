WEBVTT
Kind: captions
Language: en

00:00:02.180 --> 00:00:04.000
CHRIS BROADFOOT: Hi I'm Chris
Broadfoot, I work on the

00:00:04.000 --> 00:00:05.060
Google Maps API.

00:00:05.060 --> 00:00:06.840
ANDREW GERRAND: And I'm Andrew
Gerrand and I work on the Go

00:00:06.840 --> 00:00:07.840
programming language.

00:00:07.840 --> 00:00:11.020
And today we're here from
Google in Sydney to

00:00:11.020 --> 00:00:16.570
demonstrate a HTML5 Google Maps
based web app that uses

00:00:16.570 --> 00:00:20.520
the Go runtime on App Engine
to perform some intensive

00:00:20.520 --> 00:00:22.860
computation in the cloud.

00:00:22.860 --> 00:00:26.820
And before we get into the guts
of the app, I'm going to

00:00:26.820 --> 00:00:28.750
get Chris to talk about
the problem our

00:00:28.750 --> 00:00:30.000
app tries to solve.

00:00:32.450 --> 00:00:34.130
CHRIS BROADFOOT: So, this might
look familiar to you,

00:00:34.130 --> 00:00:36.490
it's a map of the world
of satellite

00:00:36.490 --> 00:00:37.740
imagery taken from space.

00:00:40.740 --> 00:00:42.940
This here is also taken
from space.

00:00:42.940 --> 00:00:44.520
And it's a cloud layer.

00:00:44.520 --> 00:00:47.610
So this is available through the
Maps app and also through

00:00:47.610 --> 00:00:48.860
the Maps API.

00:00:52.170 --> 00:00:55.180
Late last year, Google Maps
Mobile added indoor floor

00:00:55.180 --> 00:00:57.200
plans to the base Google Map.

00:00:57.200 --> 00:01:00.270
So essentially, they overlaid
quite detailed indoor

00:01:00.270 --> 00:01:03.819
information in context with
the map of the world.

00:01:06.540 --> 00:01:08.750
Loughborough University has
done a similar thing, by

00:01:08.750 --> 00:01:12.990
adding custom imagery on top
of the base Google Maps so

00:01:12.990 --> 00:01:15.740
that their visitors can navigate
from the world and

00:01:15.740 --> 00:01:19.080
also within the campus.

00:01:19.080 --> 00:01:22.740
And so this is a Maps
API application.

00:01:22.740 --> 00:01:25.600
So what you're seeing here is
kite imagery taken by Frank

00:01:25.600 --> 00:01:28.730
Taylor on his Tahina
expedition.

00:01:28.730 --> 00:01:31.490
So I think this is in French
Polynesia somewhere.

00:01:31.490 --> 00:01:34.670
He's flying a kite up and taking
some aerial imagery.

00:01:34.670 --> 00:01:39.260
And so, you can see a little
clearly where his really high

00:01:39.260 --> 00:01:43.020
resolution imagery has been
meshed with the lower

00:01:43.020 --> 00:01:46.360
resolution Google Satellite
imagery.

00:01:46.360 --> 00:01:48.200
And so, if I zoom in all the
way, you can see how

00:01:48.200 --> 00:01:49.420
detailed this is.

00:01:49.420 --> 00:01:52.010
I think this is zoom level 22.

00:01:52.010 --> 00:01:55.960
And you can see these two guys
riding their bike, someone

00:01:55.960 --> 00:01:57.500
standing there, and a car.

00:02:01.270 --> 00:02:07.620
So consider, maybe yesterday you
jumped out of a blimp, you

00:02:07.620 --> 00:02:10.039
wearing Google Glass,
and you took some

00:02:10.039 --> 00:02:13.140
really awesome imagery.

00:02:13.140 --> 00:02:15.700
You'd want to get this onto
a map somehow, right?

00:02:15.700 --> 00:02:20.110
Show it in context with the
Google Satellite imagery.

00:02:20.110 --> 00:02:21.310
You can do this with
the Ground Overlay

00:02:21.310 --> 00:02:22.970
class in the Maps API.

00:02:22.970 --> 00:02:26.440
You essentially tell us where
the imagery is, and pass in

00:02:26.440 --> 00:02:27.410
lat-long bounds.

00:02:27.410 --> 00:02:32.310
So, a region on the earth,
essentially a rectangle.

00:02:32.310 --> 00:02:33.560
And you end up with something
like this.

00:02:37.050 --> 00:02:40.990
There's a trade-off between
size and high resolution.

00:02:40.990 --> 00:02:45.120
So, here in this overlay we're
sending the whole image down

00:02:45.120 --> 00:02:46.880
to the client.

00:02:46.880 --> 00:02:51.700
So you'd either have to send a
large image to get really high

00:02:51.700 --> 00:02:55.700
detail when you zoom in, or
suffer low resolution imagery

00:02:55.700 --> 00:02:58.180
once you zoom in.

00:02:58.180 --> 00:03:01.030
This is the same problem that
we have on Google Maps.

00:03:01.030 --> 00:03:03.720
So consider that the width of
the world at a particular zoom

00:03:03.720 --> 00:03:05.770
level is two to the
power of that zoom

00:03:05.770 --> 00:03:08.380
level, times 256 pixels.

00:03:08.380 --> 00:03:13.980
So, at zoom level 21 that's 536
million pixels, and that

00:03:13.980 --> 00:03:17.690
turns out to be 288 quadrillion
pixels if you have

00:03:17.690 --> 00:03:21.630
really high resolution imagery
at worldwide coverage.

00:03:21.630 --> 00:03:24.290
So that turns out to be 40
petabytes, which is completely

00:03:24.290 --> 00:03:28.018
unreasonable to send
down to a browser.

00:03:28.018 --> 00:03:30.140
Even if you could send it,
they wouldn't be able to

00:03:30.140 --> 00:03:32.050
render it, right?

00:03:32.050 --> 00:03:35.930
So, the way Google Maps solves
this is by using tiles.

00:03:35.930 --> 00:03:39.550
So at zoom level zero, at the
top the entire world is

00:03:39.550 --> 00:03:41.480
represented by one tile.

00:03:41.480 --> 00:03:44.420
And as you get further and
further zoomed in, more and

00:03:44.420 --> 00:03:47.520
more tiles are used to represent
high resolution

00:03:47.520 --> 00:03:49.720
imagery of the world.

00:03:49.720 --> 00:03:51.810
So at zoom level 21, there's
many, many tiles.

00:03:55.260 --> 00:03:57.190
So this same tile-based
approach could be

00:03:57.190 --> 00:03:58.890
used for map overlays.

00:03:58.890 --> 00:04:03.040
If you've used the map in the
I/O Android app, this uses the

00:04:03.040 --> 00:04:04.700
same tile-based approach.

00:04:04.700 --> 00:04:07.916
And indeed we generated these
tiles using the app that

00:04:07.916 --> 00:04:10.730
Andrew and I will demonstrate
today.

00:04:10.730 --> 00:04:14.740
So if you zoom in, you get a
really high resolution, sharp

00:04:14.740 --> 00:04:17.374
image that matches the base
Google Maps tiles.

00:04:21.990 --> 00:04:24.680
So it's really easy to add
this tile overlay.

00:04:24.680 --> 00:04:28.260
You create an image map type,
you tell the Maps API where to

00:04:28.260 --> 00:04:31.810
find the tile image for a
particular coordinate, and

00:04:31.810 --> 00:04:35.720
then you add it to the
overlay map types.

00:04:35.720 --> 00:04:40.220
Now the I/O Android map has
about 1,000 tiles for that

00:04:40.220 --> 00:04:41.090
small area.

00:04:41.090 --> 00:04:43.490
And you can imagine that
generating these tiles is a

00:04:43.490 --> 00:04:46.560
little difficult.

00:04:46.560 --> 00:04:50.400
So we have some really
great tools that--

00:04:50.400 --> 00:04:53.630
these two are open-source and
they help you generate these

00:04:53.630 --> 00:04:55.580
tile overlays.

00:04:55.580 --> 00:04:57.466
So the first one, gdal.

00:04:57.466 --> 00:05:00.550
gdal_translate essentially
encodes some location

00:05:00.550 --> 00:05:02.460
information into the image.

00:05:02.460 --> 00:05:04.700
So we can see here, we're
converting between pixel

00:05:04.700 --> 00:05:07.230
coordinates and positions
on the earth.

00:05:07.230 --> 00:05:11.210
And then we can use gdal2tiles
or the map tiler project to

00:05:11.210 --> 00:05:16.660
generate a tile,
a tile pyramid.

00:05:16.660 --> 00:05:19.170
Now, these tools are
really great.

00:05:19.170 --> 00:05:22.610
But as I demonstrated at I/O
last year, it's quite

00:05:22.610 --> 00:05:25.390
difficult to find those
precise coordinates.

00:05:25.390 --> 00:05:29.260
So, I demonstrated an
application last year that

00:05:29.260 --> 00:05:30.430
helps you with this.

00:05:30.430 --> 00:05:32.265
But this year, we've got a
more complete solution.

00:05:34.850 --> 00:05:39.600
So we've open sourced it, it's
called overlay tiler.

00:05:39.600 --> 00:05:41.890
And you can download the
source code here.

00:05:41.890 --> 00:05:44.000
But today, Andrew and I will
be showing you some of the

00:05:44.000 --> 00:05:45.580
details about how we built it.

00:05:48.630 --> 00:05:50.230
So let's jump straight
into a quick demo.

00:05:56.960 --> 00:05:59.970
So, today we'll be adding
the Mosconi floor plan.

00:05:59.970 --> 00:06:02.500
This is essentially what I did
a few weeks ago to generate

00:06:02.500 --> 00:06:05.210
the floor plan for
the Android app.

00:06:05.210 --> 00:06:08.890
So this is a floor plan that
we got from our vendor, who

00:06:08.890 --> 00:06:11.110
did all the fit-out.

00:06:11.110 --> 00:06:16.270
And so if I go and search
for Howard Street,

00:06:16.270 --> 00:06:17.520
zoom straight in.

00:06:20.210 --> 00:06:22.670
And then I'm just going to drag
the image from my desktop

00:06:22.670 --> 00:06:24.060
onto the map.

00:06:24.060 --> 00:06:28.180
And once I drop it, you'll see
that the image is added

00:06:28.180 --> 00:06:30.390
exactly where I dropped it.

00:06:30.390 --> 00:06:32.860
And I get these three control
points that I can use to drag

00:06:32.860 --> 00:06:33.840
the image around the map.

00:06:33.840 --> 00:06:36.580
I can also use this one
in the middle to just

00:06:36.580 --> 00:06:38.170
translate it around.

00:06:38.170 --> 00:06:41.660
And I can precisely and directly
manipulate the image

00:06:41.660 --> 00:06:45.470
on the map to see what
it'll look like.

00:06:48.310 --> 00:06:53.020
So I can also use this opacity
slider just to make sure it

00:06:53.020 --> 00:06:55.580
lines up with the base
Google Maps Tiles.

00:06:55.580 --> 00:06:57.870
Or perhaps if I'm going to
eventually put it Satellite

00:06:57.870 --> 00:07:00.920
Mode, you can see it's slightly
offset, so I might

00:07:00.920 --> 00:07:03.160
actually move it there.

00:07:03.160 --> 00:07:05.430
And then hit the
Process button.

00:07:05.430 --> 00:07:08.460
And from here the overlay is
uploaded along with its

00:07:08.460 --> 00:07:11.810
coordinates to App Engine, where
App Engine will go and

00:07:11.810 --> 00:07:13.060
generate a tile set.

00:07:15.960 --> 00:07:19.190
And once that's done, I'll
download a zip file and all

00:07:19.190 --> 00:07:22.480
the tiles will be in that
zip file, along with a

00:07:22.480 --> 00:07:25.670
implementation that adds this
overlay to the map.

00:07:25.670 --> 00:07:34.500
So if I go ahead and unzip
that, open up index.html.

00:07:34.500 --> 00:07:37.140
So let's have a look inside
here at some tiles.

00:07:37.140 --> 00:07:40.010
So these are the tile
coordinates.

00:07:40.010 --> 00:07:43.900
So I can see part of
the Mosconi Center.

00:07:43.900 --> 00:07:49.150
If I open up index, we see
that the overlay is

00:07:49.150 --> 00:07:50.360
added to the map.

00:07:50.360 --> 00:07:53.440
And we can zoom all the way in
and get high resolution tiles.

00:07:59.160 --> 00:07:59.750
OK?

00:07:59.750 --> 00:08:01.980
So we'll be showing you
some of the details

00:08:01.980 --> 00:08:03.530
about how we built.

00:08:03.530 --> 00:08:09.060
Just quickly, we used HTML5, the
Maps API and Go and Google

00:08:09.060 --> 00:08:10.310
App Engine.

00:08:12.180 --> 00:08:15.840
So, first of all, I'll start
with the user interface.

00:08:15.840 --> 00:08:19.600
So the first thing you'll
notice the page is

00:08:19.600 --> 00:08:21.180
filled with a map.

00:08:21.180 --> 00:08:24.560
If you have a mapping-based
application, or an application

00:08:24.560 --> 00:08:27.440
that's quite map-heavy, you
should go ahead and fill the

00:08:27.440 --> 00:08:28.790
page with the map.

00:08:28.790 --> 00:08:31.950
Nothing hurts me more than
to see a map-intensive

00:08:31.950 --> 00:08:33.500
application that has
a really tiny map.

00:08:33.500 --> 00:08:36.730
It's a horrible user
experience.

00:08:36.730 --> 00:08:39.740
So the other thing is, if you're
giving your users a way

00:08:39.740 --> 00:08:44.370
to navigate around the world,
add Places auto-complete.

00:08:44.370 --> 00:08:47.610
It's really simple-- it's about
three lines of code--

00:08:47.610 --> 00:08:49.750
and your users will
love you for it.

00:08:53.420 --> 00:08:57.750
So, once the user has landed on
the page and navigated, we

00:08:57.750 --> 00:09:01.110
drag and drop the image
to the map.

00:09:01.110 --> 00:09:02.560
So we do this by listening
to the drop

00:09:02.560 --> 00:09:04.830
event on the map element.

00:09:04.830 --> 00:09:08.010
You can use any element
on the page.

00:09:08.010 --> 00:09:09.960
And from there, we get a handle
to the file on the

00:09:09.960 --> 00:09:12.720
local file system.

00:09:12.720 --> 00:09:14.430
This is something that
traditionally, browsers

00:09:14.430 --> 00:09:16.530
haven't offered access to.

00:09:16.530 --> 00:09:19.690
This is a really great way
to perform client-side

00:09:19.690 --> 00:09:20.800
manipulations.

00:09:20.800 --> 00:09:23.060
You don't need to send this file
to the server to begin

00:09:23.060 --> 00:09:26.030
using it, straightaway.

00:09:26.030 --> 00:09:28.800
So we create an object URL,
which gives us a URL to the

00:09:28.800 --> 00:09:30.470
local file system.

00:09:30.470 --> 00:09:34.300
And create a new overlay at the
x and y-coordinates that

00:09:34.300 --> 00:09:37.260
the user dropped the image.

00:09:37.260 --> 00:09:40.090
So, to add the overlay to the
map, we use a Google Maps

00:09:40.090 --> 00:09:41.590
overlay view.

00:09:41.590 --> 00:09:43.720
So this is a class that you
implement, these three

00:09:43.720 --> 00:09:46.460
methods, onAdd, draw,
and onRemove.

00:09:46.460 --> 00:09:51.130
So draw essentially is called
when the overlay should be

00:09:51.130 --> 00:09:52.510
re-rendered.

00:09:52.510 --> 00:09:55.440
And getMap and getPanes
getProjection are really

00:09:55.440 --> 00:09:58.150
useful to render the overlay.

00:10:02.990 --> 00:10:05.950
So once the image is added
to the map, we

00:10:05.950 --> 00:10:07.800
create an image element.

00:10:07.800 --> 00:10:12.430
We set the source to the URL
on the local file system.

00:10:12.430 --> 00:10:15.730
And we add it to the
overlay image pane.

00:10:15.730 --> 00:10:18.120
You see at the bottom, we're
calling getPanes.

00:10:18.120 --> 00:10:22.540
And this is a handle to some of
the map panes so that when

00:10:22.540 --> 00:10:25.930
the map is panned,
your overlay is

00:10:25.930 --> 00:10:27.180
translated with the map.

00:10:30.400 --> 00:10:33.070
So once the overlay is added to
the map, you need to give

00:10:33.070 --> 00:10:35.690
the users some way
to manipulate it.

00:10:35.690 --> 00:10:38.430
We do this by adding three
control points, top left, top

00:10:38.430 --> 00:10:39.850
right, and bottom right.

00:10:39.850 --> 00:10:43.610
And for each one we
had a marker.

00:10:43.610 --> 00:10:48.640
The user is able to drag it
around, and we use the bindTo

00:10:48.640 --> 00:10:52.470
function to bind the position
of the marker to the control

00:10:52.470 --> 00:10:55.050
point on that overlay, so that
whenever the marker is

00:10:55.050 --> 00:10:58.160
dragged, the overlay's control
points are updated as well.

00:11:00.840 --> 00:11:04.610
Now, whenever the user drags
the marker, whenever the

00:11:04.610 --> 00:11:07.410
position of those markers
change, we need to re-warp the

00:11:07.410 --> 00:11:11.310
image, so that they get
a really direct

00:11:11.310 --> 00:11:14.510
manipulation feel.

00:11:14.510 --> 00:11:17.200
We do this with an affine
transformation.

00:11:17.200 --> 00:11:21.650
So, affine transformations are
four types of transformations,

00:11:21.650 --> 00:11:28.910
translation, scaling,
rotation, and skew.

00:11:28.910 --> 00:11:32.000
And so with those four
transformations combined, we

00:11:32.000 --> 00:11:33.990
can do something like this.

00:11:33.990 --> 00:11:38.020
And so this represents all of
the operations that you can do

00:11:38.020 --> 00:11:39.570
based on three control points.

00:11:42.850 --> 00:11:48.050
So using an affine transform, we
can warp the image whenever

00:11:48.050 --> 00:11:50.400
the user drags the marker.

00:11:50.400 --> 00:11:53.360
We use RequestAnimationFrame
to synchronize the paint

00:11:53.360 --> 00:11:57.750
events of the browser with our
own paint events, and we set

00:11:57.750 --> 00:12:00.100
the transform property
on the image.

00:12:00.100 --> 00:12:06.200
So down below, you can see
the CSS property matrix.

00:12:06.200 --> 00:12:09.250
And so this is the matrix that
represents the transformation

00:12:09.250 --> 00:12:12.950
based on those three
control points.

00:12:12.950 --> 00:12:16.640
And it's also the exact same
matrix that we'll be using on

00:12:16.640 --> 00:12:21.550
the server-side later, and
Andrew will talk through that.

00:12:21.550 --> 00:12:24.790
So when we first created
this app, we

00:12:24.790 --> 00:12:27.070
dragged a large overlay--

00:12:27.070 --> 00:12:29.400
I think it was tens of megabytes
or hundreds of

00:12:29.400 --> 00:12:30.330
megabytes--

00:12:30.330 --> 00:12:32.740
and the browser slowed
to a crawl.

00:12:32.740 --> 00:12:36.090
This is because it was just too
much work to be able to

00:12:36.090 --> 00:12:40.870
transform the this image
many times a second.

00:12:40.870 --> 00:12:44.590
So when the user drags the image
to the map, we check if

00:12:44.590 --> 00:12:46.860
it's larger than a certain
dimension.

00:12:46.860 --> 00:12:50.910
And if it is, we just re-size
that image in the browser,

00:12:50.910 --> 00:12:52.810
using Canvas.

00:12:52.810 --> 00:12:57.150
Using Canvas, we can paint a
image to a canvas, and turn it

00:12:57.150 --> 00:12:59.810
into a data URL.

00:12:59.810 --> 00:13:04.490
And then we update the
source of the image

00:13:04.490 --> 00:13:05.740
so it's scaled down.

00:13:08.340 --> 00:13:10.690
While this is all happening, the
full size image is being

00:13:10.690 --> 00:13:13.940
uploaded to Blobstore
on App Engine.

00:13:13.940 --> 00:13:17.070
So as soon as the user drops
it, the image is uploaded.

00:13:17.070 --> 00:13:20.090
But this immediately able to
manipulate the image, because

00:13:20.090 --> 00:13:23.800
we have access to
that local file.

00:13:23.800 --> 00:13:27.870
So we just upload in the back
end, and once the user's

00:13:27.870 --> 00:13:30.400
finished manipulating, once
they press that Process

00:13:30.400 --> 00:13:33.570
button, the three coordinates of
the control points are sent

00:13:33.570 --> 00:13:34.650
to the server.

00:13:34.650 --> 00:13:39.460
And the server starts
tiling the image.

00:13:39.460 --> 00:13:42.420
Andrew will talk more about
what happens now.

00:13:42.420 --> 00:13:43.670
ANDREW GERRAND: Thanks, Chris.

00:13:46.400 --> 00:13:49.130
So now that we've seen the user
interface and how this

00:13:49.130 --> 00:13:53.340
was constructed, I'm going to
talk about how the tiles are

00:13:53.340 --> 00:13:56.590
processed on the back end and
the zip file is created.

00:13:56.590 --> 00:13:58.990
So, as I mentioned at the
beginning of the talk, we're

00:13:58.990 --> 00:14:02.560
using the Google App Engine
platform to build this app.

00:14:02.560 --> 00:14:05.100
And who here has used
App Engine before?

00:14:05.100 --> 00:14:06.290
Anyone?

00:14:06.290 --> 00:14:08.690
All right, so those of you
who used it, who's

00:14:08.690 --> 00:14:11.090
used the Go API before?

00:14:11.090 --> 00:14:13.350
Ah, that's great.

00:14:13.350 --> 00:14:16.680
So for those of you don't know,
the App Engine platform

00:14:16.680 --> 00:14:19.390
is Google's platform as
a service offering.

00:14:19.390 --> 00:14:22.010
That is, we take care of all
the infrastructure worries,

00:14:22.010 --> 00:14:25.640
building it out, scaling it and
administering it, so that

00:14:25.640 --> 00:14:28.680
you don't have to, and you and
your team can just focus on

00:14:28.680 --> 00:14:32.440
building scalable, reliable
web apps.

00:14:32.440 --> 00:14:34.840
In this application, we actually
use a variety of the

00:14:34.840 --> 00:14:37.540
services available in App
Engine, and I'm going to talk

00:14:37.540 --> 00:14:38.430
through some of that.

00:14:38.430 --> 00:14:42.680
So, just an overview of
how the app works.

00:14:42.680 --> 00:14:45.820
There are five main
parts of the app.

00:14:45.820 --> 00:14:50.250
The first is the upload handler,
which receives the

00:14:50.250 --> 00:14:53.440
file from the user and stores it
into the Blobstore Service,

00:14:53.440 --> 00:14:57.750
which is a service for storing
large, unstructured data.

00:14:57.750 --> 00:14:59.700
The second is the
process handler.

00:14:59.700 --> 00:15:02.650
And this receives the set
of overlay coordinates.

00:15:02.650 --> 00:15:05.490
That is, when the user has
positioned the overlay on the

00:15:05.490 --> 00:15:09.350
map, it sends the latitude and
longitude of the top left, top

00:15:09.350 --> 00:15:12.140
right, and bottom right
corners that overlay.

00:15:12.140 --> 00:15:14.880
And the process handler takes
those coordinates, it takes

00:15:14.880 --> 00:15:19.090
the original overlay image, and
then computes which tiles

00:15:19.090 --> 00:15:21.750
need to be generated at what
zoom levels and the

00:15:21.750 --> 00:15:23.930
coordinates of those tiles.

00:15:23.930 --> 00:15:28.080
And then creates some tasks
which are fed to this next

00:15:28.080 --> 00:15:30.120
handler, the slice handler.

00:15:30.120 --> 00:15:33.600
And so the slice handler takes
these tile coordinates, and

00:15:33.600 --> 00:15:38.040
the original image, and then
performs the transformation

00:15:38.040 --> 00:15:42.440
that the user requested in the
first place using a external

00:15:42.440 --> 00:15:46.080
package called graphics-go,
which provides an affine

00:15:46.080 --> 00:15:49.120
transformations primitive which
is very convenient for

00:15:49.120 --> 00:15:50.720
what we're doing.

00:15:50.720 --> 00:15:56.740
And then it encodes each of
those new tiles as a PNG image

00:15:56.740 --> 00:15:59.910
and stores them into
the data store.

00:15:59.910 --> 00:16:03.180
Once all the slicing is
completed it kicks off another

00:16:03.180 --> 00:16:07.900
task, the zip task, which
collects all of the tiles that

00:16:07.900 --> 00:16:11.080
have been generated and then
generates the index dot html

00:16:11.080 --> 00:16:13.340
file, that we saw earlier.

00:16:13.340 --> 00:16:16.210
And then bundles all those files
together into a zip and

00:16:16.210 --> 00:16:17.670
stores in into the Blobstore.

00:16:17.670 --> 00:16:22.070
Finally the user is prompted
to download the zip file

00:16:22.070 --> 00:16:25.410
through the download handler,
which simply serves the zip

00:16:25.410 --> 00:16:27.040
file directly from Blobstore.

00:16:30.330 --> 00:16:34.500
So, when describing any app, a
great place to start is with

00:16:34.500 --> 00:16:35.430
data structures.

00:16:35.430 --> 00:16:38.365
And our app has two very
straightforward data

00:16:38.365 --> 00:16:39.280
structures.

00:16:39.280 --> 00:16:42.630
The first is the overlay
structure, and these are both

00:16:42.630 --> 00:16:45.660
the Go data structure
definitions, which map

00:16:45.660 --> 00:16:49.150
directly to datastore
entity records.

00:16:54.130 --> 00:16:57.870
The overlay struct represents
any given map overlay, so when

00:16:57.870 --> 00:17:01.850
a user drags an overlay onto
a map along with the file

00:17:01.850 --> 00:17:05.170
upload, we create a
overlay entity.

00:17:05.170 --> 00:17:06.960
And the first field in
the overlay entity

00:17:06.960 --> 00:17:08.869
is the image field.

00:17:08.869 --> 00:17:12.684
And the image field is a blob
key, a reference to that image

00:17:12.684 --> 00:17:14.130
in the Blobstore.

00:17:14.130 --> 00:17:17.750
The second one is a zip blob
key, and that will be a

00:17:17.750 --> 00:17:20.640
reference to the zip file,
once it's been created.

00:17:20.640 --> 00:17:25.760
And then we have the pixel
coordinates of the top left,

00:17:25.760 --> 00:17:28.089
top right, and bottom right of
the overlay which are used in

00:17:28.089 --> 00:17:30.220
computing the transformation.

00:17:30.220 --> 00:17:34.710
And finally we have the total
number of tiles that will be

00:17:34.710 --> 00:17:37.820
generated, and we use that to
figure out when we're finished

00:17:37.820 --> 00:17:40.050
generating all the tiles.

00:17:40.050 --> 00:17:43.360
And the other data structure
that we have is the tile.

00:17:43.360 --> 00:17:47.920
And a tile has an image field,
which is just a byte array,

00:17:47.920 --> 00:17:53.630
which will have the contents
of our PNG map tile image.

00:17:53.630 --> 00:17:56.630
And three other int 64 fields,
which are the x and

00:17:56.630 --> 00:18:00.130
y-coordinates of the tile and
pixel coordinates, and the

00:18:00.130 --> 00:18:02.220
zoom level at which this tile
should be displayed.

00:18:04.720 --> 00:18:06.740
So now that I've given you that
overview, I'm not going

00:18:06.740 --> 00:18:10.240
to walk through the entire
application piece by piece

00:18:10.240 --> 00:18:13.520
because it would take probably
longer than we have now.

00:18:13.520 --> 00:18:16.280
And a lot of it is minutia
that you can probably

00:18:16.280 --> 00:18:19.400
understand fairly easily
on your own.

00:18:19.400 --> 00:18:21.550
So instead we're going to talk
about some of the design

00:18:21.550 --> 00:18:25.610
problem so we encountered when
building the app, and how we

00:18:25.610 --> 00:18:29.240
went about solving
those problems.

00:18:29.240 --> 00:18:32.320
So the first problem was
to make it reliable.

00:18:32.320 --> 00:18:34.460
It's easy to write a program
that just runs from start to

00:18:34.460 --> 00:18:38.110
finish, and if everything goes
well, then it's correct.

00:18:38.110 --> 00:18:41.200
But in the land of computers,
things can and will go wrong

00:18:41.200 --> 00:18:42.310
all the time.

00:18:42.310 --> 00:18:46.190
And so we wanted to build this
app so that, if the sliced

00:18:46.190 --> 00:18:49.210
process, for instance, failed
at any point, it would just

00:18:49.210 --> 00:18:51.590
resume where it left off instead
of having to start all

00:18:51.590 --> 00:18:52.870
over again.

00:18:52.870 --> 00:18:54.880
In some of the more high
resolution overlays, we're

00:18:54.880 --> 00:18:57.860
talking about thousands of
tiles being generated.

00:18:57.860 --> 00:19:00.970
And it would be really
inconvenient to have to just

00:19:00.970 --> 00:19:03.170
take the pot luck that it's
going to succeed to completion

00:19:03.170 --> 00:19:05.920
every time.

00:19:05.920 --> 00:19:10.930
So the solution to this was to
use some of App Engine's APIs

00:19:10.930 --> 00:19:15.140
and build our app on top of
those reliable fault-tolerance

00:19:15.140 --> 00:19:15.780
structures.

00:19:15.780 --> 00:19:20.380
And the first of these is
the Task Queue API.

00:19:20.380 --> 00:19:24.990
And so task queues are a way
of reliably scheduling and

00:19:24.990 --> 00:19:27.840
running work in a fault-tolerant
way, and they

00:19:27.840 --> 00:19:29.090
come in two different
varieties.

00:19:32.110 --> 00:19:33.760
The first are push
queues, which are

00:19:33.760 --> 00:19:34.970
used to start workers.

00:19:34.970 --> 00:19:39.250
So, when a task is entered into
a push queue, it triggers

00:19:39.250 --> 00:19:42.120
some work, it calls
an HTTP handler.

00:19:42.120 --> 00:19:45.350
And pull queues, which are
consumed by workers, so

00:19:45.350 --> 00:19:49.840
workers actively lease tasks
from pull queues, do the work,

00:19:49.840 --> 00:19:51.180
and when it's complete,
they delete the

00:19:51.180 --> 00:19:53.700
task from the queue.

00:19:53.700 --> 00:19:57.190
In the Overlay Tiler app, we use
push queues to start the

00:19:57.190 --> 00:20:01.560
slice and zip tasks on backend
instances, and we use pull

00:20:01.560 --> 00:20:04.750
queues to track the tiles that
need to be processed.

00:20:04.750 --> 00:20:06.930
And so slice process will
lease those processes.

00:20:11.320 --> 00:20:15.880
The other piece of the puzzle
are App Engine backends.

00:20:15.880 --> 00:20:19.210
And so, a backend is a special
type of app instance that has

00:20:19.210 --> 00:20:21.520
greater memory and
CPU allowances

00:20:21.520 --> 00:20:23.840
than a typical instance.

00:20:23.840 --> 00:20:26.260
And they have longer request
limits, so you can do much

00:20:26.260 --> 00:20:28.670
more longer-running processes
with backends.

00:20:31.920 --> 00:20:36.800
We set up a slicer backend that
runs slice tasks, and the

00:20:36.800 --> 00:20:40.620
slice tasks are triggered
by a push queue.

00:20:40.620 --> 00:20:43.690
And each slice task will
lease tile tasks from

00:20:43.690 --> 00:20:45.560
the tile pull queue.

00:20:45.560 --> 00:20:49.390
And for each tile, it performs
the transformation, renders

00:20:49.390 --> 00:20:52.900
the tile, stores it in the data
store, and then removes

00:20:52.900 --> 00:20:54.720
the tile from that pull queue.

00:20:54.720 --> 00:20:57.600
So you can imagine that the tile
queue is asking for work,

00:20:57.600 --> 00:20:59.780
completing it, and then telling
the task queue system

00:20:59.780 --> 00:21:01.140
that this work is done.

00:21:01.140 --> 00:21:06.070
And gradually that tile queue is
consumed until it's empty.

00:21:06.070 --> 00:21:10.670
And so in the diagram, at the
bottom, we see that the slice

00:21:10.670 --> 00:21:14.440
push queue is triggering the
task as a whole, and then the

00:21:14.440 --> 00:21:18.690
task is taking tiles out of
the tile pull queue and

00:21:18.690 --> 00:21:22.650
turning them into
rendered tiles.

00:21:22.650 --> 00:21:27.620
So, if a slice task at any point
fails, that's when the

00:21:27.620 --> 00:21:30.790
task queues really come
into their own.

00:21:30.790 --> 00:21:33.950
If my slice task just dies in
the middle-- say it's rendered

00:21:33.950 --> 00:21:37.740
two tiles, but it leased
four from the queue.

00:21:37.740 --> 00:21:42.180
The lease on those remaining two
tiles will expire, and go

00:21:42.180 --> 00:21:45.070
back into the tile pull queue.

00:21:45.070 --> 00:21:48.010
And meanwhile, another slice
task is being created by the

00:21:48.010 --> 00:21:49.910
slice push queue.

00:21:49.910 --> 00:21:53.440
And those remaining two tiles
be leased and the remaining

00:21:53.440 --> 00:21:55.490
work to be done without really
skipping a beat.

00:21:58.980 --> 00:22:00.940
So that's how we made
it more reliable.

00:22:00.940 --> 00:22:03.670
The second issue was
making it faster.

00:22:03.670 --> 00:22:07.150
And so, what we have here is
an embarrassingly parallel

00:22:07.150 --> 00:22:07.760
problem, right?

00:22:07.760 --> 00:22:10.470
We have one source of data
that's basically immutable,

00:22:10.470 --> 00:22:12.100
that is, the tile overlay.

00:22:12.100 --> 00:22:14.900
And then we have many, many,
many small jobs that need to

00:22:14.900 --> 00:22:18.740
be run over that
piece of data.

00:22:18.740 --> 00:22:21.720
So there's no reason that it
should be done in serial,

00:22:21.720 --> 00:22:23.600
which is how we had
it originally.

00:22:23.600 --> 00:22:26.630
So instead, we thought we would
just run multiple tasks

00:22:26.630 --> 00:22:27.460
in parallel.

00:22:27.460 --> 00:22:32.120
And fortunately, the design that
we have using task queues

00:22:32.120 --> 00:22:35.350
made it trivial to run multiple
slots tasks across

00:22:35.350 --> 00:22:37.130
multiple backend instances.

00:22:37.130 --> 00:22:39.880
And to do this, all we needed
to do was configure our

00:22:39.880 --> 00:22:43.420
backends to launch four
instances of the slice

00:22:43.420 --> 00:22:47.340
backend, instead of one, and
to process four slice tasks

00:22:47.340 --> 00:22:49.810
simultaneously instead of one.

00:22:49.810 --> 00:22:54.685
And then in the process handler,
where we set up our

00:22:54.685 --> 00:22:58.870
slice tasks, we just add this
little bit of code here, this

00:22:58.870 --> 00:23:01.930
is the only added code,
is for loop.

00:23:01.930 --> 00:23:06.650
And then we target each task
to each one of the four

00:23:06.650 --> 00:23:10.750
backends, creating four
tasks instead of one.

00:23:10.750 --> 00:23:11.250
And that's it.

00:23:11.250 --> 00:23:14.280
And we got a four-times
speed up, and that was

00:23:14.280 --> 00:23:14.920
all we had to do.

00:23:14.920 --> 00:23:16.350
And that was quite nice.

00:23:16.350 --> 00:23:19.670
But I'm not that easily
satisfied.

00:23:19.670 --> 00:23:26.720
The slice process itself, it
requests tiles to be done, it

00:23:26.720 --> 00:23:30.080
performs the computation to
generate and encode the tile,

00:23:30.080 --> 00:23:31.850
and then it stores it
in the data store.

00:23:31.850 --> 00:23:33.630
And then it repeats that
process again.

00:23:33.630 --> 00:23:46.090
But there's no reason we should
wait for the datastore

00:23:46.090 --> 00:23:49.050
put to complete before
moving on to process

00:23:49.050 --> 00:23:50.550
the next set of tiles.

00:23:50.550 --> 00:23:53.170
And so fortunately, Go's
concurrency mechanisms make it

00:23:53.170 --> 00:23:55.550
really easy to do this.

00:23:55.550 --> 00:24:00.240
And so this is a very
broad-brushstrokes idea of how

00:24:00.240 --> 00:24:04.150
it worked without concurrency,
in the purely sequential way.

00:24:04.150 --> 00:24:07.920
So you lease the tasks, you
render the tiles, store the

00:24:07.920 --> 00:24:09.550
tiles in the datastore, and
then delete the completed

00:24:09.550 --> 00:24:11.490
tasks from the queue.

00:24:11.490 --> 00:24:15.050
And with concurrency, we still
have our original lease tasks

00:24:15.050 --> 00:24:19.410
and render tiles in the task
queue, but now we have this

00:24:19.410 --> 00:24:23.330
error channel, for rallying
Go routines.

00:24:23.330 --> 00:24:27.130
And then we just launch our
storage and deletion parts of

00:24:27.130 --> 00:24:29.520
the process in another
Go routine.

00:24:29.520 --> 00:24:32.350
And if you're interested in
learning how this works and

00:24:32.350 --> 00:24:35.940
more about it, Rob Pike is
giving a talk tomorrow

00:24:35.940 --> 00:24:39.420
morning, I think in this
same room, called

00:24:39.420 --> 00:24:40.530
Go Concurrency Patterns.

00:24:40.530 --> 00:24:43.900
I highly recommend you attend,
it's a great talk.

00:24:43.900 --> 00:24:47.830
But the net effect of this,
is in the case without

00:24:47.830 --> 00:24:50.730
concurrency, we had this
sequential render and put,

00:24:50.730 --> 00:24:52.580
render and put, render
and put.

00:24:52.580 --> 00:24:56.620
And with concurrency, we were
able to render tasks basically

00:24:56.620 --> 00:24:59.470
as fast as we could lease them
from the queue, and put them

00:24:59.470 --> 00:25:01.230
all in the background
simultaneously.

00:25:01.230 --> 00:25:03.460
And because the puts tended
to take less time than the

00:25:03.460 --> 00:25:07.010
renders, it was always in
sync and caught up.

00:25:07.010 --> 00:25:10.100
And with that, we got another
factor of two.

00:25:10.100 --> 00:25:16.660
So with a net of about 15, 20
extra lines in our program, we

00:25:16.660 --> 00:25:22.660
got an eight times speedup,
which is nice.

00:25:22.660 --> 00:25:28.240
So another third design issue
that we had was knowing when

00:25:28.240 --> 00:25:32.080
our tasks were complete.

00:25:32.080 --> 00:25:36.730
So, when all the tiles been
generated, we need to know

00:25:36.730 --> 00:25:39.570
that they're all done and
create the zip file.

00:25:39.570 --> 00:25:42.100
But when you've got multiple
slots tasks all generating

00:25:42.100 --> 00:25:45.560
tiles simultaneously, just
because one is finished

00:25:45.560 --> 00:25:48.310
processing tiles, doesn't mean
that another one isn't still

00:25:48.310 --> 00:25:50.510
going and still has
more work to do.

00:25:50.510 --> 00:25:53.810
And it would be pretty bad if we
started creating a zip file

00:25:53.810 --> 00:25:57.570
which didn't have all of
the tiles in it, right?

00:25:57.570 --> 00:26:00.950
And another thing is we can't
just kick off the creation of

00:26:00.950 --> 00:26:03.890
a zip file at the end of any
one, because we might end up

00:26:03.890 --> 00:26:06.305
creating four zip files, and
that's a waste of work.

00:26:09.210 --> 00:26:12.500
So to do this, we had
to manage state.

00:26:12.500 --> 00:26:16.630
And in App Engine, there are
some bad places to keep state.

00:26:16.630 --> 00:26:21.820
One of those places is in app
instances, which can just die.

00:26:21.820 --> 00:26:25.530
And so there's no guarantee
that they'll stick around

00:26:25.530 --> 00:26:30.570
they're not unreliable, but you
just can't rely on them.

00:26:30.570 --> 00:26:36.240
But that memcache records may
expire at any time because of

00:26:36.240 --> 00:26:37.560
the guarantees that memcache
gives you.

00:26:37.560 --> 00:26:40.610
They guarantee consistency and
accuracy but they don't

00:26:40.610 --> 00:26:43.510
guarantee that they'll
actually be there.

00:26:43.510 --> 00:26:46.780
And similarly, we can't just
count the tiles in the client

00:26:46.780 --> 00:26:49.830
and expect the client to do
the right thing, because

00:26:49.830 --> 00:26:52.720
clients can be broken, or
malicious, or just disappear

00:26:52.720 --> 00:26:55.180
at any time.

00:26:55.180 --> 00:26:58.260
So the one good place
to keep state in App

00:26:58.260 --> 00:26:59.680
Engine is in the datastore.

00:26:59.680 --> 00:27:03.340
It's consistent, structured,
and a reliable place.

00:27:03.340 --> 00:27:06.330
And fortunately we're
already using it.

00:27:06.330 --> 00:27:09.680
So we just implement
this algorithm to

00:27:09.680 --> 00:27:11.270
know when we're done.

00:27:11.270 --> 00:27:16.090
So at the end of each slice
task, when a slice task is

00:27:16.090 --> 00:27:19.720
finished processing tiles and
has no more work to do, it

00:27:19.720 --> 00:27:22.400
does a query to count the number
of tiles that exist in

00:27:22.400 --> 00:27:23.830
the datastore.

00:27:23.830 --> 00:27:27.090
And then it takes that count,
and it compares it with the

00:27:27.090 --> 00:27:29.320
total number of tiles
that it's expecting.

00:27:29.320 --> 00:27:32.180
So we had a field in the overlay
that was a record with

00:27:32.180 --> 00:27:34.280
the number of total tiles.

00:27:34.280 --> 00:27:41.780
And if there aren't enough tiles
in the datastore, we

00:27:41.780 --> 00:27:44.990
know that it's time
to keep slicing.

00:27:44.990 --> 00:27:50.070
So we go back to the start and
try and find more work to do.

00:27:50.070 --> 00:27:54.630
Otherwise, we check the
ZipRunning value in the

00:27:54.630 --> 00:27:55.880
overlay record.

00:27:55.880 --> 00:27:58.120
Actually, sorry, I omitted that
from the start, there's

00:27:58.120 --> 00:28:01.330
actually a boolean field in
our overlay struct that

00:28:01.330 --> 00:28:04.520
indicates whether we've created
a zip task or not.

00:28:04.520 --> 00:28:07.750
And if a zip task is already
running, then we're good to

00:28:07.750 --> 00:28:09.950
exit and shut down
this last task.

00:28:09.950 --> 00:28:11.910
But if neither of these two
conditions have been

00:28:11.910 --> 00:28:15.030
fulfilled, it means that all
of the tiles have been

00:28:15.030 --> 00:28:19.070
generated, it's time to start
zipping up the tiles.

00:28:19.070 --> 00:28:24.340
And so we add a task to the zip
push queue, and then we

00:28:24.340 --> 00:28:27.220
set the ZipRunning flag to true,
in the overlay record,

00:28:27.220 --> 00:28:31.760
and put it back into
the datastore.

00:28:31.760 --> 00:28:34.180
So that is fairly

00:28:34.180 --> 00:28:37.100
straightforward, but it's racy.

00:28:37.100 --> 00:28:43.700
So if we tried to actually run
this, there's a chance that

00:28:43.700 --> 00:28:48.400
two slice tasks could compare
the number of tiles and not

00:28:48.400 --> 00:28:50.210
see that there's a zip file
running, but then create two

00:28:50.210 --> 00:28:52.100
zip files simultaneously.

00:28:52.100 --> 00:28:54.510
And so the solution to this
is to just run it inside a

00:28:54.510 --> 00:28:56.370
datastore transaction.

00:28:56.370 --> 00:28:59.120
And with the Go runtime, that's
as simple as creating a

00:28:59.120 --> 00:29:01.820
function closure, which
encloses all of these

00:29:01.820 --> 00:29:03.940
operations, and then
run with the

00:29:03.940 --> 00:29:07.120
running transaction function.

00:29:07.120 --> 00:29:10.680
And this even applies
to adding the

00:29:10.680 --> 00:29:12.350
task to the task queue.

00:29:12.350 --> 00:29:14.450
So task queues are incorporated
in datastore

00:29:14.450 --> 00:29:16.825
transactions, and that's a
really nice mechanism.

00:29:20.210 --> 00:29:23.050
And so our fourth and
final problem is

00:29:23.050 --> 00:29:25.390
communicating with the user.

00:29:25.390 --> 00:29:29.450
So, after the user has hit the
Process button, and all these

00:29:29.450 --> 00:29:32.520
slice tasks have been fired off,
and the zip task has been

00:29:32.520 --> 00:29:36.220
fired off, there's no back
channel to the user.

00:29:36.220 --> 00:29:39.270
The backends are running these
instances and the user has no

00:29:39.270 --> 00:29:40.600
direct communication
with the backend.

00:29:43.260 --> 00:29:45.400
And not only do we need to tell
them when it's done, we

00:29:45.400 --> 00:29:48.880
also need to tell them as it's
going, what the state of the

00:29:48.880 --> 00:29:52.080
program is, so they have some
indication it's actually doing

00:29:52.080 --> 00:29:53.330
something and not stalling.

00:29:55.780 --> 00:29:57.990
So the means for doing
this with App Engine

00:29:57.990 --> 00:30:00.410
is the Channel API.

00:30:00.410 --> 00:30:04.000
And at the App Engine Channel
API just provides a push

00:30:04.000 --> 00:30:07.050
channel from App Engine
instances

00:30:07.050 --> 00:30:09.490
to the user's browser.

00:30:09.490 --> 00:30:11.970
And the mechanism for doing
this is really simple.

00:30:11.970 --> 00:30:14.250
There's just two functions on
the server side, there's the

00:30:14.250 --> 00:30:16.680
create function and
the send function.

00:30:16.680 --> 00:30:19.260
And so the create function
just takes an ID of your

00:30:19.260 --> 00:30:21.770
choosing, which uniquely
identifies the channel.

00:30:21.770 --> 00:30:25.190
And then returns a token, which
you pass to the client.

00:30:25.190 --> 00:30:28.830
And the client uses some
JavaScript create that channel

00:30:28.830 --> 00:30:31.060
using the token.

00:30:31.060 --> 00:30:33.510
And then sending a message, you
just provide the client ID

00:30:33.510 --> 00:30:35.810
and the message you want to
send, and it's any textual

00:30:35.810 --> 00:30:38.950
string that you can send
to the client.

00:30:38.950 --> 00:30:42.450
And on the client side, there's
some JavaScript, you

00:30:42.450 --> 00:30:45.180
just create a new channel object
and open it, which

00:30:45.180 --> 00:30:46.620
returns a socket.

00:30:46.620 --> 00:30:49.890
And then the socket has an
onmessage handler, which, when

00:30:49.890 --> 00:30:52.710
called, will pass a
message object.

00:30:52.710 --> 00:30:55.600
And so this code will just log
the message to the console

00:30:55.600 --> 00:30:57.010
every time a message
comes through.

00:30:57.010 --> 00:30:59.085
And there are also some other
handlers to detect the opening

00:30:59.085 --> 00:31:03.880
of the channel, the closing of
it, and errors and so on.

00:31:03.880 --> 00:31:11.490
So in our app, Go's support for
JSon encoding of native

00:31:11.490 --> 00:31:14.310
data types makes it really
clean and nice.

00:31:14.310 --> 00:31:17.380
We just define a message struct,
which is the structure

00:31:17.380 --> 00:31:21.480
of the message we want to
send to the client.

00:31:21.480 --> 00:31:27.060
And then we use this send
JSon function to send a

00:31:27.060 --> 00:31:31.370
JSon-encoded version of the Go
data structure to the client.

00:31:31.370 --> 00:31:34.040
Now, our message struct
contains four fields.

00:31:34.040 --> 00:31:36.750
The first is the total number
of tiles in the overlay.

00:31:36.750 --> 00:31:39.630
And the second is a list
of ids of tiles

00:31:39.630 --> 00:31:41.450
that have been processed.

00:31:41.450 --> 00:31:48.060
So in this second code snippet
here, this is what we do after

00:31:48.060 --> 00:31:51.120
processing a bunch of tiles.

00:31:51.120 --> 00:31:54.320
We send a message to the client
that contains the total

00:31:54.320 --> 00:31:58.050
number of tiles and the ids of
those tiles, and then the

00:31:58.050 --> 00:32:00.290
client adds them to a list
of tiles that it's

00:32:00.290 --> 00:32:02.960
keeping track of.

00:32:02.960 --> 00:32:05.730
The other two, fields TilesDone
and ZipDone are just

00:32:05.730 --> 00:32:09.180
boolean flags to indicate what
are the stage of the process.

00:32:09.180 --> 00:32:11.620
So once all of the tiles have
been computed and the slice

00:32:11.620 --> 00:32:16.210
task has detected this, it
sends this message, just

00:32:16.210 --> 00:32:19.690
setting the TilesDone equals
true, with send JSon.

00:32:19.690 --> 00:32:23.260
And then the final message that
the client will receive

00:32:23.260 --> 00:32:26.770
is the ZipDone message, so we
just send a message with

00:32:26.770 --> 00:32:29.920
ZipDone set to true.

00:32:29.920 --> 00:32:34.790
And on the client side, we set
up a channel by opening the

00:32:34.790 --> 00:32:38.160
socket and register
a message handler.

00:32:38.160 --> 00:32:42.970
And in the message handler, we
JSon decode that message and

00:32:42.970 --> 00:32:44.830
check the fields of the message
to see what kind of

00:32:44.830 --> 00:32:45.480
message it is.

00:32:45.480 --> 00:32:49.640
So if ZipDone is set to true, we
redirect the user's browser

00:32:49.640 --> 00:32:51.480
to the zip file.

00:32:51.480 --> 00:32:53.670
If TilesDone is set to true,
we display a creating zip

00:32:53.670 --> 00:32:54.940
archive message.

00:32:54.940 --> 00:32:57.725
And ids is set, it means that
we're getting progress

00:32:57.725 --> 00:33:00.630
information about the tiles
that have been computed.

00:33:00.630 --> 00:33:05.430
And so we add those ids to
a object named tiles.

00:33:05.430 --> 00:33:08.620
And this object just collects,
it's essentially a set of all

00:33:08.620 --> 00:33:09.990
of those tile ids.

00:33:09.990 --> 00:33:12.870
And this means if we receive ids
more than once, because a

00:33:12.870 --> 00:33:15.800
task has failed in some way,
it means that we're not

00:33:15.800 --> 00:33:17.090
counting tiles more than once.

00:33:17.090 --> 00:33:21.155
We won't end up showing 110% of
tiles being computed, say,

00:33:21.155 --> 00:33:23.590
if we received messages
more than oce.

00:33:23.590 --> 00:33:27.100
So it's just a form of
deduplication, essentially.

00:33:27.100 --> 00:33:29.980
And so we display a percentage
of the number of tiles that

00:33:29.980 --> 00:33:33.540
have been computed
in that case.

00:33:33.540 --> 00:33:36.550
So now we'll just
demonstrate a--

00:33:36.550 --> 00:33:38.360
Do you want to?

00:33:38.360 --> 00:33:39.400
CHRIS BROADFOOT: So hopefully
the demo gods

00:33:39.400 --> 00:33:41.610
will shine upon us.

00:33:41.610 --> 00:33:42.980
ANDREW GERRAND: Well, they
shined upon Sergei yesterday,

00:33:42.980 --> 00:33:45.630
so this is a much smaller ask.

00:33:45.630 --> 00:33:47.030
CHRIS BROADFOOT: I'm far less
worried than he was

00:33:47.030 --> 00:33:47.752
yesterday, as well.

00:33:47.752 --> 00:33:49.440
[LAUGHS]

00:33:49.440 --> 00:33:51.700
ANDREW GERRAND: So now we're
going to try a bit of a bigger

00:33:51.700 --> 00:34:00.870
image, which is Gotland, off
the coast of Sweden is it?

00:34:00.870 --> 00:34:05.250
And this is from USGS's--

00:34:05.250 --> 00:34:06.300
what's the project called?

00:34:06.300 --> 00:34:08.840
CHRIS BROADFOOT: I think it's
called The World As Art.

00:34:08.840 --> 00:34:11.889
So they've got some really
beautiful satellite imagery.

00:34:11.889 --> 00:34:13.710
This is one of my favorites,
it's called

00:34:13.710 --> 00:34:15.670
Van Gogh from space.

00:34:15.670 --> 00:34:19.429
So it's a photo of this island
and it's just some really

00:34:19.429 --> 00:34:21.630
amazing imagery.

00:34:21.630 --> 00:34:31.260
So if I go ahead and search for
Gotland, not Scotland, and

00:34:31.260 --> 00:34:33.440
drag and drop this image.

00:34:33.440 --> 00:34:37.219
You can actually see this
progress bar moving, so I was

00:34:37.219 --> 00:34:38.800
able to manipulate the image.

00:34:38.800 --> 00:34:43.340
I didn't, but it was just up
uploading in the background.

00:34:43.340 --> 00:34:46.670
And I can just position it.

00:34:46.670 --> 00:34:48.630
It's probably better to go into
satellite mode for this

00:34:48.630 --> 00:34:50.905
one and not back the opacity.

00:34:53.670 --> 00:34:55.249
Maybe if I zoom out--

00:34:55.249 --> 00:34:58.440
I'll just get it, I'm
not going to spend

00:34:58.440 --> 00:34:59.920
too long doing this.

00:35:04.810 --> 00:35:06.060
Apparently Andrew is much
better at this than me.

00:35:10.730 --> 00:35:11.610
ANDREW GERRAND: Just do it.

00:35:11.610 --> 00:35:12.200
CHRIS BROADFOOT:
Looks good, OK.

00:35:12.200 --> 00:35:14.640
Let's hit Process.

00:35:14.640 --> 00:35:16.920
This is quite a large
overlay, actually.

00:35:16.920 --> 00:35:19.080
ANDREW GERRAND: So now you can
see it's processing tiles.

00:35:19.080 --> 00:35:22.200
And if we look at the instances,
you can see there

00:35:22.200 --> 00:35:24.680
are four slice instances
that are being spun up.

00:35:24.680 --> 00:35:27.590
And if we look at the
task queues--

00:35:27.590 --> 00:35:28.960
it's refreshing now--

00:35:28.960 --> 00:35:31.900
at the bottom you can see
that there are 1,100

00:35:31.900 --> 00:35:33.040
tasks in the queue.

00:35:33.040 --> 00:35:35.160
And 180 have been leased
in the last minute.

00:35:35.160 --> 00:35:37.660
And so if we keep refreshing
while that's going, you see

00:35:37.660 --> 00:35:41.230
we're up to 17% now.

00:35:41.230 --> 00:35:43.450
More tasks have continued to
be leased, so they're being

00:35:43.450 --> 00:35:47.840
consumed from the queue
as it churns through.

00:35:47.840 --> 00:35:50.980
And we have the four instances
still running.

00:35:50.980 --> 00:35:52.890
And you can see their
CPU time--

00:35:52.890 --> 00:35:54.600
they're actually nor working
that hard, it must be data

00:35:54.600 --> 00:35:55.960
sort dominated.

00:35:55.960 --> 00:35:59.800
And then if I refresh the logs,
so we can actually see

00:35:59.800 --> 00:36:04.070
the active backend requests and
log messages being pushed

00:36:04.070 --> 00:36:12.320
through from the backend
in semi-real time.

00:36:12.320 --> 00:36:15.485
And so each one of these 10
tiles messages means that 10

00:36:15.485 --> 00:36:17.120
tiles have been computed.

00:36:17.120 --> 00:36:21.610
And so we can see it's
nearing completion.

00:36:21.610 --> 00:36:26.580
Oh, and I should also note you
can see in the slice queue,

00:36:26.580 --> 00:36:28.800
there are four tasks in the
queue and there are four

00:36:28.800 --> 00:36:29.840
running simultaneously.

00:36:29.840 --> 00:36:32.570
So that's our four
slices going.

00:36:36.290 --> 00:36:38.890
And you see there's actually
been one or two errors there,

00:36:38.890 --> 00:36:41.350
and they've just been gracefully
restarted and

00:36:41.350 --> 00:36:42.940
picked up again.

00:36:42.940 --> 00:36:47.120
And so now the zip archive is
being created on the backend,

00:36:47.120 --> 00:36:50.980
and it should be served to us.

00:36:50.980 --> 00:36:57.980
And then appear in our
downloads, which is this one.

00:37:03.767 --> 00:37:05.230
Is that it?

00:37:05.230 --> 00:37:07.590
Let's check the tiles.

00:37:07.590 --> 00:37:10.621
No, that's not one.

00:37:10.621 --> 00:37:13.870
It's this one.

00:37:13.870 --> 00:37:20.590
So now if I open the index dot
html, I'll see the overlay on

00:37:20.590 --> 00:37:21.170
the island.

00:37:21.170 --> 00:37:25.470
So if I zoom in, I'll start
to see the greater detail.

00:37:25.470 --> 00:37:26.720
Cool.

00:37:29.800 --> 00:37:32.440
CHRIS BROADFOOT: So, I just
want to talk a little bit

00:37:32.440 --> 00:37:37.340
about the reasons why we chose
Go to do this, as opposed to

00:37:37.340 --> 00:37:39.560
the Python or Java runtimes
on App Engine.

00:37:39.560 --> 00:37:43.070
So, first of all, Go has great
standard packages, which we

00:37:43.070 --> 00:37:45.630
took full advantage
of in this app.

00:37:45.630 --> 00:37:48.860
Next is their great external
package support, driven by

00:37:48.860 --> 00:37:51.190
really vibrant open-source
community.

00:37:51.190 --> 00:37:54.030
And we used a graphics Go
package just to perform the

00:37:54.030 --> 00:37:55.520
affine transformations.

00:37:55.520 --> 00:37:58.170
And that package is actually
built atop the it built-in

00:37:58.170 --> 00:37:59.980
image packages.

00:37:59.980 --> 00:38:02.760
And then there's this great site
go.pkgdoc which you can

00:38:02.760 --> 00:38:05.950
visit to get a list of the
thousands of packages that are

00:38:05.950 --> 00:38:07.020
available--

00:38:07.020 --> 00:38:08.680
of varying degrees of
quality, of course.

00:38:11.980 --> 00:38:16.840
The main reason for choosing Go
on App Engine for this task

00:38:16.840 --> 00:38:18.930
is that it's the only App Engine
run time that lets you

00:38:18.930 --> 00:38:23.590
run this user-provided code
in native machine code.

00:38:23.590 --> 00:38:25.190
So you get the full performance
of the machine

00:38:25.190 --> 00:38:26.180
that it's running on.

00:38:26.180 --> 00:38:29.240
It's not running on a virtual
machine, it's not virtualized,

00:38:29.240 --> 00:38:31.840
it's just real code running
on real cores.

00:38:31.840 --> 00:38:34.140
And so you can really crunch
some serious numbers with Go

00:38:34.140 --> 00:38:35.500
on App Engine.

00:38:35.500 --> 00:38:37.670
And finally, I think
I was just a great

00:38:37.670 --> 00:38:38.710
language all around.

00:38:38.710 --> 00:38:41.580
It's simple in its design.

00:38:41.580 --> 00:38:45.180
The language and the libraries
are consistent and easy to use

00:38:45.180 --> 00:38:46.430
when combined.

00:38:48.410 --> 00:38:51.410
It makes for a very
comprehensible and cohesive

00:38:51.410 --> 00:38:53.210
programing experience.

00:38:53.210 --> 00:38:55.830
And also, Go provides some great
concurrency primitives.

00:38:55.830 --> 00:38:59.010
And as we saw very briefly, I
was able to get a factor of

00:38:59.010 --> 00:39:02.070
two performance increase in
my App Engine app just by

00:39:02.070 --> 00:39:05.470
introducing a small amount of
concurrency in one of its core

00:39:05.470 --> 00:39:08.060
components.

00:39:08.060 --> 00:39:12.980
So the code for this app is
available in a Google Code

00:39:12.980 --> 00:39:15.570
project, overlay-tiler.

00:39:15.570 --> 00:39:17.690
And you may want to wait a few
minutes because we're going to

00:39:17.690 --> 00:39:21.380
push an update just
after this talk.

00:39:21.380 --> 00:39:23.610
If you want to learn more about
the Maps API, visit

00:39:23.610 --> 00:39:25.810
developers.google.com/maps.

00:39:25.810 --> 00:39:27.880
And similarly, to learn more
about App Engine this is the

00:39:27.880 --> 00:39:30.140
same domain slash App Engine.

00:39:30.140 --> 00:39:33.310
And to learn about Go, visit
golang.org which contains a

00:39:33.310 --> 00:39:36.380
wealth of documentation as well
as an interactive online

00:39:36.380 --> 00:39:41.550
tutorial, and some
other fun stuff.

00:39:41.550 --> 00:39:44.450
So thanks everyone for the
coming along today, on behalf

00:39:44.450 --> 00:39:46.870
of Chris and I. If you have any
questions we'll be happy

00:39:46.870 --> 00:39:48.630
to answer them now,
but thank you.

00:39:55.130 --> 00:39:58.960
Just step up to the mic if
you want to ask anything.

00:39:58.960 --> 00:40:01.020
Or not.

00:40:01.020 --> 00:40:04.020
Or you just all go to
the next thing.

00:40:04.020 --> 00:40:04.490
No?

00:40:04.490 --> 00:40:08.110
Cool

00:40:08.110 --> 00:40:11.050
AUDIENCE: Just curious about
how much compute power you

00:40:11.050 --> 00:40:16.540
used on that exercise in terms
of translating it to--

00:40:16.540 --> 00:40:17.260
ANDREW GERRAND: To costs?

00:40:17.260 --> 00:40:19.220
AUDIENCE: Yeah, cost or
running it on your own

00:40:19.220 --> 00:40:21.266
servers, sure?

00:40:21.266 --> 00:40:23.150
ANDREW GERRAND: So, my
understanding is these App

00:40:23.150 --> 00:40:24.620
instances cost--

00:40:24.620 --> 00:40:26.400
and the don't quote me-- but
it's somewhere in the realm of

00:40:26.400 --> 00:40:30.150
$0.10, $0.15 an hour because
they're at the highest ones

00:40:30.150 --> 00:40:30.700
that we have.

00:40:30.700 --> 00:40:34.260
But again, I'm not a 100%
sure on the cost.

00:40:34.260 --> 00:40:36.990
CHRIS BROADFOOT: Can we look
at the cost in the logs?

00:40:36.990 --> 00:40:39.290
ANDREW GERRAND: We probably can
but I don't want to, for

00:40:39.290 --> 00:40:40.540
reasons you know about.

00:40:42.530 --> 00:40:44.810
Not because it's high, but
because it shows some internal

00:40:44.810 --> 00:40:48.900
stuff because we're logged in
as our Google.com addresses.

00:40:48.900 --> 00:40:51.810
But you notice that there are
four instances running now.

00:40:51.810 --> 00:40:53.540
And because they're dynamic
instances, they'll actually

00:40:53.540 --> 00:40:56.470
only stick around for
5, 10 minutes max.

00:40:56.470 --> 00:40:59.460
And so you actually only pay
for a fraction of that hour

00:40:59.460 --> 00:41:01.780
for a bursty kind of
job like this.

00:41:01.780 --> 00:41:03.790
And said backends can either
be configured to run

00:41:03.790 --> 00:41:07.310
continuously, in which case you
just pay a constant rate,

00:41:07.310 --> 00:41:09.500
or if they're dynamic,
they'll just spin up

00:41:09.500 --> 00:41:10.450
when they're needed.

00:41:10.450 --> 00:41:11.490
And then they'll spin down.

00:41:11.490 --> 00:41:13.990
And you can actually control
when backends are started and

00:41:13.990 --> 00:41:16.950
stopped programmatically, as
well, using specially formed

00:41:16.950 --> 00:41:18.000
HTTP requests.

00:41:18.000 --> 00:41:19.250
Yeah?

00:41:22.640 --> 00:41:27.260
AUDIENCE: Can Cgo work with
this on App Engine?

00:41:27.260 --> 00:41:28.860
ANDREW GERRAND: Sorry,
can Cgo?

00:41:28.860 --> 00:41:31.200
So, the question was does Cgo
work with App Engine.

00:41:31.200 --> 00:41:36.900
And Cgo is a function call
interface for calling into C

00:41:36.900 --> 00:41:38.850
code from Go code.

00:41:38.850 --> 00:41:41.940
And the answer is no, the Go
App Engine runtime only

00:41:41.940 --> 00:41:46.260
supports Go code, because the
memory safety that we get from

00:41:46.260 --> 00:41:48.550
Go is what allows us
to run your code

00:41:48.550 --> 00:41:49.920
safely on our servers.

00:41:49.920 --> 00:41:52.420
Otherwise we wouldn't have
that security, C is a

00:41:52.420 --> 00:41:55.080
fundamentally unsafe language.

00:41:55.080 --> 00:41:56.330
Thanks.

00:41:59.740 --> 00:42:02.200
AUDIENCE: Just curious about
what kind of errors do you

00:42:02.200 --> 00:42:05.420
get, for example, for those
kind of task most times?

00:42:05.420 --> 00:42:10.470
Because it doesn't seem to be
that, it seems to be a bit

00:42:10.470 --> 00:42:11.100
frequently.

00:42:11.100 --> 00:42:14.420
And what kind of errors?

00:42:14.420 --> 00:42:16.425
ANDREW GERRAND: So, typically
the kind of errors that we see

00:42:16.425 --> 00:42:20.200
are in some cases, out
in memory errors.

00:42:20.200 --> 00:42:24.600
So if you have a particularly
large overlay and then you

00:42:24.600 --> 00:42:29.650
slice a large number of tiles,
if, in some cases the garbage

00:42:29.650 --> 00:42:32.030
collector hasn't caught up,
your app instance could be

00:42:32.030 --> 00:42:34.270
killed because it's
run out of memory.

00:42:34.270 --> 00:42:36.290
And we haven't seen a lot of
that, we've seen a few

00:42:36.290 --> 00:42:39.840
instances with some really
big overlays.

00:42:39.840 --> 00:42:42.090
Other things can happen are,
because App Engine is

00:42:42.090 --> 00:42:45.330
distributed across multiple
data centers, you can

00:42:45.330 --> 00:42:49.020
sometimes end up with hiccups
in the network, where a

00:42:49.020 --> 00:42:54.500
particular datastore request,
a put or a get, will be hung

00:42:54.500 --> 00:42:58.050
for longer than a particular
request deadline, and then

00:42:58.050 --> 00:42:59.460
your instance will be killed.

00:43:02.640 --> 00:43:04.510
It's basically just because
you working on a large,

00:43:04.510 --> 00:43:05.760
distributed system.

00:43:07.990 --> 00:43:12.640
We guarantee consistency,
but we don't guarantee--

00:43:12.640 --> 00:43:13.780
I don't know how to phrase
it properly.

00:43:13.780 --> 00:43:15.960
I probably should know.

00:43:15.960 --> 00:43:20.585
But yeah, basically in any
system, you get errors that

00:43:20.585 --> 00:43:21.760
you don't expect, right?

00:43:21.760 --> 00:43:23.930
So you have to design it
assuming that any particular

00:43:23.930 --> 00:43:25.180
part will fail.

00:43:28.650 --> 00:43:32.260
AUDIENCE: Hi, I'm actually the
developer of nettiler that you

00:43:32.260 --> 00:43:33.030
mentioned earlier.

00:43:33.030 --> 00:43:35.480
And I'd like to ask
you, what's the

00:43:35.480 --> 00:43:37.510
intended use of the system?

00:43:37.510 --> 00:43:41.240
Is it something public
or is it something

00:43:41.240 --> 00:43:42.610
internal for Google?

00:43:42.610 --> 00:43:49.860
And if it's public, what's the
biggest size of image that you

00:43:49.860 --> 00:43:53.320
are able to process
or what is it that

00:43:53.320 --> 00:43:55.360
you have tried already?

00:43:55.360 --> 00:43:57.170
CHRIS BROADFOOT: So
we definitely

00:43:57.170 --> 00:43:59.190
designed it to be public.

00:43:59.190 --> 00:44:01.890
So the source code is completely
available and--

00:44:01.890 --> 00:44:05.220
ANDREW GERRAND: But as a
service, we didn't design it

00:44:05.220 --> 00:44:07.840
to be launched as a Google
service or product.

00:44:07.840 --> 00:44:11.250
It's really just a pedagogical
exercise in learning about the

00:44:11.250 --> 00:44:13.990
Maps API and learning about
Go on App Engine.

00:44:13.990 --> 00:44:17.170
AUDIENCE: So if I wanted to,
I could run it on my own

00:44:17.170 --> 00:44:17.750
instance of App Engine.

00:44:17.750 --> 00:44:18.610
ANDREW GERRAND: Absolutely.

00:44:18.610 --> 00:44:19.900
AUDIENCE: It's not
a Google service.

00:44:19.900 --> 00:44:22.890
OK, I understand.

00:44:22.890 --> 00:44:24.090
ANDREW GERRAND: We were
running it on a public

00:44:24.090 --> 00:44:27.280
instance now, but for the
purposes of our demo it's not

00:44:27.280 --> 00:44:29.290
available to you all.

00:44:29.290 --> 00:44:32.150
It adds a level of
unpredictability.

00:44:32.150 --> 00:44:35.030
But we do intend to open that
up for people to use.

00:44:35.030 --> 00:44:40.400
But anyone's free to deploy it
wherever they want as well.

00:44:40.400 --> 00:44:43.470
AUDIENCE: And the question
about the image size.

00:44:43.470 --> 00:44:46.450
What is some upper limit made
that you have tried or

00:44:46.450 --> 00:44:48.470
something like that?

00:44:48.470 --> 00:44:53.070
ANDREW GERRAND: So the biggest
images we've put in have been

00:44:53.070 --> 00:44:56.750
between like 15, 20 megabytes
as a JPEG.

00:44:56.750 --> 00:45:01.730
And so image size, that's
approaching about 10,000

00:45:01.730 --> 00:45:04.730
pixels on a side.

00:45:04.730 --> 00:45:07.980
Between 7,000 or 8,000
pixels, maybe.

00:45:07.980 --> 00:45:09.840
CHRIS BROADFOOT: It's really
bounded by the size of the

00:45:09.840 --> 00:45:12.690
instances that we're
running on.

00:45:12.690 --> 00:45:16.160
So as Andrew mentioned, we were
running into some memory

00:45:16.160 --> 00:45:19.530
issues on larger overlays.

00:45:19.530 --> 00:45:21.460
ANDREW GERRAND: But nothing
that we weren't able to do

00:45:21.460 --> 00:45:22.710
solve in the end.

00:45:26.760 --> 00:45:29.640
So I think ultimately the upper
bound of the image you

00:45:29.640 --> 00:45:32.740
can load is one that you could
decode within the memory

00:45:32.740 --> 00:45:34.640
limits of a large App
Engine instance.

00:45:34.640 --> 00:45:38.830
And I think the limit is 1 gig,
you would have to check

00:45:38.830 --> 00:45:39.975
the website to be sure.

00:45:39.975 --> 00:45:41.580
Yeah?

00:45:41.580 --> 00:45:44.430
AUDIENCE: What is the workflow
like in developing and

00:45:44.430 --> 00:45:46.180
debugging an app that
is written in Go

00:45:46.180 --> 00:45:48.180
and runs on App Engine?

00:45:48.180 --> 00:45:53.860
ANDREW GERRAND: Right, so the Go
App Engine SDK is built on

00:45:53.860 --> 00:45:55.220
top of the Python SDK.

00:45:55.220 --> 00:45:58.250
So it comes with the same
development app server that

00:45:58.250 --> 00:46:00.780
you can use to run Python
apps locally.

00:46:00.780 --> 00:46:04.760
And so when you work on your
Go app, you launch the

00:46:04.760 --> 00:46:07.310
development app server and it
will automatically compile

00:46:07.310 --> 00:46:08.890
your Go app and run it.

00:46:08.890 --> 00:46:11.620
And then you can just
access it via

00:46:11.620 --> 00:46:13.980
local host, in a browser.

00:46:13.980 --> 00:46:17.030
If you make changes to your Go
source code, the code is

00:46:17.030 --> 00:46:18.120
recompiled.

00:46:18.120 --> 00:46:22.280
And so you get the same kind of
edit, refresh, test cycle

00:46:22.280 --> 00:46:25.790
that you get with scripted
web apps.

00:46:25.790 --> 00:46:28.890
And because Go code tends to
compile usually in sub-second

00:46:28.890 --> 00:46:34.340
times, usually sub
100-millisecond in some cases,

00:46:34.340 --> 00:46:36.616
you don't really notice the
difference between that and

00:46:36.616 --> 00:46:39.010
working on Python apps.

00:46:39.010 --> 00:46:41.980
In deployment it all feels
exactly the same as the other

00:46:41.980 --> 00:46:43.060
Python platforms.

00:46:43.060 --> 00:46:47.850
It uses the Python app cfg
tool for deployment.

00:46:50.640 --> 00:46:52.510
And one thing that's probably
worth mentioning is if you

00:46:52.510 --> 00:46:56.640
have existing Python or Java
App Engine apps, you can

00:46:56.640 --> 00:46:59.020
deploy backends that
run Go code.

00:46:59.020 --> 00:47:03.820
So if you already have some user
interface, you can write

00:47:03.820 --> 00:47:09.280
your heavy-lifting code in Go
and just have a hybrid set up

00:47:09.280 --> 00:47:10.810
like that, and there's
no issues there.

00:47:15.000 --> 00:47:17.020
Cool, well if there are no other
questions, thanks again

00:47:17.020 --> 00:47:18.660
everyone for coming along and
I'll see you at the rest of

00:47:18.660 --> 00:47:19.910
the conference.

