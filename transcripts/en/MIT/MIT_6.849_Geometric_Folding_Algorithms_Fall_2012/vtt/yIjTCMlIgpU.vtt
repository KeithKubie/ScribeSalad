WEBVTT
Kind: captions
Language: en

00:00:03.060 --> 00:00:06.830
PROFESSOR: OK,
welcome back to 6849.

00:00:06.830 --> 00:00:10.360
So last lecture,
lecture three, we

00:00:10.360 --> 00:00:14.200
were talking about
local foldability

00:00:14.200 --> 00:00:19.490
and some complicated flat
folding, like a flapping bird

00:00:19.490 --> 00:00:20.690
here.

00:00:20.690 --> 00:00:25.400
We were looking at a
single vertex and locally

00:00:25.400 --> 00:00:27.220
around that vertex
what properties

00:00:27.220 --> 00:00:28.750
it would have to have.

00:00:28.750 --> 00:00:31.854
And we saw Kawasaki's theorem
which characterized the angles.

00:00:31.854 --> 00:00:33.520
And without a mountain
valley assignment

00:00:33.520 --> 00:00:35.670
Kawasaki was all you needed.

00:00:35.670 --> 00:00:38.660
The alternating sum
of angles should be 0.

00:00:38.660 --> 00:00:43.130
And given a mountain
valley pattern, locally

00:00:43.130 --> 00:00:45.310
we characterize things
as a sequence, anything

00:00:45.310 --> 00:00:46.890
you can do by a
sequence of crimps.

00:00:46.890 --> 00:00:50.980
So sort of a similar
version to lecture

00:00:50.980 --> 00:00:53.550
two, which was about
1D flat foldability.

00:00:53.550 --> 00:00:55.720
There we needed
crimps and end folds.

00:00:55.720 --> 00:01:00.690
Here we needed just
crimps, which is easier.

00:01:00.690 --> 00:01:03.910
So I'm going to
jump into questions.

00:01:03.910 --> 00:01:07.280
And in particular, this
is an opportunity for me

00:01:07.280 --> 00:01:10.210
to talk about the main
thing that I skipped

00:01:10.210 --> 00:01:14.170
last class, class two,
because it relates again

00:01:14.170 --> 00:01:17.364
to this lecture, which is how
do we do this algorithmically?

00:01:17.364 --> 00:01:18.780
So it's one thing
to say, oh, just

00:01:18.780 --> 00:01:21.280
do crimps and end folds
till you can't anymore,

00:01:21.280 --> 00:01:24.080
and then when you run out of
stuff to do, if you're done,

00:01:24.080 --> 00:01:26.040
you're done, otherwise
it's not flat foldable.

00:01:26.040 --> 00:01:27.052
That's true.

00:01:27.052 --> 00:01:29.010
But the obvious way to
implement that algorithm

00:01:29.010 --> 00:01:30.800
is to sweep over
the crease pattern,

00:01:30.800 --> 00:01:32.380
look for any crimps
or end folds.

00:01:32.380 --> 00:01:35.290
If you find one, do it, and
then repeat and keep sweeping.

00:01:35.290 --> 00:01:37.020
And that would take
quadratic time,

00:01:37.020 --> 00:01:39.390
because in the worst
case every scan

00:01:39.390 --> 00:01:41.460
you have to look through
the whole pattern

00:01:41.460 --> 00:01:43.590
and at the very end you
find what you need to do.

00:01:43.590 --> 00:01:45.610
So after about n
operations-- n is

00:01:45.610 --> 00:01:47.480
the number of creases
in your pattern--

00:01:47.480 --> 00:01:49.605
you find what you need to
do, you do the operation,

00:01:49.605 --> 00:01:50.490
and then you repeat.

00:01:50.490 --> 00:01:55.050
So n plus n plus n, n
times, is n squared.

00:01:55.050 --> 00:01:57.560
But you can do
better and it's been

00:01:57.560 --> 00:02:01.087
alluded to in the lectures,
but it wasn't covered.

00:02:01.087 --> 00:02:03.295
And so I wanted to cover
it, because there's actually

00:02:03.295 --> 00:02:04.503
a really simple way to do it.

00:02:04.503 --> 00:02:06.770
There's one version
in the textbook,

00:02:06.770 --> 00:02:08.669
but there is a simpler way.

00:02:08.669 --> 00:02:13.370
So I want to talk about that.

00:02:13.370 --> 00:02:17.180
This is a new way we
just invented last week?

00:02:17.180 --> 00:02:17.680
This week?

00:02:17.680 --> 00:02:18.210
I forget.

00:02:21.210 --> 00:02:25.700
So I'm going to first talk
about it in the 1D scenario,

00:02:25.700 --> 00:02:29.920
but it's pretty much
the same for both.

00:02:33.411 --> 00:02:35.410
1D's a little bit easier
to think about, though.

00:02:50.670 --> 00:02:58.210
So 1D mountain valley
pattern something like this.

00:03:07.192 --> 00:03:09.150
So I'm going to follow
the same approach, which

00:03:09.150 --> 00:03:11.860
is sweep left to right
until I find either an end

00:03:11.860 --> 00:03:14.150
fold or a crimp that I can do.

00:03:14.150 --> 00:03:17.240
So in this case, maybe this
would be the first thing

00:03:17.240 --> 00:03:19.230
that I find sweeping
left to right.

00:03:19.230 --> 00:03:22.195
That's a crimpable pair--
or crimpable segment,

00:03:22.195 --> 00:03:25.710
I'm going to call it-- is just
one that is locally smallest.

00:03:25.710 --> 00:03:28.520
It's less than or equal to
its two neighbors in length,

00:03:28.520 --> 00:03:32.714
and it has two different
assignments, M/V or V/M.

00:03:32.714 --> 00:03:34.380
So that's a crimpable
pair, because it's

00:03:34.380 --> 00:03:36.630
shorter than those two guys.

00:03:36.630 --> 00:03:38.560
So that's the basic
algorithm, but what

00:03:38.560 --> 00:03:42.670
I do after that is going to
be a little bit different.

00:03:42.670 --> 00:03:56.830
So I want to search left to
right for a segment that's

00:03:56.830 --> 00:03:59.360
either crimpable
or end foldable.

00:04:10.140 --> 00:04:11.710
And there's two situations.

00:04:11.710 --> 00:04:18.170
If I don't find any operations
to do, then we stop.

00:04:18.170 --> 00:04:19.610
And if there are
any creases left

00:04:19.610 --> 00:04:21.250
we know that the
resulting thing is not

00:04:21.250 --> 00:04:24.044
flat foldable from what
we proved in lecture two.

00:04:24.044 --> 00:04:26.460
If there's no crimp or end
fold, you're not flat foldable.

00:04:29.260 --> 00:04:35.390
But if you do find
something, then do the fold.

00:04:35.390 --> 00:04:37.530
This is so far pretty obvious.

00:04:37.530 --> 00:04:41.060
I'm going to draw the picture
for a crimp situation.

00:04:41.060 --> 00:04:43.640
So in the crimp
situation-- these

00:04:43.640 --> 00:04:46.310
are the previous
and next creases--

00:04:46.310 --> 00:04:48.550
we have these
lengths x, y, and z.

00:04:48.550 --> 00:04:51.220
We know that y is less than
or equal to z and is less than

00:04:51.220 --> 00:04:52.900
or equal to x.

00:04:52.900 --> 00:04:58.470
And after we do the
crimp, it looks like this.

00:04:58.470 --> 00:05:02.410
So we have x, y, and
z here, but we're

00:05:02.410 --> 00:05:04.160
then going to fuse
this material together,

00:05:04.160 --> 00:05:06.160
because these creases
are done with.

00:05:06.160 --> 00:05:07.880
We don't really care about them.

00:05:07.880 --> 00:05:11.320
The new length that we
get is x minus y plus z.

00:05:14.110 --> 00:05:14.610
OK.

00:05:14.610 --> 00:05:16.800
So that's what I
mean by do the fold.

00:05:16.800 --> 00:05:26.359
And we'll also call this
sort of merging the segments,

00:05:26.359 --> 00:05:28.900
meaning replace-- so normally
we have a sequence of lengths--

00:05:28.900 --> 00:05:32.040
replace x, y, z with
x minus y plus z,

00:05:32.040 --> 00:05:36.470
remove these two creases
which were, say, M and V.

00:05:36.470 --> 00:05:38.340
Now we want to continue.

00:05:38.340 --> 00:05:40.210
And the realization
is that we don't

00:05:40.210 --> 00:05:42.970
have to start over our
search in searching

00:05:42.970 --> 00:05:45.330
left to right for
a crimpable thing.

00:05:45.330 --> 00:05:47.770
If we went all the way
through the pattern

00:05:47.770 --> 00:05:49.840
and then finally found
a crimp at the end,

00:05:49.840 --> 00:05:52.290
should we start way back here?

00:05:52.290 --> 00:05:52.790
No.

00:05:52.790 --> 00:05:53.530
There's no point.

00:05:53.530 --> 00:05:57.000
You might as well start
basically where you just were.

00:05:57.000 --> 00:05:58.250
Not quite.

00:05:58.250 --> 00:06:00.920
You have to go back one step.

00:06:00.920 --> 00:06:11.130
So the next step in this
algorithm is go back one step,

00:06:11.130 --> 00:06:13.510
and then continue the search.

00:06:13.510 --> 00:06:14.870
Back means left.

00:06:20.230 --> 00:06:25.851
And the search is this line.

00:06:25.851 --> 00:06:26.350
OK.

00:06:26.350 --> 00:06:30.510
So that's an algorithm,
a little loop there.

00:06:30.510 --> 00:06:37.870
So in this example we-- the
point of what's going on

00:06:37.870 --> 00:06:39.900
and the reason this
algorithm is correct

00:06:39.900 --> 00:06:42.300
is we just modified
these three segments.

00:06:42.300 --> 00:06:43.800
And we replaced
these three segments

00:06:43.800 --> 00:06:48.080
with a single segment which
looks something like that.

00:06:50.880 --> 00:06:54.050
And the rest, the parts to
the left and to the right

00:06:54.050 --> 00:06:55.290
are the same.

00:06:55.290 --> 00:06:57.150
I still claim we need
to back up one segment

00:06:57.150 --> 00:07:00.160
and look at this one again,
because now potentially

00:07:00.160 --> 00:07:03.190
this one might be crimpable
whereas it wasn't before.

00:07:03.190 --> 00:07:04.660
Because we changed
this length, it

00:07:04.660 --> 00:07:08.090
may have gotten
longer potentially.

00:07:08.090 --> 00:07:09.370
Or shorter.

00:07:09.370 --> 00:07:10.330
It could have changed.

00:07:10.330 --> 00:07:13.910
So this pair may be crimpable
whereas it wasn't before.

00:07:13.910 --> 00:07:17.265
So just to make sure,
we'll go left one step,

00:07:17.265 --> 00:07:19.530
and then we'll check, is
that segment crimpable?

00:07:19.530 --> 00:07:20.080
Is this one?

00:07:20.080 --> 00:07:20.950
Is this one?

00:07:20.950 --> 00:07:22.700
And just keep going.

00:07:22.700 --> 00:07:26.100
And I'm guessing
this pattern is not

00:07:26.100 --> 00:07:28.780
is not flat foldable
because of these two.

00:07:28.780 --> 00:07:32.025
We could check.

00:07:32.025 --> 00:07:34.350
Did I miss one?

00:07:34.350 --> 00:07:40.260
V, M, M. M is the little thing.

00:07:40.260 --> 00:07:41.804
So I think this
is going to crimp.

00:07:41.804 --> 00:07:43.220
And then this will
get end folded.

00:07:43.220 --> 00:07:47.580
But still this is a problem
because of the two M's.

00:07:47.580 --> 00:07:49.250
So this will not flat fold.

00:07:49.250 --> 00:07:51.400
We'll be left with
something like this,

00:07:51.400 --> 00:07:54.820
which is the two M's
and then we say, oh.

00:07:54.820 --> 00:07:55.960
We'll reach the stop case.

00:07:55.960 --> 00:07:57.570
Can't find a crimp
or and end fold

00:07:57.570 --> 00:07:58.944
and there are
still creases left.

00:07:58.944 --> 00:08:03.480
And so we know that
we're not flat foldable.

00:08:03.480 --> 00:08:09.970
But the reason I'm doing this
fast resume of the search,

00:08:09.970 --> 00:08:12.900
continuing the search
from one step to the left,

00:08:12.900 --> 00:08:14.970
is because we get a
good running time.

00:08:19.870 --> 00:08:22.850
I'm going to use running
time notation of order n.

00:08:22.850 --> 00:08:25.131
This means some
constant times n.

00:08:25.131 --> 00:08:27.630
We don't really care what the
constant is, but the growth is

00:08:27.630 --> 00:08:30.930
linear in the number
of creases that's n.

00:08:30.930 --> 00:08:37.980
And the reason it's
linear is that the number

00:08:37.980 --> 00:08:43.320
of rightward steps
that we make is

00:08:43.320 --> 00:08:46.140
going to be equal to n plus
the number of leftward steps.

00:08:51.140 --> 00:08:51.730
Why is that?

00:08:51.730 --> 00:08:54.651
Because overall the search
is going left to right,

00:08:54.651 --> 00:08:56.900
and if it doesn't find
anything it just takes n steps.

00:08:56.900 --> 00:08:58.900
You look at all the creases
or all the segments.

00:08:58.900 --> 00:09:02.781
It's basically n,
n plus 1, whatever.

00:09:02.781 --> 00:09:05.030
For each one, you check is
it crimpable, end foldable.

00:09:05.030 --> 00:09:06.071
That takes constant time.

00:09:06.071 --> 00:09:09.130
You're just comparing
a couple of numbers.

00:09:09.130 --> 00:09:11.820
So I'm counting the
number of rightward steps.

00:09:11.820 --> 00:09:14.090
The trouble with the
search is that every time I

00:09:14.090 --> 00:09:16.950
find a fold to do
I go back one step

00:09:16.950 --> 00:09:18.700
and so I'm kind
of losing progress

00:09:18.700 --> 00:09:19.800
because I go backwards.

00:09:19.800 --> 00:09:21.860
There's actually two
reasons why that's OK.

00:09:21.860 --> 00:09:25.270
One is you're also decreasing
n at the same time,

00:09:25.270 --> 00:09:28.090
because you're replacing
3 things with 1 thing,

00:09:28.090 --> 00:09:29.510
so n goes down by 2.

00:09:29.510 --> 00:09:36.740
But also, in order to
make a rightward step

00:09:36.740 --> 00:09:39.600
either it's in the
full search or it's

00:09:39.600 --> 00:09:42.010
because you went back one and
you have to go right again.

00:09:42.010 --> 00:09:43.630
So this is true.

00:09:43.630 --> 00:09:47.440
And the point is the number
of leftward steps is also

00:09:47.440 --> 00:09:50.970
at most n, because
every time you

00:09:50.970 --> 00:09:52.670
do a leftward step
you did a fold,

00:09:52.670 --> 00:09:54.680
and there's only
n folds to make.

00:09:54.680 --> 00:09:58.360
So-- it's actually less,
because crimps do two at a time.

00:09:58.360 --> 00:10:01.641
But the point is
this is at most 2n.

00:10:01.641 --> 00:10:04.250
And so the number of rightward
steps we make is linear.

00:10:04.250 --> 00:10:07.400
And so the overall
running time is linear.

00:10:07.400 --> 00:10:10.371
For the algorithms people, this
is a very simple amortization

00:10:10.371 --> 00:10:10.870
argument.

00:10:10.870 --> 00:10:13.520
We're charging the
leftward steps to the folds

00:10:13.520 --> 00:10:15.350
that we're doing.

00:10:15.350 --> 00:10:18.399
So that's an easy way to
do 1D flat foldability

00:10:18.399 --> 00:10:19.940
testing for mountain
valley patterns.

00:10:19.940 --> 00:10:20.900
Yes?

00:10:20.900 --> 00:10:23.560
AUDIENCE: Why do you
need to go back a step?

00:10:23.560 --> 00:10:25.920
So, the segment
that you labelled x,

00:10:25.920 --> 00:10:30.750
its new length is x plus
the quantity z minus y,

00:10:30.750 --> 00:10:32.591
and z is greater than y.

00:10:32.591 --> 00:10:36.740
So it's x plus a
positive number, right?

00:10:36.740 --> 00:10:42.110
So it's only increasing
in length, not decreasing.

00:10:42.110 --> 00:10:44.020
PROFESSOR: Only increasing.

00:10:44.020 --> 00:10:46.340
But that's of interest, right?

00:10:46.340 --> 00:10:51.910
Because if you had something
that wasn't crimpable

00:10:51.910 --> 00:10:57.780
because this was too short, and
then-- OK, here's an example.

00:10:57.780 --> 00:10:59.100
Good question.

00:10:59.100 --> 00:11:00.560
I hadn't thoroughly checked.

00:11:00.560 --> 00:11:02.110
So we scan.

00:11:02.110 --> 00:11:05.250
This guy's not crimpable
because this guy's too short.

00:11:05.250 --> 00:11:09.050
Then we reach-- suppose
then we jump to this guy.

00:11:09.050 --> 00:11:12.300
I'll do valley mountain to make
this definitely not crimpable.

00:11:12.300 --> 00:11:13.350
We look at this guy.

00:11:13.350 --> 00:11:15.110
We do the crimp.

00:11:15.110 --> 00:11:18.710
And now suddenly we have
this nice big length.

00:11:18.710 --> 00:11:22.180
And so now this
pair is crimpable.

00:11:22.180 --> 00:11:22.680
Good.

00:11:22.680 --> 00:11:24.346
So that's why we need
to go back a step.

00:11:24.346 --> 00:11:25.850
After we crimp
this guy, this one

00:11:25.850 --> 00:11:28.776
becomes crimpable
if it wasn't before.

00:11:28.776 --> 00:11:30.177
Yeah.

00:11:30.177 --> 00:11:32.260
I could have easily believed
that this step wasn't

00:11:32.260 --> 00:11:34.070
necessary, but it
definitely doesn't hurt

00:11:34.070 --> 00:11:36.760
and it is indeed necessary.

00:11:36.760 --> 00:11:39.380
The key is that we don't have
to back up more than one step,

00:11:39.380 --> 00:11:43.039
because we're only changing
our neighbors, basically.

00:11:43.039 --> 00:11:44.580
Other questions
about this algorithm?

00:11:47.240 --> 00:11:49.960
OK, well once we have this for--
this is really for lecture two

00:11:49.960 --> 00:11:53.640
material, we can adapt it to
lecture three material, which

00:11:53.640 --> 00:11:54.910
is the circular case.

00:11:54.910 --> 00:11:57.540
Instead of having a line
we have a circle of paper.

00:11:57.540 --> 00:12:00.110
In that case, we only
need to look for crimps,

00:12:00.110 --> 00:12:02.205
and so we do the same
thing for crimps.

00:12:07.990 --> 00:12:14.980
I don't think I really need to
write this down, but algorithm

00:12:14.980 --> 00:12:19.895
for a single vertex
mountain valley pattern.

00:12:23.960 --> 00:12:25.710
It's basically the
same algorithm.

00:12:25.710 --> 00:12:29.040
Instead of wherever
you see left and right

00:12:29.040 --> 00:12:32.050
you replace it with clockwise
and counterclockwise

00:12:32.050 --> 00:12:34.595
going around in a circle.

00:12:34.595 --> 00:12:35.970
There's no obvious
starting point

00:12:35.970 --> 00:12:38.440
you just start at an arbitrary
segment, which in this case

00:12:38.440 --> 00:12:41.160
is an angle of the
crease pattern.

00:12:41.160 --> 00:12:43.905
Maybe I should draw a
little crease pattern, just

00:12:43.905 --> 00:12:46.265
for a picture.

00:12:48.802 --> 00:12:50.510
So you start, let's
say, at this segment.

00:12:50.510 --> 00:12:53.010
You see is this pair crimpable.

00:12:53.010 --> 00:12:56.670
If not continue,
let's say, clockwise.

00:12:56.670 --> 00:12:57.950
Keep going.

00:12:57.950 --> 00:13:00.436
If you ever find a crimpable
pair, like these two guys--

00:13:00.436 --> 00:13:01.810
maybe this is
mountain and valley

00:13:01.810 --> 00:13:03.940
and this is a locally
smallest angle--

00:13:03.940 --> 00:13:08.360
you do the crimp, meaning
you replace this angle x y

00:13:08.360 --> 00:13:13.610
and z with x minus y
plus z, just as before.

00:13:13.610 --> 00:13:17.270
And then you step
counterclockwise one step.

00:13:17.270 --> 00:13:19.040
And the point is
the invariant you're

00:13:19.040 --> 00:13:23.365
maintaining at all times during
this algorithm, the interval

00:13:23.365 --> 00:13:26.950
of the segments from the very
first segment you went to,

00:13:26.950 --> 00:13:28.480
up to but not
including the segment

00:13:28.480 --> 00:13:30.310
you're currently
looking at, those

00:13:30.310 --> 00:13:33.160
are all guaranteed not
crimpable at the moment.

00:13:33.160 --> 00:13:35.873
And so when you do a crimp,
that may invalidate this one,

00:13:35.873 --> 00:13:37.480
and so you have to step
backwards because you're not

00:13:37.480 --> 00:13:39.257
sure whether that one's
crimpable anymore.

00:13:39.257 --> 00:13:40.590
But you maintain that invariant.

00:13:40.590 --> 00:13:46.195
And so when if you ever get
back to the original angle

00:13:46.195 --> 00:13:49.440
that you were considering,
the original segment,

00:13:49.440 --> 00:13:52.270
then you know that in fact
everything is not crimpable,

00:13:52.270 --> 00:13:54.190
and then you're in trouble.

00:13:54.190 --> 00:13:55.360
Maybe.

00:13:55.360 --> 00:13:57.440
Except for this issue
which I also forgot about

00:13:57.440 --> 00:14:00.590
in lecture three-- I mean, I
didn't forget about this time,

00:14:00.590 --> 00:14:03.370
but I forgot about it then--
which is in the base case.

00:14:06.040 --> 00:14:08.900
You can never actually do
everything by crimping,

00:14:08.900 --> 00:14:11.230
because at the
very end your hope

00:14:11.230 --> 00:14:14.281
is that you have a cone
with two creases that

00:14:14.281 --> 00:14:15.530
are both the same orientation.

00:14:18.740 --> 00:14:19.720
That is your goal.

00:14:19.720 --> 00:14:22.220
You know that there's two more
mountains or two more valleys

00:14:22.220 --> 00:14:23.870
and crimps pair them up.

00:14:23.870 --> 00:14:26.900
So you hope that you end
up with the situation.

00:14:26.900 --> 00:14:31.000
If you do, and these
two angles are equal,

00:14:31.000 --> 00:14:32.640
then you're flat foldable.

00:14:32.640 --> 00:14:35.650
You have that one
last fold to make.

00:14:35.650 --> 00:14:39.140
Otherwise, if you have anything
else, you're not flat foldable.

00:14:39.140 --> 00:14:40.770
That's what we proved
in lecture three,

00:14:40.770 --> 00:14:43.061
is that crimps are enough to
get down to this situation

00:14:43.061 --> 00:14:44.650
where you have only
two creases left,

00:14:44.650 --> 00:14:48.840
and that's what's foldable
when you only have two creases.

00:14:48.840 --> 00:14:51.750
OK so this is becoming a cone
as soon as you do operations.

00:14:51.750 --> 00:14:55.040
It's just like the
analysis we did.

00:14:55.040 --> 00:14:57.257
But this algorithm
will run in linear time

00:14:57.257 --> 00:14:58.090
for the same reason.

00:14:58.090 --> 00:15:01.020
The number of clockwise
steps equals at most n

00:15:01.020 --> 00:15:04.100
plus the number of
counterclockwise steps.

00:15:04.100 --> 00:15:08.670
And so I guess I should
maybe write "at most."

00:15:08.670 --> 00:15:10.679
And so this is
linear time as well.

00:15:10.679 --> 00:15:12.220
Any questions about
those algorithms?

00:15:14.945 --> 00:15:15.445
Yeah.

00:15:15.445 --> 00:15:17.070
AUDIENCE: For the
simple one, could you

00:15:17.070 --> 00:15:20.360
run into some edge case
where the very last crimp

00:15:20.360 --> 00:15:24.324
you considered makes the
very first one, which

00:15:24.324 --> 00:15:25.990
wasn't crimpable,
crimpable and then you

00:15:25.990 --> 00:15:29.174
have to go around
the circle again?

00:15:29.174 --> 00:15:30.170
PROFESSOR: Ah.

00:15:30.170 --> 00:15:30.670
OK.

00:15:30.670 --> 00:15:31.340
Good question.

00:15:34.550 --> 00:15:35.050
Right.

00:15:35.050 --> 00:15:37.780
So we said, OK, this is
guaranteed not crimpable,

00:15:37.780 --> 00:15:41.530
but if you then crimp
the very last segment

00:15:41.530 --> 00:15:45.570
this one may become crimpable,
and then that may propagate

00:15:45.570 --> 00:15:48.020
and force you to go
around a second time.

00:15:48.020 --> 00:15:50.630
AUDIENCE: So if that happens
at each step, then at each step

00:15:50.630 --> 00:15:53.306
you go all the way around,
and it could become quadratic.

00:15:53.306 --> 00:15:53.710
PROFESSOR: Ooh, interesting.

00:15:53.710 --> 00:15:54.610
AUDIENCE: But I'm
not sure if it's

00:15:54.610 --> 00:15:56.734
possible for that to
happen every step.

00:16:00.074 --> 00:16:00.740
PROFESSOR: Good.

00:16:00.740 --> 00:16:02.921
Well, this is the nature
of new algorithms.

00:16:02.921 --> 00:16:03.420
Yeah.

00:16:03.420 --> 00:16:08.180
AUDIENCE: The set of
possibly crimpable things

00:16:08.180 --> 00:16:11.640
increases by at most 1 every
time-- or at most 2 every time

00:16:11.640 --> 00:16:13.014
you make a crimp.

00:16:13.014 --> 00:16:13.680
PROFESSOR: Yeah.

00:16:13.680 --> 00:16:16.510
So certainly you will only have
to go around at most n times,

00:16:16.510 --> 00:16:20.520
but a quadratic bound
overall is not very exciting.

00:16:20.520 --> 00:16:23.200
AUDIENCE: So it stays linear.

00:16:23.200 --> 00:16:26.940
The interval in which things
are possibly crimpable

00:16:26.940 --> 00:16:29.612
expands by at most 2 every
time you make a crimp.

00:16:29.612 --> 00:16:30.320
PROFESSOR: I see.

00:16:30.320 --> 00:16:31.010
OK.

00:16:31.010 --> 00:16:33.390
So this is a different
algorithm, unfortunately.

00:16:33.390 --> 00:16:35.135
But you maintain the
interval of things

00:16:35.135 --> 00:16:36.510
that are guaranteed
not crimpable

00:16:36.510 --> 00:16:40.007
and you can look at
both ends whether you

00:16:40.007 --> 00:16:40.840
can crimp something.

00:16:40.840 --> 00:16:42.384
If you can, fine, you do it.

00:16:42.384 --> 00:16:43.925
You shrink the
interval a little bit.

00:16:43.925 --> 00:16:46.475
So in general your interval
is-- I have colored chalk,

00:16:46.475 --> 00:16:50.930
I should use it-- your
interval is an interval.

00:16:50.930 --> 00:16:54.650
It starts somewhere,
ends somewhere.

00:16:54.650 --> 00:16:56.550
And you're checking
is this guy crimpable.

00:16:56.550 --> 00:16:58.230
If it's not crimpable
you can extend

00:16:58.230 --> 00:16:59.440
the interval a little bit.

00:16:59.440 --> 00:17:01.260
If it is crimpable
you do the fold

00:17:01.260 --> 00:17:04.233
and you actually shrink
the interval a little bit.

00:17:04.233 --> 00:17:06.524
But every time you shrink
the interval, you did a fold,

00:17:06.524 --> 00:17:08.050
and that only happens n times.

00:17:08.050 --> 00:17:10.341
Every time you grow the
interval, you grew the interval

00:17:10.341 --> 00:17:12.740
and you can only grow n times.

00:17:12.740 --> 00:17:14.048
Good.

00:17:14.048 --> 00:17:15.589
So that will clean
up this situation.

00:17:15.589 --> 00:17:17.297
If this ends up being
crimpable, you just

00:17:17.297 --> 00:17:19.599
shrink the interval
from the other side.

00:17:19.599 --> 00:17:21.430
So I guess if I
wanted to just tweak

00:17:21.430 --> 00:17:24.849
this algorithm I would
change the notion of first.

00:17:24.849 --> 00:17:28.369
So I said, oh, this guy is
the first one that I visited.

00:17:28.369 --> 00:17:30.340
But if I end up
crimping this guy,

00:17:30.340 --> 00:17:34.628
I have to advance the first
to be the very next interval.

00:17:34.628 --> 00:17:35.921
Good.

00:17:35.921 --> 00:17:36.420
Thank you.

00:18:07.048 --> 00:18:07.580
All right.

00:18:07.580 --> 00:18:09.630
I'll correct that in
the notes as well.

00:18:09.630 --> 00:18:11.206
It was almost correct.

00:18:11.206 --> 00:18:12.580
Think now that
should be correct.

00:18:12.580 --> 00:18:14.170
Thanks for checking.

00:18:14.170 --> 00:18:16.450
And now we can do
it in linear time.

00:18:16.450 --> 00:18:19.507
There's a different
algorithm in the textbook,

00:18:19.507 --> 00:18:20.840
which uses more data structures.

00:18:20.840 --> 00:18:22.670
This I like because
it's very simple.

00:18:22.670 --> 00:18:27.020
It's just, like, storing
two pointers and that's it.

00:18:27.020 --> 00:18:29.720
Other questions?

00:18:29.720 --> 00:18:30.230
OK.

00:18:30.230 --> 00:18:31.500
That does algorithms.

00:18:31.500 --> 00:18:36.600
That was the new material
I wanted to cover.

00:18:36.600 --> 00:18:40.250
Then there is the other--
the actual algorithm that

00:18:40.250 --> 00:18:43.171
was briefly described in class
is this local foldability

00:18:43.171 --> 00:18:43.670
algorithm.

00:18:43.670 --> 00:18:46.560
So you have now not
just a single vertex,

00:18:46.560 --> 00:18:48.160
but you have a whole
crease pattern.

00:18:48.160 --> 00:18:52.385
You'd like to assign a mountain
valley assignment to it that

00:18:52.385 --> 00:18:54.670
is at least locally
good, that when

00:18:54.670 --> 00:18:57.330
you run this algorithm
at each vertex it gives

00:18:57.330 --> 00:18:59.940
the right answer, it
says that, yeah, it's

00:18:59.940 --> 00:19:01.590
locally foldable
for each vertex.

00:19:01.590 --> 00:19:04.330
It doesn't mean the whole
thing will fold flat,

00:19:04.330 --> 00:19:06.690
but it's a start, at least.

00:19:06.690 --> 00:19:10.030
It's a necessary
condition for that.

00:19:10.030 --> 00:19:11.879
So I just want to give
you a few examples

00:19:11.879 --> 00:19:13.670
of this algorithm,
because it is confusing.

00:19:13.670 --> 00:19:15.820
I didn't do any
examples in lecture.

00:19:15.820 --> 00:19:17.890
It's always been the most
confusing part to me,

00:19:17.890 --> 00:19:24.127
and especially this notion
of merging cycles and paths.

00:19:24.127 --> 00:19:26.460
So for starters, these are
the examples in the textbook.

00:19:26.460 --> 00:19:30.210
They're pretty simple, but at
least they'll get us warmed up.

00:19:30.210 --> 00:19:33.305
So the crease pattern
is the bold black lines.

00:19:33.305 --> 00:19:34.880
It's two of them.

00:19:34.880 --> 00:19:37.520
And in this case it's
the generic case,

00:19:37.520 --> 00:19:40.500
so there's a unique
pairing here.

00:19:40.500 --> 00:19:43.240
There's only one crimpable
pair, which are these two guys.

00:19:43.240 --> 00:19:45.850
This is the only
locally smallest angle.

00:19:45.850 --> 00:19:47.566
So those two have
to be crimped first.

00:19:47.566 --> 00:19:49.940
One's going to be a mountain,
one's going to be a valley.

00:19:49.940 --> 00:19:52.450
So we would write not
equals in this blue thing

00:19:52.450 --> 00:19:54.032
to represent that constraint.

00:19:54.032 --> 00:19:55.240
This will be all that's left.

00:19:55.240 --> 00:19:57.230
And so these two guys
have to be equal.

00:19:57.230 --> 00:20:00.410
It's symmetric, so it looks
the same all the way around.

00:20:00.410 --> 00:20:03.500
And so when you see, OK, these
two guys have to be not equal,

00:20:03.500 --> 00:20:05.720
but also these two guys
have to be not equal,

00:20:05.720 --> 00:20:07.790
but also these two guys
have to be not equal,

00:20:07.790 --> 00:20:10.580
this is what we call a
cycle of constraints.

00:20:10.580 --> 00:20:11.860
In general, you get paths.

00:20:11.860 --> 00:20:14.172
Like, this one starts
and ends at infinity,

00:20:14.172 --> 00:20:15.630
so these two guys
have to be equal,

00:20:15.630 --> 00:20:16.650
these two guys have to be equal.

00:20:16.650 --> 00:20:19.420
They could both be mountain,
both be valley, doesn't matter.

00:20:19.420 --> 00:20:21.200
These are the only constraints.

00:20:21.200 --> 00:20:23.460
But this cycle--
cycles can be problems,

00:20:23.460 --> 00:20:25.310
and here because it's
an odd cycle of not

00:20:25.310 --> 00:20:27.580
equals there's no
way to assign it.

00:20:27.580 --> 00:20:29.666
If you say mountain,
valley, mountain,

00:20:29.666 --> 00:20:31.290
then these two guys
are both mountains,

00:20:31.290 --> 00:20:33.350
which violates that constraint.

00:20:33.350 --> 00:20:36.620
In general, the
number of not equals

00:20:36.620 --> 00:20:38.980
should be even in each cycle.

00:20:38.980 --> 00:20:43.010
If it's ever an odd number of
not equals, you're in trouble.

00:20:43.010 --> 00:20:46.770
Here's an example where
the cycle is even,

00:20:46.770 --> 00:20:48.730
but we end up with
an equals here,

00:20:48.730 --> 00:20:51.200
and so the number of
not equals is still odd,

00:20:51.200 --> 00:20:52.510
so this is also bad.

00:20:52.510 --> 00:20:57.480
I mean, it's just replacing this
segment with two equal creases.

00:20:57.480 --> 00:21:00.290
Still can't assign a
mountain or valley.

00:21:00.290 --> 00:21:03.310
But these are kind
of simple examples.

00:21:03.310 --> 00:21:05.900
These are cycles and everything
was uniquely determined here.

00:21:05.900 --> 00:21:08.200
You had to crimp this guy first.

00:21:08.200 --> 00:21:09.900
You had to crimp this guy first.

00:21:09.900 --> 00:21:11.280
There was no choice.

00:21:11.280 --> 00:21:13.300
And the tricky part
of the algorithm

00:21:13.300 --> 00:21:15.870
is when you have choice, when
you have multiple equal angles,

00:21:15.870 --> 00:21:17.420
you don't know what
to crimp first.

00:21:17.420 --> 00:21:19.839
The algorithm just
crimps one of them first,

00:21:19.839 --> 00:21:21.380
but then it might
have to fix things.

00:21:21.380 --> 00:21:22.867
So I came up with
a simple example

00:21:22.867 --> 00:21:23.950
where you have to do that.

00:21:23.950 --> 00:21:29.650
I think it will help clarify
how this merging really happens.

00:21:29.650 --> 00:21:40.470
So the example is-- it's hard
to draw an equilateral triangle

00:21:40.470 --> 00:21:43.650
with accurate angles,
but I'll do my best--

00:21:43.650 --> 00:21:46.550
and then these are supposed
to be right angles.

00:21:53.150 --> 00:21:53.650
OK.

00:21:53.650 --> 00:21:54.816
So that's my crease pattern.

00:21:57.430 --> 00:21:58.835
And some of this is forced.

00:22:02.230 --> 00:22:05.690
This guy-- at this vertex, this
is the only locally smallest

00:22:05.690 --> 00:22:06.190
angle.

00:22:06.190 --> 00:22:07.780
It's only 60 degrees,
these are 90.

00:22:07.780 --> 00:22:09.220
This is bigger than 90.

00:22:09.220 --> 00:22:12.607
So this has to be crimped
first, and it's not equal.

00:22:12.607 --> 00:22:13.940
That means these guys are equal.

00:22:13.940 --> 00:22:15.315
We don't really
care about those.

00:22:15.315 --> 00:22:20.010
And it's symmetric,
so not equal, equal.

00:22:20.010 --> 00:22:21.250
OK.

00:22:21.250 --> 00:22:22.370
But here we have a choice.

00:22:22.370 --> 00:22:23.832
There's two 60 degree angles.

00:22:23.832 --> 00:22:25.415
This does not look
very flat foldable.

00:22:25.415 --> 00:22:31.180
I think I'd better add
some more creases there.

00:22:31.180 --> 00:22:34.350
Got to have to even
parity at every vertex.

00:22:34.350 --> 00:22:35.350
So now we have a choice.

00:22:35.350 --> 00:22:38.630
Do we crimp this one first or
do we crimp the other one first?

00:22:38.630 --> 00:22:41.860
At this point, it's symmetric,
so I'll do this one first.

00:22:41.860 --> 00:22:44.279
This'll be my pairing.

00:22:44.279 --> 00:22:45.820
And there are two
possibilities here.

00:22:45.820 --> 00:22:47.750
Either I crimp this one first
or crimp this one first.

00:22:47.750 --> 00:22:48.790
The algorithm doesn't care.

00:22:48.790 --> 00:22:50.748
So let's suppose it does
this one, because this

00:22:50.748 --> 00:22:52.380
is the bad one.

00:22:52.380 --> 00:22:52.880
OK.

00:22:52.880 --> 00:22:57.390
Now we have a cycle with
an odd number not equals.

00:22:57.390 --> 00:23:00.475
So this is not
possible to satisfy.

00:23:00.475 --> 00:23:01.850
The algorithm
doesn't stop there.

00:23:01.850 --> 00:23:05.710
It says, OK, I have these paths.

00:23:05.710 --> 00:23:09.270
There's a cycle here
that's a problem,

00:23:09.270 --> 00:23:13.325
then I also have a path up here.

00:23:13.325 --> 00:23:13.950
How does it go?

00:23:13.950 --> 00:23:20.660
There's a path that goes
here, here, here, here.

00:23:20.660 --> 00:23:23.860
And there's a path
that goes here.

00:23:23.860 --> 00:23:26.350
But really it looks at the
vertices that had choice.

00:23:26.350 --> 00:23:29.770
It says, look, at
this moment I had

00:23:29.770 --> 00:23:32.210
a choice between whether to
fold this angle or this angle.

00:23:32.210 --> 00:23:35.210
In general, it might have
been a bunch of equal angles.

00:23:35.210 --> 00:23:40.290
We see here that there's a cycle
that the other choice would've

00:23:40.290 --> 00:23:42.320
involved a path.

00:23:42.320 --> 00:23:43.900
And so we merge.

00:23:43.900 --> 00:23:48.050
In general, if there's
two different things--

00:23:48.050 --> 00:23:49.800
one could be a cycle,
one could be a path,

00:23:49.800 --> 00:23:51.966
they could both be cycles,
they could both be paths,

00:23:51.966 --> 00:23:54.460
whatever-- if I ever
have the opportunity

00:23:54.460 --> 00:23:58.650
to join those two parts
together I'll do it.

00:23:58.650 --> 00:24:01.362
So in other words, I do
the other crease first.

00:24:01.362 --> 00:24:02.070
Let me draw that.

00:24:06.930 --> 00:24:12.820
What that means will become
clear once we actually do one.

00:24:12.820 --> 00:24:16.090
So I want to do this first.

00:24:16.090 --> 00:24:17.070
The rest is the same.

00:24:30.010 --> 00:24:30.610
OK.

00:24:30.610 --> 00:24:34.930
So in that situation, what do
my paths and cycle look like?

00:24:34.930 --> 00:24:37.380
Well, there was this path
that started over here.

00:24:37.380 --> 00:24:40.530
It used to go like this, but
now this vertex has changed.

00:24:40.530 --> 00:24:44.480
So it's going to do something
different at that vertex.

00:24:44.480 --> 00:24:46.450
Now it goes over this way.

00:24:46.450 --> 00:24:49.240
I'm just following
the constraints.

00:24:49.240 --> 00:24:52.217
Now those two guys are
constrained to be different.

00:24:52.217 --> 00:24:53.800
And these are
constrained to be equal.

00:24:53.800 --> 00:24:56.100
So lo and behold we merged
a path and the cycle

00:24:56.100 --> 00:24:57.520
and we got a single path.

00:24:57.520 --> 00:24:59.740
The other paths remain the same.

00:24:59.740 --> 00:25:01.420
Just these two guys
got interchanged.

00:25:01.420 --> 00:25:05.050
What we're doing is basically
turning here and turning here

00:25:05.050 --> 00:25:08.210
instead of going that
way and going that way.

00:25:08.210 --> 00:25:10.760
And whenever you have two pieces
like this, and one of which

00:25:10.760 --> 00:25:13.212
is a cycle, you will do a merge.

00:25:13.212 --> 00:25:14.920
Merging can only help
us, because they'll

00:25:14.920 --> 00:25:16.496
get bigger and
bigger and bigger.

00:25:16.496 --> 00:25:18.150
The bigger these
sets of constraints

00:25:18.150 --> 00:25:20.380
are, essentially,
the better chance

00:25:20.380 --> 00:25:22.370
that you'll get
the parity right.

00:25:22.370 --> 00:25:25.230
I can never-- and this
is argued in the notes,

00:25:25.230 --> 00:25:31.650
but few-- it never hurts to
merge something, is the point.

00:25:31.650 --> 00:25:34.180
And if you're lucky-- if you,
say, merge two odd cycles--

00:25:34.180 --> 00:25:36.320
they will become even.

00:25:36.320 --> 00:25:39.320
If you merge with a path,
you'll become a path.

00:25:39.320 --> 00:25:40.270
And so you're golden.

00:25:40.270 --> 00:25:41.990
Paths are always good.

00:25:41.990 --> 00:25:46.790
And so this thing becomes
flat foldable, or at least

00:25:46.790 --> 00:25:48.732
locally flat foldable.

00:25:48.732 --> 00:25:52.840
And we can mark in a
crease pattern, I guess.

00:25:52.840 --> 00:25:55.690
You could make this-- that's
going to be hard to see,

00:25:55.690 --> 00:26:03.140
I think-- mountain, valley,
mountain, valley, mountain--

00:26:03.140 --> 00:26:14.260
oh, sorry-- equals, not equals,
this is not equals, not equals,

00:26:14.260 --> 00:26:18.710
not equals, equals.

00:26:18.710 --> 00:26:19.619
These guys are free.

00:26:19.619 --> 00:26:21.160
So you can make one
of them mountain,

00:26:21.160 --> 00:26:24.220
one of--- you can make them
all mountains, I guess.

00:26:24.220 --> 00:26:25.550
Or not.

00:26:25.550 --> 00:26:26.050
OK.

00:26:26.050 --> 00:26:29.330
This is a locally
valid flat folding.

00:26:29.330 --> 00:26:32.240
And it's hard to tell
whether it actually works

00:26:32.240 --> 00:26:33.330
except by folding it.

00:26:33.330 --> 00:26:36.180
So here I made one.

00:26:36.180 --> 00:26:39.540
That's the top side, I think.

00:26:39.540 --> 00:26:41.870
Ideally I got the same
crease pattern as here.

00:26:41.870 --> 00:26:44.210
The reds are mountains.

00:26:44.210 --> 00:26:46.250
Looks the same.

00:26:46.250 --> 00:26:47.062
And then--

00:26:47.062 --> 00:26:49.270
It's clear that this pattern
is flat foldable, right?

00:26:49.270 --> 00:26:51.540
You just simple fold
here, and then you've

00:26:51.540 --> 00:26:54.480
got a single vertex and that
single vertex is flat foldable.

00:26:54.480 --> 00:26:56.510
But this does not do that.

00:26:56.510 --> 00:26:57.905
It does a kind of twist.

00:26:57.905 --> 00:27:02.420
It's kind of a fun mountain
valley assignment for it.

00:27:02.420 --> 00:27:04.860
So in this case it works.

00:27:04.860 --> 00:27:07.272
In general, you might get
some weird mountain valley

00:27:07.272 --> 00:27:08.480
assignment that doesn't work.

00:27:08.480 --> 00:27:11.220
But something simple
like this pattern,

00:27:11.220 --> 00:27:15.345
which has four
vertices, always will.

00:27:15.345 --> 00:27:17.440
Any more questions
about local foldability?

00:27:17.440 --> 00:27:20.530
That gives you at least an idea
of what the merges look like.

00:27:20.530 --> 00:27:22.608
It's hard to draw a huge
example, but-- Yeah.

00:27:22.608 --> 00:27:24.024
AUDIENCE: So the
generic case, you

00:27:24.024 --> 00:27:25.550
don't really have
a choice at any--

00:27:25.550 --> 00:27:27.675
PROFESSOR: In the generic
case you have no choices,

00:27:27.675 --> 00:27:31.810
and so you've got to-- you
just check, does it work.

00:27:31.810 --> 00:27:32.640
And if it--

00:27:32.640 --> 00:27:36.112
AUDIENCE: If you have
an odd number of faces,

00:27:36.112 --> 00:27:38.340
odd number of sides, then
it's not going to work?

00:27:38.340 --> 00:27:40.140
PROFESSOR: If you have a face
with an odd number of sides,

00:27:40.140 --> 00:27:41.100
that might be fine.

00:27:41.100 --> 00:27:43.100
It depends on these
assignments, whether they're

00:27:43.100 --> 00:27:45.400
not equal or equals.

00:27:45.400 --> 00:27:50.862
Like if this were an equal
sign, then you'd be happy.

00:27:50.862 --> 00:27:52.320
And that would
happen, for example,

00:27:52.320 --> 00:27:55.600
if you move these
creases to be very small.

00:27:55.600 --> 00:27:58.940
I'd have to also make this
one proportionally big, which

00:27:58.940 --> 00:28:01.400
is possible if I move
this vertex way over here.

00:28:01.400 --> 00:28:03.186
I'll have a triangle.

00:28:03.186 --> 00:28:04.310
This will have a big angle.

00:28:04.310 --> 00:28:06.190
Then I can have a
small angle here

00:28:06.190 --> 00:28:08.500
and these two guys
will be made not equal

00:28:08.500 --> 00:28:09.875
and these two will
be made equal,

00:28:09.875 --> 00:28:12.400
and then the parity's fine.

00:28:12.400 --> 00:28:17.380
So if you have a cycle with
an odd number of not equals,

00:28:17.380 --> 00:28:18.820
then you're screwed.

00:28:18.820 --> 00:28:20.860
In the generic case
there's nothing you can do.

00:28:20.860 --> 00:28:23.570
When you have equal angles,
when you had a choice,

00:28:23.570 --> 00:28:26.310
you go back and check whether
the choices would do merges.

00:28:26.310 --> 00:28:27.860
If you do, you do them.

00:28:27.860 --> 00:28:29.760
Overall, this turns out
to take a linear time

00:28:29.760 --> 00:28:34.640
if you're careful, because you
can only merge so many times.

00:28:34.640 --> 00:28:40.650
You have at most n parts and
each merge-- with some care.

00:28:40.650 --> 00:28:42.850
You need fancy data structures
to get this to work.

00:28:42.850 --> 00:28:44.650
You need find stuff,
but then you'll

00:28:44.650 --> 00:28:47.230
get linear time over all.

00:28:47.230 --> 00:28:48.974
Other questions?

00:28:48.974 --> 00:28:52.126
AUDIENCE: So what's the
definition of merging, again?

00:28:52.126 --> 00:28:53.750
PROFESSOR: So the
definition of merging

00:28:53.750 --> 00:28:56.710
is you look at every time
you had a choice in running

00:28:56.710 --> 00:29:01.630
this algorithm-- which you have
to not just run this algorithm

00:29:01.630 --> 00:29:05.260
but you have to maintain all
the choices that you had made.

00:29:05.260 --> 00:29:07.350
So whenever you had two
equal angles-- in general,

00:29:07.350 --> 00:29:10.880
the algorithm is you look at
a sequence of equal angles.

00:29:10.880 --> 00:29:12.810
The algorithm maybe
chooses the first one,

00:29:12.810 --> 00:29:14.750
but you could have chosen any.

00:29:14.750 --> 00:29:16.950
You see for each of the
other possibilities,

00:29:16.950 --> 00:29:21.200
would that end up combining
two of the components.

00:29:21.200 --> 00:29:26.300
So the constraints sort of join
together either into cycles

00:29:26.300 --> 00:29:29.330
or into paths, like this guy.

00:29:29.330 --> 00:29:31.480
And we just check, if
I do this other change,

00:29:31.480 --> 00:29:34.230
does it end up combining
two of those components?

00:29:34.230 --> 00:29:38.500
Before I had 1, 2,
3, 4 components.

00:29:38.500 --> 00:29:40.670
Now I only have 3 components.

00:29:40.670 --> 00:29:42.190
So just see what happens.

00:29:42.190 --> 00:29:44.920
If that decreases the number
of components I do it.

00:29:44.920 --> 00:29:47.370
And you can guarantee
this never hurts you.

00:29:47.370 --> 00:29:50.520
Keep merging components
until you can't anymore.

00:29:50.520 --> 00:29:52.060
And then either it
works and you've

00:29:52.060 --> 00:29:55.980
got no parity problems or no
cycles, or it doesn't work.

00:29:55.980 --> 00:29:59.223
If it doesn't work, there is
no local foldable assignment.

00:29:59.223 --> 00:29:59.722
Yeah.

00:29:59.722 --> 00:30:01.180
AUDIENCE: When you
say it's linear,

00:30:01.180 --> 00:30:03.785
are you counting
vertices or edges?

00:30:03.785 --> 00:30:05.910
PROFESSOR: Let's say number
of vertices plus edges.

00:30:05.910 --> 00:30:10.520
That's the safe way to define
n and then linear in that.

00:30:10.520 --> 00:30:12.760
Or if you count
the endpoints here

00:30:12.760 --> 00:30:16.410
it doesn't matter whether you
just count vertices or edges.

00:30:16.410 --> 00:30:19.780
The sum of the two
is always safe.

00:30:19.780 --> 00:30:22.297
So n usually just means
the size of the input,

00:30:22.297 --> 00:30:24.880
and those vertices and edges,
so why not just count them both.

00:30:27.440 --> 00:30:29.410
Other questions?

00:30:29.410 --> 00:30:30.580
Cool.

00:30:30.580 --> 00:30:34.750
So that's local foldability.

00:30:34.750 --> 00:30:37.310
I just have a few
more little things

00:30:37.310 --> 00:30:40.331
and then you can
ask more questions.

00:30:40.331 --> 00:30:40.830
Oh, sorry.

00:30:40.830 --> 00:30:42.070
I have one more example.

00:30:42.070 --> 00:30:43.042
I forgot.

00:30:43.042 --> 00:30:45.000
This is an example where
everything works fine.

00:30:45.000 --> 00:30:46.170
You don't get any cycles.

00:30:46.170 --> 00:30:47.660
But it's kind of a fun example.

00:30:47.660 --> 00:30:49.540
The crane.

00:30:49.540 --> 00:30:52.220
I'd never analyzed it
before, so I spent the time

00:30:52.220 --> 00:30:54.030
to draw one of these pictures.

00:30:54.030 --> 00:30:56.830
So first I just put a
bunch of circles down,

00:30:56.830 --> 00:31:00.640
and I look for things that
are forced, just because that

00:31:00.640 --> 00:31:01.720
is more interesting.

00:31:01.720 --> 00:31:03.380
I tried to make it
as bad as possible.

00:31:03.380 --> 00:31:05.088
It turns out I couldn't
make it that bad.

00:31:05.088 --> 00:31:06.630
But this guy's
forced, because it's

00:31:06.630 --> 00:31:09.490
the only locally smallest angle.

00:31:09.490 --> 00:31:11.010
And then it's
symmetrical around.

00:31:11.010 --> 00:31:14.770
So this guy's forced.

00:31:14.770 --> 00:31:16.800
Four of them should be forced.

00:31:16.800 --> 00:31:18.840
If I advance, yeah.

00:31:18.840 --> 00:31:20.150
This one, this one.

00:31:20.150 --> 00:31:21.770
Those are all forced
to be not equal.

00:31:21.770 --> 00:31:22.610
The rest are equal.

00:31:22.610 --> 00:31:25.130
The other guys have ambiguity.

00:31:25.130 --> 00:31:25.869
And I tried.

00:31:25.869 --> 00:31:28.160
I thought this would be a
great place to find the cycle

00:31:28.160 --> 00:31:30.285
and then we could resolve
the cycle, because I know

00:31:30.285 --> 00:31:34.370
this should work in the end,
but I couldn't make a cycle.

00:31:34.370 --> 00:31:37.950
It's not possible, because
there's sort of this cut point

00:31:37.950 --> 00:31:38.980
here.

00:31:38.980 --> 00:31:42.000
And you once you go to
one side of the pattern,

00:31:42.000 --> 00:31:44.080
you can't come back
to the other side.

00:31:44.080 --> 00:31:46.220
I could make a really
long path though.

00:31:46.220 --> 00:31:48.012
So I chose-- there's
a lot of choices here,

00:31:48.012 --> 00:31:49.470
but the algorithm
just chooses one.

00:31:49.470 --> 00:31:51.400
I tried to make the
longest path I could.

00:31:51.400 --> 00:31:53.690
It's kind of a fun puzzle.

00:31:53.690 --> 00:31:55.155
Not that hard to solve.

00:31:55.155 --> 00:31:57.030
It gets a little hard
to draw these pairings.

00:31:57.030 --> 00:31:59.260
Here these two guys are
paired together as not equal.

00:31:59.260 --> 00:32:00.870
We crimp that first.

00:32:00.870 --> 00:32:03.000
Then let's say we
crimp these two.

00:32:03.000 --> 00:32:04.570
Then we've got two
angles here, each

00:32:04.570 --> 00:32:08.320
of which I think is 90 degrees
after you do the crimps.

00:32:08.320 --> 00:32:10.820
And so these two guys
have to be equal.

00:32:10.820 --> 00:32:13.430
That's what this notation means.

00:32:13.430 --> 00:32:16.500
So here there were, I think
four different possibilities.

00:32:16.500 --> 00:32:20.920
And if you trace all the
paths, you get these guys.

00:32:20.920 --> 00:32:24.530
So there's some simple paths
out here, but then there's

00:32:24.530 --> 00:32:28.290
this purple path in the
middle, which starts here,

00:32:28.290 --> 00:32:31.540
goes up here, over here,
over here, along this crease,

00:32:31.540 --> 00:32:40.730
over here, here, here, here, up
there, here, here, there, back,

00:32:40.730 --> 00:32:43.830
forth, and then it
escapes in the corner.

00:32:43.830 --> 00:32:46.010
So you get a mountain valley
assignment out of this.

00:32:46.010 --> 00:32:48.400
I didn't test whether
it was possible.

00:32:48.400 --> 00:32:50.110
Probably not.

00:32:50.110 --> 00:32:53.640
Anyway, you get something,
and it might be possible.

00:32:53.640 --> 00:32:56.980
Exercise for you to try at home.

00:32:56.980 --> 00:32:57.670
All right.

00:32:57.670 --> 00:32:59.870
That took some time to draw.

00:33:02.720 --> 00:33:03.990
Cool.

00:33:03.990 --> 00:33:06.980
That's local foldability.

00:33:06.980 --> 00:33:08.960
Now with the
Kawasaki condition, I

00:33:08.960 --> 00:33:10.520
mentioned briefly
in lecture three

00:33:10.520 --> 00:33:13.350
that-- We were talking
about convex cones, where

00:33:13.350 --> 00:33:15.800
the amount of material is
less than or equal to 360.

00:33:15.800 --> 00:33:18.075
Someone pointed out and
said, oh, out of paper

00:33:18.075 --> 00:33:19.700
you can't make
something more than 360.

00:33:19.700 --> 00:33:21.940
And it's true if you start
from one sheet of paper.

00:33:21.940 --> 00:33:24.640
But if you start with
multiple sheets of material

00:33:24.640 --> 00:33:29.050
and join them together, like
sew them up, like in a T-shirt,

00:33:29.050 --> 00:33:31.240
you can get non-convex
cones, meaning

00:33:31.240 --> 00:33:33.230
more than 360 degrees
of material here.

00:33:33.230 --> 00:33:35.800
This is, let's say,
270, let's call it?

00:33:35.800 --> 00:33:37.784
So you double that,
because there's

00:33:37.784 --> 00:33:39.700
a front side and the
back side of the T-shirt.

00:33:39.700 --> 00:33:41.980
Easier to see in a 3D one.

00:33:41.980 --> 00:33:47.540
You've got more than 360 degrees
of material in the armpits.

00:33:47.540 --> 00:33:50.100
So, yes, it's true.

00:33:50.100 --> 00:33:56.610
And what happens, as I mentioned
briefly, is there's a new case.

00:33:56.610 --> 00:33:58.260
There's sort of
two situations when

00:33:58.260 --> 00:34:02.700
you have a kind of a mess
of material like this,

00:34:02.700 --> 00:34:04.940
more than 360
degrees of material.

00:34:04.940 --> 00:34:06.130
There are two possibilities.

00:34:06.130 --> 00:34:09.400
Either you end up folding it to
lie in less than a full circle,

00:34:09.400 --> 00:34:12.300
in terms of the boundary,
and then it's just like here.

00:34:12.300 --> 00:34:14.659
The alternating sum
should be equal to 0.

00:34:14.659 --> 00:34:17.600
Or you end up folding it
so that it encompasses

00:34:17.600 --> 00:34:20.010
an entire circle,
and then you end up

00:34:20.010 --> 00:34:24.010
with this alternating sum of
angles being plus or minus 360.

00:34:24.010 --> 00:34:25.239
And it's in the textbook.

00:34:25.239 --> 00:34:27.760
It's not so easy to prove
that that's all that happens,

00:34:27.760 --> 00:34:30.780
but you-- Basically, you
can't twist multiple times,

00:34:30.780 --> 00:34:33.659
because then you'd end
up with a crossing.

00:34:33.659 --> 00:34:35.679
So it's not that much
harder to analyze

00:34:35.679 --> 00:34:36.840
these kinds of situations.

00:34:36.840 --> 00:34:38.420
You can do it.

00:34:38.420 --> 00:34:40.350
But this is a
great excuse for me

00:34:40.350 --> 00:34:43.030
to show cool ways
to fold T-shirts.

00:34:43.030 --> 00:34:45.130
How many people seen this video?

00:34:45.130 --> 00:34:46.010
most.

00:34:46.010 --> 00:34:47.120
It's like six years old.

00:34:47.120 --> 00:34:48.912
Have you ever tried it?

00:34:48.912 --> 00:34:51.010
[LAUGHTER]

00:34:51.010 --> 00:34:54.130
I brought an extra
little T-shirt here.

00:34:54.130 --> 00:34:57.210
This is totally for fun.

00:34:57.210 --> 00:34:58.880
You pinch here and here.

00:34:58.880 --> 00:35:00.190
Bring this side over here.

00:35:00.190 --> 00:35:01.160
You pinch.

00:35:01.160 --> 00:35:03.906
You do a nice
flourish, and then you

00:35:03.906 --> 00:35:05.530
get your perfectly
folded-- I didn't

00:35:05.530 --> 00:35:09.160
do it perfectly--
T-shirt in one motion.

00:35:09.160 --> 00:35:14.140
As they say, in two seconds,
and it works for us.

00:35:14.140 --> 00:35:17.150
So it's a great T-shirts.

00:35:17.150 --> 00:35:21.320
And for fun, here's the--
this is like the high tech way

00:35:21.320 --> 00:35:23.140
to do it.

00:35:23.140 --> 00:35:27.250
There's actually a whole bunch
of T-shirt folding machines.

00:35:27.250 --> 00:35:28.340
You push the button.

00:35:28.340 --> 00:35:30.823
It's a bunch of simple
folds, actually.

00:35:30.823 --> 00:35:32.698
So it's a nice little
simple folding machine.

00:35:32.698 --> 00:35:34.000
[LAUGHTER]

00:35:34.000 --> 00:35:35.820
It's kind of fun to watch.

00:35:35.820 --> 00:35:39.280
Seems like a lot of set up time.

00:35:39.280 --> 00:35:43.520
You have set up time with
the fast method also.

00:35:43.520 --> 00:35:45.430
So It's kind of fun.

00:35:45.430 --> 00:35:48.220
The same machine. you can also
wrap them directly into bags.

00:35:48.220 --> 00:35:49.125
Question?

00:35:49.125 --> 00:35:51.600
AUDIENCE: Have you
in clothing stores

00:35:51.600 --> 00:35:53.990
they have non-mechanical
versions of those

00:35:53.990 --> 00:35:55.430
that are just plastic boards.

00:35:55.430 --> 00:35:56.160
PROFESSOR: And you just--

00:35:56.160 --> 00:35:58.422
AUDIENCE: That you can flop over
so that all your T-shirts are

00:35:58.422 --> 00:35:58.820
folded the same.

00:35:58.820 --> 00:35:59.900
PROFESSOR: It's not automated.

00:35:59.900 --> 00:36:00.400
Yes.

00:36:00.400 --> 00:36:04.310
You can actually buy-- I've
only seen them in stores rarely.

00:36:04.310 --> 00:36:05.930
They're usually
in the back room.

00:36:05.930 --> 00:36:08.455
But you can actually buy
this folding machine.

00:36:08.455 --> 00:36:11.840
It's like a giant piece of
plastic with exactly-- maybe

00:36:11.840 --> 00:36:14.040
only three creases,
I think typically.

00:36:14.040 --> 00:36:16.382
And then you just do them
in some order manually

00:36:16.382 --> 00:36:17.840
with simple folds,
and it does make

00:36:17.840 --> 00:36:20.860
really nicely folded T-shirts.

00:36:20.860 --> 00:36:22.850
Nicer than I could
fold by hand, anyway.

00:36:22.850 --> 00:36:23.350
All right.

00:36:23.350 --> 00:36:24.840
That was just for fun.

00:36:24.840 --> 00:36:26.400
While we're on the
topic of T-shirts.

00:36:29.340 --> 00:36:31.480
Next question is about
higher dimensions.

00:36:31.480 --> 00:36:33.224
So I mentioned
briefly, yeah, you

00:36:33.224 --> 00:36:34.640
can do higher
dimensional origami.

00:36:34.640 --> 00:36:36.010
Not much is known about it.

00:36:36.010 --> 00:36:38.700
So a natural thing to ask
about is flat foldability

00:36:38.700 --> 00:36:40.130
for higher dimensions.

00:36:40.130 --> 00:36:45.030
And there are exactly
two papers about this.

00:36:45.030 --> 00:36:47.350
Well, maybe even just one.

00:36:47.350 --> 00:36:50.680
The old one is this paper
by Kawasaki-- same guy

00:36:50.680 --> 00:36:54.640
as Kawasaki's condition--
and this is in this book.

00:36:54.640 --> 00:36:56.459
This the first--
this is a hard book

00:36:56.459 --> 00:36:58.000
to get a copy of,
First International

00:36:58.000 --> 00:36:59.660
Meeting of Origami
Science and Technology.

00:36:59.660 --> 00:37:01.534
These days it's called
Origami Science, Math,

00:37:01.534 --> 00:37:02.980
and Education, OSME.

00:37:02.980 --> 00:37:04.900
And this T-shirt is from
the latest one, which

00:37:04.900 --> 00:37:10.330
was in Singapore two
years ago, I think, 2010.

00:37:10.330 --> 00:37:13.101
Next one is in a
year or two in Japan.

00:37:13.101 --> 00:37:14.350
So this is the very first one.

00:37:14.350 --> 00:37:15.530
This is before my time.

00:37:15.530 --> 00:37:16.740
And there's this paper.

00:37:16.740 --> 00:37:20.429
It's a translated Japanese
paper, so it has a few typos.

00:37:20.429 --> 00:37:21.845
We also have the
Japanese original

00:37:21.845 --> 00:37:23.880
if you're interested in
reading this some time.

00:37:23.880 --> 00:37:25.750
You see, for example,
here is folding

00:37:25.750 --> 00:37:27.170
a regular piece
of paper in half.

00:37:27.170 --> 00:37:29.970
Here's folding a 3D
solid of paper in half.

00:37:29.970 --> 00:37:32.790
A little harder to
imagine, but there it is.

00:37:32.790 --> 00:37:34.750
And let's see,
what's in this paper?

00:37:34.750 --> 00:37:37.910
There's a definition,
although I would really

00:37:37.910 --> 00:37:39.530
call it a necessary condition.

00:37:39.530 --> 00:37:41.290
I think this is not
a good definition

00:37:41.290 --> 00:37:42.620
of flat origami in 3D.

00:37:42.620 --> 00:37:43.470
But there it is.

00:37:43.470 --> 00:37:45.470
This is the definition.

00:37:45.470 --> 00:37:50.020
What it says is basically,
locally everything works out.

00:37:50.020 --> 00:37:52.700
When you do a fold,
it's like a reflection.

00:37:52.700 --> 00:37:54.160
If you do it
instantaneously, this

00:37:54.160 --> 00:37:56.340
is like reflecting this
piece through the line

00:37:56.340 --> 00:37:57.130
for flat folding.

00:37:57.130 --> 00:38:00.230
This is like reflecting this
piece through the plane.

00:38:00.230 --> 00:38:04.250
And so one condition you
have is that if you-- it's

00:38:04.250 --> 00:38:07.467
easier to look at one of
the examples in the paper.

00:38:07.467 --> 00:38:09.050
So you have this
crease pattern, which

00:38:09.050 --> 00:38:11.790
you can draw by a bunch
of planes, let's say.

00:38:11.790 --> 00:38:13.630
If you kind of walk
around and say, OK, I

00:38:13.630 --> 00:38:15.088
go through this
crease, which means

00:38:15.088 --> 00:38:16.700
I reflect through
that plane, then

00:38:16.700 --> 00:38:18.908
I reflect through this plane,
this plane, this plane,

00:38:18.908 --> 00:38:23.450
you can take any sort of path,
any cycle through this world.

00:38:23.450 --> 00:38:25.720
In the end I should end
up back where I started.

00:38:25.720 --> 00:38:27.149
Otherwise I'm ripping.

00:38:27.149 --> 00:38:28.940
And what that condition
says is that if you

00:38:28.940 --> 00:38:31.189
take the sequence of reflections
and you compose them,

00:38:31.189 --> 00:38:34.740
you end up with no reflection
at all, that nothing moved.

00:38:34.740 --> 00:38:37.670
And so that's a necessary
condition for flat foldability.

00:38:37.670 --> 00:38:41.300
I wouldn't call it a definition,
although this paper did.

00:38:41.300 --> 00:38:44.510
Natural definition
is more like what

00:38:44.510 --> 00:38:49.030
we draw in 2D for
flat folding, where

00:38:49.030 --> 00:38:52.040
we add another layer,
another dimension,

00:38:52.040 --> 00:38:55.860
and then guarantee no
collisions in that dimension.

00:38:55.860 --> 00:38:58.020
So same thing in 3D.

00:38:58.020 --> 00:39:00.751
It's just harder to imagine
stacking up copies of 3D.

00:39:00.751 --> 00:39:01.250
Question?

00:39:01.250 --> 00:39:02.916
AUDIENCE: Doesn't the
reflection analogy

00:39:02.916 --> 00:39:04.853
only apply to
simple folds, where

00:39:04.853 --> 00:39:06.617
the plane goes all the way?

00:39:06.617 --> 00:39:07.200
PROFESSOR: OK.

00:39:07.200 --> 00:39:07.783
Good question.

00:39:07.783 --> 00:39:09.321
The reflection
analogy definitely

00:39:09.321 --> 00:39:10.320
applies to simple folds.

00:39:10.320 --> 00:39:12.040
It also applies to
non-simple folds.

00:39:12.040 --> 00:39:14.170
But it does require
straight folds,

00:39:14.170 --> 00:39:18.100
which here mean flat
folds, like planar folds.

00:39:18.100 --> 00:39:19.710
For curve creases,
you're not really

00:39:19.710 --> 00:39:22.120
reflecting, because
you can't fold

00:39:22.120 --> 00:39:23.610
a curve crease all the way.

00:39:23.610 --> 00:39:24.602
You can't fold it flat.

00:39:24.602 --> 00:39:26.810
But whenever you fold
something all the way-- so even

00:39:26.810 --> 00:39:30.250
in something like this, which is
not a simple fold in the end--

00:39:30.250 --> 00:39:31.580
you can check.

00:39:31.580 --> 00:39:34.520
Essentially, this is what we--
on the circle, when we said,

00:39:34.520 --> 00:39:37.450
OK, you walk this way and then
you just change direction.

00:39:37.450 --> 00:39:38.860
That's essentially
the reflection

00:39:38.860 --> 00:39:41.210
that's happening on the circle.

00:39:41.210 --> 00:39:43.152
If you live on the circle
you're reflecting in

00:39:43.152 --> 00:39:45.360
that you're immediately
bouncing back at that crease.

00:39:45.360 --> 00:39:47.620
It turns out to
hold in 2D as well.

00:39:47.620 --> 00:39:49.870
So if you look at the
effect of this crease,

00:39:49.870 --> 00:39:54.060
it is that you're reflecting
this part over that crease.

00:39:54.060 --> 00:39:55.810
I guess you can see
it in the folding too.

00:39:55.810 --> 00:39:58.599
I mean, you go over this
crease, then you hit this line,

00:39:58.599 --> 00:40:00.640
and then you immediately
bounce back at the line.

00:40:00.640 --> 00:40:03.537
That is actually a
reflection through the line.

00:40:03.537 --> 00:40:04.120
Good question.

00:40:04.120 --> 00:40:06.900
It's obvious for simple
folds, but reflection actually

00:40:06.900 --> 00:40:08.860
works here as well.

00:40:08.860 --> 00:40:13.350
We'll talk more about that in
the next lecture, I believe.

00:40:13.350 --> 00:40:14.260
OK.

00:40:14.260 --> 00:40:17.250
I was looking up reference,
any papers that cited that one,

00:40:17.250 --> 00:40:19.600
and there's basically
one paper, which

00:40:19.600 --> 00:40:25.709
is this kind of a
graphics/art/math paper talking

00:40:25.709 --> 00:40:27.000
about four-dimensional origami.

00:40:27.000 --> 00:40:30.840
It's basically some
simulations and some examples.

00:40:30.840 --> 00:40:33.990
Here's the not folding
all the way picture.

00:40:33.990 --> 00:40:35.590
A little harder to imagine.

00:40:35.590 --> 00:40:39.840
Here they're doing, I think, the
4D analog of a rabbit ear fold.

00:40:39.840 --> 00:40:41.460
Little hard to
tell, but first they

00:40:41.460 --> 00:40:42.910
do a simple fold
along a bisector.

00:40:42.910 --> 00:40:44.200
That I can understand.

00:40:44.200 --> 00:40:46.420
And then they do an
inside reverse fold.

00:40:46.420 --> 00:40:51.560
And then you end up with
1/4 of the tetrahedron.

00:40:51.560 --> 00:40:55.984
So if you divide, this is the
centroid of the tetrahedron.

00:40:55.984 --> 00:40:57.650
It's really hard to
draw these pictures.

00:40:57.650 --> 00:40:59.820
In the paper, they
actually showed two images,

00:40:59.820 --> 00:41:02.410
and if you align
them with your eyes

00:41:02.410 --> 00:41:03.900
then you'll see
a 3D image, which

00:41:03.900 --> 00:41:07.350
is of course a projection
of the 4D thing.

00:41:07.350 --> 00:41:08.900
They also have this one.

00:41:08.900 --> 00:41:10.820
Anyone have red-blue
glasses with them?

00:41:10.820 --> 00:41:13.310
Then you'll see this in 3D.

00:41:13.310 --> 00:41:15.530
Here you can watch that later.

00:41:15.530 --> 00:41:19.194
This is their 4D analog of
a flapping bird, I guess.

00:41:19.194 --> 00:41:21.110
It's pretty hard to see
these pictures, though

00:41:21.110 --> 00:41:25.407
But this is the state of the art
in 4D origami as far as I know.

00:41:25.407 --> 00:41:26.490
It's kind of neat to find.

00:41:26.490 --> 00:41:29.650
This is a pretty recent paper.

00:41:29.650 --> 00:41:33.210
Questions about
higher dimensions?

00:41:33.210 --> 00:41:36.620
Lots of things are open.

00:41:36.620 --> 00:41:38.850
For example, single
vertex flat foldability

00:41:38.850 --> 00:41:41.120
could be a neat problem.

00:41:41.120 --> 00:41:44.527
I don't think-- It may be
that Kawasaki's condition

00:41:44.527 --> 00:41:45.610
from that paper is enough.

00:41:45.610 --> 00:41:46.790
I don't know.

00:41:46.790 --> 00:41:49.360
Maybe not.

00:41:49.360 --> 00:41:50.240
OK.

00:41:50.240 --> 00:41:52.820
Last question, just kind
of a nice place to end

00:41:52.820 --> 00:41:56.150
is, why are we spending all
this time on flat foldability.

00:41:56.150 --> 00:41:58.700
Flat origami's kind of boring.

00:41:58.700 --> 00:42:01.020
And so why do we spend
all this time with it?

00:42:01.020 --> 00:42:04.360
It's good to check
why are we doing this.

00:42:04.360 --> 00:42:07.210
One answer of course is that
there's interesting mathematics

00:42:07.210 --> 00:42:08.950
here.

00:42:08.950 --> 00:42:10.980
It's kind of a natural question.

00:42:10.980 --> 00:42:12.020
Why not?

00:42:12.020 --> 00:42:14.850
That's the math cop-out answer.

00:42:14.850 --> 00:42:17.480
But there are actually a
lot of good answers as well.

00:42:17.480 --> 00:42:19.980
One answer is that flat origami
actually is pretty cool.

00:42:19.980 --> 00:42:22.340
There's a whole world of
flat tessellations, where

00:42:22.340 --> 00:42:25.060
you fold a repeating
pattern in your sheet.

00:42:25.060 --> 00:42:26.730
This is from a
rectangle of paper.

00:42:26.730 --> 00:42:28.563
What you're seeing here
is a shadow pattern.

00:42:28.563 --> 00:42:31.180
It's held up to a window, and
so you see this shadow pattern,

00:42:31.180 --> 00:42:36.220
which looks an awful lot like
a 6 by 6 by 6 Rubik's cube.

00:42:36.220 --> 00:42:38.420
That's the design here.

00:42:38.420 --> 00:42:42.030
You could make it even
larger if you want.

00:42:42.030 --> 00:42:44.850
Another answer is, well,
maybe I need to store stuff.

00:42:44.850 --> 00:42:46.405
And while I can
unfold things, it's

00:42:46.405 --> 00:42:47.420
kind of big when it's unfolded.

00:42:47.420 --> 00:42:48.961
If I could fold it
all the way flat--

00:42:48.961 --> 00:42:51.290
maybe I care about the 3D
shape, but if I could fold it

00:42:51.290 --> 00:42:53.414
all the way flat, then it
would be easier to store.

00:42:53.414 --> 00:42:55.810
It's going to be smaller, more
compact, I can roll it up,

00:42:55.810 --> 00:42:56.810
I can do lots of things.

00:42:56.810 --> 00:42:58.900
Airbag folding is one example.

00:42:58.900 --> 00:43:00.747
Here you actually
start with a 3D shape.

00:43:00.747 --> 00:43:01.830
There's no sort of unfold.

00:43:01.830 --> 00:43:03.980
It's been sewn into a 3D shape.

00:43:03.980 --> 00:43:06.790
And then you want to collapse
it into some nice flat shape

00:43:06.790 --> 00:43:09.390
for storage in your steering
wheel, or the side of your car,

00:43:09.390 --> 00:43:10.260
or whatever.

00:43:10.260 --> 00:43:16.210
And this is an example of
folding using flat origami

00:43:16.210 --> 00:43:16.710
designs.

00:43:16.710 --> 00:43:21.000
This crease pattern is
based on the tree method,

00:43:21.000 --> 00:43:25.530
and other stuff we haven't
covered yet, fold and cut.

00:43:25.530 --> 00:43:27.250
So that's another.

00:43:27.250 --> 00:43:29.650
That's sort of the
practical answer.

00:43:29.650 --> 00:43:31.917
And then there's more
mathematical answers,

00:43:31.917 --> 00:43:32.500
deeper things.

00:43:32.500 --> 00:43:35.120
Even if you don't care about
flat folding by itself,

00:43:35.120 --> 00:43:37.710
it turns out to relate
to 3D folding as well.

00:43:37.710 --> 00:43:40.500
This is a paper
that's very cool.

00:43:40.500 --> 00:43:43.740
We have a guest lecture by
Tomohiro Tachi coming up.

00:43:43.740 --> 00:43:46.430
I haven't scheduled
exactly when it will be,

00:43:46.430 --> 00:43:49.770
because it's in the in the box.

00:43:49.770 --> 00:43:51.914
It's on tape.

00:43:51.914 --> 00:43:53.580
So we'll be watching
that at some point.

00:43:53.580 --> 00:43:56.264
He was actually just
visiting a couple weeks ago.

00:43:56.264 --> 00:43:57.680
And he has this
cool theorem which

00:43:57.680 --> 00:44:00.360
says that if you
have a plane or quad

00:44:00.360 --> 00:44:03.170
mesh-- so a particular kind of
crease pattern, every vertex

00:44:03.170 --> 00:44:07.170
has four incident increases,
every face is a quadrilateral--

00:44:07.170 --> 00:44:09.651
and it's flat foldable--
so you may not

00:44:09.651 --> 00:44:11.150
care about flat
foldability, but you

00:44:11.150 --> 00:44:13.090
need this Kawasaki
condition to guarantee

00:44:13.090 --> 00:44:16.810
that this will work-- then it
has a rigid folding motion, if

00:44:16.810 --> 00:44:19.150
and only if it has a 3D state.

00:44:19.150 --> 00:44:21.540
Let me show you some examples.

00:44:21.540 --> 00:44:26.010
So this a kind of a classic
origami called miura-ori.

00:44:26.010 --> 00:44:28.580
And it has this cool property
that even if these panels are

00:44:28.580 --> 00:44:31.945
made up out of rigid material
like sheet metal or plastic

00:44:31.945 --> 00:44:35.760
or whatever, if these are
hinges you can still fold it.

00:44:35.760 --> 00:44:37.450
And this is an
animation of it folding.

00:44:37.450 --> 00:44:39.620
And indeed it folds flat.

00:44:39.620 --> 00:44:41.260
And what the
theorem is saying is

00:44:41.260 --> 00:44:45.310
if you can build a 3D picture
like this, any one of these,

00:44:45.310 --> 00:44:48.910
that guarantees that there's
this folding motion-- not

00:44:48.910 --> 00:44:51.960
necessarily all the way to flat,
but at least part way to flat.

00:44:51.960 --> 00:44:53.900
And often you can get
it all the way to flat.

00:44:53.900 --> 00:44:56.690
And so Tomohiro's
developed software

00:44:56.690 --> 00:44:58.805
that lets you start
with something

00:44:58.805 --> 00:45:01.300
you know works-- so this
is a miura-ori that's

00:45:01.300 --> 00:45:03.290
been folded partly--
and then just start

00:45:03.290 --> 00:45:05.881
pulling on the vertices and
messing it up and just changing

00:45:05.881 --> 00:45:06.380
the shapes.

00:45:06.380 --> 00:45:09.467
So this is not a folding.

00:45:09.467 --> 00:45:11.300
You're changing how the
paper fits together.

00:45:11.300 --> 00:45:12.910
You're changing
the crease pattern.

00:45:12.910 --> 00:45:15.290
As you do that, he keeps
track of the crease pattern

00:45:15.290 --> 00:45:17.370
and he adds constraints
to make sure

00:45:17.370 --> 00:45:19.310
that it stays flat foldable.

00:45:19.310 --> 00:45:24.300
The result is you end up with
a 3D embedding, a 3D folding,

00:45:24.300 --> 00:45:25.790
and you have a flat
foldable crease

00:45:25.790 --> 00:45:26.873
pattern that goes with it.

00:45:26.873 --> 00:45:28.890
And that guarantees
that you get a motion.

00:45:28.890 --> 00:45:29.630
Those two things.

00:45:29.630 --> 00:45:33.210
So this technique of
having flat foldability

00:45:33.210 --> 00:45:35.810
lets him design crazy
crease patterns that

00:45:35.810 --> 00:45:39.070
fold into whatever
shape he wants

00:45:39.070 --> 00:45:44.020
with a nice rigid motion where
all these panels stay rigid.

00:45:44.020 --> 00:45:48.629
So that's another motivation
for flat foldability.

00:45:48.629 --> 00:45:50.170
It's probably used
elsewhere as well,

00:45:50.170 --> 00:45:54.079
but this is kind of the
coolest, newest example I know,

00:45:54.079 --> 00:45:55.870
where it's just a
condition in the theorem,

00:45:55.870 --> 00:45:57.320
and in order to check
that condition you

00:45:57.320 --> 00:45:58.820
need to understand
flat foldability.

00:46:01.259 --> 00:46:01.925
Other questions?

00:46:04.560 --> 00:46:06.005
That's all I have for slides.

00:46:11.530 --> 00:46:13.370
Cool.

00:46:13.370 --> 00:46:15.860
That's the end of class.

