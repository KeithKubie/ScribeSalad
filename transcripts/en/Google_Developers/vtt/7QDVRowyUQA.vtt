WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:09.730
&gt;&gt; GERRAND: My name is Andrew Gerrand and
I work at Google Sydney and on the Go Team,

00:00:09.730 --> 00:00:16.449
the Go Programming Language. Just before I
get started, who here has heard of Go before?

00:00:16.449 --> 00:00:21.840
And keep your hand up if you've actually seen
some Go code or if you've written some Go

00:00:21.840 --> 00:00:29.130
code. My colleague there is feverishly waving
his hand. Cool. And other languages that you

00:00:29.130 --> 00:00:37.630
guys use, who's--who writes Java codes typically
and Python? JavaScript? Anything else? Just

00:00:37.630 --> 00:00:39.590
yell something out.
&gt;&gt; Scala.

00:00:39.590 --> 00:00:42.230
&gt;&gt; GERRAND: Scala. Cool.
&gt;&gt; Common Lisp.

00:00:42.230 --> 00:00:51.870
&gt;&gt; GERRAND: Common Lisp. We got one real nerd
here. That's right. Sorry. So in this talk

00:00:51.870 --> 00:01:00.079
today called Real World Go, I'm going to introduce
Go, talk about some of Go's interesting language

00:01:00.079 --> 00:01:05.689
features and also discuss some real world
applications in which Go is being used outside

00:01:05.689 --> 00:01:12.450
of Google. And we do use it increasingly extensively
within Google. But there's a lot of interesting

00:01:12.450 --> 00:01:18.860
projects happening out there in the world
as well. There is a system called SpeakerMeter

00:01:18.860 --> 00:01:26.220
which we're using at Boot Camp in I/O to get
feedback from people. That's the QI code you

00:01:26.220 --> 00:01:29.659
can scan now, but I'm going to take it off
the screen probably before you get a chance

00:01:29.659 --> 00:01:34.560
to do so. I'll show it again at the end. It's
just a good way of getting feedback back to

00:01:34.560 --> 00:01:41.009
me so I can improve my speaking skills. So
I'll just start with some background as to

00:01:41.009 --> 00:01:48.770
the origins of Go, the why and what. So, why
Go? It's a question I get asked pretty often.

00:01:48.770 --> 00:01:54.220
Why create a new programming language? We
have so many. Surely there's no need for another

00:01:54.220 --> 00:01:59.400
one. Well, this was born basically out of
frustration with the existing languages, the

00:01:59.400 --> 00:02:05.700
mainstream languages that we had at our disposal.
The statically typed languages, the dominant

00:02:05.700 --> 00:02:12.889
ones like C++ and Java tend to be very efficient
when they compile and run and they give you

00:02:12.889 --> 00:02:20.940
a lot of control. But they're typically very
bureaucratic. They can be verbose in use but--and

00:02:20.940 --> 00:02:25.430
also overly complex. It can be difficult to
understand exactly how the code you've--that

00:02:25.430 --> 00:02:30.040
you've written will behave when you've written
it and sometimes they can be very, very picky.

00:02:30.040 --> 00:02:35.829
But on the other hand, we have these dynamic
languages and scripting languages that are

00:02:35.829 --> 00:02:42.269
really easy to use. But because they're dynamically
typed, they can be very error-prone. A lot

00:02:42.269 --> 00:02:46.449
of programmer errors that would be compiler
errors in a statically typed language become

00:02:46.449 --> 00:02:51.560
runtime errors in a dynamic language. And
this means that you don't notice until you've

00:02:51.560 --> 00:02:57.129
deployed your program but some obscure corner
case triggers a colossal bug. They can also

00:02:57.129 --> 00:03:02.460
be inefficient and slow. And when you start
writing code at scale and particularly at

00:03:02.460 --> 00:03:08.900
a kind of Google scale with many tens of thousands
of programmers, they really start to breakdown

00:03:08.900 --> 00:03:15.129
in terms of their ability to componentize
and abstract things. And finally, we live

00:03:15.129 --> 00:03:21.089
in this concurrent world where we have many,
many network machines and multi-core machines.

00:03:21.089 --> 00:03:26.989
But the traditional approach to writing concurrent
software is tricky. It's--involves threads

00:03:26.989 --> 00:03:31.019
and locks and you have to be very precise
in your reasoning about those programs to

00:03:31.019 --> 00:03:37.510
write correct concurrent programs. So, generally,
the landscape looks like you had speed reliability

00:03:37.510 --> 00:03:42.309
or simplicity and you had to pick two. And
sometimes we only got to pick one and we thought,

00:03:42.309 --> 00:03:49.079
"Well, can't we do better than this?" So,
Go is a modern general purpose language. It

00:03:49.079 --> 00:03:55.309
compiles to native machine code on a variety
of architectures. It's statically typed, so

00:03:55.309 --> 00:03:59.909
you get the reliability and efficiency benefits
of statically typed language, but it has a

00:03:59.909 --> 00:04:05.829
lightweight syntax. Using type inference,
we can infer a lot of the typed information,

00:04:05.829 --> 00:04:12.449
so you remove that repetition from defining
types and such. It has a simple type system.

00:04:12.449 --> 00:04:17.761
It's not a classical OO kind of model and
so it's very easy to understand what's going

00:04:17.761 --> 00:04:24.169
on and understand what your code does. And
finally, it has some novel concurrency primitives

00:04:24.169 --> 00:04:28.870
that make reasoning and writing--reasoning
about and writing concurrent code a lot more

00:04:28.870 --> 00:04:36.610
straightforward. So when we designed Go, the
tenets of that design were, first and foremost,

00:04:36.610 --> 00:04:43.090
simplicity. Each language feature should be
easy to understand in and of itself. So you

00:04:43.090 --> 00:04:47.241
should be able to understand all the rules
associated with a particular feature and make--easily

00:04:47.241 --> 00:04:53.770
make valid decisions about how that should
behave. And going hand in hand in that is

00:04:53.770 --> 00:04:59.740
orthogonality. Each of Go's features should,
when they interact with the other features,

00:04:59.740 --> 00:05:03.740
should interact in a predictable and consistent
way, a way that's easy to understand and reason

00:05:03.740 --> 00:05:09.190
about. And finally, readability. It's very
important when working in a collaborative

00:05:09.190 --> 00:05:13.460
environment that when you look at a piece
of code, you should be able to understand

00:05:13.460 --> 00:05:18.340
what that code does without having to have
a huge amount of external context in your

00:05:18.340 --> 00:05:26.030
mind in order to make sense of it. And driving
all of this was a consensus driven design

00:05:26.030 --> 00:05:32.520
process. Rob said that nothing went into the
Go language until Ken Thompson, Robert Griesemer,

00:05:32.520 --> 00:05:37.849
and Rob all agreed that it was right and it
was correct. And as a result, there were some

00:05:37.849 --> 00:05:41.650
language features that didn't--that were in
discussion for over a year before they actually

00:05:41.650 --> 00:05:46.740
made it into the language proper. And each
of those three has a very--has different aesthetics,

00:05:46.740 --> 00:05:51.800
very different opinions about languages. And
so, the--in the end, the compromise is something

00:05:51.800 --> 00:05:57.789
that's really solid and very, very well thought
through. So this is one of the simplest possible

00:05:57.789 --> 00:06:03.669
Go programs is just the "Hello, world." It
has a package statement saying which package

00:06:03.669 --> 00:06:09.470
the program belongs to. Every Go program starts
in package main, the function main. We have

00:06:09.470 --> 00:06:14.419
an input statement. The font package is a
string formatting package. And our main function

00:06:14.419 --> 00:06:19.169
simply cause the print line function from
the string for main package to print "Hello,

00:06:19.169 --> 00:06:22.389
world." And that, I think those are the Chinese
characters for "world." They're just--the--we

00:06:22.389 --> 00:06:29.310
use those characters to underscore that all
Go source files, UTF-8, Unicode files, so

00:06:29.310 --> 00:06:34.889
you can use Unicode in string literals and
you can also use them in identifiers. So,

00:06:34.889 --> 00:06:39.800
if you brought a mathematical formula, for
example, you can use like a sigma character

00:06:39.800 --> 00:06:47.259
to signify some value if you like. And this
is Hello, world 2.0. So, if you run this program,

00:06:47.259 --> 00:06:53.449
it starts a web server listening on port 8080
and if you visited that URL, you would see

00:06:53.449 --> 00:06:57.770
the string "Hello, world." The difference
between this and the previous slide is we've

00:06:57.770 --> 00:07:03.780
added the HTTP package to the imports. And
now we have defined a second function, handler,

00:07:03.780 --> 00:07:08.999
which is an HTTP handler that simply writes
the string "Hello" followed by the path component

00:07:08.999 --> 00:07:15.210
of the URL as the HTTP response. And this--and
in the main function, we register that handler

00:07:15.210 --> 00:07:22.490
to the webroot and start the web server. So
this is just to give an idea of the sort of

00:07:22.490 --> 00:07:24.550
succinctness of Go code, how straightforward
it is to accomplish something that's actually

00:07:24.550 --> 00:07:31.150
quite complex under the hood. So let's take
a look at Go's type system. So, I mentioned

00:07:31.150 --> 00:07:36.659
Go is a statically type language but the type
inference system that we have saves a lot

00:07:36.659 --> 00:07:43.749
of repetition. Now this is a bit of a contrived
example for Java, but in Java or in C or C++,

00:07:43.749 --> 00:07:49.159
you need to say which type your variable is
going to be and then you assign something

00:07:49.159 --> 00:07:54.559
of that type to the variable. And so in Java's
case, you say, "Integer i = new Integer(1)"

00:07:54.559 --> 00:08:00.309
or "foo = new foo." In C+--C or C++, you have
to say "int i = 1." But it's obvious in the

00:08:00.309 --> 00:08:06.490
code that most of the time you just want an
integer. So in Go, we can just say "i := 1"

00:08:06.490 --> 00:08:12.990
to declare a new i which is an integer equal
to one. If we use a floating point initializer,

00:08:12.990 --> 00:08:19.759
then it'll be a float64 type and if we use
a string, it'll be a string. And in this final

00:08:19.759 --> 00:08:24.160
example, I've actually created a function
value, mul, which multiplies two integers

00:08:24.160 --> 00:08:30.090
and returns an integer. And the type will
be inferred to be a function type that takes

00:08:30.090 --> 00:08:34.800
two integers and returns an integer. So, this
gives you an idea of the kind of shorthand

00:08:34.800 --> 00:08:41.860
that you start to develop running Go code.
In Go, we have--we defined methods on types.

00:08:41.860 --> 00:08:46.930
And methods can be defined on any user defined
type. In this case, I've defined a type called

00:08:46.930 --> 00:08:53.000
Point which is a struct containing two values,
x and y, both floats. And then I can declare

00:08:53.000 --> 00:08:58.760
this method apps on point and it returns to
float64, and all that does is return the absolute

00:08:58.760 --> 00:09:05.100
value of that point. And then to create a
point value, I have to say "p := Point" with

00:09:05.100 --> 00:09:10.420
some initial values. And then I can take the
app--call apps on that P in the same way you

00:09:10.420 --> 00:09:14.880
would in Java or other languages like that.
So it's kind of familiar. But when I say they

00:09:14.880 --> 00:09:19.750
can be defined on any type, I mean like any
type. It doesn't have to be a stuct. A struct

00:09:19.750 --> 00:09:24.730
kind of looks like an object but this kind
of underscores here, I if have my float which

00:09:24.730 --> 00:09:34.500
is just a float64, I can define an abs method
on that type and it just returns the absolute

00:09:34.500 --> 00:09:38.680
value of that floating point value. And then
I can create my float in the say way I did

00:09:38.680 --> 00:09:44.149
with point and call abs on that. So what I'm
trying to show here is that Go objects are

00:09:44.149 --> 00:09:48.060
just values. There's no sort of box. There's--it's
not a--it doesn't have to be a class. You

00:09:48.060 --> 00:09:55.720
just define methods on bits of data. So it's
a nice way of associating logic with data

00:09:55.720 --> 00:10:01.699
but without the sort of the way overhead of
establishing a class and building that kind

00:10:01.699 --> 00:10:07.740
of hierarchy. So, in order to generalize Go
types, in order to make them interact nicely

00:10:07.740 --> 00:10:14.680
with each other, we have Go's concept of interfaces.
And interfaces simply specify the behaviors

00:10:14.680 --> 00:10:21.449
of types. So, when you define an interface
type; you define a set of methods and often,

00:10:21.449 --> 00:10:25.800
it's just one or two methods. I think the
largest go interface I have seen has maybe

00:10:25.800 --> 00:10:34.649
four or five. And any type that implements
those methods will implement that interface

00:10:34.649 --> 00:10:40.389
implicitly. So if I have some function PrintAbs
which types an Abser, which is any type that

00:10:40.389 --> 00:10:51.139
implements Abs, I can pass in a value of type
MyFloat or a point to that function. And at

00:10:51.139 --> 00:10:56.070
no point did the--either of those types have
to be aware of the Abser interface. They don't

00:10:56.070 --> 00:11:00.199
have to declare that they implement the Abser
interface. They just do, simply because they

00:11:00.199 --> 00:11:07.611
declare the Abs method. And this--to give
you a concrete example of this in the IO package

00:11:07.611 --> 00:11:15.320
in the standard library, we declare a interface
type called Writer. And writers are used to

00:11:15.320 --> 00:11:20.470
write streams of binary data to things and
they--it's just one method called Write which

00:11:20.470 --> 00:11:26.490
takes a buffer or a slice of bytes or an array
of bytes and returns the number of bytes written

00:11:26.490 --> 00:11:31.420
and an error value. But there are many, many
writers throughout the standard library and

00:11:31.420 --> 00:11:36.180
in other Go code and then you can use those
writers anywhere where a writer is expected.

00:11:36.180 --> 00:11:42.270
And we've already seen an example of this
in the Hello World 2.0 example. In our HTTP

00:11:42.270 --> 00:11:49.121
handler, we have an Fprint statement and Fprint
writes the string to W. W is a response writer,

00:11:49.121 --> 00:11:55.360
it's our HTTP response. And the reason why
this works is because Fprint expects an IO

00:11:55.360 --> 00:12:01.190
writer and HTTP response writer implements
the write method. Now, at no point does the

00:12:01.190 --> 00:12:06.779
fmt package need to be aware of the HTTP package.
It just works because that interface is implemented

00:12:06.779 --> 00:12:13.820
implicitly and there's examples of this everywhere.
I mean, you can just as easily, say, encode

00:12:13.820 --> 00:12:21.430
an image to a writer or you can--internally
in the HTTP handler, we have like, if you--if

00:12:21.430 --> 00:12:27.270
you're writing GZIPed HTTP request, you can
just chain these writers to write from this

00:12:27.270 --> 00:12:32.880
response writer to a GZIP writer to the network
connection itself that sends the response

00:12:32.880 --> 00:12:40.149
to the user. So this becomes very, very powerful
once you're coding at scale and it really

00:12:40.149 --> 00:12:46.089
helps to decouple pieces of code and make
them independent of each other and very easy

00:12:46.089 --> 00:12:55.770
to mix and match. And now a bit about Go's
concurrency features. Who is familiar with

00:12:55.770 --> 00:13:03.829
UNIX environments? It's the world, isn't it?
In UNIX we think about processes that are

00:13:03.829 --> 00:13:10.920
connected by pipes. If I wanted to find all
of the number of lines of test code in the

00:13:10.920 --> 00:13:15.740
Go standard library, I could issue a find
to find all the file names in the Go package

00:13:15.740 --> 00:13:22.980
tree, grep them for file sending in test and
then pipe that into a word count and get the

00:13:22.980 --> 00:13:29.209
number of lines. Each of these tools is a
simple tool designed to do one thing and to

00:13:29.209 --> 00:13:32.649
do it well. And this is--this is the UNIX
philosophy, right? And so we have standard

00:13:32.649 --> 00:13:39.079
interface between each of those and then they
can just be connected indiscriminately. The

00:13:39.079 --> 00:13:45.889
analogue in Go is that you have goroutines
that are connected by channels. So what's

00:13:45.889 --> 00:13:51.589
a goroutine? A goroutine is like a thread.
They share memory like a typical threading

00:13:51.589 --> 00:13:56.160
environment, but they're much cheaper than
threads. Goroutines have segmented stats which

00:13:56.160 --> 00:14:00.639
means that they can be created in only a few
kilobytes so they're very, very cheap to create

00:14:00.639 --> 00:14:08.649
and destroy. And the go runtime typically
schedules many of these goroutines across

00:14:08.649 --> 00:14:13.899
a fewer number of operating system threads,
often only a handful. It's possible to have

00:14:13.899 --> 00:14:19.889
thousands or tens of thousands of goroutines
running in a program that is essentially single-threaded.

00:14:19.889 --> 00:14:25.839
So the syntax to launch a goroutine is using
the Go keyword. If I had some function Sort

00:14:25.839 --> 00:14:35.490
that takes a list and sorts it, I could choose
a pivot i and then sort each part of that

00:14:35.490 --> 00:14:43.769
list in separate goroutines by saying go sort
which calls the sort function in a new goroutine.

00:14:43.769 --> 00:14:48.610
The other part of go's concurrency model are
channels. Channels are a typed conduit for

00:14:48.610 --> 00:14:55.160
synchronization and communication. So, a channel
can send or receive any go type. So unlike

00:14:55.160 --> 00:15:03.149
UNIX pipes which are simply binary data, channels
are typed. And the way you use a channel is

00:15:03.149 --> 00:15:10.389
with the channel operator which is a "&lt;-". It
looks like an arrow and you use that to send

00:15:10.389 --> 00:15:12.879
and receive values through a channel and the
data moves in the direction of the arrow.

00:15:12.879 --> 00:15:19.520
So in this compute function here, compute
takes a channel of integers called CH and

00:15:19.520 --> 00:15:24.839
then it will call the function some computation
and send the result of that function to the

00:15:24.839 --> 00:15:29.750
channel CH. And then in the main function,
we can create a channel of integers using

00:15:29.750 --> 00:15:37.080
the make function, store that in CH, launch
a goroutine that calls compute. And so the

00:15:37.080 --> 00:15:41.980
compute will go off and run this function,
send the resulting value on CH. Meanwhile,

00:15:41.980 --> 00:15:47.230
in my main function, in the main goroutine,
I receive a value from that channel and store

00:15:47.230 --> 00:15:53.939
it in result and then later, I can do something
with that result. So to give a better example

00:15:53.939 --> 00:15:58.480
of synchronization, let's look back at the
sort example. I had these two goroutines that

00:15:58.480 --> 00:16:02.959
have gone off and are sorting this list, each
take a part of the list to sort. But then

00:16:02.959 --> 00:16:08.639
how do I know when they are finished? I can
use a channel to synchronize those goroutines

00:16:08.639 --> 00:16:14.019
so that I can find out when they're both finished
and therefore, when the list is sorted. So

00:16:14.019 --> 00:16:17.689
in this example, I created channel done which
is just a channel of Boolean values. It could

00:16:17.689 --> 00:16:21.529
be a channel of any kind of values. What I'm
interested in is the message that something

00:16:21.529 --> 00:16:29.180
has happened, not the value itself. And then
I create a doSort closure. So Go has closures,

00:16:29.180 --> 00:16:38.560
it encloses the done channel. And doSort takes
a slice, S, sorts that slice, and when it's

00:16:38.560 --> 00:16:42.889
finished, it just sends the value true to
that channel. It could be false, it doesn't

00:16:42.889 --> 00:16:48.970
matter what the value actually is. And then
back in the main goroutine, I choose the pivot

00:16:48.970 --> 00:16:54.879
and actually launch two new goroutines that
do that sort. And then after they're done,

00:16:54.879 --> 00:17:00.009
I just receive two values from the done channel.
After I've received both of those values,

00:17:00.009 --> 00:17:06.180
I know that both the sort operations are completed
and so I can continue on with the code. And

00:17:06.180 --> 00:17:10.910
this works because unbuffered channel operations
are synchronous and they only happen when

00:17:10.910 --> 00:17:19.710
the sending side and the receiving side are
both ready to make the operation happen. So,

00:17:19.710 --> 00:17:25.810
slightly more concrete example of communication.
In a typical sort of threading model, you

00:17:25.810 --> 00:17:31.890
might have many workers that feed from a task
pool and in a traditional sense you would

00:17:31.890 --> 00:17:35.634
have worker threads contending over some lock
for a pool of work. And so it doesn't matter

00:17:35.634 --> 00:17:41.280
if you don't really understand what this code
means precisely, but basically we have this

00:17:41.280 --> 00:17:47.800
pool which has a Mutex in it and a list of
tasks. And then if I have some worker function

00:17:47.800 --> 00:17:52.230
and if many of those are running concurrently,
if they want to get a new piece of work, they

00:17:52.230 --> 00:17:56.250
have to take that lock, they have to pick
the next task out of the pool, and then they

00:17:56.250 --> 00:18:00.420
have to adjust the pools length, and then
release the lock, and then they can process

00:18:00.420 --> 00:18:09.130
the task. So already my function is--my worker
function is more concerned with dealing with

00:18:09.130 --> 00:18:13.000
the concurrency model than it is in actually
doing the work which is--we think is the wrong

00:18:13.000 --> 00:18:18.640
way to think about it. In Go, a more idiomatic
way to do this in Go would be to have many

00:18:18.640 --> 00:18:22.990
worker goroutines that just receive tasks
from a channel and then they send the tasks

00:18:22.990 --> 00:18:28.930
to another channel when they're done. So in
this case, I have a worker function, many

00:18:28.930 --> 00:18:34.740
of which will be running and set with their
own goroutines, and then they just loop forever,

00:18:34.740 --> 00:18:41.280
receiving work from an in channel and processing
it and then sending work to an out channel.

00:18:41.280 --> 00:18:49.030
And so in my main function, I create two channels:
pending and done. And then I launch some goroutine

00:18:49.030 --> 00:18:53.701
to create work somewhere and that would just
send work on the pending channel. And then

00:18:53.701 --> 00:18:59.440
I launch 10 workers to receive work from the
pending channel, work on it and send it to

00:18:59.440 --> 00:19:06.150
done. And then I've launched function consumeWork
to just consume the work that's actually being

00:19:06.150 --> 00:19:12.410
completed. And so in this sense, all we're
looking at here is--the only code on the screen

00:19:12.410 --> 00:19:16.121
is code that's actually concerned with doing
what we want to do. We don't have to think

00:19:16.121 --> 00:19:22.220
about locks, we don't have to think about
contention or anything like that. It's simply

00:19:22.220 --> 00:19:27.430
the code required to express the problem and
that's the real elegance of the system. So

00:19:27.430 --> 00:19:33.470
goroutines, they give you the efficiency of
an asynchronous model of like an event-driven

00:19:33.470 --> 00:19:39.150
model, except you can write code in asynchronous
style. You just write goroutines to do their

00:19:39.150 --> 00:19:45.040
specific jobs well, to think about their specific
problem and then you connect them together

00:19:45.040 --> 00:19:50.560
with channels. And in practice, this yields
much, much simpler code and much more maintainable

00:19:50.560 --> 00:19:56.820
code because it's a lot easier to reason about
a single goroutine or a single function which

00:19:56.820 --> 00:20:04.710
has a specific job to do. And so, Go encourage
you to think--encourages you to think about

00:20:04.710 --> 00:20:07.431
the concurrency--the concurrency issues that
actually matter. And our sort of mantra is

00:20:07.431 --> 00:20:12.900
don't communicate by sharing memory. Instead,
you can share memory by communicating about

00:20:12.900 --> 00:20:20.450
that memory. Another really nice thing about
Go is it has quite a rich standard library

00:20:20.450 --> 00:20:25.550
and it's very carefully constructed and consistent.
And so we have more than 150 packages in the

00:20:25.550 --> 00:20:30.560
standard library and it's constantly under
development. It's practically improving everyday,

00:20:30.560 --> 00:20:34.330
literally improving probably every couple
of days with a huge amount of progress being

00:20:34.330 --> 00:20:40.770
made in this regard, which is great. And beyond
the standard library, we also have more than

00:20:40.770 --> 00:20:46.870
200 packages listed on our package dashboard
with like, MySQL, MongoDB, other database

00:20:46.870 --> 00:20:53.600
drivers, SDL bindings for doing graphics and
audio, protocol buffers for communicating

00:20:53.600 --> 00:21:01.030
across networks, and OAuth libraries for interacting
with foreign systems and APIs. Now, let's

00:21:01.030 --> 00:21:07.670
quickly give you a glance at the Go center
library. So this is the list of the standard

00:21:07.670 --> 00:21:15.650
library about archivers, compression, Kryptos,
a lot of Krypto actually, encodings, X11,

00:21:15.650 --> 00:21:20.850
packages for reading Go code, HTPP, and so
on and so on. And this is the package dashboard

00:21:20.850 --> 00:21:26.640
which lists recent installs of packages, Go
packages by third parties. And so you can

00:21:26.640 --> 00:21:29.850
see there's a huge amount of activity going
on there. So it's very much an ecosystem that's

00:21:29.850 --> 00:21:38.210
thriving and alive and well. So now, for the
sort of second part, what is Go actually good

00:21:38.210 --> 00:21:45.950
for? Well, when we launched Go, we called
it a "Systems language" which was probably

00:21:45.950 --> 00:21:51.530
a bit misleading. We originally thought it
would be ever--it would be a good replacement

00:21:51.530 --> 00:21:56.570
language for the kind of things we were using
C++ and Java for at Google. But it turned

00:21:56.570 --> 00:21:59.620
out that there was a lot of interest from
people in the dynamic languages camps. There

00:21:59.620 --> 00:22:05.660
are a lot of people frustrated by the scripting
languages that we're using and they were enticed

00:22:05.660 --> 00:22:13.031
by an easy-to-use, reliable language that
performs well. And so we've seen a lot of

00:22:13.031 --> 00:22:18.400
diverse uses of Go from around the world in
scientific computing, web applications, graphics,

00:22:18.400 --> 00:22:22.880
network tools, and much more. More than I
can enumerate here. And so now we just call

00:22:22.880 --> 00:22:30.600
Go a "General-purpose language." So let's
look at our real world examples. The first

00:22:30.600 --> 00:22:38.330
example I want to look at is Heroku. Who's
heard of Heroku, anyone? They are a cloud

00:22:38.330 --> 00:22:44.420
hosting company for Ruby programmers. And
two guys there, Keith and Blake, were designing

00:22:44.420 --> 00:22:50.680
a "distributed init system" for their--for
their cluster of virtual machines and they

00:22:50.680 --> 00:22:55.120
needed it to manage processors across this
speed fleet in a way that it could recover

00:22:55.120 --> 00:23:00.390
gracefully from instance failures, network
partitions and so on. And so they needed a

00:23:00.390 --> 00:23:06.860
way to reliably synchronize and share information
among those servers in a way that is consistent.

00:23:06.860 --> 00:23:11.890
And so they wrote something called Doozer.
So Doozer is a basis for building distributed

00:23:11.890 --> 00:23:17.930
systems. It's a highly available consistent
data store and what it does is it provides

00:23:17.930 --> 00:23:23.640
a single fundamental synchronization primitive
called compare-and-set which can be used as

00:23:23.640 --> 00:23:29.190
the basis for building any kind of synchronization
operation. And indeed, in Go's memory model,

00:23:29.190 --> 00:23:34.610
we used compare-and-set internally to implement
that. But this is compare-and-set over a network

00:23:34.610 --> 00:23:39.420
and so, it can be used for a whole range of
things. They say that Doozer is where you

00:23:39.420 --> 00:23:46.910
put the family jewels and one typical example
of a system like this is in database master

00:23:46.910 --> 00:23:55.580
election. So imagine you have a master--database
master and several slaves. If the master goes

00:23:55.580 --> 00:24:03.150
away and just disappears, what do the slaves
do? They can use Doozer to decide who gets

00:24:03.150 --> 00:24:08.430
to be the next master or similarly, if you
have, say, a cluster environment which is

00:24:08.430 --> 00:24:12.590
high performance and needs to be readily available;
you can use Doozer as a name service. You

00:24:12.590 --> 00:24:17.600
could use DNS but then there's propagation
delays and other issues associated with that.

00:24:17.600 --> 00:24:21.790
Using Doozer instead, you can just push all
of your name information to there and then

00:24:21.790 --> 00:24:26.760
you know that every node in your network is
seeing the same information at the same time

00:24:26.760 --> 00:24:30.770
in a way that is available and consistent.
And the same goes for configuration. They

00:24:30.770 --> 00:24:36.440
push a lot of their configuration data into
Doozer and they--and that means that all of

00:24:36.440 --> 00:24:40.480
the servers know the state of the system simultaneously.
They know what they're supposed to be doing

00:24:40.480 --> 00:24:46.960
and it--they can rely on that to be true.
So why did they choose Go to do this? Well,

00:24:46.960 --> 00:24:53.870
first and foremost, Go's concurrency primitives
suit the problem. Doozer uses a product called

00:24:53.870 --> 00:25:00.080
Paxos to achieve the consensus between nodes.
And Paxos is a very, very complicated distributed

00:25:00.080 --> 00:25:06.470
algorithm that is described in terms of separate
entities that communicate by sending messages

00:25:06.470 --> 00:25:12.460
asynchronously. And it's very, very hard to
get this right. There are a lot of implementations

00:25:12.460 --> 00:25:17.770
out there and many of the example implementations
used to educate people about Paxos are full

00:25:17.770 --> 00:25:23.150
of errors. But they found that Goroutines
and channels actually made it manageable or

00:25:23.150 --> 00:25:28.290
even easy to implement Paxos. So that's probably
too strong a word; it's still hard. But they

00:25:28.290 --> 00:25:32.300
said that in--this is a quote from them on
the Go blog that they write for us a couple

00:25:32.300 --> 00:25:37.170
of weeks ago and they said that, "In the same
way that garbage collectors improve upon malloc

00:25:37.170 --> 00:25:42.650
and free, we found that goroutines and channels
improve upon lock-based approach to concurrency.

00:25:42.650 --> 00:25:46.810
These tools let us avoid complex bookkeeping
and stay focused on the problem at hand. We

00:25:46.810 --> 00:25:50.610
are still amazed at how few lines of code
it took to achieve something renowned for

00:25:50.610 --> 00:25:57.000
being so difficult." So that's quite a testimonial.
They also found Go convenient. Through it's

00:25:57.000 --> 00:26:02.580
standard library, they were able to implement
a web-based administration console for Doozer

00:26:02.580 --> 00:26:08.020
in literally a train ride. And so they said
this is a real testament to how well Go mixes

00:26:08.020 --> 00:26:13.890
systems and applications programming. And
finally they said that Go has a mechanical

00:26:13.890 --> 00:26:19.580
source formatter called gofnt, and which is
used to make all Go code look the same and

00:26:19.580 --> 00:26:24.160
settle any syntax disputes. And they found
that they never argued over where to put a

00:26:24.160 --> 00:26:28.240
curly-brace, tabs versus spaces, or if we
should align assignments. Who's had an argument

00:26:28.240 --> 00:26:34.510
with a colleague about syntax issues? Seriously.
I know I have, but I haven't since I've started

00:26:34.510 --> 00:26:39.940
running Go code. They just simply agreed that
the buck stopped at the output of gofnt which

00:26:39.940 --> 00:26:46.050
is great. My next example comes from New Zealand
from a company called "MROffice." And one

00:26:46.050 --> 00:26:52.000
man, Kees Varekamp, had a background in market
research software but he found most of the

00:26:52.000 --> 00:26:57.730
existing software in that space to be pretty
lacking. So he launched his company MROffice

00:26:57.730 --> 00:27:03.920
in 2010 to make better software for this industry.
And the flagship product he designed is called

00:27:03.920 --> 00:27:09.610
"Dialer." And what it does is, in a call center
environment, you have many interviewers who

00:27:09.610 --> 00:27:16.630
are called calling people to perform interviews
and they have interview software that provides

00:27:16.630 --> 00:27:22.070
scripts for those interviews and collects
statistics. And they have a VoIP gateway for

00:27:22.070 --> 00:27:27.600
actually making the telephony calls. But they
needed some--Dialer solves the problem of

00:27:27.600 --> 00:27:32.080
choosing numbers to call and calling them
such that no interviewer is waiting for people

00:27:32.080 --> 00:27:36.910
to pickup and such that no interviewee is
being kept on hold before an interviewer arrives.

00:27:36.910 --> 00:27:41.480
It's actually quite a difficult problem and
one that he seems to have solved well. So

00:27:41.480 --> 00:27:46.670
originally he wrote Dialer in Python. And
he said, "I love Python," and uses it for

00:27:46.670 --> 00:27:50.530
everything but he found that long-running
server processes are not--it's not such a

00:27:50.530 --> 00:27:54.920
good choice for those. There's a lot--he was
getting lots of runtime errors that could

00:27:54.920 --> 00:27:59.740
have been caught during compile time. And
he said, "When Go came out, it would immediately

00:27:59.740 --> 00:28:04.020
made sense to me, it was type safe, compiled,
and feels like a scripting language." So he

00:28:04.020 --> 00:28:08.980
ported his code base to Go and it worked for
him because he found that the concurrency

00:28:08.980 --> 00:28:13.940
model really suited the problem he was having.
If you have a Go routine to handle each call,

00:28:13.940 --> 00:28:18.740
each interviewer, and each interviewee, and
goroutines to connect those together, you

00:28:18.740 --> 00:28:24.590
can then they--and communicate together via
channels. It greatly simplified the problem.

00:28:24.590 --> 00:28:29.560
And he also found that the HTTP and websocket
libraries made it really easy for him to just

00:28:29.560 --> 00:28:35.330
throw together a management user interface.
So, he has this beta product now running in

00:28:35.330 --> 00:28:40.480
multiple core call centers around the world.
And he's also working on a predictive Dialer

00:28:40.480 --> 00:28:46.080
design using neural networks and pushing the
features even further. And his conclusions

00:28:46.080 --> 00:28:51.260
about Go is he found the tutorials and documentation
were excellent. And he said, "I've been converted

00:28:51.260 --> 00:28:55.440
to statistically typed languages," which I
think is one of the nicest testimonials I've

00:28:55.440 --> 00:28:59.350
heard about Go. And he says that, "Go is a
good compromise for cooperation between type

00:28:59.350 --> 00:29:05.440
purists and lazy scripters." And I think he
was describing himself as a lazy scripter.

00:29:05.440 --> 00:29:12.140
My next example is from a company called "Atlassian."
Atlassian make development and collaboration

00:29:12.140 --> 00:29:17.730
tools for the developers. They're as a worldwide
company and they mostly develop in Java. But

00:29:17.730 --> 00:29:21.530
they have this testing cluster of virtual
machines which they use to test all their

00:29:21.530 --> 00:29:27.980
software across and they run in a large number
of this diskless hosts. And it has a provisioning

00:29:27.980 --> 00:29:33.100
and monitoring system that's written in Go.
And so that system consists of three parts;

00:29:33.100 --> 00:29:40.540
there's an agent that runs on each virtual
machine and it monitors the state of the virtual

00:29:40.540 --> 00:29:45.130
machine; broadcasting that stayed across the
land. A manager process that listens to those

00:29:45.130 --> 00:29:51.950
agents broadcasts and then takes some action
if the virtual machine fails to report. And

00:29:51.950 --> 00:29:57.910
a command line tool for issuing commands to
the manager process. So the agent itself is

00:29:57.910 --> 00:30:03.440
trivial. It just sits there looping endlessly
reading its state from the proc virtual file

00:30:03.440 --> 00:30:07.790
system, encoding that state in a protocol
buffer, and broadcasting it out across the

00:30:07.790 --> 00:30:13.090
network. And then the manager process, when
it starts up it reads a configuration file,

00:30:13.090 --> 00:30:17.980
launches the goroutine. One goroutine for
each Virtual Machine in the cluster and each

00:30:17.980 --> 00:30:24.070
of those goroutine's just listens for those
announcements from the agent. And if it fails

00:30:24.070 --> 00:30:29.890
to check in, it will issue instructions usually
via shell commands to keep that machine in

00:30:29.890 --> 00:30:36.280
the correct state. And so this is a kind of
diagram of how that works. We have physical

00:30:36.280 --> 00:30:40.150
machines which each have VMs which each have
Agents. And each of those Agents corresponds

00:30:40.150 --> 00:30:48.250
to a goroutine running in a single manager
process. So he--Dave Cheney who wrote this

00:30:48.250 --> 00:30:55.070
found it really easy to deploy and ship binaries
using Go because Go binaries are all statically

00:30:55.070 --> 00:31:01.340
linked and have no dependencies. And so, he
just was able to push out these binaries to

00:31:01.340 --> 00:31:06.890
these diskless hosts and he found it much
easier compared to shipping a JVM or a Python

00:31:06.890 --> 00:31:12.390
runtime. And he also found that the one goroutine
per Virtual Machine made the problem really

00:31:12.390 --> 00:31:18.190
easy to approach. And he said it was trivial
in Go but really painful in other languages

00:31:18.190 --> 00:31:26.170
that he tried. So my next example and final
example is a system called Camlistore which

00:31:26.170 --> 00:31:33.600
is written by Brad Fitzpatrick and he wanted
to store his data across all of his devices

00:31:33.600 --> 00:31:37.704
and to share that data with his friends and
the public, and it really is that general.

00:31:37.704 --> 00:31:43.810
He wanted to make a system for storing all
data and sharing it with anyone. And so, at

00:31:43.810 --> 00:31:48.130
its core, Camlistore is a content-addressable
data store which means that all content in

00:31:48.130 --> 00:31:54.170
the system is identified by a hash of its
content. It's a synchronization and access-control

00:31:54.170 --> 00:32:00.770
mechanism for that data across data stores.
It's an application programming interface

00:32:00.770 --> 00:32:06.520
for people that want to interact with the
system. It has a user interface. It is considered

00:32:06.520 --> 00:32:11.540
your 'home directory for the web' and finally,
it's programming language-agnostic. It's not

00:32:11.540 --> 00:32:19.160
Go specific, except the largest parts of it
are written in Go. So use cases with Camlistore,

00:32:19.160 --> 00:32:24.870
say, personal backups which you can automatically
synchronize to various cloud files service--file

00:32:24.870 --> 00:32:34.020
hosting services or other systems in other
places as--or a drop box style file synchronization

00:32:34.020 --> 00:32:40.500
mechanism for synchronizing your working data
across machines. You an use it for photo management

00:32:40.500 --> 00:32:44.490
and sharing. There's an Android app so that
if you take a photo, it can automatically

00:32:44.490 --> 00:32:49.460
get pushed out to your Camlistore and shared
with anybody who has access rights to your

00:32:49.460 --> 00:32:54.750
photos. And you can also use it for website
content management. So if you want to push

00:32:54.750 --> 00:33:00.100
objects into there and have them served out
over HTTP; that will work as well. So the

00:33:00.100 --> 00:33:05.400
Go parts of Camlistore are the Camlistore
daemon which is the blobserver in itself.

00:33:05.400 --> 00:33:10.610
The thing that stores all the data and HTTP
server for interacting with Camlistore clients

00:33:10.610 --> 00:33:17.370
if I have a Camlistore API; a user interface
for users and administrators; and also some

00:33:17.370 --> 00:33:22.750
command-line tools. Camput and camget for
interacting with the data store, camsync for

00:33:22.750 --> 00:33:27.580
synchronizing data stores, and probably the
most interesting example is cammount which

00:33:27.580 --> 00:33:33.660
is a FUSE file system like user line filesystem
which you can use to access data directly

00:33:33.660 --> 00:33:40.720
from a Camlistore blob server. It also includes
about two dozen as sort of libraries which

00:33:40.720 --> 00:33:45.490
he wrote in the process of building Camlistore.
And each of those libraries is not just something

00:33:45.490 --> 00:33:51.770
that's tied inherently through Camlistore
proper. It's something that--they're all little

00:33:51.770 --> 00:33:54.780
pieces that you can pull out and use in other
pieces of software and--which he has done

00:33:54.780 --> 00:34:00.400
and others have done. And so, why did he choose
to write it in Go? Well, this is a kind of--this

00:34:00.400 --> 00:34:05.730
is the nicest Go testimonial I've seen. He
said, "I've been running Go for over a year

00:34:05.730 --> 00:34:10.839
now and it makes me giddy about programming
again. Annoying things that aren't annoying,

00:34:10.839 --> 00:34:15.389
trade-offs that I normally worry about I no
longer worry about. I bust out lots of fast,

00:34:15.389 --> 00:34:20.419
correct, maintainable testable code in very
small amounts of time," and he hasn't been

00:34:20.419 --> 00:34:25.940
this excited about a language in ages. I asked
him how long it took him to write Cammount,

00:34:25.940 --> 00:34:30.539
the FUSE file system thing and he just said,
"Oh, two or three beers." Like literally,

00:34:30.539 --> 00:34:36.379
it's that productive a language. And we also
asked, you know, "Why didn't you write Camlistore

00:34:36.379 --> 00:34:39.649
before?" He said, "Well, I have the idea for
a very long time but it wasn't until I got

00:34:39.649 --> 00:34:45.540
familiar with Go that I felt that it was actually
possible. It just always had seemed too painful

00:34:45.540 --> 00:34:52.139
before then." So in this presentation, I've
shown four examples of Go being used in very

00:34:52.139 --> 00:35:00.720
different ways. We have this rock-solid systems
programming language in Doozer. We have Go

00:35:00.720 --> 00:35:07.859
being used for simple and reliable applications
programming in Dialer. We've seen just simple

00:35:07.859 --> 00:35:13.400
utility programming, utilizing Go's concurrency
support at Atlassian. And with Camlistore,

00:35:13.400 --> 00:35:20.589
we've seen a "full stack" programming happening
from data store to user interface, Go has

00:35:20.589 --> 00:35:25.920
been more than capable of all of these things.
So one thing I haven't mentioned so far is

00:35:25.920 --> 00:35:34.099
that Go is Open Source. It began at Google
in 2007 as a 20% project and was --but in

00:35:34.099 --> 00:35:43.640
November 2009, we released it under the BSD
license, so it's totally free. Since its release,

00:35:43.640 --> 00:35:48.731
more than 130 non-Google contributors have
submitted over 1,000 changes to the Go core.

00:35:48.731 --> 00:35:54.519
And so there's a huge community involvement
in developing Go. About 10 Go employees work--Google

00:35:54.519 --> 00:36:01.289
employees work on Go full-time. And we have
two non-Google committers, those are people

00:36:01.289 --> 00:36:05.630
who can commit straight to the Go core and
dozens of regular contributors, people who

00:36:05.630 --> 00:36:13.099
write code for us every week. So all of Go
development takes place on public mailing

00:36:13.099 --> 00:36:17.309
lists. All that code reviews, and all that
prices is fully visible to the outside world.

00:36:17.309 --> 00:36:23.560
And I invite you now, if this kind of thing
interests you, to get involved. We're very

00:36:23.560 --> 00:36:27.339
open to new contributors. We have a lot of
documentation for getting started working

00:36:27.339 --> 00:36:33.130
with the Go core and we welcome anybody who
wants to contribute to our project. So, I've

00:36:33.130 --> 00:36:37.650
only really scratched the surface about what
Go is about here. There is a lot more to it

00:36:37.650 --> 00:36:44.720
still and you can learn a lot more about Go
at I/O today, and tomorrow, and the next day.

00:36:44.720 --> 00:36:53.490
This afternoon, I'm taking a workshop called
"Get Started with Go" which will be a hands-on--getting

00:36:53.490 --> 00:37:02.240
started with the Go language and I'm doing
that twice. There's two sessions, one and

00:37:02.240 --> 00:37:06.619
a repeat. And tomorrow, Rob Pike and I will
be giving a talk called "Writing web apps

00:37:06.619 --> 00:37:10.790
in Go." I strongly encourage you to come along
to that. There'll be surprises, there will

00:37:10.790 --> 00:37:17.970
be course schwag. And at office hours from
12:00 to 3:00 at I/O on both days, you can

00:37:17.970 --> 00:37:23.930
meet with some of the Go team and have all
of your questions answered. And if you're

00:37:23.930 --> 00:37:28.759
interested in pursuing this further now, I
strongly encourage you to visit our website

00:37:28.759 --> 00:37:34.650
or our official blog. There's a huge wealth
of information there and a lot of articles

00:37:34.650 --> 00:37:41.720
and a lot of informative stuff to get you
started. So, does anybody have any questions?

00:37:41.720 --> 00:37:47.890
&gt;&gt; Where is Go being used inside Google?
&gt;&gt; GERRAND: The question was where is Go being

00:37:47.890 --> 00:37:52.519
used inside Google. Unfortunately, I can't
answer that question, but I can say that it

00:37:52.519 --> 00:37:58.420
is being used in a lot of places for a variety
of purposes. But I can say that one place

00:37:58.420 --> 00:38:04.670
where it has seen a lot of adoption is in
the operations kind of tasks where you have

00:38:04.670 --> 00:38:09.150
people who administer large systems who typically
write--would write scripts to do things across

00:38:09.150 --> 00:38:13.320
a vast number of machines. They can now do
this in Go and they find it a lot more of--a

00:38:13.320 --> 00:38:19.450
much more efficient language than what they
have been using before. Anything else? Yeah.

00:38:19.450 --> 00:38:24.665
&gt;&gt; Is anyone using Go for embedded programming
and what's the state of the arm compiler?

00:38:24.665 --> 00:38:28.089
&gt;&gt; GERRAND: The question was "Is anybody using
Go for embedded programming and what's the

00:38:28.089 --> 00:38:35.359
state of the arm compiler?" I'm not--I'm not
aware of anybody using it for embedded proper.

00:38:35.359 --> 00:38:42.241
I know a while ago somebody was--the guy who
started the arm port over a year ago did so

00:38:42.241 --> 00:38:51.170
because he wanted to run it on a small embedded
device to drive one of those 3D milling machines.

00:38:51.170 --> 00:38:56.180
So, I know that's happened but I haven't heard
much about that since. But we've been--the

00:38:56.180 --> 00:39:00.869
Go compiler is mature and it is stable and
we've tracked the build status of it, and

00:39:00.869 --> 00:39:07.270
we run builders on the Nexus One phones. So,
it runs on where Android will run. And it--you

00:39:07.270 --> 00:39:14.590
know, I can imagine it will be able to power
Android applications at some point, but it's

00:39:14.590 --> 00:39:18.320
a matter of doing the heavy lifting involved
in building the interfaces to do that. But

00:39:18.320 --> 00:39:22.970
we're very, very committed to arm as a platform.
It's certainly not a second class citizen.

00:39:22.970 --> 00:39:25.670
We've invested a huge amount of time in making
our arm compiler really mature and the code

00:39:25.670 --> 00:39:27.750
generation really efficient. Yup.
&gt;&gt; Why is there a--what's the use of the distinction

00:39:27.750 --> 00:39:41.839
between the new and make keywords?
&gt;&gt; GERRAND: The question was what's the distinction

00:39:41.839 --> 00:39:47.420
between the new and make keywords? I don't
think I showed new in this talk. But I may

00:39:47.420 --> 00:39:49.839
have.
&gt;&gt; You made channels.

00:39:49.839 --> 00:39:56.070
&gt;&gt; GERRAND: Yeah, so, make is for initializing
internal Go data structures like maps or slices

00:39:56.070 --> 00:40:04.319
or channels, and new is for initializing instances
of user defined types or built-in types. New

00:40:04.319 --> 00:40:09.962
just initialize--it allocates the memory and
returns to the point of that memory and that's

00:40:09.962 --> 00:40:13.869
all it does. But make actually does something
more than just allocating. Yeah.

00:40:13.869 --> 00:40:23.717
&gt;&gt; Is there common pitfalls that you see with
the people trying Go, starting from C++ or

00:40:23.717 --> 00:40:25.190
Java?
&gt;&gt; GERRAND: The question is, "Are there common

00:40:25.190 --> 00:40:31.230
pitfalls to people starting from C++ or Java
who'd get in to Go?" The most common pitfall

00:40:31.230 --> 00:40:38.319
is people tend to bring with them a whole
lot of patents that they inherit from these

00:40:38.319 --> 00:40:43.010
sort of traditional object oriented languages.
And as I mentioned, Go doesn't have classes.

00:40:43.010 --> 00:40:47.240
It doesn't encourage you to use subtype inheritance
and there is something that's like inheritance

00:40:47.240 --> 00:40:54.990
but it's much less far reaching. And really,
I think the biggest hurdle is that people

00:40:54.990 --> 00:41:01.599
have to say--people often come to our mailing
list and say, you know, "How do I setup this

00:41:01.599 --> 00:41:08.160
particular type hierarchy?" And the answer
is, "Well, don't do that." But the more polite

00:41:08.160 --> 00:41:13.530
answer is, well, what is the problem you're
actually trying to solve? Like, maybe if you--and

00:41:13.530 --> 00:41:17.799
so once we find that once people sort of described
the bigger picture of what they're trying

00:41:17.799 --> 00:41:24.160
to do, there tends to be a more elegant and
idiomatic way of doing that in Go. So I think,

00:41:24.160 --> 00:41:27.529
you know, as with learning all new things,
there's always a process of unlearning involved

00:41:27.529 --> 00:41:31.779
as well. And I think that's actually one of
the things I've enjoyed the most about learning

00:41:31.779 --> 00:41:39.319
Go has been reevaluating a lot of the things
that I had considered a given about programming.

00:41:39.319 --> 00:41:44.099
A lot of that stuff has actually turned out
to be not very important at all. Yeah.

00:41:44.099 --> 00:41:49.609
&gt;&gt; [INDISTINCT].
&gt;&gt; GERRAND: Uh-hmm.

00:41:49.609 --> 00:41:58.650
&gt;&gt; When we talk about the new [INDISTINCT].
&gt;&gt; GERRAND: So, the questions was I showed

00:41:58.650 --> 00:42:07.380
some locks in my code and when would I choose
to use explicit locking versus using channels.

00:42:07.380 --> 00:42:16.289
So, basically you just use whichever is easiest,
whichever is clearest. Sometimes using a lock

00:42:16.289 --> 00:42:21.450
is the most elegant way to express a particular
thing. The classical example in Go is when

00:42:21.450 --> 00:42:27.849
you have some shared data structure that you
want to protect from synchronous access from--sorry,

00:42:27.849 --> 00:42:34.619
from concurrent access. Like--and in that
case, you could setup a Go routine that manages

00:42:34.619 --> 00:42:40.420
that structure and send it instructions via
channels to update or retrieve values from

00:42:40.420 --> 00:42:44.539
that--from that data structure. But often,
it's actually easier to just create a lock

00:42:44.539 --> 00:42:51.269
for that data structure and do it in a typical
way. But Go sort of gives you the freedom

00:42:51.269 --> 00:42:54.530
to either use channels where they're appropriate
or use locks where they're appropriate. There's

00:42:54.530 --> 00:43:00.670
no sort of prescriptiveness there in the language.
Yeah.

00:43:00.670 --> 00:43:06.032
&gt;&gt; You could send the channels via channels.
What's the practical application?

00:43:06.032 --> 00:43:09.569
&gt;&gt; GERRAND: So the question was you can send
channels via channels and what's the practical

00:43:09.569 --> 00:43:17.519
application of this. So, a common application
of this is you--if you--it's a pattern where

00:43:17.519 --> 00:43:22.160
you have some kind of multiplexer that, say,
receives messages on a channel and then wants

00:43:22.160 --> 00:43:28.049
to send it out over a variety of channels
or a range of channels to various goroutines.

00:43:28.049 --> 00:43:34.930
And in--in that situation, if a goroutine
wants to be included in that multiplexer,

00:43:34.930 --> 00:43:39.890
it will actually send the channel to the multiplexer
and the multiplexer will add it to its list

00:43:39.890 --> 00:43:44.089
of channels it should be sending things to.
So in that way, you can kind of register with

00:43:44.089 --> 00:43:51.570
some goroutine and then be associated with
it. And another one is you can create a data

00:43:51.570 --> 00:43:59.329
structure that includes a function value and
a channel, send it to some other Goroutine

00:43:59.329 --> 00:44:03.759
which executes the function and then sends
the result of that function call back down

00:44:03.759 --> 00:44:09.029
the channel to the caller. So it's kind of--I
always kind of envision it as like, you sort

00:44:09.029 --> 00:44:14.170
of coil up a rope and like throw the other
end to somebody actually down a channel and

00:44:14.170 --> 00:44:18.180
then they'd pass things back to you that way.
So, there's some really cool things that you

00:44:18.180 --> 00:44:23.480
can do once you sort of start getting into
the details of it. It's a good question. Anybody

00:44:23.480 --> 00:44:30.130
else? No. Yeah.
&gt;&gt; [INDISTINCT].

00:44:30.130 --> 00:44:36.559
&gt;&gt; GERRAND: The question was what's the preferred
text data for writing Go. The answer is that

00:44:36.559 --> 00:44:42.369
we have decidedly agnostic on this front.
I use Vim. I know some of the other guys on

00:44:42.369 --> 00:44:46.432
the team use some more esoteric editors. We
have eMax users. There are people who use

00:44:46.432 --> 00:44:52.759
the clips, people who use Xcode. In the Go
distribution, there is a misc folder which

00:44:52.759 --> 00:44:58.900
has editor support for a variety of editors.
And we're always keen to have people submit

00:44:58.900 --> 00:45:02.950
support for other editors as well. I know
for Eclipse there is actually a project called

00:45:02.950 --> 00:45:06.380
Go Eclipse which extends their support for
writing Go in Eclipse further. But I'm not

00:45:06.380 --> 00:45:09.009
an Eclipse user so I don't know a hell of
a lot about that but.

00:45:09.009 --> 00:45:15.109
&gt;&gt; [INDISTINCT].
&gt;&gt; GERRAND: So the statement was doesn't that

00:45:15.109 --> 00:45:22.630
make that hard for debugging things if you
can't step through things? But we don't--we

00:45:22.630 --> 00:45:29.400
don't have really a solid IDE integration
in terms of debugging. But in the last few

00:45:29.400 --> 00:45:35.131
months we've really improved our support for
GDB, like a new debugger. And if you have

00:45:35.131 --> 00:45:39.710
an editor that's GDB aware, then that should
be able to interact pretty well with--that

00:45:39.710 --> 00:45:45.579
should be able to debug Go programs pretty
well. But this is definitely something that

00:45:45.579 --> 00:45:51.730
we are looking to improve even further. And
sort of on the roadmap is a dedicated Go debugger

00:45:51.730 --> 00:46:00.920
that we would endeavor to integrate with as
many environments as we could. Yeah.

00:46:00.920 --> 00:46:05.420
&gt;&gt; What was your background prior to that?
&gt;&gt; GERRAND: My background was in applications

00:46:05.420 --> 00:46:10.819
programming and systems programming. I used
to work for a web startup before I started

00:46:10.819 --> 00:46:17.000
at Google, in which I wrote a lot of--a variety
of code from front-end to back-end, to--we

00:46:17.000 --> 00:46:26.460
did a large data mining system. And before
that, I worked for internet providers, building

00:46:26.460 --> 00:46:34.119
applications for them. Anybody else? No? Who's
coming to my workshop this afternoon? Hey,

00:46:34.119 --> 00:46:37.749
victory. Great. I'll see you all there. Thank
you.

