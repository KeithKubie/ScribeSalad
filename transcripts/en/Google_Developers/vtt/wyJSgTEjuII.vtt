WEBVTT
Kind: captions
Language: en

00:00:00.380 --> 00:00:03.730
AMY: Welcome everyone
who's just started

00:00:03.730 --> 00:00:05.680
watching this broadcast.

00:00:05.680 --> 00:00:09.510
And if you want to join in
person, feel free to do.

00:00:09.510 --> 00:00:13.600
There are a few extra slots
left on the Hangout.

00:00:13.600 --> 00:00:19.790
And there's a total of 10, so
if you try to join and can't

00:00:19.790 --> 00:00:21.910
manage it, you can still just
watch the broadcast.

00:00:26.280 --> 00:00:33.120
So let me introduce Proppy,
otherwise known as Johan,

00:00:33.120 --> 00:00:34.790
who's an App Engine dev rel.

00:00:34.790 --> 00:00:39.720
He's been doing a lot of work
with Go the language Go.

00:00:39.720 --> 00:00:44.960
And this is Andrew, another
App Engine dev rel.

00:00:44.960 --> 00:00:47.030
And this is Dave who
works on Go.

00:00:47.030 --> 00:00:49.270
And my name's Amy.

00:00:49.270 --> 00:00:55.960
And Proppy's going to give a
presentation about building Go

00:00:55.960 --> 00:00:57.510
apps on App Engine.

00:00:57.510 --> 00:01:05.150
And we want this to be as
interactive as possible, so we

00:01:05.150 --> 00:01:08.080
encourage a few of you to join
the Hangout if you feel like

00:01:08.080 --> 00:01:10.610
it and ask questions
as we go on.

00:01:10.610 --> 00:01:17.040
And if you know the Go IRC
channel, I think someone's

00:01:17.040 --> 00:01:19.110
monitoring the questions
on that as well.

00:01:19.110 --> 00:01:22.740
ANDREW: And in the App Engine
IRC channel as well.

00:01:22.740 --> 00:01:23.570
AMY: All right, great.

00:01:23.570 --> 00:01:26.450
So let's get started.

00:01:26.450 --> 00:01:28.550
JOHAN EUPHROSINE: So it's a
short presentation explaining

00:01:28.550 --> 00:01:30.670
how to build a simple
application

00:01:30.670 --> 00:01:31.980
with Go on App Engine.

00:01:31.980 --> 00:01:34.190
You can follow the slide along
on proppy-go-ae.appspot.com.

00:01:39.850 --> 00:01:41.920
So a bit of presentation
about me.

00:01:41.920 --> 00:01:43.690
My name is Johan Euphrosine.

00:01:43.690 --> 00:01:46.300
I am working at Google Zurich.

00:01:46.300 --> 00:01:48.920
I'm a developer program engineer
on App Engine, which

00:01:48.920 --> 00:01:51.085
means that I'm supporting
the App Engine Developer

00:01:51.085 --> 00:01:51.790
Community--

00:01:51.790 --> 00:01:55.940
on the forums, on stack
overflow, and also on IRC.

00:01:55.940 --> 00:01:59.970
I write code for a new feature
when there is new SDK release.

00:01:59.970 --> 00:02:02.480
And I write batch code
about best practices.

00:02:02.480 --> 00:02:05.320
You can reach me through
my Google+ profile at

00:02:05.320 --> 00:02:09.050
profiles.google.com/proppy.

00:02:09.050 --> 00:02:14.130
And here is a photo of
me with more hair.

00:02:14.130 --> 00:02:15.630
So what is App Engine?

00:02:15.630 --> 00:02:17.780
So, quickly, App Engine allows
you to scale your web

00:02:17.780 --> 00:02:21.390
applications by running them
on a Google infrastructure.

00:02:21.390 --> 00:02:26.000
So you get to use the same back
end as Gmail, Calendar,

00:02:26.000 --> 00:02:29.380
and other Google properties
exposed as API for your

00:02:29.380 --> 00:02:30.630
application.

00:02:33.250 --> 00:02:37.200
So recently, last year, we
announced the Go Runtime as

00:02:37.200 --> 00:02:38.630
experimental.

00:02:38.630 --> 00:02:41.810
So the Go Runtime has a few
unique properties compared to

00:02:41.810 --> 00:02:45.390
other runtimes of App Engine,
which are Python and Java.

00:02:45.390 --> 00:02:47.560
So each runs native code.

00:02:47.560 --> 00:02:52.510
It has a very low memory
footprint, meaning that the Go

00:02:52.510 --> 00:02:55.510
instance in App Engine usually
consumes less memory than

00:02:55.510 --> 00:02:58.060
other instances.

00:02:58.060 --> 00:03:05.010
It's also faster to start,
because since it's all

00:03:05.010 --> 00:03:08.250
combined to a single binary,
when App Engine starts your

00:03:08.250 --> 00:03:11.130
application, it only has
to read a single file.

00:03:11.130 --> 00:03:15.235
Whereas with Java or Python,
that's [INAUDIBLE]

00:03:15.235 --> 00:03:16.680
your application.

00:03:16.680 --> 00:03:18.810
And also there is [INAUDIBLE]

00:03:18.810 --> 00:03:20.530
for concurrency.

00:03:20.530 --> 00:03:23.722
By default, what happens when
you deploy a Go application in

00:03:23.722 --> 00:03:27.730
App Engine is that you spawn a
Go routine, which is like with

00:03:27.730 --> 00:03:29.800
thread on each request.

00:03:29.800 --> 00:03:34.080
And when one request is doing
some IO, it can process

00:03:34.080 --> 00:03:39.700
another incoming request,
meaning that you get to

00:03:39.700 --> 00:03:45.710
consume less instance-hour,
because your instance is more

00:03:45.710 --> 00:03:49.250
used as there are more
requests coming in.

00:03:49.250 --> 00:03:51.460
The runtime doesn't necessarily
need to spawn new

00:03:51.460 --> 00:03:55.840
instances for a new
Go request.

00:03:55.840 --> 00:03:59.820
So a really simple example
of how to write a web

00:03:59.820 --> 00:04:01.280
application in Go.

00:04:01.280 --> 00:04:05.920
So we just import
a few packages.

00:04:05.920 --> 00:04:10.310
So we'll import the font package
for formatting string,

00:04:10.310 --> 00:04:12.970
and the standard message to the
package, which order you

00:04:12.970 --> 00:04:17.610
to configure with
an HTTP server.

00:04:17.610 --> 00:04:19.820
There is an init function which
is called when Your

00:04:19.820 --> 00:04:20.940
application starts.

00:04:20.940 --> 00:04:28.580
And in this init function, we
just define a root to a URL,

00:04:28.580 --> 00:04:29.990
which is called Hello.

00:04:29.990 --> 00:04:33.596
And we map it to Handler, which
is a function of Hello.

00:04:33.596 --> 00:04:37.035
And then in this function, which
takes two arguments, a

00:04:37.035 --> 00:04:41.080
response writer to write our
response and an HTTP request

00:04:41.080 --> 00:04:49.010
just to get the request writer,
we can write to the

00:04:49.010 --> 00:04:51.360
response writer the
exit we want to

00:04:51.360 --> 00:04:54.605
write into the program.

00:04:54.605 --> 00:04:57.830
In order to deploy it to App
Engine, we need to create a

00:04:57.830 --> 00:05:01.020
small manifest, which will
describe your application.

00:05:01.020 --> 00:05:02.185
We named your application.

00:05:02.185 --> 00:05:05.970
Its name is gopher.

00:05:05.970 --> 00:05:07.840
We tell which runtime
we want to use.

00:05:07.840 --> 00:05:09.460
We want to use Go.

00:05:09.460 --> 00:05:10.560
We define some [INAUDIBLE]

00:05:10.560 --> 00:05:12.010
for static files.

00:05:12.010 --> 00:05:16.470
So if we want images
[INAUDIBLE]

00:05:16.470 --> 00:05:20.330
by your application, which has
defined the best images that

00:05:20.330 --> 00:05:22.820
we have, all the files
which are located in

00:05:22.820 --> 00:05:24.680
the directory images.

00:05:24.680 --> 00:05:27.810
Same for doc.

00:05:27.810 --> 00:05:32.980
Then we just map all URL
to a Go application.

00:05:32.980 --> 00:05:37.310
We can start an experiment with
the application locally

00:05:37.310 --> 00:05:44.780
by starting the development
server, which is embedded in

00:05:44.780 --> 00:05:47.080
the Go SDK.

00:05:47.080 --> 00:05:49.490
And if we want to deploy it
to App Engine, we could

00:05:49.490 --> 00:05:50.260
[INAUDIBLE]

00:05:50.260 --> 00:05:53.576
that and we give it the best
application if we offer it to

00:05:53.576 --> 00:05:56.360
App Engine.

00:05:56.360 --> 00:05:58.800
AMY: I'm going to interrupt
for just a second to

00:05:58.800 --> 00:05:59.650
encourage--

00:05:59.650 --> 00:06:02.810
we saw a few open
Hangout slots.

00:06:02.810 --> 00:06:07.160
So if anyone wants to ask any
questions, please do join.

00:06:07.160 --> 00:06:11.260
And welcome to Marcel
who just joined in.

00:06:11.260 --> 00:06:12.510
JOHAN EUPHROSINE: Welcome.

00:06:14.630 --> 00:06:15.850
I've written a small
demo of the

00:06:15.850 --> 00:06:17.960
application we've just created.

00:06:17.960 --> 00:06:20.440
So it just prints a [INAUDIBLE]
string.

00:06:26.930 --> 00:06:30.570
So now we'll try to do a bit
more complicated thing.

00:06:30.570 --> 00:06:34.670
So I don't know if you are
reading the news like me, but

00:06:34.670 --> 00:06:37.800
I always get it under checking
both Hacker News and

00:06:37.800 --> 00:06:40.040
Programming Reddit
at the same time.

00:06:40.040 --> 00:06:42.805
So we'll write a small
application that will allow us

00:06:42.805 --> 00:06:46.200
to check both at the
same time without

00:06:46.200 --> 00:06:48.360
opening two browser windows.

00:06:48.360 --> 00:06:51.630
So what basically your
application will be doing is

00:06:51.630 --> 00:06:58.932
that it will fetch the JSON and
XML stream of both Hacker

00:06:58.932 --> 00:07:05.060
News and Programming Reddits and
print it to a screen and

00:07:05.060 --> 00:07:06.850
serve it as a text file.

00:07:06.850 --> 00:07:15.050
So, first, in order to be able
to fetch the Hacker News

00:07:15.050 --> 00:07:20.495
stream, we'll import a module
which is called App Engine URL

00:07:20.495 --> 00:07:24.540
Fetch, which allows you to reach
an API on App Engine

00:07:24.540 --> 00:07:28.750
that allows us to fetch
remote HTTP resources.

00:07:28.750 --> 00:07:33.440
We'll be importing encoding in
XML since Hacker News RSS feed

00:07:33.440 --> 00:07:36.140
is encoded in XML.

00:07:36.140 --> 00:07:41.140
And we define a new one there
which is called hackernews,

00:07:41.140 --> 00:07:45.350
and we bind it to the
function hackernews.

00:07:45.350 --> 00:07:48.880
And so here is how we can
decode XML in Go.

00:07:48.880 --> 00:07:53.770
So you can see here the
structure of the RSS feed of

00:07:53.770 --> 00:07:54.700
hackernews.

00:07:54.700 --> 00:07:59.620
So there is a root element which
is called RSS, then a

00:07:59.620 --> 00:08:01.480
tiny amount which is
called channel.

00:08:01.480 --> 00:08:03.870
And for each item in this
channel, there is an

00:08:03.870 --> 00:08:08.160
[INAUDIBLE], which is called
item with both a

00:08:08.160 --> 00:08:10.105
title and a link back.

00:08:10.105 --> 00:08:14.620
So we need to define
some type that will

00:08:14.620 --> 00:08:17.810
map to this XML structure.

00:08:17.810 --> 00:08:21.400
So to do that, we just define
plain structure in Go.

00:08:21.400 --> 00:08:23.760
So the way you define structure
in Go is just that

00:08:23.760 --> 00:08:25.510
you create a new type
declaration.

00:08:25.510 --> 00:08:26.670
You give it a name.

00:08:26.670 --> 00:08:34.100
And then you specify the main
door of your structure.

00:08:34.100 --> 00:08:39.470
So here, for example, we've just
defined a structure for

00:08:39.470 --> 00:08:40.890
the root elements.

00:08:40.890 --> 00:08:45.200
And we said that a feed has
one data element, which is

00:08:45.200 --> 00:08:46.050
called channel.

00:08:46.050 --> 00:08:50.530
So here we have this small
annotation that allow to bind

00:08:50.530 --> 00:08:57.270
or struct elements to the name
of the type in the XML stream.

00:08:57.270 --> 00:08:59.230
So what is a feed data?

00:08:59.230 --> 00:09:02.720
A feed data is a channel, so
it's a collection of XML item.

00:09:02.720 --> 00:09:05.200
So here we just have
a slice of item.

00:09:05.200 --> 00:09:11.810
And each item is a title which
is bound to the title type and

00:09:11.810 --> 00:09:16.830
the URL, which is going to
the root [INAUDIBLE].

00:09:16.830 --> 00:09:19.360
And so here we have no
hierarchy, a structure

00:09:19.360 --> 00:09:24.590
hierarchy, which completely maps
to our RSS feed format.

00:09:28.040 --> 00:09:33.390
And the way we decode that in Go
is quite simple, actually.

00:09:33.390 --> 00:09:35.830
So we create a new function
which is called

00:09:35.830 --> 00:09:38.695
hackernewsItem, Which will take
an App Engine context.

00:09:38.695 --> 00:09:42.335
So an App Engine context is what
is necessary to issue App

00:09:42.335 --> 00:09:45.900
Engine API code, and which are
the collection of items that

00:09:45.900 --> 00:09:49.670
we use that we just defined
on the previous slide.

00:09:49.670 --> 00:09:53.890
So we just create a new URL
fetch client, that will allow

00:09:53.890 --> 00:09:56.880
us to make HTTP requests.

00:09:56.880 --> 00:10:01.150
We issue a Get request to the
feed URL, which is having the

00:10:01.150 --> 00:10:02.950
RSS feed for Hacker News.

00:10:02.950 --> 00:10:07.740
We handle the error, so we
print an error in case we

00:10:07.740 --> 00:10:10.545
don't manage to fetch
a stream.

00:10:14.710 --> 00:10:17.850
When we issue a Get request,
we get a response back.

00:10:17.850 --> 00:10:23.219
A response, we can read
the response with

00:10:23.219 --> 00:10:24.240
the body number .

00:10:24.240 --> 00:10:27.220
And we have to make sure we
close the body before our

00:10:27.220 --> 00:10:27.990
function ends.

00:10:27.990 --> 00:10:30.620
And for that in Go, we have a
very useful keyword, which is

00:10:30.620 --> 00:10:34.120
called "defer," which will allow
you to specify function

00:10:34.120 --> 00:10:37.240
codes to write that will
get executed when

00:10:37.240 --> 00:10:38.630
your function exits.

00:10:38.630 --> 00:10:43.260
So whatever exit form that you
have in your function, if you

00:10:43.260 --> 00:10:47.290
return in the middle of your
function or if you just go

00:10:47.290 --> 00:10:49.600
through the function
to the end, this

00:10:49.600 --> 00:10:52.730
statement will get executed.

00:10:52.730 --> 00:10:55.860
That line ensures that we close
the body before the

00:10:55.860 --> 00:10:57.340
function exits.

00:10:57.340 --> 00:11:02.020
And we create a new decoder
in order to decode

00:11:02.020 --> 00:11:05.445
XML from the body.

00:11:05.445 --> 00:11:07.900
We just [INAUDIBLE]

00:11:07.900 --> 00:11:12.095
the root type that we defined on
the slide before, which is

00:11:12.095 --> 00:11:14.260
a root element of the hierarchy
of the type for

00:11:14.260 --> 00:11:15.700
defining the RSS feed.

00:11:15.700 --> 00:11:17.740
And we call it the
Decode function.

00:11:17.740 --> 00:11:22.040
And what the Decode function
will do is that it will pass

00:11:22.040 --> 00:11:26.820
the XML stream and instantiate
an element.

00:11:26.820 --> 00:11:29.350
The [INAUDIBLE] corresponds
correspond to the type that we

00:11:29.350 --> 00:11:30.810
have given as an argument.

00:11:30.810 --> 00:11:36.650
So when it will go on the
RSS [INAUDIBLE], it will

00:11:36.650 --> 00:11:38.830
instantiate an HNFeed object.

00:11:38.830 --> 00:11:41.760
And when you see a [INAUDIBLE],
it will

00:11:41.760 --> 00:11:44.890
instantiate an HNFeedData
structure.

00:11:44.890 --> 00:11:48.440
And when we see Item
[INAUDIBLE], it will

00:11:48.440 --> 00:11:52.630
instantiate a new item object
for each item that's been

00:11:52.630 --> 00:11:54.520
encountered.

00:11:54.520 --> 00:11:58.440
And so after that, we just have
to return the data items

00:11:58.440 --> 00:12:01.920
that we just passed.

00:12:01.920 --> 00:12:05.940
And so the last thing that we
need to do is to print it back

00:12:05.940 --> 00:12:09.000
to the both other issues
that we [INAUDIBLE].

00:12:09.000 --> 00:12:16.750
So we just set Content-Type
to say it's plain text.

00:12:16.750 --> 00:12:19.910
And we just iterate on the
objects that we get back from

00:12:19.910 --> 00:12:21.495
the hackernews item function.

00:12:21.495 --> 00:12:24.020
Here you can see how to
make [INAUDIBLE].

00:12:24.020 --> 00:12:27.675
So there is a range keyword that
will return both an index

00:12:27.675 --> 00:12:33.400
and an item for each item that
we get back from the

00:12:33.400 --> 00:12:38.180
hackernews item function
[INAUDIBLE], which we just

00:12:38.180 --> 00:12:43.010
print each item title
and each item year.

00:12:43.010 --> 00:12:45.145
So here we can see
a little demo.

00:12:53.230 --> 00:12:54.810
So here we can see
all the links.

00:12:54.810 --> 00:12:59.340
So this tells the URL of each
item that is in the Hacker

00:12:59.340 --> 00:13:00.951
News RSS feed.

00:13:04.250 --> 00:13:07.880
So there's does anyone
have any questions?

00:13:07.880 --> 00:13:08.320
ANDREW: Proppy?

00:13:08.320 --> 00:13:08.760
JOHAN EUPHROSINE: Yeah.

00:13:08.760 --> 00:13:12.180
ANDREW: On the previous slide,
what was the underscore in

00:13:12.180 --> 00:13:14.596
that range statement?

00:13:14.596 --> 00:13:15.020
JOHAN EUPHROSINE: Ah.

00:13:15.020 --> 00:13:18.970
So good question, Andrew.

00:13:18.970 --> 00:13:22.690
So the underscore is to
say that we don't

00:13:22.690 --> 00:13:24.310
want to use this parameter.

00:13:24.310 --> 00:13:26.790
So it just binds
the parameter--

00:13:26.790 --> 00:13:30.250
since we have to explicitly say
that we want to enter this

00:13:30.250 --> 00:13:32.510
[INAUDIBLE].

00:13:32.510 --> 00:13:36.590
So as a range keyword,
we return two

00:13:36.590 --> 00:13:37.850
items for each duration.

00:13:37.850 --> 00:13:40.060
We have to say that we don't
want to enter this parameter.

00:13:40.060 --> 00:13:43.055
So we just-- the [INAUDIBLE],
we say that we don't want to

00:13:43.055 --> 00:13:44.790
enter this parameter.

00:13:44.790 --> 00:13:46.960
ANDREW: So if I did have a
variable there, it would be

00:13:46.960 --> 00:13:49.360
assigned the index page?

00:13:49.360 --> 00:13:49.900
JOHAN EUPHROSINE: Yeah.

00:13:49.900 --> 00:13:54.485
So the range would return both
each index and each element of

00:13:54.485 --> 00:13:57.670
the collection that
is on the right.

00:13:57.670 --> 00:13:59.870
AMY: So I have a question
for you, Proppy.

00:13:59.870 --> 00:14:01.815
This code all looks
pretty clean.

00:14:05.430 --> 00:14:08.680
With what you've shown so far,
what about it do you think is

00:14:08.680 --> 00:14:10.980
maybe easier than writing
in Python?

00:14:10.980 --> 00:14:12.940
Or what maybe is harder?

00:14:12.940 --> 00:14:18.410
How would you like to comment
on that, or would you maybe

00:14:18.410 --> 00:14:21.010
want to wait until you show
a little more code?

00:14:21.010 --> 00:14:23.080
ANDREW: I don't think he's
gotten to the good part yet.

00:14:23.080 --> 00:14:24.630
AMY: OK.

00:14:24.630 --> 00:14:26.350
JOHAN EUPHROSINE: Yeah, that's
an interesting question.

00:14:26.350 --> 00:14:30.650
So in Python you have some
legends that you need to

00:14:30.650 --> 00:14:34.210
decode XML on the fly and
map it to objects.

00:14:34.210 --> 00:14:37.710
That's usually-- what you
get back from that is a

00:14:37.710 --> 00:14:40.980
dictionary, because
you can't--

00:14:40.980 --> 00:14:44.920
they only generate tags that
Python could use without

00:14:44.920 --> 00:14:48.570
knowing it, without knowing what
you want to decode, is

00:14:48.570 --> 00:14:50.550
just a plain dictionary.

00:14:50.550 --> 00:14:54.190
And so the type of [INAUDIBLE]
that you've got the same

00:14:54.190 --> 00:14:58.090
convenience as Python for
decoding arbitrary XML

00:14:58.090 --> 00:15:02.830
structure that you also get
access to because you define

00:15:02.830 --> 00:15:04.960
exactly what you
want to decode.

00:15:04.960 --> 00:15:07.517
And it's not two concrete types
that you have defined in

00:15:07.517 --> 00:15:08.920
your application.

00:15:08.920 --> 00:15:12.450
Whereas in Python, what you
will get, we'll see now.

00:15:12.450 --> 00:15:14.990
It will not be more complicated,
but it will be

00:15:14.990 --> 00:15:16.220
less [INAUDIBLE].

00:15:16.220 --> 00:15:19.590
Because what you will get back
from a general decoder XML

00:15:19.590 --> 00:15:22.870
function will be just
a Python dictionary.

00:15:22.870 --> 00:15:27.260
Whereas in Go, you get proven
types that you have defined.

00:15:27.260 --> 00:15:29.505
ANDREW: So does that mean that
when you're using the Python

00:15:29.505 --> 00:15:32.450
dictionary you would need to
test for the presence of

00:15:32.450 --> 00:15:34.370
various keys?

00:15:34.370 --> 00:15:37.850
Whereas in Go, the data types,
because the fields are always

00:15:37.850 --> 00:15:40.210
present in values of those
types, you don't

00:15:40.210 --> 00:15:43.330
need to do all that?

00:15:43.330 --> 00:15:47.060
JOHAN EUPHROSINE: Basically,
it allows you to address

00:15:47.060 --> 00:15:50.290
[INAUDIBLE] or XML and be sure
that they are there.

00:15:50.290 --> 00:15:56.690
Whereas in Python, you are not
sure what is in the dictionary

00:15:56.690 --> 00:15:57.940
[INAUDIBLE].

00:16:00.830 --> 00:16:04.980
AMY: Just as a Go novice,
that's one thing

00:16:04.980 --> 00:16:05.670
I like about it.

00:16:05.670 --> 00:16:09.790
The strict typing, but the easy
definition, so it doesn't

00:16:09.790 --> 00:16:11.530
have all the syntactic
overhead of

00:16:11.530 --> 00:16:12.700
something like Java.

00:16:12.700 --> 00:16:14.120
JOHAN EUPHROSINE: I think it's
very [INAUDIBLE] that you

00:16:14.120 --> 00:16:18.400
could pass an XML that's in your
line and just annotate

00:16:18.400 --> 00:16:25.580
your type just with simple
annotation binding a field, a

00:16:25.580 --> 00:16:28.700
strict field to XML.

00:16:28.700 --> 00:16:32.210
There is no syntax you could
write for something which is

00:16:32.210 --> 00:16:33.230
not triggered.

00:16:33.230 --> 00:16:36.890
I mean, like data binding is
not a triggered operation.

00:16:36.890 --> 00:16:41.850
I find the solution that Go
uses is very convenient.

00:16:41.850 --> 00:16:44.100
ANDREW: There's also one other
nice thing about it, which is

00:16:44.100 --> 00:16:49.730
that the XML decoder will only
decode and store those fields

00:16:49.730 --> 00:16:52.360
that you actually have present
in your Go data type.

00:16:52.360 --> 00:16:56.920
So if you're decoding a really
large XML stream, you won't

00:16:56.920 --> 00:16:59.090
have to load all that stuff
into memory before

00:16:59.090 --> 00:17:00.130
discarding it again.

00:17:00.130 --> 00:17:02.260
You can just only take out the
fields you're actually

00:17:02.260 --> 00:17:03.288
interested in.

00:17:03.288 --> 00:17:05.700
JOHAN EUPHROSINE: Yeah.

00:17:05.700 --> 00:17:08.980
Whereas when you write for
Python, generally the Decode

00:17:08.980 --> 00:17:11.150
function will decode
all the fields.

00:17:15.490 --> 00:17:18.966
You will have to manually
write to--

00:17:18.966 --> 00:17:22.089
I mean, either you do the
parsing yourself using some

00:17:22.089 --> 00:17:26.480
kind of reader and then you can
selectively get what you

00:17:26.480 --> 00:17:29.220
want, but then your parsing
for this doubles.

00:17:29.220 --> 00:17:33.500
Or if you use a generic decode
function, you would just get

00:17:33.500 --> 00:17:35.708
an enormous [INAUDIBLE] if you
have an enormous string.

00:17:40.670 --> 00:17:42.960
AMY: As Andrew said, I suspect
you're getting to the really

00:17:42.960 --> 00:17:45.630
cool stuff in just
a minute here.

00:17:45.630 --> 00:17:50.250
JOHAN EUPHROSINE: Actually,
just the same with JSON,

00:17:50.250 --> 00:17:56.546
though we do exactly the same
with Programming Reddits.

00:17:56.546 --> 00:18:03.580
And so Reddits APIs
have a JSON file.

00:18:03.580 --> 00:18:07.530
And actually, it's both an
access file and some JSON

00:18:07.530 --> 00:18:10.900
file, but the RSS file structure
is quite messed up.

00:18:10.900 --> 00:18:15.050
So you can't access the link of
the element, because it's

00:18:15.050 --> 00:18:19.040
encoded to see that inside
the description.

00:18:19.040 --> 00:18:23.660
So for being able to easily
pass title and links

00:18:23.660 --> 00:18:26.750
programmatically of Programming
Reddits, you need

00:18:26.750 --> 00:18:29.910
to use the JSON API.

00:18:29.910 --> 00:18:33.685
For that, we'll just import
encoding JSON, just like we

00:18:33.685 --> 00:18:36.520
imported encoding XML before.

00:18:36.520 --> 00:18:39.870
We'll define a new Handle, which
is called "proggit."

00:18:39.870 --> 00:18:43.470
There is a URL slash proggit.

00:18:43.470 --> 00:18:46.510
And we'll map JSON to Go
type, just like we've

00:18:46.510 --> 00:18:48.220
done before with XML.

00:18:48.220 --> 00:18:54.000
So the structure of the JSON
feed is a bit complicated for

00:18:54.000 --> 00:18:54.660
what it is.

00:18:54.660 --> 00:18:55.885
But it's like this.

00:18:55.885 --> 00:19:03.620
So you've got the data element,
which has a children

00:19:03.620 --> 00:19:06.410
attribute, with a collection
of children element.

00:19:06.410 --> 00:19:09.380
Each of these trigger an element
also of the data

00:19:09.380 --> 00:19:14.360
attributes, which finally
adds a title and a URL.

00:19:14.360 --> 00:19:19.180
And so we'll just define
Go type just as before.

00:19:19.180 --> 00:19:22.870
So the range field is
a data element.

00:19:22.870 --> 00:19:25.880
And so you see here that we
don't have any annotation

00:19:25.880 --> 00:19:29.170
because what I find in Go is
that if you don't define an

00:19:29.170 --> 00:19:33.990
annotation, the decode function
will default on

00:19:33.990 --> 00:19:39.490
passing the attributes
that correspond to

00:19:39.490 --> 00:19:40.890
your property name.

00:19:40.890 --> 00:19:44.400
So clearly we know that it needs
to get better attributes

00:19:44.400 --> 00:19:47.670
because we've defined a property
in your structure

00:19:47.670 --> 00:19:50.920
which is named data.

00:19:50.920 --> 00:19:54.670
So a Reddit feed data is
a collection of items.

00:19:54.670 --> 00:20:02.620
And so we have a Reddits feed
item type, which will match to

00:20:02.620 --> 00:20:05.560
the JSON children attributes.

00:20:05.560 --> 00:20:08.720
And so here, you can see that
we have put an annotation,

00:20:08.720 --> 00:20:12.120
because the name of our property
is different from the

00:20:12.120 --> 00:20:14.890
name of the attribute.

00:20:14.890 --> 00:20:19.930
And then each Reddit feed thing
will be a data item here

00:20:19.930 --> 00:20:24.550
just to capture what is
in the attribute data.

00:20:24.550 --> 00:20:27.850
And the item structure will
just be the same structure

00:20:27.850 --> 00:20:31.380
that we have been using before
for the [INAUDIBLE].

00:20:31.380 --> 00:20:39.460
So here we see that we are two
hierarchy types that shows the

00:20:39.460 --> 00:20:43.390
same leaf type elements
which is item.

00:20:43.390 --> 00:20:47.150
So we'll be about to decode
Hacker News and Programming

00:20:47.150 --> 00:20:52.350
Reddits using two different
functions, and we will get the

00:20:52.350 --> 00:20:56.920
same item types back from
the Go function.

00:20:56.920 --> 00:20:59.630
So here, that is how we
get [INAUDIBLE] on

00:20:59.630 --> 00:21:00.970
JSON streaming Go.

00:21:00.970 --> 00:21:04.820
So it's quite similar to what
we've seen before with XML.

00:21:04.820 --> 00:21:09.590
The only difference is that we
instantiate a new JSON decoder

00:21:09.590 --> 00:21:12.760
instead of instantiating
an XML decoder.

00:21:12.760 --> 00:21:17.105
We use a Reddit feed type
instead of using the Hacker

00:21:17.105 --> 00:21:19.200
News feed type.

00:21:19.200 --> 00:21:20.450
We can decode.

00:21:22.940 --> 00:21:24.690
In order to return
a collection of

00:21:24.690 --> 00:21:26.720
item, we have to--

00:21:26.720 --> 00:21:27.470
it writes--

00:21:27.470 --> 00:21:31.320
because what we get back from
the decode function is a

00:21:31.320 --> 00:21:34.520
Reddit field, which is a Reddit
feed data, which is a

00:21:34.520 --> 00:21:36.490
collection of Reddit
feed item.

00:21:36.490 --> 00:21:39.550
And what our function returns
is a collection of item.

00:21:39.550 --> 00:21:42.160
So we need to instantiate
a collection of item.

00:21:42.160 --> 00:21:47.770
So you do that in Go by using
the Make key word, which

00:21:47.770 --> 00:21:51.400
allows you to instantiate
a slice of item.

00:21:51.400 --> 00:21:54.680
And you can specify a LAN,
events, and the capacity.

00:21:54.680 --> 00:21:58.670
You know we know the LANs in
advance, so we can say that we

00:21:58.670 --> 00:22:03.240
want to instantiate as many
items that we have--

00:22:03.240 --> 00:22:10.940
Reddit feed item, you know,
in the Reddit feed data.

00:22:10.940 --> 00:22:15.765
And so we just integrate an
old item and fill the new

00:22:15.765 --> 00:22:17.375
slide that we have
just created.

00:22:17.375 --> 00:22:20.480
And so in the end, we
get a slice of item

00:22:20.480 --> 00:22:21.730
back from this function.

00:22:25.150 --> 00:22:27.270
What's left is just that
we need to print it.

00:22:27.270 --> 00:22:31.840
So as before, we just set the
Content-Type and iterate from

00:22:31.840 --> 00:22:35.200
what we get back from the
proggit item function and

00:22:35.200 --> 00:22:37.120
point it to the response.

00:22:40.870 --> 00:22:48.990
So here you can see that we
just printed the top items

00:22:48.990 --> 00:22:51.232
that are in Programming
Reddits--

00:22:51.232 --> 00:22:55.280
the title and the URL
on the right.

00:22:55.280 --> 00:22:57.440
AMY: And Proppy?

00:22:57.440 --> 00:22:58.930
JOHAN EUPHROSINE: Yeah?

00:22:58.930 --> 00:23:02.490
AMY: Since people might not be
able to see that output very

00:23:02.490 --> 00:23:05.340
well and just might be
interested in general, I think

00:23:05.340 --> 00:23:11.330
that you have the code
also on code.google

00:23:11.330 --> 00:23:12.545
somewhere, don't you?

00:23:12.545 --> 00:23:17.490
JOHAN EUPHROSINE: Yeah, at the
end of the presentation, there

00:23:17.490 --> 00:23:20.160
will be a link to the code.

00:23:20.160 --> 00:23:21.410
AMY: OK, great.

00:23:25.240 --> 00:23:28.850
JOHAN EUPHROSINE: So now we need
to print both, because we

00:23:28.850 --> 00:23:31.800
are printing Hacker News items,

00:23:31.800 --> 00:23:32.770
Programming Reddit item.

00:23:32.770 --> 00:23:36.020
And now we want to print
both on the response.

00:23:36.020 --> 00:23:42.675
And so since we can just call
our hackernews item function,

00:23:42.675 --> 00:23:46.710
call our Programming Reddits
item function, get the item

00:23:46.710 --> 00:23:49.510
back, And just iterate
on each of them and

00:23:49.510 --> 00:23:51.512
print them in the response.

00:23:51.512 --> 00:23:54.630
And so we'll first print the
Hacker News item, and then

00:23:54.630 --> 00:23:58.395
print the Programming
Reddit item.

00:23:58.395 --> 00:24:03.940
And here we can see that we
actually printed both.

00:24:07.970 --> 00:24:13.710
And you can see, I added some
[INAUDIBLE] statement in the

00:24:13.710 --> 00:24:15.610
code before in order to
check the latency.

00:24:15.610 --> 00:24:23.890
So we see that it took like 260
milliseconds to fetch the

00:24:23.890 --> 00:24:26.260
item from Hacker News.

00:24:26.260 --> 00:24:28.255
It took like 100 milliseconds
to fetch

00:24:28.255 --> 00:24:31.270
the item from proggit.

00:24:31.270 --> 00:24:36.726
To print both of them--, like
the latency of the [INAUDIBLE]

00:24:36.726 --> 00:24:40.790
function, which was Progginator,
it's just the

00:24:40.790 --> 00:24:43.660
same as the latency of Hacker
News and proggit.

00:24:43.660 --> 00:24:49.410
So it means that if I can use a
slow, like we won't be able

00:24:49.410 --> 00:24:52.260
to print anything before
I can use it as Handle.

00:24:52.260 --> 00:24:59.220
And also, we'll just send it to
latency of both URL fetch.

00:25:02.110 --> 00:25:05.440
And so what we need to do now
to be more efficient is to

00:25:05.440 --> 00:25:07.070
make it concurrent.

00:25:07.070 --> 00:25:12.000
So it's just like the same code
that we've seen before,

00:25:12.000 --> 00:25:14.340
we just added a few keywords.

00:25:14.340 --> 00:25:18.980
So we are using the Go
[INAUDIBLE], which is from the

00:25:18.980 --> 00:25:20.320
goroutine, which is
the [INAUDIBLE].

00:25:22.900 --> 00:25:29.766
It will allow us to fetch
a Hacker News item and a

00:25:29.766 --> 00:25:31.535
Programming Reddit item
concurrently.

00:25:35.020 --> 00:25:37.490
So here we just--

00:25:37.490 --> 00:25:42.600
in order to get the item back
from this goroutine, we'll

00:25:42.600 --> 00:25:43.840
create a channel.

00:25:43.840 --> 00:25:45.120
So we create a channel.

00:25:45.120 --> 00:25:49.810
A channel is a structure that
will allows goroutines to

00:25:49.810 --> 00:25:51.300
communicate safely
between them.

00:25:51.300 --> 00:25:56.357
So you first just figure out Go
tied to a channel, and you

00:25:56.357 --> 00:25:59.890
can send the item to a channel
and read item back.

00:25:59.890 --> 00:26:03.690
And what we will do, being that
we spoke to goroutine,

00:26:03.690 --> 00:26:10.940
that we'll each send a slice
of item to the channel.

00:26:10.940 --> 00:26:13.890
In the parent goroutine that
has been spawned to

00:26:13.890 --> 00:26:16.300
[INAUDIBLE] request,
we just [INAUDIBLE]

00:26:16.300 --> 00:26:18.320
back from the channel.

00:26:18.320 --> 00:26:21.695
So it means that both
UR shell [INAUDIBLE]

00:26:21.695 --> 00:26:23.370
fetch concurrently
has happened.

00:26:26.180 --> 00:26:31.650
So here we just create a new
chain on which [INAUDIBLE].

00:26:35.640 --> 00:26:41.070
Here we spawn the goroutine and
send the wizard, which is

00:26:41.070 --> 00:26:43.590
a slice of item back
to the channel.

00:26:43.590 --> 00:26:45.906
Here we spawn another goroutine
for Programming

00:26:45.906 --> 00:26:49.780
Reddits and send the wizard
back to the channel

00:26:49.780 --> 00:26:52.465
Here we iterate.

00:26:52.465 --> 00:26:55.930
We do an iteration of two,
because we have two

00:26:55.930 --> 00:26:57.750
[INAUDIBLE] to read
from the channel.

00:26:57.750 --> 00:26:58.610
Read them.

00:26:58.610 --> 00:27:02.225
So this is a syntax
for receiving

00:27:02.225 --> 00:27:04.040
stuff from the channel.

00:27:04.040 --> 00:27:07.690
And then we iterate up each on
the slice we get back from the

00:27:07.690 --> 00:27:09.220
channel and print them
to the screen.

00:27:14.200 --> 00:27:16.170
And here you can see exactly
the same [INAUDIBLE]

00:27:16.170 --> 00:27:17.420
as before.

00:27:19.360 --> 00:27:23.025
And notice it's just
quicker, because

00:27:23.025 --> 00:27:23.970
here are the latencies.

00:27:23.970 --> 00:27:26.670
So Programming Reddit takes
like [INAUDIBLE]

00:27:26.670 --> 00:27:27.810
seconds.

00:27:27.810 --> 00:27:31.900
Hackernews takes 190 seconds.

00:27:31.900 --> 00:27:36.590
The progginator function
only takes the highest

00:27:36.590 --> 00:27:37.580
latencies of the two.

00:27:37.580 --> 00:27:41.370
So it means that both of
our fetch calls happen

00:27:41.370 --> 00:27:43.950
concurrently.

00:27:43.950 --> 00:27:46.040
Since they happen concurrently,
we are only

00:27:46.040 --> 00:27:50.870
bound to the slowest one instead
of being bound to the

00:27:50.870 --> 00:27:54.920
center of the two latencies.

00:27:54.920 --> 00:27:57.500
So are some takeaways
from the talk.

00:28:00.700 --> 00:28:02.970
The encoding package makes
parsing fun again.

00:28:02.970 --> 00:28:07.740
So we see that it's really easy
to bind a Go native type

00:28:07.740 --> 00:28:12.960
to either XML ends or Java
attributes, which make parsing

00:28:12.960 --> 00:28:17.320
really easy and serve a call.

00:28:17.320 --> 00:28:20.250
We have seen the Go runtime
is inherently concurrent.

00:28:20.250 --> 00:28:25.760
So you can easily spawn a
goroutine and make sure to

00:28:25.760 --> 00:28:28.390
handle any operation
concurrently.

00:28:28.390 --> 00:28:34.180
And also, the Go runtime will
run a Go routine each incoming

00:28:34.180 --> 00:28:36.310
HTTP request.

00:28:36.310 --> 00:28:38.770
And we've seen also that
there is no need--

00:28:38.770 --> 00:28:43.360
in Python and in Java, in order
to do the [INAUDIBLE],

00:28:43.360 --> 00:28:45.040
we'd have to use an async API.

00:28:47.610 --> 00:28:50.610
Here we see that in Go, we don't
need to add an async and

00:28:50.610 --> 00:28:51.830
sync version of an API.

00:28:51.830 --> 00:28:59.880
We just wrap the code we want to
be in sync with [INAUDIBLE]

00:28:59.880 --> 00:29:02.605
and just use a channel to get
the [INAUDIBLE] back and

00:29:02.605 --> 00:29:05.578
return a synchronous API code
into something asynchronous.

00:29:08.330 --> 00:29:10.940
And so there is some homework
that you can do in order to

00:29:10.940 --> 00:29:15.420
improve this demo.

00:29:15.420 --> 00:29:19.710
Obviously, the same stuff
gets often [INAUDIBLE]

00:29:19.710 --> 00:29:20.700
since you've got
both hackernews

00:29:20.700 --> 00:29:21.920
and Programming Reddits.

00:29:21.920 --> 00:29:23.705
So you can write some
code to get

00:29:23.705 --> 00:29:26.300
duplicates and also by ranking.

00:29:26.300 --> 00:29:28.510
You can make it pretty, because
it's just plain text

00:29:28.510 --> 00:29:31.898
right now, so you can make
it prettier with

00:29:31.898 --> 00:29:34.280
templates and CSS.

00:29:34.280 --> 00:29:37.570
You can move the fetch to happen
offline instead of

00:29:37.570 --> 00:29:39.250
happening on each
user request.

00:29:39.250 --> 00:29:45.140
So instead of doing a URL fetch
on each HTTP request,

00:29:45.140 --> 00:29:47.190
you can [INAUDIBLE]

00:29:47.190 --> 00:29:51.480
that will do the URL fetch as
a bad one and then cache it.

00:29:51.480 --> 00:29:54.455
So when you have like thousands
of people that use

00:29:54.455 --> 00:29:58.280
the site, you don't do a URL
fetch to fetch some content to

00:29:58.280 --> 00:30:01.740
Reddit and [INAUDIBLE]

00:30:01.740 --> 00:30:03.080
each time.

00:30:03.080 --> 00:30:06.215
And you can go fork the messy
code at this URL.

00:30:06.215 --> 00:30:06.690
So

00:30:06.690 --> 00:30:09.421
code.google.com/p/progginator project.

00:30:09.421 --> 00:30:13.250
And the slides are also
available in this [INAUDIBLE]

00:30:13.250 --> 00:30:14.510
too.

00:30:14.510 --> 00:30:15.530
So thank you.

00:30:15.530 --> 00:30:19.625
There are some links that you
can investigate if you want to

00:30:19.625 --> 00:30:21.274
work further.

00:30:21.274 --> 00:30:23.760
This is a doc for the Go
App Engine runtime.

00:30:23.760 --> 00:30:28.520
This is the main website
for the Go [INAUDIBLE].

00:30:28.520 --> 00:30:32.150
And there is my profile
on Google+.

00:30:32.150 --> 00:30:36.650
So if you have questions,
we can do them now.

00:30:36.650 --> 00:30:39.350
AUDIENCE: Proppy,
can you hear me?

00:30:39.350 --> 00:30:40.600
JOHAN EUPHROSINE: Yeah.

00:30:43.200 --> 00:30:45.690
AUDIENCE: Just a
quick question.

00:30:45.690 --> 00:30:46.940
You were using [INAUDIBLE]

00:30:50.720 --> 00:30:53.760
channel [INAUDIBLE]

00:30:53.760 --> 00:30:57.930
when you're collecting
the item [INAUDIBLE]

00:30:57.930 --> 00:31:00.065
concurrently.

00:31:00.065 --> 00:31:02.873
You would be passing directly
the channel [INAUDIBLE].

00:31:06.250 --> 00:31:09.290
passing them to your template.

00:31:09.290 --> 00:31:10.950
JOHAN EUPHROSINE: I'm sorry--

00:31:10.950 --> 00:31:11.430
AUDIENCE: Yeah.

00:31:11.430 --> 00:31:12.680
JOHAN EUPHROSINE: [INAUDIBLE].

00:31:16.230 --> 00:31:17.670
I couldn't really hear
the question.

00:31:17.670 --> 00:31:21.030
Can you try it a little
bit more slowly?

00:31:21.030 --> 00:31:22.280
[INAUDIBLE].

00:31:24.594 --> 00:31:28.716
AUDIENCE: I'm in the chat.

00:31:28.716 --> 00:31:30.376
JOHAN EUPHROSINE: Yeah, just
type through the chat.

00:31:30.376 --> 00:31:31.720
It would be simpler.

00:31:31.720 --> 00:31:35.592
AMY: Yeah, I can read
it out if you like.

00:31:35.592 --> 00:32:27.990
[TYPING]

00:32:27.990 --> 00:32:30.970
JOHAN EUPHROSINE: So the
question is, if you were using

00:32:30.970 --> 00:32:33.360
templates, would you patch them
directly to the templates

00:32:33.360 --> 00:32:37.470
or collect an item and pass
in those to the templates?

00:32:37.470 --> 00:32:42.020
So I think I would
do the latter.

00:32:42.020 --> 00:32:45.750
So what I would do
is that I would--

00:32:45.750 --> 00:32:48.245
because what I get back from
the channel is not actually

00:32:48.245 --> 00:32:49.680
the usual item.

00:32:49.680 --> 00:32:52.440
I get a slice of item
from the channel.

00:32:52.440 --> 00:32:55.500
So what I would do is with the
main Go routine, I would

00:32:55.500 --> 00:32:58.480
collect the item from the
channel, the slice of item

00:32:58.480 --> 00:33:01.120
from the channel, and just print
them out by template by

00:33:01.120 --> 00:33:03.480
giving it the slice of
item [INAUDIBLE].

00:33:03.480 --> 00:33:05.300
That's really [INAUDIBLE]

00:33:05.300 --> 00:33:07.940
different perspective of this.

00:33:07.940 --> 00:33:09.690
ANDREW: With the way it's
currently designed, then,

00:33:09.690 --> 00:33:12.060
yeah, you probably
would do that.

00:33:12.060 --> 00:33:15.660
But it is possible from within
a template to range over a

00:33:15.660 --> 00:33:18.510
channel in the same way that you
can range over a channel

00:33:18.510 --> 00:33:20.510
in novel Go code.

00:33:20.510 --> 00:33:24.450
And that's particularly useful
if you have some code that's

00:33:24.450 --> 00:33:27.730
generating values, like a large
stream of them, and then

00:33:27.730 --> 00:33:30.910
you want to generate a
particularly large template.

00:33:30.910 --> 00:33:35.120
You can have your generator
and your template being--

00:33:35.120 --> 00:33:37.285
you have the values being
generated and the template

00:33:37.285 --> 00:33:40.430
being constructed concurrently
without having to load your

00:33:40.430 --> 00:33:44.440
entire data into memory, which
is a really nice property.

00:33:44.440 --> 00:33:47.740
But in this particular instance,
you're already

00:33:47.740 --> 00:33:55.040
loading all of the items into
memory immediately when you do

00:33:55.040 --> 00:33:56.565
the JSON and XML decodes.

00:33:56.565 --> 00:34:00.780
So there's no real advantage
to streaming them into the

00:34:00.780 --> 00:34:02.190
into the template itself.

00:34:02.190 --> 00:34:06.030
You might as well just collect
them, and arrange them before

00:34:06.030 --> 00:34:07.190
passing them into
the template.

00:34:07.190 --> 00:34:09.960
And that's what I would
do usually as well.

00:34:09.960 --> 00:34:13.290
JOHAN EUPHROSINE: Also when we
pass an item, a slice in the

00:34:13.290 --> 00:34:16.285
channel it's not-- it doesn't
copy them [INAUDIBLE].

00:34:16.285 --> 00:34:22.218
It's just a reference to the
same slice of this, right?

00:34:22.218 --> 00:34:23.030
ANDREW: Yep.

00:34:23.030 --> 00:34:26.750
JOHAN EUPHROSINE: So we aren't
duplicating the slice content

00:34:26.750 --> 00:34:28.440
in multiple goroutines.

00:34:35.644 --> 00:34:39.595
ANDREW: I was going to say, in
this case, are they items, are

00:34:39.595 --> 00:34:42.110
they values, or are they
pointers to items?

00:34:42.110 --> 00:34:45.870
It looks like they're
items themselves.

00:34:45.870 --> 00:34:47.530
JOHAN EUPHROSINE: Yeah, they're
items themselves, but

00:34:47.530 --> 00:34:54.969
when you pass it to a channel my
understanding is that when

00:34:54.969 --> 00:35:01.520
you enter a slice of item to a
channel, you don't copy the

00:35:01.520 --> 00:35:04.000
individual elements, right?

00:35:04.000 --> 00:35:05.300
ANDREW: Yes, that's correct.

00:35:05.300 --> 00:35:08.150
I mean, when you pass a slice
around, you're passing a

00:35:08.150 --> 00:35:10.355
reference to the underlying
data.

00:35:10.355 --> 00:35:17.550
But if you wanted to sort or
de-duplicate those items and

00:35:17.550 --> 00:35:20.340
interleaf the ones from proggit
and the ones from

00:35:20.340 --> 00:35:22.080
Hacker News together, then
you might consider

00:35:22.080 --> 00:35:24.100
using a pointer type.

00:35:24.100 --> 00:35:27.390
So a slice of pointers to items
instead of a slice of

00:35:27.390 --> 00:35:30.560
items, and you'd have some
small saving there.

00:35:30.560 --> 00:35:33.300
But the actual item struct
is very small, because it

00:35:33.300 --> 00:35:35.250
consists of some
string values.

00:35:35.250 --> 00:35:38.640
And string values in Go are
reference types as well.

00:35:38.640 --> 00:35:41.710
And so there's very little
copying going on there.

00:35:41.710 --> 00:35:43.830
I mean, each item
is probably only

00:35:43.830 --> 00:35:51.100
about 64 bytes or something.

00:35:51.100 --> 00:35:55.920
JOHAN EUPHROSINE: So very
quickly, take a look if

00:35:55.920 --> 00:36:01.294
there's any questions on Google+
or on the [INAUDIBLE].

00:36:01.294 --> 00:36:03.826
AMY: OK, I have a question for
you, Proppy, if there are no

00:36:03.826 --> 00:36:04.310
other questions.

00:36:04.310 --> 00:36:06.040
I have to take a quick
look first.

00:36:06.040 --> 00:36:08.590
ANDREW: Well, there is one
question on the moderator,

00:36:08.590 --> 00:36:10.580
which is an App Engine
question.

00:36:10.580 --> 00:36:14.480
And it's from Jurka Danyik
from the Czech Republic

00:36:14.480 --> 00:36:18.120
saying, I don't want my app to
depend on App Engine too much.

00:36:18.120 --> 00:36:20.470
I'm afraid of the vendor
locking issue.

00:36:20.470 --> 00:36:24.410
How hard is it to build an app
in Go that runs on App Engine,

00:36:24.410 --> 00:36:28.120
and if needed, can be moved
to my private web server?

00:36:28.120 --> 00:36:30.910
JOHAN EUPHROSINE: I think that
actually David can comment

00:36:30.910 --> 00:36:33.730
about this, because he recently
implemented something

00:36:33.730 --> 00:36:35.730
in the Go build that
dealt with it.

00:36:40.540 --> 00:36:45.260
DAVE: It'd be pretty easy to
write a Go App Engine app that

00:36:45.260 --> 00:36:50.400
has minimal dependencies
on App Engine itself.

00:36:50.400 --> 00:36:54.520
For example, the Go website
itself, golang.org, is built

00:36:54.520 --> 00:36:56.640
by an App Engine app.

00:36:56.640 --> 00:37:02.300
But that App Engine app is
almost completely just Go doc,

00:37:02.300 --> 00:37:06.706
which is a standard Go program
that you can build and compile

00:37:06.706 --> 00:37:09.730
and run on your own machine and
ships with the standard Go

00:37:09.730 --> 00:37:10.900
distribution.

00:37:10.900 --> 00:37:15.710
All that has is a very small,
little [INAUDIBLE]

00:37:15.710 --> 00:37:20.902
file that [INAUDIBLE].

00:37:20.902 --> 00:37:24.170
And other than that, it's just
a regular, like I said,

00:37:24.170 --> 00:37:25.070
[INAUDIBLE] design.

00:37:25.070 --> 00:37:28.890
The Go runtime on App Engine
is pretty permissive for

00:37:28.890 --> 00:37:31.060
allowing you to write something
that's independent

00:37:31.060 --> 00:37:34.580
of App Engine.

00:37:34.580 --> 00:37:37.170
ANDREW: So to learn to write
an app like this, this is

00:37:37.170 --> 00:37:43.010
actually very portable, because
the HTTP package is

00:37:43.010 --> 00:37:46.160
well integrated with
Go on App Engine.

00:37:46.160 --> 00:37:49.090
So like what Dave just said, if
you write just a straight

00:37:49.090 --> 00:37:56.190
web app that doesn't really talk
to much of [INAUDIBLE],

00:37:56.190 --> 00:37:59.435
you can basically just use one
in one place or the other.

00:37:59.435 --> 00:38:05.310
The one that we're using
here is URL fetch.

00:38:05.310 --> 00:38:09.030
And if you look at the--
is it on this slide?

00:38:09.030 --> 00:38:14.370
Proppy, can you go to a slide
which has the [INAUDIBLE]

00:38:14.370 --> 00:38:16.155
urlfetch client on it.

00:38:16.155 --> 00:38:19.070
I think that had it.

00:38:19.070 --> 00:38:21.630
So if you notice on the first
line of this function after

00:38:21.630 --> 00:38:27.140
the declaration, the URL fetch
client, that variable client

00:38:27.140 --> 00:38:30.240
is actually just an HTTP client,
the same type of HTTP

00:38:30.240 --> 00:38:34.080
client you would use in a
standalone Go program as well.

00:38:34.080 --> 00:38:37.300
So the URL fetch client just
implements the same

00:38:37.300 --> 00:38:38.320
interfaces.

00:38:38.320 --> 00:38:41.520
And you can use anything that
expects those interfaces,

00:38:41.520 --> 00:38:44.420
which is basically any Go
package that uses HTTP.

00:38:44.420 --> 00:38:49.960
So we tried really hard in
creating all of the Go App

00:38:49.960 --> 00:38:53.210
Engine APIs to use a lot of the
standard Go interfaces so

00:38:53.210 --> 00:38:55.760
that it's really easy to--

00:38:55.760 --> 00:38:59.920
I use the Go standard library
and external libraries with

00:38:59.920 --> 00:39:03.580
the App Engine APIs and also to
decouple your app entirely

00:39:03.580 --> 00:39:05.440
from App Engine.

00:39:05.440 --> 00:39:08.970
With that said, if you write an
App Engine app that depends

00:39:08.970 --> 00:39:12.207
heavily on the task
infrastructure and the App

00:39:12.207 --> 00:39:15.820
Engine data store, those are
really, really rich APIs.

00:39:15.820 --> 00:39:18.340
And that's one of the real value
adds of the App Engine

00:39:18.340 --> 00:39:20.970
platform, is that you get these
really, really scalable,

00:39:20.970 --> 00:39:22.740
reliable systems.

00:39:22.740 --> 00:39:24.980
That you don't get free.

00:39:24.980 --> 00:39:28.110
And it would be a little bit
more difficult to divorce

00:39:28.110 --> 00:39:29.070
yourself from that.

00:39:29.070 --> 00:39:30.373
JOHAN EUPHROSINE: It's
interesting to note that there

00:39:30.373 --> 00:39:34.150
is a project called App Appscale
that implements the

00:39:34.150 --> 00:39:35.950
Go runtime.

00:39:35.950 --> 00:39:41.305
It allows you to run basically
APIs tablet that [INAUDIBLE]

00:39:43.980 --> 00:39:49.050
database or [INAUDIBLE] software
that will just

00:39:49.050 --> 00:39:52.920
provide you the same SPI that
you have on App Engine, just

00:39:52.920 --> 00:39:57.210
with different back-end
issues, like MongoDB,

00:39:57.210 --> 00:39:58.460
[INAUDIBLE].

00:40:00.938 --> 00:40:04.490
And also I wanted to--

00:40:04.490 --> 00:40:10.595
maybe David can you tell us a
bit about the build tag, the

00:40:10.595 --> 00:40:12.320
App Engine build tag.

00:40:12.320 --> 00:40:17.800
Because I think that you can
easily design your apps so you

00:40:17.800 --> 00:40:22.140
have the App Engine specific
parts that are as efficient as

00:40:22.140 --> 00:40:23.790
with App Engine buildout.

00:40:23.790 --> 00:40:27.000
And so you can still use the
regular Go build to build your

00:40:27.000 --> 00:40:32.290
stuff without the App Engine
specifics, right?

00:40:36.990 --> 00:40:40.046
DAVE: I'm not entirely sure
what you're asking me.

00:40:40.046 --> 00:40:42.520
[INAUDIBLE]

00:40:42.520 --> 00:40:45.840
that you fill in with an
implementation that you're

00:40:45.840 --> 00:40:48.320
using the App Engine
APIs and--

00:40:48.320 --> 00:40:51.340
JOHAN EUPHROSINE: No, I was
thinking like, for example,

00:40:51.340 --> 00:40:57.300
Andrew was saying that your URL
fetch module uses the same

00:40:57.300 --> 00:41:01.826
JFS as the regular
HTTP client.

00:41:01.826 --> 00:41:03.076
DAVE: Yeah, [INAUDIBLE].

00:41:06.360 --> 00:41:09.980
JOHAN EUPHROSINE: If you write
your App Engine specific code

00:41:09.980 --> 00:41:13.185
and just [INAUDIBLE]

00:41:13.185 --> 00:41:16.695
it with the App Engine name tag,
can you make sure that

00:41:16.695 --> 00:41:21.190
the Go To when it builds your
application doesn't build the

00:41:21.190 --> 00:41:23.350
pieces specific to App Engine?

00:41:23.350 --> 00:41:23.800
DAVE: Yeah.

00:41:23.800 --> 00:41:31.390
So just in the same way as you
could say some platform

00:41:31.390 --> 00:41:34.636
depended on [INAUDIBLE] or that
you had some who would

00:41:34.636 --> 00:41:39.883
only work on Linux or some who
will only work on Mac or some

00:41:39.883 --> 00:41:42.160
who would only work on Windows,
you can add a little

00:41:42.160 --> 00:41:45.450
annotation at the top of your
source files, and then Go To

00:41:45.450 --> 00:41:50.410
will only build those when
it's on that platform.

00:41:50.410 --> 00:41:51.700
The same thing with
App Engine.

00:41:51.700 --> 00:41:59.100
So if you have a build tag at
the top of your file that says

00:41:59.100 --> 00:42:04.240
this file requires App Engine
or App Engine apps

00:42:04.240 --> 00:42:05.490
[INAUDIBLE].

00:42:09.130 --> 00:42:11.580
JOHAN EUPHROSINE: OK, so yeah, I
think that's neat that there

00:42:11.580 --> 00:42:17.290
is a super build team into the
Go To number to get one

00:42:17.290 --> 00:42:21.330
application that can get
more than one platform.

00:42:21.330 --> 00:42:22.580
DAVE: Yeah.

00:42:24.690 --> 00:42:26.950
AMY: So let me ask you
a question, Proppy.

00:42:26.950 --> 00:42:30.870
And this is also directed to
Andrew and Dave, if you want

00:42:30.870 --> 00:42:31.480
to answer it.

00:42:31.480 --> 00:42:35.980
So the Go routines and channels
are really cool.

00:42:35.980 --> 00:42:41.870
And it's sort of a philosophical
departure from

00:42:41.870 --> 00:42:44.920
what people might be used to
or might think of as your

00:42:44.920 --> 00:42:48.110
regular thread program if you're
a Java programmer.

00:42:48.110 --> 00:42:53.820
And it seems like it lends
itself less to getting into

00:42:53.820 --> 00:42:56.960
trouble with that kind
of programming.

00:42:56.960 --> 00:42:59.945
Maybe you want to comment
a little more on that?

00:42:59.945 --> 00:43:04.730
ANDREW: Well, I mean, if you
consider Proppy's example of

00:43:04.730 --> 00:43:07.990
performing these two calls in
parallel and then having a

00:43:07.990 --> 00:43:12.250
rendezvous and collecting the
results, using a traditional

00:43:12.250 --> 00:43:16.080
kind of semaphore approach, you
would probably use a white

00:43:16.080 --> 00:43:19.680
group or something like that.

00:43:19.680 --> 00:43:21.920
Generally, there's just a lot
more boilerplate involved in

00:43:21.920 --> 00:43:24.050
setting up the channels and
setting up the locks.

00:43:24.050 --> 00:43:26.470
And then there can
be a lot more--

00:43:26.470 --> 00:43:28.250
basically what you're
doing is you're

00:43:28.250 --> 00:43:29.730
talking around the problem.

00:43:29.730 --> 00:43:31.955
You're creating these
kind of [INAUDIBLE].

00:43:46.910 --> 00:43:50.820
JOHAN EUPHROSINE: So it seems
they are just frozen for me.

00:43:50.820 --> 00:43:52.221
Is it the same for--

00:43:54.930 --> 00:43:58.291
OK, so you were frozen.

00:43:58.291 --> 00:44:02.050
AMY: Yeah, we're back, but I
think we need to start over

00:44:02.050 --> 00:44:06.410
with what Andrew was saying.

00:44:06.410 --> 00:44:11.080
ANDREW: In essence what I'm
saying is that in Go, to make

00:44:11.080 --> 00:44:14.060
something run another thread
is [INAUDIBLE]

00:44:14.060 --> 00:44:15.870
in the space.

00:44:15.870 --> 00:44:17.600
In pretty much any other
traditional threading

00:44:17.600 --> 00:44:19.700
environment, there's a
lot more involved in

00:44:19.700 --> 00:44:20.900
setting up a thread.

00:44:20.900 --> 00:44:27.010
And similarly, to communicate
between threads in the

00:44:27.010 --> 00:44:30.390
traditional method, you
have some sort of

00:44:30.390 --> 00:44:32.530
semaphore, like a lock.

00:44:32.530 --> 00:44:34.940
And then you have the data that
you want to communicate,

00:44:34.940 --> 00:44:37.140
and they're two separate
things.

00:44:37.140 --> 00:44:39.410
In Go they're combined
into the same thing.

00:44:39.410 --> 00:44:42.850
You have a channel, and the
channel is both a signal--

00:44:42.850 --> 00:44:44.390
it's synchronization--

00:44:44.390 --> 00:44:47.490
and it is the message itself.

00:44:47.490 --> 00:44:48.380
It's the data.

00:44:48.380 --> 00:44:52.520
And so it's a lot less error
prone, particularly once the

00:44:52.520 --> 00:44:55.160
system becomes more complex.

00:44:55.160 --> 00:44:59.320
And so I think it's a pretty
clear win, if you're doing any

00:44:59.320 --> 00:45:02.530
kind of [INAUDIBLE] software.

00:45:02.530 --> 00:45:05.730
JOHAN EUPHROSINE: One of the
mantras of the Go [INAUDIBLE]

00:45:05.730 --> 00:45:09.660
is don't communicate by
sharing, but share by

00:45:09.660 --> 00:45:12.350
communicating.

00:45:12.350 --> 00:45:15.120
I think that it's fitting.

00:45:15.120 --> 00:45:17.110
It's also really useful.

00:45:17.110 --> 00:45:21.270
I mean, the way the App Engine--
maybe David can

00:45:21.270 --> 00:45:24.070
correct me, but the way that App
Engine runtime is designed

00:45:24.070 --> 00:45:26.910
is that it will spawn one Go
routine for each information

00:45:26.910 --> 00:45:28.160
you request.

00:45:31.310 --> 00:45:34.210
It will not run more than one
Go Looking at a time.

00:45:34.210 --> 00:45:38.720
But if one Go looking is doing
IO, it can add an addition to

00:45:38.720 --> 00:45:39.730
another Go To.

00:45:39.730 --> 00:45:42.870
And since most of what App
Engine apps are doing is to

00:45:42.870 --> 00:45:50.100
make APC code and API code,
that's really a strong win for

00:45:50.100 --> 00:45:51.350
App Engine.

00:45:53.450 --> 00:45:57.040
Even if it's single threaded,
it's on [INAUDIBLE]

00:45:57.040 --> 00:45:58.290
operation concurrently.

00:46:01.530 --> 00:46:04.950
ANDREW: And Go is easily the
most lightweight of the three

00:46:04.950 --> 00:46:06.690
App Engine runtimes as well.

00:46:06.690 --> 00:46:10.620
So in terms of squeezing CPU
time out of your instances, I

00:46:10.620 --> 00:46:12.830
think it's pretty good
for that, too.

00:46:12.830 --> 00:46:15.105
Does anybody else that's in
the Hangout have questions

00:46:15.105 --> 00:46:17.465
that they'd like to ask about
the talk or about App Engine

00:46:17.465 --> 00:46:18.715
or about Go?

00:46:23.250 --> 00:46:25.640
AMY: Are you still on
the IRC channel?

00:46:25.640 --> 00:46:28.357
JOHAN EUPHROSINE: Yeah, I've
muted a few people, so maybe I

00:46:28.357 --> 00:46:29.607
can unmute them.

00:46:34.010 --> 00:46:36.980
And so does anybody
have a question?

00:46:36.980 --> 00:46:38.230
No?

00:46:39.906 --> 00:46:41.320
AMY: There's Chris.

00:46:41.320 --> 00:46:42.572
JOHAN EUPHROSINE: Oh,
Chris is here.

00:46:51.510 --> 00:46:52.760
Hey, Chris.

00:46:57.980 --> 00:46:59.230
AMY: Any questions about
[INAUDIBLE]?

00:47:02.600 --> 00:47:03.850
JOHAN EUPHROSINE: I do.

00:47:06.830 --> 00:47:08.080
DAVE: Does the mic work?

00:47:11.060 --> 00:47:12.180
JOHAN EUPHROSINE: His
mic is broken.

00:47:12.180 --> 00:47:15.102
So he may have a question
on chat.

00:47:26.014 --> 00:47:29.769
He says, I like the example
where multiple wizards come

00:47:29.769 --> 00:47:32.404
from Hacker News and Reddit
at the same time.

00:47:32.404 --> 00:47:37.673
Is it possible to run on desktop
queries completely?

00:47:37.673 --> 00:47:39.110
DAVE: Yes.

00:47:39.110 --> 00:47:40.360
Very easy.

00:47:47.950 --> 00:47:50.220
JOHAN EUPHROSINE: You just have
to wrap your API code

00:47:50.220 --> 00:47:53.230
into Go routine and
run concurrently.

00:47:53.230 --> 00:47:54.040
ANDREW: In essence, yeah.

00:47:54.040 --> 00:47:57.750
But with the data store, though,
you have to be aware

00:47:57.750 --> 00:48:01.900
that it won't necessarily
buy you a lot.

00:48:01.900 --> 00:48:05.160
It depends what you're doing,
particularly if you're doing

00:48:05.160 --> 00:48:07.800
transactions within
entity groups.

00:48:07.800 --> 00:48:11.100
If you try and conduct two
transactions on same data at

00:48:11.100 --> 00:48:13.890
same time, or even on data
that's in the same entity

00:48:13.890 --> 00:48:18.580
group, you probably won't see
a big win over just doing it

00:48:18.580 --> 00:48:20.050
sequentially.

00:48:20.050 --> 00:48:25.000
Because instead of serializing
in the client, it'll just be

00:48:25.000 --> 00:48:28.412
serializing it inside
the data store.

00:48:28.412 --> 00:48:33.880
DAVE: He could do it probably
with a URL fetch.

00:48:33.880 --> 00:48:34.850
You're rendering--

00:48:34.850 --> 00:48:38.320
well, you could do fetching
your [INAUDIBLE]

00:48:38.320 --> 00:48:41.650
from the data store at the same
time as doing a URL fetch

00:48:41.650 --> 00:48:45.190
to that weather service because
The weather in Sydney

00:48:45.190 --> 00:48:46.440
[INAUDIBLE].

00:48:49.240 --> 00:48:53.750
You would be doing all that
at once, very easily.

00:48:53.750 --> 00:48:57.290
JOHAN EUPHROSINE: I don't know
about the specifics about the

00:48:57.290 --> 00:48:59.530
way the data store--

00:48:59.530 --> 00:49:04.570
the smallest API layer of the
API code [INAUDIBLE].

00:49:04.570 --> 00:49:08.922
But I know that for Python--
maybe David can confirm, but I

00:49:08.922 --> 00:49:12.500
know that for Python when you
are doing an emergency Get on

00:49:12.500 --> 00:49:17.005
each [INAUDIBLE], it will
actually do much better

00:49:17.005 --> 00:49:18.255
[INAUDIBLE].

00:49:20.770 --> 00:49:23.720
I don't know if it's doing
the same for Go.

00:49:23.720 --> 00:49:26.820
But you have to realize that
there is that candy, that

00:49:26.820 --> 00:49:30.890
extra level of concurrency that
sometimes is introduced

00:49:30.890 --> 00:49:35.890
on the library layer,
so on the SDK layer.

00:49:35.890 --> 00:49:40.230
So for me, it can look like just
an API code, but the user

00:49:40.230 --> 00:49:42.940
will be [INAUDIBLE].

00:49:42.940 --> 00:49:46.550
And also there is another layer
of concurrency happening

00:49:46.550 --> 00:49:47.850
on the south side.

00:49:47.850 --> 00:49:50.650
So when the data store back and
receive your request, it

00:49:50.650 --> 00:49:52.710
can decide to go and
fetch [INAUDIBLE]

00:49:52.710 --> 00:49:53.960
concurrently as well.

00:50:00.940 --> 00:50:07.220
AMY: We had someone typing
in the chat window.

00:50:07.220 --> 00:50:11.710
In app.yaml for Go Runtime,
we expect to find

00:50:11.710 --> 00:50:15.340
script_goapp as the--

00:50:15.340 --> 00:50:16.490
ANDREW: --as the main handler.

00:50:16.490 --> 00:50:18.260
So what is the magic
behind that?

00:50:18.260 --> 00:50:28.010
So essentially when we designed
the Go App Engine

00:50:28.010 --> 00:50:31.550
SDK, we based it on
the Python SDK.

00:50:31.550 --> 00:50:36.740
And so the Python SDK uses an
applet YAML file to define

00:50:36.740 --> 00:50:37.610
[INAUDIBLE].

00:50:37.610 --> 00:50:40.580
And in Python then, you
actually specify the

00:50:40.580 --> 00:50:44.440
[INAUDIBLE], and then you have
a script directive that says

00:50:44.440 --> 00:50:46.606
which Python script
is actually going

00:50:46.606 --> 00:50:48.370
to handle this request.

00:50:48.370 --> 00:50:52.420
But in Go, we don't run multiple
Go programs for

00:50:52.420 --> 00:50:53.300
multiple requests.

00:50:53.300 --> 00:50:56.270
We just run a single instance
of your Go app.

00:50:56.270 --> 00:50:59.950
And then all of the HTTP
requests that are to be

00:50:59.950 --> 00:51:03.040
handled by the Go app are sent
to that single app, no matter

00:51:03.040 --> 00:51:05.060
how many handles you
have to find.

00:51:05.060 --> 00:51:13.430
So this script calling _go_app
signifies that this is a

00:51:13.430 --> 00:51:16.380
handler that should be
handled by the app.

00:51:16.380 --> 00:51:20.500
And so you can't have separate
Go apps that handle different

00:51:20.500 --> 00:51:23.490
parts of your app.

00:51:23.490 --> 00:51:27.680
But you can just write totally
independent packages that

00:51:27.680 --> 00:51:32.280
handle various handlers
independently.

00:51:32.280 --> 00:51:34.700
And they can effectively be
independent programs.

00:51:34.700 --> 00:51:37.170
But on the server side, you must
understand that they're

00:51:37.170 --> 00:51:38.950
actually built into the
same binary, and

00:51:38.950 --> 00:51:40.610
they're executed together.

00:51:40.610 --> 00:51:42.520
So it's a slight departure
from the

00:51:42.520 --> 00:51:45.510
way it works in Python.

00:51:45.510 --> 00:51:47.245
JOHAN EUPHROSINE: I think
that you can--

00:51:47.245 --> 00:51:50.820
you handle most of the routine
in your Go application as

00:51:50.820 --> 00:51:53.950
opposed in Python where you
enter some of the routine at

00:51:53.950 --> 00:51:56.880
the channel and some of the
routine in your Python

00:51:56.880 --> 00:51:57.700
application.

00:51:57.700 --> 00:52:00.610
It's actually a cleaner design,
because you actually

00:52:00.610 --> 00:52:04.050
only have one place to put your
dynamic routine, whereas

00:52:04.050 --> 00:52:07.860
in Python, you can decide to
put them in two places.

00:52:07.860 --> 00:52:10.650
Sometimes it's confusing
for users as well.

00:52:10.650 --> 00:52:16.010
I would like add to
what Andrew says.

00:52:16.010 --> 00:52:22.360
You can add back ends that are
different Go apps, That?

00:52:22.360 --> 00:52:25.640
Interact some or with your Go
application with [INAUDIBLE].

00:52:25.640 --> 00:52:29.040
So if you need to read the same
application in space, if

00:52:29.040 --> 00:52:32.550
you need to be deploy each part
of the Go program, you

00:52:32.550 --> 00:52:37.850
can either use version or you
can use back end in order for

00:52:37.850 --> 00:52:41.330
you to deploy different binary
to the same application.

00:52:41.330 --> 00:52:44.170
ANDREW: And also if you have a
Python application and you

00:52:44.170 --> 00:52:46.660
want to use Go to do something
that you can't do in Python,

00:52:46.660 --> 00:52:49.360
like if you have some number
crunching or something, you

00:52:49.360 --> 00:52:52.730
can actually deploy a Go
back-end to your Python app

00:52:52.730 --> 00:52:55.150
and communicate between the two
using [INAUDIBLE], which

00:52:55.150 --> 00:52:58.520
is actually a pretty powerful
combination.

00:52:58.520 --> 00:53:03.610
You could do the same
with Java as well.

00:53:03.610 --> 00:53:06.025
But I'd also like to
ask if you can

00:53:06.025 --> 00:53:07.710
have multiple handlers?

00:53:07.710 --> 00:53:10.080
And the answer is, yes, you can
have multiple handlers.

00:53:10.080 --> 00:53:13.880
But the point that Proppy was
making is that your app

00:53:13.880 --> 00:53:17.500
channel can basically just have
a catch-all expression in

00:53:17.500 --> 00:53:23.670
the handler and then hand off
all of the routing requests to

00:53:23.670 --> 00:53:25.100
the Go app itself.

00:53:25.100 --> 00:53:29.130
So you just have your handle
clauses in the Go app handling

00:53:29.130 --> 00:53:30.810
the [INAUDIBLE] that you want

00:53:30.810 --> 00:53:34.700
DAVE: In fact, Proppy's example
for the tool has at

00:53:34.700 --> 00:53:36.480
least three handlers.

00:53:42.830 --> 00:53:45.570
JOHAN EUPHROSINE: So
any more questions?

00:53:45.570 --> 00:53:47.522
Otherwise, I guess
we [INAUDIBLE].

00:53:52.290 --> 00:53:54.460
DAVE: So, to an actual
binary, yeah.

00:53:54.460 --> 00:53:54.950
JOHAN EUPHROSINE: He's
talking binary.

00:53:54.950 --> 00:54:01.190
So Alex says that he got it like
we are combining the app

00:54:01.190 --> 00:54:04.680
to a sort of binary, but that's
actually a binary.

00:54:04.680 --> 00:54:05.130
DAVE: Yeah.

00:54:05.130 --> 00:54:06.080
It's the real program.

00:54:06.080 --> 00:54:07.600
It runs in the HC.

00:54:11.780 --> 00:54:14.930
JOHAN EUPHROSINE: And the nice
side effect is that it's

00:54:14.930 --> 00:54:16.040
really fast to run.

00:54:16.040 --> 00:54:19.850
So the Go instant start-up
time is really one of the

00:54:19.850 --> 00:54:23.760
fastest of all the App Engine
runtime, because it only needs

00:54:23.760 --> 00:54:27.790
to read a single file in order
to start your application.

00:54:27.790 --> 00:54:30.830
ANDREW: Yeah, in contrast to
Python, which has to actually

00:54:30.830 --> 00:54:34.800
interpret your Python code and
fire up a Python interpreter,

00:54:34.800 --> 00:54:39.840
or the JVM, which actually
has to load a JVM.

00:54:39.840 --> 00:54:45.880
And so if your app sees a sudden
spike of traffic, I'd

00:54:45.880 --> 00:54:48.190
go out and respond really,
really quickly, because it

00:54:48.190 --> 00:54:53.660
takes hundredths of a second
to fire up a go-out.

00:54:53.660 --> 00:54:54.920
It really is pretty
impressive.

00:55:02.140 --> 00:55:03.565
JOHAN EUPHROSINE: Yeah, I have
a question for David.

00:55:13.330 --> 00:55:15.350
So you know that when you start
a Go routine in App

00:55:15.350 --> 00:55:19.560
Engine, you can only do
useful things in the

00:55:19.560 --> 00:55:21.950
window of the request.

00:55:21.950 --> 00:55:24.630
So if you're outside of the
request window, you can

00:55:24.630 --> 00:55:26.575
already interact with the API.

00:55:26.575 --> 00:55:30.640
You can still have global
channel running in the

00:55:30.640 --> 00:55:32.030
background in your application,
but there

00:55:32.030 --> 00:55:35.208
wouldn't be a bug to issue
an new API code, right?

00:55:35.208 --> 00:55:35.640
DAVE: Right.

00:55:35.640 --> 00:55:36.990
Yup.

00:55:36.990 --> 00:55:38.880
JOHAN EUPHROSINE: I was
wondering if there is support

00:55:38.880 --> 00:55:42.225
for [INAUDIBLE]

00:55:42.225 --> 00:55:45.870
in the Python Java runtime,
as there was a new concept

00:55:45.870 --> 00:55:48.340
introduced which is called
[INAUDIBLE].

00:55:48.340 --> 00:55:55.570
That's on YouTube defined to
pull threads that span across

00:55:55.570 --> 00:55:59.130
the request window.

00:55:59.130 --> 00:56:01.240
But it's only for
the back end.

00:56:01.240 --> 00:56:04.310
And I was wondering if there
is the same thing which in

00:56:04.310 --> 00:56:05.120
planned with Go?

00:56:05.120 --> 00:56:07.580
So we need to explain all
the things that can--

00:56:10.420 --> 00:56:16.580
just one Go To that can interact
with API and not tied

00:56:16.580 --> 00:56:19.910
to an HTTP request.

00:56:19.910 --> 00:56:24.310
DAVE: So there's two modes of
operations for back ends.

00:56:24.310 --> 00:56:31.940
There's a serving back end,
which serves requests.

00:56:31.940 --> 00:56:33.260
You know, requests come in.

00:56:33.260 --> 00:56:33.950
It will handle it.

00:56:33.950 --> 00:56:36.510
It will generate a response.

00:56:36.510 --> 00:56:38.230
And then finish up
that request.

00:56:38.230 --> 00:56:39.555
But there's also--

00:56:39.555 --> 00:56:41.690
I don't remember the
terminology--

00:56:41.690 --> 00:56:44.375
lonely back ends, processing
back ends.

00:56:44.375 --> 00:56:49.550
And in that case, what happens
is that the Go instance will

00:56:49.550 --> 00:56:53.190
start, and the App Engine
infrastructure will say that a

00:56:53.190 --> 00:56:58.975
request to a URL, something
like _ah/*.

00:56:58.975 --> 00:57:03.396
Now, if the back end doesn't
return from that, then that

00:57:03.396 --> 00:57:07.650
back end string is a long
running processing back end,

00:57:07.650 --> 00:57:11.380
which means that you have
effectively a long running

00:57:11.380 --> 00:57:17.460
request that can last for
minutes, hours, days, weeks.

00:57:17.460 --> 00:57:20.420
And so during that time,
you can make API calls.

00:57:20.420 --> 00:57:24.630
If you construct an App Engine
context from that request that

00:57:24.630 --> 00:57:28.680
you received to _ah/*. "A," "H,"
So even if they could get

00:57:28.680 --> 00:57:31.320
the same thing where you can
have something long running

00:57:31.320 --> 00:57:34.950
for a long time, but
make API calls.

00:57:34.950 --> 00:57:39.340
JOHAN EUPHROSINE: So you just
have to use the customer as

00:57:39.340 --> 00:57:41.990
the context when you get the
warm-up and just reuse the

00:57:41.990 --> 00:57:43.656
same context forever.

00:57:43.656 --> 00:57:46.760
DAVE: Yeah, and not return from
that initial request.

00:57:46.760 --> 00:57:48.010
JOHAN EUPHROSINE: OK.

00:57:50.174 --> 00:57:52.550
ANDREW: Yeah, in effect that
becomes your main.

00:57:52.550 --> 00:57:55.390
Like if you're running a
standalone function, then that

00:57:55.390 --> 00:57:59.986
main-- that start handler is
just like your main function.

00:57:59.986 --> 00:58:04.520
JOHAN EUPHROSINE: Yeah, and if
[INAUDIBLE] serving the back

00:58:04.520 --> 00:58:09.295
end is doing IO, if this long
running back end is doing IO,

00:58:09.295 --> 00:58:13.420
for example, like it's looking
at a channel or like looking

00:58:13.420 --> 00:58:16.980
at API code, does that mean it
can answer incoming HTTP

00:58:16.980 --> 00:58:20.040
requests as well?

00:58:20.040 --> 00:58:21.280
DAVE: No.

00:58:21.280 --> 00:58:24.545
If the back end doesn't return
from the [INAUDIBLE]

00:58:24.545 --> 00:58:27.940
start request, it won't be
sending me more requests.

00:58:27.940 --> 00:58:31.330
It won't be building
in that respect.

00:58:31.330 --> 00:58:32.580
JOHAN EUPHROSINE: OK.

00:58:37.525 --> 00:58:37.990
AMY: OK.

00:58:37.990 --> 00:58:43.500
Well, I think we're at the top
of the hour so, as they say in

00:58:43.500 --> 00:58:50.540
radio, so if we have no more
last minute questions, thanks

00:58:50.540 --> 00:58:53.000
everyone very much for joining
us or for watching.

00:58:56.470 --> 00:58:57.900
ANDREW: And thanks, Proppy,
for writing and

00:58:57.900 --> 00:58:58.850
delivering the talk.

00:58:58.850 --> 00:59:00.170
AMY: Thanks very much, Proppy.

00:59:00.170 --> 00:59:01.420
See you guys next time.

