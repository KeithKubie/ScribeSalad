WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.346
[MUSIC PLAYING]

00:00:03.346 --> 00:00:07.060
ELLIOTT HUGHES: So today, we
do not want to get any new C++

00:00:07.060 --> 00:00:07.560
users.

00:00:07.560 --> 00:00:11.550
We hope that you will use
Java or Kotlin if you can.

00:00:11.550 --> 00:00:14.550
But obviously there are people
who can't, and we're here

00:00:14.550 --> 00:00:15.220
for you.

00:00:15.220 --> 00:00:18.360
And so I think what we
really want to say is just,

00:00:18.360 --> 00:00:19.890
we are working on C and C++.

00:00:19.890 --> 00:00:20.482
We do care.

00:00:20.482 --> 00:00:21.940
We're trying to
make things better,

00:00:21.940 --> 00:00:23.773
and we want to talk
about some of the things

00:00:23.773 --> 00:00:26.050
that we've been doing
over the past few years.

00:00:26.050 --> 00:00:32.850
So specifically, we are the
platform, the OS, C++ team.

00:00:32.850 --> 00:00:39.300
And we took over the
NDK around 2015 for r10.

00:00:39.300 --> 00:00:42.030
The parts that we
consider the NDK

00:00:42.030 --> 00:00:44.548
are basically the compiler,
the headers, and the libraries.

00:00:44.548 --> 00:00:46.590
So we're not talking about
things like the Studio

00:00:46.590 --> 00:00:49.680
integration, the Gradle stuff.

00:00:49.680 --> 00:00:52.080
The Studio folks are around,
they've got numerous talks

00:00:52.080 --> 00:00:55.950
and you can talk to
them other times.

00:00:55.950 --> 00:00:59.850
So Dan's going to start with a
introduction to what we've done

00:00:59.850 --> 00:01:01.083
since we took over the NDK.

00:01:01.083 --> 00:01:01.750
DAN ALBERT: Yes.

00:01:01.750 --> 00:01:05.730
So like Elliott said, we
took over in about May 2015.

00:01:05.730 --> 00:01:08.580
That was NDK r10e at the time.

00:01:08.580 --> 00:01:12.340
So I'm going to be
covering from then on.

00:01:12.340 --> 00:01:15.310
To give some perspective what
the OS C++ experience looked

00:01:15.310 --> 00:01:17.920
like back then, this
was Marshmallow.

00:01:17.920 --> 00:01:20.230
We were most of the
way done with that.

00:01:20.230 --> 00:01:23.260
We had the transition to Clang
well underway at that point.

00:01:23.260 --> 00:01:26.510
We'd moved a device
in its entirety.

00:01:26.510 --> 00:01:27.850
We were working on others.

00:01:27.850 --> 00:01:33.460
We had complete C++14 support
from libc++ at that point.

00:01:33.460 --> 00:01:36.190
Google is big on dogfooding,
so the idea being we

00:01:36.190 --> 00:01:37.760
should be using
what you're using

00:01:37.760 --> 00:01:40.570
so that we find the bugs
before we ship them to you.

00:01:40.570 --> 00:01:42.777
Unfortunately for
the NDK at the time,

00:01:42.777 --> 00:01:44.110
this is what things looked like.

00:01:44.110 --> 00:01:45.443
We had four different compilers.

00:01:45.443 --> 00:01:48.190
So that was two versions of
GCC, two versions of Clang.

00:01:48.190 --> 00:01:50.080
Clang was heavily forked.

00:01:50.080 --> 00:01:51.790
Three different C++ libraries.

00:01:51.790 --> 00:01:55.060
We had stlport, hadn't received
updates upstream in years so it

00:01:55.060 --> 00:01:56.530
was still in C++03.

00:01:56.530 --> 00:02:00.280
We had the gnustl, more commonly
known as GNUs libstdc++.

00:02:00.280 --> 00:02:02.410
That's what you have in
your normal Linux system.

00:02:02.410 --> 00:02:06.490
And libc++, which is LLVMs
C++ standard library which

00:02:06.490 --> 00:02:08.509
we're using in the platform.

00:02:08.509 --> 00:02:10.780
This was also quite
heavily forked in the NDK,

00:02:10.780 --> 00:02:12.430
and it had a
compatibility library

00:02:12.430 --> 00:02:15.460
that let it run going
back to Gingerbread.

00:02:15.460 --> 00:02:18.950
And that library had quite
a few bugs, unfortunately.

00:02:18.950 --> 00:02:21.460
So that was a major
source of issues.

00:02:21.460 --> 00:02:23.830
We also had a copy
of the OS headers

00:02:23.830 --> 00:02:27.040
for every single API
level and architecture.

00:02:27.040 --> 00:02:30.970
And typically that meant that if
we fixed a bug in the headers,

00:02:30.970 --> 00:02:32.840
we only fixed it in
the most recent version

00:02:32.840 --> 00:02:33.970
and it didn't get backported.

00:02:33.970 --> 00:02:35.428
Which was a big
problem because you

00:02:35.428 --> 00:02:37.780
were using whichever
version of the headers

00:02:37.780 --> 00:02:39.215
matched your min SDK version.

00:02:39.215 --> 00:02:40.840
So if we only fixed
the latest version,

00:02:40.840 --> 00:02:43.132
you wouldn't actually see
the fix for about five years,

00:02:43.132 --> 00:02:45.770
maybe more.

00:02:45.770 --> 00:02:48.920
So the question is how do we
get to this dogfooding world.

00:02:48.920 --> 00:02:50.770
And we could
essentially either just

00:02:50.770 --> 00:02:52.780
stop shipping NDKs
for a couple of years

00:02:52.780 --> 00:02:54.550
while we dealt with
all of the issues that

00:02:54.550 --> 00:02:56.110
had to get us there.

00:02:56.110 --> 00:02:57.970
That didn't sound
particularly appealing,

00:02:57.970 --> 00:03:01.630
so instead we tried
to do this in smaller,

00:03:01.630 --> 00:03:02.900
less disruptive steps.

00:03:02.900 --> 00:03:05.380
Each step still had
some disruption,

00:03:05.380 --> 00:03:08.560
but it was a much easier
hurdle to get over.

00:03:08.560 --> 00:03:12.350
We did this in a predictable
opt in, opt out, and then remove

00:03:12.350 --> 00:03:12.850
cycle.

00:03:12.850 --> 00:03:16.630
If I use the unified
headers as an example, r14

00:03:16.630 --> 00:03:18.660
we added a flag
to turn those on.

00:03:18.660 --> 00:03:20.740
r15, if your app wasn't
ready to switch yet,

00:03:20.740 --> 00:03:23.980
you could still opt out
with a different flag.

00:03:23.980 --> 00:03:26.500
And then by r16 we had
worked out all the kinks

00:03:26.500 --> 00:03:29.680
and we were ready to move on, so
we removed the previous option.

00:03:32.890 --> 00:03:37.660
The compilers, we started
with this really with r11.

00:03:37.660 --> 00:03:40.090
That was when we
unforked the NDKs Clang,

00:03:40.090 --> 00:03:43.750
and that alone let us
close just a ton of bugs.

00:03:43.750 --> 00:03:47.470
It was then the same compiler
that we used to build the OS.

00:03:47.470 --> 00:03:49.390
r13 couple releases
later we switched

00:03:49.390 --> 00:03:53.290
that to be the default.
And then by r18 it was--

00:03:53.290 --> 00:03:55.540
we were to the point that
we could actually rely fully

00:03:55.540 --> 00:03:59.030
on Clang and libc++,
so we removed GCC.

00:03:59.030 --> 00:04:02.350
At this point, all of
Android, all of ChromeOS, iOS,

00:04:02.350 --> 00:04:03.610
all of these are using Clang.

00:04:03.610 --> 00:04:07.313
So if you are targeting a subset
of these operating systems,

00:04:07.313 --> 00:04:09.730
your code is much more likely
to be portable between them.

00:04:13.050 --> 00:04:15.670
The unified headers I
had mentioned earlier,

00:04:15.670 --> 00:04:18.209
this is the gist of
what those look like.

00:04:18.209 --> 00:04:21.360
Instead of having a different
copy of this header for every

00:04:21.360 --> 00:04:24.990
single API level, we have
this annotation here,

00:04:24.990 --> 00:04:28.080
__INTRODUCED_IN, that says that
dlvsym was not available until

00:04:28.080 --> 00:04:30.320
Android 24.

00:04:30.320 --> 00:04:33.680
The compiler will make sure
that you can't actually

00:04:33.680 --> 00:04:38.250
build against that if your min
SDK version is not at least 24.

00:04:38.250 --> 00:04:41.550
We still have all of the types,
the macros, the constants,

00:04:41.550 --> 00:04:44.020
all the things that you need
to use these APIs visible.

00:04:44.020 --> 00:04:45.240
So if you are running--

00:04:45.240 --> 00:04:47.280
if your min SDK version
is lower than the device

00:04:47.280 --> 00:04:48.988
you're actually running
on, you can still

00:04:48.988 --> 00:04:51.990
access the new API with dlsym
and use all the correct types

00:04:51.990 --> 00:04:54.422
rather than copy pasting
all the types and constants

00:04:54.422 --> 00:04:56.130
into your project,
like you would have to

00:04:56.130 --> 00:04:57.720
with the previous solution.

00:05:00.290 --> 00:05:02.630
This did unearth
a handful of bugs.

00:05:02.630 --> 00:05:05.960
It was mostly actually
old Android workarounds

00:05:05.960 --> 00:05:08.513
that had been checked in,
had to be deleted in order

00:05:08.513 --> 00:05:09.680
to work with the new option.

00:05:09.680 --> 00:05:11.660
But deleting code's
pretty straightforward,

00:05:11.660 --> 00:05:12.840
so that's not too bad.

00:05:15.820 --> 00:05:16.770
libc++.

00:05:16.770 --> 00:05:21.690
Like I said, this
was one of the more--

00:05:21.690 --> 00:05:25.380
this was really our main goal,
was to give you a up to date

00:05:25.380 --> 00:05:28.260
C++ standard library.

00:05:28.260 --> 00:05:31.140
Something that actually could
support C++11 at the time

00:05:31.140 --> 00:05:33.750
and then 14 and now even 17.

00:05:33.750 --> 00:05:36.390
It was a fairly long
road to get there.

00:05:36.390 --> 00:05:39.300
It required those
previous fixes first.

00:05:39.300 --> 00:05:43.320
In r16 was when we really
started doing this in earnest.

00:05:43.320 --> 00:05:47.670
We rewrote that compatibility
library with all the bugs,

00:05:47.670 --> 00:05:50.400
added a whole bunch
of tests, made sure

00:05:50.400 --> 00:05:51.980
that that was nice and solid.

00:05:51.980 --> 00:05:56.322
And we shipped that in r16, took
the beta sticker off and said,

00:05:56.322 --> 00:05:57.530
yes, please start using this.

00:05:57.530 --> 00:05:59.150
It wasn't the default yet.

00:05:59.150 --> 00:06:00.950
We waited for r17 for that.

00:06:00.950 --> 00:06:03.907
So r17 it became the default.
And then r18 everything

00:06:03.907 --> 00:06:05.990
was looking good and we
removed the other options.

00:06:08.560 --> 00:06:12.180
So as of r18 the NDK had a
single compiler, the same one

00:06:12.180 --> 00:06:13.260
we used to build the OS.

00:06:13.260 --> 00:06:15.900
A single set of headers, same
ones we used to build the OS.

00:06:15.900 --> 00:06:18.690
And a single C++ library,
the same one we used to build

00:06:18.690 --> 00:06:20.190
the operating system.

00:06:20.190 --> 00:06:22.449
So it was dogfooding
mission accomplished.

00:06:22.449 --> 00:06:25.802
[APPLAUSE]

00:06:27.965 --> 00:06:30.090
Does this mean that there's
no more disruption when

00:06:30.090 --> 00:06:31.290
you update your NDK?

00:06:31.290 --> 00:06:32.583
Unfortunately, not quite.

00:06:32.583 --> 00:06:35.250
There are still a few changes we
are going to need to be making.

00:06:35.250 --> 00:06:38.555
This is particularly to
reduce the size of the NDK.

00:06:38.555 --> 00:06:40.680
There's a whole bunch of
redundant copies of things

00:06:40.680 --> 00:06:41.575
right now.

00:06:41.575 --> 00:06:43.200
And if you're build
system is currently

00:06:43.200 --> 00:06:44.970
relying on those
redundant copies, when

00:06:44.970 --> 00:06:47.370
I go to delete them your
build system's going to break.

00:06:47.370 --> 00:06:51.330
Fortunately as long as
you're on NDK r19 or newer,

00:06:51.330 --> 00:06:54.210
ndk-build and CMake, our two
officially supported options,

00:06:54.210 --> 00:06:57.010
are already onto this.

00:06:57.010 --> 00:07:01.220
So as long as you're using
those, you're already covered.

00:07:01.220 --> 00:07:04.517
If you do have your
own build system,

00:07:04.517 --> 00:07:06.350
there is fortunately a
doc linked down there

00:07:06.350 --> 00:07:09.090
at the bottom that
will tell you all

00:07:09.090 --> 00:07:11.090
that you need to know to
actually integrate this

00:07:11.090 --> 00:07:12.560
into your own build system.

00:07:12.560 --> 00:07:15.200
Aside from that, we do have
the two build systems still.

00:07:15.200 --> 00:07:17.690
ndk-build is alive and well.

00:07:17.690 --> 00:07:19.280
It is purpose built for Android.

00:07:19.280 --> 00:07:22.100
So often, if you are
targeting only Android,

00:07:22.100 --> 00:07:24.770
that is actually going to
be your easiest option.

00:07:24.770 --> 00:07:26.060
That is not the normal case.

00:07:26.060 --> 00:07:28.928
You are probably also
targeting iOS, Windows, handful

00:07:28.928 --> 00:07:29.720
of other platforms.

00:07:29.720 --> 00:07:31.528
In that case, CMake
is your best bet.

00:07:31.528 --> 00:07:34.070
It is going to be the easiest
option for cross platform work.

00:07:36.600 --> 00:07:40.762
And with that, I'm handing
off to Elliott for debugging.

00:07:40.762 --> 00:07:41.750
ELLIOTT HUGHES: Hi.

00:07:41.750 --> 00:07:45.020
So I think it's not really going
to be much of a surprise that

00:07:45.020 --> 00:07:47.600
the first thing to
talk about with C, C++,

00:07:47.600 --> 00:07:50.100
debugging is memory issues.

00:07:50.100 --> 00:07:54.320
So like I said at the start,
we are the OS C++ team.

00:07:54.320 --> 00:07:56.210
So any kind of
problem that you guys

00:07:56.210 --> 00:07:58.700
are having in apps, we've
been having in the OS

00:07:58.700 --> 00:08:01.310
itself for a long time.

00:08:01.310 --> 00:08:03.403
Typically we've
used ASan for this.

00:08:06.190 --> 00:08:08.030
This is a new hardware
accelerated ASan,

00:08:08.030 --> 00:08:11.060
and hopefully we'll talk
about that some other time.

00:08:11.060 --> 00:08:13.560
But right now ASan is kind of
the state of the art for this.

00:08:13.560 --> 00:08:15.330
That's what we're
using for platform.

00:08:15.330 --> 00:08:17.480
And what we're going
to talk about today

00:08:17.480 --> 00:08:20.600
is how you can use
this in the NDK.

00:08:20.600 --> 00:08:25.880
It is supported in the NDK, it's
just perhaps less well known.

00:08:25.880 --> 00:08:28.700
So these are the kind of
issues that ASan can find.

00:08:28.700 --> 00:08:31.370
It's basically everything
except for leaks.

00:08:31.370 --> 00:08:33.830
For leaks we use malloc debug.

00:08:33.830 --> 00:08:36.470
You can find documentation for
that on developer.android.com

00:08:36.470 --> 00:08:39.140
as well, in the same place
as the ASan documentations.

00:08:39.140 --> 00:08:41.980
But the key thing I want to
talk about is this wrap.sh.

00:08:41.980 --> 00:08:46.400
So ASan on Android is
interesting in that the way it

00:08:46.400 --> 00:08:49.250
works is that you have this
LD_PRELOAD, this shared

00:08:49.250 --> 00:08:52.610
library that has to get loaded
before your code starts.

00:08:52.610 --> 00:08:56.030
Basically, it intercepts
all of the memory allocation

00:08:56.030 --> 00:08:57.650
and freeing operations.

00:08:57.650 --> 00:09:00.050
And to do that,
it obviously needs

00:09:00.050 --> 00:09:03.320
to be running before any
allocations are actually made.

00:09:03.320 --> 00:09:04.950
Normally this
wouldn't be a problem,

00:09:04.950 --> 00:09:07.150
but on Android when
your app starts,

00:09:07.150 --> 00:09:08.900
you're not actually
starting from scratch.

00:09:08.900 --> 00:09:11.960
You're starting from
a clone of the zygote.

00:09:11.960 --> 00:09:14.720
Which, you know, it's
generally helpful.

00:09:14.720 --> 00:09:18.020
It reduces your app
startup time greatly

00:09:18.020 --> 00:09:21.110
because the common startup
that every app would

00:09:21.110 --> 00:09:22.980
have to do have all
the framework stuff

00:09:22.980 --> 00:09:24.170
has already happened.

00:09:24.170 --> 00:09:26.090
If you want more details
about the zygote,

00:09:26.090 --> 00:09:29.760
the art folks are going to be
giving a talk tomorrow morning

00:09:29.760 --> 00:09:32.690
where they'll be talking about
some of the new optimizations

00:09:32.690 --> 00:09:33.850
they've done to that in Q.

00:09:33.850 --> 00:09:35.600
But for our purposes,
all you need to know

00:09:35.600 --> 00:09:39.360
is this kind of gets
and your way for ASan.

00:09:39.360 --> 00:09:41.120
So what we added
was a thing where

00:09:41.120 --> 00:09:45.240
if you have a shell script
in your APK called wrap.sh

00:09:45.240 --> 00:09:49.550
and in the correct directory,
when the zygote comes

00:09:49.550 --> 00:09:53.930
to launch your app, instead of
cloning what's already there

00:09:53.930 --> 00:09:57.890
it actually starts
completely from scratch.

00:09:57.890 --> 00:10:01.840
So here's an example of what
such a shell script could

00:10:01.840 --> 00:10:02.620
look like.

00:10:02.620 --> 00:10:07.330
So $@ is basically shell
for all the arguments.

00:10:07.330 --> 00:10:13.970
So what's happening here is
when Android calls your wrap.sh,

00:10:13.970 --> 00:10:15.590
it gives you the
exact command line

00:10:15.590 --> 00:10:18.120
that it would
otherwise have run.

00:10:18.120 --> 00:10:20.145
So here we're just
saying, do what

00:10:20.145 --> 00:10:21.270
you would have done anyway.

00:10:21.270 --> 00:10:24.440
So the only difference is you're
in a completely fresh process.

00:10:24.440 --> 00:10:26.300
You're not cloned
from the zygote.

00:10:26.300 --> 00:10:29.930
And anything that you
output to stdout or stderr

00:10:29.930 --> 00:10:31.190
will go to the log.

00:10:31.190 --> 00:10:33.170
It will go to logcat
rather than just being

00:10:33.170 --> 00:10:34.580
lost like it normally would.

00:10:34.580 --> 00:10:37.250
Again because the assumption
is you're debugging here,

00:10:37.250 --> 00:10:39.150
you want to see anything.

00:10:39.150 --> 00:10:43.410
So here's a slightly more
interesting version, then.

00:10:43.410 --> 00:10:49.325
This is saying-- so
the ASan options,

00:10:49.325 --> 00:10:50.700
there's a link a
couple of slides

00:10:50.700 --> 00:10:54.090
ago for all the details about
the different ASan options.

00:10:54.090 --> 00:10:56.610
This is just an example of
like, here are common options

00:10:56.610 --> 00:10:58.980
that you will want if you're
using ASan on Android.

00:10:58.980 --> 00:11:00.600
So that puts that
into the environment

00:11:00.600 --> 00:11:02.310
for when you're app starts.

00:11:02.310 --> 00:11:05.400
LD_PRELOAD, like I
said, that's a clue

00:11:05.400 --> 00:11:08.670
to the dynamic linker when
you start with this app,

00:11:08.670 --> 00:11:11.310
load this library first.

00:11:11.310 --> 00:11:15.690
And this is, kind of,
the runtime for ASan.

00:11:15.690 --> 00:11:17.160
ndk-build knows about this.

00:11:17.160 --> 00:11:18.690
It will do this magic for you.

00:11:18.690 --> 00:11:20.910
There's a little wrinkle
with Studio at the moment,

00:11:20.910 --> 00:11:24.810
that we need to teach Studio
to actually package this.

00:11:24.810 --> 00:11:27.030
If you're not using
Studio, you don't really

00:11:27.030 --> 00:11:27.990
need to do anything.

00:11:27.990 --> 00:11:31.830
If you are, definitely go
to developer.android.com.

00:11:31.830 --> 00:11:33.990
You can see the
docs about wrap.sh,

00:11:33.990 --> 00:11:36.690
and we've got an example of
that that has screenshots

00:11:36.690 --> 00:11:38.012
of what you need to do.

00:11:38.012 --> 00:11:40.470
If you're using ndk-build, this
is more what it looks like.

00:11:40.470 --> 00:11:43.110
In your Android.mk
file, you literally just

00:11:43.110 --> 00:11:46.840
tell a compiler please turn
on address sanitization.

00:11:46.840 --> 00:11:50.640
The -fno-omit-frame-pointer
thing is so that we can give

00:11:50.640 --> 00:11:53.550
you good quick unwinds.

00:11:53.550 --> 00:11:57.340
Like I say, if you do this,
ndk-build picks up on that.

00:11:57.340 --> 00:12:00.250
It spots that you've
said sanitize address,

00:12:00.250 --> 00:12:03.690
and it'll actually set
up the wrap.sh for you.

00:12:03.690 --> 00:12:05.850
So like I say, lots more
documentation on that.

00:12:05.850 --> 00:12:08.860
It is kind of complicated, but
once you get the hang of it

00:12:08.860 --> 00:12:09.680
it's not too bad.

00:12:09.680 --> 00:12:12.055
There's documentation about
that on developer.android.com

00:12:12.055 --> 00:12:14.520
that includes a few examples.

00:12:14.520 --> 00:12:17.730
File bugs if you have
trouble with any of that.

00:12:17.730 --> 00:12:20.460
So another thing we have that--

00:12:20.460 --> 00:12:23.010
we've been using this,
again, the platform

00:12:23.010 --> 00:12:25.410
has used this since 2012.

00:12:25.410 --> 00:12:27.030
We've used this for
a long time now.

00:12:27.030 --> 00:12:30.510
But by default, NDK users
aren't getting this.

00:12:30.510 --> 00:12:34.950
If you want us to catch easy,
sort of, buffer overrun bugs

00:12:34.950 --> 00:12:38.550
if you define
_FORTIFY_SOURCE to 2--

00:12:38.550 --> 00:12:41.310
again, you can look this
up on the web for details.

00:12:41.310 --> 00:12:44.940
You define _FORTIFY_SOURCE,
you can actually have us behind

00:12:44.940 --> 00:12:45.900
the scenes.

00:12:45.900 --> 00:12:49.490
The compiler, if it can do
so, will prove at compile time

00:12:49.490 --> 00:12:51.940
that your code is either
correct or incorrect.

00:12:51.940 --> 00:12:54.270
It is incorrect, it will
just spew out an error

00:12:54.270 --> 00:12:55.740
and you can fix
it there and then.

00:12:55.740 --> 00:12:59.430
If it can't prove it, it'll
actually insert a call

00:12:59.430 --> 00:13:00.930
to a slightly
different routine that

00:13:00.930 --> 00:13:02.520
will do some runtime checking.

00:13:02.520 --> 00:13:05.580
So in this example, this
is something obviously

00:13:05.580 --> 00:13:07.140
very contrived, but
this is something

00:13:07.140 --> 00:13:10.020
that this static analysis
built into the compiler

00:13:10.020 --> 00:13:11.070
doesn't actually spot.

00:13:11.070 --> 00:13:13.590
It doesn't realize
that that 32 is

00:13:13.590 --> 00:13:16.120
going to be used as
that parameter to read.

00:13:16.120 --> 00:13:18.180
So it turns this
into a runtime check.

00:13:18.180 --> 00:13:21.810
And if that fails, you then
get a nice, clear abort.

00:13:21.810 --> 00:13:24.480
And the abort message will be
along the lines of, you know,

00:13:24.480 --> 00:13:28.250
fortify the specific
function you called and then

00:13:28.250 --> 00:13:30.120
what you asked it
to do and what it

00:13:30.120 --> 00:13:32.780
thinks the current
state of the world is.

00:13:32.780 --> 00:13:34.430
Similar to that, an
even easier case.

00:13:34.430 --> 00:13:40.850
We have a lot of app compat
use where SELinux policies have

00:13:40.850 --> 00:13:43.280
changed or permissions
on some file have changed

00:13:43.280 --> 00:13:45.740
or even the existence
of a file has changed.

00:13:45.740 --> 00:13:48.540
But apps are assuming,
oh, I just open this file

00:13:48.540 --> 00:13:49.700
and then I read from it.

00:13:49.700 --> 00:13:52.770
And they kind of plow on without
actually checking for errors.

00:13:52.770 --> 00:13:54.650
So it's simple cases
like that where

00:13:54.650 --> 00:13:59.450
it's never valid to give a
null file pointer to any stdio

00:13:59.450 --> 00:14:00.360
function.

00:14:00.360 --> 00:14:03.200
So we will actually,
just on recent builds,

00:14:03.200 --> 00:14:04.940
we'll just blow you
out of the water.

00:14:04.940 --> 00:14:05.810
Nice clean abort.

00:14:05.810 --> 00:14:09.570
Nice clean error message.

00:14:09.570 --> 00:14:11.780
Another similar thing
on more recent builds

00:14:11.780 --> 00:14:15.170
is that there's been a lot
of confusion about pthread_t,

00:14:15.170 --> 00:14:17.150
which is what you get
from pthread_create

00:14:17.150 --> 00:14:19.460
and you use with all the
other pthread functions,

00:14:19.460 --> 00:14:21.080
and pid_t, which
is basically just

00:14:21.080 --> 00:14:24.950
the integer that the kernel
uses for its raw thread.

00:14:24.950 --> 00:14:27.350
And you do sometimes need
to deal with both of these

00:14:27.350 --> 00:14:29.900
depending on what
your app is doing.

00:14:29.900 --> 00:14:33.770
You can get a pid_t
from a pthread_t.

00:14:33.770 --> 00:14:37.920
There's a p_thread gettid NP
function that you can call.

00:14:37.920 --> 00:14:40.490
So if you're using some
kind of low level Linux API

00:14:40.490 --> 00:14:42.800
that requires a tid,
you can do that.

00:14:42.800 --> 00:14:45.625
What you can't do is
you can't give a tid,

00:14:45.625 --> 00:14:49.160
you know, a pid, to one
of the pthread functions.

00:14:49.160 --> 00:14:51.702
Historically, it would
just silently do nothing.

00:14:51.702 --> 00:14:53.910
Because it would look on
its list of current threads,

00:14:53.910 --> 00:14:56.360
say I've not heard of
that, that's not a thread,

00:14:56.360 --> 00:14:57.210
and do nothing.

00:14:57.210 --> 00:14:59.450
Nowadays, it actually
catches this-- again,

00:14:59.450 --> 00:15:00.828
nice clear abort--

00:15:00.828 --> 00:15:02.120
and tells you what you've done.

00:15:02.120 --> 00:15:06.720
Usually this means-- if
it's a low number like this,

00:15:06.720 --> 00:15:11.350
it means that you made this
pthread and tid confusion.

00:15:11.350 --> 00:15:13.250
If it's a high
number, that means

00:15:13.250 --> 00:15:15.320
you've lost track of
one of your threads.

00:15:15.320 --> 00:15:17.000
It's basically the
thread equivalent

00:15:17.000 --> 00:15:19.730
of, like, a double close
or an invalid free.

00:15:19.730 --> 00:15:22.970
Those are often a
bit harder to debug.

00:15:22.970 --> 00:15:28.940
Something brand new in Q
that's new to Android is fdsan.

00:15:28.940 --> 00:15:32.930
So file descriptors, it's
what's behind the scenes of like

00:15:32.930 --> 00:15:36.530
the stdio file or
the C++ file APIs.

00:15:36.530 --> 00:15:37.800
It's an integer.

00:15:37.800 --> 00:15:41.280
It's what the Linux kernel
uses to represent an open file.

00:15:41.280 --> 00:15:46.380
And it's quite easy to mess
up the ownership of these.

00:15:46.380 --> 00:15:48.890
And what's really unfortunate
is that the kernel

00:15:48.890 --> 00:15:51.660
does a, kind of,
first fit allocation.

00:15:51.660 --> 00:15:54.140
So if you allocate
five files and then

00:15:54.140 --> 00:15:56.720
you close one and
open another, you'll

00:15:56.720 --> 00:15:58.340
get that same number reused.

00:15:58.340 --> 00:16:00.890
So it's really hard
to debug these.

00:16:00.890 --> 00:16:02.060
So what we've done.

00:16:02.060 --> 00:16:05.320
We've actually added tracking
for this to the C library.

00:16:05.320 --> 00:16:06.950
The link at the
bottom explains how

00:16:06.950 --> 00:16:09.850
if you've got higher
level classes that

00:16:09.850 --> 00:16:12.950
control some resources
that have file descriptors,

00:16:12.950 --> 00:16:15.170
you can actually
take part in this.

00:16:15.170 --> 00:16:18.600
But we've wired up the basic
classes, the basic structs,

00:16:18.600 --> 00:16:22.070
things like file and
stdio so that you--

00:16:22.070 --> 00:16:24.510
this example on the
slide, for example.

00:16:24.510 --> 00:16:27.630
This is a real bug that
we actually had in Android

00:16:27.630 --> 00:16:28.700
that was found by this.

00:16:28.700 --> 00:16:31.130
Obviously, the real one was
spread over multiple files

00:16:31.130 --> 00:16:32.390
and hundreds of lines.

00:16:32.390 --> 00:16:34.040
But it boils down to this.

00:16:34.040 --> 00:16:36.337
That now is a nice clear abort.

00:16:36.337 --> 00:16:37.670
Well there's actually two modes.

00:16:37.670 --> 00:16:38.930
Again, see the documentation.

00:16:38.930 --> 00:16:41.180
You can either-- by
default at the moment,

00:16:41.180 --> 00:16:43.520
it just logs if
it finds an issue

00:16:43.520 --> 00:16:44.780
and then lets you carry on.

00:16:44.780 --> 00:16:48.133
So it preserves that, kind
of, backward buggy behavior.

00:16:48.133 --> 00:16:49.550
Hopefully in future
we'll actually

00:16:49.550 --> 00:16:51.320
make that fully
enforcing, but you can do

00:16:51.320 --> 00:16:54.110
that yourself in the meantime.

00:16:54.110 --> 00:16:55.730
So unwinding.

00:16:55.730 --> 00:16:58.640
Whenever you have a crash,
you've seen the sort of stacks

00:16:58.640 --> 00:17:01.523
that you get from that.

00:17:01.523 --> 00:17:03.190
Behind the scenes,
there's piece of code

00:17:03.190 --> 00:17:06.140
called the unwinder which is
basically just crawling up

00:17:06.140 --> 00:17:09.800
your stack working
out what called what.

00:17:09.800 --> 00:17:11.569
In the past, that really--

00:17:11.569 --> 00:17:14.869
it worked fine for C and C++,
but it kind of fell apart when

00:17:14.869 --> 00:17:16.730
it hit Java.

00:17:16.730 --> 00:17:19.250
So one thing we've
done more recently.

00:17:19.250 --> 00:17:21.238
We've written a
completely new unwinder.

00:17:21.238 --> 00:17:23.780
And the major feature of that
is that it actually understands

00:17:23.780 --> 00:17:25.260
Java and Kotlin frames.

00:17:25.260 --> 00:17:27.260
It doesn't matter whether
they're ahead of time,

00:17:27.260 --> 00:17:29.060
compiled, jitted,
or interpreted.

00:17:29.060 --> 00:17:30.380
It will do the right thing.

00:17:30.380 --> 00:17:34.520
In Q, we've added a few
extra little tricks.

00:17:34.520 --> 00:17:36.050
ELF build IDs are useful.

00:17:36.050 --> 00:17:38.240
Every object file,
every executable

00:17:38.240 --> 00:17:41.300
you have has a
hash encoded in it.

00:17:41.300 --> 00:17:45.497
We'll actually show those
hashes in Q so that you can--

00:17:45.497 --> 00:17:46.580
sometimes you're not sure.

00:17:46.580 --> 00:17:47.958
Like, is this is
this really the,

00:17:47.958 --> 00:17:50.000
were they running the
right version of the code I

00:17:50.000 --> 00:17:51.000
think they were running?

00:17:51.000 --> 00:17:52.680
Am I debugging against
the wrong thing?

00:17:52.680 --> 00:17:54.750
You can check it out.

00:17:54.750 --> 00:17:58.070
So here's an example of what
the stacks used to look like.

00:17:58.070 --> 00:18:01.860
The blue parts, the C++,
that used to work fine.

00:18:01.860 --> 00:18:04.430
But as soon as we'd hit
Java, we'd basically stop.

00:18:04.430 --> 00:18:07.700
Because the way Java--

00:18:07.700 --> 00:18:10.000
the way they are at
runtime maintains

00:18:10.000 --> 00:18:11.750
its stack is very different.

00:18:11.750 --> 00:18:15.030
In P and Q, we've actually
taught it about that.

00:18:15.030 --> 00:18:17.960
So this is the kind of
stack you'll get these days.

00:18:17.960 --> 00:18:20.630
It doesn't even matter whether
it's interpreted or jitted.

00:18:20.630 --> 00:18:22.190
We'll just do the right thing.

00:18:22.190 --> 00:18:25.250
We even have if you
have your own JIT,

00:18:25.250 --> 00:18:29.780
we actually use the same
kind of API behind the scenes

00:18:29.780 --> 00:18:32.320
that things like
GDB use for this.

00:18:32.320 --> 00:18:38.130
So you can actually tell us
about your own JITs as well.

00:18:38.130 --> 00:18:40.160
What can you do when you
have a good unwinder?

00:18:40.160 --> 00:18:44.570
Profiling is an obvious
thing that comes to mind.

00:18:44.570 --> 00:18:48.470
In NDK r13, we shipped a
thing called simpleperf.

00:18:48.470 --> 00:18:50.660
This is basically like
the Linux perf tool.

00:18:50.660 --> 00:18:53.725
It's a command line
tool you can use.

00:18:53.725 --> 00:18:55.100
It's useful, and
it was certainly

00:18:55.100 --> 00:18:56.930
useful for the OS people.

00:18:56.930 --> 00:18:58.490
Not so useful for
app developers,

00:18:58.490 --> 00:19:03.810
because you can't generally
run your app whenever you want.

00:19:03.810 --> 00:19:07.700
So one thing that we did
as a sort of stopgap was we

00:19:07.700 --> 00:19:12.000
added a tool to give you
HTML flame graphs that you

00:19:12.000 --> 00:19:13.250
could then see in the browser.

00:19:13.250 --> 00:19:15.890
But obviously, the real
aim was the GUI profiler.

00:19:15.890 --> 00:19:18.170
Hopefully you saw that.

00:19:18.170 --> 00:19:20.122
This was released in Studio 3.1.

00:19:20.122 --> 00:19:21.830
It was mentioned in
the Studio blog post.

00:19:21.830 --> 00:19:23.163
And hopefully you've tried that.

00:19:23.163 --> 00:19:25.160
If you haven't,
that might actually

00:19:25.160 --> 00:19:27.797
be worth switching to
Studio so you can try that.

00:19:27.797 --> 00:19:29.630
So this is what the
command line looks like.

00:19:29.630 --> 00:19:32.260
Basically the same-- if anyone's
familiar with the Linux perf

00:19:32.260 --> 00:19:34.100
tool, it's basically the same.

00:19:34.100 --> 00:19:37.330
This is the separate
record and report steps.

00:19:37.330 --> 00:19:39.080
We also support
annotation if you actually

00:19:39.080 --> 00:19:41.720
want to see right down
to the assembler level

00:19:41.720 --> 00:19:43.100
where was my code.

00:19:43.100 --> 00:19:45.530
You can connect to
existing processes.

00:19:45.530 --> 00:19:48.620
But again, the easiest way to
do that is just to use Studios.

00:19:48.620 --> 00:19:51.110
The Studio UI is the
picture in the foreground.

00:19:51.110 --> 00:19:55.220
Picture in the background is
the sort of HTML thing we have.

00:19:55.220 --> 00:19:59.270
So now we'll talk about some
of the things that people hit

00:19:59.270 --> 00:20:04.370
either when switching from
GCC to Clang or from gnustl

00:20:04.370 --> 00:20:09.710
to libc++, or just, in fact,
in terms of upgrading between

00:20:09.710 --> 00:20:13.140
different versions of the NDK.

00:20:13.140 --> 00:20:15.430
DAN ALBERT: So this
was a very common issue

00:20:15.430 --> 00:20:18.750
we saw when people were
updating to the unified headers.

00:20:18.750 --> 00:20:21.180
You would update, and
suddenly your code

00:20:21.180 --> 00:20:24.240
would no longer compile because
some function that really

00:20:24.240 --> 00:20:25.860
ought to be there was missing.

00:20:25.860 --> 00:20:29.710
Really common case for this
was mmap just disappeared.

00:20:29.710 --> 00:20:32.940
The reason for this was that
Bionic supports this feature

00:20:32.940 --> 00:20:34.230
called _FILE_OFFSET_BITS.

00:20:34.230 --> 00:20:36.510
It allows you to
specify that you

00:20:36.510 --> 00:20:39.330
want a 64-bit off_t so you
can deal with files larger

00:20:39.330 --> 00:20:41.700
than two gigabytes.

00:20:41.700 --> 00:20:44.730
This was a feature that
wasn't in older NDKs.

00:20:44.730 --> 00:20:47.910
So if you set _FILE_OFFSET_BITS
when you were using an older

00:20:47.910 --> 00:20:50.460
NDK, nothing happened.

00:20:50.460 --> 00:20:52.120
It failed silently.

00:20:52.120 --> 00:20:54.180
You got no indication
that nothing happened,

00:20:54.180 --> 00:20:55.800
and it moved on.

00:20:55.800 --> 00:20:58.420
When you then upgraded, you
were getting this feature.

00:20:58.420 --> 00:21:02.040
And if you asked for it before
it was actually available,

00:21:02.040 --> 00:21:03.990
your build would fail.

00:21:03.990 --> 00:21:06.870
Fortunately, the fix for
this is extremely easy.

00:21:06.870 --> 00:21:08.960
If all you want is
the old behavior back,

00:21:08.960 --> 00:21:11.100
grep through your project,
find the line that says

00:21:11.100 --> 00:21:12.330
_FILE_OFFSET_BITS.

00:21:12.330 --> 00:21:14.280
It'll be in either one
of your build scripts

00:21:14.280 --> 00:21:16.588
or possibly in one
of your source files.

00:21:16.588 --> 00:21:18.630
Just delete that line and
everything will be back

00:21:18.630 --> 00:21:19.410
to the way it was.

00:21:19.410 --> 00:21:22.300
If you do need a
large file support,

00:21:22.300 --> 00:21:25.463
the answer is a bit
more complicated.

00:21:25.463 --> 00:21:26.880
Essentially you
need to figure out

00:21:26.880 --> 00:21:28.710
what your min SDK
version is, what you're

00:21:28.710 --> 00:21:30.240
OK with your min
SDK version being,

00:21:30.240 --> 00:21:32.980
which subsets of
the APIs you need.

00:21:32.980 --> 00:21:35.040
Fortunately, this is
really well documented.

00:21:35.040 --> 00:21:36.480
The doc link there.

00:21:36.480 --> 00:21:38.100
You can search in
our bug tracker.

00:21:38.100 --> 00:21:39.450
If you have more
questions just file a bug.

00:21:39.450 --> 00:21:40.283
We're happy to help.

00:21:42.870 --> 00:21:44.570
ELLIOTT HUGHES: So
I think probably

00:21:44.570 --> 00:21:47.500
everyone who has native
code has seen this.

00:21:47.500 --> 00:21:50.570
You know, you run your
new version of your APK,

00:21:50.570 --> 00:21:53.710
you get an unsatisfied
link error.

00:21:53.710 --> 00:21:56.240
We had this ourselves
in the platform.

00:21:56.240 --> 00:22:00.845
So we have debugging
information in there-- click.

00:22:00.845 --> 00:22:03.220
If you set this property--
you don't need a rooted device

00:22:03.220 --> 00:22:04.637
for this, debug
properties you can

00:22:04.637 --> 00:22:07.120
set regardless--
you can actually

00:22:07.120 --> 00:22:11.410
turn on the full logging from
the dynamic linker itself.

00:22:11.410 --> 00:22:14.200
It'll tell you everything,
every file it considers,

00:22:14.200 --> 00:22:15.970
and it'll tell you
why it didn't open it.

00:22:15.970 --> 00:22:19.030
So rather than just this
short dlerror message

00:22:19.030 --> 00:22:21.640
that you get in the
unsatisfied link error,

00:22:21.640 --> 00:22:25.240
if you really want to see the
full information you can here.

00:22:25.240 --> 00:22:27.685
No example of this because
it is just far too verbose.

00:22:30.378 --> 00:22:32.420
DAN ALBERT: Another common
issue you'll run into,

00:22:32.420 --> 00:22:34.490
particularly while
updating to a new compiler

00:22:34.490 --> 00:22:38.335
or switching between different
types of compilers or even just

00:22:38.335 --> 00:22:39.710
to a new version
of the compiler,

00:22:39.710 --> 00:22:41.690
is undefined behavior.

00:22:41.690 --> 00:22:43.820
C++ is full of
undefined behavior.

00:22:43.820 --> 00:22:46.940
It's very exciting.

00:22:46.940 --> 00:22:49.627
This can just lead to all
sorts of surprising behaviors

00:22:49.627 --> 00:22:50.460
in your application.

00:22:50.460 --> 00:22:52.940
So fortunately, Clang gives
you a really good tool

00:22:52.940 --> 00:22:55.160
to try to sort out these issues.

00:22:55.160 --> 00:22:57.740
It's undefined
behavior sanitizer.

00:22:57.740 --> 00:22:59.840
Like with ASan, you can
enable this quite simply

00:22:59.840 --> 00:23:02.500
in your Android.mk.

00:23:02.500 --> 00:23:06.550
If you add these flags, instead
of just unpredictable behavior

00:23:06.550 --> 00:23:10.560
at runtime, you will get a
nice stack trace and a crash

00:23:10.560 --> 00:23:12.670
in logcat that explains
what went wrong

00:23:12.670 --> 00:23:14.720
and where it went wrong.

00:23:14.720 --> 00:23:18.100
This is also extremely useful
for a security conscious code.

00:23:18.100 --> 00:23:22.450
It is much better to just
stop and restart rather than

00:23:22.450 --> 00:23:28.120
continue into unpredictable
behavior for security reasons.

00:23:28.120 --> 00:23:31.510
We actually ship with this on in
the platform for some modules.

00:23:31.510 --> 00:23:34.510
Things like Stagefright, for
example, back in [INAUDIBLE] M,

00:23:34.510 --> 00:23:36.500
whenever that was.

00:23:36.500 --> 00:23:38.570
Undefined behavior
sanitizer was the only tool

00:23:38.570 --> 00:23:41.790
we had that could
actually catch that bug.

00:23:41.790 --> 00:23:48.703
And so we now keep
that on as a mitigation

00:23:48.703 --> 00:23:50.120
ELLIOTT HUGHES:
Right so one thing

00:23:50.120 --> 00:23:51.650
that also caused
trouble for people

00:23:51.650 --> 00:23:53.200
who were switching
from GCC to Clang

00:23:53.200 --> 00:23:56.600
is that Clang is a lot
fussier about assembler.

00:23:56.600 --> 00:23:59.515
This example, there are
four different instructions

00:23:59.515 --> 00:24:00.920
that that might be.

00:24:00.920 --> 00:24:03.860
It's probably obvious to a
human which one that they meant,

00:24:03.860 --> 00:24:05.710
but Clang refuses to guess.

00:24:05.710 --> 00:24:08.360
GCC would just guess.

00:24:08.360 --> 00:24:12.020
The workaround, if you don't
have time to work on this right

00:24:12.020 --> 00:24:14.120
now and you just want to
get on with your life.

00:24:14.120 --> 00:24:15.380
-fno-integrated-as.

00:24:15.380 --> 00:24:18.710
That lets you use the binutils
assembler behind the scenes

00:24:18.710 --> 00:24:20.900
so you'll get the
existing behavior.

00:24:20.900 --> 00:24:23.540
We actually moved forward and
fixed all of the ambiguities

00:24:23.540 --> 00:24:25.220
in our code.

00:24:25.220 --> 00:24:28.091
The easy trick for doing
that is just use [INAUDIBLE]..

00:24:30.372 --> 00:24:31.830
DAN ALBERT: Another
common problem.

00:24:31.830 --> 00:24:33.920
You will go and update your SDK.

00:24:33.920 --> 00:24:35.330
It will update the NDK with it.

00:24:35.330 --> 00:24:37.122
And now your build is
broken because you're

00:24:37.122 --> 00:24:40.100
Gradle plugin didn't upgrade.

00:24:40.100 --> 00:24:41.840
There are a handful
of assumptions

00:24:41.840 --> 00:24:43.640
that the Gradle plugin
will make about how

00:24:43.640 --> 00:24:45.130
the NDK is structured.

00:24:45.130 --> 00:24:49.340
We are doing everything we can
to remove those where possible.

00:24:49.340 --> 00:24:51.680
But fortunately, there's
another really easy fix

00:24:51.680 --> 00:24:53.000
for this problem.

00:24:53.000 --> 00:24:55.882
Out in beta earlier
today with Studio 3.5,

00:24:55.882 --> 00:24:57.590
you can actually
specify your NDK version

00:24:57.590 --> 00:25:00.530
in your build.gradle right
alongside your Gradle plugin

00:25:00.530 --> 00:25:01.370
version.

00:25:01.370 --> 00:25:03.360
That way these two things
remain in lockstep.

00:25:03.360 --> 00:25:04.777
You upgrade them
at the same time.

00:25:04.777 --> 00:25:06.290
Everything will be fine.

00:25:06.290 --> 00:25:08.810
Again, that is
Gradle 3.5 plugin.

00:25:08.810 --> 00:25:12.680
So you will need that first,
but from then on you're covered.

00:25:12.680 --> 00:25:15.860
This also lets you install
multiple versions of the NDK

00:25:15.860 --> 00:25:16.360
easily.

00:25:16.360 --> 00:25:18.110
So if you are working
on multiple projects

00:25:18.110 --> 00:25:20.480
and you need different versions
of the NDK for each one

00:25:20.480 --> 00:25:22.950
because the project
started at different times,

00:25:22.950 --> 00:25:24.380
that's now nice and easy to do.

00:25:27.620 --> 00:25:30.120
ELLIOTT HUGHES: So hopefully
you already read the blog posts

00:25:30.120 --> 00:25:31.980
that we've had over the
past couple of years

00:25:31.980 --> 00:25:35.100
about the move to 64-bit and
the requirement that everybody

00:25:35.100 --> 00:25:37.530
supports it.

00:25:37.530 --> 00:25:40.500
The main thing we
want to talk to you

00:25:40.500 --> 00:25:43.020
about today is just some tips.

00:25:43.020 --> 00:25:45.780
So we had this problem
back in Lollipop.

00:25:45.780 --> 00:25:48.720
Like my team, we basically
spent the entire year

00:25:48.720 --> 00:25:53.040
fixing all the code, all
the 32-bit assumptions.

00:25:53.040 --> 00:25:56.070
For those of you who are already
running the same code on iOS,

00:25:56.070 --> 00:25:56.820
you shouldn't have a problem.

00:25:56.820 --> 00:25:58.653
You've already been
through this transition.

00:25:58.653 --> 00:26:00.780
For those of you
aren't, the main thing

00:26:00.780 --> 00:26:06.080
that caused trouble
for us was JNI code.

00:26:06.080 --> 00:26:07.830
So places where you
have a Java class that

00:26:07.830 --> 00:26:09.720
has some kind of native peer.

00:26:09.720 --> 00:26:12.000
That was all using
jint for us, so we

00:26:12.000 --> 00:26:14.250
had to go through and
catch all of those.

00:26:14.250 --> 00:26:17.940
These warnings-- and this
actually turns these warnings

00:26:17.940 --> 00:26:20.280
on and then make them errors.

00:26:20.280 --> 00:26:24.780
This was completely necessary
for us to fix the platform.

00:26:24.780 --> 00:26:28.830
These catch places where
you're converting a 32-bit int

00:26:28.830 --> 00:26:31.110
to and from a pointer.

00:26:31.110 --> 00:26:33.060
A trickier one, a
less obvious one,

00:26:33.060 --> 00:26:35.610
is implicit function
declarations will hurt you

00:26:35.610 --> 00:26:36.990
as well.

00:26:36.990 --> 00:26:40.170
Because the old
K&amp;R assumption is

00:26:40.170 --> 00:26:42.660
that if you don't
tell the compiler what

00:26:42.660 --> 00:26:45.120
the type of a function
is, the assumption

00:26:45.120 --> 00:26:48.390
is that it returns int, which
means 32 bits, which means

00:26:48.390 --> 00:26:49.650
it'll truncate your pointer.

00:26:49.650 --> 00:26:53.550
So in this example, foo()
actually returns a char*.

00:26:53.550 --> 00:26:55.350
We didn't tell a compiler that.

00:26:55.350 --> 00:26:57.720
We ignored it's warning
about the implicit function

00:26:57.720 --> 00:26:59.670
declaration, and
it said, fine, I'll

00:26:59.670 --> 00:27:02.280
just drop those top 32 bits.

00:27:02.280 --> 00:27:04.447
And obviously, that
doesn't go well at runtime.

00:27:04.447 --> 00:27:06.780
So that's the thing to add
to your build if you actually

00:27:06.780 --> 00:27:09.820
want it, the compiler, to
just say, no, this is wrong,

00:27:09.820 --> 00:27:12.075
I'm not going to do that.

00:27:12.075 --> 00:27:14.200
So Dan's now going to talk
about some of the things

00:27:14.200 --> 00:27:17.610
that we're working on
for the near future.

00:27:17.610 --> 00:27:20.420
DAN ALBERT: So somewhat
short term on the roadmap,

00:27:20.420 --> 00:27:22.250
we are looking
into a new linker.

00:27:22.250 --> 00:27:25.160
Right now we have
bfd and we have gold.

00:27:25.160 --> 00:27:28.160
We are looking to
lld for the NDK.

00:27:28.160 --> 00:27:31.490
We are already using
lld for the platform.

00:27:31.490 --> 00:27:34.340
It, for one, is a lot faster.

00:27:34.340 --> 00:27:36.230
For something like
linking the Linux kernel,

00:27:36.230 --> 00:27:37.590
it is actually twice as fast.

00:27:37.590 --> 00:27:39.530
So instead of a three
minute link step,

00:27:39.530 --> 00:27:41.720
it is only a minute and a half.

00:27:41.720 --> 00:27:45.590
It is also a lot better at
detecting ODR violations

00:27:45.590 --> 00:27:47.060
and reporting them
in useful ways.

00:27:47.060 --> 00:27:49.430
If you've ever tried to
debug one of those with one

00:27:49.430 --> 00:27:52.883
of the other linkers,
it can be quite a pain.

00:27:52.883 --> 00:27:55.300
It's also got better support
for the newer Clang features.

00:27:55.300 --> 00:27:58.570
LTO will work better with lld.

00:27:58.570 --> 00:28:01.300
This is already in the NDK
as an experimental feature.

00:28:01.300 --> 00:28:03.430
It has been for a
release or two now.

00:28:03.430 --> 00:28:05.410
It's still got some
rough edges in the NDK,

00:28:05.410 --> 00:28:07.000
particularly on Windows.

00:28:07.000 --> 00:28:08.190
It doesn't always work.

00:28:08.190 --> 00:28:10.000
We are always working on this.

00:28:10.000 --> 00:28:15.440
I believe r21 will have
most of those issues fixed.

00:28:15.440 --> 00:28:18.280
However, other
cases it does work.

00:28:18.280 --> 00:28:20.110
Like I said, we are
using this for the OS

00:28:20.110 --> 00:28:22.970
so it does work in a
good number of cases.

00:28:22.970 --> 00:28:26.080
If you are not impacted by
any of the existing bugs

00:28:26.080 --> 00:28:29.350
and you do want your builds to
be faster, it is worth a shot.

00:28:29.350 --> 00:28:31.330
If you do encounter
bugs, please file them.

00:28:31.330 --> 00:28:34.010
This is still
quite early for us,

00:28:34.010 --> 00:28:36.040
which is why there is
no solid roadmap here.

00:28:36.040 --> 00:28:37.623
Normally we would
say, you know, we're

00:28:37.623 --> 00:28:39.910
going to make this the
default in this release

00:28:39.910 --> 00:28:41.410
and then remove it
and this release.

00:28:41.410 --> 00:28:44.330
We haven't made it
to that point yet.

00:28:44.330 --> 00:28:48.750
But please do try it
out if you get a chance.

00:28:48.750 --> 00:28:51.600
A larger task here
is making it easier

00:28:51.600 --> 00:28:55.020
to access third party libraries
in your NDK applications.

00:28:55.020 --> 00:28:58.852
We want something as simple as
just apt install openssl-dev.

00:28:58.852 --> 00:29:00.810
If you've ever tried
building that for Android,

00:29:00.810 --> 00:29:02.655
it is quite a hassle.

00:29:02.655 --> 00:29:04.780
It does not use any of our
supported build systems,

00:29:04.780 --> 00:29:07.380
so you have to make their
build system work with the NDK.

00:29:07.380 --> 00:29:10.540
It can be a hassle.

00:29:10.540 --> 00:29:13.680
So we are investigating
a number of options

00:29:13.680 --> 00:29:16.170
to make this easier for
you so you can just specify

00:29:16.170 --> 00:29:17.520
this in your build.gradle.

00:29:17.520 --> 00:29:21.000
My app depends on curl,
something like that.

00:29:21.000 --> 00:29:24.090
This is really early
for us right now.

00:29:24.090 --> 00:29:27.090
If you do have any
suggestions or there's

00:29:27.090 --> 00:29:29.370
a use case you think we're
not going to consider,

00:29:29.370 --> 00:29:30.150
there is a bug.

00:29:30.150 --> 00:29:34.410
It is linked from
our NDK GitHub page.

00:29:34.410 --> 00:29:36.220
Please go leave a comment there.

00:29:36.220 --> 00:29:38.310
We'd love to hear
from you on that.

00:29:38.310 --> 00:29:39.810
It is definitely
not too late for us

00:29:39.810 --> 00:29:43.510
to change our plans here.

00:29:43.510 --> 00:29:44.410
So yes.

00:29:44.410 --> 00:29:45.520
Help us help you.

00:29:45.520 --> 00:29:46.600
Try the OS betas.

00:29:46.600 --> 00:29:48.790
Try the NDK betas.

00:29:48.790 --> 00:29:50.500
Sooner you file
bugs, the more likely

00:29:50.500 --> 00:29:53.570
it is that we won't ship them.

00:29:53.570 --> 00:29:55.390
It is never fun
when you find out

00:29:55.390 --> 00:29:58.390
that the only thing you can do
is work around an existing bug

00:29:58.390 --> 00:30:01.120
because it is too
late to fix it.

00:30:01.120 --> 00:30:04.260
File bugs at our
GitHub bug tracker.

00:30:04.260 --> 00:30:05.123
Give feedback.

00:30:05.123 --> 00:30:06.790
Even if you just have
a question to ask,

00:30:06.790 --> 00:30:07.900
it's a good place to start.

00:30:07.900 --> 00:30:09.483
Worst thing that
will happen is I will

00:30:09.483 --> 00:30:12.380
close your bug with an answer.

00:30:12.380 --> 00:30:14.545
If you do have
questions you want

00:30:14.545 --> 00:30:15.920
to talk to us
about in person, we

00:30:15.920 --> 00:30:19.160
do have office hours
tomorrow morning at 8:30.

00:30:19.160 --> 00:30:21.470
If you are anything like me
and that sounds terrible,

00:30:21.470 --> 00:30:24.780
we will also be around
at 2:00 in the afternoon.

00:30:24.780 --> 00:30:27.990
And thank you for your time.

00:30:27.990 --> 00:30:30.090
[APPLAUSE]

00:30:30.990 --> 00:30:34.340
[MUSIC PLAYING]

