WEBVTT
Kind: captions
Language: en

00:00:03.340 --> 00:00:04.640
RYAN BOYD: Hello everyone.

00:00:04.640 --> 00:00:07.870
My name is Ryan Boyd and I'm a
Developer Advocate at Google

00:00:07.870 --> 00:00:11.300
focused on Google Apps and
the Apps Marketplace.

00:00:11.300 --> 00:00:15.180
But today, we're actually here
to talk about OpenID and OAuth

00:00:15.180 --> 00:00:18.780
and how they work for identity
and data access.

00:00:18.780 --> 00:00:20.430
If you have any questions
throughout the talk, you can

00:00:20.430 --> 00:00:21.260
save them for the end.

00:00:21.260 --> 00:00:23.430
We will have a Q&amp;A period.

00:00:23.430 --> 00:00:25.920
Of course, I'll also be around
the rest of the conference in

00:00:25.920 --> 00:00:29.080
between the sandbox and office
hours and things like that.

00:00:29.080 --> 00:00:31.480
And you can reach me online
via my Twiiter profile,

00:00:31.480 --> 00:00:35.510
ryguyrg and my Google profile
is linked there as well.

00:00:35.510 --> 00:00:39.540
And lastly, there's a feedback
link at the top right, which

00:00:39.540 --> 00:00:41.750
the box gets slightly cut
off on the screen.

00:00:41.750 --> 00:00:45.940
But you can record your feedback
there and that will

00:00:45.940 --> 00:00:50.020
be helpful for me to improve
the talk for the future.

00:00:50.020 --> 00:00:52.850
All right, so what are we
here to talk about?

00:00:52.850 --> 00:00:54.620
There's a number of items
on our agenda.

00:00:54.620 --> 00:00:58.900
But basically it breaks down
to talking about OpenID and

00:00:58.900 --> 00:01:00.350
talking about OAuth.

00:01:00.350 --> 00:01:02.840
And then talking about a couple
of different scenarios

00:01:02.840 --> 00:01:05.620
for each of those, including
how to handle mobile

00:01:05.620 --> 00:01:08.760
authentication as well how to
handle OAuth for businesses

00:01:08.760 --> 00:01:10.080
and organizations.

00:01:10.080 --> 00:01:12.590
And then we're going to talk a
little bit about the future of

00:01:12.590 --> 00:01:16.350
these technologies, and the
future is going to come quite

00:01:16.350 --> 00:01:19.820
quickly in this case.

00:01:19.820 --> 00:01:22.200
All right, terminology.

00:01:22.200 --> 00:01:25.710
Terminology is really key to
understanding these topics.

00:01:25.710 --> 00:01:28.680
I hope I don't bore you too much
by introducing new terms

00:01:28.680 --> 00:01:30.780
and describing them a couple
different ways.

00:01:30.780 --> 00:01:33.990
But that's what I'm
going to be doing.

00:01:33.990 --> 00:01:35.860
With each term I'm going to try
to talk about them in a

00:01:35.860 --> 00:01:38.530
real world use case, and then
try to talk about them in an

00:01:38.530 --> 00:01:40.200
online use case.

00:01:40.200 --> 00:01:45.050
And hopefully between those two,
you can get them because

00:01:45.050 --> 00:01:46.920
it'll really help
understanding.

00:01:46.920 --> 00:01:49.460
So the first term we're going
to talk about today is

00:01:49.460 --> 00:01:50.850
authentication.

00:01:50.850 --> 00:01:53.440
Authentication is about
verifying the identity of a

00:01:53.440 --> 00:01:58.090
user, knowing that the user
is who they say they are.

00:01:58.090 --> 00:02:00.910
In the case of Colonel Tom
visiting a top-secret military

00:02:00.910 --> 00:02:03.520
establishment, his identity
is verified using

00:02:03.520 --> 00:02:05.340
a scan of his eye.

00:02:05.340 --> 00:02:08.150
Then after his identity is
verified by the folks at the

00:02:08.150 --> 00:02:12.030
military base, they then need
to decide what Colonel Tom

00:02:12.030 --> 00:02:13.020
should have access to.

00:02:13.020 --> 00:02:16.560
In particular, what rooms on the
military base Colonel Tom

00:02:16.560 --> 00:02:18.030
should be able to go into.

00:02:18.030 --> 00:02:20.870
And that's what authorization is
all about, making sure that

00:02:20.870 --> 00:02:25.410
someone has the right access and
only the right access when

00:02:25.410 --> 00:02:28.430
they go to access
some resources.

00:02:28.430 --> 00:02:31.140
So in the online world,
let's meet Bob.

00:02:31.140 --> 00:02:32.540
Everyone say hi to Bob.

00:02:32.540 --> 00:02:33.860
Hi, Bob.

00:02:33.860 --> 00:02:35.960
All right, Bob, is an
Administrative Assistant at

00:02:35.960 --> 00:02:37.590
Acme Corporation.

00:02:37.590 --> 00:02:39.980
And Bob uses his computer
every single day.

00:02:39.980 --> 00:02:42.270
And the first thing Bob does
when he goes to his

00:02:42.270 --> 00:02:44.240
compute is log in.

00:02:44.240 --> 00:02:47.380
He types in a username
and a password.

00:02:47.380 --> 00:02:49.810
That gets sent off to the server
and the server says,

00:02:49.810 --> 00:02:53.100
hey, is this the correct
password for this username?

00:02:53.100 --> 00:02:56.050
And if so, the user is
considered authenticated.

00:02:56.050 --> 00:02:59.520
The server thinks that if this
person provided the right

00:02:59.520 --> 00:03:01.410
password for this account,
then it must in

00:03:01.410 --> 00:03:03.550
fact, be that person.

00:03:03.550 --> 00:03:07.870
Not always true as you guys
know, but that's the basics of

00:03:07.870 --> 00:03:11.630
authentication as it works
in most websites.

00:03:11.630 --> 00:03:14.320
But after the user's
authenticated, we need to

00:03:14.320 --> 00:03:16.730
figure out what access the user
should have. So in the

00:03:16.730 --> 00:03:21.240
case of this Acme Corporation,
we have Bob being able to

00:03:21.240 --> 00:03:24.920
access his own mail, but not
being able to access the mail

00:03:24.920 --> 00:03:28.460
of the other people in
the organization.

00:03:28.460 --> 00:03:31.200
So Bob is authenticated to his
Acme Corp account and has

00:03:31.200 --> 00:03:34.860
authorized access
to his mailbox.

00:03:34.860 --> 00:03:38.520
Now, to put these in context
for the presentation, for

00:03:38.520 --> 00:03:39.920
authentication we're going
to be primarily

00:03:39.920 --> 00:03:41.590
talking about OpenID.

00:03:41.590 --> 00:03:44.530
And when authenticating a user
using OpenID when they're

00:03:44.530 --> 00:03:46.260
visiting a website.

00:03:46.260 --> 00:03:48.310
And then for OAuth we're
primarily talking about

00:03:48.310 --> 00:03:52.780
getting authorized access to a
user's data, kind of delegated

00:03:52.780 --> 00:03:55.770
access to a user's data that
is stored elsewhere.

00:03:55.770 --> 00:03:57.020
In this case, at Google.

00:03:59.590 --> 00:04:03.230
So authenticating users via
OpenID, or authentication of

00:04:03.230 --> 00:04:04.250
users via OpenID.

00:04:04.250 --> 00:04:07.090
That's what I get for adding
slides at the last minute.

00:04:07.090 --> 00:04:09.070
OpenID terminology.

00:04:09.070 --> 00:04:11.630
So let's get into some
terms and first talk

00:04:11.630 --> 00:04:14.470
about identity providers.

00:04:14.470 --> 00:04:16.390
The most common identity
provider that you're probably

00:04:16.390 --> 00:04:18.740
familiar with is the Department
of Motor Vehicles.

00:04:18.740 --> 00:04:21.700
When you go there you prove
your identity to them, and

00:04:21.700 --> 00:04:23.570
they issue you a driver's
license.

00:04:23.570 --> 00:04:27.270
And that driver's license
says, hey, this is Tom.

00:04:27.270 --> 00:04:31.400
This is Tom's birthdate and
some other information.

00:04:31.400 --> 00:04:33.790
Now if you take that driver's
license, walk to your car, and

00:04:33.790 --> 00:04:37.190
speed out of the parking lot,
and get pulled over by a cop,

00:04:37.190 --> 00:04:39.920
that cop is what's called
a relying party.

00:04:39.920 --> 00:04:43.650
That cop is relying upon the
assertion of your identity by

00:04:43.650 --> 00:04:47.300
the identity provider in order
to write you a ticket.

00:04:47.300 --> 00:04:49.220
So he looks at the driver's
license and if the picture

00:04:49.220 --> 00:04:52.260
matches he says, this is Tom.

00:04:52.260 --> 00:04:53.200
This is his birthdate.

00:04:53.200 --> 00:04:55.170
This is his address,
et cetera.

00:04:55.170 --> 00:04:58.410
And he issues you the ticket.

00:04:58.410 --> 00:05:01.310
Now how does this work
in the online world?

00:05:01.310 --> 00:05:04.950
Let's give you an example of
federated identity in the

00:05:04.950 --> 00:05:08.230
online world and we'll
bring Bob back.

00:05:08.230 --> 00:05:10.190
So Bob is an Administrative
Assistant,

00:05:10.190 --> 00:05:11.400
but he's often traveling.

00:05:11.400 --> 00:05:15.570
He's on the road, rushing to
catch his next plane, and he

00:05:15.570 --> 00:05:17.820
doesn't always remember
where he's going next.

00:05:17.820 --> 00:05:20.490
So he stores his itineraries in
a travel planning service

00:05:20.490 --> 00:05:22.600
called TripIt.

00:05:22.600 --> 00:05:25.190
TripIt is basically a place you
can store your itineraries

00:05:25.190 --> 00:05:27.240
and share them with your
friends and colleagues.

00:05:27.240 --> 00:05:29.620
And he goes to TripIt, but he
doesn't want to have to create

00:05:29.620 --> 00:05:30.370
another account.

00:05:30.370 --> 00:05:32.790
He doesn't want to have to
create another password.

00:05:32.790 --> 00:05:35.260
So he goes to TripIt and he
says, TripIt, I want to use my

00:05:35.260 --> 00:05:38.200
Google account to log in.

00:05:38.200 --> 00:05:42.810
And TripIt says, OK, Google,
who is this guy?

00:05:42.810 --> 00:05:46.490
And Google returns and says,
hey, TripIt, this is Bob.

00:05:46.490 --> 00:05:50.050
So in this case, we have Bob as
the end user, TripIt as the

00:05:50.050 --> 00:05:52.925
relying party, and Google as
the identity provider.

00:05:56.080 --> 00:06:00.300
And we have success, the user is
authenticated to his TripIt

00:06:00.300 --> 00:06:02.990
account using his
Google identity.

00:06:02.990 --> 00:06:05.300
And most importantly, never
actually had to have a

00:06:05.300 --> 00:06:07.100
password on TripIt.

00:06:07.100 --> 00:06:10.280
Because Google is asserting
his identity to TripIt, he

00:06:10.280 --> 00:06:12.780
only necessarily had to have
a password at Google.

00:06:15.470 --> 00:06:18.010
So why do we care
about OpenID?

00:06:18.010 --> 00:06:20.200
We care about OpenID for a
number of different reasons.

00:06:20.200 --> 00:06:23.050
I'm going to go through
several of them here.

00:06:23.050 --> 00:06:27.100
But basically, users can log
in to all sites using their

00:06:27.100 --> 00:06:28.300
existing accounts.

00:06:28.300 --> 00:06:30.390
They don't have to create a new
account and new identities

00:06:30.390 --> 00:06:33.220
to log into websites.

00:06:33.220 --> 00:06:35.690
All right, so this is the quote
that's on the front page

00:06:35.690 --> 00:06:38.720
of openid.net, or was at
the time that I looked.

00:06:38.720 --> 00:06:42.850
"OpenID is a safe, faster, and
easier way to log in to

00:06:42.850 --> 00:06:43.980
websites."

00:06:43.980 --> 00:06:45.330
We're going to go through
each of these points.

00:06:45.330 --> 00:06:46.790
We're going to start with
faster and easier

00:06:46.790 --> 00:06:48.900
and get back to safe.

00:06:48.900 --> 00:06:50.180
But I truly believe in this.

00:06:50.180 --> 00:06:53.760
So faster and easier.

00:06:53.760 --> 00:06:56.740
Let's look at a traditional
signup process.

00:06:56.740 --> 00:06:59.340
So traditional signup process--
this is a fictitious

00:06:59.340 --> 00:07:01.470
app called SaaSy Payroll.

00:07:01.470 --> 00:07:02.550
Just a screen shot here.

00:07:02.550 --> 00:07:05.980
But this is a typical signup
process where you fill out

00:07:05.980 --> 00:07:08.530
your first name, last name,
e-mail address, provide a

00:07:08.530 --> 00:07:10.460
password, double enter
that password.

00:07:10.460 --> 00:07:12.730
And if you're like me, you often
typo that password when

00:07:12.730 --> 00:07:14.360
you double enter it.

00:07:14.360 --> 00:07:16.430
So this takes a little
bit of time.

00:07:16.430 --> 00:07:19.500
But you fill out this form,
and then you get an e-mail

00:07:19.500 --> 00:07:24.460
sent to you that confirms that
you have that e-mail address.

00:07:24.460 --> 00:07:28.320
And this whole process took
about 50 keystrokes and 3

00:07:28.320 --> 00:07:29.055
mouse click.

00:07:29.055 --> 00:07:31.350
Of course, if you have a more
complicated password, it may

00:07:31.350 --> 00:07:33.090
have taken you even more.

00:07:33.090 --> 00:07:34.950
But this is a really
bad process.

00:07:34.950 --> 00:07:37.960
This process make babies cry.

00:07:37.960 --> 00:07:39.380
And why are babies crying?

00:07:39.380 --> 00:07:43.390
Babies are crying because even
babies know that you can offer

00:07:43.390 --> 00:07:46.820
a better user experience for
signing up for a website.

00:07:46.820 --> 00:07:50.670
Even babies know or should
know about OpenID.

00:07:50.670 --> 00:07:52.400
And how you can offer
an improved user

00:07:52.400 --> 00:07:55.320
experience with OpenID.

00:07:55.320 --> 00:07:58.090
So let's take a look at that
same sort of process and see

00:07:58.090 --> 00:08:00.730
how that works in OpenID.

00:08:00.730 --> 00:08:03.260
This is the log in box
at one time on a

00:08:03.260 --> 00:08:04.850
website called Tungle.

00:08:04.850 --> 00:08:08.630
And they're presenting a variety
of different options

00:08:08.630 --> 00:08:11.690
for you to log in using an
existing account that you

00:08:11.690 --> 00:08:14.390
already have. These are a
variety of different identity

00:08:14.390 --> 00:08:18.350
providers and this is often
referred to as something like

00:08:18.350 --> 00:08:21.380
the OpenID NASCAR.

00:08:21.380 --> 00:08:23.650
That was a term someone else
came up with, but it's a good

00:08:23.650 --> 00:08:24.410
way to describe it.

00:08:24.410 --> 00:08:26.770
It's basically a bunch
of different logos.

00:08:26.770 --> 00:08:29.160
And in here you can choose from
one of the major identity

00:08:29.160 --> 00:08:32.090
providers to log in with.

00:08:32.090 --> 00:08:34.659
It doesn't actually provide the
option for you to log in

00:08:34.659 --> 00:08:37.066
with your own identity on your
own identity provider if

00:08:37.066 --> 00:08:38.559
you're a real geek.

00:08:38.559 --> 00:08:41.520
And that's unfortunate for
many people, but it is

00:08:41.520 --> 00:08:43.630
actually what you see
most often because

00:08:43.630 --> 00:08:45.660
it's easier for users.

00:08:45.660 --> 00:08:47.730
So they see this, and if you
have a Google account, you'd

00:08:47.730 --> 00:08:49.600
click on the Google button.

00:08:49.600 --> 00:08:51.800
You're already logged in to your
Google account so you get

00:08:51.800 --> 00:08:54.710
prompted, hey, would you like
to allow or deny access to

00:08:54.710 --> 00:08:56.430
your Google account?

00:08:56.430 --> 00:08:59.050
And you say, hey, I'm going
to allow access.

00:08:59.050 --> 00:09:00.620
And then you're signed
into the website.

00:09:00.620 --> 00:09:03.520
It was really that simple.

00:09:03.520 --> 00:09:08.450
This whole process was 0
keystrokes and 2 mouse clicks.

00:09:08.450 --> 00:09:10.170
This is making puppies happy.

00:09:10.170 --> 00:09:12.920
Now would you rather make puppy
happy than babies cry?

00:09:12.920 --> 00:09:14.620
Hopefully everyone.

00:09:14.620 --> 00:09:17.170
All right.

00:09:17.170 --> 00:09:18.240
This is what it's all about.

00:09:18.240 --> 00:09:22.830
It's basically making your users
happier and not making

00:09:22.830 --> 00:09:24.030
your babies cry.

00:09:24.030 --> 00:09:26.930
So now let's talk about safer.

00:09:26.930 --> 00:09:30.902
We've talked about faster and
easier, how is it safer?

00:09:30.902 --> 00:09:33.070
It's safer for a number
of different reasons.

00:09:33.070 --> 00:09:35.660
You have one username
and password.

00:09:35.660 --> 00:09:37.350
You don't have to create
username and passwords for

00:09:37.350 --> 00:09:38.110
every different site
you visit.

00:09:38.110 --> 00:09:39.720
You have one.

00:09:39.720 --> 00:09:42.405
Because you only have one that
password can be ultra- secure.

00:09:42.405 --> 00:09:45.300
It can be something that you
really are going to remember

00:09:45.300 --> 00:09:47.560
and you're going to remember
every single time that you go

00:09:47.560 --> 00:09:49.590
to enter it.

00:09:49.590 --> 00:09:56.110
My typical password is many
times the length of the eight

00:09:56.110 --> 00:09:58.810
character limitation that
sites give you.

00:09:58.810 --> 00:10:00.610
It always frustrates me when
I'm limited at eight

00:10:00.610 --> 00:10:03.960
characters because I want to
have an ultra-secure password.

00:10:03.960 --> 00:10:06.510
And I can have an ultra-secure
password because there's only

00:10:06.510 --> 00:10:10.720
a few places I actually
provide that password.

00:10:10.720 --> 00:10:13.440
The password is only provided
to the identity provider.

00:10:13.440 --> 00:10:16.250
Only the identity provider
ever sees that password.

00:10:16.250 --> 00:10:18.920
All these other sites, all the
other relying parties never

00:10:18.920 --> 00:10:20.890
see a password from you.

00:10:20.890 --> 00:10:25.220
This makes it definitely much
safer because most users--

00:10:25.220 --> 00:10:28.150
actually, how many of you reuse
the same password on

00:10:28.150 --> 00:10:30.350
multiple sites?

00:10:30.350 --> 00:10:32.210
See.

00:10:32.210 --> 00:10:35.590
It's very helpful to have that
one password provided to the

00:10:35.590 --> 00:10:38.230
identity provider and only
the identity provider.

00:10:38.230 --> 00:10:42.620
Now, in addition to having a
password, you can also have

00:10:42.620 --> 00:10:45.090
what's called two factor auth
and other protections.

00:10:45.090 --> 00:10:48.310
How many of you are familiar
with two factor auth?

00:10:48.310 --> 00:10:51.650
All right, so I don't have to
explain that to most of you.

00:10:51.650 --> 00:10:54.810
For those of you that don't
understand it, basically the

00:10:54.810 --> 00:10:58.040
idea is security is
done in layers.

00:10:58.040 --> 00:10:59.510
And one of those layers
is something

00:10:59.510 --> 00:11:01.250
you know, your password.

00:11:01.250 --> 00:11:04.380
Another layer might be something
that you are, which

00:11:04.380 --> 00:11:07.110
is like the eye scan
of Colonel Tom.

00:11:07.110 --> 00:11:10.280
But the last layer might be
something that you have.

00:11:10.280 --> 00:11:13.660
When I go to log into my typical
identity provider, I'm

00:11:13.660 --> 00:11:17.740
actually prompted to not enter
the password and only the

00:11:17.740 --> 00:11:20.560
password, but asked
to enter in a

00:11:20.560 --> 00:11:23.630
one-time password as well.

00:11:23.630 --> 00:11:25.810
The way Google has implemented
it mostly for external

00:11:25.810 --> 00:11:29.310
purposes is you get an SMS
message or you get a

00:11:29.310 --> 00:11:31.880
notification on your mobile
device and it proves that you

00:11:31.880 --> 00:11:34.160
have something in your
possession in addition to

00:11:34.160 --> 00:11:35.530
knowing the password.

00:11:35.530 --> 00:11:40.740
It makes it quite easy and also,
quite secure because

00:11:40.740 --> 00:11:42.940
only if you have that in your
possession and know the

00:11:42.940 --> 00:11:46.710
password are you able
to log into sites.

00:11:46.710 --> 00:11:48.800
All right, so safe,
faster, easier.

00:11:48.800 --> 00:11:51.660
Safer, user only provides
their one ultra-secure

00:11:51.660 --> 00:11:54.510
password to their identity
provider.

00:11:54.510 --> 00:11:57.200
And that ultra-secure password
could be backed up with

00:11:57.200 --> 00:11:58.790
something like two
factor auth.

00:11:58.790 --> 00:12:01.690
The user is often already logged
in to their identity

00:12:01.690 --> 00:12:04.730
provider, so it's super fast
as you saw earlier.

00:12:04.730 --> 00:12:06.560
And the user doesn't need
to create the other

00:12:06.560 --> 00:12:08.440
username and password.

00:12:08.440 --> 00:12:11.440
Now, this is how it's
safer, faster, and

00:12:11.440 --> 00:12:14.520
easier for your users.

00:12:14.520 --> 00:12:18.020
The next question though is,
how is it easier for you as

00:12:18.020 --> 00:12:20.070
developers?

00:12:20.070 --> 00:12:22.590
And we're going to talk a little
bit about becoming an

00:12:22.590 --> 00:12:25.220
OpenID relying party
and how this makes

00:12:25.220 --> 00:12:26.870
things easier for you.

00:12:26.870 --> 00:12:28.130
Or doesn't in some cases.

00:12:28.130 --> 00:12:31.510
But at least it makes it
easier for your users.

00:12:31.510 --> 00:12:34.410
All right, so I'm going
to assert that

00:12:34.410 --> 00:12:39.150
OpenID is easy to implement.

00:12:39.150 --> 00:12:40.940
Now, how many of you would
disagree with me?

00:12:40.940 --> 00:12:43.610
How many of you have looked
at this at all?

00:12:43.610 --> 00:12:45.600
All right, good.

00:12:45.600 --> 00:12:49.090
It's easy to implement, but
it's not easy enough.

00:12:49.090 --> 00:12:51.870
It's not easy enough because
there are a huge number of

00:12:51.870 --> 00:12:53.370
edge cases.

00:12:53.370 --> 00:12:56.830
Now I've worked with probably
a couple hundred OpenID

00:12:56.830 --> 00:12:59.230
replying parties over the last
couple of years on the Google

00:12:59.230 --> 00:13:03.800
Apps Marketplace and these edge
cases are things that a

00:13:03.800 --> 00:13:06.540
lot of people don't deal
with to start out with.

00:13:06.540 --> 00:13:09.500
These edge cases are things that
you can get by without

00:13:09.500 --> 00:13:13.160
implementing it first. You can
implement the basics of OpenID

00:13:13.160 --> 00:13:15.000
using OpenID libraries.

00:13:15.000 --> 00:13:17.070
There are a variety of different
libraries and

00:13:17.070 --> 00:13:21.900
different languages that you
can use and get by without

00:13:21.900 --> 00:13:24.090
implementing these edge cases.

00:13:24.090 --> 00:13:28.980
But if you do that, then your
customer support folks get the

00:13:28.980 --> 00:13:30.510
burden of the problem.

00:13:30.510 --> 00:13:33.640
And that's because there are
edge cases such as an existing

00:13:33.640 --> 00:13:38.100
user wants to switch to using
OpenID, or an OpenID user

00:13:38.100 --> 00:13:41.242
wants to switch back to
using a password.

00:13:41.242 --> 00:13:45.475
A user changes their e-mail
address, what do you do?

00:13:45.475 --> 00:13:48.800
And there's a link at the bottom
here where those are

00:13:48.800 --> 00:13:50.040
documented.

00:13:50.040 --> 00:13:53.120
But a variety of different edge
cases that most OpenID

00:13:53.120 --> 00:13:56.270
relying parties don't actually
implement, and then their

00:13:56.270 --> 00:13:58.470
customer support people
get angry.

00:13:58.470 --> 00:14:01.100
And the cost of them
implementing OpenID is

00:14:01.100 --> 00:14:02.710
actually more than the
benefit that they're

00:14:02.710 --> 00:14:04.080
achieving from it.

00:14:04.080 --> 00:14:05.910
So you kind of have to implement
these edge cases,

00:14:05.910 --> 00:14:08.570
and everyone will eventually
deal with them.

00:14:08.570 --> 00:14:10.240
But let's make it easier.

00:14:10.240 --> 00:14:12.570
Let's make it easier to
implement OpenID.

00:14:12.570 --> 00:14:15.220
Let's make it easier to become
a relying party.

00:14:15.220 --> 00:14:18.400
And we're going to do that by
introducing to you the Google

00:14:18.400 --> 00:14:20.520
Identity Toolkit.

00:14:20.520 --> 00:14:22.480
Now, what you're seeing
here probably

00:14:22.480 --> 00:14:24.570
doesn't what that exciting.

00:14:24.570 --> 00:14:26.890
You just see a username
and password.

00:14:26.890 --> 00:14:29.140
But you might see the second
tab over here that says

00:14:29.140 --> 00:14:31.740
connect with any account.

00:14:31.740 --> 00:14:33.930
And that connect with any
account tab has a couple of

00:14:33.930 --> 00:14:34.940
different options.

00:14:34.940 --> 00:14:39.880
Has Gmail, Yahoo, AOL, and
Hotmail is actually now on the

00:14:39.880 --> 00:14:43.860
official list. And this allows
you to log in using your

00:14:43.860 --> 00:14:48.070
existing identity, but with
less pain as developers.

00:14:48.070 --> 00:14:51.260
And it has less pain because we
provide a mixture of three

00:14:51.260 --> 00:14:56.740
components here: JavaScript UI
widgets, client libraries, and

00:14:56.740 --> 00:15:00.210
code on Google's servers to
actually make this process a

00:15:00.210 --> 00:15:02.650
lot easier for you
as developers.

00:15:02.650 --> 00:15:05.990
And it's easier for you, but
it's also more prescriptive.

00:15:05.990 --> 00:15:06.990
Basically we provide

00:15:06.990 --> 00:15:09.550
interfaces for you to implement.

00:15:09.550 --> 00:15:12.540
And if you implement those
interfaces, we actually are

00:15:12.540 --> 00:15:14.920
dealing with a lot of the
different edge cases that we

00:15:14.920 --> 00:15:16.650
talked about earlier.

00:15:16.650 --> 00:15:19.430
Now this project is just kind
of in testing currently.

00:15:19.430 --> 00:15:22.850
I will have at the end of the
presentation, some e-mail

00:15:22.850 --> 00:15:26.530
address and that sort of thing
that you can reach out to to

00:15:26.530 --> 00:15:29.500
get to test this project.

00:15:29.500 --> 00:15:31.950
But it should be
fully out soon.

00:15:31.950 --> 00:15:33.920
If you search for it right now
on the web I think you

00:15:33.920 --> 00:15:38.370
probably come to a website about
it, but again, more at

00:15:38.370 --> 00:15:41.410
the end of the presentation
in the resources section.

00:15:41.410 --> 00:15:44.270
Now the Google Identity Toolkit
supports two different

00:15:44.270 --> 00:15:46.430
flavors of OpenID.

00:15:46.430 --> 00:15:50.520
It supports using OpenID only
for signup, so that when users

00:15:50.520 --> 00:15:53.810
go to signup for your
application, you can sign them

00:15:53.810 --> 00:15:55.700
up using their existing
identities.

00:15:55.700 --> 00:15:58.130
And you get some special
information by that.

00:15:58.130 --> 00:16:00.530
You get their name, you got
their e-mail address.

00:16:00.530 --> 00:16:03.570
It basically prevents the user
from having to enter in some

00:16:03.570 --> 00:16:06.460
of the common information.

00:16:06.460 --> 00:16:09.230
And then you can authenticate
the users via password after

00:16:09.230 --> 00:16:10.040
you sign them up.

00:16:10.040 --> 00:16:13.380
Now, I personally don't like
this as you can imagine.

00:16:13.380 --> 00:16:17.590
I'd much rather you implement an
OpenID for signup and also

00:16:17.590 --> 00:16:19.830
for your day-to-day login.

00:16:19.830 --> 00:16:23.090
However, many websites aren't
comfortable with that, so we

00:16:23.090 --> 00:16:26.890
do offer both of these options
in the Google Identity Toolkit

00:16:26.890 --> 00:16:29.400
to be as flexible as possible.

00:16:29.400 --> 00:16:32.800
And then there are a variety
of different identity

00:16:32.800 --> 00:16:36.620
providers that you can use, and
I believe it's an option

00:16:36.620 --> 00:16:37.760
when you're configuring it.

00:16:37.760 --> 00:16:40.820
You can choose which of these
different identity

00:16:40.820 --> 00:16:43.520
providers to accept.

00:16:43.520 --> 00:16:47.380
All right, so now that we talked
about making it easier

00:16:47.380 --> 00:16:51.190
for you to implement OpenID
using the Google Identity

00:16:51.190 --> 00:16:54.340
Toolkit, let's show you what
it actually looks like.

00:16:54.340 --> 00:16:56.130
There's a quick video here.

00:16:56.130 --> 00:16:59.970
I say connect with any account,
I click on Gmail.

00:16:59.970 --> 00:17:01.340
A little pop-up occurs.

00:17:01.340 --> 00:17:03.550
I agree to pass on
that information.

00:17:03.550 --> 00:17:05.880
I say allow.

00:17:05.880 --> 00:17:08.540
And again, my name and
e-mail address.

00:17:08.540 --> 00:17:10.690
And then it's asking me for some
additional information in

00:17:10.690 --> 00:17:13.740
one of these example widgets.

00:17:13.740 --> 00:17:16.619
So the Google Identity Toolkit
makes it easier for you, as a

00:17:16.619 --> 00:17:19.339
web application developer,
to implement OpenID.

00:17:22.140 --> 00:17:24.430
With working with all these
different partners I have one

00:17:24.430 --> 00:17:27.220
question that keeps
on coming up.

00:17:27.220 --> 00:17:30.300
And that question is, when
users are logging into my

00:17:30.300 --> 00:17:33.310
website with OpenID, they
don't have a password.

00:17:33.310 --> 00:17:36.640
And when they don't have a
password, how can they use my

00:17:36.640 --> 00:17:38.470
mobile applications?

00:17:38.470 --> 00:17:40.520
So they have mobile
applications, native mobile

00:17:40.520 --> 00:17:44.070
applications, that exist on
iPhones and Androids and

00:17:44.070 --> 00:17:45.540
BlackBerrys.

00:17:45.540 --> 00:17:47.770
These native mobile apps
typically have a username and

00:17:47.770 --> 00:17:48.930
password field.

00:17:48.930 --> 00:17:50.870
And they don't need to know
how to authenticate their

00:17:50.870 --> 00:17:54.030
users that are authenticated
to their website

00:17:54.030 --> 00:17:55.280
with just an OpenID.

00:17:57.640 --> 00:18:01.200
And the problem here is that
they have code that may have

00:18:01.200 --> 00:18:04.000
been written by a contractor
or written by someone who's

00:18:04.000 --> 00:18:06.490
moved on to another project,
it's native code sitting on

00:18:06.490 --> 00:18:08.450
their devices.

00:18:08.450 --> 00:18:10.900
So how do they deal with that?

00:18:10.900 --> 00:18:15.380
One option is allow the users
to create a password.

00:18:18.480 --> 00:18:21.070
Now this isn't my favorite
option as you might imagine.

00:18:21.070 --> 00:18:24.380
But it's the easiest option
for developers.

00:18:24.380 --> 00:18:26.990
So all of these different
options are basically on the

00:18:26.990 --> 00:18:29.090
scale of is it easier
for developers or is

00:18:29.090 --> 00:18:30.710
it easier for users?

00:18:30.710 --> 00:18:32.860
Somewhere along the that scale,

00:18:32.860 --> 00:18:34.390
these options are fitting.

00:18:34.390 --> 00:18:35.700
This is kind of an
extreme end.

00:18:35.700 --> 00:18:39.470
It's really easy for developers
because they just

00:18:39.470 --> 00:18:42.520
need to add something in their
settings panel that allows the

00:18:42.520 --> 00:18:44.330
user to create a password.

00:18:44.330 --> 00:18:46.660
Concur is an application on
the Apps Marketplace and

00:18:46.660 --> 00:18:48.100
they've done exactly that.

00:18:48.100 --> 00:18:50.260
If you go to their settings
panel, you can choose to

00:18:50.260 --> 00:18:52.370
create a password and that
password's used to

00:18:52.370 --> 00:18:54.190
authenticate you in
the mobile device.

00:18:54.190 --> 00:18:56.700
But let's get a little
bit better.

00:18:56.700 --> 00:19:00.680
Let's not allow the users to
come up with a password and

00:19:00.680 --> 00:19:03.150
reuse the password that they
might have already used on

00:19:03.150 --> 00:19:04.530
many others sites.

00:19:04.530 --> 00:19:07.460
Let's generate a password that's
reasonably complex and

00:19:07.460 --> 00:19:09.330
give it to them.

00:19:09.330 --> 00:19:11.630
This is actually a screen shot
from one of the Google

00:19:11.630 --> 00:19:14.310
interfaces that if you're using
the two factor auth you

00:19:14.310 --> 00:19:16.150
have the ability to do this.

00:19:16.150 --> 00:19:18.360
You have the ability to go in
and say, I want to create a

00:19:18.360 --> 00:19:21.120
password for this particular
mobile app, or this particular

00:19:21.120 --> 00:19:22.920
website, or what have you.

00:19:22.920 --> 00:19:25.130
And it gives you a password.

00:19:25.130 --> 00:19:27.200
You only see that
password once.

00:19:27.200 --> 00:19:29.300
It's kind of assumed that that
mobile application is

00:19:29.300 --> 00:19:30.400
remembering your identity.

00:19:30.400 --> 00:19:34.020
Most mobile applications, once
you log into them, they assume

00:19:34.020 --> 00:19:36.110
that you're mobile phone is
fairly secure and don't make

00:19:36.110 --> 00:19:37.680
you log in on a regular basis.

00:19:37.680 --> 00:19:39.590
So this works OK for that.

00:19:39.590 --> 00:19:42.660
But the user still needs to go
and figure out where this is

00:19:42.660 --> 00:19:45.860
and get that password,
and enter it.

00:19:45.860 --> 00:19:48.540
So, OpenID.

00:19:48.540 --> 00:19:50.390
Did you all guess that that's
what I was going to talk about

00:19:50.390 --> 00:19:53.700
here as my favorite
way hopefully?

00:19:53.700 --> 00:19:57.430
OpenID is really my favorite
way to authenticate mobile

00:19:57.430 --> 00:20:00.120
devices and native mobile
applications.

00:20:00.120 --> 00:20:02.110
Now OpenID wasn't designed
for this.

00:20:02.110 --> 00:20:04.090
I'm not going to go out
and say, this was the

00:20:04.090 --> 00:20:05.340
whole point of OpenID.

00:20:05.340 --> 00:20:07.890
OpenID's really about
websites.

00:20:07.890 --> 00:20:13.730
But OpenID can work on native
applications and native mobile

00:20:13.730 --> 00:20:15.440
applications in particular.

00:20:15.440 --> 00:20:17.290
And so we're going to talk
about how that's done.

00:20:19.800 --> 00:20:22.780
So this is the TripIt
application on an Android.

00:20:22.780 --> 00:20:25.880
TripIt is the travel planning
service I mentioned earlier.

00:20:25.880 --> 00:20:28.220
Basically, they native mobile
applications on several

00:20:28.220 --> 00:20:32.010
different platforms. This is
their application on Android.

00:20:32.010 --> 00:20:36.140
So you click on the signup to
TripIt or sign in to TripIt.

00:20:36.140 --> 00:20:39.560
And basically, it pops up
a web page like this.

00:20:39.560 --> 00:20:43.760
This is popping up in a new
browser window outside of the

00:20:43.760 --> 00:20:45.440
application.

00:20:45.440 --> 00:20:49.580
And when this pops up, you
actually first get a thing to

00:20:49.580 --> 00:20:50.950
create a new account
for TripIt.

00:20:50.950 --> 00:20:52.250
I skipped that screen.

00:20:52.250 --> 00:20:53.410
This is about signing in.

00:20:53.410 --> 00:20:56.100
And you see the link at the
bottom that says sign in with

00:20:56.100 --> 00:20:57.100
your Google account?

00:20:57.100 --> 00:20:58.830
You click and sign
in with Google.

00:20:58.830 --> 00:21:01.420
And again, since you're already
logged into your

00:21:01.420 --> 00:21:06.070
account on your mobile device,
you're prompted just to allow.

00:21:06.070 --> 00:21:07.950
Now a little tip and trick for
those of you who go about

00:21:07.950 --> 00:21:09.230
implementing this.

00:21:09.230 --> 00:21:12.430
Some people will implement this
flow by using an embedded

00:21:12.430 --> 00:21:15.110
web browser in the
application.

00:21:15.110 --> 00:21:18.790
If you do that, that embedded
browser often has a different

00:21:18.790 --> 00:21:23.500
cookie store, cookie jar, than
your main web browser.

00:21:23.500 --> 00:21:25.910
So even if a user was logged
in in the main web browser,

00:21:25.910 --> 00:21:27.750
they'll have to log in again.

00:21:27.750 --> 00:21:30.580
That's why I much prefer the
flow of actually popping up

00:21:30.580 --> 00:21:32.980
the native browser on the device
and not trying to do an

00:21:32.980 --> 00:21:35.280
embedded web view.

00:21:35.280 --> 00:21:39.050
So I can just here allow,
click allow.

00:21:39.050 --> 00:21:39.870
And I'm in to TripIt.

00:21:39.870 --> 00:21:41.210
It's really that simple.

00:21:41.210 --> 00:21:44.080
So it's a four-step process.

00:21:44.080 --> 00:21:46.840
One, two, three, four
for the user.

00:21:46.840 --> 00:21:49.630
Like I said, OpenID's not
designed for the, so it can be

00:21:49.630 --> 00:21:52.290
a little bit tricky
for the developer.

00:21:52.290 --> 00:21:55.000
But for the user, it's
really simple.

00:21:55.000 --> 00:21:57.280
Some people still are concerned
about this pop-up

00:21:57.280 --> 00:22:00.930
web browser, but I would much
rather have the UI of having a

00:22:00.930 --> 00:22:04.550
web browser pop up than having
to enter my password on a

00:22:04.550 --> 00:22:07.870
mobile device with that
little thumb keyboard.

00:22:07.870 --> 00:22:09.300
This is how you can deal with

00:22:09.300 --> 00:22:11.940
authentication on mobile devices.

00:22:11.940 --> 00:22:13.940
If you have some questions
about how to deal with

00:22:13.940 --> 00:22:17.020
authorization, how to get access
to a user's calendar or

00:22:17.020 --> 00:22:20.110
contacts or something like that
on a mobile device, there

00:22:20.110 --> 00:22:22.990
was actually a session
yesterday, which you can catch

00:22:22.990 --> 00:22:26.990
hopefully tomorrow on YouTube.

00:22:26.990 --> 00:22:29.780
The session was called Client
Login Hashfail.

00:22:29.780 --> 00:22:33.170
And that session did go into a
little bit more detail about

00:22:33.170 --> 00:22:38.100
how to deal with using OAuth
from mobile devices.

00:22:38.100 --> 00:22:40.410
The other thing that they talked
about in that session

00:22:40.410 --> 00:22:43.980
is a little bit more of the
future of how this will work

00:22:43.980 --> 00:22:47.140
and how we can make it easier
for you as developers by

00:22:47.140 --> 00:22:51.670
essentially having a native
application on the device,

00:22:51.670 --> 00:22:55.370
which you, as developers, can
talk to to get the user's

00:22:55.370 --> 00:22:58.550
identity and access to their
data rather than having to go

00:22:58.550 --> 00:23:00.630
through the OpenID dance.

00:23:00.630 --> 00:23:03.960
So check out that session.

00:23:03.960 --> 00:23:07.210
Look for things happening
in the future there.

00:23:07.210 --> 00:23:09.770
But that's a really good
transition into getting

00:23:09.770 --> 00:23:12.820
authorized data access
via OAuth.

00:23:12.820 --> 00:23:14.730
Now OAuth is an open protocol.

00:23:14.730 --> 00:23:18.150
OAuth is an open protocol just
like OpenID, but its point is

00:23:18.150 --> 00:23:20.570
to get delegated and
authorized access

00:23:20.570 --> 00:23:22.910
from users to data.

00:23:22.910 --> 00:23:27.360
So you might ask why I
care or why you care.

00:23:27.360 --> 00:23:30.590
You care because there are a
bunch of different APIs out

00:23:30.590 --> 00:23:33.790
there that you can use to
get access to with this

00:23:33.790 --> 00:23:34.880
technology.

00:23:34.880 --> 00:23:38.220
There are 35 plus APIs
at Google that are

00:23:38.220 --> 00:23:40.276
authorized via OAuth.

00:23:40.276 --> 00:23:44.580
And these 35 plus APIs do a
variety of different things.

00:23:44.580 --> 00:23:48.230
And not only are there 35 plus
APIs at Google, but there are

00:23:48.230 --> 00:23:50.910
hundreds and hundreds of APIs
around the web that our

00:23:50.910 --> 00:23:53.250
authorized using OAuth.

00:23:53.250 --> 00:23:56.860
But really, what matters is what
those APIs provide your

00:23:56.860 --> 00:23:58.680
application.

00:23:58.680 --> 00:24:00.900
So those APIs at Google--

00:24:00.900 --> 00:24:04.680
I'm going to give you a couple
examples about the type of

00:24:04.680 --> 00:24:07.850
data that your app can
access using OAuth.

00:24:07.850 --> 00:24:09.350
The first one is contacts.

00:24:09.350 --> 00:24:11.100
Let's say you have a web
application and you want to

00:24:11.100 --> 00:24:16.020
allow users to invite other
users, their friends and that

00:24:16.020 --> 00:24:18.340
sort of thing, to your
application.

00:24:18.340 --> 00:24:21.880
And those users are storing that
data in Google Contacts.

00:24:21.880 --> 00:24:24.220
Well it's pretty simple for
you to use OAuth and get

00:24:24.220 --> 00:24:27.280
access to their data and pool a
feed of the user's contacts

00:24:27.280 --> 00:24:31.250
and allow them to send e-mails
to their friends inviting them

00:24:31.250 --> 00:24:33.930
to your website.

00:24:33.930 --> 00:24:36.310
Calendar.

00:24:36.310 --> 00:24:40.040
I'm sorry, your application
manages events in some way,

00:24:40.040 --> 00:24:43.000
and you want to allow the users
to add events to their

00:24:43.000 --> 00:24:45.300
own calendars because they use
Google Calendar on a regular

00:24:45.300 --> 00:24:48.360
basis and that's where they want
to store the history of

00:24:48.360 --> 00:24:51.710
all their events and keep track
of them in one place.

00:24:51.710 --> 00:24:54.080
You can use the Calendar API.

00:24:54.080 --> 00:24:57.920
Picasa Web Albums, YouTube, some
other cases where if you

00:24:57.920 --> 00:25:00.740
want to embed a user's photos
or get access to a user's

00:25:00.740 --> 00:25:04.520
videos, you could do all that
by getting authorized access

00:25:04.520 --> 00:25:06.770
with OAuth.

00:25:06.770 --> 00:25:09.410
And then the rest of it is
kind of read-only feeds.

00:25:09.410 --> 00:25:12.620
Most of these are based off
Atom Publishing Protocol.

00:25:12.620 --> 00:25:15.480
So once you get authorized
access with OAuth, you're

00:25:15.480 --> 00:25:18.510
reading in XML or Atom-based
feed using a

00:25:18.510 --> 00:25:20.970
standard rest scenario.

00:25:20.970 --> 00:25:26.440
So fairly simple, but why do you
need to learn this really

00:25:26.440 --> 00:25:30.690
fancy protocol in order to get
access to users' data?

00:25:30.690 --> 00:25:34.230
Why don't you just ask them
for their password?

00:25:34.230 --> 00:25:37.140
All right, you shouldn't ask
them for their password.

00:25:37.140 --> 00:25:40.620
But how many of you have seen
websites that look like this?

00:25:40.620 --> 00:25:43.600
Tell us your Gmail account, we
promise we won't tell anyone

00:25:43.600 --> 00:25:45.010
your password.

00:25:45.010 --> 00:25:47.460
You guys all seen this?

00:25:47.460 --> 00:25:51.380
Well it really irritates me
every time I see it because I

00:25:51.380 --> 00:25:53.500
know there's a better way and
the babies are out there

00:25:53.500 --> 00:25:57.810
crying because they know
there's a better way.

00:25:57.810 --> 00:26:00.820
You can access a user's data
with their password.

00:26:00.820 --> 00:26:01.970
That is correct.

00:26:01.970 --> 00:26:04.960
Right now, our APIs do allow
you to take the user's

00:26:04.960 --> 00:26:08.330
username and password and get
access to their data.

00:26:08.330 --> 00:26:13.890
But this is really bad because
the user is granting access to

00:26:13.890 --> 00:26:15.780
their entire account
at that point.

00:26:15.780 --> 00:26:18.380
They're not just granting access
to the one API or two

00:26:18.380 --> 00:26:21.210
APIs that your application
needs access to.

00:26:21.210 --> 00:26:23.970
They're granting access to
everything in their Google

00:26:23.970 --> 00:26:26.170
account, the whole world.

00:26:26.170 --> 00:26:30.780
You do not want that as a user
and you don't want to ask your

00:26:30.780 --> 00:26:32.720
users to do that
as a developer.

00:26:32.720 --> 00:26:36.170
Because the smart users will
stand back and say, no, no.

00:26:36.170 --> 00:26:38.540
I really don't want
to do that.

00:26:38.540 --> 00:26:43.700
And the dumb users will just
give you their password and

00:26:43.700 --> 00:26:45.620
you'll have a database
full of passwords.

00:26:45.620 --> 00:26:46.720
And that's just a really
bad thing.

00:26:46.720 --> 00:26:50.755
So don't put yourself in that
risk scenario as a user or as

00:26:50.755 --> 00:26:52.610
a developer.

00:26:52.610 --> 00:26:56.450
All right, so some terminology
with OAuth.

00:26:56.450 --> 00:26:57.820
We have a protected resource.

00:26:57.820 --> 00:27:00.510
This is the resource on
a server that requires

00:27:00.510 --> 00:27:02.870
authorization to access.

00:27:02.870 --> 00:27:05.360
We have the resource owner,
the person that owns the

00:27:05.360 --> 00:27:07.245
protected resource and
approves access.

00:27:09.850 --> 00:27:10.940
And then we have the server.

00:27:10.940 --> 00:27:13.750
The server is holding the
protected resource and

00:27:13.750 --> 00:27:17.370
deciding whether or not it
should grant access.

00:27:17.370 --> 00:27:18.380
And then the client.

00:27:18.380 --> 00:27:21.580
Again, we're going to use this
SaaSy Payroll example as a web

00:27:21.580 --> 00:27:25.020
application, which needs access
to data that's stored

00:27:25.020 --> 00:27:27.940
on the server.

00:27:27.940 --> 00:27:32.110
All right, so which flavor
of OAuth do you use?

00:27:32.110 --> 00:27:34.110
There's plenty of different
flavors at Google

00:27:34.110 --> 00:27:36.320
and at other providers.

00:27:36.320 --> 00:27:38.580
And what flavor of OAuth
you use depends on

00:27:38.580 --> 00:27:40.550
who owns the data.

00:27:40.550 --> 00:27:43.670
You can have individual
ownership of data where every

00:27:43.670 --> 00:27:47.570
user gets to decide, this is
my data, I'm going to grant

00:27:47.570 --> 00:27:49.510
this application access
to my data.

00:27:49.510 --> 00:27:52.450
And that user can make
that decision.

00:27:52.450 --> 00:27:56.290
But then you can also have
company owned resources.

00:27:56.290 --> 00:27:59.820
So think of something like,
you're in a very large company

00:27:59.820 --> 00:28:03.970
and that company has calendars,
for instance.

00:28:03.970 --> 00:28:05.980
You have your corporate
calendar.

00:28:05.980 --> 00:28:07.640
You might have some confidential
stuff on your

00:28:07.640 --> 00:28:08.640
corporate calendar.

00:28:08.640 --> 00:28:12.340
Your company does not trust
you to be the one deciding

00:28:12.340 --> 00:28:16.970
whether a third party app can
grant access or can get access

00:28:16.970 --> 00:28:18.410
to the calendar.

00:28:18.410 --> 00:28:20.920
So you have these IT guardians
that sit and make those

00:28:20.920 --> 00:28:23.040
decisions, evaluate the security
of apps, and that

00:28:23.040 --> 00:28:24.930
sort of thing.

00:28:24.930 --> 00:28:26.400
So we're going to go through
these two scenarios and the

00:28:26.400 --> 00:28:28.900
different flavors of OAuth that
are used in these two

00:28:28.900 --> 00:28:31.500
different flavors.

00:28:31.500 --> 00:28:33.880
So we're going to start off by
the individual grant case,

00:28:33.880 --> 00:28:37.160
where the individual
owns the resource.

00:28:37.160 --> 00:28:40.400
And I'm going to be somewhat
lazy here and use the

00:28:40.400 --> 00:28:43.330
application SaaSy Payroll
to demonstrate this.

00:28:43.330 --> 00:28:45.920
And why I say somewhat lazy is
because this is really an

00:28:45.920 --> 00:28:47.650
individual use case that
we're talking about.

00:28:47.650 --> 00:28:50.100
So let's imagine that we're at a
very small company of just a

00:28:50.100 --> 00:28:54.230
couple of employee, there's no
IT guardians to protect us.

00:28:54.230 --> 00:28:57.680
But we have this payroll
application and we want to

00:28:57.680 --> 00:29:00.870
allow this payroll application
to add our pay dates onto our

00:29:00.870 --> 00:29:02.350
Google Calendar.

00:29:02.350 --> 00:29:04.710
Again, we keep track of all
of our dates in our Google

00:29:04.710 --> 00:29:07.450
Calendar in one place and
we want to know when our

00:29:07.450 --> 00:29:09.750
payroll's coming up without
having to log in to the

00:29:09.750 --> 00:29:11.820
payroll app.

00:29:11.820 --> 00:29:13.100
So the payroll application
could look

00:29:13.100 --> 00:29:14.750
something like this.

00:29:14.750 --> 00:29:17.050
They give you your paycheck and
then at the bottom they

00:29:17.050 --> 00:29:20.173
have a link that allows
you to add your pay

00:29:20.173 --> 00:29:22.100
dates to your calendar.

00:29:22.100 --> 00:29:24.230
This pops up a screen that
looks like this.

00:29:24.230 --> 00:29:26.390
This is the OAuth 2 flow.

00:29:26.390 --> 00:29:29.740
And this screen basically says,
hey, this SaaSy Payroll

00:29:29.740 --> 00:29:32.170
application would like to manage
your calendar, view and

00:29:32.170 --> 00:29:33.630
manage the events on
your calendar.

00:29:33.630 --> 00:29:36.760
The user hits allow access and
all of a sudden, the app,

00:29:36.760 --> 00:29:42.640
after a little redirect dance,
can actually put the pay dates

00:29:42.640 --> 00:29:44.120
on your Google Calendar.

00:29:44.120 --> 00:29:46.040
So now you don't have to log
into Payroll each time you

00:29:46.040 --> 00:29:47.870
want to see when you get paid.

00:29:47.870 --> 00:29:50.320
Awesome.

00:29:50.320 --> 00:29:53.090
Now, let's talk about this in a
little more detail and what

00:29:53.090 --> 00:29:55.290
the technical flow is.

00:29:55.290 --> 00:29:59.800
And we're going to start off by
talking about this in the

00:29:59.800 --> 00:30:02.640
aspect of a developer going
to build an app

00:30:02.640 --> 00:30:04.260
for the first time.

00:30:04.260 --> 00:30:08.010
The developer has to actually
register their application and

00:30:08.010 --> 00:30:12.280
get a client ID client
secret from Google.

00:30:12.280 --> 00:30:14.750
And they go to a screen that
looks like this; Google says,

00:30:14.750 --> 00:30:17.190
here's your client ID
and client secret.

00:30:17.190 --> 00:30:19.720
And then the developer puts
that in their production

00:30:19.720 --> 00:30:23.660
infrastructure somewhere in a
secure fashion, so that when

00:30:23.660 --> 00:30:26.260
they make future requests
and the user visits the

00:30:26.260 --> 00:30:29.740
application, they have
access to that data.

00:30:29.740 --> 00:30:32.400
So now the user came to that web
page and said, I went to

00:30:32.400 --> 00:30:35.740
add my payroll dates to
my Google Calendar.

00:30:35.740 --> 00:30:38.950
And the web developer
does a few things in

00:30:38.950 --> 00:30:41.400
their code, of course.

00:30:41.400 --> 00:30:45.010
The application will redirect
the user over to Google and

00:30:45.010 --> 00:30:49.060
includes a client ID, includes
a redirect URI, which is the

00:30:49.060 --> 00:30:51.710
URI to redirect the
user back to after

00:30:51.710 --> 00:30:53.450
they're done this process.

00:30:53.450 --> 00:30:55.510
And includes a scope.

00:30:55.510 --> 00:30:59.230
The scope is basically what APIs
that this application is

00:30:59.230 --> 00:31:01.380
trying to get access to.

00:31:01.380 --> 00:31:04.620
At Google these scopes are often
in the form of URLs.

00:31:04.620 --> 00:31:06.420
They don't have to be.

00:31:06.420 --> 00:31:09.250
And you can actually include
multiple scopes at once.

00:31:09.250 --> 00:31:11.760
So we just asked for Calendar
here, but you could ask for

00:31:11.760 --> 00:31:14.060
Calendar and Contacts and
YouTube and that sort of thing

00:31:14.060 --> 00:31:16.530
all at one try.

00:31:16.530 --> 00:31:18.980
So the application redirects
user to Google with that

00:31:18.980 --> 00:31:20.650
information.

00:31:20.650 --> 00:31:22.050
There's luckily no
signatures or

00:31:22.050 --> 00:31:23.030
anything like that involved.

00:31:23.030 --> 00:31:24.240
It's just a clear
URL that you're

00:31:24.240 --> 00:31:26.430
redirecting the user to.

00:31:26.430 --> 00:31:32.270
And then Google redirects the
user back to the application,

00:31:32.270 --> 00:31:34.810
the redirect URI that
was specified.

00:31:34.810 --> 00:31:38.620
And includes a code
in that URL.

00:31:38.620 --> 00:31:40.840
And the URL looks something
like this.

00:31:40.840 --> 00:31:44.020
It's a URL on the application,
and then we have a code that

00:31:44.020 --> 00:31:46.770
says authorization code.

00:31:46.770 --> 00:31:50.340
And then the application
performs a post to Google.

00:31:50.340 --> 00:31:53.670
And in that post, it basically
includes it client ID and

00:31:53.670 --> 00:31:57.820
client secret, and also
includes that code.

00:31:57.820 --> 00:32:02.020
When it does this, Google looks
up and responds to that

00:32:02.020 --> 00:32:06.960
request by giving the
application two main things.

00:32:06.960 --> 00:32:09.390
The first is its access token.

00:32:09.390 --> 00:32:11.230
This is the token that
will be used to make

00:32:11.230 --> 00:32:11.990
requests to the API.

00:32:11.990 --> 00:32:14.710
And we're going to see how
that works shortly.

00:32:14.710 --> 00:32:18.540
And then the second main thing
is this refresh token.

00:32:18.540 --> 00:32:22.270
So the access token actually
expires once every 3,920

00:32:22.270 --> 00:32:24.130
seconds in this example.

00:32:24.130 --> 00:32:26.870
That can be a variable
number of course.

00:32:26.870 --> 00:32:29.790
And when that access token
expires, you need to go off

00:32:29.790 --> 00:32:32.700
and get another access token.

00:32:32.700 --> 00:32:35.450
And you can do that using
the refresh token.

00:32:35.450 --> 00:32:38.160
And this refresh token is
actually with Google in our

00:32:38.160 --> 00:32:41.740
current implementation, valid
indefinitely until the user

00:32:41.740 --> 00:32:43.010
revokes it.

00:32:43.010 --> 00:32:48.230
So either before or after the
token expires, you can use

00:32:48.230 --> 00:32:50.730
that refresh token
to renew access.

00:32:50.730 --> 00:32:53.270
And we're going to see how that
works here in a second.

00:32:53.270 --> 00:32:56.000
But first, let's take that
access token and actually make

00:32:56.000 --> 00:32:58.890
a call to the API.

00:32:58.890 --> 00:33:01.720
We're going to make that call
to the API specifying that

00:33:01.720 --> 00:33:04.400
access token in one
of two ways.

00:33:04.400 --> 00:33:08.320
You can specify it as a query
parameter in your request. So

00:33:08.320 --> 00:33:12.090
just in the URL you can say,
the OAuth token is this.

00:33:12.090 --> 00:33:15.020
Or you can specify
as a header.

00:33:15.020 --> 00:33:17.380
If you guys are going off and
making the decision, well,

00:33:17.380 --> 00:33:19.020
which one should I use?

00:33:19.020 --> 00:33:22.290
Please use the header in
most circumstances.

00:33:22.290 --> 00:33:25.510
I want you to use the header
because the header is often

00:33:25.510 --> 00:33:30.050
not logged in proxy server logs
or in your web server

00:33:30.050 --> 00:33:31.960
logs, or things like that.

00:33:31.960 --> 00:33:36.210
Although these tokens are just
valid for 3,920 seconds, it's

00:33:36.210 --> 00:33:39.740
still helpful for you to keep
that data out of the logs and

00:33:39.740 --> 00:33:43.410
will make your app a little
bit more secure.

00:33:43.410 --> 00:33:46.690
But that being said, the query
parameter is also really

00:33:46.690 --> 00:33:50.500
useful for debugging and the
query parameter is useful if

00:33:50.500 --> 00:33:52.730
you're writing JavaScript
applications.

00:33:52.730 --> 00:33:55.530
With this whole OAuth 2 flow,
you can write JavaScript

00:33:55.530 --> 00:33:59.340
applications pretty much
entirely within your browser

00:33:59.340 --> 00:34:02.260
and not have to have much
server side code.

00:34:02.260 --> 00:34:04.300
So that's helpful.

00:34:04.300 --> 00:34:06.750
We've made a call to
the protected API.

00:34:06.750 --> 00:34:09.290
We've waited a period of time.

00:34:09.290 --> 00:34:11.600
There are 3,920 seconds.

00:34:11.600 --> 00:34:14.730
And I think I skipped
something here.

00:34:14.730 --> 00:34:18.070
And we need to refresh
the access token.

00:34:18.070 --> 00:34:21.690
You can refresh that access
token, like I said, before or

00:34:21.690 --> 00:34:23.889
after the token has expired.

00:34:23.889 --> 00:34:26.300
So some applications might want
to say, I'm using this

00:34:26.300 --> 00:34:27.290
access a lot.

00:34:27.290 --> 00:34:30.010
The user's active in
their session.

00:34:30.010 --> 00:34:31.820
And it's been 3,800 seconds.

00:34:31.820 --> 00:34:34.310
Let me go off and refresh
the access

00:34:34.310 --> 00:34:36.310
token behind the scenes.

00:34:36.310 --> 00:34:39.020
Or you might want to say, we're
just going to wait until

00:34:39.020 --> 00:34:40.420
Google returns an error.

00:34:40.420 --> 00:34:42.420
And after Google returns an
error, we're going to try to

00:34:42.420 --> 00:34:43.440
refresh this.

00:34:43.440 --> 00:34:45.170
You can do either one.

00:34:45.170 --> 00:34:48.880
Basically, you're specifying the
client ID, client secret,

00:34:48.880 --> 00:34:50.810
and the refresh token.

00:34:50.810 --> 00:34:53.449
And Google will return an
access token to you.

00:34:53.449 --> 00:34:56.420
Pretty simple.

00:34:56.420 --> 00:34:58.535
So the whole flow works
something like this.

00:34:58.535 --> 00:35:02.390
The developer registers the
application at Google.

00:35:02.390 --> 00:35:03.735
The user visits the
application.

00:35:06.860 --> 00:35:10.185
The application asked the user
to authorize access at data--

00:35:10.185 --> 00:35:12.940
or access data at Google.

00:35:12.940 --> 00:35:15.370
The Google clicks that allow
button and says, I'm going to

00:35:15.370 --> 00:35:19.150
grant access to this
application.

00:35:19.150 --> 00:35:23.790
Google returns to the
application with the code.

00:35:23.790 --> 00:35:28.360
Then the application actually
requests an update--

00:35:28.360 --> 00:35:31.810
a access token from that code.

00:35:31.810 --> 00:35:34.460
And Google returns both
that access token

00:35:34.460 --> 00:35:35.850
and the refresh token.

00:35:35.850 --> 00:35:38.850
And again, the refresh token
is valid indefinitely, even

00:35:38.850 --> 00:35:41.910
though the access token's
expiring.

00:35:41.910 --> 00:35:44.320
Then the application can
actually access Google

00:35:44.320 --> 00:35:47.900
Calendar by specifying that
access token in either the URL

00:35:47.900 --> 00:35:49.860
or the query parameter.

00:35:49.860 --> 00:35:53.260
Google returns or updates
protected data.

00:35:53.260 --> 00:35:56.250
Sometime later, you have to go
through this renewal process

00:35:56.250 --> 00:36:00.840
by passing in the refresh token
and getting back a new

00:36:00.840 --> 00:36:03.010
access token.

00:36:03.010 --> 00:36:05.590
So this is a whole
OAuth 2 flow.

00:36:05.590 --> 00:36:07.800
I did not mention the word
signatures at all.

00:36:07.800 --> 00:36:09.850
For those of you who have dealt
with OAuth one, that's

00:36:09.850 --> 00:36:13.610
kind of one of the bigger
pain points of OAuth 1.

00:36:13.610 --> 00:36:15.950
But the next case that I'm going
to introduce to you is

00:36:15.950 --> 00:36:21.460
going to be the business
ownership of data.

00:36:21.460 --> 00:36:23.810
And with the business ownership
of data, we are

00:36:23.810 --> 00:36:27.610
going to be using a flavor of
OAuth 1, which has signatures.

00:36:27.610 --> 00:36:30.620
But hopefully, eventually that's
going to go away in

00:36:30.620 --> 00:36:34.190
favor of OAuth 2 based
protocols.

00:36:34.190 --> 00:36:37.140
So in the business scenario
this is going to be the

00:36:37.140 --> 00:36:38.410
company owning the resource.

00:36:38.410 --> 00:36:40.670
There's this team of IT
guardians who are protecting

00:36:40.670 --> 00:36:44.400
access to the data owned by a
company, and they want to

00:36:44.400 --> 00:36:46.200
grant access.

00:36:46.200 --> 00:36:48.860
And there's two different ways
that the company can grant

00:36:48.860 --> 00:36:50.330
access to data.

00:36:50.330 --> 00:36:53.330
And in these examples, the way
that we deal with companies at

00:36:53.330 --> 00:36:54.790
Google is via Google Apps.

00:36:54.790 --> 00:36:56.790
So these two examples are
going to be based off of

00:36:56.790 --> 00:36:58.100
Google Apps.

00:36:58.100 --> 00:37:01.450
And the first one is in the
Google Apps Control Panel.

00:37:01.450 --> 00:37:04.840
A company can grant an
application access to a

00:37:04.840 --> 00:37:09.360
particular API or scope as we
talked about earlier, via the

00:37:09.360 --> 00:37:13.380
Google Apps Control Panel by
specifying the name of their

00:37:13.380 --> 00:37:18.400
client and consumer key and
specifying the scope of data

00:37:18.400 --> 00:37:21.110
that it needs access to,
or multiple scopes.

00:37:21.110 --> 00:37:23.530
So this would basically be
saying, SaaSy Payroll can have

00:37:23.530 --> 00:37:25.630
access to Google Calendar.

00:37:25.630 --> 00:37:29.970
And once they authorize that
in the Business Edition or

00:37:29.970 --> 00:37:32.920
Education Edition of Google
Apps, once that's authorized

00:37:32.920 --> 00:37:36.920
that application now has access
to that API for every

00:37:36.920 --> 00:37:40.190
user within the organization.

00:37:40.190 --> 00:37:43.350
The other way is via the Google
Apps Marketplace.

00:37:43.350 --> 00:37:45.830
So an application that's
distributed on the Google Apps

00:37:45.830 --> 00:37:49.920
Marketplace can say, I need
access to Google Calendar in

00:37:49.920 --> 00:37:52.310
order for my application
to work.

00:37:52.310 --> 00:37:55.590
And when the IT administrator
installs that application from

00:37:55.590 --> 00:37:59.720
the Apps Marketplace, they can
grant access to that data in

00:37:59.720 --> 00:38:02.560
that one step during the
install process.

00:38:02.560 --> 00:38:04.510
It's a very simple flow.

00:38:04.510 --> 00:38:06.890
Makes it a lot easier than
copying and pasting scopes and

00:38:06.890 --> 00:38:09.380
that sort of thing.

00:38:09.380 --> 00:38:13.500
So after they do that because
the application has access to

00:38:13.500 --> 00:38:15.810
every user within the
organization--

00:38:15.810 --> 00:38:17.440
their Calendar, their
Contacts, and

00:38:17.440 --> 00:38:18.670
that sort of thing--

00:38:18.670 --> 00:38:22.160
then SaaSy Payroll could not
only update my calendar, but

00:38:22.160 --> 00:38:25.290
can also update the calendar
of everyone else within the

00:38:25.290 --> 00:38:28.720
organization with their payroll
dates without those

00:38:28.720 --> 00:38:31.850
users ever having to
actively log in.

00:38:31.850 --> 00:38:34.360
So remember, the administrator
gave them permission to do

00:38:34.360 --> 00:38:37.470
this, and then they can go off
in the background and update

00:38:37.470 --> 00:38:39.430
all these different calendars.

00:38:39.430 --> 00:38:42.300
And I may never actually have to
see the payroll application

00:38:42.300 --> 00:38:46.000
because I know when I'm
going to get paid.

00:38:46.000 --> 00:38:47.760
So let's go through what
this looks like

00:38:47.760 --> 00:38:50.380
from a technical basis.

00:38:50.380 --> 00:38:51.720
There's the first step here.

00:38:51.720 --> 00:38:54.300
It actually is split into two,
depending on whether you're an

00:38:54.300 --> 00:38:57.410
Apps Marketplace application or
whether you're just trying

00:38:57.410 --> 00:38:59.620
to get access in the
Control Panel.

00:38:59.620 --> 00:39:03.090
The one I'm showing here is the
screen of where you need

00:39:03.090 --> 00:39:06.880
to go register as a developer
if you just want the

00:39:06.880 --> 00:39:09.420
administrators to grant
access in the Google

00:39:09.420 --> 00:39:11.090
Apps Control Panel.

00:39:11.090 --> 00:39:15.050
This is the OAuth 1 standard
registration page linked to

00:39:15.050 --> 00:39:16.700
from our documentation,
which I'll refer to at

00:39:16.700 --> 00:39:17.810
the end of the talk.

00:39:17.810 --> 00:39:20.280
But this standard authorization
page, or

00:39:20.280 --> 00:39:23.070
registration page, will give
you this OAuth consumer key

00:39:23.070 --> 00:39:24.260
and secret.

00:39:24.260 --> 00:39:26.710
If you're an Apps Marketplace
app, it's a very similar

00:39:26.710 --> 00:39:29.970
process in that you go and
register your application, but

00:39:29.970 --> 00:39:32.770
Google actually gives you the
consumer key and consumer

00:39:32.770 --> 00:39:34.240
secret at the time that
you register.

00:39:37.310 --> 00:39:40.120
So you've registered, the
administrator grants access in

00:39:40.120 --> 00:39:42.140
one of those two different ways
that we talked about.

00:39:44.910 --> 00:39:47.530
And then you start
to make requests.

00:39:47.530 --> 00:39:50.100
And you make requests
by including an

00:39:50.100 --> 00:39:51.770
authorization header.

00:39:51.770 --> 00:39:54.810
So that's the part that's kind
of similar to before.

00:39:54.810 --> 00:39:57.950
There's an authorization header
in your HTTP request.

00:39:57.950 --> 00:40:01.440
It references the key for
the application and also

00:40:01.440 --> 00:40:04.030
references a couple other
bits of data.

00:40:04.030 --> 00:40:06.950
If you're using OAuth 1, I would
definitely recommend you

00:40:06.950 --> 00:40:10.230
use some library that
implements OAuth 1.

00:40:10.230 --> 00:40:12.940
Google has a variety of
libraries for it.

00:40:12.940 --> 00:40:15.520
OAuth 2, the stuff that we
talked about before because

00:40:15.520 --> 00:40:17.980
there's no signatures, that sort
of thing, you're actually

00:40:17.980 --> 00:40:20.290
able to pretty easily
write your own code

00:40:20.290 --> 00:40:22.710
that handles that.

00:40:22.710 --> 00:40:25.200
I did that kind of in less than
an hour accessing several

00:40:25.200 --> 00:40:27.610
different APIs using OAuth 2.

00:40:27.610 --> 00:40:28.300
That's fine.

00:40:28.300 --> 00:40:31.070
But with OAuth 1, you will
want some sort of library

00:40:31.070 --> 00:40:33.150
because you need to generate
these cryptographic

00:40:33.150 --> 00:40:34.020
signatures.

00:40:34.020 --> 00:40:36.190
And these cryptographic
signatures are based off of a

00:40:36.190 --> 00:40:36.580
[INAUDIBLE],

00:40:36.580 --> 00:40:39.120
a time stamp, your consumer
secret, and

00:40:39.120 --> 00:40:41.510
that sort of thing.

00:40:41.510 --> 00:40:43.750
But let's assume you have this
library generating this

00:40:43.750 --> 00:40:46.220
authorization header for you,
and you're accessing the

00:40:46.220 --> 00:40:47.870
Calendar API.

00:40:47.870 --> 00:40:50.770
The other thing that you need
to do is specify on whose

00:40:50.770 --> 00:40:53.390
behalf you're accessing
the Calendar API.

00:40:53.390 --> 00:40:55.920
So if you remembered inside
the organization that we

00:40:55.920 --> 00:40:59.120
talked about with SaaSy Payroll,
we had Ryan, Tim,

00:40:59.120 --> 00:41:01.870
Scott, a variety of
different users.

00:41:01.870 --> 00:41:05.590
For each user, you need to
specify their e-mail address

00:41:05.590 --> 00:41:08.720
as the xoauth requestor to ID
when you're making the request

00:41:08.720 --> 00:41:09.770
to the API.

00:41:09.770 --> 00:41:11.890
And that's how you do it.

00:41:11.890 --> 00:41:14.910
Fairly simple, as long as you
have that library backed up

00:41:14.910 --> 00:41:19.910
and helping you out with that
authorization header.

00:41:19.910 --> 00:41:21.160
So here's the general flow.

00:41:21.160 --> 00:41:23.630
The developer registers
the application.

00:41:23.630 --> 00:41:29.510
The admin visits the Google and
authorizes the application

00:41:29.510 --> 00:41:31.230
in the Control Panel.

00:41:31.230 --> 00:41:33.460
And then the application--

00:41:33.460 --> 00:41:35.270
somehow or another I messed
up my transitions here.

00:41:35.270 --> 00:41:38.340
But the application then
accesses Google Calendar by

00:41:38.340 --> 00:41:42.110
specifying that xoauth
requester ID header.

00:41:42.110 --> 00:41:44.750
xoauth requstor ID sorry,
as a query parameter.

00:41:44.750 --> 00:41:47.790
And then an authorization
header with a signature.

00:41:47.790 --> 00:41:51.020
And Google returns or updates
the protected data.

00:41:51.020 --> 00:41:53.350
Then they can go through and
access that data for another

00:41:53.350 --> 00:41:56.350
user by just specifying a
different xoauth requestor ID.

00:42:00.520 --> 00:42:02.130
So we talked about a number
of different things.

00:42:02.130 --> 00:42:04.710
We talked about general
terminology for authentication

00:42:04.710 --> 00:42:06.410
and authorization.

00:42:06.410 --> 00:42:09.490
Then we talked about OpenID
authentication, mobile

00:42:09.490 --> 00:42:13.480
authentication, and how to use
OAuth in two different areas.

00:42:13.480 --> 00:42:20.320
First, using OAuth and this is
OAuth 2, or 2.0, for accessing

00:42:20.320 --> 00:42:21.910
individual users' data.

00:42:21.910 --> 00:42:26.340
And then we talked about using
OAuth 1, the two-legged flow

00:42:26.340 --> 00:42:29.830
for accessing data that's
authorized by businesses.

00:42:32.390 --> 00:42:35.480
Now what's the future
look like?

00:42:35.480 --> 00:42:37.920
The future is all
about having one

00:42:37.920 --> 00:42:40.720
protocol for all use cases.

00:42:40.720 --> 00:42:45.090
You want a single protocol to
handle both authentication and

00:42:45.090 --> 00:42:47.560
authorization.

00:42:47.560 --> 00:42:50.050
You're all probably thinking,
why do we have both this

00:42:50.050 --> 00:42:52.220
OpenID and this OAuth thing?

00:42:52.220 --> 00:42:55.090
Really, we can eliminate
one of them.

00:42:55.090 --> 00:42:58.420
And we can eliminate one of them
because the process is

00:42:58.420 --> 00:43:00.780
essentially the same.

00:43:00.780 --> 00:43:03.640
If you look at this page, this
page was copied kind of from

00:43:03.640 --> 00:43:06.330
the OAuth 2 flow for an
individual user granting

00:43:06.330 --> 00:43:09.890
access to their calendar, and
I've modified it a little bit

00:43:09.890 --> 00:43:12.500
to say, this application
would like access

00:43:12.500 --> 00:43:14.440
to your Google identity.

00:43:14.440 --> 00:43:18.420
And they'd like to view your
e-mail address and name.

00:43:18.420 --> 00:43:20.910
So instead of granting the
application access to your

00:43:20.910 --> 00:43:24.520
Calendar data, it's just
granting access to your

00:43:24.520 --> 00:43:26.570
identity and that information.

00:43:26.570 --> 00:43:30.280
So essentially it's using OAuth
2 to get access to your

00:43:30.280 --> 00:43:34.280
identity and use OAuth 2 for
authentication in addition to

00:43:34.280 --> 00:43:35.560
authorization.

00:43:35.560 --> 00:43:38.120
Now there's certainly some
different guarantees between

00:43:38.120 --> 00:43:42.540
the clients and servers going
on here about what needs to

00:43:42.540 --> 00:43:45.100
happen when you're getting
access to a calendar versus

00:43:45.100 --> 00:43:47.680
what needs to happen when
you're getting access to

00:43:47.680 --> 00:43:49.200
someone's identity.

00:43:49.200 --> 00:43:51.630
But the flow and what it
looks like to users

00:43:51.630 --> 00:43:54.060
is mostly the same.

00:43:54.060 --> 00:43:57.710
So this has actually been
proposed as a project called

00:43:57.710 --> 00:44:00.160
OpenID Connect.

00:44:00.160 --> 00:44:04.200
And I don't know exactly what
our timeline is as Google to

00:44:04.200 --> 00:44:06.030
implement something like that.

00:44:06.030 --> 00:44:08.430
But this is really where we
see the future going.

00:44:08.430 --> 00:44:12.410
We see the future as the ability
to use OAuth to get

00:44:12.410 --> 00:44:15.570
access not only to a user's
data, like their calendar or

00:44:15.570 --> 00:44:16.910
their contacts.

00:44:16.910 --> 00:44:19.660
But also to get access
to their identity.

00:44:19.660 --> 00:44:22.440
So you, as developers, don't
need to deal with the

00:44:22.440 --> 00:44:25.010
complicated issues
of signatures and

00:44:25.010 --> 00:44:26.560
that sort of thing.

00:44:26.560 --> 00:44:29.290
There will still be some things
for discovery when

00:44:29.290 --> 00:44:31.280
we're talking about
authentication.

00:44:31.280 --> 00:44:33.220
Basically figuring
out who a user's

00:44:33.220 --> 00:44:35.630
authentication provider is.

00:44:35.630 --> 00:44:39.360
But overall, this should make
it a lot easier for getting

00:44:39.360 --> 00:44:42.820
access to a user's identity and
getting access to their

00:44:42.820 --> 00:44:47.440
data by learning only
a single protocol.

00:44:47.440 --> 00:44:50.280
So a variety of different
resources that you have here.

00:44:50.280 --> 00:44:53.730
The Google Identity Toolkit,
which I talked about earlier,

00:44:53.730 --> 00:44:56.790
is basically that toolkit to
make it a lot easier to do

00:44:56.790 --> 00:44:58.620
OpenID authentication.

00:44:58.620 --> 00:45:00.670
And there's someone's
e-mail address.

00:45:00.670 --> 00:45:02.320
They were brave enough
to put that up there,

00:45:02.320 --> 00:45:04.580
please don't spam them.

00:45:04.580 --> 00:45:07.320
But if you are interested in
using the Google Identity

00:45:07.320 --> 00:45:10.390
Toolkit and trying it out
on your website, contact

00:45:10.390 --> 00:45:14.120
esachs@google.com and
he can hook you up.

00:45:14.120 --> 00:45:16.120
And then there's some links
for various other

00:45:16.120 --> 00:45:17.360
documentation.

00:45:17.360 --> 00:45:21.510
Google has one main site for
all of our all auth docs.

00:45:21.510 --> 00:45:24.475
And then there's also the
OAuth playground there.

00:45:24.475 --> 00:45:29.210
It's using OAuth 1, so it's a
little bit different flow for

00:45:29.210 --> 00:45:30.530
the individual case.

00:45:30.530 --> 00:45:33.340
But it's a very helpful tool to
learn some of this and to

00:45:33.340 --> 00:45:35.970
try out our various APIs.

00:45:35.970 --> 00:45:37.880
And then, as I mentioned
earlier, there's a client

00:45:37.880 --> 00:45:40.530
login fail session that
happened yesterday.

00:45:40.530 --> 00:45:42.540
Catch up on that on YouTube.

00:45:42.540 --> 00:45:45.790
And you can reach me via
Twitter at ryguyrg.

00:45:45.790 --> 00:45:48.410
And of course, if you have any
feedback on this session,

00:45:48.410 --> 00:45:52.470
please submit it in that
feedback link below.

00:45:52.470 --> 00:45:55.650
Now it's time for Q&amp;A.

00:45:55.650 --> 00:45:56.750
Questions?

00:45:56.750 --> 00:45:58.800
There are microphones.

00:45:58.800 --> 00:46:02.872
Looks like someone's already
standing so, go for it.

00:46:02.872 --> 00:46:04.280
AUDIENCE: I have a question.

00:46:04.280 --> 00:46:07.460
On the enterprise side, it looks
like it's pretty good.

00:46:07.460 --> 00:46:09.510
You know, I have somebody else
making a decision for me.

00:46:09.510 --> 00:46:12.450
But when I'm using Google
personally right now, I'm

00:46:12.450 --> 00:46:14.940
trying to store information
on there.

00:46:14.940 --> 00:46:17.670
Always worried about still
using open auth and

00:46:17.670 --> 00:46:18.000
everything.

00:46:18.000 --> 00:46:20.185
And that's because there's no
granular level of access.

00:46:20.185 --> 00:46:22.970
If somebody has access to my
documents, there's everything.

00:46:22.970 --> 00:46:24.300
It's just open.

00:46:24.300 --> 00:46:26.550
My calendar, they got access
to all my calendars.

00:46:26.550 --> 00:46:31.000
Is there a thought about
creating silos where the

00:46:31.000 --> 00:46:33.650
interested party can only have
access to a certain calendar

00:46:33.650 --> 00:46:35.300
or a certain folders
in a document?

00:46:35.300 --> 00:46:36.190
That's one question.

00:46:36.190 --> 00:46:39.450
Just kind of going back on it
also, I'd like to know when

00:46:39.450 --> 00:46:41.760
they pull data from my calendar,
how often they do

00:46:41.760 --> 00:46:44.300
that, and where do they
store the data?

00:46:44.300 --> 00:46:48.780
So that I can be knowledgeable
of what they're doing with it.

00:46:48.780 --> 00:46:49.930
Those two concerns there.

00:46:49.930 --> 00:46:51.730
RYAN BOYD: So yeah, two
basic questions.

00:46:51.730 --> 00:46:55.230
First was about more granular
level of access.

00:46:55.230 --> 00:46:58.270
And yes, it's definitely
something that we're looking

00:46:58.270 --> 00:47:02.590
at and we've implemented for a
couple newer APIs, the ability

00:47:02.590 --> 00:47:04.490
to get access.

00:47:04.490 --> 00:47:07.390
First of all, just kind of as
a read-only way versus a

00:47:07.390 --> 00:47:09.160
read-write fashion.

00:47:09.160 --> 00:47:12.220
But then we're also looking at
say, access to things like an

00:47:12.220 --> 00:47:15.180
individual Google Doc, or
individual Google Calendar.

00:47:15.180 --> 00:47:16.620
Definitely looking
at all that.

00:47:16.620 --> 00:47:19.040
And the second was
on audit ability.

00:47:19.040 --> 00:47:19.980
I agree with you.

00:47:19.980 --> 00:47:21.210
That's all I'm going
to say on that.

00:47:21.210 --> 00:47:22.660
But I agree with you and
it'd be nice to be

00:47:22.660 --> 00:47:23.910
able to see that data.

00:47:26.080 --> 00:47:28.755
AUDIENCE: On the OpenID part
of your presentation, how

00:47:28.755 --> 00:47:33.694
would OpenID work if you have a
Google Apps account and your

00:47:33.694 --> 00:47:37.953
Gmail account and your OpenId is
more on the Gmail side and

00:47:37.953 --> 00:47:40.382
you are working on your
Google Apps account.

00:47:40.382 --> 00:47:41.830
Cookie-wise, it's
going to be--

00:47:41.830 --> 00:47:45.220
RYAN BOYD: Yeah, so Google
has a couple of

00:47:45.220 --> 00:47:47.870
different types of accounts.

00:47:47.870 --> 00:47:50.490
The primary type of account
that's always existed is kind

00:47:50.490 --> 00:47:53.560
of the consumer account, regular
Gmail accounts that

00:47:53.560 --> 00:47:54.900
you guys are used to.

00:47:54.900 --> 00:47:58.570
The second type of account
is a Google Apps account.

00:47:58.570 --> 00:48:01.360
And we've actually tried to
move these Google Apps

00:48:01.360 --> 00:48:04.880
accounts recently into becoming
full regular consumer

00:48:04.880 --> 00:48:06.800
accounts in addition
to having access to

00:48:06.800 --> 00:48:09.710
the business services.

00:48:09.710 --> 00:48:12.060
I actually don't know how
that works right now.

00:48:12.060 --> 00:48:15.060
I actually login, I use
incognito window for my

00:48:15.060 --> 00:48:18.000
consumer stuff and use
a regular window

00:48:18.000 --> 00:48:20.060
for my business access.

00:48:20.060 --> 00:48:23.010
But I think that the way that
that should access or should

00:48:23.010 --> 00:48:25.590
work is really having
a choice.

00:48:25.590 --> 00:48:29.200
Is having when you go to
OpenID basically being

00:48:29.200 --> 00:48:32.450
prompted and say, which account
would you like to

00:48:32.450 --> 00:48:34.110
authenticate with?

00:48:34.110 --> 00:48:37.890
Depending on how the developer
has implemented OpenID, we do

00:48:37.890 --> 00:48:41.510
have some hints on that in the
process they went through.

00:48:41.510 --> 00:48:43.150
But yeah, it's definitely
something that the team's

00:48:43.150 --> 00:48:46.120
aware of, and I was actually
talking with them two or three

00:48:46.120 --> 00:48:49.400
weeks ago, with the engineers
that are implementing this.

00:48:49.400 --> 00:48:52.010
And it's something we're aware
of and hopefully, we'll fix

00:48:52.010 --> 00:48:53.310
soon for you, so you
don't have to use

00:48:53.310 --> 00:48:54.220
that incognito window.

00:48:54.220 --> 00:48:55.070
AUDIENCE: Thank you.

00:48:55.070 --> 00:48:55.795
RYAN BOYD: Yep.

00:48:55.795 --> 00:48:58.320
Let's alternate back
over to here.

00:48:58.320 --> 00:49:00.450
AUDIENCE: First of all, thanks
for the great talk.

00:49:00.450 --> 00:49:02.380
I'm wondering if you have
anything to say about the

00:49:02.380 --> 00:49:07.170
potential privacy implications
of sort of telling Google

00:49:07.170 --> 00:49:10.280
every website I login to
at exactly what time I

00:49:10.280 --> 00:49:12.470
login to that site.

00:49:12.470 --> 00:49:13.530
RYAN BOYD: Sure.

00:49:13.530 --> 00:49:19.180
I mean the original version of
OpenID basically returned a

00:49:19.180 --> 00:49:22.420
opaque identifier back
to the website.

00:49:22.420 --> 00:49:27.530
So basically, if you went to
login to TripIt and you wanted

00:49:27.530 --> 00:49:30.260
to log in using your Google
account, TripIt would get back

00:49:30.260 --> 00:49:34.880
just an identifier that's a
URL or URI and includes a

00:49:34.880 --> 00:49:37.800
number that TripIt doesn't
know how to associate.

00:49:37.800 --> 00:49:42.620
And even the consumer version
of OpenID today for Gmail

00:49:42.620 --> 00:49:46.340
accounts will actually return a
different opaque identifier

00:49:46.340 --> 00:49:49.020
for every site that you visit.

00:49:49.020 --> 00:49:52.700
That being said, many websites
want more information.

00:49:52.700 --> 00:49:54.600
They want to have your name
and they want to have your

00:49:54.600 --> 00:49:55.370
e-mail address.

00:49:55.370 --> 00:49:59.230
So they include what's called
OpenID attribute exchange

00:49:59.230 --> 00:50:02.720
requests as part of their
initial request. And when they

00:50:02.720 --> 00:50:05.600
include that, basically you
those additional elements on

00:50:05.600 --> 00:50:08.310
the authorization screen saying,
is it OK to pass in

00:50:08.310 --> 00:50:09.720
your name and your
e-mail address?

00:50:09.720 --> 00:50:12.020
And you can either
allow or deny.

00:50:12.020 --> 00:50:17.990
If you had websites that you
really wanted to be entirely

00:50:17.990 --> 00:50:21.995
anonymous per se to, then you
wouldn't want to ever approve

00:50:21.995 --> 00:50:24.400
a screen that looks like that
and you'd want to encourage

00:50:24.400 --> 00:50:28.070
those website developers to not
ask for that information.

00:50:28.070 --> 00:50:31.720
We don't currently have a way
to basically say the website

00:50:31.720 --> 00:50:32.910
developer asked for it.

00:50:32.910 --> 00:50:36.110
You, as a user, can say, no, I
want to login, but I don't

00:50:36.110 --> 00:50:37.330
want to pass that information.

00:50:37.330 --> 00:50:40.010
We don't currently have that
scenario implemented.

00:50:40.010 --> 00:50:42.720
But it's something, if there was
enough requests for, it is

00:50:42.720 --> 00:50:44.280
something we could, of
course, look at.

00:50:44.280 --> 00:50:45.480
AUDIENCE: Sorry, that's
all great information.

00:50:45.480 --> 00:50:47.670
But I don't think that
answers my question.

00:50:47.670 --> 00:50:50.350
I'm talking about on the
side of the provider.

00:50:50.350 --> 00:50:52.660
Google learning all of the
different sites that I'm

00:50:52.660 --> 00:50:53.446
logging in to.

00:50:53.446 --> 00:50:54.220
RYAN BOYD: Sorry.

00:50:54.220 --> 00:50:57.330
AUDIENCE: No, that's OK.

00:50:57.330 --> 00:50:59.590
That's your choice to use
the OpenID provider

00:50:59.590 --> 00:51:01.080
that you want to use.

00:51:01.080 --> 00:51:04.560
And if you don't like that
provider knowing the different

00:51:04.560 --> 00:51:06.880
sites that you're logging in
to, then use a different

00:51:06.880 --> 00:51:08.940
provider that you're
OK with that with.

00:51:08.940 --> 00:51:13.020
Or use your own provider with
the risk that some websites

00:51:13.020 --> 00:51:14.770
might just have that NASCAR
and you can't

00:51:14.770 --> 00:51:15.690
use your own provider.

00:51:15.690 --> 00:51:19.090
But yeah, I don't have
any fantastic answer

00:51:19.090 --> 00:51:19.880
for you on that one.

00:51:19.880 --> 00:51:22.410
The way the protocol works is
Google gets to see that

00:51:22.410 --> 00:51:25.830
information during
the process.

00:51:25.830 --> 00:51:27.600
AUDIENCE: I guess I'm just
wondering if there's going to

00:51:27.600 --> 00:51:29.220
be consumer push back or
if we should expect

00:51:29.220 --> 00:51:30.330
something like from this.

00:51:30.330 --> 00:51:31.180
Thank you.

00:51:31.180 --> 00:51:32.726
RYAN BOYD: Thanks.

00:51:32.726 --> 00:51:34.750
AUDIENCE: Question
about the refresh

00:51:34.750 --> 00:51:37.250
tokens around best practices.

00:51:37.250 --> 00:51:40.250
Should, as application
developers, we pay attention

00:51:40.250 --> 00:51:43.470
to the expiration time and
request a new auth token

00:51:43.470 --> 00:51:46.560
before it expires or just wait
to get a fail authorization

00:51:46.560 --> 00:51:48.780
and try again?

00:51:48.780 --> 00:51:51.480
RYAN BOYD: It would reduce
latency if you expected, if

00:51:51.480 --> 00:51:52.420
you looked at it.

00:51:52.420 --> 00:51:54.740
Basically, if you did some
background process looking at

00:51:54.740 --> 00:51:58.010
when your tokens expire and
knowing that the user is

00:51:58.010 --> 00:52:00.070
currently active on your
site and renewing them

00:52:00.070 --> 00:52:01.560
automatically.

00:52:01.560 --> 00:52:05.220
Because otherwise you're
basically waiting to get--

00:52:05.220 --> 00:52:06.490
sorry, a 401 or 403.

00:52:06.490 --> 00:52:07.790
I'm sorry, I'm forgetting
which.

00:52:07.790 --> 00:52:11.060
But you're basically waiting to
get that return by Google.

00:52:11.060 --> 00:52:14.380
And if you do that, then you're
adding an extra request

00:52:14.380 --> 00:52:18.850
in the process and the user is
sitting there waiting for you

00:52:18.850 --> 00:52:20.860
not only to get the
error, but also to

00:52:20.860 --> 00:52:22.230
then refresh the token.

00:52:22.230 --> 00:52:23.300
And then get the data.

00:52:23.300 --> 00:52:25.730
So it's really up to you.

00:52:25.730 --> 00:52:28.930
But if you have an application
that you want to reduce the

00:52:28.930 --> 00:52:30.880
latency a lot, I would renew
them in advance.

00:52:33.640 --> 00:52:34.530
AUDIENCE: Just a
quick question.

00:52:34.530 --> 00:52:36.060
You may not be able to answer
because it might be

00:52:36.060 --> 00:52:36.920
outside your area.

00:52:36.920 --> 00:52:39.840
But App Engine currently,
I believe, uses

00:52:39.840 --> 00:52:41.040
version 1 of OAuth.

00:52:41.040 --> 00:52:45.110
Is App Engine going to update
to version 2 of OAuth or are

00:52:45.110 --> 00:52:46.710
they sticking with 1?

00:52:46.710 --> 00:52:49.500
RYAN BOYD: You're right that I
don't have the answer to that.

00:52:49.500 --> 00:52:53.180
I know that there
are libraries.

00:52:53.180 --> 00:52:57.290
The API client for Python I
believe has implemented.

00:52:57.290 --> 00:52:59.210
Jed is nodding his
head here, yes.

00:52:59.210 --> 00:53:03.550
So yes, the API client for
Python distributed by Google,

00:53:03.550 --> 00:53:07.570
which you can use on App Engine
does support OAuth 2.

00:53:07.570 --> 00:53:11.020
But frankly, OAuth 2 is really
easy to implement, even if you

00:53:11.020 --> 00:53:13.600
don't have a library that
supports it I wouldn't be too

00:53:13.600 --> 00:53:16.095
scared about trying to
implement OAuth 2.

00:53:16.095 --> 00:53:19.815
AUDIENCE: It wasn't so much as
a client, like using App

00:53:19.815 --> 00:53:20.760
Engine as a client.

00:53:20.760 --> 00:53:24.710
But you can actually use App
Engine as a relying party.

00:53:24.710 --> 00:53:25.360
Sorry, as a--

00:53:25.360 --> 00:53:27.350
RYAN BOYD: You mean
as a OAuth--

00:53:27.350 --> 00:53:29.850
you have an API hosted on App
Engine and you're trying to

00:53:29.850 --> 00:53:32.530
authorize users accessing
that API?

00:53:32.530 --> 00:53:34.030
So I don't know the
answer to you.

00:53:34.030 --> 00:53:34.300
Sorry.

00:53:34.300 --> 00:53:36.806
AUDIENCE: All right,
thank you.

00:53:36.806 --> 00:53:37.620
AUDIENCE: Yeah, thanks.

00:53:37.620 --> 00:53:41.556
I'm wondering if developers
store the refresh token in the

00:53:41.556 --> 00:53:44.742
database and say they have a
Sony moment and the database

00:53:44.742 --> 00:53:47.250
gets spilled out to the public,
are those refresh

00:53:47.250 --> 00:53:54.470
tokens worth anything by
themselves outside of the app

00:53:54.470 --> 00:53:58.300
of the developer who
requested it?

00:53:58.300 --> 00:54:00.270
RYAN BOYD: In addition to that
refresh token, they would need

00:54:00.270 --> 00:54:04.890
to have that client ID and
client secret in addition.

00:54:04.890 --> 00:54:07.050
So I'm trying to think here.

00:54:09.910 --> 00:54:12.130
In general, I think that as long
as they weren't able to

00:54:12.130 --> 00:54:15.020
get on the client secret,
they would be OK.

00:54:15.020 --> 00:54:17.630
Because I'm pretty sure the
client secret is only ever

00:54:17.630 --> 00:54:22.930
communicated in server to server
post from the server--

00:54:22.930 --> 00:54:27.320
or from the client, from the
web application to Google

00:54:27.320 --> 00:54:28.190
using HTTPS.

00:54:28.190 --> 00:54:30.320
So it's stored securely
somewhere in their

00:54:30.320 --> 00:54:32.150
environment.

00:54:32.150 --> 00:54:35.600
I'd still be slightly concerned,
but I think as long

00:54:35.600 --> 00:54:38.550
as your storing that data
separately, that would be a

00:54:38.550 --> 00:54:39.220
best practice.

00:54:39.220 --> 00:54:41.088
AUDIENCE: I don't need
more than just that.

00:54:41.088 --> 00:54:43.430
OK, thanks.

00:54:43.430 --> 00:54:44.800
RYAN BOYD: Don't get your
database compromised though,

00:54:44.800 --> 00:54:46.050
how's that?

00:54:48.070 --> 00:54:50.010
AUDIENCE: I think a lot of us
are sort of having tin foil

00:54:50.010 --> 00:54:53.230
hat moments with the
APIs on that stuff.

00:54:53.230 --> 00:54:57.030
Is there any way for the end
users to know how scrupulous

00:54:57.030 --> 00:55:00.380
or not a web application
is when they are

00:55:00.380 --> 00:55:02.620
using OAuth or OpenID?

00:55:02.620 --> 00:55:05.350
Is there any sort of
certification process or

00:55:05.350 --> 00:55:08.710
anything like that for us to
know when we do allow this

00:55:08.710 --> 00:55:12.570
token and all of this other
behind the scenes stuff how

00:55:12.570 --> 00:55:15.410
securely it's being
implemented?

00:55:15.410 --> 00:55:18.600
RYAN BOYD: We don't have
anything that we can provide

00:55:18.600 --> 00:55:19.240
you for that.

00:55:19.240 --> 00:55:23.010
I would talk to the people
who are implementing.

00:55:23.010 --> 00:55:25.470
Talk to the web applications
that you're considering using

00:55:25.470 --> 00:55:26.320
and ask them for more

00:55:26.320 --> 00:55:28.480
information on their practices.

00:55:28.480 --> 00:55:30.790
Look at who they're funded by.

00:55:30.790 --> 00:55:33.120
Look at a variety of different
things to determine how much

00:55:33.120 --> 00:55:34.950
you trust that company.

00:55:34.950 --> 00:55:37.535
But Google does not have any
sort of certification on that.

00:55:37.535 --> 00:55:38.983
AUDIENCE: OK.

00:55:38.983 --> 00:55:40.710
Are the sort of auditing
companies

00:55:40.710 --> 00:55:42.328
aware of how this works?

00:55:42.328 --> 00:55:45.970
Do they have best practices
for us to follow?

00:55:45.970 --> 00:55:49.330
Basically, how much third party
support is there for

00:55:49.330 --> 00:55:54.430
really, really solid, secure
use of OAuth and OpenID?

00:55:54.430 --> 00:55:56.760
RYAN BOYD: There are certainly
consulting firms that

00:55:56.760 --> 00:55:59.920
specialize in this
type of stuff.

00:55:59.920 --> 00:56:02.570
There are companies that
actually implement it for you,

00:56:02.570 --> 00:56:05.000
and you can just kind
of use their APIs.

00:56:05.000 --> 00:56:08.500
Things like Janrain
is an example of

00:56:08.500 --> 00:56:09.430
one of those companies.

00:56:09.430 --> 00:56:10.800
J-A-N-R-A-I-N.

00:56:10.800 --> 00:56:12.610
And they've actually implemented
a lot of the open

00:56:12.610 --> 00:56:15.720
source libraries
as well for it.

00:56:15.720 --> 00:56:19.090
That My best recommendation
right now would be check out

00:56:19.090 --> 00:56:22.140
some of those companies and
certainly do some due

00:56:22.140 --> 00:56:24.120
diligence when you're evaluating
applications.

00:56:24.120 --> 00:56:26.488
AUDIENCE: Thank you.

00:56:26.488 --> 00:56:26.890
AUDIENCE: Hi.

00:56:26.890 --> 00:56:32.461
Please, could you elaborate, why
did you use OAuth 1 in the

00:56:32.461 --> 00:56:34.770
second business use case?

00:56:34.770 --> 00:56:35.140
RYAN BOYD: Sure.

00:56:35.140 --> 00:56:39.260
So basically, OAuth 2, the way
we've implemented it thus far,

00:56:39.260 --> 00:56:42.150
requires that the user have
an active session in their

00:56:42.150 --> 00:56:45.890
browser in order to do
that initial grant.

00:56:45.890 --> 00:56:50.020
And the user is granting access
to only their data.

00:56:50.020 --> 00:56:52.800
In the case of the business use
case where you want an IT

00:56:52.800 --> 00:56:55.960
admin to grant access to
the data for the entire

00:56:55.960 --> 00:56:59.350
organization, we just haven't
implemented that yet in an

00:56:59.350 --> 00:57:01.410
OAuth 2 style flow.

00:57:01.410 --> 00:57:04.336
So it's just a question of time
more than anything else.

00:57:04.336 --> 00:57:06.670
AUDIENCE: Thank you.

00:57:06.670 --> 00:57:07.750
AUDIENCE: Hey Ryan.

00:57:07.750 --> 00:57:12.600
Let's say you have two websites
that are implementing

00:57:12.600 --> 00:57:17.210
Google for authentication and
instead of actually using

00:57:17.210 --> 00:57:19.410
OAuth to pull data
from Google, you

00:57:19.410 --> 00:57:21.620
actually want it to use--

00:57:21.620 --> 00:57:25.770
would you be able to support
where they both use the login,

00:57:25.770 --> 00:57:29.332
but now they actually can pull
data from each other as

00:57:29.332 --> 00:57:31.740
opposed to pulling
data from Google?

00:57:31.740 --> 00:57:33.740
RYAN BOYD: So one of them is
pulling data from Google and

00:57:33.740 --> 00:57:34.310
then the other one--

00:57:34.310 --> 00:57:35.360
AUDIENCE: No, neither of them.

00:57:35.360 --> 00:57:39.560
They're just both using Google
for authentication.

00:57:39.560 --> 00:57:42.350
RYAN BOYD: You would basically
be establishing some sort of

00:57:42.350 --> 00:57:44.720
trust between those
two servers.

00:57:44.720 --> 00:57:46.900
And you could use OAuth.

00:57:46.900 --> 00:57:51.000
Basically, have those two
services use OAuth for that

00:57:51.000 --> 00:57:52.500
trust back and forth.

00:57:52.500 --> 00:57:55.050
But it's not something that
Google itself would be

00:57:55.050 --> 00:57:56.070
involved in.

00:57:56.070 --> 00:57:58.920
You would use authentication,
like use OpenID for

00:57:58.920 --> 00:58:01.510
authentication to get access
to the user's identity.

00:58:01.510 --> 00:58:05.920
But then to kind of transmit
data between the two servers,

00:58:05.920 --> 00:58:08.230
you'd probably use OAuth with
some sort of trust between

00:58:08.230 --> 00:58:09.040
those two servers.

00:58:09.040 --> 00:58:09.510
AUDIENCE: Right.

00:58:09.510 --> 00:58:11.390
So you have to implement
your own OAuth?

00:58:11.390 --> 00:58:12.020
RYAN BOYD: Yeah.

00:58:12.020 --> 00:58:13.950
I mean you could use other
protocols, but that would be

00:58:13.950 --> 00:58:14.530
one way to do it.

00:58:14.530 --> 00:58:14.740
AUDIENCE: Yeah.

00:58:14.740 --> 00:58:17.790
OK, thanks.

00:58:17.790 --> 00:58:18.070
AUDIENCE: Hi.

00:58:18.070 --> 00:58:21.440
Facebook and LinkedIn have
implemented OAuth 2 in the

00:58:21.440 --> 00:58:26.380
user agent flow, which doesn't
involve secrets at all.

00:58:26.380 --> 00:58:29.980
This is very useful for
developers who want to just do

00:58:29.980 --> 00:58:33.070
client side authentication.

00:58:33.070 --> 00:58:34.750
Does Google support that?

00:58:34.750 --> 00:58:38.526
I see OAuth 2.0 with the last
step in the dance as about

00:58:38.526 --> 00:58:41.950
exchanging that access
token for using code.

00:58:41.950 --> 00:58:44.510
RYAN BOYD: Yeah, we do
support entirely

00:58:44.510 --> 00:58:46.140
user agent based flow.

00:58:46.140 --> 00:58:48.920
I didn't really get into the
details in the presentation.

00:58:48.920 --> 00:58:51.470
We do support entirely user
agent based dance, where you

00:58:51.470 --> 00:58:53.780
could do it purely
from JavaScript.

00:58:53.780 --> 00:58:56.020
There may still be
a secret, but the

00:58:56.020 --> 00:58:57.170
secret is known to everyone.

00:58:57.170 --> 00:58:58.870
So you just need to
be aware of that.

00:58:58.870 --> 00:59:01.860
AUDIENCE: That kind
of sucks, right?

00:59:01.860 --> 00:59:03.700
RYAN BOYD: I'm not sure
if our current flow--

00:59:03.700 --> 00:59:06.130
I know that some of the folks
like LinkedIn have implemented

00:59:06.130 --> 00:59:08.860
it where the user actually has
to have a current active

00:59:08.860 --> 00:59:12.800
session in order to refresh
their access token.

00:59:12.800 --> 00:59:16.030
Whereas, the implementation that
I showed the user doesn't

00:59:16.030 --> 00:59:18.690
have an active session.

00:59:18.690 --> 00:59:20.940
But I'm not sure what our
support is for that yet.

00:59:20.940 --> 00:59:23.582
I can certainly talk with you
afterwards and get more info.

00:59:23.582 --> 00:59:24.074
AUDIENCE: Sure.

00:59:24.074 --> 00:59:25.790
I'll reach out to you.

00:59:25.790 --> 00:59:26.600
AUDIENCE: [INAUDIBLE].

00:59:26.600 --> 00:59:28.090
What's the relationship between
what you've talked

00:59:28.090 --> 00:59:32.010
about today and Open Social?

00:59:32.010 --> 00:59:33.610
RYAN BOYD: Sorry, I
have 30 seconds.

00:59:33.610 --> 00:59:35.280
AUDIENCE: I'll talk
to you afterwards.

00:59:35.280 --> 00:59:37.390
RYAN BOYD: Yes, let's
chat afterwards.

00:59:37.390 --> 00:59:38.710
Thank you very much, everyone.

00:59:38.710 --> 00:59:39.960
Thank you.

