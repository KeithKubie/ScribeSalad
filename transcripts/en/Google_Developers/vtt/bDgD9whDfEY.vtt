WEBVTT
Kind: captions
Language: en

00:00:03.000 --> 00:00:04.968
Martelli:
When you typically

00:00:04.968 --> 00:00:07.601
are trying things out,

00:00:07.601 --> 00:00:09.734
you want to see results
for what you're doing.

00:00:09.734 --> 00:00:11.200
How do you see results?

00:00:11.200 --> 00:00:12.968
Well, the--

00:00:12.968 --> 00:00:15.367
If you're working
at the interactive shell,

00:00:15.367 --> 00:00:17.467
then any expression you do

00:00:17.467 --> 00:00:19.801
which has a value
that is not none,

00:00:19.801 --> 00:00:22.067
it will be
represented for you

00:00:22.067 --> 00:00:23.467
on the screen.

00:00:23.467 --> 00:00:26.801
That is only useful
when you're trying things out.

00:00:26.801 --> 00:00:28.701
When you're doing a program

00:00:28.701 --> 00:00:31.067
but want to get
some extra output,

00:00:31.067 --> 00:00:32.267
like for debugging

00:00:32.267 --> 00:00:33.667
or understanding
what's going on,

00:00:33.667 --> 00:00:36.267
there's a statement
called "print."

00:00:36.267 --> 00:00:37.534
Very elementary.

00:00:37.534 --> 00:00:40.501
It just puts the strings
into standard I/O.

00:00:40.501 --> 00:00:43.334
You can use commas
to print multiple values.

00:00:43.334 --> 00:00:46.501
And it will put spaces
between the values

00:00:46.501 --> 00:00:48.200
and a new line at the end.

00:00:48.200 --> 00:00:49.868
In real program, of course,

00:00:49.868 --> 00:00:53.100
the way you do an output
is very, very different.

00:00:53.100 --> 00:00:55.000
An excellent way to do output,

00:00:55.000 --> 00:00:57.167
and very encouraged
in Google opinion,

00:00:57.167 --> 00:00:59.767
is the logging package
of the Python standard library,

00:00:59.767 --> 00:01:03.167
which basically
lets you log information

00:01:03.167 --> 00:01:04.501
at different levels.

00:01:04.501 --> 00:01:06.667
So you can tell the system,

00:01:06.667 --> 00:01:08.033
"This is for debugging."

00:01:08.033 --> 00:01:09.434
"This is for retrieve."

00:01:09.434 --> 00:01:11.067
"This is a warning."
"This is an error."

00:01:11.067 --> 00:01:12.701
"This is a fatal error."

00:01:12.701 --> 00:01:14.334
So you can be selective

00:01:14.334 --> 00:01:17.567
on what it is
that you're getting displayed.

00:01:17.567 --> 00:01:20.400
If you're writing
a web application,

00:01:20.400 --> 00:01:22.667
the typical way
you'll be seeing results

00:01:22.667 --> 00:01:27.767
is by adding string
to some HTML response object.

00:01:27.767 --> 00:01:30.033
If you're doing
a GUI application,

00:01:30.033 --> 00:01:31.634
then there will be
GUI widgets

00:01:31.634 --> 00:01:33.267
with their own methods
and so on.

00:01:33.267 --> 00:01:35.834
So I'm not going to focus
on any of these.

00:01:35.834 --> 00:01:37.868
I'm just going to use
print occasionally

00:01:37.868 --> 00:01:43.367
to show you what is the result
that you're going to get.

00:01:43.367 --> 00:01:46.467
And here's finally
some trivial examples.

00:01:46.467 --> 00:01:48.400
Python has the world record

00:01:48.400 --> 00:01:50.901
for the shortest
"Hello, world" program,

00:01:50.901 --> 00:01:53.033
the most classic program
in the world.

00:01:53.033 --> 00:01:54.467
You just have to use "print"

00:01:54.467 --> 00:01:56.133
to get to standard output

00:01:56.133 --> 00:01:57.400
and a string in quotes,

00:01:57.400 --> 00:01:58.801
and that's all
there is to it.

00:01:58.801 --> 00:02:00.400
Let's do some assignment.

00:02:00.400 --> 00:02:01.734
"X = 23"

00:02:01.734 --> 00:02:04.200
means X from now on
until further notice

00:02:04.200 --> 00:02:07.000
is bound to the number 23.

00:02:07.000 --> 00:02:08.667
So if you print X right now,

00:02:08.667 --> 00:02:11.601
it emits
on standard output 23.

00:02:11.601 --> 00:02:14.000
If you now say
"X = foo,"

00:02:14.000 --> 00:02:16.467
then whatever X
was referring to,

00:02:16.467 --> 00:02:18.133
X doesn't refer to anymore.

00:02:18.133 --> 00:02:20.334
Maybe somebody else does.
X doesn't care.

00:02:20.334 --> 00:02:23.667
The name X from now on
refers to the string "foo."

00:02:23.667 --> 00:02:26.501
And I'm deliberately using
objects of different types,

00:02:26.501 --> 00:02:27.834
like a number and a string,

00:02:27.834 --> 00:02:29.934
to point out
that the name X per se

00:02:29.934 --> 00:02:31.801
is totally at your disposal

00:02:31.801 --> 00:02:34.100
to refer to anything you want.

00:02:34.100 --> 00:02:35.501
What it is referring to

00:02:35.501 --> 00:02:37.367
depends on what
you last assigned to it.

00:02:37.367 --> 00:02:39.767
So now "print X"
emits "foo."

00:02:39.767 --> 00:02:42.067
And you can also
remove the binding.

00:02:42.067 --> 00:02:43.234
That's rarely done.

00:02:43.234 --> 00:02:45.100
But if you want,
you can "del X."

00:02:45.100 --> 00:02:47.067
This means from now on

00:02:47.067 --> 00:02:49.400
the name X doesn't refer
to anything anymore.

00:02:49.400 --> 00:02:51.634
Like if I'd never
assigned anything to it.

00:02:51.634 --> 00:02:55.133
So if you now print X,
that's an error.

00:02:55.133 --> 00:02:57.334
It raises an exception,
as we'll see

00:02:57.334 --> 00:03:00.601
because X doesn't refer
to anything.

00:03:00.601 --> 00:03:03.100
Well, what if you want X
to still be around

00:03:03.100 --> 00:03:04.934
but not refer to anything?

00:03:04.934 --> 00:03:06.434
Well, let's do it with Y.

00:03:06.434 --> 00:03:08.367
That's what
you use "none" for.

00:03:08.367 --> 00:03:11.267
"Y = none"
is different from "del Y."

00:03:11.267 --> 00:03:13.434
It means
"Y refers to something."

00:03:13.434 --> 00:03:14.767
"What?"
"Nothing."

00:03:14.767 --> 00:03:16.234
I know, it's a bit--

00:03:16.234 --> 00:03:18.000
So if you print Y,

00:03:18.000 --> 00:03:20.334
instead of an error,
you get "none."

00:03:20.334 --> 00:03:23.000
If you ever see a lot
of "none" in your output,

00:03:23.000 --> 00:03:24.501
you're probably
doing something wrong,

00:03:24.501 --> 00:03:26.133
but that's a good hint.

00:03:26.133 --> 00:03:29.000
Okay, so there are

00:03:29.000 --> 00:03:31.133
some pretty obvious
similarities

00:03:31.133 --> 00:03:33.501
between Python and Java.

00:03:33.501 --> 00:03:36.367
First of all,
in the implementation level,

00:03:36.367 --> 00:03:38.734
although there are variants
in both cases,

00:03:38.734 --> 00:03:42.534
they are both typically
compiled to bytecode.

00:03:42.534 --> 00:03:46.000
Python compiles implicitly.

00:03:46.000 --> 00:03:49.067
It's like it's got
a make engine built in.

00:03:49.067 --> 00:03:50.801
But the typical result

00:03:50.801 --> 00:03:53.634
is that a virtual machine,
or interpreter if you will,

00:03:53.634 --> 00:03:56.834
will execute in a controlled
importable way

00:03:56.834 --> 00:04:00.033
the bytecodes produced
by the compiler,

00:04:00.033 --> 00:04:02.367
explicit or implicit
as it may be.

00:04:02.367 --> 00:04:03.701
In both languages,

00:04:03.701 --> 00:04:05.868
everything inherits
from object,

00:04:05.868 --> 00:04:09.033
except it's spelled
with a lowercase O in Python.

00:04:09.033 --> 00:04:12.100
That's hardly
a deep difference.

00:04:12.100 --> 00:04:14.667
In Python, everything
is a first-class object.

00:04:14.667 --> 00:04:18.667
So in Java,
a method or a class per se

00:04:18.667 --> 00:04:20.767
does not constitute
an object.

00:04:20.767 --> 00:04:22.133
In Python, it does.

00:04:22.133 --> 00:04:24.100
There is nothing
that is just

00:04:24.100 --> 00:04:26.300
a compile time construct

00:04:26.300 --> 00:04:29.767
and doesn't have
an object responding to it.

00:04:29.767 --> 00:04:33.968
Same for numbers
and so on.

00:04:33.968 --> 00:04:36.300
Commonality,
a very deep, important,

00:04:36.300 --> 00:04:39.133
absolutely crucial commonality
between Java and Python,

00:04:39.133 --> 00:04:41.367
they both uniform
object reference semantics.

00:04:41.367 --> 00:04:45.667
In other languages,
such as C++ or C,

00:04:45.667 --> 00:04:47.834
when you say "A = B,"

00:04:47.834 --> 00:04:50.033
this means
a lot of bits from B

00:04:50.033 --> 00:04:52.734
are going to be copied over
into A.

00:04:52.734 --> 00:04:55.067
There's a copy implied.

00:04:55.067 --> 00:04:56.100
In Java or Python,

00:04:56.100 --> 00:04:57.734
when you write "A = B,"

00:04:57.734 --> 00:04:59.033
it means from now on

00:04:59.033 --> 00:05:01.400
A refers to exactly
the same object

00:05:01.400 --> 00:05:03.601
as B referred to
at that time.

00:05:03.601 --> 00:05:06.167
So everything,
and this goes for assignment,

00:05:06.167 --> 00:05:08.501
it goes for argument-passing,
goes for return values,

00:05:08.501 --> 00:05:13.200
everything is about
having names refer to objects

00:05:13.200 --> 00:05:15.701
as opposed
to having names

00:05:15.701 --> 00:05:19.734
be boxes with bits in them.

00:05:19.734 --> 00:05:23.300
Both languages
have garbage collection.

00:05:23.300 --> 00:05:25.801
The classic
Python implementation

00:05:25.801 --> 00:05:28.467
tries hard to collect garbage

00:05:28.467 --> 00:05:31.200
much more proactively
than Java.

00:05:31.200 --> 00:05:33.133
It doesn't wait
to collect garbage

00:05:33.133 --> 00:05:35.734
until there's
a lot of garbage around.

00:05:35.734 --> 00:05:39.734
It tries to collect garbage
as soon as it possible can,

00:05:39.734 --> 00:05:42.901
basically to save
the run time memory

00:05:42.901 --> 00:05:45.334
from going to waste.

00:05:45.334 --> 00:05:48.467
Other implementations of Python,
however, don't do that.

00:05:48.467 --> 00:05:51.601
A lot of what is in common
between Java and Python

00:05:51.601 --> 00:05:54.601
are stuff outside
the language proper.

00:05:54.601 --> 00:05:56.267
That's why I call them
"marginalia,"

00:05:56.267 --> 00:05:58.501
but very important
to your everyday use.

00:05:58.501 --> 00:06:01.367
Both have huge
standard libraries.

00:06:01.367 --> 00:06:04.834
Both have enormous amounts
of third-party packages

00:06:04.834 --> 00:06:06.868
and tools available.

00:06:06.868 --> 00:06:08.501
Both let you do
introspection,

00:06:08.501 --> 00:06:10.467
serialization,
threading,

00:06:10.467 --> 00:06:13.033
all as part
of the standard libraries.

00:06:13.033 --> 00:06:15.300
So if you're coming
from Java,

00:06:15.300 --> 00:06:18.000
you'll have to learn
all the different ways

00:06:18.000 --> 00:06:20.267
you can do those things
in CPython,

00:06:20.267 --> 00:06:22.534
but the fact
that you can do them

00:06:22.534 --> 00:06:24.968
is very much in common.

00:06:24.968 --> 00:06:27.300
Now if you're coming
from C++ instead,

00:06:27.300 --> 00:06:28.534
what's similar?

00:06:28.534 --> 00:06:30.667
Well, they're
both multi-paradigm.

00:06:30.667 --> 00:06:32.834
Java basically tries
to force you

00:06:32.834 --> 00:06:34.501
into object-oriented
programming.

00:06:34.501 --> 00:06:37.267
Python and C++
are happy if you do OOP,

00:06:37.267 --> 00:06:40.100
but if you want to do
procedural programming

00:06:40.100 --> 00:06:41.601
or generic programming

00:06:41.601 --> 00:06:43.567
or a little bit
of functioning programming,

00:06:43.567 --> 00:06:46.834
they'll happily
adjust to that.

00:06:46.834 --> 00:06:49.534
Both languages
have multiple inheritance.

00:06:49.534 --> 00:06:53.200
So you don't have to force
everything into a single tree.

00:06:53.200 --> 00:06:55.534
You can use
any directed or cyclic graph

00:06:55.534 --> 00:06:57.634
with caution
in both languages.

00:06:57.634 --> 00:06:59.601
You can do
operator overloading.

00:06:59.601 --> 00:07:03.133
The one thing that many
C++ programmer

00:07:03.133 --> 00:07:04.667
think they can do

00:07:04.667 --> 00:07:07.501
because they can do in C++
and they cannot do in Python

00:07:07.501 --> 00:07:09.868
is to overload the assignment.

00:07:09.868 --> 00:07:12.434
In Python,
assignment has exactly

00:07:12.434 --> 00:07:14.300
the Java semantics always.

00:07:14.300 --> 00:07:16.934
It's always
an object reference.

00:07:16.934 --> 00:07:19.133
There is no way
for you to redefine

00:07:19.133 --> 00:07:20.934
what assignment means.

00:07:20.934 --> 00:07:23.400
Assignment is not
an operator in Python.

00:07:23.400 --> 00:07:26.334
Everything else
that you can do in C++

00:07:26.334 --> 00:07:30.868
and a lot of operators
that are not operators in C++

00:07:30.868 --> 00:07:34.334
you can redefine in Python.

00:07:34.334 --> 00:07:38.901
If you're very used to doing
generic programming in C++,

00:07:38.901 --> 00:07:42.601
you know what signature based
polymorphism is.

00:07:42.601 --> 00:07:45.501
In C++ it's also spelled
"templates."

00:07:45.501 --> 00:07:47.667
Basically in Python
everything you're writing

00:07:47.667 --> 00:07:50.567
is always a template
implicitly,

00:07:50.567 --> 00:07:52.267
without any effort
on your part.

00:07:52.267 --> 00:07:53.701
Very nice index.

00:07:53.701 --> 00:07:56.267
So if you think
in terms of signatures,

00:07:56.267 --> 00:07:59.434
Python supports signatures
implicitly.

00:07:59.434 --> 00:08:01.167
Similarity--

00:08:01.167 --> 00:08:05.200
The marginal similarity
between C++ and Python

00:08:05.200 --> 00:08:07.801
is that both offer
abundant choices,

00:08:07.801 --> 00:08:10.400
maybe even too many,
for just about everything

00:08:10.400 --> 00:08:13.434
that's not an absolutely
core issue.

00:08:13.434 --> 00:08:15.534
What GUI you want to use?

00:08:15.534 --> 00:08:17.834
Basically any.

00:08:17.834 --> 00:08:20.501
Web, other networking,
databases,

00:08:20.501 --> 00:08:23.100
inter-program communication,
distributed processing.

00:08:23.100 --> 00:08:26.734
The languages don't come
with a pre-bound solution.

00:08:26.734 --> 00:08:28.267
You have to choose.

00:08:28.267 --> 00:08:30.534
There's a huge possibility
of choices,

00:08:30.534 --> 00:08:32.534
but sometimes
it can be penalizing

00:08:32.534 --> 00:08:35.667
to have too many choices.

00:08:35.667 --> 00:08:39.467
Now some people get surprised
when I point out

00:08:39.467 --> 00:08:42.267
that Python
is the one language

00:08:42.267 --> 00:08:44.667
that is most close to C.

00:08:44.667 --> 00:08:46.200
Of course the syntax
is different,

00:08:46.200 --> 00:08:48.701
but we know syntax
is only skin deep.

00:08:48.701 --> 00:08:50.334
What is similar?

00:08:50.334 --> 00:08:52.667
It's the spirit
of the language.

00:08:52.667 --> 00:08:54.667
And we can tell
because the spirit of C

00:08:54.667 --> 00:08:59.300
is officially acknowledged
as a part of the C Standard.

00:08:59.300 --> 00:09:03.367
It's in the rationale
of the ISO C Standard.

00:09:03.367 --> 00:09:07.667
And the spirit of C
consists of five principles.

00:09:07.667 --> 00:09:09.767
Trust the programmer.

00:09:09.767 --> 00:09:12.634
That's point one
of the spirit of C.

00:09:12.634 --> 00:09:15.901
Don't try to second-guess
the programmer.

00:09:15.901 --> 00:09:17.400
Trust him.

00:09:17.400 --> 00:09:20.100
C does that.
Python does that.

00:09:20.100 --> 00:09:22.734
C++ and Java do not.

00:09:22.734 --> 00:09:26.133
They try to make sure

00:09:26.133 --> 00:09:28.701
the programmer doesn't
get out of the sandbox.

00:09:28.701 --> 00:09:31.968
You know, private,
protected, and things.

00:09:31.968 --> 00:09:33.634
Don't stop the programmer

00:09:33.634 --> 00:09:35.300
from doing
what needs to be done.

00:09:35.300 --> 00:09:37.501
That's basically
a follow on from point one.

00:09:37.501 --> 00:09:39.801
Keep the language
small and simple.

00:09:39.801 --> 00:09:42.400
Don't add keywords
that are only needed

00:09:42.400 --> 00:09:44.534
because you don't trust
the programmers,

00:09:44.534 --> 00:09:46.200
like private.

00:09:46.200 --> 00:09:48.968
Provide only one way
to do an operation.

00:09:48.968 --> 00:09:52.133
This is something that C++
violates pretty badly

00:09:52.133 --> 00:09:55.033
because it always
provides more than one way

00:09:55.033 --> 00:09:57.067
because you can always
do things the C way

00:09:57.067 --> 00:09:59.300
or you can do them
the object-oriented way

00:09:59.300 --> 00:10:00.634
or you can do them
the generic way.

00:10:00.634 --> 00:10:02.934
So there's typically
three ways to do anything.

00:10:02.934 --> 00:10:06.367
In C philosophically
and Python philosophically,

00:10:06.367 --> 00:10:07.801
there should be only one way.

00:10:07.801 --> 00:10:10.067
And then the one bit

00:10:10.067 --> 00:10:13.667
where Python
doesn't really match C,

00:10:13.667 --> 00:10:17.801
the fifth most important
principle of C is be fast.

00:10:17.801 --> 00:10:20.901
Python cares more about
programmer productivity

00:10:20.901 --> 00:10:22.367
than raw speed.

00:10:22.367 --> 00:10:25.300
So it's only
about 50% there.

00:10:25.300 --> 00:10:27.200
It's got some very fast way
to do things,

00:10:27.200 --> 00:10:32.667
but it always privileges
programmer productivity instead.

00:10:32.667 --> 00:10:37.434
While C has
its own spirit

00:10:37.434 --> 00:10:39.234
encoded in the standard,

00:10:39.234 --> 00:10:40.968
Python doesn't have
an official standard,

00:10:40.968 --> 00:10:43.234
but if you type
"import this"

00:10:43.234 --> 00:10:45.501
at any interactive
Python prompt,

00:10:45.501 --> 00:10:49.000
you'll get the equivalent--
the Zen of Python.

00:10:49.000 --> 00:10:52.067
And this
is the one principle--

00:10:52.067 --> 00:10:53.901
This is the way,
for example,

00:10:53.901 --> 00:10:55.667
in which Python expresses

00:10:55.667 --> 00:10:58.934
the only one way
to perform an operation.

00:10:58.934 --> 00:11:00.200
It's a bit more verbose.

00:11:00.200 --> 00:11:02.200
There should be one,

00:11:02.200 --> 00:11:04.834
and preferably only one way
to do it.

00:11:04.834 --> 00:11:09.434
So it's more clear
in the Python formulation

00:11:09.434 --> 00:11:12.267
that this is an objective,
a target,

00:11:12.267 --> 00:11:13.801
a stretch goal.

00:11:13.801 --> 00:11:15.567
It's not something
we can actually do.

00:11:15.567 --> 00:11:17.968
Nobody's going to stop you
from saying,

00:11:17.968 --> 00:11:19.701
"Two plus three
or three plus two,"

00:11:19.701 --> 00:11:21.501
which are two ways to perform
the same operation

00:11:21.501 --> 00:11:23.334
in a trivial sense.

00:11:23.334 --> 00:11:26.234
It would make the language
more complicated

00:11:26.234 --> 00:11:28.267
to try and forbid it.

00:11:28.267 --> 00:11:30.567
So now that we've seen
similarities

00:11:30.567 --> 00:11:33.167
of Python to some languages
you might be familiar with,

00:11:33.167 --> 00:11:34.501
let's see--

00:11:34.501 --> 00:11:36.100
So what's different?

00:11:36.100 --> 00:11:38.100
If this is in common,
this is in common,

00:11:38.100 --> 00:11:39.367
this is in common,

00:11:39.367 --> 00:11:41.434
what is not in common
with any of them?

00:11:41.434 --> 00:11:43.734
Well, there's two points.

00:11:43.734 --> 00:11:48.234
First of all, Python has
very spare syntax,

00:11:48.234 --> 00:11:51.000
no ornamentation.

00:11:51.000 --> 00:11:53.067
It applies,
Tufte's principle,

00:11:53.067 --> 00:11:54.767
no wasted pixels.

00:11:54.767 --> 00:11:56.734
If you don't know
who Edward Tufte is,

00:11:56.734 --> 00:12:01.334
I suggest you should
buy his masterpiece.

00:12:01.334 --> 00:12:02.834
He's got several books out,

00:12:02.834 --> 00:12:05.934
but "The Visual Display
of Quantitative Information"

00:12:05.934 --> 00:12:07.734
is an immortal masterpiece.

00:12:07.734 --> 00:12:11.267
It's a book on how do we
display information graphically?

00:12:11.267 --> 00:12:14.767
And the core principle
is every pixel is precious.

00:12:14.767 --> 00:12:18.501
Don't put a pixel there unless
it communicates information.

00:12:18.501 --> 00:12:21.267
So for example,

00:12:21.267 --> 00:12:25.834
why does Python respect
Tufte's principle?

00:12:25.834 --> 00:12:29.968
Well, you don't put braces
or begin and end keywords

00:12:29.968 --> 00:12:31.367
around a block.

00:12:31.367 --> 00:12:32.667
You just indent it.

00:12:32.667 --> 00:12:34.400
Don't waste any pixel.

00:12:34.400 --> 00:12:36.033
You don't put parenthesis

00:12:36.033 --> 00:12:37.767
around a condition
in an "if" or "while."

00:12:37.767 --> 00:12:38.901
Why should you?

00:12:38.901 --> 00:12:40.167
You just write it

00:12:40.167 --> 00:12:42.667
like "if, space,
condition, colon."

00:12:42.667 --> 00:12:43.834
That's it.

00:12:43.834 --> 00:12:45.834
No parenthesis.
No wasted pixels.

00:12:45.834 --> 00:12:48.968
In general, Python
doesn't like punctuation.

00:12:48.968 --> 00:12:51.267
It uses
very spare punctuation

00:12:51.267 --> 00:12:56.367
and prefers to go
for keywords instead.

00:12:56.367 --> 00:12:58.567
And then there's the semantics.

00:12:58.567 --> 00:13:01.033
Of course syntax
is what strikes you first,

00:13:01.033 --> 00:13:06.033
but deep down the semantics
are much more important.

00:13:06.033 --> 00:13:08.834
Python typing is strong
but dynamic.

00:13:08.834 --> 00:13:10.534
That is it's strong.

00:13:10.534 --> 00:13:12.033
It's stronger than C
for example.

00:13:12.033 --> 00:13:13.434
You cannot say,

00:13:13.434 --> 00:13:15.734
"Take these bits
which used to be this type

00:13:15.734 --> 00:13:19.167
and make believe they're
this other type instead."

00:13:19.167 --> 00:13:22.400
With a cast,
you cannot do that.

00:13:22.400 --> 00:13:24.567
An object has integrity.

00:13:24.567 --> 00:13:27.701
It's very strong typing.

00:13:27.701 --> 00:13:31.133
About as strong as Java,
I would say, or a bit more.

00:13:31.133 --> 00:13:33.200
But names have no types.

00:13:33.200 --> 00:13:34.601
A name is a name
is a name.

00:13:34.601 --> 00:13:36.167
The object has a type,

00:13:36.167 --> 00:13:37.801
and the name
refers to the object.

00:13:37.801 --> 00:13:39.734
So at any given time,

00:13:39.734 --> 00:13:41.767
the name will be referring
to something with a type

00:13:41.767 --> 00:13:45.033
but will not have
any type itself.

00:13:45.033 --> 00:13:47.901
And this is also
known as "duck typing."

00:13:47.901 --> 00:13:49.901
That is,
if it walks like a duck

00:13:49.901 --> 00:13:52.367
and quacks like a duck,
it's a duck.

00:13:52.367 --> 00:13:54.234
That is not necessarily
the case.

00:13:54.234 --> 00:13:57.400
A few years ago a species
that had been identified

00:13:57.400 --> 00:13:59.734
as a duck sometimes
in memorial

00:13:59.734 --> 00:14:02.701
was actually revealed
by DNA analysis to be a goose,

00:14:02.701 --> 00:14:05.934
A goose that had evolved
to basically

00:14:05.934 --> 00:14:10.434
live in exactly the same
ecological niches as ducks have

00:14:10.434 --> 00:14:11.968
in other the places.

00:14:11.968 --> 00:14:14.334
I'm told it even
tasted like duck

00:14:14.334 --> 00:14:16.667
if you cooked it.

00:14:16.667 --> 00:14:19.267
Well, so it's not necessarily
true that it is a duck,

00:14:19.267 --> 00:14:21.667
but it's very true that
you could treat it as a duck

00:14:21.667 --> 00:14:25.300
for just about every purpose
in your life.

00:14:25.300 --> 00:14:27.701
There's no declarations.

00:14:27.701 --> 00:14:30.000
Declarations
are great for lovers.

00:14:30.000 --> 00:14:32.868
I want to make
a love declaration to my wife.

00:14:32.868 --> 00:14:37.133
But in life,
what you want is action,

00:14:37.133 --> 00:14:39.400
not empty words,
not declarations.

00:14:39.400 --> 00:14:42.567
You want statements,
actions.

00:14:42.567 --> 00:14:44.267
And that's
what Python gives you.

00:14:44.267 --> 00:14:46.367
Everything is a statement.

00:14:46.367 --> 00:14:48.300
Everything
is a first-class object.

00:14:48.300 --> 00:14:51.234
No need to distinguish,
is a function an object?

00:14:51.234 --> 00:14:53.167
Is a class an object?
Yes.

00:14:53.167 --> 00:14:55.100
A module is an object,
a package is an object.

00:14:55.100 --> 00:14:57.400
Everything is an object.

00:14:57.400 --> 00:15:00.000
The focus in Python

00:15:00.000 --> 00:15:01.901
is always
on the very high level,

00:15:01.901 --> 00:15:03.634
on the programmer
productivity.

00:15:03.634 --> 00:15:07.167
How does a programmer
think about his problem?

00:15:07.167 --> 00:15:11.534
We do try to support
bit twiddling at lower levels,

00:15:11.534 --> 00:15:13.701
but that's
a second-order of priority,

00:15:13.701 --> 00:15:15.467
while in seen particular

00:15:15.467 --> 00:15:17.434
it's very much
the top priority

00:15:17.434 --> 00:15:20.033
to support the way
the machine works.

00:15:20.033 --> 00:15:21.968
So about duck typing again,

00:15:21.968 --> 00:15:24.734
this is an alternative
interpretation

00:15:24.734 --> 00:15:27.000
of the expression
"duck typing,"

00:15:27.000 --> 00:15:28.801
which would be connected

00:15:28.801 --> 00:15:30.901
with not having to do
the typing yourself

00:15:30.901 --> 00:15:32.834
but training a duck
to do it for you.

00:15:32.834 --> 00:15:34.067
I think it would take

00:15:34.067 --> 00:15:35.634
quite a while
to train the duck,

00:15:35.634 --> 00:15:37.267
but if you can make it

00:15:37.267 --> 00:15:40.133
that should certainly improve
your productivity.

00:15:40.133 --> 00:15:41.667
Back to technical issues.

00:15:41.667 --> 00:15:43.033
Flow control,

00:15:43.033 --> 00:15:46.100
there's basically
four flow control statement--

00:15:46.100 --> 00:15:48.601
if, while, for, and with.

00:15:48.601 --> 00:15:52.033
You're probably familiar
with "if" and "while."

00:15:52.033 --> 00:15:54.367
And this "for"
is more equivalent

00:15:54.367 --> 00:15:57.434
to the "for each"
of Java.

00:15:57.434 --> 00:16:00.400
But, um,
what you should notice

00:16:00.400 --> 00:16:04.000
is instead of going
"else if,"

00:16:04.000 --> 00:16:06.167
there's an "elif,"
collapsed "elif,"

00:16:06.167 --> 00:16:07.968
that you can have
in an "if"

00:16:07.968 --> 00:16:09.667
and the optional "else."

00:16:09.667 --> 00:16:12.334
Loops, beside
the "break" and "continue,"

00:16:12.334 --> 00:16:14.567
just like in C and so on,

00:16:14.567 --> 00:16:16.067
also have an optional "else."

00:16:16.067 --> 00:16:18.734
That's somewhat unusual
in programming languages.

00:16:18.734 --> 00:16:20.934
The point is the "else" branch

00:16:20.934 --> 00:16:23.467
gets executed
if the "while" loop

00:16:23.467 --> 00:16:24.934
terminates naturally,

00:16:24.934 --> 00:16:26.567
not by a break.

00:16:26.567 --> 00:16:29.000
That is very handy sometimes.

00:16:29.000 --> 00:16:31.868
And the "for" has exactly
the same features.

00:16:31.868 --> 00:16:33.767
Now, "with"
is a relatively new statement,

00:16:33.767 --> 00:16:36.667
so if you want to use it
in 2.5,

00:16:36.667 --> 00:16:40.701
you will require
an import from the future.

00:16:40.701 --> 00:16:44.100
That's how we express
changes in Python

00:16:44.100 --> 00:16:47.200
that are not 100%
backwards compatible.

00:16:47.200 --> 00:16:50.000
We require the programmer

00:16:50.000 --> 00:16:52.667
to import them
from the future.

00:16:52.667 --> 00:16:55.868
That's because "with"
has become a keyword

00:16:55.868 --> 00:16:57.267
with this feature.

00:16:57.267 --> 00:16:59.267
We'll deal with that

00:16:59.267 --> 00:17:01.767
when we treat exception.

00:17:01.767 --> 00:17:03.367
But it's a very important--

00:17:03.367 --> 00:17:07.801
It's a very important
new control statement.

00:17:07.801 --> 00:17:09.534
So then we have data.

00:17:09.534 --> 00:17:11.767
We have simple types
and container types

00:17:11.767 --> 00:17:13.367
that are built in.

00:17:13.367 --> 00:17:15.601
Simple types
are all immutable,

00:17:15.601 --> 00:17:17.834
that is the number 23
is the number 23

00:17:17.834 --> 00:17:19.300
is the number 23,

00:17:19.300 --> 00:17:21.200
and it will never
be any other number.

00:17:21.200 --> 00:17:23.133
The name that you're using

00:17:23.133 --> 00:17:24.734
at some point
to refer to 23,

00:17:24.734 --> 00:17:26.801
you can use later
to refer to 24.

00:17:26.801 --> 00:17:29.501
That doesn't mean
you've changed the number.

00:17:29.501 --> 00:17:32.968
The mathematicians
would never approve.

00:17:32.968 --> 00:17:34.300
Uh, one thing I should notice

00:17:34.300 --> 00:17:36.167
is that Python
has complex numbers,

00:17:36.167 --> 00:17:37.834
which is very unusual
these days.

00:17:37.834 --> 00:17:39.901
It used to be standard.

00:17:39.901 --> 00:17:42.667
That's maybe part of why
Python is so popular

00:17:42.667 --> 00:17:45.334
for scientific computing
as well,

00:17:45.334 --> 00:17:46.934
'cause it's got
complex numbers,

00:17:46.934 --> 00:17:48.334
which are very handy
in some kind

00:17:48.334 --> 00:17:50.200
of technical
and scientific computing.

00:17:50.200 --> 00:17:52.200
And it's got
the star, star operator,

00:17:52.200 --> 00:17:53.634
which is a raise to power,

00:17:53.634 --> 00:17:56.133
which is also
extremely handy.

00:17:56.133 --> 00:17:58.300
Um, and then strings.

00:17:58.300 --> 00:18:00.868
Unfortunately two kinds,
plain and Unicode.

00:18:00.868 --> 00:18:02.767
I say "unfortunately"
because, well,

00:18:02.767 --> 00:18:05.868
it's better than only having
the plain strings like Ruby.

00:18:05.868 --> 00:18:07.701
But it's definitely inferior

00:18:07.701 --> 00:18:10.634
to only having
the Unicode strings like Java

00:18:10.634 --> 00:18:12.601
because these days

00:18:12.601 --> 00:18:15.067
we all want to have
internationalized stuff.

00:18:15.067 --> 00:18:17.601
This means you should
support Unicode.

00:18:17.601 --> 00:18:19.234
This is a big simplification

00:18:19.234 --> 00:18:20.901
that we're doing
in Python three,

00:18:20.901 --> 00:18:22.501
which is now in alpha.

00:18:22.501 --> 00:18:24.100
It's gonna be
in beta soon.

00:18:24.100 --> 00:18:25.767
Removing the distinction

00:18:25.767 --> 00:18:29.367
and only having Unicode strings
just like Java.

00:18:29.367 --> 00:18:32.400
You can concatenate,
repeat, format.

00:18:32.400 --> 00:18:36.367
Format is like
a "printf" in C.

00:18:36.367 --> 00:18:38.934
It's a very rich language.

00:18:38.934 --> 00:18:41.467
And they're
immutable sequences.

00:18:41.467 --> 00:18:44.300
So you can take the length.

00:18:44.300 --> 00:18:46.000
You can use brackets
to index or slice.

00:18:46.000 --> 00:18:48.701
You can do a "for" loop.

00:18:48.701 --> 00:18:50.634
And just like in Java script,

00:18:50.634 --> 00:18:53.300
each item in a string
is a character

00:18:53.300 --> 00:18:54.834
but there's
no character types,

00:18:54.834 --> 00:18:57.200
so each character
is a length-one string.

00:18:57.200 --> 00:18:59.033
Take care about that.

00:18:59.033 --> 00:19:02.033
And of course there's
a huge amount of methods.

00:19:02.033 --> 00:19:04.100
How do you find out
all the methods

00:19:04.100 --> 00:19:06.000
that you can use
on a Python string?

00:19:06.000 --> 00:19:08.868
Well, this is how you discover
a method on anything.

00:19:08.868 --> 00:19:11.267
You do the,
at the interactive prompt,

00:19:11.267 --> 00:19:13.100
dir, D-I-R,

00:19:13.100 --> 00:19:15.200
of the object
you are interested in.

00:19:15.200 --> 00:19:17.434
In this case,
quote, something, quote.

00:19:17.434 --> 00:19:20.934
And you get
a huge list of names

00:19:20.934 --> 00:19:23.501
of all the attributes,
including methods,

00:19:23.501 --> 00:19:25.033
of that object.

00:19:25.033 --> 00:19:26.501
You will notice
that a lot of them

00:19:26.501 --> 00:19:28.367
have two underscores
before and after.

00:19:28.367 --> 00:19:30.367
We'll come back to that
in the second part.

00:19:30.367 --> 00:19:32.133
And others
are just identifiers,

00:19:32.133 --> 00:19:34.200
like "center."

00:19:34.200 --> 00:19:35.868
So now you ask yourself,

00:19:35.868 --> 00:19:37.300
so what's that "center" thing?

00:19:37.300 --> 00:19:40.067
And this
is where help comes.

00:19:40.067 --> 00:19:43.634
You can "help,
open paren,

00:19:43.634 --> 00:19:44.901
something you want
help about."

00:19:44.901 --> 00:19:46.634
Note that is not center.

00:19:46.634 --> 00:19:48.701
It's "some string, dot, center."

00:19:48.701 --> 00:19:51.434
Because you want
the attribute or method

00:19:51.434 --> 00:19:53.501
center of a string,

00:19:53.501 --> 00:19:54.968
not of some other object.

00:19:54.968 --> 00:19:56.868
So you have to say that.

00:19:56.868 --> 00:19:59.000
And this is what it tells you.

00:19:59.000 --> 00:20:00.834
It's return string

00:20:00.834 --> 00:20:03.033
centered in a string
of a certain length,

00:20:03.033 --> 00:20:04.868
padded in a certain way.

00:20:04.868 --> 00:20:09.000
Once you've found out
the basic guidance,

00:20:09.000 --> 00:20:11.000
well, then you experiment.

00:20:11.000 --> 00:20:13.634
That's what the interactive
interpreter is from.

00:20:13.634 --> 00:20:16.968
You try "center"
with a fill character

00:20:16.968 --> 00:20:18.968
that's more visible,
like a plus.

00:20:18.968 --> 00:20:21.567
And yes, "ciao"
in a field of ten

00:20:21.567 --> 00:20:23.801
is "three plusses,
ciao, three plusses."

00:20:23.801 --> 00:20:25.601
In field of three,
does it truncate?

00:20:25.601 --> 00:20:27.634
No, it leaves it alone.

00:20:27.634 --> 00:20:29.701
What if the field is odd?

00:20:29.701 --> 00:20:32.701
Well, the extra one goes
at the beginning and so on.

00:20:32.701 --> 00:20:36.133
You don't find all of these
finely detailed in "help."

00:20:36.133 --> 00:20:38.234
You do find them
in "Python in a Nutshell,"

00:20:38.234 --> 00:20:39.567
plug, plug.

00:20:39.567 --> 00:20:41.434
But you don't need it

00:20:41.434 --> 00:20:44.100
because you can always
find them out interactively,

00:20:44.100 --> 00:20:45.601
experimentally.

00:20:45.601 --> 00:20:47.234
And that's a great way
to learn things

00:20:47.234 --> 00:20:48.868
because you actually
try them out.

00:20:48.868 --> 00:20:50.167
Learn by doing.

00:20:50.167 --> 00:20:52.067
And then we have
container types.

00:20:52.067 --> 00:20:53.934
Container types
include tuple,

00:20:53.934 --> 00:20:55.501
which are immutable sequences,

00:20:55.501 --> 00:20:57.634
and lists,
which are mutable sequences.

00:20:57.634 --> 00:20:59.601
They're typically denoted
with parenthesis

00:20:59.601 --> 00:21:01.701
versus square brackets.

00:21:01.701 --> 00:21:03.434
You also need a comma here,

00:21:03.434 --> 00:21:05.434
otherwise "(23)."

00:21:05.434 --> 00:21:07.634
would just be
the number 23

00:21:07.634 --> 00:21:10.701
because the parenthesis
are used in expressions as well.

00:21:10.701 --> 00:21:12.734
You don't need,
although you could have,

00:21:12.734 --> 00:21:14.334
an extra comma here.

00:21:14.334 --> 00:21:16.334
And then we have
set in frozenzet,

00:21:16.334 --> 00:21:19.167
which are mutable
and immutable

00:21:19.167 --> 00:21:21.234
simple hash tables,

00:21:21.234 --> 00:21:23.334
just collections of stuff.

00:21:23.334 --> 00:21:25.367
And then you have the dict,
or dictionary,

00:21:25.367 --> 00:21:29.367
which is a map from key
to value by a hash table.

00:21:29.367 --> 00:21:31.567
And all containers
have a length,

00:21:31.567 --> 00:21:33.100
number of items in them.

00:21:33.100 --> 00:21:34.834
You can loop
on each of them.

00:21:34.834 --> 00:21:37.901
And you can check if something
is part of the container,

00:21:37.901 --> 00:21:39.400
membership testing.

00:21:39.400 --> 00:21:41.033
Typically every container

00:21:41.033 --> 00:21:42.901
has many, many, many,
many methods.

00:21:42.901 --> 00:21:45.000
And in case of sets,
also some operators

00:21:45.000 --> 00:21:49.000
'cause you can do union
and intersection of sets.

00:21:49.000 --> 00:21:50.501
Sequences in particular

00:21:50.501 --> 00:21:52.834
are lists and tuples
as well as strings.

00:21:52.834 --> 00:21:55.601
You can multiply
by an integer,

00:21:55.601 --> 00:21:58.234
meaning repeat them
a certain number of times.

00:21:58.234 --> 00:22:00.300
And you can concatenate.

00:22:00.300 --> 00:22:03.234
You can concatenate
two sequences of the same type.

00:22:03.234 --> 00:22:06.467
You can index by writing
the index in brackets.

00:22:06.467 --> 00:22:08.667
You can slice by writing,

00:22:08.667 --> 00:22:11.501
"start, colon, end"

00:22:11.501 --> 00:22:15.634
and possibly
a third colon step or stride.

00:22:15.634 --> 00:22:20.100
That is, for example,
ciao of 2 is A.

00:22:20.100 --> 00:22:21.901
Indexes always start
from zero,

00:22:21.901 --> 00:22:23.834
so C, I, A.

00:22:23.834 --> 00:22:27.567
Third one instead of two.

00:22:27.567 --> 00:22:31.067
Ciao three to one
by minus one.

00:22:31.067 --> 00:22:33.567
So you start at the three,
which is the O

00:22:33.567 --> 00:22:35.100
and go backwards,

00:22:35.100 --> 00:22:37.467
because we've got
the minus on the stride,

00:22:37.467 --> 00:22:40.534
until you hit
one excluded.

00:22:40.534 --> 00:22:42.767
The end is always excluded.

00:22:42.767 --> 00:22:45.300
If you've read
Andrew Koenig's masterpiece

00:22:45.300 --> 00:22:47.100
"C Traps and Pitfalls"--

00:22:47.100 --> 00:22:48.734
If you haven't,
you should,

00:22:48.734 --> 00:22:50.400
whatever language
you're programming in.

00:22:50.400 --> 00:22:52.467
And if you have,

00:22:52.467 --> 00:22:54.567
you will remember
the chapters he devotes

00:22:54.567 --> 00:22:56.601
to explaining why every loop

00:22:56.601 --> 00:22:59.300
should be start included
and excluded.

00:22:59.300 --> 00:23:04.300
And Python uses
it very widely.

00:23:04.300 --> 00:23:06.667
Now, lists
are mutable sequences.

00:23:06.667 --> 00:23:07.868
Strings are immutable.

00:23:07.868 --> 00:23:10.100
They're built in.

00:23:10.100 --> 00:23:11.400
But lists are mutable,

00:23:11.400 --> 00:23:15.434
meaning you can assign
to an index or a slice.

00:23:15.434 --> 00:23:16.934
Assigning to an indexing

00:23:16.934 --> 00:23:19.067
just means
whatever was there before,

00:23:19.067 --> 00:23:20.801
now there is another thing.

00:23:20.801 --> 00:23:22.133
It's like assigning
to a name.

00:23:22.133 --> 00:23:23.601
Assigning to a slice

00:23:23.601 --> 00:23:25.801
can make the string longer--

00:23:25.801 --> 00:23:27.701
sorry, the list longer
or shorter

00:23:27.701 --> 00:23:30.267
because you can assign
to a slice

00:23:30.267 --> 00:23:32.167
a longer list
than the slice

00:23:32.167 --> 00:23:33.767
or a shorter list
than the slice.

00:23:33.767 --> 00:23:38.934
And things will smoothly
change to suit you.

00:23:38.934 --> 00:23:41.567
Dictionaries and sets
are not sequences.

00:23:41.567 --> 00:23:43.701
There is no intrinsic order.

00:23:43.701 --> 00:23:45.601
As I mentioned,
they're hash tables.

00:23:45.601 --> 00:23:47.267
So they're in whatever order

00:23:47.267 --> 00:23:49.567
is nice for retrieval.

00:23:49.567 --> 00:23:52.501
So there is no slicing

00:23:52.501 --> 00:23:54.567
because there
is no way to say,

00:23:54.567 --> 00:23:56.200
"What's the first
or the second?"

00:23:56.200 --> 00:23:57.567
And so on.

00:23:57.567 --> 00:23:58.901
You can iterate,

00:23:58.901 --> 00:24:00.634
and you will be
given the items

00:24:00.634 --> 00:24:03.734
in a random-looking order.

00:24:03.734 --> 00:24:06.267
There's a method
to this madness,

00:24:06.267 --> 00:24:08.167
but it's the hash function

00:24:08.167 --> 00:24:11.067
so it's far from transparent.

00:24:11.067 --> 00:24:13.100
More about containers.

00:24:13.100 --> 00:24:16.567
Containers have methods
that can be classified

00:24:16.567 --> 00:24:21.400
in two general roles--
mutating and non-mutating.

00:24:21.400 --> 00:24:24.067
A mutating method
typically does its work

00:24:24.067 --> 00:24:26.267
by altering the container,

00:24:26.267 --> 00:24:29.033
inserting something,
removing something.

00:24:29.033 --> 00:24:30.467
And typically
it returns "none"

00:24:30.467 --> 00:24:34.501
because there is no natural
result for that.

00:24:34.501 --> 00:24:39.467
For example, the append
method of list,

00:24:39.467 --> 00:24:40.968
add one at the end.

00:24:40.968 --> 00:24:46.400
The add method of sets
one more item.

00:24:46.400 --> 00:24:48.567
The update
method of dictionary

00:24:48.567 --> 00:24:51.901
merge another dictionary
into this one.

00:24:51.901 --> 00:24:53.467
They will all return "none"

00:24:53.467 --> 00:24:58.133
and change the specific object
in which you're calling them.

00:24:58.133 --> 00:25:01.534
A few mutating methods
have a natural result

00:25:01.534 --> 00:25:03.033
and therefore return it.

00:25:03.033 --> 00:25:05.200
For example, "pop" removes
typically the last,

00:25:05.200 --> 00:25:07.734
but you can tell it which one,

00:25:07.734 --> 00:25:12.267
element of a list
and gives it back to you.

00:25:12.267 --> 00:25:16.267
"Pop" in a dictionary
removes an arbitrary item

00:25:16.267 --> 00:25:18.501
and gives it back to you.

00:25:18.501 --> 00:25:20.701
Setdefault on dictionary,
that's a bit more complicated.

00:25:20.701 --> 00:25:22.267
We'll see an example later.

00:25:22.267 --> 00:25:24.300
But again,
it has a return.

00:25:24.300 --> 00:25:26.033
And then there's
non-mutating methods

00:25:26.033 --> 00:25:28.734
that, like, necessarily
return a result

00:25:28.734 --> 00:25:31.033
because they don't
do any changes.

00:25:31.033 --> 00:25:33.200
Um, sets have a variant

00:25:33.200 --> 00:25:35.567
which only supports
the non-mutating method,

00:25:35.567 --> 00:25:37.601
the frozenset.

00:25:37.601 --> 00:25:39.234
Dictionary doesn't,

00:25:39.234 --> 00:25:42.300
but it has another variant
in module collections,

00:25:42.300 --> 00:25:44.167
which we'll see
in examples later,

00:25:44.167 --> 00:25:46.467
which has a default value.

00:25:46.467 --> 00:25:49.367
Other important containers
in the collections module

00:25:49.367 --> 00:25:50.968
include
the doubled ended queue,

00:25:50.968 --> 00:25:54.000
which basically
is like a list

00:25:54.000 --> 00:25:55.834
but internally
organized differently

00:25:55.834 --> 00:25:59.868
so it's just as fast
to access from either end

00:25:59.868 --> 00:26:02.567
and rotate.

00:26:02.567 --> 00:26:05.100
We don't have
a priority queue

00:26:05.100 --> 00:26:06.567
or heap type.

00:26:06.567 --> 00:26:08.067
We only have functions

00:26:08.067 --> 00:26:11.601
that treat a list
as a priority queue.

00:26:11.601 --> 00:26:13.901
Not sure if you're
familiar with heaps,

00:26:13.901 --> 00:26:18.133
but suppose we,
for some reason, like we're--

00:26:18.133 --> 00:26:20.067
For fanatic Java programmers
and things,

00:26:20.067 --> 00:26:22.100
everything should be wrapped
in a class.

00:26:22.100 --> 00:26:24.834
We want to make
a priority type.

00:26:24.834 --> 00:26:26.133
How do we do that?

00:26:26.133 --> 00:26:28.000
Well, rushing far ahead
to things we'll see

00:26:28.000 --> 00:26:31.133
in the second half,
such as classes and methods

00:26:31.133 --> 00:26:32.400
and modules.

00:26:32.400 --> 00:26:35.100
Well, first of all
we import the "heapq" module,

00:26:35.100 --> 00:26:37.167
which gives us
all the functions we need.

00:26:37.167 --> 00:26:40.934
And then we basically
write a class called "heap"

00:26:40.934 --> 00:26:43.133
and everything get explicitly
from object

00:26:43.133 --> 00:26:44.834
with all the methods
we want.

00:26:44.834 --> 00:26:47.167
Some of them start and end
with double underscores.

00:26:47.167 --> 00:26:49.000
Those are special methods

00:26:49.000 --> 00:26:51.367
which have very special roles.

00:26:51.367 --> 00:26:53.634
Other just identifiers.

00:26:53.634 --> 00:26:56.434
You will notice "self"

00:26:56.434 --> 00:27:00.868
as the first parameter
of each and every method.

00:27:00.868 --> 00:27:02.801
That means
that the object itself

00:27:02.801 --> 00:27:04.300
in which the method
has been called.

00:27:04.300 --> 00:27:06.167
Some are others.

00:27:06.167 --> 00:27:07.868
So, for example,

00:27:07.868 --> 00:27:10.901
we first thing we need to do
is get some content,

00:27:10.901 --> 00:27:13.601
make it into a list,
assign it as a variable,

00:27:13.601 --> 00:27:17.000
and make sure it is a heap.

00:27:17.000 --> 00:27:18.934
To make sure that a list
is a heap,

00:27:18.934 --> 00:27:20.801
"heapq.heapify"

00:27:20.801 --> 00:27:23.868
basically does whatever
permutation is needed.

00:27:23.868 --> 00:27:28.234
And then this makes available
the "push" and "pop" function,

00:27:28.234 --> 00:27:30.167
which keep the heap property,

00:27:30.167 --> 00:27:31.968
the priority heap property,

00:27:31.968 --> 00:27:33.767
adding and removing an item.

00:27:33.767 --> 00:27:35.901
And the replace,

00:27:35.901 --> 00:27:38.167
which does
heap push and a pop.

00:27:38.167 --> 00:27:39.601
So it takes the previous stop

00:27:39.601 --> 00:27:41.701
and puts something else
in its place,

00:27:41.701 --> 00:27:43.033
maintaining the heap property.

00:27:43.033 --> 00:27:45.367
And this basically
would be the hard work.

00:27:45.367 --> 00:27:47.667
And we just need to call
the functions

00:27:47.667 --> 00:27:49.367
"heappush," "heappop,"
and "heapreplace,"

00:27:49.367 --> 00:27:52.434
provided by
the "heapq" module.

00:27:52.434 --> 00:27:54.634
And then
we have some special--

00:27:54.634 --> 00:27:56.834
Okay, "_init_"

00:27:56.834 --> 00:27:58.567
is the initializer.

00:27:58.567 --> 00:28:01.767
So what's the content,
what's the initial content

00:28:01.767 --> 00:28:03.567
of this thing.

00:28:03.567 --> 00:28:06.767
"_len_" is how do I
compute the length

00:28:06.767 --> 00:28:08.267
of this container?

00:28:08.267 --> 00:28:09.834
In disguise, I simply--

00:28:09.834 --> 00:28:12.467
It's the same as the length
of the list it's using.

00:28:12.467 --> 00:28:14.934
How do I iterate
in this containing?

00:28:14.934 --> 00:28:17.367
Same as you iterate
on the list it's using.

00:28:17.367 --> 00:28:19.534
How do I represent
this container?

00:28:19.534 --> 00:28:21.501
In this case,
I'm representing it

00:28:21.501 --> 00:28:24.968
as "heap, open paren,
its contents."

00:28:24.968 --> 00:28:27.133
So representation
of its contents.

00:28:27.133 --> 00:28:29.400
So I could add many more
special methods,

00:28:29.400 --> 00:28:33.801
but basically all I'm doing
is delegating properly.

00:28:33.801 --> 00:28:35.934
The special method
I'm calling

00:28:35.934 --> 00:28:40.200
has underscores
before and behind.

00:28:40.200 --> 00:28:42.334
And I'm delegating
appropriately

00:28:42.334 --> 00:28:44.033
to a built-in function

00:28:44.033 --> 00:28:46.767
that will internally invoke
the special method

00:28:46.767 --> 00:28:49.801
on this other list.

00:28:49.801 --> 00:28:52.801
I also have truthiness.

00:28:52.801 --> 00:28:56.100
Comparisons, tests,
and truth-like value.

00:28:56.100 --> 00:28:58.367
I can do
all the normal comparisons.

00:28:58.367 --> 00:29:01.334
You will have to be away
of the distinction

00:29:01.334 --> 00:29:04.133
between equality
and identity.

00:29:04.133 --> 00:29:06.634
It's spelled "two equals"
versus "is"

00:29:06.634 --> 00:29:09.834
as opposed to three equals
as in other languages.

00:29:09.834 --> 00:29:11.667
Orders of course.

00:29:11.667 --> 00:29:15.367
Membership is also considered
an elementary comparison.

00:29:15.367 --> 00:29:17.367
And you can chain comparisons.

00:29:17.367 --> 00:29:19.167
That's pretty special
to Python.

00:29:19.167 --> 00:29:23.868
So the expression
"3 &lt; = X &lt; 9"

00:29:23.868 --> 00:29:26.367
means exactly
what it should obviously mean.

00:29:26.367 --> 00:29:28.501
X is at the same time

00:29:28.501 --> 00:29:31.000
greater or equal three
and less than nine.

00:29:31.000 --> 00:29:34.000
It goes left to right.

00:29:34.000 --> 00:29:36.400
So like in Java script,

00:29:36.400 --> 00:29:38.133
the falsy concept

00:29:38.133 --> 00:29:39.934
applies to any number
that's zero,

00:29:39.934 --> 00:29:43.367
an empty string, none,
and empty container,

00:29:43.367 --> 00:29:45.467
and the special value False

00:29:45.467 --> 00:29:47.267
with an uppercase F here,

00:29:47.267 --> 00:29:51.167
which is the same thing
as the bool of zero.

00:29:51.167 --> 00:29:52.634
And everything else is true.

00:29:52.634 --> 00:29:54.367
That's a very optimistic
view of life.

00:29:54.367 --> 00:29:55.968
It's mostly everything true

00:29:55.968 --> 00:29:58.667
except some very few
special objects

00:29:58.667 --> 00:30:01.067
specifically identified
as false.

00:30:01.067 --> 00:30:03.100
And then
there's some operator

00:30:03.100 --> 00:30:04.801
like "and," "or," "not."

00:30:04.801 --> 00:30:06.167
We all spell them out.

00:30:06.167 --> 00:30:08.334
Remember, we don't
really like punctuation.

00:30:08.334 --> 00:30:12.100
So what you would spell
as "&amp;&amp;" in C,

00:30:12.100 --> 00:30:15.400
you'll spell "A-N-D"
in Python.

00:30:15.400 --> 00:30:17.234
But the semantics
are the same.

00:30:17.234 --> 00:30:20.467
And then if you want to do
on more than two at a time,

00:30:20.467 --> 00:30:22.334
you can use "any" and "all"

00:30:22.334 --> 00:30:24.834
to return
a Boolean value.

00:30:24.834 --> 00:30:27.400
So we'll see some examples.

00:30:27.400 --> 00:30:29.901
Okay, exceptions,
kind of like in Java.

00:30:29.901 --> 00:30:34.133
Accept that some anomalies
that are not really errors

00:30:34.133 --> 00:30:36.367
should also
raise an exception.

00:30:36.367 --> 00:30:39.334
And you can also raise them
explicitly with "raise."

00:30:39.334 --> 00:30:41.434
When you raise an exception,

00:30:41.434 --> 00:30:43.267
assuming nothing
is catching it,

00:30:43.267 --> 00:30:45.267
it keeps going
along the call stack

00:30:45.267 --> 00:30:47.300
killing functions
as it goes.

00:30:47.300 --> 00:30:50.901
It's kind of scary,
horror, movie-like image.

00:30:50.901 --> 00:30:52.234
And if it goes all the way,

00:30:52.234 --> 00:30:57.868
the whole program,
the whole world gets destroyed.

00:30:57.868 --> 00:30:59.934
Um, "try/except,"

00:30:59.934 --> 00:31:02.067
as opposed to "try/catch"
as in other languages,

00:31:02.067 --> 00:31:06.701
is how you make sure
that anything happening,

00:31:06.701 --> 00:31:09.667
any exception raised
in the try clause,

00:31:09.667 --> 00:31:15.167
is handled
in the proper way.

00:31:15.167 --> 00:31:17.267
"Try/final" is exactly
like in Java,

00:31:17.267 --> 00:31:19.501
but is whatever exception

00:31:19.501 --> 00:31:21.934
or non-exception
is happening in the try

00:31:21.934 --> 00:31:25.234
make sure that at the very end
you do this and that.

00:31:25.234 --> 00:31:28.200
And then we have
the new "with" statement.

00:31:28.200 --> 00:31:30.367
I'm particularly
fond of it.

00:31:30.367 --> 00:31:32.601
It implements an idiom

00:31:32.601 --> 00:31:35.567
which is very familiar
to C++ programmers--

00:31:35.567 --> 00:31:41.200
resource acquisition
is initialization,

00:31:41.200 --> 00:31:43.901
which is misspelled here.

00:31:43.901 --> 00:31:46.300
It's R-A-I-I.

00:31:46.300 --> 00:31:48.767
Or "as initialization"
instead of "is"

00:31:48.767 --> 00:31:50.400
works just as well

00:31:50.400 --> 00:31:53.067
as saves me from admitting
to a misspelling.

00:31:53.067 --> 00:31:58.167
So since it makes with,
W-I-T-H, into a keyword,

00:31:58.167 --> 00:32:01.901
to make sure we don't break
compatibility with the past,

00:32:01.901 --> 00:32:04.667
it's only enabled it
at the very top of the module

00:32:04.667 --> 00:32:08.901
you start with "from future
import with statement."

00:32:08.901 --> 00:32:13.367
And future has underscores
below before and after

00:32:13.367 --> 00:32:18.667
just to make sure it's
obviously a very special case.

00:32:18.667 --> 00:32:21.033
So if you do that,

00:32:21.033 --> 00:32:25.801
you can, um, make sure

00:32:25.801 --> 00:32:28.434
that something is initialized

00:32:28.434 --> 00:32:30.701
at the start of a block

00:32:30.701 --> 00:32:33.601
and properly finalized
when that block's exit.

00:32:33.601 --> 00:32:35.367
No matter how it exits.

00:32:35.367 --> 00:32:38.033
So it's syntactically
very elegant

00:32:38.033 --> 00:32:43.367
but semantically just like
a try/finally.

00:32:43.367 --> 00:32:46.234
The nice thing
is that the finalizer

00:32:46.234 --> 00:32:49.534
is something that you can code
once and for all.

00:32:49.534 --> 00:32:52.634
In C++ you do it
as a destructor.

00:32:52.634 --> 00:32:57.133
In Python we want
to distinguish two cases

00:32:57.133 --> 00:33:00.067
or let it distinguish
two cases.

00:33:00.067 --> 00:33:02.267
Is the object being finalized

00:33:02.267 --> 00:33:04.734
after a normal termination?

00:33:04.734 --> 00:33:08.934
Or is it being finalized
after an exception propagates?

00:33:08.934 --> 00:33:10.767
C++ doesn't
let you distinguish.

00:33:10.767 --> 00:33:12.734
A destructor is a destructor
is a destructor.

00:33:12.734 --> 00:33:15.467
You have to resort
to horrid tricks.

00:33:15.467 --> 00:33:18.133
But it's obvious that
you do want to distinguish.

00:33:18.133 --> 00:33:20.968
Consider a transaction
in a database.

00:33:20.968 --> 00:33:22.634
Well, you want to know
whether the transaction

00:33:22.634 --> 00:33:24.901
is done correctly
or incorrectly,

00:33:24.901 --> 00:33:28.067
'cause in one case
you do end work and commit

00:33:28.067 --> 00:33:30.434
and in the other one
you want to roll back, okay?

00:33:30.434 --> 00:33:33.400
You can't do that
with RAAI in C++,

00:33:33.400 --> 00:33:34.567
but you can in Python

00:33:34.567 --> 00:33:37.467
because the exit special method

00:33:37.467 --> 00:33:40.133
gets stalled whether
an exception has occurred.

00:33:40.133 --> 00:33:44.534
So let me give some examples.

00:33:44.534 --> 00:33:46.868
This is the most simple one.

00:33:46.868 --> 00:33:51.000
With open some file
as F.

00:33:51.000 --> 00:33:53.067
Use F as you will.

00:33:53.067 --> 00:33:54.868
In this case,
I'm looping over the file,

00:33:54.868 --> 00:33:56.300
so I'm getting a line
at a time

00:33:56.300 --> 00:33:58.567
and printing
the third character,

00:33:58.567 --> 00:34:00.534
actually the fourth one.

00:34:00.534 --> 00:34:03.868
Suppose this either
ends normally

00:34:03.868 --> 00:34:05.801
because the file is done

00:34:05.801 --> 00:34:07.767
or it raises an exception

00:34:07.767 --> 00:34:09.601
because there's a line
that's too short.

00:34:09.601 --> 00:34:12.934
So a line of three
is out of bounds indexing.

00:34:12.934 --> 00:34:17.334
No matter what,
F gets closed

00:34:17.334 --> 00:34:19.834
at the end of this block.

00:34:19.834 --> 00:34:21.167
Similarly,

00:34:21.167 --> 00:34:24.133
say you have a lock somewhere
in a threading system,

00:34:24.133 --> 00:34:26.868
"with the lock do something"

00:34:26.868 --> 00:34:28.801
means the lock gets acquired

00:34:28.801 --> 00:34:31.734
before the critical section
is entered

00:34:31.734 --> 00:34:34.534
and will always get released
as soon as this is done

00:34:34.534 --> 00:34:37.968
no matter whether
it's smooth or not.

00:34:37.968 --> 00:34:39.801
And this one--

00:34:39.801 --> 00:34:42.601
The "contextlib"
is a method that is a module

00:34:42.601 --> 00:34:45.100
from the central library
that gives you all kind of tools

00:34:45.100 --> 00:34:46.801
to do these kind of things.

00:34:46.801 --> 00:34:48.534
But it's basically--

00:34:48.534 --> 00:34:50.934
"Closing" makes sure

00:34:50.934 --> 00:34:54.634
that the close is called
at the end of the block.

00:34:54.634 --> 00:34:57.000
So you do a connection
to a database

00:34:57.000 --> 00:34:58.501
and open a cursor.

00:34:58.501 --> 00:35:00.067
And make sure
the cursor is closed

00:35:00.067 --> 00:35:03.601
and the database connection
is closed.

00:35:03.601 --> 00:35:06.767
So one peculiarity
of Python

00:35:06.767 --> 00:35:10.067
is we love to have
a simple statement,

00:35:10.067 --> 00:35:11.701
a high level statement,

00:35:11.701 --> 00:35:14.334
explaining terms
of lower level ones.

00:35:14.334 --> 00:35:16.801
So this is what "for" means.

00:35:16.801 --> 00:35:19.467
It means make
an iterator and loop,

00:35:19.467 --> 00:35:21.834
calling the next method
of the iterator

00:35:21.834 --> 00:35:24.400
until a stop iteration
exception,

00:35:24.400 --> 00:35:26.701
in this case terminate.

00:35:26.701 --> 00:35:30.100
We also have syntax
to use this as expression,

00:35:30.100 --> 00:35:32.934
as a simple expression
like that.

00:35:32.934 --> 00:35:35.434
A certain expression
for everything

00:35:35.434 --> 00:35:38.067
in a certain iterable
with optional clauses.

00:35:38.067 --> 00:35:39.767
Or if you use brackets,

00:35:39.767 --> 00:35:41.300
then you make a list
out of it,

00:35:41.300 --> 00:35:43.667
and it's called
"the list comprehension."

00:35:43.667 --> 00:35:48.534
And let me give some example
of using general expressions

00:35:48.534 --> 00:35:51.067
with accumulators,

00:35:51.067 --> 00:35:53.534
that is function that can
take any number of items

00:35:53.534 --> 00:35:56.000
and basically
process them all.

00:35:56.000 --> 00:35:58.167
One of the simplest
is "sum".

00:35:58.167 --> 00:36:00.968
Give sum any collection
of numbers,

00:36:00.968 --> 00:36:03.767
it will just sum them all
and return the sum.

00:36:03.767 --> 00:36:06.367
So how do we know
how many items

00:36:06.367 --> 00:36:08.634
say of any generic
type of class?

00:36:08.634 --> 00:36:10.434
It may not support
the length.

00:36:10.434 --> 00:36:13.734
Well, we sum one
for everything in the item.

00:36:13.734 --> 00:36:15.267
So we basically count.

00:36:15.267 --> 00:36:16.934
It's as simple as that.

00:36:16.934 --> 00:36:20.767
And then we can call it
on the generic expression.

00:36:20.767 --> 00:36:21.934
See?

00:36:21.934 --> 00:36:24.868
Every X in the range
from zero--

00:36:24.868 --> 00:36:26.501
0 included
from 99 excluded,

00:36:26.501 --> 00:36:27.734
which equal--

00:36:27.734 --> 00:36:31.434
which module five
equals itself, module seven.

00:36:31.434 --> 00:36:32.767
Very simple.

00:36:32.767 --> 00:36:34.434
Other accumulators,

00:36:34.434 --> 00:36:36.300
"any," I mentioned it before.

00:36:36.300 --> 00:36:38.767
Is any X greater than five

00:36:38.767 --> 00:36:40.501
among the Xs?

00:36:40.501 --> 00:36:43.133
See how natural this is.

00:36:43.133 --> 00:36:48.133
Our all(X &gt; Y&gt; Z)
for X, Y, Z.

00:36:48.133 --> 00:36:52.400
"Zip" is for parallel iteration
along containers.

00:36:52.400 --> 00:36:53.801
It actually makes a list.

00:36:53.801 --> 00:36:57.234
So you can use
the itertools,

00:36:57.234 --> 00:36:59.968
which gives you
an iterator zip, "izip."

00:36:59.968 --> 00:37:02.567
And in this case,
it must be the same context.

00:37:02.567 --> 00:37:04.667
Other example, "max."

00:37:04.667 --> 00:37:08.467
What's the highest index
at which

00:37:08.467 --> 00:37:10.234
there is a positive number?

00:37:10.234 --> 00:37:12.434
"Enumerate" given a sequence,

00:37:12.434 --> 00:37:15.567
gives you the index, item,
index, item, index, item.

00:37:15.567 --> 00:37:17.334
So you loop on index
and item

00:37:17.334 --> 00:37:19.567
and take the highest I

00:37:19.567 --> 00:37:25.067
for which X is greater
than zero.

00:37:25.067 --> 00:37:31.133
And this takes us
to halfway point.

00:37:31.133 --> 00:37:34.934
So we do have
three minutes and 51 seconds

00:37:34.934 --> 00:37:37.033
before formal break.

00:37:37.033 --> 00:37:39.300
So if there's any questions

00:37:39.300 --> 00:37:41.601
that you'd rather ask now

00:37:41.601 --> 00:37:43.133
rather than an hour from now,

00:37:43.133 --> 00:37:48.067
please go to the mike
and we'll do that.

00:37:48.067 --> 00:37:50.334
Well, if there's
no question,

00:37:50.334 --> 00:37:52.601
I can take a short break.

00:37:52.601 --> 00:37:54.534
[applause]

