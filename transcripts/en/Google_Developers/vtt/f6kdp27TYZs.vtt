WEBVTT
Kind: captions
Language: en

00:00:04.320 --> 00:00:05.920
ROB PIKE: Hi, everyone.

00:00:05.920 --> 00:00:06.690
Wow.

00:00:06.690 --> 00:00:09.030
Voice is always so big.

00:00:09.030 --> 00:00:09.980
Thanks for coming.

00:00:09.980 --> 00:00:14.470
I'm going to be talking today
about Go concurrency patterns.

00:00:14.470 --> 00:00:20.140
My name is Rob Pike, and I work
on the Go team at Google.

00:00:20.140 --> 00:00:22.720
First of all, let me give
us a little background.

00:00:22.720 --> 00:00:27.570
When Go came out in November of
2009, a lot of people were

00:00:27.570 --> 00:00:32.240
immediately fascinated by the
features of Go that provided

00:00:32.240 --> 00:00:33.820
concurrency, and wanted
to play with

00:00:33.820 --> 00:00:35.870
them and goof around.

00:00:35.870 --> 00:00:38.020
But also, a lot of people had
questions about them.

00:00:38.020 --> 00:00:40.270
And there's a question
about why

00:00:40.270 --> 00:00:41.890
concurrency's even in the language.

00:00:41.890 --> 00:00:45.090
What exactly do I mean
by concurrency?

00:00:45.090 --> 00:00:47.060
What is the origin
of the ideas?

00:00:47.060 --> 00:00:49.040
And what is it all useful for?

00:00:49.040 --> 00:00:51.070
And today I'm going to talk
about all those things, but

00:00:51.070 --> 00:00:53.050
I'm mostly going to talk about
how you use the features.

00:00:53.050 --> 00:00:55.110
But I need to give you
a little background.

00:00:55.110 --> 00:00:59.680
So if you look around in the
world at large, what you see

00:00:59.680 --> 00:01:02.050
is a lot of independently
executing things.

00:01:02.050 --> 00:01:04.519
You see people in the audience
doing their own thing,

00:01:04.519 --> 00:01:07.720
tweeting while I'm talking
and stuff like that.

00:01:07.720 --> 00:01:10.280
There's people outside,
there's cars going by.

00:01:10.280 --> 00:01:13.230
All those things are independent
agents, if you

00:01:13.230 --> 00:01:15.010
will, inside the world.

00:01:15.010 --> 00:01:18.280
And if you think about writing
a computer program, if you

00:01:18.280 --> 00:01:21.870
want to simulate or interact
with that environment, a

00:01:21.870 --> 00:01:25.670
single sequential execution is
not a very good approach.

00:01:25.670 --> 00:01:29.540
And so concurrency is really a
way of writing or structuring

00:01:29.540 --> 00:01:33.670
your program to deal with
the real world.

00:01:33.670 --> 00:01:37.260
And what I mean by concurrency,
we define as the

00:01:37.260 --> 00:01:41.680
composition of independently
executing computations.

00:01:41.680 --> 00:01:44.670
And I want to stress that
concurrency is a way of

00:01:44.670 --> 00:01:46.720
structuring software.

00:01:46.720 --> 00:01:49.540
It's a way of thinking about how
to write clean code that

00:01:49.540 --> 00:01:52.870
can interact with the real
world, and maybe simulate the

00:01:52.870 --> 00:01:55.940
real world or behave as an agent
inside the real world,

00:01:55.940 --> 00:02:00.090
and be a good actor in
that environment.

00:02:00.090 --> 00:02:02.320
Concurrency is really
not parallelism.

00:02:02.320 --> 00:02:04.620
Although a lot of people got
confused by that, and I think

00:02:04.620 --> 00:02:09.259
when Go first launched, a lot
of people thought Go was a

00:02:09.259 --> 00:02:10.220
parallel language.

00:02:10.220 --> 00:02:11.280
It's not really a parallel
language.

00:02:11.280 --> 00:02:12.560
It's a concurrent one.

00:02:12.560 --> 00:02:15.130
And one to realize the
difference is to imagine--

00:02:15.130 --> 00:02:17.290
if you have a concurrent piece
of code that you've written

00:02:17.290 --> 00:02:19.940
that uses the concurrency
features of Go or any other

00:02:19.940 --> 00:02:22.310
concurrent language, but you
only run it on a single

00:02:22.310 --> 00:02:25.360
processor, then it's certainly
not a parallel program,

00:02:25.360 --> 00:02:28.010
because it's not executing
anything in parallel.

00:02:28.010 --> 00:02:29.890
But it can still have concurrent
structure.

00:02:29.890 --> 00:02:31.680
And even on a single processor,
that could be a

00:02:31.680 --> 00:02:34.010
useful way to model the
way this stuff works.

00:02:34.010 --> 00:02:37.220
Now I actually give a talk at
the beginning of the year at a

00:02:37.220 --> 00:02:40.320
Heroku conference, which you can
find online, where I talk

00:02:40.320 --> 00:02:42.910
about in great detail about what
the difference is between

00:02:42.910 --> 00:02:44.060
concurrency and parallelism.

00:02:44.060 --> 00:02:45.700
I don't want to spend too
much time on it today.

00:02:45.700 --> 00:02:47.830
But I want to stress that I'm
talking about concurrency

00:02:47.830 --> 00:02:50.170
here, not parallelism.

00:02:50.170 --> 00:02:53.330
And just to stress this,
concurrency is a model for

00:02:53.330 --> 00:02:54.650
software construction.

00:02:54.650 --> 00:02:57.870
And the reason it's valuable is
that to interact with the

00:02:57.870 --> 00:03:00.360
real world, you have to figure
out how to write your software

00:03:00.360 --> 00:03:01.180
to do that.

00:03:01.180 --> 00:03:04.490
And concurrency and features
provided by Go, but also in

00:03:04.490 --> 00:03:06.960
other languages, are
easy to understand.

00:03:06.960 --> 00:03:08.010
They're easy to use.

00:03:08.010 --> 00:03:09.600
They're easy to reason about--

00:03:09.600 --> 00:03:12.030
which is really important,
because you don't need to be

00:03:12.030 --> 00:03:13.730
an expert to use them.

00:03:13.730 --> 00:03:15.790
You can use the concurrency
features of Go without

00:03:15.790 --> 00:03:18.520
understanding all of the
minutiae of memory barriers

00:03:18.520 --> 00:03:21.310
and threads and condition
variables and all the other

00:03:21.310 --> 00:03:25.140
stuff that people often think
of as the standard way to

00:03:25.140 --> 00:03:28.490
program parallel or concurrent
applications.

00:03:28.490 --> 00:03:29.215
It's just not true.

00:03:29.215 --> 00:03:32.120
You can work at a much higher
level and make it a lot easier

00:03:32.120 --> 00:03:32.750
for yourself.

00:03:32.750 --> 00:03:35.580
And in fact, a lot of people
have used Go to write

00:03:35.580 --> 00:03:37.370
concurrent programs who've
never done concurrent

00:03:37.370 --> 00:03:39.550
programming before, and they
find it's actually

00:03:39.550 --> 00:03:41.670
quite easy to do.

00:03:41.670 --> 00:03:45.080
Now to many people, as I said,
when Go came out, the

00:03:45.080 --> 00:03:47.260
concurrency stuff seems kind
of new and intriguing.

00:03:47.260 --> 00:03:49.710
It's not actually totally
original.

00:03:49.710 --> 00:03:53.800
In fact, there's a very long
history of concurrent ideas

00:03:53.800 --> 00:03:56.670
and programming languages that
leads towards Go, and I've

00:03:56.670 --> 00:03:57.970
listed some of them here.

00:03:57.970 --> 00:04:00.950
The most important one is
a seminal paper, which I

00:04:00.950 --> 00:04:03.360
actually recommend every
computer programmer in the

00:04:03.360 --> 00:04:07.590
world should read, is by Tony
Hoare, in 1978, called

00:04:07.590 --> 00:04:10.720
"Communicating Sequential
Processes." And that is the

00:04:10.720 --> 00:04:11.620
fundamental paper.

00:04:11.620 --> 00:04:14.010
All the real ideas
are in there.

00:04:14.010 --> 00:04:16.890
And all these other languages
build on the ideas from that

00:04:16.890 --> 00:04:19.510
paper to construct real
programming environments.

00:04:19.510 --> 00:04:23.600
Probably the most original
language that came out of this

00:04:23.600 --> 00:04:25.355
was this thing called Occam,
which was the programming

00:04:25.355 --> 00:04:26.610
language for the transputer.

00:04:26.610 --> 00:04:28.420
It came out in the early '80s.

00:04:28.420 --> 00:04:30.520
You've mostly probably
heard of Erlang.

00:04:30.520 --> 00:04:34.750
And there's another branch that
I had a role in, with

00:04:34.750 --> 00:04:38.160
languages like Newsqueak
and Limbo.

00:04:38.160 --> 00:04:40.520
There's also Concurrent ML, done
by John Reppy, which is

00:04:40.520 --> 00:04:41.550
actually a lovely language.

00:04:41.550 --> 00:04:43.260
It's a functional language,
but it's concurrent.

00:04:43.260 --> 00:04:47.480
It's kind of amazing, but it's
another level of intellectual

00:04:47.480 --> 00:04:50.750
depth that some programmers
aren't as comfortable with.

00:04:50.750 --> 00:04:53.390
But it is a beautiful
language.

00:04:53.390 --> 00:04:58.080
Go is on the branch of the
Newsqueak-Limbo-Alef sequence.

00:04:58.080 --> 00:05:00.630
And the thing that distinguishes
them from most

00:05:00.630 --> 00:05:04.050
of these others is that it has
the idea of a channel as a

00:05:04.050 --> 00:05:05.680
first-class value.

00:05:05.680 --> 00:05:08.440
In the original Hoare CSP, you
communicated directly with a

00:05:08.440 --> 00:05:11.270
process by name, and that's
essentially the way Erlang

00:05:11.270 --> 00:05:12.770
still works today.

00:05:12.770 --> 00:05:15.260
But in Go, instead you don't
talk to a process.

00:05:15.260 --> 00:05:18.540
You talk to a channel, and the
other end of that channel is

00:05:18.540 --> 00:05:20.680
some other thing that could be
reading the values that you're

00:05:20.680 --> 00:05:22.000
sending to it.

00:05:22.000 --> 00:05:25.970
And one way to understand that
distinction is that the Erlang

00:05:25.970 --> 00:05:29.290
original CSP idea is a little
bit like writing to a file by

00:05:29.290 --> 00:05:32.750
name, whereas in Go, the channel
idea is more like

00:05:32.750 --> 00:05:34.560
writing to a file descriptor.

00:05:34.560 --> 00:05:36.720
And the level of indirection
that it provides is actually

00:05:36.720 --> 00:05:39.710
kind of important to a lot
of things that get done.

00:05:39.710 --> 00:05:42.510
But I want to stress that
one model isn't

00:05:42.510 --> 00:05:43.400
better than the other.

00:05:43.400 --> 00:05:45.380
They're actually formally
equivalent.

00:05:45.380 --> 00:05:48.060
You can write one form in
terms of the other.

00:05:48.060 --> 00:05:51.320
But Go definitely is
about channels.

00:05:51.320 --> 00:05:54.350
So enough of this sort of
theoretical nonsense.

00:05:54.350 --> 00:05:57.580
Let's actually show some code.

00:05:57.580 --> 00:05:59.880
Now one of the problems with
illustrating concurrent

00:05:59.880 --> 00:06:02.490
programming is that the ideas
tend to be subtle if you've

00:06:02.490 --> 00:06:04.440
never seen them before.

00:06:04.440 --> 00:06:06.770
And people tend to write
complicated examples to

00:06:06.770 --> 00:06:07.340
demonstrate them.

00:06:07.340 --> 00:06:08.420
And I don't want to do that.

00:06:08.420 --> 00:06:11.390
So instead, I'm going to make
all of my code today be around

00:06:11.390 --> 00:06:12.750
really boring things.

00:06:12.750 --> 00:06:14.580
So these are going to be really
boring programs, but

00:06:14.580 --> 00:06:16.280
they're going to use concurrency
to make the boring

00:06:16.280 --> 00:06:17.520
a little less interesting.

00:06:17.520 --> 00:06:20.970
And this gives it a focus on
the concurrency rather than

00:06:20.970 --> 00:06:22.630
the boring elements that
are actually being made

00:06:22.630 --> 00:06:23.300
concurrent.

00:06:23.300 --> 00:06:25.570
So here's a particularly
boring program.

00:06:25.570 --> 00:06:27.720
All it does is print very
slowly, once per

00:06:27.720 --> 00:06:28.900
second, la la la.

00:06:28.900 --> 00:06:31.400
Now I'd like to stress,
actually, what's going on here

00:06:31.400 --> 00:06:33.940
is that every time I hit the run
button here-- this is an

00:06:33.940 --> 00:06:35.390
HTMI5 presentation--

00:06:35.390 --> 00:06:39.130
it compiles the binary out of
the HTML, runs it, and pops up

00:06:39.130 --> 00:06:42.680
this window talking with a web
socket back to the browser.

00:06:42.680 --> 00:06:45.340
And it's all done in Go.

00:06:45.340 --> 00:06:47.190
By doing it this way, you get
to see the actual code

00:06:47.190 --> 00:06:51.240
running, and you also trust that
what's going on here is

00:06:51.240 --> 00:06:51.950
really what I'm showing you.

00:06:51.950 --> 00:06:54.440
It's really important for the
concurrency because timing

00:06:54.440 --> 00:06:55.180
things come in.

00:06:55.180 --> 00:06:58.180
So let's make this program a
little less boring by putting

00:06:58.180 --> 00:07:02.120
in a random sleeping interval so
that they run a little less

00:07:02.120 --> 00:07:04.990
deterministically, so there's a
little randomness in there.

00:07:04.990 --> 00:07:05.690
OK.

00:07:05.690 --> 00:07:06.670
Pretty boring program, right?

00:07:06.670 --> 00:07:08.100
You still with me?

00:07:08.100 --> 00:07:09.450
All right.

00:07:09.450 --> 00:07:10.400
Now let's run this thing.

00:07:10.400 --> 00:07:12.120
So it's pretty easy.

00:07:12.120 --> 00:07:14.480
Here's the whole program except
for some boilerplate at

00:07:14.480 --> 00:07:17.230
the top, and there's the whole
program running out of the

00:07:17.230 --> 00:07:18.090
thing, and la la la.

00:07:18.090 --> 00:07:18.640
OK.

00:07:18.640 --> 00:07:19.400
Extremely boring.

00:07:19.400 --> 00:07:20.480
Good.

00:07:20.480 --> 00:07:23.590
Now boring things are things
you want to ignore.

00:07:23.590 --> 00:07:24.590
So let's ignore that.

00:07:24.590 --> 00:07:28.790
To do that, we run the boring
function as a goroutine.

00:07:28.790 --> 00:07:30.510
I"ll talk a little bit more
about goroutines in a minute.

00:07:30.510 --> 00:07:33.140
But for now, just think of a
goroutine as being analogous

00:07:33.140 --> 00:07:35.900
to launching a shell command
with an ampersand on the end

00:07:35.900 --> 00:07:36.610
of the line.

00:07:36.610 --> 00:07:38.640
It says, run this function
in the background.

00:07:38.640 --> 00:07:39.640
I don't care about it.

00:07:39.640 --> 00:07:41.420
I'm just going to keep
executing directly.

00:07:41.420 --> 00:07:43.830
So let's run this.

00:07:43.830 --> 00:07:45.450
Something went wrong.

00:07:45.450 --> 00:07:46.500
That's not actually a bug.

00:07:46.500 --> 00:07:48.310
This is actually what Go does.

00:07:48.310 --> 00:07:51.090
What happened down here is
that we launched this

00:07:51.090 --> 00:07:54.170
goroutine, and then main
immediately returned because

00:07:54.170 --> 00:07:55.580
we didn't have to wait.

00:07:55.580 --> 00:07:59.420
But the way it Go is defined,
when main returns, the program

00:07:59.420 --> 00:08:01.020
actually exits.

00:08:01.020 --> 00:08:05.060
And so this is sort of a
feature of Go that's

00:08:05.060 --> 00:08:05.540
deliberate.

00:08:05.540 --> 00:08:07.520
When main returns, the
program goes away.

00:08:07.520 --> 00:08:09.480
But it also confuses
people, at first.

00:08:09.480 --> 00:08:10.920
So I put it in the very
first example.

00:08:10.920 --> 00:08:13.925
So when you run the program, it
launches the goroutine, but

00:08:13.925 --> 00:08:15.560
the program returns
and we're done.

00:08:15.560 --> 00:08:18.980
So let's make that a little
more interesting by doing

00:08:18.980 --> 00:08:20.720
something after we launch
the goroutine.

00:08:20.720 --> 00:08:23.330
So here we launch it, and now
we print a couple of things

00:08:23.330 --> 00:08:25.510
out, wait for a while,
and then exit.

00:08:25.510 --> 00:08:28.020
So now you can see that, in
fact, we are running both the

00:08:28.020 --> 00:08:31.642
boring function and the main
function concurrently.

00:08:31.642 --> 00:08:32.080
Right?

00:08:32.080 --> 00:08:32.730
Very, very simple.

00:08:32.730 --> 00:08:35.289
So what are these goroutines?

00:08:35.289 --> 00:08:41.080
Well, it's an independently
executing function.

00:08:41.080 --> 00:08:43.330
You can think of, when you run
a function, normally you wait

00:08:43.330 --> 00:08:46.050
for the function to complete,
and you get the answer back.

00:08:46.050 --> 00:08:48.650
The goroutine says, run the
function, but I don't want to

00:08:48.650 --> 00:08:49.790
wait for the answer
to come back.

00:08:49.790 --> 00:08:51.900
Just go and execute
independently of me.

00:08:51.900 --> 00:08:54.440
So this is the sort of
fundamental idea of composing.

00:08:54.440 --> 00:08:57.300
So in Go, concurrency is the
composition of independently

00:08:57.300 --> 00:08:59.860
executing goroutines.

00:08:59.860 --> 00:09:01.380
It's got its own stack.

00:09:01.380 --> 00:09:04.700
And the stack actually grows
and shrinks as required.

00:09:04.700 --> 00:09:06.950
So unlike some threading
libraries, where you have to

00:09:06.950 --> 00:09:09.520
say how big the stack is, it's
never an issue in Go.

00:09:09.520 --> 00:09:11.470
You don't have to say how
big the stack is.

00:09:11.470 --> 00:09:14.210
It will be made as big as it
needs to be, and if the stack

00:09:14.210 --> 00:09:15.870
grows, the system will
take care of the

00:09:15.870 --> 00:09:17.110
stack growth for you.

00:09:17.110 --> 00:09:18.200
And they start out very small.

00:09:18.200 --> 00:09:21.150
So it's very cheap and practical
to have thousands or

00:09:21.150 --> 00:09:23.940
even tens of thousands of
goroutines running.

00:09:23.940 --> 00:09:25.750
And I'll show you an example,
later, where we have

00:09:25.750 --> 00:09:27.430
way more than that.

00:09:27.430 --> 00:09:30.000
And we've even seen large jobs
running in production with

00:09:30.000 --> 00:09:30.820
millions of them.

00:09:30.820 --> 00:09:32.310
So they're very, very
cheap things.

00:09:32.310 --> 00:09:33.490
They're not threads.

00:09:33.490 --> 00:09:36.650
However, for the point of view
of understanding them, it's

00:09:36.650 --> 00:09:39.690
not misleading to think of a
goroutine as just an extremely

00:09:39.690 --> 00:09:40.470
cheap thread.

00:09:40.470 --> 00:09:42.580
Because that's really, in
effect, what they are.

00:09:42.580 --> 00:09:46.200
What happens in the runtime is
goroutines are multiplexed

00:09:46.200 --> 00:09:49.220
onto threads that are created
as needed in order to make

00:09:49.220 --> 00:09:51.180
sure no goroutine ever blocks.

00:09:51.180 --> 00:09:53.630
So you just launch the
goroutines, and you don't have

00:09:53.630 --> 00:09:54.350
to think about it.

00:09:54.350 --> 00:09:56.730
And that's kind of the point.

00:09:56.730 --> 00:09:59.930
Now our example that we ran
before, where we started the

00:09:59.930 --> 00:10:02.120
goroutine, printed a bit,
and then exited, that

00:10:02.120 --> 00:10:03.230
was actually a cheat.

00:10:03.230 --> 00:10:06.150
Because the goroutines were
independently executing, but

00:10:06.150 --> 00:10:10.180
they were not communicating or
synchronizing their behavior

00:10:10.180 --> 00:10:11.020
in any way.

00:10:11.020 --> 00:10:13.790
I just started this guy, this
program talked, and the other

00:10:13.790 --> 00:10:17.220
one kept running, which isn't
a very helpful example.

00:10:17.220 --> 00:10:20.250
And so to do a proper concurrent
program, you need

00:10:20.250 --> 00:10:22.080
to be able to communicate
among the

00:10:22.080 --> 00:10:23.570
goroutines inside it.

00:10:23.570 --> 00:10:27.200
And to do that, there is a
concept of a channel in Go.

00:10:27.200 --> 00:10:28.800
And as I mentioned earlier,
channels are sort of a

00:10:28.800 --> 00:10:30.850
fundamental concept in Go.

00:10:30.850 --> 00:10:32.550
And they're first-class values,
and they're really

00:10:32.550 --> 00:10:33.040
interesting.

00:10:33.040 --> 00:10:35.330
And we'll use them to do
some interesting stuff.

00:10:35.330 --> 00:10:37.910
But the basics are very
straightforward.

00:10:37.910 --> 00:10:40.590
The first block there shows
you how to declare and

00:10:40.590 --> 00:10:42.140
initialize a channel.

00:10:42.140 --> 00:10:46.200
So var c chan int says declare
a variable called c that has

00:10:46.200 --> 00:10:47.890
type channel of integer.

00:10:47.890 --> 00:10:50.770
And channels are types, so the
values that go on the channels

00:10:50.770 --> 00:10:52.830
have a static type, in
this case, int or

00:10:52.830 --> 00:10:54.430
integer, default integer.

00:10:54.430 --> 00:10:56.630
And then to create a channel,
you actually have to

00:10:56.630 --> 00:10:59.330
initialize it by saying
make of chan int.

00:10:59.330 --> 00:11:02.440
And in Go syntax, you typically
use the := notation.

00:11:02.440 --> 00:11:04.640
So those two lines above are
equivalent to this c

00:11:04.640 --> 00:11:05.790
:= make chan int.

00:11:05.790 --> 00:11:08.490
And you tend to see that kind
of code all the time.

00:11:08.490 --> 00:11:10.890
When you want to send a value
on a channel, you use the

00:11:10.890 --> 00:11:13.100
left-pointing arrow operator.

00:11:13.100 --> 00:11:15.990
And so this sends the value
1 on the channel.

00:11:15.990 --> 00:11:18.250
And then to receive it, you
put the arrow on the other

00:11:18.250 --> 00:11:21.330
side of the c, and now the
value comes out of the

00:11:21.330 --> 00:11:23.310
channel, so that's a
receive operation.

00:11:23.310 --> 00:11:27.045
So if one goroutine says c
gets 1, then the other

00:11:27.045 --> 00:11:30.370
goroutine says, receive from
c and store the value.

00:11:30.370 --> 00:11:32.940
That sends this 1 into the
channel and then out again

00:11:32.940 --> 00:11:35.100
into the variable.

00:11:35.100 --> 00:11:37.530
And the way to think about the
mnemonic here is that the

00:11:37.530 --> 00:11:39.780
arrow points in the direction
in which the channel is

00:11:39.780 --> 00:11:40.900
sending data.

00:11:40.900 --> 00:11:43.240
So here, the 1 is pointing
into the channel.

00:11:43.240 --> 00:11:45.450
Here the arrow's pointing out of
the channel and delivering

00:11:45.450 --> 00:11:46.560
it to the value.

00:11:46.560 --> 00:11:48.560
So let's use the channel
to do something.

00:11:48.560 --> 00:11:51.320
Let's make this program we have
a little more honest.

00:11:51.320 --> 00:11:52.580
So here's our main function.

00:11:52.580 --> 00:11:56.760
And now, this time in a loop,
we actually say printf, you

00:11:56.760 --> 00:12:00.340
say some value, and here is that
receive on the channel,

00:12:00.340 --> 00:12:02.510
which we made up here.

00:12:02.510 --> 00:12:05.320
And then in the boring function,
we just loop

00:12:05.320 --> 00:12:09.900
forever, sending a printed
message to the channel.

00:12:09.900 --> 00:12:14.630
So if we run this, you can see
the program running, and then

00:12:14.630 --> 00:12:16.370
for five times, it says that.

00:12:16.370 --> 00:12:17.320
So this is honest, right?

00:12:17.320 --> 00:12:19.670
This main and the boring
function are independently

00:12:19.670 --> 00:12:22.240
executing, but they're
also communicating

00:12:22.240 --> 00:12:23.930
in the strong sense.

00:12:23.930 --> 00:12:27.380
So there's a point about what's
going on here, which

00:12:27.380 --> 00:12:30.620
is, obviously when you read from
a channel, you have to

00:12:30.620 --> 00:12:31.850
wait for there to be
a value there.

00:12:31.850 --> 00:12:33.960
It's a blocking operation.

00:12:33.960 --> 00:12:36.430
But also when you
send to a value,

00:12:36.430 --> 00:12:38.370
it's a blocking operation.

00:12:38.370 --> 00:12:40.580
When you send a value on a
channel, the channel blocks

00:12:40.580 --> 00:12:42.860
until somebody's ready
to receive it.

00:12:42.860 --> 00:12:45.970
And so as a result, if the two
goroutines are executing, and

00:12:45.970 --> 00:12:48.830
this one's sending, and this
one's receiving, whatever

00:12:48.830 --> 00:12:51.010
they're doing, when they finally
reach the point where

00:12:51.010 --> 00:12:53.260
the send and receive are
happening, we know that's like

00:12:53.260 --> 00:12:54.480
a lockstep position.

00:12:54.480 --> 00:12:57.390
Those two goroutines are at
that communication point--

00:12:57.390 --> 00:12:59.830
the send on this side and the
receive on this side.

00:12:59.830 --> 00:13:04.490
So it's also a synchronization
operation as well as a send

00:13:04.490 --> 00:13:05.820
and receive operation.

00:13:05.820 --> 00:13:08.610
And channels thus
communicate and

00:13:08.610 --> 00:13:10.190
synchronize in a single operation.

00:13:10.190 --> 00:13:13.180
And that's a pretty
fundamental idea.

00:13:13.180 --> 00:13:15.720
Now for those experts in the
room who know about buffered

00:13:15.720 --> 00:13:17.720
channels in Go-- which exist--
you can create a

00:13:17.720 --> 00:13:18.890
channel with a buffer.

00:13:18.890 --> 00:13:21.730
And buffered channels have the
property that they don't

00:13:21.730 --> 00:13:24.860
synchronize when you send,
because you can just drop a

00:13:24.860 --> 00:13:26.220
value in the buffer
and keep going.

00:13:26.220 --> 00:13:27.390
So they have different
properties.

00:13:27.390 --> 00:13:28.950
And they're kind of subtle.

00:13:28.950 --> 00:13:31.380
They're very useful for certain
problems, but you

00:13:31.380 --> 00:13:32.170
don't need them.

00:13:32.170 --> 00:13:34.170
And we're not going to use them
at all in our examples

00:13:34.170 --> 00:13:36.070
today, because I don't want
to complicate life

00:13:36.070 --> 00:13:36.960
by explaining them.

00:13:36.960 --> 00:13:38.880
But the thing about buffered
channels is they're much more

00:13:38.880 --> 00:13:41.230
like mailboxes in Erlang, so
I thought it was worth

00:13:41.230 --> 00:13:42.980
mentioning.

00:13:42.980 --> 00:13:46.630
OK so given this idea of
communication coupled with

00:13:46.630 --> 00:13:49.700
synchronization that Go's
channels provide, the Go

00:13:49.700 --> 00:13:52.205
approach to concurrent software
can be characterized

00:13:52.205 --> 00:13:55.090
as, don't communicate
by sharing memory.

00:13:55.090 --> 00:13:57.130
Share memory by communicating.

00:13:57.130 --> 00:13:59.270
In other words, you don't have
some blob of memory and then

00:13:59.270 --> 00:14:01.900
put locks and mutexes and
condition variables around it

00:14:01.900 --> 00:14:04.190
to protect it from
parallel access.

00:14:04.190 --> 00:14:06.690
Instead, you actually use the
channel to pass the data back

00:14:06.690 --> 00:14:09.280
and forth between the goroutines
and make your

00:14:09.280 --> 00:14:12.690
concurrent program
operate that way.

00:14:12.690 --> 00:14:15.990
So based on those principles,
we can now start to do some,

00:14:15.990 --> 00:14:18.290
what I call, concurrency
"patterns." And I put it in

00:14:18.290 --> 00:14:20.470
quotes because I don't want you
to think of these as being

00:14:20.470 --> 00:14:22.330
like object-oriented patterns.

00:14:22.330 --> 00:14:25.550
They're just very simple,
little, tiny examples that do

00:14:25.550 --> 00:14:27.060
interesting things.

00:14:27.060 --> 00:14:29.800
So the first and probably most
important concurrency pattern

00:14:29.800 --> 00:14:32.510
is what I call a generator,
which is a function that

00:14:32.510 --> 00:14:33.970
returns a channel.

00:14:33.970 --> 00:14:36.470
So all of these examples for the
next few slides are going

00:14:36.470 --> 00:14:38.772
to be variants of the things I
showed you before, but I'm

00:14:38.772 --> 00:14:40.370
going to do them in
different ways.

00:14:40.370 --> 00:14:43.270
So in this case, what we do is
we take our boring function,

00:14:43.270 --> 00:14:45.460
and we give it a return value.

00:14:45.460 --> 00:14:48.000
We say that this boring function
is going to return a

00:14:48.000 --> 00:14:50.920
channel of string, and this
less-than means that the

00:14:50.920 --> 00:14:54.990
return value is a channel that
you can only receive from

00:14:54.990 --> 00:14:57.390
because the main function is
only going to use it as a

00:14:57.390 --> 00:14:58.760
received value.

00:14:58.760 --> 00:15:02.650
So in this case, in the main
function, we call the boring

00:15:02.650 --> 00:15:05.040
function, and it returns
the channel.

00:15:05.040 --> 00:15:06.250
And then this is the
same as before.

00:15:06.250 --> 00:15:10.440
We just receive and print the
values that come out.

00:15:10.440 --> 00:15:15.290
And in the boring function,
instead of sort of looping

00:15:15.290 --> 00:15:17.970
forever, with the goroutine
being launched in main, we

00:15:17.970 --> 00:15:20.350
actually launch the goroutine
inside the

00:15:20.350 --> 00:15:22.320
boring function itself.

00:15:22.320 --> 00:15:23.710
You can see here,
it says go func.

00:15:23.710 --> 00:15:25.050
This is a function literal.

00:15:25.050 --> 00:15:28.090
So this is the loop that we had
before, but it's wrapped

00:15:28.090 --> 00:15:31.050
inside an anonymous function
literal and then launched with

00:15:31.050 --> 00:15:33.380
a Go keyword at the top.

00:15:33.380 --> 00:15:36.690
And so this starts the
computation and then returns

00:15:36.690 --> 00:15:41.150
back to the caller the channel
with which to communicate to

00:15:41.150 --> 00:15:45.490
that process that's running,
that goroutine.

00:15:45.490 --> 00:15:49.550
And so from the outside, this
just looks like a function

00:15:49.550 --> 00:15:52.410
whose invocation returns a
channel, and internally, it

00:15:52.410 --> 00:15:54.690
actually starts a computation
running concurrently.

00:15:54.690 --> 00:15:55.980
So let's run that.

00:15:55.980 --> 00:15:58.710
This will behave exactly the
same way, but now we've got a

00:15:58.710 --> 00:16:02.610
much nicer pattern for
constructing this service.

00:16:02.610 --> 00:16:06.560
And in fact, this is very much
like having a service.

00:16:06.560 --> 00:16:09.500
We could use multiple instances
of this boring

00:16:09.500 --> 00:16:11.470
function, give them different
names, and we'd have different

00:16:11.470 --> 00:16:13.470
services, each of which
are talking to us.

00:16:13.470 --> 00:16:16.380
So here's a simple example where
we actually launch the

00:16:16.380 --> 00:16:19.540
boring function twice, and then
in the loop, just print a

00:16:19.540 --> 00:16:21.360
value from Joe and
a value from Ann.

00:16:21.360 --> 00:16:23.690
And it's exactly the same boring
function as previously.

00:16:23.690 --> 00:16:25.690
We're just using it in
a different way.

00:16:25.690 --> 00:16:28.940
So you can see, you get a 0 from
Joe and Ann, a 1 from Joe

00:16:28.940 --> 00:16:31.600
and Ann, a 2 from Joe
and Ann, and so on.

00:16:31.600 --> 00:16:34.930
Now inside here, we're reading
a value from Joe and

00:16:34.930 --> 00:16:35.835
a value from Anne.

00:16:35.835 --> 00:16:37.660
And because of the
synchronization nature of the

00:16:37.660 --> 00:16:41.210
channels, the two guys are
taking turns, not only in

00:16:41.210 --> 00:16:43.520
printing the values out, but
also in executing them.

00:16:43.520 --> 00:16:48.180
Because if Ann is ready to send
a value but Joe hasn't

00:16:48.180 --> 00:16:50.650
done that yet, Ann will still be
blocked, waiting to deliver

00:16:50.650 --> 00:16:52.120
the value to main.

00:16:52.120 --> 00:16:54.470
Well, that's a little annoying
because maybe Ann is more

00:16:54.470 --> 00:16:56.890
talkative than Joe and doesn't
want to wait around.

00:16:56.890 --> 00:17:01.630
So we can get around that by
writing a fan-in function or a

00:17:01.630 --> 00:17:02.240
multiplexer.

00:17:02.240 --> 00:17:04.579
And to do that--

00:17:04.579 --> 00:17:06.710
here's this fan-in function--

00:17:06.710 --> 00:17:09.380
we actually stitch the two guys
together with the fan-in

00:17:09.380 --> 00:17:12.960
function and construct a single
channel, from which we

00:17:12.960 --> 00:17:14.440
can receive from both of them.

00:17:14.440 --> 00:17:16.410
And the way to think of it is
a little bit like this.

00:17:16.410 --> 00:17:19.880
Here's Joe, and here's Ann,
and they're both talking.

00:17:19.880 --> 00:17:22.980
And then the fan-in function
here is taking values from Joe

00:17:22.980 --> 00:17:25.619
and values from Ann and just
forwarding them on to the

00:17:25.619 --> 00:17:27.270
output of the fan-in function.

00:17:27.270 --> 00:17:28.079
Right?

00:17:28.079 --> 00:17:31.450
And to do that, again, it's
using the generator pattern.

00:17:31.450 --> 00:17:33.290
The fan-in function is
itself a function

00:17:33.290 --> 00:17:34.630
that returns a channel.

00:17:34.630 --> 00:17:37.350
It takes two channels as input,
returns another channel

00:17:37.350 --> 00:17:39.700
as its return value.

00:17:39.700 --> 00:17:42.070
And what we do is, again, make
the channel and return it.

00:17:42.070 --> 00:17:45.670
But internally, we launch two
independent goroutines, one

00:17:45.670 --> 00:17:51.390
copying the output from input1
to the channel, and the other

00:17:51.390 --> 00:17:54.920
one copying the data from
input2 to the channel.

00:17:54.920 --> 00:17:58.170
So when we call fanIn of boring
Joe and boring Ann,

00:17:58.170 --> 00:17:59.790
remember, they return
channels.

00:17:59.790 --> 00:18:02.300
They become the arguments to the
fan-in function, and then

00:18:02.300 --> 00:18:05.180
we launch two more goroutines
to copy the data.

00:18:05.180 --> 00:18:07.340
And so we run this guy.

00:18:07.340 --> 00:18:09.770
Ann and Joe are now completely
independent.

00:18:09.770 --> 00:18:13.720
And you can see, when it runs,
that they run in not

00:18:13.720 --> 00:18:15.220
necessarily sequential order.

00:18:15.220 --> 00:18:18.160
Because there's Joe gives three
communications in a row,

00:18:18.160 --> 00:18:20.880
there, before Ann had anything
else to say.

00:18:20.880 --> 00:18:21.350
OK?

00:18:21.350 --> 00:18:23.810
So that decouples the execution
of those guys.

00:18:23.810 --> 00:18:25.650
So even though it's all
synchronous, they can

00:18:25.650 --> 00:18:28.990
independently execute.

00:18:28.990 --> 00:18:32.350
So what if, for some reason, we
actually don't want that?

00:18:32.350 --> 00:18:35.690
We wanted to have them be
totally lockstep and

00:18:35.690 --> 00:18:36.410
synchronous.

00:18:36.410 --> 00:18:39.460
Well to do that, remember I
said these channels are

00:18:39.460 --> 00:18:41.340
first-class values in Go.

00:18:41.340 --> 00:18:44.550
That means that we can pass
a channel on a channel.

00:18:44.550 --> 00:18:47.670
And so we can send inside a
channel another channel to be

00:18:47.670 --> 00:18:49.650
used for the answer
to come back.

00:18:49.650 --> 00:18:53.010
To do this, what we do is we
construct a message structure

00:18:53.010 --> 00:18:55.500
that includes the message that
we want to print, and we

00:18:55.500 --> 00:18:59.040
include inside there another
channel that is what we call a

00:18:59.040 --> 00:18:59.970
wait channel.

00:18:59.970 --> 00:19:01.080
And that's like a signaler.

00:19:01.080 --> 00:19:05.400
And the guy will block on the
wait channel until the person

00:19:05.400 --> 00:19:07.520
says, OK, I want you
to go ahead.

00:19:07.520 --> 00:19:09.190
So let's see how that works.

00:19:09.190 --> 00:19:11.420
So here's our main loop--

00:19:11.420 --> 00:19:13.100
again, just five times
around the loop.

00:19:13.100 --> 00:19:17.840
We receive a message from the
first person and send it--

00:19:17.840 --> 00:19:19.330
this is, again, the fan-in
functions on the

00:19:19.330 --> 00:19:20.330
other side of this.

00:19:20.330 --> 00:19:24.600
Receive another one and print
that, and then wait them out.

00:19:24.600 --> 00:19:27.500
Now notice that this is
message1 and message2.

00:19:27.500 --> 00:19:31.190
They have channels inside them
that are the guys that are

00:19:31.190 --> 00:19:33.190
going to be used to
do the sequencing.

00:19:33.190 --> 00:19:38.640
So inside the boring functions,
now, we have this

00:19:38.640 --> 00:19:41.960
wait-for-it channel, and then
everybody blocks, waiting for

00:19:41.960 --> 00:19:43.730
a signal to advance.

00:19:43.730 --> 00:19:46.840
So when we run it now, you can
see they're back in lockstep,

00:19:46.840 --> 00:19:50.040
because even though the timing
is random, the sequencing

00:19:50.040 --> 00:19:55.460
here, with message1 wait and
message2 wait, means that the

00:19:55.460 --> 00:19:58.100
independently executing guys
are waiting on different

00:19:58.100 --> 00:20:02.410
channels for the signal
to advance.

00:20:02.410 --> 00:20:07.210
Now that's all fairly simple
and kind of silly.

00:20:07.210 --> 00:20:09.420
We can make it a little more
interesting by using the next

00:20:09.420 --> 00:20:12.910
part of concurrency in Go, which
is the select statement.

00:20:12.910 --> 00:20:16.230
And the select statement is a
control structure, somewhat

00:20:16.230 --> 00:20:19.630
like a switch, that lets you
control the behavior of your

00:20:19.630 --> 00:20:22.700
program based on what
communications are able to

00:20:22.700 --> 00:20:24.110
proceed at any moment.

00:20:24.110 --> 00:20:27.270
And in fact, the select
statement is really sort of a

00:20:27.270 --> 00:20:30.840
key part of why concurrency is
built into Go as features of

00:20:30.840 --> 00:20:34.800
the language, rather than
just a library.

00:20:34.800 --> 00:20:37.090
It's hard to control structures

00:20:37.090 --> 00:20:38.520
that depend on libraries.

00:20:38.520 --> 00:20:40.140
It's much easier this way.

00:20:40.140 --> 00:20:41.190
So here's how a select
statement works.

00:20:41.190 --> 00:20:42.780
It looks kind of complicated.

00:20:42.780 --> 00:20:43.970
There's a lot of text
on this slide.

00:20:43.970 --> 00:20:45.430
But it's really pretty simple.

00:20:45.430 --> 00:20:47.810
A select statement looks
like a switch.

00:20:47.810 --> 00:20:49.210
It's got a bunch of cases.

00:20:49.210 --> 00:20:52.490
And each case, instead of
being an expression, is

00:20:52.490 --> 00:20:53.870
actually a communication.

00:20:53.870 --> 00:20:55.300
So you can see, there's
a receive, a

00:20:55.300 --> 00:20:56.860
receive, and a send.

00:20:56.860 --> 00:20:59.590
And what happens in this select
statement is when you

00:20:59.590 --> 00:21:02.350
come to the top of the select,
it evaluates all of the

00:21:02.350 --> 00:21:04.530
channels that could be used for
communication inside the

00:21:04.530 --> 00:21:07.550
cases, and then it blocks
until one of

00:21:07.550 --> 00:21:09.070
them is ready to run.

00:21:09.070 --> 00:21:12.780
And once one is available to
run, that case executes, and

00:21:12.780 --> 00:21:14.090
the whole select goes on.

00:21:14.090 --> 00:21:16.890
So it's much like a regular
switch statement, except it

00:21:16.890 --> 00:21:19.330
blocks until a communication
can proceed.

00:21:19.330 --> 00:21:21.800
And there's a default that you
can put inside a select.

00:21:21.800 --> 00:21:25.790
If there's no default, then the
select will block forever

00:21:25.790 --> 00:21:28.220
until the channel can proceed.

00:21:28.220 --> 00:21:31.740
If there is a default, what
it means is, if nobody can

00:21:31.740 --> 00:21:34.920
proceed right away, then just
execute the default.

00:21:34.920 --> 00:21:38.580
And this gives you way to do
non-blocking communication.

00:21:38.580 --> 00:21:39.990
We're not going to depend on
that, but I just wanted to

00:21:39.990 --> 00:21:41.380
make sure you knew
it was there.

00:21:41.380 --> 00:21:42.660
So it's really pretty simple.

00:21:42.660 --> 00:21:45.560
The only other sort of wrinkle
is that sometimes multiple

00:21:45.560 --> 00:21:47.610
channels are available
at the same time.

00:21:47.610 --> 00:21:50.720
When that happens, the select
statement chooses one

00:21:50.720 --> 00:21:51.660
pseudo-randomly.

00:21:51.660 --> 00:21:53.980
So you can't depend on the
order in which the

00:21:53.980 --> 00:21:57.400
communications will proceed.

00:21:57.400 --> 00:21:59.070
Those of you who know Dijkstra's
guarded commands

00:21:59.070 --> 00:22:00.650
will recognize the
pattern there.

00:22:00.650 --> 00:22:03.990
It's very much like the guarded
if statement inside

00:22:03.990 --> 00:22:05.380
Dijkstra's commands.

00:22:05.380 --> 00:22:06.630
So here's our fan-in function.

00:22:06.630 --> 00:22:10.330
Same functionality, but now
written using select.

00:22:10.330 --> 00:22:12.400
So here's our old guy.

00:22:12.400 --> 00:22:14.940
This is exactly the function
we had before, you can see.

00:22:14.940 --> 00:22:17.020
And here's the new one using
the select statement.

00:22:17.020 --> 00:22:19.320
If I go back and forth, you can
see the difference is, the

00:22:19.320 --> 00:22:22.910
original guy started two
goroutines, one for each input

00:22:22.910 --> 00:22:24.640
channel to be copied
to the output.

00:22:24.640 --> 00:22:27.830
The new guy starts a single
goroutine because it's still

00:22:27.830 --> 00:22:29.360
got that generator pattern.

00:22:29.360 --> 00:22:32.740
But instead of two copy loops,
it runs one copy loop, and it

00:22:32.740 --> 00:22:36.250
selects which of the two is
ready and passes the data on

00:22:36.250 --> 00:22:38.130
appropriately.

00:22:38.130 --> 00:22:40.640
So this has exactly the same
behavior as the other one,

00:22:40.640 --> 00:22:43.370
except that we're only launching
one goroutine inside

00:22:43.370 --> 00:22:44.990
the fan-in function.

00:22:44.990 --> 00:22:48.250
Same idea, different
implementation.

00:22:48.250 --> 00:22:49.680
Now we can use selects
to do all kinds

00:22:49.680 --> 00:22:50.900
of interesting things.

00:22:50.900 --> 00:22:54.050
One of the most important is
we can use it to time out a

00:22:54.050 --> 00:22:55.080
communication.

00:22:55.080 --> 00:22:57.050
So if you're talking to somebody
who's very boring,

00:22:57.050 --> 00:22:59.960
chances are you don't want to
wait very long for them to get

00:22:59.960 --> 00:23:01.040
around to saying something.

00:23:01.040 --> 00:23:03.890
So in this case, we can simulate
that with a call to a

00:23:03.890 --> 00:23:06.500
function in the library
called time.After.

00:23:06.500 --> 00:23:10.630
And here, this select statement
says either we can

00:23:10.630 --> 00:23:13.830
get a message from Joe, or a
second's gone by, and he

00:23:13.830 --> 00:23:15.290
hasn't said anything,
in which case, we'll

00:23:15.290 --> 00:23:16.420
just get out of here.

00:23:16.420 --> 00:23:21.300
So time.After is a function
inside the standard library

00:23:21.300 --> 00:23:26.590
that returns a channel that will
deliver a value after the

00:23:26.590 --> 00:23:27.920
specified interval.

00:23:27.920 --> 00:23:31.770
So in this case, either we get
a message, or a second goes

00:23:31.770 --> 00:23:33.670
by, and we don't get a message,
and then we finish.

00:23:33.670 --> 00:23:36.650
So if we run it, you can see,
Joe goes for a while.

00:23:36.650 --> 00:23:39.900
And then he takes too long to
say something, and so we exit.

00:23:39.900 --> 00:23:40.710
OK?

00:23:40.710 --> 00:23:41.480
I think it always does this.

00:23:41.480 --> 00:23:43.100
I think I forgot to seed it.

00:23:43.100 --> 00:23:43.950
It's always saying
the same thing.

00:23:43.950 --> 00:23:44.580
All right.

00:23:44.580 --> 00:23:45.420
But you see the idea.

00:23:45.420 --> 00:23:48.030
We just keep going around this
loop until the timeout fires.

00:23:48.030 --> 00:23:50.350
Now you can do that
another way.

00:23:50.350 --> 00:23:53.440
We might decide, instead of
having a conversation where

00:23:53.440 --> 00:23:55.780
each message is at most one
second, we might just want a

00:23:55.780 --> 00:23:57.240
total time elapsed.

00:23:57.240 --> 00:24:00.140
And to do that, we can use the
time.After channel more

00:24:00.140 --> 00:24:03.160
directly by just saving it
inside a timeout channel and

00:24:03.160 --> 00:24:05.280
using it inside the
select statement.

00:24:05.280 --> 00:24:08.630
So in this case, this loop, this
entire loop will time out

00:24:08.630 --> 00:24:10.080
after five seconds.

00:24:10.080 --> 00:24:12.200
So it doesn't matter how many
times Joe says anything.

00:24:12.200 --> 00:24:14.080
After five seconds,
we're out there.

00:24:16.846 --> 00:24:17.770
Boom.

00:24:17.770 --> 00:24:18.420
OK?

00:24:18.420 --> 00:24:19.530
So that times out
the whole loop.

00:24:19.530 --> 00:24:22.560
The difference, here, is we're
timing out each message.

00:24:22.560 --> 00:24:26.340
Here, we're timing out the
whole conversation.

00:24:26.340 --> 00:24:29.600
Now another thing you can do
with a select is instead of

00:24:29.600 --> 00:24:32.130
using a timeout, you could
actually deterministically

00:24:32.130 --> 00:24:33.790
say, OK, I'm done.

00:24:33.790 --> 00:24:34.660
Stop now.

00:24:34.660 --> 00:24:37.695
So here's our inner loop again,
the select inside the

00:24:37.695 --> 00:24:38.440
inner loop.

00:24:38.440 --> 00:24:40.280
There's the send
on the message.

00:24:40.280 --> 00:24:43.640
But we actually have a second
case which is a quit channel.

00:24:43.640 --> 00:24:47.300
And what we do there is in the
main function, we create some

00:24:47.300 --> 00:24:48.130
quit channel.

00:24:48.130 --> 00:24:49.750
In this case, it doesn't
matter what type it is.

00:24:49.750 --> 00:24:51.050
I just picked bool.

00:24:51.050 --> 00:24:54.430
And then after we've printed as
many times we want what he

00:24:54.430 --> 00:24:57.310
has to say, we signal
him and say, OK.

00:24:57.310 --> 00:24:58.100
I'm done.

00:24:58.100 --> 00:25:02.480
And so at that point, this case
can proceed, because this

00:25:02.480 --> 00:25:06.040
guy's not communicating and
will eventually stop.

00:25:06.040 --> 00:25:09.740
So again, this is the same
thing as before.

00:25:09.740 --> 00:25:12.420
But now after only two
executions, we

00:25:12.420 --> 00:25:13.460
decide that's enough.

00:25:13.460 --> 00:25:14.580
We tell him to quit.

00:25:14.580 --> 00:25:17.090
And so the quit case executes
in the select, the function

00:25:17.090 --> 00:25:22.200
returns, and the boring
conversation is over.

00:25:22.200 --> 00:25:23.720
Now there's a problem with
that model, though.

00:25:23.720 --> 00:25:29.790
Because in here, in this case,
what if after this function is

00:25:29.790 --> 00:25:32.240
done, he needs to do something
inside here?

00:25:32.240 --> 00:25:34.880
So he gets the message to stop,
but he might have some

00:25:34.880 --> 00:25:36.420
cleanup functions to do.

00:25:36.420 --> 00:25:40.250
Remember that when main returns
from a Go program, the

00:25:40.250 --> 00:25:41.340
whole thing shuts down.

00:25:41.340 --> 00:25:43.390
Maybe he's got to remove
some temporary files or

00:25:43.390 --> 00:25:44.050
something like that.

00:25:44.050 --> 00:25:47.280
We want to make sure that he's
finished before we really

00:25:47.280 --> 00:25:49.760
exit, and so we need to do a
slightly more sophisticated

00:25:49.760 --> 00:25:50.700
communication.

00:25:50.700 --> 00:25:51.680
And it's very easy to do that.

00:25:51.680 --> 00:25:55.640
We just turn around and say,
send me a message back when

00:25:55.640 --> 00:25:56.390
you're done.

00:25:56.390 --> 00:26:00.670
And so in this case, we say
"Bye!" But then Joe gets the

00:26:00.670 --> 00:26:05.330
message on the quit statement,
does a cleanup, and then tells

00:26:05.330 --> 00:26:07.210
you, OK, I'm done.

00:26:07.210 --> 00:26:11.360
And this gives synchronization
for the two programs, to make

00:26:11.360 --> 00:26:13.500
sure that they're both where
they want to be.

00:26:13.500 --> 00:26:16.680
So in this case, you see we tell
him "Bye!" And then the

00:26:16.680 --> 00:26:17.220
quit fires.

00:26:17.220 --> 00:26:19.450
We do whatever cleanup
is required.

00:26:19.450 --> 00:26:20.240
Then we respond.

00:26:20.240 --> 00:26:22.980
But now we're telling him that
we're done for sure, and so

00:26:22.980 --> 00:26:24.470
it's safe for him to exit.

00:26:24.470 --> 00:26:28.290
And this is a round-trip
communication.

00:26:28.290 --> 00:26:32.690
Now speaking of round-trips, we
can also make this crazy by

00:26:32.690 --> 00:26:35.000
having a ridiculously long
sequence of these things, one

00:26:35.000 --> 00:26:36.160
talking to another one.

00:26:36.160 --> 00:26:38.390
So think of it like this.

00:26:38.390 --> 00:26:40.150
You've got a whole bunch of
gophers who want to do a

00:26:40.150 --> 00:26:42.470
Chinese Whispers game, although
I think Chinese

00:26:42.470 --> 00:26:44.420
Whispers with megaphones
might sort of

00:26:44.420 --> 00:26:45.610
make it a little weird.

00:26:45.610 --> 00:26:46.780
But you see the idea, here.

00:26:46.780 --> 00:26:48.730
This guy's sends a message
to him, sends a message--

00:26:48.730 --> 00:26:50.210
forwards it, forwards
it, forwards it.

00:26:50.210 --> 00:26:54.560
And the last guy receives the
message and prints it out.

00:26:54.560 --> 00:26:57.300
Now I want to stress that
this is not a loop.

00:26:57.300 --> 00:27:00.030
This is just going all the way
around the chain, back to the

00:27:00.030 --> 00:27:01.080
answer here.

00:27:01.080 --> 00:27:02.390
And to make it interesting--

00:27:02.390 --> 00:27:04.100
this is the gopher here--

00:27:04.100 --> 00:27:07.390
what he does is receive
from the left--

00:27:07.390 --> 00:27:09.130
sorry, receive from the
right, because this

00:27:09.130 --> 00:27:09.700
is where it's going.

00:27:09.700 --> 00:27:10.790
Coming in from the right.

00:27:10.790 --> 00:27:11.960
Sending to the left.

00:27:11.960 --> 00:27:13.180
So you receive on the right.

00:27:13.180 --> 00:27:14.630
And then we make it a channel
of integers, so I'm

00:27:14.630 --> 00:27:15.800
going to add 1.

00:27:15.800 --> 00:27:18.320
And the reason for that is, that
lets us count the number

00:27:18.320 --> 00:27:21.900
of steps, so the distortion in
the Chinese Whispers game is

00:27:21.900 --> 00:27:23.510
we add 1 to the value.

00:27:23.510 --> 00:27:25.060
And I'm not going to
go through all the

00:27:25.060 --> 00:27:25.860
details of this code.

00:27:25.860 --> 00:27:29.190
This is actually sort of subtle,
and I don't want

00:27:29.190 --> 00:27:30.000
explain it all.

00:27:30.000 --> 00:27:34.740
But all it does is basically
construct this diagram using

00:27:34.740 --> 00:27:36.870
channels to send the
answers along.

00:27:36.870 --> 00:27:38.890
And then everybody's
waiting for the

00:27:38.890 --> 00:27:41.240
first thing to be sent.

00:27:41.240 --> 00:27:44.450
And so we launch the value into
the first channel and

00:27:44.450 --> 00:27:46.150
then wait for it to come out
of the leftmost guy.

00:27:46.150 --> 00:27:48.400
So it goes, vvvvt, around
the channel.

00:27:48.400 --> 00:27:52.980
And for the sake of fun, I'm
going to run 100,000 gophers.

00:27:52.980 --> 00:27:56.060
Now remember that I'm going to
compile the program, link it,

00:27:56.060 --> 00:27:57.050
and then run it.

00:27:57.050 --> 00:28:01.654
And it takes that long to do
100,000 goroutines and all the

00:28:01.654 --> 00:28:02.146
communication.

00:28:02.146 --> 00:28:06.580
[APPLAUSE]

00:28:06.580 --> 00:28:08.470
ROB PIKE: Those are
some fast gophers.

00:28:08.470 --> 00:28:10.200
OK.

00:28:10.200 --> 00:28:12.520
Now this is obviously
a silly example, but

00:28:12.520 --> 00:28:13.240
it's an honest one.

00:28:13.240 --> 00:28:15.490
Because I really am creating all
those elements and doing

00:28:15.490 --> 00:28:17.700
the full communication and
the whole shebang.

00:28:17.700 --> 00:28:20.090
So you can think of goroutines
as being very, very

00:28:20.090 --> 00:28:21.230
lightweight things.

00:28:21.230 --> 00:28:23.530
They're even smaller
than gophers.

00:28:23.530 --> 00:28:24.120
OK.

00:28:24.120 --> 00:28:27.250
But so far, everything we've
been doing is very toy-like.

00:28:27.250 --> 00:28:30.250
And I want to stress that Go
was designed for building

00:28:30.250 --> 00:28:31.710
system software.

00:28:31.710 --> 00:28:35.650
And I want to talk now about
how we use these ideas to

00:28:35.650 --> 00:28:38.170
construct the kind of software
that we care about.

00:28:38.170 --> 00:28:41.910
Now we did this at Google, and
so what we're going to do is

00:28:41.910 --> 00:28:43.660
build a Google search engine.

00:28:43.660 --> 00:28:44.360
Sort of.

00:28:44.360 --> 00:28:45.850
It's still going to be a toy.

00:28:45.850 --> 00:28:48.170
I can't develop a Google search
engine in less than

00:28:48.170 --> 00:28:50.470
about a half an hour, and
I only have 15 minutes.

00:28:50.470 --> 00:28:51.830
But we can start.

00:28:51.830 --> 00:28:53.710
So think about what a
Google search does.

00:28:53.710 --> 00:28:57.070
If you're going to the Google
web page and you run a search,

00:28:57.070 --> 00:28:58.290
you get a bunch of
answers back.

00:28:58.290 --> 00:29:01.560
And some might be web pages,
there could be videos, there

00:29:01.560 --> 00:29:05.300
could be song clips, or weather
reports, or whatever.

00:29:05.300 --> 00:29:07.335
There's a bunch of independently
executing back

00:29:07.335 --> 00:29:10.070
ends that are looking at that
search for you and finding

00:29:10.070 --> 00:29:11.520
results that are interesting.

00:29:11.520 --> 00:29:14.500
And there might also be some
ads, so there's an ad system

00:29:14.500 --> 00:29:15.010
running, too.

00:29:15.010 --> 00:29:17.210
And so in parallel, you want
to send all of these things

00:29:17.210 --> 00:29:19.630
out to the back ends and then
gather all the answers back

00:29:19.630 --> 00:29:20.510
and deliver them.

00:29:20.510 --> 00:29:22.910
How do we actually
structure that?

00:29:22.910 --> 00:29:26.140
Well, let's fake
it, completely.

00:29:26.140 --> 00:29:28.750
Let's construct a thing called
a fakeSearch, and all our

00:29:28.750 --> 00:29:32.180
fakeSearch is going to do is
sleep for a while and then

00:29:32.180 --> 00:29:35.410
return whatever the fake answer
is that it wants, which

00:29:35.410 --> 00:29:36.320
is very uninteresting.

00:29:36.320 --> 00:29:38.210
It says, here's your result.

00:29:38.210 --> 00:29:40.230
But the point is that there's
multiple of them.

00:29:40.230 --> 00:29:42.530
And it's actually a function.

00:29:42.530 --> 00:29:45.400
So notice here, this search is
a function that takes a query

00:29:45.400 --> 00:29:46.360
and returns a result.

00:29:46.360 --> 00:29:50.390
So that's sort of a type
definition for what a search

00:29:50.390 --> 00:29:51.470
actually does.

00:29:51.470 --> 00:29:55.720
And we construct these functions
for a web, an image,

00:29:55.720 --> 00:29:57.200
and a video service.

00:29:57.200 --> 00:29:57.600
OK?

00:29:57.600 --> 00:29:58.220
Very simple.

00:29:58.220 --> 00:30:00.830
All they do is pause for a
while, and then print.

00:30:00.830 --> 00:30:04.640
And they're set to wait for
up to 100 milliseconds.

00:30:04.640 --> 00:30:06.390
So let's test it out.

00:30:06.390 --> 00:30:07.670
So here--

00:30:07.670 --> 00:30:09.880
this time I'm going to seed the
random number generator,

00:30:09.880 --> 00:30:12.020
so the values are always
different.

00:30:12.020 --> 00:30:15.520
And we start the timer, get the
results from the search,

00:30:15.520 --> 00:30:17.010
and then print out
how long it took.

00:30:17.010 --> 00:30:17.340
OK?

00:30:17.340 --> 00:30:21.090
So if I run this guy, you can
see that was 168 milliseconds.

00:30:21.090 --> 00:30:23.520
Now remember, each of these guys
could take up to about

00:30:23.520 --> 00:30:24.270
100 milliseconds.

00:30:24.270 --> 00:30:27.710
So we could see up to, like,
300 milliseconds, maybe.

00:30:27.710 --> 00:30:29.260
There's 160.

00:30:29.260 --> 00:30:30.830
There's 94, that was
a quick one.

00:30:30.830 --> 00:30:32.890
213, that was a slow one.

00:30:32.890 --> 00:30:35.490
So these are actually, you
know, running these guys.

00:30:35.490 --> 00:30:36.398
OK.

00:30:36.398 --> 00:30:40.870
Now let's make it an actual real
function that returns all

00:30:40.870 --> 00:30:42.220
of the values back, right?

00:30:42.220 --> 00:30:45.870
So here, we actually have this
Google function that takes a

00:30:45.870 --> 00:30:49.440
query and queries all of the
back ends and gathers all of

00:30:49.440 --> 00:30:51.980
the results together and returns
back a slice of the

00:30:51.980 --> 00:30:52.970
results, which is--

00:30:52.970 --> 00:30:54.860
think of it as just an
array of results.

00:30:54.860 --> 00:30:57.220
So here we run this guy, and
you can see, there are the

00:30:57.220 --> 00:31:00.610
three things, taking
a little longer to

00:31:00.610 --> 00:31:02.270
gather all of the data.

00:31:02.270 --> 00:31:03.870
OK.

00:31:03.870 --> 00:31:04.680
Trivia, right?

00:31:04.680 --> 00:31:06.900
The problem is that if you
think about it, this is

00:31:06.900 --> 00:31:09.720
running one guy, waiting for
his answer to come back,

00:31:09.720 --> 00:31:11.940
running another one, waiting for
his answer to come back,

00:31:11.940 --> 00:31:14.700
running a third one, waiting for
his answer to come back.

00:31:14.700 --> 00:31:16.240
Well, you know where
this is going.

00:31:16.240 --> 00:31:18.240
Why don't we launch those
in goroutines?

00:31:18.240 --> 00:31:21.870
So now for each of the back
ends, we independently launch

00:31:21.870 --> 00:31:24.670
a goroutine to do the search,
and then-- this

00:31:24.670 --> 00:31:26.590
is the fan-in pattern--

00:31:26.590 --> 00:31:28.570
get the data back on
the same channel.

00:31:28.570 --> 00:31:30.590
And then we can just print
them out as they arrive.

00:31:30.590 --> 00:31:32.450
So they're going to come out of
order now, but we're going

00:31:32.450 --> 00:31:33.680
to get all three of them back.

00:31:33.680 --> 00:31:35.960
But they're running
concurrently, and actually in

00:31:35.960 --> 00:31:37.200
parallel, in this case.

00:31:37.200 --> 00:31:39.830
And so we don't have to wait
around nearly as long.

00:31:39.830 --> 00:31:41.660
So there, we see,
76 milliseconds.

00:31:41.660 --> 00:31:43.040
That's pretty quick.

00:31:43.040 --> 00:31:43.910
88 milliseconds.

00:31:43.910 --> 00:31:46.570
Now we're really only waiting
for the slowest, the single

00:31:46.570 --> 00:31:48.730
slowest web search.

00:31:48.730 --> 00:31:49.860
15 milliseconds.

00:31:49.860 --> 00:31:51.680
There you go.

00:31:51.680 --> 00:31:53.220
So that's pretty cool.

00:31:53.220 --> 00:31:55.910
And notice that this is a
parallel program, now, with

00:31:55.910 --> 00:31:58.490
multiple back ends running.

00:31:58.490 --> 00:32:00.410
But we don't have any
mutexes or locks

00:32:00.410 --> 00:32:01.950
or condition variables.

00:32:01.950 --> 00:32:05.150
The model of Go's concurrency
is taking care of the

00:32:05.150 --> 00:32:08.320
intricacy of setting up and
running this safely.

00:32:08.320 --> 00:32:11.380
Now sometimes, servers
take a long time.

00:32:11.380 --> 00:32:12.640
They can be really,
really slow.

00:32:12.640 --> 00:32:15.400
So remember, we set these
up for 100 milliseconds.

00:32:15.400 --> 00:32:19.190
Once in a while, an individual
search might take more than 80

00:32:19.190 --> 00:32:19.900
milliseconds.

00:32:19.900 --> 00:32:22.740
And let's say we don't want to
wait more than a total of 80

00:32:22.740 --> 00:32:24.670
milliseconds for the
whole thing to run.

00:32:24.670 --> 00:32:26.620
We want to use the timeout
pattern now.

00:32:26.620 --> 00:32:29.900
So here's the fan-in pattern,
and here's the timeout for the

00:32:29.900 --> 00:32:31.410
whole conversation.

00:32:31.410 --> 00:32:33.830
We run this guy now, and
81 milliseconds.

00:32:33.830 --> 00:32:35.080
That was pretty quick.

00:32:37.340 --> 00:32:38.580
44 milliseconds.

00:32:38.580 --> 00:32:41.670
You see, these are
fairly quick now.

00:32:41.670 --> 00:32:44.920
They're typically 80
milliseconds or less, which is

00:32:44.920 --> 00:32:46.310
what they should be, because
we never wait.

00:32:46.310 --> 00:32:47.900
But if I run this
enough times--

00:32:47.900 --> 00:32:48.500
there.

00:32:48.500 --> 00:32:50.830
We timed out because, in
this case, two of the

00:32:50.830 --> 00:32:52.060
queries took too long.

00:32:52.060 --> 00:32:54.020
And so all we got back
was the web result.

00:32:54.020 --> 00:32:55.720
We didn't get the other two.

00:32:55.720 --> 00:32:57.460
And that's a kind
of nice idea.

00:32:57.460 --> 00:32:59.170
We know that we're going to be
able to get you an answer

00:32:59.170 --> 00:33:01.220
within 80 milliseconds.

00:33:01.220 --> 00:33:03.600
However, timing out a

00:33:03.600 --> 00:33:05.310
communication is kind of annoying.

00:33:05.310 --> 00:33:07.830
What if the server really is
going to take a long time?

00:33:07.830 --> 00:33:09.840
It's kind of a shame to
throw it on the floor.

00:33:09.840 --> 00:33:12.890
So now we add replication.

00:33:12.890 --> 00:33:17.830
So if we run three instances of
the service, say, or five,

00:33:17.830 --> 00:33:19.580
one of them is likely
to come back

00:33:19.580 --> 00:33:21.170
before the timeout expires.

00:33:21.170 --> 00:33:23.270
If only one of them is having a
problem, the other ones can

00:33:23.270 --> 00:33:24.640
all be efficient.

00:33:24.640 --> 00:33:26.280
So how do we structure that?

00:33:26.280 --> 00:33:30.080
Well, here's our familiar
pattern by now.

00:33:30.080 --> 00:33:33.460
We actually write a function
called First that takes a

00:33:33.460 --> 00:33:35.760
query and a set of replicas--

00:33:35.760 --> 00:33:38.860
this is the Go notation for
a variadic function--

00:33:38.860 --> 00:33:41.530
so we have a bunch of replicas
of a search that we're going

00:33:41.530 --> 00:33:43.040
to do, for a single search.

00:33:43.040 --> 00:33:45.390
Like, replicas of the web search
or replicas of the

00:33:45.390 --> 00:33:46.660
image search.

00:33:46.660 --> 00:33:48.340
And we make the channel
of results.

00:33:48.340 --> 00:33:53.020
And then we launch the same
search multiple times and then

00:33:53.020 --> 00:33:54.870
return the first one
that comes back.

00:33:54.870 --> 00:33:56.430
See, all these guys are going
to talk on the channel, but

00:33:56.430 --> 00:33:58.350
we're only going to return the
first one that we get.

00:33:58.350 --> 00:34:01.390
And so this will give us the
first result from all those

00:34:01.390 --> 00:34:02.320
back end guys.

00:34:02.320 --> 00:34:06.250
So here's a simple use of it,
where we run two replicas.

00:34:06.250 --> 00:34:11.699
And that time we got replica
2 in 30 milliseconds.

00:34:11.699 --> 00:34:14.080
Replica 2, Replica 1 in 24.

00:34:14.080 --> 00:34:16.050
So you can see, it's whichever
one comes back first.

00:34:16.050 --> 00:34:18.070
There's five milliseconds.

00:34:18.070 --> 00:34:21.889
And with that little tool, now,
we can build the next

00:34:21.889 --> 00:34:25.719
piece, which is to stitch all
of this magic together.

00:34:25.719 --> 00:34:29.059
So this is Google Search
3.0, full on.

00:34:29.059 --> 00:34:30.469
It's got everything in it.

00:34:30.469 --> 00:34:35.235
It has the fan-in function, it's
got the replicated back

00:34:35.235 --> 00:34:38.030
end stuff, it's got a timeout
on everybody.

00:34:38.030 --> 00:34:41.679
And so we should, with very,
very high probability now, get

00:34:41.679 --> 00:34:45.820
all three of our web search
results back in less than 80

00:34:45.820 --> 00:34:48.020
milliseconds.

00:34:48.020 --> 00:34:51.425
So there's 40 milliseconds,
56 milliseconds.

00:34:51.425 --> 00:34:52.694
You notice, they're
all three there.

00:34:52.694 --> 00:34:54.139
There's no timeouts.

00:34:54.139 --> 00:34:56.920
18, 39, 51.

00:34:56.920 --> 00:34:58.780
And this is obviously
a toy example.

00:34:58.780 --> 00:35:01.540
But you can see how we're using
the concurrency ideas in

00:35:01.540 --> 00:35:05.420
Go to build, really, a fairly
sophisticated, parallel,

00:35:05.420 --> 00:35:07.800
replicated, robust thing.

00:35:07.800 --> 00:35:09.720
And that's kind of
the message.

00:35:09.720 --> 00:35:11.750
Because it's very simple
to do that.

00:35:11.750 --> 00:35:14.910
There's still none of that sort
of minutiae of memory

00:35:14.910 --> 00:35:18.110
barriers and nonsense that
people who use threading

00:35:18.110 --> 00:35:19.600
approaches are aware of.

00:35:19.600 --> 00:35:21.810
And there's no callback, so this
is very different from

00:35:21.810 --> 00:35:24.470
using, like, node.js, or
something like that.

00:35:24.470 --> 00:35:26.870
That program is fairly
easy to understand.

00:35:26.870 --> 00:35:29.710
More important, the individual
elements of the program are

00:35:29.710 --> 00:35:31.930
all just straightforward
sequential code.

00:35:31.930 --> 00:35:35.370
And we're composing their
independent execution to give

00:35:35.370 --> 00:35:38.680
us the behavior of
the total server.

00:35:38.680 --> 00:35:41.550
So to summarize what we just did
there, we started with a

00:35:41.550 --> 00:35:44.850
very simple program that was
slow and consequential and

00:35:44.850 --> 00:35:47.720
failure-sensitive, at least
we pretended it is.

00:35:47.720 --> 00:35:51.640
And by using the concurrency
ideas in Go, we made that same

00:35:51.640 --> 00:35:55.090
stuff run quickly, concurrently,
in a replicated

00:35:55.090 --> 00:35:57.950
way, and with much
more robustness.

00:35:57.950 --> 00:36:00.120
And this is sort
of the lesson.

00:36:00.120 --> 00:36:01.960
This was actually why
the concurrency

00:36:01.960 --> 00:36:03.680
features went into Go.

00:36:03.680 --> 00:36:06.920
It's because it makes it easy
to go from this to this

00:36:06.920 --> 00:36:09.870
without worrying about safety
issues and things like that.

00:36:09.870 --> 00:36:12.480
It's just a very much more
straightforward approach to

00:36:12.480 --> 00:36:17.610
constructing what I loosely
describe as server software.

00:36:17.610 --> 00:36:19.240
There's all kinds
of party tricks.

00:36:19.240 --> 00:36:20.930
This is barely, barely touching
the surface, and

00:36:20.930 --> 00:36:23.520
there'll probably have to be a
talk again soon with a lot

00:36:23.520 --> 00:36:26.320
more rich examples using
other features that I

00:36:26.320 --> 00:36:28.010
haven't shown you today.

00:36:28.010 --> 00:36:30.150
But there's lots of talks
on the web already, with

00:36:30.150 --> 00:36:34.420
independent things about using
Go concurrency stuff to solve

00:36:34.420 --> 00:36:36.070
some interesting problems.

00:36:36.070 --> 00:36:39.970
There's a Chatroulette toy,
which Andrew talked about,

00:36:39.970 --> 00:36:42.520
that has a fairly amazing little
inner loop in it that

00:36:42.520 --> 00:36:44.420
you should probably check out.

00:36:44.420 --> 00:36:48.210
A couple of years ago at I/O, I
talked about a dynamic load

00:36:48.210 --> 00:36:50.680
balancer which uses channels
as first-class values to

00:36:50.680 --> 00:36:53.300
construct some pretty
interesting stuff.

00:36:53.300 --> 00:36:56.040
There's a legendary example
called the Concurrent Prime

00:36:56.040 --> 00:36:59.650
Sieve, which is kind of
an amazing thing.

00:36:59.650 --> 00:37:01.830
It was the first truly beautiful
concurrent program I

00:37:01.830 --> 00:37:03.240
think I ever saw.

00:37:03.240 --> 00:37:05.750
But it's completely dwarfed by
this work by Doug McIlroy,

00:37:05.750 --> 00:37:09.540
who's my old boss at Bell Labs,
who wrote a concurrent

00:37:09.540 --> 00:37:12.980
power series library using a
predecessor language to Go.

00:37:12.980 --> 00:37:18.280
And it treats the coefficients
of a power series as values in

00:37:18.280 --> 00:37:20.420
a channel, sequential
values in a channel.

00:37:20.420 --> 00:37:23.000
And using some very simple
tricks, very much like what I

00:37:23.000 --> 00:37:25.710
just showed you, it manages to
do some incredibly high-level

00:37:25.710 --> 00:37:28.940
mathematics that is very, very
difficult to do any other way.

00:37:28.940 --> 00:37:30.500
It's really rather beautiful.

00:37:30.500 --> 00:37:33.530
So there's the links if you
want to check them out.

00:37:33.530 --> 00:37:36.400
Now having just said how
wonderful all this is, I want

00:37:36.400 --> 00:37:37.990
to throw out a word
of caution.

00:37:37.990 --> 00:37:38.810
This stuff is fun.

00:37:38.810 --> 00:37:41.150
It's really fun to write your
first concurrent programs and

00:37:41.150 --> 00:37:42.040
play around with this stuff.

00:37:42.040 --> 00:37:46.000
And you should definitely try
them out and do things to see

00:37:46.000 --> 00:37:47.010
how they behave.

00:37:47.010 --> 00:37:48.380
But don't overdo it.

00:37:48.380 --> 00:37:52.040
These ideas in Go and, for
that matter, the other

00:37:52.040 --> 00:37:56.480
languages I mentioned, are not
not replacements for things

00:37:56.480 --> 00:37:58.640
like memory barriers to protect

00:37:58.640 --> 00:38:00.690
the innards of software.

00:38:00.690 --> 00:38:03.850
They're really sort of
high-level building block-like

00:38:03.850 --> 00:38:06.930
things that you use to take
simple pieces of and connect

00:38:06.930 --> 00:38:09.980
them together into larger
concurrent things.

00:38:09.980 --> 00:38:10.670
They're big ideas.

00:38:10.670 --> 00:38:12.470
They're really tools for
program construction.

00:38:12.470 --> 00:38:15.270
Remember, I said concurrency
is a model for software

00:38:15.270 --> 00:38:16.130
construction?

00:38:16.130 --> 00:38:18.610
These concurrent tools are
models for software

00:38:18.610 --> 00:38:19.740
construction.

00:38:19.740 --> 00:38:22.360
But sometimes, you don't
need that much power.

00:38:22.360 --> 00:38:24.970
If you need a reference counter,
you could write one

00:38:24.970 --> 00:38:26.110
with a channel on a goroutine.

00:38:26.110 --> 00:38:28.110
It's fun to do that
as an exercise.

00:38:28.110 --> 00:38:29.970
But I didn't show you that,
because I think

00:38:29.970 --> 00:38:31.400
that's a silly example.

00:38:31.400 --> 00:38:34.000
It's using much too heavyweight
a tool for a very

00:38:34.000 --> 00:38:35.090
simple thing.

00:38:35.090 --> 00:38:38.700
So Go has these packages in
the sync directory, called

00:38:38.700 --> 00:38:41.320
atomic and-- what was the
other one called?

00:38:41.320 --> 00:38:42.520
Sync and sync/atomic.

00:38:42.520 --> 00:38:45.850
And they contain these low-level
guys for things like

00:38:45.850 --> 00:38:47.980
reference counters when
that's all you need.

00:38:47.980 --> 00:38:49.440
And sometimes it is
all you need.

00:38:49.440 --> 00:38:54.095
So you have to balance the
sort of program structure

00:38:54.095 --> 00:38:54.830
you're doing.

00:38:54.830 --> 00:38:57.610
Glue together the large things
with these tools I've shown

00:38:57.610 --> 00:38:59.960
you, but sometimes if all you
want to do is count the number

00:38:59.960 --> 00:39:02.220
of times somebody hits your
page, all you really need is a

00:39:02.220 --> 00:39:03.080
reference counter.

00:39:03.080 --> 00:39:08.100
So as always, you should use
the right tool for the job.

00:39:08.100 --> 00:39:11.750
So in conclusion, goroutines
and channels are the

00:39:11.750 --> 00:39:13.180
concurrent features of Go.

00:39:13.180 --> 00:39:16.900
And they make it very, very easy
to construct interesting

00:39:16.900 --> 00:39:19.620
concurrent software that solves
real-world problems

00:39:19.620 --> 00:39:22.270
that include things like having
multiple inputs, having

00:39:22.270 --> 00:39:26.480
multiple outputs, independent
execution, timeouts, failures,

00:39:26.480 --> 00:39:27.830
replication, robustness.

00:39:27.830 --> 00:39:31.310
All those things that are sort
of features of the modern

00:39:31.310 --> 00:39:34.100
programming landscape, Go
actually gives you the tools

00:39:34.100 --> 00:39:35.720
to manage very, very well.

00:39:35.720 --> 00:39:37.210
And it's actually--

00:39:37.210 --> 00:39:39.430
even if you're dealing with
boring people, it's actually

00:39:39.430 --> 00:39:41.110
kind of fun to work with.

00:39:41.110 --> 00:39:43.910
So here's some links for you.

00:39:43.910 --> 00:39:44.850
I think that's the last slide.

00:39:44.850 --> 00:39:49.020
I'll just leave that one up so
you can look at these during

00:39:49.020 --> 00:39:50.110
the question period.

00:39:50.110 --> 00:39:53.090
The Go home page, golang.org,
has tons and tons of

00:39:53.090 --> 00:39:56.820
resources, videos, the language
spec, package

00:39:56.820 --> 00:40:00.060
documentation, of which there's
a phenomenal amount,

00:40:00.060 --> 00:40:04.520
lots of second-order documents
like tutorials and blog posts

00:40:04.520 --> 00:40:07.170
and stuff like that.

00:40:07.170 --> 00:40:09.910
And then at the bottom and
barely readable down at the

00:40:09.910 --> 00:40:15.220
bottom here, there's this
tinyurl.com link to my talk at

00:40:15.220 --> 00:40:17.730
the Heroku conference earlier
this year, about concurrency

00:40:17.730 --> 00:40:20.690
is not parallelism, which also
has some other examples that

00:40:20.690 --> 00:40:22.350
are a little richer than some of
the other ones I showed you

00:40:22.350 --> 00:40:24.150
today, because today
I was really

00:40:24.150 --> 00:40:26.150
concentrating on the basics.

00:40:26.150 --> 00:40:29.100
So with that, I'll stop and
maybe take some questions.

00:40:29.100 --> 00:40:39.750
[APPLAUSE]

00:40:39.750 --> 00:40:41.390
ROB PIKE: Go to the microphones,
please, so that

00:40:41.390 --> 00:40:43.690
the people at home
can play along.

00:40:43.690 --> 00:40:47.340
AUDIENCE: So one question I
had-- so the only other tool,

00:40:47.340 --> 00:40:49.920
I think, that competes with Go
for concurrency support is

00:40:49.920 --> 00:40:52.020
Haskell, which I
use regularly.

00:40:52.020 --> 00:40:54.850
And Haskell does feature some

00:40:54.850 --> 00:40:56.160
speculative parallel operators.

00:40:56.160 --> 00:41:00.160
I was wondering if those might
ever appear in Go.

00:41:00.160 --> 00:41:02.060
ROB PIKE: Haskell is a
beautiful language.

00:41:02.060 --> 00:41:03.270
It's a really lovely language.

00:41:03.270 --> 00:41:06.140
But it has a very, very
different model.

00:41:06.140 --> 00:41:10.930
And I think, to my mind, the
functional stuff sort of comes

00:41:10.930 --> 00:41:13.250
for free with Haskell, but the
whole idea behind the language

00:41:13.250 --> 00:41:15.750
is the lazy evaluation
kind of stuff.

00:41:15.750 --> 00:41:18.510
And I think it's an excellent
fit for Haskell.

00:41:18.510 --> 00:41:20.830
I don't think it's a
good fit for Go.

00:41:20.830 --> 00:41:25.210
And in fact, Doug McIlroy took
the concurrent power series

00:41:25.210 --> 00:41:28.370
example and rewrote
it in Haskell.

00:41:28.370 --> 00:41:30.730
And it's a very beautiful
program that I can't

00:41:30.730 --> 00:41:32.180
understand at all.

00:41:32.180 --> 00:41:34.120
But it's very beautiful.

00:41:34.120 --> 00:41:36.790
So I'm not trying to make
fun of Haskell.

00:41:36.790 --> 00:41:38.510
I'm really not, because it
is amazing language.

00:41:38.510 --> 00:41:42.600
But I think that the key point
about the way the concurrency

00:41:42.600 --> 00:41:45.840
features work in Go is that they
work with the way Go, as

00:41:45.840 --> 00:41:47.740
a language, also works.

00:41:47.740 --> 00:41:50.940
And you can't just borrow a
feature from another language

00:41:50.940 --> 00:41:55.630
and stick it in yours and
expect it to work well.

00:41:55.630 --> 00:41:56.820
That art of choosing
what to put in your

00:41:56.820 --> 00:41:58.130
language is part of it.

00:41:58.130 --> 00:42:00.710
So this is not to say
at all those ideas

00:42:00.710 --> 00:42:01.440
aren't really powerful.

00:42:01.440 --> 00:42:03.640
I just don't think they're
a good match for Go.

00:42:03.640 --> 00:42:05.270
And if it turns out that
I'm wrong, maybe

00:42:05.270 --> 00:42:06.330
they should go in.

00:42:06.330 --> 00:42:08.890
But offhand, I don't think
they're a good fit.

00:42:08.890 --> 00:42:09.520
Yes.

00:42:09.520 --> 00:42:12.700
AUDIENCE: Can you comment on
best practices for testing

00:42:12.700 --> 00:42:13.430
goroutines?

00:42:13.430 --> 00:42:16.150
Because it seems like you're
quasi-integration testing.

00:42:16.150 --> 00:42:17.770
Or are there mocks
for goroutines?

00:42:17.770 --> 00:42:19.400
Or how would you
go about that?

00:42:19.400 --> 00:42:20.190
ROB PIKE: So best--

00:42:20.190 --> 00:42:21.090
it's hard to hear you.

00:42:21.090 --> 00:42:23.120
So best practices for testing
concurrent code?

00:42:23.120 --> 00:42:23.860
AUDIENCE: Exactly.

00:42:23.860 --> 00:42:25.110
And for testing goroutines.

00:42:27.760 --> 00:42:28.740
ROB PIKE: Best practices.

00:42:28.740 --> 00:42:31.236
Write good tests.

00:42:31.236 --> 00:42:32.190
[AUDIENCE LAUGHS]

00:42:32.190 --> 00:42:34.590
ROB PIKE: Are you worried about
the non-determinism?

00:42:34.590 --> 00:42:37.310
AUDIENCE: Well, It seems like,
if you think about goroutines

00:42:37.310 --> 00:42:40.370
as external services, you're
thinking about basically

00:42:40.370 --> 00:42:41.440
integration testing.

00:42:41.440 --> 00:42:43.260
ROB PIKE: Well, one of the
amazing things about--

00:42:43.260 --> 00:42:44.260
let me back up here.

00:42:44.260 --> 00:42:47.180
It's actually kind of a
non-issue because of the way

00:42:47.180 --> 00:42:49.590
the language works.

00:42:49.590 --> 00:42:54.550
So let me find the example
I'm looking for.

00:42:54.550 --> 00:42:55.900
Where is it?

00:42:55.900 --> 00:42:57.090
Actually, I went back
way too far.

00:42:57.090 --> 00:42:58.340
I could have used a
much earlier one.

00:43:00.710 --> 00:43:01.060
Here we go.

00:43:01.060 --> 00:43:01.490
Look.

00:43:01.490 --> 00:43:05.400
Look at this guy here,
this example.

00:43:05.400 --> 00:43:09.370
The total interface to this
service is a channel.

00:43:09.370 --> 00:43:14.510
Nowhere does this function here
know what that channel

00:43:14.510 --> 00:43:15.730
has behind it.

00:43:15.730 --> 00:43:17.260
It's just this function
in the background

00:43:17.260 --> 00:43:18.180
that's doing something.

00:43:18.180 --> 00:43:20.910
It could be an arbitrarily
complex computation.

00:43:20.910 --> 00:43:23.210
And once you realize that that
channel is, in effect, the

00:43:23.210 --> 00:43:27.820
capability to a service, you can
mock this service with a

00:43:27.820 --> 00:43:28.540
simple thing.

00:43:28.540 --> 00:43:31.860
In fact, this might be a mock
for a service that returns

00:43:31.860 --> 00:43:34.590
values at arbitrary intervals.

00:43:34.590 --> 00:43:39.410
So I mean, it's a perfectly
good question, but all the

00:43:39.410 --> 00:43:42.270
tools I've shown you to do
that are right here.

00:43:42.270 --> 00:43:43.170
You don't need--

00:43:43.170 --> 00:43:45.260
the whole idea of a channel
is that it hides

00:43:45.260 --> 00:43:46.340
what's behind it.

00:43:46.340 --> 00:43:48.680
And so that's mocking,
right there.

00:43:48.680 --> 00:43:49.340
You've got it.

00:43:49.340 --> 00:43:49.670
AUDIENCE: Right.

00:43:49.670 --> 00:43:51.150
Because it's a first-class--

00:43:51.150 --> 00:43:52.620
ROB PIKE: It's a first-clas
citizen in the language.

00:43:52.620 --> 00:43:53.600
AUDIENCE: --that's your mock.

00:43:53.600 --> 00:43:54.330
ROB PIKE: Right.

00:43:54.330 --> 00:43:55.090
AUDIENCE: Thanks.

00:43:55.090 --> 00:43:55.740
ROB PIKE: Cool.

00:43:55.740 --> 00:43:56.500
Sorry.

00:43:56.500 --> 00:43:59.840
Let me get to the slide you
really want to look at.

00:43:59.840 --> 00:44:00.750
There we go.

00:44:00.750 --> 00:44:01.420
OK.

00:44:01.420 --> 00:44:02.090
Yes.

00:44:02.090 --> 00:44:02.750
AUDIENCE: Hi.

00:44:02.750 --> 00:44:06.400
My question is somehow related
because I really like the way

00:44:06.400 --> 00:44:09.370
you take concurrency as a
first-classing language.

00:44:09.370 --> 00:44:11.910
For instance, in typed language,
you do the static

00:44:11.910 --> 00:44:14.460
analysis of the types, runtime
analysis of the types, and

00:44:14.460 --> 00:44:16.360
everything works right.

00:44:16.360 --> 00:44:18.840
Do you plan on doing something
similar in Go?

00:44:18.840 --> 00:44:20.400
Signs in a way that--

00:44:20.400 --> 00:44:20.685
OK.

00:44:20.685 --> 00:44:23.170
If you do this, you're going
to write to that lock or if

00:44:23.170 --> 00:44:26.385
you keep doing this, you're
going to have a lock Or you

00:44:26.385 --> 00:44:29.300
are going to have a bottleneck
the way you have arranged all

00:44:29.300 --> 00:44:30.540
these patterns.

00:44:30.540 --> 00:44:33.570
Do the Go compilers go through
any kind of prettification of

00:44:33.570 --> 00:44:36.690
the concurrency properties
of your program?

00:44:36.690 --> 00:44:37.530
ROB PIKE: I'm sorry.

00:44:37.530 --> 00:44:39.260
I'm having a really hard time
understanding you because the

00:44:39.260 --> 00:44:40.480
speakers are pointing
backwards,

00:44:40.480 --> 00:44:42.140
and I'm behind them.

00:44:42.140 --> 00:44:48.040
You're asking about the static
channel network and how we

00:44:48.040 --> 00:44:50.280
typecheck that kind of thing?

00:44:50.280 --> 00:44:54.060
AUDIENCE: Go is great for
writing concurrency programs,

00:44:54.060 --> 00:44:59.040
but do you plan or do you do
any kind of verification of

00:44:59.040 --> 00:45:02.440
that concurrency, either
statically or at runtime?

00:45:02.440 --> 00:45:02.710
ROB PIKE: OK.

00:45:02.710 --> 00:45:04.380
So you want to know
about static

00:45:04.380 --> 00:45:08.490
verification of the thing?

00:45:08.490 --> 00:45:12.200
For that kind of thing, I think
independent tools are

00:45:12.200 --> 00:45:12.900
the way to go.

00:45:12.900 --> 00:45:19.400
There's a thread sanitizer
project that is coming out.

00:45:19.400 --> 00:45:20.790
I don't know if it's
actually out yet.

00:45:20.790 --> 00:45:21.330
Is it out yet?

00:45:21.330 --> 00:45:21.570
Yeah, it is.

00:45:21.570 --> 00:45:22.820
It's from Google.

00:45:22.820 --> 00:45:25.660
And they have support for
the Go environment.

00:45:25.660 --> 00:45:28.900
And so you can embed the
thread-sanitized version of

00:45:28.900 --> 00:45:32.410
the world inside your program,
and it will actually look for

00:45:32.410 --> 00:45:35.770
data races and stuff like
that, if that matters.

00:45:35.770 --> 00:45:39.460
From a communication point of
view, tools like the SPIN

00:45:39.460 --> 00:45:42.280
thing that Gerard Holzmann did,
stuff like that I think

00:45:42.280 --> 00:45:45.210
is a really good way to model
these kinds of things for

00:45:45.210 --> 00:45:46.950
static checking.

00:45:46.950 --> 00:45:51.790
And a long time ago, Gerard
did some stuff for us to

00:45:51.790 --> 00:45:55.470
statically verify pieces of
the Plan 9 kernel and its

00:45:55.470 --> 00:45:56.290
communication and

00:45:56.290 --> 00:45:58.390
synchronization stuff using SPIN.

00:45:58.390 --> 00:46:00.550
And I've been thinking of
actually approaching him and

00:46:00.550 --> 00:46:03.700
asking him to support Go's
primitives, so he can actually

00:46:03.700 --> 00:46:06.715
read a Go program and generate a
SPIN model for it and verify

00:46:06.715 --> 00:46:07.300
it statically.

00:46:07.300 --> 00:46:09.850
And I think that's actually
fairly straightforward to do,

00:46:09.850 --> 00:46:12.570
but it hasn't been done.

00:46:12.570 --> 00:46:14.720
AUDIENCE: Thank you.

00:46:14.720 --> 00:46:16.050
ROB PIKE: Please speak
carefully and slowly

00:46:16.050 --> 00:46:17.230
so I can hear you.

00:46:17.230 --> 00:46:18.560
AUDIENCE: So I have
two questions.

00:46:18.560 --> 00:46:19.790
I hope it's OK.

00:46:19.790 --> 00:46:24.830
You showed us a read from a
time.After channel inside a

00:46:24.830 --> 00:46:27.400
select and inside a loop.

00:46:27.400 --> 00:46:30.550
Say I wanted to write
time.After.

00:46:30.550 --> 00:46:33.790
How would I know from the other
side that the channel

00:46:33.790 --> 00:46:37.480
has fallen out of scope so as
to not be locked forever,

00:46:37.480 --> 00:46:39.220
waiting for the read.

00:46:39.220 --> 00:46:40.260
ROB PIKE: You mean,
how do you know--

00:46:40.260 --> 00:46:42.090
so this guy, if the timeout
doesn't fire,

00:46:42.090 --> 00:46:43.440
what happens to him?

00:46:43.440 --> 00:46:45.080
AUDIENCE: Yeah, and what happens
to the code that's in

00:46:45.080 --> 00:46:46.210
on the other side.

00:46:46.210 --> 00:46:48.820
ROB PIKE: It'll get
garbage-collected.

00:46:48.820 --> 00:46:49.495
AUDIENCE: So--

00:46:49.495 --> 00:46:52.300
ROB PIKE: So if you want to
know that-- if this is a

00:46:52.300 --> 00:46:55.450
richer example, and this is not
time.After but some more

00:46:55.450 --> 00:46:58.770
complicated thing, you want to
know that he got your message?

00:46:58.770 --> 00:47:00.820
That's this example
right here.

00:47:00.820 --> 00:47:03.520
AUDIENCE: No, I actually want
to know, on the other side.

00:47:03.520 --> 00:47:09.540
If I'm writing the time.After
function, and I wait my time,

00:47:09.540 --> 00:47:10.900
and then write to
the channel--

00:47:10.900 --> 00:47:11.320
ROB PIKE: Right.

00:47:11.320 --> 00:47:14.080
AUDIENCE: But the write locks
me until it is read--

00:47:14.080 --> 00:47:14.400
ROB PIKE: Right.

00:47:14.400 --> 00:47:16.730
AUDIENCE: So if it, instead of
being read, it never gets read

00:47:16.730 --> 00:47:21.900
and the channel falls out of
scope, will I just be locked

00:47:21.900 --> 00:47:24.960
there, and then I will be
garbage-collected completely?

00:47:24.960 --> 00:47:26.480
ROB PIKE: Yep.

00:47:26.480 --> 00:47:27.300
It's actually--

00:47:27.300 --> 00:47:29.050
there's more subtlety
than that, but yeah.

00:47:29.050 --> 00:47:30.080
I mean, you shouldn't
be worrying

00:47:30.080 --> 00:47:31.280
about it at this level.

00:47:31.280 --> 00:47:35.010
That's the short
version of it.

00:47:35.010 --> 00:47:38.510
The time.After function uses
some of these ideas, but it's

00:47:38.510 --> 00:47:40.370
slightly more sophisticated
than the basic

00:47:40.370 --> 00:47:41.700
stuff I've shown you.

00:47:41.700 --> 00:47:45.560
If you really care about when
your resource is released,

00:47:45.560 --> 00:47:48.100
then you have to write more
sophisticated code than some

00:47:48.100 --> 00:47:49.560
of the stuff I've shown you.

00:47:49.560 --> 00:47:52.490
There is some stuff in the
Google stuff where there's

00:47:52.490 --> 00:47:54.250
blocking going on behind
the scenes that's

00:47:54.250 --> 00:47:55.840
also hidden from you.

00:47:55.840 --> 00:47:58.180
In the time available, I can't
go through all of the

00:47:58.180 --> 00:47:58.990
subtleties of that.

00:47:58.990 --> 00:48:00.700
That's probably a subject
for another talk.

00:48:00.700 --> 00:48:01.000
AUDIENCE: OK.

00:48:01.000 --> 00:48:03.560
But essentially, if I am locked
on that channel that

00:48:03.560 --> 00:48:06.850
gets garbage-collected, so no
one is going to unlock me, I

00:48:06.850 --> 00:48:10.910
will be garbage-collected,
no problem, right?

00:48:10.910 --> 00:48:12.570
ROB PIKE: In many cases, yes.

00:48:12.570 --> 00:48:14.445
It depends on the specific
example.

00:48:14.445 --> 00:48:17.280
AUDIENCE: Second question is,
how did you do the any number

00:48:17.280 --> 00:48:19.510
of stacks that grow
independently?

00:48:19.510 --> 00:48:21.643
ROB PIKE: I'm sorry,
I can't hear you.

00:48:21.643 --> 00:48:25.890
AUDIENCE: The any number
of stacks that grow

00:48:25.890 --> 00:48:26.720
independently.

00:48:26.720 --> 00:48:27.450
ROB PIKE: Yep

00:48:27.450 --> 00:48:29.350
AUDIENCE: Are you allocating the
stack frames on the heap?

00:48:29.350 --> 00:48:30.150
How do you do that?

00:48:30.150 --> 00:48:33.890
ROB PIKE: They're allocated and
managed, yes, by the heap.

00:48:33.890 --> 00:48:36.240
They have a special allocator.

00:48:36.240 --> 00:48:40.750
They're not garbage-collected
in the standard collector,

00:48:40.750 --> 00:48:42.200
because we know more
about them.

00:48:42.200 --> 00:48:46.260
But they're allocated and
free fairly cheaply.

00:48:46.260 --> 00:48:46.870
AUDIENCE: Thanks.

00:48:46.870 --> 00:48:47.380
ROB PIKE: Sorry.

00:48:47.380 --> 00:48:49.500
I'm having trouble
hearing you.

00:48:49.500 --> 00:48:51.970
AUDIENCE: I was wondering
about the select control

00:48:51.970 --> 00:48:53.850
structure that you had.

00:48:53.850 --> 00:48:56.750
You were saying that if multiple
cases are ready at

00:48:56.750 --> 00:49:00.050
the same time, then you
pseudo-randomly choose one,

00:49:00.050 --> 00:49:02.660
rather than evaluating
them in order.

00:49:02.660 --> 00:49:05.830
Is there a way to write it
so that you could have a

00:49:05.830 --> 00:49:08.480
higher-priority case if
you wrote it first?

00:49:08.480 --> 00:49:10.750
Or would you just have to
nest them or something?

00:49:10.750 --> 00:49:11.990
ROB PIKE: You would nest them.

00:49:11.990 --> 00:49:13.890
AUDIENCE: You'd put the default
as another select.

00:49:13.890 --> 00:49:14.440
ROB PIKE: Yeah.

00:49:14.440 --> 00:49:18.690
One of the many properties of
Go is we tried to take away

00:49:18.690 --> 00:49:23.990
things like priorities and
fine-tuning adjustments and

00:49:23.990 --> 00:49:26.160
stuff like that.

00:49:26.160 --> 00:49:29.270
There's enough power here to do
that kind of stuff, but you

00:49:29.270 --> 00:49:32.490
have to write more code, as
opposed to making the API

00:49:32.490 --> 00:49:33.780
really complicated.

00:49:33.780 --> 00:49:36.752
So you can do prioritized stuff
in select, but yeah.

00:49:36.752 --> 00:49:37.860
You basically nest
them to do it.

00:49:37.860 --> 00:49:40.200
You put the guys you care
about most first, and if

00:49:40.200 --> 00:49:42.060
they're not ready, then you
try the other ones.

00:49:42.060 --> 00:49:42.410
AUDIENCE: Gotcha.

00:49:42.410 --> 00:49:44.142
OK.

00:49:44.142 --> 00:49:46.260
ROB PIKE: This is somewhat
related to the earlier

00:49:46.260 --> 00:49:48.490
question but a little
bit more specific.

00:49:48.490 --> 00:49:52.250
So is there a way, if you create
a channel, to determine

00:49:52.250 --> 00:49:55.540
how many readers or writers
there are for a given channel?

00:49:55.540 --> 00:49:59.620
AUDIENCE: Yeah. there's a
built-in function you can use

00:49:59.620 --> 00:50:03.830
to see how many values are in a
buffered channel, if it's a

00:50:03.830 --> 00:50:04.260
buffered channel.

00:50:04.260 --> 00:50:07.900
For a non-buffered channel like
these, there is no way at

00:50:07.900 --> 00:50:11.690
the moment to find out
how many readers and

00:50:11.690 --> 00:50:12.790
writers there are.

00:50:12.790 --> 00:50:15.410
One of the reasons for that
is any such question is

00:50:15.410 --> 00:50:17.390
inherently unsafe.

00:50:17.390 --> 00:50:20.500
Because if you care how many
readers and writers there are,

00:50:20.500 --> 00:50:22.060
then that's because you're going
to do some computation

00:50:22.060 --> 00:50:23.070
based on that.

00:50:23.070 --> 00:50:26.710
But that computation might be
wrong by the time you end up

00:50:26.710 --> 00:50:28.620
doing the computation,
because the number of

00:50:28.620 --> 00:50:29.840
values could change.

00:50:29.840 --> 00:50:33.080
When you have this kind of thing
it's much more rigorous,

00:50:33.080 --> 00:50:35.300
because you know this
communication actually

00:50:35.300 --> 00:50:38.150
proceeded, and there's
no doubt about that.

00:50:38.150 --> 00:50:39.510
If you say, can I proceed?

00:50:39.510 --> 00:50:40.760
OK, I'll get a value.

00:50:40.760 --> 00:50:42.985
You don't know that someone else
might have come in and

00:50:42.985 --> 00:50:44.550
stolen that value, and you
didn't know about it.

00:50:44.550 --> 00:50:44.980
AUDIENCE: Right.

00:50:44.980 --> 00:50:46.130
ROB PIKE: So it's actually
sort of an

00:50:46.130 --> 00:50:47.350
important point there.

00:50:47.350 --> 00:50:48.870
AUDIENCE: The example I was
thinking of is, let's say in

00:50:48.870 --> 00:50:51.330
your main method, you
create a channel.

00:50:51.330 --> 00:50:53.020
And then you attempt to read
from that channel, but there

00:50:53.020 --> 00:50:54.180
are no writers to
that channel.

00:50:54.180 --> 00:50:55.750
Or the inverse, you attempt to
write to that channel, but

00:50:55.750 --> 00:50:56.670
there are no readers.

00:50:56.670 --> 00:50:57.300
ROB PIKE: Right.

00:50:57.300 --> 00:50:58.920
AUDIENCE: Do you just
block indefinitely?

00:50:58.920 --> 00:50:59.410
Or--

00:50:59.410 --> 00:50:59.600
ROB PIKE: Yeah.

00:50:59.600 --> 00:51:00.740
AUDIENCE: Does it
determine that--

00:51:00.740 --> 00:51:00.970
OK.

00:51:00.970 --> 00:51:01.630
So it doesn't determine--

00:51:01.630 --> 00:51:03.220
ROB PIKE: You'll have to-- you
know, if there's multiple

00:51:03.220 --> 00:51:07.130
writers, then the first guy to
get there gets the first

00:51:07.130 --> 00:51:08.930
value, is how it works.

00:51:08.930 --> 00:51:10.903
And it's FIFO semantics.

00:51:10.903 --> 00:51:11.690
AUDIENCE: OK.

00:51:11.690 --> 00:51:12.210
Thank you.

00:51:12.210 --> 00:51:14.680
ROB PIKE: Yep.

00:51:14.680 --> 00:51:16.050
Any other questions?

00:51:16.050 --> 00:51:19.890
All right, at the back there's
the usual collection of

00:51:19.890 --> 00:51:22.160
goodies to be handed
out carefully.

00:51:22.160 --> 00:51:24.440
Please don't mob the
helpful staff.

00:51:24.440 --> 00:51:25.520
And thanks for coming.

00:51:25.520 --> 00:51:27.070
[APPLAUSE]

