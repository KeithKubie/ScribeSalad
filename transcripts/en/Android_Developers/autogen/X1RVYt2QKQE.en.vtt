WEBVTT
Kind: captions
Language: en

00:00:05.990 --> 00:00:07.448
 good morning everyone. 

00:00:11.192 --> 00:00:13.460
 Wait, don't applaud us. 

00:00:13.460 --> 00:00:15.040
 Leave the applause to the next few people. 

00:00:15.040 --> 00:00:18.210
 I am Romain Guy, a representative of the Android Platform team. 

00:00:18.210 --> 00:00:20.880
 This is the representative of the Tools team, Tor Norbye 

00:00:20.880 --> 00:00:22.205
 But you are not coming for us. 

00:00:22.205 --> 00:00:23.830
 You are here to listen to the speeches of several special guests. 

00:00:23.830 --> 00:00:25.204
 That's right 

00:00:25.204 --> 00:00:27.992
 I have recently been with Komain because of the official introduction of Kotlin. 

00:00:27.992 --> 00:00:28.950
 I feel very excited. 

00:00:28.950 --> 00:00:31.650
 You may have already discovered that both of us especially like Kotlin. 

00:00:31.650 --> 00:00:35.060
 We no longer take up the time for the speakers. 

00:00:35.060 --> 00:00:37.096
 Welcome them. 

00:00:51.500 --> 00:00:54.070
 Hello everyone. 

00:00:54.070 --> 00:00:56.220
 that's good. 

00:00:56.220 --> 00:00:59.040
 So I was thinking a few days ago, 

00:00:59.040 --> 00:01:03.330
 The first time I spoke at Kotlin seems to be 4 and a half years ago. 

00:01:03.330 --> 00:01:08.580
 They gave me a room for 900 people but only 7 people 

00:01:08.580 --> 00:01:11.240
 So itâ€™s nice to see more people appear today. 

00:01:11.240 --> 00:01:12.218
 Thank you 

00:01:16.430 --> 00:01:20.010
 Anyway, I have about 30 minutes or so. 

00:01:20.010 --> 00:01:22.930
 In fact, less than that 

00:01:22.930 --> 00:01:25.844
 Give you a whirlwind Kotlin tour in 28 minutes 

00:01:25.844 --> 00:01:27.760
 So I won't explain the whole language. 

00:01:27.760 --> 00:01:31.790
 I will show you as much as possible within my ability. 

00:01:31.790 --> 00:01:34.220
 How to use it and how it can provide you 

00:01:34.220 --> 00:01:35.410
 Some of the benefits, can you? 

00:01:35.410 --> 00:01:37.890
 So I have to try to do everything with real-time coding. 

00:01:37.890 --> 00:01:41.710
 So if everything goes wrong, then there is a Google video - 

00:01:41.710 --> 00:01:44.290
 I mean there is also a video about this on YouTube. 

00:01:44.290 --> 00:01:45.950
 So you can see that 

00:01:45.950 --> 00:01:48.200
 Ok, so we have to start with something very simple that you have already seen. 

00:01:48.200 --> 00:01:50.580
 That is the data class 

00:01:50.580 --> 00:01:54.480
 And I am in a file called main 

00:01:54.480 --> 00:01:57.250
 So with regard to data classes, I want to create a new type called money. 

00:01:57.250 --> 00:01:59.830
 And the amount of the upcoming Int type 

00:01:59.830 --> 00:02:01.710
 I know, donâ€™t say it now. 

00:02:01.710 --> 00:02:03.870
 It will have a string type of currency 

00:02:03.870 --> 00:02:04.370
 Ok? 

00:02:06.880 --> 00:02:09.180
 This is two attributes, 

00:02:09.180 --> 00:02:10.860
 And they will all be interpreted as only attributes. 

00:02:10.860 --> 00:02:13.530
 So this is something you are already familiar with. 

00:02:13.530 --> 00:02:14.920
 It is essentially a data class 

00:02:14.920 --> 00:02:17.260
 Let's continue to compare it with a Java I have done before. 

00:02:20.740 --> 00:02:23.040
 So vertically separated 

00:02:23.040 --> 00:02:25.400
 Let us raise the Java money - the real 

00:02:25.400 --> 00:02:28.600
 Let's go from here. 

00:02:28.600 --> 00:02:31.480
 Java money - look at it 

00:02:31.480 --> 00:02:35.450
 This is probably equivalent to what I just wrote, right? 

00:02:35.450 --> 00:02:37.340
 A JavaBean is essentially a data class that provides two getters. 

00:02:39.010 --> 00:02:41.870
 They are immutable, so they can only be viewed 

00:02:41.870 --> 00:02:44.300
 And here is the data modifier that is doing 

00:02:44.300 --> 00:02:46.341
 In fact, it is giving me a lot of things. 

00:02:46.341 --> 00:02:49.460
 Like a string, it gives me that clone 

00:02:49.460 --> 00:02:53.340
 This is called copying in Kotlin, it is doing the same thing 

00:02:53.340 --> 00:02:54.470
 It is doing hashCode 

00:02:54.470 --> 00:02:56.164
 Now you said, ok, this is great. 

00:02:56.164 --> 00:02:57.580
 Very good, but why do I need this? 

00:02:57.580 --> 00:03:00.960
 Because any good IDE can generate that for me. 

00:03:00.960 --> 00:03:01.794
 This is true, it can 

00:03:01.794 --> 00:03:03.543
 But the problem is that this is the code you need to maintain. 

00:03:04.630 --> 00:03:06.010
 And every time you add a new attribute 

00:03:06.010 --> 00:03:08.080
 You will have to go back and change that code 

00:03:08.080 --> 00:03:10.246
 And another problem you will encounter is yourself. 

00:03:10.246 --> 00:03:11.950
 I don't know, actually, if that code is 

00:03:11.950 --> 00:03:14.920
 Kotl-- 

00:03:14.920 --> 00:03:17.850
 The standard things that the IDE generates for you, 

00:03:17.850 --> 00:03:18.850
 Or you adjusted a little 

00:03:18.850 --> 00:03:19.820
 Ok? 

00:03:19.820 --> 00:03:23.220
 So this is not just saving on typing on the first line. 

00:03:23.220 --> 00:03:24.250
 Right 

00:03:24.250 --> 00:03:25.750
 Now all I have to do is continue 

00:03:25.750 --> 00:03:27.180
 Then create a main function 

00:03:27.180 --> 00:03:29.370
 Let's turn this off. 

00:03:29.370 --> 00:03:31.360
 This is Kotlin's highest confirmed entry point. 

00:03:31.360 --> 00:03:35.880
 So you have a public static empty main in a class 

00:03:35.880 --> 00:03:37.280
 You don't need to do anything if you use Kotlin 

00:03:37.280 --> 00:03:39.730
 So with Kotlin, you can put everything on the top 

00:03:39.730 --> 00:03:42.360
 It's a bit like JavaScript in good aspects 

00:03:42.360 --> 00:03:46.825
 So you don't have to -- 

00:03:46.825 --> 00:03:49.630
 I want to reiterate that everything I show you today and every function 

00:03:51.840 --> 00:03:53.920
 I want to add it to the file as a top-level thing, 

00:03:53.920 --> 00:03:56.700
 But that doesn't mean you don't have more member functions. 

00:03:57.300 --> 00:03:59.420
 Anything, any category, or even a data class 

00:03:59.420 --> 00:04:00.900
 Can have member functions 

00:04:00.900 --> 00:04:02.460
 But for the sake of brevity 

00:04:02.460 --> 00:04:03.890
 In order to show it to you, 

00:04:03.890 --> 00:04:06.490
 I will put it as the top layer, ok? 

00:04:06.490 --> 00:04:08.920
 So I want to create a new money instance 

00:04:08.920 --> 00:04:11.430
 We are going to name it, like tickets 

00:04:11.430 --> 00:04:16.579
 I will say money 100, will it be the dollar? 

00:04:16.579 --> 00:04:20.240
 I will enter a clear type here. 

00:04:20.240 --> 00:04:22.610
 But in essence what I am doing is type inference 

00:04:22.610 --> 00:04:24.550
 So Kotlin is very good at type inference. 

00:04:24.550 --> 00:04:26.820
 And it will try to infer for you, 

00:04:26.820 --> 00:04:29.350
 So you don't have to explicitly state the type 

00:04:29.350 --> 00:04:32.940
 Then I will say, for example, popcorn 

00:04:32.940 --> 00:04:37.695
 For example, tickets, copy, right? 

00:04:37.695 --> 00:04:39.320
 So basically, what it will do is 

00:04:39.320 --> 00:04:44.550
 Copy the previous and all properties to me 

00:04:44.550 --> 00:04:47.530
 So if I didn't pass in any parameters 

00:04:47.530 --> 00:04:50.570
 It will use the same value as before, good 

00:04:50.570 --> 00:04:52.420
 So I can pass in a new parameter and say 

00:04:52.420 --> 00:04:54.670
 As you know, for example in Spain, popcorn 

00:04:54.670 --> 00:04:57.450
 Seven times the price of the movie entrance 

00:04:57.450 --> 00:04:59.720
 So that would be about 500 euros 

00:04:59.720 --> 00:05:01.650
 Right? 

00:05:01.650 --> 00:05:04.900
 Now I can do something, say 

00:05:04.900 --> 00:05:11.240
 If the ticket is not equal to popcorn 

00:05:11.240 --> 00:05:17.040
 Then println "They are different!" 

00:05:17.040 --> 00:05:20.247
 Then it does this in a one-by-one comparison property 

00:05:20.247 --> 00:05:21.830
 It didn't make a comparison point 

00:05:21.830 --> 00:05:25.670
 For comparison points, we have three equal rights, right? 

00:05:25.670 --> 00:05:27.370
 Unlike JavaScript, it doesn't 

00:05:27.370 --> 00:05:31.120
 A chart that you need to remember, with 600 different locations 

00:05:31.120 --> 00:05:33.552
 And this, by the way, is a font ligature 

00:05:33.552 --> 00:05:35.010
 So don't be confused with that, 

00:05:35.010 --> 00:05:36.910
 We did not introduce new symbols 

00:05:36.910 --> 00:05:38.843
 Ok 

00:05:38.843 --> 00:05:40.776
 So I can go ahead and run this 

00:05:42.710 --> 00:05:44.410
 I understand that they are different 

00:05:44.410 --> 00:05:48.890
 If I change this to 100 and change it to US dollars 

00:05:48.890 --> 00:05:52.500
 Then I run this and it will say nothing to you. 

00:05:52.500 --> 00:05:53.690
 Because they are the same 

00:05:53.690 --> 00:05:54.604
 Ok? 

00:05:54.604 --> 00:05:56.520
 Now, one of our constantly evolving features 

00:05:56.520 --> 00:05:58.940
 Is the interaction between Java and Kotlin 

00:05:58.940 --> 00:06:02.360
 So we have this Java money here. 

00:06:02.360 --> 00:06:05.100
 So I have to continue to create an instance of it 

00:06:05.100 --> 00:06:11.260
 I would say javaMoney is equal to javaMoney, then it will be 100 

00:06:11.260 --> 00:06:13.130
 And it will be the dollar 

00:06:13.130 --> 00:06:16.420
 Then if I do javaMoney, you can see 

00:06:16.420 --> 00:06:18.920
 I don't have any getters 

00:06:18.920 --> 00:06:22.690
 At the time, I did have a getter so I can get the number 

00:06:22.690 --> 00:06:25.450
 But if I write getAmount and finish it 

00:06:25.450 --> 00:06:28.040
 IDE will replace it with an attribute 

00:06:28.040 --> 00:06:30.550
 Because we don't have getters and setters 

00:06:30.550 --> 00:06:32.790
 We just have attributes 

00:06:32.790 --> 00:06:36.270
 So this is to consume Java from Kotlin 

00:06:36.270 --> 00:06:39.420
 If you go to Java here, 

00:06:39.420 --> 00:06:41.490
 Let's continue to create an empty public static main 

00:06:41.490 --> 00:06:42.389
 Then I will do 

00:06:42.389 --> 00:06:44.180
 So let's take a look, I have to declare the type. 

00:06:44.180 --> 00:06:53.410
 Money equals new money, 100, and dollar, and -- 

00:06:53.410 --> 00:06:54.060
 Ok 

00:06:54.060 --> 00:06:57.250
 That is another thing 

00:06:57.250 --> 00:06:59.910
 In Kotlin, the semicolon is optional. 

00:06:59.910 --> 00:07:01.510
 And the reason they are optional is 

00:07:01.510 --> 00:07:03.572
 So you can have endless debates about whether you should use them. 

00:07:07.692 --> 00:07:09.650
 We are trying to compete with JavaScript 

00:07:09.650 --> 00:07:11.920
 Ok, so money. getAmount 

00:07:11.920 --> 00:07:15.047
 So I am using a Java type now - sorry, a Kotlin type from Java 

00:07:15.047 --> 00:07:17.130
 So I will get the getter and setter, right? 

00:07:17.130 --> 00:07:22.110
 So idiom, depending on how you use it 

00:07:22.110 --> 00:07:25.050
 This is just a different Java file, different Kotlin files 

00:07:25.050 --> 00:07:28.880
 In a single project, it works well and has no problems 

00:07:28.880 --> 00:07:32.760
 Ok, so let's continue to create some functions now. 

00:07:32.760 --> 00:07:35.210
 So I am going to create a function called sendPayment 

00:07:35.210 --> 00:07:36.930
 It will take the money -- 

00:07:36.930 --> 00:07:41.879
 And money -- and it will print out the money 

00:07:41.879 --> 00:07:43.670
 Of course we also have string interpolation 

00:07:43.670 --> 00:07:48.095
 So I can say, issue money.amount 

00:07:48.095 --> 00:07:50.470
 And you don't have to put these curly braces if it's just 

00:07:50.470 --> 00:07:51.800
 An attribute you passed in 

00:07:51.800 --> 00:07:53.207
 As we will see later 

00:07:53.207 --> 00:07:55.040
 So now I can call this and say, 

00:07:55.040 --> 00:07:58.290
 For example, sendPayment, tickets, right? 

00:07:58.290 --> 00:08:01.400
 Now at Kotlin, we also have - 

00:08:01.400 --> 00:08:05.090
 Note one thing here, I have not defined the return type. 

00:08:05.090 --> 00:08:07.790
 By default it is a unit, which is a bit like invalid 

00:08:07.790 --> 00:08:08.480
 But it is not 

00:08:08.480 --> 00:08:12.505
 It is actually a basically single object 

00:08:12.505 --> 00:08:15.120
 a single instance of an object 

00:08:15.120 --> 00:08:18.010
 If it's a unit, you don't have to put it there, right? 

00:08:18.010 --> 00:08:21.350
 So I have to add a new parameter here. 

00:08:21.350 --> 00:08:23.600
 Then I will say, for example, with a message 

00:08:23.600 --> 00:08:25.700
 And this becomes a string and you 

00:08:25.700 --> 00:08:27.980
 Can have default parameters 

00:08:27.980 --> 00:08:30.499
 So you notice that there are no compilation errors here. 

00:08:30.499 --> 00:08:31.540
 Because I made a default parameter 

00:08:31.540 --> 00:08:34.039
 This saves you the time to overload the function 

00:08:34.039 --> 00:08:35.580
 Member overload function, right? 

00:08:35.580 --> 00:08:37.870
 I can only have default parameters 

00:08:37.870 --> 00:08:38.870
 Then do what I want 

00:08:38.870 --> 00:08:40.429
 And you can have multiple default parameters 

00:08:40.429 --> 00:08:42.512
 Because you can have multiple default parameters 

00:08:42.512 --> 00:08:47.420
 And you can take turns to pass what you want to pass, 

00:08:47.420 --> 00:08:49.630
 You can also make name parameters 

00:08:49.630 --> 00:08:56.300
 So, actually, I can say that the message is equal to "Good luck!" 

00:08:56.300 --> 00:08:57.300
 There is money equal to the ticket 

00:08:59.430 --> 00:09:02.660
 And this is also quite useful when in use - 

00:09:02.660 --> 00:09:05.740
 You are talking to the old code, for example some 

00:09:05.740 --> 00:09:09.000
 You can't modify the function, they have 600 parameters 

00:09:09.000 --> 00:09:13.100
 And there are about 500 booleans that are true and false. 

00:09:13.100 --> 00:09:16.760
 This will give you a deeper understanding 

00:09:16.760 --> 00:09:18.190
 The parameters I passed in each location 

00:09:22.400 --> 00:09:24.000
 Yes 

00:09:24.000 --> 00:09:25.710
 I like to talk nonsense whenever I like it -- 

00:09:25.710 --> 00:09:26.430
 Clapping 

00:09:31.630 --> 00:09:37.640
 I thought in my heart, it all went very smoothly. 

00:09:37.640 --> 00:09:40.740
 Anyway, ok, let's go. 

00:09:40.740 --> 00:09:43.660
 Edit that, like adult supervision 

00:09:43.660 --> 00:09:44.454
 Ok 

00:09:44.454 --> 00:09:46.120
 Another feature of Kotlin is that 

00:09:46.120 --> 00:09:49.160
 When we have very simple functions 

00:09:49.160 --> 00:09:52.120
 Basically like returning a single value 

00:09:52.120 --> 00:09:56.150
 You can just execute a single expression function 

00:09:56.150 --> 00:09:59.130
 So I explicitly omitted the return type 

00:09:59.130 --> 00:10:02.740
 I omitted the braces, then I just returned the actual function I wanted to do. 

00:10:03.500 --> 00:10:04.830
 Ok? 

00:10:04.830 --> 00:10:08.760
 So, in fact, the concept of expression 

00:10:08.760 --> 00:10:10.150
 Appear in many places in Kotlin 

00:10:10.150 --> 00:10:12.066
 So, for example, let's create another function called convert ToDollars. 

00:10:12.066 --> 00:10:15.380
 convertToDollars, 

00:10:15.380 --> 00:10:19.080
 This will cost a dollar 

00:10:19.080 --> 00:10:22.100
 Money, then it will give back money 

00:10:22.100 --> 00:10:23.600
 Then what we have to do here 

00:10:23.600 --> 00:10:27.310
 Is a time statement, so this is essentially an example 

00:10:27.310 --> 00:10:32.670
 So when money_currency is the dollar 

00:10:32.670 --> 00:10:38.297
 Then we will return the money as we are now, right? 

00:10:38.297 --> 00:10:39.380
 Because I don't need to do anything 

00:10:39.380 --> 00:10:43.490
 If it is the euro, then all I have to do is return it. 

00:10:43.490 --> 00:10:50.682
 We have to do money.amount multiply -- 

00:10:50.682 --> 00:10:52.390
 Sorry, I have to create a new instance. 

00:10:52.390 --> 00:10:59.810
 Money, then it will be money.amount multiplied by BigDecimal 

00:10:59.810 --> 00:11:04.830
 1.10, then that will be the dollar 

00:11:04.830 --> 00:11:09.300
 Also, remove the IllegalArgumentException 

00:11:09.300 --> 00:11:15.140
 "Not the currency you are interested in!" 

00:11:15.140 --> 00:11:18.590
 So here you can actually treat a few hours as an expression 

00:11:18.590 --> 00:11:22.240
 So I can delete this return here, delete this return here, 

00:11:22.240 --> 00:11:25.480
 Put it here, then this is just 

00:11:25.480 --> 00:11:29.060
 Let time always return to an expression 

00:11:29.060 --> 00:11:33.440
 In fact, you can even delete the return here. 

00:11:33.440 --> 00:11:37.760
 Delete the money here, and delete the one there 

00:11:37.760 --> 00:11:39.350
 Then you will get a single expression 

00:11:39.350 --> 00:11:40.150
 Ok? 

00:11:40.150 --> 00:11:41.460
 Function of a single expression 

00:11:41.460 --> 00:11:42.910
 Now you notice one thing here. 

00:11:42.910 --> 00:11:46.330
 That is giving me a mistake here because this is - 

00:11:46.330 --> 00:11:49.060
 I am trying to manipulate a BigDecimal with an int 

00:11:49.060 --> 00:11:51.210
 So we have to refactor this 

00:11:51.210 --> 00:11:54.300
 Then we intend to call it BigDecimal, ok 

00:11:54.300 --> 00:11:57.700
 Now talk about BigDecimal, oh, let's get started. 

00:11:57.700 --> 00:12:06.430
 BigDecimal, BigDecimal 100 and BigDecimal-- 

00:12:06.430 --> 00:12:08.670
 I like to type BigDecimal 

00:12:08.670 --> 00:12:11.510
 I like to do this. 

00:12:11.510 --> 00:12:14.330
 So we have this here 

00:12:14.330 --> 00:12:17.120
 Now, if you look at it, actually, BigDecimal-- 

00:12:17.120 --> 00:12:20.140
 So if I create a new BigDecimal, we call it bd1 

00:12:20.140 --> 00:12:23.170
 Equal to BigDecimal 100 

00:12:23.170 --> 00:12:25.790
 You can see that bd1 gives me a bunch of functions. 

00:12:25.790 --> 00:12:28.260
 Like, divide, multiply, all these things 

00:12:28.260 --> 00:12:30.780
 What if I want to do something like a percentage? 

00:12:30.780 --> 00:12:33.660
 I want a percentage of BigDecimal 

00:12:33.660 --> 00:12:37.370
 Usually you will basically 

00:12:37.370 --> 00:12:39.597
 Inherit and then create your own version 

00:12:39.597 --> 00:12:41.430
 And have all these things, but in Kotlin 

00:12:41.430 --> 00:12:42.600
 One of the features we added - 

00:12:42.600 --> 00:12:43.760
 If you are familiar with C#-- 

00:12:43.760 --> 00:12:45.760
 It's called an extension function, which actually 

00:12:45.760 --> 00:12:48.700
 Means you can accept any category, any type and extend it 

00:12:48.700 --> 00:12:50.957
 So I can take a function of BigDecimal 

00:12:50.957 --> 00:12:53.040
 I type the name of the class I want to extend. 

00:12:53.040 --> 00:12:55.005
 Then I said that I want to make a percentage point 

00:12:55.005 --> 00:12:56.380
 And what percentage of what I want to do, 

00:12:56.380 --> 00:13:00.810
 For example, an integer, then itâ€™s going to be like that 

00:13:00.810 --> 00:13:01.540
 let us see 

00:13:01.540 --> 00:13:03.950
 So we are told that this is an extension function 

00:13:03.950 --> 00:13:07.891
 It will have this class, an instance of the object 

00:13:07.891 --> 00:13:08.390
 correct 

00:13:08.390 --> 00:13:10.700
 So I can use that, use this reference. 

00:13:10.700 --> 00:13:15.919
 Then I said this multiplied by that percentage - 

00:13:15.919 --> 00:13:18.210
 Then this must be wrapped again in a bigdecimal -- 

00:13:19.180 --> 00:13:20.810
 percentage 

00:13:20.810 --> 00:13:24.870
 Then divide by -- 

00:13:24.870 --> 00:13:29.350
 Then another BigDecimal 100 

00:13:29.350 --> 00:13:33.290
 What is wrong with this, it should be a percentage 

00:13:33.290 --> 00:13:36.120
 Therefore, the percentage-to-ratio 

00:13:36.120 --> 00:13:42.240
 Ok, so what happens now is on bd1, I have a percentage 

00:13:42.240 --> 00:13:43.170
 Ok 

00:13:43.170 --> 00:13:46.250
 I can enter a percentage of seven, then that will give me 

00:13:46.250 --> 00:13:47.360
 a certain percentage 

00:13:47.360 --> 00:13:49.890
 And the extension function is included in 

00:13:49.890 --> 00:13:51.760
 Any location defined in the package 

00:13:51.760 --> 00:13:55.560
 So for this case, I have it in com.jetbrains.gio 

00:13:55.560 --> 00:13:57.307
 And that will be included 

00:13:57.307 --> 00:13:58.890
 So you can create extension functions 

00:13:58.890 --> 00:14:00.560
 And we will see that the standard library actually 

00:14:00.560 --> 00:14:02.669
 Composed of a bunch of extension functions 

00:14:02.669 --> 00:14:04.210
 Now let's go one step further 

00:14:04.210 --> 00:14:06.670
 Because I can actually extend everything 

00:14:06.670 --> 00:14:08.890
 So let's continue to extend an integer. 

00:14:08.890 --> 00:14:11.720
 So I will type fun Int 

00:14:11.720 --> 00:14:15.760
 percentOf, and here we will do the opposite 

00:14:15.760 --> 00:14:19.120
 So I want 10% of things, right. 

00:14:19.120 --> 00:14:22.600
 I use money, for example, I want 10% of the money. 

00:14:22.600 --> 00:14:26.460
 That will be returned 

00:14:26.460 --> 00:14:30.250
 Let us see, it will return the money 

00:14:30.250 --> 00:14:34.480
 Then it will be the quantity. Multiply by, then here it will 

00:14:34.480 --> 00:14:37.760
 Quote the actual instance, so it will be like this - 

00:14:37.760 --> 00:14:42.720
 And again, this must be wrapped in BigDecimal 

00:14:42.720 --> 00:14:46.970
 Then divide by 100 

00:14:46.970 --> 00:14:47.510
 Ok 

00:14:47.510 --> 00:14:50.330
 I think I have caught the right order. 

00:14:50.330 --> 00:14:52.690
 If the execution is wrong, it doesn't matter. 

00:14:52.690 --> 00:14:53.480
 Who cares? 

00:14:53.480 --> 00:14:57.440
 Anyway, what I can do now is something like this. 

00:14:57.440 --> 00:15:05.410
 Seven percent of BigDecimal 100 

00:15:05.410 --> 00:15:05.910
 Ok? 

00:15:05.910 --> 00:15:06.630
 Oh, no, sorry. 

00:15:06.630 --> 00:15:07.620
 money 

00:15:07.620 --> 00:15:11.030
 So I can make money - no, don't clap first 

00:15:11.030 --> 00:15:12.100
 money 

00:15:12.100 --> 00:15:13.720
 Oh, let's take the money I have. 

00:15:13.720 --> 00:15:15.090
 7.percentOf (popcorn). 

00:15:15.090 --> 00:15:16.420
 Ok, ok? 

00:15:20.350 --> 00:15:22.150
 Let's do a little better 

00:15:22.150 --> 00:15:24.690
 In fact, what I want to do is something like this 

00:15:24.690 --> 00:15:28.720
 I want to make 7 percentOf popcorn 

00:15:28.720 --> 00:15:29.662
 That's very good 

00:15:29.662 --> 00:15:30.870
 You can actually do that 

00:15:30.870 --> 00:15:32.420
 Do you see that little creeping thing? 

00:15:32.420 --> 00:15:33.340
 What is the twist? 

00:15:33.340 --> 00:15:35.090
 Alt, Enter, add 'infix' 

00:15:35.090 --> 00:15:36.050
 That would be fine 

00:15:36.050 --> 00:15:40.840
 Ok, so any extension function with a single argument 

00:15:40.840 --> 00:15:42.839
 Infix symbol 

00:15:42.839 --> 00:15:44.380
 And what I did was 

00:15:44.380 --> 00:15:45.512
 Add infixes there 

00:15:45.512 --> 00:15:46.970
 And this is for you to follow 

00:15:46.970 --> 00:15:50.390
 Kotlin creates some things about the entire DSL way 

00:15:52.350 --> 00:15:53.050
 correct 

00:15:53.050 --> 00:15:57.320
 So one thing I hate to do here is all the BigDecimal here. 

00:15:57.320 --> 00:15:59.210
 That is very painful 

00:15:59.210 --> 00:16:02.600
 In Kotlin, when you want to create a value of type 'long' 

00:16:02.600 --> 00:16:05.334
 You can enter a length of 100L, then that will become a long type 

00:16:05.334 --> 00:16:06.750
 If I can do this, 

00:16:06.750 --> 00:16:12.940
 Bd2 is equal to 100BD, which would be great, but you can't, 

00:16:12.940 --> 00:16:14.050
 And there is no built-in 

00:16:14.050 --> 00:16:16.910
 But what we have in Kotlin is the extended attribute. 

00:16:16.910 --> 00:16:19.050
 They are completely similar to the extension function 

00:16:19.050 --> 00:16:21.750
 In addition to their extension with attributes 

00:16:21.750 --> 00:16:26.950
 So I can do something like .bd, right? 

00:16:26.950 --> 00:16:30.587
 Now -- or let us, so now -- 

00:16:30.587 --> 00:16:33.170
 Look, it also says that you want to create an extended attribute in an integer class? 

00:16:34.420 --> 00:16:35.430
 Want 

00:16:35.430 --> 00:16:39.260
 So this will return a BigDecimal 

00:16:39.260 --> 00:16:48.330
 Then here, I am going to return BigDecimal, 

00:16:48.330 --> 00:16:49.570
 And this is the instance 

00:16:49.570 --> 00:16:51.740
 In fact, I can convert it into an expression, 

00:16:51.740 --> 00:16:53.700
 Make it easier 

00:16:53.700 --> 00:16:54.670
 So that's it 

00:16:54.670 --> 00:16:57.330
 Now I have 100.bd 

00:16:57.330 --> 00:16:58.930
 So when I submit it, 

00:16:58.930 --> 00:17:03.599
 It looks better than BigDecimal, 

00:17:03.599 --> 00:17:04.099
 Ok? 

00:17:10.960 --> 00:17:13.160
 You can do another thing about the function 

00:17:13.160 --> 00:17:16.560
 Yes, you can extend some operators 

00:17:16.560 --> 00:17:19.141
 So you can extend, for example, the plus operator 

00:17:19.141 --> 00:17:21.599
 And what I have to do is that I donâ€™t intend to enter this. 

00:17:21.599 --> 00:17:24.614
 I have a good little thing that has done this for me. 

00:17:24.720 --> 00:17:26.760
 See how fast I type? 

00:17:26.760 --> 00:17:29.130
 So basically, what I am doing is 

00:17:29.130 --> 00:17:30.890
 For the money to rewrite the plus operator 

00:17:30.890 --> 00:17:38.960
 So now I can say that the cost is equal to the ticket plus popcorn, right. 

00:17:38.960 --> 00:17:41.960
 This allows me to increase the amount of money 

00:17:41.960 --> 00:17:44.410
 Ok, you can do it by adding, subtracting, multiplying. 

00:17:44.410 --> 00:17:46.820
 You can follow some of the built-in conventions that allow you to do this. 

00:17:50.970 --> 00:17:51.690
 Ok 

00:17:51.690 --> 00:17:54.330
 So we created a lot of types here 

00:17:54.330 --> 00:17:58.140
 Let me continue to delete everything so that we can focus 

00:17:58.140 --> 00:17:59.890
 We have created a lot of types here. 

00:17:59.890 --> 00:18:02.056
 Please note that in any of these types I created 

00:18:02.056 --> 00:18:05.220
 I never really specified a type, but you can 

00:18:05.220 --> 00:18:10.700
 So I can do it, for example, the cost of a tile train 

00:18:10.700 --> 00:18:14.520
 For example, the train is a type of money 

00:18:14.520 --> 00:18:18.500
 Then initialize it to a new value, right. 

00:18:18.500 --> 00:18:22.360
 100.bd, then the dollar 

00:18:22.360 --> 00:18:25.439
 Now if I move on and enter the train = null 

00:18:25.439 --> 00:18:26.730
 It will show me an error 

00:18:26.730 --> 00:18:28.646
 It actually shows me two errors 

00:18:28.646 --> 00:18:31.190
 One of them is because it is a constant variable 

00:18:31.190 --> 00:18:32.320
 So I can solve this problem 

00:18:32.320 --> 00:18:34.180
 I have now changed this to be variable. 

00:18:34.180 --> 00:18:36.210
 You will see the IDE emphasize it 

00:18:36.210 --> 00:18:39.510
 So it wants to point out that 

00:18:39.510 --> 00:18:40.860
 This is really something you have to escape 

00:18:40.860 --> 00:18:43.150
 We do not enforce invariance in Kotlin 

00:18:43.150 --> 00:18:44.657
 But we highly recommend it 

00:18:44.657 --> 00:18:49.420
 By default, all lists and all of them are immutable 

00:18:49.470 --> 00:18:53.380
 So I can't assign null values â€‹â€‹in Kotlin. 

00:18:53.380 --> 00:18:55.460
 Because Kotlin tried to explain this type by default is not possible 

00:18:55.460 --> 00:18:58.730
 To get rid of the exception of the null pointer, right. 

00:18:58.730 --> 00:19:00.390
 But sometimes, 

00:19:00.390 --> 00:19:02.990
 You want to have an empty type, for whatever reason, 

00:19:02.990 --> 00:19:04.230
 You feel bored 

00:19:04.230 --> 00:19:07.240
 And you can add a question mark. 

00:19:07.240 --> 00:19:10.965
 Then this will enable you to assign a null value to the type. 

00:19:10.965 --> 00:19:12.840
 Usually when you work with Kotlin, 

00:19:12.840 --> 00:19:13.900
 You may not want to do this 

00:19:13.900 --> 00:19:15.858
 You may not want to have an empty type 

00:19:15.858 --> 00:19:21.610
 But since we interact with Java, Java can be null 

00:19:21.610 --> 00:19:25.480
 So if I create a function here, 

00:19:25.480 --> 00:19:32.150
 For example, fun javaMoney, that would take the money of JavaMoney type 

00:19:32.150 --> 00:19:34.100
 Then use it to do anything 

00:19:34.100 --> 00:19:44.020
 So for example, I type println money.amount is valid. 

00:19:44.020 --> 00:19:47.060
 So this can be null 

00:19:47.060 --> 00:19:49.252
 It can, if it is one, for example, 

00:19:49.252 --> 00:19:51.210
 Return an instance call of this type of function, 

00:19:51.210 --> 00:19:52.550
 It can be null 

00:19:52.550 --> 00:19:55.370
 You can indicate by adding a question mark 

00:19:55.370 --> 00:19:58.060
 When you do this, you can see the IDE 

00:19:58.060 --> 00:19:59.790
 Will give you the error 

00:19:59.790 --> 00:20:02.570
 It says only safe operators, or double exclamation points 

00:20:02.570 --> 00:20:04.260
 It is effective here because it is basically 

00:20:04.260 --> 00:20:06.718
 Saying you will encounter an empty reference exception 

00:20:06.718 --> 00:20:08.590
 So there are two ways to solve this problem 

00:20:08.590 --> 00:20:12.200
 First, you can say, for example, money, not null 

00:20:12.200 --> 00:20:17.840
 Then do one if it is not null, then continue to operate it 

00:20:17.840 --> 00:20:20.410
 Put this upstairs 

00:20:20.410 --> 00:20:21.340
 Ok 

00:20:21.340 --> 00:20:22.460
 That is a method 

00:20:22.460 --> 00:20:26.980
 Or a shorter way is to use a safe operator or 

00:20:26.980 --> 00:20:28.740
 This is the Elvis operator here. 

00:20:28.740 --> 00:20:33.330
 So now we only say that if the money is not null, then do something. 

00:20:33.330 --> 00:20:36.270
 Now, if you want to have fun, you can do the same. 

00:20:36.270 --> 00:20:38.490
 Then the one said, I know it is empty, 

00:20:38.490 --> 00:20:39.990
 But I want to shoot on my own feet. 

00:20:39.990 --> 00:20:41.505
 Ok? 

00:20:41.505 --> 00:20:43.130
 And you have to be careful 

00:20:43.130 --> 00:20:45.480
 Because many times when people start using Kotlin 

00:20:45.480 --> 00:20:47.876
 They got this little, twisted thing here. 

00:20:47.876 --> 00:20:49.250
 Then they will behave like this, actually, 

00:20:49.250 --> 00:20:50.810
 I don't know if it will become null, 

00:20:50.810 --> 00:20:52.397
 Because I really want it not to become null 

00:20:52.397 --> 00:20:54.730
 So I won't handle the case where it is not null 

00:20:54.730 --> 00:20:55.894
 So I only do that 

00:20:55.894 --> 00:20:58.310
 They ran the app and they thought, wait a minute 

00:20:58.310 --> 00:21:00.940
 You have set Kotlin to get rid of null reference exceptions 

00:21:00.940 --> 00:21:01.440
 Yes 

00:21:04.210 --> 00:21:06.380
 Ok 

00:21:06.380 --> 00:21:07.030
 What else 

00:21:07.030 --> 00:21:07.610
 correct 

00:21:07.610 --> 00:21:09.270
 So let's switch to some other things. 

00:21:09.270 --> 00:21:11.176
 Like higher order functions 

00:21:11.176 --> 00:21:13.550
 Now, you are all familiar with higher-order functions, 

00:21:13.550 --> 00:21:15.810
 This function is basically an accept function 

00:21:15.810 --> 00:21:18.420
 Or return the function's function, and we have these things in Kotlin 

00:21:18.420 --> 00:21:22.550
 So we can enter the list of findEmails user users 

00:21:22.550 --> 00:21:25.150
 Then I will create a new function that is a predicate 

00:21:25.150 --> 00:21:27.040
 So I am passing a function here, right 

00:21:27.040 --> 00:21:30.650
 a function that takes a string and returns a boolean 

00:21:30.650 --> 00:21:31.670
 Ok? 

00:21:31.670 --> 00:21:34.971
 Then this may return the user list 

00:21:34.971 --> 00:21:36.470
 So essentially what I am doing is that I am 

00:21:36.470 --> 00:21:38.050
 Filter on a list of users 

00:21:38.050 --> 00:21:39.410
 correct 

00:21:39.410 --> 00:21:43.050
 I will do this later. 

00:21:43.050 --> 00:21:45.670
 Do it later 

00:21:45.670 --> 00:21:46.810
 Ok 

00:21:46.810 --> 00:21:48.450
 By the way, this later is built in. 

00:21:48.450 --> 00:21:51.180
 You can use it without an unimplemented exception - 

00:21:51.180 --> 00:21:52.241
 Unrealized error 

00:21:52.241 --> 00:21:54.490
 It will do another thing, but we will not discuss it, 

00:21:54.490 --> 00:21:58.020
 But nothing in Kotlin is very good 

00:21:58.020 --> 00:21:59.235
 But we wonâ€™t explore those now 

00:22:01.910 --> 00:22:03.300
 It has nothing to worry about 

00:22:06.390 --> 00:22:07.280
 I just edited it. 

00:22:07.280 --> 00:22:08.620
 Ok 

00:22:08.620 --> 00:22:09.970
 Okay thank you 

00:22:09.970 --> 00:22:13.770
 So how do I use this now? 

00:22:13.770 --> 00:22:17.490
 I can type findEmails, yes, then I will say - 

00:22:17.490 --> 00:22:19.970
 I actually have a user, let's create some users here. 

00:22:19.970 --> 00:22:22.060
 So userFromJSONFile 

00:22:22.060 --> 00:22:24.640
 I have some use here, so users.json 

00:22:24.640 --> 00:22:28.350
 So this is actually a function I prepared, 

00:22:28.350 --> 00:22:31.570
 It basically uses json to read some users from the file. 

00:22:31.570 --> 00:22:32.946
 This is a typical data class, 

00:22:32.946 --> 00:22:34.779
 You have seen it, the only new thing here. 

00:22:34.779 --> 00:22:39.021
 Is this also has an enumeration class with attribute roles 

00:22:39.520 --> 00:22:40.770
 Ok? 

00:22:40.770 --> 00:22:43.600
 So now I can enter the user, 

00:22:43.600 --> 00:22:45.120
 Then I will pass in the function 

00:22:45.120 --> 00:22:46.920
 Now I can pass the name function using the row and column reference 

00:22:48.760 --> 00:22:50.380
 Or you can pass in lambda 

00:22:50.380 --> 00:22:52.690
 In Kotlin, lambda follows this syntax. 

00:22:52.690 --> 00:22:57.510
 You pass in the parameter name, then you say, for example, 

00:22:57.510 --> 00:23:01.090
 The parameter name ends with .com, right. 

00:23:01.090 --> 00:23:04.880
 So I get a list of users ending with .com 

00:23:04.880 --> 00:23:08.880
 Now you have a single parameter in Kotlin 

00:23:08.880 --> 00:23:12.180
 You can actually omit the explicit mention 

00:23:12.180 --> 00:23:14.980
 It replaces it with it. 

00:23:14.980 --> 00:23:17.277
 So you can use it just like Groovy 

00:23:17.277 --> 00:23:19.110
 Another thing you can do in Kotlin 

00:23:19.110 --> 00:23:22.710
 Is the last parameter of the function is another function 

00:23:22.710 --> 00:23:28.220
 You can actually not include it in parentheses 

00:23:28.220 --> 00:23:31.615
 So it feels a bit like itâ€™s outside 

00:23:31.615 --> 00:23:33.740
 And this is let us 

00:23:33.740 --> 00:23:36.220
 Create one of the nice DSL features you can even 

00:23:36.220 --> 00:23:37.770
 Do this in multiple lines 

00:23:37.770 --> 00:23:40.140
 So if you look at findEmails now, in a sense, 

00:23:40.140 --> 00:23:43.900
 It may actually be like a part of the language 

00:23:43.900 --> 00:23:45.620
 But it is not, it is actually a function 

00:23:45.620 --> 00:23:51.080
 When we use a coroutine to implement asynchronous programming, 

00:23:51.080 --> 00:23:53.630
 We didn't - you know 

00:23:53.630 --> 00:23:56.000
 If you are familiar with C#, C# will implement synchronization or wait 

00:23:56.000 --> 00:23:57.560
 There are keywords in the language 

00:23:57.560 --> 00:23:58.935
 In Kotlin, there is no such thing, 

00:23:58.935 --> 00:24:00.660
 They are basically just functions 

00:24:00.660 --> 00:24:02.150
 This way, you have the flexibility 

00:24:02.150 --> 00:24:06.170
 Decide how to do different things 

00:24:06.170 --> 00:24:08.140
 Now you don't need to do all these things, 

00:24:08.140 --> 00:24:09.848
 Because all of these are built in 

00:24:09.848 --> 00:24:12.220
 So, for example, if I say dotComUsers 

00:24:12.220 --> 00:24:16.480
 I said users.filter, you can see, when I finish this, 

00:24:16.480 --> 00:24:20.170
 It actually chooses the version that contains the parameter 

00:24:20.170 --> 00:24:26.790
 So I can say that it should be emailed with .endsWith .com 

00:24:26.880 --> 00:24:32.340
 Then I can sort by it.id. 

00:24:32.340 --> 00:24:35.030
 Then let's keep doing, 

00:24:35.030 --> 00:24:44.520
 For example mapping that to a pair of it.email and it.username 

00:24:44.520 --> 00:24:45.057
 Ok? 

00:24:45.057 --> 00:24:46.640
 So all these features are actually 

00:24:46.640 --> 00:24:48.266
 Built in the small standard library that will be sent, 

00:24:48.266 --> 00:24:50.640
 You won't have problems on Android 

00:24:50.640 --> 00:24:51.310
 It is very small 

00:24:51.310 --> 00:24:54.360
 And essentially, they are all inside, the extension function 

00:24:54.360 --> 00:24:58.180
 Above the universal collection, 

00:24:58.180 --> 00:25:05.310
 So you have these very practical and practical things today. 

00:25:05.470 --> 00:25:10.380
 So this obviously gives you a pair 

00:25:10.380 --> 00:25:12.960
 And in fact, you can do better, 

00:25:12.960 --> 00:25:17.760
 If it is not in pairs, it, 

00:25:17.760 --> 00:25:19.730
 So a map, email, to the username 

00:25:19.730 --> 00:25:20.800
 Guess what? 

00:25:20.800 --> 00:25:25.460
 This is just an infix function that makes it a pair. 

00:25:25.460 --> 00:25:27.102
 Ok? 

00:25:27.102 --> 00:25:29.060
 Sometimes I won't explain the entire map. 

00:25:29.060 --> 00:25:33.060
 For example, I just want to say get back a single element 

00:25:33.060 --> 00:25:37.690
 What you can also do is reorganize the categories in Kotlin. 

00:25:37.690 --> 00:25:39.470
 Data class 

00:25:39.470 --> 00:25:44.030
 So I can do something like ID, username and email 

00:25:44.030 --> 00:25:47.670
 Ok, then I can use the ID 

00:25:47.670 --> 00:25:50.000
 And it's great, but the IDE complains, 

00:25:50.000 --> 00:25:51.557
 This variable has never been used 

00:25:51.557 --> 00:25:56.360
 In this case, you can actually replace it with an underscore 

00:25:56.880 --> 00:25:58.180
 So just like this 

00:25:58.180 --> 00:26:00.015
 You can refactor the value you want 

00:26:00.015 --> 00:26:02.640
 Anything you don't want to use is replaced with an underscore. 

00:26:02.640 --> 00:26:04.690
 Then you can continue 

00:26:04.690 --> 00:26:05.900
 Correct 

00:26:05.900 --> 00:26:07.920
 So what else can I show to you? 

00:26:07.920 --> 00:26:08.640
 Ok 

00:26:08.640 --> 00:26:11.170
 So I have some other code here. 

00:26:11.170 --> 00:26:13.850
 If you are familiar with the concept of algebraic data types 

00:26:13.850 --> 00:26:16.872
 It can be a kind in nature 

00:26:16.872 --> 00:26:19.330
 Type or other type of type, like a boolean 

00:26:19.330 --> 00:26:21.710
 In Kotlin, the way we do this is to use component classes. 

00:26:21.710 --> 00:26:23.250
 But before I got into that, 

00:26:23.250 --> 00:26:25.190
 Let me continue to enter open here 

00:26:25.190 --> 00:26:28.470
 Note the first thing here, the result of that user 

00:26:28.470 --> 00:26:29.730
 Give me a mistake 

00:26:29.730 --> 00:26:32.840
 Because by default, in Kotlin, you can't inherit from the category. 

00:26:32.940 --> 00:26:34.851
 So all the classes are essentially finalized. 

00:26:34.851 --> 00:26:36.350
 If you want to inherit from the class 

00:26:36.350 --> 00:26:40.870
 You have to use the open modifier, right? 

00:26:40.870 --> 00:26:43.650
 Now I have used the sealed, sealed 

00:26:43.650 --> 00:26:46.010
 Essentially, this is the hierarchy of user results. 

00:26:48.510 --> 00:26:50.540
 There won't be any other classes, 

00:26:50.540 --> 00:26:54.210
 In any place, will inherit from the user's results 

00:26:54.210 --> 00:26:56.360
 Everything that will be inherited from user results 

00:26:56.360 --> 00:26:59.950
 Must be in the same file, or you can turn these into subclasses 

00:27:01.000 --> 00:27:06.070
 So I can move it to the top and then this will be a subclass 

00:27:06.070 --> 00:27:10.000
 But I have to prefix it with user results 

00:27:10.000 --> 00:27:10.860
 Ok 

00:27:10.860 --> 00:27:16.830
 I just created it as an outside class 

00:27:16.830 --> 00:27:20.320
 Then why should I do this? 

00:27:20.320 --> 00:27:21.452
 Because it looks good? 

00:27:21.452 --> 00:27:22.442
 Do not 

00:27:22.442 --> 00:27:24.400
 This is actually very good, 

00:27:24.400 --> 00:27:27.940
 Because when you are doing something, it's often like you are calling a function 

00:27:27.940 --> 00:27:30.110
 Then you think, okay, if successful, 

00:27:30.110 --> 00:27:31.300
 I want it to give back a value 

00:27:31.300 --> 00:27:33.320
 If it is null, I will pass in a message 

00:27:33.320 --> 00:27:36.530
 Then you get this type, 

00:27:36.530 --> 00:27:38.094
 It contains the value you want to give back when you succeed. 

00:27:38.094 --> 00:27:40.510
 It contains the type you want to return when there is a message, 

00:27:40.510 --> 00:27:42.343
 Then you have to figure it out 

00:27:42.343 --> 00:27:45.740
 Which attributes are applied to the semantics of the error condition, 

00:27:45.740 --> 00:27:48.050
 Which properties apply to 

00:27:48.050 --> 00:27:51.832
 Non-error situation, or you can throw an exception 

00:27:51.832 --> 00:27:53.540
 In this case, you can use 

00:27:53.540 --> 00:27:54.960
 Basically returning two types of functions 

00:27:54.960 --> 00:27:58.070
 Then according to the results, do different things 

00:27:58.070 --> 00:28:01.460
 So here I say, for example, when - 

00:28:01.460 --> 00:28:08.500
 Let's create an instant val, the result is equal to the user result - 

00:28:08.500 --> 00:28:10.830
 Sorry, it should be retrieving users. 

00:28:10.830 --> 00:28:17.490
 So now I can type, when the result is successful 

00:28:17.490 --> 00:28:19.880
 Then we have to do, for example, 

00:28:19.880 --> 00:28:21.255
 We are going to get results, 

00:28:21.255 --> 00:28:31.290
 Then we enter the name forEach println 

00:28:31.290 --> 00:28:33.120
 Ok? 

00:28:33.120 --> 00:28:35.320
 username 

00:28:35.320 --> 00:28:39.550
 Then we have to fail 

00:28:39.550 --> 00:28:44.370
 Result println result.message 

00:28:44.370 --> 00:28:46.090
 Ok? 

00:28:46.090 --> 00:28:49.390
 So now based on the result, 

00:28:49.390 --> 00:28:52.570
 According to the type of feedback, I can do different things. 

00:28:52.570 --> 00:28:55.290
 I noticed one thing here, that is, it has turned green. 

00:28:55.290 --> 00:28:56.560
 I don't know if you see it on the big screen. 

00:28:56.560 --> 00:28:57.680
 But this has turned green 

00:28:57.680 --> 00:28:58.960
 This is an intelligent casting 

00:28:58.960 --> 00:29:00.918
 This is another thing we have at Kotlin. 

00:29:00.918 --> 00:29:04.402
 And you see that when I am doing a short check, 

00:29:04.402 --> 00:29:06.860
 It has been said that this is not null because it is intelligent casting 

00:29:06.860 --> 00:29:10.010
 So you don't have to come here explicitly. 

00:29:10.010 --> 00:29:14.480
 Oh, I know this is a success type, 

00:29:14.480 --> 00:29:17.650
 Let me continue to invest in this to the successful type in order to access this property. 

00:29:17.650 --> 00:29:19.510
 The compiler will do this for you, 

00:29:19.510 --> 00:29:22.260
 This is the intelligent casting 

00:29:22.260 --> 00:29:23.170
 correct 

00:29:23.170 --> 00:29:25.790
 Finally, before I handed it to Andrey 

00:29:25.790 --> 00:29:28.510
 I mentioned it quickly, and, 

00:29:28.510 --> 00:29:31.490
 There are a lot of things you see with a filter map, 

00:29:31.490 --> 00:29:36.700
 All of these are essentially eager assessments 

00:29:36.700 --> 00:29:39.470
 But we also have the ability to make lazy assessments 

00:29:39.470 --> 00:29:43.250
 So I can do val, for example, sorry, generateSequence 

00:29:43.250 --> 00:29:46.320
 Then there are some things like 1 

00:29:46.320 --> 00:29:57.280
 Then here we will do it multiplied by 10, then we will do the value 

00:29:57.280 --> 00:30:07.740
 Now I will say values.take(10), then forEach println it 

00:30:07.740 --> 00:30:10.220
 Now this is essentially creating a sequence 

00:30:10.220 --> 00:30:11.529
 An infinite generator 

00:30:11.529 --> 00:30:12.570
 It will never stop 

00:30:12.570 --> 00:30:14.720
 It will start at 1 and multiply by 10. 

00:30:14.720 --> 00:30:18.320
 But what I am saying here is that I only want to take 10 elements. 

00:30:18.320 --> 00:30:19.800
 Then print it out 

00:30:19.800 --> 00:30:23.140
 What it will do is basically consume it until it reaches 10 

00:30:23.140 --> 00:30:25.170
 It prints out -- go away -- 

00:30:28.830 --> 00:30:34.430
 It prints out one side, beautiful Christmas tree 

00:30:35.420 --> 00:30:39.100
 Ok, pyramid, casual, and park there 

00:30:39.100 --> 00:30:41.260
 Anything you have, for example 

00:30:41.260 --> 00:30:48.670
 The user we have, the user from Jason, users.json, 

00:30:48.670 --> 00:30:51.750
 You can say asSequence and convert it to a lazy evaluation. 

00:30:52.250 --> 00:30:53.094
 Ok? 

00:30:53.094 --> 00:30:55.010
 This is the time we have today to show you 

00:30:55.010 --> 00:30:58.000
 Obviously, this language has more details. 

00:30:58.000 --> 00:30:59.941
 Go online and get to know everything. 

00:30:59.941 --> 00:31:00.940
 Thank you very much 

00:31:00.940 --> 00:31:02.260
 I will hand it over to Andrey. 

00:31:06.400 --> 00:31:08.170
 Thank you, Hadi 

00:31:08.170 --> 00:31:09.720
 Hello everyone 

00:31:09.720 --> 00:31:15.120
 So as you can see, Kotlin already has a lot of things to prepare. 

00:31:15.120 --> 00:31:19.554
 But I am the annoying person who added new features before you learn the existing ones. 

00:31:19.960 --> 00:31:22.140
 So I will tell you your story now. 

00:31:22.140 --> 00:31:23.936
 But I need to find a clicker 

00:31:23.936 --> 00:31:25.790
 Is there a punching machine here? 

00:31:25.790 --> 00:31:27.280
 No, good 

00:31:27.280 --> 00:31:31.240
 Ok, so I will tell the story without a punching machine. 

00:31:31.240 --> 00:31:33.860
 So my task here is to tell you 

00:31:33.860 --> 00:31:36.440
 What will be the future version of Kotlin - 

00:31:36.440 --> 00:31:37.440
 Oh, thank you 

00:31:40.440 --> 00:31:44.440
 Now we are preparing for the first big event 

00:31:44.440 --> 00:31:47.990
 Is a platform that supports different platforms 

00:31:47.990 --> 00:31:52.030
 So in history, Kotlin is compiled into JVM bytecode. 

00:31:52.030 --> 00:31:54.500
 Same language as Java programming 

00:31:54.500 --> 00:31:57.450
 So we can run the server on the desktop, 

00:31:57.450 --> 00:32:00.850
 Of course, you can also run it on Android. 

00:32:00.850 --> 00:32:03.610
 And the same bytecode is everywhere 

00:32:03.610 --> 00:32:05.630
 That's why we can run older versions of Android 

00:32:05.630 --> 00:32:07.220
 And the new version 

00:32:07.220 --> 00:32:10.280
 But the story didn't end there, 

00:32:10.280 --> 00:32:11.410
 Because we are adding new platforms 

00:32:11.410 --> 00:32:15.270
 Recently, we have added - 

00:32:15.270 --> 00:32:19.320
 But God does not like the platform - 

00:32:19.320 --> 00:32:21.330
 Recently we added JavaScript, 

00:32:21.330 --> 00:32:24.680
 This means that Kotlin can now be compiled into JavaScript code. 

00:32:24.680 --> 00:32:27.420
 And run on the browser or node.js 

00:32:27.420 --> 00:32:32.370
 So now we support three mainstream, very popular virtual machines 

00:32:32.370 --> 00:32:36.700
 JVM, Android Dalvik, and JavaScript virtual machines 

00:32:36.700 --> 00:32:38.460
 But there are many American cases, 

00:32:38.460 --> 00:32:41.020
 That is the virtual machine is not practical 

00:32:41.020 --> 00:32:42.750
 Or simply can't get it 

00:32:42.750 --> 00:32:46.360
 For example, iOS virtual machine 

00:32:46.360 --> 00:32:47.630
 Severely restricted 

00:32:47.630 --> 00:32:49.780
 You cannot perform dynamic code generation 

00:32:49.780 --> 00:32:52.920
 Or for small embedded systems, VM is not suitable 

00:32:52.920 --> 00:32:55.560
 Or, a Linux command line tool 

00:32:55.560 --> 00:32:59.170
 VM will be a starting tool for a long time 

00:32:59.170 --> 00:33:01.650
 So this is not the case, 

00:33:01.650 --> 00:33:04.330
 That's why we are doing something called Kotlin / Native 

00:33:04.330 --> 00:33:08.220
 It can currently be used as a technical preview 

00:33:08.220 --> 00:33:11.710
 And there, we basically use Korm to compile Kotlin 

00:33:11.710 --> 00:33:15.690
 Into a native code to support binary code that can run on different platforms 

00:33:15.710 --> 00:33:18.883
 Currently, we support iOS, Linux and Mac. 

00:33:19.000 --> 00:33:21.410
 And Windows is still going on. 

00:33:21.410 --> 00:33:26.920
 So this brings us closer to this vision with Kotlin, 

00:33:26.920 --> 00:33:30.010
 When it can run on every component of a modern app, 

00:33:30.010 --> 00:33:34.010
 On any platform you like 

00:33:34.010 --> 00:33:36.120
 So imagine a full stack web application 

00:33:36.120 --> 00:33:40.070
 Both the server and the client are written in Kotlin 

00:33:40.070 --> 00:33:44.220
 Or for example, imagine a mobile platform, 

00:33:44.220 --> 00:33:45.650
 Reuse code between Android and iOS 

00:33:45.650 --> 00:33:48.780
 Or mix the previous two use cases, 

00:33:48.780 --> 00:33:51.280
 Then get a real multi-platform scene 

00:33:51.280 --> 00:33:54.970
 So our vision for Kotlin is 

00:33:54.970 --> 00:33:57.270
 Different models in the same project 

00:33:57.270 --> 00:34:00.270
 Compile into different platforms 

00:34:00.270 --> 00:34:02.770
 Of course, you -- we want to share the code there? 

00:34:02.770 --> 00:34:05.190
 Because if you support so many different things 

00:34:05.190 --> 00:34:07.650
 You will want to run the same code in different places 

00:34:07.650 --> 00:34:10.920
 We are working hard to make this possible 

00:34:10.920 --> 00:34:13.179
 But there is a very important thing 

00:34:13.179 --> 00:34:16.540
 Because before, 

00:34:16.540 --> 00:34:18.610
 Many projects try to unify the platform 

00:34:18.610 --> 00:34:21.330
 And often this will eventually become the most uncommon 

00:34:21.330 --> 00:34:24.550
 Denominator, when you only take all platforms 

00:34:24.550 --> 00:34:27.320
 Available things, you basically 

00:34:27.320 --> 00:34:29.659
 There is only one minimal interface left. 

00:34:29.659 --> 00:34:31.239
 And this is what we don't want 

00:34:31.239 --> 00:34:33.630
 So we hope that you can use all of them as much as possible. 

00:34:33.630 --> 00:34:35.929
 Platform-specific and superior API, 

00:34:35.929 --> 00:34:40.050
 Like the latest version of Android or something else 

00:34:40.050 --> 00:34:41.730
 If you want to share some code 

00:34:41.730 --> 00:34:46.860
 Only then, you must resort to some common APIs. 

00:34:46.860 --> 00:34:49.830
 So now the idea is that you have a common model with a lot of business logic. 

00:34:49.830 --> 00:34:53.380
 It can be written with Kotlin 

00:34:53.380 --> 00:34:56.540
 Platform-specific models work in parallel, 

00:34:56.540 --> 00:34:58.910
 And the two people can talk to each other 

00:34:58.910 --> 00:35:01.790
 So when you need it, you can take advantage of the API platform. 

00:35:01.790 --> 00:35:04.820
 You can use Kotlin code when you need it. 

00:35:04.820 --> 00:35:10.420
 So, todayâ€™s point is that our future is multi-platform 

00:35:10.420 --> 00:35:11.450
 Next -- oh 

00:35:17.020 --> 00:35:20.490
 The next big thing is the coroutine 

00:35:20.490 --> 00:35:23.690
 So the logic here is very straightforward 

00:35:23.690 --> 00:35:26.860
 Everyone needs to write asynchronous code, right? 

00:35:26.860 --> 00:35:31.410
 Because the world is too big for sequential execution. 

00:35:31.410 --> 00:35:36.510
 This is our reality, but it is very difficult, right? 

00:35:36.510 --> 00:35:39.970
 Who ever wrote asynchronous code? 

00:35:39.970 --> 00:35:41.970
 There are a lot of hands raised 

00:35:41.970 --> 00:35:46.210
 Those who have never done so will do this soon. 

00:35:46.210 --> 00:35:48.419
 The problem is that this is actually quite difficult 

00:35:48.419 --> 00:35:49.460
 Write order code 

00:35:49.460 --> 00:35:52.120
 Or itâ€™s hard to learn the language to help you do this. 

00:35:52.120 --> 00:35:56.190
 Because language can help you in that area. 

00:35:56.190 --> 00:35:57.240
 a lot of 

00:35:57.240 --> 00:36:00.040
 So basically we have a co-program in Kotlin 

00:36:00.040 --> 00:36:02.420
 How you write asynchronous code 

00:36:02.420 --> 00:36:03.916
 Same as writing synchronization code 

00:36:03.916 --> 00:36:05.540
 So what do you use in the synchronization code? 

00:36:05.540 --> 00:36:08.490
 Loop, if, rest and continue 

00:36:08.490 --> 00:36:09.640
 Something like this, right? 

00:36:09.640 --> 00:36:13.130
 This is the same as the collaborative code of the asynchronous code you are using. 

00:36:13.130 --> 00:36:18.390
 For language tracking 

00:36:18.390 --> 00:36:21.550
 All content, and you don't need to express a complex control flow for synchronous calculations in your code 

00:36:25.650 --> 00:36:29.760
 No callback, no fancy functional structure 

00:36:29.760 --> 00:36:34.220
 It's just a simple old order encoding 

00:36:34.220 --> 00:36:35.400
 Isn't that cool? 

00:36:39.180 --> 00:36:40.630
 Thank you 

00:36:40.630 --> 00:36:44.740
 So the idea of â€‹â€‹the coroutine is, 

00:36:44.740 --> 00:36:48.310
 You basically have the same abstraction of asynchronous and synchronous 

00:36:48.310 --> 00:36:51.400
 Moreover, a good analogy is 

00:36:51.400 --> 00:36:54.630
 Think of them as almost no threads 

00:36:54.630 --> 00:36:59.037
 Like here is the only code example I am showing you 

00:36:59.037 --> 00:37:01.120
 Basically, a lot of things that were done through threads before. 

00:37:01.120 --> 00:37:03.310
 Can be done with a collaborative program 

00:37:03.310 --> 00:37:05.130
 But the coordination process is very cheap 

00:37:05.130 --> 00:37:08.040
 So on the slide, I have a 

00:37:08.040 --> 00:37:09.980
 Create code for 100,000 companions 

00:37:09.980 --> 00:37:11.070
 Imagine it 

00:37:11.070 --> 00:37:15.490
 100,000 co-programs in parallel, and each coordinator 

00:37:15.490 --> 00:37:18.790
 Wait one second to return one 

00:37:18.790 --> 00:37:24.150
 So this program is done in one second, 

00:37:24.150 --> 00:37:28.470
 For nearly a second, as a matter of course, all the synergies 

00:37:28.470 --> 00:37:30.250
 Waiting in parallel 

00:37:30.250 --> 00:37:35.150
 However, if you try to use a thread to do this, it won't work 

00:37:35.150 --> 00:37:38.050
 100,000 threads can't be memory 

00:37:38.050 --> 00:37:39.200
 That is all 

00:37:39.200 --> 00:37:42.540
 So this is a win-win situation if you use coordination 

00:37:42.540 --> 00:37:46.100
 You will get a lot of performance, so the efficiency is very high 

00:37:46.100 --> 00:37:47.930
 And the code is simple 

00:37:47.930 --> 00:37:51.380
 So the main message today is to learn more about the collaborative process. 

00:37:51.380 --> 00:37:56.238
 Because our future may be more out of sync than now. 

00:37:57.580 --> 00:37:59.850
 So I am almost finished, 

00:37:59.850 --> 00:38:02.710
 If you want to learn more about Kotlin, check out our website. 

00:38:02.710 --> 00:38:04.960
 We have a dedicated Android section 

00:38:04.960 --> 00:38:08.900
 In addition, we will have a question and answer session after this lecture. 

00:38:08.900 --> 00:38:14.250
 So go to the developer email. 

00:38:14.250 --> 00:38:18.180
 Part C. Hadi and I will answer your questions. 

00:38:18.180 --> 00:38:20.740
 Thank you very much for listening carefully. 

