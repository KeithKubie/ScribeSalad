WEBVTT
Kind: captions
Language: en

00:00:00.008 --> 00:00:02.700
So to start with.

00:00:02.700 --> 00:00:06.890
What i'm going to say
is you need to know

00:00:08.340 --> 00:00:11.320
how to create classes
before you go ahead.

00:00:11.320 --> 00:00:12.910
Starting your frogger game.

00:00:12.910 --> 00:00:19.837
So, specifically this type of classes
is called prototypal classes.

00:00:19.837 --> 00:00:27.082
So prototypal classes what they can do
is they have a set of attributes or

00:00:27.082 --> 00:00:33.280
properties and
a member functions associated with it.

00:00:33.280 --> 00:00:39.520
So let me just share my screen now

00:00:39.520 --> 00:00:44.720
so I'm going to open up sublime and
I'm going to teach you guys how to

00:00:44.720 --> 00:00:49.310
start typing up a very
simple prototypal class.

00:00:49.310 --> 00:00:54.080
Let's define a class in JavaScript.

00:00:54.080 --> 00:00:55.350
So I'm going to use this name.

00:00:55.350 --> 00:00:56.670
So in JavaScript,

00:00:56.670 --> 00:01:01.010
when you define a class, it should
always start with a capital letter.

00:01:01.010 --> 00:01:04.180
So your class name should
have a capital letter.

00:01:04.180 --> 00:01:08.780
So that is what distinguishes a class,
a function and

00:01:08.780 --> 00:01:13.520
an object in JavaScript, because
essentially the three of them have

00:01:13.520 --> 00:01:19.000
the same syntax or
how you define them is the same.

00:01:19.000 --> 00:01:21.090
So what i'm going to do is.

00:01:21.090 --> 00:01:29.170
I'm going to go ahead and
create a class and call it Person.

00:01:29.170 --> 00:01:32.430
And I'm going to pass
in a name parameter.

00:01:32.430 --> 00:01:34.670
Into my class.

00:01:34.670 --> 00:01:40.220
So inside this, what I can do is
I can access the name attributor,

00:01:40.220 --> 00:01:47.460
assign an attribute to the name
property by using this form keyword.

00:01:47.460 --> 00:01:52.590
So that this keyword is going
to tell me the object that is

00:01:52.590 --> 00:01:56.650
actually invocating the person class.

00:01:56.650 --> 00:02:02.090
So the object is going to be
an instance of the person class.

00:02:02.090 --> 00:02:04.300
So this is what I defined here.

00:02:04.300 --> 00:02:07.740
What I'm essentially doing is,
any object I create,

00:02:07.740 --> 00:02:11.810
I assign the object
an attribute of name and

00:02:11.810 --> 00:02:17.530
then I give it the name that we passed
in while instantiating the object.

00:02:17.530 --> 00:02:21.390
This will also be called as
the constructor of the class,

00:02:21.390 --> 00:02:24.210
as you know in other languages.

00:02:24.210 --> 00:02:29.970
So yeah so what I'm doing here is I'm
actually creating a prototype function.

00:02:29.970 --> 00:02:33.930
So a prototype function is what it is,

00:02:33.930 --> 00:02:40.010
is it's going to essentially create
a member function of your class.

00:02:40.010 --> 00:02:45.570
So this function display is going to
be associated with the person class.

00:02:45.570 --> 00:02:51.260
And it can be accessed by
an instance of the person class.

00:02:51.260 --> 00:02:52.584
So, the technique for

00:02:52.584 --> 00:02:56.920
that is going to be
person.prototype.display = function off.

00:02:56.920 --> 00:03:01.020
I'm passing a greeting message
which might be just a name.

00:03:01.020 --> 00:03:06.220
So what i'm going to do is, I'm just
going to console.log code into this.

00:03:06.220 --> 00:03:10.970
You guys can figure out what has
happened to your game later.

00:03:10.970 --> 00:03:16.863
And then i'm just going
to add appended greeting

00:03:16.863 --> 00:03:21.922
to my name that I will assign this.name.

00:03:21.922 --> 00:03:27.450
So as you can see I created a prototype
function display associated with this.

00:03:28.690 --> 00:03:34.090
Also I can actually
create another function.

00:03:34.090 --> 00:03:38.230
I can call an object, new person.

00:03:38.230 --> 00:03:39.760
I can create it and.

00:03:39.760 --> 00:03:42.090
I can call the constructor.

00:03:42.090 --> 00:03:43.660
This way.
And then.

00:03:43.660 --> 00:03:47.120
I'm going to pass in my name into it.

00:03:47.120 --> 00:03:51.040
So what this is essentially doing
is it's creating an instance

00:03:51.040 --> 00:03:55.190
of the class person and
assigning the name Poomima to it.

00:03:55.190 --> 00:04:01.952
And whenever this object,
you do this it's going to,

00:04:01.952 --> 00:04:09.330
this is going to return
person.name will return Poomima.

00:04:09.330 --> 00:04:13.750
And then so
now if I want to call the display

00:04:13.750 --> 00:04:18.000
function all I have to do
is new underscore person.

00:04:19.000 --> 00:04:22.310
And then I can say good evening.

00:04:22.310 --> 00:04:28.320
So the result of the new display
function should be good evening,

00:04:28.320 --> 00:04:29.310
Poomima.

00:04:30.440 --> 00:04:31.610
So that's what it's going to do.

00:04:31.610 --> 00:04:35.420
So as you can see these
are prototypal classes,

00:04:35.420 --> 00:04:40.478
you will be using a lot of this
in your JavaScript Frogger game.

00:04:40.478 --> 00:04:44.060
&gt;&gt; Is there a better
way of saving states?

00:04:44.060 --> 00:04:47.130
&gt;&gt; Okay, saving states for
your player object.

00:04:47.130 --> 00:04:54.542
You can have an enum variable that
defines various states of the player.

00:04:54.542 --> 00:05:00.109
I know that if you have a state
where the player is alive the player

00:05:00.109 --> 00:05:06.300
is still playing when you go to like,
when you progress to levels.

00:05:06.300 --> 00:05:13.680
You need to have you know several
enum stages in your player type.

00:05:13.680 --> 00:05:16.730
So it's called an enumeration data type.

00:05:16.730 --> 00:05:21.050
So what you can do is you can
have a list of states for

00:05:21.050 --> 00:05:25.665
your player declared within
the enumeration data type.

00:05:25.665 --> 00:05:27.520
It's going to be just like an array.

00:05:27.520 --> 00:05:30.030
It's very similar to
an array where you can

00:05:30.030 --> 00:05:33.680
assign these sort of like
values to it and always.

00:05:33.680 --> 00:05:34.855
Enum data types.

00:05:34.855 --> 00:05:40.540
Take, are in the form of caps lock
that define the state of a player.

00:05:40.540 --> 00:05:42.540
So, feel free to use that and.

00:05:42.540 --> 00:05:47.742
Use leverage that data type to
actually define what state your

00:05:47.742 --> 00:05:54.155
player is currently in and what stage
you want to transition your player to.

00:05:54.155 --> 00:05:58.450
So that's one thing you can look
at designing your states with.

00:05:59.680 --> 00:06:02.660
&gt;&gt; So maybe we could talk a little
bit about how these concepts that

00:06:02.660 --> 00:06:04.403
the students are learning could be,

00:06:04.403 --> 00:06:07.085
so we're applying object
oriented concepts to a game.

00:06:07.085 --> 00:06:09.490
&gt;&gt; Mm-hm.
&gt;&gt; I think from a game sense it makes

00:06:09.490 --> 00:06:10.160
a lot of sense.

00:06:10.160 --> 00:06:10.690
&gt;&gt; Right.

00:06:10.690 --> 00:06:13.450
&gt;&gt; There is a player and
he's an object of enemies, and

00:06:13.450 --> 00:06:17.510
you want to kind of create multiple
instances of these enemies so.

00:06:17.510 --> 00:06:21.306
Having sort of this object
oriented design makes sense.

00:06:21.306 --> 00:06:23.878
&gt;&gt; Right.
&gt;&gt; When would we see this in sort of

00:06:23.878 --> 00:06:25.295
an actual website?

00:06:25.295 --> 00:06:29.714
So if i'm going to, say,
ESPN or Google, any other sort

00:06:29.714 --> 00:06:34.594
of the websites that i visit,
where on like a page would we see,

00:06:34.594 --> 00:06:39.410
where can we utilize these
object oriented design concepts?

00:06:39.410 --> 00:06:41.790
&gt;&gt; Yeah, so they could really be
used in a lot of these instances.

00:06:41.790 --> 00:06:45.450
One of the common ones that
you'll see out there as

00:06:45.450 --> 00:06:49.730
kind of an intro to JavaScript
development is the to-do list app.

00:06:49.730 --> 00:06:53.810
Everyone's built a to-do list app, you
know, over and over, a hundred times.

00:06:53.810 --> 00:06:58.040
If you think about it,
a to-do list item is pretty simple.

00:06:58.040 --> 00:07:01.430
If you think about the properties of it,
is it checked or not?

00:07:01.430 --> 00:07:04.630
And what is the text of
that to-do list item?

00:07:04.630 --> 00:07:07.250
So I could easily envision a page
that has like a box at the top that

00:07:07.250 --> 00:07:11.770
you type stuff in and
then just a series of items.

00:07:11.770 --> 00:07:14.700
Each of those items would be an object.

00:07:14.700 --> 00:07:16.020
And so then I would have.

00:07:16.020 --> 00:07:19.570
I'm thinking about
the prototype of that.

00:07:19.570 --> 00:07:21.090
Of that to do item.

00:07:21.090 --> 00:07:23.810
Imagine we have a class
of to do list item.

00:07:23.810 --> 00:07:28.870
Some of the prototype functions
I would have is edit because

00:07:28.870 --> 00:07:33.670
that functionality isn't distinct or
unique between all of these items.

00:07:33.670 --> 00:07:34.860
Everyone edits the same way.

00:07:34.860 --> 00:07:36.600
&gt;&gt; Yeah,
should be able to edit it all of them.

00:07:36.600 --> 00:07:37.270
&gt;&gt; Right.

00:07:37.270 --> 00:07:38.300
Checking and unchecking,

00:07:38.300 --> 00:07:41.110
like do you want to maybe
have a counter that updates?

00:07:41.110 --> 00:07:45.180
So, but the checking and
un-checking functionality of that

00:07:45.180 --> 00:07:47.610
to do item is going to be
the same across every single one.

00:07:47.610 --> 00:07:52.910
So it really comes down to shared
functionality as we mentioned

00:07:52.910 --> 00:07:57.530
in object oriented JavaScript course,
there's not a right way to do it.

00:07:57.530 --> 00:08:00.030
And that's kind of the,

00:08:00.030 --> 00:08:05.100
what I enjoy about JavaScript, is that
it just depends on the implementation.

00:08:05.100 --> 00:08:07.430
We can't tell you always
use a function class, or

00:08:07.430 --> 00:08:09.850
always use a pseudo classical class.

00:08:09.850 --> 00:08:11.350
It really depends on what
you're trying to do and

00:08:11.350 --> 00:08:13.080
what you're trying to accomplish.

00:08:13.080 --> 00:08:15.240
And I know that sounds difficult and
frustrating.

00:08:15.240 --> 00:08:17.050
Right now, but

00:08:17.050 --> 00:08:22.470
it'll come in time and that's one of
my favorite things about JavaScript is.

00:08:22.470 --> 00:08:24.450
I kind of compare it to Tetris.

00:08:24.450 --> 00:08:27.300
It's really easy to play,
but hard to master.

00:08:27.300 --> 00:08:28.780
That's how JavaScript is.

00:08:28.780 --> 00:08:30.480
Is it's easy to get stuff done and

00:08:30.480 --> 00:08:35.020
then a week later you're going to
learn something new and realize that.

00:08:35.020 --> 00:08:35.840
I can make that better.

00:08:35.840 --> 00:08:40.030
What i did last week and it's a constant
I can make what i just did a lot better.

