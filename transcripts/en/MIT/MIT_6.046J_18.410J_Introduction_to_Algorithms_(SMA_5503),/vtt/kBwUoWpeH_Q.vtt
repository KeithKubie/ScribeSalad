WEBVTT
Kind: captions
Language: en

00:00:07.000 --> 00:00:10.466
Good morning.
Today we're going to talk about

00:00:10.466 --> 00:00:14.800
it a balanced search structure,
so a data structure that

00:00:14.800 --> 00:00:18.266
maintains a dynamic set subject
to insertion,

00:00:18.266 --> 00:00:21.260
deletion, and search called
skip lists.

00:00:21.260 --> 00:00:25.909
So, I'll call this a dynamic
search structure because it's a

00:00:25.909 --> 00:00:28.587
data structure.
It supports search,

00:00:28.587 --> 00:00:33.000
and it's dynamic,
meaning insert and delete.

00:00:33.000 --> 00:00:39.324
So, what other dynamic search
structures do we know,

00:00:39.324 --> 00:00:45.772
just for sake of comparison,
and to wake everyone up?

00:00:45.772 --> 00:00:50.484
Shut them out,
efficient, I should say,

00:00:50.484 --> 00:00:55.568
also good, logarithmic time per
operation.

00:00:55.568 --> 00:01:01.892
So, this is a really easy
question to get us off the

00:01:01.892 --> 00:01:05.956
ground.
You've seen them all in the

00:01:05.956 --> 00:01:08.637
last week, so it shouldn't be so
hard.

00:01:08.637 --> 00:01:11.463
Treap, good.
On the problems that we saw

00:01:11.463 --> 00:01:13.565
treaps.
That's, in some sense,

00:01:13.565 --> 00:01:17.840
the simplest dynamic search
structure you can get from first

00:01:17.840 --> 00:01:21.971
principles because all we needed
was a bound on a randomly

00:01:21.971 --> 00:01:26.028
constructed binary search tree.
And then treaps did well.

00:01:26.028 --> 00:01:30.304
So, that was sort of the first
one you saw depending on when

00:01:30.304 --> 00:01:34.000
you did your problem set.
What else?

00:01:34.000 --> 00:01:36.579
Charles?
Red black trees,

00:01:36.579 --> 00:01:40.985
good answer.
So, that was exactly one week

00:01:40.985 --> 00:01:44.531
ago.
I hope you still remember it.

00:01:44.531 --> 00:01:48.614
They have guaranteed log n
performance.

00:01:48.614 --> 00:01:55.277
So, this was an expected bound.
This was a worst-case order log

00:01:55.277 --> 00:01:58.608
n per operation,
insert, delete,

00:01:58.608 --> 00:02:02.692
and search.
And, there was one more for

00:02:02.692 --> 00:02:07.743
those who want to recitation on
Friday: B trees,

00:02:07.743 --> 00:02:10.960
good.
And, by B trees,

00:02:10.960 --> 00:02:14.082
I also include two-three trees,
two-three-four trees,

00:02:14.082 --> 00:02:16.604
and all those guys.
So, if B is a constant,

00:02:16.604 --> 00:02:19.906
or if you want your B trees
knows a little bit cleverly,

00:02:19.906 --> 00:02:22.908
that these have guaranteed
order log n performance,

00:02:22.908 --> 00:02:24.529
so, worst case,
order log n.

00:02:24.529 --> 00:02:27.771
So, you should know this.
These are all balanced search

00:02:27.771 --> 00:02:29.452
structures.
They are dynamic.

00:02:29.452 --> 00:02:31.673
They support insertions and
deletions.

00:02:31.673 --> 00:02:34.195
They support searches,
finding a given key.

00:02:34.195 --> 00:02:37.677
And if you don't find the key,
you find its predecessor and

00:02:37.677 --> 00:02:42.000
successor pretty easily in all
of these structures.

00:02:42.000 --> 00:02:44.919
If you want to augment some
data structure,

00:02:44.919 --> 00:02:48.673
you should think about which
one of these is easiest to

00:02:48.673 --> 00:02:53.053
augment, as in Monday's lecture.
So, the question I want to pose

00:02:53.053 --> 00:02:56.668
to you is supposed I gave you
all a laptop right now,

00:02:56.668 --> 00:02:59.310
which would be great.
Then I asked you,

00:02:59.310 --> 00:03:03.203
in order to keep this laptop
you have to implement one of

00:03:03.203 --> 00:03:06.679
these data structures,
let's say, within this class

00:03:06.679 --> 00:03:09.817
hour.
Do you think you could do it?

00:03:09.817 --> 00:03:12.136
How many people think you could
do it?

00:03:12.136 --> 00:03:13.954
A couple people,
a few people,

00:03:13.954 --> 00:03:15.834
OK, all front row people,
good.

00:03:15.834 --> 00:03:19.219
I could probably do it.
My preference would be B trees.

00:03:19.219 --> 00:03:21.663
They're sort of the simplest in
my mind.

00:03:21.663 --> 00:03:23.794
This is without using the
textbook.

00:03:23.794 --> 00:03:25.800
This would be a closed book
exam.

00:03:25.800 --> 00:03:30.000
I don't have enough laptops to
do it, unfortunately.

00:03:30.000 --> 00:03:32.010
So, B trees are pretty
reasonable.

00:03:32.010 --> 00:03:35.484
Deletion, you have to remember
stealing from a sibling and

00:03:35.484 --> 00:03:37.860
whatnot.
So, deletions are a bit tricky.

00:03:37.860 --> 00:03:40.298
Red black trees,
I can never remember it.

00:03:40.298 --> 00:03:43.467
I'd have to look it up,
or re-derive the three cases.

00:03:43.467 --> 00:03:46.574
treaps are a bit fancy.
So, that would take a little

00:03:46.574 --> 00:03:49.012
while to remember exactly how
those work.

00:03:49.012 --> 00:03:51.571
You'd have to solve your
problem set again,

00:03:51.571 --> 00:03:55.289
if you don't have it memorized.
Skip lists, on the other hand,

00:03:55.289 --> 00:03:57.848
are a data structure you will
never forget,

00:03:57.848 --> 00:04:00.651
and something you can implement
within an hour,

00:04:00.651 --> 00:04:03.089
no problem.
I've made this claim a couple

00:04:03.089 --> 00:04:05.770
times before,
and I always felt bad because I

00:04:05.770 --> 00:04:10.133
had never actually done it.
So, this morning,

00:04:10.133 --> 00:04:13.733
I implemented skip lists,
and it took me ten minutes to

00:04:13.733 --> 00:04:17.133
implement a linked list,
and 30 minutes to implement

00:04:17.133 --> 00:04:19.333
skip lists.
And another 30 minutes

00:04:19.333 --> 00:04:21.199
debugging them.
There you go.

00:04:21.199 --> 00:04:24.133
It can be done.
Skip lists are really simple.

00:04:24.133 --> 00:04:27.666
And, at no point writing the
code did I have to think,

00:04:27.666 --> 00:04:32.000
whereas every other structure I
would have to think.

00:04:32.000 --> 00:04:36.021
There was one moment when I
thought, ah, how do I flip a

00:04:36.021 --> 00:04:38.507
coin?
That was the entire amount of

00:04:38.507 --> 00:04:41.432
thinking.
So, skip lists are a randomized

00:04:41.432 --> 00:04:44.356
structure.
Let's add in another adjective

00:04:44.356 --> 00:04:46.843
here, and let's also add in
simple.

00:04:46.843 --> 00:04:49.767
So, we have a simple,
efficient, dynamic,

00:04:49.767 --> 00:04:53.716
randomized search structure:
all those things together.

00:04:53.716 --> 00:04:57.810
So, it's sort of like treaps
and that the bound is only a

00:04:57.810 --> 00:05:01.320
randomized bound.
But today, we're going to see a

00:05:01.320 --> 00:05:06.000
much stronger bound than an
expectation bound.

00:05:06.000 --> 00:05:11.366
So, in particular,
skip lists will run in order

00:05:11.366 --> 00:05:17.083
log n expected time.
So, the running time for each

00:05:17.083 --> 00:05:22.216
operation will be order log n in
expectation.

00:05:22.216 --> 00:05:28.983
But, we're going to prove a
much stronger result that their

00:05:28.983 --> 00:05:34.000
order log n, with high
probability.

00:05:34.000 --> 00:05:37.216
So, this is a very strong
claim.

00:05:37.216 --> 00:05:42.613
And it means that the running
time of each operation,

00:05:42.613 --> 00:05:48.424
the running time of every
operation is order log n almost

00:05:48.424 --> 00:05:54.028
always in a certain sense.
Why don't I foreshadow that?

00:05:54.028 --> 00:05:59.735
So, it's something like,
the probability that it's order

00:05:59.735 --> 00:06:05.132
log n is at least one minus one
over some polynomial,

00:06:05.132 --> 00:06:08.293
and n.
And, you get to set the

00:06:08.293 --> 00:06:10.149
polynomial however large you
like.

00:06:10.149 --> 00:06:13.354
So, what this basically means
is that almost all the time,

00:06:13.354 --> 00:06:16.391
you take your skip lists,
you do a polynomial number of

00:06:16.391 --> 00:06:18.809
operations on it,
because presumably you are

00:06:18.809 --> 00:06:21.902
running a polynomial time
algorithm that using this data

00:06:21.902 --> 00:06:23.814
structure.
Do polynomial numbers of

00:06:23.814 --> 00:06:26.850
inserts, delete searches,
every single one of them will

00:06:26.850 --> 00:06:30.000
take order log n time,
almost guaranteed.

00:06:30.000 --> 00:06:33.807
So this is a really strong
bound on the tail of the

00:06:33.807 --> 00:06:36.624
distribution.
The mean is order log n.

00:06:36.624 --> 00:06:39.365
That's not so exciting.
But, in fact,

00:06:39.365 --> 00:06:43.857
almost all of the weight of
this probability distribution is

00:06:43.857 --> 00:06:47.588
right around the log n,
just tiny little epsilons,

00:06:47.588 --> 00:06:51.700
very tiny probabilities you
could be bigger than log n.

00:06:51.700 --> 00:06:55.964
So that's where we are going.
This is a data structure by

00:06:55.964 --> 00:07:00.000
Pugh] in 1989.
This is the most recent.

00:07:00.000 --> 00:07:03.119
Actually, no,
sorry, treaps are more recent.

00:07:03.119 --> 00:07:06.673
They were like '93 or so,
but a fairly recent data

00:07:06.673 --> 00:07:09.647
structure for just insert,
delete, search.

00:07:09.647 --> 00:07:13.419
And, it's very simple.
You can derive it if you don't

00:07:13.419 --> 00:07:16.393
know anything about data
structures, well,

00:07:16.393 --> 00:07:19.150
almost nothing.
Now, analyzing that the

00:07:19.150 --> 00:07:21.834
performance is log n,
that, of course,

00:07:21.834 --> 00:07:25.751
takes our sophistication.
But the data structure itself

00:07:25.751 --> 00:07:30.473
is very simple.
We're going to start from

00:07:30.473 --> 00:07:34.133
scratch.
Suppose you don't know what a

00:07:34.133 --> 00:07:38.684
red black tree is.
You don't know what a B tree

00:07:38.684 --> 00:07:41.652
is.
Suppose you don't even know

00:07:41.652 --> 00:07:45.609
what a tree is.
What is the simplest data

00:07:45.609 --> 00:07:51.941
structure for storing a bunch of
items for storing a dynamic set?

00:07:51.941 --> 00:07:54.612
A list, good,
a linked list.

00:07:54.612 --> 00:07:58.866
Now, suppose that it's a sorted
linked list.

00:07:58.866 --> 00:08:05.000
So, I'm going to be a little
bit fancier there.

00:08:05.000 --> 00:08:10.630
So, if you have a linked list
of items, here it is,

00:08:10.630 --> 00:08:16.036
maybe we'll make it doubly
linked just for kicks,

00:08:16.036 --> 00:08:22.229
how long does it take to search
in a sorted linked list?

00:08:22.229 --> 00:08:26.959
Log n is one answer.
n is the other answer.

00:08:26.959 --> 00:08:31.488
Which one is right?
n is the right answer.

00:08:31.488 --> 00:08:35.073
So, even though it's sorted,
we can't do binary search

00:08:35.073 --> 00:08:38.321
because we don't have
random-access into a linked

00:08:38.321 --> 00:08:40.553
list.
So, suppose I'm only given a

00:08:40.553 --> 00:08:44.004
pointer to the head.
Otherwise, I'm assuming it's an

00:08:44.004 --> 00:08:46.372
array.
So, in a sorted array you can

00:08:46.372 --> 00:08:48.739
search in log n.
Sorted linked list:

00:08:48.739 --> 00:08:51.919
you've still got to scan
through the darn thing.

00:08:51.919 --> 00:08:53.949
So, theta n,
worst case search.

00:08:53.949 --> 00:08:56.723
Not so good,
but if we just try to improve

00:08:56.723 --> 00:08:59.632
it a little bit,
we will discover skip lists

00:08:59.632 --> 00:09:03.970
automatically.
So, this is our starting point:

00:09:03.970 --> 00:09:06.004
sorted linked lists,
data n time.

00:09:06.004 --> 00:09:09.563
And, I'm not going to think too
much about insertions and

00:09:09.563 --> 00:09:12.995
deletions for the moment.
Let's just get search better,

00:09:12.995 --> 00:09:15.029
and then we'll worry about
dates.

00:09:15.029 --> 00:09:17.826
Updates are where randomization
will come in.

00:09:17.826 --> 00:09:21.194
Search: pretty easy idea.
So, how can we make a linked

00:09:21.194 --> 00:09:23.800
list better?
Suppose all we know about our

00:09:23.800 --> 00:09:26.152
linked lists.
What can I do to make it

00:09:26.152 --> 00:09:28.567
faster?
This is where you need a little

00:09:28.567 --> 00:09:32.000
bit of innovation,
some creativity.

00:09:32.000 --> 00:09:37.377
More links: that's a good idea.
So, I do try to maybe add

00:09:37.377 --> 00:09:40.738
pointers to go a couple steps
ahead.

00:09:40.738 --> 00:09:45.731
If I had log n pointers,
I could do all powers of two

00:09:45.731 --> 00:09:48.900
ahead.
That's a pretty good search

00:09:48.900 --> 00:09:51.877
structure.
Some people use that;

00:09:51.877 --> 00:09:56.294
like, some peer-to-peer
networks use that idea.

00:09:56.294 --> 00:10:01.000
But that's a little too fancy
for me.

00:10:01.000 --> 00:10:03.522
Ah, good.
You could try to build a tree

00:10:03.522 --> 00:10:07.172
on this linear structure.
That's essentially where we're

00:10:07.172 --> 00:10:09.163
going.
So, you could try to put

00:10:09.163 --> 00:10:12.415
pointers to, like,
the middle of the list from the

00:10:12.415 --> 00:10:14.738
roots.
So, you search between either

00:10:14.738 --> 00:10:16.663
here.
You point to the median,

00:10:16.663 --> 00:10:20.513
so you can compare against the
median, and know whether you

00:10:20.513 --> 00:10:23.964
should go in the first half or
the second half that's

00:10:23.964 --> 00:10:27.880
definitely on the right track,
also a bit too sophisticated.

00:10:27.880 --> 00:10:29.008
Another list:
yes.

00:10:29.008 --> 00:10:32.924
Yes, good.
So, we are going to use two

00:10:32.924 --> 00:10:34.990
lists.
That's sort of the next

00:10:34.990 --> 00:10:38.767
simplest thing you could do.
OK, and as you suggested,

00:10:38.767 --> 00:10:41.689
we could maybe have pointers
between them.

00:10:41.689 --> 00:10:46.108
So, maybe we have some elements
down here, some of the elements

00:10:46.108 --> 00:10:48.388
up here.
We want to have pointers

00:10:48.388 --> 00:10:51.809
between the lists.
OK, it gets a little bit crazy

00:10:51.809 --> 00:10:54.089
in how exactly you might do
that.

00:10:54.089 --> 00:10:56.085
But somehow,
this feels good.

00:10:56.085 --> 00:10:58.294
So this is one linked list:
L_1.

00:10:58.294 --> 00:11:02.000
This is another linked list:
L_2.

00:11:02.000 --> 00:11:12.965
And, to give you some
inspiration, I want to give you,

00:11:12.965 --> 00:11:19.793
so let's play a game.
The game is,

00:11:19.793 --> 00:11:29.103
what is this sequence?
So, the sequence is 14.

00:11:29.103 --> 00:11:38.000
If you know the answer,
shout it out.

00:11:38.000 --> 00:11:42.000
Anyone yet? OK, it's tricky.

00:11:54.000 --> 00:11:58.296
It's a bit of a small class,
so I hope someone knows the

00:11:58.296 --> 00:11:59.000
answer.

00:12:10.000 --> 00:12:14.088
How many TA's know the answer?
Just a couple,

00:12:14.088 --> 00:12:19.384
OK, if you're looking at the
slides, probably you know the

00:12:19.384 --> 00:12:21.522
answer.
That's cheating.

00:12:21.522 --> 00:12:26.075
OK, I'll give you a hint.
It is not a mathematical

00:12:26.075 --> 00:12:29.606
sequence.
This is a real-life sequence.

00:12:29.606 --> 00:12:32.939
Yeah?
Yeah, and what city?

00:12:32.939 --> 00:12:36.819
New York, yeah,
this is the 7th Ave line.

00:12:36.819 --> 00:12:40.989
This is my favorite subway line
in New York.

00:12:40.989 --> 00:12:46.227
But, what's a cool feature of
the New York City subway?

00:12:46.227 --> 00:12:49.428
OK, it's a skip list.
Good answer.

00:12:49.428 --> 00:12:54.471
[LAUGHTER] Indeed it is.
Skip lists are so practical.

00:12:54.471 --> 00:13:00.000
They've been implemented in the
subway system.

00:13:00.000 --> 00:13:03.503
How cool is that?
OK, Boston subway is pretty

00:13:03.503 --> 00:13:08.200
cool because it's the oldest
subway definitely in the United

00:13:08.200 --> 00:13:11.783
States, maybe in the world.
New York is close,

00:13:11.783 --> 00:13:16.082
and it has other nice features
like it's open 24 hours.

00:13:16.082 --> 00:13:20.382
That's a definite plus,
but it also has this feature of

00:13:20.382 --> 00:13:23.089
express lines.
So, it's a bit of an

00:13:23.089 --> 00:13:26.304
abstraction,
but the 7th Ave line has

00:13:26.304 --> 00:13:29.619
essentially two kinds of cars.
These are street numbers by the

00:13:29.619 --> 00:13:31.699
way.
This is, Penn Station,

00:13:31.699 --> 00:13:33.476
Times Square,
and so on.

00:13:33.476 --> 00:13:36.181
So, there are essentially two
lines.

00:13:36.181 --> 00:13:39.657
There's the express line which
goes 14, to 34,

00:13:39.657 --> 00:13:41.125
to 42, to 72,
to 96.

00:13:41.125 --> 00:13:45.607
And then, there's the local
line which stops at every stop.

00:13:45.607 --> 00:13:49.470
And, they accomplish this with
four sets of tracks.

00:13:49.470 --> 00:13:54.105
So, I mean, the express lines
have their own dedicated track.

00:13:54.105 --> 00:13:57.505
If you want to go to stop 59
from, let's say,

00:13:57.505 --> 00:14:00.905
Penn Station,
well, let's say from lower west

00:14:00.905 --> 00:14:05.000
side, you get on the express
line.

00:14:05.000 --> 00:14:10.956
You jump to 42 pretty quickly,
and then you switch over to the

00:14:10.956 --> 00:14:16.619
local line, and go on to 59 or
wherever I said I was going.

00:14:16.619 --> 00:14:21.404
OK, so this is express and
local lines, and we can

00:14:21.404 --> 00:14:25.016
represent that with a couple of
lists.

00:14:25.016 --> 00:14:29.508
We have one list,
sure, we have one list on the

00:14:29.508 --> 00:14:34.000
bottom, so leave some space up
here.

00:14:34.000 --> 00:14:48.626
This is the local line,
L_2, 34, 42,

00:14:48.626 --> 00:15:02.000
50, 59, 66, 72,
79, and so on.

00:15:02.000 --> 00:15:08.833
And then we had the express
line on top, which only stops at

00:15:08.833 --> 00:15:11.729
14, 34, 42, 72,
and so on.

00:15:11.729 --> 00:15:16.131
I'm not going to redraw the
whole list.

00:15:16.131 --> 00:15:21.575
You get the idea.
And so, what we're going to do

00:15:21.575 --> 00:15:27.482
is put links between in the
local and express lines,

00:15:27.482 --> 00:15:34.889
wherever they happen to meet.
And, that's our two linked list

00:15:34.889 --> 00:15:38.245
structure.
So, that's what I actually

00:15:38.245 --> 00:15:42.347
meant what I was trying to draw
some picture.

00:15:42.347 --> 00:15:47.754
Now, this has a property that
in one list, the bottom list,

00:15:47.754 --> 00:15:52.322
every element occurs.
And the top list just copies

00:15:52.322 --> 00:15:56.983
some of those elements.
And we're going to preserve

00:15:56.983 --> 00:16:00.338
that property.
So, L_2 stores all the

00:16:00.338 --> 00:16:05.000
elements, and L_1 stores some
subset.

00:16:05.000 --> 00:16:10.912
And, it's still open which ones
we should store.

00:16:10.912 --> 00:16:16.322
That's the one thing we need to
think about.

00:16:16.322 --> 00:16:23.241
But, our inspiration is from
the New York subway system.

00:16:23.241 --> 00:16:30.161
OK, there, that the idea.
Of course, we're also going to

00:16:30.161 --> 00:16:36.074
use more than two lists.
OK, we also have links.

00:16:36.074 --> 00:16:44.000
Let's say it links between
equal keys in L_1 and L_2.

00:16:44.000 --> 00:16:46.533
Good.
So, just for the sake of

00:16:46.533 --> 00:16:50.203
completeness,
and because we will need this

00:16:50.203 --> 00:16:55.708
later, let's talk about searches
before we worry about how these

00:16:55.708 --> 00:17:00.776
lists are actually constructed.
Of course, if I wanted that

00:17:00.776 --> 00:17:04.167
board.
So, if you want to search for

00:17:04.167 --> 00:17:06.335
an element, x,
what do you do?

00:17:06.335 --> 00:17:09.698
Well, this is the taking the
subway algorithm.

00:17:09.698 --> 00:17:14.182
And, suppose you always start
in the upper left corner of the

00:17:14.182 --> 00:17:17.396
subway system,
if you're always in the lower

00:17:17.396 --> 00:17:21.059
west side, 14th St,
and I don't know exactly where

00:17:21.059 --> 00:17:25.319
that is, but more or less,
somewhere down at the bottom of

00:17:25.319 --> 00:17:27.860
Manhattan.
And, you want to go to a

00:17:27.860 --> 00:17:33.110
particular station like 59.
Well, you'd stay on the express

00:17:33.110 --> 00:17:37.194
line as long as you can because
it happens that we started on

00:17:37.194 --> 00:17:39.849
the express line.
And then, you go down.

00:17:39.849 --> 00:17:43.389
And then you take the local
line the rest of the way.

00:17:43.389 --> 00:17:47.610
That's clearly the right thing
to do if you always start in the

00:17:47.610 --> 00:17:50.537
top left corner.
So, I'm going to write that

00:17:50.537 --> 00:17:54.009
down in some kind of an
algorithm because we will be

00:17:54.009 --> 00:17:56.936
generalizing it.
It's pretty obvious at this

00:17:56.936 --> 00:18:00.000
point.
It will remain obvious.

00:18:00.000 --> 00:18:06.096
So, I want to walk right in the
top list until that would go too

00:18:06.096 --> 00:18:09.387
far.
So, you imagine giving someone

00:18:09.387 --> 00:18:14.516
directions on the subway system
they've never been on.

00:18:14.516 --> 00:18:17.806
So, you say,
OK, you start at 14th.

00:18:17.806 --> 00:18:22.354
Take the express line,
and when you get to 72nd,

00:18:22.354 --> 00:18:25.451
you've gone too far.
Go back one,

00:18:25.451 --> 00:18:30.000
and then go down to the local
line.

00:18:30.000 --> 00:18:32.590
It's really annoying
directions.

00:18:32.590 --> 00:18:37.352
But this is what an algorithm
has to do because it's never

00:18:37.352 --> 00:18:41.362
taken the subway before.
So, it's going to check,

00:18:41.362 --> 00:18:45.540
so let's do it here.
So, suppose I'm aiming for 59.

00:18:45.540 --> 00:18:49.467
So, I started 14,
say the first thing I do is go

00:18:49.467 --> 00:18:51.305
to 34.
Then from there,

00:18:51.305 --> 00:18:54.814
I go to 42.
Still good because 59 is bigger

00:18:54.814 --> 00:18:56.903
than 42.
I go right again.

00:18:56.903 --> 00:18:59.075
I say, oops,
72 is too big.

00:18:59.075 --> 00:19:04.780
That was too far.
So, I go back to where it just

00:19:04.780 --> 00:19:07.931
was.
Then I go down and then I keep

00:19:07.931 --> 00:19:12.379
going right until I find the
element that I want,

00:19:12.379 --> 00:19:17.754
or discover that it's not in
the bottom list because bottom

00:19:17.754 --> 00:19:21.739
list has everyone.
So, that's the algorithm.

00:19:21.739 --> 00:19:27.299
Stop when going right would go
too far, and you discover that

00:19:27.299 --> 00:19:31.377
with a comparison.
Then you walk down to L_2.

00:19:31.377 --> 00:19:35.732
And then you walk right in L_2
until you find x,

00:19:35.732 --> 00:19:40.829
or you find something greater
than x, in which case x is

00:19:40.829 --> 00:19:46.793
definitely not on your list.
And you found the predecessor

00:19:46.793 --> 00:19:49.082
and successor,
which may be your goal.

00:19:49.082 --> 00:19:52.855
If you didn't find where x was,
you should find where it would

00:19:52.855 --> 00:19:55.824
go if it were there,
because then maybe you could

00:19:55.824 --> 00:19:58.051
insert there.
We're going to use this

00:19:58.051 --> 00:20:00.711
algorithm in insertion.
OK, but that search:

00:20:00.711 --> 00:20:05.027
pretty easy at this point.
Now, what we haven't discussed

00:20:05.027 --> 00:20:08.472
is how fast the search algorithm
is, and it depends,

00:20:08.472 --> 00:20:12.054
of course, which elements we're
going to store in L_1,

00:20:12.054 --> 00:20:14.824
which subset of elements should
go in L_1.

00:20:14.824 --> 00:20:18.202
Now, in the subway system,
you probably put all the

00:20:18.202 --> 00:20:21.716
popular stations in L_1.
But here, we want worst-case

00:20:21.716 --> 00:20:24.013
performance.
So, we don't have some

00:20:24.013 --> 00:20:26.513
probability distribution on the
nodes.

00:20:26.513 --> 00:20:30.500
We just like every node to be
accessed sort of as quickly as

00:20:30.500 --> 00:20:35.106
possible, uniformly.
So, we want to minimize the

00:20:35.106 --> 00:20:39.867
maximum time over all queries.
So, any ideas what we should do

00:20:39.867 --> 00:20:42.832
with L_1?
Should I put all the nodes of

00:20:42.832 --> 00:20:46.421
L_1 in the beginning?
OK, it's a strict subset.

00:20:46.421 --> 00:20:49.777
Suppose I told you what the
size of L_1 was.

00:20:49.777 --> 00:20:53.132
I can tell you,
I could afford to build this

00:20:53.132 --> 00:20:56.956
many express stops.
How should you distribute them

00:20:56.956 --> 00:21:02.731
among the elements of L_2?
Uniformly, good.

00:21:02.731 --> 00:21:08.195
So, what nodes,
sorry, what keys,

00:21:08.195 --> 00:21:17.073
let's say, go in L_1?
Well, definitely the best thing

00:21:17.073 --> 00:21:24.073
to do is to spread them out
uniformly, OK,

00:21:24.073 --> 00:21:35.000
which is definitely not what
the 7th Ave line looks like.

00:21:35.000 --> 00:21:39.788
But, let's imagine that we
could reengineer everything.

00:21:39.788 --> 00:21:45.108
So, we're going to try to space
these things out a little bit

00:21:45.108 --> 00:21:47.945
more.
So, 34 and 42nd are way too

00:21:47.945 --> 00:21:50.960
close.
We'll take a few more stops.

00:21:50.960 --> 00:21:54.418
And, now we can start to
analyze things.

00:21:54.418 --> 00:21:57.788
OK, as a function of the length
of L_1.

00:21:57.788 --> 00:22:03.197
So, the cost of a search is now
roughly, so, I want a function

00:22:03.197 --> 00:22:07.009
of the length of L_1,
and the length of L_2,

00:22:07.009 --> 00:22:11.000
which is all the elements,
n.

00:22:11.000 --> 00:22:18.141
What is the cost of the search
if I spread out all the elements

00:22:18.141 --> 00:22:20.675
in L_1 uniformly?
Yeah?

00:22:20.675 --> 00:22:26.664
Right, the total number of
elements in the top lists,

00:22:26.664 --> 00:22:33.000
plus the division between the
bottom and the top.

00:22:33.000 --> 00:22:36.276
So, I'll write the length of
L_1 plus the length of L_2

00:22:36.276 --> 00:22:39.249
divided by the length of L_1.
OK, this is roughly,

00:22:39.249 --> 00:22:42.707
I mean, there's maybe a plus
one or so here because in the

00:22:42.707 --> 00:22:46.226
worst case, I have to search
through all of L_1 because the

00:22:46.226 --> 00:22:49.078
station I could be looking for
could be the max.

00:22:49.078 --> 00:22:52.294
OK, and maybe I'm not lucky,
and the max is not on the

00:22:52.294 --> 00:22:54.842
express line.
So then, I have to go down to

00:22:54.842 --> 00:22:57.573
the local line.
And how many stops will I have

00:22:57.573 --> 00:23:01.745
to go on the local line?
Well, L_1 just evenly

00:23:01.745 --> 00:23:04.986
partitions L_2.
So this is the number of

00:23:04.986 --> 00:23:08.809
consecutive stations between two
express stops.

00:23:08.809 --> 00:23:12.300
So, I take the express,
possibly this long,

00:23:12.300 --> 00:23:15.541
but I take the local possibly
this long.

00:23:15.541 --> 00:23:18.284
And, this is an L_2.
And there is,

00:23:18.284 --> 00:23:20.694
plus, a constant,
for example,

00:23:20.694 --> 00:23:24.600
go walking down.
But that's basically the number

00:23:24.600 --> 00:23:28.839
of nodes that I visit.
So, I'd like to minimize this

00:23:28.839 --> 00:23:36.625
function.
Now, L_2, I'm going to call

00:23:36.625 --> 00:23:47.041
that n because that's the total
number of elements.

00:23:47.041 --> 00:23:55.166
L_1, I can choose to be
whatever I want.

00:23:55.166 --> 00:24:03.894
So, let's go over here.
So, I want to minimize L_1 plus

00:24:03.894 --> 00:24:07.162
n over L_1.
And I get to choose L_1.

00:24:07.162 --> 00:24:11.551
Now, I could differentiate
this, set it to zero,

00:24:11.551 --> 00:24:15.099
and go crazy.
Or, I could realize that,

00:24:15.099 --> 00:24:19.954
I mean, that's not hard.
But, that's a little bit too

00:24:19.954 --> 00:24:22.662
fancy for me.
So, I could say,

00:24:22.662 --> 00:24:26.771
well, this is clearly best when
L_1 is small.

00:24:26.771 --> 00:24:32.000
And this is clearly best when
L_1 is large.

00:24:32.000 --> 00:24:37.927
So, there's a trade-off there.
And, the trade-off will be

00:24:37.927 --> 00:24:44.701
roughly minimized up to constant
factors when these two terms are

00:24:44.701 --> 00:24:48.512
equal.
That's when I have pretty good

00:24:48.512 --> 00:24:53.275
balance between the two ends of
the trade-off.

00:24:53.275 --> 00:24:56.874
So, this is up to constant
factors.

00:24:56.874 --> 00:25:03.331
I can let L_1 equal n over L_1,
OK, because at most I'm losing

00:25:03.331 --> 00:25:10.000
a factor of two there when they
happen to be equal.

00:25:10.000 --> 00:25:14.008
So now, I just solve this.
This is really easy.

00:25:14.008 --> 00:25:18.713
This is (L_1)^2 equals n.
So, L_1 is the square root of

00:25:18.713 --> 00:25:20.979
n.
OK, so the cost that I'm

00:25:20.979 --> 00:25:24.987
getting over here,
L_1 plus L_2 over L_1 is the

00:25:24.987 --> 00:25:28.908
square root of n plus n over
root n, which is,

00:25:28.908 --> 00:25:32.723
again, root n.
So, I get two root n.

00:25:32.723 --> 00:25:36.005
So, search cost,
and I'm caring about the

00:25:36.005 --> 00:25:39.369
constant here,
because it will matter in a

00:25:39.369 --> 00:25:41.666
moment.
Two square root of n:

00:25:41.666 --> 00:25:45.112
I'm not caring about the
additive constant,

00:25:45.112 --> 00:25:48.723
but the multiplicative constant
I care about.

00:25:48.723 --> 00:25:52.743
OK, that seems good.
We started with a linked list

00:25:52.743 --> 00:25:56.928
that searched in n time,
theta n time per operation.

00:25:56.928 --> 00:26:03.000
Now we have two linked lists,
search and theta root n time.

00:26:03.000 --> 00:26:07.286
It seems pretty good.
This is what the structure

00:26:07.286 --> 00:26:10.570
looks like.
We have root n guys here.

00:26:10.570 --> 00:26:15.586
This is in the local line.
And, we have one express stop

00:26:15.586 --> 00:26:19.964
which represents that.
But we have another root n

00:26:19.964 --> 00:26:24.798
values in the local line.
And we have one express stop

00:26:24.798 --> 00:26:28.993
that represents that.
And these two are linked,

00:26:28.993 --> 00:26:31.000
and so on.

00:26:42.000 --> 00:26:44.603
Well, I should put some dot,
dot, dots in there.

00:26:44.603 --> 00:26:47.096
OK, so each of these chunks has
length root n,

00:26:47.096 --> 00:26:49.479
and the number of
representatives up here is

00:26:49.479 --> 00:26:52.083
square root of n.
The number of express stops is

00:26:52.083 --> 00:26:54.742
square root of n.
So clearly, things are balanced

00:26:54.742 --> 00:26:55.684
now.
I search for,

00:26:55.684 --> 00:26:57.512
at most, square root of n up
here.

00:26:57.512 --> 00:27:00.171
Then I search in one of these
lists for, at most,

00:27:00.171 --> 00:27:04.736
square root of n.
So, every search takes,

00:27:04.736 --> 00:27:10.565
at most, two root n.
Cool, what should we do next?

00:27:10.565 --> 00:27:15.562
So, again, ignore insertions
and deletions.

00:27:15.562 --> 00:27:22.819
I want to make searches faster
because square root of n is not

00:27:22.819 --> 00:27:25.675
so hot as we know.
Sorry?

00:27:25.675 --> 00:27:30.672
More lines.
Let's add a super express line,

00:27:30.672 --> 00:27:35.430
or another linked list.
OK, this was two.

00:27:35.430 --> 00:27:41.812
Why not do three?
So, we started with a sorted

00:27:41.812 --> 00:27:45.026
linked list.
Then we went to two.

00:27:45.026 --> 00:27:48.340
This gave us two square root of
n.

00:27:48.340 --> 00:27:52.056
Now, I want three sorted linked
lists.

00:27:52.056 --> 00:27:57.279
I didn't pluralize here.
Any guesses what the running

00:27:57.279 --> 00:28:02.000
time might be?
This is just guesswork.

00:28:02.000 --> 00:28:05.834
Don't think.
From two square root of n,

00:28:05.834 --> 00:28:08.055
you would go to,
sorry?

00:28:08.055 --> 00:28:12.091
Two square root of two,
fourth root of n?

00:28:12.091 --> 00:28:17.743
That's on the right track.
Both the constant and the root

00:28:17.743 --> 00:28:20.972
change, but not quite so
fancily.

00:28:20.972 --> 00:28:24.201
Three times the cubed root:
good.

00:28:24.201 --> 00:28:29.954
Intuition is very helpful here.
It doesn't matter what the

00:28:29.954 --> 00:28:35.000
right answer is.
Use your intuition.

00:28:35.000 --> 00:28:37.278
You can prove that.
It's not so hard.

00:28:37.278 --> 00:28:40.632
You now have three lists,
and what you want to balance

00:28:40.632 --> 00:28:44.367
are at the length of the top
list, the ratio between the top

00:28:44.367 --> 00:28:47.721
two lists, and the ratio between
the bottom two lists.

00:28:47.721 --> 00:28:50.569
So, you want these three to
multiply out to n,

00:28:50.569 --> 00:28:53.544
because the top times the ratio
times the ratio:

00:28:53.544 --> 00:28:56.582
that has to equal n.
And, so that's where you get

00:28:56.582 --> 00:28:59.746
the cubed root of n.
Each of these should be equal.

00:28:59.746 --> 00:29:03.417
So, you set them because the
cost is the sum of those three

00:29:03.417 --> 00:29:07.470
things.
So, you set each of them to

00:29:07.470 --> 00:29:11.496
cubed root of n,
and there are three of them.

00:29:11.496 --> 00:29:15.888
OK, check it at home if you
want to be more sure.

00:29:15.888 --> 00:29:21.379
Obviously, we want a few more.
So, let's think about k sorted

00:29:21.379 --> 00:29:24.673
lists.
k sorted lists will be k times

00:29:24.673 --> 00:29:28.973
the k'th root of n.
You probably guessed that by

00:29:28.973 --> 00:29:33.000
now.
So, what should we set k to?

00:29:33.000 --> 00:29:38.013
I don't want the exact minimum.
What's a good value for k?

00:29:38.013 --> 00:29:41.355
Should I set it to n?
n's kind of nice,

00:29:41.355 --> 00:29:44.697
because the n'th root of n is
just one.

00:29:44.697 --> 00:29:48.390
Now that's n.
So, this is why I cared about

00:29:48.390 --> 00:29:53.403
the lead constant because it's
going to grow as I add more

00:29:53.403 --> 00:29:56.482
lists.
What's the biggest reasonable

00:29:56.482 --> 00:30:03.572
value of k that I could use?
Log n, because I have a k out

00:30:03.572 --> 00:30:07.884
there.
I certainly don't want to use

00:30:07.884 --> 00:30:13.304
more than log n.
So, log n times the log n'th

00:30:13.304 --> 00:30:18.724
root, and this is a little hard
to draw of n.

00:30:18.724 --> 00:30:23.036
Now, what is the log n'th root
of n?

00:30:23.036 --> 00:30:27.594
That's what you're all thinking
about.

00:30:27.594 --> 00:30:34.000
What is the log n'th root of n
minus two?

00:30:34.000 --> 00:30:39.559
It's one of these good
questions whose answer is?

00:30:39.559 --> 00:30:43.381
Oh man.
Remember the definition of

00:30:43.381 --> 00:30:47.203
root?
OK, the root is n to the one

00:30:47.203 --> 00:30:51.025
over log n.
OK, good, remember the

00:30:51.025 --> 00:30:55.658
definition of having a power,
A to the B?

00:30:55.658 --> 00:30:59.943
It was like two to the power,
B log A?

00:30:59.943 --> 00:31:06.081
Does that sound familiar?
So, this is two to the log n

00:31:06.081 --> 00:31:11.872
over log n, which is,
I hope you can get it at this

00:31:11.872 --> 00:31:17.317
point, two.
Wow, so the log n'th root of n

00:31:17.317 --> 00:31:20.175
minus two is zero:
my favorite answer.

00:31:20.175 --> 00:31:23.652
OK, this is to.
So this whole thing is two log

00:31:23.652 --> 00:31:26.819
n: pretty nifty.
So, you could be a little

00:31:26.819 --> 00:31:31.377
fancier and tweak this a little
bit, but two log n is plenty

00:31:31.377 --> 00:31:36.227
good for me.
We clearly don't want to use

00:31:36.227 --> 00:31:41.298
any more lists,
but log n lists sounds pretty

00:31:41.298 --> 00:31:45.332
good.
I get, now, logarithmic search

00:31:45.332 --> 00:31:47.291
time.
Let's check.

00:31:47.291 --> 00:31:52.247
I mean, we sort of did this all
intuitively.

00:31:52.247 --> 00:31:56.281
Let's draw what the list looks
like.

00:31:56.281 --> 00:32:01.583
But, it will work.
So, I'm going to redraw this

00:32:01.583 --> 00:32:07.000
example because you have to,
also.

00:32:07.000 --> 00:32:14.968
So, let's redesign that New
York City subway system.

00:32:14.968 --> 00:32:22.781
And, I want you to leave three
blank lines up here.

00:32:22.781 --> 00:32:29.187
So, you should have this
memorized by now.

00:32:29.187 --> 00:32:34.293
But I don't.
So, we are not allowed to

00:32:34.293 --> 00:32:38.513
change the local line,
though it would be nice,

00:32:38.513 --> 00:32:43.834
add a few more stops there.
OK, we can stop at 79th Street.

00:32:43.834 --> 00:32:47.688
That's enough.
So now, we have log n lists.

00:32:47.688 --> 00:32:53.100
And here, log n is about four.
So, I want to make a bunch of

00:32:53.100 --> 00:32:55.394
lists here.
In particular,

00:32:55.394 --> 00:33:02.000
14 will appear on all of them.
So, why don't I draw those in?

00:33:02.000 --> 00:33:05.241
And, the question is,
which elements go in here?

00:33:05.241 --> 00:33:08.896
So, I have log n lists.
And, my goal is to balance the

00:33:08.896 --> 00:33:12.689
number of items up here,
and the ratio between these two

00:33:12.689 --> 00:33:15.724
lists, and the ratio between
these two lists,

00:33:15.724 --> 00:33:18.275
and the ratio between these two
lists.

00:33:18.275 --> 00:33:20.896
I want all these things to be
balanced.

00:33:20.896 --> 00:33:24.482
There are log n of them.
So, the product of all those

00:33:24.482 --> 00:33:27.655
ratios better be n,
the number of elements down

00:33:27.655 --> 00:33:29.931
here.
So, the product of all these

00:33:29.931 --> 00:33:36.457
ratios is n.
And there's log n of them;

00:33:36.457 --> 00:33:44.685
how big is each ratio?
So, I'll call the ratio r.

00:33:44.685 --> 00:33:52.400
The ratio's r.
I should have r to the power of

00:33:52.400 --> 00:33:56.514
log n equals n.
What's r?

00:33:56.514 --> 00:34:02.000
What's r minus two?
Zero.

00:34:02.000 --> 00:34:05.038
OK, this should be two to the
power of log n.

00:34:05.038 --> 00:34:09.180
So, if the ratio between the
number of elements here and here

00:34:09.180 --> 00:34:12.909
is to all the way down,
then I will have an elements at

00:34:12.909 --> 00:34:15.119
the bottom, which is what I
want.

00:34:15.119 --> 00:34:18.502
So, in other words,
I want half the elements here,

00:34:18.502 --> 00:34:22.783
a quarter of the elements here,
an eighth of the elements here,

00:34:22.783 --> 00:34:25.476
and so on.
So, I'm going to take half of

00:34:25.476 --> 00:34:28.790
the elements evenly spaced out:
34th, 50th, 66th,

00:34:28.790 --> 00:34:32.564
79th, and so on.
So, this is our new

00:34:32.564 --> 00:34:35.529
semi-express line:
not terribly fast,

00:34:35.529 --> 00:34:39.400
but you save a factor of two
for going up there.

00:34:39.400 --> 00:34:42.199
And, when you're done,
you go down,

00:34:42.199 --> 00:34:44.752
and you walk,
at most, one step.

00:34:44.752 --> 00:34:47.717
And you find what you're
looking for.

00:34:47.717 --> 00:34:52.247
OK, and then we do the same
thing over and over and over

00:34:52.247 --> 00:34:56.941
until we run out of elements.
I can't read my own writing.

00:34:56.941 --> 00:34:59.000
It's 79th.

00:35:11.000 --> 00:35:14.743
OK, if I had a bigger example,
I would be more levels,

00:35:14.743 --> 00:35:19.122
but this is just barely enough.
Let's say two elements is where

00:35:19.122 --> 00:35:21.029
I stop.
So, this looks good.

00:35:21.029 --> 00:35:24.561
Does this look like a structure
you've seen before,

00:35:24.561 --> 00:35:25.973
at all, vaguely?
Yes?

00:35:25.973 --> 00:35:28.799
A tree: yes.
It looks a lot like a binary

00:35:28.799 --> 00:35:31.715
tree.
I'll just leave it at that.

00:35:31.715 --> 00:35:34.639
In your problem set,
you'll understand why skip

00:35:34.639 --> 00:35:38.261
lists are really like trees.
But it's more or less a tree.

00:35:38.261 --> 00:35:41.566
Let's say at this level,
it looks sort of like binary

00:35:41.566 --> 00:35:42.964
search.
You look at 14;

00:35:42.964 --> 00:35:44.807
you look at 15,
and therefore,

00:35:44.807 --> 00:35:48.366
you decide whether you are in
the left half for the right

00:35:48.366 --> 00:35:50.654
half.
And that's sort of like a tree.

00:35:50.654 --> 00:35:54.340
It's not quite a tree because
we have this element repeated

00:35:54.340 --> 00:35:55.992
all over.
But more or less,

00:35:55.992 --> 00:35:59.297
this is a binary tree.
At depth I, we have two to the

00:35:59.297 --> 00:36:04.000
I nodes, just like a tree,
just like a balanced tree.

00:36:04.000 --> 00:36:08.305
I'm going to call this
structure an ideal skip list.

00:36:08.305 --> 00:36:13.201
And, if all we are doing our
searches, ideal skip lists are

00:36:13.201 --> 00:36:15.733
pretty good.
Maybe at practice:

00:36:15.733 --> 00:36:20.798
not quite as good as a binary
search tree, but up to constant

00:36:20.798 --> 00:36:24.006
factors: just as good.
So, for example,

00:36:24.006 --> 00:36:28.818
I mean, we can generalize
search, just check that it's log

00:36:28.818 --> 00:36:32.348
n.
So, the search procedure is you

00:36:32.348 --> 00:36:36.136
start at the top left.
So, let's say we are looking

00:36:36.136 --> 00:36:38.636
for 72.
You start at the top left.

00:36:38.636 --> 00:36:41.893
14 is smaller than 72,
so I try to go right.

00:36:41.893 --> 00:36:44.772
79 is too big.
So, I follow this arrow,

00:36:44.772 --> 00:36:47.196
but I say, oops,
that's too much.

00:36:47.196 --> 00:36:49.545
So, instead,
I go down 14 still.

00:36:49.545 --> 00:36:53.030
I go to the right:
oh, 50, that's still smaller

00:36:53.030 --> 00:36:55.909
than 72: OK.
I tried to go right again.

00:36:55.909 --> 00:36:58.787
Oh: 79, that's too big.
That's no good.

00:36:58.787 --> 00:37:00.833
So, I go down.
So, I get 50.

00:37:00.833 --> 00:37:05.000
I do the same thing over and
over.

00:37:05.000 --> 00:37:07.306
I try to go to the right:
oh, 66, that's OK.

00:37:07.306 --> 00:37:09.774
Try to go to the right:
oh, 79, that's too big.

00:37:09.774 --> 00:37:11.866
So I go down.
Now I go to the right and,

00:37:11.866 --> 00:37:14.120
oh, 72: done.
Otherwise, I'd go too far and

00:37:14.120 --> 00:37:16.695
try to go down and say,
oops, element must not be

00:37:16.695 --> 00:37:18.358
there.
It's a very simple search

00:37:18.358 --> 00:37:21.469
algorithm: same as here except
just remove the L_1 and L_2.

00:37:21.469 --> 00:37:23.401
Go right until that would go
too far.

00:37:23.401 --> 00:37:25.761
Then go down.
Then go right until we'd go too

00:37:25.761 --> 00:37:28.605
far, and then go down.
You might have to do this log n

00:37:28.605 --> 00:37:30.937
times.
In each level,

00:37:30.937 --> 00:37:34.687
you're clearly only walking a
couple of steps because the

00:37:34.687 --> 00:37:37.433
ratio between these two sizes is
only two.

00:37:37.433 --> 00:37:40.044
So, this will cost two log n
for search.

00:37:40.044 --> 00:37:42.991
Good, I mean,
so that was to check because we

00:37:42.991 --> 00:37:46.339
were using intuition over here;
a little bit shaky.

00:37:46.339 --> 00:37:50.357
So, this is an ideal skip list,
we have to support insertions

00:37:50.357 --> 00:37:53.303
and deletions.
As soon as we do an insert and

00:37:53.303 --> 00:37:57.321
delete, there's no way we're
going to maintain the structure.

00:37:57.321 --> 00:38:03.074
It's a bit too special.
There is only one of these

00:38:03.074 --> 00:38:09.932
where everything is perfectly
spaced out, and everything is

00:38:09.932 --> 00:38:13.597
beautiful.
So, we can't do that.

00:38:13.597 --> 00:38:20.810
We're going to maintain roughly
this structure as best we can.

00:38:20.810 --> 00:38:27.668
And, if anyone of you knows
someone in New York City subway

00:38:27.668 --> 00:38:31.452
planning, you can tell them
this.

00:38:31.452 --> 00:38:37.900
OK, so: skip lists.
So, I mean, this is basically

00:38:37.900 --> 00:38:42.099
our data structure.
You could use this as a

00:38:42.099 --> 00:38:46.500
starting point,
but then you start using skip

00:38:46.500 --> 00:38:49.400
lists.
And, we need to somehow

00:38:49.400 --> 00:38:54.900
implement insertions and
deletions, and maintain roughly

00:38:54.900 --> 00:39:01.199
this structure well enough that
the search still costs order log

00:39:01.199 --> 00:39:05.400
n time.
So, let's focus on insertions.

00:39:05.400 --> 00:39:09.559
If we do insertions right,
it turns out deletions are

00:39:09.559 --> 00:39:11.000
really trivial.

00:39:28.000 --> 00:39:31.556
And again, this is all from
first principles.

00:39:31.556 --> 00:39:34.709
We're not allowed to use
anything fancy.

00:39:34.709 --> 00:39:38.588
But, it would be nice if we
used some good chalk.

00:39:38.588 --> 00:39:42.792
This one looks better.
So, suppose you want to insert

00:39:42.792 --> 00:39:46.187
an element, x.
We said how to search for an

00:39:46.187 --> 00:39:48.773
element.
So, how do we insert it?

00:39:48.773 --> 00:39:53.785
Well, the first thing we should
do is figure out where it goes.

00:39:53.785 --> 00:39:57.584
So, we search for x.
We call search of x to find

00:39:57.584 --> 00:40:03.000
where x fits in the bottom list,
not just any list.

00:40:03.000 --> 00:40:06.371
Pretty easy to find out where
it fits in the top list.

00:40:06.371 --> 00:40:08.343
That takes, like,
constant time.

00:40:08.343 --> 00:40:11.206
What we want to know:
because the top list has

00:40:11.206 --> 00:40:14.196
constant length,
we want to know where x goes in

00:40:14.196 --> 00:40:17.186
the bottom list.
So, let's say we want to insert

00:40:17.186 --> 00:40:19.858
a search for 80.
Well, it is a bit too big.

00:40:19.858 --> 00:40:22.658
Let search for 75.
So, we'll find the 75 fits

00:40:22.658 --> 00:40:25.711
right here between 72 and 79
using the same path.

00:40:25.711 --> 00:40:29.210
OK, if it's there already,
we complain because I'm going

00:40:29.210 --> 00:40:32.900
to assume all keys are distinct
for now just so the picture

00:40:32.900 --> 00:40:38.224
stays simple.
But this works fine even if you

00:40:38.224 --> 00:40:42.385
are inserting the same key over
and over.

00:40:42.385 --> 00:40:47.587
So, that seems good.
One thing we should clearly do

00:40:47.587 --> 00:40:50.916
is insert x into the bottom
list.

00:40:50.916 --> 00:40:55.597
We now know where it fits.
It should go there.

00:40:55.597 --> 00:40:59.966
Because we want to maintain
this invariant,

00:40:59.966 --> 00:41:06.000
that the bottom list contains
all the elements.

00:41:06.000 --> 00:41:10.412
So, there we go.
We've maintained the invariant.

00:41:10.412 --> 00:41:14.261
The bottom list contains all
the elements.

00:41:14.261 --> 00:41:18.579
So, we search for 75.
We say, oh, 75 goes here,

00:41:18.579 --> 00:41:24.024
and we just sort of link in 75.
You know how to do a linked

00:41:24.024 --> 00:41:29.000
list, I hope.
Let me just erase that pointer.

00:41:29.000 --> 00:41:32.627
All the work in implementing
skip lists is the linked list

00:41:32.627 --> 00:41:34.409
manipulation.
Is that enough?

00:41:34.409 --> 00:41:38.227
No, it would be fine for now
because now there's only a chain

00:41:38.227 --> 00:41:41.918
of length three here that you'd
have to walk over if you're

00:41:41.918 --> 00:41:44.145
looking for something in this
range.

00:41:44.145 --> 00:41:47.454
But if I just keep inserting
75, and 76, than 76 plus

00:41:47.454 --> 00:41:51.081
epsilon, 76 plus two epsilon,
and so on, just pack a whole

00:41:51.081 --> 00:41:54.390
bunch of elements in here,
this chain will get really

00:41:54.390 --> 00:41:55.599
long.
Now, suddenly,

00:41:55.599 --> 00:41:58.400
things are not so balanced.
If I do a search,

00:41:58.400 --> 00:42:02.090
I'll pay an arbitrarily long
amount time here to search for

00:42:02.090 --> 00:42:05.403
someone.
If I insert k things,

00:42:05.403 --> 00:42:08.210
it'll take k time.
I want it to stay log n.

00:42:08.210 --> 00:42:11.218
If I only insert log n items,
it's OK for now.

00:42:11.218 --> 00:42:15.161
What I want to do is decide
which of these lists contain 75.

00:42:15.161 --> 00:42:17.367
So, clearly it goes on the
bottom.

00:42:17.367 --> 00:42:19.506
Every element goes in the
bottom.

00:42:19.506 --> 00:42:21.511
Should it go up a level?
Maybe.

00:42:21.511 --> 00:42:23.516
It depends.
It's not clear yet.

00:42:23.516 --> 00:42:27.460
If I insert a few items here,
definitely some of them should

00:42:27.460 --> 00:42:39.146
go on the next level.
Should I go to levels up?

00:42:39.146 --> 00:42:57.073
Maybe, but even less likely.
So, what should I do?

00:42:57.073 --> 00:43:01.804
Yeah?
Right, so you maintain the

00:43:01.804 --> 00:43:05.414
ideal partition size,
which may be like the length of

00:43:05.414 --> 00:43:07.010
this chain.
And you see,

00:43:07.010 --> 00:43:10.967
well, if that gets too long,
then I should split it in the

00:43:10.967 --> 00:43:14.091
middle, promote that guy up to
the next level,

00:43:14.091 --> 00:43:18.047
and do the same thing up here.
If this chain gets too long

00:43:18.047 --> 00:43:21.379
between two consecutive next
level express stops,

00:43:21.379 --> 00:43:23.600
then I'll promote the middle
guy.

00:43:23.600 --> 00:43:26.724
And that's what you'll do in
your problem set.

00:43:26.724 --> 00:43:30.056
That's too fancy for me.
I don't need no stinking

00:43:30.056 --> 00:43:34.000
counters.
What else could I do?

00:43:46.000 --> 00:43:48.800
I could try to maintain the
ideal skip list structure.

00:43:48.800 --> 00:43:51.811
That will be too expensive.
Like I say, 75 is the guy that

00:43:51.811 --> 00:43:54.083
gets promoted,
and this guy gets demoted all

00:43:54.083 --> 00:43:55.984
the way down.
But that will propagate

00:43:55.984 --> 00:43:58.890
everything to the right.
And that could cost linear time

00:43:58.890 --> 00:44:01.261
for update.
Other idea?

00:44:01.261 --> 00:44:07.799
If I only want half of them to
go up, I could flip a coin.

00:44:07.799 --> 00:44:11.240
Good idea.
All right, for that,

00:44:11.240 --> 00:44:16.057
I will give you a quarter.
It's a good one.

00:44:16.057 --> 00:44:19.842
It's the old line state,
Maryland.

00:44:19.842 --> 00:44:24.544
There you go.
However, you have to perform

00:44:24.544 --> 00:44:32.000
some services for that quarter,
namely, flip the coin.

00:44:32.000 --> 00:44:34.311
Can you flip a coin?
Good.

00:44:34.311 --> 00:44:38.380
What did you get?
Tails, OK, that's the first

00:44:38.380 --> 00:44:42.263
random bit.
But we are going to do is build

00:44:42.263 --> 00:44:45.869
a skip list.
Maybe I should tell you how

00:44:45.869 --> 00:44:48.828
first.
OK, but the idea is flip a

00:44:48.828 --> 00:44:50.585
coin.
If it's heads,

00:44:50.585 --> 00:44:55.671
so, sorry, if it's heads,
we will promote it to the next

00:44:55.671 --> 00:45:03.484
level, and flip again.
So, this is an answer to the

00:45:03.484 --> 00:45:10.212
question, which other lists
should store x?

00:45:10.212 --> 00:45:16.458
How many other lists should we
add x to?

00:45:16.458 --> 00:45:22.064
Well, the algorithm is,
flip a coin,

00:45:22.064 --> 00:45:28.632
and if it comes out heads,
then promote x.

00:45:28.632 --> 00:45:36.000
to the next level up,
and flip again.

00:45:36.000 --> 00:45:39.119
OK, that's key because we might
want this element to go

00:45:39.119 --> 00:45:41.084
arbitrarily high.
But for starters,

00:45:41.084 --> 00:45:43.395
we flip a coin.
It doesn't go to the next

00:45:43.395 --> 00:45:45.533
level.
Well, we'd like it to go to the

00:45:45.533 --> 00:45:49.057
next level with probability one
half because we want the ratio

00:45:49.057 --> 00:45:51.715
between these two sizes to be a
half, or sorry,

00:45:51.715 --> 00:45:54.199
two, depending which way you
take the ratio.

00:45:54.199 --> 00:45:56.742
So, I want roughly half the
elements up here.

00:45:56.742 --> 00:45:58.995
So, I flip a coin.
If it comes up heads,

00:45:58.995 --> 00:46:02.000
I go up here.
This is a fair coin.

00:46:02.000 --> 00:46:05.139
So I want it 50-50.
OK, then how many should that

00:46:05.139 --> 00:46:07.362
element go up to the next level
up?

00:46:07.362 --> 00:46:09.455
Well, with 50% probability
again.

00:46:09.455 --> 00:46:12.464
So, I flip another point.
If it comes up heads,

00:46:12.464 --> 00:46:15.799
I'll go up another level.
And that will maintain the

00:46:15.799 --> 00:46:19.265
approximate ratio between these
two guys as being two.

00:46:19.265 --> 00:46:21.947
The expected ratio will
definitely be two,

00:46:21.947 --> 00:46:25.609
and so on, all the way up.
If I go up to the top and flip

00:46:25.609 --> 00:46:28.879
a coin, it comes up heads,
I'll make another level.

00:46:28.879 --> 00:46:33.000
This is the insertion
algorithm: dead simple.

00:46:33.000 --> 00:46:38.090
The fancier one you will see on
your problem set.

00:46:38.090 --> 00:46:40.000
So, let's do it.

00:46:49.000 --> 00:46:53.435
OK, I also need someone to
generate random numbers.

00:46:53.435 --> 00:46:56.185
Who can generate random
numbers?

00:46:56.185 --> 00:47:00.000
Pseudo-random?
I'll give you a quarter.

00:47:00.000 --> 00:47:02.004
I have one here.
Here you go.

00:47:02.004 --> 00:47:05.584
That's a boring quarter.
Who would like to generate

00:47:05.584 --> 00:47:08.662
random numbers?
Someone volunteering someone

00:47:08.662 --> 00:47:10.953
else: that's a good way to do
it.

00:47:10.953 --> 00:47:13.101
Here you go.
You get a quarter,

00:47:13.101 --> 00:47:15.464
but you're not allowed to flip
it.

00:47:15.464 --> 00:47:18.900
No randomness for you;
well, OK, you can generate

00:47:18.900 --> 00:47:22.695
bits, and then compute a number.
So, give me a number.

00:47:22.695 --> 00:47:25.845
44, can answer.
OK, we already flipped a coin

00:47:25.845 --> 00:47:27.348
and I got tails.
Done.

00:47:27.348 --> 00:47:33.441
That's the insertion algorithm.
I'm going to make some more

00:47:33.441 --> 00:47:36.696
space actually,
put it way down here.

00:47:36.696 --> 00:47:41.579
OK, so 44 does not get promoted
because we got a tails.

00:47:41.579 --> 00:47:46.734
So, give me another number.
Nine, OK, I search for nine in

00:47:46.734 --> 00:47:49.989
this list.
I should mention one other

00:47:49.989 --> 00:47:53.154
thing, sorry.
I need a small change.

00:47:53.154 --> 00:47:57.223
This is just to make sure
searches still work.

00:47:57.223 --> 00:48:02.468
So, the worry is suppose I
insert something bigger and then

00:48:02.468 --> 00:48:07.096
I promote it.
This would look very bad for a

00:48:07.096 --> 00:48:11.360
skip list data structure because
I always want to start at the

00:48:11.360 --> 00:48:13.946
top left, and now there's no top
left.

00:48:13.946 --> 00:48:17.301
So, just minor change:
just let me remember that.

00:48:17.301 --> 00:48:21.354
The minor change is that I'm
going to store a special value

00:48:21.354 --> 00:48:25.478
minus infinity in every list.
So, minus infinity always gets

00:48:25.478 --> 00:48:29.811
promoted all the way to the top,
whatever the top happens to be

00:48:29.811 --> 00:48:32.234
now.
So, initially,

00:48:32.234 --> 00:48:35.407
that way I'll always have a top
left.

00:48:35.407 --> 00:48:38.139
Sorry, I forgot to mention
that.

00:48:38.139 --> 00:48:41.930
So, initially I'll just have
minus infinity.

00:48:41.930 --> 00:48:45.632
Then I insert 44.
I say, OK, 44 goes there,

00:48:45.632 --> 00:48:47.218
no promotion,
done.

00:48:47.218 --> 00:48:49.951
Now, we're going to insert
nine.

00:48:49.951 --> 00:48:53.653
Nine goes here.
So, minus infinity to nine,

00:48:53.653 --> 00:48:55.504
flip your coin,
heads.

00:48:55.504 --> 00:49:00.000
Did he actually flip it?
OK, good.

00:49:00.000 --> 00:49:02.479
He flipped it before,
yeah, sure.

00:49:02.479 --> 00:49:04.881
I'm just giving you a hard
time.

00:49:04.881 --> 00:49:09.142
So, we have nine up here.
We need to maintain this minus

00:49:09.142 --> 00:49:13.249
infinity just to make sure it
gets promoted along with

00:49:13.249 --> 00:49:16.891
everything else.
So, that looks like a nice skip

00:49:16.891 --> 00:49:18.363
list.
Flip it again.

00:49:18.363 --> 00:49:21.694
Tails, good.
OK, so this looks like an ideal

00:49:21.694 --> 00:49:23.786
skip list.
Isn't that great?

00:49:23.786 --> 00:49:27.428
It works every time.
OK, give me another number.

00:49:27.428 --> 00:49:32.000
26, OK, so I search for 26.
26 goes here.

00:49:32.000 --> 00:49:36.542
It clearly goes on the bottom
list.

00:49:36.542 --> 00:49:41.886
Here we go, 26,
and then I you raised 44.

00:49:41.886 --> 00:49:46.028
Flip.
Tails, OK, another number.

00:49:46.028 --> 00:49:52.307
50, oh, a big one.
It costs me a little while to

00:49:52.307 --> 00:49:56.449
search, and I get over here.
50.

00:49:56.449 --> 00:49:58.720
Flip.
Heads, good.

00:49:58.720 --> 00:50:05.000
So 50 gets promoted.
Flip it again.

00:50:05.000 --> 00:50:08.071
Tails, OK, still a reasonable
number.

00:50:08.071 --> 00:50:11.911
Another number?
12, it takes a little while to

00:50:11.911 --> 00:50:15.921
get exciting here.
OK, 12 goes here between nine

00:50:15.921 --> 00:50:18.907
and 26.
You're giving me a hard time

00:50:18.907 --> 00:50:20.102
here.
OK, flip.

00:50:20.102 --> 00:50:24.624
Heads, OK, 12 gets promoted.
I know you have to work a

00:50:24.624 --> 00:50:30.000
little bit, but we just came
here to search for 12.

00:50:30.000 --> 00:50:35.371
So, we know that nine was the
last point we went down.

00:50:35.371 --> 00:50:39.729
So, we promote 12.
It gets inserted up here.

00:50:39.729 --> 00:50:45.202
We are just inserting into this
particular linked list:

00:50:45.202 --> 00:50:48.952
nothing fancy.
We link the two twelves

00:50:48.952 --> 00:50:52.804
together.
It still looks kind of like a

00:50:52.804 --> 00:50:55.135
linked list.
Flip again.

00:50:55.135 --> 00:50:58.074
OK, tails, another number.
37.

00:50:58.074 --> 00:51:02.837
Jeez.
It's a good test of memory.

00:51:02.837 --> 00:51:05.570
37, what was it,
44 and 50?

00:51:05.570 --> 00:51:08.828
And 50 was at the next level
up.

00:51:08.828 --> 00:51:14.818
I think I should just keep
appending elements and have you

00:51:14.818 --> 00:51:18.496
flip coins.
OK, we just inserted 37.

00:51:18.496 --> 00:51:22.385
Tails.
OK, that's getting to be a long

00:51:22.385 --> 00:51:25.433
chain.
That looks a bit worse.

00:51:25.433 --> 00:51:29.742
OK, give me another number
larger than 50.

00:51:29.742 --> 00:51:34.284
51, good answer.
Thank you.

00:51:34.284 --> 00:51:37.495
OK, flip again.
And again.

00:51:37.495 --> 00:51:40.192
Tails.
Another number.

00:51:40.192 --> 00:51:45.201
Wait, someone else should pick
a number.

00:51:45.201 --> 00:51:49.568
It's not working.
What did you say?

00:51:49.568 --> 00:51:52.266
52, good answer.
Flip.

00:51:52.266 --> 00:51:58.559
Tails, not surprising.
We've gotten a lot of heads

00:51:58.559 --> 00:52:03.778
there.
OK, another number.

00:52:03.778 --> 00:52:06.556
53, thank you.
Flip.

00:52:06.556 --> 00:52:08.896
Heads, heads,
OK.

00:52:08.896 --> 00:52:13.136
Heads, heads,
you didn't flip.

00:52:13.136 --> 00:52:17.669
All right, 53,
you get the idea.

00:52:17.669 --> 00:52:26.004
If you get two consecutive
heads, then the guy goes up two

00:52:26.004 --> 00:52:32.000
levels.
OK, now flip for real.

00:52:32.000 --> 00:52:33.501
Heads.
Finally.

00:52:33.501 --> 00:52:39.938
Heads we've been waiting for.
If you flipped three heads in a

00:52:39.938 --> 00:52:44.122
row, you go three levels.
And each time,

00:52:44.122 --> 00:52:47.555
we keep promoting minus
infinity.

00:52:47.555 --> 00:52:50.559
Look again.
Heads, oh my God.

00:52:50.559 --> 00:52:54.206
Where were they before?
Flip again.

00:52:54.206 --> 00:53:00.000
It better be tails this time.
Tails, good.

00:53:00.000 --> 00:53:04.000
OK, you get the idea.
Eventually you run out of board

00:53:04.000 --> 00:53:06.769
space.
Now, it's pretty rare that you

00:53:06.769 --> 00:53:10.076
go too high.
What's the probability that you

00:53:10.076 --> 00:53:13.923
go higher than log n?
Another easy log computation.

00:53:13.923 --> 00:53:17.538
Each time, I have a 50%
probability of going up.

00:53:17.538 --> 00:53:22.153
One in n probability of going
up log n levels because half to

00:53:22.153 --> 00:53:24.769
the power of log n is one out of
n.

00:53:24.769 --> 00:53:28.384
So, it depends on n,
but I'm not going to go too

00:53:28.384 --> 00:53:32.022
high.
And, intuitively,

00:53:32.022 --> 00:53:37.256
this is not so bad.
So, these are skip lists.

00:53:37.256 --> 00:53:44.156
You have the ratios right in
expectation, which is a pretty

00:53:44.156 --> 00:53:49.628
weak statement.
This doesn't say anything about

00:53:49.628 --> 00:53:54.862
the lengths of these change.
But intuitively,

00:53:54.862 --> 00:53:59.739
it's pretty good.
Let's say pretty good on

00:53:59.739 --> 00:54:03.279
average.
So, I had two semi-random

00:54:03.279 --> 00:54:05.890
processes going on here.
One is picking the numbers,

00:54:05.890 --> 00:54:08.296
and that, I don't want to
assume anything about.

00:54:08.296 --> 00:54:09.935
The numbers could be
adversarial.

00:54:09.935 --> 00:54:12.494
It could be sequential.
It could be reverse sorted.

00:54:12.494 --> 00:54:14.133
It could be random.
I don't know.

00:54:14.133 --> 00:54:15.822
So, it didn't matter what he
said.

00:54:15.822 --> 00:54:18.587
At least, it shouldn't matter.
I mean, it matters here.

00:54:18.587 --> 00:54:20.174
Don't worry.
You're still loved.

00:54:20.174 --> 00:54:22.887
You still get your $0.25.
But what the algorithm cares

00:54:22.887 --> 00:54:24.730
about is the outcomes of these
coins.

00:54:24.730 --> 00:54:27.187
And the probability,
the statement that this data

00:54:27.187 --> 00:54:30.054
structure is fast with high
probability is only about the

00:54:30.054 --> 00:54:34.396
random coins.
Right, it doesn't matter what

00:54:34.396 --> 00:54:38.942
the adversary chooses for
numbers as long as those coins

00:54:38.942 --> 00:54:43.239
are random, and the adversary
doesn't know the coins.

00:54:43.239 --> 00:54:46.628
It doesn't know the outcomes of
the coins.

00:54:46.628 --> 00:54:50.595
So, in that case,
on average, overall of the coin

00:54:50.595 --> 00:54:55.057
flips, you should be OK.
But the claim is not just that

00:54:55.057 --> 00:54:58.776
it's pretty good on average.
But, it's really,

00:54:58.776 --> 00:55:03.794
really good almost always.
OK, with really high

00:55:03.794 --> 00:55:07.294
probability it's log n.
So, for example,

00:55:07.294 --> 00:55:10.705
with probability,
one minus one over n,

00:55:10.705 --> 00:55:15.192
it's order of log n,
with probability one minus one

00:55:15.192 --> 00:55:19.679
over n^2 it's log n,
probability one minus one over

00:55:19.679 --> 00:55:24.435
n^100, it's order log n.
All those statements are true

00:55:24.435 --> 00:55:30.000
for any value of 100.
So, that's where we're going.

00:55:30.000 --> 00:55:33.121
OK, I should mention,
how do you delete in a skip

00:55:33.121 --> 00:55:34.552
list?
Find the element.

00:55:34.552 --> 00:55:37.934
You delete it all the way.
There's nothing fancy with

00:55:37.934 --> 00:55:40.016
delete.
Because we have all these

00:55:40.016 --> 00:55:43.788
independent, random choices,
all of these elements are sort

00:55:43.788 --> 00:55:47.170
of independent from each other.
We don't really care.

00:55:47.170 --> 00:55:49.837
So, delete an element,
just throw it away.

00:55:49.837 --> 00:55:53.349
The tricky part is insertion.
When I insert an element,

00:55:53.349 --> 00:55:56.731
I'm just going to randomly see
how high it should go.

00:55:56.731 --> 00:56:00.569
With probability one over two
to the i, it will go to height

00:56:00.569 --> 00:56:04.597
i.
Good, that's my time.

00:56:04.597 --> 00:56:08.804
I've been having too much fun
here.

00:56:08.804 --> 00:56:14.000
I've got to go a little bit
faster, OK.

00:56:25.000 --> 00:56:32.828
So here's the theorem.
Let's see exactly what we are

00:56:32.828 --> 00:56:38.355
proving first.
With high probability,

00:56:38.355 --> 00:56:46.337
this is a formal notion which I
will define a second.

00:56:46.337 --> 00:56:55.241
Every search in n elements skip
lists costs order of log n.

00:56:55.241 --> 00:57:03.050
So, that's the theorem.
Now I need to define with high

00:57:03.050 --> 00:57:06.915
probability.
So, with high probability.

00:57:06.915 --> 00:57:10.169
And, it's a bit of a long
phrase.

00:57:10.169 --> 00:57:15.050
So, often we will,
and you can abbreviate it WHP.

00:57:15.050 --> 00:57:20.847
So, if I have a random event,
and the random event here is

00:57:20.847 --> 00:57:26.338
that every search in an n
element skip list costs order

00:57:26.338 --> 00:57:32.440
log n, I want to know what it
means for that event E to occur

00:57:32.440 --> 00:57:36.000
with high probability.

00:57:47.000 --> 00:57:53.726
So this is the definition.
So, the statement is that for

00:57:53.726 --> 00:58:00.820
any alpha greater than or equal
to one, there is a suitable

00:58:00.820 --> 00:58:04.000
choice of constants --

00:58:16.000 --> 00:58:27.739
-- for which the event,
E, occurs with this probability

00:58:27.739 --> 00:58:37.739
I keep mentioning.
So, the probability at least

00:58:37.739 --> 00:58:46.000
one minus one over n to the
alpha.

00:58:46.000 --> 00:58:49.807
So, this is a bit imprecise,
but it will suffice for our

00:58:49.807 --> 00:58:52.369
purposes.
If you want to really formal

00:58:52.369 --> 00:58:55.276
definition, you can read the
lecture notes.

00:58:55.276 --> 00:58:59.569
There are special lecture notes
for this lecture on the stellar

00:58:59.569 --> 00:59:01.784
site.
And, there's the PowerPoint

00:59:01.784 --> 00:59:06.130
notes on the SMA site.
But, right, there's a bit of a

00:59:06.130 --> 00:59:08.970
subtlety in the choice of
constants here.

00:59:08.970 --> 00:59:11.384
There is a choice of this
constant.

00:59:11.384 --> 00:59:14.011
And there's a choice of this
constant.

00:59:14.011 --> 00:59:16.994
And, these are related.
And, there's alpha,

00:59:16.994 --> 00:59:19.266
which we get to whatever we
want.

00:59:19.266 --> 00:59:22.390
But the bottom line is,
we get to choose what

00:59:22.390 --> 00:59:24.875
probability we want this to be
true.

00:59:24.875 --> 00:59:28.710
If I want it to be true,
with probability one minus one

00:59:28.710 --> 00:59:32.686
over n^100, I can do that.
I just sat alpha to a hundred,

00:59:32.686 --> 00:59:37.088
and up to this little constant
that's going to grow much slower

00:59:37.088 --> 00:59:41.936
than n to the alpha.
I get the error probability.

00:59:41.936 --> 00:59:45.048
So this thing is called the
error probability.

00:59:45.048 --> 00:59:48.438
The probability that I fail is
polynomially small,

00:59:48.438 --> 00:59:51.827
for any polynomial I want.
Now, with the same data

00:59:51.827 --> 00:59:54.870
structure, right,
I fixed the data structure.

00:59:54.870 --> 00:59:57.982
It doesn't depend on alpha.
Anything you want,

00:59:57.982 --> 01:00:01.717
any alpha value you want,
this data structure will take

01:00:01.717 --> 01:00:06.692
order of log n time.
Now, this constant will depend

01:00:06.692 --> 01:00:08.666
on alpha.
So, you know,

01:00:08.666 --> 01:00:14.141
you want error probability one
over n^100 is probably going to

01:00:14.141 --> 01:00:17.461
be, like, 100 log n.
It's still log n.

01:00:17.461 --> 01:00:22.128
OK, this is a very strong claim
about the tale of the

01:00:22.128 --> 01:00:27.064
distribution of the running time
of search, very strong.

01:00:27.064 --> 01:00:32.000
Let me give you an idea of how
strong it is.

01:00:32.000 --> 01:00:36.731
How many people know what
Boole's inequality is?

01:00:36.731 --> 01:00:42.671
How many people know what the
union bound is in probability?

01:00:42.671 --> 01:00:45.691
You should.
It's in appendix c.

01:00:45.691 --> 01:00:49.214
Maybe you'll know it by the
theorem.

01:00:49.214 --> 01:00:55.154
It's good to know it by name.
It's sort of like linearity of

01:00:55.154 --> 01:00:58.476
expectations.
It's a lot easier to

01:00:58.476 --> 01:01:03.978
communicate to someone.
Linearity of expectations:

01:01:03.978 --> 01:01:07.554
instead of saying,
you know that thing where you

01:01:07.554 --> 01:01:11.510
sum up all the expectations of
things, and that's the

01:01:11.510 --> 01:01:15.086
expectation of the sum?
It's a lot easier to say

01:01:15.086 --> 01:01:18.815
linearity of expectation.
So, let me quiz you in a

01:01:18.815 --> 01:01:21.706
different way.
So, if I take a bunch of

01:01:21.706 --> 01:01:26.119
events, and I take their union,
either this happens or this

01:01:26.119 --> 01:01:29.847
happens, or so on.
So, this is the inclusive OR of

01:01:29.847 --> 01:01:31.521
k events.
And, instead,

01:01:31.521 --> 01:01:37.000
I look at the sum of the
probabilities of those events.

01:01:37.000 --> 01:01:40.111
OK, easy question:
are these equal?

01:01:40.111 --> 01:01:42.947
No, unless they are
independent.

01:01:42.947 --> 01:01:47.248
But can I say anything about
them, any relation?

01:01:47.248 --> 01:01:51.183
Smaller, yeah.
This is less than or equal to

01:01:51.183 --> 01:01:54.477
that.
OK, this should be intuitive to

01:01:54.477 --> 01:01:57.771
you from a probability point of
view.

01:01:57.771 --> 01:02:01.705
Look at the textbook.
OK: very basic result,

01:02:01.705 --> 01:02:07.041
trivial result almost.
What does this tell us?

01:02:07.041 --> 01:02:11.479
Well, suppose that E_i is some
kind of error event.

01:02:11.479 --> 01:02:15.295
We don't want it to happen.
OK, and suppose,

01:02:15.295 --> 01:02:19.467
mix some letters here.
Suppose I have a bunch of

01:02:19.467 --> 01:02:23.017
events which occur with high
probability.

01:02:23.017 --> 01:02:26.745
OK, call those E_i complement.
So, suppose,

01:02:26.745 --> 01:02:31.893
so this is the end of that
statement, E_i complement occurs

01:02:31.893 --> 01:02:37.063
with high probability.
OK, so then the probability of

01:02:37.063 --> 01:02:39.609
E_i is very small,
polynomially small.

01:02:39.609 --> 01:02:42.636
One over n to the alpha for any
alpha I want.

01:02:42.636 --> 01:02:46.007
Now, suppose I take a whole
bunch of these events,

01:02:46.007 --> 01:02:48.690
and let's say that k is
polynomial in n.

01:02:48.690 --> 01:02:52.405
So, I take a bunch of events,
which I'd like to happen.

01:02:52.405 --> 01:02:54.882
They all occur with high
probability.

01:02:54.882 --> 01:02:57.565
There is only polynomially many
of them.

01:02:57.565 --> 01:03:00.316
So let's say,
let me give this constant a

01:03:00.316 --> 01:03:03.000
name.
Let's call it c.

01:03:03.000 --> 01:03:05.873
Let's say I take n to the c
such events.

01:03:05.873 --> 01:03:09.926
Well, what's the probability
that all those events occur

01:03:09.926 --> 01:03:12.873
together?
Because they should rest of the

01:03:12.873 --> 01:03:17.073
time occurred together because
each one occurs most of the

01:03:17.073 --> 01:03:19.578
time, occurs with high
probability.

01:03:19.578 --> 01:03:23.115
So, I want to look at E_1 bar
intersect, E_2 bar,

01:03:23.115 --> 01:03:25.842
and so on.
So, each of these occurs as

01:03:25.842 --> 01:03:29.378
high probability.
What's the chance that they all

01:03:29.378 --> 01:03:32.166
occur?
It's also with high

01:03:32.166 --> 01:03:34.316
probability.
I'm changing the alpha.

01:03:34.316 --> 01:03:37.817
So, the union bound tells me
the probability of any one of

01:03:37.817 --> 01:03:40.090
these failing,
the probability of this

01:03:40.090 --> 01:03:42.608
failing, or this failing,
or this failing,

01:03:42.608 --> 01:03:44.573
which is this thing,
is, at most,

01:03:44.573 --> 01:03:47.276
the sum of the probabilities of
each failure.

01:03:47.276 --> 01:03:49.303
These are the error
probabilities.

01:03:49.303 --> 01:03:52.619
I know that each of them is,
at most, one over n to the

01:03:52.619 --> 01:03:55.875
alpha, with a constant in front.
If I add them all up,

01:03:55.875 --> 01:03:57.779
there's only n to the c of
them.

01:03:57.779 --> 01:04:01.034
So, I take this error
probability, and I multiply by n

01:04:01.034 --> 01:04:05.400
to the c.
So, I get like n to the c over

01:04:05.400 --> 01:04:08.679
n to the alpha,
which is one over n to the

01:04:08.679 --> 01:04:11.960
alpha minus c.
I can set alpha as big as I

01:04:11.960 --> 01:04:13.880
want.
So, I said it much,

01:04:13.880 --> 01:04:17.880
much bigger than c,
and this event occurs with high

01:04:17.880 --> 01:04:21.000
probability.
I sort of made a mess here,

01:04:21.000 --> 01:04:25.719
but this event occurs with high
probability because of this.

01:04:25.719 --> 01:04:30.599
Whatever the constant is here,
however many events I'm taking,

01:04:30.599 --> 01:04:35.000
I just set alpha to be bigger
than that.

01:04:35.000 --> 01:04:37.951
And, this event will occur with
high probability,

01:04:37.951 --> 01:04:40.041
too.
So, when I say here that every

01:04:40.041 --> 01:04:42.992
search of cost order log n with
high probability,

01:04:42.992 --> 01:04:46.005
not only do I mean that if you
look at one search,

01:04:46.005 --> 01:04:48.587
it costs order log n with high
probability.

01:04:48.587 --> 01:04:51.969
You look at another search,
and it costs log n with high

01:04:51.969 --> 01:04:54.244
probability.
I mean, if you take every

01:04:54.244 --> 01:04:57.318
search, all of them take order
log n time with high

01:04:57.318 --> 01:04:59.593
probability.
So, this event that every

01:04:59.593 --> 01:05:03.036
single search you do takes order
log n, is true with high

01:05:03.036 --> 01:05:06.663
probability estimate the number
of searches you are doing is

01:05:06.663 --> 01:05:10.887
polynomial in n.
So, I'm assuming that I'm not

01:05:10.887 --> 01:05:14.467
using this data structure
forever, just for a polynomial

01:05:14.467 --> 01:05:17.136
amount of time.
But, who's got more than a

01:05:17.136 --> 01:05:19.218
polynomial amount of time
anyway?

01:05:19.218 --> 01:05:21.757
This is MIT.
So, hopefully that's clear.

01:05:21.757 --> 01:05:24.035
We'll see it a few more times.
Yeah?

01:05:24.035 --> 01:05:26.443
The algorithm doesn't depend on
Alpha.

01:05:26.443 --> 01:05:31.000
The question is how do you
choose alpha in the algorithm.

01:05:31.000 --> 01:05:33.925
So, we don't need to.
This is just sort of for an

01:05:33.925 --> 01:05:36.668
analysis tool.
This is saying that the farther

01:05:36.668 --> 01:05:39.838
out you get, so you say,
well, what's the probability

01:05:39.838 --> 01:05:43.190
that more than ten log n.
Well, it's like one over n^10.

01:05:43.190 --> 01:05:46.238
Let's say it's linear.
Well, what's the chance that

01:05:46.238 --> 01:05:49.407
you're more than 20 log n?
Well that's one over n^20.

01:05:49.407 --> 01:05:52.942
So, the point is the tail of
this distribution is getting a

01:05:52.942 --> 01:05:54.466
really small,
really fast.

01:05:54.466 --> 01:05:57.758
And, such using alpha is more
like sort of for your own

01:05:57.758 --> 01:06:00.135
feeling good.
OK, you can set it to 100,

01:06:00.135 --> 01:06:05.209
and then n is at least two.
So, that's like one over 2^100

01:06:05.209 --> 01:06:08.082
chance that you fail.
That's damn small.

01:06:08.082 --> 01:06:11.322
If you've got a real random
number generator,

01:06:11.322 --> 01:06:15.668
the chance that you're going to
hit one over 2^200 is pretty

01:06:15.668 --> 01:06:18.762
tiny, right?
So, let's say you set alpha to

01:06:18.762 --> 01:06:21.266
256, which is always a good
number.

01:06:21.266 --> 01:06:25.759
2^256 is much bigger than the
number of particles in the known

01:06:25.759 --> 01:06:29.000
universe, so,
the light matter.

01:06:29.000 --> 01:06:32.898
So, actually I think this even
accounts for some notion of dark

01:06:32.898 --> 01:06:34.533
matter.
So, this is really,

01:06:34.533 --> 01:06:37.615
really, really big.
So, the chance that you pick a

01:06:37.615 --> 01:06:41.576
random particle in the universe
that happens to be your favorite

01:06:41.576 --> 01:06:45.161
particle, this one right here,
that's over one over 2^256,

01:06:45.161 --> 01:06:47.487
or even smaller.
So, set alpha to 256,

01:06:47.487 --> 01:06:51.260
the chance to your algorithm
takes more than order log n time

01:06:51.260 --> 01:06:54.907
is a lot smaller than the chance
that a meteor strikes your

01:06:54.907 --> 01:06:58.680
computer at the same time that
it has a flooding point error,

01:06:58.680 --> 01:07:02.642
at the same time that the earth
explodes because they're putting

01:07:02.642 --> 01:07:06.415
a transport through this part of
the solar system at the same

01:07:06.415 --> 01:07:08.113
time, I mean,
I could go on,

01:07:08.113 --> 01:07:10.752
right?
It's really,

01:07:10.752 --> 01:07:13.510
really unlikely that you are
more than log n.

01:07:13.510 --> 01:07:15.705
And how unlikely:
you get to choose.

01:07:15.705 --> 01:07:19.467
But it's just in the analysis
the algorithm doesn't depend on

01:07:19.467 --> 01:07:21.159
it.
It's the same algorithm,

01:07:21.159 --> 01:07:23.040
very cool.
Sometimes, with high

01:07:23.040 --> 01:07:25.297
probability, bounds depends on
alpha.

01:07:25.297 --> 01:07:27.680
I mean, the algorithm depends
on alpha.

01:07:27.680 --> 01:07:32.307
But here, it will not.
OK, away we go.

01:07:32.307 --> 01:07:37.692
So now you all understand the
claim.

01:07:37.692 --> 01:07:45.384
So let's do a warm up.
We will also need this fact.

01:07:45.384 --> 01:07:52.769
But it's pretty easy.
The lemma is that with high

01:07:52.769 --> 01:08:01.692
probability, the number of
levels in the skip list is order

01:08:01.692 --> 01:08:06.266
log n.
I think it's order log n,

01:08:06.266 --> 01:08:09.349
certainly.
So, how do we prove that

01:08:09.349 --> 01:08:12.613
something happens with high
probably?

01:08:12.613 --> 01:08:18.144
Compute the probability that it
happened; show that it's high.

01:08:18.144 --> 01:08:22.677
Even if you don't know what
high probability means,

01:08:22.677 --> 01:08:26.122
in fact, I used to ask that
earlier on.

01:08:26.122 --> 01:08:30.746
So, let's compute the chance
that it doesn't happen,

01:08:30.746 --> 01:08:35.551
the error probability,
because that's just a one minus

01:08:35.551 --> 01:08:39.449
the cleaner.
So, I'd like to say,

01:08:39.449 --> 01:08:42.710
let's say, that it's,
at most, c log n levels.

01:08:42.710 --> 01:08:46.115
So, what's the error
probability for that event?

01:08:46.115 --> 01:08:50.028
This is sort of an event.
I'll put it in squiggles just

01:08:50.028 --> 01:08:53.000
for, all set.
This is the probability that

01:08:53.000 --> 01:08:56.260
they are strictly greater than c
log n levels.

01:08:56.260 --> 01:09:00.173
So, I want to say that that
probability is particularly

01:09:00.173 --> 01:09:04.683
small, polynomially small.
Well, how do I make levels?

01:09:04.683 --> 01:09:07.552
When I insert an element,
the probability half,

01:09:07.552 --> 01:09:09.984
it goes up.
And, the number of levels in

01:09:09.984 --> 01:09:13.726
the skip list is the max over
all the elements of how high it

01:09:13.726 --> 01:09:15.035
goes up.
But, max, oh,

01:09:15.035 --> 01:09:17.779
that's a mess.
All right, you can compute the

01:09:17.779 --> 01:09:21.022
expectation of the max if you
have a bunch of unknown

01:09:21.022 --> 01:09:24.202
variables; there is expectation
there is a constant,

01:09:24.202 --> 01:09:26.759
and you take the max.
It's like log in and

01:09:26.759 --> 01:09:31.000
expectation, but we want a much
stronger statement.

01:09:31.000 --> 01:09:35.815
And, we have this Boole's
inequality that says I have a

01:09:35.815 --> 01:09:39.472
bunch of things,
polynomially many things.

01:09:39.472 --> 01:09:43.842
Let's say we have n items.
Each one independently,

01:09:43.842 --> 01:09:47.142
I don't even care if it's a
dependent.

01:09:47.142 --> 01:09:52.582
If it goes up more than c log
n, yeah, the number of levels is

01:09:52.582 --> 01:09:55.258
more than c log n.
So, this is,

01:09:55.258 --> 01:10:00.163
at most, and then I want to
know, do any of those events

01:10:00.163 --> 01:10:03.017
happen for any of the n
elements?

01:10:03.017 --> 01:10:06.762
So, I just multiplied by n.
It's certainly,

01:10:06.762 --> 01:10:10.597
at most, n times the
probability that x gets

01:10:10.597 --> 01:10:15.502
promoted, this much here,
greater than or equal to log n

01:10:15.502 --> 01:10:18.734
times.
OK, if I pick,

01:10:18.734 --> 01:10:21.041
for any element,
x, because it's the same for

01:10:21.041 --> 01:10:23.191
each element.
They are done independently.

01:10:23.191 --> 01:10:26.179
So, I'm just summing over x
here, and that's just a factor

01:10:26.179 --> 01:10:26.756
of n.
Clear?

01:10:26.756 --> 01:10:29.588
This is Boole's inequality.
Now, what's the probability

01:10:29.588 --> 01:10:32.000
that x gets promoted c log n
times?

01:10:32.000 --> 01:10:36.646
We did this before for log n.
It was one over n.

01:10:36.646 --> 01:10:40.305
For c log n,
it's one over n to the c.

01:10:40.305 --> 01:10:44.161
OK, this is n times two.
Let's be nicer:

01:10:44.161 --> 01:10:47.324
one half to the power of c log
n.

01:10:47.324 --> 01:10:53.257
One half to the power of c log
n is one over two to the c log

01:10:53.257 --> 01:10:55.926
n.
The log n comes out here,

01:10:55.926 --> 01:10:58.991
becomes an n.
We get n to the c.

01:10:58.991 --> 01:11:05.022
So, this is n divided by n to
the c, which is n to the c minus

01:11:05.022 --> 01:11:09.904
one.
And, I get to choose c to be

01:11:09.904 --> 01:11:14.676
whatever I want.
So, I choose c minus one to be

01:11:14.676 --> 01:11:17.477
alpha.
I think exactly that.

01:11:17.477 --> 01:11:21.626
Oh, sorry, one over n to the c
minus one.

01:11:21.626 --> 01:11:24.634
Thank you.
It better be small.

01:11:24.634 --> 01:11:30.236
This is an upper bound.
So, probability is polynomially

01:11:30.236 --> 01:11:32.956
small.
I get to choose,

01:11:32.956 --> 01:11:36.484
and this is a bit of the trik.
I'm choosing this constant to

01:11:36.484 --> 01:11:38.397
be large, large enough for
alpha.

01:11:38.397 --> 01:11:40.610
The point is,
as c grows, alpha grows.

01:11:40.610 --> 01:11:43.480
Therefore, I can set alpha to
be whatever I want,

01:11:43.480 --> 01:11:46.290
set c accordingly.
So, there's a little bit more

01:11:46.290 --> 01:11:49.459
words that have to go here.
But, they're in the notes.

01:11:49.459 --> 01:11:51.851
I can set alpha to be as large
as I want.

01:11:51.851 --> 01:11:55.199
So, I can make this probability
as small as I want in the

01:11:55.199 --> 01:11:56.993
polynomial sets.
So, that's it.

01:11:56.993 --> 01:11:58.727
Number of levels,
order log n:

01:11:58.727 --> 01:12:02.224
wasn't that easy?
Rules and equality,

01:12:02.224 --> 01:12:06.026
the point is that when you're
dealing with high probability,

01:12:06.026 --> 01:12:09.377
use Boole's inequality.
And, anything that's true for

01:12:09.377 --> 01:12:12.664
one element is true for all of
them, just like that.

01:12:12.664 --> 01:12:15.886
Just lose a factor of n,
but that's just one in the

01:12:15.886 --> 01:12:18.271
alpha, and alpha is big:
big constant,

01:12:18.271 --> 01:12:21.106
but it's big.
OK, so let's prove the theorem.

01:12:21.106 --> 01:12:23.813
High probability searches cost
order log n.

01:12:23.813 --> 01:12:27.422
We now know the height is order
log n, but it depends how

01:12:27.422 --> 01:12:32.756
balanced this thing is.
It depends how long the chains

01:12:32.756 --> 01:12:36.800
are to really know that a search
costs log n.

01:12:36.800 --> 01:12:41.210
Just knowing a bound on the
height is not enough,

01:12:41.210 --> 01:12:45.805
unlike a binary tree.
So, we have one cool idea for

01:12:45.805 --> 01:12:49.389
this analysis.
And it's called backwards

01:12:49.389 --> 01:12:52.697
analysis.
So, normally you think of a

01:12:52.697 --> 01:12:58.210
search as starting in the top
left corner going left and down

01:12:58.210 --> 01:13:04.000
until you get to the item that
you're looking for.

01:13:04.000 --> 01:13:07.423
I'm going to look at the
reverse process.

01:13:07.423 --> 01:13:12.558
You start at the item you're
looking for, and you go left and

01:13:12.558 --> 01:13:15.896
up until you get to the top left
corner.

01:13:15.896 --> 01:13:20.175
The number of steps in those
two walks is the same.

01:13:20.175 --> 01:13:23.855
And, I'm not implementing an
algorithm here,

01:13:23.855 --> 01:13:27.792
I'm just doing analysis.
So, those are the same

01:13:27.792 --> 01:13:32.671
processes, just in reverse.
So, here's what it looks like.

01:13:32.671 --> 01:13:35.409
You have a search,
and it starts,

01:13:35.409 --> 01:13:42.000
which really means that it ends
at a node in the bottom list.

01:13:42.000 --> 01:13:46.845
Then, each time you visit a
node in this search,

01:13:46.845 --> 01:13:52.618
you either go left or up.
And, when do you go left or up?

01:13:52.618 --> 01:13:56.639
Well, it depends with the coin
flip was.

01:13:56.639 --> 01:14:02.000
So, if the node wasn't promoted
at this level.

01:14:02.000 --> 01:14:08.317
So, if it wasn't promoted
higher, and that happened

01:14:08.317 --> 01:14:14.003
exactly when we got a tails.
Then, we go left,

01:14:14.003 --> 01:14:19.057
which really means we came from
the left.

01:14:19.057 --> 01:14:25.754
Or, if we got a heads,
so if this node was promoted to

01:14:25.754 --> 01:14:31.440
the next level,
which happened whenever we got

01:14:31.440 --> 01:14:37.000
a heads at that particular
moment.

01:14:37.000 --> 01:14:42.860
This is in the past some time
when we did the insertion.

01:14:42.860 --> 01:14:45.844
Then we go, or came from,
up.

01:14:45.844 --> 01:14:51.704
And, we stop at the root.
This is really where we start;

01:14:51.704 --> 01:14:55.967
same thing.
So, either at the root or I'm

01:14:55.967 --> 01:15:03.000
also going to think of this as
stopping at minus infinity.

01:15:03.000 --> 01:15:05.562
OK, that was a bit messy,
but let me review.

01:15:05.562 --> 01:15:08.602
So, normally we start up here.
Well, just looking at

01:15:08.602 --> 01:15:11.344
everything backwards,
and in brackets is what's

01:15:11.344 --> 01:15:13.966
really happening.
So, this search ends at the

01:15:13.966 --> 01:15:17.364
node you were looking for.
It's always in the bottom list.

01:15:17.364 --> 01:15:19.807
Then it says,
well, was this node promoted

01:15:19.807 --> 01:15:21.953
higher?
If it was, I came from above.

01:15:21.953 --> 01:15:25.410
If not, I came to the left.
It must have been in the bottom

01:15:25.410 --> 01:15:28.033
chain somewhere.
OK, and that's true at every

01:15:28.033 --> 01:15:31.870
node you visit.
It depends whether that quite

01:15:31.870 --> 01:15:35.806
slipped heads or tails at the
time that you inserted that node

01:15:35.806 --> 01:15:38.774
into that level.
But, these are just a bunch of

01:15:38.774 --> 01:15:40.774
events.
I'm just going to check,

01:15:40.774 --> 01:15:44.258
what is the probability that
its heads, and what is the

01:15:44.258 --> 01:15:47.096
probability that a tails?
It's always a half.

01:15:47.096 --> 01:15:50.516
Every time I look at a coin
flip, when it was flipped,

01:15:50.516 --> 01:15:54.000
there was a probability of half
going out of their way.

01:15:54.000 --> 01:15:56.967
That's the magic.
And, I'm not using that these

01:15:56.967 --> 01:16:02.248
events are independent anyway.
For every element that I search

01:16:02.248 --> 01:16:05.584
for, for every value,
x, that's another search.

01:16:05.584 --> 01:16:08.123
Those events may not be
independent.

01:16:08.123 --> 01:16:12.112
I can still use Boole's
inequality and conclude that all

01:16:12.112 --> 01:16:15.375
of them are order log n with
high probability.

01:16:15.375 --> 01:16:19.582
As long as I can prove that any
one event happens with high

01:16:19.582 --> 01:16:22.556
probability.
So, I don't need independence

01:16:22.556 --> 01:16:26.835
between, I knew that these coin
flips in a single search are

01:16:26.835 --> 01:16:30.969
independent, but everything
else, for different searches I

01:16:30.969 --> 01:16:35.803
don't care.
So, how long can this process

01:16:35.803 --> 01:16:39.283
go on?
We want to know how many times

01:16:39.283 --> 01:16:44.310
can I make this walk?
Well, when I hit the root node,

01:16:44.310 --> 01:16:47.983
I'm done.
Well, how quickly would I hit

01:16:47.983 --> 01:16:51.560
the root node?
Well, with probability,

01:16:51.560 --> 01:16:57.069
a half, I go up each step.
The number of times I go up is,

01:16:57.069 --> 01:17:02.000
at most, the number of levels
minus one.

01:17:02.000 --> 01:17:05.410
And that's order log n with
high probability.

01:17:05.410 --> 01:17:07.813
So, this is the only other
idea.

01:17:07.813 --> 01:17:10.682
So, we are now improving this
theorem.

01:17:10.682 --> 01:17:15.333
So, the number of up moves in a
search, which are really down

01:17:15.333 --> 01:17:19.054
moves, but same thing,
is less than the number of

01:17:19.054 --> 01:17:22.000
levels.
Certainly, you can't go up more

01:17:22.000 --> 01:17:24.713
than there are levels in the
search.

01:17:24.713 --> 01:17:27.968
And in insert,
you can go arbitrarily high.

01:17:27.968 --> 01:17:32.000
But a search:
as high as you can go.

01:17:32.000 --> 01:17:34.821
And this is,
at most, c log n with high

01:17:34.821 --> 01:17:37.866
probability.
This is what we proved in the

01:17:37.866 --> 01:17:40.242
lemma.
So, we have a bound on the

01:17:40.242 --> 01:17:42.990
number of up moves.
Half of the moves,

01:17:42.990 --> 01:17:45.440
roughly, are going to be up
moves.

01:17:45.440 --> 01:17:49.004
So, this pretty much down to
the number of moves.

01:17:49.004 --> 01:17:51.752
Not quite.
So, what this means is that

01:17:51.752 --> 01:17:54.797
with high probability,
so this is the same

01:17:54.797 --> 01:17:58.955
probability, but I could choose
that as high as I want by

01:17:58.955 --> 01:18:03.553
setting c large enough.
The number of moves,

01:18:03.553 --> 01:18:06.893
in other words,
the cost of the search is at

01:18:06.893 --> 01:18:11.320
most the number of coin flips
until we get c long n heads,

01:18:11.320 --> 01:18:15.747
right, because in every step of
the search, I make a move,

01:18:15.747 --> 01:18:19.009
and then I flip another coin,
conceptually.

01:18:19.009 --> 01:18:22.504
There is another independent
coin lying there.

01:18:22.504 --> 01:18:27.165
And it's either heads or tails.
Each of those is independent.

01:18:27.165 --> 01:18:31.902
So, how many independent coin
flips does it take until I get c

01:18:31.902 --> 01:18:37.206
log n heads?
The claim is that that's order

01:18:37.206 --> 01:18:42.979
log n with high probability.
But we need to prove that.

01:18:42.979 --> 01:18:48.324
So, this is a claim.
So, if you just sit there with

01:18:48.324 --> 01:18:55.058
a coin, and you want to know how
many times does it take until I

01:18:55.058 --> 01:19:00.082
get c log n heads,
the claim is that that number

01:19:00.082 --> 01:19:05.000
is order log n with high
probability.

01:19:05.000 --> 01:19:08.595
As long as I prove that,
I know that the total number of

01:19:08.595 --> 01:19:11.276
steps I make,
which is the number of heads

01:19:11.276 --> 01:19:15.394
and tails is order log n because
I definitely know the number of

01:19:15.394 --> 01:19:17.094
heads is, at most,
c log n.

01:19:17.094 --> 01:19:21.147
The claim is that the number of
tails can't be too much bigger.

01:19:21.147 --> 01:19:23.174
Notice, I can't just say c
here.

01:19:23.174 --> 01:19:25.985
OK, it's really important that
I have log n.

01:19:25.985 --> 01:19:28.208
Why?
Because with high probability,

01:19:28.208 --> 01:19:32.000
it depends on n.
This notion depends on n.

01:19:32.000 --> 01:19:35.434
Log n: it's true.
Anything bigger that log n:

01:19:35.434 --> 01:19:38.087
it's true, like n.
If I put n here,

01:19:38.087 --> 01:19:41.756
this is also true.
But, if I put a constant or a

01:19:41.756 --> 01:19:46.126
log log n, this is not true.
It's really important that I

01:19:46.126 --> 01:19:50.185
have log n here because my
notion of high probability

01:19:50.185 --> 01:19:54.321
depends on what's written here.
OK, it's clear so far.

01:19:54.321 --> 01:19:57.912
We're almost done,
which is good because I just

01:19:57.912 --> 01:20:01.190
ran out of time.
Sorry, we're going to go a

01:20:01.190 --> 01:20:07.528
couple minutes over.
So, I want to compute the error

01:20:07.528 --> 01:20:12.308
probability here.
So, I want to compute the

01:20:12.308 --> 01:20:17.886
probability that there is less
than c log n heads.

01:20:17.886 --> 01:20:23.691
Let me skip this step.
So, I will be approximate and

01:20:23.691 --> 01:20:29.382
say, what's the probability that
there is, at most,

01:20:29.382 --> 01:20:33.923
c log n heads?
So, I need to say how many

01:20:33.923 --> 01:20:37.549
coins we are flipping here for
what this event is.

01:20:37.549 --> 01:20:40.139
So, I need to specify this
constant.

01:20:40.139 --> 01:20:42.729
Let's say we flip ten c log n
coins.

01:20:42.729 --> 01:20:47.169
Now I want to look at the error
probability under that event.

01:20:47.169 --> 01:20:51.312
The probability that there is
at most c log n heads among

01:20:51.312 --> 01:20:55.382
those ten c log n flips.
So, the claim is this should be

01:20:55.382 --> 01:20:58.416
pretty small.
It's going to depend on ten.

01:20:58.416 --> 01:21:01.672
Then I'll choose ten to be
arbitrarily large,

01:21:01.672 --> 01:21:05.076
and I'll be done,
OK, make my life a little bit

01:21:05.076 --> 01:21:10.054
easier.
Well, I would ask you normally,

01:21:10.054 --> 01:21:15.770
but this is 6.042 material.
So, what's the probability that

01:21:15.770 --> 01:21:19.021
we have, at most,
this many heads?

01:21:19.021 --> 01:21:23.653
Well, that means that nine c
log n of the coins,

01:21:23.653 --> 01:21:29.368
because there are ten c log n
flips, c log n heads at most,

01:21:29.368 --> 01:21:34.000
nine c log n at least better be
tails.

01:21:34.000 --> 01:21:37.149
So this is the probability that
all those other guys become

01:21:37.149 --> 01:21:39.104
tails, which is already pretty
small.

01:21:39.104 --> 01:21:41.330
And then, there is this
permutation thing.

01:21:41.330 --> 01:21:44.533
So, if I had exactly c log n
heads, this would be the number

01:21:44.533 --> 01:21:47.574
of ways to rearrange c log n
heads among ten c log n coin

01:21:47.574 --> 01:21:49.475
flips.
OK, that's just the number of

01:21:49.475 --> 01:21:51.375
permutations.
So, this is a bit big,

01:21:51.375 --> 01:21:53.601
which is kind of annoying.
This is really,

01:21:53.601 --> 01:21:55.665
really small.
The claim is this is much

01:21:55.665 --> 01:21:58.000
smaller than that is big.

01:22:14.000 --> 01:22:18.548
So, this is just some math.
I'm going to whiz through it.

01:22:18.548 --> 01:22:21.390
So, you don't have to stay too
long.

01:22:21.390 --> 01:22:26.020
But you should go over it.
You should know that y choose x

01:22:26.020 --> 01:22:30.000
is, at most, ey over x to the x,
good fact.

01:22:30.000 --> 01:22:35.033
Therefore, this is,
at most, ten c log n over c log

01:22:35.033 --> 01:22:38.456
n, also known as ten.
These cancel.

01:22:38.456 --> 01:22:43.691
There's an e out here.
And then I raise that to the c

01:22:43.691 --> 01:22:48.020
log n power.
OK, then I divide by two to the

01:22:48.020 --> 01:22:51.946
power, nine c log n.
OK, so what's this?

01:22:51.946 --> 01:22:57.986
This is e times ten to the c
log n divided by two to the nine

01:22:57.986 --> 01:23:02.355
c log n.
OK, claim this is very big.

01:23:02.355 --> 01:23:06.367
This is not so big,
because I have a nine here.

01:23:06.367 --> 01:23:09.769
So, let's work it out.
This e times ten,

01:23:09.769 --> 01:23:13.345
that's a good number,
we can put upstairs.

01:23:13.345 --> 01:23:17.096
So, we get log of e times ten,
ten times, e,

01:23:17.096 --> 01:23:21.109
and then c log n.
And then, we have over two to

01:23:21.109 --> 01:23:25.121
the nine c log n.
So, we have this two to the c

01:23:25.121 --> 01:23:31.946
log n in both cases.
So, this is two to the log,

01:23:31.946 --> 01:23:38.669
ten e minus nine,
c, log n: some basic algebra.

01:23:38.669 --> 01:23:43.199
So, I'm going to set,
not quite.

01:23:43.199 --> 01:23:49.338
This is one over two to the
nine minus log:

01:23:49.338 --> 01:23:58.253
so, just inverting everything
here, negating the sign in here.

01:23:58.253 --> 01:24:06.000
And, this is my alpha because
the rest is n.

01:24:06.000 --> 01:24:09.903
So, this is one over n to the
alpha when alpha is this

01:24:09.903 --> 01:24:13.291
particular value:
nine minus log of ten times e

01:24:13.291 --> 01:24:16.090
times c.
It's a bit of a strange thing.

01:24:16.090 --> 01:24:19.184
But, the point is,
as ten goes to infinity,

01:24:19.184 --> 01:24:22.424
nine here is the number one
smaller than ten,

01:24:22.424 --> 01:24:24.855
right?
We subtracted one somewhere

01:24:24.855 --> 01:24:27.949
along the way.
So, as ten goes to infinity,

01:24:27.949 --> 01:24:32.000
this is basically,
this is ten minus one.

01:24:32.000 --> 01:24:35.100
This is log of ten times e.
e doesn't really matter.

01:24:35.100 --> 01:24:37.531
The point is,
this is logarithmic in ten.

01:24:37.531 --> 01:24:40.692
This is linear in ten.
The thing that's linear in ten

01:24:40.692 --> 01:24:44.035
is much bigger than the thing
that's logarithmic in ten.

01:24:44.035 --> 01:24:45.919
This is called abusive
notation.

01:24:45.919 --> 01:24:48.958
OK, as ten goes to infinity,
this goes to infinity,

01:24:48.958 --> 01:24:51.329
gets bigger.
And, there is a c out here.

01:24:51.329 --> 01:24:54.794
But, for any value of c that
you want, whatever value of c

01:24:54.794 --> 01:24:58.015
you wanted in that claim,
I can make alpha arbitrarily

01:24:58.015 --> 01:25:00.629
large by changing the constant
in the big O,

01:25:00.629 --> 01:25:04.812
which here was ten.
OK, so that claim is true with

01:25:04.812 --> 01:25:07.652
high probability.
Whatever probability you want,

01:25:07.652 --> 01:25:10.673
which tells you alpha,
you set a constant effort of

01:25:10.673 --> 01:25:13.089
the log N to be this number,
which grows,

01:25:13.089 --> 01:25:15.929
and you're done.
You get the claim that is order

01:25:15.929 --> 01:25:19.312
log N heads, order log N flips
with the high probability,

01:25:19.312 --> 01:25:21.548
therefore.
[None of the steps?] in the

01:25:21.548 --> 01:25:24.146
search is order log N with high
probability.

01:25:24.146 --> 01:25:26.140
Really cool stuff;
read the notes.

01:25:26.140 --> 01:25:28.206
Sorry I went so fast at the
end.

