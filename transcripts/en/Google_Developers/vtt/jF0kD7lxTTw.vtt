WEBVTT
Kind: captions
Language: en

00:00:01.300 --> 00:00:02.374
FAISAL ABID: All right.

00:00:02.374 --> 00:00:03.290
Everyone hear me well?

00:00:03.290 --> 00:00:05.390
Good, awesome.

00:00:05.390 --> 00:00:07.790
Thank you for
coming after lunch.

00:00:07.790 --> 00:00:09.290
I know everyone
just wants to sleep.

00:00:09.290 --> 00:00:11.930
So do I. So "From Zero to One--

00:00:11.930 --> 00:00:13.722
Building a Real World
Flutter Application."

00:00:13.722 --> 00:00:15.679
What you'll learn about
me throughout this talk

00:00:15.679 --> 00:00:16.446
is I'm super lazy.

00:00:16.446 --> 00:00:18.320
I'm so lazy that I took
the title of the talk

00:00:18.320 --> 00:00:20.060
from that Peter Thiel book.

00:00:20.060 --> 00:00:22.490
And so I'm, like, whatever,
I just need a good title--

00:00:22.490 --> 00:00:23.610
"From Zero to One."

00:00:23.610 --> 00:00:27.230
So this talk is really about me
building a real world Flutter

00:00:27.230 --> 00:00:29.050
application in record time--

00:00:29.050 --> 00:00:30.890
really, five days.

00:00:30.890 --> 00:00:32.870
And the application is
actually pretty big.

00:00:32.870 --> 00:00:35.100
It has about 500,000 users.

00:00:35.100 --> 00:00:37.640
And so I said, let's
build it in Flutter.

00:00:37.640 --> 00:00:40.112
And we'll find out why and how
I built it really quickly--

00:00:40.112 --> 00:00:40.820
because I'm lazy.

00:00:40.820 --> 00:00:42.520
I use a lot of libraries.

00:00:42.520 --> 00:00:46.019
So yes, I just talked
about the first part.

00:00:46.019 --> 00:00:47.810
Second part is the
architecture of the app.

00:00:47.810 --> 00:00:49.810
I'm going to spend about
two minutes on it, just

00:00:49.810 --> 00:00:51.620
a high level overview
of how the app looks.

00:00:51.620 --> 00:00:53.720
And then we'll go
through each section

00:00:53.720 --> 00:00:55.760
and talk about the tips
and tricks I learned

00:00:55.760 --> 00:00:59.030
from building that
specific section

00:00:59.030 --> 00:01:03.050
and, really, which
libraries to use.

00:01:03.050 --> 00:01:04.195
So about me.

00:01:04.195 --> 00:01:06.530
This is my funniest
scene, who am I?

00:01:06.530 --> 00:01:09.110
I don't know.

00:01:09.110 --> 00:01:10.580
So who am I, really?

00:01:10.580 --> 00:01:13.430
I'm a Google Developer
expert in Dart and Flutter.

00:01:13.430 --> 00:01:15.921
I've been doing Dart
for a long, long time.

00:01:15.921 --> 00:01:18.170
I think I started Dart
probably like two years after--

00:01:18.170 --> 00:01:19.940
or a year after--
it was released,

00:01:19.940 --> 00:01:23.060
mainly because I was tired
of just doing web stuff,

00:01:23.060 --> 00:01:25.220
and I just wanted to
do something else,

00:01:25.220 --> 00:01:26.660
aside JavaScript.

00:01:26.660 --> 00:01:28.940
And I really started
Dart from the server.

00:01:28.940 --> 00:01:31.150
And I started using Dart
on the server a lot--

00:01:31.150 --> 00:01:35.700
built this app in 2015, or
2014, in Dart, on the server.

00:01:35.700 --> 00:01:38.510
And it was really good, so I
just fell in love with Dart--

00:01:38.510 --> 00:01:40.340
started doing it on
the web, eventually,

00:01:40.340 --> 00:01:42.590
and then, now, with Flutter.

00:01:42.590 --> 00:01:44.180
I've been-- you know I wrote--

00:01:44.180 --> 00:01:47.540
anyone read Flutter for
Android on Flutter.io?

00:01:47.540 --> 00:01:48.650
Yes-- one, two.

00:01:48.650 --> 00:01:49.280
That was me.

00:01:49.280 --> 00:01:52.170
I wrote that in,
like, two months.

00:01:52.170 --> 00:01:54.512
So if you find spelling
mistakes, that's on me.

00:01:54.512 --> 00:01:56.720
I've been an Android developer
for a long time, which

00:01:56.720 --> 00:01:58.970
is very relevant,
because Flutter

00:01:58.970 --> 00:02:02.480
is a much better experience
for me as an Android developer.

00:02:02.480 --> 00:02:05.480
I've been doing Android since
M1, when Android didn't even

00:02:05.480 --> 00:02:07.500
have a keyboard,
believe it or not.

00:02:07.500 --> 00:02:11.150
So you just had to
have a hardware device.

00:02:11.150 --> 00:02:13.500
Anyone remember the G1 device?

00:02:13.500 --> 00:02:14.000
Yes.

00:02:14.000 --> 00:02:15.090
Yeah, this is Google--

00:02:15.090 --> 00:02:16.670
I'm sure.

00:02:16.670 --> 00:02:18.360
Obviously, you guys built it.

00:02:18.360 --> 00:02:18.860
And then.

00:02:18.860 --> 00:02:20.444
I'm also a Senior
Engineer at Zoom.ai.

00:02:20.444 --> 00:02:21.818
This is what I do
during the day.

00:02:21.818 --> 00:02:22.880
So I do a lot of things.

00:02:22.880 --> 00:02:25.140
I don't know how I have
time for any of this.

00:02:25.140 --> 00:02:27.762
Zoom.ai is an AI-based
automated assistant.

00:02:27.762 --> 00:02:29.720
That's all I'm going to
say about that for now.

00:02:29.720 --> 00:02:31.700
And outside of work,
I'm an entrepreneur,

00:02:31.700 --> 00:02:33.320
trying tons of different ideas.

00:02:33.320 --> 00:02:35.060
And this is why
Flutter is also good.

00:02:35.060 --> 00:02:36.200
I do a lot of mobile apps.

00:02:36.200 --> 00:02:38.570
I do a lot of web
stuff, backend stuff.

00:02:38.570 --> 00:02:41.210
And Dart and Flutter just help
me make stuff really quickly,

00:02:41.210 --> 00:02:42.040
try it out.

00:02:42.040 --> 00:02:43.550
Fail a million times.

00:02:43.550 --> 00:02:46.010
Get rich off a couple of them.

00:02:46.010 --> 00:02:49.530
So the one that made
some money is Ven Chat.

00:02:49.530 --> 00:02:51.860
I started it in 2015.

00:02:51.860 --> 00:02:54.230
It's one of the top 150
to 200 grossing apps,

00:02:54.230 --> 00:02:55.520
depending on the month.

00:02:55.520 --> 00:02:56.450
It's very variable.

00:02:56.450 --> 00:02:58.102
It has half a million installs.

00:02:58.102 --> 00:02:59.810
It's essentially a
chat app for singles--

00:02:59.810 --> 00:03:02.210
there's nothing
special about it--

00:03:02.210 --> 00:03:06.350
and it's built in Android
currently, with a Dart backend.

00:03:06.350 --> 00:03:09.650
And so where does
Flutter fit into this?

00:03:09.650 --> 00:03:12.589
Well, every time I look at stats
on apps making money-- anyone I

00:03:12.589 --> 00:03:14.630
talk to in the industry--
they're always talking,

00:03:14.630 --> 00:03:17.570
telling me about how iOS
is making a lot more money.

00:03:17.570 --> 00:03:20.610
Any app published in iOS
makes two times, three times

00:03:20.610 --> 00:03:21.110
the money.

00:03:21.110 --> 00:03:23.990
So I wanted to build an iOS app.

00:03:23.990 --> 00:03:25.940
The problem is I
don't have time.

00:03:25.940 --> 00:03:26.820
I have a day job.

00:03:26.820 --> 00:03:28.570
And I come home, and
I work on this stuff,

00:03:28.570 --> 00:03:29.600
or I'm trying new stuff.

00:03:29.600 --> 00:03:32.120
And I don't want
to build an iOS app

00:03:32.120 --> 00:03:35.120
and then maintain
two apps all at once.

00:03:35.120 --> 00:03:38.360
Because not only do I spend
three months building an iOS

00:03:38.360 --> 00:03:42.650
app, then I've got to spend the
rest of the app's life cycle

00:03:42.650 --> 00:03:45.260
maintaining new features in
iOS, maintaining new features

00:03:45.260 --> 00:03:46.040
in Android--

00:03:46.040 --> 00:03:47.840
doing the same thing
over and over again.

00:03:47.840 --> 00:03:48.860
It's a nightmare.

00:03:48.860 --> 00:03:49.860
I don't want to do that.

00:03:49.860 --> 00:03:52.250
That's how I feel whenever
I thought about doing iOS.

00:03:52.250 --> 00:03:54.440
And then Swift came
along, and I'm like, hmm,

00:03:54.440 --> 00:03:55.510
maybe I'll do Swift.

00:03:55.510 --> 00:03:58.070
Then I looked at it again,
and I'm like, no, forget that.

00:03:58.070 --> 00:03:59.570
I'm not doing that.

00:03:59.570 --> 00:04:02.211
So Flutter became the
obvious choice for me.

00:04:02.211 --> 00:04:03.710
A lot of people
say, well, you know,

00:04:03.710 --> 00:04:05.085
you still have to
write two apps.

00:04:05.085 --> 00:04:05.750
I'm like, yeah.

00:04:05.750 --> 00:04:09.690
But then I can use
iOS as a guinea pig--

00:04:09.690 --> 00:04:11.080
test the app on there--

00:04:11.080 --> 00:04:12.740
test the Flutter up on iOS--

00:04:12.740 --> 00:04:16.579
get all the bugs hammered out,
all the usability, whatever.

00:04:16.579 --> 00:04:19.626
And then just file
build on Android

00:04:19.626 --> 00:04:20.750
and get it published there.

00:04:20.750 --> 00:04:22.135
So it's a very seamless process.

00:04:22.135 --> 00:04:24.260
I don't want to touch my
revenue stream on Android.

00:04:24.260 --> 00:04:27.620
So it makes sense for me to
build an iOS Flutter app,

00:04:27.620 --> 00:04:29.480
test it out, and deploy.

00:04:29.480 --> 00:04:34.400
So that's how I feel I'll be
after I deploy the iOS app.

00:04:34.400 --> 00:04:37.550
So it just got submitted to
Apple for approval yesterday.

00:04:37.550 --> 00:04:40.190
Should be in stores soon.

00:04:40.190 --> 00:04:43.940
So let me give you a quick
demo of how the app is--

00:04:43.940 --> 00:04:44.690
very simple.

00:04:44.690 --> 00:04:48.230
What I did for the demo is--
because it's a chat app,

00:04:48.230 --> 00:04:52.100
I replaced all the pictures
with randomuser.me,

00:04:52.100 --> 00:04:54.170
and I recorded a video.

00:04:54.170 --> 00:04:55.520
I recorded a video here.

00:04:55.520 --> 00:04:57.265
All right, so here's the app.

00:04:57.265 --> 00:04:58.390
And this is all in Flutter.

00:04:58.390 --> 00:05:03.450
So this is running on iPhone
X, or via simulator iPhone X.

00:05:03.450 --> 00:05:07.500
And I'm just going to-- it's
like a 40 second preview.

00:05:07.500 --> 00:05:08.160
You can scroll.

00:05:08.160 --> 00:05:10.170
There's a bunch
of people there--

00:05:10.170 --> 00:05:12.510
that crazy guy over there.

00:05:12.510 --> 00:05:15.270
I can see the new members
that just recently joined.

00:05:15.270 --> 00:05:17.670
And then I can see a
list of all people that

00:05:17.670 --> 00:05:19.050
have sent me a message.

00:05:19.050 --> 00:05:20.620
I can click on a person--

00:05:20.620 --> 00:05:22.740
for example, this
person right here--

00:05:22.740 --> 00:05:24.170
and send them a message.

00:05:24.170 --> 00:05:24.690
Right?

00:05:24.690 --> 00:05:28.000
Simple, and that's about it.

00:05:28.000 --> 00:05:36.070
And so when I ended up building
this, the app was roughly 60%

00:05:36.070 --> 00:05:37.330
less code than Android.

00:05:37.330 --> 00:05:40.600
It does a lot, especially for a
single developer just building

00:05:40.600 --> 00:05:41.770
this in his free time.

00:05:41.770 --> 00:05:43.242
It was a lot less code.

00:05:43.242 --> 00:05:45.700
That's mainly because Flutter
just makes everything so much

00:05:45.700 --> 00:05:46.200
easier.

00:05:46.200 --> 00:05:48.250
Building list views
on Android, you've

00:05:48.250 --> 00:05:51.310
got to build up an adapter,
set up recycling, or doing

00:05:51.310 --> 00:05:52.660
all sorts of crazy stuff.

00:05:52.660 --> 00:05:55.660
On Flutter, I just pass
in an array into a list,

00:05:55.660 --> 00:05:57.040
and I'm good to go.

00:05:57.040 --> 00:05:58.374
And it really took me five days.

00:05:58.374 --> 00:06:00.706
After all that procrastination,
I'm like, you know what?

00:06:00.706 --> 00:06:01.990
I finally need to build this.

00:06:01.990 --> 00:06:05.050
I sat there, started building
it, and within 15 to 20 hours,

00:06:05.050 --> 00:06:06.190
I was done--

00:06:06.190 --> 00:06:08.770
five after-work days, so
that's like two hours a day

00:06:08.770 --> 00:06:11.320
or something, and I was done.

00:06:11.320 --> 00:06:15.910
That was me for a couple
of days, working away.

00:06:15.910 --> 00:06:18.520
And the architecture is
pretty simple for the app.

00:06:18.520 --> 00:06:20.170
We have a Websocket
that comes in,

00:06:20.170 --> 00:06:23.050
and that's really for all
the chat realtime stuff.

00:06:23.050 --> 00:06:25.115
We're not using
Firebase for realtime.

00:06:25.115 --> 00:06:26.740
That's because when
you send a message,

00:06:26.740 --> 00:06:30.310
it used to go to our server, do
a lot of spam analysis on it--

00:06:30.310 --> 00:06:32.710
tons of moderation
and everything--

00:06:32.710 --> 00:06:34.610
and then we send it to the user.

00:06:34.610 --> 00:06:36.400
And so we use a
Websocket for that.

00:06:36.400 --> 00:06:39.250
The Websocket then triggers
an event bus message,

00:06:39.250 --> 00:06:41.710
which is when you're
chatting with a member,

00:06:41.710 --> 00:06:42.520
a message comes in.

00:06:42.520 --> 00:06:44.740
You can start replying
to the member.

00:06:44.740 --> 00:06:47.590
And then, also, as you
chat, your points go down.

00:06:47.590 --> 00:06:48.940
So there's an in-app currency.

00:06:48.940 --> 00:06:50.620
You have a finite
amount of points

00:06:50.620 --> 00:06:52.630
before you have to buy
more points to track.

00:06:52.630 --> 00:06:56.332
And so the points are also being
pushed by Websocket, every--

00:06:56.332 --> 00:06:57.790
whenever you send
a message or when

00:06:57.790 --> 00:06:59.469
someone sends a message to you.

00:06:59.469 --> 00:07:01.510
And then, lastly, there's
a complicated REST API.

00:07:01.510 --> 00:07:05.170
There's like 40, 50 endpoints
there doing all sorts of stuff,

00:07:05.170 --> 00:07:11.200
from uploading pictures
to videos, audio clips,

00:07:11.200 --> 00:07:15.190
creating profiles,
downloading tons of data--

00:07:15.190 --> 00:07:16.640
lots and lots of stuff there.

00:07:16.640 --> 00:07:18.641
So I'll go through each
one of these pieces,

00:07:18.641 --> 00:07:20.140
and talk about the
challenges I face

00:07:20.140 --> 00:07:22.730
and how I solved
it in record time.

00:07:22.730 --> 00:07:24.100
The first one is Websockets.

00:07:24.100 --> 00:07:27.310
Like I said, Websockets allow
realtime chat between the user,

00:07:27.310 --> 00:07:29.290
the server and the user again.

00:07:29.290 --> 00:07:33.040
The problem was Websockets need
to be opened during the app.

00:07:33.040 --> 00:07:34.810
But when the app is
in the background,

00:07:34.810 --> 00:07:36.580
I need Websockets to stop.

00:07:36.580 --> 00:07:41.040
So on Android and iOS, there's
an on-resume, on-pause callback

00:07:41.040 --> 00:07:41.540
done.

00:07:41.540 --> 00:07:45.510
On Android, at least, I
used a Websocket stop.

00:07:45.510 --> 00:07:47.920
And then on the
on-pause and on-resume,

00:07:47.920 --> 00:07:50.240
I did websocket.start.

00:07:50.240 --> 00:07:52.505
I wanted to find something
similar in Flutter,

00:07:52.505 --> 00:07:56.380
and I did, thanks to
WidgetsBindingObserver--

00:07:56.380 --> 00:07:58.104
if everyone can see that code.

00:07:58.104 --> 00:07:59.770
The slides will be
up later too, but I'm

00:07:59.770 --> 00:08:01.260
going to quickly describe it.

00:08:01.260 --> 00:08:03.580
WidgetsBindingObserver
is a way for you

00:08:03.580 --> 00:08:05.740
to listen to your
application states,

00:08:05.740 --> 00:08:07.160
and this was perfect for me.

00:08:07.160 --> 00:08:09.730
So what I did was I set up
a WidgetsBindingObserver

00:08:09.730 --> 00:08:11.440
at the top level of my app.

00:08:11.440 --> 00:08:13.900
That's the only place I need
this Websocket to start,

00:08:13.900 --> 00:08:16.919
because the rest of it
is handled by event bus.

00:08:16.919 --> 00:08:17.710
And I set that up--

00:08:17.710 --> 00:08:21.150
I set up an instance in the init
state, and then I get rid of it

00:08:21.150 --> 00:08:23.230
when you're disposing
of the estate.

00:08:23.230 --> 00:08:26.140
And then in did application
lifecycle change,

00:08:26.140 --> 00:08:29.950
I just detect, hey, is the app
open, or is the app closed?

00:08:29.950 --> 00:08:32.890
The super simple architecture
pattern that I found

00:08:32.890 --> 00:08:35.414
was super easy for me to
just turn on the Websocket

00:08:35.414 --> 00:08:36.080
and turn it off.

00:08:39.700 --> 00:08:41.994
And the big thing is it helps
me conserve battery life.

00:08:41.994 --> 00:08:44.410
Because if I keep the Websocket
running in the background,

00:08:44.410 --> 00:08:46.150
you just have an
open socket going,

00:08:46.150 --> 00:08:49.030
and it's just going to eat
up the person's data and also

00:08:49.030 --> 00:08:50.060
the battery life.

00:08:50.060 --> 00:08:52.266
So WidgetsBindingObserver
is a really useful trick

00:08:52.266 --> 00:08:54.640
if you have something long
running that you want to pause

00:08:54.640 --> 00:08:59.030
when the application
goes in the background.

00:08:59.030 --> 00:09:01.680
The second is points are an
in-app currency in the app.

00:09:01.680 --> 00:09:04.010
Like I said before,
whenever you do something,

00:09:04.010 --> 00:09:05.210
points are being used.

00:09:05.210 --> 00:09:07.670
Now, the points are
actually shown everywhere

00:09:07.670 --> 00:09:08.450
throughout the UI.

00:09:08.450 --> 00:09:09.920
If you browse the
app a lot, you'll

00:09:09.920 --> 00:09:12.482
see that everywhere you
go, you'll see points,

00:09:12.482 --> 00:09:13.690
and how many points you have.

00:09:13.690 --> 00:09:15.650
And those points
are always being

00:09:15.650 --> 00:09:18.260
updated, depending on your
interactions with the app.

00:09:18.260 --> 00:09:23.600
And so my initial pattern there
was build a simple event bus.

00:09:23.600 --> 00:09:25.585
On every widget-- every page--

00:09:25.585 --> 00:09:27.710
I have an event bus that's
listening to the points.

00:09:27.710 --> 00:09:30.640
And then when you go off the
page, I close the event bus,

00:09:30.640 --> 00:09:32.390
and I listen to it
again on the next page.

00:09:32.390 --> 00:09:33.223
It seemed too messy.

00:09:33.223 --> 00:09:34.760
There had to be an easier way.

00:09:34.760 --> 00:09:37.130
And so I started digging
through the documentation,

00:09:37.130 --> 00:09:40.250
and I found this great thing
called InheritedWidget.

00:09:40.250 --> 00:09:43.850
An InheritedWidget is a simple
way to pass a piece of data

00:09:43.850 --> 00:09:46.040
across all your
widgets without having

00:09:46.040 --> 00:09:47.990
to set up a bunch
of event listeners,

00:09:47.990 --> 00:09:52.520
without having to call a set
state whenever data is updated.

00:09:52.520 --> 00:09:55.550
And so what I did was I
set up an InheritedWidget

00:09:55.550 --> 00:09:57.890
at the root of my widget
tree, at the start.

00:09:57.890 --> 00:10:01.010
And then that passed in
points, and all I had to do

00:10:01.010 --> 00:10:03.800
was just have one event bus
listener for points coming in

00:10:03.800 --> 00:10:04.899
from my Websocket.

00:10:04.899 --> 00:10:06.440
And that just sent
out an update that

00:10:06.440 --> 00:10:09.500
propagated throughout the
app whatever was active,

00:10:09.500 --> 00:10:11.510
and the points got updated.

00:10:11.510 --> 00:10:15.170
So code sample there is
here's my points widget,

00:10:15.170 --> 00:10:16.520
really simple.

00:10:16.520 --> 00:10:19.700
I just extend InheritedWidget.

00:10:19.700 --> 00:10:22.790
All the constructor takes is the
actual points that the user has

00:10:22.790 --> 00:10:25.880
at this point, and then a child.

00:10:25.880 --> 00:10:30.020
And the child, in my case,
is the entire application,

00:10:30.020 --> 00:10:32.180
and then it should
notify update.

00:10:32.180 --> 00:10:35.750
When should the InheritedWidget
notify its children

00:10:35.750 --> 00:10:37.670
that there has been an
update to the points?

00:10:37.670 --> 00:10:40.310
When the points are not
the same as the new points.

00:10:40.310 --> 00:10:41.780
Simple logic there.

00:10:41.780 --> 00:10:45.500
And then I just wrote a simple
helper function called Of,

00:10:45.500 --> 00:10:48.560
which takes in a context and
searches through the widget

00:10:48.560 --> 00:10:50.460
tree to find where
this points widget is.

00:10:50.460 --> 00:10:53.490
And that's how I get a
handle to this widget.

00:10:53.490 --> 00:10:57.490
Then I set it up in my
application at the top there.

00:10:57.490 --> 00:10:59.310
So this is my main.dart file.

00:10:59.310 --> 00:11:01.716
I call new points
widget, pass in points.

00:11:01.716 --> 00:11:03.090
There's some code
above it that's

00:11:03.090 --> 00:11:04.800
just actually listening
to the Websocket

00:11:04.800 --> 00:11:06.480
and getting the
points coming in.

00:11:06.480 --> 00:11:09.240
And then there's my material
app, which is the child there.

00:11:09.240 --> 00:11:13.140
After that, somewhere, anywhere
in my app in the widget tree,

00:11:13.140 --> 00:11:14.850
I can call--

00:11:14.850 --> 00:11:18.721
if you notice
pointswidget.ofcontext.points.

00:11:18.721 --> 00:11:20.220
And wherever I'm
listening to that--

00:11:20.220 --> 00:11:22.020
whenever points are updated--

00:11:22.020 --> 00:11:25.020
that's going to trigger
an update on that widget,

00:11:25.020 --> 00:11:28.530
and I'll get the most recent
points that the user has.

00:11:28.530 --> 00:11:31.230
This is really useful because
it helps you save memory state

00:11:31.230 --> 00:11:33.744
also, rather than
opening tons of listeners

00:11:33.744 --> 00:11:35.160
and then forgetting
to close them.

00:11:35.160 --> 00:11:36.240
That's a problem
that I kept running

00:11:36.240 --> 00:11:39.040
into where I kept forgetting to
cancel the stream subscription,

00:11:39.040 --> 00:11:42.420
and I kept running into widgets
being updated in the background

00:11:42.420 --> 00:11:44.110
and causing all sorts of issues.

00:11:44.110 --> 00:11:46.181
So InheritedWidget
is your friend.

00:11:46.181 --> 00:11:48.180
Use it for when you want
to pass a piece of data

00:11:48.180 --> 00:11:49.650
across the application.

00:11:49.650 --> 00:11:51.000
It seems daunting.

00:11:51.000 --> 00:11:52.680
The docs aren't
super clear on it.

00:11:52.680 --> 00:11:54.360
But if you take a
look at the sample--

00:11:54.360 --> 00:11:56.430
and there's a great
medium post on it too--

00:11:56.430 --> 00:11:58.920
you'll understand that it's
actually a very simple concept,

00:11:58.920 --> 00:12:00.570
and you can really
use it anytime

00:12:00.570 --> 00:12:02.910
you want when you have a
single piece of data flowing

00:12:02.910 --> 00:12:05.940
through your application.

00:12:05.940 --> 00:12:08.190
Now, once I had these
two things going,

00:12:08.190 --> 00:12:11.310
my next big challenge
on Android was--

00:12:11.310 --> 00:12:12.750
I use Retrofit.

00:12:12.750 --> 00:12:14.771
Anyone here use Retrofit before?

00:12:14.771 --> 00:12:15.270
Yes.

00:12:15.270 --> 00:12:16.260
OK, great.

00:12:16.260 --> 00:12:17.730
Lots of Android guys here.

00:12:17.730 --> 00:12:20.490
So Retrofit, for those
that haven't used it,

00:12:20.490 --> 00:12:23.340
basically takes the JSON
and converts it into a POJO.

00:12:23.340 --> 00:12:24.100
Awesome.

00:12:24.100 --> 00:12:25.830
There's nothing
like this on Flutter

00:12:25.830 --> 00:12:27.330
that I found, mainly
because Flutter

00:12:27.330 --> 00:12:29.070
doesn't have reflection.

00:12:29.070 --> 00:12:31.440
And so the big
problem there was I

00:12:31.440 --> 00:12:34.286
had so many endpoints
and so many data types.

00:12:34.286 --> 00:12:35.160
I'm a lazy developer.

00:12:35.160 --> 00:12:38.550
I did not want to write down
all these single data types over

00:12:38.550 --> 00:12:42.750
and over again, and build
out a fromJSON and toMap,

00:12:42.750 --> 00:12:44.620
and all sorts of
crazy stuff there.

00:12:44.620 --> 00:12:48.270
So I started digging, and I
found this great library called

00:12:48.270 --> 00:12:49.410
Jaguar Serializer.

00:12:49.410 --> 00:12:51.370
Anyone here used this before?

00:12:51.370 --> 00:12:51.870
No.

00:12:51.870 --> 00:12:52.441
Perfect.

00:12:52.441 --> 00:12:54.690
No one knows about this
library, and I don't know why.

00:12:54.690 --> 00:12:56.100
This is awesome.

00:12:56.100 --> 00:12:59.340
So what Jaguar
Serializer does is--

00:12:59.340 --> 00:13:01.080
here's a simple code snippet.

00:13:01.080 --> 00:13:02.650
I have a message class.

00:13:02.650 --> 00:13:04.980
Message is just
a simple object--

00:13:04.980 --> 00:13:07.720
a simple PODO, as
I like to call it.

00:13:07.720 --> 00:13:11.120
And all I'm doing
here is I'm annotating

00:13:11.120 --> 00:13:13.020
that this should be generated.

00:13:13.020 --> 00:13:15.750
And I override the
toMap, and I fill out

00:13:15.750 --> 00:13:17.460
what it should be
when it converts

00:13:17.460 --> 00:13:20.410
into a map, when I'm actually
sending it back to the server.

00:13:20.410 --> 00:13:25.590
And then in my pub spec,
I enter Jaguar Serializer

00:13:25.590 --> 00:13:30.990
version 0.5.1, and I install the
command line tool, Jaguar CLI.

00:13:30.990 --> 00:13:34.470
I run it and it automatically
generates the actual Dart

00:13:34.470 --> 00:13:39.000
file, with all the fromJSON
and toMAP stuff done for me.

00:13:39.000 --> 00:13:41.160
And so this is how I use it.

00:13:41.160 --> 00:13:44.130
I call it http.get.

00:13:44.130 --> 00:13:46.560
This is me making a
request for a conversation,

00:13:46.560 --> 00:13:48.030
passing a conversation ID.

00:13:48.030 --> 00:13:50.750
When the message comes in,
I take the response body,

00:13:50.750 --> 00:13:55.890
I convert into a map, and I do
serializer, right into a PODO.

00:13:55.890 --> 00:13:56.950
And it works really well.

00:13:56.950 --> 00:13:59.760
And so now I just have a message
object that I can pass around

00:13:59.760 --> 00:14:02.430
my app, versus
having a map and then

00:14:02.430 --> 00:14:04.980
converting that into
a message object

00:14:04.980 --> 00:14:08.320
and then doing the
painful conversion back.

00:14:08.320 --> 00:14:08.820
So use it.

00:14:08.820 --> 00:14:09.330
It's a must.

00:14:09.330 --> 00:14:11.259
I think it's like the
de facto thing you

00:14:11.259 --> 00:14:13.050
have to use in a Flutter
app because you're

00:14:13.050 --> 00:14:15.780
always almost going to be
using JSON, unless you're crazy

00:14:15.780 --> 00:14:16.920
and you use XML.

00:14:16.920 --> 00:14:20.130
And so this is the best
thing to use there.

00:14:20.130 --> 00:14:23.490
Now, this is a common
little widget pattern

00:14:23.490 --> 00:14:24.660
that I developed in the app.

00:14:24.660 --> 00:14:29.130
And this is just like a quick
tip in the app, and which is--

00:14:29.130 --> 00:14:31.077
a lot of places, I'm
using Gesture Recognizer.

00:14:31.077 --> 00:14:33.660
I think almost everyone here is
using Gesture Recognizer to do

00:14:33.660 --> 00:14:35.550
taps or drags and stuff.

00:14:35.550 --> 00:14:38.100
What I found is I don't want
to keep creating a new Gesture

00:14:38.100 --> 00:14:42.540
Recognizer and have a big
syntax there-- passing a child,

00:14:42.540 --> 00:14:44.050
create a function and stuff.

00:14:44.050 --> 00:14:47.371
So as well with dialogs,
you do Show Dialog,

00:14:47.371 --> 00:14:49.620
then you have a really
complicated-- not complicated--

00:14:49.620 --> 00:14:52.900
but a big enough method call
to create an actual dialog.

00:14:52.900 --> 00:14:54.210
So what I did was--

00:14:54.210 --> 00:14:57.060
because Flutter widgets are
these immutable lightweight

00:14:57.060 --> 00:14:59.610
widgets, I just stuck
them into a static class

00:14:59.610 --> 00:15:02.010
I call common widget utils.

00:15:02.010 --> 00:15:04.680
And what I do there is I
have widgetutils.addclick,

00:15:04.680 --> 00:15:09.189
Chose and addclick takes
in a widget and a function.

00:15:09.189 --> 00:15:10.980
It shouldn't be called
container, actually.

00:15:10.980 --> 00:15:12.780
It should just be
a normal widget.

00:15:12.780 --> 00:15:15.150
And then here, I just
create a Gesture Recognizer.

00:15:15.150 --> 00:15:18.090
So this really streamlines
my development, where

00:15:18.090 --> 00:15:21.610
I can just do addclick,
pass in the two parameters,

00:15:21.610 --> 00:15:22.320
and I'm done.

00:15:22.320 --> 00:15:23.640
Same thing with show dialog.

00:15:23.640 --> 00:15:26.310
You can see that a dialog
takes in a lot of stuff there.

00:15:26.310 --> 00:15:28.140
All I do is create
dialogue, pass

00:15:28.140 --> 00:15:30.797
in a context and the actual
message I want to show,

00:15:30.797 --> 00:15:31.380
and that's it.

00:15:31.380 --> 00:15:36.910
I don't need a complicated
widget tree in my file there.

00:15:36.910 --> 00:15:39.750
Next, once I started
doing all this stuff,

00:15:39.750 --> 00:15:41.940
I needed to deal with routing.

00:15:41.940 --> 00:15:43.200
The app has a lot of pages.

00:15:43.200 --> 00:15:44.730
The demo-- I only
showed two pages,

00:15:44.730 --> 00:15:46.510
but the app is very deep.

00:15:46.510 --> 00:15:49.890
There's galleries, and
videos, and rating--

00:15:49.890 --> 00:15:51.400
all sorts of crazy stuff.

00:15:51.400 --> 00:15:54.060
And so I needed a
good routing system.

00:15:54.060 --> 00:15:56.190
Flutter's routing
system is good,

00:15:56.190 --> 00:15:58.979
but it doesn't make it
easy to pass data through.

00:15:58.979 --> 00:16:01.020
Coming from Android, all
I do is I take a bundle,

00:16:01.020 --> 00:16:02.232
and I just pass in a bundle.

00:16:02.232 --> 00:16:03.690
I look at the other
app, and then I

00:16:03.690 --> 00:16:05.150
can extract that bundle there.

00:16:05.150 --> 00:16:06.150
It doesn't make it easy.

00:16:06.150 --> 00:16:08.040
So I looked into the
docs, and I found

00:16:08.040 --> 00:16:10.605
that you have to use
onGenerateRoute and parse

00:16:10.605 --> 00:16:12.000
in the argument yourself.

00:16:12.000 --> 00:16:12.600
I'm lazy.

00:16:12.600 --> 00:16:13.100
I'm crazy.

00:16:13.100 --> 00:16:14.260
I don't want to do that.

00:16:14.260 --> 00:16:17.550
And so I found a great
library called Fluro.

00:16:17.550 --> 00:16:20.700
And Fluro is built on top
of Flutter's routing system.

00:16:20.700 --> 00:16:23.100
What I like about it-- it
has these function handlers

00:16:23.100 --> 00:16:25.110
that actually pass
in the arguments

00:16:25.110 --> 00:16:26.292
that I pass in the route.

00:16:26.292 --> 00:16:27.750
So then I can take
those arguments,

00:16:27.750 --> 00:16:29.100
and I can convert them--

00:16:29.100 --> 00:16:31.440
or pass them-- into my state.

00:16:31.440 --> 00:16:35.190
I'll show that
example in a second.

00:16:35.190 --> 00:16:37.170
And so that's Fluro.

00:16:37.170 --> 00:16:40.330
That's the cool logo there.

00:16:40.330 --> 00:16:43.210
And you can see that
I have a routes class.

00:16:43.210 --> 00:16:45.550
And, basically, Configure
Routes has tons of routes.

00:16:45.550 --> 00:16:47.800
In this example, I
just have a chat route,

00:16:47.800 --> 00:16:49.900
and it takes a chat
handler function.

00:16:49.900 --> 00:16:52.620
And then the chat
handler function

00:16:52.620 --> 00:16:54.580
creates a new widget--
new chat screen--

00:16:54.580 --> 00:16:56.699
and takes in the name,
ID, and the conversation

00:16:56.699 --> 00:16:58.990
ID so that when I want to
start chatting with a member,

00:16:58.990 --> 00:17:01.750
I click on member's profile,
and all of these arguments

00:17:01.750 --> 00:17:02.740
are passed in.

00:17:02.740 --> 00:17:07.109
And the way I call
this, let me see--

00:17:07.109 --> 00:17:09.750
where is it?

00:17:09.750 --> 00:17:11.800
OK, the way you actually
call it is simple.

00:17:11.800 --> 00:17:15.810
You just call navigator.push
and pass in the arguments,

00:17:15.810 --> 00:17:16.916
as you would in a website.

00:17:16.916 --> 00:17:18.540
Like, we were doing
angular development

00:17:18.540 --> 00:17:21.028
or any sort of web development
as query parameters.

00:17:21.028 --> 00:17:22.819
And they'll get parsed
into a bundle there.

00:17:25.640 --> 00:17:27.285
That's where I actually create--

00:17:27.285 --> 00:17:28.910
you configure your
routes at the start.

00:17:28.910 --> 00:17:31.000
That's just some
sample code there.

00:17:31.000 --> 00:17:32.190
All, right so Fluro--

00:17:32.190 --> 00:17:32.690
use it.

00:17:32.690 --> 00:17:34.400
It's a must.

00:17:34.400 --> 00:17:36.830
I find it extremely
useful, and that's

00:17:36.830 --> 00:17:39.740
like the best routing available.

00:17:39.740 --> 00:17:42.290
The next part that I
ran into was images.

00:17:42.290 --> 00:17:44.800
They're a big part of
the app, obviously.

00:17:44.800 --> 00:17:46.670
There's images everywhere.

00:17:46.670 --> 00:17:48.336
But I needed something
that was robust.

00:17:48.336 --> 00:17:50.710
I just didn't need something
that tried to load an image,

00:17:50.710 --> 00:17:52.260
didn't cache it,
and then just died

00:17:52.260 --> 00:17:54.560
if the mobile network
wasn't working,

00:17:54.560 --> 00:17:56.820
or the person's on
2G or something.

00:17:56.820 --> 00:17:58.400
And so I didn't
want to write this.

00:17:58.400 --> 00:17:59.780
Again, I'm lazy.

00:17:59.780 --> 00:18:00.530
I started looking.

00:18:00.530 --> 00:18:03.029
And I found something written
by the Flutter team, actually,

00:18:03.029 --> 00:18:03.920
called Flutter Image.

00:18:03.920 --> 00:18:06.120
And it's called Network
Image with Retry.

00:18:06.120 --> 00:18:09.860
And what Network Image with
Retry does is it takes a =

00:18:09.860 --> 00:18:12.620
and it tries to fetch the URL.

00:18:12.620 --> 00:18:15.170
If it fails, it does
some algorithm there

00:18:15.170 --> 00:18:17.720
to try to fetch it again,
depending on what's happening

00:18:17.720 --> 00:18:18.950
with network conditions.

00:18:18.950 --> 00:18:20.780
And it returns an
image provider.

00:18:20.780 --> 00:18:22.280
Now that you have
an image provider,

00:18:22.280 --> 00:18:24.140
you can take Network
Image with Retry

00:18:24.140 --> 00:18:27.710
and pass it into a circle
avatar declaration--

00:18:27.710 --> 00:18:28.522
wherever you want.

00:18:28.522 --> 00:18:30.230
You can take this and
just pass it there.

00:18:30.230 --> 00:18:32.030
So at the bottom
there, you can see

00:18:32.030 --> 00:18:35.780
that I have a container with
a center in it and a circle

00:18:35.780 --> 00:18:36.380
avatar.

00:18:36.380 --> 00:18:38.671
And you saw there was a bunch
of circle pictures there,

00:18:38.671 --> 00:18:40.670
and that just takes
in a background image.

00:18:40.670 --> 00:18:43.160
Then I have a helper class
called getProfilePic,

00:18:43.160 --> 00:18:44.750
which-- at the top
there-- returns

00:18:44.750 --> 00:18:46.470
a Network Image with Retry.

00:18:46.470 --> 00:18:50.060
So real simple-- and then I
just have a robust image caching

00:18:50.060 --> 00:18:52.980
and retry solution.

00:18:52.980 --> 00:18:55.150
Use it.

00:18:55.150 --> 00:18:57.150
Another quick tip that I found--

00:18:57.150 --> 00:18:59.767
in the app, in the Android
app, I had a lot of small--

00:18:59.767 --> 00:19:01.050
not small--

00:19:01.050 --> 00:19:05.440
fairly lengthy but
plain old Java logic.

00:19:05.440 --> 00:19:07.190
It wasn't using anything
Android specific.

00:19:07.190 --> 00:19:11.100
It was just a lot of DRM and
some calculations of stuff

00:19:11.100 --> 00:19:12.310
that needs to be done.

00:19:12.310 --> 00:19:15.720
And so I didn't really want
to write them in Dart, mainly

00:19:15.720 --> 00:19:16.890
because they were so long.

00:19:16.890 --> 00:19:21.600
So being lazy, I searched Java
to Dart converter on Google.

00:19:21.600 --> 00:19:22.740
And I did find something.

00:19:22.740 --> 00:19:25.590
I found Java to Dart web.

00:19:25.590 --> 00:19:28.165
I can actually show
you guys an example.

00:19:38.320 --> 00:19:40.440
And basically you pass in--

00:19:40.440 --> 00:19:42.370
let me increase there--

00:19:42.370 --> 00:19:46.270
you pass in some Java, and
you get some Dart back.

00:19:46.270 --> 00:19:47.890
And this really
helped me just pore

00:19:47.890 --> 00:19:50.320
over a lot of
legacy, old Java code

00:19:50.320 --> 00:19:53.590
to Dart easily, just
copying and pasting in.

00:19:53.590 --> 00:19:56.680
Don't try to pass in,
like, actual Android code.

00:19:56.680 --> 00:19:58.574
It most likely won't work.

00:19:58.574 --> 00:19:59.740
But it's a quick little tip.

00:19:59.740 --> 00:20:03.830
It'll be in the slides after.

00:20:03.830 --> 00:20:07.340
Now, this was a big one, and
I'll show the demo of the app

00:20:07.340 --> 00:20:08.030
again for this.

00:20:08.030 --> 00:20:09.830
But a responsive UI--

00:20:09.830 --> 00:20:13.690
when I click on anything in the
app, it makes a network call.

00:20:13.690 --> 00:20:15.695
Network calls are slow.

00:20:15.695 --> 00:20:17.819
It doesn't matter where
you are on your phone--

00:20:17.819 --> 00:20:19.610
I mean, where you are
location-- sometimes,

00:20:19.610 --> 00:20:20.220
it will just be slow.

00:20:20.220 --> 00:20:21.800
Sometimes, your
server might be slow.

00:20:21.800 --> 00:20:23.732
And you just don't want
to show a white page.

00:20:23.732 --> 00:20:25.190
So you want to show
a progress bar.

00:20:25.190 --> 00:20:29.330
The way you do that currently
in Flutter is you have a show

00:20:29.330 --> 00:20:31.140
loading equals false.

00:20:31.140 --> 00:20:33.500
And if show loading is false
in your build function,

00:20:33.500 --> 00:20:35.930
you show a spinner animation.

00:20:35.930 --> 00:20:39.090
Else, you show your
entire widget tree.

00:20:39.090 --> 00:20:42.330
Now, I didn't want to write
that over and over again,

00:20:42.330 --> 00:20:44.720
so I started finding
a solution for it.

00:20:44.720 --> 00:20:47.480
And so what I came across
was this great library

00:20:47.480 --> 00:20:49.010
called Async Loader.

00:20:49.010 --> 00:20:51.000
Anyone here use this library?

00:20:51.000 --> 00:20:51.500
Great.

00:20:51.500 --> 00:20:55.460
Look at this-- all this crazy
information no one's used.

00:20:55.460 --> 00:20:59.120
So Async Loader is actually
probably the most amazing

00:20:59.120 --> 00:21:01.640
FLUTTER library I've seen.

00:21:01.640 --> 00:21:03.170
And this is how you use it.

00:21:03.170 --> 00:21:06.410
You create an async loader
in your build function.

00:21:06.410 --> 00:21:08.480
And it has a few
parameters there.

00:21:08.480 --> 00:21:11.510
It has init state, render
load, render error,

00:21:11.510 --> 00:21:12.860
and render success.

00:21:12.860 --> 00:21:16.370
Init state is, basically,
as the widget is floating,

00:21:16.370 --> 00:21:17.900
what do you want to load?

00:21:17.900 --> 00:21:19.700
What data do you want to load?

00:21:19.700 --> 00:21:22.330
As render load is as
it's being loaded,

00:21:22.330 --> 00:21:23.570
what do you want to show?

00:21:23.570 --> 00:21:26.210
So in render load, I
show a progress bar.

00:21:26.210 --> 00:21:28.552
Render error is if
something went crazy wrong,

00:21:28.552 --> 00:21:29.510
what do you want to do?

00:21:29.510 --> 00:21:31.820
So here, for the
sake of the demo,

00:21:31.820 --> 00:21:34.400
I just have new text error
loading conversation.

00:21:34.400 --> 00:21:36.890
So you see a boring old
error loading conversation

00:21:36.890 --> 00:21:37.670
on the page.

00:21:37.670 --> 00:21:41.600
What you typically want is some
sort of nice little graphic

00:21:41.600 --> 00:21:44.840
that says, oh, something went
wrong, please press back.

00:21:44.840 --> 00:21:47.480
And then finally, when
all your data is loaded,

00:21:47.480 --> 00:21:50.090
render success is
called with your data

00:21:50.090 --> 00:21:52.684
that you return in
your init state.

00:21:52.684 --> 00:21:55.100
And then you can take that
data, and then you can actually

00:21:55.100 --> 00:21:56.780
render your entire UI.

00:21:56.780 --> 00:21:59.555
So here, in the video--

00:22:03.310 --> 00:22:04.160
let's go back here.

00:22:07.314 --> 00:22:09.730
So when I click this, if you
see, that's this loading bar.

00:22:09.730 --> 00:22:12.430
That's actually a
show progress loading.

00:22:12.430 --> 00:22:15.190
And then it loads and loads.

00:22:15.190 --> 00:22:17.200
And then once that
load is done, it

00:22:17.200 --> 00:22:18.920
calls render success
with all my data,

00:22:18.920 --> 00:22:20.560
and then there is my entire UI.

00:22:20.560 --> 00:22:24.300
So it really gives me a nice
little abstraction for--

00:22:24.300 --> 00:22:26.680
yeah, it gives a nice
level abstraction away,

00:22:26.680 --> 00:22:30.040
rather than having this
if sort of logic inside my

00:22:30.040 --> 00:22:31.146
build function.

00:22:31.146 --> 00:22:32.770
And then I just take
the Async Loader--

00:22:32.770 --> 00:22:36.250
I pass it to my scaffold,
and you're done.

00:22:36.250 --> 00:22:38.420
So use it.

00:22:38.420 --> 00:22:42.450
Lastly-- so I mean, with all
this done, my app was amazing.

00:22:42.450 --> 00:22:44.940
I was able to build
it in like five days.

00:22:44.940 --> 00:22:47.040
And then I sent it to
Apple for approval,

00:22:47.040 --> 00:22:50.100
and then they'll probably
get back three months later.

00:22:50.100 --> 00:22:52.800
And so I rewrote my entire app.

00:22:52.800 --> 00:22:54.912
It was really painless.

00:22:54.912 --> 00:22:56.370
Because I wrote it
so quickly-- you

00:22:56.370 --> 00:22:57.786
have to understand
that I actually

00:22:57.786 --> 00:23:00.330
had a lot of the app built. I
had the API already written.

00:23:00.330 --> 00:23:02.460
I had all the interfaces,
the logic, there.

00:23:02.460 --> 00:23:04.920
So in a real world
application that if you're

00:23:04.920 --> 00:23:07.380
writing from scratch, you can
probably get a real Flutter

00:23:07.380 --> 00:23:10.230
application done in a
week or more, actually,

00:23:10.230 --> 00:23:14.520
but nothing too crazy
like a couple of months.

00:23:14.520 --> 00:23:16.980
And my strategy there
is to launch iOS first.

00:23:16.980 --> 00:23:18.150
Test it.

00:23:18.150 --> 00:23:20.730
Launch Android after all
the testing, and then

00:23:20.730 --> 00:23:22.290
just delete the Android project.

00:23:22.290 --> 00:23:23.090
Because whatever.

00:23:23.090 --> 00:23:26.190
Now I can maintain one app, and
I can make money through it.

00:23:26.190 --> 00:23:27.510
And that's it.

00:23:27.510 --> 00:23:28.410
Thank you.

00:23:28.410 --> 00:23:30.260
[APPLAUSE]

