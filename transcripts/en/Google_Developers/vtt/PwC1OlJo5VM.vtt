WEBVTT
Kind: captions
Language: en

00:00:01.439 --> 00:00:14.360
[ Applause ]
&gt;&gt;Reto Meier: My name is Reto Meier, and I'm

00:00:14.360 --> 00:00:17.160
the tech lead for the Android developer relations
team.

00:00:17.160 --> 00:00:21.770
In today's session, I will hopefully be able
to provide you guys with some tips which will

00:00:21.770 --> 00:00:25.220
help to turn your good apps into great apps.

00:00:25.220 --> 00:00:30.410
Now, I consider this to be a follow-up from
my I/O session last year, which was Android

00:00:30.410 --> 00:00:37.870
Protips, making this Android Protips II, Electric
Boogaloo.

00:00:37.870 --> 00:00:40.469
Like last year, I'm going to try and keep
things pretty technical.

00:00:40.469 --> 00:00:41.699
There will be code.

00:00:41.699 --> 00:00:45.190
So if you're not comfortable reading code
snippets, don't worry.

00:00:45.190 --> 00:00:49.489
I will give you this signal (indicating),
which is your queue to put on your headsets,

00:00:49.489 --> 00:00:52.289
start watching Transformers.

00:00:52.289 --> 00:00:54.159
So what makes a great app?

00:00:54.159 --> 00:00:59.969
Well, in my view, a great app is one where
users aren't even thinking of it as an app.

00:00:59.969 --> 00:01:04.589
They're not thinking, am I using an app on
a smartphone connected to the Internet over

00:01:04.589 --> 00:01:05.980
a 3G network.

00:01:05.980 --> 00:01:09.370
They just want to perform an action, they
just want to use a service.

00:01:09.370 --> 00:01:13.200
Whether that's been clicking an icon, selecting
a notification, clicking something on the

00:01:13.200 --> 00:01:17.580
home screen, they just want to get something
done and your app is just the way that happens.

00:01:17.580 --> 00:01:21.100
So the idea here is to make them not have
to think about the implementation.

00:01:21.100 --> 00:01:25.480
They don't have to think about how you've
done it, how the device is connected.

00:01:25.480 --> 00:01:26.480
Everything just works.

00:01:26.480 --> 00:01:29.900
Let me give you an example of what I mean.

00:01:29.900 --> 00:01:33.410
A couple of years ago, I had the very good
fortune to visit Kenya.

00:01:33.410 --> 00:01:37.190
Over in Africa, mobile's a serious business.

00:01:37.190 --> 00:01:40.611
I don't mean serious as in finding the best
noodle bar in Nairobi.

00:01:40.611 --> 00:01:44.720
I mean serious as in this is the only way
you get online.

00:01:44.720 --> 00:01:50.390
I mean serious as in you go to a bar, you
see a cute girl or guy, and instead of sending

00:01:50.390 --> 00:01:54.680
them over a few drinks, you buy them mobile
phone credits so they can give you a call

00:01:54.680 --> 00:01:56.330
if they're interested.

00:01:56.330 --> 00:02:03.180
Now, if your smartphone is the way you get
online and it's the way that you flirt, a

00:02:03.180 --> 00:02:06.780
really interesting thing happens to your perception
of that device.

00:02:06.780 --> 00:02:09.860
Let me give you an idea of what I'm talking
about.

00:02:09.860 --> 00:02:17.030
While we were over there, a big part of our
G Africa or G Kenya event was finding out

00:02:17.030 --> 00:02:22.220
and talking about the massive growth in smartphones'
innovation and penetration across Africa.

00:02:22.220 --> 00:02:27.620
So it was kind of surprising to hear that
a lot of people didn't self-identify as Internet

00:02:27.620 --> 00:02:29.950
users on their smartphones.

00:02:29.950 --> 00:02:33.560
We asked around, "Do you use the Internet
on your phone?"

00:02:33.560 --> 00:02:34.560
"No, not really."

00:02:34.560 --> 00:02:35.560
Well, that's strange.

00:02:35.560 --> 00:02:38.590
"Why did you buy a smartphone if you're not
using the Internet on it?

00:02:38.590 --> 00:02:43.010
Do you not search for things and check your
email and update your social networks?"

00:02:43.010 --> 00:02:44.010
"Yeah, of course.

00:02:44.010 --> 00:02:46.160
Of course I use Google and Gmail and Facebook.

00:02:46.160 --> 00:02:48.680
I just don't really use the Internet."

00:02:48.680 --> 00:02:52.510
[ Laughter ]
&gt;&gt;Reto Meier: So what's going on here?

00:02:52.510 --> 00:02:54.850
Well, it's actually a really interesting phenomenon.

00:02:54.850 --> 00:02:59.190
And it's particularly the case in Africa where
most people are starting to get online for

00:02:59.190 --> 00:03:01.770
the first time using their smartphones.

00:03:01.770 --> 00:03:06.390
So people aren't thinking of these apps as
being really efficient ways of displaying

00:03:06.390 --> 00:03:08.480
a Web page on a phone.

00:03:08.480 --> 00:03:12.990
They just are thinking of that's something
I can do with this device.

00:03:12.990 --> 00:03:16.580
And that's becoming increasingly the case,
even here, where a lot of the most popular

00:03:16.580 --> 00:03:18.319
apps don't have Web sites.

00:03:18.319 --> 00:03:20.540
And if they do, people don't visit them.

00:03:20.540 --> 00:03:24.599
The entire experience is on the phone.

00:03:24.599 --> 00:03:26.430
So how big a deal is this?

00:03:26.430 --> 00:03:32.069
Well, while we were over in Kenya, we like
to visit some of the phone stores to find

00:03:32.069 --> 00:03:36.530
out what phones are selling, what kind of
tariffs, what's the deal.

00:03:36.530 --> 00:03:41.880
And we found that you can get the same phone
on basically the same tariff, and on the one

00:03:41.880 --> 00:03:45.330
hand, you can get unlimited social networking
updates.

00:03:45.330 --> 00:03:48.099
And on the other hand, unlimited Internet
access.

00:03:48.099 --> 00:03:49.880
For the same price.

00:03:49.880 --> 00:03:54.020
And the interesting thing is, the unlimited
social networking updates was actually a more

00:03:54.020 --> 00:03:55.050
popular plan.

00:03:55.050 --> 00:03:59.709
And so what we're seeing is people completely
oblivious to the fact that it's the Internet

00:03:59.709 --> 00:04:01.140
that powers this stuff.

00:04:01.140 --> 00:04:03.500
I'm sure if they thought about it, they would
realize.

00:04:03.500 --> 00:04:07.670
But the key here is that you've made that
disconnect.

00:04:07.670 --> 00:04:10.260
People are no longer thinking about how these
things work.

00:04:10.260 --> 00:04:14.099
It's just something that they want, and updating
their social networks is something they do

00:04:14.099 --> 00:04:17.780
a lot, so that becomes really valuable.

00:04:17.780 --> 00:04:24.050
So then how do we, as developers, create an
app that's more valuable than the Internet?

00:04:24.050 --> 00:04:29.030
Well, it helps if you've already got a service
that people really love, a service which they're

00:04:29.030 --> 00:04:34.530
already taking advantage of, and it's something
which they would use as a purchasing decision

00:04:34.530 --> 00:04:37.760
when figuring out what phone, what tariff,
what plan to use.

00:04:37.760 --> 00:04:40.430
Now, most of us in this room probably aren't
in that boat.

00:04:40.430 --> 00:04:42.680
We don't have the existing biggest service.

00:04:42.680 --> 00:04:46.590
What we're trying to create is the next biggest
service, the next biggest app that everyone

00:04:46.590 --> 00:04:48.550
has to have on their phones.

00:04:48.550 --> 00:04:54.030
And I think a really good approach to being
able to create that app is to build something

00:04:54.030 --> 00:04:57.540
that works as though it were an indispensable
part of the phone.

00:04:57.540 --> 00:05:02.250
So something that doesn't drain your battery,
something that's not obnoxious, that still

00:05:02.250 --> 00:05:06.100
provides all the information you need exactly
when you need it, but other than that, it

00:05:06.100 --> 00:05:07.530
stays out of the way.

00:05:07.530 --> 00:05:10.310
And at the same time, it has to be absolutely
reliable.

00:05:10.310 --> 00:05:15.380
It has to be something that users can take
for granted so they're never asking the question,

00:05:15.380 --> 00:05:16.380
should I do this?

00:05:16.380 --> 00:05:17.380
Should I have a fallback?

00:05:17.380 --> 00:05:20.750
Because if they have a fallback in case your
app doesn't work, they're just going to start

00:05:20.750 --> 00:05:21.750
using the fallback instead.

00:05:21.750 --> 00:05:27.190
So I'm going to look at each of these topics,
invisibility, efficiency, and reliability

00:05:27.190 --> 00:05:33.470
in more detail throughout -- throughout my
session here.

00:05:33.470 --> 00:05:37.030
So if I seem a little bit nervous now, it's
because I've got a video queued up.

00:05:37.030 --> 00:05:41.090
And if you saw my session last year, I had
a little bit of trouble there.

00:05:41.090 --> 00:05:45.740
So it's with a small amount of apprehension
that I queue up the first of these interstitial

00:05:45.740 --> 00:05:48.599
videos.

00:05:48.599 --> 00:05:51.460
[ Video.

00:05:51.460 --> 00:05:54.319
]
(Beeps).

00:05:54.319 --> 00:06:02.910
[ Laughter ]
(Lip-smacking sounds).

00:06:02.910 --> 00:06:08.639
(Noises, siren).

00:06:08.639 --> 00:06:14.370
[ Video concludes.

00:06:14.370 --> 00:06:17.229
]
[ Applause ]

00:06:17.229 --> 00:06:23.110
&gt;&gt;Reto Meier: Thank you.

00:06:23.110 --> 00:06:25.340
I can't take any credit for the videos.

00:06:25.340 --> 00:06:27.080
But thank you.

00:06:27.080 --> 00:06:29.220
So invisibility.

00:06:29.220 --> 00:06:31.759
It's obvious why the Droid wants to be invisible.

00:06:31.759 --> 00:06:33.790
But why do we want to make our apps invisible?

00:06:33.790 --> 00:06:35.320
Is this something we want?

00:06:35.320 --> 00:06:36.780
I think it is.

00:06:36.780 --> 00:06:38.650
And let me explain why.

00:06:38.650 --> 00:06:41.000
So two things happened to me at about the
same time.

00:06:41.000 --> 00:06:44.910
I started working for Google, and shortly
before that, I got my first Android phone,

00:06:44.910 --> 00:06:45.910
a T*Mobile G1.

00:06:45.910 --> 00:06:50.050
Do we have G1 owners past or present in the
crowd?

00:06:50.050 --> 00:06:52.699
I/O audience never disappoints.

00:06:52.699 --> 00:06:56.220
You've all been upgraded today.

00:06:56.220 --> 00:06:59.530
Those two things happened.

00:06:59.530 --> 00:07:03.210
As you know, the G1 had the Gmail app, wonderful
app.

00:07:03.210 --> 00:07:06.930
What you may not be aware of is that when
you start working at Google, you start receiving

00:07:06.930 --> 00:07:13.540
email at a rate of around 1,000 messages a
second, give or take.

00:07:13.540 --> 00:07:18.229
And so to try and triage that fire hose of
information, I would check my email every

00:07:18.229 --> 00:07:24.330
morning as I commuted into London from Wimbledon
along the district line.

00:07:24.330 --> 00:07:28.210
So if you've ever had the pleasure of enjoying
that particular journey, you'll know that

00:07:28.210 --> 00:07:32.160
your Internet connectivity goes from kind
of spotty and intermittent as you go in and

00:07:32.160 --> 00:07:36.729
out of tunnels and stations until you get
to Earl's Court, London underground proper

00:07:36.729 --> 00:07:40.580
and your Internet connectivity disappears
entirely.

00:07:40.580 --> 00:07:47.320
Now, the beauty of the Gmail app is that I'm
totally oblivious to this.

00:07:47.320 --> 00:07:48.540
I'm checking my email.

00:07:48.540 --> 00:07:51.310
I'm reading them, hit archive, it disappears.

00:07:51.310 --> 00:07:53.889
Send a message, and it goes.

00:07:53.889 --> 00:07:55.810
And I never have to think about whether or
not I'm connected.

00:07:55.810 --> 00:08:01.400
By the time I get back to my desk, open up
your laptop, my inbox is synced, my sent messages

00:08:01.400 --> 00:08:03.380
have all been dispatched, I'm ready to go.

00:08:03.380 --> 00:08:06.300
And I've never had to think for a moment,
how does Gmail work?

00:08:06.300 --> 00:08:07.850
How is it sending my emails?

00:08:07.850 --> 00:08:10.460
Is it connected to the Internet.

00:08:10.460 --> 00:08:14.890
This is in direct contrast to one of the news
apps that I've been trying to use at the same

00:08:14.890 --> 00:08:15.890
time.

00:08:15.890 --> 00:08:17.949
So I could see the headlines easily enough.

00:08:17.949 --> 00:08:22.889
But if I were to click one to try and read
the article, if I happen to be in a station,

00:08:22.889 --> 00:08:27.940
it wouldn't load, or if I go through a tunnel,
then I'll get about halfway done and it will

00:08:27.940 --> 00:08:28.940
stop.

00:08:28.940 --> 00:08:32.349
So I'd be lucky if I could read more than
one or two articles by the time I got into

00:08:32.349 --> 00:08:33.459
work.

00:08:33.459 --> 00:08:38.681
And that's the same kind of frustration as
I feel when I navigate to a location and then

00:08:38.681 --> 00:08:43.631
I look up the venue in an app, and as I'm
walking down the stairs, I go to check in

00:08:43.631 --> 00:08:47.360
and it's telling me, you don't have an Internet
connection, so you can't -- try again later.

00:08:47.360 --> 00:08:49.340
It's like, well, I want it now.

00:08:49.340 --> 00:08:51.150
I'm really not going to bother.

00:08:51.150 --> 00:08:53.060
Straightaway, I've had this disconnect.

00:08:53.060 --> 00:08:57.230
I'm thinking about how does this app work,
it needs an Internet connection and I'm indoors

00:08:57.230 --> 00:08:58.690
now, so I don't have a cell connection.

00:08:58.690 --> 00:09:00.680
I should try and get Wi-Fi.

00:09:00.680 --> 00:09:02.130
And it's a total disconnect.

00:09:02.130 --> 00:09:05.950
It makes me have to think about how the app
was written instead of what I want to do,

00:09:05.950 --> 00:09:08.839
which is simply check in.

00:09:08.839 --> 00:09:14.029
So how do we create apps which are invisible,
which let us completely ignore how they're

00:09:14.029 --> 00:09:16.310
put together in the same way that Gmail works?

00:09:16.310 --> 00:09:22.709
Well, the solution is to use something like
this, a queue and send pattern.

00:09:22.709 --> 00:09:28.100
Now, the thing about this -- so let's have
a look at this.

00:09:28.100 --> 00:09:32.140
Before I go into the details on the code,
please note that all of the code snippets,

00:09:32.140 --> 00:09:36.220
slides, and everything else will be made available
within 24 hours of this.

00:09:36.220 --> 00:09:38.430
So don't try and copy any of it down.

00:09:38.430 --> 00:09:39.440
But let's have a look at the code.

00:09:39.440 --> 00:09:44.290
So what we're trying to do here is, we check
to see whether or not we're connected.

00:09:44.290 --> 00:09:49.600
And if we're not connected, as in this case,
then we're simply going to add our transfer

00:09:49.600 --> 00:09:50.990
to the queue.

00:09:50.990 --> 00:09:55.630
So in this example, we're looking at a check-in.

00:09:55.630 --> 00:09:58.110
So if we're not connected, that's it.

00:09:58.110 --> 00:10:02.120
If we are connected, so looking at this next
section, then we're going to try the check-in

00:10:02.120 --> 00:10:03.380
first.

00:10:03.380 --> 00:10:08.340
If the check-in fails, then we're going to
add it to our retry queue.

00:10:08.340 --> 00:10:11.680
Once we've done that, we're going to go through
that retry queue, which includes anything

00:10:11.680 --> 00:10:15.880
we've queued up beforehand before we connected
to the Internet and anything which has previously

00:10:15.880 --> 00:10:17.040
failed.

00:10:17.040 --> 00:10:20.180
Anything that succeeds, we remove it from
the queue and check to see whether or not

00:10:20.180 --> 00:10:22.570
there's anything left in that queue.

00:10:22.570 --> 00:10:25.980
If there is, then we're going to need to try
this again later.

00:10:25.980 --> 00:10:30.460
Now, in this instance, I've created a fairly
simplistic retry mechanism, which is just

00:10:30.460 --> 00:10:33.310
going to use a set interval to continue to
retry.

00:10:33.310 --> 00:10:35.620
Now, this isn't particularly efficient.

00:10:35.620 --> 00:10:38.740
I'm going to give a much better example later
on of how you should probably do this.

00:10:38.740 --> 00:10:42.890
But for the purposes of this code snippet,
it gives you an idea of the process of what

00:10:42.890 --> 00:10:44.580
you should be doing.

00:10:44.580 --> 00:10:48.720
Note also at the top, when we're not connected,
we're also going to cancel this retry alarm.

00:10:48.720 --> 00:10:52.420
There's no pointed in waking the advice and
trying this again if we don't have an Internet

00:10:52.420 --> 00:10:53.420
connection.

00:10:53.420 --> 00:10:59.040
And, similarly, or in relation to that, we're
also going to enable a manifest receiver,

00:10:59.040 --> 00:11:03.220
which is going to listen for connectivity
changes, so that when we do get back on the

00:11:03.220 --> 00:11:08.330
Internet, we can straightaway go through this
queue-up queue and perform all of those transfers

00:11:08.330 --> 00:11:14.850
straightaway, so you don't have to wait for
the user to initiate another action first.

00:11:14.850 --> 00:11:17.830
So that's one way of being invisible.

00:11:17.830 --> 00:11:22.080
Another approach is to make sure that your
app feels consistent with the rest of the

00:11:22.080 --> 00:11:23.080
framework.

00:11:23.080 --> 00:11:25.290
Now, you want to be original, you want to
be creative.

00:11:25.290 --> 00:11:28.670
You want to have something which people are
going to recognize and identify with your

00:11:28.670 --> 00:11:29.670
app.

00:11:29.670 --> 00:11:33.040
But you don't want to have to give them that
moment of cognitive dissonance when they're

00:11:33.040 --> 00:11:37.240
trying to figure out how to use your app,
how does it fit into the system.

00:11:37.240 --> 00:11:42.630
So the real trick is to create something that
is consistent with the framework aesthetic

00:11:42.630 --> 00:11:47.740
but still has that creativity, still has that
uniqueness that represents your app.

00:11:47.740 --> 00:11:52.500
Now, the first step to that is to visit the
design site at developer.android.com/design,

00:11:52.500 --> 00:11:58.680
that has always the details you need both
in terms of the specific implementation deals

00:11:58.680 --> 00:12:03.910
as to how you should make your apps work,
but also the philosophy behind it.

00:12:03.910 --> 00:12:08.550
So you can think more about how are the Android
designers thinking, how do they come to those

00:12:08.550 --> 00:12:09.550
conclusions?

00:12:09.550 --> 00:12:13.510
I'm not part of the design team, so I'm not
going to go in at any length here.

00:12:13.510 --> 00:12:18.240
But happily, they will all be here tomorrow,
basically all day, down in room 9, giving

00:12:18.240 --> 00:12:22.930
sessions, interactive code labs, all of those
sorts of things to try and really help you

00:12:22.930 --> 00:12:27.600
guys get a feel for how they think, the decisions
they've made, why they've made them and how

00:12:27.600 --> 00:12:33.050
you can create something that, as I say, is
unique and identifies your app but still allows

00:12:33.050 --> 00:12:40.310
users to understand how they work without
having to spend a lot of time on it.

00:12:40.310 --> 00:12:41.670
So what else can we do?

00:12:41.670 --> 00:12:47.100
Well, I look at some of the most popular apps
and you look at things like Shazam, Instagram,

00:12:47.100 --> 00:12:49.110
they're hugely successful.

00:12:49.110 --> 00:12:54.170
And I think a big part of that is because
they've created something where it's tightly

00:12:54.170 --> 00:12:55.589
bound to an action.

00:12:55.589 --> 00:13:00.970
So whether that's recognizing what music is
playing or taking hipster photographs, you

00:13:00.970 --> 00:13:02.010
recognize that action.

00:13:02.010 --> 00:13:04.740
You associate it with their particular app.

00:13:04.740 --> 00:13:06.200
And that's a really powerful thing.

00:13:06.200 --> 00:13:09.560
That's how you get to that point where people
just want to be able to do that.

00:13:09.560 --> 00:13:11.510
And they don't care how it works.

00:13:11.510 --> 00:13:19.089
One of the real advantages to building something
which has that kind of tight focus is it makes

00:13:19.089 --> 00:13:22.839
it much easier to then port it across a variety
of different hardware.

00:13:22.839 --> 00:13:27.470
Now, this is important, because the Android
ecosystem is huge.

00:13:27.470 --> 00:13:32.579
You've got this huge variety of devices both
in terms of variations on smartphones and

00:13:32.579 --> 00:13:37.650
tablets, but also an increasingly wide and
diverse ecosystem in general.

00:13:37.650 --> 00:13:41.279
So most of us have spent a lot of time developing
for smartphones.

00:13:41.279 --> 00:13:43.860
And that's where a lot of our focus lies.

00:13:43.860 --> 00:13:46.500
Now, smartphones have all of the new gadgets.

00:13:46.500 --> 00:13:51.280
They've got all the sensors, they've got NFC,
they've got touch screens, gyroscopes, front-

00:13:51.280 --> 00:13:53.519
and back-facing cameras, the works.

00:13:53.519 --> 00:13:58.460
And so it makes sense to develop your app
to take advantage of all of that hardware.

00:13:58.460 --> 00:14:00.860
But then what happens when new hardware comes
out?

00:14:00.860 --> 00:14:05.540
You've all got a Nexus 7, you've probably
noticed it doesn't have a back-facing camera.

00:14:05.540 --> 00:14:07.490
What does that mean to us as developers?

00:14:07.490 --> 00:14:12.870
Well, the easiest step is to say, well, my
app takes advantage of all these different

00:14:12.870 --> 00:14:18.300
sensors, so I'm going to add lines to my manifest
which says it requires an accelerometer and

00:14:18.300 --> 00:14:21.620
NFC and everything else I take advantage of.

00:14:21.620 --> 00:14:25.950
Then someone releases a device which is slightly
different, and suddenly your app isn't going

00:14:25.950 --> 00:14:29.850
to be available in Google Play, and you're
cutting off what could be a significantly

00:14:29.850 --> 00:14:32.320
large portion of your potential user base.

00:14:32.320 --> 00:14:34.670
Now, you want to avoid this.

00:14:34.670 --> 00:14:36.630
And so let's have a look at a couple of examples.

00:14:36.630 --> 00:14:40.850
So for -- if you've got something like an
accelerometer, something like a compass, which

00:14:40.850 --> 00:14:45.100
depends on an accelerometer to figure out
which direction you're facing, it's pretty

00:14:45.100 --> 00:14:47.760
easy to say that is a required hardware feature.

00:14:47.760 --> 00:14:52.070
What if you have an app which lets you apply
filters to photos?

00:14:52.070 --> 00:14:53.700
Do you need a camera for that?

00:14:53.700 --> 00:14:58.050
Well, most of these apps you don't, because
you can apply those same filters to photos

00:14:58.050 --> 00:15:01.519
that are already on the device or that are
in your gallery.

00:15:01.519 --> 00:15:07.079
But by simply adding this service requires
users feature to your manifest, or even in

00:15:07.079 --> 00:15:12.320
the case of camera, just using the users permission
and not saying that the camera is optional

00:15:12.320 --> 00:15:14.770
will prevent that app from being available
to these devices.

00:15:14.770 --> 00:15:21.660
So a much better approach is to use the Package
Manager to see what hardware is actually available

00:15:21.660 --> 00:15:23.459
at run time.

00:15:23.459 --> 00:15:27.800
So rather than blocking your app from a potential
user, what you're doing instead is saying,

00:15:27.800 --> 00:15:30.649
well, the user experience is going to be different.

00:15:30.649 --> 00:15:34.709
So that can be something as simple as saying,
well, if there's not a camera, then I'm going

00:15:34.709 --> 00:15:39.720
to disable or even hide, remove, the take
a picture button.

00:15:39.720 --> 00:15:41.290
That makes sense.

00:15:41.290 --> 00:15:43.130
But it could be something much more dramatic.

00:15:43.130 --> 00:15:46.990
So you may say, well, if there's no touch
screen on this device and no sensors, then

00:15:46.990 --> 00:15:50.230
I'm going to try and present more of a lean-back
experience, something where I'm expecting

00:15:50.230 --> 00:15:54.490
people not to interact with this app as much.

00:15:54.490 --> 00:15:58.459
And so by using this Package Manager class
at run time, you're able to figure out exactly

00:15:58.459 --> 00:16:04.010
what hardware is available and really customize
that user experience to present the best possible

00:16:04.010 --> 00:16:05.990
way of being able to do things.

00:16:05.990 --> 00:16:11.360
It really comes down to, rather than trying
to say how do I lay out my screen on these

00:16:11.360 --> 00:16:17.421
different size devices, instead, what you're
figuring out is, given this hardware, how

00:16:17.421 --> 00:16:22.790
can users best perform the action which they're
expecting to be able to do with my app?

00:16:22.790 --> 00:16:26.860
So it all gets back to this simplification,
making it invisible, making it more accessible

00:16:26.860 --> 00:16:30.360
for your users.

00:16:30.360 --> 00:16:31.360
So that's invisibility.

00:16:31.360 --> 00:16:34.860
I'm going to move on to the next section now
and spend a fair amount of time on this, because

00:16:34.860 --> 00:16:36.740
it's a topic that's really close to my heart.

00:16:36.740 --> 00:16:39.490
I think efficiency is really important for
users.

00:16:39.490 --> 00:16:57.660
So let's have a look at the video.

00:16:57.660 --> 00:17:00.209
[ Video.

00:17:00.209 --> 00:17:05.310
]
(Ringing noises).

00:17:05.310 --> 00:17:10.419
[ Video concludes.

00:17:10.419 --> 00:17:12.970
]
[ Applause ]

00:17:12.970 --> 00:17:19.039
&gt;&gt;Reto Meier: So efficiency.

00:17:19.039 --> 00:17:20.799
We all know that efficiency is important.

00:17:20.799 --> 00:17:22.839
It's one of the key tenets of programming.

00:17:22.839 --> 00:17:24.689
So it's a huge topic.

00:17:24.689 --> 00:17:30.309
And today, really, I want to focus specifically
on efficiency in terms of improving the battery

00:17:30.309 --> 00:17:35.870
life of your apps or reducing the impact on
the battery life from your apps.

00:17:35.870 --> 00:17:39.739
And even more specifically, I want to look
at how your use of the cell radio, so the

00:17:39.739 --> 00:17:47.100
way in which you transfer data, can impact
on your battery life.

00:17:47.100 --> 00:17:48.850
You guys already know about my email habit.

00:17:48.850 --> 00:17:52.529
I absolutely require email access all the
time.

00:17:52.529 --> 00:17:58.460
And if you add to that apps like Pandora,
Google Music, maps, all the other things which

00:17:58.460 --> 00:18:03.220
I take for granted, if I don't get eight to
12 hours of battery life out of my phone,

00:18:03.220 --> 00:18:05.149
it's a serious inconvenience.

00:18:05.149 --> 00:18:09.759
I can see a few folks in the audience, you're
thinking eight to 12 hours, is that a Jelly

00:18:09.759 --> 00:18:10.759
Bean feature?

00:18:10.759 --> 00:18:12.340
Are you running Cyanogen.

00:18:12.340 --> 00:18:14.559
It's none of that.

00:18:14.559 --> 00:18:18.679
Really, the way I achieve it is, I'm absolutely
brutal when it comes to removing apps that

00:18:18.679 --> 00:18:20.759
disproportionately drain my battery.

00:18:20.759 --> 00:18:24.399
So if I install something, look at it once,
and then find at the end of the day my battery

00:18:24.399 --> 00:18:28.100
life hasn't lasted as long as it did before,
I'm going to remove the new app.

00:18:28.100 --> 00:18:32.549
It doesn't matter how useful it is, it makes
my entire phone less useful, and so it's going

00:18:32.549 --> 00:18:33.789
to go.

00:18:33.789 --> 00:18:39.000
And when you're performing that analysis,
figuring out which apps are the worst offenders,

00:18:39.000 --> 00:18:42.559
it turns out that the way that they use the
cell radio is actually a big impact.

00:18:42.559 --> 00:18:47.090
And you can see that when you've got your
cell phone on and you're using cell data,

00:18:47.090 --> 00:18:52.659
it can be a significant battery drain.

00:18:52.659 --> 00:18:54.080
So how do we impact that?

00:18:54.080 --> 00:18:56.729
How do we reduce the impact of that battery?

00:18:56.729 --> 00:19:01.190
A big part of that is quite simply transferring
less data.

00:19:01.190 --> 00:19:05.669
So smaller pay loads, less-frequent updates,
just generally send less data.

00:19:05.669 --> 00:19:10.009
Now, I'm going to look at a few specific techniques
for improving that side of things as well.

00:19:10.009 --> 00:19:14.919
But first, I just want to think, is there
anything else we can do?

00:19:14.919 --> 00:19:18.850
Does the timing of your transfers impact the
battery life?

00:19:18.850 --> 00:19:23.769
Turns out, happily for the length of my talk
to the answer is yes, it can impact it.

00:19:23.769 --> 00:19:30.759
And it results in a scenario that I like to
think of as the cookie Droid conundrum.

00:19:30.759 --> 00:19:36.809
So I like the cookie Droid, we need to think
to ourselves, would we prefer one big cookie

00:19:36.809 --> 00:19:38.269
or lots of little cookies?

00:19:38.269 --> 00:19:44.090
Or to put it in slightly more practical terms,
do we want to have as many -- have lots of

00:19:44.090 --> 00:19:48.169
little downloads so that we're only downloading
data that we absolutely need, never downloading

00:19:48.169 --> 00:19:49.169
anything we don't?

00:19:49.169 --> 00:19:54.529
Or do we have one -- or as few downloads as
possible, we're downloading lots of information,

00:19:54.529 --> 00:19:57.831
potentially more than we need, in order to
have fewer downloads overall?

00:19:57.831 --> 00:20:01.299
A quick straw poll.

00:20:01.299 --> 00:20:03.460
Who likes one big cookie?

00:20:03.460 --> 00:20:04.899
All right.

00:20:04.899 --> 00:20:06.549
And who's into lots of little cookies?

00:20:06.549 --> 00:20:07.630
All right.

00:20:07.630 --> 00:20:11.700
And who thinks we should just go like the
cookie Droid and eat all the cookies?

00:20:11.700 --> 00:20:13.130
Yeah.

00:20:13.130 --> 00:20:16.399
Sadly, my metaphor does not extend that far.

00:20:16.399 --> 00:20:19.820
So we're going to have to look at the two
remaining options that we have.

00:20:19.820 --> 00:20:25.470
So the little cookie at first glance seems
like a fairly good approach.

00:20:25.470 --> 00:20:28.369
You're not going to download anything that
you don't need.

00:20:28.369 --> 00:20:29.590
So you're minimizing bandwidth.

00:20:29.590 --> 00:20:34.649
You're not processing anything that you don't
need, so you're going to save some power on

00:20:34.649 --> 00:20:36.109
the device that way.

00:20:36.109 --> 00:20:41.019
And, really, what it comes down to is, you're
going to put everything off until the last

00:20:41.019 --> 00:20:42.019
minute.

00:20:42.019 --> 00:20:45.110
You're not going to do anything until you're
absolutely certain that you need to do it.

00:20:45.110 --> 00:20:48.849
And that's an approach that I used pretty
extensively getting through college.

00:20:48.849 --> 00:20:49.849
Now, --
[ Laughter ]

00:20:49.849 --> 00:20:54.120
&gt;&gt;Reto Meier: -- as it turns out, both in
terms of college grades and in terms of cell

00:20:54.120 --> 00:20:56.940
radio efficiency, it's actually not a very
good idea.

00:20:56.940 --> 00:20:59.259
It's just going to cost you more in the end.

00:20:59.259 --> 00:21:03.899
And a much better approach is to use this
big cookie model, minimizing the number of

00:21:03.899 --> 00:21:09.809
times that you touch the network, the number
of times that you have to perform these downloads.

00:21:09.809 --> 00:21:13.220
And to understand why that is the case, you
need to understand a little bit about the

00:21:13.220 --> 00:21:17.149
way that the cell radio works.

00:21:17.149 --> 00:21:22.519
So this is a really simplified version of
a typical 3G cell radio.

00:21:22.519 --> 00:21:23.519
And it works this way.

00:21:23.519 --> 00:21:25.970
So you start off in standby mode.

00:21:25.970 --> 00:21:29.980
And every time you try and start a new connection,
transaction data, it's going to take around

00:21:29.980 --> 00:21:34.570
two seconds -- this varies, but around two
seconds -- to bring the radio up to full power,

00:21:34.570 --> 00:21:36.789
at which point you can start transferring
data.

00:21:36.789 --> 00:21:41.110
Now, if this is a browser, you can imagine,
this isn't a great experience.

00:21:41.110 --> 00:21:45.149
If every time you click a link, hit refresh,
hit some JavaScript, you need to wait two

00:21:45.149 --> 00:21:49.929
seconds before the radio powers up and you
can even make the request, let alone download

00:21:49.929 --> 00:21:52.739
the data, let alone render the data.

00:21:52.739 --> 00:21:57.749
And so to try and account for that, the cell
radio will stay in a full-power state for

00:21:57.749 --> 00:22:02.039
some amount of time, typically somewhere between
five and ten seconds, and what we call a tail

00:22:02.039 --> 00:22:03.470
time.

00:22:03.470 --> 00:22:08.759
So within that time frame, the radio is still
kept in high-power state, so you have latency

00:22:08.759 --> 00:22:11.299
if you want to perform further transactions.

00:22:11.299 --> 00:22:15.919
After that tail time has expired, you go into
this low-power state, draw about half as much

00:22:15.919 --> 00:22:18.309
power, and the latency is going to be reduced.

00:22:18.309 --> 00:22:21.080
It's still going to be there, but it's going
to be significantly reduced.

00:22:21.080 --> 00:22:25.580
Now, we're going to stay in that low power
state for somewhere between ten seconds to

00:22:25.580 --> 00:22:26.739
a minute.

00:22:26.739 --> 00:22:31.570
And, again, if nothing happens after that
period of time, we go back into standby state,

00:22:31.570 --> 00:22:34.830
where we're not drawing current, but we've
introduced this latency.

00:22:34.830 --> 00:22:39.710
Now, the specific tail times are going to
vary based on carrier.

00:22:39.710 --> 00:22:43.919
So that's going to be not just carrier, but
location, so East or West Coast, different

00:22:43.919 --> 00:22:48.510
countries, different carriers, different usage
patterns for their customers and everything

00:22:48.510 --> 00:22:49.510
else.

00:22:49.510 --> 00:22:55.429
And so AT&amp;T has a -- timings like this: Five
seconds for high-power tail time, 12 seconds

00:22:55.429 --> 00:22:56.859
for low-power.

00:22:56.859 --> 00:23:01.950
Vodafone has also five seconds for high power
and a full 30 seconds.

00:23:01.950 --> 00:23:04.409
Now, I should point out that there's no better
or worse.

00:23:04.409 --> 00:23:09.059
These are just different ways in which these
companies have figured out the most efficient

00:23:09.059 --> 00:23:11.269
patterns for their users in those locations.

00:23:11.269 --> 00:23:15.840
And it goes on and you can imagine it's the
same for Verizon, and T*Mobile and everyone

00:23:15.840 --> 00:23:16.840
else.

00:23:16.840 --> 00:23:22.479
So how do you, then, as a developer figure
out the best frequencies, the right timing

00:23:22.479 --> 00:23:28.080
to do your downloads in order to have minimal
impact on the battery?

00:23:28.080 --> 00:23:33.780
Well, everyone here is an engineer, so I assume
everyone's familiar with fast Fourier transforms.

00:23:33.780 --> 00:23:36.580
So we're going to start with this basic equation.

00:23:36.580 --> 00:23:41.909
And then what we want to do is, for each carrier,
find the square root of the sum of the squares

00:23:41.909 --> 00:23:45.200
of those delta tail times, divide that by
pi.

00:23:45.200 --> 00:23:46.929
So who's still with me?

00:23:46.929 --> 00:23:47.929
Got a couple.

00:23:47.929 --> 00:23:51.499
It's very impressive, because this is totally
made up.

00:23:51.499 --> 00:23:53.479
[ Laughter ]
[ Applause ]

00:23:53.479 --> 00:24:00.190
&gt;&gt;Reto Meier: If you can see my afterwards
and explain, that would be fantastic.

00:24:00.190 --> 00:24:03.419
[ Laughter ]
&gt;&gt;Reto Meier: So like I said, this is irrelevant.

00:24:03.419 --> 00:24:04.450
You don't -- it doesn't matter.

00:24:04.450 --> 00:24:06.599
It doesn't matter what the different tail
times are.

00:24:06.599 --> 00:24:09.730
It doesn't matter what the variation by carrier
is.

00:24:09.730 --> 00:24:13.650
All you need to know is that every time you
touch the Internet, every time you make a

00:24:13.650 --> 00:24:18.369
connection or do a transfer, you're potentially
going to continue draining battery for a full

00:24:18.369 --> 00:24:19.369
minute.

00:24:19.369 --> 00:24:20.649
Just think about that.

00:24:20.649 --> 00:24:24.259
So if you touch the Internet just to do a
ping, just to say, yes, someone is still looking

00:24:24.259 --> 00:24:29.870
at this page, the cell radio is going to stay
on and continue draining battery for up to

00:24:29.870 --> 00:24:30.999
a minute.

00:24:30.999 --> 00:24:35.289
This is much easier to understand if you have
a look at the visualization.

00:24:35.289 --> 00:24:40.710
So what you have here, in blue, the blue line
graph represents network traffic for my app.

00:24:40.710 --> 00:24:46.619
And so you can see the little periodic updates,
about every 15 seconds, and then we have these

00:24:46.619 --> 00:24:48.639
larger sort of intermittent transfer.

00:24:48.639 --> 00:24:53.549
So this could be a news app, where the periodic
transfer is analytics.

00:24:53.549 --> 00:24:58.110
We're keeping track of what page, what articles
people are reading at all times so that we

00:24:58.110 --> 00:25:01.690
can get a feel for what the most popular news
articles are.

00:25:01.690 --> 00:25:06.149
And the intermittent transfers, they may represent
someone clicking an article, all right.

00:25:06.149 --> 00:25:11.059
So they want to read the full text, you click
it, download it and read it.

00:25:11.059 --> 00:25:12.879
What's more interesting is underneath.

00:25:12.879 --> 00:25:15.509
That represents the cell radio state.

00:25:15.509 --> 00:25:18.080
Now, blue is an active transfer.

00:25:18.080 --> 00:25:21.869
This is when we're actively sending and receiving
data from our server.

00:25:21.869 --> 00:25:25.649
Red is that tail time, that high-power tail
time where the radio is still drawing full

00:25:25.649 --> 00:25:28.110
current, but we're not actually transferring
anything.

00:25:28.110 --> 00:25:33.049
And that will last for around five seconds,
in this instance, exactly five seconds.

00:25:33.049 --> 00:25:35.639
So you can see right at the beginning it was
on.

00:25:35.639 --> 00:25:37.429
Then we started another transfer straightaway.

00:25:37.429 --> 00:25:39.889
So it's continued in that high-power state.

00:25:39.889 --> 00:25:42.779
If five seconds elapse, it will turn yellow.

00:25:42.779 --> 00:25:45.019
That's when we're at that low-power state.

00:25:45.019 --> 00:25:50.440
And it will stay there for a further ten seconds,
assuming no one performs any transfers.

00:25:50.440 --> 00:25:53.639
Now once that time has elapsed, you'll go
back to the idle state.

00:25:53.639 --> 00:25:56.210
And that is represented here in green.

00:25:56.210 --> 00:26:00.090
Now, you probably notice the problem.

00:26:00.090 --> 00:26:01.090
There is no green.

00:26:01.090 --> 00:26:02.090
Right?

00:26:02.090 --> 00:26:06.549
So the entire time that this app is running,
it's drawing power from the battery.

00:26:06.549 --> 00:26:08.119
And you can see, it gets worse than that.

00:26:08.119 --> 00:26:15.200
Because even just this section in the middle,
where it's just the periodic transfers, we're

00:26:15.200 --> 00:26:17.630
still never going green.

00:26:17.630 --> 00:26:24.509
So even without the user doing anything, you're
still going to be drawing current, reducing

00:26:24.509 --> 00:26:27.019
your battery life, just by having the app
open.

00:26:27.019 --> 00:26:30.099
Now, this is exactly not what you want.

00:26:30.099 --> 00:26:31.480
So how do you solve this problem?

00:26:31.480 --> 00:26:35.669
Well, I like to think of it as defragmenting
your network traffic.

00:26:35.669 --> 00:26:40.789
What we're really trying to do is use a combination
of different things: Prefetching, bundling,

00:26:40.789 --> 00:26:44.549
basically trying to perform this big cookie
model, do as many things we can every time

00:26:44.549 --> 00:26:49.389
we touch the Internet so that we reduce this
intermittent touching so we have less and

00:26:49.389 --> 00:26:52.229
less time spent draining the battery.

00:26:52.229 --> 00:26:54.979
Now, I'm going to explain how you can do that.

00:26:54.979 --> 00:26:57.320
But, first of all, I just want to show you
exactly what I'm talking about.

00:26:57.320 --> 00:27:02.820
This is the same data being transferred, the
same amount of data, but everything has been

00:27:02.820 --> 00:27:03.820
batched together.

00:27:03.820 --> 00:27:08.201
So those periodic pinnings, those Analytics
updates, you've just batched them up and I

00:27:08.201 --> 00:27:11.429
only send them when I have something else
I need to do.

00:27:11.429 --> 00:27:13.350
When they get sent isn't important.

00:27:13.350 --> 00:27:18.470
Now, instead of having on-demand downloads
for the news articles, I'm going to prefetch

00:27:18.470 --> 00:27:19.470
them.

00:27:19.470 --> 00:27:23.389
I wrote this app, and I happen to know through
my Analytics data that people read exactly

00:27:23.389 --> 00:27:28.379
two articles every minute and I happen to
know exactly which two articles those are.

00:27:28.379 --> 00:27:31.960
So that's made it really easy for me to be
able to do this prefetching routine of two

00:27:31.960 --> 00:27:33.950
articles a minute.

00:27:33.950 --> 00:27:35.029
This is pretty contrived.

00:27:35.029 --> 00:27:38.750
But it's actually contrived in a way that
makes it not as effective as it could be.

00:27:38.750 --> 00:27:43.399
In a real-world solution, you can have this
window extend far further than the few seconds

00:27:43.399 --> 00:27:44.679
that I have here.

00:27:44.679 --> 00:27:49.839
But even with this contrived and basic solution,
you can see the impact is pretty dramatic.

00:27:49.839 --> 00:27:54.549
Straightaway, you've gone from having no green
to having almost two-thirds green.

00:27:54.549 --> 00:27:59.169
Even the active traffic has been reduced because
we're able to be much more efficient in the

00:27:59.169 --> 00:28:02.690
way we download our data by doing it all in
one go.

00:28:02.690 --> 00:28:07.629
So we've reduced both the active time and
the standby time so that we really are in

00:28:07.629 --> 00:28:12.179
a much better situation here, where the app
is not going to be draining the battery for

00:28:12.179 --> 00:28:16.539
anywhere near the amount of time that it was
before.

00:28:16.539 --> 00:28:17.869
So how do we create these graphs?

00:28:17.869 --> 00:28:20.360
How do we figure out what our app is doing
and how to make it better?

00:28:20.360 --> 00:28:23.869
There are a number of tools available for
doing just that.

00:28:23.869 --> 00:28:27.159
On the most basic level, you can use logcat.

00:28:27.159 --> 00:28:32.009
So you can just print log statements before
and after you started doing your transfers,

00:28:32.009 --> 00:28:35.460
potentially even keep track of how much data
you're transferring each time in order to

00:28:35.460 --> 00:28:40.159
build up these graphs and this idea of how
your app is behaving.

00:28:40.159 --> 00:28:45.539
Another option is the arrow tool, which is
a free open source tool available from AT&amp;T,

00:28:45.539 --> 00:28:48.469
who I think are actually demoing it out in
a sandbox.

00:28:48.469 --> 00:28:51.100
You should stop by and say hi to them.

00:28:51.100 --> 00:28:54.489
The advantage of their tool is that it's going
to produce graphs very much like the ones

00:28:54.489 --> 00:28:55.950
I showed in the previous slide.

00:28:55.950 --> 00:28:59.570
So they're going to show you your network
traffic and they're going to overlay your

00:28:59.570 --> 00:29:04.349
radio state, specifically, the AT&amp;T timings.

00:29:04.349 --> 00:29:08.149
Another approach, which I actually quite like,
and this is more recently available, is the

00:29:08.149 --> 00:29:12.590
network statistics tab in the DDMS view of
your Android developer tools.

00:29:12.590 --> 00:29:14.039
That's the app that you can see here.

00:29:14.039 --> 00:29:16.080
This colorful graph.

00:29:16.080 --> 00:29:20.719
So this lets you tag different sockets, different
parts of your app so you can see how they're

00:29:20.719 --> 00:29:23.539
all interacting, as you can here, using different
colors.

00:29:23.539 --> 00:29:26.379
And you can do that using the traffic stats
class.

00:29:26.379 --> 00:29:28.779
This is a relatively new class.

00:29:28.779 --> 00:29:32.989
The beauty of all of this stuff is that you
can use it on your app even if you're targeting

00:29:32.989 --> 00:29:35.039
early versions of Android.

00:29:35.039 --> 00:29:38.039
You can do this analysis statically in the
emulator.

00:29:38.039 --> 00:29:41.609
So you can do this for -- no matter what your
target is, even if you're not targeting later

00:29:41.609 --> 00:29:44.089
versions of Android, you can still perform
the analysis.

00:29:44.089 --> 00:29:49.169
So the way this works is, you simply assign
a tag to each of your output sockets.

00:29:49.169 --> 00:29:53.629
They color code it, and you're able to see
exactly how your app interacts with other

00:29:53.629 --> 00:29:55.429
components.

00:29:55.429 --> 00:29:58.289
And you can look out for patterns, which I'm
going to go into a little bit more detail

00:29:58.289 --> 00:30:00.070
on.

00:30:00.070 --> 00:30:04.149
If you're not using sockets directly, if you're
using an HTTP client, then you can simply

00:30:04.149 --> 00:30:08.509
set the thread stats tag on the thread itself,
and that will automatically be assigned to

00:30:08.509 --> 00:30:14.059
the socket used by that HTTP client, making
life a little bit easier for you.

00:30:14.059 --> 00:30:15.570
So now you've got the grass.

00:30:15.570 --> 00:30:18.669
The next step is, what are you looking for.

00:30:18.669 --> 00:30:21.169
So the first thing you're looking for is these
short spikes.

00:30:21.169 --> 00:30:24.799
So this represents -- each of these spikes
is one second.

00:30:24.799 --> 00:30:29.839
And so we're looking for both short in terms
of height and in duration, particularly duration.

00:30:29.839 --> 00:30:33.380
Because here we are downloading for a second.

00:30:33.380 --> 00:30:37.089
And each time we do that, the device is going
to be drawing battery for a minute, so that's

00:30:37.089 --> 00:30:38.089
a really bad deal.

00:30:38.089 --> 00:30:41.529
So you want to look for anything like that
and typically these are going to be good things

00:30:41.529 --> 00:30:42.830
which can be delayed.

00:30:42.830 --> 00:30:44.339
They can be bundled up.

00:30:44.339 --> 00:30:49.469
They can be queued, so you can download them
in all in one go later.

00:30:49.469 --> 00:30:52.639
Another really bad sign is anything periodic.

00:30:52.639 --> 00:30:57.469
Anything which is happening on a set basis
because this stuff is basically guarantying

00:30:57.469 --> 00:31:00.630
a minimum amount of time that your app is
going to be drawing power.

00:31:00.630 --> 00:31:02.629
That's not what you want.

00:31:02.629 --> 00:31:07.299
The minimum possible time that your app should
be drawing power from the cell radio is zero.

00:31:07.299 --> 00:31:09.609
The user is doing nothing, it hasn't done
anything.

00:31:09.609 --> 00:31:11.610
It shouldn't draw any power.

00:31:11.610 --> 00:31:15.159
This is a really bad sign.

00:31:15.159 --> 00:31:18.559
Slightly less concerning but still an area
that you can look to improve is these batches

00:31:18.559 --> 00:31:21.700
of activities which happen in close proximity.

00:31:21.700 --> 00:31:26.379
So here they are not unreasonable transfers
but there's this gap, this few seconds between

00:31:26.379 --> 00:31:27.379
each of them.

00:31:27.379 --> 00:31:31.340
And in that gap, we are still drawing battery,
so just by pushing them together, we can have

00:31:31.340 --> 00:31:33.539
that incremental improvement.

00:31:33.539 --> 00:31:36.129
So let's have a look at some solutions.

00:31:36.129 --> 00:31:40.849
What can we do to try to improve this to defragment
our traffic?

00:31:40.849 --> 00:31:42.389
One of those approaches is prefetching.

00:31:42.389 --> 00:31:47.440
Now, what you've got to remember is that when
the cell radio, when the carrier are working

00:31:47.440 --> 00:31:52.779
out what is the right timing for these tell
times, this is what they are trying to balance.

00:31:52.779 --> 00:31:55.620
Minimize the latency and minimize the battery
life.

00:31:55.620 --> 00:31:57.330
One plays off against the other.

00:31:57.330 --> 00:31:58.659
They don't have a choice.

00:31:58.659 --> 00:32:01.049
This is the graph they are on.

00:32:01.049 --> 00:32:06.059
From our perspective, from our user perspective,
this is exactly the wrong graph.

00:32:06.059 --> 00:32:07.059
We don't want that.

00:32:07.059 --> 00:32:08.720
What we want is to hit this sweet spot.

00:32:08.720 --> 00:32:13.089
Where we have got basically zero latency and
maximum battery life.

00:32:13.089 --> 00:32:15.440
That's what we are trying to achieve.

00:32:15.440 --> 00:32:20.389
Now, the idea of prefetching, you kind of
get the best of both worlds.

00:32:20.389 --> 00:32:25.460
If it is already downloaded, it is already
processed, then you don't need to wait for

00:32:25.460 --> 00:32:27.940
it to process it again.

00:32:27.940 --> 00:32:31.109
At the same time, if you've prefetched it,
if you've bundled everything together, you

00:32:31.109 --> 00:32:36.059
are not getting this spike, this intermittent
download, in the middle your app's life cycle.

00:32:36.059 --> 00:32:41.409
It's already there, and you can much more
manage the frequency of those downloads.

00:32:41.409 --> 00:32:44.759
Now, unfortunately, prefetching isn't a silver
bullet.

00:32:44.759 --> 00:32:46.429
There is a risk.

00:32:46.429 --> 00:32:49.409
There's a risk that you will download a bunch
of data that you don't need.

00:32:49.409 --> 00:32:54.139
That's going to drain the battery just as
sufficiently or just as effectively.

00:32:54.139 --> 00:32:55.799
So how do you make that balance?

00:32:55.799 --> 00:32:59.159
Well, generally what you want to do is make
sure that whatever you are going to download

00:32:59.159 --> 00:33:01.320
is going to be used by the app.

00:33:01.320 --> 00:33:04.269
What you're trying to avoid doing is downloading
something that you know you are going to need

00:33:04.269 --> 00:33:06.070
later so you do it ahead of time.

00:33:06.070 --> 00:33:09.789
Typically, that is somewhere in the realm
of two to five minutes.

00:33:09.789 --> 00:33:13.249
Now this depends on your app, the way that
it's used.

00:33:13.249 --> 00:33:17.299
A lot of apps have sort of this two- to five-minute
window where they expect people to use them.

00:33:17.299 --> 00:33:21.499
If you have something like a music player,
the window may be significantly longer.

00:33:21.499 --> 00:33:25.120
The amount of data is also going to vary.

00:33:25.120 --> 00:33:29.120
It's usually somewhere around one to five
megs, but this is going to vary on the cell

00:33:29.120 --> 00:33:34.049
radio technology, its effectiveness, as well
as your app.

00:33:34.049 --> 00:33:37.639
Practically speaking, if you've got something
like a music player, you probably want to

00:33:37.639 --> 00:33:42.440
download the currently playing song in its
entirety and probably the next song as well,

00:33:42.440 --> 00:33:45.349
but probably not the play list, probably not
the album.

00:33:45.349 --> 00:33:46.519
All right?

00:33:46.519 --> 00:33:48.440
If you have got a news app, you can be a lot
more aggressive.

00:33:48.440 --> 00:33:50.049
We are talking about text.

00:33:50.049 --> 00:33:51.129
Text is cheap.

00:33:51.129 --> 00:33:52.399
You can download heaps.

00:33:52.399 --> 00:33:55.559
You can download all the headlines and all
of your categories.

00:33:55.559 --> 00:33:59.909
You know what, you should probably download
some of the article text as well.

00:33:59.909 --> 00:34:03.739
You can either do this simplistically, say,
well, this is my front page, I'm just going

00:34:03.739 --> 00:34:08.500
to start prefetching things based on when
they appear to the user.

00:34:08.500 --> 00:34:11.619
You can be a little more clever and use Analytics.

00:34:11.619 --> 00:34:15.220
70% of the people who use my app read these
articles.

00:34:15.220 --> 00:34:16.540
I'm going to prefetch them for everyone.

00:34:16.540 --> 00:34:21.830
Or make it more personal and say this user
always reads all the sports articles, I'm

00:34:21.830 --> 00:34:23.429
going to pull them out.

00:34:23.429 --> 00:34:28.139
Really, it's just a matter of trying to figure
out what is most likely to be used so I don't

00:34:28.139 --> 00:34:33.589
have to pull it down later without pulling
down things that isn't going to be used.

00:34:33.589 --> 00:34:35.230
I mentioned this is for 3G, these specific
timings.

00:34:35.230 --> 00:34:40.010
The thing is, it changes depending on the
cell radio that you are using.

00:34:40.010 --> 00:34:41.010
They have different efficiencies.

00:34:41.010 --> 00:34:43.149
They have different speeds.

00:34:43.149 --> 00:34:47.149
In this example, we will start with a default
based on a 3G network radio.

00:34:47.149 --> 00:34:50.210
There's a lot of code here, but it's effectively
just a couple of switch statements.

00:34:50.210 --> 00:34:54.200
All we are doing is checking, what is your
network technology.

00:34:54.200 --> 00:34:58.300
If it's 4G, then we've got two things at play.

00:34:58.300 --> 00:35:01.980
These radios, they tend to drain a little
more battery than their 3G equivalents.

00:35:01.980 --> 00:35:05.529
They are also faster, so you can download
more over the same time period.

00:35:05.529 --> 00:35:10.940
If you are trying to balance the cost of the
device going to be drawing current for a minute,

00:35:10.940 --> 00:35:15.690
so I want to download for at least ten seconds,
you want to download more on a faster network.

00:35:15.690 --> 00:35:17.940
The reverse is true for 2G.

00:35:17.940 --> 00:35:19.330
It's slower.

00:35:19.330 --> 00:35:20.769
It's slightly more energy efficient.

00:35:20.769 --> 00:35:23.150
So you want to download less data.

00:35:23.150 --> 00:35:26.910
Now, the specifics, I've gone times 4 times
2 is kind of arbitrary.

00:35:26.910 --> 00:35:31.990
This is something you need to figure out within
your own experience what makes sense for your

00:35:31.990 --> 00:35:33.240
data and for your app.

00:35:33.240 --> 00:35:36.280
The key here is to remember it is going to
vary.

00:35:36.280 --> 00:35:38.549
This is especially the case with Wi-Fi.

00:35:38.549 --> 00:35:43.200
So on Wi-Fi you don't have a cell radio cost
associated with performing these downloads.

00:35:43.200 --> 00:35:44.579
You can be much more aggressive.

00:35:44.579 --> 00:35:50.030
In this example, I've simply said download
the maximum amount that we can to put in our

00:35:50.030 --> 00:35:51.030
cache.

00:35:51.030 --> 00:35:54.381
This is going to be much more dependent on
how much data do we want on the device, what's

00:35:54.381 --> 00:36:03.750
the relative cost of processing, rather than
cost of putting things on the network.

00:36:03.750 --> 00:36:08.460
So that's fine for apps, for data that we
know we are going to need.

00:36:08.460 --> 00:36:11.650
You can prefetch things if you know eventually
it's going to have to happen.

00:36:11.650 --> 00:36:15.790
But what do you do about things that happen
which are user initiated, things which you

00:36:15.790 --> 00:36:18.480
don't know you are going to need ahead of
time because they are going to change because

00:36:18.480 --> 00:36:21.700
the user has created them while they are using
the app.

00:36:21.700 --> 00:36:25.200
The key here is to try and bundle them all
together.

00:36:25.200 --> 00:36:26.640
You are trying to be as efficient as possible.

00:36:26.640 --> 00:36:30.589
You're not -- you are bundling them, batching
them, you're doing whatever you can, trying

00:36:30.589 --> 00:36:37.089
to make sure they aren't draining the battery
when you don't need them to.

00:36:37.089 --> 00:36:41.000
One solution for that is to use a batch queue
for anything periodic.

00:36:41.000 --> 00:36:44.819
So this is for things which user created by
aren't time sensitive.

00:36:44.819 --> 00:36:47.400
So Analytics are a great example of this.

00:36:47.400 --> 00:36:51.040
Anything where you don't need the server to
provide you a response, you just need to upload

00:36:51.040 --> 00:36:52.890
it at some stage.

00:36:52.890 --> 00:36:54.910
They work really well here.

00:36:54.910 --> 00:36:59.500
So you can see, in this example, what we are
doing is every time we have something periodic,

00:36:59.500 --> 00:37:03.250
which we want to send to the server, we will
add it to a queue, and then we are going to

00:37:03.250 --> 00:37:05.010
execute that queue at a certain point.

00:37:05.010 --> 00:37:10.281
You know importantly here, that when we do
execute that queue, when we transfer these

00:37:10.281 --> 00:37:14.170
all these bundled periodic transfers, we will
also execute the next prefetch.

00:37:14.170 --> 00:37:17.490
That may not be scheduled to happen for another
minute or two.

00:37:17.490 --> 00:37:21.079
But hey, we have the radio turned on, why
not, right?

00:37:21.079 --> 00:37:22.079
Do it all now.

00:37:22.079 --> 00:37:26.400
Get it out of the way, and then we don't have
to turn the radio on again later.

00:37:26.400 --> 00:37:30.119
The same thing is true when you have time-sensitive,
on-demand transfers.

00:37:30.119 --> 00:37:33.740
So when your user is uploading a photo or
if you want to get feedback directly from

00:37:33.740 --> 00:37:36.670
the server, it needs to happen then and there.

00:37:36.670 --> 00:37:39.720
That's no reason not to bundle everything
else together as well.

00:37:39.720 --> 00:37:43.809
So when you do have these time sensitive transfers,
you execute the next prefetch.

00:37:43.809 --> 00:37:47.440
When you do that, you execute your periodic
transfers as well.

00:37:47.440 --> 00:37:50.640
It all comes back to the same underlying philosophy.

00:37:50.640 --> 00:37:54.609
Every time you touch the Internet, do everything
which you think you may need to do for the

00:37:54.609 --> 00:37:58.970
next few minutes at once.

00:37:58.970 --> 00:37:59.970
That's all good and well.

00:37:59.970 --> 00:38:05.940
But what happens to the data that is server
side but you still need to get regularly updated?

00:38:05.940 --> 00:38:09.280
So you have a news app and you want to get
new headlines or weather app and you need

00:38:09.280 --> 00:38:10.970
to know what the current temperature is.

00:38:10.970 --> 00:38:14.099
These are things which traditionally you're
going to do by polling.

00:38:14.099 --> 00:38:17.760
How can we make this a more efficient process?

00:38:17.760 --> 00:38:22.329
Fundamentally, we want to make it less frequent
and less regular to try to get away from the

00:38:22.329 --> 00:38:25.680
bad patterns we have seen earlier.

00:38:25.680 --> 00:38:28.559
First thing we can do is everyone's favorite,
inexact repeating alarms.

00:38:28.559 --> 00:38:31.770
It wouldn't be I/O if I didn't present this
slide.

00:38:31.770 --> 00:38:35.900
Basically, this will going to let the framework
do what we have been talking about for us.

00:38:35.900 --> 00:38:41.480
It will phase shift our alarms so all the
downloads at the same time as other apps download

00:38:41.480 --> 00:38:42.830
around a similar time frame.

00:38:42.830 --> 00:38:48.180
Rather than each app waking up the device
every five minutes, it all happens at once.

00:38:48.180 --> 00:38:50.329
This is a good start.

00:38:50.329 --> 00:38:51.330
But it's pretty simplistic.

00:38:51.330 --> 00:38:52.970
So what else can we do?

00:38:52.970 --> 00:38:58.039
One approach is to use what I think of as
an inactivity back-off.

00:38:58.039 --> 00:39:02.650
So what's happening here is we will set a
default for how often we should do our background

00:39:02.650 --> 00:39:03.650
updates.

00:39:03.650 --> 00:39:05.640
Now, if you've had to do this, you know this
is a balance.

00:39:05.640 --> 00:39:10.041
This is a payoff where you are thinking, how
frequently can I do these updates so that

00:39:10.041 --> 00:39:14.400
the data is as fresh as it can be but we are
not draining the battery by updating every

00:39:14.400 --> 00:39:15.630
five minutes in the background.

00:39:15.630 --> 00:39:18.769
It's always this balance.

00:39:18.769 --> 00:39:22.049
What I'm suggesting we do here instead is
to say, well, let's start with that.

00:39:22.049 --> 00:39:26.380
But if the user doesn't open the app since
the last time we have done a refresh, that

00:39:26.380 --> 00:39:27.380
was wasted.

00:39:27.380 --> 00:39:28.829
Let's wait twice as long next time.

00:39:28.829 --> 00:39:37.970
They still haven't touched it, wait twice
as long again, so on and so forth.

00:39:37.970 --> 00:39:43.200
If they exit it and never look at it again.

00:39:43.200 --> 00:39:44.609
Hopefully that doesn't happen.

00:39:44.609 --> 00:39:47.430
But if it does, your app isn't going to drain
the battery.

00:39:47.430 --> 00:39:50.900
They don't have a reason to uninstall it.

00:39:50.900 --> 00:39:56.680
I think this is a really good alternative
to trying to create that sort of -- that solution

00:39:56.680 --> 00:39:58.680
where you are trying to find that balance.

00:39:58.680 --> 00:40:02.430
So that's something we definitely should consider
as a default.

00:40:02.430 --> 00:40:07.400
Obviously, it's always useful to have an option
for uses to manually set every fresh frequency,

00:40:07.400 --> 00:40:10.289
to say, well, actually, I want it to be more
or less frequent than this.

00:40:10.289 --> 00:40:16.190
But this is kind of a more efficient way of
being able to do that first step.

00:40:16.190 --> 00:40:20.500
So I also mentioned early on that my retry
mechanism was overly simplistic.

00:40:20.500 --> 00:40:21.539
It was inefficient.

00:40:21.539 --> 00:40:23.240
I learned this the hard way.

00:40:23.240 --> 00:40:26.740
A few years ago I built a widget for Google
desktop.

00:40:26.740 --> 00:40:31.030
Anybody remember Google desktop?

00:40:31.030 --> 00:40:35.270
What this did, it's great for a cricket info
website to get test match cricket scores.

00:40:35.270 --> 00:40:39.509
As everyone knows, the fate of a match can
hinge on a single ball.

00:40:39.509 --> 00:40:42.700
I had an aggressive update frequency of every
minute.

00:40:42.700 --> 00:40:45.799
Every minute I would hit the server and scrape
the web page, find out the score.

00:40:45.799 --> 00:40:49.410
I would look for a little string that would
say the match had completed at which point

00:40:49.410 --> 00:40:51.950
I would stop doing my updates.

00:40:51.950 --> 00:40:52.950
This worked really well.

00:40:52.950 --> 00:40:56.000
I was a friend of mine who was beta testing
it at work.

00:40:56.000 --> 00:40:59.450
He went home on a Friday before the match
finished.

00:40:59.450 --> 00:41:03.630
By the time he came back on Monday, he got
the 404 page.

00:41:03.630 --> 00:41:05.220
That's a pretty busy 404 page.

00:41:05.220 --> 00:41:08.130
In fact, it's 131K of 404 page.

00:41:08.130 --> 00:41:12.109
I was hitting that every minute for every
hour every day.

00:41:12.109 --> 00:41:17.460
After a week, we've got one and quarter gig
of download which he discovered when the net

00:41:17.460 --> 00:41:21.069
ops came past his desk to see if he was doing
bit parenting.

00:41:21.069 --> 00:41:24.810
Imagine this on a mobile device.

00:41:24.810 --> 00:41:27.950
4 gigs a month, that sounds -- or 5 gigs a
month.

00:41:27.950 --> 00:41:32.610
That actually sounds a like the fair use quota
use for tariffs.

00:41:32.610 --> 00:41:34.740
This isn't good.

00:41:34.740 --> 00:41:42.390
If you have a simplistic 404 page or API which
returns with an error code, your data is going

00:41:42.390 --> 00:41:46.470
to be a lot less but you're still doing periodic
updates, you're still going to drain the battery

00:41:46.470 --> 00:41:49.450
just so the app knows something isn't working.

00:41:49.450 --> 00:41:51.180
Not a good approach.

00:41:51.180 --> 00:41:53.910
Solution here is that same back-off.

00:41:53.910 --> 00:41:54.910
Exponential back-off.

00:41:54.910 --> 00:41:56.599
Here I'm doing it using a recursive algorithm.

00:41:56.599 --> 00:42:00.400
For your apps, you will want to use something
like alarms.

00:42:00.400 --> 00:42:05.410
The key here is that, if it doesn't work,
wait twice as long next time and keep extending

00:42:05.410 --> 00:42:06.920
that.

00:42:06.920 --> 00:42:11.230
On a phone, you probably want to get to that
maximum interval, say, you know what, it's

00:42:11.230 --> 00:42:15.549
not working, forget it, show something to
the user, do something within your app to

00:42:15.549 --> 00:42:16.549
account for that.

00:42:16.549 --> 00:42:19.920
There's no value in continuing to try something
that clearly isn't working.

00:42:19.920 --> 00:42:25.720
Now, what's a better alternative to this background
polling, trying to make that more efficient,

00:42:25.720 --> 00:42:28.269
is to use Google Cloud messaging instead.

00:42:28.269 --> 00:42:30.250
This has been re-released now.

00:42:30.250 --> 00:42:34.099
Eliminate polling completely if you have control
over the server.

00:42:34.099 --> 00:42:39.500
So you just register your device to your server
into Google Cloud messaging.

00:42:39.500 --> 00:42:43.769
Instead of you polling the server, the server
sends your device direct messages when it

00:42:43.769 --> 00:42:46.650
has something to update.

00:42:46.650 --> 00:42:50.170
This is so much more powerful because you're
no longer trying to figure out that balance

00:42:50.170 --> 00:42:53.259
between how often should I ping the server
to check to see if there is something there

00:42:53.259 --> 00:42:55.480
in order to provide fresh data.

00:42:55.480 --> 00:42:57.769
You just get told by the server when there
is no data.

00:42:57.769 --> 00:43:00.799
Then you can make a decision as to, do I want
to download that now.

00:43:00.799 --> 00:43:03.470
Do I want to wait until the next prefetch
interval.

00:43:03.470 --> 00:43:04.470
What is that data?

00:43:04.470 --> 00:43:08.220
You can send all that information and provide
a much more efficient solution.

00:43:08.220 --> 00:43:11.500
So I'm not going into too much detail.

00:43:11.500 --> 00:43:17.170
The key to it is it is available back to Android
2.2, 94% of the devices.

00:43:17.170 --> 00:43:21.420
In addition to all of these new features,
it has a significantly simpler authentication

00:43:21.420 --> 00:43:22.849
story using API key.

00:43:22.849 --> 00:43:26.700
So it is much easier to use on the server
side if you're not a server side developer,

00:43:26.700 --> 00:43:30.180
which I'm not, so this was a big thing for
me.

00:43:30.180 --> 00:43:33.430
It's -- actually the next session done in
room 9 downstairs is all about Google Cloud

00:43:33.430 --> 00:43:34.430
messaging.

00:43:34.430 --> 00:43:38.690
If it is of interest to you, it should be
if it isn't, definitely go and check that

00:43:38.690 --> 00:43:41.520
out.

00:43:41.520 --> 00:43:42.930
So this kind of goes without saying.

00:43:42.930 --> 00:43:46.960
I'm going to say it anyway because it seems
fitting, redundant downloads are redundant.

00:43:46.960 --> 00:43:50.160
Don't download anything you have already downloaded.

00:43:50.160 --> 00:43:52.519
There's a few ways you can do that.

00:43:52.519 --> 00:43:54.769
You want to make sure you filter anything
on the server.

00:43:54.769 --> 00:43:59.660
Use APIs, which will let you say there is
the last piece of data that I got.

00:43:59.660 --> 00:44:04.119
Or this is the last time I did my updates,
so only send me things more recent than that.

00:44:04.119 --> 00:44:05.700
So that's kind of fundamental.

00:44:05.700 --> 00:44:09.109
Then you're not having to process things,
not having to download things which you have

00:44:09.109 --> 00:44:10.441
already downloaded in the past.

00:44:10.441 --> 00:44:14.119
The same thing goes for any processing that
you are going to do on all of that data.

00:44:14.119 --> 00:44:18.880
If you download an image and you're going
to display it as a 72 pixel thumbnail, there's

00:44:18.880 --> 00:44:21.910
probably no reason to download the full wallpaper.

00:44:21.910 --> 00:44:25.980
Much easier, more efficient for you to be
able to do that stuff on the server.

00:44:25.980 --> 00:44:31.109
Much easier to throw resources on server side
solution than to hope all your users are going

00:44:31.109 --> 00:44:32.869
to buy faster, better phones.

00:44:32.869 --> 00:44:36.650
So anything you can do server side, do it
server side.

00:44:36.650 --> 00:44:38.839
When you have downloaded it, make sure you
cache it.

00:44:38.839 --> 00:44:39.839
Cache everything.

00:44:39.839 --> 00:44:41.270
You have a couple of alternatives.

00:44:41.270 --> 00:44:43.080
You can store it in the external cache.

00:44:43.080 --> 00:44:47.160
Now this requires a new permission in Jelly
Bean to write to the external storage.

00:44:47.160 --> 00:44:51.000
It's also (indiscernible) readable, so it's
kinda awesome.

00:44:51.000 --> 00:44:55.010
If you use the internal cache, that's going
to be within your application sandbox, so

00:44:55.010 --> 00:44:56.569
it's going to be controlled by you.

00:44:56.569 --> 00:45:01.400
It's going to be also managed by the system,
which means if it becomes under resource pressure,

00:45:01.400 --> 00:45:05.230
it's going to be able to clean out your cache
in order to save it some room.

00:45:05.230 --> 00:45:08.390
This is the best approach.

00:45:08.390 --> 00:45:12.170
Another thing you can do is make sure that
you don't download anything that you don't

00:45:12.170 --> 00:45:13.170
have to.

00:45:13.170 --> 00:45:18.650
So you can do that by inspecting the headers
of your http responses.

00:45:18.650 --> 00:45:20.490
So you can check when does this data expire?

00:45:20.490 --> 00:45:21.951
When was the last time it was updated?

00:45:21.951 --> 00:45:24.569
Do I need to download the body here?

00:45:24.569 --> 00:45:27.880
When should I try and update all of this information?

00:45:27.880 --> 00:45:30.560
So that can be really useful.

00:45:30.560 --> 00:45:38.000
Even better is that in Android 4.0 we introduced
a http response cache to the http URL connection

00:45:38.000 --> 00:45:39.180
class.

00:45:39.180 --> 00:45:47.680
So this is just using a reflection to turn
on a 10 meg cache on a http URL connection.

00:45:47.680 --> 00:45:51.210
What this does is it is going to do all of
the stuff that I just explained for you.

00:45:51.210 --> 00:45:55.410
It's going to create his own cache, inspect
the expired headings and every time you make

00:45:55.410 --> 00:45:59.349
a request, it is going to check to see whether
it already has that data and whether or not

00:45:59.349 --> 00:46:00.349
it has expired.

00:46:00.349 --> 00:46:04.020
If it has it and it hasn't expired, it's just
going to serve you from the cache and put

00:46:04.020 --> 00:46:06.200
it into the cache automatically for you.

00:46:06.200 --> 00:46:10.850
This is a really neat trick to be able to
take away a lot of that hard work from you.

00:46:10.850 --> 00:46:13.260
So that's almost done with efficiency.

00:46:13.260 --> 00:46:17.099
If you want to have all of this information
without my strangely monotonic Australian

00:46:17.099 --> 00:46:23.000
accent, it much easier copy/paste code snippets,
then you can get it all from the developer

00:46:23.000 --> 00:46:26.430
training site at developer.android.com/training.

00:46:26.430 --> 00:46:28.880
It will be all there for you.

00:46:28.880 --> 00:46:33.140
I've spoken in this section about efficiency,
specifically about battery life, specifically

00:46:33.140 --> 00:46:34.970
about the cell radio.

00:46:34.970 --> 00:46:39.490
Jeff Sharkey is doing a session in this room
at 4 o'clock today which is going to cover

00:46:39.490 --> 00:46:44.670
a whole bunch of other efficiency things you
can do with CPU, with memory, with I/O, definitely

00:46:44.670 --> 00:46:45.750
check that out.

00:46:45.750 --> 00:46:47.609
So we have a few minutes left.

00:46:47.609 --> 00:46:59.660
I've got one last section, this will be the
shortest.

00:46:59.660 --> 00:47:19.900
[ Video ]
[ Applause ]

00:47:19.900 --> 00:47:55.690
&gt;&gt;Reto Meier: Relatability is something we
all want.

00:47:55.690 --> 00:48:00.640
If your power stops power your devices, if
your water starts running, it's kind of a

00:48:00.640 --> 00:48:01.640
big deal.

00:48:01.640 --> 00:48:04.839
But if it works, you just totally ignore it.

00:48:04.839 --> 00:48:05.920
And that's exactly what you want.

00:48:05.920 --> 00:48:08.920
You want to be able to take these sorts of
things for granted.

00:48:08.920 --> 00:48:10.259
So how can you do that?

00:48:10.259 --> 00:48:14.359
How can you create an app which is properly
reliable.

00:48:14.359 --> 00:48:15.980
So part of that is static analysis.

00:48:15.980 --> 00:48:20.640
You can use tools like Lint, like strict mode
will let you have a look at how your apps

00:48:20.640 --> 00:48:21.740
are working.

00:48:21.740 --> 00:48:25.880
I kind of like to think of these as a lot
like a peer review.

00:48:25.880 --> 00:48:29.210
Someone who already knows all of the right
stuff, probably the same stuff as you, maybe

00:48:29.210 --> 00:48:32.460
a little bit more, and they are able to give
you code a look over to tell you whether or

00:48:32.460 --> 00:48:34.880
not you are doing the right thing.

00:48:34.880 --> 00:48:38.930
Now, so, yeah, basically a peer review but
without the self-loathing and recriminations

00:48:38.930 --> 00:48:42.150
that so often accompany a good peer reviewing.

00:48:42.150 --> 00:48:46.970
Once you get past that though, you really
need to see how your app is going to work

00:48:46.970 --> 00:48:49.520
on devices, that means buying devices.

00:48:49.520 --> 00:48:54.950
There's thousands of Android devices, certainly
no one is going to expect anyone to buy all

00:48:54.950 --> 00:48:57.240
of them, certainly Google hasn't.

00:48:57.240 --> 00:48:58.999
So what is an alternative solution?

00:48:58.999 --> 00:49:04.700
Well, one thing from talking to developers
trying to solve this problem is find ways

00:49:04.700 --> 00:49:06.470
to separate that market.

00:49:06.470 --> 00:49:10.420
Now, what I've done here are separated into
buckets in terms of screen size and screen

00:49:10.420 --> 00:49:11.420
resolution.

00:49:11.420 --> 00:49:14.510
Now, this is no longer the way that you should
be designing your screen layouts.

00:49:14.510 --> 00:49:17.299
You are not trying to design screen layouts
in terms of these buckets.

00:49:17.299 --> 00:49:21.440
You are trying to use minimum screen widths
and make sure that you create an app that

00:49:21.440 --> 00:49:23.069
scales within those bounds.

00:49:23.069 --> 00:49:28.769
But in terms of choosing apps, choosing devices
to test your apps, this is actually still

00:49:28.769 --> 00:49:30.130
a pretty good approach.

00:49:30.130 --> 00:49:32.309
So you are now down to 16 buckets.

00:49:32.309 --> 00:49:35.491
As you choose each of the devices from that,
you want to try and create something that

00:49:35.491 --> 00:49:37.980
is as varied as possible.

00:49:37.980 --> 00:49:41.859
So you want to get devices with different
GPUs, different manufacturers, some which

00:49:41.859 --> 00:49:46.411
have cameras, some which have slide-out keyboards,
touch screens, et cetera, et cetera, and that

00:49:46.411 --> 00:49:49.690
will give you a nice cross-section to test
with.

00:49:49.690 --> 00:49:51.789
That's kind of still a lot of devices.

00:49:51.789 --> 00:49:57.309
So if your budget is a little bit more limited,
you can kind of focus on the areas which are

00:49:57.309 --> 00:50:01.690
going to represent the largest part of your
audience.

00:50:01.690 --> 00:50:06.049
So you can see here that that pretty much
comes down to smartphones and ten-inch tablets

00:50:06.049 --> 00:50:07.049
at the moment.

00:50:07.049 --> 00:50:09.760
This is based on the numbers on the Android
developer site.

00:50:09.760 --> 00:50:14.130
And that will give you a pretty good coverage,
right?

00:50:14.130 --> 00:50:15.130
That's only three devices.

00:50:15.130 --> 00:50:19.740
The only problem here is that you're actually
possibly limiting yourself.

00:50:19.740 --> 00:50:20.740
What comes next?

00:50:20.740 --> 00:50:23.040
These are the devices that are out there now.

00:50:23.040 --> 00:50:25.422
But you all have Nexus 7s now.

00:50:25.422 --> 00:50:30.499
At $199, I feel there will be a bunch these
devices in people's hands.

00:50:30.499 --> 00:50:36.980
Plus all the new smartphones are running XH
DPI so the Galaxy Nexus, HTC1X, Samsung Galaxy

00:50:36.980 --> 00:50:40.690
X3, they are all running these extra high
res displays.

00:50:40.690 --> 00:50:44.630
While this is a little bit of guesswork, you
can usually take a pretty good guess as to

00:50:44.630 --> 00:50:48.259
where the next big buckets are going to be
and perhaps invest in those as well.

00:50:48.259 --> 00:50:52.279
You guys are lucky, you've already have those
last two buckets given to you today.

00:50:52.279 --> 00:50:55.410
So that's going to make life a little bit
easier.

00:50:55.410 --> 00:50:58.470
So you've done your testing on your hardware.

00:50:58.470 --> 00:51:01.130
I did mention that that's not the right way
to do multiple screens.

00:51:01.130 --> 00:51:05.960
The right way to do multiple screens is on
the developer.android.com training site, so

00:51:05.960 --> 00:51:07.369
do check that out.

00:51:07.369 --> 00:51:11.690
Beyond that, for the devices you haven't got,
use monkey runner.

00:51:11.690 --> 00:51:12.690
Use the emulator.

00:51:12.690 --> 00:51:16.249
Try out as many variations as you can.

00:51:16.249 --> 00:51:18.750
Get alpha testers.

00:51:18.750 --> 00:51:20.470
Get people who you know.

00:51:20.470 --> 00:51:22.130
Don't get your smartest techy friends.

00:51:22.130 --> 00:51:24.069
Get your least techy friend.

00:51:24.069 --> 00:51:29.270
The guy who you have to help him get his phone
out the Swahili every other week.

00:51:29.270 --> 00:51:33.960
That is the guy who is going to find the edge
cases, push 7 buttons at the same time and

00:51:33.960 --> 00:51:35.859
wonder why it broke.

00:51:35.859 --> 00:51:39.200
That's the person who you want testing your
apps.

00:51:39.200 --> 00:51:45.859
So, if there's anything we've learned from
IO this year and the keynote yesterday, is

00:51:45.859 --> 00:51:49.529
that Android is a lot more than a smartphone
development platform.

00:51:49.529 --> 00:51:54.480
Certainly the huge, huge user base of smartphones
means it's going to be the focus for a lot

00:51:54.480 --> 00:51:55.569
of us.

00:51:55.569 --> 00:52:01.539
But with new devices like these tablets, like
the Transformer Prime and the Nexus 7, we

00:52:01.539 --> 00:52:04.650
are seeing this increasing ecosystem.

00:52:04.650 --> 00:52:08.470
If you guys have had a chance to hack around
with your Nexus Q, you see the potential is

00:52:08.470 --> 00:52:13.941
that this ecosystem is going to grow further
to devices more and more varied, more and

00:52:13.941 --> 00:52:14.941
more different.

00:52:14.941 --> 00:52:22.520
But fundamentally, hopefully, if you create
an app that uses the achievements of invisibility,

00:52:22.520 --> 00:52:28.230
efficiency, and reliability, you will create
something so that it doesn't matter what users

00:52:28.230 --> 00:52:30.890
are using, which device they are operating
with.

00:52:30.890 --> 00:52:36.480
They are not using the Internet on their phone,
they are using your app.

00:52:36.480 --> 00:52:39.600
Thank you.

00:52:39.600 --> 00:52:49.900
[ Applause ]
&gt;&gt;Reto Meier: So then we barely have enough

00:52:49.900 --> 00:52:51.480
time for a couple questions.

00:52:51.480 --> 00:52:52.480
Before we dive into that.

00:52:52.480 --> 00:52:57.520
I wanted to give a quick rundown on what I
used to provide this presentation today.

00:52:57.520 --> 00:53:00.230
I got a lot of questions about that last year.

00:53:00.230 --> 00:53:02.430
I'm actually using two devices over here.

00:53:02.430 --> 00:53:06.160
You have a Nexus 7 and a Transformer Prime.

00:53:06.160 --> 00:53:09.730
I've hooked them up so that the Transformer
Prime is doing all of work.

00:53:09.730 --> 00:53:13.859
I have a HGMI cable which goes up to the projector.

00:53:13.859 --> 00:53:15.690
My clicker plugs into it.

00:53:15.690 --> 00:53:19.799
I have an Internet connection to send off
stuff to the social networks and I have a

00:53:19.799 --> 00:53:23.009
Nexus 7 over here which is where my speaker
notes are.

00:53:23.009 --> 00:53:26.779
Today actually they hooked it up so it shows
up on my conference monitor down there.

00:53:26.779 --> 00:53:29.279
So, yeah, we do have a couple of minutes.

00:53:29.279 --> 00:53:30.279
So questions?

00:53:30.279 --> 00:53:32.520
There's mics down the aisle.

00:53:32.520 --> 00:53:33.700
&gt;&gt;&gt; Check check.

00:53:33.700 --> 00:53:36.640
Thank you for your presentation.

00:53:36.640 --> 00:53:39.640
And I'm Bo Stone from Bo Stone Consulting.

00:53:39.640 --> 00:53:40.700
So here's the question.

00:53:40.700 --> 00:53:49.390
Is there an easy way to detect that the radio
is, in fact, on and so would it make sense

00:53:49.390 --> 00:53:53.140
to check that before I do that batching that
you were referring to?

00:53:53.140 --> 00:53:54.670
&gt;&gt;Reto Meier: That's a good point.

00:53:54.670 --> 00:53:56.650
That's something that would be useful.

00:53:56.650 --> 00:54:00.950
There aren't any APIs at the moment that allow
you to say perform this the next time the

00:54:00.950 --> 00:54:01.950
radio is on.

00:54:01.950 --> 00:54:05.890
You basically want something like the passive
location provider but for transfers.

00:54:05.890 --> 00:54:09.989
Unfortunately, no, there's no API for that
at the moment.

00:54:09.989 --> 00:54:12.589
&gt;&gt;&gt; Maybe you guys will add it in the future.

00:54:12.589 --> 00:54:15.920
&gt;&gt;Reto Meier: Definitely something to hope
for.

00:54:15.920 --> 00:54:16.920
&gt;&gt;&gt; Thank you.

00:54:16.920 --> 00:54:18.769
&gt;&gt;Reto Meier: No problem.

00:54:18.769 --> 00:54:24.920
&gt;&gt;&gt; Hi, can you comment on the CPU battery
life trade-off of compressing a text file

00:54:24.920 --> 00:54:27.410
before sending it versus sending it uncompressed?

00:54:27.410 --> 00:54:29.980
&gt;&gt;Reto Meier: That's a good question.

00:54:29.980 --> 00:54:34.890
So I think the battery life impact on doing
that compression is going to be pretty negligible.

00:54:34.890 --> 00:54:39.240
The processing cost of that is going to be
pretty slow whereas when you are doing that

00:54:39.240 --> 00:54:46.220
transfer, like not only is it a shorter amount
of time, it is less pressure on the networks

00:54:46.220 --> 00:54:47.460
themselves.

00:54:47.460 --> 00:54:48.609
Big part of that as well.

00:54:48.609 --> 00:54:50.260
I focused on the efficiency side.

00:54:50.260 --> 00:54:55.430
Talk to the carriers, it's really important
for them to get payloads as small as possible,

00:54:55.430 --> 00:54:57.680
let the networks more efficiency.

00:54:57.680 --> 00:55:00.450
That's going to end up in a much better result
in your uses as well.

00:55:00.450 --> 00:55:01.510
&gt;&gt;&gt; Thank you.

00:55:01.510 --> 00:55:03.640
&gt;&gt;&gt; Thanks for the presentation.

00:55:03.640 --> 00:55:12.480
Regarding the earlier part of the presentation,
do you have any idea if Google Analytics pays

00:55:12.480 --> 00:55:17.059
attention to sort of all your recommendations?

00:55:17.059 --> 00:55:20.239
&gt;&gt;Reto Meier: That is a good question.

00:55:20.239 --> 00:55:27.859
So the existing Analytics SDK allows you to
dispatch your Analytics information whenever

00:55:27.859 --> 00:55:29.279
you want to.

00:55:29.279 --> 00:55:30.839
So that allows you to have that control.

00:55:30.839 --> 00:55:35.009
I think it's something that I've just actually
been having conversations with them now to

00:55:35.009 --> 00:55:39.600
find out exactly what they do and what they
don't do in terms of automated downloads.

00:55:39.600 --> 00:55:41.369
Something they are aware of.

00:55:41.369 --> 00:55:43.949
We will go from there.

00:55:43.949 --> 00:55:45.249
&gt;&gt;&gt; Cool, thanks.

00:55:45.249 --> 00:55:47.839
&gt;&gt;&gt; My name is Rob.

00:55:47.839 --> 00:55:57.180
I want to know if the http response cache
class is useful for caching images or just

00:55:57.180 --> 00:56:05.529
for small http responses because I found caching
images especially with, like, downloading

00:56:05.529 --> 00:56:11.252
background threads to be a really challenging
problem when you are downloading a lot of

00:56:11.252 --> 00:56:12.252
things at once.

00:56:12.252 --> 00:56:13.252
&gt;&gt;Reto Meier: Absolutely.

00:56:13.252 --> 00:56:14.252
Downloading images is definitely a challenge.

00:56:14.252 --> 00:56:19.089
I would say the http response cache, I had
to practice a long time to be able to say

00:56:19.089 --> 00:56:20.089
that.

00:56:20.089 --> 00:56:23.970
It probably could work but it's probably not
the most efficient way to deal with that,

00:56:23.970 --> 00:56:29.350
so there's -- I think we talked in the fireside
chat yesterday that there is a library which

00:56:29.350 --> 00:56:34.630
we will be releasing at some point that try
to say do it in the most effective way.

00:56:34.630 --> 00:56:36.740
There's an Android training class as well.

00:56:36.740 --> 00:56:39.270
&gt;&gt;&gt; I am really looking forward to that library.

00:56:39.270 --> 00:56:48.920
&gt;&gt;Reto Meier: I think you are not the only
one.

00:56:48.920 --> 00:56:55.920
&gt;&gt;&gt; So you comment to use Cloud messaging
service to push messages, right?

00:56:55.920 --> 00:57:03.279
But I'm wondering, so particularly a window
sign into any -- so what is the plan for those

00:57:03.279 --> 00:57:08.609
little percentages of user who don't sign
into any account.

00:57:08.609 --> 00:57:13.849
So what is the plan that -- how we can push
messages to that user.

00:57:13.849 --> 00:57:17.009
&gt;&gt;Reto Meier: That's a good question.

00:57:17.009 --> 00:57:19.109
I'm not a hundred percent sure on the answer
here.

00:57:19.109 --> 00:57:22.420
You will want to check with the GCM team who
are doing a talk next.

00:57:22.420 --> 00:57:28.880
I have a suspicion that GCM doesn't require
a sign-in, it requires the GMS services to

00:57:28.880 --> 00:57:31.730
be on the device.

00:57:31.730 --> 00:57:38.490
&gt;&gt;&gt; You mean to say this is different from
C2DM, shore for user sign-in.

00:57:38.490 --> 00:57:41.869
&gt;&gt;Reto Meier: C2DM did.

00:57:41.869 --> 00:57:43.930
I'm not certain, so please do check with the
team.

00:57:43.930 --> 00:57:46.420
I have a suspicion that that may have already
been solved.

00:57:46.420 --> 00:57:48.900
&gt;&gt;&gt; Maybe you can give me some contact.

00:57:48.900 --> 00:57:50.210
&gt;&gt;Reto Meier: Absolutely.

00:57:50.210 --> 00:57:52.799
Come out to the office hours and we will hook
you up with the right people.

00:57:52.799 --> 00:57:54.880
&gt;&gt;&gt; Hi Reto, great session.

00:57:54.880 --> 00:57:55.932
&gt;&gt;Reto Meier: Thank you.

00:57:55.932 --> 00:58:06.869
&gt;&gt;&gt; Are you aware Google http library which
also does exponential back-off, retry handling,

00:58:06.869 --> 00:58:13.009
caching, would you recommend that for development
in Android?

00:58:13.009 --> 00:58:15.849
I think it's compatible with Android run times.

00:58:15.849 --> 00:58:19.299
&gt;&gt;Reto Meier: No, I'm not family familiar
with it, so I can't really comment.

00:58:19.299 --> 00:58:23.749
That's usually a good sign, but I couldn't
say.

00:58:23.749 --> 00:58:25.849
I'd have to look into it before giving an
opinion.

00:58:25.849 --> 00:58:29.829
Thank you very much, everyone.

00:58:29.829 --> 00:58:30.979
[ Applause ]

