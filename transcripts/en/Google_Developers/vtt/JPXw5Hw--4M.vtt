WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.409
[MUSIC PLAYING]

00:00:07.305 --> 00:00:09.130
VAAS KRISHNAMURTHY:
Hi, everyone.

00:00:09.130 --> 00:00:12.050
Good morning!

00:00:12.050 --> 00:00:15.550
Thank you all for joining us for
our talk on OpenThread today.

00:00:15.550 --> 00:00:17.230
We are very excited to be here.

00:00:17.230 --> 00:00:20.420
And we hope this session will
be very useful to you all.

00:00:20.420 --> 00:00:21.940
My name is Vaas Krishnamurthy.

00:00:21.940 --> 00:00:24.866
I'm an embedded software
engineer at Nest.

00:00:24.866 --> 00:00:27.250
JONATHAN HUI: And I'm Jonathan
Hui, Principal Software

00:00:27.250 --> 00:00:31.660
Engineer leading the OpenThread
effort across Nest in Google.

00:00:31.660 --> 00:00:33.520
In this session, we
will introduce to you

00:00:33.520 --> 00:00:35.890
Thread, a low power
mesh networking

00:00:35.890 --> 00:00:39.070
protocol for connecting
your IoT devices,

00:00:39.070 --> 00:00:41.950
OpenThread an open source
implementation of that Thread

00:00:41.950 --> 00:00:44.560
protocol, and how
you as developers

00:00:44.560 --> 00:00:47.915
can start using OpenThread to
build connected IoT devices.

00:00:50.760 --> 00:00:53.100
Now, Thread's history
starts at Nest

00:00:53.100 --> 00:00:56.640
where our primary focus was to
build products and solutions

00:00:56.640 --> 00:00:59.250
that keep you comfortable
while reducing your energy

00:00:59.250 --> 00:01:02.760
consumption, as well as
improving the security

00:01:02.760 --> 00:01:07.190
and safety of you and your home.

00:01:07.190 --> 00:01:09.046
Now, in order to
achieve that vision,

00:01:09.046 --> 00:01:11.420
we wanted our products to be
able to communicate directly

00:01:11.420 --> 00:01:14.500
with each other,
with cloud services,

00:01:14.500 --> 00:01:18.120
and directly with the end
user via their mobile devices.

00:01:18.120 --> 00:01:20.750
And so we went looking for our
connectivity technology that

00:01:20.750 --> 00:01:24.030
could satisfy those needs.

00:01:24.030 --> 00:01:26.810
And in doing so, we sent out
a number of requirements.

00:01:26.810 --> 00:01:30.020
The first was that it had to
support the internet protocol

00:01:30.020 --> 00:01:33.470
or IP, because we wanted to
build solutions that support

00:01:33.470 --> 00:01:36.050
a single application
layer communicating

00:01:36.050 --> 00:01:38.180
across multiple
link technologies

00:01:38.180 --> 00:01:40.640
such a cellular and Wi-Fi.

00:01:40.640 --> 00:01:42.140
It needed to be
scalable, because we

00:01:42.140 --> 00:01:45.170
wanted to build networks
that had hundreds of nodes.

00:01:45.170 --> 00:01:47.240
It needed to be resilient,
because we wanted

00:01:47.240 --> 00:01:51.020
to support safety and security
applications where devices can

00:01:51.020 --> 00:01:53.690
communicate, even
when devices fail

00:01:53.690 --> 00:01:56.270
or when mains power is lost.

00:01:56.270 --> 00:01:58.610
It needed to be low
power, because we wanted

00:01:58.610 --> 00:02:00.680
battery powered devices
to last for years

00:02:00.680 --> 00:02:02.570
on very small batteries.

00:02:02.570 --> 00:02:06.500
And of course, it
needed to be secure.

00:02:06.500 --> 00:02:08.900
But as we went looking for
an existing connectivity

00:02:08.900 --> 00:02:10.910
technology, we
actually could not

00:02:10.910 --> 00:02:13.250
find a single technology
that satisfied

00:02:13.250 --> 00:02:16.382
all of those requirements.

00:02:16.382 --> 00:02:17.840
And furthermore,
as we were talking

00:02:17.840 --> 00:02:21.020
with others in the industry, we
found that many others actually

00:02:21.020 --> 00:02:24.390
shared the same concern.

00:02:24.390 --> 00:02:28.610
So in July of 2014, Nest, along
with those other companies,

00:02:28.610 --> 00:02:30.650
started the Thread Group.

00:02:30.650 --> 00:02:33.140
The Thread Group is a
nonprofit organization

00:02:33.140 --> 00:02:35.030
with more than 100
member companies

00:02:35.030 --> 00:02:36.596
from around the world.

00:02:36.596 --> 00:02:39.020
And the Thread Group is
responsible for defining

00:02:39.020 --> 00:02:42.420
and maintaining the Thread
protocol specification.

00:02:42.420 --> 00:02:45.780
It is a market education group
promoting the use of Thread

00:02:45.780 --> 00:02:48.110
in connected products.

00:02:48.110 --> 00:02:50.870
And it ensures a
great user experience

00:02:50.870 --> 00:02:53.510
through a rigorous
and meaningful product

00:02:53.510 --> 00:02:56.450
certification program.

00:02:56.450 --> 00:02:58.720
So that was a bit about
the history of Thread.

00:02:58.720 --> 00:03:01.280
Now I would like to give you
some of the technical details

00:03:01.280 --> 00:03:02.450
of Thread.

00:03:02.450 --> 00:03:06.380
In short, Thread is an open
IP-based secure and mesh

00:03:06.380 --> 00:03:10.170
networking protocol
for IoT devices.

00:03:10.170 --> 00:03:13.320
Now, while Thread is
a new link technology,

00:03:13.320 --> 00:03:17.660
its design utilizes existing
technologies wherever possible.

00:03:17.660 --> 00:03:21.680
At the radio layer
it uses IEEE 802.15.4

00:03:21.680 --> 00:03:24.350
It's the same radio that
ZigBee uses and has been

00:03:24.350 --> 00:03:26.780
using for the past 15 years.

00:03:26.780 --> 00:03:30.530
And using an existing widely
deployed radio technology

00:03:30.530 --> 00:03:33.890
allows Thread products to
achieve a fast time to market

00:03:33.890 --> 00:03:37.100
as well as leverage
existing economies of scale

00:03:37.100 --> 00:03:40.000
to deliver low-cost solutions.

00:03:40.000 --> 00:03:43.820
At the network layer, Thread
uses existing IETF standards

00:03:43.820 --> 00:03:48.440
for transporting the internet
protocol version 6 or IPV6

00:03:48.440 --> 00:03:54.500
over 802.15.4 radios, a
technology called 6LoWPAN.

00:03:54.500 --> 00:03:57.920
Now, Thread's support for
IP is a key differentiator.

00:03:57.920 --> 00:04:01.190
Most existing low power
technologies do not support IP.

00:04:01.190 --> 00:04:04.010
And so why is IP so powerful?

00:04:04.010 --> 00:04:07.340
Well, for Nest, it means
that we could build solutions

00:04:07.340 --> 00:04:10.730
that utilize a number of linked
technologies such as Wi-Fi,

00:04:10.730 --> 00:04:15.170
cellular, and Thread, and have
all those devices communicating

00:04:15.170 --> 00:04:19.130
securely end to end with a
single application layer,

00:04:19.130 --> 00:04:21.050
and not have to build
application protocol

00:04:21.050 --> 00:04:24.297
translators in between.

00:04:24.297 --> 00:04:25.880
And at the same time,
it means that we

00:04:25.880 --> 00:04:28.040
could have a single
network supporting

00:04:28.040 --> 00:04:31.430
multiple applications
simultaneously.

00:04:31.430 --> 00:04:34.624
IP makes it easy to
deploy new applications,

00:04:34.624 --> 00:04:37.040
because you don't have to worry
about application protocol

00:04:37.040 --> 00:04:38.956
translators in the middle.

00:04:38.956 --> 00:04:41.330
And that was a key reason for
the success of the internet

00:04:41.330 --> 00:04:43.160
and its rapid growth.

00:04:43.160 --> 00:04:46.400
And Thread extends that benefit
to low power IoT devices.

00:04:48.930 --> 00:04:51.950
So Thread operates
as a scalable mesh.

00:04:51.950 --> 00:04:54.050
Thread supports up
to 32 routers that

00:04:54.050 --> 00:04:57.590
are responsible for forwarding
packets throughout the network.

00:04:57.590 --> 00:05:01.580
At the same time, each router
is capable of attaching 511 end

00:05:01.580 --> 00:05:02.810
devices.

00:05:02.810 --> 00:05:04.640
As a result, Thread
can easily scale up

00:05:04.640 --> 00:05:08.570
to hundreds of nodes
in a single network.

00:05:08.570 --> 00:05:11.570
Now, Threats self-selects
the set of routers and scales

00:05:11.570 --> 00:05:14.750
gracefully to different
network needs.

00:05:14.750 --> 00:05:18.060
All devices initially
attach as an end device.

00:05:18.060 --> 00:05:20.170
But when additional
connectivity is needed,

00:05:20.170 --> 00:05:24.630
a Thread device may promote
itself to become a router.

00:05:24.630 --> 00:05:26.720
However, when a
router does determine

00:05:26.720 --> 00:05:29.960
that its connectivity is
redundant or unnecessary,

00:05:29.960 --> 00:05:35.360
a Thread router can demote
itself back to an end device.

00:05:35.360 --> 00:05:37.700
So Thread is resilient.

00:05:37.700 --> 00:05:40.600
Thread routers perform
a dynamic shortest path

00:05:40.600 --> 00:05:42.560
any to any routing protocol.

00:05:42.560 --> 00:05:44.500
If you're familiar
with routing protocols,

00:05:44.500 --> 00:05:47.510
it is in the class of proactive
distance-vector routing

00:05:47.510 --> 00:05:49.280
similar to RIP.

00:05:49.280 --> 00:05:53.090
In short, it means that each
router maintains and advertises

00:05:53.090 --> 00:05:55.820
the best next hop towards every
other router in the Thread

00:05:55.820 --> 00:05:57.080
network.

00:05:57.080 --> 00:05:58.820
This dynamic routing
protocol not only

00:05:58.820 --> 00:06:01.580
allows Thread devices to
efficiently forward packets

00:06:01.580 --> 00:06:03.500
throughout the
network, but it also

00:06:03.500 --> 00:06:06.350
allows Thread to
dynamically react

00:06:06.350 --> 00:06:10.690
to node failures and
radio connectivity loss.

00:06:10.690 --> 00:06:13.520
Now, Thread's resilience
extends beyond the mesh

00:06:13.520 --> 00:06:15.020
when communicating
with devices that

00:06:15.020 --> 00:06:17.180
are outside Thread's network.

00:06:17.180 --> 00:06:19.310
Thread supports
multiple border routers

00:06:19.310 --> 00:06:23.030
operating simultaneously,
providing multiple paths

00:06:23.030 --> 00:06:25.160
into and out of a network.

00:06:25.160 --> 00:06:28.940
Most other technologies rely on
a single hub or a coordinator

00:06:28.940 --> 00:06:31.100
for external connectivity
that represents

00:06:31.100 --> 00:06:32.830
a single point of failure.

00:06:32.830 --> 00:06:35.120
But that's largely
because those protocols

00:06:35.120 --> 00:06:40.340
require a get stateful
application gateway in between

00:06:40.340 --> 00:06:43.730
to connect that network
to other networks.

00:06:43.730 --> 00:06:46.905
But with Thread, you truly have
no single point of failure,

00:06:46.905 --> 00:06:48.530
whether that means
you're communicating

00:06:48.530 --> 00:06:50.690
with other devices
on the mesh network

00:06:50.690 --> 00:06:54.780
or devices off of
the mesh network.

00:06:54.780 --> 00:06:56.700
So Thread is low power.

00:06:56.700 --> 00:07:00.240
Compared to Wi-Fi,
the 802.15.4 radio

00:07:00.240 --> 00:07:04.964
itself consumes about 1/10 the
power in active receive mode.

00:07:04.964 --> 00:07:06.630
Now, when you combine
that with the fact

00:07:06.630 --> 00:07:09.300
that Thread can sleep end
devices the vast majority

00:07:09.300 --> 00:07:13.260
of time, means that Thread
devices could operate for years

00:07:13.260 --> 00:07:16.700
on very small batteries.

00:07:16.700 --> 00:07:18.960
Now, Thread is also secure.

00:07:18.960 --> 00:07:21.510
Thread protects all data
traffic at the link layer

00:07:21.510 --> 00:07:25.140
using AES-128 encryption
and authentication

00:07:25.140 --> 00:07:26.970
with replay protection.

00:07:26.970 --> 00:07:29.670
And unlike other
existing technologies,

00:07:29.670 --> 00:07:31.950
security is mandatory in Thread.

00:07:31.950 --> 00:07:33.930
There is no way
or option for you

00:07:33.930 --> 00:07:38.450
to deploy a Thread network
with security disabled.

00:07:38.450 --> 00:07:41.820
What that also means is Thread
had to solve the secure device

00:07:41.820 --> 00:07:45.600
commissioning problem in
a very user-friendly way.

00:07:45.600 --> 00:07:48.480
Via mobile device,
they open a mobile app,

00:07:48.480 --> 00:07:50.370
and discover Thread
border routers

00:07:50.370 --> 00:07:52.860
on their network using NDNS.

00:07:52.860 --> 00:07:55.350
They then establish a secure
connection with that border

00:07:55.350 --> 00:07:58.290
router, and then go over
with their mobile device

00:07:58.290 --> 00:08:01.950
and scan the QR code of the
device that they want to join,

00:08:01.950 --> 00:08:04.230
and obtain a short pairing code.

00:08:04.230 --> 00:08:06.720
The mobile device then
establishes a secure DTLS

00:08:06.720 --> 00:08:09.300
session to authenticate
the joining device

00:08:09.300 --> 00:08:11.280
and securely provide
the credentials.

00:08:11.280 --> 00:08:13.560
In fact, if you've used
a Nest product today,

00:08:13.560 --> 00:08:16.140
you'll find this process
is very similar to what

00:08:16.140 --> 00:08:17.400
you've experienced.

00:08:17.400 --> 00:08:20.520
It really is very simple
and intuitive for the user.

00:08:20.520 --> 00:08:22.160
And you'll get to
see a demo of that

00:08:22.160 --> 00:08:25.320
in a bit later in the session.

00:08:25.320 --> 00:08:27.990
So in summary, Thread supports
all of the design requirements

00:08:27.990 --> 00:08:29.850
that we set out
in the beginning.

00:08:29.850 --> 00:08:33.299
It supports IP for secure
end-to-end communication

00:08:33.299 --> 00:08:35.580
without application gateways.

00:08:35.580 --> 00:08:38.610
It supports hundreds of
devices in a single network.

00:08:38.610 --> 00:08:41.024
It has no single
point of failure.

00:08:41.024 --> 00:08:45.210
It supports lifetime in years
when operating on batteries.

00:08:45.210 --> 00:08:48.630
And it has mandatory security
with a very user-friendly

00:08:48.630 --> 00:08:50.840
commissioning process.

00:08:50.840 --> 00:08:53.320
We started that effort in 2014.

00:08:53.320 --> 00:08:55.740
Four years later, we
believe Thread is still

00:08:55.740 --> 00:08:58.290
the only communication
protocol that satisfies

00:08:58.290 --> 00:09:01.725
all of those requirements.

00:09:01.725 --> 00:09:04.380
Now, two years ago
here at I/O, we

00:09:04.380 --> 00:09:06.780
launched the OpenThread project.

00:09:06.780 --> 00:09:09.990
OpenThread is an open source
implementation of Thread.

00:09:09.990 --> 00:09:11.580
And it is the same
implementation

00:09:11.580 --> 00:09:13.722
that we use in Nest
products today.

00:09:13.722 --> 00:09:15.390
And the goal of
OpenThread is really

00:09:15.390 --> 00:09:17.640
to make the same
technology that we

00:09:17.640 --> 00:09:20.130
use in Nest products
more broadly available

00:09:20.130 --> 00:09:24.950
to developers, and
that means you.

00:09:24.950 --> 00:09:28.400
So OpenThread is an open
community-based project,

00:09:28.400 --> 00:09:30.200
and it's hosted on GitHub.

00:09:30.200 --> 00:09:32.240
All development is
done in the open.

00:09:32.240 --> 00:09:34.370
Every commit goes through
a public pull request

00:09:34.370 --> 00:09:36.760
where anyone can
comment on and review.

00:09:36.760 --> 00:09:38.720
And anybody can make
their own contributions

00:09:38.720 --> 00:09:42.500
by submitting issues or
pull requests themselves.

00:09:42.500 --> 00:09:46.700
OpenThread is also
licensed under BSD-3.

00:09:46.700 --> 00:09:49.170
And since its launch two
years ago, OpenThread

00:09:49.170 --> 00:09:51.390
has seen widespread adoption.

00:09:51.390 --> 00:09:55.230
OpenThread has been ported to
about 10 different 802.15.4

00:09:55.230 --> 00:09:56.250
radios.

00:09:56.250 --> 00:10:00.290
And you can find example drivers
for those radios on GitHub.

00:10:00.290 --> 00:10:02.040
Furthermore, many of
the silicon providers

00:10:02.040 --> 00:10:03.930
provide direct
commercial support

00:10:03.930 --> 00:10:08.214
of OpenThread running on their
silicon and in their SDK.

00:10:08.214 --> 00:10:10.380
So if you're already working
with a favorite silicon

00:10:10.380 --> 00:10:12.480
vendor of yours, I
encourage you to reach out

00:10:12.480 --> 00:10:16.070
to them regarding
support for OpenThread.

00:10:16.070 --> 00:10:18.540
An OpenThread is also
seeing strong adoption

00:10:18.540 --> 00:10:20.530
by IoT platforms--

00:10:20.530 --> 00:10:22.410
of course, Android
Things, but also

00:10:22.410 --> 00:10:27.090
Particle, runtime, and Zephyr.

00:10:27.090 --> 00:10:30.107
Though in addition to the
core thread implementation,

00:10:30.107 --> 00:10:31.940
there are a few other
sub-projects that I do

00:10:31.940 --> 00:10:33.380
want to mention.

00:10:33.380 --> 00:10:37.550
The first is wpandtund,
a user space network

00:10:37.550 --> 00:10:39.650
interface driver for Linux.

00:10:39.650 --> 00:10:41.930
Remember that Thread
supports the same IP

00:10:41.930 --> 00:10:45.630
technology that drives every
internet connected device.

00:10:45.630 --> 00:10:49.520
And with wpandtund, you can
present a Thread network

00:10:49.520 --> 00:10:52.100
as a standard network
interface of Linux,

00:10:52.100 --> 00:10:53.930
which means you can
use the same socket

00:10:53.930 --> 00:10:56.565
APIs that you're used to using
to communicate with Thread

00:10:56.565 --> 00:10:57.065
devices.

00:10:59.630 --> 00:11:02.320
OpenThread also has a
border router sub-project.

00:11:02.320 --> 00:11:06.740
And it builds on wpandtund to
provide a quick and easy method

00:11:06.740 --> 00:11:09.440
for you to connect
your OpenThread devices

00:11:09.440 --> 00:11:11.540
to ethernet or Wi-Fi networks.

00:11:11.540 --> 00:11:14.000
And you can do that using
Raspberry Pi or BeagleBone

00:11:14.000 --> 00:11:14.670
Black.

00:11:14.670 --> 00:11:19.110
And all of the source code
is available on GitHub.

00:11:19.110 --> 00:11:21.670
So as I mentioned, OpenThread
is shipping in Nest products

00:11:21.670 --> 00:11:22.880
today.

00:11:22.880 --> 00:11:24.960
And what that means for
you is that you also

00:11:24.960 --> 00:11:27.360
get to take advantage
of all of the hard work

00:11:27.360 --> 00:11:30.210
that we put into making
OpenThread work really well

00:11:30.210 --> 00:11:32.132
in end consumer products.

00:11:32.132 --> 00:11:34.590
So let me tell you a little
bit about how OpenThread really

00:11:34.590 --> 00:11:38.400
enables Nest products.

00:11:38.400 --> 00:11:41.790
The Nest Detect is a wireless
open-close sensor for things

00:11:41.790 --> 00:11:43.350
like windows and doors.

00:11:43.350 --> 00:11:45.180
It's also a motion sensor.

00:11:45.180 --> 00:11:47.790
And it communicates
only via Thread.

00:11:47.790 --> 00:11:50.250
And it does so as a
sleepy end device,

00:11:50.250 --> 00:11:53.820
allowing its radio and
processor to sleep more than 99%

00:11:53.820 --> 00:11:55.170
of the time.

00:11:55.170 --> 00:11:58.990
But when it does detect an
event such as opening a door,

00:11:58.990 --> 00:12:01.430
it can quickly wake up,
communicate that event,

00:12:01.430 --> 00:12:03.130
and set off the alarm.

00:12:03.130 --> 00:12:05.610
And by using Thread,
Nest Detect is

00:12:05.610 --> 00:12:12.100
able to operate for two years
on a small CR123 battery.

00:12:12.100 --> 00:12:15.550
The Nest DL Lock is a connected
deadbolt for your door.

00:12:15.550 --> 00:12:20.150
Like Nest Detect, it relies
only on Thread to communicate,

00:12:20.150 --> 00:12:22.990
and operates as a
sleepy end device.

00:12:22.990 --> 00:12:24.860
And by using Thread,
not only does

00:12:24.860 --> 00:12:27.430
it last for years
on AA batteries,

00:12:27.430 --> 00:12:30.565
but it can also respond to
remote lock-unlock commands

00:12:30.565 --> 00:12:31.190
within seconds.

00:12:31.190 --> 00:12:33.670
So it's very responsive.

00:12:33.670 --> 00:12:36.220
And remote unlock is
an excellent example

00:12:36.220 --> 00:12:39.410
of where you want secure
end-to-end communications.

00:12:39.410 --> 00:12:43.400
That Thread supports
that by supporting IP.

00:12:43.400 --> 00:12:46.930
Now, the Nest Guard is
a Thread border router

00:12:46.930 --> 00:12:50.440
that connects both the Nest
Detect and Nest DL Lock.

00:12:50.440 --> 00:12:51.970
It is a Linux-based
Thread border

00:12:51.970 --> 00:12:54.580
router supporting
Wi-Fi and cellular,

00:12:54.580 --> 00:12:56.440
in addition to Thread.

00:12:56.440 --> 00:13:00.520
It uses wpandtund to expose
Thread as a standard network

00:13:00.520 --> 00:13:04.060
interface to Linux-based
services and applications.

00:13:04.060 --> 00:13:07.150
And it has a 12-hour
battery backup with cellular

00:13:07.150 --> 00:13:10.570
to ensure that your Thread
network stays connected and can

00:13:10.570 --> 00:13:14.590
communicate alarms outside your
home, even when power is lost

00:13:14.590 --> 00:13:17.610
or Wi-Fi goes down.

00:13:17.610 --> 00:13:19.870
And then we have
the Nest Connect.

00:13:19.870 --> 00:13:22.110
It also serves as a
Thread border router,

00:13:22.110 --> 00:13:25.210
connecting the Nest
Detect and Nest DL Lock.

00:13:25.210 --> 00:13:28.360
Like the Nest Guard, it is a
battery-backed border router,

00:13:28.360 --> 00:13:30.490
allowing it to maintain
Thread connectivity

00:13:30.490 --> 00:13:34.460
even when power is lost or
even when Wi-Fi is down.

00:13:34.460 --> 00:13:36.640
However, unlike the
Nest Guard, Nest Connect

00:13:36.640 --> 00:13:40.840
is an RTOS class device, and
only supports Wi-Fi and Thread,

00:13:40.840 --> 00:13:45.110
allowing us to really drive
the cost of that device down.

00:13:45.110 --> 00:13:47.400
And with that, I'll
turn it over to Vaas.

00:13:47.400 --> 00:13:49.720
VAAS KRISHNAMURTHY:
Thank you, Jonathan.

00:13:49.720 --> 00:13:52.180
I've been at Nest
for over five years.

00:13:52.180 --> 00:13:55.547
And I've enabled the 15.4
radio on several Nest products.

00:13:55.547 --> 00:13:57.130
So for the rest of
this session, we're

00:13:57.130 --> 00:13:59.530
going to talk about
how to take OpenThread

00:13:59.530 --> 00:14:02.680
and other open source resources
available to quickly build

00:14:02.680 --> 00:14:05.590
your IoT device.

00:14:05.590 --> 00:14:09.430
With OpenThread being highly
portable, platform agnostic,

00:14:09.430 --> 00:14:13.690
and IPv6-based, this opens up a
large number of options for us.

00:14:13.690 --> 00:14:16.420
So we have several
system architectures,

00:14:16.420 --> 00:14:20.480
operating systems, tool chains,
and radios to pick from.

00:14:20.480 --> 00:14:23.020
So we're going to talk about
each of these categories

00:14:23.020 --> 00:14:25.810
and figure out how to
make the right decisions

00:14:25.810 --> 00:14:28.720
for your product, and what
the deciding factors are.

00:14:28.720 --> 00:14:31.940
So let's start with the
system architecture.

00:14:31.940 --> 00:14:34.090
We have three
models to pick from.

00:14:34.090 --> 00:14:38.350
The first one is called System
on Chip, or the SoC model.

00:14:38.350 --> 00:14:40.570
Here, we only have
one processor,

00:14:40.570 --> 00:14:43.030
and both the application
and OpenThread

00:14:43.030 --> 00:14:45.010
run on the single chip.

00:14:45.010 --> 00:14:47.500
This model is typically
picked for a device that

00:14:47.500 --> 00:14:51.340
has a simple function, and more
importantly for a device that

00:14:51.340 --> 00:14:53.420
runs on battery power.

00:14:53.420 --> 00:14:56.710
An example of this
device is Nest Detect,

00:14:56.710 --> 00:14:59.500
which is the motion sensor
for doors and windows.

00:14:59.500 --> 00:15:02.250
And the role of this device
on the Thread network

00:15:02.250 --> 00:15:03.670
is a sleepy end device.

00:15:03.670 --> 00:15:06.310
And it needs another fully
powered Thread router

00:15:06.310 --> 00:15:07.990
to act as its parent.

00:15:07.990 --> 00:15:10.180
There were a lot of
features added to OpenThread

00:15:10.180 --> 00:15:13.060
and parameters provided
to get this device

00:15:13.060 --> 00:15:16.460
to run on a single battery
for over two years.

00:15:16.460 --> 00:15:19.180
So all of that is available
in OpenThread for everyone

00:15:19.180 --> 00:15:21.560
to use as well.

00:15:21.560 --> 00:15:24.760
Most radios typically come
with the single Thread chip,

00:15:24.760 --> 00:15:27.820
but some today also have an
integrated Thread and BLE

00:15:27.820 --> 00:15:28.510
radio.

00:15:28.510 --> 00:15:31.510
So we have the option to
use more than one interface

00:15:31.510 --> 00:15:33.790
for communication.

00:15:33.790 --> 00:15:36.890
The next model is called
the NCP, or the Network Core

00:15:36.890 --> 00:15:38.500
Processor architecture.

00:15:38.500 --> 00:15:41.830
Here, the radio is its own chip
and we have a separate host

00:15:41.830 --> 00:15:42.670
processor.

00:15:42.670 --> 00:15:45.590
Now, this gives us a
lot more flexibility.

00:15:45.590 --> 00:15:48.970
We can choose a host processor
that's a lot more capable.

00:15:48.970 --> 00:15:51.070
And we get the
processing power to run

00:15:51.070 --> 00:15:52.990
more complex applications.

00:15:52.990 --> 00:15:57.520
We can even have a nice UI,
like a touchscreen display,

00:15:57.520 --> 00:15:58.510
voice assistant.

00:15:58.510 --> 00:16:01.150
You can have a Wi-Fi radio
to connect to the cloud,

00:16:01.150 --> 00:16:02.410
and so on.

00:16:02.410 --> 00:16:06.190
An example of this
device is the Nest Guard,

00:16:06.190 --> 00:16:07.990
which is the security hub.

00:16:07.990 --> 00:16:09.880
This has a keypad.

00:16:09.880 --> 00:16:10.960
It has a speaker.

00:16:10.960 --> 00:16:14.290
It has several radio sensors,
it has the Wi-Fi, BLE,

00:16:14.290 --> 00:16:17.510
cellular radios, in addition
to the Thread radio.

00:16:17.510 --> 00:16:20.260
The role of this device
is a Thread router,

00:16:20.260 --> 00:16:25.030
and it's meant to operate as an
always-on fully powered device.

00:16:25.030 --> 00:16:27.190
But with this NCP
model, we also have

00:16:27.190 --> 00:16:29.950
the option of having
the host and the radio

00:16:29.950 --> 00:16:31.180
sleep independently.

00:16:31.180 --> 00:16:34.600
So when it's always on, both the
host and the radio are awake,

00:16:34.600 --> 00:16:37.420
but when this device
loses external power,

00:16:37.420 --> 00:16:40.910
it can run on battery
backup for up to 12 hours.

00:16:40.910 --> 00:16:43.300
So at this time, the host
sends this information up

00:16:43.300 --> 00:16:45.910
to the cloud, and it
immediately goes to sleep.

00:16:45.910 --> 00:16:49.330
The radio, however, continues
to act as a Thread router,

00:16:49.330 --> 00:16:51.970
and can wake up the
host when needed.

00:16:51.970 --> 00:16:56.000
Another example of this model is
the more power-constrained Nest

00:16:56.000 --> 00:16:56.500
Protect.

00:16:56.500 --> 00:16:57.900
This is our smoke detector.

00:16:57.900 --> 00:16:58.990
It's battery-powered.

00:16:58.990 --> 00:17:01.240
And in this case, both
the host and the radio

00:17:01.240 --> 00:17:02.400
are always asleep.

00:17:02.400 --> 00:17:04.510
Now again, whenever
an event happens,

00:17:04.510 --> 00:17:05.950
one can always
wake up the other.

00:17:08.619 --> 00:17:12.730
The next model what we have is
the MAC and PHY architecture,

00:17:12.730 --> 00:17:14.859
where, again, we have
two different processors

00:17:14.859 --> 00:17:16.450
for the host and the radio.

00:17:16.450 --> 00:17:20.260
But in this case, the OpenThread
core runs on the host processor

00:17:20.260 --> 00:17:22.089
instead of on the radio.

00:17:22.089 --> 00:17:27.730
And this model is great for
adding 15.4 Thread support

00:17:27.730 --> 00:17:29.170
to existing products.

00:17:29.170 --> 00:17:32.230
You can simply attach a 15.4
radio to an existing device,

00:17:32.230 --> 00:17:34.420
and add support to it.

00:17:34.420 --> 00:17:37.210
Since this model
is simple to use

00:17:37.210 --> 00:17:39.400
and it has a quick
system integration,

00:17:39.400 --> 00:17:41.740
it provides the
fastest time to market,

00:17:41.740 --> 00:17:46.780
and it also offers the
lowest 15.4 component cost.

00:17:46.780 --> 00:17:49.660
So depending on your application
and your product, what

00:17:49.660 --> 00:17:51.910
your power constraints are,
what your UI looks like,

00:17:51.910 --> 00:17:53.470
what are the radios
you have, you

00:17:53.470 --> 00:17:56.740
can pick from one of these
three different architectures.

00:17:56.740 --> 00:17:59.980
Next, we pick the
operating system.

00:17:59.980 --> 00:18:02.560
OpenThread is platform agnostic.

00:18:02.560 --> 00:18:04.390
So when we choose
the operating system,

00:18:04.390 --> 00:18:07.900
we simply base it on the
complexity of your product.

00:18:07.900 --> 00:18:12.520
So for something really simple
like actuator, or a sensor,

00:18:12.520 --> 00:18:14.730
we can go with the bare
metal operating system.

00:18:14.730 --> 00:18:16.660
For something a
little more complex,

00:18:16.660 --> 00:18:18.240
we can go with the FreeRTOS.

00:18:18.240 --> 00:18:20.490
And for much more
complex applications,

00:18:20.490 --> 00:18:22.350
we can go with
Linux or the Linux

00:18:22.350 --> 00:18:25.020
based operating system
like Android Things.

00:18:25.020 --> 00:18:28.530
The Nest Detect uses FreeRTOS
for its operating system,

00:18:28.530 --> 00:18:30.920
and [INAUDIBLE] for
its networking stack.

00:18:30.920 --> 00:18:34.470
The Nest Guard uses Linux
for its operating system

00:18:34.470 --> 00:18:37.110
on the host, and FreeRTOS
for the operating

00:18:37.110 --> 00:18:38.730
system that runs in the radio.

00:18:38.730 --> 00:18:41.640
So all these operating
systems, networking stocks,

00:18:41.640 --> 00:18:43.320
and OpenThread are
all open source.

00:18:43.320 --> 00:18:46.830
So we can quickly start adding
your application support

00:18:46.830 --> 00:18:49.920
on top of this layer.

00:18:49.920 --> 00:18:52.320
OpenThread is also
toolchain agnostic.

00:18:52.320 --> 00:18:55.300
So it not only runs on these
several operating systems,

00:18:55.300 --> 00:18:57.300
but you can also
compile it using

00:18:57.300 --> 00:18:59.820
several well-known toolchains.

00:18:59.820 --> 00:19:02.940
So we pick that basically
based on whatever

00:19:02.940 --> 00:19:04.760
you're most comfortable with.

00:19:04.760 --> 00:19:07.560
OpenThread also provides a
narrow platform abstraction

00:19:07.560 --> 00:19:08.070
layer.

00:19:08.070 --> 00:19:11.280
So all of these are great for
us to achieve very quick system

00:19:11.280 --> 00:19:13.470
integration.

00:19:13.470 --> 00:19:15.450
Next, we pick the radio.

00:19:15.450 --> 00:19:17.490
There are several
radios available today

00:19:17.490 --> 00:19:20.760
that can run OpenThread, and
we are not limited to this set.

00:19:20.760 --> 00:19:23.400
It's easy to put
OpenThread to a new radio

00:19:23.400 --> 00:19:25.080
if you want to use it.

00:19:25.080 --> 00:19:29.550
Each radio here has a
different power memory and cost

00:19:29.550 --> 00:19:30.900
associated with it.

00:19:30.900 --> 00:19:33.690
And depending on the
exact features and memory,

00:19:33.690 --> 00:19:37.280
each of these range
anywhere from $0.80 to $2.

00:19:37.280 --> 00:19:38.940
So to determine
these requirements,

00:19:38.940 --> 00:19:41.370
it's best to think of
the network as a whole.

00:19:41.370 --> 00:19:43.530
So how many routers do
you have on the network?

00:19:43.530 --> 00:19:45.730
How many sleepy end
devices do you have?

00:19:45.730 --> 00:19:49.870
How many sleepy end devices need
to be supported on each router?

00:19:49.870 --> 00:19:53.730
So what is the expected battery
life of your sleepy end device?

00:19:53.730 --> 00:19:56.280
There is always a
trade-off between how often

00:19:56.280 --> 00:19:59.130
the sleepy end device pulls
versus its battery life.

00:19:59.130 --> 00:20:00.930
If you have to pull
too often, then

00:20:00.930 --> 00:20:03.180
its going to drain
the battery quicker.

00:20:03.180 --> 00:20:06.060
So first, we determine
this data pull rate.

00:20:06.060 --> 00:20:08.370
And that on the other
side for the router

00:20:08.370 --> 00:20:11.070
determines how long
each packet needs

00:20:11.070 --> 00:20:14.370
to be queued for the
sleepy end device.

00:20:14.370 --> 00:20:16.650
And the application
itself will determine

00:20:16.650 --> 00:20:18.630
how large these packets
are, and how many

00:20:18.630 --> 00:20:21.540
such packets need to be queued
for the sleepy end device.

00:20:21.540 --> 00:20:24.900
Now multiply this by the
number of sleepy end devices

00:20:24.900 --> 00:20:26.590
the router needs to support.

00:20:26.590 --> 00:20:30.360
So that gives us the minimum
RAM requirement for this router.

00:20:30.360 --> 00:20:33.690
So once we nail down the
network and memory requirements,

00:20:33.690 --> 00:20:36.060
we can pick from
one of these radios.

00:20:36.060 --> 00:20:38.910
So at this point, we can get
a couple of these development

00:20:38.910 --> 00:20:40.290
boards, because
we made decisions

00:20:40.290 --> 00:20:42.780
on the operating system,
toolchain, radio, and system

00:20:42.780 --> 00:20:43.870
architecture.

00:20:43.870 --> 00:20:47.160
And we can try out
our sample app.

00:20:47.160 --> 00:20:50.520
So OpenThread provides a very
simple-to-use command line

00:20:50.520 --> 00:20:51.340
interface.

00:20:51.340 --> 00:20:54.300
So we can do a lot
of things to exercise

00:20:54.300 --> 00:20:55.860
various features of Thread.

00:20:55.860 --> 00:20:58.080
You can inform a
network, scan, join,

00:20:58.080 --> 00:20:59.580
look at your neighbor
table entries,

00:20:59.580 --> 00:21:01.620
look at your child
table, look at the signal

00:21:01.620 --> 00:21:04.200
strength with each
neighbor that you have,

00:21:04.200 --> 00:21:06.510
you can ping one device
to another in the network,

00:21:06.510 --> 00:21:07.750
and so on.

00:21:07.750 --> 00:21:10.560
And for a host in
NCP-based platform,

00:21:10.560 --> 00:21:14.320
you can do the same thing
with our wpandtund tool.

00:21:14.320 --> 00:21:17.460
And there are also several
code labs you can try out.

00:21:17.460 --> 00:21:20.370
The code labs can either be
run on two physical devices--

00:21:20.370 --> 00:21:22.080
these development
boards-- or you

00:21:22.080 --> 00:21:27.340
can run it simply with
OpenThread in simulation mode.

00:21:27.340 --> 00:21:30.640
So at this point, we can start
building your IoT product

00:21:30.640 --> 00:21:32.560
by adding application support.

00:21:32.560 --> 00:21:34.540
Now let's say you are
building an app that

00:21:34.540 --> 00:21:38.170
has a light bulb controlled
by a remote switch.

00:21:38.170 --> 00:21:41.590
You can start building this
by writing device drivers

00:21:41.590 --> 00:21:42.980
for your product.

00:21:42.980 --> 00:21:45.850
The radio drivers themselves
are provided by the radio

00:21:45.850 --> 00:21:46.760
on platform vendors.

00:21:46.760 --> 00:21:49.240
So that's something we
don't have to worry about.

00:21:49.240 --> 00:21:52.840
And if your network only has
device-to-device communication,

00:21:52.840 --> 00:21:54.470
we are good at this point.

00:21:54.470 --> 00:21:58.870
However, if you want to send the
light's state updated to a web

00:21:58.870 --> 00:22:00.730
app or your mobile
phone, we have

00:22:00.730 --> 00:22:03.610
to add additional border
router and cloud support.

00:22:06.550 --> 00:22:09.400
And for the application
itself, we can write our own

00:22:09.400 --> 00:22:12.700
or we can leverage one
of several applications

00:22:12.700 --> 00:22:15.400
that were written specifically
for connected devices.

00:22:15.400 --> 00:22:18.830
Since the thread is IPv6-based,
we are not limited to this.

00:22:18.830 --> 00:22:21.650
There are a large number
of options to choose from.

00:22:21.650 --> 00:22:26.080
So this gives us everything
from application layer security,

00:22:26.080 --> 00:22:29.620
connection communication
APIs, software download APIs,

00:22:29.620 --> 00:22:30.550
and so on.

00:22:30.550 --> 00:22:32.860
So we can take
advantage of this layer

00:22:32.860 --> 00:22:36.200
and hook up our
application on top of this.

00:22:36.200 --> 00:22:39.520
So the next piece of the
puzzle is addressing.

00:22:39.520 --> 00:22:42.280
So how does your switch know
the address of the light

00:22:42.280 --> 00:22:43.750
it's communicating to?

00:22:43.750 --> 00:22:47.710
How does your light know the
address of the cloud service

00:22:47.710 --> 00:22:50.710
that it needs to
send updates to?

00:22:50.710 --> 00:22:54.190
Thread supports
standard IPv6 mechanisms

00:22:54.190 --> 00:22:57.780
for local and
wide-area connectivity.

00:22:57.780 --> 00:23:01.690
So all we're really doing is
building a normal IP network.

00:23:01.690 --> 00:23:04.960
So everything from assigning,
discovering, to addressing

00:23:04.960 --> 00:23:10.560
is exactly what we do for
a traditional IP network.

00:23:10.560 --> 00:23:12.850
For Nest products, we
have picked a certain

00:23:12.850 --> 00:23:16.450
naming and addressing schemes,
a cloud connectivity model,

00:23:16.450 --> 00:23:18.340
and application layer security.

00:23:18.340 --> 00:23:21.310
This layer is what
we call Weave.

00:23:21.310 --> 00:23:23.350
And we recently open-sourced it.

00:23:23.350 --> 00:23:24.690
It's called OpenWeave.

00:23:24.690 --> 00:23:27.130
We also have a code
lab set up here at I/O

00:23:27.130 --> 00:23:29.980
that everyone can try out
to understand what Weave is,

00:23:29.980 --> 00:23:31.630
what it can do,
and how to use it.

00:23:34.210 --> 00:23:37.020
So now that we've essentially
built our IoT device

00:23:37.020 --> 00:23:39.750
by adding application
and addressing support,

00:23:39.750 --> 00:23:43.570
our next task is to make the
network strong and reliable.

00:23:43.570 --> 00:23:46.470
And OpenThread provides a number
of features and parameters

00:23:46.470 --> 00:23:47.820
that help us with this.

00:23:47.820 --> 00:23:50.640
First, OpenThread is
extremely configurable.

00:23:50.640 --> 00:23:52.710
There is pretty much
everything that you want.

00:23:52.710 --> 00:23:55.320
You can change from time
outs to number of children

00:23:55.320 --> 00:23:57.960
that you want to support, how
large the buffer is, and so on.

00:23:57.960 --> 00:24:00.810
You can turn on and off
features very easily

00:24:00.810 --> 00:24:03.960
by putting in some defines
in a configuration file

00:24:03.960 --> 00:24:07.020
to make the stack do
exactly what you want.

00:24:07.020 --> 00:24:09.480
OpenThread also has
configurable logging.

00:24:09.480 --> 00:24:11.400
And this logging is
configurable at runtime.

00:24:11.400 --> 00:24:13.410
And that's the most
important thing.

00:24:13.410 --> 00:24:16.080
So say you are debugging
a network issue.

00:24:16.080 --> 00:24:18.390
And the network is working
great for several days,

00:24:18.390 --> 00:24:20.490
and occasionally
there is an error.

00:24:20.490 --> 00:24:22.770
It doesn't make sense
to have verbose logging

00:24:22.770 --> 00:24:23.920
that entire time.

00:24:23.920 --> 00:24:25.590
So what we could
do is at runtime,

00:24:25.590 --> 00:24:28.530
when that error happens, you
can turn on extra logging just

00:24:28.530 --> 00:24:30.606
doing that error condition.

00:24:30.606 --> 00:24:33.900
OpenThread also has a
great set of counters.

00:24:33.900 --> 00:24:37.110
We can see everything from the
number of packets transmitted,

00:24:37.110 --> 00:24:41.520
received, dropped in every layer
from PHY to MAC to IP layers.

00:24:41.520 --> 00:24:44.530
We can look at the transmit
data rate tracking, and so on.

00:24:44.530 --> 00:24:48.300
So all of this helps us
with getting a deep insight

00:24:48.300 --> 00:24:49.530
in the stack.

00:24:49.530 --> 00:24:53.730
And we can debug really
easily with this.

00:24:53.730 --> 00:24:55.800
OpenThread can
run in simulation.

00:24:55.800 --> 00:25:00.190
So we can emulate an OpenThread
device using a POSIX process.

00:25:00.190 --> 00:25:02.160
So if you want to test
a certain scenario

00:25:02.160 --> 00:25:03.750
over a large number
of devices, we

00:25:03.750 --> 00:25:08.940
can do so using the
OpenThread-Simulator.

00:25:08.940 --> 00:25:10.710
Next, we have Toranj.

00:25:10.710 --> 00:25:13.380
This is a Python-based
testing framework developed

00:25:13.380 --> 00:25:15.390
by our colleague [INAUDIBLE].

00:25:15.390 --> 00:25:16.720
It's very simple to use.

00:25:16.720 --> 00:25:18.900
And you can see an
example of it right here.

00:25:18.900 --> 00:25:21.120
So you can create
a number of nodes.

00:25:21.120 --> 00:25:25.050
And what you can do is
you can tell the script

00:25:25.050 --> 00:25:27.630
that I want you have only
these devices join me.

00:25:27.630 --> 00:25:30.480
And I want to have these
devices blocked from joining me.

00:25:30.480 --> 00:25:33.300
So with this, we are able
to create a complex network

00:25:33.300 --> 00:25:34.350
topologies.

00:25:34.350 --> 00:25:37.710
So you can run a certain
scenario over multiple hops,

00:25:37.710 --> 00:25:40.290
or you can force a packet
to take a certain route

00:25:40.290 --> 00:25:43.120
through the network.

00:25:43.120 --> 00:25:45.790
Next, we have a Thread
topology monitor.

00:25:45.790 --> 00:25:47.620
This is something
our team in Shanghai

00:25:47.620 --> 00:25:49.960
put together for I/O.
It's actually live

00:25:49.960 --> 00:25:52.300
and running in our sandbox.

00:25:52.300 --> 00:25:55.810
And this is basically a live
interactive network map.

00:25:55.810 --> 00:25:57.120
It gives you the device roles.

00:25:57.120 --> 00:25:58.690
It tells you what
type of devices

00:25:58.690 --> 00:26:00.980
are used, what radios
are used, and so on.

00:26:00.980 --> 00:26:03.910
And this will soon be
open-sourced as well.

00:26:03.910 --> 00:26:07.870
OpenThread supports standard
Wireshark traffic captures.

00:26:07.870 --> 00:26:10.510
So we can get one of these
dev [? boards. ?] Just load

00:26:10.510 --> 00:26:13.467
the standard NCP image--
it's a pre-NCP image--

00:26:13.467 --> 00:26:14.050
and that's it.

00:26:14.050 --> 00:26:16.360
We can start
sniffing immediately.

00:26:16.360 --> 00:26:18.730
So the other feature is
that the radio can simply

00:26:18.730 --> 00:26:21.520
be in monitor mode, where
it's just passive and acting

00:26:21.520 --> 00:26:23.590
as an external
sniffer, or a device

00:26:23.590 --> 00:26:25.360
that's part of
the network can be

00:26:25.360 --> 00:26:27.910
put in a promiscuous mode where
it's a part of the network

00:26:27.910 --> 00:26:29.590
and still capturing packets.

00:26:29.590 --> 00:26:32.250
And this is again,
great debugging tool.

00:26:32.250 --> 00:26:34.870
So if you're looking
for a lost packet,

00:26:34.870 --> 00:26:38.289
you can pretty much have the
sniffer running on all devices

00:26:38.289 --> 00:26:40.330
while it's on the network,
and look at their peak

00:26:40.330 --> 00:26:43.540
apps later to determine
where the packet was dropped.

00:26:43.540 --> 00:26:46.590
So as you can see,
all of these tools

00:26:46.590 --> 00:26:49.450
were developed for OpenThread
to make it really easy to debug.

00:26:49.450 --> 00:26:53.560
And as a result, we are able to
create a really stable network

00:26:53.560 --> 00:26:56.390
and higher-quality products.

00:26:56.390 --> 00:26:58.900
So at Nest, when we
started using OpenThread

00:26:58.900 --> 00:27:02.560
in our products and testing it
more in real-world conditions,

00:27:02.560 --> 00:27:04.780
we discovered several use cases.

00:27:04.780 --> 00:27:08.680
And we started adding features
around each one of them.

00:27:08.680 --> 00:27:11.920
So OpenThread is not only
Thread 1.1 compliant,

00:27:11.920 --> 00:27:15.190
but it has a lot of
features, that in some cases,

00:27:15.190 --> 00:27:19.150
are crucial for the success
of shipping products.

00:27:19.150 --> 00:27:21.130
There are several
of these features.

00:27:21.130 --> 00:27:24.250
And I've listed a bunch
of my favorites here.

00:27:24.250 --> 00:27:26.920
So there is channel monitor
and channel manager.

00:27:26.920 --> 00:27:29.470
So Thread operates
in 2.4 gigahertz,

00:27:29.470 --> 00:27:31.660
the same frequency as Wi-Fi.

00:27:31.660 --> 00:27:35.440
So to a wide interference, we
monitor all Thread channels,

00:27:35.440 --> 00:27:37.390
we collect data
over days, and we

00:27:37.390 --> 00:27:39.980
move to a clean channel
from time to time.

00:27:39.980 --> 00:27:42.570
So that's the channel
monitor and channel manager.

00:27:42.570 --> 00:27:45.490
There's another important
feature, jamming detection.

00:27:45.490 --> 00:27:48.220
So we're able to detect when
our network is being jammed.

00:27:48.220 --> 00:27:50.500
And we can alert
the application.

00:27:50.500 --> 00:27:53.590
Another interesting feature
is the periodic parent search.

00:27:53.590 --> 00:27:56.890
So when we first started working
on our Nest Garden and Nest

00:27:56.890 --> 00:27:59.450
Detect, we made
the network really,

00:27:59.450 --> 00:28:01.550
really strong between them.

00:28:01.550 --> 00:28:03.100
So we tricked a
bunch of parameters

00:28:03.100 --> 00:28:04.810
and made the
connection so strong

00:28:04.810 --> 00:28:07.420
that when we deployed
them and we introduce

00:28:07.420 --> 00:28:10.510
a new router in the middle,
like the Nest Connect,

00:28:10.510 --> 00:28:12.790
the problem was this
device is sleepy.

00:28:12.790 --> 00:28:15.760
And it was trying so hard
to maintain the connection

00:28:15.760 --> 00:28:18.190
with the existing
parent that it could not

00:28:18.190 --> 00:28:21.640
move to this better parent,
this potentially better parent.

00:28:21.640 --> 00:28:24.972
So we introduced this feature
called Periodic Parent Search,

00:28:24.972 --> 00:28:26.680
where every so often
the device will look

00:28:26.680 --> 00:28:28.420
for a better parent and move.

00:28:28.420 --> 00:28:31.240
However, we couldn't do this
too often, because every time we

00:28:31.240 --> 00:28:33.220
were doing this, we were
keeping the receiver

00:28:33.220 --> 00:28:34.630
on for eight seconds.

00:28:34.630 --> 00:28:36.890
And that eats into
the battery life.

00:28:36.890 --> 00:28:38.950
So we did some
computations and came up

00:28:38.950 --> 00:28:40.290
with 10 hours as our number.

00:28:40.290 --> 00:28:42.410
So every 10 hours,
our Nest Detect

00:28:42.410 --> 00:28:43.660
will look for a better parent.

00:28:43.660 --> 00:28:45.820
And even if the network
topology changes,

00:28:45.820 --> 00:28:48.310
it will form the right parent.

00:28:48.310 --> 00:28:50.390
And now we ran into
another use case.

00:28:50.390 --> 00:28:52.810
So this device in the
middle, this new parent,

00:28:52.810 --> 00:28:54.220
say it gets a software update.

00:28:54.220 --> 00:28:55.180
It reboots.

00:28:55.180 --> 00:28:57.490
And at this time,
the Nest Detect

00:28:57.490 --> 00:29:00.220
immediately goes back to
the less appealing parent.

00:29:00.220 --> 00:29:01.930
And now it doesn't
make sense for us

00:29:01.930 --> 00:29:03.790
to wait a whole 10 hours.

00:29:03.790 --> 00:29:07.120
So we detect an
involuntary detach,

00:29:07.120 --> 00:29:08.950
and we check again in
10 minutes to go back

00:29:08.950 --> 00:29:09.950
to our better parent.

00:29:09.950 --> 00:29:12.010
So a lot of such
features were added.

00:29:12.010 --> 00:29:14.500
And all of these are
practical use cases

00:29:14.500 --> 00:29:16.930
that every product out
there will run into.

00:29:16.930 --> 00:29:19.030
And Nest has already
gone through the process.

00:29:19.030 --> 00:29:23.570
And we've added several
features that help everyone.

00:29:23.570 --> 00:29:26.530
So in addition to those,
there were also really small

00:29:26.530 --> 00:29:28.690
but high-impact improvements
that we've added.

00:29:28.690 --> 00:29:30.850
So we talked about
this parent switch.

00:29:30.850 --> 00:29:34.390
So each parent remembers the
information about a child

00:29:34.390 --> 00:29:36.010
until a certain timeout.

00:29:36.010 --> 00:29:38.680
So what happens is
when the child moves

00:29:38.680 --> 00:29:40.390
to a different
parent, the old parent

00:29:40.390 --> 00:29:41.740
does not know that it's gone.

00:29:41.740 --> 00:29:44.210
So it continues to queue
packets for this child.

00:29:44.210 --> 00:29:47.110
So we added another feature
to tell the old parent

00:29:47.110 --> 00:29:49.660
that the child has moved on,
requesting it to remove it

00:29:49.660 --> 00:29:51.500
from its child table.

00:29:51.500 --> 00:29:54.430
So a lot of other changes
were added as well

00:29:54.430 --> 00:29:57.250
to get a better sleep
current, and so on.

00:29:57.250 --> 00:30:00.262
So to sum up, there were
a lot of useful tools

00:30:00.262 --> 00:30:01.720
and a great number
of features that

00:30:01.720 --> 00:30:05.170
are added to OpenThread
on top of Thread 1.1.

00:30:05.170 --> 00:30:08.410
And I also want to point
out that OpenThread was not

00:30:08.410 --> 00:30:11.140
designed just for with
Nest products in mind.

00:30:11.140 --> 00:30:13.480
Our goal is to accelerate
the development

00:30:13.480 --> 00:30:15.520
of connected devices everywhere.

00:30:15.520 --> 00:30:17.810
So we not only made
it open source,

00:30:17.810 --> 00:30:20.530
but we've also added several
features that Nest doesn't even

00:30:20.530 --> 00:30:23.290
use, like DSAP, DNS, and co-op.

00:30:23.290 --> 00:30:26.920
And these are very useful for
existing internet-based devices

00:30:26.920 --> 00:30:29.140
to adopt Thread.

00:30:29.140 --> 00:30:32.290
So please make use of these
tried and tested platforms

00:30:32.290 --> 00:30:34.270
and the open source
platforms and tools.

00:30:34.270 --> 00:30:37.210
And let's bring more of those
connected devices online.

00:30:37.210 --> 00:30:42.000
So with that, let's
check out some demos.

00:30:42.000 --> 00:30:46.170
What we have here is several
development boards all

00:30:46.170 --> 00:30:48.840
running OpenThread.

00:30:48.840 --> 00:30:53.370
So we have an Android
Things board here.

00:30:53.370 --> 00:30:56.460
This is the IMX 70
[INAUDIBLE] board.

00:30:56.460 --> 00:30:57.900
This is acting as a host.

00:30:57.900 --> 00:31:01.560
It has an LCD screen, and it
has a speaker attached to it.

00:31:01.560 --> 00:31:03.840
There is also the SiLabs
[INAUDIBLE] board.

00:31:03.840 --> 00:31:07.290
This is acting as the NCP
for the Android Things.

00:31:07.290 --> 00:31:11.100
We have a couple of Nordic
development boards here acting

00:31:11.100 --> 00:31:12.630
as System on Chip.

00:31:12.630 --> 00:31:15.240
One has a switch, and
the other one as a light.

00:31:15.240 --> 00:31:16.890
We have a couple
of Raspberry Pis

00:31:16.890 --> 00:31:19.680
here set up as border
routers, each of them

00:31:19.680 --> 00:31:21.000
using a different radio.

00:31:21.000 --> 00:31:23.630
One is using the TI
radio, another one

00:31:23.630 --> 00:31:25.350
is using a Nordic dongle.

00:31:25.350 --> 00:31:28.530
We have a SiLabs mighty
[INAUDIBLE] EFR32 development

00:31:28.530 --> 00:31:29.580
board.

00:31:29.580 --> 00:31:32.820
And also I have an NXP
dev board here that I'm

00:31:32.820 --> 00:31:34.710
going to use as my sniffer.

00:31:34.710 --> 00:31:37.530
So before we get into
the actual demo itself,

00:31:37.530 --> 00:31:39.520
I want to show you some
tools and resources

00:31:39.520 --> 00:31:42.124
and how to get to each
of these platforms.

00:31:45.030 --> 00:31:47.500
So I'm going to plug in
the sniffer into my laptop.

00:31:53.280 --> 00:31:57.530
First, let's go to
our GitHub page.

00:32:00.850 --> 00:32:05.320
So this GitHub.com/openthread,
this is where we go.

00:32:05.320 --> 00:32:07.660
So we have the code for
OpenThread, border router,

00:32:07.660 --> 00:32:09.800
wpandtund, and [INAUDIBLE].

00:32:09.800 --> 00:32:12.200
The [INAUDIBLE] is the
tool I'm going to use

00:32:12.200 --> 00:32:13.580
to start my sniffer capture.

00:32:38.930 --> 00:32:42.680
I may have to open a
different serial port here.

00:32:49.750 --> 00:32:52.790
I think that looks
a bit better, maybe?

00:32:55.570 --> 00:32:58.410
So well, while that's going in
the background, so that there,

00:32:58.410 --> 00:33:01.150
that's the sniffer that's
running the standard NCP image,

00:33:01.150 --> 00:33:04.790
starting to capture packets that
are flowing between these two

00:33:04.790 --> 00:33:05.290
devices.

00:33:05.290 --> 00:33:07.870
So I have a Nest Guard
and a Nest Detect here.

00:33:07.870 --> 00:33:10.990
So you can see there
are data requests and IP

00:33:10.990 --> 00:33:12.800
packets flowing back and forth.

00:33:12.800 --> 00:33:15.670
And this is just standard
Wireshark that you see here.

00:33:15.670 --> 00:33:18.130
So I'm going to log to this
device and show you some things

00:33:18.130 --> 00:33:18.630
there.

00:33:21.750 --> 00:33:23.870
So I'm logged into the device.

00:33:23.870 --> 00:33:26.600
And I'm going to use
a wpandtund CDL, which

00:33:26.600 --> 00:33:28.490
is the tool used by wpandtund.

00:33:28.490 --> 00:33:30.320
It's the command line interface.

00:33:30.320 --> 00:33:32.330
So we can do
wpandtund CDL status

00:33:32.330 --> 00:33:35.310
to look at the status
of the network.

00:33:35.310 --> 00:33:38.530
And we can do a
wpandtund CDL get.

00:33:38.530 --> 00:33:40.970
And this prints
all the parameters

00:33:40.970 --> 00:33:43.490
that we have associated
with this network.

00:33:43.490 --> 00:33:46.360
And these are the counters
that I was talking about.

00:33:46.360 --> 00:33:48.980
There's so many useful counters
to track various things.

00:33:48.980 --> 00:33:50.720
And these are great
debugging tools.

00:34:03.870 --> 00:34:07.510
So what I'm doing here is
just showing you the logs.

00:34:07.510 --> 00:34:11.489
And I don't see any logs.

00:34:11.489 --> 00:34:14.780
Got a typo there, sorry.

00:34:14.780 --> 00:34:15.560
There.

00:34:15.560 --> 00:34:18.949
So here, this is what
the logs look like.

00:34:18.949 --> 00:34:20.090
And they are really great.

00:34:20.090 --> 00:34:23.179
So you can see these are
just standard IP packets.

00:34:23.179 --> 00:34:25.440
You can see these IP packets.

00:34:25.440 --> 00:34:29.000
We can see data pulls
received from this device

00:34:29.000 --> 00:34:30.739
to this device, and so on.

00:34:30.739 --> 00:34:38.360
And I can also send a ping
from one device to another.

00:34:38.360 --> 00:34:41.719
And that's just a
standard IP ping.

00:34:41.719 --> 00:34:44.420
And if I go back to my
Wireshark, there it is.

00:34:44.420 --> 00:34:47.000
So if you're familiar
with this too,

00:34:47.000 --> 00:34:49.790
you'll immediately recognize
that these are just standard IP

00:34:49.790 --> 00:34:53.150
pings and standard IP packets.

00:34:53.150 --> 00:34:57.980
And the next thing I'm going to
show you is OpenThread on I/O.

00:34:57.980 --> 00:35:00.890
This is the page that
we recommend going to.

00:35:00.890 --> 00:35:04.320
And here, you have all the
information that you need here.

00:35:04.320 --> 00:35:08.030
So you go to Platforms, and here
is all the development boards

00:35:08.030 --> 00:35:09.330
that I have over there.

00:35:09.330 --> 00:35:10.970
And you can click
on any of them,

00:35:10.970 --> 00:35:14.030
and that will take you
to their GitHub page

00:35:14.030 --> 00:35:16.590
where they tell you how
to built the samples,

00:35:16.590 --> 00:35:20.040
how to load the code,
and run the example.

00:35:20.040 --> 00:35:22.820
And if we go back, we can
see other operating systems.

00:35:22.820 --> 00:35:24.860
We see the Linux-based
operating system.

00:35:24.860 --> 00:35:27.960
We have Android Things, NCP
platforms, and the board

00:35:27.960 --> 00:35:29.030
of router support.

00:35:29.030 --> 00:35:31.460
So there's the Raspberry
Pi border router support.

00:35:31.460 --> 00:35:36.200
And I've used this exact
example to replicate

00:35:36.200 --> 00:35:37.324
the setup over there.

00:35:37.324 --> 00:35:38.990
So I'm going to show
you how that works.

00:35:42.950 --> 00:35:47.740
So that border router
is advertising an AP.

00:35:51.440 --> 00:35:53.190
So here.

00:35:53.190 --> 00:35:55.190
So first, we can
open up a web app.

00:35:55.190 --> 00:35:56.780
I'm connected to that AP.

00:35:56.780 --> 00:36:00.860
And I'm directly typing in
the IP address of the device.

00:36:00.860 --> 00:36:04.190
And now I can directly start
controlling the network

00:36:04.190 --> 00:36:05.990
from this web GUI.

00:36:05.990 --> 00:36:09.050
So I can say, for
example, I can,

00:36:09.050 --> 00:36:10.490
from the network from here--

00:36:15.120 --> 00:36:16.980
so it's going.

00:36:16.980 --> 00:36:19.730
And I can open up the
Thread Commissioning app.

00:36:19.730 --> 00:36:22.830
So this can be downloaded
from Google Play.

00:36:22.830 --> 00:36:25.770
And this will detect
the border router first.

00:36:35.760 --> 00:36:37.520
There it found
the border router.

00:36:37.520 --> 00:36:39.110
Now to add a device
to the network,

00:36:39.110 --> 00:36:44.420
I'm simply going to
scan its QR code.

00:36:44.420 --> 00:36:51.740
And when I do that, the QR
code contains information

00:36:51.740 --> 00:36:56.240
about the serial ID of the
device and its pairing code.

00:36:56.240 --> 00:36:59.860
And there, the Thread device
got added to the network.

00:36:59.860 --> 00:37:01.340
And I can do the
same thing using

00:37:01.340 --> 00:37:04.209
this sample I've programmed
in the Android Things board.

00:37:04.209 --> 00:37:05.500
And there's a speaker attached.

00:37:05.500 --> 00:37:09.270
So you might be able to hear
what it's doing as I'm typing.

00:37:09.270 --> 00:37:12.220
So I can look at the
current network info.

00:37:12.220 --> 00:37:13.220
- The device is offline.

00:37:13.220 --> 00:37:15.136
VAAS KRISHNAMURTHY: It
says device is offline.

00:37:15.136 --> 00:37:15.710
I can scan.

00:37:15.710 --> 00:37:18.147
- Scanning for networks.

00:37:18.147 --> 00:37:19.730
VAAS KRISHNAMURTHY:
I find my network.

00:37:19.730 --> 00:37:21.525
And I'm going to connect to it.

00:37:21.525 --> 00:37:23.290
- Joining [INAUDIBLE].

00:37:25.820 --> 00:37:27.281
VAAS KRISHNAMURTHY: And--

00:37:27.281 --> 00:37:28.512
- The device is attached.

00:37:28.512 --> 00:37:29.720
VAAS KRISHNAMURTHY: So there.

00:37:29.720 --> 00:37:32.690
That was a simple app that
is also available on GitHub

00:37:32.690 --> 00:37:34.040
that you can try out.

00:37:34.040 --> 00:37:37.500
So now, I'm going to show
you the OpenWeave demo.

00:37:37.500 --> 00:37:40.719
So this is similar to the one
that you have in the code labs.

00:37:40.719 --> 00:37:42.260
It's just the result
of the code lab.

00:37:42.260 --> 00:37:45.600
And we're going to go over that.

00:37:45.600 --> 00:37:48.380
And what we have here
is a device configured

00:37:48.380 --> 00:37:52.070
as a switch and another
device configured as a light.

00:37:52.070 --> 00:37:55.070
And this pretty much is
just turning on the light.

00:37:55.070 --> 00:37:58.730
And there's a lot of
mechanics that go into it.

00:37:58.730 --> 00:38:01.640
So the light turned on,
and the light turns off.

00:38:01.640 --> 00:38:05.090
So what this is doing is
sending a Wave packet, which

00:38:05.090 --> 00:38:07.520
is encapsulated
in an IP message,

00:38:07.520 --> 00:38:09.740
going over the Thread radio.

00:38:09.740 --> 00:38:12.080
And the other thing that
also happens at this time

00:38:12.080 --> 00:38:16.020
is we have a cloud service
running over there.

00:38:16.020 --> 00:38:19.100
And every time I
change the state

00:38:19.100 --> 00:38:21.740
of the light, that gets
updated in the cloud.

00:38:21.740 --> 00:38:25.400
And that happens because this
information goes via Thread

00:38:25.400 --> 00:38:26.660
to our border router.

00:38:26.660 --> 00:38:29.240
And the border router is
connected to our Wi-Fi AP.

00:38:29.240 --> 00:38:31.930
And it uploads it to the cloud.

00:38:31.930 --> 00:38:35.690
So that concludes our demos.

00:38:35.690 --> 00:38:38.660
[APPLAUSE]

00:38:44.120 --> 00:38:45.780
We'd love to hear from you.

00:38:45.780 --> 00:38:49.915
Please provide us some feedback
at our I/O scheduled place.

00:38:49.915 --> 00:38:51.110
JONATHAN HUI: Yes.

00:38:51.110 --> 00:38:52.710
So that's all we
have for you today.

00:38:52.710 --> 00:38:54.210
Thank you very much for coming.

00:38:54.210 --> 00:38:56.240
We really hope you
enjoyed this session.

00:38:56.240 --> 00:38:58.880
I encourage you to go over
to our IoT sandbox, which

00:38:58.880 --> 00:39:00.230
is just next door.

00:39:00.230 --> 00:39:02.330
You can see more demos,
see more things happening,

00:39:02.330 --> 00:39:04.220
meet the rest of the team.

00:39:04.220 --> 00:39:06.860
And after tomorrow, you can
check out more information

00:39:06.860 --> 00:39:11.500
at OpenThread.IO,
GitHub.com/openthread,

00:39:11.500 --> 00:39:13.850
and go to
GoogleGroupsopenthread-users.

00:39:13.850 --> 00:39:16.050
And thank you again
for joining us.

00:39:16.050 --> 00:39:18.816
Have a great rest of Google I/O.

00:39:18.816 --> 00:39:23.440
[MUSIC PLAYING]

