WEBVTT
Kind: captions
Language: en

00:00:02.330 --> 00:00:07.899
&gt;&gt;Gabe Cohen: Hi, everybody. Welcome to Taking
Android to Work. My name is Gabe Cohen. I'm

00:00:07.899 --> 00:00:12.111
the product manager for Android Enterprise.
And I have with me Fred Chung, who's a developer

00:00:12.111 --> 00:00:17.130
advocate on Android, and Andy Standler, who's
one of the senior engineers on Android.

00:00:17.130 --> 00:00:21.560
We're going to talk today about enterprise
mobility, Android's enterprise features, and

00:00:21.560 --> 00:00:26.060
how you can extend Android in the enterprise.
But first, a little bit of housekeeping. And

00:00:26.060 --> 00:00:29.660
you've been through this for many, many sessions
now. You've got our links to provide feedback

00:00:29.660 --> 00:00:33.540
on the session, whether or not you find it
useful. And also to submit questions via moderator.

00:00:33.540 --> 00:00:39.370
Of course, we'll take live questions also.
So let's get started.

00:00:39.370 --> 00:00:43.750
As you've been hearing over the last couple
of days, Android is growing very, very fast.

00:00:43.750 --> 00:00:48.551
There are hundreds of devices, hundreds of
carriers, 400,000 devices being activated

00:00:48.551 --> 00:00:51.190
a day, and over 100 million device activations
to date.

00:00:51.190 --> 00:00:58.059
But you might not know it's also growing fast
in the workplace. But why is that?

00:00:58.059 --> 00:01:02.339
You could point to that consumer growth as
the source of the momentum. But how does it

00:01:02.339 --> 00:01:07.740
actually translate into workplace acceptance?
Well, let's think back a second.

00:01:07.740 --> 00:01:12.040
It used to be the case that the I.T. department
bought smartphones. They'd buy hundreds and

00:01:12.040 --> 00:01:15.940
thousands of devices. They'd set them up,
they'd give them to the users, they'd support

00:01:15.940 --> 00:01:20.300
the users, they'd pay for the data plans and
so on. And then really good smartphones started

00:01:20.300 --> 00:01:24.120
coming out that were targeted directly at
consumers and consumers started buying the

00:01:24.120 --> 00:01:28.610
smartphones themselves. And some of those
consumers, namely, C-level executives at Fortune

00:01:28.610 --> 00:01:34.440
500 companies started demanding that they
take those phones to work. Because nobody

00:01:34.440 --> 00:01:39.020
wants a cool personal smartphone and a lame
corporate phone; right?

00:01:39.020 --> 00:01:41.750
But to make that work, a phone needs to do
a lot of things.

00:01:41.750 --> 00:01:49.380
Uh-oh. I still have a printer update. That's
amazing.

00:01:49.380 --> 00:01:52.850
Sorry.
Anyway, in order to make that work, the device

00:01:52.850 --> 00:01:57.120
needs to do a lot of things. It needs to meet
your home needs, you personal needs, your

00:01:57.120 --> 00:02:01.370
social needs; it needs to meet your work and
your productivity needs; and it needs to meet

00:02:01.370 --> 00:02:06.390
the needs of the CIO and the I.T. department.
Companies have a really big incentive to work

00:02:06.390 --> 00:02:09.810
with their employees to accept their personal
phones because there's a lot of money to be

00:02:09.810 --> 00:02:14.350
saved in both the hardware and the data plans.
Let's talk about how a company decides to

00:02:14.350 --> 00:02:20.310
accept a mobile platform.
So let's put on our CIO hats for a second

00:02:20.310 --> 00:02:25.830
and funny-looking glasses, bow ties, whatever,
and talk about the main concerns a CIO has

00:02:25.830 --> 00:02:29.850
when accepting a new platform.
First of all, they're securing the corporate

00:02:29.850 --> 00:02:37.790
data from loss or from theft. There's managing
you in and more diverse devices at scale.

00:02:37.790 --> 00:02:41.100
And then there's apps, which is all about
the CIO's responsibility to make the company

00:02:41.100 --> 00:02:45.530
more productive with new technology.
So let's take a second and walk through each

00:02:45.530 --> 00:02:50.819
of these in a little more detail.
So first of all, the CIO needs to make sure

00:02:50.819 --> 00:02:55.680
that the company's data is secure. And even
an employee with the best of intentions is

00:02:55.680 --> 00:02:59.849
a threat to your data security. Because after
four drinks, he leaves his phone on the bar.

00:02:59.849 --> 00:03:04.209
[ Laughter ]
&gt;&gt;Gabe Cohen: And he probably doesn't read

00:03:04.209 --> 00:03:09.319
your memos that you send out about setting
a password and a lock screen for your devices.

00:03:09.319 --> 00:03:13.620
Maybe he takes that phone to Starbucks and
logs onto the corporate intranet, you better

00:03:13.620 --> 00:03:21.099
hope you're using SSL or VPN. In the worst
case, a competitor could find your vice president's

00:03:21.099 --> 00:03:27.209
home, break into her car, steal her phone,
rip out the battery, put it in a faraday cage.

00:03:27.209 --> 00:03:32.660
You get the idea.
Secondly, the CIO needs to figure out the

00:03:32.660 --> 00:03:37.110
processes that are required to manage all
of these new devices, more diverse devices

00:03:37.110 --> 00:03:41.870
at scale. Which means they need to set processes
for the users, how do they know whether or

00:03:41.870 --> 00:03:46.040
not their phone is accepted? How do they set
it up? How do they bring it online on the

00:03:46.040 --> 00:03:49.920
network and to the intranet, the mail service,
et cetera?

00:03:49.920 --> 00:03:53.520
They need to define security policies for
the company or potentially for individual

00:03:53.520 --> 00:03:58.990
organizations within the company that have
different security needs depending on the

00:03:58.990 --> 00:04:01.510
types of information they handle. They need
to figure out how to support more users over

00:04:01.510 --> 00:04:06.379
time on different kinds of devices, if they
have problems using the device, if they forget

00:04:06.379 --> 00:04:11.141
their password, which is extremely common,
if they lose it. And then, finally, over time,

00:04:11.141 --> 00:04:16.890
they need to keep a holistic view of the entire
fleet.

00:04:16.890 --> 00:04:20.949
Finally, the CIO needs to make the company
more productive with the new technology. And

00:04:20.949 --> 00:04:24.860
that means they need to look at the key software
that their employees use, they need to look

00:04:24.860 --> 00:04:29.910
at whether or not there are mobile interfaces
or apps available for that software, and then

00:04:29.910 --> 00:04:35.009
decide whether or not to build mobile apps
for that software or buy them. And once they

00:04:35.009 --> 00:04:39.039
have the software, they have to get it to
the users. How do they distribute the apps

00:04:39.039 --> 00:04:46.740
to those users' devices? And then over time,
how do they maintain them?

00:04:46.740 --> 00:04:51.909
And in some cases they need to lock down the
applications users can use on devices because

00:04:51.909 --> 00:04:55.979
there might be liability issues. You know,
with users consuming mature content or consuming

00:04:55.979 --> 00:05:01.199
lots of data that might come back in a corporate
overage bill. They might also have regulatory

00:05:01.199 --> 00:05:05.750
issues they need to comply with.
So now that we've looked at those three major

00:05:05.750 --> 00:05:10.509
areas the enterprises consider when deciding
to decide a platform, I want to talk quickly

00:05:10.509 --> 00:05:15.539
about how Android actually addresses those
needs.

00:05:15.539 --> 00:05:21.919
So Android is first and foremost focused on
users. We want to build hardware and software

00:05:21.919 --> 00:05:28.319
that users lust after. We also want to build
the ecosystem as big and as fast as possible,

00:05:28.319 --> 00:05:32.669
because it pays all these dividends in terms
of network benefits; right? We get more developers,

00:05:32.669 --> 00:05:37.129
we get more applications, more devices, and
more user choice.

00:05:37.129 --> 00:05:41.580
But there's a lot of money being spent in
the enterprise. Enterprises spend millions

00:05:41.580 --> 00:05:47.552
and millions of dollars on hardware, software,
services, support, and so on. And there are

00:05:47.552 --> 00:05:51.129
actually a lot of users in the enterprise
as well. Like, a lot of consumers actually

00:05:51.129 --> 00:05:57.479
have jobs. And those are the users that we're
focused on here. We want to unlock their ability

00:05:57.479 --> 00:06:02.539
to take their personal phone to work and use
it for both purposes.

00:06:02.539 --> 00:06:07.279
But it's really important that we keep the
enterprise support that's in Android open

00:06:07.279 --> 00:06:11.629
and extensible, because we want OEMs and software
vendors to go out there and make money in

00:06:11.629 --> 00:06:17.439
the enterprise today. And they're actually
doing that. If you look at the Motorola, they

00:06:17.439 --> 00:06:21.369
released an enterprise-focused device, the
Droid Pro. It has a better keyboard for business

00:06:21.369 --> 00:06:26.029
usage.
You can look at NitroDesk. They released TouchDown,

00:06:26.029 --> 00:06:29.170
which is a drop-in Outlook replacement, essentially,
for your phone that's available in Market.

00:06:29.170 --> 00:06:33.880
It's extremely popular.
One of our partners, Mobile Iron, actually

00:06:33.880 --> 00:06:37.949
has added Android support to the platform
to their Mobile Device Management Suite.

00:06:37.949 --> 00:06:42.319
So we have a lot of partners out there doing
different things. And especially when you

00:06:42.319 --> 00:06:47.080
look at the OEMs and the carriers, they're
doing a lot of interesting things and moving

00:06:47.080 --> 00:06:50.930
potentially in a lot of different directions.
It's a good thing, because they're out there

00:06:50.930 --> 00:06:55.759
actually getting devices into the workplace
today. But Android actually needs to introduce

00:06:55.759 --> 00:06:59.679
standards over time into the platform so that
the enterprise features that are there for

00:06:59.679 --> 00:07:05.659
developers are exposed in a consistent way.
So next I want to talk just briefly about

00:07:05.659 --> 00:07:12.289
the features we've actually added to the platform
over time.

00:07:12.289 --> 00:07:17.210
So way back in Donut, we introduced some of
the first relevant features, secure Wi-Fi

00:07:17.210 --> 00:07:22.860
and VPN support. In Eclair, we added basic
exchange support for e-mail and contacts.

00:07:22.860 --> 00:07:27.650
In Froyo, we completed the exchange support
by adding calendar. And then we added a really

00:07:27.650 --> 00:07:32.100
important piece we're going to talk about
again -- talk about in a minute, which is

00:07:32.100 --> 00:07:35.719
device policy management, which is about setting
up security features and requirements for

00:07:35.719 --> 00:07:40.289
the phones. In Gingerbread, we added more
productivity features into GMail and calendar

00:07:40.289 --> 00:07:45.599
and contacts. And in Honeycomb, we added some
really interesting stuff. We added more security

00:07:45.599 --> 00:07:49.629
policies that control passwords. We added
support for device encryption, which is one

00:07:49.629 --> 00:07:53.679
of the most frequently requested features
we have been getting from enterprise customers.

00:07:53.679 --> 00:07:57.089
We added global address list support across
the suite of apps and in contacts for both

00:07:57.089 --> 00:08:03.199
exchange and Google Apps.
So that's kind of an overview of how Android

00:08:03.199 --> 00:08:06.709
is approaching the enterprise, the features
that we built, how we're prioritizing things.

00:08:06.709 --> 00:08:11.349
And I hope that's been useful to you guys.
Next I'm going to hand it over to Andy Standler,

00:08:11.349 --> 00:08:15.759
who's going to talk a little bit about device
policy management framework.

00:08:15.759 --> 00:08:21.979
&gt;&gt;Andy Stadler: Thanks, Gabe.
Okay. Hi, my name is Andy Standler, and I'm

00:08:21.979 --> 00:08:26.379
going to sort of address the fact that this
is a developers' conference and dive into

00:08:26.379 --> 00:08:31.650
a little bit more of a development topic,
actually. And that is how you, as developers,

00:08:31.650 --> 00:08:36.840
can tackle one of the problems that Gabe touched
on. And that is how can your app ensure that

00:08:36.840 --> 00:08:42.260
it is running on a secure device. Or how can
your app control the aspects of your device

00:08:42.260 --> 00:08:45.880
configuration to make sure that it is in a
secure environment.

00:08:45.880 --> 00:08:51.050
Now, what kind of apps need this? I've kind
of broken it down into three really broad

00:08:51.050 --> 00:08:57.950
categories. The first is apps that are really
the client end point of fleet management solutions.

00:08:57.950 --> 00:09:01.340
And I've listed a couple here that you're
almost certainly familiar with. These are

00:09:01.340 --> 00:09:06.330
the apps that provide an administrator with
the ability to control and monitor the security

00:09:06.330 --> 00:09:12.000
status of a whole fleet of devices.
Now, some apps don't work with a server, but

00:09:12.000 --> 00:09:16.770
they really need to also provide the assurance
that they are on a secure device and that

00:09:16.770 --> 00:09:23.870
the data that they're collecting or presenting
is safe, remains safe, and is presented only

00:09:23.870 --> 00:09:26.400
to the intended users.
And, finally, there are apps that provide

00:09:26.400 --> 00:09:31.130
device management or fleet management types
of capabilities, but they are really oriented

00:09:31.130 --> 00:09:35.300
toward single users.
Now, these are really just a loose collection

00:09:35.300 --> 00:09:40.190
of overlapping suggestions. There are plenty
of other kind of interesting ways to deploy

00:09:40.190 --> 00:09:46.220
and use these devices. And our challenge was
to enhance the Android framework in a way

00:09:46.220 --> 00:09:50.760
that could support applications like these,
applications you can come up with, and, most

00:09:50.760 --> 00:09:55.150
importantly, support multiple applications.
We've always believed strongly that Android

00:09:55.150 --> 00:10:00.470
apps need to coexist peacefully with each
other. And security-oriented applications

00:10:00.470 --> 00:10:04.860
really are no different.
So in order to support applications like the

00:10:04.860 --> 00:10:10.280
ones I have described, we developed the Device
Policy Manager. And in the next few slides,

00:10:10.280 --> 00:10:15.120
I'm going to show you what it does and how
you can write apps to use it.

00:10:15.120 --> 00:10:20.650
So the first thing to tell you about is policies.
And these are the actual specific controls

00:10:20.650 --> 00:10:26.610
that an app can place on a device. So you're
very familiar with policies, things like require

00:10:26.610 --> 00:10:31.590
a screen lock password, require the device
to be encrypted. These are policies.

00:10:31.590 --> 00:10:36.870
We introduced policies in Froyo. We enhanced
and added to them in Honeycomb. And we are

00:10:36.870 --> 00:10:40.440
going to keep on adding policies as releases
continue.

00:10:40.440 --> 00:10:46.830
And if you want to think about where -- the
roles involved, there are really these roles:

00:10:46.830 --> 00:10:51.550
Applications that you write are going to set
the policies. The Device Policy Manager is

00:10:51.550 --> 00:10:57.400
the APIs and the framework for maintaining
those policies and communicating them among

00:10:57.400 --> 00:11:02.660
the various modules. And, finally, the rest
of the system is supposed to obey the policies.

00:11:02.660 --> 00:11:06.750
Now, let's look at one sort of interesting
aspect of this, which is, what happens when

00:11:06.750 --> 00:11:11.200
you have multiple apps that are trying to
control policies?

00:11:11.200 --> 00:11:14.870
When there are multiple sources of security
policies, we need to consider what I call

00:11:14.870 --> 00:11:21.230
the principle of increasing security. Any
app can make or set policies that increase

00:11:21.230 --> 00:11:26.150
the security of the device, but no app can
use policies to reduce the security of the

00:11:26.150 --> 00:11:29.620
device.
In practice, this really just boils down to

00:11:29.620 --> 00:11:33.760
a simple set of rules for each policy. So,
for example, passwords need to keep getting

00:11:33.760 --> 00:11:40.150
longer and stronger or more complex. And things
like a screen-lock timeout would get shorter

00:11:40.150 --> 00:11:44.980
and shorter, which makes for a more secure
device.

00:11:44.980 --> 00:11:48.740
You might be wondering if the policies I'm
describing or the concept of policies is really

00:11:48.740 --> 00:11:52.860
just a different version of Android permissions.
And they're a little different in a subtle

00:11:52.860 --> 00:11:58.290
but important way.
Policies -- I'm sorry, permissions are -- they

00:11:58.290 --> 00:12:05.180
basically let your apps do things that are
risky or may be costly or might expose data.

00:12:05.180 --> 00:12:08.611
Policies, on the other hand, actually increase
the security of the device. So they kind of

00:12:08.611 --> 00:12:13.270
-- the more policies, you're moving in the
more secure direction.

00:12:13.270 --> 00:12:17.260
Anyway, now, with these policies in place,
we just have to define an API and a work flow

00:12:17.260 --> 00:12:21.550
for using them.
Now, in order for you to create a policy management

00:12:21.550 --> 00:12:25.900
application, you need to add the following
three elements. The first is that you need

00:12:25.900 --> 00:12:30.990
to explicitly define the policies that you're
going to enforce.

00:12:30.990 --> 00:12:34.950
The second is you write a receiver. This is
very similar to a broadcast receiver. And

00:12:34.950 --> 00:12:39.910
this is so that you may be notified of the
changes to the device security status.

00:12:39.910 --> 00:12:42.730
And third, you're going to write a policy
controller. And this is where you actually

00:12:42.730 --> 00:12:47.580
write your own code which interacts with the
Device Policy Manager to monitor and control

00:12:47.580 --> 00:12:52.140
the security status of your device and also
to enforce whatever business logic is associated

00:12:52.140 --> 00:12:56.610
with that security.
So now we're going to take a look at a sample

00:12:56.610 --> 00:13:01.410
implementation. We'll start with the policy
declarations. This is simply a list, like

00:13:01.410 --> 00:13:08.570
I said, of the policies that your app intends
to enforce. And each policy directly corresponds

00:13:08.570 --> 00:13:15.730
to one or more API calls. If you don't declare
the policy, you may not make these calls.

00:13:15.730 --> 00:13:19.490
And we're going to see later this same list
will be shown to the user in a system activity.

00:13:19.490 --> 00:13:22.660
But, of course, it'll be formatted quite a
bit more nicely.

00:13:22.660 --> 00:13:27.550
And the next thing you're going to implement
is a receiver. And this is where your app

00:13:27.550 --> 00:13:32.170
can be notified of changes to device security
state. I added one little note here, because

00:13:32.170 --> 00:13:36.410
this is one of these things that -- just one
of these general Android programming reminders,

00:13:36.410 --> 00:13:42.100
is that notifications come in on the UI thread.
We always have to be careful and not get ANRs

00:13:42.100 --> 00:13:44.560
and things like that.
But the most important thing is, this is where

00:13:44.560 --> 00:13:47.650
you learn about the changes to the device
status.

00:13:47.650 --> 00:13:51.620
And a little later, we'll talk about the things
that you might do when you respond to these.

00:13:51.620 --> 00:13:57.100
Okay. So, finally, we're going to implement
a policy controller. This will take a few

00:13:57.100 --> 00:14:02.370
slides, but we'll walk through the pieces
of a sort of sample typical policy controller.

00:14:02.370 --> 00:14:09.310
In this case, it's going to be one that requires
a specific policy for your device, that the

00:14:09.310 --> 00:14:13.610
user must have created either a PIN or a password
for their screen lock.

00:14:13.610 --> 00:14:18.580
So the first thing we need to do is find out
if our app has even been activated as a device

00:14:18.580 --> 00:14:23.050
policy administrator. And if our app hasn't
been activated, we will not be able to make

00:14:23.050 --> 00:14:27.950
any policy calls at all.
So the next step is to ask the user to activate

00:14:27.950 --> 00:14:33.150
our app. And this is the place where policies
are like permissions. They are all exposed

00:14:33.150 --> 00:14:38.620
to the user. The user sees them and accepts
them before we can proceed. We don't allow

00:14:38.620 --> 00:14:42.960
just any app to start enforcing policies on
the device.

00:14:42.960 --> 00:14:47.960
So when you make this start activity call,
it presents a system activity which explains

00:14:47.960 --> 00:14:52.540
to the users what they're about to authorize.
And the app only receives permission to assert

00:14:52.540 --> 00:14:58.760
the policies if the user clicks "activate."
Even though this is a system activity, your

00:14:58.760 --> 00:15:02.260
app does have a chance to insert some text,
which gives a chance to tell the user what's

00:15:02.260 --> 00:15:08.150
about to happen and why. And, by the way,
the user might help cancel here. What do you

00:15:08.150 --> 00:15:12.221
do? We'll talk about it a little later. But
the simplest thing to say is that you need

00:15:12.221 --> 00:15:17.100
to be ready to keep trying. If you need to
get your device to a secure state, you need

00:15:17.100 --> 00:15:21.550
to be able to retry this process until the
user gets there. And, obviously, you're not

00:15:21.550 --> 00:15:25.270
going to want to present the secure data or
make the secure connections or whatever it

00:15:25.270 --> 00:15:31.040
is that your app does until they get through
all these steps.

00:15:31.040 --> 00:15:36.810
Now, once we have been activated, we can start
working with the specific policy APIs.

00:15:36.810 --> 00:15:41.790
This next step highlights an important concept,
which is that there are many policies where

00:15:41.790 --> 00:15:46.120
just because you've set a policy, it doesn't
actually mean the device has become more secure.

00:15:46.120 --> 00:15:51.800
So, for example, in this case, we can set
a policy. We can require the user to enter

00:15:51.800 --> 00:15:57.071
a PIN or a password. But until they actually
go through the process of entering a PIN or

00:15:57.071 --> 00:16:01.550
a password, the device isn't really as secure
as we want it to be. So here you see in this

00:16:01.550 --> 00:16:06.770
code the first call sets the policy. And then
the second call asks the question, "Has the

00:16:06.770 --> 00:16:13.970
user done what they need to do to reflect
the policies we've set?"

00:16:13.970 --> 00:16:18.381
And in the case that they haven't done it
yet, we need to again set the policies we

00:16:18.381 --> 00:16:23.650
want and do what we need to do to get the
user to make the changes. And in this case,

00:16:23.650 --> 00:16:27.770
we're going to use standard start activity
call to send an intent, launch the setting

00:16:27.770 --> 00:16:31.790
screen where the user can enter a new PIN
or password.

00:16:31.790 --> 00:16:36.790
Now, normally, the user can choose from four
types of screen lock: None, pattern, PIN,

00:16:36.790 --> 00:16:41.860
or password. But now, because we've established
a policy, the user will only be allowed to

00:16:41.860 --> 00:16:47.810
choose a PIN or a password. So this is a direct
example of the policies that you've set affecting

00:16:47.810 --> 00:16:52.310
the behavior of the system.
Now, once again, this is a place where the

00:16:52.310 --> 00:16:56.930
user might not continue. They might hit back
or home or get a phone call or -- anyway,

00:16:56.930 --> 00:17:00.550
they don't get past the step and they don't
finish creating the PIN or password. So once

00:17:00.550 --> 00:17:05.850
again, this is one of those places where you
need to be ready to sort of restart or dealing

00:17:05.850 --> 00:17:10.689
with this.
Before we wrap up, I would just like to cover

00:17:10.689 --> 00:17:17.749
a few issues that are pretty important when
you are developing device policy applications.

00:17:17.749 --> 00:17:22.299
First, as I've been mentioning before, there's
no denying that it does take a few steps to

00:17:22.299 --> 00:17:27.809
get through the process of getting a device
to a sufficiently secure state. You need to

00:17:27.809 --> 00:17:31.690
account for the fact that the user might not
get through all the steps the first time.

00:17:31.690 --> 00:17:35.860
And your policy controller needs to be able
to restart the process at any point in the

00:17:35.860 --> 00:17:41.350
sequence. And your design should focus on
moving the device step by step towards the

00:17:41.350 --> 00:17:45.909
sufficiently secure state.
So, to use an example, in the platform e-mail

00:17:45.909 --> 00:17:51.519
application, where we walk through this exact
same set of steps, anytime the user exits

00:17:51.519 --> 00:17:57.070
before the completion of the sequence, we
post a notification that says there's a security

00:17:57.070 --> 00:18:02.649
-- security steps are required. But then we
just leave it there, let the user respond

00:18:02.649 --> 00:18:06.289
to the notification, and at that point, bring
them back into the sequence.

00:18:06.289 --> 00:18:09.720
The other thing you might consider is through
the use of dialogues or other ways of communicating

00:18:09.720 --> 00:18:14.120
with the user, tell them what they're about
to do. Because, for example, if you just suddenly

00:18:14.120 --> 00:18:19.299
present a password entry screen, they might
not understand why. So dialogues, notification

00:18:19.299 --> 00:18:25.230
texts, these are all your friends here.
Next, there are going to be times when the

00:18:25.230 --> 00:18:32.399
security level of the device actually decreases.
An example here is that some of the newer

00:18:32.399 --> 00:18:37.669
policies we've added allow you to set device
PIN codes or passwords that have expirations

00:18:37.669 --> 00:18:42.559
on them. These are designed to force the user
to enter a new one, say, every 30 or 60 days.

00:18:42.559 --> 00:18:48.900
Now, if they allow those codes to expire,
your device is not really secure at this point,

00:18:48.900 --> 00:18:55.429
because it's using an old code. So the device
is now in a less secure date than your app

00:18:55.429 --> 00:18:59.850
wants it to be. However, it's really up to
you -- again, this is a business logic question.

00:18:59.850 --> 00:19:06.769
It's really up to you what to do at that point.
And, finally, if you are implementing account-based

00:19:06.769 --> 00:19:13.000
policy applications and if you support multiple
accounts, then you're going to be partially

00:19:13.000 --> 00:19:19.620
responsible for the increasing security notions
that I described earlier. Make sure you don't

00:19:19.620 --> 00:19:27.401
let any one of your accounts reduce the security
levels that was required by any of your other

00:19:27.401 --> 00:19:28.401
accounts.
Now that I've covered the things that you

00:19:28.401 --> 00:19:32.610
need to do when you implement a device administrator.
Fred Chung is going to show you a demo app

00:19:32.610 --> 00:19:44.740
that actually walks you through a few of these
steps.

00:19:44.740 --> 00:19:45.740
[ Applause ]
&gt;&gt;Fred Chung: Thanks, Andy.

00:19:45.740 --> 00:19:49.269
Hello, everyone.
I'm Fred Chung. I'm a developer advocate on

00:19:49.269 --> 00:19:54.299
Android. I work with a lot of external developers,
and my focus area is enterprise.

00:19:54.299 --> 00:19:59.899
Well, Andy just talked about the detailed
implementation of the device policy management

00:19:59.899 --> 00:20:07.029
API. In this section, I'm going to do a demo
that shows a practical application of the

00:20:07.029 --> 00:20:10.149
API.
What -- the use case is actually pretty straightforward.

00:20:10.149 --> 00:20:15.860
We are trying to enhance the security of an
internal application.

00:20:15.860 --> 00:20:21.529
Well, by internal application, it can really
be referring to any applications containing

00:20:21.529 --> 00:20:26.350
sensitive information. Well, for example,
your HR application, where it contains my

00:20:26.350 --> 00:20:31.260
salary information, I really want to secure
that kind of information.

00:20:31.260 --> 00:20:36.120
Typically, those applications may already
have an app-specific password requiring users

00:20:36.120 --> 00:20:41.580
to authenticate. Here's the problem. Can I
see a show of hands, how many of you have

00:20:41.580 --> 00:20:46.119
your screen-lock password set up? Including
the device you got yesterday.

00:20:46.119 --> 00:20:56.269
All right. As it turns out, more than half
of smartphone users don't have their screen

00:20:56.269 --> 00:21:03.980
lock set up. For those of you that didn't
raise your hand, I urge you to please set

00:21:03.980 --> 00:21:06.649
it up after this session.
So back to the demo.

00:21:06.649 --> 00:21:13.289
We're trying to, you know, perform a demo
that's aiming to enhance the security of the

00:21:13.289 --> 00:21:17.809
application by ensuring the proper screen
lock is set up.

00:21:17.809 --> 00:21:23.049
Well, before diving into the demo, let's have
a, you know, quick overview of the high-level

00:21:23.049 --> 00:21:28.220
architecture of the application.
As you can see on the screen, in the middle

00:21:28.220 --> 00:21:34.500
is the Android client in the tablet form factor.
On the right is an admin server that's sitting

00:21:34.500 --> 00:21:40.919
somewhere in the cloud. For this demo application,
the admin server is built on Google App Engine

00:21:40.919 --> 00:21:45.559
for Java. But in reality, it can be based
on any technology stacks. It doesn't really

00:21:45.559 --> 00:21:50.070
matter.
The admin server exposes a couple of interfaces.

00:21:50.070 --> 00:21:56.409
It exposes an HTML administrative interface,
allowing system administrators to go in and

00:21:56.409 --> 00:22:01.190
define security policies. And what I mean
by "security policies" is that they can define

00:22:01.190 --> 00:22:05.629
such things as what's the minimum length of
my password, does the password have to be

00:22:05.629 --> 00:22:09.860
PIN type or alphanumeric or pattern or so
on and so forth.

00:22:09.860 --> 00:22:14.869
Now, the second interface that is exposed
by the administrative server is a Web service

00:22:14.869 --> 00:22:20.580
interface in order to facilitate two-way communication
between the Android client and the server.

00:22:20.580 --> 00:22:28.519
Okay. Let's jump right into the demo.
Right here is -- I'm using this laptop to

00:22:28.519 --> 00:22:35.159
access -- I'm sorry. Can we switch to demo?
&gt;&gt;Gabe Cohen: You're on.

00:22:35.159 --> 00:22:41.470
&gt;&gt;Fred Chung: All right.
Can we switch back to demo, please.

00:22:41.470 --> 00:22:48.620
On your right, I'm looking at my admin server
through Chrome browser. And right here, I

00:22:48.620 --> 00:22:57.169
am working on a Motorola XOOM, obviously running
on Honeycomb. And this icon here is the demo

00:22:57.169 --> 00:23:00.330
app.
Let me go to the admin server first. I'm going

00:23:00.330 --> 00:23:11.950
to go in and log in as a user, a test user.
All right. I'm looking at the administrative

00:23:11.950 --> 00:23:17.150
interface. It's a pretty clean UI. It is an
admin interface allowing administrator to

00:23:17.150 --> 00:23:22.399
go in and define security policy.
Let's go ahead and set up a test security

00:23:22.399 --> 00:23:28.830
policy, say, requiring PIN of minimum of four
digits in length. I'm going to go ahead and

00:23:28.830 --> 00:23:31.749
save it. Now it's persisted to Google App
Engine.

00:23:31.749 --> 00:23:40.210
Now I'm going to go back to the Android client
right here. Before launching, I want to say

00:23:40.210 --> 00:23:46.899
that when you launch the app, it's going to
present you with a series of setup steps.

00:23:46.899 --> 00:23:51.679
Here's the first step. It contains a bunch
of instructions, basically, telling me to

00:23:51.679 --> 00:23:56.429
go to the admin server and set up a security
policy. Since I've already done that, I'm

00:23:56.429 --> 00:24:00.889
going to go back to the Android client and
click "next."

00:24:00.889 --> 00:24:06.119
Now it shows me the list of accounts that
are already set up on the device. And I'm

00:24:06.119 --> 00:24:12.010
just going to and click on the one account
that I have set up.

00:24:12.010 --> 00:24:19.419
Now, the app is about to perform a number
of steps outlined in Andy's section. In reality,

00:24:19.419 --> 00:24:23.549
those steps will probably complete within
a fraction of a second.

00:24:23.549 --> 00:24:28.679
So -- and, therefore, in order to make it
-- in order to make this demo more meaningful

00:24:28.679 --> 00:24:35.210
and make this demo easier to follow by everyone,
we have deliberately introduced a number of

00:24:35.210 --> 00:24:39.950
processes requiring human intervention in
between steps just to make sure the concept

00:24:39.950 --> 00:24:43.879
is clearly communicated across.
The next step that I'm going to perform is

00:24:43.879 --> 00:24:50.090
to synchronize the security policy from the
server. It's syncing. Through 3G network.

00:24:50.090 --> 00:24:55.239
I'm glad that it works.
So it came back, brought back with the security

00:24:55.239 --> 00:24:59.879
policy that we just set up, as you can see,
with PIN and a minimum password length of

00:24:59.879 --> 00:25:04.630
four.
Notice the two question mark icons. Those

00:25:04.630 --> 00:25:10.539
icons represent the fact that at this state,
the application doesn't know how to deal with

00:25:10.539 --> 00:25:16.779
the security policy, because it hasn't been
activated as a device administrator. And I'm

00:25:16.779 --> 00:25:20.039
going to go ahead and do that next by hitting
on this button "activate."

00:25:20.039 --> 00:25:26.720
It then triggers a system dialogue box. And
as Andy also pointed out earlier, that in

00:25:26.720 --> 00:25:31.899
this system dialogue box, you can put in some
customized message to make -- get clearer

00:25:31.899 --> 00:25:38.789
to the users what they are dealing with.
Now, at this point, there could be multiple

00:25:38.789 --> 00:25:43.559
outcomes; right? The users could click on
"activate" or they could click on "cancel,"

00:25:43.559 --> 00:25:49.190
or "back." So when you're dealing with an
application, you need to account for different

00:25:49.190 --> 00:25:55.259
possibilities like that. Let's go back to
the activate screen. This is the same screen

00:25:55.259 --> 00:26:00.769
we just looked at. And let's now go ahead
and activate it. The application has been

00:26:00.769 --> 00:26:06.470
activated as a system administrator. As you
notice on the -- for the icons, they switch

00:26:06.470 --> 00:26:12.109
from question marks to exclamation points,
meaning that the existing password, which

00:26:12.109 --> 00:26:17.399
doesn't exist on this device, the existing
no password set up on this device actually

00:26:17.399 --> 00:26:23.019
is not sufficient as per the device policy.
And, therefore, it's presenting me with this

00:26:23.019 --> 00:26:29.950
enforce password button. And I'm going to
click on this, which then triggers another

00:26:29.950 --> 00:26:35.119
system intent to cause this password change
screen to appear.

00:26:35.119 --> 00:26:42.419
If you remember, we defined a security policy
requiring a PIN type of password. You notice

00:26:42.419 --> 00:26:48.509
how these selections of not secure and patterns
are disabled, because these are deemed less

00:26:48.509 --> 00:26:52.159
secure than what's being required by the security
policy.

00:26:52.159 --> 00:27:00.850
Let's go ahead and set up a pin-type password
of -- I'm not telling you.

00:27:00.850 --> 00:27:08.940
Okay. Now, I have set up a PIN, and the device
recognizes that. Okay, the existing password

00:27:08.940 --> 00:27:15.139
actually is sufficient for the -- what's being
defined by the security policy. And then I

00:27:15.139 --> 00:27:19.149
can actually go ahead and access my security
-- my sensitive content.

00:27:19.149 --> 00:27:29.429
Okay. Now that the device is properly set
up with a screen lock password, and I'm going

00:27:29.429 --> 00:27:37.909
to show you what additional security can be
provided by the administrative API in conjunction

00:27:37.909 --> 00:27:42.859
with cloud-to-device messaging. For those
of you who are not familiar with that, cloud-to-device

00:27:42.859 --> 00:27:45.889
messaging is Google's implementation of push
messaging.

00:27:45.889 --> 00:27:52.970
So -- and one of the criteria that Gabe talked
about in his talk that the CIOs need to really

00:27:52.970 --> 00:27:58.370
care about device loss, theft, right, in the
event that happens, they need to have a way

00:27:58.370 --> 00:28:04.720
to be able to remotely control the device
or remotely limit certain access. And that's

00:28:04.720 --> 00:28:12.269
what this next part of the demo is about.
Let's go back to the admin server screen.

00:28:12.269 --> 00:28:18.590
and navigate to remote admin interface. There
are two buttons. Okay, I'm going to just go

00:28:18.590 --> 00:28:23.059
ahead and click on "lock device." What happens
after clicking on this is that it's going

00:28:23.059 --> 00:28:29.489
to send a push message through C2DM to the
device and the device should react to it by

00:28:29.489 --> 00:28:33.070
locking up the screen. Give it a few seconds.
&gt;&gt;Gabe Cohen: Show your hands.

00:28:33.070 --> 00:28:42.830
&gt;&gt;Fred Chung: And, 
of course, it's not working.

00:28:42.830 --> 00:29:06.659
Let me give it one more try.
Well, it's not working. But I hope you get

00:29:06.659 --> 00:29:20.769
the idea. All right. Can we actually switch
back to presentation mode, please.

00:29:20.769 --> 00:29:25.909
All right. That's too bad. But, trust me,
it works.

00:29:25.909 --> 00:29:36.340
[ Laughter ]
&gt;&gt;Fred Chung: Let's see. So that concludes

00:29:36.340 --> 00:29:41.659
the demo, at least part of the demo, where
we just looked at a proof of concept on the

00:29:41.659 --> 00:29:45.140
kinds of device management capabilities that
are possible.

00:29:45.140 --> 00:29:50.609
What we just looked at is open source under
Google Project Hosting. I strongly encourage

00:29:50.609 --> 00:29:54.730
you to have a look at it.
As developers, you can further expand on these

00:29:54.730 --> 00:30:01.720
kind of capabilities by incorporating more
useful features such as remote wipe or password

00:30:01.720 --> 00:30:10.240
resets.
Now, let's switch topics a little bit and

00:30:10.240 --> 00:30:16.780
talk about a different thing.
One of the criteria CIOs consider is how to

00:30:16.780 --> 00:30:22.440
get apps to users' devices. And let's talk
about that in the next section.

00:30:22.440 --> 00:30:32.369
All right. Well, you may consider, you know,
a -- a system administrator of a company may

00:30:32.369 --> 00:30:37.169
already have a collection of Android apps
that they want their users to install. Well,

00:30:37.169 --> 00:30:43.409
some of these apps may be home-grown applications
that are highly proprietary to the business

00:30:43.409 --> 00:30:49.739
flows of the business. And other types of
apps could be coming from third-party applications

00:30:49.739 --> 00:30:53.530
that are publicly available. And these types
of applications are aimed to increase the

00:30:53.530 --> 00:30:59.850
productivity of the workforce. For example,
TouchDown clients or Documents to Go or Angry

00:30:59.850 --> 00:31:06.039
Birds. The last one may not make sense, may
not be such a good idea for certain businesses.

00:31:06.039 --> 00:31:11.460
But I hope you get the idea.
For these types of publicly available apps,

00:31:11.460 --> 00:31:15.229
right, you may want to direct your employees
to Android Market.

00:31:15.229 --> 00:31:29.149
Let's see.
Okay. Well, Android Market is a great distribution

00:31:29.149 --> 00:31:35.279
vehicle for distributing publicly facing applications
like what we just talked about. All you have

00:31:35.279 --> 00:31:40.989
to do is to direct your users to a URL of
this format by including the package name

00:31:40.989 --> 00:31:45.830
of the apps you want them to install. Using
Android Market, it gives you, you know, a

00:31:45.830 --> 00:31:52.429
number of very useful features at no development
cost. Just to name a couple, hosting, hosting

00:31:52.429 --> 00:31:56.990
is something that you don't need to worry
about. Also, any app updates are automatically

00:31:56.990 --> 00:32:05.749
made available to the clients automatically.
However, internal app distribution may require

00:32:05.749 --> 00:32:11.580
different solutions, because, well, in some
occasions, it doesn't really make sense for

00:32:11.580 --> 00:32:15.360
others to see your internal applications.
Of the or you simply don't want others to

00:32:15.360 --> 00:32:20.460
know the existence of certain private apps.
I'm going to show you two commonly used approaches

00:32:20.460 --> 00:32:27.570
to distribute internal apps next.
Well, let's first have a look at side-loading.

00:32:27.570 --> 00:32:33.309
I'm showing the audience here, the majority
of you should probably know what it is. It's

00:32:33.309 --> 00:32:39.700
actually pretty straightforward. One pretty
common implementation is to host the APKs

00:32:39.700 --> 00:32:45.320
on a server. It can be any server capable
of serving files. It can be Apache, or it

00:32:45.320 --> 00:32:49.580
could even be based on Google Sites works
pretty well, too.

00:32:49.580 --> 00:32:58.299
To install apps, users just need to point
their browsers to their URLs, or by simply

00:32:58.299 --> 00:33:06.070
clicking on a hyperlink. When the download
completes, users taps on the APK, then the

00:33:06.070 --> 00:33:11.229
standard app installation screens will take
over.

00:33:11.229 --> 00:33:18.169
I also want to point out that in order for
side-loading to work, you need to make sure

00:33:18.169 --> 00:33:26.229
that the unknown sources selection under settings
is checked. And since Android is an open system,

00:33:26.229 --> 00:33:31.429
right, different OEMs or carriers may choose
to do different things. Some have chosen to

00:33:31.429 --> 00:33:37.359
disable these settings altogether. And in
that case, side-loading may not be possible

00:33:37.359 --> 00:33:41.739
on those affected devices. I just want to
make sure that people are aware of that.

00:33:41.739 --> 00:33:47.440
Now, we talked about side loading just now.
With this approach, as you can imagine, as

00:33:47.440 --> 00:33:52.549
your usage grows over time -- which, by the
way, is a good problem to have -- it may become

00:33:52.549 --> 00:33:58.349
a little hard for your employees to manage
all of the URLs that they are given. Or sometimes

00:33:58.349 --> 00:33:59.349
they may get all the URLs or the updates mixed
up.

00:33:59.349 --> 00:34:09.230
In order to circumvent this, I'm going to
talk to you about a more sophisticated approach,

00:34:09.230 --> 00:34:15.140
which is what I'm calling Internal App Directory.
Let's have a look at an overview of what this

00:34:15.140 --> 00:34:21.179
Internal App Directory is all about.
In a typical deployment, it involves a -- you

00:34:21.179 --> 00:34:26.270
know, a piece of server software and a corresponding
Android client.

00:34:26.270 --> 00:34:33.290
If you look at this setup, it's not that different
from the demo setup that we just saw.

00:34:33.290 --> 00:34:37.679
Through an administrative interface, system
administrators can publish a bunch of apps

00:34:37.679 --> 00:34:43.120
that they want to be made available to their
users. Periodically, the Android app would

00:34:43.120 --> 00:34:48.230
check in and say, "Hey, give me a list of
apps that my user can install."

00:34:48.230 --> 00:34:54.840
The list would then get displayed on screen.
And at this point, the Android client can

00:34:54.840 --> 00:35:00.770
perform a number of validations, for example,
he can check whether the list of apps already

00:35:00.770 --> 00:35:05.260
exists on the device, and if so, flag the
user appropriately.

00:35:05.260 --> 00:35:10.500
And if you need to build these kind of solutions
yourself, I strongly encourage you just to

00:35:10.500 --> 00:35:17.910
bookmark this API doc for Package Manager.
This API -- this class exposes maybe a few

00:35:17.910 --> 00:35:23.780
dozens of methods that allows you to gain
visibility into the various packages that

00:35:23.780 --> 00:35:28.670
are already installed on the device.
Just to name a couple, this API gives you

00:35:28.670 --> 00:35:34.870
visibility into the kinds of applications
that already exist on the device. And get

00:35:34.870 --> 00:35:41.560
package archive info allows you to do something
like to check the validity of a downloaded

00:35:41.560 --> 00:35:48.870
APK and stuff like that.
So when the user chooses a particular app

00:35:48.870 --> 00:35:53.750
that they want to download, the actual download
of the APK happens, and it may get stored

00:35:53.750 --> 00:35:59.820
in external storage. And lastly, it -- the
user -- when a user clicks on it, you can

00:35:59.820 --> 00:36:04.350
fire a system intent to trigger the installation
flow.

00:36:04.350 --> 00:36:13.710
Well, as you can see, this is a pretty involved
method. But over the long term, we believe

00:36:13.710 --> 00:36:20.690
that if you -- if you wanted to invest in
these kind of solutions, you could build something

00:36:20.690 --> 00:36:25.250
like this yourself, or you can purchase some
existing solutions out there in the market.

00:36:25.250 --> 00:36:33.780
And the functionality is pretty similar, actually.
Well, I wanted to close with sharing a few

00:36:33.780 --> 00:36:40.420
resources related to what we talked about
today. We are excited about Android's momentum

00:36:40.420 --> 00:36:46.380
as a team in the consumer space, obviously,
and also in the enterprise sector.

00:36:46.380 --> 00:36:50.410
In the enterprise sector, as well, we know
that we are not there yet. We have some more

00:36:50.410 --> 00:36:55.840
work to do. And our team is actually working
pretty hard to make sure we become successful

00:36:55.840 --> 00:37:00.780
in this area as well.
Lastly, for developers, we are looking forward

00:37:00.780 --> 00:37:05.630
to seeing the kinds of innovations from this
audience right here. Of the and we'll hope

00:37:05.630 --> 00:37:10.630
that you can build a pretty healthy business
and be very successful in the long run.

00:37:10.630 --> 00:37:13.700
Thank you very much.
[ Applause ]

00:37:13.700 --> 00:37:22.330
&gt;&gt;Fred Chung: So if you have any feedback,
please provide us. We'd love to hear your

00:37:22.330 --> 00:37:27.320
feedback through this URL.
And I'm going to open it up for Q&amp;A. For those

00:37:27.320 --> 00:37:35.020
of you that are watching the stream -- the
live streaming, you can use the Google Moderator

00:37:35.020 --> 00:37:39.230
for Q&amp;A.
&gt;&gt;Andy Stadler: Who is broadcasting that.

00:37:39.230 --> 00:37:48.010
&gt;&gt;Gabe Cohen: I am. I'll get it on the screen.
Just make that a little larger.

00:37:48.010 --> 00:37:50.980
Let's start in the crowd. First question up
front.

00:37:50.980 --> 00:37:57.650
&gt;&gt;&gt; Are there any plans to implement user
accounts, say, different users could log in

00:37:57.650 --> 00:38:04.630
with different passwords to a tablet, and
different applications would be enabled based

00:38:04.630 --> 00:38:07.410
on that user's profile?
&gt;&gt;Gabe Cohen: I can take that.

00:38:07.410 --> 00:38:10.240
That's something we're thinking about. I mean,
when we first started building Honeycomb and

00:38:10.240 --> 00:38:14.830
thought about the tablet use cases, like,
passing advice between users on the couch,

00:38:14.830 --> 00:38:19.870
it became apparent we might need something
like that in the future. We definitely also

00:38:19.870 --> 00:38:24.280
get a lot of questions about people, again,
in the stool use scenario having different

00:38:24.280 --> 00:38:28.090
security requirements, you know, not wanting
to impose the harder security requirements

00:38:28.090 --> 00:38:32.790
to access their personal stuff. The and then,
of course, in the worst case, what happens

00:38:32.790 --> 00:38:38.380
when they leave the company, what gets wiped.
So we're thinking about that. The but no specific

00:38:38.380 --> 00:38:39.431
plans.
&gt;&gt;&gt; Thank you.

00:38:39.431 --> 00:38:45.120
&gt;&gt;Gabe Cohen: Yeah. Maybe from the back mike.
&gt;&gt;&gt; Two questions. One is, is there any way

00:38:45.120 --> 00:38:48.800
for an application to detect that a device
is rooted?

00:38:48.800 --> 00:38:55.580
&gt;&gt;Fred Chung: I believe that there's a programmatic
way that I've seen once on stack overflow.

00:38:55.580 --> 00:38:59.339
But I don't know off the top of my head what
that approach is.

00:38:59.339 --> 00:39:08.260
&gt;&gt;&gt; You've seen some app that has managed
to do it without asking the user any questions,

00:39:08.260 --> 00:39:09.550
right, because the user will obviously say,
no, it isn't rooted, because they want access

00:39:09.550 --> 00:39:14.430
to enterprise resources, so they won't give
you access they won't give me root access

00:39:14.430 --> 00:39:19.340
to figure out whether the device is rooted
or not.

00:39:19.340 --> 00:39:23.450
In this case, the user is the enemy in some
sense, because the enterprise --

00:39:23.450 --> 00:39:26.680
&gt;&gt;Andy Stadler: I totally understand the question
you're asking. And it's an important question.

00:39:26.680 --> 00:39:31.010
I don't think any of us can answer it.
&gt;&gt;Gabe Cohen: I think that's a question best

00:39:31.010 --> 00:39:34.070
targeted at your security team, in case they
have ideas. And it may vary from device to

00:39:34.070 --> 00:39:36.420
device also.
&gt;&gt;Andy Stadler: Yeah.

00:39:36.420 --> 00:39:42.280
&gt;&gt;&gt; And the other question was, are you planning
to support certificates for active sync?

00:39:42.280 --> 00:39:45.210
&gt;&gt;Gabe Cohen: That's actually one of the questions
in the moderator queue.

00:39:45.210 --> 00:39:50.620
We've been hearing that pretty frequently
also. We've noticed that users have had a

00:39:50.620 --> 00:39:54.960
number of setup problems, because we don't
support certificate authentication in AOSP

00:39:54.960 --> 00:39:57.920
exchange today. So that's something we're
actually working on.

00:39:57.920 --> 00:40:02.910
&gt;&gt;&gt; Thank you.
&gt;&gt;&gt; So I have a question about the suggested

00:40:02.910 --> 00:40:08.630
method for using the -- what you call the
internal app.

00:40:08.630 --> 00:40:12.610
So it sounds like Google doesn't have a solution,
so you're just asking the developers that

00:40:12.610 --> 00:40:15.770
build to come up with their own distribution
mechanism.

00:40:15.770 --> 00:40:18.080
But it sounds like that's still going to require
side-loading to be enabled. And that doesn't

00:40:18.080 --> 00:40:25.870
work at all on AT&amp;T phones. And I don't know
on other carriers in other countries whether

00:40:25.870 --> 00:40:34.620
they enable side-loading or not.
So -- and in many ways, to ask people to enable

00:40:34.620 --> 00:40:40.960
side-loading kind of means less security to
them. So it seems counterintuitive that you

00:40:40.960 --> 00:40:45.100
would do it that way.
So are there any plans to incorporate some

00:40:45.100 --> 00:40:47.800
type of enterprise type of market in the future?
&gt;&gt;Fred Chung: Well, good feedback. I think

00:40:47.800 --> 00:40:52.130
we can take that back and look into that further.
&gt;&gt;Gabe Cohen: We're definitely aware of those

00:40:52.130 --> 00:40:56.600
problems. We're thinking about it. But I don't
think we have any solutions right now.

00:40:56.600 --> 00:41:02.090
&gt;&gt;&gt; Okay.
But then it will require side loading through

00:41:02.090 --> 00:41:07.330
that mechanism; right?
&gt;&gt;Fred Chung: That's going to be the mechanism.

00:41:07.330 --> 00:41:08.330
&gt;&gt;Gabe Cohen: That's correct.
&gt;&gt;Fred Chung: Yeah.

00:41:08.330 --> 00:41:09.490
&gt;&gt;&gt; Okay. Thanks.
&gt;&gt;&gt; One of the things that you didn't mention

00:41:09.490 --> 00:41:15.660
about the device admin is that once you enable
it, you're unable to uninstall the app.

00:41:15.660 --> 00:41:17.990
Can you explain what the motivation is behind
that and why it's not documented.

00:41:17.990 --> 00:41:22.860
&gt;&gt;Andy Stadler: Well, I'll answer the second
one first. Anything that's not documented

00:41:22.860 --> 00:41:28.890
is certainly not intentional. And so, you
know, we welcome your feedback on places where

00:41:28.890 --> 00:41:33.130
you're finding things missing in the documentation.
I think that's a fair statement on any API.

00:41:33.130 --> 00:41:38.870
Now, in terms of why you can't uninstall an
active administrator, the answer is quite

00:41:38.870 --> 00:41:44.290
simply because, you know, this is something
that has made assertions about the security

00:41:44.290 --> 00:41:48.220
state of your device. And to simply uninstall
it would be to drop everything.

00:41:48.220 --> 00:41:54.020
Now, the good news, however, is that you can
un- -- you can deactivate an administrator

00:41:54.020 --> 00:41:58.000
app, at which point you can uninstall it.
And when you deactivate it, that's one of

00:41:58.000 --> 00:42:04.190
those call-backs I mentioned. So, for example,
when you see that you've been deactivated,

00:42:04.190 --> 00:42:08.740
that's one of those regressions in security
I was talking about, you know. If you're protecting

00:42:08.740 --> 00:42:12.980
data, that's the time to wipe it or whatever.
&gt;&gt;&gt; Right. But there's no security preventing

00:42:12.980 --> 00:42:14.840
someone from deactivating it. So it just seems
like it's an extra check box a user has to

00:42:14.840 --> 00:42:25.990
uncheck. It doesn't actually make it impossible
to uninstall or anything like that. It's just

00:42:25.990 --> 00:42:30.240
an extra hoop you have to jump through first.
&gt;&gt;Andy Stadler: It's more than an extra hoop.

00:42:30.240 --> 00:42:36.370
It's very explicitly a notification. So the
question is really, then, one of are we going

00:42:36.370 --> 00:42:41.650
to block it forever, which I think is what
you're suggesting, or are we going to allow

00:42:41.650 --> 00:42:46.340
the users to do that change, but at least
give the apps the notifications they need.

00:42:46.340 --> 00:42:53.370
And the choice was made in the framework design
to take the latter course, which is we're

00:42:53.370 --> 00:42:56.400
going to let the users do this -- You know,
this is, again, one of these things where

00:42:56.400 --> 00:43:02.620
it's the user phone versus the corporate phone.
And the current, you know, direction is that

00:43:02.620 --> 00:43:07.290
we, you know -- the user still has the control
of their phone. So we make sure that the corporate

00:43:07.290 --> 00:43:13.290
data has an ability to detect that some changes
are happening and protect itself in whatever

00:43:13.290 --> 00:43:17.280
way is necessary. But we're not currently
going to block that change entirely.

00:43:17.280 --> 00:43:22.090
&gt;&gt;&gt; Okay. The current error message is just
uninstall failed. It's not very useful.

00:43:22.090 --> 00:43:25.530
&gt;&gt;Andy Stadler: I -- I'm not surprised.
&gt;&gt;&gt; Thank you.

00:43:25.530 --> 00:43:27.121
&gt;&gt;Andy Stadler: Very good feedback. Thank
you.

00:43:27.121 --> 00:43:32.530
&gt;&gt;Gabe Cohen: Let me take a couple of the
moderator questions we have up here.

00:43:32.530 --> 00:43:36.500
The first one I don't have a great answer
for. Are there plans to explicitly support

00:43:36.500 --> 00:43:40.650
remote control apps so enterprise I.T. can
solve problems directly on employees' phones?

00:43:40.650 --> 00:43:45.460
I think the answer is, today, I've seen some
vendors in this space actually partnering

00:43:45.460 --> 00:43:51.010
with OEMs to expose the APIs they need. For
instance, one of the, you know, APIs I've

00:43:51.010 --> 00:43:54.560
seen requested by people who do this kind
of support is, you know, I need to screen

00:43:54.560 --> 00:43:59.800
cap or actually remote control, like, super
dangerous permissions that we haven't actually

00:43:59.800 --> 00:44:04.560
figured out how we're going to expose, like,
if they would be in Market or what have you.

00:44:04.560 --> 00:44:09.430
So we're thinking about this, but I don't
have any direct solutions today. I think in

00:44:09.430 --> 00:44:14.670
some cases, a lot of our partners go to OEMs
to accomplish specifically what they need,

00:44:14.670 --> 00:44:18.990
and then if they're really bold, they try
to create standards across the OEMs.

00:44:18.990 --> 00:44:22.690
I think we still need to figure out which
are kind of the most common features we need

00:44:22.690 --> 00:44:25.700
to support remote control, and then ultimately
we would like to incorporate them into the

00:44:25.700 --> 00:44:28.360
platform.
Assuming that the user is informed that, they

00:44:28.360 --> 00:44:35.420
give consent, and it doesn't neuter sort of
the user experience.

00:44:35.420 --> 00:44:42.600
So for the second question up here, let me
jump down. Are there plans to implement a

00:44:42.600 --> 00:44:45.460
VPN provider API at the platform level so
different VPN types could be installed through

00:44:45.460 --> 00:44:48.630
the market?
This is also a case where people are solving

00:44:48.630 --> 00:44:54.730
this problem today by going to OEMs. You know,
I think Cisco has an OEM partnership to provide

00:44:54.730 --> 00:45:00.040
one of their VPN clients. There are a few
others. I know the Droid Pro package is something

00:45:00.040 --> 00:45:03.060
else.
What we'd really like to see it that any vendor

00:45:03.060 --> 00:45:08.700
has access to the users via the market. Again,
VPNs are extremely dangerous because they

00:45:08.700 --> 00:45:14.130
can basically monitor all network traffic
when they are active. So we're actually working

00:45:14.130 --> 00:45:18.370
on coming up with a solution that allows these
types of things to exist in user space, to

00:45:18.370 --> 00:45:23.420
be distributed through Market. But working
on the usability and the experience is kind

00:45:23.420 --> 00:45:26.330
of challenging for something that's so dangerous.
We need to make sure there are a lot of hoops

00:45:26.330 --> 00:45:30.843
to jump through. Not unlike a device management
agent.

00:45:30.843 --> 00:45:35.260
Back to the mic.
&gt;&gt; Is there any way to push configuration

00:45:35.260 --> 00:45:39.620
on the phone, like VPN settings, for example?
&gt;&gt;Gabe Cohen: We are definitely thinking about

00:45:39.620 --> 00:45:44.340
that in conjunction on working on improving
VPN support, but nothing specific.

00:45:44.340 --> 00:45:49.960
&gt;&gt;Andy Stadler: Aren't some of the third parties
showing some things along those lines?

00:45:49.960 --> 00:45:56.030
&gt;&gt;Gabe Cohen: I know some third parties have
gone to OEMs to get APIs or are using private

00:45:56.030 --> 00:46:00.760
APIs because they have been side loaded with
root privileges by OEMs to do remote configuration.

00:46:00.760 --> 00:46:03.740
I actually think this is one of the most important
areas that's going to be the most common across

00:46:03.740 --> 00:46:11.780
devices that we will need to tackle in the
future, but we are not quite there yet.

00:46:11.780 --> 00:46:16.110
Yeah.
&gt;&gt; Hi. If a company wanted to start using

00:46:16.110 --> 00:46:21.761
your device manager API for internal applications,
they would want to ask questions about what

00:46:21.761 --> 00:46:28.320
tools you have so we can test the application
to be sure they are actually secure.

00:46:28.320 --> 00:46:33.630
&gt;&gt;Andy Stadler: I'm sorry, what's the question?
&gt;&gt; What testing tools are available?

00:46:33.630 --> 00:46:38.690
&gt;&gt;Andy Stadler: None that I'm aware of, but
maybe you can tell me what you had in mind

00:46:38.690 --> 00:46:48.490
and we can start to look at that.
&gt;&gt; A lot of companies will have like a corporate

00:46:48.490 --> 00:46:52.590
I.T. policy that this has to go through some
kind of penetration testing.

00:46:52.590 --> 00:46:53.590
&gt;&gt;Andy Stadler: Ah, I see.
&gt;&gt;Gabe Cohen: No, I don't know that we necessarily

00:46:53.590 --> 00:46:57.770
have any vision for best practices for penetration
testing of Android apps. It might be a interesting

00:46:57.770 --> 00:47:03.420
question for security team, also. Sorry.
&gt;&gt;Fred Chung: We will be glad to get more

00:47:03.420 --> 00:47:08.620
information from you after this session.
&gt;&gt;Gabe Cohen: Next mic question.

00:47:08.620 --> 00:47:17.910
&gt;&gt; Yes. Are there any plans to add programmatic
-- the programmatic ability that certificates

00:47:17.910 --> 00:47:23.620
into the certificate store? Because currently
if a certificate has a C.A. that isn't built

00:47:23.620 --> 00:47:25.550
into the Android OS, that presents a bit of
a problem.

00:47:25.550 --> 00:47:33.500
&gt;&gt;Andy Stadler: Yeah, and so I know Gabe mentioned
earlier because we had another question about

00:47:33.500 --> 00:47:38.860
certificates, and, really, what we are, in
fact, working on is we didn't want to just

00:47:38.860 --> 00:47:46.660
jam certificates into one app. So there's
under way basically a more integrated solution

00:47:46.660 --> 00:47:50.480
for dealing with certificates and things like
you are talking about are definitely part

00:47:50.480 --> 00:47:52.690
of the work flows we are looking at.
&gt;&gt;Gabe Cohen: It's a known requirement. It's

00:47:52.690 --> 00:47:57.150
not one certificate. It's many certificates
in order to bootstrap an email client. So,

00:47:57.150 --> 00:47:58.150
yeah.
&gt;&gt; I have two questions. First one was in

00:47:58.150 --> 00:48:10.110
the first part of the demo you had some policies
apply to a specific user account. So I guess

00:48:10.110 --> 00:48:15.240
that implied that you could have different
policies for different accounts; is that correct?

00:48:15.240 --> 00:48:18.690
&gt;&gt;Andy Stadler: Yeah, I think what he was
showing was an example where the server would

00:48:18.690 --> 00:48:19.920
be tracking multiple accounts.
&gt;&gt; Right.

00:48:19.920 --> 00:48:21.630
&gt;&gt;Andy Stadler: Not the device.
&gt;&gt; Not the device.

00:48:21.630 --> 00:48:22.640
&gt;&gt;Andy Stadler: Right.
&gt;&gt; And the second one, you compared policies

00:48:22.640 --> 00:48:26.070
with permissions. It's possible to create
custom permissions. Can you do that with custom

00:48:26.070 --> 00:48:31.040
policies? Like can an application define a
custom policy?

00:48:31.040 --> 00:48:36.610
&gt;&gt;Andy Stadler: No, and the reason is because
the policies don't work, they don't really

00:48:36.610 --> 00:48:40.910
matter unless they have some teeth to them.
So a policy -- you can't just say I want to

00:48:40.910 --> 00:48:45.890
make a new policy. You have to have the REST
of the OS obeying that policy.

00:48:45.890 --> 00:48:50.480
So, really, the policies kind of come from
the bottom-up. A particular piece of the system

00:48:50.480 --> 00:48:57.970
will -- The thing I didn't describe in the
device policy manager is there's two tracks

00:48:57.970 --> 00:49:02.270
of API. There's the parts that apps would
use to assert policies and then there's the

00:49:02.270 --> 00:49:05.981
parts that the REST of the system uses to
say, well, what are the current policies?

00:49:05.981 --> 00:49:10.570
What do I need to do?
And so an app coming up with a policy won't

00:49:10.570 --> 00:49:14.500
really help unless the system is watching
for that policy.

00:49:14.500 --> 00:49:23.810
&gt;&gt; See, I am employed by a device manufacturer
so I have the ability to do the other part

00:49:23.810 --> 00:49:26.690
of it so, I don't know, how would I implement
something like I only want certain users to

00:49:26.690 --> 00:49:27.690
be able to change any settings, for example?
&gt;&gt;Andy Stadler: I see. If you are working

00:49:27.690 --> 00:49:33.440
for an device manufacturer, of course you
have the ability to add methods to APIs. That's,

00:49:33.440 --> 00:49:39.790
obviously, a capability you will have. Then
you would be talking about running apps that

00:49:39.790 --> 00:49:43.410
would only be able to talk to that so you
probably want to use a shared library to distribute

00:49:43.410 --> 00:49:46.501
for those devices.
These are the things that are fairly standard

00:49:46.501 --> 00:49:52.670
in terms of how OEMs can add functionality
to specific devices. Nothing really special

00:49:52.670 --> 00:49:55.550
here.
The main issue is, again, a policy doesn't

00:49:55.550 --> 00:50:02.390
matter unless somebody is listening to that
point of impact. And I would obviously suggest

00:50:02.390 --> 00:50:05.260
starting there.
&gt;&gt;Gabe Cohen: Thanks.

00:50:05.260 --> 00:50:10.790
Yes.
&gt;&gt; If a user enables a policy, say, on a Froyo

00:50:10.790 --> 00:50:16.490
phone, and the app declares something like
encryption which doesn't exist yet, is the

00:50:16.490 --> 00:50:21.690
policy granted when the user upgrades? And
if it's not granted, does a user have to activate

00:50:21.690 --> 00:50:30.181
again? Or if we upgrade our app to add a new
policy, do they have to walk through that

00:50:30.181 --> 00:50:31.181
whole process again?
&gt;&gt;Andy Stadler: No. In fact, that's a really

00:50:31.181 --> 00:50:36.080
great question, because you have actually
noticed one of the subtle but important distinctions,

00:50:36.080 --> 00:50:41.630
is that when we present the list of policies
to the user, we do, in fact, list them explicitly.

00:50:41.630 --> 00:50:46.900
And when they hit activate, we basically,
in the system, we copy down which policies

00:50:46.900 --> 00:50:51.390
the user accepted.
Now, in this -- So, for example, I think you

00:50:51.390 --> 00:50:55.680
hit a perfect one which is encryption. Let's
say they go through that on a Froyo device,

00:50:55.680 --> 00:51:04.700
and then that device is it upgraded to Honeycomb.
Or Ice Cream Sandwich or something. The user

00:51:04.700 --> 00:51:10.830
has only accepted the original and smaller
set of policies. And if the app was -- If

00:51:10.830 --> 00:51:15.650
the app was upgraded to request some newer
policies, like encryption, it's going to continue

00:51:15.650 --> 00:51:21.160
to run just fine until it tries to assert
the encryption policy.

00:51:21.160 --> 00:51:24.810
So it's going to be bounded within the ones
which were accepted.

00:51:24.810 --> 00:51:28.470
However, there is an API, I didn't show it
in the sample code but there is an API where

00:51:28.470 --> 00:51:34.600
you can basically look at policies on a one--by-one
basis. You only need to use this if you have

00:51:34.600 --> 00:51:38.720
upgraded that policy. And you can say, oh,
do I have this one? And if not, then, yes,

00:51:38.720 --> 00:51:43.210
you do have to loop back and have them accept
it one more time.

00:51:43.210 --> 00:51:48.450
Because it really -- I mean, you can't just
go do something based on this smaller set.

00:51:48.450 --> 00:51:51.740
You have got to show it to the user and say
I need you to give me the OK to do this.

00:51:51.740 --> 00:51:54.300
&gt;&gt; And does the user have to accept all the
policies again?

00:51:54.300 --> 00:51:58.300
&gt;&gt;Andy Stadler: Yeah, it's Al an all or nothing.
There are no check boxes or anything like

00:51:58.300 --> 00:51:59.300
that.
Yeah.

00:51:59.300 --> 00:52:02.450
&gt;&gt;Speaker4: Front mic.
&gt;&gt; I have a question. If the application is

00:52:02.450 --> 00:52:08.470
active, can it actually lower the requirements
for security? Example would be, for example,

00:52:08.470 --> 00:52:14.790
e-mail application. If you had exchange account
and admin requires it, if you remove the account

00:52:14.790 --> 00:52:19.220
it doesn't actually lower the policies.
&gt;&gt;Andy Stadler: So what happens is that -- remember,

00:52:19.220 --> 00:52:25.170
I mentioned how there's policies, and then
there's the state of the device. And they

00:52:25.170 --> 00:52:30.860
are linked but they are not 100 percent connected.
So to walk through a typical example, let's

00:52:30.860 --> 00:52:34.980
say that you add an account that requires
a password. The user enters a password. You

00:52:34.980 --> 00:52:38.720
have done all the right things. Now you have
got a device in that state.

00:52:38.720 --> 00:52:43.710
Now, if they delete that account, we do all
the right things, we delete the data that's

00:52:43.710 --> 00:52:49.561
associated with that account, we're going
to release those policy assertions. But we're

00:52:49.561 --> 00:52:51.760
not going to actively change their password
on them.

00:52:51.760 --> 00:52:57.320
So now the device is in a state where it has
a secure setting, such as a password or a

00:52:57.320 --> 00:53:02.450
short screen lock or whatever, might still
be encrypted. But if the user happens to go

00:53:02.450 --> 00:53:07.530
back to the settings for that setting, for
that device state, they will see that they

00:53:07.530 --> 00:53:10.360
have regained the ability to reduce the security
on their own.

00:53:10.360 --> 00:53:12.280
At this point it doesn't matter because we
no longer have the accounts in place.

00:53:12.280 --> 00:53:19.020
&gt;&gt; OK. I was testing it on tablet and actually
after removing account it didn't allow me

00:53:19.020 --> 00:53:24.880
to remove the PIN. So I guess --
&gt;&gt;Andy Stadler: It's either a bug or there

00:53:24.880 --> 00:53:28.330
was some other source of policies.
So like, for example, I know when I have been

00:53:28.330 --> 00:53:33.400
working with policy code -- and by the way,
I should have mentioned this. In the standard

00:53:33.400 --> 00:53:38.080
API demos, which is our sort of sample app,
we have a whole page where you can manually

00:53:38.080 --> 00:53:43.410
set and control policies. And sometimes I
will use that when I am exploring policy issue,

00:53:43.410 --> 00:53:48.630
and sometimes I will forget that I left a
policy asserted in API demos, and then my

00:53:48.630 --> 00:53:52.290
other app doesn't work right. It might not
be what happened to you, but most commonly,

00:53:52.290 --> 00:53:58.520
that's the case unless there's a bug. Most
commonly it's that somebody else is setting

00:53:58.520 --> 00:54:03.110
that policy.
&gt;&gt; This is just a built in mail application.

00:54:03.110 --> 00:54:07.480
And the second question was talking corporate,
any support for -- support for proxy?

00:54:07.480 --> 00:54:13.730
&gt;&gt;Gabe Cohen: Yeah. We implemented it in 3.1,
although I haven't seen that information publicized

00:54:13.730 --> 00:54:18.510
anywhere, and I am hoping that it actually
made it into the release. I think it did.

00:54:18.510 --> 00:54:21.930
So I believe it's there in 3.1, basic proxy
support, although we don't support auto configuration

00:54:21.930 --> 00:54:27.690
or authenticated proxy, so it's not done.
And actually it's a little more nuanced than

00:54:27.690 --> 00:54:32.600
that because Android apps can use different
network stacks. That proxy is applying to

00:54:32.600 --> 00:54:36.230
browser and stacks that use I believe the
Java networking stack.

00:54:36.230 --> 00:54:39.010
&gt;&gt;Andy Stadler: Don't look at me. I don't
know.

00:54:39.010 --> 00:54:42.530
&gt;&gt;Gabe Cohen: I'm like, Andy, come on.
But not necessarily everything. It's fob to

00:54:42.530 --> 00:54:46.190
bypass that, use lower level networking. Then
you don't actually integrate with that proxy

00:54:46.190 --> 00:54:50.391
support. So we are still thinking about how
to complete that. There's actually a question

00:54:50.391 --> 00:54:53.600
in moderator here about that that I was going
to talk to.

00:54:53.600 --> 00:54:57.560
We also need to think about how to manage
proxy support but that's fairly dangerous

00:54:57.560 --> 00:55:02.280
in terms of application control of system
proxy because, again, that allows monitoring

00:55:02.280 --> 00:55:05.640
of all network traffic.
&gt;&gt; Is it then implemented per connection or

00:55:05.640 --> 00:55:08.410
systemwide?
&gt;&gt;Gabe Cohen: It's per Wi-Fi network access

00:55:08.410 --> 00:55:09.861
point.
&gt;&gt; Thank you.

00:55:09.861 --> 00:55:13.570
&gt;&gt;Gabe Cohen: Yeah.
Back mic.

00:55:13.570 --> 00:55:20.540
&gt;&gt; Quick question. Is there any plan to implement
the way that the applications are pushed from

00:55:20.540 --> 00:55:25.461
the Web site, the Android Market Web site,
from something that will be agreed upon? You

00:55:25.461 --> 00:55:33.470
know, I am thinking about Google Apps for
domain, for business. Once the policies agree

00:55:33.470 --> 00:55:39.170
to the device, the admin push directly apps
to the devices that he has the right for.

00:55:39.170 --> 00:55:45.200
&gt;&gt;Gabe Cohen: That's something we've actually
talked about. It seems like that would be

00:55:45.200 --> 00:55:50.370
useful as a feature, although we haven't actually
come to agreement on how and if we should

00:55:50.370 --> 00:55:57.520
expose something like that. Again, security
considerations in mind. But it's something

00:55:57.520 --> 00:56:00.470
we are thinking about.
&gt;&gt; Okay. Obviously it has to be secure, but

00:56:00.470 --> 00:56:08.390
once it's for the device that are linked to
Google Apps for business domain, there's already

00:56:08.390 --> 00:56:13.790
a lot of policies that you can wipe directly
from the (inaudible). I was thinking from

00:56:13.790 --> 00:56:20.380
this part of the domain, push from here.
&gt;&gt;Andy Stadler: One thing I want to just mention

00:56:20.380 --> 00:56:23.500
is every time Gabe says we are thinking about
something --

00:56:23.500 --> 00:56:26.780
&gt;&gt; It's done already?
&gt;&gt;Andy Stadler: -- he really means it. His

00:56:26.780 --> 00:56:33.950
job is to maintain a very long list of priorities.
&gt;&gt;Gabe Cohen: And I sit in a cubicle and I

00:56:33.950 --> 00:56:37.040
think about them.
&gt;&gt;Andy Stadler: And future requests that believe

00:56:37.040 --> 00:56:41.160
me we know all of you have been asking for.
And it's one of Gabe's responsibilities is

00:56:41.160 --> 00:56:44.790
keeping track of that.
So when he says we're thinking about it, we

00:56:44.790 --> 00:56:49.560
really have had many discussions about it,
I want to let you know.

00:56:49.560 --> 00:56:52.480
&gt;&gt;Gabe Cohen: I mean, that particular idea
could be a really great end-user experience,

00:56:52.480 --> 00:57:02.260
so it is a good idea.
&gt;&gt; As a user during the week I may have a

00:57:02.260 --> 00:57:05.720
bunch of applications that have very high
security demands, but on the weekends I may

00:57:05.720 --> 00:57:07.450
want to not use these applications and have
lower security requirements, like not having

00:57:07.450 --> 00:57:10.390
to put in a password every time the lock screen
comes in.

00:57:10.390 --> 00:57:14.800
Now, at the moment I can set that up on Friday
night, I can remove these applications, remove

00:57:14.800 --> 00:57:18.960
the security and reset it up on Monday morning.
&gt;&gt;Gabe Cohen: You can factory reset every

00:57:18.960 --> 00:57:23.180
week, too.
&gt;&gt; Sure. Would like a "go secure" mode or

00:57:23.180 --> 00:57:26.540
a per-application model be more appropriate
for that kind of user?

00:57:26.540 --> 00:57:31.430
&gt;&gt;Gabe Cohen: So there's a few interesting
things we're seeing in the marketplace. Actually,

00:57:31.430 --> 00:57:35.400
if you drop by the enterprise booth they are
doing something kind of interesting today

00:57:35.400 --> 00:57:40.710
to address this sort of dual profile scenario.
It kind of gets to the earlier question we

00:57:40.710 --> 00:57:45.440
got about profiles, too.
So, yeah, don't really have a great answer

00:57:45.440 --> 00:57:53.000
for this today, but I think it's a real requirement.
Yeah, I mean, we've struggled with this when

00:57:53.000 --> 00:57:58.880
we're enacting one policy for Google users
on Android devices, what kind of pass code

00:57:58.880 --> 00:58:04.410
requirement, and the interaction between our
multifactor authentication, or device pass

00:58:04.410 --> 00:58:09.320
codes. You want to work with the I.T. admin
to come up with the minimum acceptable security

00:58:09.320 --> 00:58:13.740
requirements because users see this for everything.
&gt;&gt;Andy Stadler: It drives them crazy.

00:58:13.740 --> 00:58:17.930
&gt;&gt;Gabe Cohen: And it drives them insane, you
want to make sure you sort of minimize the

00:58:17.930 --> 00:58:20.620
impact while maintaining whatever your minimum
security requirements are.

00:58:20.620 --> 00:58:25.140
Most people don't really -- we have this great
conversation about the entropy differences

00:58:25.140 --> 00:58:30.350
in terms of security between certain length
pattern and certain length PINs, and if you

00:58:30.350 --> 00:58:34.210
think really carefully about what your real
security requirements are, potentially you

00:58:34.210 --> 00:58:38.000
can lower that so it's not quite as painful.
&gt;&gt; You will never have agreement with the

00:58:38.000 --> 00:58:44.770
security I.T. guy and the guy on the weekend.
Your own data showed that most people weren't

00:58:44.770 --> 00:58:46.390
locking their screens.
Thanks, guys.

00:58:46.390 --> 00:58:50.520
&gt;&gt;Gabe Cohen: So I think we need to wrap up.
Let me see if we addressed some of the other

00:58:50.520 --> 00:58:55.730
moderator questions that are here.
I think we talked about the need for unknown

00:58:55.730 --> 00:58:57.891
sources. We addressed that. I talked about
proxy.

00:58:57.891 --> 00:59:05.340
We talked about VPN specifically, and to this
question of, you know, device manufacturers

00:59:05.340 --> 00:59:10.630
basically extending enterprise support, we
think this is a really great thing because

00:59:10.630 --> 00:59:15.070
people want to use Android for work now. And
if they really want to do that, they can buy

00:59:15.070 --> 00:59:20.670
a device that meets those needs from a manufacturer
that meets those capabilities.

00:59:20.670 --> 00:59:24.990
I feel my personal responsibility is to look
at what the OEMs are doing to find the things

00:59:24.990 --> 00:59:28.950
that are going to be the most common, and
make sure those are baked into the platform

00:59:28.950 --> 00:59:35.290
because we don't want an app developer who
is talking to device management to have five

00:59:35.290 --> 00:59:39.510
different APIs they have to deal with for
the leading OEMs to control something like

00:59:39.510 --> 00:59:42.480
device encryption.
So we're trying to introduce standards over

00:59:42.480 --> 00:59:49.880
time. Like we introduced encryption in Honeycomb,
as people were start to go at it on top of

00:59:49.880 --> 00:59:52.080
Froyo.
&gt;&gt;Andy Stadler: And Honeycomb encryption is

00:59:52.080 --> 00:59:56.170
a good example, actually, because we knew
how to encrypt the device but we also knew

00:59:56.170 --> 01:00:02.000
that a lot of other OEMs were also working
on encrypting devices. And so, really -- and

01:00:02.000 --> 01:00:05.500
it's funny, we get questions like how many
bits is the encryption and really the answer

01:00:05.500 --> 01:00:08.870
is it just needs to be really secure and you
all know what that means. But the important

01:00:08.870 --> 01:00:13.850
thing for us is is there an API for it. Do
we have an API and does that API really clearly

01:00:13.850 --> 01:00:19.950
describe we are going to encrypt at least
this much of the data on the phone, and, therefore,

01:00:19.950 --> 01:00:25.310
any OEM can wire up their encryption system
to that? That's important, because that's

01:00:25.310 --> 01:00:30.431
what reduces fragmentation, not putting down
a bunch of mandates about you must have this

01:00:30.431 --> 01:00:35.640
many bits or, you know, blah, blah, blah.
&gt;&gt;Gabe Cohen: Yeah. So we plan to control

01:00:35.640 --> 01:00:41.441
these things basically through AOSP APIs.
&gt;&gt;Andy Stadler: And we're out of time.

01:00:41.441 --> 01:00:42.859
&gt;&gt;Gabe Cohen: Thanks.

