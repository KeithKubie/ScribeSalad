WEBVTT
Kind: captions
Language: en

00:00:01.067 --> 00:00:03.334
Veme: So this talk is aimed
at a 2.01 level.

00:00:03.334 --> 00:00:05.200
That means we're expecting

00:00:05.200 --> 00:00:07.234
that you've got some experience
with App Engine,

00:00:07.234 --> 00:00:09.400
you've probably
written some code

00:00:09.400 --> 00:00:12.367
and that you probably
also have written some code

00:00:12.367 --> 00:00:14.467
using the task view system.

00:00:14.467 --> 00:00:15.634
If you haven't,
that's okay.

00:00:15.634 --> 00:00:17.100
You should be able
to keep up

00:00:17.100 --> 00:00:18.801
with what I'm
going to say today,

00:00:18.801 --> 00:00:22.334
get the gist
of what's going on.

00:00:22.334 --> 00:00:27.834
So let's just go back
and look at App Engine history.

00:00:27.834 --> 00:00:29.067
So App Engine
is a great system

00:00:29.067 --> 00:00:30.701
for writing
your web apps.

00:00:30.701 --> 00:00:34.167
You can manage them,
scale them automatically.

00:00:34.167 --> 00:00:35.300
You can write them
very easily,

00:00:35.300 --> 00:00:38.033
you go straight
out of the box,

00:00:38.033 --> 00:00:40.734
start up for free
if you like.

00:00:40.734 --> 00:00:42.434
One of the limitations
that we have

00:00:42.434 --> 00:00:47.467
is that user face requests
are limited to 30 seconds.

00:00:47.467 --> 00:00:49.000
So the task key
was initially introduced

00:00:49.000 --> 00:00:53.300
as a method of overcoming
some of this limitation

00:00:53.300 --> 00:00:57.033
and also offloading
some of the work

00:00:57.033 --> 00:00:59.334
that users really shouldn't
have to wait for,

00:00:59.334 --> 00:01:04.167
so things like data start
updates or URL protocols,

00:01:04.167 --> 00:01:08.868
things that just do some
cleanup tasks in the background.

00:01:08.868 --> 00:01:12.701
So here's a mental model
for you of what a task queue is,

00:01:12.701 --> 00:01:14.501
how we'd like you
to view it.

00:01:14.501 --> 00:01:18.767
The tasks here are indicated
as the colored boxes

00:01:18.767 --> 00:01:22.200
and the queue here is sorted
in order of increasing ETA.

00:01:22.200 --> 00:01:24.601
That's the earliest time
at which we'll attempt

00:01:24.601 --> 00:01:27.133
to push the task
to your application.

00:01:27.133 --> 00:01:30.667
So I'm showing you here
a model for pushing tasks.

00:01:30.667 --> 00:01:33.067
So tasks here,
HTTP requests,

00:01:33.067 --> 00:01:34.501
you can see
on the right hand side,

00:01:34.501 --> 00:01:36.634
there's an instance
of your app

00:01:36.634 --> 00:01:38.334
that's adding a task
to the queue

00:01:38.334 --> 00:01:42.167
and that blue box is going
somewhere in the back there.

00:01:42.167 --> 00:01:44.968
And you can also see
that the task queue service

00:01:44.968 --> 00:01:46.767
is taking some tasks
from the queue,

00:01:46.767 --> 00:01:48.133
and pushing those tasks out

00:01:48.133 --> 00:01:51.300
to other instances of your app
for execution.

00:01:51.300 --> 00:01:52.701
So this is
the push model.

00:01:52.701 --> 00:01:56.367
You have control
over how many tasks

00:01:56.367 --> 00:01:57.901
can be running
concurrently.

00:01:57.901 --> 00:02:00.734
You have control over the rate
at which they're executed,

00:02:00.734 --> 00:02:06.334
and the task queue service
handles everything else for you.

00:02:06.334 --> 00:02:10.601
So the way that you define
these queues is quite simple.

00:02:10.601 --> 00:02:12.167
You've got queue.yaml

00:02:12.167 --> 00:02:14.701
or if you're using Java,
queue.xml,

00:02:14.701 --> 00:02:17.100
in which you can specify
the name and the rate

00:02:17.100 --> 00:02:21.567
and other parameters
like the retry parameters.

00:02:21.567 --> 00:02:25.667
The tasks are gonna be added
to the queue using an API,

00:02:25.667 --> 00:02:27.434
call it taskqueue.add,

00:02:27.434 --> 00:02:31.434
very simple one
for both Python and Java.

00:02:31.434 --> 00:02:33.200
You can see
that in the Python case,

00:02:33.200 --> 00:02:38.801
you refer just
to a URL equals foo,

00:02:38.801 --> 00:02:42.167
use a bit more type information
in Java.

00:02:42.167 --> 00:02:45.400
The task queue system
will push those tasks,

00:02:45.400 --> 00:02:49.534
those URLs to your app
at the rate that you specified

00:02:49.534 --> 00:02:53.000
and the instances
are scaled at the,

00:02:53.000 --> 00:02:56.200
just automatically
by App Engine itself.

00:02:56.200 --> 00:02:58.634
So any failed task
that is any task

00:02:58.634 --> 00:03:01.634
that has a return code
not in the 200 range

00:03:01.634 --> 00:03:03.434
is automatically retried,

00:03:03.434 --> 00:03:06.167
and you also can exert
some control

00:03:06.167 --> 00:03:09.334
over how those retries
are managed,

00:03:09.334 --> 00:03:12.868
what the back offs are,
how the back offs should grow,

00:03:12.868 --> 00:03:14.834
what number of retries
are allowed

00:03:14.834 --> 00:03:19.033
before the task
would fail permanently.

00:03:19.033 --> 00:03:20.267
So here's another bit
of history.

00:03:20.267 --> 00:03:22.534
This is the way
that our product has grown

00:03:22.534 --> 00:03:24.100
in the last couple of years.

00:03:24.100 --> 00:03:26.801
So you can see that
after the App Engine launch,

00:03:26.801 --> 00:03:30.000
it was a gap of about a year,
and then we were able to launch

00:03:30.000 --> 00:03:32.868
task queues as a labs feature,
it was called at the time,

00:03:32.868 --> 00:03:34.934
that's experimental.

00:03:34.934 --> 00:03:38.467
And Java support was added
a quarter after that,

00:03:38.467 --> 00:03:40.734
but initially,
we had limitations,

00:03:40.734 --> 00:03:45.534
maximum QPS was initially 20 QPS
across all of your apps.

00:03:45.534 --> 00:03:51.133
That was relaxed later
to maximum of 50 QPS per app,

00:03:51.133 --> 00:03:55.767
and then maximum
of 50 QPS per queue.

00:03:55.767 --> 00:03:57.334
So at that time,
you could have ten queues.

00:03:57.334 --> 00:03:59.934
That was a big increase.

00:03:59.934 --> 00:04:02.501
Finally, we were out of labs
at the end of last year

00:04:02.501 --> 00:04:05.834
and we had maximum
task running length

00:04:05.834 --> 00:04:10.501
increased from the standard
30 seconds up to 10 minutes.

00:04:10.501 --> 00:04:14.100
Then we were increasing
our QPS per queue to 100.

00:04:14.100 --> 00:04:17.234
That's the maximum allowed,
and today, we'd like to tell you

00:04:17.234 --> 00:04:22.701
that you're allowed
500 QPS per queue.

00:04:22.701 --> 00:04:26.267
So today, we really want
to focus your attention

00:04:26.267 --> 00:04:29.701
on the first really large
new feature

00:04:29.701 --> 00:04:30.734
in the task queue system.

00:04:30.734 --> 00:04:32.801
And this is a new model
for the queues.

00:04:32.801 --> 00:04:37.467
It's called pull queues.

00:04:37.467 --> 00:04:39.934
So these are new,
as I repeated.

00:04:39.934 --> 00:04:41.067
They have been mentioned

00:04:41.067 --> 00:04:42.434
in a couple of the other talks
already.

00:04:42.434 --> 00:04:44.767
For example, if you were here
for the backends talk,

00:04:44.767 --> 00:04:46.434
you might have heard them
mentioned.

00:04:46.434 --> 00:04:49.334
So here's the basics.

00:04:49.334 --> 00:04:54.367
Push queues, the tasks
are actually HTTP requests.

00:04:54.367 --> 00:04:56.434
In pull queues,
tasks are just data.

00:04:56.434 --> 00:04:59.834
So the meaning of that data
is completely up to you

00:04:59.834 --> 00:05:02.133
as the programmer
who creates the tasks

00:05:02.133 --> 00:05:06.901
and will also be doing some work
in response to the tasks.

00:05:06.901 --> 00:05:09.334
So workers are leasing
tasks from the queue.

00:05:09.334 --> 00:05:12.467
That's in contrast
to the push model

00:05:12.467 --> 00:05:16.367
in which the task queue system
just calls

00:05:16.367 --> 00:05:19.767
those HTTP requests
on your application.

00:05:19.767 --> 00:05:22.467
So instead of the task queue
system,

00:05:22.467 --> 00:05:26.067
deleting tasks
because an HTTP request

00:05:26.067 --> 00:05:29.434
returned a return code
in the 200 range,

00:05:29.434 --> 00:05:31.434
it's up to a worker
in a pull queue

00:05:31.434 --> 00:05:35.267
to delete the task
manually.

00:05:35.267 --> 00:05:38.033
And scaling is also
your responsibility

00:05:38.033 --> 00:05:39.667
when you're using
the pull model.

00:05:39.667 --> 00:05:44.801
So in the case of push queues,
the App Engine itself

00:05:44.801 --> 00:05:46.901
was going to scale
the number of instances for you

00:05:46.901 --> 00:05:48.434
depending on load.

00:05:48.434 --> 00:05:51.100
In this particular case
of pull queues, it's up to you

00:05:51.100 --> 00:05:56.334
to configure the number of
workers that you need.

00:05:56.334 --> 00:05:59.467
So I said
that workers lease tasks

00:05:59.467 --> 00:06:01.567
and there's a reason for that,

00:06:01.567 --> 00:06:03.567
and that's that a worker
might crash

00:06:03.567 --> 00:06:05.267
while it's working
on a task.

00:06:05.267 --> 00:06:07.634
And it would be a bad thing
if the task was lost

00:06:07.634 --> 00:06:10.367
and no one else was able
to complete the work.

00:06:10.367 --> 00:06:16.133
So you, if you crash,
the lease will expire

00:06:16.133 --> 00:06:18.801
and at some time after that,
another worker will be able

00:06:18.801 --> 00:06:21.767
to lease the task
and complete the work.

00:06:21.767 --> 00:06:25.767
But, if the task is actually
the cause of the crash,

00:06:25.767 --> 00:06:28.968
and will be causing crashes
indefinitely,

00:06:28.968 --> 00:06:30.934
you can actually limit that.

00:06:30.934 --> 00:06:32.968
You can say no more
than this many tries

00:06:32.968 --> 00:06:34.400
at leasing the task

00:06:34.400 --> 00:06:36.834
before the task is considered
to have failed permanently.

00:06:36.834 --> 00:06:41.467
That prevents
infinite crash loops.

00:06:41.467 --> 00:06:43.901
So let's just take a quick look
at the API.

00:06:43.901 --> 00:06:47.167
First I'll cover Python
and then I'll cover Java.

00:06:47.167 --> 00:06:50.100
But I'd also like to
give a plug to Go.

00:06:50.100 --> 00:06:51.667
Although I don't have
a slide on it,

00:06:51.667 --> 00:06:54.934
we have an implementation
in Go.

00:06:54.934 --> 00:07:00.234
So in Python, the big change
is that a queue in queue.yaml

00:07:00.234 --> 00:07:05.167
that you specify now
can be specified with mode pull.

00:07:05.167 --> 00:07:06.234
If you don't specify mode
at all,

00:07:06.234 --> 00:07:07.567
it defaults to push.

00:07:07.567 --> 00:07:12.934
So pull and push are the two
valid values for mode.

00:07:12.934 --> 00:07:15.968
When you're adding tasks
to tell the system

00:07:15.968 --> 00:07:19.701
that you're actually adding
one of these data-only tasks,

00:07:19.701 --> 00:07:22.234
you say,
method equals pull.

00:07:22.234 --> 00:07:25.400
So here you can see,
you know, task add,

00:07:25.400 --> 00:07:28.167
payload equals hello,
method equals pull.

00:07:28.167 --> 00:07:29.534
Now, leasing tasks,

00:07:29.534 --> 00:07:33.167
we return a list of task objects
back to you.

00:07:33.167 --> 00:07:35.501
You can lease
more than one at once.

00:07:35.501 --> 00:07:38.567
So here we're just trying
to lease three tasks

00:07:38.567 --> 00:07:39.968
for 30 seconds.

00:07:39.968 --> 00:07:42.901
The first parameter there
is the length of the lease.

00:07:42.901 --> 00:07:45.501
And finally,
with that list of tasks,

00:07:45.501 --> 00:07:47.801
you can use that also
as the argument to delete tasks

00:07:47.801 --> 00:07:50.334
once you've finished
doing your work.

00:07:50.334 --> 00:07:53.100
So q.delete tasks.

00:07:53.100 --> 00:07:56.834
And in Java, things
are very, very similar.

00:07:56.834 --> 00:07:58.067
There's just
a few more things

00:07:58.067 --> 00:07:59.968
that are a bit more idiomatic
for Java there.

00:07:59.968 --> 00:08:04.400
So here we use our builder
patent for task options

00:08:04.400 --> 00:08:07.234
to add a task,
and we use an object

00:08:07.234 --> 00:08:10.400
that specifies
that this is a pull task.

00:08:10.400 --> 00:08:13.067
Leasing tasks returns
a list of tasks handled.

00:08:13.067 --> 00:08:16.567
Task handles are a slightly
different abstraction in Java

00:08:16.567 --> 00:08:20.300
that represent tasks
in storage vs. task options

00:08:20.300 --> 00:08:22.868
which represent the tasks
before they have actually

00:08:22.868 --> 00:08:25.200
been created in storage.

00:08:25.200 --> 00:08:27.534
And we see lease tasks
again.

00:08:27.534 --> 00:08:32.300
This time, we can specify
using the time unit.

00:08:32.300 --> 00:08:36.267
And finally, deleting tasks
is done in a loop,

00:08:36.267 --> 00:08:40.634
but a very simple loop,
as you can see there.

00:08:40.634 --> 00:08:42.300
So I want to give you
a mental picture

00:08:42.300 --> 00:08:45.868
of what's happening
as you are leasing tasks

00:08:45.868 --> 00:08:49.734
so that you can see
that in this particular case,

00:08:49.734 --> 00:08:51.868
time is going to be flowing.

00:08:51.868 --> 00:08:55.167
The tasks are always
in the queue until deleted.

00:08:55.167 --> 00:08:59.067
So I'm indicating again tasks
as the colored boxes.

00:08:59.067 --> 00:09:02.868
And I'm also indicating
with that now pointer

00:09:02.868 --> 00:09:05.467
that the,
that's the current time.

00:09:05.467 --> 00:09:07.534
And then everything
to the left of that pointer

00:09:07.534 --> 00:09:09.133
is available for lease.

00:09:09.133 --> 00:09:11.167
Everything to the right
of that pointer

00:09:11.167 --> 00:09:13.567
is considered
already under lease

00:09:13.567 --> 00:09:15.767
and therefore,
you can't lease those.

00:09:15.767 --> 00:09:18.734
So here is a worker
attempting to lease three tasks

00:09:18.734 --> 00:09:20.868
for 30 seconds.

00:09:20.868 --> 00:09:21.934
We can see highlighted there

00:09:21.934 --> 00:09:24.834
the three tasks
that are available.

00:09:24.834 --> 00:09:26.801
So in this slide,

00:09:26.801 --> 00:09:29.701
we see them having been
delivered to the worker,

00:09:29.701 --> 00:09:32.667
but also moved past
the now pointer

00:09:32.667 --> 00:09:34.634
into the leased section
of the queue

00:09:34.634 --> 00:09:38.067
and they actually moved
to a point that's 30 seconds

00:09:38.067 --> 00:09:41.634
beyond the now pointer
as it exists.

00:09:41.634 --> 00:09:44.767
So we see the three tasks
come down.

00:09:44.767 --> 00:09:47.734
Now the worker is going
to work on those tasks,

00:09:47.734 --> 00:09:52.133
is gonna do whatever work
was encoded in them,

00:09:52.133 --> 00:09:53.767
presumably
the same programmer

00:09:53.767 --> 00:09:56.334
wrote the code
for inserting the tasks

00:09:56.334 --> 00:09:58.234
as is writing the code
for the worker.

00:09:58.234 --> 00:10:02.634
So the interpretation
is very much up to you.

00:10:02.634 --> 00:10:05.868
So now it's up to the worker
to delete the tasks,

00:10:05.868 --> 00:10:09.067
so uses those three
colored rectangles

00:10:09.067 --> 00:10:10.367
and we see them gone.

00:10:10.367 --> 00:10:12.434
But you also see that the
now pointer has moved on

00:10:12.434 --> 00:10:18.367
and the next leased tasks will
possibly return three as well.

00:10:20.267 --> 00:10:23.534
So I'd like to give you
a demonstration here

00:10:23.534 --> 00:10:28.634
of pull queues in action.
So this is one of the models

00:10:28.634 --> 00:10:31.634
that is pretty good
for pull queues.

00:10:31.634 --> 00:10:35.033
And this is when your tasks
are considered to be

00:10:35.033 --> 00:10:39.100
very small items of work
rather than large items of work.

00:10:39.100 --> 00:10:42.133
And we want to lease
multiple of them at once

00:10:42.133 --> 00:10:43.534
so that we can batch
the work together

00:10:43.534 --> 00:10:48.133
and gain some efficiencies
on datastore and other APIs.

00:10:48.133 --> 00:10:51.701
So in this particular case,
the tasks are votes.

00:10:51.701 --> 00:10:53.501
And we're going to be
tallying the votes

00:10:53.501 --> 00:10:57.067
and storing them periodically
back to datastore.

00:10:57.067 --> 00:11:00.567
But we don't want to be doing
a datastore operation per vote

00:11:00.567 --> 00:11:04.801
because that may well use up
all of quota very quickly.

00:11:04.801 --> 00:11:10.801
So we're going to reduce
by accumulating votes first.

00:11:10.801 --> 00:11:16.801
So let me just move across
to voter later.

00:11:16.801 --> 00:11:19.667
And this is something that
all of us have opinions on.

00:11:19.667 --> 00:11:21.067
It's all very tongue and cheek,

00:11:21.067 --> 00:11:24.701
so I don't hate any
of these languages, actually.

00:11:24.701 --> 00:11:30.267
So selecting one of them
is considered a vote.

00:11:32.000 --> 00:11:35.834
And you'll notice that the tally
hasn't updated immediately,

00:11:35.834 --> 00:11:41.834
however, if I refresh
the task queue,

00:11:41.834 --> 00:11:43.801
I can see that some of you

00:11:43.801 --> 00:11:45.968
have already been
putting votes in as well.

00:11:45.968 --> 00:11:50.300
And these are the votes
currently in the queue.

00:11:50.300 --> 00:11:52.033
Now, if I do another refresh,

00:11:52.033 --> 00:11:54.701
we should see the tallies
changing.

00:11:54.701 --> 00:11:58.067
There's somebody here who's
decided to add a vote for Java

00:11:58.067 --> 00:12:00.100
and another one in
for Perl.

00:12:00.100 --> 00:12:01.934
And you can vote as often
as you'd like.

00:12:01.934 --> 00:12:07.934
So this one may decide
just to curl in a loop.

00:12:07.934 --> 00:12:13.100
No, it can't collect.
That's all right.

00:12:13.100 --> 00:12:19.033
Right, so let's just move on--
to some of the code.

00:12:20.934 --> 00:12:23.367
So firstly, we have
our boiler plate, appl.yaml.

00:12:23.367 --> 00:12:25.067
Everything happens
in main.py.

00:12:25.067 --> 00:12:26.968
It's a very simple
application.

00:12:26.968 --> 00:12:30.834
And queue.yaml,
you can see defines a queue

00:12:30.834 --> 00:12:36.200
and it's called votes
and it's in pull mode.

00:12:36.200 --> 00:12:39.300
And our handler
is at the root level

00:12:39.300 --> 00:12:40.767
is just the vote handler.

00:12:40.767 --> 00:12:42.300
That's where on the post,

00:12:42.300 --> 00:12:44.834
you can register a vote
on the get.

00:12:44.834 --> 00:12:47.767
You just simply display
the form for voting

00:12:47.767 --> 00:12:50.100
and the current tallies.

00:12:50.100 --> 00:12:51.434
There's a tally handler as well,

00:12:51.434 --> 00:12:54.667
and that's called
only by the tasks.

00:12:54.667 --> 00:12:58.434
Sorry, it's called from cron,
but it's not meant for users.

00:12:58.434 --> 00:13:01.567
This is the one that actually
is going to do the work

00:13:01.567 --> 00:13:06.501
of pulling the votes from
the queue and updating tallies.

00:13:08.434 --> 00:13:10.100
So just a quick look
at vote handler.

00:13:10.100 --> 00:13:12.467
You can see there
in the post method,

00:13:12.467 --> 00:13:18.000
that I'm adding the tasks
to the queue with method pull.

00:13:18.000 --> 00:13:19.267
Now, the workers,

00:13:19.267 --> 00:13:21.601
well, we've got lots of choices
for workers now.

00:13:21.601 --> 00:13:24.601
Just in the previous talk,
you heard about backends.

00:13:24.601 --> 00:13:26.200
Backends could be workers.

00:13:26.200 --> 00:13:29.033
Also, cron tasks
can be workers.

00:13:29.033 --> 00:13:32.801
Also, long running tasks in
a push queue would be workers.

00:13:32.801 --> 00:13:34.501
It's really up to you.

00:13:34.501 --> 00:13:37.000
So in this case,
for this example,

00:13:37.000 --> 00:13:39.367
we're gonna
specify it in cron.

00:13:39.367 --> 00:13:44.067
So you see there, every minute,
the tally handler runs.

00:13:44.067 --> 00:13:46.300
So the data model
is pretty simple.

00:13:46.300 --> 00:13:48.434
It's just account,

00:13:48.434 --> 00:13:51.033
the key name is
going to be the language name.

00:13:51.033 --> 00:13:54.067
And there's
a convenience method there

00:13:54.067 --> 00:13:58.868
that actually
will update the count.

00:13:58.868 --> 00:14:01.400
Storing, we do
that convenience method

00:14:01.400 --> 00:14:05.567
in a transaction.

00:14:05.567 --> 00:14:07.267
And finally, the bit
that you've been waiting for,

00:14:07.267 --> 00:14:11.334
which is the loop in which we
are going to be leasing tasks,

00:14:11.334 --> 00:14:13.934
doing our work,
and then deleting them.

00:14:13.934 --> 00:14:16.767
So it's as simple
as you could imagine.

00:14:16.767 --> 00:14:19.000
First, we get hold
of the queue.

00:14:19.000 --> 00:14:24.334
Then, in a while, true loop,
we just say, lease tasks,

00:14:24.334 --> 00:14:25.934
try to get 1,000 of them
at once.

00:14:25.934 --> 00:14:27.834
A 1,000 is the maximum
that we're allowed

00:14:27.834 --> 00:14:29.267
and we'll lease them
for five minutes.

00:14:29.267 --> 00:14:31.601
If there's any kind of failure,
five minutes from now,

00:14:31.601 --> 00:14:35.300
those should be available
for another worker to lease.

00:14:35.300 --> 00:14:38.234
So if you didn't get anything,
you might as well just return,

00:14:38.234 --> 00:14:41.601
and the next indication
of this handler, via cron,

00:14:41.601 --> 00:14:45.133
will pick up anything
that's arrived.

00:14:45.133 --> 00:14:49.167
And as you see there,
we're gonna add them into a map

00:14:49.167 --> 00:14:53.601
and then use that store tallies
function to go through the map

00:14:53.601 --> 00:14:55.300
and do the datastore updates.

00:14:55.300 --> 00:14:57.133
Finally, delete the tasks.

00:14:57.133 --> 00:14:59.834
So a failure
at any point in this,

00:14:59.834 --> 00:15:03.868
is going to result in
either a retry,

00:15:03.868 --> 00:15:05.267
if you were using
long running tasks

00:15:05.267 --> 00:15:06.934
or the next indication
of cron,

00:15:06.934 --> 00:15:11.200
picking up any of the tasks
that were actually lost

00:15:11.200 --> 00:15:16.334
or could have been lost.

00:15:16.334 --> 00:15:19.667
So the main advantages
to an approach like this

00:15:19.667 --> 00:15:23.000
is to really limit your load
on datastore.

00:15:23.000 --> 00:15:25.067
So if we were doing
one transaction per vote,

00:15:25.067 --> 00:15:26.467
potentially
we could be doing

00:15:26.467 --> 00:15:28.968
a 1,000 times
datastore operations

00:15:28.968 --> 00:15:34.434
as we're doing now
in this approach.

00:15:34.434 --> 00:15:37.000
And with that,
I'd like to hand over to Vivek

00:15:37.000 --> 00:15:41.000
who is gonna tell you
all about how workers can run

00:15:41.000 --> 00:15:44.701
outside of
Google App Engine.

00:15:44.701 --> 00:15:46.133
Sahasranaman:
Can we switch?

00:15:46.133 --> 00:15:49.067
Veme: Yes.

00:15:58.200 --> 00:16:00.567
Sahasranaman:
So we're gonna talk

00:16:00.567 --> 00:16:02.701
about something
slightly different,

00:16:02.701 --> 00:16:06.033
and it's probably
like the first API

00:16:06.033 --> 00:16:08.968
that really exists
on App Engine

00:16:08.968 --> 00:16:11.167
that allows App Engine to be
accessed from outside.

00:16:11.167 --> 00:16:13.267
And we think
that for task queues,

00:16:13.267 --> 00:16:16.400
it's a very common use case
that there are things

00:16:16.400 --> 00:16:18.000
you want to do that,
you know,

00:16:18.000 --> 00:16:19.334
currently may not be
doable on App Engine,

00:16:19.334 --> 00:16:22.667
or it might be easier for you
to do them outside.

00:16:22.667 --> 00:16:25.868
You know, all image processing
is a good example.

00:16:25.868 --> 00:16:29.434
You've got some image
processing stuff in--

00:16:38.000 --> 00:16:41.167
So image processing
is an example.

00:16:41.167 --> 00:16:42.601
OCR is another example.

00:16:42.601 --> 00:16:44.434
For all of these things,
you probably have binaries

00:16:44.434 --> 00:16:46.067
that you downloaded
from the Internet

00:16:46.067 --> 00:16:48.367
and things that you can't run
easily in App Engine.

00:16:48.367 --> 00:16:51.934
So what we provide
for these things is an API

00:16:51.934 --> 00:16:55.801
that you can access
the pull queue or REST.

00:16:55.801 --> 00:16:57.667
And this allows you
to run your workers

00:16:57.667 --> 00:16:58.734
anywhere on the Internet.

00:16:58.734 --> 00:17:00.067
So they can be on VMs.

00:17:00.067 --> 00:17:02.067
They can be
on hosted machines.

00:17:02.067 --> 00:17:04.167
They can be,
you know, anywhere.

00:17:04.167 --> 00:17:08.234
And it allows, given that
these workers can run anywhere,

00:17:08.234 --> 00:17:09.667
they can actually run
custom binaries,

00:17:09.667 --> 00:17:13.634
they can run
image processing packages.

00:17:13.634 --> 00:17:15.200
So for people who aren't
familiar with REST,

00:17:15.200 --> 00:17:18.868
REST stands for
Representational State Transfer,

00:17:18.868 --> 00:17:21.534
and it's a very common model

00:17:21.534 --> 00:17:23.734
that a lot of Google APIs
are moving towards.

00:17:23.734 --> 00:17:25.801
If people were here
at the Google storage

00:17:25.801 --> 00:17:27.400
for the developer's talk
in the morning,

00:17:27.400 --> 00:17:30.167
they also have REST API.

00:17:30.167 --> 00:17:33.467
And REST basically models,

00:17:33.467 --> 00:17:35.334
has a model for
collection resources,

00:17:35.334 --> 00:17:37.067
and for the task queues,

00:17:37.067 --> 00:17:41.734
we have basically a queue
and tasks as our collections.

00:17:41.734 --> 00:17:46.934
And we allow workers
to lease and delete tasks

00:17:46.934 --> 00:17:48.868
using the REST API.

00:17:48.868 --> 00:17:51.534
And we still expect
that most of the insert calls

00:17:51.534 --> 00:17:54.634
and the thing that actually
feeds into the queue

00:17:54.634 --> 00:17:58.434
is happening from
inside App Engine.

00:17:58.434 --> 00:18:01.501
It's, the first question
you would ask

00:18:01.501 --> 00:18:04.667
when an API is made aware
of any of these things is,

00:18:04.667 --> 00:18:05.901
how do you authenticate?

00:18:05.901 --> 00:18:07.267
So how do you make sure that,
you know,

00:18:07.267 --> 00:18:09.534
only legal guys can actually
call this API?

00:18:09.534 --> 00:18:11.667
And the way we set that up is

00:18:11.667 --> 00:18:14.834
that you can actually
specify an ACL.

00:18:14.834 --> 00:18:17.467
And we'll see an example
of how that is set up.

00:18:17.467 --> 00:18:19.767
You can specify in ACL
in queue.yaml

00:18:19.767 --> 00:18:21.767
while you're uploading
an App Engine app.

00:18:21.767 --> 00:18:25.334
And the API then makes sure
that only the guys

00:18:25.334 --> 00:18:28.567
who are specified in the ACL
can actually access the API.

00:18:28.567 --> 00:18:29.767
It uses OAuth,

00:18:29.767 --> 00:18:34.534
which is a standard
authentication mechanism

00:18:34.534 --> 00:18:36.133
which kind of avoids,
you know,

00:18:36.133 --> 00:18:40.467
say keeping your passwords
in to do authentication,

00:18:40.467 --> 00:18:44.133
that a lot of Google APIs
are also moving towards.

00:18:44.133 --> 00:18:48.767
And we will see examples
of how this works.

00:18:48.767 --> 00:18:50.934
So to get started with this,

00:18:50.934 --> 00:18:53.868
there's an extra bit that you
need to specify in queue.yaml

00:18:53.868 --> 00:18:56.334
or queue.xml
if you're doing Java.

00:18:56.334 --> 00:18:57.868
It's called ACL.

00:18:57.868 --> 00:19:00.400
And we'll see
a very specific example,

00:19:00.400 --> 00:19:05.467
but basically you specify
just user app domain,

00:19:05.467 --> 00:19:07.634
a list of those,
and all of those guys

00:19:07.634 --> 00:19:12.434
are then authorized
to access your task queues.

00:19:12.434 --> 00:19:17.033
And then you access the
REST API which is at that URL.

00:19:17.033 --> 00:19:22.133
And Google is
moving to REST in a big way,

00:19:22.133 --> 00:19:24.000
and a lot of APIs
are available,

00:19:24.000 --> 00:19:27.400
and there's an open source
API client library

00:19:27.400 --> 00:19:30.033
that you can use
to talk to these APIs.

00:19:30.033 --> 00:19:32.501
And we've built a couple
of samples on top of these

00:19:32.501 --> 00:19:35.901
that are available open source
from that link,

00:19:35.901 --> 00:19:38.501
which are also at the end
of the slides.

00:19:38.501 --> 00:19:39.868
And specifically,
there are two of them.

00:19:39.868 --> 00:19:42.934
There's one which lets you
run a single command

00:19:42.934 --> 00:19:45.300
against your queue,

00:19:45.300 --> 00:19:47.267
just to make sure
that everything is working.

00:19:47.267 --> 00:19:50.300
There's another one which kind
of runs in an infinite loop,

00:19:50.300 --> 00:19:52.367
continuously pulls tasks
from your queue,

00:19:52.367 --> 00:19:56.367
executes an arbitrary binary
for each of your tasks,

00:19:56.367 --> 00:19:57.934
and then deletes the task.

00:19:57.934 --> 00:20:00.534
This, we think, is another
very common pattern

00:20:00.534 --> 00:20:04.334
that a lot of people
will want to use

00:20:04.334 --> 00:20:06.767
when they're using
pull queues.

00:20:06.767 --> 00:20:08.400
And both of these examples
are available.

00:20:08.400 --> 00:20:10.634
We'll also use these examples
in the demos

00:20:10.634 --> 00:20:13.501
that we're going to do.

00:20:13.501 --> 00:20:16.634
So the first example I have
is probably the simplest example

00:20:16.634 --> 00:20:18.033
that you can build,

00:20:18.033 --> 00:20:20.501
and something that you can't do
in App Engine today,

00:20:20.501 --> 00:20:23.734
which is very simple image
modification.

00:20:23.734 --> 00:20:27.000
So App Engine has very
simple image API,

00:20:27.000 --> 00:20:30.334
which lets you do small degrees
of transformation,

00:20:30.334 --> 00:20:33.033
but we'll try to do something
that's just a little bit beyond

00:20:33.033 --> 00:20:34.868
what App Engine can do today.

00:20:34.868 --> 00:20:37.300
And the model is very simple.

00:20:37.300 --> 00:20:40.567
The task
that we will create

00:20:40.567 --> 00:20:43.267
will contain a single photo
in the payload

00:20:43.267 --> 00:20:45.567
which will be uploaded
from an App Engine app.

00:20:45.567 --> 00:20:48.100
And then workers running in VM
will actually execute

00:20:48.100 --> 00:20:50.334
an image processing binary
on these tasks

00:20:50.334 --> 00:20:53.467
and put it back
into App Engine.

00:20:53.467 --> 00:20:56.000
I'll show you
the demo first.

00:20:56.000 --> 00:21:02.000
And then come back to
how this thing is built.

00:21:02.000 --> 00:21:05.934
So--

00:21:12.701 --> 00:21:17.834
I'll pick an image--

00:21:17.834 --> 00:21:21.901
and upload it.

00:21:21.901 --> 00:21:27.434
What I also have
is a machine.

00:21:27.434 --> 00:21:29.067
This is just
a standard machine.

00:21:29.067 --> 00:21:31.534
It doesn't really matter
where this machine is running.

00:21:31.534 --> 00:21:32.767
And on this machine,

00:21:32.767 --> 00:21:34.734
I'm gonna basically
be running something

00:21:34.734 --> 00:21:37.367
that can access
the API or REST.

00:21:37.367 --> 00:21:43.300
So in this case, I'll run
this thing called the puller

00:21:45.400 --> 00:21:48.634
which will continuously
access the queue

00:21:48.634 --> 00:21:52.334
and will actually
execute the binary,

00:21:52.334 --> 00:21:56.300
convert minus annotate
on the payload

00:21:56.300 --> 00:21:59.133
and push it back
into App Engine.

00:21:59.133 --> 00:22:02.501
And we will notice
that there's a processed image

00:22:02.501 --> 00:22:04.033
that's come back.

00:22:04.033 --> 00:22:10.033
So to kind of go into
a little bit more detail

00:22:10.033 --> 00:22:12.934
into how this app
is constructed,

00:22:12.934 --> 00:22:15.801
I'll kind of just lay it out
pictorially first for everyone.

00:22:15.801 --> 00:22:18.033
So there's basically
an App Engine app,

00:22:18.033 --> 00:22:19.167
and there's a worker
machine pull

00:22:19.167 --> 00:22:20.367
which is outside
App Engine

00:22:20.367 --> 00:22:23.701
that's trying to access
the pull queues.

00:22:23.701 --> 00:22:26.701
So what happens is you first
insert your image in

00:22:26.701 --> 00:22:28.234
as a user request handler,

00:22:28.234 --> 00:22:31.534
that then writes the image
in a datastore

00:22:31.534 --> 00:22:34.601
and then also queues up task
into the pull queue

00:22:34.601 --> 00:22:39.367
which also contains this image
as the payload.

00:22:39.367 --> 00:22:40.667
You've got a worker
machine pull

00:22:40.667 --> 00:22:42.601
which is continuously
pulling this pull queue

00:22:42.601 --> 00:22:46.267
and it will eventually notice
that there's a task available.

00:22:46.267 --> 00:22:48.634
It'll lease this task
over the REST API,

00:22:48.634 --> 00:22:53.267
execute its custom work,
whatever it needs to do.

00:22:53.267 --> 00:22:55.767
In this particular case,
I've chosen to use

00:22:55.767 --> 00:22:58.100
OAuth authenticated upload

00:22:58.100 --> 00:23:02.734
to return the converted image
back into App Engine.

00:23:02.734 --> 00:23:05.968
And there's a handler
that exists inside App Engine

00:23:05.968 --> 00:23:09.133
that eventually writes it
back into datastore.

00:23:09.133 --> 00:23:10.467
The OAuth authenticated upload

00:23:10.467 --> 00:23:13.467
ensures that only
authenticated users

00:23:13.467 --> 00:23:19.367
can actually access
the worker upload handle.

00:23:19.367 --> 00:23:22.767
So the App Engine
side of things

00:23:22.767 --> 00:23:25.868
looks very similar
to Nick's demo.

00:23:25.868 --> 00:23:27.501
So I'm gonna kind of
skip over that part

00:23:27.501 --> 00:23:30.267
and I'm gonna focus more
on how to set up the thing

00:23:30.267 --> 00:23:32.167
that's outside App Engine.

00:23:32.167 --> 00:23:33.434
So as mentioned before,

00:23:33.434 --> 00:23:36.267
there's this ACL bit
that you need to set.

00:23:36.267 --> 00:23:38.400
In this particular case,
I've chosen me and Nick

00:23:38.400 --> 00:23:41.367
as the consumers
of this queue.

00:23:41.367 --> 00:23:44.901
And we just specify those,

00:23:44.901 --> 00:23:46.667
and then you write
an App Engine.

00:23:46.667 --> 00:23:48.567
You write your App Engine code
to insert stuff

00:23:48.567 --> 00:23:53.133
into the queue as before.

00:23:53.133 --> 00:23:56.868
And then, you have to write
some code on the other side

00:23:56.868 --> 00:23:58.501
to actually pull it
out of this queue.

00:23:58.501 --> 00:23:59.868
As I mentioned before,

00:23:59.868 --> 00:24:04.501
there's the API client library
which lets you

00:24:04.501 --> 00:24:08.367
access all APIs
that are available over REST

00:24:08.367 --> 00:24:10.467
in a very systematic way.

00:24:10.467 --> 00:24:11.901
And this is available
in many languages.

00:24:11.901 --> 00:24:13.968
It's available in
Python and Java.

00:24:13.968 --> 00:24:16.634
In this specific example,
we choose Python, and in Python

00:24:16.634 --> 00:24:22.567
because of the ability of Python
to generate code on a fly.

00:24:23.968 --> 00:24:26.701
The API client can actually
call a URL,

00:24:26.701 --> 00:24:29.767
get a description
of what the API looks like,

00:24:29.767 --> 00:24:32.133
and generate
an object for you

00:24:32.133 --> 00:24:35.267
on which you can
make a function call,

00:24:35.267 --> 00:24:38.801
which eventually translates into
an API call on the interface.

00:24:38.801 --> 00:24:44.801
So the way we do this
is import a build library

00:24:44.801 --> 00:24:46.901
that's available
from API client

00:24:46.901 --> 00:24:50.701
and give it the API
that we want to build.

00:24:50.701 --> 00:24:54.200
And this will give us an object
which we can then use

00:24:54.200 --> 00:24:55.634
to make an API call.

00:24:55.634 --> 00:25:01.467
And it will just look like
a function call in Python.

00:25:01.467 --> 00:25:04.834
The next thing
we want to try out

00:25:04.834 --> 00:25:08.567
is to make sure
that this whole thing works.

00:25:08.567 --> 00:25:10.000
And here,
I get an opportunity

00:25:10.000 --> 00:25:14.234
to demonstrate
how the OAuth system works,

00:25:14.234 --> 00:25:16.834
and how the thing that
I'm running outside App Engine

00:25:16.834 --> 00:25:19.901
is actually figuring out,

00:25:19.901 --> 00:25:22.033
is actually getting
a token from you,

00:25:22.033 --> 00:25:23.934
and using that token
to authenticate you

00:25:23.934 --> 00:25:28.601
back into the API.

00:25:28.601 --> 00:25:32.234
So I will kill this...

00:25:40.100 --> 00:25:42.100
and run this utility

00:25:42.100 --> 00:25:47.100
which basically is trying to
lease one task from the queue.

00:25:47.100 --> 00:25:50.234
If you notice, the first thing
that it does

00:25:50.234 --> 00:25:56.033
is that it actually asks you to
go to this URL and authorize.

00:25:56.033 --> 00:26:02.033
So what this is trying to do
is it's doing standard OAuth

00:26:03.801 --> 00:26:07.701
and asking
for authorization for--

00:26:07.701 --> 00:26:11.200
it's saying that there's
this command line utility,

00:26:11.200 --> 00:26:13.467
Google API client by
task queue command line,

00:26:13.467 --> 00:26:17.467
which is trying to access
an API on behalf of you

00:26:17.467 --> 00:26:19.367
and you need to
grant access.

00:26:19.367 --> 00:26:24.167
So if you do this, it will
give you a verification token

00:26:24.167 --> 00:26:30.167
which I paste back
into my command line

00:26:30.167 --> 00:26:32.701
and then I notice
that the API call goes through.

00:26:32.701 --> 00:26:35.534
And just for simplicity,
this app is written

00:26:35.534 --> 00:26:38.634
so that it actually caches
the token in a file

00:26:38.634 --> 00:26:40.834
so you don't have to do this
over and over again

00:26:40.834 --> 00:26:43.367
which is why my puller was
actually working without the--

00:26:43.367 --> 00:26:47.534
without this step in my previous
iteration of the demo.

00:26:56.334 --> 00:26:58.400
And then finally,
to the worker code,

00:26:58.400 --> 00:27:00.968
so once you've got
authentication working,

00:27:00.968 --> 00:27:03.734
what you need to do is
you need to take this object

00:27:03.734 --> 00:27:06.000
that you created using
the API client libraries

00:27:06.000 --> 00:27:08.467
that I described
two slides ago,

00:27:08.467 --> 00:27:12.000
and just make an API call on it
and as I promised,

00:27:12.000 --> 00:27:13.767
the API call looks
like a function call.

00:27:13.767 --> 00:27:17.367
So, like, every verb
that you expose over the API

00:27:17.367 --> 00:27:19.000
translates into
a function call in Python

00:27:19.000 --> 00:27:20.534
and it looks quite nice.

00:27:20.534 --> 00:27:23.167
It's like all you have to do
is you get a request which says

00:27:23.167 --> 00:27:27.400
it's task API.lease
and you give it a few arguments

00:27:27.400 --> 00:27:30.133
and just execute
this request.

00:27:30.133 --> 00:27:33.501
This results
in a REST API call

00:27:33.501 --> 00:27:36.767
with an OAuth token
happening to the backend.

00:27:36.767 --> 00:27:39.267
And a response comes back

00:27:39.267 --> 00:27:42.467
which is [indistinct]
representation of a task,

00:27:42.467 --> 00:27:44.000
or of a series of tasks
in this case,

00:27:44.000 --> 00:27:46.901
because lease can actually
give you more than one task.

00:27:46.901 --> 00:27:50.934
And then, like, for people
who are familiar with Python,

00:27:50.934 --> 00:27:53.801
all you do is you just
iterate away your tasks.

00:27:53.801 --> 00:27:56.200
For each of your tasks,
I chose to execute

00:27:56.200 --> 00:27:59.934
convert minus annotate
and post the output

00:27:59.934 --> 00:28:04.834
back into my app,
and then eventually delete.

00:28:04.834 --> 00:28:09.000
So things work out
very nicely in Python.

00:28:09.000 --> 00:28:10.767
In Java, it's a little bit
more complicated

00:28:10.767 --> 00:28:11.801
because you can't,

00:28:11.801 --> 00:28:16.200
because Java deflection
only works at--

00:28:16.200 --> 00:28:18.667
you can't do this code
generation kind of phase

00:28:18.667 --> 00:28:22.067
in Java, so you have to
actually compile the,

00:28:22.067 --> 00:28:25.567
your library
into your binary

00:28:25.567 --> 00:28:31.567
rather than doing it all
at one time.

00:28:31.567 --> 00:28:37.534
We will also see another example
which is slightly different.

00:28:37.534 --> 00:28:43.067
So another you know,
very, like the second question

00:28:43.067 --> 00:28:45.634
after OAuth that people
would ask about in API is,

00:28:45.634 --> 00:28:47.934
how much can I pull
from this API?

00:28:47.934 --> 00:28:49.868
The current answer to that
is about 100K.

00:28:49.868 --> 00:28:50.968
So like you can actually,

00:28:50.968 --> 00:28:52.734
you can have tasks
of a size of 100K

00:28:52.734 --> 00:28:55.634
and you can pull
a maximum 100K out.

00:28:55.634 --> 00:28:57.267
So the next question would be,

00:28:57.267 --> 00:28:59.234
how do I do something bigger
than that?

00:28:59.234 --> 00:29:02.934
So the standard
computer science answer to that

00:29:02.934 --> 00:29:04.567
is to use a level
of indirection.

00:29:04.567 --> 00:29:07.868
So what we will do is we will
actually use another app here

00:29:07.868 --> 00:29:09.434
which actually
demonstrates that.

00:29:09.434 --> 00:29:15.334
And you can use this,
you use several storage systems

00:29:15.334 --> 00:29:17.634
to kind of do this level
of indirection.

00:29:17.634 --> 00:29:18.834
In this particular case,

00:29:18.834 --> 00:29:20.300
we choose to use Google
storage for developers,

00:29:20.300 --> 00:29:23.834
which is also kind of talked
about in the morning today.

00:29:23.834 --> 00:29:25.801
And it's an authenticated
system which,

00:29:25.801 --> 00:29:28.167
where you can store either
an authenticated token

00:29:28.167 --> 00:29:30.467
or use a predefined secret
that is shared

00:29:30.467 --> 00:29:32.934
between Google storage
and yourself

00:29:32.934 --> 00:29:34.334
to kind of authenticate.

00:29:34.334 --> 00:29:39.400
And what we've done is
that we have the same token

00:29:39.400 --> 00:29:41.701
stored between
inside App Engine

00:29:41.701 --> 00:29:43.634
and between workers
that's outside App Engine,

00:29:43.634 --> 00:29:48.801
so both these guys can basically
access the same buckets.

00:29:48.801 --> 00:29:54.300
And just for fun, we've--
what we're trying to do here

00:29:54.300 --> 00:29:58.334
is photo-stitching, which is
kind of now become commodity

00:29:58.334 --> 00:30:02.067
and kind of work on phones
but just to make it

00:30:02.067 --> 00:30:07.000
a little bit more fun,
I also chose some examples.

00:30:09.000 --> 00:30:12.534
These are images that are taken
from the Street View project.

00:30:12.534 --> 00:30:18.467
And what we will do is
we will ask the worker here

00:30:19.801 --> 00:30:23.434
to stitch
a few images for us.

00:30:29.467 --> 00:30:33.367
So like before,
I run a binary on my worker

00:30:33.367 --> 00:30:37.634
which has now noticed that
there's a task in the queue

00:30:37.634 --> 00:30:40.334
and got busy with it,

00:30:40.334 --> 00:30:45.267
and will eventually finish
stitching these images.

00:30:47.133 --> 00:30:53.067
This application also
is built a little bit--

00:30:53.067 --> 00:30:57.501
continues to show you what the
app in the background is doing.

00:31:11.334 --> 00:31:13.300
And if you notice
what it's doing is

00:31:13.300 --> 00:31:15.434
it's actually writing
all output to bigstore

00:31:15.434 --> 00:31:19.300
or to Google storage
for developers,

00:31:19.300 --> 00:31:24.234
and both the App Engine app
and the worker outside

00:31:24.234 --> 00:31:26.234
are able to access it.

00:31:26.234 --> 00:31:29.901
And here's potentially
an interesting place

00:31:29.901 --> 00:31:34.367
that a lot of people here
would probably know about.

00:31:34.367 --> 00:31:37.701
It's kind of close to here.

00:31:37.701 --> 00:31:40.534
And just for fun,
I'll do another one,

00:31:40.534 --> 00:31:44.367
which is a little
more complicated.

00:31:44.367 --> 00:31:50.300
I might stretch you guys
a little bit more.

00:31:53.734 --> 00:31:56.734
And you notice
the worker pulls up,

00:31:56.734 --> 00:32:01.834
pulls it up again
and starts off,

00:32:01.834 --> 00:32:07.000
and once this--

00:32:07.000 --> 00:32:08.133
And once this one finishes,

00:32:08.133 --> 00:32:10.367
I'll give people
an opportunity to guess

00:32:10.367 --> 00:32:16.367
where these images were taken.

00:32:16.367 --> 00:32:22.300
I suppose you can only guess
once the stitching is done.

00:32:30.934 --> 00:32:35.667
Okay.

00:32:35.667 --> 00:32:40.234
And here we go.
Any ideas?

00:32:46.367 --> 00:32:47.634
The guys who have
seen this demo before

00:32:47.634 --> 00:32:50.901
are not allowed to answer,
and for the other guys,

00:32:50.901 --> 00:32:55.367
there's a very small hint

00:32:55.367 --> 00:33:01.367
of a very iconic monument.

00:33:03.467 --> 00:33:08.534
Try again.

00:33:08.534 --> 00:33:10.567
Someone said Sydney.
This is actually a view

00:33:10.567 --> 00:33:13.567
from very close to
the Google Sydney office.

00:33:13.567 --> 00:33:16.767
If you notice,
that's the Sydney Harbor Bridge

00:33:16.767 --> 00:33:19.934
that you can see.

00:33:19.934 --> 00:33:21.667
And this is an image
that was taken from

00:33:21.667 --> 00:33:27.534
the Google Street View project
very close to the Google office.

00:33:30.968 --> 00:33:34.000
So coming back to this app,
just to kind of show

00:33:34.000 --> 00:33:37.133
this app pictorially again,
basically,

00:33:37.133 --> 00:33:38.968
it's very similar
to the previous app

00:33:38.968 --> 00:33:42.133
except that it uses
external storage system,

00:33:42.133 --> 00:33:43.434
and uses a shared secret

00:33:43.434 --> 00:33:45.434
between App Engine
and the worker pool

00:33:45.434 --> 00:33:47.834
to access the storage
authenticated.

00:33:47.834 --> 00:33:49.000
And in this case,

00:33:49.000 --> 00:33:50.701
we happen to use Google storage
for developers.

00:33:50.701 --> 00:33:52.534
You could use
lots of others.

00:33:52.534 --> 00:33:56.200
There are several other similar
storage utilities available.

00:33:59.734 --> 00:34:04.467
So to kind of recap,
there's basically a few things

00:34:04.467 --> 00:34:08.400
that you need to worry about
when you use pull queues,

00:34:08.400 --> 00:34:09.667
especially for users
of push queues

00:34:09.667 --> 00:34:13.334
who are kind of used to
a degree of convenience.

00:34:13.334 --> 00:34:15.167
There's,
scaling is a problem

00:34:15.167 --> 00:34:18.868
that you need to worry about
yourself, the pull queues.

00:34:18.868 --> 00:34:21.801
The benefit that it gives you is
that you can run these outside

00:34:21.801 --> 00:34:24.467
and as well as
you can do things like

00:34:24.467 --> 00:34:25.701
you can reduce
load of datastore,

00:34:25.701 --> 00:34:28.868
and so on and so forth,
like Nick demonstrated.

00:34:28.868 --> 00:34:31.734
But the number of workers
that you run is your problem.

00:34:31.734 --> 00:34:35.100
There's no way that the queue
is a passive entity

00:34:35.100 --> 00:34:37.467
in this case,
and it will,

00:34:37.467 --> 00:34:40.067
and you have to figure out
how many workers to run.

00:34:40.067 --> 00:34:42.901
There's an operation
on the REST API

00:34:42.901 --> 00:34:45.601
in case you're workers
outside App Engine

00:34:45.601 --> 00:34:47.200
which gives you statistics

00:34:47.200 --> 00:34:49.133
on the number of tasks
in the queue,

00:34:49.133 --> 00:34:51.234
so how many tasks
are there in the queue,

00:34:51.234 --> 00:34:53.701
and how many have been
executed in the last hour,

00:34:53.701 --> 00:34:55.167
and so on and so forth.

00:34:55.167 --> 00:34:57.367
And that can potentially
give you some hints about,

00:34:57.367 --> 00:34:58.901
you know, how many workers
you should be running.

00:34:58.901 --> 00:35:00.901
If your queue
is backing up,

00:35:00.901 --> 00:35:02.734
you will start seeing
that count rise

00:35:02.734 --> 00:35:04.234
and maybe that will
give you a hint

00:35:04.234 --> 00:35:05.734
that you should be
running more workers.

00:35:05.734 --> 00:35:08.901
If your queue size
is at zero for a long time,

00:35:08.901 --> 00:35:12.234
then maybe you should,
you know, get some workers down.

00:35:12.234 --> 00:35:15.367
The second thing to talk about
is about choosing a lease.

00:35:15.367 --> 00:35:21.300
So as Nick discussed,
if your tasks overrun the lease,

00:35:22.501 --> 00:35:24.934
they're available
for leasing again

00:35:24.934 --> 00:35:27.367
which means that another worker
will be able to pull them

00:35:27.367 --> 00:35:28.701
and execute them,

00:35:28.701 --> 00:35:30.634
which means that you will get
a lot of, you know,

00:35:30.634 --> 00:35:32.901
duplication of work happening

00:35:32.901 --> 00:35:35.033
if you choose a lease
that is too short.

00:35:35.033 --> 00:35:39.968
So to start with, we suggest
that people should choose

00:35:41.868 --> 00:35:44.167
close to the worst possible time
a worker can take.

00:35:44.167 --> 00:35:46.634
So in that case,
you kind of reduce

00:35:46.634 --> 00:35:49.100
the amount of
duplication of work.

00:35:49.100 --> 00:35:50.901
At the cost of
a little bit of overhead

00:35:50.901 --> 00:35:54.400
if your worker crashes,
but that should be okay

00:35:54.400 --> 00:35:59.467
because you're probably doing
offline processing here anyway.

00:35:59.467 --> 00:36:00.701
Another thing to think about

00:36:00.701 --> 00:36:03.000
is about what your worker
is really doing.

00:36:03.000 --> 00:36:05.567
Even with choosing
a very conservative lease,

00:36:05.567 --> 00:36:07.234
it's possible
that sometimes your workers

00:36:07.234 --> 00:36:09.801
might overrun the lease.

00:36:09.801 --> 00:36:12.534
In that case, the same task
will get done more than once.

00:36:12.534 --> 00:36:14.400
Although this, you know,
depending on how

00:36:14.400 --> 00:36:15.868
you've got your things set up,

00:36:15.868 --> 00:36:18.734
it might be relatively rare
or not.

00:36:18.734 --> 00:36:22.400
But you know, we suggest
thinking about, you know,

00:36:22.400 --> 00:36:24.767
whether you want your tasks
to be idempotent.

00:36:24.767 --> 00:36:26.567
So like, if they execute
more than once,

00:36:26.567 --> 00:36:30.868
they don't produce effects that,
you know, you don't,

00:36:30.868 --> 00:36:33.234
you can't handle
in your application.

00:36:33.234 --> 00:36:35.767
It would be,
if a repeat of a task

00:36:35.767 --> 00:36:38.334
was to produce
exactly the same effect,

00:36:38.334 --> 00:36:40.534
then you would be
basically ensured

00:36:40.534 --> 00:36:44.634
against a task
executing more than once.

00:36:44.634 --> 00:36:48.434
And finally, posting back
to App Engine from workers.

00:36:48.434 --> 00:36:51.300
On the getting the task
out of App Engine side,

00:36:51.300 --> 00:36:52.067
the REST API helps you.

00:36:52.067 --> 00:36:53.334
It's authenticated.

00:36:53.334 --> 00:36:55.634
On posting data back
to App Engine from workers,

00:36:55.634 --> 00:36:57.501
you need to worry
about OAuth yourself,

00:36:57.501 --> 00:37:00.701
and we saw two examples
of how that could be done.

00:37:00.701 --> 00:37:04.300
App Engine inherently supports
OAuth on all its handlers.

00:37:04.300 --> 00:37:08.334
So you can actually use
authenticated uploads

00:37:08.334 --> 00:37:11.434
into App Engine, which is what
we did in our first example.

00:37:11.434 --> 00:37:15.234
And you can also use
like an external storage

00:37:15.234 --> 00:37:18.467
kind of system that--
and with a shared secret

00:37:18.467 --> 00:37:24.300
to kind of protect
data transfer.

00:37:25.634 --> 00:37:26.634
And that's it.

00:37:26.634 --> 00:37:28.067
So we've got a bunch of links

00:37:28.067 --> 00:37:31.067
and a lot of this code
is already available.

00:37:31.067 --> 00:37:34.601
We've got both the samples
that we used in the demos

00:37:34.601 --> 00:37:39.100
are actually up on the
App Engine's sample's code site.

00:37:39.100 --> 00:37:42.601
And the rest API samples
are also available for you

00:37:42.601 --> 00:37:45.701
to pull and use.

00:37:45.701 --> 00:37:47.400
And there's documentation.

00:37:47.400 --> 00:37:49.901
One of the things
I'd like to show people

00:37:49.901 --> 00:37:52.901
is this thing called
the API explorer

00:37:52.901 --> 00:37:57.300
which came out from the API team
which also kind of indicates

00:37:57.300 --> 00:38:02.133
how you can use
like a description of the API

00:38:02.133 --> 00:38:04.467
to actually kind of render
and actually run an API

00:38:04.467 --> 00:38:05.801
from a browser.

00:38:05.801 --> 00:38:08.901
So in this case,
the task API,

00:38:08.901 --> 00:38:11.167
it's doing all this
by actually querying

00:38:11.167 --> 00:38:13.100
what the API looks like,

00:38:13.100 --> 00:38:14.767
and getting a description
of the API

00:38:14.767 --> 00:38:16.734
and it knows exactly
how to make the call.

00:38:16.734 --> 00:38:18.400
So, like, for example,
for the task API,

00:38:18.400 --> 00:38:20.367
there are all these calls
that exist.

00:38:20.367 --> 00:38:24.601
And in this case, if I choose
to do the lease call,

00:38:24.601 --> 00:38:27.501
it knows that these are
the four parameters to fill.

00:38:27.501 --> 00:38:30.934
In most of the calls
that we have on our API,

00:38:30.934 --> 00:38:33.300
are authenticated calls,
so they're not public calls,

00:38:33.300 --> 00:38:34.801
so it allows you to go
into this mode

00:38:34.801 --> 00:38:40.734
which allows you to do private
access which did not work.

00:38:45.200 --> 00:38:48.868
Oh, okay, well, actually,
okay, it did work.

00:38:48.868 --> 00:38:50.834
So it--
and it automatically knows

00:38:50.834 --> 00:38:54.267
that there's a scope
on this API

00:38:54.267 --> 00:38:55.467
which is a task queue scope,

00:38:55.467 --> 00:38:57.434
so the only thing you can do
on this API call

00:38:57.434 --> 00:39:00.467
is access a task queue.

00:39:00.467 --> 00:39:06.467
And now I can fill up
arguments very similar to--

00:39:12.200 --> 00:39:16.033
and try to lease one task
out of that queue for 30 seconds

00:39:16.033 --> 00:39:18.300
and you will actually see
a request go through

00:39:18.300 --> 00:39:19.968
and response come back.

00:39:19.968 --> 00:39:22.267
In this case,
my queue has no items.

00:39:22.267 --> 00:39:25.234
So the lease returns nothing
but it's kind of like

00:39:25.234 --> 00:39:26.701
a fun way of, you know,

00:39:26.701 --> 00:39:29.334
actually trying out an API
from a browser

00:39:29.334 --> 00:39:34.534
and figuring out
whether things work.

00:39:39.133 --> 00:39:43.601
Questions?

00:39:43.601 --> 00:39:46.534
Please come over
to the microphones

00:39:46.534 --> 00:39:47.834
to ask your questions,

00:39:47.834 --> 00:39:52.868
so that they can get recorded
on the video.

00:39:52.868 --> 00:39:55.834
man: How many task queues
can I have now?

00:39:55.834 --> 00:39:57.801
Veme:
You're allowed up to 100

00:39:57.801 --> 00:40:01.033
if you have enabled billing
on your app.

00:40:01.033 --> 00:40:03.801
Otherwise,
you can have 10.

00:40:03.801 --> 00:40:05.667
man:
The other is, are tasks--

00:40:05.667 --> 00:40:09.534
when App Engine
goes in maintenance mode,

00:40:09.534 --> 00:40:11.701
are task queues
still available?

00:40:11.701 --> 00:40:16.267
Veme: Yes,
they should be available.

00:40:17.868 --> 00:40:19.901
man: I think you mentioned
the word "reduce,"

00:40:19.901 --> 00:40:21.501
I think you said it was with
a small "r,"

00:40:21.501 --> 00:40:22.701
not a capital "r."

00:40:22.701 --> 00:40:23.801
Veme: Yes.

00:40:23.801 --> 00:40:24.801
man: You've gone
through 41 slides

00:40:24.801 --> 00:40:26.534
without mentioning
MapReduce.

00:40:26.534 --> 00:40:28.334
Veme:
Yes, that's right,

00:40:28.334 --> 00:40:31.200
but MapReduce
is still under development

00:40:31.200 --> 00:40:33.801
and we're hoping
that pull queues themselves

00:40:33.801 --> 00:40:37.367
may actually form part of
the solution for reducing.

00:40:37.367 --> 00:40:39.300
man:
Okay, thanks.

00:40:39.300 --> 00:40:40.667
Sahasranaman:
Just wanted to add,

00:40:40.667 --> 00:40:42.601
that MapReduce and pull queues
are actually also in,

00:40:42.601 --> 00:40:44.567
to think about
a slightly different--

00:40:44.567 --> 00:40:47.234
a pull queue is also something
that kind of gives you

00:40:47.234 --> 00:40:49.400
like a work flow
kind of system,

00:40:49.400 --> 00:40:55.400
whereas MapReduce is more
like bulk processing.

00:40:55.400 --> 00:40:57.367
man:
Could I add to the queue

00:40:57.367 --> 00:41:01.133
in a transaction like
I can with the push queue?

00:41:01.133 --> 00:41:02.133
Veme:
Yes.

00:41:02.133 --> 00:41:03.467
Actually,
all of those operations

00:41:03.467 --> 00:41:06.400
for adding transactional adds
are still supported.

00:41:06.400 --> 00:41:07.901
Yes.

00:41:07.901 --> 00:41:12.601
man: Also, can I relinquish
a lease once I've taken it?

00:41:12.601 --> 00:41:14.200
Veme:
The way that you would do that

00:41:14.200 --> 00:41:16.801
is simply to let it expire.

00:41:16.801 --> 00:41:18.501
So stop working on it,
it expires,

00:41:18.501 --> 00:41:20.968
someone else can get it.

00:41:20.968 --> 00:41:22.434
woman: I may have missed
something, so I'll ask anyway.

00:41:22.434 --> 00:41:23.834
I have two questions.

00:41:23.834 --> 00:41:27.067
One is, do you see any value
to workers actually being

00:41:27.067 --> 00:41:28.968
with REST
and be notified for tasks

00:41:28.968 --> 00:41:31.434
so that they can pull it down
just to reduce the overhead?

00:41:31.434 --> 00:41:33.767
And the second one is,
I know it's called queues,

00:41:33.767 --> 00:41:36.267
but I'm wondering
is there any potential

00:41:36.267 --> 00:41:37.934
for a Google space
like mechanism

00:41:37.934 --> 00:41:40.968
so workers can actually
request by template

00:41:40.968 --> 00:41:43.434
rather than just for the first
task in the queue?

00:41:43.434 --> 00:41:45.000
Because right now,
it looks like you'd end up

00:41:45.000 --> 00:41:47.567
having to set up separate queues
for each kind of task.

00:41:47.567 --> 00:41:48.934
Sahasranaman: I think I'll let
you answer the second part

00:41:48.934 --> 00:41:50.100
and I'll answer
the first part.

00:41:50.100 --> 00:41:53.467
Veme: Yes. So we do have
several requests

00:41:53.467 --> 00:41:54.868
on our issue tracker

00:41:54.868 --> 00:41:58.133
for just the kinds of things
that you've mentioned.

00:41:58.133 --> 00:41:59.667
We don't support them
just at the moment,

00:41:59.667 --> 00:42:03.200
and we're certainly
working on a design,

00:42:03.200 --> 00:42:05.634
but I really can't give you
more than that. But, yes.

00:42:05.634 --> 00:42:06.934
woman: So does that mean
that's a yes for both of them?

00:42:06.934 --> 00:42:08.434
Notifications?

00:42:08.434 --> 00:42:09.901
Sahasranaman: No so I'll answer
the notification question.

00:42:09.901 --> 00:42:11.167
woman:
Oh, okay.

00:42:11.167 --> 00:42:12.567
Sahasranaman:
So the notifications question

00:42:12.567 --> 00:42:17.200
is that basically, this is
something that our API team

00:42:17.200 --> 00:42:19.634
is actually currently kind of
starting to work on.

00:42:19.634 --> 00:42:22.067
None of our APIs
currently have notifications.

00:42:22.067 --> 00:42:24.067
Like, Calendar doesn't
have notifications.

00:42:24.067 --> 00:42:27.701
So there's a lot of APIs
that you could imagine--

00:42:27.701 --> 00:42:29.400
and notifications and API

00:42:29.400 --> 00:42:30.734
are really two sides
of the same coin.

00:42:30.734 --> 00:42:32.167
woman:
Right.

00:42:32.167 --> 00:42:34.767
Sahasranaman: So yeah, so
we are probably gonna have them

00:42:34.767 --> 00:42:36.701
but they don't exist
right now.

00:42:36.701 --> 00:42:41.033
woman:
Thanks.

00:42:43.400 --> 00:42:46.701
Veme: All right. Well,
there's no more questions.

00:42:46.701 --> 00:42:49.501
Thanks, everybody,
for coming.

00:42:49.501 --> 00:42:52.067
Sahasranaman:
Thank you.

