WEBVTT
Kind: captions
Language: en

00:00:06.250 --> 00:00:07.490
TOR NORBYE: Hello, everyone.

00:00:07.490 --> 00:00:09.281
I'm Tor Norbye from
the Android Tools Team.

00:00:09.281 --> 00:00:11.800
This is Romain Guy from
the Android Platform Team.

00:00:11.800 --> 00:00:14.170
And we're here to introduce
this Kotlin talk, because we

00:00:14.170 --> 00:00:15.490
both use and love Kotlin.

00:00:15.490 --> 00:00:17.906
And we're super excited that
it's now officially supported

00:00:17.906 --> 00:00:18.640
by our teams.

00:00:18.640 --> 00:00:20.590
ROMAIN GUY: Yes, so
one of the big reasons

00:00:20.590 --> 00:00:23.505
why we decided to adopt
Kotlin was you guys, everybody

00:00:23.505 --> 00:00:25.630
here, all the developers
who have been using Kotlin

00:00:25.630 --> 00:00:28.570
in the application, who have
been asking about Kotlin.

00:00:28.570 --> 00:00:30.370
So we thought,
usually it's Googlers

00:00:30.370 --> 00:00:33.160
on stage at Google I/O, and we
decided that this time around,

00:00:33.160 --> 00:00:34.720
we would have non-Googlers.

00:00:34.720 --> 00:00:37.830
So we have Christina Lee from
Pinterest and Jake Wharton

00:00:37.830 --> 00:00:38.830
from Square.

00:00:48.620 --> 00:00:50.510
So they're going
to do all the work,

00:00:50.510 --> 00:00:52.190
and Tor and I will
just disappear.

00:00:52.190 --> 00:00:52.860
Enjoy.

00:00:52.860 --> 00:00:53.526
TOR NORBYE: Bye.

00:01:00.136 --> 00:01:02.010
JAKE WHARTON: OK, so
hopefully all of you are

00:01:02.010 --> 00:01:04.830
were in Hadi presentation
earlier today.

00:01:04.830 --> 00:01:07.860
He talked about the language
and the language features

00:01:07.860 --> 00:01:10.990
outside of Kotlin, just
the language in general.

00:01:10.990 --> 00:01:14.880
And today we're going to go
through examples in Android--

00:01:14.880 --> 00:01:18.840
how the language features can
be used to basically clean up

00:01:18.840 --> 00:01:21.730
a bunch of sort of rough edges
of how you write Android code.

00:01:21.730 --> 00:01:24.840
So the first thing to
start with is here,

00:01:24.840 --> 00:01:27.960
we have a boring main activity.

00:01:27.960 --> 00:01:31.590
And what's interesting to
note is that this parameter is

00:01:31.590 --> 00:01:33.780
actually nullable, so
if your OP process is

00:01:33.780 --> 00:01:35.880
starting from scratch,
this is going to be null.

00:01:35.880 --> 00:01:39.270
And the way that we've now
represented this in Java

00:01:39.270 --> 00:01:42.504
is with nullable annotations,
support annotation.

00:01:42.504 --> 00:01:43.920
And what's great
is that, as these

00:01:43.920 --> 00:01:46.260
have been being added to
your code and Support Library

00:01:46.260 --> 00:01:50.010
code, when you start
writing Kotlin,

00:01:50.010 --> 00:01:52.680
the fact that the method
that you're overriding

00:01:52.680 --> 00:01:56.220
has that annotation, means
that Kotlin indicates

00:01:56.220 --> 00:01:57.550
that it's a nullable type.

00:01:57.550 --> 00:01:59.008
So all of the work
that you've been

00:01:59.008 --> 00:02:01.680
doing to annotate over
the last few years

00:02:01.680 --> 00:02:04.470
is now going to pay off in
Kotlin where the type system

00:02:04.470 --> 00:02:05.981
models nullability.

00:02:09.830 --> 00:02:12.830
Similarly, an Android
4.1, a lot of work

00:02:12.830 --> 00:02:15.990
was done to normalize the
getters and setters on all

00:02:15.990 --> 00:02:18.800
the views, and if you saw--

00:02:18.800 --> 00:02:21.710
these are traditionally called
beans in the Java programming

00:02:21.710 --> 00:02:23.540
language.

00:02:23.540 --> 00:02:26.810
And what's nice is that Kotlin
take these and collapses them

00:02:26.810 --> 00:02:28.780
into what's called properties.

00:02:28.780 --> 00:02:31.530
So in Java you'd refer
to them directly.

00:02:31.530 --> 00:02:33.230
But if we rewrite
this in Kotlin,

00:02:33.230 --> 00:02:36.342
you'll see that we're referring
to just an alpha property.

00:02:36.342 --> 00:02:38.550
And when we're reading from
it, it calls that getter,

00:02:38.550 --> 00:02:40.633
and when we're writing to
it, it calls the setter.

00:02:40.633 --> 00:02:43.140
So all of that work
that was done again

00:02:43.140 --> 00:02:44.300
now pays off in Kotlin.

00:02:49.280 --> 00:02:55.160
So, here's some sample
code that illustrates

00:02:55.160 --> 00:02:58.250
when you need to perform some
operation over the children

00:02:58.250 --> 00:02:59.690
inside of a view group.

00:02:59.690 --> 00:03:02.880
View group is very
similar to a collection,

00:03:02.880 --> 00:03:05.330
but it doesn't have any of
the niceties of collections,

00:03:05.330 --> 00:03:08.940
like being able to
use a foreach loop.

00:03:08.940 --> 00:03:11.990
If we rewrite this and Kotlin,
we get a much more declarative

00:03:11.990 --> 00:03:13.130
syntax.

00:03:13.130 --> 00:03:15.260
The first thing to
note is the range.

00:03:15.260 --> 00:03:18.230
Here, we are using
that infix function,

00:03:18.230 --> 00:03:19.910
and it actually will--

00:03:19.910 --> 00:03:22.550
even though it's
a function, it's

00:03:22.550 --> 00:03:24.140
like a intrinsic
in the compiler,

00:03:24.140 --> 00:03:29.540
so you still get a forloop that
uses indexes in the bytecode.

00:03:29.540 --> 00:03:33.080
And then here you can see
that the child count property

00:03:33.080 --> 00:03:36.590
that we're calling, again
comes from the get child

00:03:36.590 --> 00:03:40.730
count method, which is in Java.

00:03:40.730 --> 00:03:43.040
But we can do a lot
better than this, right?

00:03:43.040 --> 00:03:44.460
This isn't that much different.

00:03:44.460 --> 00:03:47.510
It's just a little
bit more clean.

00:03:47.510 --> 00:03:49.910
How can we make view
group behave more

00:03:49.910 --> 00:03:51.177
like other collections?

00:03:51.177 --> 00:03:52.760
While you solve the
extension methods,

00:03:52.760 --> 00:03:55.460
you can add an extension
method to view group,

00:03:55.460 --> 00:03:56.900
which does this iteration.

00:03:56.900 --> 00:04:00.290
And then you're calling code
becomes much more like you

00:04:00.290 --> 00:04:02.211
would over a normal collection.

00:04:05.300 --> 00:04:07.970
The nice thing to note here
is that extension methods

00:04:07.970 --> 00:04:11.810
will desugar into a static
method, where the group is just

00:04:11.810 --> 00:04:15.160
the first parameter.

00:04:15.160 --> 00:04:16.603
An important thing to note is--

00:04:16.603 --> 00:04:18.019
so this is a higher
order function

00:04:18.019 --> 00:04:21.079
that takes in a function
as its parameter.

00:04:21.079 --> 00:04:22.900
This will actually
cause an anonymous class

00:04:22.900 --> 00:04:26.530
to be created at the call
site that encapsulates

00:04:26.530 --> 00:04:28.360
the code inside the lambda.

00:04:28.360 --> 00:04:30.820
So this can become
prohibitively expensive, right,

00:04:30.820 --> 00:04:32.980
if we're using all these
higher order functions

00:04:32.980 --> 00:04:35.590
and creating all these
anonymous classes.

00:04:35.590 --> 00:04:36.730
Deck size goes up.

00:04:36.730 --> 00:04:37.770
Method count goes up.

00:04:40.400 --> 00:04:42.770
What we can actually
do is mark this

00:04:42.770 --> 00:04:45.320
as being an inline function.

00:04:45.320 --> 00:04:47.330
So this wasn't
mentioned by Hadi What

00:04:47.330 --> 00:04:49.520
it does is it basically
takes the implementation

00:04:49.520 --> 00:04:52.320
of this method and inlines
it into the call site.

00:04:52.320 --> 00:04:54.380
And so because the
code has been moved,

00:04:54.380 --> 00:04:56.840
you no longer have to
create that anonymous class.

00:04:56.840 --> 00:05:00.860
And so this method essentially
becomes free to use.

00:05:04.580 --> 00:05:06.890
So one thing that
you might have missed

00:05:06.890 --> 00:05:10.040
is we actually lost the ability
to know what index of child

00:05:10.040 --> 00:05:12.050
we're looking at,
but that's easily

00:05:12.050 --> 00:05:16.280
solved with a second extension
method that allows the index

00:05:16.280 --> 00:05:17.330
to be passed in.

00:05:17.330 --> 00:05:18.830
And again as an
inline function, we

00:05:18.830 --> 00:05:20.204
have no additional
overhead here.

00:05:23.960 --> 00:05:27.945
So that was for iteration,
iterating of the child views.

00:05:27.945 --> 00:05:29.320
But there's a lot
of other things

00:05:29.320 --> 00:05:30.890
we can do to view
group to make it

00:05:30.890 --> 00:05:35.400
behave a lot more like a
traditional collection.

00:05:35.400 --> 00:05:39.690
So for example, if we add a
get method as an extension

00:05:39.690 --> 00:05:43.650
function, we can now
pull out child views

00:05:43.650 --> 00:05:45.970
as if it was a list or array.

00:05:45.970 --> 00:05:48.120
We can refer to them
by index and have

00:05:48.120 --> 00:05:51.880
that corresponding
view returned.

00:05:51.880 --> 00:05:53.820
Key thing here, again
that Hadi pointed out,

00:05:53.820 --> 00:05:56.090
this is an operator
function, so we're

00:05:56.090 --> 00:06:00.350
declaring that it has a
special call site syntax.

00:06:00.350 --> 00:06:02.540
And that's what all of
these are going to be.

00:06:02.540 --> 00:06:06.180
So how about adding
and removing views?

00:06:06.180 --> 00:06:09.350
Well, we can add a minus
assign and plus assign,

00:06:09.350 --> 00:06:12.980
and so this allows us
to use shorthand syntax

00:06:12.980 --> 00:06:15.830
for removing and again adding.

00:06:20.670 --> 00:06:23.400
One more will be looking up
to see if a child's already

00:06:23.400 --> 00:06:26.250
in, and again the implementation
of these functions--

00:06:26.250 --> 00:06:29.100
we're just reusing the
methods that you otherwise

00:06:29.100 --> 00:06:32.790
would have been calling,
but getting a better syntax

00:06:32.790 --> 00:06:36.240
at the call site which
allows the view to behave

00:06:36.240 --> 00:06:39.400
much more like a collection.

00:06:39.400 --> 00:06:41.880
And so this wasn't
highlighted in Hadi's talk,

00:06:41.880 --> 00:06:45.570
but it kind of looks like
this is magical, right?

00:06:45.570 --> 00:06:47.700
When you're looking
at the code at the top

00:06:47.700 --> 00:06:49.530
where you're using
these operators,

00:06:49.530 --> 00:06:51.930
how do you know
what implementation

00:06:51.930 --> 00:06:53.410
of that is actually running?

00:06:53.410 --> 00:06:55.920
Well, a cool trick in
IntelliJ and Android Studio

00:06:55.920 --> 00:06:59.070
is that if you actually put your
cursor on one of the operators,

00:06:59.070 --> 00:07:01.620
you can Command-B into it,
and it will actually take you

00:07:01.620 --> 00:07:02.940
to the corresponding function.

00:07:02.940 --> 00:07:05.695
So even though you got
the nice call site syntax,

00:07:05.695 --> 00:07:07.320
you still have the
visibility into what

00:07:07.320 --> 00:07:09.390
the implementation is doing.

00:07:09.390 --> 00:07:12.330
And if you want, you can
actually call these methods

00:07:12.330 --> 00:07:17.880
as if they are extension methods
not using the operator syntax,

00:07:17.880 --> 00:07:19.968
because again, they're
just normal functions.

00:07:23.390 --> 00:07:25.610
So extending a type isn't
limited to just methods.

00:07:25.610 --> 00:07:27.170
We can also add properties.

00:07:27.170 --> 00:07:31.760
So how about adding
the number of children

00:07:31.760 --> 00:07:33.290
as a size property,
which is what

00:07:33.290 --> 00:07:34.540
a list or array would expose.

00:07:41.990 --> 00:07:43.670
Interesting thing
to note here, again,

00:07:43.670 --> 00:07:46.820
using string interpolation,
also mentioned in Hadi's talk.

00:07:52.240 --> 00:07:56.190
OK this one's a
little more advanced.

00:07:56.190 --> 00:08:00.300
But having the foreach
function that we added only

00:08:00.300 --> 00:08:03.072
allows us to do that
type of iteration.

00:08:03.072 --> 00:08:05.280
Whereas, a list, we have
all these other higher order

00:08:05.280 --> 00:08:06.600
functions--

00:08:06.600 --> 00:08:09.420
filtering, mapping--
that we can use

00:08:09.420 --> 00:08:11.700
that we can no longer
use on view group,

00:08:11.700 --> 00:08:14.820
because it doesn't
extend that base type.

00:08:14.820 --> 00:08:15.990
What this code does--

00:08:15.990 --> 00:08:18.540
what you don't have to really
look into and understand--

00:08:18.540 --> 00:08:22.650
is add the ability to create
an iterator of children.

00:08:22.650 --> 00:08:26.370
And so now, we get access to
using the traditional foreach

00:08:26.370 --> 00:08:28.760
loop.

00:08:28.760 --> 00:08:33.480
And if we want, we can use
those higher order extension

00:08:33.480 --> 00:08:36.720
functions that
exist on iterable.

00:08:36.720 --> 00:08:39.600
So here I am
collecting the height

00:08:39.600 --> 00:08:42.900
of all the visible
views, very declarative.

00:08:42.900 --> 00:08:47.010
And if they are
inline functions,

00:08:47.010 --> 00:08:49.060
you lose you lose
the overhead as well.

00:08:55.140 --> 00:08:59.120
So extension functions are
great for encapsulating

00:08:59.120 --> 00:09:00.800
repetitive tasks.

00:09:00.800 --> 00:09:04.370
So if you're using custom
trace points as an example,

00:09:04.370 --> 00:09:07.060
I always forget to
put the end section.

00:09:07.060 --> 00:09:08.660
And especially if
you're refactoring

00:09:08.660 --> 00:09:10.580
code that has trace
voice in it, it's

00:09:10.580 --> 00:09:14.690
very easy to rearrange
which end section is

00:09:14.690 --> 00:09:16.730
applied to which begin section.

00:09:16.730 --> 00:09:20.420
And it ends up screwing
up the SIS trace output.

00:09:20.420 --> 00:09:22.587
What we can do is just go
back and use this trick

00:09:22.587 --> 00:09:23.420
over and over again.

00:09:23.420 --> 00:09:28.050
We can encapsulate that code
inside of an inline function.

00:09:28.050 --> 00:09:30.830
And so, this will perform
the begin and end,

00:09:30.830 --> 00:09:34.950
and then it will execute
our lambda in the middle.

00:09:34.950 --> 00:09:37.250
But as an inline function,
we don't pay the cost

00:09:37.250 --> 00:09:39.440
of allocating anything.

00:09:39.440 --> 00:09:42.500
And so now our call site just
becomes trace with the tag,

00:09:42.500 --> 00:09:44.540
and then whatever's in
the body is automatically

00:09:44.540 --> 00:09:45.590
wrapped in begin and end.

00:09:48.790 --> 00:09:51.280
Another nice thing is
that you can actually

00:09:51.280 --> 00:09:52.810
return from these
functions, and so

00:09:52.810 --> 00:09:54.820
if you're computing
something, we

00:09:54.820 --> 00:09:58.220
don't lose the ability
to capture return value.

00:10:02.760 --> 00:10:06.360
OK so same tricks
over and over again.

00:10:06.360 --> 00:10:09.780
A lot of times when you're
writing the same boilerplate

00:10:09.780 --> 00:10:13.500
code, you can get this like
vision where you lose track

00:10:13.500 --> 00:10:16.680
of the ability to differentiate
whether something is correct

00:10:16.680 --> 00:10:18.930
or a mistake, because
you're so used to seeing it,

00:10:18.930 --> 00:10:20.320
you just gloss over.

00:10:20.320 --> 00:10:22.050
And so you might
have missed looking

00:10:22.050 --> 00:10:24.510
at this, that were
actually missing setting

00:10:24.510 --> 00:10:26.310
the transaction to successful.

00:10:26.310 --> 00:10:29.070
And so all the code in this
block wouldn't have even ran.

00:10:29.070 --> 00:10:31.960
This is another one where we
can just apply the same trick,

00:10:31.960 --> 00:10:33.960
write an inline function
that encapsulates

00:10:33.960 --> 00:10:38.204
this ceremony around interacting
with a database transaction,

00:10:38.204 --> 00:10:39.870
and then our call
site becomes extremely

00:10:39.870 --> 00:10:42.630
simple and declarative.

00:10:42.630 --> 00:10:44.970
This one is especially
interesting,

00:10:44.970 --> 00:10:48.690
because we still have
to refer to the database

00:10:48.690 --> 00:10:50.700
inside the transaction lock.

00:10:50.700 --> 00:10:52.740
It would be nice if we
somehow could associate

00:10:52.740 --> 00:10:57.150
the statements inside the block
with the enclosing transaction,

00:10:57.150 --> 00:10:59.560
because we already specified
it on the database.

00:10:59.560 --> 00:11:03.912
So it's redundant to say
it over and over again.

00:11:03.912 --> 00:11:05.370
One way to accomplish
this would be

00:11:05.370 --> 00:11:07.470
to change the lambda
that's being passed

00:11:07.470 --> 00:11:11.850
into the function, such
that we inject the database

00:11:11.850 --> 00:11:13.620
reference back into it.

00:11:13.620 --> 00:11:16.590
And this allows our code
to pass this into the body.

00:11:16.590 --> 00:11:20.190
This allows our code to refer
to the it parameter, which

00:11:20.190 --> 00:11:22.410
is when there's only a
single argument being

00:11:22.410 --> 00:11:23.220
passed to a lambda.

00:11:23.220 --> 00:11:27.190
You can just refer to it as it.

00:11:27.190 --> 00:11:29.190
This isn't as nice as
it could be though,

00:11:29.190 --> 00:11:31.770
because now every statement
that we put inside this lambda

00:11:31.770 --> 00:11:35.820
has to have it prefix
in front of it.

00:11:35.820 --> 00:11:40.230
So just like we had extension
functions, which add methods

00:11:40.230 --> 00:11:44.670
to a type, we can create
extension lambdas,

00:11:44.670 --> 00:11:48.217
or as I believe Kotlin calls
it lambdas with receivers.

00:11:48.217 --> 00:11:49.800
Well, it's the same
trick where, if we

00:11:49.800 --> 00:11:51.840
change the parameter
of the lambda that's

00:11:51.840 --> 00:11:54.990
being passed in to
itself via an extension

00:11:54.990 --> 00:11:58.740
function of the
database, This means

00:11:58.740 --> 00:12:02.310
that the body inside the
lambda is going to execute,

00:12:02.310 --> 00:12:06.330
as if it was a method
on SQLite database.

00:12:06.330 --> 00:12:09.510
And such, we can call methods
without having to qualify them

00:12:09.510 --> 00:12:10.830
with any reference.

00:12:10.830 --> 00:12:13.500
So now, our call site only
mentions the database once,

00:12:13.500 --> 00:12:15.780
and then we can just
call the methods

00:12:15.780 --> 00:12:18.210
for performing inserts,
updates, and deletes,

00:12:18.210 --> 00:12:21.819
without having to qualify them
with the database reference.

00:12:26.410 --> 00:12:29.930
OK sticking with databases.

00:12:29.930 --> 00:12:34.170
Doing inserts like this is not
terrible-- or deletes, I guess,

00:12:34.170 --> 00:12:35.430
in this case--

00:12:35.430 --> 00:12:38.790
but the problem is
actually the database

00:12:38.790 --> 00:12:41.940
that underlies the--
it has to execute this.

00:12:41.940 --> 00:12:44.730
It has to parse the
query every single time.

00:12:44.730 --> 00:12:46.820
Figure out that it's
syntactically correct,

00:12:46.820 --> 00:12:49.860
figure it out where
the question marks

00:12:49.860 --> 00:12:53.070
are that it needs to
bind arguments into.

00:12:53.070 --> 00:12:55.529
And so if you're running this
over and over and over again,

00:12:55.529 --> 00:12:57.403
you're basically wasting
time in the database

00:12:57.403 --> 00:12:59.610
for having it to parse your
query every single time.

00:13:02.460 --> 00:13:05.070
The way that this is
solved in the SQLite APIs

00:13:05.070 --> 00:13:08.400
is by compiling a
statement ahead of time

00:13:08.400 --> 00:13:10.480
and then reusing that
over and over again.

00:13:10.480 --> 00:13:15.210
And so now, the database
only has to parse this once,

00:13:15.210 --> 00:13:18.800
and then it just
kind of remembers,

00:13:18.800 --> 00:13:21.109
creates a model of
what the query is.

00:13:21.109 --> 00:13:22.650
And then when you
execute it, it only

00:13:22.650 --> 00:13:26.314
has to insert the
arguments and execute them.

00:13:26.314 --> 00:13:26.980
So this is nice.

00:13:26.980 --> 00:13:28.354
We get a performance
win if we're

00:13:28.354 --> 00:13:29.770
calling this a bunch of times.

00:13:29.770 --> 00:13:32.610
But we actually change this,
such that if we were calling

00:13:32.610 --> 00:13:36.870
delete by first name on a
background thread before,

00:13:36.870 --> 00:13:39.030
this compile statement
is going to run

00:13:39.030 --> 00:13:41.400
whenever this class
is created, which

00:13:41.400 --> 00:13:43.180
is usually the main thread.

00:13:43.180 --> 00:13:47.170
And so we move database
work onto the main thread.

00:13:47.170 --> 00:13:50.020
The way that this is
fixed is with a feature

00:13:50.020 --> 00:13:53.140
called delegation, and this
is property delegation.

00:13:53.140 --> 00:13:56.620
It's basically allowing
you to supply code

00:13:56.620 --> 00:14:01.990
behind a property that can
run whenever it's assigned to

00:14:01.990 --> 00:14:02.981
or read from.

00:14:02.981 --> 00:14:04.480
So in this case,
what we're doing is

00:14:04.480 --> 00:14:07.960
we're delegating the
implementation of this delete

00:14:07.960 --> 00:14:13.240
by first name property
and to a built in Kotlin

00:14:13.240 --> 00:14:15.790
feature, which is
going to make it lazy.

00:14:15.790 --> 00:14:18.790
So lazy takes in
a lambda now, that

00:14:18.790 --> 00:14:21.760
only gets called the
first time that you get

00:14:21.760 --> 00:14:25.180
the value from this property.

00:14:25.180 --> 00:14:27.250
And so what we've
done is now allowed

00:14:27.250 --> 00:14:30.190
this to have the same
behavior as the original,

00:14:30.190 --> 00:14:34.009
where it was parsed on the
background thread, but now

00:14:34.009 --> 00:14:35.800
it only does it once
instead of many times.

00:14:38.860 --> 00:14:41.770
There's a lot of examples of
where delegation on properties

00:14:41.770 --> 00:14:42.490
can be useful.

00:14:45.350 --> 00:14:47.110
Another built in
one is observable,

00:14:47.110 --> 00:14:50.020
which allows the
lambda that you supply

00:14:50.020 --> 00:14:54.790
to be called every time the
property value is changed.

00:14:54.790 --> 00:14:57.370
So I read a new
property to this name,

00:14:57.370 --> 00:14:59.650
and the delegate
calls this lambda

00:14:59.650 --> 00:15:01.210
with the old value,
the new value.

00:15:05.360 --> 00:15:07.490
For properties that
aren't immediately

00:15:07.490 --> 00:15:09.380
going to be initialized,
but that you know

00:15:09.380 --> 00:15:11.780
will very soon be initialized--

00:15:11.780 --> 00:15:13.850
instead of marking
them as nullable,

00:15:13.850 --> 00:15:16.580
which requires you to
initialize it immediately

00:15:16.580 --> 00:15:18.090
when the class is created--

00:15:18.090 --> 00:15:21.830
you can use a delegate that
allows you to sort of defer

00:15:21.830 --> 00:15:22.901
setting the value.

00:15:22.901 --> 00:15:25.400
And so if you try to read from
this without setting a value,

00:15:25.400 --> 00:15:27.230
it's going to
throw an exception.

00:15:27.230 --> 00:15:30.000
But if you write to it and then
read from it, totally fine.

00:15:30.000 --> 00:15:32.750
So this is perfect for cases
like activities in fragments

00:15:32.750 --> 00:15:35.766
where you don't control
the creation of the class,

00:15:35.766 --> 00:15:37.640
but there is a method
in the lifecycle that's

00:15:37.640 --> 00:15:42.590
very early, where you usually
set up these properties.

00:15:42.590 --> 00:15:44.720
And you can write
your own delegate.

00:15:44.720 --> 00:15:47.550
Delegate's just a interface
that you can implement.

00:15:47.550 --> 00:15:51.050
So we have one which
allows us to bind views.

00:15:51.050 --> 00:15:55.490
So it automatically-- if
this is in a view subclass,

00:15:55.490 --> 00:15:57.769
it will lazily look up
this view the first time

00:15:57.769 --> 00:15:58.560
that you access it.

00:16:03.540 --> 00:16:07.470
Another feature of delegation
is class delegation.

00:16:07.470 --> 00:16:10.440
So the transitions
framework lacks a base class

00:16:10.440 --> 00:16:12.480
that you can extend
from, such that you only

00:16:12.480 --> 00:16:15.510
have to override one method.

00:16:15.510 --> 00:16:17.760
Won't it be nice if
we somehow could only

00:16:17.760 --> 00:16:20.790
override the method
we needed, and then

00:16:20.790 --> 00:16:22.470
have something else
that we delegated to

00:16:22.470 --> 00:16:24.760
for those empty implementations?

00:16:24.760 --> 00:16:25.470
We can do this.

00:16:25.470 --> 00:16:28.350
You can create a class--
this is a object class, which

00:16:28.350 --> 00:16:31.860
is a singleton and Kotlin, and
it has empty implementations

00:16:31.860 --> 00:16:34.490
of all the functions.

00:16:34.490 --> 00:16:37.450
And so now on our original
type, what we can say

00:16:37.450 --> 00:16:39.970
is that we're implementing
transaction listener,

00:16:39.970 --> 00:16:42.640
but we're going to delegate
every call to this singleton

00:16:42.640 --> 00:16:45.640
type, except for the
ones that we override.

00:16:45.640 --> 00:16:47.860
And what Kotlin will
do is basically just

00:16:47.860 --> 00:16:50.680
add the overrides in the
class automatically, call

00:16:50.680 --> 00:16:52.840
the delegate for the ones
you haven't overwritten,

00:16:52.840 --> 00:16:55.650
and your code that
is overwritten

00:16:55.650 --> 00:16:57.910
for the single method will
be used only for that one.

00:17:01.490 --> 00:17:04.627
For testing, we
abstract away espresso.

00:17:04.627 --> 00:17:06.710
We have these things called
robots, which are just

00:17:06.710 --> 00:17:10.790
kind of high level methods
that we can interact with,

00:17:10.790 --> 00:17:14.180
instead of putting espresso
in every single test.

00:17:14.180 --> 00:17:16.040
And what's great is
that in Kotlin, we

00:17:16.040 --> 00:17:19.849
can call this in a very
readable and declarative way,

00:17:19.849 --> 00:17:21.650
but again, another
trick you can do

00:17:21.650 --> 00:17:24.020
is with these
extension functions

00:17:24.020 --> 00:17:26.720
and lambdas with
receivers, is take

00:17:26.720 --> 00:17:30.050
that kind of weird looking
constructor initialization

00:17:30.050 --> 00:17:32.270
and the apply method, which
doesn't really make sense

00:17:32.270 --> 00:17:34.280
in this case, and
turn it into something

00:17:34.280 --> 00:17:36.340
that's much like a DSL.

00:17:36.340 --> 00:17:38.780
And so you can build
these type-safe DSLs out

00:17:38.780 --> 00:17:42.290
of any domain that
you have in your app.

00:17:42.290 --> 00:17:44.135
The testing is just one example.

00:17:46.890 --> 00:17:50.120
And so finally, sealed
classes got a mention as well.

00:17:50.120 --> 00:17:52.130
So these are basically
type hierarchies

00:17:52.130 --> 00:17:57.070
that are better close that
other downstream consumers can't

00:17:57.070 --> 00:17:59.500
add an implementation of.

00:17:59.500 --> 00:18:03.920
A great use of this on Android
is for recycler view payloads.

00:18:03.920 --> 00:18:07.270
So let's say you're displaying
tweets, and when you click them

00:18:07.270 --> 00:18:10.180
or when you receive data
from the web service,

00:18:10.180 --> 00:18:13.600
you want to update the
counts and the icons.

00:18:13.600 --> 00:18:16.240
So you can write a sealed class
for each of these events, which

00:18:16.240 --> 00:18:19.570
are the objects that will
send to recycler view

00:18:19.570 --> 00:18:23.140
as payloads, so that it knows
the only change a number,

00:18:23.140 --> 00:18:26.490
or only change an icon.

00:18:26.490 --> 00:18:31.780
In here, we're using data
classes again, also mentioned.

00:18:31.780 --> 00:18:33.830
And what's great
about this is we

00:18:33.830 --> 00:18:36.350
can use a lot of the
language features

00:18:36.350 --> 00:18:40.370
to make this really readable
on the consuming side.

00:18:40.370 --> 00:18:43.020
We get the nice looping
with the lambda,

00:18:43.020 --> 00:18:45.920
then we can use the
when block, which allows

00:18:45.920 --> 00:18:48.710
us to do the smart casting.

00:18:48.710 --> 00:18:50.990
So for each of
these branches, they

00:18:50.990 --> 00:18:54.110
have associated properties
in the data classes.

00:18:54.110 --> 00:18:57.350
So each one can now
reference the properties

00:18:57.350 --> 00:19:00.110
without having to do the
explicit cast, because the

00:19:00.110 --> 00:19:04.670
when expression took care of it.

00:19:04.670 --> 00:19:08.590
So we add the other
branches, and we

00:19:08.590 --> 00:19:10.870
get this nice readable
payload implementation,

00:19:10.870 --> 00:19:14.860
instead of what we have in Java,
which is a bunch of objects

00:19:14.860 --> 00:19:18.170
and a bunch of manual casting.

00:19:18.170 --> 00:19:24.139
And so hopefully, all these
examples have really resonated.

00:19:24.139 --> 00:19:25.930
I mean there's so many
things over and over

00:19:25.930 --> 00:19:29.350
that we do in Java that we can
take the features of the Kotlin

00:19:29.350 --> 00:19:31.120
programming language
and apply them

00:19:31.120 --> 00:19:33.539
to make the code more fun to
read and more fun to write.

00:19:33.539 --> 00:19:35.080
And so now, I'm
going to turn it over

00:19:35.080 --> 00:19:37.150
to Christina, who will
talk to you about how

00:19:37.150 --> 00:19:40.056
you can adopt the language
in your organization.

00:19:40.056 --> 00:19:44.538
[APPLAUSE]

00:19:44.538 --> 00:19:49.520
[CHEERING]

00:19:49.520 --> 00:19:51.070
CHRISTINA LEE: Thanks, Jake.

00:19:51.070 --> 00:19:52.900
So hello.

00:19:52.900 --> 00:19:56.590
I just want to start out
by saying, we're here.

00:19:56.590 --> 00:20:01.674
This is I/O 2017, and we
have a session about Kotlin.

00:20:01.674 --> 00:20:04.090
A lot of people who made that
happen, they're in the room.

00:20:04.090 --> 00:20:07.060
Both the Googlers and the
people from JetBrains.

00:20:07.060 --> 00:20:08.369
I know I appreciate it.

00:20:08.369 --> 00:20:09.910
Can we give them a
round of applause?

00:20:09.910 --> 00:20:15.862
[APPLAUSE]

00:20:19.840 --> 00:20:20.950
All right.

00:20:20.950 --> 00:20:23.290
So it's been a journey--

00:20:23.290 --> 00:20:25.150
not as long as it
could have been.

00:20:25.150 --> 00:20:27.400
It's been pretty
swift, actually,

00:20:27.400 --> 00:20:29.080
but it's been a journey.

00:20:29.080 --> 00:20:32.800
A lot of us have been out
there talking to people

00:20:32.800 --> 00:20:35.200
and evangelizing Kotlin.

00:20:35.200 --> 00:20:38.740
And at first, there were
some objections like, hey,

00:20:38.740 --> 00:20:40.270
this language isn't finalized.

00:20:40.270 --> 00:20:43.850
Are you sure we should
use that in production?

00:20:43.850 --> 00:20:47.020
But as time went
on, that was solved.

00:20:47.020 --> 00:20:49.180
We now have our 1.0,
and we've had a lot

00:20:49.180 --> 00:20:51.370
of great releases since then.

00:20:51.370 --> 00:20:53.710
But I can guarantee
that anybody who's

00:20:53.710 --> 00:20:56.620
talked to anyone about
Kotlin has always fielded

00:20:56.620 --> 00:20:59.080
exactly the same question.

00:20:59.080 --> 00:21:04.584
And that was, so what does
Google think about this?

00:21:04.584 --> 00:21:07.000
And this is great, because of
course, now I can stand here

00:21:07.000 --> 00:21:08.170
and say, solved problem.

00:21:08.170 --> 00:21:11.110
This is my last slide, goodbye.

00:21:11.110 --> 00:21:15.890
But it's not actually that
easy, because of course, this

00:21:15.890 --> 00:21:19.519
is like one of those situations
where your friend says hey,

00:21:19.519 --> 00:21:20.310
do you want to run?

00:21:20.310 --> 00:21:24.160
And you're on the couch watching
TV and say, sorry, don't

00:21:24.160 --> 00:21:25.090
have running shoes.

00:21:25.090 --> 00:21:25.907
Shucks.

00:21:25.907 --> 00:21:27.490
And then they say,
it's OK we can just

00:21:27.490 --> 00:21:30.250
do push-ups You don't
need equipment for that.

00:21:30.250 --> 00:21:33.340
We've taken away that
first layer of excuse.

00:21:33.340 --> 00:21:35.740
It's the pushback that
we got most often,

00:21:35.740 --> 00:21:37.570
and now we don't
have that pushback.

00:21:37.570 --> 00:21:38.560
We have a stance.

00:21:38.560 --> 00:21:41.590
We know where we stand, but
that doesn't mean that there's

00:21:41.590 --> 00:21:42.990
no work to be done.

00:21:42.990 --> 00:21:46.510
Now, there's quite a
bit of work actually.

00:21:46.510 --> 00:21:50.020
And so I'm going to talk to
you about how to do that.

00:21:50.020 --> 00:21:52.720
A lot of the experience
will come from my mistakes

00:21:52.720 --> 00:21:54.640
but also from a lot of
you in the community

00:21:54.640 --> 00:21:57.430
that I've been talking to.

00:21:57.430 --> 00:22:01.310
So I like to break this
down into three steps.

00:22:01.310 --> 00:22:04.600
The first one and
the easiest is you.

00:22:04.600 --> 00:22:06.430
You control what you say.

00:22:06.430 --> 00:22:09.970
You control how you say
it and who you say it to.

00:22:09.970 --> 00:22:13.240
That control, it gives
you a lot of power.

00:22:13.240 --> 00:22:15.700
The second one is management.

00:22:15.700 --> 00:22:18.170
This is often the
elephant in the room,

00:22:18.170 --> 00:22:22.250
but we have some strategies to
make it easier to talk to them.

00:22:22.250 --> 00:22:24.580
And last, and I leave
at last on purpose,

00:22:24.580 --> 00:22:27.340
because I truly believe
it's the hardest part,

00:22:27.340 --> 00:22:31.090
is getting buy-in from your
team and creating an environment

00:22:31.090 --> 00:22:33.370
where when you
introduce a new tool,

00:22:33.370 --> 00:22:36.550
everybody that you work with
can be as successful and as

00:22:36.550 --> 00:22:39.530
productive as you are with it.

00:22:39.530 --> 00:22:42.280
So let's start with you.

00:22:42.280 --> 00:22:45.010
I have this quote here
that has absolutely nothing

00:22:45.010 --> 00:22:46.150
to do with tech.

00:22:46.150 --> 00:22:48.820
It's a very grandiose
quote, and the essence of it

00:22:48.820 --> 00:22:51.040
is that the only
thing that's ever

00:22:51.040 --> 00:22:54.130
created change in the world
is a small group of people

00:22:54.130 --> 00:22:56.150
who have cared deeply.

00:22:56.150 --> 00:22:58.420
And I know that
we're not usually

00:22:58.420 --> 00:22:59.980
here to change the world.

00:22:59.980 --> 00:23:02.260
We're here to change code bases.

00:23:02.260 --> 00:23:05.590
But the reason I include
this is because the language

00:23:05.590 --> 00:23:08.950
of influence is
applicable to all of us.

00:23:08.950 --> 00:23:12.520
This happens in industries
all around the world,

00:23:12.520 --> 00:23:14.830
and we don't get
to escape from it.

00:23:14.830 --> 00:23:17.870
I know that a lot of people
in this room are saying,

00:23:17.870 --> 00:23:20.090
but wait, I'm an introvert.

00:23:20.090 --> 00:23:22.540
I don't know if I can go
on stage and do a dance

00:23:22.540 --> 00:23:24.430
and shout, go Kotlin.

00:23:24.430 --> 00:23:27.050
And I'm not asking
you to do that.

00:23:27.050 --> 00:23:29.860
There are a lot of ways
for you to show enthusiasm

00:23:29.860 --> 00:23:31.720
and to be passionate.

00:23:31.720 --> 00:23:33.190
You can tweet about it.

00:23:33.190 --> 00:23:37.210
You can send a slack message
to your best friend, an email,

00:23:37.210 --> 00:23:40.720
an SMS, an MMS if we
want to go back 10 years.

00:23:40.720 --> 00:23:42.400
It doesn't really matter.

00:23:42.400 --> 00:23:45.880
There are a lot of ways that you
can communicate that you care,

00:23:45.880 --> 00:23:49.150
but the important thing is
that you do communicate.

00:23:49.150 --> 00:23:51.220
Because of course, if
you're sitting here

00:23:51.220 --> 00:23:53.170
waiting for the
people in your offers

00:23:53.170 --> 00:23:56.110
to be struck by a thunderbolt
and suddenly understand

00:23:56.110 --> 00:24:00.040
the awe-inspiring nature
of nullable types,

00:24:00.040 --> 00:24:02.920
you're probably going
to be left waiting.

00:24:02.920 --> 00:24:06.310
So be enthusiastic and
share that enthusiasm

00:24:06.310 --> 00:24:09.640
with other people, no
matter what that looks like.

00:24:09.640 --> 00:24:13.450
But the corollary to that
is that the easy part

00:24:13.450 --> 00:24:15.100
is being enthusiastic.

00:24:15.100 --> 00:24:16.120
It's a great language.

00:24:16.120 --> 00:24:19.120
It's not that hard to
get excited about it,

00:24:19.120 --> 00:24:21.340
but you also need
to sign up for what

00:24:21.340 --> 00:24:25.870
comes with that, which is that
people will have questions.

00:24:25.870 --> 00:24:28.090
If you have a build
system completely

00:24:28.090 --> 00:24:30.820
based on the Java
programming language

00:24:30.820 --> 00:24:33.220
and you introduce
a new tool to it,

00:24:33.220 --> 00:24:35.530
there's a good chance
that it might hiccup,

00:24:35.530 --> 00:24:38.770
that something might not
go exactly as planned.

00:24:38.770 --> 00:24:42.790
And you need to be there to
make sure that you can fix that,

00:24:42.790 --> 00:24:45.700
because if you care enough
to introduce a new tool,

00:24:45.700 --> 00:24:49.254
you also need to care enough
to be a steward for it.

00:24:49.254 --> 00:24:51.670
That's all I'm going to say
about you, because again, it's

00:24:51.670 --> 00:24:52.780
the part that you control.

00:24:52.780 --> 00:24:54.550
It's the easy part, right?

00:24:54.550 --> 00:24:55.780
Just get excited.

00:24:55.780 --> 00:24:57.730
It works.

00:24:57.730 --> 00:24:59.980
Now, management.

00:24:59.980 --> 00:25:02.830
Management is the
elephant in the room.

00:25:02.830 --> 00:25:05.140
I started by saying,
hey, the number one

00:25:05.140 --> 00:25:08.050
question I got was what
is Google's stance.

00:25:08.050 --> 00:25:09.700
But of course, the
number two thing

00:25:09.700 --> 00:25:14.200
that I talked about with
the community was I'm sold.

00:25:14.200 --> 00:25:17.620
I love it, but I can't convince
the people in my company

00:25:17.620 --> 00:25:20.380
that I should be
allowed to adopt Kotlin.

00:25:20.380 --> 00:25:21.460
So let's talk about that.

00:25:25.310 --> 00:25:28.350
I have been on stage,
and I've said, hey,

00:25:28.350 --> 00:25:30.380
there's this magic
argument you can use.

00:25:30.380 --> 00:25:32.030
You just walk into
someone's office,

00:25:32.030 --> 00:25:34.160
and then you say,
give me this language

00:25:34.160 --> 00:25:38.550
and I'll give you in NPE or
a relatively NPE free app.

00:25:38.550 --> 00:25:41.720
I say relatively, because where
there's a will, there's a way.

00:25:41.720 --> 00:25:45.440
But this is a great argument--
the more I talked about it

00:25:45.440 --> 00:25:47.000
with you in the
community though,

00:25:47.000 --> 00:25:49.730
the more I realized that
it boils down to something

00:25:49.730 --> 00:25:52.300
much more fundamental.

00:25:52.300 --> 00:25:56.600
And that is that Kotlin
and languages like it,

00:25:56.600 --> 00:25:58.700
they help us offload
things that we're not

00:25:58.700 --> 00:26:01.730
that good at onto our computer.

00:26:01.730 --> 00:26:03.830
And we already do this a lot.

00:26:03.830 --> 00:26:07.010
The way I know that we do this
is that we all collectively

00:26:07.010 --> 00:26:09.680
freak out anytime
our computer breaks.

00:26:09.680 --> 00:26:10.530
I know I do it.

00:26:10.530 --> 00:26:12.470
I've seen other people
do it, and that's

00:26:12.470 --> 00:26:14.120
because computers
are fundamentally

00:26:14.120 --> 00:26:16.070
a huge part of our life.

00:26:16.070 --> 00:26:18.380
They're really, really good
at doing the things that

00:26:18.380 --> 00:26:21.050
were really, really bad
at, and that frees us up

00:26:21.050 --> 00:26:24.380
to do some of the more creative
thinking, the architecting,

00:26:24.380 --> 00:26:27.230
the making sure that it
works for your coworkers.

00:26:27.230 --> 00:26:29.960
All of these more creative
and critical thinking tasks

00:26:29.960 --> 00:26:33.470
are things that we
get to focus on more.

00:26:33.470 --> 00:26:36.230
And when talking
to management, this

00:26:36.230 --> 00:26:38.690
is something that
they understand.

00:26:38.690 --> 00:26:40.640
They're going to
have questions, yes.

00:26:40.640 --> 00:26:43.940
But if you move this
conversation onto the pain of,

00:26:43.940 --> 00:26:46.370
hey, I have this
tool, and I want

00:26:46.370 --> 00:26:48.440
to use it more effectively.

00:26:48.440 --> 00:26:51.180
People understand
what that means.

00:26:51.180 --> 00:26:54.530
So of course, one example
of this from Jake,

00:26:54.530 --> 00:26:59.210
is just saying that types
are a form of testing,

00:26:59.210 --> 00:27:01.700
and whether you fully
agree with this or not,

00:27:01.700 --> 00:27:07.130
the underlying sentiment is that
we are catching errors sooner.

00:27:07.130 --> 00:27:09.980
And we're doing it without
having to keep it all logged

00:27:09.980 --> 00:27:11.390
into our head.

00:27:11.390 --> 00:27:12.890
And since we don't
have to juggle

00:27:12.890 --> 00:27:14.960
the 10 different places
that something could

00:27:14.960 --> 00:27:19.460
be null or mutating or any
of those other variables,

00:27:19.460 --> 00:27:21.950
it gives us more time to
think about other stuff.

00:27:24.536 --> 00:27:26.390
Sorry.

00:27:26.390 --> 00:27:29.660
This is my favorite
photo in this slide deck.

00:27:29.660 --> 00:27:34.140
The point here is that people
and companies are risk averse,

00:27:34.140 --> 00:27:35.690
and the reason
they're risk averse

00:27:35.690 --> 00:27:37.340
is because someone's
job out there

00:27:37.340 --> 00:27:39.602
is to make sure that your
company doesn't burn down.

00:27:39.602 --> 00:27:41.060
And that's a very
noble profession,

00:27:41.060 --> 00:27:42.980
and I appreciate
that they're there.

00:27:42.980 --> 00:27:44.660
So they have to
keep us in check,

00:27:44.660 --> 00:27:47.570
and that means that when
you're communicating to them,

00:27:47.570 --> 00:27:50.300
you can, by all means,
feel free to say

00:27:50.300 --> 00:27:51.750
there's this thing called VAL.

00:27:51.750 --> 00:27:53.750
And then you changed one
letter, and it's a VAR,

00:27:53.750 --> 00:27:54.590
and it's magical.

00:27:54.590 --> 00:27:56.960
And it's revolutionary, and
you're going to love it.

00:27:56.960 --> 00:27:58.680
And if your manager
is really cool,

00:27:58.680 --> 00:28:00.410
maybe they'll understand that.

00:28:00.410 --> 00:28:02.600
But for a lot of
people, that's not

00:28:02.600 --> 00:28:05.180
going to be a really
persuasive argument,

00:28:05.180 --> 00:28:07.610
and it's because even
if they understand

00:28:07.610 --> 00:28:12.200
that from a technical level,
it doesn't have resonance.

00:28:12.200 --> 00:28:16.070
So talk to people in a
language that they understand.

00:28:16.070 --> 00:28:18.590
Talk to them, not
about the methodology,

00:28:18.590 --> 00:28:21.930
but about the end
goal, which is to say,

00:28:21.930 --> 00:28:24.110
instead of saying there's
typed nullability,

00:28:24.110 --> 00:28:27.020
say I can provide
you an app that's

00:28:27.020 --> 00:28:29.180
more stable for our users.

00:28:29.180 --> 00:28:30.770
It'll crash less.

00:28:30.770 --> 00:28:32.930
The users will be happier.

00:28:32.930 --> 00:28:35.600
Or if your
management, like mine,

00:28:35.600 --> 00:28:39.800
values moving fast,
say, hey, I have a tool,

00:28:39.800 --> 00:28:44.060
and if you allow me to use it,
I can make more reusable code.

00:28:44.060 --> 00:28:46.910
And I can iterate faster,
and we can get more product

00:28:46.910 --> 00:28:48.740
out the door.

00:28:48.740 --> 00:28:51.200
Again, feel free to talk
to them about Kotlin.

00:28:51.200 --> 00:28:54.840
I am never going to discourage
anybody from doing that.

00:28:54.840 --> 00:28:58.040
But also step out of your
shoes and into theirs,

00:28:58.040 --> 00:29:00.020
and talk to them
at a business level

00:29:00.020 --> 00:29:01.430
about what they care about.

00:29:04.280 --> 00:29:05.190
OK.

00:29:05.190 --> 00:29:08.820
Last and hardest, the team.

00:29:08.820 --> 00:29:11.100
Now, this is a really
good place for me

00:29:11.100 --> 00:29:14.730
to add the caveat that
I'm here, because I've

00:29:14.730 --> 00:29:16.260
made some mistakes.

00:29:16.260 --> 00:29:19.140
And I want to share them
with you, so that you don't

00:29:19.140 --> 00:29:21.270
have to make the same ones.

00:29:21.270 --> 00:29:23.160
I'm sure people will
find new ones to make,

00:29:23.160 --> 00:29:25.530
but at least they won't be mine.

00:29:25.530 --> 00:29:30.840
So to start, define success.

00:29:30.840 --> 00:29:33.330
Know what that
looks like for you.

00:29:33.330 --> 00:29:35.910
And I say this, because
I was out on the grass

00:29:35.910 --> 00:29:38.910
when we announced that Kotlin
was going to be supported.

00:29:38.910 --> 00:29:41.310
And I heard a lot of
you saying, hey, cool.

00:29:41.310 --> 00:29:43.620
So does this mean that I can
just convert my whole code

00:29:43.620 --> 00:29:45.020
base to Kotlin?

00:29:45.020 --> 00:29:46.500
And I said, oh yes.

00:29:46.500 --> 00:29:50.370
I mean if that works at
your office, by all means.

00:29:50.370 --> 00:29:54.370
But what I've learned
in my Kotlin adoption,

00:29:54.370 --> 00:29:56.890
was that if you do
that, you're going

00:29:56.890 --> 00:30:00.570
to have to put up with
grumbling for months to come.

00:30:00.570 --> 00:30:03.980
And the reason for
that is that teams--

00:30:03.980 --> 00:30:08.730
they're made of diverse people,
and diverse people almost never

00:30:08.730 --> 00:30:10.890
agree unanimously.

00:30:10.890 --> 00:30:13.860
Which is to say, if you're
in a startup with two people,

00:30:13.860 --> 00:30:15.900
maybe you can go to
lunch and agree on this

00:30:15.900 --> 00:30:17.860
and push the code that day.

00:30:17.860 --> 00:30:19.290
But if you're in
a bigger company

00:30:19.290 --> 00:30:22.290
and you have 30 or
40 doves on a team,

00:30:22.290 --> 00:30:25.740
getting them all into a single
room and agreeing on something

00:30:25.740 --> 00:30:27.390
is going to be time consuming.

00:30:27.390 --> 00:30:29.880
And it's going to take effort.

00:30:29.880 --> 00:30:33.120
And so when defining
success, I would, again,

00:30:33.120 --> 00:30:36.090
encourage you to
focus on the outcome.

00:30:36.090 --> 00:30:37.590
If you want to
stand there and say

00:30:37.590 --> 00:30:40.560
Kotlin is the best
language, you can,

00:30:40.560 --> 00:30:43.110
but I guarantee you someone
will stand up and want

00:30:43.110 --> 00:30:43.980
to argue with you.

00:30:43.980 --> 00:30:49.314
Because it's fun to argue, and
developers love to do that.

00:30:49.314 --> 00:30:49.980
I'm one of them.

00:30:49.980 --> 00:30:51.150
I know.

00:30:51.150 --> 00:30:55.890
So what I would encourage
you to do instead is say,

00:30:55.890 --> 00:30:58.330
we want a stable code base.

00:30:58.330 --> 00:31:02.310
We want to hit this metric for
number of crash free sessions.

00:31:02.310 --> 00:31:05.370
We want to be able
to iterate faster.

00:31:05.370 --> 00:31:08.760
Any of these things, it's
easy for people to agree on.

00:31:08.760 --> 00:31:11.390
They're not
controversial statements.

00:31:11.390 --> 00:31:14.400
And if you start with the
common goal with your team,

00:31:14.400 --> 00:31:16.930
then when you say,
hey, there's this tool.

00:31:16.930 --> 00:31:20.520
It will get us to this
goal in XYZ steps.

00:31:20.520 --> 00:31:23.580
It's a lot easier to
have that conversation.

00:31:23.580 --> 00:31:25.470
You don't have to
start a flame war.

00:31:25.470 --> 00:31:28.230
You can sit there, and
you can dissect pieces

00:31:28.230 --> 00:31:30.330
and have productive
conversations

00:31:30.330 --> 00:31:33.520
on smaller chunks.

00:31:33.520 --> 00:31:38.520
Now, part of this is also
getting stakeholders on board,

00:31:38.520 --> 00:31:43.080
which is something I mildly
did but also mildly didn't.

00:31:43.080 --> 00:31:46.590
So the importance of
this is that if you're

00:31:46.590 --> 00:31:50.460
like me and you're a developer
and not in the management

00:31:50.460 --> 00:31:54.360
chain, it means that
if anything goes wrong

00:31:54.360 --> 00:31:58.080
after you adopt a new
tool like Kotlin, someone

00:31:58.080 --> 00:31:59.700
above you in that
chain it's going

00:31:59.700 --> 00:32:02.760
to be on the hook for it,
which is great for me,

00:32:02.760 --> 00:32:04.780
but less so for them.

00:32:04.780 --> 00:32:09.120
So there's also this dynamic too
that consists of you standing

00:32:09.120 --> 00:32:11.460
here saying, hey, this
is a great language,

00:32:11.460 --> 00:32:13.962
and then someone going
off and saying, hey,

00:32:13.962 --> 00:32:15.420
have you heard
about this language?

00:32:15.420 --> 00:32:17.340
Christina says it
was great, but I just

00:32:17.340 --> 00:32:19.260
wanted to hear your opinion.

00:32:19.260 --> 00:32:21.270
And for both of
these reasons, you

00:32:21.270 --> 00:32:23.940
want to make sure that the
culture setters in your company

00:32:23.940 --> 00:32:28.020
are on board, both because
if something happens,

00:32:28.020 --> 00:32:30.480
you want them to have
your back and to say

00:32:30.480 --> 00:32:32.250
this is the right path for us.

00:32:32.250 --> 00:32:34.290
It's worth it to
push through this.

00:32:34.290 --> 00:32:35.970
Let's just fix it.

00:32:35.970 --> 00:32:39.480
And also because if the
culture setters in your company

00:32:39.480 --> 00:32:43.080
aren't on board, you're going
to have a lot of dissent.

00:32:43.080 --> 00:32:44.850
And I know we can
get complacent,

00:32:44.850 --> 00:32:48.420
because the interop is so good
between the Java programming

00:32:48.420 --> 00:32:52.230
language and Kotlin, but
it's really not a great place

00:32:52.230 --> 00:32:55.945
for your team to be.

00:32:55.945 --> 00:32:58.500
Oh there we go.

00:32:58.500 --> 00:33:03.090
Now, also find someone who
reviews your code like this,

00:33:03.090 --> 00:33:05.280
exactly like this.

00:33:05.280 --> 00:33:06.960
I do this for my team.

00:33:06.960 --> 00:33:09.240
I've been known to
skip around my desk.

00:33:09.240 --> 00:33:09.850
It's happened.

00:33:09.850 --> 00:33:12.480
Ask any of my coworkers
in the audience.

00:33:12.480 --> 00:33:15.060
And you should find
someone in your company

00:33:15.060 --> 00:33:17.650
who feels exactly the same way.

00:33:17.650 --> 00:33:20.250
And the reason I say
that is that again,

00:33:20.250 --> 00:33:23.340
in talking to the audience
and to members of the Kotlin

00:33:23.340 --> 00:33:27.820
community, a lot of you had
said I just snuck Kotlin in.

00:33:27.820 --> 00:33:30.350
And it was great,
and nobody knew.

00:33:30.350 --> 00:33:32.730
Now, one, do you
all still have jobs?

00:33:32.730 --> 00:33:35.590
Like how is that
working for you?

00:33:35.590 --> 00:33:38.274
I mean, we need to talk.

00:33:38.274 --> 00:33:40.440
I don't know about these
rogue commits that are just

00:33:40.440 --> 00:33:41.610
coming up left and right.

00:33:41.610 --> 00:33:43.800
I appreciate the spirit though.

00:33:43.800 --> 00:33:47.820
And two, that means
that you shoulder

00:33:47.820 --> 00:33:49.590
all that work on yourself.

00:33:49.590 --> 00:33:52.020
And I don't know about you,
but I'm already pretty busy.

00:33:52.020 --> 00:33:54.570
I've got a lot of e-mails
to write during the day.

00:33:54.570 --> 00:33:59.400
And so if you can find people
who feel like you to work with,

00:33:59.400 --> 00:34:02.010
that's going to make
your job less hard.

00:34:02.010 --> 00:34:03.900
And the other reason
this is important,

00:34:03.900 --> 00:34:05.850
is that this language,
although it's

00:34:05.850 --> 00:34:07.890
been around for
several years now,

00:34:07.890 --> 00:34:10.800
is just hitting
widespread adoption.

00:34:10.800 --> 00:34:12.900
And what that means
from your perspective,

00:34:12.900 --> 00:34:16.949
is that we don't have 20
years worth of code styles

00:34:16.949 --> 00:34:21.420
to fall back on and best
practices and books and all

00:34:21.420 --> 00:34:23.320
of the things of that nature.

00:34:23.320 --> 00:34:25.530
And that means, that
when you introduce Kotlin

00:34:25.530 --> 00:34:29.650
into your code base, you get
to have those conversations.

00:34:29.650 --> 00:34:32.820
And as a developer,
that's fun, but it's also

00:34:32.820 --> 00:34:35.122
time away from your work.

00:34:35.122 --> 00:34:36.330
And what does this look like?

00:34:36.330 --> 00:34:38.730
It looks like you adding
Kotlin to your code

00:34:38.730 --> 00:34:43.170
and having almost two ways to do
almost exactly the same thing.

00:34:43.170 --> 00:34:46.199
We need to standardize
our code base, ergo,

00:34:46.199 --> 00:34:47.760
what is my company's position?

00:34:47.760 --> 00:34:50.310
Which one do we default to?

00:34:50.310 --> 00:34:52.409
I've also heard
from the Trello team

00:34:52.409 --> 00:34:54.389
that they have a
lot of conversations

00:34:54.389 --> 00:34:58.920
about what it means to be null
when we have typed nullability.

00:34:58.920 --> 00:35:00.840
This wasn't a
conversation that we

00:35:00.840 --> 00:35:03.430
had to have before,
because by default,

00:35:03.430 --> 00:35:05.310
most things were nullable.

00:35:05.310 --> 00:35:11.130
But now that we control that in
a much more concise way, what

00:35:11.130 --> 00:35:12.030
does it mean?

00:35:12.030 --> 00:35:13.530
You need to decide.

00:35:13.530 --> 00:35:16.560
Is it valid for me to
make this thing nullable,

00:35:16.560 --> 00:35:19.410
or is that just completely
illogical for the data

00:35:19.410 --> 00:35:21.510
structure that I'm building?

00:35:21.510 --> 00:35:24.030
These conversations,
they need to be had.

00:35:24.030 --> 00:35:26.340
And while you can have
them with your whole team,

00:35:26.340 --> 00:35:28.950
you can dive in and
say we're all on board.

00:35:28.950 --> 00:35:30.820
It's going to get noisy.

00:35:30.820 --> 00:35:33.270
There's a lot of thrashing
involved in deciding

00:35:33.270 --> 00:35:36.010
what your future looks like.

00:35:36.010 --> 00:35:39.720
And so this is why I would
recommend finding a nucleus

00:35:39.720 --> 00:35:41.370
and working with them.

00:35:41.370 --> 00:35:43.230
It should go without
saying that I also

00:35:43.230 --> 00:35:46.320
hope that you document all of
this, because at some point

00:35:46.320 --> 00:35:48.690
you should bring
everybody else on board.

00:35:48.690 --> 00:35:51.720
And of course, I'm not
saying not to get opinions.

00:35:51.720 --> 00:35:55.810
I'm just saying that if you
try to adopt by consensus,

00:35:55.810 --> 00:35:58.710
it might not move you along
as fast as you would otherwise

00:35:58.710 --> 00:36:01.260
hope.

00:36:01.260 --> 00:36:04.080
Now, I also want to
point out something--

00:36:04.080 --> 00:36:06.600
this is from Dan Lew's blog--

00:36:06.600 --> 00:36:09.600
about what you're expecting
from your coworkers

00:36:09.600 --> 00:36:12.870
when you ask them to
adopt a new language.

00:36:12.870 --> 00:36:15.450
And that's that
you're asking them

00:36:15.450 --> 00:36:19.830
to go from a place of expertise
to a place where they're new

00:36:19.830 --> 00:36:21.570
again.

00:36:21.570 --> 00:36:24.960
And yes, JetBrains has done
everything in their power

00:36:24.960 --> 00:36:26.700
to make this seamless.

00:36:26.700 --> 00:36:28.240
The IDE support is great.

00:36:28.240 --> 00:36:30.080
You can copy and
paste for convert.

00:36:30.080 --> 00:36:31.620
You can right-click convert.

00:36:31.620 --> 00:36:33.630
You can have hints in your IDE.

00:36:33.630 --> 00:36:35.700
You have the
compile time errors.

00:36:35.700 --> 00:36:37.650
They have smoothed
the way for you,

00:36:37.650 --> 00:36:41.610
and it is easy, way easier than
anything else I've adopted.

00:36:41.610 --> 00:36:43.920
But that doesn't mean
that there's no work.

00:36:43.920 --> 00:36:47.430
And so people when they use
the Java programming language,

00:36:47.430 --> 00:36:50.890
are often coming from a place
of having used it for years.

00:36:50.890 --> 00:36:53.509
And that means that they know
all of the little tricks.

00:36:53.509 --> 00:36:55.050
They've read all
the interview books.

00:36:55.050 --> 00:36:57.150
They've read the blog
posts and the puzzlers

00:36:57.150 --> 00:36:58.870
and all of those things.

00:36:58.870 --> 00:37:01.290
And so they know those
tiny little edge cases,

00:37:01.290 --> 00:37:04.390
just from having been in
the environment for ages.

00:37:04.390 --> 00:37:06.330
And when you come
to a new language,

00:37:06.330 --> 00:37:09.510
you don't necessarily bring
that knowledge with you.

00:37:09.510 --> 00:37:12.312
A lot of it is still
applicable, but you also

00:37:12.312 --> 00:37:13.770
have to expect that
there are going

00:37:13.770 --> 00:37:16.630
to be some times where you
haven't found all of the edge

00:37:16.630 --> 00:37:17.130
cases.

00:37:17.130 --> 00:37:19.410
And you're going to
be burned by them.

00:37:19.410 --> 00:37:23.680
And so if you're asking
that of your teammates,

00:37:23.680 --> 00:37:26.550
you need to make sure that
onboarding is a first class

00:37:26.550 --> 00:37:28.560
citizen.

00:37:28.560 --> 00:37:30.985
And I know this
isn't that exciting.

00:37:30.985 --> 00:37:31.860
We're all developers.

00:37:31.860 --> 00:37:32.940
We want to code.

00:37:32.940 --> 00:37:36.060
Who wants documentation anyways?

00:37:36.060 --> 00:37:39.120
But it really, really
is important if you

00:37:39.120 --> 00:37:42.330
want Kotlin to be
successful in your company.

00:37:42.330 --> 00:37:45.990
And that's because you can say,
oh, well everybody on my team

00:37:45.990 --> 00:37:49.890
right now, they know Kotlin,
so we don't need to onboard.

00:37:49.890 --> 00:37:52.140
But what about when
your interns come in?

00:37:52.140 --> 00:37:54.670
Or when you hire someone
new in two months?

00:37:54.670 --> 00:37:56.460
We are not at a
point in the industry

00:37:56.460 --> 00:37:58.650
right now where we can
expect that everybody

00:37:58.650 --> 00:38:02.530
walking through our interview
pipeline knows this language.

00:38:02.530 --> 00:38:04.380
And so if you throw
them in the deep end

00:38:04.380 --> 00:38:07.860
without any flotation
device, that's on you,

00:38:07.860 --> 00:38:11.850
and you should expect them
to feel lost and overwhelmed.

00:38:11.850 --> 00:38:14.700
So make onboarding a
first class citizen.

00:38:14.700 --> 00:38:16.266
Think about it early.

00:38:16.266 --> 00:38:17.640
This probably
means that you have

00:38:17.640 --> 00:38:19.950
to change what you're doing
in the first two weeks

00:38:19.950 --> 00:38:21.570
that your employees arrive.

00:38:21.570 --> 00:38:25.227
You'll have to update
documentation, code examples,

00:38:25.227 --> 00:38:27.060
make sure that they
have the tools they need

00:38:27.060 --> 00:38:29.670
to run this new
language, and probably do

00:38:29.670 --> 00:38:33.630
some mentorship as they learn
the language on the job.

00:38:33.630 --> 00:38:34.800
Do that work.

00:38:34.800 --> 00:38:38.440
It's really important, and I
know, because I put it off.

00:38:38.440 --> 00:38:40.050
So don't be like me.

00:38:40.050 --> 00:38:42.270
Get it out of the way
early, so that you

00:38:42.270 --> 00:38:44.370
don't have a bifurcated team.

00:38:44.370 --> 00:38:47.880
Again, interop, it has
all of the merits, right?

00:38:47.880 --> 00:38:48.900
It's great.

00:38:48.900 --> 00:38:51.840
But it can also make us
lazy, because we can say,

00:38:51.840 --> 00:38:54.000
they don't need to use Kotlin.

00:38:54.000 --> 00:38:56.430
They can use Java.

00:38:56.430 --> 00:39:00.450
But Kotlin, it's here to stay,
and we want people to enjoy it.

00:39:00.450 --> 00:39:02.190
And we want them to partake.

00:39:02.190 --> 00:39:03.990
So just saying, you
don't need Kotlin.

00:39:03.990 --> 00:39:06.390
You can use Java--

00:39:06.390 --> 00:39:08.270
it's not the best route.

00:39:08.270 --> 00:39:10.770
Really.

00:39:10.770 --> 00:39:15.870
Now, my only last
remaining point, show up.

00:39:15.870 --> 00:39:19.080
Be there for the work
that needs to take place.

00:39:19.080 --> 00:39:22.920
That documentation
updating, that advocacy,

00:39:22.920 --> 00:39:26.070
we all know Jake's white
paper from several years ago.

00:39:26.070 --> 00:39:29.370
That didn't just
poof into existence.

00:39:29.370 --> 00:39:31.410
He sat down, and he wrote it.

00:39:31.410 --> 00:39:34.560
And I know at my company,
we've had those moments too.

00:39:34.560 --> 00:39:36.450
We've done the behind
the scenes work that

00:39:36.450 --> 00:39:40.440
has made the adoption during the
workday much more successful,

00:39:40.440 --> 00:39:42.180
and it's not glamorous.

00:39:42.180 --> 00:39:44.040
I know.

00:39:44.040 --> 00:39:47.880
But if you want Kotlin to be
successful in your company,

00:39:47.880 --> 00:39:50.080
it's necessary.

00:39:50.080 --> 00:39:52.350
And now that I've
bummed you all out

00:39:52.350 --> 00:39:54.600
and told you how hard
this is all going to be,

00:39:54.600 --> 00:39:57.690
I just want to remind
you where we are.

00:39:57.690 --> 00:40:00.300
We have official
support for Kotlin,

00:40:00.300 --> 00:40:02.560
and that's a great place to be.

00:40:02.560 --> 00:40:04.530
So yes, there's
work involved in it.

00:40:04.530 --> 00:40:06.760
I know, and it's not
sexy work either.

00:40:06.760 --> 00:40:09.150
It's not as fun
as writing Kotlin.

00:40:09.150 --> 00:40:10.470
But it's worth it.

00:40:10.470 --> 00:40:13.500
We have the chance to
use an amazing language,

00:40:13.500 --> 00:40:16.710
so let's put to work
in to make it happen.

00:40:16.710 --> 00:40:20.400
Now, I know a lot of you, after
the keynote, were asking, hey,

00:40:20.400 --> 00:40:21.090
I'm interested.

00:40:21.090 --> 00:40:21.600
I'm solid.

00:40:21.600 --> 00:40:23.190
How do I get started?

00:40:23.190 --> 00:40:25.320
Well, here are a few resources.

00:40:25.320 --> 00:40:28.710
Predictably, I have links to
both the Android documentation

00:40:28.710 --> 00:40:31.140
and the JetBrains documentation.

00:40:31.140 --> 00:40:33.910
On that JetBrains
site, you'll find

00:40:33.910 --> 00:40:38.280
koans, which are ways to
go through coding exercises

00:40:38.280 --> 00:40:40.890
and explore the
language incrementally,

00:40:40.890 --> 00:40:42.900
as well as a standard
documentation

00:40:42.900 --> 00:40:43.920
and a [INAUDIBLE].

00:40:43.920 --> 00:40:46.860
And then obviously, there's a
book that came out about Kotlin

00:40:46.860 --> 00:40:49.397
recently, and I would
encourage you to read it.

00:40:49.397 --> 00:40:50.730
That's all I have for you today.

00:40:50.730 --> 00:40:53.220
There's no time for questions,
but we'll be outside

00:40:53.220 --> 00:40:54.700
after this presentation.

00:40:54.700 --> 00:40:55.200
Thank you.

00:40:55.200 --> 00:40:56.830
[APPLAUSE]

00:40:56.830 --> 00:40:59.747
SPEAKER: Thank you for
joining this session.

00:40:59.747 --> 00:41:06.376
[MUSIC PLAYING]

