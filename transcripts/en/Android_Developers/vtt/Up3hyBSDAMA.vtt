WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:03.388
[MUSIC PLAYING]

00:00:04.840 --> 00:00:06.530
SAM LIN: Good
afternoon, everyone.

00:00:06.530 --> 00:00:09.100
Welcome to Android
Emulator Section.

00:00:09.100 --> 00:00:10.610
My name is Sam Lin.

00:00:10.610 --> 00:00:13.960
I'm a product manager in
Android Emulator Team.

00:00:13.960 --> 00:00:16.840
Join me onstage
are Frank and Hoyt.

00:00:20.480 --> 00:00:23.090
How many people here have
been using Android Emulator?

00:00:23.090 --> 00:00:24.500
Show me your hands.

00:00:24.500 --> 00:00:27.110
Wow, that's great.

00:00:27.110 --> 00:00:28.610
Good to see you guys here.

00:00:28.610 --> 00:00:30.770
Today we're going to tell
you about a new feature

00:00:30.770 --> 00:00:32.630
and to show you a few use case.

00:00:32.630 --> 00:00:36.890
Hopefully that will
inspire you a new way

00:00:36.890 --> 00:00:41.660
to using Android Emulator to
improve your productivity.

00:00:41.660 --> 00:00:43.840
If you haven't using Android
Emulator, the first tip

00:00:43.840 --> 00:00:46.490
for you, you can download
Android Studio today and try it

00:00:46.490 --> 00:00:46.990
out.

00:00:50.410 --> 00:00:54.580
Android Emulator has always been
part of SDK from version one.

00:00:54.580 --> 00:00:57.700
Can you believe it is
already 11 years ago?

00:00:57.700 --> 00:01:00.140
I still remember my
first Android app.

00:01:00.140 --> 00:01:02.440
I powered it with SDK 1.5.

00:01:02.440 --> 00:01:06.010
Back then, Android
Emulator was slow.

00:01:06.010 --> 00:01:09.910
I end up need to using a
lot of physical device.

00:01:09.910 --> 00:01:12.840
But, in the past few years,
we have been systematically

00:01:12.840 --> 00:01:14.530
improved Android Emulator.

00:01:17.960 --> 00:01:20.720
Three years ago, we'd
review the foundation

00:01:20.720 --> 00:01:23.830
to make it much, much faster
and add a bunch of feature,

00:01:23.830 --> 00:01:28.080
so it's easier for you to
test application with it.

00:01:28.080 --> 00:01:31.200
Two years ago, we add the
Google Play Store support,

00:01:31.200 --> 00:01:35.370
so you can actually test your
application distribution flow

00:01:35.370 --> 00:01:37.580
end to end.

00:01:37.580 --> 00:01:39.830
Last year, we add the snapshot.

00:01:39.830 --> 00:01:42.790
You can literally easily switch
between different systems' tech

00:01:42.790 --> 00:01:46.420
to help you do
different tasks quickly.

00:01:46.420 --> 00:01:50.420
And this year, we add
the foldable support.

00:01:50.420 --> 00:01:53.660
You can start to help
user to unfold the future

00:01:53.660 --> 00:01:56.830
with your application.

00:01:56.830 --> 00:01:59.650
With all those changes,
we are actually

00:01:59.650 --> 00:02:01.900
focused on three key principle.

00:02:01.900 --> 00:02:04.260
The first one is fast.

00:02:04.260 --> 00:02:07.060
A good emulator should be
fast so we can actually

00:02:07.060 --> 00:02:09.479
get things done quickly.

00:02:09.479 --> 00:02:14.200
The second one, a good emulator
shall be high fidelity,

00:02:14.200 --> 00:02:16.230
which it mean you can
test application just

00:02:16.230 --> 00:02:19.360
like using physical device.

00:02:19.360 --> 00:02:23.070
Finally, a good emulator
can be versatile,

00:02:23.070 --> 00:02:25.680
so we can actually help you
finish different kinds of task

00:02:25.680 --> 00:02:28.530
quickly.

00:02:28.530 --> 00:02:32.250
At Google, we believe
faster is better than slow.

00:02:32.250 --> 00:02:34.850
That's why we start
making Android

00:02:34.850 --> 00:02:38.920
Emulator fast to save you time.

00:02:38.920 --> 00:02:42.060
So how do we know
something is fast?

00:02:42.060 --> 00:02:45.130
Obvious, UI is a big part
of it, because nobody

00:02:45.130 --> 00:02:48.390
likes using jenky
UI, we're using this

00:02:48.390 --> 00:02:50.670
to make sure our department.

00:02:50.670 --> 00:02:54.290
This is I'll show you how
many frame per second a device

00:02:54.290 --> 00:02:57.970
can draw when they run
the benchmark application.

00:02:57.970 --> 00:03:02.400
As you can see, Android Emulator
is slightly faster than Pixel 2

00:03:02.400 --> 00:03:06.390
XL, which mean running
application on Android Emulator

00:03:06.390 --> 00:03:08.250
is pretty fast now.

00:03:08.250 --> 00:03:12.270
In case you're curious, I using
the notebook have a core quad

00:03:12.270 --> 00:03:18.350
CPU, 16 gig of RAM, fresh
storage, and a good GPU.

00:03:18.350 --> 00:03:23.160
Frank, can you tell us how we
made Android Emulator fast?

00:03:23.160 --> 00:03:25.610
LINFENG "FRANK"
YANG: Sure can, Sam.

00:03:25.610 --> 00:03:28.010
So, to start out with,
the biggest thing

00:03:28.010 --> 00:03:31.760
that's changed about the Android
Emulator versus the emulator

00:03:31.760 --> 00:03:34.910
from many years
back is we stopped

00:03:34.910 --> 00:03:37.010
translating every
single instruction

00:03:37.010 --> 00:03:40.880
of the guest operating
system to x86 one at a time.

00:03:40.880 --> 00:03:42.890
So what used to be
the case that you

00:03:42.890 --> 00:03:48.290
ran an arm Android guest
operating system on an x86 host

00:03:48.290 --> 00:03:51.590
machine, and that
required the emulator

00:03:51.590 --> 00:03:53.330
to look at every
single instruction

00:03:53.330 --> 00:03:55.340
and decode them while
translating them

00:03:55.340 --> 00:03:57.530
to x86 equivalence.

00:03:57.530 --> 00:04:00.230
And this is actually
how most emulators

00:04:00.230 --> 00:04:03.230
work these days because of
this architectural mismatch

00:04:03.230 --> 00:04:06.590
between the guest operating
system's CPU architecture

00:04:06.590 --> 00:04:09.480
and the host CPU architecture.

00:04:09.480 --> 00:04:11.250
But with the Android
emulator, we've

00:04:11.250 --> 00:04:13.980
decided to run x86 on x86.

00:04:13.980 --> 00:04:17.010
And that gives you a
really powerful technology,

00:04:17.010 --> 00:04:21.269
CPU virtualization, which is
a set of hardware extensions

00:04:21.269 --> 00:04:25.740
for your CPU that let you
simply direct your computer

00:04:25.740 --> 00:04:28.590
and run the Android
guest operating system's

00:04:28.590 --> 00:04:34.070
code directly with
almost no translation.

00:04:34.070 --> 00:04:36.530
So these technologies
are called hypervisors,

00:04:36.530 --> 00:04:41.610
and we use HAXM on Windows,
or Windows Hypervisor Platform

00:04:41.610 --> 00:04:44.600
if you want to run with
Hyper-V. And on Mac we

00:04:44.600 --> 00:04:48.740
use Mac OS Hypervisor Framework,
and on Linux we use KVM.

00:04:48.740 --> 00:04:51.530
So this lets you run the
Android guest operating

00:04:51.530 --> 00:04:56.540
system with nearly the same
CPU performance as your host

00:04:56.540 --> 00:04:58.160
machine.

00:04:58.160 --> 00:05:02.600
Next, Android, to give a
brief bit of background,

00:05:02.600 --> 00:05:06.170
does almost all of its hardware
rendering operations using

00:05:06.170 --> 00:05:09.910
the OpenGL ES or Vulcan APIs.

00:05:09.910 --> 00:05:14.020
Previously we used to
run these graphics APIs

00:05:14.020 --> 00:05:18.370
in the Android guest operating
system using the CPU to render,

00:05:18.370 --> 00:05:21.640
while these APIs are meant to
be used with hardware GPUs.

00:05:21.640 --> 00:05:25.570
However, hardware GPUs
is now the default

00:05:25.570 --> 00:05:27.340
setting for the Android
Emulator and has

00:05:27.340 --> 00:05:30.040
been for quite some
time, and we've recently

00:05:30.040 --> 00:05:33.710
started supporting the
Vulcan and OpenGL ES 3.1

00:05:33.710 --> 00:05:38.650
APIs in Android Q. We do this
by leveraging GPU virtualization

00:05:38.650 --> 00:05:43.060
techniques that let you use
the full power of your host GPU

00:05:43.060 --> 00:05:46.530
in order to run
Android Emulator.

00:05:46.530 --> 00:05:47.460
SAM LIN: That's great

00:05:47.460 --> 00:05:48.690
LINFENG "FRANK" YANG: Thanks.

00:05:48.690 --> 00:05:52.610
SAM LIN: So during the
development process,

00:05:52.610 --> 00:05:55.200
you actually interact with
Android device quite often.

00:05:55.200 --> 00:05:56.700
For example, you're
testing the app,

00:05:56.700 --> 00:05:58.980
and you're installing
application.

00:05:58.980 --> 00:06:02.750
All those interaction is
basically done by Android Debug

00:06:02.750 --> 00:06:05.990
Bridge to help
you transform data

00:06:05.990 --> 00:06:09.620
from the computer
to Android device.

00:06:09.620 --> 00:06:11.270
The way to measure
this performance,

00:06:11.270 --> 00:06:13.220
you can easily done by
pushing the application

00:06:13.220 --> 00:06:16.490
or file to Android device.

00:06:16.490 --> 00:06:20.240
On this chart, we show you
Android Emulator can actually

00:06:20.240 --> 00:06:22.850
doing this much, much faster.

00:06:22.850 --> 00:06:26.690
Frank, can you show
us why it is that?

00:06:26.690 --> 00:06:28.040
LINFENG "FRANK" YANG: Sure.

00:06:28.040 --> 00:06:31.140
So if you're using-- oh,
go back to the slides?

00:06:31.140 --> 00:06:31.640
Sure.

00:06:31.640 --> 00:06:34.820
If you're using a
real device, you often

00:06:34.820 --> 00:06:37.250
need to connect it with USB.

00:06:37.250 --> 00:06:40.590
And USB contains a few
complications here and there.

00:06:40.590 --> 00:06:45.450
So you'll need a USB cable
upon USB cables, USB 2 or 3,

00:06:45.450 --> 00:06:49.880
USB drivers that work well with
your Mac OS or Windows system,

00:06:49.880 --> 00:06:53.270
especially, and
depending on your device,

00:06:53.270 --> 00:06:55.460
it may or may not support
the latest and greatest

00:06:55.460 --> 00:06:57.360
USB protocols that are fast.

00:06:57.360 --> 00:06:59.030
Now if you're
using the emulator,

00:06:59.030 --> 00:07:01.370
everything takes place
on your host machine.

00:07:01.370 --> 00:07:04.700
All of your adb pushes and
all that, they basically

00:07:04.700 --> 00:07:08.910
talk through a virtual TCP
connection over shared memory.

00:07:08.910 --> 00:07:13.130
So you're essentially limited
by your host machine's disk IO

00:07:13.130 --> 00:07:15.530
when you're transferring
files over adb.

00:07:15.530 --> 00:07:20.230
So that's why we can get
adb push to be so fast.

00:07:20.230 --> 00:07:21.660
SAM LIN: That's great.

00:07:21.660 --> 00:07:24.040
With that performance
advantage, you can actually

00:07:24.040 --> 00:07:25.250
get things done faster.

00:07:25.250 --> 00:07:27.460
For example, when you
installed application,

00:07:27.460 --> 00:07:30.720
this I'll show you,
emulator is actually

00:07:30.720 --> 00:07:33.090
faster for a simple application.

00:07:33.090 --> 00:07:36.000
Of course, if your
application is much bigger,

00:07:36.000 --> 00:07:39.880
Android Emulator will
save you more time.

00:07:39.880 --> 00:07:42.000
We also know you normally
do quite a lot of things

00:07:42.000 --> 00:07:44.670
on your computer, and
sometimes you just

00:07:44.670 --> 00:07:49.690
need to close Android Emulator
to do some other things.

00:07:49.690 --> 00:07:51.993
But for Android to
pull up, you actually

00:07:51.993 --> 00:07:53.410
take [INAUDIBLE]
for our sequence,

00:07:53.410 --> 00:07:54.910
which you can take for a while.

00:07:54.910 --> 00:07:57.250
That's why we add
Quick Boot, which

00:07:57.250 --> 00:08:00.547
will resume Android
Emulator in a few seconds.

00:08:00.547 --> 00:08:01.630
Switch it to demo, please.

00:08:04.877 --> 00:08:06.460
LINGFENG "FRANK"
YANG: Thanks, so I'll

00:08:06.460 --> 00:08:08.710
show you the difference
between a normal boot up

00:08:08.710 --> 00:08:10.540
of the device and the Emulator.

00:08:10.540 --> 00:08:13.200
So with this AVD
called Cold Boot,

00:08:13.200 --> 00:08:15.610
you can select Cold
Boot right now.

00:08:15.610 --> 00:08:17.770
And you see this black
screen here called,

00:08:17.770 --> 00:08:19.270
Boot Selected by User.

00:08:19.270 --> 00:08:22.000
And I guess, we gotta
wait for a while

00:08:22.000 --> 00:08:23.490
before a Google logo comes up.

00:08:23.490 --> 00:08:26.680
But we have this other
AVD called Quick Boot,

00:08:26.680 --> 00:08:28.150
where you just press Play.

00:08:28.150 --> 00:08:30.430
I have a previous
snapshot saved here.

00:08:30.430 --> 00:08:33.669
And it's able to just
come up right away,

00:08:33.669 --> 00:08:35.409
while the other
Emulator is still

00:08:35.409 --> 00:08:38.450
in the middle of
its boot-up cycle.

00:08:38.450 --> 00:08:44.100
And the Quick Boot Emulator is
already interactive right away.

00:08:44.100 --> 00:08:48.750
So this makes it really easy to
set your device in some state.

00:08:48.750 --> 00:08:50.930
Now, you need some more
resources or whatever--

00:08:50.930 --> 00:08:52.100
you close the Emulator.

00:08:52.100 --> 00:08:54.680
And you launch it
again really quickly.

00:08:54.680 --> 00:08:58.100
Also, this is our most
heavyweight hardware profile--

00:08:58.100 --> 00:08:59.380
the 8-inch Foldable.

00:08:59.380 --> 00:09:01.550
And it was able to
launch in much less time

00:09:01.550 --> 00:09:05.240
than a cold boot, using
our snapshots technology.

00:09:05.240 --> 00:09:07.485
Thanks-- back to the slides.

00:09:07.485 --> 00:09:08.610
SAM LIN: Wow, that's great.

00:09:13.500 --> 00:09:15.830
We also tried to look
at what kind of things

00:09:15.830 --> 00:09:19.060
Android Emulator can do
faster than a physical device.

00:09:19.060 --> 00:09:22.020
For example, our friends
on AR core team--

00:09:22.020 --> 00:09:25.600
they love using Android Emulator
to test their application.

00:09:25.600 --> 00:09:27.180
But just like me, they are lazy.

00:09:27.180 --> 00:09:29.550
They don't want to do
manual tests every time

00:09:29.550 --> 00:09:31.200
they change an application.

00:09:31.200 --> 00:09:34.410
That's why they add a new
feature called AR Micro.

00:09:34.410 --> 00:09:37.540
This allows you to
playback a preset breaker.

00:09:37.540 --> 00:09:41.150
So you can do sanity tests
quickly and precisely.

00:09:41.150 --> 00:09:42.240
Switch to demo, please.

00:09:46.042 --> 00:09:47.500
LINGFENG "FRANK"
YANG: Thanks, Sam.

00:09:47.500 --> 00:09:49.990
So for those of you who
went to the keynote today,

00:09:49.990 --> 00:09:52.390
there were some really
cool AR demos, right?

00:09:52.390 --> 00:09:56.590
And it kind of looked
like you really needed

00:09:56.590 --> 00:10:00.400
a real physical device in order
to develop and test AR apps.

00:10:00.400 --> 00:10:03.730
However, on the Emulator, we've
been working with the AR core

00:10:03.730 --> 00:10:06.860
team to enable you
to test and develop

00:10:06.860 --> 00:10:12.400
AR core apps without
needing a physical device.

00:10:12.400 --> 00:10:14.840
We call this the
Virtual Scene camera.

00:10:14.840 --> 00:10:16.330
It is a virtual
camera device that

00:10:16.330 --> 00:10:19.170
exposes a virtual environment.

00:10:19.170 --> 00:10:21.490
This virtual
environment has textures

00:10:21.490 --> 00:10:24.820
that can be picked up by
AR core tracking algorithms

00:10:24.820 --> 00:10:30.340
and, thus, can function largely
to the needs of your AR core

00:10:30.340 --> 00:10:31.960
application.

00:10:31.960 --> 00:10:37.240
But recently, we've added a
feature called AR Core Macros.

00:10:37.240 --> 00:10:39.880
This is because, when you're
running this virtual scene

00:10:39.880 --> 00:10:43.870
camera, you might end up doing a
lot of repetitive motions like,

00:10:43.870 --> 00:10:46.730
maybe, resetting to
their initial position--

00:10:46.730 --> 00:10:49.090
which we can do now
with a button press--

00:10:49.090 --> 00:10:52.570
or tracking a horizontal
plane, in order

00:10:52.570 --> 00:10:54.820
to get the tracking
plane to show up,

00:10:54.820 --> 00:10:57.490
so we can place
your AR core models.

00:10:57.490 --> 00:11:00.580
Notice that, while the
playback is going on,

00:11:00.580 --> 00:11:03.310
the camera is changing
its viewpoint according

00:11:03.310 --> 00:11:05.230
to the macro's instructions.

00:11:05.230 --> 00:11:08.170
And while that is going on,
all the right sensor signals

00:11:08.170 --> 00:11:11.890
are sent to the guest so that
your app will think that it's

00:11:11.890 --> 00:11:14.560
in a real environment.

00:11:14.560 --> 00:11:18.430
Thanks-- now back to the slides.

00:11:18.430 --> 00:11:19.870
[APPLAUSE]

00:11:19.870 --> 00:11:22.280
SAM LIN: Thank you.

00:11:22.280 --> 00:11:24.295
I think I want to
add on that one.

00:11:24.295 --> 00:11:25.670
If you look at
the mobile device,

00:11:25.670 --> 00:11:27.590
the powerful mobile
devices actually

00:11:27.590 --> 00:11:28.900
interact with the world.

00:11:28.900 --> 00:11:31.780
That means you need to do
a lot of tasks manually.

00:11:31.780 --> 00:11:35.300
And we try to explore if Android
Emulator can help you on that.

00:11:35.300 --> 00:11:39.770
This is just a starting point.

00:11:39.770 --> 00:11:41.330
In the past few
months, we have been

00:11:41.330 --> 00:11:46.340
working on [INAUDIBLE] mobile,
which polish Android Emulator.

00:11:46.340 --> 00:11:49.500
In the new release, we actually
improved the efficiency

00:11:49.500 --> 00:11:50.780
for Android Emulator.

00:11:50.780 --> 00:11:54.000
For example, when device
is on the Charger mode,

00:11:54.000 --> 00:11:56.030
Play Store can
automatically update

00:11:56.030 --> 00:11:59.430
application, whenever there's
a new version available.

00:11:59.430 --> 00:12:01.370
This is actually one
of the key reasons

00:12:01.370 --> 00:12:04.190
Android Emulator
attacking a lot of CPU and

00:12:04.190 --> 00:12:10.220
consume a lot of power, as you
can see on the chart right now.

00:12:10.220 --> 00:12:13.890
To avoid this, the team actually
properly enabled the Battery

00:12:13.890 --> 00:12:17.390
mode by default, which
will eliminate Application

00:12:17.390 --> 00:12:19.670
Auto-Update and the
background tasks,

00:12:19.670 --> 00:12:21.280
as you can see-- that blue line.

00:12:23.752 --> 00:12:25.210
But don't worry,
you can still turn

00:12:25.210 --> 00:12:28.030
on Application Auto-Update,
whenever you like it.

00:12:28.030 --> 00:12:30.210
Just switch to AC mode.

00:12:30.210 --> 00:12:33.790
Now, let me hand this over
to Hoi to tell you more.

00:12:33.790 --> 00:12:34.790
HOI LAM: Thank you, Sam.

00:12:38.020 --> 00:12:40.090
so we have just talked
about-- how do we make

00:12:40.090 --> 00:12:42.280
the Emulator nice and fast?

00:12:42.280 --> 00:12:44.860
The next thing that we
need in an Emulator is--

00:12:44.860 --> 00:12:47.140
well, actually, we
need to trust it.

00:12:47.140 --> 00:12:49.420
Otherwise, there is
very little point in you

00:12:49.420 --> 00:12:51.820
testing anything
on the Emulator.

00:12:51.820 --> 00:12:54.040
So the team have
done a lot of work

00:12:54.040 --> 00:12:58.690
to make sure that the behavior
of the Emulator is the same

00:12:58.690 --> 00:13:01.100
or very similar to
the physical device.

00:13:01.100 --> 00:13:03.070
So what are the three
things that we have done?

00:13:03.070 --> 00:13:05.270
Let's go through them.

00:13:05.270 --> 00:13:07.630
The first thing is-- we
start off with the same code

00:13:07.630 --> 00:13:10.460
base as a physical device.

00:13:10.460 --> 00:13:12.620
And when we say,
the same code base,

00:13:12.620 --> 00:13:14.240
we don't mean half a stack.

00:13:14.240 --> 00:13:16.330
We mean the whole stack.

00:13:16.330 --> 00:13:20.280
And that includes the hardware
abstraction layer, as well as

00:13:20.280 --> 00:13:22.670
the Linux kernel.

00:13:22.670 --> 00:13:26.660
In addition, as Sam and
Frank mentioned earlier,

00:13:26.660 --> 00:13:30.320
we have made it super fast
for Windows, Mac, and Linux,

00:13:30.320 --> 00:13:33.040
by paying a lot of
attention to performance,

00:13:33.040 --> 00:13:36.470
so that you can get the
same feel using the Emulator

00:13:36.470 --> 00:13:39.380
as the physical device.

00:13:39.380 --> 00:13:41.630
So OK-- fine.

00:13:41.630 --> 00:13:43.320
You've done the code.

00:13:43.320 --> 00:13:48.690
But as all good
developers do, we test it.

00:13:48.690 --> 00:13:54.770
So we are now running over
900,000 compatibility tests.

00:13:54.770 --> 00:13:56.870
And these are the
same tests that

00:13:56.870 --> 00:14:00.740
pass with your physical phone.

00:14:00.740 --> 00:14:03.080
So your physical phone
passed these tests.

00:14:03.080 --> 00:14:05.590
And the Emulator
passed the same tests.

00:14:05.590 --> 00:14:06.470
And you might go--

00:14:06.470 --> 00:14:10.780
yeah, Hoi--
900,000-- big number.

00:14:10.780 --> 00:14:12.220
What does it actually mean?

00:14:12.220 --> 00:14:13.990
Can you give me a
concrete example

00:14:13.990 --> 00:14:17.380
where this makes a difference?

00:14:17.380 --> 00:14:20.310
So this is one of the tests
that the previous generation

00:14:20.310 --> 00:14:22.540
of the Android
Emulator had failed.

00:14:22.540 --> 00:14:26.520
When you're displaying a YUV
image, instead of displaying

00:14:26.520 --> 00:14:30.180
the Blue-128,
actually, we sneakily

00:14:30.180 --> 00:14:35.800
fit in Blue-132 and hope
that you didn't notice.

00:14:35.800 --> 00:14:38.650
Well, you may not notice
it from this screen.

00:14:38.650 --> 00:14:41.840
But your integration test would.

00:14:41.840 --> 00:14:46.060
And a lot of integration tests
actually fail because of this.

00:14:46.060 --> 00:14:47.410
And why is that?

00:14:47.410 --> 00:14:50.470
When we go through the code
base, these kinds of things

00:14:50.470 --> 00:14:51.760
were in it.

00:14:51.760 --> 00:14:55.390
We basically run one set of
code if it is a physical device.

00:14:55.390 --> 00:14:57.580
And we run a completely
different set of code

00:14:57.580 --> 00:15:00.220
if it is running
in the Emulator.

00:15:00.220 --> 00:15:03.820
So the team worked diligently
and went through all the code

00:15:03.820 --> 00:15:08.060
color within Android, to
take these kind of codes out.

00:15:08.060 --> 00:15:09.130
So the result is--

00:15:09.130 --> 00:15:12.520
when you specify
Blue-128, you can be sure

00:15:12.520 --> 00:15:17.540
that it is giving you Blue-128.

00:15:17.540 --> 00:15:21.980
And if this doesn't convince
you, maybe this date will.

00:15:21.980 --> 00:15:25.490
From the 1st of
August 2019, as we all

00:15:25.490 --> 00:15:29.240
know, when you're submitting a
new or update app to the Google

00:15:29.240 --> 00:15:33.900
Play Store, you will need
to submit a 64-bit version.

00:15:33.900 --> 00:15:37.020
And if you haven't got a
64-bit device to hand--

00:15:37.020 --> 00:15:41.210
well, the Android
Emulator is your friend.

00:15:41.210 --> 00:15:42.450
Woo-hoo!

00:15:42.450 --> 00:15:45.510
So we have done testing.

00:15:45.510 --> 00:15:47.430
We've done our code base.

00:15:47.430 --> 00:15:49.320
How about things
that you'd normally

00:15:49.320 --> 00:15:52.573
find on a physical phone?

00:15:52.573 --> 00:15:53.990
The team have done
such a good job

00:15:53.990 --> 00:15:57.680
that Google Play Store
actually now trusts us to,

00:15:57.680 --> 00:16:00.525
basically, put the
store on our phone.

00:16:00.525 --> 00:16:02.150
And what this means
is you can actually

00:16:02.150 --> 00:16:05.600
truly test the app end-to-end--
not just installing it

00:16:05.600 --> 00:16:08.510
and run through the
flow within your app

00:16:08.510 --> 00:16:12.860
but through all the things that
are around the app as well.

00:16:12.860 --> 00:16:15.260
So a typical end-to-end
testing scenario

00:16:15.260 --> 00:16:21.170
might start with an ad on
a website on another app.

00:16:21.170 --> 00:16:23.900
When you click through,
it will actually take you

00:16:23.900 --> 00:16:25.580
to the Google Play Store.

00:16:25.580 --> 00:16:28.490
And you can install
the app right there.

00:16:28.490 --> 00:16:31.280
After that, you can
sign in with your Google

00:16:31.280 --> 00:16:33.740
account or any of
the social networks

00:16:33.740 --> 00:16:35.870
that your app may support.

00:16:35.870 --> 00:16:38.150
Because you can now install
those social network

00:16:38.150 --> 00:16:41.390
apps on the Emulator.

00:16:41.390 --> 00:16:43.280
If your app supports
in-app purchase,

00:16:43.280 --> 00:16:46.580
you can also test in-app
purchase in the Emulator

00:16:46.580 --> 00:16:48.450
itself.

00:16:48.450 --> 00:16:51.980
And last but not least, all of
us want our apps to go viral.

00:16:51.980 --> 00:16:55.700
You can now share your
app within the Emulator

00:16:55.700 --> 00:16:59.370
and test their flow as well.

00:16:59.370 --> 00:17:02.730
So this is truly
end-to-end testing.

00:17:02.730 --> 00:17:03.820
Woo-hoo!

00:17:03.820 --> 00:17:05.089
We heard a couple of claps.

00:17:05.089 --> 00:17:06.913
[APPLAUSE]

00:17:09.650 --> 00:17:11.920
Excellent.

00:17:11.920 --> 00:17:14.722
So we have built the
Emulator super fast.

00:17:14.722 --> 00:17:16.930
And hopefully, we'll have
convinced you as, you know,

00:17:16.930 --> 00:17:20.710
we've done a lot work in getting
back your trust on the fidelity

00:17:20.710 --> 00:17:22.670
of the Emulator.

00:17:22.670 --> 00:17:26.460
How about-- how does it
actually fit into your workflow?

00:17:26.460 --> 00:17:29.420
So let's talk about the
versatility of the Emulator

00:17:29.420 --> 00:17:31.120
itself.

00:17:31.120 --> 00:17:35.620
My own personal favorite
feature is Snapshots.

00:17:35.620 --> 00:17:37.660
How many of you have
basically installed

00:17:37.660 --> 00:17:40.520
an app, run through the
flow, and then you realize--

00:17:40.520 --> 00:17:43.040
oh, actually, I need
to test it again!

00:17:43.040 --> 00:17:44.950
Which means
uninstalling your app

00:17:44.950 --> 00:17:47.710
and then, basically, reset
up the entire thing again.

00:17:47.710 --> 00:17:50.050
Show me your hands.

00:17:50.050 --> 00:17:51.100
Yay!

00:17:51.100 --> 00:17:55.050
OK-- so this feature is for you.

00:17:55.050 --> 00:17:57.240
After you get done
all your setup steps,

00:17:57.240 --> 00:18:00.942
you can just tell the
Emulator to save a snapshot.

00:18:00.942 --> 00:18:02.400
And when you're
ready to test again

00:18:02.400 --> 00:18:05.740
from exactly that
particular point,

00:18:05.740 --> 00:18:08.610
you can just click
on the one button

00:18:08.610 --> 00:18:11.680
and basically get right
back to that point.

00:18:11.680 --> 00:18:13.290
Can we switch to
the laptop, please?

00:18:13.290 --> 00:18:15.900
And Frank will
demonstrate this for us.

00:18:15.900 --> 00:18:17.310
Over to you.

00:18:17.310 --> 00:18:18.820
LINGFENG "FRANK"
YANG: Thanks, Hoi.

00:18:18.820 --> 00:18:22.840
So I'm going to demonstrate this
little thing where oftentimes

00:18:22.840 --> 00:18:24.700
Snapshots can be useful
for when you want

00:18:24.700 --> 00:18:27.940
to put your device in
a particular state that

00:18:27.940 --> 00:18:30.010
is easy to get back to.

00:18:30.010 --> 00:18:32.530
This is especially
going to be an issue

00:18:32.530 --> 00:18:35.530
in new foldable devices,
where a split-screen may

00:18:35.530 --> 00:18:37.150
be more prominent.

00:18:37.150 --> 00:18:39.310
So to demonstrate a
split-screen first,

00:18:39.310 --> 00:18:41.180
I'll show you how to set it up.

00:18:41.180 --> 00:18:44.050
I'm going to start this
Multi-window Playground

00:18:44.050 --> 00:18:46.900
app that does different
things, depending

00:18:46.900 --> 00:18:48.430
on your split-screen settings.

00:18:48.430 --> 00:18:49.990
I'm going to activate
split-screen,

00:18:49.990 --> 00:18:54.500
by pressing the App icon
and selecting Split Screen.

00:18:54.500 --> 00:18:59.260
So, now, we have
another window pane

00:18:59.260 --> 00:19:03.440
in which we can potentially
launch a different application.

00:19:03.440 --> 00:19:05.422
Now, when you're testing
this multi-window app,

00:19:05.422 --> 00:19:06.880
one of the things
that might happen

00:19:06.880 --> 00:19:10.280
is you might launch an
un-resizeable activity.

00:19:10.280 --> 00:19:12.820
And now, when you
launch that, the system

00:19:12.820 --> 00:19:16.360
has no choice but to
cancel Split-Screen mode

00:19:16.360 --> 00:19:21.160
and put you in this Fixed-Aspect
Ratio mode right here.

00:19:21.160 --> 00:19:24.970
And now, if you want to
retest that original scenario,

00:19:24.970 --> 00:19:27.160
you need to click through
what I just did again.

00:19:27.160 --> 00:19:32.260
But with the Snapshots, once
you have saved your device

00:19:32.260 --> 00:19:37.600
in a state that you like,
you can click Play down here.

00:19:37.600 --> 00:19:39.700
And it will load the snapshot.

00:19:39.700 --> 00:19:42.120
And I guess it's still loading.

00:19:42.120 --> 00:19:45.520
But-- yeah.

00:19:45.520 --> 00:19:46.930
HOI LAM: That is live demo!

00:19:46.930 --> 00:19:48.097
LINGFENG "FRANK" YANG: Yeah.

00:19:48.097 --> 00:19:49.180
HOI LAM: Yay!

00:19:49.180 --> 00:19:49.680
[APPLAUSE]

00:19:49.680 --> 00:19:51.140
LINGFENG "FRANK"
YANG: So anyways--

00:19:51.140 --> 00:19:51.610
HOI LAM: OK-- it's there.

00:19:51.610 --> 00:19:52.430
LINGFENG "FRANK"
YANG: --you load it.

00:19:52.430 --> 00:19:55.300
And then it's in the state
that you were using before.

00:19:55.300 --> 00:20:00.200
And you can then pretty easily
set up many other states here

00:20:00.200 --> 00:20:04.040
and also change the name of
your snapshot and everything.

00:20:04.040 --> 00:20:05.200
So that's cool.

00:20:05.200 --> 00:20:06.830
All right-- back to slides.

00:20:06.830 --> 00:20:07.600
HOI LAM: Cool!

00:20:07.600 --> 00:20:09.370
Thank you, Frank.

00:20:09.370 --> 00:20:11.990
So in that scenario,
you might argue-- hey,

00:20:11.990 --> 00:20:13.050
it was just two steps.

00:20:13.050 --> 00:20:13.930
It split the screen.

00:20:13.930 --> 00:20:17.620
But as many of you who have
raised your hand before--

00:20:17.620 --> 00:20:19.840
you might spend five
minutes setting up

00:20:19.840 --> 00:20:23.170
your app to a particular
state before you go on a test.

00:20:23.170 --> 00:20:25.900
And what I usually do as
well is I will actually

00:20:25.900 --> 00:20:30.010
run through the flow of my
app and pick several snapshots

00:20:30.010 --> 00:20:33.850
along the way, which saves
me a ton of time when

00:20:33.850 --> 00:20:35.860
I want to retest a
particular bug fix

00:20:35.860 --> 00:20:40.170
or when I want to just add a new
feature at a particular place.

00:20:40.170 --> 00:20:43.190
And I can go right back in.

00:20:43.190 --> 00:20:45.943
So a performance snapshot--

00:20:45.943 --> 00:20:47.360
and we have done
a lot of testing.

00:20:47.360 --> 00:20:49.170
So now is your turn.

00:20:49.170 --> 00:20:51.280
And what's better than
running one test?--

00:20:51.280 --> 00:20:55.940
running multiple tests
at the same time.

00:20:55.940 --> 00:20:58.540
So another feature that the
Android Emulator supports

00:20:58.540 --> 00:21:02.320
is having multiple instances
running different tests

00:21:02.320 --> 00:21:04.270
at the same time.

00:21:04.270 --> 00:21:08.080
Another way that I use this
is to test the same app

00:21:08.080 --> 00:21:11.060
on different screen
configurations.

00:21:11.060 --> 00:21:15.020
And this doesn't just work
for the phone form factor.

00:21:15.020 --> 00:21:19.950
It also works for large
screen and foldables as well.

00:21:19.950 --> 00:21:23.540
And another thing
about the Emulator is--

00:21:23.540 --> 00:21:25.910
quite often, you have
different devices

00:21:25.910 --> 00:21:28.340
available in
different geographies.

00:21:28.340 --> 00:21:30.410
And, in this particular
case, foldable

00:21:30.410 --> 00:21:33.050
is actually pretty
hard to get, even when

00:21:33.050 --> 00:21:35.910
you're working in Google.

00:21:35.910 --> 00:21:39.650
So what happened with the
foldable at a moment is--

00:21:39.650 --> 00:21:43.160
I have to say, my first
taste of foldable and testing

00:21:43.160 --> 00:21:45.530
my own app on
foldable is actually

00:21:45.530 --> 00:21:47.360
on the Android Emulator.

00:21:47.360 --> 00:21:50.910
So I strongly encourage
you to take a look.

00:21:50.910 --> 00:21:52.740
And I'm sure that you
have got many more

00:21:52.740 --> 00:21:54.780
questions about
this new form factor

00:21:54.780 --> 00:21:56.940
and also the larger screen apps.

00:21:56.940 --> 00:21:59.160
So we have got a
special session today

00:21:59.160 --> 00:22:04.020
at 5:00 PM, where you can
check out the latest best

00:22:04.020 --> 00:22:06.930
practice about building for
foldable and large screen.

00:22:06.930 --> 00:22:10.940
I strongly recommend that
you attend that session.

00:22:10.940 --> 00:22:14.510
So we test-- different tests,
running at the same time.

00:22:14.510 --> 00:22:17.430
We have different screen
configuration tests.

00:22:17.430 --> 00:22:20.060
What about other things you
can do with multiple instances

00:22:20.060 --> 00:22:22.250
of the Emulator?

00:22:22.250 --> 00:22:24.050
Another one my
favorites is basically

00:22:24.050 --> 00:22:28.700
running different instances, but
running different API levels.

00:22:28.700 --> 00:22:31.610
I'm sure that a lot of you will
go through the Behavior Change

00:22:31.610 --> 00:22:36.020
page of every single Android
release and find out-- oh!

00:22:36.020 --> 00:22:37.430
You have changed this.

00:22:37.430 --> 00:22:39.290
Let me test that.

00:22:39.290 --> 00:22:45.030
This makes it super easy to
test at different API levels,

00:22:45.030 --> 00:22:49.010
such as, in this example, the
straight screens have been

00:22:49.010 --> 00:22:52.820
changed in Android Q.
So you can now test it

00:22:52.820 --> 00:22:58.250
right next to an Emulator.

00:22:58.250 --> 00:22:59.900
So Frank, can you
show us how this

00:22:59.900 --> 00:23:02.360
could be done with
different types of testing?

00:23:02.360 --> 00:23:03.610
LINGFENG "FRANK" YANG: Indeed.

00:23:03.610 --> 00:23:03.920
Well, let's switch to--

00:23:03.920 --> 00:23:04.340
HOI LAM: Let's switch
to the computer.

00:23:04.340 --> 00:23:05.840
LINGFENG "FRANK"
YANG: --the laptop.

00:23:07.060 --> 00:23:07.770
Thanks, Hoi.

00:23:07.770 --> 00:23:09.560
So there are many
different things

00:23:09.560 --> 00:23:12.710
that you can do with multiple
instances of Emulators.

00:23:12.710 --> 00:23:15.680
And there are
different Degrees So,

00:23:15.680 --> 00:23:19.370
the first one, which
we introduced recently,

00:23:19.370 --> 00:23:23.580
is a way to run more than
one instance of the same AVD.

00:23:23.580 --> 00:23:26.930
Note that previously, you needed
to create more than one AVD

00:23:26.930 --> 00:23:29.340
if you wanted to run more
than one Emulator in parallel.

00:23:29.340 --> 00:23:31.175
Well, now you don't have to.

00:23:31.175 --> 00:23:33.800
I have a terminal
open with a script

00:23:33.800 --> 00:23:37.470
to launch multiple
instances of the same AVD--

00:23:37.470 --> 00:23:40.670
called,
launch-multi-instance.sh.

00:23:40.670 --> 00:23:44.030
Now, you'll notice that this
command line is pretty typical,

00:23:44.030 --> 00:23:46.880
except for the fact that we
have this new command line

00:23:46.880 --> 00:23:47.750
flag here--

00:23:47.750 --> 00:23:48.950
read-only.

00:23:48.950 --> 00:23:52.672
And the AVD name is
the same in both cases.

00:23:52.672 --> 00:23:53.880
Now, why is this significant?

00:23:53.880 --> 00:23:57.560
Well, read-only
will essentially let

00:23:57.560 --> 00:24:00.470
you launch more than
one instance of an AVD

00:24:00.470 --> 00:24:02.700
at the same time.

00:24:02.700 --> 00:24:05.270
So when we launched a script,
it will launch both of them

00:24:05.270 --> 00:24:07.190
in the background.

00:24:07.190 --> 00:24:10.250
In addition, if you add
the read-only option

00:24:10.250 --> 00:24:12.770
and you're booting off
of a Quick Boot Snapshot,

00:24:12.770 --> 00:24:16.040
you're only going to restore
it to that previous snapshot

00:24:16.040 --> 00:24:19.630
and discard all of the changes
to the snapshot, once you exit.

00:24:19.630 --> 00:24:21.590
So once you launch
it again, you're

00:24:21.590 --> 00:24:23.127
going to be in the
same exact state

00:24:23.127 --> 00:24:25.460
that you started with when
you last saved the Quick Boot

00:24:25.460 --> 00:24:26.512
Snapshot.

00:24:26.512 --> 00:24:27.470
I will demonstrate now.

00:24:33.400 --> 00:24:36.540
So this is actually
two Emulators.

00:24:36.540 --> 00:24:38.790
And they're all
running independently.

00:24:38.790 --> 00:24:43.940
And if we look in, say--

00:24:43.940 --> 00:24:47.030
let's clear the
terminal adb devices--

00:24:47.030 --> 00:24:49.210
we have two devices.

00:24:49.210 --> 00:24:52.880
And we can run integration
tests, as if we actually

00:24:52.880 --> 00:24:54.810
had two devices.

00:24:54.810 --> 00:25:00.710
So for example, if I try to run
this instrumentation test here,

00:25:00.710 --> 00:25:02.799
the adb shell am instrument--

00:25:07.290 --> 00:25:12.720
it can run on parallel on
both devices at the same time.

00:25:12.720 --> 00:25:15.570
So one test is
running on one device,

00:25:15.570 --> 00:25:18.600
and a different test is
running on the other device.

00:25:18.600 --> 00:25:22.110
So you can get tests
starting pretty easily.

00:25:22.110 --> 00:25:24.990
One last thing to mention
about resuming these AVD

00:25:24.990 --> 00:25:28.260
clones from the same
snapshot is that their RAM

00:25:28.260 --> 00:25:29.850
is shared until it's written.

00:25:29.850 --> 00:25:31.470
It's called Copy on Write.

00:25:31.470 --> 00:25:34.200
So this is also using
less RAM than if you

00:25:34.200 --> 00:25:37.540
started two independent AVDs.

00:25:37.540 --> 00:25:40.690
So that's the same AVD instance.

00:25:40.690 --> 00:25:44.610
But what if you're testing
multiple screen configurations?

00:25:44.610 --> 00:25:52.140
Well, let's launch a normal
screen configuration and one

00:25:52.140 --> 00:25:53.385
of the new foldable ones.

00:25:56.580 --> 00:26:02.322
OK-- let's see--

00:26:02.322 --> 00:26:06.655
and if we run the Santa
Tracker in the Emulator

00:26:06.655 --> 00:26:08.030
with normal screen
configuration,

00:26:08.030 --> 00:26:10.620
it comes up with a
particular layout.

00:26:10.620 --> 00:26:14.930
However, if you launch the
foldable Emulator and then,

00:26:14.930 --> 00:26:19.190
inside that Emulator,
you launch the same app,

00:26:19.190 --> 00:26:22.490
you can often get
a different layout.

00:26:22.490 --> 00:26:26.630
So running multiple Emulator
screen configurations this way

00:26:26.630 --> 00:26:32.910
lets you really quickly test
multiple screen configurations.

00:26:32.910 --> 00:26:35.080
And since this is
a foldable device,

00:26:35.080 --> 00:26:38.290
I have to also demonstrate
the folding feature.

00:26:38.290 --> 00:26:41.040
So, with a foldable
device, the app layout

00:26:41.040 --> 00:26:44.340
will change a lot if
you fold and unfold.

00:26:44.340 --> 00:26:46.890
And so the foldable
virtual devices

00:26:46.890 --> 00:26:50.023
give you a quick
way to test this.

00:26:50.023 --> 00:26:51.940
All right-- so that's
for our different screen

00:26:51.940 --> 00:26:53.270
configurations.

00:26:53.270 --> 00:26:54.630
What about different API levels?

00:26:58.970 --> 00:27:02.840
In launch-sdk-compat, I will
be launching two Emulators.

00:27:02.840 --> 00:27:05.870
One of them is an API 27 Oreo.

00:27:05.870 --> 00:27:09.600
Another one is a Q image.

00:27:09.600 --> 00:27:12.410
So once we launch them--

00:27:12.410 --> 00:27:14.160
both of them are
in Read-Only mode.

00:27:14.160 --> 00:27:16.940
So once you can integrate
this into your CI pipeline,

00:27:16.940 --> 00:27:18.582
all the changes are
discarded on exit,

00:27:18.582 --> 00:27:20.540
so you can launch it the
same way the next time

00:27:20.540 --> 00:27:23.780
without wiping any data
or installing any apps

00:27:23.780 --> 00:27:25.940
or restoring any state.

00:27:25.940 --> 00:27:32.260
Anyways, let's see,
sharing shortcuts test.

00:27:32.260 --> 00:27:34.190
Test stat sharing
app that Hoi was

00:27:34.190 --> 00:27:38.360
showing earlier on both of
these API levels in parallel.

00:27:38.360 --> 00:27:41.660
And we can, indeed, get one
of the tests to fail and one

00:27:41.660 --> 00:27:45.570
of the tests to succeed,
depending on the API level.

00:27:45.570 --> 00:27:46.610
So there you have it--

00:27:46.610 --> 00:27:47.870
multiple instances.

00:27:47.870 --> 00:27:51.680
They will let you chart
your test with the same AVD,

00:27:51.680 --> 00:27:55.400
let you run multiple screen
configurations in parallel,

00:27:55.400 --> 00:27:59.345
and run tests on different
API levels in the same manner.

00:27:59.345 --> 00:28:00.470
All right-- back to slides.

00:28:00.470 --> 00:28:01.095
AUDIENCE: Whoo!

00:28:01.095 --> 00:28:01.910
HOI LAM: Yay!

00:28:01.910 --> 00:28:02.840
Isn't that fantastic?

00:28:02.840 --> 00:28:04.828
[APPLAUSE]

00:28:07.320 --> 00:28:09.780
So hopefully, we
have convinced you

00:28:09.780 --> 00:28:11.730
that you should
run all your tests

00:28:11.730 --> 00:28:13.550
collate multiple instances.

00:28:13.550 --> 00:28:15.600
Another way that
can really help is

00:28:15.600 --> 00:28:17.880
to run, actually, those
tests in a Headless mode,

00:28:17.880 --> 00:28:20.590
so you can save
even more memory.

00:28:20.590 --> 00:28:23.470
And by all accounts, you
save about 100 megabytes

00:28:23.470 --> 00:28:25.650
if you're running
it in Headless mode.

00:28:25.650 --> 00:28:27.060
Frank, can you show us?

00:28:27.060 --> 00:28:30.130
LINGFENG "FRANK" YANG: Indeed--
let's switch to the laptop.

00:28:30.130 --> 00:28:32.900
So one of the complaints
about the Emulator

00:28:32.900 --> 00:28:35.800
that we heard a
lot is how hard it

00:28:35.800 --> 00:28:39.820
was to deploy in many common
continuous integration

00:28:39.820 --> 00:28:41.860
containers' delivery pipelines.

00:28:41.860 --> 00:28:43.540
In the recent versions
of the Emulator,

00:28:43.540 --> 00:28:47.410
we tried to let take a hard look
at the Emulator's dependencies

00:28:47.410 --> 00:28:50.410
on the Linux system and
tried to strip down as many

00:28:50.410 --> 00:28:53.380
of them as possible,
starting with removing

00:28:53.380 --> 00:28:56.120
the usage of UI libraries.

00:28:56.120 --> 00:29:01.510
So we used to depend on things
like X-11, Pulsario, QT.

00:29:01.510 --> 00:29:03.400
But now, we give you
the option to run

00:29:03.400 --> 00:29:05.650
the Emulator in a
minimal-dependency headless

00:29:05.650 --> 00:29:06.680
field.

00:29:06.680 --> 00:29:10.270
So, in order to use
the Headless field--

00:29:10.270 --> 00:29:13.710
let's see-- q-p3-headless.sh.

00:29:16.690 --> 00:29:19.660
In recent Emulator versions, we
provided a new Emulator binary

00:29:19.660 --> 00:29:21.430
called Emulator-headless.

00:29:21.430 --> 00:29:24.880
What this is is the Emulator
that doesn't use any UI

00:29:24.880 --> 00:29:27.280
but still does all of the
rendering and everything else,

00:29:27.280 --> 00:29:29.920
just as the normal
Emulator would,

00:29:29.920 --> 00:29:33.340
so that you can get
high-fidelity results

00:29:33.340 --> 00:29:36.230
and easier to deploy.

00:29:36.230 --> 00:29:40.070
We explicitly list the libraries
on Linux that this depends on.

00:29:40.070 --> 00:29:42.890
There's only, like,
7 of them-- like,

00:29:42.890 --> 00:29:45.980
ld-so and various
essential things.

00:29:45.980 --> 00:29:48.070
So hopefully, we
this makes it easier

00:29:48.070 --> 00:29:51.760
for you to run CI
pipelines with Emulators.

00:29:51.760 --> 00:29:57.640
Launching this, you'll
notice that it's launched,

00:29:57.640 --> 00:30:00.300
but there is no UI.

00:30:00.300 --> 00:30:04.750
But, if we go back to
Studio, Lawcat is running.

00:30:04.750 --> 00:30:07.810
Everything in your tests
will behave as if there

00:30:07.810 --> 00:30:09.900
was a real device there still.

00:30:09.900 --> 00:30:12.280
You just have a
minimal footprint

00:30:12.280 --> 00:30:14.760
that is easier to deploy.

00:30:14.760 --> 00:30:16.090
All right-- thanks.

00:30:16.090 --> 00:30:16.830
Back to slides.

00:30:16.830 --> 00:30:17.621
[APPLAUSE]

00:30:17.621 --> 00:30:18.204
HOI LAM: Whoo!

00:30:21.870 --> 00:30:25.350
Let's go back to slides, please.

00:30:25.350 --> 00:30:27.380
And I'm sure that
a lot of you really

00:30:27.380 --> 00:30:29.750
want to find out-- what's
the latest best practice

00:30:29.750 --> 00:30:31.280
on building [INAUDIBLE] apps?

00:30:31.280 --> 00:30:33.530
So, on Thursday,
at 11:30, we have

00:30:33.530 --> 00:30:35.360
got another session for you.

00:30:35.360 --> 00:30:39.310
Please go there for
the latest information.

00:30:39.310 --> 00:30:41.740
So we've went through the
day-to-day development using

00:30:41.740 --> 00:30:45.150
Snapshot to having
multiple tests running--

00:30:45.150 --> 00:30:48.720
integration tests or maybe your
continuous integration system

00:30:48.720 --> 00:30:50.490
running them.

00:30:50.490 --> 00:30:53.910
OK-- so after your app launch--

00:30:53.910 --> 00:30:54.960
I am sorry.

00:30:54.960 --> 00:31:01.050
But in real life, the Android
Not Responsive and crashes,

00:31:01.050 --> 00:31:04.420
unfortunately, do happen.

00:31:04.420 --> 00:31:07.140
And one of the ways
that I use the Emulator

00:31:07.140 --> 00:31:11.700
is basically in conjunction
with the Google Play Console.

00:31:11.700 --> 00:31:13.253
So the Google Play Console--

00:31:13.253 --> 00:31:14.670
you will see the
different crashes

00:31:14.670 --> 00:31:17.250
or Android Not
Responsive being divided

00:31:17.250 --> 00:31:19.030
into different sections.

00:31:19.030 --> 00:31:22.460
One is, potentially,
your own app version.

00:31:22.460 --> 00:31:24.690
Another one is the
different devices

00:31:24.690 --> 00:31:27.840
that are experiencing
these kind of problems.

00:31:27.840 --> 00:31:30.590
And then third is the
different API levels.

00:31:30.590 --> 00:31:35.880
And you might also want to have
a look at the user feedback--

00:31:35.880 --> 00:31:37.770
whether positive or
negative-- depending

00:31:37.770 --> 00:31:39.550
on the device as well.

00:31:39.550 --> 00:31:43.300
And this is the kind of workflow
that I would go through.

00:31:43.300 --> 00:31:44.920
So the first thing
that we'd do is--

00:31:44.920 --> 00:31:46.640
I want to have a look at--

00:31:46.640 --> 00:31:48.400
are there any
particular device that

00:31:48.400 --> 00:31:53.660
is causing a lot of crashes or
Android not being responsive?

00:31:53.660 --> 00:31:57.720
And if it is, I would look up,
what is the screen density?

00:31:57.720 --> 00:31:58.920
Is it actually API?

00:31:58.920 --> 00:32:03.820
Or is other different
screen size or density?

00:32:03.820 --> 00:32:05.770
Once I get that, I
will launch an Emulator

00:32:05.770 --> 00:32:09.360
that matches that and
just do a sanity test.

00:32:09.360 --> 00:32:11.320
That's usually very quick--

00:32:11.320 --> 00:32:14.890
much, much faster than me
going down to the device lab

00:32:14.890 --> 00:32:18.330
and checking a device out.

00:32:18.330 --> 00:32:20.330
If it's not that, the
next thing that I would do

00:32:20.330 --> 00:32:23.900
is to look at the API level
and see whether the crashes is

00:32:23.900 --> 00:32:26.750
actually caused by
differences in behavior

00:32:26.750 --> 00:32:28.595
of the different API levels.

00:32:32.310 --> 00:32:37.310
While the Emulator, we think,
is of very high quality,

00:32:37.310 --> 00:32:38.920
there are always
instances where you

00:32:38.920 --> 00:32:42.227
do need to go back
to physical device.

00:32:42.227 --> 00:32:43.810
But, hopefully, what
we have done here

00:32:43.810 --> 00:32:45.580
in this session is
to convince you--

00:32:45.580 --> 00:32:47.740
the Emulator is
actually your first port

00:32:47.740 --> 00:32:51.160
of call in this diagnostic.

00:32:51.160 --> 00:32:53.290
And to hear more from
the Google Play team

00:32:53.290 --> 00:32:55.450
about how to use
the latest Android

00:32:55.450 --> 00:32:59.110
vitals to improve the quality
of your apps and games,

00:32:59.110 --> 00:33:01.750
on Thursday at 2:30,
we have a full session

00:33:01.750 --> 00:33:06.700
to go through all the new
features and existing features.

00:33:06.700 --> 00:33:08.440
So with that, let me
hand it back to Sam.

00:33:12.230 --> 00:33:14.610
SAM LIN: Thanks, Hoi and Frank.

00:33:14.610 --> 00:33:16.680
So that's a lot of
information to remember.

00:33:16.680 --> 00:33:19.200
And I bet you guys
remember it all, right?

00:33:19.200 --> 00:33:22.440
Just kidding-- so let's recap.

00:33:22.440 --> 00:33:24.780
First-- Android Emulator
is pretty fast now,

00:33:24.780 --> 00:33:27.610
so you can actually get
your tests done quickly.

00:33:27.610 --> 00:33:29.880
Secondly, Android
Emulator is pretty

00:33:29.880 --> 00:33:31.510
close to a physical device.

00:33:31.510 --> 00:33:34.440
So you can do most of the
tests with it with confidence.

00:33:34.440 --> 00:33:37.420
Finally, Android Emulator
is pretty flexible.

00:33:37.420 --> 00:33:39.540
It will help you to
validate different APIs,

00:33:39.540 --> 00:33:42.700
different screen
compilations quickly.

00:33:42.700 --> 00:33:45.390
So, with that, we
believe Android Emulator

00:33:45.390 --> 00:33:50.760
can be your go-to device
for application deployment.

00:33:50.760 --> 00:33:54.300
One thing we like about
Android is the open platform.

00:33:54.300 --> 00:33:59.950
Just like internet-- permission
list- innovation is possible.

00:33:59.950 --> 00:34:03.500
That's why we want to build
Android Emulator to help.

00:34:03.500 --> 00:34:08.190
The new opportunity-- only
possible because a user

00:34:08.190 --> 00:34:14.920
like you actually creates
a new way to help the user.

00:34:14.920 --> 00:34:19.139
So hopefully, this will
help you to find a new way

00:34:19.139 --> 00:34:22.159
to use Android Emulator to
improve your productivity.

00:34:22.159 --> 00:34:23.080
Thank you for coming.

00:34:23.080 --> 00:34:24.770
And enjoy the rest of I/O.

00:34:24.770 --> 00:34:28.420
[MUSIC PLAYING]

