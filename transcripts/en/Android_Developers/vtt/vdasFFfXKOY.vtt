WEBVTT
Kind: captions
Language: en

00:00:02.035 --> 00:00:03.160
STEPHAN LINZNER: Hey, guys.

00:00:03.160 --> 00:00:05.580
Welcome to our talk on
Android Testing APIs.

00:00:05.580 --> 00:00:07.730
And today we're
going to show you

00:00:07.730 --> 00:00:10.710
how you can write to higher
quality apps using automated

00:00:10.710 --> 00:00:11.670
tests.

00:00:11.670 --> 00:00:13.352
My name is Stephan Linzner.

00:00:13.352 --> 00:00:14.810
JOSE ALCERRECA:
I'm Jose Alcerreca.

00:00:14.810 --> 00:00:16.239
JAN-FELIX SCHMAKEIT: And
I'm Jan-Felix Schmakeit.

00:00:16.239 --> 00:00:19.030
And we are developer program
engineers on the developer

00:00:19.030 --> 00:00:21.032
platform team here at Google.

00:00:21.032 --> 00:00:22.990
And you might have seen
some of the sample code

00:00:22.990 --> 00:00:25.080
in some from libraries
that we've been working on,

00:00:25.080 --> 00:00:26.790
in particular the
Android testing support

00:00:26.790 --> 00:00:28.760
library is something
that they have worked on.

00:00:28.760 --> 00:00:30.410
And with that, I will
leave you with Stephan,

00:00:30.410 --> 00:00:32.034
who's going to talk
with you more about

00:00:32.034 --> 00:00:34.650
how Android testing has evolved
over the last few years.

00:00:34.650 --> 00:00:37.450
STEPHAN LINZNER:
Thank you, guys.

00:00:37.450 --> 00:00:39.660
So almost two years
ago when we started

00:00:39.660 --> 00:00:42.920
thinking about how we can make
developers more productive,

00:00:42.920 --> 00:00:45.560
how can we enable you guys
to write higher quality

00:00:45.560 --> 00:00:50.490
apps, one thing that repeatedly
came up was automated testing.

00:00:50.490 --> 00:00:53.540
But if you look at the testing
APIs, what you will find

00:00:53.540 --> 00:00:57.040
is some of them have changed
in API level three, which

00:00:57.040 --> 00:00:57.820
was cupcake.

00:00:57.820 --> 00:01:01.570
And most of them have been
around since API level one.

00:01:01.570 --> 00:01:04.370
So what that means
is, in the meantime,

00:01:04.370 --> 00:01:07.100
Android has evolved
a lot, right?

00:01:07.100 --> 00:01:10.260
And I'm so proud of what we've
achieved in the last five

00:01:10.260 --> 00:01:11.260
or six years in Android.

00:01:11.260 --> 00:01:13.990
And I'm pretty sure
everyone in this room is.

00:01:13.990 --> 00:01:16.620
But we haven't evolved
in a testing space,

00:01:16.620 --> 00:01:18.290
and that's what we
wanted to change.

00:01:18.290 --> 00:01:20.420
We wanted to make
testing easier,

00:01:20.420 --> 00:01:22.650
and we wanted to
have a better testing

00:01:22.650 --> 00:01:25.760
experience across the stack.

00:01:25.760 --> 00:01:28.950
So since then, we've
made a lot of progress

00:01:28.950 --> 00:01:30.810
on many levels of the stack.

00:01:30.810 --> 00:01:34.380
And we've created a new
suite of tools and frameworks

00:01:34.380 --> 00:01:36.630
to enable a better
testing experience

00:01:36.630 --> 00:01:39.130
and make it even
fun to write tests.

00:01:39.130 --> 00:01:40.890
So we have Android
Studio and Gradle,

00:01:40.890 --> 00:01:44.040
which added amazing new
features like the new unit test

00:01:44.040 --> 00:01:47.120
support which allows for
faster development cycles

00:01:47.120 --> 00:01:48.850
and makes you more productive.

00:01:48.850 --> 00:01:52.460
We have new ways to
write and run tests.

00:01:52.460 --> 00:01:55.880
And we also now have compelling
ways to display test results

00:01:55.880 --> 00:01:59.200
and code coverage reports
in Android Studio.

00:01:59.200 --> 00:02:01.550
And now, with
Android Studio 2.0,

00:02:01.550 --> 00:02:05.320
you can even refactor across
unit and instrumentation

00:02:05.320 --> 00:02:07.520
tests, which is amazing.

00:02:07.520 --> 00:02:08.780
But we went even further.

00:02:08.780 --> 00:02:11.820
So we ended up creating
a full support library

00:02:11.820 --> 00:02:14.820
for testing called the Android
Testing Support Library.

00:02:14.820 --> 00:02:19.250
This library contains
all of our testing APIs.

00:02:19.250 --> 00:02:21.970
And you can just apply
it to your project

00:02:21.970 --> 00:02:24.530
and get easily
started with testing.

00:02:24.530 --> 00:02:27.005
But even more
importantly, these library

00:02:27.005 --> 00:02:29.550
is unbundled from the
platform, which means

00:02:29.550 --> 00:02:32.170
we can update it at any time.

00:02:32.170 --> 00:02:34.140
And we can iterate
faster, and we

00:02:34.140 --> 00:02:38.390
can fix bugs more quickly,
which was a problem before.

00:02:38.390 --> 00:02:42.610
On top of that, we also
created a new testing

00:02:42.610 --> 00:02:44.140
library called Espresso.

00:02:44.140 --> 00:02:46.287
And this addresses actually
one of the biggest pain

00:02:46.287 --> 00:02:48.620
points that we had in Android
testing for a while, which

00:02:48.620 --> 00:02:50.140
is UI testing.

00:02:50.140 --> 00:02:52.260
In Espresso, you
will see that if you

00:02:52.260 --> 00:02:56.120
start using it has a really
nice, beautiful, concise,

00:02:56.120 --> 00:03:00.870
and fluent API, which makes
for frictionless testing.

00:03:00.870 --> 00:03:03.120
And with, that I'm going
to head back to JF.

00:03:03.120 --> 00:03:05.330
He's going to talk
about the code lab app

00:03:05.330 --> 00:03:09.320
that we've built to show you
how you can use our testing API

00:03:09.320 --> 00:03:10.529
as an action in your project.

00:03:10.529 --> 00:03:11.611
JAN-FELIX SCHMAKEIT: Cool.

00:03:11.611 --> 00:03:13.010
Thank you, Stephan.

00:03:13.010 --> 00:03:15.260
So the app I'm
talking about here

00:03:15.260 --> 00:03:17.450
is actually part of
a code lab that we're

00:03:17.450 --> 00:03:19.714
going to be referring to
throughout this presentation.

00:03:19.714 --> 00:03:21.630
At the end, I have some
links, some resources,

00:03:21.630 --> 00:03:23.171
you can actually
check it out and see

00:03:23.171 --> 00:03:24.670
exactly what we have done.

00:03:24.670 --> 00:03:28.190
So the app we
wanted to build was

00:03:28.190 --> 00:03:30.990
meant to showcase the best
practice for testing today.

00:03:30.990 --> 00:03:33.730
You know, how you should be
using testing in your Android

00:03:33.730 --> 00:03:34.710
application.

00:03:34.710 --> 00:03:38.110
So what we have to build is a
very simple, very standard note

00:03:38.110 --> 00:03:39.620
taking application.

00:03:39.620 --> 00:03:42.204
You can view a list of the
notes that you have in your app.

00:03:42.204 --> 00:03:44.745
You can add a new note, which
means you can also take a photo

00:03:44.745 --> 00:03:46.310
and attach it to your note.

00:03:46.310 --> 00:03:48.290
You can click on a
note and it opens up,

00:03:48.290 --> 00:03:49.950
and you can see
its full content.

00:03:49.950 --> 00:03:52.530
And we have some navigation
in there as well.

00:03:52.530 --> 00:03:56.090
And as you can see, this is very
much a stock standard Android

00:03:56.090 --> 00:03:58.359
application, probably
quite similar to the way

00:03:58.359 --> 00:03:59.650
you've built an Android before.

00:03:59.650 --> 00:04:02.600
If you're using RecycleView
to display the list of notes,

00:04:02.600 --> 00:04:04.970
we're using a system
intend to open the camera

00:04:04.970 --> 00:04:09.854
app to take a photo using the
system camera application.

00:04:09.854 --> 00:04:11.520
And we have a navigation
drawer in there

00:04:11.520 --> 00:04:14.090
as well with the menu options.

00:04:14.090 --> 00:04:18.570
Just remember the key here was
to create an application that

00:04:18.570 --> 00:04:22.010
shows you the best practices
for Android testing today.

00:04:22.010 --> 00:04:25.180
So as part of that, we were
thinking very carefully

00:04:25.180 --> 00:04:28.060
about the architecture that
we use for our application.

00:04:28.060 --> 00:04:31.156
Let me be very
clear here, MVP is

00:04:31.156 --> 00:04:33.030
Model-View-Presenter
architecture, obviously.

00:04:33.030 --> 00:04:35.830
But there are many other
great architectures out there.

00:04:35.830 --> 00:04:39.020
And it really depends on your
use cases, and your application

00:04:39.020 --> 00:04:41.290
to select something
that works for you.

00:04:41.290 --> 00:04:44.380
Just remember the key
part for any architecture

00:04:44.380 --> 00:04:46.940
is that you can separate
the different parts,

00:04:46.940 --> 00:04:49.830
the different components, of
your application from another.

00:04:49.830 --> 00:04:51.660
So you can test
them independently,

00:04:51.660 --> 00:04:54.610
and you can maintain them
independently as well.

00:04:54.610 --> 00:04:56.740
So in our case for
our application,

00:04:56.740 --> 00:04:58.200
that was the
model-view-presenter

00:04:58.200 --> 00:04:59.130
architecture.

00:04:59.130 --> 00:05:02.210
And the way this works is
that we have the data storage,

00:05:02.210 --> 00:05:04.300
the list of notes at the model.

00:05:04.300 --> 00:05:06.640
We have the view, this is
for the actual Android magic

00:05:06.640 --> 00:05:08.950
happens, sets the [INAUDIBLE]
with the RecyclerView,

00:05:08.950 --> 00:05:10.680
and display the actual notes.

00:05:10.680 --> 00:05:13.510
So for example, if you want
to load in a list of notes

00:05:13.510 --> 00:05:15.490
and display them on the
screen, the presenter

00:05:15.490 --> 00:05:18.440
talks to the model, loads
in the list of notes,

00:05:18.440 --> 00:05:19.880
and tells the view
to display it.

00:05:19.880 --> 00:05:22.160
And then the view
talks to RecyclerView,

00:05:22.160 --> 00:05:23.460
and then displays it.

00:05:23.460 --> 00:05:25.360
So just remember
the key part here

00:05:25.360 --> 00:05:28.130
is to separate the different
areas and different components

00:05:28.130 --> 00:05:29.150
of your application.

00:05:29.150 --> 00:05:31.766
This makes it really easy and
really useful for testing.

00:05:31.766 --> 00:05:33.390
Now we have Jose
coming up next telling

00:05:33.390 --> 00:05:37.480
you a bit more about testing
and independent components.

00:05:37.480 --> 00:05:38.750
JOSE ALCERRECA: Thank you, JF.

00:05:38.750 --> 00:05:43.270
So JF mentioned
testing in isolation.

00:05:43.270 --> 00:05:45.560
In order to test
in isolation, you

00:05:45.560 --> 00:05:49.910
need to be able to create
a hermetic environment.

00:05:49.910 --> 00:05:53.680
So before talking about
the types of tests,

00:05:53.680 --> 00:05:56.570
let's talk about
hermetic testing.

00:05:56.570 --> 00:05:58.490
Why do we need hermetic testing?

00:05:58.490 --> 00:06:02.370
Because there's something
worse than having no tests,

00:06:02.370 --> 00:06:04.168
that's having flaky tests.

00:06:06.992 --> 00:06:08.450
I've seen this
slide so many times,

00:06:08.450 --> 00:06:09.790
I didn't remember it was funny.

00:06:12.360 --> 00:06:15.250
A test this flaky when
it fails sometimes.

00:06:15.250 --> 00:06:19.730
So if a test fails just
1% of the time you run it,

00:06:19.730 --> 00:06:22.500
you will submit your
code, submit of your test,

00:06:22.500 --> 00:06:24.050
and in three weeks
you'll get a call

00:06:24.050 --> 00:06:26.740
or you go an email saying
something went wrong,

00:06:26.740 --> 00:06:28.610
because this test failed.

00:06:28.610 --> 00:06:30.600
So you'll start
your investigation,

00:06:30.600 --> 00:06:34.340
you'll log into your Jenkins
instance, if you have one.

00:06:34.340 --> 00:06:40.100
And after 15 minutes you will
say the famous last words,

00:06:40.100 --> 00:06:43.350
it's probably just a flaky test.

00:06:43.350 --> 00:06:48.910
That's something that you should
never have to say or hear.

00:06:48.910 --> 00:06:55.110
So in this code lab,
in this project,

00:06:55.110 --> 00:06:59.530
we had an objective to reduce
flakiness as much as possible.

00:06:59.530 --> 00:07:01.990
So the first thing
we did was to isolate

00:07:01.990 --> 00:07:04.540
from external dependencies.

00:07:04.540 --> 00:07:08.480
Externally tendencies are one
of the most important sources

00:07:08.480 --> 00:07:12.130
of flakiness, especially
the network, for example,

00:07:12.130 --> 00:07:15.490
because the network can fail.

00:07:15.490 --> 00:07:18.150
When network calls, when
you talk to your back end,

00:07:18.150 --> 00:07:22.870
API can fail in many
steps-- your Wi-Fi, your ISP

00:07:22.870 --> 00:07:23.650
connection.

00:07:23.650 --> 00:07:27.400
The server has to
be on and working,

00:07:27.400 --> 00:07:29.720
but also other
external dependencies

00:07:29.720 --> 00:07:35.120
to our code like storage,
other devices, sensors,

00:07:35.120 --> 00:07:37.120
the camera, et cetera.

00:07:37.120 --> 00:07:42.620
So what we're going to do
is replace the components

00:07:42.620 --> 00:07:46.560
that talk to these
external dependencies

00:07:46.560 --> 00:07:49.080
with fake
implementations that are

00:07:49.080 --> 00:07:54.490
going to intercept that and
return fake data immediately.

00:07:54.490 --> 00:07:57.440
For that, we could use something
like dependency injection

00:07:57.440 --> 00:07:59.850
framework like
Dagger or Dagger 2.

00:07:59.850 --> 00:08:03.860
But we found something
that is simpler, flavors.

00:08:03.860 --> 00:08:09.186
Product flavors is a feature
in the Android Gradle plug in.

00:08:09.186 --> 00:08:11.060
You're probably familiar
with it because this

00:08:11.060 --> 00:08:15.610
is what you use if you want
to create different versions

00:08:15.610 --> 00:08:17.520
of your app sharing code base.

00:08:17.520 --> 00:08:23.200
So it's very common to see
free versus paid dimension

00:08:23.200 --> 00:08:24.090
for flavors.

00:08:24.090 --> 00:08:26.220
In this case we
have prod and mock.

00:08:26.220 --> 00:08:29.730
Prod is your production version,
the one that you distribute.

00:08:29.730 --> 00:08:34.740
And mock is the one that is
going to use this fake data.

00:08:34.740 --> 00:08:38.270
If you open the project
with Android Studio

00:08:38.270 --> 00:08:40.490
and you look at the
build variants window,

00:08:40.490 --> 00:08:42.370
you'll see that we
have three variants.

00:08:42.370 --> 00:08:44.560
That's because we
are filtering out

00:08:44.560 --> 00:08:49.300
mock release, because it makes
no sense, and we don't need it.

00:08:49.300 --> 00:08:51.550
If you look at the
Gradle task list,

00:08:51.550 --> 00:08:54.370
you'll see that there is
no install debug anymore.

00:08:54.370 --> 00:08:57.860
So now we have to choose which
version we want to install.

00:08:57.860 --> 00:09:01.620
We can install Mock
Debug or Prod Debug.

00:09:01.620 --> 00:09:05.590
To run tests, we usually use
connect instrumentation tests.

00:09:05.590 --> 00:09:08.310
We usually use
connectedAndroidTests.

00:09:08.310 --> 00:09:11.870
But we can now also
choose what version

00:09:11.870 --> 00:09:15.360
to test against with connected
mock debug Android test

00:09:15.360 --> 00:09:19.310
and connected prod
debug Android test.

00:09:19.310 --> 00:09:21.040
So let's see how it's done.

00:09:21.040 --> 00:09:23.750
First, you a source
set per flavor.

00:09:23.750 --> 00:09:26.430
So we have prod and mock.

00:09:26.430 --> 00:09:29.280
And we also have another
interesting source set, Android

00:09:29.280 --> 00:09:30.280
test mark.

00:09:30.280 --> 00:09:33.310
This is where you
put the tests that

00:09:33.310 --> 00:09:37.700
only makes sense for the
mock version of your app.

00:09:37.700 --> 00:09:42.530
Check out the code to
see why we use that.

00:09:42.530 --> 00:09:46.950
This is where the actual
replacement happens.

00:09:46.950 --> 00:09:52.310
The injection class lives in
both mock and prod source sets.

00:09:52.310 --> 00:09:54.060
So that is the
class that is going

00:09:54.060 --> 00:09:57.610
to be replaced, depending on
the version that you're using.

00:09:57.610 --> 00:10:00.360
Also, we put the
fake implementations

00:10:00.360 --> 00:10:02.077
in the mock source set.

00:10:02.077 --> 00:10:03.660
This is great because
this is actually

00:10:03.660 --> 00:10:07.210
going to hide these classes
from the production app,

00:10:07.210 --> 00:10:11.225
so that you can't
use them by mistake.

00:10:11.225 --> 00:10:17.320
Zooming in a little bit,
this is the injection class

00:10:17.320 --> 00:10:19.660
of the mock source set.

00:10:19.660 --> 00:10:21.870
It has two methods,
both injection classes

00:10:21.870 --> 00:10:23.490
look the same from the outside.

00:10:23.490 --> 00:10:25.670
They have the same
public methods.

00:10:25.670 --> 00:10:27.660
Provide image file
is the method that we

00:10:27.660 --> 00:10:32.020
use from the component
that talks to the camera.

00:10:32.020 --> 00:10:35.690
So we're going to return a new
fake image file implementation.

00:10:35.690 --> 00:10:40.580
That class, the only thing it's
doing is returning a string,

00:10:40.580 --> 00:10:43.780
a path to an image
file that we preloaded.

00:10:43.780 --> 00:10:46.410
So it's a fake image, really.

00:10:46.410 --> 00:10:49.850
Provide notes
repository is the method

00:10:49.850 --> 00:10:52.870
that we use to
create a repository.

00:10:52.870 --> 00:10:55.350
So if you are using
the mock flavor,

00:10:55.350 --> 00:10:59.620
it's going to create an actual,
real in memory repository.

00:10:59.620 --> 00:11:02.620
But we're going to
inject a fake dependency.

00:11:02.620 --> 00:11:05.560
In this case, the fake notes
service API implementation.

00:11:05.560 --> 00:11:08.470
That's a very Java name, I know.

00:11:08.470 --> 00:11:12.530
It's going not to store
any HTTP connections,

00:11:12.530 --> 00:11:15.312
but it's just going
to return immediately

00:11:15.312 --> 00:11:20.110
a JSON file in this case.

00:11:20.110 --> 00:11:20.960
And that's it.

00:11:25.640 --> 00:11:29.380
That's how we set up a
hermetic environment.

00:11:29.380 --> 00:11:32.060
Is it actually three to 12:00?

00:11:32.060 --> 00:11:33.143
That would be pretty cool.

00:11:33.143 --> 00:11:34.520
Yeah, more or less?

00:11:34.520 --> 00:11:35.020
OK.

00:11:39.050 --> 00:11:41.730
This has some
interesting side effects.

00:11:41.730 --> 00:11:46.700
Mock mode, using the mock
flavor is interesting

00:11:46.700 --> 00:11:49.460
if you are developing your app.

00:11:49.460 --> 00:11:51.570
You usually do manual
testing, right,

00:11:51.570 --> 00:11:54.640
if you're developing
IA, specifically.

00:11:54.640 --> 00:11:58.210
You change something in the
UI, you deploy, and then

00:11:58.210 --> 00:12:04.700
you test manually that
what you've done works.

00:12:04.700 --> 00:12:07.470
If you use fake
data, this iteration

00:12:07.470 --> 00:12:09.430
is going to be shorter,
so your development

00:12:09.430 --> 00:12:11.030
is going to be faster.

00:12:11.030 --> 00:12:12.800
It's also good for
concurrent development.

00:12:12.800 --> 00:12:15.800
So if you don't have
a back end API yet,

00:12:15.800 --> 00:12:20.470
you can use fake
data in the meantime.

00:12:20.470 --> 00:12:23.360
We're not only going to
run instrumentation tests

00:12:23.360 --> 00:12:27.560
against the mock flavor.

00:12:27.560 --> 00:12:30.410
We can also use
the production app,

00:12:30.410 --> 00:12:34.010
because it's going to give us
very nice end-to-end tests.

00:12:34.010 --> 00:12:36.960
if we want to test the
whole project from the back

00:12:36.960 --> 00:12:38.880
end to the app.

00:12:38.880 --> 00:12:41.320
This test is going to be,
obviously, more flaky.

00:12:41.320 --> 00:12:43.170
But you don't have
to run it very often.

00:12:43.170 --> 00:12:47.010
You can run it every 24
hours, or it's actually

00:12:47.010 --> 00:12:49.380
a very nice pre-release check.

00:12:49.380 --> 00:12:53.150
So before uploading to Google
Play or your distribution

00:12:53.150 --> 00:12:56.590
channel, you run this
test against prod

00:12:56.590 --> 00:12:59.850
to make sure that
everything works well.

00:12:59.850 --> 00:13:04.040
So now that we have a
hermetic environment,

00:13:04.040 --> 00:13:06.520
we can start
talking about tests.

00:13:06.520 --> 00:13:11.580
And the first type
is unit tests.

00:13:11.580 --> 00:13:15.950
They are fundamental for
a good testing strategy.

00:13:15.950 --> 00:13:19.850
That, then, can be completed
with integration and UI tests,

00:13:19.850 --> 00:13:22.290
a small number of
end-to-end tests,

00:13:22.290 --> 00:13:26.670
and other tests like monkey
runs, robot rounds, or then

00:13:26.670 --> 00:13:31.570
performance tests that JF is
going to talk about later.

00:13:31.570 --> 00:13:34.130
The unit tests are
also called local tests

00:13:34.130 --> 00:13:38.780
because they run on
your local workstation.

00:13:38.780 --> 00:13:40.390
So they are really fast.

00:13:40.390 --> 00:13:43.070
But they're also fast
because they are small.

00:13:43.070 --> 00:13:45.950
Unit testing is
about making sure

00:13:45.950 --> 00:13:51.030
that the individual parts of
your code work as expected.

00:13:51.030 --> 00:13:55.350
So the unit tests
must be small, and you

00:13:55.350 --> 00:13:59.870
should be able to run
thousands of tests in seconds.

00:13:59.870 --> 00:14:04.150
The problem is that, because we
are running on our workstation,

00:14:04.150 --> 00:14:05.960
we don't have access
to the framework.

00:14:05.960 --> 00:14:09.050
We don't have access to Android.

00:14:09.050 --> 00:14:14.380
So the problem with Android
is that we see these a lot.

00:14:14.380 --> 00:14:19.680
We just have huge activities
with all the code typed

00:14:19.680 --> 00:14:22.570
into them, or huge fragments.

00:14:22.570 --> 00:14:25.740
So this is horrible
for unit testing.

00:14:25.740 --> 00:14:29.300
Don't be this developer.

00:14:29.300 --> 00:14:31.520
Be this other guy.

00:14:31.520 --> 00:14:33.970
He unit tests his
business logic,

00:14:33.970 --> 00:14:37.410
and he's really happy about it.

00:14:37.410 --> 00:14:41.305
Business logic means what
you're app actually does.

00:14:41.305 --> 00:14:46.356
So if you have a
photo filtering app,

00:14:46.356 --> 00:14:47.730
the business logic
would probably

00:14:47.730 --> 00:14:52.720
be the algorithms that you
use to filter the images.

00:14:52.720 --> 00:14:55.000
Only if you have a
small dependencies

00:14:55.000 --> 00:14:58.460
with the framework, you
can use this nice feature

00:14:58.460 --> 00:15:00.760
that we added to the
unit testing support

00:15:00.760 --> 00:15:04.460
in 1.1, The Mockable
Android Jar.

00:15:04.460 --> 00:15:06.520
The Android Jar is a
file that you download

00:15:06.520 --> 00:15:09.850
with the SDK manager,
and it looks like Android

00:15:09.850 --> 00:15:10.900
from the outside.

00:15:10.900 --> 00:15:13.750
It has all the public methods
and all the public classes,

00:15:13.750 --> 00:15:16.660
but it's actually empty.

00:15:16.660 --> 00:15:20.190
So if you have a small
dependency on Android,

00:15:20.190 --> 00:15:25.490
you can use a mocking
framework like Mockito

00:15:25.490 --> 00:15:27.810
to mock these classes.

00:15:27.810 --> 00:15:30.630
We have an example
on GitHub that

00:15:30.630 --> 00:15:31.960
is mocking shared preferences.

00:15:31.960 --> 00:15:34.230
So if you don't want
to wrap that class,

00:15:34.230 --> 00:15:37.960
you can use Mockito
on your unit tests

00:15:37.960 --> 00:15:42.770
and run them on your
local workstation.

00:15:42.770 --> 00:15:46.530
So let's see how the
unit tests look like.

00:15:46.530 --> 00:15:48.410
They live in the test folder.

00:15:48.410 --> 00:15:53.300
We have five classes.

00:15:53.300 --> 00:15:55.200
The first thing
you have to do is

00:15:55.200 --> 00:15:58.440
go to the build variants
window and choose

00:15:58.440 --> 00:16:01.660
unit test as the test artifact.

00:16:01.660 --> 00:16:08.300
This is going to enable the
unit test, but also refactorings

00:16:08.300 --> 00:16:10.990
and something else.

00:16:10.990 --> 00:16:12.770
But this is actually going away.

00:16:12.770 --> 00:16:16.760
In Android Studio 2.0, you
don't have to do this anymore,

00:16:16.760 --> 00:16:18.330
because both
instrumentation and unit

00:16:18.330 --> 00:16:19.538
tests are going to be active.

00:16:19.538 --> 00:16:23.160
So that you'll be able to
refactor across both test

00:16:23.160 --> 00:16:24.370
artifacts.

00:16:24.370 --> 00:16:29.640
If you know what I'm talking
about, you know this is huge.

00:16:29.640 --> 00:16:33.930
This is how a normal
unit test looks like.

00:16:33.930 --> 00:16:35.580
It's a JUnit4 test.

00:16:35.580 --> 00:16:38.110
It has the at test and
notation, the name,

00:16:38.110 --> 00:16:40.220
and it's as simple as it gets.

00:16:40.220 --> 00:16:43.600
The new note method is
called on the real presenter.

00:16:43.600 --> 00:16:46.950
And then we are verifying that
the mocked view in this case

00:16:46.950 --> 00:16:50.020
was called via that
method, showAddNote method.

00:16:50.020 --> 00:16:54.210
Verify is Mockito
API, by the way.

00:16:54.210 --> 00:16:56.000
In order to execute
it, you can right

00:16:56.000 --> 00:16:58.340
click on the method,
right click on the class,

00:16:58.340 --> 00:17:01.240
or on the right click menu.

00:17:01.240 --> 00:17:03.100
You just click on Run.

00:17:03.100 --> 00:17:07.250
From Gradle, we
simply use "test."

00:17:07.250 --> 00:17:10.560
because your unit tests
are supposed to be fast,

00:17:10.560 --> 00:17:12.770
and they should
pass really fast.

00:17:12.770 --> 00:17:16.040
So you don't need to filter one.

00:17:16.040 --> 00:17:19.456
So we just run all
of them all the time.

00:17:21.980 --> 00:17:25.119
In the code lab, we use
a test-driven development

00:17:25.119 --> 00:17:26.650
approach.

00:17:26.650 --> 00:17:30.340
This is about creating
the unit tests first.

00:17:30.340 --> 00:17:36.200
And the unit test will act
as a contract that is going

00:17:36.200 --> 00:17:38.320
to say how your app behaves.

00:17:38.320 --> 00:17:40.730
So the first thing you do,
you create the unit test.

00:17:40.730 --> 00:17:44.130
You see that it fails,
and you implement

00:17:44.130 --> 00:17:47.440
the behavior on your app
until the test passes.

00:17:47.440 --> 00:17:50.440
And then you move
on to the next test

00:17:50.440 --> 00:17:55.540
until you have something like
this, a glorious list of tests,

00:17:55.540 --> 00:17:58.500
all passing.

00:17:58.500 --> 00:18:02.300
So with all that
we've talked about,

00:18:02.300 --> 00:18:05.050
the fact that we have an
architecture that in this case

00:18:05.050 --> 00:18:09.570
is MVP, but you can
use whatever you want.

00:18:09.570 --> 00:18:12.750
The fact that we have the
hermetic testing in place,

00:18:12.750 --> 00:18:15.500
and that we are using
unit tests and TDD

00:18:15.500 --> 00:18:18.660
is going to lead you to
a very, very healthy code

00:18:18.660 --> 00:18:23.240
base, where adding new
features is super easy.

00:18:23.240 --> 00:18:28.660
It's a matter of adding a
unit test, a couple of methods

00:18:28.660 --> 00:18:30.000
in a interface.

00:18:30.000 --> 00:18:32.000
And then Android
Studio is actually

00:18:32.000 --> 00:18:34.630
going to tell you where
to fill in the gaps.

00:18:34.630 --> 00:18:38.060
Great for maintenance as well.

00:18:38.060 --> 00:18:40.440
You don't need to be afraid
of refactorings any more,

00:18:40.440 --> 00:18:44.150
because you are
covered by tests.

00:18:44.150 --> 00:18:47.330
And you'll see that instead of
adding to your technical debt

00:18:47.330 --> 00:18:51.190
every time you modify
your code, all the pieces

00:18:51.190 --> 00:18:54.950
are going to fall into place.

00:18:54.950 --> 00:18:59.210
So to finish off, I want to
talk about hybrid-type of tests.

00:18:59.210 --> 00:19:04.620
These are the unit tests that
run on a device or an emulator.

00:19:04.620 --> 00:19:07.390
They are, by definition,
integration tests, by the way.

00:19:07.390 --> 00:19:09.560
So we call them
Unit Android Tests,

00:19:09.560 --> 00:19:10.840
because we are good at naming.

00:19:13.410 --> 00:19:18.680
These tests allow
you to test things

00:19:18.680 --> 00:19:20.950
like your possible
implementation,

00:19:20.950 --> 00:19:23.330
or your SQLite Integration.

00:19:23.330 --> 00:19:26.650
And they're actually invisible.

00:19:26.650 --> 00:19:29.050
You just upload the
tests, you run them,

00:19:29.050 --> 00:19:30.780
and then the results come back.

00:19:30.780 --> 00:19:32.700
So you don't actually
see anything,

00:19:32.700 --> 00:19:34.780
because they don't
open activities,

00:19:34.780 --> 00:19:37.190
they don't open fragments.

00:19:37.190 --> 00:19:41.000
If you want to test those
UI elements and the UI

00:19:41.000 --> 00:19:44.360
interactions, Stephan is
here to talk about UI testing

00:19:44.360 --> 00:19:45.490
with Espresso.

00:19:45.490 --> 00:19:46.967
Thanks.

00:19:46.967 --> 00:19:48.883
STEPHAN LINZNER: Thanks,
Jose, that was great.

00:19:48.883 --> 00:19:52.660
[APPLAUSE]

00:19:52.660 --> 00:19:55.770
Yeah, so let's talk a
little bit of UI testing.

00:19:55.770 --> 00:19:59.120
So, yeah, I think the
previous pod was great

00:19:59.120 --> 00:20:01.530
because it showed
that we can create,

00:20:01.530 --> 00:20:03.700
that we can implement
all our business logic,

00:20:03.700 --> 00:20:08.120
and we can verify its
correctness using a unit test.

00:20:08.120 --> 00:20:11.700
And then we can move on to
a higher level of testing

00:20:11.700 --> 00:20:13.830
and write some UI tests for it.

00:20:13.830 --> 00:20:16.350
But the other thing that it
shows, and you will actually

00:20:16.350 --> 00:20:19.780
see that if you do the code
lab-- which I, by the way,

00:20:19.780 --> 00:20:22.660
hope you all do right after
this session, go down,

00:20:22.660 --> 00:20:28.050
they're downstairs-- is that
we used the IDE to generate

00:20:28.050 --> 00:20:30.030
most of the code for us.

00:20:30.030 --> 00:20:34.450
So, because, if you look at
the test as your specification,

00:20:34.450 --> 00:20:38.050
and if you do TDD, you can
use the IDE to generate

00:20:38.050 --> 00:20:39.860
almost all the code for you.

00:20:39.860 --> 00:20:41.600
And you just filling the gaps.

00:20:41.600 --> 00:20:45.360
But it also shows how you can
use meaningful abstractions,

00:20:45.360 --> 00:20:49.810
and use a unit test to spec
the behavior of your system,

00:20:49.810 --> 00:20:53.170
how your objects interact, how
to send messages to each other,

00:20:53.170 --> 00:20:54.610
how they behave.

00:20:54.610 --> 00:20:57.590
But we can apply some of these
same patterns to UI testing.

00:20:57.590 --> 00:21:00.700
And we'll look at this now.

00:21:00.700 --> 00:21:04.540
So UI tests should be a crucial
part of your development

00:21:04.540 --> 00:21:05.590
strategy.

00:21:05.590 --> 00:21:08.750
Like, essentially, they
test your application

00:21:08.750 --> 00:21:10.220
through its user interface.

00:21:10.220 --> 00:21:11.800
It's already in the word.

00:21:11.800 --> 00:21:15.030
And what that also means
is that these tests

00:21:15.030 --> 00:21:18.970
have to run on an actual
emulator or device.

00:21:18.970 --> 00:21:20.510
And the great
thing about them is

00:21:20.510 --> 00:21:23.520
they will give you a lot of
confidence in your application.

00:21:23.520 --> 00:21:27.030
Because you can run on a white
variety of configurations,

00:21:27.030 --> 00:21:29.290
on emulators, and
you can now even

00:21:29.290 --> 00:21:33.350
use Cloud Test Lab to run on
real devices in the cloud.

00:21:33.350 --> 00:21:35.160
And so for the next
release, you can just

00:21:35.160 --> 00:21:38.170
sleep well, because you
know your app is just

00:21:38.170 --> 00:21:43.520
going to work across all these
different configurations.

00:21:43.520 --> 00:21:48.580
But I think I lied a
bit, because it turns out

00:21:48.580 --> 00:21:51.510
that UI testing is
actually quite hard to do.

00:21:51.510 --> 00:21:54.540
And writing a reliable
and nonflaky UI test

00:21:54.540 --> 00:21:56.240
before Espresso,
it was a challenge.

00:21:56.240 --> 00:21:59.730
And many of you I'm sure
have experienced this.

00:21:59.730 --> 00:22:02.880
And this is essentially
why we created Espresso,

00:22:02.880 --> 00:22:07.010
because we want you guys to
focus on being productive,

00:22:07.010 --> 00:22:10.710
on writing code, implementing
new features, maybe even

00:22:10.710 --> 00:22:11.580
focus on a test.

00:22:11.580 --> 00:22:14.670
But we don't want you
to fix your flaky tests.

00:22:14.670 --> 00:22:19.060
And what Espresso will give you
is a nice, fluent, and concise

00:22:19.060 --> 00:22:23.610
API, which you can
use to hide almost all

00:22:23.610 --> 00:22:29.420
of the complexity that
comes with writing UI tests.

00:22:29.420 --> 00:22:34.660
So when we started
creating Espresso,

00:22:34.660 --> 00:22:38.230
we tried to look at UI testing
from a different angle, right?

00:22:38.230 --> 00:22:42.010
We didn't want it to focus so
much on implementation details,

00:22:42.010 --> 00:22:43.860
like activities and fragments.

00:22:43.860 --> 00:22:47.360
Instead we took a step back
and we thought, OK, what would

00:22:47.360 --> 00:22:48.620
a user do?

00:22:48.620 --> 00:22:50.110
And if you think
about it, what you

00:22:50.110 --> 00:22:52.510
do every day if you
interact with your device,

00:22:52.510 --> 00:22:53.760
you pick it up.

00:22:53.760 --> 00:22:56.024
You'll find some
view on the screen.

00:22:56.024 --> 00:22:57.690
Then you will perform
some action on it.

00:22:57.690 --> 00:22:59.880
You might click on
a button, swipe.

00:22:59.880 --> 00:23:03.890
And then you observe
some UI state change.

00:23:03.890 --> 00:23:10.310
And this is essentially how
our Espresso API looks like.

00:23:10.310 --> 00:23:13.310
So we have the onView method
as the main entry point.

00:23:13.310 --> 00:23:15.650
And then we can just
use a ViewMatcher

00:23:15.650 --> 00:23:19.710
to tell Espresso to find us
a view in the current view

00:23:19.710 --> 00:23:20.590
hierarchy.

00:23:20.590 --> 00:23:22.420
And then once we
have that view, we

00:23:22.420 --> 00:23:25.080
can either perform
a ViewAction on it.

00:23:25.080 --> 00:23:29.710
Or we can verify a ViewAssertion
like a state change in a UI.

00:23:29.710 --> 00:23:32.450
And a ViewAction in this
case would be something

00:23:32.450 --> 00:23:35.620
like a click or a scroll.

00:23:35.620 --> 00:23:38.730
The good news is that we created
all the ViewMatchers, Matchers

00:23:38.730 --> 00:23:41.030
Actions, and Assertions for you.

00:23:41.030 --> 00:23:43.370
And I'm pretty sure
the ones that we have

00:23:43.370 --> 00:23:45.750
cover, like, 90% of the cases.

00:23:45.750 --> 00:23:49.150
But the great thing is all these
three are extension points.

00:23:49.150 --> 00:23:51.840
And they make Espresso
very customizable.

00:23:51.840 --> 00:23:54.570
And you can actually
tailor it to your needs

00:23:54.570 --> 00:24:00.850
by writing your own measures,
actions, and ViewAssertions.

00:24:00.850 --> 00:24:03.270
But now let's look at
how you would actually

00:24:03.270 --> 00:24:05.690
write an Espresso test
for your application.

00:24:05.690 --> 00:24:07.910
But before we dive in
the implementation,

00:24:07.910 --> 00:24:11.060
let's have a look at the add
note feature from the notes

00:24:11.060 --> 00:24:11.570
app.

00:24:11.570 --> 00:24:15.230
So this is a UI flaw
I'm going to show you.

00:24:15.230 --> 00:24:17.680
And we're going to
implement it afterwards.

00:24:17.680 --> 00:24:20.492
So we start on the
main note screen.

00:24:20.492 --> 00:24:22.950
Then the next thing one do is
we want to click on a button.

00:24:22.950 --> 00:24:25.070
This will bring up the
add notes fragments,

00:24:25.070 --> 00:24:27.930
where we can type in a
title and a description.

00:24:27.930 --> 00:24:29.530
Then we can save the note.

00:24:29.530 --> 00:24:32.970
And this will bring us back
to the previous screen.

00:24:32.970 --> 00:24:35.110
And as you can see,
the notice displayed,

00:24:35.110 --> 00:24:38.450
the new one is displayed,
on the main notes screen.

00:24:38.450 --> 00:24:42.520
And we want to verify
that in our UI test.

00:24:42.520 --> 00:24:43.780
So, yeah let's write a test.

00:24:43.780 --> 00:24:46.110
So the first thing
that you have to do

00:24:46.110 --> 00:24:49.280
is you have to create the notes
screen test in your Android

00:24:49.280 --> 00:24:51.200
test source set.

00:24:51.200 --> 00:24:52.750
And then you have
to do two things.

00:24:52.750 --> 00:24:55.880
The first thing is
you have to tell JUnit

00:24:55.880 --> 00:24:59.940
that you actually want to use
the Android JUnit4 Runner.

00:24:59.940 --> 00:25:02.250
And then the second thing
is you have to assign

00:25:02.250 --> 00:25:03.960
the tests to a bucket.

00:25:03.960 --> 00:25:06.380
This is something that
you don't have to do,

00:25:06.380 --> 00:25:09.049
but we recommend to do it,
because, especially if you

00:25:09.049 --> 00:25:10.590
run on a built
server, you don't want

00:25:10.590 --> 00:25:12.470
to run all the tests at a time.

00:25:12.470 --> 00:25:14.790
You just want to run either
the small, the medium,

00:25:14.790 --> 00:25:15.860
or the large ones.

00:25:15.860 --> 00:25:18.330
And this is in particular
important for the large ones,

00:25:18.330 --> 00:25:22.010
because they will
run a long time.

00:25:22.010 --> 00:25:25.230
So once we've done that, we
need to set up the stage.

00:25:25.230 --> 00:25:27.070
We have to set up
our test fixture.

00:25:27.070 --> 00:25:30.520
And we do that using a new API
in the Android Testing Support

00:25:30.520 --> 00:25:32.940
Library called
Activity Test Rule.

00:25:32.940 --> 00:25:35.670
And so you might
have heard of rules.

00:25:35.670 --> 00:25:37.520
They're not really
a new concept.

00:25:37.520 --> 00:25:40.000
They have been around
awhile in JUnit4.

00:25:40.000 --> 00:25:43.420
But this is
essentially an API you

00:25:43.420 --> 00:25:45.810
can use to create
reusable components,

00:25:45.810 --> 00:25:48.320
which you can use in
all of your tests.

00:25:48.320 --> 00:25:49.780
And they reduce
[INAUDIBLE] code.

00:25:49.780 --> 00:25:52.460
And that's exactly
what we can see here.

00:25:52.460 --> 00:25:54.230
So in order to use
Activate Test Rule.

00:25:54.230 --> 00:25:55.646
The only thing
that you have to do

00:25:55.646 --> 00:25:58.600
is you have to create an
instance in a public field,

00:25:58.600 --> 00:26:00.800
annotate it with the
at rule annotation.

00:26:00.800 --> 00:26:03.510
And then what this will do
is it will start the activity

00:26:03.510 --> 00:26:08.440
before each test and will
finish it after each test run.

00:26:08.440 --> 00:26:09.520
Which is great.

00:26:09.520 --> 00:26:14.210
And now we're actually
ready to exercise our UI.

00:26:14.210 --> 00:26:16.270
And here's how you
do it with Espresso.

00:26:16.270 --> 00:26:17.924
If you remember what
I just showed you,

00:26:17.924 --> 00:26:19.340
the first thing
that we want to do

00:26:19.340 --> 00:26:22.990
is we want to click this
button at the bottom right

00:26:22.990 --> 00:26:24.140
of the screen.

00:26:24.140 --> 00:26:25.680
So the way we do
it in Espresso, we

00:26:25.680 --> 00:26:30.390
ask Espresso to give us the view
for the corresponding add note

00:26:30.390 --> 00:26:33.190
ID from the current
view hierarchy.

00:26:33.190 --> 00:26:37.130
And we do that by using
a withId View Matcher.

00:26:37.130 --> 00:26:39.290
And Espresso will
return us that view

00:26:39.290 --> 00:26:42.410
and then we want to perform
a click action on it.

00:26:42.410 --> 00:26:46.180
And Espresso will get
the view, click on it,

00:26:46.180 --> 00:26:49.190
and then add notes
fragments will show up.

00:26:49.190 --> 00:26:51.870
And then we want to type
a title and a description

00:26:51.870 --> 00:26:53.940
in the corresponding
added text fields.

00:26:53.940 --> 00:26:58.270
And again, we use the
same entry point on view.

00:26:58.270 --> 00:27:00.540
We use a withId
Matcher, again, to get

00:27:00.540 --> 00:27:03.710
a hold of the title
and description views

00:27:03.710 --> 00:27:05.410
from the view hierarchy.

00:27:05.410 --> 00:27:07.370
But this time, we
don't click on it.

00:27:07.370 --> 00:27:12.410
We just use a type text action
to type some text in the title

00:27:12.410 --> 00:27:13.530
and the description.

00:27:13.530 --> 00:27:15.270
And then we want
to save the note.

00:27:15.270 --> 00:27:18.010
And this works pretty much
the same like the first step.

00:27:18.010 --> 00:27:21.860
We get a hold of the view
using with a withId Matcher,

00:27:21.860 --> 00:27:25.379
and then we perform
a Click Action.

00:27:25.379 --> 00:27:26.920
And the last thing
that we want to do

00:27:26.920 --> 00:27:29.880
is we want to actually verify
that the note that we have just

00:27:29.880 --> 00:27:33.374
added to our model is
displayed on screen.

00:27:33.374 --> 00:27:35.540
And this time, we're going
to do things a little bit

00:27:35.540 --> 00:27:36.280
differently.

00:27:36.280 --> 00:27:37.890
We use the On View method.

00:27:37.890 --> 00:27:40.180
But instead of matching
a view by its ID,

00:27:40.180 --> 00:27:43.350
we can also use text
and tell Espresso,

00:27:43.350 --> 00:27:45.230
give me the view from
the view hierarchy

00:27:45.230 --> 00:27:47.020
which contains these texts.

00:27:47.020 --> 00:27:48.630
And then we can use
the check method

00:27:48.630 --> 00:27:53.330
to verify that the view is
actually displayed on screen.

00:27:53.330 --> 00:27:57.620
So if you look at this, this UI
flow, it's not an easy UI flow.

00:27:57.620 --> 00:28:00.310
But if you look at the
code, it looks really easy.

00:28:00.310 --> 00:28:01.810
It's really readable.

00:28:01.810 --> 00:28:04.100
And there's no
implementation details.

00:28:04.100 --> 00:28:06.490
There's no activities,
no fragments.

00:28:06.490 --> 00:28:09.350
You essentially don't have
to deal with those details

00:28:09.350 --> 00:28:10.240
anymore.

00:28:10.240 --> 00:28:14.840
And in fact, Espresso only
cares about views and windows.

00:28:14.840 --> 00:28:16.080
That's all it cares about.

00:28:16.080 --> 00:28:18.460
And it hides most
of the complexity

00:28:18.460 --> 00:28:23.000
and most of the UI
synchronization from you.

00:28:23.000 --> 00:28:25.760
And now, of course, you
want to run your test.

00:28:25.760 --> 00:28:28.310
This works pretty much the
same like Jose showed you

00:28:28.310 --> 00:28:29.740
with the unit tests.

00:28:29.740 --> 00:28:32.120
So you can either right
click on a test clause,

00:28:32.120 --> 00:28:35.260
and click on a Play
button, or you can also

00:28:35.260 --> 00:28:37.940
do it on a method level
from the test class.

00:28:37.940 --> 00:28:41.440
But what this will do is it will
create two APKs for you, a test

00:28:41.440 --> 00:28:43.980
APK and an app APK.

00:28:43.980 --> 00:28:46.970
It will deploy both of
them to your device,

00:28:46.970 --> 00:28:49.820
and then the test
APK will instrument

00:28:49.820 --> 00:28:54.580
the app using instrumentation
and exercise it's UI.

00:28:54.580 --> 00:28:58.090
So you can, of course,
do this from Gradle.

00:28:58.090 --> 00:28:59.800
This is something
that you wouldn't use

00:28:59.800 --> 00:29:01.590
in your local development flow.

00:29:01.590 --> 00:29:04.850
But it's something that comes
in very handy if you actually

00:29:04.850 --> 00:29:08.730
run from a built server, and
if you use a CI server, which

00:29:08.730 --> 00:29:11.430
is something that I think
most of you guys do anyways.

00:29:14.150 --> 00:29:20.580
And now at this point, we need
to wire up our Android code

00:29:20.580 --> 00:29:22.560
with our architecture.

00:29:22.560 --> 00:29:23.060
Right?

00:29:23.060 --> 00:29:25.800
And the good news about
this is, because we already

00:29:25.800 --> 00:29:28.190
implemented all the
logic in a presenter,

00:29:28.190 --> 00:29:31.000
our Android implementation
will be much simpler.

00:29:31.000 --> 00:29:34.940
Often it's just setting some
text on a text view field.

00:29:34.940 --> 00:29:36.780
And often it's very simple.

00:29:36.780 --> 00:29:40.650
And the other good thing is,
because we know that everything

00:29:40.650 --> 00:29:45.070
already works, because we have
the UI tests for the presenter,

00:29:45.070 --> 00:29:48.900
this is a great approach to
attempt testing in general

00:29:48.900 --> 00:29:52.400
and combine the unit
testing with the UI testing.

00:29:52.400 --> 00:29:55.500
And at one point you'll
actually go green.

00:29:55.500 --> 00:29:57.180
Your test will pass.

00:29:57.180 --> 00:29:58.890
And then you will see
something like you

00:29:58.890 --> 00:30:00.280
can see here on the right.

00:30:00.280 --> 00:30:03.480
And I've been working on
this since many years now,

00:30:03.480 --> 00:30:05.580
and I'm still
fascinated if I see

00:30:05.580 --> 00:30:07.910
those tests run on a device.

00:30:07.910 --> 00:30:09.320
And you should
really try it out,

00:30:09.320 --> 00:30:13.360
because it's a lot of fun to
write UI tests with Espresso.

00:30:13.360 --> 00:30:15.250
So let me summarize.

00:30:15.250 --> 00:30:18.730
Espresso gives you
frictionless UI testing.

00:30:18.730 --> 00:30:20.600
Espresso is really reliable.

00:30:20.600 --> 00:30:21.380
You will see that.

00:30:21.380 --> 00:30:24.960
If you switch to Espresso,
or if you start using it,

00:30:24.960 --> 00:30:28.430
you will see your test
will be much more reliable.

00:30:28.430 --> 00:30:30.380
They're also more readable.

00:30:30.380 --> 00:30:32.740
They're almost like a UI spec.

00:30:32.740 --> 00:30:35.440
So think about on-boarding
a new member to your team.

00:30:35.440 --> 00:30:37.337
You can just point
them to the test.

00:30:37.337 --> 00:30:38.670
They can read through the tests.

00:30:38.670 --> 00:30:41.170
They can almost figure
out the whole UI flow just

00:30:41.170 --> 00:30:42.430
from your test.

00:30:42.430 --> 00:30:45.200
And maybe they get excited
when they see how easy it

00:30:45.200 --> 00:30:47.030
is to write a UI test.

00:30:47.030 --> 00:30:49.830
And it's easier to
on-board them to write

00:30:49.830 --> 00:30:51.314
UI tests in the first place.

00:30:51.314 --> 00:30:52.730
The last thing I
wanted to mention

00:30:52.730 --> 00:30:55.370
is Espresso is blazing fast.

00:30:55.370 --> 00:30:57.910
We do all the
synchronization for you,

00:30:57.910 --> 00:31:02.480
and we know when to execute the
next view action immediately

00:31:02.480 --> 00:31:05.200
after the previous
one has finished.

00:31:05.200 --> 00:31:09.540
And you will immediately notice
this if you have a lot of tests

00:31:09.540 --> 00:31:11.940
and if you switch
over to Espresso.

00:31:11.940 --> 00:31:15.310
So to summarize, Espresso
makes for a nonflaky test,

00:31:15.310 --> 00:31:16.710
and you should
really try it out,

00:31:16.710 --> 00:31:18.330
because it's an
amazing framework,

00:31:18.330 --> 00:31:21.560
and it's a step forward
in UI testing on Android.

00:31:21.560 --> 00:31:25.130
And with that, I'm very excited
to have Jay to talk about some

00:31:25.130 --> 00:31:27.590
of the newer stuff that
we've been working on.

00:31:27.590 --> 00:31:29.750
Because now that we have
all the low level APIs,

00:31:29.750 --> 00:31:32.460
we really want to take a
smarter approach to testing.

00:31:32.460 --> 00:31:34.710
And we want to build the
high level tools, which

00:31:34.710 --> 00:31:38.117
sits on the lower level APIs to
enable more powerful use cases.

00:31:38.117 --> 00:31:39.200
JAN-FELIX SCHMAKEIT: Cool.

00:31:39.200 --> 00:31:40.366
Thank you very much Stephan.

00:31:46.920 --> 00:31:50.320
So we have had Jose
talking about unit testing

00:31:50.320 --> 00:31:53.510
as the fundamental way we should
be testing our applications.

00:31:53.510 --> 00:31:56.880
Then we had Stephan talking
about integration and UI tests,

00:31:56.880 --> 00:31:59.000
being able to test
the actual Android

00:31:59.000 --> 00:32:00.390
part of our application.

00:32:00.390 --> 00:32:02.340
And as you've probably
all realized by now,

00:32:02.340 --> 00:32:05.000
these testing tools
have matured quite a bit

00:32:05.000 --> 00:32:06.460
over the last few years.

00:32:06.460 --> 00:32:08.420
So now's the time
to start thinking

00:32:08.420 --> 00:32:10.590
beyond simply verifying
the functionality

00:32:10.590 --> 00:32:12.030
of the our application.

00:32:12.030 --> 00:32:13.940
Let's think about
performance testing.

00:32:13.940 --> 00:32:16.810
And this very much sits at the
top of our testing pyramid.

00:32:16.810 --> 00:32:19.742
You know, we take advantage
of all the great testing

00:32:19.742 --> 00:32:21.450
tools, and all the
platform features that

00:32:21.450 --> 00:32:25.310
are already out there to
build our performance tests.

00:32:25.310 --> 00:32:28.070
So performance testing
today-- I'm sure many of you

00:32:28.070 --> 00:32:31.030
have experienced this
yourself-- is very painful.

00:32:31.030 --> 00:32:33.380
Traditionally, you have
a few lower spec devices.

00:32:33.380 --> 00:32:35.350
For example, you
have a QA team that

00:32:35.350 --> 00:32:36.830
has or has access to those.

00:32:36.830 --> 00:32:38.790
Maybe you have a
slower network at home

00:32:38.790 --> 00:32:40.500
where you just try to
run the application

00:32:40.500 --> 00:32:43.270
and see if it performs
OK or if anything is

00:32:43.270 --> 00:32:44.840
a bit slower than it should be.

00:32:44.840 --> 00:32:47.850
And the problem with
that is you can't easily

00:32:47.850 --> 00:32:48.890
reproduce any of this.

00:32:48.890 --> 00:32:51.390
It's really hard
for you to track

00:32:51.390 --> 00:32:53.850
trends to see how your
application is performing,

00:32:53.850 --> 00:32:54.530
right?

00:32:54.530 --> 00:32:57.160
And especially if you've
automated the rest

00:32:57.160 --> 00:32:59.030
of your tests
already, why can't we

00:32:59.030 --> 00:33:00.870
automate our performance tests?

00:33:00.870 --> 00:33:03.320
And why can't we take
advantage of the existing tests

00:33:03.320 --> 00:33:08.640
that you have already written
for this particular part?

00:33:08.640 --> 00:33:11.310
Let me introduce the
Performance Testing Harness.

00:33:11.310 --> 00:33:13.235
This is actually part
of a great code lab

00:33:13.235 --> 00:33:15.470
that we've put together
that I highly encourage you

00:33:15.470 --> 00:33:18.150
to check out after our talk.

00:33:18.150 --> 00:33:21.100
The way this works is that
we has a new custom Gradle

00:33:21.100 --> 00:33:25.437
plugin that contains a
task with which you use

00:33:25.437 --> 00:33:27.100
to run your performance tests.

00:33:27.100 --> 00:33:30.450
The trick comes from a
special test listener

00:33:30.450 --> 00:33:33.260
that sits in your test APK.

00:33:33.260 --> 00:33:35.867
The basic idea is
that we capture

00:33:35.867 --> 00:33:37.950
some additional statistics
and some additional log

00:33:37.950 --> 00:33:40.330
files as you are
executing the tests.

00:33:40.330 --> 00:33:43.960
So for example, we can track
the rendering performance,

00:33:43.960 --> 00:33:47.290
the LogCat outputs for each of
the tests as you're running it,

00:33:47.290 --> 00:33:49.290
capture it on the
device, copy it back

00:33:49.290 --> 00:33:54.700
to the development machine, and
then do some analysis on it.

00:33:54.700 --> 00:33:58.300
The key parts of this are
some custom JUnit test rules

00:33:58.300 --> 00:33:59.540
that we have added.

00:33:59.540 --> 00:34:01.590
Stephan talked
about rules already.

00:34:01.590 --> 00:34:04.420
These allow you to add some
additional functionality

00:34:04.420 --> 00:34:06.150
to UI existing tests.

00:34:06.150 --> 00:34:07.800
So here we have three rules.

00:34:07.800 --> 00:34:11.804
The first one basically runs the
Dumpsys graphics info command,

00:34:11.804 --> 00:34:13.179
which you might
have already used

00:34:13.179 --> 00:34:14.720
if you've try to
track down some jank

00:34:14.720 --> 00:34:16.040
issues in your application.

00:34:16.040 --> 00:34:18.889
It allows you to get gather
some statistics on, for example,

00:34:18.889 --> 00:34:20.530
the number of janky
frames that you had

00:34:20.530 --> 00:34:22.139
and the rendering performance.

00:34:22.139 --> 00:34:25.150
You can do exactly the same for
the net stats command, which

00:34:25.150 --> 00:34:27.190
allows you to track your
network performance,

00:34:27.190 --> 00:34:30.179
number for received and
send packets, for example.

00:34:30.179 --> 00:34:33.929
And we can also capture the
LogCat outputs individually.

00:34:33.929 --> 00:34:35.489
So just remember,
these rules are

00:34:35.489 --> 00:34:38.080
applied to each test
as it's being executed.

00:34:38.080 --> 00:34:40.110
So for each test
we can now capture

00:34:40.110 --> 00:34:42.270
the graphics performance,
network performance,

00:34:42.270 --> 00:34:43.480
and the LogCat output.

00:34:43.480 --> 00:34:45.270
And this is pretty powerful.

00:34:45.270 --> 00:34:48.040
And this is all being
executed through this new test

00:34:48.040 --> 00:34:51.199
listener that gets added to
our test APK on the device.

00:34:51.199 --> 00:34:53.730
And that's how we can capture
some additional statistics as

00:34:53.730 --> 00:34:56.810
well, such as a Systrace output
if you want to track down

00:34:56.810 --> 00:34:59.400
any other performance issues.

00:34:59.400 --> 00:35:02.530
This is what it looks
like if you're actually

00:35:02.530 --> 00:35:03.400
running the test.

00:35:03.400 --> 00:35:06.450
First of all, we have
run our new custom task,

00:35:06.450 --> 00:35:08.120
run local perf test.

00:35:08.120 --> 00:35:10.310
And then, as the test
is being executed,

00:35:10.310 --> 00:35:13.700
our listener captures the
logs for each of the tests.

00:35:13.700 --> 00:35:16.480
In our case, we only had one
test we have executed here.

00:35:16.480 --> 00:35:19.280
But you can see that for
each test, we have now a log

00:35:19.280 --> 00:35:23.650
file we can go back to
and then analyze further.

00:35:23.650 --> 00:35:25.540
And of course, there's
the Systrace file

00:35:25.540 --> 00:35:28.100
that gets captured for
the entire test run.

00:35:28.100 --> 00:35:29.980
And this all happens
automatically for you.

00:35:29.980 --> 00:35:32.020
And I think this
is very powerful.

00:35:32.020 --> 00:35:35.040
So here's an example where
our test actually failed.

00:35:35.040 --> 00:35:37.420
And you can see that we
had an excessive number

00:35:37.420 --> 00:35:39.550
of janky frames, 91%.

00:35:39.550 --> 00:35:40.910
And this is clearly a problem.

00:35:40.910 --> 00:35:43.070
This is one of our
existing tests that we had.

00:35:43.070 --> 00:35:44.950
And we simply marked
as a perf test

00:35:44.950 --> 00:35:47.140
and ran our test harness
over it and captured

00:35:47.140 --> 00:35:48.220
all these statistics.

00:35:48.220 --> 00:35:51.150
So we had 91% of janky frames.

00:35:51.150 --> 00:35:54.820
Janky frame means that the
frame took longer to render

00:35:54.820 --> 00:35:57.890
on the device, so it appeared
a bit janky on the device.

00:35:57.890 --> 00:35:59.660
So our test failed.

00:35:59.660 --> 00:36:01.870
Instead of having to go
back, getting the device

00:36:01.870 --> 00:36:03.634
out having to reproduce
it, and trying

00:36:03.634 --> 00:36:06.300
to see what's going on there, we
have captured all the log files

00:36:06.300 --> 00:36:06.800
already.

00:36:06.800 --> 00:36:08.630
We have the Systrace
file there as well.

00:36:08.630 --> 00:36:10.560
So we can go straight
back to the logs

00:36:10.560 --> 00:36:12.770
we have captured to see
what the problem was,

00:36:12.770 --> 00:36:14.670
and maybe even fix
it straight away.

00:36:14.670 --> 00:36:17.480
And this is a great way to scale
up your performance testing

00:36:17.480 --> 00:36:20.260
if you think about it.

00:36:20.260 --> 00:36:22.990
Just imagine where you can
take it from here, right?

00:36:22.990 --> 00:36:24.765
Running it on one
device, yeah, that's OK.

00:36:24.765 --> 00:36:26.140
You can probably
already do that.

00:36:26.140 --> 00:36:28.470
But imagine scaling
this up and running this

00:36:28.470 --> 00:36:30.720
as part of your continuous
integration tests, right?

00:36:30.720 --> 00:36:32.700
What if you can run
all these performance

00:36:32.700 --> 00:36:35.840
tests for each
commit or for each

00:36:35.840 --> 00:36:37.210
build that you're creating.

00:36:37.210 --> 00:36:39.180
And this is very
powerful, because this now

00:36:39.180 --> 00:36:42.726
allows you to capture statistics
and trends as they develop.

00:36:42.726 --> 00:36:44.600
You might even be able
to go back all the way

00:36:44.600 --> 00:36:47.480
to one commit that introduced
some performance issues that

00:36:47.480 --> 00:36:49.180
didn't come up until later on.

00:36:49.180 --> 00:36:51.770
So no longer do you have
to rely on just simple

00:36:51.770 --> 00:36:53.220
manual performance testing.

00:36:53.220 --> 00:36:55.760
You can use our testing
harness to automate

00:36:55.760 --> 00:36:57.300
some of the work for you.

00:36:57.300 --> 00:36:59.885
And I would like
to think about, you

00:36:59.885 --> 00:37:01.680
know, this is just
the beginning, right?

00:37:01.680 --> 00:37:03.720
There's so much more we
can do with this, right?

00:37:03.720 --> 00:37:05.900
Now that our testing
tools have matured,

00:37:05.900 --> 00:37:07.700
we can start thinking
about other ways

00:37:07.700 --> 00:37:09.360
we can test and
improve our performance

00:37:09.360 --> 00:37:10.290
in our applications.

00:37:10.290 --> 00:37:12.090
You can look at battery
usage, for example.

00:37:12.090 --> 00:37:14.090
You can look at the network
performance as well.

00:37:14.090 --> 00:37:16.650
This is very much
just the beginning.

00:37:16.650 --> 00:37:20.940
So my point here is really
that we should now be starting

00:37:20.940 --> 00:37:23.200
to think about smarter testing.

00:37:23.200 --> 00:37:25.600
Smarter testing, performance
testing, and there

00:37:25.600 --> 00:37:28.140
are many other ways
we can automate

00:37:28.140 --> 00:37:30.800
some of the things we're
currently doing manually

00:37:30.800 --> 00:37:34.060
to build better apps, make it
much easier for us to verify

00:37:34.060 --> 00:37:36.660
and test our applications,
to delight our users

00:37:36.660 --> 00:37:38.410
and give them a great,
great experience

00:37:38.410 --> 00:37:41.330
as we work on our applications.

00:37:41.330 --> 00:37:45.290
With that, I highly encourage
you to check out our code labs.

00:37:45.290 --> 00:37:45.910
They're great.

00:37:45.910 --> 00:37:47.954
First of all, the
Android testing code lap.

00:37:47.954 --> 00:37:49.370
This is the one
that you have seen

00:37:49.370 --> 00:37:51.190
throughout this
entire presentation.

00:37:51.190 --> 00:37:53.270
So we have a great code
that we've put together

00:37:53.270 --> 00:37:55.940
that shows you how we have
used the MVP architecture,

00:37:55.940 --> 00:37:57.830
how we're using
test-driven development,

00:37:57.830 --> 00:38:00.840
and how we are doing the
unit testing and the UI

00:38:00.840 --> 00:38:03.930
testing in a great,
concise application.

00:38:03.930 --> 00:38:06.260
You can check this out in
the code lab downstairs,

00:38:06.260 --> 00:38:08.127
and they are online as well.

00:38:08.127 --> 00:38:10.710
If you're more curious about the
automated performance testing

00:38:10.710 --> 00:38:12.920
that I've talked about and
you want to see it in action,

00:38:12.920 --> 00:38:15.150
and have a play with it to
see how you could use it

00:38:15.150 --> 00:38:17.810
to actually track down
a performance issue,

00:38:17.810 --> 00:38:22.850
check out the automated
performance testing code lab.

00:38:22.850 --> 00:38:25.300
Here some amazing resources
we've put together.

00:38:25.300 --> 00:38:27.350
The code labs are
all available online

00:38:27.350 --> 00:38:29.900
for you to try out at home
or later on your laptop

00:38:29.900 --> 00:38:31.140
as well, if you like.

00:38:31.140 --> 00:38:33.450
We also have some
great samples out there

00:38:33.450 --> 00:38:35.930
that show you everything
from basic unit testing

00:38:35.930 --> 00:38:38.240
to much more complicated
Espresso testing.

00:38:38.240 --> 00:38:41.110
So definitely check
this out on GitHub.

00:38:41.110 --> 00:38:44.770
We also have a great project
called the Android Testing

00:38:44.770 --> 00:38:46.540
Blueprint, and
that shows you how

00:38:46.540 --> 00:38:48.830
you can integrate many
different ways of testing

00:38:48.830 --> 00:38:50.230
into one great project.

00:38:50.230 --> 00:38:53.490
For example, the unit and the UI
testing that you've seen today.

00:38:53.490 --> 00:38:56.890
And of course, we have the ATSL,
the Android Testing Support

00:38:56.890 --> 00:38:58.730
Library that we've
all been working on.

00:38:58.730 --> 00:39:01.910
So definitely check out
the great documentation

00:39:01.910 --> 00:39:03.680
for that as well.

00:39:03.680 --> 00:39:05.910
And with that, I would like
to thank you very much.

00:39:05.910 --> 00:39:08.700
It's great to see so many people
interested in testing here.

00:39:08.700 --> 00:39:10.760
We'll be around the
office hours area,

00:39:10.760 --> 00:39:13.350
and we have Stephan
joining the Android Tools

00:39:13.350 --> 00:39:16.107
Panel, the fireside chat
this afternoon as well.

00:39:16.107 --> 00:39:18.440
So you can definitely find
us if you have any questions.

00:39:18.440 --> 00:39:20.320
And I think with that,
it's time for lunch.

00:39:20.320 --> 00:39:22.400
So happy testing!

