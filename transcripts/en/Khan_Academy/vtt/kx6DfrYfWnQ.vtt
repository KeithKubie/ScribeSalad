WEBVTT
Kind: captions
Language: en

00:00:00.244 --> 00:00:01.660
What I want to do
in this video is

00:00:01.660 --> 00:00:05.625
make clear the distinction
between an iterative,

00:00:05.625 --> 00:00:08.000
or I should say iterative--
I always pronounce it wrong--

00:00:08.000 --> 00:00:13.570
an iterative function definition
and a recursive function

00:00:13.570 --> 00:00:15.890
definition.

00:00:15.890 --> 00:00:18.000
We'll do it really by
just kind of understanding

00:00:18.000 --> 00:00:21.150
where the iteration
is happening over here

00:00:21.150 --> 00:00:24.200
and where the recursion is
happening here on the right.

00:00:24.200 --> 00:00:26.190
So when we start off,
we see the product

00:00:26.190 --> 00:00:28.290
is set to be equal to 1.

00:00:28.290 --> 00:00:30.020
And then we enter our for loop.

00:00:30.020 --> 00:00:35.600
The for loop really is the
meat of this iterative function

00:00:35.600 --> 00:00:36.426
definition.

00:00:36.426 --> 00:00:38.550
And understanding what's
happening in the for loop,

00:00:38.550 --> 00:00:40.170
let me make a little table here.

00:00:40.170 --> 00:00:44.210
So I'm going to make a table
for the value of our variable i,

00:00:44.210 --> 00:00:52.860
and I'll also figure out what
the value of product times

00:00:52.860 --> 00:00:53.740
i plus 1.

00:00:53.740 --> 00:00:56.610
Because every iteration
through this for loop,

00:00:56.610 --> 00:00:59.500
we're going to evaluate this
business right over here.

00:00:59.500 --> 00:01:01.260
And then I'm going
to make a column

00:01:01.260 --> 00:01:03.275
for the new value
of our product.

00:01:07.270 --> 00:01:09.560
So let me underline
these things.

00:01:09.560 --> 00:01:12.190
And then we have the new
value of our product.

00:01:12.190 --> 00:01:15.365
So we learned in many videos
ago that in Python, we

00:01:15.365 --> 00:01:17.820
say for i in range.

00:01:17.820 --> 00:01:23.080
This range part right
over here returns a list,

00:01:23.080 --> 00:01:26.060
and it returns a list of
the number of elements

00:01:26.060 --> 00:01:27.380
that we pass number.

00:01:27.380 --> 00:01:29.276
We pass into it right over here.

00:01:29.276 --> 00:01:31.150
So if we assume-- and
I should have said this

00:01:31.150 --> 00:01:34.140
from the get-go-- let's assume
that we're calling-- just

00:01:34.140 --> 00:01:35.315
give me something specific.

00:01:35.315 --> 00:01:36.690
Let's say that
this is the result

00:01:36.690 --> 00:01:45.320
of a call of factorial of 3.

00:01:45.320 --> 00:01:48.490
So the argument that we
passed a factorial is 3, so

00:01:48.490 --> 00:01:51.640
the variable number
will refer to 3.

00:01:51.640 --> 00:01:53.950
So when you call
range of number,

00:01:53.950 --> 00:01:58.330
it will literally
return a list 0, 1, 2.

00:01:58.330 --> 00:02:00.370
So three elements starting at 0.

00:02:00.370 --> 00:02:02.550
The last element is 3 minus 1.

00:02:02.550 --> 00:02:03.870
It is 2.

00:02:03.870 --> 00:02:06.310
And so each loop
through this for loop,

00:02:06.310 --> 00:02:09.350
i is going to be assigned
to each successive element

00:02:09.350 --> 00:02:09.900
in this list.

00:02:09.900 --> 00:02:12.180
So on the first time
through this for loop,

00:02:12.180 --> 00:02:15.200
i is going to be assigned to 0.

00:02:15.200 --> 00:02:18.390
So our i is going to refer to 0.

00:02:18.390 --> 00:02:22.100
And then product times i plus 1.

00:02:22.100 --> 00:02:23.957
Well, in this
first loop product,

00:02:23.957 --> 00:02:25.540
up here before we
even enter the loop,

00:02:25.540 --> 00:02:28.480
product was defined to be 1.

00:02:28.480 --> 00:02:30.990
So product is going
to be 1, and it's

00:02:30.990 --> 00:02:35.800
1 times-- I don't want
to do it in that color.

00:02:35.800 --> 00:02:41.090
I'll just do it in
magenta-- 1 times

00:02:41.090 --> 00:02:47.205
i, which is 0-- 1
times 0, plus 1.

00:02:50.366 --> 00:02:51.740
And then our new
value or product

00:02:51.740 --> 00:02:53.210
is essentially this evaluated.

00:02:53.210 --> 00:02:54.126
We have it right here.

00:02:54.126 --> 00:02:56.800
Product is equal to
all of this business.

00:02:56.800 --> 00:02:59.084
And so our new value
is 1 times 0 plus 1.

00:02:59.084 --> 00:03:00.250
Well, that's just 1 times 1.

00:03:00.250 --> 00:03:01.990
And that's just going to be 1.

00:03:01.990 --> 00:03:04.754
And that's all we had
inside the for loop clause,

00:03:04.754 --> 00:03:06.170
because that's the
only stuff that

00:03:06.170 --> 00:03:08.540
was indented within
this for loop.

00:03:08.540 --> 00:03:13.300
And so then we go
back up, and we're

00:03:13.300 --> 00:03:15.774
going to iterate through the
next iteration of our loop,

00:03:15.774 --> 00:03:16.690
I guess you could say.

00:03:16.690 --> 00:03:19.175
And now i is going
to be assigned to 1.

00:03:22.600 --> 00:03:24.210
This expression
over here-- we're

00:03:24.210 --> 00:03:26.880
going to take our old product.

00:03:26.880 --> 00:03:30.270
So product is still 1.

00:03:30.270 --> 00:03:37.560
And it's going to be times
i, which is now 1 plus 1.

00:03:40.290 --> 00:03:42.190
And what's this
going to be equal to?

00:03:42.190 --> 00:03:45.490
Well if you evaluate all
of this, you get 1 times 2.

00:03:45.490 --> 00:03:49.960
So now the new value for product
is 2 after our second iteration

00:03:49.960 --> 00:03:53.650
through the loop-- our
second pass through the loop.

00:03:53.650 --> 00:03:57.220
And now it will go back to
the beginning of the for loop,

00:03:57.220 --> 00:04:00.090
and i will be assigned to
the next element in the list.

00:04:00.090 --> 00:04:02.550
It'll now be assigned to 2.

00:04:02.550 --> 00:04:04.130
So i is now 2.

00:04:04.130 --> 00:04:07.250
This thing over here,
it's going to be product.

00:04:07.250 --> 00:04:09.020
Well product is now 2.

00:04:09.020 --> 00:04:13.480
So it's going to be 2 times i.

00:04:13.480 --> 00:04:16.510
Well i is now 2 plus 1.

00:04:19.370 --> 00:04:22.940
And so what does this--
this is 2 times 3, or 6.

00:04:25.560 --> 00:04:27.640
And then it'll go,
and it'll say, OK,

00:04:27.640 --> 00:04:29.900
can we assign i to any
more elements of this?

00:04:29.900 --> 00:04:31.150
No, we've run out of elements.

00:04:31.150 --> 00:04:33.080
So now we break out
of the for loop,

00:04:33.080 --> 00:04:38.740
and we just return the product
or the variable product

00:04:38.740 --> 00:04:39.790
it was referring to.

00:04:39.790 --> 00:04:41.290
And that's what I
should really say.

00:04:41.290 --> 00:04:44.440
We should return the value of
the product is referring to,

00:04:44.440 --> 00:04:46.610
and that value is 6.

00:04:46.610 --> 00:04:50.030
So when you call factorial
of 3, it will return 6.

00:04:50.030 --> 00:05:00.060
So if you were to say factorial
of 3 plus factorial of 3,

00:05:00.060 --> 00:05:02.460
and you were to evaluate
this expression,

00:05:02.460 --> 00:05:05.350
this expression
would evaluate to 6,

00:05:05.350 --> 00:05:08.236
and this expression over
here would evaluate to 6,

00:05:08.236 --> 00:05:10.110
because that's what the
function will return.

00:05:10.110 --> 00:05:14.120
And then you add those up,
and they would evaluate to 12.

00:05:14.120 --> 00:05:15.620
So this is why we
call it iterative.

00:05:15.620 --> 00:05:19.890
We kept iterating through
the same set of instructions.

00:05:19.890 --> 00:05:22.359
Now let's compare the
recursive definition.

00:05:22.359 --> 00:05:24.650
And this one is a little bit
more fun in a lot of ways.

00:05:24.650 --> 00:05:30.100
So once again, we're going
to call factorial of 3.

00:05:30.100 --> 00:05:31.450
So 3 is our argument.

00:05:31.450 --> 00:05:34.520
That's the value that number
will refer to, it'll take on.

00:05:34.520 --> 00:05:36.720
It says if number is
less than or equal to 1.

00:05:36.720 --> 00:05:38.365
Well, 3 is not less
than or equal to 1.

00:05:38.365 --> 00:05:40.240
So we're not going to
do this part over here.

00:05:40.240 --> 00:05:42.010
We're going to do
the else clause.

00:05:42.010 --> 00:05:49.100
So we're going to return number
times factorial of all of this.

00:05:49.100 --> 00:05:55.700
So this is going to evaluate
to number, which is 3--

00:05:55.700 --> 00:06:06.961
that's the argument we passed---
times factorial of number minus

00:06:06.961 --> 00:06:07.460
1.

00:06:07.460 --> 00:06:09.700
Well number minus 1 is
going to evaluate to 2.

00:06:09.700 --> 00:06:12.250
3 minus 1 is 2, So
times factorial of 2.

00:06:12.250 --> 00:06:14.790
Well, that's just another
function called a factorial.

00:06:14.790 --> 00:06:16.440
So we go back, OK, factorial.

00:06:16.440 --> 00:06:18.740
But now the argument
is 2, so number is 2.

00:06:18.740 --> 00:06:19.754
We go here.

00:06:19.754 --> 00:06:21.670
If number is less than
or equal to 1, do this.

00:06:21.670 --> 00:06:22.980
Well, the number isn't
less than or equal to 1.

00:06:22.980 --> 00:06:23.520
It's 2.

00:06:23.520 --> 00:06:25.150
So now we do else.

00:06:25.150 --> 00:06:28.180
So what we now want to
return is the number

00:06:28.180 --> 00:06:29.930
times a factorial
of number minus 1.

00:06:29.930 --> 00:06:34.492
Well, in this situation,
the number is now 2,

00:06:34.492 --> 00:06:35.950
and we're going to
want to multiply

00:06:35.950 --> 00:06:43.620
that times the
factorial of 2 minus 1.

00:06:43.620 --> 00:06:46.692
Well 2 minus 1 is just 1--
times the factorial of 1.

00:06:46.692 --> 00:06:48.400
Well, we just made
another function call,

00:06:48.400 --> 00:06:50.964
so the interpreter has
to kind of remember

00:06:50.964 --> 00:06:52.880
that we've made this
whole series of functions

00:06:52.880 --> 00:06:55.680
calls and has to keep digging
deeper and deeper and deeper.

00:06:55.680 --> 00:07:00.670
So now we've called factorial
of 1, and 1 is the argument.

00:07:00.670 --> 00:07:02.010
Number is referring to 1.

00:07:02.010 --> 00:07:04.119
If number is less than
or equal to 1-- number

00:07:04.119 --> 00:07:05.410
is less than or equal to 1 now.

00:07:05.410 --> 00:07:06.868
This is why we call
it a base case.

00:07:06.868 --> 00:07:08.560
We're kind of going down to it.

00:07:08.560 --> 00:07:12.090
So if the number is less
than or equal to 1, return 1.

00:07:12.090 --> 00:07:14.860
So in this situation, when
we call factorial of 1,

00:07:14.860 --> 00:07:16.840
it literally returns 1.

00:07:16.840 --> 00:07:21.180
And so we now know
that factorial of 2

00:07:21.180 --> 00:07:23.210
evaluates to 2 times 1.

00:07:23.210 --> 00:07:26.030
So this evaluates to 2.

00:07:26.030 --> 00:07:29.070
And now we know that factorial
of 3 evaluates to 3 times

00:07:29.070 --> 00:07:36.180
2, which will evaluate to 6.

00:07:36.180 --> 00:07:37.992
So very different ways
of thinking about it

00:07:37.992 --> 00:07:39.650
but getting you the
exact same result.

00:07:39.650 --> 00:07:41.234
Once again, if you
take factorial of 3

00:07:41.234 --> 00:07:42.816
plus factorial of
3, it doesn't matter

00:07:42.816 --> 00:07:44.140
which way we implement it.

00:07:44.140 --> 00:07:46.661
We'll get 6 plus 6, or 12.

