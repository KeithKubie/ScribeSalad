WEBVTT
Kind: captions
Language: en

00:00:11.380 --> 00:00:13.830
GRZEGORZ KOSSAKOWSKI: Thanks
for introduction.

00:00:13.830 --> 00:00:15.490
So I'm from University
of Warsaw.

00:00:15.490 --> 00:00:22.350
I've been working here at Google
Atlanta for about three

00:00:22.350 --> 00:00:27.670
months kind of changing projects
to make Scala in GWT

00:00:27.670 --> 00:00:29.775
work better.

00:00:29.775 --> 00:00:34.875
So first we chose to start with
a question why Scala in

00:00:34.875 --> 00:00:38.320
GWT, why anybody would care?

00:00:38.320 --> 00:00:42.195
So Scala brings a lot of
development techniques to Java

00:00:42.195 --> 00:00:42.450
developers.

00:00:42.450 --> 00:00:46.900
And it means five channel
programming, better improved

00:00:46.900 --> 00:00:51.120
object orientation, we've tried
syntaxing composition.

00:00:51.120 --> 00:00:55.470
And at the same time it works
very well with existing Java

00:00:55.470 --> 00:00:56.360
libraries.

00:00:56.360 --> 00:01:01.720
And on the bottom you can see
a teaser of what you achieve

00:01:01.720 --> 00:01:02.805
do in Scala.

00:01:02.805 --> 00:01:08.280
This is a real code snippet I've
taken from [INAUDIBLE]

00:01:08.280 --> 00:01:10.180
of GWT.

00:01:10.180 --> 00:01:12.040
So I didn't make it up.

00:01:12.040 --> 00:01:13.580
It's real code.

00:01:13.580 --> 00:01:17.267
And I will explain later on
what's the real difference,

00:01:17.267 --> 00:01:20.230
what's happening on the
right-hand side and why you

00:01:20.230 --> 00:01:21.970
get sharper code too.

00:01:21.970 --> 00:01:23.816
It can read this.

00:01:23.816 --> 00:01:29.170
So that's one reason to work on
integration with Scala in

00:01:29.170 --> 00:01:30.420
GWT.

00:01:35.340 --> 00:01:40.130
So the basic task is to
connect to compilers.

00:01:40.130 --> 00:01:46.830
And this sounds challenging
but if you try to approach

00:01:46.830 --> 00:01:50.640
this problem you immediately
see that both compilers are

00:01:50.640 --> 00:01:52.788
working with abstract
syntax tree.

00:01:52.788 --> 00:01:55.840
So you know the structures
these compilers are

00:01:55.840 --> 00:01:57.044
processing.

00:01:57.044 --> 00:02:00.530
And so essentially what you need
to translate from one AST

00:02:00.530 --> 00:02:05.440
to another AST from Scala
internal AST to GWT internal

00:02:05.440 --> 00:02:10.490
AST. But there is a problem
actually because with

00:02:10.490 --> 00:02:11.300
[UNINTELLIGIBLE]

00:02:11.300 --> 00:02:11.790
right?

00:02:11.790 --> 00:02:15.935
It's like both projects don't
want to make AST as a part of

00:02:15.935 --> 00:02:17.380
API.

00:02:17.380 --> 00:02:20.450
They want compilers to evolve.

00:02:20.450 --> 00:02:25.100
And if we would make a direct
approach of just writing code

00:02:25.100 --> 00:02:28.420
that just translates from one
AST to another we would

00:02:28.420 --> 00:02:33.840
introduce direct type collection
between these two

00:02:33.840 --> 00:02:37.850
projects and it means all
hassle-- it introduces a

00:02:37.850 --> 00:02:42.020
hassle like you have to
coordinate the review list,

00:02:42.020 --> 00:02:47.720
you have to coordinate changes
in APIs and none of those

00:02:47.720 --> 00:02:51.270
projects none of Scala
team are working with

00:02:51.270 --> 00:02:51.450
[UNINTELLIGIBLE]

00:02:51.450 --> 00:02:52.660
on that.

00:02:52.660 --> 00:02:55.320
And there is actually
interesting observation that

00:02:55.320 --> 00:02:58.560
you had the situation right now
with JDT so Java support

00:02:58.560 --> 00:03:04.010
in GWT is implemented in exactly
this way that you have

00:03:04.010 --> 00:03:09.810
another JDT compiler in GWT and
you have translation from

00:03:09.810 --> 00:03:09.970
[UNINTELLIGIBLE]

00:03:09.970 --> 00:03:13.420
and JDT and structures to
GWT data structures.

00:03:13.420 --> 00:03:16.950
But the difference is Java
is evolving much slower.

00:03:16.950 --> 00:03:22.860
So if there is a change like a
new release of a compiler it's

00:03:22.860 --> 00:03:26.075
like every few years and with
Scala it's every one year or

00:03:26.075 --> 00:03:30.655
probably even more often.

00:03:30.655 --> 00:03:34.680
So we need a loose connection,
right?

00:03:34.680 --> 00:03:38.939
It's like still we want to
translate it from one data

00:03:38.939 --> 00:03:43.538
structure to another but with
some loose connection.

00:03:43.538 --> 00:03:48.570
So we need a stable API that
both projects can target.

00:03:51.120 --> 00:03:55.974
And this is independent in some
way, some manner from

00:03:55.974 --> 00:03:57.175
both projects.

00:03:57.175 --> 00:04:00.960
And since we are working with
compilers it makes sense to

00:04:00.960 --> 00:04:02.200
introduce another language.

00:04:02.200 --> 00:04:04.430
Compilers are working
with languages.

00:04:04.430 --> 00:04:07.570
So we can introduce
another language.

00:04:07.570 --> 00:04:12.580
And the language we're
introducing during this summer

00:04:12.580 --> 00:04:13.612
is called Jribble.

00:04:13.612 --> 00:04:16.166
And this is our stable API.

00:04:16.166 --> 00:04:22.990
Before I go into describing
how Jribble looks like and

00:04:22.990 --> 00:04:27.110
details of Jribble, but first
we should answer a question:

00:04:27.110 --> 00:04:28.990
But what about Java
source code?

00:04:28.990 --> 00:04:34.884
This is a language which GWT
is supporting and why we

00:04:34.884 --> 00:04:38.960
shouldn't just translate Scala
to Java and don't even bother

00:04:38.960 --> 00:04:41.310
with GWT at all.

00:04:41.310 --> 00:04:46.730
But there are serious problems
with this approach.

00:04:46.730 --> 00:04:49.850
So the first bullet
is important.

00:04:49.850 --> 00:04:54.910
I mean it would be so beneficial
to have direct

00:04:54.910 --> 00:04:56.410
translation from
Scala to Java.

00:04:56.410 --> 00:05:02.260
But if it was possible or if
it was easy then someone

00:05:02.260 --> 00:05:04.240
already would implement it.

00:05:04.240 --> 00:05:05.000
Right?

00:05:05.000 --> 00:05:07.006
It would have already
been implemented.

00:05:07.006 --> 00:05:10.532
And there were actually attempts
to do that in the

00:05:10.532 --> 00:05:18.440
past. There are two examples--
very good examples-- where

00:05:18.440 --> 00:05:21.320
translation is really
problematic.

00:05:21.320 --> 00:05:27.085
One is that in Scala you have
unchecked exceptions -- all of

00:05:27.085 --> 00:05:27.530
them.

00:05:27.530 --> 00:05:31.340
So you can slow every exception
and you don't need

00:05:31.340 --> 00:05:35.000
to declare this in your
message signature.

00:05:35.000 --> 00:05:39.282
And as everybody knows you have
to declare exceptions you

00:05:39.282 --> 00:05:41.840
are scaling in Java.

00:05:41.840 --> 00:05:46.860
And you can imagine some kind
of program analytics that

00:05:46.860 --> 00:05:49.087
tries to recover this
information-- which exceptions

00:05:49.087 --> 00:05:51.760
you are throwing but
this would be hard.

00:05:51.760 --> 00:05:53.750
It's a rather hard problem.

00:05:53.750 --> 00:05:58.185
And the second problem, which is
even more serious, is that

00:05:58.185 --> 00:06:00.520
constructor calls doesn't
follow Java rules.

00:06:00.520 --> 00:06:04.312
And it means that you can't have
a super constructor call

00:06:04.312 --> 00:06:07.835
as the first statement in
a definition of your

00:06:07.835 --> 00:06:09.060
constructor.

00:06:09.060 --> 00:06:09.890
OK?

00:06:09.890 --> 00:06:14.570
And there is no way to work
around this issue.

00:06:14.570 --> 00:06:22.396
It's kind of artificial Java
restriction which I believe

00:06:22.396 --> 00:06:27.266
the motivation behind this rule
is to protect programmers

00:06:27.266 --> 00:06:30.528
from making mistakes--
big mistakes.

00:06:30.528 --> 00:06:35.115
But if it's a compiler which
generates these calls it

00:06:35.115 --> 00:06:36.920
should be fine, right?

00:06:36.920 --> 00:06:39.820
And the reason why you need
these calls is it's mixing

00:06:39.820 --> 00:06:41.950
composition, I believe.

00:06:41.950 --> 00:06:44.950
So you can try it and it keeps
mixing composition in Scala.

00:06:44.950 --> 00:06:46.960
And this is really
serious problem.

00:06:46.960 --> 00:06:51.030
So that's why this approach
didn't work.

00:06:51.030 --> 00:06:56.985
But there in another common
language which is called Java

00:06:56.985 --> 00:06:58.310
byte code.

00:06:58.310 --> 00:07:02.600
And again everyone on Java
platform is targeting Java

00:07:02.600 --> 00:07:03.352
byte code.

00:07:03.352 --> 00:07:07.790
So what about this
as a stable API?

00:07:07.790 --> 00:07:15.452
And it doesn't work either
because basically Java byte

00:07:15.452 --> 00:07:20.430
code is very low level and it
doesn't carry structure of

00:07:20.430 --> 00:07:21.470
your program.

00:07:21.470 --> 00:07:25.500
So you can have an example of
an expression [INAUDIBLE]

00:07:25.500 --> 00:07:30.030
and nested expression and it's
being translated to a list of

00:07:30.030 --> 00:07:32.900
very simple operations.

00:07:32.900 --> 00:07:36.060
And we need this structure
in GWT.

00:07:36.060 --> 00:07:42.866
GWT realize when doing
optimization and translating

00:07:42.866 --> 00:07:46.570
programs into complex
Java script.

00:07:46.570 --> 00:07:51.560
It just relies on having
this structure.

00:07:51.560 --> 00:07:54.865
And another problem is arbitrary
control flow which

00:07:54.865 --> 00:07:57.590
is found in bytecode.

00:07:57.590 --> 00:08:01.160
Which means you have goto
instructions everywhere.

00:08:01.160 --> 00:08:05.542
That's how many things are
implemented in bytecode.

00:08:05.542 --> 00:08:09.405
Again, you don't even have
anything which is

00:08:09.405 --> 00:08:12.370
corresponding to goto
in JavaScript.

00:08:12.370 --> 00:08:16.492
So we'd need to emulate it and
the result would be horrible.

00:08:16.492 --> 00:08:20.520
You could imagine that maybe
you could try to recover

00:08:20.520 --> 00:08:25.590
original structure of the
bytecode so you essentially

00:08:25.590 --> 00:08:27.440
are doing the compilation.

00:08:27.440 --> 00:08:30.430
But again, Java bytecode
is for [? years ?]

00:08:30.430 --> 00:08:32.179
in the market and there is no
single decompiler which is

00:08:32.179 --> 00:08:34.309
really successful.

00:08:34.309 --> 00:08:39.147
So it means it probably is
impossible to do for every

00:08:39.147 --> 00:08:40.900
case.

00:08:40.900 --> 00:08:46.475
So that's motivation why
we introduced Jribble.

00:08:46.475 --> 00:08:50.050
Jribble is Java derived
language.

00:08:50.050 --> 00:08:54.097
So we basically start with
Java and we remove or add

00:08:54.097 --> 00:08:58.790
things we need to make
tasks simplier.

00:08:58.790 --> 00:09:02.360
Yeah there is really a funny
quote from Lex Spoon.

00:09:02.360 --> 00:09:04.304
You should read that.

00:09:08.450 --> 00:09:11.156
Jribble removes package
declarations and imports,

00:09:11.156 --> 00:09:14.940
default constructors, for loops,
and restrictions on

00:09:14.940 --> 00:09:18.322
calling super constructors--
the thing that I mentioned

00:09:18.322 --> 00:09:19.830
before.

00:09:19.830 --> 00:09:25.770
And Jribble adds method and
field signatures when you

00:09:25.770 --> 00:09:26.640
reference them.

00:09:26.640 --> 00:09:29.510
For example when you want to
call a method, you give the

00:09:29.510 --> 00:09:32.880
whole signature including
L types.

00:09:32.880 --> 00:09:36.170
And this is needed because we
want to know exact coordinate

00:09:36.170 --> 00:09:39.810
of every method we are calling
without parsing and reading

00:09:39.810 --> 00:09:40.610
all the files.

00:09:40.610 --> 00:09:45.430
Again, so you should have a
method defined in other class

00:09:45.430 --> 00:09:48.550
and I'm calling it
from other class.

00:09:48.550 --> 00:09:51.600
On the call side, I want to know
exactly which method I'm

00:09:51.600 --> 00:09:51.910
calling.

00:09:51.910 --> 00:09:53.760
If you have a situation
with [UNINTELLIGIBLE]

00:09:53.760 --> 00:09:57.775
methods for example, you don't
know which method you are

00:09:57.775 --> 00:09:57.890
calling, right?

00:09:57.890 --> 00:10:02.820
So you need the full signature
to know which methods you are

00:10:02.820 --> 00:10:05.300
calling.

00:10:05.300 --> 00:10:08.950
And yes, Jribble files are
verbose enough that they can

00:10:08.950 --> 00:10:10.600
be parsed separately.

00:10:10.600 --> 00:10:16.440
So you parse them in
an independent way.

00:10:16.440 --> 00:10:22.670
So this is the architecture of
my project and the bottom

00:10:22.670 --> 00:10:28.630
thing-- Java to gwtc-- it was
before I started doing--

00:10:28.630 --> 00:10:30.430
hacking my stuff.

00:10:30.430 --> 00:10:37.772
And I introduced the
fragment on top.

00:10:37.772 --> 00:10:42.245
And it consists of two pieces so
you have a Jribble backend

00:10:42.245 --> 00:10:46.580
on scalac side which means I
implemented new backend for

00:10:46.580 --> 00:10:50.880
Scala compiler which instead of
generating Java bytecode it

00:10:50.880 --> 00:10:52.470
generates Jribble.

00:10:52.470 --> 00:10:53.960
OK?

00:10:53.960 --> 00:11:00.470
And then on GWT side I
implemented a way to parse

00:11:00.470 --> 00:11:05.690
these files in GWT with ASP
nodes out of these files.

00:11:05.690 --> 00:11:09.660
And the thing in center is
the Jribble library.

00:11:09.660 --> 00:11:16.380
So it basically-- it defines
Jribble language and it

00:11:16.380 --> 00:11:20.030
defines a parser for Jribble
language and things like that.

00:11:20.030 --> 00:11:24.970
So I thought it would be
beneficial for you to have an

00:11:24.970 --> 00:11:29.465
idea how Jribble looks like, how
Jribble code looks like.

00:11:29.465 --> 00:11:30.990
So as you can see it's
very verbose.

00:11:30.990 --> 00:11:37.370
Like for everywhere you
reference or define a class

00:11:37.370 --> 00:11:42.410
you have always fully
qualified reference.

00:11:42.410 --> 00:11:49.410
We replaced dots with slashes
for references.

00:11:49.410 --> 00:11:55.490
And you can see massive
signature in this line before

00:11:55.490 --> 00:11:59.870
parameter list. So that's
how Jribble looks like.

00:12:02.860 --> 00:12:07.520
And now I will go into more
details on each side: on Scala

00:12:07.520 --> 00:12:12.130
side, Jribble side and GWT side,
what I was really doing

00:12:12.130 --> 00:12:13.380
there.

00:12:15.580 --> 00:12:19.450
So on the scalac side, it was
just another backend.

00:12:19.450 --> 00:12:24.040
So Scala has JVM backend which
compiles Scala code into

00:12:24.040 --> 00:12:25.360
bytecode.

00:12:25.360 --> 00:12:28.130
And it has backend to target
[UNINTELLIGIBLE]

00:12:28.130 --> 00:12:33.400
bytecode which I don't
know status of.

00:12:33.400 --> 00:12:38.030
And the nice thing about the
fact that this is another

00:12:38.030 --> 00:12:42.950
backend is it's isolated from
the rest of the compiler.

00:12:42.950 --> 00:12:46.190
So I'm not really messing with
internal parts of the

00:12:46.190 --> 00:12:46.550
compiler.

00:12:46.550 --> 00:12:53.260
It's like I'm just getting--
at the last phase of the

00:12:53.260 --> 00:12:58.530
compiling I just plug in my new
backend and then I create

00:12:58.530 --> 00:13:02.485
output in form of Jribble.

00:13:02.485 --> 00:13:08.455
So that is important property
because if Scala compiler guys

00:13:08.455 --> 00:13:12.730
are going to accept my code they
want to be sure that I

00:13:12.730 --> 00:13:18.500
don't really mess up with
their own functionality.

00:13:18.500 --> 00:13:22.880
I don't introduce new bugs
and things like that.

00:13:22.880 --> 00:13:26.286
And this backend includes both
transformations and printing

00:13:26.286 --> 00:13:29.100
of trees like abstract
syntax trees.

00:13:29.100 --> 00:13:34.655
Which means I first meed to
normalize trees in a way that

00:13:34.655 --> 00:13:37.935
they are more similar
to Java construct.

00:13:37.935 --> 00:13:41.480
So for example in Scala
everything is an expression.

00:13:41.480 --> 00:13:47.350
Like you can have-- like
block is an expresion.

00:13:47.350 --> 00:13:53.400
If statements-- which is a
statement in Java, in Scala

00:13:53.400 --> 00:13:54.681
it's an expression.

00:13:54.681 --> 00:13:57.140
It's actually a nice replacement
for conditional

00:13:57.140 --> 00:13:58.830
operator in Java.

00:13:58.830 --> 00:14:02.190
So then you have to normalize
all these things so that they

00:14:02.190 --> 00:14:03.920
are, again, become
an expression.

00:14:03.920 --> 00:14:06.720
So this is the transformation
part.

00:14:06.720 --> 00:14:09.233
And it really is simply
formatting the trees in the

00:14:09.233 --> 00:14:11.630
form of Jribble.

00:14:11.630 --> 00:14:18.300
And another thing I had to
implement was extending scalac

00:14:18.300 --> 00:14:23.540
internal testing framework which
is called partest. They

00:14:23.540 --> 00:14:27.210
have their own testing framework
and I had to add

00:14:27.210 --> 00:14:28.600
support for Jribble.

00:14:28.600 --> 00:14:32.440
And then the whole thing is
implemented in Scala which is

00:14:32.440 --> 00:14:35.260
nice to work with.

00:14:35.260 --> 00:14:40.450
And the challenges I faced on
scalac side is as I mentioned,

00:14:40.450 --> 00:14:43.795
many expressions in Scala are
not expressions in Jribble.

00:14:43.795 --> 00:14:47.770
So you have to really think
carefully how to translate

00:14:47.770 --> 00:14:52.698
these constructs to valid
Jribble constructs.

00:14:52.698 --> 00:14:58.300
And the second problem is
really, really difficult and I

00:14:58.300 --> 00:14:59.440
don't have any good answer.

00:14:59.440 --> 00:15:03.652
So that is pattern matching
logic which pattern matching

00:15:03.652 --> 00:15:06.830
is very powerful in Scala.

00:15:06.830 --> 00:15:12.500
But the internal implementation
can emit

00:15:12.500 --> 00:15:13.596
arbitrary jumps.

00:15:13.596 --> 00:15:19.014
So it means you have some form
of goto instruction that is

00:15:19.014 --> 00:15:22.821
being used to implement pattern
matching-- and again,

00:15:22.821 --> 00:15:23.610
I have the same problem.

00:15:23.610 --> 00:15:26.710
I cannot emit goto expressions
in Jribble.

00:15:26.710 --> 00:15:32.190
And I tried some tricks to
override goto into massive

00:15:32.190 --> 00:15:36.645
calls and things like that but
I'm still not sure how

00:15:36.645 --> 00:15:42.180
reliable this is and this can
lead to stack overflow, call

00:15:42.180 --> 00:15:44.130
exceptions and things
like that.

00:15:44.130 --> 00:15:48.930
So this is really
difficult part.

00:15:48.930 --> 00:15:55.880
And Scala has unification of
types which means basically--

00:15:55.880 --> 00:15:59.940
first of all, everything
is an object in Scala.

00:15:59.940 --> 00:16:05.952
And there are two types which
are call Nothing and Unit.

00:16:05.952 --> 00:16:09.555
Unit is similar to void in
Java but in Java it's not

00:16:09.555 --> 00:16:12.970
really type because you cannot
have a variable of void.

00:16:12.970 --> 00:16:17.740
And in Scala you can't have
a variable of type void.

00:16:17.740 --> 00:16:22.030
And Nothing is probably-- OK,
if you know what is bottom

00:16:22.030 --> 00:16:24.250
type than this is Nothing.

00:16:24.250 --> 00:16:28.870
If you don't know I won't be
going into details because

00:16:28.870 --> 00:16:34.030
it's like kind of-- you need
some time to explain it.

00:16:34.030 --> 00:16:39.245
But my infestation of this
unification is the expression

00:16:39.245 --> 00:16:39.800
in the bottom there.

00:16:39.800 --> 00:16:45.110
You you see like that true
all-- and you have an

00:16:45.110 --> 00:16:48.262
expression which is throwing
an exception.

00:16:48.262 --> 00:16:50.250
And it has actually
type Nothing.

00:16:53.860 --> 00:16:58.490
And another problem is our
operator both in Scala and

00:16:58.490 --> 00:17:00.290
Java is likely overweighted.

00:17:00.290 --> 00:17:02.320
OK?

00:17:02.320 --> 00:17:04.282
So it doesn't throw an exception
because on the

00:17:04.282 --> 00:17:05.980
left-hand side you have
[UNINTELLIGIBLE]

00:17:05.980 --> 00:17:07.525
so it doesn't really
[UNINTELLIGIBLE]

00:17:07.525 --> 00:17:10.940
right-hand side and it just
returns a result.

00:17:10.940 --> 00:17:17.160
Translating it to Java or
Jribble needs some careful

00:17:17.160 --> 00:17:18.400
thinking and attention.

00:17:18.400 --> 00:17:21.870
It's really tricky part.

00:17:21.870 --> 00:17:27.970
Actually I have still a lot of
bugs around this kind of

00:17:27.970 --> 00:17:30.850
constructing in Jribble
backend.

00:17:30.850 --> 00:17:35.750
So it's still not resolved
completely.

00:17:35.750 --> 00:17:39.090
So that's all about
Scala side.

00:17:39.090 --> 00:17:41.986
And there's Jribble side.

00:17:41.986 --> 00:17:45.340
So Jribble consists of language
specification.

00:17:45.340 --> 00:17:48.164
Right now the language
specification is only

00:17:48.164 --> 00:17:49.050
implementation.

00:17:49.050 --> 00:17:53.110
I didn't have separate
specification.

00:17:53.110 --> 00:17:58.710
I plan to have one but I didn't
have time to define it.

00:17:58.710 --> 00:18:02.966
And Jribble is a library.

00:18:02.966 --> 00:18:07.900
So it defines AST nodes,
parsers, printers-- things you

00:18:07.900 --> 00:18:10.850
usually want for a language.

00:18:10.850 --> 00:18:15.190
And it's written in Scala which
was, again, fun to work

00:18:15.190 --> 00:18:17.280
with.

00:18:17.280 --> 00:18:21.630
And the last point is for
people interested in or

00:18:21.630 --> 00:18:23.370
familiar with Scala.

00:18:23.370 --> 00:18:26.290
I'm using Scala library
for parsing.

00:18:26.290 --> 00:18:32.260
And you have an example of how
parse rules look like.

00:18:32.260 --> 00:18:36.515
And this is just Scala code and
it's DSL, so it's a nice

00:18:36.515 --> 00:18:37.940
library too.

00:18:37.940 --> 00:18:40.615
And you still can read
what's happening.

00:18:40.615 --> 00:18:47.520
It's a parser for parsing
while statement.

00:18:47.520 --> 00:18:51.985
And I was actually very, very
happy when I was using this

00:18:51.985 --> 00:18:52.096
library.

00:18:52.096 --> 00:18:55.380
I think it's a really,
really good one.

00:18:55.380 --> 00:18:58.970
Just to comment on that.

00:18:58.970 --> 00:19:02.350
And there was actually an
interesting problem how to

00:19:02.350 --> 00:19:03.600
test parsers.

00:19:07.670 --> 00:19:10.800
Language like Jribble
is actually complex.

00:19:10.800 --> 00:19:14.510
So if you look at the grammar,
it's complicated.

00:19:14.510 --> 00:19:19.530
So then there is a challenge how
to really test parsers--

00:19:19.530 --> 00:19:22.470
if it's parsing everything
correctly.

00:19:22.470 --> 00:19:26.310
Like writing casual union
tests is really, really

00:19:26.310 --> 00:19:27.560
tiring.

00:19:29.980 --> 00:19:30.844
I don't know.

00:19:30.844 --> 00:19:36.622
I would have to write hundreds
of union tests and then I'd

00:19:36.622 --> 00:19:40.800
parse a fragment of source
code and I would need to

00:19:40.800 --> 00:19:44.933
create all AST nodes by hanging
the code to check if

00:19:44.933 --> 00:19:45.630
things are equal.

00:19:45.630 --> 00:19:49.727
It's really, really tiring and
probably would give up after

00:19:49.727 --> 00:19:54.124
10 tests.

00:19:54.124 --> 00:19:58.070
So I decided to go
another road.

00:19:58.070 --> 00:20:01.970
And if you think what
is a parser?

00:20:01.970 --> 00:20:09.640
It's basically a function from
a string to AST node.

00:20:09.640 --> 00:20:14.230
And you can define the printer
which goes in the opposite

00:20:14.230 --> 00:20:14.600
direction.

00:20:14.600 --> 00:20:20.320
It takes AST node and it
prints it to a string.

00:20:20.320 --> 00:20:22.790
And you can compose
this to function.

00:20:22.790 --> 00:20:27.850
So you take the parser-- sorry,
printer-- and then

00:20:27.850 --> 00:20:32.620
parser and what you should get
is just a function of an AST

00:20:32.620 --> 00:20:33.816
node, OK?

00:20:33.816 --> 00:20:38.670
So once you have this
observation what you need is

00:20:38.670 --> 00:20:40.522
lots of AST nodes.

00:20:40.522 --> 00:20:45.680
Just to test the quality
of functions.

00:20:45.680 --> 00:20:49.750
And I'm using ScalaCheck
framework to generate lots and

00:20:49.750 --> 00:20:51.210
lots of AST nodes.

00:20:51.210 --> 00:20:56.340
And using this approach I've
got more than 3,000 tests,

00:20:56.340 --> 00:21:01.650
random tests, for parser.

00:21:01.650 --> 00:21:06.470
And this approach turned out to
be very, very beneficial.

00:21:06.470 --> 00:21:10.700
So I told myself many times
during the summer that I had

00:21:10.700 --> 00:21:14.505
to refactor and change the
groundwork Jribble first of

00:21:14.505 --> 00:21:19.220
all because I didn't think of
some special case or special

00:21:19.220 --> 00:21:20.600
need.

00:21:20.600 --> 00:21:24.560
So I had to refactor like half
of the grammar of Jribble and

00:21:24.560 --> 00:21:30.490
as a consequence I had to
refactor the parsing code.

00:21:30.490 --> 00:21:33.180
I wasn't really afraid of doing
that because I had so

00:21:33.180 --> 00:21:36.100
many tests and they were
catching every mistake you can

00:21:36.100 --> 00:21:38.320
imagine.

00:21:38.320 --> 00:21:44.440
Random testing is very good
about boundary conditions that

00:21:44.440 --> 00:21:48.840
you usually don't think of or
you are too lazy to really

00:21:48.840 --> 00:21:50.960
test every boundary condition.

00:21:50.960 --> 00:21:57.130
And usually there are bugs
really often waiting for you

00:21:57.130 --> 00:21:58.180
for these boundary conditions.

00:21:58.180 --> 00:21:59.240
So I really loved it.

00:21:59.240 --> 00:22:02.130
And I was using Simple Build
Tool which is like a

00:22:02.130 --> 00:22:03.920
replacement for [UNINTELLIGIBLE]

00:22:03.920 --> 00:22:08.512
which is much, much for building
and running tests and

00:22:08.512 --> 00:22:10.280
everything.

00:22:10.280 --> 00:22:16.720
So Jribble challenges: Language
must encode a lot of

00:22:16.720 --> 00:22:17.748
information.

00:22:17.748 --> 00:22:21.930
So normally what you have, you
have a source code and

00:22:21.930 --> 00:22:25.994
compiler is reading your source
code and once it has

00:22:25.994 --> 00:22:29.605
the whole source code in memory,
it tries to recover

00:22:29.605 --> 00:22:32.640
the information that is not
explicit in your source code.

00:22:32.640 --> 00:22:38.070
So for example, if you are
calling a method, based on all

00:22:38.070 --> 00:22:41.785
information it will calculate
coordinates of the message you

00:22:41.785 --> 00:22:42.220
are really calling.

00:22:42.220 --> 00:22:42.570
OK?

00:22:42.570 --> 00:22:46.365
Because it's not really explicit
in source code which

00:22:46.365 --> 00:22:48.830
methods you are trying
to call.

00:22:48.830 --> 00:22:51.440
And there are many, many
other things like that.

00:22:51.440 --> 00:22:56.640
Like you reference a field and
in the place where you

00:22:56.640 --> 00:22:59.870
reference the field and you
don't have information of the

00:22:59.870 --> 00:23:01.980
type of that field.

00:23:01.980 --> 00:23:02.310
OK?

00:23:02.310 --> 00:23:05.890
You have to go to the definition
of the field to see

00:23:05.890 --> 00:23:08.370
the type and things like that.

00:23:08.370 --> 00:23:11.144
So it's very, very verbose.

00:23:11.144 --> 00:23:14.535
If you compile Scala's standard
library to Jribble

00:23:14.535 --> 00:23:18.606
it's almost 60 megabytes
of Jribble output.

00:23:18.606 --> 00:23:20.790
It's so huge.

00:23:20.790 --> 00:23:23.656
But it compresses very well.

00:23:23.656 --> 00:23:26.682
So you can go down to-- as far
as I can remember with

00:23:26.682 --> 00:23:30.335
standard disk compression
to nine megabytes.

00:23:30.335 --> 00:23:32.840
So it's so verbose
and so repeated.

00:23:32.840 --> 00:23:39.190
And actually the most
significant reason for so huge

00:23:39.190 --> 00:23:43.610
size is because we have fully
qualified references

00:23:43.610 --> 00:23:46.360
everywhere, right, so you repeat
this information all

00:23:46.360 --> 00:23:47.490
the time.

00:23:47.490 --> 00:23:53.870
And grammar turned out to be
complicated enough to make

00:23:53.870 --> 00:23:55.550
parsing challenging.

00:23:55.550 --> 00:24:01.270
Which means it's almost like
Java with some things being

00:24:01.270 --> 00:24:01.710
removed.

00:24:01.710 --> 00:24:06.960
But I had similar problems that
people flagged when they

00:24:06.960 --> 00:24:11.972
tried to parse Java.

00:24:11.972 --> 00:24:21.710
And the last point is parser
combinators were invented by

00:24:21.710 --> 00:24:24.740
functional programming
community.

00:24:24.740 --> 00:24:29.370
And they are really,
really functional.

00:24:29.370 --> 00:24:32.635
Basically the parsers are
constructed of lots of

00:24:32.635 --> 00:24:34.480
[UNINTELLIGIBLE].

00:24:34.480 --> 00:24:38.820
The problem with that is for a
lot of Scala code, if you're

00:24:38.820 --> 00:24:43.230
compiling to bytecode, it maps
to-- like method calls are

00:24:43.230 --> 00:24:44.670
being mapped to message calls.

00:24:44.670 --> 00:24:49.700
And if you tried to used Java
tools for filing, you're fine.

00:24:49.700 --> 00:24:54.360
You might get strange method
names because Scala compiler

00:24:54.360 --> 00:25:00.050
is doing a method name
modeling sometimes.

00:25:00.050 --> 00:25:00.760
But still you are fine.

00:25:00.760 --> 00:25:05.420
But for highly functional code,
I tried profiling with

00:25:05.420 --> 00:25:06.433
[UNINTELLIGIBLE]

00:25:06.433 --> 00:25:08.860
and the result was
really horrible.

00:25:08.860 --> 00:25:15.110
I couldn't get any useful
information of the results

00:25:15.110 --> 00:25:15.536
that's good.

00:25:15.536 --> 00:25:19.560
Because what you really need
is to profile how much time

00:25:19.560 --> 00:25:23.150
you spend on evaluating the
expression and not really

00:25:23.150 --> 00:25:24.246
culling a method.

00:25:24.246 --> 00:25:27.030
So you have complicated
expression and you would like

00:25:27.030 --> 00:25:30.720
to know how much time you
spent on evaluating an

00:25:30.720 --> 00:25:32.100
expression.

00:25:32.100 --> 00:25:39.000
And Java profile's going to give
you that information and

00:25:39.000 --> 00:25:41.790
my approach will probably
be to implement special

00:25:41.790 --> 00:25:46.660
combinator for this parser
and use speechwriter.

00:25:46.660 --> 00:25:51.610
So I guess it might be
interesting for you.

00:25:51.610 --> 00:25:57.940
I looked into that problem and
it would be a good approach.

00:25:57.940 --> 00:25:59.682
So now gwtc side.

00:26:02.245 --> 00:26:11.470
On the GWT side I just plugged
my Jribble library in parallel

00:26:11.470 --> 00:26:13.780
to JDT.

00:26:13.780 --> 00:26:18.090
So it's like a parallel path.

00:26:18.090 --> 00:26:24.250
And what I need to do is parse
Jribble files which is being

00:26:24.250 --> 00:26:25.706
handled by Jribble library.

00:26:25.706 --> 00:26:28.980
Parsing, everything is being
done by that library.

00:26:28.980 --> 00:26:34.311
So I get AST nodes of Jribble
form and I need to translate

00:26:34.311 --> 00:26:36.350
them to GWT AST nodes.

00:26:36.350 --> 00:26:40.960
And Jribble is designed and
defined to be as close to Java

00:26:40.960 --> 00:26:43.510
as possible, so translation
is usually very, very

00:26:43.510 --> 00:26:44.370
straightforward.

00:26:44.370 --> 00:26:48.900
Just take one AST node and
translation is basically

00:26:48.900 --> 00:26:51.970
almost always one to one.

00:26:51.970 --> 00:26:56.770
And the nice about this approach
is that, again, it's

00:26:56.770 --> 00:27:03.640
isolated from the rest of gwtc
internal data structures and

00:27:03.640 --> 00:27:04.740
functionality.

00:27:04.740 --> 00:27:06.790
And yes, that was
the approach.

00:27:06.790 --> 00:27:12.320
You define everything in Jribble
and you have as small

00:27:12.320 --> 00:27:14.810
an impact on GWT as possible.

00:27:14.810 --> 00:27:23.750
So again, I really tried to make
it focused so it can be

00:27:23.750 --> 00:27:29.230
merged eventually to official
release I hope.

00:27:29.230 --> 00:27:35.900
So GWT challenges: Obviously I
had to program in Java again.

00:27:35.900 --> 00:27:38.090
And that was quite painful.

00:27:38.090 --> 00:27:42.625
I don't like to go into
details but it is.

00:27:47.580 --> 00:27:52.600
That's one point but another
point is you have really a lot

00:27:52.600 --> 00:27:53.870
of these AST nodes.

00:27:53.870 --> 00:27:55.680
Really, really a lot of them.

00:27:55.680 --> 00:28:01.350
And every single set is
straightforward but due to the

00:28:01.350 --> 00:28:06.805
large number of cases you'd
spend the entire day doing the

00:28:06.805 --> 00:28:09.730
same thing which is tiring.

00:28:09.730 --> 00:28:12.730
And especially if you realize
that you could do pattern

00:28:12.730 --> 00:28:18.580
matching and you'd get 10 times
smaller code if you once

00:28:18.580 --> 00:28:19.496
worked in Scala.

00:28:19.496 --> 00:28:26.150
And so the third point is it's
kind of a complaint but I

00:28:26.150 --> 00:28:28.790
don't say I have a better
answer to that.

00:28:28.790 --> 00:28:33.980
So in terms of data structures
in GWT working in the way you

00:28:33.980 --> 00:28:38.120
create like empty AST nodes and
then in second phase you

00:28:38.120 --> 00:28:40.380
add more information.

00:28:40.380 --> 00:28:43.872
And it's so easy to
miss something.

00:28:43.872 --> 00:28:48.020
And sometimes at the very
beginning of my project I

00:28:48.020 --> 00:28:56.630
missed a super-- I missed
filling in information about

00:28:56.630 --> 00:29:00.280
interfaces a class implements
and I spent two days because

00:29:00.280 --> 00:29:04.190
GWT compiler didn't blow
up or anything.

00:29:04.190 --> 00:29:06.680
It would produce me
JavaScript code.

00:29:06.680 --> 00:29:09.750
And then it's really fun to go
back in JavaScript code,

00:29:09.750 --> 00:29:10.200
right?

00:29:10.200 --> 00:29:14.800
So I spent two days to really
find I missed like one or two

00:29:14.800 --> 00:29:19.670
lines of code just coding
this information.

00:29:19.670 --> 00:29:23.682
And I don't know if there is
any good answer to that

00:29:23.682 --> 00:29:25.976
problem but I'm not
[UNINTELLIGIBLE]

00:29:25.976 --> 00:29:26.770
like that.

00:29:26.770 --> 00:29:29.960
A serious problem.

00:29:29.960 --> 00:29:35.926
So right now I should present
something working I guess.

00:29:35.926 --> 00:29:37.860
It's a good time.

00:29:37.860 --> 00:29:45.125
And people from GWT team found
[UNINTELLIGIBLE PHRASE]

00:29:45.125 --> 00:29:48.570
working I guess two
months ago.

00:29:48.570 --> 00:29:52.310
And the funny thing is that I
still had [UNINTELLIGIBLE]

00:29:52.310 --> 00:29:54.980
working and nothing else.

00:29:54.980 --> 00:29:59.380
So after two months of work--
really, really hard work-- I

00:29:59.380 --> 00:30:02.740
get only really, really
tiny improvements.

00:30:02.740 --> 00:30:06.020
So I don't know if you guys
remember that and other people

00:30:06.020 --> 00:30:09.360
watching cannot remember that.

00:30:09.360 --> 00:30:11.541
But I had a [UNINTELLIGIBLE]

00:30:11.541 --> 00:30:14.680
finishing here before--

00:30:14.680 --> 00:30:16.480
We can't see.

00:30:16.480 --> 00:30:20.699
Oh, OK, sorry.

00:30:20.699 --> 00:30:23.192
Now you can see?

00:30:23.192 --> 00:30:24.180
Yep.

00:30:24.180 --> 00:30:26.650
I think font size
could be bigger.

00:30:26.650 --> 00:30:28.132
Ah very good.

00:30:28.132 --> 00:30:28.630
Yeah that's better.

00:30:28.630 --> 00:30:29.362
OK.

00:30:29.362 --> 00:30:34.435
So the problem is I don't
see this on my screen.

00:30:37.380 --> 00:30:37.660
OK.

00:30:37.660 --> 00:30:40.260
Now I see.

00:30:40.260 --> 00:30:45.240
So two months ago the only
difference between this demo

00:30:45.240 --> 00:30:52.080
and the demo I presented two
months was that I had

00:30:52.080 --> 00:30:52.560
[UNINTELLIGIBLE]

00:30:52.560 --> 00:30:56.440
class to finish here
for defining

00:30:56.440 --> 00:30:58.100
[UNINTELLIGIBLE PHRASE]

00:30:58.100 --> 00:30:58.330
OK?

00:30:58.330 --> 00:31:01.380
And the only progress I got
is implementing that

00:31:01.380 --> 00:31:07.412
functionality on scalac side and
Jribble and gwtc side to

00:31:07.412 --> 00:31:12.690
replace this with lambda
definition and with implicit

00:31:12.690 --> 00:31:13.010
definition.

00:31:13.010 --> 00:31:17.140
So what's happening for people
who are not familiar with

00:31:17.140 --> 00:31:20.905
Scala is here I have the
lambda definition.

00:31:20.905 --> 00:31:26.050
It says I don't care about
parameter because I didn't use

00:31:26.050 --> 00:31:27.880
it on the right-hand side.

00:31:27.880 --> 00:31:35.100
And so it's a function from
ClickEvent to [UNINTELLIGIBLE]

00:31:35.100 --> 00:31:36.380
or Unit.

00:31:36.380 --> 00:31:41.490
So I'll pass a lambda
function here, OK?

00:31:41.490 --> 00:31:45.380
To the bottom right obviously
a button expects-- oh, I

00:31:45.380 --> 00:31:49.650
cannot see-- it expects
a ClickHandler.

00:31:49.650 --> 00:31:53.300
So what I do-- and this is
usually defining in some

00:31:53.300 --> 00:31:59.520
library router or something you
always reuse-- so you're

00:31:59.520 --> 00:32:04.600
defining implicit convention
from function which goes from

00:32:04.600 --> 00:32:08.003
ClickEvent to Unit-- and
remember Unit is like a void

00:32:08.003 --> 00:32:13.802
in Java-- which returns
a ClickHandler.

00:32:13.802 --> 00:32:19.260
And here you have this analysis
class definition with

00:32:19.260 --> 00:32:24.770
a method and onClick will call
it the function you pass.

00:32:24.770 --> 00:32:30.480
So basically Scala compiler
works in a way that if it sees

00:32:30.480 --> 00:32:33.405
something that doesn't type
check-- that type doesn't

00:32:33.405 --> 00:32:36.460
match-- then it tries to find
an implicit definition that

00:32:36.460 --> 00:32:39.207
will make the inserts
compile, OK?

00:32:39.207 --> 00:32:43.880
And this is what's happening
in this sample.

00:32:43.880 --> 00:32:46.850
And this works.

00:32:46.850 --> 00:32:50.616
So I can show you it
compiles hopefully.

00:32:50.616 --> 00:32:51.866
[TYPING]

00:33:01.110 --> 00:33:06.020
And while this is being done
I can tell you that this is

00:33:06.020 --> 00:33:09.780
surprisingly hard
to get right.

00:33:09.780 --> 00:33:15.170
Because you need to implement
static fields.

00:33:15.170 --> 00:33:16.255
And actually I'm
cheating here.

00:33:16.255 --> 00:33:19.990
It still looks like you take a
Scala library because it needs

00:33:19.990 --> 00:33:22.636
Scala library which defines
functions and things like

00:33:22.636 --> 00:33:23.530
that.

00:33:23.530 --> 00:33:29.335
So it looks Scala library is
being compiled and I'm just

00:33:29.335 --> 00:33:32.080
using Scala library and
everything worked.

00:33:32.080 --> 00:33:36.640
I hit to manually remove some
things because surprisingly

00:33:36.640 --> 00:33:40.700
enough Scala function
definitions depend on Scala

00:33:40.700 --> 00:33:42.880
collections which I didn't
even realize.

00:33:42.880 --> 00:33:46.040
And Scala collections use all
language features you can

00:33:46.040 --> 00:33:46.950
imagine.

00:33:46.950 --> 00:33:51.830
They are so advanced that they
simply use everything.

00:33:51.830 --> 00:33:59.810
And yes, here we've got this
resolve compilation and it's

00:33:59.810 --> 00:34:01.040
called example.

00:34:01.040 --> 00:34:02.290
[TYPING]

00:34:26.510 --> 00:34:27.650
OK.

00:34:27.650 --> 00:34:31.290
And hopefully nothing
will break.

00:34:31.290 --> 00:34:32.984
I click a button, I get
[UNINTELLIGIBLE]

00:34:32.984 --> 00:34:34.010
from Scala, right?

00:34:34.010 --> 00:34:35.260
[APPLAUSE]

00:34:38.850 --> 00:34:41.810
This is the only thing
I've done.

00:34:41.810 --> 00:34:45.739
Like anything else more
sophisticated really is Scala

00:34:45.739 --> 00:34:46.199
collection, OK?

00:34:46.199 --> 00:34:49.887
You need a list or map or
something to get anything

00:34:49.887 --> 00:34:50.136
done.

00:34:50.136 --> 00:34:55.000
And then you pull in all the
collections from Scala and

00:34:55.000 --> 00:34:59.210
this is-- so basically you
need 100% of all Scala

00:34:59.210 --> 00:35:02.100
features to get anything
running.

00:35:02.100 --> 00:35:06.930
And I will switch back to slides
and just comment more

00:35:06.930 --> 00:35:07.930
on that.

00:35:07.930 --> 00:35:09.325
So is there anything more?

00:35:12.750 --> 00:35:16.456
There no gradual progress in
this project which is really,

00:35:16.456 --> 00:35:17.330
really disappointing, OK?

00:35:17.330 --> 00:35:20.260
It's been like two weeks and
there is nothing running

00:35:20.260 --> 00:35:20.690
completely.

00:35:20.690 --> 00:35:22.710
Oh, just a bunch
of unit tests.

00:35:22.710 --> 00:35:23.630
And that's all.

00:35:23.630 --> 00:35:29.022
And as you can see, two months
later I have almost nothing

00:35:29.022 --> 00:35:33.470
better running in terms
of GWT applications.

00:35:33.470 --> 00:35:39.382
And I already told that Scala
collections library exploits

00:35:39.382 --> 00:35:41.160
every language feature.

00:35:41.160 --> 00:35:42.455
So where are we at?

00:35:42.455 --> 00:35:45.020
What is the picture
of this project?

00:35:45.020 --> 00:35:52.660
And if we recall our diagram,
I've got most of things

00:35:52.660 --> 00:35:57.160
implemented on the left-hand
side and in the center of this

00:35:57.160 --> 00:35:58.170
diagram.

00:35:58.170 --> 00:36:04.780
Which means I can compile
entire Scala library in

00:36:04.780 --> 00:36:08.140
Jribble with some little bugs
that I am aware of.

00:36:08.140 --> 00:36:11.796
But I know how to fix them.

00:36:11.796 --> 00:36:13.940
Most of them I know
how to fix them.

00:36:13.940 --> 00:36:22.150
And the result is that I can
parse 96% of Jribble files for

00:36:22.150 --> 00:36:27.670
standard Scala library which
corresponds to more than 4,400

00:36:27.670 --> 00:36:28.180
files.

00:36:28.180 --> 00:36:31.670
So this is kind of
big achievement.

00:36:31.670 --> 00:36:35.950
I told you that it exploits
almost all the language

00:36:35.950 --> 00:36:37.200
features.

00:36:38.885 --> 00:36:42.070
I've got 4% remaining.

00:36:42.070 --> 00:36:43.790
And again, this is fun.

00:36:43.790 --> 00:36:49.765
I've got 90% running quite
quickly and then next every

00:36:49.765 --> 00:36:52.170
percent is like few
days of working.

00:36:52.170 --> 00:36:57.300
OK, so for the 6% it was like
two weeks to get this.

00:36:57.300 --> 00:37:02.920
And I would expect the 4% would
be like a month to get

00:37:02.920 --> 00:37:05.990
done and correct.

00:37:05.990 --> 00:37:08.590
Because it involves things which
are most complicated:

00:37:08.590 --> 00:37:11.800
Unit, Nothing and pattern
matching logic.

00:37:11.800 --> 00:37:16.970
And the missing part is the
right-hand side of this

00:37:16.970 --> 00:37:22.940
diagram which is getting
everything, every possible

00:37:22.940 --> 00:37:25.550
node translated.

00:37:25.550 --> 00:37:30.760
And I thought this was easy but
I discovered last night

00:37:30.760 --> 00:37:35.030
that I forgot that GWT doesn't
support entire Java library,

00:37:35.030 --> 00:37:36.660
standard library, right?

00:37:36.660 --> 00:37:40.940
So Scala library, standard
library, in a few places

00:37:40.940 --> 00:37:46.710
depends on Java standard
library.

00:37:46.710 --> 00:37:52.270
And now the only thing you
can do is write by hand

00:37:52.270 --> 00:37:54.540
replacements of that
functionality.

00:37:54.540 --> 00:37:59.270
It's the same way how GWT
[UNINTELLIGIBLE PHRASE]

00:37:59.270 --> 00:38:03.590
in standard Java library.

00:38:03.590 --> 00:38:04.796
And this is actually
a lot of work.

00:38:04.796 --> 00:38:09.480
You have to go through every
file, check everything or

00:38:09.480 --> 00:38:14.125
create a framework that would be
checking for you for things

00:38:14.125 --> 00:38:16.410
that are not allowed in GWT.

00:38:16.410 --> 00:38:18.526
Yeah, it's kind of
a lot of work.

00:38:18.526 --> 00:38:23.070
To comment on the status of the
project, I believe that

00:38:23.070 --> 00:38:27.400
two months of really good
engineering work would bring

00:38:27.400 --> 00:38:33.700
you to Showcase it working but
still inefficient, maybe with

00:38:33.700 --> 00:38:38.600
bugs, and definitely won't
support, only from code line.

00:38:38.600 --> 00:38:39.110
OK?

00:38:39.110 --> 00:38:45.740
So this is like two months of
engineering still missing.

00:38:45.740 --> 00:38:50.670
So, I mentioned Showcase many
times so I think at the end of

00:38:50.670 --> 00:38:52.852
my talk I would like to
go through quickly.

00:38:57.150 --> 00:39:02.353
It's like a big application
showing lots of GWT features.

00:39:02.353 --> 00:39:07.362
But it's complicated enough that
you could imagine that if

00:39:07.362 --> 00:39:10.806
there was any point in this
project then Scala should

00:39:10.806 --> 00:39:11.540
really shine.

00:39:11.540 --> 00:39:12.340
OK?

00:39:12.340 --> 00:39:16.600
And there was external
contribution to my project.

00:39:16.600 --> 00:39:21.900
There was a person that started
translating Showcase

00:39:21.900 --> 00:39:23.150
into Scala.

00:39:25.420 --> 00:39:29.090
And we will go through that.

00:39:29.090 --> 00:39:31.886
This is the fragment that I
presented at the beginning of

00:39:31.886 --> 00:39:33.010
my talk.

00:39:33.010 --> 00:39:40.154
And what is happening here is
you set up many options and

00:39:40.154 --> 00:39:45.153
you repeat the same method call
all the time-- do I have

00:39:45.153 --> 00:39:46.920
a laser thing?

00:39:46.920 --> 00:39:47.770
Yes.

00:39:47.770 --> 00:39:55.145
So what's happening is you call
a set of many options all

00:39:55.145 --> 00:39:56.970
the time and the first parameter
and the last

00:39:56.970 --> 00:39:58.590
parameter is the same.

00:39:58.590 --> 00:40:01.393
The only thing that is changing
is the second

00:40:01.393 --> 00:40:02.080
parameter, OK?

00:40:02.080 --> 00:40:10.420
So it's kind of obvious that
this should be refactored in a

00:40:10.420 --> 00:40:15.150
form that this repetition
is removed.

00:40:15.150 --> 00:40:17.400
And with Java you
probably could.

00:40:17.400 --> 00:40:19.210
You'd find another method.

00:40:19.210 --> 00:40:23.860
But this is like nobody does
it because it's too

00:40:23.860 --> 00:40:24.580
heavyweight.

00:40:24.580 --> 00:40:27.450
So in Scala it's very natural.

00:40:27.450 --> 00:40:31.050
What's happening is you define
a list of things you want to

00:40:31.050 --> 00:40:32.380
pass through to method.

00:40:32.380 --> 00:40:38.220
And then you say for each and--
you have these method

00:40:38.220 --> 00:40:38.550
call.

00:40:38.550 --> 00:40:42.530
But with second thing you could
underscore which means

00:40:42.530 --> 00:40:45.525
you take every element of the
list and pass through to this

00:40:45.525 --> 00:40:46.720
method, OK?

00:40:46.720 --> 00:40:52.470
And that's how you get much more
readable code size and it

00:40:52.470 --> 00:40:55.070
really explains things.

00:40:55.070 --> 00:40:59.790
And another example-- yes,
I've already showed you

00:40:59.790 --> 00:41:03.335
getting rid of anonymous classes
which are really

00:41:03.335 --> 00:41:05.300
annoying Java problem
and everyone agrees.

00:41:05.300 --> 00:41:09.005
If you have only single method
you have to implement then

00:41:09.005 --> 00:41:12.785
it's really annoying to
have this definition.

00:41:12.785 --> 00:41:16.780
So with implicit convergence,
you can easy get rid of that.

00:41:16.780 --> 00:41:21.800
And you can see-- again, a
fragment of Showcase-- how it

00:41:21.800 --> 00:41:23.400
looks like.

00:41:23.400 --> 00:41:29.694
And the third example is that
Scala has built-in XML

00:41:29.694 --> 00:41:30.550
support.

00:41:30.550 --> 00:41:36.500
So you can have XML literals
mixed in freely with Java and

00:41:36.500 --> 00:41:37.913
Scala code.

00:41:37.913 --> 00:41:41.590
So instead of concatenating
strings which is bad for many

00:41:41.590 --> 00:41:45.750
reasons, you have a
nice XML literal.

00:41:45.750 --> 00:41:48.545
And this actually more
secure, right?

00:41:48.545 --> 00:41:53.093
Because we all know problems
with concatenating strings.

00:41:53.093 --> 00:41:57.960
So not only more concise and
it's better to read this code,

00:41:57.960 --> 00:42:00.120
but it's more secure.

00:42:00.120 --> 00:42:04.762
So this is like another really
obvious benefit.

00:42:04.762 --> 00:42:07.365
And I believe that there
might be much more.

00:42:07.365 --> 00:42:13.050
So this is something you can get
without defining GWT APIs

00:42:13.050 --> 00:42:16.450
and with very little
[UNINTELLIGIBLE]

00:42:16.450 --> 00:42:18.880
module and everything
will be working.

00:42:18.880 --> 00:42:21.895
But I believe if you create more
sophisticated wrappers

00:42:21.895 --> 00:42:26.870
around GWT API you would
get even more benefits.

00:42:26.870 --> 00:42:29.450
So what's the future
of this project?

00:42:29.450 --> 00:42:32.186
And first of all dev
mode support.

00:42:32.186 --> 00:42:34.880
I didn't look into
that at all.

00:42:34.880 --> 00:42:40.980
It's like if you cannot have
your code running and compile

00:42:40.980 --> 00:42:46.150
with the common line there is
no point in going into that.

00:42:46.150 --> 00:42:49.030
So I didn't have time even
think about it too much.

00:42:52.730 --> 00:42:55.790
So the obvious goal is to
get Showcase running.

00:42:55.790 --> 00:43:00.370
It's big enough to really prove
that you've got nice,

00:43:00.370 --> 00:43:03.510
decent coverage of features.

00:43:03.510 --> 00:43:06.390
And the third point is profiling
and optimizing

00:43:06.390 --> 00:43:08.130
Jribble parser.

00:43:08.130 --> 00:43:11.296
Right now the parser is really,
really slow and it's

00:43:11.296 --> 00:43:15.585
not because it's functional and
it adds some overhead but

00:43:15.585 --> 00:43:20.050
because there is backtracking
that I couldn't identify.

00:43:20.050 --> 00:43:21.350
It's horrible.

00:43:21.350 --> 00:43:25.730
I mean six minutes to parse
Scala-- Jribble of Scala

00:43:25.730 --> 00:43:26.980
standard library.

00:43:29.420 --> 00:43:35.540
And if these three things are
being implemented and done, I

00:43:35.540 --> 00:43:41.252
hope that merging extensions
with gwtc and scalac would be

00:43:41.252 --> 00:43:42.770
possible.

00:43:42.770 --> 00:43:46.660
And translating more samples to
Scala would be beneficial

00:43:46.660 --> 00:43:47.730
too.

00:43:47.730 --> 00:43:51.910
And at the end of my talk I
would like to thank a few

00:43:51.910 --> 00:43:52.323
people.

00:43:52.323 --> 00:43:57.490
So, Rob Heittman was the person
who was taking care of

00:43:57.490 --> 00:43:59.150
infrastructure for me.

00:43:59.150 --> 00:44:04.190
So we had our own center for
code review, which was

00:44:04.190 --> 00:44:05.110
[UNINTELLIGIBLE]

00:44:05.110 --> 00:44:09.090
and he was taking care of all
this stuff which was really

00:44:09.090 --> 00:44:10.710
beneficial to me.

00:44:10.710 --> 00:44:15.680
The second person, Aaron
Novstrup, he translated

00:44:15.680 --> 00:44:21.340
Showcase into Scala and again,
I'm really, really thankful

00:44:21.340 --> 00:44:25.000
for that because I didn't have
enough time to spend time on

00:44:25.000 --> 00:44:25.950
that.

00:44:25.950 --> 00:44:32.000
And obviously Lex Spoon for
hosting me, for answering 20

00:44:32.000 --> 00:44:38.070
questions a day and being
patient enough.

00:44:38.070 --> 00:44:42.080
And I'd like to thank this
company because it's not like

00:44:42.080 --> 00:44:45.010
in every company you can work
on that kind of project.

00:44:45.010 --> 00:44:49.133
And thanks for releasing so
much good software on open

00:44:49.133 --> 00:44:49.980
source licenses.

00:44:49.980 --> 00:44:51.960
I really appreciate it.

00:44:51.960 --> 00:44:56.030
And at the end there are some
pointers to homepage, groups,

00:44:56.030 --> 00:44:56.600
code review.

00:44:56.600 --> 00:44:58.680
And do you have any questions?

00:45:05.450 --> 00:45:12.440
What's the status of getting the
Jribble back into Scala?

00:45:12.440 --> 00:45:14.780
I didn't talk to Scala people.

00:45:14.780 --> 00:45:19.350
So I attended a conference
by Scala guys.

00:45:19.350 --> 00:45:21.790
It was in April this year.

00:45:21.790 --> 00:45:25.720
And I mentioned that I'd been
accepted as an intern in

00:45:25.720 --> 00:45:26.870
Google.

00:45:26.870 --> 00:45:29.870
And they seemed to be very
interested in the project.

00:45:29.870 --> 00:45:35.514
But since then I didn't really
talk about merging that

00:45:35.514 --> 00:45:39.942
because first you want
something running.

00:45:39.942 --> 00:45:44.440
But I believe that shouldn't
be a problem given the fact

00:45:44.440 --> 00:45:47.550
that I was really careful
to not touch anything.

00:45:47.550 --> 00:45:52.760
It's really just adding a new
package-- like Scala package

00:45:52.760 --> 00:45:53.930
with new code.

00:45:53.930 --> 00:45:55.966
And there's almost no
modification on the rest of

00:45:55.966 --> 00:45:56.322
the compiler.

00:45:56.322 --> 00:45:58.905
So I hope this will
be accepted.

00:45:58.905 --> 00:46:01.500
But this is just my opinion.

00:46:01.500 --> 00:46:06.110
I didn't talk to
those guys yet.

00:46:06.110 --> 00:46:13.870
Also, your build step: You first
run scalac with a output

00:46:13.870 --> 00:46:18.870
to Jribble and then you run
gwtc with a different fran

00:46:18.870 --> 00:46:21.830
reader instead of reading
the Java code?

00:46:21.830 --> 00:46:22.700
Yes.

00:46:22.700 --> 00:46:30.530
So actually on GWT side it can
read Java and Jribble files at

00:46:30.530 --> 00:46:31.220
the same time.

00:46:31.220 --> 00:46:33.970
And this very important so
you can have half of your

00:46:33.970 --> 00:46:37.580
application implemented in Scala
and then this will be

00:46:37.580 --> 00:46:38.750
compiled to Jribble.

00:46:38.750 --> 00:46:41.450
And half of your application
will be implemented in Java

00:46:41.450 --> 00:46:42.680
and this will work well.

00:46:42.680 --> 00:46:45.300
So it's more like-- I'm
basically going through class

00:46:45.300 --> 00:46:50.910
parts and I'm trying to find
files with Jribble extension

00:46:50.910 --> 00:46:54.880
and then I fire up my own parser
and all my logic for

00:46:54.880 --> 00:46:56.060
these files.

00:46:56.060 --> 00:46:58.340
And Java files are being parsed
as they are right now

00:46:58.340 --> 00:47:00.620
in GWT.

00:47:00.620 --> 00:47:01.150
So it's just file
name extension?

00:47:01.150 --> 00:47:01.840
Yes.

00:47:01.840 --> 00:47:05.971
It's just file name extension.

00:47:05.971 --> 00:47:07.432
Any other questions?

00:47:11.830 --> 00:47:15.850
In your slide about the
difficulties of translating

00:47:15.850 --> 00:47:21.366
from Scala to GWT AST, I was
curious at what level-- this

00:47:21.366 --> 00:47:25.450
may be not a useful question but
I'm curious what level of

00:47:25.450 --> 00:47:26.151
the Scala compiler you're
hooked in to.

00:47:26.151 --> 00:47:31.247
Because I would assume there's a
more AST-like level and then

00:47:31.247 --> 00:47:33.416
there's probably something
slightly lower level that's

00:47:33.416 --> 00:47:37.390
more appropriate for generating
bytecode or

00:47:37.390 --> 00:47:38.620
something like that?

00:47:38.620 --> 00:47:39.870
Yes.

00:47:42.410 --> 00:47:47.345
Actually the answer is
complicated because Scala

00:47:47.345 --> 00:47:50.690
code-- so before it reaches
bytecode there is something

00:47:50.690 --> 00:47:53.200
called ICODE in Scala.

00:47:53.200 --> 00:47:56.420
So it has like normal AST nodes
then it translates it to

00:47:56.420 --> 00:48:00.170
ICODE and only then
to bytecode.

00:48:00.170 --> 00:48:05.161
First of all, still Jribble
backend is not only printing

00:48:05.161 --> 00:48:05.980
stuff to Jribble.

00:48:05.980 --> 00:48:10.120
It's really sophisticated
logic which translates

00:48:10.120 --> 00:48:13.655
constructs which you cannot
represent in Java in the right

00:48:13.655 --> 00:48:15.690
way to [UNINTELLIGIBLE PHRASE]

00:48:15.690 --> 00:48:19.200
constructs that can be
represented in Java.

00:48:19.200 --> 00:48:23.610
So if you would like to hook
Scala compiler directly to GWT

00:48:23.610 --> 00:48:26.450
then the question is where are
you going to put this logic,

00:48:26.450 --> 00:48:27.480
right?

00:48:27.480 --> 00:48:34.160
And the only sensible answer is
you really need to do all

00:48:34.160 --> 00:48:39.380
this work in Scala because
really this logic is

00:48:39.380 --> 00:48:42.282
sophisticated and implementing
this in Java would be really,

00:48:42.282 --> 00:48:44.570
really tiresome.

00:48:44.570 --> 00:48:49.870
And then you need to add some
code to Scala compiler anyway.

00:48:49.870 --> 00:48:53.520
And still Scala compiler is
evolving very quickly.

00:48:53.520 --> 00:48:58.420
They really, really modify
their AST nodes.

00:48:58.420 --> 00:49:03.490
So there would be a really big
problem in synchronization of

00:49:03.490 --> 00:49:05.245
release and things like that.

00:49:05.245 --> 00:49:08.695
And another benefit of having
Jribble is that other

00:49:08.695 --> 00:49:10.580
languages can target it.

00:49:10.580 --> 00:49:15.370
Like you can imagine a Ruby
compiler-- a JRuby compiler

00:49:15.370 --> 00:49:17.500
for compiling in Jribble.

00:49:17.500 --> 00:49:22.165
So I think from GWT point of
view it's much more beneficial

00:49:22.165 --> 00:49:26.996
to have that kind of standard
language that everyone can

00:49:26.996 --> 00:49:28.246
target.

00:49:36.570 --> 00:49:46.406
So Jribble right now it
expresses mostly Java

00:49:46.406 --> 00:49:48.836
constructs, sort of winnowing
it down to something useful

00:49:48.836 --> 00:49:51.950
for this purpose.

00:49:51.950 --> 00:49:57.100
If you made it more
representative of-- let's

00:49:57.100 --> 00:50:00.697
assume for the sake of argument
that GWT AST had some

00:50:00.697 --> 00:50:04.330
things in it like first class
functions and some of the

00:50:04.330 --> 00:50:09.365
other constructs that you see
more of in Scala and that are

00:50:09.365 --> 00:50:10.850
also directly representable
in JavaScripts.

00:50:10.850 --> 00:50:12.503
Do you think that would make a
pretty big difference in the

00:50:12.503 --> 00:50:15.120
quality of the compiled
output?

00:50:15.120 --> 00:50:16.682
Like I fear, for example, lots
and lots of function literal

00:50:16.682 --> 00:50:19.378
objects being created as classes
when in fact they're

00:50:19.378 --> 00:50:20.824
much simpler and they're meant
to be much simpler

00:50:20.824 --> 00:50:22.700
[UNINTELLIGIBLE].

00:50:22.700 --> 00:50:26.940
The answer is no because Scala
is fully object oriented so

00:50:26.940 --> 00:50:33.010
even functions are objects which
means you have to really

00:50:33.010 --> 00:50:35.510
represent them as classes, OK?

00:50:35.510 --> 00:50:40.120
And so I don't really see
that much of benefit.

00:50:40.120 --> 00:50:43.830
And the only benefit I could
see is like comma operator

00:50:43.830 --> 00:50:50.370
which you have in JavaScript and
right now there is nothing

00:50:50.370 --> 00:50:51.970
corresponding in Jribble.

00:50:51.970 --> 00:50:58.020
So that would beneficial for
some cases but otherwise no.

00:50:58.020 --> 00:51:00.936
There is no reason.

00:51:00.936 --> 00:51:09.287
So Scala relies on JVM
optimizations and I guess for

00:51:09.287 --> 00:51:11.515
things like [? anonymous ?]

00:51:11.515 --> 00:51:14.802
classes we could rely on GWT
compiler optimizations to

00:51:14.802 --> 00:51:16.230
[UNINTELLIGIBLE PHRASE]

00:51:16.230 --> 00:51:18.951
resulting JavaScript, and not to
make the intermediate form

00:51:18.951 --> 00:51:23.570
have those optimization
[UNINTELLIGIBLE].

00:51:23.570 --> 00:51:25.490
Yeah so yeah that's true.

00:51:25.490 --> 00:51:29.370
So for example this implicit
comparison is a good example.

00:51:29.370 --> 00:51:36.140
So you have a lambda which
is really a class.

00:51:36.140 --> 00:51:37.800
In the class you have
lambda definition.

00:51:37.800 --> 00:51:44.046
It's only one method which in
Scala is called apply and it

00:51:44.046 --> 00:51:45.610
has the code that you
put in lambda.

00:51:45.610 --> 00:51:49.080
And then you have another
wrapper which takes lambda and

00:51:49.080 --> 00:51:50.650
creates like three
[UNINTELLIGIBLE].

00:51:50.650 --> 00:51:51.250
OK?

00:51:51.250 --> 00:51:54.210
So it would be very, very
space forward for a good

00:51:54.210 --> 00:51:59.220
compiler to inline all the whole
thing directly into an

00:51:59.220 --> 00:52:02.890
anonymous class implementing and
then keep the lambda thing

00:52:02.890 --> 00:52:03.730
completely.

00:52:03.730 --> 00:52:06.516
And you'd still have the
lambda in your code but

00:52:06.516 --> 00:52:09.460
compiler to easily
optimize it.

00:52:09.460 --> 00:52:12.590
This is just inlining.

00:52:12.590 --> 00:52:15.820
But this is obviously only in
special cases when you don't

00:52:15.820 --> 00:52:20.110
rely on that fact that lambda
is really a class and you do

00:52:20.110 --> 00:52:21.345
something more about it.

00:52:21.345 --> 00:52:24.203
If you just take it and execute
it then you can

00:52:24.203 --> 00:52:24.990
optimize it away.

00:52:24.990 --> 00:52:28.491
And probably most of the time
that would be the case.

00:52:31.510 --> 00:52:31.800
Any questions?

00:52:31.800 --> 00:52:33.360
Maybe questions for
[? Visit? ?]

00:52:45.070 --> 00:52:49.370
So you were saying, and if I
misheard you just tell me, but

00:52:49.370 --> 00:52:53.612
you said that 96% of the Scala
standard library you could

00:52:53.612 --> 00:52:55.920
translate.

00:52:55.920 --> 00:52:58.903
Were you saying that from
basically translating that

00:52:58.903 --> 00:52:59.570
into Jribble.

00:52:59.570 --> 00:53:01.570
Is that what you refer to?

00:53:01.570 --> 00:53:02.062
Yes.

00:53:02.062 --> 00:53:06.650
So it's still- it's not like
GWT can handle that.

00:53:06.650 --> 00:53:10.366
The reason why it cannot
handle that is, as I

00:53:10.366 --> 00:53:12.290
mentioned, I have representation
in Jribble but

00:53:12.290 --> 00:53:16.290
it still refers to Java
standard library, OK?

00:53:16.290 --> 00:53:21.390
So the missing part is emulate
all these codes somehow.

00:53:21.390 --> 00:53:24.430
And this is not very
difficult.

00:53:24.430 --> 00:53:27.180
It doesn't require any compiler
knowledge actually.

00:53:27.180 --> 00:53:30.130
It's more like you have to go
through all cases and think of

00:53:30.130 --> 00:53:37.165
I don't know-- you have three
line method in Scala so you'd

00:53:37.165 --> 00:53:40.142
have to replace it with
something that you have in

00:53:40.142 --> 00:53:42.070
GWT.

00:53:42.070 --> 00:53:43.550
So things like that.

00:53:43.550 --> 00:53:46.372
It's actually converting all of
Scala standard library into

00:53:46.372 --> 00:53:46.495
Jribble.

00:53:46.495 --> 00:53:49.292
He's only parsing 92% of it.

00:53:49.292 --> 00:53:50.774
OK, I see.

00:53:57.690 --> 00:54:01.150
Anybody else?

00:54:01.150 --> 00:54:05.745
So thanks for attention, for
coming, and thanks for hosting

00:54:05.745 --> 00:54:09.940
me here in Atlanta and hopefully
see you in the

00:54:09.940 --> 00:54:10.060
future.

00:54:10.060 --> 00:54:10.300
Thank you.

00:54:10.300 --> 00:54:11.550
[APPLAUSE]

