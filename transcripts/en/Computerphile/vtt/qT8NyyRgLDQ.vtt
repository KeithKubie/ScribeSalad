WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.920
There's a new way to do Mathematics.

00:00:04.700 --> 00:00:07.080
which has a number of advantages

00:00:07.080 --> 00:00:09.800
and this new way of doing mathematics

00:00:09.800 --> 00:00:14.500
is basically very close to just using a programming language.

00:00:14.640 --> 00:00:16.920
[Computer Science ∩ Mathematics]

00:00:17.060 --> 00:00:20.900
In Mathematics, people prove theorems

00:00:20.900 --> 00:00:24.160
I mean that's the productivity of mathematicians

00:00:24.280 --> 00:00:28.980
and there's a problem: Sometimes theorems turn out to be wrong!

00:00:29.660 --> 00:00:34.860
so it's very embarassing: I mean people publish something and provide a proof

00:00:34.860 --> 00:00:38.940
but then there's something wrong with the proof. That happens lots of times.

00:00:39.320 --> 00:00:47.300
And now we have a new opportunity, using Computer Science technology

00:00:47.300 --> 00:00:50.900
We have something called Interactive Proof Assistants

00:00:51.200 --> 00:00:57.800
and what you can do with those is, basically, dialogue with a computer

00:00:57.800 --> 00:01:00.100
you produce a proof - a mathematical proof.

00:01:00.100 --> 00:01:02.840
which can be stored like a computer program

00:01:03.080 --> 00:01:09.700
And it can be checked by this or another program to make sure that you haven't cheated.

00:01:10.160 --> 00:01:15.180
So that's... Very cool. And there is increasing use of this:

00:01:15.180 --> 00:01:22.760
There are actually some conferences where you can submit an artifact which is this formal proof.

00:01:22.760 --> 00:01:25.900
like, computer code which actually proofs the theorem.

00:01:26.060 --> 00:01:32.000
and then people can check and you can be very, very sure, that your proof is correct.

00:01:32.000 --> 00:01:36.240
People are getting lazy these days, you know? You get all these referee requests:

00:01:36.240 --> 00:01:39.160
"I can't read this proof, this is too much! I don't have the time!"

00:01:39.160 --> 00:01:43.280
But now we have these computer systems, one of them is called Coq

00:01:43.280 --> 00:01:47.720
it's a French system. I think they called it that to upset English speakers.

00:01:47.820 --> 00:01:53.860
We could just do mathematics as it has been done using Set Theory

00:01:54.120 --> 00:01:59.120
and we'd learn about Sets and Elements and that sort of thing

00:01:59.120 --> 00:02:02.600
and just formalize it that way

00:02:03.140 --> 00:02:08.600
but I think if we would do this, we really miss an opportunity:

00:02:08.680 --> 00:02:16.300
This Coq system, for example, is actually based on a programming language called Type Theory.

00:02:17.300 --> 00:02:29.300
So this Type Theory is at the same time a programming language and logic, so you can do logical reasoning

00:02:29.300 --> 00:02:34.700
and it's a replacement for this language Mathematicians use, called Set theory.

00:02:34.940 --> 00:02:39.500
It's a more recent development going back to the 70s:

00:02:39.500 --> 00:02:43.800
By the Swedish Mathematician and Philosopher
Per Martin-Löf

00:02:43.800 --> 00:02:48.940
He wanted to capture what it called Constructive Mathematics

00:02:49.280 --> 00:02:59.920
By Constructive Mathematics we mean that we can actually always obtain a result.

00:03:00.060 --> 00:03:06.940
that we don't just claim, for example, if you have a function, you may have no way to calculate the answer

00:03:07.520 --> 00:03:12.240
In constructive mathematics there is always a way to obtain an answer.

00:03:12.240 --> 00:03:20.460
If you say there exists a number of some property, in classical mathematics you may not know the number.

00:03:20.460 --> 00:03:30.760
In constructive Mathematics you can only make this claim if you can actually provide a concrete number.

00:03:34.280 --> 00:03:40.820
and Per Martin-Löf, he had nothing to do with computer science, he was really a Philosopher and Mathematician

00:03:40.960 --> 00:03:42.760
a very interesting guy

00:03:42.760 --> 00:03:47.140
"but then people thought: ok, this idea of always getting an answer:"

00:03:47.140 --> 00:03:50.560
"doesn't this correspond to, like, writing a computer program?"

00:03:50.560 --> 00:03:53.100
And he said: "Yeah, this is like a computer program."

00:03:53.600 --> 00:03:58.580
And this has been made more precise and has been used,

00:03:58.820 --> 00:04:06.880
so people started basically to implement this Type Theory on a computer.

00:04:07.400 --> 00:04:15.440
Type Theory uses the Types we have in Programming language, like for example

00:04:15.440 --> 00:04:17.840
the type of booleans, the type of Integers...

00:04:17.840 --> 00:04:21.980
or the type of functions from Integers to Booleans.
Int → Bool

00:04:21.980 --> 00:04:24.240
Input an Integer and output a Boolean
Int → Bool

00:04:24.240 --> 00:04:25.600
and so on. These are types.

00:04:26.180 --> 00:04:35.620
And a very important observation is, that we can use types in order to model logical reasoning.

00:04:35.840 --> 00:04:38.620
To model logical propositions.

00:04:38.920 --> 00:04:44.680
So if you have a proposition, a logical expression,

00:04:44.680 --> 00:04:47.000
For example, "There are infinitely many ℙrime Numbers"
∀p∈ℙ : ∃q∈ℙ | q &gt; p

00:04:47.000 --> 00:04:48.620
is a proposition

00:04:48.780 --> 00:04:57.200
or, for every two ℕatural Numbers, one is less than, equal to or greater than the other
∀a,b∈ℕ: a&lt;b ∨ a=b ∨ a&gt;b

00:04:57.200 --> 00:04:58.420
These are propositions.

00:04:59.180 --> 00:05:08.560
And the observation is that, for every proposition, we can associate a type.

00:05:09.900 --> 00:05:15.300
And that's the type of evidence or proof for this proposition.

00:05:16.060 --> 00:05:19.560
This is called the Curry-Howard Equivalence

00:05:20.620 --> 00:05:22.940
So whenever you have a proposition

00:05:23.260 --> 00:05:26.300
you find a Type such that

00:05:26.300 --> 00:05:32.740
, if there is a program of its corresponding type, then you know this proposition holds.

00:05:32.740 --> 00:05:37.100
Sean: So this is computing getting its elbows in and getting stuck into some mathematics

00:05:37.700 --> 00:05:48.000
Yes and I would say, ok, using type theory is very natural to do on a computer

00:05:48.000 --> 00:05:54.440
where as Set Theory seems to be rather alien to use on computers.

00:05:54.820 --> 00:06:03.080
In Set Theory, for example, there is the notion of a function, but it's a derived concept:

00:06:03.080 --> 00:06:06.120
You have a set of pairs with certain properties
{p|p=(a,b), *certain properties hold*}

00:06:06.160 --> 00:06:10.020
There is not this idea like in Type Theory

00:06:10.020 --> 00:06:13.400
That a function is something where you put something in and get something out
f : a → b

00:06:13.400 --> 00:06:18.480
Which corresponds to how we think in Computer Science

00:06:18.480 --> 00:06:22.640
So a function in Type Theory is something we can actually compute with,

00:06:22.640 --> 00:06:26.960
Where as a function in Mathematics and Set Theory is something like

00:06:26.960 --> 00:06:30.940
the set of all pairs of inputs with corresponding outputs

00:06:30.940 --> 00:06:35.340
but a function in Mathematics may be something you cannot compute

00:06:35.340 --> 00:06:39.520
So I'm always saying "This is not a good name, to call it `function` because

00:06:39.520 --> 00:06:43.800
a function which doesn't function shouldn't be called a function"

00:06:43.800 --> 00:06:46.900
Sean: dysfunctional functions
Thorsten: Yeah dysfunctional functions

00:06:47.460 --> 00:06:54.780
Type Theory has got some other interesting features, which have been

00:06:54.780 --> 00:06:58.420
discovered or made explicit more recently

00:06:59.560 --> 00:07:05.860
and this is work which was started by a mathematician, actually:

00:07:05.860 --> 00:07:13.320
He's called Vladimir Voevodskij and he's a Fields medalist at the Institute for Advanced Study in Princeton

00:07:13.320 --> 00:07:16.920
He is doing something called Homotopy Theory

00:07:16.920 --> 00:07:20.620
So Homotopy Theory is a quite abstract area of Mathematics

00:07:20.620 --> 00:07:26.240
where we try to understand geometric objects, a very abstract geometric objects.

00:07:27.100 --> 00:07:39.260
and you can identify geometric objects which you can transform like plastic... or play dough

00:07:39.260 --> 00:07:43.660
where you can transform one into the other in continuous transformations

00:07:43.660 --> 00:07:48.120
and first of all that doesn't seem to have anything to do with the Type Theory I mentioned

00:07:48.420 --> 00:07:52.900
but, Vladimir Voevodskij observed, that

00:07:52.900 --> 00:07:57.640
there actually is a close connection between Type Theory and Homotopy Theory

00:07:57.640 --> 00:08:01.460
which leads to this new idea called Homotopy Type Theory (HoTT)

00:08:01.720 --> 00:08:09.420
and the idea here is, that when, in Type Theory, you have a proof that two things are equal,

00:08:09.420 --> 00:08:14.640
this is like surfaces where you have a path between them

00:08:14.980 --> 00:08:23.000
and then you can also ask yourself: "Are two equalities equal?" - "Is there a path between paths?"

00:08:23.000 --> 00:08:25.240
A continuous transformation of paths

00:08:25.760 --> 00:08:29.160
Ok. That's
Sean: It's getting quite abstract

00:08:29.160 --> 00:08:31.360
Thorsten: It's getting very abstract
Sean: Is this like a

00:08:31.460 --> 00:08:38.460
Sean: -These play dough objects are a bit like a way of visualizing these ideas? Is that what he has discovered?

00:08:38.460 --> 00:08:44.840
Thorsten: No, it's not really. It's rather surprising. Because we started with something that is called

00:08:44.840 --> 00:08:49.400
Type Theory which is a programming language and a logic as I have explained.

00:08:49.400 --> 00:08:53.460
And then there is this Homotopy Theory which has completely different rules in

00:08:53.460 --> 00:08:56.020
what is called, Algebraic Topology

00:08:56.420 --> 00:09:03.640
Which is like, I mean, topology is an idea of describing continuous phenomena like ℝeal numbers and

00:09:04.820 --> 00:09:09.220
and surfaces and so on, which are important in physics and so on

00:09:09.660 --> 00:09:14.720
And then, in Homotopy Theory, people do this more and more abstractly.

00:09:14.720 --> 00:09:20.080
They try to distill the essence of these objects.

00:09:21.560 --> 00:09:27.900
They are infinitely dimensional - no really good intuition for what's going on.

00:09:29.320 --> 00:09:35.080
But then, the surprising thing, and this one of the surprising reuses of mathematics:

00:09:35.080 --> 00:09:40.440
You go completely abstract in one direction and you come out somewhere completely different

00:09:40.820 --> 00:09:46.520
And this is a relation between Type Theory and Homotopy Theory, ok?

00:09:46.520 --> 00:09:52.320
So it's not very direct; it's not like we have a type and then we have a picture which corresponds to this type

00:09:52.320 --> 00:09:54.360
It's not like this.

00:09:54.360 --> 00:09:59.040
It's much more indirect

00:09:59.040 --> 00:10:07.560
but the mathematical principles underlying this Homotopy Theory and Type Theory are matched up

00:10:07.800 --> 00:10:09.160
Surprisingly well.

00:10:09.160 --> 00:10:12.820
Maybe one question is "What is the pay-off?", I mean, what does this buy us?

00:10:13.100 --> 00:10:17.280
And I think there are some very exciting opportunities now,

00:10:17.280 --> 00:10:23.460
where Type Theory shows its superiorirty over Set Theory

00:10:23.960 --> 00:10:27.560
And this has to do with abstraction:

00:10:28.120 --> 00:10:32.460
If you want to build large mathematical libaries

00:10:33.360 --> 00:10:36.560
you have to climb a ladder of abstract reasoning

00:10:36.560 --> 00:10:42.000
You don't want to do everything on a concrete level, you have to do things abstractly.

00:10:42.000 --> 00:10:43.460
That's the power of Mathematics.

00:10:43.460 --> 00:10:50.420
Type Theory, and especially Homotopy Type Theory, in its very structure is designed in a way,

00:10:50.420 --> 00:10:56.720
that you cannot talk about the details of how things are actually implemented

00:10:57.060 --> 00:11:04.480
so for example, ℕatural Numbers: In Set Theory, ℕatural Numbers are Sets. That's maybe surprising.

00:11:04.480 --> 00:11:06.280
But in Set Theory, Everything is a Set.

00:11:06.280 --> 00:11:12.840
And there is a particular Encoding of ℕatural Numbers using Sets using {curly brackets}

00:11:12.840 --> 00:11:18.800
but there is more than one! So you can use Sets to encode ℕatural Numbers in various ways.

00:11:19.280 --> 00:11:26.060
so for example, in the standard encoding in Set Theory, there is a very strange artifact

00:11:26.240 --> 00:11:32.740
for example, one number is element of a bigger number of ℕatural Numbers, Counting Numbers

00:11:32.740 --> 00:11:35.280
It's true that 2 is an element of 3
0∈1∈2∈3∈4∈...

00:11:35.280 --> 00:11:37.360
doesn't really make any sense, right?

00:11:37.620 --> 00:11:46.760
It's just the way it's set up. Which means, when you work in Set Theory, you can see the implementation details.

00:11:47.060 --> 00:11:51.900
How numbers are actually represented using {curly brackets}.

00:11:51.900 --> 00:11:57.920
Now that's something that doesn't really matter when you think about numbers: 2∈3 is silly.

00:11:58.360 --> 00:12:00.480
But you can't hide this

00:12:00.960 --> 00:12:06.140
In Type Theory, when you introduce ℕatural Numbers in Type Theory,

00:12:06.140 --> 00:12:10.300
you cannot talk about the encoding - how they are actually represented -

00:12:10.640 --> 00:12:17.720
So for example, numbers are often represented following an idea of an Italian mathematician

00:12:17.720 --> 00:12:19.140
callead Peano, who said:

00:12:19.140 --> 00:12:20.500
0 is a ℕatural Number
0∈ℕ

00:12:20.500 --> 00:12:23.340
and every other ℕatural Number is a previous number +1
∀n∈ℕ : succ(n)∈ℕ (where succ(n) is n+1)

00:12:23.340 --> 00:12:24.600
is also a ℕatural Number
∀n∈ℕ : succ(n)∈ℕ (where succ(n) is n+1)

00:12:24.780 --> 00:12:27.700
and that's a way we can build all ℕatural Numbers.

00:12:28.500 --> 00:12:35.380
But there are other ways to do this, right? When you write numbers in this system they become very long.

00:12:35.380 --> 00:12:39.960
Because you write +1 + 1 +1 +1; that's not a very good system.

00:12:40.300 --> 00:12:44.460
So what we rather like to do is using binary encoding of numbers

00:12:44.460 --> 00:12:49.600
Using 0 and 1. That's much shorter. I mean still longer than decimal, but

00:12:49.900 --> 00:12:53.860
It's much shorter than this +1+1+1

00:12:53.860 --> 00:12:58.120
And this are two ways of encoding the ℕatural Numbers.

00:12:58.120 --> 00:13:04.900
Now in Type Theory, you cannot express the difference between these two encodings.

00:13:04.900 --> 00:13:10.420
Because they are actually in a way the same:
They exhibit the same concept.

00:13:10.420 --> 00:13:17.220
So you automatically hide implementation details, like, that's what we wanted to do in Computer Science.

00:13:17.220 --> 00:13:23.180
We want to hide implementation details because, like, if you want to change one implementation  for another,

00:13:23.180 --> 00:13:27.440
we don't want to go all the way up so everything which uses this has to be rewritten.

00:13:27.440 --> 00:13:30.340
We want to say "Ok I'll just plug something else in and it works."

00:13:30.340 --> 00:13:35.660
So you want to be able to plug in, if we use the Peano Numbers and say "that's too cumbersome"

00:13:35.660 --> 00:13:38.920
"and I'll plug in my binary numbers" and nothing should change."

00:13:39.540 --> 00:13:43.420
And that's how Type Theory is designed.

00:13:43.780 --> 00:13:50.000
And from this Homotopy Type Theory comes a very important principle

00:13:50.000 --> 00:13:53.360
which is called the Univalence Principle
(=)≅(≅)

00:13:53.360 --> 00:14:02.100
And it basically says that two things which are equivalent (≅), like the binary and Peano numbers,

00:14:02.100 --> 00:14:03.400
then they are equal (=)

00:14:03.400 --> 00:14:07.200
We cannot, not just, we cannot talk about implementation details

00:14:07.200 --> 00:14:11.800
but because we cannot talk about implementation details,

00:14:11.800 --> 00:14:18.500
two things which behave the same from outside (≅) are actually considered to be the same (=)

00:14:18.500 --> 00:14:23.120
Sean: Is this changing massively the way that people  think about things in other areas, then?

00:14:23.120 --> 00:14:29.100
Thorsten: Yes, so let's see:
It has the potential of doing this.

00:14:29.100 --> 00:14:38.340
So Homotopy Type Theory has been suggested as a new Foundation of Mathematics.

00:14:38.340 --> 00:14:45.880
People can just move into it, they can learn logical reasoning and abstract mathematics

00:14:45.880 --> 00:14:48.880
just coming from this programming angle.

00:14:50.220 --> 00:14:54.280
So I think there is an exciting opportunity.

00:14:54.460 --> 00:15:05.820
And I think, looking back to Set Theory, we have these new tools of Proof Assistants to do interactive proofs

00:15:06.180 --> 00:15:12.320
And in a way it would be a shame if we used this new technology to

00:15:12.320 --> 00:15:20.180
formalize the mathematics of the 20s and 30s, the mathematics of, let's say, yesterday.

00:15:20.380 --> 00:15:31.460
But there is an exciting new opportunity here, to really use new mathematical ideas, new foundations

00:15:31.460 --> 00:15:34.940
when we formalize mathematics.

00:15:37.820 --> 00:15:44.580
...we got a value here at x1 and we are going between x0 and x1 and the value of y, at this position...

00:15:44.580 --> 00:15:50.580
...in Type Theory means you can proof the Excluded Middle for this particular predicate,

00:15:50.580 --> 00:15:55.160
You can proof, for all numbers, either prime(n) or not prime(n)...

