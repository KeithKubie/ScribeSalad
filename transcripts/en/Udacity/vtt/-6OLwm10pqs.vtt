WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.000
[Evans] I think there are 3 main themes that really pervade the course

00:00:03.000 --> 00:00:05.000
that we've seen over and over again,

00:00:05.000 --> 00:00:08.000
but I haven't mentioned them explicitly until now.

00:00:08.000 --> 00:00:12.000
These are themes that aren't just pervasive throughout this course

00:00:12.000 --> 00:00:14.000
but are pervasive throughout all computer science.

00:00:14.000 --> 00:00:16.000
The first one is abstraction.

00:00:16.000 --> 00:00:19.000
Abstraction is all about hiding details.

00:00:19.000 --> 00:00:23.000
The point of abstraction is to make it so you can have 1 thing that is used

00:00:23.000 --> 00:00:26.000
in many different ways, and you can use it

00:00:26.000 --> 00:00:29.000
without necessarily understanding all the details behind it.

00:00:29.000 --> 00:00:33.000
We've seen lots and lots of examples of abstraction in this class.

00:00:33.000 --> 00:00:36.000
The most important one is procedural abstraction.

00:00:36.000 --> 00:00:39.000
We can write 1 procedure, use it to do lots of different things

00:00:39.000 --> 00:00:42.000
depending on what the inputs are, and when we use that procedure

00:00:42.000 --> 00:00:46.000
we don't need to know exactly what sequence of instructions will execute.

00:00:46.000 --> 00:00:48.000
What we know is what the procedure does.

00:00:48.000 --> 00:00:50.000
The second main theme is universality.

00:00:50.000 --> 00:00:52.000
We talked about this early in the class

00:00:52.000 --> 00:00:55.000
about how computers are universal machines.

00:00:55.000 --> 00:00:59.000
I want to show you how much better I've gotten at drawing.

00:00:59.000 --> 00:01:05.000
If you thought my drawing of a toaster in Unit 1 was not recognizable,

00:01:05.000 --> 00:01:07.000
I hope you can see how much better I can do now.

00:01:07.000 --> 00:01:11.000
This is a toaster, and a toaster is very different from a computer.

00:01:11.000 --> 00:01:13.000
A computer is a universal machine.

00:01:13.000 --> 00:01:17.000
We've seen lots of examples of how a computer is universal--

00:01:17.000 --> 00:01:22.000
that we only need a few simple constructs to be able to define every possible program.

00:01:22.000 --> 00:01:25.000
We saw that if we had a way to make decisions--

00:01:25.000 --> 00:01:29.000
and we saw we have that with if in Python;

00:01:29.000 --> 00:01:32.000
we saw that if we have a way to keep track of things--

00:01:32.000 --> 00:01:37.000
and in Python we can do that using variables and data;

00:01:37.000 --> 00:01:40.000
and if we have a way to keep going--

00:01:40.000 --> 00:01:45.000
and we first saw that using while--with a while loop we can make something keep going

00:01:45.000 --> 00:01:47.000
as long as we want.

00:01:47.000 --> 00:01:49.000
But in fact, we don't even need while.

00:01:49.000 --> 00:01:54.000
We could do that with procedures, and that's what we saw with recursive definitions

00:01:54.000 --> 00:01:56.000
in Unit 6.

00:01:56.000 --> 00:02:00.000
Once we have those 3 things, we can write any computer program.

00:02:00.000 --> 00:02:04.000
So we have much more power with a computer than we do with a toaster.

00:02:04.000 --> 00:02:09.000
The final major theme I want to summarize as our third main theme

00:02:09.000 --> 00:02:11.000
is one we've already mentioned here.

00:02:11.000 --> 00:02:13.000
It's recursive definitions.

00:02:13.000 --> 00:02:16.000
We introduced those explicitly in Unit 6,

00:02:16.000 --> 00:02:19.000
but you saw them many times before that.

00:02:19.000 --> 00:02:22.000
The first time you saw them was actually in Unit 1.

00:02:22.000 --> 00:02:25.000
We saw these rules that said we can make an expression

00:02:25.000 --> 00:02:29.000
by taking another expression, using the plus operator,

00:02:29.000 --> 00:02:31.000
and combining it with another expression.

00:02:31.000 --> 00:02:34.000
That was not enough by itself for a recursive definition.

00:02:34.000 --> 00:02:36.000
We also needed a base case.

00:02:36.000 --> 00:02:40.000
We saw a base case, like we can have an expression that's a number.

00:02:40.000 --> 00:02:46.000
So the big idea here is that with very simple rules we can define infinitely many things

00:02:46.000 --> 00:02:49.000
and very complex things by using rules to define things

00:02:49.000 --> 00:02:52.000
in terms of simpler versions of themselves.

