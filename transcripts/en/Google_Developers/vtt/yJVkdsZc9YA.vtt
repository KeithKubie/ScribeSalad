WEBVTT
Kind: captions
Language: en

00:00:00.060 --> 00:00:01.310
BRIAN KEHRER: Hello, everyone.

00:00:01.310 --> 00:00:03.600
Thank you for coming.

00:00:03.600 --> 00:00:04.820
I'm Brian.

00:00:04.820 --> 00:00:08.130
I'm a game developer
and graphics programmer.

00:00:08.130 --> 00:00:09.622
I was cofounder of
Muse Games where

00:00:09.622 --> 00:00:12.080
I was lead game designer on a
game you might have heard of,

00:00:12.080 --> 00:00:14.294
"Guns of Icarus Online."

00:00:14.294 --> 00:00:15.710
After that, I spent
a couple years

00:00:15.710 --> 00:00:19.535
working on mobile games and
experiences at Psyop New York.

00:00:19.535 --> 00:00:20.910
But today I'm
going to talk about

00:00:20.910 --> 00:00:24.340
some work I did last year with
ustwo in New York on two VR

00:00:24.340 --> 00:00:26.220
projects, which I'm
sure you've heard of,

00:00:26.220 --> 00:00:29.579
Cardboard Design Lab
and "Arctic Journey."

00:00:29.579 --> 00:00:31.120
So what I really
wanted to talk about

00:00:31.120 --> 00:00:34.780
is how vertex displacement, a
feature in the Cardboard SDK,

00:00:34.780 --> 00:00:37.360
was developed for the needs
of both those projects,

00:00:37.360 --> 00:00:41.450
and how it can help you develop
performant VR experiences.

00:00:41.450 --> 00:00:43.900
So the first project is
Cardboard Design Lab.

00:00:43.900 --> 00:00:45.540
It was released early last year.

00:00:45.540 --> 00:00:47.204
Hopefully you've
all tried it out.

00:00:47.204 --> 00:00:49.120
If you haven't, I highly
recommend getting it.

00:00:49.120 --> 00:00:50.330
It's also open source.

00:00:50.330 --> 00:00:52.710
So you can, in addition
to testing it out,

00:00:52.710 --> 00:00:54.690
you can mess around
with it, get it

00:00:54.690 --> 00:00:57.589
to build on other platforms,
anything you want.

00:00:57.589 --> 00:00:59.130
But the primary
purpose of Design Lab

00:00:59.130 --> 00:01:02.560
is to showcase best practices
in VR for Cardboard developers,

00:01:02.560 --> 00:01:06.084
as well as some
activities best avoided.

00:01:06.084 --> 00:01:07.500
But beyond just
the principles, it

00:01:07.500 --> 00:01:10.210
was important that the
experience also be beautiful,

00:01:10.210 --> 00:01:13.430
and of course run smoothly
at 60 frames per second.

00:01:13.430 --> 00:01:15.920
We wanted Design Lab to
embody what a Cardboard

00:01:15.920 --> 00:01:18.490
experience could and should be.

00:01:18.490 --> 00:01:20.490
But at the same time,
we really wanted

00:01:20.490 --> 00:01:23.120
to push the limits of what's
possible on a mobile device.

00:01:23.120 --> 00:01:25.990
We wanted to create lush visuals
and have high performance

00:01:25.990 --> 00:01:27.440
at the same time.

00:01:27.440 --> 00:01:29.810
So we set an ambitious
goal for ourself.

00:01:29.810 --> 00:01:32.340
Let's see if we can achieve
this look while still hitting

00:01:32.340 --> 00:01:35.150
60 frames per
second on a Nexus 5,

00:01:35.150 --> 00:01:39.200
and maybe throw in antialiasing
and some dynamic lights.

00:01:39.200 --> 00:01:40.530
But we ran into problems.

00:01:40.530 --> 00:01:42.490
Almost immediately
we realized this was

00:01:42.490 --> 00:01:44.090
going to be really challenging.

00:01:44.090 --> 00:01:46.790
Older devices were struggling
to hit 30 frames per second

00:01:46.790 --> 00:01:48.530
on even simple test scenes.

00:01:48.530 --> 00:01:50.080
They were overheating.

00:01:50.080 --> 00:01:51.800
So during the development
of Design Lab,

00:01:51.800 --> 00:01:54.830
we experimented with a new
method of distortion correction

00:01:54.830 --> 00:01:56.860
called vertex displacement.

00:01:56.860 --> 00:01:58.520
And I'll get to
that in a minute.

00:01:58.520 --> 00:02:01.640
But I just want to sort of
put this in context first.

00:02:01.640 --> 00:02:03.440
Without vertex
displacement, most

00:02:03.440 --> 00:02:06.970
of what you see in Design Lab
would not have been possible.

00:02:06.970 --> 00:02:08.250
But then we didn't stop there.

00:02:08.250 --> 00:02:10.039
So fast forward
six months and we

00:02:10.039 --> 00:02:12.160
worked on the second
project, and that's

00:02:12.160 --> 00:02:14.730
"Arctic Journey," which
is the demo project

00:02:14.730 --> 00:02:18.950
or the demo scene in
the Cardboard app.

00:02:18.950 --> 00:02:21.290
And this time we wanted
to push it even further,

00:02:21.290 --> 00:02:24.570
adding more animated characters,
richer lighting, and a more

00:02:24.570 --> 00:02:26.090
dynamic environment.

00:02:26.090 --> 00:02:28.357
And this project gave us
one of those rare chances

00:02:28.357 --> 00:02:29.940
to reflect on the
lessons we'd learned

00:02:29.940 --> 00:02:33.460
before while working on Design
Lab and refine our workflow.

00:02:33.460 --> 00:02:36.140
So we set an even
more ambitious goal.

00:02:36.140 --> 00:02:38.190
Let's see if we can
do the same thing,

00:02:38.190 --> 00:02:42.050
but this time make it richer
and run on older devices.

00:02:42.050 --> 00:02:45.680
We knew antialiasing on old
phones was almost impossible.

00:02:45.680 --> 00:02:48.130
But maybe we could get
them to at least run at 60.

00:02:48.130 --> 00:02:49.940
So in this case,
we were targeting

00:02:49.940 --> 00:02:52.460
the S3, the iPhone 5, the S4.

00:02:52.460 --> 00:02:54.910
And if you've worked with
any of these devices,

00:02:54.910 --> 00:02:58.130
they're really challenging,
especially for Cardboard apps.

00:02:58.130 --> 00:03:00.102
So I've sort of broken
this talk into two parts

00:03:00.102 --> 00:03:02.310
to mirror the evolution of
our workflow and these two

00:03:02.310 --> 00:03:03.550
projects.

00:03:03.550 --> 00:03:05.460
And first I'm going
to talk about what

00:03:05.460 --> 00:03:06.670
is vertex displacement.

00:03:06.670 --> 00:03:07.500
How do you use it?

00:03:07.500 --> 00:03:08.800
How can it help you?

00:03:08.800 --> 00:03:12.345
And second I'm going to step
back and go a bit more broad.

00:03:12.345 --> 00:03:14.470
How can you take advantage
of some of these lessons

00:03:14.470 --> 00:03:18.270
to further optimize
performance in other ways?

00:03:18.270 --> 00:03:20.940
So first, let's talk
about vertex displacement.

00:03:20.940 --> 00:03:22.900
But to do that, we need
to really quickly talk

00:03:22.900 --> 00:03:26.110
about how VR rendering works.

00:03:26.110 --> 00:03:28.640
So here's a Cardboard
application.

00:03:28.640 --> 00:03:31.100
On your device, you render
the left and right eye

00:03:31.100 --> 00:03:32.510
on your smartphone.

00:03:32.510 --> 00:03:34.220
And then you pick
up your Cardboard,

00:03:34.220 --> 00:03:36.280
and you look at them
through the lenses.

00:03:36.280 --> 00:03:39.432
And these lenses are what
create the wide field of view.

00:03:39.432 --> 00:03:40.890
But because as with
any lenses they

00:03:40.890 --> 00:03:43.850
warp the image, if you render
out this Cardboard icon the way

00:03:43.850 --> 00:03:46.170
you see it and look
through the Cardboard,

00:03:46.170 --> 00:03:49.060
you'll see an image
that's distorted.

00:03:49.060 --> 00:03:51.940
So instead, we render with
the inverse of that lens

00:03:51.940 --> 00:03:53.310
distortion applied.

00:03:53.310 --> 00:03:54.950
And this happens
in our application

00:03:54.950 --> 00:03:58.360
through the Cardboard SDK,
typically a postprocess image

00:03:58.360 --> 00:04:00.540
effect or by
rendering to a texture

00:04:00.540 --> 00:04:03.040
and projecting that
texture onto a warped mesh,

00:04:03.040 --> 00:04:05.000
and then rerendering the screen.

00:04:05.000 --> 00:04:06.990
So now when we look
through the lenses,

00:04:06.990 --> 00:04:10.470
the distortion cancels out
and we see the correct image.

00:04:10.470 --> 00:04:11.800
It's a fairly simple process.

00:04:11.800 --> 00:04:13.970
But as graphics programmers
in the room know,

00:04:13.970 --> 00:04:17.079
full screen render textures
are not free, especially

00:04:17.079 --> 00:04:20.329
on older devices, devices
with dense screens, low power

00:04:20.329 --> 00:04:21.256
devices.

00:04:21.256 --> 00:04:22.630
These full screen
render textures

00:04:22.630 --> 00:04:25.230
can create serious
performance problems.

00:04:25.230 --> 00:04:28.370
So what we wanted to do was cut
this out and render directly

00:04:28.370 --> 00:04:30.620
to the screen buffer instead.

00:04:30.620 --> 00:04:32.660
But we needed a way to
apply the lens distortion

00:04:32.660 --> 00:04:35.390
before rendering.

00:04:35.390 --> 00:04:39.040
So what if instead of
warping the rendered image,

00:04:39.040 --> 00:04:41.010
we just warped the
geometry before we

00:04:41.010 --> 00:04:47.780
finished rendering, maybe in
a vertex shader, like that?

00:04:47.780 --> 00:04:51.320
And this is what it
actually looks like.

00:04:51.320 --> 00:04:53.520
So this is the optical
distortion correction

00:04:53.520 --> 00:04:55.880
being applied in
the vertex shader,

00:04:55.880 --> 00:04:57.760
animated here for effect.

00:04:57.760 --> 00:05:01.260
So instead of transforming
individual pixels

00:05:01.260 --> 00:05:04.120
from the rendered image,
we bent the actual world

00:05:04.120 --> 00:05:05.760
and then just rendered normally.

00:05:05.760 --> 00:05:08.090
So we no longer need
a render texture.

00:05:08.090 --> 00:05:10.500
I think this is pretty awesome.

00:05:10.500 --> 00:05:12.320
You can see in this
wireframe image,

00:05:12.320 --> 00:05:15.210
as vertices extend outward
from the center of the screen,

00:05:15.210 --> 00:05:18.030
they're affected more, just
like a Photoshop lens correction

00:05:18.030 --> 00:05:20.270
effect.

00:05:20.270 --> 00:05:22.350
This is extremely
efficient, especially

00:05:22.350 --> 00:05:24.160
on older, lower power devices.

00:05:24.160 --> 00:05:26.660
This can represent a large
increase in performance.

00:05:26.660 --> 00:05:30.170
On the S3, this
doubles performance.

00:05:30.170 --> 00:05:32.440
On newer devices, you'll
see less of an impact.

00:05:32.440 --> 00:05:35.380
I think on the
5S, the iPhone, it

00:05:35.380 --> 00:05:39.710
was 20% to 30% increase
in performance.

00:05:39.710 --> 00:05:41.760
OK, so this is great.

00:05:41.760 --> 00:05:43.240
But there are some drawbacks.

00:05:43.240 --> 00:05:46.320
Mostly because this method
only operates on vertices,

00:05:46.320 --> 00:05:48.000
you can see lines
between vertices

00:05:48.000 --> 00:05:49.530
always remain straight.

00:05:49.530 --> 00:05:52.550
So the quality of this effect is
dependent on both the distance

00:05:52.550 --> 00:05:57.270
from the camera as well as the
vertex density of the scene.

00:05:57.270 --> 00:06:00.590
So you might wonder, how
many vertices do we need?

00:06:00.590 --> 00:06:02.470
And I've put two foxes here.

00:06:02.470 --> 00:06:04.030
And one of these
images is rendered

00:06:04.030 --> 00:06:06.830
using the new technique,
vertex displacement.

00:06:06.830 --> 00:06:09.170
And the other is rendered
using a render texture

00:06:09.170 --> 00:06:11.020
at double resolution.

00:06:11.020 --> 00:06:14.310
Both are just using simple
Lambertian diffuse, N dot L.

00:06:14.310 --> 00:06:16.450
And they're almost identical.

00:06:16.450 --> 00:06:20.110
So you might say like OK,
well how dense is this mesh?

00:06:20.110 --> 00:06:21.800
And the answer is
it's not that dense.

00:06:21.800 --> 00:06:24.784
So we don't need too much.

00:06:24.784 --> 00:06:26.700
And here's-- I don't
know if you can see this.

00:06:26.700 --> 00:06:28.910
It's a little tough to
see, this is an error image

00:06:28.910 --> 00:06:31.740
between the postprocess and
the vertex displacement.

00:06:31.740 --> 00:06:34.180
And it looks pretty good.

00:06:34.180 --> 00:06:36.410
So you might wonder
OK, this is great.

00:06:36.410 --> 00:06:37.320
How low can we go?

00:06:37.320 --> 00:06:40.540
Like what about a quad?

00:06:40.540 --> 00:06:45.110
And so a quad is the perfect
example of this not working.

00:06:45.110 --> 00:06:46.685
No matter how you
warp it, the edges

00:06:46.685 --> 00:06:48.560
are always going to be
lines when they should

00:06:48.560 --> 00:06:50.570
be a curved arc between points.

00:06:50.570 --> 00:06:52.920
So you're going to need
some additional tessellation

00:06:52.920 --> 00:06:55.100
on really low poly geometry.

00:06:55.100 --> 00:06:57.710
But again, the good news
is you don't need a lot.

00:06:57.710 --> 00:07:00.500
The four by four quad is
already looking passable,

00:07:00.500 --> 00:07:03.510
and the eight by eight
looks pretty good.

00:07:03.510 --> 00:07:05.970
And in fact, when we once
again compare the eight

00:07:05.970 --> 00:07:08.810
by eight quad to the render
texture at double res,

00:07:08.810 --> 00:07:11.790
the resulting difference
image isn't that far off.

00:07:11.790 --> 00:07:14.540
And I'll note, if you're
looking at a piece of geometry,

00:07:14.540 --> 00:07:16.990
that's a very large
piece of geometry

00:07:16.990 --> 00:07:18.756
very close to your eye.

00:07:18.756 --> 00:07:20.380
So this represents
kind of a worst case

00:07:20.380 --> 00:07:21.880
scenario for this technique.

00:07:21.880 --> 00:07:24.130
And as you can see again,
it's doing quite well

00:07:24.130 --> 00:07:26.002
with very low tessellation.

00:07:26.002 --> 00:07:27.960
You could very easily
increase the tessellation

00:07:27.960 --> 00:07:33.090
of this geometry without really
affecting your vertex budget.

00:07:33.090 --> 00:07:36.035
So in summary, if you decide
to use this, be forewarned,

00:07:36.035 --> 00:07:37.660
you're going to have
to be a little bit

00:07:37.660 --> 00:07:39.057
careful about tessellation.

00:07:39.057 --> 00:07:40.640
But you don't need
to go crazy either.

00:07:43.250 --> 00:07:45.700
So one of the places this
is potentially problematic

00:07:45.700 --> 00:07:48.580
and a little bit irritating
is on interface elements.

00:07:48.580 --> 00:07:50.850
And on both these
projects, we generally

00:07:50.850 --> 00:07:53.350
swapped out all the quads
for 10 by 10 planes,

00:07:53.350 --> 00:07:55.680
and then we just didn't
think about it again.

00:07:55.680 --> 00:07:56.980
This covered it.

00:07:56.980 --> 00:08:01.230
Fortunately text, each
character is rendered on a quad.

00:08:01.230 --> 00:08:05.690
And those were small enough that
it wasn't really noticeable.

00:08:05.690 --> 00:08:07.500
If you're building
interfaces in 3D space

00:08:07.500 --> 00:08:10.230
with physics, as we
did in Design Lab,

00:08:10.230 --> 00:08:14.160
using custom geometry for
your back plates in your UI

00:08:14.160 --> 00:08:15.840
is really easy.

00:08:15.840 --> 00:08:18.550
If you're using the existing
UI systems in Unity,

00:08:18.550 --> 00:08:23.150
it's still possible, but it's
a little bit more involved.

00:08:23.150 --> 00:08:27.400
OK, so so far I've
described how this works.

00:08:27.400 --> 00:08:29.900
I've talked a little bit about
performance and tessellation.

00:08:29.900 --> 00:08:31.816
But I want to talk about
one of the other side

00:08:31.816 --> 00:08:33.870
benefits of vertex
displacement, and that's

00:08:33.870 --> 00:08:37.893
a dramatic gain in resolving
power on the screen.

00:08:37.893 --> 00:08:39.809
So this image is comparing
vertex displacement

00:08:39.809 --> 00:08:43.400
all the way on the left
to a render texture, again

00:08:43.400 --> 00:08:44.900
set through Cardboard--
I think it's

00:08:44.900 --> 00:08:48.600
called screen scale-- at
one time screen resolution

00:08:48.600 --> 00:08:50.810
all the way up to two
time screen resolution,

00:08:50.810 --> 00:08:53.030
all using 4x antialiasing.

00:08:53.030 --> 00:08:55.010
And to my eye, the
vertex displacement

00:08:55.010 --> 00:08:56.950
looks about as sharp
as rendering the screen

00:08:56.950 --> 00:08:59.110
at 1 and 1/2 times
resolution, which

00:08:59.110 --> 00:09:00.840
is a huge gain in performance.

00:09:00.840 --> 00:09:04.000
Any time we can get an
extra 50% screen resolution

00:09:04.000 --> 00:09:06.200
for free, that's great.

00:09:06.200 --> 00:09:08.830
So you may be wondering,
OK, how does this work?

00:09:08.830 --> 00:09:10.690
Why is this the case?

00:09:10.690 --> 00:09:13.019
And this is maybe a
little hard to grok,

00:09:13.019 --> 00:09:14.560
but I'll try and
take you through it.

00:09:14.560 --> 00:09:16.690
If you remember from
before, because we're

00:09:16.690 --> 00:09:18.840
distorting the
underlying geometry,

00:09:18.840 --> 00:09:21.457
all of the interpreted
pixels actually get rendered.

00:09:21.457 --> 00:09:23.290
Whereas if we do this
with a render texture,

00:09:23.290 --> 00:09:24.930
we have to bilinearly
interpolate

00:09:24.930 --> 00:09:26.930
between screen pixels.

00:09:26.930 --> 00:09:29.650
So in this example, I
wrote a quick shader which

00:09:29.650 --> 00:09:31.860
I've included most of
at the bottom here,

00:09:31.860 --> 00:09:34.730
that just outputs eight
pixel lines based on screen

00:09:34.730 --> 00:09:35.950
coordinates.

00:09:35.950 --> 00:09:38.250
So this is a decent
proxy for resolution.

00:09:38.250 --> 00:09:40.380
Thinner lines in
this image represent

00:09:40.380 --> 00:09:44.290
areas of high resolution, thick
lines represent low resolution.

00:09:44.290 --> 00:09:46.110
So in the vertex
displacement case,

00:09:46.110 --> 00:09:49.620
everything's even, because
we're just rendering straight

00:09:49.620 --> 00:09:51.270
to the screen buffer.

00:09:51.270 --> 00:09:53.460
It looks like an even grid.

00:09:53.460 --> 00:09:55.930
In the render texture, you
see in the center pixels

00:09:55.930 --> 00:09:57.930
are getting blown up.

00:09:57.930 --> 00:10:01.420
So then if we increase
the resolution to 1.5,

00:10:01.420 --> 00:10:03.290
OK, we've matched
vertex displacement.

00:10:03.290 --> 00:10:06.060
But now we're rendering
all these extra pixels

00:10:06.060 --> 00:10:06.870
on the outer edge.

00:10:06.870 --> 00:10:11.240
And that's all completely wasted
and you're not looking there.

00:10:11.240 --> 00:10:13.230
So originally when we
used vertex displacement

00:10:13.230 --> 00:10:15.480
it was because of the
great performance gains.

00:10:15.480 --> 00:10:18.510
But the resolution enhancement
was really a great side effect.

00:10:18.510 --> 00:10:21.210
And I bring it up now
because on newer devices

00:10:21.210 --> 00:10:24.090
you might not be watching
performance as much, but maybe

00:10:24.090 --> 00:10:26.040
for your Cardboard
application you really need

00:10:26.040 --> 00:10:30.040
an extra kick in resolution.

00:10:30.040 --> 00:10:32.070
OK, so I've talked enough.

00:10:32.070 --> 00:10:33.490
It's great.

00:10:33.490 --> 00:10:36.430
You want to just get started.

00:10:36.430 --> 00:10:37.639
So I have good news.

00:10:37.639 --> 00:10:39.930
This feature is fully supported
in the latest Cardboard

00:10:39.930 --> 00:10:43.290
SDK for Unity, and it's
really easy to set up.

00:10:43.290 --> 00:10:45.840
So on your Cardboard
prefab in the scene,

00:10:45.840 --> 00:10:47.690
if you select
distortion correction,

00:10:47.690 --> 00:10:48.780
just set it to none.

00:10:48.780 --> 00:10:50.570
Turn it off.

00:10:50.570 --> 00:10:52.100
Then you modify your shaders.

00:10:52.100 --> 00:10:54.630
And that's it, you're done.

00:10:54.630 --> 00:10:57.370
And so many of you,
modifying shaders,

00:10:57.370 --> 00:10:59.210
that sounds really scary.

00:10:59.210 --> 00:11:03.374
So let's just do that
together very quickly.

00:11:03.374 --> 00:11:05.290
If you're writing your
own vertex and fragment

00:11:05.290 --> 00:11:07.440
shaders, which if you
are, that's awesome.

00:11:07.440 --> 00:11:08.660
I hope you are.

00:11:08.660 --> 00:11:11.940
It's a one line include
and a one line change.

00:11:11.940 --> 00:11:14.280
Instead of outputting the
vertex position multiplied

00:11:14.280 --> 00:11:16.210
by the model view
projection matrix,

00:11:16.210 --> 00:11:18.580
we include Cardboard
distortion and output

00:11:18.580 --> 00:11:20.720
this undistort vertex function.

00:11:20.720 --> 00:11:23.810
I've left the highlighting
in, but I've commented out

00:11:23.810 --> 00:11:25.940
the old MVP matrix.

00:11:25.940 --> 00:11:29.610
If you're doing advanced
things like shadows or anything

00:11:29.610 --> 00:11:31.950
with depth, don't forget to
also write a modified depth

00:11:31.950 --> 00:11:34.082
shader for any replace
shaders you're doing,

00:11:34.082 --> 00:11:35.290
otherwise effects won't work.

00:11:35.290 --> 00:11:39.265
And I'll come back to that
later and show you an example.

00:11:39.265 --> 00:11:40.640
If on the other
hand you're using

00:11:40.640 --> 00:11:42.477
Unity's built in
surface shaders,

00:11:42.477 --> 00:11:44.560
you just need to add a
very simple vertex function

00:11:44.560 --> 00:11:47.180
and add this one line.

00:11:47.180 --> 00:11:50.450
So really this is
a simple thing.

00:11:50.450 --> 00:11:52.544
Just create a new surface
shader, drop this in,

00:11:52.544 --> 00:11:53.460
and you're good to go.

00:11:56.280 --> 00:11:59.750
So let's talk about,
really quickly, how we did.

00:11:59.750 --> 00:12:03.720
On Design Lab, we rendered
about 700,000 vertices,

00:12:03.720 --> 00:12:06.570
or less, and under
100 draw calls.

00:12:06.570 --> 00:12:09.530
And we generally made our goal
of saying near 60 on the Nexus

00:12:09.530 --> 00:12:10.870
5.

00:12:10.870 --> 00:12:12.810
That vertex count
looks really high,

00:12:12.810 --> 00:12:16.190
but keep in mind that's
only 350,000 per eye.

00:12:16.190 --> 00:12:18.460
And any time you do hard
normals, which we really

00:12:18.460 --> 00:12:21.440
wanted for the aesthetic, it
multiplies the vertex count

00:12:21.440 --> 00:12:22.990
by about six.

00:12:22.990 --> 00:12:25.320
So In a modeling program
if you look at Design Lab,

00:12:25.320 --> 00:12:27.750
it looks like about 60,000
vertices, and you're like wow,

00:12:27.750 --> 00:12:28.260
this is great.

00:12:28.260 --> 00:12:29.100
This is super low poly.

00:12:29.100 --> 00:12:30.891
You pull it into Unity
and you're rendering

00:12:30.891 --> 00:12:32.730
700,000 all of a sudden.

00:12:32.730 --> 00:12:36.180
That might come as a shock.

00:12:36.180 --> 00:12:39.060
"Arctic Journey--" because we
wanted to pull it back even

00:12:39.060 --> 00:12:41.270
further, we wanted to
hit the S3 and the S4,

00:12:41.270 --> 00:12:43.920
and we really needed
those to get it 60.

00:12:43.920 --> 00:12:47.730
VR experiences of 30 just
aren't that compelling.

00:12:47.730 --> 00:12:50.960
We brought it down
to 250,000 vertices.

00:12:50.960 --> 00:12:52.980
We did that in a number of ways.

00:12:52.980 --> 00:12:55.660
A lot of it was just really
old school optimization

00:12:55.660 --> 00:12:58.330
techniques--
removing back faces,

00:12:58.330 --> 00:13:01.530
reducing model complexity based
on distance from the camera,

00:13:01.530 --> 00:13:05.820
and a really custom sort
of stupid LOD system

00:13:05.820 --> 00:13:08.190
that, as you change scenes,
we just turned things off.

00:13:08.190 --> 00:13:11.960
And we just did it by
hand, nothing really smart.

00:13:11.960 --> 00:13:13.920
But that alone wasn't enough.

00:13:13.920 --> 00:13:16.560
The rest of the performance
gains for the S3

00:13:16.560 --> 00:13:19.690
were made by removing
almost all of the textures

00:13:19.690 --> 00:13:22.810
and moving all of the shader
logic out of the pixel shader

00:13:22.810 --> 00:13:25.730
and into the vertex shader.

00:13:25.730 --> 00:13:28.290
And so that's sort of
the end of part one.

00:13:28.290 --> 00:13:32.190
And this is going to seem like
kind of a sudden transition,

00:13:32.190 --> 00:13:34.330
but this is important.

00:13:34.330 --> 00:13:38.440
Just doing vertex displacement
will get you in the ballpark.

00:13:38.440 --> 00:13:40.860
You've got a canvas to
work on, but you still

00:13:40.860 --> 00:13:46.240
have to try to find ways to
optimize for these devices.

00:13:46.240 --> 00:13:47.560
And that's challenging.

00:13:47.560 --> 00:13:48.500
And we really want
to make things

00:13:48.500 --> 00:13:51.083
look great without compromising
all those performance gains we

00:13:51.083 --> 00:13:53.755
just worked so hard to get.

00:13:53.755 --> 00:13:55.130
So now that maybe
you're thinking

00:13:55.130 --> 00:13:56.730
about vertex shaders
in a new way,

00:13:56.730 --> 00:13:59.200
I'm going to highlight a few
fun things we did with vertex

00:13:59.200 --> 00:14:02.270
shaders for other
effects, and then

00:14:02.270 --> 00:14:05.300
move on to a really quick review
of our custom lighting model

00:14:05.300 --> 00:14:08.342
we created, and wrap up with
a few optimizations tips.

00:14:10.902 --> 00:14:14.350
So the first example, the
balloons from Design Lab.

00:14:14.350 --> 00:14:17.350
So this is a relatively
simple shader.

00:14:17.350 --> 00:14:21.080
We're writing one constant from
the CPU, and that's explosion.

00:14:21.080 --> 00:14:22.930
It's written every frame.

00:14:22.930 --> 00:14:26.290
And then based on that constant
we scale all the vertices down

00:14:26.290 --> 00:14:28.380
and move them out
based on the normal.

00:14:28.380 --> 00:14:30.710
And you can see once at
the end, once we finished,

00:14:30.710 --> 00:14:33.460
we call that undistort vertex
function from the Cardboard SDK

00:14:33.460 --> 00:14:35.920
again, and it applies
the vertex displacement.

00:14:35.920 --> 00:14:37.750
And it looks great in VR.

00:14:37.750 --> 00:14:40.750
So again, a single floating
point value each frame,

00:14:40.750 --> 00:14:42.540
and we can generate
this whole effect.

00:14:42.540 --> 00:14:45.570
And this is actually
the case where

00:14:45.570 --> 00:14:48.210
we're doing both our
own custom effect

00:14:48.210 --> 00:14:51.160
and the vertex displacement,
and we have cast shadows.

00:14:51.160 --> 00:14:53.610
So there's a second
depth shader as well

00:14:53.610 --> 00:14:55.710
that writes out just
the modified depth, none

00:14:55.710 --> 00:14:56.751
of the color information.

00:15:00.310 --> 00:15:02.280
In "Arctic Journey," we
have this ocean shader,

00:15:02.280 --> 00:15:04.120
which I'm super proud of.

00:15:04.120 --> 00:15:06.570
The position values were
generating the vertex shader

00:15:06.570 --> 00:15:09.550
sort of in a standard way, three
overlapping sine functions,

00:15:09.550 --> 00:15:12.040
just multioctave noise.

00:15:12.040 --> 00:15:15.920
The tricky part's recalculating
normals in the vertex shader.

00:15:15.920 --> 00:15:18.310
Since vertices don't know
about their neighbors,

00:15:18.310 --> 00:15:21.370
you can't just recalculate
normals, right?

00:15:21.370 --> 00:15:23.940
So if you're in DX
11, maybe you're

00:15:23.940 --> 00:15:26.980
thinking like oh, I'll just
do this on a geometry shader.

00:15:26.980 --> 00:15:27.990
But we're on mobile.

00:15:27.990 --> 00:15:31.840
Those aren't available
everywhere, until now.

00:15:31.840 --> 00:15:34.830
And anyway, they can
still be expensive.

00:15:34.830 --> 00:15:37.960
So instead, we packed the
whole triangle into each vertex

00:15:37.960 --> 00:15:40.780
by passing the additional verts
through the normal and tangent.

00:15:40.780 --> 00:15:43.220
So you can see in that
vertex input struct,

00:15:43.220 --> 00:15:44.804
there's position,
normal, and tangent.

00:15:44.804 --> 00:15:46.594
But instead of using
the normal and tangent

00:15:46.594 --> 00:15:48.970
for normal and tangent, we're
just encoding the other two

00:15:48.970 --> 00:15:49.850
vertices.

00:15:49.850 --> 00:15:51.975
So we have all three
vertices, and then we can just

00:15:51.975 --> 00:15:53.630
do a really quick calculation.

00:15:53.630 --> 00:15:55.980
Because we're hard normals,
this is really easy.

00:15:55.980 --> 00:15:57.980
If you're doing soft
normals, it would obviously

00:15:57.980 --> 00:15:59.188
be a little more complicated.

00:16:01.760 --> 00:16:04.620
And then this is an
extension of the same idea.

00:16:04.620 --> 00:16:07.030
We needed to get that
draw call count down,

00:16:07.030 --> 00:16:08.721
but we really wanted
to have icebergs

00:16:08.721 --> 00:16:10.970
that were affected by the
waves and other objects that

00:16:10.970 --> 00:16:12.180
were affected by the waves.

00:16:12.180 --> 00:16:15.870
So already we've got, what,
10 icebergs in this one area,

00:16:15.870 --> 00:16:18.280
and there are
hundreds in the scene.

00:16:18.280 --> 00:16:20.140
That's obviously
not going to work.

00:16:20.140 --> 00:16:21.580
Draw calls are super expensive.

00:16:21.580 --> 00:16:24.335
So to reduce them, we need to
batch them together somehow,

00:16:24.335 --> 00:16:26.460
but now we need these
objects to move independently

00:16:26.460 --> 00:16:28.340
of each other.

00:16:28.340 --> 00:16:32.140
You could do this by rigging
up bones in Maya then animating

00:16:32.140 --> 00:16:34.840
the bones, but that's
not going to respond

00:16:34.840 --> 00:16:36.140
to your procedural effects.

00:16:36.140 --> 00:16:38.580
It's involved.

00:16:38.580 --> 00:16:40.470
It's just not fun.

00:16:40.470 --> 00:16:44.690
So instead, for each vertex,
we encoded the world space

00:16:44.690 --> 00:16:47.850
x and z object location
into the UV channels.

00:16:47.850 --> 00:16:49.990
We're not using our UVs anyway.

00:16:49.990 --> 00:16:53.860
And then we used that object
location, per iceberg,

00:16:53.860 --> 00:16:56.990
to determine the
object y offset.

00:16:56.990 --> 00:17:00.020
And then the vertices
just operated normally.

00:17:00.020 --> 00:17:01.460
So really simple trick.

00:17:01.460 --> 00:17:04.910
We did really like
stupid batching,

00:17:04.910 --> 00:17:06.422
but it saved hundreds
of draw calls

00:17:06.422 --> 00:17:08.380
and allowed us to get
this effect very cheaply.

00:17:11.160 --> 00:17:14.710
OK, so those are some
really basic tricks

00:17:14.710 --> 00:17:17.579
we did with the vertex shader.

00:17:17.579 --> 00:17:19.416
But now let's talk
about lighting.

00:17:19.416 --> 00:17:20.790
Because the major
way we maintain

00:17:20.790 --> 00:17:22.910
performance on
both experiences is

00:17:22.910 --> 00:17:25.970
by moving the lighting from
the pixel shader to the vertex

00:17:25.970 --> 00:17:27.140
shader.

00:17:27.140 --> 00:17:29.540
Because we already needed
all that extra tessellation

00:17:29.540 --> 00:17:31.340
for the distortion
correction, it

00:17:31.340 --> 00:17:33.800
allowed for high quality vertex
lighting at the same time.

00:17:33.800 --> 00:17:35.350
And I'm going to show
some of that off.

00:17:35.350 --> 00:17:37.225
Many of you when you
hear vertex lighting you

00:17:37.225 --> 00:17:42.750
think, oh man, boy, it's
like Nintendo 64 days.

00:17:42.750 --> 00:17:45.080
But when you have
enough vertices

00:17:45.080 --> 00:17:47.940
and you have so much available
performance in the vert shader,

00:17:47.940 --> 00:17:50.420
you can really do a lot.

00:17:50.420 --> 00:17:53.020
So it's an entirely
custom lighting model.

00:17:53.020 --> 00:17:55.400
I think in both of these
we use a single D-light,

00:17:55.400 --> 00:17:59.780
a single directional
light, fog, ambience.

00:17:59.780 --> 00:18:01.430
There was optionally
one point light.

00:18:01.430 --> 00:18:02.388
We could've added more.

00:18:02.388 --> 00:18:03.980
We just didn't need them.

00:18:03.980 --> 00:18:07.660
In Design Lab, we wrote a
custom exponential shadow map

00:18:07.660 --> 00:18:10.040
solution, specifically
so that we only

00:18:10.040 --> 00:18:11.900
had to do the shadows once.

00:18:11.900 --> 00:18:15.100
I think Unity now has a
solution for VR shadows.

00:18:15.100 --> 00:18:19.440
At the time they didn't,
so we just did it.

00:18:19.440 --> 00:18:22.420
Design Lab used textures for
ambient occlusion and color.

00:18:22.420 --> 00:18:24.200
"Arctic Journey" used
almost no textures

00:18:24.200 --> 00:18:28.655
whatsoever except in very
few really small cases.

00:18:28.655 --> 00:18:31.030
I'll go through each of the
major stages, the most common

00:18:31.030 --> 00:18:33.920
shader to render this scene.

00:18:33.920 --> 00:18:37.960
First of all this, always comes
up, but it happens so often.

00:18:37.960 --> 00:18:39.950
It's always worth noting
that the geometry is

00:18:39.950 --> 00:18:42.090
rendered before the sky box.

00:18:42.090 --> 00:18:46.180
Fill rate is your most expensive
enemy on mobile, doubly so

00:18:46.180 --> 00:18:49.210
on VR, whether you're rendering
to vertex displacement

00:18:49.210 --> 00:18:54.180
or even more if you're
rendering to the render texture.

00:18:54.180 --> 00:18:55.690
But by rendering
the geometry first,

00:18:55.690 --> 00:18:56.970
the graphics card
doesn't need to worry

00:18:56.970 --> 00:18:58.553
about all those black
pixels that have

00:18:58.553 --> 00:19:01.810
been included in the sky box.

00:19:01.810 --> 00:19:04.230
The next pass was fog color.

00:19:04.230 --> 00:19:06.350
This was interpreted based
on height and distance

00:19:06.350 --> 00:19:07.020
to the camera.

00:19:07.020 --> 00:19:08.270
This was all configurable.

00:19:08.270 --> 00:19:12.600
It was animated so we could
do time of day transitions.

00:19:12.600 --> 00:19:14.610
Fog alpha was
calculated separately.

00:19:14.610 --> 00:19:16.354
Same sort of deal there.

00:19:18.860 --> 00:19:22.480
The ambient term was specified
by two colors, a sky color

00:19:22.480 --> 00:19:24.420
from directly
above, and a ground

00:19:24.420 --> 00:19:26.330
color from directly below.

00:19:26.330 --> 00:19:28.480
The shader interpolated
between these two

00:19:28.480 --> 00:19:30.170
based on the object's
surface normal.

00:19:33.140 --> 00:19:35.790
Standard Lambertian
version diffuse, N dot L.

00:19:35.790 --> 00:19:39.160
And this clearly suffers a
bit from vertex lighting.

00:19:39.160 --> 00:19:40.960
Because we used a
hard normal look,

00:19:40.960 --> 00:19:43.042
we sort of got away with it.

00:19:43.042 --> 00:19:45.930
Oh, and these two foxes-- so
I included these two foxes

00:19:45.930 --> 00:19:48.570
because, OK, both "Arctic
Journey" and Cardboard Design

00:19:48.570 --> 00:19:51.070
Lab used hard normals for
part of the aesthetic.

00:19:51.070 --> 00:19:52.890
But most games
probably don't do that.

00:19:52.890 --> 00:19:55.580
If you're making an
application, maybe you

00:19:55.580 --> 00:19:58.110
want soft normals, a
really smooth look.

00:19:58.110 --> 00:19:59.730
So I included a
soft normal version

00:19:59.730 --> 00:20:01.200
of the fox for all
of these images

00:20:01.200 --> 00:20:03.660
just so you can get a sense
of what it looks like.

00:20:03.660 --> 00:20:05.410
And you can see that
version in this image

00:20:05.410 --> 00:20:06.730
really kind of looks bad.

00:20:06.730 --> 00:20:13.470
It does look sort of like three
generation old console game.

00:20:13.470 --> 00:20:15.070
So depending on the
project, you may

00:20:15.070 --> 00:20:18.350
want to do this one calculation
in the pixel shader,

00:20:18.350 --> 00:20:20.687
or just keep bumping
the tessellation

00:20:20.687 --> 00:20:22.020
until things start to look good.

00:20:22.020 --> 00:20:25.220
Vertices are really cheap.

00:20:25.220 --> 00:20:26.730
We also added Fresnel.

00:20:26.730 --> 00:20:29.380
We're just going
crazy now because we

00:20:29.380 --> 00:20:31.860
can do all kinds of math
in here and it's not really

00:20:31.860 --> 00:20:33.820
affecting performance.

00:20:33.820 --> 00:20:36.237
I'm surprised at how
good this looked.

00:20:36.237 --> 00:20:37.987
And then here's all
the lighting combined.

00:20:40.790 --> 00:20:43.610
Lastly, we baked
all of the color

00:20:43.610 --> 00:20:45.000
into the vertices themselves.

00:20:45.000 --> 00:20:48.120
We wrote a little tool
in Unity to read out

00:20:48.120 --> 00:20:50.250
the values from a texture
so our artists could

00:20:50.250 --> 00:20:52.190
do a normal texture
painting workflow,

00:20:52.190 --> 00:20:54.700
and then we just baked
them into the vertices.

00:20:54.700 --> 00:20:57.090
That was the way we got rid
of most of the textures.

00:20:59.897 --> 00:21:01.188
And then finally the composite.

00:21:05.580 --> 00:21:08.070
So I've talked about lighting.

00:21:08.070 --> 00:21:10.560
I've talked about
vertex displacement.

00:21:10.560 --> 00:21:12.310
And then I'm going to
sort of wrap this up

00:21:12.310 --> 00:21:13.800
with some optimization
tips, and then we'll

00:21:13.800 --> 00:21:15.508
have a good amount of
time for questions.

00:21:19.100 --> 00:21:23.390
So the biggest lesson we learned
really was write your shaders.

00:21:23.390 --> 00:21:26.840
When we started up
a Cardboard project

00:21:26.840 --> 00:21:30.190
and then tried to build
to really old or low power

00:21:30.190 --> 00:21:34.000
devices, we were immediately
running into problems.

00:21:34.000 --> 00:21:37.690
This was increased by the
default sky box, the Unity

00:21:37.690 --> 00:21:38.890
standard shader.

00:21:38.890 --> 00:21:42.270
These things are built for
achieving really great effects

00:21:42.270 --> 00:21:44.670
on high power devices,
but you're probably

00:21:44.670 --> 00:21:46.922
going to need to scale
things back immediately.

00:21:46.922 --> 00:21:48.380
And one of the ways
you can do that

00:21:48.380 --> 00:21:51.120
is moving your code
from the pixel shader

00:21:51.120 --> 00:21:54.300
to the vert shader, even if
you need to add vertices.

00:21:54.300 --> 00:21:57.960
These screens have something
like 4 million pixels.

00:21:57.960 --> 00:22:00.220
So any time you're
moving to running

00:22:00.220 --> 00:22:04.070
an operation a couple thousand
times, over 4 million times

00:22:04.070 --> 00:22:08.370
plus overdraw, you're winning.

00:22:08.370 --> 00:22:11.486
The second note, use half
precision, but be careful.

00:22:11.486 --> 00:22:14.400
2 to the 16th isn't that big.

00:22:14.400 --> 00:22:17.770
One of the examples
we had here, if you're

00:22:17.770 --> 00:22:20.042
used to writing shaders
and you write half,

00:22:20.042 --> 00:22:24.100
half precision
doesn't exist on PC.

00:22:24.100 --> 00:22:26.640
Everything gets compiled to
float, and will run at float.

00:22:26.640 --> 00:22:29.310
So you've switched everything
to half precision, great.

00:22:29.310 --> 00:22:32.430
And then you make a build
and everything is broken.

00:22:32.430 --> 00:22:35.350
In the case we had here,
we had rendered the sun.

00:22:35.350 --> 00:22:37.940
The sun was a
pixel shader effect

00:22:37.940 --> 00:22:42.740
based on the dot product
of vector direction,

00:22:42.740 --> 00:22:46.000
and then a scalar value
for how big it was.

00:22:46.000 --> 00:22:47.380
And at some point
someone decided

00:22:47.380 --> 00:22:49.380
they wanted to make
the sky box bigger

00:22:49.380 --> 00:22:52.490
so that we could see a
further draw distance.

00:22:52.490 --> 00:22:57.230
After we did that, I
started getting bug reports

00:22:57.230 --> 00:23:00.820
from people testing on
devices that the sun was huge.

00:23:00.820 --> 00:23:02.740
And I'm trying to
figure this out,

00:23:02.740 --> 00:23:05.220
the sun's huge,
classic engineer thing.

00:23:05.220 --> 00:23:07.580
I said no it's not, it's fine.

00:23:07.580 --> 00:23:08.620
Nothing's wrong.

00:23:08.620 --> 00:23:10.310
And I got a device
and in fact the sun

00:23:10.310 --> 00:23:13.150
was taking up the entire sky.

00:23:13.150 --> 00:23:14.780
And what had
happened was someone

00:23:14.780 --> 00:23:20.530
had scaled the sky box from
200 meters to 300 meters.

00:23:20.530 --> 00:23:23.802
And I'm sitting there
scratching my head.

00:23:23.802 --> 00:23:25.760
And I looked in there
and they were all halves.

00:23:25.760 --> 00:23:30.370
So 256 squared, we were
doing a length calculation,

00:23:30.370 --> 00:23:32.090
that number was exploding.

00:23:32.090 --> 00:23:35.510
And the sun blew up.

00:23:35.510 --> 00:23:38.770
Lastly, get clever with your
vertex data and uniforms.

00:23:38.770 --> 00:23:41.480
You can pack a lot of data into
your vertices from the CPU,

00:23:41.480 --> 00:23:43.560
and you can do that once.

00:23:43.560 --> 00:23:48.100
Things like batching or
packing other vertices in

00:23:48.100 --> 00:23:50.370
and calculating your normals.

00:23:50.370 --> 00:23:51.930
Moving data, any
time you can move it

00:23:51.930 --> 00:23:54.980
from either per vertex
operations on the CPU

00:23:54.980 --> 00:23:58.380
to the GPU, or per pixel
operations back to the vertex

00:23:58.380 --> 00:24:01.690
shader, you're running.

00:24:01.690 --> 00:24:06.380
Textures-- watch out for large,
uncompressed, or non mipmap

00:24:06.380 --> 00:24:07.350
textures.

00:24:07.350 --> 00:24:09.790
One of the biggest problems
we had on Design Lab

00:24:09.790 --> 00:24:14.800
was there was a really small,
uncompressed texture that

00:24:14.800 --> 00:24:17.450
didn't have mipmaps
hiding out on one object.

00:24:17.450 --> 00:24:19.370
And any time you looked
in one direction,

00:24:19.370 --> 00:24:21.890
the performance would drop,
and we couldn't figure it out.

00:24:21.890 --> 00:24:23.620
The vertex count
wasn't going up.

00:24:23.620 --> 00:24:25.380
The memory wasn't
really increasing.

00:24:25.380 --> 00:24:29.100
Finally we found this texture
and flipped the mipmaps on,

00:24:29.100 --> 00:24:30.390
and everything was fine.

00:24:30.390 --> 00:24:32.470
And what's happening
is, especially

00:24:32.470 --> 00:24:35.430
on some of the older devices,
the cache isn't very large,

00:24:35.430 --> 00:24:37.520
and you're blowing through
your texture cache.

00:24:37.520 --> 00:24:41.510
So those things can
really seem insurmountable

00:24:41.510 --> 00:24:43.190
and really confusing.

00:24:43.190 --> 00:24:48.250
But if you know what to look
out for, it's not too bad.

00:24:48.250 --> 00:24:51.050
Again, on "Arctic Journey,"
we approached this

00:24:51.050 --> 00:24:52.730
by removing all of the textures.

00:24:52.730 --> 00:24:55.980
It's obviously an easy solution.

00:24:55.980 --> 00:24:58.140
Avoid hidden dependent
texture reads.

00:24:58.140 --> 00:24:59.640
Nathan Martz actually
mentioned this

00:24:59.640 --> 00:25:01.900
to me, something I'd forgotten.

00:25:01.900 --> 00:25:04.310
Any time you are
calculating your UV

00:25:04.310 --> 00:25:08.220
coordinates in the pixel shader,
it's a dependent texture read

00:25:08.220 --> 00:25:10.250
and it goes through a slow path.

00:25:10.250 --> 00:25:14.560
And what he reminded me of was
that even swizzle operators

00:25:14.560 --> 00:25:16.510
count as dependent
texture reads.

00:25:16.510 --> 00:25:19.630
So if you've passed four UV
coordinates from your vertex

00:25:19.630 --> 00:25:22.020
shader into your pixel
shader and you're like great,

00:25:22.020 --> 00:25:24.780
I can read in the two textures,
this one dot xy, this one dot

00:25:24.780 --> 00:25:31.620
zw, those are dependent
texture read on Open GL ES.

00:25:31.620 --> 00:25:34.270
And then pack your channels.

00:25:34.270 --> 00:25:37.840
Don't just upload an alpha
channel, upload a full RGBA

00:25:37.840 --> 00:25:40.022
and use all of your channels.

00:25:40.022 --> 00:25:42.230
Or maybe you can bake the
whole texture into vertices

00:25:42.230 --> 00:25:42.730
like we did.

00:25:46.050 --> 00:25:47.950
OK, optimization.

00:25:47.950 --> 00:25:50.240
A lot of people ask us,
how did you optimize?

00:25:50.240 --> 00:25:51.662
What's the most important?

00:25:51.662 --> 00:25:53.870
And the answer I
always give, first

00:25:53.870 --> 00:25:55.510
you really need to profile.

00:25:55.510 --> 00:25:58.610
And this can be challenging.

00:25:58.610 --> 00:26:00.580
It's often very
hard to figure out

00:26:00.580 --> 00:26:04.690
what your limiting factor is.

00:26:04.690 --> 00:26:07.160
So we had a lot of really
simple test scenes.

00:26:07.160 --> 00:26:09.200
For fill rate, we
usually replace

00:26:09.200 --> 00:26:12.380
all of the shaders with
a solid color shader.

00:26:12.380 --> 00:26:15.510
That was the easiest way to
tell if we were burning fill.

00:26:15.510 --> 00:26:18.737
Make sure things like
the Unity sky box

00:26:18.737 --> 00:26:20.528
are turned off if you're
doing these tests.

00:26:24.220 --> 00:26:27.250
Other examples, just
removing all the objects

00:26:27.250 --> 00:26:28.230
and rendering a cube.

00:26:28.230 --> 00:26:29.700
That was actually
how we discovered

00:26:29.700 --> 00:26:34.140
that the render texture was
the problem to begin with.

00:26:34.140 --> 00:26:36.800
The first test we did on
the S3 that really showed us

00:26:36.800 --> 00:26:40.680
we had a problem was just
a simple cube in a room.

00:26:40.680 --> 00:26:45.410
Second, it's
probably draw calls.

00:26:45.410 --> 00:26:47.550
Eliminating draw calls,
either by batching objects

00:26:47.550 --> 00:26:50.930
together or removing
them, is always good.

00:26:50.930 --> 00:26:52.880
Third, minimizing
textures, either

00:26:52.880 --> 00:26:56.510
by reducing them in size,
removing them all together,

00:26:56.510 --> 00:26:59.970
enabling mipmaps,
turning on compression.

00:26:59.970 --> 00:27:04.060
Fourth, simply your
fragment shaders if you can.

00:27:04.060 --> 00:27:06.200
Pull data into vertex shooters.

00:27:06.200 --> 00:27:10.250
And lastly, reducing
your vertex count.

00:27:10.250 --> 00:27:13.450
I say lastly because
most of the optimizations

00:27:13.450 --> 00:27:14.890
we've been doing
before have been

00:27:14.890 --> 00:27:16.770
increasing vertex complexity.

00:27:16.770 --> 00:27:18.940
And you may have needed
to increase vertex count.

00:27:18.940 --> 00:27:20.800
And typically those
are more important.

00:27:20.800 --> 00:27:24.386
Obviously if you're running
10 million vertices,

00:27:24.386 --> 00:27:25.760
that balance shifts
a little bit.

00:27:30.630 --> 00:27:33.020
Sorry.

00:27:33.020 --> 00:27:35.320
Oh right, some resources.

00:27:35.320 --> 00:27:37.770
The Cardboard SDK for
Unity of course, which

00:27:37.770 --> 00:27:39.700
is a great place to start.

00:27:39.700 --> 00:27:41.200
And as I mentioned
at the beginning,

00:27:41.200 --> 00:27:43.510
Cardboard Design
Lab is open source.

00:27:43.510 --> 00:27:45.180
So definitely go grab that.

00:27:45.180 --> 00:27:48.430
You can check out a lot
of this stuff there.

00:27:48.430 --> 00:27:52.170
And then one final link, the
Open GL ES optimization tips.

00:27:52.170 --> 00:27:54.390
It goes into a lot
more detail of some

00:27:54.390 --> 00:27:56.170
of the things I've
mentioned here,

00:27:56.170 --> 00:27:59.970
especially some of the weirdness
with swizzling textures,

00:27:59.970 --> 00:28:01.356
other things you might run into.

00:28:03.980 --> 00:28:06.490
So thank you.

00:28:06.490 --> 00:28:08.496
And then, questions?

00:28:08.496 --> 00:28:11.448
[APPLAUSE]

00:28:18.336 --> 00:28:20.752
AUDIENCE: What about chromatic
aberration correction

00:28:20.752 --> 00:28:21.710
using these techniques?

00:28:21.710 --> 00:28:23.293
BRIAN KEHRER: That's
a great question.

00:28:23.293 --> 00:28:26.720
No, we did not do any.

00:28:26.720 --> 00:28:29.200
Fortunately the
lenses on Cardboard

00:28:29.200 --> 00:28:31.970
don't seem to exhibit a whole
lot of chromatic aberration.

00:28:31.970 --> 00:28:36.800
But yeah, if you're on a
headset that does, you're shot.

00:28:36.800 --> 00:28:39.614
That's a great case for
using a render texture.

00:28:39.614 --> 00:28:41.030
AUDIENCE: And the
second question,

00:28:41.030 --> 00:28:44.475
how does this technique
relate to Daydream?

00:28:44.475 --> 00:28:46.850
BRIAN KEHRER: Right, so this
is not supported on Daydream

00:28:46.850 --> 00:28:50.180
because Daydream
is using a render

00:28:50.180 --> 00:28:56.130
texture for a few effects,
some electronic stabilization

00:28:56.130 --> 00:28:58.000
and a few others.

00:28:58.000 --> 00:29:00.190
I just found out
about Daydream today.

00:29:00.190 --> 00:29:05.100
So those guys are on the--
what's the channel, sorry?

00:29:05.100 --> 00:29:06.140
AUDIENCE: The space.

00:29:06.140 --> 00:29:08.050
BRIAN KEHRER: The
space, right, the space.

00:29:08.050 --> 00:29:10.647
So if you ask them, they
can give you more detail.

00:29:10.647 --> 00:29:11.480
AUDIENCE: Thank you.

00:29:15.480 --> 00:29:18.480
AUDIENCE: Implementation
about the distortion,

00:29:18.480 --> 00:29:21.865
is it in the source so we
can check a little bit how

00:29:21.865 --> 00:29:22.850
it was done?

00:29:22.850 --> 00:29:27.050
BRIAN KEHRER: Yeah, so the cginc
that Cardboard is included,

00:29:27.050 --> 00:29:33.230
it's just using a Brown-Conrady
expansion of terms.

00:29:33.230 --> 00:29:36.404
So it's squared, fourth.

00:29:36.404 --> 00:29:38.070
But it's all in there
so you can see it.

00:29:38.070 --> 00:29:39.350
I didn't include
it just because it

00:29:39.350 --> 00:29:41.308
started to get a little
bit math heavy and then

00:29:41.308 --> 00:29:42.464
like a lot of code.

00:29:42.464 --> 00:29:43.380
But it's all in there.

00:29:43.380 --> 00:29:44.640
So check it out.

00:29:44.640 --> 00:29:47.174
AUDIENCE: OK, thanks.

00:29:47.174 --> 00:29:49.090
AUDIENCE: I think that
was my second question.

00:29:49.090 --> 00:29:51.912
The source code's available
through the GitHib

00:29:51.912 --> 00:29:52.820
repo that you--

00:29:52.820 --> 00:29:55.641
BRIAN KEHRER: Yeah, do you want
me to-- I can click it back.

00:29:55.641 --> 00:29:58.100
AUDIENCE: Yeah, so Unity
[INAUDIBLE], Unity [INAUDIBLE]?

00:29:58.100 --> 00:30:00.130
BRIAN KEHRER: Yeah, if you check
out the Cardboard Design Lab

00:30:00.130 --> 00:30:01.150
source, it's in there.

00:30:01.150 --> 00:30:02.882
AUDIENCE: And the
second question,

00:30:02.882 --> 00:30:06.526
do you do a brute force render
for the left and right eye,

00:30:06.526 --> 00:30:10.824
or do you optimize by
material in your shader?

00:30:10.824 --> 00:30:12.490
BRIAN KEHRER: Yeah,
so one of the things

00:30:12.490 --> 00:30:15.220
I was thinking
about doing was what

00:30:15.220 --> 00:30:17.730
if we packed all
the data into-- what

00:30:17.730 --> 00:30:21.270
if we packed the left and right
vertices into a single object,

00:30:21.270 --> 00:30:25.680
and then passed in two matrices?

00:30:25.680 --> 00:30:28.930
We didn't get
there because there

00:30:28.930 --> 00:30:31.180
were some other problems
with clipping and coloring

00:30:31.180 --> 00:30:31.810
and stuff.

00:30:31.810 --> 00:30:33.670
I just didn't have time, really.

00:30:33.670 --> 00:30:36.228
But yes, I think
that's possible.

00:30:40.800 --> 00:30:43.060
Anyone else?

00:30:43.060 --> 00:30:45.520
Anyone?

00:30:45.520 --> 00:30:46.420
Cool.

00:30:46.420 --> 00:30:49.770
[MUSIC PLAYING]

