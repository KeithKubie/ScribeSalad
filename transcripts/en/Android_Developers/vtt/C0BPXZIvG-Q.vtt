WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.485
[MUSIC PLAYING]

00:00:05.970 --> 00:00:08.570
KELLY COX-JORRIE: Good
morning, everyone.

00:00:08.570 --> 00:00:09.650
I'm Kelly.

00:00:09.650 --> 00:00:12.720
And I work with music
and audio app developers

00:00:12.720 --> 00:00:15.580
to help them launch and
build successful businesses

00:00:15.580 --> 00:00:17.010
on Google Play.

00:00:17.010 --> 00:00:19.960
We're really excited to be here
today to share with you both

00:00:19.960 --> 00:00:23.150
technical and business best
practices for developers that

00:00:23.150 --> 00:00:26.920
require high-quality audio.

00:00:26.920 --> 00:00:29.340
So our session is
divided into three parts.

00:00:29.340 --> 00:00:31.110
I'm first going to
share with you tips

00:00:31.110 --> 00:00:33.920
from leading audio developers
who have successfully

00:00:33.920 --> 00:00:35.710
built businesses on Android.

00:00:35.710 --> 00:00:38.300
Then Don is going
to join me on stage

00:00:38.300 --> 00:00:41.160
to share common technical
hurdles that audio developers

00:00:41.160 --> 00:00:43.650
face and ways to overcome them.

00:00:43.650 --> 00:00:47.100
Then Phil will be announcing
our latest AAudio framework

00:00:47.100 --> 00:00:48.920
that we think will
help developers

00:00:48.920 --> 00:00:50.740
reach your performance needs.

00:00:50.740 --> 00:00:53.870
Then to wrap things up,
we'll have ROLI's CEO--

00:00:53.870 --> 00:00:56.820
join us on stage for a
really cool live music demo.

00:00:56.820 --> 00:00:59.260
So stick around.

00:00:59.260 --> 00:01:01.820
So I grew up in Los
Angeles, California

00:01:01.820 --> 00:01:04.129
in a very musical family.

00:01:04.129 --> 00:01:06.030
And I remember the first
time I stepped foot

00:01:06.030 --> 00:01:07.680
into a music studio.

00:01:07.680 --> 00:01:08.890
It was really exciting.

00:01:08.890 --> 00:01:11.290
But I was also a bit
overwhelmed by the amount

00:01:11.290 --> 00:01:14.060
of professional tools
and expensive equipment,

00:01:14.060 --> 00:01:16.680
and not to mention that
renting the music studio itself

00:01:16.680 --> 00:01:19.420
wasn't exactly affordable.

00:01:19.420 --> 00:01:21.760
As a teenager,
these DJ turntables

00:01:21.760 --> 00:01:23.260
were my favorite
piece of equipment,

00:01:23.260 --> 00:01:24.840
because I thought
it was pretty cool

00:01:24.840 --> 00:01:27.890
being able to mix my favorite
beats for my friends.

00:01:27.890 --> 00:01:30.540
But as cool as these
turntables are,

00:01:30.540 --> 00:01:33.030
having access to
expensive equipment

00:01:33.030 --> 00:01:35.070
or an expensive
studio isn't really

00:01:35.070 --> 00:01:37.180
feasible for most people.

00:01:37.180 --> 00:01:39.080
So luckily, for the
billions of people

00:01:39.080 --> 00:01:41.740
around the world who
want to produce music,

00:01:41.740 --> 00:01:44.850
music creation has
changed drastically.

00:01:44.850 --> 00:01:46.940
Now with the
accessibility of mobile,

00:01:46.940 --> 00:01:50.330
you can simply download an app
and have pro-like quality music

00:01:50.330 --> 00:01:54.160
instrument and a music studio
directly in your pocket,

00:01:54.160 --> 00:01:57.930
making these DJ turntables
accessible to everyone

00:01:57.930 --> 00:01:59.470
on their phones.

00:01:59.470 --> 00:02:02.810
And that's why we've seen
tremendous popularity in apps

00:02:02.810 --> 00:02:06.630
like Edjing with over
45 million installs.

00:02:06.630 --> 00:02:08.560
But of course, it's
not just DJ apps

00:02:08.560 --> 00:02:10.180
that have grown in popularity.

00:02:10.180 --> 00:02:12.290
It's apps that allow
you to sing karaoke,

00:02:12.290 --> 00:02:17.530
such as Smule Sing with over 52
million monthly active users,

00:02:17.530 --> 00:02:19.780
and apps like Korg
KAOSSILATOR that

00:02:19.780 --> 00:02:21.980
recently released on Android.

00:02:21.980 --> 00:02:24.940
And while high-quality audio
is important to music creation

00:02:24.940 --> 00:02:28.420
apps, it's also important to
a whole host of other apps,

00:02:28.420 --> 00:02:31.900
such as VR or voice-reliant
apps or games.

00:02:31.900 --> 00:02:36.080
And the market for high-quality
audio apps is only expanding.

00:02:36.080 --> 00:02:37.810
So that's why I'd like
to now dive deeper

00:02:37.810 --> 00:02:39.740
into the first part
of our agenda, which

00:02:39.740 --> 00:02:41.990
is sharing with you
three best practices

00:02:41.990 --> 00:02:45.280
from leading audio developers
who have successfully launched

00:02:45.280 --> 00:02:47.500
and built their
businesses on Google--

00:02:47.500 --> 00:02:49.470
Android.

00:02:49.470 --> 00:02:53.150
These best practices are
launch smart, think global,

00:02:53.150 --> 00:02:55.710
and, everyone's
favorite, make money.

00:02:55.710 --> 00:02:56.710
So first, launch smart--

00:03:00.020 --> 00:03:02.660
so we know that device
fragmentation on Android

00:03:02.660 --> 00:03:04.920
can be a major challenge
for developers that

00:03:04.920 --> 00:03:07.630
require high-performance audio.

00:03:07.630 --> 00:03:10.300
In order to deliver the
best user experience,

00:03:10.300 --> 00:03:13.790
it's important to understand
what device work well

00:03:13.790 --> 00:03:15.320
for your performance needs.

00:03:15.320 --> 00:03:17.010
By performance here,
I'm specifically

00:03:17.010 --> 00:03:19.560
talking about a device's
CPU and latency,

00:03:19.560 --> 00:03:23.050
with the lower the latency,
the better the user experience.

00:03:23.050 --> 00:03:26.590
So let's take a look now at how
Joy Tunes, an app that requires

00:03:26.590 --> 00:03:29.800
low latency, approached
launching on Android

00:03:29.800 --> 00:03:32.750
in order to maximize their reach
but still achieve a good user

00:03:32.750 --> 00:03:34.890
experience.

00:03:34.890 --> 00:03:38.040
So Joy Tunes is the
creator of Simply Piano,

00:03:38.040 --> 00:03:40.300
a subscription-based
music app that helps

00:03:40.300 --> 00:03:42.550
users learn how to play piano.

00:03:42.550 --> 00:03:45.480
In fact, my daughter
here has learned

00:03:45.480 --> 00:03:48.660
how to play piano almost
exclusively on this app.

00:03:48.660 --> 00:03:51.590
So we've had a piano in my
household her entire life.

00:03:51.590 --> 00:03:53.220
And it wasn't until
I introduced her

00:03:53.220 --> 00:03:55.860
to this app did she think
that playing piano was

00:03:55.860 --> 00:03:57.400
all of a sudden fun.

00:03:57.400 --> 00:04:00.520
So what she does is she
simply follows along

00:04:00.520 --> 00:04:02.570
to the guided
lessons on our piano.

00:04:02.570 --> 00:04:04.280
And the app
immediately recognizes

00:04:04.280 --> 00:04:06.710
what she's playing and
then provides feedback

00:04:06.710 --> 00:04:08.770
to her to help her improve.

00:04:08.770 --> 00:04:11.310
So the key here is that when
my daughter presses down

00:04:11.310 --> 00:04:14.380
on the piano keys, she
expects that Simply Piano will

00:04:14.380 --> 00:04:17.720
immediately and accurately
hear what she's playing

00:04:17.720 --> 00:04:19.459
and provide feedback.

00:04:19.459 --> 00:04:21.839
But in order to have
this experience,

00:04:21.839 --> 00:04:24.750
Simply Piano
requires low latency

00:04:24.750 --> 00:04:27.760
of playback and recording
of musical tracks.

00:04:27.760 --> 00:04:31.210
So to figure out what devices
meet their low latency

00:04:31.210 --> 00:04:33.570
and computational
performance needs,

00:04:33.570 --> 00:04:35.870
they first launched a
beta version of their app

00:04:35.870 --> 00:04:38.810
in our Early Access collection.

00:04:38.810 --> 00:04:43.740
So Early Access is a collection
on Google Play for new selected

00:04:43.740 --> 00:04:46.020
apps that are still in beta.

00:04:46.020 --> 00:04:48.710
Inclusion in this
collection enabled Joy Tunes

00:04:48.710 --> 00:04:52.510
to build a beta audience and to
be able to collect private user

00:04:52.510 --> 00:04:53.590
feedback.

00:04:53.590 --> 00:04:56.920
This enabled them to identify
both problematic devices where

00:04:56.920 --> 00:05:00.440
users were having a poor
quality audio experience,

00:05:00.440 --> 00:05:02.920
but also problematic
regions that they were then

00:05:02.920 --> 00:05:06.280
able to exclude from
their production version.

00:05:06.280 --> 00:05:08.960
They also developed a way
to have their app work

00:05:08.960 --> 00:05:12.460
on lowering devices by
making automatic adjustments

00:05:12.460 --> 00:05:15.610
the certain features, such
as changing and optimizing

00:05:15.610 --> 00:05:18.560
the graphics so that a
user on a particular device

00:05:18.560 --> 00:05:21.080
would still have
a good experience.

00:05:21.080 --> 00:05:23.100
So with all of these
learnings, Joy Tunes

00:05:23.100 --> 00:05:25.860
was able to then launch
to a public audience

00:05:25.860 --> 00:05:29.560
with a very high user
rating of over 4.3

00:05:29.560 --> 00:05:32.910
and to also launch to a
larger number of devices

00:05:32.910 --> 00:05:35.780
than they had originally
thought possible.

00:05:35.780 --> 00:05:39.610
So second, you want
to think global

00:05:39.610 --> 00:05:41.290
when you think about
launching your app

00:05:41.290 --> 00:05:43.070
or growing your user base.

00:05:43.070 --> 00:05:45.260
And Android has
tremendous strength here.

00:05:45.260 --> 00:05:48.840
And we continue to see enormous
growth of music creativity apps

00:05:48.840 --> 00:05:51.610
in both developed and
emerging countries.

00:05:51.610 --> 00:05:53.460
When expanding to
developing regions,

00:05:53.460 --> 00:05:56.940
though, you want to optimize
your app for its specific needs

00:05:56.940 --> 00:05:58.776
for users that are
in that market.

00:05:58.776 --> 00:06:00.400
For instance, you
may find that there's

00:06:00.400 --> 00:06:03.400
a higher number of users
that are on low-end devices.

00:06:03.400 --> 00:06:06.230
And you may find that more
users have lower bandwidth

00:06:06.230 --> 00:06:07.390
constraints.

00:06:07.390 --> 00:06:09.180
But as mentioned
with Simply Piano,

00:06:09.180 --> 00:06:12.080
you don't have to limit your
app to particular devices.

00:06:12.080 --> 00:06:13.580
There's a number
of technical things

00:06:13.580 --> 00:06:15.460
that you can do to
optimize your app

00:06:15.460 --> 00:06:17.960
for both high and
low-end devices.

00:06:17.960 --> 00:06:21.300
So let's take a look now at
another leading audio developer

00:06:21.300 --> 00:06:23.510
that has been
distributed globally

00:06:23.510 --> 00:06:27.960
but has seen enormous
success in emerging markets.

00:06:27.960 --> 00:06:31.340
So Smule is a leading
developer of mobile music apps,

00:06:31.340 --> 00:06:33.810
including Smule Sing
that allows users

00:06:33.810 --> 00:06:35.660
to sing along to
their favorite songs

00:06:35.660 --> 00:06:37.650
in a karaoke-style fashion.

00:06:37.650 --> 00:06:40.200
So for instance, if I wanted
to sing, or if any of you

00:06:40.200 --> 00:06:42.750
wanted to sing, Disney
"Frozen's" "Let It Go,"

00:06:42.750 --> 00:06:45.470
the app would match up what
I'm singing in real time

00:06:45.470 --> 00:06:46.450
with the song.

00:06:46.450 --> 00:06:48.770
And then I'd be able to
overlay audio graphics

00:06:48.770 --> 00:06:51.990
to make my humble voice
sound like a pop star.

00:06:51.990 --> 00:06:54.350
If Disney sing-alongs aren't
popular in your household,

00:06:54.350 --> 00:06:57.330
they have a ton of
other genres, too.

00:06:57.330 --> 00:06:59.730
So Smule has seen
phenomenal growth.

00:06:59.730 --> 00:07:03.880
But last year, the app
saw over 10x active user

00:07:03.880 --> 00:07:08.300
install growth in the Southeast
Asia region with over 40%

00:07:08.300 --> 00:07:11.700
of their user base now comes
from this region with Indonesia

00:07:11.700 --> 00:07:14.460
being one of their
fastest-growing countries.

00:07:14.460 --> 00:07:17.080
But not only have they seen
enormous active user install

00:07:17.080 --> 00:07:20.430
growth, they've also been
monetizing while there--

00:07:20.430 --> 00:07:24.370
so with over 7x increase in
revenue over this same year

00:07:24.370 --> 00:07:26.450
in the southeast Asian region.

00:07:26.450 --> 00:07:28.710
So in addition to some of
the technical optimizations

00:07:28.710 --> 00:07:31.820
that they've done, another
reason for this viral uptick

00:07:31.820 --> 00:07:33.720
can be attributed
to Smule offering

00:07:33.720 --> 00:07:35.520
locally relevant content.

00:07:35.520 --> 00:07:38.710
For instance, a user in
Indonesia, pictured here

00:07:38.710 --> 00:07:41.140
on the left with the
headphones, can sing along

00:07:41.140 --> 00:07:43.850
to one of the world's
top hits, or she

00:07:43.850 --> 00:07:46.590
can choose to sing in
a duet-style karaoke

00:07:46.590 --> 00:07:48.770
with one of her favorite
regional artists,

00:07:48.770 --> 00:07:50.580
such as [? Seeta ?]
pictured on the right,

00:07:50.580 --> 00:07:53.620
who's a very popular
Indonesian singer.

00:07:53.620 --> 00:07:56.080
So as you think about
expanding your reach,

00:07:56.080 --> 00:07:58.520
you want to identify
areas of growth

00:07:58.520 --> 00:08:01.520
and then create a localized
experience for that market.

00:08:01.520 --> 00:08:03.340
I also encourage
you to check out

00:08:03.340 --> 00:08:04.990
our Building for
Billions guidelines

00:08:04.990 --> 00:08:07.350
online if you're interested
in more tips on building

00:08:07.350 --> 00:08:10.030
for emerging markets.

00:08:10.030 --> 00:08:11.820
Lastly, you want
sure that you're

00:08:11.820 --> 00:08:14.810
testing your monetization
strategy to achieve the best

00:08:14.810 --> 00:08:16.210
business results.

00:08:16.210 --> 00:08:18.420
So many music creation
apps have historically

00:08:18.420 --> 00:08:21.200
required that users pay
a premium price in order

00:08:21.200 --> 00:08:22.850
to access their app.

00:08:22.850 --> 00:08:25.380
But because of the
variety of payments

00:08:25.380 --> 00:08:28.170
that are available on mobile,
user consumption habits

00:08:28.170 --> 00:08:29.140
have changed.

00:08:29.140 --> 00:08:32.260
And in fact, on Play, our
fastest growing business model

00:08:32.260 --> 00:08:34.020
comes from subscriptions
where we've

00:08:34.020 --> 00:08:36.630
seen both subscribers
and revenue double over

00:08:36.630 --> 00:08:38.590
the last year.

00:08:38.590 --> 00:08:40.460
So while the last two
apps that I mentioned,

00:08:40.460 --> 00:08:43.120
Simply Piano and
Smule, allow users

00:08:43.120 --> 00:08:46.540
to download the app for free
and test it out and then sign up

00:08:46.540 --> 00:08:49.330
for a subscription,
the developers

00:08:49.330 --> 00:08:51.360
of Ultimate Guitar
Tabs have tested

00:08:51.360 --> 00:08:53.370
an interesting hybrid model.

00:08:53.370 --> 00:08:55.320
So Ultimate Guitar
Tabs allows you

00:08:55.320 --> 00:08:58.120
to learn how to play guitar
through in-app lessons.

00:08:58.120 --> 00:09:01.110
Or you can just jam
to your favorite song.

00:09:01.110 --> 00:09:04.140
So Ultimate Guitar started
off as a premium app.

00:09:04.140 --> 00:09:06.700
But rather than charging
a high price point,

00:09:06.700 --> 00:09:10.890
they experimented with a lower
price point for a paid app,

00:09:10.890 --> 00:09:13.640
allowing users to download
the app for $2.99,

00:09:13.640 --> 00:09:15.050
as you can see on the left.

00:09:15.050 --> 00:09:17.980
This essentially lowered
the barrier to entry.

00:09:17.980 --> 00:09:20.880
Then they up-sold their users
once they were in the app,

00:09:20.880 --> 00:09:23.850
allowing them to download
the full version for $9.99,

00:09:23.850 --> 00:09:25.450
as you can see on the right.

00:09:25.450 --> 00:09:29.720
So this hybrid approach of
using paid and in-app purchases

00:09:29.720 --> 00:09:31.740
turned out to be an
effective monetization

00:09:31.740 --> 00:09:33.780
model for Ultimate Guitar Tabs.

00:09:33.780 --> 00:09:36.090
They not only increased
their revenue overall,

00:09:36.090 --> 00:09:40.570
but in-app purchases now account
for 65% of their revenue, which

00:09:40.570 --> 00:09:44.310
is a pretty striking stat, given
they're already a premium app.

00:09:44.310 --> 00:09:46.910
So while a hybrid
approach worked for them,

00:09:46.910 --> 00:09:49.340
I encourage you to test out
different monetization models

00:09:49.340 --> 00:09:52.650
beyond premium and see where
you have the best conversion

00:09:52.650 --> 00:09:54.740
results.

00:09:54.740 --> 00:09:57.700
So these are just a few
examples of audio developers

00:09:57.700 --> 00:10:01.170
that are seeing tremendous
success on Android.

00:10:01.170 --> 00:10:04.700
There is a tremendous appetite
for music creativity apps.

00:10:04.700 --> 00:10:07.420
And so we think if you follow
the business tips that I just

00:10:07.420 --> 00:10:09.240
gave, and also some
of the technical tips

00:10:09.240 --> 00:10:11.460
that Don and Phil
will be sharing,

00:10:11.460 --> 00:10:14.860
that there's a big opportunity
for developers in this space.

00:10:14.860 --> 00:10:17.220
I would now like to
introduce Don to the stage

00:10:17.220 --> 00:10:19.260
to discuss common
technical hurdles

00:10:19.260 --> 00:10:21.310
and how developers
can overcome them.

00:10:21.310 --> 00:10:22.170
Thank you.

00:10:22.170 --> 00:10:22.270
DON TURNER: Hello.

00:10:22.270 --> 00:10:22.770
Hello.

00:10:22.770 --> 00:10:24.230
[APPLAUSE]

00:10:26.480 --> 00:10:28.250
Thank you, Kelly.

00:10:28.250 --> 00:10:29.040
Hi, I'm Don.

00:10:29.040 --> 00:10:30.310
I'm a developer advocate.

00:10:30.310 --> 00:10:33.400
And I lead our developer
efforts for the Android

00:10:33.400 --> 00:10:35.400
high-performance
audio framework.

00:10:35.400 --> 00:10:38.510
What that means is I
help you guys create

00:10:38.510 --> 00:10:42.510
amazing audio
experiences on Android.

00:10:42.510 --> 00:10:45.630
What it actually means is I
spend virtually all my time

00:10:45.630 --> 00:10:48.300
listening to sine waves.

00:10:48.300 --> 00:10:50.420
Outside of Google, I
do a bit of DJ-ing.

00:10:50.420 --> 00:10:55.440
And in my head, I like to
DJ in places like this.

00:10:55.440 --> 00:11:00.880
But the reality is actually
probably closer to this.

00:11:00.880 --> 00:11:04.580
More people definitely
turned up later, I promise.

00:11:04.580 --> 00:11:05.080
OK.

00:11:05.080 --> 00:11:07.710
So today, I'm going to give
you two best practices,

00:11:07.710 --> 00:11:09.660
which you can use in
your apps to create

00:11:09.660 --> 00:11:11.610
amazing audio experiences.

00:11:11.610 --> 00:11:15.270
These are obtain low
latency audio paths

00:11:15.270 --> 00:11:17.440
and meet your audio
deadlines so you

00:11:17.440 --> 00:11:19.989
don't give your users
headaches by putting

00:11:19.989 --> 00:11:21.280
audio glitches into their ears.

00:11:23.810 --> 00:11:26.604
So starting with obtain
low latency paths--

00:11:26.604 --> 00:11:28.270
I'm going to talk
about two signal paths

00:11:28.270 --> 00:11:31.300
through the Android system--

00:11:31.300 --> 00:11:35.990
number one, recording,
and number two, playback.

00:11:35.990 --> 00:11:37.860
Now one of the first
questions that I often

00:11:37.860 --> 00:11:42.640
get from developers is, what
is the latency of this path?

00:11:42.640 --> 00:11:46.760
And this is the thinking behind
the audio dot pro hardware

00:11:46.760 --> 00:11:48.570
feature flag.

00:11:48.570 --> 00:11:50.610
And if a device reports
support for this flag,

00:11:50.610 --> 00:11:54.760
it means that this particular
path is less than 20

00:11:54.760 --> 00:11:57.700
milliseconds over the headset.

00:11:57.700 --> 00:12:01.460
You can use this flag in your
app to enable certain features,

00:12:01.460 --> 00:12:04.320
such as live monitoring,
or you can only

00:12:04.320 --> 00:12:06.210
distribute to these devices--

00:12:06.210 --> 00:12:07.940
these pro audio devices.

00:12:07.940 --> 00:12:10.460
And there's now tens
of devices in market

00:12:10.460 --> 00:12:12.710
which is supporting this
particular standard.

00:12:12.710 --> 00:12:15.410
So it's not just Pixel
and Nexus devices.

00:12:15.410 --> 00:12:19.470
We're seeing good uptake
from OEMs as well.

00:12:19.470 --> 00:12:24.310
So audio recording--
this is the path

00:12:24.310 --> 00:12:26.340
through the Android
audio framework

00:12:26.340 --> 00:12:27.670
when you're recording.

00:12:27.670 --> 00:12:30.140
You have an analog
signal into a microphone,

00:12:30.140 --> 00:12:33.060
goes through an analog
to digital converter,

00:12:33.060 --> 00:12:35.690
through some effects to kind
of clean up the signal--

00:12:35.690 --> 00:12:38.210
this can be things
like noise cancellation

00:12:38.210 --> 00:12:39.970
and echo cancellation.

00:12:39.970 --> 00:12:43.810
And then the digital data
is delivered to your app.

00:12:43.810 --> 00:12:47.920
Now effects can add latency.

00:12:47.920 --> 00:12:50.490
So if we're talking about low
latency apps, what we want

00:12:50.490 --> 00:12:51.990
is the lowest possible latency.

00:12:51.990 --> 00:12:56.350
And there is a route through
the system which allows us

00:12:56.350 --> 00:12:58.640
to avoid adding this latency.

00:12:58.640 --> 00:13:02.194
And this is obtained using
the Voice Recognition preset.

00:13:02.194 --> 00:13:03.860
The other thing we
need to remember here

00:13:03.860 --> 00:13:06.990
is to use PCM 16 format.

00:13:06.990 --> 00:13:10.740
And this essentially
allows the audio framework

00:13:10.740 --> 00:13:12.850
to not do any format
shifting which

00:13:12.850 --> 00:13:16.020
potentially could add latency.

00:13:16.020 --> 00:13:19.540
So that's all I'm going to
say about audio recording.

00:13:19.540 --> 00:13:22.740
Audio playback is a
little more complicated.

00:13:22.740 --> 00:13:26.120
So every phone that
produces audio in the world

00:13:26.120 --> 00:13:28.854
has a digital to
analog converter in it.

00:13:28.854 --> 00:13:30.520
This takes ones and
naughts and converts

00:13:30.520 --> 00:13:36.020
into a voltage which is used to
drive headphones or a speaker.

00:13:36.020 --> 00:13:40.690
Now I like to think of this
as kind of a character which

00:13:40.690 --> 00:13:44.680
is chomping down on this audio
data and producing the signal.

00:13:44.680 --> 00:13:47.730
In fact, I even have
a name for him--

00:13:47.730 --> 00:13:50.090
Dac Man.

00:13:50.090 --> 00:13:59.180
Now Dac Man has very specific
requirements for his food.

00:13:59.180 --> 00:14:02.560
He wants it served to
him at a certain rate,

00:14:02.560 --> 00:14:05.380
and he also wants it served
to him in bite-sized chunks

00:14:05.380 --> 00:14:07.390
of a very specific size.

00:14:07.390 --> 00:14:09.830
Now for this analogy
to work, Dac Man

00:14:09.830 --> 00:14:12.780
also includes DMA controller
and all the other hardware

00:14:12.780 --> 00:14:14.260
required to consume audio.

00:14:14.260 --> 00:14:15.750
So just bear with it.

00:14:15.750 --> 00:14:22.300
So this is how Dac Man fits into
the Android audio architecture.

00:14:22.300 --> 00:14:24.490
So your app is at the top here.

00:14:24.490 --> 00:14:28.620
And it's your job to get your
audio data to the output as

00:14:28.620 --> 00:14:30.300
quickly as possible.

00:14:30.300 --> 00:14:33.600
The default path through the
system is to go through every

00:14:33.600 --> 00:14:36.780
sampler, through
some effects-- again,

00:14:36.780 --> 00:14:39.720
to improve the acoustic
quality of the signal--

00:14:39.720 --> 00:14:42.780
and then through a mixer,
and out to Dac Man.

00:14:42.780 --> 00:14:46.360
Now as with the recording
path, the resampler and effects

00:14:46.360 --> 00:14:48.090
will add latency.

00:14:48.090 --> 00:14:50.450
And we can obtain a
lower latency path

00:14:50.450 --> 00:14:55.730
called the fast mixer
path if our app conforms

00:14:55.730 --> 00:14:57.540
to certain requirements.

00:14:57.540 --> 00:15:05.160
So number one, we need to
obtain the correct sample rate.

00:15:05.160 --> 00:15:08.550
So remember I said Dac Man wants
his food at a specific rate?

00:15:08.550 --> 00:15:11.130
We can use the Audio
Manager API to find out

00:15:11.130 --> 00:15:13.530
exactly what that rate is.

00:15:13.530 --> 00:15:17.290
And that will enable us
to create an audio stream

00:15:17.290 --> 00:15:18.512
on this fast path.

00:15:18.512 --> 00:15:19.970
The other thing we
need to remember

00:15:19.970 --> 00:15:21.235
is not to add any effects.

00:15:23.760 --> 00:15:27.720
So once we've created this
audio stream to Dac Man,

00:15:27.720 --> 00:15:29.550
we need to start
supplying audio data.

00:15:29.550 --> 00:15:32.630
And we need to do it in
this specific chunk size.

00:15:32.630 --> 00:15:35.220
And again, we can use
the Audio Manager API

00:15:35.220 --> 00:15:37.850
to obtain this optimal size.

00:15:37.850 --> 00:15:41.480
So after this first
chunk of audio data

00:15:41.480 --> 00:15:46.200
is consumed by Dac Man,
he sends us a callback.

00:15:46.200 --> 00:15:50.650
He is basically saying, I've
run out of food, feed me more.

00:15:50.650 --> 00:15:53.230
And we get this callback
on a high-priority thread.

00:15:53.230 --> 00:15:55.980
And this allows you to
do your audio processing

00:15:55.980 --> 00:16:00.370
work without being preempted
by other parts of the system.

00:16:00.370 --> 00:16:03.860
Now this is a fairly critical
part of any audio app.

00:16:03.860 --> 00:16:05.830
So let's take a
closer look at what

00:16:05.830 --> 00:16:08.350
happens inside this callback.

00:16:08.350 --> 00:16:10.160
So every callback
has a deadline.

00:16:10.160 --> 00:16:13.080
Remember that you have to send
these chunks of audio data

00:16:13.080 --> 00:16:15.510
at very specific intervals.

00:16:15.510 --> 00:16:18.440
So the amount of time you
spend in this callback

00:16:18.440 --> 00:16:21.380
is going to vary based
on the computations

00:16:21.380 --> 00:16:25.020
that you're performing, like the
complexity of the audio data,

00:16:25.020 --> 00:16:30.900
but also CPU frequency and
device that you're running on.

00:16:30.900 --> 00:16:34.230
If you miss this
deadline, Dac Man

00:16:34.230 --> 00:16:35.880
is going to be very unhappy.

00:16:35.880 --> 00:16:40.530
And he's going to output
silence in protest.

00:16:40.530 --> 00:16:44.620
So it's very important that
we don't miss these deadlines.

00:16:44.620 --> 00:16:48.500
So for the next part, I wanted
to talk about some common

00:16:48.500 --> 00:16:52.900
reasons why you might miss
these audio deadlines,

00:16:52.900 --> 00:16:54.190
starting with blocking.

00:16:54.190 --> 00:16:57.060
So inside your callback,
there are various reasons

00:16:57.060 --> 00:16:58.280
you might block.

00:16:58.280 --> 00:17:00.830
And here I have a
code sample which

00:17:00.830 --> 00:17:03.150
does a whole lot of
bad things-- things

00:17:03.150 --> 00:17:04.890
you shouldn't do
in your callback.

00:17:04.890 --> 00:17:08.455
So number one, logging--

00:17:08.455 --> 00:17:10.079
instead of logging
inside the callback,

00:17:10.079 --> 00:17:12.329
you should use A-trace
and use Systrace.

00:17:12.329 --> 00:17:16.020
It's a much better tool
for debugging the callback.

00:17:16.020 --> 00:17:18.550
Don't do memory allocation.

00:17:18.550 --> 00:17:21.240
If you need to use memory inside
the callback, which invariably

00:17:21.240 --> 00:17:23.550
you do, you should
allocate the memory

00:17:23.550 --> 00:17:26.470
up-front when you
instantiate your audio stream

00:17:26.470 --> 00:17:27.940
and then just use
it inside here,

00:17:27.940 --> 00:17:31.570
rather than trying to
allocate new memory.

00:17:31.570 --> 00:17:32.920
Don't wait on other threads.

00:17:32.920 --> 00:17:35.300
Bear in mind, this is a
high-priority callback.

00:17:35.300 --> 00:17:37.350
So if you're waiting on
a lower priority thread,

00:17:37.350 --> 00:17:40.220
you have priority inversion.

00:17:40.220 --> 00:17:43.170
Don't do file I/O. If you
need to read from a file,

00:17:43.170 --> 00:17:46.520
use another thread and
then use non-blocking queue

00:17:46.520 --> 00:17:50.360
or a circular buffer to
transfer data into the callback.

00:17:50.360 --> 00:17:51.810
And don't sleep.

00:17:51.810 --> 00:17:54.230
There should never be any
need to sleep inside here.

00:17:58.490 --> 00:18:00.659
So we've dealt with blocking.

00:18:00.659 --> 00:18:02.700
The next reason why you
might miss your deadlines

00:18:02.700 --> 00:18:04.690
is core migrations.

00:18:04.690 --> 00:18:07.470
Now when you create an
audio app on Android,

00:18:07.470 --> 00:18:10.890
the CPU scheduler will
assign your audio thread

00:18:10.890 --> 00:18:12.230
to a particular core.

00:18:12.230 --> 00:18:15.070
And here, I have
a Systrace, which

00:18:15.070 --> 00:18:18.390
is showing the audio
thread running on CPU1.

00:18:18.390 --> 00:18:20.960
And we have four
callbacks marked--

00:18:20.960 --> 00:18:23.470
those green rectangles
there are the callbacks.

00:18:23.470 --> 00:18:25.810
The other row of interest
is F ready 1 here,

00:18:25.810 --> 00:18:30.050
which shows us the state
of our audio buffer.

00:18:30.050 --> 00:18:33.280
And we have four callbacks.

00:18:33.280 --> 00:18:37.790
And then the CPU scheduler
shifts our thread over to CPU0.

00:18:37.790 --> 00:18:42.110
Now this core migration can
incur a slight time penalty,

00:18:42.110 --> 00:18:43.990
in the order of a
few milliseconds.

00:18:43.990 --> 00:18:46.980
And this can cause our callback
to start late and, therefore,

00:18:46.980 --> 00:18:47.990
run over.

00:18:47.990 --> 00:18:51.850
And sure enough, we have an
audio glitch occurring there.

00:18:51.850 --> 00:18:57.420
So the solution to this is
to set thread affinity, which

00:18:57.420 --> 00:18:59.640
means that we combined
our audio thread

00:18:59.640 --> 00:19:02.980
either to the current
core which we're assigned.

00:19:02.980 --> 00:19:05.180
That's an OK say of doing it.

00:19:05.180 --> 00:19:10.010
Or we can use Get Exclusive
Cores on API 24 or above,

00:19:10.010 --> 00:19:12.670
in order to get
the cores which are

00:19:12.670 --> 00:19:17.780
reserved for the current
foreground application.

00:19:17.780 --> 00:19:19.830
Lastly, CPU frequency scaling--

00:19:19.830 --> 00:19:22.460
so this is a process
which is used

00:19:22.460 --> 00:19:25.940
to give users great
performance and great battery.

00:19:25.940 --> 00:19:28.170
It's like a power,
performance trade-off.

00:19:28.170 --> 00:19:31.817
CPU frequency is high when users
need good performance and low

00:19:31.817 --> 00:19:33.400
when they don't need
good performance,

00:19:33.400 --> 00:19:35.470
but they do want
to conserve power.

00:19:35.470 --> 00:19:38.070
So this is great for
most applications.

00:19:38.070 --> 00:19:40.020
But for real-time
audio applications,

00:19:40.020 --> 00:19:41.100
it can cause a problem.

00:19:41.100 --> 00:19:44.690
So imagine you have
a synthesizer app.

00:19:44.690 --> 00:19:48.060
And every time you press
a key, the synthesizer app

00:19:48.060 --> 00:19:50.500
generates a voice.

00:19:50.500 --> 00:19:53.120
This is how the
computational graph might

00:19:53.120 --> 00:19:55.030
look for an app like this.

00:19:55.030 --> 00:19:56.000
So we start off.

00:19:56.000 --> 00:19:58.810
We have 10 fingers
down on our keyboard.

00:19:58.810 --> 00:20:03.860
And our app bandwidth
required is fairly high.

00:20:03.860 --> 00:20:06.410
Now we take our fingers
off the keyboard.

00:20:06.410 --> 00:20:08.560
Our bandwidth
required drops down.

00:20:08.560 --> 00:20:11.205
And the CPU governor sees
that actually our app

00:20:11.205 --> 00:20:13.640
doesn't need as much
bandwidth, so it drops down

00:20:13.640 --> 00:20:15.220
the CPU frequency.

00:20:15.220 --> 00:20:17.000
Everything's fine so far.

00:20:17.000 --> 00:20:19.980
Now we put our fingers
back on the keyboard.

00:20:19.980 --> 00:20:22.940
So our bandwidth rises
to its previous level.

00:20:22.940 --> 00:20:26.320
But the governor takes a while
to ramp the CPU frequency back

00:20:26.320 --> 00:20:28.340
up to the level that we need.

00:20:28.340 --> 00:20:33.630
So unfortunately, during this
time, glitches are occurring.

00:20:33.630 --> 00:20:35.950
So the solution to this--

00:20:35.950 --> 00:20:38.420
well, the title of
this talk is "Best

00:20:38.420 --> 00:20:39.640
Practices for Android Audio."

00:20:39.640 --> 00:20:41.690
But for this
section alone, let's

00:20:41.690 --> 00:20:45.210
just call this "Don's
Practices for Android Audio."

00:20:45.210 --> 00:20:47.690
And this is from working
with top partners like ROLI.

00:20:47.690 --> 00:20:50.670
This is what actually
works in the real world.

00:20:50.670 --> 00:20:53.320
So what you can do is
you can use something

00:20:53.320 --> 00:20:55.390
called stabilizing load.

00:20:55.390 --> 00:20:59.310
Now the idea here
is that instead

00:20:59.310 --> 00:21:02.710
of having a varying amount of
time spent in your callback,

00:21:02.710 --> 00:21:04.760
you have a fixed amount of time.

00:21:04.760 --> 00:21:08.040
And the stabilizing load can
be things like gating voices

00:21:08.040 --> 00:21:11.350
on and off, or you can
use assembler no operation

00:21:11.350 --> 00:21:16.040
instructions, basically
to keep the CPU spinning.

00:21:16.040 --> 00:21:19.630
So the result of that
is that you basically

00:21:19.630 --> 00:21:23.810
have fixed load,
fixed CPU frequency,

00:21:23.810 --> 00:21:26.550
and you always have the
bandwidth you require in order

00:21:26.550 --> 00:21:28.630
to generate audio data.

00:21:28.630 --> 00:21:32.900
This is best used with sustained
performance mode on API 24,

00:21:32.900 --> 00:21:37.450
as this will avoid you running
into thermal throttling issues.

00:21:37.450 --> 00:21:41.000
So in summary, obtain
low latency audio

00:21:41.000 --> 00:21:43.120
and always meet your
audio deadlines.

00:21:43.120 --> 00:21:45.340
I'd now like to
hand over to Phil

00:21:45.340 --> 00:21:47.700
who's going to talk about
a fantastic new audio

00:21:47.700 --> 00:21:49.910
API in Android.

00:21:49.910 --> 00:21:50.510
Welcome, Phil.

00:21:50.510 --> 00:21:51.200
[APPLAUSE]

00:21:51.200 --> 00:21:52.074
PHIL BURK: Thank you.

00:21:56.430 --> 00:21:57.140
Hello.

00:21:57.140 --> 00:21:58.580
My name is Phil Burk.

00:21:58.580 --> 00:22:01.080
And I work in the
Android audio group,

00:22:01.080 --> 00:22:04.480
mostly on MIDI and pro
audio applications.

00:22:04.480 --> 00:22:06.680
My background is in
experimental music.

00:22:06.680 --> 00:22:10.920
So my personal goal is to make
the Android platform really

00:22:10.920 --> 00:22:13.140
a great platform for
making strange kinds

00:22:13.140 --> 00:22:14.820
of new musical instruments.

00:22:14.820 --> 00:22:16.320
So that's sort of
what motivates me.

00:22:19.470 --> 00:22:21.890
What I'll be talking
about is a new audio

00:22:21.890 --> 00:22:25.240
API called AAudio, which
we're very excited about.

00:22:25.240 --> 00:22:28.669
And then I'll show you how to
do callbacks using that API.

00:22:28.669 --> 00:22:30.460
And then I'll also show
you how to optimize

00:22:30.460 --> 00:22:33.975
your latency on any
particular device you

00:22:33.975 --> 00:22:34.850
happen to be running.

00:22:38.160 --> 00:22:40.100
So the AAudio is a C API.

00:22:40.100 --> 00:22:42.035
So this is a native API.

00:22:45.060 --> 00:22:47.330
You may be wondering,
why a new API?

00:22:47.330 --> 00:22:49.860
We already have
OpenSL ES and Java.

00:22:49.860 --> 00:22:54.010
And the reason is that AAudio
is, we think, easier to use.

00:22:54.010 --> 00:22:56.510
And if you've use OpenSL
ES and compare them,

00:22:56.510 --> 00:22:57.920
I think you'll see why.

00:22:57.920 --> 00:23:02.110
Also, it's a platform where
we can make improvements.

00:23:02.110 --> 00:23:06.890
And this will show
you how we do that.

00:23:06.890 --> 00:23:10.660
These three APIs can all go
through the existing Audio

00:23:10.660 --> 00:23:12.560
Flinger framework.

00:23:12.560 --> 00:23:14.990
But if we make radical
changes in the Audio Flinger

00:23:14.990 --> 00:23:17.050
we potentially could
break thousands of apps

00:23:17.050 --> 00:23:18.640
that are already existing.

00:23:18.640 --> 00:23:22.020
So what we do is we add
a new AAudio service

00:23:22.020 --> 00:23:24.464
where we can do some
pretty radical things

00:23:24.464 --> 00:23:26.630
and not have to worry about
breaking existing stuff.

00:23:26.630 --> 00:23:29.710
So we can do some big
performance enhancements

00:23:29.710 --> 00:23:32.080
in the AAudio service.

00:23:32.080 --> 00:23:34.240
So AAudio uses the
concept of streams

00:23:34.240 --> 00:23:36.830
of audio flowing from
the mic, to the app,

00:23:36.830 --> 00:23:38.680
back down to the headphones.

00:23:38.680 --> 00:23:43.610
So how do you create
a stream using AAudio?

00:23:43.610 --> 00:23:45.930
We use a builder design pattern.

00:23:45.930 --> 00:23:49.690
So in the Builder, you can set
your parameters that you want.

00:23:49.690 --> 00:23:52.010
You could leave everything
just the default.

00:23:52.010 --> 00:23:54.390
And you'll probably get
a stereo output stream.

00:23:54.390 --> 00:23:56.060
But if you need
a specific sample

00:23:56.060 --> 00:23:59.380
rate or a specific
format, you can set that.

00:23:59.380 --> 00:24:02.010
Once the Builder's set up, you
can use it like a rubber stamp

00:24:02.010 --> 00:24:04.830
to create multiple streams.

00:24:04.830 --> 00:24:06.710
So this is what it
looks like in the code.

00:24:06.710 --> 00:24:09.580
So we have AAudio,
create stream builder--

00:24:09.580 --> 00:24:11.350
pretty straightforward.

00:24:11.350 --> 00:24:14.430
And if you want, here's how
you set different parameters

00:24:14.430 --> 00:24:17.350
on the stream builder.

00:24:17.350 --> 00:24:20.360
Once you've set up the stream,
you call Audio Stream Builder

00:24:20.360 --> 00:24:21.520
Open Stream--

00:24:21.520 --> 00:24:23.370
again, pretty straightforward.

00:24:23.370 --> 00:24:25.850
And then if you
didn't specify things

00:24:25.850 --> 00:24:27.950
like the sample
rate or the format,

00:24:27.950 --> 00:24:30.200
then you'll need to query
it to find out what you got.

00:24:30.200 --> 00:24:32.210
Don't just assume that
it's 48,000 hertz,

00:24:32.210 --> 00:24:35.160
because some devices,
particularly like USB devices,

00:24:35.160 --> 00:24:37.700
it might be at 96,000
hertz or something.

00:24:37.700 --> 00:24:40.980
So it's important to query to
find out what you really got

00:24:40.980 --> 00:24:42.740
after you opened the stream.

00:24:42.740 --> 00:24:45.540
Another important value
is this frames per burst.

00:24:45.540 --> 00:24:47.410
And this correlates
with the chunk sizes

00:24:47.410 --> 00:24:51.170
that Dac Man was
consuming in Don's slides.

00:24:51.170 --> 00:24:54.330
So what is a burst
versus what is a buffer?

00:24:54.330 --> 00:24:55.830
This can be very confusing.

00:24:55.830 --> 00:24:58.670
So when we say
"buffer" in AAudio,

00:24:58.670 --> 00:25:00.800
we're talking about
the whole array

00:25:00.800 --> 00:25:03.770
where the audio data is stored
for a particular stream.

00:25:03.770 --> 00:25:07.250
And in that buffer, there
can be multiple bursts.

00:25:07.250 --> 00:25:11.350
So in this case, Dac Man has
two bursts that it can consume.

00:25:11.350 --> 00:25:14.670
And we're riding in
the size of a burst.

00:25:17.336 --> 00:25:18.585
You have to start your stream.

00:25:18.585 --> 00:25:20.210
You can pause it.

00:25:20.210 --> 00:25:21.800
You can flush the
stream, stop it.

00:25:21.800 --> 00:25:23.159
These are asynchronous calls.

00:25:23.159 --> 00:25:25.200
And normally, you don't
have to worry about that.

00:25:25.200 --> 00:25:26.740
But if you have
to synchronize, we

00:25:26.740 --> 00:25:28.300
do have a function
that will allow

00:25:28.300 --> 00:25:33.260
you to synchronize with the
state machine inside AAudio.

00:25:33.260 --> 00:25:36.862
The reading and writing-- so
we have to get data in and out

00:25:36.862 --> 00:25:37.570
of these streams.

00:25:37.570 --> 00:25:38.720
So there's two ways.

00:25:38.720 --> 00:25:43.240
If your application doesn't
need super low latency,

00:25:43.240 --> 00:25:44.920
the easiest thing
is just to read

00:25:44.920 --> 00:25:47.380
or write using blocking writes.

00:25:47.380 --> 00:25:49.540
And so here we're in a loop.

00:25:49.540 --> 00:25:50.900
And we're doing a write.

00:25:50.900 --> 00:25:56.534
And you notice we have a timeout
there as a last parameter.

00:25:56.534 --> 00:25:57.950
When we do a
blocking write, we'll

00:25:57.950 --> 00:26:01.270
get back either an error code
or the number of frames written.

00:26:01.270 --> 00:26:05.510
And if it times out, or if
we use a time-out of zero,

00:26:05.510 --> 00:26:07.670
we may get a partial transfer.

00:26:14.500 --> 00:26:15.000
OK.

00:26:15.000 --> 00:26:18.250
The second technique is when
you need the lowest latency.

00:26:18.250 --> 00:26:21.230
And to do that, you'd need a
high-priority thread that's

00:26:21.230 --> 00:26:24.570
maybe running with a
[INAUDIBLE] scheduler

00:26:24.570 --> 00:26:27.030
and hopefully the
higher priority as well.

00:26:27.030 --> 00:26:31.150
So the way to do that is
to write your own callback

00:26:31.150 --> 00:26:31.660
function.

00:26:31.660 --> 00:26:34.920
So this is function
that you would write.

00:26:34.920 --> 00:26:40.920
And AAudio will pass to you a
stream parameter, a user data,

00:26:40.920 --> 00:26:44.850
which could be an object or
a structure pointer, and then

00:26:44.850 --> 00:26:47.420
audio data pointer, which
is a pointer to your array

00:26:47.420 --> 00:26:48.770
and the number of frames.

00:26:48.770 --> 00:26:51.940
And then you can render
directly into that audio buffer

00:26:51.940 --> 00:26:52.660
and then return.

00:26:56.150 --> 00:26:58.910
Once you have your
callback function

00:26:58.910 --> 00:27:00.610
and you know what
data you want to pass,

00:27:00.610 --> 00:27:02.110
you give it to the builder.

00:27:02.110 --> 00:27:05.040
You set the data
callback on the builder.

00:27:05.040 --> 00:27:07.110
And then when you
later create a stream,

00:27:07.110 --> 00:27:10.820
it will use those values.

00:27:10.820 --> 00:27:13.390
Sometimes people need to
combine multiple inputs.

00:27:13.390 --> 00:27:15.220
Maybe you're taking
two input sources

00:27:15.220 --> 00:27:18.810
and mixing them and
sending them to an output.

00:27:18.810 --> 00:27:21.640
So what's the best way
to do that with AAudio.

00:27:21.640 --> 00:27:24.470
We recommend using
one stream as a master

00:27:24.470 --> 00:27:28.080
and doing your callback from
that master stream, which

00:27:28.080 --> 00:27:30.780
ideally should be
an output stream.

00:27:30.780 --> 00:27:33.410
And then what you
do in the callback--

00:27:33.410 --> 00:27:36.300
see, here we're being passed
the output stream pointer.

00:27:36.300 --> 00:27:40.190
So what we do in the callback
is we do a read from the input

00:27:40.190 --> 00:27:40.700
stream.

00:27:40.700 --> 00:27:42.330
And we set the time-out to zero.

00:27:42.330 --> 00:27:44.190
So this is a non-blocking call.

00:27:44.190 --> 00:27:48.090
As Don mentioned, you don't want
to block inside the callback.

00:27:48.090 --> 00:27:50.050
Now initially, you may
not get all the data

00:27:50.050 --> 00:27:51.240
that you're expecting.

00:27:51.240 --> 00:27:53.650
But pretty soon, these two
streams will synchronize--

00:27:53.650 --> 00:27:56.160
like very quickly, within
a couple buffer calls--

00:27:56.160 --> 00:27:57.900
and then you'll have
nice back and forth

00:27:57.900 --> 00:27:59.300
between these two streams.

00:27:59.300 --> 00:28:03.900
And you can do echo or guitar
effects-- things like that.

00:28:07.460 --> 00:28:09.050
The other topic
I want to discuss

00:28:09.050 --> 00:28:11.940
is dynamic latency tuning.

00:28:11.940 --> 00:28:15.530
So it's very difficult
to predict ahead

00:28:15.530 --> 00:28:18.760
of time what the exact number
of buffers that you need.

00:28:18.760 --> 00:28:21.310
And the number buffers
determines your latency.

00:28:21.310 --> 00:28:24.290
If you have too few buffers--

00:28:24.290 --> 00:28:27.220
too few bursts, I
guess, in your buffer--

00:28:27.220 --> 00:28:31.660
then if your thread is
preempted, you make glitch.

00:28:31.660 --> 00:28:33.670
So what you want to do--

00:28:33.670 --> 00:28:36.310
if you look at this
diagram from before--

00:28:36.310 --> 00:28:38.540
right now, we only
have two bursts

00:28:38.540 --> 00:28:40.900
that are valid in this
very large buffer.

00:28:40.900 --> 00:28:43.880
So that's our latency
is two times this burst

00:28:43.880 --> 00:28:45.830
for this buffer.

00:28:45.830 --> 00:28:49.280
So if we are unable to
write to the buffer,

00:28:49.280 --> 00:28:52.470
Dac Man will run out of
data after two bursts.

00:28:52.470 --> 00:28:54.430
So if we have a
glitch, we may wish

00:28:54.430 --> 00:28:57.730
that we have three
bursts in the buffer.

00:28:57.730 --> 00:29:00.160
So we have a little bit more
cushion if we get preempted--

00:29:00.160 --> 00:29:01.730
if our thread gets preempted.

00:29:01.730 --> 00:29:03.950
So we can adjust this value.

00:29:03.950 --> 00:29:06.970
The way you do that
in code is that you

00:29:06.970 --> 00:29:10.430
can query to find out how
many overruns or underruns

00:29:10.430 --> 00:29:13.660
you've had on that
output stream.

00:29:13.660 --> 00:29:16.380
And if it's changed since
the last time you checked,

00:29:16.380 --> 00:29:18.630
that means that you
just had a glitch.

00:29:18.630 --> 00:29:20.690
So what you can then
do is you can query

00:29:20.690 --> 00:29:27.120
to see what the size is of the
buffer, how much of the buffer

00:29:27.120 --> 00:29:29.825
is being used, which
determines your latency,

00:29:29.825 --> 00:29:31.700
and then bump it up and
say, well, let's just

00:29:31.700 --> 00:29:34.286
add one more burst
in here, so instead

00:29:34.286 --> 00:29:36.640
of being double-buffered,
I'll be triple-buffered.

00:29:36.640 --> 00:29:40.350
And then you set that
back in, reset your size.

00:29:40.350 --> 00:29:43.160
So this is sort of
a simplification.

00:29:43.160 --> 00:29:45.997
You may find that you want to--

00:29:45.997 --> 00:29:47.580
you could do timing
analysis and maybe

00:29:47.580 --> 00:29:49.570
lower the latency again
later, if you haven't

00:29:49.570 --> 00:29:50.730
glitched for a long time.

00:29:50.730 --> 00:29:53.020
But that's up to the
application to the those kind

00:29:53.020 --> 00:29:55.700
of smart analysis.

00:29:55.700 --> 00:29:58.730
But this is the basic technique.

00:29:58.730 --> 00:30:04.100
So in summary, a minimal AAudio
program-- you create a builder,

00:30:04.100 --> 00:30:08.760
you open a stream, you start
the stream, and then in a loop--

00:30:08.760 --> 00:30:11.840
in this case, we're doing
the blocking rights,

00:30:11.840 --> 00:30:14.570
synthesizing audio, and
writing it to the stream.

00:30:14.570 --> 00:30:16.870
And then we close
it when we're done.

00:30:16.870 --> 00:30:18.180
So pretty simple.

00:30:18.180 --> 00:30:22.300
Just for comparison, this is
sort of an equivalent OpenSL ES

00:30:22.300 --> 00:30:23.479
program.

00:30:23.479 --> 00:30:25.020
Probably it's a
littler hard to read.

00:30:25.020 --> 00:30:28.850
But as you can see, the
AAudio is fewer lines of code,

00:30:28.850 --> 00:30:34.050
little more straightforward,
if you want to use audio.

00:30:34.050 --> 00:30:37.400
So now AAudio-- you're probably
thinking, that sounds great,

00:30:37.400 --> 00:30:39.350
but it's only in the
O release, so how

00:30:39.350 --> 00:30:41.730
does that help me if I'm
writing for Marshmallow

00:30:41.730 --> 00:30:43.326
or Nougat or Lollipop?

00:30:43.326 --> 00:30:44.950
So what we're doing
is we're developing

00:30:44.950 --> 00:30:50.720
a wrapper which is basically
like the AAudio API and AAudio

00:30:50.720 --> 00:30:52.990
features.

00:30:52.990 --> 00:30:57.120
But it's in C++, so it just
looks slightly different.

00:30:57.120 --> 00:31:02.150
And what we do is we dynamically
link to the AAudio library

00:31:02.150 --> 00:31:03.160
using runtime linking.

00:31:03.160 --> 00:31:06.220
So your program can run and
link on previous versions

00:31:06.220 --> 00:31:07.990
of Android.

00:31:07.990 --> 00:31:09.780
But AAudio won't be there.

00:31:09.780 --> 00:31:12.610
And so what we do is we
just dynamically switch over

00:31:12.610 --> 00:31:14.440
to using OpenSL ES.

00:31:14.440 --> 00:31:17.870
So if you write your
program to this new API,

00:31:17.870 --> 00:31:20.160
which will be like
an open source thing.

00:31:20.160 --> 00:31:24.500
It's not quite out yet,
but will be out soon.

00:31:24.500 --> 00:31:28.870
Then if you write your
program to this C++ wrapper,

00:31:28.870 --> 00:31:31.770
then you'll be able to
use AAudio or OpenSL ES

00:31:31.770 --> 00:31:34.880
transparently and run
on old or new platforms.

00:31:38.180 --> 00:31:38.680
OK.

00:31:38.680 --> 00:31:42.230
I'm excited about
what's coming up next.

00:31:42.230 --> 00:31:44.060
ROLI's going to give us a demo.

00:31:44.060 --> 00:31:46.700
And ROLI is a company
that's been taking advantage

00:31:46.700 --> 00:31:48.390
of a lot of these tricks.

00:31:48.390 --> 00:31:49.984
They've figured
out a lot of stuff,

00:31:49.984 --> 00:31:51.650
and they've been a
great partner for us.

00:31:51.650 --> 00:31:54.690
So I'd like their CEO
of ROLI, Roland Lamb,

00:31:54.690 --> 00:31:58.310
to come up and talk about
some of the programs

00:31:58.310 --> 00:32:00.560
they've been
developing on Android.

00:32:00.560 --> 00:32:01.280
Thank you.

00:32:01.280 --> 00:32:03.730
[APPLAUSE]

00:32:07.069 --> 00:32:08.610
ROLAND LAMB: Good
morning, everybody.

00:32:08.610 --> 00:32:09.970
It's such a pleasure to be here.

00:32:09.970 --> 00:32:12.560
As Phil saying, I'm Roland Lamb.

00:32:12.560 --> 00:32:15.980
I'm the founder and CEO
of ROLI, a company that

00:32:15.980 --> 00:32:19.400
is developing new musical
hardware and software.

00:32:19.400 --> 00:32:23.370
And I'm very pleased to have
Marco and Jack Parisi with me,

00:32:23.370 --> 00:32:27.050
who are virtuoso musicians,
who are kind of on this cutting

00:32:27.050 --> 00:32:30.850
edge of new hardware, new
software, and expression.

00:32:30.850 --> 00:32:36.040
So just to give a little bit
of background, starting out,

00:32:36.040 --> 00:32:40.820
I felt really passionate about
creativity and about the joy

00:32:40.820 --> 00:32:42.810
that comes from creation.

00:32:42.810 --> 00:32:44.630
And in particular,
we thought, we

00:32:44.630 --> 00:32:47.590
want to empower everyone to
be creators, but particularly

00:32:47.590 --> 00:32:48.510
in music.

00:32:48.510 --> 00:32:51.230
And the reason for music
being kind of the center

00:32:51.230 --> 00:32:54.670
point for us is that there's
this huge opportunity

00:32:54.670 --> 00:32:57.100
for expression that is untapped.

00:32:57.100 --> 00:33:00.120
And the way we think about that
is that musical instruments

00:33:00.120 --> 00:33:02.110
are tremendously expressive.

00:33:02.110 --> 00:33:04.580
But they're still quite
difficult to learn.

00:33:04.580 --> 00:33:07.180
And on the other
side, electronic music

00:33:07.180 --> 00:33:10.190
has such versatility
associated with it,

00:33:10.190 --> 00:33:12.830
but then it's relatively
technical still

00:33:12.830 --> 00:33:15.760
and complicated to set
up your own home studio.

00:33:15.760 --> 00:33:18.240
So we thought, what if we
could create instruments

00:33:18.240 --> 00:33:21.840
that were deeply expressive
but also easy to learn,

00:33:21.840 --> 00:33:24.930
had the versatility
of electronic music,

00:33:24.930 --> 00:33:27.820
but then didn't have all of
the extra technical set-up?

00:33:27.820 --> 00:33:30.170
But to solve that problem,
we thought, first of all,

00:33:30.170 --> 00:33:34.910
we need these high-resolution
control devices for digital.

00:33:34.910 --> 00:33:38.830
So if you just have simple,
one-dimensional electronic

00:33:38.830 --> 00:33:42.180
controllers, you can't get
to that depth of expression

00:33:42.180 --> 00:33:44.390
that you have with all of
the physical gestures you

00:33:44.390 --> 00:33:46.320
can create with
acoustic instruments.

00:33:46.320 --> 00:33:49.740
So I invented this instrument
called the Seaboard.

00:33:49.740 --> 00:33:51.350
And the Seaboard
is the evolution

00:33:51.350 --> 00:33:52.820
of the piano keyboard.

00:33:52.820 --> 00:33:55.420
You can play it just the
way that you play a piano.

00:33:55.420 --> 00:33:57.540
But then you can modulate
all of the sounds

00:33:57.540 --> 00:34:00.240
in real time using very
intuitive gestures.

00:34:00.240 --> 00:34:03.932
So as Marco will show, you
could play the Seaboard, first

00:34:03.932 --> 00:34:05.015
of all, just like a piano.

00:34:10.449 --> 00:34:13.050
Maybe if guys can
bring up the audio--

00:34:13.050 --> 00:34:15.860
sounds like maybe
they just did, Marco.

00:34:15.860 --> 00:34:21.941
So we're running the
Seaboard now on Pixel.

00:34:21.941 --> 00:34:23.829
[MUSIC PLAYING]

00:34:27.147 --> 00:34:28.980
So it's kind of like
electronic piano patch.

00:34:28.980 --> 00:34:30.396
He's just playing
it like a piano.

00:34:30.396 --> 00:34:33.060
But if he wants to, he can play
it, for example, like a guitar.

00:34:33.060 --> 00:34:37.480
And he would just be able to
bend these soft, silicon keys

00:34:37.480 --> 00:34:38.739
left to right, as you'll see.

00:34:38.739 --> 00:34:41.134
[MUSIC PLAYING]

00:34:49.320 --> 00:34:51.210
So those kinds of
bends that usually you

00:34:51.210 --> 00:34:53.949
would associate with another
kind of acoustic instrument,

00:34:53.949 --> 00:34:55.330
you can create in this context.

00:34:55.330 --> 00:34:58.990
And there's many, many sonic
possibilities with something

00:34:58.990 --> 00:34:59.900
like the Seaboard.

00:34:59.900 --> 00:35:01.400
So we thought, wow,
this is awesome,

00:35:01.400 --> 00:35:03.980
we have this new
physical technology,

00:35:03.980 --> 00:35:06.620
but we want to make it
as accessible as possible

00:35:06.620 --> 00:35:09.650
to reach many, many more
people around the world.

00:35:09.650 --> 00:35:11.930
So we built a new
product called BLOCKS.

00:35:11.930 --> 00:35:14.640
And BLOCKS takes the
technology of the Seaboard

00:35:14.640 --> 00:35:19.760
and puts it into a format of
a small, pocket-sized music

00:35:19.760 --> 00:35:20.810
controller.

00:35:20.810 --> 00:35:22.570
And you see it there.

00:35:22.570 --> 00:35:25.130
You can use it to just
play beats or play

00:35:25.130 --> 00:35:26.540
expressive melodies.

00:35:26.540 --> 00:35:31.190
And when we launched BLOCKS,
we initially launched on iOS.

00:35:31.190 --> 00:35:35.100
But the idea was always to
make it go far and wide.

00:35:35.100 --> 00:35:39.440
And so the issue for us was
really about the latency--

00:35:39.440 --> 00:35:40.980
all the stuff that
Don and Phil have

00:35:40.980 --> 00:35:43.100
been talking about--
because to power

00:35:43.100 --> 00:35:44.590
these new expressive
instruments,

00:35:44.590 --> 00:35:47.530
we developed a
professional-grade synthesizer

00:35:47.530 --> 00:35:48.600
called Equator.

00:35:48.600 --> 00:35:53.060
And with Equator, you're running
many, many different channels

00:35:53.060 --> 00:35:54.801
of synthesis at the same time.

00:35:54.801 --> 00:35:56.300
And you're controlling
them with all

00:35:56.300 --> 00:35:59.190
of these different
multi-parameter gestures.

00:35:59.190 --> 00:36:02.030
It's a professional
audio application

00:36:02.030 --> 00:36:04.320
that's used in studios
all around the world.

00:36:04.320 --> 00:36:07.470
So to run that on a phone, we
had to do quite a bit of work.

00:36:07.470 --> 00:36:10.257
But the recent developments
in the last few versions

00:36:10.257 --> 00:36:11.840
of Android have made
a big difference.

00:36:11.840 --> 00:36:14.590
And all of the stuff
that's just been discussed

00:36:14.590 --> 00:36:18.400
has actually made it so now
we can run all the sounds

00:36:18.400 --> 00:36:21.130
in Equator on Android devices.

00:36:21.130 --> 00:36:23.950
Noise, the application, is
available in Early Access

00:36:23.950 --> 00:36:25.460
in the Google Play Store.

00:36:25.460 --> 00:36:27.710
And Marco and Jack, some
of you may have noticed,

00:36:27.710 --> 00:36:30.420
opened up Google
I/O two days ago

00:36:30.420 --> 00:36:32.170
with a performance
that was performed just

00:36:32.170 --> 00:36:33.800
on four-pixel phones.

00:36:33.800 --> 00:36:36.820
So they're going to just
play a minute from that.

00:36:36.820 --> 00:36:41.280
So it's Seaboard plus BLOCKS
plus four-pixel phones,

00:36:41.280 --> 00:36:46.010
three instances of Noise, and
they're also using DJ Pro2.

00:36:46.010 --> 00:36:47.230
So let's take a look.

00:36:47.230 --> 00:36:50.230
[MUSIC PLAYING]

00:37:45.230 --> 00:37:47.730
[APPLAUSE]

00:37:52.730 --> 00:37:53.490
Thank you so much.

00:37:53.490 --> 00:37:56.250
So one of the reasons why
we were able to do this

00:37:56.250 --> 00:37:59.560
was that we developed a
coding framework called JUCE--

00:37:59.560 --> 00:38:05.390
J-U-C-E. And it's a C++
cross-platform framework

00:38:05.390 --> 00:38:08.440
that's built for audio, and
it's really built for speed.

00:38:08.440 --> 00:38:12.520
And so we've been working not
only using JUCE for Noise,

00:38:12.520 --> 00:38:15.770
but we work with thousands of
developers around the world who

00:38:15.770 --> 00:38:18.640
are creating audio applications
that are cross-platform.

00:38:18.640 --> 00:38:21.430
And what we're finding is
with these recent improvements

00:38:21.430 --> 00:38:24.680
in Android, it's not just
for our applications.

00:38:24.680 --> 00:38:26.350
But for many of our
developers, they

00:38:26.350 --> 00:38:28.710
can take applications that
were audio applications that

00:38:28.710 --> 00:38:31.100
were developed for
iOS, for example,

00:38:31.100 --> 00:38:33.840
and now port those
over to Android.

00:38:33.840 --> 00:38:36.230
And we're also seeing, this
is an interesting opportunity

00:38:36.230 --> 00:38:38.180
for a lot of other
developers out there

00:38:38.180 --> 00:38:41.690
who want to create
low-latency audio applications

00:38:41.690 --> 00:38:45.136
but don't necessarily have
the resources to learn

00:38:45.136 --> 00:38:46.760
all of the different
systems associated

00:38:46.760 --> 00:38:47.670
with a different platform.

00:38:47.670 --> 00:38:49.961
So that's something to check
out, if you're interested,

00:38:49.961 --> 00:38:50.722
at JUCE.com.

00:38:50.722 --> 00:38:53.930
We also organized
something called ADC--

00:38:53.930 --> 00:38:57.370
not the ADC that Phil
was talking about.

00:38:57.370 --> 00:38:59.410
But it's called Audio
Developer Conference

00:38:59.410 --> 00:39:03.220
in London, which is on the 13th
and 15th of November, which

00:39:03.220 --> 00:39:04.560
deals with all of these issues.

00:39:04.560 --> 00:39:07.360
So check that out at JUCE.com.

00:39:07.360 --> 00:39:09.907
But just thank
you for tuning in.

00:39:09.907 --> 00:39:11.490
And we thought we'd
leave you with one

00:39:11.490 --> 00:39:13.950
more little performance
from Marco and jack.

00:39:17.918 --> 00:39:20.894
[MUSIC PLAYING]

00:40:07.022 --> 00:40:09.502
[APPLAUSE]

00:40:14.550 --> 00:40:17.940
So Marco and Jack Parisi,
everyone, and also,

00:40:17.940 --> 00:40:19.240
check out their work.

00:40:19.240 --> 00:40:20.750
Parisi is doing
some amazing things

00:40:20.750 --> 00:40:22.060
and releasing some great work.

00:40:22.060 --> 00:40:23.910
So I believe that's
all for this session.

00:40:23.910 --> 00:40:28.040
And there's a Sandbox
that will follow.

00:40:28.040 --> 00:40:30.770
So come check it out.

00:40:30.770 --> 00:40:32.960
And thank you all so very
much for coming today.

00:40:32.960 --> 00:40:35.060
[APPLAUSE]

00:40:35.060 --> 00:40:38.110
[MUSIC PLAYING]

