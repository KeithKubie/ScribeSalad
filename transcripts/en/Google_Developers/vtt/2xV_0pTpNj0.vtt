WEBVTT
Kind: captions
Language: en

00:00:00.834 --> 00:00:02.234
Brad Chen: Good morning.

00:00:02.234 --> 00:00:04.200
Thanks very much for joining
this session of Google IO.

00:00:04.200 --> 00:00:05.734
My name is Brad Chen,

00:00:05.734 --> 00:00:08.734
and I'm the Engineering Manager
of the Native Client project.

00:00:08.734 --> 00:00:10.534
And I'm really looking forward

00:00:10.534 --> 00:00:12.634
to telling you
a little bit about that today.

00:00:12.634 --> 00:00:15.334
I also wanted to mention
right away

00:00:15.334 --> 00:00:17.634
that we have other events
planned for you today.

00:00:17.634 --> 00:00:20.133
There's a Fireside Chat
at 1:00

00:00:20.133 --> 00:00:23.434
and office hours
for the Native Client project

00:00:23.434 --> 00:00:24.934
at 3:00.

00:00:24.934 --> 00:00:27.033
And a bunch of the team
members are here today.

00:00:27.033 --> 00:00:29.767
Can you guys say hello?

00:00:29.767 --> 00:00:31.434
We're looking forward
to answering

00:00:31.434 --> 00:00:33.367
any questions you have
about how to use Native Client,

00:00:33.367 --> 00:00:35.734
how to get comfortable with
the system, that sort of thing.

00:00:35.734 --> 00:00:38.434
So...let's get on
with it then.

00:00:38.434 --> 00:00:41.067
Let's talk a little bit about
Native Client and native code.

00:00:41.067 --> 00:00:42.634
Now, why would anybody want

00:00:42.634 --> 00:00:45.634
native code in a web browser
anyways?

00:00:45.634 --> 00:00:48.601
I mean, it's been such a big
source of problems in the past.

00:00:48.601 --> 00:00:51.634
Well, there's a number
of really basic things

00:00:51.634 --> 00:00:53.434
that are motivating us.

00:00:53.434 --> 00:00:54.934
Firstly, performance.

00:00:54.934 --> 00:00:59.133
The JavaScript implementations

00:00:59.133 --> 00:01:02.200
that are available in browsers
like Chrome nowadays

00:01:02.200 --> 00:01:04.000
are really quite
incredibly good.

00:01:04.000 --> 00:01:05.534
But in spite of that,

00:01:05.534 --> 00:01:07.267
there's still about two
orders of magnitude difference

00:01:07.267 --> 00:01:09.167
between what you can do
with JavaScript

00:01:09.167 --> 00:01:11.100
and what you can do
with native code.

00:01:11.100 --> 00:01:13.334
And the hardware architecture
trends actually suggest

00:01:13.334 --> 00:01:16.100
that that gap is going to
continue to broaden.

00:01:16.100 --> 00:01:18.434
Things like vector instructions
and threading

00:01:18.434 --> 00:01:21.968
are just not useful features
in today's browser

00:01:21.968 --> 00:01:24.133
for JavaScript-based systems.

00:01:24.133 --> 00:01:26.667
And so that performance,

00:01:26.667 --> 00:01:28.868
approximately
two orders of magnitude,

00:01:28.868 --> 00:01:30.434
just isn't available.

00:01:30.434 --> 00:01:32.934
So performance is really
the main thing driving us,

00:01:32.934 --> 00:01:34.901
and you'll see some other
evidence of that

00:01:34.901 --> 00:01:36.701
as I tell you
more about the system.

00:01:36.701 --> 00:01:39.734
Apart from performance,
I kind of think

00:01:39.734 --> 00:01:41.200
that people should
be able to use

00:01:41.200 --> 00:01:43.000
any programming language
they want.

00:01:43.000 --> 00:01:46.000
She shouldn't be obliged to only
use one particular language.

00:01:46.000 --> 00:01:49.300
And so native code
and native compilation

00:01:49.300 --> 00:01:52.601
makes a lot of additional
languages available.

00:01:52.601 --> 00:01:55.300
And not only are the languages
available that you like then,

00:01:55.300 --> 00:01:59.200
but also all the legacy code
that exists in those languages.

00:01:59.200 --> 00:02:01.667
And we're doing a lot
to try and make it easy

00:02:01.667 --> 00:02:04.033
to import
and use legacy code.

00:02:04.033 --> 00:02:07.968
So...with these benefits,

00:02:07.968 --> 00:02:09.767
you might wonder,
well, gee whiz, you know,

00:02:09.767 --> 00:02:12.734
ActiveX and NPAPI,
you know,

00:02:12.734 --> 00:02:14.968
Netscape and Microsoft
introduced those ten years ago,

00:02:14.968 --> 00:02:16.701
so what's the big deal?

00:02:16.701 --> 00:02:19.100
Well, a couple of things
you never got

00:02:19.100 --> 00:02:22.634
with these previous systems
are portability and safety.

00:02:22.634 --> 00:02:25.334
An ActiveX plugin
only runs on Windows,

00:02:25.334 --> 00:02:28.734
and NPAPI plugins typically
do use the native OS interfaces,

00:02:28.734 --> 00:02:30.100
so you can't move them

00:02:30.100 --> 00:02:32.267
from operating system
to operating system.

00:02:32.267 --> 00:02:35.567
Moreover,
because they have access

00:02:35.567 --> 00:02:37.667
to those native operating
system interfaces,

00:02:37.667 --> 00:02:39.501
they have full access
to the file system

00:02:39.501 --> 00:02:40.934
and full access to the network.

00:02:40.934 --> 00:02:42.501
They can do anything you want,

00:02:42.501 --> 00:02:44.567
which is, you know,
great on the one hand,

00:02:44.567 --> 00:02:47.534
unless you happen to be
the recipient of such a module

00:02:47.534 --> 00:02:49.701
that wants to send junk mail

00:02:49.701 --> 00:02:52.667
or infect your computer
with viruses.

00:02:52.667 --> 00:02:56.000
And so, these are things
that we've made

00:02:56.000 --> 00:02:58.634
very specific design decisions
and done a lot of work

00:02:58.634 --> 00:03:00.434
to try and make
much more difficult.

00:03:00.434 --> 00:03:02.667
Our goal, in terms of
portability and safety,

00:03:02.667 --> 00:03:04.200
is to deliver a system

00:03:04.200 --> 00:03:06.968
that gives about the same level
of portability and safety

00:03:06.968 --> 00:03:08.601
as JavaScript,
and eventually, you know,

00:03:08.601 --> 00:03:11.000
we'd like to even do better
than JavaScript.

00:03:11.000 --> 00:03:14.067
So that's sort of the background
on why native code.

00:03:14.067 --> 00:03:16.133
Now, what do we mean
by performance?

00:03:16.133 --> 00:03:18.834
'Cause, I mean, you can write
pretty fast JavaScript nowadays.

00:03:18.834 --> 00:03:20.634
Well, what we mean is,
literally,

00:03:20.634 --> 00:03:22.734
we wanna be within
single digit percentages

00:03:22.734 --> 00:03:25.501
of the best you can do
with desktop native code.

00:03:25.501 --> 00:03:26.934
And in particular,

00:03:26.934 --> 00:03:29.033
it means supporting
features like threads.

00:03:29.033 --> 00:03:31.434
Modern CPUs are multicore

00:03:31.434 --> 00:03:33.834
and also will tend to be
multithreaded,

00:03:33.834 --> 00:03:36.801
and so we've put a lot
of effort into providing

00:03:36.801 --> 00:03:40.133
a subset of POSIX threads
in Native Client...

00:03:40.133 --> 00:03:44.501
also sometimes known as
"enough rope to hang yourself".

00:03:44.501 --> 00:03:46.734
But we're also providing
abstractions

00:03:46.734 --> 00:03:48.834
on top of the threads
to make them easier to use.

00:03:48.834 --> 00:03:51.534
So for example,
Intel's Thread Building Blocks

00:03:51.534 --> 00:03:54.501
builds cleanly
on top of Native Client,

00:03:54.501 --> 00:03:57.834
and that's a kind of
higher level interface.

00:03:57.834 --> 00:04:00.200
Another important
performance feature

00:04:00.200 --> 00:04:03.267
which I already mentioned
briefly is vector instructions.

00:04:03.267 --> 00:04:05.868
And we'll be showing you
an example today

00:04:05.868 --> 00:04:08.067
of an application
that uses SSE instructions

00:04:08.067 --> 00:04:09.901
to accelerate photo processing.

00:04:09.901 --> 00:04:13.200
And, last but not least,
for the people who really need

00:04:13.200 --> 00:04:17.067
the highest level of performance
available in their applications,

00:04:17.067 --> 00:04:18.901
we make it relatively
straightforward

00:04:18.901 --> 00:04:20.701
to use hand-coded assembler

00:04:20.701 --> 00:04:22.501
for the small number
of people

00:04:22.501 --> 00:04:24.267
who are actually interested
in doing that.

00:04:24.267 --> 00:04:26.701
But for the really high end
performance-oriented things,

00:04:26.701 --> 00:04:28.567
the computational kernels,

00:04:28.567 --> 00:04:31.501
animation applications,
that sort of thing,

00:04:31.501 --> 00:04:33.901
all that performance
is available

00:04:33.901 --> 00:04:36.000
and substantially as available

00:04:36.000 --> 00:04:39.033
as in a desktop
programming environment.

00:04:39.033 --> 00:04:41.400
So what does this mean
for the Web?

00:04:41.400 --> 00:04:44.400
What are the new things that we
think Native Client will enable?

00:04:44.400 --> 00:04:49.501
Well, as an example,
by giving the CPU performance--

00:04:49.501 --> 00:04:51.901
making it available
in web applications,

00:04:51.901 --> 00:04:54.901
we think we can enable safer
multimedia codecs.

00:04:54.901 --> 00:04:56.934
You'll be able to have
a multimedia codec

00:04:56.934 --> 00:04:59.067
that's embedded
in a safe environment

00:04:59.067 --> 00:05:02.767
instead of running
as unconstrained native code.

00:05:02.767 --> 00:05:04.567
We'll show you some examples,

00:05:04.567 --> 00:05:06.634
and we have other examples
in our open source project

00:05:06.634 --> 00:05:09.033
of real-time audio and video
synthesis.

00:05:09.033 --> 00:05:10.834
This is animation, right,

00:05:10.834 --> 00:05:13.868
so substantially more ambitious
than just displaying a video.

00:05:13.868 --> 00:05:15.067
We're actually
creating the video

00:05:15.067 --> 00:05:16.567
and then showing it to you.

00:05:16.567 --> 00:05:18.367
Another thing
that's really important

00:05:18.367 --> 00:05:20.767
in a lot of modern user
interfaces and games

00:05:20.767 --> 00:05:22.534
is physics simulations.

00:05:22.534 --> 00:05:24.067
You actually need to have
Newtonian physics

00:05:24.067 --> 00:05:25.868
with object colliding
into each other

00:05:25.868 --> 00:05:27.968
and responding
in realistic ways.

00:05:27.968 --> 00:05:30.634
And again, in our Quake demo,

00:05:30.634 --> 00:05:32.467
which is available
in our open source release,

00:05:32.467 --> 00:05:35.167
you can see an example of that.

00:05:35.167 --> 00:05:37.834
You know, just briefly
going through the list,

00:05:37.834 --> 00:05:40.534
audio and video analysis
and recognition,

00:05:40.534 --> 00:05:42.968
things like face recognition
we think should be possible

00:05:42.968 --> 00:05:46.567
in browser-based applications
with, you know,

00:05:46.567 --> 00:05:48.667
with native code.

00:05:48.667 --> 00:05:50.167
Multimedia editors.

00:05:50.167 --> 00:05:52.868
Eventually high-throughput
cryptography

00:05:52.868 --> 00:05:54.934
and more flexible
than just using SSL.

00:05:54.934 --> 00:05:58.701
You'll be able to encode
and decode the content

00:05:58.701 --> 00:06:00.367
as you determine.

00:06:00.367 --> 00:06:02.534
And application-specific
data compression,

00:06:02.534 --> 00:06:04.300
which has a potential
to give you

00:06:04.300 --> 00:06:08.234
much more dense representations
of domain-specific data

00:06:08.234 --> 00:06:11.801
than just a generic compression
algorithm like gzip.

00:06:11.801 --> 00:06:15.567
Together with this,
with O3D,

00:06:15.567 --> 00:06:19.334
that is the 3-dimmensional
graphics interfaces for the Web

00:06:19.334 --> 00:06:21.400
that Google
has recently introduced,

00:06:21.400 --> 00:06:22.934
we think we'll be able
to enable things

00:06:22.934 --> 00:06:24.734
like high quality games,

00:06:24.734 --> 00:06:26.834
games that start to approach
the quality of things

00:06:26.834 --> 00:06:28.901
that you're accustomed
to seeing on consoles,

00:06:28.901 --> 00:06:31.934
as well as CAD applications
and a whole variety of things.

00:06:31.934 --> 00:06:34.000
So these are the kind
of applications

00:06:34.000 --> 00:06:37.300
that we want to be able
to enable with Native Client.

00:06:37.300 --> 00:06:40.300
Now...so that's enough
for background.

00:06:40.300 --> 00:06:41.801
What I want to do right now--

00:06:41.801 --> 00:06:45.367
and what we're gonna spend
most of the time on today--

00:06:45.367 --> 00:06:47.200
is going through some examples

00:06:47.200 --> 00:06:49.901
of actual Native Client
applications that we've built

00:06:49.901 --> 00:06:51.701
and show you some of
the nuts and bolts

00:06:51.701 --> 00:06:53.501
of how things are put together.

00:06:53.501 --> 00:06:55.000
Before showing you that,
I'm gonna go through

00:06:55.000 --> 00:06:58.367
a series of architecture
diagrams

00:06:58.367 --> 00:07:00.734
so you can sort of see
how the pieces--

00:07:00.734 --> 00:07:02.868
what are the pieces
and how they work together

00:07:02.868 --> 00:07:04.701
before we do the examples.

00:07:04.701 --> 00:07:07.400
So suppose, for example,

00:07:07.400 --> 00:07:09.200
you wanted to write
a little game--

00:07:09.200 --> 00:07:12.167
Global Cooling we're gonna
call it in this case--

00:07:12.167 --> 00:07:14.267
and it's implemented
as a web-based application.

00:07:14.267 --> 00:07:16.367
It happens to use
a Native Client module,

00:07:16.367 --> 00:07:18.467
so being a web-based
application,

00:07:18.467 --> 00:07:20.300
there's gonna be
some HTML someplace.

00:07:20.300 --> 00:07:23.000
Now, there's two models that
we're gonna talk about today

00:07:23.000 --> 00:07:25.000
for using
Native Client modules.

00:07:25.000 --> 00:07:26.567
One is as a plugin,

00:07:26.567 --> 00:07:28.701
and that's what we're gonna
talk about in this example.

00:07:28.701 --> 00:07:30.501
The other
is using web workers,

00:07:30.501 --> 00:07:32.267
an emerging HTML standard

00:07:32.267 --> 00:07:34.968
that you probably
heard about yesterday.

00:07:34.968 --> 00:07:37.367
So in this case,
if you're using a plugin,

00:07:37.367 --> 00:07:39.467
you'll commonly use
an object tag.

00:07:39.467 --> 00:07:40.968
And there'll be
a source argument

00:07:40.968 --> 00:07:42.501
and a number of other
arguments,

00:07:42.501 --> 00:07:44.901
but there'll be a source
argument to the object tag

00:07:44.901 --> 00:07:49.100
that says where is the content
that's gonna be activated

00:07:49.100 --> 00:07:50.567
by the plugin?

00:07:50.567 --> 00:07:53.300
When Native Client
sees the object tag

00:07:53.300 --> 00:07:55.534
and the mime type
associated with it,

00:07:55.534 --> 00:07:57.000
when the browser sees that,

00:07:57.000 --> 00:07:59.567
it actives the Native Client
infrastructure

00:07:59.567 --> 00:08:02.400
and, in particular,
a helper module

00:08:02.400 --> 00:08:06.267
that knows how to handle
the native code

00:08:06.267 --> 00:08:08.634
and enable it for
the web-based application.

00:08:08.634 --> 00:08:11.367
The browser, when it sees
the source argument,

00:08:11.367 --> 00:08:14.367
is going to download
the untrusted native code

00:08:14.367 --> 00:08:17.667
from a website
someplace on the internet.

00:08:17.667 --> 00:08:20.334
Now, in the case
of climate modeling,

00:08:20.334 --> 00:08:23.367
we probably will need
some physical simulation.

00:08:23.367 --> 00:08:25.434
So that's what most of...

00:08:25.434 --> 00:08:28.133
the scenario's
gonna be based on.

00:08:28.133 --> 00:08:30.267
But suppose,
just for a moment,

00:08:30.267 --> 00:08:33.267
suppose that somebody
was trying to trick you

00:08:33.267 --> 00:08:37.167
and get you to download and run
something dangerous, okay?

00:08:37.167 --> 00:08:40.434
So before Native Client
is gonna enable this module,

00:08:40.434 --> 00:08:43.734
it's going to pass it through
a security inspection,

00:08:43.734 --> 00:08:46.300
a static analysis
of the actual machine code,

00:08:46.300 --> 00:08:48.534
to make sure
that there are no sharp edges,

00:08:48.534 --> 00:08:50.067
nothing dangerous.

00:08:50.067 --> 00:08:53.033
And if it sees a module
that breaks the rules,

00:08:53.033 --> 00:08:55.000
that does some of the things

00:08:55.000 --> 00:08:57.267
that are explicitly
not allowed in Native Client,

00:08:57.267 --> 00:08:59.934
that module will be rejected,
and we will refuse to run it.

00:08:59.934 --> 00:09:01.801
And that's exactly
what will happen

00:09:01.801 --> 00:09:05.701
for random x86 binaries
that you might choose.

00:09:05.701 --> 00:09:07.200
Because there's
a set of instructions,

00:09:07.200 --> 00:09:09.901
a set of constructs
in the machine code

00:09:09.901 --> 00:09:11.467
that we simply don't allow

00:09:11.467 --> 00:09:13.834
because they lead
to safety problems.

00:09:13.834 --> 00:09:16.234
But if the Native Client module
in question

00:09:16.234 --> 00:09:20.100
has been built properly
and follows all of the rules

00:09:20.100 --> 00:09:22.834
that we've identified
for the system,

00:09:22.834 --> 00:09:24.901
then it will pass through
the security scan.

00:09:24.901 --> 00:09:28.801
And the next step
is to load it into a container.

00:09:28.801 --> 00:09:30.634
That's where
it will be contained

00:09:30.634 --> 00:09:32.334
and allowed to run safely.

00:09:32.334 --> 00:09:33.801
We actually think
of this container

00:09:33.801 --> 00:09:35.334
as kind of like
being in jail,

00:09:35.334 --> 00:09:36.901
'cause there's still
a set of things

00:09:36.901 --> 00:09:39.000
that we're not gonna allow
this native code to do.

00:09:39.000 --> 00:09:40.801
It's still gonna be
somewhat constrained.

00:09:40.801 --> 00:09:44.434
But now that it's activated
on your desktop

00:09:44.434 --> 00:09:46.834
and established and running,

00:09:46.834 --> 00:09:48.400
we can connect it

00:09:48.400 --> 00:09:51.033
so it can communicate
freely with the browser.

00:09:51.033 --> 00:09:53.133
And at that point,
it's gonna be able to actually

00:09:53.133 --> 00:09:55.834
interact with the browser,
and the browser, of course,

00:09:55.834 --> 00:09:57.434
will be able
to interact with it--

00:09:57.434 --> 00:10:00.601
graphics, you know, events,
all that sort of thing.

00:10:00.601 --> 00:10:06.033
So we've got our Native
Client-enabled web application.

00:10:06.033 --> 00:10:09.033
So that's a high level model
of what's going on.

00:10:09.033 --> 00:10:12.334
Just to be explicit
about a couple of details--

00:10:12.334 --> 00:10:14.701
a couple of nuances
of the system--

00:10:14.701 --> 00:10:16.234
we run the Native Client
modules

00:10:16.234 --> 00:10:17.734
in their own address space,

00:10:17.734 --> 00:10:21.033
and that's actually mostly
for exception isolation.

00:10:21.033 --> 00:10:23.734
We don't need that isolation
for memory protection.

00:10:23.734 --> 00:10:26.400
We've actually implemented that
in our sandbox.

00:10:26.400 --> 00:10:30.968
But exception handling
is more challenging.

00:10:30.968 --> 00:10:33.934
The operating systems don't
know how to handle exceptions

00:10:33.934 --> 00:10:35.400
except by killing the task.

00:10:35.400 --> 00:10:38.200
So by putting the Native Client
process module

00:10:38.200 --> 00:10:39.901
in its own process,

00:10:39.901 --> 00:10:44.734
we prevent the operating system
from terminating the browser.

00:10:44.734 --> 00:10:47.701
Another thing is
the communication interface

00:10:47.701 --> 00:10:49.801
that's indicated
with the arrows there

00:10:49.801 --> 00:10:52.434
allows for a simple message
passed in communication.

00:10:52.434 --> 00:10:54.000
In addition to that,

00:10:54.000 --> 00:10:56.400
something that we've done
that's really very powerful

00:10:56.400 --> 00:10:58.200
is we provide
a shared memory--

00:10:58.200 --> 00:11:00.300
you can establish
shared memory regions

00:11:00.300 --> 00:11:03.400
between the Native Client
module and the browser.

00:11:03.400 --> 00:11:06.968
And that's essential
for doing things like graphics

00:11:06.968 --> 00:11:09.968
that require really high
communications throughput.

00:11:09.968 --> 00:11:13.567
The shared memory regions
also allow you

00:11:13.567 --> 00:11:16.033
to implement things
like spinlocks

00:11:16.033 --> 00:11:17.267
in the case that you need

00:11:17.267 --> 00:11:20.767
really high frequency
communication.

00:11:20.767 --> 00:11:22.801
So although you can actually
do pretty well

00:11:22.801 --> 00:11:24.400
in terms of latency

00:11:24.400 --> 00:11:26.234
with the message passing
interface too.

00:11:26.234 --> 00:11:28.267
So that's the architecture
at a really high level,

00:11:28.267 --> 00:11:32.734
and keep this in mind as we go
through the three examples.

00:11:32.734 --> 00:11:34.334
I want to tell you
a little bit about

00:11:34.334 --> 00:11:35.801
security of Native Client,

00:11:35.801 --> 00:11:37.567
'cause it's a legitimate
concern for anybody

00:11:37.567 --> 00:11:40.300
who's ever used an ActiveX
or an NPAPI control.

00:11:40.300 --> 00:11:42.567
And it's really what we spent
most of our time on so far

00:11:42.567 --> 00:11:43.868
in the project.

00:11:43.868 --> 00:11:45.367
Our goal,
like I mentioned earlier,

00:11:45.367 --> 00:11:47.467
is to make native code

00:11:47.467 --> 00:11:50.767
at least as safe as JavaScript
and HTML

00:11:50.767 --> 00:11:52.567
and the other things
that people, you know,

00:11:52.567 --> 00:11:55.567
basically take for granted
in web content.

00:11:55.567 --> 00:11:57.968
So some examples
of steps that we've taken

00:11:57.968 --> 00:12:00.667
to make Native Client safer--

00:12:00.667 --> 00:12:03.434
firstly, multiple internal
security reviews.

00:12:03.434 --> 00:12:04.934
We code review all our code.

00:12:04.934 --> 00:12:06.467
That's a standard
Google practice.

00:12:06.467 --> 00:12:09.734
And anything that gets
presented publicly from Google

00:12:09.734 --> 00:12:12.133
goes through a design review
and an implementation review.

00:12:12.133 --> 00:12:14.234
The implementation review
is a really fun one.

00:12:14.234 --> 00:12:16.968
That's one--we hire
all these scary black hat guys,

00:12:16.968 --> 00:12:18.434
and they spend time--

00:12:18.434 --> 00:12:20.868
they get paid for finding
bugs in our code.

00:12:20.868 --> 00:12:22.667
So we managed to survive that.

00:12:22.667 --> 00:12:25.467
But that wasn't enough,
actually.

00:12:25.467 --> 00:12:27.334
We felt compelled to do more.

00:12:27.334 --> 00:12:28.734
So we've open sourced
the system.

00:12:28.734 --> 00:12:31.667
The system has been open sourced
since December 8th,

00:12:31.667 --> 00:12:36.901
and we've encouraged
public critical review,

00:12:36.901 --> 00:12:38.934
in part
by submitting papers

00:12:38.934 --> 00:12:41.567
to prestigious
technical conferences.

00:12:41.567 --> 00:12:44.834
We recently had a publication
in IEEE Security and Privacy,

00:12:44.834 --> 00:12:47.234
which is a really good
security conference.

00:12:47.234 --> 00:12:49.968
And more than that,
we held a security contest.

00:12:49.968 --> 00:12:52.634
We actually challenged
the community

00:12:52.634 --> 00:12:54.767
to find bugs in our system,

00:12:54.767 --> 00:12:57.133
and we're gonna be paying
cold, hard cash

00:12:57.133 --> 00:13:01.701
to the people who have found
the most interesting exploits.

00:13:01.701 --> 00:13:04.400
That contest actually ran
for about two months,

00:13:04.400 --> 00:13:06.033
ending on the 5th of May.

00:13:06.033 --> 00:13:08.300
And just some kind of background

00:13:08.300 --> 00:13:10.701
on what we put ourselves
through--

00:13:10.701 --> 00:13:13.400
over 400 teams signed up
to compete in this contest,

00:13:13.400 --> 00:13:16.133
and over 600 individuals.

00:13:16.133 --> 00:13:19.701
Of those people, there were only
22 issues submitted

00:13:19.701 --> 00:13:22.100
that were actually valid.

00:13:22.100 --> 00:13:23.901
Valid in the sense that,
you know,

00:13:23.901 --> 00:13:27.200
we agreed they were
a vulnerability of any sort.

00:13:27.200 --> 00:13:30.501
And I provided
a little high-level profile

00:13:30.501 --> 00:13:32.901
of the issues that we saw.

00:13:32.901 --> 00:13:35.000
Most of them were related
to browser integration,

00:13:35.000 --> 00:13:38.634
issues with, you know,
dealing with NPAPI

00:13:38.634 --> 00:13:42.501
or, you know,
memory allocation and management

00:13:42.501 --> 00:13:45.801
in that context.

00:13:45.801 --> 00:13:48.534
There are a couple of issues
with the inner sandbox too.

00:13:48.534 --> 00:13:50.033
That's that validator

00:13:50.033 --> 00:13:52.701
that does the static
analysis of the program.

00:13:52.701 --> 00:13:55.901
And to just give you
the next little detail,

00:13:55.901 --> 00:13:57.501
I wanted to share with you

00:13:57.501 --> 00:13:59.033
a couple of the more
interesting issues

00:13:59.033 --> 00:14:00.501
that we saw in the contest.

00:14:00.501 --> 00:14:02.367
You can see
the entire list of issues

00:14:02.367 --> 00:14:04.767
if you go to the Native Client
code site.

00:14:04.767 --> 00:14:07.701
But just kind of for
the purpose of the talk here,

00:14:07.701 --> 00:14:09.100
one interesting bug--

00:14:09.100 --> 00:14:14.067
the Native Client system
relies on being able to

00:14:14.067 --> 00:14:16.467
disassemble the program
accurately

00:14:16.467 --> 00:14:19.501
and understand
all possible control flow.

00:14:19.501 --> 00:14:21.567
And so this first bug
was an example

00:14:21.567 --> 00:14:24.567
where we had
a control flow analysis issue.

00:14:24.567 --> 00:14:26.968
Now, the Native Client system

00:14:26.968 --> 00:14:30.267
has disallowed
the x86 prefix byte

00:14:30.267 --> 00:14:32.968
for 16-bit address computation.

00:14:32.968 --> 00:14:35.067
Addr 16,
it's commonly called.

00:14:35.067 --> 00:14:36.868
And that's important,

00:14:36.868 --> 00:14:39.567
'cause that lets you do
kinds of address calculations

00:14:39.567 --> 00:14:41.667
that let you jump
anywhere in the code,

00:14:41.667 --> 00:14:44.067
so defeating our intention
of being able

00:14:44.067 --> 00:14:45.734
to reliably
disassemble the program.

00:14:45.734 --> 00:14:47.701
Well, but we missed
a case of that.

00:14:47.701 --> 00:14:50.067
It turns out that you can
use a different prefix,

00:14:50.067 --> 00:14:51.601
the data16 prefix,

00:14:51.601 --> 00:14:54.868
to do
16-bit address calculations

00:14:54.868 --> 00:14:58.767
for a certain set of jump
instructions that we neglected.

00:14:58.767 --> 00:15:01.834
And so it happened to be
two-byte jump instructions.

00:15:01.834 --> 00:15:05.434
So the solution
to address this problem

00:15:05.434 --> 00:15:08.734
and prevent this arbitrary
control-flow transfer

00:15:08.734 --> 00:15:11.434
is to disallow
the data16 instruction

00:15:11.434 --> 00:15:14.067
for a bunch of additional
two-byte instructions

00:15:14.067 --> 00:15:15.667
that we hadn't considered
before.

00:15:15.667 --> 00:15:18.667
And furthermore,
we took an additional step

00:15:18.667 --> 00:15:22.834
of un-mapping the entire
first 64 kilobytes

00:15:22.834 --> 00:15:25.234
of the address base
of the Native Client module

00:15:25.234 --> 00:15:27.334
so that any 16-bit address

00:15:27.334 --> 00:15:31.234
would never be a valid address
for a control-flow transfer.

00:15:31.234 --> 00:15:33.367
So one other quick example--

00:15:33.367 --> 00:15:34.834
I know this
is a little bit gritty,

00:15:34.834 --> 00:15:36.667
but just want to, you know,
make the point

00:15:36.667 --> 00:15:38.734
of the kinds of
steps we're taking

00:15:38.734 --> 00:15:40.234
to secure the system.

00:15:40.234 --> 00:15:43.234
There was a stack smashing
attack vulnerability found

00:15:43.234 --> 00:15:45.334
dealing with the eflags
direction flag.

00:15:45.334 --> 00:15:47.734
Now, on the x86 architecture,

00:15:47.734 --> 00:15:49.968
you probably know
there's some repeat instructions

00:15:49.968 --> 00:15:52.534
that can be used to copy
very long strings.

00:15:52.534 --> 00:15:54.634
And with those
mov instructions,

00:15:54.634 --> 00:15:57.033
there's a flag
that determines

00:15:57.033 --> 00:16:00.634
whether it copies forwards
or backwards.

00:16:00.634 --> 00:16:02.801
Well, it turns out
there was a place

00:16:02.801 --> 00:16:06.400
where we didn't check
those flags

00:16:06.400 --> 00:16:10.300
before invoking system calls
of the native operating system.

00:16:10.300 --> 00:16:14.200
And furthermore,
there was a window system call

00:16:14.200 --> 00:16:16.601
that used a repeat movs
instruction

00:16:16.601 --> 00:16:19.901
without checking
the direction flag first.

00:16:19.901 --> 00:16:22.300
So the combination
of those two problems

00:16:22.300 --> 00:16:23.801
meant that you could
actually use

00:16:23.801 --> 00:16:26.501
the Windows stack smashing
prevention code

00:16:26.501 --> 00:16:28.601
to do a stack smashing attack,

00:16:28.601 --> 00:16:30.100
which is kind of ironic.

00:16:30.100 --> 00:16:32.801
Fortunately, again, the
solution was not too difficult.

00:16:32.801 --> 00:16:34.901
It was just a matter
of clearing the flags carefully

00:16:34.901 --> 00:16:37.901
before every time we invoke
anybody's system calls.

00:16:37.901 --> 00:16:42.100
So that gives you hopefully
a little bit of intuition

00:16:42.100 --> 00:16:45.100
about the kind of tricky stuff
that is involved

00:16:45.100 --> 00:16:48.100
if you're going to attempt
to defeat the system.

00:16:48.100 --> 00:16:49.534
The good news,

00:16:49.534 --> 00:16:51.701
and the thing that we're
actually very pleased about,

00:16:51.701 --> 00:16:53.801
is although there were
a few, you know,

00:16:53.801 --> 00:16:57.100
22 issues submitted
to the contest,

00:16:57.100 --> 00:16:59.801
there were no real fundamental
architectural issues.

00:16:59.801 --> 00:17:02.567
They were all basically
implementation defects,

00:17:02.567 --> 00:17:05.868
and the kind of defects
that we had no trouble

00:17:05.868 --> 00:17:07.968
fixing in a matter of days.

00:17:07.968 --> 00:17:10.968
So that kind of reinforced
our belief

00:17:10.968 --> 00:17:13.067
that it's possible
to implement a system

00:17:13.067 --> 00:17:19.601
that achieves a substantial
level of safety.

00:17:19.601 --> 00:17:20.968
Okay.

00:17:20.968 --> 00:17:23.868
So before we dive into
the details of the examples,

00:17:23.868 --> 00:17:25.467
I wanted to tell you
a little bit about

00:17:25.467 --> 00:17:26.968
where the project is today

00:17:26.968 --> 00:17:28.968
and where we're going
in the future.

00:17:28.968 --> 00:17:34.701
Today, Native Client
is delivered as a NPAPI plugin.

00:17:34.701 --> 00:17:39.767
This design is really mostly
intended for research release,

00:17:39.767 --> 00:17:43.067
and it means that anybody who
has any NPAPI-capable browser

00:17:43.067 --> 00:17:47.267
including Opera, Safari,
Firefox, Chrome, any of those,

00:17:47.267 --> 00:17:51.167
can use our plugin
and explore creating

00:17:51.167 --> 00:17:54.767
and even trying to find
security defects in the system.

00:17:54.767 --> 00:17:58.067
The system, as you might have
noticed from my discussion,

00:17:58.067 --> 00:18:01.801
does rely quite heavily
on x86 machine code.

00:18:01.801 --> 00:18:03.534
It's the sort of
fundamental part

00:18:03.534 --> 00:18:05.367
of how we make things
secure.

00:18:05.367 --> 00:18:08.033
And the graphics support
we provide today

00:18:08.033 --> 00:18:09.868
is pretty much limited
to raster graphics

00:18:09.868 --> 00:18:11.634
which means, you know,
software graphics,

00:18:11.634 --> 00:18:14.634
not hardware accelerated
BitBlt operations.

00:18:14.634 --> 00:18:18.868
And our code development tree,

00:18:18.868 --> 00:18:21.834
for those of you
who have sent us change lists,

00:18:21.834 --> 00:18:23.667
is hosted internally.

00:18:23.667 --> 00:18:26.667
It turns out that these
are basically details

00:18:26.667 --> 00:18:28.434
for the research release,

00:18:28.434 --> 00:18:30.534
and going forward,
we're thinking much more about

00:18:30.534 --> 00:18:32.067
a developer-oriented system.

00:18:32.067 --> 00:18:34.167
So some of the implications
of that

00:18:34.167 --> 00:18:38.367
is rather than designing
the system

00:18:38.367 --> 00:18:40.133
as an NPAPI plugin,

00:18:40.133 --> 00:18:42.868
we want it to be built
directly into the browser.

00:18:42.868 --> 00:18:45.234
The web worker's demo
that we're gonna be showing

00:18:45.234 --> 00:18:47.334
is a first example of that.

00:18:47.334 --> 00:18:51.234
But we're also going to be
preparing revisions

00:18:51.234 --> 00:18:53.934
to the current version
of NPAPI,

00:18:53.934 --> 00:18:56.033
things that enhance
the portability

00:18:56.033 --> 00:18:59.667
and performance of NPAPI
as it's currently designed,

00:18:59.667 --> 00:19:03.000
so that this will be
a better interface

00:19:03.000 --> 00:19:07.200
for hosting safe plugins,
safer plugins and web browsers.

00:19:07.200 --> 00:19:11.701
We also believe very strongly
that the Web should be portable,

00:19:11.701 --> 00:19:16.501
and it is not really appropriate
to lock all future web content

00:19:16.501 --> 00:19:19.200
that uses this kind of
acceleration

00:19:19.200 --> 00:19:21.300
into a single instruction set.

00:19:21.300 --> 00:19:23.400
So we're putting a lot of
effort currently into

00:19:23.400 --> 00:19:29.701
64-bit x86 support
and also ARM support.

00:19:29.701 --> 00:19:32.400
Now, in terms of delivering
better graphics,

00:19:32.400 --> 00:19:34.501
we've got an effort--

00:19:34.501 --> 00:19:37.501
a collaboration
with the O3D team

00:19:37.501 --> 00:19:40.234
to deliver 3D graphics

00:19:40.234 --> 00:19:43.834
and make it available
to native code.

00:19:43.834 --> 00:19:46.734
A lot of developers have asked
about an open GL interface

00:19:46.734 --> 00:19:49.701
and the possibility of providing
an open GL interface

00:19:49.701 --> 00:19:50.901
in Native Client.

00:19:50.901 --> 00:19:52.534
That's definitely a request

00:19:52.534 --> 00:19:54.434
that we'd like to be able
to respond to

00:19:54.434 --> 00:19:55.834
at some point.

00:19:55.834 --> 00:19:59.100
And then finally, the other
detail I wanted to mention

00:19:59.100 --> 00:20:02.701
is we're moving into
a public SVN repository

00:20:02.701 --> 00:20:05.701
right alongside
the Chrome repository,

00:20:05.701 --> 00:20:09.000
which will make it much easier
for external developers

00:20:09.000 --> 00:20:12.334
to make contributions
directly into the system.

00:20:12.334 --> 00:20:16.501
So...the demos
that we're gonna show you today

00:20:16.501 --> 00:20:18.634
actually preview
some functionality

00:20:18.634 --> 00:20:20.400
that is not in our research
release yet

00:20:20.400 --> 00:20:23.100
but is a part of what
we're working on

00:20:23.100 --> 00:20:25.501
to provide
in our developer release.

00:20:25.501 --> 00:20:28.801
And the first example
is native web workers.

00:20:28.801 --> 00:20:30.300
Now, you've heard
some discussion

00:20:30.300 --> 00:20:33.300
in other sessions here
at Google IO about web workers,

00:20:33.300 --> 00:20:35.701
a way of creating threads
in JavaScript.

00:20:35.701 --> 00:20:38.400
Well, native web workers
are just like web workers

00:20:38.400 --> 00:20:40.501
except instead of being
written in JavaScript,

00:20:40.501 --> 00:20:42.000
they're written
in native code.

00:20:42.000 --> 00:20:44.701
But otherwise, they have
the same execution model

00:20:44.701 --> 00:20:46.801
and the same interfaces
as web workers.

00:20:46.801 --> 00:20:50.100
In particular, web worker
supports no shared data.

00:20:50.100 --> 00:20:52.534
There's no way to share data
between web workers

00:20:52.534 --> 00:20:54.601
and the browser,
and as a consequence of that,

00:20:54.601 --> 00:20:59.400
web workers can't actually
do direct DOM access.

00:20:59.400 --> 00:21:01.667
Web workers support
a postMessage API

00:21:01.667 --> 00:21:04.567
as well as XMLHTTPRequests,

00:21:04.567 --> 00:21:08.167
to make HTTP requests
of the hosting website

00:21:08.167 --> 00:21:11.167
and openDatabase to provide
access to stable storage.

00:21:11.167 --> 00:21:13.267
And you can see lots of details

00:21:13.267 --> 00:21:15.667
about the web worker
specification

00:21:15.667 --> 00:21:17.467
at the URL
that we provided up there.

00:21:17.467 --> 00:21:20.968
Our goals in Native Client
for native web workers

00:21:20.968 --> 00:21:23.167
are firstly
to support web workers

00:21:23.167 --> 00:21:24.968
and other languages
besides JavaScript,

00:21:24.968 --> 00:21:27.367
for example, C, C++ or Ruby.

00:21:27.367 --> 00:21:29.167
Also we still want to maintain

00:21:29.167 --> 00:21:31.567
the simplicity
of the web worker model,

00:21:31.567 --> 00:21:33.968
which was very deliberately
designed

00:21:33.968 --> 00:21:35.968
to prevent the kinds
of race conditions

00:21:35.968 --> 00:21:37.567
and other kinds of issues

00:21:37.567 --> 00:21:39.000
that can make
threaded programming

00:21:39.000 --> 00:21:40.567
sometimes very difficult

00:21:40.567 --> 00:21:43.868
and provide an interface
that's basically appropriate

00:21:43.868 --> 00:21:45.667
for low frequency applications.

00:21:45.667 --> 00:21:47.467
Things where like
you make a request

00:21:47.467 --> 00:21:50.167
and then, you know,
a second or so later,

00:21:50.167 --> 00:21:53.167
you get the information back
and can use it.

00:21:53.167 --> 00:21:55.267
So as an example of that,

00:21:55.267 --> 00:21:57.667
David Sehr, Tech Lead
for the Native Client project

00:21:57.667 --> 00:21:59.934
is gonna walk you through
what we've done

00:21:59.934 --> 00:22:03.167
with web workers
for Native Client.

00:22:03.167 --> 00:22:04.634
David Sehr: Thanks, Brad.

00:22:04.634 --> 00:22:07.033
As Brad said, I'm gonna
be talking a little bit about

00:22:07.033 --> 00:22:10.033
some early work we're doing on
supporting native web workers.

00:22:10.033 --> 00:22:12.767
As you probably heard,
Matt Papakipos talked yesterday

00:22:12.767 --> 00:22:15.734
about web workers and about
the sort of programming paradigm

00:22:15.734 --> 00:22:17.834
that it supports.

00:22:17.834 --> 00:22:19.767
I'm gonna show you
how we think

00:22:19.767 --> 00:22:22.167
one possible direction
that embedding Native Client

00:22:22.167 --> 00:22:24.167
into this sort of
programming model

00:22:24.167 --> 00:22:28.901
would be used, so...

00:22:28.901 --> 00:22:30.434
So here's a kind of
classic example

00:22:30.434 --> 00:22:32.567
of an application that
you might like to thread.

00:22:32.567 --> 00:22:34.634
It's a compute-intensive
application.

00:22:34.634 --> 00:22:36.734
In this case,
I'm going to be showing you

00:22:36.734 --> 00:22:38.767
computing a Mandelbrot picture.

00:22:38.767 --> 00:22:40.934
And each one of those boxes

00:22:40.934 --> 00:22:44.234
is eventually gonna be populated
with some colored bits.

00:22:44.234 --> 00:22:46.634
Mandelbrot is a compute-
intensive application.

00:22:46.634 --> 00:22:50.234
Basically you're computing
a bunch of floating point values

00:22:50.234 --> 00:22:52.334
for each one of the points
in the region.

00:22:52.334 --> 00:22:55.634
And we've taken this
as a little demo

00:22:55.634 --> 00:22:57.734
and panelized it by

00:22:57.734 --> 00:23:01.400
splitting each one of those
squares into four tiles.

00:23:01.400 --> 00:23:03.501
Each tile will be handled
by a separate web worker.

00:23:03.501 --> 00:23:05.334
On these modern multicore
processors,

00:23:05.334 --> 00:23:07.100
you can have four web workers,

00:23:07.100 --> 00:23:09.501
each having access
to one core,

00:23:09.501 --> 00:23:13.400
and you'll be able to...

00:23:13.400 --> 00:23:15.801
update Adobe, it appears,
at the moment.

00:23:15.801 --> 00:23:20.834
Anyway...[laughs].
So...

00:23:23.367 --> 00:23:26.000
So here's the JavaScript code

00:23:26.000 --> 00:23:29.501
that does a typical web worker
sort of...application,

00:23:29.501 --> 00:23:31.000
the one that I was
talking about before.

00:23:31.000 --> 00:23:32.601
There's a doubly nested loop.

00:23:32.601 --> 00:23:37.400
That's actually
just walking over the...

00:23:37.400 --> 00:23:38.901
each of the tiles.

00:23:38.901 --> 00:23:40.100
That's here.

00:23:40.100 --> 00:23:42.767
And each one of the tiles
is computed

00:23:42.767 --> 00:23:44.901
by an instance
of a web worker,

00:23:44.901 --> 00:23:47.901
and that's created
by this just new worker.

00:23:47.901 --> 00:23:50.901
And in the HTML 5 spec,

00:23:50.901 --> 00:23:54.501
the worker URL is
a JavaScript, uh, script.

00:23:54.501 --> 00:23:59.200
And then communication
is back from the web worker

00:23:59.200 --> 00:24:03.234
by assigning this
onmessage property

00:24:03.234 --> 00:24:06.601
to be a function
that takes an event.

00:24:06.601 --> 00:24:08.634
And that event will,
in this case,

00:24:08.634 --> 00:24:10.501
be the result
of the computation.

00:24:10.501 --> 00:24:12.300
Basically, it's a big
string containing

00:24:12.300 --> 00:24:14.667
the pixel RGB values.

00:24:14.667 --> 00:24:19.501
And...then there's some
GU here for

00:24:19.501 --> 00:24:22.701
putting the RGB
up on the screen.

00:24:22.701 --> 00:24:24.267
The host JavaScript,

00:24:24.267 --> 00:24:26.801
the JavaScript, actually,
that runs in the browser,

00:24:26.801 --> 00:24:30.868
is able to talk to the worker

00:24:30.868 --> 00:24:34.467
by sending--or using
these postMessage APIs.

00:24:34.467 --> 00:24:37.767
And so in this case,
each one of the tiles

00:24:37.767 --> 00:24:39.868
is started off.

00:24:39.868 --> 00:24:41.367
There's an onmessage
bound for it

00:24:41.367 --> 00:24:43.767
that will in-cue the tile

00:24:43.767 --> 00:24:45.300
and eventually
put it up on the screen

00:24:45.300 --> 00:24:46.767
when the last tile
is received.

00:24:46.767 --> 00:24:51.267
And then the tile computation
is actually started by

00:24:51.267 --> 00:24:54.267
being passed a string
that says "which tile are you"

00:24:54.267 --> 00:24:56.968
and "how big is the tile?"

00:24:56.968 --> 00:25:02.734
So the code, then, in the...
the worker JavaScript

00:25:02.734 --> 00:25:04.234
has a sort of similar flavor.

00:25:04.234 --> 00:25:06.934
There's an onmessage
that says

00:25:06.934 --> 00:25:09.934
"when I get a message
from the host JavaScript,

00:25:09.934 --> 00:25:11.734
what am I gonna do?"

00:25:11.734 --> 00:25:15.267
In this case, I'm going to do
an awful lot of...

00:25:15.267 --> 00:25:16.834
floating point stuff

00:25:16.834 --> 00:25:19.267
and then some computing RGB
values from the floating point.

00:25:19.267 --> 00:25:24.334
And eventually,
I'm going to put together...

00:25:24.334 --> 00:25:27.701
a big string that contains
all the RGB pixel values.

00:25:27.701 --> 00:25:29.734
And I'm going to do
a postMessage

00:25:29.734 --> 00:25:32.133
to pass that screen back
to the host JavaScript

00:25:32.133 --> 00:25:34.234
and the browser.

00:25:34.234 --> 00:25:36.334
So...pretty straightforward,
I think.

00:25:36.334 --> 00:25:40.834
So...our approach to this...

00:25:40.834 --> 00:25:45.334
for native web workers
will actually use the same API.

00:25:45.334 --> 00:25:48.067
The initial work we're doing,

00:25:48.067 --> 00:25:52.267
just basically the text
using a different URL--

00:25:52.267 --> 00:25:54.934
in our case,
looking for a .nexe

00:25:54.934 --> 00:25:56.734
or native executable.

00:25:56.734 --> 00:26:00.634
That's our name for
Native Client executables.

00:26:00.634 --> 00:26:06.100
If you see new worker
with the worker URL being

00:26:06.100 --> 00:26:09.100
mandel.nexe
instead of mandel.js,

00:26:09.100 --> 00:26:11.501
well, then you will start

00:26:11.501 --> 00:26:13.300
a Native Client
execution environment

00:26:13.300 --> 00:26:19.000
and...run the code that was
contained in that executable.

00:26:19.000 --> 00:26:20.501
Now, you'll be seeing this again

00:26:20.501 --> 00:26:22.601
in Nicholas's demo
in just a second.

00:26:22.601 --> 00:26:24.400
We have defined
in Native Client...

00:26:24.400 --> 00:26:26.200
there's an RPC interface

00:26:26.200 --> 00:26:29.501
which we call the simple RPC
or SRPC interface.

00:26:29.501 --> 00:26:33.400
And SRPC methods are always
of this sort of prototype

00:26:33.400 --> 00:26:37.300
where you basically
have a list input arguments

00:26:37.300 --> 00:26:40.901
and a list of return values,
and so...

00:26:40.901 --> 00:26:46.601
what we have done for this
is we bind one Native Client

00:26:46.601 --> 00:26:49.601
RPC method to be postMessage.

00:26:49.601 --> 00:26:52.000
And so that means

00:26:52.000 --> 00:26:56.801
an RPC to postMessage from
the host JavaScript is called--

00:26:56.801 --> 00:27:01.667
it will invoke this function
called Mandel worker up here.

00:27:01.667 --> 00:27:05.567
And Mandel worker
will extract its parameters.

00:27:05.567 --> 00:27:08.267
In this case, we're passing
strings as methods.

00:27:08.267 --> 00:27:11.567
The web worker interface
allows you

00:27:11.567 --> 00:27:13.067
to pass slightly richer
data types,

00:27:13.067 --> 00:27:16.467
but I'm not talking about
that in this particular example.

00:27:16.467 --> 00:27:18.234
So you can extract
the string value

00:27:18.234 --> 00:27:20.067
by saying the first
input argument,

00:27:20.067 --> 00:27:23.100
and it's a string,
so you extract that.

00:27:23.100 --> 00:27:26.901
Then it does some computing.

00:27:26.901 --> 00:27:29.267
This Mandel computes each one
of the point values

00:27:29.267 --> 00:27:31.067
and produces a string.

00:27:31.067 --> 00:27:35.267
And then when it's done
producing the string,

00:27:35.267 --> 00:27:38.267
it will call
a postMessage API,

00:27:38.267 --> 00:27:41.267
which is a postMessage
back to the browser

00:27:41.267 --> 00:27:43.667
saying here's the result
of my string.

00:27:43.667 --> 00:27:45.767
So other than the fact
that this is C,

00:27:45.767 --> 00:27:48.467
it looks an awful lot like
the JavaScript sort of approach.

00:27:48.467 --> 00:27:52.968
We defined an RPC handler
that does some computes,

00:27:52.968 --> 00:27:55.067
and it eventually
does a postMessage

00:27:55.067 --> 00:27:57.200
back to the host JavaScript.

00:27:57.200 --> 00:28:02.434
So...the two are very similar.

00:28:02.434 --> 00:28:06.567
So...and...

00:28:06.567 --> 00:28:09.534
forgive me the...

00:28:09.534 --> 00:28:11.033
posting things to the screen

00:28:11.033 --> 00:28:12.834
is actually slower
than doing most of the computes

00:28:12.834 --> 00:28:14.634
in these things.

00:28:14.634 --> 00:28:16.434
So the performance delta
is not obvious,

00:28:16.434 --> 00:28:20.634
but if the timing
is actually done,

00:28:20.634 --> 00:28:22.434
you'll see that the native
one is quite a bit faster

00:28:22.434 --> 00:28:23.934
than the JavaScript.

00:28:23.934 --> 00:28:25.434
But you can see the two things

00:28:25.434 --> 00:28:27.234
have functionally
the same behavior,

00:28:27.234 --> 00:28:30.000
the same host JavaScript code
is used

00:28:30.000 --> 00:28:32.334
for both the JavaScript
web worker

00:28:32.334 --> 00:28:34.834
and the Native Client
web worker.

00:28:34.834 --> 00:28:38.033
And we'll be developing
some more applications

00:28:38.033 --> 00:28:42.968
to try and showcase
the power of native executables

00:28:42.968 --> 00:28:44.367
in the setting

00:28:44.367 --> 00:28:47.367
as the web worker support
becomes more and more mature.

00:28:47.367 --> 00:28:51.234
It should be said that--
Brad said we're going live soon

00:28:51.234 --> 00:28:54.868
with our SV entry.

00:28:54.868 --> 00:28:57.868
The demo code
is in the repository.

00:28:57.868 --> 00:28:59.067
It'll be going out.

00:28:59.067 --> 00:29:00.467
The web worker support

00:29:00.467 --> 00:29:02.133
will be appearing
in a Chrome release

00:29:02.133 --> 00:29:03.901
that hasn't yet gone out.

00:29:03.901 --> 00:29:06.000
So sometime over
the next couple of weeks,

00:29:06.000 --> 00:29:10.200
we hope to get that out
so you'll be able to try this.

00:29:10.200 --> 00:29:13.167
And with that,
I'll turn it back to Brad.

00:29:15.033 --> 00:29:17.968
Chen: Thanks, David.

00:29:21.267 --> 00:29:23.701
Okay.

00:29:23.701 --> 00:29:26.434
So, uh...native web workers

00:29:26.434 --> 00:29:28.634
is probably gonna be
the simplest interface,

00:29:28.634 --> 00:29:30.634
simplest way to use
native code

00:29:30.634 --> 00:29:33.300
and get native code performance
in your web applications.

00:29:33.300 --> 00:29:35.400
For people
who want more interactivity,

00:29:35.400 --> 00:29:37.801
who want to write the kind
of high frequency applications

00:29:37.801 --> 00:29:40.801
like animation or audio
or video decoding,

00:29:40.801 --> 00:29:44.400
we're planning revisions
to NPAPI.

00:29:44.400 --> 00:29:47.701
We currently have NPA support
in our current system,

00:29:47.701 --> 00:29:50.100
but to address some of
the portability

00:29:50.100 --> 00:29:52.801
and performance issues
that we've found with that API.

00:29:52.801 --> 00:29:55.801
Now, for those of you who are
familiar with browser plugins,

00:29:55.801 --> 00:29:58.200
you probably recognize
that use today is quite limited.

00:29:58.200 --> 00:30:00.300
There's a lot of well-known
security issues,

00:30:00.300 --> 00:30:02.701
most of which
hopefully we've convinced

00:30:02.701 --> 00:30:04.501
that we can do something about--

00:30:04.501 --> 00:30:07.501
we've convinced you we can
do something about.

00:30:07.501 --> 00:30:09.400
Pop-up boxes asking people
questions

00:30:09.400 --> 00:30:12.033
that they really shouldn't
be asked in the first place...

00:30:12.033 --> 00:30:14.634
you know, overall,
web portability

00:30:14.634 --> 00:30:17.400
and the ubiquity of content
just kind of falls apart.

00:30:17.400 --> 00:30:20.267
We are determined
to create a better future

00:30:20.267 --> 00:30:21.901
for native plugins

00:30:21.901 --> 00:30:24.901
by addressing some of
the well-known misfeatures

00:30:24.901 --> 00:30:27.133
of NPAPI and ActiveX.

00:30:27.133 --> 00:30:29.033
And compared to web workers,

00:30:29.033 --> 00:30:30.801
we're going to actually
address

00:30:30.801 --> 00:30:33.000
some of the limitations
of that system.

00:30:33.000 --> 00:30:34.467
We will support shared data.

00:30:34.467 --> 00:30:37.534
We will provide the kinds
of things you need

00:30:37.534 --> 00:30:39.634
to implement high frequency
applications.

00:30:39.634 --> 00:30:43.334
And we'll also be providing
mechanisms through NPAPI

00:30:43.334 --> 00:30:46.167
to provide
synchronous DOM access.

00:30:46.167 --> 00:30:48.300
So as a first example

00:30:48.300 --> 00:30:50.834
of how these more direct
interfaces work,

00:30:50.834 --> 00:30:54.701
I want to show you
a video player, video decoder

00:30:54.701 --> 00:30:56.267
that we've been working on.

00:30:56.267 --> 00:30:58.100
Now, another thing
I want to point out,

00:30:58.100 --> 00:30:59.701
and the main point
of this example,

00:30:59.701 --> 00:31:01.267
is just how simple it is

00:31:01.267 --> 00:31:03.667
to take an existing
Linux application

00:31:03.667 --> 00:31:05.767
and make it work
under Native Client.

00:31:05.767 --> 00:31:07.868
This particular video decoder
is something

00:31:07.868 --> 00:31:10.267
that had been balancing around
inside Google for a while.

00:31:10.267 --> 00:31:14.667
The original test program
took an H.264 decoded video--

00:31:14.667 --> 00:31:16.267
encoded video--

00:31:16.267 --> 00:31:19.267
and wrote it as raw frames
into a file on disk.

00:31:19.267 --> 00:31:22.267
It only took 20 lines
of source code changes

00:31:22.267 --> 00:31:24.067
to take that original
test program

00:31:24.067 --> 00:31:25.567
and turn it into a program

00:31:25.567 --> 00:31:27.968
that's a simple Native Client
video player.

00:31:27.968 --> 00:31:31.567
About 210 additional lines
were required

00:31:31.567 --> 00:31:33.968
to add audio
and frame-rate control.

00:31:33.968 --> 00:31:35.467
But for now,
I just want to focus

00:31:35.467 --> 00:31:38.167
on the video modifications.

00:31:38.167 --> 00:31:41.100
So I'm actually
gonna walk you through

00:31:41.100 --> 00:31:43.267
the 20 lines of source changes
that it took

00:31:43.267 --> 00:31:45.133
to make this thing run
in Native Client.

00:31:45.133 --> 00:31:47.467
Firstly, in order to use

00:31:47.467 --> 00:31:51.367
the multimedia subsystem
that Native Client provides,

00:31:51.367 --> 00:31:53.767
and this subsystem, by the way,
leverages, you know,

00:31:53.767 --> 00:31:56.767
the communications
substrate NPAPI

00:31:56.767 --> 00:32:00.367
and the shared memory system
that I mentioned earlier.

00:32:00.367 --> 00:32:03.734
You make this call
to nacl_multimedia_init

00:32:03.734 --> 00:32:05.834
then four lines
of error checking.

00:32:05.834 --> 00:32:07.934
And then after initializing
the multimedia system,

00:32:07.934 --> 00:32:11.834
the next highlighted line
to nacl_video_init

00:32:11.834 --> 00:32:14.234
initializes
the video subsystem

00:32:14.234 --> 00:32:15.734
of the multimedia system.

00:32:15.734 --> 00:32:17.534
Four more lines of error
checking.

00:32:17.534 --> 00:32:19.033
We're gonna null out a pointer

00:32:19.033 --> 00:32:21.434
so that the application
doesn't try and write

00:32:21.434 --> 00:32:24.133
all of this video to a file
on disk.

00:32:24.133 --> 00:32:29.067
And that's the...
initialization code.

00:32:29.067 --> 00:32:31.033
The next change we had to make

00:32:31.033 --> 00:32:33.434
is when the frame
becomes available,

00:32:33.434 --> 00:32:35.534
to actually
display it on the screen.

00:32:35.534 --> 00:32:37.934
So the original
internal representation

00:32:37.934 --> 00:32:41.234
of frames in the system
was in YV12.

00:32:41.234 --> 00:32:45.133
We use this call, which was
already a part of the decoder,

00:32:45.133 --> 00:32:47.234
to create an RGB representation.

00:32:47.234 --> 00:32:52.033
and then a nacl_video_update
takes the RGB frame

00:32:52.033 --> 00:32:55.334
and causes it to be
blitted onto the screen.

00:32:55.334 --> 00:32:57.434
the screen real estate
that was established

00:32:57.434 --> 00:32:59.534
with the earlier
initialization calls.

00:32:59.534 --> 00:33:01.100
And that's it, actually.

00:33:01.100 --> 00:33:03.501
Those lines are all you need

00:33:03.501 --> 00:33:05.901
to actually get the video
displaying on the screen.

00:33:05.901 --> 00:33:08.300
Now, there's a couple of
includes that had to be fixed

00:33:08.300 --> 00:33:11.601
and there was a shutdown
that I didn't bother including.

00:33:11.601 --> 00:33:13.701
But that's pretty much
all it took.

00:33:13.701 --> 00:33:16.400
So the next thing I wanted
to actually show you

00:33:16.400 --> 00:33:18.200
is a demonstration
of the decoder.

00:33:18.200 --> 00:33:21.200
I was actually
going to build it for you first

00:33:21.200 --> 00:33:24.200
just so you can see
that, you know,

00:33:24.200 --> 00:33:26.300
that building
a Native Client module

00:33:26.300 --> 00:33:29.000
is actually not that different
from building anything else.

00:33:29.000 --> 00:33:30.200
Surprise, surprise.

00:33:30.200 --> 00:33:32.901
The path to the compiler
is a little bit messy.

00:33:32.901 --> 00:33:34.400
But after that,
this is pretty much

00:33:34.400 --> 00:33:37.400
just a normal old
invocation of GCC.

00:33:37.400 --> 00:33:39.534
It's got a bunch of
source files

00:33:39.534 --> 00:33:41.000
from the decoder itself,

00:33:41.000 --> 00:33:42.501
and then starting around here,

00:33:42.501 --> 00:33:44.300
we're pulling in some
additional source files

00:33:44.300 --> 00:33:48.501
that implement the audio part
of the system.

00:33:48.501 --> 00:33:50.300
And now it's built.

00:33:50.300 --> 00:33:52.701
So the next thing I wanna do
is actually invoke it.

00:33:52.701 --> 00:33:56.000
Now, I'm going to,
for the purposes of the demo,

00:33:56.000 --> 00:33:57.501
invoke it the way--

00:33:57.501 --> 00:34:01.467
typing the whole
command line out, we need to--

00:34:01.467 --> 00:34:03.267
and I'm not gonna be running
this in the browser,

00:34:03.267 --> 00:34:04.467
you'll notice.

00:34:04.467 --> 00:34:06.267
I'm gonna use the debug
environment

00:34:06.267 --> 00:34:08.067
that we use ourselves

00:34:08.067 --> 00:34:10.767
and that we provide as a part
of our open source release.

00:34:10.767 --> 00:34:14.667
So...let's see, staging...

00:34:14.667 --> 00:34:17.367
There's a program called
cell loader

00:34:17.367 --> 00:34:20.968
which is a container for running
these Native Client modules

00:34:20.968 --> 00:34:22.467
outside the browser.

00:34:22.467 --> 00:34:24.267
I'm gonna pass it
the debug flag,

00:34:24.267 --> 00:34:26.968
and that's because since
we're not running in a browser,

00:34:26.968 --> 00:34:29.067
I need to get the video file
off the file system.

00:34:29.067 --> 00:34:30.567
And so the debug flag

00:34:30.567 --> 00:34:32.968
is going to actually
take down the firewall

00:34:32.968 --> 00:34:34.767
that prevents
file system access

00:34:34.767 --> 00:34:36.868
and let us access
the file system directly.

00:34:36.868 --> 00:34:38.367
If you run without
the debug flag,

00:34:38.367 --> 00:34:40.167
then you wouldn't be able
to open any files

00:34:40.167 --> 00:34:42.267
or see any of the local
file system.

00:34:42.267 --> 00:34:45.868
Then I'll next specify
the Native Client module

00:34:45.868 --> 00:34:49.167
which is called
G.264release.nexe.

00:34:49.167 --> 00:34:51.267
That's what we built
up here someplace.

00:34:51.267 --> 00:34:53.367
And lastly,
the name of the video.

00:34:53.367 --> 00:34:55.434
And so we get to enjoy

00:34:55.434 --> 00:34:59.033
a 47-second ad
for Google Chrome.

00:35:03.934 --> 00:35:05.734
So a couple of things
I wanted to point out

00:35:05.734 --> 00:35:07.234
while we're watching
the squirrel run around.

00:35:07.234 --> 00:35:09.033
This just like
the office, by the way.

00:35:09.033 --> 00:35:12.033
This is a portable binary.

00:35:12.033 --> 00:35:14.434
It will run on Windows,
Mac, and Linux,

00:35:14.434 --> 00:35:18.033
and the Native Client modules
will run in NPAPI browsers

00:35:18.033 --> 00:35:22.234
Opera, Safari, Firefox,
and Chrome.

00:35:22.234 --> 00:35:24.334
It's entirely portable.

00:35:24.334 --> 00:35:25.801
We're getting pretty close
to the same performance

00:35:25.801 --> 00:35:28.534
as the original decoder.

00:35:28.534 --> 00:35:32.133
And...

00:35:32.133 --> 00:35:33.634
in addition,
in Native Client,

00:35:33.634 --> 00:35:36.334
we've gone through
a lot of effort to maintain

00:35:36.334 --> 00:35:39.033
the kind of facilities
you need

00:35:39.033 --> 00:35:41.734
to actually do
real-time applications

00:35:41.734 --> 00:35:42.934
in a reasonable way,

00:35:42.934 --> 00:35:44.734
including access
to the time stamp counter

00:35:44.734 --> 00:35:47.133
and performance
for other system calls

00:35:47.133 --> 00:35:48.934
that allow you to manage
time effectively.

00:35:48.934 --> 00:35:53.167
So that's our video decoder,

00:35:53.167 --> 00:35:54.934
and hopefully you all saw

00:35:54.934 --> 00:35:57.634
it ran pretty much
like a normal video decoder.

00:35:57.634 --> 00:35:59.734
That's the whole point, right?

00:35:59.734 --> 00:36:01.601
The next demo
we want to show you

00:36:01.601 --> 00:36:03.067
is actually an example of

00:36:03.067 --> 00:36:05.534
the same kind of interface
being used

00:36:05.534 --> 00:36:08.434
but running
in a web application.

00:36:08.434 --> 00:36:10.334
So we're gonna have
most of the user interface

00:36:10.334 --> 00:36:12.067
implemented in JavaScript,

00:36:12.067 --> 00:36:14.634
and the fast part,
the image manipulation,

00:36:14.634 --> 00:36:16.434
is gonna be implemented
in Native Code.

00:36:16.434 --> 00:36:18.501
And I'd like to introduce
Nicholas Fullagar now.

00:36:18.501 --> 00:36:20.501
He wrote this application,

00:36:20.501 --> 00:36:22.000
and he's another one of
the lead developers

00:36:22.000 --> 00:36:23.801
on the Native Client team.

00:36:23.801 --> 00:36:26.300
Nicholas Fullagar:
Thanks, Brad.

00:36:26.300 --> 00:36:27.701
Hello.

00:36:27.701 --> 00:36:32.300
So today I'm gonna demonstrate
Native Client Darkroom.

00:36:32.300 --> 00:36:35.534
And...let's see.

00:36:38.200 --> 00:36:43.834
And first we'll do a little
walk-through in Chrome

00:36:43.834 --> 00:36:45.701
and launch the application.

00:36:45.701 --> 00:36:48.934
And note, it's just like
visiting any other web page.

00:36:48.934 --> 00:36:51.367
If you have the Native Client
plugin installed,

00:36:51.367 --> 00:36:55.067
there's nothing else you need.

00:36:55.067 --> 00:36:57.367
So we're gonna open
the photo,

00:36:57.367 --> 00:37:00.234
and it's a nice little picture.

00:37:00.234 --> 00:37:03.701
And...so why...

00:37:03.701 --> 00:37:05.434
why Native Client?

00:37:05.434 --> 00:37:07.801
Why would you need
Native Client for this?

00:37:07.801 --> 00:37:10.567
Let's say, for example,

00:37:10.567 --> 00:37:14.601
this photo is something
that you've uploaded somewhere,

00:37:14.601 --> 00:37:16.267
and you want your friends

00:37:16.267 --> 00:37:18.734
to be able
to critique it for you...

00:37:18.734 --> 00:37:20.300
and they want to make
suggestions

00:37:20.300 --> 00:37:22.334
about, well,
maybe it looks better

00:37:22.334 --> 00:37:24.133
if it's in black and white.

00:37:24.133 --> 00:37:27.667
Or maybe it would look better

00:37:27.667 --> 00:37:30.701
if you add little bit more
contrast to the image.

00:37:30.701 --> 00:37:32.767
These are all
nondestructive edits,

00:37:32.767 --> 00:37:34.701
so we still have
the original image

00:37:34.701 --> 00:37:37.300
available to us.

00:37:37.300 --> 00:37:38.834
This is nice,

00:37:38.834 --> 00:37:41.167
because if you have it
sitting on the server,

00:37:41.167 --> 00:37:43.200
you don't want to start
creating

00:37:43.200 --> 00:37:46.267
multiple copies
for every edit.

00:37:46.267 --> 00:37:48.334
You really just want
to send around

00:37:48.334 --> 00:37:52.767
the values of the sliders
that people have suggested.

00:37:52.767 --> 00:37:57.601
So...these sliders
are implemented in JavaScript

00:37:57.601 --> 00:37:59.400
and HTML,

00:37:59.400 --> 00:38:04.267
and they control most of
the GUI for this application.

00:38:04.267 --> 00:38:08.534
This area here
is in Native Client.

00:38:08.534 --> 00:38:11.734
And it's running
in the native C code.

00:38:11.734 --> 00:38:15.467
And you can see
it updates pretty quickly.

00:38:15.467 --> 00:38:17.534
We can zoom in.
We can zoom out.

00:38:17.534 --> 00:38:20.601
We've got bitmap scaling
done in Native Client.

00:38:20.601 --> 00:38:23.367
We've got some
geometry operations.

00:38:23.367 --> 00:38:26.634
You can rotate the image.

00:38:26.634 --> 00:38:32.300
And these are all occurring
fairly quickly.

00:38:39.734 --> 00:38:42.234
And this is modeled after
some of the popular

00:38:42.234 --> 00:38:44.033
photo editing software

00:38:44.033 --> 00:38:47.734
that you may have
experience with.

00:38:47.734 --> 00:38:53.167
So the other important
thing to keep in mind

00:38:53.167 --> 00:38:55.534
is that this same web page

00:38:55.534 --> 00:39:00.200
will work on Linux, Mac,
and Windows

00:39:00.200 --> 00:39:01.868
as long as they have

00:39:01.868 --> 00:39:07.834
the Native Client
plugin installed.

00:39:07.834 --> 00:39:09.868
So...

00:39:09.868 --> 00:39:14.300
next, we'll look at the...

00:39:14.300 --> 00:39:18.601
source code
for a little bit.

00:39:18.601 --> 00:39:24.601
Here's the photo HTML code
and...

00:39:24.601 --> 00:39:26.400
Oh.

00:39:26.400 --> 00:39:29.400
What we're gonna
look for here is...

00:39:29.400 --> 00:39:33.033
what happens
when you update the angle.

00:39:33.033 --> 00:39:36.000
So...

00:39:36.000 --> 00:39:38.701
here we have
a little bit of HTML

00:39:38.701 --> 00:39:42.501
that sets up the slider
that the user can adjust

00:39:42.501 --> 00:39:44.100
to change the angle.

00:39:44.100 --> 00:39:46.534
And we've added
an update function,

00:39:46.534 --> 00:39:48.601
a JavaScript function

00:39:48.601 --> 00:39:53.634
that gets called every time
the slider gets changed.

00:39:55.801 --> 00:39:57.901
That calls
this JavaScript function

00:39:57.901 --> 00:40:03.300
which passes in
the value of the slider and...

00:40:03.300 --> 00:40:06.901
what we've done is we have
a Native Client object

00:40:06.901 --> 00:40:11.100
which has simple
RPC calls bound to it.

00:40:11.100 --> 00:40:14.100
And one of these calls
is Updateangle,

00:40:14.100 --> 00:40:17.701
and we pass along
the value of the slider.

00:40:17.701 --> 00:40:24.601
This now jumps into C code.

00:40:24.601 --> 00:40:26.100
And as David showed earlier,

00:40:26.100 --> 00:40:32.100
we have these SRPC methods
that we've set up, and...

00:40:32.100 --> 00:40:34.801
we've got the name
of the JavaScript function,

00:40:34.801 --> 00:40:37.501
of the JavaScript binding,

00:40:37.501 --> 00:40:40.200
and it passes one argument,
which is an integer,

00:40:40.200 --> 00:40:46.000
and it calls this C function
in our C code.

00:40:49.200 --> 00:40:52.200
So jumping to that C function,

00:40:52.200 --> 00:40:55.801
we've got the parameters
coming in,

00:40:55.801 --> 00:40:58.501
and we know
the first parameter

00:40:58.501 --> 00:41:02.167
is going to be an integer,
so we extract it here.

00:41:02.167 --> 00:41:05.767
And we convert that
slighter value to a float

00:41:05.767 --> 00:41:09.667
and then we pass it to
the darkroom class

00:41:09.667 --> 00:41:11.267
and call it setangle function.

00:41:11.267 --> 00:41:12.968
Now, it should be noted

00:41:12.968 --> 00:41:16.734
this SRPC is happening
asynchronously

00:41:16.734 --> 00:41:18.667
on a listening thread.

00:41:18.667 --> 00:41:22.868
So we're gonna...

00:41:22.868 --> 00:41:25.267
quickly just pass it over
to the darkroom class

00:41:25.267 --> 00:41:27.968
and in its
own application thread,

00:41:27.968 --> 00:41:30.067
when we're rendering the photo,

00:41:30.067 --> 00:41:33.968
we'll take into account
the new angle.

00:41:33.968 --> 00:41:36.367
Now we're gonna make
a bit of a jump,

00:41:36.367 --> 00:41:38.767
and we're gonna go straight
into the low-level code

00:41:38.767 --> 00:41:43.567
that does the pixel processing
when that image rotation occurs.

00:41:43.567 --> 00:41:47.167
This is, again, in C code.

00:41:47.167 --> 00:41:50.467
And we do the rotation
as a product of three shears.

00:41:50.467 --> 00:41:53.467
We do two horizontal shears
and a vertical shear,

00:41:53.467 --> 00:41:55.868
and that makes some of the
filtering a little bit easier

00:41:55.868 --> 00:41:58.534
because we just filter
in one dimension

00:41:58.534 --> 00:42:01.934
instead of having to filter
in two dimensions.

00:42:01.934 --> 00:42:06.133
So this is--if you've written
low-level pixel blitting code,

00:42:06.133 --> 00:42:09.734
this should look
pretty straightforward.

00:42:09.734 --> 00:42:11.234
There's quite a bit
of setup code here

00:42:11.234 --> 00:42:14.834
for calculating
what the filter value should be.

00:42:14.834 --> 00:42:16.934
And if we go further down,

00:42:16.934 --> 00:42:19.634
we get to the actual
pixel processing loop

00:42:19.634 --> 00:42:25.033
that takes the image
and does the shear.

00:42:25.033 --> 00:42:27.434
So for each pixel,

00:42:27.434 --> 00:42:29.901
we're gonna read the source,

00:42:29.901 --> 00:42:31.934
and if we go outside of range,

00:42:31.934 --> 00:42:34.067
we're gonna read
the border color.

00:42:34.067 --> 00:42:37.634
And then we're gonna apply
some SSC intrinsic code,

00:42:37.634 --> 00:42:39.734
vector instructions,

00:42:39.734 --> 00:42:44.234
to apply the filter that's
necessary to shear the pixels.

00:42:44.234 --> 00:42:52.334
Then we combine the result
and store it in the destination.

00:42:52.334 --> 00:42:56.534
So this is what's driving
the low-level...

00:42:56.534 --> 00:42:59.067
image rotation
that we looked at earlier,

00:42:59.067 --> 00:43:04.667
when I make this slider move
and we see the image rotate.

00:43:08.534 --> 00:43:13.767
So this...example
will be online soon.

00:43:13.767 --> 00:43:19.067
Keep your eye on, uh...

00:43:19.067 --> 00:43:22.734
Google Code and, uh...

00:43:22.734 --> 00:43:25.400
thanks for listening.

00:43:25.400 --> 00:43:28.400
Thanks.

00:43:28.400 --> 00:43:32.901
[applause]

00:43:32.901 --> 00:43:36.767
Chen: Okay, so...with that...

00:43:36.767 --> 00:43:38.634
we're pretty much
at the end here.

00:43:38.634 --> 00:43:41.567
Our project, like I mentioned,
has been open source

00:43:41.567 --> 00:43:42.868
since December,

00:43:42.868 --> 00:43:44.601
and we would really
be delighted

00:43:44.601 --> 00:43:47.601
if people had ideas for how
to move the system forward

00:43:47.601 --> 00:43:50.300
or had an application
that they thought would benefit

00:43:50.300 --> 00:43:53.000
from the speed of native code
in the browser.

00:43:53.000 --> 00:43:58.100
I wanted to mention at 1:00,
which is in about 15 minutes,

00:43:58.100 --> 00:43:59.601
there's a Fireside Chat

00:43:59.601 --> 00:44:01.467
where some of the product
management staff

00:44:01.467 --> 00:44:04.767
will be taking questions
about Native Client

00:44:04.767 --> 00:44:07.167
and other client technologies.

00:44:07.167 --> 00:44:08.968
And we'll be holding
office hours,

00:44:08.968 --> 00:44:11.067
the Native Client team,
at 3:00,

00:44:11.067 --> 00:44:13.501
and we'd be happy to tell you
more about these examples,

00:44:13.501 --> 00:44:15.868
other examples
in our open source release.

00:44:15.868 --> 00:44:17.367
Or if you've got
a piece of code

00:44:17.367 --> 00:44:18.968
or an idea for a system

00:44:18.968 --> 00:44:20.734
that you think
might benefit from this,

00:44:20.734 --> 00:44:23.067
we'd be there to talk
with you about it.

00:44:23.067 --> 00:44:26.167
So right now we've got plenty
of time for questions,

00:44:26.167 --> 00:44:27.634
and we'll be happy to hear about

00:44:27.634 --> 00:44:33.133
questions or ideas
about Native Client.

00:44:33.133 --> 00:44:34.767
You guys--
can you guys join me?

00:44:34.767 --> 00:44:36.267
man: In the mic, or--
Chen: Please, yeah.

00:44:36.267 --> 00:44:37.601
It's being filmed.

00:44:37.601 --> 00:44:39.567
man: You mentioned explicitly
encryption,

00:44:39.567 --> 00:44:40.734
and you said eventually.

00:44:40.734 --> 00:44:42.901
Could you elaborate?

00:44:42.901 --> 00:44:45.200
Chen: Uh...

00:44:45.200 --> 00:44:46.801
well, I guess only a little bit,

00:44:46.801 --> 00:44:48.567
since we don't have
any specific plans.

00:44:48.567 --> 00:44:50.701
But there's a high level notion
of, you know,

00:44:50.701 --> 00:44:55.567
today SSL takes an entire
web page and encrypts all of it.

00:44:55.567 --> 00:44:57.567
And there's situations
where it might be beneficial

00:44:57.567 --> 00:44:59.701
to actually
only encrypt part of it.

00:44:59.701 --> 00:45:01.701
But doing that over SSL
is messy.

00:45:01.701 --> 00:45:03.067
If, on the other hand,

00:45:03.067 --> 00:45:06.033
you had an encryption tunneled
through an HTTP request,

00:45:06.033 --> 00:45:08.133
it would give some more
flexibility.

00:45:08.133 --> 00:45:11.133
man: My specific problem is

00:45:11.133 --> 00:45:13.234
encryption and signing

00:45:13.234 --> 00:45:17.734
using X.509 certificates
under JavaScript control.

00:45:17.734 --> 00:45:20.734
And right now,
I'm forced into using IE

00:45:20.734 --> 00:45:22.834
with ActiveX controls.

00:45:22.834 --> 00:45:25.567
And I would love an alternative,
if that's on the horizon.

00:45:25.567 --> 00:45:27.033
Chen: Very interesting.

00:45:27.033 --> 00:45:30.334
Well, the one thing that I can
promise you about Native Client

00:45:30.334 --> 00:45:34.534
is if it's pure computation,
then we can deliver this

00:45:34.534 --> 00:45:37.534
almost as fast as what you get
with the native CPU.

00:45:37.534 --> 00:45:41.300
So this sounds like actually
a pretty good application.

00:45:41.300 --> 00:45:43.267
man: Thanks.

00:45:43.267 --> 00:45:45.934
Chen: Other questions.

00:45:45.934 --> 00:45:48.234
Other questions
about Native Client.

00:45:50.434 --> 00:45:54.567
man: Hi. What's the lifetime
of the web worker itself?

00:45:54.567 --> 00:45:56.601
Like how many pages
does it remain?

00:45:56.601 --> 00:45:58.033
If I move forward,

00:45:58.033 --> 00:46:01.334
how long will the web worker,
the native version operate?

00:46:01.334 --> 00:46:02.834
Chen: That's a good question,

00:46:02.834 --> 00:46:05.801
and David might know the details
of this better than me.

00:46:05.801 --> 00:46:07.934
The lifetime of a web worker.

00:46:07.934 --> 00:46:11.501
Sehr: The lifetime
of the web worker is actually,

00:46:11.501 --> 00:46:13.300
once the object
has been created,

00:46:13.300 --> 00:46:14.834
as long as there's
a reference to it,

00:46:14.834 --> 00:46:16.300
it's basically
a reference-counted object

00:46:16.300 --> 00:46:18.100
in the JavaScript
execution environment

00:46:18.100 --> 00:46:20.234
just like anything else.

00:46:20.234 --> 00:46:22.901
So as long as there's a handle
still held to the worker,

00:46:22.901 --> 00:46:25.300
that process is still alive.

00:46:25.300 --> 00:46:28.033
There's some startup
and shutdown

00:46:28.033 --> 00:46:29.834
capabilities as well,

00:46:29.834 --> 00:46:31.901
so I can send
an explicit message

00:46:31.901 --> 00:46:33.701
to shut down the web worker,
but--

00:46:33.701 --> 00:46:35.801
man: If a navigator
the page forward,

00:46:35.801 --> 00:46:37.634
and if I come back...

00:46:37.634 --> 00:46:40.000
Sehr: We're not currently
working on

00:46:40.000 --> 00:46:42.701
persistent web workers
that Matt talked about.

00:46:42.701 --> 00:46:46.000
So in that case,
you'd be sort of...

00:46:46.000 --> 00:46:48.133
you'd restart the web worker,
yes.

00:46:48.133 --> 00:46:49.634
Chen: But there is this proposal

00:46:49.634 --> 00:46:51.400
for a thing called
persistent web workers

00:46:51.400 --> 00:46:54.100
which would give
a worker thread a lifetime

00:46:54.100 --> 00:46:55.901
that's independent
of the lifetime

00:46:55.901 --> 00:46:58.234
of any particular page.

00:46:58.234 --> 00:46:59.734
And as that kind of progresses

00:46:59.734 --> 00:47:01.968
in terms of
the JavaScript version

00:47:01.968 --> 00:47:03.467
and in terms of standardization,

00:47:03.467 --> 00:47:07.400
you should expect the native
web workers to follow.

00:47:07.400 --> 00:47:10.100
man: Thanks.
Chen: Any other questions?

00:47:10.100 --> 00:47:13.567
No? Okay, well, enjoy
the rest of the Google IO

00:47:13.567 --> 00:47:15.801
and thanks very much
for listening to our talk

00:47:15.801 --> 00:47:17.868
about Native Client.

00:47:17.868 --> 00:47:18.801
[applause]

