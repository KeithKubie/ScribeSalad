WEBVTT
Kind: captions
Language: en

00:00:00.519 --> 00:00:02.310
LEAF PETERSEN: I should
mention that Bob is

00:00:02.310 --> 00:00:03.910
the co-author on these slides.

00:00:03.910 --> 00:00:06.330
So if they look good,
it's because of him.

00:00:06.330 --> 00:00:08.130
But if they start
changing behind me,

00:00:08.130 --> 00:00:10.380
I'd appreciate it if someone
would smack him, and tell

00:00:10.380 --> 00:00:12.900
him to stop.

00:00:12.900 --> 00:00:17.130
OK, so I hope he took
away from the keynotes

00:00:17.130 --> 00:00:20.610
that there are a lot of very
exciting things happening

00:00:20.610 --> 00:00:22.680
in Dart this year.

00:00:22.680 --> 00:00:24.750
There's all sorts of
exciting things happening.

00:00:24.750 --> 00:00:28.020
But the one that I personally
am most excited about because I

00:00:28.020 --> 00:00:33.570
work on the language is the
fact that Dart 2 is happening.

00:00:33.570 --> 00:00:38.990
So I want to talk today a little
bit about where we came from.

00:00:38.990 --> 00:00:40.610
How we got to this
point of Dart 3,

00:00:40.610 --> 00:00:43.020
where we came from,
where we are now.

00:00:43.020 --> 00:00:45.400
And a little bit about where
we see the language going

00:00:45.400 --> 00:00:46.410
in the future.

00:00:46.410 --> 00:00:49.190
So I want to talk about a
process of language evolution,

00:00:49.190 --> 00:00:52.100
and how we've been
managing that process

00:00:52.100 --> 00:00:55.230
over the past few years.

00:00:55.230 --> 00:00:57.110
So let's start with origins.

00:00:57.110 --> 00:01:01.280
Our origins in the
primordial slime as it were.

00:01:01.280 --> 00:01:04.550
So the original vision
for Dart, I think

00:01:04.550 --> 00:01:06.530
was a very strong
and very clear one.

00:01:06.530 --> 00:01:09.740
So sometime around
2011, there was

00:01:09.740 --> 00:01:15.320
this idea of making a
new browser language.

00:01:15.320 --> 00:01:16.910
A new language, a
better language,

00:01:16.910 --> 00:01:20.910
for writing large
web applications.

00:01:20.910 --> 00:01:22.690
So this was the
vision of Dart, and I

00:01:22.690 --> 00:01:24.690
think it was a very strong
one in a lot of ways.

00:01:24.690 --> 00:01:27.500
So the idea was to have
a mostly dynamic language

00:01:27.500 --> 00:01:31.700
layer over the top of that,
sort of a Lint like type system

00:01:31.700 --> 00:01:34.790
that also provided you
some runtime type checking,

00:01:34.790 --> 00:01:37.490
but still allowed you
to be basically dynamic

00:01:37.490 --> 00:01:39.320
at the heart of it.

00:01:39.320 --> 00:01:42.410
So a mostly dynamic language
running in the browser,

00:01:42.410 --> 00:01:45.350
and running essentially
over a just in time compiled

00:01:45.350 --> 00:01:45.930
environment.

00:01:45.930 --> 00:01:48.440
So one of the key
ideas behind Dart,

00:01:48.440 --> 00:01:49.982
or one of the key
properties of it

00:01:49.982 --> 00:01:51.440
was that it was a
language that was

00:01:51.440 --> 00:01:54.020
designed to be great on a JIT.

00:01:54.020 --> 00:01:56.570
Without too much concern
about making sure

00:01:56.570 --> 00:02:01.890
that the language was easy
to compile ahead of time.

00:02:01.890 --> 00:02:04.010
So this is a very
strong vision I think.

00:02:04.010 --> 00:02:05.810
There was a lot to
like about this,

00:02:05.810 --> 00:02:08.090
and we had a lot of success
in getting some very large

00:02:08.090 --> 00:02:08.881
customers on there.

00:02:08.881 --> 00:02:11.420
So you already heard and
saw an example of Edwards.

00:02:11.420 --> 00:02:16.220
People writing very, very large,
very powerful applications,

00:02:16.220 --> 00:02:18.410
and shipping them on the
web being very productive

00:02:18.410 --> 00:02:21.440
in the language getting very
good performance out the end.

00:02:21.440 --> 00:02:25.310
And basically, being very
happy customers for us.

00:02:25.310 --> 00:02:27.770
But things started to
change over the time

00:02:27.770 --> 00:02:29.120
that we were developing Dart.

00:02:29.120 --> 00:02:33.500
So I think there was a very
large shift in the model of how

00:02:33.500 --> 00:02:35.840
we were going to be
delivering applications

00:02:35.840 --> 00:02:39.890
on mobile as mobile became
more and more important.

00:02:39.890 --> 00:02:43.010
And a decision was made
not to put native to Dart

00:02:43.010 --> 00:02:46.730
support in Chrome, so
both of those facts

00:02:46.730 --> 00:02:48.920
changed the
environment for Dart.

00:02:48.920 --> 00:02:53.300
So from a language which could
rely on always running on JITed

00:02:53.300 --> 00:02:55.460
platform, we were
moving to a language

00:02:55.460 --> 00:02:57.170
where all of our
important customers

00:02:57.170 --> 00:03:00.710
were shipping on ahead of
time complied platforms.

00:03:00.710 --> 00:03:04.370
So our web platform needed to
rely on a compile to JavaScript

00:03:04.370 --> 00:03:07.130
story in order to
ship their code.

00:03:07.130 --> 00:03:09.530
If we were going
to compile to iOS,

00:03:09.530 --> 00:03:12.200
we needed to be able
to do good, fast,

00:03:12.200 --> 00:03:13.850
ahead of time compilation.

00:03:13.850 --> 00:03:16.340
So we could no longer
assume that we were always

00:03:16.340 --> 00:03:18.410
going to be running
on a JIT where

00:03:18.410 --> 00:03:20.600
lots of interesting
things are possible,

00:03:20.600 --> 00:03:24.140
so there was a sense that
maybe the world was changing.

00:03:24.140 --> 00:03:26.610
And that maybe we needed
to evolve with it,

00:03:26.610 --> 00:03:28.160
and we needed to
think about how we

00:03:28.160 --> 00:03:30.050
needed to change going forward.

00:03:30.050 --> 00:03:36.556
[INAUDIBLE] today about what
that process looked like.

00:03:36.556 --> 00:03:37.930
So one of the
experiments that we

00:03:37.930 --> 00:03:41.380
did as we were doing
this exploration

00:03:41.380 --> 00:03:43.660
was an idea we
called strong mode.

00:03:43.660 --> 00:03:47.920
So the idea was can we take this
Lint like type system that's

00:03:47.920 --> 00:03:50.170
been layered over the
sort of underlying

00:03:50.170 --> 00:03:52.390
dynamic language of
Dart, and tighten it

00:03:52.390 --> 00:03:53.450
up just a little bit.

00:03:53.450 --> 00:03:56.170
Just enough to get a sort
of a soundness property.

00:03:56.170 --> 00:03:59.760
To get the property that
you as a programmer,

00:03:59.760 --> 00:04:02.530
and I, as a tool
developer, could both rely

00:04:02.530 --> 00:04:08.200
on the contracts specified by
types to generate better code,

00:04:08.200 --> 00:04:11.470
or to be more productive
if I'm a developer.

00:04:11.470 --> 00:04:14.590
So this notion that we could
use a stronger type system

00:04:14.590 --> 00:04:18.100
to get a good modular
compiler generating good

00:04:18.100 --> 00:04:21.339
readable JavaScript
very, very quickly.

00:04:21.339 --> 00:04:23.800
And at the same time,
maybe provide more value

00:04:23.800 --> 00:04:28.300
to our developers who are
shipping very large apps

00:04:28.300 --> 00:04:30.480
So we set out to
do this experiment,

00:04:30.480 --> 00:04:33.290
and it was, I think, a
very interesting one.

00:04:33.290 --> 00:04:34.900
So we went off,
and we said, what

00:04:34.900 --> 00:04:36.661
do we need to
build a modern type

00:04:36.661 --> 00:04:37.910
system that will support this?

00:04:37.910 --> 00:04:40.400
So there wasn't all
that much we had to add,

00:04:40.400 --> 00:04:41.980
so we built in some
type inference.

00:04:41.980 --> 00:04:44.330
We changed the subtyping
rules a little bit,

00:04:44.330 --> 00:04:45.976
changed the override
restrictions.

00:04:45.976 --> 00:04:47.350
Basically, did
the things that we

00:04:47.350 --> 00:04:49.990
needed to do to make sure that
you couldn't cheat the type

00:04:49.990 --> 00:04:54.310
system anymore just enough.

00:04:54.310 --> 00:04:56.110
We built this prototype,
and this, I think,

00:04:56.110 --> 00:04:58.670
is the most interesting part
of the whole process for me,

00:04:58.670 --> 00:04:59.800
and the exciting part.

00:04:59.800 --> 00:05:02.230
And I think one of the reasons
that this experiment was

00:05:02.230 --> 00:05:05.450
successful is that once we built
the prototype, we didn't say,

00:05:05.450 --> 00:05:06.880
OK, we're done now.

00:05:06.880 --> 00:05:08.920
We didn't say we've
built this thing.

00:05:08.920 --> 00:05:11.470
Here it is.

00:05:11.470 --> 00:05:13.480
Take it.

00:05:13.480 --> 00:05:16.900
We had millions of lines of
existing Dart code out there,

00:05:16.900 --> 00:05:19.120
and we just started throwing
this at our prototype.

00:05:19.120 --> 00:05:20.590
So there was this
very data driven

00:05:20.590 --> 00:05:24.070
process of taking feedback
from the actual code

00:05:24.070 --> 00:05:27.010
that people had written in
Dart when it was a mostly

00:05:27.010 --> 00:05:29.440
dynamic language with a sort
of a Lint like type system,

00:05:29.440 --> 00:05:32.680
and saying, what do we need
to do in the type system

00:05:32.680 --> 00:05:35.800
to support the kind of code
that people actually wrote?

00:05:35.800 --> 00:05:38.260
And there were a lot of changes
we made to the type system

00:05:38.260 --> 00:05:39.259
over the course of this.

00:05:39.259 --> 00:05:41.200
The first iteration
of our type system,

00:05:41.200 --> 00:05:43.270
we tried out using
invariant generics,

00:05:43.270 --> 00:05:45.520
and we found there was just
too much code out there

00:05:45.520 --> 00:05:47.140
that was using covariance.

00:05:47.140 --> 00:05:48.310
And so we said, all right.

00:05:48.310 --> 00:05:49.360
We went back to
the drawing board,

00:05:49.360 --> 00:05:51.910
and figured out how we could
support covariant generics

00:05:51.910 --> 00:05:53.150
going forward.

00:05:53.150 --> 00:05:56.230
So this iterative process
of figuring out what worked

00:05:56.230 --> 00:05:59.980
and what didn't work, and
supporting existing Dart code

00:05:59.980 --> 00:06:02.530
gave us insights into
what a type system

00:06:02.530 --> 00:06:06.120
should look like for Dart.

00:06:06.120 --> 00:06:06.620
So

00:06:06.620 --> 00:06:07.670
I think there is
a lot of evidence.

00:06:07.670 --> 00:06:09.510
There was a lot of evidence
that this was successful.

00:06:09.510 --> 00:06:12.290
So certainly from a technical
standpoint, the original goals

00:06:12.290 --> 00:06:17.330
that we set out to accomplish,
we showed they were feasible.

00:06:17.330 --> 00:06:20.300
So we were able to achieve
a very fast modular compile

00:06:20.300 --> 00:06:22.740
and get a very good
dev refresh cycle.

00:06:22.740 --> 00:06:25.640
So we were actually able to
improve the refresh cycle

00:06:25.640 --> 00:06:28.310
for our web customers,
even though we

00:06:28.310 --> 00:06:31.250
were moving to an
ahead of time compiled

00:06:31.250 --> 00:06:33.110
scenario, which is
very impressive.

00:06:33.110 --> 00:06:35.690
And at the same time, we were
able to give better error

00:06:35.690 --> 00:06:40.550
checking through type
inference, and through sounder

00:06:40.550 --> 00:06:41.900
checking on the types.

00:06:41.900 --> 00:06:44.630
And so we had a lot of feedback
from people that they really

00:06:44.630 --> 00:06:47.000
liked using this
new type system.

00:06:47.000 --> 00:06:49.400
That it wasn't a huge burden.

00:06:49.400 --> 00:06:52.170
That it was actually a benefit.

00:06:52.170 --> 00:06:54.120
Interestingly,
this was true even

00:06:54.120 --> 00:06:56.970
for people who were not getting
the benefits of a new tooling

00:06:56.970 --> 00:06:59.760
that we were building
based on this type system.

00:06:59.760 --> 00:07:02.580
Flutter was one of our very
early adopters on this,

00:07:02.580 --> 00:07:05.880
and they were simply using
strong mode because they

00:07:05.880 --> 00:07:07.170
liked the better checking.

00:07:07.170 --> 00:07:10.277
So this was, I think, a
very good indicator to us

00:07:10.277 --> 00:07:11.610
that we were on the right track.

00:07:11.610 --> 00:07:14.150
We were able to get better
ahead of time compilation.

00:07:14.150 --> 00:07:15.870
We believed that
this would carry over

00:07:15.870 --> 00:07:17.960
to mobile to the
native, and certainly we

00:07:17.960 --> 00:07:19.630
were seeing this on the web.

00:07:19.630 --> 00:07:22.740
So we had this evidence that we
were able to take a language,

00:07:22.740 --> 00:07:25.800
and make it great both for
ahead of time compilation

00:07:25.800 --> 00:07:27.600
and for just in
time compilation.

00:07:27.600 --> 00:07:31.260
Get the best of both worlds,
and get all the benefits

00:07:31.260 --> 00:07:33.750
of a sound type system
without taking away

00:07:33.750 --> 00:07:37.330
all the fun things about Dart.

00:07:37.330 --> 00:07:39.370
So we felt this was
really a great story,

00:07:39.370 --> 00:07:41.730
and the decision was
made to adopt this

00:07:41.730 --> 00:07:45.890
as the core of Dart 2.

00:07:45.890 --> 00:07:47.750
So that's great.

00:07:47.750 --> 00:07:51.140
I think if you look at Dart
2 right now, the biggest

00:07:51.140 --> 00:07:53.707
change that is coming,
and I think most of you

00:07:53.707 --> 00:07:55.165
have been working
with strong mode,

00:07:55.165 --> 00:07:57.560
so you're pretty familiar
with what the core of it is.

00:07:57.560 --> 00:07:59.240
The biggest change
that is coming

00:07:59.240 --> 00:08:02.730
is this strong type system,
this sound type system.

00:08:02.730 --> 00:08:04.490
But there's a lot
of things that go

00:08:04.490 --> 00:08:07.370
into taking a
prototype like that,

00:08:07.370 --> 00:08:11.090
and making it actual real,
and making it usable.

00:08:11.090 --> 00:08:12.590
So there are changes
to the tooling.

00:08:12.590 --> 00:08:13.940
I think people are going
to talk about there's

00:08:13.940 --> 00:08:15.439
a huge amount of
changes that needed

00:08:15.439 --> 00:08:17.390
to happen in the ecosystem.

00:08:17.390 --> 00:08:20.240
So many of you out there have
been contributing so much to us

00:08:20.240 --> 00:08:22.040
as we've been
migrating this forward.

00:08:22.040 --> 00:08:24.180
Thank you so much.

00:08:24.180 --> 00:08:27.470
And at the same time,
there are a lot of changes

00:08:27.470 --> 00:08:29.450
around the language
and the libraries

00:08:29.450 --> 00:08:31.250
that we needed to
make in order to make

00:08:31.250 --> 00:08:33.650
your experience with
working with this sound type

00:08:33.650 --> 00:08:34.960
system great.

00:08:34.960 --> 00:08:36.380
And so I want to
talk a little bit

00:08:36.380 --> 00:08:38.030
about what that looked like.

00:08:38.030 --> 00:08:40.136
What you should expect
to see in Dart 2

00:08:40.136 --> 00:08:41.510
from the language
and the library

00:08:41.510 --> 00:08:43.826
as it's going to make working
with these things better.

00:08:43.826 --> 00:08:45.450
And how you can take
advantage of them.

00:08:49.340 --> 00:08:52.490
So when I think
about the changes

00:08:52.490 --> 00:08:55.070
that we made to the
language and the libraries

00:08:55.070 --> 00:08:57.740
around the edges of
the sound type system,

00:08:57.740 --> 00:09:00.770
I think there are two
key things we were trying

00:09:00.770 --> 00:09:02.570
to enable for our developers.

00:09:02.570 --> 00:09:05.630
And the first is we wanted
to make it easy for you

00:09:05.630 --> 00:09:07.280
to stay statically typed.

00:09:07.280 --> 00:09:09.200
So any place where
you were writing code,

00:09:09.200 --> 00:09:11.900
and you had something which
was nicely statically typed,

00:09:11.900 --> 00:09:14.150
and you wanted to
do something to it.

00:09:14.150 --> 00:09:16.310
And you were having trouble
preserving the types

00:09:16.310 --> 00:09:18.500
across that operation,
that was a sign

00:09:18.500 --> 00:09:20.794
that we needed to add
something to the language.

00:09:20.794 --> 00:09:22.460
And the second is we
wanted to make sure

00:09:22.460 --> 00:09:26.120
that you were able to write
APIs, which worked great

00:09:26.120 --> 00:09:27.150
with type inference.

00:09:27.150 --> 00:09:29.630
So that if you're
writing a library,

00:09:29.630 --> 00:09:33.034
the developers who use your
library, your consumers,

00:09:33.034 --> 00:09:34.700
don't need to think
as much about types.

00:09:34.700 --> 00:09:37.250
They can continue to write
their code just as they always

00:09:37.250 --> 00:09:39.470
have been, and they get
a really nice experience

00:09:39.470 --> 00:09:41.810
while simultaneously
getting all the benefits

00:09:41.810 --> 00:09:45.140
of the static typing.

00:09:45.140 --> 00:09:47.660
So I want to give a couple
of concrete examples of this

00:09:47.660 --> 00:09:52.850
to give an idea of how this
played out in the language.

00:09:52.850 --> 00:09:55.800
So this is kind of a core
piece of the Dart API.

00:09:55.800 --> 00:10:01.010
This is a Dart 1 API for
the map function on list,

00:10:01.010 --> 00:10:04.070
iterable as well.

00:10:04.070 --> 00:10:08.450
So in Dart 1, there's this
map method on the list type.

00:10:08.450 --> 00:10:11.180
And the key thing I want
you to notice about this

00:10:11.180 --> 00:10:13.370
is that the return type of
the callback that you're

00:10:13.370 --> 00:10:17.270
mapping over the elements of
this list is marked as dynamic.

00:10:17.270 --> 00:10:19.010
So there's no
information about what

00:10:19.010 --> 00:10:20.630
the type of things
coming out of it

00:10:20.630 --> 00:10:26.210
are, and the type of the
iterable that you get out also

00:10:26.210 --> 00:10:29.330
has no information about what
the type of its elements are.

00:10:29.330 --> 00:10:31.950
So it's an iterable of dynamic.

00:10:31.950 --> 00:10:34.370
A consequence of
this is the code

00:10:34.370 --> 00:10:38.780
like what I have written on the
bottom there is not going to be

00:10:38.780 --> 00:10:41.930
detected statically in Dart 1.

00:10:41.930 --> 00:10:45.980
So you can take a list of
strings, map something over it

00:10:45.980 --> 00:10:47.852
that tries to add one to it.

00:10:47.852 --> 00:10:49.310
There is nothing
in the system that

00:10:49.310 --> 00:10:52.160
will tell you that that's a
bad idea until it blows up

00:10:52.160 --> 00:10:54.090
at run time.

00:10:54.090 --> 00:10:57.270
So we can fix this fairly
easily without changing anything

00:10:57.270 --> 00:11:00.960
core in the language other
than the type system in Dart 2

00:11:00.960 --> 00:11:02.230
by adding some type inference.

00:11:02.230 --> 00:11:03.840
So in Dart 2 we
added type inference,

00:11:03.840 --> 00:11:06.600
so that variable,
x, in the callback

00:11:06.600 --> 00:11:09.360
no longer is
interpreted as dynamic.

00:11:09.360 --> 00:11:11.430
It is now inferred
to have type string,

00:11:11.430 --> 00:11:15.010
and we're able to give you an
error here telling you, hey,

00:11:15.010 --> 00:11:16.117
this is not a good idea.

00:11:16.117 --> 00:11:17.700
You don't want to
add one to a string,

00:11:17.700 --> 00:11:19.720
and you can fix your code.

00:11:19.720 --> 00:11:22.080
The problem is this
is still an error.

00:11:22.080 --> 00:11:24.750
This is still bad
code in Dart 2.

00:11:24.750 --> 00:11:26.940
And the reason
is, as I mentioned

00:11:26.940 --> 00:11:31.260
before, this map function, this
map method doesn't give you

00:11:31.260 --> 00:11:34.470
enough information about how
types flow from the inputs

00:11:34.470 --> 00:11:36.040
to the outputs.

00:11:36.040 --> 00:11:39.150
Right, so the return type
of this whole operation

00:11:39.150 --> 00:11:41.190
is an iterable of dynamic.

00:11:41.190 --> 00:11:43.170
And in a sound type
system, we can't

00:11:43.170 --> 00:11:45.017
allow you to put an
iterable of dynamic

00:11:45.017 --> 00:11:46.350
in an iterable of string, right?

00:11:46.350 --> 00:11:49.200
Because, in fact, here,
this has ints in it.

00:11:49.200 --> 00:11:50.992
And I can't let
you put ints where

00:11:50.992 --> 00:11:53.450
strings are expected if I want
to have a sound type system.

00:11:55.980 --> 00:11:59.640
The solution to this then
was to change the language.

00:11:59.640 --> 00:12:02.940
So you are having trouble as
a programmer preserving types

00:12:02.940 --> 00:12:04.999
across an API boundary.

00:12:04.999 --> 00:12:07.540
That means there's something in
the language that is missing,

00:12:07.540 --> 00:12:10.960
so we added very early on
in the strong mode process.

00:12:10.960 --> 00:12:13.440
We realized we needed to
add generic methods to Dart

00:12:13.440 --> 00:12:16.170
because it was the only way
that we could preserve types

00:12:16.170 --> 00:12:17.970
across these API boundaries.

00:12:17.970 --> 00:12:22.290
So if you add this generic
type parameter to map,

00:12:22.290 --> 00:12:24.180
now you are able
to express the fact

00:12:24.180 --> 00:12:26.250
that the return
type of the callback

00:12:26.250 --> 00:12:29.160
flows through and out
to the result type.

00:12:29.160 --> 00:12:33.090
And tells you exactly what
the return type of the map

00:12:33.090 --> 00:12:33.680
should be.

00:12:33.680 --> 00:12:36.270
And so now you're able to
write your code in a way that

00:12:36.270 --> 00:12:39.500
works in a sound type system.

00:12:39.500 --> 00:12:43.010
Even better though, you
don't have to actually write

00:12:43.010 --> 00:12:44.700
all of those types.

00:12:44.700 --> 00:12:46.770
So this gets to the second part.

00:12:46.770 --> 00:12:49.610
So this addition
of generic methods

00:12:49.610 --> 00:12:52.030
is great because it allows
you to preserve the types.

00:12:52.030 --> 00:12:53.900
But it's also great
because it allows you

00:12:53.900 --> 00:12:56.060
as a library designer,
or in this case, us,

00:12:56.060 --> 00:12:58.610
as core library
designers, to express

00:12:58.610 --> 00:13:02.930
in the type of the
method in the API

00:13:02.930 --> 00:13:05.810
exactly how inference
should work with this.

00:13:05.810 --> 00:13:08.390
And therefore, you
are able to leave.

00:13:08.390 --> 00:13:10.850
You, the developer
at the end, is

00:13:10.850 --> 00:13:13.640
able to leave all of the
types off of their code

00:13:13.640 --> 00:13:16.167
just as if they were working
in a dynamic language here.

00:13:16.167 --> 00:13:17.750
And we we're able
to fill in the types

00:13:17.750 --> 00:13:20.030
for them using
this generic method

00:13:20.030 --> 00:13:23.190
schema that was laid out there.

00:13:23.190 --> 00:13:26.300
So these two ideas of
preserving the type information,

00:13:26.300 --> 00:13:28.910
and making the API
friendly to inference

00:13:28.910 --> 00:13:31.850
play out very nicely here
once you add generic methods

00:13:31.850 --> 00:13:33.030
to the language.

00:13:33.030 --> 00:13:35.450
So this is a big feature
that we're adding to Dart 2.

00:13:35.450 --> 00:13:39.290
And part of what we're doing is
walking through the libraries,

00:13:39.290 --> 00:13:42.680
and looking for where do
these things need to happen.

00:13:42.680 --> 00:13:49.040
So another great example of this
process is in the async APIs.

00:13:49.040 --> 00:13:52.040
This at first looks extremely
similar to the example

00:13:52.040 --> 00:13:53.330
that I just gave, right?

00:13:53.330 --> 00:13:57.110
So here we have the
.then method on future,

00:13:57.110 --> 00:13:59.630
which is basically
a map over futures.

00:13:59.630 --> 00:14:03.440
And in Dart 1 as before, the
callback that you passed in

00:14:03.440 --> 00:14:05.060
was typed to return dynamic.

00:14:05.060 --> 00:14:07.130
And it returned a future
of some unknown type,

00:14:07.130 --> 00:14:10.910
and so you had the same problem
with getting the information

00:14:10.910 --> 00:14:12.060
out the other side.

00:14:12.060 --> 00:14:13.280
So you say, OK, great.

00:14:13.280 --> 00:14:14.690
We have a solution to this.

00:14:14.690 --> 00:14:18.260
We make this method generic,
and life is great, right?

00:14:18.260 --> 00:14:20.600
Generic methods for the win.

00:14:20.600 --> 00:14:23.240
And it does, in fact, solve
this particular problem,

00:14:23.240 --> 00:14:23.930
so it's great.

00:14:23.930 --> 00:14:26.220
Generic methods
got us a long way.

00:14:26.220 --> 00:14:29.270
And so when we first were
going through this process

00:14:29.270 --> 00:14:31.220
of taking all of
this code out there,

00:14:31.220 --> 00:14:34.322
and throwing it
at our prototype,

00:14:34.322 --> 00:14:35.530
we had added generic methods.

00:14:35.530 --> 00:14:36.113
We said great.

00:14:36.113 --> 00:14:39.320
We've solved the problem
right, and we very quickly

00:14:39.320 --> 00:14:42.500
started discovering that, no, we
hadn't solved all the problems.

00:14:42.500 --> 00:14:44.360
And async in
particular was a place

00:14:44.360 --> 00:14:48.050
where we encountered
something we had not expected.

00:14:48.050 --> 00:14:49.850
And something that
we would not have

00:14:49.850 --> 00:14:52.670
known about that we would not
have known to do if we had not

00:14:52.670 --> 00:14:55.490
gone through this data
driven process of trying

00:14:55.490 --> 00:14:58.130
to look at lots and
lots of real code,

00:14:58.130 --> 00:14:59.930
and understand
what it was doing.

00:14:59.930 --> 00:15:00.720
So why is that?

00:15:00.720 --> 00:15:05.060
Well, the reason is that there
is this very nice pattern

00:15:05.060 --> 00:15:08.240
that API designers
were using in Dart.

00:15:08.240 --> 00:15:12.080
So they were basically
taking this idea of dynamic,

00:15:12.080 --> 00:15:14.750
and using dynamic as a
kind of a union type.

00:15:14.750 --> 00:15:16.640
So they were saying
in async code,

00:15:16.640 --> 00:15:19.190
I often want to be able
to use the same code

00:15:19.190 --> 00:15:21.600
with async and nonasnyc things.

00:15:21.600 --> 00:15:26.240
So before I was passing here a
synchronous function to .then,

00:15:26.240 --> 00:15:28.040
so it's something that
returns an integer.

00:15:28.040 --> 00:15:30.170
But I may want to
use in the same place

00:15:30.170 --> 00:15:32.240
a callback which is
async, and therefore,

00:15:32.240 --> 00:15:33.827
returns a future event.

00:15:33.827 --> 00:15:35.660
Well, that doesn't work
anymore here, right?

00:15:35.660 --> 00:15:38.270
Because this generic
method type that I gave

00:15:38.270 --> 00:15:40.174
says whatever the
callback type is,

00:15:40.174 --> 00:15:41.840
I'm supposed to return
a future of that.

00:15:41.840 --> 00:15:43.756
So this is going to be
a future, future event.

00:15:43.756 --> 00:15:46.370
That doesn't match up.

00:15:46.370 --> 00:15:48.460
So when we looked
at real code, when

00:15:48.460 --> 00:15:50.210
we went out and saw
what people are doing,

00:15:50.210 --> 00:15:52.700
we saw something very
reasonable that real developers

00:15:52.700 --> 00:15:56.187
were using that made a great
API in which we couldn't type.

00:15:56.187 --> 00:15:57.770
And so that was a
signal to us that we

00:15:57.770 --> 00:15:59.353
needed to go back
to the drawing board

00:15:59.353 --> 00:16:01.530
and add something
to the language.

00:16:01.530 --> 00:16:04.340
So this was something that has
recently added to the language

00:16:04.340 --> 00:16:06.260
to make async code.

00:16:06.260 --> 00:16:10.040
Which is a very pervasive
pattern of code in Dart, great.

00:16:10.040 --> 00:16:14.390
So FutureOr is a new type in
Dart which has been added,

00:16:14.390 --> 00:16:17.280
which expresses this
simple union type.

00:16:17.280 --> 00:16:19.130
So if you have a
FutureOr of cat,

00:16:19.130 --> 00:16:20.750
that means either
you have a cat,

00:16:20.750 --> 00:16:22.340
or you have a future of cat.

00:16:22.340 --> 00:16:24.980
You can ask, you know so
Dart allows you to check.

00:16:24.980 --> 00:16:27.390
Am I a future, or am I a cat?

00:16:27.390 --> 00:16:30.110
So you can tell at runtime,
so the API inside of it

00:16:30.110 --> 00:16:31.580
can figure it out.

00:16:31.580 --> 00:16:33.680
And you can write
all of your APIs

00:16:33.680 --> 00:16:36.590
to consume either one to be
convenient for your developers.

00:16:36.590 --> 00:16:39.100
So now the right type
for future .then,

00:16:39.100 --> 00:16:41.660
the one that actually captures
the usage patterns of real

00:16:41.660 --> 00:16:45.374
programs is to say that the
callback doesn't return s.

00:16:45.374 --> 00:16:46.790
And it doesn't
return future of s.

00:16:46.790 --> 00:16:48.140
It returns future, or s.

00:16:48.140 --> 00:16:50.630
It's allowed to
return either one,

00:16:50.630 --> 00:16:52.730
and now you can
use it very freely.

00:16:52.730 --> 00:16:55.790
I can call future .then
with a synchronous function.

00:16:55.790 --> 00:16:58.370
I can call future .then with
an asynchronous function.

00:16:58.370 --> 00:16:59.360
It all works.

00:16:59.360 --> 00:17:01.910
The types get passed
through, and inference

00:17:01.910 --> 00:17:04.160
works out just great for
you because, again, we've

00:17:04.160 --> 00:17:06.950
incorporated into
the type system

00:17:06.950 --> 00:17:11.470
an actual encoding of
the developers intent.

00:17:11.470 --> 00:17:14.460
So this is basically
the theme, I think,

00:17:14.460 --> 00:17:16.380
of about the past
years work that we've

00:17:16.380 --> 00:17:21.000
spent on the language
of around the boundaries

00:17:21.000 --> 00:17:22.180
of the sound type system.

00:17:22.180 --> 00:17:24.810
So we added generic
methods very early on.

00:17:24.810 --> 00:17:27.310
We added the FutureOr type
to capture these patterns

00:17:27.310 --> 00:17:29.040
and asynchronous code.

00:17:29.040 --> 00:17:32.160
We've added the ability to
use void as a first class type

00:17:32.160 --> 00:17:33.000
as a type argument.

00:17:33.000 --> 00:17:35.760
So that when you're
working with code

00:17:35.760 --> 00:17:37.260
that return, and
say future of void,

00:17:37.260 --> 00:17:39.900
you can continue to chain
things through in a nice way.

00:17:39.900 --> 00:17:42.010
An inference can just
propagate that void,

00:17:42.010 --> 00:17:45.390
and we can catch places where
you might be using a void value

00:17:45.390 --> 00:17:48.020
unintentionally.

00:17:48.020 --> 00:17:50.990
Another sort of empirical
thing we discovered

00:17:50.990 --> 00:17:53.302
was that a lot of places
where people were writing

00:17:53.302 --> 00:17:55.760
dynamic code, it was because
it was just too much of a pain

00:17:55.760 --> 00:17:57.410
to write say a function type.

00:17:57.410 --> 00:18:00.560
So you can always write a
typedef for a function type

00:18:00.560 --> 00:18:01.200
somewhere else.

00:18:01.200 --> 00:18:02.908
But if you just have
some local variable,

00:18:02.908 --> 00:18:05.121
and you're trying to
put a function in it,

00:18:05.121 --> 00:18:06.620
it's kind of a
nuisance to introduce

00:18:06.620 --> 00:18:08.240
this typedef at the top level.

00:18:08.240 --> 00:18:12.560
So adding inline function types
with something that helped us

00:18:12.560 --> 00:18:14.360
encourage people to
make it easy for them

00:18:14.360 --> 00:18:15.980
to write strongly typed code.

00:18:15.980 --> 00:18:17.420
We also added null as a bottom.

00:18:17.420 --> 00:18:19.280
This is a fairly
esoteric feature,

00:18:19.280 --> 00:18:22.340
but there are a few places where
this enables some patterns that

00:18:22.340 --> 00:18:24.650
were hard to write otherwise.

00:18:24.650 --> 00:18:28.910
So the story here is basically
about taking these new features

00:18:28.910 --> 00:18:34.370
that are designed to make
working with strong mode great,

00:18:34.370 --> 00:18:37.700
and incorporating them into
the libraries in a way that

00:18:37.700 --> 00:18:42.760
makes the developer
experience great to work with.

00:18:42.760 --> 00:18:44.782
So that's all
around the language.

00:18:44.782 --> 00:18:46.990
I want to talk a little bit
about some of the changes

00:18:46.990 --> 00:18:49.570
we're making to the
libraries for strong mode to,

00:18:49.570 --> 00:18:51.710
and why we're doing
what we're doing.

00:18:51.710 --> 00:18:56.950
So this is an
example of something

00:18:56.950 --> 00:18:59.390
that you were able
to do in Dart 1 that

00:18:59.390 --> 00:19:01.480
was harder to do in Dart 2.

00:19:01.480 --> 00:19:04.630
So I mentioned before
that Dart 1 allowed

00:19:04.630 --> 00:19:06.910
you to use a list of dynamic.

00:19:06.910 --> 00:19:09.979
Dynamic was kind of a magic
get out of jail card, right?

00:19:09.979 --> 00:19:11.770
So you could use a list
of dynamic anywhere

00:19:11.770 --> 00:19:13.600
you would use anything else.

00:19:13.600 --> 00:19:16.660
So you could take this list
of integers and strings,

00:19:16.660 --> 00:19:18.777
and masquerade it as
a list of integers.

00:19:18.777 --> 00:19:20.360
The type system would
let you do that,

00:19:20.360 --> 00:19:23.020
and it only if you actually
kind of hit one of these strings

00:19:23.020 --> 00:19:24.940
unexpectedly that
things would go wrong.

00:19:24.940 --> 00:19:26.380
We can't let you
do that in Dart 2

00:19:26.380 --> 00:19:29.650
because we want our tools to
be able to rely on the fact

00:19:29.650 --> 00:19:31.840
that if you say it's
a list event, it is.

00:19:31.840 --> 00:19:34.360
So you don't have to
use the types in Dart 2.

00:19:34.360 --> 00:19:39.550
But if you use them, you
can't lie about them.

00:19:39.550 --> 00:19:42.340
So for the most part, that
works out pretty well.

00:19:42.340 --> 00:19:45.580
But we did run into places
where the libraries didn't

00:19:45.580 --> 00:19:47.410
have the functionality
that they needed

00:19:47.410 --> 00:19:49.300
to allow you to write
the code in the way

00:19:49.300 --> 00:19:51.374
that we thought you should
be able to write it,

00:19:51.374 --> 00:19:52.790
and this is a very
simple example.

00:19:52.790 --> 00:19:54.706
So suppose I have
that mix list again,

00:19:54.706 --> 00:19:56.080
and now I want to
filter it down.

00:19:56.080 --> 00:19:58.288
I want to filter out everything
which isn't in an int

00:19:58.288 --> 00:20:00.910
because I notice that there
is, in fact, a string in there

00:20:00.910 --> 00:20:02.500
to get out an iterable event.

00:20:02.500 --> 00:20:05.360
Well, the first thing I can do
is I can map a dot .where over

00:20:05.360 --> 00:20:05.860
that.

00:20:05.860 --> 00:20:08.560
This maps predicate,
and filters out

00:20:08.560 --> 00:20:11.080
everything which doesn't
satisfy the predicate.

00:20:11.080 --> 00:20:13.680
That's great, but unfortunately
the return type of .where is

00:20:13.680 --> 00:20:14.805
still iterable of dynamics.

00:20:14.805 --> 00:20:17.920
So we're back in the situation
of the static type system

00:20:17.920 --> 00:20:22.310
not being able to tell what it
is that you want to pass in.

00:20:22.310 --> 00:20:25.210
So the fix, the
workaround, was to map

00:20:25.210 --> 00:20:27.827
over it again
actually witnessing

00:20:27.827 --> 00:20:29.410
the fact that you
filtered things out.

00:20:29.410 --> 00:20:30.660
But this is really unpleasant.

00:20:30.660 --> 00:20:32.920
This is a workaround,
so this is a clear sign

00:20:32.920 --> 00:20:35.200
that there was something
missing in the APIs.

00:20:35.200 --> 00:20:37.060
And so we've been
fixing that, so we've

00:20:37.060 --> 00:20:40.180
added to iterable a
whereType method, which

00:20:40.180 --> 00:20:44.230
will do the filter and return
a new thing of the right type.

00:20:44.230 --> 00:20:46.180
It filters based on
type, and so this

00:20:46.180 --> 00:20:49.450
allows you to write this
relatively common pattern very

00:20:49.450 --> 00:20:51.760
cleanly and very concisely.

00:20:51.760 --> 00:20:54.310
So there's a number
of additional methods

00:20:54.310 --> 00:20:55.960
and changes to
the core libraries

00:20:55.960 --> 00:20:59.140
that you're going to see rolling
out in Dart 2 that are designed

00:20:59.140 --> 00:21:03.520
around this idea of
how do you make working

00:21:03.520 --> 00:21:05.800
with the core library
types in strong mode

00:21:05.800 --> 00:21:08.920
very convenient, very clean,
very terse, very Darty?

00:21:13.170 --> 00:21:15.840
So far, I've all been
talking about the work

00:21:15.840 --> 00:21:20.190
that we've done to make
working with strong mode

00:21:20.190 --> 00:21:21.720
and the sound type system great.

00:21:21.720 --> 00:21:24.070
I've talked about how we've
been updating the libraries.

00:21:24.070 --> 00:21:26.190
I haven't talked a
lot about the tools,

00:21:26.190 --> 00:21:27.898
but you're going to
hear a lot about that

00:21:27.898 --> 00:21:29.320
moving to the common front end.

00:21:29.320 --> 00:21:31.890
So there's a lot of work
just around the type system,

00:21:31.890 --> 00:21:35.147
but there's a few more
things coming in Dart 2

00:21:35.147 --> 00:21:36.230
that I want to talk about.

00:21:36.230 --> 00:21:39.810
And one of the reasons I want to
talk about them is they give us

00:21:39.810 --> 00:21:43.230
a little bit of a hint,
I think, about where

00:21:43.230 --> 00:21:45.270
we see the evolution of
the language happening

00:21:45.270 --> 00:21:46.785
in the future.

00:21:46.785 --> 00:21:48.660
So there are two things
I want to talk about.

00:21:48.660 --> 00:21:50.590
I want to talk about
64-bit integers,

00:21:50.590 --> 00:21:52.640
and I want to talk about
optional new and const.

00:21:55.960 --> 00:21:59.590
In the original
Dart vision where

00:21:59.590 --> 00:22:04.000
we were living in a
JIT compiled world,

00:22:04.000 --> 00:22:05.920
it was a very
natural choice to say

00:22:05.920 --> 00:22:10.180
we're going to make the native
integer type an arbitrary

00:22:10.180 --> 00:22:11.060
precision integer.

00:22:11.060 --> 00:22:16.260
So in the VM, you were able
to add numbers together

00:22:16.260 --> 00:22:17.260
to your heart's content.

00:22:17.260 --> 00:22:20.470
You didn't have to worry about
overflowing at 32 bits, or 64

00:22:20.470 --> 00:22:22.250
bits, or 128 bits.

00:22:22.250 --> 00:22:24.050
As much memory as you
had in your machine.

00:22:24.050 --> 00:22:26.341
If you waited long enough,
you could eventually fill up

00:22:26.341 --> 00:22:28.970
that memory with an integer.

00:22:28.970 --> 00:22:31.450
And that works very
nicely in a JIT.

00:22:31.450 --> 00:22:34.040
Because the JIT, most of the
time, you don't overflow.

00:22:34.040 --> 00:22:35.498
So the JIT just
says, you know, I'm

00:22:35.498 --> 00:22:37.810
going to just generate the
code for the fastpath then.

00:22:37.810 --> 00:22:39.310
I'll check for the
error conditions.

00:22:39.310 --> 00:22:41.980
And if they ever
happen, I'll bail out,

00:22:41.980 --> 00:22:45.100
and I'll recompile all this
code and produce the worst case

00:22:45.100 --> 00:22:45.600
code.

00:22:45.600 --> 00:22:49.240
But most of the time, I'm in the
small compact native platform

00:22:49.240 --> 00:22:50.629
code.

00:22:50.629 --> 00:22:52.670
Unfortunately, that doesn't
work well on the web,

00:22:52.670 --> 00:22:55.840
so the web has always lived
in the world where Dart

00:22:55.840 --> 00:22:57.740
integers are actually doubles.

00:22:57.740 --> 00:23:00.700
And unfortunately, it's
a little bit too costly

00:23:00.700 --> 00:23:03.590
when we are compiling
to native ahead of time.

00:23:03.590 --> 00:23:06.130
So when you are
compiling ahead of time,

00:23:06.130 --> 00:23:09.310
you don't have the option of
bailing out and regenerating

00:23:09.310 --> 00:23:10.090
the code.

00:23:10.090 --> 00:23:13.960
You have to generate all
of that code ahead of time

00:23:13.960 --> 00:23:16.016
as part of the executable
that gets shipped.

00:23:16.016 --> 00:23:17.890
So that means that your
executable is bigger.

00:23:17.890 --> 00:23:20.440
It means executable
is slower, and that's

00:23:20.440 --> 00:23:23.920
a worse experience for our end
users at the end of the day.

00:23:23.920 --> 00:23:32.710
So Dart 2 will have a default
integer type of 64-bits only,

00:23:32.710 --> 00:23:36.250
and they will not
overflow into big ints.

00:23:36.250 --> 00:23:41.560
This means we're able to
ship smaller, faster code.

00:23:41.560 --> 00:23:44.120
So that's a benefit
to our end users,

00:23:44.120 --> 00:23:45.910
but that's a big change
for the language.

00:23:45.910 --> 00:23:47.900
It's not something that
comes up very often,

00:23:47.900 --> 00:23:50.800
but it is something you need
to be aware of as developers

00:23:50.800 --> 00:23:53.380
when you're working with Dart.

00:23:53.380 --> 00:23:55.990
The second big change that
is happening in Dart 2,

00:23:55.990 --> 00:23:58.060
this was talked about a
fair bit in the keynote,

00:23:58.060 --> 00:24:01.054
but is around this
idea of reducing

00:24:01.054 --> 00:24:03.220
the amount of boilerplate
and reducing the friction.

00:24:03.220 --> 00:24:05.920
So if you look at this
piece of flutter code here,

00:24:05.920 --> 00:24:07.420
there are a bunch
of keywords, which

00:24:07.420 --> 00:24:08.960
are really sort of redundant.

00:24:08.960 --> 00:24:13.810
So everyone in the world uses
the standard coding conventions

00:24:13.810 --> 00:24:15.370
for naming constructors.

00:24:15.370 --> 00:24:18.190
So if you look at this code,
it is completely obvious to you

00:24:18.190 --> 00:24:19.310
as a developer.

00:24:19.310 --> 00:24:22.478
There's very little additional
information given to you

00:24:22.478 --> 00:24:24.144
by the fact that you
say new [INAUDIBLE]

00:24:24.144 --> 00:24:25.480
new, new, new, right?

00:24:25.480 --> 00:24:29.140
This is information that we
can statically infer for you,

00:24:29.140 --> 00:24:31.990
and you as a developer can
easily infer in your head

00:24:31.990 --> 00:24:34.900
just by reading just by
looking at the names.

00:24:34.900 --> 00:24:37.450
So it really adds very
little value to anybody,

00:24:37.450 --> 00:24:40.310
and so in Dart 2, we
will infer these for you.

00:24:40.310 --> 00:24:43.040
You are welcome to
write them if you want,

00:24:43.040 --> 00:24:45.955
but the system is able
to fill them in for you.

00:24:45.955 --> 00:24:48.219
Edge insets has a
const constructor.

00:24:48.219 --> 00:24:49.510
All of its arguments are const.

00:24:49.510 --> 00:24:53.260
Therefore, we will just
make it const for you.

00:24:53.260 --> 00:24:56.110
Anything that can't be const,
we will just fill in the news.

00:24:56.110 --> 00:24:59.170
So this is just this pattern
of reducing the friction,

00:24:59.170 --> 00:25:00.790
making things lighter
weight, making

00:25:00.790 --> 00:25:04.810
it easier for you to quickly
get reliable code out the door.

00:25:08.820 --> 00:25:12.480
So if I look forward to
where Dart is going to go,

00:25:12.480 --> 00:25:14.460
I think both of
those two features

00:25:14.460 --> 00:25:16.770
there that I just
pointed out give us

00:25:16.770 --> 00:25:20.089
an idea of where we want to
see Dart going in the future.

00:25:20.089 --> 00:25:21.880
So there are two things
that I think about.

00:25:21.880 --> 00:25:26.490
One is making our
developers more productive,

00:25:26.490 --> 00:25:29.150
and I think of that
as making Dart better.

00:25:29.150 --> 00:25:31.980
So I want you guys to
be more productive,

00:25:31.980 --> 00:25:36.100
so that you can ship better apps
more quickly to the end user.

00:25:36.100 --> 00:25:39.000
And there are lots of things
we can do to make Dart better.

00:25:39.000 --> 00:25:40.770
There are things like
generic constructors

00:25:40.770 --> 00:25:42.330
that we don't have
yet to allow us

00:25:42.330 --> 00:25:46.890
to take these relatively
untyped constructors

00:25:46.890 --> 00:25:50.130
like from iterable, and
fill in more types on them.

00:25:50.130 --> 00:25:52.350
And again, this allows us
to preserve types better,

00:25:52.350 --> 00:25:54.450
and this allows us to
get better type inference

00:25:54.450 --> 00:25:58.570
so that the users of your
APIs get a better experience.

00:25:58.570 --> 00:26:00.820
We'd like to improve the
type promotion in Dart.

00:26:00.820 --> 00:26:02.550
So Dart already
has a great feature

00:26:02.550 --> 00:26:05.710
where if you do an instance
check on a variable,

00:26:05.710 --> 00:26:09.420
we will use that information
to promote the type where

00:26:09.420 --> 00:26:13.710
possible, so that you
don't have to recast it

00:26:13.710 --> 00:26:15.390
or constantly recheck it.

00:26:15.390 --> 00:26:18.120
This is something we can
make stronger and better.

00:26:18.120 --> 00:26:20.662
And that will reduce the amount
of friction and boilerplate

00:26:20.662 --> 00:26:21.620
that you have to write.

00:26:21.620 --> 00:26:23.328
So this is something,
I think, we already

00:26:23.328 --> 00:26:26.550
have a great proposal for
from members of the team,

00:26:26.550 --> 00:26:29.940
and I really think we'll be
moving forward on quickly.

00:26:29.940 --> 00:26:31.650
There's a bunch of
longer term stuff

00:26:31.650 --> 00:26:34.530
that we're looking at as
we get more and more users.

00:26:34.530 --> 00:26:36.654
It gets harder and harder
to evolve the language.

00:26:36.654 --> 00:26:38.820
So I we're going to be
thinking very hard about what

00:26:38.820 --> 00:26:43.080
we need to add to the language
to support further evolution

00:26:43.080 --> 00:26:46.230
of the language and library.

00:26:46.230 --> 00:26:48.420
We're very interested in
maintaining this ability

00:26:48.420 --> 00:26:52.240
to work very cleanly with
untyped and typed code.

00:26:52.240 --> 00:26:55.350
So I think we'll be thinking
about how the language can

00:26:55.350 --> 00:26:57.470
support that very nicely.

00:26:57.470 --> 00:26:58.720
And there's a lot of interest.

00:26:58.720 --> 00:27:00.678
There's been a lot of
interest for a long time,

00:27:00.678 --> 00:27:03.100
but there's a lot of interest
in non-nullable types.

00:27:03.100 --> 00:27:05.460
This is a very hard thing
for us to do because there's

00:27:05.460 --> 00:27:08.970
a lot of your code out there,
which is already written

00:27:08.970 --> 00:27:10.380
without non-nullable types.

00:27:10.380 --> 00:27:12.190
And so it's very hard
to migrate that code,

00:27:12.190 --> 00:27:14.440
so we're going to have to
be very thoughtful about how

00:27:14.440 --> 00:27:19.987
we do this if we do it in a way
that doesn't break the world.

00:27:19.987 --> 00:27:21.570
But if we can do
this, I think there's

00:27:21.570 --> 00:27:24.660
a lot of value we can provide
to developers, both in terms

00:27:24.660 --> 00:27:26.850
of productivity by
catching nullers.

00:27:26.850 --> 00:27:29.929
But also, in terms of
making Dart faster,

00:27:29.929 --> 00:27:31.470
which is the other
thing that I think

00:27:31.470 --> 00:27:35.100
we're really excited about
doing with the language going

00:27:35.100 --> 00:27:35.620
forward.

00:27:35.620 --> 00:27:37.290
We're very interested
in continuing

00:27:37.290 --> 00:27:40.950
to push on this
idea of making Dart

00:27:40.950 --> 00:27:45.570
a faster, better language for
shipping native apps and web

00:27:45.570 --> 00:27:47.540
apps to end users.

00:27:47.540 --> 00:27:51.030
So we want to get the code
size down smaller on web apps

00:27:51.030 --> 00:27:54.690
and on native apps, memory
usage down, performance better.

00:27:54.690 --> 00:27:57.240
Make better use of
multi-core processors.

00:27:57.240 --> 00:28:00.150
Whether that's through better
isolates or other features.

00:28:00.150 --> 00:28:05.100
Find ways to make the end user
product a better experience

00:28:05.100 --> 00:28:07.440
by making the code
that is produced

00:28:07.440 --> 00:28:10.800
by the Dart tools
better, so this

00:28:10.800 --> 00:28:13.500
is something I think
we're very excited about.

00:28:13.500 --> 00:28:15.720
The overarching
theme here is that we

00:28:15.720 --> 00:28:18.450
want to make Dart the best
language for writing client

00:28:18.450 --> 00:28:25.010
side code, and I think we are
committed to make that happen.

00:28:25.010 --> 00:28:30.492
So if I look back at the past
sort of year or two of work,

00:28:30.492 --> 00:28:32.950
there's really an amazing amount
of things we've done here.

00:28:32.950 --> 00:28:38.650
We've taken this very dynamic
and fairly JIT focused

00:28:38.650 --> 00:28:40.260
language, and we've migrated it.

00:28:40.260 --> 00:28:43.840
We've evolved it forward to
being a fairly statically

00:28:43.840 --> 00:28:46.750
typed language that's
very friendly to ahead

00:28:46.750 --> 00:28:50.680
of time compilation without
eliminating the benefits of JIT

00:28:50.680 --> 00:28:51.259
compilation.

00:28:51.259 --> 00:28:52.300
We still have hot reload.

00:28:52.300 --> 00:28:57.160
We still have fast refresh
cycles on native and on web.

00:28:57.160 --> 00:29:00.340
So we've been able
to migrate this path

00:29:00.340 --> 00:29:03.880
of trying to keep the best of
both worlds going by having

00:29:03.880 --> 00:29:07.690
a very data driven process using
information we get by looking

00:29:07.690 --> 00:29:09.880
at the huge corpus of
code that's out there,

00:29:09.880 --> 00:29:14.990
and making sure that we fit
what people are actually doing.

00:29:14.990 --> 00:29:17.950
When I look at what
we have done so far,

00:29:17.950 --> 00:29:20.680
I look at it as we have
produced a great platform

00:29:20.680 --> 00:29:21.970
for future evolution.

00:29:21.970 --> 00:29:23.830
We have set a
baseline that I think

00:29:23.830 --> 00:29:27.850
we can use to continue to
make the language better,

00:29:27.850 --> 00:29:31.480
and we are committed
as a team to continuing

00:29:31.480 --> 00:29:32.470
to evolve the language.

00:29:32.470 --> 00:29:34.240
We are committed to growth.

00:29:34.240 --> 00:29:37.250
We are committed to making
the language better,

00:29:37.250 --> 00:29:40.360
and we want to make Dart
the best possible language

00:29:40.360 --> 00:29:42.940
for writing client side code.

00:29:42.940 --> 00:29:46.290
[APPLAUSE]

