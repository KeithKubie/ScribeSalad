WEBVTT
Kind: captions
Language: en

00:00:04.188 --> 00:00:05.730
ROMAIN GUY: Good
afternoon, everyone.

00:00:05.730 --> 00:00:06.942
I'm all Romain Guy,

00:00:06.942 --> 00:00:08.150
ADAM POWELL: I'm Adam Powell.

00:00:08.150 --> 00:00:09.400
JIM SPROCH: And I'm Jim.

00:00:09.400 --> 00:00:12.080
ROMAIN GUY: All right, and we're
here to talk about UI patterns.

00:00:12.080 --> 00:00:15.740
Funny, a lot of you are
interested in that suddenly.

00:00:15.740 --> 00:00:19.430
So there was a stealth
title for the talk,

00:00:19.430 --> 00:00:22.462
so obviously it's about Jetpack
Compose on [INAUDIBLE] UI

00:00:22.462 --> 00:00:24.170
toolkit that we're
working on, and that's

00:00:24.170 --> 00:00:26.410
available in open source.

00:00:26.410 --> 00:00:29.160
And so we want to talk a
little more about this today.

00:00:29.160 --> 00:00:31.310
But first we want to talk
a little bit of history

00:00:31.310 --> 00:00:33.720
and explaining why
we're doing this.

00:00:33.720 --> 00:00:35.480
So how did we get here?

00:00:35.480 --> 00:00:37.490
A lot of you obviously
are familiar with views

00:00:37.490 --> 00:00:40.620
and activities and fragment, and
I'm sure you love those APIs,

00:00:40.620 --> 00:00:43.592
they're close to perfect.

00:00:43.592 --> 00:00:45.550
So just to give you a
little bit of background.

00:00:45.550 --> 00:00:48.590
So this is a diagram that
Chad did for a talk that

00:00:48.590 --> 00:00:50.445
we gave, I think, last year.

00:00:50.445 --> 00:00:52.820
Shows you a timeline of what
we've been up to, especially

00:00:52.820 --> 00:00:54.420
on the Android Toolkit team.

00:00:54.420 --> 00:00:56.240
So after we shipped
Android 1.0, we

00:00:56.240 --> 00:00:58.970
didn't do anything
for many, many years.

00:00:58.970 --> 00:01:00.830
And then we finally
woke up and decided

00:01:00.830 --> 00:01:03.060
to write new
libraries to help you.

00:01:03.060 --> 00:01:05.777
So things like Recycler
View, Constraint Layouts,

00:01:05.777 --> 00:01:08.360
Arch Components, and of course,
we had the adoption of Kotlin.

00:01:08.360 --> 00:01:10.190
So we have been
working on new things,

00:01:10.190 --> 00:01:12.650
but one things we
one thing we never

00:01:12.650 --> 00:01:14.840
changed was the
UI toolkit itself.

00:01:14.840 --> 00:01:17.340
We did a lot of work
underneath to make it better,

00:01:17.340 --> 00:01:20.030
we had hardware acceleration,
we fixed some bugs,

00:01:20.030 --> 00:01:22.910
we added some bugs, we
added a few features,

00:01:22.910 --> 00:01:25.860
but we never changed
it fundamentally.

00:01:25.860 --> 00:01:29.300
So one of the things that
happened over 10 years ago

00:01:29.300 --> 00:01:30.230
was this.

00:01:30.230 --> 00:01:32.320
This is a device that
we call the Sooner,

00:01:32.320 --> 00:01:34.670
and this was the
first device that I

00:01:34.670 --> 00:01:37.760
used to write Android
code when I joined Google.

00:01:37.760 --> 00:01:39.260
So to give you an
idea, this device

00:01:39.260 --> 00:01:42.770
had a single CPU
running at 80 megahertz.

00:01:42.770 --> 00:01:43.930
It didn't have a GPU.

00:01:43.930 --> 00:01:48.773
We had 64 megs of RAM, and
the screen was 320 by 240.

00:01:48.773 --> 00:01:50.690
This was not the first
device that we shipped.

00:01:50.690 --> 00:01:52.620
We shipped the G1, which
was slightly better,

00:01:52.620 --> 00:01:54.440
but that was similar in spirit.

00:01:54.440 --> 00:01:55.640
We shipped it with the GPU.

00:01:55.640 --> 00:01:57.840
We mostly didn't use it.

00:01:57.840 --> 00:01:59.840
So [INAUDIBLE] toolkit
was pretty much design

00:01:59.840 --> 00:02:01.760
for this device.

00:02:01.760 --> 00:02:04.250
Fast forward a few
years, and now we

00:02:04.250 --> 00:02:05.430
have this kind of devices.

00:02:05.430 --> 00:02:09.919
So this is a Pixel 2, I believe,
and the screen resolutions now

00:02:09.919 --> 00:02:17.040
are 2160 by 1080 or 2960
by 4040 on the XL variants.

00:02:17.040 --> 00:02:20.660
And here you can see a
screenshot of the Sooner

00:02:20.660 --> 00:02:23.930
at the same scale, and
it fits comfortably

00:02:23.930 --> 00:02:26.210
over just one icon
on the launcher.

00:02:26.210 --> 00:02:29.390
So we're still using
the same UI toolkit,

00:02:29.390 --> 00:02:31.850
so maybe it was time
to rethink our approach

00:02:31.850 --> 00:02:35.890
to UIs to better
serve those devices.

00:02:35.890 --> 00:02:38.660
And on top of that, so we build
the architecture components

00:02:38.660 --> 00:02:41.060
over the past couple years,
and the approach we took

00:02:41.060 --> 00:02:42.380
was extremely interesting.

00:02:42.380 --> 00:02:44.150
We were more open.

00:02:44.150 --> 00:02:46.833
We did a lot of alphas
and betas and RCs.

00:02:46.833 --> 00:02:48.500
We talked with you,
the community, a lot

00:02:48.500 --> 00:02:50.772
to hear what you wanted from us.

00:02:50.772 --> 00:02:52.230
I mean, you build
the applications.

00:02:52.230 --> 00:02:54.873
We don't really anymore,
so we need your input

00:02:54.873 --> 00:02:56.790
to know what it is you
need, what is you want,

00:02:56.790 --> 00:03:00.860
what are the problems that
you're facing every day.

00:03:00.860 --> 00:03:04.850
So, yeah, what are
you asking for?

00:03:04.850 --> 00:03:07.670
And what would
you like us to do?

00:03:07.670 --> 00:03:10.760
So when we ask this
question for the UI toolkit,

00:03:10.760 --> 00:03:12.860
in particular, one
of the answers we got

00:03:12.860 --> 00:03:14.235
was unbundle the UI toolkit.

00:03:14.235 --> 00:03:15.860
Because until now,
every time we wanted

00:03:15.860 --> 00:03:18.680
to ship a fix in the UI
toolkit, or every time

00:03:18.680 --> 00:03:20.450
we went to ship
a new feature, we

00:03:20.450 --> 00:03:22.400
could do this easily
ourselves, but then you

00:03:22.400 --> 00:03:24.890
had to wait for just
a few years to be

00:03:24.890 --> 00:03:27.072
able to raise your
main API level.

00:03:27.072 --> 00:03:29.030
And I know I've had many
discussions personally

00:03:29.030 --> 00:03:31.572
with some of you where I said,
I fixed your bug, you're like,

00:03:31.572 --> 00:03:33.770
yeah, I don't care
because the fix is not

00:03:33.770 --> 00:03:36.660
going to reach my users'
devices for a long, long time.

00:03:36.660 --> 00:03:39.020
So, not helpful at all.

00:03:39.020 --> 00:03:42.290
So we are thinking about moving
some of our widgets to Jetpack,

00:03:42.290 --> 00:03:43.640
make them be a support library.

00:03:43.640 --> 00:03:46.130
Let's take text view, move
it entirely in Jetpack,

00:03:46.130 --> 00:03:48.220
and then we'll be
able to deliver fixes.

00:03:48.220 --> 00:03:50.870
But as we were thinking
about doing this

00:03:50.870 --> 00:03:52.550
we thought, well,
if we're going to do

00:03:52.550 --> 00:03:54.920
this, how about
we start improving

00:03:54.920 --> 00:03:56.210
those widgets a little bit.

00:03:56.210 --> 00:03:58.230
What could we do to
improve the APIs?

00:03:58.230 --> 00:04:01.520
And I'm sure you all love
the APIs of our UI toolkit,

00:04:01.520 --> 00:04:06.590
but as Chad put it, API design
is building future regrets.

00:04:06.590 --> 00:04:08.540
And we have a lot of regrets--

00:04:08.540 --> 00:04:11.040
a lot, even more than you do.

00:04:11.040 --> 00:04:14.090
Here are some examples.

00:04:14.090 --> 00:04:18.160
So for instance view.java,
do you know how big it is?

00:04:18.160 --> 00:04:20.240
I'm sure you have big
files in your source code,

00:04:20.240 --> 00:04:23.030
I'm pretty sure you don't
have files as big as this one.

00:04:23.030 --> 00:04:29.640
So we have almost 30,000 lines
of code in view.java, yeah.

00:04:29.640 --> 00:04:34.960
[APPLAUSE] That is Google's
[? scale ?] right here.

00:04:34.960 --> 00:04:36.520
To be fair, it's
a lot of comments

00:04:36.520 --> 00:04:39.620
but still this is
not very good design.

00:04:39.620 --> 00:04:41.420
So that's one thing.

00:04:41.420 --> 00:04:43.150
And then there's random stuff.

00:04:43.150 --> 00:04:44.532
For instance, Spinner.

00:04:44.532 --> 00:04:46.240
Why do we have this
class called Spinner?

00:04:46.240 --> 00:04:48.215
It's a combo box or dropdown.

00:04:48.215 --> 00:04:50.590
We don't like Spinner, nobody
does, and a bunch of people

00:04:50.590 --> 00:04:51.840
ask, why is it called Spinner?

00:04:51.840 --> 00:04:52.940
I'll show you why.

00:04:52.940 --> 00:04:55.523
So when we shipped
our first SDK,

00:04:55.523 --> 00:04:56.690
this is what it looked like.

00:04:56.690 --> 00:04:59.680
So I ran this on my
Mac, and it does spin.

00:04:59.680 --> 00:05:02.260
[LAUGHTER]

00:05:02.260 --> 00:05:05.470
So we're not entirely
crazy or stupid,

00:05:05.470 --> 00:05:08.800
we just changed our mind.

00:05:08.800 --> 00:05:11.800
Another example that I
really like is Button.

00:05:11.800 --> 00:05:14.170
Button, if you look at the
source code of button.java,

00:05:14.170 --> 00:05:15.430
it's extremely interesting.

00:05:15.430 --> 00:05:17.680
There's very few
lines of code in there

00:05:17.680 --> 00:05:20.470
because it extends TextView.

00:05:20.470 --> 00:05:21.305
Why?

00:05:21.305 --> 00:05:22.180
It's a good question.

00:05:22.180 --> 00:05:24.750
Because when you
need to display text,

00:05:24.750 --> 00:05:27.200
the problem is that TextView
can do a lot of things.

00:05:27.200 --> 00:05:31.716
For instance, you can make a
button selectable if you want,

00:05:31.716 --> 00:05:34.060
and I'm pretty sure you
can also make it editable.

00:05:34.060 --> 00:05:35.980
[LAUGHTER]

00:05:38.023 --> 00:05:39.440
All right and of
course, there are

00:05:39.440 --> 00:05:40.960
tons of other issues
but Adam who's

00:05:40.960 --> 00:05:42.560
going to talk more about those.

00:05:42.560 --> 00:05:43.580
ADAM POWELL: Yeah,
Romain told me

00:05:43.580 --> 00:05:44.720
that I had to take
the slide that

00:05:44.720 --> 00:05:45.920
started with fragments here.

00:05:45.920 --> 00:05:48.900
I'm not entirely sure why.

00:05:48.900 --> 00:05:51.620
So as you stop to factor
some of your UIs on Android,

00:05:51.620 --> 00:05:53.900
and you start to have to
make some decisions about how

00:05:53.900 --> 00:05:55.620
you're going to write
your UI components.

00:05:55.620 --> 00:05:58.160
And this is a question that
we've had a lot over the years.

00:05:58.160 --> 00:06:01.070
Do I write a fragment or do I
write a custom view or custom

00:06:01.070 --> 00:06:01.970
viewgroup?

00:06:01.970 --> 00:06:03.980
And the problem with this
is that the answer can

00:06:03.980 --> 00:06:05.990
be really different depending
on the kind of component

00:06:05.990 --> 00:06:07.573
that you're writing,
and each approach

00:06:07.573 --> 00:06:09.690
has some of its own challenges.

00:06:09.690 --> 00:06:11.630
For example, if you
see this line of code

00:06:11.630 --> 00:06:13.880
somewhere because someone
decided that they were going

00:06:13.880 --> 00:06:16.470
to write a custom view to
solve a particular problem,

00:06:16.470 --> 00:06:19.240
what exactly is
your first reaction?

00:06:19.240 --> 00:06:21.490
ROMAIN GUY: Awesome.

00:06:21.490 --> 00:06:22.790
JIM SPROCH: No, Romain.

00:06:22.790 --> 00:06:23.457
ADAM POWELL: No?

00:06:23.457 --> 00:06:26.483
OK, so custom views are kind of
daunting to write because you

00:06:26.483 --> 00:06:28.150
really have to get
so many things right,

00:06:28.150 --> 00:06:31.073
especially if you want to expose
a first class API surface.

00:06:31.073 --> 00:06:33.490
You've got properties that
need their getters and setters,

00:06:33.490 --> 00:06:34.960
pretty standard stuff.

00:06:34.960 --> 00:06:37.030
You've got XML
attributes, which means

00:06:37.030 --> 00:06:40.510
that you need to start adding
in more stuff in your attrs.xml,

00:06:40.510 --> 00:06:42.370
define styleables.

00:06:42.370 --> 00:06:45.640
Speaking of stylables, you need
to define actual default styles

00:06:45.640 --> 00:06:48.250
and probably edit some
default theme attributes

00:06:48.250 --> 00:06:51.593
to make sure that all those
styles get wired up properly.

00:06:51.593 --> 00:06:54.010
And that's before you even get
to the sheer volume of code

00:06:54.010 --> 00:06:56.560
that you need for dealing with
things like layout or touch

00:06:56.560 --> 00:06:58.550
events.

00:06:58.550 --> 00:07:02.380
So meanwhile, fragments give
you a whole lot of flexibility,

00:07:02.380 --> 00:07:05.403
plus all the lifecycle hooks for
hanging your application logic

00:07:05.403 --> 00:07:07.570
from, especially now that
you've got arch components

00:07:07.570 --> 00:07:10.443
to give you some of this
in a more pluggable way.

00:07:10.443 --> 00:07:11.860
But this kind of
makes them better

00:07:11.860 --> 00:07:14.350
suited for coarser
grained situations.

00:07:14.350 --> 00:07:18.160
Reusable hold article displays
with interactive subcomponents

00:07:18.160 --> 00:07:21.460
and not really so much
things like single buttons.

00:07:21.460 --> 00:07:24.100
But the problem with this is
that your apps aren't static.

00:07:24.100 --> 00:07:26.570
They really change
and grow over time.

00:07:26.570 --> 00:07:28.990
So there's a potentially
really high engineering cost

00:07:28.990 --> 00:07:30.760
to having to cross
over from one of

00:07:30.760 --> 00:07:33.760
these abstractions to another
as your use cases change.

00:07:36.480 --> 00:07:38.550
So you insulate yourself
from that change.

00:07:38.550 --> 00:07:40.260
You build other
architectures to keep

00:07:40.260 --> 00:07:42.660
your views, your fragments,
and activities as removed

00:07:42.660 --> 00:07:44.430
from these things as
possible, and maybe

00:07:44.430 --> 00:07:47.238
actually make it a little bit
easier to test along the way.

00:07:47.238 --> 00:07:49.530
No matter which of these
architectures, or some of them

00:07:49.530 --> 00:07:52.470
that aren't listed
that you might choose,

00:07:52.470 --> 00:07:54.150
they all take on the
same basic shape.

00:07:54.150 --> 00:07:56.460
You bind some of this
stuff in your activity,

00:07:56.460 --> 00:07:59.250
your views publish
events and receive state,

00:07:59.250 --> 00:08:03.140
and everything in between
is kind of a judgment call.

00:08:03.140 --> 00:08:05.200
So these architectures
really exist

00:08:05.200 --> 00:08:08.110
to help define and reason
about your apps' data flow

00:08:08.110 --> 00:08:10.930
and answer the three
main questions.

00:08:10.930 --> 00:08:14.480
So what is the source of truth?

00:08:14.480 --> 00:08:15.920
Who owns it?

00:08:15.920 --> 00:08:18.980
And more specifically,
who can change it?

00:08:18.980 --> 00:08:21.870
So once you answer some
of these questions,

00:08:21.870 --> 00:08:25.310
then you realize that
the Android UI toolkit

00:08:25.310 --> 00:08:28.590
doesn't really work this way.

00:08:28.590 --> 00:08:30.380
Views kind of own
their own state

00:08:30.380 --> 00:08:32.419
and make their own changes
whether you want them

00:08:32.419 --> 00:08:33.980
to or not.

00:08:33.980 --> 00:08:35.900
Most of these view
state changes at least

00:08:35.900 --> 00:08:37.442
have some optional
listeners that you

00:08:37.442 --> 00:08:39.740
can attach so you can respond
to some of those changes

00:08:39.740 --> 00:08:42.390
and do something about it.

00:08:42.390 --> 00:08:46.160
But really, the Spinner is
another great example here,

00:08:46.160 --> 00:08:48.380
as odd as it is.

00:08:48.380 --> 00:08:51.432
And it's got this
onSelectedItemChanged listener

00:08:51.432 --> 00:08:53.390
that tells you when the
user changed the value.

00:08:53.390 --> 00:08:56.030
You've picked a new
value from the dropdown.

00:08:56.030 --> 00:08:59.360
And it gives you this callback
after the items already

00:08:59.360 --> 00:09:00.050
changed.

00:09:00.050 --> 00:09:03.320
And for a lot of UIs,
this is kind of useless

00:09:03.320 --> 00:09:06.120
because then you have to
change it back after the fact.

00:09:06.120 --> 00:09:08.030
So if you've ever
created one of those UIs

00:09:08.030 --> 00:09:11.180
where you have a custom dot,
dot, dot, you pop up a dialog,

00:09:11.180 --> 00:09:13.790
you've let the user make
some custom selections,

00:09:13.790 --> 00:09:16.010
and then you have to
change the adapter,

00:09:16.010 --> 00:09:18.050
set the value to something new.

00:09:18.050 --> 00:09:21.350
It's kind of a song and dance
that's not a lot of fun.

00:09:21.350 --> 00:09:23.120
And you also have to
deal with this idea

00:09:23.120 --> 00:09:24.650
of these reentrant
listener calls

00:09:24.650 --> 00:09:26.690
once you do set something back.

00:09:26.690 --> 00:09:28.910
So your listener has to
handle both the cases

00:09:28.910 --> 00:09:31.400
where you meant to
change it on purpose

00:09:31.400 --> 00:09:32.690
or when the user did it.

00:09:32.690 --> 00:09:36.260
And that just is more and more
code that you can get wrong.

00:09:36.260 --> 00:09:39.913
But there's some advantages
to this kind of approach.

00:09:39.913 --> 00:09:41.330
I mean, like, I
would love to just

00:09:41.330 --> 00:09:44.120
be able to change my salary and
then tell Romain all about it

00:09:44.120 --> 00:09:46.230
after the fact.

00:09:46.230 --> 00:09:47.898
ROMAIN GUY: We'll
talk about it at work.

00:09:47.898 --> 00:09:50.190
ADAM POWELL: No, this is me
telling you after the fact.

00:09:50.190 --> 00:09:51.773
ROMAIN GUY: Yeah,
we'll talk about it.

00:09:51.773 --> 00:09:53.680
ADAM POWELL: OK.

00:09:53.680 --> 00:09:58.840
So speaking of events, when you
have a single source of truth,

00:09:58.840 --> 00:10:00.790
you don't have all
of these problems.

00:10:00.790 --> 00:10:03.850
Every piece of
state has one owner.

00:10:03.850 --> 00:10:06.610
And only the owner
can make changes

00:10:06.610 --> 00:10:09.080
to that particular state.

00:10:09.080 --> 00:10:11.440
So that means that
the owner is listening

00:10:11.440 --> 00:10:14.410
to events that are happening
somewhere else in the UI,

00:10:14.410 --> 00:10:15.880
and it makes
changes in response.

00:10:19.000 --> 00:10:22.090
How many of you have
seen some code like this?

00:10:22.090 --> 00:10:25.100
Hopefully, not too recently--
oh no, we've got a few hands.

00:10:25.100 --> 00:10:28.780
OK, so Android's UI APIs
were really kind of designed

00:10:28.780 --> 00:10:30.130
for this world--

00:10:30.130 --> 00:10:32.920
handling events by implementing
several different listener

00:10:32.920 --> 00:10:35.950
interfaces in one class
where that state lives.

00:10:35.950 --> 00:10:38.420
By implementing these
interfaces where the state is,

00:10:38.420 --> 00:10:39.962
you can make sure
that you don't have

00:10:39.962 --> 00:10:42.280
to lace that state through
too many different places.

00:10:42.280 --> 00:10:46.510
And this is kind of gross,
but lambdas weren't even

00:10:46.510 --> 00:10:49.250
part of the language when
this was common practice.

00:10:49.250 --> 00:10:52.902
So we can take a
few liberties here.

00:10:52.902 --> 00:10:55.360
But if you let somebody who's
comfortable with Kotlin lose,

00:10:55.360 --> 00:10:57.670
they might go nuts
and play some golf.

00:10:57.670 --> 00:10:59.712
They might write
something more like this.

00:10:59.712 --> 00:11:01.420
And the advantages of
something like this

00:11:01.420 --> 00:11:02.920
is that it's event
driven and it's

00:11:02.920 --> 00:11:05.350
built on composing
behaviors rather than based

00:11:05.350 --> 00:11:06.330
on inheritance.

00:11:06.330 --> 00:11:08.080
You can kind of get
away with implementing

00:11:08.080 --> 00:11:09.820
a bunch of interfaces
on a central class

00:11:09.820 --> 00:11:12.700
like the slide we saw before
when you have a small team.

00:11:12.700 --> 00:11:14.770
If everybody fits
in the same room

00:11:14.770 --> 00:11:16.600
and you can just ask
each other questions,

00:11:16.600 --> 00:11:18.183
you know that you're
not going to make

00:11:18.183 --> 00:11:19.940
a mess in front of one another.

00:11:19.940 --> 00:11:22.120
But as app and
team sizes grew, it

00:11:22.120 --> 00:11:24.010
became much less
sustainable to do that.

00:11:24.010 --> 00:11:26.335
So by leaning into
Kotlin in particular,

00:11:26.335 --> 00:11:28.710
we can write much more powerful
and more composable APIs.

00:11:31.910 --> 00:11:33.800
But really, whether
you've decided

00:11:33.800 --> 00:11:36.410
to write a fragment
or a view, the changes

00:11:36.410 --> 00:11:37.910
that you have to
make really kind of

00:11:37.910 --> 00:11:40.580
look similar if you're trying
to write something that's

00:11:40.580 --> 00:11:43.730
really reusable, something
that exposes a first class API

00:11:43.730 --> 00:11:47.180
surface for other people to use.

00:11:47.180 --> 00:11:50.030
You'll have something that looks
either MyFragment or MyView,

00:11:50.030 --> 00:11:52.670
and it might be a
Kotlin or a Java file.

00:11:52.670 --> 00:11:55.388
You have an XML file
that holds your layout

00:11:55.388 --> 00:11:56.930
for that particular
file potentially,

00:11:56.930 --> 00:11:58.930
if it's something
complicated, if it's something

00:11:58.930 --> 00:12:01.080
more than just a simple
button that clicks.

00:12:01.080 --> 00:12:03.860
You've got some stuff in
your attrs.sml file that

00:12:03.860 --> 00:12:06.080
defines the stylable and
all the different attributes

00:12:06.080 --> 00:12:06.890
that it can take.

00:12:06.890 --> 00:12:08.690
And you also have to
make sure that you

00:12:08.690 --> 00:12:10.460
don't step on that
shared namespace

00:12:10.460 --> 00:12:11.895
that resources work in.

00:12:11.895 --> 00:12:14.270
Can't declare two attributes
for two completely different

00:12:14.270 --> 00:12:16.070
stylables if they
have a different type.

00:12:16.070 --> 00:12:18.530
That would be silly.

00:12:18.530 --> 00:12:20.780
And then finally, you have
to deal with everything

00:12:20.780 --> 00:12:22.860
around styling.

00:12:22.860 --> 00:12:25.820
So you're spreading
all of this code that

00:12:25.820 --> 00:12:27.890
really has to do with
the same component

00:12:27.890 --> 00:12:29.840
across many different files.

00:12:29.840 --> 00:12:32.180
And by breaking that
spatial locality,

00:12:32.180 --> 00:12:35.690
it makes it harder to regain
context or flow at a glance

00:12:35.690 --> 00:12:37.130
after you've been interrupted.

00:12:37.130 --> 00:12:40.280
So for example, if you
have pets or small children

00:12:40.280 --> 00:12:42.320
or an open plan
office, you might

00:12:42.320 --> 00:12:45.842
get interrupted pretty often.

00:12:45.842 --> 00:12:48.050
So really we're trying to
address all of these things

00:12:48.050 --> 00:12:49.440
at once.

00:12:49.440 --> 00:12:51.110
So first off, we
want to make sure

00:12:51.110 --> 00:12:53.300
that we unbundle from
the platform releases

00:12:53.300 --> 00:12:55.610
so that you can take
advantage of what

00:12:55.610 --> 00:12:58.250
we're working on immediately.

00:12:58.250 --> 00:13:00.800
We want to make sure that you
have fewer technology stack

00:13:00.800 --> 00:13:02.870
flow charts to traverse
when you're deciding

00:13:02.870 --> 00:13:04.490
how to build your component.

00:13:04.490 --> 00:13:06.740
We want to make sure that
we're not telling you, well,

00:13:06.740 --> 00:13:08.680
if you're doing something
that's bigger like this,

00:13:08.680 --> 00:13:10.430
start with a fragment,
otherwise a button.

00:13:10.430 --> 00:13:13.910
And if you're not sure, flip
a coin, see how it goes,

00:13:13.910 --> 00:13:16.790
maybe refactor later.

00:13:16.790 --> 00:13:19.430
We want to help you clarify
state ownership and event

00:13:19.430 --> 00:13:20.150
handling.

00:13:20.150 --> 00:13:21.650
This is really big
because this is

00:13:21.650 --> 00:13:24.050
one of those things that
ends up being almost

00:13:24.050 --> 00:13:26.567
an afterthought in some
applications if you are not

00:13:26.567 --> 00:13:27.650
thinking about it upfront.

00:13:27.650 --> 00:13:30.560
But it's really the flow of
data through your application

00:13:30.560 --> 00:13:33.895
that can be the most
complex interactions.

00:13:33.895 --> 00:13:36.020
And finally, we want help
you just write less code.

00:13:38.620 --> 00:13:41.080
So the simplest program
that you can write in Kotlin

00:13:41.080 --> 00:13:44.960
is really, really simple.

00:13:44.960 --> 00:13:47.440
So whenever you're
writing a GUI app though,

00:13:47.440 --> 00:13:49.460
they're not this kind
snapshot in time.

00:13:49.460 --> 00:13:51.190
It's not a fire and
forget construct

00:13:51.190 --> 00:13:54.310
where you run it once and
then the program terminates.

00:13:54.310 --> 00:13:56.750
You're done, it's done its job.

00:13:56.750 --> 00:13:59.230
So we kind of need to handle
this idea of an event loop

00:13:59.230 --> 00:14:01.090
and things that
change over time.

00:14:01.090 --> 00:14:03.880
And Kotlin really gives
us some huge advantages

00:14:03.880 --> 00:14:05.920
for working with
asynchronous code now.

00:14:05.920 --> 00:14:07.390
But can we go even further?

00:14:07.390 --> 00:14:11.800
Can we make it as simple as
this to write an Android app?

00:14:11.800 --> 00:14:14.140
JIM SPROCH: Well, maybe we can.

00:14:14.140 --> 00:14:19.360
What if instead of calling
print line, we called text?

00:14:19.360 --> 00:14:22.720
What if calling text
would admit a text widget

00:14:22.720 --> 00:14:25.160
to the UI hierarchy?

00:14:25.160 --> 00:14:27.790
This is the idea
behind Jetpack Compose.

00:14:27.790 --> 00:14:31.840
It's a declarative UI
toolkit built for Android.

00:14:31.840 --> 00:14:35.860
It's inspired by frameworks
like React, Litho, Vue.js,

00:14:35.860 --> 00:14:39.010
and Flutter, but it's
written completely in Kotlin

00:14:39.010 --> 00:14:42.550
and is fully compatible with the
existing Android view system.

00:14:42.550 --> 00:14:45.520
It aims to simplify the
way that you write code

00:14:45.520 --> 00:14:50.460
by making your Android UI
hierarchies more declarative.

00:14:50.460 --> 00:14:52.950
With Compose, your UI is
defined as a function,

00:14:52.950 --> 00:14:56.160
and this function transforms
data into view hierarchy.

00:14:56.160 --> 00:14:58.890
In this case, the
input is a simple piece

00:14:58.890 --> 00:15:03.090
of data, a person's name, and
the output is a UI hierarchy,

00:15:03.090 --> 00:15:04.890
is a text widget.

00:15:04.890 --> 00:15:06.600
When you need to
update the name,

00:15:06.600 --> 00:15:09.960
we can just re-invoke this
function with the new data,

00:15:09.960 --> 00:15:13.110
and the UI hierarchy will
contain a text widget

00:15:13.110 --> 00:15:14.550
with the new text.

00:15:14.550 --> 00:15:16.320
This radically simplifies
your application

00:15:16.320 --> 00:15:18.320
because you no longer
have to have separate code

00:15:18.320 --> 00:15:20.430
paths for inflating
the initial views

00:15:20.430 --> 00:15:22.920
and then updating
the views later.

00:15:22.920 --> 00:15:25.470
If we invoke the function
with an appropriate name,

00:15:25.470 --> 00:15:28.920
then we'll get text, hello
world, on the screen.

00:15:28.920 --> 00:15:31.350
When the data changes, we
can invoke the function again

00:15:31.350 --> 00:15:33.810
with the new data
and the new data

00:15:33.810 --> 00:15:36.720
appears with a new
greeting on the screen.

00:15:36.720 --> 00:15:39.480
Each time we invoke the function
with different data, the text

00:15:39.480 --> 00:15:41.700
on the screen is updated.

00:15:41.700 --> 00:15:45.450
But what exactly is Compose
and how does this work?

00:15:45.450 --> 00:15:48.840
Among other things, Compose
is a completely new set

00:15:48.840 --> 00:15:50.820
of widgets and
toolkit APIs built

00:15:50.820 --> 00:15:52.770
on top of composable functions.

00:15:52.770 --> 00:15:54.030
They're not views.

00:15:54.030 --> 00:15:55.140
They're not fragments.

00:15:55.140 --> 00:15:58.920
They're something smaller, more
modular, easier to work with,

00:15:58.920 --> 00:16:02.550
and easier to test in isolation.

00:16:02.550 --> 00:16:05.550
Compose is also a
Kotlin compiler plugin,

00:16:05.550 --> 00:16:08.730
which makes it possible to
define your own declarative

00:16:08.730 --> 00:16:11.370
functions using our
declarative API.

00:16:11.370 --> 00:16:13.770
The Compose compiler is
what powers the new widget

00:16:13.770 --> 00:16:16.590
set and makes it easy for you
to define your own composable

00:16:16.590 --> 00:16:18.930
widgets.

00:16:18.930 --> 00:16:21.660
Compose widgets are also fully
compatible with the existing

00:16:21.660 --> 00:16:22.810
view system.

00:16:22.810 --> 00:16:25.470
Whether you're working with
Kotlin or the Java programming

00:16:25.470 --> 00:16:27.570
language, we
provide ways for you

00:16:27.570 --> 00:16:30.880
to use the new widget set in
your existing view hierarchy,

00:16:30.880 --> 00:16:34.740
and you can use existing views
in the Compose hierarchy.

00:16:34.740 --> 00:16:37.410
You can mix and match, you
can adopt it incrementally

00:16:37.410 --> 00:16:42.320
and you can adopt it at your own
pace, just like Kotlin itself.

00:16:42.320 --> 00:16:44.270
It's also very early stage.

00:16:44.270 --> 00:16:45.860
We're still in
active development,

00:16:45.860 --> 00:16:48.028
and we're moving to ALSP
so that you guys can

00:16:48.028 --> 00:16:49.820
get an early preview
and so that you can be

00:16:49.820 --> 00:16:51.350
a part of its development too.

00:16:51.350 --> 00:16:52.970
So we can collect
feedback from you,

00:16:52.970 --> 00:16:54.720
but it's not ready for
production use yet.

00:16:57.270 --> 00:17:01.000
If you did want to use
Compose in an application,

00:17:01.000 --> 00:17:02.680
it might look
something like this.

00:17:02.680 --> 00:17:05.310
You can call composable
functions directly

00:17:05.310 --> 00:17:10.150
from the content
of your activity.

00:17:10.150 --> 00:17:11.890
All composable
functions are annotated

00:17:11.890 --> 00:17:14.020
with an @Composable annotation.

00:17:14.020 --> 00:17:16.480
This tells the Composer
compiler that your function

00:17:16.480 --> 00:17:18.099
should be treated as a widget.

00:17:18.099 --> 00:17:21.339
And it allows us to jump in and
perform the necessary rewrites

00:17:21.339 --> 00:17:22.500
at the right time.

00:17:22.500 --> 00:17:24.250
We've been working
with the JetBrains team

00:17:24.250 --> 00:17:27.220
to make all of this possible and
it's still very experimental.

00:17:27.220 --> 00:17:30.620
But basically, we intercept
calls to composable functions,

00:17:30.620 --> 00:17:34.060
and that's what allows us to
provide the declarative API.

00:17:34.060 --> 00:17:36.130
Ultimately these
functions are fully

00:17:36.130 --> 00:17:38.590
featured Kotlin functions,
which allows us to do

00:17:38.590 --> 00:17:40.850
some really interesting things.

00:17:40.850 --> 00:17:43.900
For example, if we wanted
to greet the user 10 times,

00:17:43.900 --> 00:17:48.070
we could use a simple for
loop to do exactly that.

00:17:48.070 --> 00:17:50.080
If we want to iterate
over a list of names,

00:17:50.080 --> 00:17:53.950
we can greet a whole bunch
of people all at once.

00:17:53.950 --> 00:17:56.560
We can also have logic to show
something completely different

00:17:56.560 --> 00:17:58.080
when the list is empty.

00:17:58.080 --> 00:18:00.310
But the most important thing
about composable widgets

00:18:00.310 --> 00:18:03.160
is that they're composable.

00:18:03.160 --> 00:18:05.590
Compose makes it trivial to
define your own composable

00:18:05.590 --> 00:18:08.300
functions and reuse them
throughout your application.

00:18:08.300 --> 00:18:10.870
Your UI hierarchy
is built by having

00:18:10.870 --> 00:18:13.760
composable functions call
other compatible functions.

00:18:16.227 --> 00:18:18.560
ADAM POWELL: So our story
widget here uses several stock

00:18:18.560 --> 00:18:20.540
elements that we're going
to provide out of the box

00:18:20.540 --> 00:18:22.373
to build up a pretty
straightforward layout,

00:18:22.373 --> 00:18:24.110
but you might see
another issue here

00:18:24.110 --> 00:18:26.570
if you're not suspending
disbelief quite enough looking

00:18:26.570 --> 00:18:28.320
at our slide wear here.

00:18:28.320 --> 00:18:30.500
So as we know, if
that list right there

00:18:30.500 --> 00:18:32.450
is really, really
big, then this would

00:18:32.450 --> 00:18:34.520
create a whole lot of
these story widgets

00:18:34.520 --> 00:18:36.357
that we're not going to see.

00:18:36.357 --> 00:18:38.690
As Android developers, we've
been trained over the years

00:18:38.690 --> 00:18:39.500
to avoid this.

00:18:39.500 --> 00:18:41.000
In fact, I think
about 10 years ago,

00:18:41.000 --> 00:18:42.800
Romain and I gave our
first talk together

00:18:42.800 --> 00:18:45.690
where we were talking
about list view.

00:18:45.690 --> 00:18:48.343
So this today would be the
job of a recycler view, kind

00:18:48.343 --> 00:18:50.510
of our list view two widget
that you're all probably

00:18:50.510 --> 00:18:51.900
familiar with.

00:18:51.900 --> 00:18:54.620
But that means that we have
to factor out an adapter

00:18:54.620 --> 00:18:57.560
to handle the recycler view
itself requesting and rebinding

00:18:57.560 --> 00:19:00.150
those views.

00:19:00.150 --> 00:19:01.970
So as you probably
know, there's really

00:19:01.970 --> 00:19:05.750
no good way to fit a recycler
view adapter onto a slide.

00:19:05.750 --> 00:19:07.550
It's a lot of code
even in the best case,

00:19:07.550 --> 00:19:10.130
and I'm using data binding
to cheat a bit here.

00:19:10.130 --> 00:19:12.290
And several things just
aren't shown at all,

00:19:12.290 --> 00:19:14.720
like the diff callback for
helping to handle animations

00:19:14.720 --> 00:19:15.740
on data set changes.

00:19:15.740 --> 00:19:16.850
And we certainly
don't have anything

00:19:16.850 --> 00:19:18.770
about event handling in
here, but you kind of

00:19:18.770 --> 00:19:20.987
get the basic idea.

00:19:20.987 --> 00:19:23.570
So let's come back to this loop
in the Jetpack Compose version

00:19:23.570 --> 00:19:25.460
and see what else we can do.

00:19:25.460 --> 00:19:27.890
Well, this is Kotlin after all.

00:19:27.890 --> 00:19:30.260
We can define a generic
composable function that

00:19:30.260 --> 00:19:33.200
looks like a for each loop
by using a trailing lambda

00:19:33.200 --> 00:19:36.890
argument and have it emit each
story widget as it's asked for.

00:19:36.890 --> 00:19:40.190
So what we did here is we
just defined our recycler view

00:19:40.190 --> 00:19:42.540
adapter in one line of code.

00:19:42.540 --> 00:19:44.210
So the implementation
of the scrolling

00:19:44.210 --> 00:19:48.020
list itself can be just as
smart as a recycler view.

00:19:48.020 --> 00:19:50.390
The body that we pass to
a composable function call

00:19:50.390 --> 00:19:53.330
can itself be a
computable function lambda

00:19:53.330 --> 00:19:55.490
so that scrolling list
can choose to call it

00:19:55.490 --> 00:19:57.860
multiple times or not at all.

00:19:57.860 --> 00:20:00.380
Much more powerful than
just passing parameters

00:20:00.380 --> 00:20:03.230
through an include tag since
it means the scrolling list

00:20:03.230 --> 00:20:05.568
doesn't need to know anything
about what we're going

00:20:05.568 --> 00:20:06.860
to put in there when we use it.

00:20:06.860 --> 00:20:08.870
You can put entirely
different structures

00:20:08.870 --> 00:20:11.390
in here just depending on
code that you're running

00:20:11.390 --> 00:20:11.960
and defining.

00:20:14.280 --> 00:20:16.280
So we can do some other
kind of neat things too.

00:20:16.280 --> 00:20:17.905
We can offer some
really powerful hooks

00:20:17.905 --> 00:20:21.430
into our runtime for lifecycle
and subscription management

00:20:21.430 --> 00:20:22.960
that can work
together seamlessly

00:20:22.960 --> 00:20:27.045
with things like live data, RX
Java or the new Kotlin flows.

00:20:27.045 --> 00:20:29.170
So up until now, we can do
most of what we've shown

00:20:29.170 --> 00:20:30.850
here just with a clever DSL.

00:20:30.850 --> 00:20:36.010
But here, observe will return a
new value each time it changes

00:20:36.010 --> 00:20:39.670
and cause the news feed
function around it to run again.

00:20:39.670 --> 00:20:42.160
So that'll feed new data
to our scrolling list

00:20:42.160 --> 00:20:47.190
much like a recycler view
adapter data swap will.

00:20:47.190 --> 00:20:49.892
So observe as shown here is
just defined in library code.

00:20:49.892 --> 00:20:51.100
There's nothing special here.

00:20:51.100 --> 00:20:52.683
There's nothing that
we've implemented

00:20:52.683 --> 00:20:54.683
that's based on internal API.

00:20:54.683 --> 00:20:57.100
You can write your own, too,
if you have your own favorite

00:20:57.100 --> 00:20:59.360
observable or callback types.

00:20:59.360 --> 00:21:01.270
So what else does
this imply about how

00:21:01.270 --> 00:21:03.230
the scrolling list must work?

00:21:03.230 --> 00:21:05.110
So let's go ahead and
put it into something

00:21:05.110 --> 00:21:07.640
a little bit more sophisticated.

00:21:07.640 --> 00:21:09.850
So we saw with
observing a live data

00:21:09.850 --> 00:21:12.010
that we can trigger a
recomposition when something

00:21:12.010 --> 00:21:12.800
changes.

00:21:12.800 --> 00:21:15.160
So let's use an async
loading function that

00:21:15.160 --> 00:21:17.360
can give us a
placeholder immediately

00:21:17.360 --> 00:21:20.140
but the result of running
some sort of lazy loaded block

00:21:20.140 --> 00:21:21.610
once it's actually completed.

00:21:21.610 --> 00:21:24.940
So all of these sorts of
complex image loading scenarios

00:21:24.940 --> 00:21:26.620
that we're all
familiar with suddenly

00:21:26.620 --> 00:21:31.300
become something very simple
that we can use anywhere.

00:21:31.300 --> 00:21:33.490
And also like we saw
with the scrolling list,

00:21:33.490 --> 00:21:35.890
we can weave data across
layers of the hierarchy,

00:21:35.890 --> 00:21:38.590
and they don't have to be
direct tree children either.

00:21:38.590 --> 00:21:40.180
It doesn't matter
what kind of chrome

00:21:40.180 --> 00:21:43.480
or how many layers of hierarchy
that card or column might

00:21:43.480 --> 00:21:45.663
add in between in
order to do their work.

00:21:45.663 --> 00:21:47.830
So we can go further than
we can with something like

00:21:47.830 --> 00:21:51.070
data binding, and we can write
a whole lot less wire up code.

00:21:51.070 --> 00:21:54.160
We can just use the lexical
scope of that image or story

00:21:54.160 --> 00:21:57.240
that we already have, and we
can refer to the story headline

00:21:57.240 --> 00:21:58.240
several layers deep.

00:22:01.000 --> 00:22:02.680
This is really
part of what helps

00:22:02.680 --> 00:22:04.570
make composable
functions composable,

00:22:04.570 --> 00:22:06.200
how they're kind of
getting their name.

00:22:06.200 --> 00:22:08.075
We can leave this as is.

00:22:08.075 --> 00:22:09.700
I mean, it's a lot
of code for a slide,

00:22:09.700 --> 00:22:12.010
but it's not a lot to
glance at an editor.

00:22:12.010 --> 00:22:14.770
Or we can just use our
normal tools that we've got

00:22:14.770 --> 00:22:17.830
and highlight extract
method on any part of it

00:22:17.830 --> 00:22:19.720
and go ahead and generalize it.

00:22:19.720 --> 00:22:20.900
This isn't anything magic.

00:22:20.900 --> 00:22:22.525
It's just the same
tools and techniques

00:22:22.525 --> 00:22:25.340
that we're already used to
doing when we're writing code.

00:22:25.340 --> 00:22:28.960
So we've talked about how we
can observe changes in live data

00:22:28.960 --> 00:22:31.750
and we've seen how we can show
place holders while we request

00:22:31.750 --> 00:22:34.010
a data load from somewhere else.

00:22:34.010 --> 00:22:36.780
But what if we get an update to
one of our story data objects?

00:22:40.392 --> 00:22:42.600
So our story data that we
use as a parameter in there

00:22:42.600 --> 00:22:44.610
is really most
naturally represented

00:22:44.610 --> 00:22:45.810
as a Kotlin data class.

00:22:45.810 --> 00:22:48.102
There's really nothing
too special about it.

00:22:48.102 --> 00:22:50.310
But we'd like to be able to
update our UI if anything

00:22:50.310 --> 00:22:51.340
about it changes.

00:22:51.340 --> 00:22:54.060
What if this was mutable?

00:22:54.060 --> 00:22:56.880
So if it were a fragment, we
might use an arch components

00:22:56.880 --> 00:22:59.400
view model with some
live data as properties

00:22:59.400 --> 00:23:01.613
and use the same technique
that we saw earlier.

00:23:01.613 --> 00:23:04.030
But this is going to get really
repetitive really quickly,

00:23:04.030 --> 00:23:06.580
especially with all that
extra subscription management,

00:23:06.580 --> 00:23:08.940
we're kind of deciding
where all of this goes.

00:23:08.940 --> 00:23:13.010
Really we just wanted to write
that code from the last slide,

00:23:13.010 --> 00:23:14.290
and you can.

00:23:14.290 --> 00:23:17.240
So Composer's compiler plug-in
lets you mark a data class

00:23:17.240 --> 00:23:20.300
as a model which make the
properties observable when it's

00:23:20.300 --> 00:23:23.670
used in a compose function.

00:23:23.670 --> 00:23:26.450
Now, if our story
changes, the story widget

00:23:26.450 --> 00:23:29.570
that read its fields
will know to recompose.

00:23:29.570 --> 00:23:31.970
The Compose runtime
observes the changes

00:23:31.970 --> 00:23:35.090
and will cause the story widget
function to rerun and update

00:23:35.090 --> 00:23:36.290
our UI with the new data.

00:23:42.373 --> 00:23:44.290
JIM SPROCH: When you're
generalizing your code

00:23:44.290 --> 00:23:47.230
like that, it's really
important to break it up

00:23:47.230 --> 00:23:49.150
into multiple
compatible functions

00:23:49.150 --> 00:23:52.930
and understand how the data
flows through your application.

00:23:52.930 --> 00:23:55.120
The application passes data--

00:23:55.120 --> 00:23:56.860
in this case, a
list of stories--

00:23:56.860 --> 00:23:57.978
into the news feed.

00:23:57.978 --> 00:23:59.770
The news feed is then
going to iterate over

00:23:59.770 --> 00:24:01.870
this list of stories,
extracting each

00:24:01.870 --> 00:24:03.850
of the pieces of story
data from the list

00:24:03.850 --> 00:24:07.410
and passing one story
data to each story widget.

00:24:07.410 --> 00:24:10.690
The story widget then
reads the title, the image,

00:24:10.690 --> 00:24:14.050
and the content
from the story data.

00:24:14.050 --> 00:24:17.020
The important thing here is that
the parent is always in control

00:24:17.020 --> 00:24:19.000
of the data for the child.

00:24:19.000 --> 00:24:21.670
If the data needs to be shared
between multiple widgets,

00:24:21.670 --> 00:24:24.100
the data should be hoisted
up to a common ancestor

00:24:24.100 --> 00:24:26.740
and passed down to each of
the widgets that needs it.

00:24:26.740 --> 00:24:29.080
Children should not be
reading from global variables

00:24:29.080 --> 00:24:30.520
or global data stores.

00:24:30.520 --> 00:24:32.290
They should be a
side effect free

00:24:32.290 --> 00:24:33.970
and should not do
anything except what

00:24:33.970 --> 00:24:35.950
the parent tells them to do.

00:24:35.950 --> 00:24:38.350
As your application
scales, this architecture

00:24:38.350 --> 00:24:40.898
makes your code much
easier to reason about.

00:24:40.898 --> 00:24:42.940
But what happens if the
application wants to know

00:24:42.940 --> 00:24:45.010
when a user clicks on a story?

00:24:45.010 --> 00:24:47.590
One interesting pattern
is to pass lambdas down

00:24:47.590 --> 00:24:50.950
because code is data
which allows us to have

00:24:50.950 --> 00:24:52.960
events propagate upwards.

00:24:52.960 --> 00:24:55.760
It looks something like this.

00:24:55.760 --> 00:24:59.120
In this case, the news feed
takes an unselected lambda,

00:24:59.120 --> 00:25:03.610
which is going to take
in some story data, which

00:25:03.610 --> 00:25:05.320
is the current story.

00:25:05.320 --> 00:25:10.630
It will then, when the news
feed invokes the story widget,

00:25:10.630 --> 00:25:12.610
it's going to take
this lambda and create

00:25:12.610 --> 00:25:15.280
a new lambda of its own and
pass that lambda to the story

00:25:15.280 --> 00:25:16.320
widget.

00:25:16.320 --> 00:25:18.940
The story widget then
passes that lambda

00:25:18.940 --> 00:25:23.050
to a clickable widget, which
will respond to the click.

00:25:23.050 --> 00:25:26.140
When a user clicks on the story,
clicks on the clickable widget,

00:25:26.140 --> 00:25:28.510
the unclick will fire
which will cause the event

00:25:28.510 --> 00:25:31.480
to propagate back up
to the lambda that

00:25:31.480 --> 00:25:33.640
was created and passed in.

00:25:33.640 --> 00:25:35.193
This lambda will
call unselected,

00:25:35.193 --> 00:25:37.360
which is the lambda that
was passed to the news feed

00:25:37.360 --> 00:25:38.892
by the application.

00:25:38.892 --> 00:25:40.350
So the parent is
always in control.

00:25:40.350 --> 00:25:42.940
The data-- in this case, the
lambda-- is being passed down,

00:25:42.940 --> 00:25:45.370
and then the event
bubbles back up.

00:25:45.370 --> 00:25:46.970
If we look at this
in diagram form,

00:25:46.970 --> 00:25:49.660
we see that the application
starts with some data,

00:25:49.660 --> 00:25:52.360
passes it down to the news
feed, which passes it down

00:25:52.360 --> 00:25:54.970
to each of the story
widgets, which in turn pass

00:25:54.970 --> 00:25:57.820
the information down to the
composable building blocks that

00:25:57.820 --> 00:25:59.440
build up each widget.

00:25:59.440 --> 00:26:01.870
Then when a user clicks
on a piece of the widget,

00:26:01.870 --> 00:26:05.140
that triggers an event which
calls the lambdas going back

00:26:05.140 --> 00:26:08.080
up the hierarchy,
back up to the screen.

00:26:08.080 --> 00:26:11.500
Ultimately the application can
then update the applications

00:26:11.500 --> 00:26:14.170
data model and the
new data will be

00:26:14.170 --> 00:26:16.690
passed back down all
the way down until it's

00:26:16.690 --> 00:26:19.910
displayed onto the screen.

00:26:19.910 --> 00:26:22.720
Notice that the data was
always passed top down and data

00:26:22.720 --> 00:26:24.520
always comes in as parameters.

00:26:24.520 --> 00:26:27.070
The widget didn't have to
reference the activity.

00:26:27.070 --> 00:26:30.220
It didn't do anything
except code that

00:26:30.220 --> 00:26:33.660
was controlled by the parent.

00:26:33.660 --> 00:26:35.787
We'll come back to this
with the Spinner example.

00:26:35.787 --> 00:26:36.870
ADAM POWELL: That's right.

00:26:36.870 --> 00:26:40.110
So the Spinner has a problem
that the code that we just saw

00:26:40.110 --> 00:26:42.120
doesn't in that the
Spinner makes you deal

00:26:42.120 --> 00:26:45.060
with multiple sources of truth.

00:26:45.060 --> 00:26:49.440
So our app has a state,
the Spinner has a state,

00:26:49.440 --> 00:26:51.927
and the Spinner doesn't
ask us before letting

00:26:51.927 --> 00:26:53.010
the user change its state.

00:26:53.010 --> 00:26:55.020
That's the basic
shape of the problem.

00:26:55.020 --> 00:26:57.953
And there's two ways to solve
this when you have this,

00:26:57.953 --> 00:27:00.120
like one of these sides
must win if you want to have

00:27:00.120 --> 00:27:01.930
a single source of truth.

00:27:01.930 --> 00:27:04.260
So we could design some
of these components

00:27:04.260 --> 00:27:07.500
such that the Spinner itself
is the source of truth.

00:27:07.500 --> 00:27:09.750
And you could see how you
would put that together even

00:27:09.750 --> 00:27:11.640
with the API that we just saw.

00:27:11.640 --> 00:27:13.320
And it basically
looks like having

00:27:13.320 --> 00:27:15.540
to add a whole bunch
of validation APIs.

00:27:15.540 --> 00:27:17.730
It means that every
user interaction widget

00:27:17.730 --> 00:27:20.550
needs these fully
formed APIs for anything

00:27:20.550 --> 00:27:23.280
that you can change to sort of
filter through what you might

00:27:23.280 --> 00:27:27.210
do in order to validate that
what the user's inputting is

00:27:27.210 --> 00:27:29.910
actually correct.

00:27:29.910 --> 00:27:33.000
And it scales kind of poorly if
you're writing those components

00:27:33.000 --> 00:27:33.510
yourself.

00:27:33.510 --> 00:27:36.910
You want to have a case where
it's turtles all the way down.

00:27:36.910 --> 00:27:40.140
You want to make sure that it's
as easy to write a component

00:27:40.140 --> 00:27:42.330
as it is to consume a
component, so you kind of

00:27:42.330 --> 00:27:43.860
don't want everybody
to have to deal

00:27:43.860 --> 00:27:45.965
with writing all their
APIs twice, writing

00:27:45.965 --> 00:27:48.090
these sort of validation
filters for every property

00:27:48.090 --> 00:27:48.798
that you can set.

00:27:51.290 --> 00:27:53.297
So the other option
that we think

00:27:53.297 --> 00:27:55.130
is better that we're
certainly pitching here

00:27:55.130 --> 00:27:58.430
is to let the app
own its own data

00:27:58.430 --> 00:28:01.100
and have the apps backing data
model-- the source of truth

00:28:01.100 --> 00:28:02.850
that you're using
that's part of your data

00:28:02.850 --> 00:28:05.420
repository be the
source of truth instead.

00:28:05.420 --> 00:28:07.843
So this has a whole lot
of other advantages.

00:28:10.950 --> 00:28:13.760
JIM SPROCH: Let's take a
look at a concrete example.

00:28:13.760 --> 00:28:15.980
Here we have a food
preferences widget

00:28:15.980 --> 00:28:18.240
that we define as a
composable function.

00:28:18.240 --> 00:28:20.030
It takes in some
user preference data,

00:28:20.030 --> 00:28:22.550
and ultimately it
will emit a Spinner

00:28:22.550 --> 00:28:26.240
which has some set of options
that are available to the user.

00:28:26.240 --> 00:28:28.280
Notice that the
Spinner's data is

00:28:28.280 --> 00:28:30.120
set by the selected parameter.

00:28:30.120 --> 00:28:33.200
So the favorite food of
the user is passed directly

00:28:33.200 --> 00:28:33.860
to the Spinner.

00:28:33.860 --> 00:28:36.290
The parent widget, in this
case food preferences,

00:28:36.290 --> 00:28:38.810
is in control of what
the spinner is showing.

00:28:38.810 --> 00:28:41.750
And when the spinner
has a user indicate

00:28:41.750 --> 00:28:43.730
that they want to make
a change, the user

00:28:43.730 --> 00:28:46.790
can then execute
the unchange code

00:28:46.790 --> 00:28:49.183
which will result in
the data being updated.

00:28:49.183 --> 00:28:51.350
The Spinner doesn't know
which data is being updated

00:28:51.350 --> 00:28:53.630
or what to do, it
just calls on change.

00:28:53.630 --> 00:28:56.600
When the data does get
updated, this Compose function

00:28:56.600 --> 00:29:00.240
will get recoomposed and the
new selected value will be set.

00:29:02.820 --> 00:29:05.730
We can apply the same
approach to text.

00:29:05.730 --> 00:29:07.920
So in this case, we
have an editable text

00:29:07.920 --> 00:29:11.850
for the user's name, and all
that the unchanged handler does

00:29:11.850 --> 00:29:13.320
is set the name.

00:29:13.320 --> 00:29:15.300
This looks pretty
generic and you

00:29:15.300 --> 00:29:17.820
might wonder why the
editable text couldn't just

00:29:17.820 --> 00:29:19.690
set the text itself.

00:29:19.690 --> 00:29:21.540
But maintaining this
one-way dataflow

00:29:21.540 --> 00:29:23.920
allows us to do some
really interesting things.

00:29:23.920 --> 00:29:28.170
For example, if we have a phone
number preferences, then when

00:29:28.170 --> 00:29:32.230
a new potential value comes
in, we can do filtering.

00:29:32.230 --> 00:29:35.410
We can remove any
invalid characters,

00:29:35.410 --> 00:29:38.190
and then we can format the phone
number so that it looks nice

00:29:38.190 --> 00:29:40.075
when the user is typing it in.

00:29:40.075 --> 00:29:42.450
And then we set the data model
to the new formatted phone

00:29:42.450 --> 00:29:43.710
number.

00:29:43.710 --> 00:29:45.660
Again, this will
trigger a recomposition

00:29:45.660 --> 00:29:48.570
which will cause the editable
text to show the new value.

00:29:51.592 --> 00:29:53.800
ADAM POWELL: All right, so
let's go ahead and go back

00:29:53.800 --> 00:29:55.425
to some of our goals
from the beginning

00:29:55.425 --> 00:29:56.650
that we listed through.

00:29:56.650 --> 00:29:58.520
Did we actually meet
some of those goals?

00:29:58.520 --> 00:29:59.920
And I kind of think we did.

00:29:59.920 --> 00:30:02.860
So in order to meet
our unbundling goals,

00:30:02.860 --> 00:30:09.210
we're open sourcing a new UI API
and component set for Jetpack

00:30:09.210 --> 00:30:10.710
We've offered
computable functions

00:30:10.710 --> 00:30:12.810
that scale across these
layers of abstraction.

00:30:12.810 --> 00:30:14.940
A composable function
can do the same sorts

00:30:14.940 --> 00:30:17.760
of jobs as a fragment or
as a custom view group

00:30:17.760 --> 00:30:20.060
or even as something as
small as a single button.

00:30:23.500 --> 00:30:26.680
We've kind of established this
guideline of one-way observable

00:30:26.680 --> 00:30:28.998
dataflow as a
first class concept

00:30:28.998 --> 00:30:31.540
and we're building the system
to make it easy to sort of stay

00:30:31.540 --> 00:30:33.850
on this happy path.

00:30:33.850 --> 00:30:35.920
And finally, you have
less code and you

00:30:35.920 --> 00:30:37.240
can keep it in one place.

00:30:37.240 --> 00:30:39.910
You don't have to split your
focus across multiple files

00:30:39.910 --> 00:30:41.320
just to write a
piece of your UI.

00:30:44.500 --> 00:30:46.940
JIM SPROCH: OK, that
was a lot of information

00:30:46.940 --> 00:30:48.320
in one short talk,
and we're only

00:30:48.320 --> 00:30:49.970
just scratching the surface.

00:30:49.970 --> 00:30:51.860
Some of you look
excited and others

00:30:51.860 --> 00:30:53.580
might have a lot of questions.

00:30:53.580 --> 00:30:59.695
For example, what about
view compatibility?

00:30:59.695 --> 00:31:01.320
Will this work with
the existing views,

00:31:01.320 --> 00:31:04.590
and how do I integrate
this into my application?

00:31:04.590 --> 00:31:06.920
So one of the things
that you can do

00:31:06.920 --> 00:31:10.130
is have a annotation
that indicates

00:31:10.130 --> 00:31:14.580
that this code should be usable
from within a Android view.

00:31:14.580 --> 00:31:17.353
And when you do that, it
will generate a view class.

00:31:17.353 --> 00:31:18.770
This class is just
a standard view

00:31:18.770 --> 00:31:21.500
like any other from your
code possible function.

00:31:21.500 --> 00:31:24.600
And you can use it from
XML, as shown below,

00:31:24.600 --> 00:31:27.800
or you can call
the find view by ID

00:31:27.800 --> 00:31:30.470
and get a reference to the
node and pass data directly

00:31:30.470 --> 00:31:31.070
to the view.

00:31:37.920 --> 00:31:40.650
There's other things that
might be interesting to you.

00:31:40.650 --> 00:31:42.890
For example, we've been
giving a lot of thought

00:31:42.890 --> 00:31:45.133
to how Layout Editor and
Preview Tool would work.

00:31:45.133 --> 00:31:46.550
We've been giving
a lot of thought

00:31:46.550 --> 00:31:49.712
to animation, styles, themes,
and constraint layout.

00:31:49.712 --> 00:31:51.920
All of these things are
really important to get right

00:31:51.920 --> 00:31:53.990
before we go with
a stable release.

00:31:53.990 --> 00:31:56.360
And so we're going to make
sure that we have support

00:31:56.360 --> 00:31:58.220
for everything that
you would need to build

00:31:58.220 --> 00:31:59.852
beautiful applications.

00:31:59.852 --> 00:32:02.060
And we're still thinking
about a lot of other things.

00:32:02.060 --> 00:32:03.830
We're continuing
this exploration.

00:32:03.830 --> 00:32:06.260
We have ideas around
multi-threaded layout,

00:32:06.260 --> 00:32:08.390
around asynchronous
parallel execution

00:32:08.390 --> 00:32:11.960
of composable functions, around
memoization, and much more.

00:32:11.960 --> 00:32:14.390
All of these things
become feasible because

00:32:14.390 --> 00:32:15.950
of the declarative
programming model,

00:32:15.950 --> 00:32:18.500
and we encourage you to start
exploring these ideas with us.

00:32:18.500 --> 00:32:19.850
We'd love to hear your ideas.

00:32:22.660 --> 00:32:25.617
ROMAIN GUY: All right just
want to make one clarification.

00:32:25.617 --> 00:32:27.200
You saw an example
of Jetpack Composer

00:32:27.200 --> 00:32:28.310
that was using a Spinner.

00:32:28.310 --> 00:32:32.640
We don't have a spinner yet,
and it be called Spinner.

00:32:32.640 --> 00:32:33.530
[APPLAUSE]

00:32:33.530 --> 00:32:34.905
ADAM POWELL: How
are people going

00:32:34.905 --> 00:32:36.975
to understand what to use?

00:32:36.975 --> 00:32:38.600
ROMAIN GUY: But if
you really want one,

00:32:38.600 --> 00:32:41.720
you can build one,
that's the whole point.

00:32:41.720 --> 00:32:44.010
Yeah, so I just want
to reiterate that here,

00:32:44.010 --> 00:32:45.620
one of the key
elements is-- well,

00:32:45.620 --> 00:32:47.995
two key elements that I really
love-- first, composition.

00:32:47.995 --> 00:32:49.920
If you go look at the
source code in AOSP,

00:32:49.920 --> 00:32:52.370
you can look at how some of
the widgets were implemented

00:32:52.370 --> 00:32:53.888
and you'll see they
are that simple.

00:32:53.888 --> 00:32:55.430
You start to write
some code, but you

00:32:55.430 --> 00:32:57.388
should look at the
checkbox, for instance, it's

00:32:57.388 --> 00:32:59.710
just a few lines of code,
and everything it uses

00:32:59.710 --> 00:33:02.000
is available to you
to create your own.

00:33:02.000 --> 00:33:04.570
The one-way data flow model
is also really important

00:33:04.570 --> 00:33:07.070
because a lot of the bugs and
a lot of the [INAUDIBLE] plate

00:33:07.070 --> 00:33:09.680
in your code comes from
trying to keep two data

00:33:09.680 --> 00:33:11.790
models in sync at all time.

00:33:11.790 --> 00:33:14.400
And I mess that up all the time,
and I'm sure you do as well.

00:33:14.400 --> 00:33:16.490
So we just got rid of
the problem altogether.

00:33:16.490 --> 00:33:18.412
So Jetpack Composer is
not ready to ship yet.

00:33:18.412 --> 00:33:19.370
We've established that.

00:33:19.370 --> 00:33:21.110
Please go take a look
at the source code,

00:33:21.110 --> 00:33:24.800
if you go to
d.android.com/jetpackcompose,

00:33:24.800 --> 00:33:25.880
we have explanations.

00:33:25.880 --> 00:33:28.635
We have a readme that
explain how the source

00:33:28.635 --> 00:33:29.578
tree's architectured.

00:33:29.578 --> 00:33:32.120
You can run a special version
of Android Studio that will let

00:33:32.120 --> 00:33:33.655
you play with it, compile it.

00:33:33.655 --> 00:33:35.280
We have a few demos
that are available.

00:33:35.280 --> 00:33:37.520
You can look at the
entire source tree.

00:33:37.520 --> 00:33:40.160
But in the meantime,
you can get ready

00:33:40.160 --> 00:33:41.490
before this becomes available.

00:33:41.490 --> 00:33:43.447
So one thing you can do
is just play with it,

00:33:43.447 --> 00:33:45.530
but you can also try to
structure your application

00:33:45.530 --> 00:33:47.940
to try to fill this
one-way data flow model.

00:33:47.940 --> 00:33:49.550
So one thing you
can do already is

00:33:49.550 --> 00:33:51.680
try to eliminate
all the [INAUDIBLE]

00:33:51.680 --> 00:33:54.170
you have because every time
you do this, it's almost a

00:33:54.170 --> 00:33:54.710
[INAUDIBLE].

00:33:54.710 --> 00:33:56.865
Especially if you
called get on the view,

00:33:56.865 --> 00:33:58.490
that means you're
trying to synchronize

00:33:58.490 --> 00:34:00.500
the data model of the
view with the data all

00:34:00.500 --> 00:34:01.470
of your application.

00:34:01.470 --> 00:34:03.500
And this is a potential
source of bugs.

00:34:03.500 --> 00:34:06.380
And you won't be able to do
this anymore in Jetpack Compose

00:34:06.380 --> 00:34:08.210
because your functions,
your composables,

00:34:08.210 --> 00:34:10.190
just emit a new tree.

00:34:10.190 --> 00:34:15.000
At no point can you get a handle
on the actual, not physical,

00:34:15.000 --> 00:34:18.810
but the actual new view object
that will be put on screen.

00:34:18.810 --> 00:34:21.860
So you need to get rid of this
habit like basically right now.

00:34:24.440 --> 00:34:26.690
Also you can start looking
at architecture components.

00:34:26.690 --> 00:34:28.565
How many of you are
using the arch components

00:34:28.565 --> 00:34:29.870
in one form or another?

00:34:29.870 --> 00:34:31.909
All right, you are all awesome.

00:34:31.909 --> 00:34:35.679
Everybody who didn't raise their
hands, run back to your desk

00:34:35.679 --> 00:34:37.442
and go fix that please.

00:34:37.442 --> 00:34:39.650
So you have several things
you can use like ViewModel

00:34:39.650 --> 00:34:42.270
and LiveData, but there are
also other solutions out there,

00:34:42.270 --> 00:34:44.420
so please try to use those.

00:34:44.420 --> 00:34:46.383
And now we have a
few minutes left,

00:34:46.383 --> 00:34:48.050
so here's the URL
that you can check out

00:34:48.050 --> 00:34:50.550
if you want to know more, if
you want to find a source tree.

00:34:50.550 --> 00:34:53.080
[MUSIC PLAYING]

