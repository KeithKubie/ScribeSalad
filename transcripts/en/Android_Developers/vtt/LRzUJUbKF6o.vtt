WEBVTT
Kind: captions
Language: en

00:00:00.180 --> 00:00:02.013
JASON SANMIYA: Today
we're going to give you

00:00:02.013 --> 00:00:03.790
some compelling
reasons why you should

00:00:03.790 --> 00:00:07.330
start thinking about
performance in your games

00:00:07.330 --> 00:00:08.647
and VR experiences.

00:00:08.647 --> 00:00:10.480
And we're going to show
you some of the tech

00:00:10.480 --> 00:00:12.520
that our team has
developed to help you

00:00:12.520 --> 00:00:14.670
create high performance games.

00:00:14.670 --> 00:00:17.670
But first let me introduce
my good friend and colleague,

00:00:17.670 --> 00:00:19.652
Wouter van Oortmerssen.

00:00:19.652 --> 00:00:21.610
So Wouter has a background
in game development.

00:00:21.610 --> 00:00:25.220
He's worked at Crytek, Maxis,
and also at Gearbox, so one

00:00:25.220 --> 00:00:28.170
of my personal favorite
games, Borderlands.

00:00:28.170 --> 00:00:31.650
Wouter taught game
programming at the Guildhall,

00:00:31.650 --> 00:00:33.830
and he's created
several open source game

00:00:33.830 --> 00:00:36.510
engines and languages,
my favorite of which is

00:00:36.510 --> 00:00:39.970
the deliciously named Lobster.

00:00:39.970 --> 00:00:42.450
Wouter also speaks
six natural languages,

00:00:42.450 --> 00:00:45.810
seven if you include the one he
invented when he was a teenager

00:00:45.810 --> 00:00:49.422
and that only he and his
little sister understand.

00:00:49.422 --> 00:00:50.880
Overall, he's a
lovely fellow and I

00:00:50.880 --> 00:00:52.530
recommend getting to know him.

00:00:52.530 --> 00:00:53.360
All right?

00:00:53.360 --> 00:00:55.068
WOUTER VAN OORTMERSSEN:
Thank you, Jason.

00:00:55.068 --> 00:00:56.990
So let me introduce
Jason to you.

00:00:56.990 --> 00:00:59.660
So Jason also has a game
development background,

00:00:59.660 --> 00:01:01.580
particularly in animation.

00:01:01.580 --> 00:01:03.790
Before he joined
Google, he was working

00:01:03.790 --> 00:01:07.630
at Electronic Arts, where his
locomotion system was powering

00:01:07.630 --> 00:01:10.700
the Madden and FIFA franchises.

00:01:10.700 --> 00:01:14.840
So recently Jason led
our team to create

00:01:14.840 --> 00:01:18.260
our most recent sample
game, Zushi, that's

00:01:18.260 --> 00:01:19.610
available on the Play Store.

00:01:19.610 --> 00:01:21.100
We'll see it later.

00:01:21.100 --> 00:01:25.610
And most importantly, I think,
that Jason's stated life

00:01:25.610 --> 00:01:30.930
goal is that he wants to acquire
all life's acquired tastes.

00:01:30.930 --> 00:01:35.480
So I think you should
join him in that.

00:01:35.480 --> 00:01:37.360
JASON SANMIYA: Thanks, Wouter.

00:01:37.360 --> 00:01:38.830
Wouter and I work
on a team called

00:01:38.830 --> 00:01:41.330
Fun Propulsion Labs at Google.

00:01:41.330 --> 00:01:45.030
Our mission is to support
game developers just like you

00:01:45.030 --> 00:01:48.700
by creating cross-platform,
open source technology that you

00:01:48.700 --> 00:01:50.740
can use in your games.

00:01:50.740 --> 00:01:53.480
And not just games
that you're making now.

00:01:53.480 --> 00:01:55.320
We also want to
ensure that you're

00:01:55.320 --> 00:01:57.950
set up with the right
technology to help you make

00:01:57.950 --> 00:02:01.090
great games in the near future.

00:02:01.090 --> 00:02:03.310
So today we're going
to talk about 3D games

00:02:03.310 --> 00:02:04.144
and virtual reality.

00:02:04.144 --> 00:02:06.143
WOUTER VAN OORTMERSSEN:
And why we think they're

00:02:06.143 --> 00:02:08.430
going to be increasingly
large blips on your radar.

00:02:08.430 --> 00:02:09.972
JASON SANMIYA: Why
they're difficult.

00:02:09.972 --> 00:02:11.680
WOUTER VAN OORTMERSSEN:
And finally we're

00:02:11.680 --> 00:02:14.350
going to present some technology
that we've created in our team

00:02:14.350 --> 00:02:18.050
that we think will help
you succeed in 3D and VR.

00:02:18.050 --> 00:02:19.570
JASON SANMIYA:
Along the way we'll

00:02:19.570 --> 00:02:21.380
show you some of the
small sample games

00:02:21.380 --> 00:02:24.760
that our team has developed
to demonstrate our tech.

00:02:24.760 --> 00:02:27.910
For example, this
here, this is Pie Noon.

00:02:27.910 --> 00:02:32.860
It's a multiplayer standoff
game but with cherry pies.

00:02:32.860 --> 00:02:35.830
It's pretty serious
stuff that we do.

00:02:35.830 --> 00:02:38.700
But first and
quickly, why games?

00:02:38.700 --> 00:02:41.482
Serious developers make
serious apps, don't they?

00:02:41.482 --> 00:02:43.690
WOUTER VAN OORTMERSSEN:
Well, games are big business.

00:02:43.690 --> 00:02:45.310
I mean look at the Play Store.

00:02:45.310 --> 00:02:48.980
The majority of revenue from
the Play Store comes from games.

00:02:48.980 --> 00:02:50.770
JASON SANMIYA: Yes,
and the game market

00:02:50.770 --> 00:02:53.290
is expanding to new
demographics, too.

00:02:53.290 --> 00:02:57.870
As you can see here, the
demographic that likes, say,

00:02:57.870 --> 00:03:00.130
men screaming with
their mouths open,

00:03:00.130 --> 00:03:01.760
that's pretty well served today.

00:03:01.760 --> 00:03:04.020
But going forward,
new game genres

00:03:04.020 --> 00:03:06.900
are becoming more and
more popular as well.

00:03:06.900 --> 00:03:08.700
So entire new
demographics are going

00:03:08.700 --> 00:03:10.797
to come online and become
game consumers too.

00:03:10.797 --> 00:03:12.380
WOUTER VAN OORTMERSSEN:
But maybe they

00:03:12.380 --> 00:03:14.310
just have their mouths
open because they

00:03:14.310 --> 00:03:17.731
like the candy in
the adjacent games.

00:03:17.731 --> 00:03:19.480
JASON SANMIYA: It is
exactly the same face

00:03:19.480 --> 00:03:21.554
I made this morning
when I saw the donuts.

00:03:21.554 --> 00:03:22.970
WOUTER VAN
OORTMERSSEN: All right.

00:03:22.970 --> 00:03:24.910
So games make money
today, and they're

00:03:24.910 --> 00:03:27.391
going to make even
more money tomorrow.

00:03:30.040 --> 00:03:31.440
Why do we care
about performance?

00:03:31.440 --> 00:03:33.476
Games are pretty simple, no?

00:03:33.476 --> 00:03:35.600
JASON SANMIYA: It's true
that many of today's games

00:03:35.600 --> 00:03:37.470
are technically simple.

00:03:37.470 --> 00:03:39.650
Here's some of my
recent favorite games.

00:03:39.650 --> 00:03:41.840
Does anybody
recognize these games?

00:03:41.840 --> 00:03:43.692
Just call out the names.

00:03:43.692 --> 00:03:44.900
AUDIENCE: Ridiculous Fishing.

00:03:44.900 --> 00:03:46.316
JASON SANMIYA:
Ridiculous Fishing.

00:03:46.316 --> 00:03:48.000
Of course.

00:03:48.000 --> 00:03:49.150
Anyone else?

00:03:49.150 --> 00:03:50.602
How about the one in the middle?

00:03:50.602 --> 00:03:51.560
That's kind of obscure.

00:03:51.560 --> 00:03:52.750
It's called The Guides.

00:03:52.750 --> 00:03:54.810
Very odd game
worth checking out.

00:03:54.810 --> 00:03:57.050
And on the right
is Pop the Lock.

00:03:57.050 --> 00:04:01.340
So all of these games have
wonderful visual aesthetics,

00:04:01.340 --> 00:04:03.922
but technically they don't
really tax the hardware.

00:04:03.922 --> 00:04:06.380
WOUTER VAN OORTMERSSEN: So
games like these should probably

00:04:06.380 --> 00:04:09.830
still be optimized
for low end devices

00:04:09.830 --> 00:04:12.320
or just to save battery.

00:04:12.320 --> 00:04:14.500
But for the most
part, performance

00:04:14.500 --> 00:04:17.089
is not going to be on the
radar for these kind of games.

00:04:17.089 --> 00:04:19.649
But there are games that
do tax the hardware,

00:04:19.649 --> 00:04:23.460
and as game players get used
to these kind of visuals,

00:04:23.460 --> 00:04:25.460
they're going to
be expecting them.

00:04:25.460 --> 00:04:27.378
JASON SANMIYA: Anyone
know this game?

00:04:27.378 --> 00:04:28.720
AUDIENCE: The Wolf Among Us.

00:04:28.720 --> 00:04:29.886
JASON SANMIYA: That's right.

00:04:29.886 --> 00:04:31.660
The Wolf Among Us
by Telltale Games.

00:04:31.660 --> 00:04:34.800
So this game was
released in 2013

00:04:34.800 --> 00:04:39.810
on the Xbox, the PlayStation,
Windows, and Mac.

00:04:39.810 --> 00:04:42.486
And then soon after, it was
also released on mobile.

00:04:42.486 --> 00:04:43.860
So these screenshots
are actually

00:04:43.860 --> 00:04:46.770
from the Android version, and
I think they look amazing.

00:04:46.770 --> 00:04:48.520
WOUTER VAN OORTMERSSEN:
So mobile hardware

00:04:48.520 --> 00:04:49.900
is getting
increasingly powerful.

00:04:53.040 --> 00:04:56.070
So console game developers
are increasingly

00:04:56.070 --> 00:05:01.160
going to bring these
kind of games to mobile,

00:05:01.160 --> 00:05:03.870
and that's exactly
what they're doing.

00:05:03.870 --> 00:05:05.920
JASON SANMIYA: For
example, some of my friends

00:05:05.920 --> 00:05:08.600
that are still on FIFA
soccer, when they release

00:05:08.600 --> 00:05:14.140
FIFA 16 this year, they're
using a lot of the code

00:05:14.140 --> 00:05:17.060
that I wrote three years
ago before I joined Google.

00:05:17.060 --> 00:05:19.550
And this is code that we
really struggled to make run

00:05:19.550 --> 00:05:21.230
on the consoles at the time.

00:05:21.230 --> 00:05:23.260
But they just port it
over to mobile devices

00:05:23.260 --> 00:05:25.022
and it runs fine.

00:05:25.022 --> 00:05:26.730
And in fact, this is
something that a lot

00:05:26.730 --> 00:05:29.360
of console developers
really have to do,

00:05:29.360 --> 00:05:32.680
because the mobile game
market is growing much faster

00:05:32.680 --> 00:05:34.612
than the console and
the PC game market,

00:05:34.612 --> 00:05:36.320
so they need to start
bringing over these

00:05:36.320 --> 00:05:38.190
console games to mobile.

00:05:38.190 --> 00:05:39.773
WOUTER VAN OORTMERSSEN:
And then there

00:05:39.773 --> 00:05:42.580
is virtual reality, which is
intrinsically a 3D experience.

00:05:42.580 --> 00:05:45.014
So we think that
you're going to see

00:05:45.014 --> 00:05:47.180
more and more of these kind
of experiences on mobile

00:05:47.180 --> 00:05:49.680
pretty soon, and
less of the examples

00:05:49.680 --> 00:05:51.000
that we gave previously.

00:05:51.000 --> 00:05:51.480
JASON SANMIYA: Of
course, there's

00:05:51.480 --> 00:05:54.140
going to be plenty of both
styles of games, 2D, 3D,

00:05:54.140 --> 00:05:56.370
simple, complex.

00:05:56.370 --> 00:05:58.600
But still, console
games on mobile

00:05:58.600 --> 00:06:00.610
it's going to raise
consumer expectations,

00:06:00.610 --> 00:06:02.150
just like Wouter says.

00:06:02.150 --> 00:06:06.200
And this means if performance
isn't on your radar today,

00:06:06.200 --> 00:06:08.047
it probably will be
in the near future.

00:06:08.047 --> 00:06:09.630
WOUTER VAN OORTMERSSEN:
So we're going

00:06:09.630 --> 00:06:11.670
to have to start thinking
about performance.

00:06:11.670 --> 00:06:14.600
But how much do we have to start
thinking about performance?

00:06:14.600 --> 00:06:16.420
What happens when
you get it wrong?

00:06:16.420 --> 00:06:17.660
JASON SANMIYA: Good question.

00:06:17.660 --> 00:06:20.140
So this game is Tengami.

00:06:20.140 --> 00:06:22.950
It's a really
beautiful, smoothly

00:06:22.950 --> 00:06:27.650
animated game, the paper craft
world, and it kind of folds

00:06:27.650 --> 00:06:31.300
and unfolds like origami as
you go through the world.

00:06:31.300 --> 00:06:35.172
It's strangely calming
and kind of zen-like.

00:06:35.172 --> 00:06:37.380
WOUTER VAN OORTMERSSEN: So
for 3D games like Tengami,

00:06:37.380 --> 00:06:39.680
you want to ideally
hit a fixed frame rate

00:06:39.680 --> 00:06:43.230
of 30 to 60 frames per second.

00:06:43.230 --> 00:06:44.890
When you get
performance problems,

00:06:44.890 --> 00:06:46.940
then you're going to
drop frames and that's

00:06:46.940 --> 00:06:48.610
going to create stuttering.

00:06:48.610 --> 00:06:52.420
Now if your game is mostly
static without too much motion,

00:06:52.420 --> 00:06:55.210
you may be able to get away
with a little bit of stuttering.

00:06:55.210 --> 00:06:58.430
But if you have smooth
scrolling like Tengami has here,

00:06:58.430 --> 00:07:00.750
or a lot of camera motion,
then that stuttering

00:07:00.750 --> 00:07:02.440
is going to end up
being pretty jarring.

00:07:02.440 --> 00:07:03.981
JASON SANMIYA: And
dropped frames are

00:07:03.981 --> 00:07:06.080
even more of a problem in VR.

00:07:06.080 --> 00:07:07.560
So for cardboard,
you want to hit

00:07:07.560 --> 00:07:09.890
at least 60 frames per second.

00:07:09.890 --> 00:07:13.190
You might think, well,
if I hit 59 frames

00:07:13.190 --> 00:07:15.020
per second, that's good enough.

00:07:15.020 --> 00:07:19.250
But in VR, every dropped frame
is like snagging your eyeball

00:07:19.250 --> 00:07:20.645
on a rusty nail.

00:07:20.645 --> 00:07:22.020
WOUTER VAN
OORTMERSSEN: So you're

00:07:22.020 --> 00:07:25.690
saying that if I had 59
frames per second, that's

00:07:25.690 --> 00:07:28.280
like hitting my eyeball
on a rusty nail,

00:07:28.280 --> 00:07:30.375
like, once per
second effectively?

00:07:30.375 --> 00:07:32.820
JASON SANMIYA: That's exactly
how the math works out.

00:07:32.820 --> 00:07:36.120
But in less dramatic
terms, dropping frames

00:07:36.120 --> 00:07:38.650
means user fatigue
and discomforts

00:07:38.650 --> 00:07:40.989
and potentially even nausea.

00:07:40.989 --> 00:07:42.780
WOUTER VAN OORTMERSSEN:
So let's not forget

00:07:42.780 --> 00:07:44.580
about the next billion users.

00:07:44.580 --> 00:07:47.290
There's like a billion
of them, after all.

00:07:47.290 --> 00:07:49.710
JASON SANMIYA: And they're
going to have modern phones,

00:07:49.710 --> 00:07:51.810
but they may not be
the fastest phones.

00:07:51.810 --> 00:07:53.310
WOUTER VAN OORTMERSSEN:
For example,

00:07:53.310 --> 00:07:57.219
the Nexus 6P and the Android
1 are both great phones.

00:07:57.219 --> 00:07:58.760
But just because
your game runs great

00:07:58.760 --> 00:08:00.480
the Nexus 6P is
not going to mean

00:08:00.480 --> 00:08:03.580
it's going to run great on
the next billion Android 1s.

00:08:03.580 --> 00:08:06.050
JASON SANMIYA: And even if
you hit 60 frames per second,

00:08:06.050 --> 00:08:08.280
it's still worthwhile
considering performance,

00:08:08.280 --> 00:08:11.642
because wasted CPU cycles
mean wasted battery.

00:08:11.642 --> 00:08:13.100
WOUTER VAN OORTMERSSEN:
And battery

00:08:13.100 --> 00:08:15.570
is pretty important to
mobile game players.

00:08:15.570 --> 00:08:17.820
JASON SANMIYA: So when you're
playing a simple 2D game

00:08:17.820 --> 00:08:20.390
and your phone heats up
like it's a pocket warmer,

00:08:20.390 --> 00:08:23.370
that's a good sign that the
developer wasn't prioritizing

00:08:23.370 --> 00:08:24.440
performance.

00:08:24.440 --> 00:08:25.898
WOUTER VAN OORTMERSSEN:
So you said

00:08:25.898 --> 00:08:28.770
that mobile is going to become
more like a console experience.

00:08:28.770 --> 00:08:29.907
What does that imply?

00:08:29.907 --> 00:08:31.490
JASON SANMIYA: Well,
let's take a look

00:08:31.490 --> 00:08:34.580
at how current mobile
game development differs

00:08:34.580 --> 00:08:36.520
from current console
game development,

00:08:36.520 --> 00:08:38.380
and that might give
us a sense for where

00:08:38.380 --> 00:08:40.840
mobile development might go.

00:08:40.840 --> 00:08:44.010
So first off, mobile development
teams are quite small.

00:08:44.010 --> 00:08:46.030
Console development
teams, on the other hand,

00:08:46.030 --> 00:08:48.860
come in all sizes, some
of them quite large.

00:08:48.860 --> 00:08:52.510
With a small team you have
to limit your technology.

00:08:52.510 --> 00:08:55.190
But with a big team,
your technology stack

00:08:55.190 --> 00:08:57.477
is going to be
correspondingly large.

00:08:57.477 --> 00:08:59.810
WOUTER VAN OORTMERSSEN: So
to put it in a different way,

00:08:59.810 --> 00:09:02.665
many of you may be familiar
with the idea of a thin client,

00:09:02.665 --> 00:09:05.190
thick server model
that's very common in web

00:09:05.190 --> 00:09:07.270
apps and mobile apps.

00:09:07.270 --> 00:09:09.790
So what you get, if
you take mobile gaming

00:09:09.790 --> 00:09:13.120
and you add
console-style technology,

00:09:13.120 --> 00:09:15.810
is you get more of a
thick client, thick server

00:09:15.810 --> 00:09:19.600
model where you're doing
intensive rendering, physics,

00:09:19.600 --> 00:09:22.820
animation, all
that on the client,

00:09:22.820 --> 00:09:26.940
and you're still going to have
a rich server side component.

00:09:26.940 --> 00:09:28.606
So that gets pretty complicated.

00:09:28.606 --> 00:09:29.480
JASON SANMIYA: Right.

00:09:29.480 --> 00:09:30.290
OK, then.

00:09:30.290 --> 00:09:33.720
So when we're working with these
more technically complicated

00:09:33.720 --> 00:09:36.232
clients, what are some of
the performance problems

00:09:36.232 --> 00:09:37.440
that we're going to run into?

00:09:37.440 --> 00:09:40.960
WOUTER VAN OORTMERSSEN: So
let's first talk about memory.

00:09:40.960 --> 00:09:43.040
Unlike consoles,
you don't really

00:09:43.040 --> 00:09:45.950
have a guaranteed amount of
memory on a mobile device.

00:09:45.950 --> 00:09:49.030
And unlike PCs, you don't really
have virtual memory either.

00:09:49.030 --> 00:09:53.240
So what it means
is that it really

00:09:53.240 --> 00:09:55.690
depends on the
situation when Android's

00:09:55.690 --> 00:09:58.180
going to tell you that
you've had too much memory.

00:09:58.180 --> 00:10:01.120
So the only way to make sure
that your game fits in memory

00:10:01.120 --> 00:10:05.220
and stays in memory is use
as little as possible of it.

00:10:05.220 --> 00:10:07.650
And there's another good reason.

00:10:07.650 --> 00:10:09.610
Memory bandwidth
on mobile devices

00:10:09.610 --> 00:10:14.000
is very low compared to
equivalent PC or console

00:10:14.000 --> 00:10:15.150
devices.

00:10:15.150 --> 00:10:18.760
So you may see a mobile
device, and you go, like, wow,

00:10:18.760 --> 00:10:21.110
that thing has eight
cores in it and stuff,

00:10:21.110 --> 00:10:25.020
and until you realize that if
those eight cores all start

00:10:25.020 --> 00:10:28.504
touching memory, then things
grind to a halt pretty quickly.

00:10:28.504 --> 00:10:30.670
JASON SANMIYA: Then there's
the thermal consequences

00:10:30.670 --> 00:10:33.150
of using a lot of resources.

00:10:33.150 --> 00:10:35.020
Your CPU is going
to get throttled.

00:10:35.020 --> 00:10:38.260
So mobile hardware
was designed for apps,

00:10:38.260 --> 00:10:41.950
which means they're designed
to wake up, serve the user,

00:10:41.950 --> 00:10:44.800
and then idle for a little bit.

00:10:44.800 --> 00:10:46.480
When it's idling,
it gives the CPU

00:10:46.480 --> 00:10:48.970
some time to dissipate heat.

00:10:48.970 --> 00:10:50.520
But games, on the
other hand, are

00:10:50.520 --> 00:10:54.470
kind of using the system
evenly at all times.

00:10:54.470 --> 00:10:57.310
So this means that the heap can
just kind of build up and build

00:10:57.310 --> 00:11:01.010
up until the CPU frequency has
to be throttled back in order

00:11:01.010 --> 00:11:01.677
to dissipate it.

00:11:01.677 --> 00:11:03.301
WOUTER VAN OORTMERSSEN:
And because you

00:11:03.301 --> 00:11:06.150
don't control this throttling,
it kind of has this ping pong

00:11:06.150 --> 00:11:08.490
effect on your frame
rate, which is exactly

00:11:08.490 --> 00:11:11.560
the kind of thing that's going
to make your VR users nauseous.

00:11:11.560 --> 00:11:12.310
JASON SANMIYA: OK.

00:11:12.310 --> 00:11:16.380
So we need to hit 60 frames per
second with no dropped frames,

00:11:16.380 --> 00:11:19.317
especially when targeting VR.

00:11:19.317 --> 00:11:21.650
WOUTER VAN OORTMERSSEN: So
that's going to be hard to do

00:11:21.650 --> 00:11:26.090
in C++, and frankly, it's
almost impossible in Java.

00:11:26.090 --> 00:11:28.760
JASON SANMIYA: Now there's
probably some Java programmers

00:11:28.760 --> 00:11:32.927
in here, so it's probably worth
diving into this a little bit.

00:11:32.927 --> 00:11:35.510
Maybe you can tell us a little
bit what performance challenges

00:11:35.510 --> 00:11:37.980
people see when they
develop games in Java.

00:11:37.980 --> 00:11:38.770
WOUTER VAN OORTMERSSEN:
Well, first, of course,

00:11:38.770 --> 00:11:40.180
Java's garbage collection.

00:11:40.180 --> 00:11:42.950
And garbage collection does not
help you keep a stable frame

00:11:42.950 --> 00:11:44.990
rate because the garbage
collector is going

00:11:44.990 --> 00:11:47.984
to hit at a particular frame,
give you a very lengthy frame,

00:11:47.984 --> 00:11:49.900
and then another frame
is going to be shorter.

00:11:49.900 --> 00:11:52.030
That's exactly
what we don't want.

00:11:52.030 --> 00:11:56.010
But even besides that, typically
Java code is going to be

00:11:56.010 --> 00:12:00.270
slightly slower than the
equivalent C++ code for CPU

00:12:00.270 --> 00:12:04.560
stuff like physics, animation,
simulation, that kind of thing.

00:12:04.560 --> 00:12:07.600
So even if you can make it work,
even if you can make it fit

00:12:07.600 --> 00:12:10.450
somehow, then you're going to
end up burning more battery

00:12:10.450 --> 00:12:13.240
and generating more heat
than equivalent C++.

00:12:13.240 --> 00:12:15.540
JASON SANMIYA: It's a
really tricky situation.

00:12:15.540 --> 00:12:17.770
And it's one that's worth
considering very carefully

00:12:17.770 --> 00:12:19.990
because choosing a
language is something

00:12:19.990 --> 00:12:21.910
you do at the beginning.

00:12:21.910 --> 00:12:25.580
And optimizing your
program for performance

00:12:25.580 --> 00:12:27.980
is, unfortunately, something
you tend to do at the end.

00:12:27.980 --> 00:12:30.790
So if you get to the
end of your project

00:12:30.790 --> 00:12:33.350
and you have a lot of trouble
squeezing out performance

00:12:33.350 --> 00:12:36.870
because of the intrinsic
nature of your language,

00:12:36.870 --> 00:12:39.010
well, that's a real
sinking feeling.

00:12:39.010 --> 00:12:40.593
WOUTER VAN OORTMERSSEN:
And of course,

00:12:40.593 --> 00:12:44.150
with C++ you get this
cross-platform nature for free

00:12:44.150 --> 00:12:45.655
on mobile and desktop platforms.

00:12:45.655 --> 00:12:47.030
JASON SANMIYA:
And cross-platform

00:12:47.030 --> 00:12:50.940
is increasingly important as the
games become more complicated.

00:12:50.940 --> 00:12:54.240
So writing your game twice
for two different platforms

00:12:54.240 --> 00:12:58.121
in two different languages
is a very high cost to that.

00:12:58.121 --> 00:12:58.620
OK.

00:12:58.620 --> 00:13:00.420
We understand this
is challenging.

00:13:00.420 --> 00:13:03.340
C++ is kind of like a
double-barreled shotgun,

00:13:03.340 --> 00:13:05.540
but with 1,000 barrels
and they're all pointed

00:13:05.540 --> 00:13:06.454
at your foot.

00:13:06.454 --> 00:13:07.870
WOUTER VAN
OORTMERSSEN: But that's

00:13:07.870 --> 00:13:10.540
where our team comes in.
we're Fun Propulsion Labs

00:13:10.540 --> 00:13:12.209
and we're here to help.

00:13:12.209 --> 00:13:14.000
JASON SANMIYA: That's
our logo, by the way.

00:13:14.000 --> 00:13:16.200
So what do we do?

00:13:16.200 --> 00:13:18.810
WOUTER VAN OORTMERSSEN: So
we make C++ game development

00:13:18.810 --> 00:13:19.737
libraries.

00:13:19.737 --> 00:13:21.820
JASON SANMIYA: These
libraries are cross-platform,

00:13:21.820 --> 00:13:27.519
so they work on Android,
iOS, Windows, Mac, Linux,

00:13:27.519 --> 00:13:29.060
probably on consoles,
but they're not

00:13:29.060 --> 00:13:30.290
part of our test suites.

00:13:30.290 --> 00:13:31.914
In some cases they
work on the web too.

00:13:31.914 --> 00:13:34.297
They're all open source.

00:13:34.297 --> 00:13:35.630
They're all on GitHub right now.

00:13:35.630 --> 00:13:37.530
You can go download
them if you like.

00:13:37.530 --> 00:13:37.900
WOUTER VAN
OORTMERSSEN: And we've

00:13:37.900 --> 00:13:40.840
created them both for external
developers, game developers,

00:13:40.840 --> 00:13:42.950
and also for an internal
users at Google.

00:13:42.950 --> 00:13:44.116
JASON SANMIYA: That's right.

00:13:44.116 --> 00:13:46.625
They're all independent
libraries as well.

00:13:46.625 --> 00:13:49.000
WOUTER VAN OORTMERSSEN: But
let's stop for a second here.

00:13:49.000 --> 00:13:52.150
Probably people have the
question, why libraries?

00:13:52.150 --> 00:13:55.200
Most people will have an
existing engine, right?

00:13:55.200 --> 00:13:58.490
JASON SANMIYA: So from what
we've seen, more than half

00:13:58.490 --> 00:14:02.100
of game developers are
actually using a custom engine.

00:14:02.100 --> 00:14:03.620
So there's a lot
of game developers

00:14:03.620 --> 00:14:06.470
that don't want to buy
into monolithic third party

00:14:06.470 --> 00:14:07.980
technology.

00:14:07.980 --> 00:14:10.210
So by providing
separate libraries,

00:14:10.210 --> 00:14:13.580
we allow game developers to
adopt our technology piecemeal.

00:14:13.580 --> 00:14:15.670
They can just use
whatever they need

00:14:15.670 --> 00:14:17.910
and fit it with what
they already have.

00:14:17.910 --> 00:14:19.910
And even if they are using
a third party engine,

00:14:19.910 --> 00:14:21.826
if there's something out
there that they like,

00:14:21.826 --> 00:14:25.190
they can just grab that and
jury rig it into their engine

00:14:25.190 --> 00:14:25.700
as well.

00:14:25.700 --> 00:14:26.950
WOUTER VAN OORTMERSSEN: Great.

00:14:26.950 --> 00:14:28.870
So let's talk about
these libraries

00:14:28.870 --> 00:14:31.612
and how they can help you
make more efficient games.

00:14:31.612 --> 00:14:32.820
JASON SANMIYA: OK, excellent.

00:14:32.820 --> 00:14:33.903
Let's start at the bottom.

00:14:33.903 --> 00:14:35.677
Wouter, how do we store stuff?

00:14:35.677 --> 00:14:37.260
WOUTER VAN OORTMERSSEN:
Well, for that

00:14:37.260 --> 00:14:40.230
we have FlatBuffers, which
is our serialization library.

00:14:40.230 --> 00:14:44.186
It works for games and it
works for anything, really.

00:14:44.186 --> 00:14:45.560
As you all know,
serialization is

00:14:45.560 --> 00:14:49.100
about how we load,
store, and encode stuff.

00:14:49.100 --> 00:14:54.260
And that is very vital for
a memory efficient game.

00:14:54.260 --> 00:14:57.100
Now what is special
about FlatBuffers

00:14:57.100 --> 00:14:59.720
is that it is a format
that works equally

00:14:59.720 --> 00:15:02.910
well on disk and in memory,
so you don't actually

00:15:02.910 --> 00:15:03.994
have to unpack it.

00:15:03.994 --> 00:15:04.785
JASON SANMIYA: Wow.

00:15:08.080 --> 00:15:09.980
WOUTER VAN
OORTMERSSEN: Nice one.

00:15:09.980 --> 00:15:12.380
So this saves on parsing time.

00:15:12.380 --> 00:15:15.170
It means you don't have any
object allocation whatsoever.

00:15:15.170 --> 00:15:17.600
It generally
reduces memory usage

00:15:17.600 --> 00:15:21.580
and it is more cache efficient.

00:15:21.580 --> 00:15:24.280
So what I want to say
is if your project, game

00:15:24.280 --> 00:15:26.280
or not-- if it uses
JSON or protocol

00:15:26.280 --> 00:15:29.240
buffers or some other
serialization solution,

00:15:29.240 --> 00:15:31.647
you can probably benefit
from using FlatBuffers.

00:15:31.647 --> 00:15:33.230
JASON SANMIYA: Let
me interrupt there.

00:15:33.230 --> 00:15:36.850
Interesting fact that
JSON format is so amazing,

00:15:36.850 --> 00:15:38.480
they named it after me.

00:15:38.480 --> 00:15:40.270
WOUTER VAN OORTMERSSEN:
That is not true.

00:15:40.270 --> 00:15:41.870
JASON SANMIYA: It's not true.

00:15:41.870 --> 00:15:43.245
WOUTER VAN
OORTMERSSEN: But it is

00:15:43.245 --> 00:15:45.160
a good idea, which is
why FlatBuffers first

00:15:45.160 --> 00:15:46.945
has JSON parsing built in.

00:15:46.945 --> 00:15:47.820
JASON SANMIYA: Right.

00:15:47.820 --> 00:15:49.445
WOUTER VAN OORTMERSSEN:
Yes, languages.

00:15:49.445 --> 00:15:53.880
So we originally designed
FlatBuffers for C++ and game

00:15:53.880 --> 00:15:55.020
development.

00:15:55.020 --> 00:15:57.840
But we also have support for
your favorite programming

00:15:57.840 --> 00:16:00.590
language, assuming your favorite
programming language is one

00:16:00.590 --> 00:16:10.050
of C, C++, Java, C#, Go,
Python, JavaScript, PHP, Swift,

00:16:10.050 --> 00:16:11.620
et cetera.

00:16:11.620 --> 00:16:14.560
And that's just in case that
your tools or servers are

00:16:14.560 --> 00:16:16.060
written in something
other than C++.

00:16:16.060 --> 00:16:18.351
JASON SANMIYA: And sometimes
that makes a lot of sense.

00:16:18.351 --> 00:16:19.980
WOUTER VAN
OORTMERSSEN: Sometimes.

00:16:19.980 --> 00:16:20.900
OK.

00:16:20.900 --> 00:16:24.280
You know what's also fundamental
is all this math that games

00:16:24.280 --> 00:16:24.920
use.

00:16:24.920 --> 00:16:26.450
How do we deal with that?

00:16:26.450 --> 00:16:29.230
JASON SANMIYA: We have
a library called MathFu,

00:16:29.230 --> 00:16:32.400
and it implements a lot of
common geometry functions,

00:16:32.400 --> 00:16:34.940
and it's designed to
be simple and fast.

00:16:34.940 --> 00:16:39.840
So by geometry we mean the
math on vectors and matrices,

00:16:39.840 --> 00:16:43.260
usually two, three, four,
dimensions, sometimes more.

00:16:43.260 --> 00:16:46.350
Rendering, physics,
animation, AI, they all

00:16:46.350 --> 00:16:50.090
use this kind of math, anything
that deals with physical space

00:16:50.090 --> 00:16:52.930
and calculations within it.

00:16:52.930 --> 00:16:55.700
Of course, there is other
open source math libraries

00:16:55.700 --> 00:16:59.620
out there, some of them very
good, like Eigen and TLM.

00:16:59.620 --> 00:17:01.780
But we wanted one
that was very simple

00:17:01.780 --> 00:17:04.089
and focused on the math
that was required for games,

00:17:04.089 --> 00:17:07.050
and not necessarily, say,
for scientific applications,

00:17:07.050 --> 00:17:10.980
like Eigen is very good at.

00:17:10.980 --> 00:17:12.710
We also wanted to
make a library that

00:17:12.710 --> 00:17:16.060
was extremely fast, because
it's the foundation for all

00:17:16.060 --> 00:17:17.319
of our other libraries.

00:17:17.319 --> 00:17:20.640
So we spent a lot of
time benchmarking MathFu

00:17:20.640 --> 00:17:22.420
and optimizing it
where appropriate.

00:17:22.420 --> 00:17:24.329
For example, many
of the functions

00:17:24.329 --> 00:17:25.920
use Symbian
instructions, especially

00:17:25.920 --> 00:17:27.480
the matrix operations.

00:17:27.480 --> 00:17:31.840
So this is like SSE instructions
and NEON instructions.

00:17:31.840 --> 00:17:35.377
These leverage the vector
processing unit on the chips.

00:17:35.377 --> 00:17:36.960
WOUTER VAN OORTMERSSEN:
I think you're

00:17:36.960 --> 00:17:38.660
losing the audience, Jason.

00:17:38.660 --> 00:17:39.100
JASON SANMIYA: Am I really?

00:17:39.100 --> 00:17:40.160
WOUTER VAN OORTMERSSEN: Yeah.

00:17:40.160 --> 00:17:40.660
Technical.

00:17:40.660 --> 00:17:42.560
JASON SANMIYA:
Anyway, it's fast.

00:17:42.560 --> 00:17:44.010
So we have data and math.

00:17:44.010 --> 00:17:46.130
Wouter, what do we need next?

00:17:46.130 --> 00:17:47.590
WOUTER VAN
OORTMERSSEN: So FPLBase

00:17:47.590 --> 00:17:50.040
is our lowest level
game library that we

00:17:50.040 --> 00:17:53.650
use for rendering, inputs,
loading resources, things

00:17:53.650 --> 00:17:56.890
like shaders, meshes,
textures, anything

00:17:56.890 --> 00:18:00.590
that you need to get a
game on screen, basically.

00:18:00.590 --> 00:18:02.530
It also has useful
functionality for dealing

00:18:02.530 --> 00:18:05.500
with input devices and VR.

00:18:05.500 --> 00:18:07.780
It also has threaded
resource loading.

00:18:07.780 --> 00:18:11.730
FPLBase was intended
as a way to go

00:18:11.730 --> 00:18:15.430
from an empty project
to drawing something

00:18:15.430 --> 00:18:18.490
on screen as fast as possible
with as little code as

00:18:18.490 --> 00:18:19.926
possible.

00:18:19.926 --> 00:18:21.550
So it has all the
minimal functionality

00:18:21.550 --> 00:18:24.710
that you typically
don't get when you

00:18:24.710 --> 00:18:27.760
work on top of raw open gel.

00:18:27.760 --> 00:18:30.182
Now it's on purpose not
meant to be an engine.

00:18:30.182 --> 00:18:32.390
It's not dictating how your
game should be structured

00:18:32.390 --> 00:18:33.400
or anything like that.

00:18:33.400 --> 00:18:37.380
It's just meant to be simple
and easy and quick to get going.

00:18:37.380 --> 00:18:40.220
So it works on all platforms,
mobile and desktop,

00:18:40.220 --> 00:18:41.350
thanks to SDL.

00:18:41.350 --> 00:18:43.562
JASON SANMIYA: SDL is the
simple direct media layer.

00:18:43.562 --> 00:18:45.520
WOUTER VAN OORTMERSSEN:
And other FPL libraries

00:18:45.520 --> 00:18:48.490
may be used on top of it.

00:18:48.490 --> 00:18:50.780
So now that we
can render things,

00:18:50.780 --> 00:18:55.380
what's the next thing to
make our games come to life?

00:18:55.380 --> 00:18:57.300
JASON SANMIYA: So
animation, I think,

00:18:57.300 --> 00:18:59.470
is a really great way to
bring your games to life.

00:18:59.470 --> 00:19:01.261
WOUTER VAN OORTMERSSEN:
You would say that.

00:19:01.261 --> 00:19:03.684
JASON SANMIYA: And Motive
is our animation system.

00:19:03.684 --> 00:19:05.850
It's a really great way to
bring character and charm

00:19:05.850 --> 00:19:06.690
to your games.

00:19:06.690 --> 00:19:08.500
Animation is kind of
intimidating to a lot

00:19:08.500 --> 00:19:09.083
of developers.

00:19:09.083 --> 00:19:11.500
There's just a lot of ways to
move something from point A

00:19:11.500 --> 00:19:14.180
to point B. And
some of them have

00:19:14.180 --> 00:19:18.460
a lot of feeling and intent,
but others just kind of look

00:19:18.460 --> 00:19:19.570
robotic.

00:19:19.570 --> 00:19:25.100
So the goal of Motive is to make
it easy to animate everything

00:19:25.100 --> 00:19:27.990
smooth and intensely.

00:19:27.990 --> 00:19:31.060
So to do this, we made
the runtime extremely fast

00:19:31.060 --> 00:19:32.990
because often there's
a lot in your scene

00:19:32.990 --> 00:19:34.877
that needs to be animated.

00:19:34.877 --> 00:19:37.210
It computes values in bulk
with the Symbian instructions

00:19:37.210 --> 00:19:38.650
I was talking about.

00:19:38.650 --> 00:19:41.340
The memory format is
also very compact,

00:19:41.340 --> 00:19:44.640
and this helps with the memory
bandwidth limitations that's

00:19:44.640 --> 00:19:46.295
intrinsic to mobile devices.

00:19:49.490 --> 00:19:51.830
With Motive you can
drive animations

00:19:51.830 --> 00:19:54.380
with pre-authored
splines, or you can also

00:19:54.380 --> 00:20:00.320
drive it procedurally
to, say, naturally follow

00:20:00.320 --> 00:20:02.620
a moving target.

00:20:02.620 --> 00:20:05.140
OK, so now we're
going to show you

00:20:05.140 --> 00:20:07.540
one of our sample
games, Pie Noon,

00:20:07.540 --> 00:20:11.460
to give you an idea of
how simple motion can

00:20:11.460 --> 00:20:12.922
help bring a game to life.

00:20:12.922 --> 00:20:15.874
[BEGIN VIDEO PLAYBACK]

00:20:43.367 --> 00:20:43.950
[END PLAYBACK]

00:20:43.950 --> 00:20:44.700
JASON SANMIYA: OK.

00:20:44.700 --> 00:20:47.490
So most of the animation in Pie
Noon is actually procedural.

00:20:47.490 --> 00:20:51.910
But in our next game, Zushi, we
support fully-rigged character

00:20:51.910 --> 00:20:52.880
animation.

00:20:52.880 --> 00:20:55.440
So the dapper crocodile
here will do a little jig

00:20:55.440 --> 00:20:59.420
when you feed him a piece of
sushi, as you would expect.

00:20:59.420 --> 00:21:03.300
And the jig animation is created
using third party animation

00:21:03.300 --> 00:21:05.930
authoring tools like
Maya or Blender,

00:21:05.930 --> 00:21:09.320
and it's brought into our
game via an animation pipeline

00:21:09.320 --> 00:21:10.420
that we've written.

00:21:10.420 --> 00:21:13.680
So we'll show you a
video of Zushi in a bit.

00:21:13.680 --> 00:21:15.890
OK, Wouter, so we've
got this game animated.

00:21:15.890 --> 00:21:18.000
How do we communicate
with the user?

00:21:18.000 --> 00:21:20.310
Well for that we have FlatUI.

00:21:20.310 --> 00:21:24.000
So FlatUI is an
immediate mode UI library

00:21:24.000 --> 00:21:26.190
that's meant to make
it simple, easy,

00:21:26.190 --> 00:21:31.560
and efficient to add menus,
HUDs, and other elements

00:21:31.560 --> 00:21:33.130
to your game.

00:21:33.130 --> 00:21:36.210
So let's talk a little bit
about what this immediate mode

00:21:36.210 --> 00:21:37.910
thing means.

00:21:37.910 --> 00:21:40.730
It means that rather than
constructing your UI using

00:21:40.730 --> 00:21:43.020
objects and callbacks
and things like that,

00:21:43.020 --> 00:21:46.930
you actually construct
UI by function calls

00:21:46.930 --> 00:21:49.420
that you create your
UI every frame again.

00:21:49.420 --> 00:21:52.000
Now that has a whole
bunch of advantages.

00:21:52.000 --> 00:21:54.660
For example, first of
all there's less code.

00:21:54.660 --> 00:21:57.700
There's less set of work
to do, and simple UIs

00:21:57.700 --> 00:22:00.530
are pretty simple to get going.

00:22:00.530 --> 00:22:02.510
It's much easier to
do than dynamic UI

00:22:02.510 --> 00:22:06.460
because if you don't call
a particular UI snippet,

00:22:06.460 --> 00:22:07.680
it does not appear on screen.

00:22:07.680 --> 00:22:10.800
So there is no adding and
removing of objects or anything

00:22:10.800 --> 00:22:12.680
like that needs to happen.

00:22:12.680 --> 00:22:14.440
It also means that
your UI is always

00:22:14.440 --> 00:22:17.262
consistent with your game
state because you actually

00:22:17.262 --> 00:22:23.310
can't forget to set
some state on your UI.

00:22:23.310 --> 00:22:26.374
Event handling is all local,
so it's right there in place

00:22:26.374 --> 00:22:28.040
when you're constructing
your UI and you

00:22:28.040 --> 00:22:29.660
have the data right there.

00:22:29.660 --> 00:22:31.220
So there's no
callbacks happening

00:22:31.220 --> 00:22:33.690
that might execute on
a different context

00:22:33.690 --> 00:22:35.370
or something like that.

00:22:35.370 --> 00:22:38.034
And it's very easy to
make custom UI elements

00:22:38.034 --> 00:22:39.950
because you can just
combine multiple function

00:22:39.950 --> 00:22:42.830
calls into one.

00:22:42.830 --> 00:22:44.740
For example, here's
a contrived example

00:22:44.740 --> 00:22:47.090
in the slide where we
have two UI elements

00:22:47.090 --> 00:22:49.510
like a label and a button.

00:22:49.510 --> 00:22:51.730
And as you can see, they're
just function calls.

00:22:51.730 --> 00:22:55.390
The event handling is
just an if then statement.

00:22:55.390 --> 00:22:57.760
And for the state
that we're managing,

00:22:57.760 --> 00:22:59.890
we can just use
any variable that

00:22:59.890 --> 00:23:04.270
happens to be the scope over
here, making it pretty simple.

00:23:04.270 --> 00:23:07.420
Now FlatUI has a couple of
additional cool features.

00:23:07.420 --> 00:23:11.640
So first of all, has very robust
front rendering that is Unicode

00:23:11.640 --> 00:23:14.230
internationalization aware.

00:23:14.230 --> 00:23:17.180
It generally uses
amazingly little memory.

00:23:17.180 --> 00:23:19.620
Beyond any textures and
fonts that you load,

00:23:19.620 --> 00:23:21.050
it pretty much uses no memory.

00:23:21.050 --> 00:23:23.150
JASON SANMIYA: That's kind of
a theme you're seeing here.

00:23:23.150 --> 00:23:24.358
WOUTER VAN OORTMERSSEN: Yeah.

00:23:24.358 --> 00:23:26.790
Yeah, exactly.

00:23:26.790 --> 00:23:29.905
Importantly, it can
render things into 3D.

00:23:29.905 --> 00:23:32.430
If you're doing
VR, for example, it

00:23:32.430 --> 00:23:34.070
does automatic
layout of everything

00:23:34.070 --> 00:23:38.240
using virtual sizes, which
means that your UIs look great

00:23:38.240 --> 00:23:40.220
on any screen.

00:23:40.220 --> 00:23:42.280
And it doesn't dictate a style.

00:23:42.280 --> 00:23:47.390
If you can render it, it
can be restyled, basically.

00:23:47.390 --> 00:23:50.300
So Jason, you already
spoke about animation.

00:23:50.300 --> 00:23:52.900
What else can you give us
that makes games come alive?

00:23:52.900 --> 00:23:54.650
JASON SANMIYA: One of
our first libraries,

00:23:54.650 --> 00:23:57.830
and one of the more popular,
is a liquid physics simulator

00:23:57.830 --> 00:23:58.910
called Liquid Fun.

00:23:58.910 --> 00:24:02.630
Liquid Fun is a drop in
extension for the popular box

00:24:02.630 --> 00:24:04.690
2D physics engine.

00:24:04.690 --> 00:24:08.430
It's a really simple way to add
2D liquid, gas, and particle

00:24:08.430 --> 00:24:10.200
effects to your game.

00:24:10.200 --> 00:24:13.470
The runtime algorithm
is kind of clever,

00:24:13.470 --> 00:24:15.330
and it's extremely efficient.

00:24:15.330 --> 00:24:18.220
So you'd probably be surprised
at how much complicated motion

00:24:18.220 --> 00:24:19.950
it can create.

00:24:19.950 --> 00:24:22.020
One of our other sample
games we'll show you

00:24:22.020 --> 00:24:23.569
here is called
Liquid Fun Paints.

00:24:23.569 --> 00:24:25.610
We'll just show you the
beginning of this trailer

00:24:25.610 --> 00:24:28.258
so you get a sense for
what the library does.

00:24:28.258 --> 00:24:47.710
[BEGIN VIDEO PLAYBACK]

00:25:05.557 --> 00:25:06.140
[END PLAYBACK]

00:25:06.140 --> 00:25:06.430
JASON SANMIYA: OK.

00:25:06.430 --> 00:25:07.221
So that's the idea.

00:25:07.221 --> 00:25:10.650
That's a really fun app you can
also find in the Play Store.

00:25:10.650 --> 00:25:12.810
A lot of kids love
it, like Wouter.

00:25:16.040 --> 00:25:18.000
WOUTER VAN OORTMERSSEN:
Thanks, Jason.

00:25:18.000 --> 00:25:20.980
So our next library is PinDrop,
which is our audio solution.

00:25:20.980 --> 00:25:23.500
So what's special
about PinDrop is

00:25:23.500 --> 00:25:26.020
that it goes beyond
just mere audio mixing.

00:25:26.020 --> 00:25:29.740
For example, it handles
prioritization and attenuation.

00:25:29.740 --> 00:25:31.410
That means that if
you have a game scene

00:25:31.410 --> 00:25:33.580
and suddenly there's
a lot of events,

00:25:33.580 --> 00:25:35.954
a lot of gameplay events
triggering a lot of sounds,

00:25:35.954 --> 00:25:37.370
that the system
will automatically

00:25:37.370 --> 00:25:40.300
take care of making that into a
coherent audio picture for you,

00:25:40.300 --> 00:25:41.670
basically.

00:25:41.670 --> 00:25:45.210
It also allows you to
group and selectively

00:25:45.210 --> 00:25:48.990
override relative importance
of whole groups of sounds.

00:25:48.990 --> 00:25:51.700
For example, if you want to
make sure that voiceovers get

00:25:51.700 --> 00:25:55.070
heard and things like that.

00:25:55.070 --> 00:25:57.090
Not unimportantly,
it's very data-driven,

00:25:57.090 --> 00:26:00.080
which means that people
that author the audio don't

00:26:00.080 --> 00:26:02.020
need to do any programming.

00:26:02.020 --> 00:26:03.774
It's pretty cool.

00:26:03.774 --> 00:26:05.940
JASON SANMIYA: Corgi is our
entity component system.

00:26:05.940 --> 00:26:07.520
Now entity component
systems have

00:26:07.520 --> 00:26:12.000
emerged as a popular
programming paradigm in games.

00:26:12.000 --> 00:26:14.660
So they allow you to
associate component behaviors

00:26:14.660 --> 00:26:16.180
with entities in the scene.

00:26:16.180 --> 00:26:21.330
For example, suppose I could
add an animation component

00:26:21.330 --> 00:26:25.260
to a dog entity, and this would
allow the dog to roll over.

00:26:25.260 --> 00:26:27.960
Or we could add an audio
component to the dog,

00:26:27.960 --> 00:26:31.310
and that would allow
the dog to bark.

00:26:31.310 --> 00:26:35.350
And instead of storing the
roll over and barking data

00:26:35.350 --> 00:26:37.590
with the dog entity,
we instead group

00:26:37.590 --> 00:26:41.140
all the animation data in one
spot, and all the audio data

00:26:41.140 --> 00:26:44.010
in another spot,
and this allows you

00:26:44.010 --> 00:26:46.740
to have significantly
better memory performance

00:26:46.740 --> 00:26:50.870
when you're operating on data in
bulk, as you have to in games.

00:26:50.870 --> 00:26:53.910
So note the contrast here
between object oriented

00:26:53.910 --> 00:26:57.960
programming and component
oriented programming.

00:26:57.960 --> 00:27:01.640
So the behaviors
and the data are

00:27:01.640 --> 00:27:05.359
stored with the entity in
object oriented programming.

00:27:05.359 --> 00:27:07.400
So entity component systems,
there's nothing new.

00:27:07.400 --> 00:27:09.630
If you're making a game
you probably have your own.

00:27:09.630 --> 00:27:13.030
So what we've done with Corgi
is simply package and document

00:27:13.030 --> 00:27:16.290
well the one that we wrote,
and put it up on GitHub

00:27:16.290 --> 00:27:18.720
for you to use if you like.

00:27:18.720 --> 00:27:22.670
Corgi, by the way, stands for
Component Organized Reusable

00:27:22.670 --> 00:27:24.400
Game Interface.

00:27:24.400 --> 00:27:27.550
But mostly we chose the
name because of this guy.

00:27:27.550 --> 00:27:32.400
He's kind of our unofficial
project manager on FPL.

00:27:32.400 --> 00:27:34.660
I mean, you can't say
no to those eyes, right?

00:27:34.660 --> 00:27:37.890
WOUTER VAN OORTMERSSEN: So
SceneLab is our scene editor.

00:27:37.890 --> 00:27:41.940
SceneLab kind of takes all these
previous libraries together,

00:27:41.940 --> 00:27:45.430
so it uses Corgi for the
objects that it edits,

00:27:45.430 --> 00:27:47.940
uses FlatBuffers for all
of its data, of course,

00:27:47.940 --> 00:27:50.760
and it uses FlatUI.

00:27:50.760 --> 00:27:54.210
The cool thing about SceneLab is
that it's so data-driven and so

00:27:54.210 --> 00:27:57.350
configurable that if you pass
it different kinds of object

00:27:57.350 --> 00:28:00.580
definitions, it will
automatically allow

00:28:00.580 --> 00:28:02.040
you to edit different things.

00:28:02.040 --> 00:28:04.880
So it's very easy to slot
into a different game

00:28:04.880 --> 00:28:07.412
and have an editor
specifically for that game.

00:28:07.412 --> 00:28:09.620
JASON SANMIYA: Our last
library is called BreadBoard.

00:28:09.620 --> 00:28:13.270
It's an event system that
allows you to connect

00:28:13.270 --> 00:28:15.370
disparate systems using data.

00:28:15.370 --> 00:28:17.310
So every game has
different systems

00:28:17.310 --> 00:28:20.254
like audio, AI, and the UI.

00:28:20.254 --> 00:28:22.170
And you want to keep
these systems separate so

00:28:22.170 --> 00:28:24.410
that they don't have to make
function calls into each other.

00:28:24.410 --> 00:28:26.310
Otherwise you end up
with spaghetti code.

00:28:26.310 --> 00:28:30.100
So BreadBoard lets you do this.

00:28:30.100 --> 00:28:32.450
For example, you could
take a football event

00:28:32.450 --> 00:28:35.160
from the animation system
and route that over

00:28:35.160 --> 00:28:37.970
to the audio system, which would
then play a stepping sound.

00:28:37.970 --> 00:28:39.470
And the two systems,
they don't need

00:28:39.470 --> 00:28:42.200
to be connected
with function calls.

00:28:42.200 --> 00:28:44.790
BreadBoard also supports
some arbitrary logic

00:28:44.790 --> 00:28:47.520
nodes so you can route
events a little bit more

00:28:47.520 --> 00:28:49.224
cleverly if you like.

00:28:49.224 --> 00:28:50.390
WOUTER VAN OORTMERSSEN: Wow.

00:28:50.390 --> 00:28:52.589
Look at all those animals.

00:28:52.589 --> 00:28:54.380
JASON SANMIYA: So you
knew this was coming.

00:28:54.380 --> 00:28:58.250
This is where we take a look
at Zushi, our latest game.

00:28:58.250 --> 00:29:01.770
And in Zushi you float down
a mystic river feeding sushi

00:29:01.770 --> 00:29:04.160
to well-dressed animal patrons.

00:29:04.160 --> 00:29:05.295
It's a 3D game.

00:29:05.295 --> 00:29:08.690
It runs in VR at 60
frames per second.

00:29:08.690 --> 00:29:10.946
So that's pretty
high performance.

00:29:10.946 --> 00:29:12.320
Even though it's
a few characters

00:29:12.320 --> 00:29:14.670
on the screen the game
play is very simple,

00:29:14.670 --> 00:29:18.450
it's actually technically
a high performance game.

00:29:18.450 --> 00:29:20.460
And everything in the
world is animated.

00:29:20.460 --> 00:29:24.300
It has a UI, audio,
a level editor.

00:29:24.300 --> 00:29:26.160
So even though it's
a very simple game,

00:29:26.160 --> 00:29:27.662
the technology
stack has everything

00:29:27.662 --> 00:29:29.870
that you would need to make
your own high performance

00:29:29.870 --> 00:29:32.800
VR or 3D game.

00:29:32.800 --> 00:29:34.280
And the technology
stack in Zushi

00:29:34.280 --> 00:29:36.797
is the libraries that we
just described to you.

00:29:44.217 --> 00:29:45.800
WOUTER VAN OORTMERSSEN:
You can do it.

00:29:45.800 --> 00:29:46.883
JASON SANMIYA: There we go

00:29:46.883 --> 00:30:11.597
[BEGIN VIDEO PLAYBACK]

00:30:11.597 --> 00:30:12.180
[END PLAYBACK]

00:30:12.180 --> 00:30:12.930
JASON SANMIYA: OK.

00:30:12.930 --> 00:30:15.240
So all the data in that game
is stored in FlatBuffers.

00:30:15.240 --> 00:30:17.070
It's edited in SceneLab.

00:30:17.070 --> 00:30:19.980
And using SceneLab, we can
also add corgi components

00:30:19.980 --> 00:30:21.810
to all the entities.

00:30:21.810 --> 00:30:23.268
WOUTER VAN OORTMERSSEN:
And FPLBase

00:30:23.268 --> 00:30:27.170
is used to render everything
for input and resource loading.

00:30:27.170 --> 00:30:29.840
JASON SANMIYA: Motive animates
all of the motion in the scene.

00:30:29.840 --> 00:30:31.740
WOUTER VAN OORTMERSSEN:
And FlatUI shows the menus.

00:30:31.740 --> 00:30:33.940
JASON SANMIYA: PinDrop plays
the music and sound effects.

00:30:33.940 --> 00:30:35.590
WOUTER VAN OORTMERSSEN:
And finally, BreadBoard

00:30:35.590 --> 00:30:37.089
connects all the
components together

00:30:37.089 --> 00:30:40.924
and allows us to define a game
flow in data, like Jason said.

00:30:40.924 --> 00:30:43.090
JASON SANMIYA: It's worth
noting that all the sample

00:30:43.090 --> 00:30:45.900
games that we showed you
today are also open source,

00:30:45.900 --> 00:30:49.060
so you can go to GitHub,
download them, and use them

00:30:49.060 --> 00:30:51.110
to prototype your own ideas.

00:30:51.110 --> 00:30:54.050
In fact, the Social
Good team here at Google

00:30:54.050 --> 00:30:55.570
has done just that.

00:30:55.570 --> 00:31:00.110
This is the team that powers the
donations through google.org.

00:31:00.110 --> 00:31:02.950
And they also drove the
newly launched donations card

00:31:02.950 --> 00:31:03.450
on YouTube.

00:31:03.450 --> 00:31:05.130
They're doing a
lot of good stuff.

00:31:05.130 --> 00:31:07.440
So what they did
with Pie Noon is

00:31:07.440 --> 00:31:11.140
to create a prototype of
their new donations API.

00:31:11.140 --> 00:31:15.070
This is an API that lets
users make in-app donations,

00:31:15.070 --> 00:31:17.930
and then it'll
automatically process

00:31:17.930 --> 00:31:19.620
the payments and the billing.

00:31:19.620 --> 00:31:20.810
There's no fees.

00:31:20.810 --> 00:31:22.700
There's no spam
sent to the users.

00:31:22.700 --> 00:31:26.930
And most importantly, it has the
ability for you, the developer,

00:31:26.930 --> 00:31:30.200
to support any
US-based nonprofit.

00:31:30.200 --> 00:31:32.340
So basically you're
encouraging gamers

00:31:32.340 --> 00:31:35.150
to support real world
causes from within the game.

00:31:35.150 --> 00:31:37.130
I think it's a
pretty exciting API,

00:31:37.130 --> 00:31:41.180
and you should check out
their work at this link here.

00:31:41.180 --> 00:31:42.684
And speaking of links--

00:31:42.684 --> 00:31:44.100
WOUTER VAN
OORTMERSSEN: All right.

00:31:44.100 --> 00:31:46.516
So if you want to play around
with any of the technologies

00:31:46.516 --> 00:31:49.759
that you've seen so far,
this is our developer site.

00:31:49.759 --> 00:31:50.550
JASON SANMIYA: Yep.

00:31:50.550 --> 00:31:52.850
All these links and links
to all the libraries

00:31:52.850 --> 00:31:55.490
are in the space for
this talk as well.

00:31:55.490 --> 00:31:56.900
So thanks for listening.

00:31:56.900 --> 00:32:00.430
We hope you're excited to
create high performance games.

00:32:00.430 --> 00:32:03.780
And we hope that our technology
can help you with that.

00:32:03.780 --> 00:32:08.226
WOUTER VAN OORTMERSSEN: So
we're going to have a Q&amp;A now.

00:32:08.226 --> 00:32:10.350
And if you want to talk to
me and Jason afterwards,

00:32:10.350 --> 00:32:11.470
come find us.

00:32:11.470 --> 00:32:12.930
We're here to help.

00:32:12.930 --> 00:32:14.480
[MUSIC PLAYING]

