WEBVTT
Kind: captions
Language: en

00:00:00.040 --> 00:00:01.670
The following
content is provided

00:00:01.670 --> 00:00:03.810
under a Creative
Commons license.

00:00:03.810 --> 00:00:06.530
Your support will help MIT
OpenCourseWare continue

00:00:06.530 --> 00:00:10.120
to offer high quality
educational resources for free.

00:00:10.120 --> 00:00:12.690
To make a donation or
view additional materials

00:00:12.690 --> 00:00:16.590
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.590 --> 00:00:17.251
at ocw.mit.edu.

00:00:23.830 --> 00:00:26.800
PROFESSOR: So today
I want to finish up

00:00:26.800 --> 00:00:28.660
a couple of loose
ends in the class.

00:00:28.660 --> 00:00:30.252
The first is by
the end of the day,

00:00:30.252 --> 00:00:31.960
we'll talk about EPR
that we've picked up

00:00:31.960 --> 00:00:33.487
on the last couple of lectures.

00:00:33.487 --> 00:00:35.070
We're going to close
up Bell's theorem

00:00:35.070 --> 00:00:36.109
from the very beginning.

00:00:36.109 --> 00:00:37.650
So we talked about
Bell's Inequality,

00:00:37.650 --> 00:00:39.270
and we'll re-prove
Bell's Inequality,

00:00:39.270 --> 00:00:41.945
and then we'll see what quantum
mechanics has to say about it.

00:00:41.945 --> 00:00:43.820
But first, I want to
show you something neat.

00:00:43.820 --> 00:00:46.069
So a couple of times, we've
talked about entanglement,

00:00:46.069 --> 00:00:47.190
and what it can do.

00:00:47.190 --> 00:00:49.731
And I want to spend the first
good chunk of the class talking

00:00:49.731 --> 00:00:53.344
about what entanglement can
do, and also what it can't.

00:00:53.344 --> 00:00:55.760
So before we get started, I
want to remind you of a couple

00:00:55.760 --> 00:00:57.410
things from the last lecture.

00:00:57.410 --> 00:01:01.940
So the first is
particles can have spin.

00:01:01.940 --> 00:01:03.540
Half-integer intrisic
angular momentum

00:01:03.540 --> 00:01:06.080
that has nothing to
do with being a rigid

00:01:06.080 --> 00:01:08.470
object that rotates, but is
just an intrinsic property

00:01:08.470 --> 00:01:09.440
of angular momentum.

00:01:09.440 --> 00:01:11.230
And this spin is
observable-- it's

00:01:11.230 --> 00:01:12.700
represented by an operator.

00:01:12.700 --> 00:01:14.960
In fact, a vector of
operators, Sx, Sy, and Sz,

00:01:14.960 --> 00:01:17.085
that satisfy the same
[? computational ?] relations

00:01:17.085 --> 00:01:19.100
as the orbital angular momentum.

00:01:19.100 --> 00:01:22.030
Now last time, one thing we
showed is that a state which is

00:01:22.030 --> 00:01:25.780
up-- or, for example,
down-- at an angle theta,

00:01:25.780 --> 00:01:27.970
so if I measure the
spin along this axis,

00:01:27.970 --> 00:01:30.460
I will always find it's
other up or down, spin-1/2,

00:01:30.460 --> 00:01:33.190
either plus h-bar upon
2 or minus h-bar upon 2.

00:01:33.190 --> 00:01:36.620
But I can express this
state in terms of the states

00:01:36.620 --> 00:01:39.850
with spin, which are up
or down along the z-axis.

00:01:39.850 --> 00:01:42.540
And we gave an
expression-- and I

00:01:42.540 --> 00:01:44.900
challenge you to
follow the logic given

00:01:44.900 --> 00:01:46.770
to derive this expression.

00:01:46.770 --> 00:01:48.310
An expression for
the state, which

00:01:48.310 --> 00:01:50.820
is, in this case, down
along the angle theta--

00:01:50.820 --> 00:01:54.610
it went down when measuring
spin along the angle theta--

00:01:54.610 --> 00:02:01.590
in terms of up and down of spin
along the z-axis, or long angle

00:02:01.590 --> 00:02:04.430
0, with theta here being the
declination from the vertical.

00:02:04.430 --> 00:02:05.520
OK.

00:02:05.520 --> 00:02:07.000
Yep.

00:02:07.000 --> 00:02:13.870
AUDIENCE: [INAUDIBLE] angle.

00:02:13.870 --> 00:02:14.590
PROFESSOR: Yeah.

00:02:14.590 --> 00:02:16.460
There's a general
thing for this,

00:02:16.460 --> 00:02:17.970
that says for a general angle.

00:02:17.970 --> 00:02:20.460
And it's actually
in the notes, which

00:02:20.460 --> 00:02:22.250
I guess weren't
posted from last time.

00:02:22.250 --> 00:02:23.880
But it's in the notes.

00:02:23.880 --> 00:02:26.189
And it's also easy
to derive right?

00:02:26.189 --> 00:02:27.230
So what's the point here?

00:02:27.230 --> 00:02:29.320
The point is you
have a spin vector,

00:02:29.320 --> 00:02:31.230
and it's a vector, Sx, Sy, Sz.

00:02:31.230 --> 00:02:33.170
And you can compute the
operator representing

00:02:33.170 --> 00:02:34.180
spin along a
particular direction

00:02:34.180 --> 00:02:35.800
by taking a unit vector
in that direction

00:02:35.800 --> 00:02:36.850
and taking the dot product.

00:02:36.850 --> 00:02:38.891
So that gives you a
particular linear combination

00:02:38.891 --> 00:02:40.190
of Sx, Sy, and Sz.

00:02:40.190 --> 00:02:42.930
But, from last time, you know
that's just some stupid matrix.

00:02:42.930 --> 00:02:44.460
And you could express
a matrix in any basis

00:02:44.460 --> 00:02:45.630
you want, for example,
the basis of up

00:02:45.630 --> 00:02:47.713
and down in the z-direction,
which is what we used

00:02:47.713 --> 00:02:48.339
last time.

00:02:48.339 --> 00:02:50.130
Then you can find the
eigenvectors of that,

00:02:50.130 --> 00:02:51.994
and that's how you
find these states.

00:02:51.994 --> 00:02:53.660
So there's a very
simple generalization.

00:02:53.660 --> 00:02:55.510
It just involves an
extra angle theta,

00:02:55.510 --> 00:02:58.664
which is the angle
around the equator.

00:02:58.664 --> 00:03:00.030
OK?

00:03:00.030 --> 00:03:01.570
AUDIENCE: [INAUDIBLE].

00:03:01.570 --> 00:03:05.800
PROFESSOR: Sorry,
phi, extra angle phi.

00:03:05.800 --> 00:03:08.089
So we then did the
following thing.

00:03:08.089 --> 00:03:09.880
I talked about the
Stern-Gerlach experiment

00:03:09.880 --> 00:03:12.004
and, here in an abstract
way from the Stern Gerlach

00:03:12.004 --> 00:03:14.270
experiment, the
core of the nugget.

00:03:14.270 --> 00:03:16.000
And the core of it is this.

00:03:16.000 --> 00:03:20.294
Suppose I have some spin, and
I put it in a particular state.

00:03:20.294 --> 00:03:22.710
Let's say, for simplicity, up
in the z-direction plus down

00:03:22.710 --> 00:03:24.670
in the z-direction
with equal amplitudes.

00:03:24.670 --> 00:03:27.660
So they're equally
likely to be measured.

00:03:27.660 --> 00:03:29.912
And then, these guys,
these two states,

00:03:29.912 --> 00:03:32.120
should be degenerate in
energy, because the system is

00:03:32.120 --> 00:03:32.990
rotationally invariant.

00:03:32.990 --> 00:03:34.323
It's just a spin, sitting there.

00:03:34.323 --> 00:03:36.030
There's rotational
invariance, so we

00:03:36.030 --> 00:03:40.320
know the energy can't depend on
the z-component of the angular

00:03:40.320 --> 00:03:40.870
momentum.

00:03:40.870 --> 00:03:43.161
But we can break that symmetry
and break the degeneracy

00:03:43.161 --> 00:03:44.460
by turning on a magnetic field.

00:03:44.460 --> 00:03:45.930
So for a Stern-Gerlach
experiment,

00:03:45.930 --> 00:03:47.560
we turn on a magnetic
field that had a gradient.

00:03:47.560 --> 00:03:49.430
But I just want to look at
a constant magnetic field

00:03:49.430 --> 00:03:50.990
for the moment and
see what it does.

00:03:50.990 --> 00:03:52.706
So we turn a constant
magnetic field.

00:03:52.706 --> 00:03:54.830
That's a contribution of
the energy, which is minus

00:03:54.830 --> 00:03:56.980
the magnetic field dot
the magnetic moment, which

00:03:56.980 --> 00:03:58.580
is a constant times the spin.

00:03:58.580 --> 00:04:00.580
But if the magnetic field
is in the z-direction,

00:04:00.580 --> 00:04:03.490
then this is just Bz Sz.

00:04:03.490 --> 00:04:06.990
So we then found yesterday
that this led to a splitting--

00:04:06.990 --> 00:04:09.160
that the up state had
energy plus h-bar omega,

00:04:09.160 --> 00:04:11.160
and the down state had
energy minus h-bar omega,

00:04:11.160 --> 00:04:14.271
where omega is given by
mu naught Bz upon two.

00:04:14.271 --> 00:04:15.770
Yesterday, we had
an additional term

00:04:15.770 --> 00:04:18.690
which involved the z
dependence, the beta z term,

00:04:18.690 --> 00:04:21.107
but here I'm just looking at
a constant magnetic field.

00:04:21.107 --> 00:04:22.690
But if we know the
energies are, these

00:04:22.690 --> 00:04:25.060
are still the eigenstates
of the energy operator.

00:04:25.060 --> 00:04:26.080
If we know the
energies are, we know

00:04:26.080 --> 00:04:27.480
how the system evolves in time.

00:04:27.480 --> 00:04:28.860
Here is the initial state.

00:04:28.860 --> 00:04:30.070
These are the eigenstates.

00:04:30.070 --> 00:04:31.447
The energies are these.

00:04:31.447 --> 00:04:33.280
So we can let the system
evolve in the time,

00:04:33.280 --> 00:04:34.850
and we find that
all we do, is we

00:04:34.850 --> 00:04:36.580
evolve the system with phases.

00:04:36.580 --> 00:04:38.420
This is as usual in
quantum evolution.

00:04:38.420 --> 00:04:41.550
If you have an expansion of the
state in energy eigenstates,

00:04:41.550 --> 00:04:45.600
time evolution is just
phases for each term.

00:04:45.600 --> 00:04:48.680
But note that there's
a simple thing.

00:04:48.680 --> 00:04:50.240
This omega, the
thing that determines

00:04:50.240 --> 00:04:51.990
the rate of evolution
of the phase,

00:04:51.990 --> 00:04:53.630
is controlled by
magnetic moment, which

00:04:53.630 --> 00:04:55.760
is something intrinsic to spin,
and the magnetic field, which

00:04:55.760 --> 00:04:57.660
is something I can
dial in an experiment.

00:04:57.660 --> 00:04:58.859
I can really tune it.

00:04:58.859 --> 00:05:01.400
Meanwhile, we decide how long
to leave the magnetic field on.

00:05:01.400 --> 00:05:02.790
I can turn the magnetic
field on for a while,

00:05:02.790 --> 00:05:04.760
and I could turn
it off while later.

00:05:04.760 --> 00:05:09.050
So suppose I leave the
field on for time t,

00:05:09.050 --> 00:05:13.821
such that omega t is
equal to pi upon 2.

00:05:13.821 --> 00:05:14.320
OK.

00:05:14.320 --> 00:05:16.900
So you turn on the magnetic
field for a time t,

00:05:16.900 --> 00:05:18.580
such that omega t
is pi upon 2, or t

00:05:18.580 --> 00:05:20.350
is equal to pi upon 2 omega.

00:05:20.350 --> 00:05:22.060
What is the state
then, afterwards?

00:05:22.060 --> 00:05:27.590
The state subsequently psi
after, is equal to this guy--

00:05:27.590 --> 00:05:30.510
omega t is equal to pi upon 2.

00:05:30.510 --> 00:05:34.080
But what's e to the i pi upon 2?

00:05:34.080 --> 00:05:35.190
i.

00:05:35.190 --> 00:05:35.690
Right?

00:05:35.690 --> 00:05:39.530
And e to the minus i
pi over 2, is minus i.

00:05:39.530 --> 00:05:40.780
So this is an i and a minus i.

00:05:40.780 --> 00:05:43.430
I can pull out the i so that
the phi after is i, a phase,

00:05:43.430 --> 00:05:50.490
upon root 2 times
up z, minus down z.

00:05:50.490 --> 00:05:52.340
Yeah.

00:05:52.340 --> 00:05:53.290
That's cool.

00:05:53.290 --> 00:05:55.304
And this is a state
that we saw last time.

00:05:55.304 --> 00:05:56.720
It's actually up
to normalization,

00:05:56.720 --> 00:06:00.670
which is an i, up or down
x in the x-direction.

00:06:03.299 --> 00:06:05.590
So what this lets us do is
something really quite cool.

00:06:05.590 --> 00:06:07.460
What this tells us is that all
these calculations are just

00:06:07.460 --> 00:06:09.040
the Stern-Gerlach
calculation, but even easier,

00:06:09.040 --> 00:06:10.415
because we don't
have a gradient.

00:06:10.415 --> 00:06:13.950
If we have the spin in
some superposition, which,

00:06:13.950 --> 00:06:17.380
incidentally, was initially up
and down in the z-direction,

00:06:17.380 --> 00:06:21.870
this is equal to up
in the x-direction.

00:06:21.870 --> 00:06:26.020
So in x, we have it up.

00:06:26.020 --> 00:06:28.820
We turn on a magnetic field
in z, and what happens

00:06:28.820 --> 00:06:31.490
is the spin precesses
around the z-axis.

00:06:31.490 --> 00:06:33.840
And we get down.

00:06:33.840 --> 00:06:35.070
We get precession.

00:06:35.070 --> 00:06:36.210
Here's the important point.

00:06:36.210 --> 00:06:37.550
The important point
for everything

00:06:37.550 --> 00:06:38.841
that's going to follow is this.

00:06:38.841 --> 00:06:40.970
If I have some spin
state, and I want

00:06:40.970 --> 00:06:44.450
to take it to some other
spin state, how do I do so?

00:06:44.450 --> 00:06:46.617
Well, I can build a
machine that does it,

00:06:46.617 --> 00:06:48.450
by turning on the
appropriate magnetic field

00:06:48.450 --> 00:06:51.141
and having the magnetic
field precess the spin.

00:06:51.141 --> 00:06:51.640
OK.

00:06:51.640 --> 00:06:53.500
Here I found exactly
what magnetic field

00:06:53.500 --> 00:06:56.530
I need to turn on, with what
amplitude, and for how long,

00:06:56.530 --> 00:06:59.850
such that I think the
state up x to down x,

00:06:59.850 --> 00:07:01.740
with a known phase i.

00:07:01.740 --> 00:07:03.890
Everyone cool with that?

00:07:03.890 --> 00:07:06.240
So any unit-- here's the
thing I want to convince you

00:07:06.240 --> 00:07:08.250
of-- any unitary
operation that takes you

00:07:08.250 --> 00:07:12.730
from from one spinner to
another spinner-- up z,

00:07:12.730 --> 00:07:15.970
down y, linear combination
of up and down z,

00:07:15.970 --> 00:07:19.640
some particular linear
combination of up and down x.

00:07:19.640 --> 00:07:24.260
Any such pair of
vectors can be related

00:07:24.260 --> 00:07:25.502
by unitary transformation.

00:07:25.502 --> 00:07:26.960
And any such unitary
transformation

00:07:26.960 --> 00:07:30.160
can be built by some
series of magnetic fields.

00:07:30.160 --> 00:07:31.980
That cool?

00:07:31.980 --> 00:07:34.150
You can just can prove this
yourself quite quickly,

00:07:34.150 --> 00:07:37.450
but let me just state it.

00:07:37.450 --> 00:07:40.020
So now this gives us the
ability to do the following.

00:07:40.020 --> 00:07:47.460
One, we have spins,
one, spins that can

00:07:47.460 --> 00:07:50.200
be put in a system
that can be put

00:07:50.200 --> 00:07:54.910
in states like up z and down z.

00:07:54.910 --> 00:07:58.450
And two, the ability
to rotate states.

00:07:58.450 --> 00:08:06.660
The ability to evolve
states from state to state.

00:08:06.660 --> 00:08:12.760
From spin state 1 to
psi 2 by turning on some

00:08:12.760 --> 00:08:18.500
magnetic fields, so by suitably
choosing our magnetic fields.

00:08:18.500 --> 00:08:20.470
Everyone cool with that?

00:08:20.470 --> 00:08:23.000
So here's a question I want to
ask, what do we do with this?

00:08:23.000 --> 00:08:25.470
Imagine we really had this
equipment in front of us.

00:08:25.470 --> 00:08:29.530
What power, what awesomeness
could we realize?

00:08:29.530 --> 00:08:35.100
And this is the entry
point to quantum computing.

00:08:35.100 --> 00:08:37.350
The answer to what can you
do with this cool machinery

00:08:37.350 --> 00:08:39.690
is you build a quantum computer.

00:08:39.690 --> 00:08:41.190
So let's talk about
what that means.

00:08:47.190 --> 00:08:50.395
So quick question, do
quantum computers exist?

00:08:50.395 --> 00:08:50.895
Yeah.

00:08:50.895 --> 00:08:52.190
Are they very big?

00:08:52.190 --> 00:08:52.990
No, OK.

00:08:52.990 --> 00:08:54.750
The biggest quantum computer
that's been built my knowledge

00:08:54.750 --> 00:08:56.440
is one that has factored
the number fifteen

00:08:56.440 --> 00:08:58.148
Or they might have
done 21 at this point,

00:08:58.148 --> 00:08:59.611
I'm not exactly sure.

00:08:59.611 --> 00:09:00.110
21?

00:09:00.110 --> 00:09:00.720
Done?

00:09:00.720 --> 00:09:01.220
Yeah, OK.

00:09:01.220 --> 00:09:01.910
21's done.

00:09:01.910 --> 00:09:05.440
So that's the upper end.

00:09:05.440 --> 00:09:06.961
Well, they're large, physically.

00:09:06.961 --> 00:09:07.460
It's true.

00:09:07.460 --> 00:09:09.270
They take up a room.

00:09:09.270 --> 00:09:12.040
Or at least a large table
top, an optics table.

00:09:12.040 --> 00:09:13.980
But they're not very
big in a useful sense.

00:09:13.980 --> 00:09:14.480
OK.

00:09:14.480 --> 00:09:18.110
And there's actually reasonable
people, not just reasonable,

00:09:18.110 --> 00:09:20.660
intelligent people--
and reasonable.

00:09:20.660 --> 00:09:22.530
That's a nontrivial-- Ok.

00:09:22.530 --> 00:09:24.370
The people who live
at the intersection

00:09:24.370 --> 00:09:28.199
of intelligent and
reasonable, which,

00:09:28.199 --> 00:09:29.990
admittedly as my
colleague is pointing out,

00:09:29.990 --> 00:09:32.940
is not a large overlap.

00:09:32.940 --> 00:09:35.640
There are people
in that overlap who

00:09:35.640 --> 00:09:38.865
suspect that, for some
fundamental reason,

00:09:38.865 --> 00:09:40.990
it's impossible to build
a useful quantum computer,

00:09:40.990 --> 00:09:42.394
in some deep, deep sense.

00:09:42.394 --> 00:09:44.060
I don't know whether
that's true or not.

00:09:44.060 --> 00:09:46.760
But we're about to engage in a
discussion of what happens when

00:09:46.760 --> 00:09:48.880
you build quantum
computers for n bits

00:09:48.880 --> 00:09:51.890
were n gets large, like
millions and billions

00:09:51.890 --> 00:09:55.412
as you need for codes
or for studying images.

00:09:55.412 --> 00:09:57.120
And, of course, this
is a little strange,

00:09:57.120 --> 00:09:59.070
because such a
compter doesn't exist,

00:09:59.070 --> 00:10:03.080
which leads to my colleague
and friend Scott Aaronson's

00:10:03.080 --> 00:10:06.010
lovely comment that his job,
as someone who studies quantum

00:10:06.010 --> 00:10:07.640
computers, is to
prove things that

00:10:07.640 --> 00:10:10.080
can't be done with
computers that don't exist.

00:10:10.080 --> 00:10:12.420
Which is what we're
about to do, so.

00:10:12.420 --> 00:10:14.450
So let's talk about
quantum computing.

00:10:14.450 --> 00:10:16.140
So what do I mean by
quantum computing?

00:10:16.140 --> 00:10:16.810
Here's the basic idea.

00:10:16.810 --> 00:10:18.190
Let's talk about
classical computing.

00:10:18.190 --> 00:10:20.064
Classical computing
says, I have these things

00:10:20.064 --> 00:10:22.460
called bits, which
are binary objects.

00:10:22.460 --> 00:10:23.790
They're either 0, or they're 1.

00:10:23.790 --> 00:10:25.665
And we realize them in
a very particular way.

00:10:25.665 --> 00:10:27.270
We realize them with
a little magnet,

00:10:27.270 --> 00:10:28.497
which points north or south.

00:10:28.497 --> 00:10:30.080
Now, it's not always
exactly a magnet.

00:10:30.080 --> 00:10:32.781
It isn't like an old-style
hard disk in your computer.

00:10:32.781 --> 00:10:35.030
It's something a little more
fancy than just a magnet.

00:10:35.030 --> 00:10:36.479
But it's still
basically a magnet,

00:10:36.479 --> 00:10:37.770
and you have some north, south.

00:10:37.770 --> 00:10:39.500
And whether it's pointing
north, or whether it's

00:10:39.500 --> 00:10:41.333
pointing south down
here, which I'll call 0.

00:10:41.333 --> 00:10:44.690
Or whether it's pointing north
down here, which I'll call a 1,

00:10:44.690 --> 00:10:46.570
determines whether
you call this 0 or 1.

00:10:46.570 --> 00:10:49.760
And classical
computation is your data

00:10:49.760 --> 00:10:53.070
are a set of numbers--
what's pointing down.

00:10:53.070 --> 00:10:57.520
And the process of doing
a classical computation

00:10:57.520 --> 00:11:00.740
is, build a machine
which is governed

00:11:00.740 --> 00:11:05.110
by classical mechanics,
OK, that takes

00:11:05.110 --> 00:11:07.440
this initial configuration
and replaces it

00:11:07.440 --> 00:11:10.070
with a new one, f of 0, 1.

00:11:10.070 --> 00:11:12.730
Which is also some number,
so maybe it's 0, 0.

00:11:12.730 --> 00:11:14.612
I don't know--
it's whatever f is.

00:11:14.612 --> 00:11:16.070
And what you want
to do is you want

00:11:16.070 --> 00:11:18.960
to perform some calculation,
which is some function, a known

00:11:18.960 --> 00:11:21.282
function, of your
input variables--

00:11:21.282 --> 00:11:23.490
a function, in this case,
of two bits, which produces

00:11:23.490 --> 00:11:24.960
the output that
you want, and you

00:11:24.960 --> 00:11:26.381
build a machine that does that.

00:11:26.381 --> 00:11:26.880
OK.

00:11:26.880 --> 00:11:28.129
So let me give you an example.

00:11:28.129 --> 00:11:30.800
I want to build a
classical computer that

00:11:30.800 --> 00:11:37.370
takes a string of binary
integers-- 0, 0, 1, 0, 0.

00:11:37.370 --> 00:11:40.684
And performs a logical [? NOT ?]
on each bit independently.

00:11:40.684 --> 00:11:43.350
So I need to build that computer
out of objects available to me.

00:11:43.350 --> 00:11:43.850
OK.

00:11:43.850 --> 00:11:45.900
And I need to use nothing
other than the laws

00:11:45.900 --> 00:11:47.550
of classical mechanics.

00:11:47.550 --> 00:11:50.030
That has to suffice to
describe the system.

00:11:50.030 --> 00:11:53.270
So let me give an example
of such a computer.

00:11:53.270 --> 00:11:55.650
Why, Allen, why don't
you do this calculation?

00:11:55.650 --> 00:11:56.250
OK.

00:11:56.250 --> 00:11:58.260
So, that's the
input, and I am now

00:11:58.260 --> 00:12:00.840
the classical computer 0, 1, 1.

00:12:00.840 --> 00:12:01.340
Right?

00:12:01.340 --> 00:12:03.590
Now that's not actually what
you do in your cell phone

00:12:03.590 --> 00:12:04.810
or on your laptop.

00:12:04.810 --> 00:12:07.260
That uses transistors, but
it's the same basic idea.

00:12:07.260 --> 00:12:08.510
You build a set of machines.

00:12:08.510 --> 00:12:11.880
You build a set of objects,
you know, magnetic fields,

00:12:11.880 --> 00:12:14.840
electric currents that
effect this calculation.

00:12:14.840 --> 00:12:17.410
And so there's some relationship
between what electric fields

00:12:17.410 --> 00:12:18.240
you turn on and
what currents you

00:12:18.240 --> 00:12:19.870
induce to flow and
the calculation

00:12:19.870 --> 00:12:22.852
you want to perform--
f of the input.

00:12:22.852 --> 00:12:24.893
OK, this is a basic idea
of a classical computer.

00:12:27.462 --> 00:12:28.420
Oh, and one last thing.

00:12:28.420 --> 00:12:30.740
Suppose we have n bits.

00:12:30.740 --> 00:12:34.460
Suppose we have
n classical bits.

00:12:34.460 --> 00:12:37.669
Then we have 0, 1, the end.

00:12:37.669 --> 00:12:39.460
And how many numbers
do you have to specify

00:12:39.460 --> 00:12:41.380
to specify the
configuration of n bits?

00:12:41.380 --> 00:12:43.720
This is sort of [INAUDIBLE].

00:12:43.720 --> 00:12:46.770
No, you just need to specify
the number of each bit, right?

00:12:46.770 --> 00:12:49.180
So we need n bits.

00:12:49.180 --> 00:12:50.440
So n binary numbers.

00:12:55.230 --> 00:12:56.590
Everyone cool with that?

00:12:56.590 --> 00:13:00.200
I specify what each
register is, and I'm done.

00:13:00.200 --> 00:13:02.570
Imagine this is
quantum mechanical.

00:13:02.570 --> 00:13:05.710
Instead of having bits, let's
take quantum mechanical bits.

00:13:05.710 --> 00:13:09.250
By which I'm going
to mean a system

00:13:09.250 --> 00:13:14.550
that has two possible
observable states, 0 and 1.

00:13:14.550 --> 00:13:15.400
OK.

00:13:15.400 --> 00:13:17.233
So these are the possible
observable states.

00:13:19.710 --> 00:13:23.890
And to specify a
general configuration,

00:13:23.890 --> 00:13:31.410
I see that psi is equal to
some linear combination, alpha

00:13:31.410 --> 00:13:34.700
0 plus beta 1.

00:13:34.700 --> 00:13:39.260
Now, if I measure, we know
that we'll find either 0 or 1.

00:13:39.260 --> 00:13:41.010
If we measure the spin
in the z-direction,

00:13:41.010 --> 00:13:43.820
we will measure
either up or down.

00:13:43.820 --> 00:13:45.762
However, at a given
moment in time,

00:13:45.762 --> 00:13:47.720
the system need not be
in a state corresponding

00:13:47.720 --> 00:13:48.616
to a definite value.

00:13:48.616 --> 00:13:50.240
It could be in a
general superposition.

00:13:50.240 --> 00:13:51.516
Agreed?

00:13:51.516 --> 00:13:52.640
So now here's the question.

00:13:52.640 --> 00:13:54.098
How do you how many
numbers does it

00:13:54.098 --> 00:13:59.410
take to specify the state
of a single quantum bit?

00:13:59.410 --> 00:14:01.125
Two complex numbers.

00:14:01.125 --> 00:14:01.625
Right?

00:14:01.625 --> 00:14:04.140
It takes two complex numbers
to specify the state of a bit.

00:14:04.140 --> 00:14:08.160
And if we have n qubits, and
there are n of these guys,

00:14:08.160 --> 00:14:10.100
well then, how many
numbers does it take?

00:14:10.100 --> 00:14:11.475
Well, I have to
specify the state

00:14:11.475 --> 00:14:15.140
of every possible
superposition for

00:14:15.140 --> 00:14:16.970
every possible
configuration the system.

00:14:16.970 --> 00:14:21.500
So, for example, it could be
all 0, 0, 0, dot dot dot 0,

00:14:21.500 --> 00:14:22.590
plus beta.

00:14:22.590 --> 00:14:25.635
The first one is 1, and the
rest are 0, dot dot dot plus.

00:14:25.635 --> 00:14:26.760
And how it terms are there?

00:14:26.760 --> 00:14:28.680
There are 2 to the n terms.

00:14:28.680 --> 00:14:29.180
Right.

00:14:29.180 --> 00:14:34.250
So how many numbers do I need to
specify this state of n qubits?

00:14:34.250 --> 00:14:36.870
I need 2 to the n
complex numbers.

00:14:42.370 --> 00:14:43.330
Yeah?

00:14:43.330 --> 00:14:44.940
Everyone see that?

00:14:44.940 --> 00:14:48.750
So this immediately leads to
a really frustrating reality

00:14:48.750 --> 00:14:49.750
we have to face.

00:14:49.750 --> 00:14:53.330
Suppose you want to simulate,
using a classical computer,

00:14:53.330 --> 00:14:56.850
such as sits on my desktop, I
wanted to simulate a quantum

00:14:56.850 --> 00:15:00.460
mechanical system of n
bits, or n spin-1/2 states,

00:15:00.460 --> 00:15:02.610
evolving according to
some energy function--

00:15:02.610 --> 00:15:06.170
evolving according to some
Hamiltonian [INAUDIBLE].

00:15:06.170 --> 00:15:11.926
How many variables, and how
much memory will it take?

00:15:11.926 --> 00:15:12.749
2 to the n, right?

00:15:12.749 --> 00:15:14.540
If I've got n bits that
I want to describe,

00:15:14.540 --> 00:15:17.091
it's going to take 2 to
the n complex numbers.

00:15:17.091 --> 00:15:18.590
So that's how many
variables I have.

00:15:18.590 --> 00:15:23.220
So if I have 10 bits, literally,
10 little spin-1/2 objects,

00:15:23.220 --> 00:15:27.240
to accurately specify the
quantum configuration system,

00:15:27.240 --> 00:15:30.550
I need 2 to the 10
complex numbers.

00:15:30.550 --> 00:15:32.330
And that's for 10 spins.

00:15:32.330 --> 00:15:35.240
How many things make
this piece of chalk?

00:15:35.240 --> 00:15:35.920
Right?

00:15:35.920 --> 00:15:39.200
So could you ever,
in an honest way,

00:15:39.200 --> 00:15:41.600
simulate on a
classical computer,

00:15:41.600 --> 00:15:43.790
like sits on my desktop, a
quantum mechanical system

00:15:43.790 --> 00:15:45.220
the size of this chalk.

00:15:45.220 --> 00:15:46.020
Absolutely not.

00:15:46.020 --> 00:15:47.740
It's completely and
utterly intractable.

00:15:47.740 --> 00:15:50.198
You have to come up with some
sort of approximation scheme.

00:15:50.198 --> 00:15:52.300
So simulating quantum
systems directly,

00:15:52.300 --> 00:15:55.520
by just taking the spins and
representing them with a wave

00:15:55.520 --> 00:15:57.880
function, is wildly inefficient.

00:15:57.880 --> 00:16:00.310
Incredibly difficult.

00:16:00.310 --> 00:16:03.730
Interestingly, the converse
is almost certainly not

00:16:03.730 --> 00:16:04.630
so difficult.

00:16:04.630 --> 00:16:07.570
It's almost certainly
possible for a quantum system

00:16:07.570 --> 00:16:10.360
to simulate classical
evolution quite easily.

00:16:10.360 --> 00:16:12.730
And how do you know that?

00:16:12.730 --> 00:16:13.620
Yeah, here we are.

00:16:13.620 --> 00:16:15.020
Exactly, right?

00:16:15.020 --> 00:16:18.100
Nature apparently has no trouble
simulating classical mechanics

00:16:18.100 --> 00:16:19.910
with underlying
quantum mechanics.

00:16:19.910 --> 00:16:21.850
Quantum mechanics is
the operating system,

00:16:21.850 --> 00:16:25.136
and classical mechanics is
the simulation it's running.

00:16:25.136 --> 00:16:28.970
Yeah, in a very useful
sense, a very real sense.

00:16:28.970 --> 00:16:33.930
So, at this point,
Feynman, I think,

00:16:33.930 --> 00:16:36.593
was the first person who
really pointed this out.

00:16:36.593 --> 00:16:38.460
I don't know the
details of the history,

00:16:38.460 --> 00:16:42.340
but the lore is that this was
really from his observation.

00:16:42.340 --> 00:16:43.890
Look, if that's
true, this opens up

00:16:43.890 --> 00:16:45.990
a real possibility
for computation.

00:16:45.990 --> 00:16:50.830
If things like spins-- hard
problems like calculating

00:16:50.830 --> 00:16:54.360
how spins evolve or even the
motion of chalk in the room--

00:16:54.360 --> 00:16:56.590
can be done pretty efficiently
by nature, a comput

00:16:56.590 --> 00:17:00.064
if we can build a computer that
used quantum mechanical bits,

00:17:00.064 --> 00:17:01.730
whose variables were
quantum mechanical,

00:17:01.730 --> 00:17:03.750
and involved all the
superpositions and interference

00:17:03.750 --> 00:17:05.470
effects of quantum
mechanics, perhaps we

00:17:05.470 --> 00:17:08.550
could build computers
that run exponentially

00:17:08.550 --> 00:17:10.740
faster and with
exponentially less memory

00:17:10.740 --> 00:17:12.832
and less resources than
classical computer would.

00:17:12.832 --> 00:17:14.290
Because apparently
it works, right?

00:17:14.290 --> 00:17:17.030
We're here, as was
previously said.

00:17:17.030 --> 00:17:19.000
So this is the question
of quantum computing.

00:17:19.000 --> 00:17:20.250
Can you use quantum mechanics?

00:17:20.250 --> 00:17:24.250
Can use, in particular, the
quantum evolution of the system

00:17:24.250 --> 00:17:27.030
to perform calculations
that you care about,

00:17:27.030 --> 00:17:31.000
rather than classical
computation?

00:17:31.000 --> 00:17:34.726
And if you do so, do
you gain anything?

00:17:34.726 --> 00:17:36.100
Do you get any
sort of speed ups?

00:17:36.100 --> 00:17:37.099
Is there an enhancement?

00:17:37.099 --> 00:17:39.030
Is anything better?

00:17:39.030 --> 00:17:41.172
So, here's the basic gig.

00:17:41.172 --> 00:17:43.540
The basic gig is that we're
going to take our system,

00:17:43.540 --> 00:17:45.970
considering the following
kinds of systems.

00:17:45.970 --> 00:17:49.600
Our systems are going to
be n qubits or n spins.

00:17:49.600 --> 00:17:52.000
But because I want to
emphasize that the substrate

00:17:52.000 --> 00:17:54.594
doesn't matter--- the underlying
material doesn't matter--

00:17:54.594 --> 00:17:56.010
I'm going to refer
to them purely,

00:17:56.010 --> 00:17:58.360
and this is totally typical
in the field, as qubits,

00:17:58.360 --> 00:17:59.530
rather than spin systems.

00:17:59.530 --> 00:18:02.820
And the reason is it might
work use little isolated

00:18:02.820 --> 00:18:04.927
spinning particles
with intrinsic spin.

00:18:04.927 --> 00:18:07.260
Or that might turn out to be
technologically infeasible.

00:18:07.260 --> 00:18:09.840
It shouldn't matter at the end
of the day, in the same way

00:18:09.840 --> 00:18:11.756
that if I ask you, how
does you computer work?

00:18:11.756 --> 00:18:13.440
Or if I ask you to
write a code, you

00:18:13.440 --> 00:18:15.885
write some code in C
or Python or whatever--

00:18:15.885 --> 00:18:17.510
what the hip kids
are using these days.

00:18:17.510 --> 00:18:22.340
So you write some little Scheme
code-- I still love Scheme.

00:18:22.340 --> 00:18:23.844
You write some
little Scheme code,

00:18:23.844 --> 00:18:25.760
and it performs some
calculation as to defined

00:18:25.760 --> 00:18:30.344
in just logic, in lambda
calculus, in abstract logic.

00:18:30.344 --> 00:18:31.760
Do you need to
know the substrate?

00:18:31.760 --> 00:18:34.176
So you need to know whether
your transistors are built out

00:18:34.176 --> 00:18:35.760
of silicon or germanium?

00:18:35.760 --> 00:18:39.110
Or indeed, whether it's
running on vacuum tubes?

00:18:39.110 --> 00:18:42.302
No, that's the whole point of
abstracting away computation.

00:18:42.302 --> 00:18:43.510
The substrate doesn't matter.

00:18:43.510 --> 00:18:44.477
So we can use spin-1/2.

00:18:44.477 --> 00:18:46.810
And that's going to be useful
for us at various moments.

00:18:46.810 --> 00:18:48.601
But I want to emphasize
the important thing

00:18:48.601 --> 00:18:50.860
is the actual logic
of the process,

00:18:50.860 --> 00:18:52.210
not the underlying substrate.

00:18:52.210 --> 00:18:53.001
Here's what I need.

00:18:53.001 --> 00:18:54.670
My systems are going
to be n copies,

00:18:54.670 --> 00:19:00.830
or n qubits, where each bit
is specified by either 1,

00:19:00.830 --> 00:19:04.220
represented by up, or
0, represented by down.

00:19:04.220 --> 00:19:06.010
I'll use these interchangeably.

00:19:06.010 --> 00:19:09.580
So that the full system, psi,
is a superposition of sum

00:19:09.580 --> 00:19:13.720
over all possible-- sorry,
I didn't mean to write that.

00:19:13.720 --> 00:19:15.390
So this is my system.

00:19:15.390 --> 00:19:19.490
It's going to evolve according
to some energy operation.

00:19:19.490 --> 00:19:25.070
And so my input is going to
be some wave function, psi n,

00:19:25.070 --> 00:19:27.900
for these n qubits.

00:19:27.900 --> 00:19:34.320
Computation is going to
be, evolve with some energy

00:19:34.320 --> 00:19:41.670
operator-- which I've chosen--
to implement an algorithm,

00:19:41.670 --> 00:19:45.044
in the same way that the precise
series of magnetic fields

00:19:45.044 --> 00:19:46.710
that we turn on in a
classical computer,

00:19:46.710 --> 00:19:49.126
or currents that we allow to
flow in a classical computer,

00:19:49.126 --> 00:19:51.730
implement the algorithm
that we want to effect.

00:19:51.730 --> 00:19:53.230
We evolve with some
energy operator,

00:19:53.230 --> 00:19:54.130
implementing our
linear algorithm,

00:19:54.130 --> 00:19:55.671
and we get some
output wave function,

00:19:55.671 --> 00:19:59.991
psi-- again-- for our n
bits, n quantum bits, out.

00:19:59.991 --> 00:20:02.240
So this is the basic gig
with the quantum computation.

00:20:02.240 --> 00:20:06.510
We're just replacing strings of
binary numbers and functions--

00:20:06.510 --> 00:20:09.600
evolution according to
classical mechanics in Maxwell--

00:20:09.600 --> 00:20:13.070
to other strings of numbers
with superpositions of states.

00:20:13.070 --> 00:20:15.300
Superpositions of
strings, as it were,

00:20:15.300 --> 00:20:18.310
evolving according to
the Schrodinger equation

00:20:18.310 --> 00:20:21.220
into again general
superposition.

00:20:21.220 --> 00:20:22.340
So how does this differ?

00:20:22.340 --> 00:20:24.892
What are the key differences
from a classical computer?

00:20:24.892 --> 00:20:27.100
So the key things are first
off, the input and output

00:20:27.100 --> 00:20:28.890
are not definite values.

00:20:28.890 --> 00:20:30.640
They could, in general,
be superpositions.

00:20:30.640 --> 00:20:34.850
They do not have to correspond
to a definite state in the 1, 0

00:20:34.850 --> 00:20:36.660
basis.

00:20:36.660 --> 00:20:46.340
These, in general, are
superpositions of 0, 0, 0, 1,

00:20:46.340 --> 00:20:49.280
0, 0, dot dot dot.

00:20:49.280 --> 00:20:57.180
So the input and output
are superpositions

00:20:57.180 --> 00:20:59.290
of the values we'll measure.

00:21:05.180 --> 00:21:06.520
OK.

00:21:06.520 --> 00:21:10.880
Second, when we do measure, at
the end of the day, the output,

00:21:10.880 --> 00:21:13.846
we get interference from
the various different terms

00:21:13.846 --> 00:21:14.720
in the superposition.

00:21:14.720 --> 00:21:15.920
The different terms
in the superposition

00:21:15.920 --> 00:21:17.336
will lead to
interference effects.

00:21:17.336 --> 00:21:19.940
And so our output will be
sensitive to that interference

00:21:19.940 --> 00:21:22.260
between the different
terms in the superposition.

00:21:22.260 --> 00:21:24.350
It may be that we're
in some pure state.

00:21:24.350 --> 00:21:26.080
But it may be, more
generally, we'll

00:21:26.080 --> 00:21:28.840
be in some superposition of
the states we want to measure.

00:21:28.840 --> 00:21:30.298
So we're going to
get interference.

00:21:32.670 --> 00:21:36.210
So naively, this is a
disaster because this

00:21:36.210 --> 00:21:38.185
means we get
probabilistic outcomes.

00:21:42.130 --> 00:21:44.470
That sounds bad.

00:21:44.470 --> 00:21:50.417
And so, this leads to the key
move in quantum computation.

00:21:50.417 --> 00:21:52.250
Given that we're going
to have interference,

00:21:52.250 --> 00:21:54.375
and given that those
interference effects are going

00:21:54.375 --> 00:21:59.620
to affect the probabilities of
various outcomes, what we're

00:21:59.620 --> 00:22:03.980
going to want is to
tune, or orchestrate,

00:22:03.980 --> 00:22:11.340
the interference to
get a definite outcome.

00:22:11.340 --> 00:22:14.870
We want to get the correct
answer out, rather than

00:22:14.870 --> 00:22:16.925
just probably the
correct answer out.

00:22:16.925 --> 00:22:18.550
Now there's a slight
variation of this.

00:22:18.550 --> 00:22:20.450
It's not obvious at the
beginning, how to do that.

00:22:20.450 --> 00:22:21.700
It's not even
clear that you can.

00:22:21.700 --> 00:22:22.970
So I'm going to show
you that you can.

00:22:22.970 --> 00:22:24.970
I'm going to show you an
explicit algorithm that

00:22:24.970 --> 00:22:26.340
realizes this.

00:22:26.340 --> 00:22:29.110
But, OK, that's obviously
going to be tricky.

00:22:29.110 --> 00:22:31.480
Here's something
else you can do.

00:22:31.480 --> 00:22:34.294
You can also focus
on special problems.

00:22:34.294 --> 00:22:35.460
Focus on checkable problems.

00:22:39.850 --> 00:22:42.370
And what I mean
by this is imagine

00:22:42.370 --> 00:22:45.600
we have some algorithm
that gives us an output,

00:22:45.600 --> 00:22:49.740
and that output is
probably the right answer.

00:22:49.740 --> 00:22:50.680
But we're not sure.

00:22:50.680 --> 00:22:52.160
There's some quantum
mechanical probability

00:22:52.160 --> 00:22:54.290
that this is the correct
answer to our computation--

00:22:54.290 --> 00:22:55.914
there's some probability
that it's not.

00:22:55.914 --> 00:22:58.170
So, if the calculation
was difficult,

00:22:58.170 --> 00:23:01.481
but it's easy to check whether
you have the right answer

00:23:01.481 --> 00:23:02.230
then that's great.

00:23:02.230 --> 00:23:04.188
Imagine it's 10% that
you get the right answer,

00:23:04.188 --> 00:23:06.220
but it's trivial to check.

00:23:06.220 --> 00:23:08.010
So, for example,
factoring numbers, right?

00:23:08.010 --> 00:23:09.750
If you multiply the
numbers, that's easy.

00:23:09.750 --> 00:23:11.791
You check to see whether
you got the right thing.

00:23:11.791 --> 00:23:14.980
So, for example, if you imagine
that I build a computer that

00:23:14.980 --> 00:23:16.987
is supposed to factor
numbers-- I almost

00:23:16.987 --> 00:23:18.070
said factor prime numbers.

00:23:18.070 --> 00:23:19.403
That would be a boring computer.

00:23:19.403 --> 00:23:21.750
So imagine that we build a
machine that factors numbers.

00:23:21.750 --> 00:23:22.249
Right?

00:23:22.249 --> 00:23:24.650
And so imagine its
output is probabilistic.

00:23:24.650 --> 00:23:26.860
So, you say 15, and
I say 3 times 5.

00:23:26.860 --> 00:23:28.360
You say 15, I say 5 times 3.

00:23:28.360 --> 00:23:29.692
You say 15, I say 7 tiimes 2.

00:23:29.692 --> 00:23:31.900
At that point, you're like,
well, which one is right?

00:23:31.900 --> 00:23:34.050
Well, you can check
by multiplying.

00:23:34.050 --> 00:23:36.120
So if you have a problem,
which is easy to check,

00:23:36.120 --> 00:23:39.460
but hard to do, then
probablistic is already OK.

00:23:39.460 --> 00:23:42.710
That's just as true classically
as it is quantum mechanically.

00:23:42.710 --> 00:23:44.890
Those are our basic moves.

00:23:44.890 --> 00:23:49.290
And so, the key thing
for us is that when

00:23:49.290 --> 00:23:53.140
we have n quantum bits, we have
these interference effects.

00:23:53.140 --> 00:23:56.100
And in particular, as we
started talking about last time,

00:23:56.100 --> 00:23:57.377
we get entanglement effects.

00:23:57.377 --> 00:23:59.210
What we're going to
discover is that the key

00:23:59.210 --> 00:24:00.580
to making a good
quantum algorithm

00:24:00.580 --> 00:24:02.820
is going to go to attune the
entanglement appropriately.

00:24:02.820 --> 00:24:04.520
So going to have to define
that for you in just a minute.

00:24:04.520 --> 00:24:05.396
Yeah.

00:24:05.396 --> 00:24:08.030
AUDIENCE: [INAUDIBLE].

00:24:08.030 --> 00:24:08.920
PROFESSOR: Sorry?

00:24:08.920 --> 00:24:10.170
AUDIENCE: [INAUDIBLE] process.

00:24:10.170 --> 00:24:12.010
PROFESSOR: Well, it
may or may not be.

00:24:12.010 --> 00:24:15.110
So the check, for example, ,
imagine the process I just gave

00:24:15.110 --> 00:24:15.610
you.

00:24:15.610 --> 00:24:16.980
So the question
is, what do you do

00:24:16.980 --> 00:24:18.688
if the checking process
is probabilistic?

00:24:18.688 --> 00:24:21.040
But you can use a classical
computer to check,

00:24:21.040 --> 00:24:23.560
if you have an easy checking
algorithm-- for example,

00:24:23.560 --> 00:24:24.940
multiplying numbers together.

00:24:24.940 --> 00:24:26.480
AUDIENCE: [INAUDIBLE].

00:24:26.480 --> 00:24:27.250
PROFESSOR: No.

00:24:27.250 --> 00:24:27.460
Good.

00:24:27.460 --> 00:24:28.670
And so the question
then becomes,

00:24:28.670 --> 00:24:30.150
doesn't that defeat the point
of using a quantum computer,

00:24:30.150 --> 00:24:32.066
if you're using a classical
computer to check?

00:24:32.066 --> 00:24:33.570
And so here's the thing.

00:24:33.570 --> 00:24:35.372
If I ask you to factor
a gigantic number,

00:24:35.372 --> 00:24:36.330
what do you have to do?

00:24:36.330 --> 00:24:38.470
Well, you have to take all
numbers up to its square root,

00:24:38.470 --> 00:24:40.095
and you have to
multiply them together,

00:24:40.095 --> 00:24:41.130
and that takes forever.

00:24:41.130 --> 00:24:41.630
Right?

00:24:41.630 --> 00:24:43.810
But if I tell you,
do these two numbers

00:24:43.810 --> 00:24:45.740
multiply to give you
the third number?

00:24:45.740 --> 00:24:46.864
That's easy, right?

00:24:46.864 --> 00:24:48.780
So I use a quantum
computer for the hard part,

00:24:48.780 --> 00:24:50.840
and the classical computer
for the forward part.

00:24:50.840 --> 00:24:51.750
For the checking.

00:24:51.750 --> 00:24:54.230
And that's a special class of
problems which are checkable.

00:24:54.230 --> 00:24:57.030
These all have fancy names
in information theory.

00:24:57.030 --> 00:24:59.372
I'm not going to
use the fancy names.

00:24:59.372 --> 00:25:02.029
AUDIENCE: [INAUDIBLE]
the wave function?

00:25:02.029 --> 00:25:03.070
PROFESSOR: Yeah, exactly.

00:25:03.070 --> 00:25:05.670
I mean, suppose I
give you some output,

00:25:05.670 --> 00:25:08.621
and let's say the output
is 0, 0 plus 1, 1.

00:25:08.621 --> 00:25:09.120
Right?

00:25:09.120 --> 00:25:11.510
What are you going to get,
if you measure the first bit?

00:25:11.510 --> 00:25:13.176
Well, you're either
going to get 0 or 1,

00:25:13.176 --> 00:25:15.980
with one probability
or another, right?

00:25:15.980 --> 00:25:19.905
When we compute
the probabilities

00:25:19.905 --> 00:25:22.280
in general, when we have many
terms in our superposition,

00:25:22.280 --> 00:25:23.905
we're going to get
interference effects

00:25:23.905 --> 00:25:26.080
from different terms
in the superposition.

00:25:26.080 --> 00:25:29.340
And those interference terms
will tune the probability,

00:25:29.340 --> 00:25:33.670
so they're not just the naive
probability of that one thing.

00:25:33.670 --> 00:25:35.422
But you get these
interference terms.

00:25:35.422 --> 00:25:37.130
Norm squared of one,
norm squared of two,

00:25:37.130 --> 00:25:39.840
and then the real part twice
real part of the cross term.

00:25:39.840 --> 00:25:41.080
And that twice the real
part of the cross term

00:25:41.080 --> 00:25:42.380
didn't exist classically.

00:25:42.380 --> 00:25:43.974
Quantum mechanically,
it's important,

00:25:43.974 --> 00:25:45.640
and it can change the
final probability.

00:25:45.640 --> 00:25:47.980
That's what I mean by
the interference effects.

00:25:47.980 --> 00:25:50.310
OK, so let's make all
this much more explicit.

00:25:50.310 --> 00:25:52.140
So far I've just
given you philosophy,

00:25:52.140 --> 00:25:54.490
and you should be deeply
suspicious of philosophy

00:25:54.490 --> 00:25:57.740
in a physics classroom.

00:25:57.740 --> 00:26:03.890
So, again, to be explicit,
a quantum bit, or qubit,

00:26:03.890 --> 00:26:06.450
is equal to a two state
system, and, again,

00:26:06.450 --> 00:26:09.410
the substrate doesn't matter.

00:26:09.410 --> 00:26:12.480
I could be talking
about spin-1/2 systems,

00:26:12.480 --> 00:26:17.800
or I could be talking about
ropes on a cylinder with

00:26:17.800 --> 00:26:18.550
winding mod 2.

00:26:18.550 --> 00:26:20.424
I could be talking about
all sorts of things.

00:26:20.424 --> 00:26:25.910
But it's some system with
two quantum states, 0 and 1.

00:26:25.910 --> 00:26:28.530
I want to emphasize this is
not going to be on the final.

00:26:28.530 --> 00:26:32.220
So this is just for
your moral well being.

00:26:32.220 --> 00:26:34.587
So a quantum bit is
a two state system.

00:26:34.587 --> 00:26:36.670
We have these two states,
which I'll call 0 and 1,

00:26:36.670 --> 00:26:39.360
and a general state, the
general wave function, psi,

00:26:39.360 --> 00:26:43.730
is equal to alpha 0 plus beta 1.

00:26:43.730 --> 00:26:44.440
OK.

00:26:44.440 --> 00:26:47.900
And what this means is the
probability that I measure 0

00:26:47.900 --> 00:26:50.320
is equal to norm alpha
squared, et cetera.

00:26:50.320 --> 00:26:52.680
OK.

00:26:52.680 --> 00:26:54.287
Now, again many
systems can be used--

00:26:54.287 --> 00:26:55.370
many different substrates.

00:26:55.370 --> 00:26:57.602
This is what I'm going
to mean by a qubit.

00:26:57.602 --> 00:26:59.340
So that's one qubit.

00:26:59.340 --> 00:27:01.767
The much more interesting
system is two qubits.

00:27:01.767 --> 00:27:02.850
So let's study two qubits.

00:27:06.670 --> 00:27:09.220
So in the case of two qubits,
what's a general state?

00:27:09.220 --> 00:27:10.862
Well a general state
is going to be,

00:27:10.862 --> 00:27:12.320
well, the first
particle could be 0

00:27:12.320 --> 00:27:14.985
and the second particle
could also be 0.

00:27:14.985 --> 00:27:16.790
Or we could have
the first particle 0

00:27:16.790 --> 00:27:19.460
and the second particle
1, with some coefficient,

00:27:19.460 --> 00:27:28.860
plus beta, plus gamma
1, 0, plus delta 0, 1.

00:27:28.860 --> 00:27:29.384
OK.

00:27:29.384 --> 00:27:31.050
So this is just a
general superposition.

00:27:31.050 --> 00:27:32.716
Now, you might worry
at this point look,

00:27:32.716 --> 00:27:35.180
are these identical, or
these non-identical spins?

00:27:35.180 --> 00:27:36.270
But here's the thing.

00:27:36.270 --> 00:27:38.000
I've got a spin
here-- it's in a box--

00:27:38.000 --> 00:27:39.020
and I've got another
spin here-- it's

00:27:39.020 --> 00:27:40.410
in a box-- I've got
another qubit over here.

00:27:40.410 --> 00:27:40.980
It's in a box.

00:27:40.980 --> 00:27:42.030
So they're distinguishable
because they're

00:27:42.030 --> 00:27:43.920
in different places
in my laboratory.

00:27:43.920 --> 00:27:46.400
So these are
distinguishable particles.

00:27:46.400 --> 00:27:48.900
The particle in this box
is either up or down.

00:27:48.900 --> 00:27:49.400
OK.

00:27:49.400 --> 00:27:50.858
So these are
distinguishable, and I

00:27:50.858 --> 00:27:53.176
don't have to worry about
symmetrizatoin, Bosonic

00:27:53.176 --> 00:27:54.800
or Fermionc statistics,
or any of that.

00:27:54.800 --> 00:27:56.170
They're distinguishable.

00:27:56.170 --> 00:27:58.040
And we need normalization,
so norm alpha

00:27:58.040 --> 00:28:01.010
squared plus dot dot
dot is equal to 1.

00:28:01.010 --> 00:28:02.010
And what does this mean?

00:28:02.010 --> 00:28:04.218
What this means is that,
for example, the probability

00:28:04.218 --> 00:28:07.220
of the first part, which
I'll call a is equal to 0,

00:28:07.220 --> 00:28:10.542
is equal to-- well, we sum
up all the possible ways

00:28:10.542 --> 00:28:11.250
we could do that.

00:28:11.250 --> 00:28:16.000
We have norm alpha squared
plus norm beta squared.

00:28:16.000 --> 00:28:18.910
Whoops-- this was 1, 1.

00:28:18.910 --> 00:28:20.340
Thank you.

00:28:20.340 --> 00:28:24.590
And if we're more specific, the
probability of the first qubit

00:28:24.590 --> 00:28:28.890
is 0, and the second qubit
is 1-- is equal to 1.

00:28:28.890 --> 00:28:29.650
I need 0, 1.

00:28:29.650 --> 00:28:32.740
That's this guy,
norm beta squared.

00:28:32.740 --> 00:28:33.830
OK.

00:28:33.830 --> 00:28:34.980
What I mean by two qubits.

00:28:34.980 --> 00:28:37.430
But this immediately
leads to a funny thing.

00:28:37.430 --> 00:28:40.670
There are two kinds of
states that a pair of qubits

00:28:40.670 --> 00:28:43.540
could be in, a very
special set of states,

00:28:43.540 --> 00:28:48.800
which are called
separable states.

00:28:48.800 --> 00:28:50.120
And these are special.

00:28:53.760 --> 00:28:58.400
And these states correspond
to the full system

00:28:58.400 --> 00:29:00.735
being in the state where
the first particles is

00:29:00.735 --> 00:29:02.380
in one state, and
the second particle

00:29:02.380 --> 00:29:04.370
is in the second state.

00:29:04.370 --> 00:29:04.870
OK.

00:29:04.870 --> 00:29:09.730
So, for example,
this could be eg

00:29:09.730 --> 00:29:18.690
the state 1 over
root 2-- sorry-- 0

00:29:18.690 --> 00:29:23.110
plus 1 for the first particle,
and the second particle

00:29:23.110 --> 00:29:29.078
to be in the state 1
over root 2, 0, minus 1.

00:29:33.020 --> 00:29:38.180
[INAUDIBLE] Let's just call
these general coefficients.

00:29:38.180 --> 00:29:45.010
a plus b and times c plus d.

00:29:45.010 --> 00:29:46.230
So what does this equal to?

00:29:46.230 --> 00:29:47.875
Well, this is of
the form-- there's

00:29:47.875 --> 00:29:53.140
going to be a term that's
0, 0, and that's ac.

00:29:53.140 --> 00:29:58.420
Plus a term that's 0, 1,
and that's ad with a minus.

00:29:58.420 --> 00:30:00.970
Minus ad.

00:30:00.970 --> 00:30:03.340
Plus a term that's 1, 0.

00:30:03.340 --> 00:30:04.500
That's bc.

00:30:04.500 --> 00:30:11.200
And minus a term that's
1, 1, and that's bd.

00:30:11.200 --> 00:30:11.890
OK.

00:30:11.890 --> 00:30:13.582
This is clearly not
generic, because it

00:30:13.582 --> 00:30:15.790
implies relationships amongst
the alpha, beta, delta,

00:30:15.790 --> 00:30:19.020
gamma, apart from
just normalizability.

00:30:19.020 --> 00:30:20.444
Everyone see that?

00:30:20.444 --> 00:30:21.860
So it's a pretty
non-trivial thing

00:30:21.860 --> 00:30:24.027
that you can write a thing
as, the first particle is

00:30:24.027 --> 00:30:26.485
in one state, and the second
particles in the second state.

00:30:26.485 --> 00:30:28.260
And here's physically
what that means.

00:30:28.260 --> 00:30:34.163
Physically, what that
means is that, if you're

00:30:34.163 --> 00:30:36.300
in a state like this,
and I ask you, what's

00:30:36.300 --> 00:30:40.260
the probability that I measure
the first particle to be 0,

00:30:40.260 --> 00:30:42.320
do I need to know anything
about the state of b?

00:30:45.200 --> 00:30:45.764
No.

00:30:45.764 --> 00:30:47.180
If I want to know
what probability

00:30:47.180 --> 00:30:49.100
of the first particle is 0,
I just take norm a squared.

00:30:49.100 --> 00:30:50.560
Because I'm going
to get plus norm

00:30:50.560 --> 00:30:51.810
c squared plus norm d squared.

00:30:56.515 --> 00:30:57.140
So that's fine.

00:30:57.140 --> 00:30:59.320
So, imagine the probability
of the first particle

00:30:59.320 --> 00:31:02.130
being up or down is
independent of any information

00:31:02.130 --> 00:31:03.540
about the second
particle, right?

00:31:03.540 --> 00:31:04.740
There is another thing
that's important.

00:31:04.740 --> 00:31:06.406
Suppose I tell you,
ah ha I've measured,

00:31:06.406 --> 00:31:08.490
and the first particle
is in the state 0.

00:31:08.490 --> 00:31:09.020
OK.

00:31:09.020 --> 00:31:09.450
Cool?

00:31:09.450 --> 00:31:11.491
What is the state subsequent
to that measurement?

00:31:13.950 --> 00:31:16.920
So if we measure
a is equal to 0,

00:31:16.920 --> 00:31:18.640
what is the state subsequent?

00:31:18.640 --> 00:31:21.670
Psi is equal to--
well, that's 0,

00:31:21.670 --> 00:31:24.645
and we know we've lost this,
so this particular subsystem,

00:31:24.645 --> 00:31:27.930
this particular qubit has
been collapsed to the state 0,

00:31:27.930 --> 00:31:37.544
so we have 0 times c, 0, minus
d, 1 for the second particle.

00:31:37.544 --> 00:31:39.210
Have we learned
anything about the state

00:31:39.210 --> 00:31:40.168
of the second particle?

00:31:43.644 --> 00:31:45.310
Have we learned
anything about the state

00:31:45.310 --> 00:31:46.850
of the second particle?

00:31:46.850 --> 00:31:47.640
Absolutely not.

00:31:47.640 --> 00:31:48.140
Right?

00:31:48.140 --> 00:31:49.640
Beforehand, what
was the probability

00:31:49.640 --> 00:31:52.360
that the second article is 0?

00:31:52.360 --> 00:31:53.180
Norm c squared.

00:31:53.180 --> 00:31:54.450
And the second particle 1?

00:31:54.450 --> 00:31:55.282
Norm d squared.

00:31:55.282 --> 00:31:56.240
Now what's the problem?

00:31:56.240 --> 00:31:56.739
Same.

00:31:56.739 --> 00:31:58.140
Norm c squared, norm d squared.

00:31:58.140 --> 00:31:59.640
So when you have a
seperable system,

00:31:59.640 --> 00:32:02.990
measuring one qubit tells you
nothing about the other qubit.

00:32:02.990 --> 00:32:03.930
Cool?

00:32:03.930 --> 00:32:08.330
On the other hand, consider a
state which is not separable.

00:32:08.330 --> 00:32:19.369
So the generic states
are not separable.

00:32:19.369 --> 00:32:21.410
And let me give you an
example of the state which

00:32:21.410 --> 00:32:22.750
is not seperable.

00:32:22.750 --> 00:32:23.980
Which one do I want to pick?

00:32:23.980 --> 00:32:24.930
Yeah, what the hell.

00:32:24.930 --> 00:32:34.430
Psi is 1 over root
2, 0, 0, plus 1, 1.

00:32:34.430 --> 00:32:35.960
Can this be written
as the product

00:32:35.960 --> 00:32:37.376
of the first
particle in one state

00:32:37.376 --> 00:32:38.918
and the second
particle in the other?

00:32:38.918 --> 00:32:41.042
No, because they were have
to be cross terms, which

00:32:41.042 --> 00:32:41.800
don't exist here.

00:32:41.800 --> 00:32:43.383
Right, just compare
this to that form.

00:32:43.383 --> 00:32:45.670
So, we have that the
coefficient of 0, 0 is ac.

00:32:45.670 --> 00:32:47.960
So a and c must
both be non-zero,

00:32:47.960 --> 00:32:49.880
and the coefficient
of 1, 1 is bd.

00:32:49.880 --> 00:32:52.810
So the coefficient bd must be--
both of those must be non-zero.

00:32:52.810 --> 00:32:54.554
So ac and bd are all non-zero.

00:32:54.554 --> 00:32:56.720
That means these terms have
to exist in order for it

00:32:56.720 --> 00:32:59.392
to be separable.

00:32:59.392 --> 00:33:00.257
Yeah?

00:33:00.257 --> 00:33:01.715
Because a and b
[? can't ?] vanish,

00:33:01.715 --> 00:33:04.131
and b and c [? can't ?] vanish
And these orthogonal states

00:33:04.131 --> 00:33:05.010
are independent.

00:33:05.010 --> 00:33:07.389
So this is not a
separable state.

00:33:07.389 --> 00:33:08.680
We call these states entangled.

00:33:11.720 --> 00:33:18.900
And it's funny,
because [INAUDIBLE] I

00:33:18.900 --> 00:33:20.825
think there's an e in there.

00:33:20.825 --> 00:33:21.700
AUDIENCE: [INAUDIBLE]

00:33:26.417 --> 00:33:27.000
PROFESSOR: OK.

00:33:27.000 --> 00:33:29.920
That's better.

00:33:29.920 --> 00:33:33.710
Look, I'm not a
professor of spelling.

00:33:33.710 --> 00:33:36.300
It's a little bit funny to
give these a special name

00:33:36.300 --> 00:33:41.220
and call them entangled, because
the generic state is entangled.

00:33:41.220 --> 00:33:45.080
It's sort of like
calling mice, mice,

00:33:45.080 --> 00:33:48.650
and calling all the
other mammals non-mice.

00:33:48.650 --> 00:33:50.660
Oh look, well, that
was bad example.

00:33:50.660 --> 00:33:52.605
Oh look at mice right
across from [INAUDIBLE].

00:33:52.605 --> 00:33:55.280
AUDIENCE: [LAUGHS].

00:33:55.280 --> 00:33:58.309
PROFESSOR: Hearkening back
to an earlier lecture.

00:33:58.309 --> 00:34:00.225
So, in any case, we give
these a special name,

00:34:00.225 --> 00:34:01.830
and the reason we give
them a special name

00:34:01.830 --> 00:34:03.940
is that these seperable states
do you more or less what

00:34:03.940 --> 00:34:04.760
you'd expect classically.

00:34:04.760 --> 00:34:05.990
There are no
strange correlations

00:34:05.990 --> 00:34:08.080
between the state of one
and the state of the other.

00:34:08.080 --> 00:34:08.980
They're independent quantities.

00:34:08.980 --> 00:34:11.409
But when you have a generic
state, something funny happens.

00:34:11.409 --> 00:34:12.030
They're entangled.

00:34:12.030 --> 00:34:13.696
And here's the funny
thing that happens.

00:34:13.696 --> 00:34:16.920
Suppose given the state, what's
the probability that I measure

00:34:16.920 --> 00:34:20.520
the first particle
be up, or to be 0?

00:34:20.520 --> 00:34:21.250
1/2.

00:34:21.250 --> 00:34:23.583
What's the probability that
I measure the first particle

00:34:23.583 --> 00:34:25.389
to be 1?

00:34:25.389 --> 00:34:26.770
1/2.

00:34:26.770 --> 00:34:29.510
So, before doing
any measurements,

00:34:29.510 --> 00:34:31.790
the first particle is
equally likely to be 0 or 1.

00:34:31.790 --> 00:34:35.719
So suppose I measure the
second particle to be up.

00:34:35.719 --> 00:34:37.000
OK.

00:34:37.000 --> 00:34:40.130
Then the probability that I
measure the first particle is 0

00:34:40.130 --> 00:34:43.090
is equal to 0, and
the probability

00:34:43.090 --> 00:34:46.462
that the first particle
is 1 is equal to 1,

00:34:46.462 --> 00:34:48.670
because I've this collapse
onto this term in the wave

00:34:48.670 --> 00:34:51.070
pack, the wave function.

00:34:51.070 --> 00:34:54.909
So measuring the second
qubit alters the probability

00:34:54.909 --> 00:34:56.900
distribution for
the first qubit.

00:34:56.900 --> 00:34:59.166
These guys aren't independent.

00:34:59.166 --> 00:35:00.790
They are correllated,
in a way that you

00:35:00.790 --> 00:35:01.960
studied on the problem set.

00:35:01.960 --> 00:35:02.793
They are correlated.

00:35:02.793 --> 00:35:05.570
They're in a correlated state.

00:35:05.570 --> 00:35:08.866
We call this correlation
entanglement.

00:35:08.866 --> 00:35:10.990
And here's the thing that's
most spooky about this,

00:35:10.990 --> 00:35:12.690
and we'll come back to
this in a few minutes,

00:35:12.690 --> 00:35:14.860
but I didn't tell you
anything about the geometry

00:35:14.860 --> 00:35:15.541
of the set up.

00:35:15.541 --> 00:35:17.790
But, in fact, when I was
thinking of that measurement,

00:35:17.790 --> 00:35:20.900
I built the two little qubits
in my lab, and I took one,

00:35:20.900 --> 00:35:24.180
and I sent it to France--
because France, you know.

00:35:24.180 --> 00:35:27.630
And I took the other one, and
I said it to the planet Zorg.

00:35:27.630 --> 00:35:30.070
And so off on the planet is
some poor experimentalist

00:35:30.070 --> 00:35:31.240
huddling in the cold.

00:35:31.240 --> 00:35:34.630
And our French experimentalist
makes a measurement,

00:35:34.630 --> 00:35:37.500
altering the probability
distribution instantaneously

00:35:37.500 --> 00:35:39.890
on Zorg.

00:35:39.890 --> 00:35:41.980
That should make you
a little worried.

00:35:41.980 --> 00:35:43.480
That sounds a little crazy.

00:35:43.480 --> 00:35:45.890
We'll come back to why
that is or isn't crazy,

00:35:45.890 --> 00:35:50.680
and the EPR analysis,
which puts flesh on it,

00:35:50.680 --> 00:35:52.892
sounds crazy, in a little bit.

00:35:52.892 --> 00:35:54.600
But for the moment,
let me just emphasize

00:35:54.600 --> 00:35:56.170
that, while the generic
state is entangled,

00:35:56.170 --> 00:35:57.810
the generic state is
also different than what

00:35:57.810 --> 00:35:59.590
your classical
intuition would expect.

00:35:59.590 --> 00:36:02.780
There are correlations
between the particles.

00:36:02.780 --> 00:36:05.457
So this is something
that happens

00:36:05.457 --> 00:36:07.040
with quantum mechanical
particles that

00:36:07.040 --> 00:36:08.744
doesn't happen with
classical particles.

00:36:08.744 --> 00:36:10.160
And that means
it's something that

00:36:10.160 --> 00:36:12.620
can be used in a
quantum computer that

00:36:12.620 --> 00:36:15.520
can't be used in a
classical computer.

00:36:15.520 --> 00:36:17.740
So let's see what
using entanglement

00:36:17.740 --> 00:36:21.230
gives us for computation.

00:36:21.230 --> 00:36:24.420
So let's go come back to the
quantum computing problem.

00:36:24.420 --> 00:36:27.430
And how do we
compute with qubits?

00:36:27.430 --> 00:36:28.449
So how to compute.

00:36:33.301 --> 00:36:33.800
OK.

00:36:33.800 --> 00:36:39.519
So again, as usual, the way we
take our input to our output

00:36:39.519 --> 00:36:41.060
is we build a machine
that implements

00:36:41.060 --> 00:36:42.940
an algorithm of our
choice by arranging

00:36:42.940 --> 00:36:44.940
the physical evolution
of the system under time.

00:36:44.940 --> 00:36:48.800
So that means picking
an electric field.

00:36:48.800 --> 00:36:52.250
Sorry, an energy operator--
an electric field, good lord.

00:36:52.250 --> 00:36:55.090
So it means picking
an energy operator.

00:36:55.090 --> 00:36:55.590
OK.

00:36:55.590 --> 00:37:02.180
So computing is Schroedinger
evolution with our chosen,

00:37:02.180 --> 00:37:06.780
our attuned, energy operator.

00:37:06.780 --> 00:37:08.850
So, for example, I
want to build for you

00:37:08.850 --> 00:37:10.910
now a couple of basic
circuit elements

00:37:10.910 --> 00:37:13.020
that you might want to
use in a quantum computer.

00:37:13.020 --> 00:37:14.806
So example one.

00:37:14.806 --> 00:37:17.820
The first example is, I
want to build a NOT gate

00:37:17.820 --> 00:37:20.880
And what NOT means is
that it takes the state 0

00:37:20.880 --> 00:37:25.581
and gives me 1, and it takes
the state 1, and it gives me 0.

00:37:25.581 --> 00:37:26.080
OK.

00:37:26.080 --> 00:37:27.742
This is what NOT does.

00:37:27.742 --> 00:37:28.950
So how do I build a NOT gate?

00:37:28.950 --> 00:37:34.050
Well, I can realize
this in a nice way.

00:37:34.050 --> 00:37:34.770
Doot do do.

00:37:34.770 --> 00:37:35.210
Do I want to say it that way?

00:37:35.210 --> 00:37:35.950
Yeah, good.

00:37:35.950 --> 00:37:39.970
So if I realize 0
as 1, 0, and 1 as 0,

00:37:39.970 --> 00:37:50.690
1 from last lecture and 0, 1 to
1, 0, so we need an operator.

00:37:50.690 --> 00:37:55.180
We need time evolution to effect
multiplication by an operator.

00:37:55.180 --> 00:37:56.960
That takes this
vector to this vector,

00:37:56.960 --> 00:37:58.340
and this vector to this vector.

00:37:58.340 --> 00:38:00.580
We know what that
unitary operation is.

00:38:00.580 --> 00:38:04.380
That unitary operation,
which I'll call NOT,

00:38:04.380 --> 00:38:07.000
must equal to 0, 1, 1, 0.

00:38:07.000 --> 00:38:09.570
And this operation takes
this guy to this guy,

00:38:09.570 --> 00:38:11.440
and it takes this
guy to this guy.

00:38:11.440 --> 00:38:13.630
Yeah?

00:38:13.630 --> 00:38:18.115
But I can write this
as-- I like this-- shoot,

00:38:18.115 --> 00:38:26.100
there's a phase-- minus i, e
to the i pi over 2, 0, 1, 1, 0.

00:38:28.715 --> 00:38:30.090
I mean, you can't
stop me, right?

00:38:30.090 --> 00:38:34.930
So this expanded out, as we've
done before, expanding this out

00:38:34.930 --> 00:38:37.260
gives me, with
the exponential, 1

00:38:37.260 --> 00:38:39.580
plus the thing and
all the other terms.

00:38:39.580 --> 00:38:45.240
This becomes minus i times
cosine of pi over 2 times

00:38:45.240 --> 00:38:47.710
the identity, the
2 by 2 identity,

00:38:47.710 --> 00:38:55.170
up plus i sine of pi
over 2 times 0, 1, 1, 0.

00:38:57.720 --> 00:38:59.620
But what's cosine of pi upon 2?

00:39:02.400 --> 00:39:03.890
Yeah, 0.

00:39:03.890 --> 00:39:04.390
Come on.

00:39:04.390 --> 00:39:05.360
Is everyone that tired?

00:39:05.360 --> 00:39:06.670
So cosine pi over 2 is 0.

00:39:06.670 --> 00:39:08.040
Up.

00:39:08.040 --> 00:39:10.970
Sine of pi upon 2 is 1,
because i times minus i,

00:39:10.970 --> 00:39:13.470
that's 1 times 0, 1, 1, 0.

00:39:13.470 --> 00:39:14.110
Pretty solid.

00:39:14.110 --> 00:39:14.820
But what is this?

00:39:14.820 --> 00:39:16.960
Well this is the form
Schroedinger evolution

00:39:16.960 --> 00:39:19.460
with a magnetic field,
and this is just

00:39:19.460 --> 00:39:24.549
the unitary transformation
unitary transformation

00:39:24.549 --> 00:39:28.010
for a magnetic field.

00:39:28.010 --> 00:39:28.510
Well, OK.

00:39:28.510 --> 00:39:29.330
We can say this.

00:39:29.330 --> 00:39:32.270
This is the x polymatrix
from last time.

00:39:32.270 --> 00:39:35.170
So this is like Sx,
unitary transformation

00:39:35.170 --> 00:39:39.770
for a magnetic field in the
x-direction for some time t.

00:39:39.770 --> 00:39:43.420
For time t times the frequency,
omega, which is given by mu B

00:39:43.420 --> 00:39:48.761
upon 2 is equal to pi upon 2.

00:39:48.761 --> 00:39:49.260
OK.

00:39:49.260 --> 00:39:51.385
Just like before, but for
a slightly different one.

00:39:51.385 --> 00:39:52.885
A slightly different
magnetic field.

00:39:52.885 --> 00:39:54.610
So my point here
is that we can pick

00:39:54.610 --> 00:39:56.800
a magnetic field that does this.

00:39:56.800 --> 00:39:58.910
We turn a magnetic field
with a known amplitude

00:39:58.910 --> 00:40:00.780
with a known amount
of time, details here

00:40:00.780 --> 00:40:01.687
don't matter so much.

00:40:01.687 --> 00:40:02.770
The point is we can do it.

00:40:02.770 --> 00:40:04.603
We turn a magnetic field
in the x-direction,

00:40:04.603 --> 00:40:06.060
and it takes 0 to 1 and 1 to 0.

00:40:06.060 --> 00:40:07.240
Everyone cool with that?

00:40:07.240 --> 00:40:09.860
So here is a substrate,
an actual physical system

00:40:09.860 --> 00:40:11.550
that effects this
particular evolution.

00:40:11.550 --> 00:40:12.840
I can build a NOT.

00:40:12.840 --> 00:40:15.020
The crucial thing is that
I can build a NOT gate.

00:40:15.020 --> 00:40:19.200
And I'll represent that not with
some unitary transformation U

00:40:19.200 --> 00:40:19.700
sub NOT.

00:40:22.290 --> 00:40:25.250
So that's a useful one, but
that's not the most useful gate

00:40:25.250 --> 00:40:28.620
because, if you only
ever impose logical NOTs,

00:40:28.620 --> 00:40:30.100
you just get everyone angry.

00:40:30.100 --> 00:40:32.400
But you don't actually
get anything done.

00:40:32.400 --> 00:40:36.170
Second example-- let that be
a lesson to you, Congress.

00:40:36.170 --> 00:40:39.020
So, the second
example, if we turn

00:40:39.020 --> 00:40:43.160
on the magnetic field
in the y-direction

00:40:43.160 --> 00:40:50.420
for a particular
time t, what we find

00:40:50.420 --> 00:40:59.430
is that 0 goes to 1
over root 2, 0 plus 1,

00:40:59.430 --> 00:41:08.794
and 1 goes to 1 over
upon root 2 0 minus 1.

00:41:08.794 --> 00:41:09.960
And this should be familiar.

00:41:09.960 --> 00:41:12.390
This is the up x state, and
this is the down x state.

00:41:12.390 --> 00:41:13.717
Just as we talked before.

00:41:13.717 --> 00:41:15.550
So we turn on some B
field, and we get this.

00:41:20.530 --> 00:41:23.100
So this operation has
a name because it's

00:41:23.100 --> 00:41:25.080
going to turn out to
be very useful for us.

00:41:25.080 --> 00:41:27.540
It's taking a system that's
definitely in the state 0,

00:41:27.540 --> 00:41:28.930
for sure, right?

00:41:28.930 --> 00:41:31.050
And it put us in a
superposition of 0, 1.

00:41:31.050 --> 00:41:32.800
It's a definite
superposition, so it's not

00:41:32.800 --> 00:41:34.174
like we don't know
what happened.

00:41:34.174 --> 00:41:36.755
But it's a superposition,
and you've lost certainty

00:41:36.755 --> 00:41:39.880
that you'll measure
up in the z-direction.

00:41:39.880 --> 00:41:42.620
You've gained certainty that you
measure up in the x-direction.

00:41:42.620 --> 00:41:44.330
But if we do all our
measurements in z,

00:41:44.330 --> 00:41:47.200
we just taking ourselves from
definite to superposition.

00:41:47.200 --> 00:41:47.700
Cool?

00:41:47.700 --> 00:41:50.158
So that's useful because we
know that's something a quantum

00:41:50.158 --> 00:41:52.460
computer can do, that a
classical computer can't do.

00:41:52.460 --> 00:41:54.440
Something a quantum
computer can take advantage

00:41:54.440 --> 00:41:55.981
of that classical
computer can't take

00:41:55.981 --> 00:41:58.170
advantage of is this
process of putting things

00:41:58.170 --> 00:41:59.080
into superpositions.

00:41:59.080 --> 00:42:00.140
So here we've got
an operation that

00:42:00.140 --> 00:42:01.390
puts things in superpositions.

00:42:01.390 --> 00:42:02.759
And I'll call this Hadamard.

00:42:02.759 --> 00:42:05.050
I don't know the history of
why that's called Hadamard,

00:42:05.050 --> 00:42:07.425
presumably there's some guy
with a last name of Hadamard.

00:42:07.425 --> 00:42:08.980
Anyway, the U
Hadamard does this.

00:42:08.980 --> 00:42:11.840
And as a matrix, it's
represented as 1 over root 2,

00:42:11.840 --> 00:42:13.790
times 1, 1, 1, minus 1.

00:42:19.230 --> 00:42:20.920
And there's a the
last one, which

00:42:20.920 --> 00:42:30.350
is going to be useful for me,
another one is called C C-NOT.

00:42:30.350 --> 00:42:32.154
Controlled-NOT.

00:42:32.154 --> 00:42:33.820
Controlled-NOT does
a really cool thing.

00:42:33.820 --> 00:42:37.830
It takes 0, 0, and 0,
1 and 1, 0, and 1, 1.

00:42:37.830 --> 00:42:39.980
What does is it says,
I'm going to apply a NOT

00:42:39.980 --> 00:42:45.180
to the second qubit if, and
only if, the first qubit is 1.

00:42:45.180 --> 00:42:48.250
So this takes me to--
0, 0 goes to-- well,

00:42:48.250 --> 00:42:49.710
do I perform an NOT on this bit?

00:42:49.710 --> 00:42:51.440
No, so 0, 0.

00:42:51.440 --> 00:42:52.950
Do we perform a NOT on this bit?

00:42:52.950 --> 00:42:55.700
No, 0, 1.

00:42:55.700 --> 00:42:58.340
Now I do perform a NOT
on 0, so I get 1, 1.

00:42:58.340 --> 00:43:01.060
And 1, 1-- I perform a NOT on
this bit, which gives me 1, 0.

00:43:04.420 --> 00:43:05.900
So this is called
controlled-NOT.

00:43:05.900 --> 00:43:08.120
It's a very useful thing.

00:43:08.120 --> 00:43:10.867
I'm going to represent
this in the following way.

00:43:10.867 --> 00:43:12.200
I should represent all of these.

00:43:12.200 --> 00:43:16.242
So this NOT gate, first,
I take some initial bit,

00:43:16.242 --> 00:43:17.200
and it's in some state.

00:43:17.200 --> 00:43:22.790
And then I impose U-NOT, and
it gives me an out state.

00:43:22.790 --> 00:43:26.700
Similarly, with the Hadamard,
I take an initial state n,

00:43:26.700 --> 00:43:29.590
and I've apply U Hadamard.

00:43:29.590 --> 00:43:33.370
And I get u out.

00:43:33.370 --> 00:43:36.830
And for controlled-NOT,
I now have two qubits.

00:43:36.830 --> 00:43:40.780
And I take the two qubits,
and I do a controlled-NOT,

00:43:40.780 --> 00:43:42.550
which is represented
in this form.

00:43:42.550 --> 00:43:47.960
Which says, do a NOT
on this guy, controlled

00:43:47.960 --> 00:43:49.780
by this first bit.

00:43:49.780 --> 00:43:54.960
And so this acts as U C-NOT.

00:43:54.960 --> 00:43:56.989
OK.

00:43:56.989 --> 00:43:59.030
And the key thing here,
is that while it's always

00:43:59.030 --> 00:44:01.580
possible to find a physical
real representation

00:44:01.580 --> 00:44:03.384
of some particular
unitary transformation,

00:44:03.384 --> 00:44:06.050
at the end of the day, all we're
going need is some truth table.

00:44:06.050 --> 00:44:07.466
At the end of the
day, all we need

00:44:07.466 --> 00:44:09.160
is the logic that's
being effected.

00:44:09.160 --> 00:44:10.700
And so, the details
of the substrate

00:44:10.700 --> 00:44:11.710
can be abstracted away.

00:44:15.260 --> 00:44:17.290
So what we do with this?

00:44:17.290 --> 00:44:19.580
First, so what can we do?

00:44:19.580 --> 00:44:22.600
Before we actually talk about
what we can do with it, let's

00:44:22.600 --> 00:44:25.330
briefly talk about what
you can't do with it.

00:44:25.330 --> 00:44:29.260
So what are things you can't do
with these sorts of operations?

00:44:29.260 --> 00:44:30.392
What can't you do?

00:44:38.500 --> 00:44:41.960
And to me this is among
the more surprising things.

00:44:41.960 --> 00:44:43.630
Remember that what
we're doing here

00:44:43.630 --> 00:44:46.290
is going to be evolving a system
for a Schroedinger evolution,

00:44:46.290 --> 00:44:50.076
and a Schroedinger
evolution is linear,

00:44:50.076 --> 00:44:52.040
it respects superpositions,
it's unitary,

00:44:52.040 --> 00:44:57.595
it preserves probability,
and let's just focus on that.

00:44:57.595 --> 00:44:58.970
It's linear,
unitary, and it lots

00:44:58.970 --> 00:45:01.630
of other properties,
[? temporal ?] invariance,

00:45:01.630 --> 00:45:04.059
unless you turn on a
magnetic field, which you do.

00:45:04.059 --> 00:45:05.850
But in particular, it's
linear and unitary.

00:45:05.850 --> 00:45:08.520
And those facts are going
to constrain, powerfully,

00:45:08.520 --> 00:45:13.100
the kinds of operations we can
effect on a quantum system.

00:45:13.100 --> 00:45:15.230
So, in particular, when we
look at just two qubits,

00:45:15.230 --> 00:45:16.813
there's a beautiful,
beautiful theorem

00:45:16.813 --> 00:45:18.815
says there's no cloning.

00:45:18.815 --> 00:45:19.940
And here's what that means.

00:45:19.940 --> 00:45:22.784
The no cloning theorem,
pretty high flautin'

00:45:22.784 --> 00:45:24.700
for what it really is,
which is the following.

00:45:24.700 --> 00:45:27.160
Suppose we have a system,
which has input xy.

00:45:29.454 --> 00:45:31.370
And I want to build a
machine that says, look,

00:45:31.370 --> 00:45:33.710
I've got this first qubit
it in the state x, and what

00:45:33.710 --> 00:45:35.140
I want to do is I
want to make a copy.

00:45:35.140 --> 00:45:36.490
I want to make another
quantum system that's

00:45:36.490 --> 00:45:38.580
in exactly the same
state as whatever x is.

00:45:38.580 --> 00:45:41.640
So you hand me a system where
first bit's in state tax,

00:45:41.640 --> 00:45:43.170
and the second
qubit's in state y.

00:45:43.170 --> 00:45:44.830
And I want to make a copy of x.

00:45:44.830 --> 00:45:48.310
And y is just, who
cares what's in it?

00:45:48.310 --> 00:45:52.680
So I want this to go to x, x.

00:45:52.680 --> 00:45:53.180
OK.

00:45:53.180 --> 00:45:55.654
For all y.

00:45:55.654 --> 00:45:57.470
So regardless of what
data was in here,

00:45:57.470 --> 00:45:59.790
I want to overwrite
that data, and rewrite--

00:45:59.790 --> 00:46:02.600
or that datem--
rewrite it with x.

00:46:02.600 --> 00:46:04.490
Can you do this?

00:46:04.490 --> 00:46:05.150
No, right.

00:46:05.150 --> 00:46:05.650
Why?

00:46:08.117 --> 00:46:08.992
AUDIENCE: [INAUDIBLE]

00:46:11.425 --> 00:46:12.300
PROFESSOR: Excellent.

00:46:12.300 --> 00:46:15.690
It would violate linearity
and also unitarity, indeed.

00:46:15.690 --> 00:46:18.830
So to see that quickly, it's
easiest to see the unitarity,

00:46:18.830 --> 00:46:19.356
I think.

00:46:19.356 --> 00:46:21.480
Well, it violates them
both, but for unitarity, you

00:46:21.480 --> 00:46:24.110
manage to take a linear
combination of these guys,

00:46:24.110 --> 00:46:25.855
where the two states
y are orthogonal,

00:46:25.855 --> 00:46:27.280
and you take the norm squared.

00:46:27.280 --> 00:46:29.594
So you've normalized it to 1.

00:46:29.594 --> 00:46:31.010
The linear combination
of each one

00:46:31.010 --> 00:46:33.620
goes to Sx, where
the coefficient

00:46:33.620 --> 00:46:35.240
is the sum of those two terms.

00:46:35.240 --> 00:46:42.000
So we have, for example,
x z, alpha x z plus beta

00:46:42.000 --> 00:46:47.835
x y goes to alpha plus beta x x.

00:46:50.370 --> 00:46:53.480
And that's really bad, because
if x, z, and y are orthogonal,

00:46:53.480 --> 00:46:56.640
then normalization is alpha
squared plus beta squared is 1.

00:46:56.640 --> 00:46:58.400
But x x, the
normalization is alpha

00:46:58.400 --> 00:47:00.170
plus beta quantity squared is 1.

00:47:00.170 --> 00:47:02.340
And in general that's not true.

00:47:02.340 --> 00:47:03.860
In fact, this could be 0.

00:47:03.860 --> 00:47:06.815
So this violates linearity
and a unitarity rather badly.

00:47:06.815 --> 00:47:07.777
So you can't clone.

00:47:07.777 --> 00:47:08.860
This is really disturbing.

00:47:08.860 --> 00:47:10.420
That means if you
have a quantum,

00:47:10.420 --> 00:47:13.140
and you want make a
copy of it, you can't.

00:47:13.140 --> 00:47:15.700
You can't ever make a copy
of your quantum system.

00:47:15.700 --> 00:47:16.700
One copy.

00:47:16.700 --> 00:47:18.000
One chance.

00:47:18.000 --> 00:47:20.650
That's it.

00:47:20.650 --> 00:47:22.370
No cut and paste.

00:47:22.370 --> 00:47:24.470
So, as you can imagine
that pretty powerfully

00:47:24.470 --> 00:47:26.300
constrains things
that you can do.

00:47:26.300 --> 00:47:28.690
So, a related thing here is
that there's no forgetting.

00:47:32.980 --> 00:47:38.959
Quantum evolution is, unlike an
elephant, it is highly-- well,

00:47:38.959 --> 00:47:40.250
it's like an elephant, I guess.

00:47:40.250 --> 00:47:41.330
It remembers very well.

00:47:41.330 --> 00:47:43.524
It never forgets anything.

00:47:43.524 --> 00:47:44.815
And you can see that from this.

00:47:44.815 --> 00:47:46.300
This would be an
example of forgetting.

00:47:46.300 --> 00:47:47.860
You forgot what
was in the state y.

00:47:47.860 --> 00:47:49.101
You can't ever do that.

00:47:49.101 --> 00:47:49.600
OK.

00:47:49.600 --> 00:47:54.710
So I leave this as a challenge
you to prove this show.

00:47:54.710 --> 00:47:58.510
It's a simple extension
of the same logic.

00:47:58.510 --> 00:47:59.580
So what can you do?

00:48:02.856 --> 00:48:05.501
What you can do, is you
can entangle two qubits.

00:48:05.501 --> 00:48:07.250
And that's really the
juice of everything.

00:48:07.250 --> 00:48:12.280
You can entangle.

00:48:12.280 --> 00:48:15.550
So let me show you entanglement.

00:48:15.550 --> 00:48:17.180
Good, no e.

00:48:17.180 --> 00:48:18.804
Sorry, question?

00:48:18.804 --> 00:48:20.720
So you can entangle, and
here's how you do it.

00:48:20.720 --> 00:48:22.774
Let's take this state 0, 0.

00:48:22.774 --> 00:48:23.690
So we have two qubits.

00:48:23.690 --> 00:48:25.094
The first one's in the
state 0, and the second one

00:48:25.094 --> 00:48:26.150
is in the state 0.

00:48:26.150 --> 00:48:27.790
And now, I'm going to do the
following set of operations

00:48:27.790 --> 00:48:28.260
to it.

00:48:28.260 --> 00:48:29.760
I'm first going to
impose a Hadamard

00:48:29.760 --> 00:48:33.610
operation on the first qubit,
and nothing on the second.

00:48:33.610 --> 00:48:39.287
And then I'm going to
apply controlled-NOT,

00:48:39.287 --> 00:48:40.870
and we're going to
see what I get out.

00:48:40.870 --> 00:48:42.590
So the initial state is 0, 0.

00:48:47.070 --> 00:48:53.090
After I Hadamard, well, the
first bit is no longer in 0.

00:48:53.090 --> 00:48:56.120
Hadamard on 0 gives me 0 plus 1.

00:48:56.120 --> 00:48:58.830
So this is now the
state 1 upon root 2.

00:48:58.830 --> 00:49:12.230
0 plus 1 times 0, also known as
1 over root 2, 0, 0 plus 1, 0.

00:49:12.230 --> 00:49:14.270
Now is this the separable state?

00:49:14.270 --> 00:49:17.326
Yes, there is separated.

00:49:17.326 --> 00:49:19.200
And now I'm going to
perform a controlled-NOT

00:49:19.200 --> 00:49:20.575
and what the
controlled-NOT does,

00:49:20.575 --> 00:49:23.520
is that it switches the second
bit, if the first bit is a 1.

00:49:23.520 --> 00:49:25.520
So what is the state
after we've done this?

00:49:25.520 --> 00:49:30.120
The state after we've done this
is, well, from the first term,

00:49:30.120 --> 00:49:33.920
1 upon root 2,
from the first term

00:49:33.920 --> 00:49:36.349
0, 0-- what happens to that
when we controlled-NOT?

00:49:36.349 --> 00:49:37.640
Well, we NOT this if this is 1.

00:49:37.640 --> 00:49:38.760
This is not 1, so
we don't NOT it.

00:49:38.760 --> 00:49:39.770
We leave it alone.

00:49:39.770 --> 00:49:44.600
And the second term--
1, 0 plus well, we

00:49:44.600 --> 00:49:47.720
flip this, if this is 1, and
not if it's not, so this is 1.

00:49:47.720 --> 00:49:49.090
We flip it, and we get 1, 1.

00:49:49.090 --> 00:49:53.140
And now this is the
prototypical entangled state--

00:49:53.140 --> 00:49:56.019
that I think I just erased.

00:49:56.019 --> 00:49:57.310
But this is our entitled state.

00:49:57.310 --> 00:49:58.516
It's not separable.

00:49:58.516 --> 00:49:59.890
But if I measure
the first one, I

00:49:59.890 --> 00:50:01.431
know what the state
of the second one

00:50:01.431 --> 00:50:04.400
is, which is to
say it's entangled.

00:50:04.400 --> 00:50:05.820
Cool?

00:50:05.820 --> 00:50:07.999
So by performing this
series of operations, which

00:50:07.999 --> 00:50:10.040
is nothing other than a
series of magnetic fields

00:50:10.040 --> 00:50:12.170
which I'm going to
impose to the system,

00:50:12.170 --> 00:50:14.220
I've taken a state
with initial conditions

00:50:14.220 --> 00:50:18.361
0, 0, and put it into an
entangled state, 0, 0 plus 1,

00:50:18.361 --> 00:50:18.860
1.

00:50:21.560 --> 00:50:27.600
And that's all we need for
the first basic algorithm

00:50:27.600 --> 00:50:28.680
of quantum computation.

00:50:28.680 --> 00:50:30.230
So this idea the
quantum computers

00:50:30.230 --> 00:50:31.940
might be able to
do things faster

00:50:31.940 --> 00:50:35.450
than classical computers
floated around for a while.

00:50:35.450 --> 00:50:38.230
It took a while for
people to make that sharp.

00:50:38.230 --> 00:50:44.710
And David Deutsch, who is a
very entertaining and bombastic

00:50:44.710 --> 00:50:49.840
speaker, and he wrote-- I
guess it's several now-- pretty

00:50:49.840 --> 00:50:52.030
entertaining books on the topic.

00:50:52.030 --> 00:50:53.590
And he sounds crazy.

00:50:53.590 --> 00:50:56.280
You listen to the guy
talk, and he sounds nuts.

00:50:56.280 --> 00:50:59.620
He sounds like he's
just way out there.

00:50:59.620 --> 00:51:02.020
The thing he's just-- gah!

00:51:02.020 --> 00:51:04.840
As a theorist, you listen to
him like, just slow down there,

00:51:04.840 --> 00:51:05.520
buddy.

00:51:05.520 --> 00:51:06.110
Right?

00:51:06.110 --> 00:51:09.054
And so for a long time,
I thought the guy--

00:51:09.054 --> 00:51:10.720
I only knew his sort
of public persona--

00:51:10.720 --> 00:51:12.650
I thought, yeah, he's
a little bit crazy;

00:51:12.650 --> 00:51:14.130
I'm not exactly
sure-- and this is

00:51:14.130 --> 00:51:16.500
why everyone thinks
he's such a damn genius.

00:51:16.500 --> 00:51:17.950
Because this is beautiful.

00:51:17.950 --> 00:51:20.180
So here is-- I don't know
how he came up with this,

00:51:20.180 --> 00:51:21.230
but he's clever.

00:51:21.230 --> 00:51:23.850
So here is what's now
called the Deutsch--

00:51:23.850 --> 00:51:26.280
and it's really
the one bit version

00:51:26.280 --> 00:51:32.350
of the Deutsch-Josza algorithm.

00:51:32.350 --> 00:51:34.150
So there is a first
algorithm by Deutsch

00:51:34.150 --> 00:51:35.860
that didn't quite what
it was supposed to do,

00:51:35.860 --> 00:51:37.500
then it was improved
together with Jozsa,

00:51:37.500 --> 00:51:39.300
and they made an n particle
version and everything was

00:51:39.300 --> 00:51:39.799
awesome.

00:51:39.799 --> 00:51:43.187
But here's the
Deutsch-Jozsa algorithm.

00:51:43.187 --> 00:51:44.770
And what it is, it's
a series of rules

00:51:44.770 --> 00:51:47.340
for how to make a quantum
mechanical system evolve

00:51:47.340 --> 00:51:52.570
so as to effect the calculation
you wanted to calculate.

00:51:52.570 --> 00:51:55.600
So you have to
grant, to begin, you

00:51:55.600 --> 00:51:58.860
have to let me pose
a problem to solve

00:51:58.860 --> 00:52:00.790
that can be solved
in this fashion.

00:52:00.790 --> 00:52:04.290
And this problem is going
to sound a little contrived.

00:52:04.290 --> 00:52:05.795
And, in fact, it's
wildly contrived.

00:52:05.795 --> 00:52:07.170
It was contrived
so that it could

00:52:07.170 --> 00:52:08.253
be solved in this fashion.

00:52:08.253 --> 00:52:13.880
But it's actually one that
preexists the algorithm itself,

00:52:13.880 --> 00:52:16.280
so it's not quite as ridiculous

00:52:16.280 --> 00:52:17.674
So here's the problem.

00:52:17.674 --> 00:52:19.090
So the statement
of the problem is

00:52:19.090 --> 00:52:25.020
that someone has
a function f of x.

00:52:25.020 --> 00:52:32.310
So, let's say Matt
knows a function f of x.

00:52:38.600 --> 00:52:42.070
Now the thing is, it's
extremely expensive

00:52:42.070 --> 00:52:44.120
to evaluate this
function f of x.

00:52:44.120 --> 00:52:47.960
So the way you evaluate
involves putting 20 kilomeres

00:52:47.960 --> 00:52:50.022
in superposition
states with each other.

00:52:50.022 --> 00:52:51.480
You have to run a
whole experiment.

00:52:51.480 --> 00:53:02.150
And it costs a lot of money
to run, so he charges--

00:53:02.150 --> 00:53:04.900
$1 million dollars order to--

00:53:04.900 --> 00:53:06.220
AUDIENCE: [LAUGHTER]

00:53:06.220 --> 00:53:08.220
PROFESSOR: Thank you, you
guys are not quite old

00:53:08.220 --> 00:53:10.870
enough to-- so he knows
the function f of x and he

00:53:10.870 --> 00:53:13.370
charges a million dollars in
order to evaluate the function.

00:53:13.370 --> 00:53:16.010
You say, hey, Matt, look, I
know this is a function-- which

00:53:16.010 --> 00:53:19.860
I should tell you f
is a function that

00:53:19.860 --> 00:53:24.065
takes a single bit, 0 or 1,
to another single bit, 0 or 1.

00:53:24.065 --> 00:53:26.190
So it sounds like, how hard
could this possibly be?

00:53:26.190 --> 00:53:27.810
But in fact, it's a very
hard function to evaluate.

00:53:27.810 --> 00:53:29.210
So you say, hey
Matt, what's f of 0?

00:53:29.210 --> 00:53:30.380
And he's like, give
me a million bucks.

00:53:30.380 --> 00:53:31.250
So you give him a million bucks.

00:53:31.250 --> 00:53:32.042
And he's like, 1.

00:53:32.042 --> 00:53:34.000
And you're like damn,
that cost a lot of money.

00:53:36.640 --> 00:53:38.000
So now here's the question.

00:53:38.000 --> 00:53:39.320
So this is not yet the problem.

00:53:39.320 --> 00:53:41.560
The problem is this.

00:53:41.560 --> 00:53:49.170
Is f of 0 equal
to f of 1 or not?

00:53:49.170 --> 00:53:51.630
OK.

00:53:51.630 --> 00:53:56.500
So f of 0 is either 0 or
1. f of 1 is either 0 or 1.

00:53:56.500 --> 00:53:58.800
Are they equal to each other?

00:53:58.800 --> 00:53:59.830
So this is easy, right?

00:53:59.830 --> 00:54:00.996
Classically, this is stupid.

00:54:00.996 --> 00:54:03.060
You calculate the
function f twice.

00:54:03.060 --> 00:54:04.790
You evaluate f of
0, you get a number.

00:54:04.790 --> 00:54:05.910
You evaluate f of 1,
and you get number.

00:54:05.910 --> 00:54:07.576
You look at your piece
of paper, and you

00:54:07.576 --> 00:54:09.250
say it's either the
same or different.

00:54:09.250 --> 00:54:11.400
How much does that cost you?

00:54:11.400 --> 00:54:12.580
Two million bucks.

00:54:12.580 --> 00:54:13.820
Better have good funding.

00:54:13.820 --> 00:54:15.310
So this is an expensive--

00:54:15.310 --> 00:54:17.250
And here's what Deutsch
and Josza have to say.

00:54:17.250 --> 00:54:20.250
This is really Deutsche
at the beginning.

00:54:20.250 --> 00:54:22.620
It's really quite spectacular.

00:54:22.620 --> 00:54:26.110
Deutsch says actually, I
tell you what, give me a

00:54:26.110 --> 00:54:29.170
million and a half, and I'll
do the computation give you

00:54:29.170 --> 00:54:30.430
the answer.

00:54:30.430 --> 00:54:32.430
At which point you think,
like I did previously,

00:54:32.430 --> 00:54:33.740
the guy's clearly raving.

00:54:33.740 --> 00:54:36.782
But, in fact, he's
going to make a profit,

00:54:36.782 --> 00:54:38.240
And here's how he's
going to do it.

00:54:38.240 --> 00:54:40.400
He's going to build, not
a classical computer,

00:54:40.400 --> 00:54:43.430
but a quantum computer
using quantum interference

00:54:43.430 --> 00:54:46.970
and entanglement to
do this calculation.

00:54:46.970 --> 00:54:48.524
One evaluation.

00:54:48.524 --> 00:54:49.940
And here's how
it's going to work.

00:54:49.940 --> 00:54:56.130
And the first thing we have
to do is a preview, or set up,

00:54:56.130 --> 00:54:59.720
in order to do this calculation,
you need two things.

00:54:59.720 --> 00:55:05.180
First off, you need Matt to be
able to evaluate his function

00:55:05.180 --> 00:55:08.194
in a way that respects
quantum mechanics.

00:55:08.194 --> 00:55:09.610
So, in particular,
Matt had better

00:55:09.610 --> 00:55:13.000
be able to do his experiment,
if I give him an superpositon.

00:55:13.000 --> 00:55:15.080
So we better be able to
effect the calculation

00:55:15.080 --> 00:55:16.460
in a quantum mechanical way.

00:55:16.460 --> 00:55:18.120
The same way that we
implemented a NOT quantum

00:55:18.120 --> 00:55:19.850
mechanically, or the
controlled-NOT quantum

00:55:19.850 --> 00:55:21.290
mechanically, or the
Hadamard, with some set

00:55:21.290 --> 00:55:22.112
of magnetic fields.

00:55:22.112 --> 00:55:24.320
He must be able to implement
it quantum mechanically.

00:55:24.320 --> 00:55:26.153
Otherwise, it's not an
interesting function.

00:55:26.153 --> 00:55:28.654
And let me just point out that
any function you can think of

00:55:28.654 --> 00:55:30.319
can be implemented
quantum mechanically,

00:55:30.319 --> 00:55:31.750
because you are
quantum mechanics.

00:55:31.750 --> 00:55:32.130
OK?

00:55:32.130 --> 00:55:33.921
You're just not an
elegant implementation--

00:55:33.921 --> 00:55:40.210
and no offense-- of the
quantum mechanical computation.

00:55:40.210 --> 00:55:45.220
So the set up is that Matt
needs to be able to give me--

00:55:45.220 --> 00:55:49.565
Matt provides-- a
unitary transformation,

00:55:49.565 --> 00:55:54.620
a unitary operation, use of
f that takes two qubits, x

00:55:54.620 --> 00:56:03.550
and y to x and f of x plus y.

00:56:03.550 --> 00:56:09.070
Where what this means, f of x
plus y, is addition mod two.

00:56:11.850 --> 00:56:14.920
So what this says is,
if y is 0, then this

00:56:14.920 --> 00:56:16.760
gives me f of x plus 0.

00:56:16.760 --> 00:56:19.640
If f of x is 0, that's 0
plus 0, so that gives me 0.

00:56:19.640 --> 00:56:22.890
If f of x is 1, is this
gives me 1 plus 0, that's 1.

00:56:22.890 --> 00:56:28.450
On the other hand, if y is 1,
then this gives me-- if f of x

00:56:28.450 --> 00:56:30.260
is 0, it gives me 1
plus 1, which is 0.

00:56:30.260 --> 00:56:34.600
And if f of x is 0, it's going
to be 0 plus 1, which is 1.

00:56:34.600 --> 00:56:37.250
Everyone cool with that?

00:56:37.250 --> 00:56:38.238
Yeah.

00:56:38.238 --> 00:56:39.226
AUDIENCE: [INAUDIBLE].

00:56:39.226 --> 00:56:42.559
--question, but like actually,
how do you know that the matrix

00:56:42.559 --> 00:56:46.520
actually [INAUDIBLE] I mean,
how can we know [INAUDIBLE]

00:56:46.520 --> 00:56:51.420
if matrices actually prove that
quantum mechanics [INAUDIBLE]

00:56:51.420 --> 00:56:54.322
What if the matrix is is
just an approximation--

00:56:54.322 --> 00:56:56.530
PROFESSOR: You mean what if
quantum mechanics is only

00:56:56.530 --> 00:56:57.415
an approximate description--?

00:56:57.415 --> 00:56:57.790
Of the--

00:56:57.790 --> 00:56:59.248
AUDIENCE: No I'm
sorry. [INAUDIBLE]

00:56:59.248 --> 00:57:03.617
To what if quantum mechanics--
the inelegant reprensentation

00:57:03.617 --> 00:57:05.700
of [INAUDIBLE] implementation
of quantum mechanics

00:57:05.700 --> 00:57:06.540
PROFESSOR: Is inescapable--?

00:57:06.540 --> 00:57:09.123
AUDIENCE: [INAUDIBLE] is just
an approximation of the problem,

00:57:09.123 --> 00:57:12.430
or is a really, really
good approximation--

00:57:12.430 --> 00:57:14.310
PROFESSOR: This is an
interesting question.

00:57:14.310 --> 00:57:15.430
So it's tempting
to think that this

00:57:15.430 --> 00:57:17.420
is a philosophical
question, but it turns out

00:57:17.420 --> 00:57:20.003
not to be in a way that will be
made sharp in about 10 minutes

00:57:20.003 --> 00:57:21.040
with Bell's Inequality.

00:57:21.040 --> 00:57:25.050
But a complete answer
to that question

00:57:25.050 --> 00:57:27.246
remains open, and,
probably, always will.

00:57:27.246 --> 00:57:29.496
But let me rephrase the
question slightly, and tell me

00:57:29.496 --> 00:57:32.860
if this an accurate statement.

00:57:32.860 --> 00:57:36.340
Look, at the end of the
day, what we're doing

00:57:36.340 --> 00:57:38.330
is we're going to
develop a model where

00:57:38.330 --> 00:57:41.969
quantum mechanical calculation
does something in particular.

00:57:41.969 --> 00:57:44.260
And that may or may not be
a good model the real world.

00:57:44.260 --> 00:57:46.267
And in particular,
whatever the actual thing,

00:57:46.267 --> 00:57:48.100
the actual system, that
we're studying does,

00:57:48.100 --> 00:57:51.391
may or may not be
well described by

00:57:51.391 --> 00:57:53.345
that quantum mechanical model.

00:57:53.345 --> 00:57:56.230
So can we check
whether or not it is?

00:57:56.230 --> 00:57:59.860
Is that more or
less the question?

00:57:59.860 --> 00:58:04.740
Yeah, and so the problem
is all we can ever do

00:58:04.740 --> 00:58:07.430
is say that our model
is a good or bad model.

00:58:07.430 --> 00:58:09.564
On the other hand, we
can do the following.

00:58:09.564 --> 00:58:10.980
And this is the
really neat thing.

00:58:10.980 --> 00:58:12.850
You might say, look,
underlying quantum mechanics

00:58:12.850 --> 00:58:14.420
is going to be something
more fundamental

00:58:14.420 --> 00:58:16.440
that's going to lead to
slightly different results

00:58:16.440 --> 00:58:17.590
in exactly the
sort of situations

00:58:17.590 --> 00:58:19.215
where we're going to
care about quantum

00:58:19.215 --> 00:58:22.210
computation of large
numbers and bits.

00:58:22.210 --> 00:58:26.750
And if you tell me just a little
tiny bit about what properties

00:58:26.750 --> 00:58:29.660
that underlying
description will have,

00:58:29.660 --> 00:58:31.370
that becomes an
empirical question.

00:58:31.370 --> 00:58:32.470
So, for example,
if you say, look,

00:58:32.470 --> 00:58:34.469
I suspect that underlying
the quantum mechanical

00:58:34.469 --> 00:58:37.270
probabilities is some classical
probability distribution

00:58:37.270 --> 00:58:39.735
over a hidden variable that
you have not actually measured.

00:58:39.735 --> 00:58:41.090
And what we're
going to find out is

00:58:41.090 --> 00:58:42.798
that we can rule that
out experimentally.

00:58:42.798 --> 00:58:44.360
Just that extra
little assumption

00:58:44.360 --> 00:58:46.227
that there's an underlying
hidden variable--

00:58:46.227 --> 00:58:48.310
a secret probability
distribution on some variable

00:58:48.310 --> 00:58:49.950
we just haven't
observed yet-- that

00:58:49.950 --> 00:58:53.540
is enough information about the
system to rule out that model,

00:58:53.540 --> 00:58:54.280
amazingly.

00:58:54.280 --> 00:58:58.200
So I think we'll never have
a full answer your question.

00:58:58.200 --> 00:59:03.170
But all we can do is work and
see how well our models fits.

00:59:03.170 --> 00:59:04.670
And so far, nothing's
ever disagreed

00:59:04.670 --> 00:59:07.100
with the quantum
mechanical description.

00:59:07.100 --> 00:59:10.612
Let me hold off on
questions just now.

00:59:10.612 --> 00:59:12.350
But it's a good and
interesting question

00:59:12.350 --> 00:59:15.160
that's a hard one
deal with, by which I

00:59:15.160 --> 00:59:16.370
mean it's an open question.

00:59:16.370 --> 00:59:19.042
So Matt provides
for us an operator

00:59:19.042 --> 00:59:20.500
that allows us to
calculate f of x.

00:59:20.500 --> 00:59:22.440
Now you might have
said, well look,

00:59:22.440 --> 00:59:25.390
why not just take x, and why not
have Matt build a machine that

00:59:25.390 --> 00:59:26.970
takes x and gives you f of x.

00:59:31.260 --> 00:59:32.545
Could you have done that?

00:59:32.545 --> 00:59:34.000
AUDIENCE: [INAUDIBLE]

00:59:34.000 --> 00:59:36.872
PROFESSOR: Well, it's
not exactly no cloning.

00:59:36.872 --> 00:59:39.330
But let me leave this to you
as a fun thing to think about.

00:59:39.330 --> 00:59:41.970
Why do we need this
carrier bit, as well?

00:59:45.630 --> 00:59:48.010
OK.

00:59:48.010 --> 00:59:49.110
So there's our set up.

00:59:49.110 --> 00:59:51.310
Matt provides this
function for us, U.

00:59:51.310 --> 00:59:53.620
And here's the algorithm.

00:59:53.620 --> 00:59:55.510
So the algorithm.

00:59:55.510 --> 00:59:58.850
And it's a series of steps,
one by one we do them.

00:59:58.850 --> 01:00:01.180
We perform these operations
are on our qubit.

01:00:03.744 --> 01:00:04.910
So here's what Deutsch says.

01:00:04.910 --> 01:00:11.970
Deutsch says start input, a
state psi, is equal to 0, 1.

01:00:11.970 --> 01:00:13.870
First qubit is 0,
in the state 0.

01:00:13.870 --> 01:00:15.850
The second qubit is in
the state 1, for sure.

01:00:15.850 --> 01:00:17.440
We implement that
with our boxes,

01:00:17.440 --> 01:00:19.106
or however we want
to implement it.

01:00:19.106 --> 01:00:21.230
So we find ourselves in a
definite state, you know,

01:00:21.230 --> 01:00:22.320
hard-soft.

01:00:22.320 --> 01:00:24.470
So we take a hard box,
and we take a soft box,

01:00:24.470 --> 01:00:26.386
and we pull out the hard
one and the soft one.

01:00:30.150 --> 01:00:34.360
One, Hadamard each.

01:00:34.360 --> 01:00:35.747
Hadamard on both bits.

01:00:35.747 --> 01:00:38.480
Both qubits.

01:00:38.480 --> 01:00:38.980
OK.

01:00:38.980 --> 01:00:40.188
So what does this take us to?

01:00:40.188 --> 01:00:42.950
It takes us to psi
is equal to-- well,

01:00:42.950 --> 01:00:49.275
the 0 goes to 1 over
root 2, times 0 plus 1.

01:00:49.275 --> 01:00:50.150
Did I erase Hadamard?

01:00:50.150 --> 01:00:51.620
No, good.

01:00:51.620 --> 01:00:53.710
There's Hadamard.

01:00:53.710 --> 01:00:55.300
So it does this-- does this.

01:00:55.300 --> 01:00:57.860
So it takes the first
one to 0 plus 1,

01:00:57.860 --> 01:01:03.320
and it takes the second one
to 1 over root 2, 0 minus 1.

01:01:07.660 --> 01:01:08.534
Cool?

01:01:08.534 --> 01:01:10.450
So at this point, this
isn't very interesting.

01:01:10.450 --> 01:01:12.616
What we've done is we take
it from one superposition

01:01:12.616 --> 01:01:14.210
to a different superposition.

01:01:14.210 --> 01:01:16.168
And doesn't seem to have
anything to do with f.

01:01:16.168 --> 01:01:17.830
In fact, we haven't measured f.

01:01:17.830 --> 01:01:18.860
Two.

01:01:18.860 --> 01:01:20.810
Apply f.

01:01:20.810 --> 01:01:24.260
So we apply our
operation U sub f.

01:01:24.260 --> 01:01:29.810
And well, this is a sort
of an entertaining one.

01:01:29.810 --> 01:01:31.580
If we take this 1
of root 2-- so I'm

01:01:31.580 --> 01:01:33.840
going to rewrite this in
a slightly simpler form--

01:01:33.840 --> 01:01:43.340
this is 1/2, 0, times--
0 times 0 minus 1.

01:01:43.340 --> 01:01:44.450
That's 1.

01:01:44.450 --> 01:01:49.100
Plus 1 times 0 minus 1.

01:01:53.310 --> 01:01:55.720
And the reason I'm doing that
is we're going to apply Uf.

01:01:55.720 --> 01:02:00.100
And Uf, our function
f, uses that first bit

01:02:00.100 --> 01:02:03.800
as a control bit for the second.

01:02:03.800 --> 01:02:06.140
So here's the control
bit for the second.

01:02:06.140 --> 01:02:10.820
So we apply Uf, and
this gives us 1/2.

01:02:13.310 --> 01:02:15.310
I'm going to actually do
this on the next board,

01:02:15.310 --> 01:02:16.910
because it's going
to be gigantic.

01:02:28.030 --> 01:02:31.944
So this gives us 1/2.

01:02:31.944 --> 01:02:35.500
0-- so that first one, this is
going to take this and give it

01:02:35.500 --> 01:02:38.825
0 plus f of 0,
and 1 plus f of 0.

01:02:38.825 --> 01:02:45.896
So times f of 0, plus 0.

01:02:45.896 --> 01:02:52.010
Minus f of 0 plus 1.

01:02:52.010 --> 01:03:02.905
Plus for the 1, this going to
be times f of 1, now, plus 0.

01:03:02.905 --> 01:03:10.130
Minus f of 1, plus 1.

01:03:10.130 --> 01:03:12.540
OK?

01:03:12.540 --> 01:03:16.040
Now, here's a crucial step.

01:03:16.040 --> 01:03:18.430
This is equal to, and
note the following,

01:03:18.430 --> 01:03:21.870
look at this particular guy.

01:03:21.870 --> 01:03:24.950
So for that particular
guy, suppose f of 0 is 0.

01:03:24.950 --> 01:03:28.940
If f of 0, is 0, then this
is 0 plus 0, which is 0.

01:03:28.940 --> 01:03:32.860
So f of 0 is equal to 0.

01:03:32.860 --> 01:03:37.160
And this gives me 0, and this
gives me 0 plus 1, which is 1.

01:03:37.160 --> 01:03:38.610
0 minus 1.

01:03:38.610 --> 01:03:43.980
On the other hand, if
f of 0 is equal to 1,

01:03:43.980 --> 01:03:47.920
then we get 1 plus
0, which is 1.

01:03:47.920 --> 01:03:52.930
And here we get 1 plus
1, which is 0 minus 0,

01:03:52.930 --> 01:03:56.230
which is equal to
minus 0 minus 1.

01:03:59.591 --> 01:04:00.090
Yeah?

01:04:00.090 --> 01:04:01.620
OK.

01:04:01.620 --> 01:04:10.750
So I can write this as minus 1
to the f of 0 times 0 minus 1.

01:04:14.200 --> 01:04:15.200
Everyone cool with that?

01:04:15.200 --> 01:04:18.300
This is just a little
exercise in binary arithmetic.

01:04:18.300 --> 01:04:21.950
So we can write this first term.

01:04:21.950 --> 01:04:36.149
This is 1/2 minus 1 to the
f of 0, 0, times 0 minus 1.

01:04:36.149 --> 01:04:38.440
So that's for the first one,
and exactly the same logic

01:04:38.440 --> 01:04:39.773
is going to apply to the second.

01:04:39.773 --> 01:04:42.580
But now f of 1,
instead of f of 0.

01:04:42.580 --> 01:04:54.370
Plus minus 1 to the f of 1,
times 1, times 0, minus 1.

01:04:58.620 --> 01:05:00.420
Now, I want to point
something out to you.

01:05:00.420 --> 01:05:03.840
If f of 0 is equal to f of
1, than what's true of f of 0

01:05:03.840 --> 01:05:04.840
plus f of 1?

01:05:09.364 --> 01:05:10.780
Well, if they're
the same exactly,

01:05:10.780 --> 01:05:13.050
then either it's 0 plus
0, in which case we get 0,

01:05:13.050 --> 01:05:16.630
or it's 1 plus 1, in
which case we get 0.

01:05:16.630 --> 01:05:23.241
So this is 0, if it's the
same, and 1, if it's not.

01:05:23.241 --> 01:05:23.740
OK.

01:05:23.740 --> 01:05:26.440
So we could either know them
both, or we can measure f of 0

01:05:26.440 --> 01:05:28.790
plus f of 1.

01:05:28.790 --> 01:05:30.830
So notice what happens here.

01:05:30.830 --> 01:05:34.180
This is equal to
1/2, and now I'm

01:05:34.180 --> 01:05:37.120
just going to pull out
a factor of f of 0,

01:05:37.120 --> 01:05:42.990
minus 1 to the f of 0, times--
well, both of these terms

01:05:42.990 --> 01:05:45.320
have a 0 minus 1
on the second bit,

01:05:45.320 --> 01:05:47.910
so the second qubit is
in the state 0 minus 1.

01:05:47.910 --> 01:05:49.940
Right, everyone cool with that?

01:05:49.940 --> 01:05:56.680
So this is equal to, for
the first qubit, 0 plus 1,

01:05:56.680 --> 01:06:01.860
times minus 1 to the f of 0,
that I pulled out to square it,

01:06:01.860 --> 01:06:09.800
plus f of 1, times 0 minus 1.

01:06:13.110 --> 01:06:15.370
And here's the quantity
we wanted to measure.

01:06:15.370 --> 01:06:17.970
If this is 0, then they're even.

01:06:17.970 --> 01:06:19.980
Then they're the same.

01:06:19.980 --> 01:06:23.570
If it's 1, then
they're not the same.

01:06:23.570 --> 01:06:29.120
So at this point we
just forget three,

01:06:29.120 --> 01:06:32.370
forget about the second qubit.

01:06:37.180 --> 01:06:39.240
Oh, lord.

01:06:39.240 --> 01:06:41.894
Forget about the
second qubit, and so

01:06:41.894 --> 01:06:43.310
forget about the
second qubit just

01:06:43.310 --> 01:06:46.780
does this, just
focus on this guy.

01:06:46.780 --> 01:06:51.520
And now, if f of 0 plus f of 1
is 0, so that they're the same,

01:06:51.520 --> 01:06:55.100
this is 0, minus 1 to the
0, 0, so we get 0 plus 1.

01:06:55.100 --> 01:07:00.340
So same, then our
state is 0 plus 1.

01:07:03.600 --> 01:07:06.220
And if they're
different, then we

01:07:06.220 --> 01:07:14.411
get the state 0 minus 1
Everyone agree with that?

01:07:14.411 --> 01:07:16.660
But if they're the same we
get 0 plus 1, and different

01:07:16.660 --> 01:07:17.330
we get 0 minus 1.

01:07:17.330 --> 01:07:18.996
Still doesn't work
for us, because if we

01:07:18.996 --> 01:07:21.630
measure, what's the
probability we get 0 here?

01:07:21.630 --> 01:07:22.250
1/2.

01:07:22.250 --> 01:07:23.540
And the probability
that we get 1 is 1/2.

01:07:23.540 --> 01:07:24.706
Similar, if we measure here.

01:07:24.706 --> 01:07:25.292
It was 0, 1/2.

01:07:25.292 --> 01:07:26.170
1, 1/2

01:07:26.170 --> 01:07:29.257
On the other hand these
states are familiar to us

01:07:29.257 --> 01:07:31.090
because they're what
you get by Hadamarding.

01:07:33.787 --> 01:07:36.120
So why don't we take these,
from these states to these--

01:07:36.120 --> 01:07:37.953
by doing the inverse
of the Hadamard, which,

01:07:37.953 --> 01:07:40.150
as it turns out,
is Hadamard itself.

01:07:40.150 --> 01:07:41.180
So four.

01:07:44.930 --> 01:07:45.920
Hadamard the first bit.

01:07:50.950 --> 01:07:57.310
And the output is
the state, psi out,

01:07:57.310 --> 01:08:03.770
is equal to 1/2, 1 plus,
minus 1 to the f of 0

01:08:03.770 --> 01:08:14.690
plus f 1, 0 plus
1/2, 1 minus, minus 1

01:08:14.690 --> 01:08:21.479
to the f of 0 plus f 1, 1.

01:08:21.479 --> 01:08:25.970
And now, if f of 0 and f of
1 are the same, this is a 0.

01:08:25.970 --> 01:08:27.899
We get 1 plus 1.

01:08:27.899 --> 01:08:30.600
We get just 0, and this is 0,
because this is 1, this is 1.

01:08:30.600 --> 01:08:31.600
They subtract we get 0.

01:08:31.600 --> 01:08:34.529
They're same you get this
state 0, properly normalized.

01:08:34.529 --> 01:08:36.847
If they're not the same,
you get this state 1,

01:08:36.847 --> 01:08:37.680
properly normalized.

01:08:37.680 --> 01:08:40.500
Now if we measure 0, we
know they're the same,

01:08:40.500 --> 01:08:42.920
and if we measure 1, we
know they're different.

01:08:42.920 --> 01:08:46.810
And so with absolute
certainty, now five.

01:08:46.810 --> 01:08:49.270
Measure the first qubit.

01:08:53.689 --> 01:09:00.729
And we get 0 implies the
same, and 1 implies different.

01:09:00.729 --> 01:09:03.740
And we did all of this
with a single evaluation

01:09:03.740 --> 01:09:06.521
of our function f, right here.

01:09:06.521 --> 01:09:08.479
This is where we apply
our function evaluation.

01:09:08.479 --> 01:09:10.210
We apply the function
evaluation once,

01:09:10.210 --> 01:09:12.210
and we deterministically
get the result,

01:09:12.210 --> 01:09:14.310
whether they're the
same or different.

01:09:14.310 --> 01:09:18.080
So with one call to
Matt, to my Oracle,

01:09:18.080 --> 01:09:21.970
with one call to Matt, which
cost me one million dollars,

01:09:21.970 --> 01:09:25.120
we get the answer to whether
it's the same or different.

01:09:25.120 --> 01:09:27.890
And that's a factor of
2 faster than the best

01:09:27.890 --> 01:09:28.773
classical algorithm.

01:09:31.890 --> 01:09:33.270
But that's not so satisfying.

01:09:33.270 --> 01:09:35.819
This was supposed to be
exponentially better.

01:09:35.819 --> 01:09:41.180
And so that's where Jozsa comes
in, and together with Deutsche,

01:09:41.180 --> 01:09:43.180
Deutsche and Jozsa the
show the following.

01:09:43.180 --> 01:09:47.370
That there's an exactly
analogous problem for n qubits.

01:09:47.370 --> 01:09:48.010
Wow.

01:09:48.010 --> 01:09:51.778
There's exactly analogous
from for n qubits,

01:09:51.778 --> 01:09:53.319
the Deutsche-Jozsa problem.

01:09:56.680 --> 01:10:00.000
And now, how many different
strings of integers

01:10:00.000 --> 01:10:01.660
could you put in?

01:10:01.660 --> 01:10:04.490
There are now 2 to
the n possible states.

01:10:04.490 --> 01:10:07.240
And if you want to know whether
f is the same for all of them,

01:10:07.240 --> 01:10:09.320
the worst case scenario
is you evaluate

01:10:09.320 --> 01:10:12.250
f on the first possible
combination, 0, 0, 0, 0,

01:10:12.250 --> 01:10:13.870
and you get some number.

01:10:13.870 --> 01:10:17.590
You measure f on 0, 0, 0, 0,
1, and get the same number,

01:10:17.590 --> 01:10:18.970
and just keep
doing that forever.

01:10:18.970 --> 01:10:21.011
And you still don't know
if they're all the same,

01:10:21.011 --> 01:10:24.370
until you get to
the very last one.

01:10:24.370 --> 01:10:29.020
So, order 2 to the n is
the worst case scenario.

01:10:29.020 --> 01:10:32.070
But technical scales are
of a order 2 to the n.

01:10:32.070 --> 01:10:36.340
So classically, it
takes an enormous number

01:10:36.340 --> 01:10:38.150
of observations.

01:10:38.150 --> 01:10:40.610
But in the quantum
Deutsche-Jozsa algorithm--

01:10:40.610 --> 01:10:47.780
and now in the n qubit
Deutsch-Jozsa problem-- one

01:10:47.780 --> 01:10:54.360
quantum operation, and you
get a deterministic result.

01:10:54.360 --> 01:10:58.020
And all of this, you evaluate
it once, and you know.

01:10:58.020 --> 01:10:59.120
You've solved the problem.

01:10:59.120 --> 01:11:00.900
So instead of 2 to
the n operations,

01:11:00.900 --> 01:11:03.780
it takes a single one.

01:11:03.780 --> 01:11:06.040
And now, for a large number
n of bits, for example,

01:11:06.040 --> 01:11:09.530
for large integers-- dealing
with very large numbers--

01:11:09.530 --> 01:11:12.410
this is dramatically,
exponentially more efficient

01:11:12.410 --> 01:11:15.570
than the classical algorithm.

01:11:15.570 --> 01:11:18.577
So at this point, people start
really seriously thinking

01:11:18.577 --> 01:11:20.160
about quantum
computation, whether you

01:11:20.160 --> 01:11:21.280
could get it to work.

01:11:21.280 --> 01:11:24.190
And how much we
juice you can get out

01:11:24.190 --> 01:11:26.340
of actually building
such a quantum computer.

01:11:26.340 --> 01:11:28.090
And this has developed
into a whole theory

01:11:28.090 --> 01:11:31.750
in the whole field of the
theory of computation.

01:11:31.750 --> 01:11:34.900
The thing I want to emphasize
is that the crucial move

01:11:34.900 --> 01:11:36.660
is observing that,
in quantum mechanics,

01:11:36.660 --> 01:11:39.032
you can entangle
degrees of freedom.

01:11:39.032 --> 01:11:41.490
The crucial move is observing
that you can entangle degrees

01:11:41.490 --> 01:11:42.700
of freedom, quantum
mechanically.

01:11:42.700 --> 01:11:44.830
And that's what gave us
all of the nice effects.

01:11:44.830 --> 01:11:46.288
We have these
interference effects.

01:11:46.288 --> 01:11:47.790
And these interference
effects lead

01:11:47.790 --> 01:11:50.900
to the deterministic
outcome being correlated

01:11:50.900 --> 01:11:53.020
with the result of
the computation.

01:11:53.020 --> 01:11:55.260
The interference is crucial.

01:11:55.260 --> 01:11:58.730
And this brings us
to the last point,

01:11:58.730 --> 01:12:03.080
which is exactly what's so
troubling about entanglement.

01:12:03.080 --> 01:12:05.600
And so here is
where EPR come in.

01:12:05.600 --> 01:12:08.384
And Einstein, Podolsky, and
Rosen say the following.

01:12:08.384 --> 01:12:10.550
They say, look, there are
two things that are deeply

01:12:10.550 --> 01:12:14.060
upsetting about this
entanglement story.

01:12:14.060 --> 01:12:16.229
Let me just give you a
precise experiment, they say.

01:12:16.229 --> 01:12:18.270
They say, let me give you
precise experiment that

01:12:18.270 --> 01:12:19.940
embodies all the
weirdness of this.

01:12:19.940 --> 01:12:21.830
Suppose I take two
of these qubits.

01:12:21.830 --> 01:12:25.400
And I put the qubits
in an entangled state,

01:12:25.400 --> 01:12:28.150
up, up, plus down, down.

01:12:28.150 --> 01:12:28.670
OK.

01:12:28.670 --> 01:12:30.420
Let's normalize this
with a 1 upon root 2.

01:12:30.420 --> 01:12:32.290
So there's our state.

01:12:32.290 --> 01:12:35.330
And then we take the first
qubit, so there's our two bits,

01:12:35.330 --> 01:12:38.900
we take the first qubit, we
send it somewhere faraway.

01:12:38.900 --> 01:12:41.451
And someone named
Alice is sitting here

01:12:41.451 --> 01:12:42.700
and is holding on to that bit.

01:12:42.700 --> 01:12:44.890
And we take the
second bit far away.

01:12:44.890 --> 01:12:47.690
And someone named Bob,
conventionally, is sitting here

01:12:47.690 --> 01:12:49.180
and holds a second bit.

01:12:49.180 --> 01:12:52.260
Now given this initial
of configuration,

01:12:52.260 --> 01:12:54.060
what is the
probability that Alice

01:12:54.060 --> 01:12:56.470
will measure the spin to be up?

01:12:56.470 --> 01:12:57.570
Her spin to be up.

01:12:57.570 --> 01:12:58.260
1/2, right?

01:12:58.260 --> 01:12:59.060
And 1/2 down.

01:12:59.060 --> 01:13:00.860
Similarly, Bob 1/2 up and down.

01:13:00.860 --> 01:13:05.260
Once Alice has measured
the state to be up,

01:13:05.260 --> 01:13:08.130
immediately she knows
something about Bob's spin.

01:13:08.130 --> 01:13:11.212
Bob's state will be up,
because I chose this one.

01:13:11.212 --> 01:13:13.545
I could have chosen the other,
which is the more popular

01:13:13.545 --> 01:13:15.180
[INAUDIBLE].

01:13:15.180 --> 01:13:17.557
So Bob's will also be up.

01:13:17.557 --> 01:13:19.890
Now if you look at this list--
you do this over and over

01:13:19.890 --> 01:13:22.130
and over again-- their list
just some random list of ups

01:13:22.130 --> 01:13:24.040
and downs, ups and downs,
but they're exactly

01:13:24.040 --> 01:13:25.420
correlated amongst each other.

01:13:25.420 --> 01:13:29.074
So at this point, EPR
were really upset.

01:13:29.074 --> 01:13:31.240
Because they say, look,
there are two possibilities.

01:13:31.240 --> 01:13:33.740
Either there was an answer to
the question all the way along

01:13:33.740 --> 01:13:36.450
of whether Alice's was
up and Bob's was up,

01:13:36.450 --> 01:13:38.910
or Alice's was down
and Bob's was down.

01:13:38.910 --> 01:13:43.700
Or there's some deep
non-locality in the universe,

01:13:43.700 --> 01:13:47.700
such that a distant measurement,
causally disconnected,

01:13:47.700 --> 01:13:51.620
can have an influence
on Bob's state,

01:13:51.620 --> 01:13:53.320
such that they're correlated.

01:13:53.320 --> 01:13:55.662
This may seem random, but
it's certainly not random,

01:13:55.662 --> 01:13:57.120
because it's
correlated with Alice,

01:13:57.120 --> 01:13:58.990
even though Alice is
wildly disconnected,

01:13:58.990 --> 01:14:01.600
a distant observer.

01:14:01.600 --> 01:14:04.940
Nothing could have traveled
across that distance

01:14:04.940 --> 01:14:08.464
in the time it took
to do the measurement.

01:14:08.464 --> 01:14:09.880
So they're sort
of three responses

01:14:09.880 --> 01:14:10.838
you could take to this.

01:14:10.838 --> 01:14:13.327
The first response is, look,
there isn't a problem here.

01:14:13.327 --> 01:14:15.660
It's just saying that quantum
mechanics is insufficient.

01:14:15.660 --> 01:14:17.661
There's secretly
a hidden variable,

01:14:17.661 --> 01:14:19.160
a variable you
haven't observed yet,

01:14:19.160 --> 01:14:21.620
a property of an electron
that determines whether it's

01:14:21.620 --> 01:14:23.020
going to be up or down early on.

01:14:23.020 --> 01:14:24.820
And the fact that it
looks probabilistic just

01:14:24.820 --> 01:14:26.570
means that there's
some classical dynamics

01:14:26.570 --> 01:14:29.510
for this hidden variable that
effectively is probabilistic,

01:14:29.510 --> 01:14:30.980
like a particle
moving in a fluid.

01:14:30.980 --> 01:14:32.880
Like dust pollen
grains in a fluid,

01:14:32.880 --> 01:14:34.460
it just moves around randomly.

01:14:34.460 --> 01:14:38.110
Bu it just looks random, and
it's not actually random.

01:14:38.110 --> 01:14:40.710
That's because there's an
underlying classical mechanism

01:14:40.710 --> 01:14:43.160
controlling the
probability distribution.

01:14:43.160 --> 01:14:45.580
The second version is a
quantum mechanical version.

01:14:45.580 --> 01:14:48.060
The second interpretation
is to say that, look,

01:14:48.060 --> 01:14:49.744
this may look upsetting.

01:14:49.744 --> 01:14:51.410
And I grant you that
it looks upsetting,

01:14:51.410 --> 01:14:52.730
but I'm a quantum mechanic.

01:14:52.730 --> 01:14:54.490
And quantum mechanics
works like a champ.

01:14:54.490 --> 01:14:56.060
And I'm not about to throw
it out, and say that there's

01:14:56.060 --> 01:14:57.710
some secret, hidden variables.

01:14:57.710 --> 01:14:58.740
It just works.

01:14:58.740 --> 01:15:02.220
So just give up on your naive
notions of locality, let it go,

01:15:02.220 --> 01:15:05.030
and just do the quantum
mechanical calculation.

01:15:05.030 --> 01:15:07.442
Practicing physicists look
at this, and just yawn.

01:15:07.442 --> 01:15:09.650
If you're a practicing
physicist, you just forget it.

01:15:09.650 --> 01:15:12.330
Like, obviously, it works, so
there's no more conversation

01:15:12.330 --> 01:15:13.236
to be had.

01:15:15.790 --> 01:15:17.470
So meanwhile, there's
a second version

01:15:17.470 --> 01:15:19.960
of this, which is
slightly more disturbing.

01:15:19.960 --> 01:15:21.530
Suppose Alice
measures up-- and this

01:15:21.530 --> 01:15:23.153
is all on the z-direction--
but Alice measures up

01:15:23.153 --> 01:15:24.040
in the z-direction.

01:15:24.040 --> 01:15:26.210
She thus knows that
Bob's particle is up

01:15:26.210 --> 01:15:27.200
in the z-direction.

01:15:27.200 --> 01:15:30.740
But simultaneously,
Bob could measure spin

01:15:30.740 --> 01:15:33.230
in the x-direction,
and determine

01:15:33.230 --> 01:15:36.470
that his spin is up in
the x-direction as well.

01:15:36.470 --> 01:15:40.245
At that point, EPR say, look,
we measured, empirically,

01:15:40.245 --> 01:15:42.450
that the particle is both
up in the z-direction

01:15:42.450 --> 01:15:44.010
and up in the x-direction.

01:15:44.010 --> 01:15:46.910
It's just that we did that
measurement using entanglement.

01:15:46.910 --> 01:15:51.850
But at the beginning
of the day, we

01:15:51.850 --> 01:15:55.590
had that Sx and
Sz don't commute.

01:15:55.590 --> 01:15:59.000
So you can't have a state with
definite Sx and definite Sz.

01:15:59.000 --> 01:15:59.870
You cannot possibly.

01:15:59.870 --> 01:16:01.746
It doesn't mean
anything to say so.

01:16:01.746 --> 01:16:04.370
Einstein wants to say that this
is because quantum mechanics is

01:16:04.370 --> 01:16:05.650
great, but incomplete.

01:16:05.650 --> 01:16:07.610
The rest of us want to
say that, no it's not,

01:16:07.610 --> 01:16:13.525
but that sounds like a
philosophical question.

01:16:13.525 --> 01:16:14.900
And that's the
way it was treated

01:16:14.900 --> 01:16:18.517
for a very long time, until
you come along to Bell.

01:16:18.517 --> 01:16:20.100
And Bill made a
beautiful observation.

01:16:20.100 --> 01:16:22.340
Bell said, look,
telling me that there's

01:16:22.340 --> 01:16:27.980
an underlying probabilistic
classical description tells

01:16:27.980 --> 01:16:30.630
me enough to make this
an empirical question.

01:16:30.630 --> 01:16:33.284
Because it's saying
that the statistics,

01:16:33.284 --> 01:16:34.950
the random statistics
for Bob and Alice,

01:16:34.950 --> 01:16:37.900
are correlated by a
classical dynamics

01:16:37.900 --> 01:16:39.639
rather than independent.

01:16:39.639 --> 01:16:40.680
So here's Bell's version.

01:16:40.680 --> 01:16:41.650
So remember at the
very beginning,

01:16:41.650 --> 01:16:43.066
we talked about
Bell's experiment.

01:16:43.066 --> 01:16:47.000
We said, consider three binary
properties, a, b, and c.

01:16:47.000 --> 01:16:50.610
The number of some set
that are a and not b,

01:16:50.610 --> 01:16:54.157
plus the number that
are b but not c,

01:16:54.157 --> 01:16:56.240
is always greater than or
equal to the number that

01:16:56.240 --> 01:16:57.092
are a but not c.

01:16:57.092 --> 01:16:58.550
And the way we
proved this was just

01:16:58.550 --> 01:17:01.008
by noting that, if these are
classical deterministic binary

01:17:01.008 --> 01:17:04.370
properties, then a not
b means a not b and c,

01:17:04.370 --> 01:17:06.220
or a not b and not c.

01:17:06.220 --> 01:17:08.050
And ditto for each
of these other guys.

01:17:08.050 --> 01:17:09.530
And we ended up
with an expression

01:17:09.530 --> 01:17:13.150
which was, number that are
a-- using that logically to,

01:17:13.150 --> 01:17:17.530
number that are a not b
and c plus the number that

01:17:17.530 --> 01:17:22.080
are not a, b, and not c, is
greater than or equal to 0.

01:17:22.080 --> 01:17:23.200
And that's clearly true.

01:17:23.200 --> 01:17:26.451
You can't have a number
of elements be negative.

01:17:26.451 --> 01:17:28.450
So this is trivially true,
quantum mechanically.

01:17:28.450 --> 01:17:30.241
But now here's the
experiment I want to do.

01:17:30.241 --> 01:17:33.010
I want to do actually
the EPR experiment.

01:17:33.010 --> 01:17:34.810
And here's the
experiment I want to run.

01:17:34.810 --> 01:17:38.170
Alice is going to
measure up or down at 0,

01:17:38.170 --> 01:17:41.720
and Bob is going to measure
up or down at theta.

01:17:41.720 --> 01:17:44.440
Alice is then going to
measure up and down at theta,

01:17:44.440 --> 01:17:48.030
and Bob is going to measure
up and down at 2 theta.

01:17:48.030 --> 01:17:49.490
And the third
experiment is going

01:17:49.490 --> 01:17:51.930
to be Alice going to
measure up and down at 0,

01:17:51.930 --> 01:17:54.450
and Bob is going to measure
up and down at 2 theta.

01:17:54.450 --> 01:18:02.800
So a is up or down at--
up at 0, b is up at theta,

01:18:02.800 --> 01:18:07.360
b is up at theta-- and, sorry,
this could be down at theta,

01:18:07.360 --> 01:18:10.350
not b is down a theta. b
is going to be up at theta,

01:18:10.350 --> 01:18:13.740
and c is going to
be down at 2 theta.

01:18:13.740 --> 01:18:16.910
And a, again, up at 0 and
not c is down at 2 theta.

01:18:19.810 --> 01:18:22.980
So we can rephrase this
as the probability that

01:18:22.980 --> 01:18:27.110
given that we are up at 0,
what is the probability that we

01:18:27.110 --> 01:18:29.750
are subsequently down at theta?

01:18:29.750 --> 01:18:34.394
Plus the probability
that we are up at theta,

01:18:34.394 --> 01:18:36.310
what is the probability
that we're up at theta

01:18:36.310 --> 01:18:40.370
and subsequently
down at 2 theta?

01:18:40.370 --> 01:18:44.950
And then the probability
that we are up at 0 and down

01:18:44.950 --> 01:18:47.450
to theta, using an
EPR measurement, where

01:18:47.450 --> 01:18:50.510
one is performed by Alice and
the other is performed by Bob.

01:18:50.510 --> 01:18:52.280
Exactly as EPR wanted.

01:18:52.280 --> 01:18:54.300
And we computed this
last time-- in fact

01:18:54.300 --> 01:18:58.575
I just erased, because
I'm excited about this,

01:18:58.575 --> 01:19:00.950
I guess-- I just erased the
wave function that we needed,

01:19:00.950 --> 01:19:02.150
the state we needed.

01:19:02.150 --> 01:19:06.250
And the state that we needed
was that if we are down

01:19:06.250 --> 01:19:11.560
at the angle theta, then this is
equal to cosine of theta upon 2

01:19:11.560 --> 01:19:19.750
down at 0, plus i sin
theta upon 2, up at 0.

01:19:19.750 --> 01:19:21.790
And this is enough to
answer our question.

01:19:21.790 --> 01:19:23.740
This is the quantum
mechanical prediction.

01:19:23.740 --> 01:19:25.781
What's the probability
that given that we're down

01:19:25.781 --> 01:19:28.890
at the angle theta,
we're up at the angle 0?

01:19:28.890 --> 01:19:31.000
Well, if we're down
at theta, the probably

01:19:31.000 --> 01:19:33.190
that we're up at
0-- the coefficient

01:19:33.190 --> 01:19:35.427
is i sine theta upon
2, and the probability

01:19:35.427 --> 01:19:37.510
is the norm squared of
that expansion coefficient.

01:19:37.510 --> 01:19:41.449
So the probability is sine
squared of theta upon 2.

01:19:41.449 --> 01:19:43.490
Similarly, the probability
that we're up at theta

01:19:43.490 --> 01:19:46.580
and down the 2 theta, well,
by rotation by theta, this

01:19:46.580 --> 01:19:48.320
gives me exactly the same thing.

01:19:48.320 --> 01:19:50.850
So it's, again, going
to be sine squared,

01:19:50.850 --> 01:19:54.904
sine squared theta upon 2.

01:19:54.904 --> 01:19:56.320
The probability
that we're up at 0

01:19:56.320 --> 01:19:59.660
and down at 2 theta, well, just
taking a factor of 2 for theta

01:19:59.660 --> 01:20:01.010
everywhere.

01:20:01.010 --> 01:20:04.910
And that gives me
sine squared of theta.

01:20:08.117 --> 01:20:10.700
Now, I ask you, is left the left
hand side always greater than

01:20:10.700 --> 01:20:12.033
or equal to the right hand side?

01:20:14.620 --> 01:20:15.850
And this is easy to check.

01:20:15.850 --> 01:20:17.435
Let's do this for
a very small theta.

01:20:17.435 --> 01:20:20.210
For a very small theta,
sine squared theta.

01:20:24.310 --> 01:20:28.460
So for small theta,
much less than 1,

01:20:28.460 --> 01:20:33.020
sine theta squared is theta
upon 2 the angle squared,

01:20:33.020 --> 01:20:36.150
which is equal to
theta squared upon 4.

01:20:36.150 --> 01:20:37.670
And the next one
is the same thing,

01:20:37.670 --> 01:20:41.950
plus theta upon 2 squared,
which is equal to theta squared

01:20:41.950 --> 01:20:45.900
upon 4, theta squared upon
4, so theta squared upon two.

01:20:45.900 --> 01:20:48.520
And the right hand side
is sine squared theta,

01:20:48.520 --> 01:20:50.890
which is theta squared.

01:20:50.890 --> 01:20:54.410
And is theta squared upon 2
greater than or equal to theta?

01:20:54.410 --> 01:20:55.654
Certainly not.

01:20:55.654 --> 01:20:57.320
So quantum mechanics
predicts that if we

01:20:57.320 --> 01:21:00.830
do the EPR experiment, using
these observables repeatedly,

01:21:00.830 --> 01:21:02.980
and built up statistics,
what we'll find

01:21:02.980 --> 01:21:06.059
is an explicit violation
of the Bell Inequality.

01:21:06.059 --> 01:21:08.350
And what that would represent
if it were actually true,

01:21:08.350 --> 01:21:09.725
if we actually
observed it, would

01:21:09.725 --> 01:21:12.240
be a conclusive empirical
proof that there

01:21:12.240 --> 01:21:16.700
are no classical definite
configurations underlying

01:21:16.700 --> 01:21:19.750
the probability of
quantum mechanical events.

01:21:19.750 --> 01:21:22.070
It would say that it's
impossible to build

01:21:22.070 --> 01:21:24.910
a classical theory with hidden
variables that are randomly

01:21:24.910 --> 01:21:26.980
distributed such
that you reproduce

01:21:26.980 --> 01:21:28.890
the predictions of
quantum mechanics.

01:21:28.890 --> 01:21:32.070
We see already that it doesn't
agree with quantum mechanics.

01:21:32.070 --> 01:21:34.260
The question is does it
agree with the real world?

01:21:34.260 --> 01:21:37.630
So someone has to build
this experiment and check.

01:21:37.630 --> 01:21:39.380
And this was done
by Alain Aspect.

01:21:45.010 --> 01:21:48.230
And it violates
Bell's Inequality.

01:21:48.230 --> 01:21:49.652
There is no
classical description

01:21:49.652 --> 01:21:50.860
underlying quantum mechanics.

01:21:50.860 --> 01:21:54.020
The universe around you is
inescapably probabilistic.

01:21:54.020 --> 01:21:55.562
It evolves in a
deterministic fashion

01:21:55.562 --> 01:21:56.811
through Schrodinger evolution.

01:21:56.811 --> 01:21:58.780
But when we measure
things, we measure results

01:21:58.780 --> 01:22:00.250
with probabilities.

01:22:00.250 --> 01:22:03.020
And those probabilities cannot
be explained through some

01:22:03.020 --> 01:22:04.479
underlying classical dynamics.

01:22:04.479 --> 01:22:06.770
If there's something else
underlying quantum mechanics,

01:22:06.770 --> 01:22:09.660
whatever else we know about
it, is it is not classical.

01:22:09.660 --> 01:22:12.290
And this property of
probabilistic evolution,

01:22:12.290 --> 01:22:16.160
or probabilistic measurement, is
an inescapable and empirically

01:22:16.160 --> 01:22:19.752
verified property of
the reality around us.

01:22:19.752 --> 01:22:20.960
And that's quantum mechanics.

01:22:20.960 --> 01:22:22.930
Thanks guys.

