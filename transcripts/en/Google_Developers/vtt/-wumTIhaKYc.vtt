WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:33.230
[MUSIC PLAYING]

00:00:33.230 --> 00:00:34.920
MALE SPEAKER: Shanghai
GDG is a very

00:00:34.920 --> 00:00:37.000
interesting developer community.

00:00:37.000 --> 00:00:37.840
FEMALE SPEAKER: I'm
glad somebody

00:00:37.840 --> 00:00:38.920
has asked this question.

00:00:38.920 --> 00:00:40.670
MALE SPEAKER: This is where
the magic happens.

00:00:40.670 --> 00:00:41.728
FEMALE SPEAKER: This is
primarily a question and

00:00:41.728 --> 00:00:42.354
answer show.

00:00:42.354 --> 00:00:44.560
So if any of you out there would
like to ask questions.

00:00:53.360 --> 00:00:55.300
PETE LEPAGE: Well,
welcome everyone.

00:00:55.300 --> 00:00:56.240
My name is Pete LePage.

00:00:56.240 --> 00:00:58.630
I'm a developer advocate
on the Chrome team.

00:00:58.630 --> 00:01:03.030
And with me today, we have Paul
Kinlan, who is here in

00:01:03.030 --> 00:01:04.860
London joining us.

00:01:04.860 --> 00:01:05.290
PAUL KINLAN: Hello.

00:01:05.290 --> 00:01:08.710
PETE LEPAGE: And we're here to
talk about Chrome apps and

00:01:08.710 --> 00:01:11.400
talk about the networking
stack.

00:01:11.400 --> 00:01:15.010
We decided to do something a
little bit different, a little

00:01:15.010 --> 00:01:16.320
bit fun this week.

00:01:16.320 --> 00:01:20.000
This was actually Paul's idea
to go a little bit deep and

00:01:20.000 --> 00:01:22.610
see if we could get a little bit
meta, do something inside

00:01:22.610 --> 00:01:25.170
of something that normally
hasn't been done before.

00:01:25.170 --> 00:01:28.680
So Paul, why don't you introduce
us to some of the

00:01:28.680 --> 00:01:31.770
new networking APIs that
are available?

00:01:31.770 --> 00:01:33.480
PAUL KINLAN: Yeah, cool,
so I'm Paul Kinlan.

00:01:33.480 --> 00:01:34.640
I'm based in London.

00:01:34.640 --> 00:01:36.490
You know Pete, you know
what we forgot to do?

00:01:36.490 --> 00:01:37.110
PETE LEPAGE: What is that?

00:01:37.110 --> 00:01:38.480
PAUL KINLAN: We forgot to look
at each other and high-five

00:01:38.480 --> 00:01:40.190
each other across
the internet.

00:01:40.190 --> 00:01:41.020
PETE LEPAGE: So we're ready.

00:01:41.020 --> 00:01:41.580
All right.

00:01:41.580 --> 00:01:42.320
PAUL KINLAN: Are
you good to go?

00:01:42.320 --> 00:01:42.900
PETE LEPAGE: We're good to go.

00:01:42.900 --> 00:01:43.400
You ready?

00:01:43.400 --> 00:01:44.340
PAUL KINLAN: Three, two, one.

00:01:44.340 --> 00:01:45.610
PETE LEPAGE: Two, three.

00:01:45.610 --> 00:01:46.390
PAUL KINLAN: Yeah.

00:01:46.390 --> 00:01:46.950
PETE LEPAGE: Whoa.

00:01:46.950 --> 00:01:49.960
OK, well, that was a complete,
total, utter fail.

00:01:49.960 --> 00:01:51.190
But that's OK.

00:01:51.190 --> 00:01:51.650
PAUL KINLAN: It sounded good.

00:01:51.650 --> 00:01:52.940
PETE LEPAGE: Yeah,
it sounded good.

00:01:52.940 --> 00:01:54.540
And we tried.

00:01:54.540 --> 00:01:55.270
PAUL KINLAN: We tried, right.

00:01:55.270 --> 00:01:57.550
PETE LEPAGE: A for effort.

00:01:57.550 --> 00:01:59.190
PAUL KINLAN: So yes, anyway,
back on the subject.

00:01:59.190 --> 00:02:01.920
We have a new set of
APIs in Chrome.

00:02:01.920 --> 00:02:04.670
I think in the past that we've
talked about the Chrome socket

00:02:04.670 --> 00:02:06.100
API and space.

00:02:06.100 --> 00:02:09.770
And one big glaring omission
from that API was the ability

00:02:09.770 --> 00:02:13.600
to listen on port and
bind to it by UDP.

00:02:13.600 --> 00:02:14.850
That landed a little
while ago.

00:02:14.850 --> 00:02:17.360
So you can build a server,
which basically

00:02:17.360 --> 00:02:18.470
receives UDP input.

00:02:18.470 --> 00:02:21.350
And when we showed you the Air
Drone demo, about three or

00:02:21.350 --> 00:02:26.150
four weeks ago I think, that was
using a UDP-based server.

00:02:26.150 --> 00:02:29.390
But again, the next omission,
from this whole API, was the

00:02:29.390 --> 00:02:33.430
ability to, actually in
JavaScript and HTML, build a

00:02:33.430 --> 00:02:36.900
server that is TCP based
inside the browser.

00:02:36.900 --> 00:02:38.250
So we now have the ability.

00:02:38.250 --> 00:02:39.280
And it landed recently.

00:02:39.280 --> 00:02:40.500
It's only experimental.

00:02:40.500 --> 00:02:42.810
It's only in Chrome Canary
at the moment.

00:02:42.810 --> 00:02:49.780
But we recently landed the
ability to listen and accept

00:02:49.780 --> 00:02:51.880
API calls inside Chrome.

00:02:51.880 --> 00:02:53.580
So what this enables you
to do is basically

00:02:53.580 --> 00:02:55.410
build TCP based servers.

00:02:55.410 --> 00:02:57.810
You could build an FTP server.

00:02:57.810 --> 00:03:00.090
What we're going to talk about
today, which is a web server

00:03:00.090 --> 00:03:01.720
that we've built and will
be available in

00:03:01.720 --> 00:03:04.010
GitHub after the show.

00:03:04.010 --> 00:03:05.460
Yeah, it's pretty powerful.

00:03:05.460 --> 00:03:07.680
The fact that you can have a
web server inside your web

00:03:07.680 --> 00:03:10.380
browser itself, inside
your applications.

00:03:10.380 --> 00:03:12.030
I think it's been
done by Opera.

00:03:12.030 --> 00:03:13.310
And I think Firefox has
had some stuff.

00:03:13.310 --> 00:03:16.366
But now we've got pure access in
JavaScript to be able to do

00:03:16.366 --> 00:03:16.710
these things.

00:03:16.710 --> 00:03:18.680
And it's pretty exciting
inside apps.

00:03:18.680 --> 00:03:19.780
PETE LEPAGE: Yeah,
it definitely is.

00:03:19.780 --> 00:03:21.960
And this is one of these things
that I don't think

00:03:21.960 --> 00:03:25.010
really anybody's ever
done before.

00:03:25.010 --> 00:03:28.690
And accessing these things is a
really powerful thing to be

00:03:28.690 --> 00:03:30.540
able to do.

00:03:30.540 --> 00:03:31.170
PAUL KINLAN: Yeah.

00:03:31.170 --> 00:03:31.670
I'ts pretty cool, right?

00:03:31.670 --> 00:03:31.890
PETE LEPAGE: Yeah.

00:03:31.890 --> 00:03:34.660
PAUL KINLAN: So we were
discussing the different types

00:03:34.660 --> 00:03:36.000
of ideas, the things
that we could do.

00:03:36.000 --> 00:03:39.340
And you know, web server
is the first one.

00:03:39.340 --> 00:03:40.860
The first thing that most people
try and do is a web

00:03:40.860 --> 00:03:44.700
server inside whatever it is,
listen on port 80 or even get

00:03:44.700 --> 00:03:46.700
the GET requests
coming back in.

00:03:46.700 --> 00:03:47.990
But you could go even further.

00:03:47.990 --> 00:03:50.500
You could build an
SMTP server.

00:03:50.500 --> 00:03:51.895
And the really important thing
about these type of

00:03:51.895 --> 00:03:52.620
the things is that--

00:03:52.620 --> 00:03:54.560
I missed saying this before,
and should have said it

00:03:54.560 --> 00:03:55.470
earlier on--

00:03:55.470 --> 00:03:57.220
I think, personally, this
is really important

00:03:57.220 --> 00:03:58.140
for Chrome OS, right?

00:03:58.140 --> 00:04:00.550
We want the people and the
developers to be able to use

00:04:00.550 --> 00:04:03.090
Chrome OS as a platform to
be able to develop web

00:04:03.090 --> 00:04:04.680
applications and applications
in general.

00:04:04.680 --> 00:04:06.800
And I think one of the things
that has generally been

00:04:06.800 --> 00:04:10.190
missing is this ability to, when
you're offline, connect

00:04:10.190 --> 00:04:12.745
to a local instance of a web
server, build your application

00:04:12.745 --> 00:04:15.920
locally, your website locally,
connect to it, and test it

00:04:15.920 --> 00:04:17.000
inside the browser.

00:04:17.000 --> 00:04:20.029
And I think this API, this
single API, the listen and

00:04:20.029 --> 00:04:23.060
accept APIs in the socket
interface, they allow us to do

00:04:23.060 --> 00:04:24.390
those types of things.

00:04:24.390 --> 00:04:25.920
It's going to be pretty cool
in the future to see what

00:04:25.920 --> 00:04:26.995
comes out on this.

00:04:26.995 --> 00:04:30.145
PETE LEPAGE: Yeah, absolutely.

00:04:30.145 --> 00:04:31.370
Go ahead.

00:04:31.370 --> 00:04:33.040
PAUL KINLAN: Should we jump to
a demo, just to prove it does

00:04:33.040 --> 00:04:36.170
work, and I'm not lying and
bringing everyone on?

00:04:36.170 --> 00:04:37.800
PETE LEPAGE: Yeah, I
think we should.

00:04:37.800 --> 00:04:40.080
PAUL KINLAN: Cool.

00:04:40.080 --> 00:04:41.860
PETE LEPAGE: All right, so
we've got your screen up.

00:04:41.860 --> 00:04:43.510
People can see your screen.

00:04:43.510 --> 00:04:45.200
PAUL KINLAN: Yay.

00:04:45.200 --> 00:04:46.650
This is my app.

00:04:46.650 --> 00:04:51.630
It's like a semi standalone
application build with the

00:04:51.630 --> 00:04:53.530
Chrome app APIs.

00:04:53.530 --> 00:04:55.740
And what it allows us to do--
and I'll just reload it,

00:04:55.740 --> 00:04:57.840
because I was testing
it before.

00:04:57.840 --> 00:04:59.800
Never say I never
come prepared.

00:04:59.800 --> 00:05:01.160
I was testing it before.

00:05:01.160 --> 00:05:02.510
So pick a file.

00:05:02.510 --> 00:05:05.170
And it's this directory here,
this app directory that I want

00:05:05.170 --> 00:05:09.650
to serve from my local machine,
to obviously local

00:05:09.650 --> 00:05:10.660
connections.

00:05:10.660 --> 00:05:13.430
Press Select, Start.

00:05:13.430 --> 00:05:15.540
So the interesting thing
about this, and I

00:05:15.540 --> 00:05:16.770
think I kind of like--

00:05:16.770 --> 00:05:20.680
oh, there's a big list of files
it can actually serve.

00:05:20.680 --> 00:05:23.910
I've used the normal input type
equals file attribute--

00:05:23.910 --> 00:05:25.350
method, sorry.

00:05:25.350 --> 00:05:25.880
Is it method?

00:05:25.880 --> 00:05:26.390
PETE LEPAGE: The directory?

00:05:26.390 --> 00:05:27.310
PAUL KINLAN: HTML tag.

00:05:27.310 --> 00:05:31.370
Yeah, the HTML5 tag, input type
equals file, with WebKit

00:05:31.370 --> 00:05:34.030
Directory, so I can select
directories.

00:05:34.030 --> 00:05:36.945
That returns, obviously, an
on-change It gives us access

00:05:36.945 --> 00:05:38.810
to the list of files that
we've selected.

00:05:38.810 --> 00:05:40.650
And I basically just take a
reference to those file

00:05:40.650 --> 00:05:41.260
references.

00:05:41.260 --> 00:05:45.000
And then I'll serve them
in the web or locally.

00:05:45.000 --> 00:05:49.300
So 127, there we go.

00:05:49.300 --> 00:05:50.170
That's it.

00:05:50.170 --> 00:05:52.560
It's kind of simple, Wotcha!

00:05:52.560 --> 00:05:52.970
Now live.

00:05:52.970 --> 00:05:54.530
This is an application
I made with Yeoman

00:05:54.530 --> 00:05:55.390
in about two seconds.

00:05:55.390 --> 00:05:55.860
PETE LEPAGE: Whoohoo.

00:05:55.860 --> 00:05:58.100
PAUL KINLAN: Nice little
plug to Yeoman.

00:05:58.100 --> 00:05:59.140
But it's the basic application,
right?

00:05:59.140 --> 00:06:00.020
It's not styled up.

00:06:00.020 --> 00:06:03.190
But the interesting thing is if
we go to Inspect Element--

00:06:03.190 --> 00:06:05.780
let me just detach that so we
can see it inside the screen.

00:06:05.780 --> 00:06:09.530
PETE LEPAGE: And just to mention
this, for folks who

00:06:09.530 --> 00:06:11.620
are interested, if they want
to check out the code for

00:06:11.620 --> 00:06:14.990
this, they can go to the
URL on the screen.

00:06:14.990 --> 00:06:21.150
You can go download the sample
at goo.gl/AZSTg.

00:06:21.150 --> 00:06:24.030
And you can see that
capitalization and all that

00:06:24.030 --> 00:06:24.500
stuff there.

00:06:24.500 --> 00:06:25.750
But, all right, sorry.

00:06:25.750 --> 00:06:26.530
Go ahead, Paul.

00:06:26.530 --> 00:06:27.270
PAUL KINLAN: Yeah,
that's cool.

00:06:27.270 --> 00:06:29.700
So we just push stuff to GitHub,
so people can off and

00:06:29.700 --> 00:06:30.915
experiment with it now.

00:06:30.915 --> 00:06:32.880
The caveat is, it's still
experimental.

00:06:32.880 --> 00:06:34.450
So you need to enable
experimental

00:06:34.450 --> 00:06:36.090
APIs and about flags.

00:06:36.090 --> 00:06:37.860
And it's also only available
in Canary.

00:06:37.860 --> 00:06:39.640
But once you enable those
two things, you can

00:06:39.640 --> 00:06:41.260
actually play this API.

00:06:41.260 --> 00:06:44.030
And if you look here,
this is the code.

00:06:44.030 --> 00:06:45.030
Sorry, not the code.

00:06:45.030 --> 00:06:47.190
Sorry, this is the list of
requests, just to prove that

00:06:47.190 --> 00:06:49.240
I'm actually making
those requests

00:06:49.240 --> 00:06:51.890
from my local resource--

00:06:51.890 --> 00:06:54.010
script score slash vendor, for
instance, forward slash

00:06:54.010 --> 00:06:55.820
modernizer dot min dot JS.

00:06:55.820 --> 00:06:57.380
That's being served off
of my local file

00:06:57.380 --> 00:06:59.810
system via this interface.

00:06:59.810 --> 00:07:00.482
So it's pretty cool.

00:07:00.482 --> 00:07:01.260
It's pretty powerful.

00:07:01.260 --> 00:07:04.400
And we're going to show
you actually how

00:07:04.400 --> 00:07:05.620
to build these things--

00:07:05.620 --> 00:07:05.980
PETE LEPAGE: Sweet.

00:07:05.980 --> 00:07:06.620
PAUL KINLAN: Today.

00:07:06.620 --> 00:07:08.320
So should we jump into code?

00:07:08.320 --> 00:07:10.850
PETE LEPAGE: Absolutely.

00:07:10.850 --> 00:07:13.300
PAUL KINLAN: So, as we can see
here, everybody who can see my

00:07:13.300 --> 00:07:16.170
screen, the first thing that
we need to do when we're

00:07:16.170 --> 00:07:18.820
building this application, is
actually change the manifest.

00:07:18.820 --> 00:07:22.010
The reason why we need to do
this, and I should've gotten

00:07:22.010 --> 00:07:24.690
rid of this earlier on, is by
default we don't normally have

00:07:24.690 --> 00:07:28.500
experimental permissions enabled
inside our manifest.

00:07:28.500 --> 00:07:32.410
So if I just select this and
see this here, you add

00:07:32.410 --> 00:07:33.450
experimental.

00:07:33.450 --> 00:07:38.810
This will enable your access
to the advanced socket API.

00:07:38.810 --> 00:07:40.030
You then ask for a socket
permission.

00:07:40.030 --> 00:07:41.660
And this is relatively
new syntax.

00:07:41.660 --> 00:07:43.380
It landed maybe about
a month ago.

00:07:43.380 --> 00:07:44.370
PETE LEPAGE: OK.

00:07:44.370 --> 00:07:46.320
PAUL KINLAN: But it allows you
to basically say and list

00:07:46.320 --> 00:07:48.480
different types of permissions
that you want the socket

00:07:48.480 --> 00:07:50.490
interface to have inside
your application.

00:07:50.490 --> 00:07:53.920
So if you're going to do UDP
server or send UDP requests

00:07:53.920 --> 00:07:56.940
out from your client
applications or remote server,

00:07:56.940 --> 00:07:59.010
you need to actually specify
this up front, so that the

00:07:59.010 --> 00:08:02.110
user, when they install this
application, they know the

00:08:02.110 --> 00:08:05.170
types of interactions with your
native operating system

00:08:05.170 --> 00:08:06.430
that you're going to have.

00:08:06.430 --> 00:08:07.560
And in this case--

00:08:07.560 --> 00:08:08.020
PETE LEPAGE: Yeah.

00:08:08.020 --> 00:08:12.110
I was going to say, Paul, so
if I want to send UDP, I'm

00:08:12.110 --> 00:08:15.800
guessing it's probably not UDP
connect and UDP listen is it?

00:08:15.800 --> 00:08:16.360
PAUL KINLAN: No it's not.

00:08:16.360 --> 00:08:19.390
It's UDP sendto, I believe.

00:08:19.390 --> 00:08:21.790
And it will be UDP bind.

00:08:21.790 --> 00:08:24.790
PETE LEPAGE: UDP sendto to send
packets, and then UDP

00:08:24.790 --> 00:08:28.110
bind will allow you to bind to
a port to listen for next

00:08:28.110 --> 00:08:28.885
stuff coming in?

00:08:28.885 --> 00:08:29.280
PAUL KINLAN: Yeah.

00:08:29.280 --> 00:08:31.260
And the sytax can get a little
bit more complex.

00:08:31.260 --> 00:08:35.080
So you can basically, in theory,
bind to just a single

00:08:35.080 --> 00:08:37.539
address on a special port.

00:08:37.539 --> 00:08:41.309
And what this is basically
trying to say to do here is,

00:08:41.309 --> 00:08:45.180
well, if you say TCP listen,
your application could bind to

00:08:45.180 --> 00:08:46.760
any port on the user's system.

00:08:46.760 --> 00:08:48.975
I believe it's not under the
root's permissions, so

00:08:48.975 --> 00:08:50.150
anything below.

00:08:50.150 --> 00:08:52.400
1024, I think you can't
bind to, but anything

00:08:52.400 --> 00:08:54.215
above that you can.

00:08:54.215 --> 00:08:57.460
But when you're doing a UDP
send or a TCP connect, in

00:08:57.460 --> 00:08:59.710
theory, you could connect
to port 22 for TELNET

00:08:59.710 --> 00:09:02.110
and port 80 for HTTP.

00:09:02.110 --> 00:09:05.650
You just want to let the user
know, for instance, those

00:09:05.650 --> 00:09:06.790
types of services.

00:09:06.790 --> 00:09:10.910
I'm going to give them that
little bit of extra trust that

00:09:10.910 --> 00:09:12.880
they get when they know the
only things that they can

00:09:12.880 --> 00:09:14.980
access are the things you've
listed up front.

00:09:14.980 --> 00:09:17.690
But anyway, back on topic.

00:09:17.690 --> 00:09:19.760
The most important thing
here is TCP listen.

00:09:19.760 --> 00:09:23.280
This is the new experimental
permission that you need for

00:09:23.280 --> 00:09:25.830
the socket interface to be able
to listen to ports and

00:09:25.830 --> 00:09:28.110
listen to incoming requests.

00:09:28.110 --> 00:09:29.950
So if you add this in and you've
already got a socket

00:09:29.950 --> 00:09:32.060
based application, you
should be good to go.

00:09:32.060 --> 00:09:34.900
Now that doesn't mean that--

00:09:34.900 --> 00:09:35.730
sorry--

00:09:35.730 --> 00:09:37.615
doesn't mean, straight away,
that you're going be able to

00:09:37.615 --> 00:09:38.360
start taking requests.

00:09:38.360 --> 00:09:40.660
Obviously you have to
program the API.

00:09:40.660 --> 00:09:43.890
So I just want to show you, just
to prove that all this is

00:09:43.890 --> 00:09:44.470
the same thing.

00:09:44.470 --> 00:09:46.676
Ignore this styling stuff.

00:09:46.676 --> 00:09:50.450
But let me go to the next
input type equals file.

00:09:50.450 --> 00:09:53.350
This is the HTML that's
involved in actually

00:09:53.350 --> 00:09:55.530
constructing our
user interface.

00:09:55.530 --> 00:09:58.845
Input type equals file with an
attribute of WebKit Directory

00:09:58.845 --> 00:10:01.160
and just an ID called
directory.

00:10:01.160 --> 00:10:03.980
Now the reason why I do WebKit
Directory is, if you've never

00:10:03.980 --> 00:10:06.070
actually done this before,
normally, input type equals

00:10:06.070 --> 00:10:10.290
file only allows you to
select one file from

00:10:10.290 --> 00:10:11.710
the user's file system.

00:10:11.710 --> 00:10:14.350
If you do input type equals
file under a multiple

00:10:14.350 --> 00:10:17.700
attribute, then you can select
multiple files on the user's

00:10:17.700 --> 00:10:20.440
system and get it brought back
into your application.

00:10:20.440 --> 00:10:22.450
But if you do WebKit Directory,
WebKit Directory

00:10:22.450 --> 00:10:26.110
basically gives you the entire
list of files inside the

00:10:26.110 --> 00:10:27.610
directory that the
user's selected.

00:10:27.610 --> 00:10:30.280
So we went to the app demo
before, and we saw the fact

00:10:30.280 --> 00:10:33.560
that I selected the app folder,
everything inside that

00:10:33.560 --> 00:10:34.680
folder is now available
to my application

00:10:34.680 --> 00:10:36.030
to be able to read.

00:10:36.030 --> 00:10:38.140
You can't write to those
applications.

00:10:38.140 --> 00:10:40.790
That's actually a subject for
another Hangout altogether is

00:10:40.790 --> 00:10:43.180
how to write to these files
and actually you can get

00:10:43.180 --> 00:10:46.230
access to them once you've
got a reference to it.

00:10:46.230 --> 00:10:47.720
But now it's only read-only.

00:10:47.720 --> 00:10:49.410
And to be fair, that's kind of
all we really need for our

00:10:49.410 --> 00:10:50.360
basic web service--

00:10:50.360 --> 00:10:53.680
to be able to read files that
are contained in a directory

00:10:53.680 --> 00:10:58.580
that the user has chosen and
granted you access to.

00:10:58.580 --> 00:11:00.970
So anyway, let's jump
into the code.

00:11:00.970 --> 00:11:02.780
index.js is where it lives.

00:11:02.780 --> 00:11:04.600
And as you can see, I've already
got a whole lot of

00:11:04.600 --> 00:11:04.910
boilerplate.

00:11:04.910 --> 00:11:07.550
I mean a lot of this code is
actually just hooking up the

00:11:07.550 --> 00:11:12.070
user interface elements and
then also doing stream

00:11:12.070 --> 00:11:12.650
conversions.

00:11:12.650 --> 00:11:15.120
Because the interesting things
to know about the socket API

00:11:15.120 --> 00:11:18.030
is it sends array
buffer objects.

00:11:18.030 --> 00:11:20.200
And the array buffer object is
not something that we normally

00:11:20.200 --> 00:11:22.290
deal with inside JavaScript.

00:11:22.290 --> 00:11:24.490
PETE LEPAGE: Yeah, we're not
used to that at all.

00:11:24.490 --> 00:11:28.420
So what's the difference between
an array buffer and a

00:11:28.420 --> 00:11:32.510
string, if I haven't really
played with those before?

00:11:32.510 --> 00:11:34.673
PAUL KINLAN: Yes, so the main
difference between an array

00:11:34.673 --> 00:11:37.030
buffer and a string,
essentially, is the fact that,

00:11:37.030 --> 00:11:39.400
if you have ever done any kind
of boundary manipulation on

00:11:39.400 --> 00:11:42.680
the string inside JavaScript,
you know how hard is it.

00:11:42.680 --> 00:11:44.500
You have to take the high order
byte and the lower order

00:11:44.500 --> 00:11:46.160
byte, because it's
UTF16, I think.

00:11:46.160 --> 00:11:48.480
And you have to do a whole lot
of manipulation just to access

00:11:48.480 --> 00:11:49.000
the core data.

00:11:49.000 --> 00:11:50.070
PETE LEPAGE: Yeah.

00:11:50.070 --> 00:11:53.070
PAUL KINLAN: And the array
buffer allows you to have

00:11:53.070 --> 00:11:55.570
multiple different types of
views on a piece of data.

00:11:55.570 --> 00:11:58.290
So you can say my entire data,
that's contained in array

00:11:58.290 --> 00:12:04.430
buffer, is of UInt array type or
UInt8 array, UInt16 array,

00:12:04.430 --> 00:12:07.460
UInt32 array.

00:12:07.460 --> 00:12:10.470
So you can say your array is
of different types of data.

00:12:10.470 --> 00:12:13.270
But, essentially, what it allows
you to do is say, well,

00:12:13.270 --> 00:12:16.590
my view on this array buffer is
an array of 8 bit integers,

00:12:16.590 --> 00:12:17.220
essentially.

00:12:17.220 --> 00:12:20.140
And that allows you to then
say, well, we just read

00:12:20.140 --> 00:12:21.170
through the bytes
individually.

00:12:21.170 --> 00:12:25.530
So as you can see here, if we
go here, the view, we got a

00:12:25.530 --> 00:12:29.880
new array based on the array
buffer of type UInt8 array.

00:12:29.880 --> 00:12:33.940
And then we just iterate across
it and, basically,

00:12:33.940 --> 00:12:35.300
convert our string.

00:12:35.300 --> 00:12:37.870
So we convert our string
into UInt8 array.

00:12:37.870 --> 00:12:41.270
So its written across our string
and then pushing that

00:12:41.270 --> 00:12:44.330
value that's held in the array,
directly into the

00:12:44.330 --> 00:12:46.320
actual array buffer itself.

00:12:46.320 --> 00:12:47.040
PETE LEPAGE: Perfect.

00:12:47.040 --> 00:12:50.210
PAUL KINLAN: And that's cool,
because then you can handle

00:12:50.210 --> 00:12:53.340
big endian and little endian,
when you try and deliver data.

00:12:53.340 --> 00:12:56.140
It's super important for the
socket API, because the

00:12:56.140 --> 00:12:58.420
majority of time we're not
really sending strings around.

00:12:58.420 --> 00:13:00.700
When doing a web socket, for
instance, you might want to

00:13:00.700 --> 00:13:01.850
send a string, because
it's an adjacent

00:13:01.850 --> 00:13:02.990
structure and that's fine.

00:13:02.990 --> 00:13:07.100
But actually, at the raw level
for the socket API, you send

00:13:07.100 --> 00:13:08.866
raw binary data.

00:13:08.866 --> 00:13:11.020
And that's why we need these
extra little functions.

00:13:11.020 --> 00:13:14.130
We also have an array buffer to
string, which we just used

00:13:14.130 --> 00:13:16.500
to basically convert, obviously,
an array buffer,

00:13:16.500 --> 00:13:19.000
the data that we receive back
from the service to a string.

00:13:19.000 --> 00:13:19.710
PETE LEPAGE: Right.

00:13:19.710 --> 00:13:21.410
PAUL KINLAN: And the reason
why we use this is that we

00:13:21.410 --> 00:13:24.630
have to parse out, for instance,
when an HTTP request

00:13:24.630 --> 00:13:28.685
comes in, there's a very
specific set of headers that

00:13:28.685 --> 00:13:29.670
you get through.

00:13:29.670 --> 00:13:33.590
And passing in binary, actually
byte by byte, is just

00:13:33.590 --> 00:13:34.170
a bit of a pain.

00:13:34.170 --> 00:13:34.400
PETE LEPAGE: Yeah.

00:13:34.400 --> 00:13:36.080
PAUL KINLAN: So I convert
it to a string and do

00:13:36.080 --> 00:13:36.680
some work onto it.

00:13:36.680 --> 00:13:37.910
You'll see that there's
probably a big glaring

00:13:37.910 --> 00:13:40.660
security hole in it, where I
just read the whole string.

00:13:40.660 --> 00:13:43.640
And if you send a big enough
set of headers, like 1,000

00:13:43.640 --> 00:13:46.140
megabytes or gigabytes of
headers, my application will

00:13:46.140 --> 00:13:47.330
probably crash.

00:13:47.330 --> 00:13:50.160
But just to demonstrate the
purpose of this, like I said

00:13:50.160 --> 00:13:52.140
to you guys, we're ignoring
all of that type of stuff.

00:13:52.140 --> 00:13:52.860
PETE LEPAGE: All right.

00:13:52.860 --> 00:13:55.300
And I think that's one other
thing to point out.

00:13:55.300 --> 00:14:00.030
We wrote this as a really quick
sample, not as something

00:14:00.030 --> 00:14:04.220
that is meant to be used as a
key thing that you should copy

00:14:04.220 --> 00:14:07.450
everything from and sit
down and write a web

00:14:07.450 --> 00:14:09.750
server using this.

00:14:09.750 --> 00:14:13.000
We just wanted to sort of get
some of the concepts across.

00:14:13.000 --> 00:14:16.040
And there's a few things we
could have done better.

00:14:16.040 --> 00:14:18.300
A few things we could
have done worse.

00:14:18.300 --> 00:14:19.795
PAUL KINLAN: I mean the demo's
only going to show you how to

00:14:19.795 --> 00:14:21.220
handle get requests.

00:14:21.220 --> 00:14:25.860
So if you want to do cross
origin and post puts and

00:14:25.860 --> 00:14:27.790
everything else, that's not
going to work at the moment.

00:14:27.790 --> 00:14:29.300
But the concept is there.

00:14:29.300 --> 00:14:31.740
You can build a web server
entirely in JavaScript that

00:14:31.740 --> 00:14:33.230
lives inside your browser.

00:14:33.230 --> 00:14:37.940
The place I always like this,
and I don't think they're ever

00:14:37.940 --> 00:14:41.530
going to do it, but the App
Engine SDK uploader.

00:14:41.530 --> 00:14:43.320
You kind of get your
dev environment.

00:14:43.320 --> 00:14:47.520
You can basically run Python
with mscript and whatever

00:14:47.520 --> 00:14:48.940
other technologies
you want to use.

00:14:48.940 --> 00:14:51.580
You can have the App Engine's
mini system just run inside

00:14:51.580 --> 00:14:53.286
the browser and upload.

00:14:53.286 --> 00:14:56.190
That's where I'd like to get
to in 10 year's time.

00:14:56.190 --> 00:14:58.555
Actually, in 10 year's time,
I'd like to be retired and

00:14:58.555 --> 00:14:59.180
living on the beach somewhere.

00:14:59.180 --> 00:15:00.840
PETE LEPAGE: Well, yeah.

00:15:00.840 --> 00:15:04.080
Well, how about then, in nine
years time, you get that done.

00:15:04.080 --> 00:15:06.540
And then in 10 years, you can
retire, because everybody just

00:15:06.540 --> 00:15:09.380
thinks that's so awesome and
they just make it happen.

00:15:09.380 --> 00:15:09.450
PAUL KINLAN: Yeah.

00:15:09.450 --> 00:15:11.026
I think that's good.

00:15:11.026 --> 00:15:11.680
I think that's really good.

00:15:11.680 --> 00:15:12.110
Should we do it?

00:15:12.110 --> 00:15:12.500
PETE LEPAGE: Yeah.

00:15:12.500 --> 00:15:13.360
Let's do it.

00:15:13.360 --> 00:15:14.810
Done.

00:15:14.810 --> 00:15:15.040
PAUL KINLAN: Cool.

00:15:15.040 --> 00:15:15.400
Done.

00:15:15.400 --> 00:15:17.090
Let's ship it.

00:15:17.090 --> 00:15:18.340
I have to say, I'm not
pre-announcing anything.

00:15:21.590 --> 00:15:23.780
So anyway, on that subject.

00:15:26.710 --> 00:15:28.760
So let's just jump through
the code, right.

00:15:28.760 --> 00:15:29.210
PETE LEPAGE: All right.

00:15:29.210 --> 00:15:30.230
PAUL KINLAN: This is before
the nitty-gritty, right.

00:15:30.230 --> 00:15:32.490
I just want to show you the
rest of the infrastructure

00:15:32.490 --> 00:15:34.770
that I've got ready
for you guys.

00:15:34.770 --> 00:15:35.970
They are doing dot onchange.

00:15:35.970 --> 00:15:37.600
It's not the nicest way
that we handle events.

00:15:37.600 --> 00:15:39.150
But we're only going
to bind to it once.

00:15:39.150 --> 00:15:41.760
And I just thought, for brevity,
it was going to be

00:15:41.760 --> 00:15:43.440
easier for everyone
to understand.

00:15:43.440 --> 00:15:45.400
When the user actually picks
a directory, we get

00:15:45.400 --> 00:15:46.570
the onchange event.

00:15:46.570 --> 00:15:49.610
In that onchange, we can get
an access to list of files

00:15:49.610 --> 00:15:54.540
done by this little line of
code, line 58, e.target.files.

00:15:54.540 --> 00:15:56.661
That's a list of files inside
the directory that the user

00:15:56.661 --> 00:15:57.650
has chosen.

00:15:57.650 --> 00:15:59.680
We just iterate across them.

00:15:59.680 --> 00:16:02.320
We take the Web Kit relative
path, which gives us,

00:16:02.320 --> 00:16:03.375
basically, a relative path.

00:16:03.375 --> 00:16:05.710
It doesn't give us the full
directory structure, just the

00:16:05.710 --> 00:16:07.020
root of where it is,
which is absolutely

00:16:07.020 --> 00:16:08.005
fine for a web server.

00:16:08.005 --> 00:16:11.600
Because we only ever deal,
really, with absolute paths

00:16:11.600 --> 00:16:13.080
inside our own web app.

00:16:13.080 --> 00:16:15.240
And then we just map that.

00:16:15.240 --> 00:16:19.190
We take the path, map it into,
basically, a hash.

00:16:19.190 --> 00:16:21.840
So that whenever a web request
comes in, I can then go and

00:16:21.840 --> 00:16:25.130
easily pick the file up from my
in memory store and serve

00:16:25.130 --> 00:16:26.660
that back out to the user.

00:16:26.660 --> 00:16:28.680
So that's all there is from
actually getting access to the

00:16:28.680 --> 00:16:30.290
file system.

00:16:30.290 --> 00:16:31.320
It's not the full file system.

00:16:31.320 --> 00:16:33.345
It's just the directory and all
the subdirectories that

00:16:33.345 --> 00:16:34.600
the user has chosen.

00:16:34.600 --> 00:16:35.610
But we can do some
nice things.

00:16:35.610 --> 00:16:38.220
We can kind of serve them up
inside our application.

00:16:38.220 --> 00:16:42.640
PETE LEPAGE: And to be clear,
this is the HTML5 file system,

00:16:42.640 --> 00:16:44.730
or is this the file
system access that

00:16:44.730 --> 00:16:47.150
comes with Chrome app?

00:16:47.150 --> 00:16:47.470
PAUL KINLAN: No, no.

00:16:47.470 --> 00:16:48.780
It's neither actually.

00:16:48.780 --> 00:16:49.900
Eh.

00:16:49.900 --> 00:16:52.520
So we have a couple different
types of file systems living

00:16:52.520 --> 00:16:54.320
in the user's device,
basically.

00:16:54.320 --> 00:16:58.420
We have the HTML5 file system,
which is entirely sandboxed

00:16:58.420 --> 00:17:02.010
and only available to the
application, in that domain,

00:17:02.010 --> 00:17:04.430
and all the files are obfuscated
and a whole lot of

00:17:04.430 --> 00:17:06.990
other stuff so can't go and
easily parse the files out on

00:17:06.990 --> 00:17:08.670
the user's local machine.

00:17:08.670 --> 00:17:10.869
We also have--

00:17:10.869 --> 00:17:12.559
what was the second
one you asked?

00:17:12.559 --> 00:17:14.300
PETE LEPAGE: The Chrome
apps file system.

00:17:14.300 --> 00:17:17.000
PAUL KINLAN: Yeah, so we have
the Chrome apps file system.

00:17:17.000 --> 00:17:17.550
I tell you what.

00:17:17.550 --> 00:17:20.040
It's similar to the Chrome
apps file system API.

00:17:20.040 --> 00:17:23.310
The Chrome apps file system API
and the media gallery API

00:17:23.310 --> 00:17:26.440
essentially allow you to get
elevated access to those

00:17:26.440 --> 00:17:27.280
directories.

00:17:27.280 --> 00:17:29.690
So if you're using the file
system API, you can basically

00:17:29.690 --> 00:17:32.760
say, well, the user's given
me a file, and I've got a

00:17:32.760 --> 00:17:33.440
reference to that.

00:17:33.440 --> 00:17:34.900
I want to write back to it.

00:17:34.900 --> 00:17:36.540
And we don't need that in our
application, so we're not

00:17:36.540 --> 00:17:37.790
using that part of the API.

00:17:37.790 --> 00:17:40.325
But it's using the same file
object that you get back from

00:17:40.325 --> 00:17:41.690
the system.

00:17:41.690 --> 00:17:45.280
This is literally the user's
own file system itself.

00:17:45.280 --> 00:17:46.680
So it's pretty cool.

00:17:46.680 --> 00:17:49.210
It's just a file system, but
it's only the directory that

00:17:49.210 --> 00:17:51.190
they've actually given
you access to.

00:17:51.190 --> 00:17:53.160
So let's actually get into
the code, right.

00:17:53.160 --> 00:17:54.120
Start the onclick.

00:17:54.120 --> 00:17:56.060
This is the thing that's going
to start the server.

00:17:56.060 --> 00:17:57.020
So it's pretty simple, right?

00:17:57.020 --> 00:17:58.190
We've already got the
permissions ready.

00:17:58.190 --> 00:18:01.670
So we're going to not call it
Isocket, because that's me

00:18:01.670 --> 00:18:03.150
being silly with vim.

00:18:03.150 --> 00:18:07.340
We're going to create a socket
of TCP type, with no extra

00:18:07.340 --> 00:18:09.220
information supplied.

00:18:09.220 --> 00:18:12.370
And then just take a function
call back, and call it

00:18:12.370 --> 00:18:15.040
socketInfo.

00:18:15.040 --> 00:18:17.110
So this is the very start of the
thing that most people do

00:18:17.110 --> 00:18:19.740
when they're building a
socket-based interface or an

00:18:19.740 --> 00:18:21.945
application, is they need
to create the socket.

00:18:21.945 --> 00:18:22.260
PETE LEPAGE: Right.

00:18:22.260 --> 00:18:24.420
PAUL KINLAN: So we need to do
a little bit more that that,

00:18:24.420 --> 00:18:27.960
because that's not actually
doing anything.

00:18:27.960 --> 00:18:31.600
For ease of use later on, I'm
going to bind the socket

00:18:31.600 --> 00:18:34.710
information that we get
to a global variable.

00:18:34.710 --> 00:18:38.590
Again, it's not the best type of
code, but it's just simple.

00:18:38.590 --> 00:18:39.160
It works.

00:18:39.160 --> 00:18:40.380
PETE LEPAGE: Yeah.

00:18:40.380 --> 00:18:43.490
We're going to then operate our
socket to a server socket.

00:18:43.490 --> 00:18:45.300
So we're going to say, listen.

00:18:45.300 --> 00:18:47.180
And if we do listen--

00:18:47.180 --> 00:18:50.040
oh god, sorry, I apologize.

00:18:50.040 --> 00:18:51.290
socketInfo.socketID.

00:18:55.450 --> 00:18:57.440
This is basically saying, for
the socket that we've just

00:18:57.440 --> 00:19:00.270
created, we're going to turn
it into a server socket.

00:19:00.270 --> 00:19:02.136
It doesn't mean much yet,
because we haven't got an

00:19:02.136 --> 00:19:02.990
address to bind it to.

00:19:02.990 --> 00:19:10.460
I'm just going to bind it to
local host on port 8081.

00:19:10.460 --> 00:19:11.480
This is untested now.

00:19:11.480 --> 00:19:13.963
So 8081, just to prove
that my demo later

00:19:13.963 --> 00:19:15.366
on is going to work.

00:19:15.366 --> 00:19:17.430
And we're going to allow
20 requests to come

00:19:17.430 --> 00:19:18.340
through at a time.

00:19:18.340 --> 00:19:21.780
So that's pretty much all you
have to do to get started to

00:19:21.780 --> 00:19:22.870
make it into a server socket.

00:19:22.870 --> 00:19:23.860
But the thing is, it's not that

00:19:23.860 --> 00:19:25.090
interesting once you do that.

00:19:25.090 --> 00:19:27.670
You basically want to get
notification that it's all

00:19:27.670 --> 00:19:29.920
worked and everything is fine.

00:19:29.920 --> 00:19:35.360
So if we've done it right,
console.log, I don't know,

00:19:35.360 --> 00:19:38.000
listening, listen-- you
know, I can't spell.

00:19:38.000 --> 00:19:42.300
I've found, in the past three
weeks, that my spelling is

00:19:42.300 --> 00:19:44.120
absolutely atrocious.

00:19:44.120 --> 00:19:48.800
I just noticed a spelling
mistake, result.

00:19:48.800 --> 00:19:50.710
So basically the console will
just log the fact that we made

00:19:50.710 --> 00:19:52.440
a connection and everything's
fine.

00:19:52.440 --> 00:19:55.030
If it's not fine, we'll get an
error here and an exception.

00:19:55.030 --> 00:19:56.410
So we won't be able to
do anything else.

00:19:56.410 --> 00:19:59.650
And now what we need to do is be
able to start to listen and

00:19:59.650 --> 00:20:07.020
accept our first connection
coming in.

00:20:07.020 --> 00:20:10.570
So let's just go over this a
little bit, because there's a

00:20:10.570 --> 00:20:12.940
lot that's going on,
in a relatively

00:20:12.940 --> 00:20:14.330
short amount of time.

00:20:14.330 --> 00:20:18.040
So in this case, we've made
our socket, created it.

00:20:18.040 --> 00:20:18.290
It's there.

00:20:18.290 --> 00:20:18.760
It's ready.

00:20:18.760 --> 00:20:20.050
The system knows about it.

00:20:20.050 --> 00:20:20.530
PETE LEPAGE: Yep.

00:20:20.530 --> 00:20:22.250
PAUL KINLAN: And then we've
just said, listen.

00:20:22.250 --> 00:20:24.910
So the idea here normally is,
in a client application, you

00:20:24.910 --> 00:20:26.550
do connect.

00:20:26.550 --> 00:20:28.160
You create a socket and then
you connect to a remote

00:20:28.160 --> 00:20:31.710
service or you send some
data via a UDP request.

00:20:31.710 --> 00:20:32.666
That's not what we're doing.

00:20:32.666 --> 00:20:33.410
That's a client application.

00:20:33.410 --> 00:20:35.820
This is service application,
a server application.

00:20:35.820 --> 00:20:38.950
So we're just saying listen on
port-- well, listen on IP

00:20:38.950 --> 00:20:43.130
address 127.0.0.1
on port 8081.

00:20:43.130 --> 00:20:47.030
Now I've hard coded in 127,
just because it just

00:20:47.030 --> 00:20:48.060
illustrates the point.

00:20:48.060 --> 00:20:51.560
You can actually get a list of
the network interfaces and let

00:20:51.560 --> 00:20:53.360
the user choose which
IP address.

00:20:53.360 --> 00:20:55.790
PETE LEPAGE: Which IP address
they want or which network

00:20:55.790 --> 00:20:57.340
adapter they want
to listen on.

00:20:57.340 --> 00:20:58.520
PAUL KINLAN: Yeah, essentially,
yeah.

00:20:58.520 --> 00:21:00.250
So that then lets you
get the IP address.

00:21:00.250 --> 00:21:03.240
And then you can listen on a
public IP address if your

00:21:03.240 --> 00:21:05.460
browser was--

00:21:05.460 --> 00:21:08.030
PETE LEPAGE: Multi-homed or
something like that, yeah.

00:21:08.030 --> 00:21:09.710
PAUL KINLAN: But I mean
normally, if you've got a

00:21:09.710 --> 00:21:11.530
local network and you want to
try connect to it, then you

00:21:11.530 --> 00:21:14.182
can bind to your Ethernet card
or your WiFi adapter and then

00:21:14.182 --> 00:21:15.200
have the requests come in.

00:21:15.200 --> 00:21:17.970
PETE LEPAGE: Well this could be
an interesting scenario for

00:21:17.970 --> 00:21:21.700
those people who want to write
a proxy server at home-- and

00:21:21.700 --> 00:21:24.270
have a proxy server sit at home,
that they could go and

00:21:24.270 --> 00:21:27.370
just basically write something
that proxies out network

00:21:27.370 --> 00:21:30.790
connections effectively.

00:21:30.790 --> 00:21:32.350
PAUL KINLAN: Yeah, you could
actually do that.

00:21:32.350 --> 00:21:33.170
That's actually pretty cool.

00:21:33.170 --> 00:21:34.150
PETE LEPAGE: Yeah.

00:21:34.150 --> 00:21:36.500
PAUL KINLAN: Yeah, and that's
all done by JavaScript HTML.

00:21:36.500 --> 00:21:38.140
PETE LEPAGE: Exactly.

00:21:38.140 --> 00:21:41.070
So one of things I want to call
out here that, when I

00:21:41.070 --> 00:21:42.860
first started writing some of
these network connection

00:21:42.860 --> 00:21:47.820
things, it took me a second to
go, oh, great, I love this.

00:21:47.820 --> 00:21:51.370
You do get into a bit of
call back fun, right?

00:21:51.370 --> 00:21:55.910
So on the create, it actually
has a call back that says,

00:21:55.910 --> 00:21:58.160
once it's created, call
this function.

00:21:58.160 --> 00:22:01.790
Then, once you've created the
socket, then you actually have

00:22:01.790 --> 00:22:04.920
to tell the socket what to do.

00:22:04.920 --> 00:22:08.730
So you actually have to go
and work with a couple of

00:22:08.730 --> 00:22:09.610
different pieces.

00:22:09.610 --> 00:22:13.160
So when you look at this,
remember, to think through,

00:22:13.160 --> 00:22:15.410
OK, what's this call
back going to do?

00:22:15.410 --> 00:22:19.290
How's this going to work,
in each of these pieces?

00:22:19.290 --> 00:22:21.340
PAUL KINLAN: I think that's the
important thing, right?

00:22:21.340 --> 00:22:24.440
We're just using the call backs
here because it keeps

00:22:24.440 --> 00:22:25.635
everything in one lump.

00:22:25.635 --> 00:22:26.910
You probably want
to do a bind.

00:22:26.910 --> 00:22:29.750
And you basically just pass
everything, like marginalize

00:22:29.750 --> 00:22:31.030
your JavaScript a little
better than

00:22:31.030 --> 00:22:32.560
we're going to do today.

00:22:32.560 --> 00:22:36.040
Basically just bind and let the
the object and scope flow

00:22:36.040 --> 00:22:37.820
through to function calls .

00:22:37.820 --> 00:22:41.070
The interesting thing is that
this is a common problem that

00:22:41.070 --> 00:22:42.130
JavaScript developers do.

00:22:42.130 --> 00:22:44.930
And if you're using Node, for
instance, there's a whole of

00:22:44.930 --> 00:22:48.890
NPM modules, which I try to make
asynchronous call back

00:22:48.890 --> 00:22:51.030
management a lot easier.

00:22:51.030 --> 00:22:53.680
Can I call that an
open challenge?

00:22:53.680 --> 00:22:54.720
PETE LEPAGE: Absolutely.

00:22:54.720 --> 00:22:55.670
PAUL KINLAN: I don't know.

00:22:55.670 --> 00:22:57.162
I don't know how I'm going
to do this just yet.

00:22:57.162 --> 00:23:00.685
But I would absolutely love to
see, now that we're getting

00:23:00.685 --> 00:23:02.630
some parity between the features
and functionality

00:23:02.630 --> 00:23:05.830
available on Node.js, is if we
can leverage some of the

00:23:05.830 --> 00:23:08.520
functionality that people have
built in to Node, whether it's

00:23:08.520 --> 00:23:12.400
connect, even like the web
socket servers and all this

00:23:12.400 --> 00:23:14.040
type of stuff.

00:23:14.040 --> 00:23:16.350
All these functions, if we can
write in a light wrapper

00:23:16.350 --> 00:23:19.630
around the APIs that are in
Node, that will be brilliant.

00:23:19.630 --> 00:23:20.950
If you just get them imported
into Chrome.

00:23:20.950 --> 00:23:23.940
And then we've got a similar
ecosystem across the server

00:23:23.940 --> 00:23:25.630
and then also across
the browser.

00:23:25.630 --> 00:23:29.190
What you know is your server
inside the browser, which on

00:23:29.190 --> 00:23:30.410
the client would be
pretty powerful.

00:23:30.410 --> 00:23:33.080
And then we've got big ecosystem
of application

00:23:33.080 --> 00:23:35.190
functionality then available
to developers.

00:23:35.190 --> 00:23:36.540
PETE LEPAGE: Yes.

00:23:36.540 --> 00:23:37.210
PAUL KINLAN: It would be cool.

00:23:37.210 --> 00:23:37.850
Get Meteor on.

00:23:37.850 --> 00:23:39.260
That would be brilliant, Meteor
in the browser talking

00:23:39.260 --> 00:23:39.940
to the browser.

00:23:39.940 --> 00:23:40.862
PETE LEPAGE: Yep.

00:23:40.862 --> 00:23:43.170
PAUL KINLAN: Sweet.

00:23:43.170 --> 00:23:45.315
Yeah, I was going to say I'll
buy someone an Nexus

00:23:45.315 --> 00:23:46.510
7 if they do that.

00:23:46.510 --> 00:23:47.780
But I don't think I'm
allowed to say that.

00:23:47.780 --> 00:23:49.190
PETE LEPAGE: No, probably not.

00:23:49.190 --> 00:23:51.570
Well, unless you wanted to buy
yourself an extra set--

00:23:51.570 --> 00:23:52.840
PAUL KINLAN: I would buy
it myself, actually.

00:23:52.840 --> 00:23:57.010
If someone did it, and they did
it I'd buy them a Nexus 7.

00:23:57.010 --> 00:24:00.080
PETE LEPAGE: So just to be
clear, it's not a promise.

00:24:00.080 --> 00:24:03.480
But I think if they show
something pretty cool, I think

00:24:03.480 --> 00:24:07.780
there might be some good
recognition for them.

00:24:07.780 --> 00:24:08.360
PAUL KINLAN: Yes.

00:24:08.360 --> 00:24:11.270
Definitely.

00:24:11.270 --> 00:24:13.670
PETE LEPAGE: All right, so let's
hop back into this code.

00:24:13.670 --> 00:24:14.870
PAUL KINLAN: Yeah, I'm trying
to work out how much trouble

00:24:14.870 --> 00:24:15.800
that we're going to be in.

00:24:15.800 --> 00:24:17.055
Well, I'm going to be in now.

00:24:17.055 --> 00:24:18.730
PETE LEPAGE: Eh.

00:24:18.730 --> 00:24:19.980
PAUL KINLAN: So let's
jump in, right.

00:24:19.980 --> 00:24:20.870
So we got the connection.

00:24:20.870 --> 00:24:22.475
And I'm really sorry
about going up and

00:24:22.475 --> 00:24:23.010
down through the code.

00:24:23.010 --> 00:24:26.500
I just made a little
mistake then.

00:24:26.500 --> 00:24:28.520
So I'll just jump in, right.

00:24:28.520 --> 00:24:31.025
Let's split the window, so
you can see the code.

00:24:31.025 --> 00:24:34.910
This is why I like
vim It's cool.

00:24:34.910 --> 00:24:37.330
But also your preferred text
editor is also cool.

00:24:37.330 --> 00:24:39.193
I'm not going to get into
a war about this.

00:24:39.193 --> 00:24:40.310
PETE LEPAGE: I was
going to say, I

00:24:40.310 --> 00:24:41.430
think Sublime is awesome.

00:24:41.430 --> 00:24:42.590
But you know.

00:24:42.590 --> 00:24:44.060
PAUL KINLAN: Yeah, I know.

00:24:44.060 --> 00:24:45.920
PETE LEPAGE: Whatever
floats your boat.

00:24:45.920 --> 00:24:49.050
Actually while you get yourself
set up there, I do

00:24:49.050 --> 00:24:50.620
want to mention one
thing real quick.

00:24:50.620 --> 00:24:53.270
If people who are watching this
have questions, they want

00:24:53.270 --> 00:24:56.040
to know maybe a little bit
deeper, please post your

00:24:56.040 --> 00:24:57.410
questions on Moderator.

00:24:57.410 --> 00:24:59.930
The link is there on
screen right now.

00:24:59.930 --> 00:25:03.320
You can just go to Moderator
and post a few questions.

00:25:03.320 --> 00:25:05.430
And we'll take those questions
as we get towards the end of

00:25:05.430 --> 00:25:06.220
the session today.

00:25:06.220 --> 00:25:07.110
PAUL KINLAN: Yeah, that's
pretty cool.

00:25:07.110 --> 00:25:08.110
We've got one or two--

00:25:08.110 --> 00:25:10.510
PETE LEPAGE: Yeah, we got
a couple good ones.

00:25:10.510 --> 00:25:12.700
PAUL KINLAN: Which we will be
able to answer as well.

00:25:12.700 --> 00:25:13.590
They're going to be good.

00:25:13.590 --> 00:25:14.880
PETE LEPAGE: Absolutely.

00:25:14.880 --> 00:25:16.180
So stay tuned.

00:25:16.180 --> 00:25:17.430
PAUL KINLAN: Let's go
back to the code.

00:25:20.850 --> 00:25:23.190
I apologize, two
seconds, again.

00:25:23.190 --> 00:25:23.800
Hey.

00:25:23.800 --> 00:25:26.000
PETE LEPAGE: 1, 1,000,
2, 1,000.

00:25:26.000 --> 00:25:28.160
I'm going to give you trouble.

00:25:28.160 --> 00:25:29.050
PAUL KINLAN: Yeah, dude.

00:25:29.050 --> 00:25:29.600
I'm ready.

00:25:29.600 --> 00:25:30.480
Don't worry.

00:25:30.480 --> 00:25:33.010
PETE LEPAGE: All right,
all you then.

00:25:33.010 --> 00:25:34.280
PAUL KINLAN: I was adding
to the suspense.

00:25:34.280 --> 00:25:36.830
So we talked about it before,
socket.accept.

00:25:36.830 --> 00:25:40.534
accept takes a connection that's
come in, off the queue,

00:25:40.534 --> 00:25:41.940
and then allows you
to process it.

00:25:41.940 --> 00:25:44.170
So in theory, we
have this here.

00:25:44.170 --> 00:25:46.320
So we say, I need to accept the
connection that's coming

00:25:46.320 --> 00:25:49.990
from the particular socket
that we've created.

00:25:49.990 --> 00:25:51.700
And there's a call back
called onaccept.

00:25:51.700 --> 00:25:52.960
And we're going to jump
to onaccept now

00:25:52.960 --> 00:25:53.840
and fill that out.

00:25:53.840 --> 00:25:57.300
Because what actually happens
is kind of interesting.

00:25:57.300 --> 00:25:58.090
It's part of the API.

00:25:58.090 --> 00:26:00.080
And it's something that I found
a little bit confusing,

00:26:00.080 --> 00:26:01.970
when I first played with
it, is you can

00:26:01.970 --> 00:26:03.460
only call accept once.

00:26:03.460 --> 00:26:05.180
And you can only process
one request that's

00:26:05.180 --> 00:26:06.260
come in at a time.

00:26:06.260 --> 00:26:09.300
So it's very single threaded
in this sense.

00:26:09.300 --> 00:26:10.980
So if you're doing a whole lot
of processing and someone's

00:26:10.980 --> 00:26:14.250
uploaded a big file to your
socket, then what you should

00:26:14.250 --> 00:26:19.020
really do is try and delegate
that work off to a web worker

00:26:19.020 --> 00:26:21.600
or something similar to that,
very much like you do in Node,

00:26:21.600 --> 00:26:25.220
essentially, just maintain the
asychrononicity at least.

00:26:25.220 --> 00:26:27.990
onaccept is the call back that
happens when we know we've got

00:26:27.990 --> 00:26:29.160
some data that's come back in.

00:26:29.160 --> 00:26:31.710
So the very first time we do
this, there's going to be

00:26:31.710 --> 00:26:32.090
nothing happening.

00:26:32.090 --> 00:26:33.560
Because I haven't gone back
to my browser and

00:26:33.560 --> 00:26:35.620
actually made a request.

00:26:35.620 --> 00:26:38.390
When I do make a request,
onaccept will be called.

00:26:38.390 --> 00:26:40.950
And what we need to do is we
need to jump up to my previous

00:26:40.950 --> 00:26:43.180
window and start filling
this out.

00:26:43.180 --> 00:26:46.020
Now what we do here is,
actually, we read the data

00:26:46.020 --> 00:26:50.230
from the socket into
our application.

00:26:50.230 --> 00:26:52.120
I mean, we don't have to.

00:26:52.120 --> 00:26:52.770
But otherwise, it would
be a pretty rubbish

00:26:52.770 --> 00:26:53.410
application, right?

00:26:53.410 --> 00:26:55.640
So what we're going to do is
we're going to call a simple--

00:26:55.640 --> 00:26:56.850
and there's a lot
of code in here.

00:26:56.850 --> 00:27:00.020
So please follow along.

00:27:00.020 --> 00:27:00.960
It's going to be
a bit awkward.

00:27:00.960 --> 00:27:07.970
So acceptInfo.socketID
function readInfo.

00:27:07.970 --> 00:27:10.100
And this is where you're going
to see all the call backs that

00:27:10.100 --> 00:27:11.276
we mentioned earlier on.

00:27:11.276 --> 00:27:12.350
PETE LEPAGE: Oh goody.

00:27:12.350 --> 00:27:13.360
Oh goody.

00:27:13.360 --> 00:27:14.610
PAUL KINLAN: Yeah,
it's awesome.

00:27:14.610 --> 00:27:16.890
So what we've done here is, now
that we know that we've

00:27:16.890 --> 00:27:20.850
been called, a connection has
been made to our server, we

00:27:20.850 --> 00:27:22.960
say, we'll need to read
from the socket.

00:27:22.960 --> 00:27:26.400
Notice how we are using
acceptInfo socket, not

00:27:26.400 --> 00:27:27.980
socketInfo as the variable.

00:27:27.980 --> 00:27:31.370
This is because the actual
request that's come in

00:27:31.370 --> 00:27:33.640
basically isn't on the same
socket as the one that you're

00:27:33.640 --> 00:27:34.120
listening on.

00:27:34.120 --> 00:27:36.070
The way that underlined system
works is it delegates it back

00:27:36.070 --> 00:27:37.530
off to the system.

00:27:37.530 --> 00:27:39.330
And there's a separate channel
that enables you to

00:27:39.330 --> 00:27:40.990
communicate back
to the service.

00:27:40.990 --> 00:27:43.310
So we've got a different
socket.

00:27:43.310 --> 00:27:44.710
So that's fine.

00:27:44.710 --> 00:27:45.755
We'll read through it.

00:27:45.755 --> 00:27:46.740
We call a read.

00:27:46.740 --> 00:27:50.760
And, in theory, what you'd
see here now is--

00:27:50.760 --> 00:27:53.170
I'm just going to put
it in so we know--

00:27:53.170 --> 00:27:56.080
is you would see all the data
that's come back in.

00:27:56.080 --> 00:27:58.850
readInfo itself has got
a data property.

00:27:58.850 --> 00:28:01.610
So let's just get it off.

00:28:01.610 --> 00:28:03.460
Actually, let's convert
it to a string first.

00:28:03.460 --> 00:28:04.710
arrayBufferToString.

00:28:06.530 --> 00:28:09.040
And this is a function that
I've made myself.

00:28:09.040 --> 00:28:11.140
It's not in the call
library system.

00:28:11.140 --> 00:28:11.960
But there we go, right.

00:28:11.960 --> 00:28:15.595
So the idea behind this now is
that we've gone through, got

00:28:15.595 --> 00:28:16.710
the data out, called

00:28:16.710 --> 00:28:21.400
arrayBufferToString, which is here.

00:28:21.400 --> 00:28:22.770
We basically take the
array buffer,

00:28:22.770 --> 00:28:24.150
convert it to a string.

00:28:24.150 --> 00:28:26.960
And the reason why we
do this is because--

00:28:26.960 --> 00:28:27.690
wait for it--

00:28:27.690 --> 00:28:28.340
PETE LEPAGE: I'm waiting.

00:28:28.340 --> 00:28:29.930
I'm waiting.

00:28:29.930 --> 00:28:31.550
PAUL KINLAN: We need
to read from it.

00:28:31.550 --> 00:28:36.180
So what I do is I say-- yeah,
it's exciting-- indexOf.

00:28:36.180 --> 00:28:39.510
So we need to find the very
first part of the string.

00:28:39.510 --> 00:28:40.950
I'm going to put a
space in there,

00:28:40.950 --> 00:28:43.320
because it could be wrong.

00:28:43.320 --> 00:28:44.860
Equals 0.

00:28:44.860 --> 00:28:48.210
And this is basically the HTTP
header that we've got back in.

00:28:48.210 --> 00:28:49.840
So we are reading from
the request.

00:28:49.840 --> 00:28:52.160
We're assuming that it's
a HTTP request.

00:28:52.160 --> 00:28:55.440
When it is a HTTP request, the
very first set of characters

00:28:55.440 --> 00:28:58.450
in the string are the
actual method

00:28:58.450 --> 00:28:59.440
that's going to be called.

00:28:59.440 --> 00:29:03.070
Not the underlined method, but
the post, get, put, delete,

00:29:03.070 --> 00:29:04.720
all those types things.

00:29:04.720 --> 00:29:05.790
And in this case, we're
just going to look

00:29:05.790 --> 00:29:07.280
for the word, get.

00:29:07.280 --> 00:29:10.260
We're not going to handle
anything else.

00:29:10.260 --> 00:29:11.070
That's pretty cool.

00:29:11.070 --> 00:29:13.560
So if we get the word, get,
there, there's a strong

00:29:13.560 --> 00:29:18.370
likelihood, at least, that the
data is a HTTP request.

00:29:18.370 --> 00:29:19.920
So let's parse it a
little bit more.

00:29:19.920 --> 00:29:22.000
And I'm going to take a whole
lot of liberties with this.

00:29:24.640 --> 00:29:29.190
We're going to get the
end of the URI.

00:29:29.190 --> 00:29:31.370
So the thing that comes after
the get request--

00:29:31.370 --> 00:29:36.260
and I'm sorry for doing
an HTTP 101 here--

00:29:36.260 --> 00:29:39.430
is actually the URL that
you're fetching.

00:29:39.430 --> 00:29:42.830
So just substring uriEnd.

00:29:42.830 --> 00:29:44.120
So we're just going
to parse this out.

00:29:44.120 --> 00:29:46.790
And we're going to just assume
that it all works.

00:29:46.790 --> 00:29:51.690
And we're then going to get
the file from filesMap.

00:29:51.690 --> 00:29:52.590
That's what we said before.

00:29:52.590 --> 00:29:54.980
When we clicked on the
directory, like the file

00:29:54.980 --> 00:29:59.380
picker button we have
the ability

00:29:59.380 --> 00:30:00.140
to select the directory.

00:30:00.140 --> 00:30:02.910
We take all those files in that
directory and store them

00:30:02.910 --> 00:30:05.747
in a hash with the URL,
basically, of

00:30:05.747 --> 00:30:06.780
the local file system.

00:30:06.780 --> 00:30:08.730
And then we map that
on, using this.

00:30:08.730 --> 00:30:12.870
So what we'll see here is, if
a web request comes into our

00:30:12.870 --> 00:30:16.680
server, forward slash index
dot HTML, we'll see that.

00:30:16.680 --> 00:30:17.840
We'll get the URI out.

00:30:17.840 --> 00:30:20.665
And then we'll look for a file
called index dot HTML in our

00:30:20.665 --> 00:30:23.070
memory collection of files.

00:30:23.070 --> 00:30:23.840
Which is pretty cool.

00:30:23.840 --> 00:30:27.380
And then this is going to
look silly, because it

00:30:27.380 --> 00:30:28.170
doesn't exist yet.

00:30:28.170 --> 00:30:30.670
But write response is a function
that we've made.

00:30:33.350 --> 00:30:38.100
Info.socketId file.

00:30:38.100 --> 00:30:38.690
This is just a function
that we've made.

00:30:38.690 --> 00:30:41.050
And we're going to
go to it now.

00:30:41.050 --> 00:30:43.100
PETE LEPAGE: So before
you pop down there.

00:30:46.000 --> 00:30:48.830
Where you've got your file,
when you went to hit your

00:30:48.830 --> 00:30:51.050
semicolon, you actually
got an A in there, at

00:30:51.050 --> 00:30:52.470
the end of that line.

00:30:52.470 --> 00:30:53.430
PAUL KINLAN: Dude, thank
you very much.

00:30:53.430 --> 00:30:55.790
PETE LEPAGE: Wow,
now we got an R.

00:30:55.790 --> 00:30:56.430
PAUL KINLAN: It's gone now.

00:30:56.430 --> 00:30:56.770
It should be there.

00:30:56.770 --> 00:30:59.010
PETE LEPAGE: Now
write200Response.

00:30:59.010 --> 00:31:04.060
Now why is it write200Response
versus writeResponse?

00:31:04.060 --> 00:31:05.910
PAUL KINLAN: Basically, it was
just the way I decided to try

00:31:05.910 --> 00:31:07.000
and structure the application.

00:31:07.000 --> 00:31:09.500
I was going to say that, if I
can't find the file, I would

00:31:09.500 --> 00:31:13.790
try and write a 400 response,
going out.

00:31:13.790 --> 00:31:15.900
From the verbosity of it, it
made sense when I was looking

00:31:15.900 --> 00:31:18.520
at it, just to say
write200Response.

00:31:18.520 --> 00:31:21.350
writeResponse with a status code
would probably be better.

00:31:21.350 --> 00:31:22.370
PETE LEPAGE: Fair enough.

00:31:22.370 --> 00:31:22.980
OK.

00:31:22.980 --> 00:31:23.840
PAUL KINLAN: No, we
can refer to this.

00:31:23.840 --> 00:31:25.980
And if anyone wants to take the
code, fork it, and make it

00:31:25.980 --> 00:31:29.550
look a lot nicer, then
super-fine by me.

00:31:29.550 --> 00:31:30.950
PETE LEPAGE: That would
be super cool.

00:31:30.950 --> 00:31:32.260
PAUL KINLAN: This
is our function.

00:31:32.260 --> 00:31:33.530
We take the socketID.

00:31:33.530 --> 00:31:36.800
So the socketID, this is the
network socket the network

00:31:36.800 --> 00:31:39.960
port that we're going to write
back to the client, write back

00:31:39.960 --> 00:31:43.300
to the web browser
with the data on.

00:31:43.300 --> 00:31:45.000
So we have the file.

00:31:45.000 --> 00:31:46.170
We're going to work out
the contentType.

00:31:46.170 --> 00:31:48.660
Luckily the file object, in
a lot of cases, has the

00:31:48.660 --> 00:31:50.900
contentType on.

00:31:50.900 --> 00:31:52.990
I'd just assume that, if the
contentType doesn't exist,

00:31:52.990 --> 00:31:54.704
it's called text plain.

00:31:54.704 --> 00:31:56.560
That's probably not the best
assumption, but it was

00:31:56.560 --> 00:31:58.050
reasonable.

00:31:58.050 --> 00:32:01.020
contentLength, you're a good
web citizen if put the

00:32:01.020 --> 00:32:02.360
contentLength on.

00:32:02.360 --> 00:32:03.530
So we get the file size.

00:32:03.530 --> 00:32:05.870
So the actual size of the
file is stored in

00:32:05.870 --> 00:32:06.990
the file system object.

00:32:06.990 --> 00:32:08.070
It's pretty cool.

00:32:08.070 --> 00:32:09.600
And then we do this thing
called header.

00:32:09.600 --> 00:32:10.710
We make a header.

00:32:10.710 --> 00:32:12.670
And the reason why is because,
when you do a network

00:32:12.670 --> 00:32:15.330
response, you have to put a
HTTP header at the top.

00:32:15.330 --> 00:32:17.156
And then you also, at the
bottom, you have to then put

00:32:17.156 --> 00:32:17.990
the file contents.

00:32:17.990 --> 00:32:20.750
And the HTTP header basically
says what type of protocol

00:32:20.750 --> 00:32:23.620
you're using, whether
it's HTTP1, 1.1.

00:32:23.620 --> 00:32:27.640
The status code, 200
in this case--

00:32:27.640 --> 00:32:29.750
200 is success and
the word, OK.

00:32:29.750 --> 00:32:30.960
And then some extra
information, like

00:32:30.960 --> 00:32:32.940
contentLength and contentType.

00:32:32.940 --> 00:32:36.250
Now we're using the inverse
of a stringToArrayBuffer--

00:32:36.250 --> 00:32:37.815
oh sorry.

00:32:37.815 --> 00:32:39.270
PETE LEPAGE:arrayToStringBuffer.

00:32:39.270 --> 00:32:40.760
We're using stringToArrayBuffer.

00:32:40.760 --> 00:32:42.590
PAUL KINLAN: We're now making
an array buffer.

00:32:42.590 --> 00:32:44.620
So it's converting this single
string that we've got, which

00:32:44.620 --> 00:32:48.350
is a collection of the header
information, essentially.

00:32:48.350 --> 00:32:50.950
Two, we're take basically taking
that data, making an

00:32:50.950 --> 00:32:54.860
array buffer, so that we can
send that out to the client.

00:32:54.860 --> 00:32:57.450
Now the interesting thing, and
the way I've done this-- and

00:32:57.450 --> 00:32:59.530
it's probably not the best
way, again-- is I've just

00:32:59.530 --> 00:33:01.600
assumed that I want to
glob all the data--

00:33:01.600 --> 00:33:04.740
the header and the response--
into one write.

00:33:04.740 --> 00:33:05.710
I don't have to do that.

00:33:05.710 --> 00:33:08.490
I probably shouldn't
do that that way.

00:33:08.490 --> 00:33:10.740
Anyway you have an output
buffer, which is the

00:33:10.740 --> 00:33:13.760
combination of the HTTP header
and the actual file body

00:33:13.760 --> 00:33:16.530
itself, the raw file data that
we're going to pull back in.

00:33:16.530 --> 00:33:18.875
Now we have this.

00:33:18.875 --> 00:33:19.270
Excuse me.

00:33:19.270 --> 00:33:20.860
So we have the view.

00:33:20.860 --> 00:33:23.260
The view is basically just the
way that you can actually put

00:33:23.260 --> 00:33:24.680
data into an array buffer.

00:33:24.680 --> 00:33:26.610
You can't put data into an array
buffer directly, so we

00:33:26.610 --> 00:33:28.100
have to do some work.

00:33:28.100 --> 00:33:30.870
The array buffer itself
is the header length

00:33:30.870 --> 00:33:32.360
plus the file length.

00:33:32.360 --> 00:33:38.390
We put the header at the very
start of the array buffer,

00:33:38.390 --> 00:33:39.450
which is what you need.

00:33:39.450 --> 00:33:41.510
And then we need to put
the body at the end.

00:33:41.510 --> 00:33:43.180
Now the interesting thing
here is, this is the

00:33:43.180 --> 00:33:44.850
asynchronous bit again.

00:33:44.850 --> 00:33:49.940
You have to use the HTML5 file
reader API, because we've got

00:33:49.940 --> 00:33:50.740
a file object.

00:33:50.740 --> 00:33:52.460
We don't have access
to the bytes.

00:33:52.460 --> 00:33:54.510
We need to basically ask the
system to give us that

00:33:54.510 --> 00:33:55.540
information.

00:33:55.540 --> 00:33:58.930
So we use the file reader
API, in this case.

00:33:58.930 --> 00:34:02.150
It's one single call,
fileReader, listen to onload,

00:34:02.150 --> 00:34:03.914
so that we know that the file's
been loaded up and is

00:34:03.914 --> 00:34:06.485
all ready to go.

00:34:06.485 --> 00:34:09.350
And we then, finally say,
readAsArrayBuffer.

00:34:09.350 --> 00:34:12.010
So the file object can be
returned is an array buffer.

00:34:12.010 --> 00:34:15.260
And the idea behind what we're
going to do now is once the

00:34:15.260 --> 00:34:18.050
file data's come in, we're going
to stuff that into the

00:34:18.050 --> 00:34:21.080
array buffer itself, right at
the end, after the header.

00:34:21.080 --> 00:34:23.560
So we have this one big glob of
data that we're just going

00:34:23.560 --> 00:34:25.406
to send out to the client.

00:34:25.406 --> 00:34:28.980
PETE LEPAGE: So Paul, one of the
things, if someone wanted

00:34:28.980 --> 00:34:31.900
to refactor this, one way they
could do it, to make it

00:34:31.900 --> 00:34:35.449
potentially a much faster web
server, is on start up, when

00:34:35.449 --> 00:34:39.489
it reads that directory,
depending on how many files

00:34:39.489 --> 00:34:42.349
there are, it could load all
of those files into memory.

00:34:42.349 --> 00:34:43.230
PAUL KINLAN: Yeah.

00:34:43.230 --> 00:34:45.159
PETE LEPAGE: And then just keep
them there, so that it

00:34:45.159 --> 00:34:48.830
just always was able to
immediately respond with them

00:34:48.830 --> 00:34:49.420
and have them--

00:34:49.420 --> 00:34:51.389
PAUL KINLAN: Yeah, so I mean it
seems a little heavyweight

00:34:51.389 --> 00:34:53.420
to do what we're doing
right now, honestly.

00:34:53.420 --> 00:34:54.989
But it's just there
to show the point.

00:34:54.989 --> 00:34:55.929
PETE LEPAGE: Yep.

00:34:55.929 --> 00:34:57.060
PAUL KINLAN: But the other
thing, as well, is you can

00:34:57.060 --> 00:34:59.440
actually do two socket writes,
sending the data

00:34:59.440 --> 00:35:01.260
back over the socket.

00:35:01.260 --> 00:35:02.960
You could do two writes.

00:35:02.960 --> 00:35:03.810
You could write the header
and then write

00:35:03.810 --> 00:35:04.490
the body just after.

00:35:04.490 --> 00:35:06.450
That's like two asynchronous
calls.

00:35:06.450 --> 00:35:08.610
It's a little bit harder to
orchestrate, but then we don't

00:35:08.610 --> 00:35:11.530
have to block the user interface
on trying to

00:35:11.530 --> 00:35:14.250
construct these two larger
objects together.

00:35:14.250 --> 00:35:16.050
PETE LEPAGE: Though admittedly,
in this app, there

00:35:16.050 --> 00:35:18.000
isn't much of a user
interface.

00:35:18.000 --> 00:35:20.310
So blocking on that would
not be a huge deal.

00:35:20.310 --> 00:35:22.180
But you still don't
want to do that.

00:35:22.180 --> 00:35:23.850
PAUL KINLAN: Yeah, exactly.

00:35:23.850 --> 00:35:26.670
So let's go and see where
we can go from here.

00:35:26.670 --> 00:35:28.720
So we want to do the
socket.write.

00:35:28.720 --> 00:35:31.040
So we're going to write to the
socket, write the data from

00:35:31.040 --> 00:35:35.490
the file system API to
the web, essentially.

00:35:35.490 --> 00:35:36.472
It's pretty cool.

00:35:36.472 --> 00:35:36.840
PETE LEPAGE: Cool.

00:35:36.840 --> 00:35:40.130
PAUL KINLAN: And this should
be simple socketId

00:35:40.130 --> 00:35:42.800
outputBuffer--

00:35:42.800 --> 00:35:44.970
be careful how I spell
that one out--

00:35:44.970 --> 00:35:48.575
function writeInfo.

00:35:48.575 --> 00:35:52.270
And again, another nice,
very cute call back.

00:35:52.270 --> 00:35:55.555
PETE LEPAGE: Ah, got to
love those call backs.

00:35:55.555 --> 00:35:57.655
PAUL KINLAN: I believe
that is not needed.

00:36:00.730 --> 00:36:01.990
And in theory, that's
it, right?

00:36:01.990 --> 00:36:03.590
But we want a little bit
more information.

00:36:03.590 --> 00:36:06.820
So we've taken the data and
we constructed the header

00:36:06.820 --> 00:36:08.530
response and also the
body response.

00:36:08.530 --> 00:36:10.990
And we've written it
out in one go.

00:36:10.990 --> 00:36:13.970
To be a good citizen, actually,
what we need to do

00:36:13.970 --> 00:36:15.660
is actually destroy
the socket.

00:36:15.660 --> 00:36:19.200
So one of the things I found
out, when I was doing this is

00:36:19.200 --> 00:36:21.230
the number of sockets, if you
don't destroy them, once

00:36:21.230 --> 00:36:23.160
you've finished the connection,
and you've written

00:36:23.160 --> 00:36:24.473
the data out, and you're happy
that the client's got the

00:36:24.473 --> 00:36:28.294
data, the application will
probably crash at some point

00:36:28.294 --> 00:36:29.590
in the future.

00:36:29.590 --> 00:36:30.400
PETE LEPAGE: Yeah, because
there are a

00:36:30.400 --> 00:36:32.160
limited number of sockets.

00:36:32.160 --> 00:36:32.890
PAUL KINLAN: Yeah,
essentially.

00:36:32.890 --> 00:36:34.480
PETE LEPAGE: Now, do you
need to destroy and

00:36:34.480 --> 00:36:36.630
close or just destroy?

00:36:36.630 --> 00:36:37.360
PAUL KINLAN: You might
need to close.

00:36:37.360 --> 00:36:39.670
I just did destroy, and
it seems to work.

00:36:39.670 --> 00:36:41.280
I should probably be a
better citizen and

00:36:41.280 --> 00:36:42.330
also close it as well.

00:36:42.330 --> 00:36:46.010
But what I'm doing here, this
is the thing that got me

00:36:46.010 --> 00:36:47.835
before when I was
starting this.

00:36:47.835 --> 00:36:50.283
Because overall, it took me
about an hour and a half to

00:36:50.283 --> 00:36:51.180
make this whole application.

00:36:51.180 --> 00:36:52.890
It's pretty cool.

00:36:52.890 --> 00:36:55.720
socket.accept, you need to
call that again, because

00:36:55.720 --> 00:36:56.740
you've handled the request.

00:36:56.740 --> 00:36:58.870
You basically need to tell the
system that you want to pick

00:36:58.870 --> 00:37:01.670
off the next request again.

00:37:01.670 --> 00:37:03.940
Because you can only have
one of those in flight.

00:37:03.940 --> 00:37:06.940
I chose to do it in this type of
queue here, because you can

00:37:06.940 --> 00:37:07.570
only have one in flight.

00:37:07.570 --> 00:37:10.440
I need to know that what we've
done has completed

00:37:10.440 --> 00:37:13.350
successfully, in which
case it's the write.

00:37:13.350 --> 00:37:15.270
And, in theory--

00:37:15.270 --> 00:37:16.300
oh, tell you what.

00:37:16.300 --> 00:37:17.300
That should be it.

00:37:17.300 --> 00:37:18.080
Let me just go to the end.

00:37:18.080 --> 00:37:19.600
I know there's a Stop button.

00:37:19.600 --> 00:37:22.130
We should also do socket.destroy
to kill the

00:37:22.130 --> 00:37:24.735
server socket.

00:37:24.735 --> 00:37:25.985
oh, info.socketId.

00:37:30.370 --> 00:37:34.350
And that is all we actually
need to do.

00:37:34.350 --> 00:37:35.610
We have our server.

00:37:35.610 --> 00:37:36.040
Shall we test it?

00:37:36.040 --> 00:37:37.400
PETE LEPAGE: Let's test it.

00:37:37.400 --> 00:37:39.000
PAUL KINLAN: Should
we test it live?

00:37:39.000 --> 00:37:41.160
PETE LEPAGE: Absolutely.

00:37:41.160 --> 00:37:46.580
PAUL KINLAN: So I have an
extension web server file.

00:37:46.580 --> 00:37:48.462
It's not that one.

00:37:48.462 --> 00:37:49.710
And it's not that one.

00:37:49.710 --> 00:37:50.300
That was my test.

00:37:50.300 --> 00:37:52.870
That was one of my
other tests.

00:37:52.870 --> 00:37:53.680
Hey, funny.

00:37:53.680 --> 00:37:55.560
PETE LEPAGE: There you go.

00:37:55.560 --> 00:37:57.130
PAUL KINLAN: So it hasn't
crashed yet.

00:37:57.130 --> 00:37:59.890
PETE LEPAGE: Sweet.

00:37:59.890 --> 00:38:01.762
PAUL KINLAN: Launch.

00:38:01.762 --> 00:38:04.175
Shall we see if there's
any errors?

00:38:04.175 --> 00:38:06.990
No errors so far.

00:38:06.990 --> 00:38:09.495
Choose files.

00:38:09.495 --> 00:38:11.470
Choose that app directory.

00:38:11.470 --> 00:38:12.370
PETE LEPAGE: Nice.

00:38:12.370 --> 00:38:13.330
Nice.

00:38:13.330 --> 00:38:14.570
PAUL KINLAN: No errors.

00:38:14.570 --> 00:38:15.620
Start.

00:38:15.620 --> 00:38:16.590
No errors.

00:38:16.590 --> 00:38:17.480
Oh.

00:38:17.480 --> 00:38:18.340
PETE LEPAGE: No whammies,
no whammies,

00:38:18.340 --> 00:38:19.590
no whammy, no whammy.

00:38:21.760 --> 00:38:27.032
PAUL KINLAN: 81, because--

00:38:27.032 --> 00:38:28.910
yay!

00:38:28.910 --> 00:38:29.860
It worked.

00:38:29.860 --> 00:38:30.860
PETE LEPAGE: Congratulations.

00:38:30.860 --> 00:38:32.350
Nice job, sir.

00:38:32.350 --> 00:38:33.600
PAUL KINLAN: Oh my.

00:38:36.490 --> 00:38:37.010
That's it, right.

00:38:37.010 --> 00:38:40.110
That's the whole basic premise
of what we're trying to do

00:38:40.110 --> 00:38:42.100
with this, in like 30 minutes.

00:38:42.100 --> 00:38:43.320
And we've gone through this.

00:38:43.320 --> 00:38:45.210
And we talked an obviously
long time here.

00:38:45.210 --> 00:38:48.980
We built a basic server that
allows you to serve data from

00:38:48.980 --> 00:38:52.200
your local machine, your local
Chrome OS box, your MacBook,

00:38:52.200 --> 00:38:55.030
all those types of things, serve
it directly to the user.

00:38:55.030 --> 00:38:59.070
Offline, online, however you
want to do it, you can do it.

00:38:59.070 --> 00:39:00.330
Obviously, it's a very
simple server.

00:39:00.330 --> 00:39:01.355
It only handles get requests.

00:39:01.355 --> 00:39:03.360
It doesn't do pokes and all
that type of stuff.

00:39:03.360 --> 00:39:04.750
But you can see what's
going to happen.

00:39:04.750 --> 00:39:06.740
And like I said, if you can
get some of the Node based

00:39:06.740 --> 00:39:09.320
spaces, like the server work,
a lot of people have already

00:39:09.320 --> 00:39:10.805
done in that whole ecosystem.

00:39:10.805 --> 00:39:11.560
PETE LEPAGE: Yeah.

00:39:11.560 --> 00:39:13.070
PAUL KINLAN: I know there's
quite a bit of mapping that

00:39:13.070 --> 00:39:15.010
needs to be done, because
there's a buffer, which is

00:39:15.010 --> 00:39:16.810
different to our array buffer
and all that type of stuff.

00:39:16.810 --> 00:39:19.855
So there needs to be some
marshalling and munging in

00:39:19.855 --> 00:39:22.072
between the two bits there.

00:39:22.072 --> 00:39:24.320
And I think it's one of the
things, like it would be so

00:39:24.320 --> 00:39:27.920
cool if you could test your
entire stack without

00:39:27.920 --> 00:39:30.890
necessarily having to have
Node.js sever installed.

00:39:30.890 --> 00:39:33.520
On your MacBook Pro and your
Windows machine, you'll have

00:39:33.520 --> 00:39:34.020
that on anyway.

00:39:34.020 --> 00:39:36.000
But if you've got a Chrome OS
box, right now, it's like--

00:39:36.000 --> 00:39:36.290
PETE LEPAGE: Right.

00:39:36.290 --> 00:39:37.220
PAUL KINLAN: That would
be pretty sweet.

00:39:37.220 --> 00:39:40.250
You could start to test out your
Node based application,

00:39:40.250 --> 00:39:43.140
inside the browser, from
your Chrome OS machine.

00:39:43.140 --> 00:39:46.060
PETE LEPAGE: Or you could,
effectively, go and just do

00:39:46.060 --> 00:39:49.955
any of the development that you
want to do on your Chrome

00:39:49.955 --> 00:39:53.150
Book and have a server
running locally.

00:39:53.150 --> 00:39:55.760
So I just put the URL
for the network

00:39:55.760 --> 00:39:57.310
documentation up on screen.

00:39:57.310 --> 00:39:59.530
So if you want to dive into this
a little bit deeper, you

00:39:59.530 --> 00:40:02.070
can see the URL there.

00:40:02.070 --> 00:40:04.340
And that'll take you to the
Chrome apps documentation,

00:40:04.340 --> 00:40:08.830
where all of this stuff goes
into much more detail, all of

00:40:08.830 --> 00:40:11.440
the different APIs the connect,
the destroy, the

00:40:11.440 --> 00:40:14.690
close, all of those fun
things that you do

00:40:14.690 --> 00:40:16.530
need to know about.

00:40:16.530 --> 00:40:17.280
PAUL KINLAN: The--

00:40:17.280 --> 00:40:17.930
I'm sorry.

00:40:17.930 --> 00:40:19.170
PETE LEPAGE: No, go ahead.

00:40:19.170 --> 00:40:20.730
PAUL KINLAN: Yeah, the thing I'd
just like to say is that

00:40:20.730 --> 00:40:21.570
this API is pretty cool.

00:40:21.570 --> 00:40:22.900
It's very powerful.

00:40:22.900 --> 00:40:24.350
It's something that we've
not seen inside

00:40:24.350 --> 00:40:26.490
Chrome before, at least.

00:40:26.490 --> 00:40:29.240
But the thing for me is it's
going to enable so

00:40:29.240 --> 00:40:30.010
many more use cases.

00:40:30.010 --> 00:40:31.070
It's going to be really cool.

00:40:31.070 --> 00:40:31.760
PETE LEPAGE: Yeah.

00:40:31.760 --> 00:40:33.960
PAUL KINLAN: Personally, I'd
like more high level APIs.

00:40:33.960 --> 00:40:34.450
PETE LEPAGE: Yep.

00:40:34.450 --> 00:40:36.390
PAUL KINLAN: So if someone could
make like and FTP API or

00:40:36.390 --> 00:40:39.950
DNS API and all those different
types of APIs that

00:40:39.950 --> 00:40:41.790
other developers can just use
and say, you know what?

00:40:41.790 --> 00:40:44.220
I want to connect to an FTP
client or an FTP service.

00:40:44.220 --> 00:40:46.800
Or I want to make it
my own FTP service.

00:40:46.800 --> 00:40:47.510
And it just works.

00:40:47.510 --> 00:40:47.880
PETE LEPAGE: Abolutely.

00:40:47.880 --> 00:40:48.715
PAUL KINLAN: I'd love
that to happen.

00:40:48.715 --> 00:40:50.030
That would be absolutely
brilliant.

00:40:50.030 --> 00:40:52.760
PETE LEPAGE: So actually that's
a perfect segue into

00:40:52.760 --> 00:40:53.240
some of the questions.

00:40:53.240 --> 00:40:56.920
Because one of the first
questions that's in there is,

00:40:56.920 --> 00:41:00.240
could you summarize, at a high
level, what the new use cases

00:41:00.240 --> 00:41:03.010
you see in enabling
in our apps are?

00:41:03.010 --> 00:41:05.650
Any particular use cases
that you want to see?

00:41:05.650 --> 00:41:06.020
PAUL KINLAN: Yeah.

00:41:06.020 --> 00:41:08.980
PETE LEPAGE: So I know for me,
there's a couple that I've

00:41:08.980 --> 00:41:11.090
been playing with lately.

00:41:11.090 --> 00:41:14.550
Things like there's a little box
that you can buy called an

00:41:14.550 --> 00:41:17.100
IP to IR converter.

00:41:17.100 --> 00:41:18.180
And I've just been playing
with this.

00:41:18.180 --> 00:41:19.480
I know it's completely dorky.

00:41:22.050 --> 00:41:23.530
So it plugs into your
network port.

00:41:23.530 --> 00:41:26.310
And then it's got IR
blasters on it.

00:41:26.310 --> 00:41:30.630
So you can then use that to
control your TV, your anything

00:41:30.630 --> 00:41:32.800
that's controlled via IR.

00:41:32.800 --> 00:41:37.130
So I'm working on writing a
little Chrome app that will

00:41:37.130 --> 00:41:39.680
allow me to turn my air
conditioner on and off, will

00:41:39.680 --> 00:41:43.190
allow me to turn the TV on and
off, do all sorts of crazy

00:41:43.190 --> 00:41:44.180
little things like that.

00:41:44.180 --> 00:41:45.910
So that's one case.

00:41:45.910 --> 00:41:49.650
But other things are being able
to write servers, like we

00:41:49.650 --> 00:41:54.240
talked about, being able to
go and communicate with

00:41:54.240 --> 00:41:56.440
appliances that you normally
wouldn't be able to

00:41:56.440 --> 00:41:57.680
communicate with.

00:41:57.680 --> 00:42:00.570
What are some of the ones that
you're excited about, Paul?

00:42:00.570 --> 00:42:02.395
PAUL KINLAN: Use cases
or appliances?

00:42:02.395 --> 00:42:03.150
PETE LEPAGE: Both.

00:42:03.150 --> 00:42:03.870
PAUL KINLAN: Both.

00:42:03.870 --> 00:42:05.750
Appliances, ah, so many.

00:42:05.750 --> 00:42:07.730
I really like the idea--
so we got a demo

00:42:07.730 --> 00:42:08.570
for the Media Center.

00:42:08.570 --> 00:42:09.310
PETE LEPAGE: Yep.

00:42:09.310 --> 00:42:10.920
PAUL KINLAN: I want to be able
to access all my media around

00:42:10.920 --> 00:42:13.230
my house, brings into
my Chrome app.

00:42:13.230 --> 00:42:16.130
And if I go on a plane, I can
just download it straight to

00:42:16.130 --> 00:42:17.850
my Chrome Book and still
play and listen to it.

00:42:17.850 --> 00:42:18.770
It's pretty cool.

00:42:18.770 --> 00:42:19.420
So we've got that
type of demo.

00:42:19.420 --> 00:42:22.517
That type of interaction is
something you just don't get

00:42:22.517 --> 00:42:23.290
in the browser, right?

00:42:23.290 --> 00:42:23.550
PETE LEPAGE: Yeah.

00:42:23.550 --> 00:42:23.810
PAUL KINLAN: Right now.

00:42:23.810 --> 00:42:25.230
And it's pretty cool.

00:42:25.230 --> 00:42:27.000
Some of the other stuff, so
services, in an actual way,

00:42:27.000 --> 00:42:28.430
this is important for me.

00:42:28.430 --> 00:42:31.495
You know, literally, I want us
to be able to build services

00:42:31.495 --> 00:42:34.390
and services in our
applications.

00:42:34.390 --> 00:42:36.625
I think one of the questions
is I should've built a Bit

00:42:36.625 --> 00:42:37.540
Torrent client.

00:42:37.540 --> 00:42:38.750
Yeah, we can build a
Bit Torrent client.

00:42:38.750 --> 00:42:40.170
I just don't know
how to do it.

00:42:40.170 --> 00:42:41.415
I don't know the protocol.

00:42:41.415 --> 00:42:44.580
It probably would've been a
bit longer than this talk.

00:42:44.580 --> 00:42:46.370
But yeah, those are the types of
things that we are enabled

00:42:46.370 --> 00:42:48.300
to do now, in the sense
that we can have

00:42:48.300 --> 00:42:49.200
a Bit Torrent client.

00:42:49.200 --> 00:42:51.670
And you could, in theory, just
open ports that you need to

00:42:51.670 --> 00:42:54.690
listen to the requests coming in
to share the data back out.

00:42:54.690 --> 00:42:57.310
And so you could quite easily do
it-- well, sort of easily.

00:42:57.310 --> 00:42:59.026
The API is there for you
to be able do that.

00:42:59.026 --> 00:43:00.780
That would be pretty cool.

00:43:00.780 --> 00:43:04.220
FTP services, FTP servers,
FTP clients.

00:43:04.220 --> 00:43:05.940
You know, there's so many people
who still actually use

00:43:05.940 --> 00:43:07.880
FTP, a lot of web developers
who use FTP.

00:43:07.880 --> 00:43:08.150
PETE LEPAGE: Absolutely.

00:43:08.150 --> 00:43:11.630
PAUL KINLAN: Not even FTPS, just
plain FTP to get the data

00:43:11.630 --> 00:43:13.890
around places and up
on the web host,

00:43:13.890 --> 00:43:14.470
those types of things.

00:43:14.470 --> 00:43:15.040
PETE LEPAGE: Yep.

00:43:15.040 --> 00:43:16.110
PAUL KINLAN: I was actually
thinking it might have been

00:43:16.110 --> 00:43:18.150
cool for like a cURL
on the web.

00:43:18.150 --> 00:43:20.020
You always see these things,
like cURL on the web, where

00:43:20.020 --> 00:43:24.810
you don't serve it, necessarily,
but like a normal

00:43:24.810 --> 00:43:25.990
client request.

00:43:25.990 --> 00:43:28.650
Just debug the HTTP
requests, without

00:43:28.650 --> 00:43:29.610
having to go into DevTools.

00:43:29.610 --> 00:43:30.910
You can just put it all in.

00:43:30.910 --> 00:43:32.600
And you don't need the remote
server to do it.

00:43:32.600 --> 00:43:34.040
You can do all type of stuff.

00:43:34.040 --> 00:43:36.100
The interesting thing, we don't
have any access to the

00:43:36.100 --> 00:43:38.180
really, really low layers
of the API.

00:43:38.180 --> 00:43:39.260
So you can't do pings.

00:43:39.260 --> 00:43:41.050
Like [INAUDIBLE] stuff,
you can't do.

00:43:41.050 --> 00:43:41.500
PETE LEPAGE: OK.

00:43:41.500 --> 00:43:43.700
PAUL KINLAN: But
you can do DNS.

00:43:43.700 --> 00:43:45.750
DNS clients, I want a whole load
of APIs available, high

00:43:45.750 --> 00:43:47.520
level APIs available.

00:43:47.520 --> 00:43:49.660
Let me just fire off
a DNS request or a

00:43:49.660 --> 00:43:50.510
network time request.

00:43:50.510 --> 00:43:50.770
PETE LEPAGE: Yeah.

00:43:50.770 --> 00:43:52.520
PAUL KINLAN: And all these types
of things would be cool.

00:43:52.520 --> 00:43:52.620
PETE LEPAGE: Yeah.

00:43:52.620 --> 00:43:53.730
And then we can build
some really cool

00:43:53.730 --> 00:43:55.200
applications on it.

00:43:55.200 --> 00:43:56.895
The first one that always comes
to mind-- and this is I

00:43:56.895 --> 00:43:59.190
think why we did the web
developer, kind of the web

00:43:59.190 --> 00:44:02.040
server, is because this is
something web developers want

00:44:02.040 --> 00:44:03.610
to be able to do on their
Chrome Books.

00:44:03.610 --> 00:44:04.490
PETE LEPAGE: Absolutely.

00:44:04.490 --> 00:44:05.440
PAUL KINLAN: So I think
we can enable that.

00:44:05.440 --> 00:44:07.290
And it would be pretty cool if
someone like Cloud Nine or

00:44:07.290 --> 00:44:09.952
someone else comes along and
says, yeah, we can do that

00:44:09.952 --> 00:44:10.260
while you're offline.

00:44:10.260 --> 00:44:10.535
That would be cool.

00:44:10.535 --> 00:44:12.880
PETE LEPAGE: We'll pop that
into our development

00:44:12.880 --> 00:44:13.680
environment.

00:44:13.680 --> 00:44:19.550
So Louise, from Phoenix, wants
to know is there a way to do a

00:44:19.550 --> 00:44:23.540
broadcast to find other servers
to use this for

00:44:23.540 --> 00:44:26.240
LAN-based HTML5 game servers?

00:44:26.240 --> 00:44:28.330
And the answer is, yes.

00:44:28.330 --> 00:44:31.800
Right now, there's a bug
with UDP listen on

00:44:31.800 --> 00:44:32.920
the broadcast port.

00:44:32.920 --> 00:44:34.680
So that's not going to work.

00:44:34.680 --> 00:44:37.530
And the engineers are aware
of that, and they're

00:44:37.530 --> 00:44:38.910
looking into that one.

00:44:38.910 --> 00:44:43.520
But you can, certainly, once
that gets fixed, you'll be

00:44:43.520 --> 00:44:49.690
able to listen for UDP
broadcasts sent out.

00:44:49.690 --> 00:44:52.600
PAUL KINLAN: Yeah, our Media
Gallery sample on GitHub--

00:44:52.600 --> 00:44:52.940
PETE LEPAGE: Yep.

00:44:52.940 --> 00:44:54.110
That actually does that
type of thing.

00:44:54.110 --> 00:44:56.600
But it's a little bit broken
at the moment.

00:44:56.600 --> 00:44:59.123
The thing it does, it basically
fires off of, I

00:44:59.123 --> 00:45:02.520
think, it's 239.245.255's
address.

00:45:02.520 --> 00:45:02.775
PETE LEPAGE: Yeah.

00:45:02.775 --> 00:45:04.345
PAUL KINLAN: Which is like the
UDP broadcast, essentially,

00:45:04.345 --> 00:45:05.595
for DNLA discovery.

00:45:08.470 --> 00:45:10.230
And then basically, you
will fire that off.

00:45:10.230 --> 00:45:12.070
That's fired and you can do
the broadcast, but at the

00:45:12.070 --> 00:45:13.900
other end, you need to
be able to listen.

00:45:13.900 --> 00:45:17.370
And like Pete said,
that API did work.

00:45:17.370 --> 00:45:19.240
But I think someone stopped
working recently.

00:45:19.240 --> 00:45:20.730
But should be able to find--

00:45:20.730 --> 00:45:24.590
do a UDP bind to port 0 and
then receive all these

00:45:24.590 --> 00:45:25.380
responses back in.

00:45:25.380 --> 00:45:25.870
PETE LEPAGE: Yeah.

00:45:25.870 --> 00:45:27.430
PAUL KINLAN: And that
should all work.

00:45:27.430 --> 00:45:31.370
PETE LEPAGE: So we've got
another question of, how many

00:45:31.370 --> 00:45:33.060
requests can it handle
at a time?

00:45:33.060 --> 00:45:37.060
If you have to destroy and start
accepting again, does

00:45:37.060 --> 00:45:41.330
that mean you can only accept
one request at a time?

00:45:41.330 --> 00:45:43.170
PAUL KINLAN: Yes is the answer
right now, only one

00:45:43.170 --> 00:45:44.370
request at a time.

00:45:44.370 --> 00:45:46.710
But if you look at the way Node
works, its relatively

00:45:46.710 --> 00:45:47.410
similar, right?

00:45:47.410 --> 00:45:49.470
I mean Node only processes
one request.

00:45:49.470 --> 00:45:51.920
It trys to then delegate the
rest of the functionality to

00:45:51.920 --> 00:45:54.680
other asynchronous parts of
the system, then handle

00:45:54.680 --> 00:45:56.460
responses that way.

00:45:56.460 --> 00:45:58.830
And if you look at the Python
Tornado server, it was a

00:45:58.830 --> 00:45:59.340
similar thing.

00:45:59.340 --> 00:46:01.750
You could only handle one
request at a time coming in.

00:46:01.750 --> 00:46:04.115
So yeah, right now, that's
the only way you

00:46:04.115 --> 00:46:05.230
can do it just yet.

00:46:05.230 --> 00:46:07.910
The idea is that you would
take the request.

00:46:07.910 --> 00:46:10.070
And you'd background it.

00:46:10.070 --> 00:46:11.950
I mean all these APIs
are asynchronous.

00:46:11.950 --> 00:46:14.130
So we might actually be
able to take multiple

00:46:14.130 --> 00:46:17.170
ones, earlier on.

00:46:17.170 --> 00:46:19.460
I'm trying to think how
the accept works now.

00:46:19.460 --> 00:46:21.310
I haven't actually tested it
with trying to delegate these,

00:46:21.310 --> 00:46:23.110
like finish the accept
off really early.

00:46:23.110 --> 00:46:25.370
So just say, you know what, we
finished with the accept, go

00:46:25.370 --> 00:46:26.120
off and do whatever you want.

00:46:26.120 --> 00:46:26.760
PETE LEPAGE: Yep.

00:46:26.760 --> 00:46:27.880
PAUL KINLAN: I haven't
tried that just yet.

00:46:27.880 --> 00:46:30.760
But right now it's
one at a time.

00:46:30.760 --> 00:46:32.750
It's pretty speedy for what
we're trying to do as basic

00:46:32.750 --> 00:46:34.000
file serving.

00:46:35.720 --> 00:46:37.560
PETE LEPAGE: This is something
that I think works perfectly

00:46:37.560 --> 00:46:40.790
for a development environment
or a little test environment

00:46:40.790 --> 00:46:45.620
or maybe something you want to
write for controlling of an

00:46:45.620 --> 00:46:49.850
application like the IP to IR
controller, where you're only

00:46:49.850 --> 00:46:51.970
going to have a couple people
connecting to it at any time.

00:46:51.970 --> 00:46:53.880
You're not going to have
the entire world.

00:46:53.880 --> 00:46:58.280
It's not designed, in this
particular case, to scale.

00:46:58.280 --> 00:47:01.530
Now you absolutely could write
scale with this stuff.

00:47:01.530 --> 00:47:05.090
But the way we've written
it won't scale well.

00:47:05.090 --> 00:47:06.450
PAUL KINLAN: Yeah.

00:47:06.450 --> 00:47:07.825
The way I've written this
application it probably won't

00:47:07.825 --> 00:47:10.070
scale well at all.

00:47:10.070 --> 00:47:16.190
I think it's a very
general API.

00:47:16.190 --> 00:47:17.880
It's the POSIX socket
API essentially.

00:47:17.880 --> 00:47:20.850
So we can build systems that
scale quite easily.

00:47:20.850 --> 00:47:23.010
This literally landed
last week.

00:47:23.010 --> 00:47:25.490
And what we're trying to do is
start off the conversation

00:47:25.490 --> 00:47:28.000
about getting developers
excited about this API.

00:47:28.000 --> 00:47:30.210
And then we'll start to build
out the patterns and practices

00:47:30.210 --> 00:47:33.710
about how this should actually
be managed, from the

00:47:33.710 --> 00:47:35.890
application layer, if
that makes sense.

00:47:35.890 --> 00:47:36.760
So we're still early on.

00:47:36.760 --> 00:47:38.890
And if you guys want to play
with it, you just email me

00:47:38.890 --> 00:47:43.300
PaulKinlan@Google or catch
me pm Google+ or Twitter.

00:47:43.300 --> 00:47:46.100
And we'll just try and do
another show where we'll

00:47:46.100 --> 00:47:48.300
promote some of these things,
some of the stuff

00:47:48.300 --> 00:47:49.100
that you do as well.

00:47:49.100 --> 00:47:50.020
So that would be pretty cool.

00:47:50.020 --> 00:47:51.980
But we need to know how you
want to use these things.

00:47:51.980 --> 00:47:54.082
And the only way we'll know that
is by getting you guys to

00:47:54.082 --> 00:47:54.490
experiment.

00:47:54.490 --> 00:47:55.010
PETE LEPAGE: Yeah.

00:47:55.010 --> 00:47:57.930
PAUL KINLAN: So I encourage
everyone to play.

00:47:57.930 --> 00:47:58.840
PETE LEPAGE: Yep.

00:47:58.840 --> 00:48:01.450
So we've got time for,
I think, about

00:48:01.450 --> 00:48:04.760
one or two more questions.

00:48:04.760 --> 00:48:08.540
Question was, does this work
over the internet?

00:48:08.540 --> 00:48:10.230
Yeah, it absolutely would.

00:48:10.230 --> 00:48:14.190
The one thing you have to be
aware of is that the network

00:48:14.190 --> 00:48:17.250
socket that you're listening on
has to be connected to an

00:48:17.250 --> 00:48:18.290
internet port, right.

00:48:18.290 --> 00:48:22.660
So in our particular case, we're
listening to 127.0.0.1.

00:48:22.660 --> 00:48:25.640
So we're listening for
our own loop back.

00:48:25.640 --> 00:48:29.160
But Paul could have said hey,
what's the IP address on my

00:48:29.160 --> 00:48:30.550
network port.

00:48:30.550 --> 00:48:32.080
And I want to listen on that.

00:48:32.080 --> 00:48:35.200
And then I could have, from here
in New York, connected to

00:48:35.200 --> 00:48:37.280
him and been able to
listen to that.

00:48:37.280 --> 00:48:42.630
But I would have had to been
able to get to his IP address.

00:48:42.630 --> 00:48:44.504
PAUL KINLAN: It's the same as
just general networking, so it

00:48:44.504 --> 00:48:46.480
should be fine.

00:48:46.480 --> 00:48:47.310
PETE LEPAGE: Cool.

00:48:47.310 --> 00:48:48.905
PAUL KINLAN: Yeah.

00:48:48.905 --> 00:48:50.640
Can we do one more question
or are we over time?

00:48:50.640 --> 00:48:51.370
I think we're over time
now, aren't we?

00:48:51.370 --> 00:48:52.910
PETE LEPAGE: Yeah, I think we're
a little bit over time.

00:48:52.910 --> 00:48:56.370
So with that, I want to say
thanks to Paul for joining me.

00:48:56.370 --> 00:48:59.270
And thank you guys for
all joining us.

00:48:59.270 --> 00:49:01.140
We'll be back next
week with another

00:49:01.140 --> 00:49:04.800
installment of Chrome apps.

00:49:04.800 --> 00:49:06.830
If there are things you want to
hear about, things you want

00:49:06.830 --> 00:49:10.030
us to cover in more depth,
please be sure to reach out to

00:49:10.030 --> 00:49:13.870
us, either through our own
Google+ pages-- i'm Pete

00:49:13.870 --> 00:49:16.460
LePage or you can reach
to Paul Kinlan.

00:49:16.460 --> 00:49:21.260
Or leave a comment in one of
our Google+ pages for the

00:49:21.260 --> 00:49:22.650
Chrome developers.

00:49:22.650 --> 00:49:25.080
So with that, Paul, I think
we should try for

00:49:25.080 --> 00:49:27.350
another high five.

00:49:27.350 --> 00:49:28.040
All right, ready?

00:49:28.040 --> 00:49:29.020
PAUL KINLAN: Three, two, one.

00:49:29.020 --> 00:49:29.820
PETE LEPAGE: Two, one, go.

00:49:29.820 --> 00:49:30.760
PAUL KINLAN: Yeah.

00:49:30.760 --> 00:49:31.610
PETE LEPAGE: Yes.

00:49:31.610 --> 00:49:32.110
That was --

00:49:32.110 --> 00:49:32.930
PAUL KINLAN: That didn't work?

00:49:32.930 --> 00:49:34.460
PETE LEPAGE: That was a lot
better than the first

00:49:34.460 --> 00:49:35.480
time we tried it.

00:49:35.480 --> 00:49:37.550
So all right, everybody.

00:49:37.550 --> 00:49:38.290
Thanks very much.

00:49:38.290 --> 00:49:39.680
Hope you have a wonderful day.

00:49:39.680 --> 00:49:41.750
And talk to you soon.

00:49:41.750 --> 00:49:42.650
Bye-bye.

00:49:42.650 --> 00:49:43.850
PAUL KINLAN: Thank you.

00:49:43.850 --> 00:49:54.233
[MUSIC PLAYING]

