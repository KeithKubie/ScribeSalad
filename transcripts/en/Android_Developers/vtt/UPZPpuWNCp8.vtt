WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.766
[GOOGLE LOGO MUSIC]

00:00:03.690 --> 00:00:06.410
YACINE REZGUI: Next
billion users, or NBU,

00:00:06.410 --> 00:00:09.630
are countries where half
of the population or more

00:00:09.630 --> 00:00:12.780
is not connected
yet to the internet.

00:00:12.780 --> 00:00:14.460
They have a different
way to interact

00:00:14.460 --> 00:00:18.010
with the internet, a different
way to use their smartphone.

00:00:18.010 --> 00:00:20.490
And we're going to highlight
you all those cases

00:00:20.490 --> 00:00:23.320
in this presentation.

00:00:23.320 --> 00:00:25.530
First, let's have a
situation on the ground.

00:00:28.980 --> 00:00:31.870
As you can see, the
next billion users

00:00:31.870 --> 00:00:35.350
are spread out, three
different continents--

00:00:35.350 --> 00:00:40.000
Asia, Africa, and Latin America.

00:00:40.000 --> 00:00:42.670
For some of them,
internet is just

00:00:42.670 --> 00:00:44.590
the beginning of a new era.

00:00:49.880 --> 00:00:52.730
We usually think about the
next billion users as something

00:00:52.730 --> 00:00:56.910
in the future, something
which is not ready yet.

00:00:56.910 --> 00:00:59.610
As shown on the map,
numerous countries

00:00:59.610 --> 00:01:03.950
already part of the internet.

00:01:03.950 --> 00:01:08.360
Some countries in Asia
as a whole region account

00:01:08.360 --> 00:01:12.560
for 50% of the
smartphone market--

00:01:12.560 --> 00:01:17.170
Vietnam, Philippines,
Indonesia, they

00:01:17.170 --> 00:01:18.810
are part of the
Southeast Asia, which

00:01:18.810 --> 00:01:23.610
accounts for 350 million
users on the internet.

00:01:23.610 --> 00:01:30.240
And India itself accounts for
40 million new users every year.

00:01:30.240 --> 00:01:33.750
Again, we usually think
as the next billion users

00:01:33.750 --> 00:01:37.020
that we have a timeline, we
have a time to think about it.

00:01:37.020 --> 00:01:37.830
It's already big.

00:01:37.830 --> 00:01:39.850
It's already present,
and just continue

00:01:39.850 --> 00:01:41.870
to be bigger and bigger
in the upcoming years.

00:01:45.720 --> 00:01:48.270
For them, phone is
not only a device

00:01:48.270 --> 00:01:50.640
to connect to the internet,
it's the only device

00:01:50.640 --> 00:01:52.710
they will have access to you.

00:01:52.710 --> 00:01:54.180
So you should not
expect your users

00:01:54.180 --> 00:01:56.270
to have access to a
computer or tablet

00:01:56.270 --> 00:01:58.494
to access your applications.

00:02:02.760 --> 00:02:04.880
They have a mobile-only mindset.

00:02:04.880 --> 00:02:08.590
And, as an example,
Nigeria has only 11%

00:02:08.590 --> 00:02:13.540
of the population having
access to a computer.

00:02:13.540 --> 00:02:16.620
They have an instinct
for ubiquitous computing.

00:02:16.620 --> 00:02:21.780
In India, 30% of the search
made on Google are using voice.

00:02:21.780 --> 00:02:26.250
It's not a net case, it's not
a power user thing to do there.

00:02:26.250 --> 00:02:27.360
It's really normal.

00:02:27.360 --> 00:02:29.880
They have natural interaction
with the smartphone.

00:02:29.880 --> 00:02:33.750
They will use it in
all the possible ways.

00:02:33.750 --> 00:02:37.800
Lastly, they have a huge
demand for localized content.

00:02:37.800 --> 00:02:40.620
English is the first
language on the internet,

00:02:40.620 --> 00:02:43.020
but it doesn't mean it's
a language understood

00:02:43.020 --> 00:02:46.210
by all the users over there.

00:02:46.210 --> 00:02:48.580
They don't only want
translated content.

00:02:48.580 --> 00:02:51.100
They want content adapted
for them-- for their culture,

00:02:51.100 --> 00:02:52.533
their environment.

00:02:56.320 --> 00:02:59.740
Also, you should expect users
to change their language quite

00:02:59.740 --> 00:03:03.080
often based on the environment--

00:03:03.080 --> 00:03:06.340
Maybe at work with
family, with friends,

00:03:06.340 --> 00:03:07.960
based on that current location.

00:03:07.960 --> 00:03:10.000
They will just continuously
change language.

00:03:10.000 --> 00:03:11.470
It's not something
rare for them.

00:03:11.470 --> 00:03:12.310
It's really often.

00:03:17.280 --> 00:03:21.540
As shown on the map, numerous
countries who are NBU

00:03:21.540 --> 00:03:24.150
are part of Asia and Africa.

00:03:24.150 --> 00:03:30.660
Both continents accounts
for 119 official languages.

00:03:30.660 --> 00:03:35.430
In India, you have
314 million people

00:03:35.430 --> 00:03:40.630
who can speak two languages
and sometimes even more.

00:03:40.630 --> 00:03:45.070
Again, in India, you had 23
official languages written

00:03:45.070 --> 00:03:47.890
in 13 different scripts.

00:03:47.890 --> 00:03:51.190
It brings some challenges
in terms of content display

00:03:51.190 --> 00:03:52.150
and font-swapping.

00:03:55.550 --> 00:03:59.330
Hindi, which is one of the
official languages in India,

00:03:59.330 --> 00:04:02.990
is not even on the top
30 languages in the web,

00:04:02.990 --> 00:04:06.200
even though it's the
fourth most spoken language

00:04:06.200 --> 00:04:09.170
around the world.

00:04:09.170 --> 00:04:13.400
Nigeria itself as a country
has 500 spoken languages

00:04:13.400 --> 00:04:15.020
around the whole country.

00:04:15.020 --> 00:04:18.110
Even though English may be
the official language there,

00:04:18.110 --> 00:04:20.953
people will use their local
language because, again, it's

00:04:20.953 --> 00:04:21.870
part of their culture.

00:04:21.870 --> 00:04:22.745
You cannot deny that.

00:04:27.840 --> 00:04:32.490
Also, they have another
diversity in terms of hardware.

00:04:32.490 --> 00:04:35.520
They will have different
devices, different brands.

00:04:35.520 --> 00:04:37.860
And you have to account
for them whenever you are

00:04:37.860 --> 00:04:39.444
developing your application.

00:04:43.240 --> 00:04:46.300
Some of them you may
already know, some OEMs.

00:04:46.300 --> 00:04:48.190
Obviously Samsung is there.

00:04:48.190 --> 00:04:51.430
But also some Chinese
OEMs, as Huawei,

00:04:51.430 --> 00:04:55.350
Oppo, OnePlus, and Xiaomi.

00:04:55.350 --> 00:04:57.680
In Nigeria, you
have also Everyone.

00:04:57.680 --> 00:05:00.700
And in India, you have MicroMax.

00:05:00.700 --> 00:05:05.540
Transsion is the first Android
Go OEM around the world.

00:05:05.540 --> 00:05:09.220
And maybe you've
never heard of it.

00:05:09.220 --> 00:05:11.490
They have commonly
lower specs devices,

00:05:11.490 --> 00:05:13.860
but you should not
target only those.

00:05:13.860 --> 00:05:16.090
You should think about
it as a spectrum.

00:05:16.090 --> 00:05:19.573
Some people may have higher spec
devices, some of them lower,

00:05:19.573 --> 00:05:21.240
and you have to account
for all of them.

00:05:24.270 --> 00:05:27.440
Lastly, they have long
wear hardware upgrade.

00:05:27.440 --> 00:05:29.240
You should think
about it whenever

00:05:29.240 --> 00:05:32.545
you estimate your operational
costs developing an application

00:05:32.545 --> 00:05:33.545
targeting those markets.

00:05:39.050 --> 00:05:42.650
We usually think about
offline as a narrow state.

00:05:42.650 --> 00:05:46.010
You're in a plane, in a
train, in a building where

00:05:46.010 --> 00:05:47.810
the signal is not strong.

00:05:47.810 --> 00:05:51.130
Well actually, it can
be a choice for them.

00:05:51.130 --> 00:05:54.980
Offline usually is just
a temporary mistake,

00:05:54.980 --> 00:05:59.140
the way we think about
it in Western countries.

00:05:59.140 --> 00:06:03.770
But in those NBU
countries, 95% of the users

00:06:03.770 --> 00:06:06.130
are on prepaid plans.

00:06:06.130 --> 00:06:08.680
Even though 4G and
3G is definitely

00:06:08.680 --> 00:06:12.010
cheaper years after years,
people just turn it off

00:06:12.010 --> 00:06:15.700
whenever they don't need it.

00:06:15.700 --> 00:06:19.060
So whenever you're showing a
banner, you're not connected,

00:06:19.060 --> 00:06:20.727
well, they're
already aware of it.

00:06:20.727 --> 00:06:22.060
They are the one who set it off.

00:06:24.770 --> 00:06:27.770
Also, Wi-Fi is not
always reliable.

00:06:27.770 --> 00:06:30.290
So you can't expect people
to download resources

00:06:30.290 --> 00:06:34.150
over Wi-Fi because they
may not have it at home.

00:06:34.150 --> 00:06:36.400
Sometimes 4G is even
faster than Wi-Fi.

00:06:39.550 --> 00:06:42.010
Some websites may
be also offered

00:06:42.010 --> 00:06:45.460
for free, on mobile
plans, or restricted

00:06:45.460 --> 00:06:47.750
by government regulation.

00:06:47.750 --> 00:06:50.330
So whenever you're integrating
with third parties,

00:06:50.330 --> 00:06:52.665
think about it whenever
you're developing your apps

00:06:52.665 --> 00:06:53.665
targeting those markets.

00:06:58.230 --> 00:07:02.220
We usually think about
diversity as a problem,

00:07:02.220 --> 00:07:05.730
as just too many
parameters to account for.

00:07:05.730 --> 00:07:08.220
We would love just to
have one single standard

00:07:08.220 --> 00:07:12.520
but that's just denying
their diversity.

00:07:12.520 --> 00:07:18.780
We think diversity at Google is
not a problem, it's an asset.

00:07:18.780 --> 00:07:21.060
It's a growth opportunity
for your markets.

00:07:25.300 --> 00:07:30.500
As shown earlier, again,
many countries which are NBUs

00:07:30.500 --> 00:07:33.400
are part of Asia,
which already accounts

00:07:33.400 --> 00:07:36.370
for 50% of the smartphone
market and will

00:07:36.370 --> 00:07:39.370
account for 50% of
the upcoming growth

00:07:39.370 --> 00:07:40.960
on the smartphone market.

00:07:40.960 --> 00:07:43.030
You have to compare
that to mature markets

00:07:43.030 --> 00:07:45.010
like Western countries
where you have

00:07:45.010 --> 00:07:48.430
already a huge penetration of
internet and smartphone access.

00:07:51.150 --> 00:07:55.380
Over the next 1.6
billion new connections,

00:07:55.380 --> 00:07:59.510
40% will come from these
top five countries.

00:07:59.510 --> 00:08:03.510
Four of them are
next billion users--

00:08:03.510 --> 00:08:07.680
Nigeria, India,
Pakistan, and Indonesia.

00:08:07.680 --> 00:08:09.720
Also, the surrounding
countries will

00:08:09.720 --> 00:08:13.420
be affected by that growth.

00:08:13.420 --> 00:08:17.610
So again, think about it, the
next billion users are already

00:08:17.610 --> 00:08:18.180
there.

00:08:18.180 --> 00:08:20.160
And they're just
waiting for your apps

00:08:20.160 --> 00:08:23.190
to be compatible with them.

00:08:23.190 --> 00:08:27.440
Now I'm going to hand over
to my colleague, Rajeev--

00:08:27.440 --> 00:08:31.410
Amrit, my bad-- is going
to talk about improving

00:08:31.410 --> 00:08:34.380
your application by adopting
Google products that

00:08:34.380 --> 00:08:36.120
can help you to do that.

00:08:36.120 --> 00:08:37.600
To you, Amrit.

00:08:37.600 --> 00:08:38.850
AMRIT SANJEEV: Thanks, Yacine.

00:08:42.110 --> 00:08:43.280
Hi, everyone.

00:08:43.280 --> 00:08:44.610
My name is Amrit Sanjeev.

00:08:44.610 --> 00:08:46.960
I'm a developer advocate
at Google based in India.

00:08:46.960 --> 00:08:49.060
And, in this section, I
want to talk about some

00:08:49.060 --> 00:08:51.890
of the Google products
that you can use in order

00:08:51.890 --> 00:08:55.870
to help give a better user
experience for your users

00:08:55.870 --> 00:08:59.200
in the NBU market.

00:08:59.200 --> 00:09:01.030
Let's start with app bundles.

00:09:01.030 --> 00:09:04.180
App size is a key
factor that users

00:09:04.180 --> 00:09:07.210
consider when they install
an app in these markets.

00:09:07.210 --> 00:09:10.330
By switching an upload
format to app bundles,

00:09:10.330 --> 00:09:12.850
you allow player to
distribute an APK that's

00:09:12.850 --> 00:09:17.590
optimized in terms of
resources, code, and languages

00:09:17.590 --> 00:09:20.410
based on your device's
configuration.

00:09:20.410 --> 00:09:23.470
This helps greatly reduce
the initial install size

00:09:23.470 --> 00:09:25.990
of the application and
also the install friction

00:09:25.990 --> 00:09:27.490
that users have.

00:09:27.490 --> 00:09:29.850
I want to call out
an example here--

00:09:29.850 --> 00:09:33.430
RedBus, which is a
ticket-booking app from India

00:09:33.430 --> 00:09:35.680
who switched over
to app bundle format

00:09:35.680 --> 00:09:39.520
and reduced their
APK size by 30%.

00:09:39.520 --> 00:09:43.570
This, in turn, helped them
increase their conversions

00:09:43.570 --> 00:09:45.840
by 6%.

00:09:45.840 --> 00:09:47.830
And the best part
of it is that they

00:09:47.830 --> 00:09:50.170
didn't have to change
a single line of code

00:09:50.170 --> 00:09:53.260
to achieve this result.

00:09:53.260 --> 00:09:56.110
To optimize even
further, you can

00:09:56.110 --> 00:09:59.590
choose to deliver
functionality as on-demand

00:09:59.590 --> 00:10:01.785
rather than package
it all together

00:10:01.785 --> 00:10:03.880
in the initial install.

00:10:03.880 --> 00:10:07.150
This can be achieved by
using the on-demand feature

00:10:07.150 --> 00:10:09.730
with app bundles.

00:10:09.730 --> 00:10:12.250
By adopting on-demand
features, you

00:10:12.250 --> 00:10:15.280
not only reduce the
initial install size,

00:10:15.280 --> 00:10:18.920
but also the space that you
actually take on the device.

00:10:18.920 --> 00:10:22.030
A lot of users run out of space
on devices in these regions

00:10:22.030 --> 00:10:23.710
regularly.

00:10:23.710 --> 00:10:26.320
The other important factor
is that based on usage,

00:10:26.320 --> 00:10:32.350
you can choose to remove modules
and save space for the user.

00:10:32.350 --> 00:10:35.110
An example I want to
call out is PayTM,

00:10:35.110 --> 00:10:38.680
who initially reduced their
app size using app bundles

00:10:38.680 --> 00:10:43.630
and then further optimized by
removing some of their modules

00:10:43.630 --> 00:10:45.970
as on-demand modules,
and reduced the app

00:10:45.970 --> 00:10:47.200
size by a further 20%.

00:10:49.720 --> 00:10:50.960
And they're not done yet.

00:10:50.960 --> 00:10:54.220
They're making further changes
and improving on this number

00:10:54.220 --> 00:10:57.160
even further.

00:10:57.160 --> 00:11:01.990
To extend this even further, you
could use conditional modules

00:11:01.990 --> 00:11:04.390
to install certain modules
based on your device

00:11:04.390 --> 00:11:09.340
configuration or user's locale
during the initial install.

00:11:09.340 --> 00:11:12.310
Let me explain this with
an example for you guys.

00:11:12.310 --> 00:11:15.640
Assume that you have an app
which you want to release it

00:11:15.640 --> 00:11:17.410
to two different countries.

00:11:17.410 --> 00:11:19.975
But in each of
these countries, you

00:11:19.975 --> 00:11:21.850
have completely different
payment instruments

00:11:21.850 --> 00:11:24.220
of support, which would
mean that you would have

00:11:24.220 --> 00:11:28.390
completely different workflows,
assets, and libraries required

00:11:28.390 --> 00:11:31.540
for realizing each of
the payment workflows.

00:11:31.540 --> 00:11:35.080
One way of doing this would
be to package all of this

00:11:35.080 --> 00:11:38.650
into a single payment
module and, at runtime,

00:11:38.650 --> 00:11:41.890
decide which workflow
to show to the user

00:11:41.890 --> 00:11:45.540
depending on which locale
he is using the app from.

00:11:45.540 --> 00:11:47.500
With conditional modules,
you could actually

00:11:47.500 --> 00:11:51.610
separate this into two different
modules and during install time

00:11:51.610 --> 00:11:57.040
decide which module needs to
be packaged with the app based

00:11:57.040 --> 00:11:59.260
on the user's locale.

00:11:59.260 --> 00:12:02.530
That way your device
would only get

00:12:02.530 --> 00:12:06.580
the portions of code and the
workflow that it will ever use.

00:12:06.580 --> 00:12:09.520
The second payment module
will not be there at all.

00:12:12.390 --> 00:12:15.260
As Yacine mentioned,
BOU countries

00:12:15.260 --> 00:12:16.960
have a lot of
official languages.

00:12:16.960 --> 00:12:20.360
For example India, has
23 official languages.

00:12:20.360 --> 00:12:22.240
But the interesting
thing here to note

00:12:22.240 --> 00:12:26.530
is that users usually set their
device language to be English.

00:12:26.530 --> 00:12:29.470
And it's a very common
practice for applications

00:12:29.470 --> 00:12:32.200
which cater for these markets
to have an in-app setting where

00:12:32.200 --> 00:12:34.960
users choose the language
for localizing content

00:12:34.960 --> 00:12:37.540
on their app.

00:12:37.540 --> 00:12:40.060
Now, when you take app
bundles for instance,

00:12:40.060 --> 00:12:42.550
app bundles use
the device language

00:12:42.550 --> 00:12:44.830
to optimize what
language resources need

00:12:44.830 --> 00:12:50.080
to be packaged along with the
APK during the installation.

00:12:50.080 --> 00:12:54.410
And with language
splits API, you actually

00:12:54.410 --> 00:12:56.620
bring the best of both worlds.

00:12:56.620 --> 00:12:58.780
Using this API, the
developed can then

00:12:58.780 --> 00:13:02.050
fetch additional
language resources

00:13:02.050 --> 00:13:03.890
for different
languages, say, when

00:13:03.890 --> 00:13:06.520
the user is selecting a new
language from the settings.

00:13:09.820 --> 00:13:12.140
I talked about install
size for some time.

00:13:12.140 --> 00:13:15.580
Let's talk about how app
upgrades happen in this region.

00:13:15.580 --> 00:13:19.340
App upgrade cycles
are usually longer,

00:13:19.340 --> 00:13:24.130
which means you will end up
having situations where you

00:13:24.130 --> 00:13:26.500
will have more versions of
your app in the real world

00:13:26.500 --> 00:13:28.060
to support.

00:13:28.060 --> 00:13:29.830
This has side effects.

00:13:29.830 --> 00:13:32.640
It not only increases
your operational cost,

00:13:32.640 --> 00:13:34.390
but you have to deal
with situations where

00:13:34.390 --> 00:13:37.140
users negatively rate
your app for bugs

00:13:37.140 --> 00:13:38.650
you have already fixed.

00:13:38.650 --> 00:13:40.150
But they are still
experiencing it

00:13:40.150 --> 00:13:42.790
because they never upgraded it.

00:13:42.790 --> 00:13:47.030
Now, in in-app upgrade API helps
you fix some of these problems.

00:13:47.030 --> 00:13:51.580
It allows you to show a dialog
to the user informing them

00:13:51.580 --> 00:13:54.620
that a new update is available.

00:13:54.620 --> 00:13:56.920
The best part of this
API that it actually

00:13:56.920 --> 00:13:59.650
takes into account the
player's targeting rules

00:13:59.650 --> 00:14:02.920
before showing it to the user.

00:14:02.920 --> 00:14:05.410
That is, if your stage
is rolling out only 5%

00:14:05.410 --> 00:14:08.620
of your users, only
those 5% of users

00:14:08.620 --> 00:14:10.700
actually see the upgrade dialog.

00:14:10.700 --> 00:14:14.620
It's the same case with people
who are on a different channel,

00:14:14.620 --> 00:14:17.020
say your alpha channel
of your application.

00:14:17.020 --> 00:14:19.120
And you release only to
alpha, only those users

00:14:19.120 --> 00:14:20.080
will actually see this.

00:14:22.740 --> 00:14:25.110
I want to now
switch over to SMS.

00:14:25.110 --> 00:14:30.890
Two-factor authentication is
very common in NBU countries.

00:14:30.890 --> 00:14:34.070
This is because a lot
of payment modules

00:14:34.070 --> 00:14:37.400
are actually two-factor
authentication based.

00:14:37.400 --> 00:14:39.320
And more and more
applications are

00:14:39.320 --> 00:14:42.500
requesting for SMS
permission to ensure

00:14:42.500 --> 00:14:48.350
that they can make the OTP
flow much more smoother

00:14:48.350 --> 00:14:51.510
by auto-filling it for the user.

00:14:51.510 --> 00:14:54.710
But with growing privacy
concerns, a lot of users

00:14:54.710 --> 00:14:56.890
are reluctant to give
this permission, and also

00:14:56.890 --> 00:14:58.640
worried about how much
information they're

00:14:58.640 --> 00:15:02.720
passing to an app by giving them
complete access to their SMS

00:15:02.720 --> 00:15:04.420
inbox.

00:15:04.420 --> 00:15:07.760
Last year, we introduced SMS
Retriever API, which kind of

00:15:07.760 --> 00:15:09.470
solved this problem
to a good extent,

00:15:09.470 --> 00:15:12.080
where an OTP message could be
passed through an application

00:15:12.080 --> 00:15:14.870
without the user
giving this permission.

00:15:14.870 --> 00:15:17.510
But it required the
SMS message to be

00:15:17.510 --> 00:15:19.460
formatted in a certain way.

00:15:19.460 --> 00:15:22.560
To be more precise, it a hash
code towards the end of it,

00:15:22.560 --> 00:15:24.110
which allowed the
API to identify

00:15:24.110 --> 00:15:26.810
that the particular
OTP message is

00:15:26.810 --> 00:15:29.990
for a particular application.

00:15:29.990 --> 00:15:33.290
That's great when
the SMS are sent

00:15:33.290 --> 00:15:35.850
by the application's service.

00:15:35.850 --> 00:15:39.290
But imagine a case of
a bank application.

00:15:39.290 --> 00:15:42.470
They have to deal with
hundreds of applications

00:15:42.470 --> 00:15:44.090
or thousands of them.

00:15:44.090 --> 00:15:50.180
And in such cases, you
will have to do a look-up

00:15:50.180 --> 00:15:53.390
to figure out
which hash code has

00:15:53.390 --> 00:15:55.550
to be attached to the
end of the message

00:15:55.550 --> 00:15:58.080
before you send it
out to the client.

00:15:58.080 --> 00:16:00.210
And that's kind of inefficient.

00:16:00.210 --> 00:16:03.230
So that's where the SMS and
the API comes into the picture.

00:16:03.230 --> 00:16:05.420
The workflow remains
pretty much the same.

00:16:05.420 --> 00:16:08.987
But in this case, when
the OTP is actually

00:16:08.987 --> 00:16:10.945
received on the device,
that is the OTP message

00:16:10.945 --> 00:16:15.200
is on the device, the
system would recognize

00:16:15.200 --> 00:16:17.660
using some smarts-that hey,
this is an OTP message,

00:16:17.660 --> 00:16:20.240
and short dialog to
the user asking him

00:16:20.240 --> 00:16:23.670
permission to pass that
message to the application.

00:16:23.670 --> 00:16:26.360
If the user approves
it, the OTP message

00:16:26.360 --> 00:16:28.610
is passed to the application,
and the rest of the flow

00:16:28.610 --> 00:16:30.380
can automatically continue.

00:16:30.380 --> 00:16:34.220
The advantage here is that there
is no additional formatting

00:16:34.220 --> 00:16:35.610
required.

00:16:35.610 --> 00:16:38.950
There's no SMS permission
required for this.

00:16:38.950 --> 00:16:44.360
I want to call out
an example here,

00:16:44.360 --> 00:16:48.710
of Zomato, which is a food
delivery and restaurant booking

00:16:48.710 --> 00:16:52.700
app from the region, which
was able to remove SMS read

00:16:52.700 --> 00:16:56.830
permission completely from their
application by using this API.

00:16:56.830 --> 00:16:59.420
They were part of our
early access program.

00:16:59.420 --> 00:17:02.960
And they've reported to us
that their user flow has now

00:17:02.960 --> 00:17:06.440
improved in speed and users are
having a much better experience

00:17:06.440 --> 00:17:09.680
because of this.

00:17:09.680 --> 00:17:12.480
Moving on to real
world performance,

00:17:12.480 --> 00:17:14.230
no matter where you're
launching your app,

00:17:14.230 --> 00:17:16.397
understanding the real world
performance of your app

00:17:16.397 --> 00:17:19.730
is really important
once you ship it.

00:17:19.730 --> 00:17:22.869
But it's even more critical
in NBU markets because

00:17:22.869 --> 00:17:24.880
of the plethora of
devices available there

00:17:24.880 --> 00:17:28.750
and the wide range of
conditions, hardware,

00:17:28.750 --> 00:17:33.100
network situations
prevalent in these regions.

00:17:33.100 --> 00:17:35.080
Firebase Performance
Monitoring SDK

00:17:35.080 --> 00:17:39.340
is one such SDK that you can
add to your app, which will then

00:17:39.340 --> 00:17:41.560
collect statistics
automatically,

00:17:41.560 --> 00:17:43.840
visualizes it, and
even identifies

00:17:43.840 --> 00:17:46.370
and highlights problems for you.

00:17:46.370 --> 00:17:51.070
This allows you to fix problems
before users actually see this,

00:17:51.070 --> 00:17:54.610
giving a better
experience for your users.

00:17:54.610 --> 00:17:56.980
I want to highlight the
work that [INAUDIBLE] apps

00:17:56.980 --> 00:18:02.110
did with data that they actually
derived from these Firebase

00:18:02.110 --> 00:18:03.910
Performance consults.

00:18:03.910 --> 00:18:08.350
They were able to reduce
their apps cold start-up time

00:18:08.350 --> 00:18:11.830
by 50% for users
on the 2G network.

00:18:11.830 --> 00:18:14.600
And this gave a great
experience for those users.

00:18:14.600 --> 00:18:17.590
They used the data that was
visualized by Firebase Console

00:18:17.590 --> 00:18:19.480
and identified an
issue with which

00:18:19.480 --> 00:18:23.200
was particularly happening
on 2G networks, and fix this,

00:18:23.200 --> 00:18:26.950
immediately giving a better
experience for the users.

00:18:26.950 --> 00:18:30.160
And lastly, I want to
talk about localization.

00:18:30.160 --> 00:18:34.060
When we talk about localization,
a lot of times people

00:18:34.060 --> 00:18:35.500
think about the
language in which

00:18:35.500 --> 00:18:39.820
the content is shown on the
device or within the app.

00:18:39.820 --> 00:18:43.840
Now, that's absolutely
important-- no doubt.

00:18:43.840 --> 00:18:47.440
But there are other things
that you can do in this aspect.

00:18:47.440 --> 00:18:52.810
You could use things like
localized graphics and store

00:18:52.810 --> 00:18:55.810
listings based on the user's
language and Play Console.

00:18:55.810 --> 00:18:59.410
This helps improve
conversions for your app.

00:18:59.410 --> 00:19:03.370
We have recently introduced
country-based targeting, which,

00:19:03.370 --> 00:19:06.250
again, is targeted
towards using--

00:19:06.250 --> 00:19:11.290
targeted towards improving
user conversions for your apps.

00:19:11.290 --> 00:19:14.470
One of our early access
partners, Cookbook

00:19:14.470 --> 00:19:16.330
actually increased
conversion rates

00:19:16.330 --> 00:19:19.375
by 17% using this feature.

00:19:19.375 --> 00:19:21.500
If you want to understand
more about what they did,

00:19:21.500 --> 00:19:23.200
they wrote an excellent
blog about it.

00:19:23.200 --> 00:19:24.450
And you should check that out.

00:19:26.540 --> 00:19:28.540
And, lastly, I want to
call out that this is not

00:19:28.540 --> 00:19:31.640
an exhaustive list of
products you can use.

00:19:31.640 --> 00:19:34.010
I've only called out
a few of them here,

00:19:34.010 --> 00:19:36.080
which basically has
given a lot of advantages

00:19:36.080 --> 00:19:38.830
to some of our partners who
cater for these regions.

00:19:38.830 --> 00:19:41.410
Now I'd like to hand it over
to my colleague Rajeev, who

00:19:41.410 --> 00:19:43.210
talk to you about
how to optimize

00:19:43.210 --> 00:19:44.990
apps for low-end devices.

00:19:44.990 --> 00:19:45.615
Thank you.

00:19:45.615 --> 00:19:46.770
[APPLAUSE]

00:19:46.770 --> 00:19:47.770
RAJEEV KUMAR: Thank you.

00:19:53.010 --> 00:19:54.650
Thanks, Amrit.

00:19:54.650 --> 00:19:56.220
Hello, everyone.

00:19:56.220 --> 00:19:58.130
My name is Rajeev Kumar.

00:19:58.130 --> 00:20:00.590
I work on Android Go project.

00:20:00.590 --> 00:20:04.970
And Android Go is a platform
for devices running 1GB or less

00:20:04.970 --> 00:20:09.670
RAM, minimum eight gigs
of internal storage,

00:20:09.670 --> 00:20:12.490
and low-end CPU codes.

00:20:12.490 --> 00:20:15.670
Today, I'm going to talk about
some of the best practices

00:20:15.670 --> 00:20:21.190
that me and my team has used
to optimize apps on disk,

00:20:21.190 --> 00:20:22.798
to optimize the apps on RAM.

00:20:22.798 --> 00:20:25.090
And I'm also going to talk
about some of the techniques

00:20:25.090 --> 00:20:29.560
we use to keep apps responsive.

00:20:29.560 --> 00:20:34.080
So let's talk about APK size.

00:20:34.080 --> 00:20:37.010
Why does APK size matter?

00:20:37.010 --> 00:20:39.160
It matters because it
impacts the time it

00:20:39.160 --> 00:20:42.810
takes to load your application.

00:20:42.810 --> 00:20:48.340
It also impacts the RAM it
takes to load your application.

00:20:48.340 --> 00:20:51.330
And it also impacts
the battery it

00:20:51.330 --> 00:20:55.020
takes to load your application.

00:20:55.020 --> 00:20:59.670
So what can you do to reduce
your APK size on disk?

00:20:59.670 --> 00:21:01.910
Use Proguarding.

00:21:01.910 --> 00:21:03.660
It really helps.

00:21:03.660 --> 00:21:07.460
We have used Proguarding on
systems apps like Launcher

00:21:07.460 --> 00:21:09.090
and Bluetooth APK.

00:21:09.090 --> 00:21:11.780
And just by enabling
Proguarding,

00:21:11.780 --> 00:21:17.410
we were able to gain
around 25% of disk space.

00:21:17.410 --> 00:21:21.330
But [INAUDIBLE] your public
API and Proguard flags the

00:21:21.330 --> 00:21:26.600
file so that you don't wipe
it out with Proguarding.

00:21:26.600 --> 00:21:31.580
So how could you learn more
about your API structure?

00:21:31.580 --> 00:21:36.230
We have used
APKAnalyzer tool to look

00:21:36.230 --> 00:21:40.980
at what part of application is
contributing to the APK size.

00:21:40.980 --> 00:21:45.850
And let's say you determine
the APK size was bigger

00:21:45.850 --> 00:21:48.100
because of the
resources, you would

00:21:48.100 --> 00:21:53.070
be able to use Shrink Resources
together with [INAUDIBLE]

00:21:53.070 --> 00:21:58.210
Enable in your [INAUDIBLE]
project to reduce your APK

00:21:58.210 --> 00:22:00.580
size significantly.

00:22:00.580 --> 00:22:02.790
What else you can do?

00:22:02.790 --> 00:22:07.080
You may consider to
use specific densities.

00:22:07.080 --> 00:22:11.710
For example, you can target
MDPI for certain devices

00:22:11.710 --> 00:22:14.880
and therefore not include
resources for higher density.

00:22:17.620 --> 00:22:21.810
As Amrit mentioned,
the app bundles

00:22:21.810 --> 00:22:24.540
could also help to
reduce your APK size

00:22:24.540 --> 00:22:27.060
or your initial download size.

00:22:27.060 --> 00:22:28.710
Let's take an example.

00:22:28.710 --> 00:22:34.600
The Photos app can have the
viewing capability as well as

00:22:34.600 --> 00:22:36.800
the editing capability.

00:22:36.800 --> 00:22:40.100
You may decide to not
include editor to begin with,

00:22:40.100 --> 00:22:43.190
and only download the
reader module when

00:22:43.190 --> 00:22:47.750
a user clicks on the editing
part of the application.

00:22:47.750 --> 00:22:51.320
You may also consider
to use reduced set up

00:22:51.320 --> 00:22:54.920
language in your application,
and therefore your resources

00:22:54.920 --> 00:22:56.790
is going to be smaller,
and APK size is

00:22:56.790 --> 00:22:58.040
going to be a smaller as well.

00:23:04.163 --> 00:23:08.050
Now, continuing on the theme
of reducing your APK size,

00:23:08.050 --> 00:23:11.110
let's talk about the MA
size in your application.

00:23:11.110 --> 00:23:15.630
How can you reduce MA
size in your application?

00:23:15.630 --> 00:23:21.280
Consider compressing PNG and
JPEG, crunching PNG files,

00:23:21.280 --> 00:23:24.170
and, if possible,
use WebP file format,

00:23:24.170 --> 00:23:28.610
which is great on
saving the disk size

00:23:28.610 --> 00:23:32.780
and has a decent
rendering performance.

00:23:32.780 --> 00:23:35.050
You may consider to
use vector graphics

00:23:35.050 --> 00:23:39.580
for reducing independent
icons in a scalable media.

00:23:39.580 --> 00:23:43.570
By doing so, you would not be
including the static resources.

00:23:43.570 --> 00:23:47.450
And, therefore, your APK size
is going to be a smaller.

00:23:47.450 --> 00:23:49.450
What else you can do?

00:23:49.450 --> 00:23:51.320
Avoid enumerations.

00:23:51.320 --> 00:23:56.650
A single enum can take
up to 1 to 1.4 kilobytes

00:23:56.650 --> 00:23:59.060
size in your cluster
to desk file.

00:23:59.060 --> 00:24:04.340
If possible, use [INAUDIBLE]
with Proguarding, and it

00:24:04.340 --> 00:24:09.240
will replace your enumeration
built into your constants.

00:24:09.240 --> 00:24:12.250
Remove debug symbol from
your native binaries.

00:24:12.250 --> 00:24:14.970
They are great for
developing your application.

00:24:14.970 --> 00:24:19.980
However, it can take
significant amount of APK size.

00:24:19.980 --> 00:24:23.940
And, while extracting
native libraries,

00:24:23.940 --> 00:24:27.060
by doing so, you will be
instructing packet manager

00:24:27.060 --> 00:24:31.380
to not to copy .SO file from
your application to the file

00:24:31.380 --> 00:24:32.400
system.

00:24:32.400 --> 00:24:35.303
And as a nice side
effect, your update size

00:24:35.303 --> 00:24:36.345
is going to be a smaller.

00:24:41.450 --> 00:24:47.180
Now I want to talk about how
to reduce your app size in RAM.

00:24:47.180 --> 00:24:51.720
So how would you monitor
your app size in RAM?

00:24:51.720 --> 00:24:55.680
Use Android Compiler, which
comes with Android Studio,

00:24:55.680 --> 00:25:01.440
to generate heap dump
for your application.

00:25:01.440 --> 00:25:03.870
You may also use
the ADB command,

00:25:03.870 --> 00:25:08.850
which is ADB shell am dumpheap
to generate Java heap dump as

00:25:08.850 --> 00:25:11.870
well as native heap dump.

00:25:11.870 --> 00:25:14.160
And with the debug working
on your application

00:25:14.160 --> 00:25:17.660
and with these heap dumps, you
would have a pretty good idea

00:25:17.660 --> 00:25:19.250
about what part of
your application

00:25:19.250 --> 00:25:20.810
is contributing to the RAM size.

00:25:23.920 --> 00:25:28.300
So let's say system is
under memory pressure.

00:25:28.300 --> 00:25:33.510
What can you do to reduce
memory pressure on the system?

00:25:33.510 --> 00:25:35.940
For this, the activity
manager service

00:25:35.940 --> 00:25:40.080
provides a callback called
on prem memory, which

00:25:40.080 --> 00:25:42.210
you can implement
in your activity

00:25:42.210 --> 00:25:46.470
and can release resources
and cache objects

00:25:46.470 --> 00:25:50.620
to reduce memory
pressure on the system.

00:25:50.620 --> 00:25:52.030
What else?

00:25:52.030 --> 00:25:54.880
Do not create
unnecessary processes

00:25:54.880 --> 00:25:56.140
unless they are short-lived.

00:25:56.140 --> 00:25:58.840
Long-lived processes can
contribute to the memory

00:25:58.840 --> 00:26:01.590
of your application.

00:26:01.590 --> 00:26:03.670
Use services sparingly.

00:26:03.670 --> 00:26:06.280
If possible, consider
using Java Scribbler,

00:26:06.280 --> 00:26:08.830
which is constraint-aware.

00:26:08.830 --> 00:26:12.670
It can take into account
the system memory

00:26:12.670 --> 00:26:15.560
pressure, the
network conditions,

00:26:15.560 --> 00:26:18.700
as well as the battery.

00:26:18.700 --> 00:26:21.550
Consider using optimized
data containers, which

00:26:21.550 --> 00:26:28.030
are array map, array set, sparse
array, sparse Boolean array,

00:26:28.030 --> 00:26:29.350
longest sparse array.

00:26:29.350 --> 00:26:31.780
These are optimized for
using memory efficiently,

00:26:31.780 --> 00:26:36.455
and can save your app
to have less RAM size.

00:26:42.070 --> 00:26:46.210
Continuing on the theme of
reducing APK size in RAM,

00:26:46.210 --> 00:26:47.985
you should consider
avoiding memory churn

00:26:47.985 --> 00:26:50.110
by reducing the number of
garbage collection events

00:26:50.110 --> 00:26:51.100
to occur.

00:26:51.100 --> 00:26:56.500
And for this, you should
avoid allocating objects

00:26:56.500 --> 00:26:59.680
in the performance-critical
area of your application.

00:26:59.680 --> 00:27:04.610
And those areas are on layout,
on draw, on major, et cetera.

00:27:11.570 --> 00:27:15.510
I talked about reducing
the memory churn

00:27:15.510 --> 00:27:17.970
by reducing the number
of garbage collection.

00:27:17.970 --> 00:27:20.010
It not only impacts
the memory but it also

00:27:20.010 --> 00:27:22.560
can impact your
app responsiveness

00:27:22.560 --> 00:27:24.730
by eating your app's frame.

00:27:24.730 --> 00:27:27.240
So now in this slide I'm
going to talk about how

00:27:27.240 --> 00:27:28.860
to keep your app responsive.

00:27:28.860 --> 00:27:32.490
And, for that, start
with do not drop data.

00:27:32.490 --> 00:27:35.130
Let's say you are
an email application

00:27:35.130 --> 00:27:38.220
in which [INAUDIBLE]
composing an email,

00:27:38.220 --> 00:27:41.160
and some other
application saves on top.

00:27:41.160 --> 00:27:43.260
In this case, you
want to save data

00:27:43.260 --> 00:27:48.030
so that when your application
comes back again on top,

00:27:48.030 --> 00:27:53.600
you want it to store data so
that user does not lose data.

00:27:53.600 --> 00:27:56.090
Do not expose raw data.

00:27:56.090 --> 00:28:00.320
Consider using content provider,
which is the consistent way

00:28:00.320 --> 00:28:04.610
to sell your data
across application,

00:28:04.610 --> 00:28:07.040
within your application as well.

00:28:07.040 --> 00:28:10.130
Do not interrupt user.

00:28:10.130 --> 00:28:11.690
Consider not to call
a start activity

00:28:11.690 --> 00:28:15.460
from broadcast receiver or
from a background service.

00:28:15.460 --> 00:28:19.880
If possible, consider using
notification manager to set up

00:28:19.880 --> 00:28:23.300
a notification to which you can
come back to your application

00:28:23.300 --> 00:28:26.100
by looking at that notification.

00:28:26.100 --> 00:28:27.900
Got a lot to do?

00:28:27.900 --> 00:28:33.370
Consider doing it in a thread,
maybe in a background thread

00:28:33.370 --> 00:28:36.610
to avoid any long-running
processes running

00:28:36.610 --> 00:28:39.950
in your main thread.

00:28:39.950 --> 00:28:41.920
If possible, you
may also consider

00:28:41.920 --> 00:28:46.030
to use the JavaScribbler
for the processes which are

00:28:46.030 --> 00:28:48.190
going to take longer duration.

00:28:48.190 --> 00:28:50.950
As I mentioned earlier,
it is constraint-aware

00:28:50.950 --> 00:28:58.470
and can scribble your job when
system is processing your job.

00:28:58.470 --> 00:29:03.190
Do not overload signal
activity for the devices of--

00:29:03.190 --> 00:29:04.390
devices.

00:29:04.390 --> 00:29:06.340
You may consider
your application

00:29:06.340 --> 00:29:08.260
as a federation of activity.

00:29:08.260 --> 00:29:13.230
And by doing so, you would
be making your application

00:29:13.230 --> 00:29:14.430
more maintainable.

00:29:14.430 --> 00:29:17.430
And, as a nice side
effect, it will work well

00:29:17.430 --> 00:29:20.690
with the application history
and the backstretch model.

00:29:27.580 --> 00:29:30.490
Continuing on the theme of
keeping your app responsive,

00:29:30.490 --> 00:29:33.970
design your UI so that it works
with different screen sizes.

00:29:33.970 --> 00:29:38.620
Your resources, your images
sort of scale up and down based

00:29:38.620 --> 00:29:42.620
on the screen sizes.

00:29:42.620 --> 00:29:45.800
And, lastly, do
conserve device battery.

00:29:45.800 --> 00:29:48.950
A mobile device is not so
mobile if it is constantly

00:29:48.950 --> 00:29:52.240
connected to the wall charger.

00:29:52.240 --> 00:29:57.730
Two of the main contributors
of the battery drain

00:29:57.730 --> 00:30:00.740
are the processor
and the radio signal.

00:30:00.740 --> 00:30:05.050
So it's important to do as
little processing as possible

00:30:05.050 --> 00:30:09.040
and to use network as
infrequently as possible.

00:30:14.410 --> 00:30:17.140
Now, this brings the
end of our presentation.

00:30:17.140 --> 00:30:20.230
But by no means this
is the [INAUDIBLE] list

00:30:20.230 --> 00:30:23.560
of techniques and
best practices you

00:30:23.560 --> 00:30:25.330
may use in your application.

00:30:25.330 --> 00:30:28.900
To learn about the full list
of practices and techniques,

00:30:28.900 --> 00:30:33.420
you can go to developer.androi
d.com/performance.

00:30:33.420 --> 00:30:37.320
We hope this presentation may
have helped you to learn more

00:30:37.320 --> 00:30:39.570
about the techniques
you can use for making

00:30:39.570 --> 00:30:43.830
your application have a
level for next billion users.

00:30:43.830 --> 00:30:45.030
Thanks a lot.

00:30:45.030 --> 00:30:49.280
[GOOGLE LOGO MUSIC]

