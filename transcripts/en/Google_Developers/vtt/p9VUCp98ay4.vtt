WEBVTT
Kind: captions
Language: en

00:00:00.130 --> 00:00:01.025
ANDREW GERRAND: Hello.

00:00:01.025 --> 00:00:02.500
Hi, everyone.

00:00:02.500 --> 00:00:06.390
My name's Andrew Gerrand,
and I am on the Go Team.

00:00:06.390 --> 00:00:08.660
And I'll just get everyone to
introduce ourselves, starting

00:00:08.660 --> 00:00:10.360
with Robert on the right.

00:00:10.360 --> 00:00:11.890
ROBERT GRIESEMER: Hi, I'm
Robert Griesemer.

00:00:11.890 --> 00:00:13.610
I'm working on the Go Team.

00:00:13.610 --> 00:00:16.680
ROB PIKE: Hi, I'm Rob
Pike and we're all

00:00:16.680 --> 00:00:17.770
working on the Go Team.

00:00:17.770 --> 00:00:20.720
DAVID SYMONDS: I'm
David Symonds.

00:00:20.720 --> 00:00:22.080
IAN TAYLOR: Ian Taylor.

00:00:22.080 --> 00:00:24.300
SAMEER AJMANI: Sameer Ajmani.

00:00:24.300 --> 00:00:26.996
BRAD FITZPATRICK: Brad
Fitzpatrick.

00:00:26.996 --> 00:00:29.830
ANDREW GERRAND: And so this is
basically just a freeform

00:00:29.830 --> 00:00:31.920
session about Go.

00:00:31.920 --> 00:00:35.970
We have a Google Moderator
link online which people

00:00:35.970 --> 00:00:38.660
watching the live stream
can contribute to.

00:00:38.660 --> 00:00:40.380
I don't have the link handy.

00:00:40.380 --> 00:00:43.450
So if you want to find it, just
search for something--

00:00:43.450 --> 00:00:46.110
I'm not sure.

00:00:46.110 --> 00:00:47.460
Good luck.

00:00:47.460 --> 00:00:48.760
You found the live stream
well enough.

00:00:48.760 --> 00:00:51.410
You should be able
to find the link.

00:00:51.410 --> 00:00:54.870
But otherwise, maybe just a
little bit about what's going

00:00:54.870 --> 00:00:56.050
on recently.

00:00:56.050 --> 00:00:59.790
Can I get a show of hands, who
here uses Go regularly?

00:00:59.790 --> 00:01:02.170
Whee, that's great.

00:01:02.170 --> 00:01:03.700
Really gratifying to see.

00:01:03.700 --> 00:01:06.400
So as probably most of you
know, we released our 1.1

00:01:06.400 --> 00:01:07.770
earlier this week.

00:01:07.770 --> 00:01:10.320
That's a really nice
milestone for us.

00:01:10.320 --> 00:01:10.710
Thank you.

00:01:10.710 --> 00:01:13.350
[APPLAUSE]

00:01:13.350 --> 00:01:19.210
About a year on from 1.0, and
we're pretty happy with the

00:01:19.210 --> 00:01:20.860
progress so far.

00:01:20.860 --> 00:01:23.115
It's been really great meeting
people over the past few days

00:01:23.115 --> 00:01:25.910
at I/O, and over the past couple
of days hearing about

00:01:25.910 --> 00:01:26.800
what you guys have been doing.

00:01:26.800 --> 00:01:30.890
But now we'd really like to turn
it over to you and hear

00:01:30.890 --> 00:01:34.470
your questions and tell
you what's going on.

00:01:34.470 --> 00:01:35.670
Does anybody have anything?

00:01:35.670 --> 00:01:36.490
IAN TAYLOR: [INAUDIBLE].

00:01:36.490 --> 00:01:38.310
ANDREW GERRAND: Oh, the
microphone's here.

00:01:38.310 --> 00:01:40.790
We might start with a question
from the Google Moderator.

00:01:40.790 --> 00:01:42.800
NIGEL TAO: So this
is Nigel Tao.

00:01:42.800 --> 00:01:45.890
Also on the Go Team,
just off the video.

00:01:45.890 --> 00:01:48.960
Just for the record, the Google
Moderator link is

00:01:48.960 --> 00:01:57.930
goo.gl/8sG1h in case anyone
wants to know.

00:01:57.930 --> 00:02:00.630
But of course live questions
are welcome.

00:02:00.630 --> 00:02:02.000
We have two microphones up.

00:02:02.000 --> 00:02:05.230
But whilst we're waiting,
I'll just go off

00:02:05.230 --> 00:02:06.260
the top of the moderator.

00:02:06.260 --> 00:02:10.440
So the first question is from
Fulum from South Africa.

00:02:10.440 --> 00:02:11.340
So [? Dee ?]

00:02:11.340 --> 00:02:11.780
[? Vikhov, ?]

00:02:11.780 --> 00:02:12.790
Dimitri [? Minix, ?]

00:02:12.790 --> 00:02:13.240
[? Remy ?]

00:02:13.240 --> 00:02:17.070
[INAUDIBLE], Brad Fitz, et al,
are doing an awesome job of

00:02:17.070 --> 00:02:19.530
tearing apart the runtime and
the standard library and

00:02:19.530 --> 00:02:21.810
putting it back together,
but faster.

00:02:21.810 --> 00:02:23.940
Can you discuss your
big N ideas?

00:02:23.940 --> 00:02:27.380
One less than N less than 5
for making Go programs go

00:02:27.380 --> 00:02:28.630
faster for Go 1.2.

00:02:33.650 --> 00:02:36.210
BRAD FITZPATRICK: I just run
things under a profiler and

00:02:36.210 --> 00:02:37.590
see what's at the top.

00:02:37.590 --> 00:02:40.900
And a lot of the times lately,
I've been seeing that we

00:02:40.900 --> 00:02:42.070
allocate lots of garbage.

00:02:42.070 --> 00:02:43.660
So I've been trying to
get rid of garbage.

00:02:43.660 --> 00:02:47.590
But it was just something I was
doing towards the end when

00:02:47.590 --> 00:02:48.510
there's nothing else to do.

00:02:48.510 --> 00:02:50.660
I don't know how long it'll
remain a focus.

00:02:50.660 --> 00:02:53.050
But it's definitely fun, and
there's a lot of people

00:02:53.050 --> 00:02:54.950
focusing on performance now.

00:02:54.950 --> 00:02:58.730
We can't break APIs, so we can
make things faster with the

00:02:58.730 --> 00:02:59.980
existing APIs.

00:03:02.471 --> 00:03:05.180
ROB PIKE: Well, the tooling
can get a lot better.

00:03:05.180 --> 00:03:10.170
One of the best ways to make
Go programs go faster is to

00:03:10.170 --> 00:03:11.860
control how much garbage
you generate.

00:03:11.860 --> 00:03:14.530
Because the garbage collector,
no matter how good we make it,

00:03:14.530 --> 00:03:17.120
is always going to be
potentially a slow spot.

00:03:17.120 --> 00:03:18.520
Best thing to do is
to avoid garbage.

00:03:18.520 --> 00:03:20.860
So we're worrying about trying
to get the compilers to detect

00:03:20.860 --> 00:03:24.070
more cases where an allocation
can be placed on the stack and

00:03:24.070 --> 00:03:24.870
things like that.

00:03:24.870 --> 00:03:27.180
The compilers are also do better
inlining and better

00:03:27.180 --> 00:03:28.290
optimizations.

00:03:28.290 --> 00:03:30.740
We're also spending a lot of
time looking at the runtime.

00:03:30.740 --> 00:03:33.760
We have a long list of things to
do involving improving how

00:03:33.760 --> 00:03:37.760
the stack is implemented,
how the scheduler works.

00:03:37.760 --> 00:03:39.760
Trying to make it work better
with maybe using lock-free

00:03:39.760 --> 00:03:41.860
algorithms in some parts
of the runtime.

00:03:41.860 --> 00:03:46.000
So the step from Go 1.0 to 1.1
was, depending on your

00:03:46.000 --> 00:03:49.200
program, anywhere from not much
faster, to we've heard

00:03:49.200 --> 00:03:52.160
stories of people running on
big machines seeing 10x in

00:03:52.160 --> 00:03:53.590
some cases.

00:03:53.590 --> 00:03:56.040
But typically 30-40%,
something like that.

00:03:56.040 --> 00:03:58.040
And I'm sure we can get another
significant speedup

00:03:58.040 --> 00:04:00.180
for the next round by
concentrating on the

00:04:00.180 --> 00:04:03.070
internals, and the tooling,
and also the APIs.

00:04:03.070 --> 00:04:07.100
But I want to stress that you
can find ways to make your own

00:04:07.100 --> 00:04:09.220
programs go faster by
using the tools

00:04:09.220 --> 00:04:10.250
that are already available.

00:04:10.250 --> 00:04:12.358
The profiling tools
are very good.

00:04:12.358 --> 00:04:13.206
ANDREW GERRAND: Yeah.

00:04:13.206 --> 00:04:16.260
It's probably worth mentioning
that straight after 1.1,

00:04:16.260 --> 00:04:18.209
immediately all of the people
who've been hacking on the

00:04:18.209 --> 00:04:22.400
runtime jumped in with a whole
lot of more stuff that they've

00:04:22.400 --> 00:04:23.940
had sitting on their
machines, were just

00:04:23.940 --> 00:04:25.370
waiting to mail it out.

00:04:25.370 --> 00:04:27.800
So there's a lot of activity
in that area going on.

00:04:32.560 --> 00:04:35.060
AUDIENCE: Recently there's
been some articles about

00:04:35.060 --> 00:04:37.470
importing source and
being able to

00:04:37.470 --> 00:04:38.850
tag them with versions.

00:04:38.850 --> 00:04:40.530
Do you plan to address
that anytime soon?

00:04:45.196 --> 00:04:47.730
ANDREW GERRAND: This
has come up a lot.

00:04:47.730 --> 00:04:51.800
Because of the way Go Get works,
we use the import parts

00:04:51.800 --> 00:04:53.790
to identify the location of
repositories and then fetch

00:04:53.790 --> 00:04:55.850
code automatically, but
currently there's no way to

00:04:55.850 --> 00:04:57.370
version those things.

00:04:57.370 --> 00:05:02.300
And the idea behind the design
of that system was that people

00:05:02.300 --> 00:05:07.330
would keep the head of their
repositories clean and stable,

00:05:07.330 --> 00:05:09.680
but in practice it obviously
doesn't work like that.

00:05:09.680 --> 00:05:13.800
And I think there's a lot of
space in the greater Go

00:05:13.800 --> 00:05:16.530
ecosystem to introduce better
tooling to make that easier.

00:05:16.530 --> 00:05:19.280
I've seen some really
interesting designs recently

00:05:19.280 --> 00:05:23.860
for Tools that would let you
take a snapshot of the state

00:05:23.860 --> 00:05:28.140
of your work space and then be
able to replicate that state

00:05:28.140 --> 00:05:28.970
in other places.

00:05:28.970 --> 00:05:31.860
So working in teams and
stuff like that.

00:05:31.860 --> 00:05:36.330
But I think it's not a problem
inherent in the design, but

00:05:36.330 --> 00:05:38.630
rather something that just needs
to be finessed more.

00:05:38.630 --> 00:05:40.390
And it's something that
increasingly has been coming

00:05:40.390 --> 00:05:41.040
to our attention.

00:05:41.040 --> 00:05:44.420
It's kind of hard for us because
working on the core we

00:05:44.420 --> 00:05:46.670
don't suffer from
that as much.

00:05:46.670 --> 00:05:48.900
But I can definitely see how
it affects other people.

00:05:48.900 --> 00:05:51.570
It's been hard for us to think
about the problem, as it's not

00:05:51.570 --> 00:05:53.970
a problem that we have
so much ourselves.

00:05:53.970 --> 00:05:55.060
But I think it's something
that's going

00:05:55.060 --> 00:05:56.705
to be solved soon.

00:05:56.705 --> 00:05:58.792
It definitely has my
attention at least.

00:05:58.792 --> 00:06:01.220
AUDIENCE: On a slightly related
note, are there any

00:06:01.220 --> 00:06:04.300
plans to support, say, compiled
Go libraries.

00:06:04.300 --> 00:06:07.430
From Go to use other Go
libraries, as opposed to

00:06:07.430 --> 00:06:10.394
everything just being
static binary?

00:06:13.190 --> 00:06:17.020
ROB PIKE: It's something I'd
certainly like to see.

00:06:17.020 --> 00:06:21.480
It's a tooling issue entirely,
to do Dynamic Link.

00:06:21.480 --> 00:06:23.380
First of all, it does work
with GCC Go today.

00:06:23.380 --> 00:06:25.860
But we don't have any immediate
plans to make it

00:06:25.860 --> 00:06:30.120
work in the GC Compiler
tool chain.

00:06:30.120 --> 00:06:34.000
But we have all the basic
building blocks needed for it,

00:06:34.000 --> 00:06:37.660
so I hope it'll happen
and I think it will.

00:06:37.660 --> 00:06:40.595
AUDIENCE: Thank you.

00:06:40.595 --> 00:06:41.990
AUDIENCE: Hi.

00:06:41.990 --> 00:06:45.440
First off, I'd just like to
say I like the look of Go.

00:06:45.440 --> 00:06:52.390
It seems like a great language
and a good successor to C. I

00:06:52.390 --> 00:06:54.640
don't know if it's been
considered, but personally I'd

00:06:54.640 --> 00:06:57.300
love to see it as an option on
Android for Development.

00:06:57.300 --> 00:07:00.090
I think it would be a
very good fit there.

00:07:00.090 --> 00:07:01.560
That's not the question
though.

00:07:01.560 --> 00:07:04.390
Like many people who use a bunch
of different languages,

00:07:04.390 --> 00:07:06.670
there's some features I'd
love to see in Go.

00:07:06.670 --> 00:07:11.040
And I wonder if they were
considered, and if they were

00:07:11.040 --> 00:07:13.170
decided against for any
particular reason.

00:07:13.170 --> 00:07:17.250
I think the primary one would
be more expressions than

00:07:17.250 --> 00:07:17.600
statements.

00:07:17.600 --> 00:07:22.585
So the "if," the "try," various
language constructs

00:07:22.585 --> 00:07:27.120
are statements in Go, which
means that you need vars

00:07:27.120 --> 00:07:29.780
rather than vowels a lot of the
time and you can't use as

00:07:29.780 --> 00:07:31.270
much immutability.

00:07:31.270 --> 00:07:34.230
Did you consider making
"if" an expression?

00:07:34.230 --> 00:07:37.910
And if you decided
against it, why?

00:07:37.910 --> 00:07:40.235
ROBERT GRIESEMER: I think this
is your [INAUDIBLE].

00:07:40.235 --> 00:07:41.170
ROB PIKE: All right.

00:07:41.170 --> 00:07:43.273
I was trying to fob
that one off.

00:07:46.300 --> 00:07:49.060
I actually really like the
idea of expressions as

00:07:49.060 --> 00:07:51.300
computable things, like "if"
statements and so on.

00:07:51.300 --> 00:07:52.690
I've even implemented similar

00:07:52.690 --> 00:07:55.310
functionality in other languages.

00:07:55.310 --> 00:07:58.350
It didn't really come
up in the design.

00:07:58.350 --> 00:08:00.320
I don't think it was
deliberately left out.

00:08:00.320 --> 00:08:03.200
We were just trying to keep the
control flow really clean

00:08:03.200 --> 00:08:04.690
and simple.

00:08:04.690 --> 00:08:07.760
The control structures, although
at first glance look

00:08:07.760 --> 00:08:09.780
a lot like C or Java or
something like that.

00:08:09.780 --> 00:08:11.150
They're actually quite a
bit simpler-- they've

00:08:11.150 --> 00:08:14.630
been reduced a lot.

00:08:14.630 --> 00:08:18.070
I don't remember consciously
saying we'd want to not do

00:08:18.070 --> 00:08:21.510
that, it just never came about
and I don't feel the

00:08:21.510 --> 00:08:23.050
pressure for it.

00:08:23.050 --> 00:08:25.850
One of the things we did do was
dramatically reduce the

00:08:25.850 --> 00:08:29.930
number of things that from
C would be treatable as

00:08:29.930 --> 00:08:32.510
expressions, like assignments,
pre-increment, post-increment,

00:08:32.510 --> 00:08:33.179
stuff like that.

00:08:33.179 --> 00:08:36.400
And we made those explicitly
statements, because that has a

00:08:36.400 --> 00:08:38.330
very strong effect on the
simplicity of the

00:08:38.330 --> 00:08:39.789
specification.

00:08:39.789 --> 00:08:41.970
You have much less to write
about where things happen,

00:08:41.970 --> 00:08:44.770
when things happen in the order
of evaluation by making

00:08:44.770 --> 00:08:46.640
those not be expressions.

00:08:46.640 --> 00:08:50.550
And almost every C program that
ever went down badly had

00:08:50.550 --> 00:08:53.830
a misuse of that property, so
just taking it away was a

00:08:53.830 --> 00:08:54.900
simplification.

00:08:54.900 --> 00:08:57.700
But as far as making "if"
be an expression, it

00:08:57.700 --> 00:08:58.580
just never came up.

00:08:58.580 --> 00:09:00.790
It wasn't a deliberate
omission.

00:09:00.790 --> 00:09:02.910
ROBERT GRIESEMER: I think one
of the common questions is

00:09:02.910 --> 00:09:05.350
probably the question
mark colon operator.

00:09:05.350 --> 00:09:09.730
And I think that was probably
deliberately left out.

00:09:09.730 --> 00:09:12.140
But if "if" were an expression,
then other

00:09:12.140 --> 00:09:15.030
questions come up and I think
the kind of code you would

00:09:15.030 --> 00:09:17.470
write would start to look
a little bit different.

00:09:17.470 --> 00:09:21.880
And as it is right now, you can
more or less say, unless

00:09:21.880 --> 00:09:25.400
you'd have function calls, of
course, or method calls.

00:09:25.400 --> 00:09:29.200
If you're an expression, it's
essentially an expression

00:09:29.200 --> 00:09:31.825
that's side-effect free.

00:09:31.825 --> 00:09:36.820
But if you have things like
control flowy things in your

00:09:36.820 --> 00:09:38.440
code, then that might
look different.

00:09:38.440 --> 00:09:40.920
It might be different to reason
about those programs.

00:09:40.920 --> 00:09:42.881
I think it would be a
different language.

00:09:42.881 --> 00:09:45.286
AUDIENCE: OK.

00:09:45.286 --> 00:09:49.300
AUDIENCE: So going back into
performance, I actually wanted

00:09:49.300 --> 00:09:52.980
to talk about how Go interfaces
with cgo.

00:09:52.980 --> 00:09:57.050
And I noticed that going from
Go 1.03 to 1.1, the

00:09:57.050 --> 00:09:59.500
performance in terms of
interfacing with cgo improved

00:09:59.500 --> 00:10:00.120
dramatically.

00:10:00.120 --> 00:10:03.400
I saw a huge, almost 30x
performance in certain

00:10:03.400 --> 00:10:06.280
programs that use cgo, which I
though was really freaking

00:10:06.280 --> 00:10:07.850
awesome, actually.

00:10:07.850 --> 00:10:12.020
But I also saw some random bugs
which were not in 1.03

00:10:12.020 --> 00:10:13.820
that were in 1.1.

00:10:13.820 --> 00:10:17.720
Some seg faults in [? Seeland ?]
which I'm still

00:10:17.720 --> 00:10:19.260
working through.

00:10:19.260 --> 00:10:22.240
And in general, I just wanted
to know if you guys had any

00:10:22.240 --> 00:10:24.990
more documentation on how these
things are implemented?

00:10:24.990 --> 00:10:28.480
How implementation changed
from 1.03 to 1.1?

00:10:28.480 --> 00:10:30.620
I took a quick look, and
everything's very broad--

00:10:30.620 --> 00:10:31.860
there's nothing nitty-gritty.

00:10:31.860 --> 00:10:34.280
I know I could always read the
source code, but that's very

00:10:34.280 --> 00:10:36.320
daunting at times.

00:10:36.320 --> 00:10:40.430
So I don't know if you guys
have any white papers or

00:10:40.430 --> 00:10:43.180
research documents?

00:10:43.180 --> 00:10:45.030
SAMEER AJMANI: Specifically for
Seagull, we did beef up

00:10:45.030 --> 00:10:48.010
the docs on cgo quite a bit on
how it works internally.

00:10:48.010 --> 00:10:53.230
If you go and look at
golang.org/cmd/cgo, you go

00:10:53.230 --> 00:10:56.600
down to the bottom, we've added
a couple more pages on

00:10:56.600 --> 00:11:00.900
what it generates and how it
interacts, but there's no

00:11:00.900 --> 00:11:04.940
white paper on how it
all fits together.

00:11:04.940 --> 00:11:07.120
More documentation
is always good.

00:11:07.120 --> 00:11:09.130
Certainly no one's going
to say otherwise.

00:11:09.130 --> 00:11:11.720
ANDREW GERRAND: Actually, I
think that that documentation

00:11:11.720 --> 00:11:13.720
is not actually in
the web page.

00:11:13.720 --> 00:11:17.750
You have to look at doc.go
in the cgo directory.

00:11:17.750 --> 00:11:21.270
And it's a comment past the
package comment that's quite a

00:11:21.270 --> 00:11:24.400
long, detailed discussion
of the implementation.

00:11:24.400 --> 00:11:25.235
So that might be illuminating.

00:11:25.235 --> 00:11:27.590
It was certainly illuminating
to me to read.

00:11:27.590 --> 00:11:28.760
AUDIENCE: OK, cool.

00:11:28.760 --> 00:11:30.201
Thanks.

00:11:30.201 --> 00:11:31.340
AUDIENCE: Thank you.

00:11:31.340 --> 00:11:34.650
I asked a question in the
previous session, and they

00:11:34.650 --> 00:11:36.530
asked me to ask it here.

00:11:36.530 --> 00:11:39.450
Is there any special debugging
or anything we should know

00:11:39.450 --> 00:11:41.715
about with App Engine in Go?

00:11:49.170 --> 00:11:53.170
We can run an App Engine app
locally on our machine.

00:11:53.170 --> 00:11:57.230
Can we use all these tools
to debug there, too?

00:11:57.230 --> 00:12:00.770
DAVID SYMONDS: You can't yet,
but it's on our radar.

00:12:00.770 --> 00:12:04.580
It's coming down the pipeline,
we just have to get to it--

00:12:04.580 --> 00:12:06.310
but yes, coming soon.

00:12:06.310 --> 00:12:09.960
ROB PIKE: We actually want to
make Go be the best language

00:12:09.960 --> 00:12:13.040
for App Engine, and part of that
is making the tool for it

00:12:13.040 --> 00:12:13.780
be really awesome.

00:12:13.780 --> 00:12:16.970
So you should expect to see some
wonderful stuff at some

00:12:16.970 --> 00:12:18.204
point soon.

00:12:18.204 --> 00:12:19.454
How's that?

00:12:21.836 --> 00:12:22.720
AUDIENCE: Hey there.

00:12:22.720 --> 00:12:25.310
I was wondering if you could
just provide a little bit more

00:12:25.310 --> 00:12:29.360
insight as to the extent of
the use of Go at Google.

00:12:29.360 --> 00:12:32.440
The description on the
Go language site

00:12:32.440 --> 00:12:34.230
is relatively brief.

00:12:34.230 --> 00:12:36.600
And it just mentions a couple
things like oh, it's in use at

00:12:36.600 --> 00:12:40.090
YouTube, and it kind of
leaves it at that.

00:12:40.090 --> 00:12:42.800
This ties into a separate
thing that we've had

00:12:42.800 --> 00:12:45.930
discussions about in the office,
where we primarily do

00:12:45.930 --> 00:12:47.820
consulting work for clients.

00:12:47.820 --> 00:12:50.430
And at times we've thought that
Go seemed like a great

00:12:50.430 --> 00:12:53.740
match for what we wanted to do,
but there was discussion

00:12:53.740 --> 00:12:58.060
about how heavily vested Google
was in the language.

00:12:58.060 --> 00:13:00.970
And I hate to invoke the phrase,
but you often hear

00:13:00.970 --> 00:13:03.680
nobody ever got fired
for choosing Java.

00:13:03.680 --> 00:13:07.430
And I really want to advocate
use of Go, but it's been a bit

00:13:07.430 --> 00:13:11.610
of a black box as to how certain
development on it is

00:13:11.610 --> 00:13:13.760
in terms of resources being
allocated to it.

00:13:13.760 --> 00:13:16.480
And I think in recent months
we've seen a lot of really

00:13:16.480 --> 00:13:20.310
promising things and a lot of
great features coming out, so

00:13:20.310 --> 00:13:22.330
I'm willing to stand up
and make a harder

00:13:22.330 --> 00:13:23.520
push for it next time.

00:13:23.520 --> 00:13:25.290
But I'm still curious
to hear a little bit

00:13:25.290 --> 00:13:27.580
about how it's used.

00:13:27.580 --> 00:13:31.050
ROB PIKE: I want to point out
that although Google pays our

00:13:31.050 --> 00:13:33.960
salaries, Go is an open source
project completely.

00:13:33.960 --> 00:13:35.790
So it's a fair question--
we'll answer it.

00:13:35.790 --> 00:13:37.930
But I want to make it clear that
it's very different from

00:13:37.930 --> 00:13:40.760
Java, which was a Sun product
that was pushed by a company,

00:13:40.760 --> 00:13:42.680
had a massive marketing
budget.

00:13:42.680 --> 00:13:45.920
Go is a project that we're
allowed to work on as part of

00:13:45.920 --> 00:13:48.570
working for Google because it
helps Google, which I'll talk

00:13:48.570 --> 00:13:50.830
about in a second, but it is
really an open source project.

00:13:50.830 --> 00:13:54.050
Far more people work on Go
outside Google than at Google,

00:13:54.050 --> 00:13:55.190
by orders of magnitude.

00:13:55.190 --> 00:13:56.840
It's a much, much
bigger number.

00:13:56.840 --> 00:13:59.800
So don't conflate Go and
Java that way, I

00:13:59.800 --> 00:14:02.050
think that's unfair.

00:14:02.050 --> 00:14:05.240
As far as Go's use internally
at Google,

00:14:05.240 --> 00:14:06.980
there's a number of projects--

00:14:06.980 --> 00:14:09.430
Brad could probably talk about
one in particular--

00:14:09.430 --> 00:14:10.390
that are not as well known.

00:14:10.390 --> 00:14:12.520
But there's the YouTube thing.

00:14:12.520 --> 00:14:14.900
Brad talked about
download server.

00:14:14.900 --> 00:14:18.970
There's a tremendous amount of
external facing traffic that

00:14:18.970 --> 00:14:22.170
you don't see as a Go program
because it's a Google service.

00:14:22.170 --> 00:14:25.980
But a lot of bits flow through
Google's production clusters

00:14:25.980 --> 00:14:29.550
serving stuff relevant to
users, and the amount is

00:14:29.550 --> 00:14:30.840
growing rapidly.

00:14:30.840 --> 00:14:32.340
There's a lot of teams
picking it up.

00:14:32.340 --> 00:14:34.090
There's some key infrastructure

00:14:34.090 --> 00:14:35.190
that's built in it.

00:14:35.190 --> 00:14:37.960
We don't talk about it, but we
don't talk about the C++ use

00:14:37.960 --> 00:14:39.530
internally, either--

00:14:39.530 --> 00:14:41.550
it's internal stuff.

00:14:41.550 --> 00:14:44.280
But the growth is really highly

00:14:44.280 --> 00:14:46.050
important, and I think strategic.

00:14:46.050 --> 00:14:47.090
Although that's just
me talking,

00:14:47.090 --> 00:14:48.097
that's not Google talking.

00:14:48.097 --> 00:14:50.206
Do you want to talk
about stuff, Brad?

00:14:50.206 --> 00:14:51.580
BRAD FITZPATRICK: Oh, sure.

00:14:51.580 --> 00:14:54.500
I was going to talk about the
Google download server this

00:14:54.500 --> 00:14:56.920
year, but I think I'll be
talking about it later.

00:14:56.920 --> 00:14:59.490
But all the Google download
server was

00:14:59.490 --> 00:15:01.820
rewritten from C++ to Go.

00:15:01.820 --> 00:15:05.030
And I'm working with three or
four other teams right now

00:15:05.030 --> 00:15:08.610
that are porting large systems
from C++ to Go.

00:15:08.610 --> 00:15:12.200
Just about every big system
at Google generally has a

00:15:12.200 --> 00:15:13.500
lifetime of a couple years.

00:15:13.500 --> 00:15:16.430
And when that comes up time to
rewrite it or redesign it, a

00:15:16.430 --> 00:15:19.690
lot of those teams are now
asking themselves why they're

00:15:19.690 --> 00:15:21.210
writing in C++.

00:15:21.210 --> 00:15:25.182
And a lot of them are picking
Go, because--

00:15:25.182 --> 00:15:28.170
I mean, if you guys write
Go you know why.

00:15:28.170 --> 00:15:29.870
Sometimes you don't
really need C++.

00:15:29.870 --> 00:15:32.850
It just happens that as a
historical accident Google had

00:15:32.850 --> 00:15:35.505
lots of C++ libraries, so just
everyone wrote in C++.

00:15:38.155 --> 00:15:40.240
IAN TAYLOR: I was recently
looking at the numbers, and

00:15:40.240 --> 00:15:43.330
over the last year and a half
the use of Go at Google has

00:15:43.330 --> 00:15:44.580
gone up by an order
of magnitude.

00:15:47.520 --> 00:15:51.658
I can't tell you the numbers,
but it is going up.

00:15:51.658 --> 00:15:52.150
AUDIENCE: Great.

00:15:52.150 --> 00:15:55.206
Thank you.

00:15:55.206 --> 00:15:59.050
AUDIENCE: So Go on App Engine,
unless there's been an

00:15:59.050 --> 00:16:02.260
announcement recently, is
still experimental?

00:16:02.260 --> 00:16:05.690
And full tech search on App
Engine is still experimental,

00:16:05.690 --> 00:16:08.880
so I'm probably asking
a nexus of extremely

00:16:08.880 --> 00:16:09.780
experimental questions.

00:16:09.780 --> 00:16:14.790
But there seem to be full tech
search docs stubs for Go on

00:16:14.790 --> 00:16:16.350
App Engine.

00:16:16.350 --> 00:16:20.130
Is that supported in an
experimental sense and just

00:16:20.130 --> 00:16:20.850
not documented?

00:16:20.850 --> 00:16:24.520
Or is it not even possible
to use at this point,

00:16:24.520 --> 00:16:28.350
and can we get it?

00:16:28.350 --> 00:16:31.880
DAVID SYMONDS: Go being
experimental, we don't see it

00:16:31.880 --> 00:16:38.830
that way, our team, to a degree
that the software we're

00:16:38.830 --> 00:16:42.590
putting out, we are standing
behind and not going to change

00:16:42.590 --> 00:16:43.430
randomly and so on.

00:16:43.430 --> 00:16:46.450
So we're not treating it as an
experiment in that sense.

00:16:46.450 --> 00:16:48.770
It means that when we support
APIs, we want to come up with

00:16:48.770 --> 00:16:51.110
a good API design, one
that we're happy to

00:16:51.110 --> 00:16:53.790
stick behind for years.

00:16:53.790 --> 00:16:58.540
We do have a full tech search
API being worked on.

00:16:58.540 --> 00:17:02.070
It's just not quite done
yet, but it's coming.

00:17:02.070 --> 00:17:04.356
AUDIENCE: Thank you.

00:17:04.356 --> 00:17:05.260
AUDIENCE: Hi.

00:17:05.260 --> 00:17:08.859
So, a few months ago I picked up
a Chromebook about the time

00:17:08.859 --> 00:17:13.150
that I rediscovered Go and
started playing with both of

00:17:13.150 --> 00:17:14.319
them and started going
through the tour.

00:17:14.319 --> 00:17:18.660
And one of the things that I
realized is that they really

00:17:18.660 --> 00:17:20.290
fit really well together.

00:17:20.290 --> 00:17:23.619
Go would be a great platform
to be running on top of a

00:17:23.619 --> 00:17:24.660
Chromebook.

00:17:24.660 --> 00:17:27.480
And, in fact, you might even be
able to make a shell out of

00:17:27.480 --> 00:17:29.970
that and replace
Kosh with Gosh.

00:17:29.970 --> 00:17:34.340
And you have already a really
strong metaphor of channels

00:17:34.340 --> 00:17:38.350
with co-routines or Go
routines being the

00:17:38.350 --> 00:17:40.630
applications that you could
actually be launching.

00:17:40.630 --> 00:17:42.920
And the only thing that's really
holding that back, I

00:17:42.920 --> 00:17:44.680
think, is that there's
not really a script

00:17:44.680 --> 00:17:46.600
interpreter for Go.

00:17:46.600 --> 00:17:49.565
And I'm wondering if that's even
a reasonable idea, or if

00:17:49.565 --> 00:17:54.800
it's a good idea, or if it's
just completely off the wall?

00:17:54.800 --> 00:17:57.610
ROBERT GRIESEMER: I think we
actually had once a partial

00:17:57.610 --> 00:17:59.930
interpreter that was
a prototype.

00:17:59.930 --> 00:18:04.140
And I know at least of one
internal project where

00:18:04.140 --> 00:18:09.750
somebody wrote a package which
you can consider something

00:18:09.750 --> 00:18:15.840
like a Go script thingy which
allowed you to run a piece of

00:18:15.840 --> 00:18:19.320
code that you would type in
and it behaved like an

00:18:19.320 --> 00:18:23.030
interpreter, but that's not
quite what you probably want.

00:18:23.030 --> 00:18:27.310
I think it's a feasible thing,
it's just not done--

00:18:27.310 --> 00:18:32.395
available in a public forum
that's really usable.

00:18:32.395 --> 00:18:35.610
AUDIENCE: I see it as a great
opportunity to bring a lot of

00:18:35.610 --> 00:18:40.850
developers and engaging with
Go and expand the audience.

00:18:40.850 --> 00:18:43.682
It seems like a pretty
decent fit.

00:18:43.682 --> 00:18:45.400
ROBERT GRIESEMER: I think
there's a bunch of questions

00:18:45.400 --> 00:18:47.400
that need to be answered when
you do something like that.

00:18:47.400 --> 00:18:50.710
Because most languages where you
have an interpreter have a

00:18:50.710 --> 00:18:53.660
particular model around
that interpreter.

00:18:53.660 --> 00:18:58.880
And, say, Lisp or something like
that which is really sort

00:18:58.880 --> 00:19:03.970
of expression-oriented, one
after the other one.

00:19:03.970 --> 00:19:07.180
In Go you have the concept of a
package and things that are

00:19:07.180 --> 00:19:09.730
simultaneously initialized,
et cetera.

00:19:09.730 --> 00:19:12.980
So questions like that need to
be answered-- what does that

00:19:12.980 --> 00:19:15.780
mean having interpreter
in that context?

00:19:20.624 --> 00:19:23.620
NIGEL TAO: It's just the next
question from the moderator

00:19:23.620 --> 00:19:25.240
from Dave Cheney.

00:19:25.240 --> 00:19:27.910
Putting aside the Go one
guarantee, if there was one

00:19:27.910 --> 00:19:30.330
thing you could remove from the
language what would it be?

00:19:34.794 --> 00:19:36.830
ROB PIKE: We usually get
told to put things in,

00:19:36.830 --> 00:19:39.180
not take them out.

00:19:39.180 --> 00:19:42.430
I'm unhappy with some things,
but we can't fix them.

00:19:42.430 --> 00:19:46.320
I was never a fan of the way the
ampersand stuff works to

00:19:46.320 --> 00:19:48.520
take the address of a
[? stroke ?] because it's kind

00:19:48.520 --> 00:19:51.720
of special-casey and bugs me,
although I admit it's very

00:19:51.720 --> 00:19:53.230
nice to use.

00:19:53.230 --> 00:19:57.950
I think that the number of ways
you can declare something

00:19:57.950 --> 00:20:01.040
is too large and too messy and
needs to be completely

00:20:01.040 --> 00:20:03.610
rethought and people
get confused by

00:20:03.610 --> 00:20:05.350
it, so that's something.

00:20:05.350 --> 00:20:09.380
There's also an unfortunate
thing around the difference

00:20:09.380 --> 00:20:12.190
between a null value and a null
interface that confuses

00:20:12.190 --> 00:20:16.430
people a lot, and that probably
could use a rethink.

00:20:16.430 --> 00:20:17.750
There's not a lot of things I
would take out, but there are

00:20:17.750 --> 00:20:19.610
certainly things I
would change if I

00:20:19.610 --> 00:20:21.040
were starting over.

00:20:21.040 --> 00:20:22.290
You probably have a long list.

00:20:24.824 --> 00:20:26.370
ROBERT GRIESEMER: Not
necessarily a long list, but I

00:20:26.370 --> 00:20:30.360
think the number of declarations
of a variable, as

00:20:30.360 --> 00:20:32.630
Rob mentioned, is
something that I

00:20:32.630 --> 00:20:33.870
think needs to be rethought.

00:20:33.870 --> 00:20:36.660
There's just too many ways
to do the same thing.

00:20:36.660 --> 00:20:41.090
The colon equal operator that
allows you to, quote unquote,

00:20:41.090 --> 00:20:46.030
redeclare a variable, is very
convenient, I admit, but it

00:20:46.030 --> 00:20:49.680
also introduces a whole
bunch of questions.

00:20:49.680 --> 00:20:51.700
In the beginning it introduced
a whole bunch of bugs that we

00:20:51.700 --> 00:20:56.650
now circumvent a little bit
because the compiler gives you

00:20:56.650 --> 00:20:57.600
great warnings.

00:20:57.600 --> 00:21:00.390
But still, I actually have to
think twice every single time

00:21:00.390 --> 00:21:03.100
I redeclare a variable that
happens to be also a parameter

00:21:03.100 --> 00:21:07.745
of a function, making sure that
I'm really using the same

00:21:07.745 --> 00:21:08.410
variable again.

00:21:08.410 --> 00:21:10.880
So this is something that I
think we can do better.

00:21:13.610 --> 00:21:15.010
There is also a few issues with

00:21:15.010 --> 00:21:18.435
embedding of types instructs.

00:21:22.810 --> 00:21:25.830
There's some unresolved issues
there I think that maybe we

00:21:25.830 --> 00:21:27.566
can do better.

00:21:27.566 --> 00:21:29.880
IAN TAYLOR: Personally, I
think I might drop named

00:21:29.880 --> 00:21:32.500
result parameters.

00:21:32.500 --> 00:21:35.810
I think they were a good idea,
but I think especially in

00:21:35.810 --> 00:21:38.440
conjunction with colon equals,
I think they've led to a

00:21:38.440 --> 00:21:39.600
certain degree of confusion.

00:21:39.600 --> 00:21:42.670
And an idea that Russ
suggested, we

00:21:42.670 --> 00:21:44.210
need the Syscall package.

00:21:44.210 --> 00:21:47.930
But I don't know if we need to
provide the same compatibility

00:21:47.930 --> 00:21:50.040
guarantee for the Syscall
package because that's

00:21:50.040 --> 00:21:51.870
essentially an interface between
the language and the

00:21:51.870 --> 00:21:53.720
system and systems change.

00:21:53.720 --> 00:21:56.190
And we've essentially promised
that we're going to be

00:21:56.190 --> 00:22:00.722
compatible with all future
systems, and that's difficult.

00:22:00.722 --> 00:22:04.180
DAVID SYMONDS: I'd remove the
complement of the name return

00:22:04.180 --> 00:22:06.630
values, which is the naked
return statement.

00:22:06.630 --> 00:22:09.010
So if you know your return
values and just write return,

00:22:09.010 --> 00:22:10.710
you'll return whatever
those values are.

00:22:10.710 --> 00:22:13.520
And I'd say a lot of people are
getting those wrong and I

00:22:13.520 --> 00:22:18.944
don't think it's as much
a saving as it looks.

00:22:18.944 --> 00:22:22.870
IAN TAYLOR: I would change the
in range loops when you

00:22:22.870 --> 00:22:24.430
declare variables.

00:22:24.430 --> 00:22:27.390
The variable is reused in each
iteration of the loop which

00:22:27.390 --> 00:22:31.720
has zero actual benefit in real
code and can only ever

00:22:31.720 --> 00:22:35.610
create bugs where you
accidentally close over that

00:22:35.610 --> 00:22:38.636
variable inadvertently and it
gets reused in the wrong part

00:22:38.636 --> 00:22:40.462
of the loop necessarily.

00:22:40.462 --> 00:22:42.690
And that was something we should
have fixed in Go 1.0,

00:22:42.690 --> 00:22:43.940
but didn't.

00:22:47.170 --> 00:22:49.748
There's a Go vet thing that
catches a lot of uses of that

00:22:49.748 --> 00:22:51.580
now, so that's something.

00:22:55.045 --> 00:22:57.890
AUDIENCE: I'd like to thank you
for sticking together the

00:22:57.890 --> 00:23:00.730
two languages that I used in
the 1980s, which was C and

00:23:00.730 --> 00:23:03.550
occam, into something so I can
actually dig out some more

00:23:03.550 --> 00:23:06.570
brain cells to figure
that out.

00:23:06.570 --> 00:23:08.770
I got a more modern
question though.

00:23:08.770 --> 00:23:11.970
I just got these Google Glass
things and I'm about to write

00:23:11.970 --> 00:23:12.880
some code for it.

00:23:12.880 --> 00:23:18.270
Should I write Glass code using
Go, or should I be off

00:23:18.270 --> 00:23:20.880
[? shucking ?] all of the
examples and doing Java like

00:23:20.880 --> 00:23:24.400
everyone else is?

00:23:24.400 --> 00:23:26.105
Have you heard of anyone
else trying to do

00:23:26.105 --> 00:23:27.360
Glass stuff in Go?

00:23:27.360 --> 00:23:28.625
BRAD FITZPATRICK: Are you
talking about the Mirror API?

00:23:28.625 --> 00:23:28.990
AUDIENCE: Yeah.

00:23:28.990 --> 00:23:31.590
BRAD FITZPATRICK: That should
work fine in Go.

00:23:31.590 --> 00:23:34.640
The Go client library for it
is auto-generated from the

00:23:34.640 --> 00:23:37.560
same JSON description of the
API as everything else.

00:23:37.560 --> 00:23:40.760
ANDREW GERRAND: And I've
reviewed code by some of the

00:23:40.760 --> 00:23:42.950
Glass team that have
written Go code.

00:23:42.950 --> 00:23:45.120
So they're using it, so I think
you should as well.

00:23:45.120 --> 00:23:48.230
BRAD FITZPATRICK: We actually
had a bug in the API generator

00:23:48.230 --> 00:23:49.740
I wrote, and it was actually
generating

00:23:49.740 --> 00:23:52.050
malformed Mirror APIs.

00:23:52.050 --> 00:23:55.290
And then somebody on the Glass
team mailed me a patch to the

00:23:55.290 --> 00:23:58.090
Go generator, so they've
used it at least.

00:23:58.090 --> 00:23:59.910
And I know our friend said
he wrote a little Hello

00:23:59.910 --> 00:24:01.180
World for his Glass.

00:24:01.180 --> 00:24:03.970
AUDIENCE: Well, I'll probably
dive in in the next few weeks.

00:24:03.970 --> 00:24:05.220
Thanks.

00:24:07.295 --> 00:24:08.150
AUDIENCE: Hi.

00:24:08.150 --> 00:24:10.850
I work at a company where we're
trying to standardize

00:24:10.850 --> 00:24:14.770
our new service side
API on Google Go.

00:24:14.770 --> 00:24:17.000
And unfortunately the company's
full of Ruby

00:24:17.000 --> 00:24:20.680
fanatics, and so we need some
kind of migration strategy of

00:24:20.680 --> 00:24:25.550
how a software server written
in Google Go can communicate

00:24:25.550 --> 00:24:28.700
with a software server
written in Ruby.

00:24:28.700 --> 00:24:32.160
Looking your RPC package, it
looks like it's mostly made

00:24:32.160 --> 00:24:34.930
for Go code to talk
to Go code.

00:24:34.930 --> 00:24:37.840
Other than the REST API, is
there any other solutions for

00:24:37.840 --> 00:24:41.242
communicating across to
another language?

00:24:41.242 --> 00:24:44.700
DAVID SYMONDS: I can recommend
using JSON RPC if you're not

00:24:44.700 --> 00:24:48.200
comfortable using RESTs that'll
JSON encode structures

00:24:48.200 --> 00:24:50.886
that you can send over HTTP.

00:24:50.886 --> 00:24:52.480
AUDIENCE: Is there any
other solution other

00:24:52.480 --> 00:24:54.540
than JSON as well?

00:24:54.540 --> 00:24:56.570
IAN TAYLOR: You could
use BSON.

00:24:56.570 --> 00:24:59.250
[LAUGHTER]

00:24:59.250 --> 00:25:01.000
Serious response.

00:25:01.000 --> 00:25:04.790
Also, I think Ruby programmers
tend to be pretty comfortable

00:25:04.790 --> 00:25:08.030
with the REST API,
in my experience.

00:25:08.030 --> 00:25:10.630
Go's HTTP package gives
you great facility for

00:25:10.630 --> 00:25:13.420
implementing and connecting
to those.

00:25:13.420 --> 00:25:16.020
That would be the most natural
thing, in my opinion.

00:25:18.650 --> 00:25:23.130
From what I've seen with Ruby
programmers, a lot of our most

00:25:23.130 --> 00:25:25.700
enthusiastic Go programmers in
the open source community are

00:25:25.700 --> 00:25:27.220
ex-Ruby programmers.

00:25:27.220 --> 00:25:30.695
So I think it's an easy sell
for Rubyists sometimes.

00:25:35.830 --> 00:25:38.040
AUDIENCE: Hello again.

00:25:38.040 --> 00:25:41.210
I think the thing that attracted
me the most to using

00:25:41.210 --> 00:25:43.710
Go or learning more about it was
the fact that it was the

00:25:43.710 --> 00:25:46.680
first language I saw that
explicitly acknowledged that

00:25:46.680 --> 00:25:49.660
the environment in which most
modern software runs is

00:25:49.660 --> 00:25:53.400
changed considerably from
traditional systems.

00:25:53.400 --> 00:25:56.370
And the concurrency packages and
structures, I think, are

00:25:56.370 --> 00:26:00.010
probably the thing that attracts
the most attention.

00:26:00.010 --> 00:26:01.790
I was wondering if you could
just give us a little bit of

00:26:01.790 --> 00:26:05.620
insight into anything that might
be upcoming in terms of

00:26:05.620 --> 00:26:09.370
concurrency structures and
things that encourage more

00:26:09.370 --> 00:26:13.202
easily facilitated
parallelism.

00:26:13.202 --> 00:26:17.850
ROB PIKE: There's nothing
actually planned.

00:26:17.850 --> 00:26:21.040
Go happened in part because
someone asked me to give a

00:26:21.040 --> 00:26:24.250
talk about an old concurrent
language I did at Google.

00:26:24.250 --> 00:26:26.840
You can see it on YouTube,
I think.

00:26:26.840 --> 00:26:28.860
And then I went back to my
office and I tried to do it in

00:26:28.860 --> 00:26:32.120
C++ and it was too frustrating,
so it sort of

00:26:32.120 --> 00:26:32.660
planted a seed.

00:26:32.660 --> 00:26:35.130
And it was only within a year,
I think, that we started

00:26:35.130 --> 00:26:37.080
talking about doing Go.

00:26:37.080 --> 00:26:39.690
One of the things that I'd
like to see developed, it

00:26:39.690 --> 00:26:43.610
hasn't happened yet, and I've
played with it a little bit,

00:26:43.610 --> 00:26:48.430
is the ability to use these
primitives to cross a network.

00:26:48.430 --> 00:26:51.975
Some people in the outside have
developed some stuff, and

00:26:51.975 --> 00:26:53.990
I wrote a package a few years
ago which I was never happy

00:26:53.990 --> 00:26:57.200
with, called NetChan which is
still around, but I don't

00:26:57.200 --> 00:26:58.890
recommend it.

00:26:58.890 --> 00:27:01.390
The guy at Tumblr whose name
I can't pronounce--

00:27:01.390 --> 00:27:01.835
[? ANDREW GERRAND: Putan ?]

00:27:01.835 --> 00:27:02.280
[? Mamunkov. ?]

00:27:02.280 --> 00:27:05.200
ROB PIKE: He can
pronounce it--

00:27:05.200 --> 00:27:07.860
had wrote a system called Go
Circuit, I think, which he

00:27:07.860 --> 00:27:10.100
just open sourced which lets
you do some of that and I

00:27:10.100 --> 00:27:11.880
think there's a lot
to be done there.

00:27:11.880 --> 00:27:13.670
It's one place where, for
example, Erlang does a

00:27:13.670 --> 00:27:16.740
beautiful job and we don't
do a job at all.

00:27:16.740 --> 00:27:22.760
I'd also like to see packages
develop that are as much a

00:27:22.760 --> 00:27:25.580
pattern as like in Sameer's
talk, or in the talk I gave

00:27:25.580 --> 00:27:29.390
last year where you see fan
in, fan out, multiplexing,

00:27:29.390 --> 00:27:33.240
load balancing, timeouts,
aborts, cancellations.

00:27:33.240 --> 00:27:36.750
I think some of that could be
librarified, but the language

00:27:36.750 --> 00:27:40.250
isn't strong enough to do it yet
and I would really like to

00:27:40.250 --> 00:27:43.480
see a way to make that nice.

00:27:43.480 --> 00:27:46.470
There's some new stuff in Go
1.1 about reflection on

00:27:46.470 --> 00:27:49.415
channels that makes it maybe
possible to write those now,

00:27:49.415 --> 00:27:51.500
and it might be worth trying.

00:27:51.500 --> 00:27:52.610
No actual plans.

00:27:52.610 --> 00:27:53.160
SAMEER AJMANI: Yeah.

00:27:53.160 --> 00:27:56.400
Just to echo and expand on
that, I think we're still

00:27:56.400 --> 00:27:59.050
discovering what you can do
with Go with respect to

00:27:59.050 --> 00:27:59.570
concurrency.

00:27:59.570 --> 00:28:02.110
That as we gain more experience
with how channels

00:28:02.110 --> 00:28:04.050
and selecting Go routines
fit together,

00:28:04.050 --> 00:28:05.580
patterns are evolving.

00:28:05.580 --> 00:28:08.630
They're showing up and we
say, how do I do a send?

00:28:08.630 --> 00:28:10.800
But the receiver might have
exited, and therefore I need

00:28:10.800 --> 00:28:12.480
to condition it in
the right way.

00:28:12.480 --> 00:28:14.260
There's a lot of little
things like this.

00:28:14.260 --> 00:28:17.010
You can even write micro
patterns in your code which

00:28:17.010 --> 00:28:21.552
allow you to handle these funny
cases and change the way

00:28:21.552 --> 00:28:24.560
you think about how your code
is executing and how the

00:28:24.560 --> 00:28:26.100
different components
are interacting.

00:28:26.100 --> 00:28:28.260
BRAD FITZPATRICK: Sameer
actually ran into my office

00:28:28.260 --> 00:28:31.280
the other day all excited that
he had found a new pattern in

00:28:31.280 --> 00:28:33.570
Go and he wanted to describe
it and give it a name.

00:28:33.570 --> 00:28:34.850
He went through and
described it all.

00:28:34.850 --> 00:28:37.350
And I was like oh, no, David
did that months ago.

00:28:37.350 --> 00:28:40.575
He was like, oh, bummer.

00:28:40.575 --> 00:28:42.060
SAMEER AJMANI: It really
is fun to find

00:28:42.060 --> 00:28:42.820
these things, actually.

00:28:42.820 --> 00:28:46.070
The more you play with it, and
the more you compose Go

00:28:46.070 --> 00:28:48.370
routines and have them
communicate, you really do

00:28:48.370 --> 00:28:51.320
find some interesting ways to
plug these things together and

00:28:51.320 --> 00:28:53.261
we're still learning.

00:28:53.261 --> 00:28:55.431
AUDIENCE: Great, thank you.

00:28:55.431 --> 00:28:57.490
NIGEL TAO: Good day again,
back to the moderator.

00:28:57.490 --> 00:29:01.650
From Carl Lemons, it has been
said that post-Go 1.0 the Go

00:29:01.650 --> 00:29:03.550
Team was spending more
time writing apps in

00:29:03.550 --> 00:29:04.675
libraries in Go.

00:29:04.675 --> 00:29:06.850
Can you talk about your
experiences with this?

00:29:06.850 --> 00:29:09.720
Have you discovered anything
particularly surprising, fun,

00:29:09.720 --> 00:29:10.970
or problematic?

00:29:18.827 --> 00:29:21.070
BRAD FITZPATRICK: The Garbage
Collector could use some work.

00:29:21.070 --> 00:29:23.010
But we actually have people
working on the Garbage

00:29:23.010 --> 00:29:25.255
Collector now, so that's good.

00:29:25.255 --> 00:29:28.400
ROB PIKE: And the Runtime
Scheduler, too.

00:29:28.400 --> 00:29:32.315
The general run time which
includes the Garbage

00:29:32.315 --> 00:29:34.780
Collector, the scheduler, the
implementation of channels,

00:29:34.780 --> 00:29:37.900
and maps, and all that
stuff, we knew.

00:29:37.900 --> 00:29:40.400
So it wasn't surprising,
but it was problematic.

00:29:40.400 --> 00:29:43.620
It was really the weak point
of the whole ecosystem.

00:29:43.620 --> 00:29:46.450
And most of the performance
improvements that have come in

00:29:46.450 --> 00:29:48.620
the past year have been because
of developments in

00:29:48.620 --> 00:29:52.640
that area and there's a lot
more to come, so that was

00:29:52.640 --> 00:29:53.150
interesting.

00:29:53.150 --> 00:29:55.450
We also found that the better
the tools got, the better our

00:29:55.450 --> 00:29:58.230
understanding of the programs
got, and therefore the more

00:29:58.230 --> 00:30:01.780
stuff we could see and
fix or change,

00:30:01.780 --> 00:30:03.920
and we're still learning.

00:30:03.920 --> 00:30:06.710
The language in general is young
enough that there really

00:30:06.710 --> 00:30:08.295
isn't a Go expert yet.

00:30:08.295 --> 00:30:12.815
DAVID SYMONDS: Kind of related
to that, pre-Go 1.0 when we

00:30:12.815 --> 00:30:14.750
were still making changes to
the language and to the

00:30:14.750 --> 00:30:18.730
standard libraries, Russ Cox
made a tool called Go Fix that

00:30:18.730 --> 00:30:20.180
you could run over
source code.

00:30:20.180 --> 00:30:22.375
It would read the source code
in, do some manipulation of

00:30:22.375 --> 00:30:25.200
the VAC and then write
it back out again.

00:30:25.200 --> 00:30:31.070
And that tool really didn't
have any use post-Go 1.0,

00:30:31.070 --> 00:30:33.530
because at that point we stopped
changing the language

00:30:33.530 --> 00:30:34.940
and libraries.

00:30:34.940 --> 00:30:38.600
But inside Google we found it
really great for doing very

00:30:38.600 --> 00:30:40.510
large scale cleanups.

00:30:40.510 --> 00:30:43.130
The same [INAUDIBLE] tooling
translates great so we can

00:30:43.130 --> 00:30:47.200
evolve our code inside Google
that doesn't have that

00:30:47.200 --> 00:30:50.390
compatibility guarantee
restriction on it using the

00:30:50.390 --> 00:30:51.880
same tools.

00:30:51.880 --> 00:30:55.850
And it's great-- we can clean
up millions of lines of code

00:30:55.850 --> 00:30:57.100
very easily.

00:30:59.106 --> 00:31:02.440
ROB PIKE: And Go Fix is
an example of a source

00:31:02.440 --> 00:31:03.840
transformation tool.

00:31:03.840 --> 00:31:05.870
And Go's library is mostly
because of the work Robert's

00:31:05.870 --> 00:31:11.450
done has this ability to write
amazing source transformation

00:31:11.450 --> 00:31:12.600
programs that pick [INAUDIBLE]

00:31:12.600 --> 00:31:16.720
up, make some change to it,
write it back out again in a

00:31:16.720 --> 00:31:21.060
way that is not only safe, but
also neatly formatted and

00:31:21.060 --> 00:31:21.950
performant.

00:31:21.950 --> 00:31:23.640
And we're going to see
more and more of

00:31:23.640 --> 00:31:24.220
those kind of tools.

00:31:24.220 --> 00:31:27.810
I think we've barely scratched
the surface on that.

00:31:27.810 --> 00:31:33.330
AUDIENCE: As someone new to
Go, you speak of micro

00:31:33.330 --> 00:31:34.690
patterns and things like that.

00:31:34.690 --> 00:31:37.810
Beyond just basic language,
documentation and API docks,

00:31:37.810 --> 00:31:43.210
where would you recommend to go
to learn more idiomatic Go

00:31:43.210 --> 00:31:46.426
and Go patterns and
things like that?

00:31:46.426 --> 00:31:48.130
ANDREW GERRAND: I would
recommend if you go to

00:31:48.130 --> 00:31:52.050
talks.golang.org, there's, for
instance, Sameer's talk from

00:31:52.050 --> 00:31:56.290
today, and David's, and Rob's
talk on concurrency patterns

00:31:56.290 --> 00:31:59.530
last year, and all those things
are a great resource.

00:31:59.530 --> 00:32:04.640
The Go blog has a long history
of articles that talk about

00:32:04.640 --> 00:32:07.300
all kinds of areas of Go
idiom, and we intend to

00:32:07.300 --> 00:32:08.550
continue writing
those articles.

00:32:11.512 --> 00:32:13.400
DAVID SYMONDS: Reading
the standard library.

00:32:13.400 --> 00:32:15.010
ANDREW GERRAND: Oh yeah, and
reading the standard library

00:32:15.010 --> 00:32:18.960
is a great way to actually--

00:32:18.960 --> 00:32:21.640
a lot of it is extremely well
documented internally.

00:32:21.640 --> 00:32:23.670
It's very clean,
very readable.

00:32:23.670 --> 00:32:26.070
And a lot of people have told me
that's how they got started

00:32:26.070 --> 00:32:28.630
learning Go, just by
reading that stuff.

00:32:28.630 --> 00:32:31.780
ROB PIKE: One of the recent
changes, I think it's been

00:32:31.780 --> 00:32:34.152
live for quite a while but it's
definitely part of Go

00:32:34.152 --> 00:32:37.820
1.1, is that we've pushed a
lot of examples into the

00:32:37.820 --> 00:32:42.290
documentation that are not only
visible and tested when

00:32:42.290 --> 00:32:46.776
you build the package, but if
you go to Go.doc, or at least

00:32:46.776 --> 00:32:49.520
at golang.org, and look at the
documents, the examples are

00:32:49.520 --> 00:32:51.490
actually executable right
on the web browser.

00:32:51.490 --> 00:32:53.600
And if you see an example that's
close to what you want,

00:32:53.600 --> 00:32:55.933
you can play with it in
the browser, modify it

00:32:55.933 --> 00:32:56.470
to do what you want.

00:32:56.470 --> 00:32:58.310
Run it, check it and all that,
and then just grab that code

00:32:58.310 --> 00:33:01.350
and use it, and that's another
good learning library thing.

00:33:01.350 --> 00:33:03.060
And of course you know about
the tour, I assume?

00:33:03.060 --> 00:33:03.850
Tour [INAUDIBLE]?

00:33:03.850 --> 00:33:04.760
ANDREW GERRAND: Yeah.

00:33:04.760 --> 00:33:08.020
We really want to improve
all of this stuff.

00:33:08.020 --> 00:33:11.250
I think it's already pretty
decent, particularly for a

00:33:11.250 --> 00:33:12.370
language as young as it is.

00:33:12.370 --> 00:33:16.590
But I certainly have a lot of
ambition to broaden the scope

00:33:16.590 --> 00:33:19.590
of our documentation and really
try and share as much

00:33:19.590 --> 00:33:21.750
of our experience writing
Go code as possible.

00:33:21.750 --> 00:33:22.610
AUDIENCE: Cool.

00:33:22.610 --> 00:33:24.602
Thanks.

00:33:24.602 --> 00:33:25.340
AUDIENCE: Hey.

00:33:25.340 --> 00:33:28.240
So I kind of feel like a bastard
for asking this,

00:33:28.240 --> 00:33:30.580
especially after you worked
so hard on Go 1.1.

00:33:30.580 --> 00:33:35.730
But I've been noticing a few
inconsistencies across

00:33:35.730 --> 00:33:38.390
packages which can, of course,
only be fixed with introducing

00:33:38.390 --> 00:33:39.550
breaking changes.

00:33:39.550 --> 00:33:41.230
So I was wondering,
are you already

00:33:41.230 --> 00:33:42.690
collecting stuff like that?

00:33:42.690 --> 00:33:47.215
And is Go 2.0 in your head
even a thing right now?

00:33:47.215 --> 00:33:50.710
ROB PIKE: We know lots of things
we'd like to break.

00:33:50.710 --> 00:33:55.060
And we have a list of things,
some are on the issue tracker

00:33:55.060 --> 00:33:58.730
that we would fix or least think
about fixing in Go 2.0.

00:33:58.730 --> 00:34:01.560
But Go 2.0 is not on the horizon
in the sense that

00:34:01.560 --> 00:34:02.780
we're actively designing it.

00:34:02.780 --> 00:34:04.910
But we're definitely collecting
a list of wouldn't

00:34:04.910 --> 00:34:06.890
it be nice to fix kind of
things, some of which we've

00:34:06.890 --> 00:34:08.520
already mentioned.

00:34:08.520 --> 00:34:11.469
Go 2.0 exists so much as a
category in which to throw

00:34:11.469 --> 00:34:13.870
issues that we can't
fix today.

00:34:13.870 --> 00:34:17.940
But the general attitude is that
we're not going to bother

00:34:17.940 --> 00:34:20.500
investing the time thinking
about them or being frustrated

00:34:20.500 --> 00:34:25.170
by them, because it's too
far off on the horizon.

00:34:25.170 --> 00:34:26.420
AUDIENCE: Thanks.

00:34:29.790 --> 00:34:34.630
AUDIENCE: I wanted to find out
if you have any plans, or I

00:34:34.630 --> 00:34:38.760
would like to see some
influences from

00:34:38.760 --> 00:34:41.960
Erlang's OTP system.

00:34:41.960 --> 00:34:47.630
So it's not just the language,
but the entire runtime system

00:34:47.630 --> 00:34:49.560
that has all kinds of hooks.

00:34:49.560 --> 00:34:52.719
So, for example, if you have a
channel that's blocked for a

00:34:52.719 --> 00:34:56.790
lot longer than you expect, then
you have some profiling

00:34:56.790 --> 00:35:00.520
hook which says this is
unexpected, or some debugging

00:35:00.520 --> 00:35:02.910
thing that says this
is unexpected.

00:35:02.910 --> 00:35:09.400
So a set of tools that work
along with the runtime.

00:35:09.400 --> 00:35:12.350
So another example is in
profiling, you just have the

00:35:12.350 --> 00:35:14.320
control plane currently.

00:35:14.320 --> 00:35:17.920
The statistics only show per
Go routine, how many things

00:35:17.920 --> 00:35:18.850
I've called.

00:35:18.850 --> 00:35:26.120
But if I wanted to track a user
request that logically

00:35:26.120 --> 00:35:28.470
transfers control through
several Go routines and gets

00:35:28.470 --> 00:35:31.650
back a request, if I wanted to
profile and say where is this

00:35:31.650 --> 00:35:33.590
request taking time?

00:35:33.590 --> 00:35:37.330
Through its path through various
Go routines, how can I

00:35:37.330 --> 00:35:43.530
taint that particular stream
of control that it's

00:35:43.530 --> 00:35:45.760
orthogonal to the Go routine?

00:35:45.760 --> 00:35:49.150
So I want some systemic
hooks, basically.

00:35:49.150 --> 00:35:52.230
ROB PIKE: We're very aware of
all of those things, and would

00:35:52.230 --> 00:35:53.380
love to see them.

00:35:53.380 --> 00:35:56.010
The tooling involved is
interesting work.

00:35:56.010 --> 00:35:57.610
And I don't mean that
sarcastically, I mean it's

00:35:57.610 --> 00:35:58.760
really interesting work.

00:35:58.760 --> 00:36:02.820
And some of the other systems at
Google have pieces of that

00:36:02.820 --> 00:36:05.700
kind of thing that have not been
adapted to Go yet and I

00:36:05.700 --> 00:36:07.080
think would be nice to have.

00:36:07.080 --> 00:36:09.530
As far as the Erlang
model, Erlang is a

00:36:09.530 --> 00:36:10.255
very different language.

00:36:10.255 --> 00:36:14.250
It's interpreted functions are
passable across the network.

00:36:14.250 --> 00:36:16.330
I think it does the stuff
you're talking about

00:36:16.330 --> 00:36:19.270
beautifully, but Go is
a different language.

00:36:19.270 --> 00:36:21.120
It's hard to see how
to fit it in.

00:36:21.120 --> 00:36:24.320
But I would love to be proven
wrong and have someone

00:36:24.320 --> 00:36:26.640
actually build that environment
for Go.

00:36:26.640 --> 00:36:29.790
And it's entirely possible,
but it's certainly not a

00:36:29.790 --> 00:36:31.860
priority for us at the moment.

00:36:31.860 --> 00:36:33.495
We just have a different
model in mind.

00:36:33.495 --> 00:36:35.100
AUDIENCE: Thanks.

00:36:35.100 --> 00:36:35.930
ANDREW GERRAND: Thanks.

00:36:35.930 --> 00:36:36.345
You take one.

00:36:36.345 --> 00:36:38.220
NIGEL TAO: Next moderator
question.

00:36:38.220 --> 00:36:41.840
We might have touched this
before, but Divox asks, has

00:36:41.840 --> 00:36:44.260
the Go team been putting any
thoughts on how to provide

00:36:44.260 --> 00:36:47.650
more control over dependencies
and imported packages?

00:36:47.650 --> 00:36:50.090
Not having a way to make sure
everyone on the same team has

00:36:50.090 --> 00:36:51.840
the same version of third
party packages

00:36:51.840 --> 00:36:52.780
can be really painful.

00:36:52.780 --> 00:36:53.065
ANDREW GERRAND: Yeah.

00:36:53.065 --> 00:36:54.930
I think we've already
discussed that.

00:36:54.930 --> 00:36:56.600
BRAD FITZPATRICK: Well, the
thing we didn't discuss is if

00:36:56.600 --> 00:36:58.650
you're working with a big team
or whatever, you could also

00:36:58.650 --> 00:37:00.360
just check in your dependencies
to your own

00:37:00.360 --> 00:37:01.310
version control system.

00:37:01.310 --> 00:37:03.290
Then you can have a hermetic
view of the world.

00:37:03.290 --> 00:37:05.060
You can sync back to what
the world looked

00:37:05.060 --> 00:37:06.570
like two weeks ago.

00:37:06.570 --> 00:37:10.560
And when you go to update a
version of your dependencies,

00:37:10.560 --> 00:37:12.480
you update it, run
all your tests.

00:37:12.480 --> 00:37:15.350
If all your tests pass, maybe
you run it, you do performance

00:37:15.350 --> 00:37:16.890
tests on it, then you
check it under your

00:37:16.890 --> 00:37:19.290
version control system.

00:37:19.290 --> 00:37:22.070
Go Get is nice for
playing around.

00:37:22.070 --> 00:37:23.580
But if you're going to do
something serious and you're

00:37:23.580 --> 00:37:26.140
actually going to deploy
binaries to production, your

00:37:26.140 --> 00:37:28.560
deploy to production scripts
and involve fetching some

00:37:28.560 --> 00:37:31.105
random dude's stuff on GitHub.

00:37:31.105 --> 00:37:33.530
ANDREW GERRAND: And I'm also
not sure if it's really the

00:37:33.530 --> 00:37:36.910
role of the Go tool or the
tooling provided by the

00:37:36.910 --> 00:37:39.910
language to actually dictate the
way you manage your code

00:37:39.910 --> 00:37:41.860
in a production sense.

00:37:41.860 --> 00:37:44.170
One of the virtues of the Go
tool is that it uses Get

00:37:44.170 --> 00:37:47.130
Mercurial, Subversion,
[? Bizarre, ?] all tools that

00:37:47.130 --> 00:37:49.080
exist and that are
well understood.

00:37:49.080 --> 00:37:51.420
And so if you need to build any
tooling around them, you

00:37:51.420 --> 00:37:54.100
already understand those tools
that you're already using and

00:37:54.100 --> 00:37:56.710
so it should be relatively
straightforward to integrate

00:37:56.710 --> 00:37:59.340
those with whatever
system you have.

00:37:59.340 --> 00:38:01.120
AUDIENCE: Time for one
more question?

00:38:01.120 --> 00:38:03.140
NIGEL TAO: Next one from
Carl Lemons again.

00:38:03.140 --> 00:38:05.070
Can you talk about the future
of the run time?

00:38:05.070 --> 00:38:09.710
How much of it could and/or
should be rewritten in Go?

00:38:09.710 --> 00:38:12.460
ROB PIKE: Quite a bit of it
could be rewritten in Go.

00:38:12.460 --> 00:38:14.370
The question also comes up,
why isn't there a compiler

00:38:14.370 --> 00:38:15.980
written in Go?

00:38:15.980 --> 00:38:18.420
And the answer to both of those
was it got the way it is

00:38:18.420 --> 00:38:21.050
because of expediency--

00:38:21.050 --> 00:38:22.610
to bootstrap.

00:38:22.610 --> 00:38:24.960
You can bootstrap the language
while you're

00:38:24.960 --> 00:38:26.620
writing it in itself.

00:38:26.620 --> 00:38:29.230
But it's much more cost
effective, especially when

00:38:29.230 --> 00:38:31.350
you're thinking of distributing
it once it's up

00:38:31.350 --> 00:38:32.110
and running.

00:38:32.110 --> 00:38:34.520
Which was always a consideration
for Go to take

00:38:34.520 --> 00:38:36.420
an existing language and
write in that, and C

00:38:36.420 --> 00:38:38.250
was an obvious candidate.

00:38:38.250 --> 00:38:41.170
So there's a compiler written
in C, inside [? GCC ?]

00:38:41.170 --> 00:38:44.760
Go is written in C++, uses
the GCC back end.

00:38:44.760 --> 00:38:48.320
I think we have more and more
of the pieces necessary to

00:38:48.320 --> 00:38:50.720
write the compiler
in Go available.

00:38:50.720 --> 00:38:53.400
We've got the Type
Checker now.

00:38:53.400 --> 00:38:56.080
There's an SSA package that
can do a lot of the static

00:38:56.080 --> 00:38:58.630
analysis for good compilation.

00:38:58.630 --> 00:39:00.980
But there's no actual pressure
on our side to do it-- we

00:39:00.980 --> 00:39:02.470
don't think it needs to.

00:39:02.470 --> 00:39:05.090
As far as the runtime, more
and more of it could be

00:39:05.090 --> 00:39:06.880
because the language is getting
stronger and the

00:39:06.880 --> 00:39:08.000
efficiencies are coming.

00:39:08.000 --> 00:39:09.980
But again, we don't
feel the pressure.

00:39:09.980 --> 00:39:13.390
There's no compelling reason to
do it at the moment that I

00:39:13.390 --> 00:39:15.210
can see, but I could be wrong.

00:39:18.325 --> 00:39:21.020
BRAD FITZPATRICK: I agree.

00:39:21.020 --> 00:39:23.230
One compelling reason could
be that our Go compiler is

00:39:23.230 --> 00:39:25.300
actually better than our C
compiler at this point, and

00:39:25.300 --> 00:39:26.165
lots of things.

00:39:26.165 --> 00:39:28.586
IAN TAYLOR: That's not
a compelling reason.

00:39:28.586 --> 00:39:30.960
ROBERT GRIESEMER: There's at
least one project that's done

00:39:30.960 --> 00:39:34.320
outside which I know of which
is using the existing

00:39:34.320 --> 00:39:38.540
libraries that we have for Go
Front and is trying to hook

00:39:38.540 --> 00:39:40.690
this up with an LLVM back end.

00:39:40.690 --> 00:39:44.350
So that's not a Go compiler
entirely written in Go, but

00:39:44.350 --> 00:39:46.272
it's a step in that direction.

00:39:46.272 --> 00:39:49.600
ANDREW GERRAND: I think
we're out of time.

00:39:49.600 --> 00:39:53.150
We actually have some gifts
for you that we'll be

00:39:53.150 --> 00:39:55.120
distributing from the left-hand
side of the stage.

00:39:55.120 --> 00:39:59.910
But thank you all for coming,
and please take only one.

00:39:59.910 --> 00:40:00.210
Thank you.

00:40:00.210 --> 00:40:08.257
[APPLAUSE]

