WEBVTT
Kind: captions
Language: en

00:00:03.020 --> 00:00:03.860
NICOLAS ROARD: Good
morning, everyone.

00:00:03.860 --> 00:00:05.540
My name is Nicolas Roard.

00:00:05.540 --> 00:00:07.730
I'm a software engineer
on the Android team.

00:00:07.730 --> 00:00:10.780
And I've been working on the
Android WebView and, by

00:00:10.780 --> 00:00:15.150
extension, the Android browser
for the last few years.

00:00:15.150 --> 00:00:18.740
So what I'm going to talk about
today is mostly a bit of

00:00:18.740 --> 00:00:19.910
the [INAUDIBLE]

00:00:19.910 --> 00:00:26.930
mechanisms for the WebView, how
we implemented the view.

00:00:26.930 --> 00:00:29.650
And the second part is mostly
about so how can take

00:00:29.650 --> 00:00:34.400
advantage of that to make your
application smoother

00:00:34.400 --> 00:00:36.870
and nicer to use.

00:00:36.870 --> 00:00:40.600
All right, so WebKit one, for
the probably very few that

00:00:40.600 --> 00:00:43.680
don't know what is, it
was our [INAUDIBLE]

00:00:43.680 --> 00:00:48.870
project by the KDE desktop
environment.

00:00:48.870 --> 00:00:50.530
And they use that for
their own browser.

00:00:50.530 --> 00:00:56.220
And Apple took KHTML, that
they're conjoined, and

00:00:56.220 --> 00:01:02.310
extended it and made it more
robust, and used that as a

00:01:02.310 --> 00:01:04.780
base for Safari.

00:01:04.780 --> 00:01:12.680
And more to the interest for us,
in 2008, both Chrome used

00:01:12.680 --> 00:01:16.060
an enjoined based on WebKit, and
the Android used both the

00:01:16.060 --> 00:01:20.500
browser and the WebView
also using WebKit.

00:01:20.500 --> 00:01:23.150
One of the interesting thing
with Android is that the

00:01:23.150 --> 00:01:26.070
Android browser is actually
just using the WebView.

00:01:26.070 --> 00:01:29.180
So it's exactly the same thing
that you can use in your

00:01:29.180 --> 00:01:30.430
applications.

00:01:32.550 --> 00:01:36.040
So let's talk a bit about
the architecture.

00:01:36.040 --> 00:01:38.880
So WebKit.

00:01:38.880 --> 00:01:42.400
So roughly, you've
got two parts.

00:01:42.400 --> 00:01:45.690
You've got layout engine,
something that can take some

00:01:45.690 --> 00:01:49.040
content and determine
where it wants to

00:01:49.040 --> 00:01:51.030
put the various elements.

00:01:51.030 --> 00:01:52.780
And you've got JavaScriptCore,
which is a JavaScript engine

00:01:52.780 --> 00:01:56.690
that will do whatever it
wants on the page.

00:01:56.690 --> 00:01:59.510
And those two things are our
equipment, they're the Android

00:01:59.510 --> 00:02:01.300
Elf WebKit.

00:02:01.300 --> 00:02:04.950
Right, so how it works, slightly
in more details.

00:02:04.950 --> 00:02:07.080
So let's say that
you get WebKit.

00:02:07.080 --> 00:02:10.145
You are going to get
some resources.

00:02:10.145 --> 00:02:12.610
You're going to send them to
WebKit, or WebKit was going to

00:02:12.610 --> 00:02:14.170
load them more exactly.

00:02:14.170 --> 00:02:16.270
And WebKit's going to
build a document

00:02:16.270 --> 00:02:18.440
object model using that.

00:02:18.440 --> 00:02:21.420
Execute unique JavaScript that
has to be executed on the

00:02:21.420 --> 00:02:23.220
document object model.

00:02:23.220 --> 00:02:26.430
And finally, do the layouts
and everything

00:02:26.430 --> 00:02:28.210
that needs to be done.

00:02:28.210 --> 00:02:31.180
So what is interesting to us is
that WebKit is actually a

00:02:31.180 --> 00:02:38.050
very abstract engine and
platform-specific bits and

00:02:38.050 --> 00:02:41.770
stuff like rendering
are nicely put into

00:02:41.770 --> 00:02:44.320
the category platform.

00:02:44.320 --> 00:02:47.310
And from that you can get
the final rendering.

00:02:47.310 --> 00:02:49.990
Right, so in platforms,
what do we get?

00:02:49.990 --> 00:02:57.060
We have the network and disk
access, of course.

00:02:57.060 --> 00:02:58.680
You have some system
integration.

00:02:58.680 --> 00:03:02.330
And by that, I'm mostly thinking
about the newest

00:03:02.330 --> 00:03:05.600
HTML5 APIs, stuff like
camera access or

00:03:05.600 --> 00:03:08.240
Geolocation, or whatnot.

00:03:08.240 --> 00:03:11.390
And of course, that's
+1 dependent.

00:03:11.390 --> 00:03:14.540
And the big part of this stuff
today is going to be more

00:03:14.540 --> 00:03:16.260
about the graphics and
the rendering.

00:03:16.260 --> 00:03:18.960
Because that's really where
you can see a difference

00:03:18.960 --> 00:03:22.490
between the different WebKit
implementations.

00:03:22.490 --> 00:03:26.890
And finally, you can also
possibly replace the default

00:03:26.890 --> 00:03:29.530
JavaScript engine of WebKit by
something else, which is

00:03:29.530 --> 00:03:30.690
actually what we did.

00:03:30.690 --> 00:03:36.480
We are using V8, the same
engine as Chrome.

00:03:36.480 --> 00:03:38.840
OK, so quickly about the
system integration.

00:03:42.080 --> 00:03:45.770
Those are some of the API that
we added on previous releases

00:03:45.770 --> 00:03:48.800
of Android.

00:03:48.800 --> 00:03:50.350
If you are using the WebView in
your application, I think

00:03:50.350 --> 00:03:54.650
that you can be interested in
our HTML5 video support, and

00:03:54.650 --> 00:03:56.800
Geolocation API.

00:03:56.800 --> 00:03:59.240
But anyway, roughly it will
be released this week.

00:03:59.240 --> 00:04:03.040
We tried to add more support
for those kind of APIs.

00:04:03.040 --> 00:04:05.350
All right, our JavaScript,
just to

00:04:05.350 --> 00:04:08.720
give you on the WebView.

00:04:08.720 --> 00:04:11.920
On the same device, you can
see that, well luckily, we

00:04:11.920 --> 00:04:15.360
improved from release
to release.

00:04:15.360 --> 00:04:19.690
And in JellyBean on the Nexus
S, you are a bit more than

00:04:19.690 --> 00:04:24.640
twice as fast as Gingerbread
was.

00:04:24.640 --> 00:04:27.635
Interestingly, if you compare
that to a laptop, and that's a

00:04:27.635 --> 00:04:30.320
2.5 gigahertz core
[INAUDIBLE].

00:04:30.320 --> 00:04:35.160
The Galaxy Nexus is only five to
six times slower, which if

00:04:35.160 --> 00:04:37.970
you think about it
is not that slow.

00:04:37.970 --> 00:04:40.690
I mean, we are getting closer
and closer to [INAUDIBLE]

00:04:40.690 --> 00:04:45.370
that you got on a desktop
a few years ago.

00:04:45.370 --> 00:04:47.120
All right, so rendering.

00:04:47.120 --> 00:04:50.380
And again, that's mostly where
things differ in terms of the

00:04:50.380 --> 00:04:51.240
WebKit implementation.

00:04:51.240 --> 00:04:52.700
Everyone is using WebKit.

00:04:52.700 --> 00:04:55.750
WebKit is used by so many
different companies.

00:04:55.750 --> 00:05:00.990
And where things differ is
how you implement the

00:05:00.990 --> 00:05:04.090
platform-specific bits that
decide how you want to render

00:05:04.090 --> 00:05:06.620
stuff on screen.

00:05:06.620 --> 00:05:12.320
So if you remember that,
basically that corresponds to

00:05:12.320 --> 00:05:14.820
something like that, in terms
of a rendering loop.

00:05:14.820 --> 00:05:17.900
You got [INAUDIBLE] event,
like scroll.

00:05:17.900 --> 00:05:22.930
You are going to interaction to
that, paint something like

00:05:22.930 --> 00:05:26.140
a bitmap in the [INAUDIBLE],
something that.

00:05:26.140 --> 00:05:27.780
And that's going to
be your content.

00:05:27.780 --> 00:05:30.410
And finally, you want to draw
that content on screen.

00:05:30.410 --> 00:05:32.430
And of course, you do that
over and over again.

00:05:34.990 --> 00:05:36.680
Visually, that corresponds
to that.

00:05:36.680 --> 00:05:37.930
That's an individual document.

00:05:40.630 --> 00:05:42.745
We are going to work with what
you call the viewport, which

00:05:42.745 --> 00:05:47.800
is simply the visible part
of your document.

00:05:47.800 --> 00:05:53.510
And actually live, that's
exactly how WebKit sees

00:05:53.510 --> 00:05:57.060
things, is that nothing that is
not shown on the screen is

00:05:57.060 --> 00:05:57.930
actually painted.

00:05:57.930 --> 00:06:00.295
You only paint what's visible.

00:06:00.295 --> 00:06:04.710
So the problem with that is if
you scroll around, you have to

00:06:04.710 --> 00:06:07.530
repaint this area.

00:06:07.530 --> 00:06:15.350
And that's an issue on mobile,
because it's a very tight loop

00:06:15.350 --> 00:06:16.900
and it can be slow.

00:06:16.900 --> 00:06:21.430
So what we did on Android
before in Honeycomb was

00:06:21.430 --> 00:06:26.800
instead of implementing this
action/reaction of repainting

00:06:26.800 --> 00:06:30.720
stuff as we are going on.

00:06:30.720 --> 00:06:35.250
Instead, we capture the content
of the page into what

00:06:35.250 --> 00:06:37.450
we call the picture.

00:06:37.450 --> 00:06:40.755
And then using that picture,
we can render it.

00:06:40.755 --> 00:06:43.270
OK, so why did we do that?

00:06:43.270 --> 00:06:44.770
Because the picture is
basically a vector

00:06:44.770 --> 00:06:48.270
representation of the page,
which is nice because then it

00:06:48.270 --> 00:06:51.580
means you can do stuff like
scrolling just by moving the

00:06:51.580 --> 00:06:54.530
transform of when you replay
the driving instructions.

00:06:54.530 --> 00:06:57.880
Or you can zoom without having
to go back to WebKit.

00:06:57.880 --> 00:07:01.520
And that's good because if
WebKit was only doing

00:07:01.520 --> 00:07:03.280
painting, that would be fine.

00:07:03.280 --> 00:07:05.880
But WebKit of course is doing a
lot of other stuff, loading

00:07:05.880 --> 00:07:08.860
documents, doing layouts,
anything like that.

00:07:08.860 --> 00:07:14.430
So if you depend from WebKit
to get reasonable

00:07:14.430 --> 00:07:16.320
performances, you
missed it here.

00:07:16.320 --> 00:07:19.300
Because you're going to send
[INAUDIBLE] onto WebKit

00:07:19.300 --> 00:07:21.200
saying, hey, repaint me this
part of the screen.

00:07:21.200 --> 00:07:23.920
And WebKit is saying, sure,
but hold on, I'm doing

00:07:23.920 --> 00:07:25.510
something else.

00:07:25.510 --> 00:07:28.020
So by adding this split
architecture with the picture

00:07:28.020 --> 00:07:33.210
on one side and WebKit on the
other, we can do our things on

00:07:33.210 --> 00:07:37.530
UI, and let WebKit do
it's own things.

00:07:37.530 --> 00:07:39.710
So and that's for securities,
right?

00:07:39.710 --> 00:07:42.310
We've got two different threads,
the WebCore thread

00:07:42.310 --> 00:07:43.760
and the UI thread.

00:07:43.760 --> 00:07:46.000
We have a picture that we use on
the UI thread to render the

00:07:46.000 --> 00:07:48.360
page on screen.

00:07:48.360 --> 00:07:51.070
So if we send an event from
the UI, like it's called

00:07:51.070 --> 00:07:53.200
Gesture, or [INAUDIBLE],
something like that.

00:07:53.200 --> 00:07:55.310
We send it to do a core
thread WebCore.

00:07:55.310 --> 00:07:56.890
We engineer it in your
picture, send the

00:07:56.890 --> 00:07:57.670
picture off to us.

00:07:57.670 --> 00:08:00.390
We can then use that
one to show the new

00:08:00.390 --> 00:08:03.290
content to the user.

00:08:03.290 --> 00:08:08.600
Right, so this is nice, but
there is some issues.

00:08:08.600 --> 00:08:09.620
One of the main--

00:08:09.620 --> 00:08:12.381
and I believe that most of you
have experienced that on your

00:08:12.381 --> 00:08:14.750
Android devices is
that the speed is

00:08:14.750 --> 00:08:16.810
dependent on the content.

00:08:16.810 --> 00:08:18.950
Meaning that on some websites,
you're going to be able to

00:08:18.950 --> 00:08:22.550
scroll very smoothly, very
quickly, the user interaction

00:08:22.550 --> 00:08:24.250
is going to be nice.

00:08:24.250 --> 00:08:27.190
And then you go to a different
website, and the websites is

00:08:27.190 --> 00:08:29.140
not responsive.

00:08:29.140 --> 00:08:30.730
And that's because of
this, because we are

00:08:30.730 --> 00:08:31.530
replaying this picture.

00:08:31.530 --> 00:08:34.700
And if you have too many drawing
instructions, or if

00:08:34.700 --> 00:08:39.080
the drawing instructions are too
slow to rasterize to get

00:08:39.080 --> 00:08:43.919
your final image, then you're
going to take longer than 16

00:08:43.919 --> 00:08:49.270
millisecond, and you're going
to be visibly slow.

00:08:49.270 --> 00:08:52.100
The other thing is that it's
a purely 2D model.

00:08:52.100 --> 00:08:55.110
So if you want to support things
like your CSS3D, you're

00:08:55.110 --> 00:08:57.010
out of luck.

00:08:57.010 --> 00:09:01.370
And the last thing is that if
you remember with the plugins,

00:09:01.370 --> 00:09:05.250
such as flash, you could scroll
around and the flash

00:09:05.250 --> 00:09:10.100
plugin was kind of trailing
behind you or your scroll.

00:09:10.100 --> 00:09:13.230
And that's because it's an
asynchronous rendering model,

00:09:13.230 --> 00:09:16.030
and it's difficult to
synchronize both because one

00:09:16.030 --> 00:09:17.550
doesn't know where
the other is.

00:09:20.410 --> 00:09:22.700
Anyhow, on Honeycomb,
we [INAUDIBLE]

00:09:22.700 --> 00:09:24.170
that.

00:09:24.170 --> 00:09:28.270
So the reason is because our
screen size increase.

00:09:28.270 --> 00:09:31.990
The whole restoration thing in
software didn't work out.

00:09:31.990 --> 00:09:35.050
So what we did instead,
we just take content.

00:09:35.050 --> 00:09:41.010
So the idea is that if you take
that rendering loop, you

00:09:41.010 --> 00:09:44.520
really, really, really want that
loop to be done in less

00:09:44.520 --> 00:09:46.650
than 16 milliseconds.

00:09:46.650 --> 00:09:49.250
That corresponds to 60 FPS.

00:09:49.250 --> 00:09:53.220
The problem with this is that if
the paint, as I explained,

00:09:53.220 --> 00:09:57.370
takes longer than that, then
you are out of luck.

00:09:57.370 --> 00:09:59.420
And visibly, you'll see
something like that.

00:09:59.420 --> 00:10:02.620
You're going to scroll, but
it's going to stutter.

00:10:02.620 --> 00:10:05.000
So ideally, you want something,
you know, I scroll,

00:10:05.000 --> 00:10:07.080
I draw, that's it.

00:10:07.080 --> 00:10:09.890
And that's basically what
hardware rendering is.

00:10:09.890 --> 00:10:13.590
So starting from Honeycomb
WebView, as long as your

00:10:13.590 --> 00:10:16.180
application interacts
with the mode, it's

00:10:16.180 --> 00:10:17.540
going to use that mode.

00:10:17.540 --> 00:10:19.010
And what you do, you scroll,
you draw, and

00:10:19.010 --> 00:10:21.030
you draw your tiles.

00:10:21.030 --> 00:10:24.850
And of course, what you
do is you move things

00:10:24.850 --> 00:10:26.140
into different threads.

00:10:26.140 --> 00:10:29.860
When you scroll, you send the
command saying, hey, paint me

00:10:29.860 --> 00:10:35.100
the new content, the
one I just uncover.

00:10:35.100 --> 00:10:36.980
And it give me new tiles.

00:10:36.980 --> 00:10:39.580
But the nice thing, of course,
is that as it's tying

00:10:39.580 --> 00:10:43.150
different thread, if that
operation takes time, it

00:10:43.150 --> 00:10:45.640
really doesn't matter.

00:10:45.640 --> 00:10:49.270
So here's how it
looks visually.

00:10:49.270 --> 00:10:50.610
You've got a viewport.

00:10:50.610 --> 00:10:53.345
We're going to prepare
some new tiles.

00:10:53.345 --> 00:10:55.230
We are going to use them
to display the

00:10:55.230 --> 00:10:57.020
content to the user.

00:10:57.020 --> 00:11:01.020
If the user is scrolling, we
prepare some new tile.

00:11:01.020 --> 00:11:03.000
But we don't have to wait for
the rendering loop, right?

00:11:03.000 --> 00:11:05.675
So we can just start scrolling
around, even if some of the

00:11:05.675 --> 00:11:07.360
tiles are not there,
doesn't matter.

00:11:07.360 --> 00:11:12.360
We can take the tiles that are
now hidden and reuse then to

00:11:12.360 --> 00:11:14.910
get some new content.

00:11:14.910 --> 00:11:18.600
So that's roughly the
general idea.

00:11:18.600 --> 00:11:20.550
And so on and so forth.

00:11:20.550 --> 00:11:23.670
In terms of the architecture,
we just add the new thread.

00:11:26.540 --> 00:11:29.080
When we create the picture
on the WebKit thread.

00:11:29.080 --> 00:11:31.610
We send that to the UI, send it
to the Texture Generation

00:11:31.610 --> 00:11:34.500
thread, use that to generate the
texture, send the texture

00:11:34.500 --> 00:11:38.960
to the UI, and the UI can
directly use those textures.

00:11:38.960 --> 00:11:39.890
And that's it.

00:11:39.890 --> 00:11:42.230
The nice thing with this model
is that, again, we are

00:11:42.230 --> 00:11:44.300
completely separated
from WebKit.

00:11:44.300 --> 00:11:47.520
And we can be completely
independent.

00:11:47.520 --> 00:11:49.580
So we can still do all the
zooming, scrolling and all

00:11:49.580 --> 00:11:51.530
that without having to
go back to WebKit.

00:11:51.530 --> 00:11:55.560
We still have the entire page
content inside the picture.

00:11:55.560 --> 00:11:58.830
So we still take advantage of
that to be able to generate

00:11:58.830 --> 00:12:02.240
text very quickly.

00:12:02.240 --> 00:12:05.590
So the problem with this is we
are basically doing exactly

00:12:05.590 --> 00:12:06.950
the same job as before.

00:12:06.950 --> 00:12:08.740
And on top of that, we
have to upload the

00:12:08.740 --> 00:12:10.980
content to the textures.

00:12:10.980 --> 00:12:13.790
So basically, you're going
to get slower painting

00:12:13.790 --> 00:12:16.080
performances with this
architecture.

00:12:16.080 --> 00:12:20.680
But you're going to get much
faster drawing performances.

00:12:20.680 --> 00:12:23.610
Obviously, to try to hide that
we do lots of things.

00:12:23.610 --> 00:12:26.825
Like we try to pre-cache the
tiles in the direction where

00:12:26.825 --> 00:12:28.844
you're scrolling.

00:12:28.844 --> 00:12:32.570
We schedule some tiles that are
at the lower resolution so

00:12:32.570 --> 00:12:34.770
that they can [INAUDIBLE]

00:12:34.770 --> 00:12:37.390
for us to cover a large area.

00:12:37.390 --> 00:12:42.280
So that's why on the browser
you can see some blurry

00:12:42.280 --> 00:12:44.790
content sometimes if you
scroll too fast.

00:12:44.790 --> 00:12:47.250
But at least we show
you something.

00:12:47.250 --> 00:12:48.980
Now, of course we are limited
by the memory, and that's

00:12:48.980 --> 00:12:51.300
dependent on the device.

00:12:51.300 --> 00:12:56.020
One thing that I'll talk about
later but you can think about

00:12:56.020 --> 00:12:59.400
is the tiles are 256
by 256 so far.

00:12:59.400 --> 00:13:03.110
And that's also an implication
in how you can use that to

00:13:03.110 --> 00:13:05.250
tailor your content.

00:13:05.250 --> 00:13:08.320
One thing we do in JellyBean as
well is we do some check.

00:13:08.320 --> 00:13:10.470
If the tiles are completely
empty, we don't use a texture

00:13:10.470 --> 00:13:13.970
for that, we just use a drawing
shader and just have

00:13:13.970 --> 00:13:16.220
some textures, and that
improves some of the

00:13:16.220 --> 00:13:18.600
performances.

00:13:18.600 --> 00:13:25.690
OK, so that's the rough idea on
how WebKit works in terms

00:13:25.690 --> 00:13:27.600
of rendering.

00:13:27.600 --> 00:13:31.360
And then someone decided that,
oh yeah, we can create this

00:13:31.360 --> 00:13:33.430
thing called layers.

00:13:33.430 --> 00:13:38.500
So layers, the general idea is
that you've got your page,

00:13:38.500 --> 00:13:43.950
you've got some content on
the page, and you want to

00:13:43.950 --> 00:13:48.010
translate that image, you want
to animate it on screen.

00:13:48.010 --> 00:13:50.960
If you do that, what's going to
happen is that think about

00:13:50.960 --> 00:13:53.430
it as a base surface.

00:13:53.430 --> 00:13:58.860
And you're going to have to
invalidate and repaint this

00:13:58.860 --> 00:14:01.450
entire area on the surface
because that's

00:14:01.450 --> 00:14:04.520
where you move stuff.

00:14:04.520 --> 00:14:08.180
And it's even worse because
you are not doing that in

00:14:08.180 --> 00:14:10.070
single frame, you are doing
that in as many frames you

00:14:10.070 --> 00:14:12.540
need for the animation.

00:14:12.540 --> 00:14:16.020
So the idea of layers is to
say, well, let's get that

00:14:16.020 --> 00:14:18.310
element onto it's own surface.

00:14:18.310 --> 00:14:19.830
So now we don't have a
single surface, we

00:14:19.830 --> 00:14:21.800
have multiple surfaces.

00:14:21.800 --> 00:14:27.420
And then we can just draw that
at draw time when we want to

00:14:27.420 --> 00:14:29.280
show the content to the user.

00:14:29.280 --> 00:14:32.000
And if you think about it, if
we do that in [INAUDIBLE],

00:14:32.000 --> 00:14:33.355
it's nearly a preparation.

00:14:33.355 --> 00:14:39.560
We just draw different quads and
the GPU card is doing the

00:14:39.560 --> 00:14:42.150
heavy work, and surface move.

00:14:42.150 --> 00:14:44.550
So that's the idea of layers.

00:14:44.550 --> 00:14:51.400
The other thing that you can
do with layers is better

00:14:51.400 --> 00:14:54.660
support some of the
HTML content.

00:14:54.660 --> 00:14:56.280
One example is this.

00:14:56.280 --> 00:14:58.800
You got the web page, you got
a video on the page, and you

00:14:58.800 --> 00:14:59.550
got [INAUDIBLE]

00:14:59.550 --> 00:15:02.320
section with images that
you can scroll around.

00:15:02.320 --> 00:15:06.620
The normal model would be for
the scrolling around, every

00:15:06.620 --> 00:15:09.450
time you scroll around to
repainting this area.

00:15:09.450 --> 00:15:12.240
And that's not super fast.

00:15:12.240 --> 00:15:15.690
And if you have this hardware
rendering pipeline, it's even

00:15:15.690 --> 00:15:17.930
slower because, well, on top
of everything, we have to

00:15:17.930 --> 00:15:19.320
upload a texture.

00:15:19.320 --> 00:15:22.510
So what you do instead, you
think those two things-- the

00:15:22.510 --> 00:15:25.300
video and the scrollable
elements--

00:15:25.300 --> 00:15:28.300
and you move them out
of the base surface

00:15:28.300 --> 00:15:30.510
onto their own layer.

00:15:30.510 --> 00:15:33.540
The next thing is that for the
scrollable layer, you can then

00:15:33.540 --> 00:15:40.200
not just pre-pain the stuff that
is currently on screen,

00:15:40.200 --> 00:15:43.010
but you can paint the
entire element.

00:15:43.010 --> 00:15:45.300
Then you just have to clip
when you draw it.

00:15:45.300 --> 00:15:46.590
And that's it.

00:15:46.590 --> 00:15:48.800
The nice thing is you don't have
to go back to web page,

00:15:48.800 --> 00:15:51.110
you don't have to invalidate,
you don't have to repaint, and

00:15:51.110 --> 00:15:53.260
things are smooth.

00:15:53.260 --> 00:15:53.960
Right.

00:15:53.960 --> 00:15:56.830
So on this previous page, this
is how it would look like in

00:15:56.830 --> 00:15:57.410
terms of WebKit.

00:15:57.410 --> 00:16:00.130
It would have the base surface,
the base layer.

00:16:00.130 --> 00:16:02.080
We'd have one video
layer, clip layer,

00:16:02.080 --> 00:16:04.050
and scrollable layer.

00:16:04.050 --> 00:16:07.640
The good thing with the video
layer is that if you remember

00:16:07.640 --> 00:16:11.250
what I was explaining earlier
about the flash plugin, you

00:16:11.250 --> 00:16:12.930
want stuff to be synchronized.

00:16:12.930 --> 00:16:15.610
The problem that we had before
is that we didn't know where

00:16:15.610 --> 00:16:17.980
it was, or we knew too late
because rendering was

00:16:17.980 --> 00:16:19.440
asynchronous.

00:16:19.440 --> 00:16:22.920
In this model, we just say, oh
well, be on your own layer.

00:16:22.920 --> 00:16:25.430
And then it just happen that
when we draw this layer, we're

00:16:25.430 --> 00:16:28.450
not choosing the texture.

00:16:28.450 --> 00:16:32.480
More exactly, we are directly
asking the media server to

00:16:32.480 --> 00:16:35.000
give us video texture,
and we show that.

00:16:35.000 --> 00:16:37.440
So we control entirely
where things are.

00:16:37.440 --> 00:16:42.030
And therefore, things are
fully synchronous.

00:16:42.030 --> 00:16:45.530
All right, so layers, basically,
they are great.

00:16:45.530 --> 00:16:47.100
And if there is one thing you
should remember about this

00:16:47.100 --> 00:16:48.700
talk it's use layers.

00:16:48.700 --> 00:16:51.390
And I'm going to go into more
details about how you can do

00:16:51.390 --> 00:16:52.960
that in your application.

00:16:52.960 --> 00:16:56.950
But basically, as I explain, you
can move them around and

00:16:56.950 --> 00:16:58.200
it's very cheap.

00:17:00.300 --> 00:17:04.940
And what I said before about
the foreign content.

00:17:04.940 --> 00:17:07.599
Originally the idea with layers
was not even that.

00:17:07.599 --> 00:17:11.490
The idea for layers in WebKit
was to implement CSS 3D.

00:17:11.490 --> 00:17:13.940
So CSS 3D, for the ones
who don't know, it's

00:17:13.940 --> 00:17:14.750
something like that.

00:17:14.750 --> 00:17:19.970
You've got some 3D transforms
that are applied to elements.

00:17:19.970 --> 00:17:23.670
So here, for example, all those
little rectangles are

00:17:23.670 --> 00:17:25.150
just developments.

00:17:25.150 --> 00:17:29.840
You just apply a CSS transform,
and that's it.

00:17:29.840 --> 00:17:32.620
Just another example,
got a rotating cube.

00:17:32.620 --> 00:17:35.390
And you can do all kinds
of fun things.

00:17:35.390 --> 00:17:40.360
And basically, you can use
that to maybe make user

00:17:40.360 --> 00:17:45.830
interface nicer to the user,
or more interactive.

00:17:45.830 --> 00:17:49.410
Anyhow, on Android, we
implemented the support for

00:17:49.410 --> 00:17:53.810
that in the WebView
since Honeycomb.

00:17:53.810 --> 00:17:56.440
But we also used it to
do other things.

00:17:56.440 --> 00:17:59.140
So what we did for the
architecture, we basically

00:17:59.140 --> 00:18:01.760
took the previous architecture
and we said, OK, instead of

00:18:01.760 --> 00:18:04.240
giving us just a single
texture, give

00:18:04.240 --> 00:18:06.120
us a tree of layers.

00:18:06.120 --> 00:18:08.190
And each layer will contain--

00:18:08.190 --> 00:18:08.860
I'm simplifying a bit--

00:18:08.860 --> 00:18:11.790
but actually, it will
contain a picture.

00:18:11.790 --> 00:18:12.870
The thing you notice
here is that I

00:18:12.870 --> 00:18:14.930
added the CSS animation.

00:18:14.930 --> 00:18:19.240
So CSS animation is a
pretty cool think.

00:18:19.240 --> 00:18:22.200
It's something that lets you
specify an animation, you

00:18:22.200 --> 00:18:24.170
know, decently high-level way.

00:18:24.170 --> 00:18:26.825
And you can do pretty
complex things.

00:18:26.825 --> 00:18:32.200
It's supported on Firefox and
WebKit-based browsers.

00:18:32.200 --> 00:18:35.920
The nice thing with that is that
instead of letting WebKit

00:18:35.920 --> 00:18:38.400
doing the valuation for the
animation and determining

00:18:38.400 --> 00:18:43.390
where you want an element to
be according t that, we can

00:18:43.390 --> 00:18:49.670
take this computation and
move it to the UI.

00:18:49.670 --> 00:18:52.100
And basically, that means that
those animations are hardware

00:18:52.100 --> 00:18:53.380
accelerated.

00:18:53.380 --> 00:18:54.630
Sorry.

00:18:58.260 --> 00:19:01.750
And if you have heard a bit
about the [INAUDIBLE]

00:19:01.750 --> 00:19:02.440
and stuff.

00:19:02.440 --> 00:19:04.730
That also means that those
animations are v-synced.

00:19:04.730 --> 00:19:06.930
So they are nice [INAUDIBLE].

00:19:06.930 --> 00:19:11.160
And of course, they are much,
much faster than JavaScript.

00:19:11.160 --> 00:19:12.570
You don't need to execute
anything.

00:19:12.570 --> 00:19:13.980
It's all done on the UI side.

00:19:13.980 --> 00:19:16.190
It's all synchronous.

00:19:16.190 --> 00:19:19.970
But I mean to simplify things,
try to use CSS animations.

00:19:25.080 --> 00:19:31.530
On this example, the way you
do that, you just create an

00:19:31.530 --> 00:19:35.690
animation, say where
you want it to be

00:19:35.690 --> 00:19:36.920
and apply your transform.

00:19:36.920 --> 00:19:37.890
And that's all.

00:19:37.890 --> 00:19:41.040
And that's what was giving you
this whole spin thing.

00:19:41.040 --> 00:19:47.610
So on Android, we used this
concept of layers and

00:19:47.610 --> 00:19:51.870
leveraged it to make
the content nicer.

00:19:51.870 --> 00:19:55.880
So one pretty simple thing that
we did and that was back

00:19:55.880 --> 00:19:56.790
in [INAUDIBLE]

00:19:56.790 --> 00:19:59.930
was to support fixed positioned
elements.

00:19:59.930 --> 00:20:02.290
And fixed positioned elements
are those elements on the web

00:20:02.290 --> 00:20:04.550
page that basically don't move
when you scroll around.

00:20:07.520 --> 00:20:11.270
And we implemented a bunch of
other things, like the HTML5

00:20:11.270 --> 00:20:14.560
video, the iFrame support,
OverFlow-scroll elements, of

00:20:14.560 --> 00:20:18.010
course the CSS 3D, and even
fixed background elements.

00:20:18.010 --> 00:20:20.330
So that gives you something
that if I take the I/O

00:20:20.330 --> 00:20:23.100
website, you got this
fixed element.

00:20:23.100 --> 00:20:25.270
And you see that it's
scrolling smoothly.

00:20:25.270 --> 00:20:26.790
And the reason is because
that element on

00:20:26.790 --> 00:20:28.530
top is a fixed element.

00:20:28.530 --> 00:20:30.120
We don't have to go
back to WebKit.

00:20:30.120 --> 00:20:34.240
We can just do the compositing
and the positioning on the UI

00:20:34.240 --> 00:20:36.995
when we want to draw a frame.

00:20:36.995 --> 00:20:39.145
But that's just the fixed
background element.

00:20:46.880 --> 00:20:49.780
You can see that the background
of that element is

00:20:49.780 --> 00:20:51.020
actually another image.

00:20:51.020 --> 00:20:54.530
That image doesn't move, and you
can still scroll around.

00:20:54.530 --> 00:20:56.280
Anyway, you can do a lot
of interesting things.

00:20:59.180 --> 00:21:02.330
Basically, what we're using is
the same code path as for the

00:21:02.330 --> 00:21:04.940
base layer, what I was
describing earlier.

00:21:04.940 --> 00:21:08.200
And we have the same
constraints.

00:21:08.200 --> 00:21:11.450
We tried to do a couple of
clever things to help you with

00:21:11.450 --> 00:21:14.150
that, because if you generate
too many layers, that can be

00:21:14.150 --> 00:21:16.710
an issue in terms of memory.

00:21:16.710 --> 00:21:19.630
So we try to merger layers
if we can, and a couple

00:21:19.630 --> 00:21:21.100
of things like that.

00:21:21.100 --> 00:21:24.040
All right, so that was all about
describing how stuff

00:21:24.040 --> 00:21:25.190
worked in [INAUDIBLE].

00:21:25.190 --> 00:21:28.270
Now, how can you take advantage
of that to make your

00:21:28.270 --> 00:21:30.390
stuff faster?

00:21:30.390 --> 00:21:33.100
So basically, the WebView is
something that lets you

00:21:33.100 --> 00:21:35.890
display [INAUDIBLE]
and content.

00:21:35.890 --> 00:21:42.670
You can consider that it has a
desktop HTML support level.

00:21:42.670 --> 00:21:45.160
And it can do all kind
of cool stuff.

00:21:45.160 --> 00:21:47.840
Right.

00:21:47.840 --> 00:21:49.880
Yeah, that's basically
what we added on

00:21:49.880 --> 00:21:51.130
the different versions.

00:21:53.760 --> 00:21:59.220
Let me go quickly because I
think I'm running a bit late.

00:21:59.220 --> 00:22:03.560
So you use that basically
like a normal view.

00:22:03.560 --> 00:22:05.320
It's just another widget.

00:22:05.320 --> 00:22:07.260
If you want to load content from
the internet, you have to

00:22:07.260 --> 00:22:09.180
use a permission, obviously.

00:22:09.180 --> 00:22:12.260
You may have to override
the WebViewClient if

00:22:12.260 --> 00:22:15.190
you want to do that.

00:22:15.190 --> 00:22:18.750
Loading content is as simple as
specifying URL or injecting

00:22:18.750 --> 00:22:22.250
some HTML directly.

00:22:22.250 --> 00:22:25.860
You may want to enable
JavaScript.

00:22:25.860 --> 00:22:28.190
And basically, in terms of the
rending, you've got those two

00:22:28.190 --> 00:22:28.860
different modes.

00:22:28.860 --> 00:22:30.530
You've got these hardware
rendering mode that I was

00:22:30.530 --> 00:22:31.510
talking about.

00:22:31.510 --> 00:22:33.790
You still have the software
rendering mode.

00:22:33.790 --> 00:22:36.810
And it's still there
for a reason.

00:22:36.810 --> 00:22:40.070
Sometimes it's going to be much
more memory efficient

00:22:40.070 --> 00:22:41.680
than using the hardware
rendering.

00:22:41.680 --> 00:22:45.250
Basically, if you have content
that's not very much, you are

00:22:45.250 --> 00:22:47.960
not going to be taking much
advantage of the rotating

00:22:47.960 --> 00:22:49.286
architecture.

00:22:49.286 --> 00:22:52.850
See, if your content won't move,
you don't really care.

00:22:52.850 --> 00:22:55.735
And in that case, it might be
much faster, and even as

00:22:55.735 --> 00:22:59.355
you're repainting stuff,
than using the hardware

00:22:59.355 --> 00:23:00.150
acceleration.

00:23:00.150 --> 00:23:05.350
So it's not a free lunch.

00:23:05.350 --> 00:23:09.970
If you want to use that, if your
WebView is very large, we

00:23:09.970 --> 00:23:12.140
still have to locate
the [INAUDIBLE].

00:23:12.140 --> 00:23:13.570
You're also going to
use some memory.

00:23:13.570 --> 00:23:16.790
So in some cases, that
may be a wash.

00:23:16.790 --> 00:23:20.770
Bottom line, if you don't have
too complicated content, you

00:23:20.770 --> 00:23:22.970
may want to use the software
rendering.

00:23:22.970 --> 00:23:25.150
It might be a better idea.

00:23:25.150 --> 00:23:26.180
You lose some things.

00:23:26.180 --> 00:23:29.060
You know, you have CSS3D
or inline video.

00:23:29.060 --> 00:23:32.710
But that might be OK.

00:23:32.710 --> 00:23:32.930
Right.

00:23:32.930 --> 00:23:35.620
How do you get hardware
accelerated view?

00:23:35.620 --> 00:23:38.200
Well, if your application is
accelerated, the WebView is

00:23:38.200 --> 00:23:40.820
simply going to be asked
to be drawn on to

00:23:40.820 --> 00:23:43.180
an accelerated canvas.

00:23:43.180 --> 00:23:46.770
And from then, we
know what to do.

00:23:46.770 --> 00:23:49.040
If you want to force
the 2D rendering--

00:23:49.040 --> 00:23:50.860
so let's say that you have an
application that is hardware

00:23:50.860 --> 00:23:53.550
accelerated, which
I hope you are--

00:23:53.550 --> 00:23:57.180
you may just want to specify
the layer type to software

00:23:57.180 --> 00:23:58.380
just for the WebView.

00:23:58.380 --> 00:24:01.022
And that's going to trigger the
2D rendering code path.

00:24:03.740 --> 00:24:08.090
So one nice thing is
accessibility is supported.

00:24:08.090 --> 00:24:12.440
So if you want to have
accessibility in your

00:24:12.440 --> 00:24:14.360
application in Java WebView,
you basically don't have

00:24:14.360 --> 00:24:15.570
anything to do.

00:24:15.570 --> 00:24:18.560
Just one thing, try to enable
JavaScript because then we

00:24:18.560 --> 00:24:21.160
support more things like Explore
by Touch, or Gesture

00:24:21.160 --> 00:24:23.400
Navigation.

00:24:23.400 --> 00:24:24.560
And it's basically
the same solution

00:24:24.560 --> 00:24:26.000
as Chrome or ChromeOS.

00:24:26.000 --> 00:24:31.180
So if you want to make your
content accessible, you can

00:24:31.180 --> 00:24:32.410
test that on Chrome.

00:24:32.410 --> 00:24:33.660
It's going to work on
the WebView as well.

00:24:36.530 --> 00:24:39.300
If you want to implement inline
and fullscreen video,

00:24:39.300 --> 00:24:41.920
one little [INAUDIBLE], and
this one talking about it

00:24:41.920 --> 00:24:44.090
here, is that we don't
know how to display

00:24:44.090 --> 00:24:45.750
the fullscreen mode.

00:24:45.750 --> 00:24:47.290
We have just a normal view.

00:24:47.290 --> 00:24:49.350
So if you tell us, OK, I've
got a video and I want to

00:24:49.350 --> 00:24:51.830
display fullscreen, we don't
know where to put it.

00:24:51.830 --> 00:24:55.160
So you have to give us a view.

00:24:55.160 --> 00:24:58.830
And when we go to fullscreen
mode, we'll just redirect

00:24:58.830 --> 00:25:00.220
video texture to that one.

00:25:00.220 --> 00:25:02.040
So that's how you do it.

00:25:02.040 --> 00:25:04.770
You just have to implement
onShowCustomView and

00:25:04.770 --> 00:25:06.020
onHideCustomView.

00:25:08.890 --> 00:25:11.410
The interesting thing with the
WebView is that you can bind

00:25:11.410 --> 00:25:14.702
the JavaScript code to
your [? direct ?]

00:25:14.702 --> 00:25:15.910
code.

00:25:15.910 --> 00:25:17.530
You do it in a very
simple way.

00:25:17.530 --> 00:25:19.890
You create this class.

00:25:19.890 --> 00:25:24.530
And here I'm just defining
the shortest method.

00:25:24.530 --> 00:25:25.310
And that takes [INAUDIBLE]

00:25:25.310 --> 00:25:26.480
as a parameter.

00:25:26.480 --> 00:25:30.200
And if I call that function,
JavaScript is just going to

00:25:30.200 --> 00:25:33.970
show me this little toast
message on my application.

00:25:33.970 --> 00:25:35.130
How do you bind that?

00:25:35.130 --> 00:25:36.720
It's very, very simple.

00:25:36.720 --> 00:25:40.930
You just create an instance of
that class, give it a name--

00:25:40.930 --> 00:25:42.940
so here, that's Android--

00:25:42.940 --> 00:25:44.530
add it to the WebView.

00:25:44.530 --> 00:25:48.930
And from then on, if you call
Android. showToast in

00:25:48.930 --> 00:25:52.510
JavaScript in your WebView,
that's actually going to take

00:25:52.510 --> 00:25:57.020
that bridge and execute
the [INAUDIBLE] code.

00:25:57.020 --> 00:25:59.090
All right.

00:25:59.090 --> 00:26:00.880
You can use the viewport
tag as well.

00:26:00.880 --> 00:26:06.025
That's a nice way of specifying
things like are you

00:26:06.025 --> 00:26:10.080
letting the user zoom or
not in your content?

00:26:10.080 --> 00:26:14.440
So if you have a web app and you
know explicitly that your

00:26:14.440 --> 00:26:16.110
content is not going to be
zoomable, maybe you want to

00:26:16.110 --> 00:26:18.650
prevent a user to do that,
that's going to provide a

00:26:18.650 --> 00:26:23.890
better integration with your
app, you just do it that way.

00:26:23.890 --> 00:26:26.480
There's a bunch of other
parameters that you can use,

00:26:26.480 --> 00:26:28.994
but the documentation
is there.

00:26:32.800 --> 00:26:36.460
Let's talk again about the
layers and the animation.

00:26:36.460 --> 00:26:40.920
Basically try to remember,
use layers.

00:26:40.920 --> 00:26:43.140
And if you have been to some
of the other talks about

00:26:43.140 --> 00:26:46.320
Android, this is exactly the
same problem and the same

00:26:46.320 --> 00:26:50.380
solution for the hardware
acceleration on the Android

00:26:50.380 --> 00:26:51.930
application.

00:26:51.930 --> 00:26:55.590
So the typical way that you
would then animate some

00:26:55.590 --> 00:27:00.090
content in a web page or in
your web content, you get

00:27:00.090 --> 00:27:01.790
element, [INAUDIBLE]

00:27:01.790 --> 00:27:04.590
left and top of that element.

00:27:04.590 --> 00:27:06.180
And that's basically the
worst possible way

00:27:06.180 --> 00:27:08.670
that you can do something.

00:27:08.670 --> 00:27:11.400
What you can do instead is
move that to a layer.

00:27:11.400 --> 00:27:13.970
And you can do it very simply
by just applying a CSS

00:27:13.970 --> 00:27:15.320
transform 3D.

00:27:15.320 --> 00:27:19.900
Even if it's, as here, a
completely empty transform,

00:27:19.900 --> 00:27:22.460
that's going to move that
content to its own layer.

00:27:22.460 --> 00:27:25.720
And then moving it around is
going to be much faster.

00:27:25.720 --> 00:27:27.730
Ideally, don't even use the left
[? enter, ?] because the

00:27:27.730 --> 00:27:30.430
left [? enter ?] may trigger
some [INAUDIBLE] in WebKit.

00:27:30.430 --> 00:27:33.980
So just use the translate 3D
with the right parameters, and

00:27:33.980 --> 00:27:35.860
that's probably the best way.

00:27:35.860 --> 00:27:40.355
So as an example, if you want to
take this and move it like

00:27:40.355 --> 00:27:43.330
that on the right, how
do you do that?

00:27:43.330 --> 00:27:46.770
Well, in JavaScript, you would
do something like that.

00:27:46.770 --> 00:27:49.640
And basically, you call this
run function, you set a

00:27:49.640 --> 00:27:51.700
timeout so that it's
called again.

00:27:51.700 --> 00:27:55.750
You get the delta, you see how
much pixel you need to move.

00:27:55.750 --> 00:27:58.630
And you specify the
left element.

00:27:58.630 --> 00:27:59.540
So two things here.

00:27:59.540 --> 00:28:03.690
First, it's actually a pretty
complex piece of code.

00:28:03.690 --> 00:28:06.100
Second, it's going to
be really slow.

00:28:06.100 --> 00:28:08.100
So if you try it on your tablet,
it's going to be

00:28:08.100 --> 00:28:09.900
something like that.

00:28:09.900 --> 00:28:11.510
And the reason is because
you're going to

00:28:11.510 --> 00:28:13.220
have to go to WebKit.

00:28:13.220 --> 00:28:15.550
WebKit may be busy doing
a left [? top. ?]

00:28:15.550 --> 00:28:17.090
We have to generate
new content,

00:28:17.090 --> 00:28:19.000
send it back, repaint.

00:28:19.000 --> 00:28:21.440
It's not optimal.

00:28:21.440 --> 00:28:25.440
In CSS animation, that's
how you do it.

00:28:25.440 --> 00:28:30.510
That to my eyes is much cleaner,
much more readable.

00:28:30.510 --> 00:28:34.760
And it performs a lot better.

00:28:34.760 --> 00:28:37.660
So that on the same zoom tablet,
which is not the

00:28:37.660 --> 00:28:39.130
fastest device in existence.

00:28:39.130 --> 00:28:43.640
And that's actually running
on only Chrome or

00:28:43.640 --> 00:28:45.750
ICS, I don't remember.

00:28:45.750 --> 00:28:50.120
So the CSS animation basically
gives you a much fast content.

00:28:50.120 --> 00:28:52.090
It's v-synced, it's
higher level.

00:28:52.090 --> 00:28:54.510
And you can do pretty complex
animation as well.

00:28:54.510 --> 00:28:57.490
And the way it works is because
basically for elements

00:28:57.490 --> 00:28:59.610
that are animated, you are
going to create a layer.

00:28:59.610 --> 00:29:02.030
And as we saw, layers
are much nicer.

00:29:02.030 --> 00:29:04.550
So you can do complex animations
like that.

00:29:04.550 --> 00:29:05.900
And that's very easy to do.

00:29:05.900 --> 00:29:09.600
You just set up for each element
a small animation.

00:29:09.600 --> 00:29:12.240
You can imbricate things.

00:29:12.240 --> 00:29:15.020
It's really nice.

00:29:15.020 --> 00:29:18.230
So I talk about layers, and they
are nice, and all that.

00:29:21.350 --> 00:29:23.290
how do you get layers?

00:29:23.290 --> 00:29:28.160
Well basically, you've got
a few rules in WebKit.

00:29:28.160 --> 00:29:29.920
And those are the rules.

00:29:29.920 --> 00:29:33.140
If you apply a transform3d
element, it's going to be put

00:29:33.140 --> 00:29:35.670
onto it's own layer,
et cetera.

00:29:35.670 --> 00:29:39.225
For the video, for the
canvases, for the CSS

00:29:39.225 --> 00:29:43.660
animation, all that is going
to create layers.

00:29:43.660 --> 00:29:46.770
As I said before, on Android we
are actually using layers

00:29:46.770 --> 00:29:48.820
to do more things.

00:29:48.820 --> 00:29:50.180
So we got additional rules.

00:29:50.180 --> 00:29:53.540
So if you are using a fixed
position element, bam, layer.

00:29:53.540 --> 00:29:55.600
And et cetera.

00:29:55.600 --> 00:29:58.670
OverFlow-scroll, and iFrames,
canvas, fixed background

00:29:58.670 --> 00:30:02.660
update, all these things are
going to create a layer.

00:30:02.660 --> 00:30:04.710
The thing to remember, though,
is that even if they are on

00:30:04.710 --> 00:30:08.690
their own layer, this is a
purely implementation detail.

00:30:08.690 --> 00:30:11.870
The content is going to
be visibly the same if

00:30:11.870 --> 00:30:13.020
you don't use layer.

00:30:13.020 --> 00:30:15.680
It's just going to be much
slower to render.

00:30:15.680 --> 00:30:17.900
Of course, I mean if you
are in CSS 3D, that's

00:30:17.900 --> 00:30:18.610
not going to work.

00:30:18.610 --> 00:30:22.690
But that's a special case,
because we don't do the

00:30:22.690 --> 00:30:25.890
transform, only 2D.

00:30:25.890 --> 00:30:27.730
So basically, if you have
content that you are

00:30:27.730 --> 00:30:31.860
animating, put it
onto a layer.

00:30:31.860 --> 00:30:34.240
Now, the thing you have to
remember is that creating a

00:30:34.240 --> 00:30:36.990
layer is not cheap, because
you have to

00:30:36.990 --> 00:30:38.540
basically do two repaints.

00:30:38.540 --> 00:30:41.590
You have to remove that content
from whatever surface

00:30:41.590 --> 00:30:46.580
it was, repaint that surface,
then create more textures and

00:30:46.580 --> 00:30:47.850
paint those textures as well.

00:30:47.850 --> 00:30:50.760
So all in all, it's a pretty
expensive operation.

00:30:50.760 --> 00:30:53.520
So a typical trick is just,
well, if you know that

00:30:53.520 --> 00:30:55.460
something is going to be
animated, move it onto a

00:30:55.460 --> 00:30:57.470
layer, keep it there.

00:30:57.470 --> 00:31:01.040
I mean, above all, don't do all
the back and forth all the

00:31:01.040 --> 00:31:05.060
time between I'm on
a layer, I'm on a

00:31:05.060 --> 00:31:07.780
base surface, et cetera.

00:31:07.780 --> 00:31:11.100
The tiles are 256 by 256,
at least for now.

00:31:11.100 --> 00:31:13.380
And you may take advantage
of that.

00:31:13.380 --> 00:31:17.280
So if for example, you the
viewport tag to specify that

00:31:17.280 --> 00:31:19.620
you are working toward the scale
of 1.0, you can then

00:31:19.620 --> 00:31:21.740
make sure that your content
is going to fit on

00:31:21.740 --> 00:31:22.540
just a single tile.

00:31:22.540 --> 00:31:25.090
Then it's going to be much
faster than if you are just

00:31:25.090 --> 00:31:28.870
one tile and [INAUDIBLE].

00:31:28.870 --> 00:31:30.030
You can't always do that.

00:31:30.030 --> 00:31:34.050
But you can, think about it.

00:31:34.050 --> 00:31:36.260
There is a slightly different
code path for images.

00:31:36.260 --> 00:31:39.330
If you are using images, and
let's say that you are using

00:31:39.330 --> 00:31:42.870
lots of images, you may want
to apply the [INAUDIBLE]

00:31:42.870 --> 00:31:46.721
directly on the image element
not on the [INAUDIBLE] that

00:31:46.721 --> 00:31:48.200
will contain that image.

00:31:48.200 --> 00:31:53.720
And that basically lets us just
get that image, and we

00:31:53.720 --> 00:31:54.600
can reuse it.

00:31:54.600 --> 00:31:57.450
And we just have to run
the rates at scale 1.

00:31:57.450 --> 00:32:01.530
And we let the GPU
do this scaling.

00:32:01.530 --> 00:32:05.180
And as I said, you may want to
try the software rendering.

00:32:05.180 --> 00:32:09.080
That might be nicer.

00:32:09.080 --> 00:32:11.990
While I said that you should not
use JavaScript, we still

00:32:11.990 --> 00:32:15.020
did implements, improved
stuff in JellyBean.

00:32:15.020 --> 00:32:17.770
So stuff are not as
bad as they were.

00:32:17.770 --> 00:32:20.540
But yet, I would say,
if you can use CSS

00:32:20.540 --> 00:32:22.100
animation, much nicer.

00:32:24.780 --> 00:32:27.820
All right, so one of the typical
issues that people

00:32:27.820 --> 00:32:31.440
have with the WebView
is synchronization.

00:32:31.440 --> 00:32:34.080
And by that I just mean, only
synchronize what you are

00:32:34.080 --> 00:32:38.390
showing on screen with
the Java stuff.

00:32:38.390 --> 00:32:42.690
And so if you remember that
previous diagram, we create,

00:32:42.690 --> 00:32:44.410
we get an event, we create
a new picture, we

00:32:44.410 --> 00:32:46.030
send it to the UI.

00:32:46.030 --> 00:32:50.750
Before when we were just using
the 2D rendering, we were

00:32:50.750 --> 00:32:52.740
receiving that picture, and
basically we could just draw

00:32:52.740 --> 00:32:53.820
it instantly.

00:32:53.820 --> 00:32:55.550
So we had this onPicture
[INAUDIBLE]

00:32:55.550 --> 00:32:58.350
callback that is
not imbricated.

00:32:58.350 --> 00:33:01.080
That when we were receiving it,
you would know that, OK

00:33:01.080 --> 00:33:02.700
that's the new content.

00:33:02.700 --> 00:33:04.900
But now of course, things
are different.

00:33:04.900 --> 00:33:08.620
If you create your picture,
we send it to the UI side.

00:33:08.620 --> 00:33:10.800
You get that onPictureChanged.

00:33:10.800 --> 00:33:14.000
But between the time you receive
that and the final

00:33:14.000 --> 00:33:17.150
rendered content, there
is a delay.

00:33:17.150 --> 00:33:20.020
And something that's not great
because how do you know that

00:33:20.020 --> 00:33:25.830
what you send to the WebView is
usable is binary rendered.

00:33:25.830 --> 00:33:27.550
So the solution.

00:33:27.550 --> 00:33:29.060
We don't have an API for that.

00:33:29.060 --> 00:33:32.280
But we have a solution that
actually works everywhere.

00:33:32.280 --> 00:33:35.800
And that's by using the fact
that the CSS animations have

00:33:35.800 --> 00:33:37.310
to be synchronized.

00:33:37.310 --> 00:33:40.170
So what you do is you create
the bridge objects.

00:33:40.170 --> 00:33:43.890
So here, we just add this
finish rendering method.

00:33:43.890 --> 00:33:46.810
And we just add that
to the WebView.

00:33:46.810 --> 00:33:52.250
And the simple test case here
is, I've got an application,

00:33:52.250 --> 00:33:55.130
I'm having WebView, and I'm
loading the content in my

00:33:55.130 --> 00:34:01.210
WebView, and I want to show some
text before the content

00:34:01.210 --> 00:34:02.950
is displayed saying, your
content is loading, or

00:34:02.950 --> 00:34:04.190
something like that.

00:34:04.190 --> 00:34:05.590
When the content has
been loaded, you

00:34:05.590 --> 00:34:07.460
can remove the text.

00:34:07.460 --> 00:34:09.239
And that's what the finish
rendering method does.

00:34:09.239 --> 00:34:14.790
You just set the visibility of
that text view to invisible.

00:34:14.790 --> 00:34:17.580
So we just create an instance
of that, add it to the

00:34:17.580 --> 00:34:19.280
WebView, call it Android.

00:34:21.830 --> 00:34:23.199
And the CSS Magic is here.

00:34:23.199 --> 00:34:28.530
You are going to create two
CSS rules for one element.

00:34:28.530 --> 00:34:31.350
One is just to move that element
to a composited layer.

00:34:31.350 --> 00:34:33.560
So we'll use that code path.

00:34:33.560 --> 00:34:37.380
The second is to say, if you are
on the class finish, do a

00:34:37.380 --> 00:34:40.060
slightly different translate so
that we will wait for that

00:34:40.060 --> 00:34:41.940
transition to happen.

00:34:41.940 --> 00:34:47.730
And for internal reason, you
have to give us something more

00:34:47.730 --> 00:34:49.949
than zero milliseconds.

00:34:49.949 --> 00:34:54.389
So if you got that, on
the HTML side, that's

00:34:54.389 --> 00:34:55.449
how it would look.

00:34:55.449 --> 00:34:58.260
You would add your content,
you would put your own

00:34:58.260 --> 00:35:00.980
transition element, example, at
the end of the body so you

00:35:00.980 --> 00:35:03.620
know that the rest has been
loaded, and blah, blah, blah.

00:35:03.620 --> 00:35:06.690
And when stuff are loaded,
you call load.

00:35:06.690 --> 00:35:08.070
And that's a very
simple example.

00:35:08.070 --> 00:35:10.900
If you have more complicated
content with images, or things

00:35:10.900 --> 00:35:13.350
like that, you may want to have
JavaScript on there on

00:35:13.350 --> 00:35:16.420
the onload event of
those images.

00:35:16.420 --> 00:35:19.050
You get that, and the load
implementation is basically

00:35:19.050 --> 00:35:22.730
saying, when I'm loaded, set
the class to finish.

00:35:22.730 --> 00:35:25.780
And add an event listener
to that element.

00:35:25.780 --> 00:35:29.170
When the WebKit transition has
finished, then you can call

00:35:29.170 --> 00:35:31.350
the finish rendering method
of the final [? Android ?]

00:35:31.350 --> 00:35:32.520
object.

00:35:32.520 --> 00:35:39.130
And basically that says to us,
OK, when you're loaded, use

00:35:39.130 --> 00:35:41.370
this CSS finish rule.

00:35:41.370 --> 00:35:45.790
And when that rule has been
fully executed, and we know

00:35:45.790 --> 00:35:47.540
that because we got this
event [INAUDIBLE].

00:35:47.540 --> 00:35:49.380
And then we call the callback.

00:35:49.380 --> 00:35:52.100
And at that, you are
synchronized.

00:35:52.100 --> 00:35:53.830
All right.

00:35:53.830 --> 00:35:59.070
So let me talk a bit
about the debug.

00:35:59.070 --> 00:36:00.040
OK, you've got all this.

00:36:00.040 --> 00:36:01.490
I'll do debug this content.

00:36:04.220 --> 00:36:05.800
There's a few things.

00:36:05.800 --> 00:36:09.540
First thing you can do, you
can use a console, the old

00:36:09.540 --> 00:36:13.560
school just output [INAUDIBLE]

00:36:13.560 --> 00:36:15.480
in your adb logcat.

00:36:15.480 --> 00:36:17.520
You can do that in JavaScript.

00:36:17.520 --> 00:36:21.372
You know, if you get adb
logcat, that's how

00:36:21.372 --> 00:36:21.990
it would look like.

00:36:21.990 --> 00:36:23.990
So of course, you can do all
the typical stuff in logcat

00:36:23.990 --> 00:36:26.090
feature and whatnot.

00:36:26.090 --> 00:36:30.680
You can actually specify or
use different logcat level

00:36:30.680 --> 00:36:34.250
here, the same as you
would in Java.

00:36:34.250 --> 00:36:37.380
One thing you can do, though,
is you can intercept those

00:36:37.380 --> 00:36:39.850
message calls for
your WebView.

00:36:39.850 --> 00:36:43.910
And then you can do
whatever you want.

00:36:43.910 --> 00:36:44.850
All right.

00:36:44.850 --> 00:36:48.440
One thing that's pretty useful,
if you are into

00:36:48.440 --> 00:36:50.400
testing, is Selenium
WebDriver.

00:36:50.400 --> 00:36:52.440
And it basically provides you
a testing infrastructure for

00:36:52.440 --> 00:36:55.690
your estimated content.

00:36:55.690 --> 00:36:58.450
For mobile, the nice thing is
that it supports the touch,

00:36:58.450 --> 00:37:01.870
gestures, you can take a
screenshot, compare it to a

00:37:01.870 --> 00:37:04.316
previous taken one, so you know
that your tests are going

00:37:04.316 --> 00:37:05.400
to pass on it.

00:37:05.400 --> 00:37:07.270
And more information
are there.

00:37:07.270 --> 00:37:09.390
The way it works is
pretty simple.

00:37:09.390 --> 00:37:11.130
That's an example
of a test case.

00:37:11.130 --> 00:37:14.790
You create a WebDriver,
tell it to go here.

00:37:14.790 --> 00:37:17.370
And we just open google.com.

00:37:17.370 --> 00:37:22.350
We look for the web element,
we can send keys, submit.

00:37:22.350 --> 00:37:26.310
And when we get that, we can
get the results, and assert

00:37:26.310 --> 00:37:29.260
that it corresponds to what
we are looking for.

00:37:29.260 --> 00:37:32.370
So anyway, that's just testing
infrastructure.

00:37:32.370 --> 00:37:38.170
So if you have content, not just
simply present content,

00:37:38.170 --> 00:37:41.080
but are doing more interaction
with the user, you may want to

00:37:41.080 --> 00:37:42.330
look into that.

00:37:44.310 --> 00:37:48.680
The other thing that you can do
is use the Android Browser

00:37:48.680 --> 00:37:49.780
debug mode.

00:37:49.780 --> 00:37:54.970
So I mean, if you try your own
unique [INAUDIBLE], the

00:37:54.970 --> 00:37:56.800
Android browser is not
there anymore.

00:37:56.800 --> 00:37:58.600
Your Galaxy Nexus
is still there.

00:37:58.600 --> 00:38:00.160
So it's not a perfect mode.

00:38:00.160 --> 00:38:01.990
And we are working on it.

00:38:01.990 --> 00:38:03.750
But if you have the Android
browser, there is a bunch of

00:38:03.750 --> 00:38:05.770
stuff that you can do.

00:38:05.770 --> 00:38:10.280
So the simplest thing is you
can enable that mode.

00:38:10.280 --> 00:38:12.220
To do that, you just
go there, type

00:38:12.220 --> 00:38:15.780
about:debug, you press Enter.

00:38:15.780 --> 00:38:18.740
And it's just a toggle.

00:38:18.740 --> 00:38:22.780
So it's going to trigger on and
off this Debug when you

00:38:22.780 --> 00:38:23.160
[INAUDIBLE]

00:38:23.160 --> 00:38:24.810
in the settings of
the browser.

00:38:24.810 --> 00:38:27.890
And here, there's a lot of
interesting options.

00:38:27.890 --> 00:38:30.180
Probably the one you are
interested in are UAString.

00:38:30.180 --> 00:38:32.680
So you can specify a different
user agent

00:38:32.680 --> 00:38:34.050
string for the browser.

00:38:34.050 --> 00:38:37.100
So you can easy to test if your
content is really not

00:38:37.100 --> 00:38:40.200
working, or if it's just because
the website is sending

00:38:40.200 --> 00:38:45.080
a different content, depending
on the UA.

00:38:45.080 --> 00:38:47.360
The other really interesting
thing, if you are trying to

00:38:47.360 --> 00:38:47.650
[? implement ?]

00:38:47.650 --> 00:38:50.590
performances, is the
Visual Indicator.

00:38:50.590 --> 00:38:53.480
So if you enable it, that's
what it would look like.

00:38:53.480 --> 00:38:58.540
And here, you can see all the
tiles that I was describing on

00:38:58.540 --> 00:39:00.562
the Google I/O web page.

00:39:00.562 --> 00:39:03.240
If you look at the tile, that's

00:39:03.240 --> 00:39:04.440
basically what you have.

00:39:04.440 --> 00:39:07.465
As useful information, you got
the coordinates, you got the

00:39:07.465 --> 00:39:08.700
scale factor.

00:39:08.700 --> 00:39:10.860
And as I, said, there
is a new web app.

00:39:10.860 --> 00:39:13.890
You may have some interesting
optimizations to be made in

00:39:13.890 --> 00:39:16.330
terms of with the
scale factors.

00:39:16.330 --> 00:39:20.920
So you can tailor the images
that you are showing, or

00:39:20.920 --> 00:39:28.460
things like that, and prevent
user to zoom around, or using

00:39:28.460 --> 00:39:30.350
the viewport tag.

00:39:30.350 --> 00:39:32.240
And the last thing is just
the painting time.

00:39:32.240 --> 00:39:34.040
That's with CPU time, so that
does not account for the

00:39:34.040 --> 00:39:35.420
entire pipeline.

00:39:35.420 --> 00:39:38.110
But that can be interesting if
you see that some of your

00:39:38.110 --> 00:39:42.610
contact is very slow for
whatever reason to show up.

00:39:42.610 --> 00:39:45.480
That could give you
some hints.

00:39:45.480 --> 00:39:48.650
The other thing is some of the
element, like fixed element,

00:39:48.650 --> 00:39:50.640
are shown in a different
color.

00:39:50.640 --> 00:39:53.340
So if you remember that I/O
web page earlier, it was

00:39:53.340 --> 00:39:56.620
showing the positioned
elements.

00:39:56.620 --> 00:40:01.540
This is just using a slightly
tinted red background.

00:40:01.540 --> 00:40:08.210
And the other thing is you can
see if I take this example and

00:40:08.210 --> 00:40:14.220
I zoom, that the tiles for the
Android are actually at scale

00:40:14.220 --> 00:40:18.450
1.0, while the rest of the tile
are at scale 2.70, which

00:40:18.450 --> 00:40:21.370
is the scale I was zooming
in at the time.

00:40:21.370 --> 00:40:23.930
And that's because we've got
this optimization where if you

00:40:23.930 --> 00:40:28.190
only have image on your layer,
we are not going to go further

00:40:28.190 --> 00:40:29.870
than 1.00x.

00:40:29.870 --> 00:40:32.430
So that's, again, another
optimization that you can do.

00:40:35.260 --> 00:40:37.320
You've got a bunch
of debug commands

00:40:37.320 --> 00:40:38.570
that are pretty useful.

00:40:42.560 --> 00:40:44.320
One of the nice ones
is RenderTree.

00:40:44.320 --> 00:40:48.040
That's going to basically create
a renderTree.txt on the

00:40:48.040 --> 00:40:49.510
[INAUDIBLE] card.

00:40:49.510 --> 00:40:51.490
We can grab that using adb.

00:40:51.490 --> 00:40:53.280
And that's how it looks.

00:40:53.280 --> 00:40:57.230
It basically shows you the
rendering tree of WebKit.

00:40:57.230 --> 00:40:58.810
So that's a bit involved.

00:40:58.810 --> 00:41:03.030
But if you want to read DIVX
tag, that can be quite useful.

00:41:03.030 --> 00:41:06.450
The other interesting one
is the LayersTree.

00:41:06.450 --> 00:41:11.330
And that's actually a problem in
general with Browser and in

00:41:11.330 --> 00:41:13.920
Orchid WebView is that
there is no good

00:41:13.920 --> 00:41:17.130
debugging tool for layers.

00:41:17.130 --> 00:41:19.450
We provide that [INAUDIBLE],
which just gives

00:41:19.450 --> 00:41:21.020
you the tree of layers.

00:41:21.020 --> 00:41:23.020
And if you look into it,
you can, for example,

00:41:23.020 --> 00:41:24.570
look at layer ID.

00:41:24.570 --> 00:41:27.400
And this is a fixed element on
the Google I/O web page.

00:41:27.400 --> 00:41:29.590
And you could see because
there's those fixed left,

00:41:29.590 --> 00:41:32.000
fixed up, fixed right,
and stuff.

00:41:32.000 --> 00:41:35.770
But if you look at the layer ID,
that corresponds to that

00:41:35.770 --> 00:41:37.880
blue number on the layer.

00:41:37.880 --> 00:41:40.160
So that can be helpful.

00:41:40.160 --> 00:41:42.110
It's not optimal.

00:41:42.110 --> 00:41:46.520
We can definitely do
things better.

00:41:46.520 --> 00:41:51.680
But there is definitely a lack
of good tools to deal with

00:41:51.680 --> 00:41:56.800
layers and stuff like that
even on the desktop.

00:41:56.800 --> 00:42:00.910
Just as an aside, as we are
using WebKits as well, if you

00:42:00.910 --> 00:42:04.380
do stuff in Safari or Chrome
and use their debug tools,

00:42:04.380 --> 00:42:07.970
it's probably going to go a long
way in terms of debugging

00:42:07.970 --> 00:42:09.690
your content.

00:42:09.690 --> 00:42:12.540
But you don't know
what follows.

00:42:12.540 --> 00:42:15.280
You don't know that the layer's
architecture is not

00:42:15.280 --> 00:42:19.100
exposed, so anyway.

00:42:19.100 --> 00:42:23.580
One thing that we are working on
that's not ready yet is to

00:42:23.580 --> 00:42:26.020
actually not use that anymore.

00:42:26.020 --> 00:42:30.670
But instead, we are going to
deliver HierarcyViewer.

00:42:30.670 --> 00:42:32.660
And if you don't know
HierarchyViewer, definitely

00:42:32.660 --> 00:42:33.270
look into it.

00:42:33.270 --> 00:42:36.140
It's a really nice tool that
basically lets you connect to

00:42:36.140 --> 00:42:39.890
your application, and it's prone
to viewer hierarchy.

00:42:39.890 --> 00:42:44.920
So what we'll do is that when
you have a webview instead of

00:42:44.920 --> 00:42:49.200
just showing this rectangle
same webview that's not so

00:42:49.200 --> 00:42:51.790
useful, you can see here
that we can show the

00:42:51.790 --> 00:42:54.220
entire tree of layers.

00:42:54.220 --> 00:42:56.140
You got a bunch of information
about the layers.

00:42:56.140 --> 00:42:59.830
You can grab the content
as well.

00:42:59.830 --> 00:43:01.980
And all kinds of interesting
things.

00:43:05.910 --> 00:43:06.700
And that's it.

00:43:06.700 --> 00:43:08.480
So actually, I was faster
than what I thought.

00:43:11.590 --> 00:43:13.930
So if you have any
questions, the

00:43:13.930 --> 00:43:15.100
microphones are on the aisles.

00:43:15.100 --> 00:43:18.304
And you should just
go to microphones.

00:43:18.304 --> 00:43:26.600
[APPLAUSE]

00:43:26.600 --> 00:43:29.660
AUDIENCE: Sorry in JellyBean,
if I make a web app just for

00:43:29.660 --> 00:43:33.810
JellyBean, would the WebView
use the Chrome for Android?

00:43:33.810 --> 00:43:34.400
NICOLAS ROARD: No.

00:43:34.400 --> 00:43:35.750
AUDIENCE: No, still use
the old browser

00:43:35.750 --> 00:43:36.860
rendering, and all that?

00:43:36.860 --> 00:43:38.150
NICOLAS ROARD: Yes.

00:43:38.150 --> 00:43:41.840
So I mean, the reason
is pretty simple.

00:43:41.840 --> 00:43:43.990
I mean, the WebView is part
of the platform, and

00:43:43.990 --> 00:43:46.000
Chrome is on Market.

00:43:46.000 --> 00:43:49.490
So if you update Chrome and
Market, we can't replace the

00:43:49.490 --> 00:43:51.170
implementation of the WebView.

00:43:51.170 --> 00:43:53.130
And even if we wanted, we might
not want to do that,

00:43:53.130 --> 00:43:54.380
because that could break
compatibility.

00:43:59.590 --> 00:44:02.920
AUDIENCE: We are using app
cache within WebView.

00:44:02.920 --> 00:44:06.700
So different OEM I'm seeing,
update, even some OEM

00:44:06.700 --> 00:44:08.060
[INAUDIBLE].

00:44:08.060 --> 00:44:11.100
On the same level, for example,
Honeycomb, or

00:44:11.100 --> 00:44:14.510
[INAUDIBLE], same version level
but different OEMs,

00:44:14.510 --> 00:44:16.780
browsers, triggers update
ready event,

00:44:16.780 --> 00:44:17.960
some of them don't.

00:44:17.960 --> 00:44:21.430
So it's very difficult to
implement this app cache

00:44:21.430 --> 00:44:22.420
within the WebView.

00:44:22.420 --> 00:44:24.220
Have you noticed this problem?

00:44:24.220 --> 00:44:26.390
Or is it something you
guys are working on?

00:44:26.390 --> 00:44:28.030
NICOLAS ROARD: I'm not sure
I understand the question.

00:44:28.030 --> 00:44:30.690
It's about triggering ready
events on app cache?

00:44:30.690 --> 00:44:33.370
AUDIENCE: Yeah, update ready
events, or we can refresh the

00:44:33.370 --> 00:44:36.760
page, so with the new content
within the WebView.

00:44:36.760 --> 00:44:40.450
So that if you rely on the
update ready event, then I can

00:44:40.450 --> 00:44:43.030
refresh the while view,
so I get the new

00:44:43.030 --> 00:44:43.970
content on the browser.

00:44:43.970 --> 00:44:47.260
But some of the OEMs,
I see update ready

00:44:47.260 --> 00:44:48.970
event is not firing.

00:44:48.970 --> 00:44:51.040
So it's on the same
[INAUDIBLE]

00:44:51.040 --> 00:44:54.670
version, but different OEM has
different ways that update

00:44:54.670 --> 00:44:56.020
ready event files.

00:44:58.990 --> 00:45:00.730
NICOLAS ROARD: I'm not sure.

00:45:00.730 --> 00:45:03.250
Can you come to see me after
the presentation?

00:45:03.250 --> 00:45:05.450
Because as far as I know,
things are working.

00:45:05.450 --> 00:45:07.730
But we can look into it.

00:45:10.270 --> 00:45:11.760
AUDIENCE: Hi, I have
one question.

00:45:11.760 --> 00:45:18.090
Can I use the DVtool of my
desktop browser to [INAUDIBLE]

00:45:18.090 --> 00:45:22.270
the WebView in my phone?

00:45:22.270 --> 00:45:26.570
NICOLAS ROARD: So you mean, to
use your DVtool to connect

00:45:26.570 --> 00:45:27.820
directly to the WebView?

00:45:27.820 --> 00:45:28.670
AUDIENCE: Yes.

00:45:28.670 --> 00:45:30.540
NICOLAS ROARD: That's
not doable.

00:45:30.540 --> 00:45:34.370
But as I said, if you're using
a browser on your desktop

00:45:34.370 --> 00:45:38.560
that's using WebKit, we are
using a recent version of

00:45:38.560 --> 00:45:41.850
WebKit as well, and things
are pretty similar.

00:45:41.850 --> 00:45:44.220
And there was a lot of things
that we improved in the latest

00:45:44.220 --> 00:45:46.420
version on ICS and JellyBean.

00:45:46.420 --> 00:45:49.960
So we are very comparable
to a desktop browser.

00:45:49.960 --> 00:45:54.110
So if you try stuff on the
browser, it should work pretty

00:45:54.110 --> 00:45:57.840
much the same on the WebView,
with the caveat of all those

00:45:57.840 --> 00:46:02.460
performance and the various
tricks that I explained today.

00:46:05.780 --> 00:46:09.230
AUDIENCE: Hi, right now you
guys have the ability to

00:46:09.230 --> 00:46:12.740
synchronously call from
JavaScript into native code.

00:46:12.740 --> 00:46:15.180
I was wondering if you're going
to be able to do that in

00:46:15.180 --> 00:46:16.000
the reverse?

00:46:16.000 --> 00:46:19.110
Sort of like on iOS, there's the
ability to get string by

00:46:19.110 --> 00:46:19.720
[INAUDIBLE]

00:46:19.720 --> 00:46:21.610
JavaScript string, how
you can get data from

00:46:21.610 --> 00:46:22.780
JavaScript int native.

00:46:22.780 --> 00:46:24.350
I was wondering if you're going
to implement something

00:46:24.350 --> 00:46:27.630
like that, or planning
on Android.

00:46:27.630 --> 00:46:29.510
NICOLAS ROARD: So I mean, the
way you do that, and you can

00:46:29.510 --> 00:46:30.520
use the bridge object.

00:46:30.520 --> 00:46:33.520
And you can just pass increment
to whatever you

00:46:33.520 --> 00:46:35.580
define in your class.

00:46:35.580 --> 00:46:39.390
If I remember, the data type
that we do support are

00:46:39.390 --> 00:46:44.290
strings, and you stuff
like numbers.

00:46:44.290 --> 00:46:48.190
But you can pass some content
from JavaScript to your Java

00:46:48.190 --> 00:46:49.210
UI that way.

00:46:49.210 --> 00:46:54.100
In terms of synchronous, that's
not the case right now.

00:46:54.100 --> 00:46:55.010
And [INAUDIBLE]

00:46:55.010 --> 00:46:57.405
that's very likely not going
to happened, because in

00:46:57.405 --> 00:47:00.080
general, so you want to have
an architecture that is

00:47:00.080 --> 00:47:01.130
asynchronous.

00:47:01.130 --> 00:47:07.720
Otherwise, you are going to
possibly pause the UI.

00:47:07.720 --> 00:47:09.590
And that's going to be great
in terms of the user

00:47:09.590 --> 00:47:10.635
interaction.

00:47:10.635 --> 00:47:11.885
AUDIENCE: OK, thank you.

00:47:13.880 --> 00:47:15.730
AUDIENCE: Hi, I have
two questions.

00:47:15.730 --> 00:47:19.720
The first is during your
presentation, you were talking

00:47:19.720 --> 00:47:22.980
about adding something
on the new layer.

00:47:22.980 --> 00:47:26.450
Do we have to do something on
the down structure before, or

00:47:26.450 --> 00:47:29.900
just applying a CSS tree for
[INAUDIBLE] is enough?

00:47:29.900 --> 00:47:30.220
NICOLAS ROARD: Yes.

00:47:30.220 --> 00:47:32.090
So basically, you've got
those various rules.

00:47:32.090 --> 00:47:34.780
That's going to decide, OK, I'm
going to take that element

00:47:34.780 --> 00:47:38.690
on my DOM, and move it to a
layer, and the typical one

00:47:38.690 --> 00:47:40.130
that are in WebKit.

00:47:40.130 --> 00:47:42.690
And that, by the way, is
actually true of any

00:47:42.690 --> 00:47:46.770
WebKit-based stuff, both
on mobile and desktop.

00:47:49.650 --> 00:47:51.850
The only thing, that may not
[INAUDIBLE] rendering.

00:47:51.850 --> 00:47:54.250
But if you do a transform3d,
those are the

00:47:54.250 --> 00:47:55.530
common rules in WebKit.

00:47:55.530 --> 00:47:58.730
And that's going to move that
element to a layer.

00:47:58.730 --> 00:48:00.320
So that's all you need to do.

00:48:00.320 --> 00:48:04.930
And the typical trick that I've
seen people using is just

00:48:04.930 --> 00:48:06.820
to do a [? translate 000. ?]

00:48:06.820 --> 00:48:10.520
The one caveat is that it needs
to be a translate 3D,

00:48:10.520 --> 00:48:14.120
and not a translate 2D.

00:48:14.120 --> 00:48:17.940
That's enough to promote that
element to its own surface.

00:48:17.940 --> 00:48:20.840
AUDIENCE: Yeah, so everything
is done by your browser.

00:48:20.840 --> 00:48:23.340
And the other question
is very, very quick.

00:48:23.340 --> 00:48:32.520
There is no plan to import the
Chrome Dev tools on the

00:48:32.520 --> 00:48:33.888
default browser, the WebView?

00:48:36.505 --> 00:48:38.140
NICOLAS ROARD: You know, that's
going for [INAUDIBLE].

00:48:38.140 --> 00:48:40.290
But right now, I'm not sure.

00:48:40.290 --> 00:48:41.540
AUDIENCE: OK, thank you.

00:48:44.620 --> 00:48:45.420
AUDIENCE: Good presentation.

00:48:45.420 --> 00:48:48.880
I was wondering, the CSS
animation, is that all static?

00:48:48.880 --> 00:48:52.470
Or can you dynamically change
it based on user input?

00:48:52.470 --> 00:48:53.030
NICOLAS ROARD: Oh no, totally.

00:48:53.030 --> 00:48:55.625
I mean, here I just show example
where you specify it

00:48:55.625 --> 00:48:57.250
in text, in your CSS file.

00:48:57.250 --> 00:49:02.660
But of course, you can add CSS
styling from JavaScript.

00:49:02.660 --> 00:49:04.750
In JavaScript, you can
manipulate the DOM, and you

00:49:04.750 --> 00:49:07.340
can manipulate the
CSS as well.

00:49:07.340 --> 00:49:09.370
So you can very, very well.

00:49:09.370 --> 00:49:11.710
I mean, most people do that.

00:49:11.710 --> 00:49:14.660
You respond to you some user
interaction and you are going

00:49:14.660 --> 00:49:16.920
to apply a new style in CSS.

00:49:16.920 --> 00:49:18.570
And that new style happens
to have like

00:49:18.570 --> 00:49:20.300
translate 3D, or whatnot.

00:49:20.300 --> 00:49:25.380
But as I said, it's generally
pretty costly to get an

00:49:25.380 --> 00:49:27.380
element from a base
surface to its won

00:49:27.380 --> 00:49:29.750
surface, to its own layer.

00:49:29.750 --> 00:49:33.640
So if you can keep things on
layers, that's better because

00:49:33.640 --> 00:49:36.260
then we don't have to do
this back and forth.

00:49:36.260 --> 00:49:36.990
It's not always possible.

00:49:36.990 --> 00:49:40.280
You know, you may have
too many layers.

00:49:40.280 --> 00:49:42.720
But if you can, that's
something nice.

00:49:42.720 --> 00:49:44.710
With that being said, we did
improve by a lot the

00:49:44.710 --> 00:49:46.250
performances on JellyBean.

00:49:46.250 --> 00:49:50.810
But even on ICS, that was
not to super great.

00:49:50.810 --> 00:49:52.130
AUDIENCE: One more question.

00:49:52.130 --> 00:49:54.940
So it currently supports
intertranslation, rotation,

00:49:54.940 --> 00:49:56.990
and autographic transformations.

00:49:56.990 --> 00:49:59.435
Any plans to support the Specter
transformations?

00:49:59.435 --> 00:50:00.880
NICOLAS ROARD: It works.

00:50:00.880 --> 00:50:02.930
It's supported since
Honeycomb.

00:50:02.930 --> 00:50:04.510
It's supported since
Honeycomb.

00:50:04.510 --> 00:50:06.130
AUDIENCE: OK, thank you.

00:50:10.290 --> 00:50:11.420
AUDIENCE: Thank you for
your presentation.

00:50:11.420 --> 00:50:14.490
And thanks for sharing
this information.

00:50:14.490 --> 00:50:19.100
My question is, is it possible
to proxy any

00:50:19.100 --> 00:50:20.570
web traffic via WebView?

00:50:24.250 --> 00:50:26.500
NICOLAS ROARD: That's
a good question.

00:50:26.500 --> 00:50:27.270
I'm not sure.

00:50:27.270 --> 00:50:30.010
I think there is a few things
that you can do through

00:50:30.010 --> 00:50:31.100
WebChromeClient.

00:50:31.100 --> 00:50:33.670
But I'm not entirely sure that
they are things that we expose

00:50:33.670 --> 00:50:34.920
with public APIs.

00:50:46.880 --> 00:50:49.342
OK, so yeah?

00:50:49.342 --> 00:50:50.592
AUDIENCE: [INAUDIBLE].

00:50:54.560 --> 00:50:56.240
NICOLAS ROARD: OK, so the
question was, what [INAUDIBLE]

00:50:56.240 --> 00:50:58.310
to port for DR unprotected
videos?

00:50:58.310 --> 00:51:00.850
And that depends on the support
for your unprotected

00:51:00.850 --> 00:51:03.620
videos in the HTML5 standard.

00:51:03.620 --> 00:51:09.710
So when we will have something
that works with HTML5 video,

00:51:09.710 --> 00:51:11.250
then you will have an
implementation.

00:51:11.250 --> 00:51:14.210
That's more for WebKit
question than

00:51:14.210 --> 00:51:16.564
something for us directly.

00:51:16.564 --> 00:51:19.340
AUDIENCE: [INAUDIBLE].

00:51:19.340 --> 00:51:21.800
NICOLAS ROARD: Yes.

00:51:21.800 --> 00:51:24.084
But you know, things are
not built in one day.

00:51:30.870 --> 00:51:31.630
AUDIENCE: One last question.

00:51:31.630 --> 00:51:34.800
Someone asked me this yesterday
in office hours.

00:51:34.800 --> 00:51:39.820
If you have a view, like on a
tablet, with multiple webviews

00:51:39.820 --> 00:51:42.960
on the view, is there a way that
each webview can have its

00:51:42.960 --> 00:51:44.280
own session?

00:51:44.280 --> 00:51:47.702
Because the cookie manager
currently is a singleton.

00:51:47.702 --> 00:51:48.940
NICOLAS ROARD: No.

00:51:48.940 --> 00:51:50.040
AUDIENCE: OK.

00:51:50.040 --> 00:51:51.290
Thank you.

00:51:54.010 --> 00:51:54.150
NICOLAS ROARD: OK.

00:51:54.150 --> 00:51:55.490
Well, thank you, everyone.

00:51:55.490 --> 00:51:57.960
And if you have other questions,
you can probably

00:51:57.960 --> 00:52:00.660
find me after the talk.

00:52:00.660 --> 00:52:02.955
[APPLAUSE]

