WEBVTT
Kind: captions
Language: en

00:00:06.339 --> 00:00:11.170
&gt;&gt;Debajit Ghosh: Hi. I am Debajit Ghosh. I
lead the Android Sync Team at Google, and

00:00:11.170 --> 00:00:15.279
I am delighted to talk to you about how you
can build push applications for the Android

00:00:15.279 --> 00:00:21.179
platform.
You can view live notes and ask questions

00:00:21.179 --> 00:00:30.900
on the Wave at the following URL.
During this talk, we are going to cover how

00:00:30.900 --> 00:00:38.309
many Android applications access data in the
cloud. One of the fundamental challenges for

00:00:38.309 --> 00:00:43.690
those applications is how do you keep data
on the device fresh? How do you keep the data

00:00:43.690 --> 00:00:47.910
up-to-date?
There are two basic techniques, polling and

00:00:47.910 --> 00:00:50.600
pushing.
I am going to talk about each, and we are

00:00:50.600 --> 00:00:57.090
going to see, ultimately, you typically don't
want to use polling in your applications.

00:00:57.090 --> 00:01:01.969
You want to use push.
We're then going to go through the APIs for

00:01:01.969 --> 00:01:06.550
the new Android cloud-to-device messaging
framework that we have announced here at Google

00:01:06.550 --> 00:01:11.270
I/O and we're going to see how easy it is
to build push applications on Android.

00:01:11.270 --> 00:01:17.090
We are going to go through the APIs in detail,
go through design considerations, and then

00:01:17.090 --> 00:01:24.169
we are going to wrap up with a demo.
Anybody here have an Android phone?

00:01:24.169 --> 00:01:26.700
[ Laughter ]
&gt;&gt;Debajit Ghosh: Okay. Maybe that's not a

00:01:26.700 --> 00:01:29.369
fair question. Anybody here have two Android
phones?

00:01:29.369 --> 00:01:31.170
Oh, wait.
[ Laughter ]

00:01:31.170 --> 00:01:39.360
&gt;&gt;Debajit Ghosh: These are tremendous devices.
They have got incredible browsers, and they

00:01:39.360 --> 00:01:46.369
can run really powerful, very compelling applications.
So the most interesting applications are those

00:01:46.369 --> 00:01:52.909
that access data in the cloud, giving you
seamless access to your data wherever you

00:01:52.909 --> 00:01:56.919
are.
You can have applications like mobile alerts.

00:01:56.919 --> 00:02:01.829
Your favorite hockey team just scored a goal
in overtime and is moving on to the next round

00:02:01.829 --> 00:02:08.360
of the playoffs, and you want to know the
second that happened. You can have send-to-phone

00:02:08.360 --> 00:02:13.870
applications. You are looking at a map, you
are looking at driving directions, you are

00:02:13.870 --> 00:02:18.041
looking at driving directions on the desktop.
You don't want to be looking at driving directions

00:02:18.041 --> 00:02:22.319
on the desktop. You want to the driving directions
on the phone where you can use navigation

00:02:22.319 --> 00:02:27.230
to get to where you want to go.
With a simple click of the button, you can

00:02:27.230 --> 00:02:33.209
send a map, send a Web page to your phone
easily.

00:02:33.209 --> 00:02:38.540
There are background sync applications. You
want to make use -- you want to access your

00:02:38.540 --> 00:02:43.560
data, you want to make use of your data wherever
you are, whether you are online or off-line.

00:02:43.560 --> 00:02:49.959
You want that data to sync to your device
transparently. And when you make changes to

00:02:49.959 --> 00:02:54.019
your data in the cloud, when you make changes
on the Web, you want to make sure that the

00:02:54.019 --> 00:02:59.950
latest data is reflected on your device as
quickly as possible.

00:02:59.950 --> 00:03:04.780
Across all of these types of applications
there is one fundamental challenge: How do

00:03:04.780 --> 00:03:10.760
you keep data on your device fresh? How do
you keep your data up-to-date?

00:03:10.760 --> 00:03:16.680
There are two basic techniques, polling and
pushing.

00:03:16.680 --> 00:03:24.040
Polling is a fairly simple to implement technique.
In polling, your application periodically

00:03:24.040 --> 00:03:29.510
asks your server, hey, has anything changed?
Is there any new data for me?

00:03:29.510 --> 00:03:34.640
It's pretty simple to implement.
But a lot of times the data in the cloud isn't

00:03:34.640 --> 00:03:40.769
changing that frequently. So polling can take
a bit of a toll on a battery. This is because

00:03:40.769 --> 00:03:45.459
whenever you are accessing data, whenever
you are using the data network, you are powering

00:03:45.459 --> 00:03:50.760
up the radio. When you use the radio, you
are consuming power. Even when you are done

00:03:50.760 --> 00:03:54.639
accessing data, the radio stays on for a couple
of seconds.

00:03:54.639 --> 00:03:59.279
So this can take a little bit of a toll on
a battery.

00:03:59.279 --> 00:04:03.832
Polling is, however, completely appropriate
for some types of content. If you have content

00:04:03.832 --> 00:04:09.749
that's actually changing constantly, like
stock quotes, news headlines, and your application

00:04:09.749 --> 00:04:16.519
is tolerant of showing slightly stale data,
you can poll very infrequently, and then when

00:04:16.519 --> 00:04:21.739
the user is actually starting to view that
data, is trying to access that data, your

00:04:21.739 --> 00:04:28.710
application can refresh the data immediately.
Let's take a look at the impact on a battery

00:04:28.710 --> 00:04:32.560
when you poll.
This is one of the routine measurements that

00:04:32.560 --> 00:04:38.000
we take on the Android team. It shows a typical
poll.

00:04:38.000 --> 00:04:41.889
In the baseline, when a device is idle, it
might even have an open TCP connection with

00:04:41.889 --> 00:04:47.130
the server, but there's no data being transmitted
or receive. The baseline power draw is about

00:04:47.130 --> 00:04:54.370
five to ten milliamps. But when you start
accessing data, if you are reading data, that

00:04:54.370 --> 00:04:59.340
power usage can jump up to 115 milliamps.
If you are writing data, transmitting data

00:04:59.340 --> 00:05:06.639
can be more expensive than reading, that power
usage jumps up to 180, 200 or more milliamps.

00:05:06.639 --> 00:05:15.000
So for a short poll here, you might have consumed
2.5 milliamp hours and that can add up.

00:05:15.000 --> 00:05:22.849
If your application is polling every five
minutes, then that adds up to 144 milliamp

00:05:22.849 --> 00:05:29.199
hours. That's quite a bit of a battery. A
battery typically gives you 1200 to 1400 milliamp

00:05:29.199 --> 00:05:35.199
hours, so that's over 10% of a battery from
one application that's polling every five

00:05:35.199 --> 00:05:38.710
minutes.
If you scale back your polling to every 15

00:05:38.710 --> 00:05:42.729
minutes, you do a little bit better. You consume
about 48 milliamp hours.

00:05:42.729 --> 00:05:51.940
What does this mean? How does this affect
our design? When do we want to poll?

00:05:51.940 --> 00:05:56.319
Like everything else in engineering, there
is a tradeoff and here there is a tradeoff

00:05:56.319 --> 00:06:01.720
between freshness and efficiency.
If you poll very frequently, you will have

00:06:01.720 --> 00:06:05.960
very fresh data, for your application is not
going to be as efficient.

00:06:05.960 --> 00:06:11.301
Poll less frequently and your data is not
going to be as fresh, but you will be a little

00:06:11.301 --> 00:06:16.819
bit better on the battery.
So let's take a step back. What is it that

00:06:16.819 --> 00:06:22.590
we ultimately want here?
When do we want to poll?

00:06:22.590 --> 00:06:31.270
Well, typically, ultimately we don't want
to poll. We want to push.

00:06:31.270 --> 00:06:36.780
Push-based systems provide both freshness
and efficiency, and they do that by only making

00:06:36.780 --> 00:06:43.310
use of data when it's useful.
In a push system, an application or a service

00:06:43.310 --> 00:06:48.360
will establish and maintain a connection,
a persistent connection, with a server in

00:06:48.360 --> 00:06:55.099
the cloud. And that allows that server in
the cloud to send data to the application

00:06:55.099 --> 00:07:03.270
when something has actually changed.
If you use an Android device, chances are

00:07:03.270 --> 00:07:08.710
you are already making use of push functionality.
The Google contacts, calendar, and of course

00:07:08.710 --> 00:07:15.330
Gmail sync functionality that ships on many
Android devices makes use of push. Google

00:07:15.330 --> 00:07:21.509
Voice makes use of push. And Android Market
makes use of push, like Vic showed in his

00:07:21.509 --> 00:07:29.949
demo this morning.
Anybody can implement a push-based system

00:07:29.949 --> 00:07:37.949
on the Android platform. The Android APIs,
the SDK allow anyone to run a background service

00:07:37.949 --> 00:07:43.190
to establish or maintain a connection.
Have any of you tried to build a push-based

00:07:43.190 --> 00:07:49.629
system on Android? A couple of you.
If you have tried, no doubt you have noticed

00:07:49.629 --> 00:07:54.280
that there's a couple of details to work through.
There are some things that you have to make

00:07:54.280 --> 00:07:58.710
sure you do to make that push-based system
work well, to work efficiently.

00:07:58.710 --> 00:08:05.039
So it can be somewhat tricky to implement.
Well, I'm delighted to share with you all

00:08:05.039 --> 00:08:09.729
of the time and energy, all of the work that
we have put into making push work for Google

00:08:09.729 --> 00:08:18.080
applications and opening it up to all of you
as Android cloud-to-device messaging.

00:08:18.080 --> 00:08:23.840
Android cloud to device messaging is a new
Google API that we are launching in labs.

00:08:23.840 --> 00:08:29.612
It's initially going to be available as a
small trial to developers and then we are

00:08:29.612 --> 00:08:33.510
going to open it up to all developers later
this year.

00:08:33.510 --> 00:08:38.450
Android cloud-to-device messaging requires
Android 2.2 to be on the device as well as

00:08:38.450 --> 00:08:44.390
Android Market. Android Market is required
simply for a technical requirement to make

00:08:44.390 --> 00:08:48.710
sure the underlying cloud-to-device messaging
functionality is there and present on the

00:08:48.710 --> 00:08:51.780
device.
Of course, you have a choice. You have the

00:08:51.780 --> 00:08:59.470
freedom to deploy your application however
you want, on Market or on your own Web site.

00:08:59.470 --> 00:09:03.390
Android cloud-to-device messaging makes use
of the existing persistent connection that's

00:09:03.390 --> 00:09:09.320
already used to power push in Google applications.
So that persistent connection is well amortized

00:09:09.320 --> 00:09:15.690
across a number of applications.
With Android cloud-to-device messaging, your

00:09:15.690 --> 00:09:21.160
servers can send lightweight data messages
to your applications on devices, and this

00:09:21.160 --> 00:09:27.890
is typically used to tell your application
when something has changed. This is how you

00:09:27.890 --> 00:09:33.700
can tell your application, hey, now is a good
time to sync.

00:09:33.700 --> 00:09:38.150
When an Android cloud to device message is
received on the device, it is concerted into

00:09:38.150 --> 00:09:43.580
an intent, which is well integrated with the
REST of the Android platform. That intent

00:09:43.580 --> 00:09:49.210
is broadcast, it's actually broadcast specifically
to your application through the use of permissions,

00:09:49.210 --> 00:09:54.680
and then that allows your application to do
whatever it wants.

00:09:54.680 --> 00:10:01.270
With Android cloud to device messaging, if
you want some UI component, your application

00:10:01.270 --> 00:10:05.950
supplies it. You can do whatever you want.
If you want a notification, you can use the

00:10:05.950 --> 00:10:09.590
Android notification framework to put one
up.

00:10:09.590 --> 00:10:13.980
But if you are working on a background sync
application, you might not need any UI. All

00:10:13.980 --> 00:10:19.640
you are trying to do is make sure that data
syncs transparently in the background.

00:10:19.640 --> 00:10:24.400
If you do want to have a UI, if you want to
put up a notification, for example, typically

00:10:24.400 --> 00:10:30.460
what you do is you go ahead and fetch the
new data first, then put up the notification.

00:10:30.460 --> 00:10:38.640
So that way when the user selects the notification,
they can immediately access the new data.

00:10:38.640 --> 00:10:43.690
Android cloud to device messaging is a best-effort
service. We try really, really hard to make

00:10:43.690 --> 00:10:49.850
sure that each and every message gets through.
We store messages reliably for delivery to

00:10:49.850 --> 00:10:56.090
devices that might be having network problems,
might be temporarily off-line.

00:10:56.090 --> 00:11:00.700
But every once in a while a message could
get lost, be delivered out of order, and it's

00:11:00.700 --> 00:11:04.700
just something that you need to keep in mind
when you design your application to make sure

00:11:04.700 --> 00:11:09.340
you are robust to that.
If you are like me, you like to know how things

00:11:09.340 --> 00:11:14.430
work. So let's go ahead and take a peek under
the hood of how we built Android cloud to

00:11:14.430 --> 00:11:21.540
device messaging.
First, we built out a set of servers to manage

00:11:21.540 --> 00:11:26.140
those persistent connections from all the
Android devices. And we have scaled those

00:11:26.140 --> 00:11:31.700
servers so they can handle connections from
each and every Android device.

00:11:31.700 --> 00:11:37.540
On the device, we have a background service
that establishes and maintenance that connection.

00:11:37.540 --> 00:11:45.610
Of course, we honor the background data setting
and don't do this work if the user has deselected

00:11:45.610 --> 00:11:51.360
background data, indicating that they don't
want any data to be consumed in the background.

00:11:51.360 --> 00:11:55.660
This service starts when the network first
comes up.

00:11:55.660 --> 00:12:00.040
Once we first go ahead and establish that
connection, we work really, really hard to

00:12:00.040 --> 00:12:06.420
make sure that that connection stays alive.
We make use of application-level heartbeats

00:12:06.420 --> 00:12:11.120
to keep that connection alive. This is because
on a wide-area network, there's a couple of

00:12:11.120 --> 00:12:14.460
challenges.
First, there are a lot of components on a

00:12:14.460 --> 00:12:21.240
wide-area network, like NATs and IP load balancers
that try and find, detect idle connections

00:12:21.240 --> 00:12:25.360
and kill those connections.
In addition, there's actually an interesting

00:12:25.360 --> 00:12:31.320
phenomena known as half-open connections that
we have encountered on various networks. And

00:12:31.320 --> 00:12:36.800
with the half-open connection, an application
might be able to send data in one direction,

00:12:36.800 --> 00:12:42.550
but it can't receive data in the other direction.
So we use our heartbeating protocol to detect

00:12:42.550 --> 00:12:50.760
when that happens and reconnect.
We also do everything we can to make this

00:12:50.760 --> 00:12:56.560
connection as efficient as possible. This
connection is SSL encrypted, and we have built

00:12:56.560 --> 00:13:03.800
a distributed, scalable SSL session resumption
system, so that way each time a device reconnects,

00:13:03.800 --> 00:13:12.560
it doesn't have to redownload a 2 to 3K SSL
certificate.

00:13:12.560 --> 00:13:17.141
Whenever you have an open TCP connection,
if there is no data being transmitted or received,

00:13:17.141 --> 00:13:22.390
there is very little overhead, very little
power consumption, as we saw. However, whenever

00:13:22.390 --> 00:13:28.010
you start accessing the radio, including for
heartbeats, that draws power.

00:13:28.010 --> 00:13:33.450
So we have worked really hard to minimize
our heartbeat frequency. We have actually

00:13:33.450 --> 00:13:38.650
tuned this for a lot of different networks
to minimize that heartbeat frequency, making

00:13:38.650 --> 00:13:42.960
sure that the connection stays alive, but
otherwise try to make sure that it's spaced

00:13:42.960 --> 00:13:49.240
out as much as possible.
And we also minimize the number of concurrent

00:13:49.240 --> 00:13:54.500
connections that we establish and maintain
on a device. For Android cloud to device messaging,

00:13:54.500 --> 00:14:01.260
each Android device just uses one persistent
connection.

00:14:01.260 --> 00:14:06.450
Let's take a closer look at heartbeats.
With heartbeats, when one side hasn't heard

00:14:06.450 --> 00:14:12.850
anything from the other side for some period
of time, it will go ahead and send a ping.

00:14:12.850 --> 00:14:17.940
The other side, upon receiving the ping, will
send back an ack, and when the originating

00:14:17.940 --> 00:14:22.900
side receives that ack, it knows everything
is cool. Connection is alive.

00:14:22.900 --> 00:14:29.020
If, however, one side sends a ping and doesn't
get back an ack, it knows that the connection

00:14:29.020 --> 00:14:35.890
is dead and it needs to reconnect.
To implement heartbeats, we use the Android

00:14:35.890 --> 00:14:41.890
alarm framework. We use this to schedule the
initial heartbeat, and then whenever we receive

00:14:41.890 --> 00:14:46.720
any kind of data over that connection, we
know the connection is alive, and we cancel

00:14:46.720 --> 00:14:54.510
that pending heartbeat and reschedule it.
When we actually do go ahead and issue a ping,

00:14:54.510 --> 00:14:59.160
we schedule an alarm to wait for the ack to
come back in a timely fashion. If it doesn't

00:14:59.160 --> 00:15:01.940
come back, we know the connection is dead
and we reconnect.

00:15:01.940 --> 00:15:05.890
And we actually have this same protocol on
the server side.

00:15:05.890 --> 00:15:10.580
The server side can also initiate heartbeats.
On the server side, since the servers can't

00:15:10.580 --> 00:15:14.680
reconnect to the devices, the devices are
typically behind a NAT or something like that,

00:15:14.680 --> 00:15:27.620
we mainly use this to detect a dead connection
and clean up some state.

00:15:27.620 --> 00:15:33.520
Let's go ahead and take a look at the overall
life cycle for Android cloud-to-device messaging.

00:15:33.520 --> 00:15:40.230
There are three basic phases, first, up-front,
a device, an application on device, we'll

00:15:40.230 --> 00:15:44.160
go ahead and enable Android cloud-to-device
messaging.

00:15:44.160 --> 00:15:50.520
It does this with a registration API, and
with this registration API, each application

00:15:50.520 --> 00:15:56.790
on a device gets a unique RegistrationID.
When this application gets its RegistrationID,

00:15:56.790 --> 00:16:00.330
it sends that to its server.
That way, the server can use that for sending

00:16:00.330 --> 00:16:05.180
messages.
In the run-time portion, per-message, when

00:16:05.180 --> 00:16:12.820
an application server wants to send a message,
it issues a very simple HTTP post to some

00:16:12.820 --> 00:16:17.860
servers at Google.
When the Google servers receive that HTTP

00:16:17.860 --> 00:16:23.290
post, they store the message and queue it
for delivery, for reliable delivery, to the

00:16:23.290 --> 00:16:30.940
device, and things are good to go.
Then, if an application wants to disable push,

00:16:30.940 --> 00:16:35.780
if it wants to disable cloud-to-device messaging,
it can use a simple unregister API.

00:16:35.780 --> 00:16:40.370
And you might do this if, for example, you
have a background sync application and the

00:16:40.370 --> 00:16:47.300
user unselects the auto sync check box.
Let's take a closer look at that run-time

00:16:47.300 --> 00:16:50.890
portion.
Let's look at the life of a message.

00:16:50.890 --> 00:16:59.100
Here, Android device already established a
connection with our connection servers.

00:16:59.100 --> 00:17:05.199
An application server will go ahead and send
that simple HTTP post to our cloud-to-device

00:17:05.199 --> 00:17:12.000
messaging frontends.
We receive that request, store the message,

00:17:12.000 --> 00:17:15.850
route the request to the appropriate connection
server that's housing a connection from the

00:17:15.850 --> 00:17:20.959
target device, which will go ahead and send
the message to the device.

00:17:20.959 --> 00:17:26.519
At this point, two things will happen, basically,
in parallel.

00:17:26.519 --> 00:17:32.880
First, that -- that message will be converted
into an intent, which is broadcast to wake

00:17:32.880 --> 00:17:39.049
up or start up an application.
In addition, the device will acknowledge receipt

00:17:39.049 --> 00:17:42.490
of that message so we can clear that from
our store.

00:17:42.490 --> 00:17:46.919
The application wakes up, and then it can
go ahead and fetch its latest data from its

00:17:46.919 --> 00:17:53.529
application server.
Overall, the design here is to make sure that

00:17:53.529 --> 00:18:01.620
the state, the relevant state typically remains
in the application server, not in the message.

00:18:01.620 --> 00:18:07.740
Let's take a look at some code.
To register, your application makes use of

00:18:07.740 --> 00:18:13.480
a very simple intent-based API.
You create an intent and populate it with

00:18:13.480 --> 00:18:19.740
a little bit of data.
You populate with information about your application,

00:18:19.740 --> 00:18:25.640
and you also provide it a role account that
your application server is going to use when

00:18:25.640 --> 00:18:29.610
it sends messages.
This role account has nothing to do with any

00:18:29.610 --> 00:18:34.150
of the accounts on the Android device.
Again, this is a role account that your application

00:18:34.150 --> 00:18:39.470
server is going to use when it sends messages.
And you go ahead and call start service.

00:18:39.470 --> 00:18:46.009
And then sometime later, your application
will receive an intent back with the RegistrationID.

00:18:46.009 --> 00:18:51.289
When you receive that RegistrationID, go ahead
and send that to your application servers.

00:18:51.289 --> 00:18:55.970
The Android cloud-to-device messaging framework
might reissue or rotate these registration

00:18:55.970 --> 00:18:59.540
IDs from time to time.
So your intent receiver that's receiving these

00:18:59.540 --> 00:19:02.330
registration intents might be called again
in the future.

00:19:02.330 --> 00:19:07.429
And if that happens, all you do is do the
same thing that you did in the first place.

00:19:07.429 --> 00:19:17.250
Take that RegistrationID and send it to your
server.

00:19:17.250 --> 00:19:23.190
Here's some code that shows you what -- how
you can go ahead and process that registration

00:19:23.190 --> 00:19:26.659
intent.
You have an intent receiver on receive.

00:19:26.659 --> 00:19:31.200
Check for that registration intent, and then
go ahead and see whether or not you got a

00:19:31.200 --> 00:19:33.960
RegistrationID.
If you did, cool.

00:19:33.960 --> 00:19:38.019
Send it to your server.
If you get back an error, then you should

00:19:38.019 --> 00:19:46.120
retry with some backoff.
To send messages, your application servers

00:19:46.120 --> 00:19:54.870
send a very simple HTTP post.
This request is authenticated using the ac2dm

00:19:54.870 --> 00:19:59.100
authentication token, which you typically
grab once up-front, using the client login

00:19:59.100 --> 00:20:04.649
API, and install into your servers.
You include this authentication token in the

00:20:04.649 --> 00:20:08.559
authorization header.
And then you also include a couple of URL

00:20:08.559 --> 00:20:11.980
encoded parameters.
You include the RegistrationID for the target

00:20:11.980 --> 00:20:17.639
application and device.
You include a collapse key, which controls

00:20:17.639 --> 00:20:22.310
how messages are delivered when a device is
offline.

00:20:22.310 --> 00:20:30.419
And you can also specify an optional delay
while idle parameter, as well as some small

00:20:30.419 --> 00:20:33.929
amount of payload in the form of arbitrary
key value pairs.

00:20:33.929 --> 00:20:39.679
We're going to talk about each of these parameters
in turn.

00:20:39.679 --> 00:20:45.610
When you issue that HTTP post, you'll typically
get one of three response codes back, a 200,

00:20:45.610 --> 00:20:50.169
a 401, or a 303.
If you get back a 401, that means that your

00:20:50.169 --> 00:20:54.710
authentication token is no longer valid.
So you need to grab a new one.

00:20:54.710 --> 00:20:58.321
And this could happen if, for example, you
change the password for your role account.

00:20:58.321 --> 00:21:04.850
If you get back a 503, then you should retry
your request with backoff.

00:21:04.850 --> 00:21:09.509
And please honor any retry after headers that
you receive.

00:21:09.509 --> 00:21:14.700
If you get back a 200, that means that your
request was syntactically valid, and if you

00:21:14.700 --> 00:21:20.350
get an ID in the response, everything's cool.
We got the message and are going to route

00:21:20.350 --> 00:21:24.519
it to a device.
If, however, you get back an error, one of

00:21:24.519 --> 00:21:31.679
several things could have happened.
If we start detecting an unusual or excessive

00:21:31.679 --> 00:21:40.629
amount of messaging from a sender in aggregate
across devices or from a sender to a specific

00:21:40.629 --> 00:21:46.409
device, then you'll hit some quota limits.
And when you do that, you need to back off

00:21:46.409 --> 00:21:52.929
and try again later.
If the RegistrationID that you supplied was

00:21:52.929 --> 00:22:01.760
invalid or if the application requested unregistration,
then we'll tell you that, and you need to

00:22:01.760 --> 00:22:06.580
wait until you get a new RegistrationID from
the application before you try sending messages

00:22:06.580 --> 00:22:16.039
to that target device again.
If the message you sent was too big, the payload

00:22:16.039 --> 00:22:22.630
is limited to being about 1K.
Or if you didn't supply a collapse key, you

00:22:22.630 --> 00:22:29.659
need to fix these issues before you try again.
When a message is received on the device,

00:22:29.659 --> 00:22:33.980
it's converted into an intent.
That intent is broadcast.

00:22:33.980 --> 00:22:39.789
And through the use of permissions that your
application defines and requests, that intent

00:22:39.789 --> 00:22:45.929
is sent only to your application.
When that intent is broadcast, your application

00:22:45.929 --> 00:22:48.970
is woken up or it's started.
So that means that your application doesn't

00:22:48.970 --> 00:22:53.029
need to be sitting there running in the background.
You don't need to have some service running

00:22:53.029 --> 00:22:57.929
continually.
Your application will wake up.

00:22:57.929 --> 00:23:05.860
Any payload that you provided will be converted
into the extras in the intent, and you can

00:23:05.860 --> 00:23:09.860
do whatever you need to do.
If you're going to be doing anything nontrivial,

00:23:09.860 --> 00:23:12.820
typically, you'll grab a WakeLock.
Don't forget to release the WakeLock when

00:23:12.820 --> 00:23:16.140
you're done.
And you'll do whatever processing you need

00:23:16.140 --> 00:23:19.980
to do in a service.
And you can use the intent service API to

00:23:19.980 --> 00:23:25.710
simplify your work here.
And that's it.

00:23:25.710 --> 00:23:34.809
That's all there is to the API.
First, you call registration to get your RegistrationID.

00:23:34.809 --> 00:23:41.779
Next, in the run-time portion, you issue a
simple HTTP post to send messages.

00:23:41.779 --> 00:23:48.730
And then, if your application chooses to not
make use of push anymore, for example, if

00:23:48.730 --> 00:23:53.559
the user deselects auto sync, you can unregister.
It's a pretty simple API.

00:23:53.559 --> 00:23:59.139
We found that most developers who were trying
out the API can get something up and running

00:23:59.139 --> 00:24:10.749
in a matter of hours.
We're now going to talk about some of the

00:24:10.749 --> 00:24:15.249
options and design considerations you need
to keep in mind when you're making use of

00:24:15.249 --> 00:24:19.960
Android cloud-to-device messaging.
The first concept we're going to talk about

00:24:19.960 --> 00:24:26.080
is that of message collapse.
When a device is offline for any period of

00:24:26.080 --> 00:24:32.889
time, we want to avoid message delivery explosion
when that device comes online again.

00:24:32.889 --> 00:24:39.029
A lot of times, say, in a mail application,
one "you have new mail" message is as good

00:24:39.029 --> 00:24:43.799
as any of the other ones.
So if you're on a flight, when you come off

00:24:43.799 --> 00:24:47.639
the flight, you don't need to receive tens
or hundreds of those messages.

00:24:47.639 --> 00:24:52.600
You just need one.
And so when you send a message, you can supply

00:24:52.600 --> 00:24:57.399
a collapse key.
And that collapse key controls how those messages

00:24:57.399 --> 00:25:03.480
are stored and delivered.
Typically, you specify a collapse key to correspond

00:25:03.480 --> 00:25:09.249
with some topic or some feed, whatever, that
is meaningful to your application, perhaps

00:25:09.249 --> 00:25:12.940
a URL that your application's going to hit
to get its data.

00:25:12.940 --> 00:25:19.019
And when a message is sent to our servers
with a collapse key, if there are any outstanding

00:25:19.019 --> 00:25:23.730
undelivered messages already stored under
that collapse key, the new one will overwrite

00:25:23.730 --> 00:25:30.409
the previous ones.
This really emphasizes the design principle

00:25:30.409 --> 00:25:34.529
of keeping your state in your server, not
in the messages.

00:25:34.529 --> 00:25:42.400
And we find that this allows for very clean
design and allows you to decouple your messaging

00:25:42.400 --> 00:25:46.049
channel from, for instance, your synchronization
channel.

00:25:46.049 --> 00:25:52.309
That way, the same code that you use for,
say, a manual refresh can make use of the

00:25:52.309 --> 00:25:57.789
synchronization channel as is, and all you're
doing when you receive a cloud-to-device message

00:25:57.789 --> 00:26:03.330
is kick off that -- that code.
Let's take a look at how this works.

00:26:03.330 --> 00:26:06.399
Here, we have a device that happens to be
offline.

00:26:06.399 --> 00:26:12.480
It's on the proverbial airplane.
Your application server, as usual, sends a

00:26:12.480 --> 00:26:17.580
cloud-to-device message to our frontends.
We receive it, store it.

00:26:17.580 --> 00:26:26.059
But then we don't route it to any connection
servers because the device is not connected.

00:26:26.059 --> 00:26:30.691
The application server sends a subsequent
message under the same collapse key.

00:26:30.691 --> 00:26:39.789
We'll receive that message, and that new message
will overwrite the previous message.

00:26:39.789 --> 00:26:44.019
You can specify whatever collapse key you
want on a message-by-message basis.

00:26:44.019 --> 00:26:49.470
But there's a limitation.
Each application can have, at most, four messages

00:26:49.470 --> 00:26:56.889
or four unique collapse keys outstanding at
any given time.

00:26:56.889 --> 00:27:02.409
The next concept we're going to talk about
is attenuation.

00:27:02.409 --> 00:27:08.009
We want to make sure that data on a device
is fresh, but we also want to protect a user's

00:27:08.009 --> 00:27:10.440
battery.
We want to protect the radio.

00:27:10.440 --> 00:27:15.789
Whenever a cloud-to-device message is received
on a device, that fires up the radio.

00:27:15.789 --> 00:27:19.950
And we want to make sure that the radio isn't
constantly firing up.

00:27:19.950 --> 00:27:26.830
So if we detect that a specific application
is sending a high frequency of cloud-to-device

00:27:26.830 --> 00:27:30.340
messages, we'll let the first few of those
through quickly.

00:27:30.340 --> 00:27:36.039
We want to make sure that things are fresh.
But then we're going to start holding on to

00:27:36.039 --> 00:27:41.519
those messages for a short period of time
to make sure that the radio is not firing

00:27:41.519 --> 00:27:47.169
constantly.
Attenuation is done on an application on a

00:27:47.169 --> 00:27:52.509
collapse key basis.
Let's take a look.

00:27:52.509 --> 00:27:56.980
Here we have Android device, and it's connected
to our connection servers.

00:27:56.980 --> 00:28:02.320
And the application server has already been
sending a bunch of messages recently.

00:28:02.320 --> 00:28:06.169
It'll send a new message to our cloud-to-device
messaging frontends.

00:28:06.169 --> 00:28:13.049
We'll receive the message, store it, and send
it to the connection server.

00:28:13.049 --> 00:28:17.809
At that point, we'll hold onto the message
for a short period of time.

00:28:17.809 --> 00:28:27.600
And then we'll send it to the device.
Attenuation is a way that we automatically

00:28:27.600 --> 00:28:33.299
try and protect battery and delay message
delivery.

00:28:33.299 --> 00:28:38.940
There's also a technique that you can opt
into to be even more aggressive about delaying

00:28:38.940 --> 00:28:44.090
messages, and that's by making use of the
delay while idle feature.

00:28:44.090 --> 00:28:49.049
Each Android device tells our servers when
their screen is on or off.

00:28:49.049 --> 00:28:54.970
It does this efficiently.
And by knowing when a screen is off, we know

00:28:54.970 --> 00:29:03.350
that the device isn't actively being used.
And there are certain classes of content where

00:29:03.350 --> 00:29:08.510
data changes very frequently but might not
be of much interest if the device isn't being

00:29:08.510 --> 00:29:11.590
used.
For example, in a chat application, you might

00:29:11.590 --> 00:29:17.289
not care about the latest presence updates,
which can change very frequently, when the

00:29:17.289 --> 00:29:21.520
device is in your pocket.
You might not care about your friends' latest

00:29:21.520 --> 00:29:28.210
location information, again, when the device
is on a table or in your desk.

00:29:28.210 --> 00:29:33.879
And so on a message-by-message basis, your
application servers can specify the delay

00:29:33.879 --> 00:29:38.139
while idle parameter.
And when that's specified, our connection

00:29:38.139 --> 00:29:44.749
servers will hold on to one of these messages
while the screen is off for the target device,

00:29:44.749 --> 00:29:50.860
and then it will deliver that message immediately,
as soon as the device becomes active again.

00:29:50.860 --> 00:29:55.850
Let's take a look.
Here we have Android device.

00:29:55.850 --> 00:29:58.649
It's connected to our connection servers,
but the screen is off.

00:29:58.649 --> 00:30:03.869
It's asleep.
The application server goes ahead and sends

00:30:03.869 --> 00:30:11.830
a message to our front-ends, which, as usual,
we store, route to the connection server,

00:30:11.830 --> 00:30:14.580
but at this point, the connection server is
going to hold on to the message.

00:30:14.580 --> 00:30:21.149
It's going to hold on to the message until
the device actually becomes active again.

00:30:21.149 --> 00:30:27.649
When the user starts using the device, turns
 -- turns the screen on, we'll then immediately

00:30:27.649 --> 00:30:37.529
send the message to the device.
Now that we've taken a look at the APIs and

00:30:37.529 --> 00:30:43.779
all of the design considerations, let's see
what we can do when we put all of this together

00:30:43.779 --> 00:30:48.520
and build some real applications.
The first application we're going to talk

00:30:48.520 --> 00:30:52.700
about is the Google Chrome-to-phone extension
that Vic demoed this morning.

00:30:52.700 --> 00:30:57.019
This is going to be one of the sample applications
for Android cloud-to-device messaging.

00:30:57.019 --> 00:31:07.019
In fact, you can already see all of the code
on code.google.com/P/ Chrometophone.

00:31:07.019 --> 00:31:11.840
The really great thing about this, in addition
to being a really useful application, this

00:31:11.840 --> 00:31:20.210
is one of the things that I've wanted for
a long time, the application was built by

00:31:20.210 --> 00:31:25.821
an engineer who was just kicking the tires
on our API while he was on a flight.

00:31:25.821 --> 00:31:31.830
So he built this really quickly.
And I think it really shows some of the really

00:31:31.830 --> 00:31:36.970
cool applications that you can build with
cloud-to-device messaging.

00:31:36.970 --> 00:31:42.619
If you didn't see the keynote, the Google
Chrome-to-phone extension is a simple Chrome

00:31:42.619 --> 00:31:50.039
extension that allows you to send any Web
page or a map or a YouTube video or whatever

00:31:50.039 --> 00:31:58.509
from the Web to your Android device.
It's powered by, of course, a small Android

00:31:58.509 --> 00:32:04.970
application and an also very simple App Engine
back-end.

00:32:04.970 --> 00:32:10.840
Let's take a look at how this works.
First, you go ahead and view some Web page

00:32:10.840 --> 00:32:17.519
in Chrome.
The user will then go ahead and click on the

00:32:17.519 --> 00:32:24.720
Chrome-to-phone extension, which makes a request
to the App Engine back-end.

00:32:24.720 --> 00:32:29.440
The App Engine back-end then issues a request
through the Android cloud-to-device messaging

00:32:29.440 --> 00:32:37.330
service, which will go ahead and send the
message to the target device.

00:32:37.330 --> 00:32:43.019
The user can then select a notification or
you can disable that and have automatic updates

00:32:43.019 --> 00:32:46.799
on the phone.
And then the Android device will fire up the

00:32:46.799 --> 00:32:50.840
browser, go to the origin server, and get
the latest data.

00:32:50.840 --> 00:32:57.320
If you want to look at this in more detail,
you can go ahead and look at the open source

00:32:57.320 --> 00:33:03.539
example.
The next demo we're going to take a look at

00:33:03.539 --> 00:33:08.989
is JumpNote.
JumpNote is a fully-featured, two-way push

00:33:08.989 --> 00:33:16.440
sync notes sample application.
It makes use of App Engine on the back-end

00:33:16.440 --> 00:33:23.330
and the Web UI is powered by GWT.
It's also going to be one of the open source

00:33:23.330 --> 00:33:27.399
sample applications that we ship with Android
cloud-to-device messaging.

00:33:27.399 --> 00:33:33.809
And this will show you how to make use of
the Android sync framework that we shipped

00:33:33.809 --> 00:33:40.239
in Android 2.0.
In addition, it also shows you how to use

00:33:40.239 --> 00:33:49.710
the new cloud-to-device to enable push sync
for your sync applications.

00:33:49.710 --> 00:33:57.770
When the cloud-to-device message is received
on the device, the intent receiver simply

00:33:57.770 --> 00:34:00.710
kicks off a sync, just calls the request sync
API.

00:34:00.710 --> 00:34:08.470
And that's all it needs to do, and then sync
happens as normal.

00:34:08.470 --> 00:34:18.690
Let's go ahead and take a look.
So here I have the JumpNote application.

00:34:18.690 --> 00:34:21.700
There's no data here.
And I'm going to go ahead and create a new

00:34:21.700 --> 00:34:33.550
note.
I'm going to go ahead and save the note.

00:34:33.550 --> 00:34:43.120
And now we're going to switch to the ELMO.
And on the ELMO, we can see the JumpNote application

00:34:43.120 --> 00:34:46.270
running on the device.
What's happening here?

00:34:46.270 --> 00:34:55.540
Well, when I clicked on "save," the GWT application
saved the data in the App Engine data store.

00:34:55.540 --> 00:35:01.790
It then used the App Engine task queue API
to send the HTTP post for the cloud-to-device

00:35:01.790 --> 00:35:09.640
messaging request.
Our servers got that request, stored the message,

00:35:09.640 --> 00:35:14.060
routed the message to the right connection
server, sent the message to the device, which

00:35:14.060 --> 00:35:21.790
converted to an intent, broadcast the intent.
The JumpNote application woke up, did its

00:35:21.790 --> 00:35:24.730
sync.
And all of that happened in far less time

00:35:24.730 --> 00:35:46.240
than I took to explain everything that was
going on.

00:35:46.240 --> 00:35:49.131
Anyone here interested in trying out Android
cloud-to-device messaging?

00:35:49.131 --> 00:35:53.730
&gt;&gt;&gt; Yeah!
&gt;&gt;Debajit Ghosh: Well, I'm delighted to tell

00:35:53.730 --> 00:35:59.050
you that we're launching Android cloud-to-device
messaging in Labs now, and we're accepting

00:35:59.050 --> 00:36:01.190
sign-ups.
[ Applause ]

00:36:01.190 --> 00:36:08.490
&gt;&gt;Debajit Ghosh: If you want to find out more,
if you want to read our documentation, see

00:36:08.490 --> 00:36:23.090
the open source code examples, or sign up,
go ahead and visit code.google.com/Android/c2dm.

00:36:23.090 --> 00:36:25.830
You can also Google search for that if you
didn't grab the URL.

00:36:25.830 --> 00:36:36.110
During this talk, we've seen how many Android
applications access data in the cloud.

00:36:36.110 --> 00:36:40.440
And to provide freshness for those applications,
to be both fresh and efficient, we've seen

00:36:40.440 --> 00:36:47.890
that you want to use push to keep data on
those devices fresh and up-to-date.

00:36:47.890 --> 00:36:52.740
And by using the Android cloud-to-device messaging
framework, you can do that simply.

00:36:52.740 --> 00:37:00.410
Android cloud-to-device messaging makes building
push applications simple, easy, and efficient.

00:37:00.410 --> 00:37:10.310
If you want to find out more, you can sign
up now at code.google.com/Android.C2DM.

00:37:10.310 --> 00:37:16.460
We're going to go ahead and switch over to
the moderator link to look at any questions.

00:37:16.460 --> 00:37:20.120
If you also have questions, you can go up
to the microphones and ask them at this time.

00:37:20.120 --> 00:37:24.750
Thank you.
[ Applause ]

00:37:24.750 --> 00:37:39.700
&gt;&gt;Debajit Ghosh: Are there any live questions?
Go ahead.

00:37:39.700 --> 00:37:43.840
&gt;&gt;&gt; I was wondering, what is the typical latency
that you're experiencing?

00:37:43.840 --> 00:37:46.140
&gt;&gt;Debajit Ghosh: I'm sorry.
I couldn't hear the question.

00:37:46.140 --> 00:37:51.490
&gt;&gt;&gt; What is the typical latency from the time
that a -- the server pushes the message to

00:37:51.490 --> 00:37:55.931
your server and it -- the intent shows up
on the -- on the phone?

00:37:55.931 --> 00:37:57.980
&gt;&gt;Debajit Ghosh: It's typically on the order
of seconds.

00:37:57.980 --> 00:38:02.060
It varies, obviously, depending on the network
and, you know -- both the network between

00:38:02.060 --> 00:38:05.800
your server and our servers, and the network
between our servers and the device.

00:38:05.800 --> 00:38:11.620
But it's pretty quick.
&gt;&gt;&gt; Okay.

00:38:11.620 --> 00:38:15.510
&gt;&gt;&gt; Is there an API or a mechanism to go the
other way around, from the device back to

00:38:15.510 --> 00:38:19.080
the Web to do something like a two-way chat
in the same manner?

00:38:19.080 --> 00:38:23.350
&gt;&gt;Debajit Ghosh: Typically, what applications
do is they'll just go ahead and make use of

00:38:23.350 --> 00:38:26.690
regular HTTP integration with their application
servers.

00:38:26.690 --> 00:38:31.400
&gt;&gt;&gt; Hi.
Two questions.

00:38:31.400 --> 00:38:36.430
You said that you need 2.2 Froyo in the market
for this right now.

00:38:36.430 --> 00:38:40.800
Does that mean that support for the emulators
will come in later?

00:38:40.800 --> 00:38:42.850
&gt;&gt;Debajit Ghosh: I'm sorry, can you say that
again.

00:38:42.850 --> 00:38:48.060
&gt;&gt;&gt; What about support for emulators?
Because you'll be needing 2.2 and the market?

00:38:48.060 --> 00:38:52.620
&gt;&gt;Debajit Ghosh: The 2.2 SDK will provide
support for this.

00:38:52.620 --> 00:38:54.910
So you can test out your applications on that
SDK.

00:38:54.910 --> 00:38:57.660
&gt;&gt;&gt; Okay.
And I had a second question.

00:38:57.660 --> 00:39:01.820
Does the code side also have code for the
App Engine side of the code?

00:39:01.820 --> 00:39:02.820
&gt;&gt;Debajit Ghosh: Yes, absolutely.
It's fully featured.

00:39:02.820 --> 00:39:08.320
So the Chrome-to-phone example has the Chrome
extension, the Android application, and the

00:39:08.320 --> 00:39:13.580
App Engine back-end.
The JumpNote example has the GWT and App Engine

00:39:13.580 --> 00:39:16.359
samples as well as the Android applications.
We're giving you everything.

00:39:16.359 --> 00:39:18.260
&gt;&gt;&gt; Okay.
Thanks.

00:39:18.260 --> 00:39:25.570
&gt;&gt;&gt; Yeah, you said that, like, if the phone
is idle, the server will hold the message

00:39:25.570 --> 00:39:29.680
and won't deliver it until the phone is, like,
busy.

00:39:29.680 --> 00:39:32.460
So how would you define when the phone is
idle?

00:39:32.460 --> 00:39:39.750
It is possible that the user, they run the
application, like, as a service in the background

00:39:39.750 --> 00:39:45.520
and leave it on the table, and then the screen
turn off and things like that.

00:39:45.520 --> 00:39:49.080
So how would you define, you know, like when
the phone is idle?

00:39:49.080 --> 00:39:51.780
Because that's obvious -- might be waiting
for the messages.

00:39:51.780 --> 00:39:56.640
&gt;&gt;Debajit Ghosh: The question was, I believe,
how do you determine when a phone is idle.

00:39:56.640 --> 00:39:58.940
&gt;&gt;&gt; Yes.
&gt;&gt;Debajit Ghosh: Is that the question?

00:39:58.940 --> 00:40:00.910
We do it based on whether or not the screen
is off.

00:40:00.910 --> 00:40:07.190
If the screen has been off for some period
of time, we deem that phone to be idle, inactive,

00:40:07.190 --> 00:40:10.171
because the user's not actually looking at
anything on the phone.

00:40:10.171 --> 00:40:14.650
&gt;&gt;&gt; But then again, like, the application,
it might run the service in the background

00:40:14.650 --> 00:40:17.370
and, you know, like, the service might be
waiting for the message.

00:40:17.370 --> 00:40:25.010
&gt;&gt;Debajit Ghosh: If you don't want to use
the delay while idle option, you don't have

00:40:25.010 --> 00:40:28.610
to.
That's something that you can do for types

00:40:28.610 --> 00:40:33.400
of data where you want that behavior.
Does that answer your question?

00:40:33.400 --> 00:40:37.370
&gt;&gt;&gt; Oh, can you come again, please?
&gt;&gt;Debajit Ghosh: I'm sorry, I'm having trouble

00:40:37.370 --> 00:40:41.000
hearing.
&gt;&gt;&gt; Can you explain it again for me, please.

00:40:41.000 --> 00:40:47.100
So if the service is waiting for the message
and the screen is, like, turned off, like,

00:40:47.100 --> 00:40:50.681
how can you avoid that situation?
&gt;&gt;Debajit Ghosh: So the question was, how

00:40:50.681 --> 00:40:53.030
do you avoid having your messages be delayed
 --

00:40:53.030 --> 00:40:54.370
&gt;&gt;&gt; Yes.
&gt;&gt;Debajit Ghosh: -- when the screen turns

00:40:54.370 --> 00:40:56.970
off?
If you don't want that behavior, you don't

00:40:56.970 --> 00:40:59.840
specify the delay while idle parameter.
That's an optional parameter.

00:40:59.840 --> 00:41:01.021
&gt;&gt;&gt; Oh, I see.
Thank you.

00:41:01.021 --> 00:41:07.390
&gt;&gt;&gt; Yes, hello.
Is there any ability to push a message against

00:41:07.390 --> 00:41:14.830
a certain time zone or locality?
&gt;&gt;Debajit Ghosh: Let me repeat the question.

00:41:14.830 --> 00:41:18.870
The question was, is there a way to push a
message to a certain time zone or locality?

00:41:18.870 --> 00:41:23.220
&gt;&gt;&gt; For instance, like, a country-specific
or something of that sort.

00:41:23.220 --> 00:41:26.440
&gt;&gt;Debajit Ghosh: Are you talking about localization?
&gt;&gt;&gt; Yes.

00:41:26.440 --> 00:41:30.660
&gt;&gt;Debajit Ghosh: That's something that's going
to be up to your application.

00:41:30.660 --> 00:41:35.550
So typically, again, what you're doing with
these cloud-to-device messages is sending

00:41:35.550 --> 00:41:39.910
something that, you know, tickles, wakes up
your device, wakes up your application so

00:41:39.910 --> 00:41:42.070
it can go ahead and do whatever it needs to
do.

00:41:42.070 --> 00:41:46.151
There's no UI component inherent to Android
cloud-to-device messaging.

00:41:46.151 --> 00:41:49.300
That's something that your application supplies.
Does that answer your question?

00:41:49.300 --> 00:41:52.710
&gt;&gt;&gt; Yeah, more or less.
&gt;&gt;&gt; Hi.

00:41:52.710 --> 00:41:56.670
So you mentioned that it's only available
in 2.2.

00:41:56.670 --> 00:42:01.220
And so for previous -- like, right now, I
think everybody don't have 2.2, right, and

00:42:01.220 --> 00:42:05.280
a lot of phones will not upgrade to that.
So would that be back-ported somehow?

00:42:05.280 --> 00:42:12.680
And will -- what's your recommendation on
dealing with older phones that not have that

00:42:12.680 --> 00:42:16.390
version?
&gt;&gt;Debajit Ghosh: The question was, this functionality

00:42:16.390 --> 00:42:21.670
is only available for Android 2.2.
Will this functionality be back-ported.

00:42:21.670 --> 00:42:24.490
The answer is no.
This is one of the new features.

00:42:24.490 --> 00:42:26.130
There's a lot of new features.
We're always trying to innovate.

00:42:26.130 --> 00:42:31.650
We're always trying to build out new functionality.
This is one of the new features in 2.2.

00:42:31.650 --> 00:42:36.630
&gt;&gt;&gt; In that case, we can do polling as before?
That's what you recommend?

00:42:36.630 --> 00:42:42.970
&gt;&gt;Debajit Ghosh: The question was, in that
case, we'd do polling as before on older applications

00:42:42.970 --> 00:42:48.580
 -- on older devices?
Yeah, you'd do polling or you can -- again,

00:42:48.580 --> 00:42:52.170
from day one, anyone can build their own push-based
system.

00:42:52.170 --> 00:42:54.250
So you could go ahead and build that if you
wanted.

00:42:54.250 --> 00:42:59.510
&gt;&gt;&gt; One more question.
Do you profile, like, a broadcast capability,

00:42:59.510 --> 00:43:04.061
where right now you're saying the phone has
to register for that message and you will

00:43:04.061 --> 00:43:09.070
go ahead and send it.
But there's a way, like, for any phones that

00:43:09.070 --> 00:43:14.280
have registered that has installed my app,
is there a way I can just send a message to

00:43:14.280 --> 00:43:18.670
everyone and let them know about certain information?
&gt;&gt;Debajit Ghosh: The question was, is there

00:43:18.670 --> 00:43:22.400
any way to send a message that is broadcast
to all devices.

00:43:22.400 --> 00:43:26.760
No.
The RegistrationID is a per-app, per-device

00:43:26.760 --> 00:43:31.140
ID.
It provides compartmentilization of apps and

00:43:31.140 --> 00:43:34.400
devices.
So that one, one sender can't send messages

00:43:34.400 --> 00:43:38.420
to another application.
So there's no way to do that.

00:43:38.420 --> 00:43:44.191
You'd have to issue a series of cloud-to-device
messages on your server side.

00:43:44.191 --> 00:43:47.180
&gt;&gt;&gt; Okay.
Thanks.

00:43:47.180 --> 00:43:49.310
&gt;&gt;&gt; What are the quotas?
And is pricing available?

00:43:49.310 --> 00:43:52.720
&gt;&gt;Debajit Ghosh: I'm sorry, can you repeat
the question?

00:43:52.720 --> 00:43:54.880
&gt;&gt;&gt; Is the service free?
Is there a pricing available?

00:43:54.880 --> 00:43:58.710
Is there quota limitations of how many messages
the application can send a day?

00:43:58.710 --> 00:44:01.920
&gt;&gt;Debajit Ghosh: The question was, what is
the pricing.

00:44:01.920 --> 00:44:07.110
The pricing is free.
What are the limitations?

00:44:07.110 --> 00:44:11.580
There are quota limitations.
Basically, what we're trying to do is look

00:44:11.580 --> 00:44:17.580
out for excessive usage in aggregate by a
sender or by a sender to a specific device.

00:44:17.580 --> 00:44:23.590
And if you find that you end up running into
those -- into issues with that, we can discuss

00:44:23.590 --> 00:44:26.030
and talk about quotas.
&gt;&gt;&gt; Okay.

00:44:26.030 --> 00:44:28.720
Thank you.
&gt;&gt;&gt; Two questions.

00:44:28.720 --> 00:44:33.930
One is, is there a way to specify a TTL for
a message, that it should not be delivered

00:44:33.930 --> 00:44:38.070
after a certain amount of time. So just in
case the user is offline at that point in

00:44:38.070 --> 00:44:42.770
time, the message will expire after, let's
say, two minutes and after two minutes it

00:44:42.770 --> 00:44:45.060
 --
&gt;&gt;Debajit Ghosh: The question was, is there

00:44:45.060 --> 00:44:50.440
a way to specify a TTL on a message.
The answer is, no, not currently.

00:44:50.440 --> 00:44:55.190
But if that's some other kind of functionality
you're interested in, we'll take that as feedback.

00:44:55.190 --> 00:44:58.510
&gt;&gt;&gt; Okay.
Thank you.

00:44:58.510 --> 00:45:02.970
&gt;&gt;&gt; In your example with polling every five
minutes, you said that that could use 5 to

00:45:02.970 --> 00:45:08.740
10% of your battery over a day with that operation.
Can you describe what mechanisms you use with

00:45:08.740 --> 00:45:14.330
your -- your cloud-to-device to reduce the
impact of that communication on the battery

00:45:14.330 --> 00:45:18.390
life of the phone.
For example, you respond within two seconds,

00:45:18.390 --> 00:45:23.581
when the screen is off, that kind of thing.
How are you keeping the battery usage down.

00:45:23.581 --> 00:45:26.810
&gt;&gt;Debajit Ghosh: I'm sorry, I'm having trouble
with the audio.

00:45:26.810 --> 00:45:30.230
Can you repeat the question?
You were talking about the --

00:45:30.230 --> 00:45:35.480
&gt;&gt;&gt; I'm curious how you were keeping the battery
usage down on your own cloud-to-device messaging

00:45:35.480 --> 00:45:40.280
infrastructure, 'cause you know when the screen
is on or off, and you're keeping track of

00:45:40.280 --> 00:45:45.650
things and you have quick response to messages.
How do you keep from using much power with

00:45:45.650 --> 00:45:47.710
that?
&gt;&gt;Debajit Ghosh: Well, the fundamental idea

00:45:47.710 --> 00:45:51.040
here is, we have one connection.
We amortize that connection across a lot of

00:45:51.040 --> 00:45:55.370
applications.
And when there's no traffic being transmitted

00:45:55.370 --> 00:45:59.480
or received over that connection, there's
very little power draw.

00:45:59.480 --> 00:46:04.970
And so what we've done is, we actually space
out our heartbeats to be, you know, much less

00:46:04.970 --> 00:46:08.460
frequent than every five minutes.
We make sure that those heartbeats are spaced

00:46:08.460 --> 00:46:12.880
out pretty far apart.
So for an idle device, for a device that's

00:46:12.880 --> 00:46:17.120
not getting data, there's not much impact
on battery.

00:46:17.120 --> 00:46:22.450
Of course, if you're going ahead and making
more use -- if there's a lot of messages that

00:46:22.450 --> 00:46:27.240
are coming down, then that will cause radio
wakeups, it will impact battery.

00:46:27.240 --> 00:46:32.770
And that's why we have features like attenuation.
And that's also why we have features that

00:46:32.770 --> 00:46:37.180
you can opt into, like delay while idle.
So that way, you know for your application

00:46:37.180 --> 00:46:43.110
domain you don't need to have messages sent
to an otherwise idle device, so you can afford

00:46:43.110 --> 00:46:45.620
to have them be delayed.
&gt;&gt;&gt; Thank you.

00:46:45.620 --> 00:47:00.530
&gt;&gt;&gt; So that said (Off mike) &gt;&gt;Debajit Ghosh:
The question was, that said, is there a five-minute

00:47:00.530 --> 00:47:01.800
latency in the system?
Not at all.

00:47:01.800 --> 00:47:08.590
The heartbeats are not five minutes, in fact.
We have those heartbeats in place, and they're

00:47:08.590 --> 00:47:12.390
much less frequent than every five minutes,
on the order of, you know, sometimes half

00:47:12.390 --> 00:47:16.090
an hour.
And we had those heartbeats in place just

00:47:16.090 --> 00:47:19.530
to keep the connection alive.
Because once you've established that connection,

00:47:19.530 --> 00:47:25.150
you only keep it alive because reconnecting
can be a bit more expensive.

00:47:25.150 --> 00:47:27.570
So we're just trying to keep that connection
alive.

00:47:27.570 --> 00:47:31.970
While that connection is alive, messages will
be sent very, very quickly.

00:47:31.970 --> 00:47:34.711
There shouldn't be, you know, on the order
of five-minute latency.

00:47:34.711 --> 00:47:42.700
&gt;&gt;&gt; Do you have any plans or is this compliant
with OMA push specifications?

00:47:42.700 --> 00:47:47.940
&gt;&gt;Debajit Ghosh: The question is, is there
any integration here with OMA push, are there

00:47:47.940 --> 00:47:50.940
any plans to integrate with OMA push.
Not at this time.

00:47:50.940 --> 00:47:56.830
&gt;&gt;&gt; So, basically, if I have a push server,
I cannot use it.

00:47:56.830 --> 00:48:00.940
I have to go through the one that Google sets
up; correct?

00:48:00.940 --> 00:48:04.910
&gt;&gt;Debajit Ghosh: If you want to use Android
 -- the question was, if you have a push server,

00:48:04.910 --> 00:48:07.660
you wouldn't be able to use that here.
That's correct.

00:48:07.660 --> 00:48:12.430
You'd have to -- if you want to make use of
Android cloud-to-device messaging, you have

00:48:12.430 --> 00:48:17.461
to use the Android cloud-to-device APIs.
If you want to build out support for OMA push,

00:48:17.461 --> 00:48:22.541
you know, this is Android.
You can build the service on the application

00:48:22.541 --> 00:48:26.890
or you can install, you know -- if someone
else has built one, you can install that on

00:48:26.890 --> 00:48:29.760
a device and that can go ahead and connect
to the OMA push servers.

00:48:29.760 --> 00:48:33.800
&gt;&gt;&gt; Thank you.
&gt;&gt;&gt; Okay.

00:48:33.800 --> 00:48:37.770
You said that you amortize the connection
across multiple applications.

00:48:37.770 --> 00:48:41.790
The default applications that are shipping
out that are used by Google which use push

00:48:41.790 --> 00:48:49.150
services, do those also use exactly this connection?
Or do they have a separate connection and

00:48:49.150 --> 00:48:52.450
this is only for applications -- applications
by developers?

00:48:52.450 --> 00:48:57.500
&gt;&gt;Debajit Ghosh: The question was, is this
the same connection that's used for the Google

00:48:57.500 --> 00:49:01.420
functionality or is there a separate connection?
This is the exact same connection.

00:49:01.420 --> 00:49:05.970
So we're -- we're using this functionality.
We've been using this functionality, you know,

00:49:05.970 --> 00:49:12.000
since day one to enable push for GMail contacts
and calendar sync, for a lot of other functionality.

00:49:12.000 --> 00:49:14.070
We're just basically opening this up to all
of you now.

00:49:14.070 --> 00:49:21.701
&gt;&gt;&gt; Is there a way for the user to specify
that he's okay with a high frequency of updates

00:49:21.701 --> 00:49:26.000
during some periods of the day, like in the
morning, and then in the afternoon, say I

00:49:26.000 --> 00:49:29.790
want very few messages during this time?
&gt;&gt;Debajit Ghosh: The question was, is there

00:49:29.790 --> 00:49:36.310
a way to specify an application's okay with
latency during periods of time and wants more

00:49:36.310 --> 00:49:40.480
freshness during other periods of time.
There's nothing like that.

00:49:40.480 --> 00:49:44.430
That's something that you would -- That's
the kind of logic that you would build out

00:49:44.430 --> 00:49:48.010
in your application server at the point when
you're issuing the messages.

00:49:48.010 --> 00:49:51.220
&gt;&gt;&gt; Right.
But if I was too frequent, Google would scale

00:49:51.220 --> 00:49:56.020
me back; right?
If I -- if I send messages too frequently,

00:49:56.020 --> 00:50:04.060
then your servers will -- will back off; right?
&gt;&gt;Debajit Ghosh: The question was, if the

00:50:04.060 --> 00:50:07.220
application's sending too frequently, will
Google scale that back.

00:50:07.220 --> 00:50:12.180
Yes, that's what we do with attenuation.
And there's no way to specify, you know, hints

00:50:12.180 --> 00:50:15.550
or policies of what you'd like, you know,
in the form of attenuation.

00:50:15.550 --> 00:50:21.640
&gt;&gt;&gt; Thank you.
&gt;&gt;&gt; So I have small question.

00:50:21.640 --> 00:50:26.090
The first is, how do you guarantee the security
of the message?

00:50:26.090 --> 00:50:29.310
I mean, sometimes the message can be some
sensitive information.

00:50:29.310 --> 00:50:34.080
How do you guarantee the security?
I mean, do you use any encryption or something

00:50:34.080 --> 00:50:37.220
like that to process?
&gt;&gt;Debajit Ghosh: The question was, how do

00:50:37.220 --> 00:50:42.880
you guarantee the security of a message if
a message contains some sensitive data? Do

00:50:42.880 --> 00:50:47.050
we use encryption.
That persistent connection is SSL-encrypted.

00:50:47.050 --> 00:50:51.310
But remember, the overall design here is not
to have state in the message.

00:50:51.310 --> 00:50:55.600
Don't -- I mean, you know, if you want to
have something sensitive in that message,

00:50:55.600 --> 00:50:59.300
you can encrypt it.
You can do that with the arbitrary payload.

00:50:59.300 --> 00:51:02.000
That's something you can do on an application
level.

00:51:02.000 --> 00:51:05.110
Or don't send anything sensitive down that
pipe.

00:51:05.110 --> 00:51:09.810
Just tickle your application and then have
your application fetch its sensitive data

00:51:09.810 --> 00:51:14.020
directly.
That's the kind of design that we've made

00:51:14.020 --> 00:51:17.220
use of in building our own sync functionality.
&gt;&gt;&gt; Right.

00:51:17.220 --> 00:51:26.310
So basically, basically, C2D is not suitable
for sensitive use case; right?

00:51:26.310 --> 00:51:31.280
&gt;&gt;Debajit Ghosh: The question was, Android
cloud-to-device isn't suitable for sensitive

00:51:31.280 --> 00:51:34.640
information.
And, again, I think that's something you can

00:51:34.640 --> 00:51:38.610
work through in your design by using the techniques
that I talked about.

00:51:38.610 --> 00:51:42.770
That you can control on the application side.
&gt;&gt;&gt; Right.

00:51:42.770 --> 00:51:45.620
The other question is, how do you guarantee
the authentication?

00:51:45.620 --> 00:51:50.570
I mean, someone asked me maybe what -- someone
might steal my RegistrationID and pretend

00:51:50.570 --> 00:51:57.440
to be me and address it to the server.
&gt;&gt;Debajit Ghosh: The question was, how do

00:51:57.440 --> 00:52:01.141
you authenticate these requests.
&gt;&gt;&gt; Right.

00:52:01.141 --> 00:52:04.510
&gt;&gt;Debajit Ghosh: How do you make sure that
someone else doesn't steal your RegistrationID.

00:52:04.510 --> 00:52:11.240
There's two bits of information here.
One is the role account that you specify when

00:52:11.240 --> 00:52:17.320
you create the registration.
And we make sure that when an application

00:52:17.320 --> 00:52:22.940
server tries to issue a message to a RegistrationID,
that the authentication credentials for the

00:52:22.940 --> 00:52:27.340
HTTP post match that role account.
So it's up to you.

00:52:27.340 --> 00:52:30.490
I mean, it's a password.
It's something that you should keep safe or

00:52:30.490 --> 00:52:34.930
secret on your own.
Don't -- don't start giving out that password,

00:52:34.930 --> 00:52:37.531
for example.
That's why you can also use a role account.

00:52:37.531 --> 00:52:43.290
And the second thing is, there's a per-app,
per-device RegistrationID.

00:52:43.290 --> 00:52:47.440
And that's also something that, you know,
your application gets and can send to your

00:52:47.440 --> 00:52:50.190
server.
Don't give that out, either.

00:52:50.190 --> 00:52:52.640
All right?
Those are two bits of information that you

00:52:52.640 --> 00:52:56.180
need to send a message to an app on a device.
&gt;&gt;&gt; Okay.

00:52:56.180 --> 00:52:58.480
Thank you.
&gt;&gt;Debajit Ghosh: Let's go ahead and see if

00:52:58.480 --> 00:53:02.110
there's any -- any offline questions and questions
on moderator.

00:53:02.110 --> 00:53:12.340
I think we answered the first question, which
is, this requires Android 2.2.

00:53:12.340 --> 00:53:16.730
Second question, could you discuss the relationship
between cloud-to-device in the core Android

00:53:16.730 --> 00:53:27.380
SDK and any dependency on Google services.
The Android cloud-to-device messaging API

00:53:27.380 --> 00:53:31.710
is a Google service that's supported on Android
2.2 devices.

00:53:31.710 --> 00:53:40.270
A Google account is required on the device.
Of course, your application doesn't need to

00:53:40.270 --> 00:53:44.200
think about or worry about that account.
You can use whatever authentication credentials

00:53:44.200 --> 00:53:49.150
make sense for your domain.
But to establish or maintain that connection,

00:53:49.150 --> 00:53:58.280
a Google account needs to be on the device.
So there is a dependency on Google services.

00:53:58.280 --> 00:54:06.230
The next question was about Market, and I
think we already answered that.

00:54:06.230 --> 00:54:10.000
What is -- the next question is what's the
data format? Or is that also up to us?

00:54:10.000 --> 00:54:16.101
The data format, if you are going to be sending
some payload, it's arbitrary key value pairs

00:54:16.101 --> 00:54:21.021
that you set in your HTTP post, and you can
those values be whatever you want it to be.

00:54:21.021 --> 00:54:27.301
&gt;&gt;&gt; What's the max size of the message and
how long will it last in Google servers before

00:54:27.301 --> 00:54:30.141
it's delivered to a user, in case the user
is off-line?

00:54:30.141 --> 00:54:37.640
&gt;&gt;Debajit Ghosh: The question is what's the
max size per message. Max size is 1K.

00:54:37.640 --> 00:54:41.471
The second question, I had a little bit of
trouble W how do we make sure the message

00:54:41.471 --> 00:54:44.830
gets to the device?
&gt;&gt;&gt; No. How long will it last on your servers

00:54:44.830 --> 00:54:49.501
till its delivered to the user in case the
user is off-line? What's the maximum amount

00:54:49.501 --> 00:54:54.320
of time that it can survive on your servers.
&gt;&gt;Debajit Ghosh: On the order of weeks. Maybe

00:54:54.320 --> 00:55:01.270
a month, you know.
&gt;&gt;&gt; From the perspective of the server that's

00:55:01.270 --> 00:55:07.100
generating the message, is it fire and forget
or can it get an ack back?

00:55:07.100 --> 00:55:12.730
&gt;&gt;Debajit Ghosh: So the question is, is this
a fire-and-forget request or will the application

00:55:12.730 --> 00:55:14.570
server get an acknowledgment back?
&gt;&gt;&gt; Correct.

00:55:14.570 --> 00:55:20.980
&gt;&gt;Debajit Ghosh: The application server will
get back an ID when it sends the message,

00:55:20.980 --> 00:55:28.700
and if it gets back that ID, then the message
is on its way to a device. There's no end-to-end

00:55:28.700 --> 00:55:32.650
acknowledgment that comes back from the application.
Typically, again, that's something you do

00:55:32.650 --> 00:55:38.930
in your own application logic. If you want
to have that kind of functionality, when your

00:55:38.930 --> 00:55:43.820
application receives the message, wakes up,
it can talk to your application server and

00:55:43.820 --> 00:55:48.420
provide that acknowledgment.
&gt;&gt;&gt; Right. Okay. Thanks.

00:55:48.420 --> 00:55:52.930
&gt;&gt;&gt; You may have mentioned this but I didn't
catch it. Does this work on a device that

00:55:52.930 --> 00:55:58.460
doesn't currently have service and only has
a Wi-Fi connection? Will it go through a home

00:55:58.460 --> 00:56:00.990
router?
&gt;&gt;Debajit Ghosh: The question was will this

00:56:00.990 --> 00:56:07.940
work on Wi-Fi. Yes, as long as you have a
data connection, then the device can go ahead

00:56:07.940 --> 00:56:12.860
and establish connection with our servers.
I mean, you know, it also is the -- you will

00:56:12.860 --> 00:56:17.589
need that data connectivity for your application
to access data in the cloud as well.

00:56:17.589 --> 00:56:18.890
&gt;&gt;&gt; Right. Okay.
Thanks.

00:56:18.890 --> 00:56:22.130
&gt;&gt;Debajit Ghosh: And I think that's it.
Thank you very much.

00:56:22.130 --> 00:56:23.020
[ Applause ]

