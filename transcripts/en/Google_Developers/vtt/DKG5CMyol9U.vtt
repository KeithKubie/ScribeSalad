WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:03.280
SPEAKER: I'm very excited to
introduce the one and only

00:00:03.280 --> 00:00:06.250
Leaf Peterson talking about the
Dart's type system, a subject

00:00:06.250 --> 00:00:08.050
near and dear to my heart.

00:00:08.050 --> 00:00:10.175
LEAF PETERSON: It's the
type theory talk for today,

00:00:10.175 --> 00:00:11.245
it's the only one.

00:00:11.245 --> 00:00:12.120
OK, how's the volume?

00:00:12.120 --> 00:00:13.205
Is it good?

00:00:13.205 --> 00:00:13.830
Sounds like it.

00:00:13.830 --> 00:00:16.650
If I'm yelling at
you too loud, sorry.

00:00:16.650 --> 00:00:19.650
So Sound Dart.

00:00:19.650 --> 00:00:21.430
What's all this about?

00:00:21.430 --> 00:00:24.880
So about a year
and a half ago, we

00:00:24.880 --> 00:00:29.290
started looking into how
we could layer a sound type

00:00:29.290 --> 00:00:31.660
system on top of the
existing Dart language

00:00:31.660 --> 00:00:34.080
and Dart type system.

00:00:34.080 --> 00:00:36.510
The reason that we did
this kind of crazy thing

00:00:36.510 --> 00:00:41.040
was to enable us to improve
the developer experience

00:00:41.040 --> 00:00:42.610
with the Dart dev compiler.

00:00:42.610 --> 00:00:43.790
That's going to the
next talk, so I'm not

00:00:43.790 --> 00:00:45.081
going to talk about that a lot.

00:00:45.081 --> 00:00:47.810
This talk is about what
we call strong mode, which

00:00:47.810 --> 00:00:49.810
is the sound type
system that we designed.

00:00:49.810 --> 00:00:53.590
I want to talk about what
it is, what it does for us,

00:00:53.590 --> 00:00:59.040
and how it can make your lives
as Dart developers better.

00:00:59.040 --> 00:01:02.060
So going to start out by
talking a little bit about what

00:01:02.060 --> 00:01:04.029
soundness is in general.

00:01:04.029 --> 00:01:05.570
I think in some ways
this is obvious,

00:01:05.570 --> 00:01:07.230
but I think it's
really worth talking

00:01:07.230 --> 00:01:12.350
about what the core of soundness
is when we come down to it.

00:01:12.350 --> 00:01:14.479
So really, soundness
is about a relationship

00:01:14.479 --> 00:01:17.020
between the programs that you
write, the code that you write,

00:01:17.020 --> 00:01:19.690
and the values that show
up in the code at runtime.

00:01:19.690 --> 00:01:21.990
So we say that a type,
system or language,

00:01:21.990 --> 00:01:25.460
is sound if whenever you say
that something is a dog, when

00:01:25.460 --> 00:01:28.310
your type system says this
expression, this piece of code

00:01:28.310 --> 00:01:31.390
has static type dog,
everything that you get out

00:01:31.390 --> 00:01:33.300
at runtime in that
position is going

00:01:33.300 --> 00:01:37.150
to be a dog and nothing else.

00:01:37.150 --> 00:01:41.782
So if I write some code
like this, for example,

00:01:41.782 --> 00:01:43.990
I think it's pretty clear
what the intent of this is.

00:01:43.990 --> 00:01:45.573
I'm saying I'm going
to feed the dogs,

00:01:45.573 --> 00:01:49.110
and my intent is to
pass it a list of dogs.

00:01:49.110 --> 00:01:51.610
So I've written
the type list Dog

00:01:51.610 --> 00:01:53.800
to say, hey, this
code should take dogs.

00:01:53.800 --> 00:01:57.030
So if I were to come
along and read this code,

00:01:57.030 --> 00:01:59.920
I might very reasonably
act under the assumption

00:01:59.920 --> 00:02:03.190
that all of the things that
reach the variable fido

00:02:03.190 --> 00:02:06.579
are going to be a dog.

00:02:06.579 --> 00:02:07.870
And that's a good thing, right?

00:02:07.870 --> 00:02:11.910
So Fido probably going to
have a feed method, and fido

00:02:11.910 --> 00:02:16.870
will probably very be very
happy to get a juicy bone there.

00:02:16.870 --> 00:02:19.200
So that's very reasonable
as a programmer

00:02:19.200 --> 00:02:20.242
I've expressed my intent.

00:02:20.242 --> 00:02:21.950
And if I'm refactoring
I might come along

00:02:21.950 --> 00:02:24.090
and act under the assumption
that the things that

00:02:24.090 --> 00:02:26.298
are going to get here are
going to be a list of dogs.

00:02:26.298 --> 00:02:30.810
But in fact, in regular
Dart, even in checked mode,

00:02:30.810 --> 00:02:33.620
there's no guarantee that
the things that show up here

00:02:33.620 --> 00:02:35.390
are actually going to be dogs.

00:02:35.390 --> 00:02:40.840
I might get a number,
or I might get a string,

00:02:40.840 --> 00:02:43.750
or I might get something
completely unexpected.

00:02:43.750 --> 00:02:50.750
So despite the intent,
we're not living in a world

00:02:50.750 --> 00:02:53.120
where things that are
claimed to be dogs

00:02:53.120 --> 00:02:54.860
will necessarily be dogs.

00:02:54.860 --> 00:02:57.590
In regular Dart, you
might get something

00:02:57.590 --> 00:02:59.800
completely unexpected
in a place where

00:02:59.800 --> 00:03:00.910
you expected to get a dog.

00:03:03.480 --> 00:03:08.940
There's lots of reasons why
you might care about soundness.

00:03:08.940 --> 00:03:11.490
The one that I
want to start with

00:03:11.490 --> 00:03:15.810
is why soundness matters to us
as people implementing Dart,

00:03:15.810 --> 00:03:18.720
and so I want to talk
about compiling first.

00:03:18.720 --> 00:03:22.080
So when you're
compiling unsound code,

00:03:22.080 --> 00:03:26.360
you have to be very cautious
about what things might show up

00:03:26.360 --> 00:03:28.480
where you expected a dog.

00:03:28.480 --> 00:03:32.556
This isn't a real problem
for a VM, for a just in time

00:03:32.556 --> 00:03:34.430
compiler, because a just
in time compiler can

00:03:34.430 --> 00:03:37.530
make optimistic assumptions,
and then later on it

00:03:37.530 --> 00:03:38.390
can change its mind.

00:03:38.390 --> 00:03:40.780
It can say, oh, I got a cat.

00:03:40.780 --> 00:03:43.844
I will recompile this
code, patch it back in,

00:03:43.844 --> 00:03:44.760
and everything's good.

00:03:44.760 --> 00:03:49.480
So we can do the really
fast thing optimistically

00:03:49.480 --> 00:03:50.780
and change its mind later.

00:03:50.780 --> 00:03:52.620
When you're in an
ahead of time compiler,

00:03:52.620 --> 00:03:55.450
you have to actually
plan for the worst case.

00:03:55.450 --> 00:03:58.260
You need to deal with all of
these different possibilities

00:03:58.260 --> 00:03:58.850
statically.

00:03:58.850 --> 00:04:00.410
You need to worry
about what happens

00:04:00.410 --> 00:04:02.124
if it doesn't have
a feed method,

00:04:02.124 --> 00:04:03.790
or if it has a feed
method which expects

00:04:03.790 --> 00:04:10.050
different sorts of parameters,
or it has a feed setter

00:04:10.050 --> 00:04:11.096
or getter or something.

00:04:11.096 --> 00:04:12.470
So all of those
things are things

00:04:12.470 --> 00:04:14.240
that can possibly
happen at runtime,

00:04:14.240 --> 00:04:17.060
you need to be
prepared for them.

00:04:17.060 --> 00:04:18.880
So that makes your
code much bigger,

00:04:18.880 --> 00:04:21.720
it makes it harder to
generate readable code

00:04:21.720 --> 00:04:26.770
if you're in the ahead of
time compilation setting.

00:04:26.770 --> 00:04:30.500
So the original goal,
The original motivation

00:04:30.500 --> 00:04:32.060
of looking at the
sound type system

00:04:32.060 --> 00:04:35.220
is to enable a
better ahead of time

00:04:35.220 --> 00:04:38.650
compilation system to give a
better developer experience so

00:04:38.650 --> 00:04:41.500
that we could very quickly
generate very readable code

00:04:41.500 --> 00:04:44.400
that you could very easily debug
on any browser that you wanted.

00:04:44.400 --> 00:04:47.300
And we're going to talk more
about that in a little bit.

00:04:47.300 --> 00:04:49.780
So if you are working
with a sound language

00:04:49.780 --> 00:04:51.380
and you're compiling
this code, you

00:04:51.380 --> 00:04:54.837
don't now have to worry
about very unexpected things.

00:04:54.837 --> 00:04:56.420
You don't have to
worry about strings,

00:04:56.420 --> 00:04:58.590
you don't have to
worry about numbers,

00:04:58.590 --> 00:05:01.540
you can just assume
you're going to get a dog.

00:05:01.540 --> 00:05:04.620
Everybody likes dogs.

00:05:04.620 --> 00:05:09.250
Now when we came out
with strong mode,

00:05:09.250 --> 00:05:11.750
some people just turned out
to kind of like strong mode

00:05:11.750 --> 00:05:13.170
anyway.

00:05:13.170 --> 00:05:15.840
So even some people
who are not actually

00:05:15.840 --> 00:05:17.890
using the technology
that we're building

00:05:17.890 --> 00:05:20.130
over strong mode started
turning on strong mode

00:05:20.130 --> 00:05:23.240
because they found the things
that we were building into it

00:05:23.240 --> 00:05:25.770
were useful to them as
developers, as well.

00:05:25.770 --> 00:05:28.035
Flooder was one of
our early customers,

00:05:28.035 --> 00:05:29.410
and they were a
super useful one.

00:05:29.410 --> 00:05:31.493
Because they gave us lots
of really good feedback,

00:05:31.493 --> 00:05:34.050
but they were not actually
using the technology that we

00:05:34.050 --> 00:05:35.050
were building into this.

00:05:35.050 --> 00:05:38.820
And we saw this a
lot where people

00:05:38.820 --> 00:05:42.780
were using strong mode
to get the benefits just

00:05:42.780 --> 00:05:44.030
of the stronger type system.

00:05:44.030 --> 00:05:47.420
And so strong mode
is now, I think,

00:05:47.420 --> 00:05:50.410
expanding to being used more and
more for these other benefits

00:05:50.410 --> 00:05:51.560
we're talking about.

00:05:51.560 --> 00:05:57.670
So when I'm working with
code, when I'm writing code,

00:05:57.670 --> 00:06:00.120
when I'm reading code,
when I'm maintaining code,

00:06:00.120 --> 00:06:02.870
those are all situations
where having reliable types

00:06:02.870 --> 00:06:04.990
also can provide some benefits.

00:06:04.990 --> 00:06:11.320
So if I'm reading code, it's
OK to sort of assume that

00:06:11.320 --> 00:06:14.410
when the user wrote a list of
dog that that was their intent,

00:06:14.410 --> 00:06:16.060
and that's what it will be.

00:06:16.060 --> 00:06:17.770
But it's a little unsafe.

00:06:17.770 --> 00:06:20.110
You could be relying on
accidental properties

00:06:20.110 --> 00:06:25.220
of the code that aren't actually
tracked by the type system.

00:06:25.220 --> 00:06:27.480
And this is even bigger
when you go around

00:06:27.480 --> 00:06:29.786
and you start incrementally
modifying code.

00:06:29.786 --> 00:06:31.910
If you don't get the feedback
from the type system,

00:06:31.910 --> 00:06:35.330
it's harder to maintain
very large amounts of code.

00:06:35.330 --> 00:06:37.690
And Google has large
amounts of code.

00:06:40.320 --> 00:06:42.660
So our goal was that
all these people

00:06:42.660 --> 00:06:46.970
who are doing all this work
to write types in their code

00:06:46.970 --> 00:06:50.270
would get all of the
benefit that they really

00:06:50.270 --> 00:06:51.650
weren't getting.

00:06:51.650 --> 00:06:54.720
What we were seeing was that
people were writing this code

00:06:54.720 --> 00:06:57.650
as if it was a statically typed
language, as if it was sound,

00:06:57.650 --> 00:06:59.640
but they weren't getting
all of the assistance

00:06:59.640 --> 00:07:04.870
that they could because
the language wasn't sound,

00:07:04.870 --> 00:07:06.660
and the types can lie.

00:07:06.660 --> 00:07:10.060
So our motto for strong mode
is that we want to make it

00:07:10.060 --> 00:07:13.330
so that the types can't lie.

00:07:13.330 --> 00:07:14.695
So what is strong mode?

00:07:14.695 --> 00:07:16.070
There's really
three pieces here.

00:07:16.070 --> 00:07:19.840
There's a type system, there's
a set of runtime checks

00:07:19.840 --> 00:07:22.840
that deals with the remaining
dynamism in the language,

00:07:22.840 --> 00:07:24.450
and then there's
some type inference

00:07:24.450 --> 00:07:27.100
which are there to keep
the language feeling dirty.

00:07:27.100 --> 00:07:30.480
So I want to talk about
each of these three pieces

00:07:30.480 --> 00:07:33.105
starting with the
sound type system.

00:07:33.105 --> 00:07:34.730
So there's really
actually in some ways

00:07:34.730 --> 00:07:37.100
surprisingly little
that we had to change

00:07:37.100 --> 00:07:40.190
to make the type system sound.

00:07:40.190 --> 00:07:42.070
There are really just
three major things

00:07:42.070 --> 00:07:45.240
we had to change about the
way the type system works.

00:07:45.240 --> 00:07:48.680
The first is that we had
to change the way override

00:07:48.680 --> 00:07:51.520
checking works.

00:07:51.520 --> 00:07:54.840
So dog here inherits
from object.

00:07:54.840 --> 00:07:57.900
Object has a hashcode
method that is

00:07:57.900 --> 00:08:00.470
declared to return an integer.

00:08:00.470 --> 00:08:04.540
Standard Dart doesn't object if
you change the return type here

00:08:04.540 --> 00:08:08.410
to object, and string is a
perfectly reasonable object.

00:08:08.410 --> 00:08:12.050
So this is a perfectly valid
override in normal Dart.

00:08:12.050 --> 00:08:14.470
It's a bad idea,
please don't do this.

00:08:14.470 --> 00:08:18.960
Strong mode will yell at you,
my cat will look at you funny.

00:08:18.960 --> 00:08:21.080
It's a bad idea.

00:08:21.080 --> 00:08:24.510
Similarly, covariant
method override.

00:08:24.510 --> 00:08:25.830
So that was the return type.

00:08:25.830 --> 00:08:30.200
If you want to tighten
the type on a parameter.

00:08:30.200 --> 00:08:32.590
So in some ways this looks
like very reasonable code.

00:08:32.590 --> 00:08:35.679
So I have an animal, and I say,
well, it's got a chase method.

00:08:35.679 --> 00:08:38.909
And the chase method, an
animal chases some animal.

00:08:38.909 --> 00:08:41.360
And now I'm going to take
a cat, and it's an animal,

00:08:41.360 --> 00:08:44.074
and it will chase the mice.

00:08:44.074 --> 00:08:45.240
This seems quite reasonable.

00:08:45.240 --> 00:08:49.180
But the problem is that if
I assign a cat to an animal,

00:08:49.180 --> 00:08:52.830
I can then send that cat off
to chase a dog, which is going

00:08:52.830 --> 00:08:54.502
to make for an unhappy cat.

00:08:54.502 --> 00:08:56.460
So strong mode will yell
at you if you do this,

00:08:56.460 --> 00:08:57.400
please don't do that.

00:09:00.810 --> 00:09:08.840
Another one that I think is
actually surprisingly important

00:09:08.840 --> 00:09:12.080
is getting rid of these
sneaky dynamic lists.

00:09:12.080 --> 00:09:14.940
So lists, and in general,
all sorts of generics.

00:09:14.940 --> 00:09:17.796
When you're working
with generics in Dart,

00:09:17.796 --> 00:09:19.420
there's actually a
cool feature of Dart

00:09:19.420 --> 00:09:21.650
where you can take a generic,
you can instantiate it

00:09:21.650 --> 00:09:24.410
with dynamic, and now you
can use it as anything.

00:09:24.410 --> 00:09:27.260
So here I've made
a list of dynamic,

00:09:27.260 --> 00:09:28.450
and I filled it with dogs.

00:09:28.450 --> 00:09:32.390
This is allowed to
masquerade as a list of cat.

00:09:32.390 --> 00:09:34.930
It's kind of a cool
thing, but it totally

00:09:34.930 --> 00:09:36.860
breaks all your soundness.

00:09:36.860 --> 00:09:39.490
Strong mode will yell at you,
my cat will look at you funny,

00:09:39.490 --> 00:09:41.890
please don't do that.

00:09:41.890 --> 00:09:44.610
Similarly to the
override case, we also

00:09:44.610 --> 00:09:47.220
restrict function
subtyping to be

00:09:47.220 --> 00:09:51.080
the usual contravariant on
the parameter, covariant

00:09:51.080 --> 00:09:52.160
in the return type.

00:09:52.160 --> 00:09:54.130
If you have something
which registers a cat

00:09:54.130 --> 00:09:56.600
and expects a callback
which returns a cat.

00:09:56.600 --> 00:09:58.370
In regular Dart,
this is assignable.

00:09:58.370 --> 00:10:00.440
A function which returns
an animal is assignable.

00:10:00.440 --> 00:10:03.260
So you can pass in something
which returns a dog when

00:10:03.260 --> 00:10:05.130
you register your cat.

00:10:05.130 --> 00:10:06.950
That's not going to
make anybody happy,

00:10:06.950 --> 00:10:08.650
strong mode won't let you do it.

00:10:08.650 --> 00:10:10.610
Please don't.

00:10:10.610 --> 00:10:12.730
So these restrictions
are basically

00:10:12.730 --> 00:10:17.870
enough to make a sound
type system, sort of.

00:10:17.870 --> 00:10:20.270
So what's the sort of?

00:10:20.270 --> 00:10:22.390
We didn't want to
go fully, in part

00:10:22.390 --> 00:10:24.374
because we have a
huge corpus of code.

00:10:24.374 --> 00:10:25.790
And people like
writing Dart code.

00:10:25.790 --> 00:10:27.415
So we don't want to
come along and say,

00:10:27.415 --> 00:10:29.040
you are all bad
people and wrong,

00:10:29.040 --> 00:10:31.970
and we want to punish you
for writing Dart code.

00:10:31.970 --> 00:10:34.250
We want to keep the language
as Darty as possible.

00:10:34.250 --> 00:10:35.980
So one of the ways we
did that is saying,

00:10:35.980 --> 00:10:38.830
OK, there are certain patterns
which are not quite statically

00:10:38.830 --> 00:10:41.340
sound, but we can
recover soundness

00:10:41.340 --> 00:10:45.200
by injecting runtime checks
sort of like checked mode,

00:10:45.200 --> 00:10:47.370
but a very small
subset of checked mode.

00:10:47.370 --> 00:10:52.720
So here, for example, is
actually perfectly valid

00:10:52.720 --> 00:10:54.470
strong mode code.

00:10:54.470 --> 00:10:57.350
Even though this looks
really kind of silly when

00:10:57.350 --> 00:10:59.070
you write it this
way, it's actually

00:10:59.070 --> 00:11:00.520
pretty reasonable in some ways.

00:11:00.520 --> 00:11:02.110
You have something
which is an animal.

00:11:02.110 --> 00:11:04.450
It might be a cat.

00:11:04.450 --> 00:11:07.250
In this case, though, it
is, in fact, not a cat.

00:11:07.250 --> 00:11:09.080
We will statically
let this through,

00:11:09.080 --> 00:11:12.230
but we will yell
at you at runtime.

00:11:12.230 --> 00:11:15.620
So strong mode has an implied
run time downcast here,

00:11:15.620 --> 00:11:18.180
which is going to stop
you from actually putting

00:11:18.180 --> 00:11:20.770
a dog where a cat is when you
actually get there at runtime.

00:11:23.450 --> 00:11:24.890
So that's the
runtime part of it.

00:11:24.890 --> 00:11:26.265
There's also some
checks required

00:11:26.265 --> 00:11:30.530
to deal with covariant generics,
we keep generics as covariant.

00:11:30.530 --> 00:11:34.740
Which is not totally sound,
but that works for us.

00:11:34.740 --> 00:11:37.150
So there's a caveat here
with the runtime checks.

00:11:37.150 --> 00:11:39.870
These are only implemented in
the Dart development compilers

00:11:39.870 --> 00:11:42.600
so far.

00:11:42.600 --> 00:11:44.540
We've had a lot of
success with strong mode

00:11:44.540 --> 00:11:47.150
and a lot of success
with the dev compiler.

00:11:47.150 --> 00:11:51.530
We are moving towards
implementing these semantics

00:11:51.530 --> 00:11:54.230
more widely in our tools and
supporting them more broadly

00:11:54.230 --> 00:11:56.190
so that you can
make use of them.

00:11:56.190 --> 00:11:58.850
But so far you're only going
to get those runtime parts

00:11:58.850 --> 00:12:00.620
of the checks when
you're actually running

00:12:00.620 --> 00:12:01.880
in the Dart dev compiler.

00:12:01.880 --> 00:12:04.380
So that means that you can
actually break our type system,

00:12:04.380 --> 00:12:05.890
in a certain sense,
if you're using

00:12:05.890 --> 00:12:07.440
one of the other platforms.

00:12:07.440 --> 00:12:09.910
But you still get the benefit
of the static checks anyway.

00:12:09.910 --> 00:12:11.493
And if you're running
in checked mode,

00:12:11.493 --> 00:12:13.670
you actually get most
of those checks as well.

00:12:13.670 --> 00:12:15.920
The last piece I want to
talk about is type inference.

00:12:15.920 --> 00:12:17.670
And this is the really
cool part, I think,

00:12:17.670 --> 00:12:19.420
because this is a
part where we give you

00:12:19.420 --> 00:12:20.690
a whole lot of benefits.

00:12:20.690 --> 00:12:22.760
And it's also the
part where we do

00:12:22.760 --> 00:12:26.290
things to make working with
the stronger type system still

00:12:26.290 --> 00:12:28.890
feel very Darty.

00:12:28.890 --> 00:12:32.750
So in regular Dart, when
someone writes var-- like here

00:12:32.750 --> 00:12:37.060
they say var fluffy,
what that actually means

00:12:37.060 --> 00:12:39.939
is that the type of
fluffy is dynamic.

00:12:39.939 --> 00:12:41.730
So that's a little
surprising in some ways.

00:12:41.730 --> 00:12:43.690
A lot of people think
of this as saying,

00:12:43.690 --> 00:12:47.140
this is maybe type inference,
or I don't know what.

00:12:47.140 --> 00:12:49.680
But really it means dynamic.

00:12:49.680 --> 00:12:51.620
And what that means is
that if I do something

00:12:51.620 --> 00:12:55.450
like this, where I take
a substring of fluffy,

00:12:55.450 --> 00:13:00.380
this is perfectly valid code
in regular Dart statically.

00:13:00.380 --> 00:13:04.980
Because it's dynamic, and
dynamic has all methods.

00:13:04.980 --> 00:13:07.800
So we changed that
in strong mode.

00:13:07.800 --> 00:13:10.270
In strong mode Dart,
saying var means

00:13:10.270 --> 00:13:12.830
please infer for a type
for me here rather than

00:13:12.830 --> 00:13:15.010
just treat this as dynamic.

00:13:15.010 --> 00:13:17.090
So when you write
code like this,

00:13:17.090 --> 00:13:20.470
we will infer a type of
cat for that variable,

00:13:20.470 --> 00:13:23.990
and we will yell at you.

00:13:23.990 --> 00:13:25.990
It's not just var,
basically any place

00:13:25.990 --> 00:13:29.870
that you leave off a type
in code in strong mode,

00:13:29.870 --> 00:13:34.560
we will try to fill in a type
for you using type inference.

00:13:34.560 --> 00:13:42.050
So here I have a map literal
and a string inside of a list.

00:13:42.050 --> 00:13:44.110
These, in regular
Dart, are interpreted

00:13:44.110 --> 00:13:45.900
as dynamic lists
and dynamic maps,

00:13:45.900 --> 00:13:48.730
so you could have lots of stuff
in here that you didn't expect.

00:13:48.730 --> 00:13:50.310
Or you could add
something later on

00:13:50.310 --> 00:13:52.210
and you would get no
checked mode errors

00:13:52.210 --> 00:13:56.560
because the type of these
things were actually at runtime,

00:13:56.560 --> 00:13:59.110
or are dynamic.

00:13:59.110 --> 00:14:02.810
In strong mode, we will actually
push down this outer type

00:14:02.810 --> 00:14:05.530
into this term here.

00:14:05.530 --> 00:14:07.080
And we'll say,
OK, because you're

00:14:07.080 --> 00:14:09.550
saying that x is supposed to
be a list of maps from string

00:14:09.550 --> 00:14:11.290
to ints, this is
clearly going to be

00:14:11.290 --> 00:14:13.490
a list of maps from
string to ints,

00:14:13.490 --> 00:14:15.610
and this map is going to
be a string to int thing.

00:14:15.610 --> 00:14:17.970
So statically, we
figure this out,

00:14:17.970 --> 00:14:19.870
and then we set that
type in runtime.

00:14:19.870 --> 00:14:21.640
And now any checks
later on, if you

00:14:21.640 --> 00:14:25.100
were to add something which was
not a map from string to ints,

00:14:25.100 --> 00:14:28.760
we could give you a
runtime check mode error.

00:14:28.760 --> 00:14:31.530
Similarly, if you
override a method-- here

00:14:31.530 --> 00:14:33.620
we have animal, which is
overriding the two string

00:14:33.620 --> 00:14:36.660
method-- and you leave off
one of the types, we'll say,

00:14:36.660 --> 00:14:40.780
OK, the superclass already
declared this method

00:14:40.780 --> 00:14:44.730
with a type so we will
infer a type for you.

00:14:44.730 --> 00:14:55.000
Even more interesting, if we
have a big composite expression

00:14:55.000 --> 00:14:59.700
like this, we can push types
all the way through this

00:14:59.700 --> 00:15:01.720
to get lots of interesting
type information.

00:15:01.720 --> 00:15:03.660
Which is just super
useful, and I'll give you

00:15:03.660 --> 00:15:05.100
an example of this in a minute.

00:15:05.100 --> 00:15:07.007
So here we can come
along, we can say, look,

00:15:07.007 --> 00:15:08.590
this is the list,
you put a cat in it.

00:15:08.590 --> 00:15:10.300
We'll infer that this
is a list of cat.

00:15:10.300 --> 00:15:13.430
That means that, well,
the parameter to map

00:15:13.430 --> 00:15:16.890
is going to be cat, because
I'm coming from a list of cats.

00:15:16.890 --> 00:15:19.840
And that means that the
things that I'm returning here

00:15:19.840 --> 00:15:23.020
from c.owner are
people, and that

00:15:23.020 --> 00:15:25.490
means that this variable is
going to be a list of person.

00:15:25.490 --> 00:15:28.140
I can infer all
that for you, and I

00:15:28.140 --> 00:15:31.670
can give you error messages
and completions based on that.

00:15:31.670 --> 00:15:35.450
So the goal is to be sound
but still very terse.

00:15:35.450 --> 00:15:37.684
So we really wanted to
keep the Darty feel,

00:15:37.684 --> 00:15:39.350
and we really wanted
to keep the ability

00:15:39.350 --> 00:15:45.100
to write code that had all
the nice things about Dart

00:15:45.100 --> 00:15:46.910
but still was sound.

00:15:46.910 --> 00:15:49.397
And I think so far I've
been really happy with how

00:15:49.397 --> 00:15:50.230
this has worked out.

00:15:50.230 --> 00:15:52.046
We have a very
large corpus of code

00:15:52.046 --> 00:15:53.670
that has been converted
to strong mode,

00:15:53.670 --> 00:15:55.350
and it's actually
really pleasing

00:15:55.350 --> 00:15:59.080
how small the changes are
in a lot of the cases.

00:15:59.080 --> 00:16:01.330
And that's actually been
hugely valuable for us

00:16:01.330 --> 00:16:03.600
as people designing
this type system

00:16:03.600 --> 00:16:05.330
is that we have a
huge amount of code

00:16:05.330 --> 00:16:08.080
to learn about what
actually matters.

00:16:08.080 --> 00:16:10.110
And one of the
reasons I really like

00:16:10.110 --> 00:16:12.190
that is that that's
allowed us to stay very

00:16:12.190 --> 00:16:14.360
simple with our type inference.

00:16:14.360 --> 00:16:17.830
We've very deliberately
chosen to stay

00:16:17.830 --> 00:16:21.730
in the subset that is
very fast to compute

00:16:21.730 --> 00:16:23.110
and is very predictable.

00:16:23.110 --> 00:16:26.850
Doesn't tend to have the sort
of spooky action at a distance

00:16:26.850 --> 00:16:29.910
that you get sometimes with
stronger type and inference

00:16:29.910 --> 00:16:31.390
algorithms.

00:16:31.390 --> 00:16:34.490
But we can still cover most of
the common cases that actually

00:16:34.490 --> 00:16:35.950
matter in practice
just by looking

00:16:35.950 --> 00:16:38.580
at a little regional
piece of code.

00:16:38.580 --> 00:16:42.050
So this is super exciting, and
we're still improving on this.

00:16:42.050 --> 00:16:44.410
I think it's really cool.

00:16:44.410 --> 00:16:47.020
So I wanted to show you
this actually in action.

00:16:47.020 --> 00:16:51.590
Because I think it's really nice
to see how this is integrated

00:16:51.590 --> 00:16:53.000
into the tool system.

00:16:53.000 --> 00:16:56.817
So what's that?

00:16:56.817 --> 00:16:58.150
AUDIENCE: Can you zoom in a bit?

00:16:58.150 --> 00:16:59.191
LEAF PETERSON: I can try.

00:17:03.270 --> 00:17:04.006
Let me try.

00:17:10.599 --> 00:17:12.700
How are we looking there?

00:17:12.700 --> 00:17:14.000
Yeah, that's getting better.

00:17:14.000 --> 00:17:17.280
OK, so let's work with that.

00:17:17.280 --> 00:17:22.560
So here's a simple
hierarchy of types here.

00:17:22.560 --> 00:17:25.150
We have people with
a name, we have

00:17:25.150 --> 00:17:27.180
an animal with an owner,
which is a person,

00:17:27.180 --> 00:17:29.840
and we have cats and
dogs extending animals.

00:17:29.840 --> 00:17:32.874
And now I want to do a
few things with my cats,

00:17:32.874 --> 00:17:33.790
and dogs, and animals.

00:17:33.790 --> 00:17:36.610
So if I start out
with strong mode off,

00:17:36.610 --> 00:17:40.490
there's actually no errors
in this code right now.

00:17:40.490 --> 00:17:44.710
Let me get us back in to
restart our analysis here.

00:17:44.710 --> 00:17:47.900
So there are no
errors in this code.

00:17:47.900 --> 00:17:51.670
And if I come along here, so
this is my example from before.

00:17:51.670 --> 00:17:54.680
I'm making a list of cats,
and I'm mapping over it.

00:17:54.680 --> 00:17:57.910
And now I want to
put a lambda in here.

00:17:57.910 --> 00:17:59.590
So one thing that you
can see right away

00:17:59.590 --> 00:18:03.580
is that if I try to get a
completion on this variable c,

00:18:03.580 --> 00:18:05.220
I'm not going to
get any suggestions

00:18:05.220 --> 00:18:07.350
other than the
things on the object.

00:18:07.350 --> 00:18:10.230
And the reason for
that is that if you

00:18:10.230 --> 00:18:18.020
look at what the analyzer
thinks about map, all it knows

00:18:18.020 --> 00:18:20.270
is that it takes a closure
from dynamic to dynamic.

00:18:20.270 --> 00:18:23.370
So all it knows about
c is that it's dynamic.

00:18:23.370 --> 00:18:28.070
So I might make a guess
as to what I want here.

00:18:28.070 --> 00:18:30.301
That looks right to me.

00:18:33.910 --> 00:18:36.870
And I don't get any
complaints here,

00:18:36.870 --> 00:18:40.530
and I still don't get any
useful completions out

00:18:40.530 --> 00:18:44.390
on the other end either,
which is kind of a bummer.

00:18:44.390 --> 00:18:49.870
But fortunately, it's
very easy to fix this.

00:18:49.870 --> 00:18:52.520
So if I enable strong
mode, and I come in here,

00:18:52.520 --> 00:18:56.150
and I reanalyze my code, voila.

00:18:56.150 --> 00:19:02.200
I get a nice error message
telling me in very small print

00:19:02.200 --> 00:19:06.362
that monkey boy is not
defined for the class cat.

00:19:06.362 --> 00:19:07.570
So that's really pretty cool.

00:19:07.570 --> 00:19:09.236
And you can actually
poke around in here

00:19:09.236 --> 00:19:12.050
and see all the pieces of how
this is getting figured out.

00:19:12.050 --> 00:19:15.050
So if I go up to here to
owner, in the regular Dart

00:19:15.050 --> 00:19:18.520
this is declaring a variable
field, which is dynamic.

00:19:18.520 --> 00:19:22.190
I can look at this now and I
can see that actually we've

00:19:22.190 --> 00:19:24.320
inferred a type here for person.

00:19:24.320 --> 00:19:33.930
And using that, when we come
down here and fix this code--

00:19:33.930 --> 00:19:42.460
so if I look at c here, I can
get completions for owner here.

00:19:42.460 --> 00:19:50.830
And the reason is that when
I look at the type of map,

00:19:50.830 --> 00:19:53.460
the analyzer has been
able to figure out

00:19:53.460 --> 00:19:57.060
that this is expecting a
function from cat to person

00:19:57.060 --> 00:19:59.590
now, and it's going to
return an iterable of person.

00:19:59.590 --> 00:20:01.070
So again, using
that same process

00:20:01.070 --> 00:20:02.710
of starting at the
list, and saying,

00:20:02.710 --> 00:20:04.760
OK, this is a list of
cats, pushing that types

00:20:04.760 --> 00:20:05.617
all the way down.

00:20:05.617 --> 00:20:07.700
We're able to get types
all the way through there.

00:20:07.700 --> 00:20:10.050
And now if I come out
to the other end here,

00:20:10.050 --> 00:20:12.680
I can actually now get
completions for name,

00:20:12.680 --> 00:20:14.050
for example, as well.

00:20:14.050 --> 00:20:15.611
All using type inference.

00:20:24.520 --> 00:20:26.030
It's super cool to
see it in action,

00:20:26.030 --> 00:20:29.260
and I'm really excited to see
more integration into the IDs.

00:20:29.260 --> 00:20:31.830
I think we can get a
lot of benefits here.

00:20:31.830 --> 00:20:33.760
I want to show one
more small demo.

00:20:33.760 --> 00:20:37.770
I really like this one because
this is an example of stuff

00:20:37.770 --> 00:20:41.770
where even code that
is very well tested

00:20:41.770 --> 00:20:44.470
can have latent bugs in
it that you wouldn't catch

00:20:44.470 --> 00:20:46.830
without something
like strong mode

00:20:46.830 --> 00:20:48.810
so this is a similar
hierarchy here.

00:20:48.810 --> 00:20:52.240
I have animals,
cats and dogs, and I

00:20:52.240 --> 00:20:55.120
have some API, which returns
an interval of animal.

00:20:55.120 --> 00:20:57.760
And the interesting thing
here is that in practice it

00:20:57.760 --> 00:21:00.890
actually returns a list.

00:21:00.890 --> 00:21:04.340
But its contract just says
that it returns an iterable.

00:21:04.340 --> 00:21:08.020
Now, unfortunately this
is right on the line here,

00:21:08.020 --> 00:21:10.050
but if you write code
that calls this API

00:21:10.050 --> 00:21:13.250
and then call the add method
on the thing you get back,

00:21:13.250 --> 00:21:15.840
you're not going to get any
errors in the regular analyzer.

00:21:15.840 --> 00:21:17.000
And you're also
not actually going

00:21:17.000 --> 00:21:19.583
to get any errors in your code,
even if you test it very well.

00:21:19.583 --> 00:21:24.500
Because in fact, this API
satisfies a stronger contract

00:21:24.500 --> 00:21:26.420
than what it declares,
and you are now

00:21:26.420 --> 00:21:28.020
relying on that contract.

00:21:28.020 --> 00:21:30.320
So you are more tightly
coupled to this code

00:21:30.320 --> 00:21:32.380
than you may have intended.

00:21:32.380 --> 00:21:34.170
And we actually found
these latent bugs

00:21:34.170 --> 00:21:36.330
when we were converting
code to strong mode.

00:21:36.330 --> 00:21:42.386
If you go over here and
you re-enable strong mode,

00:21:42.386 --> 00:21:44.840
you will actually
get an error saying,

00:21:44.840 --> 00:21:49.090
hey, you said that my
animals return an iterable,

00:21:49.090 --> 00:21:51.670
and you're trying
to use it as a list.

00:21:51.670 --> 00:21:54.610
You might want to fix that.

00:21:54.610 --> 00:21:56.560
I was really
excited to see that.

00:21:56.560 --> 00:22:06.030
You can play with us now in
IntelliJ, you can use DartPad.

00:22:06.030 --> 00:22:09.580
You can just turn on strong mode
with a little button down here.

00:22:09.580 --> 00:22:13.520
I don't know if any of the
other stuff that's out there-- I

00:22:13.520 --> 00:22:15.240
saw someone using a
visual code thing,

00:22:15.240 --> 00:22:17.180
I don't know if
you can use that.

00:22:17.180 --> 00:22:19.427
Oh, awesome, that's
what I like to hear.

00:22:19.427 --> 00:22:20.843
AUDIENCE: And also,
the CLI looks,

00:22:20.843 --> 00:22:23.634
you [INAUDIBLE] these options,
[INAUDIBLE] analyze it.

00:22:23.634 --> 00:22:24.800
LEAF PETERSON: That's right.

00:22:24.800 --> 00:22:28.690
So certainly if you use the Dart
analyzer from the command line,

00:22:28.690 --> 00:22:31.650
you just pass --strong,
and you're good to go.

00:22:35.940 --> 00:22:38.920
So I pulled a little bit
of a fast one on you there.

00:22:38.920 --> 00:22:41.040
If you're looking
closely, there's

00:22:41.040 --> 00:22:42.690
some funky stuff going on here.

00:22:42.690 --> 00:22:45.590
What's this parameter to map?

00:22:45.590 --> 00:22:48.070
So one of the things that
was missing from Dart when

00:22:48.070 --> 00:22:50.680
we tried to go to
implement strong mode

00:22:50.680 --> 00:22:52.840
was generic methods.

00:22:52.840 --> 00:22:54.820
And that's actually
really important

00:22:54.820 --> 00:22:58.610
if you want to track
types around reliably.

00:22:58.610 --> 00:23:02.514
Because otherwise your
functions like map,

00:23:02.514 --> 00:23:05.680
they lose type information as
soon as you flow into them.

00:23:05.680 --> 00:23:08.250
So any time you add composite
expressions like this,

00:23:08.250 --> 00:23:10.970
you tended to lose
all of your types.

00:23:10.970 --> 00:23:14.850
So generic methods were
added to strong mode first.

00:23:14.850 --> 00:23:16.980
So I should have
put this one up.

00:23:16.980 --> 00:23:22.517
Here's the regular definition
of the iterable class.

00:23:22.517 --> 00:23:24.850
This isn't quite how it's
defined, but you get the idea.

00:23:24.850 --> 00:23:26.970
It returns an iterable,
it takes in a function

00:23:26.970 --> 00:23:28.430
which just returns dynamic.

00:23:28.430 --> 00:23:33.270
In strong mode, we added via
comment syntax generic methods

00:23:33.270 --> 00:23:36.180
so that you could
declare this as having

00:23:36.180 --> 00:23:38.070
the kind of expected
generic type

00:23:38.070 --> 00:23:40.210
where you tell it
the return type

00:23:40.210 --> 00:23:44.450
and get back out an iterable
of the appropriate type.

00:23:44.450 --> 00:23:47.020
And with type inference we
could basically insert this,

00:23:47.020 --> 00:23:49.630
and you didn't even really
have to change the way you're

00:23:49.630 --> 00:23:50.765
using it most of the time.

00:23:55.740 --> 00:23:59.120
Comment syntax, bad.

00:23:59.120 --> 00:24:00.980
So I'm very happy
to say that we're

00:24:00.980 --> 00:24:04.480
very close to being able to
fully enable the full syntax.

00:24:04.480 --> 00:24:06.480
We're putting generic
methods into the language.

00:24:12.094 --> 00:24:14.960
So people have been hard
at work integrating this

00:24:14.960 --> 00:24:17.180
so that your code will
work with regular mode

00:24:17.180 --> 00:24:18.980
or with strong mode.

00:24:18.980 --> 00:24:21.520
And I'm really happy
to see this happening.

00:24:21.520 --> 00:24:24.450
It's a thing.

00:24:24.450 --> 00:24:27.770
So just a brief mention of
some stuff that's coming.

00:24:27.770 --> 00:24:29.850
We're still working really
hard in strong mode,

00:24:29.850 --> 00:24:31.200
trying to make it better.

00:24:31.200 --> 00:24:34.250
Taking feedback from
people and looking at code.

00:24:34.250 --> 00:24:35.690
There are some
knobs we're adding,

00:24:35.690 --> 00:24:38.734
and we're going to keep
experimenting, seeing what

00:24:38.734 --> 00:24:40.400
are the best ways to
tighten the system,

00:24:40.400 --> 00:24:45.020
or maybe to support
more dynamic-y code?

00:24:45.020 --> 00:24:47.290
So we're still
working on that stuff.

00:24:47.290 --> 00:24:48.730
Generic methods are coming.

00:24:48.730 --> 00:24:51.230
We've been experimenting with
supporting covariant override.

00:24:51.230 --> 00:24:54.070
So I gave you that example
of the cat chasing a mouse,

00:24:54.070 --> 00:24:56.060
and said, that's bad code.

00:24:56.060 --> 00:24:58.320
But there's actually
some very valid use cases

00:24:58.320 --> 00:24:59.270
for code like that.

00:24:59.270 --> 00:25:02.330
And so we'd like to try and
find a way to make that work,

00:25:02.330 --> 00:25:03.770
and were experimenting
with that.

00:25:03.770 --> 00:25:07.890
We also have some
non-nullability experiments.

00:25:07.890 --> 00:25:09.150
Yeah.

00:25:09.150 --> 00:25:10.720
Love to see this
happen, we hope we

00:25:10.720 --> 00:25:15.610
can make this integrate nicely
into a nice Darty language.

00:25:15.610 --> 00:25:18.350
So this is the thing.

00:25:18.350 --> 00:25:19.390
It really is a thing.

00:25:19.390 --> 00:25:21.090
So this is really
widely used in Google.

00:25:21.090 --> 00:25:24.730
We have a lot of people
converting code to strong mode.

00:25:24.730 --> 00:25:26.600
It's growing very
rapidly rapidly.

00:25:26.600 --> 00:25:28.740
We're moving packages
externally to strong mode,

00:25:28.740 --> 00:25:32.190
and we really encourage you
to make new code strong mode

00:25:32.190 --> 00:25:33.050
clean.

00:25:33.050 --> 00:25:35.220
I think it will make
your lives better,

00:25:35.220 --> 00:25:38.880
both in terms of the tooling
that we can provide for you

00:25:38.880 --> 00:25:43.227
using strong mode to
bootstrap, but also I

00:25:43.227 --> 00:25:44.810
think it'll just
make your life better

00:25:44.810 --> 00:25:46.712
in general just
giving you a better

00:25:46.712 --> 00:25:47.920
experience with the language.

00:25:47.920 --> 00:25:52.450
So give it a try.

00:25:52.450 --> 00:25:55.150
[APPLAUSE]

00:25:55.150 --> 00:25:57.000
Thank you.

