WEBVTT
Kind: captions
Language: en

00:00:03.260 --> 00:00:03.590
ARVIND JAIN: All right.

00:00:03.590 --> 00:00:04.850
Welcome everyone.

00:00:04.850 --> 00:00:07.780
My name is Arvind Jain, and I
have Satish Kamabala here with

00:00:07.780 --> 00:00:12.000
me, with a first look at Google
on making the web fast.

00:00:12.000 --> 00:00:16.440
And we're very excited to be
here today to talk about how

00:00:16.440 --> 00:00:22.800
to measure the speed of your
websites in the real world.

00:00:22.800 --> 00:00:29.015
So, before we start, why should
we measure the speed of

00:00:29.015 --> 00:00:32.240
our websites in the
first place?

00:00:32.240 --> 00:00:35.430
The answer, to me, is obvious.

00:00:35.430 --> 00:00:37.800
I don't like to visit
slow websites.

00:00:37.800 --> 00:00:41.230
I like to shop from responsive
and fast websites.

00:00:41.230 --> 00:00:44.000
I like to read news, rather
than waiting for the news

00:00:44.000 --> 00:00:45.070
piece to appear.

00:00:45.070 --> 00:00:47.660
And I'm sure you're
all like me.

00:00:47.660 --> 00:00:51.810
Nobody likes loading
slow web pages.

00:00:51.810 --> 00:00:55.130
At Google, we actually
went a bit further.

00:00:55.130 --> 00:00:58.550
We ran an experiment to
understand the relationship

00:00:58.550 --> 00:01:03.150
between speed of our service
and its usage.

00:01:03.150 --> 00:01:08.000
So in this experiment what we
did was we inserted an extra

00:01:08.000 --> 00:01:12.700
delay in serving our search
results to our users.

00:01:12.700 --> 00:01:15.750
And then waited to see, does
it actually impact usage?

00:01:15.750 --> 00:01:18.910
Are the users using our
service more, or less?

00:01:18.910 --> 00:01:21.550
And the answer was actually
very clear.

00:01:21.550 --> 00:01:25.590
We saw a significant drop in
the usage of Google search,

00:01:25.590 --> 00:01:29.630
even after adding a delay as
little as a few hundred

00:01:29.630 --> 00:01:31.650
milliseconds.

00:01:31.650 --> 00:01:35.700
And I think that applies to all
the websites out there.

00:01:35.700 --> 00:01:40.970
A slow website results in lower
usage, less revenue, and

00:01:40.970 --> 00:01:43.940
obviously poor user
experience.

00:01:43.940 --> 00:01:49.370
So we all need to make sure that
all websites are fast and

00:01:49.370 --> 00:01:51.640
responsive to our users.

00:01:51.640 --> 00:01:54.210
Of course, you can't make things
faster if you don't

00:01:54.210 --> 00:01:55.250
know how to measure it.

00:01:55.250 --> 00:01:57.150
So tat's the topic of
our talk today.

00:01:57.150 --> 00:01:58.890
How do you measure
the speed of a

00:01:58.890 --> 00:02:03.090
website in the real world?

00:02:03.090 --> 00:02:06.560
So we will talk about
three things today.

00:02:06.560 --> 00:02:10.830
We'll start with talking about
HTML web timing standard,

00:02:10.830 --> 00:02:14.910
which makes speed measurement
a web standard.

00:02:14.910 --> 00:02:19.540
After that we'll talk about how
Google Analytics uses the

00:02:19.540 --> 00:02:24.580
HTML5 web timing standard and
its Site Speed feature to make

00:02:24.580 --> 00:02:28.320
real world speed data available
to its publishers.

00:02:28.320 --> 00:02:31.340
And finally, based on that data
that we collect in Google

00:02:31.340 --> 00:02:35.180
Analytics, we want to share some
statistics on how fast

00:02:35.180 --> 00:02:36.510
the internet today is.

00:02:40.170 --> 00:02:41.890
All right.

00:02:41.890 --> 00:02:44.360
So HTML5 web timing API.

00:02:44.360 --> 00:02:50.350
This is a new standard which
we're working on in the W3C.

00:02:50.350 --> 00:02:53.020
Google and a bunch of other
companies are involved in

00:02:53.020 --> 00:02:55.960
standardizing this
as we speak.

00:02:55.960 --> 00:03:00.230
Until very recently, it was not
possible for us to measure

00:03:00.230 --> 00:03:03.650
the end-to-end user-perceived
time it takes

00:03:03.650 --> 00:03:05.210
to load a web page.

00:03:05.210 --> 00:03:08.460
It was just not possible,
because a lot of time is

00:03:08.460 --> 00:03:12.650
actually taken in doing things
like establishing a DNS

00:03:12.650 --> 00:03:16.970
connection to your website,
connecting to the website,

00:03:16.970 --> 00:03:19.210
sending a request for the
web page, and then

00:03:19.210 --> 00:03:21.060
start getting a response.

00:03:21.060 --> 00:03:24.110
And the JavaScript actually
has no clue of all of this

00:03:24.110 --> 00:03:26.210
time, where this
is being spent.

00:03:26.210 --> 00:03:29.200
So this standard actually allows
us to collect that

00:03:29.200 --> 00:03:33.450
end-to-end time that it takes
to load a web page.

00:03:33.450 --> 00:03:37.100
And you can do this from any
browser, irrespective of what

00:03:37.100 --> 00:03:38.490
device you're on.

00:03:38.490 --> 00:03:41.570
Whether you're on a mobile
phone, or whether you're on a

00:03:41.570 --> 00:03:44.790
laptop, or a notebook,
it doesn't matter.

00:03:44.790 --> 00:03:47.830
All browsers that support this
standard will allow you to

00:03:47.830 --> 00:03:51.470
collect speed data in
a consistent manner.

00:03:55.118 --> 00:03:59.310
The specification consists of
three different standards.

00:03:59.310 --> 00:04:03.650
Navigation timing, resource
timing, and user timing.

00:04:03.650 --> 00:04:07.040
Before I go into the details
of this, first let's take a

00:04:07.040 --> 00:04:11.920
look at what happens when you
load a web page in a browser.

00:04:11.920 --> 00:04:16.190
So in this waterfall
view we're loading

00:04:16.190 --> 00:04:17.839
the YouTube's homepage.

00:04:17.839 --> 00:04:21.510
And this figure shows all the
different things that happen

00:04:21.510 --> 00:04:23.030
when you load that web page.

00:04:23.030 --> 00:04:27.230
The very first thing that the
browser does is connect to

00:04:27.230 --> 00:04:30.470
your web server and download
the root web page.

00:04:30.470 --> 00:04:32.870
In this case, the YouTube
homepage.

00:04:32.870 --> 00:04:35.340
Index.html5.

00:04:35.340 --> 00:04:38.810
Once that root page comes
back, the browser

00:04:38.810 --> 00:04:41.810
starts to parse it.

00:04:41.810 --> 00:04:45.800
It executes any scripts that it
finds on the page, and it

00:04:45.800 --> 00:04:49.990
discovers new resources that
are acquired by this page.

00:04:49.990 --> 00:04:51.790
And it will start downloading
them as well.

00:04:51.790 --> 00:04:55.210
And this process continues until
all the scripts on the

00:04:55.210 --> 00:05:00.470
page have been executed and
all the individual HTTP

00:05:00.470 --> 00:05:04.380
objects have been downloaded,
for example images or CSS

00:05:04.380 --> 00:05:05.910
files or scripts.

00:05:05.910 --> 00:05:08.600
And once all of that is done,
that is when the page is

00:05:08.600 --> 00:05:10.880
considered fully loaded.

00:05:10.880 --> 00:05:16.890
In this chart, it's right
at the end of the chart.

00:05:16.890 --> 00:05:19.940
The navigation timing API,
that's the first standard that

00:05:19.940 --> 00:05:23.940
allows you to capture this
end-to-end time, starting from

00:05:23.940 --> 00:05:27.300
when user navigates to
the page to when the

00:05:27.300 --> 00:05:29.660
page is fully loaded.

00:05:29.660 --> 00:05:33.130
In addition, it also gives
you very detailed timing

00:05:33.130 --> 00:05:36.240
statistics for the
root web page.

00:05:36.240 --> 00:05:40.650
For example, how long did it
take to do the DNS resolution

00:05:40.650 --> 00:05:43.630
for youtube.com in
this example?

00:05:43.630 --> 00:05:47.510
How long does it take to
establish the TCP connection

00:05:47.510 --> 00:05:48.890
to the web host?

00:05:48.890 --> 00:05:51.290
And so on and so forth.

00:05:51.290 --> 00:05:54.650
Here is a list of all the
different timing attributes

00:05:54.650 --> 00:06:00.110
that are available to you, via
a simple JavaScript API.

00:06:00.110 --> 00:06:04.700
The list of attributes contains
network level

00:06:04.700 --> 00:06:05.340
attributes.

00:06:05.340 --> 00:06:08.940
For example, how long does it
take to the DNS resolution, or

00:06:08.940 --> 00:06:11.660
how long does it take
to do the TCP

00:06:11.660 --> 00:06:14.200
connection to your web server?

00:06:14.200 --> 00:06:17.540
It also includes HTTP level
attributes, like how long does

00:06:17.540 --> 00:06:19.906
it take to download
the response,

00:06:19.906 --> 00:06:21.970
the actual web response?

00:06:21.970 --> 00:06:24.780
And finally it also contains
document level attributes,

00:06:24.780 --> 00:06:28.580
like how long does it take to
fully render the web page?

00:06:28.580 --> 00:06:31.320
All of these attributes are
available via a single

00:06:31.320 --> 00:06:33.730
JavaScript object, called
window.performance.timing.

00:06:37.250 --> 00:06:41.990
Satish will show us a demo of
navigation timing in action.

00:06:41.990 --> 00:06:44.010
SATISH KAMBALA: Hi all.

00:06:44.010 --> 00:06:46.550
Here I have my Chrome
browser open.

00:06:46.550 --> 00:06:48.770
Like any normal user, I'm
going to a website.

00:06:48.770 --> 00:06:51.340
Let's visit news.com.

00:06:51.340 --> 00:06:53.680
I'm waiting for the
page to be loaded.

00:06:53.680 --> 00:06:55.530
Still loading.

00:06:55.530 --> 00:06:57.930
Now the page load
has completed.

00:06:57.930 --> 00:07:01.950
In this browser, I'm going to
the wrench icon and opening

00:07:01.950 --> 00:07:04.240
JavScript console, by
going to the Tools

00:07:04.240 --> 00:07:07.290
and JavaScript Console.

00:07:07.290 --> 00:07:10.750
So here let's see whether
[? event load ?] is

00:07:10.750 --> 00:07:13.230
available or not.

00:07:13.230 --> 00:07:14.480
Window.performance.timing.

00:07:17.170 --> 00:07:20.530
So you can see this object and
all the attributes that were

00:07:20.530 --> 00:07:22.610
shown in the diagram.

00:07:22.610 --> 00:07:27.260
So just look at some timings
from this object.

00:07:27.260 --> 00:07:28.710
Storing [INAUDIBLE]

00:07:28.710 --> 00:07:30.060
variable.

00:07:30.060 --> 00:07:34.265
So loadEventEnd tells, after the
load has finished, since

00:07:34.265 --> 00:07:36.720
the navigation start.

00:07:36.720 --> 00:07:40.860
And I can see that this page has
taken four seconds, like

00:07:40.860 --> 00:07:43.580
4.3 seconds approximately.

00:07:43.580 --> 00:07:45.540
That's the end of the timing.

00:07:45.540 --> 00:07:49.490
Response and minus
response start.

00:07:49.490 --> 00:07:52.250
So this represents the time for
downloading the HTML from

00:07:52.250 --> 00:07:54.610
the root page, which
is very fast.

00:07:54.610 --> 00:07:56.950
So the main HTML is fast.

00:07:56.950 --> 00:08:04.040
But if you can see the screen
capture, the overall page has

00:08:04.040 --> 00:08:07.530
taken a lot of time
to load this.

00:08:07.530 --> 00:08:10.800
So this data is available for
any website, in all the

00:08:10.800 --> 00:08:14.230
browsers that support navigation
timing API.

00:08:14.230 --> 00:08:17.870
So [INAUDIBLE] for the demo.

00:08:17.870 --> 00:08:19.480
ARVIND JAIN: Thank you Satish.

00:08:19.480 --> 00:08:22.680
So as you can see, navigation
timing allows you to capture

00:08:22.680 --> 00:08:26.920
the end-to-end page load time
for your web page, as well as

00:08:26.920 --> 00:08:30.410
detailed timing stats for
the root page only.

00:08:30.410 --> 00:08:32.270
And it's not that interesting
when you saw in the previous

00:08:32.270 --> 00:08:36.659
example, it took less than 100
milliseconds to load the main

00:08:36.659 --> 00:08:41.870
root page, which is because we
serve YouTube from a location

00:08:41.870 --> 00:08:42.780
close to you always.

00:08:42.780 --> 00:08:43.950
So it doesn't take that
much time to actually

00:08:43.950 --> 00:08:45.070
serve the root page.

00:08:45.070 --> 00:08:49.160
Most of the time is actually
spent in downloading all of

00:08:49.160 --> 00:08:51.060
the resources.

00:08:51.060 --> 00:08:53.920
And this is true for most of
web pages out there today.

00:08:53.920 --> 00:08:59.970
On average, I think web pages
have about 50 or so

00:08:59.970 --> 00:09:02.180
resources per page.

00:09:02.180 --> 00:09:05.820
It's not atypical to have even
more than 100 resources for

00:09:05.820 --> 00:09:07.950
most of the popular web pages.

00:09:07.950 --> 00:09:10.790
And most of the time is actually
spent downloading

00:09:10.790 --> 00:09:13.050
those resources.

00:09:13.050 --> 00:09:16.620
And that's where our second
specifications come into play.

00:09:16.620 --> 00:09:20.040
This is the resource timing
specification.

00:09:20.040 --> 00:09:25.130
This allows you to collect
timing information for every

00:09:25.130 --> 00:09:27.480
individual resource
on the page.

00:09:27.480 --> 00:09:31.920
And just like navigation timing,
you have a variety of

00:09:31.920 --> 00:09:35.220
different attributes available
for every individual resource

00:09:35.220 --> 00:09:36.570
on the page.

00:09:36.570 --> 00:09:41.260
These include network level
timing stats, like time to DNS

00:09:41.260 --> 00:09:45.240
resolve for the particular
resource and the time it took

00:09:45.240 --> 00:09:48.340
to do the PCP connect for the
resource, as well as HTTP

00:09:48.340 --> 00:09:51.480
level attributes like
the time to

00:09:51.480 --> 00:09:53.660
download the actual resource.

00:09:53.660 --> 00:09:57.280
This data is available for every
single resource that's

00:09:57.280 --> 00:09:58.030
on the page.

00:09:58.030 --> 00:10:03.390
It could be an image or a script
or object, iframe, svg.

00:10:03.390 --> 00:10:04.805
All the different
object types.

00:10:07.630 --> 00:10:10.740
And just like navigation timing,
this information is

00:10:10.740 --> 00:10:14.630
available through the
JavaScript API.

00:10:14.630 --> 00:10:19.500
And we'll take a look at an
example to see how that works.

00:10:19.500 --> 00:10:23.070
So in this particular example
what we're going to do is, for

00:10:23.070 --> 00:10:26.980
this given web page, we want
to see how long it takes to

00:10:26.980 --> 00:10:30.760
download every image
on the page.

00:10:30.760 --> 00:10:34.370
So the first thing that we do is
we call this method called

00:10:34.370 --> 00:10:38.670
getEntriesByType on the
window.performance object.

00:10:38.670 --> 00:10:43.680
This gives us a list of all the
individual resources that

00:10:43.680 --> 00:10:44.470
are on the page.

00:10:44.470 --> 00:10:47.300
Well, actually, it gives you
a list of all the resource

00:10:47.300 --> 00:10:52.210
timing objects that the page
has saved for you.

00:10:52.210 --> 00:10:57.750
And next we're going through
that list and checking for the

00:10:57.750 --> 00:11:00.185
resources which are of the
type image, using the

00:11:00.185 --> 00:11:02.590
initiator type field.

00:11:02.590 --> 00:11:07.470
And all we do in this case is
just alert the time it took to

00:11:07.470 --> 00:11:10.330
actually download that resource,
which is the

00:11:10.330 --> 00:11:12.720
difference between
the response and

00:11:12.720 --> 00:11:14.190
the start time attribute.

00:11:17.860 --> 00:11:22.430
So with navigation timing and
resource timing, you can

00:11:22.430 --> 00:11:26.720
capture detailed timing
statistics for the overall web

00:11:26.720 --> 00:11:28.760
page and for all the individual

00:11:28.760 --> 00:11:30.370
resources on the page.

00:11:30.370 --> 00:11:32.760
But as you all know, that
web is changing.

00:11:32.760 --> 00:11:37.350
And [INAUDIBLE], we can't really
think of just resources

00:11:37.350 --> 00:11:39.510
when we want to actually
capture timing.

00:11:39.510 --> 00:11:43.130
Many web pages are
now applications.

00:11:43.130 --> 00:11:49.050
And developers need the ability
to measure the time it

00:11:49.050 --> 00:11:53.140
takes to do logical operations
on their web pages.

00:11:53.140 --> 00:11:56.890
And many times those logical
operations do not necessarily

00:11:56.890 --> 00:12:01.450
correspond to HTTP
level resources.

00:12:01.450 --> 00:12:05.760
And that's where the user
timings API comes into play.

00:12:05.760 --> 00:12:13.410
User timing allows you to
capture the time it takes you

00:12:13.410 --> 00:12:19.890
to do a specific logical
operation on the page.

00:12:19.890 --> 00:12:23.980
It's provides a buffering
mechanism for you to capture

00:12:23.980 --> 00:12:28.220
any arbitrary start point and
end point in the application.

00:12:28.220 --> 00:12:31.840
And on top of that, it also
provides you with a high

00:12:31.840 --> 00:12:35.900
precision timer, which is useful
when you do detail and

00:12:35.900 --> 00:12:38.690
fine grain timing
measurements.

00:12:38.690 --> 00:12:42.120
So collectively, these three
APIs, navigation timing,

00:12:42.120 --> 00:12:46.720
resource timing, and user
timing, they allow you to do

00:12:46.720 --> 00:12:48.855
detailed timing instrumentation
for your web

00:12:48.855 --> 00:12:50.950
pages, and collect this data
from the real world.

00:12:53.750 --> 00:12:55.380
These standards are not
all implemented

00:12:55.380 --> 00:12:57.250
yet, by all the browsers.

00:12:57.250 --> 00:13:01.860
Navigation timing is available
in most modern browsers now,

00:13:01.860 --> 00:13:04.310
and resource timing and user
timing implementations are

00:13:04.310 --> 00:13:06.520
also expected soon.

00:13:06.520 --> 00:13:07.920
So with this we want
to switch gears.

00:13:07.920 --> 00:13:12.095
And now Satish is going to talk
about how we use the web

00:13:12.095 --> 00:13:15.820
timing API in Google Analytics
to provide real world speed

00:13:15.820 --> 00:13:17.910
data to our publishers.

00:13:17.910 --> 00:13:19.430
SATISH KAMBALA: Thanks Arvind.

00:13:19.430 --> 00:13:22.690
So it's great to have all this
data right inside the browser.

00:13:22.690 --> 00:13:27.330
But think about every website
owner changing the website to

00:13:27.330 --> 00:13:29.760
read the data from the browser,
sending it back to

00:13:29.760 --> 00:13:32.660
the servers, processing it,
and seeing the reports.

00:13:32.660 --> 00:13:35.430
Basically, to get a view of the
real world web performance

00:13:35.430 --> 00:13:37.210
is a very tedious process.

00:13:37.210 --> 00:13:39.570
So that's where we offer
a service called Google

00:13:39.570 --> 00:13:42.350
Analytics Site Speed that does
this automatically for you,

00:13:42.350 --> 00:13:46.910
and provides this data without
doing any work.

00:13:46.910 --> 00:13:50.790
So how many of you have used
Google Analytics before?

00:13:50.790 --> 00:13:51.410
OK.

00:13:51.410 --> 00:13:52.390
I think most of you know it.

00:13:52.390 --> 00:13:55.720
So as you know it's a service
that lets you measure the user

00:13:55.720 --> 00:13:56.970
engagement on your website.

00:13:59.300 --> 00:14:03.320
Typically to set up Google
Analytics on your website, you

00:14:03.320 --> 00:14:07.060
get an ID for you, and write
some script to download the

00:14:07.060 --> 00:14:09.720
Analytics script asynchronously,
and add a

00:14:09.720 --> 00:14:10.690
couple of lines.

00:14:10.690 --> 00:14:11.980
They look like this.

00:14:11.980 --> 00:14:16.150
You provide your Analytics ID to
the account, and also call

00:14:16.150 --> 00:14:19.070
trackPageview, which actually
starts collecting user

00:14:19.070 --> 00:14:22.210
engagement information
on your website.

00:14:22.210 --> 00:14:25.520
To get the Site Speed set up,
you don't need to do anything.

00:14:25.520 --> 00:14:27.860
Analytics, by default, collects
speed data for your

00:14:27.860 --> 00:14:29.930
site at one person sampling.

00:14:29.930 --> 00:14:35.510
So if you have a large website,
you can actually get

00:14:35.510 --> 00:14:37.310
a substantial [INAUDIBLE]

00:14:37.310 --> 00:14:40.540
for your site load time with
this sampling percentage.

00:14:40.540 --> 00:14:43.520
But it your site is small, like
if you have 100 or 1,000

00:14:43.520 --> 00:14:48.620
pages per day, we provide an API
to improve the sample rate

00:14:48.620 --> 00:14:50.030
for the speed collection.

00:14:50.030 --> 00:14:52.600
So this API is
setSiteSpeedSampleRate.

00:14:52.600 --> 00:14:55.630
So you should call that API
before calling trackPageview.

00:14:55.630 --> 00:15:00.150
So it collects most
speed data.

00:15:00.150 --> 00:15:03.530
One thing I want to mention here
about the sampling is we

00:15:03.530 --> 00:15:06.000
do the sampling on a visit
by visit basis.

00:15:06.000 --> 00:15:09.420
So if a user comes to your
website, and if he falls in

00:15:09.420 --> 00:15:12.260
the sample, we track speed
data for all the

00:15:12.260 --> 00:15:13.730
pages in that session.

00:15:13.730 --> 00:15:16.170
So that when you go back to
the reports later, you can

00:15:16.170 --> 00:15:18.700
analyze the user behavior on
a session by session basis.

00:15:18.700 --> 00:15:21.700
So we don't sample per page,
we sample on a session by

00:15:21.700 --> 00:15:24.520
session level.

00:15:24.520 --> 00:15:27.340
So before seeing how you can
see all this data, let's go

00:15:27.340 --> 00:15:28.640
back to the diagram that
we saw earlier

00:15:28.640 --> 00:15:30.560
for navigation timing.

00:15:30.560 --> 00:15:34.710
So the top bar here, it shows
the page view process that you

00:15:34.710 --> 00:15:35.800
saw earlier.

00:15:35.800 --> 00:15:40.160
The bottom bar maps those
attributes to the timings that

00:15:40.160 --> 00:15:41.370
you can actually represent.

00:15:41.370 --> 00:15:44.650
So the first thing is the
redirection time.

00:15:44.650 --> 00:15:47.220
So if your page has some
redirections before the final

00:15:47.220 --> 00:15:49.430
landing page is finished,
that is captured in

00:15:49.430 --> 00:15:50.750
the redirection time.

00:15:50.750 --> 00:15:52.870
Mostly, if you're getting a
difference from the search

00:15:52.870 --> 00:15:56.570
engines of other websites, you
can see how fast they're

00:15:56.570 --> 00:16:00.840
sending them to your site
by looking at this time.

00:16:00.840 --> 00:16:03.970
DNS and connection times,
they collect the network

00:16:03.970 --> 00:16:07.470
attributes, as shown in
the navigation timing.

00:16:07.470 --> 00:16:10.700
And the other one, server
response time, this is an

00:16:10.700 --> 00:16:11.990
important metric.

00:16:11.990 --> 00:16:15.835
So this measures the time from
the moment the browser sends a

00:16:15.835 --> 00:16:18.350
request to your backend
since the first byte

00:16:18.350 --> 00:16:19.570
arrives to the browser.

00:16:19.570 --> 00:16:23.330
So it represents the time your
backend takes to respond to

00:16:23.330 --> 00:16:25.080
the user request.

00:16:25.080 --> 00:16:28.460
It also includes the time to the
first byte to the browser.

00:16:28.460 --> 00:16:31.860
So if you want to understand
your backend performance from

00:16:31.860 --> 00:16:35.750
the real world users, you can
actually look at this time.

00:16:35.750 --> 00:16:37.520
And page download time
is the time to

00:16:37.520 --> 00:16:38.750
download the entire content.

00:16:38.750 --> 00:16:41.590
So starting from the first
byte to the last byte.

00:16:41.590 --> 00:16:45.240
So this varies based on your
site content and user

00:16:45.240 --> 00:16:47.750
connection speed.

00:16:47.750 --> 00:16:50.740
Frontend time is the time,
after your root page is

00:16:50.740 --> 00:16:53.600
downloaded, the time the browser
takes to pass the

00:16:53.600 --> 00:16:56.850
HTML, execute the JavaScript,
download any additional

00:16:56.850 --> 00:16:59.860
resources that are there, like
you were seeing earlier, and

00:16:59.860 --> 00:17:01.770
basically render the whole page
and show to the user,

00:17:01.770 --> 00:17:04.000
until the page loads.

00:17:04.000 --> 00:17:07.060
I've basically scaled this
diagram to show the

00:17:07.060 --> 00:17:10.450
significance of these timings,
in general what we saw from

00:17:10.450 --> 00:17:11.520
the data we have.

00:17:11.520 --> 00:17:15.060
But depending upon your site and
based on the user, these

00:17:15.060 --> 00:17:17.910
scalings can vary.

00:17:17.910 --> 00:17:20.710
Let's look at how you can see
all these reports, using a

00:17:20.710 --> 00:17:21.960
demo in Analytics.

00:17:24.319 --> 00:17:27.220
So I have Google
Analytics open.

00:17:27.220 --> 00:17:32.470
The URL is
google.com/analytics/web.

00:17:32.470 --> 00:17:34.660
At the top you can see
several reports.

00:17:34.660 --> 00:17:36.900
So Site Speed reports are
available in the standard

00:17:36.900 --> 00:17:39.540
reporting section.

00:17:39.540 --> 00:17:42.560
Then you go to the content,
and you can see Site Speed

00:17:42.560 --> 00:17:45.900
here, which has all
these reports.

00:17:45.900 --> 00:17:47.380
So it has three reports.

00:17:47.380 --> 00:17:49.140
Overview, page timings,
and user timings.

00:17:49.140 --> 00:17:51.085
Let's look at overview
report now.

00:17:55.270 --> 00:17:58.320
So I am hiding this so that
you can see the full view.

00:17:58.320 --> 00:18:02.020
So Analytics by default shows
data for the past one month.

00:18:02.020 --> 00:18:04.370
So overview report gives a quick
summary of your website

00:18:04.370 --> 00:18:06.480
performance for the
past one month.

00:18:06.480 --> 00:18:08.240
So it shows you all the timings
that I explained

00:18:08.240 --> 00:18:11.495
earlier, starting with average
page load time and all the

00:18:11.495 --> 00:18:15.690
other metrics that we saw.

00:18:15.690 --> 00:18:17.390
You can actually change
this graph to show any

00:18:17.390 --> 00:18:20.880
metric that you want.

00:18:20.880 --> 00:18:24.790
And overview also gives you
shortcuts to see the speed

00:18:24.790 --> 00:18:27.390
data on common dimensions
like browser,

00:18:27.390 --> 00:18:29.570
country, and per page.

00:18:29.570 --> 00:18:33.700
Coming to the page, your website
might have many pages,

00:18:33.700 --> 00:18:36.360
and overall site speed load time
might not give you enough

00:18:36.360 --> 00:18:39.120
insight to improve
your website.

00:18:39.120 --> 00:18:41.470
So that's where page timings
report comes in.

00:18:41.470 --> 00:18:44.925
It lets you look at your speed
data on a page by page basis.

00:18:48.550 --> 00:18:51.060
So the page timings report shows
a graph similar to the

00:18:51.060 --> 00:18:54.640
above, and it also shows
you a table.

00:18:54.640 --> 00:18:57.770
And this table gives you a list
of page load times for

00:18:57.770 --> 00:18:58.890
the top 10 pages.

00:18:58.890 --> 00:19:02.420
So we show the average page
load time on pageviews.

00:19:02.420 --> 00:19:03.520
We just sorted by
the pageviews.

00:19:03.520 --> 00:19:06.430
So we can actually see the top
10 pages for your website and

00:19:06.430 --> 00:19:09.630
see how they're performing
in terms of loading.

00:19:09.630 --> 00:19:11.810
In addition to the page load
time, we also show some

00:19:11.810 --> 00:19:15.090
important metrics, like bounce
rate and percent of exit.

00:19:15.090 --> 00:19:17.580
So these metrics actually
vary from page to page.

00:19:17.580 --> 00:19:19.870
So if your page is taking a
long time, people usually

00:19:19.870 --> 00:19:22.425
abandon before the page loads,
and they actually go to the

00:19:22.425 --> 00:19:22.870
other site.

00:19:22.870 --> 00:19:26.210
So these metrics are important
on a page by page basis.

00:19:26.210 --> 00:19:28.930
We show them alongside the page
load time, so you can get

00:19:28.930 --> 00:19:30.910
a view of how this is affecting
the other metrics.

00:19:36.240 --> 00:19:38.380
So in this analytics
reporting, we

00:19:38.380 --> 00:19:39.780
have three tabs here.

00:19:39.780 --> 00:19:42.030
Explorer, Performance,
and Map Overlay.

00:19:42.030 --> 00:19:44.550
So below the Explorer tab we
have another section called

00:19:44.550 --> 00:19:48.550
Technical, which shows the
other metrics, basically.

00:19:48.550 --> 00:19:51.040
Page load time is the first
metric to see overall.

00:19:51.040 --> 00:19:53.230
And if you are caring about a
specific metric, like server

00:19:53.230 --> 00:19:55.395
response time, you can actually
come to the technical

00:19:55.395 --> 00:19:57.350
section and then see them.

00:19:57.350 --> 00:19:59.490
This is similar to
the site usage.

00:19:59.490 --> 00:20:04.920
It has a graph, and you can
change to any metric.

00:20:04.920 --> 00:20:08.600
And it also gives the table of
pageviews and all the other

00:20:08.600 --> 00:20:09.850
timing metrics.

00:20:13.680 --> 00:20:16.550
So you might be wondering, in
all these reports I've shown

00:20:16.550 --> 00:20:19.560
until now, I'm only showing
average page load time.

00:20:19.560 --> 00:20:22.350
But latency distribution is not
normal distribution, so

00:20:22.350 --> 00:20:23.800
average does not represent
your site

00:20:23.800 --> 00:20:26.170
performance for all users.

00:20:26.170 --> 00:20:30.780
So if you have some users who
are experiencing large page

00:20:30.780 --> 00:20:33.290
load times, that can actually
skew your average and might

00:20:33.290 --> 00:20:35.670
actually give you a wrong
picture of your website load.

00:20:35.670 --> 00:20:38.690
So we do do some
filtering, like

00:20:38.690 --> 00:20:39.650
removing extreme outliers.

00:20:39.650 --> 00:20:41.710
Like more than 10 minutes load
time, if it is there we can

00:20:41.710 --> 00:20:43.520
have it removed from
these calculations.

00:20:43.520 --> 00:20:45.830
But if there are some users who
take one or two minutes,

00:20:45.830 --> 00:20:47.620
that can actually skew
your average.

00:20:47.620 --> 00:20:48.380
So that's where this
Performance

00:20:48.380 --> 00:20:49.630
tab comes into picture.

00:20:52.380 --> 00:20:55.700
So Performance tab shows you the
latency distribution for

00:20:55.700 --> 00:20:58.980
your site, across different
speed buckets.

00:20:58.980 --> 00:21:02.540
So in this diagram I can see
that m latency solution is

00:21:02.540 --> 00:21:05.310
like zero to one second.

00:21:05.310 --> 00:21:09.070
10% of the users are
experiencing less than one

00:21:09.070 --> 00:21:12.620
second page load time,
which is pretty good.

00:21:12.620 --> 00:21:13.960
And 40% of users are
experiencing

00:21:13.960 --> 00:21:14.780
one to three seconds.

00:21:14.780 --> 00:21:17.700
So I can actually see from this,
even though my average

00:21:17.700 --> 00:21:21.770
page load time is 3.3 seconds,
around 80% of the users are

00:21:21.770 --> 00:21:23.550
experiencing latency below
three seconds.

00:21:23.550 --> 00:21:26.500
So I feel pretty confident,
OK, my site is doing OK.

00:21:26.500 --> 00:21:28.000
But there are some users
who are experiencing

00:21:28.000 --> 00:21:29.020
more than one minute.

00:21:29.020 --> 00:21:31.280
So I might want to look at them
and then see whether I

00:21:31.280 --> 00:21:34.270
can do something for them.

00:21:34.270 --> 00:21:38.940
Finally the Map Overlay here
gives you the site performance

00:21:38.940 --> 00:21:40.990
data on a region by
region basis.

00:21:40.990 --> 00:21:42.740
And why is region important?

00:21:42.740 --> 00:21:45.370
Because most of the time you
host your website in one

00:21:45.370 --> 00:21:48.720
region, but you might get users
from different locations

00:21:48.720 --> 00:21:49.740
in the world.

00:21:49.740 --> 00:21:53.200
So you not only want to look at
the user experience based

00:21:53.200 --> 00:21:56.070
on speed buckets, but you want
to see how users in other

00:21:56.070 --> 00:22:00.120
regions are experiencing
your website.

00:22:00.120 --> 00:22:02.890
So here, similar [INAUDIBLE]
reports.

00:22:02.890 --> 00:22:06.650
We show the top 10 countries
that get the pages from you,

00:22:06.650 --> 00:22:10.060
and show the page load time
for those countries.

00:22:10.060 --> 00:22:12.610
And the map gives a quick
summary to say.

00:22:12.610 --> 00:22:14.600
It has a lot of gradients.

00:22:14.600 --> 00:22:18.710
So thick green color kind of
shows that the people in that

00:22:18.710 --> 00:22:20.620
country are experiencing
high latency.

00:22:20.620 --> 00:22:22.620
Light color shows
they are fast.

00:22:26.380 --> 00:22:28.990
So we just went through an
overview of all these reports

00:22:28.990 --> 00:22:30.160
and analytics.

00:22:30.160 --> 00:22:33.840
But I wanted to give an example
of how my friend used

00:22:33.840 --> 00:22:38.070
these reports to see his latency
has changed as he made

00:22:38.070 --> 00:22:39.430
improvements to his website.

00:22:39.430 --> 00:22:41.670
So he's a good blogger.

00:22:41.670 --> 00:22:44.240
And also his [INAUDIBLE], so
he keeps making performance

00:22:44.240 --> 00:22:45.550
improvements to his site.

00:22:45.550 --> 00:22:49.250
And let's see how he has seen
the speed change over time.

00:22:51.770 --> 00:22:53.470
So he had a New Year's
resolution

00:22:53.470 --> 00:22:55.000
to improve his blog.

00:22:55.000 --> 00:22:58.830
So around December end, he kind
of changed his blogging

00:22:58.830 --> 00:23:02.180
provider, posting from one
platform to another platform.

00:23:02.180 --> 00:23:04.990
So here I am comparing
generated data

00:23:04.990 --> 00:23:06.240
compared to the December.

00:23:10.450 --> 00:23:14.595
So the blue lines represent
January, the new provider, and

00:23:14.595 --> 00:23:18.230
the orange lines represent
December.

00:23:18.230 --> 00:23:20.570
So it shows that the average
page load time has increased

00:23:20.570 --> 00:23:22.840
by 25% after this change.

00:23:22.840 --> 00:23:25.330
So in January it shows that
there is a significant

00:23:25.330 --> 00:23:25.720
improvement.

00:23:25.720 --> 00:23:28.850
So we can see that the change
has really worked for him.

00:23:28.850 --> 00:23:31.470
So there is an improvement in
the average page load time.

00:23:31.470 --> 00:23:33.960
Not only that, there is an
improvement in page views.

00:23:33.960 --> 00:23:37.110
Which could be coincidental
or as a result of speed.

00:23:37.110 --> 00:23:41.200
But it's a good thing for him
to change the provider.

00:23:41.200 --> 00:23:43.430
So this is just a change
in the average.

00:23:43.430 --> 00:23:45.100
Let's see how the distribution
has changed.

00:23:48.840 --> 00:23:53.880
So the orange bars, that
is before the change.

00:23:53.880 --> 00:23:56.610
You can see that they're
scattered over one to three

00:23:56.610 --> 00:23:59.640
second buckets, and three
to seven seconds.

00:23:59.640 --> 00:24:01.550
So people are evenly
distributed.

00:24:01.550 --> 00:24:02.720
Some people are even
experiencing

00:24:02.720 --> 00:24:04.200
seven to thirteen seconds.

00:24:04.200 --> 00:24:06.160
But after the change,
that color has

00:24:06.160 --> 00:24:07.740
shifted to the left side.

00:24:07.740 --> 00:24:10.790
Most of the users are now seeing
zero to one seconds,

00:24:10.790 --> 00:24:12.220
one to three second buckets.

00:24:12.220 --> 00:24:13.800
And some users are still
in the three to

00:24:13.800 --> 00:24:14.370
seven bucket range.

00:24:14.370 --> 00:24:17.590
So this gives me an idea, OK,
not that the average has

00:24:17.590 --> 00:24:21.460
improved, but most of the users
also have shifted to the

00:24:21.460 --> 00:24:24.200
speed of the buckets.

00:24:24.200 --> 00:24:26.910
So one thing is his old hosting
provider used to

00:24:26.910 --> 00:24:28.610
generate the web pages
dynamically.

00:24:28.610 --> 00:24:30.830
So there's a database created
that is happening when

00:24:30.830 --> 00:24:32.470
somebody goes to his website.

00:24:32.470 --> 00:24:34.870
And the new provider actually
recalculates them and then

00:24:34.870 --> 00:24:36.690
stores those images
statically.

00:24:36.690 --> 00:24:39.340
So because this is related to
the backend time, let's see

00:24:39.340 --> 00:24:41.110
how the server response
time has changed.

00:24:44.160 --> 00:24:46.590
So if you look at the orange
bars, which is the old hosting

00:24:46.590 --> 00:24:50.150
provider, he's generating
the pages dynamically.

00:24:50.150 --> 00:24:51.930
His distribution is bimodal.

00:24:51.930 --> 00:24:55.750
So there is a set of users in
the 0.1 to 0.5 seconds, and

00:24:55.750 --> 00:24:57.210
there is another set
of users in the one

00:24:57.210 --> 00:24:58.570
to two second bucket.

00:24:58.570 --> 00:25:01.360
So this can be explained by
saying if the queries in the

00:25:01.360 --> 00:25:03.970
backend are actually cached,
they are getting the pages

00:25:03.970 --> 00:25:06.285
faster and they're falling
in this bucket, 0.1

00:25:06.285 --> 00:25:08.380
to 0.5 second buckets.

00:25:08.380 --> 00:25:10.720
Or if the query is not cached,
they're actually falling into

00:25:10.720 --> 00:25:12.600
the second bucket.

00:25:12.600 --> 00:25:15.110
After his shift, because
the pages are generated

00:25:15.110 --> 00:25:18.230
statically, they are moved
to the faster buckets.

00:25:18.230 --> 00:25:20.540
So that can be seen in
this distribution.

00:25:20.540 --> 00:25:23.780
So these reports actually help
you understand how these

00:25:23.780 --> 00:25:26.180
changes are happening as you
make site improvements.

00:25:35.660 --> 00:25:38.420
One interesting thing, if you
see here in January the first

00:25:38.420 --> 00:25:42.400
half of the month he's seen
varying page load times.

00:25:42.400 --> 00:25:45.835
So he did some investigation,
and he found that in the Asian

00:25:45.835 --> 00:25:46.950
region the [INAUDIBLE]

00:25:46.950 --> 00:25:49.360
was erratic and it
was timing out.

00:25:49.360 --> 00:25:50.990
That caused actually
this increase.

00:25:50.990 --> 00:25:53.210
So he put another to do
to fix the social

00:25:53.210 --> 00:25:54.580
widgets on his blog.

00:25:54.580 --> 00:25:57.090
So he told me that he has
fixed it recently.

00:25:57.090 --> 00:26:02.190
So let's see whether that
made a difference.

00:26:02.190 --> 00:26:05.840
And seeing the data
from May to June,

00:26:05.840 --> 00:26:07.980
average page load time.

00:26:07.980 --> 00:26:10.510
There is an annotation
that he added.

00:26:10.510 --> 00:26:14.390
So he tells me that on May 25th
he changed his site such

00:26:14.390 --> 00:26:17.250
that he preferred the loading
of all social widgets on his

00:26:17.250 --> 00:26:20.250
page to happen after that
page actually loads.

00:26:20.250 --> 00:26:24.360
So as you can see, after this
the average page load time is

00:26:24.360 --> 00:26:26.920
hovering from two the
three seconds.

00:26:26.920 --> 00:26:28.940
Compared to eight to nine
seconds, which is a big

00:26:28.940 --> 00:26:29.440
improvement.

00:26:29.440 --> 00:26:32.745
So you can observe all these
improvements in these reports.

00:26:37.050 --> 00:26:38.410
Let's get back to the slides.

00:26:38.410 --> 00:26:41.230
So this is just a summary of
what we have seen so far.

00:26:41.230 --> 00:26:45.570
You have an overview report,
page timings, there is a

00:26:45.570 --> 00:26:51.670
technical section, the
histograms, map overlay.

00:26:51.670 --> 00:26:54.760
So page timings and over report
gives you by default,

00:26:54.760 --> 00:26:58.200
without doing any work, your
site page load latency.

00:26:58.200 --> 00:27:02.000
But as you learned earlier, most
of the user interaction

00:27:02.000 --> 00:27:03.460
happens after the page loads.

00:27:03.460 --> 00:27:07.180
Because nowadays the websites
are complex and they're mostly

00:27:07.180 --> 00:27:09.910
behaving like applications, you
want to measure the time

00:27:09.910 --> 00:27:11.580
after the page actually loads.

00:27:11.580 --> 00:27:14.170
That's where user
timing comes in.

00:27:14.170 --> 00:27:17.600
It lets you define user defined
custom timings.

00:27:17.600 --> 00:27:20.940
You can define any action of
what you want in your website,

00:27:20.940 --> 00:27:23.010
and measure the timing
with this.

00:27:23.010 --> 00:27:26.440
So if you have Ajax actions that
are happening, you can

00:27:26.440 --> 00:27:27.920
measure those timings.

00:27:27.920 --> 00:27:31.060
If you want to get detailed
performance measurements, like

00:27:31.060 --> 00:27:32.890
on your page you want to measure
how much time each

00:27:32.890 --> 00:27:35.580
widget is taking to load, or how
much time CSS is taking to

00:27:35.580 --> 00:27:39.290
load, you can do that with the
detailed instrumentation.

00:27:39.290 --> 00:27:42.240
Or if you have a site like a
news website, where they're

00:27:42.240 --> 00:27:44.760
not concerned about the page
load time, but they're

00:27:44.760 --> 00:27:47.000
concerned about how long it
takes to show the main article

00:27:47.000 --> 00:27:51.380
to the user, they'd want user
perceived load time, and then

00:27:51.380 --> 00:27:53.720
start reporting analytics.

00:27:53.720 --> 00:27:57.280
So user timings allows you
to do all of that.

00:27:57.280 --> 00:27:59.820
And the way to do it is using
an API called trackTiming.

00:28:04.260 --> 00:28:07.170
So this API has five
parameters.

00:28:07.170 --> 00:28:08.680
First three of them
are required,

00:28:08.680 --> 00:28:10.800
other two are optional.

00:28:10.800 --> 00:28:11.880
Let's go through one by one.

00:28:11.880 --> 00:28:14.130
So first parameter
is category.

00:28:14.130 --> 00:28:17.320
So what we have noticed is,
even instead of Google, we

00:28:17.320 --> 00:28:19.930
also try to make all
the apps fast.

00:28:19.930 --> 00:28:22.720
What we noticed is most of the
people start instrumenting,

00:28:22.720 --> 00:28:24.945
and then keep adding a lot
of variables and they

00:28:24.945 --> 00:28:26.220
pile up over time.

00:28:26.220 --> 00:28:30.000
So we have made it mandatory to
say specify a category as a

00:28:30.000 --> 00:28:32.790
first parameter, so you can
group your variables into

00:28:32.790 --> 00:28:33.800
separate logical things.

00:28:33.800 --> 00:28:36.910
So for example, if I take a
YouTube website, I can define

00:28:36.910 --> 00:28:39.830
category as watch page,
homepage, search page,

00:28:39.830 --> 00:28:40.970
settings page.

00:28:40.970 --> 00:28:43.030
So at a high level, I can see
which page I am creating a

00:28:43.030 --> 00:28:46.220
report for tracking
the latency.

00:28:46.220 --> 00:28:48.220
The second parameter is a
variable, which is like the

00:28:48.220 --> 00:28:49.990
JavaScript load time
or [INAUDIBLE]

00:28:49.990 --> 00:28:53.290
action load time
kind of thing.

00:28:53.290 --> 00:28:54.490
And this is a time.

00:28:54.490 --> 00:28:56.320
And we provide one millisecond
resolution.

00:28:56.320 --> 00:28:59.460
So you can specify the time to
track timing at a millisecond

00:28:59.460 --> 00:29:00.040
resolution.

00:29:00.040 --> 00:29:03.010
And you can see all of
that in the reports.

00:29:03.010 --> 00:29:05.370
The other two optional
parameters are label and

00:29:05.370 --> 00:29:06.510
sample rate.

00:29:06.510 --> 00:29:09.890
So here a label is any arbitrary
text that you can

00:29:09.890 --> 00:29:13.680
attach to your user
timing data.

00:29:13.680 --> 00:29:17.260
So the way to use labels
is if you're doing some

00:29:17.260 --> 00:29:18.150
experimentation--

00:29:18.150 --> 00:29:20.630
like Google web search does
thousands of experiments every

00:29:20.630 --> 00:29:22.990
day, and I want to see how one
experiment is performing

00:29:22.990 --> 00:29:25.860
against others, or how my
experiment is changing the

00:29:25.860 --> 00:29:27.370
speed data.

00:29:27.370 --> 00:29:30.130
So you can attach your
experiment as a label, and see

00:29:30.130 --> 00:29:31.980
the data for a particular
category and

00:29:31.980 --> 00:29:35.220
variable along them.

00:29:35.220 --> 00:29:37.870
So this is very powerful,
because you don't want to do

00:29:37.870 --> 00:29:39.200
some speed change without
knowing how

00:29:39.200 --> 00:29:40.070
much it actually improves.

00:29:40.070 --> 00:29:42.550
So you can do an experiment and
attach some label and see

00:29:42.550 --> 00:29:45.820
how it performs, and
then make it 100%.

00:29:45.820 --> 00:29:48.040
The sample rate here is similar
to the Site Speed

00:29:48.040 --> 00:29:49.290
sample rate.

00:29:49.290 --> 00:29:53.580
So the reason we provide the
sample rate API is because if

00:29:53.580 --> 00:29:56.310
you send too many hits to the
Google Analytics, when you

00:29:56.310 --> 00:29:58.170
look at them in the reports
they'll take a

00:29:58.170 --> 00:29:59.020
long time to load.

00:29:59.020 --> 00:30:01.670
And they also do some sampling
while generating the reports.

00:30:01.670 --> 00:30:04.460
So if your site is small, you
should definitely increase the

00:30:04.460 --> 00:30:05.300
sample rate.

00:30:05.300 --> 00:30:07.660
But if your site is large, like
more than one million or

00:30:07.660 --> 00:30:12.760
10 million, you should keep it
in the default sample rate.

00:30:12.760 --> 00:30:14.360
Let's see how this track
timing API can be

00:30:14.360 --> 00:30:17.130
used with an example.

00:30:17.130 --> 00:30:20.030
So this example tries to measure
the time to load a

00:30:20.030 --> 00:30:21.050
[INAUDIBLE]

00:30:21.050 --> 00:30:23.330
that is loaded through Ajax.

00:30:23.330 --> 00:30:25.760
So I defined a class
called TimeTracker.

00:30:25.760 --> 00:30:29.330
So I'm using this class as a
helper class that stores the

00:30:29.330 --> 00:30:33.890
category, variable and other
bookkeeping for me.

00:30:33.890 --> 00:30:34.450
[INAUDIBLE]

00:30:34.450 --> 00:30:35.280
class.

00:30:35.280 --> 00:30:39.530
And when I make xhr request,
before I send the request I

00:30:39.530 --> 00:30:41.220
record the start time.

00:30:41.220 --> 00:30:44.380
And after I get the response
and validate that it's a

00:30:44.380 --> 00:30:46.550
success, I measure
the end time.

00:30:46.550 --> 00:30:49.290
And then I kind of send the data
to Google Analytics by

00:30:49.290 --> 00:30:51.420
calling this trackTiming.

00:30:51.420 --> 00:30:56.590
So the main things are you just
record you start time,

00:30:56.590 --> 00:30:58.850
record your end time, and
then just make a call to

00:30:58.850 --> 00:30:59.460
trackTiming.

00:30:59.460 --> 00:31:00.610
That it as simple as it is.

00:31:00.610 --> 00:31:03.570
So it's very simple to do
these user timings using

00:31:03.570 --> 00:31:06.670
trackTiming API, but this
is also very powerful.

00:31:06.670 --> 00:31:09.090
You can use this trackTiming
API to measure any timing.

00:31:09.090 --> 00:31:12.380
For example, you have a web
page, and you want to measure

00:31:12.380 --> 00:31:14.510
how long the user takes
before he interacts

00:31:14.510 --> 00:31:15.670
with your web page.

00:31:15.670 --> 00:31:18.320
So you can measure the time
using this trackTiming API.

00:31:20.980 --> 00:31:23.410
So at this point you may be
wondering, you have user

00:31:23.410 --> 00:31:25.610
timing specification in the
browser, and we have user

00:31:25.610 --> 00:31:27.090
timings in the Google
Analytics.

00:31:27.090 --> 00:31:29.730
How do these two
work together?

00:31:29.730 --> 00:31:31.350
These two actually compliment
each other.

00:31:31.350 --> 00:31:34.240
Because if you notice in this
example, I am creating a class

00:31:34.240 --> 00:31:36.290
called TimeTracker that
is doing a lot of

00:31:36.290 --> 00:31:37.710
bookkeeping for me.

00:31:37.710 --> 00:31:40.060
Storing the category, variable,
recording the start,

00:31:40.060 --> 00:31:41.300
recording the end.

00:31:41.300 --> 00:31:44.020
And if you noticed, user timings
API actually does the

00:31:44.020 --> 00:31:45.320
same thing for you.

00:31:45.320 --> 00:31:48.080
So it provides an API to measure
the start and end

00:31:48.080 --> 00:31:49.950
measures, and [INAUDIBLE]
through them.

00:31:49.950 --> 00:31:52.450
So the advantage of that is you
don't need to pass these

00:31:52.450 --> 00:31:53.260
variables around.

00:31:53.260 --> 00:31:55.410
I don't need to create an object
and pass it around my

00:31:55.410 --> 00:31:59.320
JavaScript code, which kind of
makes the whole code look

00:31:59.320 --> 00:32:01.890
uglier, less variable, because
I'm passing performance

00:32:01.890 --> 00:32:03.290
related data throughout.

00:32:03.290 --> 00:32:06.200
But if you have it in the
browser, at any point in your

00:32:06.200 --> 00:32:08.570
code you can say start
measurement for a particular

00:32:08.570 --> 00:32:11.230
name, variable name, and
[INAUDIBLE] measure, and then

00:32:11.230 --> 00:32:12.980
report it using the
track timing.

00:32:12.980 --> 00:32:16.290
So user timing API can be used
for buffering the data, and

00:32:16.290 --> 00:32:19.020
track timing can be used to send
the data to Analytics.

00:32:19.020 --> 00:32:20.870
So you can make them
work together.

00:32:23.440 --> 00:32:26.070
So I'm not going to demo the
user timings report, because

00:32:26.070 --> 00:32:28.330
it's very similar to
the page timings.

00:32:28.330 --> 00:32:31.370
You have the same three tabs,
Explorer, Performance, and Map

00:32:31.370 --> 00:32:32.770
Overlay tabs.

00:32:32.770 --> 00:32:35.810
And if you see on the bottom,
we have a dimension to slice

00:32:35.810 --> 00:32:37.120
and dice the data by.

00:32:37.120 --> 00:32:41.090
So like I was saying, we provide
several ways to look

00:32:41.090 --> 00:32:42.540
at user timings data.

00:32:42.540 --> 00:32:46.905
We have a category at a high
level, we have a label as a

00:32:46.905 --> 00:32:48.380
tagging mechanism.

00:32:48.380 --> 00:32:51.310
So you can look at a particular
variable data and

00:32:51.310 --> 00:32:53.610
compare how it is doing across
different categories.

00:32:53.610 --> 00:32:56.355
Like how long my social widgets
are taking to load on

00:32:56.355 --> 00:32:58.390
my home page, compared
to watch page.

00:32:58.390 --> 00:33:02.710
Or you can see how a particular
variable is taking

00:33:02.710 --> 00:33:03.430
across different levels.

00:33:03.430 --> 00:33:06.170
You can plug them together and
see which one is better.

00:33:06.170 --> 00:33:08.900
So you can do that powerful
slice and dice using these

00:33:08.900 --> 00:33:10.150
dimensions.

00:33:12.380 --> 00:33:17.020
And in the Performance tab, we
have a single set of buckets

00:33:17.020 --> 00:33:20.250
that are provided for
all the timings.

00:33:20.250 --> 00:33:23.110
These buckets are designed in
such a way that we can measure

00:33:23.110 --> 00:33:25.860
granular timings, like
JavaScript things that usually

00:33:25.860 --> 00:33:27.970
are in the range of 10
milliseconds, things that

00:33:27.970 --> 00:33:29.180
happen on the client side.

00:33:29.180 --> 00:33:31.430
Or you can also measure
large load times that

00:33:31.430 --> 00:33:32.970
take a lot of minutes.

00:33:32.970 --> 00:33:36.170
We provided buckets starting
with 0.1 seconds, until one

00:33:36.170 --> 00:33:39.100
minute or more.

00:33:39.100 --> 00:33:40.950
At the high level, we give
some buckets first.

00:33:40.950 --> 00:33:43.935
But if you want to dig deeper we
provide sub-buckets, so you

00:33:43.935 --> 00:33:45.580
can go expend those buckets
and then see

00:33:45.580 --> 00:33:47.340
how those are varying.

00:33:50.660 --> 00:33:53.950
So until now we have seen how
page timings and user timings

00:33:53.950 --> 00:33:56.720
give you a complete tool set
for measuring your website

00:33:56.720 --> 00:33:58.030
performance.

00:33:58.030 --> 00:34:00.640
But that's not all that Google
Analytics can do for you.

00:34:00.640 --> 00:34:01.890
It can do even more.

00:34:03.910 --> 00:34:05.950
You can create custom reports.

00:34:05.950 --> 00:34:09.199
By custom reports I mean you
can create a table of any

00:34:09.199 --> 00:34:11.825
metric that you care about,
along any dimension that you

00:34:11.825 --> 00:34:13.230
are really interested in.

00:34:13.230 --> 00:34:15.530
For example here, let's take
a look at this table.

00:34:15.530 --> 00:34:17.050
Visitor Caching Info.

00:34:17.050 --> 00:34:19.540
I'm plotting my average
page load time based

00:34:19.540 --> 00:34:20.730
on the visitor type.

00:34:20.730 --> 00:34:22.829
Visitor type is a standard
dimension that is available in

00:34:22.829 --> 00:34:23.989
the Analytics.

00:34:23.989 --> 00:34:27.219
So I can see my returning
visitors are experiencing

00:34:27.219 --> 00:34:29.739
faster pages compared
to new visitors.

00:34:29.739 --> 00:34:32.179
This is obvious because some
of the resources on my page

00:34:32.179 --> 00:34:35.850
might be cached, so they
see faster load times.

00:34:35.850 --> 00:34:40.120
So this way you can actually
plot your latency versus some

00:34:40.120 --> 00:34:43.130
revenue metrics, or some goals
that you're interested in.

00:34:43.130 --> 00:34:45.429
You can create any custom
report that

00:34:45.429 --> 00:34:47.880
you want using Analytics.

00:34:47.880 --> 00:34:49.860
Not only that, you can actually
create dashboards.

00:34:49.860 --> 00:34:51.790
This is a simple dashboard
which has all these four

00:34:51.790 --> 00:34:53.960
tables that I created.

00:34:53.960 --> 00:34:55.909
So these dashboards can be
accessed in the home

00:34:55.909 --> 00:34:57.159
[INAUDIBLE].

00:35:00.960 --> 00:35:02.700
So the standard reporting is
where we saw the reports.

00:35:02.700 --> 00:35:04.860
So the dashboards can be
seen in this home page.

00:35:08.180 --> 00:35:12.025
And then we provide an API to
expose all the data that you

00:35:12.025 --> 00:35:14.080
have seen in the reports
through the API.

00:35:14.080 --> 00:35:16.850
So if you don't like the
reports, you can actually pull

00:35:16.850 --> 00:35:20.240
the data using the API and draw
your own visualizations.

00:35:20.240 --> 00:35:23.500
You can plot whatever you want
in whatever way you want, on

00:35:23.500 --> 00:35:25.090
your web page server,
on your websites.

00:35:25.090 --> 00:35:26.070
You don't need to
come to Google

00:35:26.070 --> 00:35:27.640
Analytics to see this data.

00:35:31.630 --> 00:35:33.020
Another powerful feature
of Google

00:35:33.020 --> 00:35:34.850
Analytics is advanced segments.

00:35:34.850 --> 00:35:38.200
So what advance segments let
you do is see any reporting

00:35:38.200 --> 00:35:41.530
Google Analytics for
a segment of users.

00:35:41.530 --> 00:35:44.170
You can define any segment of
users the way you want.

00:35:44.170 --> 00:35:45.432
You can create the
segments very

00:35:45.432 --> 00:35:48.110
easily, in multiple steps.

00:35:48.110 --> 00:35:51.580
Here I'm again using some
default segments that are

00:35:51.580 --> 00:35:53.050
already created.

00:35:53.050 --> 00:35:55.570
So there is a segment called
search traffic, which shows

00:35:55.570 --> 00:35:58.320
the data for traffic coming
from the search results.

00:35:58.320 --> 00:36:01.360
And I have a direct traffic
segment, which shows data

00:36:01.360 --> 00:36:03.250
people who visit my
site directly.

00:36:03.250 --> 00:36:06.600
And I am seeing the technical
section of all the metrics

00:36:06.600 --> 00:36:08.100
across these two segments.

00:36:08.100 --> 00:36:10.340
You can do this segmenting
across any reports.

00:36:10.340 --> 00:36:14.200
User timing sites, page
timings, or any other

00:36:14.200 --> 00:36:14.810
[INAUDIBLE]

00:36:14.810 --> 00:36:16.060
metrics also.

00:36:18.580 --> 00:36:20.820
And these reports are good.

00:36:20.820 --> 00:36:22.200
You can see all the data.

00:36:22.200 --> 00:36:25.970
But you won't be looking at the
reports 24 hours a day.

00:36:25.970 --> 00:36:29.280
But you are speed-conscious,
and you want to be notified

00:36:29.280 --> 00:36:30.950
when something changes,
something significantly

00:36:30.950 --> 00:36:32.850
changes to your website
performance.

00:36:32.850 --> 00:36:36.020
So that's why Analytics allows
you to set up alerts.

00:36:36.020 --> 00:36:38.620
So you can set alerts to be
notified when something

00:36:38.620 --> 00:36:41.290
happens to your site, and it
automatically sends you email,

00:36:41.290 --> 00:36:42.770
or phone, or SMS,
or something.

00:36:42.770 --> 00:36:44.460
Whatever you said.

00:36:44.460 --> 00:36:46.890
Here there's an example.

00:36:46.890 --> 00:36:50.560
I'm asking you to alert me when
my average page load time

00:36:50.560 --> 00:36:53.930
increases by more than 10%
compared to the same day in

00:36:53.930 --> 00:36:54.810
previous week.

00:36:54.810 --> 00:36:58.050
Because your page view traffic
or page load time, all these

00:36:58.050 --> 00:37:00.180
graphs vary based
on the week day.

00:37:00.180 --> 00:37:02.480
Weekend, you might have more
traffic or less traffic,

00:37:02.480 --> 00:37:03.640
depending on your content.

00:37:03.640 --> 00:37:08.390
So for the same day of the
previous week, if my page load

00:37:08.390 --> 00:37:10.750
time changes by more than
10% I want to be sent

00:37:10.750 --> 00:37:14.010
an email or an SMS.

00:37:14.010 --> 00:37:15.490
This is the result
of the email.

00:37:15.490 --> 00:37:18.410
So it shows me that my average
page load time has

00:37:18.410 --> 00:37:20.600
increased by 67%.

00:37:20.600 --> 00:37:23.640
Not only does it give me an
alert, it also gives me some

00:37:23.640 --> 00:37:25.780
reasons why this alert
could be happening.

00:37:25.780 --> 00:37:27.210
This is, again, based
on the correlation.

00:37:27.210 --> 00:37:30.390
So this may not be the actual
reason, but you can actually

00:37:30.390 --> 00:37:32.520
take this as a starting
point and debug why

00:37:32.520 --> 00:37:33.800
it could have happened.

00:37:33.800 --> 00:37:38.230
So in this case, people from
India, New Delhi city, are

00:37:38.230 --> 00:37:40.000
experiencing high load
times, which caused

00:37:40.000 --> 00:37:41.440
my average to increase.

00:37:41.440 --> 00:37:44.160
So if I have a background in
that region, I can go and see

00:37:44.160 --> 00:37:46.010
if there is a problem
with me set up.

00:37:46.010 --> 00:37:48.080
Or if there's a network already
in that region, I can

00:37:48.080 --> 00:37:51.580
do such kind of analysis.

00:37:51.580 --> 00:37:55.220
So far we have seen how Google
Analytics gives you several

00:37:55.220 --> 00:37:57.800
ways to see your performance
of the website.

00:37:57.800 --> 00:37:59.060
But if you have some apps--

00:37:59.060 --> 00:38:01.660
native apps, like iOS apps
or Android apps--

00:38:01.660 --> 00:38:04.570
there is a good talk that is
tomorrow, to see how Analytics

00:38:04.570 --> 00:38:07.240
helps you measure the end-to-end
value of your apps.

00:38:07.240 --> 00:38:08.140
You should attend that.

00:38:08.140 --> 00:38:10.440
It's at 11:30 tomorrow
morning.

00:38:13.190 --> 00:38:17.390
So measuring your speed is the
first step of improving your

00:38:17.390 --> 00:38:18.800
website speed.

00:38:18.800 --> 00:38:21.290
Because this talk is about
that measurement, I'm not

00:38:21.290 --> 00:38:23.570
going to look into how you can
optimize the websites.

00:38:23.570 --> 00:38:26.940
But I'll give you some pointers
to some tools that I

00:38:26.940 --> 00:38:28.450
frequently use.

00:38:28.450 --> 00:38:32.670
Web page test is nice tool to
see your website performance

00:38:32.670 --> 00:38:33.890
in a lab scenario.

00:38:33.890 --> 00:38:37.380
So you can simulate a user,
using a browser, coming from a

00:38:37.380 --> 00:38:40.160
location, and see how
your page loads.

00:38:40.160 --> 00:38:41.720
It gives you waterfall charts.

00:38:41.720 --> 00:38:43.960
In fact, the waterfall charts
that we were showing earlier,

00:38:43.960 --> 00:38:45.950
one of them was taken from
the web page test.

00:38:45.950 --> 00:38:50.320
You can also see video
strip of the web

00:38:50.320 --> 00:38:50.980
page loading process.

00:38:50.980 --> 00:38:53.900
So it takes snapshots of your
web page at several points of

00:38:53.900 --> 00:38:54.440
the load time.

00:38:54.440 --> 00:38:56.990
So if it takes 10 second to
load, that'll be like 50

00:38:56.990 --> 00:38:59.820
snapshots, from zero to ten
seconds, at several points.

00:38:59.820 --> 00:39:03.480
And vendors actually use it to
see some content of the page

00:39:03.480 --> 00:39:06.140
being loaded using
that video strip.

00:39:06.140 --> 00:39:08.760
So this is a very good tool for
analyzing your web page

00:39:08.760 --> 00:39:10.250
and how it behaves.

00:39:10.250 --> 00:39:14.050
And the Chrome Developer Tools,
again I used it earlier

00:39:14.050 --> 00:39:15.200
to show how
window.performance.timing

00:39:15.200 --> 00:39:18.330
object shows the data.

00:39:18.330 --> 00:39:21.100
This is also very powerful to
analyze your web pages.

00:39:21.100 --> 00:39:23.010
There was a talk about
it Tuesday morning.

00:39:23.010 --> 00:39:25.780
So If you missed it, the
talk was recorded.

00:39:25.780 --> 00:39:29.930
So you can go and watch
it on YouTube later.

00:39:29.930 --> 00:39:31.460
So Analysis is good
to understand how

00:39:31.460 --> 00:39:32.830
your website is doing.

00:39:32.830 --> 00:39:35.000
And optimization is
the next step.

00:39:35.000 --> 00:39:37.850
We have a group called Page
Speed Insights, that analyses

00:39:37.850 --> 00:39:42.040
your web page and gives you
suggestions to improve your

00:39:42.040 --> 00:39:45.060
speed, based on the best
practices that we have known

00:39:45.060 --> 00:39:46.420
and we have learned for years.

00:39:46.420 --> 00:39:48.590
So you don't need
to do anything.

00:39:48.590 --> 00:39:51.700
If you go to that link, enter
your website, it gives you

00:39:51.700 --> 00:39:53.330
[INAUDIBLE] suggestions.

00:39:53.330 --> 00:39:55.960
Based on the priority, again.

00:39:55.960 --> 00:39:58.010
So you can go ahead and change
your website to implement

00:39:58.010 --> 00:39:59.650
those solutions.

00:39:59.650 --> 00:40:02.720
But there are tools which
actually do this suggestion

00:40:02.720 --> 00:40:04.620
implementation automatically
for you.

00:40:04.620 --> 00:40:07.960
So we have an Apache module
called mod_pagespeed.

00:40:07.960 --> 00:40:10.940
So if you use that module, it
implements those page speed

00:40:10.940 --> 00:40:11.835
suggestions automatically.

00:40:11.835 --> 00:40:14.050
It rewrites your web page,
and then serves it.

00:40:14.050 --> 00:40:17.260
So you get the benefit
without much work.

00:40:17.260 --> 00:40:19.470
And we also a Page
Speed Service.

00:40:19.470 --> 00:40:20.390
It's the service--

00:40:20.390 --> 00:40:23.420
if you point your domain name
to the service, it does the

00:40:23.420 --> 00:40:25.420
serving as well as the rewriting
part for you.

00:40:25.420 --> 00:40:29.480
So you get the benefits of
Google infrastructure, where

00:40:29.480 --> 00:40:31.470
your website will be served
from location close to the

00:40:31.470 --> 00:40:35.180
user, as well as these best
practices applied to your

00:40:35.180 --> 00:40:36.670
website content.

00:40:39.540 --> 00:40:41.720
If you have a Google App Engine
app, we have made it

00:40:41.720 --> 00:40:43.170
even easier for you.

00:40:43.170 --> 00:40:45.725
There is a simple check box
where you can say enable page

00:40:45.725 --> 00:40:47.420
speed service for my
Google Engine app.

00:40:47.420 --> 00:40:49.830
And it will do what Page Speed
Service does for your Google

00:40:49.830 --> 00:40:51.490
Engine app automatically.

00:40:51.490 --> 00:40:54.480
And if you want to learn more
about the App Engine app,

00:40:54.480 --> 00:40:56.190
there is a session tomorrow
morning at

00:40:56.190 --> 00:40:58.030
11:30, in room [? 304, ?]

00:40:58.030 --> 00:40:59.180
I guess.

00:40:59.180 --> 00:41:01.470
You can learn more there.

00:41:01.470 --> 00:41:03.845
So with this I will hand over
to Arvind, who has some

00:41:03.845 --> 00:41:06.550
interesting data, and will tell
you how fast the web is

00:41:06.550 --> 00:41:08.290
from our point of view.

00:41:08.290 --> 00:41:09.180
ARVIND JAIN: Thank you Satish.

00:41:09.180 --> 00:41:13.520
So Google Analytics is a really
good tool to measure

00:41:13.520 --> 00:41:16.350
the speed of your website
in the real world.

00:41:16.350 --> 00:41:19.260
And I think more importantly
than that, it actually allows

00:41:19.260 --> 00:41:22.490
you to understand the
relationship between speed and

00:41:22.490 --> 00:41:24.260
other business metrics
that you care about.

00:41:24.260 --> 00:41:28.825
For example, how much revenue
you make, our how many page

00:41:28.825 --> 00:41:30.690
views do you get for
your website.

00:41:30.690 --> 00:41:32.260
So it's a great tool.

00:41:32.260 --> 00:41:35.680
You should work on making your
site fast, and then you should

00:41:35.680 --> 00:41:36.820
convince yourself.

00:41:36.820 --> 00:41:40.070
You can see the data in Google
analytics, and see how it

00:41:40.070 --> 00:41:43.670
actually improves your other
business metrics.

00:41:43.670 --> 00:41:46.090
Google Analytics has lots
and lots of users.

00:41:46.090 --> 00:41:48.350
We have millions of
websites that

00:41:48.350 --> 00:41:49.600
actually use Google Analytics.

00:41:52.030 --> 00:41:56.000
And from that we've been
collecting a lot of data on

00:41:56.000 --> 00:41:58.880
the performance of
these websites.

00:41:58.880 --> 00:42:01.480
If you look in aggregate, that's
a good enough data set

00:42:01.480 --> 00:42:04.650
for us to proxy the performance
of the entire web.

00:42:04.650 --> 00:42:05.400
So that's what we did.

00:42:05.400 --> 00:42:09.460
We did a study on one
[INAUDIBLE] called site speed

00:42:09.460 --> 00:42:10.910
data from Google Analytics.

00:42:10.910 --> 00:42:14.380
This was done using data from
publishers who actually

00:42:14.380 --> 00:42:18.290
allowed us to do these kinds
of studies, by opting into

00:42:18.290 --> 00:42:20.440
aggregate analysis.

00:42:20.440 --> 00:42:23.910
And these are the results
from that study.

00:42:23.910 --> 00:42:26.720
So first of all, the
web is not fast.

00:42:26.720 --> 00:42:30.470
I mean I think this is one of
the things that we all need to

00:42:30.470 --> 00:42:33.800
work on, make sure that our
websites are really fast.

00:42:33.800 --> 00:42:37.370
On desktop it takes well over
six seconds, on average, to

00:42:37.370 --> 00:42:38.390
load a web page.

00:42:38.390 --> 00:42:39.070
That's a lot of time.

00:42:39.070 --> 00:42:42.170
Just imagine sitting for six
seconds, not doing anything,

00:42:42.170 --> 00:42:44.500
just waiting for the
page to load.

00:42:44.500 --> 00:42:45.990
On mobile, it's even worse.

00:42:45.990 --> 00:42:50.740
It takes well over 10 seconds on
average to load a web page.

00:42:50.740 --> 00:42:55.070
And by the way, this mobile
data is from Android ICS

00:42:55.070 --> 00:42:55.820
builds only.

00:42:55.820 --> 00:42:58.830
So these are really the best
phones that are out there.

00:42:58.830 --> 00:43:01.550
And even those are quite slow.

00:43:01.550 --> 00:43:05.220
The other chart shows the
different histograms.

00:43:05.220 --> 00:43:06.980
But the story remains
the same.

00:43:06.980 --> 00:43:11.910
The web is quite slow
as of today.

00:43:11.910 --> 00:43:14.460
This is another interesting
navigation.

00:43:14.460 --> 00:43:18.090
Here we show how fast
the web is for all

00:43:18.090 --> 00:43:19.430
these different countries.

00:43:19.430 --> 00:43:22.570
There's actually a heat map,
there's a link to a heat map

00:43:22.570 --> 00:43:26.260
here where you can see the
performance of the internet in

00:43:26.260 --> 00:43:28.580
any given country.

00:43:28.580 --> 00:43:30.280
The data is sort of obvious.

00:43:30.280 --> 00:43:34.460
It shows that the web is fast
in countries where you would

00:43:34.460 --> 00:43:36.110
expect it to be.

00:43:36.110 --> 00:43:38.470
I think it's sort of well-known
that countries like

00:43:38.470 --> 00:43:40.930
Japan and Sweden, they have
really good broadband

00:43:40.930 --> 00:43:42.330
connections to the home.

00:43:42.330 --> 00:43:45.800
Often in excess of 100
megabits per second.

00:43:45.800 --> 00:43:48.430
And that sort of shows
in this data.

00:43:48.430 --> 00:43:51.480
But why is that important
to you?

00:43:51.480 --> 00:43:52.220
One of things--

00:43:52.220 --> 00:43:55.550
we at Google, we really
care about this data.

00:43:55.550 --> 00:44:00.510
And we want to make sure that
our web services have the same

00:44:00.510 --> 00:44:03.960
level of responsiveness, no
matter where the user is.

00:44:03.960 --> 00:44:07.910
So if the user is coming from
a slow connection, or if a

00:44:07.910 --> 00:44:10.410
user is coming from a really
fast connection, we want to

00:44:10.410 --> 00:44:14.090
make sure that we provide them
with the same responsive

00:44:14.090 --> 00:44:16.900
experience, even if that means
that we have to sacrifice on

00:44:16.900 --> 00:44:18.000
some features.

00:44:18.000 --> 00:44:21.900
So we would often go and cut
some features from our

00:44:21.900 --> 00:44:25.530
products, so that we can still
maintain those low page load

00:44:25.530 --> 00:44:27.290
times for our users.

00:44:27.290 --> 00:44:30.870
As an example, for Google Maps
we can solve them with

00:44:30.870 --> 00:44:32.940
low-resolution titles.

00:44:32.940 --> 00:44:37.240
For Google search, we can
actually remove some of the

00:44:37.240 --> 00:44:39.730
features which are not commonly
needed, or we can

00:44:39.730 --> 00:44:43.680
defer loading them and make
them available later.

00:44:43.680 --> 00:44:46.950
Gmail, again, has the same kind
of experience, where for

00:44:46.950 --> 00:44:49.310
slow connections we would
actually show them a more

00:44:49.310 --> 00:44:52.780
traditional, web 1.0 style
email interface.

00:44:52.780 --> 00:44:55.630
Where you get to see your emails
really fast, but you

00:44:55.630 --> 00:44:57.210
won't get all the cool
features, like

00:44:57.210 --> 00:44:58.580
Hangouts and what not.

00:44:58.580 --> 00:45:00.830
So that's sort of the design
philosophy that we follow.

00:45:00.830 --> 00:45:04.470
And we often notice that that
is actually very useful, and

00:45:04.470 --> 00:45:08.150
helps us keep those users in
those countries where the

00:45:08.150 --> 00:45:09.450
connections are slow.

00:45:09.450 --> 00:45:10.990
And that's something for
you to consider as

00:45:10.990 --> 00:45:13.570
well, for your websites.

00:45:13.570 --> 00:45:15.210
This is yet another
aggregation.

00:45:15.210 --> 00:45:19.090
This shows the speed
of the web across

00:45:19.090 --> 00:45:21.200
different industry verticals.

00:45:21.200 --> 00:45:23.470
And sort of interesting--

00:45:23.470 --> 00:45:26.780
entertainment sites, as an
example, tend to be fairly

00:45:26.780 --> 00:45:28.430
rich, with a lot of images.

00:45:28.430 --> 00:45:33.580
And that sort of materializes
into slow page load times.

00:45:33.580 --> 00:45:36.330
And the same question emerges
again, why should you care

00:45:36.330 --> 00:45:37.180
about this?

00:45:37.180 --> 00:45:39.870
So one of the things that is
actually good to know, where

00:45:39.870 --> 00:45:43.420
does your site stack up?

00:45:43.420 --> 00:45:45.470
As compared to your competitors,
for example.

00:45:45.470 --> 00:45:49.090
So you can go to Google
Analytics, look at how fast

00:45:49.090 --> 00:45:54.210
your website is, and then
compare the performance of

00:45:54.210 --> 00:45:55.820
your website with these
aggregates.

00:45:55.820 --> 00:46:00.680
For example, you can find out
whether your site is typical,

00:46:00.680 --> 00:46:04.160
or slower, or faster than other
websites in your region.

00:46:04.160 --> 00:46:09.480
Or whether it's slower or
faster compared to other

00:46:09.480 --> 00:46:12.700
websites in the business
as yours.

00:46:12.700 --> 00:46:14.030
So this is all we have today.

00:46:14.030 --> 00:46:15.750
This concludes our
presentation.

00:46:15.750 --> 00:46:17.130
Thank you all for coming.

00:46:17.130 --> 00:46:19.350
And we would love to take any
questions that you might have.

00:46:34.950 --> 00:46:38.000
AUDIENCE: Question about
the custom metrics

00:46:38.000 --> 00:46:39.310
that you can collect.

00:46:39.310 --> 00:46:42.400
I saw in your example you were
measuring the beginning and

00:46:42.400 --> 00:46:43.950
end of a particular operation.

00:46:43.950 --> 00:46:48.840
Is there a way to just capture
how far you are from the very

00:46:48.840 --> 00:46:50.940
beginning of when the web
page began to load?

00:46:50.940 --> 00:46:53.620
Say that you're loading some
resources via Ajax shortly

00:46:53.620 --> 00:46:57.480
after the page loads, so that
it's comparable to--

00:46:57.480 --> 00:47:01.100
it's on the same timeline as
the rest of the performance

00:47:01.100 --> 00:47:02.870
events, this long to
get to this step,

00:47:02.870 --> 00:47:04.230
this step, this step.

00:47:04.230 --> 00:47:06.930
SATISH KAMBALA: So the
navigation timing API has this

00:47:06.930 --> 00:47:07.940
fetch start.

00:47:07.940 --> 00:47:10.360
That's one of the attributes in
the navigation timing API,

00:47:10.360 --> 00:47:12.100
that tells when the page
started to fetch.

00:47:12.100 --> 00:47:15.180
So you can base all of
your end times with

00:47:15.180 --> 00:47:15.940
[? respect to ?]

00:47:15.940 --> 00:47:18.523
the fetch start, so we can
compare them one by one.

00:47:18.523 --> 00:47:19.250
AUDIENCE: OK.

00:47:19.250 --> 00:47:20.500
Cool, thanks.

00:47:32.070 --> 00:47:37.490
AUDIENCE: Ads are often
a major issue with web

00:47:37.490 --> 00:47:40.310
performance.

00:47:40.310 --> 00:47:41.800
And they're also
very variable.

00:47:41.800 --> 00:47:48.030
Is it possible to remove those
from those timings, so you can

00:47:48.030 --> 00:47:53.590
check your pages outside of ads,
in case the ad stuff is

00:47:53.590 --> 00:47:56.060
not something that you're
able to control.

00:47:56.060 --> 00:47:56.550
ARVIND JAIN: Yes.

00:47:56.550 --> 00:47:58.680
I think that's a difficult
thing to do.

00:47:58.680 --> 00:48:02.380
Because when you load a web
page, your ads are actually

00:48:02.380 --> 00:48:05.030
just one of the 100 resources,
for example,

00:48:05.030 --> 00:48:06.720
that have been loaded.

00:48:06.720 --> 00:48:09.250
And it's really hard to tell
what would happen if those ads

00:48:09.250 --> 00:48:11.040
were not there.

00:48:11.040 --> 00:48:14.630
You can certainly
look at the--

00:48:14.630 --> 00:48:15.630
there are other tools.

00:48:15.630 --> 00:48:17.600
For example you can use Web Page
Test, or you can use Dev

00:48:17.600 --> 00:48:21.070
Tools, to actually see the
waterfall and see that your

00:48:21.070 --> 00:48:23.650
ads are actually sort of coming
in the way of your

00:48:23.650 --> 00:48:26.150
actual content from
getting loaded.

00:48:26.150 --> 00:48:29.420
So that's one of the ways to
actually see whether ads make

00:48:29.420 --> 00:48:30.630
things worse.

00:48:30.630 --> 00:48:32.980
Now the other thing to do is you
can actually measure the

00:48:32.980 --> 00:48:34.920
performance of your
ads by themselves.

00:48:34.920 --> 00:48:39.420
For example you can use user
timings to extract the time

00:48:39.420 --> 00:48:41.970
from the start of an ad quest
to when the ad request

00:48:41.970 --> 00:48:42.800
actually comes back.

00:48:42.800 --> 00:48:46.160
That sort of tells you
how long does the

00:48:46.160 --> 00:48:47.150
ads actually take.

00:48:47.150 --> 00:48:49.890
And if your ads are blocking,
like if they actually block

00:48:49.890 --> 00:48:52.440
the content of web page, they'll
show the actual impact

00:48:52.440 --> 00:48:54.990
of those ads on the web
page performance.

00:48:54.990 --> 00:48:56.820
So you can actually look at the
data, and you can manually

00:48:56.820 --> 00:49:00.790
definitely try to figure out
the actual impact of ads on

00:49:00.790 --> 00:49:01.500
the web pages.

00:49:01.500 --> 00:49:04.170
The right thing, in my opinion,
is to actually use

00:49:04.170 --> 00:49:05.470
ads properly.

00:49:05.470 --> 00:49:08.580
And many ad networks, definitely
all Google ad

00:49:08.580 --> 00:49:11.260
products these days, the
recommended way to include

00:49:11.260 --> 00:49:14.130
them is to load them
asynchronously, so that they

00:49:14.130 --> 00:49:20.010
don't actually come in the way
of your web page performance.

00:49:20.010 --> 00:49:20.840
Seems like that's it.

00:49:20.840 --> 00:49:22.090
So thank you again.

