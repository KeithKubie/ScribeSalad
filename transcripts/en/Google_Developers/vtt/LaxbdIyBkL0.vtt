WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.939
[APPLAUSE]

00:00:04.939 --> 00:00:05.730
ADDY OSMANI: Hello.

00:00:05.730 --> 00:00:07.930
So we all care
about performance.

00:00:07.930 --> 00:00:09.497
Keeping our pages fast.

00:00:09.497 --> 00:00:11.580
Making sure that we're
using just the right amount

00:00:11.580 --> 00:00:12.690
of memory.

00:00:12.690 --> 00:00:15.320
How many people here have used
the Chrome DevTools before,

00:00:15.320 --> 00:00:19.590
to try figuring out if they have
a memory leak in their route?

00:00:19.590 --> 00:00:22.690
How many people here have
enjoyed that experience?

00:00:22.690 --> 00:00:23.190
Right?

00:00:23.190 --> 00:00:24.189
There's like one person.

00:00:24.189 --> 00:00:24.749
Get out!

00:00:24.749 --> 00:00:25.540
[AUDIENCE LAUGHTER]

00:00:25.540 --> 00:00:26.930
No.

00:00:26.930 --> 00:00:30.590
So I've been working with
the DevTools for few years.

00:00:30.590 --> 00:00:33.010
Memory profiling, using
our memory tools--

00:00:33.010 --> 00:00:35.030
they're fantastic,
but at times they

00:00:35.030 --> 00:00:36.854
feel a little bit
of a black box.

00:00:36.854 --> 00:00:39.020
And so in this talk we're
going to look a little bit

00:00:39.020 --> 00:00:42.420
at understanding how memory
profiling works in the DevTools

00:00:42.420 --> 00:00:44.480
give you some pro
tips on that stuff.

00:00:44.480 --> 00:00:47.449
We're also going to do a deep
dive into some V8 specifics

00:00:47.449 --> 00:00:49.740
to help you understand how
things like the memory graph

00:00:49.740 --> 00:00:50.710
work.

00:00:50.710 --> 00:00:54.080
It's hopefully going to
be interesting but-- yeah.

00:00:54.080 --> 00:00:56.400
Whenever I'm building
an app that I

00:00:56.400 --> 00:00:58.350
think this is going
pretty well, I'm

00:00:58.350 --> 00:01:00.840
pretty happy with
the performance,

00:01:00.840 --> 00:01:02.820
half the time I end up
in this situation where

00:01:02.820 --> 00:01:04.849
I've got this really
nice, smooth performance,

00:01:04.849 --> 00:01:07.810
and then someone
comes in and crashes

00:01:07.810 --> 00:01:12.740
into that nice feeling
like a plastic tractor.

00:01:12.740 --> 00:01:16.550
That is what a memory leak
feels like to me half the time.

00:01:16.550 --> 00:01:18.940
So I've been
getting a few emails

00:01:18.940 --> 00:01:22.317
from some friends that had a
few memory profiling issues.

00:01:22.317 --> 00:01:23.900
And so what we're
going to do is we're

00:01:23.900 --> 00:01:26.730
going to take a look
at some of those emails

00:01:26.730 --> 00:01:29.600
and try to figure out how
to solve these issues.

00:01:29.600 --> 00:01:35.730
So let's go and open up
the DevTools on this page.

00:01:35.730 --> 00:01:37.720
Now, what's the first issue?

00:01:37.720 --> 00:01:40.520
Paul writes in saying, "Why
is my memory usage growing?

00:01:40.520 --> 00:01:43.160
My app slows down when
I click on this button.

00:01:43.160 --> 00:01:45.052
Why is that happening?"

00:01:45.052 --> 00:01:47.260
So the first thing you can
do-- before we actually go

00:01:47.260 --> 00:01:49.176
and open up the DevTools--
the first thing you

00:01:49.176 --> 00:01:51.440
can do, if you think you
have some sort of issue

00:01:51.440 --> 00:01:53.090
to do with memory in
Chrome is actually

00:01:53.090 --> 00:01:55.130
going to open up
the Task Manager.

00:01:55.130 --> 00:01:57.790
So the Task Manager is actually
hidden in the Tools menu,

00:01:57.790 --> 00:02:00.360
So you can go to Tools
and Task Manager.

00:02:00.360 --> 00:02:02.040
What this will do
is actually give you

00:02:02.040 --> 00:02:05.090
a list of all of the currently
open tabs and extensions

00:02:05.090 --> 00:02:08.100
that you have, and it will
list right next to them

00:02:08.100 --> 00:02:10.380
the current memory
usage, CPU usage.

00:02:10.380 --> 00:02:13.250
You can actually go and if you
right click on the top here,

00:02:13.250 --> 00:02:15.930
you can also expand
it to show the GPU

00:02:15.930 --> 00:02:19.150
memory, JavaScript memory,
shared memory being used.

00:02:19.150 --> 00:02:22.270
And this is useful for just,
like, getting a hint about

00:02:22.270 --> 00:02:25.820
whether you've got
growing memory in a tab.

00:02:25.820 --> 00:02:29.700
So in this case, we could go
and try to find the mail tab.

00:02:29.700 --> 00:02:31.890
If I go and I click
on this button--

00:02:31.890 --> 00:02:35.540
might have to drag this window
a tiny bit-- what I'll see

00:02:35.540 --> 00:02:38.530
is that, yep, memory
usage is growing

00:02:38.530 --> 00:02:40.030
in this tab at the moment.

00:02:40.030 --> 00:02:43.490
That's useful for
a very simple hint.

00:02:43.490 --> 00:02:46.400
But what I want is
some more specifics.

00:02:46.400 --> 00:02:49.510
So what I'm going to do is I'm
going to open up the DevTools.

00:02:49.510 --> 00:02:51.490
Head on over to the Timeline.

00:02:51.490 --> 00:02:54.160
And I'm now in Memory view.

00:02:54.160 --> 00:02:56.880
Technically speaking, this is
Frames view and memory view.

00:02:56.880 --> 00:02:59.920
Just make sure you've got the
"Capture memory" option on when

00:02:59.920 --> 00:03:01.450
you're trying to
work on this stuff.

00:03:01.450 --> 00:03:03.182
So Memory view is really useful.

00:03:03.182 --> 00:03:04.640
If you haven't used
it before, it's

00:03:04.640 --> 00:03:08.400
great for tracking the total
number of objects allocated

00:03:08.400 --> 00:03:11.060
in memory, seeing
whether they've grown,

00:03:11.060 --> 00:03:13.370
looking at the total
number of DOM nodes

00:03:13.370 --> 00:03:15.620
that have been allocated,
how many documents have been

00:03:15.620 --> 00:03:17.850
created, event
listeners allocated.

00:03:17.850 --> 00:03:21.440
So here, I've clicked on my
button, and if I go and look

00:03:21.440 --> 00:03:24.540
here I can see that the memory
usage on this page is growing.

00:03:24.540 --> 00:03:25.750
It's not growing too much.

00:03:25.750 --> 00:03:26.930
It's growing a little bit.

00:03:26.930 --> 00:03:30.660
But I can actually go
and slice down this data,

00:03:30.660 --> 00:03:33.700
try to see what's going on
in a particular segment.

00:03:33.700 --> 00:03:36.410
In the bottom view, where
you see the Memory pane,

00:03:36.410 --> 00:03:39.760
you can take a look at the
size of the JavaScript heap,

00:03:39.760 --> 00:03:40.830
whether that's growing.

00:03:40.830 --> 00:03:43.614
Again, the documents, the nodes.

00:03:43.614 --> 00:03:45.530
Right off the back of
that, we've actually got

00:03:45.530 --> 00:03:48.050
another question
that was sent in:

00:03:48.050 --> 00:03:50.430
"Where does GC-- so where
does garbage collection--

00:03:50.430 --> 00:03:52.670
fit in with memory profiling?

00:03:52.670 --> 00:03:56.027
I'm trying to look at the
time spent by the GC."

00:03:56.027 --> 00:03:57.610
Now, what I'm going
to do is I'm going

00:03:57.610 --> 00:03:59.642
to click on "Start
creating chunks,"

00:03:59.642 --> 00:04:01.100
and go and start
recording, and I'm

00:04:01.100 --> 00:04:04.380
going to explain a
workflow for tracking down

00:04:04.380 --> 00:04:05.820
if you've got a memory issue.

00:04:05.820 --> 00:04:08.520
So normally, if you think that
you have a leak, after you've

00:04:08.520 --> 00:04:10.680
taken a look at
the Task Manager,

00:04:10.680 --> 00:04:12.800
try to identify a
sequence of actions

00:04:12.800 --> 00:04:14.730
that you think might be
leading to that leak.

00:04:14.730 --> 00:04:16.630
So maybe it's clicking
on a button that's

00:04:16.630 --> 00:04:18.795
going to show more
images in a carousel,

00:04:18.795 --> 00:04:20.170
or clicking a
button that's going

00:04:20.170 --> 00:04:22.720
to display more
content in your page.

00:04:22.720 --> 00:04:25.120
So identify the
sequence of actions

00:04:25.120 --> 00:04:26.570
that's suspected of leaking.

00:04:26.570 --> 00:04:29.224
Go and record a Timeline
like we're doing right now.

00:04:29.224 --> 00:04:30.890
And then the next
thing you want to do--

00:04:30.890 --> 00:04:33.760
and this is pretty important--
is use the trash icon.

00:04:33.760 --> 00:04:36.600
So there's a trash icon here
that says, "Collect garbage."

00:04:36.600 --> 00:04:40.634
What this is going to do
is basically force GC.

00:04:40.634 --> 00:04:42.800
If you don't click this
icon, what's going to happen

00:04:42.800 --> 00:04:44.800
is that the objects
that you have in memory

00:04:44.800 --> 00:04:48.741
are going to stay alive
until the next round of GC.

00:04:48.741 --> 00:04:50.240
It's not a massive
deal, but it just

00:04:50.240 --> 00:04:52.700
means that you're going to be
waiting a while before you're

00:04:52.700 --> 00:04:55.010
going to be able to get
a proper profile of this.

00:04:55.010 --> 00:05:00.220
Now, if you iterate a few times
and you see a sawtooth curve,

00:05:00.220 --> 00:05:01.720
it might mean that
you're allocating

00:05:01.720 --> 00:05:03.400
a lot of short-lived objects.

00:05:06.150 --> 00:05:07.977
What I mean by a
sawtooth curve is

00:05:07.977 --> 00:05:09.810
something that looks a
little bit like this.

00:05:09.810 --> 00:05:12.315
So pay attention to what's
in the red rectangle

00:05:12.315 --> 00:05:13.360
at the very top.

00:05:13.360 --> 00:05:14.529
So that's a sawtooth curve.

00:05:14.529 --> 00:05:16.820
If you see something that
looks a little bit like this,

00:05:16.820 --> 00:05:19.380
it means you're allocating
lots of short-life objects.

00:05:19.380 --> 00:05:22.170
And if that sequence isn't
expected to retain memory--

00:05:22.170 --> 00:05:24.500
so if you're not doing
anything too intensive

00:05:24.500 --> 00:05:27.090
and your DOM node count
isn't actually dropping--

00:05:27.090 --> 00:05:30.210
it might be an indication
that you're leaking.

00:05:30.210 --> 00:05:32.292
So keep that in mind.

00:05:32.292 --> 00:05:34.250
Let's take a look at the
next question we have.

00:05:34.250 --> 00:05:37.070
So we've got another
question in here.

00:05:37.070 --> 00:05:40.800
This one's from Jake
Archibald: "Addy, buddy, pal.

00:05:40.800 --> 00:05:43.570
I'm letting you find and
fix a memory leak in my app.

00:05:43.570 --> 00:05:48.030
Also, please send a PR
with the fix to my repo."

00:05:48.030 --> 00:05:50.410
That's Jake.

00:05:50.410 --> 00:05:51.870
Right, so we just
learned about how

00:05:51.870 --> 00:05:54.470
to go and try to memory
profile something.

00:05:54.470 --> 00:05:57.610
What we've got here is what
looks like we've got some tabs

00:05:57.610 --> 00:05:59.860
and we actually
have a slider that's

00:05:59.860 --> 00:06:01.270
just displaying some images.

00:06:01.270 --> 00:06:04.610
This is like a carousel, so
it's displaying different images

00:06:04.610 --> 00:06:05.790
based on the seasons.

00:06:05.790 --> 00:06:10.100
We've got one for autumn,
summer, winter, and spring.

00:06:10.100 --> 00:06:12.181
Nothing overly complex.

00:06:12.181 --> 00:06:13.930
Now we're going to do
here is, Jake thinks

00:06:13.930 --> 00:06:15.471
that he has a memory
leak in his app.

00:06:15.471 --> 00:06:17.570
I'm actually going to
reload the page in case

00:06:17.570 --> 00:06:20.220
any of the objects
from our other examples

00:06:20.220 --> 00:06:21.690
are still hanging around.

00:06:21.690 --> 00:06:23.430
I'm gonna clear that.

00:06:23.430 --> 00:06:25.010
And what we're
going to do here is

00:06:25.010 --> 00:06:28.430
we're actually going to go
and use the object allocation

00:06:28.430 --> 00:06:30.530
tracker in DevTools
tools to figure out

00:06:30.530 --> 00:06:32.214
if we have a memory leak.

00:06:32.214 --> 00:06:33.630
Now the object
allocation tracker,

00:06:33.630 --> 00:06:35.220
let's actually go
and record this.

00:06:35.220 --> 00:06:38.110
So I'm just going to
click on "Start here."

00:06:38.110 --> 00:06:38.990
Start interacting.

00:06:38.990 --> 00:06:40.460
Now the object
allocation tracker

00:06:40.460 --> 00:06:43.750
basically takes heap
snapshots periodically

00:06:43.750 --> 00:06:45.590
throughout a recording.

00:06:45.590 --> 00:06:48.260
The bars that you're
seeing here, the blue bars,

00:06:48.260 --> 00:06:49.700
basically mean new objects.

00:06:49.700 --> 00:06:51.730
And the height of
these objects basically

00:06:51.730 --> 00:06:54.240
correspond to the
size of the objects.

00:06:54.240 --> 00:06:57.180
So something is getting
sort of turned into gray,

00:06:57.180 --> 00:06:59.620
it means that we don't have
to worry about it anymore.

00:06:59.620 --> 00:07:01.330
If it's staying blue, we do.

00:07:01.330 --> 00:07:04.250
So I'm going to stop
just there, and let's

00:07:04.250 --> 00:07:07.650
try narrowing down one
of the thicker bars

00:07:07.650 --> 00:07:08.910
and see what's going on here.

00:07:08.910 --> 00:07:14.160
So I'm going to select a
segment, maybe a larger segment

00:07:14.160 --> 00:07:16.732
then we've got at the moment.

00:07:16.732 --> 00:07:17.690
Let's take a look here.

00:07:17.690 --> 00:07:19.350
We've got DOM token list.

00:07:19.350 --> 00:07:22.140
You've got attributes,
a node map.

00:07:22.140 --> 00:07:27.980
Let's try to expand
it to the whole set.

00:07:27.980 --> 00:07:31.470
And what I see here is that
I've got HTML li element, so

00:07:31.470 --> 00:07:34.760
the list element, that
may be causing trouble.

00:07:34.760 --> 00:07:36.950
So this is, basically--
How many people

00:07:36.950 --> 00:07:40.630
here have used the heap
snapshot tools before?

00:07:40.630 --> 00:07:42.660
A small number of people, OK.

00:07:42.660 --> 00:07:44.535
Basically, what the
object allocation tracker

00:07:44.535 --> 00:07:45.951
is doing in the
background is it's

00:07:45.951 --> 00:07:47.790
taking a bunch of
different snapshots

00:07:47.790 --> 00:07:49.780
and it's basically
leaving behind stuff

00:07:49.780 --> 00:07:52.080
that hasn't been
correctly cleaned up.

00:07:52.080 --> 00:07:53.650
So here, what we
can see is that we

00:07:53.650 --> 00:07:55.500
have a number of
different list elements.

00:07:55.500 --> 00:07:59.180
And if I go and I
dive down into here,

00:07:59.180 --> 00:08:01.670
what you'll see in the retaining
view at the very bottom

00:08:01.670 --> 00:08:04.040
is we've got a few
different objects.

00:08:04.040 --> 00:08:08.140
We've got HTML document, details
element, HTML div element.

00:08:08.140 --> 00:08:11.410
What I see here is a reference
to a variable name called

00:08:11.410 --> 00:08:12.820
"last div."

00:08:12.820 --> 00:08:14.400
And if I actually
hover over this,

00:08:14.400 --> 00:08:17.370
I can scroll down in
this information bar

00:08:17.370 --> 00:08:18.940
and see that the
innerHTML actually

00:08:18.940 --> 00:08:21.220
seems to be some of
the content for one

00:08:21.220 --> 00:08:23.590
of these carousel items.

00:08:23.590 --> 00:08:25.454
Now if I go over
into my sources view,

00:08:25.454 --> 00:08:26.870
and we actually
go and take a look

00:08:26.870 --> 00:08:29.560
at the source for this
particular example--

00:08:29.560 --> 00:08:32.100
I'm gonna try bumping up
the font size a little bit

00:08:32.100 --> 00:08:35.110
so people can see it.

00:08:35.110 --> 00:08:39.130
Let's actually run through the
functions that are called here.

00:08:39.130 --> 00:08:41.039
Whenever I go and
select a tab, it's

00:08:41.039 --> 00:08:44.070
calling this function called
"select tab," which is then

00:08:44.070 --> 00:08:46.500
going and calling load content.

00:08:46.500 --> 00:08:48.110
Let's scroll down
to load content.

00:08:48.110 --> 00:08:49.600
We can see this
doing two things.

00:08:49.600 --> 00:08:52.020
It's calling "prepare
content," which

00:08:52.020 --> 00:08:55.270
happens to be referencing last
div, so maybe that's leaking.

00:08:55.270 --> 00:08:58.270
And it's also calling
"prepare gallery."

00:08:58.270 --> 00:09:01.097
Now if we scroll down
a little bit further

00:09:01.097 --> 00:09:02.680
and we take a look
at prepare gallery,

00:09:02.680 --> 00:09:04.520
let's take a look at
what's going on here.

00:09:04.520 --> 00:09:07.090
So here's probably where all
of our different list elements

00:09:07.090 --> 00:09:09.110
are coming from, so
it's gone and it's

00:09:09.110 --> 00:09:11.439
tried to query those in the DOM.

00:09:11.439 --> 00:09:12.980
Then we scroll down
a little further,

00:09:12.980 --> 00:09:16.020
and what notice is that
basically every single time

00:09:16.020 --> 00:09:18.400
Jake is selecting
a new tab, he's

00:09:18.400 --> 00:09:21.980
actually going and setting
"interval" on this animation.

00:09:21.980 --> 00:09:23.836
But he's not clearing it.

00:09:23.836 --> 00:09:25.210
So that's going
to end up causing

00:09:25.210 --> 00:09:27.820
a leak if we continue doing it.

00:09:27.820 --> 00:09:29.760
One thing he could do
here is probably go

00:09:29.760 --> 00:09:32.000
and actually-- if we scroll
down we can see the fix.

00:09:32.000 --> 00:09:34.860
If he just went and
actually assigned

00:09:34.860 --> 00:09:37.410
a variable for that
timer, for that interval,

00:09:37.410 --> 00:09:38.980
we can go clear
it up when we know

00:09:38.980 --> 00:09:41.000
that it's no longer necessary.

00:09:41.000 --> 00:09:43.630
Otherwise, we're going to end up
with a copy of prepare gallery

00:09:43.630 --> 00:09:45.963
with everything that
comes inside of it--

00:09:45.963 --> 00:09:48.700
its elements, its function
definitions-- in memory

00:09:48.700 --> 00:09:51.040
on every single click.

00:09:51.040 --> 00:09:52.210
So we've looked at that.

00:09:52.210 --> 00:09:53.630
Let's move on to
another example.

00:09:53.630 --> 00:09:56.140
Let's go back to the timeline.

00:09:56.140 --> 00:10:01.030
So Matt Gone asks, "What
are scattered objects?"

00:10:01.030 --> 00:10:03.354
Scattered objects are
basically something

00:10:03.354 --> 00:10:04.520
that we mention in our docs.

00:10:04.520 --> 00:10:06.860
You may or may not have
come across before.

00:10:06.860 --> 00:10:09.090
I'm going to go back to
profiles for a moment.

00:10:09.090 --> 00:10:11.450
Clear this stuff up.

00:10:11.450 --> 00:10:13.510
Reload the page very quickly.

00:10:13.510 --> 00:10:16.630
And I'm going to go and
record a heap snapshot.

00:10:16.630 --> 00:10:19.572
Let's just record a heap
snapshot very quickly.

00:10:19.572 --> 00:10:21.030
And now let's record
one after I've

00:10:21.030 --> 00:10:25.820
clicked the "Create
scattered objects" button.

00:10:25.820 --> 00:10:27.830
Do a comparison
between these two.

00:10:27.830 --> 00:10:30.640
Sorry, I've got to
expand this a little bit.

00:10:34.610 --> 00:10:38.130
Now one thing that you might
run across in your applications

00:10:38.130 --> 00:10:41.330
is you might have objects that
are basically the same kind

00:10:41.330 --> 00:10:43.740
but which happen to be
scattered across different parts

00:10:43.740 --> 00:10:44.573
of your application.

00:10:44.573 --> 00:10:47.060
So you might be using the same
class in different modules,

00:10:47.060 --> 00:10:50.020
for example, or across
different plug-ins.

00:10:50.020 --> 00:10:52.330
Now one of the nice things
about the heap profiler

00:10:52.330 --> 00:10:55.360
is that it'll actually aggregate
all of the different instances

00:10:55.360 --> 00:10:58.040
for that particular
type of item.

00:10:58.040 --> 00:11:00.822
So in this case, our class is
actually just called "item."

00:11:00.822 --> 00:11:03.030
And it'll just aggregate
them all into this nice view

00:11:03.030 --> 00:11:05.170
so we can go we can
just drop down and see,

00:11:05.170 --> 00:11:07.220
OK well, this is
where I have all

00:11:07.220 --> 00:11:08.940
of the different
instances of "item."

00:11:08.940 --> 00:11:11.330
To just give you a
little bit of insight

00:11:11.330 --> 00:11:13.580
into what the code
there is doing-- we

00:11:13.580 --> 00:11:14.700
have two functions here.

00:11:14.700 --> 00:11:16.740
Both of them are
using the item class.

00:11:16.740 --> 00:11:18.710
This is a very
simple item class.

00:11:18.710 --> 00:11:20.430
Both of them are
using the item class.

00:11:20.430 --> 00:11:22.870
But in the profiler
view, I can actually

00:11:22.870 --> 00:11:26.060
just get a nice, simple
way of drilling down

00:11:26.060 --> 00:11:31.130
to exactly those instantiations
that I'm interested in.

00:11:31.130 --> 00:11:34.320
Let's take a look
at another example.

00:11:34.320 --> 00:11:39.260
So this is an example
from Paul Lewis, it seems.

00:11:39.260 --> 00:11:42.170
Paul, do you want to come
up to read up your email?

00:11:42.170 --> 00:11:45.670
PAUL LEWIS: No. [INAUDIBLE].

00:11:45.670 --> 00:11:47.757
ADDY OSMANI: I would never
do anything like that!

00:11:47.757 --> 00:11:49.590
Not to an esteemed
colleague like you, Paul.

00:11:52.120 --> 00:11:53.460
You're coming up to do this.

00:12:01.270 --> 00:12:03.590
Right so.

00:12:03.590 --> 00:12:04.390
PAUL LEWIS: Hi!

00:12:04.390 --> 00:12:04.580
ADDY OSMANI: Hi!

00:12:04.580 --> 00:12:05.455
This is your section.

00:12:05.455 --> 00:12:07.700
This is the email
that you wrote me.

00:12:07.700 --> 00:12:08.950
PAUL LEWIS: That's harsh.

00:12:08.950 --> 00:12:11.890
Today I walked into the
gym and did one push-up

00:12:11.890 --> 00:12:13.760
in front of everyone.

00:12:13.760 --> 00:12:15.440
Then ripped off my shirt.

00:12:15.440 --> 00:12:17.566
Of course I did, why wouldn't I?

00:12:17.566 --> 00:12:19.190
And I walked out
grunting, "You did it!

00:12:19.190 --> 00:12:20.520
You did it!"

00:12:20.520 --> 00:12:23.560
Anyway, I'm trying to understand
what I see in heap snapshots.

00:12:23.560 --> 00:12:24.510
Help?

00:12:24.510 --> 00:12:25.750
ADDY OSMANI: I didn't
embarrass you in any way.

00:12:25.750 --> 00:12:27.470
PAUL LEWIS: No, that
sounds totally legit.

00:12:27.470 --> 00:12:28.886
ADDY OSMANI: Not
in the slightest!

00:12:32.410 --> 00:12:34.610
Maybe you'll do a push-up later.

00:12:34.610 --> 00:12:35.110
Right.

00:12:35.110 --> 00:12:38.890
So Paul's wondering about how
we can find detached nodes

00:12:38.890 --> 00:12:40.680
in the heap snapshot view.

00:12:40.680 --> 00:12:45.030
So let's go and create--
let's take a clean snapshot.

00:12:45.030 --> 00:12:47.080
And then let's take
a snapshot after I've

00:12:47.080 --> 00:12:50.160
clicked on the "Create
detached nodes" button.

00:12:50.160 --> 00:12:52.270
Let's go and record that.

00:12:52.270 --> 00:12:54.239
Let's go to the comparison
view, because we

00:12:54.239 --> 00:12:56.655
want to compare what happened
between those two snapshots.

00:12:59.600 --> 00:13:00.230
Right.

00:13:00.230 --> 00:13:02.835
And if we go and take a
look at HTML div element,

00:13:02.835 --> 00:13:05.210
what you'll see is that we
have a number of elements here

00:13:05.210 --> 00:13:07.020
which are highlighted in red.

00:13:07.020 --> 00:13:08.710
If I go I select
one of them, you'll

00:13:08.710 --> 00:13:10.730
see that we have
other nodes that

00:13:10.730 --> 00:13:12.850
are mentions in this
detached DOM tree

00:13:12.850 --> 00:13:15.684
lower down on the page,
which happen to be in yellow.

00:13:15.684 --> 00:13:17.350
Now there's a little
bit of a difference

00:13:17.350 --> 00:13:19.970
between the red nodes
in the yellow nodes.

00:13:19.970 --> 00:13:22.930
Red nodes don't actually
have any direct references

00:13:22.930 --> 00:13:24.900
from JavaScript to them,
and they're usually

00:13:24.900 --> 00:13:28.584
alive because they're still
part of some detached DOM tree.

00:13:28.584 --> 00:13:30.250
There might be a node
in the tree that's

00:13:30.250 --> 00:13:33.610
referenced from JavaScript,
maybe as a closure,

00:13:33.610 --> 00:13:35.250
or from a variable.

00:13:35.250 --> 00:13:38.400
But it's coincidentally
preventing the entire DOM tree

00:13:38.400 --> 00:13:39.996
from being garbage collected.

00:13:39.996 --> 00:13:41.620
The yellow nodes--
so again, those ones

00:13:41.620 --> 00:13:43.760
that are the very
bottom-- do have

00:13:43.760 --> 00:13:45.880
direct references
from JavaScript.

00:13:45.880 --> 00:13:50.140
So look for those yellow nodes
in the same detached DOM tree

00:13:50.140 --> 00:13:54.310
to locate if you have
a leak of some sort.

00:13:54.310 --> 00:13:56.310
And we can go and we can
actually clean that up

00:13:56.310 --> 00:13:58.680
by clicking on the "Clean
detached nodes" button.

00:13:58.680 --> 00:14:00.805
I'm not going to show you
that, but I will give you

00:14:00.805 --> 00:14:03.010
the demos later on, so
you can check that out.

00:14:03.010 --> 00:14:05.500
Eric writes in and
he's asking, "How

00:14:05.500 --> 00:14:09.160
does memory work with
V8 hidden classes?

00:14:09.160 --> 00:14:12.740
Someone told me if the compiler
can use hidden classes,

00:14:12.740 --> 00:14:14.980
your code will
execute much faster

00:14:14.980 --> 00:14:17.880
and will use much less memory.

00:14:17.880 --> 00:14:20.270
Is this true?"

00:14:20.270 --> 00:14:21.830
OK, so let's try to do that.

00:14:21.830 --> 00:14:26.060
Let's go and create
a new heap snapshot.

00:14:26.060 --> 00:14:27.330
Let's clear.

00:14:27.330 --> 00:14:29.020
Create a new heap snapshot.

00:14:29.020 --> 00:14:31.300
Create some objects.

00:14:31.300 --> 00:14:32.887
Do another recording.

00:14:32.887 --> 00:14:33.970
So this is taking a while.

00:14:33.970 --> 00:14:38.640
We're creating a ton of
objects here in the background.

00:14:38.640 --> 00:14:41.500
So it's still collecting
and parsing that data

00:14:41.500 --> 00:14:43.570
and building up the tree.

00:14:43.570 --> 00:14:45.625
So we go and we
take a look here.

00:14:45.625 --> 00:14:47.000
And what you'll
notice is that we

00:14:47.000 --> 00:14:50.410
have two classes that are of
particular interest to us.

00:14:50.410 --> 00:14:53.071
We have slow purchase
and fast purchase.

00:14:53.071 --> 00:14:54.820
Now, I'm going to
expand this a little bit

00:14:54.820 --> 00:14:56.940
so you can see all
of the data here.

00:14:56.940 --> 00:15:00.080
Now, slow purchase
has a retained size

00:15:00.080 --> 00:15:03.070
that is significantly larger
than the retained size

00:15:03.070 --> 00:15:04.790
of fast purchase.

00:15:04.790 --> 00:15:08.110
If we take a look at our
page once again, actually,

00:15:08.110 --> 00:15:10.260
and I go and do some
calculus, which is basically

00:15:10.260 --> 00:15:11.915
just performing
the same operation

00:15:11.915 --> 00:15:14.705
with those two classes--
just one of them is slow

00:15:14.705 --> 00:15:16.480
and one of them is
fast-- what you'll see

00:15:16.480 --> 00:15:21.700
is that fast is actually pretty
significantly faster than slow.

00:15:21.700 --> 00:15:25.340
Let's go and try to
explain that a little bit.

00:15:25.340 --> 00:15:28.050
So V8's optimizing
compiler makes

00:15:28.050 --> 00:15:30.020
a lot of assumptions
about your code.

00:15:30.020 --> 00:15:31.830
It transparently,
in the background,

00:15:31.830 --> 00:15:34.670
creates hidden classes
representing your objects.

00:15:34.670 --> 00:15:36.520
And using those
hidden classes, V8

00:15:36.520 --> 00:15:38.320
is able to work a lot faster.

00:15:38.320 --> 00:15:41.380
If you do things like
delete properties,

00:15:41.380 --> 00:15:43.070
those assumptions
are no longer valid

00:15:43.070 --> 00:15:45.500
and they can end up
causing de-optimizations

00:15:45.500 --> 00:15:47.230
behind the scenes.

00:15:47.230 --> 00:15:49.350
So in this particular
case, what we

00:15:49.350 --> 00:15:52.800
see is we have a fast object
and a slow object Functionally

00:15:52.800 --> 00:15:55.520
speaking, these two classes
are very, very similar.

00:15:55.520 --> 00:15:59.916
The only difference is that in
the case of the slow object,

00:15:59.916 --> 00:16:01.290
I thought I'd be
really clever, I

00:16:01.290 --> 00:16:03.700
thought maybe the
slow object would

00:16:03.700 --> 00:16:06.230
be faster if I actually
deleted a property.

00:16:06.230 --> 00:16:09.500
It's actually using
less memory, right?

00:16:09.500 --> 00:16:10.310
Maybe?

00:16:10.310 --> 00:16:12.450
I don't know.

00:16:12.450 --> 00:16:15.440
And so we delete this
property from our object.

00:16:15.440 --> 00:16:20.175
But what actually happens is
that causes V8 to actually bail

00:16:20.175 --> 00:16:23.720
out of using its hidden
classes for optimization,

00:16:23.720 --> 00:16:25.880
and it makes things
significantly slower.

00:16:25.880 --> 00:16:27.660
Actually any where
up to 15 times

00:16:27.660 --> 00:16:30.710
slower in the case of
this particular example.

00:16:30.710 --> 00:16:35.490
So although I'm saying try to
be careful when using delete,

00:16:35.490 --> 00:16:38.240
you're almost certain to find
it in many popular JavaScript

00:16:38.240 --> 00:16:38.800
libraries.

00:16:38.800 --> 00:16:41.240
It certainly has a
place in the language.

00:16:41.240 --> 00:16:43.430
There are valid uses of it.

00:16:43.430 --> 00:16:45.250
But the main takeaway
here is to avoid

00:16:45.250 --> 00:16:48.706
modifying the structure of
hot objects at run time.

00:16:48.706 --> 00:16:50.830
So in this case, what we
probably should have done,

00:16:50.830 --> 00:16:52.371
instead of using
the delete key word,

00:16:52.371 --> 00:16:54.870
is just nullifying the object
so that it could be properly

00:16:54.870 --> 00:16:56.240
garbage collected.

00:16:56.240 --> 00:16:58.580
Because only when the last
reference to an object

00:16:58.580 --> 00:17:01.530
is removed does that object
get properly eligible

00:17:01.530 --> 00:17:04.349
for collection.

00:17:04.349 --> 00:17:05.000
Great.

00:17:05.000 --> 00:17:09.510
So let's go and take a
look at another example.

00:17:09.510 --> 00:17:11.420
Before we go on
to closures, let's

00:17:11.420 --> 00:17:15.930
take a look at leaky DOM nodes.

00:17:15.930 --> 00:17:19.390
Rob Dobson writes in,
saying, "I suspect

00:17:19.390 --> 00:17:23.180
that I have an array leaf
nodes which might be leaking.

00:17:23.180 --> 00:17:25.092
I'm not quite sure
how to find this."

00:17:25.092 --> 00:17:26.550
Well, the workflow
is actually very

00:17:26.550 --> 00:17:28.820
similar to what we've
been doing here before.

00:17:28.820 --> 00:17:31.395
I'm actually going to, once
again, refresh the page.

00:17:31.395 --> 00:17:33.770
Normally, when you're doing
any sort of memory profiling,

00:17:33.770 --> 00:17:36.920
you probably want to start off
with what we call a clean room

00:17:36.920 --> 00:17:38.170
testing environment.

00:17:38.170 --> 00:17:40.740
What that means is that you
should be working in a brand

00:17:40.740 --> 00:17:43.850
new user profile, without
any extensions enabled.

00:17:43.850 --> 00:17:46.566
Incognito is OK,
but there are still

00:17:46.566 --> 00:17:48.440
extensions that you can
end up running there,

00:17:48.440 --> 00:17:50.460
and your extensions
can end up actually

00:17:50.460 --> 00:17:52.240
impacting your
performance scores.

00:17:52.240 --> 00:17:54.940
So regardless of whether
you're doing memory profiling

00:17:54.940 --> 00:17:57.580
or you're trying to
take a look at what's

00:17:57.580 --> 00:17:59.680
going on with your
frame rate, make sure

00:17:59.680 --> 00:18:02.790
you're generally working in
a clean testing environment.

00:18:02.790 --> 00:18:05.500
So here what we're
going to do is

00:18:05.500 --> 00:18:08.120
we're going take
some heap snapshots.

00:18:08.120 --> 00:18:11.220
So I'm gonna take a
snapshot before this action.

00:18:11.220 --> 00:18:12.890
Go in, create some nodes.

00:18:12.890 --> 00:18:14.660
Take one right after.

00:18:14.660 --> 00:18:17.250
Take a look at the comparison.

00:18:17.250 --> 00:18:20.100
And if I scroll
down here, let's see

00:18:20.100 --> 00:18:21.570
if there's anything of interest.

00:18:21.570 --> 00:18:23.100
So at the very
bottom, you can see

00:18:23.100 --> 00:18:25.580
that we have our
detached DOM tree.

00:18:25.580 --> 00:18:27.650
Now, you're probably
going to be doing

00:18:27.650 --> 00:18:30.290
this on a much larger
screen if you're at work,

00:18:30.290 --> 00:18:32.700
but it's usually
good to actually

00:18:32.700 --> 00:18:34.355
have DevTools fully open.

00:18:34.355 --> 00:18:36.410
Like, on a second screen,
so you can take a look

00:18:36.410 --> 00:18:37.640
at all the details here.

00:18:37.640 --> 00:18:39.970
But if we expand the
detached DOM tree here,

00:18:39.970 --> 00:18:41.840
what you'll notice is
that the leaf nodes

00:18:41.840 --> 00:18:44.520
array that Rob was talking
about is actually visible here,

00:18:44.520 --> 00:18:47.060
so it is in fact leaking.

00:18:47.060 --> 00:18:50.440
You take a look at the sources
for what he's doing here,

00:18:50.440 --> 00:18:52.930
and-- I'm not sure
which example this is.

00:18:52.930 --> 00:18:58.960
I guess this one. -- Actually,
I've got I've got some slides

00:18:58.960 --> 00:19:00.350
on this.

00:19:00.350 --> 00:19:02.650
So this is to do with DOM leaks.

00:19:02.650 --> 00:19:06.740
So what we have here is a
graph that basically talks

00:19:06.740 --> 00:19:10.380
about a page containing
a parent div,

00:19:10.380 --> 00:19:17.050
with the ID tree, and a child's
a-link with the ID "leaf."

00:19:17.050 --> 00:19:19.167
And if we walk through
what's happening here,

00:19:19.167 --> 00:19:21.000
what you'll see is that,
well, first of all,

00:19:21.000 --> 00:19:25.140
just going and selecting
"tree," we're selecting "leaf."

00:19:25.140 --> 00:19:26.920
We're selecting "body."

00:19:26.920 --> 00:19:30.740
We're, first of all, trying
to remove a reference to tree.

00:19:30.740 --> 00:19:32.470
We're thinking,
OK, well, normally

00:19:32.470 --> 00:19:34.990
you'd imagine that actually
cleans up everything.

00:19:34.990 --> 00:19:38.610
But tree isn't able to get
properly garbage collected,

00:19:38.610 --> 00:19:41.370
because tree ref is actually
still being referenced up here.

00:19:41.370 --> 00:19:44.590
And so to fix that, we
set tree ref to "null."

00:19:44.590 --> 00:19:46.692
Now unfortunately, it
still can't be correctly

00:19:46.692 --> 00:19:48.650
garbage collected at that
point because there's

00:19:48.650 --> 00:19:52.400
an indirect reference
to tree from leaf ref.

00:19:52.400 --> 00:19:54.860
So you see here we're still
trying to reference something

00:19:54.860 --> 00:19:58.330
that is a part of tree so
you have to also set leaf ref

00:19:58.330 --> 00:20:00.063
to null in order
for this entire tree

00:20:00.063 --> 00:20:03.360
to be properly
garbage collected.

00:20:03.360 --> 00:20:05.440
Let's take a quick
look at closures

00:20:05.440 --> 00:20:08.800
before we dive into
some more V8 stuff.

00:20:08.800 --> 00:20:12.940
So Paul asks, "How do
I analyze the impact

00:20:12.940 --> 00:20:17.110
of closures on memory?

00:20:17.110 --> 00:20:17.770
I'm lazy.

00:20:17.770 --> 00:20:20.370
Can I have explanation or demo?"

00:20:20.370 --> 00:20:21.770
All right.

00:20:21.770 --> 00:20:23.960
How about I give
him an explanation?

00:20:23.960 --> 00:20:26.880
Right so, closures
are pretty powerful.

00:20:26.880 --> 00:20:29.880
They enable us to use inner
functions to retain access

00:20:29.880 --> 00:20:33.560
to outer function variables,
even after the outer function

00:20:33.560 --> 00:20:34.570
is returned.

00:20:34.570 --> 00:20:36.880
Unfortunately,
closures also happens

00:20:36.880 --> 00:20:39.480
to be excellent at hiding
circular references

00:20:39.480 --> 00:20:42.580
to JavaScript objects and DOM
objects, which can sometimes

00:20:42.580 --> 00:20:45.406
be something that
leads to memory leaks.

00:20:45.406 --> 00:20:46.780
So if you're using
closures, just

00:20:46.780 --> 00:20:48.654
make sure that you
understand what references

00:20:48.654 --> 00:20:51.050
are retained inside the closure.

00:20:51.050 --> 00:20:54.370
In this particular case,
we have three examples

00:20:54.370 --> 00:20:56.690
of more or less
something very similar.

00:20:56.690 --> 00:21:01.710
But we happen to be using
"eval" in the very last example,

00:21:01.710 --> 00:21:05.000
and we're passing
through an argument

00:21:05.000 --> 00:21:07.980
to our function in
such a way that there's

00:21:07.980 --> 00:21:11.490
going to be constantly a
reference to our large string

00:21:11.490 --> 00:21:13.570
or anything that is
passed [INAUDIBLE] there.

00:21:13.570 --> 00:21:15.570
That is going to make it
very difficult for that

00:21:15.570 --> 00:21:17.640
to be properly cleaned up.

00:21:17.640 --> 00:21:19.280
Your inner functions
and your closures

00:21:19.280 --> 00:21:20.500
usually need to
be able to access

00:21:20.500 --> 00:21:22.250
all the variables for
the outer functions,

00:21:22.250 --> 00:21:25.796
meaning that as long as
a reference to it exists,

00:21:25.796 --> 00:21:27.170
variables from
the outer function

00:21:27.170 --> 00:21:29.000
can be correctly
garbage collected.

00:21:29.000 --> 00:21:33.630
And so they'll continue
to consume memory,

00:21:33.630 --> 00:21:36.140
and so after those
functions have completed,

00:21:36.140 --> 00:21:38.230
invoking, which might
mean a memory leak.

00:21:38.230 --> 00:21:42.920
So just be careful
with closures as well.

00:21:42.920 --> 00:21:45.740
So we've covered DOM leaks,
we've covered closures.

00:21:45.740 --> 00:21:46.970
Quick tip to do a timer.

00:21:46.970 --> 00:21:49.040
So timers can also
be something that

00:21:49.040 --> 00:21:50.790
are a little bit
tricky to deal with.

00:21:50.790 --> 00:21:53.960
Anything you're doing
repetitively, inside a timer,

00:21:53.960 --> 00:21:55.790
can be anything
that is left running

00:21:55.790 --> 00:21:58.570
for quite a long time, that you
need to be pretty careful with.

00:21:58.570 --> 00:22:01.960
If you've got something like a
slide show that loops forever,

00:22:01.960 --> 00:22:04.450
just make sure nothing in
the slide show itself still

00:22:04.450 --> 00:22:07.820
maintains references to DOM
objects that could accumulate

00:22:07.820 --> 00:22:11.740
leaks if they
happened to be GC'd.

00:22:11.740 --> 00:22:14.750
I wanted to quickly
mention ES6 WeakMaps.

00:22:14.750 --> 00:22:17.100
Has anyone here heard
of WeakMaps before?

00:22:17.100 --> 00:22:18.190
Or used them?

00:22:18.190 --> 00:22:19.660
Awesome.

00:22:19.660 --> 00:22:24.370
Right, so the idea here is
that we have basically two

00:22:24.370 --> 00:22:28.276
ways of defining private
member data for a class.

00:22:28.276 --> 00:22:29.400
We have two-person classes.

00:22:29.400 --> 00:22:31.060
They're basically
doing the same thing.

00:22:31.060 --> 00:22:33.040
This is your typical
classical example

00:22:33.040 --> 00:22:37.450
of having a nodule with
private data on public data.

00:22:37.450 --> 00:22:40.630
So a person has a closure that
captures some private data.

00:22:40.630 --> 00:22:43.050
And that private data--
so, in this example,

00:22:43.050 --> 00:22:45.030
on the left where we
see our private data,

00:22:45.030 --> 00:22:47.500
so you see that VAR privateData?

00:22:47.500 --> 00:22:50.250
That is basically
a strong reference.

00:22:50.250 --> 00:22:53.080
The garbage collector is only
able to collect an object

00:22:53.080 --> 00:22:55.110
if there are only
weak references to it,

00:22:55.110 --> 00:22:57.380
or no reference to it at all.

00:22:57.380 --> 00:22:58.800
The WeakMap version
of this-- so,

00:22:58.800 --> 00:23:01.840
WeakMaps are basically
something that come in ES6.

00:23:01.840 --> 00:23:04.289
The WeakMap version
holds keys weakly,

00:23:04.289 --> 00:23:06.330
and that basically means
that the person instance

00:23:06.330 --> 00:23:10.230
and its private data are
eligible for garbage collection

00:23:10.230 --> 00:23:12.580
when a person object is no
longer referenced by the rest

00:23:12.580 --> 00:23:15.540
of the application it's
basically just a new type that

00:23:15.540 --> 00:23:19.090
helps us avoid memory leak
situations a little bit more

00:23:19.090 --> 00:23:21.580
easily than we have with ES5.

00:23:21.580 --> 00:23:24.750
Just an example of where the
language is trying to help you

00:23:24.750 --> 00:23:27.980
avoid shooting
yourself in the foot.

00:23:27.980 --> 00:23:32.180
So we've walked through
some very quick demos.

00:23:32.180 --> 00:23:35.197
I've got a little bit of
a cheat sheet for you.

00:23:35.197 --> 00:23:36.780
Some people are
really stoked whenever

00:23:36.780 --> 00:23:39.240
they hear that there are
cheats available for something,

00:23:39.240 --> 00:23:42.546
so maybe you'll be
excited about that too.

00:23:42.546 --> 00:23:43.920
So this is the
way that I usually

00:23:43.920 --> 00:23:46.420
approach any sort of memory
profiling or performance

00:23:46.420 --> 00:23:47.960
optimization.

00:23:47.960 --> 00:23:49.640
Design first.

00:23:49.640 --> 00:23:50.640
Code from the design.

00:23:50.640 --> 00:23:52.790
And then profile the result.

00:23:52.790 --> 00:23:55.940
What this is all about
is simple designs

00:23:55.940 --> 00:23:59.180
are usually easier to optimize
if you follow this pattern.

00:23:59.180 --> 00:24:01.400
Sometimes profiling
can reveal problems

00:24:01.400 --> 00:24:03.520
that you don't find
when you go and do

00:24:03.520 --> 00:24:08.610
things like premature
optimization.

00:24:08.610 --> 00:24:10.610
Premature optimization
is definitely

00:24:10.610 --> 00:24:11.490
the root of all evil.

00:24:11.490 --> 00:24:14.260
Whatever you take away from
this talk today please make sure

00:24:14.260 --> 00:24:16.760
you're trying to make sure that
your code and the solutions

00:24:16.760 --> 00:24:19.970
to your code make as much sense
as possible first before you go

00:24:19.970 --> 00:24:22.254
and try designing
for performance.

00:24:22.254 --> 00:24:24.420
You can always apply those
performance optimizations

00:24:24.420 --> 00:24:26.610
the very end.

00:24:26.610 --> 00:24:29.180
So don't let performance
considerations

00:24:29.180 --> 00:24:31.070
affect the design
of a piece of code.

00:24:31.070 --> 00:24:34.880
That can sometimes result in
code that is not as visually

00:24:34.880 --> 00:24:37.610
pleasing to look at and
deal with as is possible,

00:24:37.610 --> 00:24:41.190
because you were complicated
it with the optimization.

00:24:41.190 --> 00:24:44.464
So here's my memory checklist.

00:24:44.464 --> 00:24:46.130
The first thing you
need to ask yourself

00:24:46.130 --> 00:24:48.130
whenever you think you
might have a memory issue

00:24:48.130 --> 00:24:50.370
is, "Is my app using
too much memory?"

00:24:50.370 --> 00:24:53.170
The timeline memory view
and Chrome Task Manager

00:24:53.170 --> 00:24:55.570
can help you identify if
you're using too much memory.

00:24:55.570 --> 00:24:57.486
Remember that memory
view gives you everything

00:24:57.486 --> 00:25:01.730
from tracking objects that are
allocated, to live DOM nodes,

00:25:01.730 --> 00:25:04.390
to JavaScript event listeners
and the inspected render

00:25:04.390 --> 00:25:05.780
process.

00:25:05.780 --> 00:25:08.270
"Is my app free
of memory leaks?"

00:25:08.270 --> 00:25:10.230
Use the object
allocation tracker.

00:25:10.230 --> 00:25:12.770
Object allocation tracker can
help you narrow down leaks,

00:25:12.770 --> 00:25:17.100
looks at the JavaScript object
allocation in real time.

00:25:17.100 --> 00:25:18.710
You could also use
the heap profiler

00:25:18.710 --> 00:25:21.540
to take heap snapshots,
analyze memory graphs,

00:25:21.540 --> 00:25:24.200
and compare snapshots to
discover what objects are not

00:25:24.200 --> 00:25:27.140
being cleaned up by
garbage collection.

00:25:27.140 --> 00:25:30.340
"How frequently is my app
forcing garbage collection?"

00:25:30.340 --> 00:25:32.520
If you're GCing
pretty frequently,

00:25:32.520 --> 00:25:34.830
you may be allocating
too frequently.

00:25:34.830 --> 00:25:37.240
So use the timeline memory
view once again just

00:25:37.240 --> 00:25:41.540
to help you identify pauses
that are of interest.

00:25:41.540 --> 00:25:43.980
There are some good rules
that you can follow.

00:25:43.980 --> 00:25:46.540
Avoid long-lasting
references to DOM elements

00:25:46.540 --> 00:25:47.710
you no longer need.

00:25:47.710 --> 00:25:48.720
DOM leaks really suck.

00:25:48.720 --> 00:25:51.860
They can sometimes be a
little bit tricky to discover.

00:25:51.860 --> 00:25:54.360
But as long as you're keeping
an eye on any references

00:25:54.360 --> 00:25:56.460
you're making to elements,
and especially when

00:25:56.460 --> 00:25:59.230
you're in loops, you're
making sure to either nullify

00:25:59.230 --> 00:26:00.850
those references
when you're done

00:26:00.850 --> 00:26:03.760
or not make those references
in the first place.

00:26:03.760 --> 00:26:06.620
That that's even better.

00:26:06.620 --> 00:26:08.810
Properties of objects
like DOM objects

00:26:08.810 --> 00:26:11.450
might contain references
to other objects

00:26:11.450 --> 00:26:14.660
or JavaScript objects they
contain references to others.

00:26:14.660 --> 00:26:16.660
That can end up causing
circular reference

00:26:16.660 --> 00:26:18.720
issues that can lead to leaks.

00:26:18.720 --> 00:26:22.680
V8 is really, really
awesome at getting around

00:26:22.680 --> 00:26:24.740
some of these issues
for you, but it's always

00:26:24.740 --> 00:26:26.750
good to just keep
these in mind when

00:26:26.750 --> 00:26:28.840
you're developing your apps.

00:26:28.840 --> 00:26:31.220
Better than de-referencing,
use local scopes,

00:26:31.220 --> 00:26:33.320
unbind events that
are needed anymore,

00:26:33.320 --> 00:26:35.760
so unbind those event listeners.

00:26:35.760 --> 00:26:37.910
Be careful when you're
storing large chunks of data

00:26:37.910 --> 00:26:39.280
you're not going to use.

00:26:39.280 --> 00:26:40.690
So this is
particularly important

00:26:40.690 --> 00:26:44.150
when you're looking at anything
like storing data offline,

00:26:44.150 --> 00:26:47.590
storing data for a
temporary user session.

00:26:47.590 --> 00:26:49.510
Make sure nothing
really large gets cached

00:26:49.510 --> 00:26:50.840
that you don't want to cache.

00:26:50.840 --> 00:26:54.560
Make sure that your caches don't
accumulate forever, and have

00:26:54.560 --> 00:26:56.750
an aging mechanism to
get rid of old objects.

00:26:56.750 --> 00:26:58.416
Because a lot of time
and you can end up

00:26:58.416 --> 00:27:00.810
catching large sets of
data that the user is never

00:27:00.810 --> 00:27:02.922
going to need to
reuse once again.

00:27:02.922 --> 00:27:04.380
So just be careful
with that stuff.

00:27:04.380 --> 00:27:06.160
Manage your local
cache adequately.

00:27:08.730 --> 00:27:11.152
So we've been looking at a
little bit of DevTools stuff.

00:27:11.152 --> 00:27:13.110
I'm going to spend a
little bit of time talking

00:27:13.110 --> 00:27:17.380
about the conceptual material
of how JavaScript manages memory

00:27:17.380 --> 00:27:18.770
in V8.

00:27:18.770 --> 00:27:22.140
To explain some of the stuff
that we saw in our demos.

00:27:22.140 --> 00:27:25.850
For anyone that hasn't
quite grokked it yet:

00:27:25.850 --> 00:27:27.440
why does perf matter?

00:27:27.440 --> 00:27:29.950
Well, first of all, we
care about delivering

00:27:29.950 --> 00:27:30.730
silky smooth apps.

00:27:30.730 --> 00:27:33.080
Everyone wants happy users
and silky smooth apps

00:27:33.080 --> 00:27:34.270
can help us get there.

00:27:34.270 --> 00:27:36.960
We want longer battery
life, smoother interactions.

00:27:36.960 --> 00:27:39.510
We want our apps to
live as long as possible

00:27:39.510 --> 00:27:43.680
without having to worry
about them crashing.

00:27:43.680 --> 00:27:45.060
Nothing is free.

00:27:45.060 --> 00:27:46.676
So the fastest
page-- does anyone

00:27:46.676 --> 00:27:49.320
know what the fastest
page on the web is?

00:27:49.320 --> 00:27:50.250
Anyone at all?

00:27:53.090 --> 00:27:54.470
It's about blank.

00:27:54.470 --> 00:27:56.770
That is the fastest
page on the web.

00:27:56.770 --> 00:27:58.430
Anything that we
add on to that page

00:27:58.430 --> 00:28:00.580
actually is making it slower.

00:28:00.580 --> 00:28:01.720
So nothing is free.

00:28:01.720 --> 00:28:03.410
Use tools like the
Task Manager to keep

00:28:03.410 --> 00:28:05.209
an eye on what
resources you're using,

00:28:05.209 --> 00:28:06.750
because you're always
going to end up

00:28:06.750 --> 00:28:10.416
paying some price
for those resources.

00:28:10.416 --> 00:28:11.790
If you take a look
at this, these

00:28:11.790 --> 00:28:14.390
are some stats from last year.

00:28:14.390 --> 00:28:16.950
Google apps-- so things
like Gmail, Docs--

00:28:16.950 --> 00:28:19.820
spend about 50 to 70%
of our time in V8.

00:28:19.820 --> 00:28:22.810
A lot of popular sites spend
somewhere between 20 to 40%

00:28:22.810 --> 00:28:25.340
of their time in V8 on
JavaScript app distribution

00:28:25.340 --> 00:28:25.880
time.

00:28:25.880 --> 00:28:27.310
So it's still an area that.

00:28:27.310 --> 00:28:32.230
If you end up having leaks, is
worth actually optimizing on.

00:28:32.230 --> 00:28:36.510
As Nat covered in his
talk, most the time

00:28:36.510 --> 00:28:38.540
we're trying to hit
60 frames a second

00:28:38.540 --> 00:28:41.650
in our apps to deliver on
those smooth experiences.

00:28:41.650 --> 00:28:43.720
That basically gives
us 16 milliseconds

00:28:43.720 --> 00:28:45.650
to get everything done in.

00:28:45.650 --> 00:28:47.570
So for Chrome's
workload, we're looking

00:28:47.570 --> 00:28:50.990
at 16 milliseconds for
dealing with loading data,

00:28:50.990 --> 00:28:54.140
parsing HTML, dealing with the
layout of the page, JavaScript

00:28:54.140 --> 00:28:55.800
execution.

00:28:55.800 --> 00:28:57.640
Anything that ends
up slowing that down

00:28:57.640 --> 00:29:00.630
is going to result in your
user seeing pauses and jitter.

00:29:00.630 --> 00:29:03.670
And that's going to basically
mean them seeing jank.

00:29:03.670 --> 00:29:04.270
Right?

00:29:04.270 --> 00:29:07.965
So jank manifests itself when
you blow your frame budget.

00:29:07.965 --> 00:29:09.840
If you are able to
complete within that time,

00:29:09.840 --> 00:29:11.589
you're going to end
up missing your frame,

00:29:11.589 --> 00:29:14.360
and your animations are going
to end up seeming sort of janky.

00:29:14.360 --> 00:29:16.730
So visually slow to your users.

00:29:16.730 --> 00:29:19.000
We don't want that.

00:29:19.000 --> 00:29:20.730
Blow your memory
completely and you're

00:29:20.730 --> 00:29:24.660
going to end up seeing the
"He's dead, Jim" message.

00:29:24.660 --> 00:29:27.080
The friendliest message ever.

00:29:27.080 --> 00:29:29.840
Which basically means that the
operating system has terminated

00:29:29.840 --> 00:29:31.800
your tab because it's
run out of memory.

00:29:31.800 --> 00:29:34.680
Again, something that
we don't want to happen.

00:29:34.680 --> 00:29:39.510
And we can prevent by
avoiding memory leaks.

00:29:39.510 --> 00:29:43.280
Whenever it comes to the
performance versus memory

00:29:43.280 --> 00:29:45.370
battle, we've
always got one side

00:29:45.370 --> 00:29:48.357
the says, "You can always
throw more memory at a problem.

00:29:48.357 --> 00:29:50.440
You know, I don't need to
worry about memory leaks

00:29:50.440 --> 00:29:53.290
because I'm just going to
add another 16 gigs of memory

00:29:53.290 --> 00:29:54.140
to my system."

00:29:54.140 --> 00:29:55.376
Right?

00:29:55.376 --> 00:29:56.750
But unfortunately,
the reality is

00:29:56.750 --> 00:29:58.650
that this isn't a
problem that can just

00:29:58.650 --> 00:30:00.820
be solved by throwing
more memory at it.

00:30:00.820 --> 00:30:04.560
You think about your grandma,
that maybe has a Chromebook.

00:30:04.560 --> 00:30:07.760
Maybe that only has four gigs
of memory on it, or 8 gigs,

00:30:07.760 --> 00:30:09.190
or whatever it is these days.

00:30:09.190 --> 00:30:12.360
That has significantly
less than your development

00:30:12.360 --> 00:30:16.010
system at work that has 32 or
64 gigs of memory, whatever

00:30:16.010 --> 00:30:18.160
it is you crazy kids have today.

00:30:18.160 --> 00:30:20.510
But whenever it comes down
to the old age performance

00:30:20.510 --> 00:30:22.790
versus memory trade-off,
offer performance.

00:30:22.790 --> 00:30:26.130
Let's try to get it
great for everybody.

00:30:26.130 --> 00:30:29.555
So let's take a look at some
memory management basics.

00:30:31.857 --> 00:30:33.690
So here's what we're
going to be looking at.

00:30:33.690 --> 00:30:36.680
We're going to look at the
types of values that there are.

00:30:36.680 --> 00:30:38.580
How values are
organized in memory.

00:30:38.580 --> 00:30:39.600
What is garbage?

00:30:39.600 --> 00:30:44.210
And actually define
properly what is a leak.

00:30:44.210 --> 00:30:47.210
So JavaScript variables
can be four primary types.

00:30:47.210 --> 00:30:50.260
We have Boolean, number,
string, and objects.

00:30:50.260 --> 00:30:52.460
So the Boolean type is
really just true or false.

00:30:52.460 --> 00:30:53.690
You guys already know that.

00:30:53.690 --> 00:30:56.235
Number type is basically
any double position floating

00:30:56.235 --> 00:30:56.735
number.

00:30:56.735 --> 00:31:00.780
You've got the string, which
is a UTF-16 encoded character

00:31:00.780 --> 00:31:01.430
array.

00:31:01.430 --> 00:31:02.805
And then you've
got your objects,

00:31:02.805 --> 00:31:04.381
which are like a key value map.

00:31:04.381 --> 00:31:04.880
Right?

00:31:04.880 --> 00:31:07.840
So those are the
four primitive types.

00:31:07.840 --> 00:31:10.850
Objects are built around
key value mapping.

00:31:10.850 --> 00:31:12.490
The key goes into
the square brackets,

00:31:12.490 --> 00:31:15.170
and this is always a
string, unless you're

00:31:15.170 --> 00:31:18.370
talking about ES6
maps, which allow

00:31:18.370 --> 00:31:20.540
you to have non-string
keys, but we're not

00:31:20.540 --> 00:31:22.320
going to talk about that.

00:31:22.320 --> 00:31:25.340
No matter what you put
into those brackets

00:31:25.340 --> 00:31:28.290
it's going to end up being
coerced into a string.

00:31:28.290 --> 00:31:31.170
And then you use that as
sort of a look-up table.

00:31:31.170 --> 00:31:33.170
And then for that value,
you can store basically

00:31:33.170 --> 00:31:37.700
any JavaScript object
inside of that value.

00:31:37.700 --> 00:31:40.150
So think of memory as a graph.

00:31:40.150 --> 00:31:42.780
The memory graph is a
pretty fundamental concept

00:31:42.780 --> 00:31:45.790
when it comes to trying
to understand how browsers

00:31:45.790 --> 00:31:47.405
handle JavaScript performance.

00:31:50.390 --> 00:31:52.750
So think of memory as a
graph with primitive types.

00:31:52.750 --> 00:31:55.310
So those numbers, those
strings, those objects

00:31:55.310 --> 00:31:56.309
we were talking about.

00:31:56.309 --> 00:31:58.100
It could visually be
represented as a graph

00:31:58.100 --> 00:32:00.960
with a number of
interconnected points that

00:32:00.960 --> 00:32:02.650
look a little bit like this.

00:32:02.650 --> 00:32:05.470
So we're looking at a whole
bunch of circles here,

00:32:05.470 --> 00:32:07.120
and lines on this side.

00:32:07.120 --> 00:32:10.830
But let's start from the
left of the blue circle here.

00:32:10.830 --> 00:32:11.980
So the root node.

00:32:11.980 --> 00:32:14.870
This is the root object that's
inside the memory management

00:32:14.870 --> 00:32:15.400
system.

00:32:15.400 --> 00:32:18.870
It's not something you can
explicitly manipulate or do

00:32:18.870 --> 00:32:20.140
anything crazy with.

00:32:20.140 --> 00:32:24.040
But this is just where every
object you create descends from

00:32:24.040 --> 00:32:25.770
and it's also called the root.

00:32:25.770 --> 00:32:29.350
From that root it
references global variables.

00:32:29.350 --> 00:32:32.370
The red objects here
are object variables.

00:32:32.370 --> 00:32:34.180
So those can reference
other variables.

00:32:34.180 --> 00:32:36.580
And the green
circles are scalar.

00:32:36.580 --> 00:32:38.030
Scalar variables.

00:32:38.030 --> 00:32:40.420
Like a Boolean, or
a number, and that

00:32:40.420 --> 00:32:42.760
can't really reference
anything else.

00:32:42.760 --> 00:32:44.990
And you can see the green
node at the very end here.

00:32:44.990 --> 00:32:47.500
I'm not sure if my
cursor is visible.

00:32:47.500 --> 00:32:50.800
That green note at the end here
at the upper part of the screen

00:32:50.800 --> 00:32:52.760
is basically the
terminating node

00:32:52.760 --> 00:32:55.900
in this part of
the object graph.

00:32:55.900 --> 00:33:00.010
So objects have a concept
of a retaining tree.

00:33:00.010 --> 00:33:02.300
This is the path
along the graph that

00:33:02.300 --> 00:33:04.920
are keeping the object from
being classified as memory.

00:33:04.920 --> 00:33:06.390
So on this side
right now you can

00:33:06.390 --> 00:33:10.070
see that we have a green
node over here in the center.

00:33:10.070 --> 00:33:14.610
Let's look at its retaining
tree for this green node.

00:33:14.610 --> 00:33:17.110
So the retaining tree
for this green node

00:33:17.110 --> 00:33:20.240
is this yellow node right
here, the root node.

00:33:20.240 --> 00:33:23.500
As well as this other
path from the root

00:33:23.500 --> 00:33:26.510
to the other yellow
node, and the other

00:33:26.510 --> 00:33:29.480
actually has to pass through it
or it can get pinned in memory.

00:33:29.480 --> 00:33:31.130
If both of those
paths are terminated,

00:33:31.130 --> 00:33:33.140
then the object becomes
garbage collected

00:33:33.140 --> 00:33:36.230
and it's eventually
correctly collected up.

00:33:39.290 --> 00:33:41.646
So what about removing
a value from that graph?

00:33:41.646 --> 00:33:43.270
Well, this is a fairly
basic operation.

00:33:43.270 --> 00:33:44.874
It is sort of
important to understand

00:33:44.874 --> 00:33:46.540
how you can remove a
value from a graph.

00:33:46.540 --> 00:33:49.410
So if we want to
remove the red value,

00:33:49.410 --> 00:33:52.210
so this value at the
very end right here--

00:33:52.210 --> 00:33:54.000
if you want to remove
that from the graph,

00:33:54.000 --> 00:33:57.420
we could cut this edge right
here from the root node

00:33:57.420 --> 00:33:59.050
to the first green node.

00:33:59.050 --> 00:34:01.950
And then the red
value becomes garbage.

00:34:01.950 --> 00:34:04.650
If we cut this edge
it's also garbage.

00:34:04.650 --> 00:34:06.150
Or we cut this edge.

00:34:06.150 --> 00:34:07.940
Basically, any of
these edges cut

00:34:07.940 --> 00:34:11.257
would make the red node garbage.

00:34:11.257 --> 00:34:12.840
And that brings us
on to that question

00:34:12.840 --> 00:34:15.030
of, "What exactly is garbage?"

00:34:15.030 --> 00:34:15.699
Right?

00:34:15.699 --> 00:34:18.790
Well, it's all values that can't
be reached from the root node.

00:34:18.790 --> 00:34:21.080
Or, if we say it
another way, it's

00:34:21.080 --> 00:34:22.969
all values that are
lacking any sort

00:34:22.969 --> 00:34:25.170
of retaining path in the system.

00:34:25.170 --> 00:34:27.360
So if something doesn't
have a retaining path,

00:34:27.360 --> 00:34:29.179
then it becomes garbage
like these nodes

00:34:29.179 --> 00:34:30.890
that you see right here.

00:34:30.890 --> 00:34:34.330
So you'll see that here
there's no path from the root

00:34:34.330 --> 00:34:37.070
nodes, these values.

00:34:37.070 --> 00:34:41.690
So these values are
properly garbage collected.

00:34:41.690 --> 00:34:43.949
What about garbage collection?

00:34:43.949 --> 00:34:45.719
At the next garbage
collection process

00:34:45.719 --> 00:34:47.510
for these nodes that
we're talking about,

00:34:47.510 --> 00:34:49.000
they're going to be
cleaned up, and that

00:34:49.000 --> 00:34:51.416
brings us to try to explain
what garbage collection is all

00:34:51.416 --> 00:34:52.210
about.

00:34:52.210 --> 00:34:54.210
The first step in
garbage collection

00:34:54.210 --> 00:34:57.150
is to find all of the
live values in the system.

00:34:57.150 --> 00:34:59.130
The second is to
return the memory used

00:34:59.130 --> 00:35:00.780
by the dead values
back to the system

00:35:00.780 --> 00:35:02.830
so they can be
recycled later on.

00:35:02.830 --> 00:35:03.790
As we see here.

00:35:08.840 --> 00:35:10.940
And there they go.

00:35:10.940 --> 00:35:13.510
What about a value's
retained size?

00:35:13.510 --> 00:35:16.350
So another property that
basically every value

00:35:16.350 --> 00:35:19.360
inside of JavaScript has
is its retained size.

00:35:19.360 --> 00:35:21.930
So the retained size you could
probably conceptually think

00:35:21.930 --> 00:35:24.670
about as the amount of
memory that would be free

00:35:24.670 --> 00:35:27.910
if the value went
and became garbage.

00:35:27.910 --> 00:35:30.720
And if so, that's the size the
value and its descendants would

00:35:30.720 --> 00:35:31.930
lack retaining paths.

00:35:36.620 --> 00:35:38.480
And so if we look
at the yellow node

00:35:38.480 --> 00:35:41.370
on this graph, its retained
size of this new yellow node,

00:35:41.370 --> 00:35:45.730
is both of the green
node size plus itself.

00:35:45.730 --> 00:35:49.340
And if we go all the way
back to the root node,

00:35:49.340 --> 00:35:51.350
the retained size is
all of the memory that's

00:35:51.350 --> 00:35:54.690
being used by your JavaScript.

00:35:54.690 --> 00:35:58.620
Which takes on to, "What
is actually a memory leak?"

00:35:58.620 --> 00:36:00.340
Well, a memory leak
is something that's

00:36:00.340 --> 00:36:03.740
existed in basically any sort
of computer system ever created.

00:36:03.740 --> 00:36:05.620
But the idea is that
it's a gradual loss

00:36:05.620 --> 00:36:07.570
of the available system memory.

00:36:07.570 --> 00:36:10.300
It occurs when you've
mistakenly left a retaining path

00:36:10.300 --> 00:36:12.360
to some value
inside of that graph

00:36:12.360 --> 00:36:13.730
that we were talking about.

00:36:13.730 --> 00:36:15.300
So JavaScript web
apps can usually

00:36:15.300 --> 00:36:18.790
suffer from similar
memory-related issues

00:36:18.790 --> 00:36:22.630
that you'll see in native apps,
mobile apps, Android apps.

00:36:22.630 --> 00:36:25.290
Leaks to do with bloat, but also
to do with garbage collection

00:36:25.290 --> 00:36:25.790
pauses.

00:36:28.960 --> 00:36:33.970
So you might think that
the value has no path here.

00:36:33.970 --> 00:36:37.550
So a value that erroneously
still has a retaining path

00:36:37.550 --> 00:36:39.370
is something we need
to be concerned about.

00:36:39.370 --> 00:36:41.740
So you might think of the
value has no path, starting

00:36:41.740 --> 00:36:44.290
from the root node,
getting to it,

00:36:44.290 --> 00:36:46.970
and that will be collected
on the next round of garbage

00:36:46.970 --> 00:36:48.000
collection.

00:36:48.000 --> 00:36:50.640
But you're occasionally
and accidentally leaving

00:36:50.640 --> 00:36:51.820
a retaining path.

00:36:51.820 --> 00:36:53.360
And so you end up
with the situation

00:36:53.360 --> 00:36:54.755
of having a memory leak.

00:36:54.755 --> 00:36:56.880
So if we take a look at
this really simple example,

00:36:56.880 --> 00:36:59.220
it's a little bit
Gmail-themed, where

00:36:59.220 --> 00:37:01.970
we've got this email
message and we're basically

00:37:01.970 --> 00:37:04.470
appending it to a list.

00:37:04.470 --> 00:37:05.630
So we have an email object.

00:37:05.630 --> 00:37:07.930
We have this message
field inside of it.

00:37:07.930 --> 00:37:11.270
We assign that to a
div node in the DOM,

00:37:11.270 --> 00:37:13.900
and we then want to display
these email messages,

00:37:13.900 --> 00:37:18.790
so we add that div node into
the display list as well.

00:37:18.790 --> 00:37:20.520
So this is what the
object graph looks

00:37:20.520 --> 00:37:21.750
like after running this code.

00:37:21.750 --> 00:37:23.500
So that's a very
simplistic piece of code.

00:37:23.500 --> 00:37:25.890
This is what the object
graph looks like for it.

00:37:25.890 --> 00:37:28.000
So we're starting
at the root node. .

00:37:28.000 --> 00:37:30.810
There's paths to both
email and display.

00:37:30.810 --> 00:37:33.620
And then off to email,
there's a path to message,

00:37:33.620 --> 00:37:36.780
and there's this special
kind of edge from the message

00:37:36.780 --> 00:37:37.970
through to the div node.

00:37:37.970 --> 00:37:39.520
And this is pinning
a native object,

00:37:39.520 --> 00:37:41.103
so I'm trying to
highlight that there.

00:37:41.103 --> 00:37:43.590
That's pinning a native object,
an external object that's

00:37:43.590 --> 00:37:45.740
not directly related
to JavaScript,

00:37:45.740 --> 00:37:49.240
but it just looks
the way it does.

00:37:49.240 --> 00:37:51.340
So maybe the
programmer is trying

00:37:51.340 --> 00:37:53.150
to go and clean up
this list of messages

00:37:53.150 --> 00:37:56.670
and they'll do something like
display.removeAllChildren.

00:37:56.670 --> 00:38:00.080
And you think, OK, maybe
all these divs are gone.

00:38:00.080 --> 00:38:03.250
Maybe I don't have to worry
about this problem anymore.

00:38:03.250 --> 00:38:04.730
But whoops!

00:38:04.730 --> 00:38:06.350
Something has gone wrong!

00:38:06.350 --> 00:38:09.180
We've actually managed to cache
a reference from the message

00:38:09.180 --> 00:38:10.870
object to the div node.

00:38:10.870 --> 00:38:13.270
And so until the email
itself is removed

00:38:13.270 --> 00:38:15.520
from the system-- which
could take forever.

00:38:15.520 --> 00:38:17.817
We don't know when that's
actually going to happen.--

00:38:17.817 --> 00:38:19.650
The div node is going
to be pinned to memory

00:38:19.650 --> 00:38:21.610
and we've leaked it.

00:38:21.610 --> 00:38:24.225
Imagine this happening on a
system of a great scale, where

00:38:24.225 --> 00:38:26.350
you could have hundreds of
messages being loaded up

00:38:26.350 --> 00:38:27.260
at the same time.

00:38:27.260 --> 00:38:28.790
It could easily
escalate to a point

00:38:28.790 --> 00:38:31.500
where you're leaking so
much memory that you're not

00:38:31.500 --> 00:38:36.700
able to create new tabs, or your
current tab ends up crashing.

00:38:36.700 --> 00:38:39.450
So some memory management
basics that we've covered.

00:38:39.450 --> 00:38:42.100
In general, the basic idea
is that memory management

00:38:42.100 --> 00:38:45.820
in JavaScript, and all of
values organized inside a graph.

00:38:45.820 --> 00:38:47.520
So remember the graph?

00:38:47.520 --> 00:38:49.140
They can have retaining paths.

00:38:49.140 --> 00:38:53.080
Any value that lacks a
retaining path becomes garbage.

00:38:53.080 --> 00:38:56.479
And then there's retained sizes,
and that's the amount of memory

00:38:56.479 --> 00:38:58.270
that you're going to
free up when the value

00:38:58.270 --> 00:39:01.780
itself becomes garbage.

00:39:01.780 --> 00:39:04.940
Let's go from the general to the
specific and talk about the way

00:39:04.940 --> 00:39:08.570
that V8 manages memory and
what happens during a GC pause.

00:39:08.570 --> 00:39:10.320
We're then going to
talk a little bit more

00:39:10.320 --> 00:39:12.490
about DevTools tools
and just summarize

00:39:12.490 --> 00:39:14.698
some of the tools that are
going to be useful for you

00:39:14.698 --> 00:39:17.496
in your day to day workflow.

00:39:17.496 --> 00:39:18.870
So the first
question you usually

00:39:18.870 --> 00:39:20.980
ask yourself is, "What
is the cost of actually

00:39:20.980 --> 00:39:23.150
allocated memory in JavaScript?"

00:39:23.150 --> 00:39:25.110
And surprisingly,
it's not the "call

00:39:25.110 --> 00:39:27.460
to new"-- so going and creating
a new instance of class.

00:39:27.460 --> 00:39:28.900
It's actually not that.

00:39:28.900 --> 00:39:31.710
Typically, the call to new
is actually pretty fast.

00:39:31.710 --> 00:39:34.160
It's gotten much
faster in recent years.

00:39:34.160 --> 00:39:35.760
It's really fast
until you've gone

00:39:35.760 --> 00:39:38.902
and you've exhausted
your entire memory pool.

00:39:38.902 --> 00:39:40.610
And we'll get to this
in a moment, what's

00:39:40.610 --> 00:39:41.820
actually happening.

00:39:41.820 --> 00:39:43.820
But at that point
the runtime is forced

00:39:43.820 --> 00:39:45.570
to go and do a
garbage collection.

00:39:45.570 --> 00:39:47.250
And this is where all
the time is spent.

00:39:47.250 --> 00:39:49.550
It can actually
take milliseconds.

00:39:49.550 --> 00:39:52.404
So remember, if you're
trying to write a 60 fps app,

00:39:52.404 --> 00:39:54.570
and you've only got 16
milliseconds to do everything

00:39:54.570 --> 00:39:57.600
in, a garbage collection pause
might pause your application

00:39:57.600 --> 00:39:59.710
for five, maybe 10 milliseconds.

00:39:59.710 --> 00:40:02.160
Which for Gmail might
be OK, but for some apps

00:40:02.160 --> 00:40:03.530
it's really too long.

00:40:03.530 --> 00:40:05.920
As Nat mentioned, GC
pauses have become

00:40:05.920 --> 00:40:07.670
less of an issue
in recent years.

00:40:07.670 --> 00:40:12.140
But again, it's just something
that's useful to be aware of.

00:40:12.140 --> 00:40:14.880
So the next thing
we're going to cover

00:40:14.880 --> 00:40:19.210
is the young generation and
old generation concepts in V8.

00:40:19.210 --> 00:40:21.185
So V8 manages memory
in two generations.

00:40:21.185 --> 00:40:23.370
There's the young
and there's the old.

00:40:23.370 --> 00:40:25.344
The young generation
will probably

00:40:25.344 --> 00:40:26.885
be telling you, "Get
to the chopper!"

00:40:26.885 --> 00:40:28.676
And the old generation
will be telling you,

00:40:28.676 --> 00:40:30.874
"Get to the walker."

00:40:30.874 --> 00:40:31.540
That's terrible.

00:40:31.540 --> 00:40:32.530
I'm sorry.

00:40:32.530 --> 00:40:33.420
I apologize.

00:40:33.420 --> 00:40:35.960
That's the only terrible
joke I'm making today.

00:40:35.960 --> 00:40:36.581
Right.

00:40:36.581 --> 00:40:38.330
By young and old, what
do I actually mean?

00:40:38.330 --> 00:40:41.250
Well, by young and
old, I mean how long

00:40:41.250 --> 00:40:44.330
has the JavaScript value
existed for in the system?

00:40:44.330 --> 00:40:47.520
Over time, young values end up
getting promoted to old values,

00:40:47.520 --> 00:40:49.430
so after a few
garbage collections,

00:40:49.430 --> 00:40:51.310
if the value of an
object survives--

00:40:51.310 --> 00:40:53.510
meaning there's a
retaining path and it's

00:40:53.510 --> 00:40:56.910
kept in memory-- eventually that
value ends up getting promoted

00:40:56.910 --> 00:40:58.120
to the old generation.

00:40:58.120 --> 00:41:00.570
So as you can see,
young values end up

00:41:00.570 --> 00:41:02.900
getting translated into
old values over time.

00:41:06.290 --> 00:41:09.100
So what are the properties of
the young generation in V8?

00:41:09.100 --> 00:41:11.680
Well, it offers really
fast allocation.

00:41:11.680 --> 00:41:12.700
So young Arnie.

00:41:12.700 --> 00:41:14.800
Really fast allocation.

00:41:14.800 --> 00:41:16.944
It's frequently collected.

00:41:16.944 --> 00:41:18.860
In fact, if you're using
the DevTools Timeline

00:41:18.860 --> 00:41:20.740
you can usually see
the GC event on,

00:41:20.740 --> 00:41:23.095
so if you hover over one of
those bars in the timeline

00:41:23.095 --> 00:41:25.050
you can actually
see the GC events,

00:41:25.050 --> 00:41:27.510
and dive down into some more
information that will give you

00:41:27.510 --> 00:41:30.020
some insights that
can be useful.

00:41:30.020 --> 00:41:32.900
So those will give you some
hints on young generation

00:41:32.900 --> 00:41:34.970
collection.

00:41:34.970 --> 00:41:36.820
Then we've got the
old generation.

00:41:36.820 --> 00:41:39.560
In contrast, it
offers fast allocation

00:41:39.560 --> 00:41:42.640
but the collection is
usually a lot slower.

00:41:42.640 --> 00:41:45.079
The good thing is that it's
really infrequently collected,

00:41:45.079 --> 00:41:46.870
and some of the old
generation's collection

00:41:46.870 --> 00:41:50.080
occurs in parallel with
your page's execution.

00:41:50.080 --> 00:41:52.962
So whereas the young
generation is really

00:41:52.962 --> 00:41:55.170
just-- everything is stopped,
your collection occurs,

00:41:55.170 --> 00:41:57.570
then your page resumes--
the old generation mixes

00:41:57.570 --> 00:42:00.820
a little bit of collection
with your page's execution.

00:42:00.820 --> 00:42:03.200
I'm mostly going to be focusing
on the young generation

00:42:03.200 --> 00:42:04.783
here because that's
where you're going

00:42:04.783 --> 00:42:06.381
to feel the pain
inside your apps.

00:42:06.381 --> 00:42:08.130
And it's going to
happen pretty regularly.

00:42:08.130 --> 00:42:11.200
So let's try to cover it.

00:42:11.200 --> 00:42:13.460
So it's important
to understand why

00:42:13.460 --> 00:42:16.136
collecting the young generation
is a little bit faster.

00:42:16.136 --> 00:42:17.760
Intuitively, you
usually have to end up

00:42:17.760 --> 00:42:20.700
understanding that the
cost of the GC pause

00:42:20.700 --> 00:42:23.170
is actually proportional to
the number of live objects

00:42:23.170 --> 00:42:24.600
that you have in memory.

00:42:24.600 --> 00:42:27.650
Because objects get split
into the young generation

00:42:27.650 --> 00:42:29.880
and the old generation,
young generation

00:42:29.880 --> 00:42:32.560
actually doesn't
survive very long.

00:42:32.560 --> 00:42:35.330
So after a round of
garbage collection is run,

00:42:35.330 --> 00:42:37.310
most of the values in
the young generation

00:42:37.310 --> 00:42:38.570
don't actually make it.

00:42:38.570 --> 00:42:41.120
They have retaining path,
because they're just

00:42:41.120 --> 00:42:44.360
used briefly, short of
short-lived objects.

00:42:44.360 --> 00:42:45.750
They don't exist anymore.

00:42:45.750 --> 00:42:47.679
They're not really in the graph.

00:42:47.679 --> 00:42:49.970
Whereas, by their nature,
objects in the old generation

00:42:49.970 --> 00:42:52.240
have usually survived
quite a long time.

00:42:52.240 --> 00:42:54.684
So you can't expect when
a collection is triggered

00:42:54.684 --> 00:42:57.350
for the old generation that many
of them are going to disappear.

00:42:57.350 --> 00:43:00.600
They're going to be around
for quite some time.

00:43:00.600 --> 00:43:02.740
So knowing the cost of the
garbage collection pause

00:43:02.740 --> 00:43:04.930
really comes down to the
number of live objects.

00:43:04.930 --> 00:43:07.670
And it becomes quite clear why
collecting the young generation

00:43:07.670 --> 00:43:09.500
is so much faster.

00:43:09.500 --> 00:43:12.470
So let's take a look at the
young generation in action.

00:43:12.470 --> 00:43:16.840
So here the young generation
is split into two semi-spaces.

00:43:16.840 --> 00:43:20.720
There's the To space
and the From space.

00:43:20.720 --> 00:43:23.300
Now the To space is where
values that you allocate

00:43:23.300 --> 00:43:27.040
from your page get
executed, like the new fu.

00:43:27.040 --> 00:43:29.240
It's coming out of the To space.

00:43:29.240 --> 00:43:31.790
And the From space actually
just sits there not really

00:43:31.790 --> 00:43:33.290
being used until much later on.

00:43:33.290 --> 00:43:36.580
We'll see what happens
with it in just a second.

00:43:36.580 --> 00:43:39.090
So assuming that the To
space started off empty,

00:43:39.090 --> 00:43:40.980
and your page starts
allocating objects,

00:43:40.980 --> 00:43:43.130
so let's say that we're
allocating objects,

00:43:43.130 --> 00:43:45.463
we're going to name them
something simple, like A, B, C,

00:43:45.463 --> 00:43:47.420
D. Let's look at the allocation.

00:43:47.420 --> 00:43:52.840
So we go and we allocate
A, and then B, and then

00:43:52.840 --> 00:43:56.980
C, and finally D. And
everything up until this point

00:43:56.980 --> 00:43:58.500
has been really, really fast.

00:43:58.500 --> 00:44:02.650
And there's been no interruption
to your page's execution.

00:44:02.650 --> 00:44:05.570
But then your page goes
and it calls new E.

00:44:05.570 --> 00:44:09.010
And actually, it's just too big.

00:44:09.010 --> 00:44:10.500
It doesn't fit
into the To space.

00:44:10.500 --> 00:44:13.120
We've hit a threshold
in out system

00:44:13.120 --> 00:44:16.170
where we've moved incrementally
closer to this GC pause,

00:44:16.170 --> 00:44:17.950
and now we've
actually triggered it.

00:44:17.950 --> 00:44:21.510
So we've got to pause
inside of our app.

00:44:21.510 --> 00:44:24.030
So what happens is that
new E doesn't happen.

00:44:24.030 --> 00:44:25.644
It's kind of paused.

00:44:25.644 --> 00:44:27.060
So we're still in
this state where

00:44:27.060 --> 00:44:30.450
we just have A, B, C, and
D inside of our To space,

00:44:30.450 --> 00:44:31.570
and the page is paused.

00:44:31.570 --> 00:44:35.407
Everything halts and the
collection is then triggered.

00:44:35.407 --> 00:44:37.490
So the first step in a
young generation collection

00:44:37.490 --> 00:44:41.570
is that the From and the
To spaces get swapped.

00:44:41.570 --> 00:44:44.190
The labels to them
get flipped internally

00:44:44.190 --> 00:44:46.490
and the live value
is then found.

00:44:46.490 --> 00:44:49.330
I'm not going to go into too
much detail about this part

00:44:49.330 --> 00:44:51.300
of the system, but
everything that

00:44:51.300 --> 00:44:53.100
still has a retaining
path on the graph

00:44:53.100 --> 00:44:57.610
is discovered, and then
marked for copy at this point.

00:44:57.610 --> 00:45:00.910
So you can see here
that A and C are marked,

00:45:00.910 --> 00:45:03.996
and B and D have not been
marked, so they're garbage.

00:45:03.996 --> 00:45:05.120
They're not going anywhere.

00:45:05.120 --> 00:45:08.820
And this is most of where
our time ends up going.

00:45:08.820 --> 00:45:10.970
It's where the live
values end being copied

00:45:10.970 --> 00:45:13.570
from the From space
to the To space.

00:45:13.570 --> 00:45:14.290
So here we are.

00:45:14.290 --> 00:45:16.373
We've done the copying,
we've done the collection,

00:45:16.373 --> 00:45:18.670
we've just copied the live
objects from one semi-space

00:45:18.670 --> 00:45:20.635
to the next.

00:45:20.635 --> 00:45:22.760
And there's no other work
to be done at this point.

00:45:22.760 --> 00:45:24.810
It's just ready
for the next time

00:45:24.810 --> 00:45:28.090
there's a garbage collection
around that needs to happen.

00:45:28.090 --> 00:45:29.970
And at this point
your page is resumed

00:45:29.970 --> 00:45:32.210
and the object E is
allocated, so it's then

00:45:32.210 --> 00:45:34.960
able to actually do something.

00:45:34.960 --> 00:45:35.940
So quick summary.

00:45:35.940 --> 00:45:39.200
What you have to understand
is that each allocation in V8

00:45:39.200 --> 00:45:41.690
moves you closer to a
collection, so a garbage

00:45:41.690 --> 00:45:42.649
collection round.

00:45:42.649 --> 00:45:44.190
The trade-off we
talked about earlier

00:45:44.190 --> 00:45:46.126
between more memory
and performance?

00:45:46.126 --> 00:45:47.750
You start to see why
that doesn't quite

00:45:47.750 --> 00:45:49.090
hold up inside JavaScript.

00:45:49.090 --> 00:45:51.090
Because the more memory
you use, the faster

00:45:51.090 --> 00:45:52.799
you're going to get
to this actual pause.

00:45:52.799 --> 00:45:54.215
That's actually
where you're going

00:45:54.215 --> 00:45:55.830
to end up losing performance.

00:45:55.830 --> 00:45:58.030
So just try to take
some care there.

00:45:58.030 --> 00:46:00.300
Not only that, but the
more memory you're using,

00:46:00.300 --> 00:46:02.340
the longer that pause
is going to take.

00:46:02.340 --> 00:46:04.690
And the larger the heap,
the longer the collection

00:46:04.690 --> 00:46:07.271
is going to take
to actually occur.

00:46:07.271 --> 00:46:08.770
So remember,
triggering a collection

00:46:08.770 --> 00:46:10.554
pauses your application.

00:46:10.554 --> 00:46:12.720
So when the collection
occurs, your app gets paused,

00:46:12.720 --> 00:46:14.430
you get higher latency.

00:46:14.430 --> 00:46:17.130
Let's say the user
is going and clicking

00:46:17.130 --> 00:46:18.510
the inside the application.

00:46:18.510 --> 00:46:20.240
Well, that click isn't going
to register for a while,

00:46:20.240 --> 00:46:22.090
because we've got to
do this big collection.

00:46:22.090 --> 00:46:24.423
This is the is the place to
drop frames per interaction,

00:46:24.423 --> 00:46:25.850
and in general, unhappy users.

00:46:25.850 --> 00:46:28.340
And unhappy users are going
to end up going somewhere else

00:46:28.340 --> 00:46:30.980
and you don't want that.

00:46:30.980 --> 00:46:33.720
So let's take a quick summary
of some of the performance tools

00:46:33.720 --> 00:46:35.780
that we have available to us.

00:46:35.780 --> 00:46:38.340
So what the performance
memory API does

00:46:38.340 --> 00:46:40.520
is it gives us a
great tool for doing

00:46:40.520 --> 00:46:43.070
in-the-field measurements.

00:46:43.070 --> 00:46:45.210
So it gives you
back three values.

00:46:45.210 --> 00:46:47.540
It tells you the
JS heap size limit,

00:46:47.540 --> 00:46:49.060
which is the total
amount of memory

00:46:49.060 --> 00:46:50.650
available for JavaScript.

00:46:50.650 --> 00:46:53.851
It tells you the
total JS heap size,

00:46:53.851 --> 00:46:55.350
which is the amount
of memory that's

00:46:55.350 --> 00:46:58.260
been allocated so far,
including the free space.

00:46:58.260 --> 00:47:00.750
So this is including
memory that has already

00:47:00.750 --> 00:47:02.050
been garbage collected.

00:47:02.050 --> 00:47:04.620
So you could predict
the "I'm dead, Jim"

00:47:04.620 --> 00:47:09.140
message by seeing when total JS
heap size hits the JS heap size

00:47:09.140 --> 00:47:10.070
limit.

00:47:10.070 --> 00:47:11.950
And as the total
JS heap size starts

00:47:11.950 --> 00:47:14.290
to get closer and closer,
you know that at some point,

00:47:14.290 --> 00:47:17.750
you're going to trigger this
and end up out of memory.

00:47:17.750 --> 00:47:20.460
And finally, it gives
you used JS heap size.

00:47:20.460 --> 00:47:22.750
That basically tells
you the amount of memory

00:47:22.750 --> 00:47:26.317
that's currently being used
by live objects in the graph.

00:47:26.317 --> 00:47:28.150
So let's quickly summarize
some of the stuff

00:47:28.150 --> 00:47:29.650
that we learned today
in Chrome DevTools,

00:47:29.650 --> 00:47:31.760
and hopefully this is
going to be stuff that's

00:47:31.760 --> 00:47:34.060
going to be useful to you
in your day-to-day jobs.

00:47:34.060 --> 00:47:37.440
So DevTools memory timeline, we
showed it earlier in the talk.

00:47:37.440 --> 00:47:41.960
It shows you everything
from parsed JavaScript,

00:47:41.960 --> 00:47:45.180
to calculated styles,
garbage collection pauses.

00:47:45.180 --> 00:47:48.070
In the frames view it'll
show you everything from pane

00:47:48.070 --> 00:47:49.000
to composite.

00:47:49.000 --> 00:47:51.208
We're mostly interested in
the memory side of things,

00:47:51.208 --> 00:47:53.690
so it will show you
total allocated memory,

00:47:53.690 --> 00:47:57.690
live DOM nodes, number
event listeners.

00:47:57.690 --> 00:47:59.180
Don't forget that
you can force GC

00:47:59.180 --> 00:48:01.200
from the DevTools
using the trash icon.

00:48:01.200 --> 00:48:04.314
That's a really important
step people always miss.

00:48:04.314 --> 00:48:05.730
This is something
we automatically

00:48:05.730 --> 00:48:08.970
do for you if you're happening
to use one of the profilers.

00:48:08.970 --> 00:48:13.200
In timeline it can be
useful to force a GC too.

00:48:13.200 --> 00:48:14.180
Memory distribution.

00:48:14.180 --> 00:48:15.930
Heap snapshots are
really useful for that.

00:48:15.930 --> 00:48:18.230
So once you've confirmed
that a problem exists, go

00:48:18.230 --> 00:48:19.890
and try taking
some heap snapshots

00:48:19.890 --> 00:48:23.240
and dive into the
nitty-gritty of what's

00:48:23.240 --> 00:48:26.482
going on inside
your application.

00:48:26.482 --> 00:48:28.690
We let you switch between
a number of different views

00:48:28.690 --> 00:48:30.981
of the data that's available,
so we've got three views.

00:48:30.981 --> 00:48:33.300
We've got Summary, which
groups by constructor name.

00:48:33.300 --> 00:48:35.100
Comparison, which
I use a lot, which

00:48:35.100 --> 00:48:37.176
compares two different
snapshots together.

00:48:37.176 --> 00:48:38.550
Containment view,
which gives you

00:48:38.550 --> 00:48:41.650
a bird's eye view of
the object structure.

00:48:41.650 --> 00:48:43.890
Don't forget the difference
between these two colors.

00:48:43.890 --> 00:48:46.740
So yellow objects have
JavaScript references on them.

00:48:46.740 --> 00:48:49.680
Red or detached nodes,
they reference from one

00:48:49.680 --> 00:48:52.490
with the yellow background.

00:48:52.490 --> 00:48:54.740
Reading results, the DevTools
Docs curve of this stuff

00:48:54.740 --> 00:48:55.350
pretty well.

00:48:55.350 --> 00:48:56.770
We're running out of time.

00:48:56.770 --> 00:48:58.915
So distance is the distance
from your GC roots.

00:49:02.406 --> 00:49:03.780
You've got retained
memory, which

00:49:03.780 --> 00:49:06.170
is memory used by
all of your objects.

00:49:06.170 --> 00:49:08.150
The objects they are
referencing, as well.

00:49:08.150 --> 00:49:10.850
Use it to know where you're
using most of your memory.

00:49:10.850 --> 00:49:12.900
You've got shallow size.

00:49:12.900 --> 00:49:14.850
Even small objects
inside your application

00:49:14.850 --> 00:49:16.920
can hold large amounts
of memory indirectly

00:49:16.920 --> 00:49:19.810
by preventing other objects
from being disposed,

00:49:19.810 --> 00:49:21.792
so just keep an
eye shallow sizes.

00:49:21.792 --> 00:49:22.750
You've got constructor.

00:49:22.750 --> 00:49:24.690
So we try to group
all the objects

00:49:24.690 --> 00:49:29.330
in the retaining tree by their
type, so keep an eye on those.

00:49:29.330 --> 00:49:31.325
The retaining tree
shows you information

00:49:31.325 --> 00:49:32.700
that will help
you understand why

00:49:32.700 --> 00:49:34.900
objects aren't being collected.

00:49:34.900 --> 00:49:35.400
Quick tip.

00:49:35.400 --> 00:49:37.050
If you happen to
be using closures,

00:49:37.050 --> 00:49:39.250
please try to name them, because
those will actually show up

00:49:39.250 --> 00:49:41.250
in the heap profiler, and
it will be really easy

00:49:41.250 --> 00:49:42.980
for you to go and detect them.

00:49:42.980 --> 00:49:46.932
So in this case we've got two
examples where, at the top--

00:49:46.932 --> 00:49:49.140
I know this is a little bit
hard to see-- at the top,

00:49:49.140 --> 00:49:51.180
we're basically saying
var LC equals function,

00:49:51.180 --> 00:49:52.660
which is not a name function.

00:49:52.660 --> 00:49:54.420
In the bottom, we're
saying var LC equals

00:49:54.420 --> 00:49:56.710
function LC, which
is a name function.

00:49:56.710 --> 00:49:59.740
The second one will show up as
a labeled thing inside the heap

00:49:59.740 --> 00:50:00.970
snapshot.

00:50:00.970 --> 00:50:04.680
So you can easily
stay on top of that.

00:50:04.680 --> 00:50:07.574
Profiling memory leaks.

00:50:07.574 --> 00:50:10.240
Some of you may be familiar with
the "three snapshot" technique,

00:50:10.240 --> 00:50:13.510
which we've had in the
DevTools Docs for few years.

00:50:13.510 --> 00:50:16.220
We've recently retired
that technique.

00:50:16.220 --> 00:50:18.012
The basic idea
there was that you

00:50:18.012 --> 00:50:19.970
started from a steady
state, and then performed

00:50:19.970 --> 00:50:22.170
a number of different
snapshots and compared

00:50:22.170 --> 00:50:24.120
what happened between
those snapshots

00:50:24.120 --> 00:50:26.850
to understand whether
or not you had a leak.

00:50:26.850 --> 00:50:28.892
What we replaced that with
over time-- I'm sorry,

00:50:28.892 --> 00:50:30.891
I'm just skipping through
this because of time--

00:50:30.891 --> 00:50:33.510
but what we replaced that
with is the object allocation

00:50:33.510 --> 00:50:36.560
tracker I was showing
you earlier on.

00:50:36.560 --> 00:50:38.610
Basic idea with the
object allocation tracker

00:50:38.610 --> 00:50:40.530
is that we give
you a way to avoid

00:50:40.530 --> 00:50:43.320
having to repetitively take
snapshots yourself to find out

00:50:43.320 --> 00:50:44.900
if you have a leak.

00:50:44.900 --> 00:50:47.520
So the snapshot, the
allocation snapshots,

00:50:47.520 --> 00:50:50.380
can be recorded from the
record heap allocation

00:50:50.380 --> 00:50:51.930
section of profiles.

00:50:51.930 --> 00:50:54.285
It combines the detailed
snapshot information

00:50:54.285 --> 00:50:56.260
that you see in
the heap profiler,

00:50:56.260 --> 00:50:59.180
with the incremental
updating in real time view

00:50:59.180 --> 00:51:01.440
that you get inside
the Timeline panel.

00:51:01.440 --> 00:51:04.280
It's really useful to use and
I'd definitely check that out.

00:51:06.870 --> 00:51:09.860
You can read more about the
trackers inside of our Docs.

00:51:09.860 --> 00:51:12.350
Remember that blue bars
mean memory allocations.

00:51:12.350 --> 00:51:14.010
Taller means more
memory being used.

00:51:14.010 --> 00:51:16.420
Gray bars mean that something
has been de-allocated.

00:51:16.420 --> 00:51:18.070
You can trim down by time.

00:51:18.070 --> 00:51:20.270
You can take a look
at the heap contents

00:51:20.270 --> 00:51:23.150
quite easily to dig
into more information.

00:51:23.150 --> 00:51:25.760
Very quickly, I'm going
to start wrapping up.

00:51:25.760 --> 00:51:28.750
Something new that we introduced
in the Canary DevTools

00:51:28.750 --> 00:51:30.880
is allocation stack traces.

00:51:30.880 --> 00:51:32.160
This is a brand new concept.

00:51:32.160 --> 00:51:33.840
We haven't talked
about it before.

00:51:33.840 --> 00:51:36.380
But the basic idea
here is that you can go

00:51:36.380 --> 00:51:38.380
and you can enable
this in settings

00:51:38.380 --> 00:51:41.230
in the Canary DevTools,
under record heap allocation

00:51:41.230 --> 00:51:42.650
stack traces.

00:51:42.650 --> 00:51:45.310
And it just makes a profile
and collects stack traces

00:51:45.310 --> 00:51:48.470
when you're going and recording
your heap allocations.

00:51:48.470 --> 00:51:51.670
So once you've gone and
you've recorded a profile,

00:51:51.670 --> 00:51:53.170
you'll see that we
actually give you

00:51:53.170 --> 00:51:55.671
a new tab next to
the retainers view.

00:51:55.671 --> 00:51:58.170
And the stack trace is going
to be missing for many objects,

00:51:58.170 --> 00:52:00.460
but if it happens,
it just means that it

00:52:00.460 --> 00:52:01.950
was created by V8 internals.

00:52:01.950 --> 00:52:03.575
It just gives you
some more information

00:52:03.575 --> 00:52:06.680
that you can use
during debugging.

00:52:06.680 --> 00:52:08.650
I'm going to gloss
over very quickly.

00:52:08.650 --> 00:52:09.720
Flame charts.

00:52:09.720 --> 00:52:12.190
How many people here have
heard of flame charts before?

00:52:12.190 --> 00:52:14.880
Right, so, half of you
have heard of flame charts.

00:52:14.880 --> 00:52:18.510
If you're trying to visualize
JavaScript execution over time,

00:52:18.510 --> 00:52:20.340
flame charts are really useful.

00:52:20.340 --> 00:52:24.330
You go and trigger them by
recording a new CPU profile.

00:52:24.330 --> 00:52:28.690
If you go and try to select
the Chart view inside of that

00:52:28.690 --> 00:52:31.640
but that'll basically give
you this really gorgeous view

00:52:31.640 --> 00:52:33.360
that provides a
visual representation

00:52:33.360 --> 00:52:36.730
of your JavaScript
processing over time.

00:52:36.730 --> 00:52:38.940
You can actually dig down
to individual functions

00:52:38.940 --> 00:52:41.010
and see how much
time they took up.

00:52:41.010 --> 00:52:42.950
And by analyzing
and understanding

00:52:42.950 --> 00:52:44.960
your call progression
you can visually

00:52:44.960 --> 00:52:46.820
gain a better understanding
of the execution

00:52:46.820 --> 00:52:48.070
within parts of your app.

00:52:48.070 --> 00:52:51.260
So the height of these actual
bars isn't really significant;

00:52:51.260 --> 00:52:53.460
they just represent function
calls which occurred.

00:52:53.460 --> 00:52:57.950
What is important is
the width of those bars.

00:52:57.950 --> 00:53:00.720
You can take a look at more
of the stuff in our docs.

00:53:00.720 --> 00:53:03.830
Is optimization actually
worth the effort?

00:53:03.830 --> 00:53:06.010
I'd actually say
yes, I think it is.

00:53:06.010 --> 00:53:08.760
I know that I've been throwing a
lot of stuff at you guys today.

00:53:08.760 --> 00:53:11.355
There's been a lot of stuff on
tooling, a lot of stuff on V8.

00:53:11.355 --> 00:53:15.080
This stuff is actually
worth knowing about.

00:53:15.080 --> 00:53:17.870
This is a graph from
Gmail's memory usage

00:53:17.870 --> 00:53:20.400
that we took over
a 10-month period,

00:53:20.400 --> 00:53:23.320
using the performance
memory API.

00:53:23.320 --> 00:53:26.354
And what we discovered, if you
take a look at the very left,

00:53:26.354 --> 00:53:28.020
is that you see that
memory was actually

00:53:28.020 --> 00:53:30.690
really out of
control at one point.

00:53:30.690 --> 00:53:33.810
The green line is the median
and the blue line corresponds

00:53:33.810 --> 00:53:35.370
to the 99th percentile.

00:53:35.370 --> 00:53:36.950
You can see the for
our power users,

00:53:36.950 --> 00:53:38.860
using the tools that
I showed you today,

00:53:38.860 --> 00:53:43.130
we were actually able to reduce
memory footprint by up to 80%,

00:53:43.130 --> 00:53:44.260
if not more.

00:53:44.260 --> 00:53:46.590
And for our average
users, we were actually

00:53:46.590 --> 00:53:50.250
able to reduce their footprint
by 50%, which is kind of huge.

00:53:50.250 --> 00:53:53.430
So for long-life
applications like Gmail,

00:53:53.430 --> 00:53:55.200
being able to narrow
down memory leaks,

00:53:55.200 --> 00:53:57.730
being able to squash them
down, is actually a big deal.

00:53:57.730 --> 00:54:00.146
If you do end up having memory
leaks in your applications,

00:54:00.146 --> 00:54:02.520
I hope that you'll take
a look at our docs,

00:54:02.520 --> 00:54:05.594
you'll learn the tools, try
to use them on your own apps.

00:54:05.594 --> 00:54:07.010
There are a bunch
of resources I'm

00:54:07.010 --> 00:54:08.492
going to link you up to later.

00:54:08.492 --> 00:54:09.950
There's some good
case studies that

00:54:09.950 --> 00:54:12.480
have been done by
everyone from Imager

00:54:12.480 --> 00:54:15.910
to Drupal to StrongLoop
to other people

00:54:15.910 --> 00:54:18.270
who've been looking at
memory leaks in JavaScript

00:54:18.270 --> 00:54:22.380
and how they apply
to everyday apps.

00:54:22.380 --> 00:54:23.742
Last thing to remember.

00:54:23.742 --> 00:54:25.200
Ask yourself these
questions if you

00:54:25.200 --> 00:54:27.340
think you have issues
with your apps memory.

00:54:27.340 --> 00:54:28.920
How much memory is
your page using?

00:54:28.920 --> 00:54:30.190
Is your page leak free?

00:54:30.190 --> 00:54:32.090
How frequently are you GCing?

00:54:32.090 --> 00:54:33.390
Know your arsenal.

00:54:33.390 --> 00:54:35.530
Make sure that you know
the profiling tools

00:54:35.530 --> 00:54:39.054
inside of things like Chrome,
regardless of whether it's also

00:54:39.054 --> 00:54:40.970
looking at the Firefox
dev tools and other dev

00:54:40.970 --> 00:54:43.050
tools that are out there.

00:54:43.050 --> 00:54:44.150
To know your arsenal.

00:54:44.150 --> 00:54:46.640
Hopefully at least one or
two people in this room

00:54:46.640 --> 00:54:48.990
are excited about the
idea of having a better

00:54:48.990 --> 00:54:50.810
grip on memory profiling.

00:54:50.810 --> 00:54:53.390
Maybe some of you are just
excited this talk is over

00:54:53.390 --> 00:54:56.860
and you get to actually eat.

00:54:56.860 --> 00:54:59.440
But overall, I hope that you
at least got something out

00:54:59.440 --> 00:55:00.560
of this talk.

00:55:00.560 --> 00:55:01.780
That's it for me.

00:55:01.780 --> 00:55:03.440
Thank you.

