WEBVTT
Kind: captions
Language: en

00:00:00.816 --> 00:00:01.940
MEGHAN DESAI: Hi, everyone.

00:00:01.940 --> 00:00:04.184
Welcome to the
Project Volta session.

00:00:04.184 --> 00:00:06.600
This was previously known as
the Android Power Performance

00:00:06.600 --> 00:00:07.100
Primer.

00:00:07.100 --> 00:00:09.621
If you can say that three
times, five times as fast, there

00:00:09.621 --> 00:00:11.120
might be a prize
in it for you guys.

00:00:11.120 --> 00:00:13.620
But this is the introduction
to Project Volta.

00:00:13.620 --> 00:00:14.774
My name is Meghan.

00:00:14.774 --> 00:00:16.149
I'm a product
manager on Android,

00:00:16.149 --> 00:00:17.350
and I have here with me Matthew.

00:00:17.350 --> 00:00:18.600
MATTHEW WILLIAMS: I'm Matthew.

00:00:18.600 --> 00:00:19.810
I work on Android Cloud.

00:00:19.810 --> 00:00:22.184
MEGHAN DESAI: And we're here
to talk about Project Volta.

00:00:22.184 --> 00:00:24.640
So we know that
today, battery life

00:00:24.640 --> 00:00:27.330
is one of the biggest
complaints that users

00:00:27.330 --> 00:00:29.170
have with Android
devices out there.

00:00:29.170 --> 00:00:31.560
As we live in a world
that's more and more mobile,

00:00:31.560 --> 00:00:32.976
it's really important
that we have

00:00:32.976 --> 00:00:34.810
devices that last the
full day at least.

00:00:34.810 --> 00:00:36.730
And I could not tell
you how many times

00:00:36.730 --> 00:00:39.140
I've been in a situation where,
after a long day at work,

00:00:39.140 --> 00:00:41.056
I'm trying to get a ride
home and I can't call

00:00:41.056 --> 00:00:42.900
a ride because my phone
is out of battery.

00:00:42.900 --> 00:00:46.590
So we're really passionate
about addressing this issue,

00:00:46.590 --> 00:00:49.130
and that was the impetus
of Project Volta.

00:00:49.130 --> 00:00:52.571
With Project Volta, we looked
across the platform, Android

00:00:52.571 --> 00:00:54.445
platform, to see what
opportunities lie there

00:00:54.445 --> 00:00:55.760
for improvement.

00:00:55.760 --> 00:00:57.360
We wanted to figure
out what tools

00:00:57.360 --> 00:01:00.600
and APIs we could build for
you guys to make it easier

00:01:00.600 --> 00:01:02.920
for you to make your
applications more efficient

00:01:02.920 --> 00:01:05.660
and also increase the
transparency about power

00:01:05.660 --> 00:01:07.070
consumption for users.

00:01:07.070 --> 00:01:08.570
So you saw some of
the features that

00:01:08.570 --> 00:01:11.289
are more user facing at
the keynote from Dave.

00:01:11.289 --> 00:01:13.080
This session is going
to focus specifically

00:01:13.080 --> 00:01:16.284
on the tools and APIs that
we have built for you guys.

00:01:16.284 --> 00:01:18.700
So let's dig a little bit
deeper into some of the analysis

00:01:18.700 --> 00:01:19.730
that we did.

00:01:19.730 --> 00:01:21.910
We started out
looking at a Nexus 5,

00:01:21.910 --> 00:01:25.480
and we said, let's
establish a baseline.

00:01:25.480 --> 00:01:27.040
We turned off
everything on there,

00:01:27.040 --> 00:01:28.790
so it was in airplane
mode, screen off,

00:01:28.790 --> 00:01:30.344
so completely in standby.

00:01:30.344 --> 00:01:32.760
And that gives you something
like a month of battery life.

00:01:32.760 --> 00:01:34.780
But of course, we don't
do this to our devices.

00:01:34.780 --> 00:01:37.090
We actually use them throughout
the course of the day.

00:01:37.090 --> 00:01:38.090
We put them on cellular.

00:01:38.090 --> 00:01:39.250
We make calls.

00:01:39.250 --> 00:01:40.190
We have Wi-Fi.

00:01:40.190 --> 00:01:42.220
We have applications
that are syncing.

00:01:42.220 --> 00:01:44.100
We are checking our
social networks.

00:01:44.100 --> 00:01:44.950
We're playing games.

00:01:44.950 --> 00:01:45.658
The screen is on.

00:01:45.658 --> 00:01:48.250
Well, all of that adds
up, and the battery life

00:01:48.250 --> 00:01:51.037
goes way, way down
to less than a day.

00:01:51.037 --> 00:01:53.120
So that red line that
you're seeing there-- that's

00:01:53.120 --> 00:01:54.619
where we saw the
opportunity, and we

00:01:54.619 --> 00:01:56.590
wanted to dig even
deeper into there

00:01:56.590 --> 00:01:59.570
and figure out what
can we do there.

00:01:59.570 --> 00:02:01.610
So we decided to take
a more microscopic look

00:02:01.610 --> 00:02:02.920
at what's happening.

00:02:02.920 --> 00:02:07.050
And before I go into more, let
me talk about three active use

00:02:07.050 --> 00:02:09.580
cases I'm going to talk
about as we do this analysis.

00:02:09.580 --> 00:02:11.824
First, the application
processor being awake.

00:02:11.824 --> 00:02:13.990
We know that when the
application processor's awake,

00:02:13.990 --> 00:02:15.729
power is being consumed.

00:02:15.729 --> 00:02:17.270
Next, the cellular
radio being awake,

00:02:17.270 --> 00:02:19.311
and we're going to look
at what happens when that

00:02:19.311 --> 00:02:21.290
is awake and is
doing its activity.

00:02:21.290 --> 00:02:23.040
And then, finally, the
screen being awake.

00:02:23.040 --> 00:02:26.080
That's one of the biggest
drawers of power on the device.

00:02:26.080 --> 00:02:27.886
So we'll take a look
at each of these.

00:02:27.886 --> 00:02:30.010
Again, first, let's establish
ourselves a baseline.

00:02:30.010 --> 00:02:33.460
So what you're seeing here
is current draw over time.

00:02:33.460 --> 00:02:36.790
So we basically hooked up
an amp meter to the device

00:02:36.790 --> 00:02:38.980
to measure what's happening,
what kind of power

00:02:38.980 --> 00:02:41.230
is being drawn by
the device over time.

00:02:41.230 --> 00:02:43.800
So this baseline right here is
in standby-- that standby mode

00:02:43.800 --> 00:02:47.810
I just described where the only
thing that is really active

00:02:47.810 --> 00:02:50.200
is that the cellular radio is
in its standby state, where

00:02:50.200 --> 00:02:52.274
it periodically checks
in with the cell tower.

00:02:52.274 --> 00:02:53.940
And that's what these
little spikes are.

00:02:53.940 --> 00:02:54.940
So this is our baseline.

00:02:54.940 --> 00:02:56.517
Very little power
is being consumed.

00:02:56.517 --> 00:02:58.350
Let's say you wanted
to turn the CPU on just

00:02:58.350 --> 00:02:59.980
for a brief period of time.

00:02:59.980 --> 00:03:01.560
This is what happens.

00:03:01.560 --> 00:03:03.372
So we turn the
application processor on.

00:03:03.372 --> 00:03:04.330
The processor turns on.

00:03:04.330 --> 00:03:06.414
It checks to see if there's
any work to do or not.

00:03:06.414 --> 00:03:08.538
And then it goes off because
there's nothing to do.

00:03:08.538 --> 00:03:09.280
This was a no-op.

00:03:09.280 --> 00:03:12.309
Well, just to do that, that
much power is consumed.

00:03:12.309 --> 00:03:14.850
You can see that it's actually
on for a little over a second.

00:03:14.850 --> 00:03:17.830
And what's happening is
that the processor has

00:03:17.830 --> 00:03:20.260
to turn on, load all
these things into its RAM

00:03:20.260 --> 00:03:22.875
and into its memory and
figure out what it needs to do

00:03:22.875 --> 00:03:24.110
or if it doesn't do
anything, and then it

00:03:24.110 --> 00:03:25.120
tears everything down.

00:03:25.120 --> 00:03:27.250
So that's consuming power.

00:03:27.250 --> 00:03:29.461
And you can think of the
area underneath that curve,

00:03:29.461 --> 00:03:31.835
the integral-- that is the
power, the many amp-hours that

00:03:31.835 --> 00:03:33.155
are being consumed.

00:03:33.155 --> 00:03:34.780
Next, let's take a
look at what happens

00:03:34.780 --> 00:03:37.530
when you want to send a
packet over the LTE radio.

00:03:37.530 --> 00:03:41.610
So we decided to simulate
sending one packet over LTE,

00:03:41.610 --> 00:03:43.560
and here's the shape we saw.

00:03:43.560 --> 00:03:47.460
So it starts out in standby,
and then we see these spikes.

00:03:47.460 --> 00:03:49.220
So the cellular
radio's coming up.

00:03:49.220 --> 00:03:50.190
It sends the packet.

00:03:50.190 --> 00:03:51.780
It receives this
acknowledgement.

00:03:51.780 --> 00:03:54.140
But then you see all these
little spikes afterwards.

00:03:54.140 --> 00:03:56.390
So first you see
a few big spikes--

00:03:56.390 --> 00:03:57.990
that's when the
activity is happening.

00:03:57.990 --> 00:04:00.870
Then afterwards you see this
long tail of little spikes.

00:04:00.870 --> 00:04:03.540
But what's happening there is
that the radio decides that,

00:04:03.540 --> 00:04:05.200
hey, I just sent this packet.

00:04:05.200 --> 00:04:06.450
Maybe there's more work to do.

00:04:06.450 --> 00:04:08.366
So I'm going to stay in
this in-between state.

00:04:08.366 --> 00:04:10.340
I'm not completely in
standby, but I'm ready

00:04:10.340 --> 00:04:12.230
just in case something comes up.

00:04:12.230 --> 00:04:13.650
Well, that seems reasonable.

00:04:13.650 --> 00:04:14.930
That makes a lot of sense.

00:04:14.930 --> 00:04:17.070
But if this happens
a lot-- that that's

00:04:17.070 --> 00:04:19.240
extra energy that
is spent-- then

00:04:19.240 --> 00:04:21.505
the device is not actually
doing anything useful.

00:04:21.505 --> 00:04:22.630
So we'll come back to that.

00:04:22.630 --> 00:04:24.240
I think there's some
opportunity there.

00:04:24.240 --> 00:04:25.100
Let's quickly take
a look at what

00:04:25.100 --> 00:04:26.980
happens when the
screen turns on.

00:04:26.980 --> 00:04:28.130
There's a big spike.

00:04:28.130 --> 00:04:29.796
You would expect that
because the screen

00:04:29.796 --> 00:04:31.180
is a huge, huge power consumer.

00:04:31.180 --> 00:04:34.210
One of the biggest ones because
you had to turn on these LEDs

00:04:34.210 --> 00:04:37.010
and paint the screen and do
the processing to figure out

00:04:37.010 --> 00:04:38.510
what to actually
show on the screen.

00:04:38.510 --> 00:04:40.270
So turning the screen
on for a second,

00:04:40.270 --> 00:04:45.110
this is what we saw as a
curve for power consumption.

00:04:45.110 --> 00:04:45.610
Cool.

00:04:45.610 --> 00:04:48.320
So let's take a look at
this in a different way.

00:04:48.320 --> 00:04:50.736
Let's compare that to
that baseline that we saw.

00:04:50.736 --> 00:04:53.110
Let's assume that we wanted
to do one of these active use

00:04:53.110 --> 00:04:54.480
cases for one second.

00:04:54.480 --> 00:04:58.120
So we took the power that that
consumes and divided into it

00:04:58.120 --> 00:05:00.850
the standby power to figure
out what are we trading off

00:05:00.850 --> 00:05:03.840
when we keep the device
active for one second.

00:05:03.840 --> 00:05:06.170
And it turns out
that we actually

00:05:06.170 --> 00:05:08.560
trade off two
minutes of standby.

00:05:08.560 --> 00:05:10.727
This is a rough number
across those three use cases.

00:05:10.727 --> 00:05:12.268
Obviously, you're
going to be trading

00:05:12.268 --> 00:05:14.290
off more if the screen
is on for one second.

00:05:14.290 --> 00:05:18.140
But let's say it's two
minutes for the sake of this--

00:05:18.140 --> 00:05:20.232
or roughly two minutes.

00:05:20.232 --> 00:05:21.440
Do two minutes really matter?

00:05:21.440 --> 00:05:23.600
That seems like a really
small amount of time.

00:05:23.600 --> 00:05:27.039
Well, if it was just once,
just once this was happening,

00:05:27.039 --> 00:05:28.580
then, yeah, it
doesn't really matter.

00:05:28.580 --> 00:05:31.850
But let's take an example where
you have 50 apps on the device.

00:05:31.850 --> 00:05:33.752
We have tons and tons
of apps on our devices.

00:05:33.752 --> 00:05:34.960
They're syncing all the time.

00:05:34.960 --> 00:05:36.767
We're using those
apps all the time.

00:05:36.767 --> 00:05:38.350
Let's say you had
50 apps on a device,

00:05:38.350 --> 00:05:41.350
and they were each keeping
the processor or the cell

00:05:41.350 --> 00:05:44.230
radio or the screen on
for one second every hour,

00:05:44.230 --> 00:05:45.450
each of them doing this.

00:05:45.450 --> 00:05:48.060
Well, that amounts to 100
minutes of standby time

00:05:48.060 --> 00:05:50.520
that you trade off every hour.

00:05:50.520 --> 00:05:53.305
You do this for eight
hours, that's 800 minutes.

00:05:53.305 --> 00:05:54.305
That's a lot of minutes.

00:05:54.305 --> 00:05:55.405
MATTHEW WILLIAMS: That's huge.

00:05:55.405 --> 00:05:56.210
MEGHAN DESAI:
That's huge, right?

00:05:56.210 --> 00:05:57.168
MATTHEW WILLIAMS: Yeah.

00:05:57.168 --> 00:05:58.870
MEGHAN DESAI: Yeah.

00:05:58.870 --> 00:06:02.050
So why can't apps
just be lazier?

00:06:02.050 --> 00:06:03.505
What if apps were just lazier?

00:06:03.505 --> 00:06:05.130
MATTHEW WILLIAMS:
I'm not sure, Meghan.

00:06:05.130 --> 00:06:06.610
That sounds kind of gimmicky.

00:06:06.610 --> 00:06:08.230
Could you explain
this some more?

00:06:08.230 --> 00:06:09.720
MEGHAN DESAI: Yeah,
sure, Matthew.

00:06:09.720 --> 00:06:11.970
Let me introduce a concept
called "lazy first."

00:06:11.970 --> 00:06:14.230
The idea here is that
if your application

00:06:14.230 --> 00:06:17.000
can be lazy first,
then be lazy first.

00:06:17.000 --> 00:06:18.250
The obvious way to do this?

00:06:18.250 --> 00:06:21.445
Reduce the number of times that
you keep the device active.

00:06:21.445 --> 00:06:23.570
That seems like a no-brainer,
but of course, that's

00:06:23.570 --> 00:06:24.575
not doable all the time.

00:06:24.575 --> 00:06:25.950
There's a lot of
legitimate times

00:06:25.950 --> 00:06:27.980
when you need to be
connecting to the network

00:06:27.980 --> 00:06:29.660
or keeping a wake lock.

00:06:29.660 --> 00:06:32.170
So maybe you can coalesce
a lot of these activities.

00:06:32.170 --> 00:06:34.400
If you have a lot of
network calls in succession,

00:06:34.400 --> 00:06:36.150
you can group them
together into one call,

00:06:36.150 --> 00:06:39.470
so you pay less of that overhead
that we just talked about.

00:06:39.470 --> 00:06:40.837
Now, finally, you can defer it.

00:06:40.837 --> 00:06:42.670
If you have content
that needs to be updated

00:06:42.670 --> 00:06:44.250
to the application
every week, it

00:06:44.250 --> 00:06:45.250
doesn't need to
happen right away.

00:06:45.250 --> 00:06:45.710
It can happen.

00:06:45.710 --> 00:06:48.293
You can defer it to maybe when
the phone is charged or plugged

00:06:48.293 --> 00:06:49.807
in.

00:06:49.807 --> 00:06:51.640
That's what I mean by
"lazy first," Matthew.

00:06:51.640 --> 00:06:53.000
MATTHEW WILLIAMS:
OK, I mean, I guess

00:06:53.000 --> 00:06:55.540
when you put it in that context,
this makes a lot of sense.

00:06:55.540 --> 00:06:57.470
So on mobile, we
have these devices

00:06:57.470 --> 00:06:59.950
which are constantly
transitioning states.

00:06:59.950 --> 00:07:01.760
So it's a quite likely
scenario that you're

00:07:01.760 --> 00:07:03.301
going to be in a
situation where it's

00:07:03.301 --> 00:07:05.400
expensive to do certain
types of operations.

00:07:05.400 --> 00:07:07.650
But if you can wait
for long enough--

00:07:07.650 --> 00:07:10.660
and that's the key of the
matter, this waiting-- you're

00:07:10.660 --> 00:07:12.520
most likely going to
get into a situation

00:07:12.520 --> 00:07:15.570
where the environment is
much more cost effective.

00:07:15.570 --> 00:07:18.520
So essentially, the thing
we'd like you to ask yourself

00:07:18.520 --> 00:07:20.710
is, what is the
longest amount of time

00:07:20.710 --> 00:07:22.820
that I'm willing to
do this type of thing?

00:07:22.820 --> 00:07:25.235
And then you can schedule
this work based on that.

00:07:25.235 --> 00:07:28.760
But this is kind of a big ask,
because the infrastructure

00:07:28.760 --> 00:07:31.320
up until now just
hasn't really existed.

00:07:31.320 --> 00:07:32.810
But that's changed
in L. So we've

00:07:32.810 --> 00:07:34.860
built out a new
set of APIs, which

00:07:34.860 --> 00:07:36.820
we're calling the
JobScheduler, which

00:07:36.820 --> 00:07:40.360
make it really easy to specify
these types of constraints

00:07:40.360 --> 00:07:42.030
that directly target
the types of work

00:07:42.030 --> 00:07:44.050
that you're
interested in and then

00:07:44.050 --> 00:07:45.690
provide a callback
for the system

00:07:45.690 --> 00:07:49.990
to know when your application,
this logic, should be run.

00:07:49.990 --> 00:07:52.590
So I'm talking
about jobs and work,

00:07:52.590 --> 00:07:55.230
but what exactly do I mean?

00:07:55.230 --> 00:07:58.400
For example, like a non
user-facing network call.

00:07:58.400 --> 00:08:00.392
So this is a case where
the users interact

00:08:00.392 --> 00:08:03.210
with the application and you
have some data to upload,

00:08:03.210 --> 00:08:05.400
and they're not expecting
any sort of callback.

00:08:05.400 --> 00:08:07.840
They're not expecting to
see any change in the UI.

00:08:07.840 --> 00:08:10.070
So yeah, you could
upload this immediately,

00:08:10.070 --> 00:08:12.640
but if the user isn't expecting
to see anything from this,

00:08:12.640 --> 00:08:13.280
why not wait?

00:08:13.280 --> 00:08:15.760
Why not defer this operation?

00:08:15.760 --> 00:08:17.780
Another example that
we could think about

00:08:17.780 --> 00:08:21.570
is any sort of CPU
intensive operation.

00:08:21.570 --> 00:08:22.860
This is video processing.

00:08:22.860 --> 00:08:24.860
This is database cleanup.

00:08:24.860 --> 00:08:27.600
Again, non-user facing,
really easy to defer

00:08:27.600 --> 00:08:30.970
if the infrastructure did exist.

00:08:30.970 --> 00:08:32.480
So just another
example-- any sort

00:08:32.480 --> 00:08:34.340
of job you want to
perform periodically,

00:08:34.340 --> 00:08:36.919
like some sort of Cron job
or something that you'd

00:08:36.919 --> 00:08:39.870
like to happen at some
point in time in the future.

00:08:39.870 --> 00:08:43.530
So let's take a look
at a specific example.

00:08:43.530 --> 00:08:47.150
Every 15 hours, perform some
database cleanup and maybe

00:08:47.150 --> 00:08:49.490
upload some logs to my server.

00:08:49.490 --> 00:08:53.300
So at this point, this probably
looks like a common situation

00:08:53.300 --> 00:08:55.210
that a lot of you
have done and have

00:08:55.210 --> 00:08:57.700
had to do on a regular basis.

00:08:57.700 --> 00:09:00.310
And you're wondering, well,
why has the Android team gone

00:09:00.310 --> 00:09:02.184
to all the trouble of
building out this brand

00:09:02.184 --> 00:09:04.130
new API for something
that's been possible

00:09:04.130 --> 00:09:05.589
since the inception of Android?

00:09:05.589 --> 00:09:07.380
But then again, if
you've done this before,

00:09:07.380 --> 00:09:09.589
you probably agree with me
that it's not that simple.

00:09:09.589 --> 00:09:11.296
So in the first place,
you want something

00:09:11.296 --> 00:09:13.140
to happen in about 15
hours, so you set up

00:09:13.140 --> 00:09:15.250
an alarm with the Alarm Manager.

00:09:15.250 --> 00:09:15.750
That's fine.

00:09:15.750 --> 00:09:18.680
That's pretty simple
and well understood.

00:09:18.680 --> 00:09:21.320
But the Alarm Manager doesn't
persist these operations.

00:09:21.320 --> 00:09:23.520
So you're going to probably have
to write some stuff to storage.

00:09:23.520 --> 00:09:25.640
And at this point, all
you're really interested in

00:09:25.640 --> 00:09:27.879
is a wall-clock
time plus whatever

00:09:27.879 --> 00:09:30.045
parameters you were interested
in in the first place

00:09:30.045 --> 00:09:31.980
that you need to do this work.

00:09:31.980 --> 00:09:33.680
But 15 hours passes.

00:09:33.680 --> 00:09:35.850
The Alarm Manager sends
you your broadcast.

00:09:35.850 --> 00:09:38.500
Your app wakes up, and it
tries to hit the network,

00:09:38.500 --> 00:09:40.920
and there's no connectivity.

00:09:40.920 --> 00:09:43.430
So at this point, you register
with the Connectivity Manager

00:09:43.430 --> 00:09:46.510
to let you know when
connectivity comes back.

00:09:46.510 --> 00:09:48.310
But we're on mobile,
and these environments

00:09:48.310 --> 00:09:49.310
are constantly changing.

00:09:49.310 --> 00:09:53.050
Your network could be flapping,
your server could be down,

00:09:53.050 --> 00:09:55.390
or there could be all
sorts of failure scenarios.

00:09:55.390 --> 00:09:57.439
So you go into a failure state.

00:09:57.439 --> 00:09:58.730
You're doing your own back-off.

00:09:58.730 --> 00:10:00.830
You set up some more alarms
in the Alarm Manager.

00:10:00.830 --> 00:10:03.159
You have to track this failure.

00:10:03.159 --> 00:10:05.700
You have to write all of these
parameters dealt into storage,

00:10:05.700 --> 00:10:07.325
because you're using
the Alarm Manager,

00:10:07.325 --> 00:10:09.660
and if the device reboots,
all that stuff will go away.

00:10:09.660 --> 00:10:12.420
So it's really not that
simple, but let's take a look

00:10:12.420 --> 00:10:16.090
at how we do this with
something like JobScheduler.

00:10:16.090 --> 00:10:18.300
So again, you're
seeing here that we're

00:10:18.300 --> 00:10:20.690
providing this
builder, which you

00:10:20.690 --> 00:10:22.810
use to produce this
job-in-four objects,

00:10:22.810 --> 00:10:26.240
and a job-in-four is
an exact encapsulation

00:10:26.240 --> 00:10:28.830
of what it is that
you like to do.

00:10:28.830 --> 00:10:31.254
So in the constructor,
your provide a job ID,

00:10:31.254 --> 00:10:33.670
which is some integer that you
assign for the job yourself

00:10:33.670 --> 00:10:37.040
which you use to differentiate
this job from other jobs

00:10:37.040 --> 00:10:39.947
that you might schedule
against the system.

00:10:39.947 --> 00:10:41.780
And then you give it
the service components.

00:10:41.780 --> 00:10:43.955
And this is your service
that you subclass

00:10:43.955 --> 00:10:47.160
that we provide where your
execution logic is housed,

00:10:47.160 --> 00:10:50.090
and we'll talk about
that some more later.

00:10:50.090 --> 00:10:53.099
In this case, we're asking
for any sort of network,

00:10:53.099 --> 00:10:55.140
but if you know you have
a bunch of uploads to do

00:10:55.140 --> 00:10:56.556
and you want an
unmetered network,

00:10:56.556 --> 00:10:58.770
you can also ask for
that type of thing.

00:10:58.770 --> 00:11:01.661
Then you set in the
timing constraints.

00:11:01.661 --> 00:11:03.660
In this case, I want this
to periodically happen

00:11:03.660 --> 00:11:04.770
every 15 hours.

00:11:04.770 --> 00:11:09.310
And then you're asking that
the device be plugged in.

00:11:09.310 --> 00:11:10.510
And that's it.

00:11:10.510 --> 00:11:11.490
There you have it.

00:11:11.490 --> 00:11:14.050
So we saw a bunch
of-- this example

00:11:14.050 --> 00:11:15.769
has a lot of
interesting criteria.

00:11:15.769 --> 00:11:17.560
But this kind of just
scratches the surface

00:11:17.560 --> 00:11:19.490
of the types of things you
can do with the JobScheduler.

00:11:19.490 --> 00:11:21.410
Let's look at some
of the other things.

00:11:21.410 --> 00:11:25.060
Let's look at it all in total.

00:11:25.060 --> 00:11:27.310
So the first thing that
we've introduced in L,

00:11:27.310 --> 00:11:30.450
and this is brand new, is this
network activity awareness.

00:11:30.450 --> 00:11:33.670
Now this is actually a
Connectivity Manager API

00:11:33.670 --> 00:11:35.254
that we've integrated against.

00:11:35.254 --> 00:11:36.920
So you can use this
in your applications

00:11:36.920 --> 00:11:38.710
if you wanted to
do your own stuff.

00:11:38.710 --> 00:11:41.605
But for our purposes-- and this
is getting back to that graph

00:11:41.605 --> 00:11:45.500
you saw earlier that Meghan
showed-- that really long tail

00:11:45.500 --> 00:11:50.580
where the network
was not quite idle

00:11:50.580 --> 00:11:52.320
but wasn't quite active either.

00:11:52.320 --> 00:11:55.270
So if we're aware that the
radio card is in that state,

00:11:55.270 --> 00:11:57.940
we can piggyback
on that and take

00:11:57.940 --> 00:12:00.880
advantage of that opportunity.

00:12:00.880 --> 00:12:03.360
The next thing we're going
to introduce is Idle mode.

00:12:03.360 --> 00:12:06.470
So this is, as it sounds
like, a period of time

00:12:06.470 --> 00:12:09.260
for which the system has
determined that the phone is

00:12:09.260 --> 00:12:13.950
not being used and is not
likely to be used anytime soon.

00:12:13.950 --> 00:12:16.460
So just to take an
example, if you set up

00:12:16.460 --> 00:12:20.140
a job that required Idle
mode and also charging,

00:12:20.140 --> 00:12:22.705
this would probably be
executed sometime at night

00:12:22.705 --> 00:12:24.330
when the user is
sleeping and the phone

00:12:24.330 --> 00:12:26.920
is plugged into the wall
or on their bedside table

00:12:26.920 --> 00:12:27.550
next to them.

00:12:27.550 --> 00:12:29.750
And from a battery
perspective, you

00:12:29.750 --> 00:12:31.800
can't do much better than that.

00:12:31.800 --> 00:12:33.100
You can hammer the CPU.

00:12:33.100 --> 00:12:34.308
You can do whatever you want.

00:12:34.308 --> 00:12:37.240
The user isn't around to
see any of this stuff.

00:12:37.240 --> 00:12:40.860
And when they wake up in the
morning, the battery's at 100%

00:12:40.860 --> 00:12:43.030
because it was
plugged in all night.

00:12:43.030 --> 00:12:46.300
We've also consolidated a bunch
of pre-existing functionality.

00:12:46.300 --> 00:12:49.040
We saw this in the
previous example.

00:12:49.040 --> 00:12:52.950
You can ask for tasks to run
while the device is charging.

00:12:52.950 --> 00:12:56.290
And you can also specify
different types of network.

00:12:56.290 --> 00:13:00.340
So these are the types
of powerful criteria

00:13:00.340 --> 00:13:04.660
that you can specify, but let's
talk a bit about the features.

00:13:04.660 --> 00:13:06.330
So as I mentioned,
the JobScheduler,

00:13:06.330 --> 00:13:08.570
you don't have to worry
about persistence at all.

00:13:08.570 --> 00:13:10.850
You can specify your
execution state.

00:13:10.850 --> 00:13:13.750
You hand a bundle of
parameters to the system,

00:13:13.750 --> 00:13:16.139
to the JobScheduler, and we
take care of that for you.

00:13:16.139 --> 00:13:17.930
We hand that back to
you at execution time,

00:13:17.930 --> 00:13:22.680
no matter how often a device may
have rebooted in the interim.

00:13:22.680 --> 00:13:26.050
And then you can specify, on a
period job basis, your back-off

00:13:26.050 --> 00:13:26.940
and retry criteria.

00:13:26.940 --> 00:13:29.419
And I think this is particularly
powerful, because you

00:13:29.419 --> 00:13:31.710
can say, for example, that
you want this back-off to be

00:13:31.710 --> 00:13:34.010
linear-- whether you want
it to be exponential--

00:13:34.010 --> 00:13:36.670
and you also specify the
initial back-off time.

00:13:36.670 --> 00:13:40.910
So you can decide for
yourself how you want your job

00:13:40.910 --> 00:13:44.450
to behave when it gets
into a failure state.

00:13:44.450 --> 00:13:46.700
And finally, set up
these timing criteria.

00:13:46.700 --> 00:13:49.540
You can [INAUDIBLE] once,
at one point in the future,

00:13:49.540 --> 00:13:51.115
or just to reoccur periodically.

00:13:53.810 --> 00:13:55.385
So because examples
are fun, let's

00:13:55.385 --> 00:13:56.510
take a look at another one.

00:13:56.510 --> 00:13:59.400
And this one is
going to look more

00:13:59.400 --> 00:14:02.160
at the timing side of things
rather than the other one.

00:14:02.160 --> 00:14:03.800
So again, we're using
some integer job

00:14:03.800 --> 00:14:06.340
ID, which you've incremented
by one in this case,

00:14:06.340 --> 00:14:09.270
because we used some
integer in the last example.

00:14:09.270 --> 00:14:14.450
Same, this is providing end
point to the JobScheduler.

00:14:14.450 --> 00:14:16.230
But here we're
seeing that I don't

00:14:16.230 --> 00:14:18.870
want this to run until
five seconds has passed.

00:14:18.870 --> 00:14:23.230
So only after five seconds will
this be eligible for execution.

00:14:23.230 --> 00:14:25.970
And this is an
interesting setup.

00:14:25.970 --> 00:14:28.890
In this case, we're
overriding with a deadline.

00:14:28.890 --> 00:14:32.280
So were saying, in 15
minutes, come what may,

00:14:32.280 --> 00:14:34.720
this task has to run.

00:14:34.720 --> 00:14:38.410
So for example, you
think that if we

00:14:38.410 --> 00:14:40.035
asked the network
but 15 minutes passed

00:14:40.035 --> 00:14:41.993
and there wasn't a network
because the phone is

00:14:41.993 --> 00:14:44.330
in airplane mode or there
just was nothing available,

00:14:44.330 --> 00:14:45.371
you would be run anyways.

00:14:45.371 --> 00:14:47.340
So this is a
guarantee for you guys

00:14:47.340 --> 00:14:50.520
to know that your job will
occur by a certain point.

00:14:50.520 --> 00:14:54.210
But bearing in mind that
if you set this deadline,

00:14:54.210 --> 00:14:57.730
it's your responsibility
to check in your code

00:14:57.730 --> 00:15:04.140
that the device is charging or
that the network is connected.

00:15:04.140 --> 00:15:06.950
So that's an example.

00:15:06.950 --> 00:15:08.860
And we've seen, so
far, how you build

00:15:08.860 --> 00:15:10.860
these objects, a bunch
of different criteria,

00:15:10.860 --> 00:15:12.410
and the functionality
you get and how

00:15:12.410 --> 00:15:14.400
you hand them to
the JobScheduler.

00:15:14.400 --> 00:15:17.950
Let's talk a bit about how
you execute your logic.

00:15:17.950 --> 00:15:18.960
It is pretty simple.

00:15:18.960 --> 00:15:21.520
The system, when it's
determined that your job is

00:15:21.520 --> 00:15:25.400
eligible to run, will just call
onStartJob in your service.

00:15:25.400 --> 00:15:28.700
And the service in this case
is a service that we provide,

00:15:28.700 --> 00:15:31.776
so you don't have to worry
about any of the service life

00:15:31.776 --> 00:15:33.400
cycle mechanisms or
anything like that.

00:15:33.400 --> 00:15:36.380
You just override
onStartJob, bearing in mind

00:15:36.380 --> 00:15:38.890
that this happens in the main
thread of the application.

00:15:38.890 --> 00:15:41.280
So any RIFF that
you want to do, you

00:15:41.280 --> 00:15:43.890
have to ofFbo it using any
of the numerous framework

00:15:43.890 --> 00:15:47.730
components that let you
do concurrent programming.

00:15:47.730 --> 00:15:51.390
You do your work, and you call
a job finished when you're done.

00:15:51.390 --> 00:15:55.510
But we set up a
bunch of criteria

00:15:55.510 --> 00:15:57.050
like, for example, charging.

00:15:57.050 --> 00:15:59.680
And it might be the case
that you're doing your work

00:15:59.680 --> 00:16:01.230
and the phone is unplugged.

00:16:01.230 --> 00:16:03.050
So the facility for
that is that if this

00:16:03.050 --> 00:16:06.330
happens and the criteria that
you set up are no longer valid,

00:16:06.330 --> 00:16:08.214
the system will call
onStopJob to let you

00:16:08.214 --> 00:16:10.380
know, hey, you need to wrap
up whatever you're doing

00:16:10.380 --> 00:16:13.690
and stop doing your work.

00:16:13.690 --> 00:16:15.150
So yeah, that's it.

00:16:15.150 --> 00:16:17.440
I mean, I think it's
a really powerful API.

00:16:17.440 --> 00:16:18.540
It's really simple to use.

00:16:18.540 --> 00:16:21.015
You just hand a lot of the
complicated functionality

00:16:21.015 --> 00:16:23.040
to scheduler, and you
worry about what's

00:16:23.040 --> 00:16:26.050
important to you-- just
executing your logic.

00:16:26.050 --> 00:16:28.680
But how do we actually
measure that we've

00:16:28.680 --> 00:16:29.744
made some improvements?

00:16:29.744 --> 00:16:31.910
MEGHAN DESAI: That's an
excellent question, Matthew.

00:16:31.910 --> 00:16:34.530
We talked about all these
APIs and some of the issues

00:16:34.530 --> 00:16:35.670
that we discovered earlier.

00:16:35.670 --> 00:16:37.985
Well, you start investing
energy into building them,

00:16:37.985 --> 00:16:40.610
and you want to be able to know
that you're making a difference

00:16:40.610 --> 00:16:42.660
and you're actually
improving the battery life.

00:16:42.660 --> 00:16:44.990
So one of the ways to do
this is to literally hook up

00:16:44.990 --> 00:16:46.682
an amp meter to
the battery leaves.

00:16:46.682 --> 00:16:48.140
That's pretty much
what we did when

00:16:48.140 --> 00:16:49.970
we came up with
that chart earlier

00:16:49.970 --> 00:16:53.730
that you saw-- those charts that
showed current draw over time.

00:16:53.730 --> 00:16:56.795
This sounds pretty cool,
but we did this in a lab

00:16:56.795 --> 00:16:57.560
with equipment.

00:16:57.560 --> 00:17:00.000
It's probably not practical
for most of you out there.

00:17:00.000 --> 00:17:02.510
So we've improved the
on-board battery stats.

00:17:02.510 --> 00:17:04.450
These are the things
on device-- information

00:17:04.450 --> 00:17:06.325
that's collected that's
relevant to the power

00:17:06.325 --> 00:17:07.619
consumption on the device.

00:17:07.619 --> 00:17:09.430
So let's talk about that.

00:17:09.430 --> 00:17:11.430
This is the same
set of information

00:17:11.430 --> 00:17:14.899
that is currently powering the
Battery Settings page, where

00:17:14.899 --> 00:17:17.190
you can see which applications
or system components are

00:17:17.190 --> 00:17:19.240
consuming what amount of power.

00:17:19.240 --> 00:17:20.420
But how do you get to this?

00:17:20.420 --> 00:17:23.060
There's a simple
ADB command, dumpsys

00:17:23.060 --> 00:17:26.869
batterystats, that dumps out the
battery-relevant information.

00:17:26.869 --> 00:17:28.947
The --charged is
just to make sure you

00:17:28.947 --> 00:17:31.530
get the data since the last time
the device was fully charged.

00:17:31.530 --> 00:17:33.113
That way you reduce
some of the noise,

00:17:33.113 --> 00:17:35.639
and you get a nice clean
discharge cycle into this data.

00:17:35.639 --> 00:17:37.180
You can also supply
the package name,

00:17:37.180 --> 00:17:40.120
which would make sure that
the data is restricted

00:17:40.120 --> 00:17:42.020
to your specific application.

00:17:42.020 --> 00:17:44.041
Otherwise you'll get the
global stats as well.

00:17:44.041 --> 00:17:45.540
So let's take a
look at what you get

00:17:45.540 --> 00:17:47.370
when you type this command in.

00:17:47.370 --> 00:17:49.490
One of the things you
get is the global stats.

00:17:49.490 --> 00:17:51.490
This is actually really
interesting information.

00:17:51.490 --> 00:17:53.860
It's giving you a macro
view over that discharge

00:17:53.860 --> 00:17:56.244
cycle about what happened,
what consumed the power.

00:17:56.244 --> 00:17:58.660
So some of the things that are
interesting here to us when

00:17:58.660 --> 00:18:00.990
we look at these are the
partial wakelock time.

00:18:00.990 --> 00:18:02.629
If that time is
really, really high,

00:18:02.629 --> 00:18:04.170
then you know that
something was off.

00:18:04.170 --> 00:18:06.897
Something was keeping the
processor awake way too long,

00:18:06.897 --> 00:18:09.230
and that was probably the
culprit that you can go after.

00:18:09.230 --> 00:18:11.265
You can also see
the total run time.

00:18:11.265 --> 00:18:12.890
In addition to that,
you can see things

00:18:12.890 --> 00:18:15.387
like the mobile radio
being on, the packets

00:18:15.387 --> 00:18:17.470
that were received on a
mobile radio versus Wi-Fi,

00:18:17.470 --> 00:18:20.360
and that can give you a sense
of what the network activity was

00:18:20.360 --> 00:18:23.460
like during that
discharge cycle.

00:18:23.460 --> 00:18:26.030
We have also added a brand new
thing to this battery stats

00:18:26.030 --> 00:18:28.712
in L, something called the
milliseconds per packet.

00:18:28.712 --> 00:18:30.170
This is actually
quite interesting.

00:18:30.170 --> 00:18:32.220
What it's showing
is the total number

00:18:32.220 --> 00:18:34.506
of packets sent by
a particular UID.

00:18:34.506 --> 00:18:36.130
And a UID, again,
for your application,

00:18:36.130 --> 00:18:38.180
is you can go look
that up in DDMS.

00:18:38.180 --> 00:18:40.320
It's the same UID
that's used here.

00:18:40.320 --> 00:18:42.260
It shows you the
number of packets

00:18:42.260 --> 00:18:44.870
that your application sent
and the time that it took.

00:18:44.870 --> 00:18:47.050
So you can see, for
example, the first example

00:18:47.050 --> 00:18:50.390
here, UIDA is extremely
inefficient because it sent

00:18:50.390 --> 00:18:52.760
only four packets but
it took over 12 seconds

00:18:52.760 --> 00:18:54.920
to accomplish that.

00:18:54.920 --> 00:18:56.670
Let's take a look at
another example here.

00:18:56.670 --> 00:19:00.770
So UIDs B and C. So B, you can
see that it sent 3,600 packets

00:19:00.770 --> 00:19:06.010
over 42 minutes, versus C sent
about the same, 4,000 packets,

00:19:06.010 --> 00:19:07.410
but only over two minutes.

00:19:07.410 --> 00:19:09.300
So there's a huge
difference there,

00:19:09.300 --> 00:19:11.090
and it tells you
that one was far more

00:19:11.090 --> 00:19:13.570
efficient in transmitting that
information than the other.

00:19:13.570 --> 00:19:15.778
Now, this could be for
completely legitimate reasons,

00:19:15.778 --> 00:19:18.110
or it could be an area
that you can investigate

00:19:18.110 --> 00:19:20.240
to figure out what was going on.

00:19:20.240 --> 00:19:22.820
Next, we have
aggregated stats by UID.

00:19:22.820 --> 00:19:26.170
Again, that same UID I mentioned
for your application package.

00:19:26.170 --> 00:19:28.880
Here you can see data that is
specific to your application--

00:19:28.880 --> 00:19:32.120
similar things like
mobile time used.

00:19:32.120 --> 00:19:35.470
An interesting thing here is
the processor wakelock usage.

00:19:35.470 --> 00:19:38.160
So if you recall, what happens
when we talked about the CPU

00:19:38.160 --> 00:19:38.660
being awake?

00:19:38.660 --> 00:19:40.970
When you wake up
the CPU, there's

00:19:40.970 --> 00:19:42.495
time spent to
perform the actions

00:19:42.495 --> 00:19:44.120
that your application
wants to perform,

00:19:44.120 --> 00:19:47.110
but then that also enables
other applications to wake

00:19:47.110 --> 00:19:48.730
up and perform other actions.

00:19:48.730 --> 00:19:51.557
So those actions that is
allowing other applications

00:19:51.557 --> 00:19:53.140
to do things while
you're holding that

00:19:53.140 --> 00:19:56.160
wakelock-- that is now being
blamed to your application

00:19:56.160 --> 00:19:56.870
by 50%.

00:19:56.870 --> 00:19:59.090
So 50% of that
extra time is being

00:19:59.090 --> 00:20:02.010
blamed to your application.

00:20:02.010 --> 00:20:04.270
Then finally, there
is Battery History.

00:20:04.270 --> 00:20:05.290
This is really powerful.

00:20:05.290 --> 00:20:08.610
This is showing me every
single battery-related event

00:20:08.610 --> 00:20:11.290
that happened over
that discharge cycle.

00:20:11.290 --> 00:20:13.090
You can find this
in a bug report.

00:20:13.090 --> 00:20:16.420
Just look for the DUMP OF
SERVICE batterystats header,

00:20:16.420 --> 00:20:17.920
and you can find
this information.

00:20:17.920 --> 00:20:20.830
It's actually at the top
of the Battery Stats.

00:20:20.830 --> 00:20:23.650
And here you can see things like
when the mobile radio was up,

00:20:23.650 --> 00:20:27.150
when wakelocks were being
held, or different wake reasons

00:20:27.150 --> 00:20:28.140
for the wakelocks.

00:20:28.140 --> 00:20:30.820
And from this, you can
determine unusual patterns

00:20:30.820 --> 00:20:33.477
of power consumption
or system activity.

00:20:33.477 --> 00:20:36.060
MATTHEW WILLIAMS: I don't know,
Meghan, just looking at this--

00:20:36.060 --> 00:20:38.710
I'm sure there's a lot
of really rich data--

00:20:38.710 --> 00:20:41.960
but there's way too many
symbols and complicated numbers

00:20:41.960 --> 00:20:43.476
and names.

00:20:43.476 --> 00:20:45.235
If there was some
way to make this

00:20:45.235 --> 00:20:47.860
more transparent to the user, I
think it'd be much more useful.

00:20:47.860 --> 00:20:48.350
MEGHAN DESAI: You think so?

00:20:48.350 --> 00:20:50.200
All right, Matthew,
just for you,

00:20:50.200 --> 00:20:52.220
we built a two-clock
battery historian.

00:20:52.220 --> 00:20:55.119
So like Matthew, I like
visualizations as well.

00:20:55.119 --> 00:20:56.660
And when I looked
at this bug report,

00:20:56.660 --> 00:20:59.330
it was actually crazy
amounts of information.

00:20:59.330 --> 00:21:01.360
I tried to put the
whole thing into here,

00:21:01.360 --> 00:21:02.940
but it was just
way, way too long.

00:21:02.940 --> 00:21:05.952
And so to be able to consume
all that information nicely,

00:21:05.952 --> 00:21:07.660
you need a nice
visualization, and that's

00:21:07.660 --> 00:21:09.166
why we built Battery Historian.

00:21:09.166 --> 00:21:11.040
What it takes is it
takes those battery stats

00:21:11.040 --> 00:21:12.623
and spits out some
nice visualization.

00:21:12.623 --> 00:21:15.810
It's a Python script that
builds an HTML visualization.

00:21:15.810 --> 00:21:17.560
So enough talking about
this magical tool.

00:21:17.560 --> 00:21:19.320
Let's see what this produced.

00:21:19.320 --> 00:21:22.580
So Matthew was kind enough to
donate one of his bug reports

00:21:22.580 --> 00:21:23.870
to analyze here.

00:21:23.870 --> 00:21:26.820
So let's look at some
activity on his phone.

00:21:26.820 --> 00:21:29.390
This is showing just the first
few hours of that discharge

00:21:29.390 --> 00:21:32.480
cycle, and you can see a
lot of different roads here.

00:21:32.480 --> 00:21:34.120
So we're going to
zoom into this,

00:21:34.120 --> 00:21:36.620
but each of these
rectangles are representing

00:21:36.620 --> 00:21:38.730
when that activity was
reported, for example.

00:21:38.730 --> 00:21:40.271
So let's actually
take a closer look.

00:21:40.271 --> 00:21:44.840
We're going to zoom into that
part of the-- let's do this.

00:21:44.840 --> 00:21:45.640
All right.

00:21:45.640 --> 00:21:48.260
So the first row there
is the battery level.

00:21:48.260 --> 00:21:50.720
This is when the battery
level was reported,

00:21:50.720 --> 00:21:51.787
and the system logs that.

00:21:51.787 --> 00:21:53.370
So you can see, for
example, you hover

00:21:53.370 --> 00:21:56.090
over one of these
rectangles, and you

00:21:56.090 --> 00:21:58.607
can see that the battery
level reported was down to 93%

00:21:58.607 --> 00:21:59.190
at that point.

00:21:59.190 --> 00:22:01.064
Again, this is since
the last time the device

00:22:01.064 --> 00:22:03.480
was fully charged, so you're
expecting a discharge curve

00:22:03.480 --> 00:22:04.660
there.

00:22:04.660 --> 00:22:06.290
Let's take a look
at this next row.

00:22:06.290 --> 00:22:07.200
Top.

00:22:07.200 --> 00:22:10.040
Top means, what was the
application running at the top?

00:22:10.040 --> 00:22:13.070
What was the user actually
using at that time

00:22:13.070 --> 00:22:14.550
that's reported here?

00:22:14.550 --> 00:22:16.610
And so let's see
what Matthew was

00:22:16.610 --> 00:22:18.540
doing in those big
red rectangles.

00:22:18.540 --> 00:22:21.310
So that second rectangle--
looks like Matthew

00:22:21.310 --> 00:22:23.410
was using WhatsApp.

00:22:23.410 --> 00:22:24.344
That's cool, Matthew.

00:22:24.344 --> 00:22:25.494
Communicating on WhatsApp.

00:22:25.494 --> 00:22:26.160
You got friends.

00:22:26.160 --> 00:22:27.894
That's cool.

00:22:27.894 --> 00:22:29.435
Let's look at what
else he was doing.

00:22:29.435 --> 00:22:32.879
Ah, this other big rectangle
that you see there-- he

00:22:32.879 --> 00:22:34.420
was using the dialer
app, so maybe he

00:22:34.420 --> 00:22:35.200
was making a phone call.

00:22:35.200 --> 00:22:35.760
We'll find out.

00:22:35.760 --> 00:22:36.718
Let's see what happens.

00:22:36.718 --> 00:22:37.589
All right.

00:22:37.589 --> 00:22:39.130
We look at some of
these other lines.

00:22:39.130 --> 00:22:41.230
That big green line--
Wi-Fi was running,

00:22:41.230 --> 00:22:42.650
so he was on Wi-Fi
the whole time.

00:22:42.650 --> 00:22:44.426
That's pretty cool.

00:22:44.426 --> 00:22:48.450
Next, let's look at
this screen line.

00:22:48.450 --> 00:22:49.432
What's happening here?

00:22:49.432 --> 00:22:50.140
It's interesting.

00:22:50.140 --> 00:22:53.460
I can see already that the first
two rectangles are correlated

00:22:53.460 --> 00:22:57.490
with the first two red
rectangles up on the top,

00:22:57.490 --> 00:23:00.950
and it looks like the screen was
on when he was using WhatsApp.

00:23:00.950 --> 00:23:02.380
That makes sense.

00:23:02.380 --> 00:23:03.590
Let's see what else is here.

00:23:03.590 --> 00:23:04.645
Ah, phone and call.

00:23:04.645 --> 00:23:05.200
All right.

00:23:05.200 --> 00:23:06.658
It looks like he
was making a call.

00:23:06.658 --> 00:23:08.970
We were right that when
the dialer was up top,

00:23:08.970 --> 00:23:11.412
he was actually in a phone call.

00:23:11.412 --> 00:23:12.870
So look at how easy
that was for me

00:23:12.870 --> 00:23:16.300
to take that complicated
battery stats history report

00:23:16.300 --> 00:23:18.750
and quickly identify the
patterns of behavior and usage

00:23:18.750 --> 00:23:19.250
there.

00:23:19.250 --> 00:23:21.770
Now let's dig deeper
into actually identifying

00:23:21.770 --> 00:23:24.710
some of the problem areas
that we're talking about.

00:23:24.710 --> 00:23:28.230
So this other part of the report
we can now zoom into-- you

00:23:28.230 --> 00:23:30.330
can see things like
wakelocks being reported,

00:23:30.330 --> 00:23:33.274
when the system was running,
things when mobile radio was

00:23:33.274 --> 00:23:35.190
on and off, and the
reasons for the wakelocks.

00:23:35.190 --> 00:23:36.850
And again, as I
mentioned, hovering over

00:23:36.850 --> 00:23:38.600
these rectangles can
give you more insight

00:23:38.600 --> 00:23:42.000
into what that entry
is in the logs.

00:23:42.000 --> 00:23:44.980
So let's take a look
at another bug report.

00:23:44.980 --> 00:23:47.200
Now, we decided to
do a simulation.

00:23:47.200 --> 00:23:49.210
We looked at data--
the actual usage data

00:23:49.210 --> 00:23:52.340
from a whole bunch of
our testers at Google.

00:23:52.340 --> 00:23:54.320
And based on the
data from there,

00:23:54.320 --> 00:23:57.300
we created 50
simulated applications,

00:23:57.300 --> 00:23:58.870
and we wanted to
see what happens,

00:23:58.870 --> 00:24:00.790
and we collected
this bug report.

00:24:00.790 --> 00:24:02.610
So let's see what's
going on here.

00:24:02.610 --> 00:24:04.568
I'm going to zoom in
again in that bottom part.

00:24:04.568 --> 00:24:07.070
It looks like there's
some activity there.

00:24:07.070 --> 00:24:08.220
Holy crap.

00:24:08.220 --> 00:24:08.930
All right.

00:24:08.930 --> 00:24:10.990
So there's a lot of
rectangles there.

00:24:10.990 --> 00:24:12.760
Looks like there's
a lot happening.

00:24:12.760 --> 00:24:15.230
All these applications
are hyperactive.

00:24:15.230 --> 00:24:18.110
Hey, Matthew, do you think
the paradigms of "lazy first"

00:24:18.110 --> 00:24:19.180
could be applied here?

00:24:19.180 --> 00:24:20.015
Maybe these things
are legitimate,

00:24:20.015 --> 00:24:22.290
but maybe we could apply
those paradigms here.

00:24:22.290 --> 00:24:23.206
MATTHEW WILLIAMS: Yes.

00:24:23.206 --> 00:24:26.500
So, Meghan, this looks
like a prime candidate

00:24:26.500 --> 00:24:28.700
for the types of
defer and coalescing

00:24:28.700 --> 00:24:30.290
that we were talking
about earlier.

00:24:30.290 --> 00:24:32.247
I mean, you see all
these striations,

00:24:32.247 --> 00:24:34.705
which basically means that the
phone is waking up, grabbing

00:24:34.705 --> 00:24:37.200
a wakelock, doing some
really small amounts of work,

00:24:37.200 --> 00:24:38.460
and going back to sleep.

00:24:38.460 --> 00:24:41.430
This is bad because your paying
that overhead of loading up

00:24:41.430 --> 00:24:43.810
the application process
up every single time

00:24:43.810 --> 00:24:45.549
you see one of these spikes.

00:24:45.549 --> 00:24:47.590
And the same things happen
with the mobile radio.

00:24:47.590 --> 00:24:49.930
It's important to remember
here that, again, you

00:24:49.930 --> 00:24:52.910
have that really expensive
long tail of not quite idle,

00:24:52.910 --> 00:24:55.550
not quite active states.

00:24:55.550 --> 00:24:57.780
And we're paying that
penalty every single time

00:24:57.780 --> 00:24:59.260
one of these little blocks ends.

00:24:59.260 --> 00:25:02.460
Because the mobile radio is
coming up, you're using it,

00:25:02.460 --> 00:25:04.470
and it's going right back down.

00:25:04.470 --> 00:25:06.820
So as Meghan said,
we've got this data

00:25:06.820 --> 00:25:09.915
from a bunch of
Google employees.

00:25:09.915 --> 00:25:11.290
So we have these
50 applications,

00:25:11.290 --> 00:25:14.830
and we simulated this traffic by
using the Alarm Manager to just

00:25:14.830 --> 00:25:18.600
naively wake up the application
and send some [INAUDIBLE]

00:25:18.600 --> 00:25:22.890
to know it's network traffic,
and then assume that it's

00:25:22.890 --> 00:25:25.700
going to finish its work,
and go back to sleep.

00:25:25.700 --> 00:25:28.140
So we decided to make these
applications more lazy

00:25:28.140 --> 00:25:32.725
by adding a deferral
between 0 and 30 seconds.

00:25:32.725 --> 00:25:36.140
And we just randomly chose
a number between 0 and 30

00:25:36.140 --> 00:25:39.136
for each of these network calls,
for each of these applications.

00:25:39.136 --> 00:25:40.760
So I'm not saying
that it's 30 seconds.

00:25:40.760 --> 00:25:41.820
I'm saying that,
on average, it's

00:25:41.820 --> 00:25:43.440
probably going to be about
15 seconds, because this

00:25:43.440 --> 00:25:45.245
was a uniform
random distribution.

00:25:45.245 --> 00:25:48.470
And we're going to get as many
deferrals as 0 as we do 30.

00:25:48.470 --> 00:25:52.380
So 0 seconds of deferral being
the active case, where it just

00:25:52.380 --> 00:25:54.290
doesn't try to
wait around at all.

00:25:54.290 --> 00:25:57.400
And let's see what we got.

00:25:57.400 --> 00:25:59.745
So immediately, even from
a layman's perspective,

00:25:59.745 --> 00:26:02.620
the bottom table
is much cleaner.

00:26:02.620 --> 00:26:05.136
We don't have nearly
as many wakeups,

00:26:05.136 --> 00:26:07.230
which indicate that when
the phone does wake up,

00:26:07.230 --> 00:26:09.120
you see the mobile
network is active.

00:26:09.120 --> 00:26:12.230
So work is being
done, and then it

00:26:12.230 --> 00:26:14.060
goes back to sleep
at the end of that.

00:26:14.060 --> 00:26:16.870
Look at the shape of this mobile
video traffic at the bottom.

00:26:16.870 --> 00:26:18.570
It's much more compact.

00:26:18.570 --> 00:26:20.070
There are much fewer
of these boxes.

00:26:20.070 --> 00:26:23.990
So we're paying much less
of this overhead penalty

00:26:23.990 --> 00:26:27.350
per mobile video
active transition.

00:26:27.350 --> 00:26:29.050
So I think this
looks pretty good.

00:26:29.050 --> 00:26:29.870
MEGHAN DESAI: Matthew,
that is amazing.

00:26:29.870 --> 00:26:30.640
This is amazing.

00:26:30.640 --> 00:26:33.810
So you were able to use the
JobScheduler APIs to coalesce

00:26:33.810 --> 00:26:35.460
a lot of this
activity, and we're

00:26:35.460 --> 00:26:37.140
paying less of that
overhead penalty

00:26:37.140 --> 00:26:38.980
repeatedly that we
talked about earlier.

00:26:38.980 --> 00:26:42.920
So these are just beautiful
battery historian images.

00:26:42.920 --> 00:26:45.760
But what was the actual
impact on battery life like?

00:26:45.760 --> 00:26:47.301
MATTHEW WILLIAMS:
Yeah, you're right.

00:26:47.301 --> 00:26:49.220
I mean, it's one thing
to show a nice picture

00:26:49.220 --> 00:26:51.459
but the value that we're
trying to quantify here

00:26:51.459 --> 00:26:52.125
is battery life.

00:26:52.125 --> 00:26:55.820
And so this simulation
was run over two days,

00:26:55.820 --> 00:26:57.520
both for the active
Alarm Manager

00:26:57.520 --> 00:27:00.000
case and the lazy
JobScheduler case.

00:27:00.000 --> 00:27:02.590
And in the former debug,
we started at 100%,

00:27:02.590 --> 00:27:07.400
and it dropped down to about
55% battery life after two days.

00:27:07.400 --> 00:27:09.690
And lastly, the JobScheduler
the drop was from 100%

00:27:09.690 --> 00:27:11.390
to about 70%.

00:27:11.390 --> 00:27:14.500
So that's a really
remarkable difference,

00:27:14.500 --> 00:27:16.580
and I'm not making a
statement that we're

00:27:16.580 --> 00:27:19.440
going to see this improvement
in battery life across the board

00:27:19.440 --> 00:27:22.230
as soon as everybody jumps
onboard one of these APIs.

00:27:22.230 --> 00:27:24.152
But it does give kind
of a ballpark estimate

00:27:24.152 --> 00:27:25.860
of the types of
improvements we can make.

00:27:25.860 --> 00:27:28.193
MEGHAN DESAI: Yeah, but that's
still really, really cool

00:27:28.193 --> 00:27:30.710
that you were able to get
a 15% to 20% increase.

00:27:30.710 --> 00:27:32.390
Granted, this is a
simulated use case,

00:27:32.390 --> 00:27:35.180
but that means that there's
some real-world battery

00:27:35.180 --> 00:27:36.990
impact you could have for users.

00:27:36.990 --> 00:27:37.870
That's really cool.

00:27:37.870 --> 00:27:40.410
Now, Matthew, if I understood
the simulation correctly,

00:27:40.410 --> 00:27:42.820
though, you weren't
optimizing just the one app.

00:27:42.820 --> 00:27:44.810
You had to optimize
all 50 of the apps.

00:27:44.810 --> 00:27:45.600
Is that right?

00:27:45.600 --> 00:27:46.558
MATTHEW WILLIAMS: Yeah.

00:27:46.558 --> 00:27:49.520
So essentially what this
simulation comes like is that,

00:27:49.520 --> 00:27:50.580
I'm some [INAUDIBLE].

00:27:50.580 --> 00:27:54.830
I jumped into a device, and
I decided to artificially

00:27:54.830 --> 00:27:56.960
make each network request lazy.

00:27:56.960 --> 00:27:58.600
And that just isn't the case.

00:27:58.600 --> 00:28:00.872
This is something that
will affect everybody.

00:28:00.872 --> 00:28:03.205
This is something we're
thinking about in the framework.

00:28:03.205 --> 00:28:05.190
This is something that we're
thinking about in Google Play

00:28:05.190 --> 00:28:05.820
services.

00:28:05.820 --> 00:28:07.280
And this is also
the kind of thing

00:28:07.280 --> 00:28:09.950
that affects all of you
guys, the developers.

00:28:09.950 --> 00:28:14.190
But the issue with it
being a collective problem

00:28:14.190 --> 00:28:17.160
is that, when we start making
steps in the right direction,

00:28:17.160 --> 00:28:20.297
we can reap the
collective rewards.

00:28:20.297 --> 00:28:22.380
MEGHAN DESAI: That's very
eloquently put, Matthew.

00:28:22.380 --> 00:28:22.880
Thank you.

00:28:22.880 --> 00:28:23.730
He's exactly right.

00:28:23.730 --> 00:28:25.800
This is something
that we all have

00:28:25.800 --> 00:28:28.120
to embrace and help address.

00:28:28.120 --> 00:28:30.510
And if I were to sum
up this whole talk,

00:28:30.510 --> 00:28:32.480
we'd just tell you
about procrastinating.

00:28:32.480 --> 00:28:34.680
We want you to build apps
that procrastinate, that

00:28:34.680 --> 00:28:35.760
are lazy first.

00:28:35.760 --> 00:28:37.550
You can use the
JobScheduler APIs

00:28:37.550 --> 00:28:39.800
to help do that in
an efficient way

00:28:39.800 --> 00:28:43.640
and allow the platform to
optimize how it helps utilize

00:28:43.640 --> 00:28:46.445
the underlying system resources
in a power-efficient manner.

00:28:46.445 --> 00:28:48.150
And then finally,
Battery Historian

00:28:48.150 --> 00:28:50.290
is a tool that can
help you digest

00:28:50.290 --> 00:28:53.490
large amounts of
battery-related statistics

00:28:53.490 --> 00:28:55.634
and see them visually
in a nice timeline.

00:28:55.634 --> 00:28:56.800
MATTHEW WILLIAMS: Yeah, man.

00:28:56.800 --> 00:29:00.670
That Battery Historian too was
excellent, but how do people

00:29:00.670 --> 00:29:01.410
actually use it?

00:29:01.410 --> 00:29:03.087
Because it's one
thing to say a tool

00:29:03.087 --> 00:29:05.670
exists and another thing to put
it in the hands of developers.

00:29:05.670 --> 00:29:07.822
MEGHAN DESAI: That's
actually a really good point.

00:29:07.822 --> 00:29:09.280
Battery Historian
is a tool that we

00:29:09.280 --> 00:29:11.599
are open-sourcing
for all of you guys.

00:29:11.599 --> 00:29:13.140
As I mentioned, it's
a Python script.

00:29:13.140 --> 00:29:16.540
You can find it at
that GitHub URL today.

00:29:16.540 --> 00:29:20.092
Keeping in mind, though, it will
work with battery statistics

00:29:20.092 --> 00:29:22.550
from the L Preview Build, which
will be available tomorrow.

00:29:22.550 --> 00:29:23.980
So once you start
running that Build,

00:29:23.980 --> 00:29:25.830
you can gather the
battery stats and start

00:29:25.830 --> 00:29:29.397
using Battery Historian
to visualize those stats.

00:29:29.397 --> 00:29:31.480
Also, if you have any
questions about what we just

00:29:31.480 --> 00:29:34.630
talked about-- Project Volta,
JobScheduler APIs, or Battery

00:29:34.630 --> 00:29:38.010
Historian-- we have office
hours for Project Volta

00:29:38.010 --> 00:29:40.320
from 3:00 to 4:00 PM
today and tomorrow

00:29:40.320 --> 00:29:41.810
at the Android Sandbox booth.

00:29:41.810 --> 00:29:44.002
It's just right outside.

00:29:44.002 --> 00:29:44.960
MATTHEW WILLIAMS: Yeah.

00:29:44.960 --> 00:29:46.960
So we went over the
JobScheduler in some detail,

00:29:46.960 --> 00:29:49.720
and there's also an I/O
Bytes video up on YouTube

00:29:49.720 --> 00:29:52.050
if you want to dig some
more into this stuff.

00:29:52.050 --> 00:29:54.716
But if you're interested in just
jumping straight into the code,

00:29:54.716 --> 00:29:57.810
we have a sample app up, which
will let you set up these jobs.

00:29:57.810 --> 00:30:00.580
It gives you a very simple
UI to specify the constraints

00:30:00.580 --> 00:30:02.142
that you're
interested in and get

00:30:02.142 --> 00:30:03.350
the callback from the system.

00:30:03.350 --> 00:30:04.308
So that's up on GitHub.

00:30:04.308 --> 00:30:08.197
It's Google Samples,
Android JobScheduler.

00:30:08.197 --> 00:30:09.780
MEGHAN DESAI: And
we started this talk

00:30:09.780 --> 00:30:11.960
by saying that we're
passionate about battery life.

00:30:11.960 --> 00:30:13.980
This is not just something
that we're passionate

00:30:13.980 --> 00:30:16.290
about in the Android
framework but across Google.

00:30:16.290 --> 00:30:17.980
And so I'd encourage
you to check out

00:30:17.980 --> 00:30:20.110
some of the other sessions, like
the "Achieving More With Mobile

00:30:20.110 --> 00:30:22.140
Cloud," where they might
talk about some of the APIs

00:30:22.140 --> 00:30:23.681
that they're
introducing and building

00:30:23.681 --> 00:30:26.000
to help make things
more power efficient

00:30:26.000 --> 00:30:28.400
and make it easier for you
guys to make your applications

00:30:28.400 --> 00:30:29.770
more power efficient as well.

00:30:29.770 --> 00:30:31.400
MATTHEW WILLIAMS: Yeah,
Meghan, thanks a lot, man.

00:30:31.400 --> 00:30:32.691
I thoroughly enjoyed that talk.

00:30:32.691 --> 00:30:34.800
I thought you were
eloquent and well-spoken.

00:30:34.800 --> 00:30:35.530
MEGHAN DESAI: Thank you, Matt.

00:30:35.530 --> 00:30:36.500
Likewise, likewise.

00:30:36.500 --> 00:30:38.440
And thank you all for
attending the session.

00:30:38.440 --> 00:30:41.850
We hope you enjoyed it as
much as Matthew and I did.

00:30:41.850 --> 00:30:44.012
Now go out there and try
out these APIs and Battery

00:30:44.012 --> 00:30:45.720
Historian and let us
know what you think.

00:30:45.720 --> 00:30:46.130
MATTHEW WILLIAMS: Yeah, thanks.

00:30:46.130 --> 00:30:47.130
MEGHAN DESAI: Thank you.

00:30:47.130 --> 00:30:48.130
[APPLAUSE]

