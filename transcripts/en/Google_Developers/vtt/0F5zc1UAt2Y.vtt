WEBVTT
Kind: captions
Language: en

00:00:06.000 --> 00:00:08.567
Chandler: Welcome, everyone.
My name is David Chandler.

00:00:08.567 --> 00:00:11.467
I work with the Google
Web Toolkit team in Atlanta,

00:00:11.467 --> 00:00:13.534
and today, John LaBanca and I

00:00:13.534 --> 00:00:16.033
are gonna be talking
about some ways to improve

00:00:16.033 --> 00:00:18.100
the performance
of your GWT apps.

00:00:18.100 --> 00:00:20.400
I want to acknowledge,
at the outset here,

00:00:20.400 --> 00:00:22.367
uh, we recognize
that we're competing

00:00:22.367 --> 00:00:25.133
with another great GWT session
across the hall,

00:00:25.133 --> 00:00:28.667
the gaming program session with
Phil Rogers and Ray Cromwell,

00:00:28.667 --> 00:00:32.033
and, uh, we'd like
to be there, too... [laughs]

00:00:32.033 --> 00:00:33.801
'cause they're doin'
some cool stuff,

00:00:33.801 --> 00:00:37.200
so I promised to do at least
one cool visual demo for you

00:00:37.200 --> 00:00:38.934
during this talk, uh,

00:00:38.934 --> 00:00:42.100
so you can get something--
some eye candy out of it.

00:00:43.501 --> 00:00:46.334
So we're gonna talk first about
why does speed matter?

00:00:46.334 --> 00:00:48.000
Just some interesting numbers

00:00:48.000 --> 00:00:50.501
related to your page load times
and exit times.

00:00:50.501 --> 00:00:52.334
We'll look at
5 performance pitfalls.

00:00:52.334 --> 00:00:54.334
A few of these,
you may have seen

00:00:54.334 --> 00:00:56.000
from previous I/O conferences,

00:00:56.000 --> 00:00:58.000
and then there's
some new stuff, as well.

00:00:58.000 --> 00:00:59.667
Then we'll talk about the new--

00:00:59.667 --> 00:01:01.734
John will talk about
the new cell widgets,

00:01:01.734 --> 00:01:04.267
uh, in GWT 2.1 and following.

00:01:04.267 --> 00:01:06.534
We'll look at activities
and places

00:01:06.534 --> 00:01:08.434
and code splitting
as a technique

00:01:08.434 --> 00:01:11.033
to improve your
application's performance,

00:01:11.033 --> 00:01:13.400
and then finally,
some compiler tips

00:01:13.400 --> 00:01:16.167
at the end of our talk.

00:01:16.167 --> 00:01:18.534
So first of all,
why does speed matter?

00:01:18.534 --> 00:01:21.033
This is an interesting graph
from wikia.com.

00:01:21.033 --> 00:01:23.033
They measured the exit rate
at their site

00:01:23.033 --> 00:01:24.801
versus the load time,

00:01:24.801 --> 00:01:27.801
and showed that as the load time
approached five seconds,

00:01:27.801 --> 00:01:30.634
they would lose up to 20%
of their users.

00:01:30.634 --> 00:01:33.601
Now Google did a test
once upon a time

00:01:33.601 --> 00:01:36.767
of this same thing, and we had
more dramatic numbers.

00:01:36.767 --> 00:01:39.667
People asked for 30
search results, instead of 10,

00:01:39.667 --> 00:01:42.767
and that increased the load time
half a second

00:01:42.767 --> 00:01:44.801
for the first page
of search results,

00:01:44.801 --> 00:01:47.267
and what we measured
in small experiments

00:01:47.267 --> 00:01:49.234
was that, over a 6-week period,

00:01:49.234 --> 00:01:51.667
that resulted in a 25% decline

00:01:51.667 --> 00:01:53.801
in the first-page
search results.

00:01:53.801 --> 00:01:56.634
So that would be
about $2 1/2 billion,

00:01:56.634 --> 00:01:58.534
at the time
the test was conducted,

00:01:58.534 --> 00:02:00.167
in revenue for Google,

00:02:00.167 --> 00:02:02.067
so we were quite
concerned about that

00:02:02.067 --> 00:02:05.067
and we did not go out
with 30 search results.

00:02:05.067 --> 00:02:08.167
That's why you still see 10 as
the default on your page today.

00:02:08.167 --> 00:02:12.067
So let's talk about
some performance pitfalls.

00:02:12.067 --> 00:02:13.901
The first one, related to this,

00:02:13.901 --> 00:02:15.767
is don't lose the user
at startup.

00:02:15.767 --> 00:02:19.267
HTTP requests is the slowest
thing you can do in the browser.

00:02:19.267 --> 00:02:21.300
There's no JavaScript operation
that takes as long

00:02:21.300 --> 00:02:23.133
as going to the server and back.

00:02:23.133 --> 00:02:26.167
So one of the techniques,
which has been around in GWT

00:02:26.167 --> 00:02:28.067
for quite a while,
is to use ClientBundle

00:02:28.067 --> 00:02:30.501
to minimize trips for images

00:02:30.501 --> 00:02:32.367
and CSS resources.

00:02:32.367 --> 00:02:35.133
Chris Ramsdale showed
that technique in more detail

00:02:35.133 --> 00:02:36.901
in his talk
this morning on mobile,

00:02:36.901 --> 00:02:38.767
but basically,
it's a simple interface

00:02:38.767 --> 00:02:40.501
where you can combine

00:02:40.501 --> 00:02:42.367
all of your images
and resources together,

00:02:42.367 --> 00:02:45.701
and then GWT will make
only one trip to the server

00:02:45.701 --> 00:02:47.767
and split them all out
on the client

00:02:47.767 --> 00:02:49.901
instead of making
individual requests

00:02:49.901 --> 00:02:52.200
for each image in CSS.

00:02:52.200 --> 00:02:54.767
Another technique you can do
is to prefetch data

00:02:54.767 --> 00:02:58.434
that's needed by your first
page at load time,

00:02:58.434 --> 00:03:00.534
so one easy way to do this is,

00:03:00.534 --> 00:03:03.934
instead of hosting your GWT app
in a static HTML page,

00:03:03.934 --> 00:03:06.934
you can host it in a JSP page,
for example,

00:03:06.934 --> 00:03:10.133
and then any data that your--
your GWT app is gonna need,

00:03:10.133 --> 00:03:12.100
uh, just right off the bat,

00:03:12.100 --> 00:03:14.234
you just write in
as JavaScript variables

00:03:14.234 --> 00:03:16.701
into the host page,

00:03:16.701 --> 00:03:19.601
and then you can use
the GWT dictionary class

00:03:19.601 --> 00:03:23.067
to read those JavaScript
variables from your GWT app,

00:03:23.067 --> 00:03:26.067
or you can use
JSNI methods, as well,

00:03:26.067 --> 00:03:28.133
to do that.

00:03:28.133 --> 00:03:30.200
We've recently written
an article on this

00:03:30.200 --> 00:03:32.000
on the GWT code site,

00:03:32.000 --> 00:03:33.868
uh, that you can check out

00:03:33.868 --> 00:03:36.133
and get more info
on that technique.

00:03:36.133 --> 00:03:38.901
Okay, a second big
performance pitfall

00:03:38.901 --> 00:03:40.767
is don't lock up the browser.

00:03:40.767 --> 00:03:42.701
JavaScript is single-threaded,

00:03:42.701 --> 00:03:45.033
and so you don't want
the browser to become

00:03:45.033 --> 00:03:47.234
unresponsive to user input,

00:03:47.234 --> 00:03:49.234
and that means
you have to be careful,

00:03:49.234 --> 00:03:51.734
uh, when writing your GWT code.

00:03:51.734 --> 00:03:55.300
So Scheduler is the new feature

00:03:55.300 --> 00:03:57.601
that was--replaces
the timer feature

00:03:57.601 --> 00:03:59.501
in the older versions of GWT,

00:03:59.501 --> 00:04:01.567
and there's a method,
scheduleDeferred,

00:04:01.567 --> 00:04:04.767
that will wait until
the browser event loop runs,

00:04:04.767 --> 00:04:07.767
and then it will run your code
after that, so this--by--

00:04:07.767 --> 00:04:10.601
instead of just doing everything
inline in your GWT code,

00:04:10.601 --> 00:04:13.234
if you occasionally use
scheduleDeferred

00:04:13.234 --> 00:04:15.067
to defer some operations,

00:04:15.067 --> 00:04:19.067
then that will give users
a chance to respond.

00:04:19.067 --> 00:04:22.167
This is sometimes also required
as a workaround

00:04:22.167 --> 00:04:24.634
for focus and layout issues.

00:04:24.634 --> 00:04:27.868
Some of the widgets, like--
I know, a text box,

00:04:27.868 --> 00:04:30.934
if you call SetFocus true on it,

00:04:30.934 --> 00:04:34.868
um, then it may not actually
take effect in some browsers

00:04:34.868 --> 00:04:37.200
until after
the event loop runs,

00:04:37.200 --> 00:04:39.033
so you have to use
scheduleDeferred

00:04:39.033 --> 00:04:41.467
and then SetFocus true,
and then it will happen.

00:04:43.534 --> 00:04:45.534
Okay, for repetitive UI work,

00:04:45.534 --> 00:04:49.167
uh, similarly here, you don't
want to use a for loop

00:04:49.167 --> 00:04:51.334
to do, say, an animation frame,

00:04:51.334 --> 00:04:53.167
because that would
make the browser

00:04:53.167 --> 00:04:55.000
completely unresponsive
to user input.

00:04:55.000 --> 00:04:57.167
So instead, you're gonna
have a while loop,

00:04:57.167 --> 00:04:58.934
and then for each frame,

00:04:58.934 --> 00:05:00.834
the--the command
to draw a frame,

00:05:00.834 --> 00:05:04.334
you would put in
a scheduleFixedPeriod,

00:05:04.334 --> 00:05:06.767
for example,
and that would execute it

00:05:06.767 --> 00:05:09.701
once every 5, 10,
15 milliseconds,

00:05:09.701 --> 00:05:11.701
however often you specify.

00:05:11.701 --> 00:05:14.167
There's also a method
that's useful in the Scheduler

00:05:14.167 --> 00:05:15.934
called scheduleFinally,

00:05:15.934 --> 00:05:19.367
that will execute code
before the browser repaint,

00:05:19.367 --> 00:05:21.100
uh, event loop runs,

00:05:21.100 --> 00:05:23.367
and this is good
for coalescing calls,

00:05:23.367 --> 00:05:27.467
so if you had several calls that
manipulate the DOM, for example,

00:05:27.467 --> 00:05:31.133
then you could
use scheduleFinally

00:05:31.133 --> 00:05:32.901
to have them all run together,

00:05:32.901 --> 00:05:36.534
and that would reduce flicker,
as well as limit

00:05:36.534 --> 00:05:39.667
the amount of actual
DOM activity that's required

00:05:39.667 --> 00:05:41.601
in the browser.

00:05:43.400 --> 00:05:46.501
Okay, number 3--Don't make
two trips when one will do.

00:05:46.501 --> 00:05:48.400
What we're talking about here

00:05:48.400 --> 00:05:50.501
is batching of calls
to the server.

00:05:50.501 --> 00:05:53.267
So with GWT-RPC,

00:05:53.267 --> 00:05:55.267
you can do this using
the Command pattern,

00:05:55.267 --> 00:05:58.601
and there's lots of frameworks
out there for that GWT dispatch.

00:05:58.601 --> 00:06:00.767
Actually, there's a few
frameworks for that.

00:06:00.767 --> 00:06:03.534
The gwt-dispatch is one
that's been very popular,

00:06:03.534 --> 00:06:07.133
uh, lets you send nouns
or commands to the server

00:06:07.133 --> 00:06:10.200
rather than having to call
service methods directly,

00:06:10.200 --> 00:06:13.000
and by doing that,
you can queue up your commands,

00:06:13.000 --> 00:06:15.767
and then send them all at once
to the server.

00:06:15.767 --> 00:06:18.300
And I've written a couple
articles on my blog

00:06:18.300 --> 00:06:20.200
about using gwt-dispatch
to do that,

00:06:20.200 --> 00:06:23.167
or you can now use
RequestFactory,

00:06:23.167 --> 00:06:27.133
which is our new
RPC capability in GWT,

00:06:27.133 --> 00:06:30.834
and RequestFactory has built-in
batching support.

00:06:30.834 --> 00:06:32.801
So with GWT 2.3,

00:06:32.801 --> 00:06:37.367
you just call RequestContext
dot whatever your method is,

00:06:37.367 --> 00:06:39.601
and instead of calling fire
immediately,

00:06:39.601 --> 00:06:41.501
you call the dot 2 method,

00:06:41.501 --> 00:06:44.133
and then after all of those
are accumulated,

00:06:44.133 --> 00:06:45.901
then you call dot fire,

00:06:45.901 --> 00:06:47.934
and that just makes one trip
to the server.

00:06:47.934 --> 00:06:52.033
With GWT 2.4, which the beta
came out this week,

00:06:52.033 --> 00:06:55.667
you could actually do this
across services, as well,

00:06:55.667 --> 00:06:58.701
using the requestContext.append
method.

00:06:58.701 --> 00:07:00.767
So that's a good way, again,

00:07:00.767 --> 00:07:02.801
to minimize the chattiness

00:07:02.801 --> 00:07:04.734
of your application
to the server

00:07:04.734 --> 00:07:07.334
and thereby improve
its responsiveness.

00:07:08.968 --> 00:07:12.300
Number 4--Watch out
for RPC type explosion.

00:07:12.300 --> 00:07:16.400
So this one affects
not so much runtime performance

00:07:16.400 --> 00:07:18.267
as compile time.

00:07:18.267 --> 00:07:22.234
Basically, RPC, because
it supports polymorphism,

00:07:22.234 --> 00:07:25.234
will generate a serializer
and deserializer

00:07:25.234 --> 00:07:28.534
for each concrete type
of an interface

00:07:28.534 --> 00:07:30.667
in an inheritance hierarchy,

00:07:30.667 --> 00:07:33.467
and so you end up with--

00:07:33.467 --> 00:07:36.000
if you have large
inheritance hierarchies,

00:07:36.000 --> 00:07:38.968
you end up with lots of
serializers and deserializers,

00:07:38.968 --> 00:07:42.667
and that takes a lot of time
to the compile process.

00:07:42.667 --> 00:07:46.534
It also increases the size
of your JavaScript download,

00:07:46.534 --> 00:07:49.334
um, unnecessarily,
in some cases.

00:07:50.901 --> 00:07:54.334
So our recommendation here
is to prefer concrete types

00:07:54.334 --> 00:07:56.667
to interfaces
when you're using RPC,

00:07:56.667 --> 00:08:00.033
so in--ordinarily, in Java,
you would use a list

00:08:00.033 --> 00:08:02.701
rather than an array list,
specifically,

00:08:02.701 --> 00:08:04.734
but it turns out,
it's better for RPC--

00:08:04.734 --> 00:08:06.601
if you're sending that
over the wire,

00:08:06.601 --> 00:08:08.601
you should actually
just use the array list

00:08:08.601 --> 00:08:11.100
unless you really do need
to make it, at some point,

00:08:11.100 --> 00:08:13.300
other types of lists.

00:08:13.300 --> 00:08:16.234
You can also blacklist
RPC types

00:08:16.234 --> 00:08:18.734
so that no code will be
generated for those,

00:08:18.734 --> 00:08:20.901
if you know
you're not gonna use 'em,

00:08:20.901 --> 00:08:24.000
and the details on that, you can
look on the GWT issue tracker,

00:08:24.000 --> 00:08:25.868
um, in 4438. 

00:08:25.868 --> 00:08:27.868
We need better documentation,
but I needed something quick

00:08:27.868 --> 00:08:30.000
for the slide,
so there you have it.

00:08:30.000 --> 00:08:33.100
Also, consider
RequestFactory instead.

00:08:33.100 --> 00:08:35.133
This is the new RPC layer,

00:08:35.133 --> 00:08:37.334
and it will
support polymorphism.

00:08:37.334 --> 00:08:39.601
It's not there yet,
but it will support it

00:08:39.601 --> 00:08:42.300
in a way that doesn't cause
these type explosions,

00:08:42.300 --> 00:08:44.267
because RequestFactory
doesn't have to generate

00:08:44.267 --> 00:08:46.033
a serializer and deserializer

00:08:46.033 --> 00:08:48.868
for every class, like RPC does.

00:08:51.000 --> 00:08:53.200
And finally,
for the performance pitfalls,

00:08:53.200 --> 00:08:56.033
number 5, don't use a widget
when HTML will do.

00:08:56.033 --> 00:08:57.901
Widgets have overhead

00:08:57.901 --> 00:09:01.467
due to the event processing
that's required in a browser,

00:09:01.467 --> 00:09:03.300
and anytime you add
an event handler,

00:09:03.300 --> 00:09:04.968
then that's taking up memory

00:09:04.968 --> 00:09:07.200
and it's slowing down
the browser a little bit.

00:09:07.200 --> 00:09:10.901
So, uh, don't use widgets

00:09:10.901 --> 00:09:12.834
unless you actually do need
to respond

00:09:12.834 --> 00:09:14.834
to events from that widget.

00:09:14.834 --> 00:09:17.834
If you're just trying to write
HTML onto the page,

00:09:17.834 --> 00:09:20.367
then just use
plain HTML instead,

00:09:20.367 --> 00:09:23.000
and you can do that easily
using UiBinder

00:09:23.000 --> 00:09:25.567
with HTML tags.

00:09:25.567 --> 00:09:27.901
Uh, but there is a caution here.

00:09:27.901 --> 00:09:29.901
If you do need to catch an event

00:09:29.901 --> 00:09:33.367
at some, you know, deep--
deeply nested place

00:09:33.367 --> 00:09:35.234
in the widget hierarchy,

00:09:35.234 --> 00:09:38.734
it does have to have a path
consisting only of widgets

00:09:38.734 --> 00:09:40.434
back up to the top.

00:09:40.434 --> 00:09:43.434
So you can't do, say,
all of your layout

00:09:43.434 --> 00:09:45.133
in HTML at a top level,

00:09:45.133 --> 00:09:47.000
and then have HTML, HTML, HTML,

00:09:47.000 --> 00:09:49.901
and then try to attach a widget
to listen for events,

00:09:49.901 --> 00:09:51.801
because they won't bubble up,

00:09:51.801 --> 00:09:54.234
so if you do need 'em
at a low level,

00:09:54.234 --> 00:09:58.234
then you should be using widgets
all the way up.

00:09:58.234 --> 00:10:00.167
Also, you can use
the new LayoutPanels.

00:10:00.167 --> 00:10:03.834
They're more efficient
than previous panels were

00:10:03.834 --> 00:10:05.801
because they delegate more
to the browser

00:10:05.801 --> 00:10:07.701
and they make less use
of tables,

00:10:07.701 --> 00:10:11.634
so we've--we're using
more CSS layout now.

00:10:11.634 --> 00:10:14.534
And now for lists and tables

00:10:14.534 --> 00:10:16.334
and trees, especially,

00:10:16.334 --> 00:10:19.033
we recommend that you use
the new Cell widgets

00:10:19.033 --> 00:10:23.400
instead of the old
FlexTable and grid.

00:10:23.400 --> 00:10:26.100
Those approaches,
each Cell was a widget,

00:10:26.100 --> 00:10:28.868
but with Cell widgets,
as John will come and tell us,

00:10:28.868 --> 00:10:30.834
uh, it's a much
lighter-weight pattern,

00:10:30.834 --> 00:10:34.467
so John LaBanca, please come
and tell us about Cell widgets.

00:10:34.467 --> 00:10:37.834
[applause]

00:10:37.834 --> 00:10:40.701
LaBanca: Thank you.

00:10:40.701 --> 00:10:44.167
All right. Um, so for those
of you who aren't familiar,

00:10:44.167 --> 00:10:47.434
we recently,
as ofGWT 2.2, I believe,

00:10:47.434 --> 00:10:50.367
we introduced this new concept
of Cells and Cell widgets.

00:10:50.367 --> 00:10:52.901
So what I'm gonna talk about
today is what is a Cell,

00:10:52.901 --> 00:10:54.901
and how does it compare
to a widget?

00:10:54.901 --> 00:10:57.400
And then we're gonna go into
and talk about CellTable,

00:10:57.400 --> 00:11:00.400
what it is, why it's so awesome,
and how to use it.

00:11:00.400 --> 00:11:02.167
There are other Cell widgets.

00:11:02.167 --> 00:11:04.033
There's CellTree, CellList,

00:11:04.033 --> 00:11:06.701
but CellTable has by far
gotten the most use,

00:11:06.701 --> 00:11:08.934
so we're gonna focus on that.

00:11:08.934 --> 00:11:11.667
Okay, so Cell widgets are bas--

00:11:11.667 --> 00:11:14.667
Cells are like
widget flyweights.

00:11:14.667 --> 00:11:16.901
A widget creates
its DOM structure

00:11:16.901 --> 00:11:18.968
using DOM calls
and createElement,

00:11:18.968 --> 00:11:22.334
and then builds itself
and syncs events on itself.

00:11:22.334 --> 00:11:25.467
All that is fairly expensive
when you do a lot of it.

00:11:25.467 --> 00:11:28.367
A Cell, on the other hand--
you create one instance,

00:11:28.367 --> 00:11:31.067
as you can see,
uh, in the little chart below--

00:11:31.067 --> 00:11:34.567
that one instance generates
HTML strings.

00:11:34.567 --> 00:11:37.200
It can create multiple,

00:11:37.200 --> 00:11:39.300
uh, multiple DOM elements
from those strings.

00:11:39.300 --> 00:11:42.234
Any time an event occurs on
one of those elements,

00:11:42.234 --> 00:11:43.767
it goes back to the flyweight,

00:11:43.767 --> 00:11:47.000
and you get the event and you
get the parent DOM element.

00:11:47.000 --> 00:11:49.100
The benefits of this--

00:11:49.100 --> 00:11:51.501
as Dave mentioned,
widgets have overhead,

00:11:51.501 --> 00:11:53.367
so there's a lot less overhead,

00:11:53.367 --> 00:11:57.200
and you can render large sets,
such as an entire table,

00:11:57.200 --> 00:11:59.667
as a single HTML string.

00:11:59.667 --> 00:12:03.968
Okay, so some of the features
that are currently supported--

00:12:03.968 --> 00:12:07.534
We support paging,
multiple row selection,

00:12:07.534 --> 00:12:10.234
keyboard navigation
and row selection,

00:12:10.234 --> 00:12:12.267
column sorting,
and the rest of 'em,

00:12:12.267 --> 00:12:15.267
and what we're hoping to add
by the end of this quarter

00:12:15.267 --> 00:12:16.934
is a fixed header and footer

00:12:16.934 --> 00:12:19.000
with a scrollable content area
in the center,

00:12:19.000 --> 00:12:22.100
and also a fully customized
table structure,

00:12:22.100 --> 00:12:23.968
so rowspans, colspans.

00:12:23.968 --> 00:12:26.400
You can do things like have,
uh, expandable rows

00:12:26.400 --> 00:12:29.400
by just creating multiple rows
and indexing,

00:12:29.400 --> 00:12:32.634
um, everything past
the first row.

00:12:32.634 --> 00:12:35.167
So here's a little demo.

00:12:35.167 --> 00:12:38.634
Um, now the demo
I'm doing here--

00:12:38.634 --> 00:12:42.200
this is the Google Web Toolkit
showcase app

00:12:42.200 --> 00:12:44.667
that is--has been available
for a long time,

00:12:44.667 --> 00:12:46.567
so I'm gonna do a few things.

00:12:46.567 --> 00:12:50.200
I'm going to click
and do multi-selection.

00:12:50.200 --> 00:12:53.133
Um, I can navigate

00:12:53.133 --> 00:12:54.834
using the cursors,

00:12:54.834 --> 00:12:57.834
and you can see, it's only--it's
skipping non-editable Cells.

00:12:57.834 --> 00:13:01.334
I can click...

00:13:01.334 --> 00:13:03.067
and change a value,

00:13:03.067 --> 00:13:04.934
and then I can do paging,

00:13:04.934 --> 00:13:08.434
so you can see how fast
this table pages.

00:13:08.434 --> 00:13:10.801
Basically, as fast
as I can click on it.

00:13:10.801 --> 00:13:12.834
Uh, and column sorting.

00:13:17.033 --> 00:13:19.033
All right, so...

00:13:19.033 --> 00:13:20.868
we had a little overview.

00:13:20.868 --> 00:13:22.868
Now let's talk about
how you actually create

00:13:22.868 --> 00:13:24.534
one of these CellTables.

00:13:24.534 --> 00:13:27.534
So basically, creating
the CellTable widget--very easy.

00:13:27.534 --> 00:13:30.934
You create the widget,
and then you add columns.

00:13:30.934 --> 00:13:33.000
Create a widget.

00:13:33.000 --> 00:13:36.467
You'll notice that, here, we've
typed it with the type Contact.

00:13:36.467 --> 00:13:38.167
That's the row value,

00:13:38.167 --> 00:13:40.133
the value that goes across
all the columns.

00:13:40.133 --> 00:13:43.634
Each column will have
its own genericized type

00:13:43.634 --> 00:13:46.167
that represents either a field
or a group of fields

00:13:46.167 --> 00:13:47.868
in the--in the row.

00:13:47.868 --> 00:13:50.300
The simplest column
is a text column.

00:13:50.300 --> 00:13:53.400
It's a type String, so you don't
need to add the extra type,

00:13:53.400 --> 00:13:55.167
and what you basically do

00:13:55.167 --> 00:13:57.300
is you provide
this getValue method,

00:13:57.300 --> 00:14:00.334
which says, get me the column
value from the row value,

00:14:00.334 --> 00:14:03.334
so object or Contact dot name.

00:14:03.334 --> 00:14:05.334
For something slightly
more complicated,

00:14:05.334 --> 00:14:07.000
we use a date,

00:14:07.000 --> 00:14:10.000
so a date Cell is a Cell
that will represent a date.

00:14:10.000 --> 00:14:12.367
You can customize the format
of the date object,

00:14:12.367 --> 00:14:13.567
and what we say is,

00:14:13.567 --> 00:14:15.968
uh, the column is of type
Contact and Date,

00:14:15.968 --> 00:14:18.467
so from a column row object,
get the Date,

00:14:18.467 --> 00:14:22.100
and that's exactly what
this getValue method does.

00:14:22.100 --> 00:14:23.968
All right, pretty
straightforward.

00:14:23.968 --> 00:14:27.067
How do we put data
into the CellTable?

00:14:27.067 --> 00:14:29.567
The simplest version
is what you see here.

00:14:29.567 --> 00:14:32.067
You take a list of data
and you call setRowData,

00:14:32.067 --> 00:14:34.634
and boom, your data will appear
in your CellTable.

00:14:34.634 --> 00:14:38.400
But that's really only useful if
you have, you know, static data.

00:14:38.400 --> 00:14:41.767
You just want to render a large
set, but it's not dynamic.

00:14:41.767 --> 00:14:43.834
So a more practical use case

00:14:43.834 --> 00:14:45.934
involves a data provider.

00:14:45.934 --> 00:14:48.400
Now the data provider
is not a required class.

00:14:48.400 --> 00:14:50.133
It's a convenience class.

00:14:50.133 --> 00:14:51.868
What it's really doing is

00:14:51.868 --> 00:14:54.667
the CellTable can fire
range change events,

00:14:54.667 --> 00:14:57.067
and so it's listening for
the range change event,

00:14:57.067 --> 00:14:59.567
getting the data for
the new range, and providing it,

00:14:59.567 --> 00:15:01.634
but you'll find that these
dataProviders are pretty,

00:15:01.634 --> 00:15:03.634
uh, are a little bit
easier to use

00:15:03.634 --> 00:15:05.300
for some of that setup logic.

00:15:05.300 --> 00:15:07.801
So we're gonna create
an asynchronous data provider--

00:15:07.801 --> 00:15:10.300
I'll get to it in one second--
And then we're going

00:15:10.300 --> 00:15:12.968
to add the table as a display
of that data provider.

00:15:12.968 --> 00:15:14.834
Multiple tables, and you can--

00:15:14.834 --> 00:15:17.834
you know, tables and lists,
you can use 'em jointly,

00:15:17.834 --> 00:15:20.834
can be--can have
the same data provider

00:15:20.834 --> 00:15:22.501
providing data for them,

00:15:22.501 --> 00:15:24.501
so you don't have to manage

00:15:24.501 --> 00:15:27.267
multiple requests
for the same data.

00:15:27.267 --> 00:15:31.100
Okay, onRangeChange is called
when the table is loaded

00:15:31.100 --> 00:15:33.267
and when the user pages,

00:15:33.267 --> 00:15:35.267
so if they're paging through,
it might--

00:15:35.267 --> 00:15:38.234
the range here is going to
start--let's say, 0 through 50,

00:15:38.234 --> 00:15:40.234
and then it will go
51 through 100.

00:15:40.234 --> 00:15:43.734
At this point, you can send
an RPC request,

00:15:43.734 --> 00:15:45.400
or whatever you need to do,

00:15:45.400 --> 00:15:47.367
to get the data from the server.

00:15:47.367 --> 00:15:49.200
When it comes back,

00:15:49.200 --> 00:15:51.934
you call updateRowData
with the new data.

00:15:51.934 --> 00:15:53.901
One of the cool features
about CellTable

00:15:53.901 --> 00:15:56.601
is that it's--it supports
a push model,

00:15:56.601 --> 00:15:59.100
so you can send the request
for the first 20 rows,

00:15:59.100 --> 00:16:01.667
then the next 20 rows,
then the next 20 rows,

00:16:01.667 --> 00:16:03.734
and just update the data
incrementally,

00:16:03.734 --> 00:16:06.734
so you don't have to wait
for a very long RPC call

00:16:06.734 --> 00:16:08.767
to get something in front
of the user.

00:16:08.767 --> 00:16:10.767
In addition
to AsyncDataProvider,

00:16:10.767 --> 00:16:13.000
we also provide
ListDataProvider,

00:16:13.000 --> 00:16:16.033
which is even simpler. You don't
have to implement anything.

00:16:16.033 --> 00:16:19.434
It is a data provider
backed by a java.util.list,

00:16:19.434 --> 00:16:21.834
and any modifications
you make to the list

00:16:21.834 --> 00:16:23.834
are reflected in the table.

00:16:23.834 --> 00:16:26.200
All right, so you've got
your table.

00:16:26.200 --> 00:16:28.067
You've got the data
in your table.

00:16:28.067 --> 00:16:30.000
How do you make modifications?

00:16:30.000 --> 00:16:33.534
What we support is each column
has a field updater,

00:16:33.534 --> 00:16:35.367
and the field updater is called

00:16:35.367 --> 00:16:37.234
when the user interacts
with the Cell,

00:16:37.234 --> 00:16:39.801
so if it's a button Cell
and the user clicks the button,

00:16:39.801 --> 00:16:41.467
it calls the field updater.

00:16:41.467 --> 00:16:43.834
And the parameters that
are passed to update,

00:16:43.834 --> 00:16:46.434
um, there's some--the index
and general stuff.

00:16:46.434 --> 00:16:49.534
The contact here is
an unmodified row value.

00:16:49.534 --> 00:16:53.033
The date, the new birthday,
is the new column value,

00:16:53.033 --> 00:16:54.634
so if it's a text field,

00:16:54.634 --> 00:16:57.534
the--the new birthday
would be the new text.

00:16:57.534 --> 00:17:01.133
What we do is we call
our RPC service,

00:17:01.133 --> 00:17:03.701
we send the row value
and the new data,

00:17:03.701 --> 00:17:05.400
and then, on success,

00:17:05.400 --> 00:17:07.534
we knew that it's been
a successful change,

00:17:07.534 --> 00:17:09.400
we call contact.setBirthday.

00:17:09.400 --> 00:17:12.067
We update our local cache,
wherever you store that,

00:17:12.067 --> 00:17:13.801
and redraw the table.

00:17:13.801 --> 00:17:16.334
And so with this model,
in the meantime,

00:17:16.334 --> 00:17:18.868
your cell can go into a pending
state if you want it to.

00:17:18.868 --> 00:17:20.968
You can do a lot
of different things,

00:17:20.968 --> 00:17:23.400
and when we redraw,
because CellTable is so fast,

00:17:23.400 --> 00:17:25.901
um, even if you have 50 rows
and 10 columns,

00:17:25.901 --> 00:17:29.234
you should be able to redraw
so fast that it doesn't matter

00:17:29.234 --> 00:17:31.501
that you're redrawing
the whole table.

00:17:31.501 --> 00:17:33.367
If you have a very large table

00:17:33.367 --> 00:17:36.434
and you want to make sure that
you only redraw that one value,

00:17:36.434 --> 00:17:38.267
you want to optimize
for performance.

00:17:38.267 --> 00:17:40.367
Instead of redrawing
the whole table,

00:17:40.367 --> 00:17:43.367
you can set--you can push
that new value to the table

00:17:43.367 --> 00:17:46.300
by calling setRowData
with a singletonlist.

00:17:46.300 --> 00:17:47.968
The key here,

00:17:47.968 --> 00:17:50.434
the reason this isn't
the obvious first choice

00:17:50.434 --> 00:17:53.367
is that in the asynchronous
RPC call,

00:17:53.367 --> 00:17:56.367
the index could change,
so if the user deletes a row

00:17:56.367 --> 00:17:58.200
while you're updating
another row,

00:17:58.200 --> 00:18:00.067
um, the index will be off,

00:18:00.067 --> 00:18:02.634
so you have to manage that
in your own app logic,

00:18:02.634 --> 00:18:04.968
and for some, it will
be easier than others,

00:18:04.968 --> 00:18:06.968
but this is an optimization.

00:18:06.968 --> 00:18:09.467
And with that, I will
hand it back to Dave,

00:18:09.467 --> 00:18:11.300
who's gonna talk
about code splitting

00:18:11.300 --> 00:18:13.334
and Activities and Places.

00:18:13.334 --> 00:18:16.267
[applause]

00:18:18.200 --> 00:18:20.200
Chandler: Thanks, John.

00:18:20.200 --> 00:18:24.834
So GWT 2.1 released
a new application framework

00:18:24.834 --> 00:18:27.634
that used Activities and Places,

00:18:27.634 --> 00:18:31.133
and we want to cover that
this morning,

00:18:31.133 --> 00:18:33.000
this afternoon,
whatever time it is.

00:18:33.000 --> 00:18:35.267
It's been a long
couple of months.

00:18:35.267 --> 00:18:38.901
Um, in order
to help you understand

00:18:38.901 --> 00:18:40.868
how you can use it
with code splitting.

00:18:40.868 --> 00:18:42.767
Code splitting, you're probably
familiar with,

00:18:42.767 --> 00:18:44.467
the GWT.runAsync.

00:18:44.467 --> 00:18:47.100
This is a way to break
your application up

00:18:47.100 --> 00:18:50.434
into parts of JavaScript,
individual scripts,

00:18:50.434 --> 00:18:53.701
where each one only gets loaded
as it's actually needed,

00:18:53.701 --> 00:18:55.701
and this can
dramatically improve

00:18:55.701 --> 00:18:58.868
the load time
of your application

00:18:58.868 --> 00:19:02.434
by reducing the amount of code
needed on the first page.

00:19:02.434 --> 00:19:04.234
So what I'm gonna show you here

00:19:04.234 --> 00:19:06.234
is how to use Activities
and Places,

00:19:06.234 --> 00:19:09.300
and then we'll look at how
to use Activities and Places

00:19:09.300 --> 00:19:11.434
with code splitting,
specifically.

00:19:11.434 --> 00:19:15.634
So Activities and Places
helps you manage history,

00:19:15.634 --> 00:19:17.834
your browser's history,
bookmarks,

00:19:17.834 --> 00:19:19.667
and the evil "back" button.

00:19:19.667 --> 00:19:21.901
What happens if you
are building a Web app

00:19:21.901 --> 00:19:24.567
and it's an AJAX app,
it's mostly JavaScript,

00:19:24.567 --> 00:19:27.200
and unless you do something
special in your app,

00:19:27.200 --> 00:19:28.934
what happens
when the user comes up

00:19:28.934 --> 00:19:31.234
and clicks the "back" button?

00:19:31.234 --> 00:19:33.067
Your app goes away,

00:19:33.067 --> 00:19:36.067
because it goes back to whatever
page they were on, right?

00:19:36.067 --> 00:19:37.934
So users don't think
that's the way

00:19:37.934 --> 00:19:39.701
applications should work,

00:19:39.701 --> 00:19:42.734
and so GWT has had
for a long time in it,

00:19:42.734 --> 00:19:44.400
uh, the history object,

00:19:44.400 --> 00:19:46.400
which lets you put
a token on the URL,

00:19:46.400 --> 00:19:48.934
and there's a special
little iframe

00:19:48.934 --> 00:19:52.000
that you put in your host page
that listens for events,

00:19:52.000 --> 00:19:54.501
listens for changes
to the browser history,

00:19:54.501 --> 00:19:58.400
and then can update the state
of your application.

00:19:58.400 --> 00:20:02.467
It's then difficult
to use history directly.

00:20:02.467 --> 00:20:04.400
It takes a little more thought,

00:20:04.400 --> 00:20:07.267
and so there are lots
of frameworks that emerged

00:20:07.267 --> 00:20:10.534
um, MVP frameworks, like
gwt-presenter and gwt-platform,

00:20:10.534 --> 00:20:12.534
that will do this
history management for you

00:20:12.534 --> 00:20:14.200
through the notion of Places.

00:20:14.200 --> 00:20:16.534
Well, now we have
our own notion of Places

00:20:16.534 --> 00:20:18.200
in GWT itself.

00:20:18.200 --> 00:20:19.801
And you might ask,

00:20:19.801 --> 00:20:21.934
What does this have to do
with model-view-presenter?

00:20:21.934 --> 00:20:23.767
So there's been
some confusion about this.

00:20:23.767 --> 00:20:25.434
I apologize for this.

00:20:25.434 --> 00:20:27.434
Uh, some of the confusion
is our fault

00:20:27.434 --> 00:20:29.701
because we originally
conflated some concepts,

00:20:29.701 --> 00:20:33.968
and the MVP pattern,
strictly speaking,

00:20:33.968 --> 00:20:35.968
view and presenter
doesn't have anything to do

00:20:35.968 --> 00:20:37.634
with place
and history management.

00:20:37.634 --> 00:20:40.534
However, those two topics were
originally presented together

00:20:40.534 --> 00:20:43.534
on this stage,
um, a couple years ago,

00:20:43.534 --> 00:20:45.601
in the same presentation,

00:20:45.601 --> 00:20:48.767
and so people began
to commonly refer to MVP

00:20:48.767 --> 00:20:51.834
as place/history management,
as well.

00:20:51.834 --> 00:20:53.834
And it turns out that framers
like gwt-presenter

00:20:53.834 --> 00:20:56.033
and gwt-platform--it actually
makes a lot of sense

00:20:56.033 --> 00:20:57.701
and is very convenient,

00:20:57.701 --> 00:20:59.701
if you've defined
a presenter in your app,

00:20:59.701 --> 00:21:01.434
to just be able to annotate

00:21:01.434 --> 00:21:03.934
and have it take on the notion
of place, as well,

00:21:03.934 --> 00:21:06.701
and have the framework
automatically handle,

00:21:06.701 --> 00:21:10.334
um, the URL transitions when you
navigate to and from a place.

00:21:10.334 --> 00:21:12.367
With Activities
and Places now, though,

00:21:12.367 --> 00:21:14.334
I'm gonna separate
those concepts.

00:21:14.334 --> 00:21:16.901
We're not talking
about MVP proper here.

00:21:16.901 --> 00:21:19.501
We're talking about
browser history management.

00:21:21.601 --> 00:21:25.200
Okay, let's do a quick demo
of Places in action here,

00:21:25.200 --> 00:21:27.901
so you can see this.

00:21:27.901 --> 00:21:30.834
This is the Expenses sample app,

00:21:30.834 --> 00:21:33.000
which is in the GWT trunk,

00:21:33.000 --> 00:21:34.968
and it uses Places.

00:21:34.968 --> 00:21:36.968
So you'll notice,
uh, the URL here.

00:21:36.968 --> 00:21:39.501
We're just at our load page,
expenses.html,

00:21:39.501 --> 00:21:42.534
but when I click on one
of these detail items,

00:21:42.534 --> 00:21:44.234
the URL changes,

00:21:44.234 --> 00:21:46.300
and now we have some I.D.

00:21:46.300 --> 00:21:48.300
and a full class name in there.

00:21:48.300 --> 00:21:49.968
Okay, that's our Place.

00:21:49.968 --> 00:21:51.968
It's in response
to a Place change.

00:21:51.968 --> 00:21:54.767
So if I bookmark this place--

00:21:54.767 --> 00:21:57.400
we'll just copy it
to the clipboard here

00:21:57.400 --> 00:21:59.601
and pull up a new browser tab

00:21:59.601 --> 00:22:01.701
and copy that in

00:22:01.701 --> 00:22:03.367
and then go directly there,

00:22:03.367 --> 00:22:06.434
it loads our app and takes us
immediately to that Place.

00:22:06.434 --> 00:22:08.434
That's what we're talking about

00:22:08.434 --> 00:22:10.467
um, with the notion of Places.

00:22:13.000 --> 00:22:17.033
So how do we make this work
in GWT 2.1 and following?

00:22:17.033 --> 00:22:19.100
Okay, first, some definitions.

00:22:19.100 --> 00:22:22.868
A Place just represents
a bookmarkable state.

00:22:22.868 --> 00:22:25.501
A PlaceController is a GWT class

00:22:25.501 --> 00:22:28.334
that makes the "back" button
and bookmarks

00:22:28.334 --> 00:22:30.000
work like you expect.

00:22:30.000 --> 00:22:31.834
It's what actually does
the interaction

00:22:31.834 --> 00:22:33.567
with the GWT history object.

00:22:33.567 --> 00:22:35.601
And a PlaceTokenizer
is something that you write

00:22:35.601 --> 00:22:37.334
that tells GWT--

00:22:37.334 --> 00:22:40.834
how do I convert from the state
of my Java object

00:22:40.834 --> 00:22:43.434
to a String that can be
put on the URL,

00:22:43.434 --> 00:22:46.567
or, conversely, from that string

00:22:46.567 --> 00:22:50.100
back to the Java object
representing a Place?

00:22:50.100 --> 00:22:52.701
So here's an example of a Place.

00:22:52.701 --> 00:22:56.634
This one extends the Place
class, which is now in GWT,

00:22:56.634 --> 00:22:59.868
and the main part of it,
really, is the Tokenizer.

00:22:59.868 --> 00:23:01.801
The two methods are required.

00:23:01.801 --> 00:23:04.868
We have getPlace and getToken,
and these just--

00:23:04.868 --> 00:23:08.801
you tell GWT how to translate
the Java to a string

00:23:08.801 --> 00:23:10.734
and vice versa.

00:23:13.000 --> 00:23:15.300
That's--that's basically it
for Places.

00:23:15.300 --> 00:23:17.868
It's very simple. It is
a little bit of boilerplate.

00:23:17.868 --> 00:23:20.400
It would be nice if we would
generate these Tokenizers

00:23:20.400 --> 00:23:22.367
automatically,
and you can expect to see

00:23:22.367 --> 00:23:24.501
future work related to that
down the road.

00:23:24.501 --> 00:23:27.000
Some of the other frameworks,
like gwt-presenter,

00:23:27.000 --> 00:23:29.200
use annotations
and then GWT generators

00:23:29.200 --> 00:23:31.267
in order to take care
of this for you,

00:23:31.267 --> 00:23:35.200
and it would be nice if we did
something similar in GWT.

00:23:35.200 --> 00:23:37.200
How do you tell GWT

00:23:37.200 --> 00:23:39.634
about all of your Places
in your app?

00:23:39.634 --> 00:23:41.601
You do that using
a PlaceHistoryMapper.

00:23:41.601 --> 00:23:43.601
This is a simple
marker interface.

00:23:43.601 --> 00:23:46.167
It has no actual methods
or code in it,

00:23:46.167 --> 00:23:49.133
but the annotation
@WithTokenizers

00:23:49.133 --> 00:23:52.133
is where you point
to the Tokenizer class

00:23:52.133 --> 00:23:53.801
for each Place in your app.

00:23:53.801 --> 00:23:55.467
You just list them all out,

00:23:55.467 --> 00:23:58.100
and then GWT automatically
registers them

00:23:58.100 --> 00:24:01.000
in its infrastructure.

00:24:02.934 --> 00:24:05.934
The PlaceHistoryMapper is
the interface that you extend,

00:24:05.934 --> 00:24:08.167
and there's also
a factory version of this,

00:24:08.167 --> 00:24:10.467
called
PlaceHistoryMapperWithFactory,

00:24:10.467 --> 00:24:14.434
and if your Tokenizers require
arguments in their constructors,

00:24:14.434 --> 00:24:17.300
then you need--you'll need
to use the factory version

00:24:17.300 --> 00:24:19.434
instead of this interface.

00:24:21.601 --> 00:24:23.934
Okay, let's look
at the moving parts.

00:24:23.934 --> 00:24:25.934
What actually happens here?

00:24:25.934 --> 00:24:28.501
Let's say you want to cause
the view to transition,

00:24:28.501 --> 00:24:30.067
go to a new Place,

00:24:30.067 --> 00:24:33.901
so you call the
PlaceController.goTo method.

00:24:33.901 --> 00:24:36.968
That results in a PlaceChange
event being fired.

00:24:36.968 --> 00:24:38.934
It goes to the EventBus.

00:24:38.934 --> 00:24:41.934
The PlaceHistoryHandler,
which is a GWT class,

00:24:41.934 --> 00:24:43.901
uh, listens for that event,

00:24:43.901 --> 00:24:46.801
and then it calls
History.newItem,

00:24:46.801 --> 00:24:49.400
which actually puts the URL

00:24:49.400 --> 00:24:52.501
on the browser's address bar.

00:24:54.067 --> 00:24:57.801
Going backwards, when the user
uses the "back" button

00:24:57.801 --> 00:24:59.534
or goes to a bookmark,

00:24:59.534 --> 00:25:03.300
that causes the History
ValueChangeEvent to be fired.

00:25:03.300 --> 00:25:05.901
The PlaceHistoryHandler
picks that up,

00:25:05.901 --> 00:25:09.267
calls PlaceController.goTo
the new place,

00:25:09.267 --> 00:25:12.334
and Affects
the Place transition.

00:25:16.000 --> 00:25:20.133
Okay, Places are designed
to be used with Activities.

00:25:20.133 --> 00:25:23.567
They don't have to be,
but it's useful.

00:25:23.567 --> 00:25:25.567
So if you don't use them
with Activities,

00:25:25.567 --> 00:25:28.300
you would have to listen for
these PlaceChangeEvents

00:25:28.300 --> 00:25:30.033
in your app yourself,

00:25:30.033 --> 00:25:33.033
and then change the view
however you need to

00:25:33.033 --> 00:25:34.701
based on those events,

00:25:34.701 --> 00:25:37.367
but if you use the Activities,

00:25:37.367 --> 00:25:40.167
then there's a little more stuff
that GWT will do for you.

00:25:40.167 --> 00:25:42.801
So the terminology is taken
from Android development.

00:25:42.801 --> 00:25:44.601
An Activity just represents

00:25:44.601 --> 00:25:46.534
something that the user
is doing.

00:25:46.534 --> 00:25:49.567
We say it handles wake-up,
setup, and show-up,

00:25:49.567 --> 00:25:53.834
so it's kind of managing
the state of the user's actions

00:25:53.834 --> 00:25:56.467
with respect to a particular
part of the UI.

00:25:56.467 --> 00:25:59.300
So one of the nice features
of Activities

00:25:59.300 --> 00:26:02.400
is that they can automatically
warn users before leaving,

00:26:02.400 --> 00:26:06.000
so if they use
the "back" button, let's say,

00:26:06.000 --> 00:26:08.100
a warning box
will pop up and says,

00:26:08.100 --> 00:26:10.501
this Activity is stopping.
Do you really want to stop?

00:26:10.501 --> 00:26:13.300
And you can control
the message, of course.

00:26:13.300 --> 00:26:16.300
If you have multiple
Activities running on your--

00:26:16.300 --> 00:26:19.334
on your screen--we'll look at
an example of that in a minute--

00:26:19.334 --> 00:26:22.567
uh, then all of those
Activity stop messages

00:26:22.567 --> 00:26:26.100
will just get appended
to a single warning box.

00:26:26.100 --> 00:26:28.400
Now Activities are started
and stopped

00:26:28.400 --> 00:26:30.801
by an ActivityManager.

00:26:30.801 --> 00:26:34.300
and you have one ActivityManager
per panel on your screen,

00:26:34.300 --> 00:26:37.267
so you can have
multiple Activities going

00:26:37.267 --> 00:26:40.100
all at the same time.

00:26:40.100 --> 00:26:42.167
They take care
of instantiating the view

00:26:42.167 --> 00:26:45.100
for a particular area
of the screen,

00:26:45.100 --> 00:26:47.567
and they can be presenters

00:26:47.567 --> 00:26:49.834
uh, in MVP parlance,

00:26:49.834 --> 00:26:51.601
but they don't have to be.

00:26:51.601 --> 00:26:54.667
It's really intended to be
a higher-level concept.

00:26:54.667 --> 00:26:56.634
But an Activity
can be associated

00:26:56.634 --> 00:26:58.734
with a Place, as well.

00:26:58.734 --> 00:27:00.868
We'll look at that all
in a minute

00:27:00.868 --> 00:27:02.701
in a big, complicated diagram.

00:27:02.701 --> 00:27:05.000
So here is a typical Activity.

00:27:05.000 --> 00:27:06.934
This extends
the AbstractActivity,

00:27:06.934 --> 00:27:08.801
which is just
a convenience class.

00:27:08.801 --> 00:27:10.467
The real requirement

00:27:10.467 --> 00:27:12.400
is just to implement
the Activity interface,

00:27:12.400 --> 00:27:15.334
but this class provides
default implementations

00:27:15.334 --> 00:27:18.367
of a lot of your methods
for you.

00:27:18.367 --> 00:27:20.701
The most important method
is the start method.

00:27:20.701 --> 00:27:22.634
This is where it all happens.

00:27:22.634 --> 00:27:24.634
Notice that it takes a panel

00:27:24.634 --> 00:27:26.801
of type AcceptsOneWidget,

00:27:26.801 --> 00:27:30.267
so this is what enforces
the requirement that an Activity

00:27:30.267 --> 00:27:33.334
is responsible for managing
one area of the screen,

00:27:33.334 --> 00:27:36.367
and then it also
takes an eventBus,

00:27:36.367 --> 00:27:39.033
which is the bus
that your app uses

00:27:39.033 --> 00:27:41.634
to communicate with other parts
of the app.

00:27:41.634 --> 00:27:45.534
So you call panel.setWidget
with your view,

00:27:45.534 --> 00:27:47.801
and that then brings,

00:27:47.801 --> 00:27:52.033
um, that results in GWT
calling "add widget"

00:27:52.033 --> 00:27:54.200
to that container,

00:27:54.200 --> 00:27:57.200
so this is what actually
makes your view show up

00:27:57.200 --> 00:27:59.133
on the screen.

00:28:01.267 --> 00:28:03.367
An ActivityMapper
is what you use

00:28:03.367 --> 00:28:06.634
to tell GWT, when this Place
transition happens,

00:28:06.634 --> 00:28:08.300
here's the Activity to load,

00:28:08.300 --> 00:28:10.801
so it has only one method,
called getActivity.

00:28:10.801 --> 00:28:12.734
It takes a Place,

00:28:12.734 --> 00:28:15.167
and your code will typically
look something like this.

00:28:15.167 --> 00:28:16.901
If it's one type of Place,

00:28:16.901 --> 00:28:19.501
then you return
the corresponding Activity.

00:28:21.067 --> 00:28:24.567
You'll have one ActivityMapper

00:28:24.567 --> 00:28:28.033
for each region
of the screen, typically.

00:28:28.033 --> 00:28:31.067
We'll look at that
in just a second.

00:28:31.067 --> 00:28:34.067
Okay, so a couple of
ActivityMapper idioms here.

00:28:34.067 --> 00:28:37.467
Your code can return
a new activity

00:28:37.467 --> 00:28:40.667
each time the getActivity method
is called,

00:28:40.667 --> 00:28:44.934
in which case, your Activities
are completely disposable,

00:28:44.934 --> 00:28:47.267
and this makes your code
the cleanest

00:28:47.267 --> 00:28:51.267
because you're not having
to clean up the state each time.

00:28:51.267 --> 00:28:54.167
Each time, you're just getting
a brand-new activity,

00:28:54.167 --> 00:28:55.868
and all the state is gone

00:28:55.868 --> 00:28:58.801
from previous views
for that Place.

00:28:58.801 --> 00:29:01.734
Uh, but you can also use
a singleton Activity,

00:29:01.734 --> 00:29:04.234
where you might obtain it
from dependency injection,

00:29:04.234 --> 00:29:06.000
from GIN, let's say,

00:29:06.000 --> 00:29:08.000
or from your own factory,

00:29:08.000 --> 00:29:11.400
and in that case, you would
just call an update method

00:29:11.400 --> 00:29:13.267
on your singleton Activity

00:29:13.267 --> 00:29:15.033
and tell it about the new Place,

00:29:15.033 --> 00:29:18.400
and then you have to do
the state cleanup.

00:29:18.400 --> 00:29:21.901
Okay, so how does this all
work together now?

00:29:21.901 --> 00:29:23.968
Places and Activities?

00:29:23.968 --> 00:29:26.901
Let's say you call
PlaceController.goTo.

00:29:26.901 --> 00:29:29.434
Again, it fires
the PlaceChangeEvent,

00:29:29.434 --> 00:29:31.567
which gets picked up
by the ActivityManager.

00:29:31.567 --> 00:29:35.100
The ActivityManager
asks your ActivityMapper,

00:29:35.100 --> 00:29:37.968
"What activity
goes with this Place?"

00:29:37.968 --> 00:29:41.167
and then it calls the mayStop
method on the old Activity

00:29:41.167 --> 00:29:43.667
that was running
in the area of the screen.

00:29:43.667 --> 00:29:46.434
If it allows it to stop,

00:29:46.434 --> 00:29:50.033
then the ActivityManager
will start the new Activity.

00:29:50.033 --> 00:29:54.067
The only piece that you write is
the Activity itself, of course,

00:29:54.067 --> 00:29:55.868
and the ActivityMapper.

00:29:55.868 --> 00:29:59.667
All these other classes
are fundamental GWT classes.

00:30:02.767 --> 00:30:06.400
So how can you divide
a screen into regions

00:30:06.400 --> 00:30:09.200
and have one Place transition

00:30:09.200 --> 00:30:12.834
result in multiple
Activity transitions?

00:30:14.400 --> 00:30:17.000
Let's look at the right side
of the screen first.

00:30:17.000 --> 00:30:19.033
We have the List
Activity Manager

00:30:19.033 --> 00:30:21.167
and the Details
Activity Manager

00:30:21.167 --> 00:30:23.934
on the top and bottom.

00:30:23.934 --> 00:30:26.200
These would be
two different Activities

00:30:26.200 --> 00:30:28.501
running in their
respective panels,

00:30:28.501 --> 00:30:30.334
so each has its own manager,

00:30:30.334 --> 00:30:32.467
and each will have
its own mapper,

00:30:32.467 --> 00:30:36.100
but there would only be
one PlaceChange.

00:30:36.100 --> 00:30:38.834
So in this case,
the URL would probably have

00:30:38.834 --> 00:30:43.067
something like
detailrecordid=34,

00:30:43.067 --> 00:30:46.434
and then all three
of these things

00:30:46.434 --> 00:30:49.767
would be listening
for the PlaceChangeEvent

00:30:49.767 --> 00:30:52.300
and would make
the transitions appropriately.

00:30:52.300 --> 00:30:54.100
So the two on the right

00:30:54.100 --> 00:30:56.467
are wired up with Places
and Activities,

00:30:56.467 --> 00:30:58.667
so your ActivityMapper would say

00:30:58.667 --> 00:31:02.901
if place instanceof DetailPlace,

00:31:02.901 --> 00:31:07.267
then return new DetailActivity,
and that would result

00:31:07.267 --> 00:31:09.601
in the bottom of the screen
being updated.

00:31:09.601 --> 00:31:11.968
Similar for the top,
with the List Activity,

00:31:11.968 --> 00:31:13.701
and then, on the left side,

00:31:13.701 --> 00:31:15.767
this is a permanent feature
of our screen.

00:31:15.767 --> 00:31:18.701
It doesn't actually change
with respect to each Place.

00:31:18.701 --> 00:31:20.534
The navigation is always there,

00:31:20.534 --> 00:31:22.834
so it doesn't even need
to be an Activity.

00:31:22.834 --> 00:31:25.601
It can just listen for
PlaceChangeEvents directly.

00:31:25.601 --> 00:31:28.133
That's why we have
PlaceChangeHandler over there.

00:31:28.133 --> 00:31:29.701
You could make it an activity,

00:31:29.701 --> 00:31:31.434
but it doesn't really
buy you anything.

00:31:31.434 --> 00:31:33.267
You just listen for
the PlaceChangeEvents

00:31:33.267 --> 00:31:36.767
and then update the UI,
showing a new selected item.

00:31:36.767 --> 00:31:40.267
So that's how you can have
the notion of a composite Place.

00:31:40.267 --> 00:31:42.133
You just have one Place,

00:31:42.133 --> 00:31:44.067
but then you can have
each Activity

00:31:44.067 --> 00:31:46.534
respond to that PlaceChange.

00:31:50.734 --> 00:31:53.100
And this slide just summarizes
that in words,

00:31:53.100 --> 00:31:55.767
so each region has
its own ActivityManager

00:31:55.767 --> 00:31:57.534
and ActivityMapper,

00:31:57.534 --> 00:32:00.133
all the ActivityManagers
will get notified

00:32:00.133 --> 00:32:02.300
when the Place changes,

00:32:02.300 --> 00:32:05.000
and then each Activity
can update its own region

00:32:05.000 --> 00:32:07.033
or view appropriately.

00:32:10.033 --> 00:32:12.667
So Activities, I said,
can be disposable.

00:32:12.667 --> 00:32:14.634
Places are disposable, as well.

00:32:14.634 --> 00:32:17.734
They're designed
to be throwaway objects.

00:32:17.734 --> 00:32:19.467
Each time the URL changes,

00:32:19.467 --> 00:32:22.501
that's gonna be a new Place
object in your GWT code.

00:32:22.501 --> 00:32:24.934
Views, however,

00:32:24.934 --> 00:32:27.300
you don't want to make
disposable, typically,

00:32:27.300 --> 00:32:29.234
for performance,

00:32:29.234 --> 00:32:31.400
because view creation
is expensive,

00:32:31.400 --> 00:32:33.601
because you're touching
the DOM in the browser,

00:32:33.601 --> 00:32:36.868
so the best idea is
to have your Activities

00:32:36.868 --> 00:32:39.868
obtain the views
from some kind of factory,

00:32:39.868 --> 00:32:42.868
either dependency injection
or a factory you create,

00:32:42.868 --> 00:32:46.067
and that way, you're minimizing

00:32:46.067 --> 00:32:47.934
the amount of time

00:32:47.934 --> 00:32:50.434
required to do that.

00:32:54.601 --> 00:32:57.133
Okay, now we come
to code splitting.

00:32:57.133 --> 00:32:59.033
This is what--this is
the good part.

00:32:59.033 --> 00:33:02.167
This is why we are doing
this new Activities and Places.

00:33:02.167 --> 00:33:05.267
We'd like to be able
to defer code downloads

00:33:05.267 --> 00:33:07.033
until we actually need 'em,

00:33:07.033 --> 00:33:09.501
and this capability has been
in GWT ever since 2.0,

00:33:09.501 --> 00:33:11.167
the GWT.runAsync.

00:33:11.167 --> 00:33:13.133
So you make a runAsync call,

00:33:13.133 --> 00:33:15.501
and anything
in the onSuccess method

00:33:15.501 --> 00:33:17.167
will be deferred

00:33:17.167 --> 00:33:19.901
until it's actually encountered.

00:33:19.901 --> 00:33:22.601
The GWT compiler
is actually very smart.

00:33:22.601 --> 00:33:24.701
It sees this construct
in your code,

00:33:24.701 --> 00:33:26.601
and then follows
the call hierarchy

00:33:26.601 --> 00:33:28.734
from within the onSuccess method

00:33:28.734 --> 00:33:30.767
and it packages everything
that's called

00:33:30.767 --> 00:33:34.234
inside that onSuccess method
into a separate JavaScript.

00:33:34.234 --> 00:33:36.701
and it only goes after
that separate JavaScript

00:33:36.701 --> 00:33:39.534
when it's actually triggered.

00:33:39.534 --> 00:33:42.801
So a common thing to do
is to break your application up

00:33:42.801 --> 00:33:45.367
into a tabbed panel interface,
for example,

00:33:45.367 --> 00:33:48.868
and make each tabbed panel
EventHandler

00:33:48.868 --> 00:33:52.667
call the on--have
the runAsync call

00:33:52.667 --> 00:33:55.300
that will end up with onSuccess
getting called

00:33:55.300 --> 00:33:59.067
and only then goes and loads
the view for that panel.

00:33:59.067 --> 00:34:01.467
There's a class that not many
people know about,

00:34:01.467 --> 00:34:03.334
called the AsyncProxy class
in GWT,

00:34:03.334 --> 00:34:05.067
that can help you with this,

00:34:05.067 --> 00:34:08.968
because it can actually
turn an Async call

00:34:08.968 --> 00:34:11.100
into one that looks
like a synchronous call,

00:34:11.100 --> 00:34:12.834
so if you use the AsyncProxy,

00:34:12.834 --> 00:34:15.334
uh, it can help you navigate
some of the difficulty

00:34:15.334 --> 00:34:17.367
of the code here with runAsync.

00:34:17.367 --> 00:34:19.334
And I just want to point out

00:34:19.334 --> 00:34:21.567
that you can use
the -compileReport option

00:34:21.567 --> 00:34:24.133
in order to find out
what the effectiveness

00:34:24.133 --> 00:34:26.100
of your runAsync splits
has been.

00:34:26.100 --> 00:34:28.601
So you should always do this,
because you'll be surprised.

00:34:28.601 --> 00:34:30.434
Sometimes you think
you're splitting code

00:34:30.434 --> 00:34:32.934
in a way that makes sense,
and you'll find out

00:34:32.934 --> 00:34:34.934
you're actually not making
much difference at all.

00:34:34.934 --> 00:34:36.601
So you run compileReport,

00:34:36.601 --> 00:34:39.100
and then look in the soycReport
directory that it creates,

00:34:39.100 --> 00:34:40.934
and you'll get a nice view of--

00:34:40.934 --> 00:34:43.501
how--the total size
of each split point.

00:34:46.434 --> 00:34:49.400
So how do we do code splitting
with Activities and Places?

00:34:49.400 --> 00:34:51.067
Well, what we've found

00:34:51.067 --> 00:34:53.067
on Google projects
that have been using this

00:34:53.067 --> 00:34:55.968
is that an Activity is
a very natural split point.

00:34:55.968 --> 00:34:58.801
It turns out to be
not too big, not too small,

00:34:58.801 --> 00:35:01.667
it's easy to understand,
and it more or less corresponds

00:35:01.667 --> 00:35:04.801
to something the user
is doing in the UI,

00:35:04.801 --> 00:35:07.667
so it's a good--
it's a good place.

00:35:07.667 --> 00:35:10.734
So you might have, for example,
in a multi-tabbed interface,

00:35:10.734 --> 00:35:13.667
each tab might have
its own Activity,

00:35:13.667 --> 00:35:16.267
and then you would split
on the Activity

00:35:16.267 --> 00:35:20.300
in order to defer download
for that tab.

00:35:20.300 --> 00:35:23.400
So with GIN, you want to use
the AsyncProvider,

00:35:23.400 --> 00:35:25.601
uh, class that's part of GIN,

00:35:25.601 --> 00:35:27.834
and it's actually
being moved into--

00:35:27.834 --> 00:35:30.300
the interface is being moved
into GWT, as well,

00:35:30.300 --> 00:35:33.033
so you don't have a dependency
on GIN, necessarily.

00:35:34.601 --> 00:35:37.400
So your getActivity method
in your mapper

00:35:37.400 --> 00:35:39.200
would probably have
something like this.

00:35:39.200 --> 00:35:43.000
It would return
the activityAsyncProvider.get--

00:35:43.000 --> 00:35:45.734
that's the standard method
on the AsyncProvider--

00:35:45.734 --> 00:35:49.734
and that would then cause
your activity to be loaded.

00:35:49.734 --> 00:35:52.801
GIN, if you use this approach,
and why it's nice,

00:35:52.801 --> 00:35:55.801
is that GIN will generate
the runAsync call for you,

00:35:55.801 --> 00:35:58.634
so you don't even have
to have that block.

00:35:58.634 --> 00:36:00.734
Now if you want
to do without GIN,

00:36:00.734 --> 00:36:03.200
then you're gonna want
to create a proxy class

00:36:03.200 --> 00:36:06.534
that's going to proxy
the Activity start method,

00:36:06.534 --> 00:36:08.467
and so you would--

00:36:08.467 --> 00:36:13.300
whenever your Activity proxy
class start method gets called,

00:36:13.300 --> 00:36:15.667
then it would put in
the runAsync block,

00:36:15.667 --> 00:36:19.234
which would make the real call
to obtain your Activity.

00:36:20.901 --> 00:36:23.467
There is some work in progress
on this still.

00:36:23.467 --> 00:36:26.033
If you look at issue 5129,
there's extensive discussion

00:36:26.033 --> 00:36:28.067
about different possible
approaches, and we're still

00:36:28.067 --> 00:36:30.367
looking at which one
we're actually gonna commit to,

00:36:30.367 --> 00:36:33.033
uh, the GWT trunk
to make this a little easier,

00:36:33.033 --> 00:36:36.033
but you can write your own, and
the recipes are all up there.

00:36:36.033 --> 00:36:39.000
It's just too detailed
to put on a screen.

00:36:42.868 --> 00:36:45.734
Okay, lastly, let's look
at some compiler tips.

00:36:49.734 --> 00:36:51.834
We hear quite often from people,

00:36:51.834 --> 00:36:53.968
uh, doing large projects,

00:36:53.968 --> 00:36:57.367
that GWT projects can take
several minutes to compile.

00:36:57.367 --> 00:36:59.367
We've--sometimes
10 or 20 minutes--

00:36:59.367 --> 00:37:01.000
uh, really large projects

00:37:01.000 --> 00:37:05.067
using a lot of permutations,
even larger.

00:37:05.067 --> 00:37:06.734
So the reason is,

00:37:06.734 --> 00:37:09.234
is because GWT creates
permutations for each browser,

00:37:09.234 --> 00:37:12.901
which is custom JavaScript code
specific for that browser,

00:37:12.901 --> 00:37:15.267
which is the most efficient code
for that browser,

00:37:15.267 --> 00:37:18.567
because we've tweaked
the JavaScript in order to know

00:37:18.567 --> 00:37:21.501
about the browser's
particular idiosyncrasies

00:37:21.501 --> 00:37:24.100
and speed improvements
that are possible, et cetera.

00:37:24.100 --> 00:37:27.067
Which is great
for user experience,

00:37:27.067 --> 00:37:29.567
because the user gets
the fastest experience they can,

00:37:29.567 --> 00:37:31.400
but it does mean
that you're having

00:37:31.400 --> 00:37:34.133
additional compile time
for your app.

00:37:34.133 --> 00:37:37.267
So one technique
when you're using--

00:37:37.267 --> 00:37:40.501
prior to your final
production compile--

00:37:40.501 --> 00:37:43.133
is just to set a single
user-agent property

00:37:43.133 --> 00:37:45.534
in your gwt.xml,

00:37:45.534 --> 00:37:47.968
so you're only compiling
one browser permutation

00:37:47.968 --> 00:37:50.400
for the one that you normally
develop with,

00:37:50.400 --> 00:37:52.267
and as your project gets larger,

00:37:52.267 --> 00:37:55.667
you'll appreciate
the benefit of this more.

00:37:55.667 --> 00:37:58.033
You can also do the same thing
with locale,

00:37:58.033 --> 00:38:01.667
because permutations
get multiplied together,

00:38:01.667 --> 00:38:04.367
so if you have
five browser permutations

00:38:04.367 --> 00:38:06.400
and four languages, or locales,

00:38:06.400 --> 00:38:08.868
that's gonna result
in 20 permutations.

00:38:08.868 --> 00:38:12.534
So if you're using
multiple properties this way,

00:38:12.534 --> 00:38:14.968
you definitely want
to be restricting them

00:38:14.968 --> 00:38:17.434
when you're doing your ordinary
development compiles.

00:38:17.434 --> 00:38:19.434
Of course, I should have said
at the beginning,

00:38:19.434 --> 00:38:21.934
you shouldn't be compiling
as a normal part of development.

00:38:21.934 --> 00:38:23.801
You should be using
development mode,

00:38:23.801 --> 00:38:26.000
when your changes take place
right away. [chuckles]

00:38:27.801 --> 00:38:29.801
Um, avoid RPC type explosion.

00:38:29.801 --> 00:38:31.901
Just a reminder there, as well.

00:38:31.901 --> 00:38:34.234
This is not something
you can deal with easily

00:38:34.234 --> 00:38:37.367
in your gwt.xml, except for
the RPC blacklisting...

00:38:39.634 --> 00:38:42.868
But be thinking about it as
you design your RPC interfaces.

00:38:42.868 --> 00:38:45.968
So these are a couple things
to improve your compile time.

00:38:45.968 --> 00:38:48.934
Now draftCompile is an option
that you can add,

00:38:48.934 --> 00:38:52.634
and it allows you to skip
a lot of the optimizations.

00:38:52.634 --> 00:38:54.567
So you wouldn't want to use that

00:38:54.567 --> 00:38:56.367
for your final
production compile,

00:38:56.367 --> 00:38:58.200
but this will typically--

00:38:58.200 --> 00:39:00.667
well, we'll show some numbers
here in a second.

00:39:02.667 --> 00:39:06.000
Okay, so I put together
a simple little app,

00:39:06.000 --> 00:39:08.400
and this is where I do
my eye candy demo.

00:39:08.400 --> 00:39:10.234
It's just got 12 classes,

00:39:10.234 --> 00:39:12.000
and I ran
some different numbers,

00:39:12.000 --> 00:39:13.901
so let me just show you
the app first,

00:39:13.901 --> 00:39:16.601
so you can see a little bit, uh,
of what we're dealing with.

00:39:16.601 --> 00:39:18.367
It's called Spirodraw.

00:39:18.367 --> 00:39:21.634
I like math, and I like
polar coordinates.

00:39:21.634 --> 00:39:24.133
It was one of the things
that got me into programming

00:39:24.133 --> 00:39:25.968
on the Apple IIe
in seventh grade,

00:39:25.968 --> 00:39:27.968
so I made my high school
Java students

00:39:27.968 --> 00:39:29.801
that I'm teaching this year

00:39:29.801 --> 00:39:32.968
do a little animation
with polar coordinates

00:39:32.968 --> 00:39:34.801
so they could see
these equations.

00:39:34.801 --> 00:39:38.067
So here, we can change
the numerator and denominator

00:39:38.067 --> 00:39:40.567
for, uh, actually, that last one
looked pretty good.

00:39:40.567 --> 00:39:43.100
Let's go with that, um,

00:39:43.100 --> 00:39:46.033
on a standard
"r"equals cosine "n"theta,

00:39:46.033 --> 00:39:47.667
and it draws it out.

00:39:47.667 --> 00:39:49.334
This is using GWTCanvas,

00:39:49.334 --> 00:39:51.834
and I'm really not supposed
to be talking about this.

00:39:51.834 --> 00:39:54.334
I'm supposed to be talking about
performance, but it's cool.

00:39:54.334 --> 00:39:56.334
[laughter]
Chandler: [laughs]

00:39:56.334 --> 00:39:58.601
And what's even cooler
is this little gizmo,

00:39:58.601 --> 00:40:01.167
which we animated also
with GWTCanvas,

00:40:01.167 --> 00:40:04.167
and you can come in here
and set the wheel size

00:40:04.167 --> 00:40:05.834
and the colors

00:40:05.834 --> 00:40:08.501
to change the shape
of the, uh, the graph,

00:40:08.501 --> 00:40:11.000
and you probably had a toy
like this when you were a kid

00:40:11.000 --> 00:40:13.501
and thought it was great,
but you got annoyed with it

00:40:13.501 --> 00:40:15.167
whenever the paper would slip,

00:40:15.167 --> 00:40:17.167
and it would make your drawings
not beautiful anymore.

00:40:17.167 --> 00:40:19.734
Well, here, the paper
never slips, right?

00:40:19.734 --> 00:40:21.434
[laughs] So you can enjoy it.

00:40:21.434 --> 00:40:23.334
So this is
my little Spirodraw app.

00:40:23.334 --> 00:40:26.801
It's spirodraw.appspot.com.
and, uh, you can do that

00:40:26.801 --> 00:40:29.801
for the rest of the presentation
if you get bored with me.

00:40:29.801 --> 00:40:33.300
So 12 classes, very simple app,

00:40:33.300 --> 00:40:35.133
but these are some numbers.

00:40:35.133 --> 00:40:37.200
I just went through and ran
different combinations,

00:40:37.200 --> 00:40:40.400
so just a standard compile
for all browsers

00:40:40.400 --> 00:40:42.901
was 43.3 seconds.

00:40:42.901 --> 00:40:45.400
If I did Safari only,

00:40:45.400 --> 00:40:47.534
by restricting
the user-agent property,

00:40:47.534 --> 00:40:50.868
then that took it down
to 27.7 seconds.

00:40:50.868 --> 00:40:54.267
If I do draftCompile
and Safari only,

00:40:54.267 --> 00:40:56.501
I could get it down
to 24.1 seconds,

00:40:56.501 --> 00:40:58.167
so about half.

00:40:58.167 --> 00:41:00.000
So just by restricting
the browser agent,

00:41:00.000 --> 00:41:01.901
which is a one-liner
in your XML,

00:41:01.901 --> 00:41:04.067
and using
the draftCompile option,

00:41:04.067 --> 00:41:06.067
you can cut
your compile time in half,

00:41:06.067 --> 00:41:07.734
and it'll be more dramatic

00:41:07.734 --> 00:41:09.567
the more permutations
you have, of course.

00:41:09.567 --> 00:41:11.400
Note that
the -compileReport option

00:41:11.400 --> 00:41:13.067
takes it the other way.

00:41:13.067 --> 00:41:15.567
Because it's generating
a lot of extra data for you,

00:41:15.567 --> 00:41:17.400
it will add time
to your compile,

00:41:17.400 --> 00:41:19.234
so be careful
when you're doing development.

00:41:19.234 --> 00:41:21.434
You don't want to do that
every time through.

00:41:21.434 --> 00:41:24.434
Okay, now that's
how to speed up compiles.

00:41:24.434 --> 00:41:26.434
What about shrinking
the resulting JavaScript?

00:41:26.434 --> 00:41:28.400
There's quite a few things
you can do,

00:41:28.400 --> 00:41:30.701
uh, some lesser-known options
in GWT to do this.

00:41:30.701 --> 00:41:33.834
So one of them is called
the -XdisableClassMetadata,

00:41:33.834 --> 00:41:37.100
and this is an option
you can pass to the compiler

00:41:37.100 --> 00:41:40.133
which will cause the compiler
to not generate

00:41:40.133 --> 00:41:43.634
some extra JavaScript that
does just class cast checking.

00:41:43.634 --> 00:41:46.868
And if you're not using
a lot of class cast checking,

00:41:46.868 --> 00:41:49.534
uh, in your code,
or if you can tolerate

00:41:49.534 --> 00:41:51.968
class cast violations,
basically,

00:41:51.968 --> 00:41:56.601
then you can use this
and save some resulting size.

00:41:56.601 --> 00:42:00.400
Similar, the--sorry, I got
my two methods mixed up.

00:42:00.400 --> 00:42:02.868
That was class cast cheshing--
cat--checking.

00:42:02.868 --> 00:42:04.868
I was talking
about class metadata.

00:42:04.868 --> 00:42:07.000
You have to be careful
with this one,

00:42:07.000 --> 00:42:08.868
because it will disable
some methods.

00:42:08.868 --> 00:42:11.100
Like, you can't call getName
on your class

00:42:11.100 --> 00:42:12.834
if you've got this in here.

00:42:12.834 --> 00:42:15.200
So if you use these,
they're considered -X.

00:42:15.200 --> 00:42:17.367
They're slightly experimental.
You just want to make sure

00:42:17.367 --> 00:42:19.868
you test your app and make sure
everything still works,

00:42:19.868 --> 00:42:21.901
uh, if you're using
these options.

00:42:21.901 --> 00:42:24.934
Uh, and those will show up
as a JavaScript in your--

00:42:24.934 --> 00:42:26.634
exception in your browser.

00:42:26.634 --> 00:42:29.133
The compiler won't warn you
if you're using these.

00:42:29.133 --> 00:42:31.467
It just won't work.

00:42:31.467 --> 00:42:34.033
Okay, and then -compileReport,
we already talked about--

00:42:34.033 --> 00:42:37.667
puts the story of your compile
in the extras directory,

00:42:37.667 --> 00:42:41.133
and that would allow you to see,
um, the largest packages,

00:42:41.133 --> 00:42:43.367
because you can see
the size of the JavaScript

00:42:43.367 --> 00:42:45.067
resulting from each
Java package,

00:42:45.067 --> 00:42:47.267
so you could then
see if there's anything

00:42:47.267 --> 00:42:49.701
that you could eliminate
or maybe combine

00:42:49.701 --> 00:42:52.234
in order to not pay the tax

00:42:52.234 --> 00:42:54.801
for that package twice.

00:42:54.801 --> 00:42:57.000
Okay, some others here.

00:42:57.000 --> 00:43:00.834
We have some parameters
you can put in your gwt.xml.

00:43:00.834 --> 00:43:03.133
The shrink--sorry,
the compiler.stackMode.

00:43:03.133 --> 00:43:06.367
Stack stripping, it's called,
will remove a lot of info

00:43:06.367 --> 00:43:08.601
that can be used
in client-side stack traces,

00:43:08.601 --> 00:43:11.133
and you can get
up to a 15% reduction,

00:43:11.133 --> 00:43:13.968
uh, typically, from this.

00:43:13.968 --> 00:43:16.501
There's also
a new property put in

00:43:16.501 --> 00:43:19.033
to obfuscate the enum names,

00:43:19.033 --> 00:43:21.801
so if you use enum types
in your app extensively,

00:43:21.801 --> 00:43:23.501
you might want to look at this.

00:43:23.501 --> 00:43:25.367
Um, we're talkin'
about bytes here.

00:43:25.367 --> 00:43:27.868
You know, we're--
if you have an enum

00:43:27.868 --> 00:43:30.834
that's like male, female
for gender,

00:43:30.834 --> 00:43:33.834
it's 4 bytes and 5 bytes.
It's gonna go down to 0,1.

00:43:33.834 --> 00:43:36.334
So you're not gonna save
a whole lot of space,

00:43:36.334 --> 00:43:38.834
but if you use it a lot,
you might save a little.

00:43:38.834 --> 00:43:41.701
Um, we'll have a number
on that here in a sec.

00:43:41.701 --> 00:43:44.300
CssResource.obfuscationPrefix--

00:43:44.300 --> 00:43:47.834
uh, this is another thing you
can do to shorten up the names

00:43:47.834 --> 00:43:51.000
when you're using ClientBundle
and CSS Resources.

00:43:51.000 --> 00:43:53.267
There's a couple resources
listed here.

00:43:53.267 --> 00:43:57.167
You can look at the GWT FAQ
on our documentation site,

00:43:57.167 --> 00:44:00.834
as well as the file that's part
of the GWT distribution,

00:44:00.834 --> 00:44:02.801
CompilerParameters.gwt.xml,

00:44:02.801 --> 00:44:05.167
has even more parameters
that you can look at.

00:44:05.167 --> 00:44:08.934
These are the main ones that
affect size and speed, though.

00:44:10.634 --> 00:44:12.801
Okay, so what are the numbers
for--are different?

00:44:12.801 --> 00:44:14.734
Again, for
our Spirodraw app here,

00:44:14.734 --> 00:44:16.834
which does minimal casting
and has only one enum,

00:44:16.834 --> 00:44:18.834
so we're not really testing
those very heavily here,

00:44:18.834 --> 00:44:20.834
uh, but we see we can get
a few percent

00:44:20.834 --> 00:44:23.100
out of the -X options,

00:44:23.100 --> 00:44:25.067
3.8% out of stack stripping,

00:44:25.067 --> 00:44:28.067
and if you put it all together,
you can get a 7% reduction.

00:44:28.067 --> 00:44:29.734
Well, that's actually, uh,

00:44:29.734 --> 00:44:32.267
that's actually pretty sizable,
in this case,

00:44:32.267 --> 00:44:35.267
'cause we went from 280 K
down to 261 K.

00:44:35.267 --> 00:44:37.234
If your app is a lot bigger

00:44:37.234 --> 00:44:39.400
and uses a lot more
of these things,

00:44:39.400 --> 00:44:43.501
you could see anywhere
from 15% to 20% reduction.

00:44:43.501 --> 00:44:45.868
It may give you
a little extra boost

00:44:45.868 --> 00:44:47.701
on load time.

00:44:49.934 --> 00:44:53.501
So we've talked
about, uh, speed.

00:44:53.501 --> 00:44:55.801
Why does it matter?

00:44:55.801 --> 00:44:57.701
Pitfalls, Use Cell widgets,

00:44:57.701 --> 00:45:01.000
Use Activities and Places,
Compiler tips.

00:45:01.000 --> 00:45:03.434
I hope you've gotten
some valuable information here,

00:45:03.434 --> 00:45:05.501
and thank you very much.

00:45:05.501 --> 00:45:07.801
Let me take some questions
at the mics

00:45:07.801 --> 00:45:09.968
if, uh, anybody has any.

00:45:09.968 --> 00:45:12.901
[applause]

00:45:15.100 --> 00:45:17.100
Chandler: Thank you. Yes.

00:45:17.100 --> 00:45:19.601
man: Yeah, hi. I was wondering
if one of you

00:45:19.601 --> 00:45:22.601
could speak a little bit more
about sorting with CellTable,

00:45:22.601 --> 00:45:24.601
'cause I'm converting
to CellTable

00:45:24.601 --> 00:45:27.100
for my own implementation,
and I was able

00:45:27.100 --> 00:45:29.601
to get sorting working,
but it seemed a little onerous,

00:45:29.601 --> 00:45:31.767
and I was wondering
if there was any quick, easy,

00:45:31.767 --> 00:45:34.334
um, you know,
just 99% of the time,

00:45:34.334 --> 00:45:37.334
I want alphanumeric
on the contents, basically.

00:45:37.334 --> 00:45:38.968
Chandler: Okay.

00:45:38.968 --> 00:45:41.968
LaBanca: Um, so there's a--
so at its core,

00:45:41.968 --> 00:45:43.801
sorting is basically
a ColumnSortHandler.

00:45:43.801 --> 00:45:45.667
I guess you've already
discovered this,

00:45:45.667 --> 00:45:48.701
and, um, there are
a couple tricks you can do.

00:45:48.701 --> 00:45:50.767
So it's designed to work
in two scenarios.

00:45:50.767 --> 00:45:53.968
One is you, uh, when you sort,

00:45:53.968 --> 00:45:56.000
you'll get--you can get
a RangeChangeEvent,

00:45:56.000 --> 00:45:58.267
if you're sending an RPC request
to the server.

00:45:58.267 --> 00:46:00.701
At that point, you basically
send the sort info

00:46:00.701 --> 00:46:03.267
to the server, and the server
can do the sorting.

00:46:03.267 --> 00:46:05.467
If you're doing it
only on the client,

00:46:05.467 --> 00:46:08.367
um, you can provide--you can use
the ListDataProvider,

00:46:08.367 --> 00:46:10.200
which is a java.util.list,

00:46:10.200 --> 00:46:12.767
and what you can do is
you can associate a column

00:46:12.767 --> 00:46:15.033
with a comparator,

00:46:15.033 --> 00:46:17.701
and so, um, that's the simplest
it will get.

00:46:17.701 --> 00:46:19.701
You basically say,
when this column is sorted,

00:46:19.701 --> 00:46:21.601
use this comparator,
and if it's reverse-sorted,

00:46:21.601 --> 00:46:23.434
it will just use the comparator
in reverse,

00:46:23.434 --> 00:46:25.968
and, um, so you might want
to look into that.

00:46:25.968 --> 00:46:29.100
man: Okay, thank you.

00:46:29.100 --> 00:46:31.300
man: Is there any
documentation anywhere

00:46:31.300 --> 00:46:33.934
on the optimize levels
in the compile?

00:46:35.601 --> 00:46:38.601
Chandler: I don't think there's
any doc on specific levels.

00:46:38.601 --> 00:46:40.601
man: 'Cause it says,
like, 0 to 9.

00:46:40.601 --> 00:46:42.267
Chandler: Right.

00:46:42.267 --> 00:46:45.767
man: Is 9 better than 0,
or is 0 better than 9?

00:46:45.767 --> 00:46:49.000
Chandler: Oh.
man: [laughs]

00:46:49.000 --> 00:46:51.767
Chandler: I don't know.
Which compiles faster?

00:46:51.767 --> 00:46:53.601
man: Well, no--
specifically around,

00:46:53.601 --> 00:46:55.701
you know, like, the size
of the compile

00:46:55.701 --> 00:46:57.534
and all that type of thing.

00:46:57.534 --> 00:47:00.167
Is there any benefit
of using, you know, 9,

00:47:00.167 --> 00:47:02.200
or what's the default?
Let's put it that way.

00:47:02.200 --> 00:47:04.701
Chandler: I believe the default
is 9, and I believe

00:47:04.701 --> 00:47:06.534
that the draftCompile option
gives you 0.

00:47:06.534 --> 00:47:09.033
man: Okay.
Chandler: Yeah, so I think--

00:47:09.033 --> 00:47:11.467
In practice, I think most people
just use draftCompile.

00:47:11.467 --> 00:47:13.601
They don't worry about
individual levels,

00:47:13.601 --> 00:47:15.868
because probably,
if you're using draftCompile,

00:47:15.868 --> 00:47:18.334
you're wanting it to be as--

00:47:18.334 --> 00:47:20.200
compile as quickly as possible,

00:47:20.200 --> 00:47:22.767
and if you're compiling
for production,

00:47:22.767 --> 00:47:24.901
you want as much
optimization as possible,

00:47:24.901 --> 00:47:27.000
so practically, I don't think
people actually use that.

00:47:27.000 --> 00:47:28.868
They just use draftCompile.

00:47:28.868 --> 00:47:30.868
man: Okay, 'cause the reason
I was asking

00:47:30.868 --> 00:47:33.901
is there was a post somewhere
that said if you use, like, 4,

00:47:33.901 --> 00:47:37.200
it's, like, 20% smaller
code creation than if you use 9.

00:47:37.200 --> 00:47:39.200
I don't know if that's true,
or if that's--

00:47:39.200 --> 00:47:42.200
Chandler: I could see that
being true for 4 versus 9,

00:47:42.200 --> 00:47:44.200
but I would expect
that 0 would be even--

00:47:44.200 --> 00:47:45.868
oh, sorry, sorry.

00:47:45.868 --> 00:47:49.000
man: Yeah, it was like, 9
is larger than, like, 4.

00:47:49.000 --> 00:47:50.968
Chandler: Yeah. Okay, yeah.
man: Just curious.

00:47:50.968 --> 00:47:53.100
Chandler: Okay, yeah.
man: Thank you.

00:47:53.100 --> 00:47:55.934
man: Um, at the beginning
of your talk,

00:47:55.934 --> 00:47:57.501
you were t--

00:47:57.501 --> 00:48:00.334
um, you mentioned that
you should only create widgets,

00:48:00.334 --> 00:48:04.801
um, in cases where you need
events off those widgets.

00:48:04.801 --> 00:48:08.300
Um, I'm wondering
about HTML panels,

00:48:08.300 --> 00:48:10.567
'cause you said also
that if--if you can,

00:48:10.567 --> 00:48:12.868
just use HTML, straight HTML,

00:48:12.868 --> 00:48:15.868
if you don't need to put,
um, events in there.

00:48:15.868 --> 00:48:18.367
But what if you were
to create an HTML panel

00:48:18.367 --> 00:48:20.868
and then, you know, I.D.
some element way down there

00:48:20.868 --> 00:48:22.534
and then add a widget to that?

00:48:22.534 --> 00:48:24.367
Do you get any benefits
from that?

00:48:24.367 --> 00:48:26.467
Is that
an optimization technique

00:48:26.467 --> 00:48:28.434
that you think might fly, or...

00:48:28.434 --> 00:48:30.267
Chandler: I think--do you know--
LaBanca: Yeah.

00:48:30.267 --> 00:48:32.100
Chandler: HTML panels
still have some--

00:48:32.100 --> 00:48:34.367
LaBanca: Yeah--no, abso--
but that is an optimization.

00:48:34.367 --> 00:48:36.567
In fact, if you're
using UiBinder,

00:48:36.567 --> 00:48:38.534
that's the way
most people use it,

00:48:38.534 --> 00:48:42.367
is they create the HTML panel,
fill it with raw HTML,

00:48:42.367 --> 00:48:44.267
and just use
widgets selectively.

00:48:44.267 --> 00:48:46.767
That's the big--if you use that
throughout your app,

00:48:46.767 --> 00:48:48.767
I mean, one is not gonna
make a difference,

00:48:48.767 --> 00:48:50.767
but if you use it
throughout your app,

00:48:50.767 --> 00:48:52.834
that's significantly faster
than using panels,

00:48:52.834 --> 00:48:55.100
GWT panels, throughout,
so, definitely.

00:48:55.100 --> 00:48:58.100
man: Okay, thanks.

00:48:58.100 --> 00:49:01.234
Chandler: Question over here,
down the center aisle.

00:49:01.234 --> 00:49:03.567
man: Okay, so I would have
two questions.

00:49:03.567 --> 00:49:06.067
One is not certainly relevant,

00:49:06.067 --> 00:49:07.801
but what happened to Roo?

00:49:07.801 --> 00:49:10.501
That was a big thing last time,

00:49:10.501 --> 00:49:13.133
and, like, I didn't hear
anything about that.

00:49:13.133 --> 00:49:14.834
Chandler: Um, I'm not aware

00:49:14.834 --> 00:49:17.400
of a lot of activity
around Roo, currently.

00:49:17.400 --> 00:49:19.634
Um, I think some GWT folks--

00:49:19.634 --> 00:49:22.634
actually, the Spring guy who is
supposed to be working with that

00:49:22.634 --> 00:49:24.300
is here at the conference,

00:49:24.300 --> 00:49:26.834
um, so you might ask him
what's going on with it,

00:49:26.834 --> 00:49:29.167
um, but it's--that's
Spring's department, really,

00:49:29.167 --> 00:49:31.968
more than--more than GWT.
man: Okay.

00:49:31.968 --> 00:49:33.734
Second one would be, like--

00:49:33.734 --> 00:49:37.334
you told that it's a good idea
to cache the views,

00:49:37.334 --> 00:49:39.501
but not the presenters.
Chandler: Right.

00:49:39.501 --> 00:49:42.300
man: But could that not, uh,
lead to some memory issues

00:49:42.300 --> 00:49:44.434
if you cache too many views?

00:49:44.434 --> 00:49:47.367
'Cause I get--somehow,
it's caching the memory,

00:49:47.367 --> 00:49:50.133
like all the widgets and stuff.

00:49:50.133 --> 00:49:52.133
Chandler: I suppose if you had,

00:49:52.133 --> 00:49:54.334
you know, hundreds or thousands
of views,

00:49:54.334 --> 00:49:58.801
that you could end up
eating some memory that way,

00:49:58.801 --> 00:50:01.133
but when I say
"cache the views,"

00:50:01.133 --> 00:50:03.801
I'm not talking about loading
them all at once, necessarily,

00:50:03.801 --> 00:50:05.901
but just the first time
they get loaded.

00:50:05.901 --> 00:50:08.467
Then you keep them around
as, essentially, singletons

00:50:08.467 --> 00:50:10.267
rather than creating
new instances

00:50:10.267 --> 00:50:11.934
every time the Place changes.

00:50:11.934 --> 00:50:13.934
man: Mm-hmm. Okay, thank you.
Chandler: Yeah.

00:50:13.934 --> 00:50:15.701
Okay, over here.

00:50:15.701 --> 00:50:17.834
man: So I really appreciated
in this session

00:50:17.834 --> 00:50:21.167
the, uh, breakdown
of Activities, Places,

00:50:21.167 --> 00:50:23.734
views, and presenters,
and kind of seeing

00:50:23.734 --> 00:50:27.033
how you could take pieces
and make up a page,

00:50:27.033 --> 00:50:29.501
and then in an earlier
presentation, you talked about

00:50:29.501 --> 00:50:32.901
views and presenters
being used for mobile.

00:50:32.901 --> 00:50:35.501
Could I convince you to take
these sample applications

00:50:35.501 --> 00:50:38.501
and create a mobile version
of it, so that we can see

00:50:38.501 --> 00:50:41.801
how Activities, Places,
views, presenters,

00:50:41.801 --> 00:50:44.567
can be put together
for your desktop

00:50:44.567 --> 00:50:46.501
and then for mobile?

00:50:46.501 --> 00:50:49.501
Chandler: Yeah, take a look
at the Expenses sample.

00:50:49.501 --> 00:50:52.100
Actually, there's a mobile
version of that already.

00:50:52.100 --> 00:50:54.534
man: Excellent.
Chandler: And I think it uses

00:50:54.534 --> 00:50:56.934
Activities and Places.
I'm not positive.

00:50:56.934 --> 00:50:59.701
LaBanca: Actually, the mobile
web app sample is even better.

00:50:59.701 --> 00:51:01.767
The newest sample, um, has--

00:51:01.767 --> 00:51:03.734
it's exactly
what you're talking about.

00:51:03.734 --> 00:51:05.501
It uses Activities and Places,

00:51:05.501 --> 00:51:08.033
and it has--the Activity
is the "presenter,"

00:51:08.033 --> 00:51:12.033
and we have different views
for tablet, mobile, and desktop,

00:51:12.033 --> 00:51:14.834
so basically, it will detect
which device you're on

00:51:14.834 --> 00:51:16.667
and serve you the view,

00:51:16.667 --> 00:51:18.767
but the 90% of the code

00:51:18.767 --> 00:51:21.634
that's, like,
above the view logic

00:51:21.634 --> 00:51:25.067
is all completely shared.
man: And so that--

00:51:25.067 --> 00:51:27.400
what I'm wondering about
is on the desktop,

00:51:27.400 --> 00:51:29.434
you're gonna want to have
all the pieces together,

00:51:29.434 --> 00:51:31.601
and then on the phone,
for example,

00:51:31.601 --> 00:51:34.000
those pieces that are all
together on the desktop

00:51:34.000 --> 00:51:36.100
will end up being
different pages, right?

00:51:36.100 --> 00:51:39.501
LaBanca: Um, it's the same
Places, but they look different.

00:51:39.501 --> 00:51:41.000
man: Okay.

00:51:41.000 --> 00:51:42.834
LaBanca: So for example,
on the desktop--

00:51:42.834 --> 00:51:44.834
I'll tell you what
the versions look like.

00:51:44.834 --> 00:51:46.667
On the desktop, you have a menu,

00:51:46.667 --> 00:51:48.667
and you click
the task list or "Add Task."

00:51:48.667 --> 00:51:51.667
if you haven't seen the app,
it's a task manager.

00:51:51.667 --> 00:51:55.167
And so you have a task list
that's a table, a CellTable,

00:51:55.167 --> 00:51:56.834
and then you have Add Task.

00:51:56.834 --> 00:51:58.834
It's a form, and you can
switch between them.

00:51:58.834 --> 00:52:00.701
On the mobile version,
it's similar,

00:52:00.701 --> 00:52:02.567
except you have a list of tasks,

00:52:02.567 --> 00:52:05.067
and each item has, you know,
a sort of a rich--

00:52:05.067 --> 00:52:07.067
it has a name
and a date under it,

00:52:07.067 --> 00:52:09.067
and when you click one,
it slides over,

00:52:09.067 --> 00:52:12.067
and the form is more vertical
for a mobile.

00:52:12.067 --> 00:52:15.067
And then on the tablet,
it's got them, uh, split screen,

00:52:15.067 --> 00:52:17.067
so you have the list
always visible

00:52:17.067 --> 00:52:19.567
and the task on the--
on the side,

00:52:19.567 --> 00:52:21.234
and it even supports things

00:52:21.234 --> 00:52:23.400
like rotating the mobile device
and the tablet.

00:52:23.400 --> 00:52:25.234
man: Excellent.
That sounds exactly

00:52:25.234 --> 00:52:27.067
like what I'm wondering about.
Thanks.

00:52:27.067 --> 00:52:28.934
Chandler: That code
is located right here.

00:52:28.934 --> 00:52:31.434
I've got it up on the--
it's under the, uh,

00:52:31.434 --> 00:52:34.067
in trunk, samples,
mobile web app.

00:52:34.067 --> 00:52:36.000
Question from this mic.

00:52:36.000 --> 00:52:37.734
man: Yeah, so, um,

00:52:37.734 --> 00:52:41.067
Cells are awesome from
a performance perspective,

00:52:41.067 --> 00:52:44.067
but they don't really compare
to widgets in terms of,

00:52:44.067 --> 00:52:46.400
uh, being able to, you know,

00:52:46.400 --> 00:52:48.400
add styles and attributes

00:52:48.400 --> 00:52:50.367
and basically muck with them,

00:52:50.367 --> 00:52:52.300
uh, very dynamically.

00:52:52.300 --> 00:52:55.300
And given that Cells
kind of seem to be the future

00:52:55.300 --> 00:52:57.400
with--with the new widgets
and all of this,

00:52:57.400 --> 00:53:00.934
uh, do you think, um, you know,
ever get Cells to a point

00:53:00.934 --> 00:53:03.167
where it doesn't require,
you know,

00:53:03.167 --> 00:53:06.534
a brand-new Cell implementation
with, you know, innerHTML stuff

00:53:06.534 --> 00:53:08.334
and your own, you know,
dispatch and stuff,

00:53:08.334 --> 00:53:11.767
just to, you know, add something
that the Cell up front did not--

00:53:11.767 --> 00:53:14.267
you know, most of them will
sometimes take style name,

00:53:14.267 --> 00:53:17.267
but, you know, nothing really
other than that,

00:53:17.267 --> 00:53:19.100
um, if you know what I mean.

00:53:19.100 --> 00:53:22.367
LaBanca: Yeah, the first set
of Cells were very rudimentary,

00:53:22.367 --> 00:53:24.400
and we intentionally
didn't expose any styles

00:53:24.400 --> 00:53:26.267
so that we could add them later,

00:53:26.267 --> 00:53:29.334
'cause if we exposed them now,
we'd be stuck with 'em.

00:53:29.334 --> 00:53:32.334
So the answer is yes, we plan
to expand the library,

00:53:32.334 --> 00:53:34.334
and to focus on ClientBundle

00:53:34.334 --> 00:53:36.267
and, uh, CSS resources,

00:53:36.267 --> 00:53:38.334
so they'll be a little bit
more difficult--

00:53:38.334 --> 00:53:41.834
well, okay, admittedly, they'll
be more difficult, um, to style,

00:53:41.834 --> 00:53:45.367
because you have to specify
your styles in a CSS resource,

00:53:45.367 --> 00:53:48.501
but, um, when you do that,
the GWT compiler is--

00:53:48.501 --> 00:53:50.501
can optimize those
and obfuscate the names,

00:53:50.501 --> 00:53:52.501
so it actually gives you
a performance benefit,

00:53:52.501 --> 00:53:54.968
and so, over time, we're gonna
expand that library

00:53:54.968 --> 00:53:58.334
and make it more customizable,
ad we're following a pattern.

00:53:58.334 --> 00:54:02.033
The only one in there now
is the, um, the button widget

00:54:02.033 --> 00:54:04.501
has been modified,
or the "text" button.

00:54:04.501 --> 00:54:07.300
But we're following
a pattern where it's--

00:54:07.300 --> 00:54:11.267
we gwt.create all
of the, um, the resources

00:54:11.267 --> 00:54:13.100
and the view version of that,

00:54:13.100 --> 00:54:14.934
the appearance pattern,
we call it.

00:54:14.934 --> 00:54:18.234
And so what that means is that
third parties can provide skins

00:54:18.234 --> 00:54:21.234
that not only replace the styles
but the actual DOM structure,

00:54:21.234 --> 00:54:23.734
so your button can go
from being a button element

00:54:23.734 --> 00:54:26.100
to some nested divs
to whatever else you want.

00:54:26.100 --> 00:54:28.033
And we're hoping that takes off,

00:54:28.033 --> 00:54:31.033
but we have not yet really
started to expand that library.

00:54:31.033 --> 00:54:34.634
man: Sure, sure. I-I perhaps
overemphasized style,

00:54:34.634 --> 00:54:36.567
um, and what
I was talking about.

00:54:36.567 --> 00:54:40.000
Widgets are also just really--
since they're stateful,

00:54:40.000 --> 00:54:42.934
it's very easy to intuitively,
you know, modify them,

00:54:42.934 --> 00:54:44.901
you know, adding children,
removing children,

00:54:44.901 --> 00:54:46.968
uh, setting things
that aren't style-related,

00:54:46.968 --> 00:54:49.000
like titles or values
or whatever.

00:54:49.000 --> 00:54:52.133
Uh, it's just a very stateful
and intuitive model

00:54:52.133 --> 00:54:54.200
that I don't quite see
yet in Cells,

00:54:54.200 --> 00:54:56.434
um, but would
definitely like to.

00:54:56.434 --> 00:54:58.501
Obviously, I understand you
don't have states, so that...

00:54:58.501 --> 00:55:00.334
Chandler: Yeah, I think it's--

00:55:00.334 --> 00:55:02.901
if I can speak to that, I think
it's pretty much implicit

00:55:02.901 --> 00:55:04.567
in the flyweight pattern.

00:55:04.567 --> 00:55:06.567
If you're writing out HTML,
it--it's gonna be ugly,

00:55:06.567 --> 00:55:08.901
but that's how you get
the performance benefit

00:55:08.901 --> 00:55:11.901
associated with
the--the Cell widgets.

00:55:11.901 --> 00:55:13.901
LaBanca: And one thing
that's coming down the pipe

00:55:13.901 --> 00:55:16.901
is a UiBinder for Cells,
so that--that will help a lot,

00:55:16.901 --> 00:55:19.968
so instead of having
to construct the HTML

00:55:19.968 --> 00:55:21.801
from an object,

00:55:21.801 --> 00:55:24.167
using, uh, StringBuilder
or SafeHtml Builder,

00:55:24.167 --> 00:55:27.534
you could just put it
into a UiBinder XML file

00:55:27.534 --> 00:55:30.767
and sort of write the raw HTML,
and then replace parts

00:55:30.767 --> 00:55:33.734
with the values
that you want to replace

00:55:33.734 --> 00:55:35.701
so that should help.

00:55:35.701 --> 00:55:37.367
Chandler: Question over here.

00:55:37.367 --> 00:55:40.167
man: Yeah. We start
to use CellTable,

00:55:40.167 --> 00:55:43.234
and it's nice
and very easy to use

00:55:43.234 --> 00:55:45.934
and also has a custom column,

00:55:45.934 --> 00:55:48.601
so you can create
your own column type,

00:55:48.601 --> 00:55:52.167
and, uh--but we have some
problems with alignment.

00:55:52.167 --> 00:55:55.667
I don't know--it's the way--
we didn't use it properly, or--

00:55:55.667 --> 00:55:58.667
because some columns
won't align to the left,

00:55:58.667 --> 00:56:02.267
some to the right,
and it works in some browsers

00:56:02.267 --> 00:56:04.667
and doesn't work
in other browsers.

00:56:04.667 --> 00:56:08.033
Is it a known issue,
or something we didn't do right?

00:56:08.033 --> 00:56:10.467
LaBanca: The text aligns
on different sides?

00:56:10.467 --> 00:56:14.534
man: The--yes, alignment,
uh, for the column.

00:56:14.534 --> 00:56:16.868
LaBanca: By default,
we don't adjust alignment,

00:56:16.868 --> 00:56:19.934
so the browser just chooses
the alignment.

00:56:19.934 --> 00:56:22.434
It may vary between browsers.
Chandler: It does.

00:56:22.434 --> 00:56:24.267
LaBanca: And they may even
do creative stuff

00:56:24.267 --> 00:56:26.767
like move numbers over to one
side but text over to the other,

00:56:26.767 --> 00:56:28.434
but there is a, uh--
man: Exactly.

00:56:28.434 --> 00:56:30.934
LaBanca: In a column, have you
tried using the setAlignment?

00:56:30.934 --> 00:56:32.934
man: Yes, we tried, but--
LaBanca: Didn't work?

00:56:32.934 --> 00:56:35.434
man: It worked in some browsers,
but it doesn't work--

00:56:35.434 --> 00:56:37.934
LaBanca: Okay, you can
file a bug and we'll take a--

00:56:37.934 --> 00:56:39.767
that should fix it
in all browsers.

00:56:39.767 --> 00:56:42.267
man: Okay, my other question
is related to the Activities.

00:56:42.267 --> 00:56:43.934
We started to use that, as well,

00:56:43.934 --> 00:56:47.434
and the warning, you know,
pop-up is very nice

00:56:47.434 --> 00:56:49.400
when the user wants to,

00:56:49.400 --> 00:56:51.901
um, when they click
the--the "back" button,

00:56:51.901 --> 00:56:55.367
but sometimes, we want
to pop up a new window,

00:56:55.367 --> 00:56:59.300
and for example, pop up a new
window to an external URL,

00:56:59.300 --> 00:57:01.634
and that warning also pops up.

00:57:01.634 --> 00:57:05.067
Is there any, you know, bypass
or workaround with that?

00:57:05.067 --> 00:57:07.934
We don't want--we don't want
to show that pop-up

00:57:07.934 --> 00:57:10.834
when they try to open
a new window,

00:57:10.834 --> 00:57:12.567
go to another URL.

00:57:12.567 --> 00:57:15.000
Chandler: Uh, you have
the onMayStop method,

00:57:15.000 --> 00:57:17.567
where you provide
your warning message,

00:57:17.567 --> 00:57:20.234
so you could override
that method and make it,

00:57:20.234 --> 00:57:22.767
uh, you know, set some kind
of flag in there,

00:57:22.767 --> 00:57:24.601
that it could look at
to determine

00:57:24.601 --> 00:57:27.133
whether or not you wanted
to show the message.

00:57:27.133 --> 00:57:28.968
man: Um--
Chandler: Is that--

00:57:28.968 --> 00:57:32.234
because if you return "true"
from--no, sorry.

00:57:32.234 --> 00:57:34.200
You would be looking
at the, uh--

00:57:34.200 --> 00:57:35.968
yeah, it's onMayStop, I think.

00:57:35.968 --> 00:57:39.200
If you return "true" from that,
then it will--

00:57:39.200 --> 00:57:42.400
um, it will let it
go ahead and stop,

00:57:42.400 --> 00:57:44.400
and it won't pop
any warning message at all.

00:57:44.400 --> 00:57:46.400
man: Give example--
uh, on your screen,

00:57:46.400 --> 00:57:48.234
maybe you have
a button to click,

00:57:48.234 --> 00:57:51.234
and that will open up
a new pop-up window,

00:57:51.234 --> 00:57:53.801
go to an external URL...
Chandler: Mm-hmm.

00:57:53.801 --> 00:57:56.100
man: Would even leave
this page, anyway,

00:57:56.100 --> 00:57:58.934
but the pop-up--and the warning,
you know, comes out,

00:57:58.934 --> 00:58:02.400
and asks you, do you want to
stay and do you want to leave?

00:58:02.400 --> 00:58:05.868
I mean, is there any workaround
for that, or...

00:58:05.868 --> 00:58:08.367
Chandler: That--no, I can't
remember which method it is,

00:58:08.367 --> 00:58:10.934
exactly, but it's--
I think it's onMayStop...

00:58:10.934 --> 00:58:12.767
man: Okay.
Chandler: End the Activity,

00:58:12.767 --> 00:58:14.534
and if you return
the right thing,

00:58:14.534 --> 00:58:16.534
it's either "no" or "true"
or something like that,

00:58:16.534 --> 00:58:18.934
but then it will
allow it to stop

00:58:18.934 --> 00:58:21.767
without putting up
any kind of a warning message.

00:58:21.767 --> 00:58:23.901
man: Okay, I'll look into.
Thank you.

00:58:23.901 --> 00:58:26.300
Chandler: Yeah. Question?

00:58:26.300 --> 00:58:28.901
man: Yeah. When I've inspected

00:58:28.901 --> 00:58:31.901
some of the JavaScript
that's generated,

00:58:31.901 --> 00:58:33.801
um, you know how it
kind of goes,

00:58:33.801 --> 00:58:36.400
uh, shortest method
to longest method,

00:58:36.400 --> 00:58:39.901
there seems to be an awful lot
of methods that are just empty.

00:58:39.901 --> 00:58:42.033
I'm not sure if that's,

00:58:42.033 --> 00:58:45.701
um, just some coding style
that just seems to be pervasive

00:58:45.701 --> 00:58:47.534
in projects that
I've seen 'em in,

00:58:47.534 --> 00:58:49.767
but I noticed this like,

00:58:49.767 --> 00:58:52.100
you know, 40 just
totally empty methods,

00:58:52.100 --> 00:58:53.834
and I'm thinking,
there's probably gotta be

00:58:53.834 --> 00:58:57.334
some compiler setting
that gets rid of those?

00:58:57.334 --> 00:58:59.234
I don't know
if maybe they're there

00:58:59.234 --> 00:59:03.033
as an obfuscation technique
to sort of throw people off.

00:59:03.033 --> 00:59:05.200
I don't really know,

00:59:05.200 --> 00:59:07.534
but I do notice them
consistently in there,

00:59:07.534 --> 00:59:10.167
and I wonder if that's something
that we can get rid of.

00:59:10.167 --> 00:59:11.834
I mean, it's, like,
three characters

00:59:11.834 --> 00:59:14.567
or, yeah, four characters
apiece, so it's not huge,

00:59:14.567 --> 00:59:16.534
but there are 40 or 50 of 'em,

00:59:16.534 --> 00:59:19.501
so does that sound familiar
at all? Do you see that...

00:59:19.501 --> 00:59:21.634
Chandler: I remember
seeing an issue on this

00:59:21.634 --> 00:59:23.067
uh, on the issue tracker,
actually.

00:59:23.067 --> 00:59:25.067
Did you file that issue?
man: No, I didn't.

00:59:25.067 --> 00:59:26.567
Chandler: [laughs] Okay.

00:59:26.567 --> 00:59:28.567
Um, so someone else
has observed it.

00:59:28.567 --> 00:59:31.300
man: Good.
Chandler: And I don't remember,

00:59:31.300 --> 00:59:33.701
uh, I don't remember
the details, honestly.

00:59:33.701 --> 00:59:35.367
I know it's out there.

00:59:35.367 --> 00:59:37.367
You might see whatever responses
were on that issue,

00:59:37.367 --> 00:59:39.367
but it has been
pointed out before.

00:59:39.367 --> 00:59:41.367
man: Okay. I haven't
looked in 2.3.0,

00:59:41.367 --> 00:59:43.868
but I mean, about 2.1 and 2.2,
I noticed 'em, but...

00:59:43.868 --> 00:59:45.868
Chandler: Yeah, I-I think there
are some pathological cases

00:59:45.868 --> 00:59:47.834
where that happens.

00:59:47.834 --> 00:59:50.501
It's--and we're trying not
to do that, ordinarily,

00:59:50.501 --> 00:59:53.534
um, but, yeah, without looking
at the actual code, whatever,

00:59:53.534 --> 00:59:55.834
it's hard to say.
man: Okay, thanks.

00:59:55.834 --> 00:59:57.734
Chandler: Yes.

00:59:57.734 --> 01:00:01.000
man: So closely related
to code splitting is the ability

01:00:01.000 --> 01:00:04.067
to defer loading of third-party
JavaScript libraries.

01:00:04.067 --> 01:00:08.100
Is there any thought
to providing that API,

01:00:08.100 --> 01:00:10.033
or did I miss it?

01:00:12.300 --> 01:00:14.300
LaBanca: I don't think
we have that...

01:00:14.300 --> 01:00:15.968
man: Okay.
LaBanca: Obviously.

01:00:15.968 --> 01:00:17.968
Chandler: Yeah.
man: Have you thought about it?

01:00:17.968 --> 01:00:19.801
LaBanca: What you're basically
talking about

01:00:19.801 --> 01:00:22.801
is a script widget, if you will,
with a LoadHandler.

01:00:22.801 --> 01:00:25.234
I mean, that's what
it would amount to,

01:00:25.234 --> 01:00:28.367
um, and it's not on anybody's
radar, as far as I know,

01:00:28.367 --> 01:00:30.367
but if it would be useful,
probably something

01:00:30.367 --> 01:00:32.367
that could be done.
Chandler: Yeah.

01:00:32.367 --> 01:00:34.200
man: In our case,
the third-party library

01:00:34.200 --> 01:00:35.868
is larger than our app,

01:00:35.868 --> 01:00:39.234
and we use it less
than 20% of the time,

01:00:39.234 --> 01:00:42.734
so there are cases where
it would be very useful.

01:00:42.734 --> 01:00:44.567
LaBanca: Do you want--

01:00:44.567 --> 01:00:48.000
uh, if you just want to defer
the loading of it,

01:00:48.000 --> 01:00:49.667
you can use runAsync,

01:00:49.667 --> 01:00:51.501
and in your runAsync call--

01:00:51.501 --> 01:00:53.334
well, that's not really
what you want.

01:00:53.334 --> 01:00:56.334
Um, I mean--yeah, I'm not sure.
I don't have a good answer.

01:00:56.334 --> 01:00:58.434
I'd be making stuff up.
man: Okay.

01:01:01.400 --> 01:01:03.400
Chandler: Last question,
over here. Yep.

01:01:03.400 --> 01:01:05.567
man: Now to--to
this runAsync topic,

01:01:05.567 --> 01:01:07.868
so you mentioned that we can

01:01:07.868 --> 01:01:09.834
inject, like,
inject it with GIN,

01:01:09.834 --> 01:01:12.767
like, to annotate it, and what
happens if it cannot load?

01:01:12.767 --> 01:01:15.901
Is there some error handling
for that?

01:01:15.901 --> 01:01:18.634
Chandler: Yes, you also provide
an onFailure method

01:01:18.634 --> 01:01:21.534
uh, in your runAsync block.
man: Oh.

01:01:21.534 --> 01:01:23.534
Chandler: And
the onFailure method--

01:01:23.534 --> 01:01:25.534
then you control what happens.
man: Okay.

01:01:25.534 --> 01:01:27.534
[speaking indistinctly]
Okay, thanks.

01:01:27.534 --> 01:01:29.467
Chandler: Okay, thank you
very much.

