WEBVTT
Kind: captions
Language: en

00:00:00.060 --> 00:00:02.270
 
in the previous video you saw a few

00:00:02.270 --> 00:00:02.280
in the previous video you saw a few
 

00:00:02.280 --> 00:00:05.150
in the previous video you saw a few
examples of how vectorization by using

00:00:05.150 --> 00:00:05.160
examples of how vectorization by using
 

00:00:05.160 --> 00:00:06.920
examples of how vectorization by using
built-in functions and by avoiding

00:00:06.920 --> 00:00:06.930
built-in functions and by avoiding
 

00:00:06.930 --> 00:00:09.470
built-in functions and by avoiding
explicit for loops allows you to speed

00:00:09.470 --> 00:00:09.480
explicit for loops allows you to speed
 

00:00:09.480 --> 00:00:11.480
explicit for loops allows you to speed
up your code significantly let's take a

00:00:11.480 --> 00:00:11.490
up your code significantly let's take a
 

00:00:11.490 --> 00:00:14.240
up your code significantly let's take a
look at few more examples the rule of

00:00:14.240 --> 00:00:14.250
look at few more examples the rule of
 

00:00:14.250 --> 00:00:16.070
look at few more examples the rule of
thumb to keep in mind is when you

00:00:16.070 --> 00:00:16.080
thumb to keep in mind is when you
 

00:00:16.080 --> 00:00:17.990
thumb to keep in mind is when you
programming your neural network so when

00:00:17.990 --> 00:00:18.000
programming your neural network so when
 

00:00:18.000 --> 00:00:19.519
programming your neural network so when
you're programming logistic regression

00:00:19.519 --> 00:00:19.529
you're programming logistic regression
 

00:00:19.529 --> 00:00:22.340
you're programming logistic regression
whenever possible avoid explicit for

00:00:22.340 --> 00:00:22.350
whenever possible avoid explicit for
 

00:00:22.350 --> 00:00:25.279
whenever possible avoid explicit for
loops and it's not always possible to

00:00:25.279 --> 00:00:25.289
loops and it's not always possible to
 

00:00:25.289 --> 00:00:27.950
loops and it's not always possible to
never use a for loop but when you can

00:00:27.950 --> 00:00:27.960
never use a for loop but when you can
 

00:00:27.960 --> 00:00:29.689
never use a for loop but when you can
use a built in function or find some

00:00:29.689 --> 00:00:29.699
use a built in function or find some
 

00:00:29.699 --> 00:00:32.179
use a built in function or find some
other way to compute whatever you need

00:00:32.179 --> 00:00:32.189
other way to compute whatever you need
 

00:00:32.189 --> 00:00:34.940
other way to compute whatever you need
it will often go faster than if you

00:00:34.940 --> 00:00:34.950
it will often go faster than if you
 

00:00:34.950 --> 00:00:37.430
it will often go faster than if you
haven't explicit for me let's look at

00:00:37.430 --> 00:00:37.440
haven't explicit for me let's look at
 

00:00:37.440 --> 00:00:38.270
haven't explicit for me let's look at
another example

00:00:38.270 --> 00:00:38.280
another example
 

00:00:38.280 --> 00:00:42.049
another example
if ever you want to compute a vector you

00:00:42.049 --> 00:00:42.059
if ever you want to compute a vector you
 

00:00:42.059 --> 00:00:44.959
if ever you want to compute a vector you
as the product of a matrix a and another

00:00:44.959 --> 00:00:44.969
as the product of a matrix a and another
 

00:00:44.969 --> 00:00:49.010
as the product of a matrix a and another
vector B then the definition of a matrix

00:00:49.010 --> 00:00:49.020
vector B then the definition of a matrix
 

00:00:49.020 --> 00:00:52.250
vector B then the definition of a matrix
multiply is that you know UI is equal to

00:00:52.250 --> 00:00:52.260
multiply is that you know UI is equal to
 

00:00:52.260 --> 00:00:57.260
multiply is that you know UI is equal to
sum of a j AI J VJ alright that's how

00:00:57.260 --> 00:00:57.270
sum of a j AI J VJ alright that's how
 

00:00:57.270 --> 00:01:00.290
sum of a j AI J VJ alright that's how
you define UI and so the non vectorized

00:01:00.290 --> 00:01:00.300
you define UI and so the non vectorized
 

00:01:00.300 --> 00:01:02.180
you define UI and so the non vectorized
implementation of this would be you know

00:01:02.180 --> 00:01:02.190
implementation of this would be you know
 

00:01:02.190 --> 00:01:07.039
implementation of this would be you know
to set u equals NP plus zeros would be n

00:01:07.039 --> 00:01:07.049
to set u equals NP plus zeros would be n
 

00:01:07.049 --> 00:01:12.320
to set u equals NP plus zeros would be n
by 1 and then you know 4i and so on for

00:01:12.320 --> 00:01:12.330
by 1 and then you know 4i and so on for
 

00:01:12.330 --> 00:01:18.649
by 1 and then you know 4i and so on for
J and so on right and UI plus equals you

00:01:18.649 --> 00:01:18.659
J and so on right and UI plus equals you
 

00:01:18.659 --> 00:01:24.440
J and so on right and UI plus equals you
know a IJ times VJ so now this has to

00:01:24.440 --> 00:01:24.450
know a IJ times VJ so now this has to
 

00:01:24.450 --> 00:01:27.859
know a IJ times VJ so now this has to
foldings looking over both I and J so

00:01:27.859 --> 00:01:27.869
foldings looking over both I and J so
 

00:01:27.869 --> 00:01:29.300
foldings looking over both I and J so
that's a non vectorized version the

00:01:29.300 --> 00:01:29.310
that's a non vectorized version the
 

00:01:29.310 --> 00:01:30.710
that's a non vectorized version the
vectorized implementation would be to

00:01:30.710 --> 00:01:30.720
vectorized implementation would be to
 

00:01:30.720 --> 00:01:37.999
vectorized implementation would be to
say u equals NP dot a comma V and diems

00:01:37.999 --> 00:01:38.009
say u equals NP dot a comma V and diems
 

00:01:38.009 --> 00:01:39.560
say u equals NP dot a comma V and diems
plantation on the right to vectorize

00:01:39.560 --> 00:01:39.570
plantation on the right to vectorize
 

00:01:39.570 --> 00:01:42.620
plantation on the right to vectorize
version now eliminates two different for

00:01:42.620 --> 00:01:42.630
version now eliminates two different for
 

00:01:42.630 --> 00:01:44.050
version now eliminates two different for
loops and it's going to be way faster

00:01:44.050 --> 00:01:44.060
loops and it's going to be way faster
 

00:01:44.060 --> 00:01:46.819
loops and it's going to be way faster
let's go through one more example let's

00:01:46.819 --> 00:01:46.829
let's go through one more example let's
 

00:01:46.829 --> 00:01:48.560
let's go through one more example let's
say you already have a vector V in

00:01:48.560 --> 00:01:48.570
say you already have a vector V in
 

00:01:48.570 --> 00:01:52.039
say you already have a vector V in
memory and you want to apply the

00:01:52.039 --> 00:01:52.049
memory and you want to apply the
 

00:01:52.049 --> 00:01:54.350
memory and you want to apply the
exponential operation on every element

00:01:54.350 --> 00:01:54.360
exponential operation on every element
 

00:01:54.360 --> 00:01:56.899
exponential operation on every element
of say this vector V so you confuse you

00:01:56.899 --> 00:01:56.909
of say this vector V so you confuse you
 

00:01:56.909 --> 00:02:00.139
of say this vector V so you confuse you
equals in a vector that's e to the B 1 e

00:02:00.139 --> 00:02:00.149
equals in a vector that's e to the B 1 e
 

00:02:00.149 --> 00:02:03.429
equals in a vector that's e to the B 1 e
to the V 2 and so on down to e to the

00:02:03.429 --> 00:02:03.439
to the V 2 and so on down to e to the
 

00:02:03.439 --> 00:02:05.630
to the V 2 and so on down to e to the
the end

00:02:05.630 --> 00:02:05.640
the end
 

00:02:05.640 --> 00:02:07.250
the end
so this would be a non vectorized

00:02:07.250 --> 00:02:07.260
so this would be a non vectorized
 

00:02:07.260 --> 00:02:09.830
so this would be a non vectorized
implementation right which is that first

00:02:09.830 --> 00:02:09.840
implementation right which is that first
 

00:02:09.840 --> 00:02:12.890
implementation right which is that first
you initialize you to a vector of zeros

00:02:12.890 --> 00:02:12.900
you initialize you to a vector of zeros
 

00:02:12.900 --> 00:02:14.870
you initialize you to a vector of zeros
and then you have a for loop that

00:02:14.870 --> 00:02:14.880
and then you have a for loop that
 

00:02:14.880 --> 00:02:18.320
and then you have a for loop that
computes the elements one at a time but

00:02:18.320 --> 00:02:18.330
computes the elements one at a time but
 

00:02:18.330 --> 00:02:21.440
computes the elements one at a time but
it turns out that Python numpy have many

00:02:21.440 --> 00:02:21.450
it turns out that Python numpy have many
 

00:02:21.450 --> 00:02:24.100
it turns out that Python numpy have many
built-in functions that allow you to

00:02:24.100 --> 00:02:24.110
built-in functions that allow you to
 

00:02:24.110 --> 00:02:28.460
built-in functions that allow you to
compute these vectors with just a single

00:02:28.460 --> 00:02:28.470
compute these vectors with just a single
 

00:02:28.470 --> 00:02:32.360
compute these vectors with just a single
call to a single function so what I

00:02:32.360 --> 00:02:32.370
call to a single function so what I
 

00:02:32.370 --> 00:02:35.770
call to a single function so what I
would do to implement this is import um

00:02:35.770 --> 00:02:35.780
would do to implement this is import um
 

00:02:35.780 --> 00:02:42.500
would do to implement this is import um
numpy s and p and then you just call you

00:02:42.500 --> 00:02:42.510
numpy s and p and then you just call you
 

00:02:42.510 --> 00:02:47.420
numpy s and p and then you just call you
equals and p dot e to the B and so

00:02:47.420 --> 00:02:47.430
equals and p dot e to the B and so
 

00:02:47.430 --> 00:02:50.630
equals and p dot e to the B and so
notice that whereas previously you have

00:02:50.630 --> 00:02:50.640
notice that whereas previously you have
 

00:02:50.640 --> 00:02:53.180
notice that whereas previously you have
that explicit for loop with just one

00:02:53.180 --> 00:02:53.190
that explicit for loop with just one
 

00:02:53.190 --> 00:02:55.699
that explicit for loop with just one
line of code here on this V is an input

00:02:55.699 --> 00:02:55.709
line of code here on this V is an input
 

00:02:55.709 --> 00:02:58.970
line of code here on this V is an input
vector use an output vector you've

00:02:58.970 --> 00:02:58.980
vector use an output vector you've
 

00:02:58.980 --> 00:03:01.130
vector use an output vector you've
gotten rid of the explicit for loop and

00:03:01.130 --> 00:03:01.140
gotten rid of the explicit for loop and
 

00:03:01.140 --> 00:03:02.810
gotten rid of the explicit for loop and
the implementation land rights will be

00:03:02.810 --> 00:03:02.820
the implementation land rights will be
 

00:03:02.820 --> 00:03:04.970
the implementation land rights will be
much faster than the one needing

00:03:04.970 --> 00:03:04.980
much faster than the one needing
 

00:03:04.980 --> 00:03:07.580
much faster than the one needing
explicit value inside the numpy library

00:03:07.580 --> 00:03:07.590
explicit value inside the numpy library
 

00:03:07.590 --> 00:03:10.460
explicit value inside the numpy library
as many other vector value function so

00:03:10.460 --> 00:03:10.470
as many other vector value function so
 

00:03:10.470 --> 00:03:14.090
as many other vector value function so
NP dot log of V will compute the element

00:03:14.090 --> 00:03:14.100
NP dot log of V will compute the element
 

00:03:14.100 --> 00:03:18.289
NP dot log of V will compute the element
wise log n peeves computes the absolute

00:03:18.289 --> 00:03:18.299
wise log n peeves computes the absolute
 

00:03:18.299 --> 00:03:24.050
wise log n peeves computes the absolute
value MP dot maximum confuse the element

00:03:24.050 --> 00:03:24.060
value MP dot maximum confuse the element
 

00:03:24.060 --> 00:03:25.850
value MP dot maximum confuse the element
wise maximum so you take the max of

00:03:25.850 --> 00:03:25.860
wise maximum so you take the max of
 

00:03:25.860 --> 00:03:30.289
wise maximum so you take the max of
every element of B what's zero these

00:03:30.289 --> 00:03:30.299
every element of B what's zero these
 

00:03:30.299 --> 00:03:33.610
every element of B what's zero these
last are two this takes the element wise

00:03:33.610 --> 00:03:33.620
last are two this takes the element wise
 

00:03:33.620 --> 00:03:38.270
last are two this takes the element wise
square of each element of V you know 1

00:03:38.270 --> 00:03:38.280
square of each element of V you know 1
 

00:03:38.280 --> 00:03:41.210
square of each element of V you know 1
over V takes the element wise inverse

00:03:41.210 --> 00:03:41.220
over V takes the element wise inverse
 

00:03:41.220 --> 00:03:44.270
over V takes the element wise inverse
and so on so whenever you attempted to

00:03:44.270 --> 00:03:44.280
and so on so whenever you attempted to
 

00:03:44.280 --> 00:03:47.060
and so on so whenever you attempted to
write a for loop take a look and see if

00:03:47.060 --> 00:03:47.070
write a for loop take a look and see if
 

00:03:47.070 --> 00:03:49.759
write a for loop take a look and see if
there's a way to call a non PI built-in

00:03:49.759 --> 00:03:49.769
there's a way to call a non PI built-in
 

00:03:49.769 --> 00:03:52.240
there's a way to call a non PI built-in
function to do it without that for loop

00:03:52.240 --> 00:03:52.250
function to do it without that for loop
 

00:03:52.250 --> 00:03:54.830
function to do it without that for loop
so let's take all of these learnings and

00:03:54.830 --> 00:03:54.840
so let's take all of these learnings and
 

00:03:54.840 --> 00:03:56.680
so let's take all of these learnings and
apply it to our logistic regression

00:03:56.680 --> 00:03:56.690
apply it to our logistic regression
 

00:03:56.690 --> 00:03:59.600
apply it to our logistic regression
gradient descent implementation and see

00:03:59.600 --> 00:03:59.610
gradient descent implementation and see
 

00:03:59.610 --> 00:04:01.190
gradient descent implementation and see
if we can at least get rid of one of the

00:04:01.190 --> 00:04:01.200
if we can at least get rid of one of the
 

00:04:01.200 --> 00:04:03.979
if we can at least get rid of one of the
two folders we had so here's our code

00:04:03.979 --> 00:04:03.989
two folders we had so here's our code
 

00:04:03.989 --> 00:04:06.440
two folders we had so here's our code
for computing the derivatives for

00:04:06.440 --> 00:04:06.450
for computing the derivatives for
 

00:04:06.450 --> 00:04:08.810
for computing the derivatives for
logistic regression and we had two for

00:04:08.810 --> 00:04:08.820
logistic regression and we had two for
 

00:04:08.820 --> 00:04:11.210
logistic regression and we had two for
loops one was this one up here and the

00:04:11.210 --> 00:04:11.220
loops one was this one up here and the
 

00:04:11.220 --> 00:04:13.720
loops one was this one up here and the
second one was this one right so in our

00:04:13.720 --> 00:04:13.730
second one was this one right so in our
 

00:04:13.730 --> 00:04:16.680
second one was this one right so in our
example we had N and

00:04:16.680 --> 00:04:16.690
example we had N and
 

00:04:16.690 --> 00:04:19.650
example we had N and
equals two but if you had more features

00:04:19.650 --> 00:04:19.660
equals two but if you had more features
 

00:04:19.660 --> 00:04:21.570
equals two but if you had more features
than just two features then you need to

00:04:21.570 --> 00:04:21.580
than just two features then you need to
 

00:04:21.580 --> 00:04:24.960
than just two features then you need to
have a full group of a DW 1 DW 2 DW 3

00:04:24.960 --> 00:04:24.970
have a full group of a DW 1 DW 2 DW 3
 

00:04:24.970 --> 00:04:26.790
have a full group of a DW 1 DW 2 DW 3
and so on so it's as if this as you have

00:04:26.790 --> 00:04:26.800
and so on so it's as if this as you have
 

00:04:26.800 --> 00:04:34.070
and so on so it's as if this as you have
for J equals 1 to NX you know DW j pw j

00:04:34.070 --> 00:04:34.080
for J equals 1 to NX you know DW j pw j
 

00:04:34.080 --> 00:04:37.650
for J equals 1 to NX you know DW j pw j
you know gues updated all right so we

00:04:37.650 --> 00:04:37.660
you know gues updated all right so we
 

00:04:37.660 --> 00:04:41.250
you know gues updated all right so we
like to eliminate this second volume

00:04:41.250 --> 00:04:41.260
like to eliminate this second volume
 

00:04:41.260 --> 00:04:44.220
like to eliminate this second volume
that's what we'll do on the slide so the

00:04:44.220 --> 00:04:44.230
that's what we'll do on the slide so the
 

00:04:44.230 --> 00:04:46.050
that's what we'll do on the slide so the
way we'll do so is that instead of

00:04:46.050 --> 00:04:46.060
way we'll do so is that instead of
 

00:04:46.060 --> 00:04:50.040
way we'll do so is that instead of
explicitly initializing DW 1 DW 2 and so

00:04:50.040 --> 00:04:50.050
explicitly initializing DW 1 DW 2 and so
 

00:04:50.050 --> 00:04:53.460
explicitly initializing DW 1 DW 2 and so
on two zeros we're going to get rid of

00:04:53.460 --> 00:04:53.470
on two zeros we're going to get rid of
 

00:04:53.470 --> 00:04:58.200
on two zeros we're going to get rid of
this and instead make DW a vector so

00:04:58.200 --> 00:04:58.210
this and instead make DW a vector so
 

00:04:58.210 --> 00:05:02.760
this and instead make DW a vector so
we're going to set D W equals M MP dot

00:05:02.760 --> 00:05:02.770
we're going to set D W equals M MP dot
 

00:05:02.770 --> 00:05:07.980
we're going to set D W equals M MP dot
zeros and let's make those a on and X by

00:05:07.980 --> 00:05:07.990
zeros and let's make those a on and X by
 

00:05:07.990 --> 00:05:12.210
zeros and let's make those a on and X by
1 dimensional vector then here instead

00:05:12.210 --> 00:05:12.220
1 dimensional vector then here instead
 

00:05:12.220 --> 00:05:14.820
1 dimensional vector then here instead
of this you know for group over the

00:05:14.820 --> 00:05:14.830
of this you know for group over the
 

00:05:14.830 --> 00:05:16.680
of this you know for group over the
individual components we just use this

00:05:16.680 --> 00:05:16.690
individual components we just use this
 

00:05:16.690 --> 00:05:23.310
individual components we just use this
vector valued operation DW plus equals x

00:05:23.310 --> 00:05:23.320
vector valued operation DW plus equals x
 

00:05:23.320 --> 00:05:31.140
vector valued operation DW plus equals x
I times DZ I and then finally instead of

00:05:31.140 --> 00:05:31.150
I times DZ I and then finally instead of
 

00:05:31.150 --> 00:05:36.540
I times DZ I and then finally instead of
this we will just have DW on device

00:05:36.540 --> 00:05:36.550
this we will just have DW on device
 

00:05:36.550 --> 00:05:40.230
this we will just have DW on device
equals M so now we've gone from having

00:05:40.230 --> 00:05:40.240
equals M so now we've gone from having
 

00:05:40.240 --> 00:05:42.630
equals M so now we've gone from having
two for loops to just one folder we

00:05:42.630 --> 00:05:42.640
two for loops to just one folder we
 

00:05:42.640 --> 00:05:44.970
two for loops to just one folder we
still have this one for loop that loops

00:05:44.970 --> 00:05:44.980
still have this one for loop that loops
 

00:05:44.980 --> 00:05:49.230
still have this one for loop that loops
over the individual training examples so

00:05:49.230 --> 00:05:49.240
over the individual training examples so
 

00:05:49.240 --> 00:05:51.000
over the individual training examples so
I hope this video gave you a sense of

00:05:51.000 --> 00:05:51.010
I hope this video gave you a sense of
 

00:05:51.010 --> 00:05:53.670
I hope this video gave you a sense of
vectorization and by getting rid of one

00:05:53.670 --> 00:05:53.680
vectorization and by getting rid of one
 

00:05:53.680 --> 00:05:55.470
vectorization and by getting rid of one
full loop your code will already run

00:05:55.470 --> 00:05:55.480
full loop your code will already run
 

00:05:55.480 --> 00:05:57.840
full loop your code will already run
faster but it turns out we could do even

00:05:57.840 --> 00:05:57.850
faster but it turns out we could do even
 

00:05:57.850 --> 00:05:59.970
faster but it turns out we could do even
better so the next video will talk about

00:05:59.970 --> 00:05:59.980
better so the next video will talk about
 

00:05:59.980 --> 00:06:02.460
better so the next video will talk about
how to decorate justic regression even

00:06:02.460 --> 00:06:02.470
how to decorate justic regression even
 

00:06:02.470 --> 00:06:04.380
how to decorate justic regression even
further and you see a pretty surprising

00:06:04.380 --> 00:06:04.390
further and you see a pretty surprising
 

00:06:04.390 --> 00:06:07.170
further and you see a pretty surprising
result that without using any full loops

00:06:07.170 --> 00:06:07.180
result that without using any full loops
 

00:06:07.180 --> 00:06:08.820
result that without using any full loops
without needing for loop over the

00:06:08.820 --> 00:06:08.830
without needing for loop over the
 

00:06:08.830 --> 00:06:12.030
without needing for loop over the
training examples you could write code

00:06:12.030 --> 00:06:12.040
training examples you could write code
 

00:06:12.040 --> 00:06:14.820
training examples you could write code
to process the entire training set so

00:06:14.820 --> 00:06:14.830
to process the entire training set so
 

00:06:14.830 --> 00:06:17.220
to process the entire training set so
pretty much all at the same time so

00:06:17.220 --> 00:06:17.230
pretty much all at the same time so
 

00:06:17.230 --> 00:06:20.790
pretty much all at the same time so
let's see that in the next video

