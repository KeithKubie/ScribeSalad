WEBVTT
Kind: captions
Language: en

00:00:00.040 --> 00:00:03.520
How many computers in here do you think we've got multiple processors in?

00:00:03.760 --> 00:00:11.500
Ok, um, yeah, I don't think any of them have got multiple processors in the way that I would think of multiple processors

00:00:11.660 --> 00:00:15.780
My edit machine has two Intel processors in it, physical chips

00:00:16.000 --> 00:00:20.860
Ok, so you define a multiprocessor system as having two physical chips?

00:00:21.060 --> 00:00:22.240
That's what I'm thinking.

00:00:22.340 --> 00:00:26.700
Okay, or we could also take multiple cores. Where it's the same thing on the same pieces of the silicon.

00:00:29.320 --> 00:00:37.980
Okay, so you've got two physical chips being two physical processors which machine or multiple cores which machines in here do you think are multiprocessor?

00:00:38.100 --> 00:00:41.260
We'll just use that term to refer to both of them systems.

00:00:41.260 --> 00:00:45.420
Okay. Well, I reckon these new Macs here have got multiple cores.

00:00:45.580 --> 00:00:49.140
Yup, they're all quad core machines of various types

00:00:49.420 --> 00:00:51.540
Your phone maybe? 
Yeah the phone will

00:00:51.660 --> 00:00:53.960
but you've got all these vintage machines around

00:00:53.969 --> 00:01:01.259
So starting over here with the apple macintosh LC 475. Well, let's just say I said, you've got one processor in it. There's also a

00:01:01.989 --> 00:01:05.999
PowerPC laptop under there underneath the surface underneath the multi processor motherboard

00:01:06.010 --> 00:01:09.689
So the surface is real depressed is just sitting under there the Atari ST

00:01:10.060 --> 00:01:14.640
That one we could count this as we'll say it isn't why? Could we count it out?

00:01:15.460 --> 00:01:21.689
Because the keyboard has got a CPU in it. Okay. Yeah, I've got an intelligent keyboard. So the CPUs got a

00:01:22.840 --> 00:01:27.479
microcontroller in there which scans the keyboard and then sends over a serial link the key presses to

00:01:27.940 --> 00:01:34.560
The main CPU and so on so so proprietor in there. I've got the Atari Falcon under here how many processors?

00:01:35.820 --> 00:01:41.000
I'm guessing that there's a trick here. So I'm going for two. Yes got two processors in it. It's got a

00:01:41.580 --> 00:01:47.040
68030 cpu and it's also got a five six zero zero one DSP both motorola

00:01:47.770 --> 00:01:52.439
Processors in that don't think any of that acorn stuff which are now relatively. Well. Yep

00:01:52.439 --> 00:01:57.059
So they're all single processor systems. Although the risk PC did have two prices of slots

00:01:57.060 --> 00:02:03.240
So it could have read a separate 486 put in there and let's say managed to get hold of the one existing Hydra card in

00:02:04.210 --> 00:02:07.979
Enable you to have multiple ARM chip so that single processor their original IBM PC

00:02:08.709 --> 00:02:14.639
Single processor BBC micro I think if that's a special one then possibly but if just under one man, no

00:02:14.640 --> 00:02:18.720
So that is a special one. That's actually got what a Concord they're tube system

00:02:19.810 --> 00:02:22.679
Which if you watch the videos on Steve Furber?

00:02:23.620 --> 00:02:30.060
Talks more about this, but they initially released the second processor not Co prices over the second processor for the system

00:02:30.060 --> 00:02:35.640
Which was a complete another computer inside there with a 6502 Ram and so on in their 64k of Ram

00:02:35.920 --> 00:02:39.660
Showed that old it was and that was then connected to the BBC micro which had its

00:02:40.360 --> 00:02:44.279
32k of RAM and its 6502 on there the master turbo

00:02:44.280 --> 00:02:51.869
I've got over there has that built into the motherboard and so that's technically a multiprocessor system. It's got two CPUs in there

00:02:51.870 --> 00:02:53.870
She's got two CPUs at the same time

00:02:54.010 --> 00:03:00.480
Running a slightly different speeds but to CPS at the same time Apple to single processor the acorn and the Amiga and the Atari

00:03:01.090 --> 00:03:06.750
Again, the Amiga I think you could possibly make an argument. It was a multiprocessor system, but not in the way

00:03:06.820 --> 00:03:13.060
We're thinking about it. Why have we just done that? Well, it shows that there's there's two ways you can design a multiprocessor system

00:03:13.300 --> 00:03:18.840
So your system home your editing system the Macs on here. They have two processes.

00:03:19.480 --> 00:03:24.600
That are of the same design to Intel court or two core. Shall we say or

00:03:25.180 --> 00:03:27.180
multiple cores all of the same design

00:03:27.400 --> 00:03:32.459
And those purchases are identical and they use pretty much to do any of the tasks of things

00:03:32.590 --> 00:03:35.369
It's what we call a symmetric multiprocessor system

00:03:35.650 --> 00:03:40.290
So each CPU in there can be allocated by the operating system to run programs

00:03:40.290 --> 00:03:44.189
It can answer io and things and just do anything that you need to do. They can split the tasks up

00:03:45.010 --> 00:03:47.010
To do different things

00:03:47.200 --> 00:03:50.220
by comparison the Falcon and the

00:03:50.860 --> 00:03:53.100
BBC micro system the BBC master turbo

00:03:54.220 --> 00:03:57.809
They have multiple processes in them and you can use them for general purpose tests

00:03:58.120 --> 00:04:04.230
But the general idea is that their processes do different tasks. So it's an asymmetric multiprocessor system

00:04:04.450 --> 00:04:06.120
Say for example on the Falcon

00:04:06.120 --> 00:04:08.110
The idea was at the 68030

00:04:08.110 --> 00:04:13.259
would run you the main system whatever thing is doing and then he fueled you to do some sort of person that would benefit from

00:04:13.260 --> 00:04:16.049
The DSP chip the five six zero zero one that's in there

00:04:16.120 --> 00:04:21.269
You would offload your processing onto that feed the data and it would president it would feed the data back out

00:04:21.280 --> 00:04:23.280
So it's effectively running as a separate

00:04:23.919 --> 00:04:25.919
Subsystem and so on

00:04:26.240 --> 00:04:30.680
On the BBC micro system. The idea was since that you'd have the 6502 chip

00:04:31.169 --> 00:04:33.258
There's in there's normal running the IO

00:04:33.479 --> 00:04:37.788
Drawing things on the screen handling the keyboard and so on and then you'd have your main processor

00:04:37.789 --> 00:04:41.299
That would do most of the processing work and occasionally would tell the other processor

00:04:41.490 --> 00:04:46.099
to load a file into memory or to tell the other processor to do things so you can design a

00:04:46.650 --> 00:04:48.709
Multi-person system in two ways. You can either have it

00:04:48.710 --> 00:04:53.000
So all the CPUs are working on the same task and in that case

00:04:53.000 --> 00:04:56.089
They probably will all connect to the same piece of shared memory and they'd all

00:04:56.400 --> 00:04:59.810
work on the same task and they'd all talk to the same bit memory and

00:05:00.000 --> 00:05:06.859
Communicate along that or you can say now I'm gonna have different processes perhaps of different types different speeds doing different jobs

00:05:06.860 --> 00:05:10.580
So multiprocessor systems have been around for quite a while in various different guises

00:05:10.620 --> 00:05:17.989
There's a sort of suggestion here that the idea of parallel is the more modern way of doing it surely with things like GPUs

00:05:18.720 --> 00:05:26.720
Coming we've got hybrids now, right? Well, yeah. Well, yeah, but I mean the GPU is generally being used for a specific task

00:05:27.419 --> 00:05:34.369
things whether that's graphics processing or Bitcoin mining or whatever it is able to do on it and depending on whether you're wanting to make

00:05:34.370 --> 00:05:39.649
Money or lose money and I can let you work out which one of that is going to do which and surely we're using

00:05:39.930 --> 00:05:43.400
Multiple cores purely because we ran out of horsepower on single cores

00:05:44.880 --> 00:05:47.029
So one reason with 4 cores good question

00:05:47.460 --> 00:05:52.320
So the things you want to fight the problem run as fast as possible and you've got two ways to do that

00:05:52.640 --> 00:05:54.480
You can either make the computer run faster

00:05:54.840 --> 00:05:58.820
for example, speak fast you get more words per second and so on and you get it going and you get your computer doing more and more and

00:05:58.820 --> 00:06:02.509
More more and more more more more more more more faster and faster faster faster and faster,  the problem with

00:06:02.509 --> 00:06:07.249
Is that is you get to a point where you can't actually push the computer faster. There's a thing called the power wall

00:06:07.320 --> 00:06:10.700
That's the point where you can no longer dissipate the heat away from the CPU

00:06:10.940 --> 00:06:15.440
We actually hit that quite a while ago what you're able to reduce the voltages used on the chips

00:06:15.520 --> 00:06:20.880
which meant you could get a bit more and again, but a Platinum getting to the point now where the voltages are, so

00:06:21.870 --> 00:06:24.229
different is really logic zero and a logic one is so low that

00:06:24.419 --> 00:06:30.139
Actually, you could take it any lower you'd get a leakage between the transistors on the chip itself. And so it's not possible

00:06:30.719 --> 00:06:35.028
So you can push the speed in one way the other way you can make the problem

00:06:35.370 --> 00:06:37.940
Make the program run faster is to split it up into multiple chunks

00:06:39.310 --> 00:06:40.790
To do them all at the same time

00:06:40.790 --> 00:06:48.159
so one way for example to make sandwiches faster is that you butter the bread faster you put the filling in faster you put the

00:06:48.160 --> 00:06:50.499
Bread faster the other person if you get two people doing it

00:06:50.500 --> 00:06:54.160
And then it takes in the same amount of time to make one summary's but you have two people doing it

00:06:54.160 --> 00:06:57.639
So they make twice as many sandwiches each time. They make a sandwich same with the computer

00:06:57.640 --> 00:06:59.740
we can either make the computer processor faster or

00:07:00.140 --> 00:07:07.240
We can have multiple cores each working on part of the problem at the same speed and then we have them produce the problem

00:07:07.610 --> 00:07:10.210
Produce the result faster to do that

00:07:10.210 --> 00:07:15.070
We need to be able to break the problem down into multiple chunks and x:q each of those chunks separately

00:07:15.110 --> 00:07:20.560
Which is one problem you need to work out and can you break the problem down can be quite simple if you will say

00:07:21.530 --> 00:07:25.179
Processing an image you want to say make it 50% the brightness

00:07:25.490 --> 00:07:29.410
Then you can process the top half process the bottom half separately do them at the same time

00:07:29.410 --> 00:07:32.949
You have the time it takes to process the whole image

00:07:32.950 --> 00:07:37.780
But the tasks are harder to break down because you need to work out how you want to break down the algorithm to run over

00:07:37.780 --> 00:07:39.680
different things asymmetric and symmetric

00:07:39.680 --> 00:07:43.120
Multiprocessors aren't really competing for each other. It's not this is how we used to do it

00:07:43.120 --> 00:07:44.210
This is how we do it now

00:07:44.210 --> 00:07:47.259
You would find that there are multi person systems back in the 80s and 90s

00:07:47.450 --> 00:07:50.290
Parallel processing was a big thing in the late 80s early 90s

00:07:51.290 --> 00:07:54.279
People were looking at parallel architectures for doing all sorts of things

00:07:54.560 --> 00:08:01.690
In fact, one of the things which describes how parallel systems work Flynn's taxonomy was created in 1966. So

00:08:02.390 --> 00:08:04.900
The ideas have been around for a while

00:08:04.900 --> 00:08:10.150
I think it's more that for a lot of things when you you've got a task that you want to do in different things

00:08:10.580 --> 00:08:13.150
symmetric multiprocessing makes sense for other things

00:08:13.700 --> 00:08:15.160
having an asymmetric system

00:08:15.160 --> 00:08:22.809
Whether that's your DSP IO processor a GPU a tensorflow type thing and so on makes more sense like that

00:08:22.810 --> 00:08:28.209
So how we design a multiprocessor system is very much based on what you're wanting to do

00:08:28.210 --> 00:08:33.220
What are you trying to do with it? I mean Flynn's taxonomy is an interesting thing because you then get some really weird

00:08:34.070 --> 00:08:36.280
processor types coming up so you can either have a

00:08:37.100 --> 00:08:40.749
system which has got a single instruction stream or

00:08:41.450 --> 00:08:48.819
Multiple instruction streams and a single data stream or you can have multiple data streams

00:08:48.830 --> 00:08:55.209
So you'll end up with a single instruction stream single data system or most multiple destruction streams single data system single instruction

00:08:56.000 --> 00:08:58.479
multiple data system or multiple instruction stream

00:08:59.029 --> 00:09:03.549
Multiple data systems so a modern multi-core CPU. Well actually at times

00:09:04.100 --> 00:09:08.439
behave like a single instruction stream system at times behave like a

00:09:08.870 --> 00:09:12.579
SIMD single instruction stream multiple data stream system and

00:09:13.040 --> 00:09:15.909
At times behave like a multiple instruction stream

00:09:16.069 --> 00:09:19.599
Multiple data system and we end up with these all being used at different times

00:09:19.600 --> 00:09:22.719
The easiest way I think about it as a single instruction stream

00:09:23.000 --> 00:09:27.219
Single data stream price is that that's the sort of classic model of a processor

00:09:27.220 --> 00:09:30.550
you've got a set of instructions that your program is executing and

00:09:30.920 --> 00:09:36.939
You could think of these flowing through the CPU one after the other okay with the occasional branches

00:09:37.129 --> 00:09:41.619
Like water flowing through a stream if you look at one point the water flows through at that point

00:09:41.620 --> 00:09:43.929
That's what these two options are doing. They're flowing through the CPU

00:09:44.269 --> 00:09:50.138
And each of those instructions is probably going to be loading a value from memory or doing some processing on the value

00:09:50.139 --> 00:09:55.839
That's come from memory and then putting it back out to memory. So if we say you I don't know. Let's say it's rendering

00:09:56.420 --> 00:09:59.500
3d graphics you're going to be doing lots of matrix

00:09:59.689 --> 00:10:03.039
multiplications and things on that that you can then pull the data in do the

00:10:03.110 --> 00:10:11.019
Calculations and write out the new points and so on now what Intel did around who late 90s they introduced what's called the multimedia extensions

00:10:11.240 --> 00:10:13.240
MMX and that was followed by

00:10:14.059 --> 00:10:15.500
sse sse2

00:10:15.500 --> 00:10:22.599
AMD's 3d now and those other things that do different things which basically add one Accord single instruction multiple data instructions

00:10:23.089 --> 00:10:28.119
So these instructions are still a single stream of instructions that so we're going to add something. We're going to multiply something

00:10:28.850 --> 00:10:31.269
But rather just acting on one piece of data at a time

00:10:32.149 --> 00:10:36.818
They can act on multiple pieces of data and if you think back to that 3d graphics

00:10:37.129 --> 00:10:40.959
You for example will have your X Y Z coordinates for

00:10:42.800 --> 00:10:48.789
Say your shape and you normally actually store that as four coordinates because you have the x y&amp;z and then you have a

00:10:49.220 --> 00:10:53.829
1 in the vetch because it makes the map slightly simpler. And so you might actually then call that

00:10:54.410 --> 00:11:01.300
You need to multiply that by a matrices and with us SIMD type instruction. You can read those four values and

00:11:01.910 --> 00:11:04.839
Read the four values from one column of your matrix

00:11:05.660 --> 00:11:09.139
And multiply them all together, which is four separate operations

00:11:09.570 --> 00:11:15.499
But if you can use an SIMD instruction, you can do that in one operation working on four separate bits of data

00:11:15.500 --> 00:11:22.640
So it multiplies the first player together the second pair together the third player together and the four pair together all in one instruction

00:11:22.800 --> 00:11:27.590
so they added extra bits new al use new designs for doing things that and they will them to have

00:11:27.930 --> 00:11:32.359
These instructions if your data restricts the data, your pricing is such that you can take advantage of that

00:11:32.360 --> 00:11:37.039
you can get some significant speed boost because rather than doing four instructions you have to do one and

00:11:37.530 --> 00:11:43.759
but you take advantage of what's called data level parallelism the data the pricing you want to do enables you to

00:11:44.280 --> 00:11:49.549
Do those instructions on multiple data options at the same time and you get some sort of speed-up

00:11:49.550 --> 00:11:56.780
It works for some tasks 3d graphics. For example, for other tasks. It's less useful and so you don't benefit from them

00:11:57.630 --> 00:12:03.619
but the other thing our CPUs can do is that they have a multiple cores and modern CPUs the intel i7

00:12:04.260 --> 00:12:05.910
AMD's and so on

00:12:05.910 --> 00:12:07.910
are all

00:12:08.100 --> 00:12:14.450
Multiple instruction multiple data things so they have separate calls each of richer running their own stream of instructions

00:12:14.450 --> 00:12:17.330
So they're on different bits of the program or different programs altogether

00:12:17.940 --> 00:12:23.150
processing different bits of data still a single stream per processor instance

00:12:23.150 --> 00:12:26.359
But unless it's an SIMD bit and so you can have multiple data streams

00:12:26.360 --> 00:12:26.730
and

00:12:26.730 --> 00:12:27.870
So you have them?

00:12:27.870 --> 00:12:34.640
Running all of these things and that is pretty much what people think of as parallel processing multi processing of things is you've got multiple

00:12:34.830 --> 00:12:38.900
CPU cores running their own programs processing their own set of data

00:12:39.630 --> 00:12:41.689
So we can build up different things

00:12:41.690 --> 00:12:49.280
So they've been around for years and we've had various different types symmetric asymmetric the different ones of Flynn's Tessa Nanami you've been around

00:12:49.440 --> 00:12:55.309
For a while that leaves us with this weird one in the top right corner of the diagram, which is the multiple instruction stream

00:12:55.310 --> 00:12:57.310
So got multiple streams of instructions

00:12:57.810 --> 00:12:59.810
acting on a single data stream

00:13:00.300 --> 00:13:02.780
Yeah, they're weird. Not many of them exist these days

00:13:02.780 --> 00:13:08.329
I think the most prominent example that I've heard of I've never actually had to program it more's the pity is

00:13:08.700 --> 00:13:10.729
the space shuttle guidance computer

00:13:15.619 --> 00:13:22.329
Left our flowers probably the Space Shuttle guidance computer used a multiple instruction stream single data stream machine

00:13:22.329 --> 00:13:25.358
And that's one of the reasons you might want to do that. Is that enables you to say do?

00:13:25.819 --> 00:13:32.738
Multiple calculations and then get some sort of fault tolerance, perhaps out of it touchdown so you can build parallel processing in different ways

00:13:33.019 --> 00:13:35.888
but the one that we're perhaps most familiar with is that we've got

00:13:36.139 --> 00:13:41.408
multiple of CPUs in our computer whether they're physical chips physical cores as it happens to be all their

00:13:41.809 --> 00:13:47.649
Multiple cores on the same piece of silicon and if we're doing that we need to make those

00:13:48.049 --> 00:13:55.389
Multiple processors do useful things. So the simplest thing we could do is get the operating system to schedule multiple

00:13:55.909 --> 00:14:03.099
Programs multiple processes across each of the different CPUs, but that enables had to run multiple programs really good

00:14:03.099 --> 00:14:05.829
but it doesn't really give us any speed-up in terms of

00:14:06.199 --> 00:14:09.728
Running a single program to solve a single task and to do that

00:14:09.729 --> 00:14:13.269
we actually need to break the problem down into multiple chunks and

00:14:13.759 --> 00:14:19.718
Execute a chunk of each of that problem on each of the different processes. We've got available to us. Whether that's 2 4 6 8

00:14:20.509 --> 00:14:22.279
32

00:14:22.279 --> 00:14:25.898
However many we've actually got to deal with so we need to break our problem down

00:14:26.329 --> 00:14:31.209
Into multiple what often refer to with threads of execution and run them on different?

00:14:31.849 --> 00:14:33.829
CPU cores

00:14:33.829 --> 00:14:39.668
Is that same a1 so that he can decrypt the message and read it? Right? So Alice maybe wants to send another one

00:14:39.669 --> 00:14:41.889
So she's going to tick this KDF function again

00:14:41.889 --> 00:14:46.178
She's going to produce a new key and a2 I she's going to send that to Bob

00:14:46.179 --> 00:14:50.769
He's going to take this receiving function a2 now. Bob wants to send a message. So he's going to tick

