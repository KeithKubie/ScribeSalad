WEBVTT
Kind: captions
Language: en

00:00:00.340 --> 00:00:01.570
CHRIS ELLIOTT: --on to the
next talk on the Cloud

00:00:01.570 --> 00:00:02.670
Platform track.

00:00:02.670 --> 00:00:05.100
This is actually an amazing
turnout considering the Glass

00:00:05.100 --> 00:00:08.029
Dev section is right
across the street.

00:00:08.029 --> 00:00:09.960
When I found out I was scheduled
to go right against

00:00:09.960 --> 00:00:12.520
the Glass sessions, I was
planning to turn into a small

00:00:12.520 --> 00:00:15.100
fireside chat with a few
people, but this

00:00:15.100 --> 00:00:17.310
turnout blew me away.

00:00:17.310 --> 00:00:19.520
But we have quite a good session
in here planned up in

00:00:19.520 --> 00:00:21.300
line for you, so please
don't leave.

00:00:21.300 --> 00:00:23.190
I'm glad nobody got up
and ran to the back.

00:00:23.190 --> 00:00:24.710
Oh, the Glass session's
happening now?

00:00:28.200 --> 00:00:31.330
So without any further ado,
let's get this started.

00:00:31.330 --> 00:00:33.670
I remember being a game
developer many years ago, and

00:00:33.670 --> 00:00:35.660
I was thinking about
this recently.

00:00:35.660 --> 00:00:37.520
And it was really funny because
the hardest thing for

00:00:37.520 --> 00:00:41.420
me to find was dedicated game
servers to run my game engine

00:00:41.420 --> 00:00:42.960
and test with players.

00:00:42.960 --> 00:00:45.880
I would be trolling IRC at late
hours of the night, just

00:00:45.880 --> 00:00:48.350
trying to find somebody willing
to host my game and

00:00:48.350 --> 00:00:50.900
get 32 friends on it to
really stress test it.

00:00:50.900 --> 00:00:52.710
It was extremely hard to find.

00:00:52.710 --> 00:00:54.400
And it's interesting
today that that

00:00:54.400 --> 00:00:55.750
is no longer a problem.

00:00:55.750 --> 00:00:58.430
You have a vast amount of
computing resources available

00:00:58.430 --> 00:01:00.920
for building out amazing games,
and now the challenge

00:01:00.920 --> 00:01:03.830
is really, how do you create
those games and create them in

00:01:03.830 --> 00:01:06.040
a way that's really going to
scale as the number of users

00:01:06.040 --> 00:01:07.440
playing your game scales?

00:01:07.440 --> 00:01:10.020
And at the end of the day, it
really comes down to building

00:01:10.020 --> 00:01:12.530
in a way that when your game
becomes an unexpected

00:01:12.530 --> 00:01:15.110
success-- there's just massive
growth, 20 fold

00:01:15.110 --> 00:01:15.970
over what you expected--

00:01:15.970 --> 00:01:18.960
that you can survive that
onslaught scale and make sure

00:01:18.960 --> 00:01:21.050
everyone can get in and have a
really great experience on

00:01:21.050 --> 00:01:21.880
your platform.

00:01:21.880 --> 00:01:23.520
And that's really what we're
talking about with this

00:01:23.520 --> 00:01:25.500
session is how to make
that possible on the

00:01:25.500 --> 00:01:27.620
Google Cloud Platform.

00:01:27.620 --> 00:01:30.800
So the game plan starts off with
a very high level Compute

00:01:30.800 --> 00:01:33.280
Engine and App Engine and
Google Cloud Platform

00:01:33.280 --> 00:01:35.280
overview, just highlighting
the fundamental building

00:01:35.280 --> 00:01:37.950
blocks that we'll be working
with throughout the session.

00:01:37.950 --> 00:01:40.650
Up next is looking at mobile
gaming architecture that

00:01:40.650 --> 00:01:43.120
really shows you how all these
pieces fit together to solve a

00:01:43.120 --> 00:01:45.360
lot of common problems mobile
developers face when they're

00:01:45.360 --> 00:01:46.540
building out games.

00:01:46.540 --> 00:01:48.920
And then up next, what better
than to hear it from people

00:01:48.920 --> 00:01:50.330
who have done this themselves
and scaled

00:01:50.330 --> 00:01:51.950
to a huge user base?

00:01:51.950 --> 00:01:54.490
And so some great guys from
FreshPlanet are going to come

00:01:54.490 --> 00:01:56.610
up and talk about how they used
this platform to power

00:01:56.610 --> 00:01:59.900
their game "SongPop." And then
finally, wrapping it up with a

00:01:59.900 --> 00:02:02.600
dedicated game server that
really targets the real time

00:02:02.600 --> 00:02:04.850
gaming where you need tens of
thousands of virtual machines

00:02:04.850 --> 00:02:06.270
running all of your
game servers.

00:02:06.270 --> 00:02:07.490
So that's really what
we have in store

00:02:07.490 --> 00:02:10.050
over the next 45 minutes.

00:02:10.050 --> 00:02:12.910
So many of you have probably
seen this slide if you

00:02:12.910 --> 00:02:15.960
attended the Cloud Platform
keynote, and it really

00:02:15.960 --> 00:02:18.610
highlights all of the amazing
technology we've exposed.

00:02:18.610 --> 00:02:21.020
And really, it's amazing
how you connect it.

00:02:21.020 --> 00:02:22.830
But as a developer, the biggest
challenge is, what do

00:02:22.830 --> 00:02:23.810
I need to know here?

00:02:23.810 --> 00:02:24.810
What is relevant?

00:02:24.810 --> 00:02:26.280
How do all the pieces
connect together?

00:02:26.280 --> 00:02:28.710
And furthermore, how do I
augment all these other Google

00:02:28.710 --> 00:02:30.530
services, such as the
Play Games that

00:02:30.530 --> 00:02:31.890
was announced yesterday?

00:02:31.890 --> 00:02:33.870
What value can that
bring to my app?

00:02:33.870 --> 00:02:36.700
So what's really interesting and
what continues to blow me

00:02:36.700 --> 00:02:39.340
away is just the scale of the
Google Cloud Platform.

00:02:39.340 --> 00:02:41.110
We announced that we have over
three million active

00:02:41.110 --> 00:02:43.950
applications yesterday
and over 300,000

00:02:43.950 --> 00:02:45.320
developers every month.

00:02:45.320 --> 00:02:49.260
And just every day, we seem to
run into really amazing game

00:02:49.260 --> 00:02:52.130
studios pushing the limits of
the technology in creating

00:02:52.130 --> 00:02:54.500
these next generation
gaming experiences.

00:02:54.500 --> 00:02:57.310
So this is just a sample of
the game studios that are

00:02:57.310 --> 00:02:58.200
building on the platform.

00:02:58.200 --> 00:03:00.730
And what's really interesting,
it's a huge spectrum.

00:03:00.730 --> 00:03:02.840
You're looking at AAA Studios
all the way down to small

00:03:02.840 --> 00:03:04.730
indie studios, and they're all
leveraging the platform to

00:03:04.730 --> 00:03:07.780
deliver these next generation
experiences.

00:03:07.780 --> 00:03:10.770
And what's even cooler is
it's not just one game.

00:03:10.770 --> 00:03:13.380
They really get hooked on App
Engine, and it becomes a way

00:03:13.380 --> 00:03:14.290
of building out their games.

00:03:14.290 --> 00:03:16.110
They understand the platform,
they know how to scale on

00:03:16.110 --> 00:03:18.450
Google, and they trust Google
to scale based on past

00:03:18.450 --> 00:03:19.650
experiences they've had.

00:03:19.650 --> 00:03:22.300
For example, EA Games has
launched over five games on

00:03:22.300 --> 00:03:24.710
the platform from "Tetris"
to "The Simpsons Game" to

00:03:24.710 --> 00:03:27.840
"Yahtzee." You don't even
realize what's powering these

00:03:27.840 --> 00:03:31.090
games because it just scales
seamlessly as these games take

00:03:31.090 --> 00:03:33.290
off and you see all of your
friends playing them.

00:03:33.290 --> 00:03:37.160
And another one that really blew
me away was Epic Games.

00:03:37.160 --> 00:03:40.250
I had no idea "Infinity Blade
2," the compelling social

00:03:40.250 --> 00:03:42.180
features were all powered
by App Engine--

00:03:42.180 --> 00:03:44.650
no idea until I was talking to
them at GDC and they mentioned

00:03:44.650 --> 00:03:46.530
this, and it's just absolutely
amazing.

00:03:46.530 --> 00:03:49.000
And what blew away the most
about this example was the

00:03:49.000 --> 00:03:52.210
fact that it was done by mostly
one guy in six weeks.

00:03:52.210 --> 00:03:54.170
Could you imagine having to
build out the back end for

00:03:54.170 --> 00:03:54.995
"Infinity Blade 2"?

00:03:54.995 --> 00:03:57.600
You have six weeks, you're one
guy, and you know that tens of

00:03:57.600 --> 00:03:59.780
millions of people are going
to download this game.

00:03:59.780 --> 00:04:02.100
That's pressure, and that's
really when they turned to App

00:04:02.100 --> 00:04:04.530
Engine because they know and
trust it to scale and deliver

00:04:04.530 --> 00:04:06.230
and allow them to really
launch and

00:04:06.230 --> 00:04:08.840
have a great success.

00:04:08.840 --> 00:04:09.670
They also used it for "Vote!!

00:04:09.670 --> 00:04:10.660
The Game" as well.

00:04:10.660 --> 00:04:13.760
That was a very timely piece,
but it was also pretty cool.

00:04:13.760 --> 00:04:16.380
Check it out as well for
"Infinity Blade" meets

00:04:16.380 --> 00:04:18.910
election politics.

00:04:18.910 --> 00:04:21.790
And looking at the core
fundamental aspects of

00:04:21.790 --> 00:04:23.620
building on the Google
Cloud Platform,

00:04:23.620 --> 00:04:24.960
first one is App Engine.

00:04:24.960 --> 00:04:26.100
Most people know what this is.

00:04:26.100 --> 00:04:28.430
It's been around for five or six
years, and really that is

00:04:28.430 --> 00:04:30.920
the Platform as a Service that's
easy to build, easy to

00:04:30.920 --> 00:04:32.930
deliver, easy to deploy, and
easy to maintain your

00:04:32.930 --> 00:04:33.810
application.

00:04:33.810 --> 00:04:37.040
You write it in a language of
your choice that's provided,

00:04:37.040 --> 00:04:39.260
and then you can use this
platform to really scale up

00:04:39.260 --> 00:04:41.360
with respect to your
user base.

00:04:41.360 --> 00:04:43.620
Another real, foundation
building block of gaming

00:04:43.620 --> 00:04:45.740
solutions is Compute Engine.

00:04:45.740 --> 00:04:48.960
It's looking at that scenario
where you need your own open

00:04:48.960 --> 00:04:52.140
and flexible platform to run
any code, any packages, any

00:04:52.140 --> 00:04:55.510
software, to run your custom
game engine, to run some large

00:04:55.510 --> 00:04:56.420
game engines.

00:04:56.420 --> 00:04:58.990
If you want to run NoJS, it
provides that flexibility.

00:04:58.990 --> 00:05:00.940
And I'm going to touch a little
bit on really what

00:05:00.940 --> 00:05:03.600
we've seen Compute Engine being
great for for developers

00:05:03.600 --> 00:05:05.910
and what kind of experiences
they've been having on the

00:05:05.910 --> 00:05:08.340
platform with Compute
Engine specifically.

00:05:08.340 --> 00:05:11.460
And time and time again, it is
the consistent performance and

00:05:11.460 --> 00:05:13.440
the amazing network that has
blown developers away and

00:05:13.440 --> 00:05:16.390
pushed their imagination of
what's actually possible on

00:05:16.390 --> 00:05:18.360
Cloud Platforms.

00:05:18.360 --> 00:05:19.590
Here's just one of them.

00:05:19.590 --> 00:05:20.780
Actually, Ed's in the
audience right now.

00:05:20.780 --> 00:05:22.670
You can talk to him more about
this, that I didn't just make

00:05:22.670 --> 00:05:23.470
this quote up.

00:05:23.470 --> 00:05:25.550
So Chrome JAM, you may have
heard about this.

00:05:25.550 --> 00:05:29.000
It was a project that was
basically you log in, jam out

00:05:29.000 --> 00:05:30.910
with four friends, real time
audio streaming, and it had

00:05:30.910 --> 00:05:33.910
extremely tight latency
requirements.

00:05:33.910 --> 00:05:35.760
And it wasn't even possible
on some of the other cloud

00:05:35.760 --> 00:05:38.070
platforms, but it was possible
on Compute Engine.

00:05:38.070 --> 00:05:40.570
So when I got this quote that
your latency's crazy low, pat

00:05:40.570 --> 00:05:42.900
the team on the back, definitely
fired it off to the

00:05:42.900 --> 00:05:43.560
networking team.

00:05:43.560 --> 00:05:45.470
And they love seeing feedback
like this because it really

00:05:45.470 --> 00:05:48.030
justifies all the hard work we
put into the technology over

00:05:48.030 --> 00:05:50.980
the many, many years.

00:05:50.980 --> 00:05:54.340
Also, you may have seen this
MapR Terasort World Record.

00:05:54.340 --> 00:05:55.930
The MapR broke the
Terasort World

00:05:55.930 --> 00:05:57.450
Record on Compute Engine.

00:05:57.450 --> 00:05:58.210
Amazing.

00:05:58.210 --> 00:06:00.590
What's really cool about this
for game developers is the

00:06:00.590 --> 00:06:03.300
fact that they broke it in a
cloud-based environment, and

00:06:03.300 --> 00:06:05.840
the past record was held by
dedicated hardware in their

00:06:05.840 --> 00:06:06.920
own data center.

00:06:06.920 --> 00:06:09.790
So this really challenges the
expectations as a developer if

00:06:09.790 --> 00:06:10.880
you're building out a game.

00:06:10.880 --> 00:06:12.980
OK, I need 1,000 servers in the
East Coast to support my

00:06:12.980 --> 00:06:15.050
traffic there, 1,000
in Europe.

00:06:15.050 --> 00:06:17.640
You can really now leverage the
Cloud Platform and start

00:06:17.640 --> 00:06:19.270
to scale up where your
user base is.

00:06:19.270 --> 00:06:21.280
And the key message here is if
you tried cloud platforms in

00:06:21.280 --> 00:06:23.300
the past for running these game
engines, and they just

00:06:23.300 --> 00:06:25.010
haven't been able to scale
or have the latency or

00:06:25.010 --> 00:06:27.200
performance you expect, check
our Compute Engine.

00:06:27.200 --> 00:06:28.440
You'll be happily surprised.

00:06:28.440 --> 00:06:30.520
And this is just one of the many
examples that show how

00:06:30.520 --> 00:06:33.740
that performance is delivering
real results.

00:06:33.740 --> 00:06:37.060
And finally, it really can be
summed up in a nice, neat

00:06:37.060 --> 00:06:38.530
little package with
a little bow.

00:06:38.530 --> 00:06:42.245
Kunal from Wizard Ops, they
moved their application over

00:06:42.245 --> 00:06:44.140
to Compute Engine and
immediately, they went,

00:06:44.140 --> 00:06:46.900
"Everything is just noticeably
faster in the application."

00:06:46.900 --> 00:06:48.990
And we're not talking about
going in the logs and seeing

00:06:48.990 --> 00:06:49.990
10 milliseconds.

00:06:49.990 --> 00:06:52.070
It's actually in the
application, playing the game,

00:06:52.070 --> 00:06:54.380
firing off requests, doing all
the actions, everything just

00:06:54.380 --> 00:06:56.810
responded quicker, and the
performance blew them away

00:06:56.810 --> 00:07:00.560
from what they were expecting
based on past experiences.

00:07:00.560 --> 00:07:04.560
So that is Cloud Platform in a
nutshell, and now we're going

00:07:04.560 --> 00:07:06.650
to jump into an architecture
that highlights how to piece

00:07:06.650 --> 00:07:10.110
together all of those
components.

00:07:10.110 --> 00:07:14.250
And with that, we always try
to highlight the key design

00:07:14.250 --> 00:07:16.420
requirements a lot of developers
face when building

00:07:16.420 --> 00:07:17.670
out these applications.

00:07:19.730 --> 00:07:21.660
Firstly, iOS, Android
devices--

00:07:21.660 --> 00:07:23.740
and if you're building a game
now, quite often you're

00:07:23.740 --> 00:07:25.200
looking at multi-platform.

00:07:25.200 --> 00:07:27.160
And the other really big
important thing is being

00:07:27.160 --> 00:07:29.930
scalable to millions of users,
but not just being able to hit

00:07:29.930 --> 00:07:32.470
a million users, ten million,
100 million users, but scaling

00:07:32.470 --> 00:07:34.220
in a way that makes sense so
you're not over and under

00:07:34.220 --> 00:07:36.350
provisioned, and you're not
spending a huge amount on

00:07:36.350 --> 00:07:38.260
servers when you only
have five players.

00:07:38.260 --> 00:07:39.610
And at the end of the day, it's
really about creating an

00:07:39.610 --> 00:07:41.960
engaging social game that just
grows virally and gives you

00:07:41.960 --> 00:07:43.120
some really great growth.

00:07:43.120 --> 00:07:45.160
And actually, FreshPlanet will
talk a bit more about things

00:07:45.160 --> 00:07:47.290
they did with that.

00:07:47.290 --> 00:07:49.370
And whenever we do one of these
reference architectures,

00:07:49.370 --> 00:07:52.960
we love to show an application
that highlights it is really

00:07:52.960 --> 00:07:55.475
straightforward to get up to
speed and start running and

00:07:55.475 --> 00:07:57.160
piecing together all
these components.

00:07:57.160 --> 00:08:00.330
And so with that, we created
a sample application called

00:08:00.330 --> 00:08:03.000
Griddler which we're going to
open source very soon, and it

00:08:03.000 --> 00:08:04.950
just highlights how you can
build a mobile game very

00:08:04.950 --> 00:08:06.820
quickly on the platform.

00:08:06.820 --> 00:08:10.200
And so if I switch over
to the overhead.

00:08:10.200 --> 00:08:10.970
It works.

00:08:10.970 --> 00:08:12.400
So essentially, you
join in this game.

00:08:12.400 --> 00:08:14.540
It's an asynchronous-based
mobile real game.

00:08:14.540 --> 00:08:16.610
And so you can go there, you
can challenge your friends,

00:08:16.610 --> 00:08:17.790
you can play by yourself.

00:08:17.790 --> 00:08:21.170
And so if I jump in and I go
to Challenge An Opponent,

00:08:21.170 --> 00:08:23.730
you'll see that I only have one
friend, but Greg, he's my

00:08:23.730 --> 00:08:24.640
best friend.

00:08:24.640 --> 00:08:26.520
We play this game
all of the time.

00:08:26.520 --> 00:08:29.760
And so you go in here, and you
challenge him to a game.

00:08:29.760 --> 00:08:31.990
So this will basically then
hit App Engine, send off a

00:08:31.990 --> 00:08:33.760
push notification
to his device.

00:08:33.760 --> 00:08:35.890
And then once he accepts that
device, it'll start a count

00:08:35.890 --> 00:08:37.850
down, and we'll be competing
in real time

00:08:37.850 --> 00:08:39.080
against this game.

00:08:39.080 --> 00:08:41.289
It's kind of unfair because
Greg worked very closely

00:08:41.289 --> 00:08:43.500
developing the game and knows
all of the answers to the

00:08:43.500 --> 00:08:46.550
riddle, where I've only made
it through the first three.

00:08:46.550 --> 00:08:48.590
And so once he accepts the push
notification that makes

00:08:48.590 --> 00:08:51.200
it to his device, that should
start, assuming we don't have

00:08:51.200 --> 00:08:55.820
any unexpected Wi-Fi challenges
and so forth.

00:08:55.820 --> 00:08:59.550
Anything on your device yet?

00:08:59.550 --> 00:09:01.850
Well, what you will see--

00:09:01.850 --> 00:09:02.840
we'll try one more time.

00:09:02.840 --> 00:09:04.340
I don't want to have one of
these mobile demos that goes

00:09:04.340 --> 00:09:05.360
down in flames.

00:09:05.360 --> 00:09:07.120
We seem to have really bad
experience with doing mobile

00:09:07.120 --> 00:09:08.200
demos in Cloud Platform.

00:09:08.200 --> 00:09:10.460
Always, the unexpected stuff
happens regardless of how much

00:09:10.460 --> 00:09:11.210
you'll test.

00:09:11.210 --> 00:09:13.330
But you'll notice that I'm
actually plugged into the

00:09:13.330 --> 00:09:16.690
power on the phone, so we learn
from our mistakes very

00:09:16.690 --> 00:09:19.340
quickly at Google for anybody
who was at the keynote.

00:09:19.340 --> 00:09:22.070
So it looks like the phones in
this room and the wireless

00:09:22.070 --> 00:09:24.750
isn't quite working right, so
let's jump into Single Player.

00:09:24.750 --> 00:09:25.910
And so this is exactly
what you see.

00:09:25.910 --> 00:09:27.720
So you're hitting App Engine,
you're getting requests for

00:09:27.720 --> 00:09:29.350
all of the game boards,
and you jump in.

00:09:29.350 --> 00:09:31.720
And so you get something like,
what has to be broken before

00:09:31.720 --> 00:09:32.590
it can be used?

00:09:32.590 --> 00:09:34.730
I know the answer because I've
done this one a few times.

00:09:34.730 --> 00:09:36.060
Egg.

00:09:36.060 --> 00:09:39.290
Feed me and I live, yet give
me a drink and I die.

00:09:39.290 --> 00:09:40.900
Fire.

00:09:40.900 --> 00:09:41.630
Let's see.

00:09:41.630 --> 00:09:42.290
Where's fire?

00:09:42.290 --> 00:09:43.270
Right here.

00:09:43.270 --> 00:09:44.850
And so you go through, and
you're competing against your

00:09:44.850 --> 00:09:46.000
friend to get the quickest
time, the

00:09:46.000 --> 00:09:47.540
highest score, et cetera.

00:09:47.540 --> 00:09:49.410
What has four legs but
only one foot?

00:09:49.410 --> 00:09:51.230
I didn't know the answer to
this, and I was thinking about

00:09:51.230 --> 00:09:52.690
this for 10, 15 minutes.

00:09:52.690 --> 00:09:54.680
One of the guys in the back
setting up for all the AV,

00:09:54.680 --> 00:09:55.530
they're rock stars.

00:09:55.530 --> 00:09:56.320
They figured it out.

00:09:56.320 --> 00:09:58.170
We're just setting up here and
out of nowhere, the guy yells,

00:09:58.170 --> 00:09:59.640
it's bed, bed!

00:09:59.640 --> 00:10:00.640
What are you talking about?

00:10:00.640 --> 00:10:02.940
It makes perfect sense, bed.

00:10:02.940 --> 00:10:04.960
So that's kind of what we're
looking at here.

00:10:04.960 --> 00:10:08.520
But this next one honestly, I
don't know what the answer is.

00:10:08.520 --> 00:10:10.440
I really don't answer is, so
we're kind of blocked here

00:10:10.440 --> 00:10:11.900
unless anybody has any idea.

00:10:11.900 --> 00:10:17.030
I fly straight and on track, I
take off when pulled back.

00:10:17.030 --> 00:10:17.480
Yeah?

00:10:17.480 --> 00:10:18.280
AUDIENCE: [INAUDIBLE].

00:10:18.280 --> 00:10:19.230
CHRIS ELLIOTT: Arrow.

00:10:19.230 --> 00:10:20.270
Is it in the game board?

00:10:20.270 --> 00:10:21.740
Oh yeah.

00:10:21.740 --> 00:10:24.330
All right, you're a rock star.

00:10:24.330 --> 00:10:27.464
What runs and never
gets tired?

00:10:27.464 --> 00:10:29.770
AUDIENCE: [INAUDIBLE].

00:10:29.770 --> 00:10:31.266
CHRIS ELLIOTT: Water?

00:10:31.266 --> 00:10:33.390
Wow, you guys are rock stars.

00:10:36.470 --> 00:10:37.080
There's water.

00:10:37.080 --> 00:10:38.885
What kind of tree can you
carry in your hand?

00:10:41.670 --> 00:10:42.720
What's that?

00:10:42.720 --> 00:10:44.650
AUDIENCE: [INAUDIBLE].

00:10:44.650 --> 00:10:45.920
CHRIS ELLIOTT: A palm tree?

00:10:45.920 --> 00:10:46.730
I tried palm.

00:10:46.730 --> 00:10:47.520
It didn't work before.

00:10:47.520 --> 00:10:49.170
Well anyways, it goes
on like this.

00:10:49.170 --> 00:10:50.690
We could spend the entire
session doing this.

00:10:50.690 --> 00:10:52.920
Show of hands, who wants to do
riddles the entire session, or

00:10:52.920 --> 00:10:55.440
who wants to see some
architectures?

00:10:55.440 --> 00:11:01.260
OK, there was a surprising
number of hands for riddles,

00:11:01.260 --> 00:11:02.850
but it might not be great
for anybody viewing at

00:11:02.850 --> 00:11:03.680
home after the fact.

00:11:03.680 --> 00:11:05.710
So that's the kind of game we're
looking at, so let's

00:11:05.710 --> 00:11:08.230
jump back over to the Mac.

00:11:08.230 --> 00:11:12.180
And when building out a game
like that, the core building

00:11:12.180 --> 00:11:14.300
block really is the mobile
application, creating your

00:11:14.300 --> 00:11:16.710
native application,
iOS, on Android,

00:11:16.710 --> 00:11:18.040
whatever devices you want.

00:11:18.040 --> 00:11:20.185
And really where the magic
begins is when you connect it

00:11:20.185 --> 00:11:21.110
to App Engine.

00:11:21.110 --> 00:11:23.830
Cloud Endpoint is an amazing
piece of technology for

00:11:23.830 --> 00:11:26.510
creating a RESTful API and
seamlessly connecting your

00:11:26.510 --> 00:11:28.670
mobile applications
to your front ends

00:11:28.670 --> 00:11:30.140
running on App Engine.

00:11:30.140 --> 00:11:33.520
It provides RESTful APIs and
strongly typed libraries for

00:11:33.520 --> 00:11:35.580
your devices that make it
very simple to call

00:11:35.580 --> 00:11:37.000
that from code natively.

00:11:37.000 --> 00:11:39.890
I had the misfortune of having
to do this before Cloud

00:11:39.890 --> 00:11:42.330
Endpoints existed, creating
a RESTful API with full

00:11:42.330 --> 00:11:45.350
authentication, and it is not
easy to do that, and Cloud

00:11:45.350 --> 00:11:49.550
Endpoints makes everyone's
lives a lot easier now.

00:11:49.550 --> 00:11:50.850
And so what does that
actually look like?

00:11:50.850 --> 00:11:54.680
It really is dead simple to put
together an application

00:11:54.680 --> 00:11:56.400
that calls Cloud Endpoints.

00:11:56.400 --> 00:11:58.890
You add this annotation to
declare the path you would

00:11:58.890 --> 00:12:01.070
like and the variables, and then
you'll see essentially

00:12:01.070 --> 00:12:03.530
within App Engine in Java, you
define the function, you

00:12:03.530 --> 00:12:05.660
define the variables you're
looking at, and then what will

00:12:05.660 --> 00:12:07.360
be generated is this
client library--

00:12:07.360 --> 00:12:09.040
for example, shown here
for Android--

00:12:09.040 --> 00:12:10.390
that just makes it very
simple to call

00:12:10.390 --> 00:12:13.830
gameBackend.sendInvitation,
and that's it.

00:12:13.830 --> 00:12:15.910
One of the really cool things
here you may not have noticed

00:12:15.910 --> 00:12:18.180
is the fact that we have a user
parameter in App Engine

00:12:18.180 --> 00:12:20.140
to use, but there's nothing
we're sending actually from

00:12:20.140 --> 00:12:21.070
the client application.

00:12:21.070 --> 00:12:23.220
And that's populated
automatically if you need that

00:12:23.220 --> 00:12:25.480
for application and making sure
the user is who they say

00:12:25.480 --> 00:12:27.680
they are, and you have the full
authentication baked in.

00:12:27.680 --> 00:12:31.250
Really, really cool stuff, and
that all uses Google's API

00:12:31.250 --> 00:12:32.860
technology.

00:12:32.860 --> 00:12:35.940
The other aspect is looking at
pushing notifications out to

00:12:35.940 --> 00:12:38.510
the device, such as this
push notification

00:12:38.510 --> 00:12:40.610
that I sent to Greg.

00:12:40.610 --> 00:12:42.510
And this is really where
Google Cloud Messaging

00:12:42.510 --> 00:12:44.340
provides all that functionality,
and you can

00:12:44.340 --> 00:12:45.480
even leverage some
of the stuff that

00:12:45.480 --> 00:12:47.710
was announced yesterday.

00:12:47.710 --> 00:12:49.620
But another thing that's really
cool here is Apple Push

00:12:49.620 --> 00:12:51.280
Notification works
from App Engine.

00:12:51.280 --> 00:12:53.160
So some people in the room might
have tried this a year

00:12:53.160 --> 00:12:56.300
ago and realized it wasn't
possible very quickly.

00:12:56.300 --> 00:12:59.100
But now, it is possible because
the socket's API makes

00:12:59.100 --> 00:13:01.790
it seamless to integrate Apple
Push Notification Service

00:13:01.790 --> 00:13:04.360
directly with App Engine and
call that without much effort

00:13:04.360 --> 00:13:05.360
on your end.

00:13:05.360 --> 00:13:06.960
And so it really is seamless.

00:13:06.960 --> 00:13:10.440
I mean, within App Engine, you
import the required libraries

00:13:10.440 --> 00:13:11.340
and so forth.

00:13:11.340 --> 00:13:13.380
And then from there, it's the
standard exactly what you'd

00:13:13.380 --> 00:13:16.130
expect, the push.Alert, and you
send the device IDs, the

00:13:16.130 --> 00:13:17.530
messages, et cetera.

00:13:17.530 --> 00:13:19.800
So we actually are going to have
a paper published very

00:13:19.800 --> 00:13:22.230
soon to show you how to build
that out on App Engine, and

00:13:22.230 --> 00:13:24.580
also a sample application to
give you something to get up

00:13:24.580 --> 00:13:26.080
to speed very quickly.

00:13:26.080 --> 00:13:28.200
So the only nuances that come
into play here are just

00:13:28.200 --> 00:13:30.270
working with Apple Push
Notification Service.

00:13:30.270 --> 00:13:32.380
For example, they don't like you
opening many, many socket

00:13:32.380 --> 00:13:34.300
connections, so you'd be looking
at using something

00:13:34.300 --> 00:13:36.600
like maintaining a socket
connection in the back end

00:13:36.600 --> 00:13:38.090
that lives around forever
and doesn't

00:13:38.090 --> 00:13:39.780
terminate after every request.

00:13:39.780 --> 00:13:41.480
And then you can use mechanisms
like the task

00:13:41.480 --> 00:13:43.750
queues to really batch those
up and send them through.

00:13:43.750 --> 00:13:45.520
So all the components of App
Engine really provide the

00:13:45.520 --> 00:13:47.840
scalable framework to allow you
to scale up to sending out

00:13:47.840 --> 00:13:49.235
tens of millions of push
notifications.

00:13:51.960 --> 00:13:55.310
And so one of the secret
sauces of App Engine--

00:13:55.310 --> 00:13:57.130
one of the many, many
secret sauces.

00:13:57.130 --> 00:14:00.600
I mean, it's a delicious thing
full of crazy secret sauces,

00:14:00.600 --> 00:14:02.780
but the Datastore, in my
opinion, is one of the biggest

00:14:02.780 --> 00:14:05.350
things that really gives App
Engine, makes it a great place

00:14:05.350 --> 00:14:06.490
for developers to work.

00:14:06.490 --> 00:14:08.560
It's a NoSQL database
that just scales

00:14:08.560 --> 00:14:10.160
to ridiculous size.

00:14:10.160 --> 00:14:12.730
And when you combine that with
Memcache, you can really scale

00:14:12.730 --> 00:14:15.210
up to 80 million users without
having any hiccups at all in

00:14:15.210 --> 00:14:16.380
your database layer.

00:14:16.380 --> 00:14:19.700
And so with that, for Griddles
for example, all of those game

00:14:19.700 --> 00:14:22.590
boards are frequently accessed
and requested, it makes sense

00:14:22.590 --> 00:14:24.080
to cache those in Memcache.

00:14:24.080 --> 00:14:25.800
I mean, Memcache isn't an
infinite service, and you need

00:14:25.800 --> 00:14:26.880
to use it wisely.

00:14:26.880 --> 00:14:29.130
But those are being requested
for every single player, and

00:14:29.130 --> 00:14:30.560
it's a perfect use case.

00:14:30.560 --> 00:14:33.940
However, the Datastore is a
great place to store all of

00:14:33.940 --> 00:14:37.060
those user scores, profiles, et
cetera, all of the games,

00:14:37.060 --> 00:14:38.110
all of the challenges.

00:14:38.110 --> 00:14:39.830
And of course, you'll keep all
of the boards in there long

00:14:39.830 --> 00:14:41.890
term and just refresh
them in case the

00:14:41.890 --> 00:14:43.090
Memcache gets evicted.

00:14:43.090 --> 00:14:44.900
So that's one example of how
you can think about using

00:14:44.900 --> 00:14:46.780
Datastore and Memcache when
you're building out these

00:14:46.780 --> 00:14:48.620
mobile applications.

00:14:48.620 --> 00:14:50.440
And then the other aspect really
is the Tasks Queued,

00:14:50.440 --> 00:14:51.530
Schedule Tasks.

00:14:51.530 --> 00:14:53.580
These we kind of highlighted
when talking about Apple Push

00:14:53.580 --> 00:14:54.800
Notification Service.

00:14:54.800 --> 00:14:56.720
And Schedule Task, for example,
would be great if you

00:14:56.720 --> 00:14:59.340
want to go through daily and
send out a notification to

00:14:59.340 --> 00:15:01.270
anybody who hasn't played the
game in a week just saying,

00:15:01.270 --> 00:15:03.410
hey, we have new content.

00:15:03.410 --> 00:15:05.430
Would you like to try, or a lot
of these things you see

00:15:05.430 --> 00:15:08.240
mobile applications doing.

00:15:08.240 --> 00:15:11.250
And up next, a lot of times,
you need to have an online

00:15:11.250 --> 00:15:14.570
object store to store video or
pictures or a lot of this rich

00:15:14.570 --> 00:15:16.080
content that users expect.

00:15:16.080 --> 00:15:18.010
You may have seen this in the
Cloud Platform Overview where

00:15:18.010 --> 00:15:20.110
we're storing video on Cloud
Storage, and this is really

00:15:20.110 --> 00:15:22.100
straightforward to connect to
App Engine, connect to your

00:15:22.100 --> 00:15:24.990
mobile devices, and start
storing all that content here.

00:15:24.990 --> 00:15:27.010
And if you're looking at things
like using images, the

00:15:27.010 --> 00:15:29.760
Image service is a great way of
rescaling any images a user

00:15:29.760 --> 00:15:32.740
uploads so it matches whatever
UI you have set up with your

00:15:32.740 --> 00:15:35.700
mobile application.

00:15:35.700 --> 00:15:37.050
And finally, Compute Engine.

00:15:37.050 --> 00:15:39.250
I mean, it's amazing to be able
to fork out to Compute

00:15:39.250 --> 00:15:41.250
Engine any of these batch
processing workloads or any

00:15:41.250 --> 00:15:43.730
time you want to run any code
at all that doesn't

00:15:43.730 --> 00:15:46.340
necessarily work within App
Engine, and that is really

00:15:46.340 --> 00:15:48.940
where Compute Engine is a great
use case in this example

00:15:48.940 --> 00:15:50.450
for mobile applications.

00:15:50.450 --> 00:15:51.890
Although you want to leverage
App Engine for a lot of the

00:15:51.890 --> 00:15:53.520
scalability aspects--
that'll get you up

00:15:53.520 --> 00:15:54.590
to speed the quickest--

00:15:54.590 --> 00:15:56.750
Compute Engine is there to back
you up when you need to

00:15:56.750 --> 00:15:58.910
run your own Linux virtual
machines and custom software

00:15:58.910 --> 00:16:00.130
packages and so forth.

00:16:00.130 --> 00:16:02.130
The example we really like
to talk about is video

00:16:02.130 --> 00:16:03.450
transcoding, for example.

00:16:03.450 --> 00:16:06.240
You have videos in the Cloud
Storage, pulling them out,

00:16:06.240 --> 00:16:07.500
doing the transcoding,
and putting them

00:16:07.500 --> 00:16:08.670
back in Cloud Storage.

00:16:08.670 --> 00:16:11.000
And then the Task Queue is
really the key mechanism to

00:16:11.000 --> 00:16:13.230
orchestrate that communication
between Compute

00:16:13.230 --> 00:16:15.540
Engine and App Engine.

00:16:15.540 --> 00:16:17.705
And that is also very
seamless to set up.

00:16:17.705 --> 00:16:20.390
I realized during this
presentation, I say "seamless"

00:16:20.390 --> 00:16:22.550
many, many times, but it
really is seamless.

00:16:22.550 --> 00:16:24.680
Talk to anybody who has built
on the platform and created

00:16:24.680 --> 00:16:27.060
these massive games, and they
will echo the exact same sort

00:16:27.060 --> 00:16:28.940
of sentiments.

00:16:28.940 --> 00:16:30.960
So when you create the instance,
all you have to do

00:16:30.960 --> 00:16:32.530
to set up Task Queue is really
straightforward.

00:16:32.530 --> 00:16:35.530
You just specify the service
scope to give access to the

00:16:35.530 --> 00:16:37.220
Task Queue within
that project.

00:16:37.220 --> 00:16:40.060
From there, if you were in the
instance on Compute Engine,

00:16:40.060 --> 00:16:42.200
you'll have access to the
metadata with the access token

00:16:42.200 --> 00:16:43.600
or to call out like that.

00:16:43.600 --> 00:16:45.510
Otherwise, if you're using
things like the Client

00:16:45.510 --> 00:16:49.110
Library, it's very seamless to
go in and just one line of

00:16:49.110 --> 00:16:51.090
code, to configure that, and
then from there, you can start

00:16:51.090 --> 00:16:52.890
calling Task Queue and
can perform a lot

00:16:52.890 --> 00:16:55.080
of operations there.

00:16:55.080 --> 00:16:57.800
And those operations are similar
to what you'd expect.

00:16:57.800 --> 00:16:59.900
I mean, you can pull a lease
down on a task, do a bunch of

00:16:59.900 --> 00:17:02.420
processing work, and then
delete that task once

00:17:02.420 --> 00:17:04.040
everything's completed.

00:17:04.040 --> 00:17:06.020
And one of those completion
steps might include putting

00:17:06.020 --> 00:17:08.359
another task back on the queue
where App Engine can be

00:17:08.359 --> 00:17:10.950
pulling that information back
down and doing some more

00:17:10.950 --> 00:17:13.089
processing, notifying
the user, et cetera.

00:17:13.089 --> 00:17:15.240
And finally, if you're looking
at things like autoscaling,

00:17:15.240 --> 00:17:16.690
the Task Queue Stats
is a great place

00:17:16.690 --> 00:17:17.660
to go there as well.

00:17:17.660 --> 00:17:19.310
So if you see you have 1,000
videos waiting to be

00:17:19.310 --> 00:17:21.670
transcoded, increase the
number of instances.

00:17:21.670 --> 00:17:23.650
That's just one of the many ways
you can scale on Compute

00:17:23.650 --> 00:17:25.849
Engine, and you can really have
the flexibility to tweak

00:17:25.849 --> 00:17:27.910
that to whatever kind of
techniques you're familiar

00:17:27.910 --> 00:17:29.160
with using.

00:17:31.110 --> 00:17:34.070
So the last aspect of the
solution is BigQuery.

00:17:34.070 --> 00:17:36.210
BigQuery is absolutely
amazing.

00:17:36.210 --> 00:17:38.840
I was talking to a customer a
couple days ago, and they

00:17:38.840 --> 00:17:41.150
thought it was voodoo magic
because it's real time

00:17:41.150 --> 00:17:43.390
analytics for massive
data sets.

00:17:43.390 --> 00:17:45.470
And so they ran a query over
five billion rows, and it

00:17:45.470 --> 00:17:46.780
returned in three seconds.

00:17:46.780 --> 00:17:48.420
That didn't make any sense
to them at all.

00:17:48.420 --> 00:17:49.340
This is impossible.

00:17:49.340 --> 00:17:49.940
Something must be wrong.

00:17:49.940 --> 00:17:52.490
But actually, it is
working correctly.

00:17:52.490 --> 00:17:55.340
It's based on proven, bullet
tested Google technology.

00:17:55.340 --> 00:17:57.260
And it's really great
for mobile games.

00:17:57.260 --> 00:17:59.230
Almost every studio we talked
to that is building on the

00:17:59.230 --> 00:18:01.690
platform and has scaled up
to millions of users uses

00:18:01.690 --> 00:18:03.930
BigQuery for getting a lot of
really great insight into

00:18:03.930 --> 00:18:05.100
their application.

00:18:05.100 --> 00:18:09.120
A great example of how you can
use it is you have every

00:18:09.120 --> 00:18:11.070
single action per
user per day.

00:18:11.070 --> 00:18:13.450
It's a great opportunity to run
a MapReduce over that job

00:18:13.450 --> 00:18:16.040
and aggregate it down
to a level that

00:18:16.040 --> 00:18:17.010
you really care about.

00:18:17.010 --> 00:18:20.760
For example, total actions per
user per day instead of every

00:18:20.760 --> 00:18:21.960
single action.

00:18:21.960 --> 00:18:24.450
At that point, you can put it
into BigQuery and start asking

00:18:24.450 --> 00:18:29.790
really insightful things, such
as, what happens to users who

00:18:29.790 --> 00:18:31.700
stop playing for a week, and
we send them a promotion?

00:18:31.700 --> 00:18:32.530
Do they come back?

00:18:32.530 --> 00:18:34.200
Or if I have a double experience
weekend, do people

00:18:34.200 --> 00:18:34.730
spend more?

00:18:34.730 --> 00:18:35.830
Do people play longer?

00:18:35.830 --> 00:18:37.840
It's a really powerful component
for getting a lot of

00:18:37.840 --> 00:18:42.310
this insight that is key to
building a mobile application.

00:18:42.310 --> 00:18:45.030
And finally, you've actually
come to the best Glass session

00:18:45.030 --> 00:18:47.520
in my opinion, although I might
be a little bit biased.

00:18:47.520 --> 00:18:49.660
When looking at building out
apps on Glass, I mean, you

00:18:49.660 --> 00:18:51.630
have the Mirror API, you
can do native Android

00:18:51.630 --> 00:18:52.530
applications.

00:18:52.530 --> 00:18:55.870
But really, it's the back end
where the magic happens.

00:18:55.870 --> 00:18:57.900
When you're creating the next
generation of applications

00:18:57.900 --> 00:19:01.370
powered by Glass, Google Cloud
Platform is the best place to

00:19:01.370 --> 00:19:03.690
go and build those applications
out because you

00:19:03.690 --> 00:19:05.830
can leverage all of
this technology.

00:19:05.830 --> 00:19:07.860
And when you only have a couple
of developers with

00:19:07.860 --> 00:19:09.790
devices, there's not going to be
a lot of cost, but once it

00:19:09.790 --> 00:19:11.940
takes off, you'll be able
to scale up massively.

00:19:11.940 --> 00:19:15.110
And so really, you can use
things like Cloud Endpoints,

00:19:15.110 --> 00:19:16.670
you can connect it through
Mirror API.

00:19:16.670 --> 00:19:18.530
You may have noticed on the
Mirror API, for example, App

00:19:18.530 --> 00:19:21.250
Engine is a great place to go
for Java and Python, and so

00:19:21.250 --> 00:19:24.750
all of these techniques are
directly applicable to Glass.

00:19:24.750 --> 00:19:27.410
So this is really how you build
Glass applications.

00:19:27.410 --> 00:19:30.620
All those people on the other
side are in the wrong session.

00:19:30.620 --> 00:19:33.180
Don't tell them I said that.

00:19:33.180 --> 00:19:35.700
Might not work out too well.

00:19:35.700 --> 00:19:38.430
So what better way than to
actually hear about how you

00:19:38.430 --> 00:19:40.400
build on a platform and that
it's not just voodoo magic I'm

00:19:40.400 --> 00:19:41.980
talking about, that it actually
is possible to create

00:19:41.980 --> 00:19:43.610
a very successful application?

00:19:43.610 --> 00:19:46.450
I'd like to welcome to the stage
Olivier and Alexis from

00:19:46.450 --> 00:19:50.030
FreshPlanet who have built this
amazing game, "SongPop,"

00:19:50.030 --> 00:19:51.700
and they're going to tell
you all about it.

00:19:51.700 --> 00:19:52.720
Thanks, guys.

00:19:52.720 --> 00:19:58.480
[APPLAUSE]

00:19:58.480 --> 00:20:01.590
OLIVIER MICHON: So I am Olivier,
and this is Alexis.

00:20:01.590 --> 00:20:04.590
We are not yet on Google Glass,
but hopefully soon.

00:20:07.790 --> 00:20:08.790
So we are FreshPlanet.

00:20:08.790 --> 00:20:11.760
We are a small company, we're
a start-up in New York City

00:20:11.760 --> 00:20:15.170
around 20 developers right now,
and we are focusing on

00:20:15.170 --> 00:20:19.350
making mobile social
games on app.

00:20:19.350 --> 00:20:23.440
Something that sets us apart,
I think, is that we are very

00:20:23.440 --> 00:20:26.220
small teams, so we usually have
between three and four

00:20:26.220 --> 00:20:28.070
developers per project.

00:20:28.070 --> 00:20:32.580
But at the same time, we want to
have a very large scale, so

00:20:32.580 --> 00:20:36.260
lots and lots of users, so we
have to be very efficient and

00:20:36.260 --> 00:20:40.080
find the right technology that
allows that, and this is one

00:20:40.080 --> 00:20:43.930
of the reasons why we use
Google Cloud Platform.

00:20:43.930 --> 00:20:47.400
About one year ago, we released
"SongPop." I don't

00:20:47.400 --> 00:20:50.100
know if you guys have
played it a little.

00:20:50.100 --> 00:20:53.600
We wrote a few months ago a blog
post on the Google Cloud

00:20:53.600 --> 00:20:59.120
Blog, and Chris was nice enough
to invite us to share a

00:20:59.120 --> 00:21:01.790
bit more detail with you.

00:21:01.790 --> 00:21:04.330
So for those of you who don't
know, "SongPop" is a very

00:21:04.330 --> 00:21:04.850
simple game.

00:21:04.850 --> 00:21:07.740
At its heart, it's really you
have five song samples that

00:21:07.740 --> 00:21:09.740
get streamed to you.

00:21:09.740 --> 00:21:13.226
You have to guess either the
song title or the artist.

00:21:13.226 --> 00:21:16.000
This is on iOS, Android,
or on the web.

00:21:16.000 --> 00:21:17.930
The twist to it is that it's
purely muliplayer.

00:21:17.930 --> 00:21:19.340
You never play alone.

00:21:19.340 --> 00:21:21.890
You're always competing
against someone else.

00:21:21.890 --> 00:21:26.500
It can be a stranger or
one of your friends.

00:21:26.500 --> 00:21:29.480
I think we did something right
with this game because this is

00:21:29.480 --> 00:21:31.550
what our growth looks like.

00:21:31.550 --> 00:21:34.480
We did absolutely no
marketing at all.

00:21:34.480 --> 00:21:37.015
And this is a million
daily active users.

00:21:37.015 --> 00:21:39.860
We released around
May of last year.

00:21:39.860 --> 00:21:42.800
By June, we were already at two
million daily active users

00:21:42.800 --> 00:21:46.790
with a curve that looks like the
famous hockey stick, only

00:21:46.790 --> 00:21:50.830
it keeps growing and growing as
we reach more users across

00:21:50.830 --> 00:21:53.710
many different countries.

00:21:53.710 --> 00:21:58.440
We plateaued around September of
last year with five million

00:21:58.440 --> 00:22:00.690
daily active users, and at this
time, we were the first

00:22:00.690 --> 00:22:04.900
game in the App Stores in many
countries including the US,

00:22:04.900 --> 00:22:07.370
the UK, and Australia.

00:22:07.370 --> 00:22:09.820
In terms of scale, what it
represents when you're at this

00:22:09.820 --> 00:22:12.930
point, it's 300 million
requests a day on your

00:22:12.930 --> 00:22:13.610
infrastructure.

00:22:13.610 --> 00:22:18.060
It's three billion Datastore
operations per day.

00:22:18.060 --> 00:22:22.320
We were streaming around 20
terabytes a day of songs and

00:22:22.320 --> 00:22:24.620
album covers for the music.

00:22:24.620 --> 00:22:28.790
So let's dig a bit and see how
we structure that and which of

00:22:28.790 --> 00:22:32.960
the Google Cloud products we
used to reach this scale.

00:22:32.960 --> 00:22:34.590
On the left, you can see that we
have those three different

00:22:34.590 --> 00:22:38.830
clients that we support, so
iOS, Android, the web.

00:22:38.830 --> 00:22:41.955
They're all talking to our App
Engine back end written in

00:22:41.955 --> 00:22:45.520
Python with the same
simple JSON API.

00:22:45.520 --> 00:22:48.480
Then they fetch all the media
contents, so the song samples

00:22:48.480 --> 00:22:53.650
and the album cover on
Google Cloud Storage.

00:22:53.650 --> 00:22:57.210
And we have to push data back
to our users when we release

00:22:57.210 --> 00:22:59.560
new playlists, when we think
they might be interested, when

00:22:59.560 --> 00:23:00.760
they have a new challenge.

00:23:00.760 --> 00:23:03.570
We also have a chat enabled in
the game so when you receive a

00:23:03.570 --> 00:23:05.020
new message.

00:23:05.020 --> 00:23:07.690
For that, we use Google Cloud
Messaging for Android.

00:23:07.690 --> 00:23:10.390
We use Apple Push Notification
with Socket.

00:23:10.390 --> 00:23:13.570
We use a channel
API on the web.

00:23:13.570 --> 00:23:16.820
We integrate deeply with
Facebook for friend requests

00:23:16.820 --> 00:23:19.810
on all of the API.

00:23:19.810 --> 00:23:22.995
But really at the centerpiece
of it all is our App Engine

00:23:22.995 --> 00:23:26.220
code written in Python, and
it integrates with all the

00:23:26.220 --> 00:23:28.430
different pieces of the
Cloud Platform--

00:23:28.430 --> 00:23:33.060
the Datastore, Memcache, Task
Queue, we use all of that.

00:23:33.060 --> 00:23:36.440
So let's see what kind of logic
we have to run because

00:23:36.440 --> 00:23:39.590
at first, it seems like a very
simple game somewhat, but I

00:23:39.590 --> 00:23:42.840
think we do a few interesting
things.

00:23:42.840 --> 00:23:45.400
On the left, you can
see the matching.

00:23:45.400 --> 00:23:48.050
So you can, of course, challenge
an opponent on

00:23:48.050 --> 00:23:51.620
Facebook with username and
email, but we manage to run

00:23:51.620 --> 00:23:53.900
more interesting queries
on App Engine.

00:23:53.900 --> 00:23:56.530
For instance, we have a feature
called Best Match.

00:23:56.530 --> 00:23:59.500
What it does, it's going to try
to find an opponent for

00:23:59.500 --> 00:24:03.750
you that wants to play with
strangers, that's currently

00:24:03.750 --> 00:24:06.320
active, that's close to
you geographically--

00:24:06.320 --> 00:24:09.340
so we look at the state and
even the city level--

00:24:09.340 --> 00:24:14.330
and then we match you on your
music taste because you will

00:24:14.330 --> 00:24:17.310
have a way better experience if
you play with someone that

00:24:17.310 --> 00:24:19.430
likes the same kind of music
because you're going to go

00:24:19.430 --> 00:24:21.620
back and forth with music
you both like.

00:24:21.620 --> 00:24:23.755
So it was very important.

00:24:23.755 --> 00:24:25.770
After we released this feature,
we looked at the

00:24:25.770 --> 00:24:30.590
metrics, and it was very
beneficial for us compared to

00:24:30.590 --> 00:24:32.440
just random matching
to take user

00:24:32.440 --> 00:24:34.300
music tastes into account.

00:24:34.300 --> 00:24:36.420
Those kind of things can run on
App Engine even if they are

00:24:36.420 --> 00:24:38.350
very complicated.

00:24:38.350 --> 00:24:41.520
On top, we also have lots of
Playlists to manage and lots

00:24:41.520 --> 00:24:43.090
of quizzes to generate.

00:24:43.090 --> 00:24:46.500
We have to create hundreds of
playlists with up to 500 songs

00:24:46.500 --> 00:24:49.380
each, and when you generate a
playlist, we have to take into

00:24:49.380 --> 00:24:53.560
account you as a player and your
skills in this playlist,

00:24:53.560 --> 00:24:56.070
but also the person that's
going to receive it.

00:24:56.070 --> 00:24:58.630
Based on that, we have to
balance and pick the right set

00:24:58.630 --> 00:25:01.410
of songs that we want.

00:25:01.410 --> 00:25:03.800
But I think the most interesting
part is the

00:25:03.800 --> 00:25:07.160
[INAUDIBLE] button because most
games, their results are

00:25:07.160 --> 00:25:10.800
on one user in terms of data,
in terms of scalability.

00:25:10.800 --> 00:25:13.490
But SongPop is different because
it's purely one versus

00:25:13.490 --> 00:25:16.990
one, so most of our data
is between two users.

00:25:16.990 --> 00:25:21.150
It's what we call the Player
versus Player, or PvP.

00:25:21.150 --> 00:25:25.180
It means that our database is
really a graph structure, and

00:25:25.180 --> 00:25:28.830
so we store the current quiz
there, we store a bunch of

00:25:28.830 --> 00:25:32.280
stats on your histories of
scores and playlists sent.

00:25:32.280 --> 00:25:34.890
We store the Chat messages.

00:25:34.890 --> 00:25:38.740
So it's a bit of particularity
and we are pretty heavy users

00:25:38.740 --> 00:25:42.790
of the back end, both in terms
of data and logic.

00:25:42.790 --> 00:25:45.160
But to dig even deeper on that,
I'm going to let Alexis

00:25:45.160 --> 00:25:46.410
talk about it.

00:25:49.030 --> 00:25:51.270
ALEXIS HANICOTTE: So let's first
start with how we define

00:25:51.270 --> 00:25:52.120
our models.

00:25:52.120 --> 00:25:53.730
That's pretty straightforward.

00:25:53.730 --> 00:25:57.080
We have our user model that
holds the list of playlists he

00:25:57.080 --> 00:25:58.630
has purchased.

00:25:58.630 --> 00:26:02.570
Then our playlist model, that is
just a collection of songs.

00:26:02.570 --> 00:26:05.400
Then the song model, that
belongs to an album that is

00:26:05.400 --> 00:26:06.530
from an artist.

00:26:06.530 --> 00:26:09.700
Then we have this PvP model
that represent the link

00:26:09.700 --> 00:26:11.722
between the user and
the opponent.

00:26:11.722 --> 00:26:14.930
This holds the current state of
the game and the history of

00:26:14.930 --> 00:26:17.770
the interaction between
the two users.

00:26:17.770 --> 00:26:20.450
In Google App Engine,
this translates

00:26:20.450 --> 00:26:21.870
directly into the code.

00:26:21.870 --> 00:26:25.230
For instance, we have to write
a Playlist class with all the

00:26:25.230 --> 00:26:27.810
properties we want on it and
the type we want for these

00:26:27.810 --> 00:26:29.000
properties.

00:26:29.000 --> 00:26:31.110
And that's all you need to do.

00:26:31.110 --> 00:26:34.230
Then App Engine will create the
necessary entries into the

00:26:34.230 --> 00:26:39.420
Datastore as soon as you
start using this class.

00:26:39.420 --> 00:26:44.010
I would like to go further and
show what is the real code you

00:26:44.010 --> 00:26:46.830
actually need to write on App
Engine from when the request

00:26:46.830 --> 00:26:50.570
hits your back end to when you
can deliver the response.

00:26:50.570 --> 00:26:54.120
To do that, we can do it with a
real example from "SongPop"

00:26:54.120 --> 00:26:55.610
that we call user/data.

00:26:55.610 --> 00:26:59.470
This handler is used to keep the
device up to date, so it's

00:26:59.470 --> 00:27:02.270
called every time the user opens
the application or goes

00:27:02.270 --> 00:27:04.230
back to this main screen.

00:27:04.230 --> 00:27:07.460
And we have to pull all the
active games he has, so it can

00:27:07.460 --> 00:27:11.380
be up to 80 games, and this is
called many times for each

00:27:11.380 --> 00:27:12.150
user session.

00:27:12.150 --> 00:27:14.360
So that's a critical
call for us.

00:27:14.360 --> 00:27:19.250
If it fails, the user can no
longer see what he can play.

00:27:19.250 --> 00:27:22.730
So what we really have to do
is we query for the games,

00:27:22.730 --> 00:27:24.330
that is, all PvP models.

00:27:24.330 --> 00:27:27.740
And for each PvP, we have to
retrace the playlists linked

00:27:27.740 --> 00:27:30.700
to the current quiz and
the user model and

00:27:30.700 --> 00:27:33.560
his opponent profile.

00:27:33.560 --> 00:27:35.030
We structure it this way.

00:27:35.030 --> 00:27:38.440
So first, we fetch the current
user, then we query for the

00:27:38.440 --> 00:27:39.720
list of games.

00:27:39.720 --> 00:27:43.330
Then we can extract the playlist
we need from the

00:27:43.330 --> 00:27:46.180
games and the user and get
the opponent's data.

00:27:46.180 --> 00:27:49.630
Finally, we combine and format
everything and send that back

00:27:49.630 --> 00:27:50.900
to the client.

00:27:50.900 --> 00:27:53.400
So I will show you, for each
of these steps, how we

00:27:53.400 --> 00:27:57.270
implemented them and why
is it efficient.

00:27:57.270 --> 00:28:00.980
So let's start with getting
the current user.

00:28:00.980 --> 00:28:04.430
So we just extract the User ID
from the incoming requests,

00:28:04.430 --> 00:28:07.480
and then we use a Python
NDB API to

00:28:07.480 --> 00:28:08.990
retrieve the user model.

00:28:08.990 --> 00:28:13.530
So by just coding
User.get_by_id.

00:28:13.530 --> 00:28:14.820
Why is this efficient?

00:28:14.820 --> 00:28:18.530
Well first, it goes through the
Cloud Datastore that is

00:28:18.530 --> 00:28:21.750
designed to be highly scalable,
in fact, it's built

00:28:21.750 --> 00:28:23.080
on top of BigTable.

00:28:23.080 --> 00:28:25.060
That is what Google uses
internally for

00:28:25.060 --> 00:28:26.700
some of their products.

00:28:26.700 --> 00:28:29.960
But what really makes this line
efficient is that it goes

00:28:29.960 --> 00:28:32.370
through a Memcache layer.

00:28:32.370 --> 00:28:36.180
So when we call our user/data
handler again, it will

00:28:36.180 --> 00:28:40.290
directly fetch the user model
from Memcache, saving us lots

00:28:40.290 --> 00:28:43.520
of time and Datastore
operations.

00:28:43.520 --> 00:28:47.170
Also a nice feature with NDB is
that the model is added to

00:28:47.170 --> 00:28:48.930
the instance memory.

00:28:48.930 --> 00:28:52.020
So when you have other parts of
your code that also want to

00:28:52.020 --> 00:28:54.690
retrieve this user by
this ID, you will

00:28:54.690 --> 00:28:56.030
directly get the model.

00:28:56.030 --> 00:29:00.100
You don't have to manage
all of that.

00:29:00.100 --> 00:29:03.570
Now that we have the current
user, we can query for the

00:29:03.570 --> 00:29:04.990
list of games.

00:29:04.990 --> 00:29:09.890
So here is how we write a
query using the NDB API.

00:29:09.890 --> 00:29:12.660
You can just do that and it
works, but that would not be

00:29:12.660 --> 00:29:15.470
very efficient, and that would
be expensive because this

00:29:15.470 --> 00:29:17.510
doesn't make use of Memcache.

00:29:17.510 --> 00:29:21.810
Indeed, NDB can't guess when
each was invalidated, so it's

00:29:21.810 --> 00:29:26.250
up to you to implement this,
but that's still very easy.

00:29:26.250 --> 00:29:28.965
We just define our
own Memcache key.

00:29:28.965 --> 00:29:30.610
Look it up in Memcache.

00:29:30.610 --> 00:29:32.540
If it's not there, re-perform
a query

00:29:32.540 --> 00:29:36.250
and set it into Memcache.

00:29:36.250 --> 00:29:39.580
Now that we have the list of
games, we have the keys of the

00:29:39.580 --> 00:29:42.590
playlist we need, the keys of
the opponents we want, so we

00:29:42.590 --> 00:29:45.780
can just group all of these keys
and perform one single

00:29:45.780 --> 00:29:49.320
call to the Datastore to
retrieve all of the models.

00:29:49.320 --> 00:29:52.820
Finally, we just have to process
all of this data and

00:29:52.820 --> 00:29:55.690
move it into JSON to what we
want to send to the client.

00:29:55.690 --> 00:29:58.760
I will just spare
you this code.

00:29:58.760 --> 00:29:59.810
So that's it.

00:29:59.810 --> 00:30:04.010
We implemented a request
handler, and here is what real

00:30:04.010 --> 00:30:05.540
production code looks like.

00:30:05.540 --> 00:30:07.870
It's about 40 lines of code
to implement this

00:30:07.870 --> 00:30:09.510
and optimize this.

00:30:09.510 --> 00:30:11.890
And this has run billions
of times serving

00:30:11.890 --> 00:30:14.540
over 80 million users.

00:30:14.540 --> 00:30:17.680
So once we have this code ready,
all we have to do is

00:30:17.680 --> 00:30:21.350
hit Deploy and let App
Engine do its work.

00:30:21.350 --> 00:30:24.560
It will create the necessary
entries into the Datastore, it

00:30:24.560 --> 00:30:26.970
will spawn the necessary
instances as

00:30:26.970 --> 00:30:28.910
your traffic grows.

00:30:28.910 --> 00:30:32.625
So just sit and watch your
app scale effortlessly.

00:30:35.340 --> 00:30:37.520
Here are a few more things
I would like to share,

00:30:37.520 --> 00:30:39.780
especially with App
Engine developers.

00:30:39.780 --> 00:30:44.650
One of these is make use of
Memcache wisely because you

00:30:44.650 --> 00:30:47.770
will be allocated more space as
your app grows, but that's

00:30:47.770 --> 00:30:49.550
still limited.

00:30:49.550 --> 00:30:52.480
So if you put everything in it,
you will find that it's no

00:30:52.480 --> 00:30:54.690
longer efficient when
you reach really

00:30:54.690 --> 00:30:56.940
high traffic limits.

00:30:56.940 --> 00:31:00.280
One other thing is that you
should really only index what

00:31:00.280 --> 00:31:02.710
you really need to query
on your models.

00:31:02.710 --> 00:31:05.560
By default, everything is
indexed, and that's very

00:31:05.560 --> 00:31:06.540
convenient.

00:31:06.540 --> 00:31:10.160
But if your models are often
updated, that will be really

00:31:10.160 --> 00:31:13.050
expensive, and that
will significantly

00:31:13.050 --> 00:31:14.400
increase your bill.

00:31:14.400 --> 00:31:17.450
That's just an easy thing to
do, unindex what you don't

00:31:17.450 --> 00:31:19.410
need to query.

00:31:19.410 --> 00:31:23.300
Then don't worry about
documented quotas on the limit

00:31:23.300 --> 00:31:26.000
about App Engine, because they
are just there to make sure

00:31:26.000 --> 00:31:29.420
one single app doesn't
abuse any resources.

00:31:29.420 --> 00:31:32.660
But actually, for "SongPop,"
most of them have been

00:31:32.660 --> 00:31:35.170
increased more than
tenfold for us.

00:31:35.170 --> 00:31:39.270
So App Engine can really scale
more than the limits that are

00:31:39.270 --> 00:31:41.892
documented.

00:31:41.892 --> 00:31:44.840
Finally, we were pleasantly
surprised with the support we

00:31:44.840 --> 00:31:47.110
got with the Premier Accounts.

00:31:47.110 --> 00:31:50.250
You get to talk with qualified
people that are responsive,

00:31:50.250 --> 00:31:54.260
and they really give you useful
insights about what is

00:31:54.260 --> 00:31:57.760
going on in your application.

00:31:57.760 --> 00:32:00.130
So that was for the
technical part.

00:32:00.130 --> 00:32:02.730
Olivier can continue.

00:32:02.730 --> 00:32:05.700
OLIVIER MICHON: So to conclude,
I would like to say

00:32:05.700 --> 00:32:07.950
that App Engine really
allowed us to scale.

00:32:07.950 --> 00:32:11.220
Scale to us, it's not really
about not having to worry

00:32:11.220 --> 00:32:11.850
about hardware.

00:32:11.850 --> 00:32:13.860
We expect a lot more.

00:32:13.860 --> 00:32:17.630
When we worked on "SongPop,"
we worked less than three

00:32:17.630 --> 00:32:21.050
months on it with our
own two developers.

00:32:21.050 --> 00:32:23.690
We released it on iOS, Android,
and the web, so we

00:32:23.690 --> 00:32:26.960
were on a very tight schedule,
and we had no idea if it was

00:32:26.960 --> 00:32:28.410
going to succeed or not.

00:32:28.410 --> 00:32:32.100
But scaling means that it is
very important to us that we

00:32:32.100 --> 00:32:34.690
write a line of code the same
way if it's going to get

00:32:34.690 --> 00:32:37.250
executed 10 times or 10 billion
times, like Alexis

00:32:37.250 --> 00:32:38.370
showed you.

00:32:38.370 --> 00:32:40.800
Because once we release
"SongPop," it's when things

00:32:40.800 --> 00:32:42.070
really start for us.

00:32:42.070 --> 00:32:45.280
We're not shipping a
box and move on.

00:32:45.280 --> 00:32:48.340
We are shipping a first version
of our game, but it's

00:32:48.340 --> 00:32:49.730
more of a service.

00:32:49.730 --> 00:32:52.310
And actually, most of the
efforts we put into SongPop

00:32:52.310 --> 00:32:54.440
were after the launch.

00:32:54.440 --> 00:32:57.530
So it's very important, if you
want to keep your audience

00:32:57.530 --> 00:33:01.740
engaged, to release features
and features.

00:33:01.740 --> 00:33:04.920
Alexis here wrote most of the
back end code all by himself,

00:33:04.920 --> 00:33:08.560
and when we started scaling to
five million users, he was not

00:33:08.560 --> 00:33:10.580
worried about [INAUDIBLE] the
database or things like that.

00:33:10.580 --> 00:33:12.860
He was worried about the new
features that we wanted to

00:33:12.860 --> 00:33:15.840
implement to really keep the
momentum of our game.

00:33:15.840 --> 00:33:19.480
So this is what scaling means
to us, and I think it's very

00:33:19.480 --> 00:33:23.160
important for small
teams like us.

00:33:23.160 --> 00:33:25.230
Now I would like to mention
something about cost, because

00:33:25.230 --> 00:33:28.820
I think a lot of developers can
be worried about cost on

00:33:28.820 --> 00:33:31.320
App Engine because it has a
very different structure

00:33:31.320 --> 00:33:33.820
compared to what you
see elsewhere.

00:33:33.820 --> 00:33:36.230
But I want to tell you that even
for a game like us with

00:33:36.230 --> 00:33:39.210
more than 80 million people, and
we give the game for free

00:33:39.210 --> 00:33:43.340
to all of our users, we still
manage to make a profit.

00:33:43.340 --> 00:33:46.640
App Engine is not a prohibitive
cost at all.

00:33:46.640 --> 00:33:49.350
In terms of cost to us, it's
more of the cost of the missed

00:33:49.350 --> 00:33:50.510
opportunities.

00:33:50.510 --> 00:33:52.125
What would have happened
if we had crashed

00:33:52.125 --> 00:33:53.280
when we were growing?

00:33:53.280 --> 00:33:56.370
What would have happened if we
took six months or 10 months

00:33:56.370 --> 00:33:59.030
to deliver a full version
of the game?

00:33:59.030 --> 00:34:02.810
So this is really what
cost means to us.

00:34:02.810 --> 00:34:05.480
I would like to say one last
thing, one quick example about

00:34:05.480 --> 00:34:09.310
scaling with App Engine
with a little example.

00:34:09.310 --> 00:34:12.489
Every week in "SongPop," we
reset the score because we

00:34:12.489 --> 00:34:15.600
want to give you a chance, if
you lost against your friend

00:34:15.600 --> 00:34:18.389
the previous week, to
win the next week.

00:34:18.389 --> 00:34:21.159
So what happens is during a
period of time of around five

00:34:21.159 --> 00:34:25.210
minutes, we have tens of
millions of push notifications

00:34:25.210 --> 00:34:28.219
that are sent to our users
to re-engage them.

00:34:28.219 --> 00:34:30.989
It's a great and important way
for us to re-engage them at

00:34:30.989 --> 00:34:32.290
this point.

00:34:32.290 --> 00:34:36.170
But at the same time, what it
does, it's going to have a

00:34:36.170 --> 00:34:37.650
huge impact on our traffic.

00:34:37.650 --> 00:34:40.940
And for less than five minutes,
we go from, let's

00:34:40.940 --> 00:34:44.050
say, thousands of queries per
second to more than 10,000

00:34:44.050 --> 00:34:46.250
query per second
on App Engine.

00:34:46.250 --> 00:34:49.986
So it's very important to us
that during this time when we

00:34:49.986 --> 00:34:53.150
are re-engaging all of our users
and preparing them for

00:34:53.150 --> 00:34:56.565
the next week so they have
a good user experience.

00:34:56.565 --> 00:34:59.390
For that, App Engine is perfect
because it autoscales

00:34:59.390 --> 00:35:02.420
and it autoscales very fast,
which means that it pumps new

00:35:02.420 --> 00:35:06.390
instances very fast because
they are so lightweight.

00:35:06.390 --> 00:35:09.450
So we are pretty confident to
say is that App Engine was

00:35:09.450 --> 00:35:12.220
very instrumental in the success
of "SongPop," from

00:35:12.220 --> 00:35:17.820
fast prototyping to scale
to 8 million users.

00:35:17.820 --> 00:35:19.880
Last slide.

00:35:19.880 --> 00:35:23.160
We are all day in the Sandbox
with Alexis, so

00:35:23.160 --> 00:35:24.590
it's just over there.

00:35:24.590 --> 00:35:25.750
Don't hesitate to stop by.

00:35:25.750 --> 00:35:29.520
We are very happy to share our
experience and more details

00:35:29.520 --> 00:35:31.560
about what we are doing.

00:35:31.560 --> 00:35:34.940
Of course, we can take also
questions after this

00:35:34.940 --> 00:35:36.130
presentation.

00:35:36.130 --> 00:35:38.260
And we have more projects
coming, so we are working on

00:35:38.260 --> 00:35:41.000
more things in the next few
weeks and few months, and they

00:35:41.000 --> 00:35:43.766
are all going to be powered with
Google Cloud Platform.

00:35:43.766 --> 00:35:45.172
And that's it.

00:35:45.172 --> 00:35:46.620
I'll let Chris talk.

00:35:46.620 --> 00:35:47.090
Thanks.

00:35:47.090 --> 00:35:52.740
[APPLAUSE]

00:35:52.740 --> 00:35:55.310
CHRIS ELLIOTT: It's absolutely
amazing talking to developers

00:35:55.310 --> 00:35:57.830
and hearing these same kind of
stories again and again.

00:35:57.830 --> 00:36:00.610
And the fact that it was mainly
one person scaling to

00:36:00.610 --> 00:36:03.850
code that executes 11 billion
times without any major

00:36:03.850 --> 00:36:07.210
issues, that's absolutely insane
and really highlights

00:36:07.210 --> 00:36:08.590
the benefits of the platform.

00:36:08.590 --> 00:36:11.050
And it was funny how you guys
threw in the, we are hiring

00:36:11.050 --> 00:36:14.050
note, because we see such a
huge demand for App Engine

00:36:14.050 --> 00:36:14.820
developers.

00:36:14.820 --> 00:36:17.200
If you're a qualified App Engine
developer, please give

00:36:17.200 --> 00:36:19.280
us your resume because we have
tons of people that keep

00:36:19.280 --> 00:36:22.120
asking us time and time
and time again.

00:36:22.120 --> 00:36:23.710
So it's great.

00:36:23.710 --> 00:36:25.610
And that saying, code,
deploy, and enjoy.

00:36:25.610 --> 00:36:28.440
When I first read it, that's an
absolutely amazing way of

00:36:28.440 --> 00:36:29.140
phrasing it.

00:36:29.140 --> 00:36:32.380
And so if you see that at next
I/O as more an official

00:36:32.380 --> 00:36:35.590
keynote or anything, you'll be
firsthand witnesses to where

00:36:35.590 --> 00:36:38.480
the origin of that saying
comes from.

00:36:38.480 --> 00:36:42.780
So last is our final reference
architecture, and this is

00:36:42.780 --> 00:36:45.360
really dealing with dedicated
game servers on the platform

00:36:45.360 --> 00:36:48.840
and harnessing the power
of Compute Engine.

00:36:48.840 --> 00:36:53.360
And I play mobile games
all day long.

00:36:53.360 --> 00:36:56.170
I realize my boss is here, but
I do play games all day long.

00:36:56.170 --> 00:36:57.650
Luckily, it's part of my job.

00:36:57.650 --> 00:37:01.890
But when I get home, I sit down,
I boot up my gaming PC,

00:37:01.890 --> 00:37:04.550
and I jump in for some real
time, competitive, player

00:37:04.550 --> 00:37:07.090
versus player, 64 people
on a battlefield,

00:37:07.090 --> 00:37:08.450
all just going crazy.

00:37:08.450 --> 00:37:11.020
And that is really the other
side of gaming that you see a

00:37:11.020 --> 00:37:13.700
lot of people having a blast
with, and that is directly

00:37:13.700 --> 00:37:17.140
what we're targeting with this
reference architecture.

00:37:17.140 --> 00:37:20.080
And so it's creating a full
featured game experience that

00:37:20.080 --> 00:37:23.070
has all the functionality you
expect, and once again, being

00:37:23.070 --> 00:37:25.215
scalable in a way that
makes a lot of sense.

00:37:27.730 --> 00:37:30.780
So with that, once again, we
created a sample application,

00:37:30.780 --> 00:37:33.060
and this is the sample
application we put together.

00:37:33.060 --> 00:37:35.790
You may recognize GRITS from
last I/O if you were here or

00:37:35.790 --> 00:37:39.050
watched any of the talks,
and it's essentially an

00:37:39.050 --> 00:37:43.820
application to highlight HTML5
player versus player NoJS.

00:37:43.820 --> 00:37:47.026
And we took this core outline,
and then we really applied a

00:37:47.026 --> 00:37:48.860
lot of the scalability concepts
we're going to talk

00:37:48.860 --> 00:37:50.980
to, to the application
to show you exactly

00:37:50.980 --> 00:37:51.940
what it looks like.

00:37:51.940 --> 00:37:55.690
And so we'll jump over to
a demo real quick here.

00:37:55.690 --> 00:37:56.650
So this is what it looks like.

00:37:56.650 --> 00:37:58.555
You basically log in, and you're
hitting App Engine, and

00:37:58.555 --> 00:38:01.150
you can see a bunch of game
servers that are allocated and

00:38:01.150 --> 00:38:03.130
how many people are playing.

00:38:03.130 --> 00:38:05.760
From there, you can directly
jump in and do a quick match,

00:38:05.760 --> 00:38:08.620
or you can find a game with a
reasonable number of players.

00:38:08.620 --> 00:38:10.070
So if I'm brand new, I'm
probably going to want to play

00:38:10.070 --> 00:38:12.250
in a small server just I
can pick up the game.

00:38:12.250 --> 00:38:14.200
And from there, you'll notice
we're actually no longer on

00:38:14.200 --> 00:38:14.690
App Engine.

00:38:14.690 --> 00:38:17.410
We're actually at the IP address
of Compute Engine.

00:38:17.410 --> 00:38:19.290
Obviously, there's lots of ways
of doing it, but this is

00:38:19.290 --> 00:38:21.420
just a very verbose way of
showing you what's actually

00:38:21.420 --> 00:38:22.800
happening under the covers.

00:38:22.800 --> 00:38:25.690
From there, you jump in, start
a quick game, and all of the

00:38:25.690 --> 00:38:28.370
assets will be pulled down
from the server--

00:38:28.370 --> 00:38:30.960
so the media, the music,
all of the graphics--

00:38:30.960 --> 00:38:33.550
onto the web browser
client here.

00:38:33.550 --> 00:38:35.790
And while that's happening-- it
usually takes a little bit

00:38:35.790 --> 00:38:38.620
longer up here on stage
on the Wi-Fi--

00:38:38.620 --> 00:38:40.410
we also have an admin console
that you can log

00:38:40.410 --> 00:38:41.540
into and see here.

00:38:41.540 --> 00:38:43.700
And this allows you to start
up a cluster, spin down a

00:38:43.700 --> 00:38:46.920
cluster, and it's also a great
place to go to experiment with

00:38:46.920 --> 00:38:49.650
autoscaling, which we actually
implemented in here as well.

00:38:49.650 --> 00:38:53.230
So after the average load on the
server passes 80%, you'll

00:38:53.230 --> 00:38:55.880
end up adding new servers
automatically and spinning up

00:38:55.880 --> 00:38:57.140
to handle the number
of players who

00:38:57.140 --> 00:38:59.720
keep joining the game.

00:38:59.720 --> 00:39:01.800
So if we jump back,
we should be in.

00:39:01.800 --> 00:39:02.800
And basically, we're in.

00:39:02.800 --> 00:39:05.730
So you respond, and
it's fairly basic.

00:39:05.730 --> 00:39:07.830
It's highlighting some cutting
edge web technologies.

00:39:07.830 --> 00:39:08.820
I mean, it's developed
by Google.

00:39:08.820 --> 00:39:11.460
We don't have a massive team
of AAA developers.

00:39:11.460 --> 00:39:13.610
But it kind of highlights
running around, real time

00:39:13.610 --> 00:39:15.530
motion, shooting, et cetera.

00:39:15.530 --> 00:39:16.830
A bunch of people can
join in and play.

00:39:16.830 --> 00:39:18.750
And it's always really funny
after showing this in a

00:39:18.750 --> 00:39:21.690
presentation, especially at
Google, usually I look in

00:39:21.690 --> 00:39:23.820
afterwards and there's 50 people
playing, even though

00:39:23.820 --> 00:39:26.030
there's somebody else up
presenting afterwards.

00:39:26.030 --> 00:39:28.130
It's kind of fun to see people
get in and really have fun

00:39:28.130 --> 00:39:30.250
with the application.

00:39:30.250 --> 00:39:33.240
And so jumping back to the
slides, all of this source

00:39:33.240 --> 00:39:37.120
code is actually open sourced as
of two days ago, so you can

00:39:37.120 --> 00:39:39.120
go in, pick it up, start playing
with it, and get a

00:39:39.120 --> 00:39:41.100
really quick way to start
scaling on the platform with

00:39:41.100 --> 00:39:42.480
dedicated game servers.

00:39:42.480 --> 00:39:45.190
And swap in whatever you want
to replace the game assets

00:39:45.190 --> 00:39:47.330
that we provide.

00:39:47.330 --> 00:39:50.540
So with the architecture, the
big difference here when you

00:39:50.540 --> 00:39:53.310
look at the devices is it's
no longer mobile devices.

00:39:53.310 --> 00:39:54.460
You're looking at
everything from

00:39:54.460 --> 00:39:56.340
gaming PCs, to web browser.

00:39:56.340 --> 00:39:59.060
It's up to you as a game
developer to really use what

00:39:59.060 --> 00:40:01.250
technology makes sense for the
game you're developing and the

00:40:01.250 --> 00:40:03.910
players that will be using it.

00:40:03.910 --> 00:40:05.940
From that point on to the magic
of Cloud Endpoints,

00:40:05.940 --> 00:40:08.350
really connecting to Server
Matchmaking, and this can be

00:40:08.350 --> 00:40:10.450
as simple or complex
as you want.

00:40:10.450 --> 00:40:13.020
It could be, I want to play
Capture the Flag with people

00:40:13.020 --> 00:40:15.580
of reasonable skill nearby, and
have all the matchmaking

00:40:15.580 --> 00:40:18.240
logic to make that happen and
return a single IP address to

00:40:18.240 --> 00:40:19.200
the client.

00:40:19.200 --> 00:40:21.370
Otherwise, you could do things
of just give a large list of

00:40:21.370 --> 00:40:24.040
IP addresses in a region and
allow the client to go in, see

00:40:24.040 --> 00:40:26.420
which one has a lower latency,
and join whatever map they

00:40:26.420 --> 00:40:27.290
choose to play.

00:40:27.290 --> 00:40:29.660
That's just one of the many ways
of building it out, and

00:40:29.660 --> 00:40:32.490
the key aspect is App Engine
has a scalable component to

00:40:32.490 --> 00:40:35.380
really scale up and provide
the technology to power

00:40:35.380 --> 00:40:36.930
whatever type of matchmaking
algorithm

00:40:36.930 --> 00:40:39.200
you choose to implement.

00:40:39.200 --> 00:40:42.010
From there, you saw on GRITS
what we looked at, very

00:40:42.010 --> 00:40:42.790
straightforward.

00:40:42.790 --> 00:40:44.870
List of IP addresses and
also just Quick Match.

00:40:47.770 --> 00:40:50.610
And so from there, this is
really where the magic happens

00:40:50.610 --> 00:40:52.660
and where a game developer
should spend the majority of

00:40:52.660 --> 00:40:56.080
their time, is really focusing
on creating the core game play

00:40:56.080 --> 00:40:58.110
experience that keeps people
riveted on the

00:40:58.110 --> 00:40:59.110
edge of their seats.

00:40:59.110 --> 00:41:00.920
And so that's really connecting
your game clients

00:41:00.920 --> 00:41:04.110
to the over full duplex sockets
to the game engines

00:41:04.110 --> 00:41:06.910
running on Compute Engine, and
having that real time gaming,

00:41:06.910 --> 00:41:09.740
low latency, all the benefits
of the platform there are

00:41:09.740 --> 00:41:13.150
really what power these
type of applications.

00:41:13.150 --> 00:41:15.420
And what's really interesting
here as well is as you start

00:41:15.420 --> 00:41:17.940
to grow, you can increase
capacity in different regions

00:41:17.940 --> 00:41:19.610
and you're not necessarily tied
to being overprovisioned

00:41:19.610 --> 00:41:23.690
in an area where it turns out
your game is not as popular.

00:41:23.690 --> 00:41:26.070
Next up, going back to App
Engine, a lot of cases you

00:41:26.070 --> 00:41:27.500
have in game requests.

00:41:27.500 --> 00:41:29.920
So it could be something as
simple as at the end of the

00:41:29.920 --> 00:41:32.260
match, you have a bunch of
players, and you want to keep

00:41:32.260 --> 00:41:34.300
track of their scores,
kill death ratios, et

00:41:34.300 --> 00:41:35.340
cetera, long term.

00:41:35.340 --> 00:41:37.530
That's a great place to go,
post it to App Engine.

00:41:37.530 --> 00:41:39.600
That can all scale up and keep
track of all of the user

00:41:39.600 --> 00:41:40.800
profiles there.

00:41:40.800 --> 00:41:42.810
Otherwise, if you're doing
things like a marketplace,

00:41:42.810 --> 00:41:45.050
it's a great place to go back
and verify that somebody has

00:41:45.050 --> 00:41:47.860
purchased the plus five
sword of greatness.

00:41:47.860 --> 00:41:50.150
All of the infrastructure, once
again, can support those

00:41:50.150 --> 00:41:51.590
full featured functionality
you'd

00:41:51.590 --> 00:41:54.190
expect for in game requests.

00:41:54.190 --> 00:41:56.600
Up next, the final component
of the App Engine

00:41:56.600 --> 00:41:59.840
implementation here for the
Server Matchmaking is really

00:41:59.840 --> 00:42:02.610
the virtual machine
orchestration, so really

00:42:02.610 --> 00:42:07.660
scaling up and scaling down as
your player base grows, and

00:42:07.660 --> 00:42:08.940
scaling in a way that
makes sense.

00:42:08.940 --> 00:42:11.480
So you can even do some more
complex logic that, for

00:42:11.480 --> 00:42:14.310
example, if you notice it's
nighttime, all the gamers have

00:42:14.310 --> 00:42:16.320
gone to sleep at 5:00 AM and
have a bunch of excess

00:42:16.320 --> 00:42:18.430
capacity, it's very
straightforward to then remove

00:42:18.430 --> 00:42:20.800
those servers from matchmaking
and terminate them and bring

00:42:20.800 --> 00:42:22.790
them back when the players
come back next night.

00:42:22.790 --> 00:42:25.400
And with the sub-hour billing
that we announced yesterday as

00:42:25.400 --> 00:42:27.840
well, it makes it even easier
to start to build out these

00:42:27.840 --> 00:42:29.800
autoscaling algorithms because
you're not worried about

00:42:29.800 --> 00:42:31.830
having an instance provisioned
for an hour and being charged

00:42:31.830 --> 00:42:32.030
for an hour.

00:42:32.030 --> 00:42:34.420
You're only charged for the
minutes that it's actually up

00:42:34.420 --> 00:42:36.820
and running, which makes this a
lot easier to implement and

00:42:36.820 --> 00:42:40.550
reduce the complexity there.

00:42:40.550 --> 00:42:45.030
So we saw this on GRITS, what it
looked like, and it's very

00:42:45.030 --> 00:42:45.770
straightforward.

00:42:45.770 --> 00:42:47.690
This actually, Admin Console
allows you to play with your

00:42:47.690 --> 00:42:49.190
autoscaling algorithms
as well.

00:42:49.190 --> 00:42:51.610
So you can go in, jump, set your
load, and then watch the

00:42:51.610 --> 00:42:54.950
autoscaling algorithms take
place and scale up the number

00:42:54.950 --> 00:42:57.260
of instances running.

00:42:57.260 --> 00:43:00.090
And finally, the last bit
really is that MapReduce

00:43:00.090 --> 00:43:04.320
dynamic duo between MapReduce
and BigQuery, and using this

00:43:04.320 --> 00:43:06.640
powerful technology to get a lot
of insights into what your

00:43:06.640 --> 00:43:08.020
players are doing.

00:43:08.020 --> 00:43:10.800
And for those of you who have
been taking pictures the

00:43:10.800 --> 00:43:13.160
entire time, I feel bad, but
this is the final slide.

00:43:13.160 --> 00:43:15.410
I'm not going to add any more
components just to keep

00:43:15.410 --> 00:43:16.940
trolling everyone.

00:43:16.940 --> 00:43:19.970
And with this, if you're running
game servers and you

00:43:19.970 --> 00:43:22.090
have tens of thousands of
instances, which a lot of

00:43:22.090 --> 00:43:24.990
these games are scaling up to,
you have a huge amount of game

00:43:24.990 --> 00:43:27.590
logs, and that's a great place
to put them in cloud storage

00:43:27.590 --> 00:43:29.925
and then run a lot more complex
processing over them

00:43:29.925 --> 00:43:31.880
to get those insights you
really need as a game

00:43:31.880 --> 00:43:34.640
developer to be successful.

00:43:34.640 --> 00:43:35.880
And I kind of lied, actually.

00:43:35.880 --> 00:43:39.400
Glass integration, once again,
think about all of these

00:43:39.400 --> 00:43:42.190
components, all this cool game
play that is possible.

00:43:42.190 --> 00:43:44.470
It works perfectly on the
platform as well.

00:43:44.470 --> 00:43:46.590
And actually with Glass, if
anybody in the room creates a

00:43:46.590 --> 00:43:49.090
Brick Breaker application,
please let me know.

00:43:49.090 --> 00:43:50.740
I've been dying to have Brick
Breaker because that would

00:43:50.740 --> 00:43:53.400
actually work perfectly on the
[INAUDIBLE] scrolling forward

00:43:53.400 --> 00:43:53.970
and backwards.

00:43:53.970 --> 00:43:57.230
So let me know if you
come up with that.

00:43:57.230 --> 00:44:00.610
So that really is just the
matchmaking aspect.

00:44:00.610 --> 00:44:03.420
And really, it's about creating
a full featured game,

00:44:03.420 --> 00:44:06.800
keeping all of the user's
information around, all of

00:44:06.800 --> 00:44:09.930
their stats, et cetera, to
having friends, to creating a

00:44:09.930 --> 00:44:12.170
marketplace, to creating events,
social engagement, all

00:44:12.170 --> 00:44:14.760
of these features that games
really need to be successful

00:44:14.760 --> 00:44:17.310
long term, App Engine is a great
place to build out and

00:44:17.310 --> 00:44:18.610
augment the functionality.

00:44:18.610 --> 00:44:20.390
Just like with FreshPlanet, they
launched, and then they

00:44:20.390 --> 00:44:22.570
could quickly iterate, add new
features, and really keep

00:44:22.570 --> 00:44:23.510
people engaged.

00:44:23.510 --> 00:44:25.540
Those sort of concepts also
apply to this type of

00:44:25.540 --> 00:44:29.010
dedicated server
infrastructure.

00:44:29.010 --> 00:44:34.510
And so to wrap up, time and time
again, we see that from

00:44:34.510 --> 00:44:38.140
small indie developers to AAA
game studios, the Google Cloud

00:44:38.140 --> 00:44:41.020
Platform is the place for
cutting edge developers to

00:44:41.020 --> 00:44:43.450
build out these really
innovative experiences, and we

00:44:43.450 --> 00:44:45.610
continue to see people really
pushing the boundaries and

00:44:45.610 --> 00:44:46.620
blowing us away with
what they're

00:44:46.620 --> 00:44:49.850
building on the platform.

00:44:49.850 --> 00:44:53.860
And the Solution Papers for the
mobile architecture, the

00:44:53.860 --> 00:44:56.300
iOS Push Notification, and the
Dedicated Game Server are

00:44:56.300 --> 00:44:59.300
already published or will be
published very soon to the

00:44:59.300 --> 00:45:00.650
Cloud Platform website.

00:45:00.650 --> 00:45:01.910
If you go to the website,
there should

00:45:01.910 --> 00:45:02.880
be Resources button.

00:45:02.880 --> 00:45:05.570
You can click there, and all
the papers will show up.

00:45:05.570 --> 00:45:07.580
Otherwise, keep an eye on the
newsletter for a lot of the

00:45:07.580 --> 00:45:09.600
latest up to date information
there.

00:45:09.600 --> 00:45:11.390
Otherwise, the sample
applications are all

00:45:11.390 --> 00:45:12.340
available on GitHub.

00:45:12.340 --> 00:45:14.110
So the GRITS one
is live today.

00:45:14.110 --> 00:45:16.640
The Mobile Backend Starter
is ready there as well.

00:45:16.640 --> 00:45:19.270
And the mobile gaming one, the
riddle game, if you really

00:45:19.270 --> 00:45:21.240
want to know what the last few
riddles are, should be

00:45:21.240 --> 00:45:23.330
published pretty soon, and we'll
announce that in the

00:45:23.330 --> 00:45:25.930
newsletter as well.

00:45:25.930 --> 00:45:28.090
And there's other relevant
I/O sessions as well.

00:45:28.090 --> 00:45:29.680
I've gone through and
talked to the teams

00:45:29.680 --> 00:45:30.860
building these out.

00:45:30.860 --> 00:45:32.820
Today later on, there's
one on mobile,

00:45:32.820 --> 00:45:33.960
From Nothing to Nirvana.

00:45:33.960 --> 00:45:36.760
And it's a really great example
of how is very easy to

00:45:36.760 --> 00:45:39.200
get up and running and start
building out an application

00:45:39.200 --> 00:45:43.730
that harnesses the power of App
Engine to really create a

00:45:43.730 --> 00:45:45.030
scalable game.

00:45:45.030 --> 00:45:48.520
Otherwise tomorrow, the OAuth
talk is a great way to see how

00:45:48.520 --> 00:45:51.510
all of these components really
fit together and solve complex

00:45:51.510 --> 00:45:53.800
problems, and it is
very seamless.

00:45:53.800 --> 00:45:55.820
This is the talk that justifies
how many times I've

00:45:55.820 --> 00:45:58.530
been using the word "seamless."
And also, the

00:45:58.530 --> 00:46:00.120
10:00 AM talk is really cool.

00:46:00.120 --> 00:46:02.530
It's with Game Sys, and they
talk about building out a

00:46:02.530 --> 00:46:04.090
massive scalable infrastructure
and how they

00:46:04.090 --> 00:46:06.490
really harness the power of
BigQuery to get some really

00:46:06.490 --> 00:46:07.310
cool insights.

00:46:07.310 --> 00:46:08.450
It's a really good talk.

00:46:08.450 --> 00:46:12.530
And yesterday, JAM with
Chrome had a talk.

00:46:12.530 --> 00:46:15.570
Really cool, since we had a
quote in the presentation,

00:46:15.570 --> 00:46:17.330
highlights one of those cool
things that people are

00:46:17.330 --> 00:46:18.100
building out.

00:46:18.100 --> 00:46:20.230
And even the slot car racer that
you saw in the keynote as

00:46:20.230 --> 00:46:22.250
well, that's Compute Engine,
App Engine, really

00:46:22.250 --> 00:46:24.770
highlighting that dedicated
server aspect.

00:46:24.770 --> 00:46:26.580
You could talk to Ed as well if
you'd like more information

00:46:26.580 --> 00:46:29.100
about that.

00:46:29.100 --> 00:46:30.335
And that's really it.

00:46:30.335 --> 00:46:33.880
I'd like to invite Alexis and
Olivier back up to the stage,

00:46:33.880 --> 00:46:36.150
and we'll take any questions
that you have.

00:46:36.150 --> 00:46:38.780
There's microphones on either
side, so please line up.

00:46:38.780 --> 00:46:41.340
Otherwise, please fill out the
survey when you leave and

00:46:41.340 --> 00:46:44.900
rate, and we'll keep you up to
date on the latest status of

00:46:44.900 --> 00:46:46.400
the riddles.

00:46:46.400 --> 00:46:46.970
Yeah, question.

00:46:46.970 --> 00:46:52.900
[APPLAUSE]

00:46:52.900 --> 00:46:53.250
AUDIENCE: Hi.

00:46:53.250 --> 00:46:57.570
I saw you were using cloud
storage BigQuery to store, I

00:46:57.570 --> 00:46:59.570
guess, all the game
information.

00:46:59.570 --> 00:47:02.665
But why not use Google SQL?

00:47:02.665 --> 00:47:06.490
Is it because [INAUDIBLE] scale
the same, in which case,

00:47:06.490 --> 00:47:09.010
we need to use either of them?

00:47:09.010 --> 00:47:09.360
CHRIS ELLIOTT: Yeah.

00:47:09.360 --> 00:47:11.520
So the question is, why aren't
you using Cloud SQL for some

00:47:11.520 --> 00:47:12.990
of this analysis and insight?

00:47:12.990 --> 00:47:14.880
And that's actually another
perfectly good option that you

00:47:14.880 --> 00:47:17.150
can put in there if you really
are familiar with using SQL,

00:47:17.150 --> 00:47:19.210
you need a database that
scales and manages.

00:47:19.210 --> 00:47:22.090
And if your data sets are
reasonable size, that's great.

00:47:22.090 --> 00:47:24.360
The reason we put BigQuery in
here is really, you're looking

00:47:24.360 --> 00:47:26.820
at billions and billions and
billions of rows of data.

00:47:26.820 --> 00:47:28.890
And once you start to put that
size of data in a managed

00:47:28.890 --> 00:47:31.470
service like Cloud SQL, it's
really going to start to break

00:47:31.470 --> 00:47:33.840
down because SQL is just not
designed for that kind of data

00:47:33.840 --> 00:47:34.680
processing.

00:47:34.680 --> 00:47:36.760
Whereas if you read the Dremel
white paper, it's amazing

00:47:36.760 --> 00:47:38.970
technology we have that's really
making a possible.

00:47:38.970 --> 00:47:41.720
AUDIENCE: So basically, it would
be just a scaling issue?

00:47:41.720 --> 00:47:42.360
CHRIS ELLIOTT: Yeah.

00:47:42.360 --> 00:47:44.730
It's really being able to get
a lot of big data insight.

00:47:44.730 --> 00:47:49.240
I mean, MySQL and big data
usually don't mix frequently.

00:47:49.240 --> 00:47:50.234
AUDIENCE: Thank you.

00:47:50.234 --> 00:47:52.050
CHRIS ELLIOTT: Yeah,
no problem.

00:47:52.050 --> 00:47:53.580
Yeah?

00:47:53.580 --> 00:47:53.940
AUDIENCE: Hi.

00:47:53.940 --> 00:47:56.690
I'm Simon [? Peter ?] from
Quebec City in Canada.

00:47:56.690 --> 00:47:57.060
CHRIS ELLIOTT: Cool.

00:47:57.060 --> 00:47:58.300
I'm a Canadian as well.

00:47:58.300 --> 00:47:59.260
AUDIENCE: Nice.

00:47:59.260 --> 00:48:02.980
My question is for the "SongPop"
application.

00:48:02.980 --> 00:48:07.040
How do you manage to get
"SongPop" profitable, even

00:48:07.040 --> 00:48:10.190
though you make very
heavy usage of

00:48:10.190 --> 00:48:11.925
the App Engine platform?

00:48:15.190 --> 00:48:16.920
OLIVIER MICHON: So we have
different ways we monetize.

00:48:16.920 --> 00:48:18.640
Again, we have some advertising
on the free

00:48:18.640 --> 00:48:22.340
version, we have in-app
purchase, and we have these

00:48:22.340 --> 00:48:23.170
kind of different things.

00:48:23.170 --> 00:48:25.180
I think it's a basic
business model.

00:48:25.180 --> 00:48:29.160
But my point was that even
with just an average

00:48:29.160 --> 00:48:32.430
monetization for an app,
App Engine cost is not

00:48:32.430 --> 00:48:32.970
prohibitive.

00:48:32.970 --> 00:48:35.760
You still manage to be
profitable for an app that you

00:48:35.760 --> 00:48:38.940
essentially distribute free
for everyone and just put

00:48:38.940 --> 00:48:39.840
advertising in it.

00:48:39.840 --> 00:48:42.110
AUDIENCE: Thank you.

00:48:42.110 --> 00:48:44.480
CHRIS ELLIOTT: Cool.

00:48:44.480 --> 00:48:47.430
Nobody asked about Google
Play Services?

00:48:47.430 --> 00:48:50.810
I even created a slide right
after this one for a segue.

00:48:50.810 --> 00:48:52.310
Should have planted
a question.

00:48:52.310 --> 00:48:53.880
Well, I'll show you
the slide anyways.

00:48:53.880 --> 00:48:56.180
So if you're thinking about
Google Play as well, how that

00:48:56.180 --> 00:48:59.220
fits in, it's really kind of
looking at these dimensions.

00:48:59.220 --> 00:49:01.300
Flexibility, you have increased
flexibility as you

00:49:01.300 --> 00:49:03.450
start to use App Engine and
Compute Engine, you have more

00:49:03.450 --> 00:49:05.320
and more freedom to do
anything you want.

00:49:05.320 --> 00:49:08.040
But it's much easier to develop
with something like

00:49:08.040 --> 00:49:09.830
Play if you're just a front
end mobile developer and

00:49:09.830 --> 00:49:11.890
quickly want a leaderboard
or stats.

00:49:11.890 --> 00:49:14.350
So the key option is you have
the flexibility to implement

00:49:14.350 --> 00:49:15.370
anything you want
on the platform.

00:49:15.370 --> 00:49:17.630
And it's up to you as a
developer to choose what tools

00:49:17.630 --> 00:49:19.750
best fit your use case, but we
have all of those tools to

00:49:19.750 --> 00:49:22.780
enable those next generation
experiences.

00:49:22.780 --> 00:49:24.030
So thank you for asking
that question.

00:49:28.460 --> 00:49:28.680
All right.

00:49:28.680 --> 00:49:29.860
Well thank you, everybody.

00:49:29.860 --> 00:49:36.310
[APPLAUSE]

