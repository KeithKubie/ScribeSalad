WEBVTT
Kind: captions
Language: en

00:00:02.801 --> 00:00:05.234
Thompson: Hello.
I'm Lilli Thompson,

00:00:05.234 --> 00:00:07.100
and this is Building
Game Development Tools

00:00:07.100 --> 00:00:10.767
with App Engine,
GWT, and WebGL.

00:00:10.767 --> 00:00:12.434
So if you want to give
feedback during the session,

00:00:12.434 --> 00:00:14.801
there's an official
SpeakerMeter page,

00:00:14.801 --> 00:00:16.801
and there are also
some official hashtags,

00:00:16.801 --> 00:00:18.334
if you want to
chat about it.

00:00:18.334 --> 00:00:20.000
And I'll show this slide
again at the end,

00:00:20.000 --> 00:00:24.367
if you don't get
the information right now.

00:00:24.367 --> 00:00:26.634
So first of all,
the structure of this talk.

00:00:26.634 --> 00:00:29.133
So I'll start out sort of
defining the problem space

00:00:29.133 --> 00:00:31.300
and talk about why we need
game development tools

00:00:31.300 --> 00:00:33.367
and why this particular
set of technologies

00:00:33.367 --> 00:00:35.834
is a good fit
for this problem.

00:00:35.834 --> 00:00:37.267
Then I'll show you
a demo of a couple of

00:00:37.267 --> 00:00:42.534
really good motivating use cases
of tools on these technologies,

00:00:42.534 --> 00:00:43.834
and then the second half
of the talk

00:00:43.834 --> 00:00:46.000
is really
the meat of things.

00:00:46.000 --> 00:00:48.200
It's the story of how
those demos were made.

00:00:48.200 --> 00:00:50.400
There were all sorts of things
I sort of stumbled into

00:00:50.400 --> 00:00:52.400
while I was developing,

00:00:52.400 --> 00:00:56.934
and it's about sharing
that development process.

00:00:56.934 --> 00:01:01.601
All right, so my background
is in console game development.

00:01:01.601 --> 00:01:03.567
Before joining Google
as a software engineer,

00:01:03.567 --> 00:01:06.334
I was the lead of tools
in central technology

00:01:06.334 --> 00:01:08.601
at Secret Level Sega,

00:01:08.601 --> 00:01:10.667
and game tools are something
I'm really interested in.

00:01:10.667 --> 00:01:13.234
It's something I've done
for a lot of my career.

00:01:13.234 --> 00:01:14.901
And when I came to Google
and started working

00:01:14.901 --> 00:01:18.133
with App Engine and GWT,
I was super excited,

00:01:18.133 --> 00:01:20.834
because these were
technological solutions

00:01:20.834 --> 00:01:24.067
to very real game programming
programs I'd had in the past.

00:01:24.067 --> 00:01:25.934
So the motivation
behind this talk

00:01:25.934 --> 00:01:29.467
is really sharing
that thought with you.

00:01:29.467 --> 00:01:31.400
This talk is for anyone
who's interested

00:01:31.400 --> 00:01:34.801
in game development tools,
and I expect a lot of people

00:01:34.801 --> 00:01:37.501
here to be interested
in browser games,

00:01:37.501 --> 00:01:39.267
but actually the same
technologies and techniques

00:01:39.267 --> 00:01:41.868
would work equally well
for mobile games

00:01:41.868 --> 00:01:45.701
or even some tools
for console games.

00:01:45.701 --> 00:01:47.133
So what are we
talking about?

00:01:47.133 --> 00:01:51.434
What exactly do I mean
by game development tool?

00:01:51.434 --> 00:01:53.100
Well, first, we should talk
about the type of data

00:01:53.100 --> 00:01:55.400
we're going to support,
and the kind of assets

00:01:55.400 --> 00:01:57.934
I'm talking about
are geometric assets.

00:01:57.934 --> 00:02:00.167
So you have
big mesh data.

00:02:00.167 --> 00:02:01.634
And the thing about
geometry data

00:02:01.634 --> 00:02:04.367
is that it is just
so much bigger than the stuff

00:02:04.367 --> 00:02:06.901
most people are used to
dealing with on the web.

00:02:06.901 --> 00:02:08.834
You've got these big
binary files

00:02:08.834 --> 00:02:10.667
and all this custom
logical data,

00:02:10.667 --> 00:02:12.734
like rigging data
and trigger data

00:02:12.734 --> 00:02:14.367
that doesn't have
a natural visualization

00:02:14.367 --> 00:02:16.300
for your tools to use.

00:02:16.300 --> 00:02:18.167
And on top of that, you've got
a lot of multimedia stuff

00:02:18.167 --> 00:02:20.868
like sound effects, and video,
and that kind of stuff.

00:02:20.868 --> 00:02:22.067
And on top of all that,

00:02:22.067 --> 00:02:24.067
all this complicated
multimedia data

00:02:24.067 --> 00:02:25.968
is connected together
in a big web.

00:02:25.968 --> 00:02:28.167
So for instance,
your character assets

00:02:28.167 --> 00:02:29.634
are going to
reference rigs.

00:02:29.634 --> 00:02:31.267
They might also
reference meshes.

00:02:31.267 --> 00:02:32.934
Your meshes might
reference materials.

00:02:32.934 --> 00:02:35.367
Your materials might reference
textures and shaders,

00:02:35.367 --> 00:02:36.534
even particle effects,
and sounds,

00:02:36.534 --> 00:02:38.067
and all that kind of stuff.

00:02:38.067 --> 00:02:41.234
So you've got complicated data
and complicated connectivity

00:02:41.234 --> 00:02:44.234
between that data.

00:02:44.234 --> 00:02:46.534
So you're going to need tools
to set all that up,

00:02:46.534 --> 00:02:49.334
and when I say game
development tool,

00:02:49.334 --> 00:02:52.067
probably the first thing on
a lot of people's minds

00:02:52.067 --> 00:02:53.367
is level editors,

00:02:53.367 --> 00:02:55.767
and level editors are
important and interesting,

00:02:55.767 --> 00:02:57.667
but I just wanted to point out
that that's just one

00:02:57.667 --> 00:03:00.334
of many types of tools
you might need.

00:03:00.334 --> 00:03:02.734
You might need a way to set up
your material bindings

00:03:02.734 --> 00:03:04.934
or define metadata
on your assets,

00:03:04.934 --> 00:03:07.234
or if you have any sort of
skeletal animation system,

00:03:07.234 --> 00:03:09.067
you might need
an HSM editor,

00:03:09.067 --> 00:03:10.367
or if you have cut scenes
in your game,

00:03:10.367 --> 00:03:12.701
you might need a cinematic
editor or logic editors.

00:03:12.701 --> 00:03:14.868
There are all kinds
of opportunities

00:03:14.868 --> 00:03:19.467
for different kinds of tools
on all scales.

00:03:19.467 --> 00:03:21.300
So what's interesting about
tools programming,

00:03:21.300 --> 00:03:23.367
with respect to
engine programming?

00:03:23.367 --> 00:03:24.634
And I point this out,

00:03:24.634 --> 00:03:26.834
because it's going
to affect your choice

00:03:26.834 --> 00:03:29.667
of technology platforms
for one or the other.

00:03:29.667 --> 00:03:32.601
And the thing about tools
is that in all likelihood,

00:03:32.601 --> 00:03:35.534
they're part of the process
of making your game,

00:03:35.534 --> 00:03:36.934
not part of the product
itself.

00:03:36.934 --> 00:03:39.400
You're probably not shipping
your tools.

00:03:39.400 --> 00:03:42.400
And what that means is that
for your game engine,

00:03:42.400 --> 00:03:44.501
you might be willing to go
through all sorts of contortions

00:03:44.501 --> 00:03:47.734
to wring every last bit of
performance out of the platform

00:03:47.734 --> 00:03:50.234
that you possibly can,
and you might be willing

00:03:50.234 --> 00:03:55.033
to sacrifice ease of development
for performance,

00:03:55.033 --> 00:03:57.367
and that would likely be
a pretty bad decision

00:03:57.367 --> 00:03:59.434
for designing your tools,

00:03:59.434 --> 00:04:01.901
because if the number one
priority for your game engine

00:04:01.901 --> 00:04:04.133
is performance,
then the number one priority

00:04:04.133 --> 00:04:06.234
for your tools
is probably something else.

00:04:06.234 --> 00:04:10.200
It's like rapid iteration time
or quick debugging.

00:04:10.200 --> 00:04:13.467
So the two different uses
really do have different

00:04:13.467 --> 00:04:15.467
technological priorities,

00:04:15.467 --> 00:04:18.100
and a different technology
platform is often warranted,

00:04:18.100 --> 00:04:20.167
and you see this
in the console games industry,

00:04:20.167 --> 00:04:21.567
where it's a really
popular choice

00:04:21.567 --> 00:04:24.200
to develop your game engine
in something really fast,

00:04:24.200 --> 00:04:26.901
like C or C++,
and then do your game tools

00:04:26.901 --> 00:04:28.234
in a different language
entirely,

00:04:28.234 --> 00:04:30.067
that's optimized
for these other concerns.

00:04:30.067 --> 00:04:32.667
For instance, it's really common
for console game studios

00:04:32.667 --> 00:04:36.200
to write their tools in C#.

00:04:36.200 --> 00:04:37.734
So if you've got
a browser game,

00:04:37.734 --> 00:04:39.000
you might be thinking
to yourself,

00:04:39.000 --> 00:04:41.767
"Well, my engine
is pretty small in scope,

00:04:41.767 --> 00:04:43.234
and my data
isn't too complicated.

00:04:43.234 --> 00:04:44.934
My team's pretty small.

00:04:44.934 --> 00:04:47.501
Maybe I can do all the data
setup and authoring I need to do

00:04:47.501 --> 00:04:49.934
just by hand authoring
a text file,

00:04:49.934 --> 00:04:51.534
something really,
really simple."

00:04:51.534 --> 00:04:53.601
If that's the scale
you're working on,

00:04:53.601 --> 00:04:56.434
do you still care about
game development tools?

00:04:56.434 --> 00:04:57.834
And the answer is yes.

00:04:57.834 --> 00:05:00.701
Yes, you absolutely
should care.

00:05:00.701 --> 00:05:04.400
It's true that web games
and mobile games

00:05:04.400 --> 00:05:06.434
and all these new media forms
of games, on the whole,

00:05:06.434 --> 00:05:08.267
are simpler today
than console games.

00:05:08.267 --> 00:05:12.167
There's no doubt about that,
but it is amazing how quickly

00:05:12.167 --> 00:05:15.367
the quality of the content
and the complexity are going up,

00:05:15.367 --> 00:05:19.067
and the expectations of users
are going up along with them.

00:05:19.067 --> 00:05:22.200
We saw this in the console games
industry about 20 years ago,

00:05:22.200 --> 00:05:23.734
when game engines
were much smaller,

00:05:23.734 --> 00:05:26.334
and the platforms had
a lot less power,

00:05:26.334 --> 00:05:28.534
and you could pretty much
just hack things together,

00:05:28.534 --> 00:05:30.334
and tools weren't
that big of a deal.

00:05:30.334 --> 00:05:32.033
And then year after year,
the consoles grew, and grew,

00:05:32.033 --> 00:05:33.501
and grew in power.

00:05:33.501 --> 00:05:36.868
And before anybody really knew
how to solve these problems well

00:05:36.868 --> 00:05:39.200
or acknowledge that they were
really important problems,

00:05:39.200 --> 00:05:41.133
there was this dramatic
need for tools,

00:05:41.133 --> 00:05:42.567
and the console industry
had to stop

00:05:42.567 --> 00:05:44.734
and do a lot of catching up
and learning.

00:05:44.734 --> 00:05:46.434
So you all should learn
from that.

00:05:46.434 --> 00:05:49.701
And even if you're doing a game
in the browser or a mobile game,

00:05:49.701 --> 00:05:52.133
and it seems simple today,
you will need tools,

00:05:52.133 --> 00:05:54.634
and good tools will increase
the quality of your content

00:05:54.634 --> 00:05:58.300
and the quality of your game.
I guarantee it.

00:05:58.300 --> 00:06:01.200
Okay, so hopefully,
we're all on the same page

00:06:01.200 --> 00:06:03.767
and think that developing tools
is a really important part

00:06:03.767 --> 00:06:06.067
of developing a game,
but there are many different

00:06:06.067 --> 00:06:07.868
platforms on which you could
write your tools.

00:06:07.868 --> 00:06:12.133
So why would you use
these particular technologies?

00:06:12.133 --> 00:06:14.000
So there are a couple of
key concerns

00:06:14.000 --> 00:06:15.734
for your tools platform.

00:06:15.734 --> 00:06:18.968
For one thing, you have to
consider the development skills

00:06:18.968 --> 00:06:20.701
your team has
and where you want them to grow,

00:06:20.701 --> 00:06:21.767
so what technologies
you think

00:06:21.767 --> 00:06:23.033
might be important
in the future.

00:06:23.033 --> 00:06:26.267
Sometimes, tools are a good way
to try things out.

00:06:26.267 --> 00:06:28.000
Tools are all about UIs,
so you're going to need

00:06:28.000 --> 00:06:30.901
some library with a lot of
widgets and text boxes,

00:06:30.901 --> 00:06:33.334
and list boxes.
You'll need all that.

00:06:33.334 --> 00:06:35.467
You also have to consider
setup overhead.

00:06:35.467 --> 00:06:37.634
So every time a new team member
joins your team,

00:06:37.634 --> 00:06:38.934
you're going to have to
get them set up

00:06:38.934 --> 00:06:41.467
with a development environment
for your game.

00:06:41.467 --> 00:06:43.534
And if it's a big complicated
install process,

00:06:43.534 --> 00:06:45.200
that's a lot of work for you.

00:06:45.200 --> 00:06:47.801
And also consider
that the trend in game art

00:06:47.801 --> 00:06:50.300
has been to working
with offsite artists,

00:06:50.300 --> 00:06:52.801
and that just underscores
the need for simplicity

00:06:52.801 --> 00:06:54.667
of setup of your tools.

00:06:54.667 --> 00:06:55.801
And then, as I mentioned,

00:06:55.801 --> 00:07:00.167
debugging is absolutely
top priority.

00:07:00.167 --> 00:07:02.567
So how does App Engine
fit into all this?

00:07:02.567 --> 00:07:05.300
Well, App Engine is Google's
cloud services framework.

00:07:05.300 --> 00:07:07.868
It's a set of APIs and tools
that help you

00:07:07.868 --> 00:07:10.434
build an application
and a way to host them,

00:07:10.434 --> 00:07:13.100
and I think the number one
reason you would want to use

00:07:13.100 --> 00:07:16.200
something like App Engine
is for collaboration.

00:07:16.200 --> 00:07:17.601
Really, the first reasons

00:07:17.601 --> 00:07:20.534
that you might want to use
App Engine are just reasons

00:07:20.534 --> 00:07:21.934
to put your tools
in the cloud,

00:07:21.934 --> 00:07:24.467
and it's to have things
in a collaborative environment.

00:07:24.467 --> 00:07:26.334
And we talked about the need
of ease of setup,

00:07:26.334 --> 00:07:27.834
and so if you have
things in a browser,

00:07:27.834 --> 00:07:30.067
there's no executable
for each user to install.

00:07:30.067 --> 00:07:31.234
There are no command line
arguments

00:07:31.234 --> 00:07:33.200
nor anything like that.
Setup is super easy.

00:07:33.200 --> 00:07:35.667
Everybody knows how
to use a browser.

00:07:35.667 --> 00:07:38.234
And then the thing that makes
App Engine particularly great

00:07:38.234 --> 00:07:41.100
for this use case is that,
like I mentioned,

00:07:41.100 --> 00:07:43.133
the tools are probably
not your product.

00:07:43.133 --> 00:07:45.534
You're busy making your game,
so you probably don't have

00:07:45.534 --> 00:07:48.267
a lot of time devoted
to buying hardware,

00:07:48.267 --> 00:07:51.033
and managing
an authentication system,

00:07:51.033 --> 00:07:53.400
and load balancing,
and all the kind of framework

00:07:53.400 --> 00:07:57.467
and boilerplate you need
to get set up for a web app.

00:07:57.467 --> 00:07:59.968
And one thing that App Engine
does really, really well

00:07:59.968 --> 00:08:02.567
is provide a lot
of supporting APIs

00:08:02.567 --> 00:08:05.033
and have a really good
new user setup.

00:08:05.033 --> 00:08:08.868
So App Engine is great
for this use.

00:08:08.868 --> 00:08:11.601
All right, so backends
and App Engine in the cloud,

00:08:11.601 --> 00:08:13.767
but there are many ways
to write the frontend UI

00:08:13.767 --> 00:08:16.767
for your web app,
so why would you use GWT?

00:08:16.767 --> 00:08:20.367
So GWT is Google's framework
for making web apps.

00:08:20.367 --> 00:08:24.033
It is a way to compile Java code
into JavaScript,

00:08:24.033 --> 00:08:26.901
that is optimized for
different browsers.

00:08:26.901 --> 00:08:28.834
And what's cool
about that?

00:08:28.834 --> 00:08:30.968
Well, what GWT really gives you

00:08:30.968 --> 00:08:32.934
is a scalable development
environment,

00:08:32.934 --> 00:08:36.067
and what I mean by that
is that JavaScript is great

00:08:36.067 --> 00:08:37.634
for rapid prototyping.

00:08:37.634 --> 00:08:39.000
That's one of the things
it's really good at.

00:08:39.000 --> 00:08:40.734
But if you have
a big application--

00:08:40.734 --> 00:08:44.033
and tools are big applications--
that have a lot of moving parts,

00:08:44.033 --> 00:08:45.367
going to live a long time,

00:08:45.367 --> 00:08:47.133
a lot of people are
going to work on it,

00:08:47.133 --> 00:08:48.501
you really benefit
from something

00:08:48.501 --> 00:08:50.334
with a little more structure,

00:08:50.334 --> 00:08:53.267
and that's exactly what
the Java of GWT gives you.

00:08:53.267 --> 00:08:56.334
You have all the idioms and
patterns of Java there to use,

00:08:56.334 --> 00:08:59.167
and yet it compiles
the JavaScript.

00:08:59.167 --> 00:09:01.767
And on top of that, GWT has
a lot of really nice widgets,

00:09:01.767 --> 00:09:04.267
if the ones that are there
don't suit your needs,

00:09:04.267 --> 00:09:06.100
you can write your own,
and that's really easy,

00:09:06.100 --> 00:09:09.334
and the whole thing
is open source.

00:09:09.334 --> 00:09:12.901
All right, so backends
and App Engine, UIs and GWT,

00:09:12.901 --> 00:09:15.501
but now we need a way
to render 3-D data.

00:09:15.501 --> 00:09:18.968
So why would you use WebGL
for that?

00:09:18.968 --> 00:09:22.234
Well, if you're a developer,
and you want to render 3-D data,

00:09:22.234 --> 00:09:24.300
there are pretty much
two games in town

00:09:24.300 --> 00:09:25.801
for working in a browser.

00:09:25.801 --> 00:09:29.133
There's Molehill, which is
the 3-D functionality in Flash,

00:09:29.133 --> 00:09:30.501
or there's WebGL.

00:09:30.501 --> 00:09:33.000
That's pretty much the choice
you're making.

00:09:33.000 --> 00:09:35.133
So why would you want
to use WebGL?

00:09:35.133 --> 00:09:38.934
Well, you know,
it's nice to have an API

00:09:38.934 --> 00:09:40.267
that doesn't require
any plugins.

00:09:40.267 --> 00:09:42.767
So the browser just renders
WebGL natively,

00:09:42.767 --> 00:09:44.300
and that's one less thing
to set up,

00:09:44.300 --> 00:09:48.200
and we talked about how
ease of setup was important.

00:09:48.200 --> 00:09:50.300
On top of that, you're
probably going to be mixing

00:09:50.300 --> 00:09:52.934
a lot of Java and JavaScript
for your application,

00:09:52.934 --> 00:09:55.334
because there are a lot of
cool JavaScript APIs

00:09:55.334 --> 00:09:57.000
that are useful to
game development.

00:09:57.000 --> 00:09:59.734
So having WebGL be in
JavaScript is really nice.

00:09:59.734 --> 00:10:01.701
Everything is sort of together
in JavaScript.

00:10:01.701 --> 00:10:04.567
You can use the browser
JavaScript debugging tools

00:10:04.567 --> 00:10:06.567
that you're already using
for everything else,

00:10:06.567 --> 00:10:09.634
not to mention there are some
really cool third party tools

00:10:09.634 --> 00:10:12.801
for WebGL debugging,
for instance, WebGL inspectors,

00:10:12.801 --> 00:10:14.501
one of them.

00:10:14.501 --> 00:10:16.834
And on top of that,
it's just a really fast,

00:10:16.834 --> 00:10:19.400
nice way
to do your drawing.

00:10:19.400 --> 00:10:20.834
All right,
so that's the background.

00:10:20.834 --> 00:10:26.367
Let me show you a demo of a tool
built using these technologies.

00:10:26.367 --> 00:10:31.067
Whoa, why am I
black screening?

00:10:31.067 --> 00:10:34.634
Aha.

00:10:34.634 --> 00:10:39.000
All right, so this is my demo,
and what this is,

00:10:39.000 --> 00:10:41.000
is just an asset
viewing tool.

00:10:41.000 --> 00:10:45.767
So the idea here is that
you sync to a version control,

00:10:45.767 --> 00:10:47.767
where you're probably checking
in all your assets,

00:10:47.767 --> 00:10:50.067
and then you can see them
in the browser.

00:10:50.067 --> 00:10:51.601
So you know, you have
a bunch of meshes.

00:10:51.601 --> 00:10:53.367
You can sort of page
through your data.

00:10:53.367 --> 00:10:56.734
This tool supports shaders,
textures, and meshes.

00:10:56.734 --> 00:10:59.467
So if I look at
my thumbnails,

00:10:59.467 --> 00:11:02.501
I can see that there's a bunch
of mesh data up at the top.

00:11:02.501 --> 00:11:04.000
Then I have a bunch
of textures.

00:11:04.000 --> 00:11:07.334
I have about 90 assets loaded
into this database right now,

00:11:07.334 --> 00:11:10.501
and then shaders
down at the bottom.

00:11:10.501 --> 00:11:14.300
And so the idea here is
that you can examine your data

00:11:14.300 --> 00:11:16.934
to see that it is
what you expect.

00:11:16.934 --> 00:11:18.667
And then over here
on the right,

00:11:18.667 --> 00:11:20.067
I have a property grid
sort of thing

00:11:20.067 --> 00:11:23.267
where I pulled out key
information about this object,

00:11:23.267 --> 00:11:25.501
including its name
and its ID

00:11:25.501 --> 00:11:26.968
and, of course,
its poly count.

00:11:26.968 --> 00:11:29.701
So you can see this model here
is only about 2,500 polygons.

00:11:29.701 --> 00:11:32.400
It's not particularly big.

00:11:32.400 --> 00:11:34.200
But if I contrast that with
this character model,

00:11:34.200 --> 00:11:36.734
this is about
130,000 polygons.

00:11:36.734 --> 00:11:38.801
You can see
he's very, very dense.

00:11:38.801 --> 00:11:41.100
You can sort of examine
his topology and wireframe,

00:11:41.100 --> 00:11:46.334
which sort of helps you get a
handle on what's going on here.

00:11:46.334 --> 00:11:49.400
This model is the biggest thing
I actually have in this database

00:11:49.400 --> 00:11:52.133
right now.
It's about 200,000 polygons,

00:11:52.133 --> 00:11:57.400
so dense that it's actually sort
of hard to parse in wireframe.

00:11:57.400 --> 00:11:58.834
So it's cool that you can
just sort of look

00:11:58.834 --> 00:12:02.534
at your stuff like that.

00:12:02.534 --> 00:12:06.901
So this was the very first
tool, just an asset viewer tool

00:12:06.901 --> 00:12:08.868
that I thought of
when I started trying to think

00:12:08.868 --> 00:12:11.434
about doing game tools
in a browser.

00:12:11.434 --> 00:12:13.067
And it was really
exciting to me,

00:12:13.067 --> 00:12:15.300
because this is a tool
I actually wanted to write

00:12:15.300 --> 00:12:16.601
at a previous game studio.

00:12:16.601 --> 00:12:18.834
We had this idea that we wanted
to write this tool,

00:12:18.834 --> 00:12:20.567
but we didn't have
the technology,

00:12:20.567 --> 00:12:24.467
and the strong motivation behind
this is that often time,

00:12:24.467 --> 00:12:26.901
big game studios,
a lot of little game studios,

00:12:26.901 --> 00:12:28.734
or studios work together
as partners,

00:12:28.734 --> 00:12:32.300
and it's really hard to see
what each other are doing,

00:12:32.300 --> 00:12:35.234
so it's very common to have
three different artists

00:12:35.234 --> 00:12:38.734
at three different developers
all making photorealistic rocks,

00:12:38.734 --> 00:12:41.968
or crates, or grass textures,
or any of this kind of stuff

00:12:41.968 --> 00:12:43.400
that's really common.

00:12:43.400 --> 00:12:46.167
And just having a way
to view it in the browser,

00:12:46.167 --> 00:12:47.534
which is what you can
do with App Engine,

00:12:47.534 --> 00:12:50.334
is a really strong
use case.

00:12:50.334 --> 00:12:52.501
Anyway, I was really excited
about just the asset viewer,

00:12:52.501 --> 00:12:54.801
but I added a few more sort
of little features

00:12:54.801 --> 00:12:59.234
that show off some things
that WebGL makes really easy.

00:12:59.234 --> 00:13:02.067
So for instance, if I look
at this Android model,

00:13:02.067 --> 00:13:03.834
this panel down here
at the bottom

00:13:03.834 --> 00:13:06.834
shows his material bindings,
and this is all live editable.

00:13:06.834 --> 00:13:08.968
And material binding tools
are something that you find

00:13:08.968 --> 00:13:10.467
throughout the games industry.

00:13:10.467 --> 00:13:12.133
It's something I've written
for a game studio before,

00:13:12.133 --> 00:13:14.934
so it's a really nice realistic
use case,

00:13:14.934 --> 00:13:18.467
and the idea is that his shader,
you can just go--

00:13:18.467 --> 00:13:20.067
browsing here shows me
all the shaders

00:13:20.067 --> 00:13:21.534
I have in my database.

00:13:21.534 --> 00:13:24.767
I can set him up
as a red shader,

00:13:24.767 --> 00:13:28.501
or I can render his surface
normals as RDB values,

00:13:28.501 --> 00:13:30.968
or I've got a nice vertex
displacement shader

00:13:30.968 --> 00:13:33.300
that makes him all noisy,

00:13:33.300 --> 00:13:34.734
or my favorite
is the tune shader.

00:13:34.734 --> 00:13:36.734
It makes him all cartoony.

00:13:36.734 --> 00:13:38.934
And the cool thing
is that all this shader code

00:13:38.934 --> 00:13:40.133
is live editable.

00:13:40.133 --> 00:13:41.667
So if you click over
to the shaders tab,

00:13:41.667 --> 00:13:42.934
you see the program

00:13:42.934 --> 00:13:45.467
that's actually running
on this asset right now,

00:13:45.467 --> 00:13:46.901
and on the left you have
the vertex shader,

00:13:46.901 --> 00:13:48.534
on the right you have
the fragment shader.

00:13:48.534 --> 00:13:54.534
And if I want to make him
a little redder, I can do so.

00:13:54.534 --> 00:13:57.701
Or if think his outline
should be a little heavier,

00:13:57.701 --> 00:14:00.868
I can change that.
So the thing about this,

00:14:00.868 --> 00:14:04.734
this is the sort of thing that
WebGL makes super easy to do,

00:14:04.734 --> 00:14:06.834
because all your shader code
in your programs,

00:14:06.834 --> 00:14:09.267
you can pass them around
as strings in JavaScript,

00:14:09.267 --> 00:14:11.467
and all your data
is right there in JavaScript.

00:14:11.467 --> 00:14:13.567
So writing an interactive
shader editor,

00:14:13.567 --> 00:14:15.367
which was something
that had been hard,

00:14:15.367 --> 00:14:18.501
the last time I tried to do it,
is really easy with WebGL.

00:14:18.501 --> 00:14:20.667
So it's a lot of fun.

00:14:20.667 --> 00:14:23.167
And then, of course,
the texture channels

00:14:23.167 --> 00:14:27.000
that are inputs to these shaders
area also live editable,

00:14:27.000 --> 00:14:29.734
so I can just put him back
to a flat shader and show, like,

00:14:29.734 --> 00:14:32.667
what if he were flat shaded
and made of brick

00:14:32.667 --> 00:14:34.200
or something like that?

00:14:34.200 --> 00:14:37.000
So it's all a really nice, easy
way to set up material bindings.

00:14:37.000 --> 00:14:40.701
And then I had one more use case
I wanted to show you,

00:14:40.701 --> 00:14:41.701
if you look
at this robot.

00:14:41.701 --> 00:14:43.000
And the idea--

00:14:43.000 --> 00:14:44.868
and this is a totally different
type of functionality--

00:14:44.868 --> 00:14:47.834
but the idea here is that maybe
you've got 3-D assets,

00:14:47.834 --> 00:14:49.501
but you want to make
a 2-D game.

00:14:49.501 --> 00:14:51.300
So what you really need
is a way to take

00:14:51.300 --> 00:14:54.033
a bunch of snapshots of
your mesh from different angles.

00:14:54.033 --> 00:14:56.534
So you can compile them
down into a GIF

00:14:56.534 --> 00:14:58.300
or however you're going
to store them,

00:14:58.300 --> 00:15:01.734
and that's what this tool does,
and WebGL makes this very easy,

00:15:01.734 --> 00:15:04.400
because you can just grab
what's on the current canvas

00:15:04.400 --> 00:15:06.367
and upload that
to App Engine.

00:15:06.367 --> 00:15:09.000
So for instance, here I select
a number of images,

00:15:09.000 --> 00:15:10.701
a starting rotation,
an ending rotation,

00:15:10.701 --> 00:15:11.901
and a resolution.

00:15:11.901 --> 00:15:14.234
Well, he's actually big
for this display.

00:15:14.234 --> 00:15:18.267
And then I can generate
a filmstrip view of this asset.

00:15:18.267 --> 00:15:20.067
So you can see him sort of
progressively rotated.

00:15:20.067 --> 00:15:21.701
And then I could take that,
and I could use it

00:15:21.701 --> 00:15:23.667
in my 2-D game
in a nice way.

00:15:23.667 --> 00:15:26.868
And this is the same technology,
the same idea behind this,

00:15:26.868 --> 00:15:29.167
that thing used to make
these thumbnails over here.

00:15:29.167 --> 00:15:32.067
So if I think this Android
would look better

00:15:32.067 --> 00:15:35.934
with a different screenshot,
I can set it now.

00:15:35.934 --> 00:15:38.434
So anyway, so that's
pretty much it for the demo,

00:15:38.434 --> 00:15:40.934
and the idea here is that WebGL
makes material bindings

00:15:40.934 --> 00:15:43.601
and shaders totally easy
and awesome and fun,

00:15:43.601 --> 00:15:46.234
and App Engine does
this collaboration really well.

00:15:46.234 --> 00:15:51.467
And so that's the basic premise.
All right, so back to the talk.

00:15:57.300 --> 00:15:59.234
All right, so before I go on
to the second half of the talk,

00:15:59.234 --> 00:16:02.934
just a tiny word of caution,
which is that

00:16:02.934 --> 00:16:05.067
some of the features
that I used for that demo,

00:16:05.067 --> 00:16:06.367
or that I'm about
to talk about,

00:16:06.367 --> 00:16:09.300
require leading edge
browser support.

00:16:09.300 --> 00:16:11.467
So I didn't want to give you
the false impression

00:16:11.467 --> 00:16:13.067
that all these things
were available

00:16:13.067 --> 00:16:16.133
in absolutely every browser,
because they're definitely not.

00:16:16.133 --> 00:16:19.267
Now, wide availability
is important and good,

00:16:19.267 --> 00:16:21.601
and it's important to note this,
but I think,

00:16:21.601 --> 00:16:25.334
especially for this use case,
it's actually less important,

00:16:25.334 --> 00:16:28.667
because you're developing tools
for people at your game studio

00:16:28.667 --> 00:16:30.067
who already--
you're not trying to support

00:16:30.067 --> 00:16:31.067
everybody on the web.

00:16:31.067 --> 00:16:32.234
So the people at your studio

00:16:32.234 --> 00:16:34.300
already need all kinds of
custom setup.

00:16:34.300 --> 00:16:36.434
They need a 2-D editor,
and a 3-D editor,

00:16:36.434 --> 00:16:38.367
and a copy of your IDE,
and a copy of your source code,

00:16:38.367 --> 00:16:39.701
and so on, and so forth.

00:16:39.701 --> 00:16:42.501
So saying browse to the tools
in a modern browser

00:16:42.501 --> 00:16:44.534
is just not that big of a deal,
in my opinion,

00:16:44.534 --> 00:16:46.901
but I wanted to note that.

00:16:46.901 --> 00:16:48.667
All right, so let's talk about
the technology

00:16:48.667 --> 00:16:51.534
that went into that demo.

00:16:51.534 --> 00:16:53.868
So the basic building blocks
that I was trying to support

00:16:53.868 --> 00:16:56.534
are shaders, textures,
and meshes.

00:16:56.534 --> 00:16:58.334
That's the data you saw
in the tool.

00:16:58.334 --> 00:17:00.467
And the basic things
I wanted to do with them

00:17:00.467 --> 00:17:03.234
are I wanted to be able
to store them in the cloud,

00:17:03.234 --> 00:17:06.434
use the cloud to process them
from an intermediate form

00:17:06.434 --> 00:17:09.434
into a built form of the assets,
put them in a nice format,

00:17:09.434 --> 00:17:11.200
where they're easily served
to the client,

00:17:11.200 --> 00:17:12.567
and then render them
on the client.

00:17:12.567 --> 00:17:14.400
So that's the box
around the problem

00:17:14.400 --> 00:17:17.234
we're trying to solve.

00:17:17.234 --> 00:17:19.567
So the very, very first thing
you're going to need to know

00:17:19.567 --> 00:17:22.534
for any of this technology
is how you get from

00:17:22.534 --> 00:17:25.734
the Java code in GWT
to JavaScript,

00:17:25.734 --> 00:17:28.234
because, you know, I use
a lot of JavaScript APIs,

00:17:28.234 --> 00:17:30.667
and WebGL itself
is a JavaScript API,

00:17:30.667 --> 00:17:34.734
so you're going to need to know
how to go back and forth,

00:17:34.734 --> 00:17:36.901
and the way you do that
is with something called

00:17:36.901 --> 00:17:40.300
GWT JavaScript Native
Interface or JSNI.

00:17:40.300 --> 00:17:42.067
And what that is it's
your all-purpose window

00:17:42.067 --> 00:17:46.067
from GWT's Java
into the JavaScript world.

00:17:46.067 --> 00:17:49.167
And what it looks like
to write a JSNI method

00:17:49.167 --> 00:17:51.567
is that you write a Java method

00:17:51.567 --> 00:17:53.634
with this native keyword
out front,

00:17:53.634 --> 00:17:54.968
like you can see
on the slide,

00:17:54.968 --> 00:17:57.234
and then it looks
to your Java IDE,

00:17:57.234 --> 00:17:59.934
like the body of that method
is written in JavaScript

00:17:59.934 --> 00:18:03.634
inside a comment, and you see,
like in the example method,

00:18:03.634 --> 00:18:07.167
the argument passed in
is used by the same name

00:18:07.167 --> 00:18:09.100
in the JavaScript, which is
how you sort of get data

00:18:09.100 --> 00:18:11.634
from one side to the other.

00:18:11.634 --> 00:18:13.868
And you can be as
object-oriented as you like

00:18:13.868 --> 00:18:15.300
with JSNI.

00:18:15.300 --> 00:18:17.701
You can either just inline
all your JavaScript straight,

00:18:17.701 --> 00:18:22.000
or you can just call functions
that live in a JavaScript file

00:18:22.000 --> 00:18:24.767
somewhere else,
or if you're being fancy,

00:18:24.767 --> 00:18:26.067
and you want to do
a lot of stuff in Java,

00:18:26.067 --> 00:18:28.567
you can make Java classes
that abstract out

00:18:28.567 --> 00:18:30.400
a bunch of JavaScript
functionality,

00:18:30.400 --> 00:18:32.334
and then treat them as objects
in your Java.

00:18:32.334 --> 00:18:35.467
The amount of how you exactly
set that up is up to you,

00:18:35.467 --> 00:18:41.100
but JSNI is the basic technology
behind it all.

00:18:41.100 --> 00:18:42.567
All right, so if
that was step zero,

00:18:42.567 --> 00:18:44.467
step one is like
you want to build a tool.

00:18:44.467 --> 00:18:45.767
You've got some data.

00:18:45.767 --> 00:18:48.267
What do you do with it?

00:18:48.267 --> 00:18:50.901
So if you've got static data,
you can deploy it

00:18:50.901 --> 00:18:52.667
just like you always deploy
static data.

00:18:52.667 --> 00:18:54.067
You can just deploy it
along with your app,

00:18:54.067 --> 00:18:56.834
the same way you put images
on your web pages.

00:18:56.834 --> 00:18:59.601
So you can either have
big directories of textures,

00:18:59.601 --> 00:19:03.534
and meshes, and shaders loose,
but that's not a great idea,

00:19:03.534 --> 00:19:05.234
because you're going to be
doing a whole bunch of fetches,

00:19:05.234 --> 00:19:07.267
and that's not particularly
efficient,

00:19:07.267 --> 00:19:09.567
or a better idea is
to ball everything up

00:19:09.567 --> 00:19:12.467
as resource bundles and then
serve them to the client

00:19:12.467 --> 00:19:15.267
all at once.

00:19:15.267 --> 00:19:18.334
All right, so resource bundles
sound like a good idea,

00:19:18.334 --> 00:19:20.200
but how do you actually
handle that,

00:19:20.200 --> 00:19:23.667
once you're working
with it on the client?

00:19:23.667 --> 00:19:28.601
And the way you do that is
with the HTML5 file system API,

00:19:28.601 --> 00:19:31.667
and what this is, is a way
to get a sandboxed

00:19:31.667 --> 00:19:34.701
local file system
that your browser can use.

00:19:34.701 --> 00:19:36.300
And it really is sandbox,

00:19:36.300 --> 00:19:38.634
so you can't write all over
the client file system.

00:19:38.634 --> 00:19:40.968
You can't write to my docs
or anything like that.

00:19:40.968 --> 00:19:43.934
But within the sandbox, you can
read and write directories,

00:19:43.934 --> 00:19:45.234
and you can read and write
files.

00:19:45.234 --> 00:19:47.667
So you can do all sorts
of cool file systemy stuff,

00:19:47.667 --> 00:19:49.367
and this is exactly
what you would want,

00:19:49.367 --> 00:19:51.200
if you had a big bundle
of resources,

00:19:51.200 --> 00:19:53.100
and you wanted to
expand it locally

00:19:53.100 --> 00:19:56.267
and keep it organized
on your machine.

00:19:56.267 --> 00:19:57.601
So this is what
it looks like to use,

00:19:57.601 --> 00:19:59.667
the file system API.

00:19:59.667 --> 00:20:03.000
Your way in is this function
request file system,

00:20:03.000 --> 00:20:05.400
and you tell it whether
you want persistent

00:20:05.400 --> 00:20:08.400
or temporary storage,
and you say how much you want,

00:20:08.400 --> 00:20:10.501
and then you give it
a callback.

00:20:10.501 --> 00:20:13.734
It gets called when the file
system is ready for you.

00:20:13.734 --> 00:20:14.834
And then once that callback
is called,

00:20:14.834 --> 00:20:16.701
you do pretty much
whatever you want.

00:20:16.701 --> 00:20:18.534
A very reasonable thing to do

00:20:18.534 --> 00:20:21.400
would be to check a hash
of local resources

00:20:21.400 --> 00:20:23.400
against a hash of resources
on the server,

00:20:23.400 --> 00:20:24.701
and see whether
there was syncing to do

00:20:24.701 --> 00:20:27.434
and sync accordingly.

00:20:27.434 --> 00:20:30.367
This is what it looks like
to write a new file.

00:20:30.367 --> 00:20:33.133
So this is asking the root
directory of the file system

00:20:33.133 --> 00:20:35.234
to get a file
by a specific name.

00:20:35.234 --> 00:20:38.968
The function get file is used
for reading and writing,

00:20:38.968 --> 00:20:42.634
so here we say we're creating
a new file.

00:20:42.634 --> 00:20:44.267
You specify a callback
for what to do

00:20:44.267 --> 00:20:46.667
when the writing is done.

00:20:46.667 --> 00:20:48.501
Then you create one
of these blob builder objects,

00:20:48.501 --> 00:20:50.601
which is how you get contents
into your file.

00:20:50.601 --> 00:20:52.801
You put contents in it,
you write it,

00:20:52.801 --> 00:20:55.300
and your callback
gets called.

00:20:55.300 --> 00:20:57.133
Reading, very similar.

00:20:57.133 --> 00:20:59.434
Here, we're asking the root
directory of the file system

00:20:59.434 --> 00:21:01.834
to get a file by
a specific name,

00:21:01.834 --> 00:21:06.467
create a file reader object,
specify a callback

00:21:06.467 --> 00:21:09.267
for what to do when
the file is done reading,

00:21:09.267 --> 00:21:10.400
then you read the file.

00:21:10.400 --> 00:21:12.567
So pretty standard
file read/write API.

00:21:12.567 --> 00:21:13.734
There's nothing tricky
about it at all,

00:21:13.734 --> 00:21:15.067
but it's super useful,

00:21:15.067 --> 00:21:16.601
and it's something
you will definitely want,

00:21:16.601 --> 00:21:20.300
if you're dealing
with heavy resources.

00:21:20.300 --> 00:21:22.868
All right, so we've got
everything in a resource bundle.

00:21:22.868 --> 00:21:24.534
Now we're serving it
all together at once,

00:21:24.534 --> 00:21:26.567
but that initial download
might be pretty slow,

00:21:26.567 --> 00:21:28.567
because you're getting all
your resources at once.

00:21:28.567 --> 00:21:32.133
So how do you
speed things up?

00:21:32.133 --> 00:21:34.167
Well, the answer with
static data for speed

00:21:34.167 --> 00:21:36.167
is pretty much caching,
caching, caching, caching.

00:21:36.167 --> 00:21:38.934
And there are many
different types of caching.

00:21:38.934 --> 00:21:40.501
It doesn't stop
at browser caching.

00:21:40.501 --> 00:21:42.634
There are a ton of different
caching opportunities.

00:21:42.634 --> 00:21:44.100
So much that, actually,
this would justify

00:21:44.100 --> 00:21:45.501
probably a whole talk,

00:21:45.501 --> 00:21:47.534
but I'm just going to go through
a lot of new things.

00:21:47.534 --> 00:21:49.400
I'm not really going
to do it justice.

00:21:49.400 --> 00:21:52.100
So if you have static resources
on App Engine,

00:21:52.100 --> 00:21:54.167
you can set up their cache
expiration times

00:21:54.167 --> 00:21:56.100
in your App Engine
web config file,

00:21:56.100 --> 00:21:58.033
so that's a good thing to know
if you're serving

00:21:58.033 --> 00:22:01.200
big sort of static resources.

00:22:01.200 --> 00:22:03.801
Besides that, if you're
responding from a servlet

00:22:03.801 --> 00:22:05.467
in such a way
that you have control

00:22:05.467 --> 00:22:07.834
over the response headers,
there are a couple of

00:22:07.834 --> 00:22:10.534
really important headers
you want to set.

00:22:10.534 --> 00:22:12.834
So for instance,
max age says how long

00:22:12.834 --> 00:22:14.567
something's going to stay
in the cache,

00:22:14.567 --> 00:22:16.534
or cache control public
is a really good one.

00:22:16.534 --> 00:22:19.467
It says that intermediaries
between the client

00:22:19.467 --> 00:22:21.667
and the server can store
copies of your data.

00:22:21.667 --> 00:22:23.667
So if you're willing to allow
that to happen,

00:22:23.667 --> 00:22:26.400
that can speed things up
a whole lot for you.

00:22:26.400 --> 00:22:29.100
And then on top of that,
just good caching technique,

00:22:29.100 --> 00:22:31.634
you want to use something
called content fingerprinting,

00:22:31.634 --> 00:22:33.901
which is where you make
the name of your file

00:22:33.901 --> 00:22:35.701
a hash of its contents
or something that changes

00:22:35.701 --> 00:22:38.801
when the contents change,
and you do that because values

00:22:38.801 --> 00:22:40.000
are stored in the cache,

00:22:40.000 --> 00:22:42.067
but with the name of the file
is the key.

00:22:42.067 --> 00:22:44.467
So if you correlate the two,
then you can set

00:22:44.467 --> 00:22:48.234
a very aggressive cache
timeout expiration on your data

00:22:48.234 --> 00:22:51.334
and not worry about it,
your cache getting poisoned,

00:22:51.334 --> 00:22:55.601
because the name will change,
and then it will get re-cached.

00:22:55.601 --> 00:22:59.234
There's also this thing called
the HTML5 Application Cache,

00:22:59.234 --> 00:23:03.501
which is five megs of local
cache data in the browser.

00:23:03.501 --> 00:23:05.801
The way you interact
with App Cache

00:23:05.801 --> 00:23:08.634
is through a manifest file
that says what to cache

00:23:08.634 --> 00:23:10.200
and what not to cache.

00:23:10.200 --> 00:23:13.400
The way you associate yourself
with the manifest file

00:23:13.400 --> 00:23:16.300
is by referencing it
in your HTML.

00:23:16.300 --> 00:23:17.801
And then the one thing
you need to know,

00:23:17.801 --> 00:23:21.400
if you're doing this on App
Engine, or actually in general,

00:23:21.400 --> 00:23:24.434
is that the file extension
or the file,

00:23:24.434 --> 00:23:26.167
the cache manifest file,
has to be served

00:23:26.167 --> 00:23:29.000
with the MIME type text
cache manifest.

00:23:29.000 --> 00:23:30.200
So if you're doing this
in App Engine,

00:23:30.200 --> 00:23:32.200
this is how you would
set up that MIME mapping

00:23:32.200 --> 00:23:34.000
in your web to XML file,
and it can be

00:23:34.000 --> 00:23:38.334
whatever file extension
you use to that MIME type.

00:23:38.334 --> 00:23:40.901
And then this is what a cache
manifest file looks like.

00:23:40.901 --> 00:23:43.534
It starts with the words
"cache manifest."

00:23:43.534 --> 00:23:46.234
There's a section of
explicitly cache resources,

00:23:46.234 --> 00:23:48.534
and these things are
going to stay cached

00:23:48.534 --> 00:23:51.267
until the cache is
programmatically updated

00:23:51.267 --> 00:23:53.000
or the manifest file
changes.

00:23:53.000 --> 00:23:55.000
So you want to make sure that
these things are really static,

00:23:55.000 --> 00:23:57.734
because they're going to stay
there for a while.

00:23:57.734 --> 00:24:00.167
Then there's a section of things
that always bypass the cache,

00:24:00.167 --> 00:24:03.267
always go the network,
and then you have

00:24:03.267 --> 00:24:06.133
this extra bit of control,
where you can specify what to do

00:24:06.133 --> 00:24:07.734
if your application
is offline.

00:24:07.734 --> 00:24:11.334
You can specify
alternate resources.

00:24:11.334 --> 00:24:15.100
Okay, so that's static data,
but we're talking about tools,

00:24:15.100 --> 00:24:16.400
and that means you're
authoring data,

00:24:16.400 --> 00:24:18.868
which means you need
some sort of dynamic solution

00:24:18.868 --> 00:24:19.968
for storing data.

00:24:19.968 --> 00:24:21.200
That's really the heart
of the problem.

00:24:21.200 --> 00:24:24.133
So what do you do
with that?

00:24:24.133 --> 00:24:26.834
So in App Engine, there are
two ways of storing data

00:24:26.834 --> 00:24:29.934
I'm going to talk about.
There's Datastore and Blobstore.

00:24:29.934 --> 00:24:33.567
So Datastore is the sort of
default option with App Engine.

00:24:33.567 --> 00:24:36.901
It's a non-relational database,
so if you come to it

00:24:36.901 --> 00:24:40.200
expecting a relational database,
you might be disappointed.

00:24:40.200 --> 00:24:42.834
So you have to understand
what Datastore is.

00:24:42.834 --> 00:24:44.400
It's really easy to use.

00:24:44.400 --> 00:24:46.200
Properties on Datastore objects,
you can see them

00:24:46.200 --> 00:24:48.601
in the Datastore console
of App Engine, very nice.

00:24:48.601 --> 00:24:51.100
There are a bunch of frameworks
that work with it

00:24:51.100 --> 00:24:53.167
like Objectify and JDO.

00:24:53.167 --> 00:24:56.300
So it's great, except
for entities in Datastore

00:24:56.300 --> 00:24:57.567
can only be up to a meg,

00:24:57.567 --> 00:25:00.367
which is really not much
for a game today,

00:25:00.367 --> 00:25:02.400
and that's where Blobstore
comes in.

00:25:02.400 --> 00:25:04.968
So Blobstore entities can be
up to two gigs,

00:25:04.968 --> 00:25:06.234
which is really nice,

00:25:06.234 --> 00:25:08.300
and you upload them all
as a single blob,

00:25:08.300 --> 00:25:11.200
but then when you want to read
or write them programmatically,

00:25:11.200 --> 00:25:13.000
you have to do so
in one-meg chunks,

00:25:13.000 --> 00:25:14.934
so it's a little bit
more opaque,

00:25:14.934 --> 00:25:17.234
but it's a lot more efficient,
and you'll definitely need it,

00:25:17.234 --> 00:25:20.634
if you're doing mesh data.

00:25:20.634 --> 00:25:22.400
What you will
most likely do is

00:25:22.400 --> 00:25:24.334
you will upload your data
into Blobstore,

00:25:24.334 --> 00:25:26.467
and then you'll create
a Datastore wrapper

00:25:26.467 --> 00:25:30.100
for each object that probably
abstracts out or pulls out

00:25:30.100 --> 00:25:32.200
a few important properties
that you want to have

00:25:32.200 --> 00:25:33.567
really available,

00:25:33.567 --> 00:25:37.501
and then you'll store
the blob key of the blob,

00:25:37.501 --> 00:25:41.467
and then you'll use
the two together.

00:25:41.467 --> 00:25:43.400
If your application wants
to write stuff straight

00:25:43.400 --> 00:25:45.534
into Blobstore, it can do so
using something called

00:25:45.534 --> 00:25:47.934
the Blobstore file write API.

00:25:47.934 --> 00:25:50.400
This is new
in App Engine 1.4.3,

00:25:50.400 --> 00:25:52.434
so it's actually
a fairly new thing,

00:25:52.434 --> 00:25:56.701
but it's really easy to use and
really important for game stuff.

00:25:56.701 --> 00:26:00.067
So how do you use it is
that you get a file service

00:26:00.067 --> 00:26:02.968
from a file service factory.

00:26:02.968 --> 00:26:07.067
You have that service create
a new file with some type.

00:26:07.067 --> 00:26:08.934
You open a write channel
to that file,

00:26:08.934 --> 00:26:12.467
put your data in it.
You close it.

00:26:12.467 --> 00:26:14.968
And then because most of
your interactions with Blobstore

00:26:14.968 --> 00:26:17.901
will be by blob key,
you ask the service

00:26:17.901 --> 00:26:19.701
to give you the key
of the blob you just made,

00:26:19.701 --> 00:26:21.267
and hang onto that however
you're hanging onto

00:26:21.267 --> 00:26:24.901
the rest of your blob keys.

00:26:24.901 --> 00:26:26.934
So if you're uploading data
to Blobstore,

00:26:26.934 --> 00:26:29.934
the process has a few steps,
and it might confuse you

00:26:29.934 --> 00:26:32.334
the very first time you do it,
but it's really not hard.

00:26:32.334 --> 00:26:35.033
The idea is that you're going
to have a form on your client

00:26:35.033 --> 00:26:36.968
that needs to post data
somewhere

00:26:36.968 --> 00:26:39.968
to get it into Blobstore,
and so you need a URL,

00:26:39.968 --> 00:26:41.968
and you get that URL
from the Blobstore service.

00:26:41.968 --> 00:26:44.834
So the Blobstore service
has a method, create URL,

00:26:44.834 --> 00:26:47.000
which takes a handler,
which is going to get called

00:26:47.000 --> 00:26:48.467
once the upload is done.

00:26:48.467 --> 00:26:51.934
So the first thing your client
form does is request that URL.

00:26:51.934 --> 00:26:54.901
It makes the post.
The handler gets called,

00:26:54.901 --> 00:26:56.667
and then the trick
is that the first handler

00:26:56.667 --> 00:26:59.534
can only return
a headers-only redirect.

00:26:59.534 --> 00:27:01.567
It can't actually respond
to the client form,

00:27:01.567 --> 00:27:03.434
so it has to redirect
somewhere else,

00:27:03.434 --> 00:27:06.701
and then that somewhere
else can respond.

00:27:06.701 --> 00:27:07.934
So maybe it sounds confusing,

00:27:07.934 --> 00:27:09.634
but it's really not
much code at all.

00:27:09.634 --> 00:27:11.000
The idea is here we are,

00:27:11.000 --> 00:27:13.601
we're asking the Blobstore
service to create a URL,

00:27:13.601 --> 00:27:14.834
and we're giving it
a handler to call,

00:27:14.834 --> 00:27:16.434
once the upload happens.

00:27:16.434 --> 00:27:19.400
The upload happens.
The post gets called.

00:27:19.400 --> 00:27:22.534
The HTTP request object
that came in had information

00:27:22.534 --> 00:27:25.767
about the blob keys that were
just created in the upload,

00:27:25.767 --> 00:27:26.801
and you don't have
to know anything

00:27:26.801 --> 00:27:28.100
about the format of the data.

00:27:28.100 --> 00:27:30.934
The Blobstore service
will parse it out for you.

00:27:30.934 --> 00:27:32.901
So you can ask it
to give you back a map.

00:27:32.901 --> 00:27:34.400
You can do whatever
you want with that data.

00:27:34.400 --> 00:27:35.934
So in this case,
I'm recommending you probably

00:27:35.934 --> 00:27:37.968
make a Datastore object
to sort of keep track

00:27:37.968 --> 00:27:40.100
of your Blobstore object.

00:27:40.100 --> 00:27:41.968
Then you can redirect
somewhere,

00:27:41.968 --> 00:27:43.834
and you can redirect
anywhere you want.

00:27:43.834 --> 00:27:46.667
I usually redirect to the
get method on the same servlet,

00:27:46.667 --> 00:27:48.634
just to keep everything
in the same file,

00:27:48.634 --> 00:27:50.934
and then you can take
any parameters you want to pass

00:27:50.934 --> 00:27:53.601
between the two and pull them
out into URL parameters.

00:27:53.601 --> 00:27:56.133
So here I'm taking the I.D.
of the asset I just made,

00:27:56.133 --> 00:27:59.601
putting it into the URL,
redirecting to get.

00:27:59.601 --> 00:28:03.334
I pull out the parameters
I just put there, the I.D.,

00:28:03.334 --> 00:28:05.501
and then I respond to
the client form with that I.D.

00:28:05.501 --> 00:28:08.300
And so what it looks like to
the client form is upload blob,

00:28:08.300 --> 00:28:12.934
get back asset I.D.,
which is very reasonable.

00:28:12.934 --> 00:28:15.400
Okay, so that covers, like,
getting data into App Engine.

00:28:15.400 --> 00:28:17.400
That's great, but there are
all sorts of transforms

00:28:17.400 --> 00:28:18.801
you might want to do
on your data.

00:28:18.801 --> 00:28:20.667
Game data is sort of fraught

00:28:20.667 --> 00:28:23.300
with all these big data
transforms that you need to do.

00:28:23.300 --> 00:28:25.701
So what's available
for that?

00:28:25.701 --> 00:28:27.033
So there's several
different options,

00:28:27.033 --> 00:28:29.767
depending on the type of data
you want to process.

00:28:29.767 --> 00:28:33.133
So if you've got 2-D data,
you want the ImageService.

00:28:33.133 --> 00:28:35.801
If you've got a bunch
of medium-sized jobs,

00:28:35.801 --> 00:28:37.834
the task queue
is a really good choice.

00:28:37.834 --> 00:28:41.334
And if you have really,
really heavy processing to do,

00:28:41.334 --> 00:28:42.601
you might want
App Engine Backend.

00:28:42.601 --> 00:28:43.801
So I'm going to talk
about each of these.

00:28:43.801 --> 00:28:45.667
They're all sort of
service-side ways

00:28:45.667 --> 00:28:48.133
you can do processing.

00:28:48.133 --> 00:28:49.601
So the ImageService
is awesome.

00:28:49.601 --> 00:28:52.934
It's just a really lightweight
image processing API.

00:28:52.934 --> 00:28:54.067
It doesn't do a lot.

00:28:54.067 --> 00:28:55.501
It's not particularly
feature full,

00:28:55.501 --> 00:28:57.734
but the things it does, it does
really well and efficiently,

00:28:57.734 --> 00:29:00.734
and they're probably the very
first things you want.

00:29:00.734 --> 00:29:02.667
For instance, getting thumbnails
out of your data,

00:29:02.667 --> 00:29:04.868
totally easy with ImageService
and cropping,

00:29:04.868 --> 00:29:06.267
that kind of stuff.

00:29:06.267 --> 00:29:08.167
So here's what it looks like
to use.

00:29:08.167 --> 00:29:11.167
You get an ImageService from
the ImageService factory,

00:29:11.167 --> 00:29:14.534
very typical App Engine API
pattern.

00:29:14.534 --> 00:29:17.300
Then the way you actually
interact with the ImageService

00:29:17.300 --> 00:29:18.701
is you give it a blob key.

00:29:18.701 --> 00:29:21.567
The images it operates on
have to be stored in Blobstore.

00:29:21.567 --> 00:29:23.467
So you get the key
to one of those images,

00:29:23.467 --> 00:29:26.934
and it will return to you a URL,
and that URL is the way

00:29:26.934 --> 00:29:28.734
you're going to manipulate
that image.

00:29:28.734 --> 00:29:31.934
And so important to note
that URL's can take

00:29:31.934 --> 00:29:33.667
a couple hundred milliseconds
to generate,

00:29:33.667 --> 00:29:35.467
so you definitely
want to do this once

00:29:35.467 --> 00:29:37.501
and then hang onto that URL.

00:29:37.501 --> 00:29:38.834
But once it's generated,

00:29:38.834 --> 00:29:42.701
it's really fast to use
that URL to manipulate it.

00:29:42.701 --> 00:29:45.934
And then the way you actually
do image processing

00:29:45.934 --> 00:29:48.100
is by appending strings
to the very end of that URL.

00:29:48.100 --> 00:29:50.033
So this particular suffix says

00:29:50.033 --> 00:29:53.033
scale the image down to
100 X 100 and crop it.

00:29:53.033 --> 00:29:55.467
And this is really nice to be
able to do all this processing

00:29:55.467 --> 00:29:56.801
via string manipulation,

00:29:56.801 --> 00:30:00.267
because likely different parts
of your UI,

00:30:00.267 --> 00:30:02.067
and your client might want
images at different resolutions

00:30:02.067 --> 00:30:03.334
or stuff like that.

00:30:03.334 --> 00:30:06.667
So it's really nice
to have that control.

00:30:06.667 --> 00:30:09.300
All right, so the task here
is the way to do

00:30:09.300 --> 00:30:12.400
parallel background processing
in App Engine.

00:30:12.400 --> 00:30:14.767
It looks to the system,
each task, as it's executing,

00:30:14.767 --> 00:30:17.167
looks like an HTTP request,
which is really nice,

00:30:17.167 --> 00:30:19.300
because that means
that task queue tasks

00:30:19.300 --> 00:30:22.400
scale the same way
that HTTP requests scale,

00:30:22.400 --> 00:30:24.601
and App Engine is great
at handling

00:30:24.601 --> 00:30:26.634
a whole bunch of
HTTP requests.

00:30:26.634 --> 00:30:28.334
So for instance, you know,
your tasks can get distributed

00:30:28.334 --> 00:30:31.501
across instances
and all that kind of stuff.

00:30:31.501 --> 00:30:33.901
Every task can run
for ten minutes,

00:30:33.901 --> 00:30:35.567
which may sound like a lot
or a little,

00:30:35.567 --> 00:30:38.634
depending on what kind of
processing you're trying to do.

00:30:38.634 --> 00:30:42.100
And by default you can have
100 per second,

00:30:42.100 --> 00:30:44.934
or that's the max level
you can set it at.

00:30:44.934 --> 00:30:46.801
So the sort of flow chart
I have on the slide here

00:30:46.801 --> 00:30:49.133
illustrates how I'm using
the task queue

00:30:49.133 --> 00:30:51.000
and what I think is
a really compelling use case,

00:30:51.000 --> 00:30:52.300
when you're talking
about game data,

00:30:52.300 --> 00:30:54.367
and that's the game data
build process.

00:30:54.367 --> 00:30:56.467
So it's very common,
if you've got 3-D data,

00:30:56.467 --> 00:30:59.367
to have your artist working in
some sort of 3-D authoring tool,

00:30:59.367 --> 00:31:01.133
and then they export to
some sort of verbose

00:31:01.133 --> 00:31:03.400
intermediate format
like OBJ or COLLADA,

00:31:03.400 --> 00:31:04.634
or something like that.

00:31:04.634 --> 00:31:05.834
But that's not what
your engine consumes,

00:31:05.834 --> 00:31:08.100
because that would be
horribly inefficient.

00:31:08.100 --> 00:31:09.968
So instead, you need
some sort of process

00:31:09.968 --> 00:31:12.767
that builds your intermediate
data into binary data.

00:31:12.767 --> 00:31:17.200
So you need to do all these
data processing operations.

00:31:17.200 --> 00:31:19.167
So that's where something like
having tasks is good.

00:31:19.167 --> 00:31:21.267
So for instance, in the tool
I just showed you,

00:31:21.267 --> 00:31:24.601
the idea is it syncs to
my subversion repository,

00:31:24.601 --> 00:31:26.934
gets all 90 assets at once,
and then farms out

00:31:26.934 --> 00:31:28.734
a whole bunch of tasks
and builds them all in parallel.

00:31:28.734 --> 00:31:31.400
So something like that,
if your data build needs fit

00:31:31.400 --> 00:31:35.300
into ten minutes,
is a really nice thing.

00:31:35.300 --> 00:31:38.033
So this is what it looks like
to actually set up a task queue.

00:31:38.033 --> 00:31:40.634
You have a queue to XML file
that goes with all your other

00:31:40.634 --> 00:31:41.801
App Engine config files.

00:31:41.801 --> 00:31:43.601
You give it a name
and a rate

00:31:43.601 --> 00:31:45.133
at which you want to allow it
to process,

00:31:45.133 --> 00:31:47.100
and there are a couple of other
things I didn't put on a slide.

00:31:47.100 --> 00:31:50.334
For instance, you can set
max number of concurrent tasks

00:31:50.334 --> 00:31:51.734
you're willing to
let it execute,

00:31:51.734 --> 00:31:53.734
if you want to keep an eye
on your processing,

00:31:53.734 --> 00:31:56.434
your resource use.

00:31:56.434 --> 00:31:58.567
And then here's what
it looks like to use.

00:31:58.567 --> 00:32:01.734
You call it a queue by one
that you just put

00:32:01.734 --> 00:32:05.767
in the queue XML file, by name,
and then you add tasks to it,

00:32:05.767 --> 00:32:08.868
and each task takes a URL
that it's going to hit,

00:32:08.868 --> 00:32:11.367
whether you're going to get
or post to that URL,

00:32:11.367 --> 00:32:14.701
and URL parameters
you want to add,

00:32:14.701 --> 00:32:17.434
and then each task executes,
calls to get,

00:32:17.434 --> 00:32:19.033
and it does whatever
kind of processing

00:32:19.033 --> 00:32:20.701
that method
is supposed to do.

00:32:20.701 --> 00:32:22.300
So task queues are actually
a really big subject,

00:32:22.300 --> 00:32:24.367
and I'm not really
doing them justice.

00:32:24.367 --> 00:32:26.601
There's another talk
the hour after next

00:32:26.601 --> 00:32:28.434
that's on nothing
but task queues.

00:32:28.434 --> 00:32:29.701
So if you're interested
and want to learn more,

00:32:29.701 --> 00:32:32.767
that's definitely
the place to go.

00:32:32.767 --> 00:32:35.534
All right, so if ten minutes
did not sound like nearly enough

00:32:35.534 --> 00:32:38.801
processing to you,
then App Engine Backends

00:32:38.801 --> 00:32:40.734
might be a solution to
what you're trying to do,

00:32:40.734 --> 00:32:43.534
and the idea here is
that App Engine,

00:32:43.534 --> 00:32:47.100
standard App Engine
is really great at managing

00:32:47.100 --> 00:32:49.467
a whole bunch of requests,
web requests,

00:32:49.467 --> 00:32:51.400
and that's really good
for some things,

00:32:51.400 --> 00:32:53.601
but not so great
for heavy processing.

00:32:53.601 --> 00:32:57.000
So for instance, every request
starts with a client.

00:32:57.000 --> 00:32:59.434
Those requests have
30 second timeouts.

00:32:59.434 --> 00:33:01.801
Instances spin up and down,
based on load,

00:33:01.801 --> 00:33:03.067
so you don't know
what's in memory

00:33:03.067 --> 00:33:04.801
or what instance you're on,
all that.

00:33:04.801 --> 00:33:06.434
So if you're doing
some really heavy work,

00:33:06.434 --> 00:33:09.367
this is not a particularly good
environment to be in.

00:33:09.367 --> 00:33:12.367
So for instance, in games,
it's very common to have

00:33:12.367 --> 00:33:14.367
these big, big data
processing operations

00:33:14.367 --> 00:33:18.267
that go on for, like, between
8 and 24 hours per build.

00:33:18.267 --> 00:33:21.067
So if you're building
occlusion data, or AI data,

00:33:21.067 --> 00:33:22.934
or light maps,
or something like that,

00:33:22.934 --> 00:33:25.234
you might need, like,
a whole lot of processing,

00:33:25.234 --> 00:33:28.100
and that's where App Engine
Backends come in.

00:33:28.100 --> 00:33:30.467
So the idea here
is that you have an instance

00:33:30.467 --> 00:33:32.234
with no request deadline.

00:33:32.234 --> 00:33:33.567
You get more memory,

00:33:33.567 --> 00:33:35.868
and you get an individually
addressable instance,

00:33:35.868 --> 00:33:37.367
so you can keep talking
to the same instance,

00:33:37.367 --> 00:33:40.567
and you can sort of think about
what's actually in memory.

00:33:40.567 --> 00:33:43.734
And, again, backends
are a really big subject.

00:33:43.734 --> 00:33:46.634
Next hour, there's a talk
on nothing but backends,

00:33:46.634 --> 00:33:48.634
so I'm just sort of
mentioning it here.

00:33:48.634 --> 00:33:50.234
But if you want
to learn a lot more,

00:33:50.234 --> 00:33:53.133
go to that session.

00:33:53.133 --> 00:33:55.767
All right, so we've got
our data stored in the cloud.

00:33:55.767 --> 00:33:57.801
We've processed it
into some sort of form.

00:33:57.801 --> 00:34:00.300
We know how to process it
into a form that we can use,

00:34:00.300 --> 00:34:01.767
but what form
should that be?

00:34:01.767 --> 00:34:03.067
So what's an interesting--

00:34:03.067 --> 00:34:06.901
what's a good format
to store your data in?

00:34:06.901 --> 00:34:08.567
We're talking about
serialization.

00:34:08.567 --> 00:34:11.300
And so to me, the very
first thing I thought of

00:34:11.300 --> 00:34:14.033
and what seemed pretty obvious
is that I wanted binary data,

00:34:14.033 --> 00:34:18.801
so my meshes are all stored
in Blobstore as buffers afloat.

00:34:18.801 --> 00:34:20.167
It was actually kind of
a surprise to me,

00:34:20.167 --> 00:34:22.200
because I came from
the games industry first.

00:34:22.200 --> 00:34:24.400
I'm not a web programmer
by default--

00:34:24.400 --> 00:34:26.200
that binary data
is actually pretty hard

00:34:26.200 --> 00:34:27.701
to request in a browser.

00:34:27.701 --> 00:34:31.167
XML HTTP requests did not
have a binary response type

00:34:31.167 --> 00:34:33.868
until this new specification
was recently added.

00:34:33.868 --> 00:34:38.200
XMLHTTPRequest Level 2, which
adds two new response types:

00:34:38.200 --> 00:34:39.634
array buffer and blob.

00:34:39.634 --> 00:34:41.000
And so you're going to need
one of those,

00:34:41.000 --> 00:34:45.200
if you're going to serialize
binary data.

00:34:45.200 --> 00:34:46.968
So it was obvious to me
that I should use binary data,

00:34:46.968 --> 00:34:49.234
but I was talking about this
with some other Googlers,

00:34:49.234 --> 00:34:51.767
and the Google Body team
actually serializes their data

00:34:51.767 --> 00:34:53.734
as UTF-8, which actually
blew my mind

00:34:53.734 --> 00:34:55.133
that they could do that.

00:34:55.133 --> 00:34:57.634
And so Google Body, if
you're interested in WebGL,

00:34:57.634 --> 00:34:59.734
and you haven't--
you're not aware of Google Body,

00:34:59.734 --> 00:35:01.100
you should definitely
check it out.

00:35:01.100 --> 00:35:03.033
Not only is it
a really cool tool,

00:35:03.033 --> 00:35:04.901
but it's a really cool use
of WebGL.

00:35:04.901 --> 00:35:07.801
They have about 1.4 million
triangles in their mesh,

00:35:07.801 --> 00:35:11.334
and yet, the whole thing is
pretty snappy to use.

00:35:11.334 --> 00:35:14.167
And they get there by doing
a couple of really smart things.

00:35:14.167 --> 00:35:16.033
They delta compress
their geometry,

00:35:16.033 --> 00:35:18.000
so they have a bunch of
really small numbers.

00:35:18.000 --> 00:35:20.501
They use variable length
encoding on their UTF-8,

00:35:20.501 --> 00:35:22.767
so small numbers
are encoded small.

00:35:22.767 --> 00:35:27.000
Then they configure their HTTP
to be sent GZipped,

00:35:27.000 --> 00:35:28.634
which is something you can do
with your headers,

00:35:28.634 --> 00:35:31.100
and some browsers can just
naturally decode it.

00:35:31.100 --> 00:35:33.968
You don't have to do
any extra work on the client.

00:35:33.968 --> 00:35:39.000
And then I believe the thing is,
it's the interaction of GZip

00:35:39.000 --> 00:35:41.334
with the UTF-8 and all
the nice, small numbers.

00:35:41.334 --> 00:35:42.467
It GZips really well,

00:35:42.467 --> 00:35:44.300
and they get a fantastic
compression ratio.

00:35:44.300 --> 00:35:47.100
They actually get about
3.5 times better compression

00:35:47.100 --> 00:35:48.868
than I did with binary data.

00:35:48.868 --> 00:35:50.734
It's really cool, so--
and then, of course,

00:35:50.734 --> 00:35:52.767
everything is text,
so you can just parse it out

00:35:52.767 --> 00:35:57.334
as a response text string,
and you can just use charCode@

00:35:57.334 --> 00:35:59.267
to sort of parse out data.

00:35:59.267 --> 00:36:02.467
It's a really
cool solution.

00:36:02.467 --> 00:36:04.534
All right, so we figured out
a couple of options

00:36:04.534 --> 00:36:06.133
for data formats.
We've got our data,

00:36:06.133 --> 00:36:09.868
but how do you actually
request it from GWT?

00:36:09.868 --> 00:36:11.434
So here we're talking
about Java code

00:36:11.434 --> 00:36:13.200
that's going to allow you
to request this data

00:36:13.200 --> 00:36:16.434
you just worked so hard
to set up.

00:36:16.434 --> 00:36:20.534
Now, GWT has a really nice
class XML HTTP request,

00:36:20.534 --> 00:36:23.634
which does a really good job
of making XML HTTP requests

00:36:23.634 --> 00:36:26.601
easy and sort of abstract away
the details and all that.

00:36:26.601 --> 00:36:29.067
But the problem is
that it doesn't have

00:36:29.067 --> 00:36:30.634
a few methods you need,

00:36:30.634 --> 00:36:32.167
if you want to request
binary data.

00:36:32.167 --> 00:36:35.501
So what I needed to do
was to extend the XML HTTP

00:36:35.501 --> 00:36:38.934
request class
to add two new methods,

00:36:38.934 --> 00:36:42.067
which are get response,
the actual body of the response.

00:36:42.067 --> 00:36:44.334
What's exposed right now
in the existing version of GWT

00:36:44.334 --> 00:36:45.968
is response text,
which wasn't good enough,

00:36:45.968 --> 00:36:48.133
because I've got
a big blob of binary data,

00:36:48.133 --> 00:36:49.767
and it comes back
as a JavaScript object,

00:36:49.767 --> 00:36:51.567
which is something
that the Java code

00:36:51.567 --> 00:36:53.000
is not going to try
to interpret.

00:36:53.000 --> 00:36:54.000
It's just going to get
thrown over

00:36:54.000 --> 00:36:56.968
into JavaScript immediately.

00:36:56.968 --> 00:36:59.334
And then you needed a method
to set the response tab

00:36:59.334 --> 00:37:01.467
you were expecting to one
of these binary types.

00:37:01.467 --> 00:37:03.968
So those are the only additions
you needed to make

00:37:03.968 --> 00:37:07.734
to XML HTTP requests
to be able to do this.

00:37:07.734 --> 00:37:09.968
And then what it looks like
to actually use

00:37:09.968 --> 00:37:11.300
is you make one of
these objects.

00:37:11.300 --> 00:37:14.868
You open a connection
to a specific URL.

00:37:14.868 --> 00:37:20.701
You set the response type to
one of these new binary types.

00:37:20.701 --> 00:37:22.767
You say what to do
when you're done.

00:37:22.767 --> 00:37:27.100
So when it's done, you want to
load data with a response body,

00:37:27.100 --> 00:37:29.834
which this load data function
is a native method,

00:37:29.834 --> 00:37:31.567
which takes that JavaScript
object,

00:37:31.567 --> 00:37:33.067
which I'm not trying
to interpret in Java,

00:37:33.067 --> 00:37:37.167
and just passes it on over into
the JavaScript side of things.

00:37:37.167 --> 00:37:38.701
And then here in the
JavaScript function,

00:37:38.701 --> 00:37:41.067
I take my blob
that I got passed in,

00:37:41.067 --> 00:37:42.934
and make a typed array
out of it.

00:37:42.934 --> 00:37:46.334
So JavaScript had not had
a good way to represent

00:37:46.334 --> 00:37:49.734
binary data until the typed
array specification came along,

00:37:49.734 --> 00:37:52.300
and typed arrays
are a way to make,

00:37:52.300 --> 00:37:53.934
a way to actually
get binary data.

00:37:53.934 --> 00:37:55.901
They're a way to make views
on a data object.

00:37:55.901 --> 00:37:58.801
So in this case, I'm saying
view this blob of stuff

00:37:58.801 --> 00:38:00.234
as a float 32 array.

00:38:00.234 --> 00:38:03.767
I could as easily say view this
as a UN8 array or whatever.

00:38:03.767 --> 00:38:06.167
There are a bunch of different
types you can look at things at.

00:38:06.167 --> 00:38:09.100
And then from there on,
you pass your buffer into WebGL,

00:38:09.100 --> 00:38:12.334
and off it renders.

00:38:12.334 --> 00:38:15.334
All right, so
where are we now?

00:38:15.334 --> 00:38:17.701
We've stored our data.
We've processed it.

00:38:17.701 --> 00:38:19.601
We've serialized it
and requested it.

00:38:19.601 --> 00:38:21.701
WebGL is rendering it.
Everything is good.

00:38:21.701 --> 00:38:23.400
One more thing
we need to know how to do

00:38:23.400 --> 00:38:25.400
which is that we want to add
interactivity

00:38:25.400 --> 00:38:27.000
to the application,
so we want to make sure

00:38:27.000 --> 00:38:31.467
that it's rendering
as efficiently as possible.

00:38:31.467 --> 00:38:33.133
So the way you do that is

00:38:33.133 --> 00:38:36.601
with this request animation
frame API,

00:38:36.601 --> 00:38:39.300
and the idea here
is that the old school way

00:38:39.300 --> 00:38:43.734
to do animation in JavaScript is
with this function setInterval,

00:38:43.734 --> 00:38:46.834
and what setInterval does
is that it takes a callback

00:38:46.834 --> 00:38:49.667
and a rate,
and it just calls and calls

00:38:49.667 --> 00:38:51.400
and calls at that rate.

00:38:51.400 --> 00:38:53.701
And the problem with that is
that your JavaScript

00:38:53.701 --> 00:38:56.968
is not necessarily in
a particularly good position

00:38:56.968 --> 00:38:58.901
to know whether
that makes any sense.

00:38:58.901 --> 00:39:01.601
So for instance, the client
could not have the resources

00:39:01.601 --> 00:39:04.567
to fill the request
you're asking it to draw,

00:39:04.567 --> 00:39:06.834
or, you know, worse still,
your WebGL could be

00:39:06.834 --> 00:39:08.667
in a background tab,
so it might make no sense

00:39:08.667 --> 00:39:11.567
to update your animation
at all, and yet,

00:39:11.567 --> 00:39:13.200
setInterval will just call
and call and call,

00:39:13.200 --> 00:39:15.734
because it's not
particularly smart.

00:39:15.734 --> 00:39:18.033
So that's where Request
Animation Frame comes in.

00:39:18.033 --> 00:39:20.701
Request Animation Frame
has a very similar format

00:39:20.701 --> 00:39:24.133
in that you specify a callback,
and it'll attempt to call you,

00:39:24.133 --> 00:39:26.000
but it puts the browser
in charge.

00:39:26.000 --> 00:39:29.100
So the browser can take account
of all the conditions

00:39:29.100 --> 00:39:32.701
that it knows about
and decide intelligently

00:39:32.701 --> 00:39:35.534
whether you should be
called back.

00:39:35.534 --> 00:39:37.300
So the API for Request
Animation Frame

00:39:37.300 --> 00:39:39.701
is still stabilizing.
It's a very new thing.

00:39:39.701 --> 00:39:42.701
So if you want to use it,
you want to use a shim layer.

00:39:42.701 --> 00:39:45.067
You can see this is trying
to call it with a bunch

00:39:45.067 --> 00:39:46.868
of different formats
and then falling back,

00:39:46.868 --> 00:39:50.100
if none of those work.

00:39:50.100 --> 00:39:51.400
And that's pretty much it.

00:39:51.400 --> 00:39:54.300
So those are the major
technical sort of milestones

00:39:54.300 --> 00:39:57.234
and hurdles that I needed
to overcome to make the demo.

00:39:57.234 --> 00:39:59.067
That's sort of
what I learned.

00:39:59.067 --> 00:40:01.834
And to recap, all right, so
if you've got static data,

00:40:01.834 --> 00:40:03.667
you want to cache it,
and there are lots and lots

00:40:03.667 --> 00:40:05.501
of different ways of caching,
and you should try to get

00:40:05.501 --> 00:40:06.834
to know as many of them
as possible,

00:40:06.834 --> 00:40:09.067
because they will help you
a lot.

00:40:09.067 --> 00:40:11.300
If you are dealing
with resource bundles,

00:40:11.300 --> 00:40:14.434
you're going to want
the HTML5 file system API,

00:40:14.434 --> 00:40:18.367
a really useful way to get
a sandbox local file system.

00:40:18.367 --> 00:40:21.000
If you've got dynamic data,
you're going to want Datastore

00:40:21.000 --> 00:40:22.701
or Blobstore to store stuff
in App Engine.

00:40:22.701 --> 00:40:24.267
You're probably going
to want a mix of both.

00:40:24.267 --> 00:40:26.133
Probably every game asset
is going to be represented

00:40:26.133 --> 00:40:29.667
by a Blobstore part
and a Datastore part.

00:40:29.667 --> 00:40:31.601
If you're doing any kind of
processing or transforms

00:40:31.601 --> 00:40:32.968
on your assets,

00:40:32.968 --> 00:40:34.601
you're going to want a couple
of different APIs.

00:40:34.601 --> 00:40:37.334
If you're doing 2-D stuff,
you might want the ImageService.

00:40:37.334 --> 00:40:40.634
If you've got a bunch of jobs
that fit into ten-minute chunks,

00:40:40.634 --> 00:40:42.200
you're going to want
task queues.

00:40:42.200 --> 00:40:44.100
And if you've got really,
really heavy operations,

00:40:44.100 --> 00:40:46.501
you might want App Engine
Backends.

00:40:46.501 --> 00:40:49.234
And then for data formats
and serialization,

00:40:49.234 --> 00:40:50.868
you can store your data
as binary

00:40:50.868 --> 00:40:54.234
if you're using XHR Level 2,

00:40:54.234 --> 00:40:57.834
or you can store it as UTF-8,
which can be efficient,

00:40:57.834 --> 00:41:00.534
can be very efficient,
if you do stuff, smart stuff

00:41:00.534 --> 00:41:06.133
like delta compressing your mesh
and GZipping your HTTP.

00:41:06.133 --> 00:41:07.167
And that's pretty much it.

00:41:07.167 --> 00:41:08.167
All right, so questions.

00:41:08.167 --> 00:41:09.734
And if you want to give
feedback, again,

00:41:09.734 --> 00:41:12.667
here's the SpeakerMeter link,
and there's some hashtags,

00:41:12.667 --> 00:41:16.133
if you want to talk
about it on Twitter.

00:41:16.133 --> 00:41:22.033
Any questions?
[applause]

00:41:24.701 --> 00:41:28.501
man: Do you know if there's
any plans to make a wrapper

00:41:28.501 --> 00:41:31.300
around the WebGL frontend
for GWT?

00:41:31.300 --> 00:41:32.901
Thompson:
I don't know.

00:41:32.901 --> 00:41:36.567
Yeah, I'm not sure about that.
I'm sorry.

00:41:40.734 --> 00:41:44.400
Yeah.

00:41:44.400 --> 00:41:47.934
man: Just out of curiosity,
who are you building tools for?

00:41:47.934 --> 00:41:51.701
Who are your users?

00:41:51.701 --> 00:41:53.300
Thompson:
Me, personally?

00:41:53.300 --> 00:41:55.234
man: Because it sounds like
you work at Google, right?

00:41:55.234 --> 00:41:58.133
And I assume
this is your job.

00:41:58.133 --> 00:41:59.367
Thompson:
Right.

00:41:59.367 --> 00:42:01.067
man: Is Google
making games or recording...

00:42:01.067 --> 00:42:02.100
Thompson: Oh, I got it.
I see what you're asking.

00:42:02.100 --> 00:42:03.767
man:
...game publishers?

00:42:03.767 --> 00:42:05.267
Thompson: Google is
interested in games,

00:42:05.267 --> 00:42:08.534
so Google is really sort of--
has been over, very recently,

00:42:08.534 --> 00:42:10.567
ramping up its interest
in the game community.

00:42:10.567 --> 00:42:13.934
And so what my job title is,
I'm a Game Developer Advocate,

00:42:13.934 --> 00:42:15.934
which means that I'm
an ex-game programmer

00:42:15.934 --> 00:42:18.734
that talks to the game industry
or people interested in games

00:42:18.734 --> 00:42:20.501
about Google technologies.

00:42:20.501 --> 00:42:22.133
So the tools I made

00:42:22.133 --> 00:42:24.000
are actually not
for any particular game.

00:42:24.000 --> 00:42:27.367
Like, we don't actually
make content,

00:42:27.367 --> 00:42:30.767
but the idea is to demonstrate
that these things can be done,

00:42:30.767 --> 00:42:32.100
and get enthusiasm for them.

00:42:32.100 --> 00:42:33.667
Because this is
all really new.

00:42:33.667 --> 00:42:36.501
Actually, there isn't a lot
written about using App Engine

00:42:36.501 --> 00:42:38.400
and WebGL or App Engine
and 3-D data, really.

00:42:38.400 --> 00:42:40.167
So it's really just
to pioneer that stuff,

00:42:40.167 --> 00:42:43.868
but no particular use case.

00:42:43.868 --> 00:42:45.767
Anyone else?

00:42:45.767 --> 00:42:49.033
Yeah?

00:42:49.033 --> 00:42:51.868
man: So I know this might go
beyond the scope of the demo

00:42:51.868 --> 00:42:54.701
that you've shown,
but have you put much thought

00:42:54.701 --> 00:42:57.267
into how this might play nice
with a version control system?

00:42:57.267 --> 00:43:00.000
I'm assuming that these assets
would all go up

00:43:00.000 --> 00:43:02.000
to Google land, right?

00:43:02.000 --> 00:43:03.334
Thompson: Yes.

00:43:03.334 --> 00:43:05.434
So yeah,
that's a really good question.

00:43:05.434 --> 00:43:08.934
So I think--
I would not recommend

00:43:08.934 --> 00:43:11.534
that you would try to rewrite
your version to Drill System

00:43:11.534 --> 00:43:14.200
in App Engine, unless writing
a version control system

00:43:14.200 --> 00:43:16.367
is really your primary goal.

00:43:16.367 --> 00:43:18.300
Which it usually isn't.

00:43:18.300 --> 00:43:19.400
It's way bigger
than you think it is,

00:43:19.400 --> 00:43:21.868
if you've never
tried to do it.

00:43:21.868 --> 00:43:25.634
I think a very reasonable
workflow for a real game studio

00:43:25.634 --> 00:43:28.734
would be to check your assets
into version control somewhere,

00:43:28.734 --> 00:43:30.400
and then sync periodically.

00:43:30.400 --> 00:43:32.100
If you're doing something
like the asset viewer tool,

00:43:32.100 --> 00:43:34.667
the idea would be on change
you'd pull data in,

00:43:34.667 --> 00:43:36.734
or nightly,
or something like that.

00:43:36.734 --> 00:43:40.834
So I think you
definitely want to work

00:43:40.834 --> 00:43:42.467
with external version control,
whatever that is,

00:43:42.467 --> 00:43:47.968
and just sort of communicate
between the two.

00:43:47.968 --> 00:43:53.601
Anything else?

00:43:53.601 --> 00:43:55.167
All right.
Oh, yeah?

00:43:55.167 --> 00:43:56.434
man:
Is it open source?

00:43:56.434 --> 00:43:57.634
Thompson: So the question is,
is it open source?

00:43:57.634 --> 00:43:59.934
And which thing are you
asking about?

00:43:59.934 --> 00:44:01.467
man: [indistinct]
Thompson: No, not yet.

00:44:01.467 --> 00:44:03.133
The code is a total disaster,

00:44:03.133 --> 00:44:04.634
because I was hacking on it
right before I--

00:44:04.634 --> 00:44:08.434
But I intend to make this a live
demo that people can use,

00:44:08.434 --> 00:44:12.200
but it isn't yet.

00:44:12.200 --> 00:44:16.534
Anything else?

00:44:16.534 --> 00:44:18.334
All right, well,
thank you all for coming.

00:44:18.334 --> 00:44:21.300
Have a good IO.

