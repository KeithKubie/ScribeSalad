WEBVTT
Kind: captions
Language: en

00:00:00.650 --> 00:00:02.630
ILYA GRIGORIK: Hi everyone,
my name is Ilya Grigorik.

00:00:02.630 --> 00:00:05.370
I'm a developer advocate
on the Make the Web

00:00:05.370 --> 00:00:06.680
Fast Team at Google.

00:00:06.680 --> 00:00:09.560
And today I want to talk to you
about Mobile Performance

00:00:09.560 --> 00:00:13.100
from Radio Up, which is to say,
taking a lower level look

00:00:13.100 --> 00:00:16.340
at how the radio works, and what
we can learn about it to

00:00:16.340 --> 00:00:19.950
make our apps, mobile apps, and
web pages more performant.

00:00:19.950 --> 00:00:21.970
So these are some tips and
tricks that I've learned from

00:00:21.970 --> 00:00:24.470
working with different Google
properties, helping them

00:00:24.470 --> 00:00:26.470
optimize their applications,
and some

00:00:26.470 --> 00:00:28.420
general best practices.

00:00:28.420 --> 00:00:31.500
So first I think we should start
with the obvious, or

00:00:31.500 --> 00:00:34.000
maybe it's not so obvious to
many of us, which is, wireless

00:00:34.000 --> 00:00:36.330
is fundamentally different
than wired.

00:00:36.330 --> 00:00:38.440
There are different
constraints.

00:00:38.440 --> 00:00:40.570
The technology, the underlying
technology, is,

00:00:40.570 --> 00:00:42.060
in fact, very different.

00:00:42.060 --> 00:00:45.860
And fortunately or
unfortunately, I'm not quite

00:00:45.860 --> 00:00:50.330
sure yet, our platform actually
abstracts that.

00:00:50.330 --> 00:00:54.030
TCP and our browsers make it
seem like it's all the same,

00:00:54.030 --> 00:00:56.203
whether you're accessing over
a wireless network, whether

00:00:56.203 --> 00:00:59.010
it's Wi-Fi, a mobile network,
or a wired network, it feels

00:00:59.010 --> 00:01:00.070
like all the same.

00:01:00.070 --> 00:01:02.650
But once you actually dig a
little bit deeper, you'll

00:01:02.650 --> 00:01:05.330
realize that there are different
design constraints,

00:01:05.330 --> 00:01:08.260
even within the different
wireless standards.

00:01:08.260 --> 00:01:10.890
And that actually dictates how
you need to design your

00:01:10.890 --> 00:01:14.790
applications to make them
feel performant.

00:01:14.790 --> 00:01:17.330
So first of all,
why do we care?

00:01:17.330 --> 00:01:20.920
It turns out that performance
is a top criteria for all

00:01:20.920 --> 00:01:23.090
applications, mobile
especially.

00:01:23.090 --> 00:01:26.080
And there's a number of great
studies that have been done

00:01:26.080 --> 00:01:27.480
about performance on mobile.

00:01:27.480 --> 00:01:31.880
And the first takeaway is that
users expect mobile sites to

00:01:31.880 --> 00:01:34.800
perform just as well, if not
better, on mobile than they do

00:01:34.800 --> 00:01:35.430
on desktop.

00:01:35.430 --> 00:01:38.630
We don't have more relaxed
expectations on mobile.

00:01:38.630 --> 00:01:40.360
If anything, it should
be faster.

00:01:40.360 --> 00:01:41.100
You're on the go.

00:01:41.100 --> 00:01:43.680
You're trying to check
something quickly.

00:01:43.680 --> 00:01:44.740
You don't have much time.

00:01:44.740 --> 00:01:46.390
You want it to perform well.

00:01:46.390 --> 00:01:49.880
Now, out of all these users that
have asked this question,

00:01:49.880 --> 00:01:53.090
more than half have actually
reported feeling frustrated

00:01:53.090 --> 00:01:56.090
about having a problem when
accessing a site or an app

00:01:56.090 --> 00:01:57.560
over a mobile network.

00:01:57.560 --> 00:02:00.840
And most of those, the number
one complaint has been the

00:02:00.840 --> 00:02:05.970
slow load time for their
applications.

00:02:05.970 --> 00:02:09.759
And after that, almost half of
them said, if I had a problem,

00:02:09.759 --> 00:02:11.940
I couldn't get the page to load
fast enough, it didn't

00:02:11.940 --> 00:02:14.590
react fast enough, they
wouldn't come back.

00:02:14.590 --> 00:02:17.620
So you've lost that user, and
they're not returning to your

00:02:17.620 --> 00:02:20.280
site, which is the worst
possible outcome.

00:02:20.280 --> 00:02:23.420
And of course, this also
translates to dollars and

00:02:23.420 --> 00:02:24.950
cents, and even millions
of dollars.

00:02:24.950 --> 00:02:27.310
So this another great case study
that I'd like to share.

00:02:27.310 --> 00:02:29.670
This is done by Aberdeen
Group.

00:02:29.670 --> 00:02:33.520
They looked at a whole number,
100-plus e-commerce sites, and

00:02:33.520 --> 00:02:38.330
they realized that adding one
second of delay to their pages

00:02:38.330 --> 00:02:40.890
and to their applications
dropped their conversions

00:02:40.890 --> 00:02:41.660
significantly.

00:02:41.660 --> 00:02:44.160
So this is your actual
purchases.

00:02:44.160 --> 00:02:47.590
People viewed fewer pages,
and, of course, customer

00:02:47.590 --> 00:02:49.230
satisfaction decreased
as well.

00:02:49.230 --> 00:02:52.400
So this is just 1,000
milliseconds of latency added

00:02:52.400 --> 00:02:53.200
to your application.

00:02:53.200 --> 00:02:54.930
So it's not just dollars
and cents.

00:02:54.930 --> 00:02:57.580
For many sites, large
sites, it's

00:02:57.580 --> 00:02:59.920
literally millions of dollars.

00:02:59.920 --> 00:03:02.400
So our agenda today is to
actually look at Radio

00:03:02.400 --> 00:03:03.500
Performance 101.

00:03:03.500 --> 00:03:06.040
It's kind of a propeller
hat talk, a little bit.

00:03:06.040 --> 00:03:09.310
And specifically, we'll compare
Wi-Fi and mobile.

00:03:09.310 --> 00:03:11.770
And you'll see why because it's
important to understand

00:03:11.770 --> 00:03:14.090
that even something like Wi-Fi
and mobile networks are

00:03:14.090 --> 00:03:16.960
fundamentally different in
how we schedule, how the

00:03:16.960 --> 00:03:20.060
communication is done, and how
we design our applications, or

00:03:20.060 --> 00:03:23.480
what we can even do to optimize
our applications.

00:03:23.480 --> 00:03:26.930
And we'll also look at some
practical tips for what you

00:03:26.930 --> 00:03:29.090
can do in your applications
to design for this.

00:03:29.090 --> 00:03:31.610
And then I'll leave the last
part for you, which is to

00:03:31.610 --> 00:03:34.280
optimize the profit part.

00:03:34.280 --> 00:03:37.990
So there are tons and tons of
techniques for how to make

00:03:37.990 --> 00:03:39.480
your applications
more performant.

00:03:39.480 --> 00:03:41.540
There is application
optimizations.

00:03:41.540 --> 00:03:43.970
There's HTTP-specific
optimizations, or

00:03:43.970 --> 00:03:45.810
HTTP1-specific optimizations.

00:03:45.810 --> 00:03:47.710
We are not going to
touch on those.

00:03:47.710 --> 00:03:49.430
We're going to mention
them at the very end.

00:03:49.430 --> 00:03:51.440
We're actually going to go
a little bit deeper.

00:03:51.440 --> 00:03:54.830
We're going to go below the
application layer, even below

00:03:54.830 --> 00:03:57.600
the TCP layer, and kind of look
at, like, how does the

00:03:57.600 --> 00:03:58.880
radio actually work?

00:03:58.880 --> 00:04:02.030
So we'll put the wired stuff
aside, look at the radio, and

00:04:02.030 --> 00:04:03.600
dive into Wi-Fi and mobile.

00:04:03.600 --> 00:04:07.610
So 3G and 4G, what's so
special about that?

00:04:07.610 --> 00:04:09.370
How does battery life
play into this?

00:04:09.370 --> 00:04:11.050
It turns out the battery
life is kind

00:04:11.050 --> 00:04:12.120
of the central component.

00:04:12.120 --> 00:04:12.910
There's the radio.

00:04:12.910 --> 00:04:17.010
Then there's the battery,
those are two connected

00:04:17.010 --> 00:04:18.450
components that we need
to think about.

00:04:18.450 --> 00:04:21.220
And what is the radio
resource controller?

00:04:21.220 --> 00:04:23.380
Our friend and foe.

00:04:23.380 --> 00:04:25.090
So let's dive right it.

00:04:25.090 --> 00:04:29.270
First of all, wireless, or
Wi-Fi, came around in the

00:04:29.270 --> 00:04:29.940
early '90s.

00:04:29.940 --> 00:04:32.100
That's when the first standards
were published.

00:04:32.100 --> 00:04:34.850
But really, it only became
popular in the late '90s with

00:04:34.850 --> 00:04:37.880
the release of the B802.11B
standard, which is the 11

00:04:37.880 --> 00:04:39.630
megabits per second standard.

00:04:39.630 --> 00:04:42.050
And the thing to realize about
Wi-Fi is, it was literally

00:04:42.050 --> 00:04:45.290
designed as an extension
to your Local Area

00:04:45.290 --> 00:04:46.550
Network, your LAN.

00:04:46.550 --> 00:04:49.670
So we reuse all the same
framing, protocols,

00:04:49.670 --> 00:04:51.430
mechanisms, all the rest of
them, and basically added a

00:04:51.430 --> 00:04:53.050
wireless interface to it.

00:04:53.050 --> 00:04:56.820
So it is not designed for a
mobile device, which is to

00:04:56.820 --> 00:04:59.500
say, a device with
limited battery.

00:04:59.500 --> 00:05:01.160
It was designed for
your desktop

00:05:01.160 --> 00:05:02.390
computer, your laptop computer.

00:05:02.390 --> 00:05:05.400
We weren't constrained
by power at the time.

00:05:05.400 --> 00:05:09.500
Think back to the phone
that you had in 1999.

00:05:09.500 --> 00:05:11.790
We weren't thinking about the
kinds of applications that

00:05:11.790 --> 00:05:14.120
we're delivering at the time.

00:05:14.120 --> 00:05:17.360
And the thing about Wi-Fi is,
we need to understand how we

00:05:17.360 --> 00:05:20.500
actually schedule, how we
communicate, over Wi-Fi.

00:05:20.500 --> 00:05:23.960
So when we're communicating over
a wired connection, we

00:05:23.960 --> 00:05:27.280
have a switch, or a router,
which routes all the packets

00:05:27.280 --> 00:05:31.630
between the client and
server, for example.

00:05:31.630 --> 00:05:34.250
In Wi-Fi, we share the
radio channel.

00:05:34.250 --> 00:05:36.720
And the radio channel
is a shared medium

00:05:36.720 --> 00:05:37.410
between all of us.

00:05:37.410 --> 00:05:39.470
All of us can't talk
at the same time.

00:05:39.470 --> 00:05:41.000
That would just generate
a lot of noise.

00:05:41.000 --> 00:05:43.070
So we need some sort of a
mechanism to figure out who's

00:05:43.070 --> 00:05:44.090
going to talk when.

00:05:44.090 --> 00:05:46.210
And Wi-Fi takes a very hands
off approach about this.

00:05:46.210 --> 00:05:48.980
It basically says, let's use a
very simple algorithm, which

00:05:48.980 --> 00:05:52.200
is, if you want to talk,
first listen if

00:05:52.200 --> 00:05:53.720
nobody else is talking.

00:05:53.720 --> 00:05:56.390
If nobody else is talking
then start talking.

00:05:56.390 --> 00:05:58.760
And if another person starts
talking while you're talking,

00:05:58.760 --> 00:06:01.840
well then, both of you stop,
wait for random interval of

00:06:01.840 --> 00:06:04.000
time, and repeat the
whole process.

00:06:04.000 --> 00:06:08.130
So it's kind of like this party
algorithm of hey, we'll

00:06:08.130 --> 00:06:11.160
just trust that all of you
behave nicely, and you'll all

00:06:11.160 --> 00:06:12.380
respect each other.

00:06:12.380 --> 00:06:15.550
And we'll just kind of
share this medium.

00:06:15.550 --> 00:06:16.990
That's Wi-Fi.

00:06:16.990 --> 00:06:20.200
Now you can actually model
this and prove that the

00:06:20.200 --> 00:06:23.600
channel load, or the amount of
traffic, needs to be kept

00:06:23.600 --> 00:06:24.250
fairly low.

00:06:24.250 --> 00:06:27.110
In fact, the load of the network
needs to be below 10%

00:06:27.110 --> 00:06:28.860
in order to achieve
good performance.

00:06:28.860 --> 00:06:30.960
You're always going to
have retransmissions.

00:06:30.960 --> 00:06:33.050
There will always be the case
when I start talking, and you

00:06:33.050 --> 00:06:35.320
start talking a little bit
later, and we collide.

00:06:35.320 --> 00:06:37.520
But that's OK, because we will
wait, and then we'll

00:06:37.520 --> 00:06:39.370
retransmit data, and
everything's OK.

00:06:39.370 --> 00:06:41.010
You can get pretty
good performance.

00:06:41.010 --> 00:06:44.150
But after a while, you basically
run into this case

00:06:44.150 --> 00:06:46.130
where there are too many devices
trying to compete for

00:06:46.130 --> 00:06:49.730
the same medium, and the network
basically collapses.

00:06:49.730 --> 00:06:52.520
There's no way to recover
from this state.

00:06:52.520 --> 00:06:55.600
And I'm pretty sure all of us
have experienced this at some

00:06:55.600 --> 00:06:56.640
point, right?

00:06:56.640 --> 00:07:00.770
Wi-Fi and a large group
of people in a room?

00:07:00.770 --> 00:07:04.100
Not a good combination,
oftentimes.

00:07:04.100 --> 00:07:05.840
So that's, in part, why.

00:07:05.840 --> 00:07:08.920
And we can dig a little bit
deeper and actually look at

00:07:08.920 --> 00:07:09.880
how it's implemented.

00:07:09.880 --> 00:07:14.030
So in the 2.4 gigahertz
spectrum, we actually have a

00:07:14.030 --> 00:07:17.390
limited amount of spectrum,
let's say 60 megahertz.

00:07:17.390 --> 00:07:19.800
Within that 60 megahertz, we
can actually have three

00:07:19.800 --> 00:07:22.030
channels, which is to
say up to three

00:07:22.030 --> 00:07:24.070
devices can talk in parallel.

00:07:24.070 --> 00:07:26.530
And they won't interfere
with each other.

00:07:26.530 --> 00:07:27.390
So these are the channels.

00:07:27.390 --> 00:07:29.960
If you guys have ever dug into
your settings on your Wi-Fi

00:07:29.960 --> 00:07:33.010
router, that would be your
channel one, channel six, or

00:07:33.010 --> 00:07:35.750
channel 11, or something
to that extent.

00:07:35.750 --> 00:07:39.860
Now the problem is, this is
nice nice and pretty--

00:07:39.860 --> 00:07:41.950
this is a little chart
that I pulled up

00:07:41.950 --> 00:07:43.530
on my own home network.

00:07:43.530 --> 00:07:45.740
And you can see that there's
over a dozen networks.

00:07:45.740 --> 00:07:47.510
And they're all overlapping.

00:07:47.510 --> 00:07:49.630
We're all trying to talk
over each other.

00:07:49.630 --> 00:07:52.760
And basically, Wi-Fi to
some degree, is a

00:07:52.760 --> 00:07:54.080
victim of its own success.

00:07:54.080 --> 00:07:55.890
It has become so ubiquitous.

00:07:55.890 --> 00:08:00.910
There's so many Wi-Fi routers
out there that it's very hard

00:08:00.910 --> 00:08:03.820
to get a slot to talk to
somebody without interfering

00:08:03.820 --> 00:08:04.500
with anybody.

00:08:04.500 --> 00:08:08.530
So your neighbor, when they
start streaming that HD

00:08:08.530 --> 00:08:11.750
Netflix movie, they're
interfering with you as well.

00:08:11.750 --> 00:08:13.550
Even though it's a different
access point, they're still

00:08:13.550 --> 00:08:16.250
using the same shared
spectrum.

00:08:16.250 --> 00:08:19.000
So there is limited capacity.

00:08:19.000 --> 00:08:24.050
And most networks have tens,
or even more than dozens of

00:08:24.050 --> 00:08:25.100
overlapping networks.

00:08:25.100 --> 00:08:26.560
So here's a fun experiment.

00:08:26.560 --> 00:08:28.270
I ran this at my house.

00:08:28.270 --> 00:08:31.060
So this is not definitive data,
but this is an example,

00:08:31.060 --> 00:08:32.150
a data point.

00:08:32.150 --> 00:08:35.679
There's about 15 access
points just in

00:08:35.679 --> 00:08:37.130
and around my apartment.

00:08:37.130 --> 00:08:38.640
And I ran this very
simple test.

00:08:38.640 --> 00:08:41.090
I took my laptop, and I had
my router, which was

00:08:41.090 --> 00:08:42.020
about 15 feet away.

00:08:42.020 --> 00:08:43.240
And I was staring right at it.

00:08:43.240 --> 00:08:46.380
And I figured hey, how long does
it take for one packet to

00:08:46.380 --> 00:08:49.070
get from my laptop
to my router?

00:08:49.070 --> 00:08:51.470
Like what is the latency
of that first hop?

00:08:51.470 --> 00:08:54.720
And I gathered data
for several hours.

00:08:54.720 --> 00:08:56.910
So this is a good
sample of data.

00:08:56.910 --> 00:09:01.410
And if you look at the numbers
here, the 95th percentile is

00:09:01.410 --> 00:09:03.280
about 50 milliseconds.

00:09:03.280 --> 00:09:06.840
So to travel 15 feet from my
laptop to my router, it was

00:09:06.840 --> 00:09:10.650
taking about 50 milliseconds,
which is crazy because 50

00:09:10.650 --> 00:09:12.680
milliseconds is about the amount
of time it takes to

00:09:12.680 --> 00:09:14.970
travel from the West Coast
to the East Coast.

00:09:14.970 --> 00:09:19.830
So here I am trying to shuttle
a packet 15 feet away to my

00:09:19.830 --> 00:09:20.830
wireless router.

00:09:20.830 --> 00:09:23.230
So this is a function of,
there's just a lot of other

00:09:23.230 --> 00:09:26.270
activity in the vicinity,
so we're competing

00:09:26.270 --> 00:09:27.520
for the same spectrum.

00:09:27.520 --> 00:09:29.560
So then I tried something
different.

00:09:29.560 --> 00:09:31.830
I actually went out and bought
a different router, which is

00:09:31.830 --> 00:09:36.640
using the new 802.11N standard
and it's running on the 5

00:09:36.640 --> 00:09:37.350
gigahertz band.

00:09:37.350 --> 00:09:40.210
And the 5 gigahertz band gives
us more bandwidth.

00:09:40.210 --> 00:09:43.360
And by the function of the fact
that it's also new, not

00:09:43.360 --> 00:09:45.330
many people are using it.

00:09:45.330 --> 00:09:48.890
So I was the lone person
on that channel, and I

00:09:48.890 --> 00:09:49.840
ran the same test.

00:09:49.840 --> 00:09:53.620
And there you go, my 95th
percentile latency is down to

00:09:53.620 --> 00:09:55.480
two milliseconds.

00:09:55.480 --> 00:09:57.680
So as far as I'm concerned,
that was a fantastic

00:09:57.680 --> 00:09:58.350
investment.

00:09:58.350 --> 00:10:01.080
So if nothing else, you can go
back home, upgrade your router

00:10:01.080 --> 00:10:04.590
to 5 gigahertz, hope that not
many of you are living in the

00:10:04.590 --> 00:10:07.650
same neighborhood, and you're
not competing with each other,

00:10:07.650 --> 00:10:09.730
and then you'll get much
better performance, web

00:10:09.730 --> 00:10:10.500
performance.

00:10:10.500 --> 00:10:12.510
We just cut 50 milliseconds
of latency.

00:10:12.510 --> 00:10:15.860
That is huge for performance.

00:10:15.860 --> 00:10:18.100
So some takeaways from this.

00:10:18.100 --> 00:10:22.310
First of all, Wi-Fi makes no
guarantees about the bandwidth

00:10:22.310 --> 00:10:23.980
or the data rate you're
going to get.

00:10:23.980 --> 00:10:26.090
Anybody else can start
transmitting at

00:10:26.090 --> 00:10:27.840
any point in time.

00:10:27.840 --> 00:10:29.090
So it's unpredictable.

00:10:33.430 --> 00:10:35.650
One way to deal with
this is to adapt to

00:10:35.650 --> 00:10:36.840
the variable bandwidth.

00:10:36.840 --> 00:10:37.860
Not to predict it--

00:10:37.860 --> 00:10:38.810
you can't predict it.

00:10:38.810 --> 00:10:40.160
You can only adapt to it.

00:10:40.160 --> 00:10:43.910
So we leverage this to, for
example, serve video.

00:10:43.910 --> 00:10:46.580
When we serve video on YouTube,
we serve it in small

00:10:46.580 --> 00:10:50.710
chunks, like 5 to 10 second
chunks where we stream a chunk

00:10:50.710 --> 00:10:53.620
of video, we see if you can
download it fast enough.

00:10:53.620 --> 00:10:55.430
If you can download it fast
enough, we can upgrade you to

00:10:55.430 --> 00:10:58.610
a higher quality stream.

00:10:58.610 --> 00:11:01.770
Vice versa, if your bandwidth
was all of a sudden cut in

00:11:01.770 --> 00:11:04.260
half because somebody else is
streaming a video, we will

00:11:04.260 --> 00:11:07.960
downgrade you seamlessly to
a lower resolution video.

00:11:07.960 --> 00:11:10.670
So that's adaptive streaming.

00:11:10.670 --> 00:11:12.960
And that's something you can do
as well if you're streaming

00:11:12.960 --> 00:11:15.330
music, streaming video,
or other things.

00:11:15.330 --> 00:11:17.460
The other variable that you
can't really control with

00:11:17.460 --> 00:11:20.600
Wi-Fi is, of course,
latency and jitter.

00:11:20.600 --> 00:11:24.100
So because we have these
collisions all the time, and

00:11:24.100 --> 00:11:26.180
your packets need to be
retransmitted, and there's not

00:11:26.180 --> 00:11:26.760
much you can do.

00:11:26.760 --> 00:11:28.795
Wi-Fi provides no guarantees
about this.

00:11:28.795 --> 00:11:33.860
So if you've ever tried to
implement a real time chat or

00:11:33.860 --> 00:11:37.070
real time voice and video over
Wi-Fi, you've certainly run

00:11:37.070 --> 00:11:38.270
into this problem.

00:11:38.270 --> 00:11:41.470
So perhaps the only thing you
can really do is start looking

00:11:41.470 --> 00:11:45.170
into something like WebRTC which
allows you to leverage

00:11:45.170 --> 00:11:47.180
unreliable delivery and
basically [? UDP ?]

00:11:47.180 --> 00:11:47.890
in a browser.

00:11:47.890 --> 00:11:51.480
And we had a great session
on WebRTC earlier today.

00:11:51.480 --> 00:11:55.280
So if you guys missed it, check
out the video for that.

00:11:55.280 --> 00:11:56.630
So that's Wi-Fi.

00:11:56.630 --> 00:11:59.240
So that's just a baseline.

00:11:59.240 --> 00:12:02.420
Now let's take a look at
2G, 3G, 4G networks.

00:12:02.420 --> 00:12:05.810
How do they work and how
are they different?

00:12:05.810 --> 00:12:12.100
So first of all, when the mobile
standards started they

00:12:12.100 --> 00:12:16.400
set aside some specific
constraints that they needed

00:12:16.400 --> 00:12:17.270
to optimize for.

00:12:17.270 --> 00:12:20.980
First is they needed to
guarantee some level of

00:12:20.980 --> 00:12:22.040
performance.

00:12:22.040 --> 00:12:24.880
So they wanted to make sure
that they don't have this

00:12:24.880 --> 00:12:28.500
congestion collapse scenario
which is present in Wi-Fi.

00:12:28.500 --> 00:12:30.980
They want to have some knobs to
tweak to say, if this is a

00:12:30.980 --> 00:12:33.070
really overloaded network,
we will lower the

00:12:33.070 --> 00:12:34.440
data rates for everybody.

00:12:34.440 --> 00:12:37.230
But you can still sort of
get a lower data rate.

00:12:37.230 --> 00:12:38.610
But we want to be able
to control that.

00:12:38.610 --> 00:12:39.750
And we need some
knobs for that.

00:12:39.750 --> 00:12:41.520
So that's number one.

00:12:41.520 --> 00:12:44.300
Second is, of course we're
covering a much larger

00:12:44.300 --> 00:12:47.770
geographical area, which means
that, once again, we need to

00:12:47.770 --> 00:12:49.120
handle more clients.

00:12:49.120 --> 00:12:51.750
And that's something we
need to account for.

00:12:51.750 --> 00:12:54.260
And the second one is
our battery life.

00:12:54.260 --> 00:12:57.500
So it turns out, when you're
optimizing for mobile devices,

00:12:57.500 --> 00:13:00.160
you really need to think
about battery life.

00:13:00.160 --> 00:13:05.370
I think, for many of us, if
we use our mobile device

00:13:05.370 --> 00:13:08.250
actively, you'll find that your
batteries is draining

00:13:08.250 --> 00:13:09.350
very, very quickly.

00:13:09.350 --> 00:13:14.450
So radio is a very important
component of that.

00:13:14.450 --> 00:13:17.520
You add these two things
together, and you get the

00:13:17.520 --> 00:13:19.790
Radio Resource Controller.

00:13:19.790 --> 00:13:22.660
And what is the Radio
Resource Controller?

00:13:22.660 --> 00:13:26.530
So mobile networks, the 2G, 3G,
and 4G standards, take a

00:13:26.530 --> 00:13:29.880
different approach as to how
they schedule when you can

00:13:29.880 --> 00:13:30.780
communicate.

00:13:30.780 --> 00:13:34.380
Instead of doing this freebie
approach of you just start

00:13:34.380 --> 00:13:36.880
talking when you think nobody
else is talking, they're

00:13:36.880 --> 00:13:39.050
actually employing a moderator,
which is to say,

00:13:39.050 --> 00:13:41.900
the radio tower actually tells
you when you can speak.

00:13:41.900 --> 00:13:44.350
You tell the radio tower
that hey, I would like

00:13:44.350 --> 00:13:45.500
to send some data.

00:13:45.500 --> 00:13:48.940
And then the radio tower
consults its schedule and

00:13:48.940 --> 00:13:51.320
tells you, OK, I've got
these five people

00:13:51.320 --> 00:13:52.400
that are queued up.

00:13:52.400 --> 00:13:53.610
You're this far away.

00:13:53.610 --> 00:13:56.280
So you start transmitting at
this point in time with this

00:13:56.280 --> 00:13:59.000
signal power, with these
parameters, with this

00:13:59.000 --> 00:14:02.220
encoding, and then you have
this amount of time.

00:14:02.220 --> 00:14:05.260
So it's a very different
scheduling mechanism.

00:14:05.260 --> 00:14:07.820
And as you can imagine, this
adds a lot more overhead.

00:14:07.820 --> 00:14:10.780
But it allows us to schedule
resources more efficiently

00:14:10.780 --> 00:14:11.800
within the network.

00:14:11.800 --> 00:14:14.710
And this obviously has
its pros and cons.

00:14:14.710 --> 00:14:18.920
So the Radio Resource Controller
lives within a

00:14:18.920 --> 00:14:23.350
different component of the
network infrastructure.

00:14:23.350 --> 00:14:25.270
In 2G and 3G network,
it was actually

00:14:25.270 --> 00:14:26.600
living in the core network.

00:14:26.600 --> 00:14:28.790
In the latest networks, it is
living right at the radio

00:14:28.790 --> 00:14:31.710
tower, which is one of the ways
of how we're improving

00:14:31.710 --> 00:14:33.280
performance in 4G networks.

00:14:33.280 --> 00:14:37.050
By moving it closer to you,
we're reducing the latency.

00:14:37.050 --> 00:14:40.460
But the Radio Resource
Controller has a number of

00:14:40.460 --> 00:14:41.650
implications.

00:14:41.650 --> 00:14:45.270
So the first of these is the
difference and the distinction

00:14:45.270 --> 00:14:49.490
between the control and the
user-plane latency.

00:14:49.490 --> 00:14:53.400
So whenever you talk to anybody
that's working in the

00:14:53.400 --> 00:14:56.590
mobile space, they'll often
throw this out and mention the

00:14:56.590 --> 00:14:57.870
control-plane latency.

00:14:57.870 --> 00:14:59.280
What is it?

00:14:59.280 --> 00:15:02.760
Recall that we need to talk to
the radio tower to figure out

00:15:02.760 --> 00:15:04.990
when we're allowed to
transfer the data.

00:15:04.990 --> 00:15:05.720
This is what happens.

00:15:05.720 --> 00:15:08.120
First, you send a message to the
radio tower, and you say,

00:15:08.120 --> 00:15:09.900
I'd like to send data.

00:15:09.900 --> 00:15:13.080
The radio tower determines
when you can talk.

00:15:13.080 --> 00:15:14.390
And then it sends you
a message back.

00:15:14.390 --> 00:15:16.840
That is the control-plane
latency.

00:15:16.840 --> 00:15:21.900
And in 3G networks, this can
take up to 2 and 1/2 seconds.

00:15:21.900 --> 00:15:23.260
2 and 1/2 seconds.

00:15:23.260 --> 00:15:26.720
We haven't even sent a packet
of data, application data,

00:15:26.720 --> 00:15:28.970
from your phone, we're just
basically trying to get a

00:15:28.970 --> 00:15:31.110
resource assignment from
the radio tower.

00:15:31.110 --> 00:15:33.960
In 4G networks, and the latest
generation networks, this time

00:15:33.960 --> 00:15:36.270
is significantly improved.

00:15:36.270 --> 00:15:38.570
It's under 100 milliseconds.

00:15:38.570 --> 00:15:41.100
But nonetheless, every
millisecond counts, and 100

00:15:41.100 --> 00:15:43.580
milliseconds is a significant
amount of time.

00:15:43.580 --> 00:15:46.770
And then only after we've
incurred this cost, and we've

00:15:46.770 --> 00:15:50.880
gotten our resource assignment,
can we then start

00:15:50.880 --> 00:15:54.400
transmitting data from our
phone to the radio tower.

00:15:54.400 --> 00:15:57.020
And that is known as the
user-plane latency.

00:15:57.020 --> 00:16:00.070
And for example, in 4G networks,
that can be about 10

00:16:00.070 --> 00:16:01.100
milliseconds.

00:16:01.100 --> 00:16:04.160
So we are definitely in the
weeds here looking at how the

00:16:04.160 --> 00:16:05.710
mobile radio works.

00:16:05.710 --> 00:16:09.370
But some important
takeaways there.

00:16:09.370 --> 00:16:10.940
Let's take this from
the ground up.

00:16:10.940 --> 00:16:11.990
Your phone is idle.

00:16:11.990 --> 00:16:12.700
It's been asleep.

00:16:12.700 --> 00:16:13.910
You take it out of
your pocket.

00:16:13.910 --> 00:16:15.810
You start typing a URL.

00:16:15.810 --> 00:16:17.180
You hit go.

00:16:17.180 --> 00:16:18.880
What happens?

00:16:18.880 --> 00:16:20.800
So this is a 4G network.

00:16:20.800 --> 00:16:22.460
First, we need to talk
to the tower.

00:16:22.460 --> 00:16:24.260
So we're going to occur
at least 100

00:16:24.260 --> 00:16:25.950
milliseconds of latency.

00:16:25.950 --> 00:16:29.270
Then our phone is active and
starts transmitting data, or

00:16:29.270 --> 00:16:31.930
the radio is active, and it
starts transmitting data.

00:16:31.930 --> 00:16:37.210
After some time, it will
actually downgrade your radio

00:16:37.210 --> 00:16:40.640
into a short sleep cycle, which
is to say, it's not

00:16:40.640 --> 00:16:42.680
going to listen for
transmissions all the time.

00:16:42.680 --> 00:16:46.840
It'll sleep for some time, and
it'll wake up periodically to

00:16:46.840 --> 00:16:47.690
save power.

00:16:47.690 --> 00:16:50.660
It turns out that the radio is
the second most expensive

00:16:50.660 --> 00:16:54.670
component in terms of power or
energy use in your phone after

00:16:54.670 --> 00:16:55.670
the screen.

00:16:55.670 --> 00:16:58.240
So this is why we want
to turn off the radio

00:16:58.240 --> 00:16:59.820
as quickly as possible.

00:16:59.820 --> 00:17:02.720
And in the case of 4G networks,
this is usually done

00:17:02.720 --> 00:17:05.439
after 100 milliseconds of
inactivity on your radio.

00:17:05.439 --> 00:17:06.780
So we've transmitted
some data.

00:17:06.780 --> 00:17:09.920
We wait for a 100 millisecond
pause, and then we downgrade

00:17:09.920 --> 00:17:12.520
your radio into this
half sleep state.

00:17:12.520 --> 00:17:15.770
And at that point, if you want
to transmit data again, we

00:17:15.770 --> 00:17:19.240
need to go through that whole
control-plane cycle once more.

00:17:19.240 --> 00:17:23.790
So you're once again incurring
this same cost.

00:17:23.790 --> 00:17:26.670
But then, if your phone
continues to be idle, we wait

00:17:26.670 --> 00:17:27.859
for another 100 milliseconds.

00:17:27.859 --> 00:17:31.700
We go into the second, the
long sleep mode, and only

00:17:31.700 --> 00:17:34.940
after about 10 seconds,
we will go back

00:17:34.940 --> 00:17:36.510
into the idle mode.

00:17:36.510 --> 00:17:38.910
So a kind of pretty complicated
flow chart.

00:17:38.910 --> 00:17:41.940
But effectively, what this says
is, first, we have to

00:17:41.940 --> 00:17:44.110
incur the cost to upgrade
the radio.

00:17:44.110 --> 00:17:46.120
And then it takes a roughly
10 seconds to get

00:17:46.120 --> 00:17:47.380
back to idle mode.

00:17:47.380 --> 00:17:51.890
And this is very important,
as you'll see in a second.

00:17:51.890 --> 00:17:53.160
So let's put this together.

00:17:53.160 --> 00:17:54.300
This is pretty low level.

00:17:54.300 --> 00:17:57.600
How does the effect an actual
data transfer, something like

00:17:57.600 --> 00:17:59.230
an HTTP data transfer?

00:17:59.230 --> 00:18:01.280
So let's start from
the beginning.

00:18:01.280 --> 00:18:03.380
We want to send a request, which
means we need to do a

00:18:03.380 --> 00:18:04.130
DNS lookup.

00:18:04.130 --> 00:18:05.900
We may need to do
a DNS lookup.

00:18:05.900 --> 00:18:08.670
We need to do a TCP handshake,
followed by dispatching the

00:18:08.670 --> 00:18:11.170
actual HTTP request, and
then we actually need

00:18:11.170 --> 00:18:12.510
to fetch the content.

00:18:12.510 --> 00:18:17.800
And maybe optionally, we need
to do the TLS handshake,

00:18:17.800 --> 00:18:22.420
another up to two round
trips there.

00:18:22.420 --> 00:18:25.350
So let's add up all
these numbers.

00:18:25.350 --> 00:18:28.230
First of all, we have the
control plane latency, which

00:18:28.230 --> 00:18:30.300
is the time to wake up
the radio and get

00:18:30.300 --> 00:18:31.330
into the active state.

00:18:31.330 --> 00:18:34.770
So I'm using HSPA here,
which is a 3G network.

00:18:34.770 --> 00:18:38.360
And I'm using an average round
trip time of about 200

00:18:38.360 --> 00:18:41.460
milliseconds, which is roughly
the time that we see at Google

00:18:41.460 --> 00:18:42.910
for 3G networks.

00:18:42.910 --> 00:18:45.810
And then, for 4G networks, these
new generation networks,

00:18:45.810 --> 00:18:48.770
let's use 80 milliseconds
which is actually fairly

00:18:48.770 --> 00:18:50.900
aggressive.

00:18:50.900 --> 00:18:56.950
So 200 to 2.5 seconds, so 200
milliseconds to 2 and 1/2

00:18:56.950 --> 00:18:58.680
seconds, just to get out of

00:18:58.680 --> 00:19:00.830
control-plane for the 3G network.

00:19:00.830 --> 00:19:03.660
And then we have these round
trips to fetch the DNS, to

00:19:03.660 --> 00:19:05.260
establish TCP, and
all the rest.

00:19:05.260 --> 00:19:07.700
And very quickly, you add
up all these numbers.

00:19:07.700 --> 00:19:11.300
This is without your server
response time.

00:19:11.300 --> 00:19:14.150
We already have over
half a second of

00:19:14.150 --> 00:19:16.260
just network latency.

00:19:16.260 --> 00:19:18.410
And this is very important if
you're trying to design a

00:19:18.410 --> 00:19:21.430
responsive application that
feels responsive to the user.

00:19:21.430 --> 00:19:24.050
So the good news is, things are
definitely getting better

00:19:24.050 --> 00:19:25.250
and better with 4G.

00:19:25.250 --> 00:19:27.530
We're down into hundreds
of milliseconds and

00:19:27.530 --> 00:19:29.020
half a second territory.

00:19:29.020 --> 00:19:32.190
But we also can't rely on 4G,
as you'll see in a second.

00:19:32.190 --> 00:19:35.300
So really, you should assume
that there is literally

00:19:35.300 --> 00:19:39.050
seconds of network latency
overhead when you design your

00:19:39.050 --> 00:19:40.300
applications.

00:19:42.450 --> 00:19:46.100
So the first takeaway here is,
we know that there are some

00:19:46.100 --> 00:19:50.480
constants that good applications
need to follow.

00:19:50.480 --> 00:19:53.690
A number of different User
Experience Research studies

00:19:53.690 --> 00:19:56.270
have shown that, in order for
an app to feel instant, they

00:19:56.270 --> 00:19:58.600
need to respond to the user, it
needs to acknowledge user

00:19:58.600 --> 00:20:00.890
input within hundreds
of milliseconds.

00:20:00.890 --> 00:20:03.990
And we just saw that, even on
the latest 4G network, you're

00:20:03.990 --> 00:20:07.200
incurring 300 to 500
milliseconds, which means that

00:20:07.200 --> 00:20:10.880
you, basically, you cannot wait
for the HTTP request, or

00:20:10.880 --> 00:20:12.050
any request, to complete.

00:20:12.050 --> 00:20:15.000
You need to acknowledge the user
input independently of

00:20:15.000 --> 00:20:16.630
dispatching the request.

00:20:16.630 --> 00:20:18.240
So acknowledge the input.

00:20:18.240 --> 00:20:20.020
Send the request in
the background.

00:20:20.020 --> 00:20:25.740
That is the only way you will
have an application that feels

00:20:25.740 --> 00:20:27.380
instant to the user.

00:20:27.380 --> 00:20:31.900
So all communication should
be asynchronous.

00:20:31.900 --> 00:20:35.370
Similarly, you should anticipate
the RRC latency.

00:20:35.370 --> 00:20:38.430
It's a very common complaint
about mobile network that, oh

00:20:38.430 --> 00:20:41.110
my god, they're so
unpredictable, the variability

00:20:41.110 --> 00:20:42.220
is so high.

00:20:42.220 --> 00:20:45.420
Turns out, once you're aware of
the control-plane latency,

00:20:45.420 --> 00:20:48.110
or of this negotiation at the
beginning, which is the time

00:20:48.110 --> 00:20:51.890
to wake up your radio, you can
model this stuff very well.

00:20:51.890 --> 00:20:54.990
And you can build, and you can
bake these things into the

00:20:54.990 --> 00:20:56.620
design process of your
application.

00:20:56.620 --> 00:20:58.350
Once you talk to the designers,
and you let them

00:20:58.350 --> 00:21:01.030
know that, hey, it may actually
take two seconds

00:21:01.030 --> 00:21:03.640
before we can do anything, like
even send an application

00:21:03.640 --> 00:21:07.550
packet, they can design your
application in a way that

00:21:07.550 --> 00:21:10.290
provides some sort of feedback
to the user that, hey, we're

00:21:10.290 --> 00:21:14.370
working on processing
your input, but

00:21:14.370 --> 00:21:17.360
it may take a while.

00:21:17.360 --> 00:21:20.470
All right, so moving on,
we talked about energy.

00:21:20.470 --> 00:21:24.890
So this is another gotcha that,
I think, is top of mind

00:21:24.890 --> 00:21:28.950
for a lot of applications that
are native applications, but

00:21:28.950 --> 00:21:31.690
is not yet top of mind for a
lot of web applications.

00:21:31.690 --> 00:21:34.860
But it certainly will be soon.

00:21:34.860 --> 00:21:38.380
So notice that, in our earlier
diagram, we said it takes

00:21:38.380 --> 00:21:41.680
about 10 seconds to cycle from
a high power state into a low

00:21:41.680 --> 00:21:42.770
power state.

00:21:42.770 --> 00:21:46.510
This actually causes what is
known as an energy tail, where

00:21:46.510 --> 00:21:50.030
it doesn't matter how much data
you have transferred, the

00:21:50.030 --> 00:21:52.390
radio will be active for a
certain period of time.

00:21:52.390 --> 00:21:55.400
Like, you could have transferred
one bit or one

00:21:55.400 --> 00:21:56.195
byte of data.

00:21:56.195 --> 00:21:57.250
It doesn't matter.

00:21:57.250 --> 00:21:59.460
Or you could have transferred
10 kilobytes, or 100

00:21:59.460 --> 00:22:00.390
kilobytes of data.

00:22:00.390 --> 00:22:02.910
The radio's going to be on,
effectively, for 10 seconds

00:22:02.910 --> 00:22:04.070
after that.

00:22:04.070 --> 00:22:08.400
So you're not going
to save much by

00:22:08.400 --> 00:22:10.490
sending data bit by bit.

00:22:10.490 --> 00:22:12.470
What you want to do is, you want
to send as much data as

00:22:12.470 --> 00:22:15.670
possible as early as possible.

00:22:15.670 --> 00:22:20.330
And in fact, intermittent data
transfers is a huge huge

00:22:20.330 --> 00:22:22.630
performance anti pattern
on mobile.

00:22:22.630 --> 00:22:24.590
So I have an example of this.

00:22:24.590 --> 00:22:28.200
An average mobile device today
has about five Watt-hours of

00:22:28.200 --> 00:22:29.140
battery capacity.

00:22:29.140 --> 00:22:30.760
And don't worry about
the units too much.

00:22:30.760 --> 00:22:33.030
This is just to illustrate
a point.

00:22:33.030 --> 00:22:35.790
And five Watt-hours is
about 18,000 joules.

00:22:35.790 --> 00:22:38.470
And it turns out that an average
phone today of a 4G

00:22:38.470 --> 00:22:42.260
connection, in order to cycle
from a low state, to high

00:22:42.260 --> 00:22:45.430
state, back to low state,
will take about

00:22:45.430 --> 00:22:47.310
10 joules of energy.

00:22:47.310 --> 00:22:48.870
Let's do our math.

00:22:48.870 --> 00:22:52.300
Let's say we have one minute
pulling interval.

00:22:52.300 --> 00:22:54.770
So I built an application,
like a Gmail application,

00:22:54.770 --> 00:22:57.500
which, every minute, will wake
up and just ping the server

00:22:57.500 --> 00:22:59.290
and say, do I have an email?

00:22:59.290 --> 00:23:02.800
Are there any messages for me?

00:23:02.800 --> 00:23:04.560
You multiply that out, it
turns out that this

00:23:04.560 --> 00:23:09.610
application will consume 3%
of battery life per hour.

00:23:09.610 --> 00:23:11.260
Now you have a couple of
these applications

00:23:11.260 --> 00:23:12.360
running on your phone.

00:23:12.360 --> 00:23:14.570
They have non-overlapping
intervals.

00:23:14.570 --> 00:23:16.800
You have your phone in your
pocket for half a day, you

00:23:16.800 --> 00:23:18.650
take it out, your battery
is at 25%.

00:23:18.650 --> 00:23:20.670
And you're wondering what
the heck happened there?

00:23:20.670 --> 00:23:22.200
That's what happened there.

00:23:22.200 --> 00:23:25.000
We're doing these intermittent
things and that was draining

00:23:25.000 --> 00:23:25.750
the battery.

00:23:25.750 --> 00:23:29.440
So intermittent data transfers
are extremely expensive.

00:23:29.440 --> 00:23:32.940
And there's a really cool case
study that was done as a joint

00:23:32.940 --> 00:23:35.860
case study between
AT&amp;T and Pandora.

00:23:35.860 --> 00:23:40.400
They analyzed the native Pandora
application, which is,

00:23:40.400 --> 00:23:42.390
of course, a music streaming
application.

00:23:42.390 --> 00:23:43.800
And then discovered something
interesting.

00:23:43.800 --> 00:23:45.550
Pandora was doing all
the right things.

00:23:45.550 --> 00:23:47.150
When they were streaming
music, you would

00:23:47.150 --> 00:23:48.070
start playing the song.

00:23:48.070 --> 00:23:51.620
They would stream the entire
song down to the client and

00:23:51.620 --> 00:23:52.620
just play the whole thing.

00:23:52.620 --> 00:23:54.370
So they would turn off the
radio, which is exactly what

00:23:54.370 --> 00:23:55.380
you want to do.

00:23:55.380 --> 00:24:00.130
But then, about every, I think,
58 seconds, or 60

00:24:00.130 --> 00:24:03.920
seconds, Pandora would fire an
analytics beacon which was

00:24:03.920 --> 00:24:07.120
reporting how far along did you
listen in the song, did

00:24:07.120 --> 00:24:09.810
you like the song, and
all the rest--

00:24:09.810 --> 00:24:11.265
it seems reasonable.

00:24:11.265 --> 00:24:14.820
They analyzed it and realized
that those data transfers were

00:24:14.820 --> 00:24:19.050
accounting to 0.2% of the total
bytes transferred, but

00:24:19.050 --> 00:24:23.540
it was 46% of the battery life
of that application, which is

00:24:23.540 --> 00:24:28.770
a huge, of course, performance
problem.

00:24:28.770 --> 00:24:31.060
So all they had to
do was to move--

00:24:31.060 --> 00:24:32.840
these are not critical
beacons.

00:24:32.840 --> 00:24:35.350
They could simply defer that
until later, until the next

00:24:35.350 --> 00:24:37.880
song data transfer that could
accumulate this data.

00:24:37.880 --> 00:24:40.850
And they did exactly that, and
they significantly improved

00:24:40.850 --> 00:24:43.680
the performance of their
application.

00:24:43.680 --> 00:24:45.560
So here are a couple
of examples.

00:24:45.560 --> 00:24:47.800
It's a little bit small, but I
was looking at, for example

00:24:47.800 --> 00:24:49.710
CNN.com here.

00:24:49.710 --> 00:24:52.790
And I noticed that they have a
real time analytics beacon

00:24:52.790 --> 00:24:54.000
installed on their site.

00:24:54.000 --> 00:24:56.230
So whenever you're reading a
CNN article on your mobile

00:24:56.230 --> 00:25:00.200
phone, about every five seconds
[? Charredbeat ?]

00:25:00.200 --> 00:25:02.990
sends a beacon saying,
I'm still here.

00:25:02.990 --> 00:25:04.225
Yep, I'm still here.

00:25:04.225 --> 00:25:05.520
Yep, I'm still alive.

00:25:05.520 --> 00:25:08.420
And guess, as you're reading
CNN, you're just draining your

00:25:08.420 --> 00:25:11.530
battery, which is not
a great experience.

00:25:11.530 --> 00:25:14.010
So in Google Analytics, we
actually caught this

00:25:14.010 --> 00:25:14.940
problem early on.

00:25:14.940 --> 00:25:16.740
And we fixed it.

00:25:16.740 --> 00:25:19.150
And we don't do this.

00:25:19.150 --> 00:25:21.490
We have a different way, where
we provide real time

00:25:21.490 --> 00:25:24.400
analytics, but we have a way to
do that without requiring

00:25:24.400 --> 00:25:25.670
these beacons.

00:25:25.670 --> 00:25:29.070
So the short takeaway is, if you
are sending these kinds of

00:25:29.070 --> 00:25:31.930
beacons in your application,
web or native, definitely

00:25:31.930 --> 00:25:33.240
something to reconsider because

00:25:33.240 --> 00:25:35.800
it's extremely expensive.

00:25:35.800 --> 00:25:39.550
Now unfortunately today, I don't
think many platforms

00:25:39.550 --> 00:25:42.210
provide very good
instrumentation or visibility

00:25:42.210 --> 00:25:46.480
into how much energy does
my application consume--

00:25:46.480 --> 00:25:49.190
whether that's web or native.

00:25:49.190 --> 00:25:54.270
But one tool that is actually
very good is the AT&amp;Ts Arrow

00:25:54.270 --> 00:25:56.220
tool, which is a free and
open source tool.

00:25:56.220 --> 00:25:58.610
And I will show you guys
a quick demo of this.

00:26:01.770 --> 00:26:02.580
I've have it running here.

00:26:02.580 --> 00:26:04.800
So what it allows you to do is,
it allows you to capture a

00:26:04.800 --> 00:26:05.490
trace file.

00:26:05.490 --> 00:26:08.640
You can actually install an
application on your Android

00:26:08.640 --> 00:26:11.340
device, you hit Record, and
you interact with your

00:26:11.340 --> 00:26:12.030
application.

00:26:12.030 --> 00:26:14.230
Then you export a trace, and you
can analyze it with this

00:26:14.230 --> 00:26:15.010
analyzer tool.

00:26:15.010 --> 00:26:17.030
So I've already prerecorded a
trace, and I'm just going to

00:26:17.030 --> 00:26:19.550
show it to you guys here.

00:26:19.550 --> 00:26:22.400
So let me load this app here.

00:26:22.400 --> 00:26:27.400
And you can also run it in an
emulator, but I prefer to do

00:26:27.400 --> 00:26:28.710
it on my phone.

00:26:28.710 --> 00:26:31.030
So I loaded a website.

00:26:31.030 --> 00:26:32.090
I have this trace.

00:26:32.090 --> 00:26:34.360
One of the cool things is
provides is, it can actually

00:26:34.360 --> 00:26:35.840
record your screen.

00:26:35.840 --> 00:26:37.860
So here I'm starting
Collector.

00:26:37.860 --> 00:26:40.660
And I'll just fast forward
a little bit.

00:26:40.660 --> 00:26:42.880
So I'm loading the site
Red Robin here.

00:26:42.880 --> 00:26:45.570
And you can actually look at the
diagnostics screen here.

00:26:45.570 --> 00:26:46.990
And you can see this
line moving here.

00:26:46.990 --> 00:26:51.440
So this is us downloading the
page, and you can see the

00:26:51.440 --> 00:26:54.440
throughput, the different RFC
states, or the states of the

00:26:54.440 --> 00:26:57.440
radio, and the energy
consumption on your app.

00:26:57.440 --> 00:27:00.250
So let me pause this.

00:27:00.250 --> 00:27:03.710
And one of the cool things
about this tool is, it'll

00:27:03.710 --> 00:27:05.940
actually also analyze the
content that you're

00:27:05.940 --> 00:27:08.300
downloading and point
out common

00:27:08.300 --> 00:27:10.300
performance anti patterns.

00:27:10.300 --> 00:27:12.780
Things like, hey, you're
not caching the data.

00:27:12.780 --> 00:27:16.250
Or you have intermittent
data transfers.

00:27:16.250 --> 00:27:19.520
But then, on top of all of that,
it'll also tell you the

00:27:19.520 --> 00:27:23.950
energy consumed during this
session that you've recorded.

00:27:23.950 --> 00:27:26.020
So you can actually
model this.

00:27:26.020 --> 00:27:28.600
Now one thing to call out
is, this is not an exact

00:27:28.600 --> 00:27:29.110
measurement.

00:27:29.110 --> 00:27:30.270
This is based on a model.

00:27:30.270 --> 00:27:33.110
So it has some assumptions about
the phone that you're

00:27:33.110 --> 00:27:34.810
using and the network
type you're on.

00:27:34.810 --> 00:27:37.420
So you can actually switch those
and say, I want to run

00:27:37.420 --> 00:27:41.520
this model on a 3G network
instead of a 4G network.

00:27:41.520 --> 00:27:44.620
So if nothing else, this is
a great tool to play with.

00:27:44.620 --> 00:27:48.330
And I encourage you guys
to check it out.

00:27:48.330 --> 00:27:50.560
I hope that in the future we'll
have more tools like

00:27:50.560 --> 00:27:54.470
this baked right into our kind
of day to day dev tools, both

00:27:54.470 --> 00:27:58.690
on native and web platforms.

00:27:58.690 --> 00:28:00.780
So it is all about
the battery.

00:28:00.780 --> 00:28:02.710
It literally is all
about the battery.

00:28:02.710 --> 00:28:06.530
Whenever you're wondering why
doesn't my mobile radio behave

00:28:06.530 --> 00:28:09.670
in a certain way, always ask
the question how does it

00:28:09.670 --> 00:28:11.270
impact my battery life?

00:28:11.270 --> 00:28:13.450
And you often find
the answer there.

00:28:13.450 --> 00:28:16.760
Radio at full power, if it's
on all the time, will

00:28:16.760 --> 00:28:19.330
literally drain your battery
in a matter of hours.

00:28:19.330 --> 00:28:24.250
If you've ever had your phone
burning your leg, you know how

00:28:24.250 --> 00:28:29.150
that feels, what's usually
happening there is, you can't

00:28:29.150 --> 00:28:31.090
get a connection, and some
application is just

00:28:31.090 --> 00:28:33.350
continuously trying
to reconnect.

00:28:33.350 --> 00:28:36.420
And that turns on the
radio at full power.

00:28:36.420 --> 00:28:39.590
It drains your battery like
there's no tomorrow.

00:28:39.590 --> 00:28:43.480
And the actual transfer
size does not matter.

00:28:43.480 --> 00:28:44.660
It doesn't matter if
you're transferring

00:28:44.660 --> 00:28:47.110
one byte or 100 kilobytes.

00:28:47.110 --> 00:28:48.740
That's the other important
takeaway.

00:28:48.740 --> 00:28:51.680
So the consequence of that is,
you want to pre-fetch data.

00:28:54.190 --> 00:28:59.210
I'll fetch the previews and the
thumbnails of my awesome

00:28:59.210 --> 00:29:02.280
application, and then, as you
scroll, I'll fetch the rest.

00:29:02.280 --> 00:29:03.690
That's an anti pattern
on mobile.

00:29:03.690 --> 00:29:06.460
You want to pre-fetch as much
data as possible, turn off the

00:29:06.460 --> 00:29:08.020
radio, and then hopefully
keep it off

00:29:08.020 --> 00:29:10.360
for as long as possible.

00:29:10.360 --> 00:29:12.590
And we already talked about
periodic data transfers.

00:29:12.590 --> 00:29:13.640
So what can you do there.

00:29:13.640 --> 00:29:15.830
You can defer the request
until later.

00:29:15.830 --> 00:29:16.850
You can combine them.

00:29:16.850 --> 00:29:20.730
You can launch that data into
a local database like local

00:29:20.730 --> 00:29:24.560
storage and then fire
the request later.

00:29:24.560 --> 00:29:27.770
Of course, we provide some
tools for this, both on

00:29:27.770 --> 00:29:28.660
Android and Chrome.

00:29:28.660 --> 00:29:31.940
So Google Cloud Messaging is
definitely something that you

00:29:31.940 --> 00:29:33.770
guys should check out
and leverage.

00:29:33.770 --> 00:29:37.840
And what it allows you to do is,
you can push notifications

00:29:37.840 --> 00:29:40.870
to our servers, to the Google
Cloud Messaging servers, and

00:29:40.870 --> 00:29:43.740
then those servers will try to
determine an optimal strategy

00:29:43.740 --> 00:29:48.330
to deliver those messages to
your phone by minimizing the

00:29:48.330 --> 00:29:49.470
amount of data transfers.

00:29:49.470 --> 00:29:52.060
So for example, we
just launched

00:29:52.060 --> 00:29:53.610
the support on Chrome.

00:29:53.610 --> 00:29:56.420
We don't yet have feature
parity with Android.

00:29:56.420 --> 00:29:58.100
I hope we get there quick.

00:29:58.100 --> 00:30:01.000
But for example, on Android,
you can actually mark a

00:30:01.000 --> 00:30:03.840
message as delay while idle--

00:30:03.840 --> 00:30:08.300
which is to say, if the user's
phone is idle, don't

00:30:08.300 --> 00:30:09.270
push it right now.

00:30:09.270 --> 00:30:12.980
But when they wake up their
phone, push the message there.

00:30:12.980 --> 00:30:14.890
And not only that, but if you're
going to delay the

00:30:14.890 --> 00:30:17.020
message, this is the
time to live.

00:30:17.020 --> 00:30:19.460
If the user doesn't wake up
their phone within the next

00:30:19.460 --> 00:30:21.590
hour, just drop the message on
the floor because it's no

00:30:21.590 --> 00:30:22.980
longer relevant.

00:30:22.980 --> 00:30:25.150
And it's the combination of
these things that allow you to

00:30:25.150 --> 00:30:28.350
build efficient applications,
where you can have efficient

00:30:28.350 --> 00:30:31.210
delivery of these messages to
the phone without necessarily

00:30:31.210 --> 00:30:34.270
having to wake up the phone or
having your phone wake up

00:30:34.270 --> 00:30:36.710
periodically and query
your service, which

00:30:36.710 --> 00:30:37.960
clearly does not scale.

00:30:40.680 --> 00:30:44.860
So that's a little bit about
how the radio works on the

00:30:44.860 --> 00:30:45.900
phone itself.

00:30:45.900 --> 00:30:49.640
Now let's take a deep dive into
how the mobile network,

00:30:49.640 --> 00:30:52.430
the core network, actually
works, and what implications

00:30:52.430 --> 00:30:55.200
it has on performance.

00:30:55.200 --> 00:31:00.420
So at a very high level, the
mobile network effectively has

00:31:00.420 --> 00:31:02.025
a couple of important
components.

00:31:02.025 --> 00:31:03.790
The first one is the
packet gateway.

00:31:03.790 --> 00:31:06.270
And the way to think about the
packet gateway is, it's

00:31:06.270 --> 00:31:08.710
basically like your wireless
router, or your

00:31:08.710 --> 00:31:10.050
router at your house.

00:31:10.050 --> 00:31:13.310
It's a NAT device which
accepts all of the

00:31:13.310 --> 00:31:13.860
connections.

00:31:13.860 --> 00:31:15.650
It terminates all of
the connections.

00:31:15.650 --> 00:31:18.230
And then it forwards the packets
to your device, in

00:31:18.230 --> 00:31:21.110
this case, a mobile device.

00:31:21.110 --> 00:31:25.350
And there's an important pause
here, which is, your

00:31:25.350 --> 00:31:27.600
connection, or the connection
to your phone between the

00:31:27.600 --> 00:31:30.990
server to your phone, is not
an end to end connection.

00:31:30.990 --> 00:31:33.760
It is being terminated
by this router.

00:31:33.760 --> 00:31:36.597
So just the fact that you're
turning off your radio, or

00:31:36.597 --> 00:31:38.820
you're pressing the power button
on your phone, does not

00:31:38.820 --> 00:31:41.840
terminate the TCP connection,
which I think is a common

00:31:41.840 --> 00:31:42.990
misconception.

00:31:42.990 --> 00:31:46.060
And if you're ever seeing this
kind of pattern, where you

00:31:46.060 --> 00:31:49.010
have your code basically saying,
look, if I turn off

00:31:49.010 --> 00:31:51.850
the radio, I'm going to lose
my WebSocket connection or

00:31:51.850 --> 00:31:54.300
something else, that is not true
because the connection is

00:31:54.300 --> 00:31:56.990
still maintained by
the radio network.

00:31:56.990 --> 00:32:00.100
And it will wake up your radio
when it's necessary.

00:32:00.100 --> 00:32:02.800
So if you have code like this
in your application, you

00:32:02.800 --> 00:32:04.240
definitely want to
turn that off.

00:32:04.240 --> 00:32:08.020
Most carriers have, actually,
timeouts of anywhere between

00:32:08.020 --> 00:32:12.030
five to 30 minutes for
a TCP connection.

00:32:12.030 --> 00:32:15.260
If anything, I've found that, by
working with many different

00:32:15.260 --> 00:32:18.200
apps, it's usually the
application server on your

00:32:18.200 --> 00:32:21.590
side that's terminating the
connection early on.

00:32:21.590 --> 00:32:25.030
Like you have aggressive
timeouts of 60 seconds.

00:32:25.030 --> 00:32:27.680
And then, because of that, your
app needs to periodically

00:32:27.680 --> 00:32:29.970
pull your server to
keep it open.

00:32:29.970 --> 00:32:33.700
So make sure that that
plumbing is correct.

00:32:33.700 --> 00:32:36.970
It's not the carriers
in most cases.

00:32:36.970 --> 00:32:40.160
OK, so we've got the
packet gateway.

00:32:40.160 --> 00:32:41.950
The packet gateway has
no idea about the

00:32:41.950 --> 00:32:43.210
location of your device.

00:32:43.210 --> 00:32:46.990
What it actually does is, it
forwards the packets to the

00:32:46.990 --> 00:32:48.930
serving gateway.

00:32:48.930 --> 00:32:52.210
And the serving gateway needs
to figure out, where are you

00:32:52.210 --> 00:32:54.680
and where is your device?

00:32:54.680 --> 00:32:56.230
The trick is, the
serving gateway

00:32:56.230 --> 00:32:57.570
doesn't know that either.

00:32:57.570 --> 00:33:00.180
It basically needs to query a
local database, like a user

00:33:00.180 --> 00:33:03.710
database, to say which radio
tower are you currently

00:33:03.710 --> 00:33:04.820
associated with.

00:33:04.820 --> 00:33:06.780
And how is your billing
status?

00:33:06.780 --> 00:33:09.740
Should I even be forwarding
this packet to begin with?

00:33:09.740 --> 00:33:12.480
So that's this mobility
management entity.

00:33:12.480 --> 00:33:13.950
So just like a user database.

00:33:13.950 --> 00:33:16.950
That's all it is.

00:33:16.950 --> 00:33:20.300
All right, so let's try this.

00:33:20.300 --> 00:33:24.800
Let's say we want to send a data
packet from your phone.

00:33:24.800 --> 00:33:27.120
We can actually connect all
the pieces together now.

00:33:27.120 --> 00:33:29.400
First, my device is
going to wake up.

00:33:29.400 --> 00:33:31.300
And the first component is,
it's going to talk to the

00:33:31.300 --> 00:33:31.870
radio tower.

00:33:31.870 --> 00:33:35.790
It's going to negotiate the
times when it can send data.

00:33:35.790 --> 00:33:38.430
That will take hundreds of
milliseconds, or up to two

00:33:38.430 --> 00:33:39.870
seconds on 3G networks.

00:33:39.870 --> 00:33:42.250
After that, it will transfer
data to the radio tower.

00:33:42.250 --> 00:33:44.830
The radio tower will transfer
it to the serving gateway,

00:33:44.830 --> 00:33:47.450
which will forward it to the
packing gateway, and only then

00:33:47.450 --> 00:33:49.400
will it hit the external
network.

00:33:49.400 --> 00:33:52.180
And this is when the data is
transferred to your server and

00:33:52.180 --> 00:33:53.210
all the rest.

00:33:53.210 --> 00:33:56.960
The latencies for this
end-to-end transferring here,

00:33:56.960 --> 00:33:59.820
without the external network,
is anywhere between 50

00:33:59.820 --> 00:34:01.670
milliseconds to hundreds
of milliseconds

00:34:01.670 --> 00:34:02.720
on different networks.

00:34:02.720 --> 00:34:06.460
I pulled out these numbers from
the AT&amp;T technical FAQ.

00:34:06.460 --> 00:34:11.130
So basically, the takeaway here
is 4G, 50 milliseconds,

00:34:11.130 --> 00:34:14.820
plus the transfer time to use
server, on 3G, as high as 400

00:34:14.820 --> 00:34:19.110
milliseconds and much, much
worse for 2G networks.

00:34:19.110 --> 00:34:22.070
It turns out, that's
a simple case.

00:34:22.070 --> 00:34:23.710
Let's try the more
complicated case.

00:34:23.710 --> 00:34:25.659
And I hope you guys
stay with me here.

00:34:25.659 --> 00:34:28.610
Let's say we actually want to
push a packet to the device.

00:34:28.610 --> 00:34:32.030
So we're trying to wake
up the device.

00:34:32.030 --> 00:34:35.350
Our server pushes a packet
to the mobile carrier.

00:34:35.350 --> 00:34:36.850
It hits the packet gateway.

00:34:36.850 --> 00:34:38.739
That goes to the serving
gateway.

00:34:38.739 --> 00:34:40.340
The server gateway,
once again, has no

00:34:40.340 --> 00:34:41.600
idea where you are.

00:34:41.600 --> 00:34:44.159
One of the nice properties of
mobile networks is, well, you

00:34:44.159 --> 00:34:44.810
guys are mobile.

00:34:44.810 --> 00:34:45.710
You hop into a car.

00:34:45.710 --> 00:34:47.760
Now you're on your way
out of San Francisco.

00:34:47.760 --> 00:34:49.310
We have no idea where you are.

00:34:49.310 --> 00:34:52.590
So the serving gateway actually
talks to the mobility

00:34:52.590 --> 00:34:55.780
management here, and it says,
OK, I need to send this packet

00:34:55.780 --> 00:34:56.980
to this user.

00:34:56.980 --> 00:34:59.440
Tell me where to forward
the packet to?

00:34:59.440 --> 00:35:02.500
The mobility interface doesn't
actually know your current

00:35:02.500 --> 00:35:04.070
physical location.

00:35:04.070 --> 00:35:06.730
It knows, kind of
geographically, where you are.

00:35:06.730 --> 00:35:10.300
OK, last time he checked in,
he was in San Francisco.

00:35:10.300 --> 00:35:12.360
So it sends a ping to
all of the radio

00:35:12.360 --> 00:35:13.580
towers in the vicinity.

00:35:13.580 --> 00:35:16.210
And says just flood the entire
network with a beacon that

00:35:16.210 --> 00:35:19.880
says, hey you, user number blah,
blah, blah, there's a

00:35:19.880 --> 00:35:21.370
packet waiting for you.

00:35:21.370 --> 00:35:23.810
Identify yourself, please.

00:35:23.810 --> 00:35:25.130
Your radio wakes up.

00:35:25.130 --> 00:35:26.070
It gets that packet.

00:35:26.070 --> 00:35:27.270
It then talks to the tower.

00:35:27.270 --> 00:35:28.990
It says, hey, I'm here.

00:35:28.990 --> 00:35:30.930
I'm associated with
you right now.

00:35:30.930 --> 00:35:32.540
That data gets transferred
back.

00:35:32.540 --> 00:35:35.020
It goes back to the serving
gateway, and now it can

00:35:35.020 --> 00:35:38.670
transfer the data back to the
tower and to your device.

00:35:38.670 --> 00:35:40.380
This is pretty complicated.

00:35:40.380 --> 00:35:44.030
And the reason I'm pointing
this out is, oftentimes,

00:35:44.030 --> 00:35:46.240
there's a question of
why does it take 200

00:35:46.240 --> 00:35:47.370
milliseconds to do this?

00:35:47.370 --> 00:35:49.120
I mean, but clearly,
this is a pretty

00:35:49.120 --> 00:35:51.030
complicated problem to solve.

00:35:51.030 --> 00:35:54.020
So the fact that we can do this
in 40 to 50 milliseconds

00:35:54.020 --> 00:36:00.200
in 4G is actually or rather
impressive, to be honest.

00:36:00.200 --> 00:36:03.320
So this is a little crazy.

00:36:03.320 --> 00:36:05.190
But is it worth it?

00:36:05.190 --> 00:36:06.750
I think that's a valid
question to ask.

00:36:06.750 --> 00:36:08.860
We went from Wi-Fi, where
we had nothing.

00:36:08.860 --> 00:36:11.870
We just said, just talk
and hope for the best.

00:36:11.870 --> 00:36:13.010
Cross our fingers.

00:36:13.010 --> 00:36:16.320
We went to this 4G network
interface, where now we have

00:36:16.320 --> 00:36:20.520
all these routers, radio towers
talking to each other,

00:36:20.520 --> 00:36:23.580
it's all crazy.

00:36:23.580 --> 00:36:24.720
Where are we going?

00:36:24.720 --> 00:36:28.020
So this is a great case study
that was done a couple years

00:36:28.020 --> 00:36:34.120
back, actually, in 2011, where
they measured performance of

00:36:34.120 --> 00:36:37.730
Wi-Fi networks, typical
home router networks.

00:36:37.730 --> 00:36:40.600
I think this was done with
802.11G, so a fairly new

00:36:40.600 --> 00:36:43.350
standard, and they compared
it against LTE.

00:36:43.350 --> 00:36:47.390
So just focus on these
two clusters here.

00:36:47.390 --> 00:36:49.480
And what I want to point out
is, first of all, the

00:36:49.480 --> 00:36:51.340
throughput is actually better.

00:36:51.340 --> 00:36:55.110
But most importantly is this
graph right here, which is the

00:36:55.110 --> 00:36:58.150
round trip time for
our packets.

00:36:58.150 --> 00:37:02.540
With Wi-Fi, there's no
guarantees about the latency

00:37:02.540 --> 00:37:04.010
of the delivery of
your packets.

00:37:04.010 --> 00:37:07.680
And that's why you have these
giant tails here.

00:37:07.680 --> 00:37:10.060
Generally speaking, the latency
is fairly low, but

00:37:10.060 --> 00:37:11.590
then you have these outliers,
which is why

00:37:11.590 --> 00:37:13.070
this line is stretched.

00:37:13.070 --> 00:37:16.750
With LTE, even though it's
so much more seemingly

00:37:16.750 --> 00:37:18.760
complicated, or not just
seemingly, it is more

00:37:18.760 --> 00:37:23.690
complicated, we can actually
deliver more reliable latency

00:37:23.690 --> 00:37:25.940
and lower jitter across
the network.

00:37:25.940 --> 00:37:27.140
So this is good.

00:37:27.140 --> 00:37:29.800
This is great.

00:37:29.800 --> 00:37:32.300
4G will make things better.

00:37:38.370 --> 00:37:40.400
So a couple of things.

00:37:40.400 --> 00:37:44.980
Mobile radio is optimized for
burst data transfers.

00:37:44.980 --> 00:37:50.180
It is not optimized for sending
bits in small chunks.

00:37:50.180 --> 00:37:52.240
What you want to do is, you want
to transfer as much data

00:37:52.240 --> 00:37:55.250
as possible and then
turn off the radio.

00:37:55.250 --> 00:37:58.640
And in fact, the latest 4G
networks can transfer on the

00:37:58.640 --> 00:38:03.110
order of 10 of megabits per
second, which is really high

00:38:03.110 --> 00:38:03.910
data rates.

00:38:03.910 --> 00:38:06.960
But it will do so in very
small assignments.

00:38:06.960 --> 00:38:09.960
In fact, the bandwidth
assignments are done in

00:38:09.960 --> 00:38:12.360
millisecond and lower chunks.

00:38:12.360 --> 00:38:16.563
So you get a chunk of airspace
for about one millisecond, and

00:38:16.563 --> 00:38:18.690
you can transfer huge
amounts of data.

00:38:18.690 --> 00:38:20.620
So pack as much data
as you can.

00:38:20.620 --> 00:38:21.900
Group your requests.

00:38:21.900 --> 00:38:23.150
Don't delay your requests.

00:38:26.220 --> 00:38:31.110
The not so good news part of the
4G world is that 4G will

00:38:31.110 --> 00:38:32.760
take a while to come.

00:38:32.760 --> 00:38:36.840
Despite the fact that there is
ads everywhere, across all the

00:38:36.840 --> 00:38:40.850
highways and everywhere else
that 4G will save all things,

00:38:40.850 --> 00:38:43.060
4G will take a while
to deploy.

00:38:43.060 --> 00:38:44.810
Current carriers have
deployed a lot of

00:38:44.810 --> 00:38:46.500
infrastructure for 3G.

00:38:46.500 --> 00:38:49.550
And they're continuing to
improve that, in part because

00:38:49.550 --> 00:38:51.770
they can, and in part because
it's very expensive.

00:38:51.770 --> 00:38:56.840
So the dominant network type
of this decade, not just of

00:38:56.840 --> 00:39:00.100
this year, or in the coming
year, of this decade, will be

00:39:00.100 --> 00:39:00.910
3G networks.

00:39:00.910 --> 00:39:03.810
And granted, they are being
enhanced to deliver higher

00:39:03.810 --> 00:39:04.590
data rates.

00:39:04.590 --> 00:39:07.570
But nonetheless, you can see
that the growth, overall

00:39:07.570 --> 00:39:10.750
growth projections, are
for 3G networks.

00:39:10.750 --> 00:39:14.500
The good news is, at least
within North America, LTE and

00:39:14.500 --> 00:39:16.810
HSPA, which are the 4G networks,
are actually taking

00:39:16.810 --> 00:39:18.170
off quite well.

00:39:18.170 --> 00:39:22.240
In fact, we are way ahead of the
curve compared to all the

00:39:22.240 --> 00:39:23.050
other countries.

00:39:23.050 --> 00:39:26.800
But nonetheless, you have to
basically assume that your

00:39:26.800 --> 00:39:30.400
users will be using a mix
of 3G and 4G networks.

00:39:30.400 --> 00:39:33.970
And even if you have a 4G
network data plan on your

00:39:33.970 --> 00:39:36.920
phone, your phone is switching
between 4G

00:39:36.920 --> 00:39:39.430
and 3G all the time.

00:39:39.430 --> 00:39:43.040
Depending on coverage, or where
you currently are, and

00:39:43.040 --> 00:39:44.660
load within the network.

00:39:44.660 --> 00:39:48.540
So because of that, you have to
design for variable network

00:39:48.540 --> 00:39:50.630
performance and availability.

00:39:50.630 --> 00:39:52.810
It is truly a multi-generation
future.

00:39:52.810 --> 00:39:55.790
You can't assume that you'll get
great performance with 4G.

00:39:55.790 --> 00:39:58.870
You need to plan for 3G
networks as well.

00:39:58.870 --> 00:40:00.980
Bandwidth and latency
are variable.

00:40:00.980 --> 00:40:04.530
And of course, as we've all
experienced, connectivity is

00:40:04.530 --> 00:40:05.120
intermittent.

00:40:05.120 --> 00:40:08.520
So if you're building a mobile
application, or an application

00:40:08.520 --> 00:40:12.320
for the mobile web, you have to
assume that there should be

00:40:12.320 --> 00:40:17.920
an offline mode or some fallback
to say what happens

00:40:17.920 --> 00:40:20.780
when I can't actually connect.

00:40:20.780 --> 00:40:23.370
And I mentioned this before,
but I think this is an

00:40:23.370 --> 00:40:26.940
important point to
make once again.

00:40:26.940 --> 00:40:29.860
You should have some sort
of a backup strategy.

00:40:29.860 --> 00:40:35.630
Oftentimes, the reason we have
poor battery performance is

00:40:35.630 --> 00:40:41.510
because some application does
not plan for intermittent

00:40:41.510 --> 00:40:44.390
connectivity, or the fact that
there is no connectivity, and

00:40:44.390 --> 00:40:46.640
it just continues to pull
the server to say,

00:40:46.640 --> 00:40:47.490
are you there yet?

00:40:47.490 --> 00:40:48.220
Are you there yet?

00:40:48.220 --> 00:40:49.260
Are you there yet?

00:40:49.260 --> 00:40:55.160
And that's what's burning your
leg and burning the battery on

00:40:55.160 --> 00:40:55.750
your device.

00:40:55.750 --> 00:40:58.930
What you want to do instead is
to say, I'm going to try to

00:40:58.930 --> 00:40:59.950
connect now.

00:40:59.950 --> 00:41:04.820
And then every time I fail, I
will just punt further out

00:41:04.820 --> 00:41:07.210
into the future, have some sort
of a decay function, and

00:41:07.210 --> 00:41:09.215
then say I'm going to stop
after this interval, and

00:41:09.215 --> 00:41:10.820
you'll retry later.

00:41:10.820 --> 00:41:14.290
Nine cases out of 10, whenever
I have a performance or a

00:41:14.290 --> 00:41:16.690
battery life problem, I track
it down to exactly this.

00:41:16.690 --> 00:41:17.860
It's some application
that's just

00:41:17.860 --> 00:41:19.820
sitting there, in a loop--

00:41:19.820 --> 00:41:23.600
while not connected,
keep trying.

00:41:23.600 --> 00:41:24.850
Not a good strategy.

00:41:27.100 --> 00:41:31.210
So with that, I think we've gone
through the full cycle.

00:41:31.210 --> 00:41:34.120
And we're back to application
best practices.

00:41:34.120 --> 00:41:36.810
Of course, all the radio stuff
is very important.

00:41:36.810 --> 00:41:41.330
But optimizing TCP best
practices, TLS, and HTTP is

00:41:41.330 --> 00:41:42.560
very important.

00:41:42.560 --> 00:41:45.010
The takeaways here is, of
course, measure first.

00:41:45.010 --> 00:41:47.770
Make sure you're using real user
measurement, and you're

00:41:47.770 --> 00:41:49.810
measuring performance across
real networks.

00:41:49.810 --> 00:41:53.180
Do that first, and then
optimize later.

00:41:53.180 --> 00:41:55.610
And I'll just call out a couple
of examples that I

00:41:55.610 --> 00:41:56.990
think are very important.

00:41:56.990 --> 00:42:00.170
The fastest request is
a request not made.

00:42:00.170 --> 00:42:01.820
This is an obvious one.

00:42:01.820 --> 00:42:04.290
But it turns out, when we
analyze a lot of mobile

00:42:04.290 --> 00:42:06.730
applications, they're
not caching data.

00:42:06.730 --> 00:42:09.700
This is the number one problem
for a lot of applications.

00:42:09.700 --> 00:42:11.340
So make sure you do that.

00:42:11.340 --> 00:42:14.920
Bytes are literally expensive
for a lot of users.

00:42:14.920 --> 00:42:16.490
You need to compress
resources.

00:42:16.490 --> 00:42:19.000
And you know, it's funny because
we've been talking

00:42:19.000 --> 00:42:21.520
about compressing resources,
compressing images, for years.

00:42:21.520 --> 00:42:24.260
But we still find that a lot of
applications don't do it.

00:42:24.260 --> 00:42:27.070
And of course, leveraging
formats like WebP, as you guys

00:42:27.070 --> 00:42:28.920
heard at the keynote,
and we had a session

00:42:28.920 --> 00:42:31.020
earlier today on WebP--

00:42:31.020 --> 00:42:36.700
definitely encourage you to try
it both on web and native.

00:42:36.700 --> 00:42:40.660
And then, finally, shameless
self promotion.

00:42:40.660 --> 00:42:43.620
I've been writing a book on this
stuff, and, specifically,

00:42:43.620 --> 00:42:45.700
on mobile radio performance
and other things.

00:42:45.700 --> 00:42:47.210
And it's available
online for free.

00:42:47.210 --> 00:42:49.980
So if you guys are curious to
learn more about this, and I

00:42:49.980 --> 00:42:53.240
can talk about it all day,
please check it out and please

00:42:53.240 --> 00:42:53.850
offer feedback.

00:42:53.850 --> 00:42:56.920
You can actually comment
right on it.

00:42:56.920 --> 00:42:59.970
And with that, I think we have
some time for questions.

00:42:59.970 --> 00:43:02.240
If you can grab one of the
mics, and I'd be happy to

00:43:02.240 --> 00:43:03.660
answer them.

00:43:03.660 --> 00:43:22.280
[APPLAUSE]

00:43:22.280 --> 00:43:22.770
AUDIENCE: Hi.

00:43:22.770 --> 00:43:23.790
My name is Maurice.

00:43:23.790 --> 00:43:25.310
I work for Verizon Wireless.

00:43:25.310 --> 00:43:32.160
I have a question regarding APIs
or services that can be

00:43:32.160 --> 00:43:35.270
provided by the Android
framework itself to allow

00:43:35.270 --> 00:43:38.270
developers to make application
more efficient.

00:43:38.270 --> 00:43:42.510
For example, the same way today
doesn't allow you to put

00:43:42.510 --> 00:43:46.310
network access in your main
thread, is there anything

00:43:46.310 --> 00:43:50.250
planned to do in that matter?

00:43:50.250 --> 00:43:55.110
ILYA GRIGORIK: So I have more
experience with the web part

00:43:55.110 --> 00:43:55.570
of the stack.

00:43:55.570 --> 00:43:58.040
So I can't necessarily comment
on the Android part.

00:43:58.040 --> 00:44:01.400
I would actually direct you to
the Android guys sitting

00:44:01.400 --> 00:44:02.750
outside for that.

00:44:02.750 --> 00:44:09.140
But something like GCM, we
continue enhance GCM, or the

00:44:09.140 --> 00:44:11.240
Google Cloud Messaging, and
that's what you want to use

00:44:11.240 --> 00:44:12.010
for a lot of communication.

00:44:12.010 --> 00:44:14.840
We just recently announced the
ability to actually send data

00:44:14.840 --> 00:44:16.420
through GCM as well.

00:44:16.420 --> 00:44:18.830
AUDIENCE: Thank you.

00:44:18.830 --> 00:44:23.860
AUDIENCE: So my understanding
of why LTE is much better is

00:44:23.860 --> 00:44:28.560
partially because of the
modulation that it uses.

00:44:28.560 --> 00:44:32.500
Since LTE uses LFDM, and Wi-Fi
uses something different.

00:44:32.500 --> 00:44:36.810
Do you know if there's any
industry trends to move the

00:44:36.810 --> 00:44:40.300
modulation scheme of the access
points that you might

00:44:40.300 --> 00:44:44.890
have at home, to use that
technology over what we have

00:44:44.890 --> 00:44:47.370
today, since it's so jittery?

00:44:47.370 --> 00:44:49.410
ILYA GRIGORIK: So there's a
couple questions in there.

00:44:49.410 --> 00:44:52.280
So LTE has a host of different
improvements.

00:44:52.280 --> 00:44:53.890
So they're basically redesigning
the network from

00:44:53.890 --> 00:44:54.790
the ground up.

00:44:54.790 --> 00:44:56.960
They're moving the scheduling
stuff into the

00:44:56.960 --> 00:44:58.020
edges of the network.

00:44:58.020 --> 00:45:01.130
They're using a new modulation
scheme, as you described.

00:45:01.130 --> 00:45:03.440
So it's not just a modulation.

00:45:03.440 --> 00:45:05.790
Because that helps you
with throughput.

00:45:05.790 --> 00:45:08.210
But there's a number of other
variables, like the energy

00:45:08.210 --> 00:45:10.650
use, the latency of assumption,
the connection,

00:45:10.650 --> 00:45:11.880
all the rest.

00:45:11.880 --> 00:45:15.540
For moving that same technology
into, let's say,

00:45:15.540 --> 00:45:17.600
your local access points,
yes to some degree.

00:45:17.600 --> 00:45:21.820
So Wi-Fi standards and LTE,
or 3GPP, standards

00:45:21.820 --> 00:45:23.230
are completely separate.

00:45:23.230 --> 00:45:26.800
But just watching both of them,
they do borrow and steal

00:45:26.800 --> 00:45:28.240
from each other.

00:45:28.240 --> 00:45:31.640
So with the latest Wi-Fi
standards, you'll find that

00:45:31.640 --> 00:45:34.790
the way they're achieving
gigabit data rates is by using

00:45:34.790 --> 00:45:37.030
the same tricks, to
a large degree.

00:45:37.030 --> 00:45:39.700
AUDIENCE: So do you know
if that's in 802 AC?

00:45:39.700 --> 00:45:41.630
ILYA GRIGORIK: Yeah, that's
in part how they're--

00:45:41.630 --> 00:45:42.960
yeah, exactly.

00:45:42.960 --> 00:45:44.460
AUDIENCE: Thank you.

00:45:44.460 --> 00:45:47.020
AUDIENCE: I'm fairly new
to Android development.

00:45:47.020 --> 00:45:49.630
And this may have been covered
in the messaging, cloud

00:45:49.630 --> 00:45:50.920
messaging feature.

00:45:50.920 --> 00:45:55.270
I was just wondering, is there
any currently, or plans to

00:45:55.270 --> 00:45:59.710
provide support for aggregating
requests from the

00:45:59.710 --> 00:46:03.470
OS level or framework to, if
you've got multiple apps

00:46:03.470 --> 00:46:06.440
running that all have a stupid
beacon request, is there any

00:46:06.440 --> 00:46:10.510
support for ganging these
together, so multiple apps

00:46:10.510 --> 00:46:12.550
kind of work with each other
instead of against each other

00:46:12.550 --> 00:46:14.860
to reduce radio usage?

00:46:14.860 --> 00:46:15.770
ILYA GRIGORIK: Yeah, so I
think that's definitely

00:46:15.770 --> 00:46:17.130
something that we're
looking at.

00:46:17.130 --> 00:46:19.600
And that's something that only
the platform can provide.

00:46:19.600 --> 00:46:22.210
As an application designer,
you can't control what the

00:46:22.210 --> 00:46:23.750
other applications are doing.

00:46:23.750 --> 00:46:25.830
So this is definitely something
that we're thinking

00:46:25.830 --> 00:46:29.990
about, both on the web, like
on Chrome, for example, how

00:46:29.990 --> 00:46:32.350
can Chrome leverage something
like this, and also within the

00:46:32.350 --> 00:46:33.630
Android platform.

00:46:33.630 --> 00:46:37.980
So a good example of this is
turning off the radio early.

00:46:37.980 --> 00:46:40.920
If we know that there's no other
connections being made,

00:46:40.920 --> 00:46:43.080
we can terminate the
connections early.

00:46:43.080 --> 00:46:45.190
That can be done by the
operating system in

00:46:45.190 --> 00:46:47.840
conjunction with the Radio
Resource Controller.

00:46:47.840 --> 00:46:49.830
So yes, there's definitely
work in that direction.

00:46:49.830 --> 00:46:51.560
AUDIENCE: So that's
nothing current,

00:46:51.560 --> 00:46:52.880
but it's in the works?

00:46:52.880 --> 00:46:55.042
ILYA GRIGORIK: Yeah, yeah.

00:46:55.042 --> 00:46:58.040
AUDIENCE: Do you have
recommendations for tools just

00:46:58.040 --> 00:47:01.235
as a user, to help figure out
what's killing your battery on

00:47:01.235 --> 00:47:03.100
iOS and Android?

00:47:03.100 --> 00:47:04.750
ILYA GRIGORIK: Yeah, so
I hope we make that

00:47:04.750 --> 00:47:05.790
tooling much better.

00:47:05.790 --> 00:47:09.550
I guess a couple of tips that
I use, one is, you actually

00:47:09.550 --> 00:47:11.460
have the battery panel
within Android.

00:47:11.460 --> 00:47:14.870
If you go into your settings and
kind of navigate down, it

00:47:14.870 --> 00:47:16.810
actually gives you a really
good breakdown of which

00:47:16.810 --> 00:47:18.400
applications consume power.

00:47:18.400 --> 00:47:20.730
And if you click on the graph,
it will also show you kind of

00:47:20.730 --> 00:47:23.610
a breakdown of when the power
is being consumed.

00:47:23.610 --> 00:47:26.500
So I've found that that's the
most effective way to identify

00:47:26.500 --> 00:47:28.720
specific applications.

00:47:28.720 --> 00:47:31.010
I think we need to do more
to isolate, like,

00:47:31.010 --> 00:47:31.970
at a webpage level.

00:47:31.970 --> 00:47:33.300
There's nothing really
like that.

00:47:33.300 --> 00:47:35.680
And I think we need something
like that.

00:47:35.680 --> 00:47:38.971
So I hope we'll have a better
answer in a year's time.

00:47:38.971 --> 00:47:41.180
AUDIENCE: Thanks.

00:47:41.180 --> 00:47:44.740
AUDIENCE: Hi, could you talk a
little bit about strategies

00:47:44.740 --> 00:47:46.680
that you would use for games?

00:47:46.680 --> 00:47:50.310
Because they have a completely
different data access pattern.

00:47:50.310 --> 00:47:53.580
And they typically talk
UDP instead of TCP.

00:47:53.580 --> 00:47:56.600
And they require lower latency
in case you're playing with

00:47:56.600 --> 00:47:57.590
someone else.

00:47:57.590 --> 00:47:59.940
ILYA GRIGORIK: So all of the
same optimization strategies

00:47:59.940 --> 00:48:01.150
would apply there.

00:48:01.150 --> 00:48:03.250
It doesn't matter if it's
TCP or UDP, you need

00:48:03.250 --> 00:48:04.640
to wake up the radio.

00:48:04.640 --> 00:48:07.450
So to the extent possible, you
want to aggregate data.

00:48:07.450 --> 00:48:11.170
You don't want to be beaconing
back every single achievement

00:48:11.170 --> 00:48:14.660
unlocked by the user if that
can be kept on the device.

00:48:14.660 --> 00:48:18.940
So once again, leveraging things
like GCM and others to

00:48:18.940 --> 00:48:21.660
aggregate that data,
it's all the same.

00:48:21.660 --> 00:48:24.570
The protocol doesn't
actually matter.

00:48:24.570 --> 00:48:26.600
AUDIENCE: Thanks.

00:48:26.600 --> 00:48:28.950
AUDIENCE: As a JavaScript
developer, the best practices,

00:48:28.950 --> 00:48:32.890
as you said, is to batch API
requests or other requests.

00:48:32.890 --> 00:48:35.650
Could you comment on the beacon
API, which would help

00:48:35.650 --> 00:48:39.960
us tap into actually when
the radio is active.

00:48:39.960 --> 00:48:41.140
ILYA GRIGORIK: The beacon API.

00:48:41.140 --> 00:48:45.110
So are you talking about
the new proposal?

00:48:45.110 --> 00:48:46.315
AUDIENCE: Yeah, and then what
the status of that is.

00:48:46.315 --> 00:48:48.780
ILYA GRIGORIK: Yeah, OK, so in
the HP performance working

00:48:48.780 --> 00:48:51.050
group, we're working on a couple
of proposals, I guess.

00:48:51.050 --> 00:48:55.020
One is the beacon API, which is
to say, I want you to send

00:48:55.020 --> 00:48:57.670
this request, but I don't
actually care

00:48:57.670 --> 00:48:58.570
when you send it.

00:48:58.570 --> 00:49:00.340
Just send it when it's
convenient for you.

00:49:00.340 --> 00:49:02.370
A good example of that
is analytics beacons.

00:49:02.370 --> 00:49:04.420
You don't want to wake up
the radio right now.

00:49:04.420 --> 00:49:07.280
You're just saying, defer
this and dispatch it

00:49:07.280 --> 00:49:08.660
at some later time.

00:49:08.660 --> 00:49:11.180
So there's no implementation
of that yet.

00:49:11.180 --> 00:49:14.220
I think we have early
drafts of the spec.

00:49:14.220 --> 00:49:16.020
If you guys are interested, I
would definitely encourage you

00:49:16.020 --> 00:49:18.670
to check out the working group
and comment on it.

00:49:18.670 --> 00:49:21.146
But hopefully, soon, we'll
have something.

00:49:21.146 --> 00:49:23.330
AUDIENCE: OK, thanks.

00:49:23.330 --> 00:49:26.840
AUDIENCE: Can you talk about
what tools you used to look at

00:49:26.840 --> 00:49:29.800
your Wi-Fi networks
in those slides?

00:49:29.800 --> 00:49:32.120
ILYA GRIGORIK: What is the
tool that I used in--

00:49:32.120 --> 00:49:34.300
you know, I don't remember off
the top of my head, but if you

00:49:34.300 --> 00:49:38.500
talk to me afterwards, I can
find it on my laptop.

00:49:38.500 --> 00:49:40.470
AUDIENCE: A question
about analytics.

00:49:40.470 --> 00:49:40.680
ILYA GRIGORIK: Yes.

00:49:40.680 --> 00:49:43.295
AUDIENCE: So what solutions are
you currently working on

00:49:43.295 --> 00:49:47.780
at Google not to lose the data
value, and to reduce the

00:49:47.780 --> 00:49:49.560
battery consumption.

00:49:49.560 --> 00:49:53.420
ILYA GRIGORIK: So for analytics,
what you generally

00:49:53.420 --> 00:49:55.170
want to do-- so this is actually
related to the

00:49:55.170 --> 00:49:56.950
previous question about
the beacon API.

00:49:56.950 --> 00:50:00.260
So oftentimes, you can report
the data later.

00:50:00.260 --> 00:50:03.150
So one strategy is to literally
stash the data into

00:50:03.150 --> 00:50:05.310
your local database and
then report it when

00:50:05.310 --> 00:50:06.350
the radio is active.

00:50:06.350 --> 00:50:08.240
This requires some modifications
of your

00:50:08.240 --> 00:50:10.160
application itself.

00:50:10.160 --> 00:50:14.020
But for example, on the real
time analytics, we don't

00:50:14.020 --> 00:50:19.550
actually ping back every
so often to just

00:50:19.550 --> 00:50:21.240
say that you're there.

00:50:21.240 --> 00:50:25.050
We do the real time analytics
differently, which is to say,

00:50:25.050 --> 00:50:27.780
we track when you first visit
the page, which is when you

00:50:27.780 --> 00:50:31.980
hit that beacon, and then we say
that you're active on the

00:50:31.980 --> 00:50:35.560
page for the next 30 seconds.

00:50:35.560 --> 00:50:37.820
And if you navigate to
another page, then

00:50:37.820 --> 00:50:38.910
you're still active.

00:50:38.910 --> 00:50:41.850
So we're not forcing this
five second interval.

00:50:41.850 --> 00:50:45.490
And I think we need to talk to
the other vendors and get them

00:50:45.490 --> 00:50:48.040
to move in the same direction
because they're literally

00:50:48.040 --> 00:50:50.600
costing a lot in terms
of performance.

00:50:50.600 --> 00:50:51.740
AUDIENCE: And about
Google Analytics,

00:50:51.740 --> 00:50:53.420
and additional question.

00:50:53.420 --> 00:50:58.260
Will it be a separate API
extended for request bulking?

00:50:58.260 --> 00:50:59.960
ILYA GRIGORIK: Can you say
that again, sorry.

00:50:59.960 --> 00:51:03.230
AUDIENCE: So for example, we
have a start in activity.

00:51:03.230 --> 00:51:06.280
And we are reporting the user
when there is a start of

00:51:06.280 --> 00:51:07.860
activity, and when he left it.

00:51:07.860 --> 00:51:10.910
And there's a chain of them.

00:51:10.910 --> 00:51:14.790
And will be the API of Google
Analytics extended, so we can

00:51:14.790 --> 00:51:19.090
bufferize this, like put, and
put to buffer, and to report

00:51:19.090 --> 00:51:20.530
later, or something like this.

00:51:20.530 --> 00:51:21.330
ILYA GRIGORIK: That's
a great idea.

00:51:21.330 --> 00:51:22.780
So there's three ways
to tackle that.

00:51:22.780 --> 00:51:26.040
Google Analytics can provide
a new API to basically say,

00:51:26.040 --> 00:51:28.310
stash this and send it later.

00:51:28.310 --> 00:51:30.270
You can implement your own
wrapper around it, and

00:51:30.270 --> 00:51:32.980
basically say, I'm going to
fire this later, when I

00:51:32.980 --> 00:51:34.840
consider that it's active.

00:51:34.840 --> 00:51:37.030
And then the best approach, I
think, is a combination of the

00:51:37.030 --> 00:51:41.010
two, which is the beacon API,
which we were just talking

00:51:41.010 --> 00:51:45.170
about, which is basically a
browser mechanism, to say

00:51:45.170 --> 00:51:47.270
we'll defer this to the browser
to determine because

00:51:47.270 --> 00:51:48.970
it's actually in the
best position.

00:51:48.970 --> 00:51:51.410
So today the fastest way to get
what you're talking about

00:51:51.410 --> 00:51:53.560
is to implement it in
your application.

00:51:53.560 --> 00:51:55.750
I can certainly talk to the
Google Analytics Team and see

00:51:55.750 --> 00:51:57.500
if there is interest
in implementing

00:51:57.500 --> 00:51:58.230
something like this.

00:51:58.230 --> 00:52:00.500
I think that's a great idea.

00:52:00.500 --> 00:52:02.570
And then, maybe in a year's
time, we'll have something

00:52:02.570 --> 00:52:04.310
like the Beacon API.

00:52:04.310 --> 00:52:04.950
AUDIENCE: Thank you.

00:52:04.950 --> 00:52:06.315
ILYA GRIGORIK: Yeah.

00:52:06.315 --> 00:52:06.770
SPEAKER 1: We're
way over time.

00:52:06.770 --> 00:52:08.140
[INAUDIBLE]

00:52:08.140 --> 00:52:10.410
ILYA GRIGORIK: All
right, one more.

00:52:10.410 --> 00:52:14.540
AUDIENCE: My question is
related to the Nexus 4.

00:52:14.540 --> 00:52:17.230
I've always used Verizon, and
I've never had any signal

00:52:17.230 --> 00:52:20.880
reception issues until I
switched to T-Mobile.

00:52:20.880 --> 00:52:26.640
At my house, on the first
floor, I only get edge.

00:52:26.640 --> 00:52:30.990
On the second floor, I get
edge, but it's iffy.

00:52:30.990 --> 00:52:34.820
On the third floor, I'll
get edge and HSPA+.

00:52:34.820 --> 00:52:36.880
Now this is the thing, though.

00:52:36.880 --> 00:52:39.830
With this phone, the decibel
rating, from what I'm reading,

00:52:39.830 --> 00:52:41.100
is like around 100.

00:52:41.100 --> 00:52:44.350
If I hold the phone in my
hand, I lose signal.

00:52:44.350 --> 00:52:47.188
ILYA GRIGORIK: You're
holding it wrong.

00:52:47.188 --> 00:52:48.620
AUDIENCE: But this
is the thing.

00:52:48.620 --> 00:52:51.520
If I'm on a phone call, and
then I hold it, it doesn't

00:52:51.520 --> 00:52:52.660
drop signal.

00:52:52.660 --> 00:52:56.400
So my question is, is there a
way that I, as an end user,

00:52:56.400 --> 00:53:00.920
can make the phone put more
power to the radio to hold the

00:53:00.920 --> 00:53:03.832
signal because I can't
change T-Mobile.

00:53:03.832 --> 00:53:04.980
ILYA GRIGORIK: So the
short answer is no.

00:53:04.980 --> 00:53:09.060
The energy use is actually
dictated by the radio tower.

00:53:09.060 --> 00:53:11.320
It actually tells you, depending
on where you are,

00:53:11.320 --> 00:53:14.310
the distance between you and the
radio tower, the amount of

00:53:14.310 --> 00:53:17.220
other people talking, the exact
signal power that you

00:53:17.220 --> 00:53:18.210
should be transmitting.

00:53:18.210 --> 00:53:20.290
So in fact, the radio tower is
actually trying to help you

00:53:20.290 --> 00:53:23.370
optimize your battery use, which
sounds like, in this

00:53:23.370 --> 00:53:25.820
case, it may be working
against you.

00:53:25.820 --> 00:53:27.660
But there's no explicit
control of that,

00:53:27.660 --> 00:53:29.415
unfortunately.

00:53:29.415 --> 00:53:31.020
AUDIENCE: OK.

00:53:31.020 --> 00:53:32.270
ILYA GRIGORIK: Great,
thanks guys.

