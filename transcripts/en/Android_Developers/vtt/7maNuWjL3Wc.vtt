WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.890
[MUSIC PLAYING]

00:00:04.890 --> 00:00:07.610
Welcome to my talk, which
apparently my naming joke

00:00:07.610 --> 00:00:10.445
was also simultaneously thought
of by Lawrence Moroney, if you

00:00:10.445 --> 00:00:11.770
went to his talk two hours ago.

00:00:11.770 --> 00:00:14.080
But it's a clever one.

00:00:14.080 --> 00:00:16.760
The goal today is to
walk through everything

00:00:16.760 --> 00:00:19.600
you need to understand in
order to be able to understand

00:00:19.600 --> 00:00:20.770
how JobScheduler works.

00:00:20.770 --> 00:00:22.947
Because if you can
know how to choose

00:00:22.947 --> 00:00:25.280
between different options of
building a background task,

00:00:25.280 --> 00:00:27.710
we'll just build a better app,
which will be really great.

00:00:27.710 --> 00:00:29.520
JobScheduler is really
scary, and nobody ever

00:00:29.520 --> 00:00:31.190
wants to talk about it,
because if you bring it up

00:00:31.190 --> 00:00:32.390
and somebody starts
talking to you,

00:00:32.390 --> 00:00:34.810
you probably won't understand
what they're talking about.

00:00:34.810 --> 00:00:35.710
And that's hard.

00:00:35.710 --> 00:00:37.470
So we're going to go through all
of it, and by the end of this

00:00:37.470 --> 00:00:40.136
you're going to walk out of here
ready to name drop JobScheduler

00:00:40.136 --> 00:00:43.170
and just really rampant
and advocate for it.

00:00:43.170 --> 00:00:44.614
So it will be great.

00:00:44.614 --> 00:00:45.780
Why you should listen to me?

00:00:45.780 --> 00:00:49.510
I am Joanna Smith, this is a
copy of my bio off the website.

00:00:49.510 --> 00:00:50.911
You can read that, or not.

00:00:50.911 --> 00:00:52.910
Specifically the things
I've done with Android--

00:00:52.910 --> 00:00:55.630
I co-founded the Android
Development Patterns

00:00:55.630 --> 00:00:56.430
Initiative.

00:00:56.430 --> 00:00:58.352
We have a lot of
videos, me and Ian Lake.

00:00:58.352 --> 00:00:59.060
He's right there.

00:00:59.060 --> 00:01:00.680
You probably just
watched his talk.

00:01:00.680 --> 00:01:02.760
We made the videos and we
have a weekly pro-tip series

00:01:02.760 --> 00:01:04.430
of written content and
we have a lot more ideas

00:01:04.430 --> 00:01:05.760
coming over the next year.

00:01:05.760 --> 00:01:10.740
We're trying to identify--
bust bad behavior

00:01:10.740 --> 00:01:12.064
and teach best practices.

00:01:12.064 --> 00:01:13.480
Because we have a
lot of developer

00:01:13.480 --> 00:01:16.190
outreach on how Android
works, and how APIs work,

00:01:16.190 --> 00:01:17.840
and really how
you can implement.

00:01:17.840 --> 00:01:20.860
But we don't have anyone
telling you when to implement

00:01:20.860 --> 00:01:23.410
or what to choose, or
what the options are.

00:01:23.410 --> 00:01:26.000
Or if you have 13
different paths which one's

00:01:26.000 --> 00:01:27.370
going to be best for your app.

00:01:27.370 --> 00:01:29.155
So we're trying to
tackle that problem.

00:01:29.155 --> 00:01:31.280
Watch our videos, let us
know how well we're doing.

00:01:31.280 --> 00:01:35.920
And then also, we created the
second course in our Udacity

00:01:35.920 --> 00:01:37.270
Android Nanodegree.

00:01:37.270 --> 00:01:39.120
So if you're trying
to expand your skills

00:01:39.120 --> 00:01:40.720
or just brush up on something
you haven't seen before,

00:01:40.720 --> 00:01:42.100
that's a really great resource.

00:01:42.100 --> 00:01:43.940
All those course materials
are available online for free.

00:01:43.940 --> 00:01:45.810
But if you enroll in the
class and pay the fee,

00:01:45.810 --> 00:01:47.184
you also get
instructor guidance.

00:01:47.184 --> 00:01:48.364
That's pretty cool.

00:01:48.364 --> 00:01:51.030
And then this is just like a fun
fact I like to throw out there,

00:01:51.030 --> 00:01:54.250
I started learning Android,
actually in February of 2014.

00:01:54.250 --> 00:01:56.900
So I'm very new to this game
compared to a lot of people.

00:01:56.900 --> 00:01:59.852
I like to bring that up because
it can seem really intimidating

00:01:59.852 --> 00:02:01.310
when you're learning
something new,

00:02:01.310 --> 00:02:02.300
and you're trying
to get into it,

00:02:02.300 --> 00:02:03.443
and everyone's talking
about all these words

00:02:03.443 --> 00:02:04.526
that you don't understand.

00:02:04.526 --> 00:02:06.943
And they're reminiscing about
how Gingerbread was so ugly.

00:02:06.943 --> 00:02:09.525
And you're like, I don't think
I ever had a Gingerbread phone.

00:02:09.525 --> 00:02:11.830
I don't know how to participate
in this conversation.

00:02:11.830 --> 00:02:14.361
And it's intimidating, and
this is a hard, hard problem

00:02:14.361 --> 00:02:14.860
to solve.

00:02:14.860 --> 00:02:17.450
I just want everyone to know,
you don't-- I mean I did this

00:02:17.450 --> 00:02:19.220
lesson two years ago, and
I'm giving a talk to you guys

00:02:19.220 --> 00:02:20.250
as if I'm an expert.

00:02:20.250 --> 00:02:21.890
You can really learn
a lot, really fast

00:02:21.890 --> 00:02:24.750
if you just push
yourself and try.

00:02:24.750 --> 00:02:28.020
So that being said, let's
try Background Services.

00:02:28.020 --> 00:02:30.280
The goal here is we want
to do a bunch of work

00:02:30.280 --> 00:02:31.804
off of our main thread.

00:02:31.804 --> 00:02:33.220
And because that
main thread, it's

00:02:33.220 --> 00:02:36.042
also called the UI thread
for a very good reason,

00:02:36.042 --> 00:02:37.500
meaning that it
controls everything

00:02:37.500 --> 00:02:38.899
that you can see on the device.

00:02:38.899 --> 00:02:40.940
If something starts to go
wrong, and you're still

00:02:40.940 --> 00:02:43.220
on your UI thread,
you're user is just going

00:02:43.220 --> 00:02:45.310
to see this hideous thing.

00:02:45.310 --> 00:02:46.992
Don't be this!

00:02:46.992 --> 00:02:49.200
It's ugly, I couldn't even
find a good picture of it,

00:02:49.200 --> 00:02:50.300
because nobody wants
to screenshot it.

00:02:50.300 --> 00:02:51.910
It's such a horrifying sight.

00:02:51.910 --> 00:02:52.970
Right?

00:02:52.970 --> 00:02:55.670
And I didn't know
how to make one.

00:02:55.670 --> 00:02:57.860
If you show this to your
user, if this comes up,

00:02:57.860 --> 00:02:59.610
your user is immediately
giving up on you.

00:02:59.610 --> 00:03:01.100
They're leaving the app,
they're not trying again,

00:03:01.100 --> 00:03:02.400
they're not going
to try and refresh.

00:03:02.400 --> 00:03:03.800
Most likely they won't
open your app again,

00:03:03.800 --> 00:03:05.550
and they will probably
even uninstall you.

00:03:05.550 --> 00:03:08.320
This is a death warrant, and
you don't want to see this.

00:03:08.320 --> 00:03:10.220
But the thing is,
that's what users see.

00:03:10.220 --> 00:03:11.845
What it actually
means is that your app

00:03:11.845 --> 00:03:13.970
is working really hard,
and it just needs a minute.

00:03:13.970 --> 00:03:15.070
And that's what's
really frustrating

00:03:15.070 --> 00:03:16.700
because the developer
perspective here

00:03:16.700 --> 00:03:19.947
is that you're trying to do work
and you just forgot something.

00:03:19.947 --> 00:03:22.030
But the user perspective
is you're the worst ever,

00:03:22.030 --> 00:03:23.915
and I hate you.

00:03:23.915 --> 00:03:25.290
We're going to
move on, and we're

00:03:25.290 --> 00:03:27.874
going to avoid this by moving
something off the main thread.

00:03:27.874 --> 00:03:29.290
Work that's going
to hang is going

00:03:29.290 --> 00:03:31.330
to make us miss our frame rate,
and we don't want to do that.

00:03:31.330 --> 00:03:32.760
So we're going to
just shift it away,

00:03:32.760 --> 00:03:34.360
and then it can re-sync
with the later activity

00:03:34.360 --> 00:03:36.000
when it's time to
actually update it.

00:03:36.000 --> 00:03:38.400
Instead of trying to
pause the current activity

00:03:38.400 --> 00:03:39.950
and wait for it.

00:03:39.950 --> 00:03:41.554
OK, so that's our goal.

00:03:41.554 --> 00:03:43.220
So we don't want to
miss our frame rate,

00:03:43.220 --> 00:03:45.170
because we've missed that,
[INAUDIBLE] will just magically

00:03:45.170 --> 00:03:46.461
appear and start hating on you.

00:03:46.461 --> 00:03:48.120
[LAUGHTER]

00:03:48.120 --> 00:03:49.830
So the question is,
where do we start?

00:03:49.830 --> 00:03:51.685
And when I say back
on work, all of you

00:03:51.685 --> 00:03:53.620
are probably thinking
oh, good, AsyncTask.

00:03:53.620 --> 00:03:56.140
And that's not correct.

00:03:56.140 --> 00:03:58.980
AsyncTask is actually tied
to activity lifecycle.

00:03:58.980 --> 00:04:02.620
And that have its own
advantages and disadvantages.

00:04:02.620 --> 00:04:04.990
So I'm going to focus
on work that is entirely

00:04:04.990 --> 00:04:07.310
off the main thread and
AsyncTask has its place,

00:04:07.310 --> 00:04:09.450
and you can read all
about it on your own.

00:04:09.450 --> 00:04:12.700
So let's start with services.

00:04:12.700 --> 00:04:13.840
What's a service?

00:04:13.840 --> 00:04:16.680
Well, it's complex.

00:04:16.680 --> 00:04:17.300
They're hard.

00:04:17.300 --> 00:04:19.820
They have a lot of pieces
you have to manage.

00:04:19.820 --> 00:04:21.360
Services run in the background.

00:04:21.360 --> 00:04:24.030
They're fully apart from any
app activity or fragment,

00:04:24.030 --> 00:04:25.840
but that means that
it can keep running,

00:04:25.840 --> 00:04:27.310
even when your app isn't.

00:04:27.310 --> 00:04:29.666
Which is actually
pretty fantastic.

00:04:29.666 --> 00:04:31.540
But because of this,
that means that services

00:04:31.540 --> 00:04:33.577
can't affect your UI.

00:04:33.577 --> 00:04:35.660
So if you actually want
to show progress dialogue,

00:04:35.660 --> 00:04:38.240
because what you're doing is
in response to user initiated

00:04:38.240 --> 00:04:40.710
action, you probably do
want your AsyncTask that's

00:04:40.710 --> 00:04:41.900
a really great way to do it.

00:04:41.900 --> 00:04:43.600
But if you're kicking off
some sort of activity that

00:04:43.600 --> 00:04:45.510
only needs to report
back when it's done,

00:04:45.510 --> 00:04:47.370
maybe update the
UI then, a service

00:04:47.370 --> 00:04:50.170
is going to be great, because it
can send that information back

00:04:50.170 --> 00:04:51.750
through other avenues later on.

00:04:51.750 --> 00:04:54.250
But, you can update the UI
while you're in a service.

00:04:54.250 --> 00:04:56.460
So any results you
have to pass it.

00:04:56.460 --> 00:04:59.090
Services are great for things
like syncing with your server.

00:04:59.090 --> 00:05:00.655
This is something that's
not usually user initiated,

00:05:00.655 --> 00:05:02.654
but you want to back up
all those photos they've

00:05:02.654 --> 00:05:03.990
been taking in your app.

00:05:03.990 --> 00:05:04.990
That's really
important, but that

00:05:04.990 --> 00:05:06.890
doesn't have to happen
exactly at that moment.

00:05:06.890 --> 00:05:09.240
That could happen when the
phone is put down or is idle,

00:05:09.240 --> 00:05:11.280
or just whenever
there's a chance

00:05:11.280 --> 00:05:14.000
and the radio's already on.

00:05:14.000 --> 00:05:15.690
The other thing is
that services have

00:05:15.690 --> 00:05:18.270
to manage their own lifecycle.

00:05:18.270 --> 00:05:21.205
And that can be kind
of intimidating.

00:05:21.205 --> 00:05:23.830
Because you have to first figure
out which methods to override.

00:05:23.830 --> 00:05:24.860
And then how to override them.

00:05:24.860 --> 00:05:26.090
And then what you
want to leave alone.

00:05:26.090 --> 00:05:27.131
And then how you call it.

00:05:27.131 --> 00:05:29.370
And it's just a lot, which
goes back to my point

00:05:29.370 --> 00:05:31.190
that services are complex.

00:05:31.190 --> 00:05:35.440
So, that's why we're going to
talk about IntentService, which

00:05:35.440 --> 00:05:36.860
does all this work for you.

00:05:36.860 --> 00:05:39.470
How nice is that?

00:05:39.470 --> 00:05:42.070
So IntentService is a much
easier implementation,

00:05:42.070 --> 00:05:44.352
because it will handle
all of its own lifecycle.

00:05:44.352 --> 00:05:46.560
You don't have to worry
about starting it, or binding

00:05:46.560 --> 00:05:48.240
it, or letting it
go, or destroying it.

00:05:48.240 --> 00:05:50.559
It does all of that for
you, it's already written.

00:05:50.559 --> 00:05:53.100
You can focus on what matters,
and that's the background work

00:05:53.100 --> 00:05:55.635
and not how you get into or
out of your background task.

00:05:55.635 --> 00:05:57.635
The trade-off here with
an IntentService instead

00:05:57.635 --> 00:05:59.550
of another one, is that
an IntentService can only

00:05:59.550 --> 00:06:00.730
handle one thing at a time.

00:06:00.730 --> 00:06:02.531
All requests will
happen sequentially.

00:06:02.531 --> 00:06:04.780
So if your app is designed
with multiple requests that

00:06:04.780 --> 00:06:06.930
might come in and [INAUDIBLE]
at the exact same time,

00:06:06.930 --> 00:06:09.513
you're going to have to read the
documentation on how services

00:06:09.513 --> 00:06:11.480
work, sorry.

00:06:11.480 --> 00:06:13.880
How do we create
an IntentService?

00:06:13.880 --> 00:06:17.120
First step, you have to make
a class for your service.

00:06:17.120 --> 00:06:19.420
And to do that you need to
declare it in your manifest.

00:06:19.420 --> 00:06:21.336
You have to say that
this is going to be here.

00:06:21.336 --> 00:06:24.420
Like, this actually exists
and I'm going to use it.

00:06:24.420 --> 00:06:26.170
And then, of course,
some of you may know,

00:06:26.170 --> 00:06:28.350
exported is this
variable that says

00:06:28.350 --> 00:06:31.176
you can restrict
the service to only

00:06:31.176 --> 00:06:32.300
being accessed by your app.

00:06:32.300 --> 00:06:33.383
Which is what false means.

00:06:33.383 --> 00:06:34.916
Or, if you say to
true, other apps

00:06:34.916 --> 00:06:37.290
may be able to interact with
your service and set it off,

00:06:37.290 --> 00:06:39.510
which is sometimes
really valuable.

00:06:39.510 --> 00:06:41.370
You can also declare
multiple services.

00:06:41.370 --> 00:06:45.317
You can have 13 of them and each
one is a very targeted service.

00:06:45.317 --> 00:06:47.900
Definitely real service could
be like, definitely a real share

00:06:47.900 --> 00:06:50.130
service, and like definitely
a real backup service,

00:06:50.130 --> 00:06:51.990
and every one could have its
own specified task, which

00:06:51.990 --> 00:06:53.406
makes code maintenance
really easy

00:06:53.406 --> 00:06:55.830
and also means it's a lot
easier to track what's going on

00:06:55.830 --> 00:06:57.194
and when things are going wrong.

00:06:57.194 --> 00:06:58.610
But most importantly,
your service

00:06:58.610 --> 00:07:00.550
needs to extend
from IntentService.

00:07:00.550 --> 00:07:03.094
So, you have a class,
and the only method

00:07:03.094 --> 00:07:05.010
you have to implement,
or override by default,

00:07:05.010 --> 00:07:05.940
is on handle intent.

00:07:05.940 --> 00:07:07.940
You can actually just
ignore all the other ones.

00:07:07.940 --> 00:07:10.540
That's the whole lifecycle
being handled for you,

00:07:10.540 --> 00:07:13.370
which is pretty fantastic.

00:07:13.370 --> 00:07:15.950
So onHandleIntent, this
is where all of your work

00:07:15.950 --> 00:07:17.530
is going to happen.

00:07:17.530 --> 00:07:18.152
Imagine that.

00:07:18.152 --> 00:07:19.610
So maybe this is
where you're going

00:07:19.610 --> 00:07:22.332
to open a network connection,
or send data to your server,

00:07:22.332 --> 00:07:24.040
and then clean up that
connection, that'd

00:07:24.040 --> 00:07:27.210
be pretty great-- cleaning
up your network connections.

00:07:27.210 --> 00:07:28.960
Or maybe you want to
write to the SD card.

00:07:28.960 --> 00:07:31.290
All of this kind of
stuff is definitely not

00:07:31.290 --> 00:07:32.710
supposed to effect your UI.

00:07:32.710 --> 00:07:35.390
Maybe you'll send the message
updated and change something

00:07:35.390 --> 00:07:37.140
to green.

00:07:37.140 --> 00:07:39.240
But all of the data
you might need,

00:07:39.240 --> 00:07:42.277
you can put into that
intent like as an extra,

00:07:42.277 --> 00:07:44.360
pass it along, and then
use that to maybe kick off

00:07:44.360 --> 00:07:46.640
a notification, or kick off
the work they need to do.

00:07:46.640 --> 00:07:50.277
Anything that's really relevant,
services are pretty versatile.

00:07:50.277 --> 00:07:52.360
Once you've got it written,
you need to invoke it.

00:07:52.360 --> 00:07:54.834
And this happens from,
usually, an activity.

00:07:54.834 --> 00:07:56.750
And to do that, you need
to create the intent,

00:07:56.750 --> 00:07:59.119
fill it with something,
and then pass it.

00:07:59.119 --> 00:08:01.160
And passing is great, you
just call startservice,

00:08:01.160 --> 00:08:02.950
it's actually that easy.

00:08:02.950 --> 00:08:04.030
OK, start it, I'm ready.

00:08:04.030 --> 00:08:05.789
Like I said, like an
IntentService manages

00:08:05.789 --> 00:08:06.580
it's own lifecycle.

00:08:06.580 --> 00:08:09.430
You don't have to start
it, bind it, all the stuff.

00:08:09.430 --> 00:08:11.920
You just call startservice with
the intent and you're done.

00:08:11.920 --> 00:08:14.500
That's actually
all there is to it.

00:08:14.500 --> 00:08:16.804
And then with all of
the data you pass along,

00:08:16.804 --> 00:08:18.595
then your intent might--
your service might

00:08:18.595 --> 00:08:21.040
be able to actually use that
same kind of intent to report

00:08:21.040 --> 00:08:21.980
back.

00:08:21.980 --> 00:08:24.700
So given enough information
to know what its job is

00:08:24.700 --> 00:08:28.120
and if a response
is necessary, too.

00:08:28.120 --> 00:08:30.290
You know that you can use
it calling startservice,

00:08:30.290 --> 00:08:32.206
but the question is when
to call startservice,

00:08:32.206 --> 00:08:35.000
and my advice is usually
from a BroadcastReceiver.

00:08:35.000 --> 00:08:38.340
Because these are really great
ways of waiting for a signal

00:08:38.340 --> 00:08:40.809
that something needs to happen.

00:08:40.809 --> 00:08:44.090
Whenever anything
actually needs to happen.

00:08:44.090 --> 00:08:46.810
So BroadcastReceiver job is
to respond to an announcement

00:08:46.810 --> 00:08:48.979
and that comes in the form
of yet another intent.

00:08:48.979 --> 00:08:50.520
These are magical
little things like,

00:08:50.520 --> 00:08:53.099
I'd like to do this,
with these constraints.

00:08:53.099 --> 00:08:54.890
So this is a common
trigger for kicking off

00:08:54.890 --> 00:08:58.020
background work, which is great
because a BroadcastReceiver

00:08:58.020 --> 00:09:00.824
doesn't actually bring your
app into the foreground.

00:09:00.824 --> 00:09:02.240
It can kick off a
service that may

00:09:02.240 --> 00:09:04.573
or not affect foreground work,
but the BroadcastReceiver

00:09:04.573 --> 00:09:07.394
itself opens, runs on
receive, and triggers

00:09:07.394 --> 00:09:09.810
whatever is in that, and then
stays all in the background.

00:09:09.810 --> 00:09:11.643
So you're still protecting
your main thread,

00:09:11.643 --> 00:09:13.910
which is our goal here.

00:09:13.910 --> 00:09:15.780
So BroadcastReceiver
can actually

00:09:15.780 --> 00:09:17.550
interact with several
different sources.

00:09:17.550 --> 00:09:20.510
A local broadcast will come
from within your own app.

00:09:20.510 --> 00:09:23.190
And this is a sign that maybe
it's time to sync, [INAUDIBLE]

00:09:23.190 --> 00:09:24.648
the service, or
maybe it's actually

00:09:24.648 --> 00:09:27.550
the IntentService reporting
back about how the job went,

00:09:27.550 --> 00:09:31.770
or this failed, or
that's not a real URI.

00:09:31.770 --> 00:09:33.780
App broadcasts can also
come from other apps

00:09:33.780 --> 00:09:35.410
on the device, which is
really great when you're

00:09:35.410 --> 00:09:36.730
trying to take advantage
of functionality

00:09:36.730 --> 00:09:38.600
that you don't want to build,
but somebody else offers.

00:09:38.600 --> 00:09:40.016
Or you want to
offer functionality

00:09:40.016 --> 00:09:41.970
to other developers
so that you actually

00:09:41.970 --> 00:09:44.320
get users using a lot of
different really great things.

00:09:44.320 --> 00:09:46.720
So you don't have
to keep rebuilding

00:09:46.720 --> 00:09:48.560
picture-taking every
time, or storage,

00:09:48.560 --> 00:09:50.256
or something like that.

00:09:50.256 --> 00:09:51.880
System broadcasts
are really important,

00:09:51.880 --> 00:09:53.190
they carry status information.

00:09:53.190 --> 00:09:54.814
Things like something
being plugged in,

00:09:54.814 --> 00:09:56.270
or a signal that's changing.

00:09:56.270 --> 00:09:57.520
So you might be subscribed to.

00:09:57.520 --> 00:10:00.374
So if you really care
about your app only

00:10:00.374 --> 00:10:02.790
runs when plugged in, because
maybe you're a sleep tracker

00:10:02.790 --> 00:10:04.289
and you don't want
it to fall asleep

00:10:04.289 --> 00:10:05.870
while the user's also asleep.

00:10:05.870 --> 00:10:07.620
That's the kind of thing, you'd
wait for the signal on this,

00:10:07.620 --> 00:10:08.690
and then if it came
unplugged, you'd

00:10:08.690 --> 00:10:10.130
get a broadcast
that it's unplugged,

00:10:10.130 --> 00:10:11.640
and that might
change your behavior.

00:10:11.640 --> 00:10:14.657
You might only stop
tracking data to that point.

00:10:14.657 --> 00:10:16.740
And finally, you can use
them for server messages,

00:10:16.740 --> 00:10:17.930
like downstream messages.

00:10:17.930 --> 00:10:20.270
GCM actually has its own
dedicated BroadcastReceiver

00:10:20.270 --> 00:10:22.260
system, which I'll
tell you about.

00:10:22.260 --> 00:10:23.980
Downstream messages
are a great way

00:10:23.980 --> 00:10:26.604
for your server to indicate that
something needs to happen now.

00:10:26.604 --> 00:10:30.677
Which the app might not be able
to give a signal on, right?

00:10:30.677 --> 00:10:32.760
So basically BroadcastReceivers
are the best thing

00:10:32.760 --> 00:10:34.870
ever because any kind of
message can come through,

00:10:34.870 --> 00:10:36.744
and then you can react
accordingly, and maybe

00:10:36.744 --> 00:10:38.450
start off any kind
of different service.

00:10:38.450 --> 00:10:42.730
And just like service, you can
register multiple receivers.

00:10:42.730 --> 00:10:44.449
So let's talk about
how to do that.

00:10:44.449 --> 00:10:46.240
With an IntentService,
it's the same thing.

00:10:46.240 --> 00:10:48.440
You have to create
the actual class,

00:10:48.440 --> 00:10:51.620
and then declare it your
receiver in your manifest that

00:10:51.620 --> 00:10:52.674
looks roughly the same.

00:10:52.674 --> 00:10:54.090
But the meat of
everything here is

00:10:54.090 --> 00:10:56.355
going to live in this
method called onreceive.

00:10:56.355 --> 00:10:58.610
It's really the only
thing you have to override

00:10:58.610 --> 00:11:00.172
with a BroadcastReceiver.

00:11:00.172 --> 00:11:02.130
And this will do all of
your intent processing,

00:11:02.130 --> 00:11:04.720
like you get the intent
that comes through,

00:11:04.720 --> 00:11:07.304
and any extras might indicate
what kind of work you're doing

00:11:07.304 --> 00:11:09.220
here, maybe your
BroadcastReceiver does double

00:11:09.220 --> 00:11:10.650
duty, maybe it doesn't.

00:11:10.650 --> 00:11:13.540
But this will help you do any
kind of processing and kicking

00:11:13.540 --> 00:11:16.072
off your service.

00:11:16.072 --> 00:11:17.530
The thing about a
BroadcastReceiver

00:11:17.530 --> 00:11:19.900
is that it only lives
for the duration

00:11:19.900 --> 00:11:22.930
of this onreceive call,
which is like milliseconds.

00:11:22.930 --> 00:11:26.170
So, you can't do your core of
your background work in here.

00:11:26.170 --> 00:11:30.064
You need to offload that to
prevent any further hanging.

00:11:30.064 --> 00:11:32.480
Because otherwise as soon as
this call completes, it dies.

00:11:32.480 --> 00:11:33.854
Also if you have
a helper method,

00:11:33.854 --> 00:11:35.880
you don't really
have a chance here.

00:11:35.880 --> 00:11:39.177
OK, so you also have to
register your BroadcastReceiver,

00:11:39.177 --> 00:11:41.510
like you have to say which
intents you're interested in.

00:11:41.510 --> 00:11:42.790
And we don't just
get everything,

00:11:42.790 --> 00:11:43.873
that would be a nightmare.

00:11:43.873 --> 00:11:46.380
Like just constant
information coming in.

00:11:46.380 --> 00:11:47.950
And I recommend
looking into what's

00:11:47.950 --> 00:11:50.200
called LocalBroadcastManager,
because if you're really

00:11:50.200 --> 00:11:51.908
just using broadcast
within your own app,

00:11:51.908 --> 00:11:55.860
as a signal to and from
services, this is a great tool.

00:11:55.860 --> 00:11:57.450
You can also include
an intent filter,

00:11:57.450 --> 00:11:59.783
like, I want this intent,
with these kinds of parameters

00:11:59.783 --> 00:12:00.640
and stuff.

00:12:00.640 --> 00:12:02.520
So it lets you set up everything
for a number of situations,

00:12:02.520 --> 00:12:03.800
and I think it's pretty great.

00:12:03.800 --> 00:12:04.842
So check the box on that.

00:12:04.842 --> 00:12:06.508
Because we're going
to move on to what's

00:12:06.508 --> 00:12:08.130
called a
WakefulBroadcastReceiver.

00:12:08.130 --> 00:12:12.140
I told you that onreceive
only lasts, your app is only

00:12:12.140 --> 00:12:14.790
brought to life for the
duration of onreceive which

00:12:14.790 --> 00:12:17.110
means that there's a chance
that between onreceive

00:12:17.110 --> 00:12:18.880
and startservice
like onreceive wraps

00:12:18.880 --> 00:12:20.380
and your service
hasn't started yet,

00:12:20.380 --> 00:12:23.460
there's a chance that the system
might take away your CPU time

00:12:23.460 --> 00:12:24.220
inbetween that.

00:12:24.220 --> 00:12:26.510
So if you need to guarantee
that your service runs

00:12:26.510 --> 00:12:28.690
the moment that
onreceive ends, you

00:12:28.690 --> 00:12:29.857
want to acquire a wake lock.

00:12:29.857 --> 00:12:32.273
And you want to hold that wake
lock until your service has

00:12:32.273 --> 00:12:33.230
a chance to run.

00:12:33.230 --> 00:12:35.000
But wake locks are
hard, and you shouldn't

00:12:35.000 --> 00:12:38.070
have to waste your time on
that, because we did it for you.

00:12:38.070 --> 00:12:39.770
We created the
WakefulBroadcastReceiver,

00:12:39.770 --> 00:12:41.220
which manages it's
own wake lock,

00:12:41.220 --> 00:12:44.330
and still guarantee that your
service will run immediately

00:12:44.330 --> 00:12:46.000
after onreceive.

00:12:46.000 --> 00:12:48.250
So, again look at
all these things

00:12:48.250 --> 00:12:50.542
we did for you, because
background work is really hard.

00:12:50.542 --> 00:12:52.208
Let us manage as much
of the life-cycles

00:12:52.208 --> 00:12:54.480
we can, unless you have some
sort of custom situation,

00:12:54.480 --> 00:12:56.813
and at that point you're
already doing tons of research,

00:12:56.813 --> 00:12:58.040
so you're golden, right?

00:12:58.040 --> 00:13:00.430
OK, so implementing the
WakefulBroadcastReceiver

00:13:00.430 --> 00:13:03.230
procedure, look it's exactly the
same, except I added the word

00:13:03.230 --> 00:13:04.400
wakeful.

00:13:04.400 --> 00:13:08.480
It's not scary all,
it's the only change.

00:13:08.480 --> 00:13:11.730
It just means-- all these things
we worked really hard, finally

00:13:11.730 --> 00:13:13.670
to make these great
tools for you,

00:13:13.670 --> 00:13:16.410
because it wasn't
easy for so long.

00:13:16.410 --> 00:13:19.410
OK so I mentioned that GCM
has its own special situation,

00:13:19.410 --> 00:13:22.020
and I'd like to explain a
little bit more about that.

00:13:22.020 --> 00:13:25.630
We really try to push
GCM, not just because we

00:13:25.630 --> 00:13:27.599
love our own products,
but because if you

00:13:27.599 --> 00:13:30.140
have to maintain a persistent
network connection on a device,

00:13:30.140 --> 00:13:30.848
that's expensive.

00:13:30.848 --> 00:13:33.924
It drains radio, it drains CPU
time, it drains the battery.

00:13:33.924 --> 00:13:36.590
And so if every app is trying to
do their own homegrown version,

00:13:36.590 --> 00:13:37.791
that's going to be horrible.

00:13:37.791 --> 00:13:40.290
But if we can create one that
the entire device knows about,

00:13:40.290 --> 00:13:42.715
that's smart enough to know
when to pass things along

00:13:42.715 --> 00:13:44.840
to the right apps, and has
the right access things,

00:13:44.840 --> 00:13:46.680
then we can save huge
performance wins,

00:13:46.680 --> 00:13:49.200
huge user wins, and huge
developer effort, right?

00:13:49.200 --> 00:13:50.700
And that's why you
can see us, we're

00:13:50.700 --> 00:13:53.020
always pushing Google
Cloud Messaging.

00:13:53.020 --> 00:13:55.040
The other thing is that
GCM has an advantage

00:13:55.040 --> 00:13:56.960
that your homegrown
version will never have.

00:13:56.960 --> 00:13:58.742
And that's that
all of our carriers

00:13:58.742 --> 00:14:00.700
have worked with us to
give special recognition

00:14:00.700 --> 00:14:02.850
to the ports that GCM
travels on, to keep

00:14:02.850 --> 00:14:06.220
them open as long as possible.

00:14:06.220 --> 00:14:09.930
Any messaging alternative you'll
see in downstream messaging,

00:14:09.930 --> 00:14:11.920
will usually be
built on top of GCM,

00:14:11.920 --> 00:14:13.480
or will be built on
a polling system.

00:14:13.480 --> 00:14:14.920
And you don't-- if you don't
want to build your own polling

00:14:14.920 --> 00:14:17.975
system, why would you want to
build on top of another one?

00:14:17.975 --> 00:14:20.350
So throughout the conference,
as you see us all basically

00:14:20.350 --> 00:14:22.016
force-feeding you
GCM, know that we have

00:14:22.016 --> 00:14:23.390
a really good reason for it.

00:14:23.390 --> 00:14:27.060
It's not just because we
happen to be cousins with it.

00:14:27.060 --> 00:14:27.609
OK.

00:14:27.609 --> 00:14:29.150
The other thing
about the GcmReceiver

00:14:29.150 --> 00:14:31.680
is it actually extends from
WakefulBroadcastReceiver,

00:14:31.680 --> 00:14:33.730
so you get that wake lock
management by default,

00:14:33.730 --> 00:14:35.110
which is even better.

00:14:35.110 --> 00:14:37.068
So to use it, you have
to declare your receiver

00:14:37.068 --> 00:14:38.710
the way you would
any other receiver.

00:14:38.710 --> 00:14:40.550
Except you have to
have something special,

00:14:40.550 --> 00:14:43.336
which is the permission to send.

00:14:43.336 --> 00:14:44.710
That means that
you are basically

00:14:44.710 --> 00:14:49.420
adhering to the permission
required by GCM, because you

00:14:49.420 --> 00:14:51.626
want you want protected
communications, so GCM

00:14:51.626 --> 00:14:53.000
service requires
this permission,

00:14:53.000 --> 00:14:54.708
and you honor this
permission, and that's

00:14:54.708 --> 00:14:57.810
what this lets you to do,
to declare in your manifest.

00:14:57.810 --> 00:15:00.010
And also, you set up an
intent filter to say like,

00:15:00.010 --> 00:15:05.840
I want all receiving messages
from GCM to my application.

00:15:05.840 --> 00:15:07.770
Super easy.

00:15:07.770 --> 00:15:09.727
So then you build
your listener service.

00:15:09.727 --> 00:15:11.810
Did you notice you don't
have to build a receiver?

00:15:11.810 --> 00:15:13.810
You don't have to extend
from GCM receiver, that

00:15:13.810 --> 00:15:17.264
already exists for you, you just
have to use it by declaring it.

00:15:17.264 --> 00:15:19.680
Then all you have to do is
override your listener service.

00:15:19.680 --> 00:15:22.080
It's not an intents service,
but it's still pretty great

00:15:22.080 --> 00:15:25.324
because you don't have to
manage and life-cycles still.

00:15:25.324 --> 00:15:27.240
Then your message comes
in with who it's from,

00:15:27.240 --> 00:15:28.359
so you get your server ID.

00:15:28.359 --> 00:15:30.150
You can double check
that you're getting it

00:15:30.150 --> 00:15:31.150
from the right
messaging case, maybe

00:15:31.150 --> 00:15:32.550
you have multiple
different things.

00:15:32.550 --> 00:15:34.008
And you get all
the information you

00:15:34.008 --> 00:15:37.230
need in data based on how you
structure your own data when

00:15:37.230 --> 00:15:38.540
you send it.

00:15:38.540 --> 00:15:42.780
So great, so great, why
are you not doing this?

00:15:42.780 --> 00:15:49.237
So now we can move on from how
background work specifically

00:15:49.237 --> 00:15:51.320
like how to implement it,
to when to implement it,

00:15:51.320 --> 00:15:52.762
and how to invoke it.

00:15:52.762 --> 00:15:54.220
You know you can
call startservice,

00:15:54.220 --> 00:15:56.040
but the question is,
what do you really

00:15:56.040 --> 00:15:59.130
use to trigger a reminder
when it comes later?

00:15:59.130 --> 00:16:01.681
And when does it
need to come later?

00:16:01.681 --> 00:16:03.180
So concerning that
question of when,

00:16:03.180 --> 00:16:07.230
if you need your work to run
at a specific moment in time,

00:16:07.230 --> 00:16:09.520
you're going to get to
meet the AlarmManager.

00:16:09.520 --> 00:16:11.660
So an alarm is not
like a wake up alarm,

00:16:11.660 --> 00:16:14.080
like, 'ding, ding, ding'
alarm is a signal to your app

00:16:14.080 --> 00:16:18.830
that it's time for your app to
wake up and do some more work.

00:16:18.830 --> 00:16:21.200
And when you register
an intent with an alarm,

00:16:21.200 --> 00:16:23.370
it'll actually fire that
intent as soon as it

00:16:23.370 --> 00:16:25.270
fires through the AlarmManager.

00:16:25.270 --> 00:16:27.940
So setting alarms
with AlarmManager.

00:16:27.940 --> 00:16:31.480
To set a single alarm with
anything that's above API 19

00:16:31.480 --> 00:16:32.801
you can call set.

00:16:32.801 --> 00:16:33.800
Look how simple that is.

00:16:33.800 --> 00:16:35.690
And it sets a single
inexact alarm.

00:16:35.690 --> 00:16:38.317
And what inexact means
is that, let's say

00:16:38.317 --> 00:16:40.150
your alarm is supposed
to go off in an hour,

00:16:40.150 --> 00:16:41.650
it will not go off
before that hour,

00:16:41.650 --> 00:16:43.484
but it may go off
sometime after that hour,

00:16:43.484 --> 00:16:45.150
if the system is
trying to intelligently

00:16:45.150 --> 00:16:46.730
batch things together.

00:16:46.730 --> 00:16:49.130
Because we want to save
battery as much as possible,

00:16:49.130 --> 00:16:50.440
so if we know there
are four alarms coming

00:16:50.440 --> 00:16:51.898
up sometime between
three and four,

00:16:51.898 --> 00:16:53.900
we might try to run them
all at the same time.

00:16:53.900 --> 00:16:57.080
But it will never fire early
and that's a guarantee.

00:16:57.080 --> 00:16:59.320
We also have setwindow,
which is if you're flexible,

00:16:59.320 --> 00:17:00.820
and you don't really
mind using set,

00:17:00.820 --> 00:17:03.624
but you want to have a
definite duration of time,

00:17:03.624 --> 00:17:04.540
this is pretty great,.

00:17:04.540 --> 00:17:07.160
Because you can specify what
that window is going to be.

00:17:07.160 --> 00:17:08.930
And then when it
really does matter,

00:17:08.930 --> 00:17:11.808
we have setexact, in order
to specify that time actually

00:17:11.808 --> 00:17:12.599
really does matter.

00:17:12.599 --> 00:17:14.839
And this is important for
maybe a calendar reminder.

00:17:14.839 --> 00:17:16.255
If you're 40 minutes
late on that,

00:17:16.255 --> 00:17:18.865
you've actually really messed
up with your users' life.

00:17:18.865 --> 00:17:20.490
The other thing to
note is that any API

00:17:20.490 --> 00:17:24.510
before 19 set and setexact
are equivalent because we

00:17:24.510 --> 00:17:27.010
didn't actually intoduce an
exact timing until KitKat.

00:17:27.010 --> 00:17:30.250
So API before 19, you
would just call set.

00:17:30.250 --> 00:17:32.920
And it's already exact,
how great is that?

00:17:32.920 --> 00:17:36.220
So to do this, look
how few lines of code

00:17:36.220 --> 00:17:37.780
this is, like this
isn't terrifying.

00:17:37.780 --> 00:17:39.190
You don't have to worry.

00:17:39.190 --> 00:17:42.390
You just get the AlarmManager
service from the system,

00:17:42.390 --> 00:17:44.854
create your intent, and you
have to turn your intent

00:17:44.854 --> 00:17:45.770
into a pending intent.

00:17:45.770 --> 00:17:49.670
And that's how the AlarmManager
is able to actually fire it.

00:17:49.670 --> 00:17:51.310
Definitely use
request codes here.

00:17:51.310 --> 00:17:53.425
So I'm skipping-- you
could call a receiver here,

00:17:53.425 --> 00:17:56.050
that would make a lot of sense,
because maybe you want to react

00:17:56.050 --> 00:17:57.430
to a different kind of thing.

00:17:57.430 --> 00:17:58.750
I'm skipping straight
to the service,

00:17:58.750 --> 00:18:01.170
I know that this alarm means
it's time to run this thing.

00:18:01.170 --> 00:18:03.582
I'm going to invoke
that service directly.

00:18:03.582 --> 00:18:05.540
And then I set it up for
whenever I want it to,

00:18:05.540 --> 00:18:06.610
time to trigger.

00:18:06.610 --> 00:18:08.880
I didn't declare that
because I don't know on here,

00:18:08.880 --> 00:18:10.854
maybe I want it to be an hour.

00:18:10.854 --> 00:18:13.270
Different situation-- maybe
you don't want a single alarm,

00:18:13.270 --> 00:18:15.090
maybe you want an alarm
that repeats itself

00:18:15.090 --> 00:18:17.390
on its own schedule.

00:18:17.390 --> 00:18:20.420
This is, surprisingly,
still AlarmManager.

00:18:20.420 --> 00:18:23.190
You're not surprised,
it's not a surprise.

00:18:23.190 --> 00:18:27.980
So with repeating alarms,
we have setInexactRepeating

00:18:27.980 --> 00:18:28.990
for guess what?

00:18:28.990 --> 00:18:30.330
InexactRepeating alarms.

00:18:30.330 --> 00:18:32.326
So you specify a period
of time, like maybe

00:18:32.326 --> 00:18:33.700
you need it to go
off every hour,

00:18:33.700 --> 00:18:35.570
but not necessarily on the hour.

00:18:35.570 --> 00:18:37.070
You have a little
bit of give there.

00:18:37.070 --> 00:18:42.222
So we'll go off every hour, but
maybe, maybe at 15, maybe not.

00:18:42.222 --> 00:18:43.930
Which is pretty
fantastic as far as like,

00:18:43.930 --> 00:18:45.596
I need this to be
done fairly regularly,

00:18:45.596 --> 00:18:49.231
but I don't specifically
care that it's at 4:02pm.

00:18:49.231 --> 00:18:51.730
Then that means that you can
talk about set exact repeating,

00:18:51.730 --> 00:18:52.900
except it doesn't exist.

00:18:52.900 --> 00:18:54.110
That's not a thing,
we didn't create that,

00:18:54.110 --> 00:18:56.260
because it doesn't make
a whole lot of sense.

00:18:56.260 --> 00:18:59.320
We actually say, use setexact,
to set a repeating alarm,

00:18:59.320 --> 00:19:01.890
and then when it triggers
that one, set the next one.

00:19:01.890 --> 00:19:04.390
Because if it's that exact, you
probably have something else

00:19:04.390 --> 00:19:07.589
you care about, and you
probably want to check on that.

00:19:07.589 --> 00:19:09.380
The other truth is we
actually don't really

00:19:09.380 --> 00:19:10.610
recommend this either,
we would rather you just

00:19:10.610 --> 00:19:12.860
not set exact repeating
alarms at all.

00:19:12.860 --> 00:19:15.110
So setting and exact repeating
is really your answer,

00:19:15.110 --> 00:19:18.170
but if you need a special use
case, just do it one at a time

00:19:18.170 --> 00:19:20.890
and build that into how
you manage your alarm.

00:19:20.890 --> 00:19:22.900
So to set an
InexactRepeating alarm,

00:19:22.900 --> 00:19:25.510
you see how it's pretty much
exactly the same, as far as

00:19:25.510 --> 00:19:26.120
setting it up.

00:19:26.120 --> 00:19:27.890
And then you call
InexactRepeating,

00:19:27.890 --> 00:19:29.090
but instead of just
saying the time trigger,

00:19:29.090 --> 00:19:31.506
you have to add that interval,
an interval that you really

00:19:31.506 --> 00:19:32.139
care about.

00:19:32.139 --> 00:19:34.680
Again, I just made up a variable
because I don't specifically

00:19:34.680 --> 00:19:36.679
care about counting out
milliseconds, right now.

00:19:39.170 --> 00:19:42.120
Now what if you need your
alarm to go off often?

00:19:42.120 --> 00:19:43.710
Let's say every
60 seconds, right?

00:19:43.710 --> 00:19:45.760
Like it's something that
triggers another action,

00:19:45.760 --> 00:19:47.810
maybe you're
checking on a censor,

00:19:47.810 --> 00:19:49.830
or there's something
that you need to do

00:19:49.830 --> 00:19:52.200
incredibly, incredibly, often.

00:19:52.200 --> 00:19:54.060
We don't recommend
AlarmManager at all.

00:19:54.060 --> 00:19:55.860
We think you should
write your own handler

00:19:55.860 --> 00:19:59.060
to handle this kind of thing
and use a time trigger.

00:19:59.060 --> 00:20:01.090
But I'm not going to
teach you how to do that,

00:20:01.090 --> 00:20:03.340
because that's really bad
for performance and battery.

00:20:03.340 --> 00:20:06.120
And you should probably try to
find an alternative instead.

00:20:06.120 --> 00:20:08.540
But you should know
that it exists.

00:20:08.540 --> 00:20:11.250
Now when your job needs to
go off at some point today,

00:20:11.250 --> 00:20:13.870
maybe-ish, like, just
whenever we're on Wi-Fi,

00:20:13.870 --> 00:20:15.740
like either when you
don't really care,

00:20:15.740 --> 00:20:17.198
you just want it
to happen, or when

00:20:17.198 --> 00:20:19.920
you're waiting for a specific
set of conditions to be met.

00:20:19.920 --> 00:20:23.060
This is when you're going to get
to that wonderful thing that's

00:20:23.060 --> 00:20:25.220
called JobScheduler And
you're not afraid, right,

00:20:25.220 --> 00:20:26.720
because you have
all this background

00:20:26.720 --> 00:20:29.020
and not intimidated anymore.

00:20:29.020 --> 00:20:33.970
So JobScheduler
isn't complicated,

00:20:33.970 --> 00:20:36.890
it's just got a lot
of pieces to it.

00:20:36.890 --> 00:20:38.240
So let's talk about background.

00:20:38.240 --> 00:20:40.879
It was introduced in
Lollipop, and what it does, is

00:20:40.879 --> 00:20:43.420
it doesn't work off of a time
schedule the way an alarm does,

00:20:43.420 --> 00:20:45.777
instead it works based
off of conditions.

00:20:45.777 --> 00:20:48.110
Maybe I'm waiting for Wi-Fi
when the user isn't actually

00:20:48.110 --> 00:20:49.180
using their phone.

00:20:49.180 --> 00:20:53.480
That's a pretty good time to
run an upload of photos, right?

00:20:53.480 --> 00:20:55.230
JobScheduler is designed
to make it really

00:20:55.230 --> 00:20:57.760
easy for the system to batch
jobs, because everybody says,

00:20:57.760 --> 00:20:59.176
I have this job
it needs to happen

00:20:59.176 --> 00:21:01.135
at this kind of situation,
and I have one, too.

00:21:01.135 --> 00:21:03.634
And you're like, oh great, you
both want Wi-Fi, Wi-Fi is on,

00:21:03.634 --> 00:21:04.680
let's go together.

00:21:04.680 --> 00:21:06.560
Like hold hands,
you got a buddy.

00:21:06.560 --> 00:21:08.970
And that's our
battery and perf win,

00:21:08.970 --> 00:21:11.190
which will make
[INAUDIBLE] really happy.

00:21:11.190 --> 00:21:14.000
The other thing is
JobScheduler surprisingly runs

00:21:14.000 --> 00:21:15.144
on the main thread.

00:21:15.144 --> 00:21:17.810
And I'm not really kidding, like
the job service that you create

00:21:17.810 --> 00:21:19.082
will run on your main thread.

00:21:19.082 --> 00:21:21.040
So when you're actually
doing complicated work,

00:21:21.040 --> 00:21:23.060
you use your job
service in conjunction

00:21:23.060 --> 00:21:24.520
with some other
background service,

00:21:24.520 --> 00:21:30.750
like a task, a basic task,
or like an intent service.

00:21:30.750 --> 00:21:32.136
So to use
JobScheduler, you start

00:21:32.136 --> 00:21:33.510
by creating that
job service that

00:21:33.510 --> 00:21:37.210
runs on the main thread,
which is very odd in my mind.

00:21:37.210 --> 00:21:39.900
To do this, you need to
override at least two methods,

00:21:39.900 --> 00:21:40.460
if not more.

00:21:40.460 --> 00:21:42.780
The first is onstart
job, which is called,

00:21:42.780 --> 00:21:44.820
not by you, but by
the system, when

00:21:44.820 --> 00:21:46.665
it's time to start your job.

00:21:46.665 --> 00:21:48.290
But because it runs
on the main thread,

00:21:48.290 --> 00:21:50.940
this is the place where you want
to kick off to your other work

00:21:50.940 --> 00:21:52.770
when you're doing
heavy computations.

00:21:52.770 --> 00:21:54.850
If you're just setting
a job to maybe send

00:21:54.850 --> 00:21:58.310
a notification because it's
six o'clock, that's fine.

00:21:58.310 --> 00:22:03.250
But anything that's heavy,
you want to kick it off here.

00:22:03.250 --> 00:22:05.140
And when you
override onstart job,

00:22:05.140 --> 00:22:07.600
in addition to
starting web work here,

00:22:07.600 --> 00:22:08.980
you need to return a Boolean.

00:22:08.980 --> 00:22:11.460
So you're going to return
true if you've moved work

00:22:11.460 --> 00:22:14.400
to a background thread, in order
to perform that kind of stuff

00:22:14.400 --> 00:22:16.169
to show that something
else is going on

00:22:16.169 --> 00:22:17.960
and JobScheduler needs
to be aware of that.

00:22:17.960 --> 00:22:19.560
But you return false
if it was a simple task

00:22:19.560 --> 00:22:21.810
and you've already finished
and we're done processing.

00:22:21.810 --> 00:22:24.220
So that's what
that Boolean means.

00:22:24.220 --> 00:22:29.280
And then for onstop
job, you actually,

00:22:29.280 --> 00:22:31.020
this is called by
the system again,

00:22:31.020 --> 00:22:33.270
but it's only when the job
is cancelled before it gets

00:22:33.270 --> 00:22:34.530
the chance to be finished.

00:22:34.530 --> 00:22:37.070
So maybe you were waiting for
Wi-Fi, and then you had it,

00:22:37.070 --> 00:22:38.754
but the user left
the Wi-Fi zone,

00:22:38.754 --> 00:22:40.170
and now you don't
have it anymore.

00:22:40.170 --> 00:22:41.045
You haven't finished.

00:22:41.045 --> 00:22:44.020
So we cancel the job,
because these conditions

00:22:44.020 --> 00:22:45.270
aren't being met anymore.

00:22:45.270 --> 00:22:47.025
And so this is what
this Boolean is for,

00:22:47.025 --> 00:22:48.900
whatever cleanup you
need to do is important.

00:22:48.900 --> 00:22:50.540
But also you need to
return true if you

00:22:50.540 --> 00:22:52.998
want to reschedule that job
because it didn't have a chance

00:22:52.998 --> 00:22:53.584
to run.

00:22:53.584 --> 00:22:56.000
But if it didn't really matter,
then you can return false,

00:22:56.000 --> 00:22:57.980
and it will just be dropped.

00:22:57.980 --> 00:23:01.875
So that's what those super
indicative Booleans are.

00:23:01.875 --> 00:23:04.000
And then that third method
that you don't override,

00:23:04.000 --> 00:23:06.125
but you need to call that
lives inside job services

00:23:06.125 --> 00:23:08.640
is jobFinished And this
is how you call it,

00:23:08.640 --> 00:23:13.972
you need to in your service,
way away, they've kicked off to,

00:23:13.972 --> 00:23:15.930
once you're done with
your work, you call this,

00:23:15.930 --> 00:23:18.840
and you pass back the job
parameters that were passed in.

00:23:18.840 --> 00:23:19.420
You see?

00:23:19.420 --> 00:23:21.450
From here, your onstop job?

00:23:21.450 --> 00:23:24.680
So I put them in, but you need
to pass these parameters back

00:23:24.680 --> 00:23:26.520
to indicate which jobs
we're finished with.

00:23:26.520 --> 00:23:28.660
And this tells the system
that we actually completed,

00:23:28.660 --> 00:23:30.743
we're good, we're very,
very happy, and we're done

00:23:30.743 --> 00:23:32.940
and you don't have to
worry about rescheduling.

00:23:32.940 --> 00:23:34.545
Unless you failed at your job.

00:23:34.545 --> 00:23:35.920
Maybe like the
network connection

00:23:35.920 --> 00:23:37.940
fell through or something
on your server's end.

00:23:37.940 --> 00:23:39.745
So that's what that
Boolean here means.

00:23:42.432 --> 00:23:44.140
True means we need to
reschedule the job,

00:23:44.140 --> 00:23:46.340
and false means that we're good.

00:23:46.340 --> 00:23:49.230
And when we're rescheduling
true will kick off.

00:23:49.230 --> 00:23:51.606
JobScheduler has a built in
exponential back off for you.

00:23:51.606 --> 00:23:53.063
You don't have to
do that math, you

00:23:53.063 --> 00:23:55.540
don't have to keep track
of when you want to retry.

00:23:55.540 --> 00:23:57.590
We'll do that intelligently
on your behalf.

00:23:57.590 --> 00:23:59.131
We just know that
you didn't succeed,

00:23:59.131 --> 00:24:01.920
and you want to try again,
and so we'll reschedule you.

00:24:01.920 --> 00:24:03.354
Look how helpful we are.

00:24:03.354 --> 00:24:05.520
I have talked about "we"
like I didn't work on this,

00:24:05.520 --> 00:24:07.450
I know how to use it.

00:24:07.450 --> 00:24:09.480
You need to register
your service, as usual,

00:24:09.480 --> 00:24:11.850
but you also need to
bind to the job service.

00:24:11.850 --> 00:24:13.470
And so yet another
permission that's

00:24:13.470 --> 00:24:16.650
nested in with our declaration.

00:24:16.650 --> 00:24:19.180
And finally you
create the scheduler.

00:24:19.180 --> 00:24:21.220
So this is going to be
probably in an activity

00:24:21.220 --> 00:24:23.410
where you're keeping
track of everything.

00:24:23.410 --> 00:24:25.600
And there's a couple
of pieces here.

00:24:25.600 --> 00:24:27.450
So second bit of this
is the JobScheduler

00:24:27.450 --> 00:24:29.408
we're just fetching that
from the system again.

00:24:29.408 --> 00:24:30.040
Very easy.

00:24:30.040 --> 00:24:32.510
And then we create
a JobInfo object,

00:24:32.510 --> 00:24:34.582
and that needs some
sort of ID for the jobs

00:24:34.582 --> 00:24:36.290
that your activity
knows what's going on.

00:24:36.290 --> 00:24:38.270
But also, the name
of the service.

00:24:38.270 --> 00:24:40.770
So for the first time, we're
not using an intent to rely on,

00:24:40.770 --> 00:24:42.370
we're just using the class name.

00:24:42.370 --> 00:24:44.879
Which we get from the
component name class.

00:24:44.879 --> 00:24:46.670
And then all the
conditions you care about,

00:24:46.670 --> 00:24:48.336
and I'll touch on
that in just a minute.

00:24:48.336 --> 00:24:50.350
And then you just call
scheduler, schedule.

00:24:50.350 --> 00:24:52.820
With your JobInfo
Very, very easy.

00:24:52.820 --> 00:24:54.860
So the hard part
is with JobInfo,

00:24:54.860 --> 00:24:58.540
and these are just some of
the offers JobInfo offers.

00:24:58.540 --> 00:25:00.290
I told you, you could
decide you only care

00:25:00.290 --> 00:25:01.410
about certain
criteria, and this is

00:25:01.410 --> 00:25:03.360
where you can set all
of those criteria, when

00:25:03.360 --> 00:25:06.659
you're worried about your job.

00:25:06.659 --> 00:25:08.200
A couple of these
are pretty obvious,

00:25:08.200 --> 00:25:10.290
like you can create your own
back off and retry policy,

00:25:10.290 --> 00:25:12.960
and that'll be used when we're
rescheduling your job for you.

00:25:12.960 --> 00:25:16.540
You can create a minimum
delay before your job is run.

00:25:16.540 --> 00:25:19.580
So if you say I want to do
this whenever Wi-Fi is on,

00:25:19.580 --> 00:25:22.386
but I don't want to do it until
at least six hours from now.

00:25:22.386 --> 00:25:24.760
That can be really helpful,
especially if you're managing

00:25:24.760 --> 00:25:27.140
traffic with your server.

00:25:27.140 --> 00:25:29.070
We have an override
deadline, so that's

00:25:29.070 --> 00:25:30.960
the maximum amount of
time that could pass

00:25:30.960 --> 00:25:33.210
before your job must be run.

00:25:33.210 --> 00:25:34.772
That's really
helpful, too, if you

00:25:34.772 --> 00:25:36.730
know that you have to
get something done today,

00:25:36.730 --> 00:25:39.610
and it's going to hit
midnight or whatever.

00:25:39.610 --> 00:25:41.910
Persistent indicates that
you want to persist this job

00:25:41.910 --> 00:25:43.632
request across a reboot.

00:25:43.632 --> 00:25:46.090
A lot of times when your app
is started for the first time,

00:25:46.090 --> 00:25:47.870
then you might
change your behavior,

00:25:47.870 --> 00:25:51.534
but if you know that you
need this after the reboot,

00:25:51.534 --> 00:25:52.950
that's a great way
to indicate it.

00:25:52.950 --> 00:25:54.260
Then we have connectivity
requirements.

00:25:54.260 --> 00:25:57.010
It could be you're waiting for
any network, metered or not.

00:25:57.010 --> 00:25:59.599
Or maybe you're just waiting
for Wi-Fi specifically.

00:25:59.599 --> 00:26:01.390
You've got some constants
in the class that

00:26:01.390 --> 00:26:02.860
will help you specify that.

00:26:02.860 --> 00:26:04.640
And of course
charging, and/or idle.

00:26:04.640 --> 00:26:07.600
Idle indicating that the
screen is off, usually.

00:26:11.110 --> 00:26:12.970
This is the magic
of JobScheduler.

00:26:12.970 --> 00:26:15.700
This is like where
it really happens.

00:26:15.700 --> 00:26:19.190
And then we have this
hypothetical situation

00:26:19.190 --> 00:26:20.920
of do I just use one?

00:26:20.920 --> 00:26:24.310
And I would say, no.

00:26:24.310 --> 00:26:27.369
So what if you have a situation
where a user presses a share

00:26:27.369 --> 00:26:28.910
button, that stops
your IntentService

00:26:28.910 --> 00:26:30.540
because a share probably needs
to happen right away that's

00:26:30.540 --> 00:26:31.570
user initiated.

00:26:31.570 --> 00:26:34.585
But you're not actually online
for some reason, maybe it's

00:26:34.585 --> 00:26:37.024
a bad connection, or maybe
you can't really [INAUDIBLE].

00:26:37.024 --> 00:26:38.690
So you could then use
your IntentService

00:26:38.690 --> 00:26:41.749
to schedule a job schedule, like
a job service for you, right?

00:26:41.749 --> 00:26:43.790
And then that way you
don't have to worry, again,

00:26:43.790 --> 00:26:46.730
about keeping track
of your own back off

00:26:46.730 --> 00:26:49.620
or your own retry you don't have
to worry about what's going on.

00:26:49.620 --> 00:26:51.100
You can just be
like, OK I failed

00:26:51.100 --> 00:26:52.025
when I tried to
do it immediately,

00:26:52.025 --> 00:26:53.450
the user probably wont
notice since they're not

00:26:53.450 --> 00:26:54.408
on the internet anyway.

00:26:54.408 --> 00:26:55.871
So just schedule this for later.

00:26:55.871 --> 00:26:57.370
And this is one of
those things that

00:26:57.370 --> 00:27:00.970
are-- it's hard to teach, how
do you teach someone to consider

00:27:00.970 --> 00:27:03.010
multiple different
resources to build

00:27:03.010 --> 00:27:04.850
the best possible behavior?

00:27:04.850 --> 00:27:08.076
This is one that I was
talking about my talk,

00:27:08.076 --> 00:27:09.450
and Ian was like,
well, you know,

00:27:09.450 --> 00:27:10.610
you should tell them
about like fun things.

00:27:10.610 --> 00:27:12.020
Well I didn't even
think of that.

00:27:12.020 --> 00:27:13.650
How do I stand up here and
teach people if I can't even

00:27:13.650 --> 00:27:14.840
think of all these things?

00:27:14.840 --> 00:27:16.590
And so it is hard, and
that's why I really

00:27:16.590 --> 00:27:18.300
like when people share
about [INAUDIBLE].

00:27:18.300 --> 00:27:19.890
Because this would be a
great situation and it

00:27:19.890 --> 00:27:21.270
makes things so much
easier for the developer.

00:27:21.270 --> 00:27:22.770
You can use these
kinds of services,

00:27:22.770 --> 00:27:24.430
not just take work
off the main thread,

00:27:24.430 --> 00:27:26.600
but also to make it
so you don't have

00:27:26.600 --> 00:27:29.180
to build your own logic
that's been built 17,000 times

00:27:29.180 --> 00:27:31.300
already.

00:27:31.300 --> 00:27:34.030
OK, so trying to teach you
how to build better apps,

00:27:34.030 --> 00:27:36.060
and also how to
not work very hard.

00:27:36.060 --> 00:27:38.264
This is going to be really
successful, you guys.

00:27:38.264 --> 00:27:39.680
The final point I
want to touch on

00:27:39.680 --> 00:27:41.450
is what about the actual alarms?

00:27:41.450 --> 00:27:43.200
Like those ones that
go "ding, ding, ding"

00:27:43.200 --> 00:27:45.242
and wake you up from your nap.

00:27:45.242 --> 00:27:46.950
If AlarmManager manages
the other alarms,

00:27:46.950 --> 00:27:48.210
how do you actually
schedule these?

00:27:48.210 --> 00:27:49.627
Those seem really
important, do I

00:27:49.627 --> 00:27:51.560
have to issue my own
sound notification

00:27:51.560 --> 00:27:54.330
or something, every time
my AlarmManager goes off?

00:27:54.330 --> 00:27:55.600
The thing is, no, you don't.

00:27:55.600 --> 00:28:00.670
Because AlarmManager has this
super helpful set alarm clock

00:28:00.670 --> 00:28:01.172
method.

00:28:01.172 --> 00:28:03.380
And then of course, you can
get the next alarm clock.

00:28:03.380 --> 00:28:06.720
But that's introduced
in 21, clearly,

00:28:06.720 --> 00:28:08.790
since I wrote that on the thing.

00:28:08.790 --> 00:28:12.837
So what's special about these
methods is they were introduced

00:28:12.837 --> 00:28:13.670
relatively recently.

00:28:13.670 --> 00:28:19.030
And also these are exempt
from any kind of doze mode,

00:28:19.030 --> 00:28:21.490
or standby, idle mode
that we've introduced.

00:28:21.490 --> 00:28:23.730
Because alarm clocks are
incredibly important.

00:28:23.730 --> 00:28:25.370
The user probably
relies on those

00:28:25.370 --> 00:28:27.280
for getting to work on time.

00:28:27.280 --> 00:28:32.420
And so what's really
cool about setalarmclock

00:28:32.420 --> 00:28:36.210
is that if you set that
alarm, let's say for like 6:30

00:28:36.210 --> 00:28:39.250
in the morning, and
you're in doze mode

00:28:39.250 --> 00:28:41.710
because you've had to charge
your phone over night.

00:28:41.710 --> 00:28:43.460
Those mode will exit
well before 6:30

00:28:43.460 --> 00:28:45.320
to give every app a
chance to run and sync,

00:28:45.320 --> 00:28:47.220
so when the user finally
hears that noise and wakes up

00:28:47.220 --> 00:28:48.719
and checks their
phone, everything's

00:28:48.719 --> 00:28:50.150
ready-- the news
is already there.

00:28:50.150 --> 00:28:52.580
So I think that that's a
really cool build around.

00:28:52.580 --> 00:28:54.440
So you can definitely
rely on these.

00:28:54.440 --> 00:28:57.330
If you're using, if
you're not quite to 21,

00:28:57.330 --> 00:29:02.890
but you're on KitKat, you
can just call setupexact

00:29:02.890 --> 00:29:04.390
because we're not
worried about doze

00:29:04.390 --> 00:29:06.210
because you're on
an older phone.

00:29:06.210 --> 00:29:07.717
But you know exactly
that this time

00:29:07.717 --> 00:29:09.800
is going to happen because
setexact will be on it.

00:29:09.800 --> 00:29:11.810
And then finally,
for before KitKat,

00:29:11.810 --> 00:29:14.400
you can just use set
directly because we

00:29:14.400 --> 00:29:16.700
didn't introduce inexact
timing until after that.

00:29:16.700 --> 00:29:21.980
And so that's how you would
cover actual important alarms.

00:29:21.980 --> 00:29:23.579
And that's my whole talk.

00:29:23.579 --> 00:29:25.370
Other things you probably
want to look into

00:29:25.370 --> 00:29:28.890
are sync adapters, which
will help you manage data

00:29:28.890 --> 00:29:30.150
programmatically on your own.

00:29:30.150 --> 00:29:32.062
And also we have GCM's
networks manager.

00:29:32.062 --> 00:29:33.520
So if you want to
look at something

00:29:33.520 --> 00:29:36.360
similar to JobScheduler, but
is a little bit more targeted,

00:29:36.360 --> 00:29:38.430
you should read
that documentation.

00:29:38.430 --> 00:29:40.610
But hey, now you're all
JobScheduler pros, right?

00:29:40.610 --> 00:29:42.920
You could totally do
this on your own, right?

00:29:42.920 --> 00:29:45.062
Right?

00:29:45.062 --> 00:29:46.270
That's not very enthusiastic.

00:29:46.270 --> 00:29:47.560
Thank you, Alex!

00:29:47.560 --> 00:29:48.410
OK, cool.

00:29:48.410 --> 00:29:50.910
This is how you can find me on
Google+ and on Twitter if you

00:29:50.910 --> 00:29:52.868
have any questions always
feel free to call me.

00:29:52.868 --> 00:29:54.624
I will honestly try
to respond to them.

00:29:54.624 --> 00:29:56.790
I'm bad at social networking,
but I'm working on it.

00:29:56.790 --> 00:29:58.492
And I will be
mingling in this room

00:29:58.492 --> 00:30:00.700
if you have any other
questions about how to do this.

00:30:00.700 --> 00:30:02.910
But hopefully you're not scared
of background jobs and services

00:30:02.910 --> 00:30:04.030
the way I was last year.

00:30:04.030 --> 00:30:08.530
[APPLAUSE]

00:30:08.530 --> 00:30:10.080
[MUSIC PLAYING]

