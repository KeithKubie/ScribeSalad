WEBVTT
Kind: captions
Language: en

00:00:02.840 --> 00:00:04.265
 Batch payment, batch! 

00:00:04.265 --> 00:00:07.499
 It's really all you hear network specialists talking about nowadays 

00:00:07.679 --> 00:00:09.648
 Almost as if they were trying to say something to you 

00:00:09.703 --> 00:00:12.617
 My name is Colt McCannless, and the fact that they are 

00:00:13.084 --> 00:00:15.197
 We all know that networking is the biggest criminal 

00:00:15.198 --> 00:00:17.740
 When it comes to battery drain on mobile devices 

00:00:17.750 --> 00:00:20.506
 I mean, take into account the waves of broadcast on any of your phones 

00:00:20.730 --> 00:00:24.790
 After a request, it will wait for an additional time of about 20 to 60 seconds 

00:00:24.790 --> 00:00:28.756
 Keeps the chip shaky, drains the power in case of a server response only 

00:00:28.920 --> 00:00:31.656
 If nothing is returned, only then will it move to sleep mode 

00:00:31.732 --> 00:00:34.792
 In the worst case scenario, your application can end up in a position 

00:00:34.800 --> 00:00:38.093
 Each of the network requests activates cellular transmission waves 

00:00:38.094 --> 00:00:40.527
 It pays to keep it active over time 

00:00:40.761 --> 00:00:44.289
 Assembly is the best way to link these requests together 

00:00:44.289 --> 00:00:47.162
 So that you only have to pay the cost of activation and keep the device active once 

00:00:47.310 --> 00:00:51.359
 But the big question here is, how will you actually assemble? 

00:00:51.560 --> 00:00:55.510
 Well, first understand that any requests created as a result of a user's work 

00:00:55.559 --> 00:00:57.629
 Generally need to be processed now 

00:00:57.701 --> 00:01:00.320
 Everything else though, is quite a game of justice 

00:01:00.321 --> 00:01:03.550
 Basically, if there is even a slight chance that the request will be delayed 

00:01:03.605 --> 00:01:06.000
 It will not cause users to throw their phones out of the window 

00:01:06.000 --> 00:01:07.534
 Then you have to think about it 

00:01:07.710 --> 00:01:10.842
 Now from the code point of view, it is the easiest way to implement the assembly 

00:01:10.858 --> 00:01:13.356
 Are essentially intercepting applications 

00:01:13.548 --> 00:01:15.650
 Rather than immediately implemented 

00:01:15.778 --> 00:01:19.677
 We store them in a queue of actions to be implemented in the future 

00:01:19.802 --> 00:01:24.808
 This can be as simple as a Queue object or as complex as a content provider 

00:01:24.875 --> 00:01:26.523
 To transform them into a sequential form to disk 

00:01:26.563 --> 00:01:29.518
 In case you are worried about losing them when the application is terminated 

00:01:29.610 --> 00:01:30.774
 But here's the hard part 

00:01:30.923 --> 00:01:34.060
 How do we know when to send these pending orders? 

00:01:34.060 --> 00:01:36.773
 Well, you can wait until you reach a minimum 

00:01:36.813 --> 00:01:41.210
 Such as 10 requests or anything and then launch your list Activate broadcast waves from dormancy and send data 

00:01:41.210 --> 00:01:43.808
 It is a very accurate way to address the problem 

00:01:43.970 --> 00:01:47.482
 But the truth is that the system does a lot of other things in the background 

00:01:47.512 --> 00:01:50.011
 Before reaching the threshold point 

00:01:50.210 --> 00:01:53.767
 Cell broadcast waves will be activated to complete some other tasks 

00:01:54.000 --> 00:01:58.540
 Therefore, it is very logical to try and carry out these operations when they occur 

00:01:58.540 --> 00:02:01.603
 Basically, you can set up this code to give the application a reverse call 

00:02:01.604 --> 00:02:03.618
 Any time the network devices are turned on 

00:02:03.770 --> 00:02:06.134
 When that happens, go ahead and launch the waiting line. 

00:02:06.340 --> 00:02:08.869
 But things may become a bit more complicated 

00:02:08.869 --> 00:02:10.910
 What if you want to wait until you connect to a Wi-Fi network 

00:02:10.911 --> 00:02:12.347
 Or connect it to a power source? 

00:02:12.415 --> 00:02:13.440
 Or something crazy, 

00:02:13.480 --> 00:02:16.801
 Such as you want to wait until the user is not riding a bike or not in a car anymore 

00:02:17.160 --> 00:02:20.800
 This is exactly why you need to use a GCM network administrator 

00:02:20.970 --> 00:02:25.660
 This is the Google Store Services API which helps to schedule network oriented tasks 

00:02:25.660 --> 00:02:27.410
 And handle the assembly for you. 

00:02:27.410 --> 00:02:30.443
 This greatly simplifies the implementation of common patterns 

00:02:30.546 --> 00:02:34.288
 Such as waiting for connection and networking, retrying network attempts and retreating. 

00:02:34.437 --> 00:02:38.291
 Basically, all the good things you need with one useful API 

00:02:38.502 --> 00:02:40.856
 Now, if you do not know what the profile looks like for your application 

00:02:40.880 --> 00:02:42.270
 Or you are at a bad point 

00:02:42.445 --> 00:02:45.670
 Check out the Network Monitor tool within the Android Studio 

00:02:45.670 --> 00:02:49.770
 This tool will help you to know how many times incoming and outgoing requests occur 

00:02:49.770 --> 00:02:51.631
 The size of each request 

00:02:51.980 --> 00:02:53.926
 Assembly is one of the basic techniques 

00:02:53.950 --> 00:02:56.227
 Which can improve the performance of your applications to users 

00:02:56.450 --> 00:02:59.013
 But it is not the only networking technology you need to know 

00:02:59.027 --> 00:03:02.522
 This is why you need to check the rest of the content of Android performance patterns 

00:03:02.548 --> 00:03:05.473
 Do not forget to join our community on Google+ as well 

00:03:05.647 --> 00:03:09.310
 So stay calm, type your code, and always remember, performance is important. 

