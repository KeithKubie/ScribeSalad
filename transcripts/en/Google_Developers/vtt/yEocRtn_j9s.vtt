WEBVTT
Kind: captions
Language: en

00:00:02.860 --> 00:00:05.259
&gt;&gt;Seth Ladd: Okay. I think we're going to
get started here.

00:00:05.259 --> 00:00:08.930
First, thanks everyone for your time. Definitely
after lunch we'll try to keep you energized

00:00:08.930 --> 00:00:13.759
and motivated here.
So this is Super Browser 2 Turbo HD Remix:

00:00:13.759 --> 00:00:20.180
An Introduction to HTML5 Game Development.
My name is Seth Ladd. I'm a developer advocate

00:00:20.180 --> 00:00:23.980
with Google. That means we work with partners
of all different sizes, helping them get up

00:00:23.980 --> 00:00:28.180
and running on Chrome, HTML5, and the Open
Web Platform.

00:00:28.180 --> 00:00:33.460
I focus on games, and so this is a topic very
near and dear to my heart.

00:00:33.460 --> 00:00:38.120
Certainly reach out to me online, either Twitter,
my blog, or definitely at the show after this

00:00:38.120 --> 00:00:42.120
session or around. I'll be in the Chrome sandbox
area. Love to hear your stories about what

00:00:42.120 --> 00:00:45.329
you're doing with HTML5 and games, so definitely
reach out. I'd love to chat with you.

00:00:45.329 --> 00:00:50.440
Also, after this session, we will be running
a Google Moderator. This link is up here.

00:00:50.440 --> 00:00:54.910
This also works for everyone at home as well.
So we'll run through the top moderated questions

00:00:54.910 --> 00:00:59.990
as well as like live questions from the audience.
I want to get started, though, with a quick

00:00:59.990 --> 00:01:04.339
little story. I want to take you back to 1993.
My buddies and are down in the basement playing

00:01:04.339 --> 00:01:08.510
Dungeons &amp; Dragons, drinking a lot of Mountain
Dew. You know, good times. Typical Friday

00:01:08.510 --> 00:01:09.510
night.
And so he asks, "Hey, do you have a modem?"

00:01:09.510 --> 00:01:14.460
I said, "Yeah, I do. We totally have a modem."
So we all run upstairs. He says, "I'm going

00:01:14.460 --> 00:01:17.100
to download this awesome game for you."
So we said, "Okay."

00:01:17.100 --> 00:01:21.850
So we run upstairs and we yell down, "Don't
pick up the phone," which is how you got on

00:01:21.850 --> 00:01:26.000
the Internet back in those days.
And so after a couple hours, we ran back upstairs

00:01:26.000 --> 00:01:28.799
and we -- he unzipped and he says, "Get ready.
Check this out."

00:01:28.799 --> 00:01:35.220
And what game is it? But it's Doom. Doom?
Yes. Doom defined the first-person shooter

00:01:35.220 --> 00:01:39.530
genre. This game totally blew us away. We
stayed up all night playing this game. It

00:01:39.530 --> 00:01:43.780
was our first all nighter for games, and so
our Dungeons &amp; Dragons meet-ups turned into

00:01:43.780 --> 00:01:48.990
LAN parties. It was really a lot of fun.
I went home, bought all the different levels,

00:01:48.990 --> 00:01:52.740
upgraded my machine, bought everything it
ever made. I mean this was really, really

00:01:52.740 --> 00:01:57.120
-- this was an impactful moment for gaming.
Especially for me and my friends.

00:01:57.120 --> 00:02:00.540
So what can that little story kind of story
us and set us up for the talk?

00:02:00.540 --> 00:02:05.810
Well, certainly you could see there with even
with BBSs back in those days, digital distribution

00:02:05.810 --> 00:02:09.940
is key.
EA's CEO just recently said, "Virtually everything

00:02:09.940 --> 00:02:13.290
we're doing now is against the digital opportunity.
It's where we see our growth."

00:02:13.290 --> 00:02:17.690
So even BBSs back then, and the web today,
just click and play, digital distribution

00:02:17.690 --> 00:02:21.890
is awesome.
As you heard, I bought everything ID ever

00:02:21.890 --> 00:02:25.819
made, all the Quake episodes, all the Doom
episodes, shareware, got really into it.

00:02:25.819 --> 00:02:31.670
Gamers spend money. For instance, just a recent
report here, "U.S. virtual goods market will

00:02:31.670 --> 00:02:36.099
reach 2.1 billion overall in 2011." And this
is just virtual goods.

00:02:36.099 --> 00:02:41.170
Games monetize in a variety of different ways.
In-app subscriptions, micro-trends, virtual

00:02:41.170 --> 00:02:46.340
goods. So gamers spend money.
As I'm sure many of you also have, you've

00:02:46.340 --> 00:02:52.840
upgraded your video cards, your CPUs, et cetera.
Gamers upgrade. You upgrade your console systems,

00:02:52.840 --> 00:02:56.740
and I believe that this trend continues onto
the web today where gamers will upgrade their

00:02:56.740 --> 00:03:00.840
browsers. And so I want to encourage all of
us to think of it that way as we build our

00:03:00.840 --> 00:03:05.849
great HTML5 games. Users will come to you
if your game is awesome.

00:03:05.849 --> 00:03:10.269
But probably the most important part is games
create emotional responses, really emotional

00:03:10.269 --> 00:03:13.790
memories, and I still have that feeling of
staying up all night with all my buddies playing

00:03:13.790 --> 00:03:17.910
all the game all the way through, totally
amazed, you know, bloodshot in the morning.

00:03:17.910 --> 00:03:22.000
This was a really good feeling. I'm sure many
of you also remember that time you beat that

00:03:22.000 --> 00:03:27.050
level after 150 different tries, or you finally
beat that arcade game with your friend. I

00:03:27.050 --> 00:03:31.110
mean, these are really powerful emotional
responses and that's something you want to

00:03:31.110 --> 00:03:36.670
capitalize on when you add games into your
toolkit for your products and services.

00:03:36.670 --> 00:03:39.569
So what are we up to today? Well, we're going
to learn how to build a simple HTML5 game,

00:03:39.569 --> 00:03:44.660
so we're going to teach you the tools to add
game development into your toolkit so that

00:03:44.660 --> 00:03:49.450
you can create happy and engaged users.
But really, we're going to blow up some aliens.

00:03:49.450 --> 00:03:54.180
So remember this is a 101 talk so this is
targeted towards the JavaScript developer,

00:03:54.180 --> 00:03:57.140
the web developer. Maybe you know some jQuery,
maybe you've built some interactive websites,

00:03:57.140 --> 00:04:01.120
you've probably maybe built an app or two,
but you've never done any game development.

00:04:01.120 --> 00:04:05.140
This is the talk from you. We're going to
zero from hero, from start to finish, all

00:04:05.140 --> 00:04:10.659
the way through in about 45, 50 minutes.
So let's get started. Let's build a game.

00:04:10.659 --> 00:04:14.159
The game we're going to build from start to
finish is this little gem I whipped up here

00:04:14.159 --> 00:04:21.400
called Bad Aliens. Aliens are coming in, attacking
our ship -- or our planet -- and if we had

00:04:21.400 --> 00:04:29.309
audio -- yeah? No? Okay. Well, really cool
audio. (Sounds) That's more like it. Excellent.

00:04:29.309 --> 00:04:35.589
Then we're going to do this from beginning
to finish.

00:04:35.589 --> 00:04:38.219
So it's a fairly straightforward game, kind
of simple here, but there's a lot of moving

00:04:38.219 --> 00:04:43.009
parts, so let's break it down here. Throughout
today's talk, we're going to build the space

00:04:43.009 --> 00:04:47.180
using canvas. We're going to figure out how
to draw images like the aliens and the explosions.

00:04:47.180 --> 00:04:50.900
We're going to add movement and animations.
We're going to set up our correct timing in

00:04:50.900 --> 00:04:55.669
the game. We're going to have image rotation.
We're going to reduce work by using off-scheme

00:04:55.669 --> 00:05:00.740
canvases, turret and mouse tracking with input
control, shooting, lasers, exploding with

00:05:00.740 --> 00:05:05.800
animation, including detection, sounds, of
course, score keeping. We're going to figure

00:05:05.800 --> 00:05:08.949
out how to monitor the performance. And we're
going to make the whole game work offline

00:05:08.949 --> 00:05:13.069
and we're going to start that right now.
Our first object here is to bootstrap the

00:05:13.069 --> 00:05:14.520
game. We're going to do that by employing
HTML5 canvas.

00:05:14.520 --> 00:05:20.970
Canvas is a 2D drawing surface. You can think
of it like a bitmap surface. It's an immediate

00:05:20.970 --> 00:05:24.259
mode drawing surface. That means everything
that you draw into the canvas immediately

00:05:24.259 --> 00:05:26.740
is applied.
You can think of it like you have a paintbrush

00:05:26.740 --> 00:05:31.029
and you paint on a piece of paper. That paint
is there. You can't get that off.

00:05:31.029 --> 00:05:35.169
Contrast this a little bit with something
like SVG, where SVG is more DOM based and

00:05:35.169 --> 00:05:39.199
you can, you know, manipulate the nodes in
SVG and it will kind of reapply itself. But

00:05:39.199 --> 00:05:44.490
canvas is immediate mode.
Canvas has primitive APIs -- or APIs for primitives

00:05:44.490 --> 00:05:50.119
like lines, arcs, gradients, and the one we're
going to use a lot in this game where you

00:05:50.119 --> 00:05:55.370
can draw images straight onto canvas. Canvas
also supports transformation and scaling where

00:05:55.370 --> 00:06:00.039
you can manipulate the coordinate space and
the coordinate system directly on the canvas

00:06:00.039 --> 00:06:02.599
as well.
It's important to point out that canvas is

00:06:02.599 --> 00:06:07.689
being hardware accelerated in modern browsers
and this will continue, and so this is very

00:06:07.689 --> 00:06:11.550
good for performance for HTML5 games.
And you're probably wondering well, what about

00:06:11.550 --> 00:06:17.729
WebGL? WebGL is a 3D context so that's native
3D into your browser. It's essentially OpenGL

00:06:17.729 --> 00:06:24.189
ES 2.0, all driven by JavaScript.
WebGL is very important, especially for gaming,

00:06:24.189 --> 00:06:28.309
and it's a little complex for the normal JavaScript
developer and so you'll see APIs beginning

00:06:28.309 --> 00:06:33.279
to appear that can raise the abstraction level,
make it a little bit more approachable. You'll

00:06:33.279 --> 00:06:38.240
see WebGL being very important for 2D as well
as 3D games, but for today, we're going to

00:06:38.240 --> 00:06:41.949
focus on canvas.
So the canvas code, very simple. We have a

00:06:41.949 --> 00:06:46.409
simple HTML5 document here and we just declare
that canvas is an element in our document

00:06:46.409 --> 00:06:49.839
and set the width and height and that's all
we need to have a hundred percent or more

00:06:49.839 --> 00:06:53.279
void of space. Doesn't look like much but
we got to start somewhere.

00:06:53.279 --> 00:06:57.099
So next, now that we have space, we want to
figure out how do we render images on here.

00:06:57.099 --> 00:07:01.301
Well, we're going to draw images directly
onto the canvas. We also want to make sure

00:07:01.301 --> 00:07:05.939
that we load all these assets and images before
we start the game. As you know, images come

00:07:05.939 --> 00:07:10.099
in essentially asynchronously or in parallel
so we want to queue them all up and download

00:07:10.099 --> 00:07:14.869
them, wait for them, and then start.
As you notice, the planet is in the center

00:07:14.869 --> 00:07:20.009
of the screen. We need to figure out how to
draw that planet square in the center there,

00:07:20.009 --> 00:07:24.050
so we're going to introduce an asset manager.
An asset manager queues up the downloads,

00:07:24.050 --> 00:07:28.589
he waits for them all to finish or error out,
and then signals that our game will start.

00:07:28.589 --> 00:07:32.129
To draw images, we're going to use canvas'
draw image call, which takes one of those

00:07:32.129 --> 00:07:35.839
images we download in an XY coordinate and
will draw it straight onto the canvas.

00:07:35.839 --> 00:07:40.110
It's important to understand that this X and
Y from canvas' perspective is the upper left

00:07:40.110 --> 00:07:44.430
of that image, and as you saw here, everything
needs to be centered around that point, and

00:07:44.430 --> 00:07:47.939
we'll show you how to do the offsets.
And then because the planet is in the center

00:07:47.939 --> 00:07:52.400
of the screen, to make our lives a lot easier,
we're going to use canvas' translate to move

00:07:52.400 --> 00:07:55.759
that coordinate system.
So looking at the asset management code, this

00:07:55.759 --> 00:07:59.559
is really straightforward stuff, but we're
going to be able to queue up the downloads

00:07:59.559 --> 00:08:03.270
and we're going to be able to ask the asset
manager, "Is it done." I mean, it just asks

00:08:03.270 --> 00:08:07.789
did everything either error out or succeed.
When we're ready to go ahead and kick off

00:08:07.789 --> 00:08:11.739
all the downloads, it just loops through all
of our entities, sets up the appropriate success

00:08:11.739 --> 00:08:16.020
and failure callbacks, and then here in the
highlighted code, we increment our counters

00:08:16.020 --> 00:08:19.860
and then we can check after every callback,
are we actually done now, and if so, let's

00:08:19.860 --> 00:08:24.300
fire off the game.
Now, as I mentioned, the -- we want to move

00:08:24.300 --> 00:08:27.709
that planet into the center.
Now, canvas, by default, has zero zero in

00:08:27.709 --> 00:08:32.919
the upper left. This is its -- this is his
canvas default orientation. But we want it

00:08:32.919 --> 00:08:35.440
right in the center, because as you can see
everything is kind of coming in towards the

00:08:35.440 --> 00:08:38.829
center, so to make our lives more easier and
to think about the game playing more like

00:08:38.829 --> 00:08:43.527
a cartesian plain, where zero zero is in the
center, we need to move that.

00:08:43.527 --> 00:08:47.010
Canvas translation to the rescue. You can
see a sample image here I got from the great

00:08:47.010 --> 00:08:52.310
MDC website. We're going to use an offset
that actually moves that zero zero point down

00:08:52.310 --> 00:08:56.269
for us.
So putting it all together in asset manager,

00:08:56.269 --> 00:08:59.660
we're going to ask it to queue up the download,
and then when we're ready, say "Download all

00:08:59.660 --> 00:09:03.050
and give it a callback."
When download all succeeds, we're going go

00:09:03.050 --> 00:09:07.230
get that asset from asset manager, we're going
to translate our coordinate system here, you

00:09:07.230 --> 00:09:11.360
can see, where you just essentially take canvas'
width and height divided by 2 and that moves

00:09:11.360 --> 00:09:14.990
us right into the center. That's zero zero
now. And then we're going to draw the image.

00:09:14.990 --> 00:09:19.110
Now, we want the planet at zero zero, but
remember canvas draws images from the upper

00:09:19.110 --> 00:09:23.100
left, so that's the further offset here where
you take these sprites' width and height divided

00:09:23.100 --> 00:09:27.600
by 2, and then as we see here, planet is smack-dab
in the middle.

00:09:27.600 --> 00:09:31.540
So now we have a coordinate system, we're
drawing images to the screen, and we have

00:09:31.540 --> 00:09:35.370
asset management.
Our next objective here is flying aliens.

00:09:35.370 --> 00:09:38.970
This implies a couple things. Now that we're
going to add in a lot of different assets

00:09:38.970 --> 00:09:41.829
into the game -- or sorry, entities -- we
need a game engine to manage all these things.

00:09:41.829 --> 00:09:45.709
So we're going to add in a formal game engine
and we're going to formalize the concept of

00:09:45.709 --> 00:09:50.779
an entity. This also implies that aliens are
moving around the screen and we need to calculate

00:09:50.779 --> 00:09:54.570
things like velocity and animate them so it
appears like they're moving. So we need some

00:09:54.570 --> 00:09:59.209
sort of loop. And a game engine or even simple
game code like this, when you boil it all

00:09:59.209 --> 00:10:03.759
down, you have a simple loop of update and
draw. Update draw, update draw, as fast as

00:10:03.759 --> 00:10:08.569
we can. That is, up to 60 frames a second.
Update loops through all the entities in your

00:10:08.569 --> 00:10:13.010
system and updates their state, and draw loops
through all the entities in the system and

00:10:13.010 --> 00:10:16.360
draws them onto your screen.
So as JavaScript developers, you're all probably

00:10:16.360 --> 00:10:18.720
saying, "Oh, yeah. No problem. We have set
time-out, set interval."

00:10:18.720 --> 00:10:23.170
In fact, this is not what you want to do.
If you use these methods, you are not conveying

00:10:23.170 --> 00:10:27.329
your intent clearly to the browser and the
browser does not know how to help you.

00:10:27.329 --> 00:10:33.450
For instance, your element moves off screen,
scrolls off, or becomes hidden behind a tab,

00:10:33.450 --> 00:10:37.620
the browser has no idea that, oh, what you're
trying to do is efficiently and effectively

00:10:37.620 --> 00:10:40.690
animate, and the browser doesn't know how
to integrate your code directly into the render

00:10:40.690 --> 00:10:42.860
loop.
The browser manufacturers understood this

00:10:42.860 --> 00:10:47.089
problem and introduced a new method called
request animation frame. This integrates you

00:10:47.089 --> 00:10:51.709
directly into the browser's render loop and
the browser can now help you optimize. For

00:10:51.709 --> 00:10:56.149
instance, if that tab, playing your game,
goes behind the curtains, if you will, the

00:10:56.149 --> 00:11:00.209
browser can now pause the game, which is good
because the loop stops, you save battery and

00:11:00.209 --> 00:11:05.779
you save CPU. This is all good.
So looking at the code here, our simple game

00:11:05.779 --> 00:11:10.259
engine simply manages a collection of entities
and we have a master draw and we have a master

00:11:10.259 --> 00:11:14.700
update loop and they just loop through the
entities and call the same method.

00:11:14.700 --> 00:11:19.339
Inside the game loop, this is the function
that's actually called up to 60 times a second.

00:11:19.339 --> 00:11:24.399
We have the update and the draw call in that
order and we also create a couple times -- time

00:11:24.399 --> 00:11:27.540
deltas here so we understand how to calculate
things like velocity.

00:11:27.540 --> 00:11:32.470
Then to start all this loop, we have a game
engine that's start. We have a nice little

00:11:32.470 --> 00:11:36.779
inner function here that actually calls loop
and then calls again request animation frame.

00:11:36.779 --> 00:11:41.850
So this here highlights that every time you
want to ask the browser to draw for you or

00:11:41.850 --> 00:11:46.139
to be signaled when to draw, you have to ask
it again and again and again. So that's why

00:11:46.139 --> 00:11:51.009
at the end of the loop here we reask to be
integrated in with request animation frame.

00:11:51.009 --> 00:11:56.730
A quick note, really another benefit of request
animation frame, is that browser -- I'm sorry,

00:11:56.730 --> 00:12:01.110
laptop displays, your monitors at home, they're
all running at 60 hertz, 60 frames a second.

00:12:01.110 --> 00:12:05.050
Trying to do any work above and beyond that
is actually just waste of CPU, especially

00:12:05.050 --> 00:12:09.790
for your draw cycles. And so request animation
frame knows this and will try to sync up with

00:12:09.790 --> 00:12:14.490
that 60 hertz, so you don't even have to calculate
the timeouts.

00:12:14.490 --> 00:12:19.440
So request animation frame is new and we have
browser prefixes in front as we work out the

00:12:19.440 --> 00:12:24.279
kinks, so this nice little shim here will
help you future-proof your code by handling

00:12:24.279 --> 00:12:29.150
the browser prefixes and then falling back
to set time-out if those -- if request animation

00:12:29.150 --> 00:12:34.120
frame is not supported. I highly recommend
this blog post here, the title here, to learn

00:12:34.120 --> 00:12:39.079
more about the benefits of request animation
frame and to get this shim.

00:12:39.079 --> 00:12:43.339
So looking at our first entity in the system,
this is an alien. We have our update and draw

00:12:43.339 --> 00:12:47.201
methods in here. You can see we update the
state inside update, where essentially we

00:12:47.201 --> 00:12:51.240
move that X and Y coordinate, and then in
draw we just want to draw that sprite. And

00:12:51.240 --> 00:12:54.921
remember we want to draw everything centered
around the point -- that is the X and Y where

00:12:54.921 --> 00:12:59.790
we think the element is -- and so we just
introduce a simple method here, draw sprite

00:12:59.790 --> 00:13:04.300
centered where we do the offsets.
So looking at that now, here we go. We have

00:13:04.300 --> 00:13:07.400
aliens flying across the screen. We've got
entity managers. This is great but we have

00:13:07.400 --> 00:13:12.070
a hundred percent more uh-oh. So I don't know
if anybody caught the bug that was introduced

00:13:12.070 --> 00:13:16.100
in the previous code, but to illustrate it,
keep your eyes on the moving aliens.

00:13:16.100 --> 00:13:18.820
So let's say I'm playing Bad Aliens and I
think, you know what? I want to play another

00:13:18.820 --> 00:13:22.480
-- see what other cool games are out there,
so of course I go to the Chrome Web Store

00:13:22.480 --> 00:13:26.139
and I'm browsing around the games and I'm
like, you know what, Bad Aliens is the coolest

00:13:26.139 --> 00:13:30.279
game ever made and so I'm just going to go
with that. Whoa! Where did the aliens go?

00:13:30.279 --> 00:13:34.690
So let's just catch that again. And because
-- remember, because request animation frame

00:13:34.690 --> 00:13:39.320
has kicked in here, when I open up a new tab
like this, the game is paused, and we're browsing

00:13:39.320 --> 00:13:45.240
around, (making sound), boom! They all kind
of jump around. I call this the wormhole effect.

00:13:45.240 --> 00:13:49.230
So our objective now is to fix the timing.
So what's going on? If you remember back in

00:13:49.230 --> 00:13:54.350
the loop itself, I was looking at the system
clock and calculating the delta before -- last

00:13:54.350 --> 00:13:58.460
time my loop ran and then now and getting
this nice little time delta in here. But in

00:13:58.460 --> 00:14:02.510
fact, because the game can get paused, as
we saw here with request animation frame,

00:14:02.510 --> 00:14:06.480
and we jump back into the game, that delta
could be very, very large. And if you're basing

00:14:06.480 --> 00:14:12.620
that off of anything like your velocity calculations,
you can have these tremendous wormhole effects.

00:14:12.620 --> 00:14:15.430
That's not good.
So we're going to introduce our own timer,

00:14:15.430 --> 00:14:20.199
our own in-game clock. We're going to ignore
the system clock and we're going to clamp

00:14:20.199 --> 00:14:22.149
these deltas here to a well-known consistent
state.

00:14:22.149 --> 00:14:29.100
So we're going to introduce a simple timer
here. The timer in its tick method, you can

00:14:29.100 --> 00:14:32.930
see the highlighted code here is the kind
of key code where we do math.min between the

00:14:32.930 --> 00:14:39.290
wall delta where a system time diff between
the loop is or our max step. So this is really

00:14:39.290 --> 00:14:43.610
good because now we can pause the game. Everything
moves in lock step and this actually sets

00:14:43.610 --> 00:14:47.870
us up for great multiplayer action, as well,
as we have a game clock now independent of

00:14:47.870 --> 00:14:52.420
system clock, so you can tell events will
happen at a particular time in the game, independent

00:14:52.420 --> 00:14:56.410
of people's FPS rates or machine speeds or
whatnot.

00:14:56.410 --> 00:15:02.089
So inside the loop, we remove all the crufty
time code and we put in a simple clock tick.

00:15:02.089 --> 00:15:07.829
This gets -- just gets set from timer.tick
and then back over in alien.update, we can

00:15:07.829 --> 00:15:14.269
use in clock tick in replace of the older
system clock delta to calculate speed and

00:15:14.269 --> 00:15:17.029
velocity.
So we have now a hundred percent less wormholes.

00:15:17.029 --> 00:15:19.810
And they're slower here only because I didn't
sync up the timing.

00:15:19.810 --> 00:15:23.690
So let's go back to -- we're going to pause
the game. Let's pause the game.

00:15:23.690 --> 00:15:29.910
And everything picks up exactly where it was.
So now we have a consistent in-game time.

00:15:29.910 --> 00:15:34.059
Our next objective, though, here to fix is
we're going to orient alien ships. We're not

00:15:34.059 --> 00:15:37.899
quite as menacing as we possibly could. We
want them facing down Earth, so right now

00:15:37.899 --> 00:15:41.910
they're all just pointing down and we want
them to all be pointing towards that zero

00:15:41.910 --> 00:15:45.869
zero point.
So canvas to the rescue again with this nice

00:15:45.869 --> 00:15:51.860
rotate call. Rotate takes radians and will
rotate clockwise. The important point here,

00:15:51.860 --> 00:15:57.139
though, is rotate actually rotates the entire
canvas coordinate system, so we don't use

00:15:57.139 --> 00:16:00.589
rotate to rotate the image and then draw,
necessarily. We actually move the entire coordinate

00:16:00.589 --> 00:16:04.750
system for canvas around from that origin
point, draw the image.

00:16:04.750 --> 00:16:09.061
So here's a good -- good image also from the
MDC site as well.

00:16:09.061 --> 00:16:14.610
So there are couple steps here to make this
happen correctly. Our first step up here in

00:16:14.610 --> 00:16:20.779
the red, we're going to translate our context
to the X and Y coordinate of our sprites.

00:16:20.779 --> 00:16:23.059
We're going to move everything relative to
where we want to draw.

00:16:23.059 --> 00:16:26.860
So you can see here when we draw, we're at
the upper left-hand of the image but at least

00:16:26.860 --> 00:16:31.319
we're drawing pretty close to where we want.
In Step 2, we add in the rotation, so you

00:16:31.319 --> 00:16:34.379
can see here now the image is rotated but
he's still offset.

00:16:34.379 --> 00:16:38.399
So then in Step 3, we have the translate,
we have the rotate, but then we have to draw

00:16:38.399 --> 00:16:43.439
that image offset based on his width and height
minus 2 again and now we're drawing the image

00:16:43.439 --> 00:16:46.120
rotated and exactly on top of the point where
we want to draw.

00:16:46.120 --> 00:16:53.089
We can add that code now back over to alien.draw
and you can see here we wrap all this fancy

00:16:53.089 --> 00:16:58.190
manipulation here with save and restore.
So canvas again to the rescue. It allows us

00:16:58.190 --> 00:17:03.240
to push and pop the state inside canvas, so
that we can manipulate accordingly. We can

00:17:03.240 --> 00:17:08.100
translate and rotate all we want. And then
if we restore, we can pop off. That is undo

00:17:08.100 --> 00:17:13.980
any of the changes we made, so that further
calls to the context are uneffected by any

00:17:13.980 --> 00:17:17.409
of these changes.
So here we have a hundred percent more correct

00:17:17.409 --> 00:17:23.900
image rotation. Great. Okay.
Moving on, we are going to optimize the canvas

00:17:23.900 --> 00:17:28.640
code and save battery. So it turns out that
one of the roots of all evil of computer programming

00:17:28.640 --> 00:17:38.430
is early optimization. Excuse me. But we know
that drawing to the canvas is actually the

00:17:38.430 --> 00:17:42.080
toughest part of our game here, so we want
to optimize this code. So we're going to introduce

00:17:42.080 --> 00:17:47.750
a cool concept called off-screen canvas. Off-screen
canvas allows us to create a canvas not visible

00:17:47.750 --> 00:17:52.380
on the browser, but still attached. We can
draw things onto this off-screen canvas and

00:17:52.380 --> 00:18:00.360
then use the canvas. Here in this code we
have rotated cache where we create off-screen

00:18:00.360 --> 00:18:04.899
canvas. We do the same rotation and translation
we saw earlier, and then you return the canvas

00:18:04.899 --> 00:18:11.840
and not the image. Here in alien, we call
rotate and cache. We get the image from the

00:18:11.840 --> 00:18:17.110
asset manager. We do the rotation cache and
return it to the sprite -- return it as a

00:18:17.110 --> 00:18:21.450
sprite. Now this sprite, which itself is a
canvas, can be treated like an image and drawn

00:18:21.450 --> 00:18:25.299
over and all over. This is great. Because,
if you think about it, we would like the aliens

00:18:25.299 --> 00:18:30.140
to loop around the screen. each one 60 times
a second was being translated and rotated

00:18:30.140 --> 00:18:35.450
and drawn. Certainly, we can do better than
that. Rotation and cache only once. Turns

00:18:35.450 --> 00:18:42.030
out it's a very big improvement. Here I just
looked with the developer tools. And 10 seconds

00:18:42.030 --> 00:18:49.090
of game play. And we have on the right no
caching. That is, we do the rotation and transformation

00:18:49.090 --> 00:18:54.690
every time for every alien. And, on the left
here, we introduce that off-screen canvas

00:18:54.690 --> 00:18:59.270
caching. Only four milliseconds in all that
10 seconds was being spent. Huge performance

00:18:59.270 --> 00:19:03.490
gains. It should be noted that once more canvases
become hardware accelerated, this difference

00:19:03.490 --> 00:19:07.600
will minimize a little bit. But still it's
a good technique to do any work you would

00:19:07.600 --> 00:19:13.400
do over and over again once and cache it.
So then we have 100% more effective image

00:19:13.400 --> 00:19:19.020
rotation. Game still plays correctly, and
we're using a lot less CPU speed.

00:19:19.020 --> 00:19:24.150
Okay. Now we had to add in our planetary defense
forces, which implies the matter of turrets.

00:19:24.150 --> 00:19:28.120
And to add turrets to move around, we add
input handling. So we're going to listen for

00:19:28.120 --> 00:19:33.720
clicks and mouse moves here. But, as we'll
see in a moment, those clicks as we get raw

00:19:33.720 --> 00:19:40.190
event callbacks, isn't relevant to our game
space. We need to do offsets.

00:19:40.190 --> 00:19:44.049
As web developers, you're probably familiar
with doing on mouse move or on click and then

00:19:44.049 --> 00:19:48.300
handling whatever it is you need to do inside
the callback. But it turns out in games you

00:19:48.300 --> 00:19:52.330
don't really want to do that. You want to
let the update loop manage all the state for

00:19:52.330 --> 00:19:57.691
you. You don't want to manipulate the state
of your entities in the actual callback for

00:19:57.691 --> 00:20:01.070
things like click and mouse move. So we're
going to store the click or store the fact

00:20:01.070 --> 00:20:06.980
we have a mouse position and actually process
it later in the update loop.

00:20:06.980 --> 00:20:12.340
So now we can ask the game engine to start
input. We have both input handlers, both click

00:20:12.340 --> 00:20:17.950
and mouse move. And we call get x and y, which
is the method we wrote to translate the x

00:20:17.950 --> 00:20:22.670
and y we get from the callbacks back into
game coordinate space. So, to look at what

00:20:22.670 --> 00:20:30.490
this means, here is the raw client.x and client.y
code. If I were to click right in the center,

00:20:30.490 --> 00:20:37.050
x is 522 and y is 399. That's not exactly
00 or close to it. So we need to figure out

00:20:37.050 --> 00:20:40.549
how to offset that.
First thing we need to do is call get bounding

00:20:40.549 --> 00:20:47.399
client rect. And do that offset first. And
we're at 516, 391. Little bit closer. That

00:20:47.399 --> 00:20:54.130
offset is the white border between the documents
page -- document window and the canvas itself.

00:20:54.130 --> 00:20:57.970
And then the final offset here, we're going
to take that and offset again from the canvas

00:20:57.970 --> 00:21:03.211
width and height divided by 2. And it turns
out I clicked pretty close at 4 and 7. So

00:21:03.211 --> 00:21:08.690
do you need to do this? No. But it's really
helpful to get that x and y -- those points

00:21:08.690 --> 00:21:12.630
relative to your end game coordinate system
just makes everything a lot easier.

00:21:12.630 --> 00:21:18.230
So here, turning that into code, same code
we just saw. We're going to turn the offset

00:21:18.230 --> 00:21:22.299
x and y.
Now, over in sentry, which is that turret

00:21:22.299 --> 00:21:26.720
that follows our mouse, you can say, if there's
a game.mouse, if we have some sort of movement,

00:21:26.720 --> 00:21:32.269
I can go ahead and use the games mouse y and
mouse x and calculate accordingly.

00:21:32.269 --> 00:21:36.640
Now, we want the game loop to be refreshed
every time. So at the end of the game loop,

00:21:36.640 --> 00:21:42.019
we need to clear out, for instance, the clicks.
So, if I didn't click, the game doesn't remember

00:21:42.019 --> 00:21:46.580
I had a click. So just always reset the state
at the end of that game loop. Now we should

00:21:46.580 --> 00:21:50.880
have a turret and a grade. It's following
my mouse around. So now we have mouse movement.

00:21:50.880 --> 00:21:55.480
And now that we added mouse click handling,
we can now start shooting lasers. So we want

00:21:55.480 --> 00:21:59.631
to start handling the click. Shoot some lasers.
Now that we have aliens flying around everywhere,

00:21:59.631 --> 00:22:03.169
and we have all these laser bullets flying
around everywhere. We need to start thinking

00:22:03.169 --> 00:22:07.179
about do I need to manage these things when
they fall off the screen. So we're going to

00:22:07.179 --> 00:22:11.140
introduce the concept of remove from world
bit, which is a simple bit here and the game

00:22:11.140 --> 00:22:17.501
engine can check. And if it's true, it knows
to remove it at a managed entry. So over in

00:22:17.501 --> 00:22:22.580
sentry, remember, in the update loop is where
you actually handle the click and do the work.

00:22:22.580 --> 00:22:28.020
So we say if there is a game dot click, then
call shoot. And over in shoot we create a

00:22:28.020 --> 00:22:34.190
bullet and give it to the game engine so he
can start becoming managed and update and

00:22:34.190 --> 00:22:38.789
drawn. Over in bullet, we detect if we come
off the screen. And, if so, we set to world

00:22:38.789 --> 00:22:47.700
equals true. In game engine we can loop again
and say did anything get flagged for removal

00:22:47.700 --> 00:22:51.809
after our main update loop? This, obviously,isn't
super optimized code or anything. But for

00:22:51.809 --> 00:22:56.640
the purposes of our simple game here, this
works great.

00:22:56.640 --> 00:23:17.600
So we should have -- you should reload. Uh-oh.
There we go. If it doesn't come up, we'll

00:23:17.600 --> 00:23:19.210
keep going. Okay. We'll come back to that
one. See if it pops in. Pretending we had

00:23:19.210 --> 00:23:24.539
cool firing lasers there.
We want to make those hypothetical lasers

00:23:24.539 --> 00:23:29.919
explode. So, to do that, we're going to add
to the concept of an animation class. Animation

00:23:29.919 --> 00:23:37.230
class will handle something called a sprite
sheet. A sprite sheet is a collection of animation

00:23:37.230 --> 00:23:42.860
frames all stitched together so that the animation
class can work through it step-by-step and

00:23:42.860 --> 00:23:48.149
draw it quickly, makes it look like an animation.
Nice thing, by stitching everything together

00:23:48.149 --> 00:23:52.070
to create one asset versus 10, 20, or 30,
there's a lot less resources going over the

00:23:52.070 --> 00:23:56.520
wire. This is a good thing for performance.
And this is a concept familiar to game developers.

00:23:56.520 --> 00:24:02.250
So sprite sheets are very handy. Turns out
that canvases draw image takes advantage of

00:24:02.250 --> 00:24:07.299
this quite nicely. Because one of the overloaded
calls here can take a certain subsection of

00:24:07.299 --> 00:24:12.750
your image, that is, your sprite sheet, pick
that up, and then draw it on the canvas to

00:24:12.750 --> 00:24:19.221
your main game canvas. So it can work itself
through quite nicely. This is an example of

00:24:19.221 --> 00:24:23.289
what an animation class would look like in
draw frame. He knows the time through the

00:24:23.289 --> 00:24:27.919
game. This is another reason why the game
timer is so important. And then we call canvases

00:24:27.919 --> 00:24:32.370
draw image, which knows what current frame
we're on. So we can calculate exactly how

00:24:32.370 --> 00:24:37.870
far into the spreadsheet we need to go, pick
up just that subsection or subregion and then

00:24:37.870 --> 00:24:42.720
draw it on remaining canvas. Animation class
would also know what current frame and are

00:24:42.720 --> 00:24:48.080
we done with the animation or not?
So over in bullet explosion now, his draw

00:24:48.080 --> 00:24:53.519
method -- we just simply delegate to his animation
class where we draw a frame inside draw. Now

00:24:53.519 --> 00:24:59.149
you're asking where did bullet explosion come
from? Great technique here in game development

00:24:59.149 --> 00:25:04.230
is you can actually change or swap entities
in and out. So instead of in the bullet class,

00:25:04.230 --> 00:25:07.760
for instance, saying, if I'm exploding, do
this and, if not exploding, do that which

00:25:07.760 --> 00:25:14.600
gets very complicated, a neat technique is
to remove one entity, swap in another entity

00:25:14.600 --> 00:25:19.360
right on top of them. And the user never knows,
and it's just much simpler to manage different

00:25:19.360 --> 00:25:25.940
entities. So here we add a bullet explosion
entity and then removed the bullet entity.

00:25:25.940 --> 00:25:29.570
So now we're good. Now we have shooting. We
have bullets flying through space. We have

00:25:29.570 --> 00:25:32.549
explosions. You can see the animation class,
work through the frames.

00:25:32.549 --> 00:25:37.559
And I also use canvas as a scale method. So
as I move through the animation, I also scale

00:25:37.559 --> 00:25:43.179
it up and up and up. So this is pretty cool,
but I think we can do better. We want sounds.

00:25:43.179 --> 00:25:49.360
Those cool explosions. So HTML5 audio not
quite there yet for game development. There's

00:25:49.360 --> 00:25:54.370
a lot written on this subject. I'd ask you
to go definitely research this yourself. I

00:25:54.370 --> 00:25:58.820
think the good news here is the message has
been heard. So there's patches floating for

00:25:58.820 --> 00:26:04.180
Chrome that should fix some of the major issues.
The W3C, for instance, is starting a group

00:26:04.180 --> 00:26:09.110
called audio working group to look at what
a more robust audio API would look like. But

00:26:09.110 --> 00:26:14.110
back in real life, we need to get this working,
we need to use sound manager 2. Sound manager

00:26:14.110 --> 00:26:20.480
2 is a really neat simple API for playing
sounds. It will delegate to flash and also

00:26:20.480 --> 00:26:24.169
delegate to HTML5 audio. So you can use code
today that is future-proof.

00:26:24.169 --> 00:26:30.590
We're going to integrate sound manager into
our asset manager. Pretty straightforward.

00:26:30.590 --> 00:26:34.649
One of the tricks here is you're going to
want to set auto load to true so that you

00:26:34.649 --> 00:26:40.000
can preload all of your images and predownload
all of your sounds. So asset manager knows

00:26:40.000 --> 00:26:45.320
how to kick off your game when all resources
are done downloading. And it's very simple.

00:26:45.320 --> 00:26:49.260
You can ask the asset manager get the sound
and call play. And at this point, we're in

00:26:49.260 --> 00:26:56.139
the sound manager 2 world. And he'll go ahead
and play. So let's see what it sounds like

00:26:56.139 --> 00:27:05.220
here. All right. Now we're cruising. Pretty
satisfying explosions. That's pretty good.

00:27:05.220 --> 00:27:08.159
Good base.
Now we're all set up to actually blow up the

00:27:08.159 --> 00:27:13.639
aliens. So we need to add a collision detection
algorithm here. For a simple game we're going

00:27:13.639 --> 00:27:20.830
to add a circle intersection algorithm. We're
going to give every object a radius. From

00:27:20.830 --> 00:27:25.880
that radius we can determine if the two circles
that represent the objects collide. This,

00:27:25.880 --> 00:27:30.519
obviously, doesn't work in all cases. But,
for this simple game, it will work great.

00:27:30.519 --> 00:27:34.610
So, to do this inside bullet explosion in
his update method, we're going to loop again

00:27:34.610 --> 00:27:37.840
through all the aliens on the screen and say,
"Hey, are you caught in my explosion? Are

00:27:37.840 --> 00:27:41.350
you caught in my explosion?" And, if so, we're
going to implement our score and then trigger

00:27:41.350 --> 00:27:45.390
the explosion game logic. So this works for
our simple game here, because there's not

00:27:45.390 --> 00:27:50.309
that many entities on the system. However,
one of the early optimizations you'll probably

00:27:50.309 --> 00:27:55.889
do is end up implementing something like spatial
partitioning which cuts up game board or canvas

00:27:55.889 --> 00:27:59.610
into subregions. And you track which entity
is in which subregion. And then, when you

00:27:59.610 --> 00:28:04.399
go to do a collision detection, you have a
much more narrow view coordinate into your

00:28:04.399 --> 00:28:10.950
world and you'll have to check every entity.
So one Protip that I often like to do is for

00:28:10.950 --> 00:28:16.679
all the entities in my game, when I do this,
I can do visual debugging and draw a circle

00:28:16.679 --> 00:28:22.470
around my entity that just aids me in understanding
where I'm drawing things and visually debug

00:28:22.470 --> 00:28:25.649
if the collision detection works. So, for
instance, it shows you how easy it is to draw

00:28:25.649 --> 00:28:30.480
a circle around something. And, if I set this
one bit show outlines, all my entities will

00:28:30.480 --> 00:28:35.750
be outlined. So now you can see the circles
are on the screen. Hopefully, maybe not. But

00:28:35.750 --> 00:28:40.080
we should be able to fire away. [Audio sound
effects]

00:28:40.080 --> 00:28:50.240
So now we have collision detection, extra
sounds for the alien explosion. And all right.

00:28:50.240 --> 00:28:52.830
Great.
So now that we actually are able to blow up

00:28:52.830 --> 00:28:57.039
some aliens, we're tracking some score, we
want to see what's my score? How am I doing?

00:28:57.039 --> 00:29:01.799
So, for purposes of our simple game here,
we're going to use canvas's fill text. It

00:29:01.799 --> 00:29:07.080
will draw text straight on to the canvas.
Very straightforward. Very simple. However,

00:29:07.080 --> 00:29:11.750
you'll probably want to optimize this as well.
You can use a technique like sprite sheet

00:29:11.750 --> 00:29:16.620
for game fonts. Impact has a cool tool for
this. And then using the same spreadsheet,

00:29:16.620 --> 00:29:22.720
we can draw subregions on to your main canvas.
You can do the same thing with text sprite

00:29:22.720 --> 00:29:27.570
sheets on font as well. You'll probably notice
the text in your game probably doesn't need

00:29:27.570 --> 00:29:34.180
to be updated 60 times a second. The score
doesn't change 60 times a second. So in early

00:29:34.180 --> 00:29:38.960
optimization, you'll probably want to employ
off-screen canvas approach for stuff that

00:29:38.960 --> 00:29:45.130
doesn't change frequently like the game text
or the score. But, just to show you how simple

00:29:45.130 --> 00:29:50.720
it is to do, we're going to ask the game to
draw score and draw the number of lives we

00:29:50.720 --> 00:29:53.691
have left. And we're going to integrate that
in with the game loop. And then you can see

00:29:53.691 --> 00:29:59.510
it's easy to draw text on the screen with
canvas. So we have 100% more scores. I left

00:29:59.510 --> 00:30:07.270
this running. Shoot! I'm already super dead.
That's a simple way to get something like

00:30:07.270 --> 00:30:12.250
text and score display onto the screen.
So, now that we've worked through a lot of

00:30:12.250 --> 00:30:16.269
this and started thinking about performance,
you want to start asking yourself how do I

00:30:16.269 --> 00:30:21.399
measure performance? There's two ways to think
about performance, especially in HTML5 games.

00:30:21.399 --> 00:30:26.840
There's how fast am I drawing to the screen?
That's your draw loop. And how fast am I executing

00:30:26.840 --> 00:30:30.990
the business logic or update loop? So you
can think of more complex games that might

00:30:30.990 --> 00:30:36.090
have a physics engine. The optimizing how
you approach your physics loop might be different

00:30:36.090 --> 00:30:39.429
than how you optimize and approach your draw
loop. So there's two different high-level

00:30:39.429 --> 00:30:44.669
ways when I think about optimization. For
the draw loop we're going to -- there's a

00:30:44.669 --> 00:30:48.409
great JavaScript utility calls stats.js for
Mr. Doobs. It draws a nice little canvas underneath

00:30:48.409 --> 00:30:55.090
and gives you a rendering to visualize what's
happening. But That's his best approximation.

00:30:55.090 --> 00:30:59.960
It turns out that Chrome in about flags has
a really cool way to display a true to life

00:30:59.960 --> 00:31:07.340
FPS counter. And that's the best way to understand
how truly often is Chrome drawing to the screen.

00:31:07.340 --> 00:31:12.340
To look at things like your physics performance
or your update loops, highly recommend developer

00:31:12.340 --> 00:31:16.000
tools, the profiler that will go through and
tell you exactly which JavaScript calls you're

00:31:16.000 --> 00:31:21.049
spending most of your time on.
And over in Mozilla, to get the best way to

00:31:21.049 --> 00:31:25.549
look at how often I'm drawing to screen, they
have a cool mozPaintCount which you can query.

00:31:25.549 --> 00:31:28.961
And that just increments every time you draw
to screen. And you can infer the FPS count

00:31:28.961 --> 00:31:33.721
from that.
So a quick look at stats.js. This is what

00:31:33.721 --> 00:31:40.509
it looks like. Draw a histogram of what your
FPS looks like from his best estimation. We're

00:31:40.509 --> 00:31:45.070
actually going to add that into our game to
show you what's going on here. It's very simple.

00:31:45.070 --> 00:31:51.710
You integrate that right into your update
loop. And then he will draw it for you. The

00:31:51.710 --> 00:31:55.850
Chrome about flags here, FPS counter will
show in the upper left hand and give you a

00:31:55.850 --> 00:32:02.050
true FPS. So the more you dive in, the more
you want hard core numbers. So I definitely

00:32:02.050 --> 00:32:06.700
ask you to check this out. One note, though:
This will only turn on with hardware acceleration

00:32:06.700 --> 00:32:13.620
for things like WebGL and soon-to-be hardware-accelerated
canvas. So you may or may not see this, depending

00:32:13.620 --> 00:32:18.230
on your browser and game.
Here's what developer tools look like. I used

00:32:18.230 --> 00:32:22.500
this, for instance, to determine how much
time I'm spending in actual draw alien call

00:32:22.500 --> 00:32:26.759
for the optimization in image caching. This
is really, really great. I think you'll be

00:32:26.759 --> 00:32:31.009
surprised about where you actually need to
optimize your code. You're probably thinking

00:32:31.009 --> 00:32:34.340
I've got to optimize all these different for
loops everywhere. And you're probably going

00:32:34.340 --> 00:32:40.840
to figure out where you have to draw less.
And this will confirm that for you. So 100%

00:32:40.840 --> 00:32:44.950
more. How are we doing? Down here we have
19 frames per second. I think we can do better

00:32:44.950 --> 00:32:52.360
than that. So I think that's due to the -- yeah,
being the iFrame. Here we go up to 44. All

00:32:52.360 --> 00:32:59.730
right. We're doing okay.
Here come the aliens. Whee! So, anyway, a

00:32:59.730 --> 00:33:03.759
good perspective into the performance of your
game.

00:33:03.759 --> 00:33:09.690
And our final objective here is offline play.
A lot has been talked about offline for HTML5

00:33:09.690 --> 00:33:15.799
tools and technologies. And I think I want
to point out that we're not necessarily interested

00:33:15.799 --> 00:33:21.519
in true 100% offline like completely disconnected
all the time. Although that's a great goal.

00:33:21.519 --> 00:33:24.289
And I think you can incrementally work your
way up there. But I think you want to look

00:33:24.289 --> 00:33:29.980
at these technologies because you want transient
number activity. We're at the show. Wi-Fi

00:33:29.980 --> 00:33:36.090
can be a little sketchy. It's important to
understand your user doesn't always have best

00:33:36.090 --> 00:33:40.460
available network connectivity at 100% of
the time. Sometimes might even have no network.

00:33:40.460 --> 00:33:44.210
So we want to compensate for that. And, of
course, you want to save bandwidth builds

00:33:44.210 --> 00:33:49.409
for your service as well. So we're going to
employ application cache. Application cache

00:33:49.409 --> 00:33:55.010
is a declarative way to signal all of the
static assets like JavaScript, CSS, images,

00:33:55.010 --> 00:34:00.539
HTML, et cetera, and tell the browser to super
cache them. That is, cache them outside into

00:34:00.539 --> 00:34:06.659
normal managed browser cache, more left indefinitely.
Normal application cache has a 5 meg limit.

00:34:06.659 --> 00:34:12.340
But, if you install the game from Chrome web
store, you get unlimited storage.

00:34:12.340 --> 00:34:18.320
So a couple tips here: The AppCache, the manifest
file has to change if you want anything to

00:34:18.320 --> 00:34:22.650
be reflected on the client. So this is important
point. Always trips me up. I always forget

00:34:22.650 --> 00:34:27.630
to twiddle. Just change the file in any way,
shape, or form to signal the browser to redownload

00:34:27.630 --> 00:34:31.830
anything. Changes are reflected on the second
load. This is kind of a subtle point, in my

00:34:31.830 --> 00:34:36.300
opinion. Might mess you up in your first set
of debugging. But the application cache, remember,

00:34:36.300 --> 00:34:41.690
will download in a separate thread all the
assets. And then -- so, if your player is

00:34:41.690 --> 00:34:44.760
playing and you've got a cache and everything
is working great offline and you've changed

00:34:44.760 --> 00:34:50.650
something so that, while the player is playing,
it's redownloaded all of the assets. Again,

00:34:50.650 --> 00:34:54.340
he's not going to see the new version. The
cache doesn't take effect immediately out

00:34:54.340 --> 00:34:59.150
of nowhere. The user has to reload again.
So that the second time he plays again after

00:34:59.150 --> 00:35:03.420
the update, he'll actually be pulling from
the updated cache. Something to keep in mind

00:35:03.420 --> 00:35:11.060
and a little tricky. Highly recommend AppCache
info. Lot of great insider knowledge. Luckily,

00:35:11.060 --> 00:35:14.810
a file is pretty straightforward. We just
declared all the different assets we're on

00:35:14.810 --> 00:35:20.260
in no particular order. And this signals the
browser. All we need to do is declare this

00:35:20.260 --> 00:35:26.490
as manifest attribute in our HTML file in
our document. And we have 100% more aliens

00:35:26.490 --> 00:35:30.990
on the plane. I'm not messing with the Wi-Fi
gods. And you'll just have to take my words

00:35:30.990 --> 00:35:36.890
for it here. But it totally does work.
So we actually ran through. And that was actually

00:35:36.890 --> 00:35:41.920
pretty quick. All the different steps we need
from zero to hero to build a HTML5 game. Hopefully,

00:35:41.920 --> 00:35:46.590
most of that was pretty straightforward stuff.
Luckily, we don't have to star from scratch.

00:35:46.590 --> 00:35:52.720
There is a lot of interesting movement here
in the HTML5 game engine community. Couple

00:35:52.720 --> 00:35:58.600
cool notes: Rocket engine, an HTML5 game engine,
bought by Disney no longer publicly available.

00:35:58.600 --> 00:36:04.070
Aves, another HTML5 game engine, bought by
Zynga, no longer publicly available. Big companies

00:36:04.070 --> 00:36:08.830
are investing in HTML5 games.
Stuff you guys can play with: Impact, they're

00:36:08.830 --> 00:36:12.960
here at the show. Crafty is an open source
engine. Game closure, they're here at the

00:36:12.960 --> 00:36:18.450
show. A couple others. I do want a special
call out to Forplay, which is an open source

00:36:18.450 --> 00:36:23.800
GWT game engine. This is really cool. I highly
recommend you check out their talk tomorrow.

00:36:23.800 --> 00:36:28.280
They're going to show something really, really
nice. Check it out. The many, many more links

00:36:28.280 --> 00:36:32.090
here goes to a get hub Wiki page with a ton
of HTML5 game engines all in varying degrees

00:36:32.090 --> 00:36:38.120
of completeness and features and whatnot.
So a lot of action going on here.

00:36:38.120 --> 00:36:43.200
I know you're saying, well, mobile is hot,
hot, hot. How do I get in on that action?

00:36:43.200 --> 00:36:47.880
Turns out game engines are thinking heavily
about this problem. So, for instance, Impact

00:36:47.880 --> 00:36:53.609
recently released a cool blog post in addition
to their game engine that takes your HTML5

00:36:53.609 --> 00:36:59.750
game written in JavaScript and uses canvas
and will get it at near native speeds on to

00:36:59.750 --> 00:37:05.700
your IOS device. For instance, uses the nitro
JS engine to execute your JavaScript natively

00:37:05.700 --> 00:37:11.890
and then will translate your canvas call to
open AL. So this is really, really cool. One

00:37:11.890 --> 00:37:18.590
toolkit -- one technology toolkit like HTML5
multiple platforms does something very cool.

00:37:18.590 --> 00:37:24.570
So does space board. Stick with HTML.
Another theme is you don't have to start from

00:37:24.570 --> 00:37:29.550
scratch. A lot of us aren't artists. So I
do want to call out there are ways to get

00:37:29.550 --> 00:37:35.570
assets you can use to start playing with HTML5
games. For instance, freecell.org has more

00:37:35.570 --> 00:37:41.860
than enough to get started with. Free sound.
Any great development blog in general. But

00:37:41.860 --> 00:37:49.100
they have cool artwork licensed for you to
use in your indie game. So we've built a really

00:37:49.100 --> 00:37:52.880
cool game. It's all set to go. How do we get
it in the hands of users? Quick shout-out

00:37:52.880 --> 00:38:01.140
to Chrome Web Store. This is the open marketplace
for web apps and web games. You can see here

00:38:01.140 --> 00:38:07.770
numerous call-outs to games. Lord of Ultima,
Spark Chest and favorite games. Games are

00:38:07.770 --> 00:38:13.440
really, really important to game store. There's
no up-front app review process. You can put

00:38:13.440 --> 00:38:17.691
your game in. And it will be published into
the directory more or less immediately. Big

00:38:17.691 --> 00:38:24.680
companies like EA, Zynga, Atari, Big Point
and Pop Cap and lots of other developers and

00:38:24.680 --> 00:38:30.550
indies are putting their game into the store.
How to get started, call out to Appmator to

00:38:30.550 --> 00:38:36.320
automate the process. This is a subtle point,
but something here to remember I think it's

00:38:36.320 --> 00:38:41.550
key. Chrome Web Store users use Chrome. It
sounds totally obvious. If you think about

00:38:41.550 --> 00:38:46.940
it, it means Chrome Web Store is your safety
net. You can build that awesome HTML5 game

00:38:46.940 --> 00:38:51.420
and distribute it through an actual marketplace,
a store and be assured that your users are

00:38:51.420 --> 00:38:57.420
using a modern browser that can run all this
awesome HTML5 awesomeness.

00:38:57.420 --> 00:39:10.620
Success story here. World Golf Tour here,
for instance. So that's a lot of material.

00:39:10.620 --> 00:39:15.780
This is just one talk? No. There's a lot of
stuff out there. For instance, there's a whole

00:39:15.780 --> 00:39:20.470
other HTML5 game conference. There's a whole
bunch of people on Twitter who publish books

00:39:20.470 --> 00:39:24.340
and write about this. And they actually make
games. Lots of different blogs. For instance,

00:39:24.340 --> 00:39:29.210
Hive and go forward and publish their experiences.
And they build out their latest HTML5 games.

00:39:29.210 --> 00:39:33.900
Function Source, the new web magazine online,
has a great article called HTML meet the world

00:39:33.900 --> 00:39:40.220
of games. And I think probably most telling
here is game developer magazine, the magazine

00:39:40.220 --> 00:39:48.120
has a feature article in HTML5 game development
this month. So to sum it all up, just remember

00:39:48.120 --> 00:39:53.380
simple HTML5 games are just canvas and JavaScript.
And all the tools are already there in your

00:39:53.380 --> 00:39:58.120
browser. No otherwise magic that you need
to get going. But let these game engines do

00:39:58.120 --> 00:40:01.730
the heavy lifting. We looked at all the code,
and it might be interesting to build it up

00:40:01.730 --> 00:40:07.610
from scratch and get a feel for what's going
on. Don't start from scratch. See one of these

00:40:07.610 --> 00:40:14.810
game engines might help you get bootstrapped.
Remember then even Id, guys who make Wolfenstein,

00:40:14.810 --> 00:40:21.380
even Rage coming out this summer, he said
if uncompressed Rage is going to be a terabyte.

00:40:21.380 --> 00:40:27.040
So, even these guys, started with an 8 bit
scroller called commander king. So it's within

00:40:27.040 --> 00:40:31.380
our reach to build great games and start with
a great experience. So definitely go out there

00:40:31.380 --> 00:40:38.100
and have fun. I want to thank everyone for
joining me. We're going to do some live Q&amp;A.

00:40:38.100 --> 00:40:43.250
I encourage everybody to give me feedback
on the talk. I appreciate that. Everyone who

00:40:43.250 --> 00:40:50.140
gets a live question gets a cool HTML5 keychain,
nice and heavy and hefty. You can see these

00:40:50.140 --> 00:40:55.530
slides as well. We'll jump over to moderator.
And please do come up to the mics.

00:40:55.530 --> 00:40:59.470
So thank you very much.
[Applause]

00:40:59.470 --> 00:41:05.770
&gt;&gt;Seth Ladd: All right. You're fast.
&gt;&gt;&gt; Number one.

00:41:05.770 --> 00:41:10.000
&gt;&gt;Seth Ladd: Okay.
&gt;&gt;&gt; So you were repainting the entire canvas

00:41:10.000 --> 00:41:11.750
every frame, just clearing it out and restarting
it.

00:41:11.750 --> 00:41:20.191
&gt;&gt;Seth Ladd: Yeah.
&gt;&gt;&gt; So how important in game performance is

00:41:20.191 --> 00:41:21.440
like using double buffering techniques or
doing incremental drawing and erasing and

00:41:21.440 --> 00:41:22.990
moving things so like --
&gt;&gt;Seth Ladd: So -- yeah. That's a great question.

00:41:22.990 --> 00:41:28.250
So generally you want to reduce the numbers
of drawing as much as possible, especially

00:41:28.250 --> 00:41:31.660
with un-accelerated canvas, and so each technique
depends on your particular game, but we've

00:41:31.660 --> 00:41:35.280
seen some really good performance improvements
by using, for instance, multi-canvas, just

00:41:35.280 --> 00:41:38.610
laying them all on top of each other.
So, for instance, the background may not change,

00:41:38.610 --> 00:41:42.710
so just draw that once, put another canvas
on top. That may be like one parallax which

00:41:42.710 --> 00:41:47.920
moves slower. So that's a technique I've seen
work really well, but --

00:41:47.920 --> 00:41:51.230
&gt;&gt;&gt; So you have like transparent backgrounds
for the foreground canvases and then they

00:41:51.230 --> 00:41:52.230
show through or --
&gt;&gt;Seth Ladd: Well, the canvas -- yeah. Because

00:41:52.230 --> 00:41:55.150
if you don't draw on the canvas, you can set
it just with CSS to be transparent.

00:41:55.150 --> 00:41:57.170
&gt;&gt;&gt; Okay. Great.
&gt;&gt;Seth Ladd: So that's one way to handle it.

00:41:57.170 --> 00:42:00.040
So let's take one from the Moderator here.
"Hi. Is there any statistical data about the

00:42:00.040 --> 00:42:03.080
use of browsers today that can help us take,"
ta-da, ta-da, ta-da.

00:42:03.080 --> 00:42:06.150
So basically can I actually do this in the
real world?

00:42:06.150 --> 00:42:11.090
So the answer is: There's lots of data out
there, like ComScore and NetScore, Cass. I

00:42:11.090 --> 00:42:14.360
mean, you can go find out for yourselves,
but the important thing to remember here is

00:42:14.360 --> 00:42:18.680
that it's very relative to your audience.
For instance, the audience for TechCrunch

00:42:18.680 --> 00:42:22.770
is going to be using a different browser than
the Wall Street Journal, for instance. So

00:42:22.770 --> 00:42:26.910
it's important to always look at who are you
trying to hit and what browser they're running.

00:42:26.910 --> 00:42:31.600
So, I mean, I don't have any stats on me,
but this is a good question, but I would say

00:42:31.600 --> 00:42:34.730
especially with something like the Chrome
Web Store, you can publish right there and

00:42:34.730 --> 00:42:42.450
just know, oh, everyone's on Chrome so -- question?
&gt;&gt;&gt; Yeah. I'm wondering about 3D game play,

00:42:42.450 --> 00:42:46.570
3D objects, robotic type things.
&gt;&gt;Seth Ladd: Uh-huh.

00:42:46.570 --> 00:42:49.020
&gt;&gt;&gt; Is HTML5 going to be able to support that
kind --

00:42:49.020 --> 00:42:56.480
&gt;&gt;Seth Ladd: Sure. Yeah. So part of the Open
Web Platform, part of the family of HTML5

00:42:56.480 --> 00:43:01.390
technology, is something called WebGL. WebGL
embeds a full featuring OpenGL ES 2.0 engine

00:43:01.390 --> 00:43:07.450
right in your browser and that's how you get
the hardware side or GPU'd awesome OpenGL

00:43:07.450 --> 00:43:09.490
graphics. Yeah.
So we'll take another one here.

00:43:09.490 --> 00:43:13.741
"Are HTML5 games just another way to create
pastime games or is it kind of a real game

00:43:13.741 --> 00:43:16.980
creation?"
Ah! I've heard this question a lot.

00:43:16.980 --> 00:43:20.560
So the way I like to picture it is lots of
games are real, right?

00:43:20.560 --> 00:43:26.600
So I -- for instance, we bundle Entanglement,
which is a really cool HTML5 game, very professionally

00:43:26.600 --> 00:43:30.500
produced, very soothing soundtrack, and that's
a real game. That's all HTML5.

00:43:30.500 --> 00:43:37.660
So I think what this is probably saying is
can we make triple A titles maybe on the order

00:43:37.660 --> 00:43:43.390
of like Medal of Honor or Call of Duty. That's
probably a little bit a ways away. There is

00:43:43.390 --> 00:43:48.690
a technology called native client which lets
you run C and C++ code natively and securely

00:43:48.690 --> 00:43:53.960
on the browser. That's probably more in tune
with what this person is asking about.

00:43:53.960 --> 00:43:59.400
Especially because AAA title game development
have a lot of investment in C code so that's

00:43:59.400 --> 00:44:01.590
probably one thing to look at. Question.
&gt;&gt;&gt; Hi. Can I ask two questions?

00:44:01.590 --> 00:44:03.600
&gt;&gt;Seth Ladd: Sure. But you only get one key
chain.

00:44:03.600 --> 00:44:08.720
&gt;&gt;&gt; Okay. I'd like to ask: Is there implementation
for streaming audio and video or does it have

00:44:08.720 --> 00:44:15.110
to be downloaded and cached?
&gt;&gt;Seth Ladd: That's actually a funny point

00:44:15.110 --> 00:44:21.560
because the HTML5 audio tag as originally
envisioned was really a streaming audio -- like

00:44:21.560 --> 00:44:24.190
that's what they originally kind of -- like
you can start playing like a song and it will

00:44:24.190 --> 00:44:31.220
just play, and what they didn't really work
out is what games need, like fast iteration,

00:44:31.220 --> 00:44:34.180
over and over and over play like for shooting
sounds and stuff.

00:44:34.180 --> 00:44:37.460
So, yeah, HTML5 will have audio and video.
You can stream it.

00:44:37.460 --> 00:44:40.980
&gt;&gt;&gt; So like a 4 mega- -- you won't have to
wait for a 4-megabyte audio file to download

00:44:40.980 --> 00:44:43.660
or anything like that?
&gt;&gt;Seth Ladd: If you want to play like a background

00:44:43.660 --> 00:44:44.660
sound?
&gt;&gt;&gt; Yeah.

00:44:44.660 --> 00:44:48.240
&gt;&gt;Seth Ladd: Sure. In fact, that's actually
where HTML5 audio tag does a pretty good job

00:44:48.240 --> 00:44:50.580
at.
&gt;&gt;&gt; Okay. Then my other question would be:

00:44:50.580 --> 00:44:52.540
The tutorial like you had right now, would
you be able to have that available publicly

00:44:52.540 --> 00:44:56.070
so that maybe your average teenager can start
making his own games?

00:44:56.070 --> 00:45:01.270
&gt;&gt;Seth Ladd: Absolutely.
So you can get the slides here. And then there's

00:45:01.270 --> 00:45:06.130
a link to the game way at the front, and everything
is on Get Hub, so you can just pull it down

00:45:06.130 --> 00:45:10.380
and play with it. But also Crafty is open
source as well so you can look at how they

00:45:10.380 --> 00:45:12.120
do it.
&gt;&gt;&gt; Okay. Thank you.

00:45:12.120 --> 00:45:15.080
&gt;&gt;Seth Ladd: Uh-huh. Let's see here.
"Are there any plans to make web apps ask

00:45:15.080 --> 00:45:18.950
for elevated privileges like full screen"
-- I think this is something we've been thinking

00:45:18.950 --> 00:45:23.890
a lot about. We don't have anything to talk
about today. But, yeah, I think games do ask

00:45:23.890 --> 00:45:25.920
for more elevated behavior into the system,
where you can do things like mouse captures.

00:45:25.920 --> 00:45:26.920
I think we're well aware of that.
&gt;&gt;&gt; What are some considerations for producing

00:45:26.920 --> 00:45:27.920
games that are part of like a business type
of thing? There's some games that, you know,

00:45:27.920 --> 00:45:28.920
actually are like sales for a business or
actually integrate with -- for instance, the

00:45:28.920 --> 00:45:37.080
-- the golf one integrated with a lot of different
partners and things. What are some considerations

00:45:37.080 --> 00:45:51.230
and how would HTML5 maybe be a special place
to do that?

00:45:51.230 --> 00:45:59.420
&gt;&gt;Seth Ladd: So I think -- yeah, I'm not sure
I understand exactly the question. That's

00:45:59.420 --> 00:46:02.440
a lot of business deals like you have to work
out with different partners.

00:46:02.440 --> 00:46:07.981
As far as HTML5, I mean, there is -- you get
enhanced game play out of it because things

00:46:07.981 --> 00:46:14.270
like the browser can now accelerate canvas
for you, or WebGL, and it requires less plug-ins.

00:46:14.270 --> 00:46:18.300
It could be a good thing.
So maybe the sell of "I'm going to build my

00:46:18.300 --> 00:46:23.980
game in HTML5 and future-proof myself as HTML5
gets on more and more platforms and devices."

00:46:23.980 --> 00:46:26.250
That's -- that probably is the right way to
go. But yeah.

00:46:26.250 --> 00:46:27.250
&gt;&gt;&gt; Yeah. Okay. Thank you.
&gt;&gt;Seth Ladd: Sure. Chris?

00:46:27.250 --> 00:46:28.250
&gt;&gt;&gt; Two things. Keyboard accessibility was
a big problem when canvas came out.

00:46:28.250 --> 00:46:33.440
&gt;&gt;Seth Ladd: Yeah.
&gt;&gt;&gt; Is the impact engine or other game engines,

00:46:33.440 --> 00:46:40.640
did they fix that?
And how do you stop people from hacking your

00:46:40.640 --> 00:46:42.430
game and changing the scores in the JavaScript
itself?

00:46:42.430 --> 00:46:45.730
&gt;&gt;Seth Ladd: Sure. Yeah.
So the first question, I don't -- I can't

00:46:45.730 --> 00:46:49.700
speak for them. I don't know really what they're
doing and I'm not fully up on what the standards

00:46:49.700 --> 00:46:53.481
bodies are doing with accessibility related
directly to canvas. That's a good question.

00:46:53.481 --> 00:46:55.560
But impact is here at the show. We can chat
with them.

00:46:55.560 --> 00:46:57.550
&gt;&gt;&gt; No. Just keyboard controls. They were
always a problem to have keyboard-enabled

00:46:57.550 --> 00:47:03.240
games.
&gt;&gt;Seth Ladd: Oh, oh, okay. So I -- so I've

00:47:03.240 --> 00:47:05.620
written games with impact that handle the
keyboard just fine, so yeah.

00:47:05.620 --> 00:47:09.210
&gt;&gt;&gt; Okay.
&gt;&gt;Seth Ladd: The second question was how do

00:47:09.210 --> 00:47:12.750
I stop people from hacking my game score?
Yeah, that's -- that's a tough one.

00:47:12.750 --> 00:47:19.340
So in the end of the day, you probably want
to keep honest people honest, so tools like

00:47:19.340 --> 00:47:23.720
GUID or Closure or any number of (inaudible)
obfuscation libraries for JavaScript will

00:47:23.720 --> 00:47:28.490
obfuscate all the code for you, make it a
little bit harder. But really with like Firebug

00:47:28.490 --> 00:47:32.820
and Developer Tools, you're going to be able
to go in and if you don't do a good job obfuscating

00:47:32.820 --> 00:47:37.690
your, like, local storage calls, for instance,
you can't stop the hacker on the local side.

00:47:37.690 --> 00:47:41.920
So I take that if I take that question and
go another step further, I think this really

00:47:41.920 --> 00:47:47.210
speaks to something like server replay of
the game so you can move your -- and this

00:47:47.210 --> 00:47:50.020
is where something like Node can really work
out, because if you write all your game in

00:47:50.020 --> 00:47:53.750
JavaScript and then you move that same logic
over into a server, replay all the moves,

00:47:53.750 --> 00:47:57.490
you can verify what they did.
And then for the monetization, for instance,

00:47:57.490 --> 00:48:00.600
that's where in-app payment is really kind
of powerful because they're buying all these

00:48:00.600 --> 00:48:02.810
virtual goods.
You almost just want your game to get out

00:48:02.810 --> 00:48:08.440
to as many people as possible and then you
start buying these items, so... yeah. Good

00:48:08.440 --> 00:48:12.280
question.
Let's see if we can take -- are there any

00:48:12.280 --> 00:48:15.660
other plans to support sequence like the -- ah,
okay. Are there -- okay.

00:48:15.660 --> 00:48:20.780
You would have to check in with the W3C audio
group for this. I don't know what their plans

00:48:20.780 --> 00:48:25.710
are. I think they're more or less agnostic
to the encoding format. They're just trying

00:48:25.710 --> 00:48:30.630
to get the audio to play, you know, frequently
and reliably, so I -- I don't know if there's

00:48:30.630 --> 00:48:40.680
any other plans to introduce these other formats.
Question.

00:48:40.680 --> 00:48:43.466
&gt;&gt;&gt; Does the current Chrome browser on the
Android platform support the hardware acceleration?

00:48:43.466 --> 00:48:45.590
&gt;&gt;Seth Ladd: That's a good question. So just
a correction there. The browser on Android

00:48:45.590 --> 00:48:49.360
is not Chrome. It's just a Webkit based browser.
&gt;&gt;&gt; Okay.

00:48:49.360 --> 00:48:54.050
&gt;&gt;Seth Ladd: And I don't know, unfortunately,
what Android's plans are for canvas acceleration.

00:48:54.050 --> 00:48:58.310
&gt;&gt;&gt; Are they currently supported?
&gt;&gt;Seth Ladd: I don't know. Sorry.

00:48:58.310 --> 00:49:00.710
&gt;&gt;&gt; Okay.
&gt;&gt;Seth Ladd: Although you might want to chat

00:49:00.710 --> 00:49:03.740
with Impact here at the show, for instance,
or Game Closure here at the show because they've

00:49:03.740 --> 00:49:09.849
figured out a way to get all that running
natively. Yeah. That's kind of cool.

00:49:09.849 --> 00:49:10.849
"How about using CoffeeScript" -- yeah. How
about it. That's pretty cool.

00:49:10.849 --> 00:49:18.520
Question in the back.
&gt;&gt;&gt; Yeah. I'm Indy Game Developer. You might

00:49:18.520 --> 00:49:28.570
have seen me on Congregate and New Grounds.
So I have a big library of flex. I have a

00:49:28.570 --> 00:49:29.820
big library of Silverlight. I'm not too proud
of that. Sorry.

00:49:29.820 --> 00:49:33.180
&gt;&gt;Seth Ladd: Uh-huh.
&gt;&gt;&gt; But anyway, so if I want to make a game

00:49:33.180 --> 00:49:38.440
with HTML5 but I've already written half of
it in flex, what's my best plan as far as

00:49:38.440 --> 00:49:40.660
migrating it?
&gt;&gt;Seth Ladd: Yeah. I'm not aware of anyone

00:49:40.660 --> 00:49:45.400
that will take you from Action Script 3, which
is I'm assuming what you built it in, back

00:49:45.400 --> 00:49:49.870
over to JavaScript, but I know that Untyped
Action Script is pretty close to JavaScript,

00:49:49.870 --> 00:49:52.240
so I don't know of any -- any tools there,
unfortunately.

00:49:52.240 --> 00:49:57.040
I will say, though, that, you know, with something
from the Chrome Web Store, I think it's very

00:49:57.040 --> 00:50:02.140
pragmatic, right? Like you can put Flash games
in the Chrome Web Store and, yes, this was

00:50:02.140 --> 00:50:05.970
a talk about HTML5, I definitely think it's
the future, but at the same time a lot of

00:50:05.970 --> 00:50:10.830
people have Action Script skills and have
written out games. And so I think stepping

00:50:10.830 --> 00:50:14.990
maybe one step back, as long as it's a great
game with great performance and plays well

00:50:14.990 --> 00:50:17.690
in the browser, I think that's what users
really care about.

00:50:17.690 --> 00:50:19.540
So --
&gt;&gt;&gt; My users apparently all run Linux.

00:50:19.540 --> 00:50:22.430
&gt;&gt;Seth Ladd: Aha. Okay. Well, sorry. You know,
I like Linux.

00:50:22.430 --> 00:50:28.840
I think we're running out of the good questions.
Let me see. "Any" --

00:50:28.840 --> 00:50:33.990
[Laughter]
"Will Google ever make a game." I don't know.

00:50:33.990 --> 00:50:36.690
"Any future plans to include a game plan controller?
Supports?"

00:50:36.690 --> 00:50:42.550
Yeah. I don't think there's anything concrete
here, but I think looking at the device API

00:50:42.550 --> 00:50:47.530
and re-approaching that as far as accessing
the microphone and the -- and the camera,

00:50:47.530 --> 00:50:50.340
I think the logical next step here is game
controllers as well.

00:50:50.340 --> 00:50:56.370
So I think that it's something on our minds
but I don't think there's anything concrete

00:50:56.370 --> 00:50:59.860
there.
I sort of answered that with Christian.

00:50:59.860 --> 00:51:04.950
And browsers and versions. I tested this on
FireFox 4 and Chrome 11, so...

00:51:04.950 --> 00:51:08.901
Okay. If there's no other questions, I think
we're all set, and again, thank you very much

00:51:08.901 --> 00:51:09.340
for your time.
[Applause]

