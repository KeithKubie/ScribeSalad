WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:03.140
In the last few videos, we
wrote a nice little program here

00:00:03.140 --> 00:00:05.750
that asks the user for
some type of an input,

00:00:05.750 --> 00:00:08.580
and then computes the
factorial of that number,

00:00:08.580 --> 00:00:09.970
and then prints it out.

00:00:09.970 --> 00:00:11.200
And that's nice.

00:00:11.200 --> 00:00:12.860
But you could
imagine a world where

00:00:12.860 --> 00:00:15.474
you would want to calculate
the factorial multiple places,

00:00:15.474 --> 00:00:16.890
or in multiple
different programs,

00:00:16.890 --> 00:00:18.764
or in the same program,
you want to calculate

00:00:18.764 --> 00:00:20.600
the factorial multiple times.

00:00:20.600 --> 00:00:22.760
And you don't want to have
to write this code over

00:00:22.760 --> 00:00:26.370
and over again every time you
want to calculate a factorial.

00:00:26.370 --> 00:00:28.090
So what I'm going
to do in this video

00:00:28.090 --> 00:00:31.810
is define a function that
calculates the factorial.

00:00:31.810 --> 00:00:33.920
And then we can use
that function every time

00:00:33.920 --> 00:00:35.550
we want to calculate
that factorial.

00:00:35.550 --> 00:00:37.591
So essentially, what that
function is going to do

00:00:37.591 --> 00:00:40.320
is going to put all of this
code right here in one place.

00:00:40.320 --> 00:00:41.840
And then any other
program that I

00:00:41.840 --> 00:00:45.020
want to calculate the factorial,
I can just recall that code.

00:00:45.020 --> 00:00:46.390
I don't have to rewrite it.

00:00:46.390 --> 00:00:48.660
So let me just show you
what I'm talking about.

00:00:48.660 --> 00:00:51.070
So I'm going to
define a function.

00:00:51.070 --> 00:00:54.132
And the key word in Python--
so it's a special word that

00:00:54.132 --> 00:00:56.090
tells the interpreter
that something special is

00:00:56.090 --> 00:00:58.310
about to happen-- the
key word in Python

00:00:58.310 --> 00:01:00.484
for defining a
function is d-e-f.

00:01:00.484 --> 00:01:01.900
So I'm going to
define a function.

00:01:01.900 --> 00:01:03.950
I'm going to call it
the factorial function.

00:01:03.950 --> 00:01:07.010
And it tends to be a
good idea to name things

00:01:07.010 --> 00:01:08.760
indicative of what
they actually do.

00:01:08.760 --> 00:01:11.030
Sometimes beginning
programmers have

00:01:11.030 --> 00:01:13.510
a habit of naming
things like x425.

00:01:13.510 --> 00:01:15.230
And someone who
comes in later will

00:01:15.230 --> 00:01:18.220
have no clue of what that
variable or that function

00:01:18.220 --> 00:01:18.792
is all about.

00:01:18.792 --> 00:01:20.500
So you definitely want
to somehow name it

00:01:20.500 --> 00:01:22.650
so it gives an idea of
what it's supposed to do.

00:01:22.650 --> 00:01:25.090
My function's called factorial.

00:01:25.090 --> 00:01:28.320
And the user, when
they call factorial,

00:01:28.320 --> 00:01:30.280
they need to tell
factorial what number

00:01:30.280 --> 00:01:32.420
am I going to take
the factorial of.

00:01:32.420 --> 00:01:36.370
So they're going to pass it
an argument called number.

00:01:36.370 --> 00:01:39.064
And if these words look
a little confusing,

00:01:39.064 --> 00:01:40.730
I'll explain them in
detail in a second.

00:01:40.730 --> 00:01:43.390
But you can just-- hopefully
the more you see this,

00:01:43.390 --> 00:01:47.110
the more familiar you'll
get with these ideas.

00:01:47.110 --> 00:01:50.180
And so they're going
to pass its number.

00:01:50.180 --> 00:01:52.360
And I'm just going to
have to return back

00:01:52.360 --> 00:01:53.655
to the calling program.

00:01:53.655 --> 00:01:55.030
And I actually
shouldn't even say

00:01:55.030 --> 00:01:56.446
the user's going
to pass a number.

00:01:56.446 --> 00:01:59.280
The calling program is
going to pass a number.

00:01:59.280 --> 00:02:02.600
And I need to return back
the factorial of that number

00:02:02.600 --> 00:02:03.719
to the calling program.

00:02:03.719 --> 00:02:05.760
So let me write this down
as a comment, actually.

00:02:09.539 --> 00:02:16.400
So returns the factorial
of the argument

00:02:16.400 --> 00:02:18.085
of the argument number.

00:02:18.085 --> 00:02:19.960
And sometimes you'll
hear the word parameter.

00:02:19.960 --> 00:02:21.810
Sometimes you'll hear
the word argument.

00:02:21.810 --> 00:02:24.120
When you're making a
definition of a function,

00:02:24.120 --> 00:02:26.060
this is more formally
called a parameter.

00:02:26.060 --> 00:02:31.460
Number is one of the parameters
to the factorial function.

00:02:31.460 --> 00:02:34.780
The actual number that
someone else passes to it--

00:02:34.780 --> 00:02:36.930
so let's say someone
calls factorial with a 3

00:02:36.930 --> 00:02:40.350
here-- then more formally,
that 3 would be the argument.

00:02:40.350 --> 00:02:44.250
So it returns the factorial
of the argument number.

00:02:44.250 --> 00:02:47.630
And this is the argument
number right over here.

00:02:47.630 --> 00:02:49.220
So I literally
mean-- I don't mean

00:02:49.220 --> 00:02:51.107
this is just arbitrarily
the word number.

00:02:51.107 --> 00:02:53.440
I'm literally talking about
this number right over here.

00:02:53.440 --> 00:02:55.727
Maybe I'll say the
argument number.

00:02:55.727 --> 00:02:57.560
Maybe I'll put it in
quotes to make it clear

00:02:57.560 --> 00:02:59.152
that this is the argument.

00:02:59.152 --> 00:03:00.860
I'm not talking about
any general number.

00:03:00.860 --> 00:03:02.250
And let's define it.

00:03:02.250 --> 00:03:05.460
So we're going to use the
same code essentially.

00:03:05.460 --> 00:03:08.570
Actually, let me
just copy and paste

00:03:08.570 --> 00:03:10.440
a lot of what I took over here.

00:03:10.440 --> 00:03:11.770
So I'm going to cut that out.

00:03:11.770 --> 00:03:13.700
And I'm going to
repaste it over here.

00:03:13.700 --> 00:03:16.080
But I have to be careful
about my indentations,

00:03:16.080 --> 00:03:18.570
because indentations
are how Python

00:03:18.570 --> 00:03:19.930
knows what's part of what.

00:03:19.930 --> 00:03:21.860
It knows how to
interpret things.

00:03:21.860 --> 00:03:24.440
So everything that's part
of this function definition

00:03:24.440 --> 00:03:25.800
has to be indented.

00:03:25.800 --> 00:03:29.410
And we do it by four spaces--
one, two, three, four.

00:03:29.410 --> 00:03:32.140
And this is another
four, two, three, four.

00:03:32.140 --> 00:03:35.070
And then this is part of the
for loop, one, two, three, four.

00:03:35.070 --> 00:03:37.020
And let's think about
what we have so far.

00:03:37.020 --> 00:03:39.680
So it's going to be
passed some number.

00:03:39.680 --> 00:03:43.050
We define this variable
product equals 1.

00:03:43.050 --> 00:03:45.250
And we'll talk more about
scoping of variables.

00:03:45.250 --> 00:03:48.170
But this variable is
only going to be usable

00:03:48.170 --> 00:03:50.437
within this
factorial definition,

00:03:50.437 --> 00:03:52.770
because the first time I
defined it right here is inside

00:03:52.770 --> 00:03:54.200
of this right here.

00:03:54.200 --> 00:03:57.410
So we'll go more into scoping
of variables in the future.

00:03:57.410 --> 00:04:00.270
And then the same logic
we did before, for i

00:04:00.270 --> 00:04:03.360
in range of number-- now
we're not getting number

00:04:03.360 --> 00:04:06.360
using the input function.

00:04:06.360 --> 00:04:08.300
It's being passed
to the function.

00:04:08.300 --> 00:04:11.280
Then product is equal to product
times i plus 1, same logic

00:04:11.280 --> 00:04:12.600
as we had before.

00:04:12.600 --> 00:04:14.587
So after you go
through this for loop--

00:04:14.587 --> 00:04:16.420
after you go through
it-- you're essentially

00:04:16.420 --> 00:04:18.490
going to go through
number times,

00:04:18.490 --> 00:04:21.560
product will have in it
the factorial of number.

00:04:21.560 --> 00:04:24.120
Instead of outputting it
directly, what we want to do

00:04:24.120 --> 00:04:25.380
is return.

00:04:25.380 --> 00:04:27.521
We're going to return it
to the calling program.

00:04:27.521 --> 00:04:29.520
And in the next video,
I'm going to diagram this

00:04:29.520 --> 00:04:31.190
out a little bit
cleaner if this seems

00:04:31.190 --> 00:04:32.850
a little bit confusing to you.

00:04:32.850 --> 00:04:35.050
I'm going to return product.

00:04:35.050 --> 00:04:38.000
So it's essentially the exact
same code as we had before.

00:04:38.000 --> 00:04:40.360
But we've packaged it
inside of a function.

00:04:40.360 --> 00:04:42.510
We've defined a
function, takes it,

00:04:42.510 --> 00:04:44.420
it has a parameter
called a number.

00:04:44.420 --> 00:04:47.316
If you pass factorial-- if
you want a factorial of 3,

00:04:47.316 --> 00:04:48.440
you'd write factorial of 3.

00:04:48.440 --> 00:04:50.450
And 3 would be the
argument, the thing that's

00:04:50.450 --> 00:04:52.550
being put in the place
of the variable number,

00:04:52.550 --> 00:04:54.470
or the thing that
number is referring to.

00:04:54.470 --> 00:04:56.760
You define product
is equal to 1.

00:04:56.760 --> 00:04:59.596
And then, you go number times.

00:04:59.596 --> 00:05:01.220
So for i in range of
number-- and we've

00:05:01.220 --> 00:05:04.180
explained the logic of that in
the previous video-- every time

00:05:04.180 --> 00:05:05.060
you start with 1.

00:05:05.060 --> 00:05:07.695
And then you do 1 times
1 is going to be 1.

00:05:07.695 --> 00:05:09.070
And then product's
going to be 1.

00:05:09.070 --> 00:05:10.890
But then i's going to be 1.

00:05:10.890 --> 00:05:12.000
i starts off at 0.

00:05:12.000 --> 00:05:15.290
So it's going to be 1
times 0 plus 1 gives you 1.

00:05:19.650 --> 00:05:20.700
Then i is 1.

00:05:20.700 --> 00:05:23.900
And so it's going to be 1 times
1 plus 1, which is 1 times 2.

00:05:23.900 --> 00:05:25.339
And so it's going to be 2, then.

00:05:25.339 --> 00:05:26.880
And it'll keep
incrementing that way.

00:05:26.880 --> 00:05:28.920
And we explain that in
detail in the last video.

00:05:28.920 --> 00:05:31.450
And then finally, it's going
to return that product.

00:05:31.450 --> 00:05:34.305
So if we want to have
the same exact behavior

00:05:34.305 --> 00:05:38.150
as before, but now we're using
this function, what we could do

00:05:38.150 --> 00:05:41.552
is-- we could say, we'll
still have the input.

00:05:41.552 --> 00:05:43.010
So this is our
function definition.

00:05:43.010 --> 00:05:44.830
But then, along
our main program,

00:05:44.830 --> 00:05:46.490
we've defined our function.

00:05:46.490 --> 00:05:49.060
And now, we can just
say, look, from the user,

00:05:49.060 --> 00:05:52.410
get a non-negative integer
to take the factorial of.

00:05:52.410 --> 00:05:54.320
And let's put that
into-- let's call

00:05:54.320 --> 00:05:59.320
that a variable
called user input.

00:05:59.320 --> 00:06:01.530
And then what I'm
going to do is I'm

00:06:01.530 --> 00:06:10.322
going to define another variable
called factorial of user input.

00:06:10.322 --> 00:06:12.030
And now, this is going
to be interesting.

00:06:12.030 --> 00:06:14.610
I'm going to call
this function up here.

00:06:14.610 --> 00:06:17.150
So this is going to
be equal to factorial

00:06:17.150 --> 00:06:23.140
of whatever the user had input,
so the factorial of user input,

00:06:23.140 --> 00:06:26.010
the factorial of this
variable right over here,

00:06:26.010 --> 00:06:28.950
the factorial of user input.

00:06:28.950 --> 00:06:31.270
So now, factorial of user
input will be storing--

00:06:31.270 --> 00:06:32.645
or I guess we
should say, it will

00:06:32.645 --> 00:06:34.500
be pointing to
the actual answer.

00:06:34.500 --> 00:06:36.570
And now, we just
have to print it out.

00:06:36.570 --> 00:06:38.390
So now we can print.

00:06:38.390 --> 00:06:43.480
And now we can print
factorial of user input.

00:06:43.480 --> 00:06:45.514
So they look like sentences.

00:06:45.514 --> 00:06:46.930
But these are just
variable names.

00:06:46.930 --> 00:06:48.600
And I'm naming this
way so you really

00:06:48.600 --> 00:06:50.183
know what's inside
of those variables,

00:06:50.183 --> 00:06:52.510
or what those variables
are really pointing to.

00:06:52.510 --> 00:06:56.450
So factorial of user input.

00:06:56.450 --> 00:07:01.811
Now the moment of truth is
always saving the program

00:07:01.811 --> 00:07:03.060
and actually trying to run it.

00:07:03.060 --> 00:07:06.370
So let's try to run it right
now and see what happens.

00:07:06.370 --> 00:07:08.970
Let's see what happens here.

00:07:08.970 --> 00:07:11.360
So at least nothing
broke so far.

00:07:11.360 --> 00:07:13.929
So once again, so
I want to be clear.

00:07:13.929 --> 00:07:14.970
The program started here.

00:07:14.970 --> 00:07:17.070
But up here, all we
did is define this.

00:07:17.070 --> 00:07:19.576
So it's not actually
telling-- it's not

00:07:19.576 --> 00:07:21.200
creating any interaction
with the user.

00:07:21.200 --> 00:07:23.158
It's actually not processing
anything just yet.

00:07:23.158 --> 00:07:24.667
So it just defines
this function.

00:07:24.667 --> 00:07:26.250
Then it goes down
to here and it says,

00:07:26.250 --> 00:07:27.990
OK, look, get some
input from the user.

00:07:27.990 --> 00:07:29.930
And that's what we're
doing right here.

00:07:29.930 --> 00:07:32.340
And after we input
some number here,

00:07:32.340 --> 00:07:34.890
then it's going to go--
it's going to actually call

00:07:34.890 --> 00:07:37.320
this function with that
number that we put.

00:07:37.320 --> 00:07:39.940
The number that we put's going
to go put in the user input.

00:07:39.940 --> 00:07:42.660
And then it's going to call
factorial with user input

00:07:42.660 --> 00:07:43.355
as an argument.

00:07:47.060 --> 00:07:48.940
So let's try it
with the number 3.

00:07:48.940 --> 00:07:52.280
And it did not work.

00:07:52.280 --> 00:07:53.790
Oh, and I see why
it did not work,

00:07:53.790 --> 00:07:56.684
because I had this left over
from the previous program,

00:07:56.684 --> 00:07:58.100
which actually
makes no sense now.

00:07:58.100 --> 00:08:00.050
So let me get rid of that.

00:08:00.050 --> 00:08:02.110
It's a good lesson that
seldom on the first try

00:08:02.110 --> 00:08:04.262
does something work perfectly.

00:08:04.262 --> 00:08:04.970
Let me try again.

00:08:04.970 --> 00:08:06.678
That was just nonsense
that I didn't even

00:08:06.678 --> 00:08:07.730
realize was down there.

00:08:07.730 --> 00:08:09.520
So let me try it again.

00:08:09.520 --> 00:08:10.520
So let me try.

00:08:10.520 --> 00:08:12.940
So a 3 again.

00:08:12.940 --> 00:08:15.380
And it gave me a good answer.

00:08:15.380 --> 00:08:16.790
It gave me the factorial of 3.

00:08:16.790 --> 00:08:20.380
And what's cool now is because
now my Python interpreter is

00:08:20.380 --> 00:08:23.212
assuming that this
definition has been made,

00:08:23.212 --> 00:08:25.670
I can now call the factorial
straight from the interpreter.

00:08:25.670 --> 00:08:27.680
If I had another program, I
could call it in multiple ways.

00:08:27.680 --> 00:08:29.420
And now, you should
hopefully appreciate

00:08:29.420 --> 00:08:31.310
why it's cool that
we made this function

00:08:31.310 --> 00:08:33.250
definition, because
now we can calculate,

00:08:33.250 --> 00:08:35.679
because I've defined
this function factorial,

00:08:35.679 --> 00:08:38.270
I can calculate
the factorial of 4.

00:08:38.270 --> 00:08:39.080
It's 24.

00:08:39.080 --> 00:08:50.560
I could say the factorial of 5
minus the factorial of 3, 114.

00:08:50.560 --> 00:08:52.269
I can take the factorial of 12.

00:08:52.269 --> 00:08:54.560
And you can tell the computer,
even though this is just

00:08:54.560 --> 00:08:56.560
interpreting all of this--
we'll talk more about

00:08:56.560 --> 00:09:00.010
interpreted versus compiled
code-- it's incredibly fast,

00:09:00.010 --> 00:09:02.520
faster than we can
really even fathom.

00:09:02.520 --> 00:09:04.840
So this is a real
power of a function

00:09:04.840 --> 00:09:07.580
is that I don't have to rewrite
the code every time now.

00:09:07.580 --> 00:09:10.510
I can just call it with
different arguments.

00:09:10.510 --> 00:09:11.760
So factorial of 2.

00:09:11.760 --> 00:09:12.850
I can do it every time.

00:09:12.850 --> 00:09:14.690
I don't have to
rerun the program.

00:09:14.690 --> 00:09:16.840
And if I write other
programs that use factorial,

00:09:16.840 --> 00:09:18.720
maybe I do some
things in [INAUDIBLE],

00:09:18.720 --> 00:09:21.510
I can just use
this as a function.

00:09:21.510 --> 00:09:25.670
In fact, I don't
even have to know

00:09:25.670 --> 00:09:27.380
what's going on
inside the function.

00:09:27.380 --> 00:09:33.290
And one of the other
powerful aspects of functions

00:09:33.290 --> 00:09:35.996
is that-- let's say I write
a bunch of programs that

00:09:35.996 --> 00:09:37.870
call-- so I have this
program right here that

00:09:37.870 --> 00:09:38.787
calls factorial.

00:09:38.787 --> 00:09:40.620
But let's say that you
come up with a better

00:09:40.620 --> 00:09:42.790
way of writing this
right over here.

00:09:42.790 --> 00:09:47.400
As long as your program,
that does the same thing

00:09:47.400 --> 00:09:49.930
with different guts, the
end user won't notice.

00:09:49.930 --> 00:09:52.090
So maybe you write a faster
way, or a simpler way,

00:09:52.090 --> 00:09:55.600
of doing this, a way that uses
less memory or less CPU power,

00:09:55.600 --> 00:09:57.559
then you could just
replace this later on.

00:09:57.559 --> 00:09:59.100
And then the
[INAUDIBLE] program that

00:09:59.100 --> 00:10:01.244
calls it, as long
as it still works,

00:10:01.244 --> 00:10:02.410
it'll work for that program.

00:10:02.410 --> 00:10:04.657
And it'll just work
that much better.

