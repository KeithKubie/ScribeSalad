WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:16.269
[MUSIC PLAYING]

00:00:26.622 --> 00:00:27.510
PAUL SAXMAN: Hello, everybody.

00:00:27.510 --> 00:00:29.470
And welcome to this week's
episode of Google Maps

00:00:29.470 --> 00:00:30.640
Developers Live.

00:00:30.640 --> 00:00:31.790
I'm Paul Saxman.

00:00:31.790 --> 00:00:33.620
With me this week is--

00:00:33.620 --> 00:00:35.030
MANO MARKS: Mano Marks.

00:00:35.030 --> 00:00:38.390
PAUL SAXMAN: And today, we're
going to talk about importing,

00:00:38.390 --> 00:00:41.550
modifying, and exporting
data from Google Maps.

00:00:41.550 --> 00:00:45.840
The idea is that data comes in
a lot of different formats.

00:00:45.840 --> 00:00:49.030
What's the easiest way, I think,
to get the data into

00:00:49.030 --> 00:00:52.400
Google Maps, modify
that data--

00:00:52.400 --> 00:00:55.190
because sometimes data doesn't
look quite right, and there's

00:00:55.190 --> 00:00:58.190
some really, really simple
tricks for actually modifying

00:00:58.190 --> 00:01:01.590
data within a Google Map-- and
then exporting the data so

00:01:01.590 --> 00:01:04.220
that you can re-import
it for later use.

00:01:04.220 --> 00:01:06.140
Mano, on the other hand,
is going to talk

00:01:06.140 --> 00:01:07.430
about something similar.

00:01:07.430 --> 00:01:07.990
But--

00:01:07.990 --> 00:01:12.130
MANO MARKS: I'm going to revisit
a demo that I did this

00:01:12.130 --> 00:01:17.220
fall, which is parsing a
shapefile, which is a

00:01:17.220 --> 00:01:20.470
geographic information
systems format,

00:01:20.470 --> 00:01:22.180
directly in the browser.

00:01:22.180 --> 00:01:26.780
So we're going to get into a
little bit of HTML5 and talk

00:01:26.780 --> 00:01:31.650
about the nitty gritties
of DataView and

00:01:31.650 --> 00:01:33.730
byte-by-byte access.

00:01:33.730 --> 00:01:34.480
PAUL SAXMAN: Right.

00:01:34.480 --> 00:01:36.830
So I'm going to be Mr.
Basic, and you're

00:01:36.830 --> 00:01:39.560
going to be Mr. Advanced.

00:01:39.560 --> 00:01:41.020
So the approach I took
was actually

00:01:41.020 --> 00:01:42.950
just the bare minimum.

00:01:42.950 --> 00:01:46.920
So what I wanted to do was to
see if I had a file in kind of

00:01:46.920 --> 00:01:51.120
the ideal format, how could I
get that into the Google Map

00:01:51.120 --> 00:01:53.540
as quickly and easily as
possible, like I said,

00:01:53.540 --> 00:01:56.280
manipulate it if the data
doesn't look quite right, and

00:01:56.280 --> 00:01:57.340
then export it out.

00:01:57.340 --> 00:02:02.020
And each of these steps takes a
few lines of code, which I'm

00:02:02.020 --> 00:02:03.840
going to start off
and show you now.

00:02:03.840 --> 00:02:06.970
So what I started with is
this visualization we

00:02:06.970 --> 00:02:07.780
did a few weeks ago.

00:02:07.780 --> 00:02:11.225
This is the CLIWOC ship data.

00:02:11.225 --> 00:02:14.770
I'm not too sure these polylines
are too visible on

00:02:14.770 --> 00:02:15.560
your screen right now.

00:02:15.560 --> 00:02:17.080
But we have a number
of polylines here

00:02:17.080 --> 00:02:20.700
rendered on this map.

00:02:20.700 --> 00:02:22.030
So just for a little
more context, a

00:02:22.030 --> 00:02:24.260
CLIWOC database, it's--

00:02:24.260 --> 00:02:28.720
what is it, 25,000
ship voyages?

00:02:28.720 --> 00:02:30.180
MANO MARKS: I don't
remember how many.

00:02:30.180 --> 00:02:32.890
I know it's 275,000
data points.

00:02:32.890 --> 00:02:33.840
PAUL SAXMAN: Data points.

00:02:33.840 --> 00:02:35.860
Yeah, so there's just
a ton of data.

00:02:35.860 --> 00:02:37.430
We gave a couple
presentations--

00:02:37.430 --> 00:02:39.205
I think that was a
few weeks ago--

00:02:39.205 --> 00:02:41.470
on this data set and these
visualizations.

00:02:41.470 --> 00:02:44.930
So this is just kind of a
continuation of that.

00:02:44.930 --> 00:02:50.520
So it's 250,000-plus points,
25,000 or more voyages.

00:02:50.520 --> 00:02:51.570
So it's quite a bit of data.

00:02:51.570 --> 00:02:53.850
We're not showing it all on
the screen right now.

00:02:53.850 --> 00:02:56.260
I have the slider in
here to actually--

00:02:56.260 --> 00:03:01.510
this goes, I think, a range
of about 20 or 30--

00:03:01.510 --> 00:03:02.550
no, it's even more than that--

00:03:02.550 --> 00:03:05.960
I think about 50 actual
voyages at a time.

00:03:05.960 --> 00:03:07.730
So you can see there's
a very rich data set.

00:03:07.730 --> 00:03:08.650
There's a lot of data in here.

00:03:08.650 --> 00:03:11.880
But as I'm scrolling along, you
can see things like the

00:03:11.880 --> 00:03:16.000
polylines actually intersecting
or laying over

00:03:16.000 --> 00:03:19.520
the land mass, which is
obviously not something you

00:03:19.520 --> 00:03:21.155
expect to see in a
ship database.

00:03:26.210 --> 00:03:28.990
So by the way, the
two episodes--

00:03:28.990 --> 00:03:30.780
I think they were about three
weeks ago that we did these,

00:03:30.780 --> 00:03:32.660
or four weeks ago--

00:03:32.660 --> 00:03:34.350
you can go back and see kind
of how we built these

00:03:34.350 --> 00:03:35.020
visualizations.

00:03:35.020 --> 00:03:37.600
We talk about the techniques
we used and go through the

00:03:37.600 --> 00:03:40.600
code for actually
building these.

00:03:40.600 --> 00:03:43.210
But this one we showed
previously, as well.

00:03:43.210 --> 00:03:46.590
This, actually, is all
the data on one

00:03:46.590 --> 00:03:47.990
map at a single time.

00:03:47.990 --> 00:03:51.310
And what I did is, actually,
I put mouse event

00:03:51.310 --> 00:03:52.880
listeners on here.

00:03:52.880 --> 00:04:00.445
So as I mouse over these, I'm
actually changing the opacity

00:04:00.445 --> 00:04:03.430
and width of the polyline
dynamically, as we're doing

00:04:03.430 --> 00:04:05.470
mouse-over events.

00:04:05.470 --> 00:04:08.090
And you can see here, like if I
highlight some of these guys

00:04:08.090 --> 00:04:11.990
here, we have some kind of
crazy, messy polylines.

00:04:11.990 --> 00:04:14.630
I'm not too sure if this was
actually in the original

00:04:14.630 --> 00:04:18.760
processing step that we did to
get the data out of the CLIWOC

00:04:18.760 --> 00:04:22.440
database into JSON, which I'm
going to talk about in a

00:04:22.440 --> 00:04:24.260
little bit.

00:04:24.260 --> 00:04:28.240
But it's just worth using as a
sample case for messy data.

00:04:28.240 --> 00:04:30.700
And so you can see this polyline
here that I mouse

00:04:30.700 --> 00:04:32.810
over, this orange is England.

00:04:32.810 --> 00:04:35.700
This was a ship to, I believe
it was Indonesia.

00:04:35.700 --> 00:04:39.640
And there's quite a few points
that are kind of out of

00:04:39.640 --> 00:04:42.930
sequence, which, to me,
would mean actually

00:04:42.930 --> 00:04:45.330
just bad time stamps.

00:04:45.330 --> 00:04:49.185
So what I did for
this week is--

00:04:49.185 --> 00:04:51.590
whoops, that's not mine--

00:04:51.590 --> 00:04:55.540
is I took the exact same data
set, pretty much the exact

00:04:55.540 --> 00:04:56.480
same visualization.

00:04:56.480 --> 00:04:58.720
But I'm just doing one
line at a time.

00:04:58.720 --> 00:05:01.450
I actually kind of made them a
little bit wider so that we

00:05:01.450 --> 00:05:05.730
can a little more easily get
the mouse-over event.

00:05:05.730 --> 00:05:08.180
And now the slider actually
just goes

00:05:08.180 --> 00:05:09.740
one voyage at a time.

00:05:09.740 --> 00:05:11.730
So you can see here, as I slide
from left to right, I'm

00:05:11.730 --> 00:05:13.290
just going voyage by voyage.

00:05:13.290 --> 00:05:16.360
The little number on the top
left there, which is 1493

00:05:16.360 --> 00:05:19.430
right now, that's just the
identifier from the

00:05:19.430 --> 00:05:21.220
original data set.

00:05:21.220 --> 00:05:26.610
And these are actually ordered
chronologically, I believe.

00:05:26.610 --> 00:05:28.350
So what I did, though, with
this visualization--

00:05:28.350 --> 00:05:30.430
so this is kind of fun, just
to look at the data.

00:05:30.430 --> 00:05:33.730
We found a messy one there.

00:05:33.730 --> 00:05:35.790
That actually just looks like
an inverted lat/long.

00:05:38.790 --> 00:05:41.820
So what I did with this one is
the mouse event-- what happens

00:05:41.820 --> 00:05:45.020
now is, actually, I'm making
the polyline editable.

00:05:45.020 --> 00:05:47.580
And this is actually a feature
of the Google Maps API.

00:05:47.580 --> 00:05:52.340
So a polyline has a setEditable,
getEditable,

00:05:52.340 --> 00:05:54.710
mutator, and accessor
method on it.

00:05:54.710 --> 00:05:56.130
And I think it's also
a property in

00:05:56.130 --> 00:05:59.830
the polyline options.

00:05:59.830 --> 00:06:03.470
So you can make it editable
by default.

00:06:03.470 --> 00:06:06.370
But this time, what I did is
just, as I mouse-click, I

00:06:06.370 --> 00:06:08.340
switch the polyline
to editable.

00:06:08.340 --> 00:06:12.780
Then what I can do is I have
listeners on these markers

00:06:12.780 --> 00:06:15.510
here, or these controls,
on the polyline.

00:06:15.510 --> 00:06:19.010
So if I click one of these,
actually, what I'm going to do

00:06:19.010 --> 00:06:21.140
is delete it.

00:06:21.140 --> 00:06:24.230
You see now my data looks
nice and clean.

00:06:24.230 --> 00:06:27.260
The other thing that you can
do with these-- and this is

00:06:27.260 --> 00:06:29.370
kind of a little more advanced,
and I didn't really

00:06:29.370 --> 00:06:32.740
cover this in the code--

00:06:32.740 --> 00:06:36.150
so you see here that there's
two shades of markers, or

00:06:36.150 --> 00:06:37.780
controls, on these polylines.

00:06:37.780 --> 00:06:39.940
The dark ones are actually
ones that are part of the

00:06:39.940 --> 00:06:41.150
original data set.

00:06:41.150 --> 00:06:43.400
And the light ones
are virtual ones.

00:06:43.400 --> 00:06:45.980
So if I grab one of these and
drag it, it will actually

00:06:45.980 --> 00:06:49.500
create a new point in
the polyline path.

00:06:49.500 --> 00:06:53.460
So the ones that are
fully opaque, I

00:06:53.460 --> 00:06:54.930
can drag those around.

00:06:54.930 --> 00:06:57.300
And you get a little undo.

00:06:57.300 --> 00:07:00.580
And the ones that are slightly
transparent, if I grab one of

00:07:00.580 --> 00:07:03.310
those and drag it, it
becomes a real node.

00:07:03.310 --> 00:07:05.100
And also, once again, you
get the little undo.

00:07:05.100 --> 00:07:07.970
And you can only undo once.

00:07:07.970 --> 00:07:12.750
So again, this is all kind of
default functionality or basic

00:07:12.750 --> 00:07:14.630
functionality of the Maps API.

00:07:14.630 --> 00:07:18.782
I can c you a little bit
of code, how I do this.

00:07:18.782 --> 00:07:23.340
So let's get Sublime Text
a little bigger.

00:07:23.340 --> 00:07:27.140
And then I'll go back and show
you some of the techniques I

00:07:27.140 --> 00:07:28.470
use for loading the data in.

00:07:28.470 --> 00:07:30.390
MANO MARKS: Can you bump
the font up a bit?

00:07:30.390 --> 00:07:32.230
PAUL SAXMAN: Absolutely.

00:07:32.230 --> 00:07:33.480
How's that?

00:07:37.520 --> 00:07:40.095
So this is the polylines3,
the last one that I

00:07:40.095 --> 00:07:42.010
just showed you here.

00:07:42.010 --> 00:07:43.830
So first, I'm going to show
you, actually, the event

00:07:43.830 --> 00:07:46.590
handling that I did for
making it editable.

00:07:46.590 --> 00:07:48.510
And you'll be amazed at
how simple it is.

00:07:51.120 --> 00:07:53.590
So I have a method in here
called create polylines, which

00:07:53.590 --> 00:07:58.410
just allows me to do a closure
around attaching events to the

00:07:58.410 --> 00:08:01.430
polyline when I create it,
instead of just creating it in

00:08:01.430 --> 00:08:05.920
a loop, which makes it a lot
harder to attach events.

00:08:05.920 --> 00:08:08.550
So what I'm doing here is I just
have a listener, a click

00:08:08.550 --> 00:08:09.800
event listener, on
the polyline.

00:08:12.500 --> 00:08:14.820
And so here, I'm
checking if the

00:08:14.820 --> 00:08:17.830
event.vertex is not undefined.

00:08:17.830 --> 00:08:20.620
So I'm basically saying,
have I clicked on a

00:08:20.620 --> 00:08:23.550
vertex on the polyline?

00:08:23.550 --> 00:08:27.000
And if not, I'm just going to
make the polyline editable.

00:08:27.000 --> 00:08:30.130
So the vertex event only occurs
if you're already in

00:08:30.130 --> 00:08:31.930
the editable mode.

00:08:31.930 --> 00:08:34.539
If you're not in the editable
mode, I'm just going to make

00:08:34.539 --> 00:08:36.740
the polyline editable.

00:08:36.740 --> 00:08:37.840
So you click the polyline.

00:08:37.840 --> 00:08:41.179
If it's not in editable mode,
it's going to become editable.

00:08:41.179 --> 00:08:43.370
Otherwise, if it already is
editable and you click on a

00:08:43.370 --> 00:08:45.880
vertex, then I'm going to
execute this code in this

00:08:45.880 --> 00:08:47.290
statement here.

00:08:47.290 --> 00:08:50.820
And so here, what I'm doing is
I'm just taking the line,

00:08:50.820 --> 00:08:53.140
getting the path, and removing
the vertex at that particular

00:08:53.140 --> 00:08:59.100
index, because that's actually
taking it out of the path for

00:08:59.100 --> 00:09:01.190
the polyline.

00:09:01.190 --> 00:09:03.250
And then here, I'm actually
going back to my original data

00:09:03.250 --> 00:09:08.220
set and taking that vertex out
of the original data set.

00:09:08.220 --> 00:09:09.290
And this was pretty easy.

00:09:09.290 --> 00:09:11.590
All I did earlier, when
I loaded the code, is

00:09:11.590 --> 00:09:12.670
I assigned an index.

00:09:12.670 --> 00:09:16.020
So this is going from a polyline
back to my original

00:09:16.020 --> 00:09:19.750
data set index, and so
getting that out.

00:09:19.750 --> 00:09:24.140
And I'm deleting the element
from the array.

00:09:24.140 --> 00:09:26.340
This is a little bit of a tricky
statement, just because

00:09:26.340 --> 00:09:28.470
when you delete an
item out of an

00:09:28.470 --> 00:09:30.760
array, it becomes undefined.

00:09:30.760 --> 00:09:35.820
But it doesn't matter in our
case, because everything works

00:09:35.820 --> 00:09:37.930
out the way we expect.

00:09:37.930 --> 00:09:40.380
And I'll explain that
in just a minute.

00:09:40.380 --> 00:09:44.960
So another thing that I put in
this visualization here so we

00:09:44.960 --> 00:09:45.820
could edit it--

00:09:45.820 --> 00:09:47.800
so of course, once you've edited
the data, you want to

00:09:47.800 --> 00:09:50.270
get it back out so that you
can actually use it later.

00:09:50.270 --> 00:09:51.670
I put this little button
way up at the top.

00:09:51.670 --> 00:09:52.580
It's a little bit small.

00:09:52.580 --> 00:09:54.950
Let's see if I can zoom in.

00:09:54.950 --> 00:09:56.340
There we go.

00:09:56.340 --> 00:09:57.840
And click that guy here.

00:09:57.840 --> 00:09:58.960
It opens up a new window.

00:09:58.960 --> 00:10:01.010
It sits here for a little bit,
because I'm actually doing

00:10:01.010 --> 00:10:05.470
document.write for the
entire data set.

00:10:05.470 --> 00:10:08.232
And you can see here, we have
the data back out again--

00:10:08.232 --> 00:10:10.850
oops, there we go, make it
a little bit bigger.

00:10:10.850 --> 00:10:12.970
So you can see this might look
a little bit familiar.

00:10:12.970 --> 00:10:16.570
It's actually just
JSON format.

00:10:16.570 --> 00:10:17.740
So that's the trick
for actually

00:10:17.740 --> 00:10:19.030
importing and exporting.

00:10:19.030 --> 00:10:21.320
And I'll show you that now.

00:10:21.320 --> 00:10:24.100
So importing the code,
even easier.

00:10:24.100 --> 00:10:25.510
So exporting is in JSON.

00:10:25.510 --> 00:10:28.500
But importing is actually
a little bit easier.

00:10:28.500 --> 00:10:29.930
All I did for importing--

00:10:29.930 --> 00:10:33.070
and I said I'm going to do the
very basics here today--

00:10:33.070 --> 00:10:37.260
is-- no, I don't want
that guy here--

00:10:37.260 --> 00:10:39.130
the whole data set actually
takes quite a long time to

00:10:39.130 --> 00:10:42.410
load into Sublime.

00:10:42.410 --> 00:10:46.360
So basically, I just formatted
my data kind of in this format

00:10:46.360 --> 00:10:54.850
here to load it into my map.

00:10:54.850 --> 00:10:57.210
So basically, I just have
the path objects--

00:10:57.210 --> 00:11:00.000
in each of those, the ID, which
I mentioned earlier, is

00:11:00.000 --> 00:11:02.030
the ID from the original
data set--

00:11:02.030 --> 00:11:04.260
the countries, which I
use for coloring, and

00:11:04.260 --> 00:11:05.220
then the entire path.

00:11:05.220 --> 00:11:06.670
So the path is what
I use for actually

00:11:06.670 --> 00:11:08.290
generating the polylines.

00:11:08.290 --> 00:11:11.660
So this is actually a JavaScript
script, not a

00:11:11.660 --> 00:11:15.030
JavaScript JSON object
or JSON file.

00:11:15.030 --> 00:11:18.330
So the benefit of using a script
instead of JSON for

00:11:18.330 --> 00:11:21.310
loading files is I can just add
the script tag, and it'll

00:11:21.310 --> 00:11:25.530
actually just assign this to
my global context for my

00:11:25.530 --> 00:11:26.610
application.

00:11:26.610 --> 00:11:28.770
If you're using JSON, what you
have to do is you have to put

00:11:28.770 --> 00:11:34.010
the JSON in a file, you have to
do an XHR request to load

00:11:34.010 --> 00:11:35.730
the data, and then you actually
have to send the data

00:11:35.730 --> 00:11:43.400
to the JSON parser to get
in your visualization.

00:11:43.400 --> 00:11:45.900
So the benefit of this is that
you don't need to do all the

00:11:45.900 --> 00:11:48.590
extra coding to actually get
the data into your map.

00:11:48.590 --> 00:11:51.400
The negative side is this
really isn't portable.

00:11:51.400 --> 00:11:54.820
So this data is really specific
to my application.

00:11:54.820 --> 00:11:56.350
Other people can actually
load the data.

00:11:56.350 --> 00:12:00.370
But the catch is that this
variable may already be

00:12:00.370 --> 00:12:04.800
assigned within the global scope
for their application.

00:12:04.800 --> 00:12:07.110
So if somebody wants to use this
data, they'd have to say,

00:12:07.110 --> 00:12:10.500
well, I have to make sure
that I'm assigning this.

00:12:10.500 --> 00:12:14.380
Actually, I think in my data
set, I use data equals.

00:12:14.380 --> 00:12:17.380
Data is the variable name, which
is probably the least

00:12:17.380 --> 00:12:18.490
generic version--

00:12:18.490 --> 00:12:19.610
or the most.

00:12:19.610 --> 00:12:21.840
Anyways, it's probably the
worst naming convention I

00:12:21.840 --> 00:12:23.550
could use for portability.

00:12:23.550 --> 00:12:28.560
But for my visualization, just
for my personal use, it was

00:12:28.560 --> 00:12:30.370
pretty straightforward to use.

00:12:30.370 --> 00:12:32.640
You can see here, all I'm
doing is just creating a

00:12:32.640 --> 00:12:36.250
script tag, loading that file,
and then all that data is

00:12:36.250 --> 00:12:37.880
available to my application.

00:12:37.880 --> 00:12:42.350
So it's really just getting
the data in JavaScript

00:12:42.350 --> 00:12:45.860
notation and loading script.

00:12:45.860 --> 00:12:49.150
I do have to go through a little
bit of manipulation,

00:12:49.150 --> 00:12:54.510
because those lat/longs in the
original file, I actually have

00:12:54.510 --> 00:12:56.710
to convert those to Google
Maps lat/longs.

00:12:56.710 --> 00:12:59.530
I could actually put this in
the original source file,

00:12:59.530 --> 00:13:01.790
because it is JavaScript.

00:13:01.790 --> 00:13:04.480
It'll just run when I actually
load that script tag.

00:13:04.480 --> 00:13:07.750
But I like to kind of keep the
data a little easier to read

00:13:07.750 --> 00:13:09.300
instead of using these
Google Map lat/longs.

00:13:09.300 --> 00:13:11.930
It also makes it a little more
generic, even though,

00:13:11.930 --> 00:13:13.980
ultimately, it's not
at all generic.

00:13:16.870 --> 00:13:20.010
Anyway, so creating the
polylines by loading those

00:13:20.010 --> 00:13:22.540
lat/longs into these
polylines.

00:13:22.540 --> 00:13:26.420
And that's pretty much it.

00:13:26.420 --> 00:13:28.240
Exporting the data.

00:13:28.240 --> 00:13:31.830
Since this actually turns out to
be a couple lines of code,

00:13:31.830 --> 00:13:35.250
which is really nice, all
I'm doing is I'm just

00:13:35.250 --> 00:13:38.220
JSON.stringify-ing that
original data object.

00:13:38.220 --> 00:13:44.830
So I'm loading the data variable
or the array of

00:13:44.830 --> 00:13:46.130
objects in.

00:13:46.130 --> 00:13:49.670
And I'm doing the manipulation
using the polyline, but then

00:13:49.670 --> 00:13:52.620
actually removing the data from
the original data set.

00:13:52.620 --> 00:13:54.130
And then, when I want to
export, all I do is

00:13:54.130 --> 00:13:57.650
JSON.stringify and write
that to a new window.

00:13:57.650 --> 00:14:00.500
So just a couple lines of
code to export, a few

00:14:00.500 --> 00:14:02.110
lines of code to import.

00:14:02.110 --> 00:14:07.830
And getting a new map is pretty
minimal code, I think.

00:14:07.830 --> 00:14:10.420
There's a lot of limitations
with this approach.

00:14:10.420 --> 00:14:14.900
Namely, like I said earlier,
with these polylines, you can

00:14:14.900 --> 00:14:16.100
actually manipulate them.

00:14:16.100 --> 00:14:19.260
So instead of just deleting
nodes, I can actually drag

00:14:19.260 --> 00:14:21.730
nodes around.

00:14:21.730 --> 00:14:25.530
So this code that I have here
actually doesn't support that,

00:14:25.530 --> 00:14:28.610
because all I'm listening
for is click

00:14:28.610 --> 00:14:31.370
events on these vertices.

00:14:31.370 --> 00:14:33.770
If I did want to support that,
I'd have to do a couple of

00:14:33.770 --> 00:14:34.350
different things.

00:14:34.350 --> 00:14:39.760
Either, instead of serializing
the original data set, I'd

00:14:39.760 --> 00:14:44.660
have to actually serialize
this path to JSON.

00:14:44.660 --> 00:14:46.570
And that's a little bit tricky,
because this is a

00:14:46.570 --> 00:14:47.970
Google Maps lat/long object.

00:14:47.970 --> 00:14:51.710
If I just JSON.stringify that,
it's going to look like a

00:14:51.710 --> 00:14:56.750
Google Maps lat/long object,
which is undefined, which is

00:14:56.750 --> 00:14:57.970
in a public interface,
actually.

00:14:57.970 --> 00:15:02.730
So the other approach is I can
actually just manually

00:15:02.730 --> 00:15:05.070
stringify this.

00:15:05.070 --> 00:15:09.350
Or what I could do is I could
set up more event listeners,

00:15:09.350 --> 00:15:13.990
because I do have mouseup,
mousedown, and mousemove

00:15:13.990 --> 00:15:16.210
events for polylines.

00:15:16.210 --> 00:15:17.420
I could listen for those.

00:15:17.420 --> 00:15:20.510
And then, every time you move
a node, go and update it in

00:15:20.510 --> 00:15:21.470
the original data set.

00:15:21.470 --> 00:15:24.180
Every time I add a node,
insert one to the

00:15:24.180 --> 00:15:25.350
original data set.

00:15:25.350 --> 00:15:28.350
It's a little bit more work.

00:15:28.350 --> 00:15:35.270
I'd probably, just for fun,
code it both ways, because

00:15:35.270 --> 00:15:37.430
we're probably talking about
tens of lines of codes for

00:15:37.430 --> 00:15:38.680
both approaches.

00:15:40.460 --> 00:15:43.580
So maybe a future show.

00:15:43.580 --> 00:15:46.790
And with that, I'm going
to hand off--

00:15:46.790 --> 00:15:52.290
Mano has some advanced
techniques to show off.

00:15:52.290 --> 00:15:56.720
I was going to originally say
minimalist versus whatever the

00:15:56.720 --> 00:15:58.020
opposite of minimalist is.

00:15:58.020 --> 00:16:03.160
But it's not really that,
because you're really showing

00:16:03.160 --> 00:16:07.300
not all data is JavaScript
format, right?

00:16:07.300 --> 00:16:08.270
MANO MARKS: Right.

00:16:08.270 --> 00:16:10.070
PAUL SAXMAN: A lot
of data is--

00:16:10.070 --> 00:16:12.990
MANO MARKS: Do we have mine
pulled up somewhere?

00:16:12.990 --> 00:16:13.500
PAUL SAXMAN: Oops, you're
going to have to

00:16:13.500 --> 00:16:14.190
load it, I'm sorry.

00:16:14.190 --> 00:16:15.440
MANO MARKS: That's all right.

00:16:17.990 --> 00:16:20.900
PAUL SAXMAN: So while Mano's
loading the file--

00:16:20.900 --> 00:16:25.070
so what he's done is he
has Esri shapefiles.

00:16:25.070 --> 00:16:26.640
I think shapefiles are kind
of a generic format now.

00:16:26.640 --> 00:16:28.946
MANO MARKS: Where did
you-- sorry, where--

00:16:28.946 --> 00:16:29.902
PAUL SAXMAN: There you go.

00:16:29.902 --> 00:16:30.860
MANO MARKS: OK.

00:16:30.860 --> 00:16:34.030
PAUL SAXMAN: And so lots of
data, lots of GIS data and

00:16:34.030 --> 00:16:37.980
Maps data, is actually
in this file format.

00:16:37.980 --> 00:16:43.456
So things like the Natural Earth
data we've seen before

00:16:43.456 --> 00:16:46.520
with some of our
visualizations.

00:16:46.520 --> 00:16:46.850
MANO MARKS: Right.

00:16:46.850 --> 00:16:51.820
So a lot of authoritative data
ends up being in shapefile

00:16:51.820 --> 00:16:56.910
format, data that's given out
by government agencies,

00:16:56.910 --> 00:16:58.870
particularly.

00:16:58.870 --> 00:17:05.480
Resource extraction companies, a
lot of places like using the

00:17:05.480 --> 00:17:07.410
shapefile as an interchange
format.

00:17:07.410 --> 00:17:14.050
And one reason is because, while
it's owned by Esri as a

00:17:14.050 --> 00:17:17.520
company, they have opened
the specification.

00:17:17.520 --> 00:17:19.465
And it's actually kind
of interesting.

00:17:19.465 --> 00:17:25.780
A shapefile is technically
not just a shapefile.

00:17:32.590 --> 00:17:37.760
It's multiple files.

00:17:37.760 --> 00:17:39.130
PAUL SAXMAN: [INAUDIBLE]
chase it down.

00:17:39.130 --> 00:17:46.146
So that directory.

00:17:46.146 --> 00:17:47.920
MANO MARKS: OK, there we go.

00:17:47.920 --> 00:17:53.570
So shapefiles are generally
distributed as zip files.

00:17:53.570 --> 00:17:57.780
And they'll have a bunch of
different files in there.

00:17:57.780 --> 00:18:01.350
There's the SHP file, which
is where it gets its name.

00:18:01.350 --> 00:18:04.090
And that describes
the geometry.

00:18:04.090 --> 00:18:09.810
There's the DBF file, which
is the database file.

00:18:09.810 --> 00:18:12.370
It's in an old Xbase format.

00:18:12.370 --> 00:18:15.240
Basically, think dBASE 4.

00:18:15.240 --> 00:18:20.320
So we're going back to the
early '90s at this point.

00:18:20.320 --> 00:18:23.480
Actually, one of my first data
management jobs was working

00:18:23.480 --> 00:18:28.490
with dBASE 4 for DOS
quite a while ago.

00:18:31.000 --> 00:18:36.300
And by the way, if you're ever
going to write a DBF parser,

00:18:36.300 --> 00:18:38.460
don't make the mistake that I
made, which is looking for the

00:18:38.460 --> 00:18:41.200
latest dBASE specification,
because, apparently, dBASE

00:18:41.200 --> 00:18:42.450
went up to dBASE 7.

00:18:44.910 --> 00:18:51.470
The Xbase parser that most of
the DBF files that you'll find

00:18:51.470 --> 00:18:56.260
out there is basically
dBASE 4.

00:18:56.260 --> 00:18:57.730
And there was quite a
bit of difference.

00:18:57.730 --> 00:19:01.520
So I lost a few hours
trying to track down

00:19:01.520 --> 00:19:04.080
bytes in that way.

00:19:04.080 --> 00:19:05.990
There's a number of other
files in here.

00:19:05.990 --> 00:19:08.630
There's a PRJ file, which
tells you what

00:19:08.630 --> 00:19:10.570
the projection is.

00:19:10.570 --> 00:19:12.490
We're not going to worry
about that one today.

00:19:12.490 --> 00:19:15.510
We're just going to assume,
because I know this particular

00:19:15.510 --> 00:19:22.100
file is in WGS84, so it's
standard lat/long.

00:19:22.100 --> 00:19:24.220
And then there's
an index file.

00:19:24.220 --> 00:19:26.190
There's a number of different
files that can be

00:19:26.190 --> 00:19:27.450
associated with this.

00:19:27.450 --> 00:19:31.960
For our purposes today, we
just need SHP and DBF.

00:19:31.960 --> 00:19:34.070
So this is my standard HTML.

00:19:34.070 --> 00:19:37.630
I've actually separated out
entirely my JavaScript code

00:19:37.630 --> 00:19:42.760
from the HTML file.

00:19:42.760 --> 00:19:48.320
Then I have shploadsample.js,
which does the basic loading

00:19:48.320 --> 00:20:02.180
of the map and calling out the
SHP and DBF parser files and

00:20:02.180 --> 00:20:04.940
then giving them some callbacks
to what to do with

00:20:04.940 --> 00:20:06.780
the data once it gets it.

00:20:06.780 --> 00:20:10.610
So let me just take a look at
the sample just so you can

00:20:10.610 --> 00:20:11.740
orient here.

00:20:11.740 --> 00:20:15.500
I actually downloaded, from the
US Census, census track

00:20:15.500 --> 00:20:17.490
data for California.

00:20:17.490 --> 00:20:20.050
I think it's a 26-megabyte
download.

00:20:20.050 --> 00:20:23.410
So that's zipped together.

00:20:23.410 --> 00:20:26.840
That's quite a bit of data being
loaded, and it does take

00:20:26.840 --> 00:20:28.180
a little bit to load.

00:20:28.180 --> 00:20:30.800
I'm not going to show
you that here.

00:20:30.800 --> 00:20:34.470
But you can see here, there are
a whole bunch of different

00:20:34.470 --> 00:20:38.700
polygons within the state
of California.

00:20:38.700 --> 00:20:44.330
And you see, if I click on a
polygon, I actually get an

00:20:44.330 --> 00:20:45.540
info window.

00:20:45.540 --> 00:20:51.360
And I get the same data here
along in a side panel.

00:20:51.360 --> 00:20:56.420
And if I click here, it just
resets the info window and the

00:20:56.420 --> 00:20:58.000
side panel.

00:20:58.000 --> 00:21:00.280
PAUL SAXMAN: So this is just
one example of the kind of

00:21:00.280 --> 00:21:02.710
data you can get, though, out
of shapefiles, right?

00:21:02.710 --> 00:21:03.310
MANO MARKS: Oh, yeah.

00:21:03.310 --> 00:21:03.670
Right.

00:21:03.670 --> 00:21:07.960
We work with polygon data,
country border data.

00:21:07.960 --> 00:21:11.450
There's point data, polygon
data, line data.

00:21:11.450 --> 00:21:14.850
There's a whole bunch of
different formats that you can

00:21:14.850 --> 00:21:17.690
get your data in.

00:21:17.690 --> 00:21:21.880
And you could spend quite a
bit of time delving into

00:21:21.880 --> 00:21:22.610
shapefiles.

00:21:22.610 --> 00:21:27.090
Shapefiles are probably the
third most common data format

00:21:27.090 --> 00:21:28.360
that's available on the web.

00:21:28.360 --> 00:21:33.620
The most common by far is KML
files, which there's over a

00:21:33.620 --> 00:21:35.020
billion of.

00:21:35.020 --> 00:21:40.230
Then there's GeoJSON, which is
in numbers in the millions.

00:21:40.230 --> 00:21:43.070
And then there's hundreds of
thousands of shapefiles.

00:21:43.070 --> 00:21:47.000
But as I said, they're often
authoritative data.

00:21:47.000 --> 00:21:49.290
So let's just take
a quick look.

00:21:51.950 --> 00:21:59.070
For the SHP file, I'm using a
file called shp.js done by

00:21:59.070 --> 00:22:04.020
Ilmari Heikkinen, who's an
ex-Googler, used to work on

00:22:04.020 --> 00:22:05.090
the Chrome team.

00:22:05.090 --> 00:22:07.880
And he was just interested
in some geometry.

00:22:07.880 --> 00:22:13.290
So he released shp.js and then
modified it to remove the

00:22:13.290 --> 00:22:19.750
three.js portion that he used,
because I don't use that for

00:22:19.750 --> 00:22:20.900
rendering here.

00:22:20.900 --> 00:22:23.410
So just to make it
very simple.

00:22:23.410 --> 00:22:30.960
And then I created on my own
this dbf.js, which mirrors

00:22:30.960 --> 00:22:37.970
that file but parses
out the DBF file--

00:22:37.970 --> 00:22:39.840
the database file.

00:22:39.840 --> 00:22:47.530
So just to quickly walk through
how shp.js works, we

00:22:47.530 --> 00:22:53.570
have this SHP parser, which
allows you to do loading here,

00:22:53.570 --> 00:22:55.580
so shpparser.load.

00:22:55.580 --> 00:23:01.890
And it takes a URL to
a file, a callback,

00:23:01.890 --> 00:23:03.600
and an error function.

00:23:03.600 --> 00:23:07.670
And so the URL is the
file that'll load.

00:23:07.670 --> 00:23:11.770
The callback is the function
that it will run once you've

00:23:11.770 --> 00:23:12.660
completed loading.

00:23:12.660 --> 00:23:15.820
And the error is what happens
if something--

00:23:15.820 --> 00:23:19.540
what do you do if it doesn't
actually work out?

00:23:19.540 --> 00:23:23.810
So we create a new
XMLHttpRequest, XHR.

00:23:23.810 --> 00:23:26.480
And we give it a response
type of array buffer.

00:23:26.480 --> 00:23:29.110
Now, this is new in HTML5.

00:23:29.110 --> 00:23:30.810
Modern browsers support this.

00:23:30.810 --> 00:23:32.810
Older browsers don't.

00:23:32.810 --> 00:23:36.750
This is allowing you to parse
data as a binary.

00:23:39.378 --> 00:23:40.770
PAUL SAXMAN: Which is always
kind of a little bit of a

00:23:40.770 --> 00:23:44.165
misnomer, right, because it's an
XMLHttpRequest when you're

00:23:44.165 --> 00:23:45.390
loading binary.

00:23:45.390 --> 00:23:46.500
MANO MARKS: Yes.

00:23:46.500 --> 00:23:50.350
Yeah, that's something
that is a little odd.

00:23:50.350 --> 00:23:54.760
The XMLHttpRequest was something
put in to parse XML

00:23:54.760 --> 00:23:58.280
data back when that was how a
lot of data got into browsers.

00:23:58.280 --> 00:24:01.180
But it is, as you mentioned--

00:24:01.180 --> 00:24:04.340
you can load JSON data in it,
you can load CSV data, you can

00:24:04.340 --> 00:24:05.730
load a lot of different
formats in.

00:24:05.730 --> 00:24:07.933
PAUL SAXMAN: It's basically the
tool you want to use for

00:24:07.933 --> 00:24:10.395
loading data across the HTTP.

00:24:10.395 --> 00:24:10.710
MANO MARKS: Right.

00:24:10.710 --> 00:24:13.790
Now, of course, you can also
only load from the same

00:24:13.790 --> 00:24:22.110
domain, because that's a
security feature built into

00:24:22.110 --> 00:24:28.500
XMLHttpRequest and prevents
you from doing something

00:24:28.500 --> 00:24:32.140
damaging to a user's browser
by loading in potentially

00:24:32.140 --> 00:24:35.410
malicious code from somebody
else's domain.

00:24:35.410 --> 00:24:41.510
No surprises to the user,
no bad surprises.

00:24:41.510 --> 00:24:47.660
And then we create this variable
d, which is the data,

00:24:47.660 --> 00:24:50.120
by running the parse function.

00:24:50.120 --> 00:24:52.320
And I'm going to walk you
through a few steps here just

00:24:52.320 --> 00:24:55.050
to give you a sense
of how this works.

00:24:55.050 --> 00:25:05.400
But you can see here, the
parser.parse takes this array

00:25:05.400 --> 00:25:08.420
buffer, creates an object.

00:25:08.420 --> 00:25:09.680
It also creates a DataView.

00:25:09.680 --> 00:25:12.940
And DataView is, again,
new in HTML5.

00:25:12.940 --> 00:25:14.980
It's on modern browsers.

00:25:14.980 --> 00:25:21.480
It gives you methods to access
the data within a binary array

00:25:21.480 --> 00:25:26.160
buffer and then creates this
IDX, which is a variable,

00:25:26.160 --> 00:25:31.800
which is just an index, just to
say this is the byte that

00:25:31.800 --> 00:25:33.050
I'm at at this moment.

00:25:37.260 --> 00:25:43.360
And then the first thing it does
is it gets a getInt32 on

00:25:43.360 --> 00:25:46.820
the DataView, which means it's
parsing, basically, the first

00:25:46.820 --> 00:25:48.020
four bytes.

00:25:48.020 --> 00:25:52.970
And it's just checking to see
that it's got the correct file

00:25:52.970 --> 00:25:58.240
code, because SHP files, those
first four bytes always equal

00:25:58.240 --> 00:26:00.990
this value here.

00:26:00.990 --> 00:26:08.400
And then it just walks through
all these different bytes,

00:26:08.400 --> 00:26:13.870
basically creating attributes
for the object.

00:26:13.870 --> 00:26:17.270
Here, we've got word length, and
then byte length, and then

00:26:17.270 --> 00:26:20.730
the version number,
the shape type.

00:26:20.730 --> 00:26:26.830
And then, each time, it advances
the index by a

00:26:26.830 --> 00:26:34.190
certain amount in order to get
the next set of bytes.

00:26:34.190 --> 00:26:39.700
So here, you can see it's
getInt32, getFloat64.

00:26:39.700 --> 00:26:44.870
It's just walking through to
get these values for you.

00:26:44.870 --> 00:26:48.470
And then, at some point here,
after a certain number of

00:26:48.470 --> 00:26:50.610
bytes, we actually look
at the record.

00:26:50.610 --> 00:26:58.430
So much of this is actually
the header for the file.

00:26:58.430 --> 00:27:02.750
So you see it's giving you min
and minY, maxX and maxY.

00:27:02.750 --> 00:27:07.050
These are the values that
describe the bounding box,

00:27:07.050 --> 00:27:09.870
basically, which you're
operating in.

00:27:09.870 --> 00:27:17.110
And then each record you are
parsing through to get, you've

00:27:17.110 --> 00:27:21.150
got a record number, you've got
a record length, and then

00:27:21.150 --> 00:27:23.990
parsing out the shape, which
just defines the--

00:27:27.650 --> 00:27:30.630
well, here, we have a whole
parse shape function--

00:27:30.630 --> 00:27:33.770
but basically, parsing out the
x- and y-coordinates, and if

00:27:33.770 --> 00:27:36.630
there's any other coordinates,
the different coordinates

00:27:36.630 --> 00:27:38.290
there, as well.

00:27:38.290 --> 00:27:40.185
So other coordinates would
be things like altitude.

00:27:43.720 --> 00:27:48.570
And you can see it gets
quite involved.

00:27:48.570 --> 00:27:51.890
One of the things you discover
when you're doing this is it's

00:27:51.890 --> 00:27:53.340
really very detail oriented.

00:27:53.340 --> 00:27:59.530
You're going in deep on, OK,
at byte number four, I get

00:27:59.530 --> 00:28:01.540
this value, and it
means this thing.

00:28:01.540 --> 00:28:04.790
It's a very deep parsing
kind of thing.

00:28:04.790 --> 00:28:07.700
If you miss one byte, everything
looks really wrong,

00:28:07.700 --> 00:28:09.850
and you get confused.

00:28:09.850 --> 00:28:14.220
You missed the flag that tells
you that you've ended your

00:28:14.220 --> 00:28:16.080
search for a particular field.

00:28:18.620 --> 00:28:21.740
But it's worth it when you get
to the end, and you're like,

00:28:21.740 --> 00:28:23.200
wow, I just did something
really cool.

00:28:23.200 --> 00:28:28.670
I parsed a binary file
in JavaScript.

00:28:28.670 --> 00:28:30.370
It's pretty awesome.

00:28:30.370 --> 00:28:34.260
So the DBF that I wrote--
and by the way, the

00:28:34.260 --> 00:28:38.640
shp.js is on GitHub.

00:28:38.640 --> 00:28:44.130
Dbf.js, we're going to release
in Google code at some point.

00:28:44.130 --> 00:28:45.720
It's in code review right now.

00:28:45.720 --> 00:28:49.270
So hopefully, you'll be seeing
that fairly soon.

00:28:49.270 --> 00:28:53.960
But I just follow that same
format when I'm walking

00:28:53.960 --> 00:28:54.520
through here.

00:28:54.520 --> 00:28:56.800
And I actually parse out a whole
bunch of data that you

00:28:56.800 --> 00:28:57.830
probably don't even need.

00:28:57.830 --> 00:29:00.780
Like there's an encryption flag
that tells you whether

00:29:00.780 --> 00:29:01.900
it's encrypted.

00:29:01.900 --> 00:29:04.210
There's an Incomplete
Transaction flag that tells

00:29:04.210 --> 00:29:08.160
you whether or not the DBF file
was saved at some point

00:29:08.160 --> 00:29:10.940
in an incomplete state.

00:29:10.940 --> 00:29:14.880
When you get that in a
production file, you're

00:29:14.880 --> 00:29:18.320
probably not worried
about this.

00:29:27.892 --> 00:29:33.720
So for the shp.js, once I have
parsed through that, the

00:29:33.720 --> 00:29:39.140
callback is this shape load,
which, basically, I create a

00:29:39.140 --> 00:29:45.240
polygon for each polygon
in this data set.

00:29:45.240 --> 00:29:51.770
So you see in here, I actually
check what is the type of the

00:29:51.770 --> 00:29:58.190
shapefile and assign the
different types to the object.

00:29:58.190 --> 00:30:01.900
But then I go through and I
pull out basically all the

00:30:01.900 --> 00:30:05.580
points and create an
MVC array for each

00:30:05.580 --> 00:30:07.603
path within each shape.

00:30:10.140 --> 00:30:13.560
Let me go back to
the result here.

00:30:13.560 --> 00:30:17.260
You'll see that there are
a bunch of polygons.

00:30:17.260 --> 00:30:19.920
And some of these polygons
actually have what are known

00:30:19.920 --> 00:30:25.920
as inner polygons,
or inner rings.

00:30:25.920 --> 00:30:29.080
That is when you have a polygon
that has a hole in it.

00:30:29.080 --> 00:30:31.720
And Maps API supports that.

00:30:31.720 --> 00:30:33.750
You can set multiple paths.

00:30:33.750 --> 00:30:39.680
And if a path is within a
polygon, that will show up as

00:30:39.680 --> 00:30:41.170
a hole in your polygon.

00:30:41.170 --> 00:30:42.770
PAUL SAXMAN: I call
those doughnuts.

00:30:42.770 --> 00:30:44.780
MANO MARKS: Yes, they're
like doughnuts.

00:30:44.780 --> 00:30:46.030
Exactly.

00:30:48.650 --> 00:30:54.720
Yeah, so it's pretty much
what I've done.

00:30:54.720 --> 00:30:58.140
I'm going to actually take
a look in the JavaScript

00:30:58.140 --> 00:31:03.260
console, because I have it
log both of the objects.

00:31:03.260 --> 00:31:06.300
And I'm not sure if this
is going to be visible

00:31:06.300 --> 00:31:07.320
here, or very well.

00:31:07.320 --> 00:31:10.630
But let's open that
up a little bit.

00:31:10.630 --> 00:31:15.170
This is the SHP file.

00:31:15.170 --> 00:31:22.370
And you can see each record
contains an array of objects

00:31:22.370 --> 00:31:25.940
that has a shape in it.

00:31:25.940 --> 00:31:30.240
It's quite a-- you have to go
SHP, it's the record, record

00:31:30.240 --> 00:31:33.150
0, has a shape, has a content.

00:31:33.150 --> 00:31:37.725
And you see it's got a maxX
and a maxY in it--

00:31:42.130 --> 00:31:43.380
just pulled that off screen--

00:31:47.730 --> 00:31:51.130
which defines the boundaries
of the shape.

00:31:51.130 --> 00:31:55.050
But then it's got a whole
bunch of points.

00:31:55.050 --> 00:31:58.020
And one of the interesting
things about this is shp.js

00:31:58.020 --> 00:32:01.140
has longitude and
then latitude.

00:32:01.140 --> 00:32:03.620
So that's the point order.

00:32:03.620 --> 00:32:06.050
So you have to be aware of that
when you're creating your

00:32:06.050 --> 00:32:07.120
lat/long objects.

00:32:07.120 --> 00:32:08.740
You have to flip them around.

00:32:08.740 --> 00:32:10.750
PAUL SAXMAN: So it's long/lat in
a shapefile, but lat/long--

00:32:10.750 --> 00:32:11.980
MANO MARKS: Exactly.

00:32:11.980 --> 00:32:15.620
Much like KML files are
actually the same way.

00:32:15.620 --> 00:32:17.510
PAUL SAXMAN: That's a
very practical tip.

00:32:17.510 --> 00:32:18.880
MANO MARKS: Yeah.

00:32:18.880 --> 00:32:22.690
So then, in the DBF, we have
the same sort of thing.

00:32:22.690 --> 00:32:25.000
We have the number of fields,
which we parsed out from the

00:32:25.000 --> 00:32:29.560
file, and then what those
actual fields are.

00:32:29.560 --> 00:32:31.840
So here, you can
see the values.

00:32:31.840 --> 00:32:33.700
And they're parallel arrays.

00:32:33.700 --> 00:32:39.800
So the records in the DBF file
match the records in the SHP

00:32:39.800 --> 00:32:41.660
file at the same index.

00:32:41.660 --> 00:32:44.010
So the first record is the same
as the first record, the

00:32:44.010 --> 00:32:46.700
second record is the
same as the second.

00:32:46.700 --> 00:32:52.630
PAUL SAXMAN: So how hard would
it be to export this

00:32:52.630 --> 00:32:57.600
JavaScript version of your
shapefile into, let's say, a

00:32:57.600 --> 00:32:59.590
JSON file or JavaScript?

00:32:59.590 --> 00:33:00.260
MANO MARKS: Very easy.

00:33:00.260 --> 00:33:06.630
You see right here, once you
have the code, which Ilmari

00:33:06.630 --> 00:33:09.180
and I have written,
these are objects.

00:33:09.180 --> 00:33:10.100
These are JSON objects.

00:33:10.100 --> 00:33:13.730
So you'd just stringify
that and port it out.

00:33:13.730 --> 00:33:17.720
Then you could just
use that without

00:33:17.720 --> 00:33:19.066
parsing the object again.

00:33:19.066 --> 00:33:20.000
PAUL SAXMAN: Right.

00:33:20.000 --> 00:33:21.250
Cool.

00:33:24.430 --> 00:33:26.040
When I saw this the
first time, I was

00:33:26.040 --> 00:33:27.870
kind of amazed that--

00:33:27.870 --> 00:33:30.780
this is a massive number
of polygons, right?

00:33:30.780 --> 00:33:31.060
MANO MARKS: It is, yeah.

00:33:31.060 --> 00:33:33.680
PAUL SAXMAN: I mean, we're
seeing some pretty amazing

00:33:33.680 --> 00:33:34.590
performance--

00:33:34.590 --> 00:33:36.230
polygon and polyline
performance--

00:33:36.230 --> 00:33:37.750
on the Google Maps API.

00:33:37.750 --> 00:33:40.010
MANO MARKS: Thousands of
polygons, each of which has

00:33:40.010 --> 00:33:42.860
multiple vertices.

00:33:42.860 --> 00:33:43.350
PAUL SAXMAN: Yeah.

00:33:43.350 --> 00:33:45.020
The ship data, again,
that's, like,

00:33:45.020 --> 00:33:49.260
250-some thousand points.

00:33:49.260 --> 00:33:51.620
I'd assume this is actually
beyond that, even.

00:33:51.620 --> 00:33:56.200
MANO MARKS: This is all rendered
in canvas on top of

00:33:56.200 --> 00:33:57.150
the Maps API.

00:33:57.150 --> 00:34:01.480
So you're seeing quite a bit
of performance here.

00:34:01.480 --> 00:34:03.330
I mean, you can see how
the different--

00:34:03.330 --> 00:34:05.920
these are just the census tracks
for San Francisco here.

00:34:08.770 --> 00:34:09.139
PAUL SAXMAN: Yeah.

00:34:09.139 --> 00:34:11.570
So it's a really
nice data set.

00:34:11.570 --> 00:34:15.400
And this is actually one of
the most popular use cases

00:34:15.400 --> 00:34:18.920
I've seen is doing
census data.

00:34:18.920 --> 00:34:23.070
Everybody always wants the state
boundaries and province

00:34:23.070 --> 00:34:24.500
boundaries.

00:34:24.500 --> 00:34:28.469
A lot of that data, like you
said, the official data

00:34:28.469 --> 00:34:31.409
sources provide these
shapefiles, which makes this a

00:34:31.409 --> 00:34:32.884
really powerful tool.

00:34:32.884 --> 00:34:36.050
MANO MARKS: Yeah, exactly.

00:34:36.050 --> 00:34:37.190
Cool.

00:34:37.190 --> 00:34:40.420
PAUL SAXMAN: Maybe in a few
more weeks, we can do some

00:34:40.420 --> 00:34:42.992
census data analysis.

00:34:42.992 --> 00:34:45.116
MANO MARKS: Right, yeah.

00:34:45.116 --> 00:34:46.070
Cool.

00:34:46.070 --> 00:34:47.100
PAUL SAXMAN: Awesome.

00:34:47.100 --> 00:34:48.260
So that's pretty much it.

00:34:48.260 --> 00:34:52.989
So we have basic techniques,
just loading JavaScript

00:34:52.989 --> 00:34:57.650
objects, making them editable in
the browser, in the map, so

00:34:57.650 --> 00:34:59.920
that you can actually export
them again, kind of clean up

00:34:59.920 --> 00:35:02.770
your data or beautify
your data.

00:35:02.770 --> 00:35:06.490
And then we see some advanced
techniques using shapefiles to

00:35:06.490 --> 00:35:08.990
get the shapefiles
into your map.

00:35:08.990 --> 00:35:12.110
And then, as we mentioned
before, you can just

00:35:12.110 --> 00:35:15.400
json.stringify, and I get that
data back out again in a

00:35:15.400 --> 00:35:19.570
format so you don't have
to ever parse it again.

00:35:19.570 --> 00:35:22.940
Although, I assume some of this
data might be licensed.

00:35:22.940 --> 00:35:29.180
But that's up for the
user to investigate.

00:35:29.180 --> 00:35:30.960
So if you guys have any
questions, post them in the

00:35:30.960 --> 00:35:34.160
comments, please, and we'll
try to get back to you.

00:35:34.160 --> 00:35:38.520
And Mano's data is kind
of in code review.

00:35:38.520 --> 00:35:40.110
Mine's getting ramped
up for code review.

00:35:40.110 --> 00:35:43.670
So I know we said this
a few weeks ago.

00:35:43.670 --> 00:35:45.070
Before, I was on vacation.

00:35:45.070 --> 00:35:48.490
But the code is on the way,
because we definitely want to

00:35:48.490 --> 00:35:49.930
get it in your guys' hands
to see what you

00:35:49.930 --> 00:35:52.250
guys can do with it.

00:35:52.250 --> 00:35:54.550
So enjoy, and we'll
see you next week.

00:35:54.550 --> 00:35:55.402
MANO MARKS: All right.

00:35:55.402 --> 00:35:56.652
Thanks a lot.

00:36:02.790 --> 00:36:23.567
[MUSIC PLAYING]

