WEBVTT
Kind: captions
Language: en

00:00:02.650 --> 00:00:04.540
So, before we begin,
I just want to make

00:00:04.540 --> 00:00:07.560
sure you guys all remember
about the quiz on Friday.

00:00:07.560 --> 00:00:12.550
So the quiz is going to
be in Walker at 2 pm.

00:00:12.550 --> 00:00:14.230
Everybody goes to Walker.

00:00:14.230 --> 00:00:16.710
The quiz is open book.

00:00:16.710 --> 00:00:18.070
You can bring your own notes.

00:00:18.070 --> 00:00:21.130
You can bring a class notes,
bring the readings from class;

00:00:21.130 --> 00:00:23.110
you can bring your calculator.

00:00:23.110 --> 00:00:25.922
But please don't bring any
computers, phones, PDAs,

00:00:25.922 --> 00:00:26.630
things like that.

00:00:26.630 --> 00:00:28.630
So make sure you have all
your stuff printed out

00:00:28.630 --> 00:00:31.560
before you show up if you've
been taking notes on a laptop.

00:00:31.560 --> 00:00:37.680
OK, so what we're going to
do today is just quickly,

00:00:37.680 --> 00:00:39.970
well, we're going to do an
introduction to networking.

00:00:39.970 --> 00:00:41.670
But quickly I just
want to finish

00:00:41.670 --> 00:00:44.190
the topic of caching
that we began,

00:00:44.190 --> 00:00:46.740
that sort of introduced at
the very end of the lecture

00:00:46.740 --> 00:00:47.800
last time.

00:00:47.800 --> 00:00:51.760
So, if you guys
remember, we were

00:00:51.760 --> 00:00:55.630
talking about our pipeline
WebServer system that

00:00:55.630 --> 00:01:06.400
consisted of these three stages:
a networking stage connected up

00:01:06.400 --> 00:01:15.400
to our HTML stage connected
up to our disk stage.

00:01:15.400 --> 00:01:19.650
OK, and we did a
little performance

00:01:19.650 --> 00:01:20.777
analysis of the system.

00:01:20.777 --> 00:01:22.860
We looked at what the cost
of each of these stages

00:01:22.860 --> 00:01:26.670
is, what sort of throughput of
each one of these stages is.

00:01:26.670 --> 00:01:29.920
We said that as long as we
split this networking module up

00:01:29.920 --> 00:01:32.920
into ten submodules, we can get
the throughput of this thing

00:01:32.920 --> 00:01:37.790
to be about 100
requests per second.

00:01:37.790 --> 00:01:41.490
We said the latency
of this was 1 ms.

00:01:41.490 --> 00:01:45.160
So that means it can process a
thousand requests per second.

00:01:45.160 --> 00:01:48.550
We said the latency
of the disk was 10 ms.

00:01:48.550 --> 00:01:50.160
So that means it
can also process

00:01:50.160 --> 00:01:52.520
100 requests per second.

00:01:52.520 --> 00:01:55.410
And we said, remember, that when
we are looking at a pipeline,

00:01:55.410 --> 00:01:57.350
the sort of throughput
of the entire pipeline

00:01:57.350 --> 00:01:59.100
is going to be
bottlenecked by the slowest

00:01:59.100 --> 00:02:01.205
stage in the system.

00:02:01.205 --> 00:02:02.580
And so if we look
at this, we see

00:02:02.580 --> 00:02:05.970
that these two stages
are both running

00:02:05.970 --> 00:02:09.560
at 100 requests per second.

00:02:09.560 --> 00:02:14.360
But we have a very simple way of
making this first network stage

00:02:14.360 --> 00:02:16.380
be able to process more
requests per second,

00:02:16.380 --> 00:02:20.690
right, because we
simply can replicate

00:02:20.690 --> 00:02:22.360
the number of threads
that are sending

00:02:22.360 --> 00:02:23.760
data out over the network.

00:02:23.760 --> 00:02:28.180
So, for example, if we went from
ten nodes here to 100 nodes,

00:02:28.180 --> 00:02:31.160
we could increase the
throughput of this stage

00:02:31.160 --> 00:02:33.650
to 1,000 requests
per second, which

00:02:33.650 --> 00:02:36.560
means that now the bottleneck
stage that we have is simply

00:02:36.560 --> 00:02:37.300
the disk stage.

00:02:37.300 --> 00:02:39.180
So the question is,
is there something

00:02:39.180 --> 00:02:41.870
we can do to increase the
throughput of the disk stage?

00:02:41.870 --> 00:02:43.609
If you think about
it, at first it

00:02:43.609 --> 00:02:45.150
may seem like, well,
there's probably

00:02:45.150 --> 00:02:49.000
no way that we can do anything
because the disk takes 10 ms,

00:02:49.000 --> 00:02:51.470
you know, every page
takes 10 ms to read in.

00:02:51.470 --> 00:02:54.270
So what are we going
to do about that?

00:02:54.270 --> 00:02:56.159
And there's a very
sort of standard answer

00:02:56.159 --> 00:02:57.950
to that that you guys
have all seen before,

00:02:57.950 --> 00:02:59.225
and that answer is caching.

00:03:02.600 --> 00:03:07.230
OK so the simple
idea is that we're

00:03:07.230 --> 00:03:09.830
going to take this IO
stage, or this disk stage,

00:03:09.830 --> 00:03:12.360
with this disk
that runs at 10 ms.

00:03:12.360 --> 00:03:14.330
What I've shown here
is a very simple piece

00:03:14.330 --> 00:03:16.010
of pseudo code that
might correspond

00:03:16.010 --> 00:03:18.590
to what this sort
of read or the get

00:03:18.590 --> 00:03:22.570
page ID function for
this IO stage does.

00:03:22.570 --> 00:03:24.210
It simply calls
some read function

00:03:24.210 --> 00:03:28.020
that reads page ID off the
disk and then returns the page.

00:03:28.020 --> 00:03:29.810
If we add a cache
to this system,

00:03:29.810 --> 00:03:31.470
suppose we have
an in memory cache

00:03:31.470 --> 00:03:35.110
that can retrieve
a page in 0.1 ms.

00:03:35.110 --> 00:03:37.080
In that case, the
way that we can

00:03:37.080 --> 00:03:39.684
use that cache is just before
every time we go to the disk,

00:03:39.684 --> 00:03:42.100
we can check and see if the
page that we're trying to load

00:03:42.100 --> 00:03:43.190
is in the cache.

00:03:43.190 --> 00:03:44.976
And then only if
it's not in the cache

00:03:44.976 --> 00:03:46.600
do we need to actually
go to the disks.

00:03:46.600 --> 00:03:47.950
And we get a miss on the cache.

00:03:47.950 --> 00:03:50.750
We go check the disk to see
if the page is available.

00:03:50.750 --> 00:03:53.140
So we can extend the
code in a very simple way

00:03:53.140 --> 00:03:54.850
to take advantage of this.

00:03:54.850 --> 00:03:57.460
We simply say, we look
up in the cache first,

00:03:57.460 --> 00:03:59.880
and then if the page is
null or empty or whatever,

00:03:59.880 --> 00:04:03.170
we can't find it in the cache,
then we go ahead and look it up

00:04:03.170 --> 00:04:04.320
on the disk.

00:04:04.320 --> 00:04:06.620
And then we add that
result to the cache.

00:04:06.620 --> 00:04:09.130
So there's a couple
of little details

00:04:09.130 --> 00:04:10.430
that we need to work through.

00:04:10.430 --> 00:04:13.210
But let's first look at what
the performance of this system

00:04:13.210 --> 00:04:14.710
is going to be, or
how this is going

00:04:14.710 --> 00:04:17.120
to impact the performance
of what we've been doing.

00:04:17.120 --> 00:04:23.540
So if we come over
here, if we think

00:04:23.540 --> 00:04:27.250
about what the cost of accessing
a page on this system would be,

00:04:27.250 --> 00:04:30.722
well, we're always going to
have to check the cache, right?

00:04:30.722 --> 00:04:31.930
That's the first thing we do.

00:04:31.930 --> 00:04:37.270
So I'm going to write C for cost
of accessing the cache, where

00:04:37.270 --> 00:04:39.020
cost is in this case
going to be expressed

00:04:39.020 --> 00:04:40.900
in something like the
number of milliseconds

00:04:40.900 --> 00:04:44.662
to do a lookup in the cache,
and then plus the cost

00:04:44.662 --> 00:04:45.870
of looking it up on the disk.

00:04:45.870 --> 00:04:48.430
But we only have to look up
on the disk some of the time,

00:04:48.430 --> 00:04:50.440
right, so there is
some probability

00:04:50.440 --> 00:04:59.620
of getting a miss times
the cost of that miss.

00:04:59.620 --> 00:05:02.560
OK, so in this case, we said
the cost of going to the cache

00:05:02.560 --> 00:05:05.710
was 0.1 ms.

00:05:05.710 --> 00:05:09.587
The cost of going to
the disk is 10 ms.

00:05:09.587 --> 00:05:11.420
OK, and now what we're
left is to figure out

00:05:11.420 --> 00:05:13.860
what the probability
of this miss is.

00:05:16.500 --> 00:05:20.130
So if you think about a
system for a little bit,

00:05:20.130 --> 00:05:23.090
you might say, well, OK, what
does the system look like?

00:05:23.090 --> 00:05:26.680
What's the probability that we
are actually going to get a hit

00:05:26.680 --> 00:05:29.150
or miss?

00:05:29.150 --> 00:05:31.900
And if what the
applications are doing

00:05:31.900 --> 00:05:34.160
is simply generating
random requests

00:05:34.160 --> 00:05:36.320
for random pages, which
might be one model of how

00:05:36.320 --> 00:05:38.044
the application
behaves, then it doesn't

00:05:38.044 --> 00:05:39.460
seem like cache
is going to buy us

00:05:39.460 --> 00:05:41.050
very much, right,
because the cache is

00:05:41.050 --> 00:05:43.508
going to be a small fraction
of the total size of the disk.

00:05:43.508 --> 00:05:46.260
It might be in RAM, so we
might have 100 MB of cache,

00:05:46.260 --> 00:05:48.720
and we might have 10
GB of disk, right?

00:05:48.720 --> 00:05:50.959
So that means there is a
factor of 100 difference

00:05:50.959 --> 00:05:52.000
between these two things.

00:05:52.000 --> 00:05:53.744
So if the page
requests are random,

00:05:53.744 --> 00:05:56.160
the probability that something
is going to be in the cache

00:05:56.160 --> 00:05:57.340
is going to be very low.

00:05:57.340 --> 00:05:59.060
It's going to be only, say, 1%.

00:05:59.060 --> 00:06:02.219
But it turns out that
almost all applications

00:06:02.219 --> 00:06:04.510
have an interesting property
which is commonly referred

00:06:04.510 --> 00:06:07.970
to as locality of reference.

00:06:13.160 --> 00:06:17.050
What this means is that if you
look at which pages a program

00:06:17.050 --> 00:06:18.850
is likely to access
over time, be

00:06:18.850 --> 00:06:23.610
these pages of data
or parts of a program,

00:06:23.610 --> 00:06:26.310
typically a page that has
been accessed recently

00:06:26.310 --> 00:06:28.214
is very likely to
be accessed again.

00:06:28.214 --> 00:06:29.880
So a simple example
might be that if you

00:06:29.880 --> 00:06:32.660
look at the files that are
being used in a computer system,

00:06:32.660 --> 00:06:34.859
usually there is a
small set of files

00:06:34.859 --> 00:06:37.150
that a user is working with
at any given point in time.

00:06:37.150 --> 00:06:38.980
You're running certain
programs; you're

00:06:38.980 --> 00:06:40.410
editing certain documents.

00:06:40.410 --> 00:06:42.290
And there's a huge
array of other programs

00:06:42.290 --> 00:06:44.410
and files and documents
that are on the system

00:06:44.410 --> 00:06:46.140
that you aren't accessing.

00:06:46.140 --> 00:06:49.720
And when those active
files are being accessed,

00:06:49.720 --> 00:06:51.570
there's a much
higher probability

00:06:51.570 --> 00:06:54.142
of getting a hit of looking
at those active files

00:06:54.142 --> 00:06:56.350
then there is of going to
any one of the other files.

00:06:56.350 --> 00:06:58.990
So even when the difference
between these things

00:06:58.990 --> 00:07:01.540
is, say, a factor of 100,
in the case of a Web server,

00:07:01.540 --> 00:07:03.360
it might be very
likely that we would

00:07:03.360 --> 00:07:07.660
have 90% maybe of the pages
that have been accessed

00:07:07.660 --> 00:07:10.000
are already in the cache.

00:07:10.000 --> 00:07:14.910
So in that case, sorry, this
probability should be 0.9, 90%.

00:07:14.910 --> 00:07:18.930
OK, so suppose that
the probability, sorry,

00:07:18.930 --> 00:07:22.140
the probability of a hit is 90%.

00:07:22.140 --> 00:07:24.380
The probability of
a miss is then 10%.

00:07:24.380 --> 00:07:29.820
OK, so if you look at now
what this sort of formula

00:07:29.820 --> 00:07:34.400
evaluates to, we see it's
0.1 plus ten times 0.1.

00:07:34.400 --> 00:07:39.180
So, it's 1.1
milliseconds on average,

00:07:39.180 --> 00:07:42.340
assuming that we get a
90% hit rate on our cache.

00:07:42.340 --> 00:07:46.520
OK, so if you now come
back to this diagram, that

00:07:46.520 --> 00:07:53.252
means that the throughput
of the box is one over 1.1,

00:07:53.252 --> 00:07:55.460
remember, because throughput
is just one over latency

00:07:55.460 --> 00:07:58.570
when we have sort of just
this one module, which

00:07:58.570 --> 00:08:01.250
means that now we can
process something like,

00:08:01.250 --> 00:08:06.440
so this is something
like, sorry,

00:08:06.440 --> 00:08:09.160
this should be one over latency.

00:08:09.160 --> 00:08:11.010
But this is in milliseconds.

00:08:11.010 --> 00:08:17.150
So this is 0.1, one, sorry, the
number of seconds is 0.0011,

00:08:17.150 --> 00:08:17.650
right?

00:08:17.650 --> 00:08:21.080
So, one over 0.0011
is about 900.

00:08:21.080 --> 00:08:23.560
OK, so we can get about
900 requests per second

00:08:23.560 --> 00:08:25.800
that we can process
instead of just 100.

00:08:25.800 --> 00:08:27.640
This is approximately equal.

00:08:30.290 --> 00:08:32.039
OK, so what we've
managed to do is

00:08:32.039 --> 00:08:34.070
increase the throughput
at this stage

00:08:34.070 --> 00:08:35.354
by about a factor of nine.

00:08:35.354 --> 00:08:37.270
I mean, now you can see
that sort of all three

00:08:37.270 --> 00:08:40.101
of these stages are close to
about 1,000 requests a second.

00:08:40.101 --> 00:08:42.059
We have increased the
performance of the system

00:08:42.059 --> 00:08:45.140
pretty dramatically by
introducing the cache.

00:08:45.140 --> 00:08:48.140
And you have to remember
that this cache is only

00:08:48.140 --> 00:08:49.680
going to be a good
idea when we are

00:08:49.680 --> 00:08:52.250
sure that we have this
locality of reference property.

00:08:52.250 --> 00:08:56.510
OK, so if the Web server
is going to a random page,

00:08:56.510 --> 00:08:58.810
if the Web server
is sort of asked

00:08:58.810 --> 00:09:00.580
to fetch a random
page on every request,

00:09:00.580 --> 00:09:02.371
the cache is not going
to be a good choice.

00:09:02.371 --> 00:09:06.220
But most of the time Web servers
to have this locality property.

00:09:06.220 --> 00:09:07.650
So the last little
detail that we

00:09:07.650 --> 00:09:13.330
need to talk about when
we talk about caches,

00:09:13.330 --> 00:09:21.910
is the sort of question about
how we deal with page eviction.

00:09:21.910 --> 00:09:27.530
So in this diagram here, when
we call add to the cache,

00:09:27.530 --> 00:09:30.040
if the cache is already
full of results,

00:09:30.040 --> 00:09:33.260
we have to pick something
to replace, right?

00:09:33.260 --> 00:09:39.350
So we need what's called a page
removal or page replacement

00:09:39.350 --> 00:09:39.980
policy.

00:09:39.980 --> 00:09:48.310
OK, so you guys presumably have
seen different page removal

00:09:48.310 --> 00:09:51.270
or page replacement
properties in 6.004 before.

00:09:51.270 --> 00:09:53.740
I'll just talk about
two very quickly:

00:09:53.740 --> 00:09:58.020
a FIFO policy and a LRU policy.

00:09:58.020 --> 00:10:00.600
OK, so what FIFO means
is First In First Out.

00:10:00.600 --> 00:10:03.920
So it says the
thing to throw out

00:10:03.920 --> 00:10:06.470
is the first thing that
we loaded into the cache.

00:10:06.470 --> 00:10:09.980
OK, so if I access
a set of pages,

00:10:09.980 --> 00:10:13.010
suppose I have a
three element cache

00:10:13.010 --> 00:10:16.190
and I access a set of pages,
one, two, three, two, one,

00:10:16.190 --> 00:10:20.470
four, what I'm going to do
is I'm going to load this.

00:10:20.470 --> 00:10:24.800
I'm going to access
these three pages.

00:10:24.800 --> 00:10:27.340
Page 1 will be the first
one that's in my cache.

00:10:27.340 --> 00:10:31.280
So when I try and load page
4, I'm going to evict page 1.

00:10:31.280 --> 00:10:33.690
OK, that's what's going
to happen in a FIFO system

00:10:33.690 --> 00:10:36.100
because one was the first
one that was loaded.

00:10:36.100 --> 00:10:37.890
But a least recently
used approach

00:10:37.890 --> 00:10:40.590
says instead of evicting
the first thing that

00:10:40.590 --> 00:10:43.350
was put into the cache, we want
to evict the last thing that

00:10:43.350 --> 00:10:45.330
was read from the cache.

00:10:45.330 --> 00:10:48.520
So in this case, if I do one,
two, three, two, one, and then

00:10:48.520 --> 00:10:50.740
I get four, the last thing
that was read was three,

00:10:50.740 --> 00:10:53.312
and that's what I'll
evict from the cache.

00:10:53.312 --> 00:10:55.520
So, if you think about the
intuition behind these two

00:10:55.520 --> 00:10:59.980
policies, you sort of realized
that this FIFO approach

00:10:59.980 --> 00:11:02.140
has a problem,
which is that it's

00:11:02.140 --> 00:11:05.000
sort of contrary to this notion
of locality of reference,

00:11:05.000 --> 00:11:07.370
right, because it
doesn't capture anything

00:11:07.370 --> 00:11:14.590
about how frequently a
data item is accessed

00:11:14.590 --> 00:11:16.880
or when it was last accessed.

00:11:16.880 --> 00:11:19.830
It throws the sort of first
access thing out of the cache

00:11:19.830 --> 00:11:23.190
even if that first access
thing is read all the time.

00:11:23.190 --> 00:11:26.300
LRU sort of captures the
intuition which we want,

00:11:26.300 --> 00:11:28.900
which is that something
that's been accessed recently

00:11:28.900 --> 00:11:30.540
is likely to be accessed again.

00:11:30.540 --> 00:11:33.230
And something that hasn't
been accessed very recently

00:11:33.230 --> 00:11:35.610
is less likely to
be accessed again.

00:11:35.610 --> 00:11:38.790
So it sort of captures
our intuitive idea

00:11:38.790 --> 00:11:41.050
that we want locality
of reference.

00:11:41.050 --> 00:11:42.700
So the text talks
much more carefully

00:11:42.700 --> 00:11:44.533
about these different
page removal policies.

00:11:44.533 --> 00:11:46.870
But anytime you see
anybody talk about a cache,

00:11:46.870 --> 00:11:49.689
you should sort of immediately
think to ask the question,

00:11:49.689 --> 00:11:51.980
well, what's the page removal
policy that's being used?

00:11:54.500 --> 00:11:59.230
OK, so that basically does it
for our discussion of caching

00:11:59.230 --> 00:12:02.016
and of performance that
we started last time.

00:12:02.016 --> 00:12:03.390
And what we're
going to do now is

00:12:03.390 --> 00:12:07.840
move on to the topic
of networking, OK?

00:12:07.840 --> 00:12:29.030
So -- So a computer network,
you guys should all be familiar

00:12:29.030 --> 00:12:30.780
of what the idea of a
computer network is.

00:12:30.780 --> 00:12:34.100
It's some sort of a
connection that connects

00:12:34.100 --> 00:12:36.830
multiple computers together.

00:12:36.830 --> 00:12:40.625
So why are we interested in
studying a computer network?

00:12:40.625 --> 00:12:42.750
What is it that's relevant
about a computer network

00:12:42.750 --> 00:12:44.550
for the purposes of this class?

00:12:44.550 --> 00:12:47.410
And there's really sort
of two primary reasons.

00:12:47.410 --> 00:12:51.100
The first one is that
computer networks are commonly

00:12:51.100 --> 00:12:54.052
used as components of systems.

00:12:57.110 --> 00:12:59.590
OK, so anytime we are building
a big computer system,

00:12:59.590 --> 00:13:03.710
it's very likely it's going
to involve a computer network.

00:13:03.710 --> 00:13:05.210
So it's going to
be important for us

00:13:05.210 --> 00:13:07.460
to understand what the
properties of computer networks

00:13:07.460 --> 00:13:11.270
are, and how computer networks
affect the design of our system

00:13:11.270 --> 00:13:14.400
if you want to use them
effectively in our systems.

00:13:14.400 --> 00:13:16.000
And computer networks
have a number

00:13:16.000 --> 00:13:17.450
of uses in the computer systems.

00:13:17.450 --> 00:13:22.420
They do things like allow us
to overcome geographic limits.

00:13:22.420 --> 00:13:27.719
So what you guys are all
familiar with the ability

00:13:27.719 --> 00:13:29.260
of the Internet to
allow you to check

00:13:29.260 --> 00:13:31.609
the score of some
sporting game that's

00:13:31.609 --> 00:13:33.400
happening on the other
side of the country,

00:13:33.400 --> 00:13:39.750
or to be able to send an e-mail
to your parents back home.

00:13:39.750 --> 00:13:42.240
So obviously, being able
to sort of transmit data

00:13:42.240 --> 00:13:44.660
over long distances is
clearly a good thing

00:13:44.660 --> 00:13:46.640
for many kinds of systems.

00:13:46.640 --> 00:13:48.850
They also allow us to
access remote data.

00:13:51.780 --> 00:13:54.450
And this is related to the
other thing, to the other one.

00:13:54.450 --> 00:13:56.462
But if you have data
that's not on your computer

00:13:56.462 --> 00:13:57.920
that you want to
get a hold of, you

00:13:57.920 --> 00:13:59.670
may want to contact
your bank and ask them

00:13:59.670 --> 00:14:01.440
for your bank balance.

00:14:01.440 --> 00:14:05.490
And then finally
they can be used

00:14:05.490 --> 00:14:07.765
to physically separate
a client and a server.

00:14:12.650 --> 00:14:14.930
So we talked about
the last few lectures,

00:14:14.930 --> 00:14:19.320
we spent a while
talking about the fact

00:14:19.320 --> 00:14:21.920
that we can use things like
threads and address spaces

00:14:21.920 --> 00:14:24.870
in order to provide a sort
of enforced modularity

00:14:24.870 --> 00:14:27.100
between modules running
on the same computer.

00:14:27.100 --> 00:14:28.990
But there are lots of
situations in which we

00:14:28.990 --> 00:14:31.200
want to actually physically
separate the client

00:14:31.200 --> 00:14:32.170
and the server, right?

00:14:32.170 --> 00:14:34.010
Your bank doesn't
really want you

00:14:34.010 --> 00:14:38.010
to be running your copy of
Quicken on their server,

00:14:38.010 --> 00:14:40.820
right, because this notion of
enforced modularity we talked

00:14:40.820 --> 00:14:43.620
about isn't a perfect
separation between the client

00:14:43.620 --> 00:14:46.200
and the server, whereas
putting these things on really

00:14:46.200 --> 00:14:49.110
separate machines that are only
connected by this network that

00:14:49.110 --> 00:14:51.670
is controlled by this piece of
hardware that's this network

00:14:51.670 --> 00:14:56.690
card that sort of talks with the
network, that's a good reason

00:14:56.690 --> 00:14:59.790
may be to separate these
things from each other.

00:14:59.790 --> 00:15:01.610
And then finally, the
second major reason

00:15:01.610 --> 00:15:03.890
why we want to study
networks is simply

00:15:03.890 --> 00:15:06.600
that they themselves are
an interesting computer

00:15:06.600 --> 00:15:10.090
system, OK?

00:15:10.090 --> 00:15:11.520
So we talked in
the first lecture

00:15:11.520 --> 00:15:13.799
about some of the interesting
sort of properties

00:15:13.799 --> 00:15:15.090
that big computer systems have.

00:15:15.090 --> 00:15:17.332
Well, there's not
many computer systems

00:15:17.332 --> 00:15:19.040
that are bigger than
the Internet, right?

00:15:19.040 --> 00:15:22.390
It's a perfect example of
the giant complex interesting

00:15:22.390 --> 00:15:24.757
system with all sorts of
complicated behaviors.

00:15:24.757 --> 00:15:27.090
And we'll talk about some of
those complicated behaviors

00:15:27.090 --> 00:15:30.220
today as we overview networks.

00:15:33.310 --> 00:15:38.990
So the goal of our discussion
of networking in some sense

00:15:38.990 --> 00:15:42.080
is going to be to develop
a set of tools that

00:15:42.080 --> 00:15:46.980
allow us to have universal
communication between a number

00:15:46.980 --> 00:15:49.061
of different clients.

00:15:49.061 --> 00:15:49.560
OK.

00:15:57.410 --> 00:15:59.570
So what do I mean by that?

00:15:59.570 --> 00:16:03.250
Suppose I have some
collection of machines,

00:16:03.250 --> 00:16:06.790
which I'll just draw
as little boxes that

00:16:06.790 --> 00:16:08.740
are scattered around.

00:16:08.740 --> 00:16:10.200
And they are connected together.

00:16:10.200 --> 00:16:15.130
What we want to do is to
connect these guys together, OK?

00:16:15.130 --> 00:16:17.559
And the network system
that we are going to design

00:16:17.559 --> 00:16:19.600
is going to be the
interconnect that allows these

00:16:19.600 --> 00:16:21.980
got to talk to each other.

00:16:21.980 --> 00:16:23.700
And what we want
this network to be

00:16:23.700 --> 00:16:25.349
able to provide at
a very high level

00:16:25.349 --> 00:16:27.265
is the ability to do
any-to-any communication.

00:16:30.610 --> 00:16:34.400
OK, so if this is
A and this is D,

00:16:34.400 --> 00:16:37.620
we want to A to be able to
send a message to D or anybody

00:16:37.620 --> 00:16:38.780
else who's in this network.

00:16:38.780 --> 00:16:42.190
And that should be true for any
of the pairs that we can find.

00:16:42.190 --> 00:16:43.880
And so, in some
sense, what we're

00:16:43.880 --> 00:16:46.740
going to do over the course
of the next couple of weeks

00:16:46.740 --> 00:16:49.060
is sort of see how we
design this cloud that

00:16:49.060 --> 00:16:51.760
sits in between all these
different computers.

00:16:51.760 --> 00:16:53.870
If you like, you can sort
of think of this cloud.

00:16:53.870 --> 00:16:56.200
Often times, the Internet
is represented as a cloud.

00:16:56.200 --> 00:16:59.450
It's just some black box that
you sort of send messages

00:16:59.450 --> 00:17:00.510
into with an address.

00:17:00.510 --> 00:17:02.950
And on the other
side, the message

00:17:02.950 --> 00:17:04.266
pops out at the other end.

00:17:04.266 --> 00:17:05.890
So, we're going to
dive into this cloud

00:17:05.890 --> 00:17:08.980
and see what happens
inside of it.

00:17:08.980 --> 00:17:18.790
So, in order to
start to understand

00:17:18.790 --> 00:17:23.160
some of the challenges
of building this cloud,

00:17:23.160 --> 00:17:26.692
we are going to start
looking top down.

00:17:26.692 --> 00:17:28.400
We're going to look
at the biggest issues

00:17:28.400 --> 00:17:29.530
that we have to deal
with, and then we're

00:17:29.530 --> 00:17:32.360
going to break up those issues
into some smaller pieces.

00:17:32.360 --> 00:17:40.630
So - - OK, so what
are the issues

00:17:40.630 --> 00:17:42.830
that sort is immediately
pop out when you first

00:17:42.830 --> 00:17:45.540
start thinking about the
properties of a network?

00:17:45.540 --> 00:17:51.710
Well, so there's some
technological issues which

00:17:51.710 --> 00:17:55.740
have to do with things like
the physical medium over which

00:17:55.740 --> 00:17:58.990
you're transmitting messages,
or the properties of the links

00:17:58.990 --> 00:18:00.490
over which you're
transmitting them,

00:18:00.490 --> 00:18:04.370
the rates at which you can
send data, the lost rate,

00:18:04.370 --> 00:18:07.170
the percentage of messages
that get lost by the link

00:18:07.170 --> 00:18:08.040
as it's transmitted.

00:18:08.040 --> 00:18:09.498
So those are the
kinds of things we

00:18:09.498 --> 00:18:11.970
mean by technological concerns.

00:18:11.970 --> 00:18:17.160
And so one kind of
technological concern is this,

00:18:17.160 --> 00:18:19.242
is sort of the different
kinds of technology

00:18:19.242 --> 00:18:20.700
that we might use
for transmission.

00:18:20.700 --> 00:18:26.640
And we saw this notion of D
technology over DT before.

00:18:26.640 --> 00:18:28.710
It's just this idea
that technology,

00:18:28.710 --> 00:18:30.710
just like the technology
in your computer system

00:18:30.710 --> 00:18:33.174
has been evolving
dramatically over time.

00:18:33.174 --> 00:18:35.590
The technology of networks has
been evolving dramatically.

00:18:35.590 --> 00:18:37.750
And we're going to
sort of study some

00:18:37.750 --> 00:18:39.610
of the range of
different technologies

00:18:39.610 --> 00:18:41.080
that we have to deal with.

00:18:41.080 --> 00:18:45.850
There also are a set of limits,
technological, physical,

00:18:45.850 --> 00:18:48.630
fundamental limits that are
associated with networks.

00:18:48.630 --> 00:18:53.820
So, these are things like
the speed of light, OK?

00:18:53.820 --> 00:18:59.010
We simply can't send messages
faster than the speed of light,

00:18:59.010 --> 00:18:59.511
right?

00:18:59.511 --> 00:19:01.968
These are messages that are
being transmitted [down wire?].

00:19:01.968 --> 00:19:03.460
And they propagate
at some speed.

00:19:03.460 --> 00:19:06.010
And that's going to be
fundamentally a bottleneck

00:19:06.010 --> 00:19:07.729
in the design of
a computer system.

00:19:07.729 --> 00:19:09.270
If I have to send
a message from here

00:19:09.270 --> 00:19:11.110
to California, that
message isn't going

00:19:11.110 --> 00:19:13.490
to get there any sooner
than the amount of time

00:19:13.490 --> 00:19:16.790
it takes for light to
travel across the country.

00:19:16.790 --> 00:19:19.264
And the amount of
time that it takes

00:19:19.264 --> 00:19:20.930
to transmit a message
across the country

00:19:20.930 --> 00:19:22.570
is nontrivial in computer time.

00:19:22.570 --> 00:19:24.560
It might be a couple
hundred milliseconds.

00:19:24.560 --> 00:19:26.420
And that's a long time
as we saw before it

00:19:26.420 --> 00:19:28.320
when we have a processor
that connects one

00:19:28.320 --> 00:19:31.780
billion instructions a second.

00:19:31.780 --> 00:19:34.950
OK, so the other
interesting issue

00:19:34.950 --> 00:19:36.600
that's going to come
out about networks

00:19:36.600 --> 00:19:39.725
is that networks are a
shared infrastructure, OK?

00:19:45.710 --> 00:19:48.440
What that means is that there
are multiple users who are

00:19:48.440 --> 00:19:50.010
simultaneously using a network.

00:19:50.010 --> 00:19:52.760
You guys, of course, all know
this from using the Internet.

00:19:52.760 --> 00:19:55.090
And all the networks that
we study in this class

00:19:55.090 --> 00:19:56.930
are basically a
shared infrastructure.

00:19:56.930 --> 00:19:59.130
And we'll talk in
a minute about why

00:19:59.130 --> 00:20:03.260
the networks are fundamentally
almost always going

00:20:03.260 --> 00:20:04.515
to be sort of shared.

00:20:04.515 --> 00:20:05.890
They're going to
have to transmit

00:20:05.890 --> 00:20:08.330
data for multiple different
users at the same time.

00:20:08.330 --> 00:20:10.413
And that's going to present
a number of challenges

00:20:10.413 --> 00:20:13.050
about how we ensure that
the network is fair,

00:20:13.050 --> 00:20:15.060
that everybody gets
to send their data

00:20:15.060 --> 00:20:17.740
when they want to send
data, how we sort of

00:20:17.740 --> 00:20:20.450
allow multiple people to
access the same physical wire

00:20:20.450 --> 00:20:23.250
at the same point in time.

00:20:23.250 --> 00:20:27.780
OK, so what I want to do is
I'll talk about these two things

00:20:27.780 --> 00:20:28.636
now in order.

00:20:28.636 --> 00:20:30.760
I'm going to start off by
talking about technology.

00:20:30.760 --> 00:20:55.720
So -- So the first interesting
technological problem,

00:20:55.720 --> 00:20:58.020
which I've already mentioned
is that these networks are

00:20:58.020 --> 00:20:59.180
extremely diverse.

00:20:59.180 --> 00:21:01.920
They are heterogeneous.

00:21:01.920 --> 00:21:06.600
OK, networking technology
has evolved a great deal

00:21:06.600 --> 00:21:10.240
in the past 20 years or 30
years since networks first

00:21:10.240 --> 00:21:11.630
started being designed.

00:21:11.630 --> 00:21:14.840
And that means there is a
huge sort of range of devices

00:21:14.840 --> 00:21:17.390
that we might have to
transmit data over.

00:21:17.390 --> 00:21:19.530
So let me show you what I mean.

00:21:19.530 --> 00:21:23.520
This is just a graph showing
the rate of transmission,

00:21:23.520 --> 00:21:25.260
the sort of number
of bits per second

00:21:25.260 --> 00:21:27.720
that you can send over
different networking protocols.

00:21:27.720 --> 00:21:29.470
And the thing to take
away from this first

00:21:29.470 --> 00:21:33.330
is to note that on
the Y axis here,

00:21:33.330 --> 00:21:35.540
this is an exponential scale.

00:21:35.540 --> 00:21:37.970
So the technology
at the very bottom,

00:21:37.970 --> 00:21:40.240
things like early
telephone modems,

00:21:40.240 --> 00:21:43.640
could maybe send data
at 10 kb per second,

00:21:43.640 --> 00:21:47.940
whereas these sort of high-end
router class devices that

00:21:47.940 --> 00:21:54.120
are running the Internet or sort
of very fast desktop Ethernet

00:21:54.120 --> 00:21:56.880
kinds of connections
that are coming out today

00:21:56.880 --> 00:21:59.580
can send more like,
say, in this case we

00:21:59.580 --> 00:22:06.890
have 10 Tb a second, right,
so one times ten to the tenth.

00:22:06.890 --> 00:22:10.410
So we are talking about a factor
of ten to the seventh or ten

00:22:10.410 --> 00:22:12.270
to the eighth difference
in performance

00:22:12.270 --> 00:22:15.020
in terms of the number of bits
that these different kinds

00:22:15.020 --> 00:22:16.736
of devices can
actually transmit.

00:22:16.736 --> 00:22:17.860
So, that's pretty dramatic.

00:22:17.860 --> 00:22:21.075
And that's going to make it
difficult to design computer

00:22:21.075 --> 00:22:21.575
systems.

00:22:28.190 --> 00:22:31.510
OK, and these
kinds of variations

00:22:31.510 --> 00:22:37.490
occur not only at
the sort of number

00:22:37.490 --> 00:22:43.940
of bits that we can
send per second,

00:22:43.940 --> 00:22:49.150
but also in terms of the
propagation delay of the links,

00:22:49.150 --> 00:22:50.150
OK?

00:22:50.150 --> 00:22:53.100
So if I have a local
area network that's

00:22:53.100 --> 00:22:55.592
connecting two computers
in my office together,

00:22:55.592 --> 00:22:57.800
I may be able to transmit
a message from one computer

00:22:57.800 --> 00:23:00.374
to the other in an order
of microseconds, OK?

00:23:00.374 --> 00:23:02.040
But as we said before,
to send a message

00:23:02.040 --> 00:23:04.740
all the way across the
country might take 200 ms.

00:23:04.740 --> 00:23:08.310
To send a message
across the Pacific Ocean

00:23:08.310 --> 00:23:11.010
by way of the satellite
around the United States

00:23:11.010 --> 00:23:12.340
might take a second.

00:23:12.340 --> 00:23:14.990
To send a message
to Mars might take

00:23:14.990 --> 00:23:16.860
tens of seconds or a minute.

00:23:16.860 --> 00:23:19.690
OK, so there's this huge range
in terms of transmission times

00:23:19.690 --> 00:23:21.356
that some of these
different links have.

00:23:23.780 --> 00:23:28.690
So, fundamentally these
two things, bit rate

00:23:28.690 --> 00:23:31.650
and propagation delay
are going to tell us

00:23:31.650 --> 00:23:37.660
how long we would expect it to
take for a message to travel

00:23:37.660 --> 00:23:39.990
from one place to the other.

00:23:39.990 --> 00:23:43.470
So for example,
the amount of time,

00:23:43.470 --> 00:23:46.980
so we can think of a
communication link,

00:23:46.980 --> 00:23:53.990
if you like, as being a piece of
pipe, which has some width that

00:23:53.990 --> 00:23:59.230
is the bit rate.

00:23:59.230 --> 00:24:01.360
OK, so the width of the
pipe is the number of bits

00:24:01.360 --> 00:24:03.240
that I can cram down this thing.

00:24:03.240 --> 00:24:06.240
So, a wider pipe I can
shove more data down it.

00:24:06.240 --> 00:24:09.690
But no matter how much data I
can shove down it per second,

00:24:09.690 --> 00:24:12.600
there still is some link
to this pipe, right?

00:24:12.600 --> 00:24:15.440
And that's the sort of
separation between the sender

00:24:15.440 --> 00:24:17.810
and receiver.

00:24:17.810 --> 00:24:20.300
And that's bottlenecked,
as we said before,

00:24:20.300 --> 00:24:21.440
by the speed of light.

00:24:21.440 --> 00:24:23.140
And that's going to
affect how long it

00:24:23.140 --> 00:24:27.171
takes for a message to get from,
say, one endpoint to the other.

00:24:27.171 --> 00:24:28.670
So if you think
about the total time

00:24:28.670 --> 00:24:30.752
to transmit a message
from one guy to the other,

00:24:30.752 --> 00:24:32.210
it's going to be
the amount of time

00:24:32.210 --> 00:24:35.910
it takes to pack the bits into
the beginning of the pipe,

00:24:35.910 --> 00:24:37.790
right, and then
the amount of time

00:24:37.790 --> 00:24:45.319
that it takes for all those
bits to come out the other end.

00:24:45.319 --> 00:24:47.610
So it's going to be some
combination of the propagation

00:24:47.610 --> 00:24:50.062
delay plus the
transmission delay.

00:24:50.062 --> 00:24:51.520
The propagation
delay is just going

00:24:51.520 --> 00:25:02.760
to be equal to length
divided by, say, for example,

00:25:02.760 --> 00:25:05.770
the speed of light.

00:25:05.770 --> 00:25:08.100
And we're going to need to
add to that the transmission

00:25:08.100 --> 00:25:10.700
delay, which is simply going
to be the number of bits

00:25:10.700 --> 00:25:16.200
we have to send divided by the
bit rate, the number of bits

00:25:16.200 --> 00:25:19.140
per second.

00:25:19.140 --> 00:25:27.260
OK, and so this is the time
to send along one link.

00:25:30.530 --> 00:25:35.800
OK, so it's worth remembering
that this time to send

00:25:35.800 --> 00:25:39.210
equation, this is only to
send along a single link.

00:25:39.210 --> 00:25:42.660
If we have to send more data,
if there are multiple people,

00:25:42.660 --> 00:25:47.160
for example, who are waiting
to get access to a link,

00:25:47.160 --> 00:25:50.020
that may increase the delay
that it takes to send a message.

00:25:50.020 --> 00:25:52.339
Or if we have to relay a
message over multiple hops

00:25:52.339 --> 00:25:54.880
and there are some intermediate
node in between each of those

00:25:54.880 --> 00:25:56.590
hops, then that
sort of processing

00:25:56.590 --> 00:25:59.070
at each intermediate node
may take some additional time

00:25:59.070 --> 00:26:00.580
as well.

00:26:00.580 --> 00:26:07.370
OK, so if we look
at a graph of some

00:26:07.370 --> 00:26:10.420
of the properties
of networks, it's

00:26:10.420 --> 00:26:12.710
interesting to sort of
look at the rate of change

00:26:12.710 --> 00:26:14.097
of these different technologies.

00:26:14.097 --> 00:26:15.930
So this is just showing
what Moore's Law is.

00:26:15.930 --> 00:26:17.570
So we saw this before.

00:26:17.570 --> 00:26:19.680
Processor speed
doubles every 18 months

00:26:19.680 --> 00:26:21.920
according to Moore's Law.

00:26:21.920 --> 00:26:25.009
If you look at the size of
the Internet, so the number

00:26:25.009 --> 00:26:26.800
of things that we have
to connect together,

00:26:26.800 --> 00:26:29.060
well, that's been
doubling every 13 months.

00:26:29.060 --> 00:26:32.022
So this has this sort
of exponential behavior

00:26:32.022 --> 00:26:33.230
that Moore's Law has as well.

00:26:33.230 --> 00:26:36.064
So we are talking about
sort of the number of things

00:26:36.064 --> 00:26:37.730
that we have to connect
together is just

00:26:37.730 --> 00:26:39.380
growing at this massive rate.

00:26:39.380 --> 00:26:42.040
And that's a real
challenge for designing

00:26:42.040 --> 00:26:44.590
the kinds of protocols
that we are going to need

00:26:44.590 --> 00:26:47.700
to use in these networks.

00:26:47.700 --> 00:26:49.700
The other thing that we
see that's been going up

00:26:49.700 --> 00:26:52.420
at the same rate or even faster
is the amount of traffic that's

00:26:52.420 --> 00:26:53.360
being sent over the Internet.

00:26:53.360 --> 00:26:55.110
So more and more people
are sending data.

00:26:55.110 --> 00:26:57.610
And again, this
affects the sort of,

00:26:57.610 --> 00:26:59.550
this is the challenge
for designing protocols

00:26:59.550 --> 00:27:02.740
that are able to scale up and
up and up to these greater

00:27:02.740 --> 00:27:05.750
and greater rates.

00:27:05.750 --> 00:27:10.120
The largest link capacity
in the past few years

00:27:10.120 --> 00:27:13.900
has actually started to go up as
fast as double once every seven

00:27:13.900 --> 00:27:14.400
months.

00:27:14.400 --> 00:27:17.220
So this is the size of
the largest pipe that's

00:27:17.220 --> 00:27:20.830
on the Internet, say, connecting
lots of these big service

00:27:20.830 --> 00:27:22.650
providers on the
Internet together.

00:27:22.650 --> 00:27:25.650
And this is just been getting
larger and larger and larger

00:27:25.650 --> 00:27:26.350
as well.

00:27:26.350 --> 00:27:27.850
And so that's,
again, means in order

00:27:27.850 --> 00:27:29.860
to exploit all this
additional link capacity,

00:27:29.860 --> 00:27:31.670
we need faster computers.

00:27:31.670 --> 00:27:37.140
And the rate of
change of technology

00:27:37.140 --> 00:27:38.930
is just extremely high.

00:27:38.930 --> 00:27:40.790
Interestingly enough,
of course, as we

00:27:40.790 --> 00:27:42.802
said before, the speed
of light never changes.

00:27:42.802 --> 00:27:44.260
So this is a
fundamental constraint

00:27:44.260 --> 00:27:45.690
that we're always going
to have to deal with when

00:27:45.690 --> 00:27:47.010
we are building these things.

00:27:47.010 --> 00:27:48.897
That is also the case
that if you look at,

00:27:48.897 --> 00:27:50.730
there's another number
that you can look at.

00:27:50.730 --> 00:27:52.350
And in the context
of the Internet,

00:27:52.350 --> 00:27:56.620
this number is, this is
bits per second per dollar.

00:27:56.620 --> 00:27:59.780
OK, so what does that mean?

00:27:59.780 --> 00:28:03.130
This is the amount
of money that it

00:28:03.130 --> 00:28:06.530
costs to, for example,
send one bit per second

00:28:06.530 --> 00:28:08.240
over the Internet.

00:28:08.240 --> 00:28:10.730
And this number just has not
been scaling up very fast.

00:28:10.730 --> 00:28:12.580
If you look at
this, it's a factor

00:28:12.580 --> 00:28:16.410
of ten cheaper today
than it was in 1980

00:28:16.410 --> 00:28:19.910
to send the same amount
of data per second out

00:28:19.910 --> 00:28:22.710
over the Internet.

00:28:22.710 --> 00:28:28.357
So, why is that?

00:28:28.357 --> 00:28:29.440
That seems strange, right?

00:28:29.440 --> 00:28:31.530
I mean, if you look at the
fundamental technology,

00:28:31.530 --> 00:28:33.650
the technology itself
has gotten much faster.

00:28:33.650 --> 00:28:35.680
If you look at the
Ethernet network

00:28:35.680 --> 00:28:37.680
that you might have in
your home or your office,

00:28:37.680 --> 00:28:41.092
this thing has
gotten, in 1980 you

00:28:41.092 --> 00:28:42.550
might have had one
megabit a second

00:28:42.550 --> 00:28:44.341
that you could transmit
over this Ethernet.

00:28:44.341 --> 00:28:47.174
You can now, for $100
go to Best Buy and buy

00:28:47.174 --> 00:28:49.090
something that can
transmit a gigabit a second

00:28:49.090 --> 00:28:49.798
over an Ethernet.

00:28:49.798 --> 00:28:52.480
OK, so we are talking about
a huge scale up in technology

00:28:52.480 --> 00:28:55.430
in terms of the performance
of the networks.

00:28:55.430 --> 00:28:58.730
The issue here is that
there is a human cost that's

00:28:58.730 --> 00:29:01.850
associated with sending
data out over the Internet.

00:29:01.850 --> 00:29:06.430
And if I want to send data
from here to California,

00:29:06.430 --> 00:29:09.960
there's a physical wire that
that data has to transfer over,

00:29:09.960 --> 00:29:10.480
right?

00:29:10.480 --> 00:29:11.780
And somebody owns that wire.

00:29:11.780 --> 00:29:13.270
And it cost somebody
a lot of money

00:29:13.270 --> 00:29:15.950
to cut the holes in the
ground where that wire runs

00:29:15.950 --> 00:29:17.900
and to knock holes
through buildings

00:29:17.900 --> 00:29:19.580
and to get rights
from all the cities

00:29:19.580 --> 00:29:22.040
that that wire runs through
to dig holes in their roads,

00:29:22.040 --> 00:29:22.540
right?

00:29:22.540 --> 00:29:24.240
So, there is some
very large human cost

00:29:24.240 --> 00:29:27.310
associated with setting up
these sort of very wide area

00:29:27.310 --> 00:29:27.950
internets.

00:29:27.950 --> 00:29:29.850
And you see the
same kind of thing

00:29:29.850 --> 00:29:31.820
not just in wire but
in wireless technology

00:29:31.820 --> 00:29:34.200
with wireless companies
paying huge amounts of money

00:29:34.200 --> 00:29:37.460
for access to the rights
to use a particular part

00:29:37.460 --> 00:29:39.720
of the wireless spectrum.

00:29:39.720 --> 00:29:42.090
So this is these bits
per second per dollar

00:29:42.090 --> 00:29:46.870
is growing slowly, OK, and the
reason for that is human costs.

00:29:52.160 --> 00:29:54.176
OK, and what this
argues for, what

00:29:54.176 --> 00:29:55.800
this suggests that
we are going to need

00:29:55.800 --> 00:29:57.820
to do when we are
building these internets

00:29:57.820 --> 00:30:00.430
or building these
large networks is

00:30:00.430 --> 00:30:02.430
to share these network links.

00:30:02.430 --> 00:30:06.180
So, if every time we added
a new host to the network,

00:30:06.180 --> 00:30:10.940
we had to run a wire
that connected it

00:30:10.940 --> 00:30:12.560
to every other host
in the network.

00:30:12.560 --> 00:30:14.310
Obviously, that would
be hugely expensive,

00:30:14.310 --> 00:30:15.630
so we want to avoid that.

00:30:15.630 --> 00:30:18.400
And so, we are going
to end up because

00:30:18.400 --> 00:30:20.950
of these costs of physically
running the wires having

00:30:20.950 --> 00:30:24.100
to share network connections.

00:30:24.100 --> 00:30:26.780
And that brings us to
sort of the next topic

00:30:26.780 --> 00:30:30.320
that I want to talk about,
which is this topic of sharing.

00:30:40.510 --> 00:30:43.390
OK, so just that
everybody is clear,

00:30:43.390 --> 00:30:46.370
this notion of having
pair-wise links,

00:30:46.370 --> 00:30:48.310
a connection from every
host every other host

00:30:48.310 --> 00:30:49.790
is just not practical.

00:30:49.790 --> 00:30:53.560
So suppose I have them
set of nodes like this,

00:30:53.560 --> 00:30:55.780
if I want to connect
all of them together

00:30:55.780 --> 00:30:58.810
by their own set of
independent wires,

00:30:58.810 --> 00:31:01.320
I don't know if I got
all of them there,

00:31:01.320 --> 00:31:07.220
but then the cost is going
to be, if I have N hosts,

00:31:07.220 --> 00:31:10.690
the cost is going to
be N squared wires.

00:31:10.690 --> 00:31:15.772
OK, and that is just
too expensive, right?

00:31:15.772 --> 00:31:17.230
If you have a
million hosts, you're

00:31:17.230 --> 00:31:18.990
going to have a trillion wires.

00:31:18.990 --> 00:31:21.450
So we don't want to be
building anything that has

00:31:21.450 --> 00:31:24.050
a trillion components in it.

00:31:24.050 --> 00:31:26.890
It's going to be really,
really expensive to deploy.

00:31:26.890 --> 00:31:33.710
So what we end up
doing is multiplexing.

00:31:33.710 --> 00:31:36.100
OK, so what do I mean by that?

00:31:36.100 --> 00:31:38.990
I mean this notion
of sharing links.

00:31:38.990 --> 00:31:40.840
So let's look at
a very simplified

00:31:40.840 --> 00:31:44.670
kind of an architecture for
something like the Internet.

00:31:49.740 --> 00:31:55.350
So suppose I have two hosts, two
nodes, two computers, A and B

00:31:55.350 --> 00:31:57.540
that I want to be able
to communicate over

00:31:57.540 --> 00:32:00.160
a network to some other
pair of nodes, C and D.

00:32:00.160 --> 00:32:04.410
OK, well in a multiplex
network, what we're going to do

00:32:04.410 --> 00:32:08.730
is we're going to have a
set of these boxes that

00:32:08.730 --> 00:32:11.010
are going to connect
these nodes together.

00:32:19.460 --> 00:32:22.900
So I just sort of shown one
possible network topology.

00:32:22.900 --> 00:32:26.905
But with these boxes are, they
are sometimes called switches.

00:32:30.660 --> 00:32:32.220
And they are the
connection points

00:32:32.220 --> 00:32:34.410
that are scattered
in various locations

00:32:34.410 --> 00:32:36.919
around the Internet
that transfer data

00:32:36.919 --> 00:32:38.210
from one location to the other.

00:32:38.210 --> 00:32:43.620
So in your home, you may
well have what's sometimes

00:32:43.620 --> 00:32:44.880
called a wireless router.

00:32:44.880 --> 00:32:47.080
That's the thing that
transfers data from the air

00:32:47.080 --> 00:32:48.100
onto a wire network.

00:32:48.100 --> 00:32:49.990
You may have a box
from your cable company

00:32:49.990 --> 00:32:53.605
that transfers data from
your home out over the cable.

00:32:53.605 --> 00:32:54.980
And then the cable
company itself

00:32:54.980 --> 00:32:57.600
has a box that transfers
data to some other service

00:32:57.600 --> 00:33:00.337
provider, which may be transfers
data across the country, which

00:33:00.337 --> 00:33:02.920
transfers data into the home of
whoever you're trying to send,

00:33:02.920 --> 00:33:04.295
or the business
of whoever you're

00:33:04.295 --> 00:33:05.490
trying to send a message to.

00:33:05.490 --> 00:33:08.660
So you have this set of what
we are calling switches here

00:33:08.660 --> 00:33:12.430
that connect all these
various hosts together.

00:33:12.430 --> 00:33:15.550
And these hosts clearly,
there are connections here

00:33:15.550 --> 00:33:16.480
that are sharing data.

00:33:16.480 --> 00:33:20.730
So if I look at this link here,
if both A and B are trying

00:33:20.730 --> 00:33:23.080
to send data to
C, clearly there's

00:33:23.080 --> 00:33:27.870
going to be some data for both
A and B traveling on this wire.

00:33:27.870 --> 00:33:38.400
And so, what we end up
with is, sorry, so there

00:33:38.400 --> 00:33:41.380
is a set of issues that
are brought up by the fact

00:33:41.380 --> 00:33:44.020
that we are sharing this
data, and that we have

00:33:44.020 --> 00:33:45.810
this kind of switched
infrastructure

00:33:45.810 --> 00:33:47.600
which we are running
data around in.

00:33:47.600 --> 00:33:49.660
So the first issue
that we need to talk

00:33:49.660 --> 00:33:53.890
about that obviously comes
up is this notion of routing.

00:33:53.890 --> 00:33:55.970
OK, so when you see
a graph like this

00:33:55.970 --> 00:33:57.530
and you ask the
question, well, OK,

00:33:57.530 --> 00:34:00.100
how does A get its data to C?

00:34:00.100 --> 00:34:02.520
We have to pick
some route which A

00:34:02.520 --> 00:34:07.530
is going to take
along this path,

00:34:07.530 --> 00:34:09.280
through this network
in order to get to C.

00:34:09.280 --> 00:34:11.654
And, there are a couple of
different alternatives, right?

00:34:11.654 --> 00:34:14.440
So, any time you're
sending a message,

00:34:14.440 --> 00:34:17.460
there has to be something that
plans out how that route is

00:34:17.460 --> 00:34:19.159
going to be transmitted.

00:34:19.159 --> 00:34:20.934
And commonly what
happens is that each one

00:34:20.934 --> 00:34:22.850
of these intermediate
points along the network

00:34:22.850 --> 00:34:27.179
has some table which says how
to get to every other location

00:34:27.179 --> 00:34:28.020
within the network.

00:34:28.020 --> 00:34:31.030
And we'll talk about
how those tables work,

00:34:31.030 --> 00:34:34.090
how these tables that talk about
where to forward your messages

00:34:34.090 --> 00:34:34.830
to work.

00:34:34.830 --> 00:34:38.320
But when a node has multiple
sort of possible locations

00:34:38.320 --> 00:34:41.040
where it can send data out
to, typically that node

00:34:41.040 --> 00:34:41.960
is called a router.

00:34:41.960 --> 00:34:43.219
OK, so if you hear
the term router,

00:34:43.219 --> 00:34:45.343
just think of it as one of
these switch things that

00:34:45.343 --> 00:34:48.139
gets to make a decision about
where some kind of traffic

00:34:48.139 --> 00:34:51.120
is going to be sent to.

00:34:51.120 --> 00:34:56.980
OK, so now what we
need to do in order

00:34:56.980 --> 00:35:00.480
to think a little bit more
about how these switches work

00:35:00.480 --> 00:35:05.860
is to resolve the issue of
how we multiplex traffic

00:35:05.860 --> 00:35:08.320
over one of these links.

00:35:08.320 --> 00:35:10.500
So we said there may be
traffic for both A and B

00:35:10.500 --> 00:35:12.356
running on this
link going into D.

00:35:12.356 --> 00:35:14.480
Well, so how are we going
to interleave the traffic

00:35:14.480 --> 00:35:16.750
from A and B in order
to make this work?

00:35:16.750 --> 00:35:20.200
And there are two techniques.

00:35:20.200 --> 00:35:25.980
We call this technique
for interleaving data,

00:35:25.980 --> 00:35:30.910
we call it switching
or multiplexing.

00:35:30.910 --> 00:35:34.300
And we're going to talk about
two techniques for switching.

00:35:34.300 --> 00:35:37.980
We're going to talk
about circuit switching.

00:35:37.980 --> 00:35:44.110
And we'll talk about
packet switching.

00:35:44.110 --> 00:35:47.180
So circuit switching
is pretty easy

00:35:47.180 --> 00:35:48.880
to understand at
an intuitive level.

00:35:48.880 --> 00:35:50.338
The idea with the
circuit switch is

00:35:50.338 --> 00:35:53.930
that we want to set up
some reserved channel that

00:35:53.930 --> 00:35:56.670
is the communication channel
between two endpoints,

00:35:56.670 --> 00:35:58.710
say for example, A and C.

00:35:58.710 --> 00:36:01.480
So, a simple way if you want to
think about circuit switching

00:36:01.480 --> 00:36:06.440
is to think about the way that
phone networks used to work.

00:36:06.440 --> 00:36:09.730
So you may have seen these old
movies where the operator would

00:36:09.730 --> 00:36:11.480
plug wires into a switchboard.

00:36:11.480 --> 00:36:13.780
What an operator is doing
there is establishing

00:36:13.780 --> 00:36:17.100
a physical circuit, a
physical wire that connects

00:36:17.100 --> 00:36:18.310
two endpoints together.

00:36:18.310 --> 00:36:20.190
OK, so that's circuit switching.

00:36:20.190 --> 00:36:23.060
Each operator has a
bunch of lines coming in

00:36:23.060 --> 00:36:24.490
and a bunch of lines coming out.

00:36:24.490 --> 00:36:25.960
Somebody connects
to the operator

00:36:25.960 --> 00:36:28.840
and says I want
to talk to line A.

00:36:28.840 --> 00:36:32.490
And the operator establishes
the physical connection.

00:36:32.490 --> 00:36:34.760
So, of course we don't
use that technology

00:36:34.760 --> 00:36:37.050
for doing circuit
switching anymore,

00:36:37.050 --> 00:36:38.960
but this notion of
circuit switching

00:36:38.960 --> 00:36:41.920
is still used in the
telephone system.

00:36:41.920 --> 00:36:44.630
And the way that a common
digital telephone system

00:36:44.630 --> 00:36:48.100
might work is as follows.

00:36:48.100 --> 00:36:55.970
So the idea is that suppose I
have some set of nodes A, B,

00:36:55.970 --> 00:37:01.480
and C, all of which want to send
their data out over some line.

00:37:01.480 --> 00:37:05.610
So they are connecting
up to some switch.

00:37:05.610 --> 00:37:08.230
And they want us their
data out over this switch,

00:37:08.230 --> 00:37:12.270
out over this wire that is on
the other side of this switch.

00:37:12.270 --> 00:37:16.220
OK, so what this kind of
switching that we are going

00:37:16.220 --> 00:37:19.580
to talk about does, which is
commonly called TDM for Time

00:37:19.580 --> 00:37:21.205
Division Multiplexing --

00:37:31.890 --> 00:37:35.040
is to give each
one of these nodes,

00:37:35.040 --> 00:37:37.190
A, B, and C, a
little unit of time

00:37:37.190 --> 00:37:40.350
in which only its traffic is
being transmitted on this wire.

00:37:40.350 --> 00:37:45.350
So if you think of
this wire as having

00:37:45.350 --> 00:37:47.250
one additional
piece of information

00:37:47.250 --> 00:37:51.410
put on at each unit of time, and
this is the wire stretching out

00:37:51.410 --> 00:37:54.130
away from the host so
that this is sort of time

00:37:54.130 --> 00:37:57.080
is going this way as the signal
propagates down the wire.

00:37:57.080 --> 00:37:59.496
And if you were to look at all
the different messages that

00:37:59.496 --> 00:38:02.960
are on the wire, what you see
is sort of a repeating pattern

00:38:02.960 --> 00:38:04.900
of time intervals.

00:38:04.900 --> 00:38:07.410
And each of these time
intervals would be carved up

00:38:07.410 --> 00:38:08.480
into a number of slots.

00:38:14.600 --> 00:38:22.440
OK, and each slot is allocated
to exactly one of these nodes.

00:38:22.440 --> 00:38:24.670
And each node gets the
same slot and each one

00:38:24.670 --> 00:38:26.100
of these larger intervals.

00:38:26.100 --> 00:38:29.110
OK, so you'd see a pattern
like A's traffic, B's traffic,

00:38:29.110 --> 00:38:30.447
C's traffic, and so on.

00:38:30.447 --> 00:38:32.030
And then in the next
interval we would

00:38:32.030 --> 00:38:34.620
have A's traffic, B's traffic,
and C's traffic again.

00:38:34.620 --> 00:38:36.730
So there would be
this repeating pattern

00:38:36.730 --> 00:38:40.250
where each node is associated
to the same slot in every one

00:38:40.250 --> 00:38:41.870
of these intervals, OK?

00:38:41.870 --> 00:38:44.440
And we call the data
that, say, for example, A

00:38:44.440 --> 00:38:48.050
puts into a slot a frame.

00:38:48.050 --> 00:38:52.520
The frame is sort
of the set of data

00:38:52.520 --> 00:38:55.150
that is allocated to a node.

00:38:55.150 --> 00:38:57.942
And, so this is
basically the way

00:38:57.942 --> 00:38:59.150
that circuit switching works.

00:38:59.150 --> 00:39:01.399
And it's almost exactly the
way that the phone network

00:39:01.399 --> 00:39:02.050
works now.

00:39:02.050 --> 00:39:04.044
So a phone network
carves up the wire

00:39:04.044 --> 00:39:05.710
into a bunch of these
little slots where

00:39:05.710 --> 00:39:11.140
each conversation is allocated
one of these sort of frames

00:39:11.140 --> 00:39:12.180
in each interval.

00:39:12.180 --> 00:39:17.250
So in a typical phone network,
a frame might be eight bits.

00:39:17.250 --> 00:39:20.060
And there might be
these intervals.

00:39:20.060 --> 00:39:22.110
There might be 8,000
of them per second.

00:39:22.110 --> 00:39:26.250
OK, so we have 8,000
intervals per second.

00:39:26.250 --> 00:39:32.510
OK, and so what that means is
that if each frame is eight

00:39:32.510 --> 00:39:34.120
bits and there is
8,000 intervals,

00:39:34.120 --> 00:39:37.370
each sender can send
64,000 bits per second.

00:39:37.370 --> 00:39:39.980
And, it turns out that
64,000 bits per second

00:39:39.980 --> 00:39:43.800
is about enough to be
able to encode voice

00:39:43.800 --> 00:39:47.830
at a sort of acceptable
level for people.

00:39:47.830 --> 00:39:51.360
So we can talk about the
capacity of this channel

00:39:51.360 --> 00:39:53.950
by basically looking
at the number of frames

00:39:53.950 --> 00:39:55.110
that are in one interval.

00:39:55.110 --> 00:39:59.230
So if we say there are N
max frames in one interval,

00:39:59.230 --> 00:40:02.190
then that specifies the
number of conversations

00:40:02.190 --> 00:40:05.400
that we can simultaneously
maintain on this wire.

00:40:05.400 --> 00:40:07.900
OK, so the behavior of one of
these circuit-switched systems

00:40:07.900 --> 00:40:11.210
is as follows: everybody
who's having a conversation

00:40:11.210 --> 00:40:14.620
has bandwidth allocated to
them, and has a frame allocated

00:40:14.620 --> 00:40:16.110
to them in every interval.

00:40:16.110 --> 00:40:19.530
So, up to N max conversations
can be held simultaneously

00:40:19.530 --> 00:40:20.780
and there's no problem.

00:40:20.780 --> 00:40:23.890
But as soon as we
get to the N max

00:40:23.890 --> 00:40:26.930
plus first guy tries
to initiate a call,

00:40:26.930 --> 00:40:29.414
the network will simply refuse
to accept that connection

00:40:29.414 --> 00:40:31.330
because there's no slot
available for this guy

00:40:31.330 --> 00:40:33.820
to do his communication.

00:40:33.820 --> 00:40:38.390
And the last little detail about
how these circuit switches work

00:40:38.390 --> 00:40:40.930
is how do we actually
establish a connection

00:40:40.930 --> 00:40:43.170
in the first place?

00:40:43.170 --> 00:40:47.650
And we need some protocol
for actually resorting

00:40:47.650 --> 00:40:49.550
to a slot for a
particular connection

00:40:49.550 --> 00:40:51.360
between a pair of endpoints.

00:40:51.360 --> 00:40:52.900
And so typically
what you will do

00:40:52.900 --> 00:40:55.790
is reserve some frame
or set of frames

00:40:55.790 --> 00:40:58.550
to carry information that's
used to configure the connection

00:40:58.550 --> 00:41:00.010
between the endpoints.

00:41:00.010 --> 00:41:04.360
So, A can request that
an interval be assigned

00:41:04.360 --> 00:41:07.240
to its connection
between C, and then it

00:41:07.240 --> 00:41:12.570
will be by communicating
during a special frame.

00:41:12.570 --> 00:41:16.730
OK, so that's circuit switching.

00:41:16.730 --> 00:41:20.834
But, circuit switching
has a problem.

00:41:20.834 --> 00:41:23.250
And we're going to need to
introduce this notion of packet

00:41:23.250 --> 00:41:24.333
switching to deal with it.

00:41:29.010 --> 00:41:32.390
OK, so the reason that circuit
switching has a problem

00:41:32.390 --> 00:41:34.920
is as follows: because although
circuit switching works

00:41:34.920 --> 00:41:37.280
great for voice where every
conversation is essentially

00:41:37.280 --> 00:41:41.390
a continuous stream of audio
that can always be encoded

00:41:41.390 --> 00:41:45.300
at about 64 kb per second,
Internet traffic just

00:41:45.300 --> 00:41:46.750
doesn't work like that, right?

00:41:46.750 --> 00:41:48.583
People who are communicating
on the Internet

00:41:48.583 --> 00:41:51.162
can have very variable demands
for the amount of traffic

00:41:51.162 --> 00:41:52.120
that they want to send.

00:41:52.120 --> 00:41:55.270
And even taken as an aggregate,
taking all the people who

00:41:55.270 --> 00:41:58.700
are, say, for example at the
community of MIT over time,

00:41:58.700 --> 00:42:00.580
there still is a
lot of variation

00:42:00.580 --> 00:42:01.840
in the network demand.

00:42:01.840 --> 00:42:05.600
So this is just a plot over the
course of the day with samples

00:42:05.600 --> 00:42:08.060
taken every five minutes
of the amount of traffic

00:42:08.060 --> 00:42:13.421
that was being sent out
of one of MIT's labs.

00:42:13.421 --> 00:42:15.670
OK, and so you don't need
to worry too much about what

00:42:15.670 --> 00:42:16.800
these different lines show.

00:42:16.800 --> 00:42:19.630
But the point is that there
are these periodic spikes.

00:42:19.630 --> 00:42:23.510
And these spikes represent
spikes of traffic

00:42:23.510 --> 00:42:25.730
demand a different
machines on the network.

00:42:25.730 --> 00:42:28.050
So you can see that at any
given point in time, there

00:42:28.050 --> 00:42:31.280
can be anywhere
from, at its lowest,

00:42:31.280 --> 00:42:38.430
these numbers are about 40 Mb
per second to numbers as high

00:42:38.430 --> 00:42:39.600
as 100 Mb a second.

00:42:39.600 --> 00:42:43.817
So there's a lot of variation
in the demand at MIT's network.

00:42:43.817 --> 00:42:45.900
Here's another way of
looking at the same traffic.

00:42:45.900 --> 00:42:47.108
This is an interesting graph.

00:42:47.108 --> 00:42:48.770
This is showing the
amount of traffic

00:42:48.770 --> 00:42:50.710
that different protocols use.

00:42:50.710 --> 00:42:53.199
This is a real graph by the way.

00:42:53.199 --> 00:42:54.740
This is showing the
amount of traffic

00:42:54.740 --> 00:42:58.660
that is transmitted over MIT's
network for different types

00:42:58.660 --> 00:42:59.450
of protocols.

00:42:59.450 --> 00:43:02.420
And what you see here is that
it's really pretty amazing.

00:43:02.420 --> 00:43:05.310
You see that Kazaa, this
file trading network,

00:43:05.310 --> 00:43:10.210
is using up a vast majority of
the traffic that we send out

00:43:10.210 --> 00:43:11.590
of MIT.

00:43:11.590 --> 00:43:14.970
But besides that, there's
another interesting point

00:43:14.970 --> 00:43:17.760
which is that noticed during the
months of October and November,

00:43:17.760 --> 00:43:20.399
the two leftmost
lines here, we are

00:43:20.399 --> 00:43:22.940
sending a lot more traffic than
during the month of December.

00:43:22.940 --> 00:43:24.481
So, if you were at
MIT and are trying

00:43:24.481 --> 00:43:26.950
to plan how much traffic you
expected to be transmitted

00:43:26.950 --> 00:43:28.850
during a month,
this makes it hard

00:43:28.850 --> 00:43:31.160
because there was a 50% drop
in the amount of traffic

00:43:31.160 --> 00:43:34.010
from one month on
this Kazaa network.

00:43:34.010 --> 00:43:36.620
So we need to introduce
this notion of packet

00:43:36.620 --> 00:43:40.150
switching to deal with this
problem of unpredictable rates.

00:43:47.940 --> 00:43:52.430
OK, so in many kinds
of data networks,

00:43:52.430 --> 00:43:54.306
it's simply not
possible to predict

00:43:54.306 --> 00:43:56.180
exactly how much traffic
you're going to need

00:43:56.180 --> 00:43:58.540
to send at any point in time.

00:43:58.540 --> 00:44:00.010
And so the idea is
to use something

00:44:00.010 --> 00:44:03.764
called asynchronous multiplexing
instead of time division

00:44:03.764 --> 00:44:04.305
multiplexing.

00:44:10.060 --> 00:44:11.490
And the idea is as follows.

00:44:11.490 --> 00:44:17.560
Suppose we have our three nodes,
A, B, and C all transmitting

00:44:17.560 --> 00:44:21.360
data through some
switch out over a wire

00:44:21.360 --> 00:44:22.936
just like we did before.

00:44:22.936 --> 00:44:24.310
If you look at
the traffic that's

00:44:24.310 --> 00:44:28.250
being transmitted on this
wire, what you'll see

00:44:28.250 --> 00:44:33.004
is that it's not
necessarily going

00:44:33.004 --> 00:44:35.170
to have the same regular
pattern that we had before.

00:44:35.170 --> 00:44:37.330
The idea is that
any node is allowed

00:44:37.330 --> 00:44:40.130
to try and start talking on this
wire any time that it wants.

00:44:40.130 --> 00:44:41.270
It's asynchronous.

00:44:41.270 --> 00:44:42.380
It's not timed.

00:44:42.380 --> 00:44:45.330
There's no regular slots when
nodes are required to transmit.

00:44:45.330 --> 00:44:47.280
So this might be traffic for A.

00:44:47.280 --> 00:44:48.520
This might be traffic for A.

00:44:48.520 --> 00:44:53.530
This might be traffic
for B, A, A, and C.

00:44:53.530 --> 00:44:59.880
OK, so what this
suggests, and noticed

00:44:59.880 --> 00:45:03.310
that these packages of data
that are being transmitted

00:45:03.310 --> 00:45:04.980
are of different sizes.

00:45:04.980 --> 00:45:07.080
Typically these
are called packets.

00:45:07.080 --> 00:45:08.920
And that's what this
is packet switching

00:45:08.920 --> 00:45:11.740
because we are sending the full
packages of information that

00:45:11.740 --> 00:45:14.070
are of a variable size as
opposed to these fixed size

00:45:14.070 --> 00:45:16.434
frames that we were
transmitting before.

00:45:16.434 --> 00:45:18.850
And notice that there is no
requirement that A transmitted

00:45:18.850 --> 00:45:19.710
any specific time.

00:45:19.710 --> 00:45:23.410
A is allowed to try and
transmit as much as it wants.

00:45:23.410 --> 00:45:25.250
But this does
introduce a complexity

00:45:25.250 --> 00:45:27.560
because it makes it hard
to plan for the capacity

00:45:27.560 --> 00:45:28.420
of the network.

00:45:28.420 --> 00:45:30.570
So suppose that
each of A, B, and C

00:45:30.570 --> 00:45:36.320
have a 1 Mb per second link, and
suppose that this link is also

00:45:36.320 --> 00:45:37.310
1 Mb per second.

00:45:40.200 --> 00:45:43.830
Now, clearly if A, B, and C
are rarely sending any traffic,

00:45:43.830 --> 00:45:45.760
then everybody
may be able to get

00:45:45.760 --> 00:45:47.200
all its data onto the network.

00:45:47.200 --> 00:45:48.870
But if A, B, and C
all decide that they

00:45:48.870 --> 00:45:51.817
want to send at the same
time at 1 Mb per second,

00:45:51.817 --> 00:45:53.900
then there's going to be
a problem because they're

00:45:53.900 --> 00:45:56.520
going to be trying to send
more data over this link them

00:45:56.520 --> 00:45:58.520
the link has capacity for.

00:45:58.520 --> 00:46:00.210
And so what that
immediately suggests

00:46:00.210 --> 00:46:02.610
is that in these boxes, in
these packet switch networks,

00:46:02.610 --> 00:46:04.080
there is some kind of a queue.

00:46:04.080 --> 00:46:06.610
OK, so we're doing queuing
within the network.

00:46:12.400 --> 00:46:17.970
But it also, so you
might ask the question,

00:46:17.970 --> 00:46:21.160
why don't network designers
design these packet switch

00:46:21.160 --> 00:46:25.560
networks so that you
never have a link that's

00:46:25.560 --> 00:46:27.550
connecting multiple
endpoints together

00:46:27.550 --> 00:46:30.350
that doesn't have sufficient
capacity to transmit all

00:46:30.350 --> 00:46:32.830
of the information from all
of the endpoints that may

00:46:32.830 --> 00:46:34.922
be transmitting data over it?

00:46:34.922 --> 00:46:36.630
But if you think about
this for a second,

00:46:36.630 --> 00:46:38.171
that's going to be
a really bad idea.

00:46:38.171 --> 00:46:39.650
So suppose we are
on the Internet.

00:46:39.650 --> 00:46:44.830
And suppose that I am
designing simple website.

00:46:44.830 --> 00:46:47.620
I want to set up a website
for students of 6.033.

00:46:47.620 --> 00:46:50.410
If I needed to make sure
that that website had

00:46:50.410 --> 00:46:53.370
sufficient bandwidth that
could support connections

00:46:53.370 --> 00:46:55.080
from everybody who
is on the Internet

00:46:55.080 --> 00:46:58.130
just in case everybody who's on
the Internet decided to access

00:46:58.130 --> 00:47:00.015
that website at
exactly the same time,

00:47:00.015 --> 00:47:01.390
I would be in big
trouble, right,

00:47:01.390 --> 00:47:03.431
because I would have to
have hundreds of terabits

00:47:03.431 --> 00:47:06.456
of bandwidth available
to me in order

00:47:06.456 --> 00:47:07.580
to be able to support that.

00:47:07.580 --> 00:47:09.079
So clearly I'm not
going to do that.

00:47:09.079 --> 00:47:11.650
Instead, what I'm going to do
as a network designer is simply

00:47:11.650 --> 00:47:14.614
try and ensure that most
of the time my network has

00:47:14.614 --> 00:47:16.280
enough bandwidth
available for the users

00:47:16.280 --> 00:47:17.530
were going to be accessing it.

00:47:17.530 --> 00:47:19.440
But some of the time,
there may not be.

00:47:19.440 --> 00:47:22.630
I may sort of under-provision
the network, may not

00:47:22.630 --> 00:47:24.930
provide enough resources.

00:47:24.930 --> 00:47:30.550
And so during those times
when the network has

00:47:30.550 --> 00:47:33.100
more data that's trying
to be sent over it than it

00:47:33.100 --> 00:47:36.690
could possibly send, we
call those congestion times.

00:47:36.690 --> 00:47:39.790
And when a network is subject
to long periods of congestion,

00:47:39.790 --> 00:47:42.900
these queues that are sitting
in the network may fill up.

00:47:42.900 --> 00:47:44.420
So these queues are
some fixed size.

00:47:44.420 --> 00:47:46.620
They are stored typically
in RAM on a device,

00:47:46.620 --> 00:47:48.430
and they can over-fill.

00:47:48.430 --> 00:47:52.030
And when they over-fill, we
have to do something about it.

00:47:52.030 --> 00:47:54.970
OK, so this problem of
congestion in networks

00:47:54.970 --> 00:47:59.240
leads to all sorts of kind
of interesting trade-offs

00:47:59.240 --> 00:48:01.340
in the design of these
packet switch networks.

00:48:01.340 --> 00:48:04.450
And typically the bottom
line is basically,

00:48:04.450 --> 00:48:07.990
and we'll talk about
this in much more detail,

00:48:07.990 --> 00:48:10.730
but the bottom line is
typically these packet

00:48:10.730 --> 00:48:14.220
switch networks have to be able
to drop data some of the time.

00:48:14.220 --> 00:48:16.030
If a queue over-fills,
the network

00:48:16.030 --> 00:48:19.060
has no choice but to refuse
to transmit data for somebody.

00:48:19.060 --> 00:48:21.920
But because these packet
switch networks are composed

00:48:21.920 --> 00:48:23.400
of multiple routers
along the way,

00:48:23.400 --> 00:48:25.630
it may be that the data
is actually dropped deep

00:48:25.630 --> 00:48:29.000
in the network by some router
not when I first try and send

00:48:29.000 --> 00:48:32.750
the data, but five hops down the
line the data may be dropped.

00:48:32.750 --> 00:48:37.790
And so these kinds
of things complicate

00:48:37.790 --> 00:48:39.300
the design of these systems.

00:48:39.300 --> 00:48:41.260
Queuing means there's
variable delay.

00:48:41.260 --> 00:48:44.220
OK, and congestion means
there may be data that's lost.

00:48:44.220 --> 00:48:47.200
And to deal with lost, we may
have to retransmit packets.

00:48:47.200 --> 00:48:52.500
And so this gets the sort
of fundamental notion

00:48:52.500 --> 00:48:55.650
that's going to come up in the
design of these packet switch

00:48:55.650 --> 00:48:57.990
networks, and that's
that the extraction

00:48:57.990 --> 00:49:00.200
that these packet
switch networks provides

00:49:00.200 --> 00:49:03.100
is so-called best
effort networking.

00:49:08.100 --> 00:49:10.660
And that means at
the lowest level,

00:49:10.660 --> 00:49:13.110
these networks don't
guarantee that the data

00:49:13.110 --> 00:49:15.350
that you send over them
will actually be delivered.

00:49:15.350 --> 00:49:17.180
All they say is
the network is sort

00:49:17.180 --> 00:49:18.990
of promising that it
will try hard to get

00:49:18.990 --> 00:49:20.220
the data to be delivered.

00:49:20.220 --> 00:49:23.000
But you as a user,
the applications that

00:49:23.000 --> 00:49:24.690
are using this run
network interface

00:49:24.690 --> 00:49:26.810
need to understand that
this variable delay,

00:49:26.810 --> 00:49:28.410
they need to
understand that there's

00:49:28.410 --> 00:49:29.993
congestion that can
happen which means

00:49:29.993 --> 00:49:31.460
that packets can be dropped.

00:49:31.460 --> 00:49:33.680
Congestion also means
that typically packets

00:49:33.680 --> 00:49:35.570
may be retransmitted.

00:49:35.570 --> 00:49:37.640
And so that means
that all of your data

00:49:37.640 --> 00:49:39.500
may not arrive at the other end.

00:49:39.500 --> 00:49:42.477
And so this is the best
effort network abstraction,

00:49:42.477 --> 00:49:44.810
and we're going to talk about
these kinds of best effort

00:49:44.810 --> 00:49:48.080
network abstractions exclusively
for the next several weeks

00:49:48.080 --> 00:49:50.132
as opposed to these
circuit switch networks.

00:49:50.132 --> 00:49:51.590
And what we're
going to do is we're

00:49:51.590 --> 00:49:54.040
going to see how we can build
up a set of software that

00:49:54.040 --> 00:49:56.790
runs on top of these best
effort networks that allows us

00:49:56.790 --> 00:49:59.480
to provide things
like, for example,

00:49:59.480 --> 00:50:04.020
some reasonable guarantee of
reliable delivery, that data

00:50:04.020 --> 00:50:08.030
won't be lost as data is
transmitted over the network.

00:50:08.030 --> 00:50:09.730
So we will see how
we build up layers

00:50:09.730 --> 00:50:11.440
on top of this
best effort network

00:50:11.440 --> 00:50:14.760
stack that allow us to provide
certain guarantees to the user.

00:50:14.760 --> 00:50:17.690
So that's it for today, and
tomorrow we will talk about,

00:50:17.690 --> 00:50:20.425
starting Monday we will
talk about the link layer

00:50:20.425 --> 00:50:21.550
interface for these things.

00:50:21.550 --> 00:50:23.790
Don't forget about the exam.

