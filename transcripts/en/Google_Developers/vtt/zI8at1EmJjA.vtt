WEBVTT
Kind: captions
Language: en

00:00:02.367 --> 00:00:03.367
Pamela Fox: Just curious,
how many of you

00:00:03.367 --> 00:00:04.901
were in the earlier talk?

00:00:04.901 --> 00:00:06.567
The grab bag
kind of--sweet.

00:00:06.567 --> 00:00:08.033
All right, cool,
you guys are like--

00:00:08.033 --> 00:00:12.734
we just kind of have a club of
people that like maps and stuff.

00:00:12.734 --> 00:00:15.868
All right, so now
we're gonna get into

00:00:15.868 --> 00:00:19.067
a bit more
of an advanced topic,

00:00:19.067 --> 00:00:21.667
and talking specifically about--
we're talking about

00:00:21.667 --> 00:00:25.100
the 2D maps APIs here
and performance tips.

00:00:25.100 --> 00:00:27.200
As we know,
performance is really important

00:00:27.200 --> 00:00:29.501
to making
good websites.

00:00:29.501 --> 00:00:31.701
And there's a couple of us
that are gonna be talking today,

00:00:31.701 --> 00:00:34.801
so there's me, and most
of you guys know me now,

00:00:34.801 --> 00:00:37.734
and we have Sasha
from Redfin,

00:00:37.734 --> 00:00:41.400
and we have
Marcelo from Google,

00:00:41.400 --> 00:00:44.767
from the Sydney office.

00:00:44.767 --> 00:00:46.434
Do I need this part?
Right, right.

00:00:46.434 --> 00:00:48.601
So, uh, so the reason
we're talking about this:

00:00:48.601 --> 00:00:50.133
because one of the things
that's really important

00:00:50.133 --> 00:00:52.934
to us at Google
is latency.

00:00:52.934 --> 00:00:56.501
And I'm sure you heard spiels
from Larry and Sergei before,

00:00:56.501 --> 00:00:58.601
but basically,
we're not gonna launch something

00:00:58.601 --> 00:01:00.267
unless it's fast enough,
right?

00:01:00.267 --> 00:01:03.767
If the web page is fast, then
the user is happier using it,

00:01:03.767 --> 00:01:05.868
and they can get
what they want to faster.

00:01:05.868 --> 00:01:08.033
And when you think about it
from a Google perspective,

00:01:08.033 --> 00:01:10.200
that means more time
for them to click on ads.

00:01:10.200 --> 00:01:12.200
So, uh,
more money, right?

00:01:12.200 --> 00:01:14.501
So that's what, you know,
kinda what it boils down to,

00:01:14.501 --> 00:01:16.267
but, basically,
latency is really important,

00:01:16.267 --> 00:01:17.801
and we want to make sure
that you guys

00:01:17.801 --> 00:01:21.901
can use our stuff,
and create fast experiences

00:01:21.901 --> 00:01:24.200
for your users.

00:01:24.200 --> 00:01:26.934
It's really when I--
like, I monitor Twitter

00:01:26.934 --> 00:01:28.434
for Google maps API,

00:01:28.434 --> 00:01:29.801
and whenever
I see somebody say,

00:01:29.801 --> 00:01:31.601
"Oh, the Google maps API
is taking too long,"

00:01:31.601 --> 00:01:34.834
then I get really sad
and cry.

00:01:34.834 --> 00:01:37.100
So this is really just
a session

00:01:37.100 --> 00:01:38.334
so that I don't cry as much.

00:01:38.334 --> 00:01:40.667
Still a bit, though.

00:01:40.667 --> 00:01:43.167
All right, so, um,

00:01:43.167 --> 00:01:46.033
one of the initial things
that makes an API slow

00:01:46.033 --> 00:01:49.033
is actually
loading the API

00:01:49.033 --> 00:01:51.067
because JavaScript
loads into the browser.

00:01:51.067 --> 00:01:55.701
And to talk about that
we have Marcelo.

00:01:55.701 --> 00:01:58.701
Marcelo: Hi, guys,
my name is Marcelo.

00:01:58.701 --> 00:02:01.968
I work on the Maps API team
back in Sydney,

00:02:01.968 --> 00:02:03.567
and I'm here to talk about
latency issues

00:02:03.567 --> 00:02:06.801
when loading
the JavaScript API.

00:02:06.801 --> 00:02:08.334
So, as you know,
the browser has--

00:02:08.334 --> 00:02:09.667
there are
a lot of resources

00:02:09.667 --> 00:02:13.133
before I can actually display
interactable, uh, map

00:02:13.133 --> 00:02:14.501
to the user.

00:02:14.501 --> 00:02:18.267
Mainly image files
and JavaScript files.

00:02:18.267 --> 00:02:21.901
These resources are loaded
in a very well-defined sequence.

00:02:21.901 --> 00:02:23.968
And let's call, for now,
the sequence

00:02:23.968 --> 00:02:25.834
the Loading Sequence.

00:02:25.834 --> 00:02:28.334
So I think it's interesting
for us to take a closer look

00:02:28.334 --> 00:02:31.601
at how time is spent
during this loading sequence.

00:02:31.601 --> 00:02:37.000
that can have some insight about
where the latency hotspots are.

00:02:37.000 --> 00:02:39.033
So the first thing
that comes down the pipe

00:02:39.033 --> 00:02:40.100
is the bootstrap.

00:02:40.100 --> 00:02:42.601
The bootstrap is
a small JavaScript file

00:02:42.601 --> 00:02:44.033
that the browser
downloads

00:02:44.033 --> 00:02:47.534
when it encounters
the maps API--

00:02:47.534 --> 00:02:50.601
the script tag
at the top of the page.

00:02:50.601 --> 00:02:53.501
The bootstrap comes down,
gets executed

00:02:53.501 --> 00:02:56.501
at around 2.5 seconds,

00:02:56.501 --> 00:03:01.467
and it will then download
main.js.

00:03:01.467 --> 00:03:06.334
Main.js is the bulk
of the JavaScript API.

00:03:06.334 --> 00:03:08.400
It get downloaded
and initialized

00:03:08.400 --> 00:03:11.033
at around
3.1 seconds.

00:03:13.234 --> 00:03:16.300
It's only after the page
has set a center on the map,

00:03:16.300 --> 00:03:19.300
that the map will actually
start downloading tiles.

00:03:19.300 --> 00:03:20.968
On a typical map,

00:03:20.968 --> 00:03:25.434
we know that setCenter's called
at around 3.8 seconds,

00:03:25.434 --> 00:03:28.167
and the tiles
will finish downloading

00:03:28.167 --> 00:03:30.400
at around
4.6 seconds.

00:03:30.400 --> 00:03:32.734
So, there you have it--
around five seconds

00:03:32.734 --> 00:03:35.834
before the user can actually
start interacting with the map.

00:03:35.834 --> 00:03:39.667
It's not too bad,
but it's not great.

00:03:39.667 --> 00:03:43.200
But if you look on
the iPhone and Adroid platform,

00:03:43.200 --> 00:03:45.100
the numbers look
pretty scary.

00:03:46.801 --> 00:03:48.934
Main.js, for instance,
takes nine seconds

00:03:48.934 --> 00:03:50.834
to download
on the iPhone.

00:03:50.834 --> 00:03:52.601
That's in comparison
to 3.1 seconds

00:03:52.601 --> 00:03:54.534
on the desktop platform.

00:03:54.534 --> 00:03:56.400
And the tiles
would only be visible

00:03:56.400 --> 00:03:58.267
after 18 seconds.

00:03:58.267 --> 00:04:02.534
That's 13 seconds later than
you would on a desktop platform.

00:04:02.534 --> 00:04:07.968
So we think
that's pretty unacceptable.

00:04:07.968 --> 00:04:10.133
So there's
a couple reasons for that.

00:04:10.133 --> 00:04:12.334
One of the reasons--
just too many files

00:04:12.334 --> 00:04:16.267
for the browser
to download.

00:04:16.267 --> 00:04:19.234
First, it comes the boostrap
and then main.js,

00:04:19.234 --> 00:04:21.167
and they have to be,
because of their nature,

00:04:21.167 --> 00:04:23.000
they have to be
downloaded in sequence.

00:04:23.000 --> 00:04:24.267
We can not
paralyze those.

00:04:24.267 --> 00:04:27.467
And only after the map
know where the center is,

00:04:27.467 --> 00:04:30.634
they can start
downloading the tiles.

00:04:30.634 --> 00:04:34.100
A typical map will require
from 9, 12,

00:04:34.100 --> 00:04:37.434
all the way up to
25, 36 tiles,

00:04:37.434 --> 00:04:39.467
depending on
the size of the map.

00:04:39.467 --> 00:04:41.567
And, as you guys may know,

00:04:41.567 --> 00:04:44.901
each file request
carries a lot of overhead,

00:04:44.901 --> 00:04:46.901
especially over
a high-latency network,

00:04:46.901 --> 00:04:48.434
like 3-D,
for instance.

00:04:48.434 --> 00:04:53.701
So that's where
the 19 seconds is coming from.

00:04:55.033 --> 00:04:57.434
So what we suggest
to get around this

00:04:57.434 --> 00:04:59.701
is to use
the Static Map API.

00:04:59.701 --> 00:05:01.133
So with the
Static Map API,

00:05:01.133 --> 00:05:03.067
you can fetch
a static view of the map,

00:05:03.067 --> 00:05:05.234
put that into--
into the maptive,

00:05:05.234 --> 00:05:07.434
and you're able to show,
you know,

00:05:07.434 --> 00:05:10.167
a useful map to your user
much earlier.

00:05:10.167 --> 00:05:11.701
Of course,
it won't be interactable,

00:05:11.701 --> 00:05:13.534
but the user
will get to see something

00:05:13.534 --> 00:05:15.601
while he's waiting
for the

00:05:15.601 --> 00:05:17.801
[indistinct] API to be
downloaded in the background.

00:05:17.801 --> 00:05:19.067
If you do that,

00:05:19.067 --> 00:05:22.434
you will be replacing,
in this specific example,

00:05:22.434 --> 00:05:29.501
a 200KB download,
split over 10, 20 small files,

00:05:30.868 --> 00:05:35.467
with a single download
of around 80KB in size.

00:05:35.467 --> 00:05:37.267
So it's, you know--

00:05:37.267 --> 00:05:39.667
you're much more likely
to give a map

00:05:39.667 --> 00:05:42.067
to a user earlier.

00:05:42.067 --> 00:05:44.634
I have
a little demo here

00:05:44.634 --> 00:05:45.667
that implements this.

00:05:45.667 --> 00:05:49.000
Let me just
show you guys.

00:05:52.634 --> 00:05:54.634
Let me just...

00:06:00.467 --> 00:06:01.701
May I?

00:06:01.701 --> 00:06:03.701
I clear your cache.
Pamela: Uh, yeah.

00:06:03.701 --> 00:06:05.200
Marcelo: Okay.

00:06:05.200 --> 00:06:08.767
So let's just see here
the on-demand demo.

00:06:12.834 --> 00:06:14.834
Pamela: Thank you to Barry
in the audience

00:06:14.834 --> 00:06:16.767
for this demo.

00:06:19.234 --> 00:06:24.801
Marcelo: Uh, okay.

00:06:24.801 --> 00:06:25.801
Pamela: What are you
looking for?

00:06:25.801 --> 00:06:28.200
Marcelo: Uh, sorry, oh.

00:06:28.200 --> 00:06:29.834
Pamela: Oh, yeah.
Marcelo: Okay, there you go.

00:06:29.834 --> 00:06:32.367
So you can see there,
it's downloading

00:06:32.367 --> 00:06:34.601
the page
and just a static map,

00:06:34.601 --> 00:06:36.033
and show that
shortly to the user,

00:06:36.033 --> 00:06:38.601
and wait until
the user clicks--

00:06:38.601 --> 00:06:39.801
the user click
on the map.

00:06:39.801 --> 00:06:42.200
That's when--

00:06:42.200 --> 00:06:45.300
the JavaScript API
is actually downloaded.

00:06:45.300 --> 00:06:48.400
And this other demo here

00:06:48.400 --> 00:06:51.367
does sort of
the same,

00:06:51.367 --> 00:06:52.667
but it doesn't wait
for the user

00:06:52.667 --> 00:06:53.868
to track
to the map.

00:06:53.868 --> 00:06:55.767
So it doesn't
transition really quickly.

00:06:55.767 --> 00:06:57.300
Of course,
if your user

00:06:57.300 --> 00:06:58.834
is in a slow connection,

00:06:58.834 --> 00:07:01.567
he--there will be
a delay

00:07:01.567 --> 00:07:04.100
where he wouldn't be able
to interact with the map.

00:07:04.100 --> 00:07:06.701
but that's better than
get a blank div.

00:07:12.434 --> 00:07:14.100
So...

00:07:14.100 --> 00:07:16.501
the other big reason
why it can be so slow

00:07:16.501 --> 00:07:18.801
to load a map
on a mobile device

00:07:18.801 --> 00:07:22.133
is just the sheer size
of the API.

00:07:22.133 --> 00:07:24.200
If you look at this,
this is the list of classes

00:07:24.200 --> 00:07:27.501
that the public interface
implements.

00:07:27.501 --> 00:07:32.701
And that all adds up to
about 220KB of JavaScript.

00:07:32.701 --> 00:07:33.701
The problem
with this

00:07:33.701 --> 00:07:36.100
is that
we just recently found out

00:07:36.100 --> 00:07:39.901
that the iPhone takes
around 20 milliseconds

00:07:39.901 --> 00:07:42.033
to parse each KB
of JavaScript.

00:07:42.033 --> 00:07:46.033
So if you multiply that,
what you get is 4.4 seconds.

00:07:46.033 --> 00:07:48.267
That's the amount of time
that the browser will wait

00:07:48.267 --> 00:07:52.534
for the Jesup engine to digest
all this JavaScript code.

00:07:52.534 --> 00:07:53.801
And during this time,
the browser

00:07:53.801 --> 00:07:55.534
is completely
unresponsive.

00:07:55.534 --> 00:07:59.934
So again, it's a really
unacceptable user experience

00:07:59.934 --> 00:08:02.067
in our opinion.

00:08:02.067 --> 00:08:04.100
So to try to alleviate
this problem,

00:08:04.100 --> 00:08:07.534
what we are doing
is offloading some of the code

00:08:07.534 --> 00:08:09.834
that currently sits
in main.js

00:08:09.834 --> 00:08:13.467
into js modules.

00:08:13.467 --> 00:08:15.567
These modules
can be downloaded dynamically

00:08:15.567 --> 00:08:17.300
after the tiles
have arrived,

00:08:17.300 --> 00:08:19.167
so they don't
hog the CPU

00:08:19.167 --> 00:08:21.601
during the
start-up sequence.

00:08:23.868 --> 00:08:27.434
So far, we've been able
to modularize around 20%

00:08:27.434 --> 00:08:29.667
of main.js,

00:08:29.667 --> 00:08:33.200
but unfortunately,
there's a major obstacle

00:08:33.200 --> 00:08:34.634
to this work.

00:08:34.634 --> 00:08:38.200
which is the fact that the API
was designed a few years ago

00:08:38.200 --> 00:08:40.667
around a synchronous
programming model

00:08:40.667 --> 00:08:44.868
that doesn't play really well
with dynamic modules.

00:08:44.868 --> 00:08:47.801
And the fact that we cannot,
for obvious reasons,

00:08:47.801 --> 00:08:50.901
change the public API,

00:08:50.901 --> 00:08:56.200
makes this a major, uh,
show-stopper for us,

00:08:56.200 --> 00:08:58.033
as far as
motorization goes.

00:08:58.033 --> 00:09:00.033
So after a lot
of discussion

00:09:00.033 --> 00:09:01.601
back in Sydney,

00:09:01.601 --> 00:09:04.567
the team decided
to bite the bullet

00:09:04.567 --> 00:09:07.801
and start working on
the next generation

00:09:07.801 --> 00:09:13.801
of the API,
which we call Maps API v3.

00:09:13.801 --> 00:09:15.734
The Maps API v3
is being released today.

00:09:15.734 --> 00:09:18.801
There's a blog post up.

00:09:18.801 --> 00:09:20.300
The [indistinct]
is also up.

00:09:20.300 --> 00:09:23.133
You guys can check it out--
see what you think

00:09:23.133 --> 00:09:24.234
about the API,

00:09:24.234 --> 00:09:26.901
give us feedback,
maybe try the demos,

00:09:26.901 --> 00:09:30.467
even try to come up
your own mashups.

00:09:30.467 --> 00:09:33.100
And I'll just finish
my presentation here

00:09:33.100 --> 00:09:35.634
with, you know,
a few bullet points

00:09:35.634 --> 00:09:38.467
of why we think that
v3 is so special.

00:09:38.467 --> 00:09:40.234
The first thing is, uh,

00:09:40.234 --> 00:09:45.367
v3 is built from the ground up
with latency in mind.

00:09:45.367 --> 00:09:46.968
So we are going for
a very aggressive

00:09:46.968 --> 00:09:48.467
JavaScript
modularization,

00:09:48.467 --> 00:09:53.334
and that fact that we don't have
a well-established API,

00:09:53.334 --> 00:09:57.033
a legacy API, if you like,
to hold us back

00:09:57.033 --> 00:09:59.033
is a real blessing.

00:10:00.834 --> 00:10:03.567
We also baked
some latency-specific features

00:10:03.567 --> 00:10:04.801
into the API.

00:10:04.801 --> 00:10:07.634
So, for instance,
the Static Map optimization

00:10:07.634 --> 00:10:08.634
I just told
you guys about

00:10:08.634 --> 00:10:10.133
is actually built
into the API,

00:10:10.133 --> 00:10:11.801
so it's really easy
for developers

00:10:11.801 --> 00:10:14.601
to deploy that
into their websites.

00:10:14.601 --> 00:10:18.934
And, last but not least,
we really, really committed to

00:10:18.934 --> 00:10:21.501
the iPhone
and Android platforms,

00:10:21.501 --> 00:10:24.167
and we hope
we can provide

00:10:24.167 --> 00:10:29.033
the best
user experience possible.

00:10:29.033 --> 00:10:32.267
And Susannah,
who is with us today,

00:10:32.267 --> 00:10:34.801
will be giving
a presentation tomorrow,

00:10:34.801 --> 00:10:36.701
where she'll go
into much more detail

00:10:36.701 --> 00:10:40.367
about v3
and how to use it.

00:10:40.367 --> 00:10:43.200
So I really recommend
you guys attend.

00:10:44.868 --> 00:10:46.734
Pamela: All right,
thank you, Marcelo.

00:10:46.734 --> 00:10:49.434
[applause]

00:10:51.801 --> 00:10:53.968
Pamela: So now with that
nifty new android you got,

00:10:53.968 --> 00:10:57.067
you can make maps
that work really well on it.

00:10:57.067 --> 00:10:58.300
You see.

00:10:58.300 --> 00:10:59.801
So, I know we didn't
give you an android,

00:10:59.801 --> 00:11:02.400
but we gave you a tool
to harness on the android,

00:11:02.400 --> 00:11:05.334
which is
just as good, really.

00:11:05.334 --> 00:11:07.033
So that
is our new API,

00:11:07.033 --> 00:11:09.734
and that's going to solve
some of the latency issues

00:11:09.734 --> 00:11:12.367
with loading in
JavaScript in lots of resources.

00:11:12.367 --> 00:11:14.167
But there are still
other performance issues,

00:11:14.167 --> 00:11:18.100
both for that API and
for the current API generally.

00:11:18.100 --> 00:11:19.501
So one of these
is the issue

00:11:19.501 --> 00:11:22.367
of trying to display
many markers on the map.

00:11:22.367 --> 00:11:24.534
Now, this is a very common
question we get in the group,

00:11:24.534 --> 00:11:27.567
is, "Hey, I tried to put ten
thousand markers on the map,

00:11:27.567 --> 00:11:30.267
and then
my browser got really slow."

00:11:30.267 --> 00:11:31.601
Well...

00:11:31.601 --> 00:11:32.734
what can I tell you?

00:11:32.734 --> 00:11:36.267
You tried to put
10,000 markers on the map.

00:11:36.267 --> 00:11:37.701
So the thing is,
that remember that

00:11:37.701 --> 00:11:39.100
the map's
API JavaScript

00:11:39.100 --> 00:11:41.734
was originally created from
the Google Maps JavaScript,

00:11:41.734 --> 00:11:43.934
which meant that everything--
all the classes we had

00:11:43.934 --> 00:11:45.400
were classes
we originally designed

00:11:45.400 --> 00:11:47.434
for the use case
we had in mind.

00:11:47.434 --> 00:11:48.634
And the use case
on Google Maps

00:11:48.634 --> 00:11:49.667
is you do a search,

00:11:49.667 --> 00:11:51.934
and you get back
ten labeled markers,

00:11:51.934 --> 00:11:53.033
and that's it.

00:11:53.033 --> 00:11:54.701
Google Maps
almost never--well,

00:11:54.701 --> 00:11:56.067
sometimes they do now,

00:11:56.067 --> 00:11:58.267
but generally never shows
more than ten markers at a time.

00:11:58.267 --> 00:12:00.100
So to design
the GMarker class,

00:12:00.100 --> 00:12:01.334
with this in mind.

00:12:01.334 --> 00:12:02.567
They wanted
a lot of features.

00:12:02.567 --> 00:12:04.834
They wanted printability;
they wanted dragability.

00:12:04.834 --> 00:12:06.767
They wanted foregrounds,
shadows.

00:12:06.767 --> 00:12:09.267
They wanted hotspots
that would work

00:12:09.267 --> 00:12:10.868
in every single browser,

00:12:10.868 --> 00:12:13.234
including IE6.

00:12:13.234 --> 00:12:14.901
All this, which means
that GMarker

00:12:14.901 --> 00:12:17.801
is a really
full-featured class,

00:12:17.801 --> 00:12:19.934
which means that
it actually contains

00:12:19.934 --> 00:12:22.133
a lot of DOM nodes
in order to create it,

00:12:22.133 --> 00:12:23.734
and make it work
correctly.

00:12:23.734 --> 00:12:26.534
So that means, if you try
and put 10,000 markers on a map,

00:12:26.534 --> 00:12:27.734
what you're actually
putting on a map

00:12:27.734 --> 00:12:29.801
is something like
50,000 DOM nodes.

00:12:29.801 --> 00:12:31.234
And the thing is,

00:12:31.234 --> 00:12:33.267
if you try and put 50,000
DOM nodes in the browser,

00:12:33.267 --> 00:12:35.767
the browser gets
really, really sad.

00:12:35.767 --> 00:12:39.000
So we don't want to make
it sad so it cries.

00:12:39.000 --> 00:12:40.701
So what you can do
is that,

00:12:40.701 --> 00:12:43.000
in the API we have
a GOverlay interface,

00:12:43.000 --> 00:12:45.033
and you can extend
this overface

00:12:45.033 --> 00:12:47.234
to create
your own custom overlay.

00:12:47.234 --> 00:12:49.200
So I'll just show you
an example of one that I made,

00:12:49.200 --> 00:12:50.701
so you--all you have to do
is make a marker

00:12:50.701 --> 00:12:53.400
that just doesn't have
as many features

00:12:53.400 --> 00:12:54.434
as our marker has,

00:12:54.434 --> 00:12:56.334
and is optimized for
what you want

00:12:56.334 --> 00:12:57.801
your markers
to accomplish, right?

00:12:57.801 --> 00:13:01.334
If you want your markers
to have thousands of them,

00:13:01.334 --> 00:13:03.501
and, uh, be clickable,

00:13:03.501 --> 00:13:06.200
you can do that with not much
lines of code at all.

00:13:06.200 --> 00:13:08.501
So we can see
a demonstration here.

00:13:08.501 --> 00:13:10.601
I'll do GMarker.

00:13:12.167 --> 00:13:14.200
It's gonna be
a bit slow.

00:13:14.200 --> 00:13:15.801
And we're adding
a thousand--

00:13:15.801 --> 00:13:17.734
oh, that's gonna be
really bad.

00:13:17.734 --> 00:13:20.701
You can see
the shadows turned up first,

00:13:20.701 --> 00:13:22.801
and then we have
the markers.

00:13:22.801 --> 00:13:24.167
So that kind of
took a while,

00:13:24.167 --> 00:13:28.400
and then--well, panning
isn't really, like, that fun.

00:13:28.400 --> 00:13:30.434
So now, I'll do...

00:13:32.968 --> 00:13:34.033
a thousand Marker Light.

00:13:34.033 --> 00:13:36.801
So you see
that was a lot faster,

00:13:38.234 --> 00:13:40.067
and the panning
is smoother too.

00:13:40.067 --> 00:13:42.200
And even then, this isn't
an extreme optimization.

00:13:42.200 --> 00:13:43.934
All I've done here
is create an overlay

00:13:43.934 --> 00:13:46.534
that has one div
with an image DIV inside,

00:13:46.534 --> 00:13:49.434
so I've reduced
from 5 DOM nodes to 2 DOM nodes.

00:13:49.434 --> 00:13:51.467
So this is a performance
enhancement already,

00:13:51.467 --> 00:13:55.067
but you can go
even more extreme than that,

00:13:55.067 --> 00:13:57.234
and I'm gonna have
Sasha from Redfin

00:13:57.234 --> 00:14:01.067
talk about
his extreme solution.

00:14:01.067 --> 00:14:02.367
Sasha: I don't know
how extreme it is,

00:14:02.367 --> 00:14:04.634
but, uh, so as Pamela said,
my name is Sasha.

00:14:04.634 --> 00:14:05.767
I work for Redfin.

00:14:05.767 --> 00:14:08.667
We're an online
web real-estate company.

00:14:08.667 --> 00:14:10.234
And, from the beginning,
we took the map

00:14:10.234 --> 00:14:11.968
as the center
of our user interface.

00:14:11.968 --> 00:14:14.300
It's--you can do, sort of,
polygon-based search,

00:14:14.300 --> 00:14:15.601
you can search
for neighborhoods,

00:14:15.601 --> 00:14:18.267
and we show a lot of houses
on the map by default.

00:14:18.267 --> 00:14:19.701
We show up to 500
at a time,

00:14:19.701 --> 00:14:22.267
and it's been a problem for us
for a long time.

00:14:22.267 --> 00:14:24.434
So, we actually--
we actually took Marker Light,

00:14:24.434 --> 00:14:27.334
and we've added
a bunch of stuff to it.

00:14:27.334 --> 00:14:29.334
And I'm just gonna show you
how it works on our site,

00:14:29.334 --> 00:14:31.267
and then take you through

00:14:31.267 --> 00:14:33.000
a very simplified
version of the code

00:14:33.000 --> 00:14:36.434
just to--so you get an idea
of what the code looks like.

00:14:36.434 --> 00:14:38.801
All right.

00:14:38.801 --> 00:14:42.267
It's in Firefox, right?

00:14:42.267 --> 00:14:43.467
So here we are
at Redfin--

00:14:43.467 --> 00:14:44.834
Let's give ourselves
a little bit more space.

00:14:44.834 --> 00:14:45.934
We've got some houses
on the map;

00:14:45.934 --> 00:14:47.100
we're looking at
Potrero Hill.

00:14:47.100 --> 00:14:48.567
Let's say, though--
we, you know,

00:14:48.567 --> 00:14:50.267
we're interested in, what,
in the bargains,

00:14:50.267 --> 00:14:51.400
so let's look at, uh,

00:14:51.400 --> 00:14:55.868
San Francisco,
let's say, under 550K.

00:14:55.868 --> 00:14:58.734
That's affordable,
right?

00:14:58.734 --> 00:15:00.701
All right,
so it just added

00:15:00.701 --> 00:15:03.901
477 things
to the map right there.

00:15:03.901 --> 00:15:06.467
And you see it happened
pretty darn fast.

00:15:06.467 --> 00:15:08.133
This is actually
waiting for the network.

00:15:08.133 --> 00:15:10.601
And...that's adding.

00:15:10.601 --> 00:15:12.701
And so we're adding--

00:15:12.701 --> 00:15:15.300
so you saw the demo that
Pamela just did

00:15:15.300 --> 00:15:17.767
of adding a thousand
normal GMarkers.

00:15:17.767 --> 00:15:19.367
Obviously,
it happened a lot faster here.

00:15:19.367 --> 00:15:21.434
So how do we do that?

00:15:23.667 --> 00:15:27.033
So we did, basically,
what Pamela just described:

00:15:27.033 --> 00:15:29.234
subclass GOverlay.

00:15:29.234 --> 00:15:32.033
We called it, actually--
We called it SuperMarker,

00:15:32.033 --> 00:15:34.000
which, 'cause,
I don't know,

00:15:34.000 --> 00:15:35.067
'cause we wanted to do
one better than

00:15:35.067 --> 00:15:37.801
Marker Light, I guess.
[laughs]

00:15:37.801 --> 00:15:41.701
So what you do is
you subclass GOverlay,

00:15:41.701 --> 00:15:44.067
and this is just
really simple beginning code

00:15:44.067 --> 00:15:46.968
to say, "Okay, we've got a layer
and a DOM node."

00:15:46.968 --> 00:15:48.067
We're holding
onto a DOM node.

00:15:48.067 --> 00:15:49.934
The basic way
this strategy works

00:15:49.934 --> 00:15:52.734
is, as far as
Google Maps is concerned,

00:15:52.734 --> 00:15:55.467
SuperMarker is
just one marker.

00:15:55.467 --> 00:15:58.834
The thing--the GOverlay subclass
is just one marker on the map,

00:15:58.834 --> 00:16:02.701
but underneath it we're gonna
draw stuff inside SuperMarker.

00:16:02.701 --> 00:16:04.534
So we're gonna--we're basically
gonna keep track of

00:16:04.534 --> 00:16:08.367
all of the things
we want to put on the map--

00:16:08.367 --> 00:16:10.267
all the houses
we want to put on the map

00:16:10.267 --> 00:16:13.100
and tell SuperMarker about them
sort of secretly.

00:16:13.100 --> 00:16:15.734
So you have to implement
a method called initialize,

00:16:15.734 --> 00:16:17.734
which gives you the map,

00:16:17.734 --> 00:16:20.100
uh, the G Map
you're a part of.

00:16:20.100 --> 00:16:21.267
And all it's doing
right here

00:16:21.267 --> 00:16:22.801
is just creating
a DIV element

00:16:22.801 --> 00:16:26.000
and adding it to
a particular pane in the map.

00:16:26.000 --> 00:16:27.734
So this is the DIV element,
the DIV node--

00:16:27.734 --> 00:16:29.534
it's gonna--the DOM node
it's gonna hold on to

00:16:29.534 --> 00:16:32.901
to do
its own drawing.

00:16:32.901 --> 00:16:35.801
Now you--you implement
a draw method.

00:16:35.801 --> 00:16:36.901
And there are
a couple interesting things

00:16:36.901 --> 00:16:39.467
to look at
in this one, in this thing.

00:16:39.467 --> 00:16:42.167
And most of the interesting
performance things here

00:16:42.167 --> 00:16:44.267
don't really have to do
much with the map.

00:16:44.267 --> 00:16:45.367
A lot of you
probably know some of this,

00:16:45.367 --> 00:16:48.267
but, as Pamela said,

00:16:48.267 --> 00:16:52.601
adding 5,000 DOM nodes
makes things very slow.

00:16:52.601 --> 00:16:55.000
But it's also so--you wanna
reduce the number of DOM nodes,

00:16:55.000 --> 00:16:58.534
and we're only doing
one DOM node per marker, here.

00:16:58.534 --> 00:16:59.868
But other things
that help are

00:16:59.868 --> 00:17:02.501
that you don't do--
use the DOM APIs,

00:17:02.501 --> 00:17:04.367
that you make
a big string,

00:17:04.367 --> 00:17:06.367
and slam it all in
within your HTML--

00:17:06.367 --> 00:17:07.934
makes it much faster
to add things.

00:17:07.934 --> 00:17:09.868
You'll also notice that,

00:17:09.868 --> 00:17:12.133
instead of doing, you know,
plus equals on the string,

00:17:12.133 --> 00:17:14.601
it creates an array and
joins the array at the bottom--

00:17:14.601 --> 00:17:16.934
also much faster.

00:17:16.934 --> 00:17:18.968
And the third thing
to notice

00:17:18.968 --> 00:17:21.100
is that
it actually is creating--

00:17:21.100 --> 00:17:23.033
we're--in this--
in our version

00:17:23.033 --> 00:17:25.033
we only create one DOM node
per marker,

00:17:25.033 --> 00:17:27.701
and then we use
what's called CSS Sprites

00:17:27.701 --> 00:17:29.367
in order to put
the image on it.

00:17:29.367 --> 00:17:30.467
So rather than
doing a DIV

00:17:30.467 --> 00:17:31.834
with an image
underneath it,

00:17:31.834 --> 00:17:36.968
we use--we have one
gigantic, uh, image

00:17:36.968 --> 00:17:38.634
that has a bunch
of different kinds of icons

00:17:38.634 --> 00:17:40.033
because we have about,

00:17:40.033 --> 00:17:42.133
I don't know, maybe
a hundred different icons

00:17:42.133 --> 00:17:44.200
depending on what kind
of house it is,

00:17:44.200 --> 00:17:45.467
what type of house,

00:17:45.467 --> 00:17:47.200
whether it's
a favorite of yours, et cetera.

00:17:47.200 --> 00:17:49.501
We put them all together
into one giant image

00:17:49.501 --> 00:17:51.634
that's just one download
to the browser,

00:17:51.634 --> 00:17:54.801
and then we use CSS--
the CSS background image--

00:17:54.801 --> 00:17:57.534
to select out
little pieces of that image.

00:17:57.534 --> 00:17:59.400
So it's just
a DIV with a background.

00:17:59.400 --> 00:18:02.067
The downside of this is...
won't print.

00:18:02.067 --> 00:18:04.667
As Pamela said,
markers are very full-featured.

00:18:04.667 --> 00:18:05.801
They have
all these things.

00:18:05.801 --> 00:18:07.501
They have shadows,
they have printability.

00:18:07.501 --> 00:18:08.567
You're not
gonna get printing,

00:18:08.567 --> 00:18:10.934
but it's gonna be
a lot faster.

00:18:10.934 --> 00:18:13.334
So that's
the drawing right there.

00:18:13.334 --> 00:18:15.367
And then finally,

00:18:15.367 --> 00:18:17.367
once you've written
this GOverlay,

00:18:17.367 --> 00:18:19.300
all you need to do is just,
basically, add it to the map,

00:18:19.300 --> 00:18:21.734
and underneath
the covers, you tell it,

00:18:21.734 --> 00:18:25.767
"Hey, here are the ten things
you need to draw."

00:18:25.767 --> 00:18:27.167
And it makes
the DOM nodes for you.

00:18:27.167 --> 00:18:30.601
And that's it.

00:18:30.601 --> 00:18:33.567
[claps]

00:18:35.601 --> 00:18:38.033
Pamela: So that was all
using the JavaScript API,

00:18:38.033 --> 00:18:39.968
but, actually,
the Flash API,

00:18:39.968 --> 00:18:41.801
though it does tend to be
a lot faster at stuff,

00:18:41.801 --> 00:18:43.501
can still run into the issue

00:18:43.501 --> 00:18:46.701
of having
too many things in the DOM.

00:18:46.701 --> 00:18:48.234
So people
in the Flash API community

00:18:48.234 --> 00:18:50.601
have implemented
really similar solutions

00:18:50.601 --> 00:18:51.634
to SuperMarker.

00:18:51.634 --> 00:18:55.167
I think they call it
Super Overlay.

00:18:55.167 --> 00:19:00.033
And where did you
drag it to?

00:19:00.033 --> 00:19:02.434
Too many tabs.

00:19:02.434 --> 00:19:03.567
You guys
are cheating.

00:19:03.567 --> 00:19:05.100
You can see
too much.

00:19:05.100 --> 00:19:07.534
All right, I'll just
open it.

00:19:07.534 --> 00:19:08.868
So here's an example:

00:19:08.868 --> 00:19:12.901
this is a map of victims
of some dude named Madoff.

00:19:14.033 --> 00:19:15.667
You guys probably
know more than me.

00:19:15.667 --> 00:19:16.701
This is
a Flash map,

00:19:16.701 --> 00:19:17.968
and you can see

00:19:17.968 --> 00:19:20.300
it's got thousands
of markers on here,

00:19:20.300 --> 00:19:21.701
and as I
mouse over the markers,

00:19:21.701 --> 00:19:24.567
I still have
interactivity,

00:19:24.567 --> 00:19:26.334
and they even
raise to the front here.

00:19:26.334 --> 00:19:27.400
So that's the thing.

00:19:27.400 --> 00:19:28.701
When you implement
your own overlay,

00:19:28.701 --> 00:19:30.033
you can
implement stuff, like,

00:19:30.033 --> 00:19:31.868
you know,
changing the Z index.

00:19:31.868 --> 00:19:33.534
It's really
entirely up to you

00:19:33.534 --> 00:19:36.100
what you want
to implement there.

00:19:38.467 --> 00:19:39.701
All right.

00:19:39.701 --> 00:19:42.567
Still this hasn't really
solved our problem,

00:19:42.567 --> 00:19:43.901
if we want to put
ten thousand markers.

00:19:43.901 --> 00:19:46.234
This will work pretty good
for five hundred markers,

00:19:46.234 --> 00:19:47.601
for a thousand
markers.

00:19:47.601 --> 00:19:50.601
But ten thousand markers--
that's just too much.

00:19:50.601 --> 00:19:52.434
Even just
ten thousand DOM nodes...

00:19:52.434 --> 00:19:55.200
that's still too many
to put on the map.

00:19:55.200 --> 00:19:58.133
So there's a couple
different solutions here.

00:19:58.133 --> 00:19:59.501
One of them
is clustering,

00:19:59.501 --> 00:20:01.567
which is becoming
more common now.

00:20:01.567 --> 00:20:03.334
Here's a classic example
of clustering,

00:20:03.334 --> 00:20:06.300
which is
AuthorMapper.

00:20:06.300 --> 00:20:07.501
You can see it here,

00:20:07.501 --> 00:20:10.300
and they have stuff, like,
individual markers

00:20:10.300 --> 00:20:12.434
to signify, okay,
there's only one author, here,

00:20:12.434 --> 00:20:13.734
and then multiple markers
to say,

00:20:13.734 --> 00:20:15.167
all right, this is
a cluster.

00:20:15.167 --> 00:20:16.534
They also use
the coloring

00:20:16.534 --> 00:20:18.033
to indicate
the size of the cluster.

00:20:18.033 --> 00:20:20.400
So you see, okay, red means that
there are more articles there,

00:20:20.400 --> 00:20:21.801
and yellow means less.

00:20:21.801 --> 00:20:25.434
And these are standard features
of clustering sites.

00:20:25.434 --> 00:20:28.334
Here's another example,
which is [indistinct].

00:20:28.334 --> 00:20:30.400
And, you see,
they also use numbers

00:20:30.400 --> 00:20:32.100
on the cluster markers,

00:20:32.100 --> 00:20:33.701
and when you mouse over,
you get a little thing

00:20:33.701 --> 00:20:35.601
that says, "Oh, this is how many
things are here."

00:20:35.601 --> 00:20:36.634
And now you can zoom in,

00:20:36.634 --> 00:20:38.100
and then the clusters
would expand out

00:20:38.100 --> 00:20:41.767
to either more clusters, or
maybe some individual markers.

00:20:41.767 --> 00:20:43.267
And you can see
some of them here.

00:20:43.267 --> 00:20:46.033
So this one is actually--
the way they implement this

00:20:46.033 --> 00:20:49.100
is that--I think it's every
night or every week or so--

00:20:49.100 --> 00:20:51.234
they crunch through the data
on their database.

00:20:51.234 --> 00:20:53.701
They run it through a
K-means Clustering Algorithm,

00:20:53.701 --> 00:20:55.501
and then they save out
the cluster information

00:20:55.501 --> 00:20:56.667
to their database.

00:20:56.667 --> 00:20:58.200
So it is
a fair amount of effort

00:20:58.200 --> 00:21:03.701
for them to actually implement
this clustering algorithm.

00:21:03.701 --> 00:21:06.601
So what--I'm really happy
that now, actually--

00:21:06.601 --> 00:21:09.067
a few month ago
we announced MarkerCluster,

00:21:09.067 --> 00:21:11.400
an addition in
the Open Source library,

00:21:11.400 --> 00:21:13.434
and what MarkerCluster is,
is that it's actually

00:21:13.434 --> 00:21:15.634
a JavaScript-only
cluster

00:21:15.634 --> 00:21:17.667
that will do
all the clustering for you.

00:21:17.667 --> 00:21:19.868
And all you have to do
is pass in...

00:21:19.868 --> 00:21:22.968
pass in
the data that you want.

00:21:22.968 --> 00:21:24.901
And it's
a very naive cluster,

00:21:24.901 --> 00:21:26.000
okay, it just does--

00:21:26.000 --> 00:21:27.834
it, basically, uh,
breaks it up into

00:21:27.834 --> 00:21:29.434
a pixel grid,

00:21:29.434 --> 00:21:32.067
and you can kind of specify
the size that you want.

00:21:32.067 --> 00:21:34.000
And then it will figure out
the best clusters.

00:21:34.000 --> 00:21:35.701
But they thing is, like,
K--

00:21:35.701 --> 00:21:38.434
you don't have to write
a K-means Clustering Algorithm.

00:21:38.434 --> 00:21:40.434
It'll do it
purely in JavaScript,

00:21:40.434 --> 00:21:41.534
so you don't
have to store

00:21:41.534 --> 00:21:43.601
a database of
your marker clusters.

00:21:43.601 --> 00:21:45.133
And it's pretty fast
as well.

00:21:45.133 --> 00:21:46.367
There's an example
that does

00:21:46.367 --> 00:21:47.601
a performance test
as well.

00:21:47.601 --> 00:21:48.634
So if you're looking

00:21:48.634 --> 00:21:51.334
for a very fast
clustering solution,

00:21:51.334 --> 00:21:53.968
I highly recommend
checking out MarkerCluster.

00:21:53.968 --> 00:21:56.667
Since it is open source,
you could tweak it yourself

00:21:56.667 --> 00:21:59.400
to, uh, if you need
to change the algorithm a bit.

00:22:01.234 --> 00:22:05.100
So that's kind of
standard clustering.

00:22:05.100 --> 00:22:07.167
You could also do
regional clustering.

00:22:07.167 --> 00:22:09.400
So if it makes sense
to cluster your data

00:22:09.400 --> 00:22:12.834
by some political region
like city, state, country,

00:22:12.834 --> 00:22:15.067
continent, etcetera,

00:22:15.067 --> 00:22:17.167
then you can divide all your
data into those clusters,

00:22:17.167 --> 00:22:19.567
and make cluster markers
for each of those.

00:22:19.567 --> 00:22:20.801
And you see,
in this example,

00:22:20.801 --> 00:22:22.667
when I mouse over
one of the cluster markers,

00:22:22.667 --> 00:22:25.300
I actually see the outlined
polygon for that region.

00:22:25.300 --> 00:22:26.868
So that's
a nice hint to the user,

00:22:26.868 --> 00:22:29.534
like, hey, these are actual
regional clusters.

00:22:29.534 --> 00:22:30.901
And they understand, like,
oh, okay,

00:22:30.901 --> 00:22:32.868
this represents
California.

00:22:32.868 --> 00:22:33.834
Because that's the thing
with clusters--

00:22:33.834 --> 00:22:35.000
is that you want
to be clear

00:22:35.000 --> 00:22:36.300
about what
it's actually representing.

00:22:36.300 --> 00:22:38.968
You can see
that here.

00:22:38.968 --> 00:22:40.801
And, actually,

00:22:40.801 --> 00:22:43.667
travellr is a site
that just launched recently,

00:22:43.667 --> 00:22:46.634
which is kind of like
Yahoo Answers for the map,

00:22:46.634 --> 00:22:50.434
and probably has smarter users
than Yahoo Answers does.

00:22:50.434 --> 00:22:51.601
And you can see,
it's nice.

00:22:51.601 --> 00:22:53.667
They start off
with continents.

00:22:53.667 --> 00:22:57.267
And we can mouse over and see
what they represent.

00:22:57.267 --> 00:22:58.868
They haven't done
border polygons yet,

00:22:58.868 --> 00:23:00.434
but I've asked them to.

00:23:00.434 --> 00:23:02.467
[laughs]
Nicely.

00:23:03.901 --> 00:23:04.934
What I like--
this is a pretty good

00:23:04.934 --> 00:23:06.300
user experience here,

00:23:06.300 --> 00:23:08.400
because I know exactly what
these clusters represent,

00:23:08.400 --> 00:23:10.367
and I can zoom in
to see more information.

00:23:10.367 --> 00:23:13.100
And they implement this
on the server

00:23:13.100 --> 00:23:15.501
using--I think it's
a B plus tree

00:23:15.501 --> 00:23:17.734
or something
like that.

00:23:17.734 --> 00:23:19.667
So those are different types
of clustering you can do,

00:23:19.667 --> 00:23:20.934
and it's kind of
up to you, like,

00:23:20.934 --> 00:23:22.734
how extreme
you want to take it,

00:23:22.734 --> 00:23:24.200
and how much
you want to customize it.

00:23:24.200 --> 00:23:25.567
There's an article
here

00:23:25.567 --> 00:23:28.901
that compares the various
clustering arguns available.

00:23:28.901 --> 00:23:31.133
That's a link to some sample
K-means clustering code

00:23:31.133 --> 00:23:32.801
if you want to
write it yourself on a server.

00:23:32.801 --> 00:23:36.100
And Maptimize
is actually a, um,

00:23:36.100 --> 00:23:38.100
basically, you give them
their data,

00:23:38.100 --> 00:23:40.000
uh, you give them
your data,

00:23:40.000 --> 00:23:41.267
and they'll go
run it through

00:23:41.267 --> 00:23:42.734
their own clustering algorithm
on their server,

00:23:42.734 --> 00:23:44.234
and then they'll just
give you some JavaScript,

00:23:44.234 --> 00:23:45.567
for you to include
on your site,

00:23:45.567 --> 00:23:46.901
and get the clusters
to show up.

00:23:46.901 --> 00:23:49.901
So they're kind of
a hosted clustering solution.

00:23:49.901 --> 00:23:51.200
And you have to pay.

00:23:51.200 --> 00:23:52.334
A bit.

00:23:52.334 --> 00:23:53.901
Not too much.

00:23:53.901 --> 00:23:54.901
So there's clustering,

00:23:54.901 --> 00:23:56.100
and clustering
is what you use

00:23:56.100 --> 00:23:57.534
when you want
to make sure

00:23:57.534 --> 00:23:59.801
that the user can eventually
actually click on the marker.

00:23:59.801 --> 00:24:01.868
Because with clustering, you can
always zoom in far enough,

00:24:01.868 --> 00:24:03.634
and actually have
clickable markers.

00:24:03.634 --> 00:24:04.901
But that's not
always necessary.

00:24:04.901 --> 00:24:07.000
Sometimes when you have
ten thousand markers,

00:24:07.000 --> 00:24:08.734
you don't really care
about people clicking.

00:24:08.734 --> 00:24:10.801
You just care about them
visualizing the information

00:24:10.801 --> 00:24:12.300
that you have.

00:24:12.300 --> 00:24:15.167
So there's a couple ways of
doing View-only visualizations.

00:24:15.167 --> 00:24:19.467
So this is, um,
FundRace from Huffington Post.

00:24:20.667 --> 00:24:21.801
And this is
really nice here.

00:24:21.801 --> 00:24:22.968
What they've done
is that

00:24:22.968 --> 00:24:25.133
they geocoded
the campaign contributions

00:24:25.133 --> 00:24:27.367
from everyone
in America,

00:24:27.367 --> 00:24:29.234
and then plotted them
on the map.

00:24:29.234 --> 00:24:30.334
And then
what they did was--

00:24:30.334 --> 00:24:32.234
they actually
created tiles,

00:24:32.234 --> 00:24:33.234
and then they put them
underneath

00:24:33.234 --> 00:24:34.434
our hybrid
upper layer.

00:24:34.434 --> 00:24:35.634
And so these tiles--

00:24:35.634 --> 00:24:37.434
it's basically like
dot density mapping.

00:24:37.434 --> 00:24:38.501
They've just done
a pixel

00:24:38.501 --> 00:24:41.267
for every contribution
that they have.

00:24:41.267 --> 00:24:44.901
And it's pretty cool because
you can go and zoom in,

00:24:44.901 --> 00:24:47.067
and then see,
in your area,

00:24:47.067 --> 00:24:50.267
exactly how red it is,
and how blue it is,

00:24:50.267 --> 00:24:52.167
and whether you should be
hating on your neighbors,

00:24:52.167 --> 00:24:55.200
and stuff like that.

00:24:55.200 --> 00:24:57.067
And it's good because
it doesn't--

00:24:57.067 --> 00:24:59.234
you know, you can click on it,
and you can zoom in,

00:24:59.234 --> 00:25:01.000
and you can see-you can get
the general idea

00:25:01.000 --> 00:25:02.934
of how red or blue
an area is,

00:25:02.934 --> 00:25:04.501
but as a user
I don't really expect

00:25:04.501 --> 00:25:05.901
to be able
to click on a pixel

00:25:05.901 --> 00:25:08.501
and find out exactly who that
pixel represents...right?

00:25:08.501 --> 00:25:11.133
I can look and see some samples
in the sidebar here,

00:25:11.133 --> 00:25:15.100
and see who--what kind of people
these people are.

00:25:15.100 --> 00:25:17.200
But they don't have to worry
about people mining down

00:25:17.200 --> 00:25:19.300
to that--
individual pieces of data.

00:25:19.300 --> 00:25:21.467
So this is
something you could think about,

00:25:21.467 --> 00:25:23.033
and this does involve
actually rendering out

00:25:23.033 --> 00:25:24.133
tiles on your server,

00:25:24.133 --> 00:25:26.334
so they have some
image manipulation,

00:25:26.334 --> 00:25:28.234
where they're just
writing pixels into the tiles,

00:25:28.234 --> 00:25:30.400
and then
putting them out.

00:25:32.534 --> 00:25:33.968
Something similar
you can do

00:25:33.968 --> 00:25:36.601
is a HeatMap,

00:25:36.601 --> 00:25:39.467
and there actually is a
HeatMap public API you can use.

00:25:39.467 --> 00:25:41.601
And there's also
some open source projects--

00:25:41.601 --> 00:25:43.033
there's on
called G Heat,

00:25:43.033 --> 00:25:44.434
to render out
these tiles.

00:25:44.434 --> 00:25:46.367
Because a HeatMap,
once again--

00:25:46.367 --> 00:25:47.801
you're probably gonna
have to render tiles.

00:25:47.801 --> 00:25:48.968
If you use Flash,

00:25:48.968 --> 00:25:50.501
you could actually do HeatMaps
purely in Flash.

00:25:50.501 --> 00:25:51.667
You don't need to render
your own tiles,

00:25:51.667 --> 00:25:53.634
so we do have a demo of that
in the gallery.

00:25:53.634 --> 00:25:55.501
This one is
a tile HeatMap,

00:25:55.501 --> 00:25:58.501
and it's nice--this is
a search for pizza.

00:25:58.501 --> 00:26:00.167
So this is just
to give me a general idea.

00:26:00.167 --> 00:26:02.834
If I went to Boston,
and I desperately needed pizza,

00:26:02.834 --> 00:26:05.033
what general area
would I go to?

00:26:05.033 --> 00:26:06.267
Right?

00:26:06.267 --> 00:26:07.934
But, um, the thing
to be careful about HeatMaps

00:26:07.934 --> 00:26:10.133
is that the user understands
what they're looking at here,

00:26:10.133 --> 00:26:13.300
and that it's
actually useful data.

00:26:13.300 --> 00:26:14.834
You know, it could just be that
every heat map

00:26:14.834 --> 00:26:16.200
looks like this
for Boston

00:26:16.200 --> 00:26:18.934
because the most amount of
restaurants for Boston is there

00:26:18.934 --> 00:26:20.267
in the city, right?

00:26:20.267 --> 00:26:22.667
So you may look at
comparing what data you have

00:26:22.667 --> 00:26:23.801
to population data

00:26:23.801 --> 00:26:28.234
to make it
more clear for the user.

00:26:28.234 --> 00:26:30.801
all right, and
here's a solution

00:26:30.801 --> 00:26:32.934
which is kind of a mix
of all the other ones,

00:26:32.934 --> 00:26:34.834
which is
really, really cool

00:26:34.834 --> 00:26:36.467
and something that
Google Maps is doing now.

00:26:36.467 --> 00:26:37.601
So we were talking
about earlier:

00:26:37.601 --> 00:26:38.667
it used to be,
you do a local search,

00:26:38.667 --> 00:26:39.834
you get back
those ten markers,

00:26:39.834 --> 00:26:41.968
and they represent
the top ten results.

00:26:41.968 --> 00:26:44.234
But sometimes you want
more than that, right?

00:26:44.234 --> 00:26:45.801
You're like, "Okay,
I searched for pizza."

00:26:45.801 --> 00:26:48.100
"I know that there's more than
ten pizza places in New York."

00:26:48.100 --> 00:26:49.467
Right?

00:26:49.467 --> 00:26:51.801
So we wanted to have a way
of indicating that to the user,

00:26:51.801 --> 00:26:53.567
and giving them
a better way of visualizing

00:26:53.567 --> 00:26:55.234
what their search result
really looked like.

00:26:55.234 --> 00:26:56.767
So we introduced
these things

00:26:56.767 --> 00:26:59.234
that we affectionately
call pimples,

00:26:59.234 --> 00:27:01.534
and they look like
little pimples or measles

00:27:01.534 --> 00:27:03.734
on top of
the map.

00:27:03.734 --> 00:27:05.200
And I'll, actually--
I'll just show you

00:27:05.200 --> 00:27:09.167
in the browser.

00:27:09.167 --> 00:27:11.033
Here we go.

00:27:11.033 --> 00:27:13.601
So here I've done
a search for Chinese food.

00:27:13.601 --> 00:27:15.734
And it's cool because
when you look at it,

00:27:15.734 --> 00:27:17.067
you can actually--
you can see--

00:27:17.067 --> 00:27:18.400
you can tell
where Chinatown is.

00:27:18.400 --> 00:27:20.367
Chinatown is where
the G and the I are.

00:27:20.367 --> 00:27:23.634
And that's where the most number
of local search results are.

00:27:23.634 --> 00:27:25.133
And with these pimples,
if I say--

00:27:25.133 --> 00:27:28.234
well, so I
actually live--

00:27:28.234 --> 00:27:29.467
I live right about here.

00:27:29.467 --> 00:27:31.834
So I can go and click
on one of these

00:27:31.834 --> 00:27:34.133
and actually find out
that result.

00:27:34.133 --> 00:27:35.834
Right?

00:27:35.834 --> 00:27:37.133
But the thing is
that these aren't

00:27:37.133 --> 00:27:39.334
actually
little markers.

00:27:39.334 --> 00:27:41.000
What these are
is just a tile

00:27:41.000 --> 00:27:43.067
that's been rendered
and made clickable.

00:27:43.067 --> 00:27:44.367
So the way
we make it clickable

00:27:44.367 --> 00:27:46.534
is that, at the same time as
rendering these tiles,

00:27:46.534 --> 00:27:48.334
we passed down
some JSON.

00:27:48.334 --> 00:27:52.267
And you can look and see
the JSON...

00:27:52.267 --> 00:27:53.934
here.

00:27:53.934 --> 00:27:55.868
So here's some
example JSON--

00:27:55.868 --> 00:27:57.734
that doesn't really
increase it.

00:27:57.734 --> 00:27:59.467
But basically,
the JSON just contains

00:27:59.467 --> 00:28:00.901
information about
the clickable pixel bounds,

00:28:00.901 --> 00:28:01.968
so we say,
all right,

00:28:01.968 --> 00:28:03.367
we're passing down
these tiles,

00:28:03.367 --> 00:28:05.467
and this area's clickable,
this area's clickable,

00:28:05.467 --> 00:28:06.934
this area's clickable.

00:28:06.934 --> 00:28:08.901
So when you do the mouse over
event, you can go and query,

00:28:08.901 --> 00:28:11.234
"Okay, which pixel bounds
am I in right now?"

00:28:11.234 --> 00:28:13.467
"Should I change my cursor
into a pointer?"

00:28:13.467 --> 00:28:14.467
And when somebody
actually clicks,

00:28:14.467 --> 00:28:15.634
we can go and say,

00:28:15.634 --> 00:28:18.100
"All right, what have I actually
clicked on?"

00:28:18.100 --> 00:28:22.033
"Should--what information should
I open up there, right?"

00:28:22.033 --> 00:28:23.300
And you could do
an AJAX call

00:28:23.300 --> 00:28:24.300
to go fetch
that information

00:28:24.300 --> 00:28:27.234
by some ID that
you stored in that JSON.

00:28:27.234 --> 00:28:28.567
So this
is really nice

00:28:28.567 --> 00:28:31.100
because no matter how many
search results we have,

00:28:31.100 --> 00:28:34.667
we're downloading
the same amount of data

00:28:34.667 --> 00:28:37.467
but for the user,
it's a clickable experience.

00:28:37.467 --> 00:28:39.767
So this is how
you can kind of mix

00:28:39.767 --> 00:28:41.667
being able to visualize
lots of information

00:28:41.667 --> 00:28:44.634
with having
scalable performance.

00:28:44.634 --> 00:28:46.367
And we use this
for other things, too.

00:28:46.367 --> 00:28:47.634
We use this for
our photos layer.

00:28:47.634 --> 00:28:49.667
And videos,

00:28:49.667 --> 00:28:52.234
Wikipedia,
web cams.

00:28:52.234 --> 00:28:54.167
So this is
technically--

00:28:54.167 --> 00:28:55.200
if these were done
as markers,

00:28:55.200 --> 00:28:56.634
the map would just
absolutely die,

00:28:56.634 --> 00:28:59.901
but these are just combination
of clickable tile layers on top.

00:28:59.901 --> 00:29:02.467
And we have
a demo of this

00:29:02.467 --> 00:29:07.334
from on of the developers
who's in the audience.

00:29:08.767 --> 00:29:10.601
So this is a slightly different
way of doing it.

00:29:10.601 --> 00:29:13.534
And you can see here,
as I mouse over--

00:29:13.534 --> 00:29:15.834
we don't do
click behavior here--

00:29:15.834 --> 00:29:18.100
but, um--
oh, we do?

00:29:18.100 --> 00:29:21.000
What happens
when I click?

00:29:21.000 --> 00:29:24.300
[laughs]

00:29:28.868 --> 00:29:30.934
Okay, well, I don't have it
in Firebug right now.

00:29:30.934 --> 00:29:34.033
But you can see that
the mouse cursor is changing

00:29:34.033 --> 00:29:35.767
to indicate that these
are in fact clickable,

00:29:35.767 --> 00:29:37.601
and that you get
a very satisfying experience

00:29:37.601 --> 00:29:38.701
when you click.

00:29:38.701 --> 00:29:40.901
And the way--
[laughs]

00:29:40.901 --> 00:29:44.634
The way he's doing this
is really, really cool

00:29:44.634 --> 00:29:46.234
because, uh...

00:29:46.234 --> 00:29:47.901
So in the other example
on Google Maps,

00:29:47.901 --> 00:29:49.267
we passed on the tiles
and then we passed

00:29:49.267 --> 00:29:51.167
on a separate
JSON.

00:29:51.167 --> 00:29:53.234
What he does is
he renders the tiles,

00:29:53.234 --> 00:29:55.100
and the he attaches cookies
to the tiles.

00:29:55.100 --> 00:29:56.300
And when he gets
each tile,

00:29:56.300 --> 00:29:57.534
he just parses out
the cookies,

00:29:57.534 --> 00:29:59.400
and the cookies
contain the information

00:29:59.400 --> 00:30:01.000
about the clickable
pixel bounds.

00:30:01.000 --> 00:30:02.300
So in one single
request,

00:30:02.300 --> 00:30:03.701
he has
all the information needed

00:30:03.701 --> 00:30:06.000
to make clickable tiles.

00:30:06.000 --> 00:30:07.434
So, John, you should
raise your hands

00:30:07.434 --> 00:30:08.834
because a lot of people
have questions.

00:30:08.834 --> 00:30:11.801
Yeah--so I know some of you
asked me earlier about this,

00:30:11.801 --> 00:30:13.901
so you should talk to John
after,

00:30:13.901 --> 00:30:15.400
if you're curious
for more information

00:30:15.400 --> 00:30:20.367
about how
he did this.

00:30:20.367 --> 00:30:23.100
Okay, so that's a problem
with having lots of markers.

00:30:23.100 --> 00:30:26.434
So now let's move on
to polys.

00:30:26.434 --> 00:30:27.701
So the first problem
we have

00:30:27.701 --> 00:30:29.234
is the same problem
we had at GMarker.

00:30:29.234 --> 00:30:30.534
It has a lot
of features.

00:30:30.534 --> 00:30:33.033
GPolygon, GPolyline--
they have lots of features;

00:30:33.033 --> 00:30:35.567
they can be, you know,
edited.

00:30:35.567 --> 00:30:36.801
They're clickable.

00:30:36.801 --> 00:30:38.667
They can, um--

00:30:38.667 --> 00:30:40.100
they can be
geodesic.

00:30:40.100 --> 00:30:41.634
We do
bounds clipping.

00:30:41.634 --> 00:30:44.100
Lots of optimizations that
we've done on GPolygon,

00:30:44.100 --> 00:30:47.234
and all really catered toward
their use on Google Maps, right?

00:30:47.234 --> 00:30:49.167
So it may be that
your use of polygons

00:30:49.167 --> 00:30:50.467
is different from 
our use,

00:30:50.467 --> 00:30:53.434
and you may have to come up with
a different solution.

00:30:53.434 --> 00:30:56.167
So the first answer,
and this is--

00:30:56.167 --> 00:30:57.567
it's a very similar story
to markers--

00:30:57.567 --> 00:30:59.434
is just to do
a lightweight polygon class.

00:30:59.434 --> 00:31:01.567
So the same way
we can extend GOverlay,

00:31:01.567 --> 00:31:03.100
and make
a lightweight marker,

00:31:03.100 --> 00:31:05.334
we can extend GOverlay
and make a lightweight polygon.

00:31:05.334 --> 00:31:07.334
And so this demo
actually comes from

00:31:07.334 --> 00:31:09.801
another developer,
Mike Geary.

00:31:09.801 --> 00:31:12.133
All right, so he just--
he's in the back of the room.

00:31:12.133 --> 00:31:15.234
And, this is called
Polygonzo,

00:31:15.234 --> 00:31:16.467
which is
an awesome name.

00:31:16.467 --> 00:31:19.100
And you can see what
we're using here

00:31:19.100 --> 00:31:21.934
is, uh, this is using
the Canvas Tag.

00:31:21.934 --> 00:31:23.868
And if you guys saw
the keynote earlier,

00:31:23.868 --> 00:31:24.868
I think they talked
about Canvas.

00:31:24.868 --> 00:31:26.434
Canvas is
awesome.

00:31:26.434 --> 00:31:27.968
It's just a way of drawing
graphics in the browser.

00:31:27.968 --> 00:31:29.400
It's part of
HTML 5.

00:31:29.400 --> 00:31:31.434
It is in
most browsers,

00:31:31.434 --> 00:31:35.234
except IE.

00:31:35.234 --> 00:31:37.334
But he manages--

00:31:37.334 --> 00:31:38.968
this thing hacks
on top of VML

00:31:38.968 --> 00:31:40.434
to make really, really fast
VML.

00:31:40.434 --> 00:31:42.467
So, 'cause IE
does have VML as a solution,

00:31:42.467 --> 00:31:44.934
and he kinda just figured out
how to make VML

00:31:44.934 --> 00:31:47.033
be as fast
as possible.

00:31:47.033 --> 00:31:48.934
So it does work
in IE as well.

00:31:48.934 --> 00:31:53.400
So here we're actually
loading in 34,000 points

00:31:53.400 --> 00:31:57.033
and about 3,400
shapes,

00:31:57.033 --> 00:31:59.701
which is
pretty amazing.

00:31:59.701 --> 00:32:01.934
And then--
wait, wait for it.

00:32:01.934 --> 00:32:03.601
Ready?

00:32:03.601 --> 00:32:08.467
Oh, yeah,
that's good.

00:32:08.467 --> 00:32:10.801
We'll just take it in for a bit,
guys, just take it in.

00:32:10.801 --> 00:32:12.634
And I'm sure
you guys are thinking, like,

00:32:12.634 --> 00:32:15.734
"Oh, I needed animated polys
that were rainbow-colored."

00:32:15.734 --> 00:32:17.367
"Yes!"

00:32:17.367 --> 00:32:18.701
But this kinda--

00:32:18.701 --> 00:32:20.033
it's kind of silly,
but it exemplifies

00:32:20.033 --> 00:32:21.567
how--how fast this is.

00:32:21.567 --> 00:32:23.167
And this was developed
while they were working

00:32:23.167 --> 00:32:24.300
on the election maps,

00:32:24.300 --> 00:32:25.901
because they needed
to be able to visualize

00:32:25.901 --> 00:32:28.334
all of the voting districts
on top of maps

00:32:28.334 --> 00:32:32.033
and do it
as fast as possible.

00:32:32.033 --> 00:32:33.567
And they didn't want
to use tiles

00:32:33.567 --> 00:32:35.334
so this is a solution--
they don't need tiles.

00:32:35.334 --> 00:32:36.567
And you can see,
when we mouse over,

00:32:36.567 --> 00:32:38.734
we can actually see, um,

00:32:38.734 --> 00:32:40.567
all the information about the
county we're mouse overing.

00:32:40.567 --> 00:32:41.968
So that's the thing--

00:32:41.968 --> 00:32:44.167
JavaScript is actually pretty
fast at doing calculations

00:32:44.167 --> 00:32:46.434
about what bounds
it's inside of.

00:32:46.434 --> 00:32:47.968
So really fast
at pixel bounds

00:32:47.968 --> 00:32:49.267
and even for doing
polygonal bounds.

00:32:49.267 --> 00:32:52.067
This thing is
figuring out on the spot

00:32:52.067 --> 00:32:53.834
what we're
mousing over.

00:32:53.834 --> 00:32:56.334
So that kind of information--
or that kind of processing--

00:32:56.334 --> 00:32:59.267
can be done
entirely in the client now.

00:32:59.267 --> 00:33:00.767
You know, granted,
maybe if you do

00:33:00.767 --> 00:33:04.667
20,000 places instead of 4,000,
maybe you'll get a bit slower.

00:33:04.667 --> 00:33:06.868
but a lot of people
tend to think

00:33:06.868 --> 00:33:08.167
that this is stuff that you
need, like,

00:33:08.167 --> 00:33:09.734
a spatial server
to do

00:33:09.734 --> 00:33:10.767
and you have to go
send it off

00:33:10.767 --> 00:33:12.167
to the
Oracle Spatial Database--

00:33:12.167 --> 00:33:13.501
that's what I had to do
in university.

00:33:13.501 --> 00:33:15.267
But it's not really
that necessary anymore.

00:33:15.267 --> 00:33:16.934
You just do a nice little
JavaScript function,

00:33:16.934 --> 00:33:19.634
and for the most part
it will work.

00:33:23.567 --> 00:33:24.868
But even so,

00:33:24.868 --> 00:33:27.133
even having
this lightweight poly,

00:33:27.133 --> 00:33:28.267
you still might
have the problem

00:33:28.267 --> 00:33:30.133
where your polygons
just are too thick,

00:33:30.133 --> 00:33:31.267
and have
too many points,

00:33:31.267 --> 00:33:32.434
and this is actually
a pretty common problem.

00:33:32.434 --> 00:33:34.100
Because a lot of times,
when we get data,

00:33:34.100 --> 00:33:36.734
we get it from sources
that don't think about the fact

00:33:36.734 --> 00:33:39.067
that eventually it might be
rendered on a map, right?

00:33:39.067 --> 00:33:40.334
So GIS people,
they go out,

00:33:40.334 --> 00:33:41.567
and they go and, like,

00:33:41.567 --> 00:33:43.734
record this pixel, and then
record this pixel.

00:33:43.734 --> 00:33:45.567
So they come back with
massive amounts of points

00:33:45.567 --> 00:33:48.701
that represent
these regions.

00:33:48.701 --> 00:33:50.601
So you can see that Alaska
is actually, like,

00:33:50.601 --> 00:33:53.200
ten times the amount of points
that America is

00:33:53.200 --> 00:33:55.234
because Alaska just has
this crazy coastline

00:33:55.234 --> 00:33:58.000
that goes like that.

00:33:58.000 --> 00:33:59.968
So what you want to do
is simplify your data

00:33:59.968 --> 00:34:01.400
before you render
on to the maps.

00:34:01.400 --> 00:34:03.400
So you should be simplifying,
probably, on the server.

00:34:03.400 --> 00:34:06.200
And you can use
a couple different programs.

00:34:06.200 --> 00:34:07.467
This is a nice online one

00:34:07.467 --> 00:34:09.267
that will actually show you
interactively, like,

00:34:09.267 --> 00:34:11.334
how it's shaping, and show you
a couple different algorithms

00:34:11.334 --> 00:34:13.834
for simplifying
your data.

00:34:13.834 --> 00:34:15.868
And there there's some,
you know, Python scripts

00:34:15.868 --> 00:34:17.367
and what not that
will do this for you as well.

00:34:17.367 --> 00:34:18.667
So just make sure
you're not

00:34:18.667 --> 00:34:21.834
trying to render
too many points on a map

00:34:21.834 --> 00:34:23.901
because often times,
your users don't need

00:34:23.901 --> 00:34:25.167
all that point
information.

00:34:25.167 --> 00:34:31.067
And, uh, you should certainly
simplify it first.

00:34:31.067 --> 00:34:32.467
All right.

00:34:32.467 --> 00:34:34.734
Now there's situations
where your users

00:34:34.734 --> 00:34:36.868
do want the information
about all those points,

00:34:36.868 --> 00:34:38.300
but they don't want
that information

00:34:38.300 --> 00:34:41.234
until they've zoomed in,
you know, pretty far, right?

00:34:41.234 --> 00:34:43.033
So you can see,
in this example,

00:34:43.033 --> 00:34:47.033
this line is at, you know,
some higher zoom level

00:34:47.033 --> 00:34:49.734
and as we zoom in,
we see more and more points.

00:34:49.734 --> 00:34:52.701
And you can do this
really easily in the API

00:34:52.701 --> 00:34:54.634
using something called
encoded polylines.

00:34:54.634 --> 00:34:56.167
And so,
encoded polylines--

00:34:56.167 --> 00:34:57.968
you basically
take your information, like,

00:34:57.968 --> 00:35:00.767
"Okay, this is my polyline,
and here's all the points."

00:35:00.767 --> 00:35:03.801
"And the points are gonna
display at this zoom level."

00:35:03.801 --> 00:35:04.968
And so we'll figure out--

00:35:04.968 --> 00:35:06.534
you give us
the encoded information,

00:35:06.534 --> 00:35:07.968
and we'll figure out, okay,
we're gonna show this points,

00:35:07.968 --> 00:35:09.634
'cause we're at
this zoom level,

00:35:09.634 --> 00:35:10.834
and we're gonna show this points
'cause we're at this zoom level.

00:35:10.834 --> 00:35:12.267
So that's
a nice optimization

00:35:12.267 --> 00:35:15.300
because it means that, if
the user is at this zoom level,

00:35:15.300 --> 00:35:17.400
you can potentially show
a lot more polylines

00:35:17.400 --> 00:35:19.901
because it's gonna add up
to the same amount of points

00:35:19.901 --> 00:35:25.267
that you'll have just for that
one at the higher zoom level.

00:35:25.267 --> 00:35:27.801
So we have documentation about
how to write encoded polys,

00:35:27.801 --> 00:35:29.434
and there's lots of scripts
that can do it for you,

00:35:29.434 --> 00:35:30.801
and then,
in your database,

00:35:30.801 --> 00:35:32.767
it could be a more succinct way
of storing your encoded--

00:35:32.767 --> 00:35:33.968
your polyline information
as well,

00:35:33.968 --> 00:35:35.367
because you would simply
store it as

00:35:35.367 --> 00:35:37.400
a giant string
of information.

00:35:37.400 --> 00:35:40.100
All right, but
saying all that,

00:35:40.100 --> 00:35:41.200
you're still
gonna have the issue

00:35:41.200 --> 00:35:42.567
where you're gonna go
pimp it out,

00:35:42.567 --> 00:35:44.467
and you're gonna use
Polygonzo,

00:35:44.467 --> 00:35:45.968
and you're gonna use
encoded polylines,

00:35:45.968 --> 00:35:48.801
and then you're gonna test it
in Firefox and Chrome,

00:35:48.801 --> 00:35:50.701
and be like, "Oh, my God,
that was the best site ever."

00:35:50.701 --> 00:35:54.467
And then you're gonna test it
in IE, and you're gonna cry.

00:35:54.467 --> 00:35:57.067
So the problem is that when
it comes to vector graphics,

00:35:57.067 --> 00:35:59.968
the browsers still
haven't agreed.

00:35:59.968 --> 00:36:01.834
So we have this situation where
in the API,

00:36:01.834 --> 00:36:04.734
we actually have
four different techniques

00:36:04.734 --> 00:36:06.400
for rendering polys.

00:36:06.400 --> 00:36:07.801
We have VML
for IE,

00:36:07.801 --> 00:36:10.434
and we have
SVG and Canvas.

00:36:10.434 --> 00:36:11.834
I don't remember which one
we do where

00:36:11.834 --> 00:36:13.467
because we change it
every week,

00:36:13.467 --> 00:36:15.801
and then failing all that we
actually have a graphic server

00:36:15.801 --> 00:36:17.501
to render tiles
out for graphics,

00:36:17.501 --> 00:36:20.267
but we don't usually
have to use that anymore.

00:36:20.267 --> 00:36:22.200
So, it's
a sad situation,

00:36:22.200 --> 00:36:24.100
and anyone doing
anything graphical on the web

00:36:24.100 --> 00:36:25.934
knows that
it's a sad situation,

00:36:25.934 --> 00:36:28.267
and we're also desperately
bribing IE

00:36:28.267 --> 00:36:29.434
and trying
to get them drunk,

00:36:29.434 --> 00:36:32.400
and saying,
"Hey, Canvas, wahoo!"

00:36:32.400 --> 00:36:33.667
But it hasn't
happened yet.

00:36:33.667 --> 00:36:36.567
So this is the situation
with vector graphics on the web.

00:36:36.567 --> 00:36:39.534
So there's a couple different
solutions for this.

00:36:39.534 --> 00:36:43.000
One of them is to give up
on the web and use Flash,

00:36:43.000 --> 00:36:45.200
which I'm a huge fan of;
it's much easier.

00:36:45.200 --> 00:36:47.667
[laughs]

00:36:47.667 --> 00:36:49.901
So let me show
Flash examples.

00:36:49.901 --> 00:36:51.300
The great thing
about Flash is that,

00:36:51.300 --> 00:36:54.701
number one, it works
pretty much the same everywhere,

00:36:54.701 --> 00:36:56.801
except maybe
on mobile phones.

00:36:56.801 --> 00:36:59.400
And the other thing
is that, um,

00:36:59.400 --> 00:37:02.067
it was kind of designed
for this kind of thing:

00:37:02.067 --> 00:37:03.868
doing graphics
and vector graphics.

00:37:03.868 --> 00:37:06.067
So it works
really well.

00:37:06.067 --> 00:37:07.934
So here's a demo
using Flash,

00:37:07.934 --> 00:37:09.467
and this is
visualizing

00:37:09.467 --> 00:37:12.934
how San Francisco voted
on Proposition 8,

00:37:12.934 --> 00:37:17.434
which is kind of
an interesting vote to see.

00:37:17.434 --> 00:37:21.534
And we can go and change this
by one or two choices.

00:37:23.400 --> 00:37:24.734
There's a bubble, um,
oh, percent.

00:37:26.367 --> 00:37:28.734
So it's really nice;
it's really fast.

00:37:28.734 --> 00:37:32.200
And you can put a fair amount
of polys on the map,

00:37:32.200 --> 00:37:35.100
and there's actually a blog post
which I linked to here

00:37:35.100 --> 00:37:37.567
that shows
all the countries in the world

00:37:37.567 --> 00:37:39.567
and does a comparison using
the JavaScript API,

00:37:39.567 --> 00:37:41.133
and using
the Flash API.

00:37:41.133 --> 00:37:42.501
And that's interesting
because you can go

00:37:42.501 --> 00:37:44.067
and bring it up
in the different browsers,

00:37:44.067 --> 00:37:46.267
and you'll see--in Chrome,
actually, it's pretty similar

00:37:46.267 --> 00:37:48.901
because Canvas and Flash
have pretty good performance.

00:37:48.901 --> 00:37:52.534
But once you open it up in
a slower browser like IE 6,

00:37:52.534 --> 00:37:54.434
then it all goes to hell.

00:37:54.434 --> 00:37:58.133
And Flash doesn't have
that issue.

00:37:58.133 --> 00:38:00.234
But another solution
you can use for JavaScript,

00:38:00.234 --> 00:38:03.501
if you're still holding on that
the web is gonna get better,

00:38:03.501 --> 00:38:05.934
and it should,
is to use tile layers.

00:38:05.934 --> 00:38:07.734
And this is basically
what we do on maps, right?

00:38:07.734 --> 00:38:09.000
So thing about
our road map tiles

00:38:09.000 --> 00:38:11.501
is that they have
a huge amount of vector data,

00:38:11.501 --> 00:38:13.801
but all that vector
is baked into the tiles,

00:38:13.801 --> 00:38:15.868
and that's how we get
such good performance

00:38:15.868 --> 00:38:17.934
because, no matter where
you go in the world,

00:38:17.934 --> 00:38:19.300
you're always
just loading in

00:38:19.300 --> 00:38:23.067
the seven tiles that represent
that part of the world.

00:38:23.067 --> 00:38:26.234
So you can create
these tiles layers yourself.

00:38:26.234 --> 00:38:28.033
And you can render whatever
vector data you have

00:38:28.033 --> 00:38:29.167
into those tiles

00:38:29.167 --> 00:38:31.033
and basically bake
your polygons in there

00:38:31.033 --> 00:38:32.801
and then overlay it
on top of our tiles.

00:38:32.801 --> 00:38:36.968
So here's another demo
from John.

00:38:36.968 --> 00:38:39.367
And he's just
generating these tiles

00:38:39.367 --> 00:38:41.400
from his
Postgres database,

00:38:41.400 --> 00:38:44.400
and, uh,

00:38:44.400 --> 00:38:47.367
you can see as we zoom in--
it's just loading more.

00:38:47.367 --> 00:38:48.501
Actually, I'll do this
in Firebug

00:38:48.501 --> 00:38:50.667
so you can actually
see the tiles.

00:38:54.334 --> 00:38:57.467
So you hid my stuff
in view, yes.

00:38:57.467 --> 00:39:01.534
So we'll do images,
outline images, all images.

00:39:01.534 --> 00:39:03.300
So here you can see
I've outlined the images.

00:39:03.300 --> 00:39:04.701
So you can tell that
they're all tiles.

00:39:04.701 --> 00:39:06.901
And it's a combination of
his custom tiles

00:39:06.901 --> 00:39:09.767
with our
hybrid upper layer.

00:39:09.767 --> 00:39:11.534
And you can see,
as you zoom in,

00:39:11.534 --> 00:39:14.767
one of these tiles becomes
four more tiles.

00:39:14.767 --> 00:39:17.334
So this is just
an image pyramid.

00:39:17.334 --> 00:39:18.801
So if you're creating
these tiles yourself,

00:39:18.801 --> 00:39:21.534
you just have to have a script
that will write out these images

00:39:21.534 --> 00:39:22.934
and then create
an image pyramid.

00:39:22.934 --> 00:39:25.334
So basically
the world is divided

00:39:25.334 --> 00:39:28.234
into an X-Y-Z grid, um,
three-dimensional,

00:39:28.234 --> 00:39:30.701
and everywhere in the world
you have a tile

00:39:30.701 --> 00:39:32.100
representing
that grid.

00:39:32.100 --> 00:39:34.734
Now you probably don't
want to actually pre-render

00:39:34.734 --> 00:39:36.100
all the tiles,

00:39:36.100 --> 00:39:37.567
especially if you're covering,
like, a large area,

00:39:37.567 --> 00:39:39.000
like all of America
in every zoom level.

00:39:39.000 --> 00:39:40.634
So there
you probably want to have

00:39:40.634 --> 00:39:41.734
on-demand
tile rendering,

00:39:41.734 --> 00:39:43.534
so that you only create
the tiles

00:39:43.534 --> 00:39:47.300
for the requested
viewport, right?

00:39:47.300 --> 00:39:48.968
'Cause it actually is
quite a bit of space

00:39:48.968 --> 00:39:50.234
on your hard drive

00:39:50.234 --> 00:39:54.901
to store tiles for zoom levels
1-21 in the world.

00:39:54.901 --> 00:39:57.634
It's like trillions of
terabytes and stuff.

00:39:57.634 --> 00:39:59.901
That's approximately...
number.

00:39:59.901 --> 00:40:02.567
[laughs]

00:40:02.567 --> 00:40:06.567
So yeah--so actually that's
everything I had to say

00:40:06.567 --> 00:40:08.000
about performance tips.

00:40:08.000 --> 00:40:10.801
So there's a lot here,
and a lot of options for you,

00:40:10.801 --> 00:40:12.634
using API v3,

00:40:12.634 --> 00:40:14.467
combining it with some of
the techniques we talked about.

00:40:14.467 --> 00:40:16.734
Using API v2 and using
some of the techniques.

00:40:16.734 --> 00:40:19.701
Using the Flash API.

00:40:19.701 --> 00:40:22.167
Lots of things to to that can
make for a better experience,

00:40:22.167 --> 00:40:23.367
and of course
we'll keep working

00:40:23.367 --> 00:40:25.667
on trying to bake these things
into the API.

00:40:25.667 --> 00:40:27.467
So with v3
we baked in

00:40:27.467 --> 00:40:28.834
that Static Map
optimization

00:40:28.834 --> 00:40:30.601
because we knew
a lot of people wanted it

00:40:30.601 --> 00:40:33.133
but didn't want to go through
the effort to implement it.

00:40:33.133 --> 00:40:34.467
So where it makes sense,

00:40:34.467 --> 00:40:37.367
we're gonna keep trying to do
the work for you,

00:40:37.367 --> 00:40:38.834
so that you
don't have to do

00:40:38.834 --> 00:40:43.033
as much of this optimization
yourself.

00:40:43.033 --> 00:40:44.100
So I just
want to talk about

00:40:44.100 --> 00:40:46.400
the qualified developer program,
again,

00:40:46.400 --> 00:40:49.033
for any of you who wasn't
in the earlier session.

00:40:49.033 --> 00:40:53.300
So this program is
to help us find

00:40:53.300 --> 00:40:55.634
all the qualified
Maps API developers out there

00:40:55.634 --> 00:40:56.767
and badge you,

00:40:56.767 --> 00:40:59.067
and be able to point
people to you.

00:40:59.067 --> 00:41:00.901
So in this program
you can sign up,

00:41:00.901 --> 00:41:03.968
and you can register yourself
as a vendor,

00:41:03.968 --> 00:41:05.167
and then
take a test,

00:41:05.167 --> 00:41:06.767
and provide
some references,

00:41:06.767 --> 00:41:10.367
and indicate if you've done
community forum support.

00:41:10.367 --> 00:41:13.868
And then we'll see
if you qualify,

00:41:13.868 --> 00:41:15.534
and we can give you
a badge,

00:41:15.534 --> 00:41:17.033
and then anyone
who's looking for

00:41:17.033 --> 00:41:18.367
maps API developers

00:41:18.367 --> 00:41:20.767
can go find you
in our Vendors Marketplace

00:41:20.767 --> 00:41:22.334
and then
contact you for work.

00:41:22.334 --> 00:41:23.801
So if you are
a freelance developer,

00:41:23.801 --> 00:41:26.067
please give this a try.

00:41:26.067 --> 00:41:27.501
It's fun,
taking tests.

00:41:27.501 --> 00:41:29.033
I love it.

00:41:29.033 --> 00:41:31.200
You love it, too.

00:41:31.200 --> 00:41:35.067
So give it a go and please
send us feedback about it.

00:41:35.067 --> 00:41:36.334
This is the first--

00:41:36.334 --> 00:41:38.000
we're rolling this out
for the Maps API

00:41:38.000 --> 00:41:39.868
before any of our other
Google APIs

00:41:39.868 --> 00:41:41.934
because the Maps API
has traditionally had

00:41:41.934 --> 00:41:43.868
a pretty strong
freelance community,

00:41:43.868 --> 00:41:46.300
and we never really had
a good way of recognizing them,

00:41:46.300 --> 00:41:47.501
and giving them their--

00:41:47.501 --> 00:41:50.300
a spotlight and way
for people to find them.

00:41:50.300 --> 00:41:51.767
So if it goes well
for Maps APIs,

00:41:51.767 --> 00:41:53.968
then it goes over the world,

00:41:53.968 --> 00:41:55.334
and you can get qualified
for everything.

00:41:55.334 --> 00:41:58.601
I personally plan
on getting qualified tonight.

00:41:58.601 --> 00:42:00.901
It should be easy since
I wrote half the test.

00:42:00.901 --> 00:42:03.868
audience: [laughs]

00:42:03.868 --> 00:42:06.968
I felt bad when I failed
my own questions, though.

00:42:06.968 --> 00:42:09.033
All right, so now
we take questions.

00:42:09.033 --> 00:42:10.834
If you have questions,
you come up to the mic.

00:42:10.834 --> 00:42:12.400
Thanks, guys.

00:42:12.400 --> 00:42:14.801
audience: [claps]

00:42:21.801 --> 00:42:26.300
[clicks tongue]

00:42:27.868 --> 00:42:29.601
No questions?

00:42:29.601 --> 00:42:32.000
If you--can you
come up to the mic and do it?

00:42:35.067 --> 00:42:37.400
And I should plug--
there's Ignite.

00:42:37.400 --> 00:42:38.601
If you guys
have never seen Ignite,

00:42:38.601 --> 00:42:40.133
we're doing Ignite
at IO.

00:42:40.133 --> 00:42:44.367
And Ignite is five minutes,
20 slides, 15 seconds,

00:42:44.367 --> 00:42:45.534
auto-advance.

00:42:45.534 --> 00:42:47.200
It's a very
interesting format.

00:42:47.200 --> 00:42:48.834
And I'm doing
one of the talks

00:42:48.834 --> 00:42:50.901
so I'm freaking out
a little bit.

00:42:50.901 --> 00:42:55.567
But that's at 4:00 in, I think,
the room across the way.

00:42:55.567 --> 00:42:58.167
So I recommend that
four your 4:00 slot,

00:42:58.167 --> 00:43:00.100
if you haven't done
anything for that yet.

00:43:00.100 --> 00:43:01.334
Yup.

00:43:01.334 --> 00:43:03.634
man: Hi, do you know
of any implementations

00:43:03.634 --> 00:43:07.567
where you have, like,
a group of markers on a map,

00:43:07.567 --> 00:43:10.400
and it auto-determines what
the appropriate zoom level is

00:43:10.400 --> 00:43:13.767
so that they're not
all bunched up together.

00:43:13.767 --> 00:43:15.934
Pamela: So that's, basically--
you can stay up.

00:43:15.934 --> 00:43:19.067
That would basically be
marker cluster,

00:43:19.067 --> 00:43:21.934
like, it figures out--
Oh, actually, no, no.

00:43:21.934 --> 00:43:23.534
So we have something called
MarkerManager,

00:43:23.534 --> 00:43:25.834
and what MarkerManager
does is, it says--

00:43:25.834 --> 00:43:27.467
you give it batches
and you say,

00:43:27.467 --> 00:43:28.834
"Okay, I want these markers
at this zoom level,

00:43:28.834 --> 00:43:30.267
and these markers
at this zoom level."

00:43:30.267 --> 00:43:32.934
But the thing is, there, you
have to pre-decide the batches,

00:43:32.934 --> 00:43:35.000
but somebody
for the Flash API

00:43:35.000 --> 00:43:37.334
wrote something on top of
the Marker Manager,

00:43:37.334 --> 00:43:39.234
which will automatically
figure out,

00:43:39.234 --> 00:43:42.934
like, nice zoom levels
for that.

00:43:42.934 --> 00:43:45.167
So I think he called it
multi-level MarkerManager,

00:43:45.167 --> 00:43:47.000
but I can ping you
the link after.

00:43:47.000 --> 00:43:48.200
man: Thanks.

00:43:48.200 --> 00:43:49.400
Pamela: Yeah, so
that doesn't do clustering.

00:43:49.400 --> 00:43:50.701
It just does random,
like--

00:43:50.701 --> 00:43:52.100
oh, there's a lot here
so we're not gonna--

00:43:52.100 --> 00:43:54.801
we're not gonna show
all of those at this zoom level.

00:43:54.801 --> 00:43:56.934
Right.

00:43:56.934 --> 00:43:59.634
man: I have close to
4,000 markers,

00:43:59.634 --> 00:44:02.300
and a layer
of polygon.

00:44:02.300 --> 00:44:05.133
I want
both of them clickable.

00:44:05.133 --> 00:44:06.300
Pamela: Okay.

00:44:06.300 --> 00:44:11.033
man: So far, I'm using
the XML parsing

00:44:11.033 --> 00:44:15.534
so that I can hide it, you know,
or show it whenever I want.

00:44:15.534 --> 00:44:16.601
Pamela: Yep.

00:44:16.601 --> 00:44:18.067
man: Now,
what's happening here

00:44:18.067 --> 00:44:21.767
is that
every time I click on the link,

00:44:21.767 --> 00:44:23.334
the parsing is going on
in the background,

00:44:23.334 --> 00:44:24.834
and I don't want that.

00:44:24.834 --> 00:44:26.634
How do we stop it?

00:44:26.634 --> 00:44:28.467
It's taking forever, so.

00:44:28.467 --> 00:44:30.701
Pamela: Um, what is it
parsing when you click?

00:44:30.701 --> 00:44:32.734
man: It's parsing
the XML file.

00:44:32.734 --> 00:44:35.801
It just has the
lat-long information,

00:44:35.801 --> 00:44:38.534
and just a description,
that's all.

00:44:38.534 --> 00:44:40.567
Pamela: Okay, well, the first
thing I would recommend that

00:44:40.567 --> 00:44:42.567
is instead of using XML,
I would use JSON,

00:44:42.567 --> 00:44:45.634
since it's natively
supported in JavaScript.

00:44:45.634 --> 00:44:46.968
So you'll get
a slightly faster

00:44:46.968 --> 00:44:48.467
parsing performance,
there.

00:44:48.467 --> 00:44:50.334
man: I see.

00:44:50.334 --> 00:44:52.801
Pamela: And then--JSON, you can
make pretty compact.

00:44:52.801 --> 00:44:54.701
You can really make your keys
be really short

00:44:54.701 --> 00:44:56.067
and stuff like that.

00:44:56.067 --> 00:44:58.634
So I recommend JSON just as
the data transfer format.

00:44:58.634 --> 00:45:01.033
man: Okay.

00:45:01.033 --> 00:45:02.334
Pamela: And as for--

00:45:02.334 --> 00:45:04.367
I don't know what your
exact setup looks like,

00:45:04.367 --> 00:45:08.200
but I would look at
how much data you're downloading

00:45:08.200 --> 00:45:09.434
and how much
you're parsing,

00:45:09.434 --> 00:45:11.300
and whether maybe you can
segment it differently.

00:45:11.300 --> 00:45:13.000
And maybe--I don't know
what you're doing exactly,

00:45:13.000 --> 00:45:15.300
but you could do
more efficient stuff

00:45:15.300 --> 00:45:19.167
if you only load in the data
for approximately that bounds

00:45:19.167 --> 00:45:20.634
or something like that.

00:45:20.634 --> 00:45:22.734
man: Yeah, unfortunately,
we don't have that option.

00:45:22.734 --> 00:45:24.901
We want to see all the
3,000 markers at the same time.

00:45:24.901 --> 00:45:27.467
And then as we move in,
you know,

00:45:27.467 --> 00:45:30.834
the other 2,000
kick in.

00:45:30.834 --> 00:45:33.501
Okay, so I'll try
the JSON for that.

00:45:33.501 --> 00:45:35.601
Pamela: Yeah, try JSON
with some of the things

00:45:35.601 --> 00:45:36.734
we showed here
as well.

00:45:36.734 --> 00:45:38.300
man: Okay, and
the second question is

00:45:38.300 --> 00:45:41.534
do you have thematic mapping
support for AP--uh, for maps?

00:45:41.534 --> 00:45:44.234
I know they recently came out
with one for Google Earth,

00:45:44.234 --> 00:45:45.934
which was like, something,
last week or--

00:45:45.934 --> 00:45:47.367
Pamela: Yeah, yeah.

00:45:47.367 --> 00:45:50.167
So yeah, this guy,
this developer, Bjørn Sandvik,

00:45:50.167 --> 00:45:51.701
from the
thematic mapping blog.

00:45:51.701 --> 00:45:54.234
He made it--he used
the visualization API

00:45:54.234 --> 00:45:56.501
with the Google Earth API
to make it really easy

00:45:56.501 --> 00:45:58.300
to do thematic mapping.

00:45:58.300 --> 00:45:59.767
Just--I think he does it
country-base.

00:45:59.767 --> 00:46:01.701
So you can make a spreadsheet
that has a bunch of countries,

00:46:01.701 --> 00:46:02.834
and codes,

00:46:02.834 --> 00:46:05.267
and then it will go on plot them
on Google Earth,

00:46:05.267 --> 00:46:09.167
doing different
visualization techniques.

00:46:09.167 --> 00:46:10.767
So that's just something
a developer wrote.

00:46:10.767 --> 00:46:13.501
We in--
I'd say, in the APIs,

00:46:13.501 --> 00:46:15.067
we really haven't
baked in

00:46:15.067 --> 00:46:18.367
any sort of
thematic mapping.

00:46:18.367 --> 00:46:20.534
But lots of people have done it
on top of it.

00:46:20.534 --> 00:46:22.667
So I would love for us
to bake it more in,

00:46:22.667 --> 00:46:27.801
to make it a bit easier
to do thematic mapping,

00:46:27.801 --> 00:46:29.067
'cause it is
hard right now.

00:46:29.067 --> 00:46:31.501
But there's a fair amount
of data out there

00:46:31.501 --> 00:46:34.067
and, of,
geometry data,

00:46:34.067 --> 00:46:35.834
'cause the first thing you need
is geometry data.

00:46:35.834 --> 00:46:39.133
And in the group
we have...

00:46:40.934 --> 00:46:42.901
long--that's not
what I'm searching for.

00:46:46.300 --> 00:46:48.734
So we have--

00:46:48.734 --> 00:46:51.601
well, we have a bit
easier to use--not that one.

00:46:51.601 --> 00:46:53.501
This one:
GIS Data.

00:46:53.501 --> 00:46:55.133
This is a long list
of data sets

00:46:55.133 --> 00:46:56.300
that we've kind of
collected,

00:46:56.300 --> 00:46:59.067
so UK boundaries,
world data sets.

00:46:59.067 --> 00:47:01.200
This one's really cool:
dyne geometry.

00:47:01.200 --> 00:47:03.868
They'll actually give you--

00:47:03.868 --> 00:47:06.100
they give you
the encoded polylines

00:47:06.100 --> 00:47:10.567
and a JSON for all these regions
in the world.

00:47:10.567 --> 00:47:13.200
And they also offer
a web service as well

00:47:13.200 --> 00:47:15.801
to give back
the geometry.

00:47:15.801 --> 00:47:17.534
So there--
it's certainly--

00:47:17.534 --> 00:47:19.334
It does require
a bit of effort

00:47:19.334 --> 00:47:21.734
to, you know,
find that data

00:47:21.734 --> 00:47:24.400
and then decide how you want
to render it on the map.

00:47:24.400 --> 00:47:26.200
But there's nothing
stopping you from doing it.

00:47:26.200 --> 00:47:28.767
man: Okay, okay, and the last
question would be

00:47:28.767 --> 00:47:33.801
is there a JavaScript
support in KML right now?

00:47:33.801 --> 00:47:36.300
My objective is to--

00:47:38.067 --> 00:47:41.968
when I'm clicking on
a small href link,

00:47:41.968 --> 00:47:44.234
it should pop up
a window,

00:47:44.234 --> 00:47:46.334
rather than just popping up
a whole--

00:47:46.334 --> 00:47:49.100
rather than redirecting it
to a completely new blank page

00:47:49.100 --> 00:47:50.334
or some page.

00:47:50.334 --> 00:47:53.834
I just want to limit that
to a pop-up window.

00:47:53.834 --> 00:47:58.901
Pamela: Right, so,
as for KML support in the APIs,

00:47:58.901 --> 00:48:01.434
in the JavaScript API v2,
we have this class

00:48:01.434 --> 00:48:03.601
called GeoXml,

00:48:03.601 --> 00:48:05.968
and that takes a KML file
and renders it on the map.

00:48:05.968 --> 00:48:07.400
But we don't provide--

00:48:07.400 --> 00:48:08.767
it doesn't provide
any more customization

00:48:08.767 --> 00:48:09.801
on top of it.

00:48:09.801 --> 00:48:11.234
It's just
putting on the map,

00:48:11.234 --> 00:48:13.534
and then however we render it
is how we render it.

00:48:13.534 --> 00:48:15.434
And you can't
control it.

00:48:15.434 --> 00:48:16.734
So a lot of people
have written

00:48:16.734 --> 00:48:19.100
open source extensions
for parsing KML,

00:48:19.100 --> 00:48:21.334
so there's E GeoXml,
and there's GeoXml.

00:48:21.334 --> 00:48:23.400
And these will read in the file
and display it,

00:48:23.400 --> 00:48:25.167
and then you can
customize more

00:48:25.167 --> 00:48:28.834
of how that KML
is displayed.

00:48:28.834 --> 00:48:30.200
But the thing there
is that

00:48:30.200 --> 00:48:34.267
it's rendering it using
native GMarker and GPolyline.

00:48:34.267 --> 00:48:37.234
So you'll still
suffer from performance

00:48:37.234 --> 00:48:38.868
if your KML file
is quite large.

00:48:38.868 --> 00:48:42.000
So you could look
at combining

00:48:42.000 --> 00:48:46.033
E GeoXml with, maybe,
Polygonzo or Marker Light

00:48:46.033 --> 00:48:49.601
if you need to have
a lot of geometry in your file.

00:48:49.601 --> 00:48:52.601
man: Okay, I see.
All right, thank you.

00:48:52.601 --> 00:48:54.467
Pamela: Yup.

00:48:54.467 --> 00:48:57.100
man: I got a question regarding
the Redfin solution.

00:48:57.100 --> 00:49:00.701
So, yeah, you're not using
DOM nodes,

00:49:00.701 --> 00:49:02.934
and you're kind of
breaking up the DOM string

00:49:02.934 --> 00:49:04.701
and then you are using
innerHTML,

00:49:04.701 --> 00:49:06.667
but ultimately
it's still DOM elements,

00:49:06.667 --> 00:49:08.934
and then anytime that
you're gonna be panning the map,

00:49:08.934 --> 00:49:11.801
it is still
gonna be slow.

00:49:11.801 --> 00:49:13.367
Are you doing anything
to work around that,

00:49:13.367 --> 00:49:17.767
or is your solution basically
just to solve the drawing

00:49:17.767 --> 00:49:20.601
and not worry about
the panning and stuff like that.

00:49:20.601 --> 00:49:23.567
But it is part of
the mapping faction.

00:49:23.567 --> 00:49:24.801
Sasha: So, if you don't mind.
Pamela: Yeah.

00:49:24.801 --> 00:49:27.934
Sasha: Yeah, so, clearly
panning is also a problem.

00:49:27.934 --> 00:49:32.534
I mean, most browsers--
500 divs is not that bad...

00:49:32.534 --> 00:49:33.868
is not particularly bad.

00:49:33.868 --> 00:49:37.767
And we spend a lot of time
worrying about the redraw.

00:49:37.767 --> 00:49:39.767
The first draw is
gonna be the worst for us,

00:49:39.767 --> 00:49:41.434
but we do a lot of stuff of,
like,

00:49:41.434 --> 00:49:44.367
keeping an array of pointers
to all those DOM nodes.

00:49:44.367 --> 00:49:45.734
based on IDs.

00:49:45.734 --> 00:49:47.234
And, you know,
there's lots of

00:49:47.234 --> 00:49:48.334
interesting things
you can do where you say,

00:49:48.334 --> 00:49:51.334
okay, well, those ten
went off-map,

00:49:51.334 --> 00:49:53.667
and I want--put ten
onto the map.

00:49:53.667 --> 00:49:56.634
Okay, instead of taking out
those ten DOM nodes

00:49:56.634 --> 00:49:58.100
and putting ten DOM nodes
back in,

00:49:58.100 --> 00:49:59.501
or redrawing it all,

00:49:59.501 --> 00:50:04.033
you can say, okay, well just
change the CSS style,

00:50:04.033 --> 00:50:05.934
so I get a different
CSS background image,

00:50:05.934 --> 00:50:07.234
and give them
a different ID,

00:50:07.234 --> 00:50:08.734
or swap out their ID.

00:50:08.734 --> 00:50:10.701
And now all of a sudden,
you know,

00:50:10.701 --> 00:50:12.234
I didn't actually
have to do--

00:50:12.234 --> 00:50:14.300
I didn't have to add
or subtract from the DOM,

00:50:14.300 --> 00:50:16.868
which is
super-expensive.

00:50:16.868 --> 00:50:18.801
You can also, like,
let's say

00:50:18.801 --> 00:50:21.000
you know, half of the markers
went off the map.

00:50:21.000 --> 00:50:22.734
Sometimes it's better
just to go through

00:50:22.734 --> 00:50:24.000
and display
NONE nodes,

00:50:24.000 --> 00:50:26.901
rather than
ripping them out of the DOM.

00:50:26.901 --> 00:50:29.200
And then, you know,
we put in heuristics for, okay,

00:50:29.200 --> 00:50:31.634
well, but if you know, sometimes
we put in heuristics--

00:50:31.634 --> 00:50:33.734
we've tweaked this
a million times.

00:50:33.734 --> 00:50:35.434
But, heuristics for things,
like,

00:50:35.434 --> 00:50:38.234
okay, well, if I'm taking out
90% of the things on the map,

00:50:38.234 --> 00:50:40.701
I should probably just take
the whole div

00:50:40.701 --> 00:50:41.767
that contains
all of them out,

00:50:41.767 --> 00:50:43.834
and just re-draw.

00:50:43.834 --> 00:50:47.234
And so those are
a couple strategies we've used,

00:50:47.234 --> 00:50:49.334
and actually,
to be honest,

00:50:49.334 --> 00:50:50.968
I don't remember which ones
we're using right now

00:50:50.968 --> 00:50:53.767
because we've cycled through,
I think, all of those.

00:50:53.767 --> 00:50:55.601
And I think some of those
we're still using,

00:50:55.601 --> 00:50:57.133
but it's a matter of

00:50:57.133 --> 00:50:59.901
think of those, test them,
think of those, test them.

00:50:59.901 --> 00:51:01.167
Does that help?

00:51:01.167 --> 00:51:03.901
man: Yeah, and, just a kind of
general question.

00:51:03.901 --> 00:51:07.634
Have you guys run into this
IE, of course, issue

00:51:07.634 --> 00:51:13.501
where there's an HTML DOM size
limit of 175,000 pixels?

00:51:14.868 --> 00:51:16.167
Sasha: I have not.
Pamela: No.

00:51:16.167 --> 00:51:17.901
Sasha: I have never
run into that.

00:51:17.901 --> 00:51:19.200
man: You guys are really lucky
if you haven't.

00:51:19.200 --> 00:51:20.501
All right, thanks.

00:51:20.501 --> 00:51:21.601
Sasha: Sweet!

00:51:21.601 --> 00:51:22.934
Pamela: We have
other IE issues.

00:51:22.934 --> 00:51:25.634
man: My question just
kinda has to do with G Unload.

00:51:25.634 --> 00:51:28.767
v2 kind of introduced--helped
with all the circular references

00:51:28.767 --> 00:51:31.434
and all that, but I see
a kind of absence in v3,

00:51:31.434 --> 00:51:33.634
so, improvement?

00:51:33.634 --> 00:51:35.400
Pamela: So, yeah,
that's an improvement.

00:51:35.400 --> 00:51:39.601
'Cause we realized we could just
do G Unload ourselves.

00:51:39.601 --> 00:51:43.033
'Cause we had you put G Unload
on the body on Unload.

00:51:43.033 --> 00:51:45.701
But it's like, well,
why are we making them do that?

00:51:45.701 --> 00:51:47.100
We can do that
ourselves.

00:51:47.100 --> 00:51:50.033
So we do all of that
clean-up ourselves.

00:51:50.033 --> 00:51:51.434
man: Cool.
Pamela: Yeah.

00:51:51.434 --> 00:51:52.934
We actually had it, like,
a month ago,

00:51:52.934 --> 00:51:54.267
and then we were, like,
this is silly.

00:51:54.267 --> 00:51:56.467
We don't want to make
developers do it.

00:51:56.467 --> 00:51:58.000
[laughs]

00:51:58.000 --> 00:52:00.267
So you notice in the v3, like,
we've gone through and, like,

00:52:00.267 --> 00:52:01.868
everything that makes it
into v3 API

00:52:01.868 --> 00:52:03.801
we've kind of
analyzed it to death,

00:52:03.801 --> 00:52:05.067
and fought,

00:52:05.067 --> 00:52:09.467
and decided which things
really belong in this API,

00:52:09.467 --> 00:52:12.367
and which things
we can do for you and stuff.

00:52:12.367 --> 00:52:13.434
man: Sorry, I came in late.

00:52:13.434 --> 00:52:16.100
About GMAP-3.

00:52:16.100 --> 00:52:18.000
Are all the features
of GMAP-2

00:52:18.000 --> 00:52:19.634
gonna be supported
in GMAP-3?

00:52:19.634 --> 00:52:23.133
You just change
the architecture

00:52:23.133 --> 00:52:25.467
to optimize
the performance, right?

00:52:25.467 --> 00:52:27.167
Pamela: Yeah, so--

00:52:27.167 --> 00:52:29.734
I should--we didn't really
mention that it's--

00:52:29.734 --> 00:52:31.534
did you say it's
MVC architecture?

00:52:31.534 --> 00:52:32.868
Marcelo: I didn't.

00:52:32.868 --> 00:52:35.033
Pamela: Okay, so,
we're doing an MVC architecture,

00:52:35.033 --> 00:52:38.734
which makes it easier for us
to bring new things in

00:52:38.734 --> 00:52:42.200
because it makes it really,
really trivial to modularize.

00:52:42.200 --> 00:52:43.400
And there will be more
information about that

00:52:43.400 --> 00:52:44.734
in Susannah's talk
tomorrow.

00:52:44.734 --> 00:52:46.834
But, basically, we're going
to look at v2 and v3

00:52:46.834 --> 00:52:49.601
and look at the usage for
the features in v2,

00:52:49.601 --> 00:52:52.334
and figure out which things
should be baked into v2

00:52:52.334 --> 00:52:55.033
and also figure out which things
we can simply open source,

00:52:55.033 --> 00:52:56.834
and put it into
its own library.

00:52:56.834 --> 00:52:59.567
So we're gonna have
a bit more

00:52:59.567 --> 00:53:01.734
of an official story
on extensions,

00:53:01.734 --> 00:53:06.734
and maybe have slightly more
official extensions as well.

00:53:06.734 --> 00:53:08.834
So stuff that we didn't
maybe think is necessary

00:53:08.834 --> 00:53:10.834
to put into
that main core,

00:53:10.834 --> 00:53:12.767
but we wanna make it really easy
for people

00:53:12.767 --> 00:53:14.000
to integrate
with their maps.

00:53:14.000 --> 00:53:17.033
So eventually, everything
should be supported

00:53:17.033 --> 00:53:19.200
in some way,

00:53:19.200 --> 00:53:20.868
as long as it was
something

00:53:20.868 --> 00:53:22.701
that people actually used
in v2.

00:53:22.701 --> 00:53:24.601
We actually did have
one class in v2

00:53:24.601 --> 00:53:26.934
that we discovered
this year

00:53:26.934 --> 00:53:28.000
had never been used.

00:53:28.000 --> 00:53:29.234
man: Which one?

00:53:29.234 --> 00:53:30.367
Pamela: It was...

00:53:30.367 --> 00:53:34.667
gXML...transform...
GXslt?

00:53:34.667 --> 00:53:35.968
man: Oh, yeah,
that's transform.

00:53:35.968 --> 00:53:37.601
Pamela: Yeah,
it had a bug in it,

00:53:37.601 --> 00:53:39.200
so it wasn't usable.

00:53:39.200 --> 00:53:40.434
So that kind of class--

00:53:40.434 --> 00:53:42.667
For two years, no one
said anything, right?

00:53:42.667 --> 00:53:44.767
That kind of class we would
probably not have it

00:53:44.767 --> 00:53:45.767
in this thing,
right?

00:53:45.767 --> 00:53:46.801
And the thing also
to think about

00:53:46.801 --> 00:53:48.400
is the Maps API
came out

00:53:48.400 --> 00:53:51.200
before there were many
JavaScript APIs on the web.

00:53:51.200 --> 00:53:53.367
So there's a lot of stuff
we put in the Maps API,

00:53:53.367 --> 00:53:55.400
like, how to create
dragable objects,

00:53:55.400 --> 00:53:57.267
how to do
XML HP request,

00:53:57.267 --> 00:53:59.834
that's really not necessary
to have in a Maps API.

00:53:59.834 --> 00:54:02.834
We just did it because people
didn't have any other options.

00:54:02.834 --> 00:54:06.167
Now, most people use, like
jQuery, Prototype, whatever.

00:54:06.167 --> 00:54:08.267
So it's silly for us
to replicate

00:54:08.267 --> 00:54:10.534
the kind of general
AJAX-y things

00:54:10.534 --> 00:54:12.100
that those things do.

00:54:12.100 --> 00:54:14.801
So you notice that we probably
wouldn't put classes like that

00:54:14.801 --> 00:54:17.868
into a Maps API.

00:54:17.868 --> 00:54:21.601
man: So there's not gonna be
a GMAP Light, right?

00:54:21.601 --> 00:54:25.667
It's gonna be GMAP-3
for both mobile and desktop.

00:54:25.667 --> 00:54:26.701
Pamela: It's quite light.

00:54:26.701 --> 00:54:29.334
It is light, yes.
[laughs]

00:54:29.334 --> 00:54:33.734
man: Looking forward
to it.

00:54:33.734 --> 00:54:36.334
Pamela: Okay.

00:54:36.334 --> 00:54:38.567
All right.

00:54:38.567 --> 00:54:43.634
Cool, so you guys can come
to Ignite now...sweet.

00:54:43.634 --> 00:54:44.767
All right.
Thank you, guys.

00:54:44.767 --> 00:54:45.868
Sasha: Thank you.
Marcelo: Thank you.

