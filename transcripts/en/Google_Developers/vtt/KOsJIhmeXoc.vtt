WEBVTT
Kind: captions
Language: en

00:00:00.090 --> 00:00:01.030
NICK BRAY: Hello.

00:00:01.030 --> 00:00:02.300
My name is Nick Bray.

00:00:02.300 --> 00:00:03.470
I'm a software engineer.

00:00:03.470 --> 00:00:05.930
And I'm working on
Native Client.

00:00:05.930 --> 00:00:07.460
This is, unfortunately,
where dinner parties

00:00:07.460 --> 00:00:08.810
get a little awkward.

00:00:08.810 --> 00:00:10.440
So Nick, what's Native Client?

00:00:13.680 --> 00:00:14.880
It's a developer thing.

00:00:14.880 --> 00:00:16.170
It's part of Chrome.

00:00:16.170 --> 00:00:17.420
I work on Chrome.

00:00:19.830 --> 00:00:21.620
That's usually a fairly
soul-crushing thing.

00:00:21.620 --> 00:00:24.640
But fortunately, this isn't
a dinner party.

00:00:24.640 --> 00:00:27.050
And we can talk about
interesting things.

00:00:27.050 --> 00:00:29.910
So when I say "interesting,"
what I mean is--

00:00:29.910 --> 00:00:31.850
you get to drink from
the fire hose.

00:00:31.850 --> 00:00:33.720
So we're going to be discussing
address space.

00:00:33.720 --> 00:00:35.700
We're going to be discussing
instructions, assembly

00:00:35.700 --> 00:00:37.110
language, that kind of thing.

00:00:37.110 --> 00:00:40.290
I will try to make sure everyone
can follow along,

00:00:40.290 --> 00:00:43.450
even if you don't have a huge
amount of background in this.

00:00:43.450 --> 00:00:45.270
But we're going to get into
the nitty gritty technical

00:00:45.270 --> 00:00:48.950
details of how Native
Client works.

00:00:48.950 --> 00:00:52.170
Before we do this, of course,
the only kind thing to do is

00:00:52.170 --> 00:00:55.330
give a bit of an overview and
say how this fits in, why

00:00:55.330 --> 00:00:57.400
we're doing it, what's
important here.

00:00:57.400 --> 00:01:00.700
So one big thing we keep saying
is that Native Client

00:01:00.700 --> 00:01:03.330
allows native code to be safe
and secure as JavaScript.

00:01:03.330 --> 00:01:07.800
And this is a very compressed
tag line, which unless you

00:01:07.800 --> 00:01:10.690
actually know what's going on
behind the scenes, you aren't

00:01:10.690 --> 00:01:12.050
quite sure what that means.

00:01:12.050 --> 00:01:14.020
So one picture is worth
a thousand words.

00:01:14.020 --> 00:01:15.930
And this is a picture, which
you probably are familiar

00:01:15.930 --> 00:01:18.710
with, is whenever you try to run
a piece of native code on

00:01:18.710 --> 00:01:21.240
a computer, you get a
scary dialog box, or

00:01:21.240 --> 00:01:22.000
run from the web.

00:01:22.000 --> 00:01:25.590
So say someone tries to install
an NPAPI plug-in on

00:01:25.590 --> 00:01:29.000
your computer or even download
an EXE from the Internet, then

00:01:29.000 --> 00:01:31.820
try to run it, well, the
operating system is typically

00:01:31.820 --> 00:01:34.350
skeptical of any binary which
is coming from the network.

00:01:34.350 --> 00:01:36.540
And says, hey wait, you probably
shouldn't do this,

00:01:36.540 --> 00:01:38.170
but what do I know?

00:01:38.170 --> 00:01:40.040
You can do it anyways.

00:01:40.040 --> 00:01:43.240
So the problem with this is that
most users really cannot

00:01:43.240 --> 00:01:46.640
evaluate whether they should
click Run or not.

00:01:46.640 --> 00:01:50.130
And you sometimes lose 60 to
90% of your users when they

00:01:50.130 --> 00:01:51.730
get this dialog box.

00:01:51.730 --> 00:01:54.330
And even if they do hit Run,
then suddenly a lot of

00:01:54.330 --> 00:01:55.530
burden is on you.

00:01:55.530 --> 00:01:57.750
The burden becomes on you as
the developer to make sure

00:01:57.750 --> 00:02:00.650
that this piece of native code
you installed on your customer

00:02:00.650 --> 00:02:03.780
system is actually safe and
secure and doesn't become an

00:02:03.780 --> 00:02:06.290
attack vector where someone
exploits your customers

00:02:06.290 --> 00:02:07.710
because you made a mistake.

00:02:07.710 --> 00:02:12.090
So native code, understandably,
is very scary,

00:02:12.090 --> 00:02:14.400
especially when you get
these dialog boxes.

00:02:14.400 --> 00:02:17.290
So does the story end there,
Native Client?

00:02:17.290 --> 00:02:19.070
Should we be doing this?

00:02:19.070 --> 00:02:22.410
As it turns out, it isn't native
code itself which is

00:02:22.410 --> 00:02:23.000
the problem.

00:02:23.000 --> 00:02:24.810
It's the fact that my
presentation has not been

00:02:24.810 --> 00:02:27.360
refreshed, and the bullet
points aren't fading in.

00:02:27.360 --> 00:02:28.610
Hold on a second.

00:02:37.811 --> 00:02:39.550
OK, back in business.

00:02:39.550 --> 00:02:42.280
So the problem is that the
operating system has a very

00:02:42.280 --> 00:02:46.220
different notion of security
than the web does.

00:02:46.220 --> 00:02:49.520
So say I'm browsing a website
to watch videos of cats,

00:02:49.520 --> 00:02:51.870
because that's what we all do,
we just don't admit it.

00:02:51.870 --> 00:02:56.300
And then suddenly I notice my
tax return being uploaded to a

00:02:56.300 --> 00:02:58.080
Russian website.

00:02:58.080 --> 00:03:00.530
So this right here
is a Windows API

00:03:00.530 --> 00:03:03.000
call to open a file.

00:03:03.000 --> 00:03:06.030
So really, this Russian website
does not need my tax

00:03:06.030 --> 00:03:08.580
return in order for me to
watch videos of cats.

00:03:08.580 --> 00:03:10.730
So there's something seriously
wrong here.

00:03:10.730 --> 00:03:13.800
But as it turns out, operating
systems are secure.

00:03:13.800 --> 00:03:15.760
They just think that any
program running on your

00:03:15.760 --> 00:03:18.750
computer is acting
on your behalf.

00:03:18.750 --> 00:03:21.610
So because you can open your
own spreadsheet, it assumes

00:03:21.610 --> 00:03:25.270
that any native program should
have access to it.

00:03:25.270 --> 00:03:27.580
The web figured out this is
probably not the way things

00:03:27.580 --> 00:03:30.170
should run when you're loading
other people's programs.

00:03:30.170 --> 00:03:33.260
So instead they say that the
program is operating on behalf

00:03:33.260 --> 00:03:34.570
of the website.

00:03:34.570 --> 00:03:36.880
And it should only do things
which you authorize the

00:03:36.880 --> 00:03:39.320
website to do.

00:03:39.320 --> 00:03:41.480
What this means, of course, is
that if you load native code

00:03:41.480 --> 00:03:43.530
and it can talk to the operating
system, it can just

00:03:43.530 --> 00:03:45.340
blow right past the browser.

00:03:45.340 --> 00:03:47.600
And that is the fundamental
problem with native code, is

00:03:47.600 --> 00:03:51.490
it can do things that your web
browser says is unsafe.

00:03:51.490 --> 00:03:53.530
Another problem, which isn't
immediately apparent, is this

00:03:53.530 --> 00:03:56.630
is a Windows API call
to open a file.

00:03:56.630 --> 00:03:59.480
And imagine if you were, say,
writing a nice application to

00:03:59.480 --> 00:04:02.780
view cat videos, which also
happens to upload files.

00:04:02.780 --> 00:04:05.880
Well, suddenly you have a cross-
platform support issue.

00:04:05.880 --> 00:04:08.290
You can open the files on
Windows, but are you going to

00:04:08.290 --> 00:04:09.180
support Mac builds?

00:04:09.180 --> 00:04:10.720
Are you going to support
Linux builds?

00:04:10.720 --> 00:04:12.790
I mean, honestly, when you're
writing malware, it becomes a

00:04:12.790 --> 00:04:14.150
huge problem.

00:04:14.150 --> 00:04:15.810
Of course, there's some
honest developers who

00:04:15.810 --> 00:04:16.769
have the same problem.

00:04:16.769 --> 00:04:19.220
And that's, when I distribute
native code, how do I make

00:04:19.220 --> 00:04:21.290
sure it actually
runs on all the

00:04:21.290 --> 00:04:23.540
operating systems out there?

00:04:23.540 --> 00:04:25.920
Another thing, again, which
isn't immediately obvious, is

00:04:25.920 --> 00:04:27.440
this is a synchronous call.

00:04:27.440 --> 00:04:30.100
A lot of operating system APIs
were designed back in the days

00:04:30.100 --> 00:04:32.230
where synchronous blocking
of things

00:04:32.230 --> 00:04:33.640
seemed like a good idea.

00:04:33.640 --> 00:04:36.740
But with the advent of browsers
and JavaScript, a

00:04:36.740 --> 00:04:39.570
decision was made to eliminate
the use of threads for the

00:04:39.570 --> 00:04:42.450
most part within a single
JavaScript environment, a

00:04:42.450 --> 00:04:43.620
single document.

00:04:43.620 --> 00:04:45.440
And instead, everything was
single-threaded with

00:04:45.440 --> 00:04:46.860
asynchronous callbacks.

00:04:46.860 --> 00:04:49.710
So APIs have had to change in
order to support the web.

00:04:49.710 --> 00:04:52.320
Whenever you open a file on the
web, you, in fact, give it

00:04:52.320 --> 00:04:54.100
a callback to call you back.

00:04:54.100 --> 00:04:59.020
So, the big crux of Native
Client is making you talk to

00:04:59.020 --> 00:05:01.930
the web browser instead of
talking to the operating

00:05:01.930 --> 00:05:05.260
system, and in fact making it
impossible to talk to the

00:05:05.260 --> 00:05:06.510
operating system.

00:05:08.560 --> 00:05:11.170
So this is an example of what
a native program talking to

00:05:11.170 --> 00:05:12.350
the web browser would
look like.

00:05:12.350 --> 00:05:14.690
It's a little ugly, but
it's from real code.

00:05:14.690 --> 00:05:16.370
And well, real code is ugly.

00:05:16.370 --> 00:05:20.180
So this is an example of doing
a URL request to get the page

00:05:20.180 --> 00:05:22.660
www.google.com.

00:05:22.660 --> 00:05:25.070
It's analogous to what we were
seeing with opening a file.

00:05:25.070 --> 00:05:27.030
But it's a different
API, and it's

00:05:27.030 --> 00:05:29.120
routed through the browser.

00:05:29.120 --> 00:05:33.070
So Native Client provides a
bunch of APIs for I/O that are

00:05:33.070 --> 00:05:35.300
mediated through the browser
through an API called the

00:05:35.300 --> 00:05:36.950
Pepper Plugin API.

00:05:36.950 --> 00:05:39.530
The Pepper Plugin API you can
think of as a successor to the

00:05:39.530 --> 00:05:41.990
Netscape Plugin API, where
things we've learned in the

00:05:41.990 --> 00:05:45.170
meantime, such as 3D graphics
are good, have been

00:05:45.170 --> 00:05:45.910
incorporated.

00:05:45.910 --> 00:05:48.950
And instead of just drawing to
a random window, you can now

00:05:48.950 --> 00:05:51.420
delegate to the browser and say
here's some 3D content,

00:05:51.420 --> 00:05:52.610
just like WebGL.

00:05:52.610 --> 00:05:55.120
So ultimately, the Pepper Plugin
API gives you a lot of

00:05:55.120 --> 00:05:57.680
functionality similar
to JavaScript.

00:05:57.680 --> 00:06:01.190
As you can think, all the APIs
that JavaScript has to open

00:06:01.190 --> 00:06:04.940
URLs, to draw 3D content, it's
also exposed to native code

00:06:04.940 --> 00:06:06.190
through Pepper.

00:06:08.080 --> 00:06:10.910
Not everything is I/O. So if you
want to spin up a thread

00:06:10.910 --> 00:06:13.030
or do things like that, that
actually occurs within a

00:06:13.030 --> 00:06:13.830
single process.

00:06:13.830 --> 00:06:15.100
You don't need to talk
to the browser,

00:06:15.100 --> 00:06:16.450
don't need it's approval.

00:06:16.450 --> 00:06:18.860
And for that, we've used
the POSIX API.

00:06:18.860 --> 00:06:21.750
So you can spawn threads
and do similar things.

00:06:21.750 --> 00:06:25.650
So if your code's running on
Linux, you can port the I/O to

00:06:25.650 --> 00:06:26.760
use Pepper.

00:06:26.760 --> 00:06:29.330
And more or less, everything
else should look

00:06:29.330 --> 00:06:31.570
relatively the same.

00:06:31.570 --> 00:06:33.810
And why are we doing this?

00:06:33.810 --> 00:06:36.030
The ultimate goal is no
scary dialog box.

00:06:36.030 --> 00:06:37.580
You can just run the code.

00:06:37.580 --> 00:06:39.680
It follows the web safety rules,
so you don't have to

00:06:39.680 --> 00:06:40.660
warn the user.

00:06:40.660 --> 00:06:41.940
It's part a seamless
experience.

00:06:41.940 --> 00:06:45.010
And in fact, most users won't
know the running NaCl.

00:06:45.010 --> 00:06:48.150
We have a lot of games in the
web store now, which we aren't

00:06:48.150 --> 00:06:48.950
trumpeting NaCl.

00:06:48.950 --> 00:06:50.970
It's just you can run bastion
on your computer now.

00:06:53.710 --> 00:06:56.670
So the life cycle of a Native
Client application has three

00:06:56.670 --> 00:06:57.710
distinct stages.

00:06:57.710 --> 00:06:59.040
The first stage is what
the developer

00:06:59.040 --> 00:07:00.230
does on their computer.

00:07:00.230 --> 00:07:04.000
So you can get a bunch of
sources, existing library.

00:07:04.000 --> 00:07:06.170
Or say you've written a game,
and you want to port the game,

00:07:06.170 --> 00:07:07.660
run it on the web.

00:07:07.660 --> 00:07:10.590
You do supporting work on your
C files, and then you use a

00:07:10.590 --> 00:07:13.850
modified version of GCC,
which we provide.

00:07:13.850 --> 00:07:15.130
There's one wrinkle on this.

00:07:15.130 --> 00:07:18.060
And that's that you need to
use a version of GCC that

00:07:18.060 --> 00:07:20.870
targets binaries for different
platforms--

00:07:20.870 --> 00:07:22.930
or different architectures,
I should say, chip

00:07:22.930 --> 00:07:23.820
architectures.

00:07:23.820 --> 00:07:26.810
So the binaries that are
produced are OS independent,

00:07:26.810 --> 00:07:31.710
but for the moment, they have a
architecture, an instruction

00:07:31.710 --> 00:07:33.730
architecture set dependency.

00:07:33.730 --> 00:07:38.130
So for this talk, I'm going to
show you the internals for the

00:07:38.130 --> 00:07:40.670
x86-64 sandboxing model.

00:07:40.670 --> 00:07:43.890
And you can think that the
x86-32 and the ARM sandboxing

00:07:43.890 --> 00:07:46.230
models are quite similar.

00:07:46.230 --> 00:07:50.670
The details differ, but
spiritually they're the same.

00:07:50.670 --> 00:07:52.130
At the end of the year,
we're going to have a

00:07:52.130 --> 00:07:54.590
product called PNaCl.

00:07:54.590 --> 00:07:56.020
I should've defined this
a little earlier.

00:07:56.020 --> 00:07:59.530
When I say NaCl, I mean
Native Client.

00:07:59.530 --> 00:08:02.650
And I've just use this term so
much, I use it automatically.

00:08:02.650 --> 00:08:05.430
So I need to make very sure
that everyone knows I mean

00:08:05.430 --> 00:08:06.220
Native Client.

00:08:06.220 --> 00:08:09.540
So PNaCl, Portable Native,
Client, P-NaCl, is going to

00:08:09.540 --> 00:08:12.510
use an LLVM-based tool chain,
which will allow you to ship

00:08:12.510 --> 00:08:15.560
bit code, platform independent
bit code, across the wire.

00:08:15.560 --> 00:08:17.740
And that'll get translated to
whatever architecture you want

00:08:17.740 --> 00:08:18.940
to use on the computer.

00:08:18.940 --> 00:08:21.860
So that'll be roughly
the end of the year.

00:08:21.860 --> 00:08:26.060
And at the bottom level, what
we're going to talk about

00:08:26.060 --> 00:08:27.260
today remains the same.

00:08:27.260 --> 00:08:29.800
So the interchange format will
change, but the sandboxing

00:08:29.800 --> 00:08:32.580
model, the inner mechanics,
is going to stay the same.

00:08:32.580 --> 00:08:36.840
So this modified version of GCC
outputs code which we can

00:08:36.840 --> 00:08:38.640
later statically analyze.

00:08:38.640 --> 00:08:39.919
And we'll get into
what this is.

00:08:39.919 --> 00:08:42.150
We call it validation.

00:08:42.150 --> 00:08:44.450
Once you compile this code, you
upload it to a web server,

00:08:44.450 --> 00:08:45.490
just like a normal web app.

00:08:45.490 --> 00:08:47.640
In fact, it looks a lot
like a normal web app.

00:08:47.640 --> 00:08:48.710
You have an HTML file.

00:08:48.710 --> 00:08:49.780
You can have JavaScript.

00:08:49.780 --> 00:08:51.390
You can have CSS.

00:08:51.390 --> 00:08:53.810
And then within that app, you
have an embed tag somewhere.

00:08:53.810 --> 00:08:56.970
And the embed tag pulls in the
Native Client executable, and

00:08:56.970 --> 00:08:58.360
it can talk with the rest
of the web page.

00:08:58.360 --> 00:09:03.970
So you can make a UI
with HTML elements.

00:09:03.970 --> 00:09:06.890
And finally, at the end,
there is the user.

00:09:06.890 --> 00:09:08.940
The user is running a browser
on the computer.

00:09:08.940 --> 00:09:12.490
The browser loads the page,
loads the embed tag, pulls in

00:09:12.490 --> 00:09:15.040
the Native Client executable.

00:09:15.040 --> 00:09:16.200
So the question to
ask at this point

00:09:16.200 --> 00:09:18.020
is, where's the security?

00:09:18.020 --> 00:09:21.360
Ultimately, the user wants to
say that this application I'm

00:09:21.360 --> 00:09:24.230
running on the network isn't
going to harm my computer.

00:09:24.230 --> 00:09:26.230
So how are we are able to
make that assertion?

00:09:26.230 --> 00:09:29.810
We actually can't say that
about the compiler.

00:09:29.810 --> 00:09:32.530
So the compiler tries to output
code, which we can

00:09:32.530 --> 00:09:34.120
verify as safe.

00:09:34.120 --> 00:09:37.550
But we don't trust it, because
at the end of the day who

00:09:37.550 --> 00:09:38.990
knows what the developer's
intending.

00:09:38.990 --> 00:09:41.105
They could just have an
arbitrary binary blob that

00:09:41.105 --> 00:09:42.870
they put together with
the hex editor.

00:09:42.870 --> 00:09:45.720
And when the user gets it, they
have to look at it and

00:09:45.720 --> 00:09:47.770
verify it's safe before
they run it.

00:09:47.770 --> 00:09:50.380
And similarly, even if
it isn't malicious,

00:09:50.380 --> 00:09:52.300
compilers have bugs.

00:09:52.300 --> 00:09:55.560
So GCC, LLVM, very complex
pieces of software.

00:09:55.560 --> 00:09:59.000
They were not written with
safety in mind to begin with.

00:09:59.000 --> 00:10:01.220
So saying that these compilers
are going to produce perfect

00:10:01.220 --> 00:10:03.520
code, that's a bad assumption
to make.

00:10:03.520 --> 00:10:06.590
Instead, on the web browser, we
look at the code before we

00:10:06.590 --> 00:10:09.410
run it and apply some simple
rules to try to verify it's

00:10:09.410 --> 00:10:12.000
safe rather than saying this
big complicated piece of

00:10:12.000 --> 00:10:14.000
software is where
the safety is.

00:10:16.760 --> 00:10:21.010
When Native Client actually runs
an EXE, the process model

00:10:21.010 --> 00:10:22.330
looks a little bit like this.

00:10:22.330 --> 00:10:25.740
So what you think of as the web
browser, what you see is

00:10:25.740 --> 00:10:27.020
called the browser process.

00:10:27.020 --> 00:10:29.500
And that's just a normal
application running on your

00:10:29.500 --> 00:10:31.230
computer, talking with the OS.

00:10:31.230 --> 00:10:35.860
But every time Chrome visits a
new domain, it usually splits

00:10:35.860 --> 00:10:38.840
it off into its own process
and says there is a render

00:10:38.840 --> 00:10:42.460
process for the specific site,
which can do all the

00:10:42.460 --> 00:10:45.100
JavaScript execution, all the
rendering of the DOM.

00:10:45.100 --> 00:10:47.100
And we're going to try to
keep sites separate.

00:10:47.100 --> 00:10:50.690
So if one site is compromised,
it rattles around in its own

00:10:50.690 --> 00:10:54.300
process and has a much harder
time attacking another site,

00:10:54.300 --> 00:10:56.790
stealing your credentials from
your banking system,

00:10:56.790 --> 00:10:57.860
or things like that.

00:10:57.860 --> 00:11:00.050
So these renderer processes run
in something called the

00:11:00.050 --> 00:11:01.730
Chrome Sandbox.

00:11:01.730 --> 00:11:04.800
The Chrome Sandbox, you can
think of it as deprivileging

00:11:04.800 --> 00:11:06.050
the processes.

00:11:06.050 --> 00:11:09.480
It says, hey, if these processes
ask for your tax

00:11:09.480 --> 00:11:12.300
return, that's probably
a bad idea.

00:11:12.300 --> 00:11:15.470
So don't trust them, don't
give it to them.

00:11:15.470 --> 00:11:17.120
So you'd think that this
solves most of the

00:11:17.120 --> 00:11:18.730
problems for NaCl.

00:11:18.730 --> 00:11:21.910
But as it turns out, we're
following a pattern called

00:11:21.910 --> 00:11:23.440
defense in depth.

00:11:23.440 --> 00:11:26.910
We try to build layers, each of
which is secure on its own.

00:11:26.910 --> 00:11:29.410
And if one of those layers
fails, the other should catch

00:11:29.410 --> 00:11:30.920
the problem.

00:11:30.920 --> 00:11:32.600
And there's actually some
subtle problems with the

00:11:32.600 --> 00:11:34.770
sandbox I'm not going
to get fully into.

00:11:34.770 --> 00:11:38.180
But Native Client tries to
provide an inner sandbox

00:11:38.180 --> 00:11:39.800
inside its own process.

00:11:39.800 --> 00:11:42.460
So when you have an embed tag
in the web page, instead of

00:11:42.460 --> 00:11:44.450
running the Native Client
executable inside the render

00:11:44.450 --> 00:11:47.510
process, it spins up yet another
process, and then

00:11:47.510 --> 00:11:50.820
applies the inner sandbox to
make sure it never can--

00:11:50.820 --> 00:11:54.690
or we try to make sure it can
never do anything bad.

00:11:54.690 --> 00:11:57.270
So for the rest of this
presentation, I'm going to be

00:11:57.270 --> 00:11:58.740
talking about the
inner sandbox.

00:11:58.740 --> 00:12:00.280
I'm going to be talking
about what

00:12:00.280 --> 00:12:02.350
happens in the NaCl process.

00:12:02.350 --> 00:12:06.400
Now, there's a lot of little
pieces that build up in order

00:12:06.400 --> 00:12:09.950
for us to verify that the
process isn't talking with the

00:12:09.950 --> 00:12:12.150
operating system, or more
correctly, the code that's

00:12:12.150 --> 00:12:15.250
loaded across the network is not
talking directly with the

00:12:15.250 --> 00:12:16.230
operating system.

00:12:16.230 --> 00:12:19.470
And we can do very controlled
calls to provide services that

00:12:19.470 --> 00:12:22.430
are needed.

00:12:22.430 --> 00:12:25.180
So the first step in this
journey is being able to

00:12:25.180 --> 00:12:28.050
understand what code we have.

00:12:28.050 --> 00:12:29.240
So you'd think this is easy.

00:12:29.240 --> 00:12:30.550
You've done assembly language.

00:12:30.550 --> 00:12:32.030
You see a lot of instructions.

00:12:32.030 --> 00:12:34.900
And we just look at the
instructions and say, bad

00:12:34.900 --> 00:12:35.430
instruction.

00:12:35.430 --> 00:12:37.070
We're not running it.

00:12:37.070 --> 00:12:38.400
End of the story.

00:12:38.400 --> 00:12:40.960
However, computers see the world
in a different way than

00:12:40.960 --> 00:12:41.740
humans usually do.

00:12:41.740 --> 00:12:45.070
And that's that native code
is a stream of bytes.

00:12:45.070 --> 00:12:47.220
And they start executing
the stream of bytes--

00:12:47.220 --> 00:12:50.660
pull in bytes, execute, pull
in more bytes, execute.

00:12:50.660 --> 00:12:52.595
And if we really want to
understand what the processor

00:12:52.595 --> 00:12:55.380
is doing, we have to disassemble
the code.

00:12:55.380 --> 00:12:58.160
We have to look at it from the
CPU's point of view and see

00:12:58.160 --> 00:13:01.080
what it's going to execute.

00:13:01.080 --> 00:13:04.300
So before we get into why this
is all difficult, the question

00:13:04.300 --> 00:13:05.440
is, what are we looking for?

00:13:05.440 --> 00:13:08.880
What instructions do we
not want to execute?

00:13:08.880 --> 00:13:12.070
The first one which I've been
harping on is syscall.

00:13:12.070 --> 00:13:15.150
So syscall, just as a
convention, on the right I

00:13:15.150 --> 00:13:18.670
will have the bytes that these
instructions compile into.

00:13:18.670 --> 00:13:20.760
So syscall is a two-byte
instruction.

00:13:20.760 --> 00:13:23.680
And what this does is, it says,
hey, operating system, I

00:13:23.680 --> 00:13:25.920
want you provide a
service for me.

00:13:25.920 --> 00:13:29.720
And without the outer sandbox,
without the Chrome sandbox,

00:13:29.720 --> 00:13:31.900
there is very obvious problems
here, is that you can open

00:13:31.900 --> 00:13:33.630
files, do all sorts
of bad things.

00:13:33.630 --> 00:13:35.910
But even with the Chrome
sandbox, there are still a lot

00:13:35.910 --> 00:13:36.830
of problems.

00:13:36.830 --> 00:13:41.480
So there's a recently publicized
vulnerability in

00:13:41.480 --> 00:13:46.460
the Intel implementation of the
x86-64 architecture, where

00:13:46.460 --> 00:13:49.810
the sysexit return-- so in the
operating system return from

00:13:49.810 --> 00:13:53.820
assist call, if you set it up
in such a clever way, you

00:13:53.820 --> 00:13:56.030
could cause it to overwrite
arbitrary memory inside the

00:13:56.030 --> 00:14:00.080
operating system and result in
a exploit, where you could

00:14:00.080 --> 00:14:02.430
escalate privileges in
the operating system.

00:14:02.430 --> 00:14:06.810
So the silicon itself
allowed an attack on

00:14:06.810 --> 00:14:08.250
the operating system.

00:14:08.250 --> 00:14:09.840
The bottom line is, we
simply do not want

00:14:09.840 --> 00:14:10.930
to make these calls.

00:14:10.930 --> 00:14:12.880
These calls are the gateway
to the operating system.

00:14:12.880 --> 00:14:14.230
They are an attack surface.

00:14:14.230 --> 00:14:16.400
So even if we're in a
de-privilege process, we don't

00:14:16.400 --> 00:14:19.260
want to make them in
the first place.

00:14:19.260 --> 00:14:20.480
Another interesting
instruction.

00:14:20.480 --> 00:14:23.930
This is actually a fairly old
example, but famous, is the

00:14:23.930 --> 00:14:25.410
FOOF instruction.

00:14:25.410 --> 00:14:29.840
The FOOF instruction, because
it starts with F-O-O-F, had

00:14:29.840 --> 00:14:33.420
this nasty habit of actually
freezing your entire computer

00:14:33.420 --> 00:14:35.560
when executed on an
older Pentium.

00:14:35.560 --> 00:14:39.990
So under the hood what was going
on is it applied a lock,

00:14:39.990 --> 00:14:42.780
and then it tried to execute
an invalid instruction.

00:14:42.780 --> 00:14:46.250
And it never recovered
and unlocked so your

00:14:46.250 --> 00:14:47.790
entire CPU hung up.

00:14:47.790 --> 00:14:50.020
So if you talk to some security
people, they'll say,

00:14:50.020 --> 00:14:52.160
well, this isn't really a
security vulnerability.

00:14:52.160 --> 00:14:54.990
Because, well, you know, you
aren't using your bank account

00:14:54.990 --> 00:14:56.980
information to some
random hacker.

00:14:56.980 --> 00:14:59.060
But if you think about it from
a web perspective, do you

00:14:59.060 --> 00:15:01.240
really want to surf to a web
page and have to power cycle

00:15:01.240 --> 00:15:01.850
your computer?

00:15:01.850 --> 00:15:02.890
It's bad.

00:15:02.890 --> 00:15:05.470
So there is these classes of
instructions that again we

00:15:05.470 --> 00:15:08.260
want to blacklist and say if
we encounter these in an

00:15:08.260 --> 00:15:11.080
executable, obviously the
person's up to no good.

00:15:11.080 --> 00:15:13.860
So syscalls, FOOF instructions,
we're not going

00:15:13.860 --> 00:15:16.460
to mess with them and just
reject the binary out right

00:15:16.460 --> 00:15:18.590
and not run it.

00:15:18.590 --> 00:15:20.310
So there's a third class
of instruction,

00:15:20.310 --> 00:15:22.470
which is a little weird.

00:15:22.470 --> 00:15:25.700
And if you just look at this
instruction, all it does is

00:15:25.700 --> 00:15:27.790
multiply a bunch of
numbers together.

00:15:27.790 --> 00:15:28.980
Perfectly safe.

00:15:28.980 --> 00:15:30.570
There's no problem with this.

00:15:30.570 --> 00:15:33.520
Well, as it turns out, the one
wrinkle here is that this is

00:15:33.520 --> 00:15:38.350
part of a new instruction set,
the SSE4 instruction set.

00:15:38.350 --> 00:15:40.880
So if you're running on a
computer that doesn't support

00:15:40.880 --> 00:15:43.670
this instruction set, what
happens when you try to

00:15:43.670 --> 00:15:45.440
execute it?

00:15:45.440 --> 00:15:48.240
So in theory, it should just
halt the process, but has

00:15:48.240 --> 00:15:51.620
everyone really tested every
invalid instruction possible

00:15:51.620 --> 00:15:52.770
on every chip?

00:15:52.770 --> 00:15:55.670
So instead of running this risk,
instead what we do when

00:15:55.670 --> 00:15:57.960
we encounter it, instead of
rejecting the program, we

00:15:57.960 --> 00:16:00.570
simply write over it with
halt instructions.

00:16:00.570 --> 00:16:04.250
So a well-formed executable
should not try to execute this

00:16:04.250 --> 00:16:06.160
instruction if it's
not supported.

00:16:06.160 --> 00:16:08.290
But if it does, because we
overwrote it with halt

00:16:08.290 --> 00:16:11.960
instructions, that causes the
execution to stop when it

00:16:11.960 --> 00:16:14.720
encounters it, just like it
theoretically should if the

00:16:14.720 --> 00:16:17.940
instruction was not supported
by the processor.

00:16:17.940 --> 00:16:20.460
So overall, Native Client is
looking for a variety of

00:16:20.460 --> 00:16:24.250
instructions that wants to say
either don't run the program,

00:16:24.250 --> 00:16:27.780
or overwrite this to be
sure that we're safe.

00:16:27.780 --> 00:16:29.720
So how do we find these
instructions?

00:16:29.720 --> 00:16:32.290
That's the crucial step.

00:16:32.290 --> 00:16:34.250
So previously, I said it's
a stream of bytes.

00:16:34.250 --> 00:16:35.630
And you're taking chunks
out of the stream of

00:16:35.630 --> 00:16:36.440
bytes as you go.

00:16:36.440 --> 00:16:39.630
And that's nice until you
realize that you aren't just

00:16:39.630 --> 00:16:41.070
going in one direction.

00:16:41.070 --> 00:16:43.050
You can occasionally hit
a jump that'll take you

00:16:43.050 --> 00:16:44.680
somewhere else in
the execution.

00:16:44.680 --> 00:16:46.010
And it could be an
arbitrary byte.

00:16:46.010 --> 00:16:47.330
So there's two classes
of jumps we're

00:16:47.330 --> 00:16:48.150
going to deal with.

00:16:48.150 --> 00:16:51.110
One is direct jumps, jumps where
you know the address

00:16:51.110 --> 00:16:53.830
that you're going to, and
indirect jumps, where your

00:16:53.830 --> 00:16:56.620
address is calculated from data,
and you may not know

00:16:56.620 --> 00:16:59.480
exactly where you're
going upfront.

00:16:59.480 --> 00:17:02.530
So here's an example of a
problematic direct jump.

00:17:02.530 --> 00:17:04.270
So two instructions here.

00:17:04.270 --> 00:17:08.890
The first instruction loads a
constant into a register.

00:17:08.890 --> 00:17:11.770
Now, this is a strange constant,
but we'll assume the

00:17:11.770 --> 00:17:13.710
programmer knows what they're
doing, and they have some

00:17:13.710 --> 00:17:15.790
reason for that constant.

00:17:15.790 --> 00:17:20.920
And then the next instruction
jumps backwards 4 bytes.

00:17:20.920 --> 00:17:24.020
So on the surface, this
should be OK.

00:17:24.020 --> 00:17:26.230
But the fundamental problem is
that the move instruction

00:17:26.230 --> 00:17:30.130
right before the jump backwards
is 5 bytes.

00:17:30.130 --> 00:17:32.890
So you're actually jumping back
into the middle of the

00:17:32.890 --> 00:17:34.820
move instruction.

00:17:34.820 --> 00:17:37.790
So if we look at how the
processor sees this instead of

00:17:37.790 --> 00:17:42.280
how our human eyes see the
assembly instruction, it first

00:17:42.280 --> 00:17:45.490
sees the byte b8 and says, oh,
b8, that's a move constant

00:17:45.490 --> 00:17:47.610
into eax instruction.

00:17:47.610 --> 00:17:50.130
And then there's going to be
4 bytes following it, which

00:17:50.130 --> 00:17:51.080
define a constant.

00:17:51.080 --> 00:17:53.420
So it happily pulls out the
constant, moves in the

00:17:53.420 --> 00:17:55.020
register, goes on.

00:17:55.020 --> 00:17:58.070
Then it says, oh, there's a
jump backwards 4 bytes.

00:17:58.070 --> 00:18:00.730
It's actually a jump backwards 6
bytes, because the processor

00:18:00.730 --> 00:18:03.250
calculates from the end of the
instruction, whereas the

00:18:03.250 --> 00:18:05.660
assembly language calculates
from the beginning.

00:18:05.660 --> 00:18:06.940
Just a detail, but
some people may

00:18:06.940 --> 00:18:08.260
find it a little confusing.

00:18:08.260 --> 00:18:11.520
So you jump backwards 4 bytes,
and then the processor happily

00:18:11.520 --> 00:18:13.780
starts executing what
it previously

00:18:13.780 --> 00:18:15.610
treated as a constant.

00:18:15.610 --> 00:18:18.070
So it says oh, 0f 05.

00:18:18.070 --> 00:18:18.850
Hey, that's a syscall.

00:18:18.850 --> 00:18:20.170
Let me do a syscall.

00:18:20.170 --> 00:18:21.880
And then suddenly, you don't.

00:18:21.880 --> 00:18:24.650
And then it sees a jump, which
nicely takes you out past the

00:18:24.650 --> 00:18:27.460
previous jump, and you go on
with your normal execution.

00:18:27.460 --> 00:18:30.870
So in one single instruction,
we managed to smuggle in two

00:18:30.870 --> 00:18:32.860
additional instructions,
which just entirely

00:18:32.860 --> 00:18:34.670
compromised your system.

00:18:34.670 --> 00:18:36.720
So Native Client doesn't
play this game.

00:18:36.720 --> 00:18:39.760
If it ever detects a program
trying to jump into what it

00:18:39.760 --> 00:18:42.820
previously thought was an
instruction, it says I'm not

00:18:42.820 --> 00:18:43.590
going to run this program.

00:18:43.590 --> 00:18:44.450
I'm not going to touch it.

00:18:44.450 --> 00:18:46.450
Obviously, you're doing
something sketchy.

00:18:46.450 --> 00:18:50.940
So if you generate code like
this, we don't run it.

00:18:50.940 --> 00:18:52.870
The other class of jumps
are indirect jumps.

00:18:52.870 --> 00:18:54.290
These are a little harder.

00:18:54.290 --> 00:18:56.450
Because you don't know exactly
where you're going.

00:18:56.450 --> 00:18:58.630
So how do we tell if we're
jumping inside an

00:18:58.630 --> 00:19:00.860
instruction or not?

00:19:00.860 --> 00:19:03.930
So this is a C example of where
indirect jumps come in.

00:19:03.930 --> 00:19:05.610
You take a function pointer.

00:19:05.610 --> 00:19:07.720
You call the function pointer.

00:19:07.720 --> 00:19:11.580
So if you look at the assembly
language, this is very

00:19:11.580 --> 00:19:12.700
simplified, assuming
you have an

00:19:12.700 --> 00:19:14.720
aggressive optimizing compiler.

00:19:14.720 --> 00:19:18.200
You do a direct call to a known
address, which we don't

00:19:18.200 --> 00:19:18.990
know what it is.

00:19:18.990 --> 00:19:20.700
So it's not fully
disassembled.

00:19:20.700 --> 00:19:23.550
And then the return value ends
up in rax, the register.

00:19:23.550 --> 00:19:27.330
And then you say, yeah, just
call that, whatever it is.

00:19:27.330 --> 00:19:29.100
So if we were being aggressive,
we could do some

00:19:29.100 --> 00:19:31.540
deep analysis, try to figure
out what the pointer could

00:19:31.540 --> 00:19:32.570
possibly point to.

00:19:32.570 --> 00:19:33.390
But that's hard.

00:19:33.390 --> 00:19:34.570
That's expensive.

00:19:34.570 --> 00:19:37.290
So instead, a much simpler
thing to do is look at

00:19:37.290 --> 00:19:40.400
individual instructions and
say can we infer from the

00:19:40.400 --> 00:19:42.370
sequence if what we're
doing is safe?

00:19:42.370 --> 00:19:45.740
So what we're saying is that
this function pointer could be

00:19:45.740 --> 00:19:47.680
a random number for
all we care.

00:19:47.680 --> 00:19:50.375
Can we make jumping to
a random number safe?

00:19:50.375 --> 00:19:53.490
Can we make sure that jumping to
a random number doesn't get

00:19:53.490 --> 00:19:56.640
us inside an instruction?

00:19:56.640 --> 00:19:59.400
So the first step, which may not
make sense until you see

00:19:59.400 --> 00:20:03.360
the second step, is any pointer,
any function pointer,

00:20:03.360 --> 00:20:05.690
any instruction pointer that
we're going to jump to, we

00:20:05.690 --> 00:20:08.350
first put a mask on it.

00:20:08.350 --> 00:20:11.140
And that mask says, drop
the lower 5 bits.

00:20:11.140 --> 00:20:13.950
Set the lower 5 bits to 0.

00:20:13.950 --> 00:20:15.430
So how does this help us out?

00:20:15.430 --> 00:20:17.570
What it means is that instead
of being able to jump

00:20:17.570 --> 00:20:23.950
anywhere, we can instead jump
to every 32 bytes, 1/32 of

00:20:23.950 --> 00:20:24.430
everywhere.

00:20:24.430 --> 00:20:26.690
And this isn't immediately
obvious how it

00:20:26.690 --> 00:20:28.040
improves our lives.

00:20:28.040 --> 00:20:30.440
But we modified a
compiler, right?

00:20:30.440 --> 00:20:33.450
So we can tell the compiler
that instead of having

00:20:33.450 --> 00:20:37.310
instructions that could move
over or lap over the 32-byte

00:20:37.310 --> 00:20:39.960
boundaries, any time you would
potentially omit an

00:20:39.960 --> 00:20:42.910
instruction that overlaps the
boundary, nudge it down a

00:20:42.910 --> 00:20:43.590
little bit.

00:20:43.590 --> 00:20:46.200
Stick in extra operations
that do nothing.

00:20:46.200 --> 00:20:48.990
And then we know that any time
you do an indirect jump to a

00:20:48.990 --> 00:20:51.600
32-byte boundary, you will be
hitting the start of an

00:20:51.600 --> 00:20:55.010
instruction instead of the
middle of an instruction.

00:20:55.010 --> 00:20:58.440
So the mask allows you to jump
to known safe locations, even

00:20:58.440 --> 00:21:01.570
if you don't know what
those locations are.

00:21:01.570 --> 00:21:03.110
Here's a more concrete
example.

00:21:03.110 --> 00:21:05.660
Here is that funky move again
with that constant.

00:21:05.660 --> 00:21:08.730
And if you generated it so that
it overlapped the 32-byte

00:21:08.730 --> 00:21:11.060
boundary, an indirect
jump could again

00:21:11.060 --> 00:21:12.420
execute this syscall.

00:21:12.420 --> 00:21:18.270
Because it would go to a mov 32
address, see the 0f 05, and

00:21:18.270 --> 00:21:20.230
boom, there goes your
tax return.

00:21:20.230 --> 00:21:24.720
So instead, the validation
algorithm require would reject

00:21:24.720 --> 00:21:26.780
this, because it overlaps
the boundary.

00:21:26.780 --> 00:21:29.440
Instead the compiler would
generate this extra

00:21:29.440 --> 00:21:32.420
no-operation and move the
instruction down.

00:21:32.420 --> 00:21:35.030
So the combination of not
allowing direct jumps inside

00:21:35.030 --> 00:21:37.590
that instruction and making
sure that no instructions

00:21:37.590 --> 00:21:40.610
overlap 32-byte boundaries allow
you to know where all

00:21:40.610 --> 00:21:44.650
the control flow in your
program is going.

00:21:44.650 --> 00:21:46.600
Aha, you say, but I'm
a clever hacker.

00:21:46.600 --> 00:21:48.750
I can modify the code after
you validate it.

00:21:48.750 --> 00:21:51.500
So validation just happens
at the beginning.

00:21:51.500 --> 00:21:53.460
We say, we'll look
at the code.

00:21:53.460 --> 00:21:56.820
If it's good to go, we'll
let you run the code.

00:21:56.820 --> 00:21:59.900
So, to prevent code
modification, we say any time

00:21:59.900 --> 00:22:02.480
we have a chunk of data, which
represents code, it's going to

00:22:02.480 --> 00:22:05.830
be readable and executable
when you don't have the

00:22:05.830 --> 00:22:07.510
permissions to write it.

00:22:07.510 --> 00:22:09.850
So everything that goes through
the validator, once we

00:22:09.850 --> 00:22:12.430
know what it does, we make sure
it keeps doing what we

00:22:12.430 --> 00:22:14.390
know it does.

00:22:14.390 --> 00:22:15.360
Aha, you say.

00:22:15.360 --> 00:22:17.110
But what about things
that aren't code?

00:22:17.110 --> 00:22:20.200
So I can just do a buffer
overflow somewhere, jump to

00:22:20.200 --> 00:22:23.120
that buffer overflow, start
executing it, and I just

00:22:23.120 --> 00:22:24.950
executed code you haven't
validated.

00:22:24.950 --> 00:22:28.580
Well, again, every piece of data
we make sure can be read

00:22:28.580 --> 00:22:31.360
and written, but not executed.

00:22:31.360 --> 00:22:34.450
So this plugs the hole for
self-modifying code.

00:22:34.450 --> 00:22:35.930
So I just lied to you.

00:22:35.930 --> 00:22:39.840
And that's that things can
change after the initial setup

00:22:39.840 --> 00:22:40.410
of the program.

00:22:40.410 --> 00:22:42.390
So you can load dynamic
libraries.

00:22:42.390 --> 00:22:45.270
You can have just-in-time
compilers which emit new code

00:22:45.270 --> 00:22:48.030
and actually modify the code
in very controlled ways.

00:22:48.030 --> 00:22:50.360
But how you do that is
kind of complicated.

00:22:50.360 --> 00:22:52.320
Because you need to make sure
that if there's multiple

00:22:52.320 --> 00:22:56.340
threads, you never get memory
de-coherency, where you

00:22:56.340 --> 00:22:57.980
execute an instruction
which is in the

00:22:57.980 --> 00:22:59.930
middle of being modified.

00:22:59.930 --> 00:23:01.980
At the end of this presentation,
I'll have a link

00:23:01.980 --> 00:23:02.880
to the research papers.

00:23:02.880 --> 00:23:05.810
So if you're really interested
in how we do memory safe code

00:23:05.810 --> 00:23:08.110
modification, you can read
up or ask me afterwards.

00:23:08.110 --> 00:23:10.640
But for this presentation, we're
going to ignore this

00:23:10.640 --> 00:23:13.640
rather large, ugly issue.

00:23:13.640 --> 00:23:18.370
Another thing is that mprotect
is now security-critical.

00:23:18.370 --> 00:23:21.250
So syscalls, we've thought about
all the damage we could

00:23:21.250 --> 00:23:22.150
do with them.

00:23:22.150 --> 00:23:24.930
But now we can start doing
indirect damage like

00:23:24.930 --> 00:23:27.860
unprotecting a page, writing it,
then boom, we're executing

00:23:27.860 --> 00:23:30.260
code that is invalid.

00:23:30.260 --> 00:23:33.440
Similarly, there's other
syscalls like GetProcessID,

00:23:33.440 --> 00:23:35.690
not immediately obvious why
they're dangerous, but they

00:23:35.690 --> 00:23:38.370
can be used to escalate attacks
by knowing where

00:23:38.370 --> 00:23:39.270
you're going from.

00:23:39.270 --> 00:23:41.720
So the name of the game is
white-listing, only allowing

00:23:41.720 --> 00:23:44.805
functionality we know is safe
instead of saying, eh, do a

00:23:44.805 --> 00:23:46.055
syscall , whatever.

00:23:48.210 --> 00:23:51.330
So that's the basics of how we
allow code to be decompiled.

00:23:51.330 --> 00:23:54.280
And if you actually start
looking at how this affects

00:23:54.280 --> 00:23:55.850
calling and returning a
function, there's some

00:23:55.850 --> 00:23:57.890
interesting things that
get shaken out.

00:23:57.890 --> 00:23:59.270
So I'm going to do
in the reverse.

00:23:59.270 --> 00:24:01.450
I'm going to show how you
return from a function.

00:24:01.450 --> 00:24:03.880
Then I'm going to show how you
call it, because the return

00:24:03.880 --> 00:24:05.130
impacts the call.

00:24:07.460 --> 00:24:09.360
So usually, returning from
a function is a single

00:24:09.360 --> 00:24:10.400
instruction.

00:24:10.400 --> 00:24:14.980
Return, pop an address off the
stack, jumps to that address,

00:24:14.980 --> 00:24:17.230
and you're back to where
you called from.

00:24:17.230 --> 00:24:20.120
So you could call the same
function for multiple places.

00:24:20.120 --> 00:24:23.190
So the call records where you
called from on the stack in

00:24:23.190 --> 00:24:24.800
order to be able to
return to it.

00:24:24.800 --> 00:24:29.040
But implicitly, this is
an indirect jump.

00:24:29.040 --> 00:24:32.400
So a malicious program could
stick a random number on the

00:24:32.400 --> 00:24:35.870
stack and then jump instead of
calling to the function.

00:24:35.870 --> 00:24:37.940
And then when the function
returned, who

00:24:37.940 --> 00:24:39.090
knows where you are.

00:24:39.090 --> 00:24:41.290
So there is a type of exploit
called return-oriented

00:24:41.290 --> 00:24:44.710
programming, which uses this
kind of thing where the

00:24:44.710 --> 00:24:46.695
returns can be repurposed
for jumping

00:24:46.695 --> 00:24:48.890
to arbitrary locations.

00:24:48.890 --> 00:24:50.550
So we can try to fix this.

00:24:50.550 --> 00:24:54.200
We can manually pop the return
address off the stack, mask

00:24:54.200 --> 00:24:56.980
it, just like we should for
indirect jumps, push it back

00:24:56.980 --> 00:24:58.860
on the stack, and then return.

00:24:58.860 --> 00:24:59.950
So problem solved.

00:24:59.950 --> 00:25:01.230
Well, no.

00:25:01.230 --> 00:25:02.490
I mentioned threads earlier.

00:25:02.490 --> 00:25:04.840
And threads are a big problem
because there could be another

00:25:04.840 --> 00:25:07.520
thread in the background trying
to smash the stack.

00:25:07.520 --> 00:25:10.700
And so between the moment where
you push the address on

00:25:10.700 --> 00:25:14.180
the stack and when you return,
the memory could get changed

00:25:14.180 --> 00:25:16.880
out from under you, and you
could end up anywhere.

00:25:16.880 --> 00:25:17.920
Who knows where?

00:25:17.920 --> 00:25:20.760
So we can't really trust any
addresses in memory.

00:25:20.760 --> 00:25:23.180
We can only trust addresses
in registers.

00:25:23.180 --> 00:25:26.090
So what this means is that in
order to return, we can't use

00:25:26.090 --> 00:25:27.230
the return instruction.

00:25:27.230 --> 00:25:31.090
We pop off the stack, mask it,
and then jump to the address.

00:25:31.090 --> 00:25:33.900
This has a few consequences,
like branch prediction is a

00:25:33.900 --> 00:25:34.980
little harder.

00:25:34.980 --> 00:25:38.480
And we're using more bytes
to do the same operation.

00:25:38.480 --> 00:25:41.870
So I mentioned earlier that
the sandboxing schemes for

00:25:41.870 --> 00:25:43.670
different architectures
were different.

00:25:43.670 --> 00:25:45.870
And this is largely due to the
fact that we are trying to

00:25:45.870 --> 00:25:49.940
minimize the cost and tailor
it to each architecture.

00:25:49.940 --> 00:25:52.850
So we try to keep the number
of bytes per sandbox

00:25:52.850 --> 00:25:55.640
instruction as low as possible
through being horrendously

00:25:55.640 --> 00:25:57.570
clever about how
we mask things.

00:25:57.570 --> 00:25:59.745
And if you want to talk about
this, again, we can talk about

00:25:59.745 --> 00:26:02.640
it afterwards, about clever
instruction encodings.

00:26:02.640 --> 00:26:03.840
So return.

00:26:03.840 --> 00:26:06.940
A very basic instruction is
actually dangerous because

00:26:06.940 --> 00:26:13.680
it's doing an indirect jump
to a location from memory.

00:26:13.680 --> 00:26:15.060
So bad idea.

00:26:15.060 --> 00:26:18.280
We have to do it explicitly.

00:26:18.280 --> 00:26:23.580
So whenever we have masks, it
becomes critical that we don't

00:26:23.580 --> 00:26:25.690
bypass the mask.

00:26:25.690 --> 00:26:28.930
So we may have two instructions,
the mask and

00:26:28.930 --> 00:26:29.990
then the jump.

00:26:29.990 --> 00:26:32.010
But if there's some other jump
which goes between the

00:26:32.010 --> 00:26:34.400
instructions, it doesn't
actually violate what I talked

00:26:34.400 --> 00:26:35.620
about previously.

00:26:35.620 --> 00:26:38.020
I said you can't jump
into an instruction.

00:26:38.020 --> 00:26:40.350
But if you jump between these
two instructions that are

00:26:40.350 --> 00:26:42.050
critical for safety,
suddenly you just

00:26:42.050 --> 00:26:42.970
stripped off the mask.

00:26:42.970 --> 00:26:44.900
The entire security
model fails.

00:26:44.900 --> 00:26:47.270
And you have a problem.

00:26:47.270 --> 00:26:48.780
We call these
pseudo-instructions.

00:26:48.780 --> 00:26:50.880
So whenever we have a sequence
of instructions which is

00:26:50.880 --> 00:26:53.760
security critical, we say treat
it just like it was an

00:26:53.760 --> 00:26:54.870
instruction.

00:26:54.870 --> 00:26:58.480
So direct jumps cannot jump
inside a pseudo-instruction.

00:26:58.480 --> 00:27:01.150
Indirect jumps cannot jump
inside a pseudo-instruction,

00:27:01.150 --> 00:27:04.580
which means that the entire
pseudo-instruction has to not

00:27:04.580 --> 00:27:09.220
cross a 32-byte boundary.

00:27:09.220 --> 00:27:12.990
As a terminology, we
call this bundling.

00:27:12.990 --> 00:27:18.960
So what does this mean for
calling a function?

00:27:18.960 --> 00:27:21.590
If you just call it like you
expected, just from the middle

00:27:21.590 --> 00:27:25.320
of a bundle somewhere,
you do the call.

00:27:25.320 --> 00:27:26.180
You know, you see
the mask here.

00:27:26.180 --> 00:27:27.910
You see the indirect jump.

00:27:27.910 --> 00:27:29.630
And then where do
you return to?

00:27:29.630 --> 00:27:32.690
The problem is that the mask
drops the lower 5 bits of the

00:27:32.690 --> 00:27:36.230
address, so you aren't returning
to the address that

00:27:36.230 --> 00:27:38.800
was pushed on the stack
if those lower bits

00:27:38.800 --> 00:27:40.430
were not all zeroes.

00:27:40.430 --> 00:27:44.800
So you end up returning to the
beginning of the bundle where

00:27:44.800 --> 00:27:45.850
the call was from.

00:27:45.850 --> 00:27:47.420
And this is obviously
not what you want.

00:27:47.420 --> 00:27:49.840
This starts to look a bit like
an infinite loop unless you

00:27:49.840 --> 00:27:50.710
account for it.

00:27:50.710 --> 00:27:52.790
Where you really want it to
return is immediately after

00:27:52.790 --> 00:27:53.950
the instruction.

00:27:53.950 --> 00:27:58.630
So the work-around for this is
that whenever you have a call,

00:27:58.630 --> 00:28:01.510
you pat it down to the very
end of the bundle.

00:28:01.510 --> 00:28:05.020
And this means that the return
address is at the beginning of

00:28:05.020 --> 00:28:06.500
the very next bundle.

00:28:06.500 --> 00:28:09.150
So when you mask it, when you
drop the lower 5 bits, it

00:28:09.150 --> 00:28:11.190
doesn't change it at all.

00:28:11.190 --> 00:28:16.130
So all these instruction
sequences that we're showing

00:28:16.130 --> 00:28:19.860
in fact should not change the
correctness of the program.

00:28:19.860 --> 00:28:23.030
They are simply there for the
validator to say, oh, yep, I

00:28:23.030 --> 00:28:24.600
can prove that this is safe.

00:28:24.600 --> 00:28:27.870
And if somehow garbage data gets
in here, I know that I'm

00:28:27.870 --> 00:28:29.500
going to be jumping
to a known place.

00:28:29.500 --> 00:28:32.420
But in normal operation, the
compiler will stick everything

00:28:32.420 --> 00:28:35.490
on 32-byte aligned boundaries
that we need to jump to

00:28:35.490 --> 00:28:36.740
indirectly.

00:28:39.590 --> 00:28:41.860
OK, so yet again, I lied.

00:28:41.860 --> 00:28:43.480
I seem to be a serial
liar here.

00:28:43.480 --> 00:28:46.090
I apologize.

00:28:46.090 --> 00:28:48.020
There's more going on
in the process than

00:28:48.020 --> 00:28:49.210
just this bit of code.

00:28:49.210 --> 00:28:52.130
We can validate a lot of code,
but as it turns out, there's

00:28:52.130 --> 00:28:54.090
other code and data in
the process that

00:28:54.090 --> 00:28:55.730
we don't fully control.

00:28:55.730 --> 00:28:58.210
It needs to be there
so we can use it.

00:28:58.210 --> 00:29:02.120
So we have a world where we
have a single process with

00:29:02.120 --> 00:29:05.540
code we don't trust and
code that we do trust.

00:29:05.540 --> 00:29:10.130
So this is the general view
of what I've shown so far.

00:29:10.130 --> 00:29:12.410
There's untrusted code
and untrusted data.

00:29:12.410 --> 00:29:15.280
And what I mean by untrusted
is this code is coming from

00:29:15.280 --> 00:29:17.040
somewhere across the wire.

00:29:17.040 --> 00:29:20.310
And instead of having to have
this dialog box that says,

00:29:20.310 --> 00:29:21.730
well, you're running
at your own risk.

00:29:21.730 --> 00:29:23.280
Instead, we validate it.

00:29:23.280 --> 00:29:25.000
And then we say this conforms
to our rules.

00:29:25.000 --> 00:29:27.970
So we'll run it without having
to place trust in it.

00:29:27.970 --> 00:29:31.960
We will enforce the security
instead of trusting, so

00:29:31.960 --> 00:29:34.850
untrusted code, untrusted
data.

00:29:34.850 --> 00:29:38.130
Well, every time you launch a
process, the operating system

00:29:38.130 --> 00:29:40.100
likes to stick in some code.

00:29:40.100 --> 00:29:42.510
So you can talk with the
operating system.

00:29:42.510 --> 00:29:44.870
And we could do something really
nasty, like try to

00:29:44.870 --> 00:29:46.540
overwrite this, kick it out.

00:29:46.540 --> 00:29:48.430
But we're going to need
it eventually.

00:29:48.430 --> 00:29:50.220
We're going to need
to do something.

00:29:50.220 --> 00:29:52.540
Simply living within the
sandbox isn't enough.

00:29:52.540 --> 00:29:56.310
So down the road, we're going
to need to talk to the NTDLL

00:29:56.310 --> 00:29:58.210
on Windows, for instance.

00:29:58.210 --> 00:30:01.390
But we don't want the untrusted
code to do it.

00:30:01.390 --> 00:30:03.590
Similarly, we're going to be
talking with a web browser.

00:30:03.590 --> 00:30:07.220
So the easiest way to do this
is load the DLL for the web

00:30:07.220 --> 00:30:08.700
browser in the process.

00:30:08.700 --> 00:30:11.120
So we can call the same
functionality to talk between

00:30:11.120 --> 00:30:13.690
processes that Chrome uses.

00:30:13.690 --> 00:30:15.380
There's also trusted data.

00:30:15.380 --> 00:30:18.580
So when we're running the
sandbox, we have to keep track

00:30:18.580 --> 00:30:20.590
of things like where
code is mapped.

00:30:20.590 --> 00:30:24.110
Because if the untrusted code
says, well, there's actually

00:30:24.110 --> 00:30:26.540
no code there, so why don't
you map code there again?

00:30:26.540 --> 00:30:28.360
Then we could get weird
overwrites, partial

00:30:28.360 --> 00:30:29.340
instructions.

00:30:29.340 --> 00:30:30.470
So there's bookkeeping data.

00:30:30.470 --> 00:30:33.040
And if you could clobber that
data, if you could go there

00:30:33.040 --> 00:30:35.940
and say overwrite the table
for where all the code is,

00:30:35.940 --> 00:30:37.600
then the untrusted code
could start doing,

00:30:37.600 --> 00:30:40.740
again, very bad things.

00:30:40.740 --> 00:30:44.650
What we need to do is we need to
make sure all the execution

00:30:44.650 --> 00:30:47.860
and all the data access that
can be done directly by the

00:30:47.860 --> 00:30:52.040
untrusted code only happens
within a confined region that

00:30:52.040 --> 00:30:55.370
doesn't include NTDLL, that
doesn't include Chrome DLL,

00:30:55.370 --> 00:30:58.700
that doesn't include any bit of
code or data which could be

00:30:58.700 --> 00:31:00.850
used as an exploit.

00:31:00.850 --> 00:31:05.010
So on 64-bit systems, this is a
4-gigabyte range of memory.

00:31:05.010 --> 00:31:08.190
And we reserve one of the
registers, R15, to point to

00:31:08.190 --> 00:31:10.530
the bottom of this range.

00:31:10.530 --> 00:31:12.790
So one of our security-critical
properties

00:31:12.790 --> 00:31:15.330
is that R15 cannot
be overwritten by

00:31:15.330 --> 00:31:16.510
the entrusted code.

00:31:16.510 --> 00:31:18.610
So as the validator goes
through, it looks for anything

00:31:18.610 --> 00:31:20.310
that can modify R15.

00:31:20.310 --> 00:31:23.020
And if something does, it
goes, nope, not going

00:31:23.020 --> 00:31:24.900
to deal with it.

00:31:24.900 --> 00:31:27.020
A thing you may note also is
that this is a 4-gigabyte

00:31:27.020 --> 00:31:30.850
range, which happens to be 2 of
32, which allows us to do

00:31:30.850 --> 00:31:33.820
some horrendously clever stuff
to make our masking as small

00:31:33.820 --> 00:31:34.260
as possible.

00:31:34.260 --> 00:31:37.130
We'll get into that
in a second.

00:31:37.130 --> 00:31:39.330
So here's a scenario that
we have to worry about.

00:31:39.330 --> 00:31:41.740
What happens when the untrusted
code tries to jump

00:31:41.740 --> 00:31:43.790
outside the sandbox?

00:31:43.790 --> 00:31:47.010
So it can't do a direct jump
outside this constrained

00:31:47.010 --> 00:31:50.870
range, because the validator
can't see the target.

00:31:50.870 --> 00:31:53.180
And because it can't see the
target, it can't tell whether

00:31:53.180 --> 00:31:55.770
it's in the middle of an
instruction, so it says, no.

00:31:55.770 --> 00:31:58.140
But it could do an
indirect jump.

00:31:58.140 --> 00:32:00.840
So it could do an indirect
jump to a 32-byte aligned

00:32:00.840 --> 00:32:02.610
boundary somewhere in NTDLL.

00:32:02.610 --> 00:32:04.390
And we have to allow this,
because you could be loading

00:32:04.390 --> 00:32:05.470
shared libraries.

00:32:05.470 --> 00:32:08.630
So you may not know where the
code is before you load it.

00:32:08.630 --> 00:32:11.120
So what we have to do is we have
to make sure the indirect

00:32:11.120 --> 00:32:14.460
jumps only fall within this
constrained range.

00:32:14.460 --> 00:32:16.870
So how do we do that?

00:32:16.870 --> 00:32:20.010
We have to confine the jumps
to the 4-gigabyte range.

00:32:20.010 --> 00:32:20.800
Here's an example.

00:32:20.800 --> 00:32:22.070
It's just an empty function.

00:32:22.070 --> 00:32:24.390
What's happening implicitly
here, however,

00:32:24.390 --> 00:32:25.690
is that it's returning.

00:32:25.690 --> 00:32:28.710
And as we went through all these
explanations, this is

00:32:28.710 --> 00:32:30.510
what a return eventually
looks like.

00:32:30.510 --> 00:32:33.060
There's this masked indirect
jump back to

00:32:33.060 --> 00:32:34.700
wherever you came from.

00:32:34.700 --> 00:32:37.200
But this could go into NTDLL.

00:32:37.200 --> 00:32:39.400
How do we fix it?

00:32:39.400 --> 00:32:43.280
So we confine it by masking
it and dropping

00:32:43.280 --> 00:32:45.190
the upper 32 bits.

00:32:45.190 --> 00:32:47.820
So we boil it down to
a 32-bit address.

00:32:47.820 --> 00:32:49.350
Then we add the offset.

00:32:49.350 --> 00:32:51.370
And then we actually use that.

00:32:51.370 --> 00:32:53.690
So remember I was saying
horrendously clever?

00:32:53.690 --> 00:32:55.960
This is not really
self-promotion.

00:32:55.960 --> 00:32:57.760
When I was doing this
presentation, I had to work

00:32:57.760 --> 00:33:00.000
through exactly how these
instructions worked.

00:33:00.000 --> 00:33:01.250
It's actually pretty
interesting.

00:33:01.250 --> 00:33:04.240
So the "and" right here
is doing a 32-bit

00:33:04.240 --> 00:33:05.580
operation on a register.

00:33:05.580 --> 00:33:09.890
And then later the register is
being used as a 64-bit value.

00:33:09.890 --> 00:33:12.550
So doing the 32-bit operation
implicitly

00:33:12.550 --> 00:33:14.700
zeroes the upper bits.

00:33:14.700 --> 00:33:17.970
And this allows the actual "and"
to be packed down into a

00:33:17.970 --> 00:33:19.720
single byte data.

00:33:19.720 --> 00:33:22.740
So it says, it's going to
be e0 sign extended.

00:33:22.740 --> 00:33:25.220
And then I'll implicitly drop
the upper 32 bits, because

00:33:25.220 --> 00:33:26.740
it's a 32-bit operation.

00:33:26.740 --> 00:33:30.600
Then you do a full 64-bit add
and a full 64-bit jump.

00:33:30.600 --> 00:33:34.300
So the cost of this is about
8 bytes as opposed 2 bytes.

00:33:34.300 --> 00:33:36.540
So there's a bit of overhead for
doing it this way, but we

00:33:36.540 --> 00:33:37.640
know where it's going.

00:33:37.640 --> 00:33:39.790
We know it's only going to be
within the confined region.

00:33:39.790 --> 00:33:42.640
And we know it's only going to
be to a 32-byte boundary.

00:33:42.640 --> 00:33:44.970
And we know there's going to
be no instructions that are

00:33:44.970 --> 00:33:47.930
overlapping those 32-byte
boundaries.

00:33:47.930 --> 00:33:51.090
The next thing to worry about is
reading and writing bits of

00:33:51.090 --> 00:33:54.800
data that are outside
this confined range.

00:33:54.800 --> 00:33:56.950
Writing is obviously
a problem.

00:33:56.950 --> 00:33:58.500
If you can write to something,
you can change it.

00:33:58.500 --> 00:33:59.610
You can control it.

00:33:59.610 --> 00:34:02.020
It makes attacks much easier.

00:34:02.020 --> 00:34:07.060
Reading, debatably it's not an
attack, but this can be used

00:34:07.060 --> 00:34:09.060
to help attacks.

00:34:09.060 --> 00:34:11.420
So if you can poke around
memory, find where things are,

00:34:11.420 --> 00:34:14.460
then you can do much more
controlled jumps, much more

00:34:14.460 --> 00:34:17.080
dangerous intended
actions than just

00:34:17.080 --> 00:34:19.860
jumping around randomly.

00:34:19.860 --> 00:34:22.790
So how do we confine
data access?

00:34:22.790 --> 00:34:24.540
Here's an example
of a C function.

00:34:24.540 --> 00:34:27.239
We're just taking a function
pointer, and we're writing a

00:34:27.239 --> 00:34:30.510
constant to that pointer
wherever it may be.

00:34:30.510 --> 00:34:32.030
Thus far, we haven't
talked about

00:34:32.030 --> 00:34:34.219
sandboxing rights at all.

00:34:34.219 --> 00:34:37.000
So the Intel instruction for
doing this just says move this

00:34:37.000 --> 00:34:40.210
constant to wherever the memory
address points to.

00:34:40.210 --> 00:34:43.489
So to sandbox it, we do
something similar to jumps.

00:34:43.489 --> 00:34:47.820
We mask it by moving a 32-bit
register to itself.

00:34:47.820 --> 00:34:50.530
So again, we rely on the
implicit zeroing

00:34:50.530 --> 00:34:51.370
of the upper bits.

00:34:51.370 --> 00:34:53.980
But since we don't need to
discard the lower bits, it's

00:34:53.980 --> 00:34:55.000
just a move.

00:34:55.000 --> 00:34:56.690
Simple enough.

00:34:56.690 --> 00:35:00.750
And then we do a complicated
addressing mode, which

00:35:00.750 --> 00:35:06.190
actually adds R15 simultaneously
with moving the

00:35:06.190 --> 00:35:08.500
constant to the address
that's computed.

00:35:08.500 --> 00:35:13.270
So this move instruction is
saying add R15 to rax and then

00:35:13.270 --> 00:35:16.830
multiply rax by 1,
and there you go.

00:35:16.830 --> 00:35:20.380
Instead of 5 bytes to do this
move constant, we got 9 bytes.

00:35:20.380 --> 00:35:22.360
Not too bad.

00:35:22.360 --> 00:35:23.820
There's a little curious
thing here, though.

00:35:23.820 --> 00:35:26.030
There's that multiplier.

00:35:26.030 --> 00:35:28.860
So we know that rax is a
32-bit value, but that

00:35:28.860 --> 00:35:30.960
multiplier can be up to 8.

00:35:30.960 --> 00:35:33.740
So we aren't actually operating
within a 4-gigabyte

00:35:33.740 --> 00:35:36.180
range, we're potentially
doing a write

00:35:36.180 --> 00:35:38.960
to 8 times 4 gigabytes?

00:35:38.960 --> 00:35:41.170
And there's ways you can rack
it up even further with

00:35:41.170 --> 00:35:42.440
constant offsets.

00:35:42.440 --> 00:35:47.600
So we could tweak this a little
harder and do the mask

00:35:47.600 --> 00:35:50.070
and get rid of the
multiplications, but sometimes

00:35:50.070 --> 00:35:51.880
compilers just like
to generate these.

00:35:51.880 --> 00:35:54.340
And the more features you get
rid of, the slower the code's

00:35:54.340 --> 00:35:55.660
going to be.

00:35:55.660 --> 00:35:58.570
So instead of trying to do
instruction sequences that are

00:35:58.570 --> 00:36:04.480
safer, we actually say, well,
40 to 44 gigabytes on either

00:36:04.480 --> 00:36:08.580
side of this confined range,
we're going to mark as--

00:36:08.580 --> 00:36:09.680
we own it.

00:36:09.680 --> 00:36:11.080
So you can't use it.

00:36:11.080 --> 00:36:13.420
So you aren't actually
allocating the memory.

00:36:13.420 --> 00:36:17.840
You're just marking it as no one
gets this memory but us.

00:36:17.840 --> 00:36:19.590
And it's illegal to read.

00:36:19.590 --> 00:36:20.550
It's illegal to write.

00:36:20.550 --> 00:36:21.770
It's illegal to jump to.

00:36:21.770 --> 00:36:23.540
It doesn't exist.

00:36:23.540 --> 00:36:28.170
So if you can do a memory access
which is outside this

00:36:28.170 --> 00:36:31.720
4-gigabyte range, you get caught
by the guard region.

00:36:31.720 --> 00:36:34.420
And that's how we allow these
addressing modes.

00:36:34.420 --> 00:36:37.100
And just as a funny side note,
sometimes we get people

00:36:37.100 --> 00:36:40.010
benchmarking Native Client
and say, you take over 80

00:36:40.010 --> 00:36:41.820
gigabytes of memory!

00:36:41.820 --> 00:36:45.190
And we're like, do you have over
80 gigabytes of memory?

00:36:45.190 --> 00:36:46.710
But really what they're looking
at is they're looking

00:36:46.710 --> 00:36:50.900
at address space usage rather
than actual memory usage.

00:36:53.590 --> 00:36:56.170
So we can't do anything fun.

00:36:56.170 --> 00:36:58.320
We can just go inside
the sandbox.

00:36:58.320 --> 00:36:58.980
How do we get out?

00:36:58.980 --> 00:37:02.720
How do we actually request the
URL like I showed in the

00:37:02.720 --> 00:37:04.530
beginning of this
presentation?

00:37:04.530 --> 00:37:08.960
To do that, at the bottom of
the sandbox Native Client

00:37:08.960 --> 00:37:11.910
inserts a bit of code called
the trampoline.

00:37:11.910 --> 00:37:14.240
Now the trampoline is code that
would not normally be

00:37:14.240 --> 00:37:17.700
validated, but allows you to do
a controlled jump outside

00:37:17.700 --> 00:37:18.720
the sandbox.

00:37:18.720 --> 00:37:22.020
So there's a trampoline entry
for each service we provide,

00:37:22.020 --> 00:37:23.710
such as spawning threads.

00:37:23.710 --> 00:37:25.480
And when you want that, you
jump to the trampoline.

00:37:25.480 --> 00:37:28.540
And the trampoline jumps you out
into Chrome DLL, where we

00:37:28.540 --> 00:37:30.320
provide an implementation
for that.

00:37:30.320 --> 00:37:33.020
So the set of trampoline calls
you have, which are analogous

00:37:33.020 --> 00:37:35.900
to syscalls, are the same
on every platform.

00:37:35.900 --> 00:37:41.390
So in one swoop, we are
providing a cross-platform API

00:37:41.390 --> 00:37:47.390
and controlling exactly what
services the native code gets.

00:37:47.390 --> 00:37:50.700
The trampoline itself, again,
is small, but in some ways

00:37:50.700 --> 00:37:52.020
overly clever.

00:37:52.020 --> 00:37:55.840
And we take a constant address,
stick it in a

00:37:55.840 --> 00:38:00.270
register, and then call
that address.

00:38:00.270 --> 00:38:02.290
And there's a few things
going on here.

00:38:02.290 --> 00:38:06.060
One is that we do the move into
the register instead of

00:38:06.060 --> 00:38:10.490
doing a direct call, so that
it's easier to patch the code

00:38:10.490 --> 00:38:12.820
as we know exactly the address
we're going to.

00:38:12.820 --> 00:38:14.790
And in fact, we can make that
address the same for all the

00:38:14.790 --> 00:38:15.800
trampolines.

00:38:15.800 --> 00:38:17.790
So if you have multiple
trampolines going to the same

00:38:17.790 --> 00:38:21.050
place, since direct jumps are
relative, you'd have to do a

00:38:21.050 --> 00:38:22.660
lot of math and make sure
that you're jumping

00:38:22.660 --> 00:38:23.370
to the right address.

00:38:23.370 --> 00:38:25.750
But here we just jump to
a constant address.

00:38:25.750 --> 00:38:28.140
Another thing is that it's a
call instead of a jump, so we

00:38:28.140 --> 00:38:31.620
can have a trace of where the
syscall's coming from.

00:38:31.620 --> 00:38:33.790
So we know, oh, we're going
through trampoline 4,

00:38:33.790 --> 00:38:36.350
therefore, we know what
service we're getting.

00:38:36.350 --> 00:38:38.390
And then finally at the
end, there's a halt.

00:38:38.390 --> 00:38:41.640
So even though we're doing a
call, we never return to where

00:38:41.640 --> 00:38:42.270
we called from.

00:38:42.270 --> 00:38:44.310
It's just a method to
trace the address of

00:38:44.310 --> 00:38:45.530
where we came from.

00:38:45.530 --> 00:38:48.800
So if anyone returns from inside
the system code, it's

00:38:48.800 --> 00:38:49.840
going to hit the halt, and it's

00:38:49.840 --> 00:38:52.140
going to prevent execution.

00:38:52.140 --> 00:38:55.210
This is all interesting because
it's within 13 bytes.

00:38:55.210 --> 00:38:57.760
So this means that the
trampoline fits within the

00:38:57.760 --> 00:39:00.030
32-byte bundle.

00:39:00.030 --> 00:39:04.470
And this means that indirect
jumps will never go inside the

00:39:04.470 --> 00:39:04.940
trampoline.

00:39:04.940 --> 00:39:06.840
They can only go to the start
to the trampoline.

00:39:06.840 --> 00:39:10.610
And this is what allows us to
do safe exits outside of the

00:39:10.610 --> 00:39:13.110
NaCl sandbox.

00:39:13.110 --> 00:39:16.870
So putting it all together, this
is the API call which I

00:39:16.870 --> 00:39:18.000
started with.

00:39:18.000 --> 00:39:19.690
It is loading a URL.

00:39:19.690 --> 00:39:23.300
So to do this, the untrusted
code initiates it by jumping

00:39:23.300 --> 00:39:27.150
to the trampoline and saying
I want to do this request.

00:39:27.150 --> 00:39:29.740
The trampoline takes
it to Chrome DLL.

00:39:29.740 --> 00:39:32.750
Chrome DLL has an implementation
that says, OK,

00:39:32.750 --> 00:39:35.130
native code wants to
do a URL request.

00:39:35.130 --> 00:39:38.140
Well, I can't do it myself
because I'm running inside the

00:39:38.140 --> 00:39:39.340
Chrome sandbox.

00:39:39.340 --> 00:39:42.160
So instead, what I have to do
is I have to talk to the

00:39:42.160 --> 00:39:44.850
Chrome browser via the
render process.

00:39:44.850 --> 00:39:47.030
So to do that, I'm going to need
to do some inter-process

00:39:47.030 --> 00:39:48.110
communication.

00:39:48.110 --> 00:39:50.830
So it talks to the operating
system and says, hey, send

00:39:50.830 --> 00:39:53.875
this bit of the data to the
renderer process, and then it

00:39:53.875 --> 00:39:54.770
will know what to do with it.

00:39:54.770 --> 00:39:56.830
And at that point, it's
out of NaCl's control.

00:39:56.830 --> 00:40:00.040
It's just however the JavaScript
call would be.

00:40:00.040 --> 00:40:01.290
Same paths.

00:40:03.430 --> 00:40:05.630
That is Native Client
in a nutshell.

00:40:05.630 --> 00:40:07.310
And I hope you all
followed that.

00:40:07.310 --> 00:40:10.640
And we have questions
afterwards, if you don't.

00:40:10.640 --> 00:40:12.640
There's more to this.

00:40:12.640 --> 00:40:15.190
As I mentioned before, dynamic
code loading in JIT, memory

00:40:15.190 --> 00:40:18.180
consistency, making the
sandboxing model work is a

00:40:18.180 --> 00:40:19.440
whole other ball of wax.

00:40:19.440 --> 00:40:21.090
I find it very fascinating.

00:40:21.090 --> 00:40:23.930
I hope you guys look into it.

00:40:23.930 --> 00:40:25.630
Portable Native Client.

00:40:25.630 --> 00:40:28.070
This is the future.

00:40:28.070 --> 00:40:30.497
Bit code, LLVM tool
chain, fixes, the

00:40:30.497 --> 00:40:33.040
architecture-specific issues
we have now, but you

00:40:33.040 --> 00:40:33.720
still can use it.

00:40:33.720 --> 00:40:35.700
You can write applications
now and switch to

00:40:35.700 --> 00:40:36.950
PNaCl when it's available.

00:40:39.130 --> 00:40:41.230
You may have noticed that
nothing in this presentation

00:40:41.230 --> 00:40:43.700
really has to be inside
the browser.

00:40:43.700 --> 00:40:46.600
So this is a technical solution,
the sandboxing,

00:40:46.600 --> 00:40:48.070
software for the isolation.

00:40:48.070 --> 00:40:51.690
There have been some projects
to use the same sandboxing

00:40:51.690 --> 00:40:55.080
technology to, for instance, run
computation in the cloud.

00:40:55.080 --> 00:40:57.850
Or to just say, you know,
I don't want to audit

00:40:57.850 --> 00:40:58.790
this piece of code.

00:40:58.790 --> 00:41:02.590
Well, I'll just throw it in the
sandbox, and that way, I

00:41:02.590 --> 00:41:04.840
know that the third-party code
is going to be much more

00:41:04.840 --> 00:41:08.110
contained than it
would otherwise.

00:41:08.110 --> 00:41:09.310
Recommended reading.

00:41:09.310 --> 00:41:11.750
So every time we give a NaCl
talk, we point people to

00:41:11.750 --> 00:41:12.860
gonacl.com.

00:41:12.860 --> 00:41:16.130
This is a developer-oriented
site, where you download the

00:41:16.130 --> 00:41:20.460
compiler, the SDK tutorials
about how to get you started.

00:41:20.460 --> 00:41:22.910
This talk was a little
technical, more

00:41:22.910 --> 00:41:25.470
research-based, so we have a
bunch of research papers, too.

00:41:25.470 --> 00:41:26.860
I point you towards those.

00:41:26.860 --> 00:41:30.660
If you Google gonacl or Native
Client research papers, you'll

00:41:30.660 --> 00:41:32.180
get these URLs.

00:41:32.180 --> 00:41:34.660
And my favorite one is actually
"A Tale of Two

00:41:34.660 --> 00:41:37.700
Pwnies." So every year
or so, there's a

00:41:37.700 --> 00:41:39.640
browser security contest.

00:41:39.640 --> 00:41:43.350
And this year, Chrome
had two exploits.

00:41:43.350 --> 00:41:46.220
One of them actually touched
NaCl but did not break it.

00:41:46.220 --> 00:41:48.080
So they used NaCl as
an attack platform

00:41:48.080 --> 00:41:49.580
to hit the GPU process.

00:41:49.580 --> 00:41:52.450
And I myself actually learned
a lot from reading this.

00:41:52.450 --> 00:41:55.790
And it's really eye-opening to
see how many layers and levels

00:41:55.790 --> 00:41:58.660
you have to get through to
do a modern exploit.

00:41:58.660 --> 00:42:00.470
The one that involved
NaCl was six.

00:42:00.470 --> 00:42:03.230
The other one was 10 because
they had to chain that many

00:42:03.230 --> 00:42:04.930
different vulnerabilities
together to

00:42:04.930 --> 00:42:06.650
actually get an exploit.

00:42:06.650 --> 00:42:08.780
So security, very interesting
field.

00:42:08.780 --> 00:42:10.562
I strongly suggest you
read that paper.

00:42:13.240 --> 00:42:14.130
Now the fun part.

00:42:14.130 --> 00:42:15.828
Questions.

00:42:15.828 --> 00:42:28.060
[APPLAUSE]

00:42:28.060 --> 00:42:29.610
AUDIENCE: Thanks for
the presentation.

00:42:29.610 --> 00:42:30.670
NICK BRAY: My pleasure.

00:42:30.670 --> 00:42:32.560
AUDIENCE: Out of all of I/O,
it's probably the most

00:42:32.560 --> 00:42:34.920
interesting, funnest one that
I've ever been to, so that was

00:42:34.920 --> 00:42:35.400
really cool.

00:42:35.400 --> 00:42:38.350
I've known NaCl for about
an hour and a half.

00:42:38.350 --> 00:42:41.830
I was wondering, does it matter
what version of CIUs?

00:42:41.830 --> 00:42:48.350
Does NaCl care whether
it's C99 or C90?

00:42:48.350 --> 00:42:49.790
NICK BRAY: It doesn't even
matter if you use a

00:42:49.790 --> 00:42:51.180
C-compiler.

00:42:51.180 --> 00:42:54.480
So you can actually hand-write
NaCl code, and it'll run.

00:42:54.480 --> 00:42:57.840
But we provide compilers that
generate code that's

00:42:57.840 --> 00:42:58.920
compatible.

00:42:58.920 --> 00:43:02.920
So I think our version
of GCC supports C99.

00:43:02.920 --> 00:43:04.246
Do you know?

00:43:04.246 --> 00:43:06.120
Yeah, I think, so
you can use C99.

00:43:06.120 --> 00:43:09.430
It's whatever GCC supports,
really.

00:43:09.430 --> 00:43:10.650
AUDIENCE: The one question
I had was about

00:43:10.650 --> 00:43:11.950
the indirect jumps.

00:43:11.950 --> 00:43:15.560
And it sounds like you are
relying on the compiler to put

00:43:15.560 --> 00:43:18.180
everything on 32-bit
boundaries.

00:43:18.180 --> 00:43:20.100
That seems to me like the
only position where

00:43:20.100 --> 00:43:21.130
a handwritten exploit--

00:43:21.130 --> 00:43:25.490
I mean, you were assuming that
all the code coming in would

00:43:25.490 --> 00:43:27.170
allow jumps to 32-byte
boundaries.

00:43:27.170 --> 00:43:30.350
But if I were to hand-write some
asm that a jump into a

00:43:30.350 --> 00:43:32.850
32-bit boundary was a actually
a bad execution, how do you

00:43:32.850 --> 00:43:34.320
manage that?

00:43:34.320 --> 00:43:35.430
NICK BRAY: Validation.

00:43:35.430 --> 00:43:38.260
So while we're going through
looking at what the

00:43:38.260 --> 00:43:41.950
instructions are, we record
where they are, too.

00:43:41.950 --> 00:43:45.010
So internally, you can think
that we have a bit factor,

00:43:45.010 --> 00:43:47.200
which contains a bit
for each byte.

00:43:47.200 --> 00:43:49.990
And every time we see an
instruction start, we say,

00:43:49.990 --> 00:43:51.410
boom, there's a bit.

00:43:51.410 --> 00:43:53.580
So whenever we have a
direct jump we say,

00:43:53.580 --> 00:43:54.870
is the bit set there?

00:43:54.870 --> 00:43:56.520
We actually have to do this
after we see all the

00:43:56.520 --> 00:43:57.110
instructions.

00:43:57.110 --> 00:43:59.770
But in the final thing, we go,
OK, here's all the jump

00:43:59.770 --> 00:44:02.000
targets, here's all the
instructions, starts--

00:44:02.000 --> 00:44:02.830
AUDIENCE: But what about
the indirect

00:44:02.830 --> 00:44:05.180
jumps into the 32 byte--

00:44:05.180 --> 00:44:06.850
NICK BRAY: We do that
on the fly.

00:44:06.850 --> 00:44:10.340
So you say, OK, while I'm
parsing this instruction, I

00:44:10.340 --> 00:44:12.740
notice that it's overlapping
the 32-byte boundary.

00:44:12.740 --> 00:44:13.300
Boom, that's bad.

00:44:13.300 --> 00:44:14.810
AUDIENCE: OK.

00:44:14.810 --> 00:44:18.030
So you also make sure that all
32-byte boundary instructions,

00:44:18.030 --> 00:44:20.350
whatever is at a 32-byte
boundary is also safe.

00:44:20.350 --> 00:44:21.600
NICK BRAY: Yes.

00:44:23.910 --> 00:44:26.300
AUDIENCE: So it looks like
you're creating a 4-gig memory

00:44:26.300 --> 00:44:26.950
limit again.

00:44:26.950 --> 00:44:30.410
Didn't we just get
rid of that?

00:44:30.410 --> 00:44:33.430
NICK BRAY: It depends on
how you look at it.

00:44:33.430 --> 00:44:35.740
So there's all sorts
of devices.

00:44:35.740 --> 00:44:37.740
But what you're really saying
is, can I get more

00:44:37.740 --> 00:44:39.690
than 4 gigs of memory?

00:44:39.690 --> 00:44:42.400
And the answer is we could
change the sandboxing model,

00:44:42.400 --> 00:44:44.570
but there would be performance
implications.

00:44:44.570 --> 00:44:47.260
So a lot of the clever things
we were doing with dropping

00:44:47.260 --> 00:44:49.710
the upper 32 bits, suddenly
you're carting

00:44:49.710 --> 00:44:52.060
around 8-byte constants.

00:44:52.060 --> 00:44:54.680
And that's a generally
bad thing.

00:44:54.680 --> 00:44:56.440
So has it been a problem?

00:44:56.440 --> 00:44:58.810
And the answer is, we haven't
really had any developers

00:44:58.810 --> 00:45:00.220
complain about it.

00:45:00.220 --> 00:45:03.470
We've been living under the
4-gig limit so long, that it's

00:45:03.470 --> 00:45:04.970
not been an issue.

00:45:04.970 --> 00:45:07.010
Plus do you really want an
application in your web

00:45:07.010 --> 00:45:09.000
browser consuming that
much memory?

00:45:09.000 --> 00:45:10.270
Eh, most the time, not.

00:45:10.270 --> 00:45:11.984
There are some applications
that you write that

00:45:11.984 --> 00:45:12.300
you may want to.

00:45:12.300 --> 00:45:14.070
AUDIENCE: In five years,
certainly?

00:45:14.070 --> 00:45:15.670
NICK BRAY: Yeah.

00:45:15.670 --> 00:45:18.040
So sandboxing models
are flexible.

00:45:18.040 --> 00:45:21.590
And once we get PNaCl running,
we can take another look at

00:45:21.590 --> 00:45:23.778
generating a new sandboxing
model or

00:45:23.778 --> 00:45:26.400
something along those lines.

00:45:26.400 --> 00:45:28.940
AUDIENCE: Kind of a
related question.

00:45:28.940 --> 00:45:34.720
You, at the beginning, showed
x64, x86, and ARM.

00:45:34.720 --> 00:45:37.930
On x86, you obviously can't
do the same kind of jump

00:45:37.930 --> 00:45:40.310
constraint because you are--

00:45:40.310 --> 00:45:44.090
if you're on 32-bit x86,
you're then limited.

00:45:44.090 --> 00:45:47.790
You're going to reduce your
memory space by far more and

00:45:47.790 --> 00:45:49.950
lose a very precious register.

00:45:49.950 --> 00:45:51.390
NICK BRAY: One gig.

00:45:51.390 --> 00:45:53.800
And you don't lose precious
registers.

00:45:53.800 --> 00:45:57.660
We do something very perverse
on 32-bit Intel.

00:45:57.660 --> 00:45:59.410
We use segment registers.

00:45:59.410 --> 00:46:01.530
So we're bringing back all
these things that you

00:46:01.530 --> 00:46:01.830
thought were dead.

00:46:01.830 --> 00:46:03.545
AUDIENCE: Awesome.

00:46:03.545 --> 00:46:05.350
NICK BRAY: So, for those of you
who don't know, segment

00:46:05.350 --> 00:46:08.680
registers say this is the range
of memory you can use.

00:46:08.680 --> 00:46:13.980
So we say, OK, 256 megs for
code, 1 gig for data.

00:46:13.980 --> 00:46:16.500
If you jump outside
this, boom.

00:46:16.500 --> 00:46:19.020
And then we say you can't change
the segment registers

00:46:19.020 --> 00:46:20.120
while you're running.

00:46:20.120 --> 00:46:22.900
This has a few weird
implications, like most people

00:46:22.900 --> 00:46:23.920
thought they were dead.

00:46:23.920 --> 00:46:27.180
So the Intel atom processor
for instance, they didn't

00:46:27.180 --> 00:46:28.990
spend so much time supporting
segment registers.

00:46:28.990 --> 00:46:31.630
They do lip service, but then
when you actually use them in

00:46:31.630 --> 00:46:34.520
nonstandard ways, it
slows down a lot.

00:46:34.520 --> 00:46:36.500
AUDIENCE: Thanks.

00:46:36.500 --> 00:46:37.240
AUDIENCE: Hi.

00:46:37.240 --> 00:46:38.100
It's a great project.

00:46:38.100 --> 00:46:40.090
I love it.

00:46:40.090 --> 00:46:43.380
It is very perverse though, in
some ways, as you're going

00:46:43.380 --> 00:46:45.460
through all of these things.

00:46:45.460 --> 00:46:51.060
I was just wondering, with the
LLVM thing that you're going

00:46:51.060 --> 00:46:54.420
to be doing, does it get easier
now that you control

00:46:54.420 --> 00:46:55.570
the instruction set?

00:46:55.570 --> 00:46:58.190
I mean, can you somehow do
something to make this whole

00:46:58.190 --> 00:47:00.470
process simpler?

00:47:00.470 --> 00:47:02.980
NICK BRAY: Define the "whole
process simpler."

00:47:02.980 --> 00:47:04.300
AUDIENCE: The verification
process.

00:47:04.300 --> 00:47:09.900
I mean, since you control the
intermediate format, is there

00:47:09.900 --> 00:47:12.760
some way to--

00:47:12.760 --> 00:47:16.460
will it become simpler when
you get to the LLVM model?

00:47:16.460 --> 00:47:17.480
NICK BRAY: The big problem
is that we

00:47:17.480 --> 00:47:19.620
can't trust the compiler.

00:47:19.620 --> 00:47:21.110
So we can't audit it.

00:47:21.110 --> 00:47:23.120
We can't verify that it's--

00:47:23.120 --> 00:47:25.240
you know, it should generate
the code we want.

00:47:25.240 --> 00:47:27.630
But at the end of the day, what
we do is, we have to have

00:47:27.630 --> 00:47:29.810
validation be the last
line of defense.

00:47:29.810 --> 00:47:32.860
So if the code doesn't look
safe, we don't run it.

00:47:32.860 --> 00:47:36.500
And we make no assumptions
about its providence.

00:47:36.500 --> 00:47:42.000
So what LLVM would allow us to
do is do more creative things.

00:47:42.000 --> 00:47:44.460
Right now, the binary that's
shipped across the wire is

00:47:44.460 --> 00:47:46.830
something that we've stabilized
and we said this is

00:47:46.830 --> 00:47:48.610
what we're going to support.

00:47:48.610 --> 00:47:50.880
Once we start supporting bit
code, then we can generate

00:47:50.880 --> 00:47:52.340
other sandboxing models.

00:47:52.340 --> 00:47:54.940
We can generate other
interesting low-level things.

00:47:54.940 --> 00:47:57.690
And it decouples us and gives
us a lot of flexibility.

00:47:57.690 --> 00:48:00.040
But at the bottom level, there's
going to have to be

00:48:00.040 --> 00:48:03.010
some algorithm that goes through
and says does this

00:48:03.010 --> 00:48:04.690
native code look right?

00:48:04.690 --> 00:48:06.620
And if it doesn't,
out of there.

00:48:06.620 --> 00:48:08.320
And once LLVM's in
the picture, it

00:48:08.320 --> 00:48:10.070
should always look right.

00:48:10.070 --> 00:48:11.410
But we are going to
bank on that.

00:48:11.410 --> 00:48:12.810
We're going to always
have the last line.

00:48:12.810 --> 00:48:15.790
AUDIENCE: Will the bit code be
actual LLVM byte code, or will

00:48:15.790 --> 00:48:19.250
you have something of
your own nature?

00:48:19.250 --> 00:48:21.790
NICK BRAY: I think the plan
is actual LLVM byte code.

00:48:25.050 --> 00:48:28.057
AUDIENCE: That was actually very
similar to the question I

00:48:28.057 --> 00:48:29.360
was going to ask.

00:48:29.360 --> 00:48:32.705
When you're going through the
initial design for NaCl, why

00:48:32.705 --> 00:48:38.042
did you choose native code
versus LLVM or comparing it to

00:48:38.042 --> 00:48:40.630
the JVMs and what they do?

00:48:40.630 --> 00:48:42.100
NICK BRAY: Why choose
native code instead

00:48:42.100 --> 00:48:45.340
of everything else?

00:48:45.340 --> 00:48:48.360
AUDIENCE: Was it to have a
simpler just run- time

00:48:48.360 --> 00:48:51.030
environment, not have to
have an actual JIT?

00:48:51.030 --> 00:48:52.280
NICK BRAY: Yep.

00:48:54.060 --> 00:48:57.340
Part of the view was
compatibility, because we have

00:48:57.340 --> 00:48:59.470
a lot of infrastructure
for native code.

00:48:59.470 --> 00:49:02.150
So if we're just running native
code, a lot of that

00:49:02.150 --> 00:49:06.160
should be analogous, fairly
straightforward.

00:49:06.160 --> 00:49:07.980
Less overhead.

00:49:07.980 --> 00:49:09.700
You can access certain
intrinsic

00:49:09.700 --> 00:49:11.350
instructions directly.

00:49:11.350 --> 00:49:12.570
You can do threads.

00:49:12.570 --> 00:49:15.250
You don't have to solve
all these ugly

00:49:15.250 --> 00:49:16.940
issues at the VM level.

00:49:16.940 --> 00:49:20.130
Instead, you can just validate
it and let it rip instead of

00:49:20.130 --> 00:49:22.730
trying to have a larger surface
area, which you are

00:49:22.730 --> 00:49:25.270
trying to prove is safe.

00:49:25.270 --> 00:49:28.230
Part of it was also
a technical issue.

00:49:28.230 --> 00:49:30.280
We realized, hey,
we CAN do this.

00:49:30.280 --> 00:49:32.630
So how can we bring
it to the web?

00:49:32.630 --> 00:49:34.750
So we finally realized
native code

00:49:34.750 --> 00:49:36.420
doesn't have to be unsafe.

00:49:36.420 --> 00:49:38.060
And what are the
opportunities?

00:49:38.060 --> 00:49:39.170
So we've been seeing
a lot of people

00:49:39.170 --> 00:49:40.590
port games, for instance.

00:49:40.590 --> 00:49:43.250
And when you spend how many
years writing native code, and

00:49:43.250 --> 00:49:46.510
you want to port it, well, you
don't want to jump through too

00:49:46.510 --> 00:49:47.920
many hoops.

00:49:47.920 --> 00:49:51.520
You can try to do weird cross
compiles into JavaScript VMs,

00:49:51.520 --> 00:49:54.640
but, it works some
of the time.

00:49:54.640 --> 00:49:57.630
Instead, why don't you just run
the native code, and call

00:49:57.630 --> 00:49:59.520
the browser instead of the OS.

00:49:59.520 --> 00:50:01.400
That's the general philosophy,
is trying to keep the surface

00:50:01.400 --> 00:50:05.090
area small and trying to make
it as close to other native

00:50:05.090 --> 00:50:07.680
code development as possible.

00:50:07.680 --> 00:50:08.130
AUDIENCE: Cool.

00:50:08.130 --> 00:50:09.630
Thanks.

00:50:09.630 --> 00:50:10.560
AUDIENCE: I've got
two questions.

00:50:10.560 --> 00:50:12.790
I think they're both small.

00:50:12.790 --> 00:50:14.940
Trampolines got me thinking.

00:50:14.940 --> 00:50:17.840
Do you have any dev tools that
would de-bug what's going on,

00:50:17.840 --> 00:50:20.330
so that you can see in the
inspector that, OK, it's

00:50:20.330 --> 00:50:23.600
making it HTTP requests
and so on?

00:50:23.600 --> 00:50:25.500
NICK BRAY: De-buggers are
something we're working on.

00:50:25.500 --> 00:50:27.320
They're harder than
you'd expect.

00:50:27.320 --> 00:50:30.420
Because they've made many silly
assumptions that native

00:50:30.420 --> 00:50:33.180
code just happens to work the
way native code does.

00:50:33.180 --> 00:50:36.300
So the moment we start adding
this R15 register to offset

00:50:36.300 --> 00:50:39.500
everything, there's been a lot
of work to try to get the

00:50:39.500 --> 00:50:40.750
de-buggers to get all
the right symbols.

00:50:40.750 --> 00:50:42.530
AUDIENCE: I'm thinking on a much
higher level actually.

00:50:42.530 --> 00:50:45.220
If you're coming as a web
developer looking at things in

00:50:45.220 --> 00:50:47.780
the inspector, what's going
on in this web page?

00:50:47.780 --> 00:50:49.180
What is it doing?

00:50:49.180 --> 00:50:53.080
Can I see what stuff is it
requesting on the web?

00:50:53.080 --> 00:50:56.650
NICK BRAY: At the moment,
half and half.

00:50:56.650 --> 00:50:59.970
So whenever you're doing
a Pepper call, that

00:50:59.970 --> 00:51:00.930
usually gets traced.

00:51:00.930 --> 00:51:05.570
So every time you see a URL
load, Chrome has the console

00:51:05.570 --> 00:51:06.900
of all network activity.

00:51:06.900 --> 00:51:08.080
And it will get logged
in that.

00:51:08.080 --> 00:51:10.470
So you're mediating through
the browser, so all the

00:51:10.470 --> 00:51:11.820
instrumentation the
browser has.

00:51:11.820 --> 00:51:14.275
What's actually going on inside
the native process is a

00:51:14.275 --> 00:51:16.200
little more opaque than I'd
like at this point.

00:51:16.200 --> 00:51:19.880
And we're thinking about ways
to expose health and metrics

00:51:19.880 --> 00:51:21.450
and pull that out
of the process.

00:51:21.450 --> 00:51:22.560
AUDIENCE: That's awesome.

00:51:22.560 --> 00:51:25.410
The second question is, so
you're defending against all

00:51:25.410 --> 00:51:28.090
these things that are unsafe
from the system's perspective.

00:51:28.090 --> 00:51:32.150
But are you having any checks
and bounds on stuff that's

00:51:32.150 --> 00:51:35.800
causing infinite loops that
just eat the CPU?

00:51:35.800 --> 00:51:36.510
That kind of stuff.

00:51:36.510 --> 00:51:36.800
NICK BRAY: Nope.

00:51:36.800 --> 00:51:39.220
AUDIENCE: OK.

00:51:39.220 --> 00:51:41.640
Thanks.

00:51:41.640 --> 00:51:43.820
AUDIENCE: This is similar to
the question before last.

00:51:43.820 --> 00:51:47.270
Once you move into the LLVM
world and you're sending

00:51:47.270 --> 00:51:50.290
basically Virtual Machine
instructions and calling a

00:51:50.290 --> 00:51:54.660
limited API, how would you say
that PNaCl would compare to

00:51:54.660 --> 00:51:58.390
Java or dot-net?

00:51:58.390 --> 00:52:02.560
NICK BRAY: One thing about LLVM
is it's a bit misnamed.

00:52:02.560 --> 00:52:05.230
So the Virtual Machine
name came

00:52:05.230 --> 00:52:07.290
earlier in its life cycle.

00:52:07.290 --> 00:52:10.270
And it's more a compiler
IR than it is,

00:52:10.270 --> 00:52:12.270
strictly speaking, a VM.

00:52:12.270 --> 00:52:13.990
There's some
architecture-specific things

00:52:13.990 --> 00:52:16.640
that have got leaked into it,
which have had to be hammered

00:52:16.640 --> 00:52:19.420
out in order to use it as
an interchange format.

00:52:19.420 --> 00:52:22.800
So how would byte code
compare against VMs?

00:52:26.480 --> 00:52:28.380
It's an interesting question.

00:52:28.380 --> 00:52:30.530
I think the only real answer
I would add to

00:52:30.530 --> 00:52:32.430
that is surface area.

00:52:32.430 --> 00:52:36.260
Securing a VM is going to be
much harder than validating

00:52:36.260 --> 00:52:38.780
native code and just use
the model that's there.

00:52:38.780 --> 00:52:41.550
And the VM will likely be
slower, give or take

00:52:41.550 --> 00:52:45.520
just-in-time compilers,
how well those do.

00:52:45.520 --> 00:52:49.330
AUDIENCE: So does the validator
in PNaCl work on

00:52:49.330 --> 00:52:50.110
native code still?

00:52:50.110 --> 00:52:53.280
Or is it still validating
LLVM code?

00:52:53.280 --> 00:52:56.010
NICK BRAY: We validate all
native code before we run it.

00:52:56.010 --> 00:53:00.170
So PNaCl you can think of as
largely a translator, which is

00:53:00.170 --> 00:53:02.330
I'm going to take this bit
code, then turn it into

00:53:02.330 --> 00:53:04.460
machine code.

00:53:04.460 --> 00:53:05.960
And then we pass it off
to the validator.

00:53:05.960 --> 00:53:08.490
The validator says, OK, you
did your job right.

00:53:08.490 --> 00:53:10.540
You're good to go.

00:53:10.540 --> 00:53:11.790
AUDIENCE: Thanks.

00:53:17.120 --> 00:53:19.960
AUDIENCE: Have you done any
benchmarking on the difference

00:53:19.960 --> 00:53:24.820
between the unmodified code
that you do, like adding

00:53:24.820 --> 00:53:27.620
padding and replacing things
with pseudo-instructions,

00:53:27.620 --> 00:53:30.380
versus the modified version?

00:53:30.380 --> 00:53:31.160
NICK BRAY: Yes.

00:53:31.160 --> 00:53:34.640
AUDIENCE: And what
are the results?

00:53:34.640 --> 00:53:35.910
NICK BRAY: It depends.

00:53:35.910 --> 00:53:37.470
Also, one of these
horrible answers.

00:53:37.470 --> 00:53:38.710
I'm not trying to weasel
out, but the

00:53:38.710 --> 00:53:40.780
truth is, it does depend.

00:53:40.780 --> 00:53:43.900
So if you're doing a numerical
application, for instance,

00:53:43.900 --> 00:53:46.180
you're not going to have
a lot of jumps.

00:53:46.180 --> 00:53:47.360
You're not going to have
a lot of calls.

00:53:47.360 --> 00:53:49.460
So you can usually rip through
those instructions.

00:53:49.460 --> 00:53:51.790
But certain benchmarks which are
doing indirect jumps all

00:53:51.790 --> 00:53:55.220
over the place, you're going
to get no-op padding.

00:53:55.220 --> 00:53:57.750
You're going to get a bunch
of guard instructions.

00:53:57.750 --> 00:54:00.370
And on 32-bit, because we're
using segment registers, it's

00:54:00.370 --> 00:54:01.600
actually more efficient.

00:54:01.600 --> 00:54:06.190
So I think on 32-bit, it's like
10 20% slowdown compared

00:54:06.190 --> 00:54:07.960
to full native speed.

00:54:07.960 --> 00:54:11.630
On 64-bit, our guard sequences
are a little more complex.

00:54:11.630 --> 00:54:13.110
They take up more bytes,
a few more

00:54:13.110 --> 00:54:14.610
instructions here and there.

00:54:14.610 --> 00:54:17.520
And I'm not exactly sure what
the benchmarks are.

00:54:17.520 --> 00:54:21.680
Again, I say rule of thumb,
20%, although on some

00:54:21.680 --> 00:54:25.510
degenerate benchmarks, it's down
40, 50% just because of

00:54:25.510 --> 00:54:27.560
the way the code works out.

00:54:27.560 --> 00:54:30.540
Again, the answer is that, no
one's complained yet either.

00:54:30.540 --> 00:54:32.909
So it works as intended.

00:54:32.909 --> 00:54:34.159
AUDIENCE: Thanks.

00:54:37.310 --> 00:54:39.730
AUDIENCE: Another
PNaCl question.

00:54:39.730 --> 00:54:45.590
Since you're going to have
LLVM living in PNaCl to

00:54:45.590 --> 00:54:48.440
generate the instructions, you
mentioned earlier that you can

00:54:48.440 --> 00:54:52.345
still do JITs in
Native Client.

00:54:52.345 --> 00:54:55.610
I'm thinking about some ways
in which you could do that.

00:54:55.610 --> 00:55:00.420
Are you going to expose
the LLVM translator to

00:55:00.420 --> 00:55:03.400
applications so they can just
use that instead of having

00:55:03.400 --> 00:55:06.850
another copy of LLVM inside
to do JIT-ing?

00:55:06.850 --> 00:55:07.600
NICK BRAY: Interesting
question.

00:55:07.600 --> 00:55:09.680
Very interesting question that
I can't answer, because I'm

00:55:09.680 --> 00:55:11.500
not working on the
PNaCl project.

00:55:11.500 --> 00:55:12.730
So what they're working
on there.

00:55:12.730 --> 00:55:15.120
But you can imagine all the
complexities of, well, since

00:55:15.120 --> 00:55:18.880
we can't trust the translator,
how do we fit it in so we can

00:55:18.880 --> 00:55:20.790
run it in an untrusted
capacity.

00:55:20.790 --> 00:55:24.370
So one neat thing I didn't
mention is that the actual

00:55:24.370 --> 00:55:27.250
ahead-of-time time translator
is implemented inside of

00:55:27.250 --> 00:55:29.060
Native Client.

00:55:29.060 --> 00:55:31.860
So we have the LLVM compiler
running inside the Native

00:55:31.860 --> 00:55:35.200
Client sandbox to produce code
that then we run inside the

00:55:35.200 --> 00:55:38.260
Native Client sandbox.

00:55:38.260 --> 00:55:39.510
AUDIENCE: Thanks.

00:55:46.690 --> 00:55:48.660
NICK BRAY: Standard technique
for presentations is wait a

00:55:48.660 --> 00:55:49.820
few seconds.

00:55:49.820 --> 00:55:52.085
Usually someone gets
uncomfortable, stands up, and

00:55:52.085 --> 00:55:54.995
ask another question.

00:55:54.995 --> 00:55:57.920
If that doesn't work, then you
say, OK, thanks for coming.

