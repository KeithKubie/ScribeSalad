WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.708
YIGIT BOYAR: Oh, good
morning, everybody.

00:00:01.708 --> 00:00:03.900
Welcome to the Advanced
Data Binding session.

00:00:03.900 --> 00:00:05.600
I'm Yigit Boyar.

00:00:05.600 --> 00:00:07.390
GEORGE MOUNT: I'm
George Mount and we're

00:00:07.390 --> 00:00:09.980
from the Android UI Toolkit,
part of the Framework team

00:00:09.980 --> 00:00:11.780
on Android.

00:00:11.780 --> 00:00:14.608
And today let's talk a little
bit about data binding.

00:00:14.608 --> 00:00:16.280
[CHEERS AND APPLAUSE]

00:00:16.280 --> 00:00:17.660
YIGIT BOYAR: [LAUGHS]

00:00:17.660 --> 00:00:19.310
GEORGE MOUNT: All right.

00:00:19.310 --> 00:00:22.220
So how many of you have used
data binding in the past?

00:00:22.220 --> 00:00:22.990
All right.

00:00:22.990 --> 00:00:25.329
How many people think
it's still in beta?

00:00:25.329 --> 00:00:25.995
All right, yeah.

00:00:25.995 --> 00:00:27.439
Yeah, that's the problem.

00:00:27.439 --> 00:00:29.230
We didn't do a great
announcement last fall

00:00:29.230 --> 00:00:32.140
when we released it with
Android Studio [? 2.15. ?]

00:00:32.140 --> 00:00:34.330
But it is production now.

00:00:34.330 --> 00:00:36.031
And you are welcome to use it.

00:00:36.031 --> 00:00:37.030
It's production quality.

00:00:37.030 --> 00:00:40.200
It's actually doing
very well in the public.

00:00:40.200 --> 00:00:42.940
So if you haven't seen it, I
have put a little link here

00:00:42.940 --> 00:00:45.260
for our previous
Android data binding

00:00:45.260 --> 00:00:48.280
talk at Android Dev Summit.

00:00:48.280 --> 00:00:49.664
And you can just click on this.

00:00:49.664 --> 00:00:51.080
If you're watching
at home, that's

00:00:51.080 --> 00:00:52.700
a great thing to do right now.

00:00:52.700 --> 00:00:56.250
Pause it and go see that link.

00:00:56.250 --> 00:00:58.385
Because we're going to
show you about four minutes

00:00:58.385 --> 00:01:01.962
a quick version of what we did
for about 40 minutes back then.

00:01:01.962 --> 00:01:02.920
YIGIT BOYAR: It's good.

00:01:02.920 --> 00:01:03.920
GEORGE MOUNT: All right.

00:01:03.920 --> 00:01:06.320
So what is data binding?

00:01:06.320 --> 00:01:08.970
Well, when we have
a layout like this--

00:01:08.970 --> 00:01:10.790
this is my awesome store.

00:01:10.790 --> 00:01:13.060
And what I want to
do-- because of course,

00:01:13.060 --> 00:01:15.810
I want to get data
into my layout.

00:01:15.810 --> 00:01:19.150
And of course, I have
to find the views that

00:01:19.150 --> 00:01:20.220
are in my layout.

00:01:20.220 --> 00:01:22.980
And then set the
data, all right?

00:01:22.980 --> 00:01:25.590
This kind of sucks, right?

00:01:25.590 --> 00:01:28.140
I hate doing this.

00:01:28.140 --> 00:01:31.965
So we just use
Android data binding.

00:01:31.965 --> 00:01:33.740
So let's look at
that layout again.

00:01:33.740 --> 00:01:36.810
OK, we want to get rid
of all that setter logic.

00:01:36.810 --> 00:01:37.830
That kind of sucks.

00:01:37.830 --> 00:01:40.314
FindViewByID really is lousy.

00:01:40.314 --> 00:01:42.230
But we have to do something
a little different

00:01:42.230 --> 00:01:43.020
in the onCreate.

00:01:43.020 --> 00:01:46.260
Instead of calling
setContentView,

00:01:46.260 --> 00:01:49.890
we have to have a different
setContentView, which

00:01:49.890 --> 00:01:53.050
will create a data binding.

00:01:53.050 --> 00:01:57.815
And then we have to set the
data object on that binding.

00:01:57.815 --> 00:01:59.065
We can't do only that, though.

00:01:59.065 --> 00:02:01.500
We have to modify our
layout just a little bit.

00:02:01.500 --> 00:02:04.910
First thing we have to
do is add the layout tag

00:02:04.910 --> 00:02:06.010
to the outside of this.

00:02:06.010 --> 00:02:07.760
And of course, we move
the namespace stuff

00:02:07.760 --> 00:02:10.100
up to the top in the layout tag,
because that's the right thing

00:02:10.100 --> 00:02:10.870
to do.

00:02:10.870 --> 00:02:12.919
And we have a data tag as well.

00:02:12.919 --> 00:02:14.960
It has all the variables
that we're going to use.

00:02:14.960 --> 00:02:18.822
In this case, it's
prod for our product.

00:02:18.822 --> 00:02:22.920
So that kind of does our
import or sets the variables

00:02:22.920 --> 00:02:24.822
that we're going to
use in our layout.

00:02:24.822 --> 00:02:26.530
And then we also have
to reference those.

00:02:26.530 --> 00:02:31.130
So we assign the values
directly to our source, or text,

00:02:31.130 --> 00:02:33.670
or anything else that
we have in our layout.

00:02:33.670 --> 00:02:36.580
And here, you can see that we
can use any expression we want.

00:02:36.580 --> 00:02:42.489
And we just has the @{ to denote
that it's a data-bound tag.

00:02:42.489 --> 00:02:43.447
Let's see how it works.

00:02:45.610 --> 00:02:47.735
YIGIT BOYAR: So data binding
looks way too magical.

00:02:47.735 --> 00:02:50.655
And you want to briefly
explain that there's actually

00:02:50.655 --> 00:02:51.565
more magic.

00:02:51.565 --> 00:02:53.220
And like, there's
well-defined steps

00:02:53.220 --> 00:02:55.460
how we prepare that is
good for you to know,

00:02:55.460 --> 00:02:58.460
because then you have an idea
what's going behind the scenes.

00:02:58.460 --> 00:03:00.500
If you get a problem,
you have an idea

00:03:00.500 --> 00:03:03.000
where it might be happening.

00:03:03.000 --> 00:03:06.667
So while you hit Run
in Android Studio,

00:03:06.667 --> 00:03:08.875
the Android Studio starts
compiling your application.

00:03:08.875 --> 00:03:10.980
And it merges your resources.

00:03:10.980 --> 00:03:14.016
And when the layout
files are merged,

00:03:14.016 --> 00:03:17.360
we go pick those
layout files, and then

00:03:17.360 --> 00:03:19.432
remove everything
about data binding.

00:03:19.432 --> 00:03:22.116
So like everything you put
there about data binding gets

00:03:22.116 --> 00:03:22.615
deleted.

00:03:22.615 --> 00:03:25.290
So if you put layout with
something data binding,

00:03:25.290 --> 00:03:27.980
you lose it.

00:03:27.980 --> 00:03:30.300
And then in next step, we
parse these expressions,

00:03:30.300 --> 00:03:32.230
so that they are
grammatically correct.

00:03:32.230 --> 00:03:34.400
We don't know what you
put makes sense or not,

00:03:34.400 --> 00:03:37.130
but they need to be
grammatically correct.

00:03:37.130 --> 00:03:39.630
So when we parse, we understand,
OK, there's some, like,

00:03:39.630 --> 00:03:41.150
identifiers here.

00:03:41.150 --> 00:03:42.730
Accessing your field,
we have no idea

00:03:42.730 --> 00:03:44.209
what that is at this stage.

00:03:44.209 --> 00:03:45.250
But we know it's correct.

00:03:45.250 --> 00:03:49.130
And if it's not, we
will throw an exception.

00:03:49.130 --> 00:03:52.570
And next step, your
application code gets compiled.

00:03:52.570 --> 00:03:54.520
Like, the Java code you
write gets compiled.

00:03:54.520 --> 00:03:56.600
While it's being
compiled, we [? have an ?]

00:03:56.600 --> 00:03:59.930
annotation processor that
gets the outputs from what

00:03:59.930 --> 00:04:02.820
we parse from the
layout files and tries

00:04:02.820 --> 00:04:04.600
to understand what it means.

00:04:04.600 --> 00:04:07.320
So let's say you had
something like user.admin.

00:04:07.320 --> 00:04:09.066
Now you declare the variable.

00:04:09.066 --> 00:04:10.690
We know there was
some user cost there.

00:04:10.690 --> 00:04:12.090
We go and find that cost.

00:04:12.090 --> 00:04:14.594
Then we try to figure out,
OK, what does isAdmin mean?

00:04:14.594 --> 00:04:15.760
Like, is this a method call?

00:04:15.760 --> 00:04:17.019
Is this a field?

00:04:17.019 --> 00:04:19.006
We figured it out.

00:04:19.006 --> 00:04:22.630
We [? will be ?] resulting
like this is admin method,

00:04:22.630 --> 00:04:24.650
or you could just
say user.admin.

00:04:24.650 --> 00:04:27.440
We will still understand that
this is an is.admin Boolean

00:04:27.440 --> 00:04:28.720
method.

00:04:28.720 --> 00:04:31.560
And then figure out, OK,
this grammatically correct

00:04:31.560 --> 00:04:33.830
expression resolves
into a Boolean value.

00:04:33.830 --> 00:04:36.620
Now, when we look
at the attribute,

00:04:36.620 --> 00:04:40.050
I will try to find, OK, what
is the setter we need to call?

00:04:40.050 --> 00:04:44.770
Is this Visibility integer, or
enabled, whether we resolve it?

00:04:44.770 --> 00:04:47.060
And all of this happens
while your application

00:04:47.060 --> 00:04:48.520
is being compiled.

00:04:48.520 --> 00:04:51.920
Whilst we decide what to
do, we write the binders

00:04:51.920 --> 00:04:54.010
to the actual code
that updates the UI.

00:04:54.010 --> 00:04:57.090
And you profit.

00:04:57.090 --> 00:05:02.600
So really briefly, this
is data-bound layout file.

00:05:02.600 --> 00:05:06.020
At the time of compile,
we literally do this.

00:05:06.020 --> 00:05:07.150
Like, delete everything.

00:05:07.150 --> 00:05:09.660
We try to keep the
files, the lines

00:05:09.660 --> 00:05:11.499
match as much as possible.

00:05:11.499 --> 00:05:13.040
If you go check your
[? real ?] file,

00:05:13.040 --> 00:05:15.520
you will find the
stripped files.

00:05:15.520 --> 00:05:17.276
So we get rid of
that layout tag.

00:05:17.276 --> 00:05:19.520
Then we get rid of
everything data-binding,

00:05:19.520 --> 00:05:21.900
because APT doesn't
know about them.

00:05:21.900 --> 00:05:22.930
We clean them.

00:05:22.930 --> 00:05:27.690
And then we hit some tags,
so that-- go ahead, OK--

00:05:27.690 --> 00:05:31.180
so that when you inflate
layout, we can understand

00:05:31.180 --> 00:05:33.860
[? which field is. ?] This is
why even if you don't put IDs

00:05:33.860 --> 00:05:37.380
on those [? fields, ?]
we find them.

00:05:37.380 --> 00:05:39.307
So George has some
presents for you.

00:05:39.307 --> 00:05:40.560
[LAUGHTER]

00:05:40.560 --> 00:05:44.080
GEORGE MOUNT: So that's what
we released back in the fall.

00:05:44.080 --> 00:05:46.670
Let's see what new
things we have here.

00:05:46.670 --> 00:05:47.600
Two-way data binding.

00:05:47.600 --> 00:05:50.500
Now, I know I've heard
a lot from you guys out

00:05:50.500 --> 00:05:52.840
there that say, you
know, this is great,

00:05:52.840 --> 00:05:55.340
but without two-way
data binding,

00:05:55.340 --> 00:05:56.962
data binding's useless, right?

00:05:56.962 --> 00:05:58.170
I can't believe I heard that.

00:05:58.170 --> 00:06:02.520
But I think even one-way data
binding is pretty awesome.

00:06:02.520 --> 00:06:04.730
So I saw a few people
trying to do their own thing

00:06:04.730 --> 00:06:06.014
for two-way data binding.

00:06:06.014 --> 00:06:07.430
And they'd do
something like this,

00:06:07.430 --> 00:06:11.460
where they'd do the one-way
data binding with the regular

00:06:11.460 --> 00:06:15.880
data-binding field, and then
add another handler for the text

00:06:15.880 --> 00:06:17.062
change.

00:06:17.062 --> 00:06:18.770
And then they'd have
to check, of course,

00:06:18.770 --> 00:06:21.019
whether the change really
happened, or else you end up

00:06:21.019 --> 00:06:26.092
with this cycle of loops of
the text changes in the view,

00:06:26.092 --> 00:06:27.550
and then it goes
back to the field,

00:06:27.550 --> 00:06:30.240
and it sends a text
change message.

00:06:30.240 --> 00:06:31.650
So it was kind of a mess.

00:06:31.650 --> 00:06:34.710
And also, you end up
having this change handler

00:06:34.710 --> 00:06:39.780
for every different bound
view in your layout.

00:06:39.780 --> 00:06:41.810
And it really kind of sucked.

00:06:41.810 --> 00:06:45.610
So we wanted to do something
a little better than this.

00:06:45.610 --> 00:06:47.760
Get rid of all that stuff
that you're used to.

00:06:47.760 --> 00:06:51.890
And we can do this all on our
own by just saying @= instead

00:06:51.890 --> 00:06:53.300
of just @{, right?

00:06:53.300 --> 00:06:57.060
The @= is just kind of a
nice quick and very visible

00:06:57.060 --> 00:06:59.700
indicator that this is a
two-way data-bound field.

00:06:59.700 --> 00:07:01.850
Now we can bind to
the Android text

00:07:01.850 --> 00:07:06.340
field in a very simple way.

00:07:06.340 --> 00:07:08.930
Now, you may be wondering, how
does this notification happen?

00:07:08.930 --> 00:07:11.329
What's going on
underneath the hood?

00:07:11.329 --> 00:07:12.870
This is kind of
important if you were

00:07:12.870 --> 00:07:14.729
going to write your
own data-bound fields.

00:07:14.729 --> 00:07:17.020
So first thing we have to
know is what kind of listener

00:07:17.020 --> 00:07:17.945
should we add?

00:07:17.945 --> 00:07:19.980
We don't want to
use TextWatcher,

00:07:19.980 --> 00:07:23.860
because that's only useful
for text views or edit text.

00:07:23.860 --> 00:07:27.469
We don't want to use--
I don't know, what?

00:07:27.469 --> 00:07:28.510
YIGIT BOYAR: Time change.

00:07:28.510 --> 00:07:29.060
GEORGE MOUNT: Time change.

00:07:29.060 --> 00:07:30.800
Yeah, date change or
something like that.

00:07:30.800 --> 00:07:31.480
That wouldn't be good.

00:07:31.480 --> 00:07:32.730
So we have some
kind of generic one.

00:07:32.730 --> 00:07:34.438
It's called the inverse
binding listener.

00:07:34.438 --> 00:07:36.340
And this is basically
telling us that there's

00:07:36.340 --> 00:07:39.510
been a change on your view.

00:07:39.510 --> 00:07:42.490
And what happens is
your binding implements

00:07:42.490 --> 00:07:44.550
this listener for you.

00:07:44.550 --> 00:07:48.500
And this is code almost straight
out of the generated code.

00:07:48.500 --> 00:07:50.560
So you can see here
that what's going on

00:07:50.560 --> 00:07:53.719
is it's getting the
text from the view.

00:07:53.719 --> 00:07:55.510
And then it does, of
course, null checking.

00:07:55.510 --> 00:07:57.690
You guys have to make sure
to do all null checking.

00:07:57.690 --> 00:07:59.660
Everyone here always
double-checks their variables,

00:07:59.660 --> 00:07:59.925
right?

00:07:59.925 --> 00:08:00.510
OK?

00:08:00.510 --> 00:08:00.840
Everyone?

00:08:00.840 --> 00:08:01.270
Yeah.

00:08:01.270 --> 00:08:01.580
I see.

00:08:01.580 --> 00:08:02.910
YIGIT BOYAR: You're not
using data-binding, though.

00:08:02.910 --> 00:08:03.596
[LAUGHTER]

00:08:03.596 --> 00:08:04.721
You don't need null checks.

00:08:04.721 --> 00:08:05.827
GEORGE MOUNT: Yeah.

00:08:05.827 --> 00:08:06.785
YIGIT BOYAR: It's 2016.

00:08:06.785 --> 00:08:08.830
GEORGE MOUNT:
Yeah, that's right.

00:08:08.830 --> 00:08:10.080
Who has no pointer exceptions?

00:08:10.080 --> 00:08:10.490
I don't know.

00:08:10.490 --> 00:08:10.870
Nobody.

00:08:10.870 --> 00:08:12.110
YIGIT BOYAR: Which language?

00:08:12.110 --> 00:08:13.410
GEORGE MOUNT: And then it
finally sets the field.

00:08:13.410 --> 00:08:15.660
You can see here that it's
actually setting this field

00:08:15.660 --> 00:08:17.897
as an observable field.

00:08:17.897 --> 00:08:19.730
And actually, you might
be interested to see

00:08:19.730 --> 00:08:25.265
that this comment here is
actually in the generated code.

00:08:25.265 --> 00:08:27.390
So if you wanted to go look
at that generated code,

00:08:27.390 --> 00:08:28.889
you'll see this
comment and see what

00:08:28.889 --> 00:08:30.669
the inverse of
this expression is

00:08:30.669 --> 00:08:32.960
to help you try to debug if
you have a problem with it.

00:08:36.039 --> 00:08:39.130
So let's look at how you
get that field's value.

00:08:39.130 --> 00:08:41.080
We just saw that--
getting the field's value.

00:08:41.080 --> 00:08:43.960
And one thing to do is to
try to annotate the quickest

00:08:43.960 --> 00:08:52.040
annotation, which will give
you a getter for your view.

00:08:52.040 --> 00:08:54.000
So here we have
a text view type.

00:08:54.000 --> 00:08:59.130
And we want to know what is
the getter for android:text.

00:08:59.130 --> 00:09:00.420
Now, we have this method.

00:09:00.420 --> 00:09:01.425
We can just declare it.

00:09:01.425 --> 00:09:02.560
It's a getText.

00:09:02.560 --> 00:09:06.980
But if you don't supply
it, there's a default.

00:09:06.980 --> 00:09:08.790
And it just uses
the attribute name.

00:09:08.790 --> 00:09:11.350
So even if we didn't supply
anything, it would use getTest,

00:09:11.350 --> 00:09:15.210
because the attribute
is android:text.

00:09:15.210 --> 00:09:17.760
So it's kind of smart that way.

00:09:17.760 --> 00:09:20.770
And we have this
synthetic attribute.

00:09:20.770 --> 00:09:22.730
This is for the event.

00:09:22.730 --> 00:09:24.760
This is the event that
notifies that there's

00:09:24.760 --> 00:09:27.600
been a change in that view.

00:09:27.600 --> 00:09:29.832
And again, there's
a default here.

00:09:29.832 --> 00:09:31.540
If we didn't supply
anything, it would be

00:09:31.540 --> 00:09:34.470
android:textAttrChanged.

00:09:34.470 --> 00:09:36.740
So most of the time, you
wouldn't supply anything here

00:09:36.740 --> 00:09:38.190
at all.

00:09:38.190 --> 00:09:41.260
Now I want to talk a
little bit more about this.

00:09:41.260 --> 00:09:44.380
So we, of course, have
to get notifications

00:09:44.380 --> 00:09:46.490
from the text view.

00:09:46.490 --> 00:09:48.900
And so this is what you'd
normally do for a text view.

00:09:48.900 --> 00:09:50.480
You have to set a TextWatcher.

00:09:50.480 --> 00:09:53.330
And so we have these
event attributes

00:09:53.330 --> 00:09:55.790
in the binding adapter.

00:09:55.790 --> 00:09:59.570
And so we just add
this other attribute,

00:09:59.570 --> 00:10:00.600
the synthetic attribute.

00:10:00.600 --> 00:10:02.060
Now, the synthetic
attribute-- you

00:10:02.060 --> 00:10:03.740
can't use this in your layout.

00:10:03.740 --> 00:10:05.050
We check against it.

00:10:05.050 --> 00:10:07.750
So if you try to
do that, it's going

00:10:07.750 --> 00:10:12.720
to throw up a nice exception for
you or error message for you.

00:10:12.720 --> 00:10:16.054
But anyway, so you can now set
this in your binding adapter.

00:10:16.054 --> 00:10:17.720
And this is, of course,
all done for you

00:10:17.720 --> 00:10:19.727
for all the fields that work.

00:10:19.727 --> 00:10:21.310
And of course, what
do you have to do?

00:10:21.310 --> 00:10:22.970
You have to remove
the previous one,

00:10:22.970 --> 00:10:25.200
and then you have
to add a new one.

00:10:25.200 --> 00:10:28.140
And you have to notify them
only if they're not null, right?

00:10:28.140 --> 00:10:29.640
We don't want to
notify null things,

00:10:29.640 --> 00:10:33.232
because we, of course,
want to do null checking.

00:10:33.232 --> 00:10:35.440
And we also have to notify
our onChange [? Lister ?].

00:10:35.440 --> 00:10:38.490
So now we know that when
that text views changes,

00:10:38.490 --> 00:10:42.060
it's going to call our
generated onChange.

00:10:42.060 --> 00:10:44.920
Now, if you have a more
complex getter-- well,

00:10:44.920 --> 00:10:47.810
this is not very complex, but
this is a little more complex.

00:10:47.810 --> 00:10:52.180
The text view doesn't return
a string, it returns what?

00:10:52.180 --> 00:10:53.014
[INTERPOSING VOICES]

00:10:53.014 --> 00:10:53.804
GEORGE MOUNT: Yeah.

00:10:53.804 --> 00:10:54.990
Char sequence, right?

00:10:54.990 --> 00:10:57.135
And who here uses
char sequences?

00:10:57.135 --> 00:10:58.390
Ah, nobody uses char sequence.

00:10:58.390 --> 00:11:00.485
If you try to assign char
sequence to a string?

00:11:00.485 --> 00:11:01.620
Typecast error.

00:11:01.620 --> 00:11:03.550
So this is a little
more convenient.

00:11:03.550 --> 00:11:06.130
So you have a
getTextString, which

00:11:06.130 --> 00:11:10.937
will automatically convert your
char sequence into a string.

00:11:10.937 --> 00:11:13.020
And so this kind of thing
will help you with that.

00:11:13.020 --> 00:11:14.860
And again, we have
this attribute.

00:11:14.860 --> 00:11:17.750
And the other field is
also there-- the event.

00:11:17.750 --> 00:11:19.462
And it's automatically
defaulted.

00:11:19.462 --> 00:11:21.170
And we talked a little
about these cycles

00:11:21.170 --> 00:11:25.664
before, where if you have a
text view or an edit text,

00:11:25.664 --> 00:11:27.080
and it makes a
change, of course--

00:11:27.080 --> 00:11:29.320
it's going to change
your data field.

00:11:29.320 --> 00:11:31.300
And if you have a change
in the data field,

00:11:31.300 --> 00:11:33.264
it's going to change
your [? header ?] text.

00:11:33.264 --> 00:11:35.180
Now, that really sucks,
because what happened?

00:11:35.180 --> 00:11:38.970
User typed A, and now it just
set the text on that again,

00:11:38.970 --> 00:11:40.347
and you lost your cursor.

00:11:40.347 --> 00:11:41.316
YIGIT BOYAR: Oh!

00:11:41.316 --> 00:11:42.690
Yeah, something
you will realize.

00:11:42.690 --> 00:11:46.020
If you set the text on a text
view, it went to the same text.

00:11:46.020 --> 00:11:47.910
It'll still call
the change watchers,

00:11:47.910 --> 00:11:50.430
it'll still
[? have ?] the layout,

00:11:50.430 --> 00:11:53.032
because inside [INAUDIBLE]
actually a different

00:11:53.032 --> 00:11:53.990
[? spendable ?] string.

00:11:53.990 --> 00:11:56.650
It has some other format,
so we have to do that.

00:11:56.650 --> 00:11:57.600
GEORGE MOUNT: Yeah.

00:11:57.600 --> 00:11:59.350
YIGIT BOYAR: So
data-binding gets covered.

00:11:59.350 --> 00:12:00.140
How is that?

00:12:00.140 --> 00:12:01.556
GEORGE MOUNT: Well,
actually, it's

00:12:01.556 --> 00:12:04.414
going to do it more now,
because it just recognized

00:12:04.414 --> 00:12:05.580
that there's another change.

00:12:05.580 --> 00:12:07.530
And of course, it's going
to send another text change.

00:12:07.530 --> 00:12:09.290
And it's going to keep on
going on and on and on.

00:12:09.290 --> 00:12:10.360
And that kind of sucks.

00:12:10.360 --> 00:12:13.750
Nobody wants to see infinite
cycles in data binding.

00:12:13.750 --> 00:12:14.910
So let's solve it!

00:12:14.910 --> 00:12:17.930
We're gonna solve it
once and for all, right?

00:12:17.930 --> 00:12:19.902
Well, unfortunately, no.

00:12:19.902 --> 00:12:21.180
[LAUGHTER]

00:12:21.180 --> 00:12:23.260
But you can solve it.

00:12:23.260 --> 00:12:26.230
And we solve it for all
the ones we've implemented.

00:12:26.230 --> 00:12:28.704
You just have the check in
the binding adapter that says,

00:12:28.704 --> 00:12:31.245
when you've set the text field,
we checked the previous value

00:12:31.245 --> 00:12:33.480
and made sure that
it hasn't changed.

00:12:33.480 --> 00:12:35.490
If it has changed,
then we'll just set it.

00:12:35.490 --> 00:12:37.490
If it hasn't changed,
then we don't set it.

00:12:37.490 --> 00:12:39.669
And that breaks the
cycle before we can

00:12:39.669 --> 00:12:40.960
get this kind of infinite loop.

00:12:43.417 --> 00:12:45.000
YIGIT BOYAR: So this
kind of solutions

00:12:45.000 --> 00:12:46.280
we do in data binding.

00:12:46.280 --> 00:12:48.920
So changing the framework,
that's an option for us.

00:12:48.920 --> 00:12:50.950
But it'll only work
in the new devices.

00:12:50.950 --> 00:12:55.300
By doing these work-arounds, we
can support data binding API 7?

00:12:55.300 --> 00:12:57.620
GEORGE MOUNT: API
7, that's right.

00:12:57.620 --> 00:12:59.830
So does this work
on all attributes?

00:12:59.830 --> 00:13:00.530
Well, no.

00:13:00.530 --> 00:13:01.370
Clearly not.

00:13:01.370 --> 00:13:02.772
Because we need events.

00:13:02.772 --> 00:13:04.980
We need events to know
whether the field has changed,

00:13:04.980 --> 00:13:06.460
whether the attribute
has changed.

00:13:06.460 --> 00:13:07.834
And so we only
work with the ones

00:13:07.834 --> 00:13:11.610
that have change events,
so like TextWatcher,

00:13:11.610 --> 00:13:13.802
like CheckedChanged.

00:13:13.802 --> 00:13:15.010
So these are external events.

00:13:15.010 --> 00:13:18.030
These are not on
whatever changed events.

00:13:18.030 --> 00:13:21.090
So the good thing is
that almost everything

00:13:21.090 --> 00:13:24.635
you care about already has
a change notification on it.

00:13:24.635 --> 00:13:26.760
These are the things the
user's clicking on, right?

00:13:26.760 --> 00:13:29.000
They're typing in
the Edit field.

00:13:29.000 --> 00:13:29.770
So this is great.

00:13:29.770 --> 00:13:31.561
So we already have
notifications for these.

00:13:31.561 --> 00:13:33.750
So that will work for
almost all the attributes

00:13:33.750 --> 00:13:35.580
that you really care about.

00:13:35.580 --> 00:13:37.890
But if you have
your own fuse, you

00:13:37.890 --> 00:13:40.230
need to do this, have
an external event

00:13:40.230 --> 00:13:44.030
that you can set a listener on.

00:13:44.030 --> 00:13:44.820
All right.

00:13:44.820 --> 00:13:47.620
Let's talk a little bit
about expression chaining.

00:13:47.620 --> 00:13:51.920
Now, here I have a
layout with three views.

00:13:51.920 --> 00:13:55.434
And they all have the
same expression in it.

00:13:55.434 --> 00:13:57.922
It's kind of ugly code.

00:13:57.922 --> 00:14:01.340
Like, it's all UI code,
but it's a little ugly.

00:14:01.340 --> 00:14:03.630
And I really don't
want to do that.

00:14:03.630 --> 00:14:06.290
I'd like to have it once and
then re-use it elsewhere.

00:14:06.290 --> 00:14:11.600
So what I can do is create
an ID that I can later

00:14:11.600 --> 00:14:15.060
use in my other expressions.

00:14:15.060 --> 00:14:17.970
So now we could just
bind to another field.

00:14:17.970 --> 00:14:18.679
It's pretty nice.

00:14:18.679 --> 00:14:21.094
What it's doing under the hood,
of course, is just saying,

00:14:21.094 --> 00:14:22.716
oh, I recognize
that one, we already

00:14:22.716 --> 00:14:24.090
had a bound
expression there, I'm

00:14:24.090 --> 00:14:25.340
just going to substitute that.

00:14:28.872 --> 00:14:30.330
We also have implied
event updates.

00:14:30.330 --> 00:14:33.290
So you combined, for
example, to a checked field

00:14:33.290 --> 00:14:36.690
in another view, because checked
is a two-way data bind field.

00:14:36.690 --> 00:14:39.570
So we can just say, oh,
look, that field over there

00:14:39.570 --> 00:14:42.220
was-- the user
clicked on it, and we

00:14:42.220 --> 00:14:43.840
get an update right away.

00:14:43.840 --> 00:14:45.270
We know what happened.

00:14:45.270 --> 00:14:48.182
Let's talk a little bit
about lambda expressions.

00:14:48.182 --> 00:14:49.700
YIGIT BOYAR: So
two-way data binding

00:14:49.700 --> 00:14:53.200
is one way of grabbing
the data from the layout

00:14:53.200 --> 00:14:54.860
back to your data model.

00:14:54.860 --> 00:14:56.400
Another way is
the callback side.

00:14:56.400 --> 00:14:58.700
[INAUDIBLE] is you
get a view, you

00:14:58.700 --> 00:15:00.630
set a click list around that.

00:15:00.630 --> 00:15:02.780
So we wanted to make
it a little bit better.

00:15:02.780 --> 00:15:06.180
So in two days [? data, ?]
before we introduced this

00:15:06.180 --> 00:15:09.390
feature, what you will do with
data binding is that you would

00:15:09.390 --> 00:15:11.460
give the [? event ?] an ID.

00:15:11.460 --> 00:15:14.640
And then in your Java
code, you will get an ID

00:15:14.640 --> 00:15:15.690
from the binding.

00:15:15.690 --> 00:15:17.840
We already create
the view for you.

00:15:17.840 --> 00:15:20.280
And then you will set a
ClickListener on that.

00:15:20.280 --> 00:15:22.030
So we want to make it intuitive.

00:15:24.590 --> 00:15:25.860
We got rid of that.

00:15:25.860 --> 00:15:29.840
We introduced method references,
so that you could say,

00:15:29.840 --> 00:15:34.060
hey, we know
OnClick is an event.

00:15:34.060 --> 00:15:35.760
So where does this
presenter come from?

00:15:35.760 --> 00:15:37.718
The [INAUDIBLE] and other
variable you declare.

00:15:37.718 --> 00:15:39.050
So there's still no magic.

00:15:39.050 --> 00:15:41.580
It's not like the
OnClick event you

00:15:41.580 --> 00:15:45.140
have in the activity
in the framework.

00:15:45.140 --> 00:15:46.780
So in the Presenter,
what you would do

00:15:46.780 --> 00:15:49.289
is-- so we will [? tightly ?]
call this method.

00:15:49.289 --> 00:15:51.080
You will receive the
view, because onClick,

00:15:51.080 --> 00:15:53.890
as soon as it receives the
view, you will get the binding.

00:15:53.890 --> 00:15:55.560
So this is a cool method.

00:15:55.560 --> 00:15:58.580
Like data binding, it
has a findBinding method

00:15:58.580 --> 00:16:00.040
from any view.

00:16:00.040 --> 00:16:01.933
And you will get
the item from there

00:16:01.933 --> 00:16:04.700
and then do whatever you
want to do with that.

00:16:04.700 --> 00:16:07.230
But this is still a lot
of unnecessary code.

00:16:07.230 --> 00:16:09.840
So we wanted to make
this a little bit easier.

00:16:09.840 --> 00:16:13.520
We introduced
lambda expressions.

00:16:13.520 --> 00:16:15.050
So you get rid of that.

00:16:15.050 --> 00:16:18.870
You could instead just
say, when onClick happens,

00:16:18.870 --> 00:16:21.390
just call presenter.save
with the item.

00:16:21.390 --> 00:16:23.240
Where does the item come from?

00:16:23.240 --> 00:16:25.650
It's the item that
you declared there.

00:16:25.650 --> 00:16:28.030
So in your same method
in the presenter,

00:16:28.030 --> 00:16:31.120
like, you can do whatever you
want now you have the item.

00:16:31.120 --> 00:16:32.600
What is very cool--
actually, the

00:16:32.600 --> 00:16:36.160
reason why we pushed-- so
we had this in the timeline.

00:16:36.160 --> 00:16:37.960
But we pushed this
feature a little bit

00:16:37.960 --> 00:16:39.770
earlier, because
the testing team

00:16:39.770 --> 00:16:42.460
was releasing these
architectural demos

00:16:42.460 --> 00:16:43.453
from Google.

00:16:43.453 --> 00:16:46.790
And for the [? MDVM, ?] they
wanted something like this.

00:16:46.790 --> 00:16:51.100
When you do this, the presenter
has zero Android code.

00:16:51.100 --> 00:16:54.030
So your layout file handles
everything specific to Android.

00:16:54.030 --> 00:16:56.485
You can just test your
presenter the way you want this.

00:16:56.485 --> 00:16:58.410
It's so beautiful separation.

00:16:58.410 --> 00:17:00.730
It works very well and
makes it very clean.

00:17:00.730 --> 00:17:04.369
Another very cool thing here is
that in Android Studio today,

00:17:04.369 --> 00:17:09.920
you can go, roll over the same
function there, click on it,

00:17:09.920 --> 00:17:11.770
and go to the Presenter.

00:17:11.770 --> 00:17:15.619
So much easier to navigate the
code while we are developing.

00:17:15.619 --> 00:17:18.300
So I see [? lists ?] get
a little bit more details.

00:17:18.300 --> 00:17:20.569
So it's a lambda expression.

00:17:20.569 --> 00:17:21.980
You can also write this.

00:17:21.980 --> 00:17:24.180
The onClick receives a view.

00:17:24.180 --> 00:17:26.355
So if you look at the
description of the onClick

00:17:26.355 --> 00:17:29.216
callback class, this
is how it looks like.

00:17:29.216 --> 00:17:30.840
So you can actually
reference that view

00:17:30.840 --> 00:17:33.440
in the lambda expression
if you want to use it.

00:17:36.030 --> 00:17:38.790
And then the view inside the
expression refers to the one

00:17:38.790 --> 00:17:41.005
that you declared in
the Parameter section.

00:17:41.005 --> 00:17:45.630
So just like the Java,
eight lambda functions.

00:17:45.630 --> 00:17:47.470
And at least you
have-- you can actually

00:17:47.470 --> 00:17:48.760
name it whatever you want.

00:17:48.760 --> 00:17:53.210
So I named it v. The name
doesn't need to match anything.

00:17:53.210 --> 00:17:56.217
So let's look at the other
example, the FocusChange.

00:17:56.217 --> 00:17:58.050
So you want to know
when the FocusChange is.

00:17:58.050 --> 00:18:03.560
You want to call your presenter
with whatever the new focus is.

00:18:03.560 --> 00:18:05.030
Unfortunately, you
cannot do this,

00:18:05.030 --> 00:18:07.290
because if you look at
[? all ?] FocusChange methods

00:18:07.290 --> 00:18:10.540
or FocusChange clause, the
method receives the view

00:18:10.540 --> 00:18:12.240
and the focus state.

00:18:12.240 --> 00:18:16.200
So even if you don't want to
use the view clause, the v

00:18:16.200 --> 00:18:18.020
parameter, you
have to declare it.

00:18:18.020 --> 00:18:22.180
So the rule here is you either
declare all of the arguments

00:18:22.180 --> 00:18:26.030
that the method receives,
or you declare none.

00:18:26.030 --> 00:18:28.510
We figured out not
declaring [INAUDIBLE]

00:18:28.510 --> 00:18:29.520
very common use case.

00:18:29.520 --> 00:18:32.400
Like, in the ClickListener, you
almost never want to [? be ?]

00:18:32.400 --> 00:18:33.520
[? there ?] anyways.

00:18:33.520 --> 00:18:38.320
So we want to provide
that no-argument shortcut.

00:18:38.320 --> 00:18:40.380
Another example is onLongClick.

00:18:40.380 --> 00:18:42.140
Now, the difference
about onLongClick

00:18:42.140 --> 00:18:46.050
is it actually expects a
Boolean value as a result,

00:18:46.050 --> 00:18:49.030
so that we know we want
to populate it or not.

00:18:49.030 --> 00:18:52.640
So for this to
work, the presenter

00:18:52.640 --> 00:18:56.030
show many method-- also needs
to return a Boolean value.

00:18:56.030 --> 00:18:59.720
So we are not going to-- if
you put some lambda expression

00:18:59.720 --> 00:19:03.050
there that doesn't return the
value expected by the callback,

00:19:03.050 --> 00:19:04.360
it's not going to compile.

00:19:04.360 --> 00:19:07.580
We don't want to, you know, oh,
this, by default, return false.

00:19:07.580 --> 00:19:09.060
And something breaks
in the future.

00:19:09.060 --> 00:19:09.768
You have no idea.

00:19:09.768 --> 00:19:12.860
So if things don't match,
we don't try to do magic.

00:19:12.860 --> 00:19:14.770
We fail.

00:19:14.770 --> 00:19:17.070
So there is two ways
to do the same thing.

00:19:17.070 --> 00:19:19.920
There is the lambda expressions
and the method references.

00:19:19.920 --> 00:19:21.430
They are both useful.

00:19:21.430 --> 00:19:24.790
I want to go over what the
difference is, because they

00:19:24.790 --> 00:19:27.100
actually behave differently.

00:19:27.100 --> 00:19:29.920
So the major difference
between the two

00:19:29.920 --> 00:19:32.450
is lambda expressions
are evaluated

00:19:32.450 --> 00:19:33.490
when the event happens.

00:19:33.490 --> 00:19:36.540
So whatever expression
you put there,

00:19:36.540 --> 00:19:39.080
we evaluate it when user
clicks on a button, or the text

00:19:39.080 --> 00:19:40.970
changes, or whatever.

00:19:40.970 --> 00:19:42.770
The method references,
on the other hand,

00:19:42.770 --> 00:19:44.790
is evaluated by
me refresh the UI.

00:19:44.790 --> 00:19:47.605
When something is evaluated,
when we refresh the UI,

00:19:47.605 --> 00:19:49.710
we evaluate the
expression, we figure out

00:19:49.710 --> 00:19:52.750
which method wants to be
called, and set a ClickListener

00:19:52.750 --> 00:19:54.760
that directly references
that [? one. ?]

00:19:54.760 --> 00:19:56.415
So let's look at the example.

00:19:56.415 --> 00:19:58.010
It will be more clear.

00:19:58.010 --> 00:20:00.690
So the previous one
where we had a presenter,

00:20:00.690 --> 00:20:03.700
let's say I set it to null.

00:20:03.700 --> 00:20:05.560
And the presenters--
that same method

00:20:05.560 --> 00:20:08.750
was linked into the same button.

00:20:08.750 --> 00:20:11.350
So if we look at
saveButton.getClickListener,

00:20:11.350 --> 00:20:13.940
so in this case, when
the presenter is null,

00:20:13.940 --> 00:20:16.640
does the same button
have a ClickListener?

00:20:16.640 --> 00:20:19.990
If you are using
lambda expressions, no.

00:20:19.990 --> 00:20:22.100
It actually still
has a same button.

00:20:22.100 --> 00:20:23.680
Like, this not null.

00:20:23.680 --> 00:20:25.150
Even if you don't
have a presenter,

00:20:25.150 --> 00:20:27.960
there's a callback in that view.

00:20:27.960 --> 00:20:30.460
But if you are using method
references, yes, it's null.

00:20:30.460 --> 00:20:32.070
Like, we don't set it.

00:20:32.070 --> 00:20:34.580
So sometimes setting a view
clickable has side effects

00:20:34.580 --> 00:20:35.840
and is important for you.

00:20:35.840 --> 00:20:37.631
You will need to use
the method references.

00:20:40.000 --> 00:20:41.690
But we will take
care of [INAUDIBLE].

00:20:41.690 --> 00:20:44.180
So you are not going to crash
even if there's a callback.

00:20:44.180 --> 00:20:45.400
When the callback
[? grounds, ?] we

00:20:45.400 --> 00:20:46.983
will figure out there
is no presenter,

00:20:46.983 --> 00:20:49.604
and it will just drop it.

00:20:49.604 --> 00:20:52.970
So the way it works is when you
inflate the layout-- if you're

00:20:52.970 --> 00:20:55.640
using lambda expression,
we inflate the layout,

00:20:55.640 --> 00:20:56.970
we set the ClickListener.

00:20:56.970 --> 00:20:58.822
It belongs to us.

00:20:58.822 --> 00:21:01.280
And then when the click happens,
we evaluate the presenter,

00:21:01.280 --> 00:21:05.510
we evaluate the parameters,
and then run it.

00:21:05.510 --> 00:21:07.860
If you are using a
method reference, when

00:21:07.860 --> 00:21:10.010
we execute bindings,
this is the method

00:21:10.010 --> 00:21:11.935
that we generate
that updates the UI.

00:21:11.935 --> 00:21:15.320
When we run that method, we
will figure out the presenter.

00:21:15.320 --> 00:21:18.230
And if there is a
presenter, we will wrap it

00:21:18.230 --> 00:21:21.840
in a listener class, which
calls the related method.

00:21:21.840 --> 00:21:25.472
And if there is not, we
set the callback to null.

00:21:25.472 --> 00:21:26.930
And the listener
clause we generate

00:21:26.930 --> 00:21:28.960
looks like just something
simple like this.

00:21:28.960 --> 00:21:30.550
It receives the presenter.

00:21:30.550 --> 00:21:32.360
So we compare our
reference to that one.

00:21:32.360 --> 00:21:33.642
And then we can call it back.

00:21:33.642 --> 00:21:35.850
That presenter comes from
the presenter we evaluated.

00:21:38.570 --> 00:21:40.595
Another difference is
you can use expressions.

00:21:40.595 --> 00:21:43.000
This is the one we get
[? advantage ?] for lambda

00:21:43.000 --> 00:21:45.730
expressions-- that you can
use any expression inside

00:21:45.730 --> 00:21:48.680
the lambda versus you cannot
do that in method expressions.

00:21:48.680 --> 00:21:52.030
So you could say, like,
presenter.save(user.friend).

00:21:52.030 --> 00:21:54.270
And we will evaluate it.

00:21:54.270 --> 00:21:56.470
Or you could say,
like, data.presenter.

00:21:56.470 --> 00:21:59.190
Anything that's valid in data
binding, you can use it there,

00:21:59.190 --> 00:22:01.700
and we will evaluate it.

00:22:01.700 --> 00:22:05.440
Versus in method expressions,
you cannot do that.

00:22:05.440 --> 00:22:08.820
And the method has
to match the event.

00:22:08.820 --> 00:22:12.500
But you could still say, like,
data.presenter, same method.

00:22:12.500 --> 00:22:14.940
So you can have an expression
to the beginning of it,

00:22:14.940 --> 00:22:16.690
but you cannot change
the call parameters.

00:22:20.270 --> 00:22:22.310
The callback parameters--
in both of them,

00:22:22.310 --> 00:22:23.580
you can access it.

00:22:23.580 --> 00:22:25.080
So if you are using
a presenter, you

00:22:25.080 --> 00:22:26.621
have to declare it
yourself-- like, I

00:22:26.621 --> 00:22:28.060
want to access the view.

00:22:28.060 --> 00:22:30.500
So you declare the parameter.

00:22:30.500 --> 00:22:31.350
I'm sorry.

00:22:31.350 --> 00:22:32.780
Wrong button.

00:22:32.780 --> 00:22:35.680
And if you are using the method
references, it already works.

00:22:35.680 --> 00:22:38.224
It has to match.

00:22:38.224 --> 00:22:40.390
GEORGE MOUNT: Now, you can
use a few extra variables

00:22:40.390 --> 00:22:43.890
now in your lambda expressions
that you couldn't use before.

00:22:43.890 --> 00:22:46.170
One of them is view IDs.

00:22:46.170 --> 00:22:46.720
OK?

00:22:46.720 --> 00:22:49.680
You can reference your views
right in the expression.

00:22:49.680 --> 00:22:52.210
And it's your view ID,
and it's referenced

00:22:52.210 --> 00:22:54.380
as the camel-casified version.

00:22:54.380 --> 00:22:59.680
And this is the same field
that you use in your binding.

00:22:59.680 --> 00:23:03.736
So we camel-casify it just
the way we did before.

00:23:03.736 --> 00:23:05.110
And you can also
use the context.

00:23:05.110 --> 00:23:07.670
We found that many of
you wanted to access

00:23:07.670 --> 00:23:11.270
the context without
accessing a specific view.

00:23:11.270 --> 00:23:13.340
So we just give you the
context of the root.

00:23:13.340 --> 00:23:16.580
And you can use this as kind of
a generated, synthetic variable

00:23:16.580 --> 00:23:19.292
that you can use right
there in your layout.

00:23:19.292 --> 00:23:21.290
YIGIT BOYAR: But if
you create something

00:23:21.290 --> 00:23:23.535
that's called context,
then we won't do that.

00:23:23.535 --> 00:23:24.977
GEORGE MOUNT: Yeah,
don't do that.

00:23:24.977 --> 00:23:26.560
YIGIT BOYAR: But
please don't do that.

00:23:26.560 --> 00:23:27.780
[LAUGHTER]

00:23:27.780 --> 00:23:29.779
GEORGE MOUNT: Yeah, it
will override our context

00:23:29.779 --> 00:23:32.120
if you do that.

00:23:32.120 --> 00:23:33.940
All right, let's talk
about animations.

00:23:33.940 --> 00:23:35.018
Animations.

00:23:35.018 --> 00:23:37.226
Everyone wants to use
animations in their UIs, right?

00:23:37.226 --> 00:23:38.098
How many-- raise of hands.

00:23:38.098 --> 00:23:38.534
YIGIT BOYAR: Yeah!

00:23:38.534 --> 00:23:39.960
GEORGE MOUNT: That's right,
that's right. [INAUDIBLE].

00:23:39.960 --> 00:23:40.430
YIGIT BOYAR: Motion.

00:23:40.430 --> 00:23:42.440
GEORGE MOUNT: Get a
little motion in your UI.

00:23:42.440 --> 00:23:45.700
Well, one of the things
you see with data binding

00:23:45.700 --> 00:23:48.720
is without any kind
of a special work,

00:23:48.720 --> 00:23:50.920
you get this kind of
weird thing, where

00:23:50.920 --> 00:23:54.440
you click on something, and
it just pops into place.

00:23:54.440 --> 00:23:58.370
And that's kind of unfortunate.

00:23:58.370 --> 00:24:02.450
But we can do something pretty
simple to get a nice animation.

00:24:02.450 --> 00:24:03.820
And that's use transitions.

00:24:03.820 --> 00:24:05.640
How many of you use
transitions before?

00:24:05.640 --> 00:24:07.960
Yeah, this is something
introduced in KitKat.

00:24:07.960 --> 00:24:09.320
It's very useful.

00:24:09.320 --> 00:24:11.970
You get kind of automatic
animations with it.

00:24:11.970 --> 00:24:16.846
And what you can do is
add the onRebindCallback.

00:24:20.840 --> 00:24:24.341
One of the functions
there is the onPreBind.

00:24:24.341 --> 00:24:26.090
And that's the thing
we really care about.

00:24:26.090 --> 00:24:29.730
This is evaluated before
the binding happens,

00:24:29.730 --> 00:24:31.640
before the bindings
are evaluated.

00:24:31.640 --> 00:24:32.820
And we don't know
what's going to happen.

00:24:32.820 --> 00:24:34.320
We just know that
something is going

00:24:34.320 --> 00:24:36.970
to happen when this is called.

00:24:36.970 --> 00:24:38.692
And what we do is we
get the sceneRoot.

00:24:38.692 --> 00:24:40.900
And then, of course, call
the beginDelayedTransition.

00:24:40.900 --> 00:24:44.720
And then you get a nice effect.

00:24:44.720 --> 00:24:45.400
Pretty nice.

00:24:45.400 --> 00:24:46.350
Pretty easy.

00:24:46.350 --> 00:24:47.270
Pretty simple.

00:24:47.270 --> 00:24:49.726
YIGIT BOYAR: Maybe we
should make this an API.

00:24:49.726 --> 00:24:50.970
Enable animations.

00:24:50.970 --> 00:24:52.345
GEORGE MOUNT:
That's a good idea.

00:24:52.345 --> 00:24:53.970
Yeah, we should do that.

00:24:53.970 --> 00:24:56.020
But this doesn't
work with everything.

00:24:56.020 --> 00:24:58.370
Let's look at this ad here.

00:24:58.370 --> 00:25:01.020
When we change the
field here, which

00:25:01.020 --> 00:25:04.560
changes the age of the user,
it just still pops in and out.

00:25:04.560 --> 00:25:07.270
All right, our transition system
doesn't handle every transition

00:25:07.270 --> 00:25:08.440
you might want.

00:25:08.440 --> 00:25:11.550
It handles the most common
ones-- fading in and out,

00:25:11.550 --> 00:25:14.940
or changing the position of the
view, those kinds of things.

00:25:14.940 --> 00:25:16.606
And you can do your
own transitions,

00:25:16.606 --> 00:25:18.480
but sometimes you want
something very custom,

00:25:18.480 --> 00:25:21.110
and you just want to do
an animation for that.

00:25:21.110 --> 00:25:22.700
So what do you do?

00:25:22.700 --> 00:25:25.620
Well, in this case, what we
can do is do it with setting.

00:25:25.620 --> 00:25:28.140
When the value is
actually set on the field,

00:25:28.140 --> 00:25:32.850
we can capture the state there
and animate it ourselves.

00:25:32.850 --> 00:25:35.500
So we create this
BindingAdapter.

00:25:35.500 --> 00:25:38.570
And we, of course, get the
old value and the new value.

00:25:38.570 --> 00:25:40.861
You don't have to take the
old value if you don't want,

00:25:40.861 --> 00:25:42.520
but in this case, we do want it.

00:25:42.520 --> 00:25:45.320
And then of course, if nothing
has changed, we have to,

00:25:45.320 --> 00:25:47.240
of course, not do anything.

00:25:47.240 --> 00:25:49.590
We don't want to do anything
if nothing's changed.

00:25:49.590 --> 00:25:52.279
But then we can just animate
the change right then and there.

00:25:52.279 --> 00:25:54.070
And you can do whatever
animation you want.

00:25:54.070 --> 00:25:56.430
I don't know what you'd
want to do on a text field,

00:25:56.430 --> 00:25:57.725
but you can do whatever
you want there.

00:25:57.725 --> 00:25:58.433
Maybe cross-fade.

00:25:58.433 --> 00:25:59.230
I don't know.

00:25:59.230 --> 00:26:00.453
Dependency injection.

00:26:00.453 --> 00:26:01.005
All right.

00:26:01.005 --> 00:26:01.880
Again, show of hands.

00:26:01.880 --> 00:26:04.530
How many people love
dependency injection?

00:26:04.530 --> 00:26:05.030
All right.

00:26:05.030 --> 00:26:05.290
YIGIT BOYAR: Nice.

00:26:05.290 --> 00:26:05.580
GEORGE MOUNT: All right.

00:26:05.580 --> 00:26:06.320
This is you guys.

00:26:06.320 --> 00:26:07.432
This is for you.

00:26:07.432 --> 00:26:09.640
When you're writing tests,
of course, what do you do?

00:26:09.640 --> 00:26:15.250
When you're binding adaptors,
you have an if statement.

00:26:15.250 --> 00:26:18.850
If it's testing settings or
you're not testing settings,

00:26:18.850 --> 00:26:20.720
you could do one or the other.

00:26:20.720 --> 00:26:23.519
But we're dependency
injection fans.

00:26:23.519 --> 00:26:24.560
We don't want to do that.

00:26:24.560 --> 00:26:25.910
That sucks.

00:26:25.910 --> 00:26:30.000
So what we do is create
a binding adapter

00:26:30.000 --> 00:26:33.375
that is no longer static.

00:26:33.375 --> 00:26:35.000
So we have an abstract
binding adapter.

00:26:35.000 --> 00:26:36.583
Of course, this could
be an interface.

00:26:36.583 --> 00:26:39.130
It doesn't have to be
an abstract base class.

00:26:39.130 --> 00:26:43.410
And we implement that interface
with your test version

00:26:43.410 --> 00:26:47.780
or your production version.

00:26:47.780 --> 00:26:50.720
But we don't know
which instance to call.

00:26:50.720 --> 00:26:51.600
We're data binding.

00:26:51.600 --> 00:26:53.600
We don't know whether you
want to call something

00:26:53.600 --> 00:26:55.090
on your test or your production.

00:26:55.090 --> 00:26:58.030
And so we need to know
what you're going to do.

00:26:58.030 --> 00:27:00.190
So we create this
data-binding component.

00:27:00.190 --> 00:27:02.200
Whenever we see an
instance method like that,

00:27:02.200 --> 00:27:06.580
we know that you are going
to give us an instance.

00:27:06.580 --> 00:27:09.710
And so you implement
the component.

00:27:09.710 --> 00:27:11.980
This is a generated
data-binding component

00:27:11.980 --> 00:27:14.900
that has that
generated getter in it.

00:27:14.900 --> 00:27:16.800
And you implement that.

00:27:16.800 --> 00:27:22.080
And you do whatever you need
to do to get your component.

00:27:22.080 --> 00:27:23.580
But then you have
to set it as well.

00:27:23.580 --> 00:27:24.950
So this is the default setter.

00:27:24.950 --> 00:27:27.890
You can also do it on each
inflate call if you want.

00:27:27.890 --> 00:27:31.570
But probably, you only want
to use one or the other.

00:27:31.570 --> 00:27:37.000
But you can do it every time you
inflate a view or bind a view.

00:27:37.000 --> 00:27:40.330
But you can also do it when
you're in your static binding

00:27:40.330 --> 00:27:40.830
adapters.

00:27:40.830 --> 00:27:42.900
You don't have to do it
just when you're doing

00:27:42.900 --> 00:27:44.074
instance-binding adapters.

00:27:44.074 --> 00:27:46.240
Now, I'll show you an
instance where this is useful.

00:27:46.240 --> 00:27:49.200
So we have this system where
we're going to load an image.

00:27:49.200 --> 00:27:51.860
And we want to load the
image using an image loader.

00:27:51.860 --> 00:27:53.790
We have cached already.

00:27:53.790 --> 00:27:55.270
And we want to get
that ImageLoader

00:27:55.270 --> 00:27:56.390
instance, of course.

00:27:56.390 --> 00:27:58.950
So of course get the component.

00:27:58.950 --> 00:28:00.769
Well, where did that
component come from?

00:28:00.769 --> 00:28:02.560
Well, we could get the
context, and then we

00:28:02.560 --> 00:28:04.090
could try to find
it in the context

00:28:04.090 --> 00:28:05.900
by casting it and [INAUDIBLE].

00:28:05.900 --> 00:28:06.650
Kind of a pain.

00:28:06.650 --> 00:28:09.560
So instead, what we
want to do is introduce

00:28:09.560 --> 00:28:10.902
data-binding component.

00:28:10.902 --> 00:28:12.590
Of course, this is
our instance one

00:28:12.590 --> 00:28:14.970
that we have in our application.

00:28:14.970 --> 00:28:19.650
And we can introduce it right
there in our BindingAdapter.

00:28:19.650 --> 00:28:22.690
And then we can use it.

00:28:22.690 --> 00:28:26.130
If you're using Dagger 2, what
you do is you create a module

00:28:26.130 --> 00:28:28.126
and provide the method.

00:28:28.126 --> 00:28:30.500
And then you create a component,
and you set your default

00:28:30.500 --> 00:28:31.690
component just like that.

00:28:34.450 --> 00:28:35.820
All right.

00:28:35.820 --> 00:28:38.290
YIGIT BOYAR: So by the way,
if you're using data binding

00:28:38.290 --> 00:28:40.974
but did never write a binding
adapter, play with them.

00:28:40.974 --> 00:28:41.640
They're amazing.

00:28:41.640 --> 00:28:43.145
You can create your
own attributes.

00:28:43.145 --> 00:28:46.020
I'm seeing so many-- like,
we have to create them,

00:28:46.020 --> 00:28:48.000
so we can [? backport ?]
data binding.

00:28:48.000 --> 00:28:50.850
But they turn out to
be most widely abused,

00:28:50.850 --> 00:28:53.940
in a good way, features
of data binding.

00:28:53.940 --> 00:28:56.500
So one question we get
mainly is, how do I

00:28:56.500 --> 00:28:57.940
start using data binding?

00:28:57.940 --> 00:29:00.177
Because you already have an app.

00:29:00.177 --> 00:29:02.260
When you start from scratch,
yeah, it's very easy.

00:29:02.260 --> 00:29:03.890
But if you already
have an app, it

00:29:03.890 --> 00:29:06.599
doesn't make sense to
rewrite your layouts.

00:29:06.599 --> 00:29:07.640
This is unnecessary work.

00:29:07.640 --> 00:29:09.320
If it works, keep it.

00:29:09.320 --> 00:29:13.040
But in the new layouts, you
can start using data binding.

00:29:13.040 --> 00:29:16.190
So we wanted to go
through these levels.

00:29:16.190 --> 00:29:19.610
So to start using data binding,
you just enable it in Gradle.

00:29:19.610 --> 00:29:20.330
Super simple.

00:29:20.330 --> 00:29:22.480
Three lines.

00:29:22.480 --> 00:29:26.850
And then one thing you can start
doing today in any new layout

00:29:26.850 --> 00:29:29.360
you create is get to
the [? findViewById ?].

00:29:29.360 --> 00:29:31.540
There is like 25,
30 libraries that

00:29:31.540 --> 00:29:33.325
try to get to the
[? findViewById. ?]

00:29:33.325 --> 00:29:34.960
GEORGE MOUNT: Now it's 31.

00:29:34.960 --> 00:29:35.720
YIGIT BOYAR: Yeah.

00:29:35.720 --> 00:29:37.400
I think 31 is the last one.

00:29:37.400 --> 00:29:40.060
So I have never seen
anybody else creating it

00:29:40.060 --> 00:29:41.414
after we released data binding.

00:29:41.414 --> 00:29:43.330
This is like something
we should have released

00:29:43.330 --> 00:29:45.690
seven years ago,
like eight years ago,

00:29:45.690 --> 00:29:47.690
when we released Android

00:29:47.690 --> 00:29:52.450
So you just [? rep ?] your
layout into the layout tag,

00:29:52.450 --> 00:29:53.400
and then you are done.

00:29:53.400 --> 00:29:54.740
Nothing else you have to do.

00:29:54.740 --> 00:29:57.190
Now, with your code, you
had these findViewById

00:29:57.190 --> 00:29:59.980
or had these annotations
that you put on the views.

00:29:59.980 --> 00:30:01.460
You get rid of all of it.

00:30:01.460 --> 00:30:04.370
You get one binding
class for that layout,

00:30:04.370 --> 00:30:09.330
and it already has all the
views that has an ID as a field.

00:30:09.330 --> 00:30:11.530
These are public, final fields.

00:30:11.530 --> 00:30:12.850
And they are type-safe.

00:30:12.850 --> 00:30:14.470
Like, you don't need casting.

00:30:14.470 --> 00:30:17.330
If, by mistake-- like there is
one common mistake happens--

00:30:17.330 --> 00:30:19.670
is you use the same
ID in multiple places

00:30:19.670 --> 00:30:21.050
in different layouts.

00:30:21.050 --> 00:30:23.260
Someone changes an
ID in one place,

00:30:23.260 --> 00:30:25.370
your code doesn't crash
because the same ID

00:30:25.370 --> 00:30:26.847
was used somewhere else.

00:30:26.847 --> 00:30:29.180
But at runtime, you get a
crash, because you cannot find

00:30:29.180 --> 00:30:30.160
the view anymore.

00:30:30.160 --> 00:30:31.940
With data binding,
this cannot happen,

00:30:31.940 --> 00:30:33.780
because we create
them per layout.

00:30:33.780 --> 00:30:36.057
If someone, by mistake,
changes the ID,

00:30:36.057 --> 00:30:37.140
it's not going to compile.

00:30:40.570 --> 00:30:43.610
The second part is binding
the UI, this very simple way

00:30:43.610 --> 00:30:45.270
that you can start
using data binding.

00:30:45.270 --> 00:30:47.270
Actually, you should.

00:30:47.270 --> 00:30:50.660
In my opinion, it's no-brainer,
but of course, I'm biased.

00:30:50.660 --> 00:30:52.560
In every single UI,
you have this thing--

00:30:52.560 --> 00:30:54.750
like your presenter or whatever.

00:30:54.750 --> 00:30:58.110
Once you log the data,
you go through the data,

00:30:58.110 --> 00:31:00.980
go through your views,
and set each of them.

00:31:00.980 --> 00:31:02.490
You need to handle the null.

00:31:02.490 --> 00:31:03.940
No, you need to catch them.

00:31:03.940 --> 00:31:04.440
Blah, blah.

00:31:04.440 --> 00:31:06.440
This is just, like,
so an unnecessary code

00:31:06.440 --> 00:31:08.230
that you have to write.

00:31:08.230 --> 00:31:09.650
You don't need to write.

00:31:09.650 --> 00:31:13.110
So just get
[? rid of ?] those IDs.

00:31:13.110 --> 00:31:15.780
Declare your variable
in the layout.

00:31:15.780 --> 00:31:20.740
This is a layout to display
the specific information.

00:31:20.740 --> 00:31:22.520
It's totally
intuitive to declare

00:31:22.520 --> 00:31:24.770
the inputs of the layout there.

00:31:24.770 --> 00:31:27.270
So you say, this layout
displays the user.

00:31:27.270 --> 00:31:30.610
You define it and
you use it inside.

00:31:30.610 --> 00:31:32.640
So when someone
inflates your layout

00:31:32.640 --> 00:31:35.140
and wants to do [? only, ?]
they already the binding clause.

00:31:35.140 --> 00:31:36.431
They could see all the setters.

00:31:36.431 --> 00:31:40.570
They know what the input
is for that layout.

00:31:40.570 --> 00:31:43.900
And [INAUDIBLE] update UI
method to get rid of all of it,

00:31:43.900 --> 00:31:46.190
the only thing you do is
set it on the binding,

00:31:46.190 --> 00:31:47.510
and it takes care of it.

00:31:47.510 --> 00:31:50.960
All of this happens without
any performance penalty.

00:31:50.960 --> 00:31:52.890
The third thing is callbacks.

00:31:52.890 --> 00:31:56.600
There is always the case you get
the binding, you get the fab,

00:31:56.600 --> 00:31:58.540
and then set the ClickListener.

00:31:58.540 --> 00:32:00.800
This is also so unnecessary.

00:32:00.800 --> 00:32:02.930
Just declare the presenters.

00:32:02.930 --> 00:32:06.110
Just say, when this button
is clicked, call this thing.

00:32:06.110 --> 00:32:08.806
The nice thing about this
implementation is you can just,

00:32:08.806 --> 00:32:11.180
when you are in Android Studio--
it happens all the time,

00:32:11.180 --> 00:32:12.330
s You go into a layout.

00:32:12.330 --> 00:32:14.670
OK, what happens if
user clicks and you

00:32:14.670 --> 00:32:18.545
try to search references
of that view ID

00:32:18.545 --> 00:32:20.270
and then see where
the ClickListener is.

00:32:20.270 --> 00:32:21.832
There's a couple of steps.

00:32:21.832 --> 00:32:23.790
Here, you can just click
and go to that method,

00:32:23.790 --> 00:32:24.895
and find implementation.

00:32:28.340 --> 00:32:31.380
So especially if you
are starting a new app

00:32:31.380 --> 00:32:34.960
from scratch, observability
might be very, very handy.

00:32:34.960 --> 00:32:37.800
So instead of having
this simple user clause,

00:32:37.800 --> 00:32:40.380
you could make extend
BaseObservable.

00:32:40.380 --> 00:32:43.150
There's also an interface if
you don't want the extend.

00:32:43.150 --> 00:32:45.710
You make it bindable.

00:32:45.710 --> 00:32:47.570
And then whenever
the value changes,

00:32:47.570 --> 00:32:49.240
you want to find this change.

00:32:49.240 --> 00:32:53.210
And we will take care
of updating the UI.

00:32:53.210 --> 00:32:56.382
And there is one of the
new features-- I highly

00:32:56.382 --> 00:32:58.340
recommend is the features
two-way data binding.

00:32:58.340 --> 00:33:01.340
Now, two-way data binding
when you have complex model

00:33:01.340 --> 00:33:03.190
is not very easy to use.

00:33:03.190 --> 00:33:05.500
But like all of us
have login forms--

00:33:05.500 --> 00:33:08.230
all these simple
form kind of layouts

00:33:08.230 --> 00:33:09.952
that people has to fill.

00:33:09.952 --> 00:33:13.056
And there's a lot of
logic going in there.

00:33:13.056 --> 00:33:14.430
Instead of writing
that code, you

00:33:14.430 --> 00:33:17.980
can just let two-way
binding handle all of it

00:33:17.980 --> 00:33:19.480
and return your object.

00:33:19.480 --> 00:33:23.270
So for a layout like
this, all you [INAUDIBLE]

00:33:23.270 --> 00:33:25.610
is create the smaller
class, make all of them

00:33:25.610 --> 00:33:26.490
observable field.

00:33:26.490 --> 00:33:28.900
Like, you have only one
instance of that clause.

00:33:28.900 --> 00:33:30.850
It doesn't matter
how expensive it is.

00:33:30.850 --> 00:33:34.070
So make everything
observable fields.

00:33:34.070 --> 00:33:37.410
And then when we do that, our
layout will look like this.

00:33:37.410 --> 00:33:40.630
We have real data
that enables, disables

00:33:40.630 --> 00:33:42.270
the button or whatever logic.

00:33:42.270 --> 00:33:44.356
And you have the form model.

00:33:44.356 --> 00:33:49.140
And for each of the input
fields, you use them.

00:33:49.140 --> 00:33:50.920
So you say, this is the name.

00:33:50.920 --> 00:33:53.390
Notice that it's
a two-way binding.

00:33:53.390 --> 00:33:54.460
Or you have a button.

00:33:54.460 --> 00:34:00.480
You say if my real data model
enables it, make it enabled.

00:34:00.480 --> 00:34:00.980
You do this.

00:34:00.980 --> 00:34:03.217
So you cannot do this
in every single layout,

00:34:03.217 --> 00:34:04.300
so you need to be careful.

00:34:04.300 --> 00:34:08.929
Bu something that you can
encapsulate-- it's about forms,

00:34:08.929 --> 00:34:11.031
or [INAUDIBLE] place
you want to grab

00:34:11.031 --> 00:34:13.159
data-- it's so much
cleaner, so much simpler,

00:34:13.159 --> 00:34:15.940
and you will save time.

00:34:15.940 --> 00:34:17.420
So just do this.

00:34:17.420 --> 00:34:19.895
So now you have a binding
layout that gives you

00:34:19.895 --> 00:34:21.710
an object that has the data.

00:34:21.710 --> 00:34:25.840
And then you do whatever you
want to do with that data.

00:34:25.840 --> 00:34:28.739
So let me quickly go through
some of the best practices,

00:34:28.739 --> 00:34:31.520
because data binding
is very powerful.

00:34:31.520 --> 00:34:34.699
But just because there's a way
to do things with data binding

00:34:34.699 --> 00:34:38.110
does not mean that you should
do everything with data binding.

00:34:38.110 --> 00:34:41.810
So something you need to be
careful when using data binding

00:34:41.810 --> 00:34:44.960
is what expressions
you put there.

00:34:44.960 --> 00:34:47.070
So if you put an expression
like the [? same ?]

00:34:47.070 --> 00:34:50.000
and user click this
button, send the money,

00:34:50.000 --> 00:34:51.760
you should not do this.

00:34:51.760 --> 00:34:54.780
Like, it's so wrong,
because sending the money

00:34:54.780 --> 00:34:56.580
is completely about
your application.

00:34:56.580 --> 00:34:58.260
This is like it's
your business logic.

00:34:58.260 --> 00:35:00.520
It has nothing to
do with your UI.

00:35:00.520 --> 00:35:03.110
The only thing you
care about is that user

00:35:03.110 --> 00:35:04.840
clicked on that button.

00:35:04.840 --> 00:35:08.330
This is where the responsibility
of data binding stops.

00:35:08.330 --> 00:35:09.580
So you get rid of this.

00:35:09.580 --> 00:35:10.580
Don't do that.

00:35:10.580 --> 00:35:13.780
Instead, put something like
presenter::onSendClick,

00:35:13.780 --> 00:35:16.872
so that presenter clause
can be tested by itself.

00:35:16.872 --> 00:35:21.030
And then you will have
a reliable application.

00:35:21.030 --> 00:35:23.280
I know it's not very clear
where you want to stop.

00:35:23.280 --> 00:35:26.890
Like how much can I
data-bind, and how much

00:35:26.890 --> 00:35:28.550
I should do in the Java code?

00:35:28.550 --> 00:35:30.260
Well, you use your intuition.

00:35:30.260 --> 00:35:32.144
You know, use what
works best for you.

00:35:32.144 --> 00:35:34.060
GEORGE MOUNT: So you're
saying change the name

00:35:34.060 --> 00:35:35.660
of our function, right?

00:35:35.660 --> 00:35:36.550
YIGIT BOYAR: Yeah,
that was the goal.

00:35:36.550 --> 00:35:37.070
GEORGE MOUNT: Yeah, yeah, OK.

00:35:37.070 --> 00:35:38.903
YIGIT BOYAR: Don't call
[? our ?] functions.

00:35:38.903 --> 00:35:39.720
Use [INAUDIBLE].

00:35:39.720 --> 00:35:40.511
That will solve it.

00:35:40.511 --> 00:35:41.636
[LAUGHTER]

00:35:41.636 --> 00:35:43.730
But anyway, data binding
works with program,

00:35:43.730 --> 00:35:47.240
because we do everything in the
compile time [? set ?] detail.

00:35:47.240 --> 00:35:50.540
So another thing
is if it is related

00:35:50.540 --> 00:35:51.950
to UI, just put it there.

00:35:51.950 --> 00:35:53.874
You don't need to oh,
my god, I shouldn't put

00:35:53.874 --> 00:35:55.040
any logic in my [INAUDIBLE].

00:35:55.040 --> 00:35:57.170
It's like that doesn't
make any sense.

00:35:57.170 --> 00:36:00.260
If it is about how that
layout looks, if it is simple,

00:36:00.260 --> 00:36:02.280
just keep it there,
because the important thing

00:36:02.280 --> 00:36:04.150
is when you look
at that layout file

00:36:04.150 --> 00:36:06.470
three months after
in Android Studio,

00:36:06.470 --> 00:36:08.994
then you have an idea
what that layout does.

00:36:08.994 --> 00:36:09.910
That's the point here.

00:36:09.910 --> 00:36:12.420
Like, they should
be declarative,

00:36:12.420 --> 00:36:15.460
they should explain themselves.

00:36:15.460 --> 00:36:19.190
But if you put an
expression like this there,

00:36:19.190 --> 00:36:22.310
there is no way you read it
and understand what it's doing.

00:36:22.310 --> 00:36:23.380
It's just confusing.

00:36:23.380 --> 00:36:24.910
Don't do something like this.

00:36:24.910 --> 00:36:26.960
They need to be
simple expressions.

00:36:26.960 --> 00:36:29.010
So get rid of it.

00:36:29.010 --> 00:36:32.970
Like, create a method
that gives a short name.

00:36:32.970 --> 00:36:34.640
And then use that one instead.

00:36:34.640 --> 00:36:36.657
If they are not
readable-- if you realize

00:36:36.657 --> 00:36:38.490
they are getting long,
then you are probably

00:36:38.490 --> 00:36:40.130
doing something wrong.

00:36:40.130 --> 00:36:41.320
So it's a method we created.

00:36:41.320 --> 00:36:43.611
GEORGE MOUNT: Yeah, we can
also-- something to mention,

00:36:43.611 --> 00:36:47.060
though, is we can also do
string functions there.

00:36:47.060 --> 00:36:49.210
So if you want to do
string substitutions,

00:36:49.210 --> 00:36:51.876
you can use the string formatter
right there in your expressions

00:36:51.876 --> 00:36:53.504
as well.

00:36:53.504 --> 00:36:55.420
YIGIT BOYAR: So another
thing is RecyclerView.

00:36:55.420 --> 00:36:57.400
By the way, two
days ago, we just

00:36:57.400 --> 00:37:01.610
published a sample application
that uses data binding

00:37:01.610 --> 00:37:03.290
and RecyclerView on GitHub.

00:37:03.290 --> 00:37:07.070
And I sent it into the Spaces
link, so you can find it there.

00:37:07.070 --> 00:37:09.140
But one thing you
need to be careful of

00:37:09.140 --> 00:37:12.010
is if you are using data binding
with RecyclerView, which you

00:37:12.010 --> 00:37:14.756
should because it generates
the [? view ?] holder for you,

00:37:14.756 --> 00:37:17.140
when you bind a view,
you should always

00:37:17.140 --> 00:37:19.090
call executePendingBindings.

00:37:19.090 --> 00:37:21.660
If you don't do this,
binding will defer it

00:37:21.660 --> 00:37:24.510
until the next layout and
RecyclerView will get unhappy,

00:37:24.510 --> 00:37:27.580
because the view didn't
tell us what the height is.

00:37:27.580 --> 00:37:28.830
So there's a couple of things.

00:37:28.830 --> 00:37:30.660
These are a couple
of little examples

00:37:30.660 --> 00:37:33.540
that people did with
binding adapters mostly.

00:37:33.540 --> 00:37:35.760
Wanted to mention them.

00:37:35.760 --> 00:37:36.810
You can do this.

00:37:36.810 --> 00:37:37.980
This is like HTML.

00:37:37.980 --> 00:37:41.135
I have a text view,
and it's an image URL.

00:37:41.135 --> 00:37:43.730
Well, that should be
probably imageView.

00:37:43.730 --> 00:37:45.624
But it's an image URL.

00:37:45.624 --> 00:37:47.666
And then it just works.

00:37:47.666 --> 00:37:48.790
You have a binding adapter.

00:37:48.790 --> 00:37:49.894
You paste it to there.

00:37:49.894 --> 00:37:51.560
Everything is fine
properly [INAUDIBLE].

00:37:51.560 --> 00:37:54.786
And you know what
that image shows.

00:37:54.786 --> 00:37:56.160
You don't need
the ID or whatever

00:37:56.160 --> 00:37:58.930
to make it self-explanatory.

00:37:58.930 --> 00:38:01.180
It's invisible.

00:38:01.180 --> 00:38:03.571
Oh, here is an image URL.

00:38:03.571 --> 00:38:05.590
So you can have
multiple parameters.

00:38:05.590 --> 00:38:08.040
Binding adapters can
receive multiple parameters.

00:38:08.040 --> 00:38:10.630
You could say, OK,
this is the placeholder

00:38:10.630 --> 00:38:11.800
and this is the image URL.

00:38:11.800 --> 00:38:14.532
You have a binding adapter that
receives these two attributes.

00:38:14.532 --> 00:38:17.130
We call it with
these two values.

00:38:17.130 --> 00:38:19.770
We [? call it ?] drawable,
and it's an actual drawable.

00:38:19.770 --> 00:38:21.520
You don't need to
do it yourself.

00:38:21.520 --> 00:38:23.610
And you can
[? name ?] your logic.

00:38:23.610 --> 00:38:28.020
It works very well with testing,
because in testing, you just

00:38:28.020 --> 00:38:30.590
provide a dummy adapter
that doesn't do anything.

00:38:30.590 --> 00:38:32.690
And then now all
your tests run faster

00:38:32.690 --> 00:38:35.460
without making
that work request.

00:38:35.460 --> 00:38:36.650
The other thing-- font.

00:38:36.650 --> 00:38:40.300
This has been requested on
the text view for many years.

00:38:40.300 --> 00:38:43.480
We haven't [? invented ?]
it until data binding.

00:38:43.480 --> 00:38:47.570
Now, you could just create
your own attributes,

00:38:47.570 --> 00:38:50.080
call it app:font,
and then it works.

00:38:50.080 --> 00:38:51.840
There's actually a
project on GitHub

00:38:51.840 --> 00:38:54.152
from [? Lisa ?] that does this.

00:38:54.152 --> 00:38:55.120
It's super cool.

00:38:55.120 --> 00:38:57.932
Super convenient.

00:38:57.932 --> 00:39:00.200
And you could use
vector drawables.

00:39:00.200 --> 00:39:02.650
So [? now ?] today you cannot
use vector drawables in XML,

00:39:02.650 --> 00:39:03.150
right?

00:39:03.150 --> 00:39:03.810
No.

00:39:03.810 --> 00:39:06.435
If you use data binding, you can
actually use vector drawables.

00:39:06.435 --> 00:39:09.740
You just create the binding
adapter for that and do it.

00:39:09.740 --> 00:39:12.070
Another one here
is-- like, it's so

00:39:12.070 --> 00:39:13.715
common in applications
[INAUDIBLE]

00:39:13.715 --> 00:39:15.630
dimension image margin.

00:39:15.630 --> 00:39:20.540
And then you have something
like a dimension picture size.

00:39:20.540 --> 00:39:22.990
Dimension picture size
and picture margin,

00:39:22.990 --> 00:39:24.570
so that you could
align your views.

00:39:24.570 --> 00:39:26.190
So you create all
these dimensions,

00:39:26.190 --> 00:39:27.760
you don't need too many more.

00:39:27.760 --> 00:39:30.110
You can just use data
binding to say, hey,

00:39:30.110 --> 00:39:32.180
this thing is picture
size plus picture margin.

00:39:32.180 --> 00:39:33.372
That's it.

00:39:33.372 --> 00:39:35.330
It's like, this should
have been there already.

00:39:35.330 --> 00:39:36.470
But it wasn't.

00:39:36.470 --> 00:39:36.970
All right.

00:39:36.970 --> 00:39:40.240
So once you start
experimenting, these

00:39:40.240 --> 00:39:42.750
are things we did
not think about.

00:39:42.750 --> 00:39:43.910
Remember the image URL.

00:39:43.910 --> 00:39:46.410
There was something we thought
[? about. ?] And that was it.

00:39:46.410 --> 00:39:50.870
People came up with this
font, the margin thing.

00:39:50.870 --> 00:39:53.090
It's just new stuff you
can do with data binding.

00:39:53.090 --> 00:39:55.020
So go on, explore
[? around with ?] it.

00:39:55.020 --> 00:39:55.650
Thank you.

00:39:55.650 --> 00:39:56.650
GEORGE MOUNT: Thank you.

00:39:56.650 --> 00:39:58.490
[APPLAUSE]

00:39:59.690 --> 00:40:03.340
[MUSIC PLAYING]

