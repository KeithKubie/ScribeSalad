WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:02.730
MALE SPEAKER: So next up
we have Mr. Jake Archibald,

00:00:02.730 --> 00:00:04.650
who you met before.

00:00:04.650 --> 00:00:07.290
Jake is a long time
front end developer.

00:00:07.290 --> 00:00:11.155
He originally worked on the
Glow library at the BBC.

00:00:11.155 --> 00:00:14.900
It was kind of like a competitor
to jQuery sort of back

00:00:14.900 --> 00:00:18.000
then because they
needed IE 5.5 support.

00:00:18.000 --> 00:00:18.854
Is that the reason?

00:00:18.854 --> 00:00:19.770
JAKE ARCHIBALD: And 5.

00:00:19.770 --> 00:00:20.660
MALE SPEAKER: Yeah, and 5.

00:00:20.660 --> 00:00:21.340
IE 5 support.

00:00:21.340 --> 00:00:23.460
Yeah, this was good.

00:00:23.460 --> 00:00:26.780
He also is an expert
in @font-face.

00:00:26.780 --> 00:00:29.000
He made a fantastic
offline tool for creating

00:00:29.000 --> 00:00:31.020
CSS sprites called Sprite Cow.

00:00:31.020 --> 00:00:35.090
He developed a technique for
including IE specific styles

00:00:35.090 --> 00:00:38.770
with Sass IE, naturally.

00:00:38.770 --> 00:00:41.770
More recently, you might
know him from his work

00:00:41.770 --> 00:00:43.190
with the Application
Cache, where

00:00:43.190 --> 00:00:45.705
he wrote a number of
articles and talks.

00:00:45.705 --> 00:00:48.080
And today, he's going to be
telling you a little bit more

00:00:48.080 --> 00:00:49.500
about ServiceWorker.

00:00:49.500 --> 00:00:51.406
So, Jake Archibald.

00:00:51.406 --> 00:00:52.372
JAKE ARCHIBALD: Hey.

00:00:52.372 --> 00:00:56.240
[APPLAUSE]

00:00:56.240 --> 00:00:59.519
So I couldn't help notice that
in Mat's list of talks there

00:00:59.519 --> 00:01:01.810
that you should pay attention
to, mine wasn't on there.

00:01:01.810 --> 00:01:05.459
So no Christmas card
for you this year.

00:01:05.459 --> 00:01:08.404
So making stuff work offline
used to be very easy, right?

00:01:08.404 --> 00:01:10.070
I mean, it's only
really become an issue

00:01:10.070 --> 00:01:11.770
since the advent
of the internet.

00:01:11.770 --> 00:01:14.980
Before that, you had everything
you needed in front of you.

00:01:14.980 --> 00:01:16.730
You had the machine
that was going

00:01:16.730 --> 00:01:19.210
to do 100% of the
processing, and you

00:01:19.210 --> 00:01:21.424
had the thing that was
going to be processed.

00:01:21.424 --> 00:01:23.090
This is the first
computer I ever owned.

00:01:23.090 --> 00:01:24.210
And we should have audio here.

00:01:24.210 --> 00:01:24.980
Oh, we do a little bit.

00:01:24.980 --> 00:01:25.480
[BEEPING]

00:01:25.480 --> 00:01:27.410
And these were the
sights and sounds

00:01:27.410 --> 00:01:29.206
you would get just
to do something

00:01:29.206 --> 00:01:30.830
like render a simple
image on the page.

00:01:30.830 --> 00:01:33.360
And I got this working on a
Spectrum emulator last week,

00:01:33.360 --> 00:01:35.440
and it's the most
fun I've had in ages.

00:01:35.440 --> 00:01:37.381
And I uploaded it to
YouTube, the full video.

00:01:37.381 --> 00:01:38.880
And someone actually
took the audio,

00:01:38.880 --> 00:01:40.910
recorded it onto a
cassette, and played it

00:01:40.910 --> 00:01:42.180
in a real ZX Spectrum.

00:01:42.180 --> 00:01:42.850
And it worked.

00:01:42.850 --> 00:01:44.232
Well, it crashed
at the very end.

00:01:44.232 --> 00:01:45.940
But for me, that makes
it more authentic.

00:01:45.940 --> 00:01:48.490
It was great.

00:01:48.490 --> 00:01:50.940
But in these days--
the only thing

00:01:50.940 --> 00:01:53.980
you needed from outside the
building was electricity.

00:01:53.980 --> 00:01:56.740
And that came from beyond the
wall, wherever it comes from.

00:01:56.740 --> 00:02:00.200
As long as that stream was
constant, then you were gold.

00:02:00.200 --> 00:02:01.320
Everything would work.

00:02:01.320 --> 00:02:02.690
But then we got another stream.

00:02:02.690 --> 00:02:04.481
We got another stream
from beyond the wall,

00:02:04.481 --> 00:02:06.316
the internet, data on demand.

00:02:06.316 --> 00:02:08.440
It looks like people were
terrified of it at first.

00:02:08.440 --> 00:02:09.650
But not anymore.

00:02:09.650 --> 00:02:11.960
In fact, now, even things
that are kind of built

00:02:11.960 --> 00:02:15.250
around physical media, they
can't resist a delicious slurp

00:02:15.250 --> 00:02:17.280
of internet before
they'll do anything.

00:02:17.280 --> 00:02:20.667
I don't-- I didn't buy
new games for the PS3.

00:02:20.667 --> 00:02:23.000
Because you would go through
this every couple of months

00:02:23.000 --> 00:02:24.870
where every time you would
try and play the game,

00:02:24.870 --> 00:02:26.370
it wanted to connect
to the internet

00:02:26.370 --> 00:02:27.810
and download a 50
megabyte update.

00:02:27.810 --> 00:02:29.490
And I just wanted
to play a game.

00:02:29.490 --> 00:02:31.380
And they do automatic
updates now.

00:02:31.380 --> 00:02:33.602
It's about time, really.

00:02:33.602 --> 00:02:35.060
Yeah, I just want
to play the game.

00:02:35.060 --> 00:02:37.230
I've got the disk
here in my hand.

00:02:37.230 --> 00:02:38.960
These days, most
devices will ship

00:02:38.960 --> 00:02:41.780
with a cache for
electricity which

00:02:41.780 --> 00:02:43.700
can be used when the
stream isn't available.

00:02:43.700 --> 00:02:45.230
And we call it a battery.

00:02:45.230 --> 00:02:48.500
In fact, as we've become less
reliant on this electricity

00:02:48.500 --> 00:02:52.340
stream, we've become more
reliant on the internet stream,

00:02:52.340 --> 00:02:54.380
especially on the web.

00:02:54.380 --> 00:02:56.200
I became very aware
of this back when

00:02:56.200 --> 00:02:58.230
I worked at a small agency.

00:02:58.230 --> 00:03:01.570
You see, one day I needed
to go to the toilet.

00:03:01.570 --> 00:03:04.261
And there were five cubicles
for me to choose from.

00:03:04.261 --> 00:03:05.760
But unfortunately,
on this instance,

00:03:05.760 --> 00:03:07.640
the first four were occupied.

00:03:07.640 --> 00:03:08.930
And that's usually OK.

00:03:08.930 --> 00:03:12.670
I tend to only need
one toilet per visit.

00:03:12.670 --> 00:03:14.400
But I knew from
previous experience

00:03:14.400 --> 00:03:19.270
that the office Wi-Fi only
extended to the first four.

00:03:19.270 --> 00:03:21.475
And there's no mobile
data in there either.

00:03:21.475 --> 00:03:22.600
And I thought for a moment.

00:03:22.600 --> 00:03:24.580
And I was like, no.

00:03:24.580 --> 00:03:26.820
No, I don't consider
this good enough anymore.

00:03:26.820 --> 00:03:29.690
As a human being,
it's my right to have

00:03:29.690 --> 00:03:32.151
internet when I
go to the toilet.

00:03:32.151 --> 00:03:33.900
I've been using this
joke for a while now.

00:03:33.900 --> 00:03:35.920
But it comes with
an important update.

00:03:35.920 --> 00:03:38.150
In the Google offices--
or certainly in the UK--

00:03:38.150 --> 00:03:40.440
the situation is much worse.

00:03:40.440 --> 00:03:42.610
We have no data
at all, completely

00:03:42.610 --> 00:03:46.069
data-less to the point where
saying, I'm just going offline,

00:03:46.069 --> 00:03:47.360
has become a kind of euphemism.

00:03:51.130 --> 00:03:52.510
Of course, there
are other places

00:03:52.510 --> 00:03:54.890
without internet, like large
parts of my daily commute

00:03:54.890 --> 00:03:57.015
because I get the train in
through the countryside,

00:03:57.015 --> 00:03:59.720
underground systems of course,
planes, international roaming.

00:03:59.720 --> 00:04:02.530
You have data, but it's
too expensive to use.

00:04:02.530 --> 00:04:05.300
Have we lost something
through this data dependency?

00:04:05.300 --> 00:04:07.920
Wouldn't it be great if things
like Wikipedia or Google

00:04:07.920 --> 00:04:11.240
Maps and YouTube were once
again resilient to fluctuations

00:04:11.240 --> 00:04:12.740
in connectivity?

00:04:12.740 --> 00:04:16.120
Well, as a community,
we thought so.

00:04:16.120 --> 00:04:17.610
And we asked for a solution.

00:04:17.610 --> 00:04:22.820
And thus, we received
the Application Cache.

00:04:22.820 --> 00:04:24.520
How did that turn out?

00:04:24.520 --> 00:04:27.340
I have voiced my opinions
on AppCache before.

00:04:27.340 --> 00:04:30.200
But today, I would like to
defer to the philosopher Andre

00:04:30.200 --> 00:04:34.990
the Giant from then
WWF, who said this.

00:04:34.990 --> 00:04:36.844
I don't like to speak
badly of people.

00:04:36.844 --> 00:04:39.260
I have grown up thinking and
being told that if you cannot

00:04:39.260 --> 00:04:41.020
say something nice
about someone,

00:04:41.020 --> 00:04:43.530
you should not say
anything at all.

00:04:43.530 --> 00:04:44.940
Yeah.

00:04:44.940 --> 00:04:47.060
Oh, but I must break
that rule in this case

00:04:47.060 --> 00:04:49.886
because I hate Hulk
Hogan very much.

00:04:49.886 --> 00:04:53.710
He is a big ugly goon, and
I want to squash his face.

00:04:53.710 --> 00:04:54.680
Yeah.

00:04:54.680 --> 00:04:56.530
AppCache needs
squashed in the face.

00:04:56.530 --> 00:04:58.520
The problem with AppCache
is it's like this.

00:04:58.520 --> 00:05:03.410
It looks so simple, so inviting,
so easy to get started.

00:05:03.410 --> 00:05:09.600
But it comes with an instruction
manual, and it's huge.

00:05:09.600 --> 00:05:11.740
And if you don't read it
all and remember it all,

00:05:11.740 --> 00:05:14.360
you will be caught out.

00:05:14.360 --> 00:05:16.350
If I make an HTML
page, and point it

00:05:16.350 --> 00:05:19.849
at a manifest like this
and list some files in it,

00:05:19.849 --> 00:05:22.390
and it'll be cached and it'll
work offline, and that's great.

00:05:22.390 --> 00:05:25.450
But any page that points at
the manifest, just index HTML5

00:05:25.450 --> 00:05:28.780
here-- that will automatically
become part of the cache.

00:05:28.780 --> 00:05:29.940
And that counts per URL.

00:05:29.940 --> 00:05:32.190
So if the URL just has a
change in the query string,

00:05:32.190 --> 00:05:34.090
that's a new thing that will
be automatically cached.

00:05:34.090 --> 00:05:35.994
And this will just
build up and up and up.

00:05:35.994 --> 00:05:37.410
There's no way you
can prevent it,

00:05:37.410 --> 00:05:39.326
and there's nothing you
can do to clear it out

00:05:39.326 --> 00:05:41.240
once it happens.

00:05:41.240 --> 00:05:45.040
Also, on a page like this,
the CSS is going to work.

00:05:45.040 --> 00:05:47.220
That should be-- it
shouldn't be SCS, should it?

00:05:47.220 --> 00:05:47.960
What am I doing?

00:05:47.960 --> 00:05:50.900
Anyway, the
JavaScript will work.

00:05:50.900 --> 00:05:52.759
But what about this?

00:05:52.759 --> 00:05:56.260
This won't load even
if you're online,

00:05:56.260 --> 00:05:57.980
because it's not in the cache.

00:05:57.980 --> 00:06:00.440
And AppCache won't let network
requests through by default,

00:06:00.440 --> 00:06:03.600
unless you add this little
bit of magic at the bottom.

00:06:03.600 --> 00:06:05.430
Of course, this is
all in the manual.

00:06:05.430 --> 00:06:07.799
But there's nothing
in the manifest there

00:06:07.799 --> 00:06:09.590
that hints to me that
this is the behavior,

00:06:09.590 --> 00:06:11.165
this is what I should expect.

00:06:11.165 --> 00:06:14.860
I was on a transatlantic flight,
and I had nothing better to do.

00:06:14.860 --> 00:06:15.820
I was offline.

00:06:15.820 --> 00:06:18.480
So I tried to draw
how AppCache works.

00:06:18.480 --> 00:06:20.110
And it took me like
eight hours, partly

00:06:20.110 --> 00:06:21.970
because the specification
is so dense,

00:06:21.970 --> 00:06:23.987
and it kept confounding
my expectations.

00:06:23.987 --> 00:06:26.320
But also because the person
in front had fully reclined,

00:06:26.320 --> 00:06:28.580
so I was having to use
my laptop like a T Rex.

00:06:28.580 --> 00:06:30.880
But it's that complicated.

00:06:30.880 --> 00:06:33.250
And there's nothing wrong
with high level APIs, right?

00:06:33.250 --> 00:06:34.890
I mean, look at jQuery.

00:06:34.890 --> 00:06:37.220
They looked at what people
were doing with the DOM, all

00:06:37.220 --> 00:06:40.280
the common stuff, and
they made shortcuts.

00:06:40.280 --> 00:06:41.880
Some quite overloaded methods.

00:06:41.880 --> 00:06:45.090
You need to know what the
different arguments actually

00:06:45.090 --> 00:06:45.799
do.

00:06:45.799 --> 00:06:46.840
But it works in practice.

00:06:46.840 --> 00:06:48.710
They're really nice shortcuts.

00:06:48.710 --> 00:06:51.220
However, AppCache tried
to be the shortcut

00:06:51.220 --> 00:06:53.160
before it knew the long cuts.

00:06:53.160 --> 00:06:54.750
It looked really sweet on paper.

00:06:54.750 --> 00:06:56.750
But when developers
actually look closely at it,

00:06:56.750 --> 00:06:59.440
we go like, ugh, no, don't
like the look of that.

00:06:59.440 --> 00:07:00.370
Take that away.

00:07:03.540 --> 00:07:05.190
So we're going to
give it another try.

00:07:05.190 --> 00:07:06.530
We're giving it another try.

00:07:06.530 --> 00:07:08.832
And the new thing is
the ServiceWorker.

00:07:08.832 --> 00:07:10.790
Actually, I think this
is the first talk on it.

00:07:10.790 --> 00:07:13.210
So that didn't feel like
a deserving introduction.

00:07:13.210 --> 00:07:15.920
So we'll give that another go.

00:07:15.920 --> 00:07:21.078
And the new thing is
the ServiceWorker.

00:07:21.078 --> 00:07:21.680
But yeah.

00:07:21.680 --> 00:07:23.930
The current status is
it's a specification

00:07:23.930 --> 00:07:26.630
that we're developing,
drafting on GitHub.

00:07:26.630 --> 00:07:29.080
We've been working on this
a while, along with Mozilla

00:07:29.080 --> 00:07:31.000
and other third parties
who are interested.

00:07:31.000 --> 00:07:33.250
We've been prototyping bits
and pieces in the browser.

00:07:33.250 --> 00:07:34.940
But the spec is still
a work in progress.

00:07:34.940 --> 00:07:36.314
I'm going to show
you bits of it.

00:07:36.314 --> 00:07:38.550
And any feedback you
have on it, anything

00:07:38.550 --> 00:07:40.550
you see you don't like,
you can talk to me.

00:07:40.550 --> 00:07:42.670
You can ask me in the
Q&amp;A. But you can also

00:07:42.670 --> 00:07:44.810
file issues on GitHub.

00:07:44.810 --> 00:07:47.000
There's nothing to play
with in the browser yet,

00:07:47.000 --> 00:07:50.370
but we're hoping to hit canary
sometime early next year.

00:07:50.370 --> 00:07:51.580
So what is the ServiceWorker?

00:07:51.580 --> 00:07:53.550
Well, it's a
JavaScript context that

00:07:53.550 --> 00:07:55.060
operates for a set of URLs.

00:07:55.060 --> 00:07:56.684
And you can use it
to manage behavior.

00:07:56.684 --> 00:07:58.850
It's actually kind of easier
to show you rather than

00:07:58.850 --> 00:07:59.630
describe it.

00:07:59.630 --> 00:08:02.660
So on just a normal page, you
would register a ServiceWorker

00:08:02.660 --> 00:08:03.354
like this.

00:08:03.354 --> 00:08:04.770
The first argument,
you're telling

00:08:04.770 --> 00:08:06.860
it which URLs you want
it to be in charge of.

00:08:06.860 --> 00:08:10.070
The second argument, the
URL to the JavaScript file

00:08:10.070 --> 00:08:12.120
that's going to do
all the controlling.

00:08:12.120 --> 00:08:15.070
And congratulations, you
now have a ServiceWorker.

00:08:15.070 --> 00:08:17.520
And the ServiceWorker is very
similar to a shared worker.

00:08:17.520 --> 00:08:19.920
I mean, it exists
separately to the pages.

00:08:19.920 --> 00:08:21.660
And multiple pages
can communicate

00:08:21.660 --> 00:08:23.655
with the same instance
of the ServiceWorker.

00:08:23.655 --> 00:08:25.280
If you've developed
Chrome apps before,

00:08:25.280 --> 00:08:28.270
this is kind of similar to
the background pages model.

00:08:28.270 --> 00:08:29.876
But these are much lighter.

00:08:29.876 --> 00:08:31.000
They don't have a document.

00:08:31.000 --> 00:08:32.072
They've got no DOM.

00:08:32.072 --> 00:08:34.280
They're less of a memory
burden and less startup cost

00:08:34.280 --> 00:08:37.240
than a whole page would be.

00:08:37.240 --> 00:08:39.730
So our ServiceWorker file
currently looks like this.

00:08:39.730 --> 00:08:40.682
It's empty.

00:08:40.682 --> 00:08:42.640
And how does that affect
the behavior of pages?

00:08:42.640 --> 00:08:44.650
Well, it doesn't.

00:08:44.650 --> 00:08:46.490
Magic was a huge
problem with AppCache.

00:08:46.490 --> 00:08:48.770
An empty AppCache file
would start doing things.

00:08:48.770 --> 00:08:49.550
This doesn't.

00:08:49.550 --> 00:08:52.700
ServiceWorker aims to have
as little magic as possible.

00:08:52.700 --> 00:08:54.880
It's a bring your own magic API.

00:08:54.880 --> 00:08:56.990
You can make your
own magic with it.

00:08:56.990 --> 00:08:59.970
But by default, it doesn't
do anything you don't expect.

00:08:59.970 --> 00:09:00.929
You're in full control.

00:09:00.929 --> 00:09:02.469
But what control do
you actually get?

00:09:02.469 --> 00:09:04.390
Well, you can listen
in on network requests.

00:09:04.390 --> 00:09:06.016
You get this event.

00:09:06.016 --> 00:09:08.640
Some just like listening to the
event using the old DOM method,

00:09:08.640 --> 00:09:12.080
but you can use add event
listener if you want as well.

00:09:12.080 --> 00:09:15.784
So here, if I navigate to
slash whatever slash fubar,

00:09:15.784 --> 00:09:17.450
I'm going to get a
console lock for that

00:09:17.450 --> 00:09:19.080
in this other JavaScript file.

00:09:19.080 --> 00:09:21.060
But I also get one
for any request

00:09:21.060 --> 00:09:23.600
that I triggered by
that page as well,

00:09:23.600 --> 00:09:25.270
even they're to another domain.

00:09:25.270 --> 00:09:26.750
The usual cross
origin rules apply

00:09:26.750 --> 00:09:28.409
when it comes to accessing data.

00:09:28.409 --> 00:09:30.700
But you'll still get the
event for the request actually

00:09:30.700 --> 00:09:31.430
happening.

00:09:31.430 --> 00:09:32.970
Anyway, so what?

00:09:32.970 --> 00:09:35.190
Well, like other events
we have in the browser,

00:09:35.190 --> 00:09:37.160
you can prevent the default.

00:09:37.160 --> 00:09:39.150
And you can do something else.

00:09:39.150 --> 00:09:41.076
So here, I'm looking
at the request URL,

00:09:41.076 --> 00:09:42.450
and I'm looking
to see if it ends

00:09:42.450 --> 00:09:44.690
with one of the
image extensions.

00:09:44.690 --> 00:09:47.610
And then I'm going to
call event.respondwith.

00:09:47.610 --> 00:09:50.600
And event.respondwith
takes a response object,

00:09:50.600 --> 00:09:51.850
which is new in ServiceWorker.

00:09:51.850 --> 00:09:54.660
Or it will take a promise,
which will eventually

00:09:54.660 --> 00:09:56.870
resolve to a response.

00:09:56.870 --> 00:09:59.300
And the fetch method, which
is also new in ServiceWorker,

00:09:59.300 --> 00:10:03.360
is going to give you a promise
for a response to the URL you

00:10:03.360 --> 00:10:03.960
give it.

00:10:03.960 --> 00:10:06.924
So here I'm just redirecting
all of the requests or--

00:10:06.924 --> 00:10:09.340
and they're going to serve up
this not-a-cat image instead

00:10:09.340 --> 00:10:12.580
of any other images on the page.

00:10:12.580 --> 00:10:14.980
So note here I'm actually
satisfying a cross origin

00:10:14.980 --> 00:10:16.720
request with a same
origin response.

00:10:16.720 --> 00:10:18.790
And you can do the
opposite as well.

00:10:18.790 --> 00:10:22.500
Security is always determined by
the origin of the response, not

00:10:22.500 --> 00:10:23.970
the request.

00:10:23.970 --> 00:10:26.520
This isn't an HTTP redirect.

00:10:26.520 --> 00:10:28.680
You're just serving
up a different file.

00:10:28.680 --> 00:10:30.670
As far as the
browser's concerned,

00:10:30.670 --> 00:10:33.100
it requested
probably-cats-again,

00:10:33.100 --> 00:10:34.520
and it got it.

00:10:34.520 --> 00:10:36.486
But you could do an HTTP
redirect if you want.

00:10:36.486 --> 00:10:38.360
In fact, you can create
any kind of response.

00:10:38.360 --> 00:10:40.260
We have a kind of low
level API for that.

00:10:40.260 --> 00:10:43.160
So new same origin response,
give it a content type.

00:10:43.160 --> 00:10:43.980
Give it a body.

00:10:43.980 --> 00:10:45.732
And I'm going to serve that up.

00:10:45.732 --> 00:10:47.190
And you can see
how you could start

00:10:47.190 --> 00:10:48.850
to make things work
offline with this.

00:10:48.850 --> 00:10:52.170
Like, I get a template
from the file system API.

00:10:52.170 --> 00:10:54.910
I can get some data
from index database

00:10:54.910 --> 00:10:56.685
and mush them together
and serve that out.

00:10:56.685 --> 00:10:58.310
But that would be a
lot of code, and it

00:10:58.310 --> 00:11:01.190
would involve some
pretty gnarly APIs.

00:11:01.190 --> 00:11:03.900
So we're introducing a new
storage system specifically

00:11:03.900 --> 00:11:06.595
for this, and it's
the cache list.

00:11:06.595 --> 00:11:08.136
So we just need to
unfetch, but there

00:11:08.136 --> 00:11:10.410
are other events
as well on install.

00:11:10.410 --> 00:11:12.289
So this is called
when the browser sees

00:11:12.289 --> 00:11:13.830
the ServiceWorker
for the first time.

00:11:13.830 --> 00:11:15.960
It's your opportunity
to get everything ready

00:11:15.960 --> 00:11:18.130
before you start
hearing about requests,

00:11:18.130 --> 00:11:19.790
before you start
handling requests.

00:11:19.790 --> 00:11:23.000
So in here, I can create a new
cache, give it a set of URLs,

00:11:23.000 --> 00:11:25.671
and add it onto
the caches object.

00:11:25.671 --> 00:11:26.670
And these are just URLs.

00:11:26.670 --> 00:11:28.090
They can be from another domain.

00:11:28.090 --> 00:11:28.685
That's fine.

00:11:28.685 --> 00:11:30.435
And they'll be downloaded,
and we add them

00:11:30.435 --> 00:11:33.130
to this cache called
static-v1 or whatever.

00:11:33.130 --> 00:11:35.850
Now the cache won't
serve responses

00:11:35.850 --> 00:11:38.580
until all of those files
have successfully downloaded.

00:11:38.580 --> 00:11:40.950
And if one of them
fails, then you

00:11:40.950 --> 00:11:42.410
get nothing for
that whole cache.

00:11:42.410 --> 00:11:43.970
This is a good way to
group files together

00:11:43.970 --> 00:11:45.360
that are dependent
on each other.

00:11:45.360 --> 00:11:49.756
So if you can get the
network-failed.html out

00:11:49.756 --> 00:11:53.714
of the cache, you
know the PNG is there.

00:11:53.714 --> 00:11:54.380
The JS is there.

00:11:54.380 --> 00:11:55.600
The CSS is definitely there.

00:11:55.600 --> 00:11:57.120
They're dependent on each other.

00:11:57.120 --> 00:11:58.830
We're creating one
cache here, but you

00:11:58.830 --> 00:12:01.200
could create many,
like for a game.

00:12:01.200 --> 00:12:03.790
You could create a cache
per level, for instance.

00:12:03.790 --> 00:12:05.960
For a newspaper, you
could do a cache per issue

00:12:05.960 --> 00:12:08.760
or a cache per article.

00:12:08.760 --> 00:12:10.180
And then we wait on the cache.

00:12:10.180 --> 00:12:13.030
So event.waitUntil
takes a promise.

00:12:13.030 --> 00:12:15.260
And this is where you can
say, look, I'm not actually

00:12:15.260 --> 00:12:18.240
ready to handle requests
until this stuff has happened.

00:12:18.240 --> 00:12:20.280
On cache objects, you
get this ready method,

00:12:20.280 --> 00:12:26.530
which will resolve once that
cache has successfully formed.

00:12:26.530 --> 00:12:28.089
You might wait on
all of your caches,

00:12:28.089 --> 00:12:29.380
or you might only wait on some.

00:12:29.380 --> 00:12:32.466
So in the game model, you
might only wait on level one

00:12:32.466 --> 00:12:34.840
and allow the other levels to
download in the background.

00:12:34.840 --> 00:12:36.970
And you'll just handle it
if level two is not there

00:12:36.970 --> 00:12:38.730
for whatever reason.

00:12:38.730 --> 00:12:41.170
For instance, if the
user goes offline

00:12:41.170 --> 00:12:43.660
while that's still downloading
levels two and three,

00:12:43.660 --> 00:12:46.694
you can still offer an offline
experience for level one.

00:12:46.694 --> 00:12:48.860
And then when the user gets
to the end of level one,

00:12:48.860 --> 00:12:51.409
you can say, look, we don't
have the files for level two.

00:12:51.409 --> 00:12:53.700
We've saved your position,
and when you're next online,

00:12:53.700 --> 00:12:56.520
we can pick up
where we left off.

00:12:56.520 --> 00:12:58.080
But we're just
creating caches here.

00:12:58.080 --> 00:13:00.040
We're not actually using them.

00:13:00.040 --> 00:13:02.190
To use them, we go back
to our own fetch method.

00:13:02.190 --> 00:13:04.060
And once again, the
respondWith method,

00:13:04.060 --> 00:13:06.350
and I'm just going
to ask the caches

00:13:06.350 --> 00:13:08.316
for a match for this URL.

00:13:08.316 --> 00:13:09.940
I can be specific
and say, look, I only

00:13:09.940 --> 00:13:11.660
want to get a match
from the cache named

00:13:11.660 --> 00:13:12.742
static-v1 or whatever.

00:13:12.742 --> 00:13:14.450
But we don't really
need to do that here.

00:13:14.450 --> 00:13:16.590
We don't need to
be that specific.

00:13:16.590 --> 00:13:19.647
Of course, if that doesn't
match anything in our caches--

00:13:19.647 --> 00:13:21.980
because we're handling all
requests at the moment- we're

00:13:21.980 --> 00:13:24.480
going to get a hard failure,
even if the user's online

00:13:24.480 --> 00:13:27.310
because we're saying, go to
the cache for everything.

00:13:27.310 --> 00:13:28.939
But this whole thing
is promise based,

00:13:28.939 --> 00:13:30.980
promises that we now have
in a DOM in JavaScript.

00:13:30.980 --> 00:13:34.340
So we can fix that just by
adding .catch to the end and do

00:13:34.340 --> 00:13:35.300
something else.

00:13:35.300 --> 00:13:37.260
If you're unfamiliar
with how promises work,

00:13:37.260 --> 00:13:39.725
then there is an HTML5
Rocks article coming.

00:13:39.725 --> 00:13:41.180
It should be out next month.

00:13:41.180 --> 00:13:42.780
That hopefully will explain it.

00:13:42.780 --> 00:13:45.320
But all sync success
failure methods

00:13:45.320 --> 00:13:48.570
in JavaScript in the DOM
are moving to this model.

00:13:48.570 --> 00:13:52.040
So if you fail to get stuff from
the cache for whatever reason,

00:13:52.040 --> 00:13:54.010
like something
fails or there's not

00:13:54.010 --> 00:13:55.670
something in the
cache for that URL,

00:13:55.670 --> 00:13:57.357
we fall down to this next step.

00:13:57.357 --> 00:13:58.940
And what I'm doing
is I'm using fetch.

00:13:58.940 --> 00:14:00.940
And I'm just going to
pipe through the requests.

00:14:00.940 --> 00:14:03.030
So we're going to
go to the network.

00:14:03.030 --> 00:14:04.870
Of course, if there's
nothing in the cache,

00:14:04.870 --> 00:14:07.994
and the network request fails,
we're going to get nothing.

00:14:07.994 --> 00:14:09.160
But we can fix that as well.

00:14:09.160 --> 00:14:10.920
We can catch again.

00:14:10.920 --> 00:14:12.930
And here, I'm going to
go to the cache again,

00:14:12.930 --> 00:14:15.390
and I'm going to get the
network-failed.html file

00:14:15.390 --> 00:14:16.030
and serve that.

00:14:16.030 --> 00:14:17.790
And I know that's there
because I depended

00:14:17.790 --> 00:14:21.422
on it in the uninstall
method, event even.

00:14:21.422 --> 00:14:23.880
And our other page is going to
be better than the browser's

00:14:23.880 --> 00:14:25.212
default one because
we can say, hey,

00:14:25.212 --> 00:14:26.820
I'm afraid that resource
is not available.

00:14:26.820 --> 00:14:28.250
But here's a list
of things which are.

00:14:28.250 --> 00:14:30.166
Here's the articles that
are available to you.

00:14:30.166 --> 00:14:32.630
Here's the levels
which will work.

00:14:32.630 --> 00:14:34.830
As I mentioned before,
onfetch doesn't just

00:14:34.830 --> 00:14:36.190
fire for full page navigations.

00:14:36.190 --> 00:14:40.390
It also fires for assets on
the page, your JavaScript, XHR,

00:14:40.390 --> 00:14:41.941
CSS, images, et cetera.

00:14:41.941 --> 00:14:43.440
We can differentiate
between the two

00:14:43.440 --> 00:14:45.560
using event.type because
it makes sense here.

00:14:45.560 --> 00:14:48.220
We don't want to serve up
network-failed.html for an XHR

00:14:48.220 --> 00:14:48.720
request.

00:14:48.720 --> 00:14:50.310
That doesn't work.

00:14:50.310 --> 00:14:54.320
So here, we can just serve it
up for full page navigations.

00:14:54.320 --> 00:14:56.430
So this, this bit of
code-- what does this look

00:14:56.430 --> 00:14:58.765
like in AppCache?

00:14:58.765 --> 00:15:01.240
Ah.

00:15:01.240 --> 00:15:02.589
It's a lot simpler.

00:15:02.589 --> 00:15:04.130
But it's not actually
simpler, is it?

00:15:04.130 --> 00:15:06.517
It's just less characters.

00:15:06.517 --> 00:15:08.100
This doesn't tell
me that for any URL,

00:15:08.100 --> 00:15:11.960
it should go to the cache
first and then try the network

00:15:11.960 --> 00:15:15.109
and then fall back to
network-failed.html.

00:15:15.109 --> 00:15:16.650
And this is just
one of the few cases

00:15:16.650 --> 00:15:20.499
that AppCache can actually
do without too much issue.

00:15:20.499 --> 00:15:22.040
But you don't get
the full separation

00:15:22.040 --> 00:15:24.047
of caching and routing.

00:15:24.047 --> 00:15:25.630
But you're going to
get the weird auto

00:15:25.630 --> 00:15:27.945
caching of all pages,
that link to it.

00:15:27.945 --> 00:15:30.320
And if you want it to serve
a different fall back for XHR

00:15:30.320 --> 00:15:35.100
compared to navigations,
AppCache can't do that.

00:15:35.100 --> 00:15:37.570
If this, the worker code,
starts doing something

00:15:37.570 --> 00:15:40.740
I don't understand,
what can I do?

00:15:40.740 --> 00:15:42.772
I can add a console.log.

00:15:42.772 --> 00:15:44.230
I can add a JavaScript
break point,

00:15:44.230 --> 00:15:45.813
and I can step through
it step by step

00:15:45.813 --> 00:15:48.120
and look at all the
values of variables,

00:15:48.120 --> 00:15:51.570
look at the whole
state on every step.

00:15:51.570 --> 00:15:56.190
If this does something I
don't expect-- and it will--

00:15:56.190 --> 00:15:57.760
we're back to the manual.

00:15:57.760 --> 00:16:00.060
Read the whole thing again.

00:16:00.060 --> 00:16:02.980
When I was building Lanyard's
offline enabled mobile site,

00:16:02.980 --> 00:16:05.440
I found out some devices
were behaving differently

00:16:05.440 --> 00:16:10.546
when they were out of signal to
when they were in flight mode.

00:16:10.546 --> 00:16:11.920
And what I was
most interested in

00:16:11.920 --> 00:16:14.310
is doing a proper
no reception test.

00:16:14.310 --> 00:16:16.664
But how could I test
genuinely no reception?

00:16:16.664 --> 00:16:18.080
This is before I
worked at Google,

00:16:18.080 --> 00:16:20.163
so I couldn't just pop
along to Faraday's lavatory

00:16:20.163 --> 00:16:22.150
and sit there testing phones.

00:16:22.150 --> 00:16:24.475
So I populated the
caches on each device,

00:16:24.475 --> 00:16:27.245
and I went to the local
underground station

00:16:27.245 --> 00:16:29.840
because there's no mobile
reception down there.

00:16:29.840 --> 00:16:31.660
And I tested each
devices, see what it did.

00:16:31.660 --> 00:16:33.410
And I was filming it
with a digital camera

00:16:33.410 --> 00:16:35.390
so I could review it later on.

00:16:35.390 --> 00:16:38.490
And I looked up, and I saw
that two police officers were

00:16:38.490 --> 00:16:41.320
kind of standing in front of
me, pulling faces and pointing

00:16:41.320 --> 00:16:42.150
behind me.

00:16:42.150 --> 00:16:45.000
And I look around, and I was
sitting in between two posters.

00:16:45.000 --> 00:16:47.910
One said, someone's got
more than one mobile phone.

00:16:47.910 --> 00:16:50.430
Probably a terrorist.

00:16:50.430 --> 00:16:54.110
Doing something odd with a
camera, probably a terrorist.

00:16:54.110 --> 00:16:56.290
I was ticking all
of the terror boxes.

00:16:56.290 --> 00:16:58.380
Thankfully, the police
thought this was hilarious

00:16:58.380 --> 00:17:00.110
and decided not to
shoot me to pieces,

00:17:00.110 --> 00:17:03.210
which was very nice of them.

00:17:03.210 --> 00:17:05.710
So the ServiceWorker lets us
build these offline experiences

00:17:05.710 --> 00:17:07.996
in a flexible and testable way.

00:17:07.996 --> 00:17:08.579
But who cares?

00:17:08.579 --> 00:17:09.954
I mean, we've got
train journeys,

00:17:09.954 --> 00:17:11.450
plane journey, roaming abroad.

00:17:11.450 --> 00:17:14.510
But mobile coverage is just
getting better and better.

00:17:14.510 --> 00:17:17.499
Planes and trains are getting
Wi-Fi, some even for free.

00:17:17.499 --> 00:17:19.160
And mobile providers
are starting

00:17:19.160 --> 00:17:21.710
to remove roaming costs.

00:17:21.710 --> 00:17:23.890
Maybe even one day, Google
will put a Wi-Fi antenna

00:17:23.890 --> 00:17:25.609
outside the toilets.

00:17:25.609 --> 00:17:29.672
Is this problem going away, this
problem of zero connectivity?

00:17:29.672 --> 00:17:31.630
When I first started
making stuff work offline,

00:17:31.630 --> 00:17:33.450
my instinct was to
build things as normal

00:17:33.450 --> 00:17:35.500
and then catch the
users that were offline.

00:17:35.500 --> 00:17:37.000
And you can do that
in ServiceWorker

00:17:37.000 --> 00:17:39.030
because, do what you want.

00:17:39.030 --> 00:17:41.400
I can do onfetch, event,
respondWith, go to the network,

00:17:41.400 --> 00:17:43.150
and then catch that
and do something else,

00:17:43.150 --> 00:17:46.400
like pull some data
out of the cache.

00:17:46.400 --> 00:17:48.715
So people who have
never connectivity

00:17:48.715 --> 00:17:50.340
are going to get
fresh data every time.

00:17:50.340 --> 00:17:52.520
Users without
connectivity are rescued.

00:17:52.520 --> 00:17:53.770
We can give them something.

00:17:53.770 --> 00:17:55.930
This is graceful degradation.

00:17:55.930 --> 00:17:57.680
And as we found with
graceful degradation,

00:17:57.680 --> 00:17:59.840
it's the wrong way around.

00:17:59.840 --> 00:18:02.220
You see, when I want to get
something from the internet,

00:18:02.220 --> 00:18:04.490
I have to wake up the
radio or the Wi-Fi devices.

00:18:04.490 --> 00:18:07.380
Non 3G, that can take
a couple of seconds.

00:18:07.380 --> 00:18:09.920
And then we can begin
the epic journey

00:18:09.920 --> 00:18:11.922
to get data from somewhere
else in the world.

00:18:11.922 --> 00:18:14.380
And it's a dangerous business,
going out onto the internet.

00:18:14.380 --> 00:18:19.500
We need to negotiate the router,
ISP, DNS, intermediate proxies,

00:18:19.500 --> 00:18:21.590
the destination server,
grab what we need,

00:18:21.590 --> 00:18:23.423
and then come back
through all those things.

00:18:23.423 --> 00:18:24.400
And it's a lot to do.

00:18:24.400 --> 00:18:26.820
And if any of these
things are busy or flaky,

00:18:26.820 --> 00:18:28.330
we're going to be slow.

00:18:28.330 --> 00:18:32.290
Or worse, we're going to
end up with a total failure.

00:18:32.290 --> 00:18:35.749
But we don't know it's going to
be fast or slow until we try.

00:18:35.749 --> 00:18:37.540
We don't know it's
going to succeed or fail

00:18:37.540 --> 00:18:39.859
until one of those
two things happens.

00:18:39.859 --> 00:18:41.400
And this epic journey
is per request,

00:18:41.400 --> 00:18:42.760
and your pages are
made out of many.

00:18:42.760 --> 00:18:44.551
This is why I like
progressive enhancement,

00:18:44.551 --> 00:18:47.880
because you can get stuff
on the screen with less

00:18:47.880 --> 00:18:51.380
requirements from the network.

00:18:51.380 --> 00:18:53.180
A bit of the HTML and
the CSS comes down,

00:18:53.180 --> 00:18:54.715
you can start rendering.

00:18:54.715 --> 00:18:58.500
But ultimately, it's
still network dependent.

00:18:58.500 --> 00:19:03.245
And when your phone's like this,
it's like a one legged dog.

00:19:03.245 --> 00:19:08.160
It thinks it can still
play fetch, but it can't.

00:19:08.160 --> 00:19:09.210
And boy, will it try.

00:19:09.210 --> 00:19:12.130
And you have to sit there
watching it drag itself

00:19:12.130 --> 00:19:15.182
along the floor
with its one leg.

00:19:15.182 --> 00:19:16.140
And it's heartbreaking.

00:19:16.140 --> 00:19:18.590
It'll spend minutes
trying before it gives up.

00:19:18.590 --> 00:19:20.385
But even if your
connection's like this,

00:19:20.385 --> 00:19:22.010
you're still at the
mercy of everything

00:19:22.010 --> 00:19:24.490
else out on in the internet,
any problems that are there.

00:19:24.490 --> 00:19:25.948
And if you've got
something already

00:19:25.948 --> 00:19:28.660
on the device, if you already
have an offline experience, why

00:19:28.660 --> 00:19:30.750
wait for the network to show it?

00:19:30.750 --> 00:19:33.300
You don't have to leave the
device to get to first render.

00:19:33.300 --> 00:19:36.370
We should build our
pages offline first.

00:19:36.370 --> 00:19:38.460
And the next generation
of progressive enhancement

00:19:38.460 --> 00:19:40.950
treats the network as a
potential enhancement,

00:19:40.950 --> 00:19:43.066
an enhancement that
might not be available.

00:19:43.066 --> 00:19:44.690
So sure, connectivity's
getting better.

00:19:44.690 --> 00:19:48.060
But it's very rarely going to
be faster than getting stuff

00:19:48.060 --> 00:19:50.410
straight off the device.

00:19:50.410 --> 00:19:52.840
This whole thing's as much
about improving performance

00:19:52.840 --> 00:19:54.710
for users with
connectivity as it

00:19:54.710 --> 00:19:57.526
is for giving something
to those without.

00:19:57.526 --> 00:19:58.900
The Hoodie guys
made a great post

00:19:58.900 --> 00:20:00.910
about this, which I
recommend reading.

00:20:00.910 --> 00:20:03.060
But these ideas are
pretty new to the web.

00:20:03.060 --> 00:20:06.690
But some native apps have been
doing this for quite a while.

00:20:06.690 --> 00:20:09.830
Here we can compare the loading
of the Google Plus mobile site

00:20:09.830 --> 00:20:12.530
versus the native app
over a pretty decent

00:20:12.530 --> 00:20:14.990
mobile connection.

00:20:14.990 --> 00:20:16.740
Unfortunately, we have
to give the website

00:20:16.740 --> 00:20:22.440
a head start in this because
it has a one of these.

00:20:22.440 --> 00:20:25.430
I love the web.

00:20:25.430 --> 00:20:26.410
I hate this.

00:20:26.410 --> 00:20:28.380
We should not be doing this.

00:20:28.380 --> 00:20:30.160
But let's-- we'll
gloss over that.

00:20:30.160 --> 00:20:31.531
Oh, yeah thanks.

00:20:31.531 --> 00:20:33.239
[APPLAUSE]

00:20:33.239 --> 00:20:35.780
But let's-- we're going to load
the main site now at the same

00:20:35.780 --> 00:20:37.880
time as the app.

00:20:37.880 --> 00:20:39.485
So we go.

00:20:39.485 --> 00:20:41.360
And the native app has
content on the screen.

00:20:41.360 --> 00:20:41.970
There it goes.

00:20:41.970 --> 00:20:43.490
And the website's still
thinking about it.

00:20:43.490 --> 00:20:45.573
Oh, and now it's being
blocked by a font download.

00:20:45.573 --> 00:20:47.830
And eventually,
it comes through.

00:20:47.830 --> 00:20:50.350
If we ignore the font
delay, then both the app

00:20:50.350 --> 00:20:52.812
and the website actually
got fresh content around

00:20:52.812 --> 00:20:53.645
about the same time.

00:20:53.645 --> 00:20:57.030
But before that, the native
app shows cache content.

00:20:57.030 --> 00:20:58.520
And it feels so much faster.

00:20:58.520 --> 00:21:01.130
It looks like it beats the
website by two seconds.

00:21:01.130 --> 00:21:02.980
And in this example,
connectivity was good.

00:21:02.980 --> 00:21:04.730
And the mobile site
got an advantage

00:21:04.730 --> 00:21:07.620
because by going
through the slam door

00:21:07.620 --> 00:21:10.820
thing we did a lot of
the DNS work up front.

00:21:10.820 --> 00:21:13.480
And we did a lot
of the-- yeah, we

00:21:13.480 --> 00:21:16.245
had some [? warmer ?] for
the connections in the radio.

00:21:16.245 --> 00:21:17.804
As connectivity
gets worse, the app

00:21:17.804 --> 00:21:19.220
is going to look
better and better

00:21:19.220 --> 00:21:21.678
compared to the website because
it can just render straight

00:21:21.678 --> 00:21:22.400
from the device.

00:21:22.400 --> 00:21:25.130
ServiceWorker levels
this playing field.

00:21:25.130 --> 00:21:27.830
So we can start by
just serving a page

00:21:27.830 --> 00:21:31.310
shell from the
ServiceWorker, just the UI

00:21:31.310 --> 00:21:32.740
but no content there.

00:21:32.740 --> 00:21:34.190
And we can start up a spinner.

00:21:34.190 --> 00:21:36.150
And we can see if we've
got any cached content.

00:21:36.150 --> 00:21:37.960
And if we do, we
can show it and then

00:21:37.960 --> 00:21:40.430
start going in and fetching
some network content.

00:21:40.430 --> 00:21:41.840
If we don't have cached
content, that's fine.

00:21:41.840 --> 00:21:43.243
We'll just go to
the network and see

00:21:43.243 --> 00:21:44.701
if we can get
something from there.

00:21:44.701 --> 00:21:47.350
And once that works, we
can show the new content

00:21:47.350 --> 00:21:49.190
and hide the spinner.

00:21:49.190 --> 00:21:51.020
If the network
request fails, and we

00:21:51.020 --> 00:21:53.320
didn't show any cached
content, then that's a shame.

00:21:53.320 --> 00:21:55.860
We have to show
an error message.

00:21:55.860 --> 00:21:58.120
But if we did show
cached content,

00:21:58.120 --> 00:22:01.389
and the network request fails,
we can actually fail silently.

00:22:01.389 --> 00:22:03.680
Because this is just a load
of a page-- the user hasn't

00:22:03.680 --> 00:22:05.700
hit the Refresh
button specifically--

00:22:05.700 --> 00:22:07.470
this is the offline experience.

00:22:07.470 --> 00:22:08.150
And it works.

00:22:08.150 --> 00:22:11.210
And this is what a
lot of native apps do.

00:22:11.210 --> 00:22:13.990
We can represent that
diagram with promises.

00:22:13.990 --> 00:22:16.190
And once again, if promises
make your eyes bleed,

00:22:16.190 --> 00:22:19.100
then keep an eye on
HTML5 Rocks next month.

00:22:19.100 --> 00:22:21.319
Hopefully, there'll
be an explanation.

00:22:21.319 --> 00:22:23.860
But actually, we can do better
than the flow chart because we

00:22:23.860 --> 00:22:25.790
can make the network
request at the same time

00:22:25.790 --> 00:22:27.220
as we make the cache request.

00:22:27.220 --> 00:22:28.790
Because why wait
on the cache before

00:22:28.790 --> 00:22:30.600
we actually try
going to the network?

00:22:30.600 --> 00:22:33.450
It is possible in extreme cases
that the network request will

00:22:33.450 --> 00:22:35.977
beat the cache, like if the
user's hard drive is made

00:22:35.977 --> 00:22:38.560
of old cassette tape, but their
internet connection's amazing.

00:22:38.560 --> 00:22:39.730
It is possible.

00:22:39.730 --> 00:22:42.190
We can let the
two requests race.

00:22:42.190 --> 00:22:45.632
But we've got these two methods
where we go and fetch data.

00:22:45.632 --> 00:22:47.590
And in one, we're asking
it to go to the cache.

00:22:47.590 --> 00:22:48.850
And in the other, we're not.

00:22:48.850 --> 00:22:51.000
How does the page
tell the ServiceWorker

00:22:51.000 --> 00:22:53.560
were to get the data from?

00:22:53.560 --> 00:22:55.840
Well, here's our
implementation of fetch data.

00:22:55.840 --> 00:22:56.990
It's just XHR.

00:22:56.990 --> 00:22:59.530
It's pretty simple.

00:22:59.530 --> 00:23:02.824
If options object dot
useCache is true--

00:23:02.824 --> 00:23:04.240
if there's no
ServiceWorker there,

00:23:04.240 --> 00:23:05.540
we're just going to
reject at this point

00:23:05.540 --> 00:23:07.360
because we can't do
anything about it.

00:23:07.360 --> 00:23:10.300
But if the ServiceWorker is
there, we can set header.

00:23:10.300 --> 00:23:15.150
We're going to set header x
useCache to be true and then

00:23:15.150 --> 00:23:16.710
just serve up the XHR.

00:23:16.710 --> 00:23:18.790
I'm kind of pretending
that XHR uses promises,

00:23:18.790 --> 00:23:20.081
which it doesn't at the moment.

00:23:20.081 --> 00:23:22.050
Hopefully one day, it will.

00:23:22.050 --> 00:23:25.670
This header thing looks a
little bit magic, and it is.

00:23:25.670 --> 00:23:27.760
But it's not magic
in the ServiceWorker.

00:23:27.760 --> 00:23:30.630
It's magic you can
bring as a developer.

00:23:30.630 --> 00:23:33.270
Over in the worker, we're
listening for requests.

00:23:33.270 --> 00:23:37.850
And if it's to the API, we
can look for that header.

00:23:37.850 --> 00:23:39.850
And if that header's
there, we can just

00:23:39.850 --> 00:23:42.814
go straight to the cache
and only from the cache.

00:23:42.814 --> 00:23:45.230
And if it's not there, well,
we can get rid of that header

00:23:45.230 --> 00:23:46.450
and just go to the
network because we

00:23:46.450 --> 00:23:47.835
don't want that header hitting
the network particularly.

00:23:47.835 --> 00:23:48.525
It's not useful.

00:23:48.525 --> 00:23:50.400
But at the same time,
we can update the cache

00:23:50.400 --> 00:23:54.034
with the response we get back.

00:23:54.034 --> 00:23:55.450
The important thing
about the code

00:23:55.450 --> 00:23:58.210
here is it doesn't
make any assumptions

00:23:58.210 --> 00:23:59.470
about the network at all.

00:23:59.470 --> 00:24:01.470
It just tries stuff
and sees what happens.

00:24:01.470 --> 00:24:04.020
It's reactive, not
predictive because predictive

00:24:04.020 --> 00:24:06.290
doesn't work.

00:24:06.290 --> 00:24:08.280
Case in point, navigator.onLine.

00:24:08.280 --> 00:24:10.570
Aside from having the
worst camel casing

00:24:10.570 --> 00:24:15.076
since XMLHttpRequest,
it's useless.

00:24:15.076 --> 00:24:18.500
If you have no Wi-Fi
reception and no other data,

00:24:18.500 --> 00:24:20.580
navigator.onLine is
going to be false.

00:24:20.580 --> 00:24:21.990
Right.

00:24:21.990 --> 00:24:26.510
If you have some
Wi-Fi, it will be true.

00:24:26.510 --> 00:24:28.315
Even if the router
you're connected to

00:24:28.315 --> 00:24:33.550
is ultimately plugged into
some soil, it will be true.

00:24:36.180 --> 00:24:38.670
Predictive doesn't
work. navigator.onLine

00:24:38.670 --> 00:24:41.350
doesn't know anything
outside the device.

00:24:41.350 --> 00:24:44.890
It only knows about
the first hop.

00:24:44.890 --> 00:24:47.120
It doesn't know if the
rest of the network

00:24:47.120 --> 00:24:48.650
has just soiled itself.

00:24:48.650 --> 00:24:51.260
It can't predict
that sort of thing.

00:24:51.260 --> 00:24:53.280
Instead, just try
making requests

00:24:53.280 --> 00:24:56.349
and react to what happens.

00:24:56.349 --> 00:24:58.390
So I've got a couple of
minutes left of the talk.

00:24:58.390 --> 00:24:59.098
It's quite short.

00:24:59.098 --> 00:25:01.710
But I wanted to throw
together some other API

00:25:01.710 --> 00:25:05.540
examples, some stuff that
I haven't covered so far.

00:25:05.540 --> 00:25:07.190
If you've got a
ServiceWorker looking

00:25:07.190 --> 00:25:09.470
like this-- you're caching
some stuff-- at some point,

00:25:09.470 --> 00:25:10.620
you'll want to change that.

00:25:10.620 --> 00:25:12.450
You want to change the
URLs that in there,

00:25:12.450 --> 00:25:15.620
maybe change the routeing, fix
some bugs, add some new routes,

00:25:15.620 --> 00:25:16.244
whatever.

00:25:16.244 --> 00:25:18.160
Well, the browser's going
to check for updates

00:25:18.160 --> 00:25:20.860
to your ServiceWorker
file, serviceworker.js.

00:25:20.860 --> 00:25:24.990
It's going to check for updates
on every page navigation.

00:25:24.990 --> 00:25:28.620
You can make this not happen
with HTTP headers if you want.

00:25:28.620 --> 00:25:30.965
But by default, every
page navigation.

00:25:30.965 --> 00:25:31.840
So just change stuff.

00:25:31.840 --> 00:25:33.130
I'm going to change the URLs.

00:25:33.130 --> 00:25:36.680
I'm going to use
cache, static-v2.

00:25:36.680 --> 00:25:37.526
The fine.

00:25:37.526 --> 00:25:39.900
The browser will pick up the
byte differences in the file

00:25:39.900 --> 00:25:43.120
and go, oh, this is a new
version of the ServiceWorker,

00:25:43.120 --> 00:25:44.770
excellent.

00:25:44.770 --> 00:25:47.780
So it's going to file uninstall
for that new ServiceWorker.

00:25:47.780 --> 00:25:49.710
But the old one is
going to remain running,

00:25:49.710 --> 00:25:51.900
handling requests and
pages that are active,

00:25:51.900 --> 00:25:53.510
that are actually using it.

00:25:53.510 --> 00:25:55.700
And that's why we create
static-v2 rather than mess

00:25:55.700 --> 00:25:58.116
around with static-v1, because
there are pages still using

00:25:58.116 --> 00:25:59.500
the old version.

00:25:59.500 --> 00:26:03.264
This new worker won't take
over dealing with pages

00:26:03.264 --> 00:26:05.180
until the static cache
is ready, because we've

00:26:05.180 --> 00:26:07.120
asked it to do that.

00:26:07.120 --> 00:26:09.550
But also, it waits for all
pages using the old version

00:26:09.550 --> 00:26:10.470
to go away.

00:26:10.470 --> 00:26:12.970
And this is important because
it means that you won't end up

00:26:12.970 --> 00:26:14.727
with a situation
where you've made

00:26:14.727 --> 00:26:16.810
some changes to your
database, but there are still

00:26:16.810 --> 00:26:19.670
some pages trying to use the
old model, the old pattern.

00:26:19.670 --> 00:26:21.380
And worse, they're
saving stuff that's

00:26:21.380 --> 00:26:23.255
not going to be picked
up by the new version.

00:26:25.900 --> 00:26:28.555
Of course, you can override
this, like most things.

00:26:28.555 --> 00:26:30.680
When you're ready, when
your static cache is ready,

00:26:30.680 --> 00:26:31.940
you can call event.replace.

00:26:31.940 --> 00:26:33.565
And this is saying,
look, I don't care.

00:26:33.565 --> 00:26:34.937
I am ready to go right now.

00:26:34.937 --> 00:26:36.020
Kick the other worker out.

00:26:36.020 --> 00:26:37.770
I'm going to take over
those pages I mean,

00:26:37.770 --> 00:26:39.936
that means you're going to
be taking over pages that

00:26:39.936 --> 00:26:41.728
were loaded using old
stuff from the cache.

00:26:41.728 --> 00:26:43.519
But if you can deal
with that, that's fine.

00:26:43.519 --> 00:26:44.880
You can take over straight away.

00:26:44.880 --> 00:26:47.855
Another method can smooth
this transition, reloadAll.

00:26:47.855 --> 00:26:49.230
What this is going
to tell-- it's

00:26:49.230 --> 00:26:52.980
going to tell the pages that
are currently active to unload.

00:26:52.980 --> 00:26:56.620
And when they're all unloaded,
the new worker will step in,

00:26:56.620 --> 00:26:57.850
and those pages will reload.

00:26:57.850 --> 00:27:00.480
But each page gets the
opportunity to cancel this.

00:27:00.480 --> 00:27:02.564
So if in one of the
pages, the user's

00:27:02.564 --> 00:27:04.480
halfway through writing
a comment or an email,

00:27:04.480 --> 00:27:06.930
it can go, nope, I'm not ready.

00:27:06.930 --> 00:27:08.145
I'm going to cancel this.

00:27:08.145 --> 00:27:11.000
And I'm going to let
you know when I'm done,

00:27:11.000 --> 00:27:14.830
and we can continue upgrading.

00:27:14.830 --> 00:27:17.461
You get an event when you're
ready to take over on activate.

00:27:17.461 --> 00:27:19.460
And this is the point
where you'll go and delete

00:27:19.460 --> 00:27:20.970
the old caches because you
don't need them anymore.

00:27:20.970 --> 00:27:21.940
The old worker's gone.

00:27:21.940 --> 00:27:24.850
You can do your IDB schema
migrations or whatever.

00:27:24.850 --> 00:27:29.140
You can rearrange file
systems and so on.

00:27:29.140 --> 00:27:30.820
So this is us
controlling the cache

00:27:30.820 --> 00:27:32.590
by changing a list of files.

00:27:32.590 --> 00:27:36.250
But you can let users
control the cache themselves

00:27:36.250 --> 00:27:37.510
by deferring that to them.

00:27:37.510 --> 00:27:40.110
So you might have a page
with a Read Later button.

00:27:40.110 --> 00:27:42.040
And when it's clicked,
you can postMessage

00:27:42.040 --> 00:27:44.170
to the ServiceWorker,
telling it,

00:27:44.170 --> 00:27:48.172
we want to cache the
article with this ID.

00:27:48.172 --> 00:27:49.630
And then over in
the ServiceWorker,

00:27:49.630 --> 00:27:51.920
you can pick that up
and go, oh, is this

00:27:51.920 --> 00:27:53.705
a post request for read later?

00:27:53.705 --> 00:27:55.330
Cool, I'm going to
go and find whatever

00:27:55.330 --> 00:27:59.360
URLs I need for that article
just using XHR or something.

00:27:59.360 --> 00:28:01.780
And when I've got
those, I'm going

00:28:01.780 --> 00:28:04.274
to create a new cache
for them, and I'm

00:28:04.274 --> 00:28:05.690
going to return
when that's ready.

00:28:05.690 --> 00:28:06.470
And then I'm going
to post message

00:28:06.470 --> 00:28:08.428
back to the page to say,
yes, that thing is now

00:28:08.428 --> 00:28:09.370
available offline.

00:28:09.370 --> 00:28:11.120
I mean, this is how
you would do something

00:28:11.120 --> 00:28:12.860
like a Read Later button.

00:28:12.860 --> 00:28:16.250
It gives you full independent
control of caching and routing.

00:28:16.250 --> 00:28:18.250
So this is something that
isn't in the spec yet.

00:28:18.250 --> 00:28:21.090
But I just wanted to show that
we were thinking about it.

00:28:21.090 --> 00:28:24.390
With your caches,
they're static.

00:28:24.390 --> 00:28:27.150
But we want you to be able
to make a cache that updates

00:28:27.150 --> 00:28:28.122
in the background.

00:28:28.122 --> 00:28:30.705
We don't know the API yet, but
just something like auto update

00:28:30.705 --> 00:28:31.482
is true.

00:28:31.482 --> 00:28:32.940
And this means that
the browser can

00:28:32.940 --> 00:28:34.440
update that cache
in the background,

00:28:34.440 --> 00:28:36.690
even when the browser's
not open on the phone.

00:28:36.690 --> 00:28:38.370
It can just be
periodically checking

00:28:38.370 --> 00:28:39.680
this stuff for updates.

00:28:39.680 --> 00:28:41.260
The frequency it
would do this would

00:28:41.260 --> 00:28:43.560
depend on how often the
user uses your site, which

00:28:43.560 --> 00:28:46.264
is the iOS model, which
works pretty well.

00:28:46.264 --> 00:28:48.180
So yeah, all works in
the background services.

00:28:48.180 --> 00:28:50.810
It's really nice.

00:28:50.810 --> 00:28:53.730
Developing for the web
has huge advantages.

00:28:53.730 --> 00:28:56.160
If a thing has a
screen, it's more

00:28:56.160 --> 00:28:58.450
and more likely to
have a browser on it.

00:28:58.450 --> 00:29:00.890
Most devices now
have a browser on.

00:29:00.890 --> 00:29:02.660
When someone goes
down the native path

00:29:02.660 --> 00:29:05.320
and develops multiple
versions of the same thing

00:29:05.320 --> 00:29:08.030
for different languages, as
a platform, we must ask why

00:29:08.030 --> 00:29:11.880
and fix that bug
because it is a bug.

00:29:11.880 --> 00:29:13.547
The ServiceWorker is
one of those fixes,

00:29:13.547 --> 00:29:15.213
as are many of the
things that are going

00:29:15.213 --> 00:29:16.990
to be covered over
the next two days.

00:29:16.990 --> 00:29:19.520
ServiceWorker lets you
get content on the screen

00:29:19.520 --> 00:29:21.690
seconds faster.

00:29:21.690 --> 00:29:23.800
You can use it to ride
smoothly over bumps

00:29:23.800 --> 00:29:25.626
and jams in the network.

00:29:25.626 --> 00:29:27.625
And it provides the
groundwork for other things,

00:29:27.625 --> 00:29:30.640
like background syncing,
alarms, push notifications.

00:29:30.640 --> 00:29:33.320
We're looking at putting all of
these things into this model.

00:29:33.320 --> 00:29:34.820
And I know know.

00:29:34.820 --> 00:29:37.361
You can probably tell that I'm
[INAUDIBLE] speaking about it.

00:29:37.361 --> 00:29:40.580
I'm really excited about
this, and we hope you are too.

00:29:40.580 --> 00:29:41.540
Thank you very much.

00:29:41.540 --> 00:29:42.440
Cheers.

00:29:42.440 --> 00:29:47.726
[APPLAUSE]

