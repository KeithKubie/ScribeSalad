WEBVTT
Kind: captions
Language: en

00:00:01.440 --> 00:00:04.030
SHONA DUTTA: Hi everyone
and welcome to this session

00:00:04.030 --> 00:00:08.850
of Google I/O 2016 Designer
and Developer Communication.

00:00:08.850 --> 00:00:11.640
So we'll be talking about
both visual design and motion

00:00:11.640 --> 00:00:14.100
design, with a focus
on visual design first.

00:00:14.100 --> 00:00:17.117
So my name is Shona and I'm
an Android visual designer.

00:00:17.117 --> 00:00:19.200
KIRILL GROUCHNIKOV: Welcome
everybody, I'm Kirill.

00:00:19.200 --> 00:00:22.986
I'm a UI interface engineer on
the UI toolkit team on Android.

00:00:22.986 --> 00:00:24.360
JOHN SCHLEMMER:
I'm John Plummer.

00:00:24.360 --> 00:00:26.359
I'm the motion lead on
the material design team.

00:00:26.359 --> 00:00:27.600
MARK WEI: And I'm Mark.

00:00:27.600 --> 00:00:31.304
I'm a motion engineer
on material design.

00:00:31.304 --> 00:00:34.130
SHONA DUTTA: So as I
mentioned, my name is Shona

00:00:34.130 --> 00:00:37.790
and I'm a visual designer
on the Android Design Team.

00:00:37.790 --> 00:00:40.390
As a designer I get to
have a lot of fun coming up

00:00:40.390 --> 00:00:44.140
with really cool solutions to
tough user experience problems.

00:00:44.140 --> 00:00:46.550
But as I'm creating
those solutions,

00:00:46.550 --> 00:00:49.580
I also need to be thinking about
how our talented engineering

00:00:49.580 --> 00:00:52.550
team is going to be
implementing them.

00:00:52.550 --> 00:00:55.490
So at Google for every
design that's created,

00:00:55.490 --> 00:00:58.600
we also create a
spec to go with it.

00:00:58.600 --> 00:01:00.530
Together we're going
to take a close look

00:01:00.530 --> 00:01:03.970
at what makes a spec
successful, the assets

00:01:03.970 --> 00:01:07.190
that we create to support
that spec, and also

00:01:07.190 --> 00:01:10.130
implementation throughout
process, communication,

00:01:10.130 --> 00:01:12.930
all of that.

00:01:12.930 --> 00:01:15.850
So let's get started with specs.

00:01:15.850 --> 00:01:19.020
A spec or a specification
is a common way

00:01:19.020 --> 00:01:23.380
for designers to document the
exact dimensions, distances,

00:01:23.380 --> 00:01:27.550
colors of objects, and
text within the design.

00:01:27.550 --> 00:01:31.080
But when we say that a
designer hands off a spec,

00:01:31.080 --> 00:01:33.400
we don't mean that they get
to wipe their hands clean

00:01:33.400 --> 00:01:37.040
as soon as it hits engineering.

00:01:37.040 --> 00:01:39.990
Implementation of a
spec is a conversation

00:01:39.990 --> 00:01:43.020
that exists between
design and engineering

00:01:43.020 --> 00:01:45.560
and it ensures that we're
tweaking and maneuvering

00:01:45.560 --> 00:01:47.440
to make the most out of
the Android platform.

00:01:50.090 --> 00:01:53.560
To make a spec designers need
to understand some basics

00:01:53.560 --> 00:01:56.080
about the Android
platform first.

00:01:56.080 --> 00:01:58.780
First of all there, are
a ton of screen sizes

00:01:58.780 --> 00:02:01.200
that we need to account for.

00:02:01.200 --> 00:02:03.680
Fortunately, we don't need
to make unique designs

00:02:03.680 --> 00:02:05.440
for every one of
the screen sizes.

00:02:05.440 --> 00:02:08.389
That might drive us
a little bit crazy.

00:02:08.389 --> 00:02:13.470
Instead, we can rely on density
independent pixels, or dips

00:02:13.470 --> 00:02:16.070
to ensure that we can
specify one design that

00:02:16.070 --> 00:02:19.500
will work across a
variety of screen sizes.

00:02:19.500 --> 00:02:23.380
Dips are flexible units that
scale to uniform dimensions

00:02:23.380 --> 00:02:25.240
across these screens.

00:02:25.240 --> 00:02:27.800
Here's an example that shows
a floating action button

00:02:27.800 --> 00:02:29.390
across a variety of screens.

00:02:31.729 --> 00:02:34.020
KIRILL GROUCHNIKOV: I've been
doing Android development

00:02:34.020 --> 00:02:36.330
for over six years.

00:02:36.330 --> 00:02:38.539
For a little bit
over six years, and I

00:02:38.539 --> 00:02:40.580
think the most important
part for me to remember,

00:02:40.580 --> 00:02:43.710
and I hope you also remember,
that Android ecosystem is

00:02:43.710 --> 00:02:46.810
this continuum of screen
sizes, screen densities, screen

00:02:46.810 --> 00:02:50.190
resolutions, aspect ratios,
and pretty much every hardware

00:02:50.190 --> 00:02:52.350
aspect that you can think
of, there's a variety,

00:02:52.350 --> 00:02:53.760
there's this continuum.

00:02:53.760 --> 00:02:55.700
Much like the world
of web development,

00:02:55.700 --> 00:02:58.920
web design of the
last 20, 25 years that

00:02:58.920 --> 00:03:02.360
doesn't operate on
the fixed size of 800

00:03:02.360 --> 00:03:06.010
by 600 pixels, the same applies
to the world the Android design

00:03:06.010 --> 00:03:07.270
and Android development.

00:03:07.270 --> 00:03:09.180
You don't design for
the particular screen

00:03:09.180 --> 00:03:11.180
that you have in your
hand, just because you

00:03:11.180 --> 00:03:14.550
love that specific form factor,
be it a four inch, five inch,

00:03:14.550 --> 00:03:16.550
or maybe a 10 inch tablet.

00:03:16.550 --> 00:03:20.290
Instead, the layout
solution, the layout spec,

00:03:20.290 --> 00:03:22.160
the way you
represent information

00:03:22.160 --> 00:03:24.900
in your particular application,
your particular flow,

00:03:24.900 --> 00:03:30.217
needs to adapt to reflow to
the amount of screen space

00:03:30.217 --> 00:03:30.800
that you have.

00:03:33.490 --> 00:03:35.180
As you can see here
on the left, where

00:03:35.180 --> 00:03:38.390
you don't have a lot of screen
estate on a smaller phone,

00:03:38.390 --> 00:03:41.660
and you go to this vertical
list with smaller images,

00:03:41.660 --> 00:03:44.610
and then as you get
a bigger canvas,

00:03:44.610 --> 00:03:47.590
tablets size canvas,
desktop size canvas,

00:03:47.590 --> 00:03:52.680
you can go to a multi-column
grid with larger images.

00:03:52.680 --> 00:03:54.570
And that's just
one example of how

00:03:54.570 --> 00:03:57.750
the representation of
your content adapts,

00:03:57.750 --> 00:04:02.540
reflows, responds to
this larger canvas.

00:04:02.540 --> 00:04:05.990
In the world of web design,
it's called responsive design

00:04:05.990 --> 00:04:09.850
and breakpoints where the
layout, the presentation

00:04:09.850 --> 00:04:13.590
responds to the changes and the
size of your browser window.

00:04:13.590 --> 00:04:17.890
And break point is that part
where you say now my screen

00:04:17.890 --> 00:04:22.200
is sufficiently larger to
switch to a different way

00:04:22.200 --> 00:04:24.280
of representing
this information.

00:04:24.280 --> 00:04:25.910
In the world of
Android up until now,

00:04:25.910 --> 00:04:28.470
we chose that you call
it adaptive design,

00:04:28.470 --> 00:04:32.560
mostly because you don't really
resize an Android application

00:04:32.560 --> 00:04:33.480
window.

00:04:33.480 --> 00:04:36.380
It kind of goes in a full
screen, apart from the Status

00:04:36.380 --> 00:04:37.970
bar and Navigation bar.

00:04:37.970 --> 00:04:40.370
This is changing,
and Android and where

00:04:40.370 --> 00:04:43.600
we are introducing the
split screen functionality

00:04:43.600 --> 00:04:45.590
for phones as well
as for tablets,

00:04:45.590 --> 00:04:48.700
where you don't know
which parts of the screen

00:04:48.700 --> 00:04:50.424
your app is going to occupy.

00:04:50.424 --> 00:04:51.840
And it becomes
ever more important

00:04:51.840 --> 00:04:54.590
for your design solution, for
your implementation solution

00:04:54.590 --> 00:04:59.986
to scale gracefully to
that space on the screen.

00:04:59.986 --> 00:05:02.470
SHONA DUTTA: So one
aspect of the continuum

00:05:02.470 --> 00:05:06.440
that Kirill is talking
about is screen density.

00:05:06.440 --> 00:05:10.330
Dips are our primary way of
approaching different screen

00:05:10.330 --> 00:05:11.590
densities.

00:05:11.590 --> 00:05:14.340
So let's talk about how
best to leverage them.

00:05:14.340 --> 00:05:20.260
To design using dips for
phones in portrait mode,

00:05:20.260 --> 00:05:22.690
we use artboards that
are rendered at mdpi.

00:05:22.690 --> 00:05:26.860
So when I say artboards, I'm
talking about in Illustrator.

00:05:26.860 --> 00:05:31.020
And this is with the
screen size of 360 by 640.

00:05:31.020 --> 00:05:33.350
Of course we still need to
create additional designs

00:05:33.350 --> 00:05:36.860
for tablet layouts,
desktop, other form factors.

00:05:36.860 --> 00:05:38.790
But for the purposes
of this session,

00:05:38.790 --> 00:05:43.220
we'll be focusing on a
phone in portrait mode.

00:05:43.220 --> 00:05:46.230
When we're ready to
export these screens,

00:05:46.230 --> 00:05:50.460
we can do so at
1.5, 2, 3, and 4x

00:05:50.460 --> 00:05:52.970
to create mockups
that are appropriate

00:05:52.970 --> 00:05:55.040
for different device densities.

00:05:55.040 --> 00:06:00.130
So in this example, I
have created a mock at 360

00:06:00.130 --> 00:06:02.960
by 640, which is mdpi.

00:06:02.960 --> 00:06:06.970
And then I've exported it at
3x to create a screen that

00:06:06.970 --> 00:06:10.280
is xx each dpi sized.

00:06:10.280 --> 00:06:13.070
That means that when I
put the mock on my phone,

00:06:13.070 --> 00:06:15.101
it'll show up very
crisp and clear,

00:06:15.101 --> 00:06:17.225
just like it will in reality
when it's implemented.

00:06:19.870 --> 00:06:23.430
There are few reasons why we
work at mdpi from the beginning

00:06:23.430 --> 00:06:25.460
instead of at a larger density.

00:06:25.460 --> 00:06:28.710
Firstly, working at
mdpi ensures that users

00:06:28.710 --> 00:06:31.750
on smaller or lower
density screens

00:06:31.750 --> 00:06:34.080
will still be able
to read all the text

00:06:34.080 --> 00:06:38.380
and tap on appropriately
sized buttons.

00:06:38.380 --> 00:06:41.160
Secondly, it's easy to
export mocks and assets

00:06:41.160 --> 00:06:44.910
at higher resolutions after
they're designed and mdpi.

00:06:44.910 --> 00:06:47.480
It's much harder to reduce
resolution and still

00:06:47.480 --> 00:06:51.140
count on your designs
being crisp and clean.

00:06:51.140 --> 00:06:54.630
So in this example we've
taken a larger asset

00:06:54.630 --> 00:06:59.650
and scaled it down, and you can
see that the edges are blurry.

00:06:59.650 --> 00:07:01.960
Thirdly, when you're
working on 100 artboard file

00:07:01.960 --> 00:07:03.930
in Illustrator, and
each of those artboards

00:07:03.930 --> 00:07:06.850
is 1080 by 1920,
even vector artwork

00:07:06.850 --> 00:07:08.910
can get pretty sluggish.

00:07:08.910 --> 00:07:11.780
So instead, we keep those
files manageable by working

00:07:11.780 --> 00:07:13.270
at a smaller resolution first.

00:07:15.835 --> 00:07:18.280
KIRILL GROUCHNIKOV: So as
Shona already mentioned,

00:07:18.280 --> 00:07:20.380
device independent
pixels or dips

00:07:20.380 --> 00:07:23.100
are one of the most basic and
one of the most important units

00:07:23.100 --> 00:07:25.720
or concepts that we have
in the world of Android.

00:07:25.720 --> 00:07:28.560
It allows you to abstract
away the physical resolution

00:07:28.560 --> 00:07:32.870
of the screen and operate on
just the right level on just

00:07:32.870 --> 00:07:34.400
the right units.

00:07:34.400 --> 00:07:37.980
I remember I joined the
Android team in 2009 just

00:07:37.980 --> 00:07:39.320
before Nexus One was announced.

00:07:39.320 --> 00:07:42.560
And that was kind of like
top of the line hdpi screen.

00:07:42.560 --> 00:07:44.970
Back then we had
ldpi, mdpi, and hdpi.

00:07:44.970 --> 00:07:47.510
And now we have
double x, triple x,

00:07:47.510 --> 00:07:49.930
and who knows what will happen
over the next five years?

00:07:49.930 --> 00:07:51.500
I don't know.

00:07:51.500 --> 00:07:53.420
No comment.

00:07:53.420 --> 00:07:55.810
And it becomes ever more
important to remember that you

00:07:55.810 --> 00:07:57.100
don't operate in pixels.

00:07:57.100 --> 00:07:59.120
Instead, you operate in dips.

00:07:59.120 --> 00:08:01.210
So every mock that you
get from your designers

00:08:01.210 --> 00:08:03.780
needs to be implemented, all
the margins, all the sizes,

00:08:03.780 --> 00:08:07.540
all the paddings in dips, unless
you're absolutely sure that you

00:08:07.540 --> 00:08:10.810
want to use pixels for something
like hairline separators.

00:08:10.810 --> 00:08:14.040
But even those tend to
disappear on double x, triple x,

00:08:14.040 --> 00:08:15.430
hpdi screens.

00:08:15.430 --> 00:08:17.700
So that might not
be the best idea.

00:08:17.700 --> 00:08:23.980
The only exception to you
using dips everywhere is text.

00:08:23.980 --> 00:08:27.750
For text, we should be using
scale independent pixels,

00:08:27.750 --> 00:08:30.160
or sp, not sip, sp.

00:08:30.160 --> 00:08:33.490
The only difference
between dips and sp's is

00:08:33.490 --> 00:08:35.280
that in addition
to abstracting away

00:08:35.280 --> 00:08:39.030
the physical resolution
of the screen,

00:08:39.030 --> 00:08:42.730
a user is also able to go into
the global device settings

00:08:42.730 --> 00:08:45.170
and bump up, globally
bump up or bump down,

00:08:45.170 --> 00:08:47.690
globally the text size
across all the apps.

00:08:47.690 --> 00:08:50.920
And we should respect that
across the entire system.

00:08:50.920 --> 00:08:55.840
So in your implementation,
everything should sp units.

00:08:55.840 --> 00:08:59.090
Finally, everything
that can be interacted

00:08:59.090 --> 00:09:01.390
with on your screen,
no matter how big

00:09:01.390 --> 00:09:04.770
or how small the screen itself
is, should be at least 48

00:09:04.770 --> 00:09:06.070
by 48 dips.

00:09:06.070 --> 00:09:09.850
And unlike maybe some parts
of material design guidelines,

00:09:09.850 --> 00:09:11.060
this is not a guideline.

00:09:11.060 --> 00:09:14.200
This should be a
very hard requirement

00:09:14.200 --> 00:09:17.100
that you should not budge from.

00:09:17.100 --> 00:09:20.160
So as you can see here, an
example of maybe a smaller

00:09:20.160 --> 00:09:22.150
asset that you get
from your designer,

00:09:22.150 --> 00:09:26.130
they search icon, which
might be 24 by 24 dips,

00:09:26.130 --> 00:09:29.710
but still when you put it in
your actual XML file however,

00:09:29.710 --> 00:09:33.210
you operate at that level, it
might be in a visual designer,

00:09:33.210 --> 00:09:36.210
it might be hand coding.

00:09:36.210 --> 00:09:38.570
You should make sure
that the actual typeable

00:09:38.570 --> 00:09:42.230
area around that icon
is 48 by 48 dips, which

00:09:42.230 --> 00:09:44.450
you can do with paddings,
you can do it with margins.

00:09:44.450 --> 00:09:47.070
Or you can go back to your
designer and say well actually,

00:09:47.070 --> 00:09:50.480
the easiest for us would
be to cut that asset at 48

00:09:50.480 --> 00:09:54.984
by 48 instead of 24 by 24.

00:09:54.984 --> 00:09:57.410
SHONA DUTTA: As Kirill
mentioned, typography

00:09:57.410 --> 00:10:01.110
is specced using sp's,
scale independent pixels.

00:10:01.110 --> 00:10:04.040
Unlike dips, these
scale based not only

00:10:04.040 --> 00:10:06.880
on the user's screen
density, but also

00:10:06.880 --> 00:10:08.780
on their font preferences.

00:10:08.780 --> 00:10:11.580
So if the user has Large
Text mode turned on

00:10:11.580 --> 00:10:13.940
for improved
accessibility, then we

00:10:13.940 --> 00:10:19.470
can ensure that your app will
observe this and respect it.

00:10:19.470 --> 00:10:21.960
Now that we've gone over
the units of measure

00:10:21.960 --> 00:10:25.240
for typography, let's take a
look at a concrete example.

00:10:25.240 --> 00:10:27.790
This is an example
of a type spec.

00:10:27.790 --> 00:10:33.060
So you can see that we have
indicated font, color, size,

00:10:33.060 --> 00:10:34.450
and opacity.

00:10:34.450 --> 00:10:36.610
So these are all key
pieces of information

00:10:36.610 --> 00:10:38.489
to communicate to engineering.

00:10:38.489 --> 00:10:40.530
However, there is one
large piece that's missing.

00:10:43.110 --> 00:10:45.760
That is text
placement with regard

00:10:45.760 --> 00:10:47.990
to other elements on the screen.

00:10:47.990 --> 00:10:50.680
So in the material spec
they do a great job

00:10:50.680 --> 00:10:53.180
of making sure that we
have information about how

00:10:53.180 --> 00:10:55.600
to align text two key lines.

00:10:55.600 --> 00:10:59.300
And it talks about line
spacing between lines of text.

00:10:59.300 --> 00:11:01.560
However there are times
at which designers

00:11:01.560 --> 00:11:04.870
will need to spec text placement
that aren't necessarily covered

00:11:04.870 --> 00:11:07.130
in the material design spec.

00:11:07.130 --> 00:11:09.820
And in those cases it can
be a little bit difficult.

00:11:09.820 --> 00:11:12.970
This is because design
applications like Photoshop,

00:11:12.970 --> 00:11:16.600
Illustrator, and Sketch
all treat text bounding

00:11:16.600 --> 00:11:19.790
boxes a little bit differently.

00:11:19.790 --> 00:11:23.200
They tend to add their own
padding a little bit at a time,

00:11:23.200 --> 00:11:25.780
and there's some
variety in between them.

00:11:25.780 --> 00:11:28.610
So for this reason, it
can be misleading to try

00:11:28.610 --> 00:11:33.190
to use text bounding boxes to
place text within a design.

00:11:33.190 --> 00:11:35.440
Instead of using
the bounding boxes,

00:11:35.440 --> 00:11:39.580
we recommend that you
use text baselines.

00:11:39.580 --> 00:11:41.540
By measuring from the
top of a container

00:11:41.540 --> 00:11:44.740
to the first baseline
in the block of text,

00:11:44.740 --> 00:11:47.810
and then from the last baseline
in the same block of text

00:11:47.810 --> 00:11:49.530
to the bottom of
the container, we

00:11:49.530 --> 00:11:54.142
can accurately place the
text within the container.

00:11:54.142 --> 00:11:56.980
KIRILL GROUCHNIKOV: So baseline,
at least in Latin scripts

00:11:56.980 --> 00:11:59.300
is where kind of the
bulk of the text resides,

00:11:59.300 --> 00:12:01.390
it's kind of this virtual line.

00:12:01.390 --> 00:12:03.830
This is not true for all
the scripts out there.

00:12:03.830 --> 00:12:07.610
Some index scripts have a little
bit more vertical variety.

00:12:07.610 --> 00:12:10.220
The baseline is slightly
below what we would usually

00:12:10.220 --> 00:12:13.576
consider if you come from
the world of Latin scripts,

00:12:13.576 --> 00:12:15.950
what we would usually consider
where the bulk of the text

00:12:15.950 --> 00:12:16.940
resides.

00:12:16.940 --> 00:12:19.530
We have the ascender line
and the descender line,

00:12:19.530 --> 00:12:21.880
which again for
Latin scripts, that

00:12:21.880 --> 00:12:25.440
is kind of like the true
bounding box of the text.

00:12:25.440 --> 00:12:29.960
But if you go beyond the world
Latin scripts and go global,

00:12:29.960 --> 00:12:32.410
there are absolutely
scripts out there

00:12:32.410 --> 00:12:34.270
that have some parts
of their glyphs

00:12:34.270 --> 00:12:36.340
some parts of their
characters going

00:12:36.340 --> 00:12:39.560
above the ascender line, below
the descender line, or both.

00:12:39.560 --> 00:12:41.680
And these are just
a few examples

00:12:41.680 --> 00:12:45.370
from around the
world of scripts that

00:12:45.370 --> 00:12:49.190
have a little bit more
vertical variety in the rhythm.

00:12:49.190 --> 00:12:53.880
And some developers that
want to have a little bit

00:12:53.880 --> 00:12:57.050
more precise control over
placement and alignment

00:12:57.050 --> 00:13:00.830
of text, choose to use the
Android Include Font Padding

00:13:00.830 --> 00:13:02.680
attribute and set it to False.

00:13:02.680 --> 00:13:04.940
That works great
for Latin scripts.

00:13:04.940 --> 00:13:07.300
You have that precise
control, but you

00:13:07.300 --> 00:13:10.160
will discover that
it starts cutting off

00:13:10.160 --> 00:13:13.500
those top and bottom parts of
the glyphs under index scripts

00:13:13.500 --> 00:13:16.970
and under a wide variety
of non-Latin scripts.

00:13:16.970 --> 00:13:19.240
So instead of using
that attribute, which

00:13:19.240 --> 00:13:23.800
is heavily discouraged, instead,
get the Font Metrics Object

00:13:23.800 --> 00:13:25.490
from your Text View.

00:13:25.490 --> 00:13:28.360
Then you can query different
attributes, different fields

00:13:28.360 --> 00:13:34.790
on that font metrics to get
where the descender line is

00:13:34.790 --> 00:13:37.250
and a couple of other
parameters, attributes.

00:13:37.250 --> 00:13:40.650
And then call Set Line
Spacing API in your Text View

00:13:40.650 --> 00:13:42.870
to increase or decrease
the line spacing

00:13:42.870 --> 00:13:46.650
based on the particular
requirement from your design.

00:13:46.650 --> 00:13:49.840
Finally, if you want to
tweak the vertical rhythm

00:13:49.840 --> 00:13:53.930
in between Text Views
that aspect vertically,

00:13:53.930 --> 00:13:55.890
you can set top
and bottom padding

00:13:55.890 --> 00:13:58.530
on the Text View once
again based on your design,

00:13:58.530 --> 00:14:01.950
and based on the specific
metrics of the font that

00:14:01.950 --> 00:14:04.060
is currently being
dynamically used

00:14:04.060 --> 00:14:06.731
under the particular locale.

00:14:06.731 --> 00:14:08.860
SHONA DUTTA: So as you
can tell, typography

00:14:08.860 --> 00:14:10.390
can be a tricky subject.

00:14:10.390 --> 00:14:13.310
However when it's done well,
it can add a lot of polish

00:14:13.310 --> 00:14:14.810
to your app.

00:14:14.810 --> 00:14:18.150
Also remember whenever
possible, preview your designs

00:14:18.150 --> 00:14:19.430
on an actual device.

00:14:19.430 --> 00:14:21.900
So put the mockup on the device.

00:14:21.900 --> 00:14:24.680
That way you can tell whether
your text is readable.

00:14:24.680 --> 00:14:27.390
There's really nothing like
actually seeing the screens

00:14:27.390 --> 00:14:30.095
on a device to figure out
when your designs are working

00:14:30.095 --> 00:14:30.595
or not.

00:14:33.620 --> 00:14:37.407
Let's shift gears and talk
about shipping some assets.

00:14:37.407 --> 00:14:38.990
Earlier we talked
about the importance

00:14:38.990 --> 00:14:43.020
of working at mdpi when you're
working on the overall design.

00:14:43.020 --> 00:14:47.280
This is still true
when working on assets.

00:14:47.280 --> 00:14:51.380
When making icons, nine patches,
and another graphical elements,

00:14:51.380 --> 00:14:53.430
we still want to
be working at mdpi.

00:14:53.430 --> 00:14:58.310
Like in this example, which has
an asset from material design

00:14:58.310 --> 00:15:01.700
at 24 by 24.

00:15:01.700 --> 00:15:04.380
By ensuring that the
asset is crisp and clean

00:15:04.380 --> 00:15:09.140
at the small size, when we
scale it up by 2 or 3 or 4x,

00:15:09.140 --> 00:15:12.020
we can ensure that it remains
just as crisp at the larger

00:15:12.020 --> 00:15:14.570
sizes.

00:15:14.570 --> 00:15:18.120
Going the other direction,
moving from large to small,

00:15:18.120 --> 00:15:21.050
it's easy to run into icons
that have blurry edges

00:15:21.050 --> 00:15:24.050
and pour definition as
they're scaled down.

00:15:24.050 --> 00:15:27.070
This is because vector points
that fell on whole pixels

00:15:27.070 --> 00:15:30.630
at the large size can start
to fall on partial pixels

00:15:30.630 --> 00:15:32.670
when scaled down.

00:15:32.670 --> 00:15:35.270
Here's an example of an
icon that started large

00:15:35.270 --> 00:15:37.369
and got shrunk down
to a smaller size.

00:15:37.369 --> 00:15:38.910
You can see that it
has blurry edges.

00:15:41.500 --> 00:15:43.500
Remember that since we're
talking about Android,

00:15:43.500 --> 00:15:46.370
we need to ship assets
at a variety of sizes

00:15:46.370 --> 00:15:49.160
to suit all screen densities.

00:15:49.160 --> 00:15:51.410
At Google we
typically use PNGs is

00:15:51.410 --> 00:15:53.910
for this because they
handle transparency

00:15:53.910 --> 00:15:58.830
very well while still
maintaining small file sizes.

00:15:58.830 --> 00:16:00.500
However one of the
great new features

00:16:00.500 --> 00:16:03.120
that we recently introduced
is backwards compatibility

00:16:03.120 --> 00:16:05.200
for handling vector assets.

00:16:05.200 --> 00:16:08.510
Previously vector assets were
only available to Android 5.0

00:16:08.510 --> 00:16:09.740
and beyond.

00:16:09.740 --> 00:16:12.090
With the new availability
of vector drawables

00:16:12.090 --> 00:16:16.200
in older versions of Android,
now assets like this icon

00:16:16.200 --> 00:16:18.320
can be shipped as a
single vector asset

00:16:18.320 --> 00:16:21.170
and scaled dynamically
at run time.

00:16:21.170 --> 00:16:24.220
This is absolutely
fantastic for APK sizes

00:16:24.220 --> 00:16:26.240
because the size
of a vector asset

00:16:26.240 --> 00:16:29.480
is far smaller than the
aggregate size of all the PNG

00:16:29.480 --> 00:16:34.250
assets that one would need
for all the screen densities.

00:16:34.250 --> 00:16:36.870
But remember designers,
your vector assets

00:16:36.870 --> 00:16:38.870
will need to be
perfectly snapped

00:16:38.870 --> 00:16:41.960
to the pixel grid in order
to appear crisp and clean

00:16:41.960 --> 00:16:45.107
when they are rendered.

00:16:45.107 --> 00:16:47.190
KIRILL GROUCHNIKOV: So
going back to this variety,

00:16:47.190 --> 00:16:49.460
this continuum of screen
densities, once again,

00:16:49.460 --> 00:16:52.420
when I started it
was hdpi was the top.

00:16:52.420 --> 00:16:54.940
And now we have,
let's say we're not

00:16:54.940 --> 00:16:57.040
shipping ldpi assets
anymore anywhere,

00:16:57.040 --> 00:17:02.060
but you still have lower spec,
lower end devices at that mdpi.

00:17:02.060 --> 00:17:05.875
So if you go mdpi, hpdi,
single, double, triple x.

00:17:05.875 --> 00:17:08.250
And once again, who knows what
will happen in the future?

00:17:08.250 --> 00:17:11.050
Those PNG sizes start
adding up pretty quickly.

00:17:11.050 --> 00:17:13.270
And vector assets
are a great way

00:17:13.270 --> 00:17:17.000
to cut down on that extra
size introduced by the assets,

00:17:17.000 --> 00:17:21.369
by these PNG assets to your
overall APK binary size.

00:17:21.369 --> 00:17:24.190
And this backwards
compatibility support

00:17:24.190 --> 00:17:26.980
for vector drawables that was
added as part of the App Compat

00:17:26.980 --> 00:17:29.340
Support Library, when
we switched that support

00:17:29.340 --> 00:17:33.370
library itself to use vector
assets for a variety of search

00:17:33.370 --> 00:17:39.050
box icons in a couple of other
places, the overall binary

00:17:39.050 --> 00:17:43.260
size of that module of that
support library dropped by 9%.

00:17:43.260 --> 00:17:46.460
And 9%, if you multiply
it by however many devices

00:17:46.460 --> 00:17:49.880
your app happens to target,
or you hope to have,

00:17:49.880 --> 00:17:51.860
that's a lot of bytes.

00:17:51.860 --> 00:17:54.710
Megabytes, hopefully
gigabytes, terabytes.

00:17:54.710 --> 00:17:58.830
This is how you
go about enabling

00:17:58.830 --> 00:18:01.500
backwards compatible
support for vector assets.

00:18:01.500 --> 00:18:04.810
If your app is targeting
pre-Lollipop devices, devices

00:18:04.810 --> 00:18:11.380
that ship with that pre-Android
5.0 release, this same way you

00:18:11.380 --> 00:18:14.560
have your vector drawable
in your Resources folder,

00:18:14.560 --> 00:18:17.110
you enable the support for
vector drawables in your Gradle

00:18:17.110 --> 00:18:17.890
file.

00:18:17.890 --> 00:18:21.640
And then automatically
your Image View

00:18:21.640 --> 00:18:24.200
that is under the hood
automatically converted

00:18:24.200 --> 00:18:27.220
to use the App Compats
version of the Image View

00:18:27.220 --> 00:18:29.870
has this built in support
for vector drawables

00:18:29.870 --> 00:18:32.020
as its sources.

00:18:32.020 --> 00:18:35.760
If you still use the
PNG assets, there's

00:18:35.760 --> 00:18:39.340
great news for apps that
want to team or colorize

00:18:39.340 --> 00:18:42.250
a certain asset or
more than one asset

00:18:42.250 --> 00:18:44.370
based on the specific
colors that you're using.

00:18:44.370 --> 00:18:47.830
Play Store is a great
example that is using this.

00:18:47.830 --> 00:18:51.190
In Play Store we have these
kind of color language

00:18:51.190 --> 00:18:53.910
for different parts of
our media offerings.

00:18:53.910 --> 00:18:57.910
We have light blue for
books, darker red for movies,

00:18:57.910 --> 00:18:59.710
orange for music, and so on.

00:18:59.710 --> 00:19:02.250
So instead of shipping
five or six sets

00:19:02.250 --> 00:19:06.150
of assets that have
the same shape,

00:19:06.150 --> 00:19:08.660
but are colored or tinted
differently, instead

00:19:08.660 --> 00:19:13.130
we can now ship only one base
set of assets, PNG assets,

00:19:13.130 --> 00:19:14.760
that are just white color.

00:19:14.760 --> 00:19:17.870
And then colorize them at run
time, tint them at run time,

00:19:17.870 --> 00:19:19.790
by wrapping the
original drawable

00:19:19.790 --> 00:19:25.330
and then calling this APIs
to set tint or set tint mode.

00:19:25.330 --> 00:19:28.160
And this works
great, by the way,

00:19:28.160 --> 00:19:31.360
with the overall iconography
language of material design

00:19:31.360 --> 00:19:35.490
that has simple shapes
and that has single color.

00:19:35.490 --> 00:19:37.880
And that lends itself
very well to representing

00:19:37.880 --> 00:19:39.600
those icons in vector format.

00:19:42.175 --> 00:19:44.960
SHONA DUTTA: Now that we've
got a robust spec and a set

00:19:44.960 --> 00:19:47.830
of assets to work with,
design's work wraps up

00:19:47.830 --> 00:19:51.000
and implementation
begins, right?

00:19:51.000 --> 00:19:52.480
No, not the case.

00:19:52.480 --> 00:19:54.190
Remember, we don't hand off.

00:19:54.190 --> 00:19:57.010
Instead we consider
design and implementation

00:19:57.010 --> 00:19:59.270
to be part of a
larger conversation.

00:19:59.270 --> 00:20:01.730
Since we're all working
towards great experiences

00:20:01.730 --> 00:20:06.060
for our users, we make sure that
engine design are collaborating

00:20:06.060 --> 00:20:08.700
from the beginning, so
that when we ship a product

00:20:08.700 --> 00:20:12.559
it's both beautiful
and functional.

00:20:12.559 --> 00:20:15.100
KIRILL GROUCHNIKOV: So I might
be dating myself a little bit.

00:20:15.100 --> 00:20:19.020
I remember the old days
off waterfall approach

00:20:19.020 --> 00:20:22.750
to developing,
designing applications.

00:20:22.750 --> 00:20:25.890
Those where bad days.

00:20:25.890 --> 00:20:28.230
So basically designers
would do their own thing

00:20:28.230 --> 00:20:30.326
as one big iteration.

00:20:30.326 --> 00:20:31.700
You wouldn't even
call iteration,

00:20:31.700 --> 00:20:32.940
you would call it a phase.

00:20:32.940 --> 00:20:35.250
And then they hand over
the entire spec to you

00:20:35.250 --> 00:20:36.380
as a developer.

00:20:36.380 --> 00:20:38.490
And then you go
away and you work

00:20:38.490 --> 00:20:42.500
on however many weeks or months
that happened to be needed.

00:20:42.500 --> 00:20:44.410
And then this is done.

00:20:44.410 --> 00:20:46.990
This is not how it should
be going, especially

00:20:46.990 --> 00:20:49.300
in the world where we target
this variety of screen

00:20:49.300 --> 00:20:53.400
densities, screen aspect ratios,
screen resolutions, again, you

00:20:53.400 --> 00:20:56.820
should start with something
quick, low fidelity mocks

00:20:56.820 --> 00:20:59.280
that you implement and
put on this piece of glass

00:20:59.280 --> 00:21:01.940
in your hand so that
you can see what works

00:21:01.940 --> 00:21:03.232
and what doesn't work.

00:21:03.232 --> 00:21:05.190
It doesn't have to work
with the real back end.

00:21:05.190 --> 00:21:07.460
It doesn't have to
work with real images.

00:21:07.460 --> 00:21:11.090
But it definitely informs your
next iteration much better

00:21:11.090 --> 00:21:14.680
then just looking at this pixel
perfect mock of your phone

00:21:14.680 --> 00:21:19.650
screen size, phone screen that
is on this gigantic 30 inch

00:21:19.650 --> 00:21:21.470
monitor that designers love.

00:21:21.470 --> 00:21:24.740
It's not the same
level of feedback

00:21:24.740 --> 00:21:27.270
that you get from having
something on your device.

00:21:27.270 --> 00:21:29.820
And then your next
iteration, you

00:21:29.820 --> 00:21:31.770
grow progressively
from low fidelity

00:21:31.770 --> 00:21:33.400
to higher fidelity mocks.

00:21:33.400 --> 00:21:35.850
At every step, you know that
you're making these informed

00:21:35.850 --> 00:21:38.590
decisions.

00:21:38.590 --> 00:21:40.940
I call this here a
corner cases, but they

00:21:40.940 --> 00:21:42.900
are anything but corner.

00:21:42.900 --> 00:21:46.160
You need to think what happens
when your implementation,

00:21:46.160 --> 00:21:49.950
when your app, when your flow
leaves in the real world.

00:21:49.950 --> 00:21:54.320
And the real world is full
off 2G or 3G connections.

00:21:54.320 --> 00:21:56.010
When you wait for
multiple seconds

00:21:56.010 --> 00:21:59.420
to see those
information bits that

00:21:59.420 --> 00:22:01.760
are not yet available
as they loading

00:22:01.760 --> 00:22:03.290
from the mobile network.

00:22:03.290 --> 00:22:05.530
You live in the
world where people

00:22:05.530 --> 00:22:08.040
are on metered
connections and so on.

00:22:08.040 --> 00:22:11.270
So you need to think about what
happens during that loading

00:22:11.270 --> 00:22:13.710
phase from the
design perspective,

00:22:13.710 --> 00:22:17.130
how the design scales to
those intermediary states,

00:22:17.130 --> 00:22:19.570
and how, from the
limitation perspective,

00:22:19.570 --> 00:22:23.690
you address those empty states,
intermediary loading states.

00:22:23.690 --> 00:22:26.490
As far as an empty state,
something like Inbox Zero,

00:22:26.490 --> 00:22:28.710
people love Inbox Zero.

00:22:28.710 --> 00:22:32.020
So what happens when you don't
have anything in that inbox?

00:22:32.020 --> 00:22:35.120
What happens when you just
joined the new social network,

00:22:35.120 --> 00:22:38.270
and you don't have
anything in your stream?

00:22:38.270 --> 00:22:42.250
Instead of discouraging the
user with this empty canvas,

00:22:42.250 --> 00:22:45.270
instead you can encourage
him or her with something

00:22:45.270 --> 00:22:48.000
a little bit more human,
a little bit more friendly

00:22:48.000 --> 00:22:50.670
like seen here in the
example on the left.

00:22:50.670 --> 00:22:52.200
In the example on
the right, you can

00:22:52.200 --> 00:22:56.990
see what we call tinting or
colorization of certain pieces

00:22:56.990 --> 00:23:01.760
of your UI, based on
predominant vibrant other colors

00:23:01.760 --> 00:23:02.860
from this hero graphic.

00:23:02.860 --> 00:23:05.170
But what happens if
this hero graphic

00:23:05.170 --> 00:23:07.980
is loaded from the network
when you can't preload

00:23:07.980 --> 00:23:10.940
old possible albums, all
possible movies, and whatever

00:23:10.940 --> 00:23:14.450
you happen to have in your
app from the very beginning?

00:23:14.450 --> 00:23:16.860
You need to think about,
from the design perspective

00:23:16.860 --> 00:23:19.020
and from the implementation
perspective, what

00:23:19.020 --> 00:23:21.517
do you do with those
elements, with that FAB,

00:23:21.517 --> 00:23:23.600
with that progress indicator
where you can already

00:23:23.600 --> 00:23:25.830
play the song, but
you still don't

00:23:25.830 --> 00:23:27.520
have the cover art for it.

00:23:27.520 --> 00:23:30.080
The same goes for
localizations, which

00:23:30.080 --> 00:23:32.730
can go a little bit longer
in German or Swedish.

00:23:32.730 --> 00:23:36.960
Or in scripts such as Korean or
Chinese, a little bit taller.

00:23:36.960 --> 00:23:39.070
So your design needs
to be aware of what

00:23:39.070 --> 00:23:41.500
happens when you're
not running only

00:23:41.500 --> 00:23:46.018
on your particular
screen under English US.

00:23:46.018 --> 00:23:49.210
SHONA DUTTA: So keep in mind
that our designs are often

00:23:49.210 --> 00:23:51.220
pushing at the boundaries
of what devices

00:23:51.220 --> 00:23:53.050
are capable of handling.

00:23:53.050 --> 00:23:55.590
There will always be
technical limitations to what

00:23:55.590 --> 00:23:57.630
can be reasonably implemented.

00:23:57.630 --> 00:24:00.160
Navigating those limitations
is the responsibility

00:24:00.160 --> 00:24:02.770
of both designers and engineers.

00:24:02.770 --> 00:24:04.960
Like I mentioned
before, implementation

00:24:04.960 --> 00:24:06.390
is a conversation.

00:24:06.390 --> 00:24:09.410
And it's important to get
input from the entire team.

00:24:09.410 --> 00:24:12.180
Everyone's working towards
the same goal of creating

00:24:12.180 --> 00:24:13.960
awesome experiences.

00:24:13.960 --> 00:24:17.250
It's when we collaborate
across design and engineering

00:24:17.250 --> 00:24:21.120
that we end up reaching
the most amazing solutions.

00:24:21.120 --> 00:24:22.690
And now we'll hand
it over to John,

00:24:22.690 --> 00:24:25.030
here to talk about
motion design.

00:24:25.030 --> 00:24:28.530
[APPLAUSE]

00:24:33.530 --> 00:24:36.080
JOHN SCHLEMMER: So
thanks Shona, Kirill.

00:24:36.080 --> 00:24:39.620
I'm John, and I'm here to
talk to you about motion.

00:24:39.620 --> 00:24:41.630
So motion implementation
can be pretty

00:24:41.630 --> 00:24:44.290
different than visual
design implementation.

00:24:44.290 --> 00:24:46.762
But it's still a really
important piece of the puzzle.

00:24:46.762 --> 00:24:48.470
So the material design
team just launched

00:24:48.470 --> 00:24:50.250
some brand new
extensive animation

00:24:50.250 --> 00:24:53.096
guidelines that can be
seen at design.google.com.

00:24:53.096 --> 00:24:57.730
And we're definitely raising
the bar in animations this time.

00:24:57.730 --> 00:24:59.367
We have object moving
in curved paths

00:24:59.367 --> 00:25:01.450
instead of in straight
lines, to give the movement

00:25:01.450 --> 00:25:04.070
a little bit of a more
natural feeling, and less

00:25:04.070 --> 00:25:04.950
of robotic feeling.

00:25:07.710 --> 00:25:09.920
We have the width and height
of surfaces transforming

00:25:09.920 --> 00:25:14.850
asymmetrically to kind of
match this curve movement too.

00:25:14.850 --> 00:25:18.120
We have content within these
asymmetrically expanding

00:25:18.120 --> 00:25:21.200
services that follow
these curved paths.

00:25:21.200 --> 00:25:25.000
And the movement of both need to
stay consistent and contained.

00:25:25.000 --> 00:25:28.120
They are definitely right and
wrong ways to animate for sure.

00:25:28.120 --> 00:25:29.450
And that's what these
new animation guidelines

00:25:29.450 --> 00:25:29.991
can help you.

00:25:33.117 --> 00:25:35.490
But that's only half the battle.

00:25:35.490 --> 00:25:38.220
At the end of the day, this
needs to get implemented.

00:25:38.220 --> 00:25:39.730
And all too often,
I see animations

00:25:39.730 --> 00:25:42.110
being pretty different from
what the original design

00:25:42.110 --> 00:25:46.776
and after effects look like and
the final result in the app.

00:25:46.776 --> 00:25:48.650
And this is really
because of the skill level

00:25:48.650 --> 00:25:51.694
of either the designer
or the engineer.

00:25:51.694 --> 00:25:53.110
Sometimes it's
around the designer

00:25:53.110 --> 00:25:54.740
making an animation
in After Effects

00:25:54.740 --> 00:25:57.160
that isn't quite possible
to do on Android or iOS.

00:25:59.900 --> 00:26:01.500
But most of the
time, it's actually

00:26:01.500 --> 00:26:03.900
about how that motion
is communicated or not

00:26:03.900 --> 00:26:06.500
communicated to the engineer.

00:26:06.500 --> 00:26:09.950
A designer can't just hand
over an exported MP4 file

00:26:09.950 --> 00:26:12.400
and wipe your hands clean.

00:26:12.400 --> 00:26:15.080
There are so many subtleties
that go in a proper motion.

00:26:15.080 --> 00:26:16.860
And there's no way
anybody else that

00:26:16.860 --> 00:26:20.250
sees it, designer or engineer,
will be able to quickly pick up

00:26:20.250 --> 00:26:22.076
on all these subtle details.

00:26:22.076 --> 00:26:24.430
It's honestly just not nice
to make an engineer scrub

00:26:24.430 --> 00:26:27.430
through a video frame by frame
to try to point out and guess

00:26:27.430 --> 00:26:30.370
what's going on.

00:26:30.370 --> 00:26:32.330
The communication
absolutely needs

00:26:32.330 --> 00:26:34.280
to continue from
that initial export.

00:26:34.280 --> 00:26:36.800
And proper communication with
that engineer during that,

00:26:36.800 --> 00:26:38.650
and as he or she
is building it is

00:26:38.650 --> 00:26:40.670
required to help move
it forward, and see

00:26:40.670 --> 00:26:45.064
if it's even feasible on the
platform in the first place.

00:26:45.064 --> 00:26:47.480
So let's take a look at this
animation in Google Calendar.

00:26:47.480 --> 00:26:49.521
It's probably the most
seen animation in the app.

00:26:49.521 --> 00:26:51.700
So it's pretty important
we get it right.

00:26:51.700 --> 00:26:54.210
We tap on an event, and
we go into the Event View,

00:26:54.210 --> 00:26:57.020
we go back, and it
collapses again.

00:26:57.020 --> 00:26:58.860
It's pretty simple.

00:26:58.860 --> 00:27:00.960
Just expands and collapses.

00:27:00.960 --> 00:27:02.790
But there's so
many details here.

00:27:02.790 --> 00:27:05.550
So let's take a look at them.

00:27:05.550 --> 00:27:07.700
The width of the hard
actually transforms

00:27:07.700 --> 00:27:10.800
at a slightly offset rate
than the height of the card.

00:27:10.800 --> 00:27:14.330
The content inside of the
card moves in a strategic way

00:27:14.330 --> 00:27:16.150
to give you the illusion
that it lines up

00:27:16.150 --> 00:27:19.367
with that separate Title
field in the Header.

00:27:19.367 --> 00:27:20.950
The image inside of
the collapse event

00:27:20.950 --> 00:27:24.130
is actually a partial
reveal of the new view

00:27:24.130 --> 00:27:26.811
and it lines up with it.

00:27:26.811 --> 00:27:29.380
The exact timing of when
that old content leaves

00:27:29.380 --> 00:27:32.130
the view and the new
content comes into the view

00:27:32.130 --> 00:27:34.700
is also really important
to prevent any flashing

00:27:34.700 --> 00:27:37.650
or disturbances in the loading.

00:27:37.650 --> 00:27:39.280
The Edit FAB is
actually attached

00:27:39.280 --> 00:27:41.410
to the intersection
of the Header image

00:27:41.410 --> 00:27:44.040
and the white content below it.

00:27:44.040 --> 00:27:47.420
And the RSVP card in some
cases slides in from the bottom

00:27:47.420 --> 00:27:49.594
where it's applicable.

00:27:49.594 --> 00:27:51.010
And that's just
opening and event.

00:27:51.010 --> 00:27:53.780
What about closing it?

00:27:53.780 --> 00:27:56.662
It's also not the same
animation reversed.

00:27:56.662 --> 00:27:58.120
And this is a really
common mistake

00:27:58.120 --> 00:28:01.640
I see a lot of designers
and engineers make.

00:28:01.640 --> 00:28:03.262
Simply reversing
this animation is not

00:28:03.262 --> 00:28:05.470
really enough to convey the
subtleties of motion that

00:28:05.470 --> 00:28:07.840
were introduced when
you were expanding it.

00:28:07.840 --> 00:28:09.727
The path maybe a
little different,

00:28:09.727 --> 00:28:11.810
and the time at which the
objects leave the screen

00:28:11.810 --> 00:28:14.316
are different from when
they enter the screen.

00:28:14.316 --> 00:28:16.565
And then you have to think
about which easing curve do

00:28:16.565 --> 00:28:17.959
you use for all this.

00:28:17.959 --> 00:28:19.750
The motion designer
might know these curves

00:28:19.750 --> 00:28:21.870
according to their
software, but it

00:28:21.870 --> 00:28:26.060
might mean completely different
things to the engineer.

00:28:26.060 --> 00:28:27.830
And outgoing easing
value in After Effects

00:28:27.830 --> 00:28:29.780
is actually referred
to an ease in value

00:28:29.780 --> 00:28:31.910
in another software languages.

00:28:31.910 --> 00:28:34.201
Well an incoming easing
value in After Effects

00:28:34.201 --> 00:28:36.450
is actually referred to an
ease out in other languages

00:28:36.450 --> 00:28:37.740
and software.

00:28:37.740 --> 00:28:39.880
So that's already
pretty confusing.

00:28:39.880 --> 00:28:41.880
To make it worse, there's
a right and wrong time

00:28:41.880 --> 00:28:43.510
to use each one of those.

00:28:43.510 --> 00:28:47.410
And mixing those up can have
pretty dramatic effects too.

00:28:47.410 --> 00:28:49.120
There's a lot of
communication in what

00:28:49.120 --> 00:28:52.172
would be a seemingly simple
expand and collapse animation.

00:28:52.172 --> 00:28:54.630
And I really wanted to go over
these details with everybody

00:28:54.630 --> 00:28:57.570
just to show both the designers
and engineers everything

00:28:57.570 --> 00:29:00.130
that goes into it.

00:29:00.130 --> 00:29:01.650
Designers, you
should absolutely be

00:29:01.650 --> 00:29:03.149
considering every
detail when you're

00:29:03.149 --> 00:29:04.692
making a transition like this.

00:29:04.692 --> 00:29:06.900
And I highly recommend
checking out the new animation

00:29:06.900 --> 00:29:10.665
guidelines in the material
and the material resources.

00:29:10.665 --> 00:29:12.540
Engineers, you should
be aware that designers

00:29:12.540 --> 00:29:13.770
are thinking about this.

00:29:13.770 --> 00:29:16.285
There are these little things
that go into animation.

00:29:16.285 --> 00:29:18.660
And you have every right to
be mad at them if all you get

00:29:18.660 --> 00:29:21.225
is an MP4 file emailed to you
with no further explanation.

00:29:24.350 --> 00:29:28.420
So how do we at Google actually
communicate this motion design?

00:29:28.420 --> 00:29:30.357
Every motion designer
has their own tricks.

00:29:30.357 --> 00:29:32.940
But I'd like to go over what I
found to be the most useful way

00:29:32.940 --> 00:29:35.167
to get detailed information
to the engineer.

00:29:35.167 --> 00:29:37.000
Just so they have access
to the right delays

00:29:37.000 --> 00:29:39.425
and easing curves and values
right from the beginning.

00:29:41.909 --> 00:29:43.700
We'll be looking at
this animation in Inbox

00:29:43.700 --> 00:29:44.980
that you see the most.

00:29:44.980 --> 00:29:47.040
Opening an email.

00:29:47.040 --> 00:29:48.790
And here it is slower,
so you can actually

00:29:48.790 --> 00:29:50.002
see what's going on.

00:29:53.700 --> 00:29:56.800
I show this before, but this is
what I have in After Effects.

00:29:56.800 --> 00:29:58.600
It's a pretty complex
timeline with a bunch

00:29:58.600 --> 00:30:01.264
of hidden information
throughout the interface.

00:30:01.264 --> 00:30:02.930
Somebody not familiar
with After Effects

00:30:02.930 --> 00:30:04.870
would probably have no idea
what they're looking at.

00:30:04.870 --> 00:30:06.930
So giving an engineer an
After Effects file probably

00:30:06.930 --> 00:30:08.054
isn't the way to go either.

00:30:10.480 --> 00:30:13.520
What I do, along with a lot of
other motion designers here,

00:30:13.520 --> 00:30:16.904
is I create an animation
graph a little like this one.

00:30:16.904 --> 00:30:19.320
This is the animation graph I
made for the Inbox expanding

00:30:19.320 --> 00:30:22.030
animation that Mark and
I actually worked on.

00:30:22.030 --> 00:30:24.705
Yes, it's still a timeline, but
it's so much more digestible

00:30:24.705 --> 00:30:27.772
in this form.

00:30:27.772 --> 00:30:29.230
Instead of in
frames, it's measured

00:30:29.230 --> 00:30:32.250
in milliseconds, which is
what engineers actually

00:30:32.250 --> 00:30:34.940
need to know.

00:30:34.940 --> 00:30:37.940
Each line on the graph is
actually an animated property

00:30:37.940 --> 00:30:39.620
of an on screen element.

00:30:39.620 --> 00:30:43.800
So opacity, scaling position,
x and y, all of that

00:30:43.800 --> 00:30:46.600
is located next to the
name of the elements that's

00:30:46.600 --> 00:30:48.520
transitioning.

00:30:48.520 --> 00:30:51.720
The x-axis gives you an idea of
when that transition actually

00:30:51.720 --> 00:30:53.795
starts and for how
long it takes place.

00:30:56.850 --> 00:30:58.420
Easing curves are
also noted here.

00:30:58.420 --> 00:31:02.070
So since material design uses
a pretty common set of four

00:31:02.070 --> 00:31:05.600
different easing curves, naming
them here and identifying them

00:31:05.600 --> 00:31:09.110
here can let the engineer
cross reference them

00:31:09.110 --> 00:31:11.812
with the animation guidelines.

00:31:11.812 --> 00:31:13.270
And there it will
actually give you

00:31:13.270 --> 00:31:16.980
the exact interpolator or cubic
Bezier curve for that value.

00:31:20.310 --> 00:31:22.310
It's a little more work
for the designer upfront

00:31:22.310 --> 00:31:24.226
to create something like
this for an engineer,

00:31:24.226 --> 00:31:25.920
but I promise you,
in the end it'll

00:31:25.920 --> 00:31:28.580
take so much less time
than trying to figure out

00:31:28.580 --> 00:31:31.250
where an animation went wrong
and tweaking from an already

00:31:31.250 --> 00:31:33.010
incorrect one.

00:31:33.010 --> 00:31:35.500
So this helps me get animations
implemented with accuracy

00:31:35.500 --> 00:31:36.630
from the very beginning.

00:31:40.012 --> 00:31:42.220
And while handing off a
video with an animation graph

00:31:42.220 --> 00:31:45.900
is way better than just a
video, the communication

00:31:45.900 --> 00:31:48.237
still shouldn't stop.

00:31:48.237 --> 00:31:50.195
A designer might have a
slightly tweaked design

00:31:50.195 --> 00:31:51.300
they need to communicate.

00:31:51.300 --> 00:31:53.000
Or an engineer might
have a roadblock

00:31:53.000 --> 00:31:54.932
that they run into as
they're building it.

00:31:54.932 --> 00:31:57.140
There's always going to be
edge cases to work through

00:31:57.140 --> 00:31:58.139
as Kirill mentioned too.

00:31:58.139 --> 00:32:00.894
There's always going to be them.

00:32:00.894 --> 00:32:02.310
But I won't get
too far into that.

00:32:02.310 --> 00:32:05.240
I want to let Mark Wei talk
about his experiences working

00:32:05.240 --> 00:32:06.740
with designers and
motion designers

00:32:06.740 --> 00:32:08.828
to implement this motion.

00:32:08.828 --> 00:32:12.321
[APPLAUSE]

00:32:14.816 --> 00:32:16.820
MARK WEI: Thanks John.

00:32:16.820 --> 00:32:19.960
I'm Mark, and I'm a software
engineer focused on motion.

00:32:19.960 --> 00:32:22.190
I've worked with John
on the Inbox app,

00:32:22.190 --> 00:32:24.520
and now on material design.

00:32:24.520 --> 00:32:28.340
Friends and engineers often
strive for pixel perfection.

00:32:28.340 --> 00:32:31.730
Motion engineers strive
for frame perfection.

00:32:31.730 --> 00:32:33.920
I'm here to talk to you
today about the pain points

00:32:33.920 --> 00:32:37.440
I've encountered while
trying to achieve this goal.

00:32:37.440 --> 00:32:39.500
As John mentioned,
engineers should not

00:32:39.500 --> 00:32:41.240
be expected to implement
motion from only

00:32:41.240 --> 00:32:43.130
in After Effects video.

00:32:43.130 --> 00:32:46.020
I've often found myself
scrubbing through video frame

00:32:46.020 --> 00:32:49.420
by frame, trying to pry
apart complex motion.

00:32:49.420 --> 00:32:52.730
Even worse, sometimes
there isn't even a video.

00:32:52.730 --> 00:32:55.720
And I'm asked to implement
something on Android by seeing

00:32:55.720 --> 00:32:57.025
how it was done on iOS.

00:32:59.550 --> 00:33:01.910
Have you ever try to
figure out-- thank you.

00:33:01.910 --> 00:33:02.530
Thank you.

00:33:02.530 --> 00:33:06.450
[APPLAUSE]

00:33:06.450 --> 00:33:09.070
Have you ever try to
figure out an easing curves

00:33:09.070 --> 00:33:10.490
by inspecting the frames?

00:33:10.490 --> 00:33:13.150
It's not a very
good use of time.

00:33:13.150 --> 00:33:16.290
But fundamentally, a
video only shows a slice

00:33:16.290 --> 00:33:18.910
of the motion spec for
a very specific set

00:33:18.910 --> 00:33:20.560
of initial conditions.

00:33:20.560 --> 00:33:23.870
Engineers are always interested
in a more general case.

00:33:23.870 --> 00:33:26.540
So a richer motion
spec is necessary.

00:33:26.540 --> 00:33:29.040
This is where the animation
graph comes into play.

00:33:29.040 --> 00:33:32.680
But sometimes even the best
motion designers and engineers

00:33:32.680 --> 00:33:34.870
don't speak the same language.

00:33:34.870 --> 00:33:36.840
Here are some caveats
to look out for.

00:33:36.840 --> 00:33:39.520
And keep in mind, these
are all actual examples

00:33:39.520 --> 00:33:44.280
that I found in apps both
inside and outside Google.

00:33:44.280 --> 00:33:46.910
Let's take a look at
this expanding card.

00:33:46.910 --> 00:33:50.970
The animation graph might have
a component for width expansion

00:33:50.970 --> 00:33:55.460
and height expansion, but how
exactly does a card expand?

00:33:55.460 --> 00:33:58.990
Should you scale it
or should you mask it?

00:33:58.990 --> 00:34:02.460
The end results are
completely different.

00:34:02.460 --> 00:34:06.230
Try to use specific
language like scale and mask

00:34:06.230 --> 00:34:07.840
in your motion spec.

00:34:07.840 --> 00:34:09.835
Avoid generic terms like expand.

00:34:12.440 --> 00:34:15.610
Things get complicated when
rounded corners are involved.

00:34:15.610 --> 00:34:18.880
For material design, you may
not want to actually animate

00:34:18.880 --> 00:34:21.130
the radius of a rounded corner.

00:34:21.130 --> 00:34:24.859
Instead, think about breaking
it down into overlapping masks.

00:34:27.840 --> 00:34:30.770
It helps to include a
wireframe video showing

00:34:30.770 --> 00:34:33.120
the masks in your motion spec.

00:34:33.120 --> 00:34:35.654
This is especially true
for more complex motion

00:34:35.654 --> 00:34:36.695
with multiple components.

00:34:39.230 --> 00:34:41.760
Text scaling is really
hard to get right.

00:34:41.760 --> 00:34:43.400
Keep in mind that
an engineer may

00:34:43.400 --> 00:34:45.520
be constrained by her platform.

00:34:45.520 --> 00:34:49.230
For example, when you change
the font size of an Android Text

00:34:49.230 --> 00:34:52.989
View, you causes not only
an invalidation of that view

00:34:52.989 --> 00:34:54.989
but also a re-layout.

00:34:54.989 --> 00:34:57.410
This may cause
performance issues.

00:34:57.410 --> 00:35:00.480
A common workaround is to
just scale the entire view,

00:35:00.480 --> 00:35:04.420
or you could draw the text
manually onto the canvas.

00:35:04.420 --> 00:35:07.300
The collapsing toolbar in
the Android Design Library

00:35:07.300 --> 00:35:10.990
as shown, is a good example
of manually drawing the text

00:35:10.990 --> 00:35:14.330
to allow its font size
to change smoothly.

00:35:14.330 --> 00:35:17.270
As engineers know, it's
the edge cases that

00:35:17.270 --> 00:35:18.770
are the hardest to deal with.

00:35:18.770 --> 00:35:21.310
What if the text
reflows the multi-line?

00:35:21.310 --> 00:35:25.410
What if the style changes
to italics or bold?

00:35:25.410 --> 00:35:28.870
Include text scaling
behavior in your motion spec.

00:35:28.870 --> 00:35:31.740
Keep edge cases in mind
and know that many times

00:35:31.740 --> 00:35:33.195
a simple crossfade
is acceptable.

00:35:35.870 --> 00:35:37.760
And on the topic of
performance, it's

00:35:37.760 --> 00:35:40.910
something the designer
should also be aware of.

00:35:40.910 --> 00:35:44.010
On many platforms, animating
the alpha of the layer

00:35:44.010 --> 00:35:45.910
is actually quite expensive.

00:35:45.910 --> 00:35:48.690
For example, on Android,
you must be careful

00:35:48.690 --> 00:35:51.230
when animating the
alpha of a container

00:35:51.230 --> 00:35:53.780
like the toolbar in this video.

00:35:53.780 --> 00:35:57.140
Since its contents are being
translated independently,

00:35:57.140 --> 00:35:59.950
they must be redrawn
on every frame.

00:35:59.950 --> 00:36:02.260
This becomes a problem when
the container's alpha is

00:36:02.260 --> 00:36:06.280
being animated, and may again
result in performance issues.

00:36:06.280 --> 00:36:08.430
In this case, the
engineer may choose

00:36:08.430 --> 00:36:11.860
to apply the alpha to each
individual icon rather

00:36:11.860 --> 00:36:14.700
than the entire container.

00:36:14.700 --> 00:36:17.210
If the designer is aware
of these limitations,

00:36:17.210 --> 00:36:19.480
the motion spec can be
designed around them.

00:36:22.770 --> 00:36:24.700
Motion specs are
usually concerned

00:36:24.700 --> 00:36:29.030
with going from state A to state
B, taking a certain duration.

00:36:29.030 --> 00:36:33.170
But in the real world, user
behavior is not so clear cut.

00:36:33.170 --> 00:36:35.580
They may want to cancel
out during an animation,

00:36:35.580 --> 00:36:38.830
or tap on an item that's
still coming into view.

00:36:38.830 --> 00:36:40.750
And there's nothing
a user hates more

00:36:40.750 --> 00:36:43.030
than having to wait for
transition to finish

00:36:43.030 --> 00:36:45.090
before continuing to
interact with a UI.

00:36:47.642 --> 00:36:49.350
It's usually been left
up to the engineer

00:36:49.350 --> 00:36:52.670
to decide whether animations
can be interrupted.

00:36:52.670 --> 00:36:54.850
Going down the easy
path often means

00:36:54.850 --> 00:36:57.560
that UI elements become
frozen while an animation is

00:36:57.560 --> 00:36:58.870
in progress.

00:36:58.870 --> 00:37:02.530
Instead, consider clearly
defining in your motion spec

00:37:02.530 --> 00:37:03.850
the behavior of interruptions.

00:37:07.200 --> 00:37:09.770
I'll leave you with
a personal anecdote.

00:37:09.770 --> 00:37:11.790
I recently implemented
the transition

00:37:11.790 --> 00:37:14.760
from a floating action
button to a sheet.

00:37:14.760 --> 00:37:17.920
What you're seeing is a sheet
with the circular mask applied

00:37:17.920 --> 00:37:21.270
to it to look like the FAB.

00:37:21.270 --> 00:37:24.440
The sheet starts partially
offscreen and translates

00:37:24.440 --> 00:37:28.070
vertically until
it's fully on screen.

00:37:28.070 --> 00:37:30.150
At the same time,
the circular mask

00:37:30.150 --> 00:37:34.060
expands from the
size of the FAB.

00:37:34.060 --> 00:37:37.130
The interesting thing is at the
end value of the circular mask

00:37:37.130 --> 00:37:40.470
expansion is defined
as fully covering

00:37:40.470 --> 00:37:43.260
the visible area of the sheet.

00:37:43.260 --> 00:37:45.730
Now some of you may have
realized that this is actually

00:37:45.730 --> 00:37:47.260
a moving target.

00:37:47.260 --> 00:37:51.280
As the sheet translates,
the visible area grows.

00:37:51.280 --> 00:37:55.520
So first I calculate at this
exact time how much of the card

00:37:55.520 --> 00:37:57.240
will be visible.

00:37:57.240 --> 00:37:59.340
And then I use that
to determine the n

00:37:59.340 --> 00:38:03.280
value that the circular
mask expansion should be.

00:38:03.280 --> 00:38:07.030
This seems to work, but actually
there's something wrong.

00:38:07.030 --> 00:38:09.520
Now you'll notice that
everything in the video

00:38:09.520 --> 00:38:11.470
actually looks fine.

00:38:11.470 --> 00:38:13.850
Unlike working
with static UI, you

00:38:13.850 --> 00:38:16.410
might not find any
obvious visual glitches

00:38:16.410 --> 00:38:18.260
when motion goes wrong.

00:38:18.260 --> 00:38:20.870
But when I slow
down my animation,

00:38:20.870 --> 00:38:24.660
I realize that the sheet was
fully revealed 25 milliseconds

00:38:24.660 --> 00:38:27.900
before it was intended to.

00:38:27.900 --> 00:38:31.830
The red highlight you see marks
the beginning of that moment.

00:38:31.830 --> 00:38:35.550
Now 25 milliseconds may
not sound like much,

00:38:35.550 --> 00:38:38.390
but that means that instead of
a circular expansion happening

00:38:38.390 --> 00:38:42.900
over six frames, it now happens
over a much more quicker pace,

00:38:42.900 --> 00:38:44.710
four frames.

00:38:44.710 --> 00:38:49.700
When played back at full speed,
it felt ever so slightly off.

00:38:49.700 --> 00:38:51.600
So I triple check
all my numbers,

00:38:51.600 --> 00:38:53.360
but everything looked fine.

00:38:53.360 --> 00:38:55.650
While I was struggling
to find an explanation,

00:38:55.650 --> 00:38:58.270
I hit a sudden inspiration,
and I scribbled this graph down

00:38:58.270 --> 00:39:00.280
in my notebook.

00:39:00.280 --> 00:39:03.110
The longer line describes
how the vertical translation

00:39:03.110 --> 00:39:06.960
of the sheet shows
more area over time.

00:39:06.960 --> 00:39:10.400
The shorter line describes how
the circular mask expansion

00:39:10.400 --> 00:39:13.060
covers more area over time.

00:39:13.060 --> 00:39:15.140
The curvature of
the two lines are

00:39:15.140 --> 00:39:19.570
caused by the standard
easing curve applied to both.

00:39:19.570 --> 00:39:22.160
The last intersection
between these two lines

00:39:22.160 --> 00:39:25.030
show where we want the
two areas to coincide,

00:39:25.030 --> 00:39:27.230
satisfying the motion spec.

00:39:27.230 --> 00:39:28.610
But we can clearly
see that there

00:39:28.610 --> 00:39:30.770
was an unintended intersection.

00:39:30.770 --> 00:39:34.730
That represents an earlier time
when the circular mask already

00:39:34.730 --> 00:39:38.520
covers the entire card, which
the user perceives as a shorter

00:39:38.520 --> 00:39:40.830
duration.

00:39:40.830 --> 00:39:43.760
My motion designer did not
encountered this issue in

00:39:43.760 --> 00:39:47.370
After Effects, but I did
in my implementation.

00:39:47.370 --> 00:39:48.840
Why is that?

00:39:48.840 --> 00:39:50.890
It's because there
exists a certain set

00:39:50.890 --> 00:39:52.400
of initial conditions.

00:39:52.400 --> 00:39:53.710
The size of the sheet.

00:39:53.710 --> 00:39:55.110
The size of the FAB.

00:39:55.110 --> 00:39:56.840
The distance between
them and the edges

00:39:56.840 --> 00:40:02.050
of the screen that resulted
in this particular situation.

00:40:02.050 --> 00:40:05.100
In the end, I communicated
this to my motion designer,

00:40:05.100 --> 00:40:06.700
and we decided to
change the easing

00:40:06.700 --> 00:40:10.400
curve of the circular
mask to avoid this.

00:40:10.400 --> 00:40:13.040
Is this guaranteed to
work for the entire set

00:40:13.040 --> 00:40:15.080
of possible initial conditions?

00:40:15.080 --> 00:40:17.460
It's hard to say.

00:40:17.460 --> 00:40:18.960
Whenever you have
animations that

00:40:18.960 --> 00:40:21.550
are defined to be
dependent on one another,

00:40:21.550 --> 00:40:23.680
you may run into
problems like this.

00:40:23.680 --> 00:40:27.510
And they will be difficult to
notice and difficult to fix.

00:40:27.510 --> 00:40:28.410
Great.

00:40:28.410 --> 00:40:31.220
I was able to resolve this
issue with a simple easing curve

00:40:31.220 --> 00:40:32.100
change.

00:40:32.100 --> 00:40:34.410
But this just shows the
importance of communication

00:40:34.410 --> 00:40:37.330
between designer and developer.

00:40:37.330 --> 00:40:39.770
Some motion specs are ambiguous.

00:40:39.770 --> 00:40:43.010
Others are difficult due
to platform limitations.

00:40:43.010 --> 00:40:46.920
But a few are just plain
impossible because of reality.

00:40:46.920 --> 00:40:48.650
Having an open
communication will

00:40:48.650 --> 00:40:51.270
ensure that your intent
behind the motion spec

00:40:51.270 --> 00:40:53.410
is properly implemented.

00:40:53.410 --> 00:40:56.480
And if you keep these caveats
in mind, you and your engineer

00:40:56.480 --> 00:40:58.100
can start to speak
the same language.

00:41:01.467 --> 00:41:04.353
[APPLAUSE]

00:41:09.780 --> 00:41:11.817
SHONA DUTTA: So that
wraps up our session.

00:41:11.817 --> 00:41:13.400
If you're interested
in learning more,

00:41:13.400 --> 00:41:15.580
please check out some of
the links on the slide

00:41:15.580 --> 00:41:18.930
or join us online for
continuing the conversation.

00:41:18.930 --> 00:41:20.398
Thank you so much for attending.

00:41:20.398 --> 00:41:24.994
[APPLAUSE]

