WEBVTT
Kind: captions
Language: en

00:00:08.550 --> 00:00:10.600
RETO MEIER: Hello, and welcome
to the App Clinic.

00:00:10.600 --> 00:00:13.160
My name is Reto Meier, and I'm
the tech lead on the Android

00:00:13.160 --> 00:00:14.680
Developer Relations team.

00:00:14.680 --> 00:00:17.350
And today I'll be designing the
ultimate Cricket tracking

00:00:17.350 --> 00:00:19.000
app for Android.

00:00:19.000 --> 00:00:21.110
If you're wondering why I'm
not joined by my usual

00:00:21.110 --> 00:00:24.100
co-host, Ian Ni-Lewis, well,
despite 4 hours of

00:00:24.100 --> 00:00:27.650
excruciating training, Ian still
can't reliably determine

00:00:27.650 --> 00:00:29.970
an LBW decision without
referencing both

00:00:29.970 --> 00:00:31.400
Hot Spot and Hawkeye.

00:00:31.400 --> 00:00:34.180
And even then, half the time,
he'll forget to check the

00:00:34.180 --> 00:00:36.120
pitched outside leg.

00:00:36.120 --> 00:00:38.800
So rather than subject came to
the written examination on the

00:00:38.800 --> 00:00:41.840
Duckworth-Lewis method, I've
decided to host today's App

00:00:41.840 --> 00:00:43.950
Clinic solo.

00:00:43.950 --> 00:00:46.560
Now, I'm the sort of person
who considers Pictionary a

00:00:46.560 --> 00:00:49.080
torture roughly in line
with water boarding.

00:00:49.080 --> 00:00:52.510
So the focus of my design will
center on architecture.

00:00:52.510 --> 00:00:54.845
I'll be using apps that let you
follow cricket scores to

00:00:54.845 --> 00:00:56.270
provide some context.

00:00:56.270 --> 00:00:58.600
But the same techniques and
approaches will work just as

00:00:58.600 --> 00:01:01.840
well for a range of apps,
particularly other sports like

00:01:01.840 --> 00:01:04.239
baseball or any code of
football, whether that's

00:01:04.239 --> 00:01:06.960
throwing, kicking, catching
a round or any

00:01:06.960 --> 00:01:08.950
other shaped ball.

00:01:08.950 --> 00:01:12.390
Now fair warning, I took many
of these screen shots during

00:01:12.390 --> 00:01:15.350
day two and three of the second
Ashes test, so any

00:01:15.350 --> 00:01:19.250
members of the Australian test
squad suffering from PTSD

00:01:19.250 --> 00:01:21.530
should look away.

00:01:21.530 --> 00:01:24.360
As engineers, it can be tempting
to start designing

00:01:24.360 --> 00:01:28.240
our apps in terms of the data
we have access to, then

00:01:28.240 --> 00:01:30.380
considering how to display
that data.

00:01:30.380 --> 00:01:32.360
Instead of building the ultimate
hammer and then

00:01:32.360 --> 00:01:35.710
packaging it in a shiny box,
invest some time examining the

00:01:35.710 --> 00:01:38.890
problem as a user without
considering how you'd go about

00:01:38.890 --> 00:01:40.220
solving it.

00:01:40.220 --> 00:01:42.800
So let's take a look at the
problems the existing apps

00:01:42.800 --> 00:01:44.220
already solve.

00:01:44.220 --> 00:01:46.930
Cricinfo is celebrating its 20th
anniversary this year,

00:01:46.930 --> 00:01:49.150
and they've always been
my go-to site for

00:01:49.150 --> 00:01:51.250
following the cricket.

00:01:51.250 --> 00:01:54.030
What I really like about their
mobile app is that the info

00:01:54.030 --> 00:01:55.900
you're most likely to want--

00:01:55.900 --> 00:01:57.170
live match scores--

00:01:57.170 --> 00:01:58.860
is front and center.

00:01:58.860 --> 00:02:01.710
Swiping left and right allows
you to move between all

00:02:01.710 --> 00:02:03.880
different currently-live
matches.

00:02:03.880 --> 00:02:06.760
Beyond that, everything else--
fixtures, news, video, et

00:02:06.760 --> 00:02:09.259
cetera-- are all within
easy reach directly

00:02:09.259 --> 00:02:11.720
from the front page.

00:02:11.720 --> 00:02:14.460
Cricbuzz takes a similar
approach to live scores, but

00:02:14.460 --> 00:02:17.020
has limited the front page
to a list view of

00:02:17.020 --> 00:02:19.620
current news articles.

00:02:19.620 --> 00:02:22.440
The other content is still
available, but they've moved

00:02:22.440 --> 00:02:25.990
off the main UI and into this
navigation spinner.

00:02:25.990 --> 00:02:28.900
Now, I actually prefer this
approach in general, as it

00:02:28.900 --> 00:02:32.540
makes the app landing page
a little less cluttered.

00:02:32.540 --> 00:02:35.230
So in terms of solving problems,
we can see that both

00:02:35.230 --> 00:02:38.500
apps are providing live scores,
upcoming fixtures,

00:02:38.500 --> 00:02:42.310
cricket news, photo galleries,
and access to the rich world

00:02:42.310 --> 00:02:43.870
of cricket statistics.

00:02:43.870 --> 00:02:46.000
In terms of priorities,
the focus of both

00:02:46.000 --> 00:02:47.490
apps is live scores.

00:02:47.490 --> 00:02:50.960
So let's dive in here
a little deeper.

00:02:50.960 --> 00:02:53.480
When you select a live match in
Cricinfo, you're shown the

00:02:53.480 --> 00:02:55.960
standard score summary.

00:02:55.960 --> 00:02:59.720
It shows the current inning
score, the batsman, bowler,

00:02:59.720 --> 00:03:01.790
and even the last few balls
from the current

00:03:01.790 --> 00:03:03.020
and previous innings.

00:03:03.020 --> 00:03:06.320
Below all of that, we
have our commentary.

00:03:06.320 --> 00:03:08.460
Now, like the landing page,
everything is available by

00:03:08.460 --> 00:03:10.650
interacting directly
with the UI.

00:03:10.650 --> 00:03:14.700
You can swipe or click these
icons to move between the

00:03:14.700 --> 00:03:18.450
summary score, full score,
commentary and news views.

00:03:18.450 --> 00:03:20.410
Clicking on a particular player
will take at their

00:03:20.410 --> 00:03:21.890
stats page.

00:03:21.890 --> 00:03:24.000
This is really the heart of the
app, and they've done a

00:03:24.000 --> 00:03:28.810
great job of fitting a lot of
information into a small area.

00:03:28.810 --> 00:03:32.040
Cricbuzz has a very similar
matched score display, but its

00:03:32.040 --> 00:03:36.440
moved the navigation into
the overflow menu.

00:03:36.440 --> 00:03:37.740
They've also incorporated
a couple

00:03:37.740 --> 00:03:39.000
of really cool features.

00:03:39.000 --> 00:03:42.550
Specifically, they've got score
tracking and live audio

00:03:42.550 --> 00:03:42.985
commentary.

00:03:42.985 --> 00:03:45.690
Now, I actually think audio
commentary is a big enough

00:03:45.690 --> 00:03:48.100
feature that it deserves
promotion right

00:03:48.100 --> 00:03:49.680
to the action bar.

00:03:49.680 --> 00:03:51.980
Now, note that both
of these apps have

00:03:51.980 --> 00:03:54.320
used a refresh button.

00:03:54.320 --> 00:03:56.620
Now, a big part of my
architectural redesign is

00:03:56.620 --> 00:03:59.590
going to talk about how to
eliminate the refresh button

00:03:59.590 --> 00:04:01.610
from apps like this.

00:04:01.610 --> 00:04:03.700
Things like every refresh button
are a great example of

00:04:03.700 --> 00:04:07.230
how implementation can sometimes
drive visual design.

00:04:07.230 --> 00:04:10.540
As engineers, we need a way to
call the method that initiates

00:04:10.540 --> 00:04:11.700
the downloads.

00:04:11.700 --> 00:04:14.300
And then you add a visual
control who's event handler

00:04:14.300 --> 00:04:16.209
will trigger that
method, right?

00:04:16.209 --> 00:04:18.200
Well, no.

00:04:18.200 --> 00:04:21.060
If you start with your idealized
visual design, you

00:04:21.060 --> 00:04:22.540
wouldn't include a
refresh button.

00:04:22.540 --> 00:04:25.680
You'd just make sure that the
scores were always up-to-date.

00:04:25.680 --> 00:04:28.270
Much like a save button,
why would I ever not

00:04:28.270 --> 00:04:29.875
want to save my work?

00:04:29.875 --> 00:04:32.420
Now, just because you have a
save method doesn't mean you

00:04:32.420 --> 00:04:35.170
need to have a save
control on screen.

00:04:35.170 --> 00:04:37.960
And it's the same thing
with refresh.

00:04:37.960 --> 00:04:40.706
Now I never start a project
without sketching out my UI.

00:04:40.706 --> 00:04:43.820
And I can't draw for
sh-- love or money.

00:04:43.820 --> 00:04:46.980
But this is really an important
place to start.

00:04:46.980 --> 00:04:49.450
By defining the user experience
early, you add

00:04:49.450 --> 00:04:52.910
useful constraints around what
your app needs to do and how

00:04:52.910 --> 00:04:54.180
it needs to do it.

00:04:54.180 --> 00:04:57.350
That clarity is what lets you
build something that's

00:04:57.350 --> 00:05:00.070
targeted to solving real
problems, rather than a

00:05:00.070 --> 00:05:03.820
collection of features you
built because you could.

00:05:03.820 --> 00:05:06.430
Now I took those raw sketches
and used the design guidelines

00:05:06.430 --> 00:05:09.800
to try and put together some
mocks that sort of had that

00:05:09.800 --> 00:05:12.940
simple and consistent feel
in line with the

00:05:12.940 --> 00:05:14.640
Android visual language.

00:05:14.640 --> 00:05:16.980
In addition to the two apps that
we just looked at, I also

00:05:16.980 --> 00:05:20.310
took some inspiration from the
ABCs cricket site, which is a

00:05:20.310 --> 00:05:23.310
really clean design without
being too spartan.

00:05:23.310 --> 00:05:26.280
So I've really tried to sort of
merge those philosophies.

00:05:26.280 --> 00:05:28.960
Now, I'm clearly no designer,
but for today's app clinic,

00:05:28.960 --> 00:05:31.790
I've at least taken my pencil
sketches and turned them into

00:05:31.790 --> 00:05:33.700
some primitive mocks
for us to look at.

00:05:33.700 --> 00:05:36.780
For the real deal, the Android
design and action team are

00:05:36.780 --> 00:05:38.810
going to transform them
into real mocks

00:05:38.810 --> 00:05:41.650
for next week's show.

00:05:41.650 --> 00:05:43.190
So this is the first
of the mocks.

00:05:43.190 --> 00:05:45.760
I think it's important to
remember that a lot of

00:05:45.760 --> 00:05:48.780
developers can get lost in the
weeds of potential, of what

00:05:48.780 --> 00:05:50.640
their app could do.

00:05:50.640 --> 00:05:53.860
So we get so caught up in what
we think we might be able to

00:05:53.860 --> 00:05:56.610
build in the long term that we
lose sight of why we built the

00:05:56.610 --> 00:05:58.240
app in the first place.

00:05:58.240 --> 00:06:01.090
So my guiding principle for
software design, both visual

00:06:01.090 --> 00:06:04.080
and architectural, is to focus
on the simplest way of

00:06:04.080 --> 00:06:07.020
providing the most important
information.

00:06:07.020 --> 00:06:09.410
And I do that by asking
why has someone

00:06:09.410 --> 00:06:10.960
downloaded this app?

00:06:10.960 --> 00:06:13.230
And the easiest way of answering
that question is to

00:06:13.230 --> 00:06:14.090
ask it yourself.

00:06:14.090 --> 00:06:16.860
Why would I downloaded
this app?

00:06:16.860 --> 00:06:20.020
Now for me, it was to track the
scores of the Ashes test.

00:06:20.020 --> 00:06:22.870
So, like Cricinfo and Cricbuzz,
when you open the

00:06:22.870 --> 00:06:26.040
app, you get the live scores
for all of the ongoing

00:06:26.040 --> 00:06:27.210
matches, front and center.

00:06:27.210 --> 00:06:30.290
And you can swipe to transition
between them.

00:06:30.290 --> 00:06:33.480
For the remaining space, I was
tossing up between displaying

00:06:33.480 --> 00:06:37.600
either just all kinds of news
or upcoming fixtures.

00:06:37.600 --> 00:06:40.310
And to make a choice, I tried to
imagine the user experience

00:06:40.310 --> 00:06:43.860
based on someone's intention
when opening app for the first

00:06:43.860 --> 00:06:45.500
time when downloading.

00:06:45.500 --> 00:06:47.900
Or even once it's installed,
every time that

00:06:47.900 --> 00:06:49.810
they open the app.

00:06:49.810 --> 00:06:52.100
Now if you're checking for an
upcoming match, that takes

00:06:52.100 --> 00:06:54.800
exactly however long it takes
for you to find the match that

00:06:54.800 --> 00:06:56.470
you're trying to look for.

00:06:56.470 --> 00:06:59.310
That's a fixed time cost that's
entirely dependent on

00:06:59.310 --> 00:07:02.510
my implementation on how long
it takes for you to get to

00:07:02.510 --> 00:07:05.720
that point within the app.

00:07:05.720 --> 00:07:08.370
Now if you open they app to read
cricket news, the time

00:07:08.370 --> 00:07:09.390
cost is variable.

00:07:09.390 --> 00:07:12.420
And it's dependent on how much
time the user wants to spend

00:07:12.420 --> 00:07:13.920
reading the news.

00:07:13.920 --> 00:07:16.750
So the time taken to navigate
to news is really only an

00:07:16.750 --> 00:07:20.080
incremental additional time cost
on top of the time that

00:07:20.080 --> 00:07:23.400
they were already planning
to spend reading.

00:07:23.400 --> 00:07:26.900
So by displaying fixtures, we're
removing time from a

00:07:26.900 --> 00:07:30.760
critical path of one of those
user interactions.

00:07:30.760 --> 00:07:33.550
Now, for navigation to other
features, I've actually gone

00:07:33.550 --> 00:07:35.340
with a sliding drawer.

00:07:35.340 --> 00:07:38.000
Mainly because it's the new
hotness, but also because I

00:07:38.000 --> 00:07:40.750
think it's a really elegant
solution to navigating around

00:07:40.750 --> 00:07:42.900
a lot of heterogeneous
content.

00:07:42.900 --> 00:07:44.990
Now this is the case for an app
like this, where you have

00:07:44.990 --> 00:07:47.530
a lot of different features
which could theoretically each

00:07:47.530 --> 00:07:48.800
be separate apps.

00:07:48.800 --> 00:07:51.340
But they've been bundled
together for convenience or

00:07:51.340 --> 00:07:53.740
because they're thematically
similar.

00:07:53.740 --> 00:07:55.970
So a navigation drawer, a
sliding drawer, is a really

00:07:55.970 --> 00:07:58.220
neat way of being able
to have that sort of

00:07:58.220 --> 00:08:00.640
meta layer on top.

00:08:00.640 --> 00:08:02.880
Now really, all of this is
window dressing for the real

00:08:02.880 --> 00:08:05.460
money, the live match display.

00:08:05.460 --> 00:08:07.860
Now, following the same
principles of focus, I've

00:08:07.860 --> 00:08:10.580
tried to keep the match activity
as simple as I can.

00:08:10.580 --> 00:08:13.240
You land on this score summary,
where I've used

00:08:13.240 --> 00:08:16.010
country flags to add a little
bit of visceral reaction,

00:08:16.010 --> 00:08:17.870
something that only a
national flag seems

00:08:17.870 --> 00:08:19.590
to be able to invoke.

00:08:19.590 --> 00:08:21.810
Now, the commentary is
immediately below.

00:08:21.810 --> 00:08:23.730
And the whole thing is
just a vertical--

00:08:23.730 --> 00:08:26.040
vertically scrolling
list view.

00:08:26.040 --> 00:08:28.250
Now, you can do swiping
horizontally, and that will

00:08:28.250 --> 00:08:31.600
switch between the summary view,
the full score view, or

00:08:31.600 --> 00:08:33.630
related news based
on that match.

00:08:33.630 --> 00:08:36.620
So we've got a two-dimensional
scroll, which will let you do

00:08:36.620 --> 00:08:38.950
the change the content that
you're displaying or the

00:08:38.950 --> 00:08:42.809
content within that view.

00:08:42.809 --> 00:08:45.120
Same as the other two apps we
looked at, clicking on a

00:08:45.120 --> 00:08:47.090
particular player will take you
to their stats page and

00:08:47.090 --> 00:08:49.800
clicking on a country will take
you a country page, which

00:08:49.800 --> 00:08:51.585
is going to include stats,
recent results,

00:08:51.585 --> 00:08:54.850
and upcoming fixtures.

00:08:54.850 --> 00:08:58.680
Now, any sport that includes
five-match series that last

00:08:58.680 --> 00:09:02.150
five days each is going to
produce a lot of statistics.

00:09:02.150 --> 00:09:05.300
And any sport that includes an
afternoon tea break is going

00:09:05.300 --> 00:09:07.450
to give you a lot of
opportunities to delve into

00:09:07.450 --> 00:09:08.890
those stats.

00:09:08.890 --> 00:09:11.970
Now, in this tablet mock up,
I've tried to give an idea of

00:09:11.970 --> 00:09:14.040
the sort of space you've
got available when

00:09:14.040 --> 00:09:16.440
optimizing for tablets.

00:09:16.440 --> 00:09:18.120
Now, to me, it seems obvious
that you're going to want to

00:09:18.120 --> 00:09:20.770
drop a summary and other list
views over here on the

00:09:20.770 --> 00:09:22.020
left-hand side.

00:09:22.020 --> 00:09:25.530
And then you've got almost 2/3
of the remaining display space

00:09:25.530 --> 00:09:28.750
as prime real estate to do
things like commentary, player

00:09:28.750 --> 00:09:31.980
stats, not to mention even more
detailed things, like

00:09:31.980 --> 00:09:35.300
match statistics, player versus
player breakdowns, a

00:09:35.300 --> 00:09:38.280
multitude of graphs, and of
course, even the possibility

00:09:38.280 --> 00:09:42.010
of adding things like Hawkeye
directly within the tablet

00:09:42.010 --> 00:09:43.860
experience.

00:09:43.860 --> 00:09:46.560
Now, the mobile phone app is an
ideal way to keep track of

00:09:46.560 --> 00:09:50.330
a series or a match, but done
the right way, a tablet app

00:09:50.330 --> 00:09:53.050
actually introduces the
opportunity to deliver a true

00:09:53.050 --> 00:09:56.370
cricket companion that gives
you an immersive experience

00:09:56.370 --> 00:09:59.430
that's richer and more easily
accessible than the

00:09:59.430 --> 00:10:02.170
information already
available web.

00:10:02.170 --> 00:10:04.400
And we already know that
users spend more

00:10:04.400 --> 00:10:06.330
time in apps on tablets.

00:10:06.330 --> 00:10:08.560
So creating a rich tablet
experience is a great

00:10:08.560 --> 00:10:13.190
opportunity to drive that
deeper user engagement.

00:10:13.190 --> 00:10:16.277
Now the last feature I want to
talk about from my visual mock

00:10:16.277 --> 00:10:19.230
ups is starring a match.

00:10:19.230 --> 00:10:21.290
Now, starring is a pretty
well-understood metaphor in

00:10:21.290 --> 00:10:24.010
Android that's generally
associated with bookmarking

00:10:24.010 --> 00:10:26.840
something or marking something
as important.

00:10:26.840 --> 00:10:29.230
Now, within my app, I'm going
to take it as an explicit

00:10:29.230 --> 00:10:32.250
signal that the user is
interested in this match.

00:10:32.250 --> 00:10:35.140
And as an implicit signal that
she might be interested in one

00:10:35.140 --> 00:10:37.860
of more of the teams or even
the location with match is

00:10:37.860 --> 00:10:39.500
being played.

00:10:39.500 --> 00:10:40.990
Now, we can use this
information

00:10:40.990 --> 00:10:42.530
in a number of ways.

00:10:42.530 --> 00:10:45.475
First, by adding a shortcut to
starred matches directly from

00:10:45.475 --> 00:10:48.930
our navigation drawer, but
also as a way of enabling

00:10:48.930 --> 00:10:51.740
notifications for
match events.

00:10:51.740 --> 00:10:54.220
Now, by default, I'm going to
trigger a notification for

00:10:54.220 --> 00:10:57.080
every heart-breaking wicket,
every change of innings, and

00:10:57.080 --> 00:11:00.020
every merciful stumps
for every match

00:11:00.020 --> 00:11:01.640
that has been starred.

00:11:01.640 --> 00:11:04.130
And I will include a flag within
the settings menu to

00:11:04.130 --> 00:11:08.400
let users de-select any of those
particular match events.

00:11:08.400 --> 00:11:11.310
Now, the notification itself
should show everything related

00:11:11.310 --> 00:11:15.090
to that event, so the inning
score, the wicket details, and

00:11:15.090 --> 00:11:17.290
when you expand the
notification, the commentary

00:11:17.290 --> 00:11:18.310
associated.

00:11:18.310 --> 00:11:21.980
Ideally, you shouldn't have to
click on the notification to

00:11:21.980 --> 00:11:25.070
enter the app to be able to
understand the full context

00:11:25.070 --> 00:11:27.260
around the event that
has triggered it.

00:11:27.260 --> 00:11:29.370
There's a range of actions that
you can associate with

00:11:29.370 --> 00:11:32.490
each notification, anything from
links to the video clip

00:11:32.490 --> 00:11:35.390
to sharing the data or even an
option to cancel further

00:11:35.390 --> 00:11:37.730
notifications for the remainder
of the game when it

00:11:37.730 --> 00:11:40.830
all just becomes
too depressing.

00:11:40.830 --> 00:11:44.020
Now, the real trick is making
sure that these notifications

00:11:44.020 --> 00:11:46.220
are timely but don't
drain the battery.

00:11:46.220 --> 00:11:49.510
And that's really the
underlining philosophy of my

00:11:49.510 --> 00:11:51.350
entire design.

00:11:51.350 --> 00:11:54.550
Moving beyond the visual design,
we need to create an

00:11:54.550 --> 00:11:56.700
information architecture
that will let us bring

00:11:56.700 --> 00:11:58.990
these mocks to life.

00:11:58.990 --> 00:12:01.350
Now, we need to consider
three factors in

00:12:01.350 --> 00:12:03.390
our software design.

00:12:03.390 --> 00:12:05.030
What do we need to show?

00:12:05.030 --> 00:12:06.970
When do we need to update
what we're showing?

00:12:06.970 --> 00:12:10.010
And how do we perform these
updates efficiently?

00:12:10.010 --> 00:12:11.820
Now fundamentally, the
answers to those

00:12:11.820 --> 00:12:14.640
questions are pretty simple.

00:12:14.640 --> 00:12:16.890
Show users what they're
expecting to see.

00:12:16.890 --> 00:12:19.600
Do updates as often as you need
to, but don't do updates

00:12:19.600 --> 00:12:21.230
if they're not necessary.

00:12:21.230 --> 00:12:23.380
And perform them using a
combination of Google Cloud

00:12:23.380 --> 00:12:26.760
Messaging, sync adapters,
and the volley library.

00:12:26.760 --> 00:12:29.100
And of course, you want to do
all of that in a way that

00:12:29.100 --> 00:12:33.030
makes it look as though it's
happening by magic.

00:12:33.030 --> 00:12:34.910
Now, I'll forgive you for
thinking that those answers

00:12:34.910 --> 00:12:36.420
are a little simplistic.

00:12:36.420 --> 00:12:39.870
Certainly, I understand that a
simple design can look very

00:12:39.870 --> 00:12:41.450
different once you've
implemented

00:12:41.450 --> 00:12:43.210
it in the real world.

00:12:43.210 --> 00:12:46.690
So before we dive in, let's take
a look at a few simple

00:12:46.690 --> 00:12:51.590
techniques we can use to add
a little bit off magic.

00:12:51.590 --> 00:12:54.310
We're going to do that by
offering some features which I

00:12:54.310 --> 00:12:55.730
think users will appreciate but

00:12:55.730 --> 00:12:59.400
probably weren't expecting.

00:12:59.400 --> 00:13:01.330
Now, when we looked at Cricbuzz,
I mentioned that

00:13:01.330 --> 00:13:03.870
they're live commentary option
is a big enough deal that it

00:13:03.870 --> 00:13:06.450
should get promoted to the
action bar directly, but what

00:13:06.450 --> 00:13:10.220
if you don't have access
to a live audio stream?

00:13:10.220 --> 00:13:11.090
Fear not.

00:13:11.090 --> 00:13:13.370
You can take advantage of
Android's text-to-speech

00:13:13.370 --> 00:13:16.240
library to create your own
dynamic commentary.

00:13:16.240 --> 00:13:18.490
This is a massive features for
folks like me, who want to

00:13:18.490 --> 00:13:21.500
follow a match while I'm driving
to and from work.

00:13:21.500 --> 00:13:24.570
In fact, you can take this a
step further and include an

00:13:24.570 --> 00:13:27.210
option to automatically trigger
dynamic commentary

00:13:27.210 --> 00:13:29.730
when the user is driving using
the new location-based

00:13:29.730 --> 00:13:32.610
services activity
detection APIs.

00:13:32.610 --> 00:13:36.880
But of course, the real magic
comes for an app that seems to

00:13:36.880 --> 00:13:38.560
have been built especially
for you.

00:13:38.560 --> 00:13:40.450
And that means showing
you exactly what

00:13:40.450 --> 00:13:42.460
you expect to see.

00:13:42.460 --> 00:13:45.110
Now, when you open the app to
the landing page, there's

00:13:45.110 --> 00:13:47.200
likely to be several cricket
matches being played,

00:13:47.200 --> 00:13:50.410
including tests, one-dayers,
Twenty20, domestic and

00:13:50.410 --> 00:13:51.640
international.

00:13:51.640 --> 00:13:54.270
So how do you make sure that the
match I downloaded the app

00:13:54.270 --> 00:13:59.000
to track is the first one
displayed in this list?

00:13:59.000 --> 00:14:02.040
Now at I/O last year, I talked a
lot about context and taking

00:14:02.040 --> 00:14:04.860
advantage of what your phone
knows about you to create a

00:14:04.860 --> 00:14:07.620
personalized experience that
will make your app feel as

00:14:07.620 --> 00:14:10.690
though it was custom built
for each of your users.

00:14:10.690 --> 00:14:14.530
So how do we find out what match
each user wants to watch

00:14:14.530 --> 00:14:17.430
without asking them first?

00:14:17.430 --> 00:14:20.340
Well, for a start, we can assume
that the teams involved

00:14:20.340 --> 00:14:23.110
in a starred match are likely
to be of interest.

00:14:23.110 --> 00:14:25.090
Similarly, we can keep track
of which matches

00:14:25.090 --> 00:14:26.750
the user has watched.

00:14:26.750 --> 00:14:29.480
Over time, we should be able to
see a pattern to understand

00:14:29.480 --> 00:14:32.310
which teams or which grounds
the user is interested

00:14:32.310 --> 00:14:34.840
in the games of.

00:14:34.840 --> 00:14:36.710
But that doesn't help
us the first time

00:14:36.710 --> 00:14:37.760
that the app is opened.

00:14:37.760 --> 00:14:40.820
For that we need to be a
little bit sneakier.

00:14:40.820 --> 00:14:43.860
So let's start with
the most obvious.

00:14:43.860 --> 00:14:46.270
Check where they are using
location-based services.

00:14:46.270 --> 00:14:48.650
Request the course location
information and then reverse

00:14:48.650 --> 00:14:51.780
geocode they're last-known
location to figure out which

00:14:51.780 --> 00:14:52.930
country they're in.

00:14:52.930 --> 00:14:55.190
You can even go a step further
and figure out which state or

00:14:55.190 --> 00:14:58.050
province they're in to
understand which domestic site

00:14:58.050 --> 00:15:00.090
that they're likely
interested in.

00:15:00.090 --> 00:15:02.310
But I live in the US,
so that's really

00:15:02.310 --> 00:15:03.610
not going to work.

00:15:03.610 --> 00:15:05.390
So what else can we try?

00:15:05.390 --> 00:15:08.970
Well, another good signal is the
locale that the device is

00:15:08.970 --> 00:15:10.450
configured to.

00:15:10.450 --> 00:15:13.220
It's a strong signal, but my
device doesn't let me choose

00:15:13.220 --> 00:15:15.770
an Australian locale.

00:15:15.770 --> 00:15:19.640
Well, if I asked you what the
score was on the cricket,

00:15:19.640 --> 00:15:22.230
you'd assume I was interested in
Australia and it's not just

00:15:22.230 --> 00:15:25.730
because I'm a masochist, but
because I have an unmistakable

00:15:25.730 --> 00:15:27.230
Aussie accent.

00:15:27.230 --> 00:15:31.070
Now, it turns out that the
Android voice recognition lets

00:15:31.070 --> 00:15:34.190
you select your accent as
well as your language.

00:15:34.190 --> 00:15:36.850
So using this code, you can see
which language variation

00:15:36.850 --> 00:15:38.130
has been selected.

00:15:38.130 --> 00:15:41.650
Boom, now you can use my accent
as a way to guess which

00:15:41.650 --> 00:15:43.600
country I support.

00:15:43.600 --> 00:15:45.960
And suddenly you've got the
opportunity to customize the

00:15:45.960 --> 00:15:48.430
UI for me and put the Aussie
matches right at

00:15:48.430 --> 00:15:50.160
the top of the list.

00:15:50.160 --> 00:15:52.800
Now, this might seem like a
lot of work for a fairly

00:15:52.800 --> 00:15:54.090
trivial modification.

00:15:54.090 --> 00:15:57.910
But now, the first time I open
your app, there's a very good

00:15:57.910 --> 00:16:00.990
chance that I'll be presented
with the exact match that I

00:16:00.990 --> 00:16:04.170
downloaded this app in order
to find out the score for.

00:16:04.170 --> 00:16:07.250
That's a really powerful,
positive signal that I've done

00:16:07.250 --> 00:16:09.540
the right thing, that I've
downloaded the right app, that

00:16:09.540 --> 00:16:13.830
the person who developed it is
on the same wavelength as me.

00:16:13.830 --> 00:16:16.880
Other ways we can find out what
people are interested in.

00:16:16.880 --> 00:16:19.840
We can take advantage of
Google+ integration.

00:16:19.840 --> 00:16:22.490
So we can use the explicitly and
implicitly tracked teams

00:16:22.490 --> 00:16:26.060
from our friends to help inform
the app of the matches

00:16:26.060 --> 00:16:28.340
that we are likely to
be interested in.

00:16:28.340 --> 00:16:31.020
And as a bonus, by using Google+
sign in, you can now

00:16:31.020 --> 00:16:33.500
synchronize those starred
matches across all of the

00:16:33.500 --> 00:16:36.080
user's devices.

00:16:36.080 --> 00:16:39.120
So, now we know the matches that
you're user has indicated

00:16:39.120 --> 00:16:41.040
that they're definitely
interested in and the ones

00:16:41.040 --> 00:16:42.860
that they are likely to
be interested in.

00:16:42.860 --> 00:16:45.900
So how else can we use that
data to improve the

00:16:45.900 --> 00:16:49.010
performance and usability
of our app?

00:16:49.010 --> 00:16:52.570
Well, we could start by sending
it all to your server.

00:16:52.570 --> 00:16:54.960
Now, this is an important step,
as it's going to help us

00:16:54.960 --> 00:17:01.230
is ensure that we only perform
updates as often as needed to

00:17:01.230 --> 00:17:04.408
ensure that we can eliminate
the refresh button.

00:17:04.408 --> 00:17:07.819
Now, that means that the data
being displayed needs to be

00:17:07.819 --> 00:17:09.910
constantly up-to-date.

00:17:09.910 --> 00:17:12.510
And for sports scores, that
means getting updates as soon

00:17:12.510 --> 00:17:15.700
as they happen, but without
wasting bandwidth and battery

00:17:15.700 --> 00:17:17.560
requesting updates in
between overs or

00:17:17.560 --> 00:17:19.009
during the drinks break.

00:17:19.009 --> 00:17:22.450
Now, updates are going to fall
into two broad categories,

00:17:22.450 --> 00:17:24.609
background and foreground.

00:17:24.609 --> 00:17:27.000
When the app is open and the
user is looking at it, they're

00:17:27.000 --> 00:17:29.180
either going to be browsing,
looking at news, stats,

00:17:29.180 --> 00:17:31.080
upcoming fixtures, and so on.

00:17:31.080 --> 00:17:31.890
Or they're going to be watching

00:17:31.890 --> 00:17:34.210
a match as it happens.

00:17:34.210 --> 00:17:37.280
Now, in the latter case, you
should be looking to implement

00:17:37.280 --> 00:17:39.500
the best practices for creating
apps that transfer

00:17:39.500 --> 00:17:42.260
the data in battery-efficient
ways, so that when they're

00:17:42.260 --> 00:17:44.580
browsing around your site,
they're not draining the

00:17:44.580 --> 00:17:47.190
battery every time they
click a link.

00:17:47.190 --> 00:17:49.470
Now, I like to call this
the big cookie

00:17:49.470 --> 00:17:51.770
model of data transfers.

00:17:51.770 --> 00:17:54.190
In real terms, that means
minimizing the number of radio

00:17:54.190 --> 00:17:57.760
state transitions caused by your
app transmitting data.

00:17:57.760 --> 00:18:01.390
To do that, you need to
pre-fetch enough data so as to

00:18:01.390 --> 00:18:04.260
prevent additional downloads,
usually within the next two to

00:18:04.260 --> 00:18:07.310
five minutes, without just
cheating by downloading

00:18:07.310 --> 00:18:08.550
everything on your server.

00:18:08.550 --> 00:18:10.690
Now typically, that's going
to look like around

00:18:10.690 --> 00:18:12.840
five megs of data.

00:18:12.840 --> 00:18:15.790
Now, what you download is
whatever you think the user is

00:18:15.790 --> 00:18:19.310
likely to request within that
next five-minute time window.

00:18:19.310 --> 00:18:21.650
It's another good opportunity
to use those implicitly

00:18:21.650 --> 00:18:24.860
tracked teams to pre-fetch
commentary from matches that

00:18:24.860 --> 00:18:27.460
they're likely to observe or
which news stories they're

00:18:27.460 --> 00:18:29.760
likely to read.

00:18:29.760 --> 00:18:32.390
Pre-fetched data is available
instantly and has zero

00:18:32.390 --> 00:18:35.220
incremental cost in terms
of battery life.

00:18:35.220 --> 00:18:37.170
So it's generally good
practice to be pretty

00:18:37.170 --> 00:18:39.550
aggressive with what you choose
to pull down ahead of

00:18:39.550 --> 00:18:43.445
time, while all the time being
conscious of the associated

00:18:43.445 --> 00:18:46.560
bandwidth cost.

00:18:46.560 --> 00:18:50.280
When we do need transfer data,
you want to batch all of your

00:18:50.280 --> 00:18:51.660
transfers together.

00:18:51.660 --> 00:18:53.990
It's more efficient to transfer
a lot of data at once

00:18:53.990 --> 00:18:56.030
rather than spreading
it out over time.

00:18:56.030 --> 00:18:58.840
So if you need to pull down
commentary for new match, you

00:18:58.840 --> 00:19:01.040
should take that as an
opportunity to preempt your

00:19:01.040 --> 00:19:05.220
next batch of pre-fetch news
stories and score updates.

00:19:05.220 --> 00:19:07.630
The easiest way to do this is
by bundling all of your

00:19:07.630 --> 00:19:10.640
transfers together within
a sync adapter.

00:19:10.640 --> 00:19:13.250
Then within each of these
methods, you can make a more

00:19:13.250 --> 00:19:16.490
fine-grain choice regarding what
data you actually want to

00:19:16.490 --> 00:19:19.340
transfer each time a sync
adapter is called.

00:19:19.340 --> 00:19:20.500
Now, for example, fixtures.

00:19:20.500 --> 00:19:23.370
You probably don't need to be
updating them more than once a

00:19:23.370 --> 00:19:26.380
day, whereas news headlines will
more likely want to be

00:19:26.380 --> 00:19:28.340
much more frequent.

00:19:28.340 --> 00:19:31.380
Now, when it comes to real-time
updates, there's a

00:19:31.380 --> 00:19:34.190
temptation to set up a timer
that just pings your server

00:19:34.190 --> 00:19:36.160
for an update every minute
while your app is in the

00:19:36.160 --> 00:19:37.570
foreground.

00:19:37.570 --> 00:19:40.690
Certainly, that's an approach
that I took years ago, back in

00:19:40.690 --> 00:19:42.000
the days of Google desktop.

00:19:42.000 --> 00:19:44.920
Before I knew better, I wrote
myself a widget that tracked

00:19:44.920 --> 00:19:46.920
scores on Cricinfo
by scraping a

00:19:46.920 --> 00:19:48.740
particular page every minute.

00:19:48.740 --> 00:19:49.650
It was perfect.

00:19:49.650 --> 00:19:51.660
While the match was ongoing,
I got those constant

00:19:51.660 --> 00:19:53.620
bowl-by-bowl updates.

00:19:53.620 --> 00:19:56.440
Unfortunately, it had a bug
that included a race

00:19:56.440 --> 00:19:58.820
condition, which, when
triggered, meant that the

00:19:58.820 --> 00:20:01.650
widget missed the
end of a match.

00:20:01.650 --> 00:20:05.040
So it would get a 404 but would
keep pinging the site

00:20:05.040 --> 00:20:09.160
over and over, every minute of
every hour of every day.

00:20:09.160 --> 00:20:11.350
It was only brought to my
attention when the company's

00:20:11.350 --> 00:20:13.730
tech ops folks wondered why I
was downloading one and a

00:20:13.730 --> 00:20:16.980
quarter gig of data every
week for a month

00:20:16.980 --> 00:20:19.220
while I was on holiday.

00:20:19.220 --> 00:20:22.440
So regular updates, foreground
or background, need to be

00:20:22.440 --> 00:20:23.780
carefully managed.

00:20:23.780 --> 00:20:26.580
In fact, foreground updates are
really just a special case

00:20:26.580 --> 00:20:29.210
of background updates, one
which happens much more

00:20:29.210 --> 00:20:30.390
frequently.

00:20:30.390 --> 00:20:33.620
So let's take a look at how
they can work together.

00:20:33.620 --> 00:20:36.080
And we'll start by taking a
closer look at the background

00:20:36.080 --> 00:20:38.390
update case.

00:20:38.390 --> 00:20:41.480
Now, we have starred updates
for which we want

00:20:41.480 --> 00:20:42.320
notifications.

00:20:42.320 --> 00:20:44.810
We have implicitly tracked teams
for which we want to do

00:20:44.810 --> 00:20:47.660
regular updates to keep the
app fresh, and updates on

00:20:47.660 --> 00:20:50.100
fixtures and stats that probably
only need to happen

00:20:50.100 --> 00:20:51.880
once a day.

00:20:51.880 --> 00:20:55.300
You may even argue that only
starred matches need to be

00:20:55.300 --> 00:20:57.650
updated in the background, but
personally, I think that

00:20:57.650 --> 00:21:00.330
there's value in keeping the app
up-to-date even when it's

00:21:00.330 --> 00:21:02.960
not running, as long as we can
do so in a way that doesn't

00:21:02.960 --> 00:21:03.840
drain the battery.

00:21:03.840 --> 00:21:07.170
If you do it right, you minimize
latency at start up.

00:21:07.170 --> 00:21:09.410
You can make sure that the app
is still useful even if you

00:21:09.410 --> 00:21:12.530
don't have connectivity right
when you open it.

00:21:12.530 --> 00:21:15.720
So, like the visual design, I
start my update architecture

00:21:15.720 --> 00:21:17.590
with pen and paper.

00:21:17.590 --> 00:21:22.490
Now, this design translates
into this flow chart.

00:21:22.490 --> 00:21:23.650
So let's step through it.

00:21:23.650 --> 00:21:26.310
And we'll start with our
starred matches.

00:21:26.310 --> 00:21:28.980
Now, these are the games our
users have explicitly marked

00:21:28.980 --> 00:21:33.090
as important and for whom we're
delivering notifications

00:21:33.090 --> 00:21:35.390
while that app is in
the background.

00:21:35.390 --> 00:21:37.500
Now, matches that of being
observed while in the

00:21:37.500 --> 00:21:40.160
foreground, for which we want
to have those real-time

00:21:40.160 --> 00:21:43.290
updates, they fit into
the same category.

00:21:43.290 --> 00:21:46.800
For those updates, both the
foreground and background

00:21:46.800 --> 00:21:49.360
case, we're going to
rely entirely on

00:21:49.360 --> 00:21:51.180
Google Cloud Messaging.

00:21:51.180 --> 00:21:53.580
We'll set a flag on the server
to decide whether we want to

00:21:53.580 --> 00:21:56.820
have every bowl updates or if
we just want significant

00:21:56.820 --> 00:21:59.270
events like wickets
or end of innings.

00:21:59.270 --> 00:22:02.110
But rather than just sending a
push message notifying the

00:22:02.110 --> 00:22:05.430
client of impending update, we
can just send the entire

00:22:05.430 --> 00:22:08.930
update within the GCM payload.

00:22:08.930 --> 00:22:13.320
Now, every GCM message can
contain up to 4K of data.

00:22:13.320 --> 00:22:15.150
One over's worth
of commentary's

00:22:15.150 --> 00:22:16.200
typically around 1K.

00:22:16.200 --> 00:22:19.320
So you can safely send the
commentary for each bowl of an

00:22:19.320 --> 00:22:22.680
observed match or the details of
a fallen wicket, including

00:22:22.680 --> 00:22:25.860
the commentary, for background
notifications.

00:22:25.860 --> 00:22:28.340
Now, the result is a
significantly decreased

00:22:28.340 --> 00:22:31.350
latency for those updates and
a simpler, more efficient

00:22:31.350 --> 00:22:34.050
update implementation where
you're not having to figure

00:22:34.050 --> 00:22:36.610
out how to modify the timing
of your update based on the

00:22:36.610 --> 00:22:38.280
current state of the match.

00:22:38.280 --> 00:22:40.120
And you never doing updates
more frequently

00:22:40.120 --> 00:22:41.880
than you need to.

00:22:41.880 --> 00:22:45.840
Now, for matches that we aren't
actively tracking, we

00:22:45.840 --> 00:22:48.530
can use Google Cloud Messaging
to tickle the client when

00:22:48.530 --> 00:22:51.720
there are updates related to the
teams we implicitly track.

00:22:51.720 --> 00:22:54.360
We do want to initiate an update
for every new news

00:22:54.360 --> 00:22:57.000
update or new fixture or new
match for teams we aren't

00:22:57.000 --> 00:22:58.510
actively tracking.

00:22:58.510 --> 00:23:01.350
So we can prioritize
pre-fetching information

00:23:01.350 --> 00:23:02.900
related to the teams we
think are the most

00:23:02.900 --> 00:23:04.595
relevant to our users.

00:23:04.595 --> 00:23:06.900
Now, given that the data is
changing on the server, it

00:23:06.900 --> 00:23:09.310
again makes sense for these
updates to be driven from the

00:23:09.310 --> 00:23:12.030
server side using GCM.

00:23:12.030 --> 00:23:14.530
But we can make them even more
efficient by having the client

00:23:14.530 --> 00:23:17.350
influence the frequency with
which we actually receive

00:23:17.350 --> 00:23:18.545
these updates.

00:23:18.545 --> 00:23:22.700
Now, I like to implement a usage
back off pattern backed

00:23:22.700 --> 00:23:24.270
by a sync adapter.

00:23:24.270 --> 00:23:27.900
So every time we perform a
redundant update, defined as

00:23:27.900 --> 00:23:31.140
two updates that happen in
between the app being closed

00:23:31.140 --> 00:23:33.800
and being reopened, we double
the amount of time that we

00:23:33.800 --> 00:23:37.110
wait before we performed the
next background update.

00:23:37.110 --> 00:23:39.570
Now, that same approach will
work either by changing the

00:23:39.570 --> 00:23:43.040
frequency of a periodic sync
set for sync adapter or by

00:23:43.040 --> 00:23:45.320
setting a flag on the service
to each of those client

00:23:45.320 --> 00:23:47.460
updates to say how frequently
we should be

00:23:47.460 --> 00:23:49.430
performing this tickles.

00:23:49.430 --> 00:23:52.175
The update itself will be formed
by triggering a sync

00:23:52.175 --> 00:23:54.820
adapter in exactly the same way
as it should happen when

00:23:54.820 --> 00:23:56.570
the app is opened.

00:23:56.570 --> 00:23:58.640
And you want to get that
fresh data when

00:23:58.640 --> 00:24:00.700
the user starts browsing.

00:24:00.700 --> 00:24:03.550
Now alternatively, or
additionally, you can use

00:24:03.550 --> 00:24:06.710
further context to modify the
background updates and

00:24:06.710 --> 00:24:10.530
browsing pre-fetch rates
of your application.

00:24:10.530 --> 00:24:13.360
For example, a user standing
still, browsing the app, is

00:24:13.360 --> 00:24:15.660
much more likely to browse
for longer than one

00:24:15.660 --> 00:24:17.070
who is walking around.

00:24:17.070 --> 00:24:19.360
So you can use activity
detection to increase

00:24:19.360 --> 00:24:23.150
pre-fetch amount, or the
frequency of prefetches, based

00:24:23.150 --> 00:24:25.510
on the fact that they're
standing still.

00:24:25.510 --> 00:24:28.520
Similarly, you can use the
tilting activity to determine

00:24:28.520 --> 00:24:32.640
when to initiate daily updates,
like fixture changes,

00:24:32.640 --> 00:24:35.195
every morning when you user
picks up their device rather

00:24:35.195 --> 00:24:38.320
than specifying an
arbitrary time.

00:24:38.320 --> 00:24:40.910
Finally, there's one more piece
of magic that we can

00:24:40.910 --> 00:24:43.270
build which sits at the
confluence of background

00:24:43.270 --> 00:24:48.490
updates and implicitly tracked
teams, series notifications.

00:24:48.490 --> 00:24:51.200
So by tracking the teams that we
think users are interested

00:24:51.200 --> 00:24:54.220
in, we can send them infrequent
notifications to

00:24:54.220 --> 00:24:56.610
alert them of significant
events related to

00:24:56.610 --> 00:24:58.140
a particular team.

00:24:58.140 --> 00:25:00.920
This can be a really effective
way to help drive engagement

00:25:00.920 --> 00:25:02.990
by reminding people
to use your app.

00:25:02.990 --> 00:25:06.740
But it's important to be very
careful not to become spammy.

00:25:06.740 --> 00:25:09.920
I'd recommend only sending
notifications once per series.

00:25:09.920 --> 00:25:13.020
It would be great to know that
the Ashes is about to begin,

00:25:13.020 --> 00:25:16.390
but I don't necessarily want to
be told every single match

00:25:16.390 --> 00:25:18.240
that Australia is playing.

00:25:18.240 --> 00:25:20.790
Now, it may even make sense
to add a "stop these

00:25:20.790 --> 00:25:23.390
notifications" action to the
notification itself.

00:25:23.390 --> 00:25:27.110
Or go the other way, and perhaps
include an action to

00:25:27.110 --> 00:25:28.670
star every match
in that series.

00:25:28.670 --> 00:25:32.030
So they get one prompt and are
then able to opt in or opt out

00:25:32.030 --> 00:25:33.280
of getting further
notifications.

00:25:35.790 --> 00:25:38.540
So we've covered all the
technologies already.

00:25:38.540 --> 00:25:42.320
But let's quickly review the
technologies that we should be

00:25:42.320 --> 00:25:44.140
using to perform all
of these updates.

00:25:44.140 --> 00:25:46.400
Now, I'm not going to go into
too much detail because I've

00:25:46.400 --> 00:25:48.000
already been talking for
a very long time.

00:25:48.000 --> 00:25:50.560
But I'll share some the
resources that you can use to

00:25:50.560 --> 00:25:54.260
find out how to implement what
I've been talking about.

00:25:54.260 --> 00:25:58.550
So everything in this design
is driven from your server,

00:25:58.550 --> 00:26:01.300
with Google Cloud Messaging
either transmitting the data

00:26:01.300 --> 00:26:04.640
directly or initiating a sync
adapter update through

00:26:04.640 --> 00:26:06.550
tickling the client.

00:26:06.550 --> 00:26:09.060
The Google Cloud Messaging APIs
are described in detail

00:26:09.060 --> 00:26:13.260
at developers.andro
id.com/google/gcm and you can

00:26:13.260 --> 00:26:16.430
find out lots of detail on
implementing sync adapters in

00:26:16.430 --> 00:26:19.010
this new Android training class
on transferring data

00:26:19.010 --> 00:26:20.960
using sync adapters.

00:26:20.960 --> 00:26:23.920
For populating list views,
particularly useful for things

00:26:23.920 --> 00:26:27.950
like news, you can use volley,
which you can find out all

00:26:27.950 --> 00:26:30.800
about from Ficus Kirkpatrick's
awesome IO talk from

00:26:30.800 --> 00:26:33.480
earlier this year.

00:26:33.480 --> 00:26:35.480
One of the challenges of
having server-generated

00:26:35.480 --> 00:26:38.180
notifications based on matches
that you're syncing across

00:26:38.180 --> 00:26:41.410
multiple devices is avoiding
spending your users with the

00:26:41.410 --> 00:26:43.985
same notifications on their
phone and on their tablet.

00:26:43.985 --> 00:26:46.790
Or if you're someone like me,
on four of their phones and

00:26:46.790 --> 00:26:48.450
seven of their tablets.

00:26:48.450 --> 00:26:50.680
Now, one of the great new
features in Google Cloud

00:26:50.680 --> 00:26:53.150
Messaging is user notifications
are just part of

00:26:53.150 --> 00:26:55.340
the upstream messaging API.

00:26:55.340 --> 00:26:57.510
It's available through
Google Play services.

00:26:57.510 --> 00:27:01.150
Now, this API lets you send a
message to other instances of

00:27:01.150 --> 00:27:02.760
your application.

00:27:02.760 --> 00:27:05.770
So if you dismiss a notification
on one device,

00:27:05.770 --> 00:27:09.290
you're able to send a
notification to the client

00:27:09.290 --> 00:27:11.820
running on every device that
that notification is no longer

00:27:11.820 --> 00:27:13.310
relevant and it will
disappear.

00:27:13.310 --> 00:27:15.500
This is something you can see
in the latest version of

00:27:15.500 --> 00:27:17.460
Google Calendar.

00:27:17.460 --> 00:27:21.860
You can find our more details
from Francesca Nerieri's IO

00:27:21.860 --> 00:27:24.080
talk from earlier this year,
where he went into a lot of

00:27:24.080 --> 00:27:26.440
detail and Google Cloud
Messaging and how you can use

00:27:26.440 --> 00:27:28.480
it within your app.

00:27:28.480 --> 00:27:31.600
That was a lot of information
to digest in a relatively

00:27:31.600 --> 00:27:32.650
short period of time.

00:27:32.650 --> 00:27:34.980
I hope you enjoyed this slightly
different take on the

00:27:34.980 --> 00:27:35.940
App Clinic.

00:27:35.940 --> 00:27:39.260
As always, we'd love to hear
your thoughts and feedback.

00:27:39.260 --> 00:27:42.260
In the meantime, I'll leave
you with these key points.

00:27:42.260 --> 00:27:44.010
The refresh button is dead.

00:27:44.010 --> 00:27:46.210
Google Cloud Messaging allows
you to eliminate all

00:27:46.210 --> 00:27:48.070
unnecessary transfers
while maintaining

00:27:48.070 --> 00:27:50.450
those low latency updates.

00:27:50.450 --> 00:27:52.790
The transfers themselves should
all be handled by the

00:27:52.790 --> 00:27:55.250
sync adapter, which is not
only efficient, but also

00:27:55.250 --> 00:27:57.760
handles things like connectivity
changes to make

00:27:57.760 --> 00:28:00.690
sure your transfers always
get through.

00:28:00.690 --> 00:28:03.180
Context, anything from your
users' location to their

00:28:03.180 --> 00:28:05.910
accent can help provide those
magical touches that will

00:28:05.910 --> 00:28:08.650
cause people to fall in
love with your apps.

00:28:08.650 --> 00:28:10.870
And if you're an Australian
cricket fan, it's probably

00:28:10.870 --> 00:28:13.650
best to avoid installing any
these apps for at least the

00:28:13.650 --> 00:28:16.870
next six to 12 months.

00:28:16.870 --> 00:28:19.740
Thank you for joining us this
week on the App Clinic.

00:28:19.740 --> 00:28:23.610
Check out developers.googl
e.com/live/android or the

00:28:23.610 --> 00:28:26.230
Android Dev YouTube channel
to find out more about our

00:28:26.230 --> 00:28:30.280
upcoming episodes of this and
other Android developer shows.

00:28:30.280 --> 00:28:32.510
My name is Reto Meier.

