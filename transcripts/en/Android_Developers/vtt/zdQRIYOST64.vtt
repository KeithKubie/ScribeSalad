WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.802
[MUSIC PLAYING]

00:00:07.010 --> 00:00:08.360
CHET HAASE: Hi.

00:00:08.360 --> 00:00:10.760
Welcome to our
talk, "Drawn Out--

00:00:10.760 --> 00:00:13.280
How Android Renders the UI."

00:00:13.280 --> 00:00:15.260
It was almost called
something else.

00:00:15.260 --> 00:00:20.180
We called it this, and then
somebody in some administration

00:00:20.180 --> 00:00:22.010
position decided it
was actually going

00:00:22.010 --> 00:00:25.610
to be called "How
to Optimize Your App

00:00:25.610 --> 00:00:28.400
for Top Rendering
Performance" or something.

00:00:28.400 --> 00:00:29.990
That wasn't what
the talk was about,

00:00:29.990 --> 00:00:31.210
so fortunately, we
changed it back.

00:00:31.210 --> 00:00:31.620
ROMAIN GUY: And it still isn't.

00:00:31.620 --> 00:00:35.000
CHET HAASE: Instead, we're going
to tell you the details of how,

00:00:35.000 --> 00:00:36.500
actually, stuff works.

00:00:36.500 --> 00:00:37.310
I'm Chet Haase.

00:00:37.310 --> 00:00:38.900
I'm from the Android
toolkit team.

00:00:38.900 --> 00:00:39.470
ROMAIN GUY: And I'm Romain Guy.

00:00:39.470 --> 00:00:40.886
I'm on the Android
framework team,

00:00:40.886 --> 00:00:42.537
and I do real time graphics.

00:00:42.537 --> 00:00:45.120
CHET HAASE: And that's kind of
what we're talking about today.

00:00:45.120 --> 00:00:47.934
So we have given versions
of this talk before,

00:00:47.934 --> 00:00:49.100
and we thought we were done.

00:00:49.100 --> 00:00:51.050
And then we realized
that enough stuff

00:00:51.050 --> 00:00:53.750
has changed inside the
system that maybe it

00:00:53.750 --> 00:00:56.790
was time to go through this
again and see where we're at.

00:00:56.790 --> 00:01:00.530
So this is our
attempt to do that.

00:01:00.530 --> 00:01:01.250
Let's go.

00:01:01.250 --> 00:01:03.420
So first of all, there
is this word, rendering.

00:01:03.420 --> 00:01:04.640
What do we mean by that?

00:01:04.640 --> 00:01:09.211
Normally, it means melting
fat in order to clarify it.

00:01:09.211 --> 00:01:11.460
That's not quite what we're
going to talk about today.

00:01:11.460 --> 00:01:14.420
Instead, we're talking about
the process of actually turning

00:01:14.420 --> 00:01:16.550
all that stuff, like
buttons and check boxes

00:01:16.550 --> 00:01:19.130
and everything on the
screen, into pixels

00:01:19.130 --> 00:01:20.360
that the user can look at.

00:01:20.360 --> 00:01:21.990
And there's a lot
of things going on.

00:01:21.990 --> 00:01:23.490
There's a lot of
details that we are

00:01:23.490 --> 00:01:26.240
glossing over today
because we only

00:01:26.240 --> 00:01:28.130
have 40 minutes to do this.

00:01:28.130 --> 00:01:31.130
But we'll dump a lot of
details on you along the way.

00:01:31.130 --> 00:01:32.900
So first of all, I'm
going to take you

00:01:32.900 --> 00:01:34.250
through-- there's going
to be a bunch of colored

00:01:34.250 --> 00:01:35.666
dots on the top,
and these will be

00:01:35.666 --> 00:01:38.260
sort of a visual cue for a
lot of the rest of the talk.

00:01:38.260 --> 00:01:39.635
So I'm going to
walk through sort

00:01:39.635 --> 00:01:42.410
of the life of what happens
in the flow of information

00:01:42.410 --> 00:01:44.930
down to the pixels on the
screen really quickly.

00:01:44.930 --> 00:01:47.060
We have this thing
called the choreographer,

00:01:47.060 --> 00:01:50.080
and that kicks in usually
60 times a second,

00:01:50.080 --> 00:01:53.420
and it says, hey, Vsync,
this is the interval at which

00:01:53.420 --> 00:01:55.580
the frame is being synced.

00:01:55.580 --> 00:01:57.050
Buffers flip onto the screen.

00:01:57.050 --> 00:02:00.170
It's a good time for us to
process a lot of information,

00:02:00.170 --> 00:02:02.040
and then handle rendering
that information

00:02:02.040 --> 00:02:02.970
as a result of that.

00:02:02.970 --> 00:02:04.990
So we get a Vsync
operation that's

00:02:04.990 --> 00:02:11.250
sent up to the Java SDK lands,
and we're on the UI thread.

00:02:11.250 --> 00:02:14.360
And all of a sudden, we need to
process input events, which can

00:02:14.360 --> 00:02:15.890
trigger changes in properties.

00:02:15.890 --> 00:02:18.710
We also run any animations.

00:02:18.710 --> 00:02:20.030
So we change property values.

00:02:20.030 --> 00:02:23.300
Again, that may trigger things
like layouts and invalidation.

00:02:23.300 --> 00:02:27.140
We do, then, the whole traversal
pass, which is measuring views

00:02:27.140 --> 00:02:28.910
to figure out how
large they are,

00:02:28.910 --> 00:02:31.730
laying them out, which is
actually positioning them

00:02:31.730 --> 00:02:33.830
where they need to be,
and then drawing them.

00:02:33.830 --> 00:02:35.450
Once all of that
information is done,

00:02:35.450 --> 00:02:37.880
we sync the result
of that information

00:02:37.880 --> 00:02:40.520
over to this thing
called the render thread.

00:02:40.520 --> 00:02:44.180
And the render thread takes
that and says, OK, well, I'm

00:02:44.180 --> 00:02:46.820
going to then execute these.

00:02:46.820 --> 00:02:48.740
I'm going to
basically turn these

00:02:48.740 --> 00:02:51.800
into native versions
of all that information

00:02:51.800 --> 00:02:54.170
we produced at the Java
layer, and then I'm

00:02:54.170 --> 00:02:56.060
going to get a
buffer from the GPU,

00:02:56.060 --> 00:02:58.370
so that I have a place to
write this information.

00:02:58.370 --> 00:03:01.310
And then I'm going to actually
issue all these GPU commands

00:03:01.310 --> 00:03:02.831
as OpenGL stuff over there.

00:03:02.831 --> 00:03:05.330
And then I'm going to say, OK,
it's time to swap the buffer,

00:03:05.330 --> 00:03:07.316
and then I turn it
over to the GPU.

00:03:07.316 --> 00:03:08.690
And then the
graphics system does

00:03:08.690 --> 00:03:10.315
something called
compositing, and we're

00:03:10.315 --> 00:03:12.700
going to talk about most
of these steps today.

00:03:12.700 --> 00:03:14.741
ROMAIN GUY: So compositing
is, I think, something

00:03:14.741 --> 00:03:16.030
we've never explained before.

00:03:16.030 --> 00:03:17.988
So we're going to go in
a little bit of details

00:03:17.988 --> 00:03:20.547
about this part of the Android
rendering architecture.

00:03:20.547 --> 00:03:22.130
CHET HAASE: So the
little colored dots

00:03:22.130 --> 00:03:23.990
on the top of the
screen will be noting

00:03:23.990 --> 00:03:27.130
where we are in the process, as
we work through a few examples,

00:03:27.130 --> 00:03:28.940
so that we can
understand this better.

00:03:28.940 --> 00:03:31.560
Speaking of examples,
here's a simple one.

00:03:31.560 --> 00:03:33.770
So let's suppose
that we have a user,

00:03:33.770 --> 00:03:35.510
and the user clicks on an item.

00:03:35.510 --> 00:03:37.880
I wrote this awesome
RecyclerView application

00:03:37.880 --> 00:03:39.590
that looks exactly like this.

00:03:39.590 --> 00:03:42.020
I know it is because
that's a screen shot

00:03:42.020 --> 00:03:43.770
from my awesome application.

00:03:43.770 --> 00:03:46.590
It's a RecyclerView with
a bunch of items in it,

00:03:46.590 --> 00:03:49.920
and when the user clicks on
one, this amazing thing happens.

00:03:49.920 --> 00:03:52.730
It turns into a random
color on the background.

00:03:52.730 --> 00:03:53.840
It's incredible.

00:03:53.840 --> 00:03:56.030
I could give you the
source, but I don't know.

00:03:56.030 --> 00:03:57.180
It's pretty complicated.

00:03:57.180 --> 00:03:58.640
I'm not sure you'd
understand it.

00:03:58.640 --> 00:04:02.015
So here's the amazing layout
for my amazing demo application.

00:04:02.015 --> 00:04:03.140
There's a ConstraintLayout.

00:04:03.140 --> 00:04:05.190
There is a RecyclerView
inside of it,

00:04:05.190 --> 00:04:06.710
and then I populated
it at runtime

00:04:06.710 --> 00:04:08.780
with a bunch of
random items in there.

00:04:08.780 --> 00:04:10.280
The view hierarchy
for this thing

00:04:10.280 --> 00:04:12.020
looks basically like this.

00:04:12.020 --> 00:04:13.940
In fact, it doesn't look
basically like this.

00:04:13.940 --> 00:04:15.620
It looks exactly like this.

00:04:15.620 --> 00:04:17.280
So you walk down
from the DecorView

00:04:17.280 --> 00:04:19.279
and you've got a LinearLayout
and a FrameLayout.

00:04:19.279 --> 00:04:22.280
I'm not exactly sure why we
have the deep nesting there,

00:04:22.280 --> 00:04:23.330
but whatever.

00:04:23.330 --> 00:04:24.320
History.

00:04:24.320 --> 00:04:26.990
We have a bunch of stuff
for action bar in there.

00:04:26.990 --> 00:04:28.200
None of that really matters.

00:04:28.200 --> 00:04:29.616
What we're concerned
about here is

00:04:29.616 --> 00:04:31.970
what's actually going on
in the content hierarchy,

00:04:31.970 --> 00:04:34.370
because that's what you can
affect with your application.

00:04:34.370 --> 00:04:36.870
So we have content FrameLayout,
we have the ConstraintLayout

00:04:36.870 --> 00:04:39.050
on the outside, wrapping
the RecyclerView, and then

00:04:39.050 --> 00:04:40.070
all of the items.

00:04:40.070 --> 00:04:41.450
Specifically,
these are the items

00:04:41.450 --> 00:04:43.970
that are on screen because
those are the only ones that

00:04:43.970 --> 00:04:48.770
are actually being measured
and laid out and drawn.

00:04:48.770 --> 00:04:49.950
So what happens?

00:04:49.950 --> 00:04:51.740
Let's walk through
this example and walk

00:04:51.740 --> 00:04:54.650
through that entire flow that we
went through at the beginning.

00:04:54.650 --> 00:04:58.130
So user clicks, there's
a Vsync operation.

00:04:58.130 --> 00:05:01.880
That gets sent up and we process
input during the input phase,

00:05:01.880 --> 00:05:03.890
and we notice that
this is a click.

00:05:03.890 --> 00:05:05.501
I'm glossing over
some details here.

00:05:05.501 --> 00:05:08.000
Actually, we're going to notice
first that there was a down,

00:05:08.000 --> 00:05:09.416
and then there was
an up, and then

00:05:09.416 --> 00:05:10.942
it gets processed as a click.

00:05:10.942 --> 00:05:12.650
Just take it for
granted we're eventually

00:05:12.650 --> 00:05:14.840
going to process a click here.

00:05:14.840 --> 00:05:17.050
That ends up in this
item clicked method

00:05:17.050 --> 00:05:19.940
that I have in my
amazingly complex example,

00:05:19.940 --> 00:05:22.250
and in there, we're going
to set the background color

00:05:22.250 --> 00:05:24.410
on this item to a random color.

00:05:24.410 --> 00:05:27.950
That's why I called
the method random.

00:05:27.950 --> 00:05:31.850
That gets sent over to the set
background color in view.java,

00:05:31.850 --> 00:05:35.480
which does a bunch of stuff to
set the color on the background

00:05:35.480 --> 00:05:37.070
drawable, and then
it eventually calls

00:05:37.070 --> 00:05:39.420
this method called invalidate.

00:05:39.420 --> 00:05:41.360
Invalidation is the process--

00:05:41.360 --> 00:05:43.220
it doesn't actually
redraw the views.

00:05:43.220 --> 00:05:46.070
It's the process of telling the
View Hierarchy that something

00:05:46.070 --> 00:05:48.200
needs to be redrawn.

00:05:48.200 --> 00:05:50.930
So you get a click.

00:05:50.930 --> 00:05:54.110
That happens on the
item down at the bottom.

00:05:54.110 --> 00:05:55.360
So that item two--

00:05:55.360 --> 00:05:57.110
you see it's
surrounded by green.

00:05:57.110 --> 00:05:58.847
We have a little
invalidate method

00:05:58.847 --> 00:06:00.680
that gets called on
that, and that basically

00:06:00.680 --> 00:06:01.670
walks up the tree.

00:06:01.670 --> 00:06:04.100
It calls a series of methods
all the way up the tree,

00:06:04.100 --> 00:06:07.389
because the view knows that
it needs to be redrawn,

00:06:07.389 --> 00:06:09.680
but it actually needs to
propagate that information all

00:06:09.680 --> 00:06:11.540
the way up the hierarchy,
so that then, we

00:06:11.540 --> 00:06:14.450
can redraw all the things
on the way down, later.

00:06:14.450 --> 00:06:18.230
So we call invalidate trial
all the way up the hierarchy.

00:06:18.230 --> 00:06:21.260
That eventually ends
up in a massive class

00:06:21.260 --> 00:06:24.320
that we have called
ViewRootImpl.java,

00:06:24.320 --> 00:06:27.260
and we have this invalidate
child method there.

00:06:27.260 --> 00:06:29.270
And that basically
does nothing except

00:06:29.270 --> 00:06:32.150
says, OK, I need to schedule
a traversal, which means,

00:06:32.150 --> 00:06:34.040
OK, I've taken
information that somebody

00:06:34.040 --> 00:06:35.570
got invalidated somewhere.

00:06:35.570 --> 00:06:38.420
That means that I need to
run my traversal code later

00:06:38.420 --> 00:06:40.820
at the end of this process.

00:06:40.820 --> 00:06:43.190
Traversal is the
process of doing

00:06:43.190 --> 00:06:45.350
all the phases that are
necessary for actually

00:06:45.350 --> 00:06:46.490
rendering that frame.

00:06:46.490 --> 00:06:49.160
Specifically, it does measure--

00:06:49.160 --> 00:06:51.680
how big the views are, layout--

00:06:51.680 --> 00:06:54.830
setting the views' position and
size, and drawing the views.

00:06:54.830 --> 00:06:56.480
All of that is called traversal.

00:06:56.480 --> 00:06:58.390
So we've scheduled a traversal.

00:06:58.390 --> 00:07:00.960
That's going to happen
at some later time,

00:07:00.960 --> 00:07:02.250
and that later time is now.

00:07:02.250 --> 00:07:05.460
So in the same frame, we
end up in the traversal code

00:07:05.460 --> 00:07:07.580
in this
performTraversals method.

00:07:07.580 --> 00:07:12.167
It's going to do a PerformDraw,
which ends up calling a draw

00:07:12.167 --> 00:07:14.000
method onto core view,
and basically, that's

00:07:14.000 --> 00:07:16.320
going to propagate
all the way down.

00:07:16.320 --> 00:07:19.760
So the draw method actually
ends up in an optimization

00:07:19.760 --> 00:07:22.930
that we implemented
back in Honeycomb

00:07:22.930 --> 00:07:24.680
called Get DisplayList.

00:07:24.680 --> 00:07:27.860
So a DisplayList is a structure
that stores the rendering

00:07:27.860 --> 00:07:29.150
information, right?

00:07:29.150 --> 00:07:32.720
So if you look at the way
the button code is written

00:07:32.720 --> 00:07:35.990
or view code in general,
we call graphics commands

00:07:35.990 --> 00:07:40.220
in Canvas like DrawBackgrounds,
DrawDrawable, DrawLine,

00:07:40.220 --> 00:07:41.430
whatever.

00:07:41.430 --> 00:07:44.450
But these end up as
operations in a DisplayList.

00:07:44.450 --> 00:07:47.780
This is a compact way of
representing those operations,

00:07:47.780 --> 00:07:51.260
as well as the parameters
to the operations.

00:07:51.260 --> 00:07:53.180
So we call Get DisplayList.

00:07:53.180 --> 00:07:55.490
The decor view did
not change, in fact.

00:07:55.490 --> 00:07:57.410
So it's going to say,
well, I didn't change,

00:07:57.410 --> 00:07:59.810
but I can certainly get the
DisplayList for my child.

00:07:59.810 --> 00:08:02.000
And then on all the
way down the tree,

00:08:02.000 --> 00:08:05.720
until it gets to item two,
and it says, oh, I did change.

00:08:05.720 --> 00:08:07.314
When invalidate
was called on me,

00:08:07.314 --> 00:08:09.980
that triggered something so that
I know I need to redraw myself.

00:08:09.980 --> 00:08:11.960
So Get DisplayList
actually ends up

00:08:11.960 --> 00:08:15.500
being a draw call on the
view, where it regenerates

00:08:15.500 --> 00:08:17.120
its own display list.

00:08:17.120 --> 00:08:21.290
So now, it ends up in
this onDraw method.

00:08:21.290 --> 00:08:23.840
That ends up in the operations
in the DisplayList for that.

00:08:23.840 --> 00:08:26.750
The DisplayList consists
of, for this item,

00:08:26.750 --> 00:08:29.180
basically rect
information and text

00:08:29.180 --> 00:08:31.310
information-- pretty basic.

00:08:31.310 --> 00:08:34.130
And then we have the
DisplayList for basically

00:08:34.130 --> 00:08:35.720
the entire hierarchy.

00:08:35.720 --> 00:08:37.169
So it wasn't just
the view itself,

00:08:37.169 --> 00:08:39.080
but we have the View
Hierarchy itself

00:08:39.080 --> 00:08:41.720
is reproduced in this
hierarchy of DisplayLists,

00:08:41.720 --> 00:08:43.350
all the way down.

00:08:43.350 --> 00:08:46.040
So now we have the DisplayList
for the entire tree,

00:08:46.040 --> 00:08:48.350
and that's all that we need
to do on the UI thread.

00:08:48.350 --> 00:08:50.480
Now we need to sync
that information over

00:08:50.480 --> 00:08:52.370
to the render thread,
and the render thread

00:08:52.370 --> 00:08:54.800
is a separate thread that's
actually dealing with the GPU

00:08:54.800 --> 00:08:56.210
side of this operation.

00:08:56.210 --> 00:08:58.700
On the Java side, we
produced all the information.

00:08:58.700 --> 00:09:01.460
On the native side, then,
we actually produce--

00:09:01.460 --> 00:09:04.550
we take that information,
then sync it over to the GPU.

00:09:04.550 --> 00:09:07.610
So we have the sync
operation, where basically we

00:09:07.610 --> 00:09:09.710
copy a handle over there.

00:09:09.710 --> 00:09:12.190
And we also copy some
related information.

00:09:12.190 --> 00:09:14.030
We copy the damage
area, because it's

00:09:14.030 --> 00:09:16.340
important to know that
that item two-- that's

00:09:16.340 --> 00:09:18.650
the only thing that changed
during that frame, which

00:09:18.650 --> 00:09:20.900
means we don't need
to redraw anything

00:09:20.900 --> 00:09:22.327
else outside of that area.

00:09:22.327 --> 00:09:24.410
So we're going to copy
over the clip bounds there,

00:09:24.410 --> 00:09:26.970
so that we know what
needs to be redrawn.

00:09:26.970 --> 00:09:28.940
Now, we're also going
to do some optimization

00:09:28.940 --> 00:09:30.497
stuff like uploading bitmaps.

00:09:30.497 --> 00:09:33.080
So this is a good time to do it
at the beginning of the frame.

00:09:33.080 --> 00:09:34.984
Give them some time
to actually turn those

00:09:34.984 --> 00:09:36.650
into textures along
the way, while we're

00:09:36.650 --> 00:09:37.450
doing the other stuff.

00:09:37.450 --> 00:09:38.900
ROMAIN GUY: It mentions
here that we're uploading

00:09:38.900 --> 00:09:40.210
the non-hardware bitmaps.

00:09:40.210 --> 00:09:42.770
So hardware bitmaps is a new
type of bitmap configuration

00:09:42.770 --> 00:09:44.930
that was added in
Android O. So typically,

00:09:44.930 --> 00:09:47.180
when you have a bitmap, we
have to allocate the memory

00:09:47.180 --> 00:09:48.080
on the Java side.

00:09:48.080 --> 00:09:49.580
And then when it
comes time to draw,

00:09:49.580 --> 00:09:52.460
we have to make a copy
of the bitmap on the GPU.

00:09:52.460 --> 00:09:53.250
This is expensive.

00:09:53.250 --> 00:09:56.030
It takes time, and it doubles
the amount of RAM we're using.

00:09:56.030 --> 00:09:58.745
So using the hardware bitmaps
that are available in Oreo,

00:09:58.745 --> 00:10:01.700
you can keep the Java
side of the equation,

00:10:01.700 --> 00:10:04.310
and you can have a bitmap
that lives only on the GPU.

00:10:04.310 --> 00:10:06.720
So if you're not going to
modify this bitmap ever again,

00:10:06.720 --> 00:10:09.125
this is a really efficient
way, memory-wise,

00:10:09.125 --> 00:10:11.079
to store your bitmaps' memory.

00:10:11.079 --> 00:10:13.370
CHET HAASE: We have mentioned
the render thread before.

00:10:13.370 --> 00:10:15.536
This is something that we
introduced in the Lollipop

00:10:15.536 --> 00:10:16.430
release.

00:10:16.430 --> 00:10:19.232
It is a separate thread
that only talks to the GPU.

00:10:19.232 --> 00:10:19.940
It's native code.

00:10:19.940 --> 00:10:21.523
There is no call
outside to Java code.

00:10:21.523 --> 00:10:24.600
There are certainly no call-outs
out to application code.

00:10:24.600 --> 00:10:26.510
It just talks to the GPU.

00:10:26.510 --> 00:10:28.580
We did this-- so we still
need to do basically

00:10:28.580 --> 00:10:30.621
the same thing we did,
pre-rendered thread, which

00:10:30.621 --> 00:10:32.850
is we produce all the
DisplayList information,

00:10:32.850 --> 00:10:37.220
and then we send that
DisplayList information

00:10:37.220 --> 00:10:38.300
to the GPU.

00:10:38.300 --> 00:10:40.460
So its sort of serial,
but the render thread

00:10:40.460 --> 00:10:44.780
is able to do things
atomically, like the circular

00:10:44.780 --> 00:10:47.900
reveal animations, as well as
the ripple animations, as well

00:10:47.900 --> 00:10:49.940
as vector drawable animations--

00:10:49.940 --> 00:10:52.000
can happen atomically
on the render thread.

00:10:52.000 --> 00:10:53.630
So that something
that can happen

00:10:53.630 --> 00:10:55.210
without stalling the UI thread.

00:10:55.210 --> 00:10:56.750
And in the meantime,
the UI thread

00:10:56.750 --> 00:10:58.940
can be doing other
things while it's idle

00:10:58.940 --> 00:11:02.450
after it syncs, like maybe
some of the idle prefetch

00:11:02.450 --> 00:11:05.380
work for RecyclerView
that was done last year.

00:11:05.380 --> 00:11:07.670
So render thread kicks in.

00:11:07.670 --> 00:11:08.780
We've synced everything.

00:11:08.780 --> 00:11:11.540
We have the DisplayList,
we have the damage area,

00:11:11.540 --> 00:11:14.840
and then we turn the
DisplayList into something

00:11:14.840 --> 00:11:16.880
that we call DLOps--

00:11:16.880 --> 00:11:18.227
display list operations.

00:11:18.227 --> 00:11:20.810
So you can see that we have that
fill operation in the middle.

00:11:20.810 --> 00:11:23.840
That's the thing that
we turned green there.

00:11:23.840 --> 00:11:26.390
And then we have some
optimizations that we perform.

00:11:26.390 --> 00:11:28.724
ROMAIN GUY: So we have various
optimizations we do here.

00:11:28.724 --> 00:11:30.473
So for instance, if
you do Alpha rendering

00:11:30.473 --> 00:11:32.900
by calling set Alpha on the
view or if you set a hardware

00:11:32.900 --> 00:11:36.480
layer on the view, we try to
identify the drawing commands

00:11:36.480 --> 00:11:38.900
that need to be targeted
to those layers,

00:11:38.900 --> 00:11:41.190
and we move them at the
beginning of the frame.

00:11:41.190 --> 00:11:43.640
This avoids state
changes inside the GPU,

00:11:43.640 --> 00:11:45.149
which are extremely expensive.

00:11:45.149 --> 00:11:46.940
So without doing this
kind of optimization,

00:11:46.940 --> 00:11:49.410
you would see horrible,
horrible performance.

00:11:49.410 --> 00:11:51.870
And it's not because the
GPU itself will be slow.

00:11:51.870 --> 00:11:53.730
The GPU would just be
waiting for the CPU

00:11:53.730 --> 00:11:54.950
to give it instructions.

00:11:54.950 --> 00:11:56.450
The other one we're
doing, and we're

00:11:56.450 --> 00:11:58.760
going to show you an
actual practical example,

00:11:58.760 --> 00:12:00.500
is called reordering
and matching.

00:12:00.500 --> 00:12:02.240
We look at all those
operations, and you

00:12:02.240 --> 00:12:04.610
can see in this example,
because we have list items,

00:12:04.610 --> 00:12:06.752
we interleave a lot of
operations that are similar.

00:12:06.752 --> 00:12:08.210
So we're going to
draw a rectangle,

00:12:08.210 --> 00:12:09.560
and then we're
going to draw text,

00:12:09.560 --> 00:12:11.893
and then we're going to draw
a rectangle and text again.

00:12:11.893 --> 00:12:14.150
And again, here, we're
changing the state of the GPU

00:12:14.150 --> 00:12:16.520
several times, but
instead, what we

00:12:16.520 --> 00:12:18.290
can do is if the
commands don't overlap,

00:12:18.290 --> 00:12:19.810
we can draw all the
rectangles together,

00:12:19.810 --> 00:12:21.200
and then we can draw
all the text together.

00:12:21.200 --> 00:12:23.272
So this is part of the
reordering and matching.

00:12:23.272 --> 00:12:24.980
And sometimes, what
we do-- we say, look,

00:12:24.980 --> 00:12:27.260
if we see a bunch
of text that uses

00:12:27.260 --> 00:12:29.270
the same color
and the same font,

00:12:29.270 --> 00:12:31.310
they don't have to be
different draw text calls.

00:12:31.310 --> 00:12:34.040
They can be just a single one
that covers the entire screen.

00:12:34.040 --> 00:12:36.690
CHET HAASE: So you can see
here, the original DLOps

00:12:36.690 --> 00:12:38.834
had a fill operation,
and then it

00:12:38.834 --> 00:12:40.250
wanted to draw
some text, which is

00:12:40.250 --> 00:12:41.750
going to end up
being texture map

00:12:41.750 --> 00:12:44.090
copies from the glyph cache.

00:12:44.090 --> 00:12:46.320
Then it's got a fill
operation, and then

00:12:46.320 --> 00:12:47.450
some more text, and a fill.

00:12:47.450 --> 00:12:49.533
And so we've got all these
operations interleaved.

00:12:49.533 --> 00:12:51.057
So after the
reordering operation,

00:12:51.057 --> 00:12:52.640
then it looks a
little more like this.

00:12:52.640 --> 00:12:55.640
We've got a series of fills and
a series of text operations.

00:12:55.640 --> 00:12:57.350
They can even be
batched together

00:12:57.350 --> 00:13:00.769
to be more optimal,
which we will see here.

00:13:00.769 --> 00:13:02.560
ROMAIN GUY: So this is
an example of Gmail.

00:13:02.560 --> 00:13:05.010
So that was in
the Honeycomb era.

00:13:05.010 --> 00:13:07.269
You can see how here,
we modified the pipeline

00:13:07.269 --> 00:13:09.060
to slow down the
rendering, and you can see

00:13:09.060 --> 00:13:10.620
exactly how Gmail was drawing.

00:13:10.620 --> 00:13:12.570
So we have a lot of
list items, and we just

00:13:12.570 --> 00:13:14.222
draw them in the
exact order that they

00:13:14.222 --> 00:13:16.680
exist in your view hierarchy
and in the order of your code,

00:13:16.680 --> 00:13:17.280
actually.

00:13:17.280 --> 00:13:20.360
All the draw calls that
you make on the Canvas will

00:13:20.360 --> 00:13:21.837
respect that order.

00:13:21.837 --> 00:13:23.920
Unfortunately, like I said,
it's very inefficient.

00:13:23.920 --> 00:13:27.070
So instead, after batching
and merging and reordering,

00:13:27.070 --> 00:13:28.290
we get this.

00:13:28.290 --> 00:13:30.840
You can see, in particular,
that all the stars were

00:13:30.840 --> 00:13:34.470
drawn at the same time, and most
of the text appear all at once.

00:13:34.470 --> 00:13:36.840
What's interesting is we
are drawing all the list

00:13:36.840 --> 00:13:38.526
item backgrounds
one after the other.

00:13:38.526 --> 00:13:39.150
So that's good.

00:13:39.150 --> 00:13:40.110
The reordering worked.

00:13:40.110 --> 00:13:42.650
The batching didn't work, and
it's partly because the list

00:13:42.650 --> 00:13:44.230
items are slightly overlapping.

00:13:44.230 --> 00:13:47.130
So when commands overlap,
we have to draw them one

00:13:47.130 --> 00:13:49.560
after the other to
honor the blending,

00:13:49.560 --> 00:13:52.990
to make sure the Alpha
values are correct.

00:13:52.990 --> 00:13:57.430
And so the effect really
depends on the application.

00:13:57.430 --> 00:13:59.360
If I remember
correctly, in KitKat,

00:13:59.360 --> 00:14:02.830
the settings application was
we could draw the whole screen

00:14:02.830 --> 00:14:05.475
in about six draw calls,
instead of dozens and dozens,

00:14:05.475 --> 00:14:07.120
as seen by the View Hierarchy.

00:14:07.120 --> 00:14:09.320
So this is a very important
optimization for us.

00:14:09.320 --> 00:14:11.820
CHET HAASE: I think this work
at the time on current devices

00:14:11.820 --> 00:14:14.040
saved something like
a millisecond, which

00:14:14.040 --> 00:14:16.740
doesn't sound like much,
unless you realize that we have

00:14:16.740 --> 00:14:18.829
to do everything within 16.

00:14:18.829 --> 00:14:20.370
So it was actually
a huge improvement

00:14:20.370 --> 00:14:22.710
that allowed Gmail to be
less janky, because then it

00:14:22.710 --> 00:14:25.830
wasn't pushed out into
the next frame as often.

00:14:25.830 --> 00:14:27.644
So back to our
explanation of everything.

00:14:27.644 --> 00:14:28.810
Then we have the clipReject.

00:14:28.810 --> 00:14:31.740
So this is where we feed in the
information about the damage

00:14:31.740 --> 00:14:32.520
area, right?

00:14:32.520 --> 00:14:34.807
So we know where item
two was on the screen,

00:14:34.807 --> 00:14:36.390
and we know that we
don't need to draw

00:14:36.390 --> 00:14:37.650
anything outside of that.

00:14:37.650 --> 00:14:40.110
So as we're processing
these DLOps,

00:14:40.110 --> 00:14:41.790
we know that we can
basically throw away

00:14:41.790 --> 00:14:43.875
anything that is drawing
outside of that area.

00:14:43.875 --> 00:14:46.710
In graphics, that's
called a trivial reject.

00:14:46.710 --> 00:14:48.690
So we trivially
reject all the DLOps

00:14:48.690 --> 00:14:50.800
that weren't intersecting
with that area,

00:14:50.800 --> 00:14:52.860
and now all we have
to do is draw a fill

00:14:52.860 --> 00:14:56.510
and some text and a line.

00:14:56.510 --> 00:14:57.980
So we do that.

00:14:57.980 --> 00:15:00.360
In the process of doing
that, we can do a GetBuffer.

00:15:00.360 --> 00:15:02.070
This is usually an
implicit operation.

00:15:02.070 --> 00:15:03.380
We don't request a buffer.

00:15:03.380 --> 00:15:06.440
It's more that as soon as we
start doing GPU operations,

00:15:06.440 --> 00:15:09.440
then the GPU hands us the
buffer-- more particularly,

00:15:09.440 --> 00:15:10.940
SurfaceFlinger hands
us the buffer--

00:15:10.940 --> 00:15:13.280
that we can then put
these commands into.

00:15:13.280 --> 00:15:14.450
Then we issue the commands.

00:15:14.450 --> 00:15:17.630
This is a series of GL commands.

00:15:17.630 --> 00:15:20.270
As you can see on the
slide, it says glCommand.

00:15:20.270 --> 00:15:22.700
Basically, the equivalent of
what we need for whatever--

00:15:22.700 --> 00:15:24.170
doing the fill or the text--

00:15:24.170 --> 00:15:26.660
Bitmap copies lines, whatever.

00:15:26.660 --> 00:15:28.210
And then we swap the buffer.

00:15:28.210 --> 00:15:30.950
So this is us saying, we are
done with all of our rendering

00:15:30.950 --> 00:15:31.650
operations.

00:15:31.650 --> 00:15:34.040
We're ready to display
this frame on the screen.

00:15:34.040 --> 00:15:36.857
It's a request to SurfaceFlinger
to then swap the buffer.

00:15:36.857 --> 00:15:38.690
Basically, we're done
drawing to the buffer.

00:15:38.690 --> 00:15:40.850
You can swap this with
the one that's in front,

00:15:40.850 --> 00:15:43.340
and it'll put it on the screen.

00:15:43.340 --> 00:15:45.044
Meanwhile, in
SurfaceFlinger, then we

00:15:45.044 --> 00:15:46.960
have the composite step,
which Romain is going

00:15:46.960 --> 00:15:48.510
to talk a lot about later.

00:15:48.510 --> 00:15:51.110
But basically, it takes all
of the windows on the screen.

00:15:51.110 --> 00:15:53.630
We see here the navigation
bar, the status bar,

00:15:53.630 --> 00:15:56.690
and the actual content
window for our application.

00:15:56.690 --> 00:15:59.420
It combines all of those
in the hardware compositor,

00:15:59.420 --> 00:16:02.030
puts them on screen,
and then, tada.

00:16:02.030 --> 00:16:04.360
We're done.

00:16:04.360 --> 00:16:06.200
So that was a really
simple example.

00:16:06.200 --> 00:16:08.117
Let's look at a super
complicated example.

00:16:08.117 --> 00:16:09.700
This one is going
to be in two phases.

00:16:09.700 --> 00:16:11.860
One, so we're going
to drag the list up.

00:16:11.860 --> 00:16:14.440
So we're going to drag it,
and then as we drag it,

00:16:14.440 --> 00:16:16.777
we're going to move
the items a little bit.

00:16:16.777 --> 00:16:18.610
And then eventually,
if we keep moving them,

00:16:18.610 --> 00:16:20.193
we're going to have
a new item appear.

00:16:20.193 --> 00:16:22.730
So we're going to look
at two versions of this.

00:16:22.730 --> 00:16:24.470
There's the move only version.

00:16:24.470 --> 00:16:26.800
So as we drag it
up, a new item--

00:16:26.800 --> 00:16:28.180
not a new item appears.

00:16:28.180 --> 00:16:30.350
Everything just shifts
a little bit up.

00:16:30.350 --> 00:16:32.440
So first of all, we need
to process the down.

00:16:32.440 --> 00:16:33.630
So we have a Vsync.

00:16:33.630 --> 00:16:36.220
It says, time to
process input event.

00:16:36.220 --> 00:16:38.950
So we do that, and we
end up in code like this.

00:16:38.950 --> 00:16:40.670
On touch event in
RecyclerView, it

00:16:40.670 --> 00:16:42.670
says, well, there
was a down operation.

00:16:42.670 --> 00:16:45.160
And all it needs
to do is register

00:16:45.160 --> 00:16:46.240
where that down happened.

00:16:46.240 --> 00:16:47.840
It doesn't need to
process anything.

00:16:47.840 --> 00:16:49.090
Nothing changed on the screen.

00:16:49.090 --> 00:16:51.760
We just registered that the
user actually pressed down.

00:16:51.760 --> 00:16:53.975
So we record that for
later, and there's no op.

00:16:53.975 --> 00:16:56.350
We don't do any of the rest
of the stuff we talked about,

00:16:56.350 --> 00:16:58.840
because nothing changed.

00:16:58.840 --> 00:17:02.410
They keep dragging, and then
we end up in similar code.

00:17:02.410 --> 00:17:04.160
So we process input
on the next frame,

00:17:04.160 --> 00:17:05.619
and we say, OK, on touch event.

00:17:05.619 --> 00:17:07.839
Oh, now we know that
they've actually moved,

00:17:07.839 --> 00:17:10.720
and we know how much they moved
because we saved the old X

00:17:10.720 --> 00:17:13.150
and Y. We calculate the delta.

00:17:13.150 --> 00:17:16.240
And now we call this thing
called offset top and bottom.

00:17:16.240 --> 00:17:18.369
Basically, for all the
views on the screen,

00:17:18.369 --> 00:17:22.990
we simply move them in Y. And
offset top and bottom calls

00:17:22.990 --> 00:17:25.134
something-- it's an
invalidation method,

00:17:25.134 --> 00:17:26.300
but it's slightly different.

00:17:26.300 --> 00:17:28.390
It says, invalidateViewProperty.

00:17:28.390 --> 00:17:29.950
This is an optimization
that we put

00:17:29.950 --> 00:17:34.360
in probably Honeycomb
second release or something

00:17:34.360 --> 00:17:36.130
with DisplayList properties.

00:17:36.130 --> 00:17:38.830
So when I talked about
DisplayList earlier,

00:17:38.830 --> 00:17:40.420
there was one nuance
that I left out.

00:17:40.420 --> 00:17:42.253
We have the information
about the operations

00:17:42.253 --> 00:17:44.470
and the parameters for
the graphics operations.

00:17:44.470 --> 00:17:47.020
But we also have the information
about some core display

00:17:47.020 --> 00:17:50.020
properties, which are basically
properties of the view,

00:17:50.020 --> 00:17:53.200
like the translation
property, rotation alpha.

00:17:53.200 --> 00:17:55.810
And these are properties
which we don't need

00:17:55.810 --> 00:17:57.520
to rerender the view to change.

00:17:57.520 --> 00:18:00.560
We can simply change them in the
DisplayList structure, itself,

00:18:00.560 --> 00:18:02.980
and then they get picked
up at GPU issue time.

00:18:02.980 --> 00:18:06.260
So it's a very fast
operation for us to do that.

00:18:06.260 --> 00:18:07.690
So instead of
invalidating a view

00:18:07.690 --> 00:18:09.880
and redrawing everything
in that view all

00:18:09.880 --> 00:18:11.890
we do is say, change
the translation

00:18:11.890 --> 00:18:13.370
property in this view.

00:18:13.370 --> 00:18:16.420
So the way that happens is we
call invalidateViewProperty.

00:18:16.420 --> 00:18:18.100
That propagates all
the way up the tree,

00:18:18.100 --> 00:18:20.950
because we still need to know,
at the top layer, what happens,

00:18:20.950 --> 00:18:22.480
but it's a much
more optimal step.

00:18:22.480 --> 00:18:25.150
So this ends up in
scheduleTraversals,

00:18:25.150 --> 00:18:26.420
as it did before.

00:18:26.420 --> 00:18:28.860
In the draw, it ends up
in performTraversals,

00:18:28.860 --> 00:18:32.110
but PerformDraw can do a
much simpler version of this

00:18:32.110 --> 00:18:34.540
because the DisplayList
didn't actually change.

00:18:34.540 --> 00:18:36.670
All we did was change
DisplayList properties

00:18:36.670 --> 00:18:37.660
inside of it.

00:18:37.660 --> 00:18:39.850
So we can immediately
sync that information over

00:18:39.850 --> 00:18:41.230
to the render thread.

00:18:41.230 --> 00:18:44.830
We can then execute that, turn
that into DisplayList ops,

00:18:44.830 --> 00:18:45.580
get the buffer.

00:18:45.580 --> 00:18:47.925
Basically, everything
is as before.

00:18:47.925 --> 00:18:49.300
Let's go through
the second phase

00:18:49.300 --> 00:18:51.580
of that super
complicated example.

00:18:51.580 --> 00:18:54.250
User keeps dragging,
and as they drag,

00:18:54.250 --> 00:18:56.530
a new item appears
on the bottom.

00:18:56.530 --> 00:18:58.660
So Vsync, we process the input.

00:18:58.660 --> 00:19:00.940
We end up in a method
something like this.

00:19:00.940 --> 00:19:02.309
We know that they've moved.

00:19:02.309 --> 00:19:04.600
Oh, but that means that we
need to trigger the creation

00:19:04.600 --> 00:19:06.880
and the bind of
that new item there.

00:19:06.880 --> 00:19:09.070
That ends up in code like
this, where we actually

00:19:09.070 --> 00:19:10.660
add a view to the parent.

00:19:10.660 --> 00:19:13.570
So the RecyclerView is
going to get a new view,

00:19:13.570 --> 00:19:15.730
and it's going to
call RequestLayout.

00:19:15.730 --> 00:19:18.640
So RequestLayout is kind
of like invalidation,

00:19:18.640 --> 00:19:20.680
but instead of saying,
I need to be redrawn,

00:19:20.680 --> 00:19:23.620
it says, I need to be
remeasured and relaid out.

00:19:23.620 --> 00:19:25.670
And that could side
affect everybody there,

00:19:25.670 --> 00:19:28.000
so we basically propagate
a RequestLayout all the way

00:19:28.000 --> 00:19:30.260
up the tree, like invalidation.

00:19:30.260 --> 00:19:32.740
And then we do measure and
layout on the entire tree, just

00:19:32.740 --> 00:19:34.120
to see what changed there.

00:19:34.120 --> 00:19:36.760
So RequestLayout
happens on the parent,

00:19:36.760 --> 00:19:40.450
and then that propagates
all the way up.

00:19:40.450 --> 00:19:43.754
And that ends up, again, in
scheduleTraversals, our friend.

00:19:43.754 --> 00:19:45.670
And then performTraversals--
we're not talking

00:19:45.670 --> 00:19:46.720
about the draw stuff now.

00:19:46.720 --> 00:19:48.136
We're going to do
a performMeasure

00:19:48.136 --> 00:19:49.300
and a performLayout.

00:19:49.300 --> 00:19:51.970
Measure is basically
asking all of the views

00:19:51.970 --> 00:19:53.950
how big they would like to be.

00:19:53.950 --> 00:19:55.030
It's a request.

00:19:55.030 --> 00:19:57.860
And then layout says, this is
how big you're going to be,

00:19:57.860 --> 00:19:59.860
and this is where you're
going to be positioned.

00:19:59.860 --> 00:20:02.470
It's a negotiation between the
views and all of their parents,

00:20:02.470 --> 00:20:04.930
according to all the
constraints in the system.

00:20:04.930 --> 00:20:07.390
So we do a performMeasure.

00:20:07.390 --> 00:20:09.100
That basically calls
measure at the top,

00:20:09.100 --> 00:20:11.260
and that propagates
all the way down.

00:20:11.260 --> 00:20:13.120
And then we have
all the information

00:20:13.120 --> 00:20:15.730
about how big all of
the views want to be,

00:20:15.730 --> 00:20:18.190
and that is good enough for
us to calculate the layout

00:20:18.190 --> 00:20:18.760
information.

00:20:18.760 --> 00:20:21.440
Then we propagate layout
all the way down the tree.

00:20:21.440 --> 00:20:23.950
And once that happens on
the item and the parent that

00:20:23.950 --> 00:20:26.364
changed, then we actually
lay out that item,

00:20:26.364 --> 00:20:27.280
and we're ready to go.

00:20:27.280 --> 00:20:29.740
Now, we can actually
draw things,

00:20:29.740 --> 00:20:32.300
and everything is as before.

00:20:32.300 --> 00:20:34.750
So the nuance here was
just the layout side,

00:20:34.750 --> 00:20:38.680
except an important nuance
is we're talking about all

00:20:38.680 --> 00:20:41.500
of this RequestLayout and
measure and layout happening

00:20:41.500 --> 00:20:43.690
for this RecyclerView situation.

00:20:43.690 --> 00:20:47.020
However, RecyclerView
optimizes this.

00:20:47.020 --> 00:20:50.050
It knows enough about its
own parent and its children

00:20:50.050 --> 00:20:52.270
that it actually can
just offset the views.

00:20:52.270 --> 00:20:53.920
Instead of doing
the RequestLayout,

00:20:53.920 --> 00:20:56.003
it can actually just move
the views out of the way

00:20:56.003 --> 00:20:57.040
and create the new item.

00:20:57.040 --> 00:20:58.840
So optimization
for RecyclerView,

00:20:58.840 --> 00:21:01.127
as well as the older list view.

00:21:01.127 --> 00:21:02.710
ROMAIN GUY: So now
we're going to talk

00:21:02.710 --> 00:21:05.130
about how SurfaceFlinger,
our window compositor,

00:21:05.130 --> 00:21:07.604
composites all the
windows on the screen.

00:21:07.604 --> 00:21:09.270
This is interesting,
well, first of all,

00:21:09.270 --> 00:21:10.800
because it's always
interesting to learn something

00:21:10.800 --> 00:21:13.320
new about technology, but also
because you will understand

00:21:13.320 --> 00:21:15.120
some concepts that
are behind some

00:21:15.120 --> 00:21:18.750
of the public APIs like
Surface, SurfaceTexture,

00:21:18.750 --> 00:21:22.390
SurfaceView, or the MediaCodec.

00:21:22.390 --> 00:21:25.020
So before we can
understand composition,

00:21:25.020 --> 00:21:28.050
we have to understand a very
important concept on Android,

00:21:28.050 --> 00:21:29.310
called the buffer queue.

00:21:29.310 --> 00:21:31.350
So the buffer queue,
as the name suggests,

00:21:31.350 --> 00:21:35.220
is just a queue of buffers
where our graphics buffers live.

00:21:35.220 --> 00:21:37.624
Typically, we're going to
have one to three buffers.

00:21:37.624 --> 00:21:39.290
There are different
options, internally,

00:21:39.290 --> 00:21:40.950
where when we set
up a buffer queue,

00:21:40.950 --> 00:21:43.680
we can request how
many buffers we want.

00:21:43.680 --> 00:21:47.310
And very importantly, a buffer
queue has two endpoints.

00:21:47.310 --> 00:21:50.070
We have the producer and
we have the consumer.

00:21:50.070 --> 00:21:52.300
So typically, the way
we use a buffer queue--

00:21:52.300 --> 00:21:54.940
the producer calls a
method called dequeueBuffer

00:21:54.940 --> 00:21:55.720
on the queue.

00:21:55.720 --> 00:21:57.200
It grabs a buffer
from the queue.

00:21:57.200 --> 00:21:58.560
Now it owns it.

00:21:58.560 --> 00:22:00.770
It can do any kind of rendering.

00:22:00.770 --> 00:22:02.600
It can be sending the
pixel data directly,

00:22:02.600 --> 00:22:05.849
it can be using OpenGL, it
can be using the Canvas.

00:22:05.849 --> 00:22:06.890
It doesn't really matter.

00:22:06.890 --> 00:22:09.150
And when you use OpenGL,
this is basically

00:22:09.150 --> 00:22:11.700
what happens when you call
sled buffers at the end.

00:22:11.700 --> 00:22:14.200
That's when we're producing
the content inside the buffer.

00:22:14.200 --> 00:22:16.860
So when the producer is
done producing the content,

00:22:16.860 --> 00:22:20.010
it calls queue buffer,
and gives the buffer back

00:22:20.010 --> 00:22:21.700
to the buffer queue.

00:22:21.700 --> 00:22:24.080
Now, a consumer can
grab the next buffer

00:22:24.080 --> 00:22:26.890
in the queue using acquire.

00:22:26.890 --> 00:22:28.920
So it calls acquire
buffer, it takes

00:22:28.920 --> 00:22:30.870
the first available
buffer in the queue,

00:22:30.870 --> 00:22:34.640
it does whatever it has to do
with it, and when it's done,

00:22:34.640 --> 00:22:38.007
it puts it back by
calling release.

00:22:38.007 --> 00:22:39.340
So it's a pretty simple concept.

00:22:39.340 --> 00:22:41.260
Of course, if you were
to look at the code--

00:22:41.260 --> 00:22:42.801
all the header files
and all the code

00:22:42.801 --> 00:22:45.220
involved-- it's pretty
complicated, in part

00:22:45.220 --> 00:22:47.290
because the two endpoints
of a buffer queue

00:22:47.290 --> 00:22:49.000
can live in different processes.

00:22:49.000 --> 00:22:50.410
And this is exactly
what happens.

00:22:50.410 --> 00:22:53.000
This is how our surface
compositor works.

00:22:53.000 --> 00:22:55.150
So when you create a
window in the system,

00:22:55.150 --> 00:22:57.540
you have the Window Manager
and you have SurfaceFlinger.

00:22:57.540 --> 00:22:59.660
So the Window Manager
is effectively

00:22:59.660 --> 00:23:02.350
the producer in this
scenario, and SurfaceFlinger

00:23:02.350 --> 00:23:03.639
is our consumer.

00:23:03.639 --> 00:23:05.680
So when you call Window
Manager in that addView--

00:23:05.680 --> 00:23:07.870
and this is what's done
automatically for you when

00:23:07.870 --> 00:23:10.510
you create a dialogue, when
you create a toast, I believe,

00:23:10.510 --> 00:23:12.317
when you create an activity--

00:23:12.317 --> 00:23:13.900
internally, we create
a window object.

00:23:13.900 --> 00:23:17.650
That window object has a sibling
on the SurfaceFlinger side,

00:23:17.650 --> 00:23:18.980
called a Layer.

00:23:18.980 --> 00:23:20.560
The names can be
a little confusing

00:23:20.560 --> 00:23:23.800
because in graphics, we have to
deal with buffers and queues,

00:23:23.800 --> 00:23:27.510
and that's all we do, and
we quickly run out of names.

00:23:27.510 --> 00:23:28.500
And the graphics team--

00:23:28.500 --> 00:23:30.380
I thought of-- so
that's why we have

00:23:30.380 --> 00:23:32.830
Surface and SurfaceTextures
and buffer queue and layer

00:23:32.830 --> 00:23:33.710
and window.

00:23:33.710 --> 00:23:34.210
Yeah.

00:23:34.210 --> 00:23:35.390
So it's a little bit messy.

00:23:35.390 --> 00:23:37.010
So we have a layer
in SurfaceFlinger.

00:23:37.010 --> 00:23:39.640
It's basically a window.

00:23:39.640 --> 00:23:42.730
And the layer is the
component in the system

00:23:42.730 --> 00:23:46.120
that creates and owns the buffer
queue for your application.

00:23:46.120 --> 00:23:47.650
So it creates a
buffer queue, and we

00:23:47.650 --> 00:23:50.680
have a way to send the
endpoint to your application

00:23:50.680 --> 00:23:52.000
by creating a Surface.

00:23:52.000 --> 00:23:54.730
So whenever you see a
Surface in one of our APIs,

00:23:54.730 --> 00:23:57.740
you really have the producer
endpoint of a buffer queue

00:23:57.740 --> 00:24:00.610
that lives somewhere else in the
system, either in your process

00:24:00.610 --> 00:24:02.020
or in some other process.

00:24:02.020 --> 00:24:05.090
Most of the time, it's going
to be inside SurfaceFlinger.

00:24:05.090 --> 00:24:08.290
So now, the typical
use case for you,

00:24:08.290 --> 00:24:10.400
as an application
developer, you're

00:24:10.400 --> 00:24:13.067
going to deal with
the Surface API

00:24:13.067 --> 00:24:14.400
when you create the SurfaceView.

00:24:14.400 --> 00:24:17.690
So the way SurfaceView works is
your window as its own Surface

00:24:17.690 --> 00:24:18.800
that we see here.

00:24:18.800 --> 00:24:21.890
Then we cut a hole through
that Surface, effectively.

00:24:21.890 --> 00:24:24.230
And we ask the Window
Manager and SurfaceFlinger

00:24:24.230 --> 00:24:25.700
to create a second Surface.

00:24:25.700 --> 00:24:28.310
And we just slide it
underneath, and we

00:24:28.310 --> 00:24:30.260
pretend that they are
part of the same window.

00:24:30.260 --> 00:24:31.924
But they are not.

00:24:31.924 --> 00:24:33.287
They are two different Surfaces.

00:24:33.287 --> 00:24:34.870
They have two different
buffer queues,

00:24:34.870 --> 00:24:37.622
and they can be completely
independent from one another.

00:24:37.622 --> 00:24:39.080
So if you use a
SurfaceView, you're

00:24:39.080 --> 00:24:42.950
probably going to use OpenGL
or Vulcan or a media player

00:24:42.950 --> 00:24:44.400
to generate content.

00:24:44.400 --> 00:24:46.730
So for instance, in this
case, we have OpenGL ES.

00:24:46.730 --> 00:24:48.637
It's going to dequeueBuffer.

00:24:48.637 --> 00:24:49.970
It's going to do some rendering.

00:24:49.970 --> 00:24:52.370
It's going to queue the
buffer back into the Surface,

00:24:52.370 --> 00:24:56.035
and therefore, into
the buffer queue.

00:24:56.035 --> 00:25:03.070
If you use a Surface texture,
your consumer will be OpenGL.

00:25:03.070 --> 00:25:06.490
So you create a SurfaceTexture
by giving it a texture ID.

00:25:06.490 --> 00:25:09.850
In that case, the
SurfaceTexture creates and owns

00:25:09.850 --> 00:25:13.670
the buffer queue, so that will
often be in your own process.

00:25:13.670 --> 00:25:16.270
Then you have to pass
that SurfaceTexture

00:25:16.270 --> 00:25:18.070
to some producer,
and to do this,

00:25:18.070 --> 00:25:20.440
you create the
endpoints yourself,

00:25:20.440 --> 00:25:21.560
by creating a Surface.

00:25:21.560 --> 00:25:24.740
There's a constructor of Surface
that takes a SurfaceTexture.

00:25:24.740 --> 00:25:27.437
So you create your
Surface, you send it

00:25:27.437 --> 00:25:30.100
to some other
application, and then

00:25:30.100 --> 00:25:32.350
when your OpenGL code
is ready to render,

00:25:32.350 --> 00:25:35.620
it calls acquire to get a
buffer from the buffer queue.

00:25:35.620 --> 00:25:36.700
It does its rendering.

00:25:36.700 --> 00:25:40.330
It's going to, itself, produce
a buffer inside another queue,

00:25:40.330 --> 00:25:43.660
and then when it's done,
it can call release.

00:25:43.660 --> 00:25:47.410
TextureView is the widget
that's part of a UI toolkit

00:25:47.410 --> 00:25:50.230
that you can use to benefit
from SurfaceTexture.

00:25:50.230 --> 00:25:52.110
In that particular
case, the render thread

00:25:52.110 --> 00:25:55.360
that we talked about is the
consumer of the SurfaceTexture,

00:25:55.360 --> 00:25:58.540
and you're still responsible
for getting the Surface

00:25:58.540 --> 00:26:00.100
from the TextureView
and giving it

00:26:00.100 --> 00:26:02.970
to a producer of your choosing.

00:26:02.970 --> 00:26:05.150
You can think of it as a
fancy image, effectively.

00:26:05.150 --> 00:26:07.630
It's an image view that you
can update really efficiently,

00:26:07.630 --> 00:26:11.230
using hardware acceleration.

00:26:11.230 --> 00:26:13.300
In recent years--
we used to tell you

00:26:13.300 --> 00:26:16.120
that TextureView was
the solution, instead

00:26:16.120 --> 00:26:20.300
of SurfaceView, when you wanted
to integrate a video or OpenGL

00:26:20.300 --> 00:26:22.180
rendering inside a
complex application.

00:26:22.180 --> 00:26:24.610
For instance, if you had
the ListView or CountView

00:26:24.610 --> 00:26:25.890
or anything that was animated.

00:26:25.890 --> 00:26:28.223
SurfaceView, because it's
made of two different windows,

00:26:28.223 --> 00:26:29.920
was naturally
efficient for that,

00:26:29.920 --> 00:26:32.470
and it was not synchronized
with the rendering

00:26:32.470 --> 00:26:33.790
of your own application.

00:26:33.790 --> 00:26:36.136
This has been fixed in the
recent versions of Android.

00:26:36.136 --> 00:26:38.260
So most of the time, on
recent versions of Android,

00:26:38.260 --> 00:26:40.593
you should use a SurfaceView
instead of the TextureView.

00:26:40.593 --> 00:26:42.670
Use the TextureView
only when you have to.

00:26:42.670 --> 00:26:44.740
Maybe it's sandwiched
between your other views,

00:26:44.740 --> 00:26:47.350
or use an animation that's not
supported by the SurfaceView.

00:26:47.350 --> 00:26:49.141
CHET HAASE: I think
that was the O release.

00:26:49.141 --> 00:26:50.705
ROMAIN GUY: That
was the O-- maybe N.

00:26:50.705 --> 00:26:50.970
CHET HAASE: Maybe.

00:26:50.970 --> 00:26:51.570
ROMAIN GUY: One of the two.

00:26:51.570 --> 00:26:52.795
You have to test.

00:26:52.795 --> 00:26:54.337
CHET HAASE: That's
why we say recent.

00:26:54.337 --> 00:26:56.503
ROMAIN GUY: And here's a
list of different producers

00:26:56.503 --> 00:26:58.070
and consumers in the platform.

00:26:58.070 --> 00:27:00.110
So we looked at SurfaceView
and SurfaceTexture.

00:27:00.110 --> 00:27:02.190
OpenGL ES is a producer.

00:27:02.190 --> 00:27:03.740
It can also be a consumer.

00:27:03.740 --> 00:27:06.850
So remember when Chet was
saying that in that lifecycle

00:27:06.850 --> 00:27:09.290
of a frame, at some
point, we get a buffer.

00:27:09.290 --> 00:27:12.000
That's when we call
dequeueBuffer from the render

00:27:12.000 --> 00:27:13.990
thread, and this
is done, typically,

00:27:13.990 --> 00:27:15.630
when we do the first draw call.

00:27:15.630 --> 00:27:17.590
And at the end, when
we call eglSwapBuffer

00:27:17.590 --> 00:27:20.230
to tell the driver that
we're done with our frame,

00:27:20.230 --> 00:27:22.150
it will actually
produce the frame

00:27:22.150 --> 00:27:23.782
and put it back in
the buffer queue.

00:27:23.782 --> 00:27:25.990
You can also use things like
Vulcan, the MediaPlayer,

00:27:25.990 --> 00:27:26.700
and MediaCodec.

00:27:26.700 --> 00:27:29.370
And we have many, many more
throughout the platform.

00:27:29.370 --> 00:27:31.150
Now, the actual composition.

00:27:31.150 --> 00:27:32.620
So we have created
multiple windows

00:27:32.620 --> 00:27:34.550
that each have their own layer.

00:27:34.550 --> 00:27:37.270
SurfaceFlinger knows
about all those layers,

00:27:37.270 --> 00:27:39.640
and to talk to the display,
SurfaceFlinger actually

00:27:39.640 --> 00:27:43.300
talks to something called
the Hardware Composer.

00:27:43.300 --> 00:27:46.810
Hardware Composer is a
hardware abstraction layer

00:27:46.810 --> 00:27:49.670
that we use because we
want to avoid using the GPU

00:27:49.670 --> 00:27:52.027
and we need to composite
all those windows on screen.

00:27:52.027 --> 00:27:53.610
One of the reasons
is to save battery.

00:27:53.610 --> 00:27:55.068
It's more power
efficient that way.

00:27:55.068 --> 00:27:57.610
But it's also to make sure that
your application has access

00:27:57.610 --> 00:27:59.800
to basically all the
capabilities of the GPU.

00:27:59.800 --> 00:28:01.330
We don't take it away from you.

00:28:01.330 --> 00:28:03.210
And in the past,
you may have heard

00:28:03.210 --> 00:28:05.230
that you should limit
the number of windows

00:28:05.230 --> 00:28:06.380
you put on the screen.

00:28:06.380 --> 00:28:08.306
And you'll see why
in a few slides.

00:28:08.306 --> 00:28:09.680
So we have the
Hardware Composer.

00:28:09.680 --> 00:28:11.890
It's effectively a
block of hardware

00:28:11.890 --> 00:28:14.320
that's really fast at
taking multiple bitmaps

00:28:14.320 --> 00:28:17.710
and composing them
together on screen.

00:28:17.710 --> 00:28:19.020
And we just talked about this.

00:28:19.020 --> 00:28:21.186
So the way it actually
works-- the Hardware Composer

00:28:21.186 --> 00:28:22.847
is really a kind of a protocol.

00:28:22.847 --> 00:28:25.180
Here, I'm going to describe
the older Hardware Composer.

00:28:25.180 --> 00:28:28.110
It's called Hardware Composer
1 or Hardware Composer 0.

00:28:28.110 --> 00:28:29.110
I'm always confused now.

00:28:29.110 --> 00:28:30.700
We use one called the
Hardware Composer 2,

00:28:30.700 --> 00:28:32.430
but it's much more
complicated so I'm not

00:28:32.430 --> 00:28:34.060
going to describe it here.

00:28:34.060 --> 00:28:36.710
But the gist of it is it
basically works the same way.

00:28:36.710 --> 00:28:38.780
So SurfaceFlinger has
a bunch of layers,

00:28:38.780 --> 00:28:41.530
and we're going to call prepare
on the Hardware Composer.

00:28:41.530 --> 00:28:45.040
And we're going to send older
layers to the Hardware Composer

00:28:45.040 --> 00:28:48.280
and ask it to tell us what it
wants to do with every layer.

00:28:48.280 --> 00:28:51.430
Every Hardware Composer
is a proprietary piece

00:28:51.430 --> 00:28:54.400
of hardware in the phone
or tablet you're using,

00:28:54.400 --> 00:28:56.044
and there is no way
that we can write

00:28:56.044 --> 00:28:58.210
the drivers for all the
different Hardware Composers

00:28:58.210 --> 00:28:59.152
out there.

00:28:59.152 --> 00:29:00.610
So instead, the
Hardware Composer's

00:29:00.610 --> 00:29:01.880
going to tell us
what he wants to do.

00:29:01.880 --> 00:29:03.280
So in this case,
we have a layer.

00:29:03.280 --> 00:29:05.260
The Hardware Composer
replies, overlay.

00:29:05.260 --> 00:29:08.320
That means the Hardware Composer
understands the pixel format

00:29:08.320 --> 00:29:11.020
of that window and tells
us that it can handle it

00:29:11.020 --> 00:29:13.362
and is going to do the
composition for that window.

00:29:13.362 --> 00:29:14.070
So we keep going.

00:29:14.070 --> 00:29:15.944
It's telling us overlay
for the second layer.

00:29:15.944 --> 00:29:18.664
It's telling us overlay
for the third layer.

00:29:18.664 --> 00:29:19.330
So that's great.

00:29:19.330 --> 00:29:21.663
That means all the composition
can be done automatically

00:29:21.663 --> 00:29:24.700
for us on our behalf in
a very efficient way.

00:29:24.700 --> 00:29:27.700
So now, all our leaders
are matched to overlays.

00:29:27.700 --> 00:29:28.714
We call set.

00:29:28.714 --> 00:29:31.130
We send all the layers to the
hardware composer, this time

00:29:31.130 --> 00:29:33.490
for actual composition,
and the hardware composer

00:29:33.490 --> 00:29:35.462
sends everything to the screen.

00:29:35.462 --> 00:29:37.647
Now a more complex example.

00:29:37.647 --> 00:29:38.980
So we have the number of layers.

00:29:38.980 --> 00:29:40.650
We call prepare.

00:29:40.650 --> 00:29:42.600
For the first one,
everything goes fine.

00:29:42.600 --> 00:29:44.100
The hardware composer
says, overlay.

00:29:44.100 --> 00:29:45.420
It can handle it.

00:29:45.420 --> 00:29:47.230
But for some reason,
for the next one,

00:29:47.230 --> 00:29:48.510
it says, frame buffer.

00:29:48.510 --> 00:29:51.314
So that can happen when you're
using a pixel format that's not

00:29:51.314 --> 00:29:52.980
supported, or it could
be because you're

00:29:52.980 --> 00:29:56.010
using a rotation, and the
hardware composer doesn't know

00:29:56.010 --> 00:29:57.690
how to handle
rotation or we have

00:29:57.690 --> 00:30:01.680
too many layers on the screen,
or any number of reasons

00:30:01.680 --> 00:30:03.680
that are specific to
that hardware composer.

00:30:03.680 --> 00:30:06.150
CHET HAASE: This was much
more common in devices

00:30:06.150 --> 00:30:08.540
probably three to four
or longer years ago.

00:30:08.540 --> 00:30:09.289
ROMAIN GUY: Right.

00:30:09.289 --> 00:30:12.090
We used to have about
four hardware layers

00:30:12.090 --> 00:30:13.180
that you could use.

00:30:13.180 --> 00:30:13.710
That's four.

00:30:13.710 --> 00:30:14.100
That's five.

00:30:14.100 --> 00:30:14.600
That's four.

00:30:14.600 --> 00:30:17.562
So we used to have
four, and on Pixel 2,

00:30:17.562 --> 00:30:19.020
without going into
too much detail,

00:30:19.020 --> 00:30:20.940
you have basically seven.

00:30:20.940 --> 00:30:22.840
So it's much better
than it used to be.

00:30:22.840 --> 00:30:26.310
But if you have a Pixel 2 XL,
we use two of those layers

00:30:26.310 --> 00:30:27.860
to draw the rounded corners.

00:30:27.860 --> 00:30:30.537
So you don't really have
seven; you have five.

00:30:30.537 --> 00:30:32.620
It's actually more six,
because they can be merged

00:30:32.620 --> 00:30:33.330
by the Hardware Composer.

00:30:33.330 --> 00:30:35.760
Anyway, lots of details that
can be really complicated.

00:30:35.760 --> 00:30:37.080
You don't need to know
about all those details.

00:30:37.080 --> 00:30:38.824
Anyway, in this case,
we have one layer

00:30:38.824 --> 00:30:40.740
that can go directly to
the Hardware Composer,

00:30:40.740 --> 00:30:44.005
but we have two layers that
have been marked frame buffer.

00:30:44.005 --> 00:30:46.924
And that's where the
hard part starts for us,

00:30:46.924 --> 00:30:49.590
because when we have layers that
are not handled by the Hardware

00:30:49.590 --> 00:30:53.310
Composer, we need to use the
GPU to composite them ourselves.

00:30:53.310 --> 00:30:55.860
So SurfaceFlinger has to
be able to do everything

00:30:55.860 --> 00:30:57.294
that the hardware can do.

00:30:57.294 --> 00:30:59.460
And in that situation, we
need to create, basically,

00:30:59.460 --> 00:31:00.660
a scratch buffer--

00:31:00.660 --> 00:31:03.510
another layer-- in a format that
we know the Hardware Composer

00:31:03.510 --> 00:31:05.070
can accept.

00:31:05.070 --> 00:31:07.260
And then we use
custom OpenGL code

00:31:07.260 --> 00:31:10.500
to do the composition
ourselves of those two layers.

00:31:10.500 --> 00:31:12.240
So then, once we're
done with that part,

00:31:12.240 --> 00:31:13.937
we're left with only
two layers, and we

00:31:13.937 --> 00:31:16.020
know that those can sent
to the Hardware Composer.

00:31:16.020 --> 00:31:17.790
So that's what we do.

00:31:17.790 --> 00:31:21.750
We call set, and then
they show up on screen.

00:31:21.750 --> 00:31:23.730
CHET HAASE: So if
you're curious sometime,

00:31:23.730 --> 00:31:29.030
you can run this command, adb
shell dumpsys SurfaceFlinger.

00:31:29.030 --> 00:31:31.710
ROMAIN GUY: Capital
S, capital F.

00:31:31.710 --> 00:31:32.850
CHET HAASE: Very important.

00:31:32.850 --> 00:31:35.819
And it'll spit out way, way
more information than you want.

00:31:35.819 --> 00:31:37.860
But one of the things that
it's going to show you

00:31:37.860 --> 00:31:41.040
is a table of the
windows on the screen

00:31:41.040 --> 00:31:43.310
and whether they are
currently represented

00:31:43.310 --> 00:31:44.767
as overlays or frame buffer.

00:31:44.767 --> 00:31:47.100
ROMAIN GUY: Although you have
to run this command pretty

00:31:47.100 --> 00:31:49.860
quickly because there are tons
of optimizations internally.

00:31:49.860 --> 00:31:54.361
So what can happen
sometimes is if layers

00:31:54.361 --> 00:31:55.860
have been on the
screen for a while,

00:31:55.860 --> 00:31:57.720
and we know they
are not changing,

00:31:57.720 --> 00:31:59.820
their Hardware Composer
might be collapsing them

00:31:59.820 --> 00:32:01.780
into a single layer
until they change again.

00:32:01.780 --> 00:32:04.200
So the output of that command
is sometimes a little bit

00:32:04.200 --> 00:32:06.283
misleading, because you
might be seeing the result

00:32:06.283 --> 00:32:08.020
of optimizations based on time.

00:32:08.020 --> 00:32:09.976
So the best thing to do
is usually to run this

00:32:09.976 --> 00:32:11.850
when you're running an
animation or something

00:32:11.850 --> 00:32:13.260
is changing on screen.

00:32:13.260 --> 00:32:16.180
That's going to be the most
valuable information for you.

00:32:16.180 --> 00:32:19.230
So a few other things that
we haven't talked about.

00:32:19.230 --> 00:32:23.460
We used to tell you to use the
variant of invalidate that text

00:32:23.460 --> 00:32:24.140
in rectangles.

00:32:24.140 --> 00:32:26.580
So you could invalidate
only part of your view

00:32:26.580 --> 00:32:29.070
that you knew needed
to be repainted.

00:32:29.070 --> 00:32:31.920
That was particularly important
with older Android devices,

00:32:31.920 --> 00:32:33.750
because bandwidth was
extremely limited.

00:32:33.750 --> 00:32:35.250
We were using
software rendering.

00:32:35.250 --> 00:32:37.950
And even in the early days
of GPU rendering for us,

00:32:37.950 --> 00:32:40.860
we were pretty easily
maxing out the GPU.

00:32:40.860 --> 00:32:43.470
So those were really
important savings.

00:32:43.470 --> 00:32:45.685
You don't need to
do this any more,

00:32:45.685 --> 00:32:47.310
and even on recent
versions of Android,

00:32:47.310 --> 00:32:49.530
before this was
deprecated, it was actually

00:32:49.530 --> 00:32:50.680
ignored by the system.

00:32:50.680 --> 00:32:53.820
Now what happens, every time
you go invalidate or invalidate

00:32:53.820 --> 00:32:55.920
with a rectangle on the
view, the render thread's

00:32:55.920 --> 00:32:57.530
going to rerender
that whole view

00:32:57.530 --> 00:32:59.030
or recompute that
sole damaged area.

00:32:59.030 --> 00:33:00.520
You don't have to
worry about it.

00:33:00.520 --> 00:33:02.436
And one of the reasons
we're getting rid of it

00:33:02.436 --> 00:33:05.696
is not only is it not that
necessary anymore for savings,

00:33:05.696 --> 00:33:07.320
but it's also because
it's error-prone.

00:33:07.320 --> 00:33:10.350
And it's really easy to have
an off-by-one error or rounding

00:33:10.350 --> 00:33:12.420
error and to get
artifacts on screen.

00:33:12.420 --> 00:33:13.950
And Chet and I
can attest to that

00:33:13.950 --> 00:33:16.770
because we fixed
so many bugs linked

00:33:16.770 --> 00:33:17.970
to the use of those APIs.

00:33:17.970 --> 00:33:20.351
And the framework itself
still has bugs, I believe,

00:33:20.351 --> 00:33:20.850
around that.

00:33:20.850 --> 00:33:23.072
So now, you don't have
to worry about it.

00:33:23.072 --> 00:33:26.070
RecyclerView is now
able to do prefetching

00:33:26.070 --> 00:33:27.997
of items ahead of time.

00:33:27.997 --> 00:33:29.830
CHET HAASE: Yeah, we
mentioned this earlier.

00:33:29.830 --> 00:33:31.913
This is one of the wins
that we're now getting out

00:33:31.913 --> 00:33:34.340
of having a separate render
thread, because now, well,

00:33:34.340 --> 00:33:35.600
there's idle time.

00:33:35.600 --> 00:33:38.160
The UI thread was done with
its work after its synced.

00:33:38.160 --> 00:33:40.590
Well, it can use that
idle time productively

00:33:40.590 --> 00:33:43.050
for doing other things
like fetching things

00:33:43.050 --> 00:33:45.862
that it knows it might need
in the next few frames.

00:33:45.862 --> 00:33:46.630
ROMAIN GUY: For
composition, internally,

00:33:46.630 --> 00:33:48.296
we have a concept of
the actual display.

00:33:48.296 --> 00:33:49.544
This is an API you can use.

00:33:49.544 --> 00:33:51.960
For instance, that's what we
use when we take a screenshot

00:33:51.960 --> 00:33:55.530
or when we record a video
or when we do casting--

00:33:55.530 --> 00:33:57.060
Chromecasting, for instance.

00:33:57.060 --> 00:33:59.580
What we're effectively doing
is asking SurfaceFlinger

00:33:59.580 --> 00:34:02.970
to perform a composition, but
not to display directly-- just

00:34:02.970 --> 00:34:04.040
into another surface.

00:34:04.040 --> 00:34:06.180
So it's another way of
producing a surface.

00:34:06.180 --> 00:34:09.870
If you're interested, there's
an excellent sample application

00:34:09.870 --> 00:34:12.260
called Graphika with a
K available on GitHub.

00:34:12.260 --> 00:34:14.010
It was written by a
member of the graphics

00:34:14.010 --> 00:34:15.284
team a few years ago.

00:34:15.284 --> 00:34:17.159
It's basically a collection
of all the things

00:34:17.159 --> 00:34:19.139
you can do with
SurfaceFlinger, with Surfaces,

00:34:19.139 --> 00:34:22.590
with SurfaceView, with the media
encoder, with virtual displays.

00:34:22.590 --> 00:34:25.580
It's a very interesting
piece of code to look at.

00:34:25.580 --> 00:34:26.570
Color transforms.

00:34:26.570 --> 00:34:30.389
So in Android O, we
introduced color management,

00:34:30.389 --> 00:34:32.679
and that's one of the color
transforms we can apply.

00:34:32.679 --> 00:34:35.949
Things like nightlights
are also color transforms.

00:34:35.949 --> 00:34:38.210
We also have
colorblindness simulation.

00:34:38.210 --> 00:34:40.070
Those can be handled
by the Hardware

00:34:40.070 --> 00:34:43.219
Composer in specific
situations, and they

00:34:43.219 --> 00:34:46.880
can be the cause for
performance issues.

00:34:46.880 --> 00:34:49.370
For instance, a while
back, nightlights

00:34:49.370 --> 00:34:53.060
was not supported, I believe,
on the N5X or the N6B.

00:34:53.060 --> 00:34:54.929
One of the reasons
was the hardware.

00:34:54.929 --> 00:34:57.470
We didn't have the drivers that
could do the color transform,

00:34:57.470 --> 00:34:59.710
so we had to fall back
to GPU composition.

00:34:59.710 --> 00:35:00.740
It was really expensive.

00:35:00.740 --> 00:35:02.600
It was hurting the
battery, so we didn't

00:35:02.600 --> 00:35:03.950
have the feature on the device.

00:35:03.950 --> 00:35:06.250
And like Chet said, there
are many, many more details

00:35:06.250 --> 00:35:07.458
about our rendering pipeline.

00:35:07.458 --> 00:35:09.350
This was just a very
high level overview.

00:35:09.350 --> 00:35:11.300
We gave a number of
talks in the past

00:35:11.300 --> 00:35:13.940
that explained in
more details what

00:35:13.940 --> 00:35:16.460
we do, for instance, in
the UI render itself,

00:35:16.460 --> 00:35:17.960
how we do the
batching and merging--

00:35:17.960 --> 00:35:18.900
that kind of optimization.

00:35:18.900 --> 00:35:20.420
So if you're interested,
you can refer to those.

00:35:20.420 --> 00:35:21.750
CHET HAASE: Shadow
calculation is interesting.

00:35:21.750 --> 00:35:23.690
I think we had a talk
where we talked about some

00:35:23.690 --> 00:35:24.440
of those details.

00:35:24.440 --> 00:35:26.814
But exactly where does that
fit in the rendering pipeline

00:35:26.814 --> 00:35:29.000
is sort of clever.

00:35:29.000 --> 00:35:29.616
But yes.

00:35:29.616 --> 00:35:31.490
Lots more going on there,
but hopefully, this

00:35:31.490 --> 00:35:34.857
gives you a general sense of
how things work on Android.

00:35:34.857 --> 00:35:36.440
ROMAIN GUY: And with
that, we're done.

00:35:36.440 --> 00:35:38.390
CHET HAASE: So
we'll stop it there.

00:35:38.390 --> 00:35:39.080
Thank you.

00:35:39.080 --> 00:35:40.280
[APPLAUSE]

00:35:40.280 --> 00:35:43.330
[MUSIC PLAYING]

