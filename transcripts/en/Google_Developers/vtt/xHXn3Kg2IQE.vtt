WEBVTT
Kind: captions
Language: en

00:00:03.330 --> 00:00:05.800
&gt;&gt;Virgil Dobjanschi: Good morning.
My name is Virgil Dobjanschi. I am a software

00:00:05.800 --> 00:00:10.309
engineer at Google.
I work in the Android Application Group.

00:00:10.309 --> 00:00:17.170
I am also the author, more recently, of the
official Twitter app.

00:00:17.170 --> 00:00:21.930
I want to welcome you to the session today.
We are going to talk about the development

00:00:21.930 --> 00:00:28.430
of REST client applications.
Before we begin, I would like to invite you

00:00:28.430 --> 00:00:34.260
to view live notes and ask questions during
this session by using Google Wave.

00:00:34.260 --> 00:00:39.409
I am going to give you just a few seconds
to write down this URL if you haven't done

00:00:39.409 --> 00:00:46.690
that already.
While you are doing that, I just want to gauge

00:00:46.690 --> 00:00:51.799
your opinion about the Froyo announcement.
Were you guys impressed by this announcement,

00:00:51.799 --> 00:00:55.930
by everything we announced today in the keynote?
[ Applause ]

00:00:55.930 --> 00:01:02.570
&gt;&gt;Virgil Dobjanschi: Well, I work in that
group, and I am impressed. I'm amazed by the

00:01:02.570 --> 00:01:08.190
amount of stuff that happens in that group.
And I invite you to go to all the other Android

00:01:08.190 --> 00:01:18.510
sessions this afternoon, learn about Android
cloud-to-device messaging and all the other

00:01:18.510 --> 00:01:23.440
great lessons you can learn and you can use
when you are developing Android applications.

00:01:23.440 --> 00:01:26.840
So we have a lot of content to cover, so let's
get started.

00:01:26.840 --> 00:01:35.210
So what is REST? REST stands for representational
state transfer. It is a broadly adopted architecture

00:01:35.210 --> 00:01:40.740
style. This style is comprised of clients
and servers.

00:01:40.740 --> 00:01:51.100
Clients make request to the server to get
or change the state of a particular resource.

00:01:51.100 --> 00:01:55.260
Servers respond to the client with representations
of resource.

00:01:55.260 --> 00:02:03.030
So what is a resource? A resource is any meaningful
concept that can be addressed. For the purpose

00:02:03.030 --> 00:02:09.890
of this talk, I am going to reference back
to the Google Finance API as a simple example

00:02:09.890 --> 00:02:13.330
of an API.
So a resource in case of the Google Finance

00:02:13.330 --> 00:02:20.420
API is a stock portfolio, which is characterized
by its name and the currency in which it operates.

00:02:20.420 --> 00:02:25.690
The representation of the resource is simply
a document that fully describes that particular

00:02:25.690 --> 00:02:31.290
resource. In the case of Google Finance API,
it's an XML document which simply describes

00:02:31.290 --> 00:02:37.310
that particular resource in terms of its name
and the currency, and maybe its ID for the

00:02:37.310 --> 00:02:42.510
purpose of referring to that particular resource
later on when you need to update it or you

00:02:42.510 --> 00:02:49.569
need to delete it.
REST is in no way associated with HTTP. You

00:02:49.569 --> 00:02:56.560
can use any transport protocol. But certainly
HTTP is the most common used transport protocol

00:02:56.560 --> 00:03:04.760
for the REST-style architectures.
There are a large number of REST APIs available

00:03:04.760 --> 00:03:10.810
today. Google code offers already a host of
such APIs.

00:03:10.810 --> 00:03:17.500
Social networking sites, such as Twitter,
Facebook, MySpace, already have a very rich

00:03:17.500 --> 00:03:27.239
REST API. You can find all kinds of information-based
REST services for calendars, for flight schedules

00:03:27.239 --> 00:03:32.569
and so forth.
The first question you are going to ask yourself

00:03:32.569 --> 00:03:38.790
before you start the development of a REST
client application is why would I possibly

00:03:38.790 --> 00:03:46.180
develop an application like that if the service
that I am connecting to already has a mobile-friendly

00:03:46.180 --> 00:03:50.379
Web site. In other words, why don't I just
use the browser to connect to that service

00:03:50.379 --> 00:03:55.910
and I'm done?
Well, until the browser technology catches

00:03:55.910 --> 00:04:01.400
up, I have five reasons for you. I hope I
can remember them all.

00:04:01.400 --> 00:04:11.090
The first one is that your application, your
Android application, will be able to integrate

00:04:11.090 --> 00:04:16.820
with the Android platform. It will be able
to use intents content providers. It's going

00:04:16.820 --> 00:04:23.229
to be able to access all the private APIs
available today, only to Android applications,

00:04:23.229 --> 00:04:28.449
things that at least at this point you can't
do from a browser.

00:04:28.449 --> 00:04:35.630
Your application will be able to invoke intents,
not only to pick photos but all the other

00:04:35.630 --> 00:04:40.469
intents that are today available for all the
applications to use.

00:04:40.469 --> 00:04:47.930
The second reason is, your application can
offer intents to other applications. In other

00:04:47.930 --> 00:04:53.310
words, you are going to be able to enrich
the behavior of the platform by offering new

00:04:53.310 --> 00:04:58.940
functionality to other applications. Content
providers are there for you to access. The

00:04:58.940 --> 00:05:04.740
context content provider is a very popular
content provider. Lots of applications expose

00:05:04.740 --> 00:05:08.419
it.
The second reason is your applications can

00:05:08.419 --> 00:05:16.180
run in the background. What does that mean?
It means that if you would like to have your

00:05:16.180 --> 00:05:21.039
application refresh the data from the server
and new data is actually retrieved from the

00:05:21.039 --> 00:05:26.279
server, your application has the option to
present a notification to the user to let

00:05:26.279 --> 00:05:31.240
them know that that particular data is available.
A browser can't do that.

00:05:31.240 --> 00:05:38.059
Your application runs on devices with limited
connectivity. What does that mean? You are

00:05:38.059 --> 00:05:43.159
going to try to initiate some of the REST
methods, and they will sometimes fail because

00:05:43.159 --> 00:05:48.089
you operate in environments just like here
at the conference where the network comes

00:05:48.089 --> 00:05:52.289
and goes.
An Android application has the option to run

00:05:52.289 --> 00:06:00.639
in the background and retry operations in
the background by using an alarm, for example,

00:06:00.639 --> 00:06:08.199
for the purpose of relieving the user for
trying to hit that refresh button or post

00:06:08.199 --> 00:06:16.580
button in the browser.
Your application can actually be faster than

00:06:16.580 --> 00:06:21.949
a Web browser. Your application has the option
of retrieving all that network content in

00:06:21.949 --> 00:06:28.039
JSON or some binary or some XML format, parse
it and store it in a database. From there

00:06:28.039 --> 00:06:33.180
on, when you want to retrieve new content,
you may have the option of retrieving only

00:06:33.180 --> 00:06:37.199
content that's newer than the one that you
already have or older than the one you already

00:06:37.199 --> 00:06:41.129
have, but not the same data.
You also are not retrieving all the HTML that

00:06:41.129 --> 00:06:45.590
comes along or any kind of JavaScript that
might be too big and might take too long to

00:06:45.590 --> 00:06:51.069
download.
Finally, your application has the option of

00:06:51.069 --> 00:06:56.759
being consistent in terms of user interface
with the REST of the operating system. You

00:06:56.759 --> 00:07:06.089
can innovate in many ways to deliver a fantastic
user experience to the user.

00:07:06.089 --> 00:07:15.490
If you have participated yesterday in the
user experience talk, please take advantage

00:07:15.490 --> 00:07:21.249
of those UI patterns. Your application is
going to be so much faster and easier in some

00:07:21.249 --> 00:07:28.250
cases to use than the browser.
And finally, when users are presented with

00:07:28.250 --> 00:07:33.929
the option of using a Web browser versus a
REST application, I can guarantee you that

00:07:33.929 --> 00:07:42.999
most users will choose the REST application.
Before we begin, I would like to describe

00:07:42.999 --> 00:07:49.539
the way a novice programmer would approach
the development of a REST application. That's

00:07:49.539 --> 00:07:55.129
not you. You guys know it all, but just for
the purpose of this discussion, let's look

00:07:55.129 --> 00:07:58.259
at these things.
Hopefully, it won't take you 10,000 tries

00:07:58.259 --> 00:08:06.699
to get there. But I can tell you that I make
these mistakes myself. It's actually human

00:08:06.699 --> 00:08:12.029
nature to try to learn as little as you can
about a particular thing and move quickly

00:08:12.029 --> 00:08:16.740
forward and say, okay, I am going to have
this app ready in ten minutes. And I am going

00:08:16.740 --> 00:08:23.610
to say slow down. Get all the facts first.
Learn what's correct. Implement it correctly

00:08:23.610 --> 00:08:29.149
so you have a good base for your application
to get going.

00:08:29.149 --> 00:08:35.030
So you are a Java programmer. You have looked
around the Android SDK a little bit, and you

00:08:35.030 --> 00:08:40.760
say to yourself, I know what an activity is.
How hard would it be? I am just going to create

00:08:40.760 --> 00:08:45.180
this activity.
I understand a REST method takes a long time

00:08:45.180 --> 00:08:48.430
to execute because I need to connect to a
server, so I am going to run it in the context

00:08:48.430 --> 00:08:51.760
of a thread.
You decide that this thread is going to be

00:08:51.760 --> 00:08:57.790
an inner class of your activity. And you decide
that you are going to store all this data

00:08:57.790 --> 00:09:03.020
that you retrieve from the server in memory.
Maybe the application I am describing here

00:09:03.020 --> 00:09:09.040
is your attempt at displaying the list of
stock portfolios that I already have set up

00:09:09.040 --> 00:09:15.210
for my own account in Google Finance.
So you get your application to run. It runs

00:09:15.210 --> 00:09:22.380
fast, it doesn't crash. So why is this not
the correct approach?

00:09:22.380 --> 00:09:28.400
You have to understand how the Android operating
system works. The Android operating system

00:09:28.400 --> 00:09:34.400
was designed to work on devices with limited
memory. What does that mean?

00:09:34.400 --> 00:09:41.370
It means that, for example, when the operating
system is attempting to start a new application

00:09:41.370 --> 00:09:50.310
and it ran out of memory, it needs to make
a decision about forcefully shutting down

00:09:50.310 --> 00:09:53.240
an existing application. So how does it make
that decision?

00:09:53.240 --> 00:09:59.780
Well, the answer is you have to help the operating
system make that decision.

00:09:59.780 --> 00:10:06.530
If your application does not have a foreground
activity running -- in other words, a visible

00:10:06.530 --> 00:10:14.270
activity running -- or a service running,
the operating system can say, okay, well,

00:10:14.270 --> 00:10:19.300
this application is not currently displayed
to the user, it's not currently performing

00:10:19.300 --> 00:10:26.070
any operation, so it's safe to shut it down.
So let's now go back to our diagram and try

00:10:26.070 --> 00:10:29.070
to understand what's wrong with this picture
here.

00:10:29.070 --> 00:10:37.180
Well, here's what happens here. You launch
the thread that initiates the REST method,

00:10:37.180 --> 00:10:46.070
and guess what? You pause your activity because
maybe an incoming call needs to be answered.

00:10:46.070 --> 00:10:50.740
What happens is the operating system says,
oh, well, this particular process doesn't

00:10:50.740 --> 00:10:54.250
have any foreground activity, so you know
what? I am going to kill it. I am going to

00:10:54.250 --> 00:11:01.180
forcefully shut it down.
Well, guess what? Your post, put, delete method

00:11:01.180 --> 00:11:05.930
maybe has executed on the server and you will
never learn the result of that particular

00:11:05.930 --> 00:11:10.020
method in your app.
The get method, you get all this data in,

00:11:10.020 --> 00:11:14.641
once you get it in, you parse it, you are
happy, the operating system will shut it down

00:11:14.641 --> 00:11:20.590
for you. Wasted bandwidth.
Another thing that's wrong with your approach

00:11:20.590 --> 00:11:27.470
is that you decided to store the data in memory.
So you say, well, hang on. My application

00:11:27.470 --> 00:11:31.490
is fast.
Well, the reason why that's not a good idea,

00:11:31.490 --> 00:11:40.380
it's because by having to repeatedly retrieve
data from the server, either because the user

00:11:40.380 --> 00:11:46.660
has simply restarted the device or simply
because at one point your process had to be

00:11:46.660 --> 00:11:52.600
forcefully shut down, you are wasting CPU,
you are wasting battery, you are wasting network

00:11:52.600 --> 00:11:56.880
bandwidth.
That's not a great way to write an Android

00:11:56.880 --> 00:12:00.181
application.
And for those of you who are going to say,

00:12:00.181 --> 00:12:06.230
well, it's much faster to get this data from
memory, I am going to say by using a content

00:12:06.230 --> 00:12:11.240
provider, you have the option, should you
consider that necessary, to cache this data

00:12:11.240 --> 00:12:14.310
on memory.
So that's really not a good reason to say

00:12:14.310 --> 00:12:20.180
I'm not going to store my data.
As I said, none of you will probably write

00:12:20.180 --> 00:12:30.400
the application this way.
So let's describe today three design patterns

00:12:30.400 --> 00:12:36.930
that you can use in your applications that
would give the best user experience and the

00:12:36.930 --> 00:12:42.170
best performance. These are not the only three
patterns you can use.

00:12:42.170 --> 00:12:46.970
Once you look at them, once you understand
what they are all about, you can possibly

00:12:46.970 --> 00:12:52.530
create your own. That's great.
As long as your application complies with

00:12:52.530 --> 00:13:00.620
the basic principles that we're laying here
for you, it's okay to continue to innovate

00:13:00.620 --> 00:13:04.420
from here.
We're not going to talk about implementation

00:13:04.420 --> 00:13:11.350
details. I am not going to show you code.
Hopefully you like that.

00:13:11.350 --> 00:13:15.400
So let's introduce these three patterns. One
is based on the service API, one is based

00:13:15.400 --> 00:13:23.060
on the content provider API, and the third
one is simply a variant of the second one.

00:13:23.060 --> 00:13:27.070
We are going to use a sync adapter.
This is an advanced talk. Last year we got

00:13:27.070 --> 00:13:32.000
a lot of feedback from you guys saying some
of the sessions were too light. We decided

00:13:32.000 --> 00:13:35.610
to compensate this year.
Even though it's an advanced slide, I am going

00:13:35.610 --> 00:13:41.460
to try to introduce these concepts which some
of you may not be familiar with so you understand

00:13:41.460 --> 00:13:50.500
the basic idea behind it.
So let's get started with the first pattern.

00:13:50.500 --> 00:13:55.570
The first pattern makes use of a service.
Again, for those of how are not familiar with

00:13:55.570 --> 00:14:04.510
a service, it's an Android component that
does not interact with a user, and it's specifically

00:14:04.510 --> 00:14:12.070
designed to execute operations in the background.
It runs in the context of the main thread.

00:14:12.070 --> 00:14:17.631
We can call that the UI thread.
And in order for you to execute these operations,

00:14:17.631 --> 00:14:21.420
you need to still create a worker thread in
the service.

00:14:21.420 --> 00:14:26.600
Some people think that by simply starting
the service, I can simply execute in the context

00:14:26.600 --> 00:14:35.410
of the thread of the service that particular
long-running operations. That's false.

00:14:35.410 --> 00:14:40.380
So now that we understand that the service
exists in the platform and has, by the way,

00:14:40.380 --> 00:14:47.990
a very simple API. You can either implement
the services API by using an intent API or

00:14:47.990 --> 00:14:54.600
by using a binder interface. By the way, for
the purpose of this talk, we are going to

00:14:54.600 --> 00:15:00.940
use the intent API which is, by the way, a
little bit easier to understand.

00:15:00.940 --> 00:15:05.960
We can now get started with this first pattern.
This diagram is not exactly simple. To best

00:15:05.960 --> 00:15:12.590
understand it, we are going to take a bottom-to-top
approach by explaining the role of each component.

00:15:12.590 --> 00:15:17.160
And once we are done, we are going to do one
example starting from the top and running

00:15:17.160 --> 00:15:19.800
through an entire code flow to see how this
works.

00:15:19.800 --> 00:15:24.529
So let's get started with the REST method.
What is the REST method? Really simple. It's

00:15:24.529 --> 00:15:31.610
an entity which has the ability to prepare
an HTTP URL, to prepare the HTTP body in some

00:15:31.610 --> 00:15:37.380
cases, execute the HTTP transaction with the
server and process the response, which typically

00:15:37.380 --> 00:15:42.430
means parse the response from the server.
There's not much to say about this. Let's

00:15:42.430 --> 00:15:50.680
make some performance remarks.
Many REST APIs offer today the ability that

00:15:50.680 --> 00:15:58.570
you select the content type of responses.
Prefer them in this order. Some binary format,

00:15:58.570 --> 00:16:06.290
AMF3, whatever is out there, JSON and XML.
We are happy to announce that if you choose

00:16:06.290 --> 00:16:15.270
JSON, we have a brand-new implementation of
org.json API. It has exactly the same API

00:16:15.270 --> 00:16:20.970
as before but it performs much faster.
There is very little garbage collection going

00:16:20.970 --> 00:16:27.190
on. For those of you who tried the older version,
you are going to be very happy with this particular

00:16:27.190 --> 00:16:37.290
implementation.
Enable gzip. If the REST API that you are

00:16:37.290 --> 00:16:39.880
using allows it.
Gzip is a very fast library. It's a native

00:16:39.880 --> 00:16:45.010
implementation. Sometimes you get compression
ratio five to one, ten to one, depending how

00:16:45.010 --> 00:16:51.940
much data you are retrieving.
And by doing so, you are simply speeding up

00:16:51.940 --> 00:16:58.690
the download of data that you want, plus the
battery life will be preserved better in this

00:16:58.690 --> 00:17:02.779
case because the radio will be in use for
less amount of time.

00:17:02.779 --> 00:17:08.350
Always think about the radio, always think
about the network and the implication it has

00:17:08.350 --> 00:17:14.459
on the battery life of that particular device.
Always run this REST method in a worker thread.

00:17:14.459 --> 00:17:19.629
Understand that an HTTP transaction takes
time to implement, sometimes a long time if

00:17:19.629 --> 00:17:25.279
a timeout occurs. And you should never run
such operations in the context of the main

00:17:25.279 --> 00:17:29.409
thread.
And finally, use the Apache HTTP client, not

00:17:29.409 --> 00:17:35.059
the Java URL connection.
All right. So what do we have so far? We have

00:17:35.059 --> 00:17:41.129
the REST method, a simple API. It fires back
a Java listener callback. Really simple.

00:17:41.129 --> 00:17:46.860
Let's take a look at the processor.
The role of the processor is to mirror the

00:17:46.860 --> 00:17:54.039
state of server resources in your local database.
We're going to use the database. The role

00:17:54.039 --> 00:17:59.809
of the processor is to say, okay, this is
the state of this particular resource.

00:17:59.809 --> 00:18:06.799
So to better understand how the processor
works, we need to create this concept of a

00:18:06.799 --> 00:18:10.730
resource in the database.
Well, it's really simple. It's exactly one

00:18:10.730 --> 00:18:16.191
row in the database. In the case of Google
Finance, it's a row that maybe has the idea

00:18:16.191 --> 00:18:22.369
of this particular resource, the name of this
particular portfolio, and the currency. And

00:18:22.369 --> 00:18:28.249
we are going to add two more columns to that.
One, a status column, and, two, a result column.

00:18:28.249 --> 00:18:37.820
The status column is the one that simply indicates
the transitional slash at-REST or steady state

00:18:37.820 --> 00:18:44.119
of that particular resource. What that means
is that every resource, when it executes a

00:18:44.119 --> 00:18:52.149
REST method, has a transitional state; right?
While you are executing this particular transaction,

00:18:52.149 --> 00:18:56.450
the resource is not yet in sync with the server
so we want to keep track of this particular

00:18:56.450 --> 00:18:59.600
state.
Your question is why. Why would I possibly

00:18:59.600 --> 00:19:05.419
need this? Two reasons.
One, your user interface may want to display

00:19:05.419 --> 00:19:10.990
maybe a little icon next to the resource that
says, oh, well, you know, I don't have to

00:19:10.990 --> 00:19:15.649
stay in the activity that actually started
this post, the creation of the portfolio.

00:19:15.649 --> 00:19:20.159
I can just leave that activity. And my list
of items is just going to display a little

00:19:20.159 --> 00:19:25.999
icon next to that particular resource saying
I'm in the process of synchronizing the resource,

00:19:25.999 --> 00:19:29.789
but go ahead and use the app. I will let you
know when that's done.

00:19:29.789 --> 00:19:34.480
When that disappears, that's a good indication
that your resource has now been synchronized.

00:19:34.480 --> 00:19:38.399
So in the standard set of these, we are going
to hold some flags. These flags are going

00:19:38.399 --> 00:19:42.789
to say I am in the process of executing a
post method for this particular resource.

00:19:42.789 --> 00:19:46.419
I am in the process of updating, deleting
this particular resource.

00:19:46.419 --> 00:19:52.429
And we are going to use one more flag to say
we are in the process of executing an HTTP

00:19:52.429 --> 00:19:57.731
transaction for this REST method.
Now you have a full description of anything

00:19:57.731 --> 00:20:01.869
what's going on. At any time you can look
at the database and say, okay, I know exactly

00:20:01.869 --> 00:20:09.470
what's going on with this particular resource.
The result method can simply hold the HTTP

00:20:09.470 --> 00:20:15.929
result of the last REST method you executed
in regards to that particular resource.

00:20:15.929 --> 00:20:20.950
So now let's come back to the processor.
The processor executes before and after the

00:20:20.950 --> 00:20:25.559
REST method executes.
Before the REST method executes, in case of

00:20:25.559 --> 00:20:34.799
the post method, it's simply going to insert
the content -- it's going to create a row

00:20:34.799 --> 00:20:39.730
in the database, it's going to call an insert
method to create the row that corresponds

00:20:39.730 --> 00:20:44.619
to the resource we need to update.
We are going to set the flags to posting,

00:20:44.619 --> 00:20:49.619
meaning we're in the process of executing
a post method for this particular resource.

00:20:49.619 --> 00:20:53.049
We're going to say yep. We are also transacting,
by the way, so we are going to set that flag,

00:20:53.049 --> 00:20:57.140
too, in the column, and we initiative the
REST method.

00:20:57.140 --> 00:21:04.149
We are going to update the row in the database
with the help of the content provider. We

00:21:04.149 --> 00:21:08.870
are going to clear the state posting fire
because that particular method is no longer

00:21:08.870 --> 00:21:13.419
pending, and we are also going to clear the
transacting flag so we know we are no longer

00:21:13.419 --> 00:21:19.100
transacting the server.
Put works very similarly. It's hardly worth

00:21:19.100 --> 00:21:23.289
going through this, but we're going to update
before the (inaudible) execute, we are going

00:21:23.289 --> 00:21:30.200
to update this particular row in the database.
We are going to set the updating flag, meaning

00:21:30.200 --> 00:21:34.679
we're in the process of updating this resource
on the server. Set the transaction flag, execute

00:21:34.679 --> 00:21:41.169
the REST method. Once it's done, update it
again, and clear the two flags that we just

00:21:41.169 --> 00:21:46.769
set, if everything goes right.
By the way, as you well know, most correction

00:21:46.769 --> 00:21:53.500
REST API implementations are item potent.
It means that you want to send a document

00:21:53.500 --> 00:21:57.621
to the server saying, okay, I want to change
the state of this particular resource on the

00:21:57.621 --> 00:22:02.019
server, and you send this document representing
the change you want to make, and the response

00:22:02.019 --> 00:22:07.139
that comes back, it's the full description
of that particular resource as the server

00:22:07.139 --> 00:22:10.100
sees it. In other words, the state on the
server side.

00:22:10.100 --> 00:22:15.850
That's why it's recommended that you go ahead
and update again, although many times that's

00:22:15.850 --> 00:22:20.149
not necessary. It's up to you to decide. But
either way, in this case you are going to

00:22:20.149 --> 00:22:24.989
have to clear the flags.
Delete. Very simple. You are just going to

00:22:24.989 --> 00:22:30.610
delete -- tag that particular method for deletion.
You are not actually going to delete the resource.

00:22:30.610 --> 00:22:34.649
Why? Because we have not yet successfully
executed the REST method.

00:22:34.649 --> 00:22:38.470
You go ahead, execute the REST method. It
succeeds finally, you delete that row.

00:22:38.470 --> 00:22:41.820
Finally, you are done.
Your user interface, by the way, in this case,

00:22:41.820 --> 00:22:46.269
has the option of saying, well, you know what?
If the state deleting flag is set in the status

00:22:46.269 --> 00:22:51.370
column, I am not even going to bother displaying
that particular resource. Or you have the

00:22:51.370 --> 00:22:56.919
option to display a little synchronizing resource
right next to that particular resource to

00:22:56.919 --> 00:23:00.509
know that we have not yet deleted it but we
are about to.

00:23:00.509 --> 00:23:04.879
By the way, these flags can serve a different
purpose.

00:23:04.879 --> 00:23:09.400
What happens when you need to retry these
operations? Well, wouldn't it be great to

00:23:09.400 --> 00:23:15.460
know what exactly do you need do. The posting
flag would mean, oh, I need to execute a post

00:23:15.460 --> 00:23:19.799
method. I am going to look at the transacting
flag saying is there an HTTP transaction already

00:23:19.799 --> 00:23:22.909
posting?
So if that's the case, I am not going to start

00:23:22.909 --> 00:23:26.980
another one.
If it's not, I have the option of saying,

00:23:26.980 --> 00:23:29.970
okay, well, let me retry this. Maybe the network
didn't work last time.

00:23:29.970 --> 00:23:36.960
But that's a great way to mirror the state
of the resource in the database and retry

00:23:36.960 --> 00:23:40.210
these methods.
Get, simplest one of all. There's nothing

00:23:40.210 --> 00:23:44.509
to do. Processor has nothing to do before
the REST method inserts the new resources

00:23:44.509 --> 00:23:50.519
it wants to get from the server.
This could be the list of stock portfolios,

00:23:50.519 --> 00:23:58.940
maybe you have many of them on Google Finance.
One more thing to say about processors. They

00:23:58.940 --> 00:24:06.119
execute database operations. Never execute
database operations or content provider operations

00:24:06.119 --> 00:24:10.940
in the context of the main thread. Sooner
or later you are going to run into application

00:24:10.940 --> 00:24:15.700
not responding errors. The so-called ANRs.
It's not a good practice.

00:24:15.700 --> 00:24:24.649
Learn to stay away from that.
Also, use transactions when you SQL light.

00:24:24.649 --> 00:24:30.850
Not only will they preserve the data integrity
but they will increase the performance of

00:24:30.850 --> 00:24:36.369
your database operations.
We have the processor, we have the REST method.

00:24:36.369 --> 00:24:42.320
The processor has almost the same API as the
REST method, it goes through. But this time

00:24:42.320 --> 00:24:47.859
we are able to mirror the state of that particular
resource in the database.

00:24:47.859 --> 00:24:51.549
We said at the beginning that it's not a good
idea to start long-running operations in that

00:24:51.549 --> 00:24:58.749
activity. That's where the service comes in.
The role of the service is to simply allow

00:24:58.749 --> 00:25:07.090
your application to execute operations in
the background while an activity is long gone.

00:25:07.090 --> 00:25:12.570
I am going to say it again. An activity comes
and goes. It's just the user interface of

00:25:12.570 --> 00:25:17.179
your application.
The user has the option to hit the home button,

00:25:17.179 --> 00:25:20.600
hit the destroy button -- in other words,
go back home.

00:25:20.600 --> 00:25:25.909
Your long running operation, it's still executing.
And the nice thing is that you have the database.

00:25:25.909 --> 00:25:31.139
Simply store the state of that particular
resource in the database and when you come

00:25:31.139 --> 00:25:36.639
back to your application, regardless of what
happened, you can simply learn what happened.

00:25:36.639 --> 00:25:41.159
Did it work? Is it still pending? What's going
on?

00:25:41.159 --> 00:25:47.629
On the forward path, the service simply receives
an intent. We said we were going to use the

00:25:47.629 --> 00:25:53.629
intent-based API. It unpacks the content of
that intent, which think of it as a map. Oh,

00:25:53.629 --> 00:25:59.970
yeah, I passed in, for example, the name of
this particular stock portfolio and the currency.

00:25:59.970 --> 00:26:03.940
I am going to extract it from there. Make
a Java call to the processor. Done.

00:26:03.940 --> 00:26:08.639
On the return path, I am simply going to handle
the processor callback, and I am going to

00:26:08.639 --> 00:26:14.029
invoke what is called a binder callback. What
is a binder callback? The binder callback,

00:26:14.029 --> 00:26:18.429
think of it as an interface that was passed
in the request intent.

00:26:18.429 --> 00:26:23.331
So the upper layer says when you are done
with this particular operation, I want you

00:26:23.331 --> 00:26:29.330
to invoke this binder callback and let me
know that everything worked or failed.

00:26:29.330 --> 00:26:34.730
Here is another thing you can do in the service.
You write a social application. And all of

00:26:34.730 --> 00:26:40.150
a sudden your UI needs to download ten, 20
images just because you are scrolling really

00:26:40.150 --> 00:26:46.559
fast through that list.
Is it a good idea to download 10, 20 little

00:26:46.559 --> 00:26:51.159
images at the same time? The answer is no.
Be nice to all the other applications. They

00:26:51.159 --> 00:26:55.700
might need the bandwidth at that time.
Implement a little queue in this particular

00:26:55.700 --> 00:27:02.499
service. Allow maybe one, two, or three, as
it is the case in your application, for parallel

00:27:02.499 --> 00:27:06.830
downloads of these particular images, especially
if these particular images are larger.

00:27:06.830 --> 00:27:11.519
Always think about the other apps when you
are writing one.

00:27:11.519 --> 00:27:18.269
And finally, the service is a stateless component.
Everything it needs, it receives the intent.

00:27:18.269 --> 00:27:22.989
Fires the callback. Unless you implement the
queue we were just talking about for downloads,

00:27:22.989 --> 00:27:29.190
there's no reason to keep any state. And most
importantly, while all the pending operations

00:27:29.190 --> 00:27:35.029
have completed, shut down the service.
If you don't, the operating system is going

00:27:35.029 --> 00:27:40.749
to say, well, this guy is busy. You know,
let him keep the memory that it wants. Let

00:27:40.749 --> 00:27:45.340
him do whatever he needs to do.
Be nice, again, to all the other applications.

00:27:45.340 --> 00:27:50.809
Shut down the service once you are done. It's
very easy. We are going to say for the purpose

00:27:50.809 --> 00:27:57.090
of the service helper to stop the service
or the service can stop itself. There are

00:27:57.090 --> 00:28:03.609
many ways to do it. You have no excuse to
leave that service running.

00:28:03.609 --> 00:28:07.980
Almost there.
We have a service with an intent API, and

00:28:07.980 --> 00:28:14.720
asynchronously fires a binder callback interface.
Sometimes preparing these intents is not that

00:28:14.720 --> 00:28:20.850
easy. Or at least not elegant. I know that.
And handling the binder callback is not something

00:28:20.850 --> 00:28:27.940
we should leave as an exercise for the reader.
What we should do is have a very thin layer,

00:28:27.940 --> 00:28:33.049
we call this the service helper, that prepares
these intents for us on the forward path and

00:28:33.049 --> 00:28:37.619
handles the binder callback on the return
path.

00:28:37.619 --> 00:28:44.989
So the role of the service helper is to simply
expose a very simple asynchronous API to the

00:28:44.989 --> 00:28:49.789
caller. Let's say we want to create a portfolio.
The name of the method is create portfolio,

00:28:49.789 --> 00:28:55.259
here is my name, here is the currency. It
returns the request ID, which uniquely identifies

00:28:55.259 --> 00:29:01.970
that particular pending REST method.
It's a Singleton. There's nothing to it. You

00:29:01.970 --> 00:29:06.879
make this call and here is what the service
does.

00:29:06.879 --> 00:29:12.460
It's much simpler than it looks.
The first thing you may want to do is have

00:29:12.460 --> 00:29:18.350
the ability to ask the question is this particular
REST method already pending? That's certainly

00:29:18.350 --> 00:29:25.440
not the case with create. But if you do maybe
a get my stock portfolio list, what if you

00:29:25.440 --> 00:29:30.799
issue this request and some other activity
which quickly you switch to issues yet another

00:29:30.799 --> 00:29:33.019
request.
Well, you certainly don't want this particular

00:29:33.019 --> 00:29:40.960
situation where, let's say, you are downloading
and parsing the stock portfolios in parallel

00:29:40.960 --> 00:29:46.519
in two different threads. It makes no sense.
So you can protect yourself in this particular

00:29:46.519 --> 00:29:50.221
pattern here in the service helper. You can
implement the map from the request ID to the

00:29:50.221 --> 00:29:54.940
this intent. And you can always, first of
all, ask the service is this particular request

00:29:54.940 --> 00:29:57.999
ID still pending?
You can do something else. You can look at

00:29:57.999 --> 00:30:06.210
the values, the intents in the values method
and say by looking at the intents you will

00:30:06.210 --> 00:30:13.580
be able to answer the question is this particular
type of operation, maybe even with these parameters,

00:30:13.580 --> 00:30:18.940
already pending? And if yes, you simply return
that request ID to the user and it's a nice

00:30:18.940 --> 00:30:24.330
way to get around some of these problems.
And finally, you put the operation type, you

00:30:24.330 --> 00:30:30.269
put any method-specific parameters such as
the name and the currency. You set the binder

00:30:30.269 --> 00:30:36.539
callback and you finally call start service
which simply sends that service to the service

00:30:36.539 --> 00:30:42.270
that we discussed earlier.
On the return path, really easy. You get the

00:30:42.270 --> 00:30:48.210
binder callback, and this time you say, okay,
this particular operation is no longer pending.

00:30:48.210 --> 00:30:54.450
And you can dispatch a callback to any listeners.
Listeners are typically going to be activities

00:30:54.450 --> 00:31:00.940
that would like to know the result of this
particular REST method.

00:31:00.940 --> 00:31:06.450
One interesting discussion here is what kind
of data should I pass from the service to

00:31:06.450 --> 00:31:13.200
the service helper? And you are going to say,
okay, you just retrieved that list of stock

00:31:13.200 --> 00:31:19.529
portfolios. Should I just pass it on? Should
I just move all that data through this particular

00:31:19.529 --> 00:31:24.309
binder callback?
Well, think of it as a marshaling interface.

00:31:24.309 --> 00:31:27.529
In other words, something that has to cross
process boundaries.

00:31:27.529 --> 00:31:33.279
Well, you don't want to do that. Keep as little
data as possible in that particular callback.

00:31:33.279 --> 00:31:38.100
For example, you can say the result of this
particular REST method was 200. Okay. You

00:31:38.100 --> 00:31:42.859
can say here is, by the way, the original
intent which I used to start this operation.

00:31:42.859 --> 00:31:47.759
Maybe the caller would like to analyze the
content of that particular intent to remind

00:31:47.759 --> 00:31:55.700
itself what it was executing at that time.
All the day that you already retrieved, it's

00:31:55.700 --> 00:32:01.009
already in the database. The activity has
the option of simply saying, okay, thanks

00:32:01.009 --> 00:32:05.940
for letting me know. I am going to go and
retrieve that content.

00:32:05.940 --> 00:32:10.710
There's absolutely no harm done if you choose
once in a while to pass some data through

00:32:10.710 --> 00:32:14.409
this binder interface.
You can use any parcel-able, think of it as

00:32:14.409 --> 00:32:18.799
serialization technique, to send data over
this interface.

00:32:18.799 --> 00:32:29.210
The less data you parcel, the better it is.
So we are almost done. The service helper

00:32:29.210 --> 00:32:35.299
has a simple API. If there are any listeners
that register, these calls go back to the

00:32:35.299 --> 00:32:38.529
activity.
Let's look at the activity.

00:32:38.529 --> 00:32:43.769
Always remember the activities are pause,
resume, or destroy. They have their own mind.

00:32:43.769 --> 00:32:52.889
They have, better said, their own life cycle.
Think of them again as just user interface

00:32:52.889 --> 00:33:00.080
that is either controlled by the user. In
some cases activities pop in front of your

00:33:00.080 --> 00:33:03.879
application just because maybe a phone call
comes in, in which case the application will

00:33:03.879 --> 00:33:08.570
be paused, the activity will be paused.
And on resume, we have the option of adding

00:33:08.570 --> 00:33:11.009
a callback to the service, say, okay, I'm
back.

00:33:11.009 --> 00:33:16.630
I'm interested in what you have to say.
On pause, remove that, because if a callback

00:33:16.630 --> 00:33:22.779
will occur while your activity is paused,
sooner or later, you'll get a crash.

00:33:22.779 --> 00:33:27.779
You're trying to access this activity while
it's paused, and that's certainly an incorrect

00:33:27.779 --> 00:33:32.739
technique.
Always consider these three cases.

00:33:32.739 --> 00:33:39.139
A request method is started by the activity.
The activity just sits there in the foreground.

00:33:39.139 --> 00:33:42.129
Everything is nice, it gets the callback from
the service helper.

00:33:42.129 --> 00:33:46.039
Easy.
You, in case of an error, you can say, I'm

00:33:46.039 --> 00:33:51.559
sorry, I couldn't perform your operation.
Or, hey, cool, we created the stock portfolio.

00:33:51.559 --> 00:33:59.519
What if the activity starts the REST method,
pauses, it comes back, it resumes, and now

00:33:59.519 --> 00:34:02.559
the callback occurs.
Well, that's not much more difficult.

00:34:02.559 --> 00:34:06.220
However, you can still handle the callback.
Everything is great.

00:34:06.220 --> 00:34:13.280
You -- in this case, you may need to store
the request ID so you know to ask the service

00:34:13.280 --> 00:34:18.890
helper, is this particular request still pending?
And so -- and on resume, the answer this time

00:34:18.890 --> 00:34:21.040
is going to say, yep, that's still pending.
Okay.

00:34:21.040 --> 00:34:23.400
So I'll just wait for the call back.
Nothing special.

00:34:23.400 --> 00:34:29.140
Third one is the most complex.
REST method is started.

00:34:29.140 --> 00:34:33.070
Activity's paused.
REST method completes while the activity is

00:34:33.070 --> 00:34:37.040
paused.
Activity comes back to life and resumes.

00:34:37.040 --> 00:34:40.980
What's happening?
Well, in unresume this time you're going to

00:34:40.980 --> 00:34:45.570
have again the request ID that you started,
and you'll say is this request still running,

00:34:45.570 --> 00:34:53.210
and the answer is going to be no, it's not.
So now you understand why we chose to store

00:34:53.210 --> 00:34:56.290
the result in the database.
The application has the option to go back

00:34:56.290 --> 00:35:03.500
to the database and figure out exactly what
happened with this particular pending request

00:35:03.500 --> 00:35:10.050
while it was maybe destroyed, maybe paused,
and so on.

00:35:10.050 --> 00:35:14.270
Remember, that operation -- that long-running
operation, the REST method, was running, because

00:35:14.270 --> 00:35:20.070
it executed in the content of a service, and
the operating system said, "Okay, I'm good,

00:35:20.070 --> 00:35:24.800
just going to leave this particular process
alone, because it's executing what it thinks

00:35:24.800 --> 00:35:28.870
it's important."
So that's great.

00:35:28.870 --> 00:35:35.690
On the return path, here we have the option
to receive callbacks from the ContentProvider

00:35:35.690 --> 00:35:40.150
itself.
The ContentProvider supports what's called

00:35:40.150 --> 00:35:45.630
content observers.
Content observers are simple ways to receive

00:35:45.630 --> 00:35:51.610
notifications from the ContentProvider when
data changes for a particular set of entries

00:35:51.610 --> 00:35:55.430
in a particular table.
That's a simple explanation, but that should

00:35:55.430 --> 00:35:58.310
do.
In other words, you can monitor the status

00:35:58.310 --> 00:36:08.060
of a particular row or maybe all the rows,
all the resources in that database.

00:36:08.060 --> 00:36:11.490
We reached the top.
Let's go -- take a full example and run with

00:36:11.490 --> 00:36:15.790
it.
The activity decides to create a portfolio.

00:36:15.790 --> 00:36:20.230
It says, okay, I'm going to call the simple
method in the service helper called "create

00:36:20.230 --> 00:36:23.750
portfolio."
The service helper says, okay, I'm going to

00:36:23.750 --> 00:36:28.990
 -- new intent, packet everything I need,
the name of the service, the currency, the

00:36:28.990 --> 00:36:35.590
binder callback, the type of operation, I'm
creating a portfolio, the unique request ID.

00:36:35.590 --> 00:36:38.850
It calls start service.
It says this particular operation is pending

00:36:38.850 --> 00:36:44.120
and returns the request ID to the caller.
The caller has the option to use this particular

00:36:44.120 --> 00:36:49.060
request idea to find out if this particular
REST method is still pending.

00:36:49.060 --> 00:36:53.280
Finally, the intent gets the service, the
service unpacks it, makes a Java call to the

00:36:53.280 --> 00:36:56.520
processor.
The processor said, what kind of method corresponds

00:36:56.520 --> 00:36:59.850
to this particular Java method?
Oh, this is a POST, I need to create a new

00:36:59.850 --> 00:37:03.490
stock portfolio.
So I'm going to go and insert that content

00:37:03.490 --> 00:37:06.540
into the database, in other words, I'm going
to create a row in the database.

00:37:06.540 --> 00:37:12.360
I'm going to set the status posting, I'm going
to set the transaction flag in the status

00:37:12.360 --> 00:37:16.140
column and I'm going to say, okay, I'm ready
to execute my REST method.

00:37:16.140 --> 00:37:23.340
The REST method prepares the URI parameters,
prepares the request body, if that's required

00:37:23.340 --> 00:37:28.780
 -- and for Google Finance, that's certainly
the case -- gets the callback once the REST

00:37:28.780 --> 00:37:34.040
method transacts with the server, it obviously
gets the parts resolved back from the REST

00:37:34.040 --> 00:37:36.550
method.
The processor says, okay, I'm going to update

00:37:36.550 --> 00:37:39.820
the state of this particular resource in the
database.

00:37:39.820 --> 00:37:45.450
So it updates the content, it updates the
flag by saying, okay, this particular method

00:37:45.450 --> 00:37:48.260
is no longer pending.
We assume, obviously, that it worked.

00:37:48.260 --> 00:37:55.660
And the ContentProvider, with fire notifications
as needed, if there are any kind of content

00:37:55.660 --> 00:37:59.320
observers.
On the return path, processor says to the

00:37:59.320 --> 00:38:00.580
service, thank you.
I'm done.

00:38:00.580 --> 00:38:07.650
Service says, okay, I'm going to invoke the
binder callback that was already in the intent.

00:38:07.650 --> 00:38:10.561
And, finally, if the service -- service helper
sales, you know what?

00:38:10.561 --> 00:38:14.400
This REST method is no longer pending.
I'm going to let any activities know about

00:38:14.400 --> 00:38:17.660
the result.
And the activities have the option to handle

00:38:17.660 --> 00:38:21.550
that callback and display to the users and
so forth.

00:38:21.550 --> 00:38:25.250
So that's a quick run through this particular
design pattern.

00:38:25.250 --> 00:38:29.510
Next one.
Based on a ContentProvider API.

00:38:29.510 --> 00:38:33.080
What is a ContentProvider?
For those of you who don't know, it's a simple

00:38:33.080 --> 00:38:38.360
way in Android to store and retrieve data
across process boundaries.

00:38:38.360 --> 00:38:44.700
Typically, a ContentProvider sits in front
of the database.

00:38:44.700 --> 00:38:50.610
It offers the insert, update, delete, and
query methods that, in the end, access the

00:38:50.610 --> 00:38:52.480
database.
Really simple stuff.

00:38:52.480 --> 00:38:56.030
I can go into details.
Hopefully, that explanation will be sufficient

00:38:56.030 --> 00:38:59.920
for the purpose of this discussion.
So the first question you're going to have

00:38:59.920 --> 00:39:05.300
from me, okay, how in the world did you get
to the conclusion that you can use a ContentProvider

00:39:05.300 --> 00:39:09.360
API to initiate REST methods?
Well, the answer is simple.

00:39:09.360 --> 00:39:15.900
There's a one-to-one mapping between REST
method types and method -- some of the methods

00:39:15.900 --> 00:39:20.520
in the ContentProvider.
So the get REST method corresponds to query

00:39:20.520 --> 00:39:24.600
in the database.
The POST REST method corresponds to insert.

00:39:24.600 --> 00:39:29.100
The PUT REST method corresponds to update.
And, finally, the DELETE REST method corresponds

00:39:29.100 --> 00:39:30.570
to delete.
Really simple.

00:39:30.570 --> 00:39:37.710
It's not hard to imagine how this works.
So here's the pattern that we can use.

00:39:37.710 --> 00:39:41.960
Let's say -- By the way, in this particular
diagram, the service helper, the service,

00:39:41.960 --> 00:39:47.710
the REST method work just as before.
The ContentProvider and the processor have

00:39:47.710 --> 00:39:53.170
a slightly different functionality, and we
can cover that once we go through an entire

00:39:53.170 --> 00:39:57.930
flow to this particular diagram.
So let's assume as before that we would like

00:39:57.930 --> 00:40:02.510
to create a stock portfolio.
The activity says, okay, this is going to

00:40:02.510 --> 00:40:07.220
be a creation, so that corresponds to a POST.
Obviously, I'm going to do an insert.

00:40:07.220 --> 00:40:09.900
It calls the insert -- prepares the content
values.

00:40:09.900 --> 00:40:14.360
For those of you who are not familiar, it's
just a way to specify the values that you

00:40:14.360 --> 00:40:18.300
would like to insert in specific columns in
the ContentProvider.

00:40:18.300 --> 00:40:22.170
Calls insert.
ContentProvider says, okay, I'm going to create

00:40:22.170 --> 00:40:25.460
this row for you.
And before it returns, however, it does a

00:40:25.460 --> 00:40:32.420
trick and says, "I understand that this particular
operation needs to execute a POST REST method."

00:40:32.420 --> 00:40:37.110
So it initiates, with the help of the service
helper, the POST method.

00:40:37.110 --> 00:40:43.320
It returns the URI for the new list -- the
caller, the activity in this case.

00:40:43.320 --> 00:40:47.210
It says, okay, I inserted for you, and by
the way, I'm going to keep the transactional

00:40:47.210 --> 00:40:53.790
state for this particular resource.
The state posting will be on, the transactional

00:40:53.790 --> 00:41:00.400
flag -- transactioning flag will be on.
And, finally, the activity has the option

00:41:00.400 --> 00:41:05.390
to use these flags, should it need, to display
the status of this particular resource while

00:41:05.390 --> 00:41:10.400
it's transitioning in the UI.
That's up to the application.

00:41:10.400 --> 00:41:17.910
Or choose not to so this it at all, or, you
know, whatever policy would like to institute.

00:41:17.910 --> 00:41:21.420
Finally, the service helper calls the service,
executes the REST method.

00:41:21.420 --> 00:41:25.600
Once the REST method is successful, executes.
The processor says, okay.

00:41:25.600 --> 00:41:29.350
Because the REST method succeed, I'm going
to clear these flags, update the row.

00:41:29.350 --> 00:41:35.360
And the activity, maybe a cursor adapter,
any content observer, will have the ability

00:41:35.360 --> 00:41:40.750
to understand that this particular -- the
status of this particular resource has been

00:41:40.750 --> 00:41:43.820
updated.
By the way, in this case, if the REST method

00:41:43.820 --> 00:41:48.200
fails, it's up -- it's the responsibility
of the ContentProvider to say, okay, I'm going

00:41:48.200 --> 00:41:54.130
to set up an alarm here, and maybe after five
minutes, I'm going to retry it.

00:41:54.130 --> 00:41:59.110
And maybe I'll implement some nice exponential
backoff so I don't keep retrying, you know,

00:41:59.110 --> 00:42:05.520
and kill the battery in the process of doing
so.

00:42:05.520 --> 00:42:10.570
Please note that in this particular pattern,
we broke the ContentProvider contract a little

00:42:10.570 --> 00:42:15.370
bit.
For insert and update, everything works as

00:42:15.370 --> 00:42:17.810
expected.
You're calling insert.

00:42:17.810 --> 00:42:21.490
We insert the resource right away into the
database as a row.

00:42:21.490 --> 00:42:25.300
For update, we do the same thing.
We update the resource as the database -- forget,

00:42:25.300 --> 00:42:28.790
we do something funny.
In other words, for query, we do something

00:42:28.790 --> 00:42:31.620
funny.
We go to the database first.

00:42:31.620 --> 00:42:36.700
We'll get the rows that already exist.
Now we have a cursor, and this is the cursor

00:42:36.700 --> 00:42:43.540
that a query typically returns to the caller.
Now, if the activity would like to retrieve

00:42:43.540 --> 00:42:48.320
brand-new, fresh content from the server,
it has the option in the query URI to set

00:42:48.320 --> 00:42:53.770
a flag and say, I would like to also get the
latest data from the server.

00:42:53.770 --> 00:42:58.100
So the ContentProvider says, okay, not only
am I going to give you the results in the

00:42:58.100 --> 00:43:02.570
cursor, but also I'm going to let the service
helper know that it's time to execute a get

00:43:02.570 --> 00:43:07.290
method maybe in the refresh mode to say, just
give me items that are newer than the one

00:43:07.290 --> 00:43:13.150
I have.
Delete breaks the contract.

00:43:13.150 --> 00:43:16.410
For delete, you say, I'm going to just tag
this row for deletion.

00:43:16.410 --> 00:43:21.160
I'm not going to delete it right away.
And, finally, the row gets deleted once the

00:43:21.160 --> 00:43:24.240
particular delete REST method has completed.
It's not a big deal.

00:43:24.240 --> 00:43:30.250
You just need to think about it.
And maybe once you display your results in

00:43:30.250 --> 00:43:35.050
a list activity with a cursor, again look
at the flag to see what is the state of that

00:43:35.050 --> 00:43:38.130
particular resource in the database there.
There are other ways to do this.

00:43:38.130 --> 00:43:44.570
You can remove the row from the database,
possibly move it to another table where you're

00:43:44.570 --> 00:43:52.880
going to be able to retry delete requests.
Again, we're not forcing you to adopt these

00:43:52.880 --> 00:44:04.930
particular design patterns.
The last pattern is simply a variant of the

00:44:04.930 --> 00:44:08.040
previous one.
We're still going to use the ContentProvider

00:44:08.040 --> 00:44:11.470
API.
But we're going to use the help of a sync

00:44:11.470 --> 00:44:13.550
adapter.
How many of you know what a sync adapter is?

00:44:13.550 --> 00:44:20.720
I was afraid of that.
The sync adapter is a concept that you should

00:44:20.720 --> 00:44:24.420
learn as soon as you get home and you start
developing for applications.

00:44:24.420 --> 00:44:34.170
What it is is the ability of the system to
help you synchronize remote and local content.

00:44:34.170 --> 00:44:41.150
The system employs the help of a service manager
 -- I'm sorry, a sync manager.

00:44:41.150 --> 00:44:45.670
The sync manager manages all the sync adapters
across all apps.

00:44:45.670 --> 00:44:52.260
The sync adapters are simply services started
by the sync manager.

00:44:52.260 --> 00:44:56.560
The sync manager implements a queue of sync
adapters.

00:44:56.560 --> 00:45:02.500
In other words, if you say I would like to
sync my data, there's a request sync method

00:45:02.500 --> 00:45:08.750
in the sync manager.
It does not mean that the sync manager will

00:45:08.750 --> 00:45:13.420
say, sure, right away.
What it does instead, it queues the execution

00:45:13.420 --> 00:45:20.770
of this particular adapter behind any other
sync adapters that need to execute.

00:45:20.770 --> 00:45:26.460
By the way, even if the queue is empty, the
sync manager has the option of saying, okay.

00:45:26.460 --> 00:45:28.440
I'll get to it.
Why does it do that?

00:45:28.440 --> 00:45:32.200
Why doesn't the sync manager just run out
there and start your sync operation right

00:45:32.200 --> 00:45:35.530
away?
Well, the reason is, is because it's trying

00:45:35.530 --> 00:45:42.560
to preserve the integrity of the entire system.
What if you start your GMail sync with an

00:45:42.560 --> 00:45:47.670
e-mail sync, you develop your own app.
All of a sudden you have four apps executing

00:45:47.670 --> 00:45:51.670
these sync operations in parallel.
They all do network transactions.

00:45:51.670 --> 00:45:55.000
They all do parsing.
They all do database operations.

00:45:55.000 --> 00:45:58.790
It's a mess.
Don't do that.

00:45:58.790 --> 00:46:02.080
Also, when you -- obviously, the sync adapter
is going to help you, it's going to prevent

00:46:02.080 --> 00:46:06.930
you from getting into that trouble.
But the characteristic of a sync adapter is

00:46:06.930 --> 00:46:12.190
that it does not execute maybe as fast as
you would like to.

00:46:12.190 --> 00:46:17.040
So with that in mind, let's look at this pattern.
Activity works the same way.

00:46:17.040 --> 00:46:20.880
You need to create a stock portfolio.
You call insert into the ContentProvider.

00:46:20.880 --> 00:46:26.081
The ContentProvider creates that row in the
database that sets its -- a transitional state

00:46:26.081 --> 00:46:28.350
to whatever it needs to be.
That's it.

00:46:28.350 --> 00:46:33.680
It returns to say thank you, I'm done.
So how does the REST method execute?

00:46:33.680 --> 00:46:36.940
That's where the sync adapter comes in.
Well, I lied.

00:46:36.940 --> 00:46:41.110
The ContentProvider, before returning, calls
request sync.

00:46:41.110 --> 00:46:46.700
It says, when you have a chance, come back
to me, start my sync adapter.

00:46:46.700 --> 00:46:52.670
The sync adapter starts, looks in the database,
and asks, are there any resources that are

00:46:52.670 --> 00:46:56.450
in the transitional state at this point?
Yes.

00:46:56.450 --> 00:46:58.060
Here's our resource.
It needs to be posted.

00:46:58.060 --> 00:47:03.460
It goes, reads the row from the database,
starts the REST method, executes it, gets

00:47:03.460 --> 00:47:06.660
the result, updates the database, and says
done.

00:47:06.660 --> 00:47:09.460
What if it fails?
Well, awesome.

00:47:09.460 --> 00:47:15.530
The sync adapters have the ability to handle
errors nicely, in other words, I should say

00:47:15.530 --> 00:47:20.730
the sync manager.
The sync adapter is responsible for simply

00:47:20.730 --> 00:47:25.370
throwing errors back to the sync manager.
The sync manager says, hmm, there was an error

00:47:25.370 --> 00:47:30.180
while I tried to sync this, you know what,
by implementing exponential backoff, I'll

00:47:30.180 --> 00:47:34.880
queue this particular sync adapter behind
any others, if any, and I'm going to restart

00:47:34.880 --> 00:47:39.050
this sync when I have a chance.
All of that is already there for you.

00:47:39.050 --> 00:47:43.800
You don't have to write your code with alarms.
You don't have to do all this stuff.

00:47:43.800 --> 00:47:51.260
All you have to do is learn how to report
errors from the sync adapter to the sync manager.

00:47:51.260 --> 00:47:56.400
All our applications use the content of the
sync adapter to refresh content.

00:47:56.400 --> 00:48:00.140
GMail, e-mail, all these apps use that particular
concept.

00:48:00.140 --> 00:48:11.430
Please use it in your apps.
In conclusion, please do not implement REST

00:48:11.430 --> 00:48:13.930
methods inside activities.
It's poor practice.

00:48:13.930 --> 00:48:19.310
An activity is a piece of user interface.
It's no different than any other Java framework

00:48:19.310 --> 00:48:22.940
you work with.
It's -- there's a clear separation there between

00:48:22.940 --> 00:48:29.670
user -- user interface and functionality.
Always start a long-running operations from

00:48:29.670 --> 00:48:35.010
a service.
Also, always stop the service while -- if

00:48:35.010 --> 00:48:41.690
all the pending transactions have completed.
Always remember that the service executes

00:48:41.690 --> 00:48:45.180
in the context of the main thread.
If you need to execute these long-running

00:48:45.180 --> 00:48:48.801
operations, start a worker thread in order
to execute these operations.

00:48:48.801 --> 00:48:54.960
SQLite is your friend.
Persist early and persist often.

00:48:54.960 --> 00:49:00.510
What does that mean?
POST PUT insert as soon as you can.

00:49:00.510 --> 00:49:05.160
Update is as soon as you can.
Once you get the result, do it again, if you

00:49:05.160 --> 00:49:10.870
think that's a smart thing to do.
Please don't let your database grow infinitely.

00:49:10.870 --> 00:49:14.270
Think about this: You keep getting new items
from the server.

00:49:14.270 --> 00:49:19.970
And all of a sudden your table holds thousands,
tens of thousands, of items.

00:49:19.970 --> 00:49:25.330
Well, your database grows.
It is the responsibility of your application

00:49:25.330 --> 00:49:28.920
to possibly purge old data.
Why is that a good idea?

00:49:28.920 --> 00:49:35.620
Not only because the user will be mad at you
because you made their phone useless, but

00:49:35.620 --> 00:49:42.310
because the cursor has the ability to hold
only about one megabyte of data.

00:49:42.310 --> 00:49:48.500
Beyond one megabyte, it will have to do windowing,
which is a very slow operation.

00:49:48.500 --> 00:49:54.290
Don't hold a lot of data in these cursors.
For example, images.

00:49:54.290 --> 00:49:59.830
If you use images in your cursor, which absolutely
you could, what you're doing is, you're taking

00:49:59.830 --> 00:50:05.610
away from your ability to store more items
in a cursor.

00:50:05.610 --> 00:50:09.990
Minimize network usage.
Only request data that's newer than the one

00:50:09.990 --> 00:50:12.810
you have.
Older than the one you have, but don't go

00:50:12.810 --> 00:50:16.180
back to the server and get that one again.
Page data.

00:50:16.180 --> 00:50:21.431
If you don't page data, you are retrieving
this huge amount of data from the server.

00:50:21.431 --> 00:50:24.760
It takes time.
You parse it, takes a lot of time to parse

00:50:24.760 --> 00:50:30.810
it. You insert it in a database.
That application will never perform fast enough.

00:50:30.810 --> 00:50:34.810
Always use paging.
Hosting, the REST API that you're using sports

00:50:34.810 --> 00:50:39.610
paging.
Finally, use a sync adapter to synchronize

00:50:39.610 --> 00:50:43.440
the content of your local database with the
state of your server.

00:50:43.440 --> 00:50:49.720
We're very happy to announce here at Google
I/O that the Android cloud-to-device message

00:50:49.720 --> 00:50:55.000
is now available.
You won't have to set up an alarm in order

00:50:55.000 --> 00:51:00.170
to continuously start the sync adapter and
ask the server, are you done?

00:51:00.170 --> 00:51:03.620
Do you have new data?
Do you have new data?

00:51:03.620 --> 00:51:06.880
Use the push notification.
Of course it takes an effort on your behalf.

00:51:06.880 --> 00:51:13.080
I warmly recommend this afternoon's session
on the Android cloud-to-device messaging.

00:51:13.080 --> 00:51:21.420
I would save a lot of battery life for a particular
phone when using this technology.

00:51:21.420 --> 00:51:25.950
If you use all these techniques in your REST
method and you create your own, -- let us

00:51:25.950 --> 00:51:32.770
know, by the way, we're happy to hear from
you -- you will create awesome REST client

00:51:32.770 --> 00:51:39.070
applications, very performant, and the user
will simply enjoy using it maybe over a Web

00:51:39.070 --> 00:51:42.690
browser that accesses that same service.
Thank you.

00:51:42.690 --> 00:51:52.460
[ Applause ]
&gt;&gt;Virgil Dobjanschi: So I'll take some questions

00:51:52.460 --> 00:52:06.170
now.
&gt;&gt;&gt; Excuse me?

00:52:06.170 --> 00:52:09.820
&gt;&gt;&gt; Ladies and gentlemen, if you have any
questions, please go to the microphone, and

00:52:09.820 --> 00:52:40.900
we'll be with you in a moment.
&gt;&gt;Virgil Dobjanschi: So any questions?

00:52:40.900 --> 00:52:41.900
I'm sorry.
Go ahead.

00:52:41.900 --> 00:52:47.420
&gt;&gt;&gt; Yes, I have actually two questions.
One is, what are the advantages of intent-based

00:52:47.420 --> 00:52:53.520
service invocations versus AIDL?
And second is, would the person need to approve

00:52:53.520 --> 00:52:59.640
the sync adapter in the settings account and
sync UI for your sync adapter to work?

00:52:59.640 --> 00:53:03.061
&gt;&gt;Virgil Dobjanschi: I need you to repeat
the second question.

00:53:03.061 --> 00:53:10.080
&gt;&gt;&gt; The second part is, the -- would user
have to explicitly approve your sync adapter

00:53:10.080 --> 00:53:13.290
in the settings UI for your sync adapter to
work?

00:53:13.290 --> 00:53:18.130
&gt;&gt;Virgil Dobjanschi: So the answer to the
second question is yes.

00:53:18.130 --> 00:53:25.720
One of the nice things about the sync adapter,
it obeys the user settings on a per-account

00:53:25.720 --> 00:53:30.530
basis, which is fantastic.
Because sync adapters are linked to accounts.

00:53:30.530 --> 00:53:35.390
So you can even say I don't want -- the user
can say, I don't want this sync adapter to

00:53:35.390 --> 00:53:40.970
run all the time.
You can -- it can select which ones it will

00:53:40.970 --> 00:53:44.820
actually run.
Also, it will base the contract of out of

00:53:44.820 --> 00:53:48.760
sync and data, let's say you're traveling.
What's going to happen?

00:53:48.760 --> 00:53:54.860
Well, you probably didn't subscribe for roaming,
and you don't want your sync to go in the

00:53:54.860 --> 00:53:57.390
background.
There's a framework that takes care of that

00:53:57.390 --> 00:54:01.010
and it obeys that.
That's one of the great reasons to use a sync

00:54:01.010 --> 00:54:04.240
adapter.
&gt;&gt;&gt; So in this question, if ContentProvider

00:54:04.240 --> 00:54:10.800
kicked off the sync, but the user have never
yet approved the sync adapter, it will not

00:54:10.800 --> 00:54:12.660
sync?
&gt;&gt;Virgil Dobjanschi: It's not a manual -- it's

00:54:12.660 --> 00:54:16.260
not one of those permission things.
It's a setting for the platform.

00:54:16.260 --> 00:54:17.650
&gt;&gt;&gt; Okay.
&gt;&gt;Virgil Dobjanschi: So you have to go to

00:54:17.650 --> 00:54:21.460
settings and not even in your application
rather than the phone settings and approve

00:54:21.460 --> 00:54:24.040
it.
I know you had a first question.

00:54:24.040 --> 00:54:25.040
I apologize.
&gt;&gt;&gt; Sure.

00:54:25.040 --> 00:54:28.850
&gt;&gt;Virgil Dobjanschi: What was the first question?
&gt;&gt;&gt; The first question was, was the advantages

00:54:28.850 --> 00:54:32.360
of the intent-based service notification versus
AIDL.

00:54:32.360 --> 00:54:34.620
&gt;&gt;Virgil Dobjanschi: So there's a difference
there.

00:54:34.620 --> 00:54:39.540
That's a very complex subject.
Please look at the API of a service.

00:54:39.540 --> 00:54:45.180
In order to use the interface, the binding,
you have to actually bind to that service.

00:54:45.180 --> 00:54:49.350
You have to connect to it.
That's an asynchronous call.

00:54:49.350 --> 00:54:53.240
And you may not want to deal with the complexity
of it.

00:54:53.240 --> 00:54:58.990
The intent, on the other hand, it's very simple.
You can say, here's this intent, but note

00:54:58.990 --> 00:55:02.860
that that particular operation always executes
asynchronously.

00:55:02.860 --> 00:55:07.240
Whereas in the binder call, you have the option
to execute it synchronously.

00:55:07.240 --> 00:55:10.390
Poor design by the way, but you have no option
to do so.

00:55:10.390 --> 00:55:20.610
&gt;&gt;&gt; Hi. Thank you.
I recently came across a very useful class

00:55:20.610 --> 00:55:27.060
called intent service.
And I was wondering if -- I mean, it seems

00:55:27.060 --> 00:55:29.440
like this would be a -- like, exactly the
kind of place that you would want to use that

00:55:29.440 --> 00:55:31.350
service it.
Handles, like, the threading and everything

00:55:31.350 --> 00:55:33.710
automatically.
Do you think that's a good idea or, like,

00:55:33.710 --> 00:55:38.300
do you have any recommendations about using
or not using that class?

00:55:38.300 --> 00:55:42.640
&gt;&gt;Virgil Dobjanschi: I wanted to simplify
the content of the presentation.

00:55:42.640 --> 00:55:48.130
Intent services are great.
If what you want is to execute a long-running

00:55:48.130 --> 00:55:53.431
operation in the content of the worker thread,
the intent service can certainly help you

00:55:53.431 --> 00:55:56.970
with that.
In our case, however, I don't know if you

00:55:56.970 --> 00:56:03.700
picked up on this, everything happens asynchronously.
So I didn't have a huge need for it.

00:56:03.700 --> 00:56:05.030
Can you do it?
Absolutely.

00:56:05.030 --> 00:56:10.410
And, actually, it's a very good way of not
having to deal yourself to create that particular

00:56:10.410 --> 00:56:12.330
worker thread.
It will be created for you.

00:56:12.330 --> 00:56:14.190
So, yes, absolutely yes.
&gt;&gt;&gt; Okay.

00:56:14.190 --> 00:56:18.330
And I had a second quick question.
You said that you don't need to set a flag

00:56:18.330 --> 00:56:24.200
for the get method in your database.
And I'm wondering if I'm missing something

00:56:24.200 --> 00:56:28.230
or, like, if there is something that I might
be fetching an update for from the database,

00:56:28.230 --> 00:56:33.390
so it's something that already exists in the
 -- on the server and I've retrieve it before

00:56:33.390 --> 00:56:37.420
and now I want to see if, like, there's some
value in one of the fields and the rows have

00:56:37.420 --> 00:56:42.220
changed and I want to see if I'm getting updates
for this row, I would have to set a state

00:56:42.220 --> 00:56:45.300
for --
&gt;&gt;Virgil Dobjanschi: Is it too late for me

00:56:45.300 --> 00:56:46.670
to change that?
No.

00:56:46.670 --> 00:56:51.070
Yes, it's a good -- The problem is that you
didn't get anything yet.

00:56:51.070 --> 00:56:56.410
What are you setting these flags into?
&gt;&gt;&gt; No, I mean, it's a resource that you have

00:56:56.410 --> 00:57:00.280
retrieved, but you want to check to see if,
like, a value in that row has been updated.

00:57:00.280 --> 00:57:05.890
&gt;&gt;Virgil Dobjanschi: However, the flags I
was describing were specific to a particular

00:57:05.890 --> 00:57:10.380
resource, not for items that you haven't yet
retrieved.

00:57:10.380 --> 00:57:16.050
That type of status is okay if you store in
memory.

00:57:16.050 --> 00:57:20.150
We can -- if you want more, I'm happy to discuss
this with you after.

00:57:20.150 --> 00:57:21.150
&gt;&gt;&gt; Okay.
Great.

00:57:21.150 --> 00:57:26.130
&gt;&gt;Virgil Dobjanschi: Thank you.
Let me take a question, actually, from Wave

00:57:26.130 --> 00:57:30.620
users.
Unfortunately, we're not going to be able

00:57:30.620 --> 00:57:37.200
to show any calls.
Wow.

00:57:37.200 --> 00:57:40.200
The question regarding the Apache HTTP client
versus Java.

00:57:40.200 --> 00:57:48.010
That's a very good question.
I would simply advise that you use the HTTP

00:57:48.010 --> 00:57:53.760
Apache client, because it has a more robust
implementation.

00:57:53.760 --> 00:58:02.380
The URL connection type of HTTP transaction
is not the most efficient implementation.

00:58:02.380 --> 00:58:08.650
And the way it terminates connections sometimes
can have an adverse effect on the network.

00:58:08.650 --> 00:58:10.940
Let's leave it at that.
Sorry.

00:58:10.940 --> 00:58:14.600
Let's go.
&gt;&gt;&gt; Yeah, I do have a question on, say, if

00:58:14.600 --> 00:58:19.420
you have a search use case in the application,
do you still recommend to persist that in

00:58:19.420 --> 00:58:23.940
the database, because user is very unlikely
that he's going to come back and use that

00:58:23.940 --> 00:58:27.410
data again at a later stage.
&gt;&gt;Virgil Dobjanschi: So you're not referring

00:58:27.410 --> 00:58:31.440
to search across resources you already have
in the database?

00:58:31.440 --> 00:58:33.300
&gt;&gt;&gt; Right, yeah.
&gt;&gt;Virgil Dobjanschi: So you're going across

00:58:33.300 --> 00:58:39.790
the network.
I'm sorry to say, it's best left to the implementation

00:58:39.790 --> 00:58:40.910
of the app.
&gt;&gt;&gt; Okay.

00:58:40.910 --> 00:58:45.190
&gt;&gt;Virgil Dobjanschi: Apps that I worked on
had different requirements.

00:58:45.190 --> 00:58:47.460
Because this is a requirement of the user
interface.

00:58:47.460 --> 00:58:52.290
For example, should you initiate requests.
&gt;&gt;&gt; As you're typing?

00:58:52.290 --> 00:58:56.070
&gt;&gt;Virgil Dobjanschi: Should you initiate these
searches at every single key that's being

00:58:56.070 --> 00:58:58.770
typed?
Or should you wait until the user has said,

00:58:58.770 --> 00:59:01.480
okay, let me search now?
Up to you.

00:59:01.480 --> 00:59:07.020
Of course, you're overwhelming the network
with requests once you're doing a search,

00:59:07.020 --> 00:59:13.430
especially if you don't have some good policy
in the lower layer to say, "Ignore this response.

00:59:13.430 --> 00:59:16.300
Ignore this response," because the user is
still typing.

00:59:16.300 --> 00:59:20.720
Otherwise, you keep parsing, you keep inserting
possibly results in the database while the

00:59:20.720 --> 00:59:23.781
user is still typing.
So it's probably not the best way to do it.

00:59:23.781 --> 00:59:27.089
But there are absolutely -- I have nothing
against that.

00:59:27.089 --> 00:59:29.460
&gt;&gt;&gt; Thanks.
&gt;&gt;Virgil Dobjanschi: Sure.

00:59:29.460 --> 00:59:33.930
I'm sorry. We have time for one more question.
Not even one.

00:59:33.930 --> 00:59:37.480
I'm sorry.
If you have any more questions, please talk

00:59:37.480 --> 00:59:39.130
to me right now after the session.
[ Applause ]

