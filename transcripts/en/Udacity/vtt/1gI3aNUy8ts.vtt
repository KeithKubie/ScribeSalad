WEBVTT
Kind: captions
Language: en

00:00:00.410 --> 00:00:02.960
Let's dive deeper into the similarities.

00:00:02.960 --> 00:00:05.545
Building the portfolio apps for
the iOS nano degree,

00:00:05.545 --> 00:00:10.060
you've become intimately familiar with
the classes and foundation and UI Kit.

00:00:10.060 --> 00:00:12.200
Those classes are bridged to Swift.

00:00:12.200 --> 00:00:13.550
But as you may know by now,

00:00:13.550 --> 00:00:16.910
many of those classes are actually
written in Objective C.

00:00:16.910 --> 00:00:19.940
This means that the way they're
used in Objective C will look and

00:00:19.940 --> 00:00:23.180
feel very similar to the way
you use them in Swift.

00:00:23.180 --> 00:00:25.490
Let's take a look at an example.

00:00:25.490 --> 00:00:28.980
The following code snippets are taken
from a custom view controller class that

00:00:28.980 --> 00:00:31.260
inherits from U.I. view controller.

00:00:31.260 --> 00:00:33.960
In the code snippet here,
you can see the familiar U.I.

00:00:33.960 --> 00:00:37.032
view controller method, viewWillAppear.

00:00:37.032 --> 00:00:40.650
The Objective-C syntax will certainly
seem foreign at this point but

00:00:40.650 --> 00:00:44.870
let's focus on what we can find in
common between the two implementations.

00:00:44.870 --> 00:00:46.820
Just as you would do with Swift,

00:00:46.820 --> 00:00:51.030
you start out by calling the
viewWillAppear method of the superclass.

00:00:51.030 --> 00:00:55.010
After that, you call any methods
necessary to prepare the view before it

00:00:55.010 --> 00:00:58.245
appears, in this case
the method displayResult.

00:00:59.350 --> 00:01:02.890
By the way, if you ever find yourself
needing more time to read through

00:01:02.890 --> 00:01:05.239
the code examples,
go ahead and pause the video.

00:01:06.760 --> 00:01:08.760
Let's take a look at another example.

00:01:08.760 --> 00:01:11.850
Here are some of the methods
of the AppDelegate Protocol.

00:01:11.850 --> 00:01:15.943
You'll notice that if you create a new
project template in Xcode, whether it's

00:01:15.943 --> 00:01:20.053
an Objective-C or Swift, the same six
AppDelegate methods appear by default.

00:01:20.053 --> 00:01:23.284
I'm just showing the first four here but
you get the idea.

00:01:23.284 --> 00:01:25.145
And here they are in Swift.

00:01:25.145 --> 00:01:28.190
And here they are in Objective-C.

00:01:28.190 --> 00:01:32.400
These methods manage transitions between
the five main application states.

00:01:32.400 --> 00:01:36.950
Active, background, not running,
inactive, and suspended.

00:01:36.950 --> 00:01:39.292
These five states are language agnostic.

00:01:39.292 --> 00:01:42.855
And the transitions between them
are handled identically in Swift and

00:01:42.855 --> 00:01:43.707
Objective-C.

00:01:43.707 --> 00:01:45.763
As an iOS developer joining a new team,

00:01:45.763 --> 00:01:49.815
digging through your colleagues'
Objective-C code, you can expect to see

00:01:49.815 --> 00:01:53.820
many familiar classes and
methods from UI Kit and Foundation.

00:01:53.820 --> 00:01:57.388
Let's talk about another similarity
between iOS development in Swift in

00:01:57.388 --> 00:02:00.130
Objective-C, design patterns.

00:02:00.130 --> 00:02:02.560
Whether you're writing in Swift or
Objective-C,

00:02:02.560 --> 00:02:04.640
you'll be using principles
like the delegate and

00:02:04.640 --> 00:02:08.220
Model View Controller patterns to
guide the architecture of your app.

00:02:08.220 --> 00:02:12.130
For example, in conjunction with the
delegate pattern, both Objective-C and

00:02:12.130 --> 00:02:14.920
Swift make extensive use of protocols.

00:02:14.920 --> 00:02:15.680
Part of the need for

00:02:15.680 --> 00:02:19.740
protocols stems from both languages
having single inheritance.

00:02:19.740 --> 00:02:22.980
A given class can only
inherit from one other class.

00:02:22.980 --> 00:02:24.680
Instead of multiple inheritance,

00:02:24.680 --> 00:02:30.110
both languages employ protocols to share
functionality across unrelated classes.

00:02:30.110 --> 00:02:34.940
Let's take a look at an example from the
familiar UITextFieldDelegateProtocol.

00:02:34.940 --> 00:02:38.970
Here's an implementation of the
shouldChangeCharactersInRange method for

00:02:38.970 --> 00:02:40.745
a text field accepting a zip code.

00:02:40.745 --> 00:02:44.414
Here it is in Swift, and
here it is in Objective-C.

00:02:44.414 --> 00:02:47.340
Here are the two signatures together,
and

00:02:47.340 --> 00:02:51.100
here we see the body of the method for
each.

00:02:51.100 --> 00:02:54.540
Notice that the two implementations
are incredibly similar.

00:02:54.540 --> 00:02:58.770
The use of protocols across Objective-C
and Swift engenders continuity across

00:02:58.770 --> 00:03:02.720
iOS apps at the scale of app
architecture and on a more

00:03:02.720 --> 00:03:06.470
granular scale, as the two languages
employ many of the same protocols.

