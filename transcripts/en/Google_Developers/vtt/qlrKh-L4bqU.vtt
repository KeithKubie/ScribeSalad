WEBVTT
Kind: captions
Language: en

00:00:04.030 --> 00:00:06.270
SCOTT: Hi everyone, and welcome
to our talk on taking

00:00:06.270 --> 00:00:08.670
advantage of Android
platform features.

00:00:08.670 --> 00:00:10.080
I'm Scott, and this is Vikram.

00:00:10.080 --> 00:00:12.550
And we're both engineers who
work on Android applications.

00:00:12.550 --> 00:00:14.840
VIKRAM: Right.

00:00:14.840 --> 00:00:18.640
So let's start with who the
intended audience is, who we

00:00:18.640 --> 00:00:23.350
think you are, and what you
should gain out of this talk.

00:00:23.350 --> 00:00:25.730
This stock is aimed at
intermediate Android

00:00:25.730 --> 00:00:26.260
developers.

00:00:26.260 --> 00:00:28.990
I know it says advanced But
it's all right if you're

00:00:28.990 --> 00:00:29.870
intermediate.

00:00:29.870 --> 00:00:31.740
This is not an introductory
talk.

00:00:31.740 --> 00:00:35.340
We're hoping that you are
developers who have an

00:00:35.340 --> 00:00:37.670
application on the Play Store.

00:00:37.670 --> 00:00:41.290
You have features that you
hope to implement.

00:00:41.290 --> 00:00:43.020
You have some bugs.

00:00:43.020 --> 00:00:44.080
Probably not you guys--

00:00:44.080 --> 00:00:46.520
I can tell you guys don't
have many, many bugs.

00:00:46.520 --> 00:00:48.550
We got some bugs.

00:00:48.550 --> 00:00:52.580
But for developers like you,
two big goals stand out.

00:00:52.580 --> 00:00:57.810
The first goal is to improve
your consumer experience.

00:00:57.810 --> 00:01:00.450
Consumers like applications
that are well behaved.

00:01:00.450 --> 00:01:03.720
They like applications that
are responsive and smooth,

00:01:03.720 --> 00:01:05.830
applications that work
well on the system,

00:01:05.830 --> 00:01:08.290
consume less battery.

00:01:08.290 --> 00:01:11.350
And the second is to improve
your own productivity.

00:01:11.350 --> 00:01:14.310
You can implement features
faster, and you can squash

00:01:14.310 --> 00:01:19.060
bugs quicker if you can
work faster yourself.

00:01:19.060 --> 00:01:22.660
So if you can do those two
things, that allows you to

00:01:22.660 --> 00:01:25.375
make apps that invite
more users.

00:01:25.375 --> 00:01:26.540
And so you get more money.

00:01:26.540 --> 00:01:30.340
And that keeps you in business

00:01:30.340 --> 00:01:31.920
SCOTT: I think that slide still
has too many words.

00:01:31.920 --> 00:01:33.575
We were told to reduce
bullets.

00:01:33.575 --> 00:01:35.200
VIKRAM: Yeah, when were going
through this, they kept

00:01:35.200 --> 00:01:37.110
telling us, cut down
on bullets.

00:01:37.110 --> 00:01:39.060
So we have a special
slide for you guys.

00:01:41.610 --> 00:01:43.370
If this doesn't fit the
bill, you're probably

00:01:43.370 --> 00:01:45.840
in the wrong room.

00:01:45.840 --> 00:01:46.250
OK, wow.

00:01:46.250 --> 00:01:47.500
Nobody left, good.

00:01:50.020 --> 00:01:51.340
So a little bit about us.

00:01:51.340 --> 00:01:53.550
We wrote the Gmail app.

00:01:53.550 --> 00:02:00.470
[APPLAUSE]

00:02:00.470 --> 00:02:01.790
SCOTT: That's not
entirely true.

00:02:01.790 --> 00:02:03.380
It wasn't just the two of us.

00:02:03.380 --> 00:02:04.705
There are others.

00:02:04.705 --> 00:02:05.360
VIKRAM: Yeah, you're right.

00:02:05.360 --> 00:02:07.320
We have to be honest
in this crowd.

00:02:07.320 --> 00:02:12.890
We wrote Gmail along with many
other qualified engineers.

00:02:12.890 --> 00:02:14.520
SCOTT: Keep going.

00:02:14.520 --> 00:02:16.510
VIKRAM: OK, this is
a tough crowd.

00:02:16.510 --> 00:02:17.640
We wrote Gmail.

00:02:17.640 --> 00:02:19.190
We're in a smaller team.

00:02:19.190 --> 00:02:22.905
And we're the only ones
who are free.

00:02:22.905 --> 00:02:24.110
No--

00:02:24.110 --> 00:02:25.815
SCOTT: We are engineers
on Gmail.

00:02:25.815 --> 00:02:27.910
VIKRAM: We're engineers
on Gmail.

00:02:27.910 --> 00:02:29.000
We have a big team.

00:02:29.000 --> 00:02:31.420
We also have a lot of users.

00:02:31.420 --> 00:02:35.780
Gmail and email is used by
over 100 million users.

00:02:35.780 --> 00:02:39.060
Think about that for a minute
a bug that impacts 1% of our

00:02:39.060 --> 00:02:42.880
pocket still impact over
a million people.

00:02:42.880 --> 00:02:47.380
So squashing bugs is
a big deal for us.

00:02:47.380 --> 00:02:50.120
We also need to constantly
improve the user experience.

00:02:50.120 --> 00:02:51.550
Mobile moves really fast.

00:02:51.550 --> 00:02:53.720
People expect features.

00:02:53.720 --> 00:02:55.210
And the speed of iteration
is critical

00:02:55.210 --> 00:02:56.510
to every app's success.

00:02:56.510 --> 00:03:00.710
It's clear that it's critical
to your app's success, too.

00:03:00.710 --> 00:03:03.176
So hopefully, you can
take something

00:03:03.176 --> 00:03:05.330
out of our best practices.

00:03:05.330 --> 00:03:08.700
Perhaps, applied to your app,
it might help in improving

00:03:08.700 --> 00:03:10.721
your lives.

00:03:10.721 --> 00:03:12.950
Our overall approach
is to rely on the

00:03:12.950 --> 00:03:15.210
framework very heavily.

00:03:15.210 --> 00:03:18.320
The more that the framework
does, the less

00:03:18.320 --> 00:03:21.190
that we have to do.

00:03:21.190 --> 00:03:25.180
This means that the complexity
in our code base is reduced.

00:03:25.180 --> 00:03:29.700
And this allows us to iterate
faster, to iterate on features

00:03:29.700 --> 00:03:32.390
faster, to squash
bugs quicker.

00:03:32.390 --> 00:03:35.650
And this is a reinforcing
cycle because the lesser

00:03:35.650 --> 00:03:37.830
complex your code is,
the quicker you

00:03:37.830 --> 00:03:39.840
can iterate on features.

00:03:39.840 --> 00:03:42.300
And if you rely on the framework
for those features,

00:03:42.300 --> 00:03:45.090
you can iterate even
faster the next

00:03:45.090 --> 00:03:46.340
feature that comes along.

00:03:49.150 --> 00:03:51.960
So a great way to reduce
complexity in your course is

00:03:51.960 --> 00:03:54.680
to modularize your
UI components.

00:03:54.680 --> 00:04:00.620
And the way we do this is to
modularize our visual elements

00:04:00.620 --> 00:04:02.090
into fragments.

00:04:02.090 --> 00:04:05.670
Gmail and email use fragments
extensively.

00:04:05.670 --> 00:04:09.780
We have the same code that runs
on phone and on tablet,

00:04:09.780 --> 00:04:13.980
and we use XML resources to
give you the right layout.

00:04:16.570 --> 00:04:18.566
Here's an example
of this pattern.

00:04:18.566 --> 00:04:22.290
On the top half, above that
horizontal line, you can see

00:04:22.290 --> 00:04:25.470
an example of the layout
that we use on phone.

00:04:25.470 --> 00:04:27.685
It's a fragment that's specified
right in the XML.

00:04:30.980 --> 00:04:32.080
It's a list fragment.

00:04:32.080 --> 00:04:33.290
And it's the same list fragment

00:04:33.290 --> 00:04:34.360
that we use on tablets.

00:04:34.360 --> 00:04:38.650
The tablet XML is the bottom
half of that slide.

00:04:38.650 --> 00:04:40.620
And on tablet, since we have
more real estate, we can put

00:04:40.620 --> 00:04:42.170
two fragments side by side.

00:04:42.170 --> 00:04:44.330
And so we have a linear layout
with a list fragment and a

00:04:44.330 --> 00:04:47.420
content fragment.

00:04:47.420 --> 00:04:51.250
Having these sort reusable
components allows you to take

00:04:51.250 --> 00:04:54.230
advantage of framework features
fairly rapidly.

00:04:54.230 --> 00:04:57.020
So earlier this year, there
was this big framework

00:04:57.020 --> 00:05:00.530
feature, a big new feature that
we wanted to implement.

00:05:00.530 --> 00:05:03.610
And we had an intern do it for
us because, even though he was

00:05:03.610 --> 00:05:06.420
new to the code, the code was
already quite modular.

00:05:06.420 --> 00:05:09.090
And so he was able to implement
this all on his own.

00:05:09.090 --> 00:05:09.810
I mean, talk about impact.

00:05:09.810 --> 00:05:10.800
That was pretty impressive.

00:05:10.800 --> 00:05:12.230
SCOTT: Yeah, I wish
he was still here.

00:05:12.230 --> 00:05:15.096
He'd probably give a better
talk than us.

00:05:15.096 --> 00:05:15.940
VIKRAM: Yeah, that's true.

00:05:15.940 --> 00:05:18.350
He was quite something.

00:05:18.350 --> 00:05:20.350
We learned a lot when
he was here.

00:05:20.350 --> 00:05:22.510
We learned a lot about how
to handle fragments.

00:05:22.510 --> 00:05:25.430
So let's talk about
that for a minute.

00:05:25.430 --> 00:05:29.800
First, we do very little in
the fragments constructor.

00:05:29.800 --> 00:05:33.790
We perform all of our
initialization in the

00:05:33.790 --> 00:05:35.780
fragment's life cycle methods.

00:05:35.780 --> 00:05:40.760
And we don't maintain any
pointers because pointers

00:05:40.760 --> 00:05:44.700
don't last well because the
activities life cycle is very

00:05:44.700 --> 00:05:46.310
different from the fragments
life cycle.

00:05:46.310 --> 00:05:48.250
And so pointers will gets stale,
so we don't maintain

00:05:48.250 --> 00:05:50.590
any of those.

00:05:50.590 --> 00:05:52.070
That's a lot sort of
separate ideas.

00:05:52.070 --> 00:05:54.630
Let's look at them
in isolation.

00:05:54.630 --> 00:05:58.740
This is the general pattern
we use for a fragment.

00:05:58.740 --> 00:06:02.940
As you see, it has a single
variables, called state, it's

00:06:02.940 --> 00:06:04.220
a parcelable.

00:06:04.220 --> 00:06:06.770
And it's not initialized
in the constructor.

00:06:06.770 --> 00:06:09.300
Actually, we do nothing
in the constructor.

00:06:09.300 --> 00:06:10.470
That's secret Google code.

00:06:10.470 --> 00:06:11.720
We don't do anything
in the constructor.

00:06:14.910 --> 00:06:17.300
This means that you need to
get that state somehow.

00:06:17.300 --> 00:06:18.340
And we get it through
arguments.

00:06:18.340 --> 00:06:21.600
We get it in the onCreate
method, where there's a

00:06:21.600 --> 00:06:24.310
fragment method called
getArguments.

00:06:24.310 --> 00:06:26.690
And we have a string tag
called ARG_STATE.

00:06:26.690 --> 00:06:27.930
The string could be anything.

00:06:27.930 --> 00:06:30.500
But you get that parcelable.

00:06:30.500 --> 00:06:32.450
And you assign it in onCreate.

00:06:32.450 --> 00:06:35.430
This means that you have to
express your state as

00:06:35.430 --> 00:06:39.700
parcelables because, if it's a
native Java type, you're OK.

00:06:39.700 --> 00:06:42.630
But if it's not native, if it's
not an int or something,

00:06:42.630 --> 00:06:44.470
you have to express it
as a parcelable.

00:06:44.470 --> 00:06:46.630
But that turns out to be a good
thing to do because if

00:06:46.630 --> 00:06:49.450
you can express your state in
terms of parcelables, then you

00:06:49.450 --> 00:06:51.850
can pass it through Intents.

00:06:51.850 --> 00:06:54.460
You can give it to
other activities.

00:06:54.460 --> 00:06:56.040
So these kinds of patterns
lead to other

00:06:56.040 --> 00:06:57.290
benefits down the road.

00:07:01.230 --> 00:07:03.720
So you might wonder how we
construct these fragments.

00:07:03.720 --> 00:07:05.680
This is the pattern that we use
for constructing all of

00:07:05.680 --> 00:07:06.990
our fragments.

00:07:06.990 --> 00:07:09.520
We have a static new instance
method for every

00:07:09.520 --> 00:07:10.800
fragment that we use.

00:07:10.800 --> 00:07:13.990
And in this case, since there
was a single state variable,

00:07:13.990 --> 00:07:16.470
we pass it to the new
instance method.

00:07:16.470 --> 00:07:17.855
I see a couple of people
taking pictures.

00:07:17.855 --> 00:07:20.410
Don't worry, all of
this is there in--

00:07:20.410 --> 00:07:23.190
we have a sample app to explain
some of the stuff.

00:07:23.190 --> 00:07:25.820
So you don't need to get
any of these slides.

00:07:25.820 --> 00:07:26.620
But it's nice that you are.

00:07:26.620 --> 00:07:28.570
You could probably take pictures
of us while you're

00:07:28.570 --> 00:07:29.570
doing that.

00:07:29.570 --> 00:07:34.530
[LAUGHTER]

00:07:34.530 --> 00:07:36.280
VIKRAM: So that's how we
get all of the state.

00:07:36.280 --> 00:07:38.590
At this point, you're probably
wondering what happens to the

00:07:38.590 --> 00:07:41.980
pointers that you're
passing around?

00:07:41.980 --> 00:07:42.460
SCOTT: Not really.

00:07:42.460 --> 00:07:44.740
I'm wondering how I'll
remember any of this.

00:07:44.740 --> 00:07:47.420
VIKRAM: OK, yeah this shouldn't
be like school.

00:07:47.420 --> 00:07:49.200
Like I mentioned earlier,
if you can't

00:07:49.200 --> 00:07:50.080
remember any of this stuff--

00:07:50.080 --> 00:07:51.490
I have a terrible memory.

00:07:51.490 --> 00:07:54.910
We have a sample app with
many of these ideas

00:07:54.910 --> 00:07:56.650
that you can download.

00:07:56.650 --> 00:07:57.900
And you can see how
we do this.

00:08:00.460 --> 00:08:01.650
SCOTT: Just the app?

00:08:01.650 --> 00:08:02.400
VIKRAM: Just the sample app.

00:08:02.400 --> 00:08:03.930
Yeah-- oh yeah, source code.

00:08:03.930 --> 00:08:06.430
OK, we'll post source code along
with the sample app.

00:08:06.430 --> 00:08:09.990
Because the sample app itself
might not be useful.

00:08:09.990 --> 00:08:11.540
So that will be at the
end of the talk.

00:08:11.540 --> 00:08:13.120
So this is how we get
you guys to stay the

00:08:13.120 --> 00:08:15.880
entire 40 minute duration.

00:08:15.880 --> 00:08:17.100
Where was I?

00:08:17.100 --> 00:08:17.710
SCOTT: Pointers.

00:08:17.710 --> 00:08:19.010
VIKRAM: Pointers,
right pointers.

00:08:19.010 --> 00:08:22.460
So you might be wondering, if I
have pointers going back and

00:08:22.460 --> 00:08:25.442
forth, how exactly
do I manage that?

00:08:25.442 --> 00:08:28.250
That gets tricky with the
decoupled life cycle of the

00:08:28.250 --> 00:08:30.990
activity and the fragment
because you don't really know

00:08:30.990 --> 00:08:33.600
when a fragment will come in,
and when it'll go out.

00:08:33.600 --> 00:08:38.210
And so, for things like that,
we use a very light coupling

00:08:38.210 --> 00:08:39.309
between those two.

00:08:39.309 --> 00:08:41.770
So I'll talk about that in
a little bit from now.

00:08:41.770 --> 00:08:45.410
But let's go into the
empty constructor.

00:08:45.410 --> 00:08:47.415
You might wonder why you need
an empty constructor?

00:08:47.415 --> 00:08:50.030
This is a question we get
quite frequently.

00:08:50.030 --> 00:08:54.500
As you can see in this graph,
you're interface to creating

00:08:54.500 --> 00:08:56.775
this fragment is this new
instance method, which goes in

00:08:56.775 --> 00:09:00.150
and calls the empty constructor
for you.

00:09:00.150 --> 00:09:03.230
When you rotate the device, the
fragment manager will call

00:09:03.230 --> 00:09:06.680
the empty constructor
on your behalf.

00:09:06.680 --> 00:09:08.900
And it will populated it with
those arguments that you had

00:09:08.900 --> 00:09:10.040
set earlier.

00:09:10.040 --> 00:09:13.060
And then, when you rotate it
again, it will call your empty

00:09:13.060 --> 00:09:14.370
constructor again.

00:09:14.370 --> 00:09:16.900
And so this is going on for
the fragments anyway.

00:09:16.900 --> 00:09:19.530
And you might want to leverage
that because the fragment

00:09:19.530 --> 00:09:22.680
manager is doing it for you.

00:09:22.680 --> 00:09:25.030
So this takes the burden
out of your hands.

00:09:25.030 --> 00:09:32.380
Once the arguments are set, it
will stay with the fragment.

00:09:32.380 --> 00:09:34.305
So the framework even says so.

00:09:34.305 --> 00:09:36.090
It says, every fragment needs
an empty constructor

00:09:36.090 --> 00:09:38.120
SCOTT: Does it actually
say that?

00:09:38.120 --> 00:09:39.720
VIKRAM: That's a screen grab.

00:09:39.720 --> 00:09:43.460
It actually says that
on the documents.

00:09:43.460 --> 00:09:44.770
So make an empty constructor.

00:09:44.770 --> 00:09:45.990
You need an empty constructor.

00:09:45.990 --> 00:09:46.620
Leverage it.

00:09:46.620 --> 00:09:49.500
Use it to your benefit.

00:09:49.500 --> 00:09:52.070
So I mentioned earlier about a
coupling pattern between a

00:09:52.070 --> 00:09:53.700
fragment and an activity.

00:09:53.700 --> 00:09:56.690
This is the general idea.

00:09:56.690 --> 00:09:58.780
On the left, there's a fragment,
which implements

00:09:58.780 --> 00:10:01.940
this interface called
action taker.

00:10:01.940 --> 00:10:05.870
And when the activity is
created, it registers itself

00:10:05.870 --> 00:10:06.760
with the controller.

00:10:06.760 --> 00:10:09.540
The activity implements the
controller, and it allows for

00:10:09.540 --> 00:10:12.300
a fragment to register
with it.

00:10:12.300 --> 00:10:14.640
And at some point in the future,
when the activity

00:10:14.640 --> 00:10:16.990
needs to take an action, it

00:10:16.990 --> 00:10:20.840
delegates that to the fragment.

00:10:20.840 --> 00:10:23.270
Let's take a look at
some real code.

00:10:23.270 --> 00:10:24.750
Here you can see the activity.

00:10:24.750 --> 00:10:28.550
The activity implements an
interface which allows the

00:10:28.550 --> 00:10:30.910
fragment to register
with the activity.

00:10:30.910 --> 00:10:34.380
When the activity needs to
perform something, it checks

00:10:34.380 --> 00:10:36.900
if a listener has been
registered previously.

00:10:36.900 --> 00:10:38.340
Because if a listener hasn't
been registered, there is

00:10:38.340 --> 00:10:39.080
nothing to do, right?

00:10:39.080 --> 00:10:40.650
Because you don't have a
delegate to handle it.

00:10:40.650 --> 00:10:43.570
You just drop it on the floor.

00:10:43.570 --> 00:10:45.730
This technique works really
well because these

00:10:45.730 --> 00:10:48.460
implementations are not
tied to a fragment.

00:10:48.460 --> 00:10:50.620
You could move this
implementation to a view, or

00:10:50.620 --> 00:10:55.450
to another activity, or
through an intent.

00:10:55.450 --> 00:10:57.910
And so the delegate object can
really be of any type.

00:10:57.910 --> 00:11:00.420
It doesn't have to
be a fragment.

00:11:00.420 --> 00:11:03.465
More importantly, you could have
many fragments do this.

00:11:03.465 --> 00:11:06.160
In this example, we have a
single delegate object because

00:11:06.160 --> 00:11:08.450
this is similar to what we use
in Gmail, where you have a

00:11:08.450 --> 00:11:10.190
single list activity.

00:11:10.190 --> 00:11:11.480
But you could have
many of these.

00:11:11.480 --> 00:11:13.980
You could have five or six
different fragment, all of

00:11:13.980 --> 00:11:16.280
which need to update if they
have registered with the

00:11:16.280 --> 00:11:17.360
controller.

00:11:17.360 --> 00:11:19.230
So in that case, you'll maintain
a list of these

00:11:19.230 --> 00:11:20.480
delegate objects.

00:11:25.460 --> 00:11:27.080
Over to the fragment side.

00:11:27.080 --> 00:11:29.410
So here, we get a handle
to the activity in

00:11:29.410 --> 00:11:33.120
onActivityCreated, which is
the earliest that you have

00:11:33.120 --> 00:11:36.300
access to a functioning
activity object.

00:11:36.300 --> 00:11:39.450
And when we get that activity,
we know what kind of activity

00:11:39.450 --> 00:11:40.760
created us.

00:11:40.760 --> 00:11:42.030
And so we cast it.

00:11:42.030 --> 00:11:44.620
We cast it to do a controller
and then that allows us to

00:11:44.620 --> 00:11:46.260
register ourselves with it.

00:11:46.260 --> 00:11:48.180
And after that, we are done.

00:11:48.180 --> 00:11:50.370
We don't have to know who
the controller is.

00:11:50.370 --> 00:11:52.370
We're decoupled from it.

00:11:52.370 --> 00:11:54.650
If the controller needs to do
something while we're still

00:11:54.650 --> 00:11:58.320
up, it will call perform an
action with some arbitrary

00:11:58.320 --> 00:11:59.620
information.

00:11:59.620 --> 00:12:02.200
And at that point, we can change
our internal state, or

00:12:02.200 --> 00:12:04.450
we can change our UI,
or whatever else

00:12:04.450 --> 00:12:07.440
that we need to do.

00:12:07.440 --> 00:12:08.970
We also need to deregister.

00:12:08.970 --> 00:12:11.190
And since onActivityCreated
doesn't have an

00:12:11.190 --> 00:12:13.320
onActivityDestroyed because
the activity actually goes

00:12:13.320 --> 00:12:16.020
away much later, we do this
cleanup in onDestroy.

00:12:16.020 --> 00:12:18.370
So in onDestroy, we find
out our controller.

00:12:18.370 --> 00:12:21.510
And then we deregister from it
so that it won't send us any

00:12:21.510 --> 00:12:22.690
more events.

00:12:22.690 --> 00:12:25.320
This kind of a method has
a lot of advantages.

00:12:25.320 --> 00:12:28.050
Its robust through orientation
changes.

00:12:28.050 --> 00:12:30.240
Its robust through activity
pause and start.

00:12:30.240 --> 00:12:32.140
Because it registers
when it comes up.

00:12:32.140 --> 00:12:35.090
And it deregisters
when it goes out.

00:12:35.090 --> 00:12:38.300
It doesn't rely on keeping any
pointers because pointers can

00:12:38.300 --> 00:12:41.140
get stale pretty quickly.

00:12:41.140 --> 00:12:43.390
Finally, this let's the
framework, and the fragment

00:12:43.390 --> 00:12:46.400
manager, do most of the
heavy lifting for you.

00:12:46.400 --> 00:12:48.770
And this leads to
shorter code.

00:12:48.770 --> 00:12:51.650
So this is a pattern for
fragment and activity

00:12:51.650 --> 00:12:53.050
communication.

00:12:53.050 --> 00:12:56.170
SCOTT: I don't really think
of this as communication.

00:12:56.170 --> 00:12:57.190
VIKRAM: Yeah, you're right.

00:12:57.190 --> 00:12:58.705
Two way communication is
kind of challenging.

00:13:01.850 --> 00:13:03.780
SCOTT: It's challenging because
mobile networks are

00:13:03.780 --> 00:13:05.170
slow and expensive.

00:13:05.170 --> 00:13:07.610
Not everyone has unlimited
high speed data.

00:13:07.610 --> 00:13:10.230
And so it helps to keep your
network usage in check.

00:13:10.230 --> 00:13:12.610
In addition to turning on the
network less frequently, you

00:13:12.610 --> 00:13:15.420
need to do less with it once the
connection is established.

00:13:15.420 --> 00:13:19.060
So let's look at what
Gmail does.

00:13:19.060 --> 00:13:22.200
Gmail tries to limit total
data usage by the app.

00:13:22.200 --> 00:13:25.060
First, we let users configure
what gets synced, and how much

00:13:25.060 --> 00:13:26.390
mail we sync.

00:13:26.390 --> 00:13:29.630
This is great for users to set
up a new device because, by

00:13:29.630 --> 00:13:33.040
default, they only get 30 days
of mail from their inbox.

00:13:33.040 --> 00:13:35.560
If they have filters set up to
move noncritical mail out of

00:13:35.560 --> 00:13:38.950
their inbox, this means they
don't get all their mail sent

00:13:38.950 --> 00:13:39.630
to their device.

00:13:39.630 --> 00:13:42.070
And this saves space
and data usage.

00:13:42.070 --> 00:13:45.190
As you can see in this case, the
user has set up filters to

00:13:45.190 --> 00:13:48.430
remove particularly
annoying email.

00:13:48.430 --> 00:13:51.480
Gmail may offered gigabytes of
storage, but you probably

00:13:51.480 --> 00:13:53.490
don't want it all
on your device.

00:13:53.490 --> 00:13:56.120
Also, you can see this user
has set up filters to move

00:13:56.120 --> 00:13:58.360
non-work email out
of their inbox.

00:13:58.360 --> 00:14:00.300
Users loves such
customization.

00:14:00.300 --> 00:14:03.230
It makes them more productive,
reduces data transfer, and

00:14:03.230 --> 00:14:04.480
improves battery life.

00:14:07.410 --> 00:14:10.290
To further reduce unnecessary
data usage, we don't do any

00:14:10.290 --> 00:14:11.600
timed pulling.

00:14:11.600 --> 00:14:14.010
The server sends us a very short
message, which you can

00:14:14.010 --> 00:14:16.110
do with Google Cloud
Messaging.

00:14:16.110 --> 00:14:17.670
And that tells us there's
new data.

00:14:17.670 --> 00:14:19.790
At this point, we
begin a sync.

00:14:19.790 --> 00:14:22.190
On this slide is an example of
some of the client code for

00:14:22.190 --> 00:14:23.330
Cloud Messaging.

00:14:23.330 --> 00:14:26.040
In the first part, we register
for Cloud Messaging.

00:14:26.040 --> 00:14:28.570
The registration ID needs to be
sent to your server at some

00:14:28.570 --> 00:14:31.240
point because it's
used to direct

00:14:31.240 --> 00:14:33.270
messages to your device.

00:14:33.270 --> 00:14:36.250
The second part is an example
of a GCM intent service.

00:14:36.250 --> 00:14:39.630
You do need to use that name, as
other classes depend on it.

00:14:39.630 --> 00:14:42.180
In this case, whenever we
receive a message, we just

00:14:42.180 --> 00:14:43.930
request a sync.

00:14:43.930 --> 00:14:45.830
For a more in depth
explanation, refer

00:14:45.830 --> 00:14:47.960
to the GCM 2.0 talk.

00:14:47.960 --> 00:14:49.340
VIKRAM: GCM 2.0.

00:14:49.340 --> 00:14:50.385
Better than 1.0?

00:14:50.385 --> 00:14:51.635
SCOTT: Twice as good.

00:14:54.250 --> 00:14:56.600
When we do anything in the
background, we use an intent

00:14:56.600 --> 00:15:00.140
service it receives an intent
and then spawns a background

00:15:00.140 --> 00:15:02.770
thread to let us do any
long running tasks,

00:15:02.770 --> 00:15:04.090
like syncing mail.

00:15:04.090 --> 00:15:07.040
And then it shuts down
when it's complete.

00:15:07.040 --> 00:15:08.970
This is much better than having
a service that is

00:15:08.970 --> 00:15:11.790
continuously running but is just
sitting there, waiting

00:15:11.790 --> 00:15:15.150
for tasks, and isn't active.

00:15:15.150 --> 00:15:16.960
However, one intent service
can only have

00:15:16.960 --> 00:15:18.120
one background thread.

00:15:18.120 --> 00:15:19.980
So if you need to have multiple
tasks running

00:15:19.980 --> 00:15:23.140
simultaneously, you'll need
multiple intent services, or a

00:15:23.140 --> 00:15:24.390
custom implementation.

00:15:26.650 --> 00:15:28.480
We only want to retrieve
changes since

00:15:28.480 --> 00:15:29.840
the previous sync.

00:15:29.840 --> 00:15:32.570
So we keep track of the server's
timestamp the last

00:15:32.570 --> 00:15:35.030
time it was successful.

00:15:35.030 --> 00:15:37.000
The next time we sync, we
send this time stamp

00:15:37.000 --> 00:15:38.270
back up to the server.

00:15:38.270 --> 00:15:43.720
And it only sends us since
the previous sync.

00:15:43.720 --> 00:15:47.260
Finally, some network transfer
may be deferred until a Wi-Fi

00:15:47.260 --> 00:15:48.790
connection is established.

00:15:48.790 --> 00:15:51.450
So in Gmail, we allow you to
automatically download

00:15:51.450 --> 00:15:53.110
attachments when on Wi-Fi.

00:15:53.110 --> 00:15:55.640
Other common cases are podcast
clients allowing you to

00:15:55.640 --> 00:15:58.890
download podcasts on Wi-Fi and
social networking apps

00:15:58.890 --> 00:16:01.800
deferring photo uploads
until you're on Wi-Fi.

00:16:01.800 --> 00:16:04.170
This improves the performance of
the device and the overall

00:16:04.170 --> 00:16:07.360
user experience.

00:16:07.360 --> 00:16:09.750
But really, the biggest trick
is to be selective

00:16:09.750 --> 00:16:11.200
about what you sync.

00:16:11.200 --> 00:16:14.370
The less you sync, the less
code you run, and the less

00:16:14.370 --> 00:16:16.450
network and battery you use.

00:16:16.450 --> 00:16:18.550
So be careful about what
you sync and try to

00:16:18.550 --> 00:16:20.380
minimize data transfer.

00:16:20.380 --> 00:16:22.090
But once you have this
new data, you need

00:16:22.090 --> 00:16:25.340
to notify the user.

00:16:25.340 --> 00:16:28.370
Notification should be shown
for critical new content,

00:16:28.370 --> 00:16:31.490
something a user may want to
take immediate action on.

00:16:31.490 --> 00:16:33.140
Everyone knows what
a notification is.

00:16:33.140 --> 00:16:35.425
But here's an example.

00:16:35.425 --> 00:16:37.550
VIKRAM: Wow, nice notification,
Scott.

00:16:37.550 --> 00:16:38.790
SCOTT: Thank you.

00:16:38.790 --> 00:16:41.360
But while it looks great, it
doesn't give the user any

00:16:41.360 --> 00:16:43.900
valuable information, or at
least nothing valuable or

00:16:43.900 --> 00:16:45.990
critical to the user.

00:16:45.990 --> 00:16:49.180
Moreover, there's no immediate
action the user can take.

00:16:49.180 --> 00:16:54.290
Such notifications are annoying,
so don't make them.

00:16:54.290 --> 00:16:57.510
You want to present enough
information to the user so

00:16:57.510 --> 00:16:59.920
they only open the app
if there is something

00:16:59.920 --> 00:17:01.900
they need to do.

00:17:01.900 --> 00:17:03.400
You need to give them
enough information

00:17:03.400 --> 00:17:05.420
to make this decision.

00:17:05.420 --> 00:17:10.400
If it's valuable, and it needs
immediate action, the user

00:17:10.400 --> 00:17:12.730
will open the app.

00:17:12.730 --> 00:17:15.300
Otherwise, the user knows they
don't need to open the app.

00:17:15.300 --> 00:17:18.310
And they can just dismiss
the notification.

00:17:18.310 --> 00:17:21.180
If you give them enough
information so that they don't

00:17:21.180 --> 00:17:24.000
open the app only to close it
right away when they realized

00:17:24.000 --> 00:17:26.140
there's nothing to do, then
you've created a great

00:17:26.140 --> 00:17:27.980
notification.

00:17:27.980 --> 00:17:31.380
Gmail uses several distinct
types of notifications.

00:17:31.380 --> 00:17:34.160
When the notification is
collapsed, or on ICS, we try

00:17:34.160 --> 00:17:36.760
to present as much information
as possible in the limited

00:17:36.760 --> 00:17:38.250
space that we have.

00:17:38.250 --> 00:17:42.000
For single message, we display
the sender name, the photo,

00:17:42.000 --> 00:17:44.640
the subject of the message, and
the account or label name,

00:17:44.640 --> 00:17:46.465
along with the number
of unread messages.

00:17:49.230 --> 00:17:52.030
When there are multiple new
messages, we show you how many

00:17:52.030 --> 00:17:53.950
are new, the account or
label name, and the

00:17:53.950 --> 00:17:57.200
number of unread messages.

00:17:57.200 --> 00:17:58.780
But you can do better
than this.

00:17:58.780 --> 00:18:01.370
With expandable notifications,
you can present the user with

00:18:01.370 --> 00:18:02.870
a lot more information.

00:18:02.870 --> 00:18:05.990
And with notification actions,
you can let them take specific

00:18:05.990 --> 00:18:09.163
actions straight from
the notification.

00:18:09.163 --> 00:18:11.650
VIKRAM: Yeah, in this example,
you can reply to yourself,

00:18:11.650 --> 00:18:14.080
tell yourself how awesome
your notification was.

00:18:14.080 --> 00:18:16.530
SCOTT: I do that all the time.

00:18:16.530 --> 00:18:17.370
VIKRAM: Good.

00:18:17.370 --> 00:18:19.710
SCOTT: On Jelly Bean, when
there's only one new message,

00:18:19.710 --> 00:18:21.830
we present you with all the
same information from the

00:18:21.830 --> 00:18:23.460
collapsed notification.

00:18:23.460 --> 00:18:26.920
We also show as much of the
message as possible.

00:18:26.920 --> 00:18:29.810
We do this using big text style,
which is an inner class

00:18:29.810 --> 00:18:33.240
of notification compat.

00:18:33.240 --> 00:18:35.820
We also give you two
notification actions.

00:18:35.820 --> 00:18:38.430
So in my example, I can read the
entire message, and I can

00:18:38.430 --> 00:18:40.720
archive it right from the
notification without ever

00:18:40.720 --> 00:18:42.630
having to enter the app.

00:18:42.630 --> 00:18:46.490
Remember, with notification
actions, your goal is to allow

00:18:46.490 --> 00:18:49.050
the user to do something quick
right from the notification

00:18:49.050 --> 00:18:50.820
without having to
enter the app.

00:18:50.820 --> 00:18:53.840
So with archive, you don't
have to enter the app.

00:18:53.840 --> 00:18:57.000
And with reply, we bypass a
screen in the app and take you

00:18:57.000 --> 00:18:59.070
right to writing a reply, rather
than just into the

00:18:59.070 --> 00:19:02.310
message, where you don't
have to click reply.

00:19:02.310 --> 00:19:05.040
In an app like Gmail, there's
a lot of actions you might

00:19:05.040 --> 00:19:06.130
want to take on a message.

00:19:06.130 --> 00:19:08.610
So we made the most common
actions the default.

00:19:08.610 --> 00:19:11.330
But we also allow for some
minimal customization based on

00:19:11.330 --> 00:19:12.580
user preferences.

00:19:14.950 --> 00:19:17.890
When there are multiple new
messages, we show you a list

00:19:17.890 --> 00:19:21.610
of senders and subjects using
inbox style, which is also

00:19:21.610 --> 00:19:23.940
available in notification
compat.

00:19:23.940 --> 00:19:26.520
This lets the user decide if
there's any new messages that

00:19:26.520 --> 00:19:29.310
warrants opening the app
for further action.

00:19:29.310 --> 00:19:31.890
With all notifications, when you
swipe it away to dismiss

00:19:31.890 --> 00:19:34.550
it, we mark those messages as
having been seen so that you

00:19:34.550 --> 00:19:38.310
never get a new notification
for the same message.

00:19:38.310 --> 00:19:41.110
If another message were to come
in after dismissing this

00:19:41.110 --> 00:19:43.350
one, it would be the only one
in the notification, rather

00:19:43.350 --> 00:19:47.250
than just adding to the list
and showing you three.

00:19:47.250 --> 00:19:50.130
So to summarize, you want to
create a notification so good

00:19:50.130 --> 00:19:52.530
that the user does not have to
enter the app unless there's

00:19:52.530 --> 00:19:54.820
immediate action they
need to take.

00:19:54.820 --> 00:19:57.010
If a simple action can be
offered, it should be

00:19:57.010 --> 00:19:59.500
presented right from
the notification.

00:19:59.500 --> 00:20:02.220
And only show one notification
per event.

00:20:02.220 --> 00:20:03.850
Don't show duplicate
notifications

00:20:03.850 --> 00:20:05.460
for the same thing.

00:20:05.460 --> 00:20:07.530
It's also a good idea to let
a user configure their

00:20:07.530 --> 00:20:10.101
notification settings.

00:20:10.101 --> 00:20:12.300
VIKRAM: Seems kind of strange
that we're asking these

00:20:12.300 --> 00:20:16.140
developers that users shouldn't
enter their app.

00:20:16.140 --> 00:20:17.850
SCOTT: Well, the user doesn't
really care if they're using

00:20:17.850 --> 00:20:19.230
the app or just a
notification.

00:20:19.230 --> 00:20:22.210
To them, it's all the
interactions with the app.

00:20:22.210 --> 00:20:25.340
VIKRAM: Yeah, you're right in
that once the user does enter

00:20:25.340 --> 00:20:28.380
your app, you want to make
your app more fluid.

00:20:28.380 --> 00:20:29.430
Because you already
have the data.

00:20:29.430 --> 00:20:30.450
You've already done the sync.

00:20:30.450 --> 00:20:32.290
You've showing the
notification.

00:20:32.290 --> 00:20:33.890
So let's take a look at
how we do some of

00:20:33.890 --> 00:20:37.010
that using the loaders.

00:20:37.010 --> 00:20:39.960
Loaders are this framework
mechanism to generate data off

00:20:39.960 --> 00:20:43.840
the UI thread and to return
them on the UI thread.

00:20:43.840 --> 00:20:45.965
Gmail and email use loaders
extensively.

00:20:45.965 --> 00:20:49.440
We use them for all of our
native data types, which, for

00:20:49.440 --> 00:20:52.050
Gmail and email, is accounts,
and folders, and

00:20:52.050 --> 00:20:54.440
conversations.

00:20:54.440 --> 00:20:56.020
Loaders are the easiest
way to obtain data

00:20:56.020 --> 00:20:58.120
off a content provider.

00:20:58.120 --> 00:21:00.450
The API is generally enough
that you could write an

00:21:00.450 --> 00:21:02.390
loaders for your use case.

00:21:02.390 --> 00:21:04.190
Though in most cases,
you would probably

00:21:04.190 --> 00:21:06.110
use a cursor loader.

00:21:06.110 --> 00:21:08.090
The cursor loader performs
a content provider

00:21:08.090 --> 00:21:10.190
query of the UI thread.

00:21:10.190 --> 00:21:12.210
And then it returns
a cursor over the

00:21:12.210 --> 00:21:14.370
data on the UI thread.

00:21:14.370 --> 00:21:16.410
Let's look at an example.

00:21:16.410 --> 00:21:19.140
So that's the example
of a loader.

00:21:19.140 --> 00:21:20.640
Scott, what's this?

00:21:20.640 --> 00:21:21.680
SCOTT: Isn't this a loader?

00:21:21.680 --> 00:21:23.560
It's the first result I
got in image search.

00:21:23.560 --> 00:21:25.390
VIKRAM: I don't know, man.

00:21:25.390 --> 00:21:26.010
How would we know?

00:21:26.010 --> 00:21:27.650
We're all software
engineers here.

00:21:27.650 --> 00:21:30.640
To us, everything's
gray boxes.

00:21:30.640 --> 00:21:31.780
SCOTT: Oh, like this.

00:21:31.780 --> 00:21:32.650
VIKRAM: Yeah, like this.

00:21:32.650 --> 00:21:36.310
And this crowd understands these
boxes just like we do.

00:21:36.310 --> 00:21:38.860
This is roughly what the
loader looks like.

00:21:38.860 --> 00:21:40.800
On the left is the UI thread.

00:21:40.800 --> 00:21:43.980
And your interface to the
loader is initLoader.

00:21:43.980 --> 00:21:47.850
You call initLoader, and then
you get a call back called

00:21:47.850 --> 00:21:49.010
onCreateLoader.

00:21:49.010 --> 00:21:51.520
And that's where you create your
cursor loader, or really

00:21:51.520 --> 00:21:53.570
any kind of loader.

00:21:53.570 --> 00:21:56.350
And the cursor loader will go
off in the background thread.

00:21:56.350 --> 00:21:58.340
And it will do this content
provider query.

00:21:58.340 --> 00:22:00.470
The box is supposed to look big
because it's supposed to

00:22:00.470 --> 00:22:02.690
be heavy, and hit your
disk, and basically

00:22:02.690 --> 00:22:03.940
slow the system down.

00:22:03.940 --> 00:22:06.980
But you don't care because it's
in the background thread.

00:22:06.980 --> 00:22:10.460
When the query is done, it'll
call the call back

00:22:10.460 --> 00:22:15.880
onLoadFinished, which has a
cursor over that information.

00:22:15.880 --> 00:22:18.690
One trick that we've learned is
to implement all of these

00:22:18.690 --> 00:22:21.290
callbacks in a separate
object.

00:22:21.290 --> 00:22:23.610
One way you might be doing this
already is to have an

00:22:23.610 --> 00:22:26.190
activity or a fragment implement
these callbacks.

00:22:26.190 --> 00:22:28.340
But then, when you do that, if
you have to relocate the

00:22:28.340 --> 00:22:31.480
callbacks everywhere somewhere
else, you have to grab all

00:22:31.480 --> 00:22:34.050
these callbacks and put them
in a different object.

00:22:34.050 --> 00:22:36.270
And that's cumbersome.

00:22:36.270 --> 00:22:40.450
So let's look at an example
with all of these ideas.

00:22:40.450 --> 00:22:44.820
So here, in onCreateLoader,
we create a loader.

00:22:44.820 --> 00:22:47.510
The ID is somewhat arbitrary.

00:22:47.510 --> 00:22:49.370
It's kind of like a
Unix file handle.

00:22:49.370 --> 00:22:53.260
You want to the same ID
for the same unit of

00:22:53.260 --> 00:22:55.600
data, in some sense.

00:22:55.600 --> 00:22:59.570
In this case, we have an integer
called Folder Loader

00:22:59.570 --> 00:23:04.150
because we will only make folder
objects out of these.

00:23:04.150 --> 00:23:06.960
And the advantage of keeping
the same ID is that if you

00:23:06.960 --> 00:23:10.000
rotate the device, and if you
have a loader running, you'll

00:23:10.000 --> 00:23:13.580
get back a cursor over the
previous data right away.

00:23:13.580 --> 00:23:16.410
So there won't be any lag if the
user rotates the device.

00:23:16.410 --> 00:23:19.214
We use this a lot in Gmail.

00:23:19.214 --> 00:23:22.590
In both onCreate loader
and onLoadFinished, we

00:23:22.590 --> 00:23:23.370
check the loader ID.

00:23:23.370 --> 00:23:25.890
We want to make sure that this
was really a folder that was

00:23:25.890 --> 00:23:26.800
being created.

00:23:26.800 --> 00:23:28.150
And then we do all
of our stuff.

00:23:28.150 --> 00:23:30.850
But you might want the same
sort of logic if you have

00:23:30.850 --> 00:23:33.420
other loaders, like a
conversation loader, or a list

00:23:33.420 --> 00:23:36.680
loader, or whatever.

00:23:36.680 --> 00:23:39.260
The information that's passed to
the loader to get the load

00:23:39.260 --> 00:23:42.960
started is all in that bundle
called arguments in

00:23:42.960 --> 00:23:44.100
onCreateLoader.

00:23:44.100 --> 00:23:46.030
And that's also a really
good pattern.

00:23:46.030 --> 00:23:49.430
Try to pass all of you loader
information in the arguments

00:23:49.430 --> 00:23:51.780
as opposed to having globals
because that allows you to

00:23:51.780 --> 00:23:54.220
relocate this class called
folder loads

00:23:54.220 --> 00:23:56.520
in a different place.

00:23:56.520 --> 00:23:59.410
At sometime in the future, when
the data is ready, you

00:23:59.410 --> 00:24:01.340
get a call to onLoad finished.

00:24:01.340 --> 00:24:02.900
It has cursor right there.

00:24:02.900 --> 00:24:04.140
You can go ahead and use it.

00:24:04.140 --> 00:24:05.810
It was created off
the UI thread.

00:24:05.810 --> 00:24:07.930
So there was no lag.

00:24:07.930 --> 00:24:11.150
You might also get this onLoader
reset, which happens

00:24:11.150 --> 00:24:12.760
if the data goes away.

00:24:12.760 --> 00:24:15.620
And so you want to reset your
state, forget your reference

00:24:15.620 --> 00:24:17.170
to the cursor if you
had maintained one.

00:24:19.890 --> 00:24:22.370
So let's look at how we
use this call back.

00:24:22.370 --> 00:24:24.750
Again, using this call back
is really simple.

00:24:24.750 --> 00:24:27.120
We create a callback
object in Gmail.

00:24:27.120 --> 00:24:29.860
And he always make
final objects.

00:24:29.860 --> 00:24:32.140
And we make them final because
they tend to have very minimal

00:24:32.140 --> 00:24:34.000
state associated with them.

00:24:34.000 --> 00:24:37.390
So it helps if it's tied in with
the object that is your

00:24:37.390 --> 00:24:39.990
activity, or your fragment.

00:24:39.990 --> 00:24:43.530
When you need data, you
call this method,

00:24:43.530 --> 00:24:45.310
happily called needData--

00:24:45.310 --> 00:24:48.380
it's kind of clear
what it does.

00:24:48.380 --> 00:24:51.180
And we pass it a single URI,
which is the thing that you

00:24:51.180 --> 00:24:53.150
want to query from.

00:24:53.150 --> 00:24:56.190
And we past that URI
inside the bundle.

00:24:56.190 --> 00:24:57.910
So it's not a global.

00:24:57.910 --> 00:25:00.440
It's passed in the bundle
so that the loader call

00:25:00.440 --> 00:25:02.030
back can get at it.

00:25:02.030 --> 00:25:03.350
We give it the call
back object.

00:25:03.350 --> 00:25:04.070
We give it the bundle.

00:25:04.070 --> 00:25:05.140
That's the arguments.

00:25:05.140 --> 00:25:08.610
And then we give it that unique
ID for the loader.

00:25:08.610 --> 00:25:10.380
So this works really well
for data that's

00:25:10.380 --> 00:25:11.940
created from loaders.

00:25:11.940 --> 00:25:15.910
In Gmail, and in general, you
have these cases where you

00:25:15.910 --> 00:25:20.210
create an entire object from
a row of a cursor.

00:25:20.210 --> 00:25:23.970
And when that starts to happen,
when you do have a one

00:25:23.970 --> 00:25:26.960
to one mapping between a cursor
row and an object, you

00:25:26.960 --> 00:25:29.970
can actually do much better.

00:25:29.970 --> 00:25:33.760
You can create entire objects
off the UI thread.

00:25:33.760 --> 00:25:35.830
And the idea is fairly
straightforward.

00:25:35.830 --> 00:25:38.520
You have this cursor loader
that's already doing the

00:25:38.520 --> 00:25:41.090
content provider query
of the UI thread.

00:25:41.090 --> 00:25:44.350
What you want is, you want
that thing to create the

00:25:44.350 --> 00:25:49.260
objects in advance, before
returning the results.

00:25:49.260 --> 00:25:52.910
Objects that know that this is
a special cursor can get at

00:25:52.910 --> 00:25:55.980
the object reference that
was previously created.

00:25:55.980 --> 00:25:58.720
And whatever you return here
will continue being a cursor.

00:25:58.720 --> 00:26:02.310
So things that don't even know
that this is a special cursor

00:26:02.310 --> 00:26:04.680
can call usual cursor
of methods.

00:26:04.680 --> 00:26:07.700
So let's see how this is done.

00:26:07.700 --> 00:26:10.720
This is our object cursor.

00:26:10.720 --> 00:26:13.300
It creates objects
of type T. And it

00:26:13.300 --> 00:26:15.340
extends a cursor wrapper.

00:26:15.340 --> 00:26:17.910
So it's real, qualified cursor,
except that has two

00:26:17.910 --> 00:26:19.650
special methods.

00:26:19.650 --> 00:26:22.110
It has a method called getModel
which will return

00:26:22.110 --> 00:26:25.710
objects of type T which were
created off the UI thread.

00:26:25.710 --> 00:26:26.780
And that's the important
point.

00:26:26.780 --> 00:26:29.320
That's why we're doing
all of this.

00:26:29.320 --> 00:26:32.220
And the second method is
fillCache, which allows you

00:26:32.220 --> 00:26:37.180
populate these objects
of the UI thread.

00:26:37.180 --> 00:26:39.960
The loader itself subclasses
async task loader.

00:26:39.960 --> 00:26:44.240
Our sample app has the
full implementation.

00:26:44.240 --> 00:26:50.380
And the async task loader, in
the implementation of loading

00:26:50.380 --> 00:26:52.990
background, it does the content
provider query, which

00:26:52.990 --> 00:26:55.120
it's doing already.

00:26:55.120 --> 00:26:57.140
And that returns a cursor
called hidden.

00:26:57.140 --> 00:26:59.160
It's called hidden because
we never return it.

00:26:59.160 --> 00:27:01.800
What we do with that cursor is
that we create an object

00:27:01.800 --> 00:27:04.900
cursor from it, along with a
factory object that knows how

00:27:04.900 --> 00:27:09.270
to create these T objects from
every row of the cursor.

00:27:09.270 --> 00:27:11.290
And then we fill the
cache right away.

00:27:11.290 --> 00:27:14.520
This means that your entire
cursor is going to get fed,

00:27:14.520 --> 00:27:17.190
and the objects will get created
off the UI thread.

00:27:21.100 --> 00:27:24.320
So since this runs in the
loading background, this is

00:27:24.320 --> 00:27:26.770
all happening off the UI thread,
the object creation is

00:27:26.770 --> 00:27:29.980
not slowing down your UI.

00:27:29.980 --> 00:27:32.500
Let's going to a consumer
of this loader.

00:27:32.500 --> 00:27:35.420
You can see the general
consumer pattern here.

00:27:35.420 --> 00:27:37.130
We have the same class,
which implements

00:27:37.130 --> 00:27:38.050
all the loader callbacks.

00:27:38.050 --> 00:27:42.610
It's still called handle loads,
so it looks the same,

00:27:42.610 --> 00:27:45.040
except that in onLoadFinished,
instead of getting back a

00:27:45.040 --> 00:27:49.970
cursor, now it gives back an
object cursor of type T.

00:27:49.970 --> 00:27:52.370
And in this case, we
have an object

00:27:52.370 --> 00:27:53.540
called a big heavy object.

00:27:53.540 --> 00:27:56.420
It suggests that it takes
a long time to create.

00:27:56.420 --> 00:27:58.410
But we don't have to create
it on the UI thread.

00:27:58.410 --> 00:28:01.780
Now, we can do data.getModel
because, now, the object's

00:28:01.780 --> 00:28:03.030
already been created for you.

00:28:06.610 --> 00:28:09.310
As before, to use these
callbacks, we create a final

00:28:09.310 --> 00:28:10.850
callback object.

00:28:10.850 --> 00:28:14.470
And in this case, rather than
doing a need data, I have

00:28:14.470 --> 00:28:18.140
onCreate, where I initialize
this LOADER_BIG_HEAVY, because

00:28:18.140 --> 00:28:19.320
it's not a folder anymore.

00:28:19.320 --> 00:28:20.800
It's to a big, heavy loader.

00:28:20.800 --> 00:28:22.590
So it's got a different idea.

00:28:22.590 --> 00:28:25.330
And then, just like before, we
have a URI that we shove in

00:28:25.330 --> 00:28:28.590
the bundle, and we have
a callback object.

00:28:28.590 --> 00:28:32.460
So this looks for data that
you already have.

00:28:32.460 --> 00:28:35.000
Scott, do you know what we do
for downloading large data off

00:28:35.000 --> 00:28:36.010
the internet?

00:28:36.010 --> 00:28:38.070
SCOTT: Large data loads need
a different mechanism.

00:28:38.070 --> 00:28:42.110
So let's look at what
Gmail does.

00:28:42.110 --> 00:28:45.280
So many apps download large
objects from the network.

00:28:45.280 --> 00:28:47.240
There are quite a few developers
who valiantly try

00:28:47.240 --> 00:28:48.750
to write their own
download service.

00:28:48.750 --> 00:28:49.400
VIKRAM: Yeah, I know.

00:28:49.400 --> 00:28:52.180
My download service had
a few minor bugs--

00:28:52.180 --> 00:28:57.820
some crashes, some hangs,
data loss--

00:28:57.820 --> 00:29:01.230
SCOTT: Yeah, a couple
of harmless bugs.

00:29:01.230 --> 00:29:03.430
So we ended up using an
excellent service called

00:29:03.430 --> 00:29:05.460
DownloadManager.

00:29:05.460 --> 00:29:07.920
DownloadManager is a service
to download data from the

00:29:07.920 --> 00:29:10.755
network in a robust manner it
works on Gingerbread and

00:29:10.755 --> 00:29:13.660
above, so it's available
nearly everywhere.

00:29:13.660 --> 00:29:16.260
If you need to support Froyo
and earlier, consider using

00:29:16.260 --> 00:29:18.850
your own implementation on
those older versions.

00:29:18.850 --> 00:29:21.950
Use DownloadManager on later
versions where it's available.

00:29:21.950 --> 00:29:24.530
This way, any updates to the
framework will benefit your

00:29:24.530 --> 00:29:25.980
app running on Gingerbread
or later.

00:29:30.305 --> 00:29:31.600
VIKRAM: Oh my goodness,
my eyes.

00:29:31.600 --> 00:29:33.420
That looks ugly.

00:29:33.420 --> 00:29:35.740
SCOTT: Users can tell when you
use your own implementation

00:29:35.740 --> 00:29:36.500
because the download

00:29:36.500 --> 00:29:39.870
notification often looks horrible.

00:29:39.870 --> 00:29:41.990
Many are themed for Gingerbread
or earlier, and

00:29:41.990 --> 00:29:44.130
they look really out of place
on the hollow theme, as you

00:29:44.130 --> 00:29:47.210
can see here.

00:29:47.210 --> 00:29:49.220
Using DownloadManager
is really simple.

00:29:49.220 --> 00:29:52.330
In fact, the code to download
a file is just one line.

00:29:52.330 --> 00:29:54.610
When the download completes, an
intent is sent to your app

00:29:54.610 --> 00:29:57.180
to let your app know.

00:29:57.180 --> 00:29:59.470
DownloadManager works best when
you have a single large

00:29:59.470 --> 00:30:01.322
file to download.

00:30:01.322 --> 00:30:02.850
VIKRAM: Wow, just one line.

00:30:02.850 --> 00:30:04.930
I hope these guys aren't being
paid by the number of lines of

00:30:04.930 --> 00:30:06.420
code they write.

00:30:06.420 --> 00:30:09.230
SCOTT: Well, good developers
like everyone in the audience,

00:30:09.230 --> 00:30:11.530
will probably write very
detailed comments

00:30:11.530 --> 00:30:14.720
above that one line.

00:30:14.720 --> 00:30:16.780
But if you're really concerned
about increasing your lines of

00:30:16.780 --> 00:30:18.680
code, you can take a look
at the request object.

00:30:18.680 --> 00:30:21.460
It lets you specify
lots of options.

00:30:21.460 --> 00:30:24.310
So here, we create a new
request to specify some

00:30:24.310 --> 00:30:25.830
settings for the download.

00:30:25.830 --> 00:30:27.820
First, you said which network
types to allow.

00:30:27.820 --> 00:30:30.290
And I like Wi-Fi because
it's usually free.

00:30:30.290 --> 00:30:33.390
And we're providing it to
all of you right now.

00:30:33.390 --> 00:30:36.950
Then we set whether to allow
metered or roaming

00:30:36.950 --> 00:30:37.870
connections.

00:30:37.870 --> 00:30:39.770
And I've disallowed these
because they may

00:30:39.770 --> 00:30:43.090
cost the user extra.

00:30:43.090 --> 00:30:45.450
Then we said where
to save the file.

00:30:45.450 --> 00:30:48.050
Note that download manager
requires write access to this

00:30:48.050 --> 00:30:50.750
URI, so you can't just pass
in a file path your app's

00:30:50.750 --> 00:30:53.050
internal data directory.

00:30:53.050 --> 00:30:55.890
Then we set the text to display
in the notification.

00:30:55.890 --> 00:30:58.680
And we set the notification
visibility.

00:30:58.680 --> 00:31:01.450
You can set it to show up only
while downloading, only when

00:31:01.450 --> 00:31:04.290
complete, both, or neither.

00:31:04.290 --> 00:31:05.365
VIKRAM: Scott, what's
VISIBILITY_VISIB

00:31:05.365 --> 00:31:07.795
LE_NOTIFY_COMPLETED?

00:31:07.795 --> 00:31:11.310
SCOTT: It sets the visibility
to be visible.

00:31:11.310 --> 00:31:14.990
And it will notify you when the
download has completed.

00:31:14.990 --> 00:31:17.540
VIKRAM: OK.

00:31:17.540 --> 00:31:19.230
SCOTT: An intent is
broadcast when the

00:31:19.230 --> 00:31:20.360
notification is clicked.

00:31:20.360 --> 00:31:22.670
So your app can handle and
take the user directly to

00:31:22.670 --> 00:31:25.030
their downloaded content.

00:31:25.030 --> 00:31:27.120
And finally, you can set whether
to show the download

00:31:27.120 --> 00:31:30.160
in the system downloads UI,
which lets the user managed

00:31:30.160 --> 00:31:34.910
all of their downloaded content
across all their apps.

00:31:34.910 --> 00:31:37.220
So you have a lot of control
over the download request if

00:31:37.220 --> 00:31:38.820
you need it.

00:31:38.820 --> 00:31:41.270
DownloadManager has a lot of
functionality and will ensure

00:31:41.270 --> 00:31:43.860
that your app properly handles
intermittent connections and

00:31:43.860 --> 00:31:46.220
network switching that's common
on mobile devices.

00:31:46.220 --> 00:31:49.280
It will provide a much better
experience for your users than

00:31:49.280 --> 00:31:50.530
most custom implementations.

00:31:53.500 --> 00:31:56.450
Users typically get a new mobile
device every two years.

00:31:56.450 --> 00:31:59.070
And they love apps that maintain
their settings.

00:31:59.070 --> 00:32:01.890
In Gmail, we back up certain
preferences to the cloud so

00:32:01.890 --> 00:32:04.630
that when a user upgrades to
new device, these settings

00:32:04.630 --> 00:32:05.970
restore themselves.

00:32:05.970 --> 00:32:07.920
Users love it since they don't
have to reconfigurable

00:32:07.920 --> 00:32:09.450
everything.

00:32:09.450 --> 00:32:11.855
The backup and restore process
is transparent to the users,

00:32:11.855 --> 00:32:14.010
so all they should realize is
that the app is already

00:32:14.010 --> 00:32:16.300
configured the way
they want it.

00:32:16.300 --> 00:32:18.845
From a high level, an app can
tell the backup manager that

00:32:18.845 --> 00:32:23.580
there is new that there's
new data to back up.

00:32:23.580 --> 00:32:26.330
At some point in the future,
backup manager will query your

00:32:26.330 --> 00:32:28.800
app asking for this data.

00:32:28.800 --> 00:32:30.930
And then it'll send
it to the cloud.

00:32:30.930 --> 00:32:34.260
When a new app is installed, the
system checks if there's

00:32:34.260 --> 00:32:36.030
any data backup and
will automatically

00:32:36.030 --> 00:32:38.070
restore it for your app.

00:32:38.070 --> 00:32:40.440
You can also manually request to
restore operation, but this

00:32:40.440 --> 00:32:43.460
should not necessary.

00:32:43.460 --> 00:32:44.900
You know, this actually reminds
me of something that

00:32:44.900 --> 00:32:46.370
happened back in Canada.

00:32:46.370 --> 00:32:47.260
VIKRAM: Canada, eh?

00:32:47.260 --> 00:32:48.510
Tell me about it.

00:32:54.580 --> 00:32:59.390
SCOTT: It was a typical winter
day in Ottawa, so minus 40.

00:32:59.390 --> 00:33:02.230
I left my phone in my
car for a few hours.

00:33:02.230 --> 00:33:06.060
And when I came back, it was
not in a very good state.

00:33:06.060 --> 00:33:08.070
After fiddling around with it
for a bit, I was able to get

00:33:08.070 --> 00:33:10.100
it to boot up, sort of.

00:33:10.100 --> 00:33:12.470
But it's said the battery was
almost dead, even though it

00:33:12.470 --> 00:33:13.710
should've been fully charged.

00:33:13.710 --> 00:33:15.390
And the touch screen didn't
really respond.

00:33:15.390 --> 00:33:16.230
VIKRAM: Oh man.

00:33:16.230 --> 00:33:18.250
SCOTT: I really wish I had cloud
backup and restore then

00:33:18.250 --> 00:33:19.580
because I could have
just switched to a

00:33:19.580 --> 00:33:20.870
new phone right away.

00:33:20.870 --> 00:33:23.910
Instead, I had to wait
for mine to thaw.

00:33:23.910 --> 00:33:27.950
But back to cloud backup.

00:33:27.950 --> 00:33:30.490
So to start, you need to add a
reference in your manifest to

00:33:30.490 --> 00:33:31.750
your backup agent.

00:33:31.750 --> 00:33:33.650
This lets the system know
which component of your

00:33:33.650 --> 00:33:36.860
application will handle the
backup and restore process.

00:33:36.860 --> 00:33:38.120
VIKRAM: Looks pretty simple.

00:33:38.120 --> 00:33:39.970
SCOTT: Yeah, I tried to get
them to make the API more

00:33:39.970 --> 00:33:42.040
complicated, so I'd have more
to talk about, but they

00:33:42.040 --> 00:33:43.480
wouldn't listen to me.

00:33:43.480 --> 00:33:47.910
And unfortunately, the Java
the side is just as easy.

00:33:47.910 --> 00:33:50.230
If all you need to do is backup
shared preferences, or

00:33:50.230 --> 00:33:53.210
other simple files, you just
extend a backup agent helper

00:33:53.210 --> 00:33:56.380
and an onCreate, add a few
backup helpers that specify

00:33:56.380 --> 00:33:59.280
which shared preferences and
files to back up, and this

00:33:59.280 --> 00:34:02.850
will handle everything
else for you.

00:34:02.850 --> 00:34:05.520
If you need to do something more
complicated, you can back

00:34:05.520 --> 00:34:08.000
up and restore byte arrays,
but this requires that you

00:34:08.000 --> 00:34:10.469
implement a lot more code.

00:34:10.469 --> 00:34:14.560
So here, we implement the
onBackup method to back up a

00:34:14.560 --> 00:34:16.969
name and a signature.

00:34:16.969 --> 00:34:18.980
The onRestore method is similar,
but you have to

00:34:18.980 --> 00:34:23.170
deserialize the byte array into
the data you require.

00:34:23.170 --> 00:34:25.440
Keep in mind that the backup
service should not be used to

00:34:25.440 --> 00:34:27.190
synchronize data
across devices.

00:34:27.190 --> 00:34:29.409
It will not work for this.

00:34:29.409 --> 00:34:31.520
VIKRAM: Scott, I just realized
why people hate Java.

00:34:31.520 --> 00:34:32.550
I mean, look at those names.

00:34:32.550 --> 00:34:36.500
Byte array, output stream,
helper thingy, doer, maker.

00:34:36.500 --> 00:34:37.800
SCOTT: Well, I don't know.

00:34:37.800 --> 00:34:40.219
Personally, I think those names
aren't long enough.

00:34:40.219 --> 00:34:41.994
We need to add some factory,
and delegate,

00:34:41.994 --> 00:34:44.560
and other fancy words.

00:34:44.560 --> 00:34:46.570
But since we're on the subject,
let's look at some

00:34:46.570 --> 00:34:50.940
source code organization and
some helpful libraries.

00:34:50.940 --> 00:34:53.260
To bring your application to
more devices, the support

00:34:53.260 --> 00:34:55.179
library is extremely useful.

00:34:55.179 --> 00:34:57.930
It contains a lot of framework
APIs backboarded around on

00:34:57.930 --> 00:34:59.340
Donut and later.

00:34:59.340 --> 00:35:02.090
This lets you use fragments,
loaders, view pagers, and

00:35:02.090 --> 00:35:05.860
other new and useful classes in
your app, even if your app

00:35:05.860 --> 00:35:09.550
runs on devices running versions
of Android from

00:35:09.550 --> 00:35:11.760
before these classes existed.

00:35:11.760 --> 00:35:14.590
Gmail doesn't yet use the
support activity fragment or

00:35:14.590 --> 00:35:17.530
loader classes, but it uses
view pager, notification

00:35:17.530 --> 00:35:21.230
compat, task stack builder,
and a few others.

00:35:21.230 --> 00:35:23.930
The benefit of using classes
from the support library, even

00:35:23.930 --> 00:35:27.240
if your app only runs on ICS
and up, like Gmail, is that

00:35:27.240 --> 00:35:29.820
the support library may contain
bug fixes and new

00:35:29.820 --> 00:35:32.810
features that are not available
on older versions of

00:35:32.810 --> 00:35:35.160
Android, like ICS.

00:35:35.160 --> 00:35:37.470
Using components from the
support library allows your

00:35:37.470 --> 00:35:40.220
app to take advantage of the
latest platform features,

00:35:40.220 --> 00:35:42.760
bringing a lot of them to older
devices and degrading

00:35:42.760 --> 00:35:44.560
gracefully where it can't.

00:35:44.560 --> 00:35:47.530
It also means that if the
support library were ever

00:35:47.530 --> 00:35:50.400
updated to offer more features
on Donut you wouldn't have to

00:35:50.400 --> 00:35:52.310
make any significant changes
to your app to take

00:35:52.310 --> 00:35:55.145
advantage of them.

00:35:55.145 --> 00:35:58.180
To use the support library
classes, it's usually a simple

00:35:58.180 --> 00:36:00.480
matter of changing your imports
with minor class and

00:36:00.480 --> 00:36:02.040
method name differences.

00:36:02.040 --> 00:36:03.620
So here we have an example.

00:36:03.620 --> 00:36:05.220
As you can see, the imports
change to the

00:36:05.220 --> 00:36:06.870
support library versions.

00:36:06.870 --> 00:36:08.585
Activity becomes
FragmentActivity.

00:36:08.585 --> 00:36:10.920
And Notification becomes
NotificationCompat.

00:36:10.920 --> 00:36:12.880
It's pretty simple.

00:36:12.880 --> 00:36:15.980
Method names also change, so
instead of getFragmentManager,

00:36:15.980 --> 00:36:16.460
you have to call
getSupportFragmentManager.

00:36:16.460 --> 00:36:20.940
Support But it's not
complicated at all.

00:36:20.940 --> 00:36:23.130
As I mentioned earlier, it's
a very good idea to use the

00:36:23.130 --> 00:36:24.520
support library wherever
you can.

00:36:27.220 --> 00:36:30.550
Viki, we're you going to say
something funny here?

00:36:30.550 --> 00:36:32.430
VIKRAM: Yeah, that thing
we talked about?

00:36:32.430 --> 00:36:34.680
Last night I was thinking it's
just not funny enough, so I

00:36:34.680 --> 00:36:37.280
took it out.

00:36:37.280 --> 00:36:39.290
SCOTT: But now they'll never
hear the story but your

00:36:39.290 --> 00:36:41.440
grandmother and the
trampoline.

00:36:41.440 --> 00:36:43.310
VIKRAM: So some things
are best left unsaid.

00:36:46.510 --> 00:36:48.870
SCOTT: Some other things we
aren't exactly going to share

00:36:48.870 --> 00:36:52.370
is actual source code from
the Gmail application.

00:36:52.370 --> 00:36:53.590
VIKRAM: Yeah, we talked
to our manager.

00:36:53.590 --> 00:36:55.640
I don't think we were
convincing enough.

00:36:55.640 --> 00:36:57.600
We just weren't persuasive.

00:36:57.600 --> 00:36:58.770
SCOTT: That's OK.

00:36:58.770 --> 00:37:00.320
You can download source
code for some of the

00:37:00.320 --> 00:37:01.830
components we use.

00:37:01.830 --> 00:37:03.900
The Android open source project
contains two such

00:37:03.900 --> 00:37:05.630
components.

00:37:05.630 --> 00:37:09.680
The pretty UI for senders in
Gmail that lets you select

00:37:09.680 --> 00:37:12.370
recipients is called chips.

00:37:12.370 --> 00:37:15.980
This library is used in Gmail
calendar and messaging.

00:37:15.980 --> 00:37:18.060
It lets you select a contact
by typing in a

00:37:18.060 --> 00:37:19.410
name or email address.

00:37:19.410 --> 00:37:21.290
Once you have a contacts
selected, you can easily

00:37:21.290 --> 00:37:25.620
specify which email address
you want to use.

00:37:25.620 --> 00:37:27.850
As a developer, you can treat
the main component,

00:37:27.850 --> 00:37:31.110
RecipientEditTextView, as
a normal text view.

00:37:31.110 --> 00:37:33.580
Just populate it with a comma
separated list of email

00:37:33.580 --> 00:37:36.060
addresses, or use the appended
method, as shown on this

00:37:36.060 --> 00:37:39.920
slide, and it will resolve the
contacts in the chips.

00:37:39.920 --> 00:37:42.040
When you read the text out of
it, you get a string that can

00:37:42.040 --> 00:37:43.820
be tokenized to give
you a list of

00:37:43.820 --> 00:37:45.900
names and email addresses.

00:37:45.900 --> 00:37:47.200
The source code for
chips is in the

00:37:47.200 --> 00:37:48.555
framework's EX directory.

00:37:51.200 --> 00:37:53.470
Photo viewer is a pre-built
activity for viewing

00:37:53.470 --> 00:37:55.210
a gallery of photos.

00:37:55.210 --> 00:37:57.180
It contains scrolling
support, zooming,

00:37:57.180 --> 00:37:58.740
and some other features.

00:37:58.740 --> 00:38:02.010
Launching it is fairly simple,
as you can see here.

00:38:02.010 --> 00:38:04.640
Gmail uses it so that if you
receive a message with image

00:38:04.640 --> 00:38:07.440
attachments, we can present them
all to you in a gallery

00:38:07.440 --> 00:38:09.790
format, rather than sending you
into the Gallery app for

00:38:09.790 --> 00:38:12.200
each individual image.

00:38:12.200 --> 00:38:14.720
For basic gallery browsing, you
have to set up a content

00:38:14.720 --> 00:38:17.220
provider that implements
photo contract.

00:38:17.220 --> 00:38:19.660
This provider must return names,
URIs, and some other

00:38:19.660 --> 00:38:22.120
important items for
the gallery.

00:38:22.120 --> 00:38:24.670
The source code for photo viewer
is in frameworks opt.

00:38:27.550 --> 00:38:30.730
Google Play services is an APK
in a static library that you

00:38:30.730 --> 00:38:33.685
can use to add Google-specific
features to your application.

00:38:33.685 --> 00:38:36.550
The APK is automatically
installed on devices running

00:38:36.550 --> 00:38:39.000
Froyo or higher that have
the Play Store.

00:38:39.000 --> 00:38:41.140
It contains the bulk
of the library.

00:38:41.140 --> 00:38:43.700
The static library is built in
your application and lets you

00:38:43.700 --> 00:38:45.930
talk to the Play Services APK.

00:38:45.930 --> 00:38:48.710
One of the main benefits of
Play services over other

00:38:48.710 --> 00:38:51.520
libraries is that when certain
new features and bug fixes are

00:38:51.520 --> 00:38:54.230
available, we can push those out
to every device, and your

00:38:54.230 --> 00:38:56.740
app will automatically benefit
without even having to release

00:38:56.740 --> 00:38:58.150
your own update.

00:38:58.150 --> 00:39:00.480
For more details on Play
services, refer to the What's

00:39:00.480 --> 00:39:04.440
New in Google Play
Services session.

00:39:04.440 --> 00:39:06.600
To integrate Play Services into
your app, you need to

00:39:06.600 --> 00:39:09.010
build against the library
project and reference it from

00:39:09.010 --> 00:39:09.840
your application.

00:39:09.840 --> 00:39:12.470
At runtime, you need to perform
a check to make sure

00:39:12.470 --> 00:39:15.770
that a new enough version of
Play Services is installed.

00:39:15.770 --> 00:39:19.050
If not, you can use one of the
provided dialogues to prompt

00:39:19.050 --> 00:39:21.880
the user to download
or update it.

00:39:21.880 --> 00:39:24.730
Gmail only uses Play Services
if it's available, and we

00:39:24.730 --> 00:39:26.080
never prompt the user.

00:39:26.080 --> 00:39:29.030
So that's another option if
this functionality isn't

00:39:29.030 --> 00:39:32.260
strictly necessary for
your application.

00:39:32.260 --> 00:39:35.020
Google Play Services has many
features you can use.

00:39:35.020 --> 00:39:36.870
The games API was
just launched.

00:39:36.870 --> 00:39:40.310
There's Google+ integration,
some new location APIs,

00:39:40.310 --> 00:39:42.880
authentication, maps,
and more.

00:39:42.880 --> 00:39:44.780
These were all discussed in
great detail in other

00:39:44.780 --> 00:39:47.266
sessions, so they will
not be covered here.

00:39:47.266 --> 00:39:48.900
VIKRAM: Yeah, that's a
lot of functionality.

00:39:48.900 --> 00:39:51.690
Could we give a quick overview
of what Gmail uses here?

00:39:51.690 --> 00:39:52.840
SCOTT: Sure.

00:39:52.840 --> 00:39:56.080
Gmail uses photosphere support
from Play Services.

00:39:56.080 --> 00:39:58.870
When you receive a Photosphere
attachment, you can view it

00:39:58.870 --> 00:40:01.390
within the message, rather than
having to open it up in

00:40:01.390 --> 00:40:03.470
the gallery and view
it from there.

00:40:03.470 --> 00:40:06.290
To display a Photosphere, you
need to connect to a Panorama

00:40:06.290 --> 00:40:08.590
client and load the Panorama
info by passing

00:40:08.590 --> 00:40:10.270
in the photo URI.

00:40:10.270 --> 00:40:12.880
This will return an intent to
you which you can use to start

00:40:12.880 --> 00:40:17.230
an activity to view
the Photosphere.

00:40:17.230 --> 00:40:19.630
To help you implement Photo
Viewer, and other features we

00:40:19.630 --> 00:40:22.000
talked, about here's the link
with our sample app.

00:40:25.360 --> 00:40:29.660
VIKRAM: All right, we'll have
this link later as well.

00:40:29.660 --> 00:40:30.730
So we've talked about a lot.

00:40:30.730 --> 00:40:33.930
Here's a slide of everything
with links.

00:40:33.930 --> 00:40:35.770
SCOTT: What?

00:40:35.770 --> 00:40:37.220
VIKRAM: Yeah, you're right.

00:40:37.220 --> 00:40:38.980
This is not what we want
to leave you with.

00:40:38.980 --> 00:40:41.210
This is not a talk about
isolated components

00:40:41.210 --> 00:40:42.420
that you can use.

00:40:42.420 --> 00:40:45.300
The idea is a lot
more high level.

00:40:45.300 --> 00:40:47.500
The idea is to recognize what
the framework makes

00:40:47.500 --> 00:40:48.780
available to you.

00:40:48.780 --> 00:40:50.930
Be aware of its functionality.

00:40:50.930 --> 00:40:54.930
Make the framework do most of
the heavy lifting for you.

00:40:54.930 --> 00:40:57.970
The idea is to fit the system
well and to understand the

00:40:57.970 --> 00:41:00.940
standard way of doing things.

00:41:00.940 --> 00:41:04.480
So you do less, and
you focus on what

00:41:04.480 --> 00:41:06.910
makes your users happy.

00:41:06.910 --> 00:41:09.080
On behalf of your users,
thank you for making

00:41:09.080 --> 00:41:10.390
those awesome apps.

00:41:10.390 --> 00:41:14.800
[APPLAUSE]

00:41:14.800 --> 00:41:17.750
SCOTT: Thank you.

00:41:17.750 --> 00:41:20.470
We'll be taking questions
in office hours.

00:41:20.470 --> 00:41:22.970
And please review our session.

00:41:22.970 --> 00:41:26.670
You can use the Google I/O app
to do that, or scan one of the

00:41:26.670 --> 00:41:28.335
QR codes around the room.

00:41:28.335 --> 00:41:29.920
VIKRAM: Yeah, even if you
have to say how bad

00:41:29.920 --> 00:41:31.170
it was, it's fine.

