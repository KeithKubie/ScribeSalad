WEBVTT
Kind: captions
Language: en

00:18:49.235 --> 00:18:51.235
          Test test

00:22:25.439 --> 00:22:27.439
         May 18, 2016

00:22:46.058 --> 00:22:48.058
3:00 p.m.         

00:23:01.277 --> 00:23:09.474
         Stage 7 Lee yoe     e 
yoe       -Lee yoe        Lee 

00:23:09.475 --> 00:23:11.475
yoe 

00:23:20.819 --> 00:23:22.819
:00 p.m. PT

00:23:28.281 --> 00:23:33.364
.   te to Firebase

00:23:56.989 --> 00:23:58.989
. 

00:49:00.113 --> 00:49:03.187
.                    Pashgs

00:52:44.280 --> 00:52:46.280
Google yoke        

00:52:48.869 --> 00:52:50.869
   Google I/O 

00:52:51.918 --> 00:52:56.877
2016.
May 18, 2016.

00:52:57.163 --> 00:52:59.901
May 18, 2016

00:53:03.596 --> 00:53:05.596
.
3:00 Pacific Time

00:53:10.005 --> 00:53:14.940
.
Session AN9.

00:53:15.358 --> 00:53:17.358
Behind the Scenes

00:53:20.472 --> 00:53:23.771
.
What's catch new           New 

00:53:23.772 --> 00:53:25.772
in Android Accessibility

00:56:14.481 --> 00:56:16.932
.
&gt;&gt; Mellow, 

00:56:16.933 --> 00:56:18.433
everyone                Hello, 
everyone, welcome to behind the 

00:56:18.434 --> 00:56:23.322
scenes, what's new in Android 
accessibility.  My name is 

00:56:23.323 --> 00:56:27.222
mooses        Maya Ben Ari, 
product manager on Android 

00:56:27.223 --> 00:56:29.512
accessibility.  With me are a 
couple of people from the 

00:56:29.513 --> 00:56:31.719
accessibility team.  We are 
going to show you a couple of 

00:56:31.720 --> 00:56:36.027
new features, couple new demos, 
        Sill and a   ylvan 

00:56:37.750 --> 00:56:38.121
    ilvano      ylvan     ill             
 unique look of behind the 

00:56:38.122 --> 00:56:40.598
scenes.  This is our agenda for 
today.

00:56:40.599 --> 00:56:44.815
We will give a brief overview 
about accessibility.  We will 

00:56:44.816 --> 00:56:49.304
talk about what's new in 
accessibility in Android, and we

00:56:49.843 --> 00:56:53.144
 will talk about the gesture 
dispatch API and show a couple 

00:56:53.145 --> 00:57:00.933
of very cool demos.  Also we 
will look through voice access, 

00:57:00.934 --> 00:57:04.970
a new service, new accessibility
 service.  Then we will give a 

00:57:04.971 --> 00:57:09.957
brief look of behind the scenes 
in U.S. research.

00:57:10.227 --> 00:57:15.521
So, let's start.  What is 
accessibility?  Accessibility is

00:57:16.008 --> 00:57:19.514
 about create ed, is about 
create and products             

00:57:19.905 --> 00:57:22.946
 ing products that are usable by
 everyone, including people with

00:57:22.947 --> 00:57:27.134
 disabilities, such as motor 
impairment or visual impairment.

00:57:27.324 --> 00:57:31.529
  But I'd like to rephrase this 
definition as slightly different

00:57:31.831 --> 00:57:34.520
.  I would say that 
accessibility is about challenge

00:57:34.926 --> 00:57:41.321
 ing the assumptions we make 
about our users. can the user 

00:57:41.521 --> 00:57:45.822
see the device or distinguish 
between colors?  Can he or she 

00:57:45.823 --> 00:57:49.647
touch the device or hear back 
the sound that the device is 

00:57:49.648 --> 00:57:55.417
producing?  Can the user speak 
back to the device? this is not 

00:57:55.418 --> 00:58:01.624
a small number.  20 percent of 
the user population will have 

00:58:01.625 --> 00:58:04.523
some sort of a disability during
 their lifetime, according to 

00:58:04.524 --> 00:58:11.733
the U.S. census. not only that. 
 Challenge ing the assumption, 

00:58:12.324 --> 00:58:15.411
can been      benefit all the 
users.  Why?  Because some of 

00:58:15.412 --> 00:58:18.631
the technologies that were 
developed in the past, such as 

00:58:19.536 --> 00:58:22.833
speech recognition, or word 
prediction, started as 

00:58:22.834 --> 00:58:27.868
technologies for user with 
accessibility needs. this is not

00:58:27.869 --> 00:58:34.541
 all.  We are all accessibility 
users sometimes.  This is called

00:58:35.523 --> 00:58:39.557
 situational disability.  When 
we drive our car, we cannot look

00:58:39.558 --> 00:58:43.910
 at our phone.  When we are in a
 noisy environment, we cannot 

00:58:43.911 --> 00:58:46.918
hear the sounds of the device 
and we cannot speak back to the 

00:58:46.919 --> 00:58:51.931
device. carry heavy bags from 
the supermarket, we cannot touch

00:58:52.128 --> 00:58:57.241
 the device.  So we want to 
design an inclusive experience 

00:58:57.242 --> 00:59:03.257
for all users, regardless of 
what restriction the user might 

00:59:03.258 --> 00:59:05.258
have.

00:59:06.358 --> 00:59:10.038
Now, let me briefly mention some
 of accessibility service and 

00:59:11.350 --> 00:59:15.630
features available on the 
platform today.  So first, what 

00:59:15.631 --> 00:59:21.537
is an accessibility service?  
This is a privilege, service 

00:59:21.538 --> 00:59:24.446
that changed the interaction 
model with the device in one of 

00:59:24.447 --> 00:59:28.854
two ways     ways.  One, it can 
change the way the user 

00:59:28.855 --> 00:59:32.729
interacts with the device, or it
 can change the way that content

00:59:33.030 --> 00:59:38.540
 is presented to the user. the 
first accessibility service we 

00:59:38.541 --> 00:59:43.618
have on the device today is talk
back.  Talkback is targeted for 

00:59:43.619 --> 00:59:48.541
people with vision impairment, 
or blind, and it's basically a 

00:59:48.731 --> 00:59:53.033
screen reader.  The user can 
interrupt with the device using 

00:59:53.034 --> 00:59:58.150
touch gesture, and content is 
presented, content is spoken to 

00:59:58.151 --> 01:00:03.020
the user through text to speech.
  The second accessibility 

01:00:03.021 --> 01:00:10.542
service is Braille back.
So can we switch to the demo?  

01:00:10.543 --> 01:00:13.234
Braille back is similar to talk
back, just in this case, the 

01:00:13.235 --> 01:00:15.926
user can interrupt with 
something which is called a 

01:00:15.927 --> 01:00:22.455
Braille refreshable display.
The user can type through these 

01:00:22.939 --> 01:00:27.326
keys, or interact with this 
joystick, and then the content 

01:00:28.140 --> 01:00:31.943
is presented using Braille in 
those Braille cells with the 

01:00:31.944 --> 01:00:41.471
dots raising and lowering. 
service is switch access.  

01:00:41.472 --> 01:00:44.036
Switch access is targeted for 
motor impaired users who have 

01:00:44.037 --> 01:00:48.963
trouble interacting with the 
touch display.  In this case, we

01:00:48.964 --> 01:00:51.982
 have something which is called 
adaptive switch.  This adaptive 

01:00:51.983 --> 01:00:56.233
switch has two buttons.  The 
user can configure one button as

01:00:56.946 --> 01:01:01.327
 next and one built       button
 as select.  Using only these 

01:01:01.328 --> 01:01:05.556
two buttons, the user can 
interact with the device, note 

01:01:05.557 --> 01:01:08.863
that the switch can be with more
 or less buttons.

01:01:09.251 --> 01:01:14.147
Can we switch back to the slides
?  The last accessibility 

01:01:14.853 --> 01:01:19.455
service is voice access.  In 
voice access, the user can 

01:01:19.456 --> 01:01:24.428
perform low level interaction on
 the device using only his voice

01:01:24.648 --> 01:01:29.845
.  This is a new service that we
 recently launched, and Patrick 

01:01:29.846 --> 01:01:33.741
and Scott from the accessibility
 group will soon tell us more 

01:01:33.742 --> 01:01:36.580
about this one.

01:01:39.976 --> 01:01:43.952
We also have a couple of 
accessibility features already 

01:01:43.953 --> 01:01:46.034
baked into the platform.  For 
example,

01:03:11.283 --> 01:03:18.525
         Pashgs  ing    ing?  Hi
.  Welcome.  So, I'm very good 

01:03:18.752 --> 01:03:21.871
          very glad to be  
because I can finally share with

01:03:21.989 --> 01:03:26.285
 you what  up to at Firebase.  A
   Today, more than ever, has 

01:03:26.286 --> 01:03:29.604
the tools you need to build a 
success ful    ful          I'm 

01:03:29.605 --> 01:03:35.631
also excited because...I kind of
 came to I/O this      the long 

01:03:35.632 --> 01:03:40.280
way around.  I left a great job 
at Google years ago.  I wanted 

01:03:40.661 --> 01:03:43.541
to dive into this app detail 
       develop thing and change 

01:03:43.809 --> 01:03:47.068
the world with a small up.  This
 small start-up had a you 

01:03:47.299 --> 01:03:50.733
  unique vision.   we could en 
   empofrp   wer developers by 

01:03:50.734 --> 01:03:57.133
lettinged to create and  back 
end that needed to support that.

01:03:58.630 --> 01:04:01.595
  And      that start-up, of 
course, was partly sunny 

01:04:01.820 --> 01:04:03.820
        se. 

01:04:06.082 --> 01:04:09.800
 So          Parse.  So, before 
I oined Google and teamed up 

01:04:09.801 --> 01:04:12.459
with the Firebase team , I spent
 three years on the partly sunny

01:04:12.624 --> 01:04:15.233
         se team.  Most 

01:04:16.003 --> 01:04:19.159
    Parse team.   known as lead 
develop er   er for partly sunny

01:04:19.417 --> 01:04:22.537
         se     Parse push 
   Push.  And in when there were

01:04:22.782 --> 01:04:26.935
 reliability and scaleability  
tended to hit only the largest  

01:04:27.157 --> 01:04:30.478
        I worked a lot between t
he backened     end develop 

01:04:30.641 --> 01:04:38.245
            ae   nd   ae   end 
developers and  team.  As a fowl

01:04:38.615 --> 01:04:40.478
    Fowler      fowl      former
 partly sunny         se

01:04:40.479 --> 01:04:44.021
     Parse team member, hearing 
 shut down hurt me physically 

01:04:44.022 --> 01:04:46.345
and to anybody was a partly 
sunny         se     Parse 

01:04:46.346 --> 01:04:49.729
customer in this room, I want to
 express cere est    st a

01:04:52.680 --> 01:04:55.213
pologies.  Nope      Nobody in 
partly 

01:04:52.680 --> 01:04:54.037
sunny         se     Parse, nor 
Firebase;  what's 

01:04:54.038 --> 01:04:56.853
happening                  
                   , happy with 

01:04:56.854 --> 01:04:59.613
what's happening here today.  
We're not with the fain      

01:04:59.614 --> 01:05:02.863
pain you've gone through.   my 
former teammates in partly sunny

01:05:03.057 --> 01:05:05.865
         se     Parse, I want to
 express  I am that they've 

01:05:05.866 --> 01:05:10.098
response ive   e yibl      ibly 
handled this tragedy   ic  

01:05:10.420 --> 01:05:13.286
Firebase gave a year notice they
 were doing a down.  They gave 

01:05:13.287 --> 01:05:17.318
an open source implementation of
  end and         ae   end and 

01:05:17.319 --> 01:05:20.386
dead  dicated themselves to 
spend the next  ing    ing 

01:05:20.387 --> 01:05:23.588
customers migraine   te.  I 
think we should all thank       

01:05:23.746 --> 01:05:25.746
thank you for Senate        
setting 

01:05:32.125 --> 01:05:35.244
         So, the advice I'm 
going to give today is 

01:05:35.463 --> 01:05:42.302
Jen   generic.   have to have 
been a     .  But...I've decided

01:05:42.847 --> 01:05:45.902
 to lay out the content to 
people who are like me coming 

01:05:45.903 --> 01:05:47.903
from a partly sunny 
           Parse back end 

01:05:51.072 --> 01:05:52.565
Understand ing    ing all the 
nefrp   w feet  atures available

01:05:52.566 --> 01:05:55.785
 in          We're going to 
start today by looking at how 

01:05:55.786 --> 01:06:00.489
Firebase in the doing     Google
 eek  cosystem.  And why 

01:06:00.959 --> 01:06:03.660
Firebase can help  if you 
already have a back end     ae

01:06:03.854 --> 01:06:08.788
   end.  , we're going to look 
at the set of products .    that

01:06:09.020 --> 01:06:13.928
 can help cover the feet  ature 
gap .com and Parse serve er 

01:06:14.150 --> 01:06:17.632
       Server.          Then, 
we're going to cover some novel 

01:06:17.940 --> 01:06:21.720
feet  atures, you   unique 
Firebase, that have no Parse 

01:06:21.721 --> 01:06:23.813
alternate ive and finally,

01:06:27.344 --> 01:06:30.757
 deep into the internals of how 
you build your app  see how 

01:06:31.089 --> 01:06:35.963
Firebase' approach gives  never 
     , new tools.          So, 

01:06:35.964 --> 01:06:38.475
we welcome you to Google.  No 
matter where       where you are

01:06:38.689 --> 01:06:43.084
  what you might already be 
running your ication on, even if

01:06:43.306 --> 01:06:45.959
 it's Parse serve er 
       Server.  Because with  

01:06:46.183 --> 01:06:50.974
you can build just about 
anything.  You know,  look at 

01:06:50.975 --> 01:06:54.040
back ae   end service, we tip 
 ypically compare it       to 

01:06:54.190 --> 01:06:58.073
one of four alternate 
     itudes.  At the very bottom

01:06:58.697 --> 01:07:02.922
 we have an rastructure as a 
service.  These give      give 

01:07:02.923 --> 01:07:06.581
us the raw  blocks we can use to
 build any back ae   end, as 

01:07:06.582 --> 01:07:10.699
long  the time and expertise.  
In doing     Google, this  means

01:07:11.175 --> 01:07:13.175
 Google compute engine 
             Compute Engine, 

01:07:13.176 --> 01:07:16.790
where you can         you   cess
 to raw virtue al    al machines

01:07:16.791 --> 01:07:22.253
 or Google contain er  where you
 can scale up and down instances

01:07:22.486 --> 01:07:25.928
.  If , you can go up the stack.
  You can trade off  the 

01:07:25.929 --> 01:07:28.697
operation al   al response 
ibility by use ing  as a service

01:07:28.968 --> 01:07:33.424
.  Like Google app engine  
        App Engine or the up  

01:07:34.027 --> 01:07:36.814
Google Google Cloud             
 Cloud functions.        These 

01:07:36.815 --> 01:07:39.731
products let you continue 
developing back ae   end while 

01:07:39.732 --> 01:07:42.905
not need ing    ing to worry 
about which servers your 

01:07:50.891 --> 01:07:53.701
    end runs on.  You can go the
 next lay yer    er up on 

01:07:53.877 --> 01:07:57.135
        yer    er up and use  as
 a service like Firebase to hand

01:07:57.362 --> 01:08:01.989
 off some of mental response 
ibility. S    ies.  Because, 

01:08:02.283 --> 01:08:05.280
backend as service provides a 
sweet       suite of inter 

01:08:05.461 --> 01:08:09.568
grated feet  atures that a  to 
spend most, or even all of your 

01:08:09.569 --> 01:08:14.862
time, focus on the client code. 
  we're not going to spend time 

01:08:14.863 --> 01:08:18.353
today covering        lasz t 
level, software as a service, 

01:08:18.354 --> 01:08:23.031
but I listed here,,  
                      it  to 

01:08:23.032 --> 01:08:26.168
remind you that Google is fairly
 you   unique.  power ful    ful

01:08:26.169 --> 01:08:28.967
 and success ful    ful products
 at all layers  stack, which 

01:08:28.968 --> 01:08:31.652
means, when you choose to 
develop with  you're not cyto 

01:08:31.882 --> 01:08:35.864
     stuck at only one alternate
      itude.  You can  out.  

01:08:37.489 --> 01:08:42.708
agine if you have a backend 
today written on Google  

01:08:43.027 --> 01:08:46.190
             Compute Engine.  
Odds are, if you're distribute 

01:08:46.191 --> 01:08:48.563
ing     ing files, use ing 
    ing Google          e ing 

01:08:48.925 --> 01:08:50.094
    ing gloudz          e 
ing     ing Google Cloud storage

01:08:50.095 --> 01:08:54.046
 to much      doo  so.  
Tradition  if you wanted to give

01:08:54.336 --> 01:08:57.414
 users acre  cess to  you have 
to create your own A pfk    PI 

01:08:57.415 --> 01:09:01.817
serve er   r to control has acre
  cess to which files.  , starti

01:09:01.980 --> 01:09:06.597
ng today, you can use Firebase 
storage       Storage.  backend 

01:09:06.767 --> 01:09:10.422
as a service lay yer    er on 
top of the infra    goo     

01:09:10.423 --> 01:09:15.943
Google Cloud storage.  This will
 let  a simple rules file to 

01:09:16.123 --> 01:09:19.235
describe for your entier  should
 have acre  cess and it saves 

01:09:19.236 --> 01:09:22.504
you the need need ing    ing to 
manage and scale a service 

01:09:22.932 --> 01:09:27.420
between your and your users.    
      Simple   ilarly, you'll 

01:09:27.421 --> 01:09:32.188
also be able to go down the 
stack.      , I'm announce ing

01:09:32.403 --> 01:09:35.494
     ing the upcoming goo     
Google Cloud ully inter grate 

01:09:35.495 --> 01:09:39.135
with Firebase.  You'll be  react
 to changes that happen in the 

01:09:39.136 --> 01:09:43.470
Firebase eek .          So...
this means that if you already 

01:09:43.658 --> 01:09:47.006
have a backend, .  And if it's 
at a different alternate 

01:09:47.178 --> 01:09:50.595
     itude from  that's also 
fine.  If you've migraine   ted 

01:09:50.596 --> 01:09:54.164
from  to Parse serve er 
       Server, you've        

01:09:54.165 --> 01:09:57.971
you've gone from a backnd  end 
at service to infrastructure or 

01:09:57.972 --> 01:10:00.902
platform as a service. that's 
the right choice for your team, 

01:10:01.087 --> 01:10:03.597
I encourage  stick with it chlt 
    .  Because Firebase can help

01:10:03.830 --> 01:10:06.206
 you, no  your exist ing    ing 
solution is today.  

01:10:09.876 --> 01:10:14.657
, we have a series of feet 
 atures that cover the  between 

01:10:14.658 --> 01:10:23.076
Parse.com and Parse serve er 
  r.  These  crash reporting, 

01:10:23.077 --> 01:10:24.816
Parse an          
               Crash Reporting, 

01:10:24.817 --> 01:10:28.825
Parse an lit    alytics 
        Analytics, Parse host  

01:10:28.826 --> 01:10:31.599
Parse config      Config.       
  Firebase has products in all 

01:10:32.449 --> 01:10:35.282
these areas.  Let's look  you 
can recover these product areas 

01:10:35.283 --> 01:10:40.959
and do more you ever could 
before.   and foremost, you 

01:10:40.960 --> 01:10:45.920
should check out Firebase an  
This is the crown jewel of the 

01:10:46.564 --> 01:10:51.126
nefrp   w Firebase .  You don't 
need to add code to start use 

01:10:51.290 --> 01:10:55.250
ing     ing it and  no charge, 
no matter how many A pfk    PI 

01:10:55.251 --> 01:10:59.280
requests send.          If you 
have complex analysis needs, 

01:10:59.525 --> 01:11:03.614
Firebase an lit      Analytics  
grate with Google bit 

01:11:03.615 --> 01:11:05.615
questionnaire          ry 
        Bit Query will let you 

01:11:05.748 --> 01:11:08.780
slice  your data as you see fit 
and an lit    alytics 

01:11:09.004 --> 01:11:11.496
        Analytics, sets       
sets the  many other inter

01:11:11.743 --> 01:11:16.332
 grations with Firebase products
 , this is our new an lit 

01:11:16.670 --> 01:11:20.700
   alytics idea      dear      
dear      dashboard.  Ads     As

01:11:20.921 --> 01:11:24.765
 you'll  the most important feet
  ature is at the top.   are use

01:11:24.976 --> 01:11:28.199
 ing     ing your application?  
We sliced that down  

01:11:34.392 --> 01:11:37.421
daily, weekly and monthly users 
of your app so understand the 

01:11:37.422 --> 01:11:40.635
next engagement.         Next, 
you can scroll down and see ret

01:11:40.968 --> 01:11:44.597
ention could he      horts.   a 
fans cy word for do your users 

01:11:44.598 --> 01:11:47.558
keep use ing     ing your  do 
they get board       bored with 

01:11:47.559 --> 01:11:51.125
it?  Retention could he 
     horts  your use yer    r 

01:11:51.126 --> 01:11:54.647
base based on which which week 
they d use ing     ing your app.

01:11:54.648 --> 01:11:56.977
  You can look overtime 
       vertically  line and see 

01:11:56.978 --> 01:12:01.091
when did people stop use ing 
    ing my app?         Now, 

01:12:01.092 --> 01:12:07.228
you'll also notice this dashb
oard is show ing    ing  users 

01:12:07.580 --> 01:12:10.902
age 25 to 34.  This application 
wasn't  providing that 

01:12:11.295 --> 01:12:17.150
information to Firebase.  With  
you automatically get power ful 

01:12:17.339 --> 01:12:20.767
   ful information,  ing    ing 
any code, you understand where 

01:12:20.768 --> 01:12:27.060
your new  are coming from, how 
many of them are coming back, , 

01:12:27.231 --> 01:12:30.060
they're use ing     ing your app
 when they do, and even  

01:12:30.061 --> 01:12:35.425
information like their agenda 
     gender, age, country, s.  

01:12:35.426 --> 01:12:40.290
All in a free product.   if 
you'd like, you can add extra 

01:12:40.291 --> 01:12:43.214
information for     alytics 
        Analytics as well.  You 

01:12:43.215 --> 01:12:49.407
can describe custom attribute  
users or provide up to 5 hnd

01:12:49.663 --> 01:12:53.964
    00 custom types of  like to 
send.  And you can use this  

01:12:53.965 --> 01:12:55.965
dive deep er   er into your 
groups. 

01:12:58.676 --> 01:13:04.495
 But if you to compose that, you
 can do so in add  udiences.  

01:13:04.496 --> 01:13:10.013
Add    let you describe a 
collection of users who  

01:13:10.014 --> 01:13:12.014
characteristics and 

01:13:13.987 --> 01:13:18.006
 into a        demographic in 
your app and understand how they

01:13:18.244 --> 01:13:22.035
 use it  also use eu    add 
 udiences to reen  -engage 

01:13:22.036 --> 01:13:24.417
customers in application.  Use 
ing     ing Firebase 

01:13:24.418 --> 01:13:26.418
notifications, or config. 

01:13:30.323 --> 01:13:34.132
  I said, you don't need to add 
code to use an lit 

01:13:34.316 --> 01:13:37.171
     Analytics.  It's part of 
the core SDK, but if like to add

01:13:37.540 --> 01:13:41.801
 additional properties, you can 
say set     r property string or

01:13:42.059 --> 01:13:47.230
 you can log additional events  
event with name,  parameters.  

01:13:47.418 --> 01:13:52.878
Asks      It's that ease y.  .
..if you are like me, you 

01:13:52.879 --> 01:13:56.275
occasionally write in 
                im ware and...

01:14:01.806 --> 01:14:06.068
one of the biggest problems I  
track ing    ing down what went 

01:14:06.069 --> 01:14:09.245
wrong in the field.  The  you 
get a bug report, it's hard to 

01:14:09.246 --> 01:14:12.121
translate  use yer    r is 
describe ing to an actual crash 

01:14:12.122 --> 01:14:16.228
dumb p. second time you get a 
bug report, you need to tree  is

01:14:16.381 --> 01:14:20.187
 this a new issue or should I 
save myself time not debug this 

01:14:20.440 --> 01:14:23.118
because it's already known?  
When you  third crash report, it

01:14:23.331 --> 01:14:25.825
 seems familiar, you need  
         figure out whether or 

01:14:25.826 --> 01:14:29.409
not this is a known issue  been 
fixed or whether that bug has 

01:14:29.744 --> 01:14:31.744
reGreg      
                reGreg     d and

01:14:31.938 --> 01:14:35.126
 crash reporting can help you 
solve   of these important 

01:14:35.127 --> 01:14:38.019
problems.  , in the crash report
ing dashboard, you can 

01:14:41.678 --> 01:14:43.853
see at a, how many crashes 
        crashes are happening in

01:14:44.095 --> 01:14:46.095
 your app  There's three 
important

01:14:49.195 --> 01:14:52.302
                  , we've 
grouped them together into crust

01:14:52.492 --> 01:14:54.957
    lusters.  Crust    lusters 
ors with simple   ilar stack 

01:14:54.958 --> 01:14:59.357
traces and likely have the  
cause.  This can greatly help 

01:14:59.358 --> 01:15:02.115
you tree  iage and into the 
individual reports that you see.

01:15:02.116 --> 01:15:10.504
  You can   iage by how many use
rs are impacted by these        

01:15:10.505 --> 01:15:13.212
  Now, when we scroll down into 
crust    lusters, you can see we

01:15:13.213 --> 01:15:17.462
 have detailed information.  We 
see the stack  the latest 

01:15:17.463 --> 01:15:22.367
version that this app is crashed
 for, you can also dive into 

01:15:22.622 --> 01:15:29.420
every single error that  reports
 have detailed information.   

01:15:29.862 --> 01:15:34.061
what device was running this app
.  understand whether that 

01:15:34.062 --> 01:15:36.062
device was jail broken.

01:15:39.799 --> 01:15:43.903
   how much memory was available
 in the  where       what 

01:15:43.904 --> 01:15:46.004
wrouchl         country it was 
in.  You can understand why     

01:15:46.386 --> 01:15:49.275
 on was I     Wi-Fi or cellular.
  One great feet  ature  

01:15:53.044 --> 01:15:55.303
 Android is that you can report 
non- fate al       fatal errors 

01:15:55.304 --> 01:15:58.863
as  You don't have to wait for a
 crash to improve  your app. 

01:16:02.241 --> 01:16:05.821
 Crash reporting                
  reporting also comes without 

01:16:05.822 --> 01:16:11.622
code by default.   of the core S
DK on an  Android.  In I ofking 

01:16:11.870 --> 01:16:14.577
pod.  However...you can make  
ease ier     ier if you'd like 

01:16:14.757 --> 01:16:16.757
to add a little bit of 

01:16:21.643 --> 01:16:23.643
 First, Firebase crash

01:16:30.668 --> 01:16:36.983
      crash.log reports this.  
And a non- fate al 

01:16:37.178 --> 01:16:39.178
      fatal     - fatal 
      fatal error, Firebasec

01:16:39.463 --> 01:16:43.740
rash.report.          Now...if 
you have an exist ing    ing 

01:16:43.741 --> 01:16:47.134
backend, odds are you have a 
serve er   r that is able to 

01:16:47.135 --> 01:16:49.135
host web kon tent
        content. 

01:16:51.263 --> 01:16:56.635
 you check out a dead  dicated 
host ing  It can make your life 

01:16:56.636 --> 01:17:02.917
much ease ier you can use a sim
ple command .  Which is Firebase

01:17:02.918 --> 01:17:06.827
 redeploy, you deploy an en  re 
copy of your static website.  If

01:17:06.828 --> 01:17:13.122
 you screws up  an issue, you 
can safely get back to a well-  

01:17:13.123 --> 01:17:15.436
use ing     ing fire base  
           e ing     ing 

01:17:15.437 --> 01:17:18.143
Firebase roll balk      back.

01:17:23.592 --> 01:17:28.419
 locally with the same software 
that we use  infrastructure.   

01:17:28.420 --> 01:17:30.103
Firebase host ing    ing is 
fast            

01:17:30.104 --> 01:17:33.153
ing        Hosting is fast.  It 
automatically inter  content 

01:17:33.154 --> 01:17:37.586
delivery networks to make sure  
is deliver aechd quickly a     

01:17:37.753 --> 01:17:41.797
           ed quickly across the
 globe and  secure.  We're SSL 

01:17:41.996 --> 01:17:45.437
first.  We manage all of the  
that you need to handle to serve

01:17:45.682 --> 01:17:50.066
 as a      secure con  You just 
give us files, and we give you a

01:17:50.067 --> 01:17:55.475
 fast  network.                 
     Firebase host ing    ing is

01:17:55.676 --> 01:17:58.936
 so ease y to use, I actually 
strug to come up with a 

01:17:58.937 --> 01:18:01.908
follow-up slide here.  So,  I 
decided to give an announcement.

01:18:01.909 --> 01:18:05.701
  Starting  Firebase host ing 
       Hosting supports custom 

01:18:05.702 --> 01:18:09.926
doe mains absolute .  

01:18:17.103 --> 01:18:20.080
         Now our final product 
app between Parse

01:18:24.033 --> 01:18:25.730
 remote config
             Remote Config.  

01:18:25.731 --> 01:18:28.613
It's a power ful    ful  I'm 
happy to share t it with you 

01:18:28.614 --> 01:18:31.069
today.   need die nam 
     ynamic content in your app

01:18:31.272 --> 01:18:35.364
lication,  database isn't really
 the right place to put it. 

01:18:36.263 --> 01:18:38.098
                       Firebase 
remote config             Remote

01:18:38.099 --> 01:18:40.879
 Config let's you store die nam
      ynamic content Parse conf

01:18:41.147 --> 01:18:44.760
ig      Config did, except you 
have the ability  what you're 

01:18:44.761 --> 01:18:46.888
sending according to the 
Democrat        demographics  

01:18:46.889 --> 01:18:49.776
use yer    r.  You can send 
different con figs to . 

01:18:53.996 --> 01:18:57.443
 agine you've written a 
newspaper  Newspapers of old had

01:18:57.757 --> 01:19:03.076
 headlines.  We're going to  
into our application.  That 

01:19:03.278 --> 01:19:06.656
headline is meant to gagement 
and will do so with relevance.  

01:19:07.497 --> 01:19:10.783
With  config             Remote 
Config, you can target national 

01:19:11.225 --> 01:19:16.445
 users who are in a particular 
Kuru      country.  If you ple 

01:19:16.446 --> 01:19:22.508
headlines, you can do a tested 
rollout and  rollout to doo  AB 

01:19:22.509 --> 01:19:24.859
test ing    ing to see whether 
or  nefrp   w headline is 

01:19:24.860 --> 01:19:27.771
driving the edge      engagement
 you          If you're a multi

01:19:28.130 --> 01:19:31.130
-Marin       ling     lingual 
product, you can add trans  in 

01:19:31.131 --> 01:19:34.882
your remote cog     config, by 
providing a config based on the 

01:19:34.883 --> 01:19:39.362
language of the device  cess ing
    ing this.         And if you

01:19:39.363 --> 01:19:43.433
 have particular interest groups
 within your  those will 

01:19:43.434 --> 01:19:46.709
probably be in an lit    alytics
         Analytics.  You'll have

01:19:46.894 --> 01:19:49.098
 an add  udience for people who 
love snowballed            

01:19:49.099 --> 01:19:52.751
snowboard  look      love 
Google.  So, you can past      

01:19:52.752 --> 01:19:59.859
post all  I ofk    /O news he'll
   adlines to people in the add 

01:20:00.211 --> 01:20:02.396
 udience in an lit
      Analytics.          Use 

01:20:02.397 --> 01:20:05.594
ing     ing remote config is    
            Remote Config is 

01:20:05.595 --> 01:20:09.294
ease y.  There are three things 
 to doo  to get started.  You 

01:20:09.295 --> 01:20:14.366
want to provide off faults.  
These will be used before your  

01:20:14.367 --> 01:20:19.788
or any time the cash value is 
too old to able.  , you can tell

01:20:20.169 --> 01:20:22.169
 remote config to fetch or fetch

01:20:25.503 --> 01:20:29.900
 duration.  This will make sure 
you get a  of remote config 

01:20:30.045 --> 01:20:32.678
            Remote Config if it 
has expired. , finally, once 

01:20:32.679 --> 01:20:36.253
remote config             Remote
 Config has acre  cessed the , 

01:20:36.254 --> 01:20:39.244
it doesn't automatically make it
 available.   pretty bad if you 

01:20:39.245 --> 01:20:42.429
started configure ing     ing 
your app  set of con

01:20:45.470 --> 01:20:50.937
date in between.   line activate
 fetched helps you coordinate 

01:20:50.938 --> 01:20:56.263
copies  config with how your app
lication flows.  Once  latest 

01:20:56.264 --> 01:21:00.016
copy of remote config, you can 
use  lodge   gic like you would 

01:21:00.296 --> 01:21:04.665
a dictionary.  Use and tacks and
 act as any property by name and

01:21:04.902 --> 01:21:08.945
  a wrapper object back where 
you can get, spools, whatever 

01:21:08.946 --> 01:21:10.946
you'd like.

01:21:15.533 --> 01:21:19.063
   feet  atures help us gain 
parent a          parrot   ity 

01:21:19.064 --> 01:21:22.035
from Parse serve er 
       Server  what we had in 

01:21:22.036 --> 01:21:25.078
Parse.com.  we go onto the 
things that are the core f of 

01:21:25.079 --> 01:21:29.339
your  you might need to choose 
between one backend , I want to 

01:21:29.340 --> 01:21:32.349
give a brief shout out to some 
novel feet  atures that are you 

01:21:32.520 --> 01:21:38.193
  unique to Firebase.  , we have
 die nam      ynamic links.  Die

01:21:38.194 --> 01:21:42.882
 nam      ynamic links ares for 
your application.  They can 

01:21:42.883 --> 01:21:46.545
share the location tent deep 
within your app.  They work even

01:21:46.776 --> 01:21:50.867
 for use  don't have the app in
stalled yet.         SHA  hazam 

01:21:50.868 --> 01:21:53.864
has been invesz ting n in die 
nam      ynamic links recently 

01:21:54.224 --> 01:21:56.643
by  ing    ing with coke  ca 
koel         Coca-Cola to print 

01:21:56.644 --> 01:21:59.289
them on their bottles 
               bottles  get a 

01:21:59.290 --> 01:22:02.718
warm welcome for users that want
 tri-      try out f   the app

01:22:02.950 --> 01:22:05.205
lication         In case you're 
not fortunate enough to partner 

01:22:05.206 --> 01:22:07.258
with  ca koel         Coca-Cola,
 we have another product for you

01:22:07.440 --> 01:22:11.718
.  With vites, your users can 
send these die nam      ynamic  

01:22:11.719 --> 01:22:14.145
their friends regardless of 
whether or not  ing     ing your

01:22:14.146 --> 01:22:16.146
 app. 

01:22:18.434 --> 01:22:20.434
 And then you can improve or

01:22:23.361 --> 01:22:27.114
 index ing    ing allows the 
doing     Google search engine 

01:22:27.115 --> 01:22:29.755
to crawl die nam      ynamic 
links in your app and provide 

01:22:29.756 --> 01:22:36.720
deep links  app's content in 
Google search results.  , since,

01:22:36.968 --> 01:22:41.896
 like I said, I'm fallible and 
many of you are as well, we have

01:22:41.897 --> 01:22:45.844
 Firebase test lab        Test 
Lab for an  This will let you 

01:22:45.845 --> 01:22:50.632
automate your app on many s 
owned by doing     Google.  You 

01:22:50.633 --> 01:22:54.882
can get much  test coverage 
without having to buy every an  

01:22:54.883 --> 01:22:56.883
that

01:22:58.742 --> 01:22:59.884
 increase paid growth in your 
application by      ing the 

01:22:59.885 --> 01:23:04.979
nefrp   w inter grations with 
doing     Google ad words       

01:23:05.621 --> 01:23:12.413
 Ad Words.         Words.  You 
can your ads to that Democrat 

01:23:12.676 --> 01:23:13.097
       demographics 
           Democrat        demographic

01:23:13.098 --> 01:23:17.272
 and you can earn  your app
lication by use ing     ing 

01:23:17.273 --> 01:23:20.889
Google AdMob that  advertise
ments in your application. 

01:23:25.934 --> 01:23:29.006
 , now the meet      meat of the
 talk.  The remain ing    ing 

01:23:29.007 --> 01:23:32.524
products more central to the way
 you build an application. s, AU

01:23:32.902 --> 01:23:39.376
  authentication, and data.  So 
there did           they a deep 

01:23:39.613 --> 01:23:42.391
er   er look.  Fear      First 
and foremost, notification have 

01:23:42.392 --> 01:23:45.524
a special place in mchl   y 
heart.   two products in this 

01:23:45.525 --> 01:23:50.817
sort of area.  Google         
ing           Messaging is now 

01:23:50.818 --> 01:23:52.982
Firebase cloud     Cloud message
 ing           Messaging.  This 

01:23:53.426 --> 01:23:55.867
 that provides a low-level 
service for 

01:24:00.188 --> 01:24:01.539
ing content directly to an app, 
for push ing    ing data to  

01:24:01.540 --> 01:24:04.093
    .  It is still free      
psychiatry            freely 

01:24:04.094 --> 01:24:06.993
available, access yibl     ible 
from the  pfk    PIs and is the 

01:24:06.994 --> 01:24:11.970
platform that other providers, 
like  urban hair      ar 

01:24:13.101 --> 01:24:15.395
       Urban Airship already use
 today for     to reach your  

01:24:15.396 --> 01:24:18.661
from their purse       push 
platforms.         Nothing in 

01:24:19.087 --> 01:24:20.848
Firebase cloud     Cloud message
 ing           Messaging 

01:24:20.849 --> 01:24:24.722
requires you to  fire      
Firebase services.  On top of 

01:24:24.723 --> 01:24:26.723
that, we built s. 

01:24:31.783 --> 01:24:34.503
 This is the set of products 
will help you use information 

01:24:34.504 --> 01:24:38.651
you gained   to more acre 
 curately target your users and 

01:24:38.652 --> 01:24:42.123
create  for those users.        
  So, let's look at the nefrp 

01:24:42.363 --> 01:24:44.363
  w dashb

01:24:45.453 --> 01:24:49.995
oard.  Obviously a  er   r 
should let you type in a.  You 

01:24:49.996 --> 01:24:55.022
can also schedule the 
notification to  now or later.  

01:24:55.023 --> 01:24:59.618
You can schedule it to be now, 
an exact time in the future, or 

01:24:59.619 --> 01:25:03.671
a time       relative to the use
 yer    r's device ing    .  If 

01:25:03.672 --> 01:25:06.625
you have that news ication, you 
can schedule the push to be sent

01:25:07.431 --> 01:25:10.877
 every at 8:30 at the use yer 
   r's time zone. 

01:25:13.915 --> 01:25:18.585
  the real power of Firebase 
notifications  its target ing 

01:25:18.837 --> 01:25:24.266
   ing framework.  With Firebase
 , you can use all of that rich 

01:25:24.741 --> 01:25:27.373
knowledge  in Firebase an lit 
     Analytics to target your 

01:25:27.613 --> 01:25:31.786
users  like.  You can target 
your users with the  udiences 

01:25:31.787 --> 01:25:37.203
you've created.   you're mover a
 Parse push to channel the     

01:25:37.204 --> 01:25:42.281
person, then I  out topics.  
They're the same John      

01:25:42.282 --> 01:25:46.839
general , you subscribe to a top
ic and receive pushes  that topi

01:25:47.077 --> 01:25:50.448
c.  The main difference between 
push to  use ing     ing topics 

01:25:50.449 --> 01:25:55.867
is that topics is about 50  er  
        And then, finally, if 

01:25:55.868 --> 01:25:59.213
you're test ing    ing an 
individual       device, you can

01:25:59.450 --> 01:26:04.969
 use this console to target just
 your  that you can be confident

01:26:04.970 --> 01:26:07.839
 you haven't just headline 
     llo world to your enpicture

01:26:08.082 --> 01:26:11.197
 use yer               tier  re 
use yer    r base.  I have seen 

01:26:11.347 --> 01:26:14.655
happen, actually.  It's not the 
greatest page to 

01:26:18.703 --> 01:26:22.697
  , Firebase notifications inter
 grates with Firebase  

01:26:22.830 --> 01:26:25.122
     Analytics in both direction
s.  You can use an lit 

01:26:25.217 --> 01:26:28.381
   alytics to  you want to en
gage and you can use an lit 

01:26:28.568 --> 01:26:32.159
   alytics  whether or not you 
use     successfully eng

01:26:32.507 --> 01:26:36.184
 udience.   automatically 
measure how     how many pushes 

01:26:36.451 --> 01:26:41.228
were sent and were opened, but 
we will also be able to  

01:26:41.527 --> 01:26:45.072
conversion of    event if you 
apply one.  , you know, in this 

01:26:45.073 --> 01:26:51.547
example, we have asked the use 
to look at a new talk.  Or    

01:26:51.548 --> 01:26:54.901
Our goal here is that they star 
that session, they'll add the 

01:26:54.977 --> 01:26:59.173
talk to their.  If you do so, it
 will shoch up in our an 

01:26:59.865 --> 01:27:01.865
                   show up in 
our an lit      

01:27:02.612 --> 01:27:05.557
        Analytics funnel.  
understand more about Firebase 

01:27:05.558 --> 01:27:08.753
notifications and  message ing 
                Cloud Messaging,

01:27:08.980 --> 01:27:14.310
 check out these two talks.  We 
CM is now FCM, which covers that

01:27:14.703 --> 01:27:17.247
 foundation            
foundation al  On top of it, we 

01:27:17.248 --> 01:27:20.696
have Firebase notification  
everything you need to know in 

01:27:20.697 --> 01:27:25.726
45 minutes , I'm going to give a
 lot of shout outs to        

01:27:25.926 --> 01:27:30.633
outs  talks, I'll post them all 
on the spaces after  You don't 

01:27:30.634 --> 01:27:35.387
need to take pictures of every  
slide.         Firebase author 

01:27:35.388 --> 01:27:37.388
author              

01:27:41.197 --> 01:27:44.289
 author      Auth describes who 
is use ing     ing your app.  

01:27:44.477 --> 01:27:48.250
It's  same providers you     you
 used to expect and more.   

01:27:48.251 --> 01:27:51.454
importantly, Firebase author 
     Auth allows you to provide 

01:27:51.455 --> 01:27:56.325
own backend service to control 
your end AU  authentic and it

01:28:02.100 --> 01:28:05.219
 Firebase author, it's so pow  
                pow             

01:28:05.518 --> 01:28:09.115
      Auth, it's so power  
implement log in   in where you 

01:28:09.116 --> 01:28:13.108
log into  ing     ing a Parse 
session token.  , for any 

01:28:13.441 --> 01:28:16.218
service, if you have Parse serve
 er        Server, which going 

01:28:16.463 --> 01:28:20.352
to stay around, that might be a 
fine strategy. are on Parse.com,

01:28:20.547 --> 01:28:25.570
 I recommend that you use,  a  
the client side.  When someone 

01:28:25.571 --> 01:28:29.296
tries to in, you'll try to log 
in against Firebase.  If that  

01:28:29.539 --> 01:28:35.946
ceed, but does credentials that 
you still have in your app to a 

01:28:35.947 --> 01:28:39.441
new use yer    r in Firebase and
 then migraine   te the  Parse 

01:28:39.442 --> 01:28:47.086
use yer    r over to your 
Firebase database.  , Firebase 

01:28:47.087 --> 01:28:53.734
sessions have the same power of 
Parse , except we use crypt 

01:28:53.735 --> 01:28:56.567
Colonelfy sped      instead of 
the                             

01:28:56.821 --> 01:29:00.849
  Krog              yog 
   ography instead of the data .

01:29:00.850 --> 01:29:05.801
  It includes all of the things 
you'd have had  PF session 

01:29:05.802 --> 01:29:08.816
object, except it's enkoed 
   coded and by your app's 

01:29:09.144 --> 01:29:12.284
product key.  This means, you 
can  sure that the session is 

01:29:12.285 --> 01:29:17.042
valid, which use yer    r it , 
when it's supposed to expire and

01:29:17.292 --> 01:29:22.497
 any custom  have from your 
personal author      Auth 

01:29:22.498 --> 01:29:25.734
service.  Rules  particular 
session is from an I ofk    OT 

01:29:25.735 --> 01:29:29.557
device and  should have res
tricted acre  cess.  can all be 

01:29:29.558 --> 01:29:32.636
verify ied directly on the 
session toke  without having to 

01:29:32.637 --> 01:29:38.349
make an extra A pfk    PI 
request for  that you make.   

01:29:38.350 --> 01:29:43.614
Firebase author      Auth inter 
grates with Firebase rules.  In 

01:29:43.615 --> 01:29:46.989
system like Parse rngs every
           , every object 

01:29:46.990 --> 01:29:50.445
describes its own acre control. 
 And as an app administrator, 

01:29:50.446 --> 01:29:52.569
this can to unsernt 
    certainty.  Because you 

01:29:52.570 --> 01:29:57.448
can't actually add  udit   cess 
control in your system and     

01:29:57.449 --> 01:30:01.747
unless you read your entier  re 
catch        er  re app's con

01:30:02.094 --> 01:30:05.390
tents         Even worse?  If 
you need to update information 

01:30:05.391 --> 01:30:10.858
or  your application, if you 
need to give admins  cess, you 

01:30:10.859 --> 01:30:14.067
would have to doo  a full data 
migration of tier  re 

01:30:14.068 --> 01:30:20.723
application for this to work.  
Instead,       Auth and Firebase

01:30:21.923 --> 01:30:25.506
 ask the         security rules 
allow you to  one file, the 

01:30:25.507 --> 01:30:28.631
rules that should be applied 
entier  re systems.  Your enfire

01:30:28.942 --> 01:30:32.296
    tier  re Firebase database 
or tier  re Firebase storage 

01:30:32.297 --> 01:30:35.499
bucket.  And you can know, 
confidence, that these rules are

01:30:36.131 --> 01:30:38.131
 applied everywhere 

01:30:41.236 --> 01:30:45.761
, you can learn more about 
identity and author       

01:30:45.762 --> 01:30:49.680
Firebase with three key talks.  
First, the key to Firebase 

01:30:49.681 --> 01:30:54.436
security.  This will go over e 
languages you'll use to secure 

01:30:54.437 --> 01:30:59.477
the realtime database  storage. 
                       Next, to 

01:30:59.478 --> 01:31:03.495
focus on the actual log in   in 
experience, we have  for a great

01:31:04.143 --> 01:31:08.947
 sign in experience.  And one  
pitch a few times is zero to app

01:31:10.710 --> 01:31:15.273
 cap               Zero to App, 
:   Firebase.  This talk 

01:31:15.626 --> 01:31:20.171
combines off the database  to 
create three apps with live code

01:31:20.373 --> 01:31:22.745
 ing     ing.  We'll someone 
live code ing     ing at all 

01:31:22.746 --> 01:31:26.638
times for I ofk     iOS, an
  Android .  So nobody's left 

01:31:26.896 --> 01:31:34.095
out in the talk. , next, if we.
..there we go.  If you have 

01:31:34.096 --> 01:31:38.834
large of data, a database is not
 the right place to put chlt 

01:31:39.054 --> 01:31:42.407
    .  So, for blobs       blobs
 of rich data, we have Firebase

01:31:43.202 --> 01:31:46.509
       Storage.  The Firebase 
lay yer    er on top of the pet 

01:31:46.867 --> 01:31:50.312
  PETA    petabyte         
Google Cloud storage product 

01:31:50.511 --> 01:31:53.906
              Storage Product.  
 if you look at our dashboard, 

01:31:53.907 --> 01:31:58.481
the first thing  on our dashb
oard is that Firebase storage is

01:31:58.801 --> 01:32:04.344
  a stand alone product.  You 
can look at your , you can mod

01:32:04.544 --> 01:32:08.652
ify them, upload them and you  
to wrap your files inside other 

01:32:08.653 --> 01:32:10.653
objects.

01:32:16.902 --> 01:32:20.939
   we have a rules tab.  
Firebase products are secure , 

01:32:20.940 --> 01:32:24.570
not just things that is    point
 to them.  Data  is secure, even

01:32:24.697 --> 01:32:28.711
 if the URLs leak out.   you can
 delete files directly.  There's

01:32:29.008 --> 01:32:35.707
 no more collection required.  
And there's no more ten 

01:32:36.108 --> 01:32:40.128
  megabyte limit for files you 
use in Firebase Storage.  llows 

01:32:40.129 --> 01:32:45.122
you to doo  download and upload 
resume ing ily.  ...Parse has 

01:32:45.403 --> 01:32:50.918
not yet decided the migration 
strategy .com and Parse files.  

01:32:50.919 --> 01:32:54.664
But there is a get  
peed         Wikipedia page 

01:32:54.665 --> 01:32:56.665
which I'll post in the spaces 
after this

01:32:59.882 --> 01:33:02.853
.  Because is    Parse serve er 
       Server already has a plug

01:33:03.026 --> 01:33:06.835
 play adapt er   er for Parse 
files.  You can use Google 

01:33:07.781 --> 01:33:10.587
storage       Storage.  There's 
an official node module.  Since 

01:33:11.191 --> 01:33:13.473
 built on Google Cloud storage, 
it's reverse 

01:33:17.102 --> 01:33:23.956
 use one backend to have data 
that  a Parse file and Firebase 

01:33:24.159 --> 01:33:26.159
Storage. 

01:33:28.990 --> 01:33:31.916
 Now, they you save the best for
 last

01:33:36.432 --> 01:33:40.858
This is the original .  It's why
 470,000 developers trust       

01:33:40.859 --> 01:33:46.841
today.  The Firebase database 
       Database started years 

01:33:46.842 --> 01:33:51.833
ago by let  of preconceptions of
 how a database needs to.  We 

01:33:51.834 --> 01:33:55.327
don't need to have unstructured 
data just  some collection.  We 

01:33:55.328 --> 01:33:58.997
can lay out our data to  way we 
plan to present it in our app

01:33:59.211 --> 01:34:03.401
lication.  we don't need to 
restrict ourselves to some rest 

01:34:03.402 --> 01:34:08.502
ful .  Rest is nice because it's
 ease y to think  so Firebase 

01:34:09.931 --> 01:34:14.208
does support rest for the 
realtime , however, we believe 

01:34:14.209 --> 01:34:20.209
that being a cut it chlt     .  
        Dragging to refresh is 

01:34:20.210 --> 01:34:23.533
going to be as old to    
tomorrow as     ing refresh to 

01:34:23.534 --> 01:34:30.296
check your e-mail is today.  ...
while on other systems, you 

01:34:30.297 --> 01:34:36.184
might have to save an  have a 
cloud code trigger, send a push 

01:34:37.121 --> 01:34:39.345
 have that show up in your 
device, issue a questionnaire 

01:34:39.702 --> 01:34:44.015
         ry, update your UI, re-
     realize that not everybody 

01:34:44.696 --> 01:34:48.891
 notifications enabled and also 
have a poll loop damages your 

01:34:48.892 --> 01:34:53.129
battery life and isn't very 
response  so add extra are     U

01:34:53.332 --> 01:34:57.546
I that allows you to over load  
poll refresh.        Let's just 

01:34:57.547 --> 01:35:01.559
make the data sink   ync.  
Describe the data you  and it 

01:35:01.560 --> 01:35:05.800
pushes the devices in mill
iseconds.  So,  we've done this 

01:35:05.801 --> 01:35:11.651
is by restructuring how we show 
 Data in a Firebase database is 

01:35:11.652 --> 01:35:17.565
build       built like a giant J
SON document or a giant tree. ' 

01:35:21.650 --> 01:35:24.095
 node      in that tree and say 
"I care about this" ."   said 

01:35:24.096 --> 01:35:27.765
you like to listen to a point in
 the base, and     any changes 

01:35:27.766 --> 01:35:33.153
to that will be in  Intel  
streamed down to your device.   

01:35:33.154 --> 01:35:37.126
       Now...this requirement 
is                requires us to

01:35:37.323 --> 01:35:41.209
 have an unfamiliar structure  
you can see familiar concepts 

01:35:41.388 --> 01:35:45.706
show up.  look at the first top 
level      -level keys here, 

01:35:45.707 --> 01:35:50.413
they're  and presenters.  Now 
these are the  collections, 

01:35:50.902 --> 01:35:54.716
which should sound familiar.  
Your first ept in most databases

01:35:54.933 --> 01:36:01.448
, your table or your class.   
same way in Firebase.  , next, 

01:36:01.607 --> 01:36:06.584
underneath the presentations 
collection, see some jib 

01:36:06.779 --> 01:36:09.620
  gibberish, some numbers.  More
 commonly  Rand    random 

01:36:09.621 --> 01:36:13.688
advantages            strings.  
This is how you have a list  in 

01:36:13.689 --> 01:36:19.243
Firebase.  We have a tool called
 a push ID will Jen   generate a

01:36:19.244 --> 01:36:22.928
 Rand    random stream based on 
the serve  stam     stamp.  This

01:36:23.055 --> 01:36:27.520
 allows you to insert data into 
 insert data into a list while a

01:36:27.789 --> 01:36:32.245
void ing .          With this 
type of layout, though, you 

01:36:32.246 --> 01:36:37.372
consider these the object IDs in
 our collection.  And underneath

01:36:37.636 --> 01:36:43.209
 object IDs, you'll see that all
 of the next keys  same 

01:36:43.210 --> 01:36:48.092
structure.  These are our 
objects in        document 

01:36:48.093 --> 01:36:52.718
object model.          Now...s
ome of these keys make sense.  

01:36:52.719 --> 01:36:58.921
Location, title,  are just 
strings.  They last           

01:36:58.922 --> 01:37:02.894
This last one is a  curious.  
It's a bit nested, it's 

01:37:02.895 --> 01:37:07.039
structured.  What ?  The first 
key is that title.  Presenters. 

01:37:07.040 --> 01:37:13.680
  you remember, that was a name 
of our other space.  And 

01:37:13.681 --> 01:37:19.654
remember how I said that, list 
of  garbage strings or arrays?  

01:37:19.852 --> 01:37:24.853
This is the name  name space 
being mapped to a key or to an a

01:37:25.077 --> 01:37:27.077
rray of

01:37:28.446 --> 01:37:36.212
 .          If we scroll down.
..we'll notice that presenters 

01:37:36.213 --> 01:37:41.455
has a       named inlien    
lined.  This is how we can 

01:37:41.456 --> 01:37:45.773
structure    al data in Firebase
.  We have the name or value one

01:37:47.054 --> 01:37:51.400
 key point ing    ing to basic
ally a template parameter or  

01:37:51.647 --> 01:37:55.887
inside the database somewhere 
else.          That's how you 

01:37:55.888 --> 01:38:01.072
can use that one reference to 
have a of objects or list a   of

01:38:01.307 --> 01:38:04.226
 pointers to objects elsewhere  
database. 

01:38:07.605 --> 01:38:12.017
 is a new and novel approach.  I
 know it might a little int

01:38:12.279 --> 01:38:17.046
imidate ing at first, so I want
ed to a case study from sky skan

01:38:17.243 --> 01:38:19.957
     scanner.  Sky skan 
    scanner is a  app in Europe.

01:38:19.958 --> 01:38:22.508
  They have over 5 million ive 
customers. 

01:38:25.563 --> 01:38:28.323
 And they built a modern web    
 web 

01:38:32.742 --> 01:38:35.773
 and wanted to know how they 
were doing.  They  feet  ature 

01:38:35.774 --> 01:38:40.513
where they asked the customer, "
how  you?  "  If the customer 

01:38:40.514 --> 01:38:43.697
was happy, they'd in the use yer
    r to share their feedback on

01:38:43.808 --> 01:38:47.396
 the app store  the app with 
their friends.  If the feedback 

01:38:47.840 --> 01:38:55.044
, they asked for feedback 
directly.  This  another backe

01:38:55.200 --> 01:38:59.842
nd.  They decided to try out  
They said it took them ten hours

01:38:59.977 --> 01:39:02.824
 to rewrite whole feet  ature 
use ing     ing Firebase.  It 

01:39:02.825 --> 01:39:06.804
took them two  test all their 
inter grations with the new  and

01:39:07.115 --> 01:39:11.907
 took them two weeks to fully 
roll their entier  re new code 

01:39:11.908 --> 01:39:16.946
base.  they say about it?  It 
was ease y to switch fromlegacy 

01:39:16.947 --> 01:39:22.410
solution.  The web A pfk    PI 
is premature for the base and 

01:39:22.665 --> 01:39:28.486
it's incredible y ease y to use.
  , ...I'm going to, light and 

01:39:28.487 --> 01:39:31.237
fast, go  of migraine   te ing
     ing data.  These are fund

01:39:31.594 --> 01:39:34.912
amentally   They're structured 
differently.  Tip  ypically talk

01:39:35.035 --> 01:39:39.217
 about a background sink   ync. 
 You have your old app,  a new 

01:39:39.218 --> 01:39:43.694
one in a clean room, you might 
have some  transformer lodge 

01:39:43.855 --> 01:39:47.801
  gic, but you can use that to 
load import.  You can use that 

01:39:48.045 --> 01:39:49.523
to Secretary of State 
                   test your new

01:39:49.524 --> 01:39:53.085
 app with ashot of old data.  
You can drop that data if you  

01:39:53.294 --> 01:39:56.902
restart.  ...you need to restart
 again and do sink   ync ing

01:39:57.607 --> 01:40:01.574
    ing with end.  To make sure 
that when you have these two  

01:40:01.784 --> 01:40:06.310
they don't diverge.  This is a 
bit of a  you need to sink   ync

01:40:06.779 --> 01:40:11.334
 at the same time as  over write
      write old data.   some 

01:40:11.335 --> 01:40:14.537
cloud code for you              
    Cloud code for you that can 

01:40:14.538 --> 01:40:18.472
help you do types of migrations.
  The other option you can do  

01:40:18.613 --> 01:40:21.865
your app and put it into read 
only mode and your sink 

01:40:22.068 --> 01:40:25.767
  ynchronization afterwards.   
other option is a double write. 

01:40:25.939 --> 01:40:29.732
 You start with  app, connect to
 a new database with an app that

01:40:30.639 --> 01:40:34.576
 acre  cess to both copies.  
First you trade yourase with the

01:40:34.844 --> 01:40:37.875
 source of truth and you might 
do a  of data in the background.

01:40:38.147 --> 01:40:42.166
  As feet  atures become  or    
are fully migraine   ted, you 

01:40:42.167 --> 01:40:45.801
can change your  truth to be the
 hybrid app.  Sorry, to be the 

01:40:46.244 --> 01:40:49.665
  w bak ckend.          Eventu
ally your old app stops being 

01:40:49.666 --> 01:40:53.273
Utesed        used, you can  
your dependency on the old back

01:40:53.469 --> 01:40:55.469
end and then your new app. 

01:40:59.140 --> 01:41:00.881
 I said, I'm going to be sharing
 -- oop! , there's two sessions 

01:41:00.882 --> 01:41:04.331
to dive in deep er   er.  
Conceive              Dive into 

01:41:04.332 --> 01:41:06.332
the realtime database

01:41:09.276 --> 01:41:12.942
                 Realtime 
Database and zero app     to 

01:41:09.276 --> 01:41:13.840
app   App cap               Zero
 to App.  We  an    a suite of 

01:41:13.841 --> 01:41:17.526
inter grated products designed 
to im  app, grow your database 

01:41:17.738 --> 01:41:21.627
and earn money.  We you how you 
can add novel tools to Firebase 

01:41:21.628 --> 01:41:26.363
or  and how Firebase' approach 
to getting you  to building an 

01:41:26.364 --> 01:41:28.979
app gives you novel advantages. 
         So, remember, 

01:41:29.118 --> 01:41:31.492
migraine   te ing     ing to 
Firebase doesn't need to 

01:41:32.413 --> 01:41:34.486
migraine   te ing     ing away 
from something else.  We've 

01:41:34.754 --> 01:41:37.807
shown  the Firebase tools can 
help you solve problems  you 

01:41:37.808 --> 01:41:39.808
haven't been able to before. 

01:41:43.031 --> 01:41:45.031
         What's next?  We had 

01:41:47.399 --> 01:41:52.133
the            Join online, I'd 
love to hear what  doing, what 

01:41:52.427 --> 01:41:54.812
you love about the nefrp   w 
Firebase  we can improve.  Thank

01:41:54.813 --> 01:41:58.883
 you very much on behalf myself 
and my partner, sill    Sylvan 

01:41:59.007 --> 01:42:01.007
    ilvano, the

01:42:03.284 --> 01:42:07.024
 of my time in the tent or I'll 
be at  afternoon sessions at I/O

01:42:07.222 --> 01:42:09.222
.  Thank you.  

01:42:13.505 --> 01:42:17.457
         Pashgs resentation clue
      concluded at can     3:45 

01:42:17.458 --> 01:42:20.384
p.m. PT]         Pashgs
        "This text is being 

01:42:20.385 --> 01:42:22.385
provided in a rough draft 
format.  

01:53:07.648 --> 01:53:15.747
 Increasing app quality with 
testtesting

01:53:22.934 --> 01:53:25.066
  FB3 increasing app quality 
with testing  

01:53:46.541 --> 01:53:48.541
.  

01:53:56.372 --> 01:53:58.372
Increasing App

01:54:02.516 --> 01:54:04.934
 Quality With Test

01:54:08.834 --> 01:54:10.834
Testing 

01:56:22.588 --> 01:56:28.637
&gt;&gt; Hi, everyone, my name is 
Ahmed.  I'm a developer at 

01:56:28.638 --> 01:56:37.681
Firebase test lab.  I'm joined 
with me  Fergus  Ali.  I'm on 

01:56:38.213 --> 01:56:42.132
Firebase crash&gt;&gt; Michael B

01:56:47.982 --> 01:56:52.611
 Iordanis with Shazam.  will 
help you with the quality and 

01:56:53.035 --> 01:56:57.834
testing with your apps.  We know
 quality is superintendent to  

01:56:58.038 --> 01:57:01.157
-- is important to us.  We will 
hear this throughout the 

01:57:01.158 --> 01:57:04.774
conference today.  We want you 
to have the best possible apps, 

01:57:04.775 --> 01:57:09.149
build the best possible apps and
 you need to make sure you have 

01:57:09.150 --> 01:57:13.571
quality to make your apps s
uccessful.  In fact, more than 

01:57:13.572 --> 01:57:19.425
51% of the one story views we 
saw on the reviews on Google 

01:57:19.426 --> 01:57:22.994
Play are related to quality 
issues.  Bugs and crashes.  Data

01:57:23.775 --> 01:57:27.220
 is clearly showing us we need 
quality results and in this talk

01:57:27.221 --> 01:57:30.924
 we will talk to you about the 
different tools that Google 

01:57:30.925 --> 01:57:33.978
offers to be able to manage your
 quality throughout the life 

01:57:33.979 --> 01:57:39.203
cycle of your application 
development.  Starting with 

01:57:39.204 --> 01:57:42.765
Firebase test lab, which allows 
you to manage the quality of 

01:57:42.766 --> 01:57:46.934
your application during 
development to the Play launch 

01:57:47.027 --> 01:57:50.980
report that was announced today 
and allow you to manage the 

01:57:50.981 --> 01:57:56.846
quality of your app during the 
release process.  And Firebase, 

01:57:56.847 --> 01:58:02.123
which was also announced and it 
will help you prioritize the 

01:58:02.124 --> 01:58:05.752
most important and impactful 
crashes and resolve them quickly

01:58:05.753 --> 01:58:12.294
 so they don't affect your 
users.  Many of you heard about 

01:58:12.295 --> 01:58:16.782
cloud test lab, that was 
announced last year.  We're now 

01:58:17.106 --> 01:58:22.185
proud to say we are part of the 
Firebase family.  This is the 

01:58:22.186 --> 01:58:29.998
most amazing Googler products 
released.  It is all in the 

01:58:29.999 --> 01:58:33.645
tools in one location and 
Firebase test lab is part of 

01:58:33.898 --> 01:58:40.813
that suite of tools.   lab is 
your first stop to manage 

01:58:40.814 --> 01:58:44.925
quality during the test process.
  With Firebase test lab, we 

01:58:44.926 --> 01:58:48.684
want you to make sure your app 
works well on the devices your 

01:58:48.685 --> 01:58:52.117
users have.  That is why the 
first part to get started is the

01:58:52.570 --> 01:58:56.595
 infrastructure.  This is an 
actual photo from our device 

01:58:56.755 --> 01:59:00.334
lab.  This is devices running in
 our data centers, hosting them 

01:59:00.335 --> 01:59:06.896
from different manufacturer, 
different API levels and form 

01:59:07.102 --> 01:59:12.665
factors.  The goal is to make it
 easy to access these devices at

01:59:12.666 --> 01:59:14.815
 any time, don't worry about 
building infrastructure or 

01:59:14.816 --> 01:59:18.386
buying more devices.  We have 
that covered for you.  You build

01:59:18.387 --> 01:59:21.589
 your app and run it on this 
amazing infrastructure.   second

01:59:22.000 --> 01:59:25.410
 part of Firebase test lab is 
how it easily integrates with 

01:59:25.411 --> 01:59:28.732
your development work flow.  All
 you need to get started is a 

01:59:28.733 --> 01:59:31.945
web browser and your app.  You 
can upload your app to the 

01:59:32.103 --> 01:59:36.734
browser, start your test, and go
 from there.  We also built an 

01:59:36.735 --> 01:59:40.124
integration with Android studios
 so you can run your test during

01:59:40.884 --> 01:59:45.547
 developing Android studio and 
built a command line interface 

01:59:45.548 --> 01:59:50.260
to use during your integration 
If you use Jenkins you can see 

01:59:50.261 --> 01:59:53.965
it on the developers 
documentation and the amazing 

01:59:53.966 --> 01:59:58.694
community built for construction
 on how to use circle CI and 

01:59:58.695 --> 02:00:02.632
team city.  All of these docs 
are available and we're adding 

02:00:02.633 --> 02:00:04.633
more and 

02:00:06.741 --> 02:00:10.369
more.  We agree that writing 
test code is something we don't 

02:00:10.370 --> 02:00:13.971
want to invest in from the 
beginning.  This is where we 

02:00:13.972 --> 02:00:20.481
built this robo crawler it 
launches your app, clicks on 

02:00:20.482 --> 02:00:22.699
button as a normal user would do

02:00:26.190 --> 02:00:30.947
do.  It builds the activity and 
tracks the crash.  It is logging

02:00:31.065 --> 02:00:36.798
 use using Google and bypassing 
the log-in using Google and was 

02:00:36.799 --> 02:00:40.586
able to find a crash near the 
end.  It gives you the full path

02:00:40.587 --> 02:00:46.468
 leading to the crash so you can
 resolve all of these issues.  

02:00:46.725 --> 02:00:50.493
Now, no matter how smart this 
robo is, it probably won't be 

02:00:50.494 --> 02:00:56.390
able to guess your custom log-in
 credentials.  We're building 

02:00:57.922 --> 02:01:01.910
the espresso test recorder at 
Android studio.  All you have to

02:01:02.370 --> 02:01:07.140
 do with the first test to build
 espresso, launch the app on 

02:01:07.141 --> 02:01:12.457
your phone, we capture all the 
interaction you do and build a 

02:01:12.458 --> 02:01:20.542
full low -- fully reusable test 
script for you.  is the most 

02:01:20.543 --> 02:01:24.541
impactful user journey, cover 
them with test cases and every 

02:01:24.542 --> 02:01:28.609
new change to your code, make 
sure the scenarios don't break. 

02:01:29.169 --> 02:01:33.224
 are the most scenarios in your 
app, you shouldn't break them by

02:01:33.365 --> 02:01:40.121
 any change.   lab provides a 
full report with logs, screen 

02:01:40.310 --> 02:01:43.730
shots, stat traces and a video 
to allow you to fix any issues 

02:01:43.731 --> 02:01:47.499
on your app, resolve them and go
 back to a green 

02:01:50.660 --> 02:01:54.585
state.  So I mentioned that 
Firebase test lab is basically 

02:01:54.586 --> 02:01:58.471
cloud test lab, which was 
announced last year at I/O, but 

02:01:58.472 --> 02:02:02.595
now it is part of the Firebase 
family.   to say we worked 

02:02:03.096 --> 02:02:06.166
really closely with our partners
 and developers and they helped 

02:02:06.167 --> 02:02:13.435
us shape the product.  We ran 
100 devices on the 

02:02:13.436 --> 02:02:17.657
infrastructure and believe we 
can add much more than that.  

02:02:18.744 --> 02:02:23.099
Here's four square, they're 
telling us how it was easy to 

02:02:23.100 --> 02:02:27.738
integrate Firebase test lab into
 their work flow.  Also the 

02:02:27.739 --> 02:02:31.196
friends from KK box.  They were 
able with the robo, by crawling 

02:02:31.197 --> 02:02:34.615
o application they were able to 
resolve issues on launch on 

02:02:34.616 --> 02:02:38.162
their devices that they would 
have never captured it otherwise

02:02:38.163 --> 02:02:40.163
 and would have affected users. 

02:02:47.245 --> 02:02:50.836
 want to introduce Michael 
Bailey.  We did a talk 

02:02:51.144 --> 02:02:53.890
previously, and I'm proud to do 
my second talk in a row with 

02:02:54.271 --> 02:02:57.532
him.  Mike is a respectful and 
highly influential in the 

02:02:57.533 --> 02:03:06.530
Android community.  I will leave
 it up to him.  Yeah.  Thanks, 

02:03:07.534 --> 02:03:09.534
Ahmed.   we

02:03:12.565 --> 02:03:19.806
  We have an American Express 
Android app.  When tools like 

02:03:19.807 --> 02:03:25.280
espresso came out we started to 
verify it did what we wanted it 

02:03:25.281 --> 02:03:29.332
do to within r.  Set up a 
physical device farm that 

02:03:29.333 --> 02:03:35.072
started on my desk with a bunch 
of devices connected to a MAC m

02:03:35.203 --> 02:03:40.543
ini, to run Jenkins and for 
every branch we ran all the 

02:03:40.544 --> 02:03:43.772
tests to make sure we didn't 
introduce defects.  That was 

02:03:43.773 --> 02:03:47.597
fine with a small number of 
tests and didn't have that big 

02:03:47.598 --> 02:03:52.217
of an Android team.  Espresso 
made it easy to write tests, we 

02:03:52.218 --> 02:03:56.310
wrote more because it helped us 
increase quality.  We needed 

02:03:56.311 --> 02:04:03.745
more devices.  We had problems
problems connecting them to MAC 

02:04:04.101 --> 02:04:08.217
minis.  This grew and grew, and 
more engineers, and more 

02:04:08.419 --> 02:04:11.747
requests, and more tests to run 
on our infrastructure. A 

02:04:11.748 --> 02:04:17.097
constant refrain was I can't 
merge my change because the 

02:04:17.098 --> 02:04:19.474
builds aren't passing because 
the device is giving me 

02:04:19.723 --> 02:04:23.991
problems, can you unplug it, 
replug it with USB to get the 

02:04:23.992 --> 02:04:28.664
test to run.  It was becoming a 
maintenance burden.  It was a 

02:04:28.665 --> 02:04:32.219
daily refrain in our process to 
run the tests and make sure they

02:04:32.389 --> 02:04:37.880
 were always passing.  It was 
taking a lot of engineer and 

02:04:37.881 --> 02:04:44.929
hardware to run all the tests.  
Last year a Google I/O I heard 

02:04:44.930 --> 02:04:48.313
about the Firebase Test Lab for 
Android, about how I could run 

02:04:48.314 --> 02:04:54.335
my test on devicedevices 
provided by Google.  I contacted

02:04:54.573 --> 02:04:58.332
 them, asked them for early 
access.  Last July Ahmed and 

02:04:58.333 --> 02:05:04.158
team came to our office, got us 
set up with cloud test lab.  By 

02:05:04.481 --> 02:05:09.632
August, we had decompensated our
 own device farm and running all

02:05:09.815 --> 02:05:11.815
 our tests on 

02:05:16.683 --> 02:05:17.908
Cloud Test Lab.  By August, we 
had decompensated our own device

02:05:17.909 --> 02:05:19.054
 farm and running all our tests 
on Firebase Test Lab.  No more 

02:05:19.055 --> 02:05:21.837
did we have the complaints about
 running all the tests, getting 

02:05:21.957 --> 02:05:24.583
to the last one, it fails and 
you have to start the job all 

02:05:24.584 --> 02:05:28.178
over again.  We were able to add
 more engineers and tests 

02:05:28.179 --> 02:05:31.924
without having to worry about 
how are we going to get more 

02:05:32.271 --> 02:05:36.373
devices?  it slow down our whole
 process?  So by switching to 

02:05:36.590 --> 02:05:39.452
this, we got more productivity, 
able to get early access to this

02:05:39.636 --> 02:05:42.962
 tool, and we have a lot less 
maintenance.  We can actually 

02:05:42.963 --> 02:05:44.963
focus ourselves on writing the 
tests

02:05:48.094 --> 02:05:55.090
 and with making a high quality 
app that card members expect.  

02:05:55.091 --> 02:05:59.273
Now I will turn it over to 
Fergus from the Play team. 

02:06:00.544 --> 02:06:02.544
Thanks, 

02:06:04.485 --> 02:06:08.325
&gt;&gt; I'm very excited to be here 
today to announce the prelaunch 

02:06:08.326 --> 02:06:11.979
report as part of the Play 
developer console.  Ahmed talked

02:06:12.427 --> 02:06:16.328
 about, in the development life 
cycle of building your app, you 

02:06:16.329 --> 02:06:22.594
should test it using Firebase 
Test Lab, Jenkins plug-ins and 

02:06:22.783 --> 02:06:25.521
the command line.  When you are 
about to release your app to the

02:06:27.707 --> 02:06:32.857
 1.2 billion monthly active Play
 users.  Did I fix the issues, 

02:06:32.858 --> 02:06:38.682
is my app ready to be shown to 
the users, how does it look?  

02:06:38.683 --> 02:06:41.623
That is where this comes in and 
shines.  Before I go into what 

02:06:41.624 --> 02:06:49.019
is included in the prelaunch 
board.  Hands up if you have an 

02:06:49.291 --> 02:06:54.235
app on Play today.  Keep your 
hands up, if you tested that app

02:06:54.606 --> 02:06:59.474
 on more than 10 devices.  I'm 
impressed.  Keep your hand up if

02:06:59.651 --> 02:07:03.639
 you got those results within an
 hour.  Very impressive guy over

02:07:03.768 --> 02:07:06.729
 here.  I will show you how to 
all keep your hand up when you 

02:07:06.730 --> 02:07:10.104
are asked that question in the 
future as a result of the 

02:07:10.270 --> 02:07:16.944
prelaunch report.  That is 
powered by Firebase Test Lab.  

02:07:16.945 --> 02:07:20.243
includes three parts, crashes, 
screen shots, security.  In the 

02:07:20.244 --> 02:07:24.693
crashes section, we show you the
 results of the robo that Ahmed 

02:07:24.694 --> 02:07:29.775
described, interacting with your
 app for about five minutes, 

02:07:29.776 --> 02:07:33.175
across 10-plus physical Android 
devices, and we show you if 

02:07:33.176 --> 02:07:38.150
there was a crash we show you 
the stack trays, log cache, 

02:07:38.151 --> 02:07:41.983
device spec and a video of the 
robot interacting with the 

02:07:42.162 --> 02:07:44.781
application.  This really helps 
you be able to get to the 

02:07:44.782 --> 02:07:49.184
problem that the app has and be 
able to solve that crash.  As 

02:07:49.185 --> 02:07:52.177
you can see with the app 
developer, the first version 

02:07:52.178 --> 02:07:56.385
they uploaded had a lot of 
issues.  As they kept releasing 

02:07:56.386 --> 02:07:59.682
new versions they fixed the 
issue.  Then they with the final

02:07:59.847 --> 02:08:07.619
 version they just pushed, to 
the Alpha beta channel, 

02:08:07.620 --> 02:08:10.586
identified two crashes and can 
solve those.  developer in this 

02:08:10.587 --> 02:08:13.740
room would have a crash happen 
in their app.  We decided to 

02:08:13.891 --> 02:08:17.554
launch the screen shot section, 
which helps you with the 

02:08:17.555 --> 02:08:20.464
usability issues with your app. 
 This is powerful when you have 

02:08:20.465 --> 02:08:23.143
green results as part of the 
prelaunch

02:08:29.514 --> 02:08:33.062
 port you can see what is looks 
like across the different 

02:08:33.366 --> 02:08:35.851
versions, screen sizes and 
languages.  You can see what 

02:08:35.852 --> 02:08:43.407
your app looks like in right to 
left Arabic, merging markets, 

02:08:43.902 --> 02:08:47.410
Hindi, languages with long 
strings.  German, there is an 

02:08:47.411 --> 02:08:51.684
issue with the layout of the 
text.   your design team to be 

02:08:51.685 --> 02:08:54.086
able to catch the issues before 
it is pushed to all the

02:09:00.525 --> 02:09:05.534
 users.  The last part is the 
security section.  This is where

02:09:05.535 --> 02:09:10.336
 we push the security team to 
put them to work for you.  This 

02:09:10.337 --> 02:09:13.214
is where we identify in the 
application, and give you 

02:09:13.215 --> 02:09:17.578
information to be able to help 
you solve that issue before you 

02:09:17.579 --> 02:09:22.077
release to all the users in 
Play.  How to get access to this

02:09:22.397 --> 02:09:27.439
 prelaunch report?  You go to 
the Google play developer 

02:09:27.440 --> 02:09:32.809
console, click on the prelaunch 
tab, which replaced the precloud

02:09:33.165 --> 02:09:39.552
 test lab.  When you click on 
the tab, opt in, the next UPK 

02:09:39.553 --> 02:09:42.596
upload will have this report 
generated within one hour.  We 

02:09:42.597 --> 02:09:49.348
have already found that 60% of 
the top apps on Google play used

02:09:49.492 --> 02:09:54.847
 the alpha beta c you didn't use
 it before, now you have a 

02:09:55.003 --> 02:09:59.871
reason, thank you.  We will hand
 it over to Ali to talk about 

02:09:59.872 --> 02:10:08.129
Firebase crash reporting.  
Thanks everybody.  We launched 

02:10:08.130 --> 02:10:11.484
Firebase crash reporting today, 
we're super excited.  Thanks for

02:10:11.652 --> 02:10:13.652
 being 

02:10:19.100 --> 02:10:25.212
here.  We believe that Firebase 
Crash Reporting is a benefit.  

02:10:25.213 --> 02:10:31.902
While the prelaunch reports on 
production stage, this focuses 

02:10:31.903 --> 02:10:35.140
on the stage of the users coming
 into the app, interacting with 

02:10:35.141 --> 02:10:38.589
the app.  The objective is to 
give them the best possible user

02:10:38.766 --> 02:10:45.112
 experience. is not exactly the 
easiest thing, right.  When you 

02:10:45.113 --> 02:10:49.264
think about the mobile ecosystem
 we live in, many variables at 

02:10:49.409 --> 02:10:56.044
play.  Multiple operating 
systems, iOS levels, different 

02:10:56.045 --> 02:11:00.219
device manufacturer, device 
model, the list of variables 

02:11:00.220 --> 02:11:04.214
goes on and on.  The combination
 can be too much to handle 

02:11:04.215 --> 02:11:08.455
within testing alone.  need 
something in production, losing 

02:11:08.456 --> 02:11:12.144
users that happened to be on a 
device that wasn't tested or a 

02:11:12.145 --> 02:11:16.007
user path that wasn't accounted 
for is not acceptable.  Every 

02:11:16.008 --> 02:11:21.341
user is as important as every 
other user.  And that's exactly 

02:11:21.342 --> 02:11:26.590
why we introduce Firebase Crash 
Reporting.  So what is it e

02:11:27.798 --> 02:11:31.278
xactly?  It is an SDK that 
support iOS and Android and you 

02:11:31.279 --> 02:11:34.528
get a package in your app, push 
it to production and it detects 

02:11:34.529 --> 02:11:38.685
information about the errors 
that your users see.  aggregates

02:11:38.842 --> 02:11:42.420
 this data and using the 
Firebase console you can see 

02:11:42.421 --> 02:11:46.035
details about it so you can be 
on the way to fixing the issues 

02:11:46.209 --> 02:11:53.073
faster than ever.  Setting up is
 really easy.  If you are on 

02:11:53.207 --> 02:11:58.560
Android, grab the cradle plug i
n.  On iOS, install the pod, add

02:11:58.848 --> 02:12:03.561
 one line of code, off you go, 
errors running.  When you push 

02:12:03.562 --> 02:12:06.664
to production and you start 
seeing errors coming in, when 

02:12:06.665 --> 02:12:09.441
they first come in, they start 
looking something like this, 

02:12:09.573 --> 02:12:15.034
right?  All over the place some 
errors from some device, not 

02:12:15.202 --> 02:12:17.824
others.  Some errors from 
specific user paths that weren't

02:12:18.312 --> 02:12:22.110
 accounted for.  And the first 
thing we do with the data is we 

02:12:22.111 --> 02:12:26.798
cluster it.  So it looks 
something like this.  We group 

02:12:26.799 --> 02:12:32.183
the errors by having them in 
buckets of similar stacked 

02:12:32.299 --> 02:12:34.771
traces.  What that does for you 
is a couple of things.  First of

02:12:34.963 --> 02:12:38.563
 all, it allows you to get a 
sense of how many unique issues 

02:12:38.564 --> 02:12:41.874
you have in your app.  The other
 thing is you have a sense of 

02:12:42.154 --> 02:12:44.885
prioritization.  You understand 
for each cluster of errors, is 

02:12:44.886 --> 02:12:49.723
it a fatal error, nonfatal 
error, you get a user count and 

02:12:49.724 --> 02:12:54.512
number of occurrences so you 
understand the severity of the 

02:12:54.810 --> 02:12:56.810
issue.  friends

02:12:59.677 --> 02:13:03.582
 at sky scanner have been using 
this for a while.  By using 

02:13:03.951 --> 02:13:08.070
clustering, they cut down on 
issues and cut down on crashes 

02:13:08.071 --> 02:13:12.352
by 30%. Think about the amount 
of gain you can have with such a

02:13:12.353 --> 02:13:16.881
 simple action.   So now you 
have identified through 

02:13:16.882 --> 02:13:22.788
clustering what you need to work
 on.  The best part now is 

02:13:22.789 --> 02:13:26.069
actually fixing the issue.  This
 is where the Firebase console 

02:13:26.252 --> 02:13:30.385
comes in.  We give you a lot of 
data, a lot of information, 

02:13:30.386 --> 02:13:32.984
everything you need to identify 
the root cause of the issue and 

02:13:32.985 --> 02:13:38.972
get it done in no time.  The 
first thing you see is a top 

02:13:39.268 --> 02:13:42.202
level breakdown of metrics.  So 
we'll tell you obvious things 

02:13:42.203 --> 02:13:47.024
like the exception name in 
Android or crashing scene in 

02:13:47.174 --> 02:13:50.287
iOS, but give you a breakdown of
 the app version so you can 

02:13:50.288 --> 02:13:52.873
understand if the latest app 
version in production is doing 

02:13:52.874 --> 02:13:56.312
better or worse than the 
previous ones and the breakdown 

02:13:56.313 --> 02:14:00.013
of the operating systems or 
operating system levels.  

02:14:00.014 --> 02:14:03.139
Breakdown of the devices and so 
on.  The idea here is that you 

02:14:03.140 --> 02:14:06.809
are quickly able to attribute 
the errors to some factors and 

02:14:06.810 --> 02:14:14.625
eliminate other factors.  The 
next thing we give you is the 

02:14:14.626 --> 02:14:21.122
stat r give you the application 
on iOS and Android, and you get 

02:14:21.123 --> 02:14:24.259
to see everything down to the 
line number.  We highlight that 

02:14:24.260 --> 02:14:27.532
frame in the stat base that 
belongs in your app so you can 

02:14:27.533 --> 02:14:35.931
jump to the problem and not 
waste time.   you get 

02:14:36.312 --> 02:14:38.261
comprehensive device 
diagnostics.  This is important 

02:14:38.262 --> 02:14:41.241
for a couple of things.  Let me 
first tell you what you get.  

02:14:41.242 --> 02:14:46.410
Some of the things we give you 
are the amount of ram and disk 

02:14:46.411 --> 02:14:50.052
space available on your device. 
 You get things like was the 

02:14:50.053 --> 02:14:56.479
device in landscape, portrait, 
timestamp of the error, API 

02:14:56.684 --> 02:14:58.958
levels, basically everything 
that is set on the device. You 

02:14:58.959 --> 02:15:02.197
can go through instances and see
 what the device of that user 

02:15:02.198 --> 02:15:05.786
was like at the moment the error
 took place.  is pretty 

02:15:06.003 --> 02:15:09.187
important, not just because you 
get to fix the issue faster, but

02:15:09.381 --> 02:15:11.896
 you get to save time on 
customer support, because you 

02:15:11.897 --> 02:15:15.063
don't have to do that back and 
forth with the users so you 

02:15:15.246 --> 02:15:21.103
understand what the device was 
like at the time of the error. I

02:15:21.420 --> 02:15:27.931
 have talked about so far is 
about creating a snapshot, 

02:15:27.932 --> 02:15:31.012
accurate snapshot of the issue. 
 What happens when you have 

02:15:31.013 --> 02:15:35.709
multiple ways to lead you to the
 same way in the code.  We have 

02:15:35.710 --> 02:15:41.416
a way to log custom errors -- 
custom events.  We out of the 

02:15:41.809 --> 02:15:46.238
box log some events like when 
the crash takes place, but you 

02:15:46.475 --> 02:15:50.360
interlace your own custom events
 with it, so you can read your 

02:15:50.952 --> 02:15:56.623
errors like a story. got some 
data back, I populated my UI 

02:15:56.905 --> 02:16:02.469
model and boom, a crash happens.
   becomes that much easier

02:16:06.352 --> 02:16:10.663
 over the last couple of months,
 we had the opportunities to 

02:16:10.664 --> 02:16:14.286
work with Shazam.  They have 
tested our product, given 

02:16:14.615 --> 02:16:18.140
feedback, made it much better.  
Today I'm happy to have my 

02:16:22.104 --> 02:16:27.167
friend Iordanis who will tell us
 about Android development.  He 

02:16:27.168 --> 02:16:33.384
will tell us about i Thank you. 
 Two points for pronouncing my 

02:16:33.385 --> 02:16:38.948
name correctly.you.  There is 
excitement about Firebase.  

02:16:40.164 --> 02:16:46.520
Shazam that was excitement was 
started when we received a 

02:16:46.521 --> 02:16:53.074
contact from the Shazam team.  
installation was so easy, we 

02:16:53.075 --> 02:16:56.937
decided in some of the features 
that were described and were 

02:16:57.069 --> 02:17:00.185
compelling, we decided to 
integrate with crash reporting 

02:17:00.281 --> 02:17:03.846
first.  After a couple of months
 of having it in production, it 

02:17:03.847 --> 02:17:06.838
turns out to be a valuable 
production to our current tool 

02:17:07.082 --> 02:17:11.366
chain, that is for those three 
reasons.   a very large number 

02:17:11.367 --> 02:17:16.135
of users per day.  Even if just 
a tiny percentage of the users 

02:17:16.136 --> 02:17:20.142
experiences a crash, it adds up.
  So the number of crashes are 

02:17:20.143 --> 02:17:23.395
actually quite a lot.  In our 
previous system, couldn't handle

02:17:23.931 --> 02:17:28.886
 all of that traffic so we knew 
we were not getting the whole 

02:17:29.232 --> 02:17:33.529
picture.  We know that will not 
be an issue with Google, with 

02:17:33.530 --> 02:17:37.326
Firebase because it is powered 
by the Google infrastructure and

02:17:37.454 --> 02:17:42.650
 we have an accurate view of how
 many crashes we get.  Ali 

02:17:42.651 --> 02:17:45.840
described the level of details 
with Firebase Crash Reporting. I

02:17:45.932 --> 02:17:48.807
 will give an example of how 
that helped us.   we are getting

02:17:49.046 --> 02:17:53.943
 the number of users in the 
distribution of users where the 

02:17:54.839 --> 02:17:58.286
crash occurs that we didn't have
 before.  A couple of releases 

02:17:58.423 --> 02:18:02.514
ago, we resolved two new issues 
that were appearing with the 

02:18:02.515 --> 02:18:06.944
same frequency but different 
distribution to users.  The 

02:18:07.494 --> 02:18:10.121
first was spread out, high d
istribution.  We knew it wasn't 

02:18:10.122 --> 02:18:14.033
going to be a device specific 
bug and quite occasional.  The 

02:18:14.034 --> 02:18:18.052
other one, on the other hand was
 specific, limited number of 

02:18:18.270 --> 02:18:21.249
users.  When we went to the 
Firebase console, we saw exactly

02:18:21.653 --> 02:18:26.414
 the manufacturer's models 
affected, the iOS versions and 

02:18:26.415 --> 02:18:33.263
managed to fix the issues.  the 
Firebase we integrated with 

02:18:33.264 --> 02:18:38.058
crash reporting, we use 
analytics, we know it will be 

02:18:38.059 --> 02:18:43.580
part of the same unified STK in 
the console.  We started using 

02:18:43.970 --> 02:18:46.802
dynamic links, as you may have 
seen, helps you maintain the 

02:18:46.803 --> 02:18:50.625
context of the user through the 
installation of your a amazing 

02:18:50.918 --> 02:18:53.856
to be an early using of crash 
reporting and we look forward to

02:18:54.192 --> 02:18:58.298
 doing more and more 
integrations.  Ali, back to  

02:18:58.426 --> 02:19:06.532
Thanks, pal.   I want to touch 
on a point that he just 

02:19:06.533 --> 02:19:10.297
mentioned at the end.  One of 
the main principleprinciples 

02:19:10.298 --> 02:19:14.093
that guide us as we think about 
app quality is it is not just 

02:19:14.094 --> 02:19:16.871
about metrics shown on a 
dashboard.  It is what you do 

02:19:16.872 --> 02:19:22.676
with this data and putting users
 first by having timely reaction

02:19:22.825 --> 02:19:28.853
 and winning them.  We think 
Firebase will be a key 

02:19:29.016 --> 02:19:33.648
ingredient to that.  you have an
 e-Commerce app and you have a 

02:19:33.649 --> 02:19:36.874
feature that will help with the 
conversion rates.  You want to 

02:19:37.001 --> 02:19:41.238
keep an eye on quality, of 
course.  jump into the Firebase 

02:19:41.471 --> 02:19:45.620
console, first thing you do is 
go to analytics.  In analytic, 

02:19:45.621 --> 02:19:49.977
build an audience of users that 
see errors.  You can do this 

02:19:49.978 --> 02:19:54.800
because we have the integration 
out of the box.  time it catches

02:19:54.929 --> 02:19:58.751
 an error. is added to an 
audience.  We will see how 

02:19:58.921 --> 02:20:03.096
important this is in a bit.   is
 go to remote config, which 

02:20:03.097 --> 02:20:05.914
allows you to control things 
remotely.  You wire that to your

02:20:06.430 --> 02:20:11.039
 feature to use it as an on-off 
switch.  You can pull the plug 

02:20:11.040 --> 02:20:13.954
anytime you want without having 
to push an update.  Okay.  So 

02:20:13.955 --> 02:20:18.113
you do these two things, push 
your new version out with a 

02:20:18.448 --> 02:20:21.302
feature, I take a look at the 
crash reporting console.  And 

02:20:21.303 --> 02:20:24.616
all of a sudden, there is a 
spike in errors.  Obviously, t

02:20:24.928 --> 02:20:28.260
hat's not a good thing.  You 
drill a bit more into it, look 

02:20:28.444 --> 02:20:30.925
at the stat base, you quickly 
realize this has something to do

02:20:31.323 --> 02:20:35.641
 with the feature you just 
pushed.  Jump back into remote 

02:20:35.642 --> 02:20:39.391
config, you turn the feature off
 and go into Firebase 

02:20:39.551 --> 02:20:42.290
notifications, you can send a 
push notification to an audience

02:20:42.291 --> 02:20:46.221
 in analytics.  You just created
 an audience of people that see 

02:20:46.579 --> 02:20:49.349
errors and now you can 
automatically send them a push 

02:20:49.762 --> 02:20:52.893
notification, tell them sorry, 
you're working on this and maybe

02:20:53.196 --> 02:20:57.091
 send them a discount to re
engage them back to the app.  

02:20:57.092 --> 02:20:59.451
Within minutes, you would do 
things that would otherwise take

02:20:59.636 --> 02:21:05.447
 you days of coding.  That is 
not even counting the time to 

02:21:05.448 --> 02:21:07.839
get the update.  That is 
powerful stuff.  At the end, 

02:21:07.840 --> 02:21:11.302
when you fix the issue, you go 
back to test lab, build a test 

02:21:11.303 --> 02:21:14.988
case for it and make sure any 
possible regression that might 

02:21:14.989 --> 02:21:19.885
happen in the future never makes
 it to your users.  This is what

02:21:20.042 --> 02:21:24.126
 is cool about Firebase.  It is 
14 powerful features that you 

02:21:24.127 --> 02:21:29.957
get access to using one SDK and 
one console you mix and match 

02:21:29.958 --> 02:21:33.600
what you need.  They're a cross 
platform, the vast majority of 

02:21:33.601 --> 02:21:37.372
features we have are supports 
iOS and Android and only going 

02:21:37.373 --> 02:21:41.399
to get better as we 
cross-integrate them more and 

02:21:41.666 --> 02:21:45.599
more.  We hope this gives you a 
different perspective on app 

02:21:45.600 --> 02:21:48.059
quality and gets you to think a
bout it throughout the quality 

02:21:48.060 --> 02:21:53.577
of stages of your app. you 
develop, use test lab to catch 

02:21:53.578 --> 02:21:56.736
all the bugs in development.  
When you release, keep your eye 

02:21:56.737 --> 02:22:00.382
on the Alpha and beta channels 
to make sure it is looking good.

02:22:01.080 --> 02:22:04.068
 production, use cross reporting
 to catch everything out there. 

02:22:04.069 --> 02:22:07.435
 We think using this combination
 will go a long way and will get

02:22:07.436 --> 02:22:11.038
 you the five-star reviews.   We

02:22:14.690 --> 02:22:17.738
 hope you're excited we have an 
amazing community of app 

02:22:17.739 --> 02:22:20.802
developers you can see on this 
slide and would love nothing 

02:22:20.803 --> 02:22:24.628
more than for you to join us.  
last notes here, we have a booth

02:22:24.968 --> 02:22:27.949
 set up right outside of this 
room where the test lab team 

02:22:27.950 --> 02:22:31.110
actually set up a rack with 
actual devices in it.  It is 

02:22:31.111 --> 02:22:34.083
really cool.  You need to check 
this out.  So drop us a visit 

02:22:34.084 --> 02:22:39.152
over there.  will be around for 
Q&amp;A for about an hour or so.  We

02:22:39.304 --> 02:22:42.970
 would love to talk to you.  F
inally, all the products we 

02:22:43.180 --> 02:22:46.832
talked about today are live 
today.   the console, hack away,

02:22:47.517 --> 02:22:51.494
 enjoy it.  Keep thinking about 
app quality.  It really matters.

02:22:51.495 --> 02:22:56.628
  Thank you so much.   to you in
 a bit &gt;&gt; So we'll do Q&amp;A, there

02:22:56.756 --> 02:22:59.931
 are mics here if you want to 
ask questions right now, 

02:23:00.612 --> 02:23:02.612
actually.

02:23:06.786 --> 02:23:13.306
 does the automated espresso 
work with asynchronous code like

02:23:14.013 --> 02:23:18.102
 an event bus or RX java 
something that has the idling 

02:23:18.375 --> 02:23:21.130
resources? Yeah, so this is 
definitely -- this is a great 

02:23:21.287 --> 02:23:24.500
question.  So this is one of the
 scenarios that we're still 

02:23:24.832 --> 02:23:28.599
considering to support.  Like 
one thing we're considering to 

02:23:28.600 --> 02:23:34.427
do isdo is add delays for that. 
 We know this isn't the optimal 

02:23:34.585 --> 02:23:40.917
way.  We generated a boiler 
plate for fully functional 

02:23:41.413 --> 02:23:44.405
espresso code for you.  You can 
hack at it or use it as is.  

02:23:44.406 --> 02:23:48.624
That is basically the idea.  
Yeah.  Thanks.  Questions, just 

02:23:48.749 --> 02:23:52.296
come to the mic if you want to 
ask a question.  Next question. 

02:23:53.298 --> 02:24:02.350
  the Firebase Test Lab the 
gentlemen at American Express, 

02:24:02.351 --> 02:24:06.469
is the idea to use it in the 
continuous integration process 

02:24:06.470 --> 02:24:08.571
or more when you are ready to 
release you send a bill up 

02:24:08.928 --> 02:24:13.366
there?  Is there a quick enough 
performance to be able to go run

02:24:13.547 --> 02:24:18.686
 this and then be able to have 
your check-in staged, based on 

02:24:18.861 --> 02:24:23.167
that.  Make sense?  Yeah, I 
think, both are valid use case, 

02:24:23.168 --> 02:24:26.249
I think.  If you want to -- if 
you have changes on a branch and

02:24:26.445 --> 02:24:30.013
 you want to make sure all your 
tests are passing before the 

02:24:30.380 --> 02:24:33.817
branch is merged a CI is a great
 place to do that.  You want to 

02:24:33.818 --> 02:24:36.853
make sure you do the regression 
before you launch and also you 

02:24:36.854 --> 02:24:40.778
get the additional protection of
 the Play launch report. Right. 

02:24:41.242 --> 02:24:47.615
 But per check-in?   run every 
branch before it gets merged so 

02:24:47.616 --> 02:24:51.131
whatever the latest check-in 
when the CI picks it up.  If you

02:24:51.306 --> 02:24:58.591
 do a couple check-ins in a row,
 it may miss one.  It is the 

02:24:58.592 --> 02:25:01.520
latest check in on every full 
request.  You said it is

02:25:04.581 --> 02:25:11.922
 one single STK, have you made 
any thoughts on how to make one 

02:25:11.923 --> 02:25:19.612
mass analytic STK.  Like Google 
Play services.  I'm sure people 

02:25:19.613 --> 02:25:21.613
are concerned about that 

02:25:28.118 --> 02:25:32.255
 cut depending on what you want.
  In the case of iOS, you can 

02:25:32.256 --> 02:25:36.684
include individual fonts, but we
 have configuration pods that 

02:25:36.685 --> 02:25:42.813
have a product for you as a base
 package.  That is a preference 

02:25:42.814 --> 02:25:47.252
for you there.  lot of amazing  
Hi, I was wondering how this new

02:25:47.387 --> 02:25:49.943
 mechanism is different from the
 old crash reporting mechanism 

02:25:49.944 --> 02:25:54.800
where the user gets to select 
what send details, screen shots 

02:25:54.801 --> 02:25:59.224
of the report and are the end 
users aware of this change?  Do 

02:25:59.225 --> 02:26:03.725
you have control over it?  Yes. 
 So on the Google Play developer

02:26:04.412 --> 02:26:08.420
 console, you see crashes that 
are reported by users for the 

02:26:08.902 --> 02:26:15.504
platform.  So these are crashes 
ANRs, like exceptions.  The STK 

02:26:15.505 --> 02:26:21.108
is where you control your own 
custom exceptions as well.  STK 

02:26:21.109 --> 02:26:26.252
will catch all the exceptions 
that you control.  And then you 

02:26:26.537 --> 02:26:31.553
have the ANRs from Google play 
show up as well.  We recommend 

02:26:31.554 --> 02:26:35.465
people to use Firebase Crash 
Reporting as the crash reporting

02:26:35.466 --> 02:26:40.320
 tool moving forward to improve 
your iOS and Android  Thank you.

02:26:40.321 --> 02:26:44.446
  Hello, I have two questions, 
actually.  The first one, there 

02:26:44.447 --> 02:26:48.887
is a lot of Firebase branding.  
Can we use it without Firebase 

02:26:48.888 --> 02:26:54.171
as a back end? &gt;&gt; Can you use 
Firebase Crash Reporting without

02:26:54.683 --> 02:26:59.306
 using Firebase back end?  
Definitely.  You can pick and 

02:26:59.307 --> 02:27:05.016
choose what you want to use.  No
 matter what back end you can 

02:27:05.017 --> 02:27:09.276
use Firebase Crash Reporting.  
we use Firebase test reporting 

02:27:09.277 --> 02:27:16.466
as a feedback tool so clients 
can enter feedback not just  

02:27:16.467 --> 02:27:21.543
What sort It is not necessarily 
a crash or issue, but something 

02:27:21.544 --> 02:27:27.681
behaving erratically.  Can they 
bring up an interface and hey, 

02:27:27.682 --> 02:27:31.838
why is this happening?  That is 
not something happening today, 

02:27:31.839 --> 02:27:38.515
but a feature request, and 
something to link into your own 

02:27:39.811 --> 02:27:44.107
 Hello.  I just want to know 
about custom exceptions.  Can I 

02:27:44.108 --> 02:27:49.380
put some custom fields like user
 I.D. or something and filter by

02:27:49.795 --> 02:27:54.385
 that?  I'm not sure I got the 
question.  Can you say it again?

02:27:54.386 --> 02:27:58.801
  Can you put custom identifiers
 with your crash, can you send 

02:27:58.802 --> 02:28:04.150
user I.D.s yourself?  We don't 
have this at the moment.  It is 

02:28:04.151 --> 02:28:08.862
a top request.  working on it.  
The problem with this is it has 

02:28:09.053 --> 02:28:11.704
implications on privacy of 
course.  We want to do it in the

02:28:11.705 --> 02:28:17.721
 right way to protect end user 
privacy.  We're aware of this 

02:28:17.722 --> 02:28:23.599
request and working on it as a 
&gt;&gt; Okay, tyHi, our app uses the 

02:28:23.908 --> 02:28:28.144
camera.  It has always been hard
 to test multiple devices. racks

02:28:28.408 --> 02:28:33.213
 like the lab offers when we 
have this proprietary technology

02:28:33.214 --> 02:28:35.934
 that has to take frames and 
understand what they're filming,

02:28:36.290 --> 02:28:39.695
 do you have any suggestions how
 we can test something like 

02:28:40.038 --> 02:28:45.325
that?  Sure.  So one way to test
 scenarios like this is to mock 

02:28:45.326 --> 02:28:49.643
the input to the camera and do 
the processing.  If you do an 

02:28:50.078 --> 02:28:53.097
instrumentation testing, that is
 one way to do it.  The thing 

02:28:53.266 --> 02:28:56.346
is, you can still use the 
camera.  These are actual 

02:28:56.551 --> 02:29:00.092
phones, the fact is we tape the 
back of the camera, because we 

02:29:00.093 --> 02:29:02.997
don't want any privacy concerns 
from people looking at other 

02:29:03.202 --> 02:29:07.114
people's apps at the same time. 
 That is what we do.  Can you 

02:29:07.115 --> 02:29:11.237
get a set of frames to do any 
processing for.  Like, do the 

02:29:12.001 --> 02:29:16.263
actual capturing of the screen 
and mock the expected response 

02:29:16.264 --> 02:29:20.188
and do the processing  That is 
one of the big advantages of 

02:29:20.514 --> 02:29:24.306
using the physical devices that 
test lab has to offer, versus 

02:29:24.307 --> 02:29:29.770
using virtual d sounds like a 
good idea, thanks.  But if I 

02:29:29.771 --> 02:29:33.996
want to test the output of the 
camera itself, so there is no 

02:29:34.326 --> 02:29:37.515
possibility today on the lab, 
right?  Yeah, but the idea is 

02:29:37.516 --> 02:29:41.313
like the camera itself, you 
really -- it is depending on the

02:29:41.314 --> 02:29:44.393
 manufacturer.  Like you should 
expect -- you should expect a 

02:29:44.394 --> 02:29:49.429
video at the end and your app 
will perform as well as it will 

02:29:49.430 --> 02:29:53.515
be able to process that video.  
So you can still make sure the 

02:29:53.516 --> 02:29:57.805
camera launches, it fires up, it
 records something and then 

02:29:57.806 --> 02:30:01.202
separate the video processing 
from that.  Basically, in t

02:30:01.500 --> 02:30:05.200
esting, in general, you try to 
breakdown every part.  Like, you

02:30:05.201 --> 02:30:09.135
 don't want to put as much 
dependency -- so many 

02:30:09.136 --> 02:30:13.073
dependencies in your testing.  
it down as much as possible.  

02:30:13.074 --> 02:30:18.888
That is one way to do it.  Break
 it down, recording versus  y 

02:30:20.708 --> 02:30:22.708
have two questions for the 
gentleman from

02:30:25.935 --> 02:30:29.723
 AMEX.  How big was the test 
suite?  How long does it take 

02:30:29.724 --> 02:30:38.895
you to run it doing a PI  It has
 grown over time, we're at well 

02:30:38.896 --> 02:30:42.261
over a thousand instrumentation 
tests.  We break them up, we 

02:30:42.262 --> 02:30:46.783
shard them, meaning we don't run
 them in one continuous, single 

02:30:47.056 --> 02:30:52.494
invocation, we run them in 
multiple invocations to CTL.  

02:30:52.805 --> 02:30:55.968
will depend on how you run them,
 like if you divide them up, how

02:30:56.424 --> 02:31:04.384
 you do that.  It depends -- it 
will depend also on the QM time 

02:31:04.385 --> 02:31:10.915
on  In a typical VR verify 
process how long does it take? 

02:31:10.916 --> 02:31:15.280
We can see 20 to 30 minutes, 
which we also do code review.  

02:31:15.281 --> 02:31:17.768
The code review usually takes 
longer than that.  But there is 

02:31:17.769 --> 02:31:23.796
a lot of  Did you think about 
any cross back solutions.  I use

02:31:24.136 --> 02:31:32.562
 this for iOS and Android or 
just Android?   A question for 

02:31:32.563 --> 02:31:37.655
the rest of the panel.  Do we 
have successful examples of 

02:31:37.656 --> 02:31:47.048
folks that have used it for 
cross  -- platform.  works 

02:31:47.049 --> 02:31:51.538
across iOS and Android.  We are 
evaluating the iOS  When you 

02:31:51.539 --> 02:31:55.533
said Firebase is cross platform,
 it is everything else Exactly, 

02:31:55.534 --> 02:31:59.463
except for test lab.  do you 
have plans for doing that cross 

02:31:59.618 --> 02:32:03.600
platform?  That is a great  took
 us like some significant effort

02:32:03.780 --> 02:32:07.368
 to bring this infrastructure up
 and running.  So we're still 

02:32:07.540 --> 02:32:12.458
evaluating the iOS offering.  
tuned for updates.   announce 

02:32:12.459 --> 02:32:19.011
right  Thank you.  All right.  
We use apium to drive tests.  Is

02:32:19.175 --> 02:32:25.035
 that supported on the test lab?
  If not, what is  Apium is not 

02:32:25.036 --> 02:32:31.934
supported in test lab.  Right 
now the Android test link, 

02:32:31.935 --> 02:32:36.865
espresso and robotium.  And with
 espresso test reporter, give it

02:32:37.166 --> 02:32:42.361
 a try, start hacking with  
Thank yThanks.  I have a 

02:32:42.622 --> 02:32:46.992
question about the prerelease 
testing.  Our app has a log-in 

02:32:47.359 --> 02:32:50.935
screen, you can't get past it 
without logging in.  The issue 

02:32:50.936 --> 02:32:53.847
we have had with testing 
currently on the console is you 

02:32:53.848 --> 02:32:58.599
get a log-in screen, it presses 
around a little bit and that 

02:32:58.600 --> 02:33:03.162
finishes the testing.  Is there 
plans to give simple log-in i

02:33:03.307 --> 02:33:07.220
nformation?  Yes, one of the 
gifts Ahmed demonstrated was 

02:33:07.524 --> 02:33:14.047
handling a log-in screen for 
Google+ or any Google account, r

02:33:14.894 --> 02:33:19.770
 already supported today, if you
 use a Google log-in for your a

02:33:20.105 --> 02:33:23.694
pplication.   on other log-in 
flows.  Today, the real value is

02:33:23.882 --> 02:33:28.704
 if you don't have a log-in, or 
you have Google log-in with your

02:33:29.150 --> 02:33:34.128
  All right.  Thank  Thank you 
very much.   have a question 

02:33:34.129 --> 02:33:39.787
about scaleability for test 
labs.  two dimensions.  app is 

02:33:39.788 --> 02:33:44.315
quite popular in Kenya.  And we 
have seen some pretty unique 

02:33:44.316 --> 02:33:51.638
devices and iOSOS versions on 
it.  If that device is not in 

02:33:51.639 --> 02:33:55.318
test labs, how would we request 
that?   since the announcement 

02:33:55.481 --> 02:33:58.171
today, I assume a lot of 
developers are going to be 

02:33:58.172 --> 02:34:02.561
trying it out.  How do you 
foresee scaling it to Google 

02:34:02.562 --> 02:34:06.436
scale as all the developers want
 to run their test across all 

02:34:06.437 --> 02:34:11.061
the devices of your test lab?  
That's a great question.  test 

02:34:11.062 --> 02:34:14.187
lab is trying to help you with 
is the exact two points you m

02:34:14.887 --> 02:34:17.234
ention.  It is something like 
we're taking care of the 

02:34:17.235 --> 02:34:20.844
infrastructure so you don't have
 to and we're taking care of 

02:34:21.036 --> 02:34:24.077
getting all the devices you need
 so you don't have to.  It is 

02:34:24.078 --> 02:34:27.923
growing with Google scale, we're
 building the infrastructure 

02:34:27.924 --> 02:34:31.009
with Google scale, you should 
expect to get started and run it

02:34:31.010 --> 02:34:34.345
 right now.  In terms of device 
diversity, this is top priority.

02:34:34.346 --> 02:34:38.384
  We're adding more devices now.
  Just keep looking.  Hopefully 

02:34:38.385 --> 02:34:41.811
the devices that are popular in 
Kenya will be available soon and

02:34:41.812 --> 02:34:45.558
 you will get more and more 
value over  Thanks a lot,  Thank

02:34:45.559 --> 02:34:50.190
 yHi, everyone.  I have a 
question directed to one of the 

02:34:50.364 --> 02:34:56.901
persons, Michael, who works in d
ynamics, how do you check a 

02:34:57.546 --> 02:35:01.021
feature called remote check 
deposit?  Anything that is 

02:35:01.022 --> 02:35:08.016
remote check deposit?  related 
the camera taking a picture?  We

02:35:08.149 --> 02:35:12.228
 haven't done any camera 
testing.  The app we use on 

02:35:12.358 --> 02:35:15.087
Cloud Test Lab has no camera 
features in it.  We haven't done

02:35:15.616 --> 02:35:19.851
 any camera  It doesn't support 
it using espresso, right?  

02:35:19.852 --> 02:35:25.739
Because of third  You mean, like
 you will can deposit a check in

02:35:25.740 --> 02:35:31.379
 the test?  Uh-huh. Yeah, as I 
mentioned, one way to do it is 

02:35:31.380 --> 02:35:34.939
break it down into two parts.  
Make sure the camera fires, that

02:35:34.940 --> 02:35:38.880
 is one test to account for.  
The other part is when it gets 

02:35:38.881 --> 02:35:43.639
an image it is able to process i
 is the recommended approach to 

02:35:43.640 --> 02:35:51.966
do  Thank you. Thanks.   do we 
get those screen shots in the 

02:35:51.967 --> 02:35:55.715
developer console?  Are those 
going to be kind of automatic?  

02:35:55.831 --> 02:35:59.402
Do we need to put in some test 
code that tells you where to 

02:35:59.403 --> 02:36:03.979
take the screen s Yeah, so 
today, the way it works is you 

02:36:04.700 --> 02:36:09.393
just upload the APK to the Play 
developer console.  The robo 

02:36:09.394 --> 02:36:13.094
that Ahmed described will 
interact with the app for about 

02:36:13.095 --> 02:36:17.516
five minutes.  There are screen 
shots taken about every second 

02:36:17.517 --> 02:36:21.874
the robot is interacting.  We a
re adjusting it to capture the 

02:36:22.518 --> 02:36:25.703
big screen differences so it is 
most valuable to you and 

02:36:25.704 --> 02:36:28.208
investigating other ways to 
enhance that with showing you 

02:36:28.209 --> 02:36:32.811
the state the app is in.  You 
should be able to gather the 

02:36:32.954 --> 02:36:36.911
data and shouldn't have to do 
any work really.  Upload the amp

02:36:37.238 --> 02:36:44.824
  -- APK, the report is 
generated for free.  to add to 

02:36:44.825 --> 02:36:48.782
what Fergus mentioned, if you 
are using it to run the 

02:36:49.317 --> 02:36:52.101
implementation test, in 
espresso, we have a library in 

02:36:52.102 --> 02:36:55.236
the documentation you can use.As
 you mention you have to take 

02:36:55.237 --> 02:36:59.716
screen shots at the locations 
you want, using that  how does 

02:37:00.778 --> 02:37:04.864
Firebase analytics compare to 
Google analytics?  I think that 

02:37:04.865 --> 02:37:07.944
is something -- there is another
 session on the analytics side 

02:37:07.945 --> 02:37:11.067
of things.  Maybe that would be 
the right forum for that 

02:37:11.196 --> 02:37:15.315
question.  Unfortunately That 
session was at 3:00 p.m., but I 

02:37:15.316 --> 02:37:20.186
can connect you with the person 
for that.  work for a client 

02:37:20.187 --> 02:37:23.715
that is consider concerned about
 the confidentiality, when you 

02:37:23.716 --> 02:37:27.336
capture the screen shots and 
crash reporting, do you store 

02:37:28.096 --> 02:37:35.351
that, do you guys store that?  
There is no screens shots in the

02:37:35.779 --> 02:37:39.187
 crash reporting.  These are 
done in test lab and usually 

02:37:39.188 --> 02:37:43.343
dummy  Thank yHi, I know there 
is

02:37:46.612 --> 02:37:55.859
 -- test lab is a developiented 
--  platform.  is the role for 

02:37:55.860 --> 02:38:01.300
the developer in  The QA teams 
spend time setting up the 

02:38:01.635 --> 02:38:04.820
devices and configuring the 
cables, which is an inefficient 

02:38:04.821 --> 02:38:09.911
use of time. can go and run the 
test and work on the automation 

02:38:09.912 --> 02:38:12.868
of the test and be able to go 
through the results and actually

02:38:12.997 --> 02:38:16.297
 then generate the reports and 
bugs of what issues are h

02:38:16.977 --> 02:38:21.576
appening.  It is more about 
enhancing the QA team's ability 

02:38:21.577 --> 02:38:24.910
to make the rest of the team 
aware of the issues that are 

02:38:25.577 --> 02:38:31.397
being uncovered.   Thank you.  
Ahmed do you want to reply to 

02:38:31.604 --> 02:38:38.436
that?  &gt;&gt; Sure.  For the QA team
 question, the QA team can build

02:38:38.437 --> 02:38:43.243
 your infrastructure.  use case 
here that is great for QA team 

02:38:43.244 --> 02:38:46.314
as well, previously from the 
research, what we notice is 

02:38:46.315 --> 02:38:50.959
people will have a device 
closet.  Before releasing a new 

02:38:51.351 --> 02:38:57.135
version, you grab a phone, run a
 scenario and grab another 

02:38:57.343 --> 02:39:01.974
phone.  With the test recorder, 
we want to make it easy.  Record

02:39:02.186 --> 02:39:07.065
 the script one, run it in the 
cloud and make sure the app runs

02:39:07.287 --> 02:39:11.229
 on all the devices with one 
trial of your app. &gt;&gt; Two 

02:39:11.230 --> 02:39:16.603
questions.  First, what is 
average crash rate of the most 

02:39:16.604 --> 02:39:26.489
popular application?  is more 
than crash and 

02:39:26.662 --> 02:39:33.629
features, and performance such 
as STS and something like that. 

02:39:34.019 --> 02:39:39.201
 Do you have any plan to test 
this and improve the 

02:39:40.439 --> 02:39:44.315
performance?  Yeah, performance 
testing is something definitely 

02:39:44.316 --> 02:39:48.072
where we have heard so many like
 ideas and feedback about from 

02:39:48.436 --> 02:39:50.798
developers.  It is something we 
will probably start thinking 

02:39:51.058 --> 02:39:56.250
about.  So yeah, stay tuned for 
 The first question is what is 

02:39:56.251 --> 02:40:01.872
average --Yeah, so in terms of 
the previous question about the 

02:40:01.873 --> 02:40:04.696
confidentiality of app 
developers, that is something 

02:40:04.697 --> 02:40:08.433
that we definitely respect.  we 
wouldn't be able to tell you 

02:40:08.434 --> 02:40:12.127
which apps are the crashiest 
ones, unfortunately. about 

02:40:16.373 --> 02:40:22.596
that.  there a standard for bad 
crash rate or good crash &gt;&gt; 

02:40:22.757 --> 02:40:25.348
Yeah, definitely something we 
could investigate is showing you

02:40:25.468 --> 02:40:30.150
 how you compare with your peers
 in a way where it is anonymized

02:40:30.269 --> 02:40:33.105
 for the rest of the group.  
Thanks for the feedback.  I 

02:40:33.106 --> 02:40:36.794
think we have time for one last 
question.   the person behind 

02:40:36.969 --> 02:40:42.870
you?   All right.  So do you 
have a way to test the look and 

02:40:42.871 --> 02:40:47.814
feel of the application rather 
than like the functionality?  

02:40:47.981 --> 02:40:51.298
Yeah.  So as part of the p
relaunch report we show you the 

02:40:51.299 --> 02:40:54.460
screen shots.  Today, you 
actually can look through the 

02:40:55.208 --> 02:40:58.619
screen shots and identify the 
issues yourself, but definitely 

02:40:58.620 --> 02:41:02.042
things we are investigating is 
accessibility and other 

02:41:02.043 --> 02:41:05.143
identification of the issues 
that are appearing on the 

02:41:05.514 --> 02:41:11.145
screens. Okay.  then the app has
 to be coasted in Firebase -- 

02:41:11.146 --> 02:41:15.635
hosted in Firebase to be tested 
or  Any Android app can  Got  

02:41:15.636 --> 02:41:19.508
You can choose to use one 
Firebase offering.  it.  Thank  

02:41:19.509 --> 02:41:23.204
Thank you.  think we're out of 
time now, but thanks everyone 

02:41:23.205 --> 02:41:27.617
for joining, encourage you to 
use our quality &gt;&gt; Thank  We 

02:41:27.618 --> 02:41:34.547
will hang out over there at the 
test lab biography,  -- come by.

02:41:34.548 --> 02:41:36.548
  We will show you a demo as

02:41:45.711 --> 02:41:47.711
 of 

02:47:52.385 --> 02:47:54.385
 . . .

02:55:59.623 --> 02:55:59.743
Services provided by:
Caption First, Inc.

02:55:59.744 --> 02:55:59.841
P.O. Box 3066
Monument, CO 80132

02:55:59.842 --> 02:55:59.899
800-825-5234
www.captionfirst.com

02:55:59.900 --> 02:55:59.927
***
Thi s text is being provided in

02:55:59.928 --> 02:55:59.930
a realtime format. Communication

02:55:59.931 --> 02:56:03.331
Access Realtime Translation
(CART) or captioning are

02:55:59.931 --> 02:56:04.130
provided in  order to facilitate
communication accessibility and

02:55:59.932 --> 02:55:59.974
may not be a  totally verbatim
record of the proceedings.

02:55:59.975 --> 02:56:01.975
***

02:56:08.012 --> 02:56:13.320
Google
Google I/O

02:56:13.342 --> 02:56:15.512
Angular two and Progressive Web 
Apps

02:56:15.513 --> 02:56:17.513
5:00 p.m.

02:56:21.116 --> 02:56:24.131
May 18, 2016
5:00 p.m. PT

02:56:48.522 --> 02:56:50.522
(Cheering and applause)

02:56:56.923 --> 02:56:58.822
&gt;&gt; ROB WORMALD: Hey, I'm a 
developer

02:56:58.823 --> 02:56:59.816
 advocate.
&gt;&gt; ALEX RICKABAUGH: I'm a 

02:56:59.817 --> 02:57:01.817
software
 engineer. We work on

02:57:05.436 --> 02:57:07.419
  Angular mobile,
 and we're here to talk about 

02:57:07.420 --> 02:57:09.435
progressive
 web apps apps.

02:57:09.458 --> 02:57:11.725
&gt;&gt; ROB WORMALD: So if you've 
been

02:57:11.726 --> 02:57:16.142
 at I/O today, you heard  about 
progressive

02:57:16.143 --> 02:57:18.621
 web apps. For us to understand 
why

02:57:18.622 --> 02:57:21.114
 you should  be interested in 
them,

02:57:21.115 --> 02:57:24.113
 them, we should go back a bit. 
In

02:57:24.114 --> 02:57:25.921
 the Wild West  of the weapon 
development

02:57:25.922 --> 02:57:29.931
 world, web development world, 
six

02:57:29.932 --> 02:57:32.319
 months ago, this is how we  
started

02:57:32.320 --> 02:57:34.326
 building web apps. You'd have a
 browser,

02:57:34.327 --> 02:57:37.527
 a server, you'd  go to a 
website.

02:57:37.528 --> 02:57:39.925
 The server would construct the 
page,

02:57:39.926 --> 02:57:42.827
 send it  back, you decide to 
buy

02:57:42.828 --> 02:57:45.831
 the budget widget, you send a 
post

02:57:45.832 --> 02:57:48.222
 back, and the  cycle would go 
on

02:57:48.223 --> 02:57:50.241
 and on.
And this worked really great for

02:57:51.038 --> 02:57:53.121
 a
 long time.

02:57:53.145 --> 02:57:55.031
&gt;&gt; ALEX RICKABAUGH: And then we 
discovered

02:57:55.032 --> 02:57:57.839
 Ajax and started  building 
single-page

02:57:57.840 --> 02:57:59.630
 applications. The idea was 
instead

02:57:59.631 --> 02:58:01.530
 of a  request response cycle 
over

02:58:01.531 --> 02:58:04.026
 and over again, we would send 
down

02:58:04.027 --> 02:58:06.323
  JavaScript code with the first
 page.

02:58:06.324 --> 02:58:08.232
 That code would take over  and 
run

02:58:08.233 --> 02:58:11.327
 the UI. If it needed data, it 
would

02:58:11.328 --> 02:58:15.235
 get it. We would send  back 
JSON

02:58:15.236 --> 02:58:16.943
 and drop it. This was a much 
better

02:58:16.944 --> 02:58:18.727
 world, actually. We  had 
applications

02:58:18.728 --> 02:58:20.738
 that felt a lot more 
interactive

02:58:20.739 --> 02:58:24.640
 and faster.
&gt;&gt; So the framework that we work

02:58:24.846 --> 02:58:26.743
 on
 came from this world. You  

02:58:26.744 --> 02:58:28.737
might
 have heard of it. Anybody here 

02:58:28.738 --> 02:58:31.276
an
 Angular developer? Yes.  You 

02:58:31.277 --> 02:58:34.419
can
 woo, that's good. So, we de

02:58:34.421 --> 02:58:37.814
scribe
 Angular as this super  heroic 

02:58:37.815 --> 02:58:40.276
JavaScript
 framework. It's like what 

02:58:40.277 --> 02:58:42.237
Angular
 would've been been, or, it's 

02:58:42.238 --> 02:58:43.840
what
 HTML would have been had we 

02:58:43.841 --> 02:58:48.849
designed
 it for  web apps. There's tons 

02:58:48.850 --> 02:58:51.139
of
 Angular apps in the wild.

02:58:51.163 --> 02:58:52.145
Everything was wonderful and 
great.

02:58:52.146 --> 02:58:56.948
 It's a great world we live  in.
&gt;&gt; So we started building more 

02:58:56.949 --> 02:58:59.279
and
 more complicateed single- 

02:58:59.280 --> 02:59:00.254
single-page
 applications with features and 

02:59:00.255 --> 02:59:02.056
bells
 and whistles. We  ran into some

02:59:02.057 --> 02:59:04.370
 problems,
 right. Suddenly we're pushing a

02:59:04.400 --> 02:59:05.958
 lot
 of  code to the browser, every 

02:59:05.959 --> 02:59:07.958
time
 the application starts up. The 

02:59:07.959 --> 02:59:09.775
 web
 wasn't designed to do this. Web

02:59:09.776 --> 02:59:11.765
 pages
 are supposed to be  interactive

02:59:11.766 --> 02:59:13.357
.
 It shouldn't take ten seconds 

02:59:13.358 --> 02:59:17.260
to
 load the code in.

02:59:17.287 --> 02:59:19.881
&gt;&gt; This is why we're here today,
 and

02:59:19.882 --> 02:59:21.174
 why this has become a  thing. 
This

02:59:21.175 --> 02:59:23.277
 is the quote from Google 
developers

02:59:23.278 --> 02:59:25.170
 website. I'm not  going to read
 it

02:59:25.171 --> 02:59:27.663
 to you. But the primary 
takeaway

02:59:27.664 --> 02:59:30.971
 here is the  idea of the app-
like

02:59:30.972 --> 02:59:35.086
 user experience. On the age 
team,

02:59:35.087 --> 02:59:36.276
 Angular team, we've  been 
trying

02:59:36.277 --> 02:59:38.712
 to hit the goal of building app
-like

02:59:38.713 --> 02:59:44.123
 apps, right? So  while the web 
has

02:59:44.124 --> 02:59:45.382
 been evolving, while these 
ideas

02:59:45.383 --> 02:59:48.607
 of PWAs are  coming out, 
Angular

02:59:48.608 --> 02:59:50.082
 has been evolving. We've been 
writing

02:59:50.083 --> 02:59:51.483
 the new  version of Angular, 
Angular

02:59:51.484 --> 02:59:53.678
 2, and we've been really kind 
of

02:59:53.679 --> 02:59:56.391
  trying to re-evolve the entire
 framework

02:59:56.392 --> 02:59:58.794
 as this whole web thing  
changes.

02:59:58.795 --> 03:00:03.389
 We want to keep up, right?
And so to do that, we wanted to 

03:00:03.390 --> 03:00:05.589
build
 one. We wanted to see  what the

03:00:05.793 --> 03:00:08.003
 experience
 was like. A huge amount of the 

03:00:08.004 --> 03:00:10.392
Angular
 team  doesn't build apps on a 

03:00:10.393 --> 03:00:12.407
day-to-day
 basis. We build framework code 

03:00:12.408 --> 03:00:13.993
code.
 We don't always know what you 

03:00:13.994 --> 03:00:15.993
as
 developers have to deal  with. 

03:00:15.994 --> 03:00:17.307
So
 this is something we want to do

03:00:17.308 --> 03:00:18.891
.
 So we wanted to build  this 

03:00:18.892 --> 03:00:20.995
progressive
 web app and get a feel for what

03:00:21.092 --> 03:00:23.709
 it
 means to make  an application 

03:00:23.710 --> 03:00:25.202
really
 perform, what it means to make 

03:00:25.203 --> 03:00:27.705
them
 re reliable offline, online, 

03:00:27.706 --> 03:00:29.706
how
 hard it is, how easy it is to 

03:00:29.707 --> 03:00:32.695
make
  things immerseive to get this 

03:00:32.696 --> 03:00:33.136
good
 experience.

03:00:33.137 --> 03:00:36.301
&gt;&gt; We didn't just want to build 
another

03:00:36.302 --> 03:00:38.010
 sample application. We  wanted 
to

03:00:38.011 --> 03:00:40.094
 build something we would use. 
The

03:00:40.095 --> 03:00:43.404
 Angular team, we get  a lot of 
GitHub

03:00:43.405 --> 03:00:46.207
 issues. Some are good bug 
reports,

03:00:46.208 --> 03:00:47.604
 reproduceleproducible 
reproducible,

03:00:47.605 --> 03:00:49.298
 and some are not as high 
quality.

03:00:49.299 --> 03:00:52.206
 We need a way to  triage them 
quickly.

03:00:52.207 --> 03:00:54.698
 We built issue zero. If you 
used

03:00:54.699 --> 03:00:56.304
 inbox zero,  it's kind of the 
same

03:00:56.305 --> 03:00:59.340
 principle. You go through and 
swipe

03:00:59.341 --> 03:01:01.397
 left on  issues to close them. 
You

03:01:01.398 --> 03:01:05.413
 swipe right to triage and apply
 labels.

03:01:05.414 --> 03:01:07.518
As Rob was saying, we don't 
build

03:01:07.519 --> 03:01:08.519
 comprehensive applications  
that

03:01:08.520 --> 03:01:11.809
 much. We wanted tomore all of
make

03:01:11.810 --> 03:01:14.509
 sure this stuff would work well
  together.

03:01:14.510 --> 03:01:16.513
 We took the idea of an 
application

03:01:16.514 --> 03:01:19.123
 shell, the service  worker API,
 fire-based

03:01:19.124 --> 03:01:20.814
 authentication, it's a server
less

03:01:20.815 --> 03:01:23.011
 app. We  used index DB to make 
sure

03:01:23.012 --> 03:01:25.117
 the data is cacheed offline. If
 you

03:01:25.118 --> 03:01:26.814
  don't have a network 
connection,

03:01:26.815 --> 03:01:29.424
 it'll load. We used two 
projects

03:01:29.425 --> 03:01:31.316
  within Angular, our material 
framework

03:01:31.317 --> 03:01:33.915
 for building pretty,  beautiful
 UIs,

03:01:33.916 --> 03:01:36.412
 and our CLI which takes care of
 a

03:01:36.413 --> 03:01:40.722
 lot of the  build tooling for 
us.

03:01:40.723 --> 03:01:42.207
So the first challenge we wanted
 to

03:01:42.208 --> 03:01:43.831
 see if we addressed well  was 
loading

03:01:43.832 --> 03:01:45.216
 the application, getting 
something

03:01:45.217 --> 03:01:49.329
 on the screen  really quickly. 
And

03:01:49.330 --> 03:01:52.712
 so, this idea of application 
shell

03:01:52.713 --> 03:01:54.316
 that we're  using to do this 
comes

03:01:54.317 --> 03:01:55.723
 from progressive web apps. The 
idea

03:01:55.724 --> 03:01:57.625
 is  that you really take 
advantage

03:01:57.626 --> 03:02:01.214
 of what index.HTML is. It's not
  just

03:02:01.215 --> 03:02:03.051
 a place where we put the 
scripts

03:02:03.052 --> 03:02:04.724
 to load and the link tags  to 
the

03:02:04.725 --> 03:02:07.218
 CSS. It's the very first thing 
that

03:02:07.219 --> 03:02:08.837
 gets sent from the web  server 
to

03:02:08.838 --> 03:02:12.725
 the phone or to the browser.
So we take advantage of it and 

03:02:12.726 --> 03:02:15.217
we
 put this static UI into it.  

03:02:15.218 --> 03:02:17.112
This
 code that will render this 

03:02:17.113 --> 03:02:19.121
little
 title bar and a menu icon.  And

03:02:19.417 --> 03:02:21.229
 it's
 not much, but it tells our user

03:02:21.230 --> 03:02:23.118
s
 this application is a alive on 

03:02:23.119 --> 03:02:24.617
the
 page. It's loading. It's 

03:02:24.618 --> 03:02:26.622
working.
 It's doing work  for you in the

03:02:26.818 --> 03:02:28.823
 background
 to fetch data. At the very 

03:02:28.824 --> 03:02:32.868
bottom,
 we  put our script tags loaded 

03:02:32.869 --> 03:02:34.869
asynchronously.
 And that means that  Angular is

03:02:35.038 --> 03:02:36.661
 loading
 in the background while the 

03:02:36.662 --> 03:02:39.529
browser
 is busy  rendering this page. 

03:02:39.530 --> 03:02:41.523
Eventually
 it'll fill this application 

03:02:41.524 --> 03:02:42.955
shell
  with dynamic content.

03:02:42.956 --> 03:02:45.057
And that gives you a really nice
,

03:02:45.058 --> 03:02:47.022
 beautiful loading experience 
experience.

03:02:47.023 --> 03:02:49.120
 But one challenge doing this is
 you

03:02:49.121 --> 03:02:51.319
 kind of have two  copies of 
your

03:02:51.320 --> 03:02:52.522
 application. You have the 
static

03:02:52.523 --> 03:02:54.634
 code, the HTML  that loads the 
snap

03:02:54.635 --> 03:02:56.930
 shell, and then you have your 
dynamic

03:02:56.931 --> 03:02:58.234
  application written in Angular
.

03:02:58.235 --> 03:02:59.626
 We didn't want you to have to 
do

03:02:59.627 --> 03:03:02.522
  this. So we thought, ha what 
if

03:03:02.523 --> 03:03:04.222
 we could use the same 
primitives

03:03:04.223 --> 03:03:06.120
 in  Angular that we use to 
control

03:03:06.121 --> 03:03:08.928
 what DOM appears where, to 
control

03:03:08.929 --> 03:03:10.222
  what would be in your 
application

03:03:10.223 --> 03:03:12.225
 shell and would be in your  
static --

03:03:12.226 --> 03:03:15.739
 in your dynamic application.
So that's what we did. We have 

03:03:15.740 --> 03:03:17.341
this
 little shell render  directive.

03:03:17.342 --> 03:03:19.624
 And
 you can apply it and say this 

03:03:19.625 --> 03:03:20.651
thing
 should be part  of the app 

03:03:20.652 --> 03:03:23.037
shell,
 or excludeed from the app shell

03:03:23.042 --> 03:03:28.032
.
&gt;&gt; So how do we do this? If 

03:03:28.033 --> 03:03:30.729
you've
 built an Angular 1  application

03:03:31.140 --> 03:03:33.133
,
 you know the point of Angular. 

03:03:33.134 --> 03:03:34.447
The
 idea has been to  write an 

03:03:34.448 --> 03:03:36.753
application,
 talk to Angular, and Angular 

03:03:36.754 --> 03:03:39.434
handles
 talk talking to the DOM. We 

03:03:39.435 --> 03:03:41.640
don't
 make you do manual DOM updates.

03:03:41.853 --> 03:03:43.342
 This
  has been the selling point, 

03:03:43.343 --> 03:03:45.252
it's
 why we use it. But it's also  

03:03:45.253 --> 03:03:48.157
kind
 of the biggest crutch in 

03:03:48.158 --> 03:03:51.854
Angular 1,
 we are tightly coupleed  to the

03:03:54.153 --> 03:03:55.848
idea
 of splitting the two  ideas 

03:03:55.849 --> 03:03:58.361
apart.
 So now Angular 2 is very much 

03:03:58.362 --> 03:03:59.385
two
 parts.

03:03:59.386 --> 03:04:00.754
So we have the Angular that you 
kind

03:04:00.755 --> 03:04:03.252
 of know and love, you  speak to
,

03:04:03.253 --> 03:04:06.310
 that's what your application 
talks

03:04:06.311 --> 03:04:08.150
 to. Then we have a  separate 
layer

03:04:08.151 --> 03:04:10.057
 we call the renderer, which 
talks

03:04:10.058 --> 03:04:12.264
 to the DOM. But  these two 
pieces

03:04:12.265 --> 03:04:14.255
 were decoupled. We have a 
bridge

03:04:14.256 --> 03:04:15.850
 you speak  between the two. And
 it

03:04:15.851 --> 03:04:18.462
 means this renderer could be by
 default,

03:04:18.463 --> 03:04:20.555
  the one we use in the DOM like
 in

03:04:20.556 --> 03:04:23.065
 Angular 1, but it allows us to 
 do

03:04:23.066 --> 03:04:25.069
 flexible, interesting things. A
 lot

03:04:25.070 --> 03:04:27.254
 of this work is under a  
project

03:04:27.255 --> 03:04:30.162
 called Angular Universal. The 
idea

03:04:30.163 --> 03:04:33.054
 of Universal is that  it allows
 us

03:04:33.055 --> 03:04:36.561
 to do -- really boot up your 
application

03:04:36.562 --> 03:04:37.854
 and treat  Angular as if it was
 just

03:04:37.855 --> 03:04:40.670
 an app.
You don't have to think it's a 

03:04:40.671 --> 03:04:42.357
browser
 or web app or whatever,  it's 

03:04:42.358 --> 03:04:45.057
just
 an app. And so, this is an 

03:04:45.058 --> 03:04:47.355
example
 in Gulp. We're  booting up your

03:04:47.676 --> 03:04:49.957
 application,
 pre-rendering the content, and 

03:04:49.958 --> 03:04:51.865
 writing
 it out to disk. So this is 

03:04:51.866 --> 03:04:53.866
happening
 when you build your  app at the

03:04:54.093 --> 03:04:55.498
 same
 time you're compileing your 

03:04:55.499 --> 03:04:56.801
code.
 We can take that  application 

03:04:56.802 --> 03:04:58.892
shell,
 do all of the work upfront, and

03:04:59.184 --> 03:05:01.689
 then
 you can  statically cache this 

03:05:01.690 --> 03:05:04.805
application
 ready to go on your web server.

03:05:04.810 --> 03:05:08.784
&gt;&gt; That's how Universal works to
 build

03:05:08.785 --> 03:05:10.892
 application shell from  your 
templates

03:05:10.893 --> 03:05:13.096
 in HTML at build time. But you 
can

03:05:13.097 --> 03:05:15.090
 actually run  Universal at run 
time,

03:05:15.091 --> 03:05:17.088
 too, on your web server. If you
 have

03:05:17.089 --> 03:05:21.696
 a no  JS server or ASP.net has 
a

03:05:21.697 --> 03:05:23.169
 beautiful integration, when the
 user

03:05:23.170 --> 03:05:26.187
  requests a page, instead of 
serveing

03:05:26.188 --> 03:05:28.999
 them the JavaScript and the  
HTML

03:05:29.000 --> 03:05:31.002
 and having Angular run in the 
browser,

03:05:31.003 --> 03:05:33.002
 you can run Angular  in the 
server

03:05:33.003 --> 03:05:34.495
 and render out the HTML that 
you

03:05:34.496 --> 03:05:36.410
 would otherwise  have displayed
 in

03:05:36.411 --> 03:05:38.106
 the browser and send it to the 
user

03:05:38.107 --> 03:05:41.394
 statically.
So here's an example of how that

03:05:41.504 --> 03:05:45.002
 works
 in a no JS server.  You've 

03:05:45.003 --> 03:05:46.997
probably
 seen Express, a framework for 

03:05:46.998 --> 03:05:49.087
building
 web  servers in node. And here 

03:05:49.088 --> 03:05:51.689
we're
 telling express when it sees a 

03:05:51.690 --> 03:05:53.707
 request
 for an HTML file, it should use

03:05:53.890 --> 03:05:56.409
 the
 express engine from  Universal.

03:05:56.788 --> 03:05:59.539
 Instead
 of sending static HTML bytes to

03:05:59.791 --> 03:06:02.621
 the
 client, Ex Express will boot up

03:06:02.799 --> 03:06:04.502
 the
 Angular application, run 

03:06:04.503 --> 03:06:06.394
through
 and  render all your templates 

03:06:06.395 --> 03:06:08.534
just
 as if it were running in the  

03:06:08.535 --> 03:06:11.208
browser,
 and send the HTML to the client

03:06:11.390 --> 03:06:12.799
.
 It's a powerful way of  doing 

03:06:12.800 --> 03:06:14.889
things.
And it has a lot of benefits. We

03:06:15.294 --> 03:06:16.289
 talked
 about performance,  getting 

03:06:16.290 --> 03:06:18.394
applications
 on screen fast. But another one

03:06:18.595 --> 03:06:21.099
 is
 search  engine optimization. 

03:06:21.100 --> 03:06:23.110
Not
 every web crawler out there 

03:06:23.111 --> 03:06:25.703
executes
  JavaScript code when it's 

03:06:25.704 --> 03:06:27.899
loading
 your application. So if you  

03:06:27.900 --> 03:06:30.805
want
 to be indexed well and have a 

03:06:30.806 --> 03:06:32.397
good
 experience in search  engines, 

03:06:32.398 --> 03:06:33.892
it's
 beneficial to be able to serve 

03:06:33.893 --> 03:06:35.893
static
 HTML to the  crawler instead of

03:06:36.010 --> 03:06:38.023
 a
 bunch of JavaScript that it 

03:06:38.024 --> 03:06:38.736
won't
  understand.

03:06:38.737 --> 03:06:42.208
And that also works on social 
networks.

03:06:42.209 --> 03:06:43.715
 If someone takes a  link to 
your

03:06:43.716 --> 03:06:45.705
 application and shares it, the 
scraper

03:06:45.706 --> 03:06:47.011
 from the  social network is 
trying

03:06:47.012 --> 03:06:49.604
 to figure out a good image or 
text

03:06:49.605 --> 03:06:51.000
 ex extract to put in the post. 
It

03:06:51.001 --> 03:06:52.813
 won't know what to do with the 
 JavaScript,

03:06:52.814 --> 03:06:54.110
 but it can understand the 
static

03:06:54.111 --> 03:07:00.000
 HTML that Universal  produces. 
So

03:07:00.001 --> 03:07:01.597
 this experience with Universal,
 rendering

03:07:01.598 --> 03:07:03.609
 on the  server, works really 
well

03:07:03.610 --> 03:07:06.300
 across all browsers, all device
s.

03:07:06.301 --> 03:07:08.409
But if your user happens to be 
using

03:07:08.410 --> 03:07:11.859
 a modern web browser like  
chrome

03:07:11.860 --> 03:07:13.206
 that supports service worker, 
this

03:07:13.207 --> 03:07:14.514
 experience gets even  better. 
You

03:07:14.515 --> 03:07:16.219
 can think of a service worker 
as

03:07:16.220 --> 03:07:18.833
 an HTTP serveer that  runs in 
the

03:07:18.834 --> 03:07:21.025
 browser and handles all the 
requests

03:07:21.026 --> 03:07:23.365
 clientside. So,  in the service
 worker

03:07:23.366 --> 03:07:25.726
 we can cache all of the static 
content

03:07:25.727 --> 03:07:27.209
 for  your application, the 
JavaScript,

03:07:27.210 --> 03:07:29.612
 CSS, HTML that makes it tick.  
Whenever

03:07:29.613 --> 03:07:31.219
 the user opens the app, we're 
not

03:07:31.220 --> 03:07:33.416
 serveing over a network  
connection

03:07:33.417 --> 03:07:36.123
 slowly, we're loading it from 
cache

03:07:36.124 --> 03:07:38.121
 on the phone.
In addition to the static 

03:07:38.122 --> 03:07:39.818
content,
 we cache that application  

03:07:39.819 --> 03:07:42.418
shell
 that was built for you by 

03:07:42.422 --> 03:07:44.623
Universal
 at build time so that  even the

03:07:46.026 --> 03:07:47.924
 very
 first paint running locally 

03:07:47.925 --> 03:07:50.916
happens
 with static  content. And that 

03:07:50.917 --> 03:07:51.741
is
 really fast.

03:07:51.742 --> 03:07:56.417
&gt;&gt; It's crazy fast.
&gt;&gt; So that only gets us so far, 

03:07:56.418 --> 03:07:59.626
right?
 We can get the initial  load. 

03:07:59.627 --> 03:08:01.029
The
 initial first paint working 

03:08:01.030 --> 03:08:03.125
really
 quickly. But Angular  still has

03:08:03.328 --> 03:08:05.022
 to
 download in the background, and

03:08:05.023 --> 03:08:06.729
 your
 application  still has to 

03:08:06.730 --> 03:08:08.428
download
 in the background. And that 

03:08:08.429 --> 03:08:09.817
means
 we can't  be doing things like 

03:08:09.818 --> 03:08:11.922
this,
 where we just load too much  

03:08:11.923 --> 03:08:13.713
JavaScript
 code before the application can

03:08:13.714 --> 03:08:16.618
 start
 up. And so how  do we deal with

03:08:16.815 --> 03:08:18.817
 this
 problem? We break up the 

03:08:18.818 --> 03:08:21.421
application
 and use  the router to load 

03:08:21.422 --> 03:08:23.339
code
 in only when it's needed.

03:08:23.340 --> 03:08:25.316
So when we start up the app, we 
only

03:08:25.317 --> 03:08:28.419
 serve the code needed to  
render

03:08:28.420 --> 03:08:30.226
 the home screen. If you were 
watching

03:08:30.227 --> 03:08:32.574
 the keynote, android  instant 
apps

03:08:32.575 --> 03:08:34.133
 works the same way, only serve
ing

03:08:34.134 --> 03:08:35.836
 the part of the app  needed for
 the

03:08:35.837 --> 03:08:37.630
 first view. As you move around 
in

03:08:37.631 --> 03:08:38.842
 the application,  our router 
will

03:08:38.843 --> 03:08:40.932
 issue a request and load in 
code

03:08:40.933 --> 03:08:42.938
 dynamically to  keep the 
application

03:08:42.939 --> 03:08:47.448
 running. And that, too, gets 
even

03:08:47.449 --> 03:08:49.634
 better if  you have a service 
worker.

03:08:49.635 --> 03:08:51.933
 Not only do we cache the static
  content

03:08:51.934 --> 03:08:54.443
 in the application shell, for a
 small

03:08:54.444 --> 03:08:55.727
 application, we can  load all 
the

03:08:55.728 --> 03:08:57.958
 routes into the service worker 
cache

03:08:57.959 --> 03:08:59.133
 so that they're  available just
 as

03:08:59.134 --> 03:09:01.138
 if the user had downloaded your
 whole

03:09:01.139 --> 03:09:03.544
 app.
For a large application, we plan

03:09:03.932 --> 03:09:05.038
 to
 have some strategies in  the 

03:09:05.039 --> 03:09:07.151
service
 worker to wait for a strong 

03:09:07.152 --> 03:09:08.744
Wi-Fi
 connection and wait  for the 

03:09:08.745 --> 03:09:10.551
user
 to be idle in the application, 

03:09:10.552 --> 03:09:11.846
and
 then start pre- pre-fetching 

03:09:11.847 --> 03:09:13.736
some
 of these things more 

03:09:13.737 --> 03:09:15.737
intelligently.
 And we  think that'll lead to a

03:09:15.950 --> 03:09:17.236
 really
 good experience for all sizes 

03:09:17.237 --> 03:09:19.000
of
  applications, no matter how 

03:09:19.001 --> 03:09:20.967
much
 JavaScript you need.

03:09:20.968 --> 03:09:23.245
&gt;&gt; So, again, I think we've 
solved

03:09:23.246 --> 03:09:25.433
 or maybe not solved, but  made 
progress

03:09:25.434 --> 03:09:27.234
 on getting this application run
ning

03:09:27.235 --> 03:09:29.140
 quick. And,  again, being able 
to

03:09:29.141 --> 03:09:30.642
 progressively load this 
application

03:09:30.643 --> 03:09:33.441
 as we go  along. And data bind
ing

03:09:33.442 --> 03:09:35.963
 is the magic that makes Angular
 tick.

03:09:35.964 --> 03:09:37.737
  It's the big reason we all use
 it.

03:09:37.738 --> 03:09:39.740
 If you haven't, we'll do a  
quick

03:09:39.741 --> 03:09:41.133
 review. This is what it looks 
like

03:09:41.134 --> 03:09:43.737
 in Angular 2. We have a  
template,

03:09:43.738 --> 03:09:45.339
 data in the controller, and 
binding

03:09:45.340 --> 03:09:47.870
 this repo to iCop  to the 
source

03:09:47.871 --> 03:09:50.408
 tag of the image, and doing 
double

03:09:50.409 --> 03:09:52.037
 curly braces and  just doing 
some

03:09:52.038 --> 03:09:54.756
 actual text binding there.
So this is really fast, 

03:09:54.757 --> 03:09:56.139
something
 Angular has done for a long  

03:09:56.140 --> 03:09:58.547
time.
 It's why we all love it, right?

03:09:59.046 --> 03:10:00.547
 And
 I think, too, we've  made 

03:10:00.548 --> 03:10:02.337
changes
 to how the change section works

03:10:02.338 --> 03:10:04.856
.
 In an Angular 1  application, 

03:10:04.857 --> 03:10:06.439
you
 could get into situations where

03:10:06.440 --> 03:10:08.250
 if
 you were  doing estrange things

03:10:08.251 --> 03:10:11.158
,
 strange things, you'd get a 

03:10:11.159 --> 03:10:13.042
cycle.
 If you had an Angular  

03:10:13.043 --> 03:10:15.634
application
 that explodeed and said 

03:10:15.635 --> 03:10:17.542
infinite
 digest psych, cycle, this is  

03:10:17.543 --> 03:10:21.448
why.
 In Angular 2, we wanted to 

03:10:21.449 --> 03:10:23.293
solve
 the problem. Change  connection

03:10:23.294 --> 03:10:26.855
 runs
 from top to bottom -- change 

03:10:26.856 --> 03:10:28.850
detection.
 We start  checking at the top, 

03:10:28.851 --> 03:10:32.349
run
 it down,. Run it once, it's 

03:10:32.350 --> 03:10:33.173
very
 fast.

03:10:33.174 --> 03:10:34.461
But if you have a situation 
where

03:10:34.462 --> 03:10:36.352
 you have a huge list, a  
thousand

03:10:36.353 --> 03:10:39.266
 GitHub issues to get through in
 your app, you can get  into 

03:10:39.267 --> 03:10:41.628
situations
 where you get bogged down. You 

03:10:41.629 --> 03:10:43.348
have
 a lot of  stuff that has to be 

03:10:43.349 --> 03:10:45.751
change
 detected. We put an 

03:10:45.752 --> 03:10:49.458
optimization
 in  here that we called on push

03:10:50.247 --> 03:10:51.959
 change
 detection. And this allows us  

03:10:51.960 --> 03:10:53.864
to,
 in this case, we have an issue 

03:10:53.865 --> 03:10:55.865
list.
 This is going to have a  lot of

03:10:55.960 --> 03:10:57.652
 stuff
 in it. You might be doing other

03:10:57.653 --> 03:10:58.850
 stuff
 in the  application that's not 

03:10:58.851 --> 03:11:00.584
going
 to change that often.

03:11:00.585 --> 03:11:03.959
You don't want to have to repeat
edly

03:11:03.960 --> 03:11:05.349
 check the bindings. We  can 
declare

03:11:05.350 --> 03:11:07.949
 this on push change detection 
strategy.

03:11:07.950 --> 03:11:10.568
 What it means  is that when the
 application

03:11:10.569 --> 03:11:11.742
 does its regular change 
detection

03:11:11.743 --> 03:11:14.048
  cycle, we skip the whole tree 
of

03:11:14.049 --> 03:11:15.956
 components. It gives you a big 
 boost

03:11:15.957 --> 03:11:18.453
 in speed. If you're using 
observables

03:11:18.454 --> 03:11:20.152
 or anything like that that, you
 can

03:11:20.153 --> 03:11:21.965
 then say to the application, 
hey,

03:11:21.966 --> 03:11:23.862
 this thing is  ready to be 
dirty

03:11:23.863 --> 03:11:25.858
 checked. You get a nice 
performance

03:11:25.859 --> 03:11:29.555
 boost from  doing that.
So, bear with me, this gets 

03:11:29.556 --> 03:11:31.668
technical.
 This is my favorite  part of 

03:11:31.669 --> 03:11:34.848
Angular
 2. In Angular 1, we did this 

03:11:34.849 --> 03:11:36.270
idea
 where you took  your template 

03:11:36.271 --> 03:11:38.868
and
 the way data binding works is 

03:11:38.869 --> 03:11:40.668
we
 compile your  templates. We 

03:11:40.669 --> 03:11:42.461
load
 them in, pull them off the 

03:11:42.462 --> 03:11:44.477
server,
 run code in  the browser that 

03:11:44.478 --> 03:11:49.960
parses
 these templates, and turn them 

03:11:49.961 --> 03:11:51.167
into
  introductions  introduction  

03:11:51.168 --> 03:11:53.859
instructions
 to update the DOM. It works 

03:11:53.860 --> 03:11:55.435
really
 well. But we want wanted in 

03:11:55.436 --> 03:11:57.470
Angular
 2 Angular 2 to make sure we did

03:11:57.670 --> 03:11:58.495
 it
 better.

03:11:58.496 --> 03:12:00.665
So in Angular 2 we have a very 
similar

03:12:00.666 --> 03:12:02.163
 idea. We have the idea  where 
we're

03:12:02.164 --> 03:12:04.557
 takeing your templates and 
generateing

03:12:04.558 --> 03:12:06.764
 these  instructions from them, 
but

03:12:06.765 --> 03:12:09.165
 doing it at build time rather 
than

03:12:09.166 --> 03:12:09.957
 in  the browser when your 
application

03:12:09.958 --> 03:12:12.063
 boots up. We do it when you  
build

03:12:12.064 --> 03:12:14.269
 the app with web pack or 
whatever,

03:12:14.270 --> 03:12:16.463
 and we generate very,  very 
efficient

03:12:16.464 --> 03:12:18.464
 code. To bias calls

03:12:29.262 --> 03:12:29.366
 it obviously
 fast, which is a  good term you

03:12:29.367 --> 03:12:29.418
 get
 good benefits. It's fast. You 

03:12:29.419 --> 03:12:29.543
don't
 have to  ship weight to the 

03:12:29.544 --> 03:12:30.003
browser.
Things start up quickly. We got 

03:12:30.004 --> 03:12:31.316
the
 demo working the other day day.

03:12:31.317 --> 03:12:32.932
 This
 is a hello world application. 

03:12:32.933 --> 03:12:36.620
So,
 I believe it's  broughtly com

03:12:36.622 --> 03:12:40.291
pressed,
 an Angular 2 application where 

03:12:40.292 --> 03:12:41.833
we
 have to  ship this extra code, 

03:12:41.834 --> 03:12:45.034
it
 gets down do 118K, which isn't 

03:12:45.035 --> 03:12:47.239
bad.
 If  we can pull out the extra 

03:12:47.240 --> 03:12:49.240
code,
 we can get it down to

03:12:52.566 --> 03:12:56.657
 22kilobytes 22kilobytes,
 which is ridiculously small.

03:12:56.660 --> 03:12:58.660
&gt;&gt; Isn't Angular 1 around

03:13:11.227 --> 03:13:11.326
 50?
&gt;&gt; It's bigger than that.

03:13:11.327 --> 03:13:13.327
&gt;&gt; Rob loves running the

03:13:20.905 --> 03:13:21.117
 offline compiler
 and figureing out how  small he

03:13:21.118 --> 03:13:21.167
 can
 get it.

03:13:21.168 --> 03:13:21.321
&gt;&gt; This is my life.
&gt;&gt; ALEX RICKABAUGH: This is my 

03:13:21.322 --> 03:13:21.479
native
 favorite part. We have  Angular

03:13:21.480 --> 03:13:21.554
 running
 in dynamic mode. We're shipping

03:13:21.555 --> 03:13:21.693
 the
 compiler to  the browseer, 

03:13:21.694 --> 03:13:22.317
downloading
 templates, and running the 

03:13:22.318 --> 03:13:23.780
compilation
  step there. It's not a bad 

03:13:23.781 --> 03:13:25.489
experience
 for developing an  application.

03:13:25.490 --> 03:13:27.885
 You
 can edit code on disk, save it,

03:13:28.307 --> 03:13:31.326
 refresh,
 it  shows up in the browser. 

03:13:31.327 --> 03:13:33.472
It's
 great. But we have this big 

03:13:33.473 --> 03:13:34.685
green
  blob here. I can't see the 

03:13:34.686 --> 03:13:37.887
screen.
 This big green blob is Angular 

03:13:37.888 --> 03:13:40.000
 compileing
 your application, all the work 

03:13:40.001 --> 03:13:42.186
that
 we have to do, all  the 

03:13:42.187 --> 03:13:47.893
execution,
 before your app boots up.

03:13:47.917 --> 03:13:49.695
We finally finish compilation, 
there's

03:13:49.696 --> 03:13:54.498
 a pink ribbon. That  works 
today.

03:13:54.499 --> 03:13:56.401
 With the offline compiler, we 
get

03:13:56.402 --> 03:13:58.608
 rid of the big  green blob. 
We're

03:13:58.609 --> 03:14:00.502
 no longer downloading the 
compiler

03:14:00.503 --> 03:14:01.793
 and running  it. We don't have 
to

03:14:01.794 --> 03:14:03.676
 do that work. When the browser 
loads

03:14:03.677 --> 03:14:05.996
 the  JavaScript that the off
line

03:14:05.997 --> 03:14:08.217
 compiler produces, it runs your
 app

03:14:08.218 --> 03:14:09.601
  from the first line. It just 
works.

03:14:09.602 --> 03:14:11.594
 It's a lot faster. We don't  
even

03:14:11.595 --> 03:14:12.700
 have to do the work in the 
browser

03:14:12.701 --> 03:14:14.304
 of parseing the  JavaScript 
from

03:14:14.305 --> 03:14:17.307
 the compiler.
And that gives you even more 

03:14:17.308 --> 03:14:19.363
speedup.
 So, here the dynamic  

03:14:19.364 --> 03:14:21.208
application
 loads in about 500 milliseconds

03:14:21.209 --> 03:14:23.106
,
 and whatever this  trace was 

03:14:23.107 --> 03:14:25.504
captureing,
 we're booting the static, 

03:14:25.505 --> 03:14:27.708
compileed
 version  in about 250. So it's 

03:14:27.709 --> 03:14:29.709
a
 really good speed improvement.

03:14:33.703 --> 03:14:34.504
&gt;&gt; ROB WORMALD: We've done a 
huge

03:14:34.505 --> 03:14:36.297
 amount of work. We've done  
some

03:14:36.298 --> 03:14:38.507
 really good stuff. One of the 
big

03:14:38.508 --> 03:14:40.500
 things we are exciteed on  the 
team

03:14:40.501 --> 03:14:42.518
 is now everybody else can start
 building

03:14:42.519 --> 03:14:44.800
 stuff on top of  this. The 
reason

03:14:44.801 --> 03:14:46.515
 Angular 1 was such a success is
 we

03:14:46.516 --> 03:14:48.818
 had a huge  community of people
 who

03:14:48.819 --> 03:14:51.808
 built awesome tools. For us, 
it's

03:14:51.809 --> 03:14:53.623
 now the  time to see the cool 
stuff

03:14:53.624 --> 03:14:56.627
 come. If you watched the 
keynote,

03:14:56.628 --> 03:15:01.625
  there was a big deal with Fire
 Base.

03:15:01.626 --> 03:15:03.221
 Whoo. We worked with them  for 
a

03:15:03.222 --> 03:15:05.720
 long time. They've been amazing
 partners.

03:15:05.721 --> 03:15:09.112
If you've used Angular Fire and 
Angular 1,

03:15:09.113 --> 03:15:10.840
 awesome library. We  wanted to 
make

03:15:10.841 --> 03:15:11.922
 sure there was a better 
experience

03:15:11.923 --> 03:15:14.230
 for Angular 2.

03:15:17.412 --> 03:15:20.311
  We have Angular Fire 2,
 it works on their realtime 

03:15:20.312 --> 03:15:22.718
database.
 It's  awesome. It's a single 

03:15:22.719 --> 03:15:24.219
thing
 you drop in your application. 

03:15:24.220 --> 03:15:26.115
This
  is a realtime chat and eight 

03:15:26.116 --> 03:15:28.106
lines
 of code. A very simple thing  

03:15:28.107 --> 03:15:31.016
to
 do. It's amazing, part of the 

03:15:31.017 --> 03:15:32.920
Fire
 Based umbrella.  Authentication

03:15:32.921 --> 03:15:35.718
 is
 super hard for web developers, 

03:15:35.719 --> 03:15:37.727
super
 hard for  everybody, right?

03:15:37.886 --> 03:15:40.651
In Angular Fire, we drop it in. 
Two

03:15:40.652 --> 03:15:42.626
 bits to config, plug in  your 
application,

03:15:42.627 --> 03:15:44.621
 and then it's two lines of code
,

03:15:44.622 --> 03:15:47.397
 log in, there  you go. Super, 
super

03:15:47.398 --> 03:15:49.426
 simple. The other thing that 
comes

03:15:49.427 --> 03:15:52.239
 into Fire  Based is push 
messageing,

03:15:52.240 --> 03:15:54.231
 cloud messageing. So we've 
never

03:15:54.232 --> 03:15:55.937
 been  able to do this in a 
browser

03:15:55.938 --> 03:16:00.032
 before. Native apps can do it. 
We've

03:16:00.033 --> 03:16:01.753
  never had this possibility in 
a

03:16:01.754 --> 03:16:04.034
 web browser before.
Now with service workers, 

03:16:04.035 --> 03:16:05.838
they're
 running in the background  

03:16:05.839 --> 03:16:07.636
constantly
 all the time. If you have 

03:16:07.637 --> 03:16:09.639
access
 to a service worker,  you can 

03:16:09.640 --> 03:16:11.240
tell
 it to register for push 

03:16:11.241 --> 03:16:12.934
notifications.
 Even if the  application is 

03:16:12.935 --> 03:16:15.335
closed,
 you get a push notification. 

03:16:15.336 --> 03:16:17.408
It's
 amazing  stuff. This, we're 

03:16:17.409 --> 03:16:19.442
super,
 super exciteed about. The other

03:16:19.742 --> 03:16:21.467
 one
 that  we're really super excite

03:16:21.468 --> 03:16:25.367
ed,
 and they talked about this, Ion

03:16:25.382 --> 03:16:26.748
ic
 has  been an amazing partner. 

03:16:26.749 --> 03:16:30.101
Hundreds
 of of thousands of Ionic apps 

03:16:30.102 --> 03:16:30.766
out
  there.

03:16:30.767 --> 03:16:32.754
They do a really good job of 
doing

03:16:32.755 --> 03:16:35.536
 visuals, apps in general.  They
 announceed

03:16:35.537 --> 03:16:37.490
 that they're going to support 
progressive

03:16:37.491 --> 03:16:38.547
 web apps apps. We've been 
working

03:16:38.548 --> 03:16:40.544
 with them for a little while on
 building

03:16:40.545 --> 03:16:43.852
  Ionic progressive web apps. 
That's

03:16:43.853 --> 03:16:46.365
 going to be super, super  
exciting.

03:16:46.366 --> 03:16:47.944
 Stoked about that. And this is 
one

03:16:47.945 --> 03:16:49.553
 thing that if you're  a 
JavaScript

03:16:49.554 --> 03:16:51.550
 developer, this is mind-blowing
.

03:16:51.551 --> 03:16:53.355
And if you write code in any 
other

03:16:53.356 --> 03:16:54.961
 language, you're like,  why're 
you

03:16:54.962 --> 03:16:56.445
 talking about this. But, if 
you're

03:16:56.446 --> 03:16:59.861
 a JavaScript  developer, I want
 to show this to you. This is 

03:16:59.862 --> 03:17:03.264
Angular
 2. We use  type script. Now we 

03:17:03.266 --> 03:17:05.054
have
 code that understands itself 

03:17:05.055 --> 03:17:07.294
effectively effectively.
 This is me getting code 

03:17:07.295 --> 03:17:12.359
appreciation
 in my completion in my IDE. I 

03:17:12.360 --> 03:17:14.257
was
  like, I'm a web developer, I 

03:17:14.258 --> 03:17:16.358
don't
 get this. When I screw up, I  

03:17:16.359 --> 03:17:17.974
get
 warnings before you compile 

03:17:17.975 --> 03:17:19.868
your
 code or run it, it's like  you 

03:17:19.869 --> 03:17:21.276
did
 something wrong. This is a big 

03:17:21.277 --> 03:17:24.680
deal.
If you're an Android developer, 

03:17:24.681 --> 03:17:26.573
you're
 like why're you talking  about 

03:17:26.574 --> 03:17:27.969
this?
 Because we don't get this. We 

03:17:27.970 --> 03:17:29.875
don't
 get to do this.  This, I think,

03:17:29.876 --> 03:17:31.974
 is
 super, super amazing. This is 

03:17:31.975 --> 03:17:33.401
coming
 for us.

03:17:33.402 --> 03:17:35.992
&gt;&gt; The offline compiler 
generates

03:17:35.993 --> 03:17:37.691
 type script. You will get  
error

03:17:37.692 --> 03:17:40.082
 messages saying you misspelled 
something

03:17:40.083 --> 03:17:41.795
 in this data bind binding, it 
doesn't

03:17:41.796 --> 03:17:44.378
 exist on your component.
&gt;&gt; I spent 30 minutes going, 

03:17:44.379 --> 03:17:46.484
what
 have I broken in the  compiler?

03:17:46.678 --> 03:17:48.478
 It
 was telling me, no, there's 

03:17:48.479 --> 03:17:50.589
something
 wrong in your  template. I had 

03:17:50.590 --> 03:17:52.380
no
 idea. This has never happened 

03:17:52.381 --> 03:17:54.085
that
 your  template is checked and 

03:17:54.086 --> 03:17:56.788
it
 said, you're wrong, do that. 

03:17:56.789 --> 03:17:58.584
That's
  coming soon. Very, very cool.

03:17:58.585 --> 03:18:01.884
&gt;&gt; You're write Angular 
components,

03:18:01.885 --> 03:18:03.079
 and that works really well 
well.

03:18:03.080 --> 03:18:05.540
 But there's this thing called 
web

03:18:05.541 --> 03:18:06.986
 components, and it's  basically
 a

03:18:06.987 --> 03:18:08.690
 custom DOM element that you 
make

03:18:08.691 --> 03:18:11.486
 and attach some  behavior to. 
And

03:18:11.487 --> 03:18:13.189
 because they're normal DOM 
elements

03:18:13.190 --> 03:18:14.180
 and Angular  works well with 
all

03:18:14.181 --> 03:18:15.986
 DOM elements, they fit really 
well

03:18:15.987 --> 03:18:17.709
 into an  Angular application. 
So

03:18:17.710 --> 03:18:20.896
 this is a YouTube search page 
we've

03:18:20.897 --> 03:18:22.492
  written. It has an input where
 we

03:18:22.493 --> 03:18:24.189
 want to type for something, and
  a

03:18:24.190 --> 03:18:26.597
 list of search results, and a 
YouTube

03:18:26.598 --> 03:18:28.895
 player.
And the player is not an Angular

03:18:29.105 --> 03:18:30.888
 component.
 It's a web  component that 

03:18:30.889 --> 03:18:32.397
someone
 has written that takes a video 

03:18:32.398 --> 03:18:35.993
ID.
 We  Biden the ID bind  the ID 

03:18:35.994 --> 03:18:37.592
to
 the one that comes out of the 

03:18:37.593 --> 03:18:39.593
search
 and it works. It's  awesome.

03:18:42.104 --> 03:18:44.104
 So we've
 talked about type script, about

03:18:44.517 --> 03:18:46.008
 the
 compiler,  and in general, the 

03:18:46.009 --> 03:18:48.009
JavaScript
 ecosystem is getting complicate

03:18:48.506 --> 03:18:50.993
ed complicated.
 Angular works with ES6 modules 

03:18:50.994 --> 03:18:52.954
now.
 There's all  kinds of 

03:18:52.955 --> 03:18:55.599
compilation
 steps uh you have to do. We 

03:18:55.600 --> 03:18:56.999
wanted
 to build  something to get that

03:18:57.000 --> 03:18:58.910
 out
 of your way and let you focus 

03:18:58.911 --> 03:19:00.635
on
  building applications.

03:19:00.636 --> 03:19:02.897
That's what our CLI is designed 
to

03:19:02.898 --> 03:19:05.199
 do. It lets you focus on  your 
app

03:19:05.200 --> 03:19:06.998
 and we take care of the tooling
.

03:19:06.999 --> 03:19:08.496
 To start a new project  with 
the

03:19:08.497 --> 03:19:11.894
 CLI, you MPM install it. We're 
used

03:19:11.895 --> 03:19:14.096
 to doing stuff like  this. You 
say

03:19:14.097 --> 03:19:16.899
 NG new my web app. It will set 
up

03:19:16.900 --> 03:19:19.896
 an application  with a build 
script.

03:19:19.897 --> 03:19:22.207
 When you seed in and say NG 
serve

03:19:22.208 --> 03:19:23.616
 it'll  build your application, 
it'll

03:19:23.617 --> 03:19:26.608
 start up a web browser, set up 
a

03:19:26.609 --> 03:19:28.016
  web server, open the app in 
the

03:19:28.017 --> 03:19:29.801
 browser, and actually watch the
  file

03:19:29.802 --> 03:19:31.709
 system. So when you edit code 
in

03:19:31.710 --> 03:19:34.015
 your IDE and save it it'll  re
fresh

03:19:34.016 --> 03:19:36.203
 the browser and start executing
.

03:19:36.204 --> 03:19:38.104
So if you want to start doing 
mobile

03:19:38.105 --> 03:19:39.706
 app development with  Angular, 
we've

03:19:39.707 --> 03:19:41.608
 added this dash dash mobile 
flag

03:19:41.609 --> 03:19:45.521
 to the CLI. When  you say NG 
new

03:19:45.522 --> 03:19:47.807
 dash dash mobile we set up the 
same

03:19:47.808 --> 03:19:49.732
 Angular  application scaffold 
and

03:19:49.733 --> 03:19:51.819
 add a web app manifest so you 
get

03:19:51.820 --> 03:19:54.207
 a nice  install to home screen 
prompt

03:19:54.208 --> 03:19:56.304
 in Chrome. I think we add meta 
tags

03:19:56.305 --> 03:19:58.122
  for safari as well. If you 
want

03:19:58.123 --> 03:20:00.615
 to, it'll set up a service work
er

03:20:00.616 --> 03:20:02.912
  so you can do do -- your 
application

03:20:02.913 --> 03:20:04.725
 will be reliable to work off 
offline

03:20:04.726 --> 03:20:08.408
 or online.
It's integrateed with the build 

03:20:08.409 --> 03:20:10.329
process
 to figure out the  static 

03:20:10.330 --> 03:20:12.408
information,
 it'll be cacheed, we set up the

03:20:12.729 --> 03:20:15.116
 application
  shell for you with Universal 

03:20:15.117 --> 03:20:16.719
so
 you can use the shell, render, 

03:20:16.720 --> 03:20:19.417
 shell,
 no render, and it'll generate 

03:20:19.418 --> 03:20:21.911
an
 application shell for you you. 

03:20:21.912 --> 03:20:23.912
So
 our CLI is not only designed to

03:20:24.012 --> 03:20:25.844
 help
 you start up a  project, but 

03:20:25.845 --> 03:20:27.424
also
 to live with you as you go 

03:20:27.425 --> 03:20:29.019
through
 the  development process. It'll

03:20:29.020 --> 03:20:30.728
 create
 your project, install  

03:20:30.729 --> 03:20:32.726
dependencies,
 help you scaffold your 

03:20:32.727 --> 03:20:34.727
application.
 Every time  you're creating new

03:20:34.731 --> 03:20:36.610
 components,
 or creating new routes or  

03:20:36.611 --> 03:20:39.041
something
 like that, it'll set up the 

03:20:39.042 --> 03:20:40.239
boiler
 plate for you.

03:20:40.240 --> 03:20:42.473
It'll help you at build time run
 the

03:20:42.474 --> 03:20:43.812
 compilation process,  generate 
service

03:20:43.813 --> 03:20:46.620
 workers and manifests, helps 
you

03:20:46.621 --> 03:20:49.019
 run tests, do C CSS processing.
 When

03:20:49.020 --> 03:20:51.116
 you're ready to deploy to 
something

03:20:51.117 --> 03:20:53.713
 like  Fire Based hosting, CLI 
has

03:20:53.714 --> 03:20:55.420
 integration for that. It lives 
with

03:20:55.421 --> 03:20:59.432
  you throughout the development
 process.

03:20:59.433 --> 03:21:02.040
&gt;&gt; So this is the thing that is 
very,

03:21:02.041 --> 03:21:06.124
 kind of, interesting and and, 
kind of, crazy to eplain. I love

03:21:08.731 --> 03:21:10.739
explain.
 We've optimizeed everything we 

03:21:10.740 --> 03:21:12.639
can
  in Angular 2. But we are still

03:21:12.640 --> 03:21:14.859
 kind
 of at this disadvantage to  

03:21:14.860 --> 03:21:15.941
native
 apps. You know, they have the 

03:21:15.942 --> 03:21:17.937
ability
 to take advantage of  the whole

03:21:17.938 --> 03:21:19.831
 application,
 kind of, power. They've got 

03:21:19.832 --> 03:21:22.625
multiple
  processors in mobile devices 

03:21:22.626 --> 03:21:25.167
now.
 As web developers, we're Yoo  

03:21:25.168 --> 03:21:28.723
you
 have had used  to working in 

03:21:28.724 --> 03:21:30.628
one
 thread, shareing it with all 

03:21:30.629 --> 03:21:32.128
the
 work the  browser has to do, 

03:21:32.129 --> 03:21:35.146
pointing,
 point painting, rendering. The 

03:21:35.147 --> 03:21:36.762
idea
 of multi-thread multi-threaded 

03:21:36.763 --> 03:21:38.740
web
 apps is crazy. We've had web 

03:21:38.741 --> 03:21:40.758
workers
 for a  long, long time.

03:21:40.800 --> 03:21:42.639
But you've probably never used 
them.

03:21:42.640 --> 03:21:45.091
 Some people do, but, Jr.,  very
 few

03:21:45.092 --> 03:21:46.149
 people take advantage of them 
in

03:21:46.150 --> 03:21:47.653
 their applications. And  this 
is

03:21:47.654 --> 03:21:48.751
 because they're really, really 
hard

03:21:48.752 --> 03:21:49.766
 to work with. You  have to 
start

03:21:49.767 --> 03:21:52.951
 up a script in the background. 
And

03:21:52.952 --> 03:21:54.244
 then you're re remote control
ling

03:21:54.245 --> 03:21:56.653
 your application over this tiny
 pipe.

03:21:56.654 --> 03:21:59.059
 It's  hard to work with. Nobody
 uses

03:21:59.060 --> 03:22:00.247
 them. It's a shame because we 
have

03:22:00.248 --> 03:22:03.042
  all this power waiting to be 
unlocked.

03:22:03.043 --> 03:22:06.779
So, again in, in Angular 2 we 
wanted

03:22:06.780 --> 03:22:08.780
 to taking advantage of this

03:22:12.762 --> 03:22:12.866
.  The
 same tech that lets us do rend

03:22:12.867 --> 03:22:13.954
ering
 and application shell  actually

03:22:13.955 --> 03:22:15.355
 allows
 us to do something really 

03:22:15.356 --> 03:22:17.051
interesting.
 So we can  take your Angular 

03:22:17.052 --> 03:22:19.452
application,
 we can move the whole thing, 

03:22:19.453 --> 03:22:21.345
all
  of your code in Angular, into 

03:22:21.346 --> 03:22:24.360
a
 web worker, and then we run a  

03:22:24.361 --> 03:22:28.391
very,
 very light weight rendering 

03:22:28.392 --> 03:22:30.349
thread.
 Your main DOM thread  has a 

03:22:30.350 --> 03:22:32.876
tiny
 listener that talks to the DOM 

03:22:32.877 --> 03:22:34.563
and
 listens to eventses eventses, 

03:22:34.564 --> 03:22:36.772
events,
  and transfers everything to 

03:22:36.773 --> 03:22:38.773
Angular
 running, effective

03:22:42.519 --> 03:22:42.634
ly, in the  background.
Rather than the life cycle look

03:22:42.635 --> 03:22:43.766
ing
 like this, where the code  is 

03:22:43.767 --> 03:22:45.465
doing
 work, shareing, and competing 

03:22:45.466 --> 03:22:47.466
for
 resources with the rest  of the

03:22:47.583 --> 03:22:49.086
 browser,
 we can split it up. This means 

03:22:49.087 --> 03:22:50.665
your
 application  gets to work free 

03:22:50.666 --> 03:22:52.170
form
 in the background and the main 

03:22:52.171 --> 03:22:54.168
UI
 thread  is kept really, really 

03:22:54.169 --> 03:22:55.781
clean
 just for render, paints, and 

03:22:55.782 --> 03:22:57.782
the
  things the browser needs to do

03:22:58.071 --> 03:22:59.771
.
 This gives you incredible  

03:22:59.772 --> 03:23:01.386
performance.
 This is experimental.

03:23:01.387 --> 03:23:03.165
This may not be right for every 
app,

03:23:03.166 --> 03:23:05.279
 but really, I think the  point 
of

03:23:05.280 --> 03:23:07.774
 this for us is that we want to 
be

03:23:07.775 --> 03:23:09.727
 sure that for the next  five or
 ten

03:23:09.728 --> 03:23:11.368
 years, whatever comes down the 
pipeline

03:23:11.369 --> 03:23:12.573
 in the  browser, we're flexible
.

03:23:12.574 --> 03:23:14.266
 And I think that this is the 
beginning

03:23:14.267 --> 03:23:15.964
  of something very, very 
interesting

03:23:15.965 --> 03:23:18.872
 from Angular. So this is kind  
of

03:23:18.873 --> 03:23:20.578
 close to the end of our talk, 
but

03:23:20.579 --> 03:23:21.871
 the point we want to get  
across

03:23:21.872 --> 03:23:24.369
 is that this is really just the
 beginning

03:23:24.370 --> 03:23:26.973
 for Angular 2.
We're just coming into our re

03:23:26.974 --> 03:23:29.171
lease
 candidate. Go try it out.  We 

03:23:29.172 --> 03:23:31.073
want
 to see what you guys build with

03:23:31.074 --> 03:23:32.482
 it.
 I think it's going to  be 

03:23:32.483 --> 03:23:34.073
really
 exciting. The whole progressive

03:23:34.074 --> 03:23:35.676
 idea,
 there's been a  lot of talk 

03:23:35.677 --> 03:23:37.280
about
 it. It's a really, really 

03:23:37.281 --> 03:23:39.177
amazing
 concept for  the web. We want 

03:23:39.178 --> 03:23:40.685
to
 make that as easy as possible 

03:23:40.686 --> 03:23:42.004
for
 everybody  to get started.

03:23:42.005 --> 03:23:43.686
&gt;&gt; One of the things I've heard 
people

03:23:43.687 --> 03:23:45.689
 say is progressive web  apps 
are

03:23:45.690 --> 03:23:47.584
 really good normal apps that 
get

03:23:47.585 --> 03:23:49.391
 super powers and  browsers that
 have

03:23:49.392 --> 03:23:50.989
 all this functionality. Angular
 is

03:23:50.990 --> 03:23:53.976
 the super  heroic JavaScript 
framework.

03:23:53.977 --> 03:23:55.504
 We think they go perfect 
together.

03:23:55.505 --> 03:23:57.778
&gt;&gt; Cool. So, if you want to 
check

03:23:57.779 --> 03:23:59.488
 out our code, issue zero is  
open

03:23:59.489 --> 03:24:03.680
 source. We have the GitHub repo
 here. If you want to learn  

03:24:03.681 --> 03:24:06.484
more
 about the service worker and 

03:24:06.485 --> 03:24:09.801
application
 shell, the content  is here. 

03:24:09.802 --> 03:24:11.583
And
 tomorrow there is a talk by 

03:24:11.584 --> 03:24:16.690
jewels
 jewel Jules, at 4:00 p.m.  

03:24:16.691 --> 03:24:18.691
tomorrow.
 So, make sure to check it out.

03:24:19.888 --> 03:24:21.888
(Applause)

03:24:23.383 --> 03:24:25.383
(Cheering and applause)

03:24:28.282 --> 03:24:30.184
&gt;&gt; And we'll hang around for 
questions

03:24:30.185 --> 03:24:32.135
 if anybody has any.
&gt;&gt; Yeah,.

03:24:32.136 --> 03:24:36.995
&gt;&gt; So feel free to step up.
&gt;&gt; Questions? No questions?

03:24:42.982 --> 03:24:45.485
&gt;&gt; Not a single question. No one
 even

03:24:45.486 --> 03:24:47.097
 wants to ask when  Angular 2 is
 going

03:24:47.098 --> 03:24:48.559
 to be released?
(Laughter)

03:24:48.560 --> 03:24:50.592
&gt;&gt; Somebody's got to ask that 
question,

03:24:50.593 --> 03:24:53.110
 come on.
&gt;&gt; Shoot.

03:24:53.132 --> 03:24:55.311
&gt;&gt; When will Angular 2 be 
released?

03:24:55.312 --> 03:24:58.211
&gt;&gt; Good question. Soon.
(Laughter)

03:24:58.234 --> 03:25:00.601
&gt;&gt; AUDIENCE: Good answer.
&gt;&gt; PRESENTER: So the real answer

03:25:00.902 --> 03:25:02.893
 to
 that question, I should  talk 

03:25:02.894 --> 03:25:04.304
about
 this while I'm in front of a 

03:25:04.305 --> 03:25:05.753
bunch
 of Angular  developers. The 

03:25:05.754 --> 03:25:07.939
core
 of it, I think we're pretty 

03:25:07.940 --> 03:25:09.811
stoked
 that it's  fully baked. I think

03:25:09.812 --> 03:25:11.812
 the
 router we're pretty sure is not

03:25:11.826 --> 03:25:12.807
 fully
  baked. I don't think anybody 

03:25:12.808 --> 03:25:14.104
in
 this room is going to argue 

03:25:14.105 --> 03:25:15.802
with
  me on that. Angular 2 Angular 

03:25:15.803 --> 03:25:18.312
2
 core is ready to go. We would 

03:25:18.313 --> 03:25:19.816
probably
  almost ship it tomorrow, but 

03:25:19.817 --> 03:25:21.011
we
 want to make sure that the 

03:25:21.012 --> 03:25:22.119
router
  and everything is going to 

03:25:22.120 --> 03:25:24.008
work
 really, really well with it.

03:25:24.009 --> 03:25:25.813
So everybody else on the Angular
 team

03:25:25.814 --> 03:25:28.416
 is in the office right  now 
writing

03:25:28.417 --> 03:25:29.605
 the router. That's why they're 
not

03:25:29.606 --> 03:25:31.507
 on stage with us  here. As soon
 as

03:25:31.508 --> 03:25:33.019
 we're happy that that's ready 
to

03:25:33.020 --> 03:25:35.207
 go, it'll be  out to go. But 
the

03:25:35.208 --> 03:25:36.800
 core itself is stable, if you 
want

03:25:36.801 --> 03:25:38.112
 to start  writing components 
and

03:25:38.113 --> 03:25:39.816
 all the stuff we've talked 
about,

03:25:39.817 --> 03:25:41.817
 it's  good to go.

03:25:45.208 --> 03:25:47.209
 Do you want to
 use the mic? I'm sorry. There's

03:25:47.405 --> 03:25:49.317
 a
  whole queue of people waiting,

03:25:49.318 --> 03:25:52.423
 actually.
 But ask yours quickly. I  

03:25:52.424 --> 03:25:54.613
apologize.
 We're really bad at this. Sorry

03:25:54.929 --> 03:25:59.018
.
&gt;&gt; AUDIENCE: Is it 22 KBs?

03:25:59.040 --> 03:26:00.624
&gt;&gt; PRESENTER: That's a real 
number.

03:26:00.625 --> 03:26:02.816
&gt;&gt; AUDIENCE: So then it's much 
smaller

03:26:02.817 --> 03:26:05.415
 than React, as well. So  how 
does

03:26:05.416 --> 03:26:08.212
 it handle all the DOM structure
?

03:26:08.213 --> 03:26:10.229
 How does it get to know  that 
something

03:26:10.230 --> 03:26:13.023
 has changed if it does not -- 
does

03:26:13.024 --> 03:26:16.520
 the architect  architect --
&gt;&gt; PRESENTER: Sure. There's a 

03:26:16.521 --> 03:26:18.315
couple
 ways it works. The idea  of 

03:26:18.316 --> 03:26:20.651
this
 tiny number is that Angular is 

03:26:20.652 --> 03:26:22.736
modular,
 for a start. Most  of the code 

03:26:22.737 --> 03:26:24.642
that's
 in Angular itself is this idea 

03:26:24.643 --> 03:26:26.332
of
 takeing code  and generating 

03:26:26.333 --> 03:26:28.956
DOM
 from it. It's all the mechanism

03:26:29.339 --> 03:26:32.350
 that
 has to  parse your templates. 

03:26:32.351 --> 03:26:35.181
Hello
 world at 22K means we've 

03:26:35.182 --> 03:26:36.252
stripped
 out  everything that's not 

03:26:36.253 --> 03:26:38.544
involved
 in basically just, like, 

03:26:38.545 --> 03:26:40.545
getting,
  sort of, data onto the DOM.

03:26:40.861 --> 03:26:42.743
And things like zone -- zone is 
what

03:26:42.744 --> 03:26:44.752
 listens to events and  triggers
 this

03:26:44.753 --> 03:26:46.041
 step. The way you can think 
about

03:26:46.042 --> 03:26:49.046
 it is that in  dynamic mode, we
 generate

03:26:49.047 --> 03:26:51.046
 or have all this code around 
that

03:26:51.047 --> 03:26:54.554
 does  the translation. In 
static

03:26:54.555 --> 03:26:56.243
 mode, we drop the code and 
generate

03:26:56.244 --> 03:26:57.845
  the code we need to do the 
updates

03:26:57.846 --> 03:26:59.339
 for the specific views. Does  
that

03:26:59.340 --> 03:27:01.260
 answer your question? You're 
shakeing

03:27:01.261 --> 03:27:03.755
 your head like no.
&gt;&gt; AUDIENCE: So the time you 

03:27:03.756 --> 03:27:05.645
were
 showing, that does not come  at

03:27:05.646 --> 03:27:07.957
 the
 end of the second time? The 

03:27:07.958 --> 03:27:11.650
content
 loaded fully. It'll  still, 

03:27:11.651 --> 03:27:14.053
like,
 process because it's got some 

03:27:14.054 --> 03:27:16.452
things
 to get, will it  be showing? Is

03:27:16.843 --> 03:27:18.854
 the
 content fully loaded at that 

03:27:18.855 --> 03:27:19.775
point
 in time?

03:27:19.776 --> 03:27:22.741
&gt;&gt; PRESENTER: Yes.
&gt;&gt; AUDIENCE: It is? So how does 

03:27:22.742 --> 03:27:23.676
it
 get the stuff?

03:27:23.677 --> 03:27:25.553
&gt;&gt; PRESENTER: Oh. So the idea is
,

03:27:25.554 --> 03:27:27.945
 when we run this compilation  
pipeline,

03:27:27.946 --> 03:27:30.353
 we do something called tree-
shakeing.

03:27:30.354 --> 03:27:33.147
 And what that does  is look at 
what

03:27:33.148 --> 03:27:34.859
 code is used in the application
 and

03:27:34.860 --> 03:27:36.549
 what code is  not. So Angular 
has

03:27:36.550 --> 03:27:38.455
 a lot of features in it. You 
probably,

03:27:38.456 --> 03:27:40.446
 in a  single application, will 
not

03:27:40.447 --> 03:27:42.257
 manage to use all of them. We 
want

03:27:42.258 --> 03:27:44.522
  to make sure that we're not 
sending

03:27:44.523 --> 03:27:45.358
 code to the browser that's  
never

03:27:45.359 --> 03:27:46.987
 going to run. So that's why 
that

03:27:46.988 --> 03:27:49.152
 number is so small. We've  
taken

03:27:49.153 --> 03:27:53.257
 out the cop compiler, we did 
compilation

03:27:53.258 --> 03:27:55.156
 already. You're not  using 
forums,

03:27:55.157 --> 03:27:57.761
 we've taken out HTTP and router
 and

03:27:57.762 --> 03:28:00.458
 all that.
That's why the number is really 

03:28:00.459 --> 03:28:02.068
small.
 It's only the code  that's need

03:28:02.069 --> 03:28:04.569
ed
 to get that done. As you build 

03:28:04.570 --> 03:28:06.764
more
 complicateed  apps, you'll 

03:28:06.765 --> 03:28:08.354
touch
 more of Angular, we'll bring 

03:28:08.355 --> 03:28:09.961
more
 code in.  You're only paying 

03:28:09.962 --> 03:28:12.458
the
 cost of the bytes that you're 

03:28:12.459 --> 03:28:13.789
actually
  going to use.

03:28:13.790 --> 03:28:15.760
&gt;&gt; If that didn't answer your 
question,

03:28:15.761 --> 03:28:17.669
 find us after and  we'll talk 
about

03:28:17.670 --> 03:28:19.370
 it, for sure.
&gt;&gt; AUDIENCE: Did I understand 

03:28:19.371 --> 03:28:21.266
you
 correctly regarding the  multi-

03:28:21.267 --> 03:28:22.978
threading,
 you were saying it's similar to

03:28:22.979 --> 03:28:24.963
 the
 app frame framework, the 

03:28:24.964 --> 03:28:26.489
application,
 or is it different?

03:28:26.490 --> 03:28:28.759
&gt;&gt; PRESENTER: I mean, it is your
 same

03:28:28.760 --> 03:28:30.961
 Angular application, but  we 
started

03:28:30.962 --> 03:28:34.361
 in a slightly different manner.
&gt;&gt; AUDIENCE: How you set up the 

03:28:34.362 --> 03:28:35.862
time
 slices for the threads,  and 

03:28:35.863 --> 03:28:37.357
the
 context switching, is it 

03:28:37.358 --> 03:28:38.773
similar
 to the context switching  in 

03:28:38.774 --> 03:28:39.690
the
 application?

03:28:39.691 --> 03:28:40.862
&gt;&gt; PRESENTER: There is some 
context

03:28:40.863 --> 03:28:43.775
 switching that goes on.
&gt;&gt; AUDIENCE: How do you set up 

03:28:43.776 --> 03:28:45.519
the
 timers to --

03:28:45.520 --> 03:28:48.173
&gt;&gt; PRESENTER: Again, so this is 
not --

03:28:48.174 --> 03:28:50.670
 the analogy to the way  a 
proper

03:28:50.671 --> 03:28:51.562
 multi-thread environment, it's 
not

03:28:51.563 --> 03:28:53.288
 exactly the same.  We're still 
doing

03:28:53.289 --> 03:28:55.289
 this message passing between 
two

03:28:57.877 --> 03:29:00.335
 queuetion, but but, it's dis
patching

03:29:00.336 --> 03:29:02.969
 render instructions out and get
ting

03:29:02.970 --> 03:29:08.781
 it back  in. We're not sink 
synchronizeing

03:29:08.782 --> 03:29:11.285
 application work.
&gt;&gt; Your Angular app is running 

03:29:11.286 --> 03:29:12.960
in
 the web worker, doing change  

03:29:12.961 --> 03:29:15.687
connection
  detection, making requests, 

03:29:15.688 --> 03:29:18.280
running
 your normal application.

03:29:18.303 --> 03:29:20.267
&gt;&gt; AUDIENCE: This is not 
something

03:29:20.268 --> 03:29:23.278
 the developer can tune?
&gt;&gt; PRESENTER: No. It's sort of 

03:29:23.279 --> 03:29:25.972
like,
 the entire application --  

03:29:25.973 --> 03:29:27.886
instead
 of booting it in the main UI 

03:29:27.887 --> 03:29:29.880
thread,
 you boot it in the  background.

03:29:29.881 --> 03:29:31.596
&gt;&gt; AUDIENCE: Those who code size
s

03:29:31.597 --> 03:29:33.674
 you showed, one of them was  22
K,

03:29:33.675 --> 03:29:36.769
 the other one was 116. The 22K,
 that's

03:29:36.770 --> 03:29:38.879
 the complete size of  the image
,

03:29:38.880 --> 03:29:41.883
 or as you scroll down or click,
 then

03:29:41.884 --> 03:29:44.674
 more corrode code will be  
downloaded?

03:29:44.675 --> 03:29:47.035
&gt;&gt; PRESENTER: It's like an 
Angular

03:29:47.036 --> 03:29:49.174
 binary doing the bare  minimum.
 Take

03:29:49.175 --> 03:29:50.876
 some data and render it to the 
screen.

03:29:50.877 --> 03:29:52.376
 That's the  point. It's an 
Angular

03:29:52.377 --> 03:29:54.508
 application that is doing the 
my

03:29:54.509 --> 03:29:56.975
 malthing the minimal of  what 
Angular

03:29:56.976 --> 03:29:58.780
 does. It's a complete 
application.

03:29:58.781 --> 03:30:00.673
 There's no other  code to be 
loaded.

03:30:00.674 --> 03:30:02.990
 That's the whole package.
&gt;&gt; AUDIENCE: Thank you.

03:30:03.013 --> 03:30:05.981
&gt;&gt; PRESENTER: Yeah,.
&gt;&gt; AUDIENCE: I also had a 

03:30:05.982 --> 03:30:08.476
question
 about the multi-threaded  thing

03:30:08.675 --> 03:30:10.200
 you
 talked about at the end there.

03:30:10.201 --> 03:30:12.989
&gt;&gt; PRESENTER: Sure.
&gt;&gt; AUDIENCE: What is the 

03:30:12.990 --> 03:30:15.323
advantage
 to having a separate render  

03:30:15.324 --> 03:30:17.288
thread
 on the main thread and running 

03:30:17.289 --> 03:30:19.378
the
 application in the web  worker?

03:30:19.586 --> 03:30:20.980
 You're
 still running your whole 

03:30:20.981 --> 03:30:23.080
application
 from a single  thread, still 

03:30:23.081 --> 03:30:24.585
push
 updates to the renderer in the 

03:30:24.586 --> 03:30:25.914
same
 amount of  time.

03:30:25.915 --> 03:30:26.994
&gt;&gt; PRESENTER: This is a good 
question.

03:30:26.995 --> 03:30:29.989
 There's a cool demo you  should
 watch.

03:30:29.990 --> 03:30:31.802
 I'll give you the link after 
this.

03:30:31.803 --> 03:30:33.093
 You still have  the same amount
 of

03:30:33.094 --> 03:30:34.794
 work to do. We're not changing 
that

03:30:34.795 --> 03:30:36.410
 problem.  In a web application,
 when

03:30:36.411 --> 03:30:39.389
 you do something like, lets say
 apply

03:30:39.390 --> 03:30:43.291
 an image  filter, like on 
Instagram,

03:30:43.292 --> 03:30:45.498
 if you do that work in a single
 thread thread,

03:30:45.499 --> 03:30:47.700
 that work's going to run but 
everything

03:30:47.701 --> 03:30:50.705
 else is going to  stop.
You're not going to be able to 

03:30:50.706 --> 03:30:53.501
scroll
 the page. Everything  freezes 

03:30:53.502 --> 03:30:54.450
while
 that work happens.

03:30:54.451 --> 03:30:57.707
&gt;&gt; You click the button and it 
doesn't

03:30:57.708 --> 03:30:59.023
 release until the work  is done
.

03:30:59.024 --> 03:31:00.414
 The browser is blocked waiting 
on

03:31:00.415 --> 03:31:03.513
 your application.
&gt;&gt; So what your user sees is 

03:31:03.514 --> 03:31:05.014
this
 horrible stoppage. The  

03:31:05.015 --> 03:31:06.706
important
 thing with the progressive idea

03:31:06.707 --> 03:31:09.525
 is
 that we never want  the browser

03:31:09.550 --> 03:31:12.107
 to
 go janky, we never want the 

03:31:12.108 --> 03:31:13.447
user
 experience to  suffer. 

03:31:13.448 --> 03:31:15.516
Splitting
 these two things up allows us 

03:31:15.517 --> 03:31:17.118
--
 they could  keep scrolling the 

03:31:17.119 --> 03:31:18.614
page
 while this work is turning in 

03:31:18.615 --> 03:31:20.306
the
  background. That's the general

03:31:20.307 --> 03:31:22.521
 theory
 of this. Does that make  sense?

03:31:22.718 --> 03:31:24.718
&gt;&gt; AUDIENCE: Thank you.
&gt;&gt; PRESENTER: Cool.

03:31:24.765 --> 03:31:26.340
&gt;&gt; AUDIENCE: You know this guy, 
he's

03:31:26.341 --> 03:31:28.135
 awesome.
&gt;&gt; PRESENTER: A little bit.

03:31:28.136 --> 03:31:30.220
&gt;&gt; AUDIENCE: I was saying that I
 am

03:31:30.221 --> 03:31:31.720
 going to be able to write  a 
single

03:31:31.721 --> 03:31:35.128
 code base with Ionic, push to 
progressive,

03:31:35.129 --> 03:31:38.113
 Android and  iOS eventually?
&gt;&gt; PRESENTER: That's the general

03:31:38.312 --> 03:31:40.922
 theory.
 Adam is nodding his  head yes, 

03:31:40.923 --> 03:31:43.018
he's
 from the Ionic team, you should

03:31:43.212 --> 03:31:45.208
 talk
 to him.  Actually, to get into 

03:31:45.209 --> 03:31:47.510
a
 bigger discussion, the coolest 

03:31:47.511 --> 03:31:49.024
thing
  about Angular's dependency 

03:31:49.025 --> 03:31:50.420
injection
 is that you can write an  

03:31:50.421 --> 03:31:51.921
application
 and think about the top layer 

03:31:51.922 --> 03:31:53.919
of
 it. For things like  native 

03:31:53.920 --> 03:31:56.317
storage
 and database and whatever, use 

03:31:56.318 --> 03:31:59.010
DI
 to swap out  these pieces. 90% 

03:31:59.011 --> 03:32:00.615
of
 your code base should be 

03:32:00.616 --> 03:32:02.424
portable
 between  the different contexts

03:32:02.425 --> 03:32:04.135
 and
 that last 10% you should be 

03:32:04.136 --> 03:32:06.338
able
 to  change out with whatever 

03:32:06.339 --> 03:32:09.917
environment.
&gt;&gt; AUDIENCE: Fire Based 

03:32:09.918 --> 03:32:11.918
underneath.
&gt;&gt; PRESENTER: Yes, beautiful.

03:32:12.026 --> 03:32:13.122
&gt;&gt; AUDIENCE: Does Angular have 
any

03:32:13.123 --> 03:32:16.237
 support for data stream,  like 
any

03:32:16.238 --> 03:32:18.825
 data, continuous flow?
&gt;&gt; PRESENTER: You asked the 

03:32:18.826 --> 03:32:19.263
right
 guy.

03:32:19.264 --> 03:32:23.118
&gt;&gt; This is Mr. Stream.
&gt;&gt; AUDIENCE: Socket IO, or 

03:32:23.119 --> 03:32:26.539
something,
 how does it render such?

03:32:26.561 --> 03:32:28.899
&gt;&gt; PRESENTER: So. That's a good 
question.

03:32:28.900 --> 03:32:31.620
 We showed you Fire  Based on 
stage.

03:32:31.621 --> 03:32:36.224
 There's nothing opinionated, 
most

03:32:36.225 --> 03:32:38.625
 people use  Socket IO. We don't
 provide

03:32:38.626 --> 03:32:41.222
 a library, but you can pull the
 one

03:32:41.223 --> 03:32:44.131
  off NPM and it works. This is 
the

03:32:44.132 --> 03:32:45.844
 nice thing about Angular 2.  
It's

03:32:45.845 --> 03:32:49.230
 less opinionated than Angular 1
.

03:32:49.231 --> 03:32:51.529
 It should work. Socket IO,  web
 socket,

03:32:51.530 --> 03:32:53.721
 signal, all these other things,
 just

03:32:53.722 --> 03:32:59.142
 plug it in and  it works.
&gt;&gt; AUDIENCE: Awesome.

03:32:59.164 --> 03:33:01.527
&gt;&gt; AUDIENCE: Hi. Will the pre-
compileed

03:33:01.528 --> 03:33:03.844
 templates become like a  JSX, 
like

03:33:03.845 --> 03:33:06.937
 a language in the future?
&gt;&gt; PRESENTER: That's -- so. 

03:33:06.938 --> 03:33:10.446
(Chuckling)
 JSX, tricky question,  right? 

03:33:10.447 --> 03:33:12.933
Conceptually,
 the output of pre-compilation 

03:33:12.934 --> 03:33:14.934
is
 on a high  level not dissimilar

03:33:14.937 --> 03:33:19.134
 to
 what the output of JSX looks 

03:33:19.135 --> 03:33:21.173
like.
 It's a  set of render 

03:33:21.174 --> 03:33:23.244
instructions.
 I don't want to compare then 

03:33:23.245 --> 03:33:25.245
one
 to  one, but, I don't think you

03:33:25.344 --> 03:33:26.778
 will
 ever write the code that our  

03:33:26.779 --> 03:33:30.050
compiler
 is writing, right? And I think 

03:33:30.051 --> 03:33:31.640
that
 at the end of the  day, the 

03:33:31.641 --> 03:33:34.340
language
 for describeing JSX, we have a 

03:33:34.341 --> 03:33:36.979
very
 different  opinion. There's a 

03:33:36.980 --> 03:33:38.435
good
 blog post which is like, we 

03:33:38.436 --> 03:33:40.334
like
  templates because they're a 

03:33:40.335 --> 03:33:41.458
limiting
 thing.

03:33:41.459 --> 03:33:43.136
You're not writing this other 
language.

03:33:43.137 --> 03:33:44.349
 They're simple,  declarative, 
we

03:33:44.350 --> 03:33:46.549
 can do what we need to do. JSX 
is

03:33:46.550 --> 03:33:48.148
 a different  opinion. It's not 
wrong,

03:33:48.149 --> 03:33:50.152
 bad, or worse, but it's a 
different

03:33:50.153 --> 03:33:53.649
 way  of thinking about things.
&gt;&gt; A big part of that is we can 

03:33:53.650 --> 03:33:54.468
optimize
 them.

03:33:54.469 --> 03:33:56.455
&gt;&gt; I probably shouldn't say this
,

03:33:56.456 --> 03:33:58.050
 but, I think the live stream  
is

03:33:58.051 --> 03:34:01.209
 off. If you wanted to write a 
JSX

03:34:01.210 --> 03:34:02.438
 renderer for Angular 2, you  
could

03:34:02.439 --> 03:34:04.447
 do it. We're not going to, but 
you

03:34:04.448 --> 03:34:05.751
 could.
&gt;&gt; AUDIENCE: The example you 

03:34:05.752 --> 03:34:07.350
gave
 during the talk, that the  

03:34:07.351 --> 03:34:09.650
templates
 compile into type script gave 

03:34:09.651 --> 03:34:10.949
me
 the idea that you can  basic

03:34:10.950 --> 03:34:15.045
ally
 then do runtime, like checking 

03:34:15.046 --> 03:34:16.842
as
 well, writing the  HTML. You 

03:34:16.843 --> 03:34:19.048
can
 say, this is wrong.

03:34:19.071 --> 03:34:20.745
&gt;&gt; PRESENTER: That's exactly 
what's

03:34:20.746 --> 03:34:24.146
 coming down the pike.
&gt;&gt; We have mature code in 

03:34:24.147 --> 03:34:26.344
Angular
 2, code that has existed for  a

03:34:26.662 --> 03:34:28.360
 while
 now that we've run through this

03:34:28.361 --> 03:34:30.353
 new
 process and it  catches bugs.

03:34:30.354 --> 03:34:32.276
&gt;&gt; AUDIENCE: Perfect.
&gt;&gt; PRESENTER: It's amazing.

03:34:32.277 --> 03:34:34.366
&gt;&gt; You can think of it like the 
template

03:34:34.367 --> 03:34:37.252
 becomes the source  map for the
 generateed

03:34:37.253 --> 03:34:40.655
 code.
&gt;&gt; AUDIENCE: Thank you.

03:34:40.678 --> 03:34:42.200
&gt;&gt; AUDIENCE: What's the 
relationship

03:34:42.201 --> 03:34:45.059
 between Angular 2 and  Polymer?
 I've

03:34:45.060 --> 03:34:46.558
 seen that. It's another 
component

03:34:46.559 --> 03:34:49.367
 library.
&gt;&gt; PRESENTER: Again, I think 

03:34:49.368 --> 03:34:50.977
probably
 different opinions on  the way 

03:34:50.978 --> 03:34:53.461
to
 do things. Neither is right or 

03:34:53.462 --> 03:34:55.462
wrong.
 One of the cool  things about 

03:34:55.685 --> 03:34:58.063
Polymer
 components is you can drop them

03:34:58.862 --> 03:34:59.873
 in
 Angular  apps. That's the short

03:34:59.874 --> 03:35:01.462
 answer.
 We are two different frameworks

03:35:01.463 --> 03:35:03.060
  that
 look at the world slightly 

03:35:03.061 --> 03:35:04.862
differently.
&gt;&gt; AUDIENCE: How would you 

03:35:04.863 --> 03:35:06.366
characterize
 your opinion and their  opinion

03:35:06.367 --> 03:35:08.367
?
 I assume you're friendly.

03:35:08.379 --> 03:35:10.060
&gt;&gt; PRESENTER: Yeah,. I would say
 I

03:35:10.061 --> 03:35:12.459
 think their main focus is on  
DOM

03:35:12.460 --> 03:35:14.257
 and components as a thing, 
right.

03:35:14.258 --> 03:35:16.561
 And very much if you like  web 
platform.

03:35:16.562 --> 03:35:18.159
 And I think that our focus is 
very

03:35:18.160 --> 03:35:20.662
 much on building  larger 
applications

03:35:20.663 --> 03:35:22.863
 on really JavaScript, right. 
And

03:35:22.864 --> 03:35:25.063
 I think  that's a fair thing to
 say,

03:35:25.064 --> 03:35:26.172
 right? We have different 
opinions

03:35:26.173 --> 03:35:28.276
 on  dependency injection and 
the

03:35:28.277 --> 03:35:34.079
 way you compos things.
&gt;&gt; And running in locations 

03:35:34.080 --> 03:35:36.069
other
 than browsers, like the  server

03:35:36.070 --> 03:35:38.469
.
&gt;&gt; We play with our stuff their 

03:35:38.470 --> 03:35:40.470
stuff
 a lot. It's an interesting idea

03:35:40.569 --> 03:35:42.569
.
  We like the idea of dropping 

03:35:42.594 --> 03:35:43.890
Polymer
 components in Angular apps.

03:35:43.891 --> 03:35:45.276
&gt;&gt; Before Angular 2 material 
came

03:35:45.277 --> 03:35:47.267
 out, I was building a sample  
application

03:35:47.268 --> 03:35:49.165
 and just took the Polymer 
material

03:35:49.166 --> 03:35:51.269
 library and import imported it 
wholesale

03:35:51.270 --> 03:35:54.084
 and it worked. It was beautiful
.

03:35:54.085 --> 03:35:56.164
&gt;&gt; PRESENTER: Yeah,. Cool. Any 
other

03:35:56.165 --> 03:35:59.181
 questions? No? Okay. Well,  
thanks

03:35:59.182 --> 03:36:02.378
 for coming.
&gt;&gt; PRESENTER: Yeah, thank you 

03:36:02.379 --> 03:36:02.707
very
 much.

03:36:02.708 --> 03:36:04.708
(Cheering and applause)

03:36:07.872 --> 03:36:13.880
 (Session
concluded at 5:39 p.m. PT) 

03:36:13.881 --> 03:36:17.681
(This text is provided as a
realtime service and is not to

03:36:13.881 --> 03:36:13.883
be  copied from any live event.
Please contact Caption First if

03:36:13.884 --> 03:36:13.885
you  would like to receive a
properly formatted transcript of

03:36:13.886 --> 03:36:15.886
this  event.)

03:45:48.039 --> 03:45:50.039
 the   

03:46:03.556 --> 03:46:05.556
F

03:46:07.201 --> 03:46:10.818
 product ideas using Firebase.  

03:46:22.865 --> 03:46:27.502
 Product Ideas Using Firebase   

03:56:52.029 --> 03:56:54.029
[Cheers] 

03:57:04.033 --> 03:57:06.438
 All right.  This is going to be
 something that you will 

03:57:06.903 --> 03:57:08.903
remember, I 

03:57:11.614 --> 03:57:19.291
think.  Hello, everybody my name
 is Ran.  I work on Google.  I 

03:57:19.292 --> 03:57:24.142
spend most of my time on L
aunchpad.  That is an a start 

03:57:24.143 --> 03:57:29.441
with Google Developer.  Mainly, 
I will talk about common 

03:57:29.442 --> 03:57:33.690
challenges related to the 
never-ending question of: What 

03:57:33.691 --> 03:57:37.267
should we build next?  I will 
share with you some best 

03:57:37.268 --> 03:57:41.509
practices that we know are 
working for startups and how we 

03:57:41.510 --> 03:57:43.510
can leverage Firebase to

03:57:46.713 --> 03:57:48.791
  use them. 

03:57:52.197 --> 03:57:58.214
 In 2015, we worked with 6,000 
startups worldwide and provided 

03:57:58.569 --> 03:58:01.941
50,000 hours of one-on-one 
mentorship. &gt;&gt; 

03:58:05.189 --> 03:58:10.231
Yeah!  Now, for those 50,000 
hours of mentorship, we have 

03:58:10.232 --> 03:58:13.768
learned what drive startup 
success and what doesn't.  works

03:58:14.222 --> 03:58:22.583
 and what doesn't work.  Now, we
 know that startups are not the 

03:58:22.805 --> 03:58:27.913
same.   say all startups are the
 same, but there are common 

03:58:27.914 --> 03:58:32.731
problems and challenges that 
every startup needs to solve.  

03:58:32.732 --> 03:58:36.533
there is the technical 
challenge.  Can we build it?   

03:58:36.534 --> 03:58:40.646
is the product challenge.  All r
ight, we can build it, do people

03:58:40.788 --> 03:58:45.160
 need it?   use it?  Next there 
is the market challenge.  All 

03:58:45.336 --> 03:58:48.612
right, we build it, there is 
people who need it, we want to 

03:58:48.613 --> 03:58:55.154
use it, can we reach them?  It 
is not that trivial.  First 

03:58:55.155 --> 03:58:57.728
challenge is the scale 
challenge.  When you think about

03:58:57.729 --> 03:59:02.919
 it, startup scales are any 
aspect of user, employees, 

03:59:02.920 --> 03:59:08.521
operations and how do you do 
that and maintain your sanity. 

03:59:08.522 --> 03:59:13.555
but not least, the financial 
challenge.  How do you make it 

03:59:13.682 --> 03:59:17.857
profitable, make money in your 
startup, your business.  Today I

03:59:17.858 --> 03:59:20.937
 will focus on the product 
challenge.  I like to call it, 

03:59:20.938 --> 03:59:23.854
how to build products that 
people need, that people 

03:59:23.980 --> 03:59:28.807
actually use.   usually, when I 
talk about the product 

03:59:29.008 --> 03:59:33.068
challenge, people automatically 
think that it's related only to 

03:59:33.069 --> 03:59:36.597
early stage startups, to teams 
that didn't release the product 

03:59:36.598 --> 03:59:43.951
yet, that they're second product
 market a MAC and hoodie walking

03:59:44.075 --> 03:59:49.098
 down university avenue in Palo 
Alto.  The truth is product 

03:59:49.099 --> 03:59:53.884
challenge is a never ending 
challenge.  You live it every 

03:59:53.885 --> 03:59:58.353
single day in this amazing 
journey of building successful 

03:59:58.531 --> 04:00:01.785
products that drive successful 
businesses.  It doesn't matter 

04:00:01.921 --> 04:00:08.862
if you have zero users, 10K 
users or 10 million users, you 

04:00:08.863 --> 04:00:13.125
ask yourself: What should I 
build now?  And I'd like to 

04:00:13.126 --> 04:00:22.958
start in sharing a story with 
you.  It is a story

04:00:23.227 --> 04:00:27.036
 of a good friend of mine.  She 
wanted to be here, but couldn't 

04:00:27.037 --> 04:00:31.795
make it. is Rony.  She writes 
Android code and iOS code and 

04:00:31.796 --> 04:00:38.790
has this lovely dog named Nala. 
 And Nala loves Android. 

04:00:42.227 --> 04:00:46.566
 likes to go outside, go on long
 walks, hang out in the park.  

04:00:46.567 --> 04:00:50.188
Nala is a playful dog and 
super-friendly, and likes to 

04:00:50.189 --> 04:00:56.000
play with other dogs as well.  
One day, Rony thought, hey, why 

04:00:56.001 --> 04:01:03.038
don't I build a hyperhyperlocal 
network for dogs and owners.  

04:01:03.039 --> 04:01:07.175
Being this super awesome girl, 
that's what she did.  She sat 

04:01:07.176 --> 04:01:10.501
down over the weekend and came 
up with the app and let you see 

04:01:10.502 --> 04:01:14.672
other dog owners walking their 
dogs around you.  You can know 

04:01:14.673 --> 04:01:17.672
when to walk the dog and 
potentially make new friends for

04:01:17.851 --> 04:01:24.295
 you and your pets.  And she 
released this, what you might 

04:01:24.296 --> 04:01:32.894
call MPP.  Boom.  She tweets 
about it.  Blogger picks it

04:01:34.500 --> 04:01:40.974
 up.  20,000 installs, 5,000 
daily active user, users that 

04:01:40.975 --> 04:01:49.770
use have MVP$200,000 in seed 
money and focus on adding 

04:01:49.905 --> 04:01:53.847
feature, in other words, 
building our product.  Rony is 

04:01:53.848 --> 04:01:57.745
smart.  I can't say that too 
many times.  She knows 

04:01:57.746 --> 04:02:02.096
everything about a startup, and 
she knows she needs to validate 

04:02:02.190 --> 04:02:05.548
thing, and do user research.  
That's exactly the very first 

04:02:05.549 --> 04:02:10.921
thing she's doing.  builds this 
amazing landing page, again, 

04:02:10.922 --> 04:02:13.643
featuring Nala, telling people 
about the product that she's 

04:02:13.644 --> 04:02:17.140
about to release and allowing 
them to leave their e-mail 

04:02:17.141 --> 04:02:21.367
address if they're interested to
 hear more about it or join a 

04:02:21.368 --> 04:02:25.059
private beta.  And of course, 
she checks conversion 

04:02:31.453 --> 04:02:35.909
rates.  sends out notifications 
to the loyal users and ask hey, 

04:02:35.910 --> 04:02:40.521
would you like user ratings or 
that or that in the app.  Users 

04:02:40.647 --> 04:02:44.973
can say yes or no, and of 
course, she checks conversion 

04:02:45.151 --> 04:02:47.151
rates.  Lastly

04:02:51.498 --> 04:02:55.820
, just to be extra sure, she 
went out and spoke to her users,

04:02:55.997 --> 04:03:00.974
 like the real world, speaking 
with them.  She buys them 

04:03:01.243 --> 04:03:05.742
coffee, shows them her mockups 
and asks them three questions.  

04:03:06.080 --> 04:03:10.134
Would you use it?  you pay for 
it?  And how much will you pay 

04:03:10.135 --> 04:03:16.743
for it?   her user research, she
 builds what she thinks is a 

04:03:16.744 --> 04:03:18.744
great 

04:03:20.412 --> 04:03:26.512
product.  She publishing it on 
app store and Google Play, ready

04:03:26.668 --> 04:03:31.848
 to takeoff, but unfortunately 
she crashes. didn't get the 

04:03:31.849 --> 04:03:37.024
traction she wants.  Let's see, 
let's look at what went wrong 

04:03:37.369 --> 04:03:41.218
here.  very first thing Rony did
 was using a landing page.  She 

04:03:41.219 --> 04:03:43.267
used it in order to figure out 
if people

04:03:47.829 --> 04:03:53.129
 want such an app, if people 
need it.  In fact, landing page 

04:03:53.130 --> 04:03:57.099
can answer only one single 
question: Are people interested 

04:03:57.100 --> 04:04:01.852
enough to give me their e-mail a
 doesn't say anything about do 

04:04:01.853 --> 04:04:09.688
people need it and will people 
use it.  The second thing that 

04:04:09.689 --> 04:04:13.812
Rony did is listening to her 
users, either in person or via 

04:04:13.813 --> 04:04:17.430
push notifications.  But the 
very first rule in user research

04:04:17.876 --> 04:04:23.778
 is ... never listen to users!  
know it sounds funny, but bear 

04:04:23.779 --> 04:04:29.375
with me for a moment.  listen to
 your users, instead ... watch 

04:04:29.643 --> 04:04:33.213
and observe their behavior.  The
 reason is that we, human being,

04:04:33.773 --> 04:04:37.682
 we're very bad at predicting 
our own behavior.  There is 

04:04:37.683 --> 04:04:41.622
almost zero correlation between 
what we say we will do and what 

04:04:41.623 --> 04:04:48.352
we actually do.  Psychologists 
know that, researchers know 

04:04:48.831 --> 04:04:50.831
that, developers

04:04:53.204 --> 04:04:57.783
 don't.  So I'm here to help.  
Let's see what Rony could have 

04:04:57.784 --> 04:05:01.436
done differently.  I will 
introduce you to a methodology 

04:05:01.753 --> 04:05:05.726
proved to be working.  Build, 
experiment, optimize.  Now, 

04:05:05.843 --> 04:05:09.645
being an engineer, I feel very 
comfortable with the build s

04:05:09.821 --> 04:05:11.821
tuff.  To 

04:05:13.363 --> 04:05:19.457
me, writing code is not a job, 
it is a hobby.   I like to do.  

04:05:19.458 --> 04:05:22.769
That's my sweet spot.   I'm not 
the only one in the room.  Let's

04:05:22.934 --> 04:05:26.744
 move to experiment.  What is a 
good experiment?  What do I w am

04:05:27.019 --> 04:05:29.145
 I looking for in my 
experiments?  A good

04:05:32.318 --> 04:05:35.891
 experiment is fast.  I want to 
get results quickly.  I don't 

04:05:35.892 --> 04:05:40.345
want to wait forever to figure 
out what my next move is.  A 

04:05:40.346 --> 04:05:42.346
good experiment is

04:05:44.343 --> 04:05:47.314
 efficient I like to run 
experiment without investing a 

04:05:47.315 --> 04:05:50.821
lot of manpower.  like to run 
experiment -- it doesn't matter 

04:05:50.822 --> 04:05:55.131
if we are talking about a small 
team or big team, ideally, one 

04:05:55.132 --> 04:05:59.789
person will be able to run -- 
and manage multiple experiments 

04:06:00.206 --> 04:06:03.719
simultaneously.  And last but 
not least, good experiments 

04:06:03.720 --> 04:06:08.697
provide me with real data.  your
 users, remember, observe their 

04:06:09.007 --> 04:06:16.332
behavior.  We act upon real 
data, not gut feeling.  I need a

04:06:16.333 --> 04:06:21.051
 system that will allow me to 
track data, analyze it, act upon

04:06:21.397 --> 04:06:25.818
 it all in one place.  Make 
data-driven decisions.  Now, 

04:06:25.961 --> 04:06:28.572
unfortunately, if you wanted to 
run experiments, you would have 

04:06:28.573 --> 04:06:36.499
to use multiple products from 
analytics to AB systems to push 

04:06:36.500 --> 04:06:41.920
analytics and what not.  You 
need to integrate Android and 

04:06:41.921 --> 04:06:47.176
iOS and write code on the 
service side.  You need to face 

04:06:47.177 --> 04:06:50.948
some data integration issue and 
deal with data discrepancy 

04:06:50.949 --> 04:06:54.393
between system.  means you don't
 have one single place with all 

04:06:54.394 --> 04:06:57.621
the data.  Well, that was the 
situation until we

04:07:02.408 --> 04:07:05.959
 announced Firebase today.  If 
you have been to the keynote 

04:07:06.205 --> 04:07:08.205
today, I probably heard about

04:07:11.272 --> 04:07:15.310
 haven't heard the keynote, then
 I suggest you get up, find a 

04:07:15.311 --> 04:07:19.194
way to travel back in time and 
watch the keynote.  Because the 

04:07:19.195 --> 04:07:24.259
keynote was awesome.  And for 
the keynote, there's a T-shirt h

04:07:24.994 --> 04:07:32.092
ere.  All right.   know, can I 
get a "hell yeah" for the 

04:07:32.388 --> 04:07:37.005
keynote.  Let's do AP testing.  
This side, can I get a hell 

04:07:37.314 --> 04:07:43.916
yeah!  What about that side?  
T-shirt goes that way.  

04:07:43.917 --> 04:07:45.917
[Laughter]  

04:07:50.464 --> 04:07:53.867
right, Firebase, Firebase is a 
suit of integrated products to 

04:07:53.868 --> 04:07:59.694
help you build your app, grow 
your app and earn money.  It 

04:07:59.695 --> 04:08:06.690
helps you build your app and 
make money. know and understand 

04:08:06.691 --> 04:08:09.673
there is more than one platform 
out there.  Firebase has all the

04:08:11.718 --> 04:08:16.165
 great features you can see 
here.  I will obviously not go 

04:08:16.166 --> 04:08:19.876
over all of them.  I will focus 
on what makes Firebase a great 

04:08:19.877 --> 04:08:21.877
experiment

04:08:24.926 --> 04:08:33.830
al analytics.  the heart of the 
Firebase platform.  It is free 

04:08:33.831 --> 04:08:35.831
and unlimited.  Now you can

04:08:40.348 --> 04:08:44.990
 learn and understand everything
 your users are doing without c

04:08:45.956 --> 04:08:53.403
ompromising.  100% free.   no 
hits limits, no quota, no 

04:08:53.688 --> 04:08:59.715
sampling, 100% for free.  And 
automatic event reporting.  When

04:08:59.716 --> 04:09:02.841
 you integrate Firebase 
Analytics into your product 

04:09:02.842 --> 04:09:09.219
without adding any lines of 
code, we track key events, like 

04:09:09.220 --> 04:09:11.220
apple pays

04:09:12.987 --> 04:09:18.754
 -- app updates, and out of the 
box key metrics, like monthly 

04:09:19.172 --> 04:09:24.631
active user, average revenue per
 user, average revenue per 

04:09:24.632 --> 04:09:29.222
paying user, and more.  is so 
powerful because

04:09:32.334 --> 04:09:33.682
 it is tightly integrated with 
Firebase and with Google.  Now, 

04:09:33.683 --> 04:09:39.829
you can take the data, make some
 insights and immediately turn 

04:09:39.830 --> 04:09:43.648
the insights into action item. 
we'll see how you do that later.

04:09:43.649 --> 04:09:51.228
  And last, it's your data.  All
 the data that we track and 

04:09:51.229 --> 04:09:54.736
collect in Firebase Analytics is
 your data, with very few single

04:09:55.183 --> 04:09:59.802
 clicks, very few clicks, you 
can export all your data to 

04:10:00.099 --> 04:10:02.708
BigQuery, connect it to whatever
 tables you have and run 

04:10:02.709 --> 04:10:06.851
anything from queries to machine
 learning to prediction API.  It

04:10:06.852 --> 04:10:11.637
 is your data.  Now, let's take 
a look at what it takes to add 

04:10:12.012 --> 04:10:14.012
Firebase Analytics into your 

04:10:15.526 --> 04:10:19.741
product.  You start at the 
Firebase console.  And you get 

04:10:19.742 --> 04:10:25.617
this lovely screen where you can
 add Android app, iOS app or web

04:10:25.618 --> 04:10:30.535
 app, you go small configuration
 phase, get a config file to 

04:10:30.536 --> 04:10:36.540
download to your product.  Then 
a single line of code in iOS 

04:10:36.541 --> 04:10:45.472
grabbing from graddella  --

04:10:47.346 --> 04:10:52.977
 Gradle file, and you have that 
done and you get it right out of

04:10:55.912 --> 04:10:59.063
 the Box 1, seven, 30-day, to 
retention cohorts, and 

04:10:59.064 --> 04:11:02.477
demographics and so much more. 
time to go through all of it, I 

04:11:02.478 --> 04:11:04.750
will focus on the things that m

04:11:09.809 --> 04:11:14.312
atter to us.  Remember our goal?
  We want to watch and observe 

04:11:14.313 --> 04:11:19.096
our users behavior.  see how 
Firebase Analytics helps us do 

04:11:19.263 --> 04:11:22.516
that.  many other analytics 
systems, Firebase Analytics is 

04:11:22.517 --> 04:11:27.205
an event-centric system.  That 
means it tracks and collects 

04:11:27.406 --> 04:11:34.388
event.  Logging event is super, 
super easy.  50, grab a 

04:11:34.389 --> 04:11:41.159
reference to Firebase Analytics 
object and initialize it.  And 

04:11:41.633 --> 04:11:45.907
then use the API.  This is how I
 would use it when a user clicks

04:11:46.162 --> 04:11:49.910
 an item in my app to view more 
details about it.  As you can 

04:11:50.025 --> 04:11:54.246
see, the API is straightforward.
  You build a bundle and call 

04:11:54.247 --> 04:11:57.827
log event with that bundle.  
Now, deciding what to log and 

04:11:57.828 --> 04:11:59.828
when can sometimes

04:12:02.171 --> 04:12:06.099
 be tricky.  That's why we came 
up with some suggested schemas, 

04:12:06.414 --> 04:12:11.780
like you see here.  Item I.D., 
item name, content type.  Of c

04:12:11.952 --> 04:12:16.431
ourse, you can use whatever 
schemas you want, in case you 

04:12:17.001 --> 04:12:19.001
don't like 

04:12:21.801 --> 04:12:26.037
ours.  Once you go back to the 
console, you can see the events 

04:12:26.038 --> 04:12:32.356
and drill down an event to see 
more information about it.  Now 

04:12:32.357 --> 04:12:36.474
thing is we want to track user's
 flow, we don't want to track 

04:12:36.475 --> 04:12:39.933
single interaction.  We want to 
track the whole interaction, 

04:12:40.341 --> 04:12:44.378
what the user is doing.  That is
 where funnels come to help.  

04:12:44.379 --> 04:12:50.828
Funnels come to help.  Great.  
So finally the series of events 

04:12:50.829 --> 04:12:54.031
that are important to us, that 
we're interested in.  As soon as

04:12:54.032 --> 04:13:00.256
 you define a funnel, let's see 
user browse through items, add 

04:13:00.257 --> 04:13:04.287
an item to a cart and purchase 
it, that is a series of events 

04:13:04.288 --> 04:13:08.489
we're interested in, when we 
define the funnel, Firebase 

04:13:08.725 --> 04:13:12.654
Analytics will track and go 
through the journey and tell us 

04:13:13.234 --> 04:13:18.040
what is the conversion rate?  
How many users went from one 

04:13:18.041 --> 04:13:23.337
state to another?   added an 
item to the cart?  How many 

04:13:23.338 --> 04:13:28.514
actually made a purchase?  It is
 great to check where you are 

04:13:28.515 --> 04:13:33.536
losing users and where you need 
to improve.  I said Firebase 

04:13:34.618 --> 04:13:42.504
Analytics is an event-centric 
system, but it is also 

04:13:45.149 --> 04:13:48.775
 That makes it unique.  We know 
that users are not the same.  

04:13:49.733 --> 04:13:52.041
Different users behave 
differently.  In order to really

04:13:52.366 --> 04:13:55.768
 understand our users and what 
they're doing, we need to be 

04:13:55.769 --> 04:14:01.291
able to define different groups 
of users.  We call those groups 

04:14:01.493 --> 04:14:05.456
audiences.  we need to breakdown
 every single report based on 

04:14:05.457 --> 04:14:12.259
those groups or audiences, 
everything from funnels to 

04:14:12.432 --> 04:14:14.432
events, to

04:14:17.927 --> 04:14:22.203
 ARPs and everything, when you 
think of an audience, you think 

04:14:22.204 --> 04:14:26.204
of males, versus females, 
different age groups, maybe some

04:14:27.119 --> 04:14:30.556
 location, language or some 
other common attributes like 

04:14:31.307 --> 04:14:38.003
device, OS version, app version,
 et cetera.  Firebase Analytics 

04:14:38.004 --> 04:14:41.978
has all that, but it also lets 
you define your own user 

04:14:42.121 --> 04:14:45.852
property, like, I don't know, 
users that shared an item at 

04:14:45.853 --> 04:14:50.004
least once.  Or users that 
reached level 5 in my 

04:14:53.340 --> 04:14:58.414
game.  Remember what we need 
from our experiment framework. 

04:14:58.415 --> 04:15:03.034
takes care of providing us with 
real data and data we can act u

04:15:03.163 --> 04:15:06.736
pon, but we still need to be 
able to make quick and fast 

04:15:06.737 --> 04:15:10.420
changes in our app and the way 
our app behaves.  This is 

04:15:10.421 --> 04:15:15.882
exactly why we built remote 
config.  As a matter of fact, 

04:15:15.883 --> 04:15:20.406
remote config started as an 
internal system we used at 

04:15:20.798 --> 04:15:26.410
Google.  First, we used it in 
the framework, GMS and opened it

04:15:26.810 --> 04:15:33.783
 to internal apps like Gmail, 
Play.  It saved us so many times

04:15:33.956 --> 04:15:38.244
 and proved to be so valuable to
 us, we said all right.  Maybe 

04:15:38.245 --> 04:15:43.186
other developers can benefit 
from it.  We open it up today on

04:15:43.539 --> 04:15:53.013
 Android and iOS.  Remote config
 lets you store key value pairs 

04:15:53.014 --> 04:15:58.125
and lets you store them.  You 
can save language, device, app 

04:15:58.931 --> 04:16:05.778
version, OS version, et cetera. 
 And do stage rollouts to change

04:16:05.779 --> 04:16:06.764
 values to 10% of the users in 
North America.  And since 

04:16:06.765 --> 04:16:10.481
everything is so integrated with
 analytics, you can target 

04:16:10.482 --> 04:16:15.628
different audiences with remote 
config.  For example, let's say 

04:16:15.629 --> 04:16:20.261
I'm building this great game and
 I'm not sure how hard I need to

04:16:20.334 --> 04:16:25.083
 make this game.  So I set up 
with remote config, the game 

04:16:25.469 --> 04:16:31.582
difficulty level.  I can change 
it remotely.  But I can do even 

04:16:31.801 --> 04:16:36.912
more.  Let's say I can make the 
game harder for people who reach

04:16:36.913 --> 04:16:42.581
 level 5 in less than two days 
and I can make the game easier 

04:16:42.582 --> 04:16:45.628
for people who are struggling 
with level 1 for more than two 

04:16:46.003 --> 04:16:49.270
hours, so they won't get 
frustrated.  You know what, 

04:16:49.271 --> 04:16:55.162
let's see how I would do that.  
First, I initialize remote 

04:16:55.163 --> 04:16:59.214
config and set some different 
values to it.  Just in case I 

04:16:59.215 --> 04:17:01.646
don't have a network or 
something, I do have the 

04:17:01.647 --> 04:17:07.458
different values.   call fetch 
and activate fetch to grab the 

04:17:07.459 --> 04:17:09.459
new values from the 

04:17:12.608 --> 04:17:19.636
server.  Anywhere in my app, I 
can use the values in my get by 

04:17:19.637 --> 04:17:25.635
calling get in, get string, as 
simple as that. Don't worry 

04:17:25.636 --> 04:17:29.949
about calling multiple fetches 
and stuff.  We have caching 

04:17:30.104 --> 04:17:34.445
mechanism and we know how to 
turn the caches valid to may 

04:17:34.593 --> 04:17:41.048
fetch a no-op.  There is a good 
remote config talk, I think, 

04:17:41.049 --> 04:17:43.049
tomorrow.  All right. k to

04:17:45.059 --> 04:17:46.757
 our game plan.  So with 
Firebase Analytics and remote 

04:17:46.758 --> 04:17:51.935
config, I can run experiments 
and change my game difficulty 

04:17:51.936 --> 04:17:54.694
level pretty easily.  But I 
still don't know what is the 

04:17:54.695 --> 04:17:58.376
right difficulty level that I 
should stick with.  In other 

04:17:58.377 --> 04:18:04.838
words, what am I trying to 
optimize here?  Now, everything 

04:18:04.839 --> 04:18:10.254
that you optimize, everything 
that you change every feature 

04:18:10.255 --> 04:18:16.160
that you add, every little thing
 in your app needs to show 

04:18:16.161 --> 04:18:20.001
significant improvement in one 
of the three.  Conversion from 

04:18:20.002 --> 04:18:24.001
free to paid.  Actual users that
 are paying for your app, paying

04:18:24.174 --> 04:18:28.168
 for your service.  Time spent 
in app, increase the time that 

04:18:28.169 --> 04:18:33.427
users are using your product.  
And retention.  Make your users 

04:18:33.428 --> 04:18:42.509
use your product or app more 
often.  So I'd like to show you 

04:18:42.510 --> 04:18:48.526
how App in the Air used this 
framework -- a very similar 

04:18:48.527 --> 04:18:52.354
framework and Firebase to learn 
the experiments, learn and 

04:18:52.355 --> 04:18:56.089
optimize the product and their 
business.  So up in the air is 

04:18:56.090 --> 04:19:00.009
basically a personal travel 
assistant.  It gives you 

04:19:00.010 --> 04:19:02.278
consistency and all the 
resources and information that 

04:19:02.279 --> 04:19:08.616
you need about your flight and 
travel regardless of the airline

04:19:09.262 --> 04:19:14.327
 and all the flight.  They 
released an SDK so other 

04:19:14.328 --> 04:19:18.431
developers can plug into it.  
What I like about up in the air,

04:19:18.432 --> 04:19:22.177
 it has additional features that
 save you time and money and 

04:19:22.178 --> 04:19:25.107
airport trips and queue for 
security in the airport.  I like

04:19:25.285 --> 04:19:31.629
 that.  Let's see how App in the
 Air used Firebase to validate 

04:19:31.630 --> 04:19:35.527
what they are doing.  First 
thing they did is define funnel 

04:19:35.528 --> 04:19:40.505
that represents the main goal of
 the app, or their main KPI, if 

04:19:40.506 --> 04:19:47.754
you wish, which is user openers 
the app adds a flight and makes 

04:19:47.755 --> 04:19:53.698
a purchase.  That's the core 
metric of the business.  Define 

04:19:53.699 --> 04:20:01.736
the funnel and this is what they
 got.   see 29% of the users 

04:20:01.737 --> 04:20:06.562
added a flight and 7.2% of those
 users actually made a purchase.

04:20:06.563 --> 04:20:11.607
  That is across all users.  So 
they started filtering this 

04:20:11.608 --> 04:20:14.874
funnel based on different 
demographics and other 

04:20:15.066 --> 04:20:18.271
parameters, actually, they used 
about 18 different properties 

04:20:18.272 --> 04:20:22.281
and attributes to filter and 
take a look -- take a deeper 

04:20:22.282 --> 04:20:26.373
look at what their users are 
doing.  And here are some 

04:20:26.374 --> 04:20:31.986
interesting things that they've 
learned.  Users between age 18 

04:20:31.987 --> 04:20:33.987
and 24 have

04:20:35.203 --> 04:20:37.203
 two times -- 

04:20:41.423 --> 04:20:43.508
yeah.  They have two time add 
flight conversion.   more 

04:20:43.889 --> 04:20:45.889
flights.  And they have

04:20:49.802 --> 04:20:52.088
 1.5 times purchase flight 
conversion.  Purchase 

04:20:52.197 --> 04:20:55.288
conversion.  They looked at 
other properties and found that 

04:20:55.816 --> 04:20:59.293
users running Marshmallow also 
convert better.  Almost two 

04:20:59.294 --> 04:21:01.294
times add flight and

04:21:07.593 --> 04:21:11.510
 1.4 times make a purchase.  
Just by looking at Firebase 

04:21:11.511 --> 04:21:14.048
Analytics with audiences, 
breaking out what users are 

04:21:14.299 --> 04:21:16.938
doing, they immediately got some
 very interesting and crucial 

04:21:16.939 --> 04:21:20.988
action items.  First, we need to
 investigate why we have this 

04:21:20.989 --> 04:21:25.774
difference in performance.  
Second, let's check issues on 

04:21:25.775 --> 04:21:30.881
bad OS versions.  Maybe users 
with Kit Kat, the app doesn't 

04:21:30.882 --> 04:21:33.202
crash in Kit Kat, but maybe 
there is a problem there.  Maybe

04:21:33.203 --> 04:21:37.041
 we're slow, maybe we're 
lagging, maybe there is a glitch

04:21:37.325 --> 04:21:40.799
 in the UI.  I don't know.  But 
it is worse --

04:21:44.942 --> 04:21:46.906
 it makes sense to experiment 
that.  And it allows them to 

04:21:46.907 --> 04:21:50.815
know which users to engage, that
 are more likely to make a p

04:21:50.955 --> 04:21:55.352
urchase.  So one of the things 
that they decided to check was 

04:21:55.353 --> 04:22:04.536
the onboarding process of the 
app. used remote config, as you 

04:22:04.842 --> 04:22:09.474
can see to define a quick 
experiment.  50% of users will 

04:22:09.475 --> 04:22:12.585
get a welcome screen explaining 
what the app is doing.  And they

04:22:12.716 --> 04:22:17.571
 will get one free credit to get
 flight --  the service before 

04:22:17.921 --> 04:22:22.351
they buy.  And the other 50% of 
the users will not get the 

04:22:23.263 --> 04:22:27.332
welcome screen, will not get the
 free credit for flight alerts. 

04:22:27.670 --> 04:22:31.559
 And they compared the 
conversion rate, based on those 

04:22:34.297 --> 04:22:38.976
groups.  When they compared, 
this is what they saw.  

04:22:39.437 --> 04:22:45.682
At-flight conversion is pretty 
similar.  The welcome screen, 

04:22:46.684 --> 04:22:51.671
not having a welcome screen 
configurated didn't change the 

04:22:51.672 --> 04:22:54.468
add flights.  But one group 
actually purchased two times 

04:22:54.469 --> 04:22:57.679
more than the other group.  
Here's the question for you guys

04:22:58.536 --> 04:23:05.764
 and girls.  Which group 
purchased more?  The group that 

04:23:05.765 --> 04:23:11.684
got a nice welcome screen, 
hello, welcome to App in the 

04:23:11.685 --> 04:23:15.011
Air, here's a free credit, try 
before you buy. The group that 

04:23:15.012 --> 04:23:17.987
installed the app, opened it and
 immediately in the screen they 

04:23:17.988 --> 04:23:21.534
needed to figure out what to do?
  Who thinks it is the group 

04:23:21.535 --> 04:23:24.763
with the welcome screen?  Who 
thinks it is the group with the 

04:23:24.764 --> 04:23:26.764
no welcome 

04:23:28.894 --> 04:23:35.396
screen?  Who doesn't think?  
[Laughter] All right.  That's 

04:23:35.397 --> 04:23:39.165
exactly why you need to make 
data-driven decision and not gut

04:23:39.751 --> 04:23:46.622
 feeling.  having a welcome 
screen and offering a free 

04:23:47.831 --> 04:23:55.263
credit made people buy less.  
the very first call to action 

04:23:55.264 --> 04:23:58.815
that App in the Air did was 
going back to remote config and 

04:23:58.816 --> 04:24:03.535
change that group that doesn't 
get a welcome screen from 50% to

04:24:03.536 --> 04:24:05.536
 100%, and the 

04:24:08.929 --> 04:24:12.206
result?   Two times purchase 
across both iOS and Android.  

04:24:21.911 --> 04:24:24.877
 Actually, the team that 
implemented all of that is 

04:24:24.878 --> 04:24:26.878
sitting 

04:24:30.823 --> 04:24:35.856
here.  Another thing that they 
did, which is very interesting, 

04:24:35.857 --> 04:24:40.614
App in the Air, they render an 
application service -- server, 

04:24:40.615 --> 04:24:45.834
sorry, on app engine.   the 
server, in the backend, they 

04:24:45.835 --> 04:24:49.432
have lots of data about users, 
preferences, history of 

04:24:49.595 --> 04:24:54.574
purchases, and tons and tons of 
stuff.  But now with Firebase 

04:24:54.575 --> 04:24:57.747
Analytics -- now with Firebase 
Analytics, Firebase Analytics 

04:24:57.748 --> 04:25:03.943
also stores data about users' 
behavior.   linked the two.  

04:25:03.944 --> 04:25:12.902
They started running some secret
 sauce of prediction amp -- APIs

04:25:13.284 --> 04:25:17.451
 and crazy queries and found 
something interesting.  They 

04:25:17.587 --> 04:25:23.553
found out there is a group of 
users you can define based on 

04:25:23.999 --> 04:25:27.337
parameters, which is three times
 more likely to fly business.  

04:25:28.417 --> 04:25:32.612
Okay?  Immediately as the user 
opens the app, you can predict 

04:25:32.613 --> 04:25:37.335
that this user may fly business.
  That means that those users, 

04:25:37.336 --> 04:25:43.969
they value convenience over 
price.  So immediately, as soon 

04:25:43.970 --> 04:25:49.787
as a user in that group opens 
the app the first time before 

04:25:49.788 --> 04:25:53.635
they do anything.  App in the 
Air can customize the 

04:25:53.794 --> 04:25:57.706
suggestions, and the ads that 
those users see, because they 

04:25:57.707 --> 04:26:01.863
know that maybe they like luxury
 hotels or better cars or better

04:26:02.353 --> 04:26:09.370
 flights. this is what I call a 
win-win-win.  the results from 

04:26:09.371 --> 04:26:11.122
this thing was a significant 
increase, not only in the 

04:26:11.123 --> 04:26:15.165
conversion rate of how many 
people actually purchased, but 

04:26:15.166 --> 04:26:17.166
also

04:26:20.318 --> 04:26:28.818
 in the average revenue per 
paying user.  Again, win-win-win

04:26:28.819 --> 04:26:32.768
 just by looking at data and 
data decisions.  So, back to 

04:26:32.915 --> 04:26:39.404
Rony.  She starts using Firebase
 to validate her ideas and now 

04:26:39.405 --> 04:26:42.917
super happy.   a picture from t
oday, actually, that she sent 

04:26:43.068 --> 04:26:47.313
me.  super happy with new 
friends for her and her dog, 

04:26:50.552 --> 04:26:54.748
Nala.  So for more information 
about Firebase Analytics and 

04:26:54.749 --> 04:26:58.308
remote config and how you can 
start using it today to validate

04:26:58.879 --> 04:27:03.588
 your ideas, run experiments and
 optimize everything in your 

04:27:03.888 --> 04:27:08.229
app, go to our docs, our 
support, and office hours today,

04:27:08.601 --> 04:27:11.108
 we just ran out of them.  There
 are office hours tomorrow and 

04:27:11.434 --> 04:27:14.005
Friday, look for the people with
 the yellow shirts that are 

04:27:14.006 --> 04:27:18.059
hanging around here.  They will 
be more than happy to help you 

04:27:18.060 --> 04:27:21.079
integrate Firebase today.  Thank
 you, everybody. Now, if you 

04:27:21.080 --> 04:27:25.763
have questions, I have some 
time.  We have some time.  

04:27:33.642 --> 04:27:35.642
 For this side.  

04:27:48.412 --> 04:27:52.339
  Either nobody listened or 
everybody understood everything.

