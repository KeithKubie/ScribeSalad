WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.234
[MUSIC PLAYING]

00:00:05.764 --> 00:00:07.180
TIM MURRAY: My
name is Tim Murray,

00:00:07.180 --> 00:00:09.090
and I work on the
Android performance team.

00:00:09.090 --> 00:00:12.430
And we're going to talk
today about improving

00:00:12.430 --> 00:00:14.870
your application's
performance on Android.

00:00:18.240 --> 00:00:21.660
Now one of the big things that
the Android performance has

00:00:21.660 --> 00:00:25.350
done in the past year was
to optimize the performance

00:00:25.350 --> 00:00:28.650
of the Google Pixel.

00:00:28.650 --> 00:00:33.960
We looked at everything on the
Pixel, from application code

00:00:33.960 --> 00:00:37.050
all the way down to the
kernel, everything in between.

00:00:37.050 --> 00:00:38.520
We tweaked things.

00:00:38.520 --> 00:00:40.740
We experimented with things.

00:00:40.740 --> 00:00:44.100
We replaced other
components entirely.

00:00:44.100 --> 00:00:45.610
What did we try to do here?

00:00:45.610 --> 00:00:47.760
What did we do to--

00:00:47.760 --> 00:00:50.244
what was our focus
for performance?

00:00:53.090 --> 00:00:57.900
Number one, we wanted to hit 60
frames per second all the time.

00:00:57.900 --> 00:01:02.240
This means that you have
to render a frame in 16.7

00:01:02.240 --> 00:01:04.790
milliseconds all the time.

00:01:04.790 --> 00:01:08.060
If you run at 60 frames per
second, your app looks fluid.

00:01:08.060 --> 00:01:11.180
Your app looks smooth
and responsive.

00:01:11.180 --> 00:01:14.750
If you don't run at 60 frames
per second, people notice.

00:01:14.750 --> 00:01:16.280
The phone doesn't feel fast.

00:01:16.280 --> 00:01:18.680
The phone feels like
it's struggling.

00:01:18.680 --> 00:01:22.590
So that kind of
consistency is paramount.

00:01:22.590 --> 00:01:27.090
You really want to hit 60
frames per second all the time.

00:01:27.090 --> 00:01:28.970
The second thing
we focused on was

00:01:28.970 --> 00:01:32.540
to make applications
start quickly.

00:01:32.540 --> 00:01:34.970
A user will switch
between applications a lot

00:01:34.970 --> 00:01:36.850
in the course of normal usage.

00:01:36.850 --> 00:01:38.690
You know, if I'm in
Gmail and I click

00:01:38.690 --> 00:01:41.150
a link that opens in Chrome,
I want that to go quickly.

00:01:41.150 --> 00:01:44.210
If I click a link
in, you know, Chrome

00:01:44.210 --> 00:01:47.180
that takes me to Twitter, I
want that to go quickly, too.

00:01:47.180 --> 00:01:50.240
Any time that I'm sitting
there waiting for the system

00:01:50.240 --> 00:01:53.350
to switch applications
feels like dead time.

00:01:53.350 --> 00:01:55.700
It's time when I
remember that I'm

00:01:55.700 --> 00:01:59.150
using a computer as
opposed to just interacting

00:01:59.150 --> 00:02:01.910
with that stuff I
want to get done.

00:02:01.910 --> 00:02:06.050
So reducing the amount of
time you spend switching apps

00:02:06.050 --> 00:02:08.270
makes the system
feel effortless.

00:02:08.270 --> 00:02:11.990
It's really important.

00:02:11.990 --> 00:02:12.830
That's it.

00:02:12.830 --> 00:02:16.370
That's what we focused
on system-wide for Pixel.

00:02:16.370 --> 00:02:20.750
We just wanted to hit those
two things consistently.

00:02:20.750 --> 00:02:24.020
If you do these two
things, when your device is

00:02:24.020 --> 00:02:26.090
switching between
applications very quickly

00:02:26.090 --> 00:02:30.290
and running at 60 frames
per second, it'll feel fast.

00:02:30.290 --> 00:02:33.380
But more importantly,
if your device

00:02:33.380 --> 00:02:35.960
runs at 60 frames per second
and switches between apps

00:02:35.960 --> 00:02:39.980
quickly consistently,
it does it all the time,

00:02:39.980 --> 00:02:41.870
the device stops
feeling like anything.

00:02:41.870 --> 00:02:43.940
It stops feeling like a device.

00:02:43.940 --> 00:02:46.100
Instead, it feels like
you're interacting directly

00:02:46.100 --> 00:02:47.810
with the application.

00:02:47.810 --> 00:02:50.090
And that's magical for a user.

00:02:50.090 --> 00:02:52.220
That's really important.

00:02:52.220 --> 00:02:55.430
But there's a problem
with this scenario.

00:02:57.950 --> 00:03:01.190
We run apps, and
apps can be slow.

00:03:01.190 --> 00:03:04.350
And of course, on the
system side of things,

00:03:04.350 --> 00:03:08.180
we're constantly trying
to make it easier

00:03:08.180 --> 00:03:11.150
to write fast applications
and make it harder

00:03:11.150 --> 00:03:13.820
to write slow applications.

00:03:13.820 --> 00:03:16.700
But fundamentally, as an
application developer,

00:03:16.700 --> 00:03:18.200
there's always going
to be something

00:03:18.200 --> 00:03:23.240
you can do to make the system
not run at 60 frames per second

00:03:23.240 --> 00:03:26.810
or make your app start
up really slowly.

00:03:26.810 --> 00:03:30.240
The issue is that from the
point of view of the user,

00:03:30.240 --> 00:03:34.760
they don't care that it's one
app that happens to run slowly.

00:03:34.760 --> 00:03:40.370
One app that doesn't run at 60
fps or doesn't start up quickly

00:03:40.370 --> 00:03:43.550
ruins that whole magical
feeling of a device.

00:03:43.550 --> 00:03:46.850
And it reminds them that they're
not interacting with an app.

00:03:46.850 --> 00:03:49.610
They're touching their
phone, and then they

00:03:49.610 --> 00:03:52.070
want to throw their
phone against the wall.

00:03:52.070 --> 00:03:54.200
So today we're going
to talk about two tools

00:03:54.200 --> 00:03:58.280
that we used during
Pixel really extensively

00:03:58.280 --> 00:04:01.260
to analyze performance
and help you

00:04:01.260 --> 00:04:04.430
as app developers figure out
what you can do to improve

00:04:04.430 --> 00:04:07.400
your application's performance.

00:04:07.400 --> 00:04:12.680
The first tool we're going to
talk about is called gfx info.

00:04:12.680 --> 00:04:17.000
So gfx info is a shell
command that you can

00:04:17.000 --> 00:04:19.310
use on the device via dumpsys.

00:04:19.310 --> 00:04:23.540
And all it does is it tell
you about the rendering

00:04:23.540 --> 00:04:26.310
time for your application.

00:04:26.310 --> 00:04:31.430
So here we can see that
we rendered 223 frames.

00:04:31.430 --> 00:04:35.840
We get the average frame time,
the 90th, 95th, 99th percentile

00:04:35.840 --> 00:04:36.950
frame time.

00:04:36.950 --> 00:04:41.900
And then it gives us some idea
of why things were actually

00:04:41.900 --> 00:04:43.850
slow.

00:04:43.850 --> 00:04:46.820
We use this a lot
internally, and we really

00:04:46.820 --> 00:04:50.035
just look at average
frame time, 90th, 95th,

00:04:50.035 --> 00:04:53.060
and 99th percentile frame time.

00:04:53.060 --> 00:04:54.230
And that's it.

00:04:54.230 --> 00:04:55.760
That's all this tool does.

00:04:55.760 --> 00:04:58.550
It doesn't tell you
why your app ran slow.

00:04:58.550 --> 00:05:02.120
It doesn't tell you anything
that you should do to fix it.

00:05:02.120 --> 00:05:06.050
So why am I up here
talking about it?

00:05:06.050 --> 00:05:09.390
Because you can automate it.

00:05:09.390 --> 00:05:11.855
If you take one thing
away from this talk,

00:05:11.855 --> 00:05:15.530
if you decide to take a
nap for the next half hour,

00:05:15.530 --> 00:05:21.650
just run gfx info at the very
end of whatever automated task

00:05:21.650 --> 00:05:22.850
you're running.

00:05:22.850 --> 00:05:25.550
And congratulations, now
you have a performance test.

00:05:25.550 --> 00:05:29.750
Now you have a thing you
can run regressions on.

00:05:29.750 --> 00:05:32.840
You can spot regressions
in your application.

00:05:32.840 --> 00:05:35.240
The first time you have
a performance regression

00:05:35.240 --> 00:05:39.560
in your application that
you want to track down,

00:05:39.560 --> 00:05:43.100
this will save you so
much time and effort,

00:05:43.100 --> 00:05:46.440
it will pay for
itself instantly.

00:05:46.440 --> 00:05:50.690
This is how most of the internal
Android jank tests work.

00:05:50.690 --> 00:05:53.630
This is how we track all
jank across the system.

00:05:53.630 --> 00:05:55.770
It's incredibly useful.

00:05:55.770 --> 00:05:56.750
Please just do it.

00:05:56.750 --> 00:06:00.274
You'll save yourself
so much time.

00:06:00.274 --> 00:06:02.000
But OK, that's gfx info.

00:06:02.000 --> 00:06:06.294
That only tells you where
your performance is today.

00:06:06.294 --> 00:06:08.460
It doesn't tell you why
your performance is that way

00:06:08.460 --> 00:06:10.310
or what you should do about it.

00:06:10.310 --> 00:06:12.290
For that we have to turn
to a different tool,

00:06:12.290 --> 00:06:16.620
my favorite tool, really,
the only tool I ever use--

00:06:16.620 --> 00:06:17.810
Systrace.

00:06:17.810 --> 00:06:21.500
So a lot of developers
have tried Systrace,

00:06:21.500 --> 00:06:23.900
and they've told me they
have no idea what's going

00:06:23.900 --> 00:06:25.450
on when they look at Systrace.

00:06:25.450 --> 00:06:26.390
And that's fair.

00:06:26.390 --> 00:06:29.990
I can stand up here and tell
you that Systrace is easy.

00:06:29.990 --> 00:06:33.000
It's not really easy.

00:06:33.000 --> 00:06:35.660
Systrace is not a CPU profiler.

00:06:35.660 --> 00:06:40.890
Systrace is instead a
system wide tracing tool.

00:06:40.890 --> 00:06:42.860
The first thing that
means is, Systrace

00:06:42.860 --> 00:06:44.240
doesn't care about your app.

00:06:44.240 --> 00:06:47.420
It doesn't do anything
special to your application.

00:06:47.420 --> 00:06:50.660
It's not going to go
peek at your applications

00:06:50.660 --> 00:06:53.180
call stacks and say, hey,
you spent a really long time

00:06:53.180 --> 00:06:54.770
in this function.

00:06:54.770 --> 00:06:55.890
It doesn't do that.

00:06:55.890 --> 00:06:57.950
It just tells you
when your application

00:06:57.950 --> 00:06:59.930
was running and
certain events that

00:06:59.930 --> 00:07:03.780
occur within your application.

00:07:03.780 --> 00:07:07.702
It also tells you everything
about the rest of the system.

00:07:07.702 --> 00:07:09.410
It will tell you things
about the kernel.

00:07:09.410 --> 00:07:11.493
It'll tell you things about
the graphics pipeline.

00:07:11.493 --> 00:07:15.510
It will tell you things about
the framework and activity

00:07:15.510 --> 00:07:17.340
manager and things like that.

00:07:17.340 --> 00:07:18.990
Really, if there's
any information

00:07:18.990 --> 00:07:21.090
you want about an
Android device,

00:07:21.090 --> 00:07:24.570
we have probably
surfaced it via Systrace.

00:07:24.570 --> 00:07:27.300
We use it for everything.

00:07:27.300 --> 00:07:31.560
Just to be-- just to reinforce
how important Systrace is,

00:07:31.560 --> 00:07:37.380
in the past year, I've looked
at somewhere over 2,000 traces.

00:07:37.380 --> 00:07:40.980
We use Systrace a whole lot.

00:07:40.980 --> 00:07:43.410
Now Systrace is not
in Android Studio.

00:07:43.410 --> 00:07:46.500
If you want to get Systrace,
there are two ways to get it.

00:07:46.500 --> 00:07:50.250
First of all, it's in platform
tools in the Android SDK.

00:07:50.250 --> 00:07:52.950
You can get a version
of Systrace from there.

00:07:52.950 --> 00:07:54.820
What I like to do,
though, is I get

00:07:54.820 --> 00:07:57.570
Systrace from the repository
where it's developed.

00:07:57.570 --> 00:08:02.530
It's part of a project called
Catapult, which is on GitHub.

00:08:02.530 --> 00:08:03.030
Cantabile?

00:08:03.030 --> 00:08:05.670
Catapult is owned by members of
the Google Chrome and Android

00:08:05.670 --> 00:08:07.150
teams.

00:08:07.150 --> 00:08:10.150
So upstream Catapult
is always improving.

00:08:10.150 --> 00:08:11.400
There are always new features.

00:08:11.400 --> 00:08:15.060
I usually get top
of tree Catapult.

00:08:15.060 --> 00:08:18.360
Once you get that, you'll have
this Python executable that you

00:08:18.360 --> 00:08:22.860
can run, and you
can get a trace.

00:08:22.860 --> 00:08:24.370
Now how does Systrace
actually work?

00:08:24.370 --> 00:08:27.080
What does it actually tell you?

00:08:27.080 --> 00:08:30.450
Systrace is three components.

00:08:30.450 --> 00:08:33.770
At the bottom is this
thing called ftrace.

00:08:33.770 --> 00:08:41.070
Ftrace is a Linux kernel feature
that allows the kernel and user

00:08:41.070 --> 00:08:46.500
space to write event information
into a central buffer.

00:08:46.500 --> 00:08:48.990
What this means,
basically, is that you

00:08:48.990 --> 00:08:53.340
can get a journal of any event
that happened on the system.

00:08:53.340 --> 00:08:55.920
So the kernel will tell
us things like, hey,

00:08:55.920 --> 00:08:58.260
this process started
running on this CPU,

00:08:58.260 --> 00:09:02.730
or, hey, the clocks
changed on this CPU.

00:09:02.730 --> 00:09:03.330
That's great.

00:09:03.330 --> 00:09:07.050
It's really low level,
but we can use it.

00:09:07.050 --> 00:09:10.670
The next thing above ftrace
is a program called atrace.

00:09:10.670 --> 00:09:15.630
Atrace is a Android
program on the device that

00:09:15.630 --> 00:09:18.360
is installed automatically
and the Android image,

00:09:18.360 --> 00:09:20.280
it's on every device.

00:09:20.280 --> 00:09:23.970
All it really does is it
configures the ftrace.

00:09:23.970 --> 00:09:28.170
But it also configures
user space tracing.

00:09:28.170 --> 00:09:30.630
So atrace will go
and turn on all

00:09:30.630 --> 00:09:33.840
of these different trace points
inside of the Android user

00:09:33.840 --> 00:09:34.900
space.

00:09:34.900 --> 00:09:37.317
So here we can get
things like, you

00:09:37.317 --> 00:09:39.150
want to find out what
Window Manager thought

00:09:39.150 --> 00:09:41.220
about your application.

00:09:41.220 --> 00:09:42.450
Atrace will turn that on.

00:09:42.450 --> 00:09:45.150
Or Activity Manager,
or any other part

00:09:45.150 --> 00:09:50.460
of the Android framework, all
of that is controlled by atrace.

00:09:50.460 --> 00:09:53.890
The top most layer
is Systrace itself.

00:09:53.890 --> 00:09:58.380
Systrace then lives on your
host development machine,

00:09:58.380 --> 00:10:00.660
and it gets the
results from atrace

00:10:00.660 --> 00:10:05.820
and it wraps those results
in a nice HTML file.

00:10:05.820 --> 00:10:09.240
You get this giant,
potentially tens of megs

00:10:09.240 --> 00:10:13.696
or even hundreds of megs, HTML
file that contains a trace.

00:10:13.696 --> 00:10:16.320
So all you have to do to look at
the trace is you open the HTML

00:10:16.320 --> 00:10:17.190
file.

00:10:17.190 --> 00:10:19.080
It's pretty convenient,
and it actually

00:10:19.080 --> 00:10:23.370
makes sharing traces
incredibly easy.

00:10:23.370 --> 00:10:25.740
Now the first
thing you should do

00:10:25.740 --> 00:10:28.500
when you decide to
start tracing a device

00:10:28.500 --> 00:10:30.120
is you should look
at the categories

00:10:30.120 --> 00:10:31.900
available on that device.

00:10:31.900 --> 00:10:36.330
Systrace events are
separated into categories.

00:10:36.330 --> 00:10:39.600
And those categories
will vary from OS version

00:10:39.600 --> 00:10:44.670
the OS version, and
potentially device to device.

00:10:44.670 --> 00:10:47.550
In general, the important
stuff will always be there.

00:10:47.550 --> 00:10:50.280
The core stuff that you
want as an app developer,

00:10:50.280 --> 00:10:54.580
we have tests for that, so
they'll be on every device.

00:10:54.580 --> 00:10:56.697
Now let's actually
run a trace and see

00:10:56.697 --> 00:10:57.780
what that would look like.

00:11:00.360 --> 00:11:02.230
So this is the command
I used for the trace

00:11:02.230 --> 00:11:05.720
you'll see for the
rest of this talk.

00:11:05.720 --> 00:11:08.030
And the way Systrace
works is you

00:11:08.030 --> 00:11:15.170
provide the list of event tags
that you want in your trace.

00:11:15.170 --> 00:11:19.610
And here we have sched, which
is the kernel scheduler,

00:11:19.610 --> 00:11:23.040
we have freq for CPU
frequency information,

00:11:23.040 --> 00:11:27.620
idle will tell us about
when the CPU goes idle, am

00:11:27.620 --> 00:11:31.040
and wm tell us about the Android
Activity Manager and Window

00:11:31.040 --> 00:11:35.120
Manager, gfx will tell
us everything you ever

00:11:35.120 --> 00:11:38.489
wanted to know about the
Android graphics pipeline,

00:11:38.489 --> 00:11:40.280
view will tell you
about the view hierarchy

00:11:40.280 --> 00:11:43.790
inside applications, which
can be really useful,

00:11:43.790 --> 00:11:49.250
dalvik enables the trace
point for the Arc VM,

00:11:49.250 --> 00:11:51.830
input will tell you when you're
actually touching the screen,

00:11:51.830 --> 00:11:54.770
and binder driver will
tell you exactly when

00:11:54.770 --> 00:11:59.510
a process is making an IPC call
over binder to another process.

00:11:59.510 --> 00:12:01.680
The last three
arguments are special.

00:12:01.680 --> 00:12:05.450
Dash t just says we're going
to run the trace for 5 seconds.

00:12:05.450 --> 00:12:07.940
If you omit the dash
t, Systrace will just

00:12:07.940 --> 00:12:11.510
prompt you to press Enter
when you want to stop tracing.

00:12:11.510 --> 00:12:14.420
Dash o just controls
where you write the file.

00:12:14.420 --> 00:12:18.120
So you can write the I/O dot
HTML instead of trace dot HTML.

00:12:18.120 --> 00:12:20.840
Dash b is a little odd.

00:12:20.840 --> 00:12:24.420
So I mentioned ftrace
and the f buffer.

00:12:24.420 --> 00:12:27.560
The ftrace buffer
is a fixed size.

00:12:27.560 --> 00:12:31.310
By default, it's, I
think, 1.4 megabytes.

00:12:31.310 --> 00:12:34.190
And what happens if you fill
this buffer, if you have

00:12:34.190 --> 00:12:37.910
too many events for the buffer,
is you'll get a trace, and then

00:12:37.910 --> 00:12:40.660
at the end, things will
just kind of stop happening.

00:12:40.660 --> 00:12:42.410
You think you ran the
trace for 5 seconds,

00:12:42.410 --> 00:12:45.080
but maybe you only actually
have 3 and 1/2 seconds

00:12:45.080 --> 00:12:48.200
worth of events in there.

00:12:48.200 --> 00:12:51.130
When I take a trace, I always
increase the buffer size.

00:12:51.130 --> 00:12:54.530
So here I've increased
it to 16 megabytes.

00:12:54.530 --> 00:12:57.200
And for this kind
of trace we probably

00:12:57.200 --> 00:12:59.180
don't have to increase
the buffer size,

00:12:59.180 --> 00:13:02.240
but it's always better to
increase the buffer size

00:13:02.240 --> 00:13:07.070
and not have to take a
trace a second time then

00:13:07.070 --> 00:13:11.210
be overly conservative
with the buffer size.

00:13:11.210 --> 00:13:15.339
All right, we run this,
we now get a trace.

00:13:15.339 --> 00:13:16.880
What does a trace
actually look like?

00:13:20.010 --> 00:13:23.160
There is a lot going
on in this trace.

00:13:23.160 --> 00:13:25.140
And if you're in
the back, I'm sorry.

00:13:25.140 --> 00:13:27.930
It's probably
really hard to see.

00:13:27.930 --> 00:13:29.880
The first thing to
know about the trace

00:13:29.880 --> 00:13:34.050
is that it is a timeline view.

00:13:34.050 --> 00:13:37.620
It moves left to
right, and you can

00:13:37.620 --> 00:13:40.654
scroll it left to right, and
time moves from left to right.

00:13:40.654 --> 00:13:42.820
So the left side here is
the beginning of the trace.

00:13:42.820 --> 00:13:45.780
That's zero seconds when
we kicked off the trace.

00:13:45.780 --> 00:13:50.250
And five seconds is
when the trace ends.

00:13:50.250 --> 00:13:52.800
You can move around the trace.

00:13:52.800 --> 00:13:57.761
You can pan in time
with a and d keys,

00:13:57.761 --> 00:14:00.260
and you can zoom in and out on
whatever section of the trace

00:14:00.260 --> 00:14:03.040
you're looking at with w s.

00:14:03.040 --> 00:14:07.490
So it's just wasd, like
a first person shooter.

00:14:07.490 --> 00:14:09.550
The trace also
scrolls up and down.

00:14:09.550 --> 00:14:12.000
So here you see there are
a bunch of rows up here.

00:14:12.000 --> 00:14:15.690
There's this kernel section,
and then a calculator section.

00:14:15.690 --> 00:14:18.060
There are way more rows
than fit on the screen

00:14:18.060 --> 00:14:21.360
because there is one row
generally for every thread that

00:14:21.360 --> 00:14:23.440
is run during the trace.

00:14:23.440 --> 00:14:25.260
So you may have
hundreds or thousands

00:14:25.260 --> 00:14:28.620
of rows in your trace.

00:14:28.620 --> 00:14:32.400
The next thing to look at
when you start using Systrace

00:14:32.400 --> 00:14:35.140
is there is this
palette of tools

00:14:35.140 --> 00:14:37.672
that I have over here in
the upper right hand corner.

00:14:37.672 --> 00:14:38.880
You can click on these tools.

00:14:38.880 --> 00:14:42.210
You can also access them with
numbers one through four.

00:14:42.210 --> 00:14:43.710
Number one is the pointer.

00:14:43.710 --> 00:14:46.530
That's the main tool we
use when we use Systrace.

00:14:46.530 --> 00:14:48.630
That lets us click
the individual events

00:14:48.630 --> 00:14:52.080
that we see in the trace and
get some information about them.

00:14:52.080 --> 00:14:54.180
And when you click an
event, it will show up

00:14:54.180 --> 00:14:57.810
in the bottom half of
the screen like that.

00:14:57.810 --> 00:15:00.870
So here we can see
calculator was running,

00:15:00.870 --> 00:15:04.950
we see the process ID, we see
the thread ID, the priority,

00:15:04.950 --> 00:15:07.460
we can see when exactly
it started in the trace,

00:15:07.460 --> 00:15:09.080
we see how long it ran for.

00:15:09.080 --> 00:15:11.400
You get a bunch of
useful statistics.

00:15:11.400 --> 00:15:13.230
You can also use the
pointer to select

00:15:13.230 --> 00:15:16.110
a lot of different things
in the trace, which

00:15:16.110 --> 00:15:21.010
gives you a aggregate
view that looks like that.

00:15:21.010 --> 00:15:23.700
And so this will
basically add up

00:15:23.700 --> 00:15:29.070
all of the threads, like if I
select the region in the kernel

00:15:29.070 --> 00:15:32.019
section here, this will add
up all of the threads that

00:15:32.019 --> 00:15:33.435
occurred and tell
us how much time

00:15:33.435 --> 00:15:34.940
did we spend in each thread.

00:15:34.940 --> 00:15:38.370
Well, what was the average
time that each thread ran?

00:15:38.370 --> 00:15:40.050
Things like that.

00:15:40.050 --> 00:15:40.950
That's really useful.

00:15:40.950 --> 00:15:44.200
We'll come back to that later.

00:15:44.200 --> 00:15:48.030
Number two and
three on the palette

00:15:48.030 --> 00:15:49.380
are for panning and zooming.

00:15:49.380 --> 00:15:51.955
So they're equivalent to wasd.

00:15:51.955 --> 00:15:53.080
You don't need to use them.

00:15:53.080 --> 00:15:54.810
You can use them if you want.

00:15:54.810 --> 00:15:57.380
I generally just use wasd.

00:15:57.380 --> 00:16:00.060
The fourth tool though
is incredibly useful.

00:16:00.060 --> 00:16:03.180
It is the highlighter tool.

00:16:03.180 --> 00:16:07.170
So you can select a region
of time in the trace.

00:16:07.170 --> 00:16:11.280
And that region will
have a white background,

00:16:11.280 --> 00:16:12.920
and everything you
haven't selected

00:16:12.920 --> 00:16:15.750
will then have a
gray background.

00:16:15.750 --> 00:16:18.480
You can use this to keep track
of the area you care about

00:16:18.480 --> 00:16:20.700
as you scroll vertically
through a trace.

00:16:20.700 --> 00:16:23.220
So if you find
something in one process

00:16:23.220 --> 00:16:26.110
and you think, something
went wrong here,

00:16:26.110 --> 00:16:27.930
what else was the
system doing, you

00:16:27.930 --> 00:16:30.690
can scroll up and down
the trace and know exactly

00:16:30.690 --> 00:16:33.930
what part of the trace
you should be looking at.

00:16:33.930 --> 00:16:36.540
I use the highlighter
constantly.

00:16:36.540 --> 00:16:40.570
If you start using Systrace,
you probably will as well.

00:16:40.570 --> 00:16:45.930
Now let's scroll down and see
what else is in the trace.

00:16:45.930 --> 00:16:47.770
More stuff.

00:16:47.770 --> 00:16:53.430
So every row in a trace is
either a counter or a thread.

00:16:53.430 --> 00:16:58.680
And down here at the
bottom is a thread.

00:16:58.680 --> 00:17:03.870
These blocks right
here are the core thing

00:17:03.870 --> 00:17:06.450
that you will look
at in Systrace.

00:17:06.450 --> 00:17:08.369
These are events.

00:17:08.369 --> 00:17:15.025
So every Systrace event
has a beginning and an end.

00:17:15.025 --> 00:17:17.690
Systrace events
can then be nested.

00:17:17.690 --> 00:17:20.859
So this is a stack
that grows down.

00:17:20.859 --> 00:17:24.180
You can see that here a
choreographer event happened,

00:17:24.180 --> 00:17:28.210
and a traversal event
was contained entirely

00:17:28.210 --> 00:17:31.720
within that event, and more
things happened beneath.

00:17:31.720 --> 00:17:36.090
This is some stuff that's part
of a calculator app startup.

00:17:36.090 --> 00:17:41.110
And you will see a lot of these
as you look through a trace.

00:17:41.110 --> 00:17:46.000
Each event it corresponds to
explicit place in the Android

00:17:46.000 --> 00:17:49.240
code base that somebody
thought, hey, maybe somebody

00:17:49.240 --> 00:17:52.290
will need to figure out that
this is happening sometime.

00:17:52.290 --> 00:17:54.520
It's good to pay
attention to these.

00:17:54.520 --> 00:17:57.230
Now let's zoom in on
the beginning of--

00:17:57.230 --> 00:18:00.040
or at the end of Activity
Start for calculator.

00:18:00.040 --> 00:18:02.890
So in this trace, we
launched calculator

00:18:02.890 --> 00:18:04.780
and clicked a few buttons.

00:18:04.780 --> 00:18:07.570
Here we are at the very
end of Activity Start.

00:18:07.570 --> 00:18:10.630
And I zoomed in really closely,
and it's still probably

00:18:10.630 --> 00:18:13.720
hard to see because Systrace
has a lot of very small UI

00:18:13.720 --> 00:18:15.330
elements.

00:18:15.330 --> 00:18:21.370
But there are these colored bars
on top of the UI thread here.

00:18:21.370 --> 00:18:24.550
These colored bars
represent the state

00:18:24.550 --> 00:18:28.810
of that thread at
any point in time.

00:18:28.810 --> 00:18:33.790
There are five different
states that a thread can be in.

00:18:33.790 --> 00:18:37.500
Now if we click the green
bar above the UI thread

00:18:37.500 --> 00:18:40.120
in the middle, we see
that at this point

00:18:40.120 --> 00:18:41.710
the thread was running.

00:18:41.710 --> 00:18:44.560
So at this point, the thread
is actually running on a CPU.

00:18:44.560 --> 00:18:45.839
It's running on CPU 1.

00:18:45.839 --> 00:18:48.130
And if we were to scroll back
up to the kernel section,

00:18:48.130 --> 00:18:51.430
we would see it's
scheduled on CPU 1.

00:18:51.430 --> 00:18:54.610
This is how you can know that
your application is actually

00:18:54.610 --> 00:18:57.600
running at particular
times on the CPU.

00:19:00.680 --> 00:19:04.370
The next state that we
care about is runnable.

00:19:04.370 --> 00:19:07.940
Runnable means that
your thread could start

00:19:07.940 --> 00:19:09.350
running at some point in time.

00:19:09.350 --> 00:19:11.960
Nothing is preventing
your thread from running.

00:19:11.960 --> 00:19:15.171
It's just that the kernel
has not scheduled it yet.

00:19:15.171 --> 00:19:17.420
There are any number of
reasons why this could happen.

00:19:17.420 --> 00:19:19.790
Maybe there's more
higher priority work.

00:19:19.790 --> 00:19:23.340
Maybe your thread has just
run for a really long time,

00:19:23.340 --> 00:19:26.030
and a scheduler is trying to
be fair and give other threads

00:19:26.030 --> 00:19:28.730
an opportunity to run.

00:19:28.730 --> 00:19:31.010
There are lots of
reasons for this.

00:19:31.010 --> 00:19:33.320
But if you're seeing a lot
of this in your application,

00:19:33.320 --> 00:19:36.800
it's probably due
to thread priority.

00:19:36.800 --> 00:19:40.490
The third thing that you
can see on the right hand

00:19:40.490 --> 00:19:44.120
side of the trace here
is there's a red bar.

00:19:44.120 --> 00:19:47.210
And the red bar is
uninterruptible sleep,

00:19:47.210 --> 00:19:49.960
which sounds a little
scarier than it is.

00:19:49.960 --> 00:19:53.060
Uninterruptible
sleep is your thread

00:19:53.060 --> 00:19:57.260
is blocked on some lock
inside of the kernel.

00:19:57.260 --> 00:19:59.000
As an application
developer, there's

00:19:59.000 --> 00:20:01.250
generally not much
you can do with this.

00:20:01.250 --> 00:20:03.540
Sometimes it's hardware related.

00:20:03.540 --> 00:20:06.560
Sometimes it has
to do with memory.

00:20:06.560 --> 00:20:10.760
Usually, if you see a lot
of uninterruptible sleep,

00:20:10.760 --> 00:20:14.510
it's my fault. It's
a system problem.

00:20:14.510 --> 00:20:18.290
So we're probably aware
and trying to fix it.

00:20:18.290 --> 00:20:21.049
But sometimes you can see
it's related to memory.

00:20:21.049 --> 00:20:22.840
You can get some more
information about it.

00:20:25.720 --> 00:20:30.190
The fourth type of
state is a special kind

00:20:30.190 --> 00:20:32.800
of uninterruptible sleep that
as an application developer

00:20:32.800 --> 00:20:36.040
you can actually
do something about.

00:20:36.040 --> 00:20:39.010
The orange state here
is your sleeping--

00:20:39.010 --> 00:20:42.010
your thread is sleeping
on block I/O. This means

00:20:42.010 --> 00:20:43.900
that your thread is
reading from disk,

00:20:43.900 --> 00:20:47.110
and the disk hasn't gotten the
results back to your thread,

00:20:47.110 --> 00:20:49.330
so your thread
can't make progress.

00:20:49.330 --> 00:20:51.670
If you see a lot of
this in your trace,

00:20:51.670 --> 00:20:53.260
you're just reading
too much data.

00:20:53.260 --> 00:20:56.440
Try not to read so much data.

00:20:56.440 --> 00:20:58.300
The fifth state,
the last state, is

00:20:58.300 --> 00:21:02.105
the state you'll see most often,
and it's usually white or gray,

00:21:02.105 --> 00:21:03.730
depending on the back
end of the trace.

00:21:03.730 --> 00:21:06.430
It just means the
thread is sleeping.

00:21:06.430 --> 00:21:10.420
The thread has no work
to do, so it is asleep.

00:21:10.420 --> 00:21:11.330
It's not running.

00:21:11.330 --> 00:21:13.120
The scheduler isn't
trying to run it.

00:21:13.120 --> 00:21:15.100
Nothing is working on
behalf of that thread

00:21:15.100 --> 00:21:18.040
directly in the kernel
or anything like that.

00:21:18.040 --> 00:21:21.130
If you see this a lot and
you think that's weird,

00:21:21.130 --> 00:21:26.080
it's probably due to some
user space lock interaction

00:21:26.080 --> 00:21:28.510
because user space locks
will show up as sleeping.

00:21:34.060 --> 00:21:36.370
The last thing you can do
with these colored bars that

00:21:36.370 --> 00:21:39.790
is really great is you can
select all of them in a region

00:21:39.790 --> 00:21:42.830
that you care about to
get aggregate information.

00:21:42.830 --> 00:21:44.620
So here we can see
we spent so much time

00:21:44.620 --> 00:21:47.560
sleeping versus
runnable versus running.

00:21:47.560 --> 00:21:49.810
I do this constantly.

00:21:49.810 --> 00:21:53.890
This gives me a
really coarse idea

00:21:53.890 --> 00:21:59.140
of what the bottleneck is for
a particular piece of code.

00:21:59.140 --> 00:22:02.990
I can take a trace and see,
hey, this thread is running.

00:22:02.990 --> 00:22:04.170
It's on the CPU.

00:22:04.170 --> 00:22:07.300
It should be making progress,
but it's just taking too long.

00:22:07.300 --> 00:22:08.500
What's going on?

00:22:08.500 --> 00:22:11.440
It means that it just has
too much CPU work to do.

00:22:11.440 --> 00:22:13.690
If it's getting CPU time
and not running fast enough,

00:22:13.690 --> 00:22:15.731
all you can really do is
reduce the amount of CPU

00:22:15.731 --> 00:22:17.200
work it has to do.

00:22:17.200 --> 00:22:20.140
Now if I take a trace and I
see that a thread is always

00:22:20.140 --> 00:22:22.930
in block I/O, then
I know it's reading

00:22:22.930 --> 00:22:24.740
too much data from disk.

00:22:24.740 --> 00:22:27.010
So don't read so
much data from disk.

00:22:30.810 --> 00:22:32.560
If you're sleeping
where you don't expect,

00:22:32.560 --> 00:22:34.634
it probably means that
your application logic

00:22:34.634 --> 00:22:35.800
is a little weird somewhere.

00:22:35.800 --> 00:22:38.650
You probably have some
weird priority inversion

00:22:38.650 --> 00:22:42.430
to something, or lock contention
that you didn't expect,

00:22:42.430 --> 00:22:44.870
something like that.

00:22:44.870 --> 00:22:48.640
Another useful tool on a trace
is I mentioned the input tag

00:22:48.640 --> 00:22:49.870
earlier.

00:22:49.870 --> 00:22:52.860
And up here at the
very top, there

00:22:52.860 --> 00:22:55.900
is this tiny little
box for input response.

00:22:55.900 --> 00:22:57.700
And this shows where
I actually touched

00:22:57.700 --> 00:22:59.420
the screen and the trace.

00:22:59.420 --> 00:23:02.320
So here I touched the screen,
and I guess my finger was down

00:23:02.320 --> 00:23:05.650
for 28.8 milliseconds.

00:23:05.650 --> 00:23:08.610
You can use that in a trace
similar to the highlighter.

00:23:08.610 --> 00:23:11.530
You could use that to orient
yourself in the trace.

00:23:11.530 --> 00:23:13.840
You know what's going on.

00:23:13.840 --> 00:23:17.650
If you remember what you were
doing while creating the trace,

00:23:17.650 --> 00:23:22.060
you can figure out where
exactly you are logically inside

00:23:22.060 --> 00:23:24.530
that trace.

00:23:24.530 --> 00:23:26.690
But what if you need more
information than this?

00:23:26.690 --> 00:23:28.231
What if you have a
lot of information

00:23:28.231 --> 00:23:30.550
about what your app is
doing logically that you

00:23:30.550 --> 00:23:32.061
want to get in a trace?

00:23:32.061 --> 00:23:32.560
Good news.

00:23:32.560 --> 00:23:34.810
That's pretty easy.

00:23:34.810 --> 00:23:37.510
So there is a class,
Android dot os got

00:23:37.510 --> 00:23:39.640
trace, that has two methods--

00:23:39.640 --> 00:23:42.880
begin section and end section.

00:23:42.880 --> 00:23:46.810
If you put-- you can put
a string in begin section,

00:23:46.810 --> 00:23:49.350
and that will just show up
as an event in the trace.

00:23:49.350 --> 00:23:51.520
It shows up the same
as anything else.

00:23:51.520 --> 00:23:53.560
The only special thing
you need to keep in mind

00:23:53.560 --> 00:23:55.930
here is you need to
call trace dot end

00:23:55.930 --> 00:23:58.630
section from the same
thread every time you

00:23:58.630 --> 00:24:00.400
have a begin section.

00:24:00.400 --> 00:24:02.560
If you don't have a
one-to-one mapping

00:24:02.560 --> 00:24:05.260
between begin section
and end section,

00:24:05.260 --> 00:24:07.750
your trace will look weird.

00:24:07.750 --> 00:24:11.110
You will get very weird
rendering in your trace.

00:24:11.110 --> 00:24:14.373
And it's just because
you forgot a end section

00:24:14.373 --> 00:24:17.710
or you had too
many end sections.

00:24:17.710 --> 00:24:20.440
If we take a trace, and we
want to see the app events,

00:24:20.440 --> 00:24:24.040
we have to do a little bit
more than we did initially.

00:24:24.040 --> 00:24:27.790
First, we specify
this app tag as part

00:24:27.790 --> 00:24:29.800
of the arguments to
the trace, and then we

00:24:29.800 --> 00:24:32.710
have to pass dash a
and the package name

00:24:32.710 --> 00:24:34.720
that you care about.

00:24:34.720 --> 00:24:37.030
Then you just take a
normal trace like that

00:24:37.030 --> 00:24:43.690
and you open it up, and
you see this trace event,

00:24:43.690 --> 00:24:47.470
which is just whatever
you put in your string.

00:24:47.470 --> 00:24:53.110
If you have logical groupings
of work or a logical task

00:24:53.110 --> 00:24:57.160
that the user is doing,
adding a trace event for that

00:24:57.160 --> 00:24:58.390
is really useful.

00:24:58.390 --> 00:25:03.640
When I look at large, complex
applications within Google,

00:25:03.640 --> 00:25:07.520
I find that the applications I
can debug easily and understand

00:25:07.520 --> 00:25:09.400
performance of easily
are the ones that

00:25:09.400 --> 00:25:13.227
implement their own
application trace events.

00:25:13.227 --> 00:25:14.560
I definitely recommend doing it.

00:25:14.560 --> 00:25:18.067
It's not that difficult, and
it will be worth it as you

00:25:18.067 --> 00:25:19.150
start looking at Systrace.

00:25:19.150 --> 00:25:23.210
It will make Systrace a
lot more comprehensible.

00:25:23.210 --> 00:25:28.370
And for reading a
trace, that's about it.

00:25:28.370 --> 00:25:32.290
There's not really that
much going on in a trace.

00:25:32.290 --> 00:25:34.220
It's just sort of
what the system is

00:25:34.220 --> 00:25:35.420
doing at any point in time.

00:25:35.420 --> 00:25:38.720
And everything that the system
is doing at any point in time

00:25:38.720 --> 00:25:39.920
ends up looking like this.

00:25:42.570 --> 00:25:44.310
So now what?

00:25:44.310 --> 00:25:48.000
I don't think most of you
probably feel that comfortable

00:25:48.000 --> 00:25:49.470
using Systrace yet.

00:25:49.470 --> 00:25:52.170
So why would we want
to use Systrace?

00:25:52.170 --> 00:25:56.380
What is Systrace going to tell
us that makes it so useful?

00:25:56.380 --> 00:26:00.510
Let's go back to the two
goals that we had for Pixel.

00:26:00.510 --> 00:26:02.430
Number one, 60
frames per second.

00:26:02.430 --> 00:26:04.419
Number two, it makes
appa start quickly.

00:26:04.419 --> 00:26:06.210
OK, yes, Systrace could
tell us some things

00:26:06.210 --> 00:26:07.620
about this directly.

00:26:07.620 --> 00:26:09.930
But there is an
underlying principle here

00:26:09.930 --> 00:26:13.360
that we should call out.

00:26:13.360 --> 00:26:15.000
Don't look slow.

00:26:15.000 --> 00:26:15.610
That's it.

00:26:15.610 --> 00:26:20.250
That's really the only
performance rule there is.

00:26:20.250 --> 00:26:22.830
The reason why we
use Systrace is it

00:26:22.830 --> 00:26:25.370
can tell us where we look slow.

00:26:25.370 --> 00:26:27.670
And note that I said,
don't look slow.

00:26:27.670 --> 00:26:31.410
I didn't say, don't be slow.

00:26:31.410 --> 00:26:33.540
This may sound weird
coming from a person who

00:26:33.540 --> 00:26:37.740
works on performance, but
for any moderately complex

00:26:37.740 --> 00:26:40.360
application, at
some point in time,

00:26:40.360 --> 00:26:44.040
you're going to have to
do something that is slow.

00:26:44.040 --> 00:26:46.650
Maybe you're going to do
some giant matrix multiply

00:26:46.650 --> 00:26:47.820
for some reason.

00:26:47.820 --> 00:26:49.860
Maybe you're going
to read from disk.

00:26:49.860 --> 00:26:51.690
You have to read a large image.

00:26:51.690 --> 00:26:54.300
Maybe you have to talk
to the network, which

00:26:54.300 --> 00:26:58.140
could take who knows how long.

00:26:58.140 --> 00:27:01.170
At that point, you
want to understand

00:27:01.170 --> 00:27:03.330
why did the system
end up looking slow

00:27:03.330 --> 00:27:05.610
when I was doing this,
and then what can I

00:27:05.610 --> 00:27:07.650
do to work around this.

00:27:07.650 --> 00:27:10.290
You know you have to
do this slow thing.

00:27:10.290 --> 00:27:13.020
What can you do in
your application

00:27:13.020 --> 00:27:16.050
to identify where exactly that
slow point happened, and then

00:27:16.050 --> 00:27:20.400
work around it to make the
system still look fast?

00:27:20.400 --> 00:27:22.110
Because that's all
the user care about.

00:27:22.110 --> 00:27:25.950
They don't care if the
system is slow or is fast.

00:27:25.950 --> 00:27:28.410
They just want the
system to feel fast.

00:27:28.410 --> 00:27:31.800
If you do that, it'll be great.

00:27:31.800 --> 00:27:38.070
Now let's apply that to
the two goals that we had.

00:27:38.070 --> 00:27:39.696
App startup.

00:27:39.696 --> 00:27:41.570
The basic thing with
Systrace and app startup

00:27:41.570 --> 00:27:43.890
is you can use
Systrace to figure out

00:27:43.890 --> 00:27:47.370
exactly where your time is
going during app startup.

00:27:47.370 --> 00:27:49.870
Then you can decide
what to do about it.

00:27:49.870 --> 00:27:52.920
And there's no one size
fits all advice here.

00:27:52.920 --> 00:27:54.420
Really you have
to understand what

00:27:54.420 --> 00:27:55.980
your particular
application is doing,

00:27:55.980 --> 00:27:58.620
what the needs of
your application are,

00:27:58.620 --> 00:28:00.390
and then you can come
up with a solution.

00:28:04.640 --> 00:28:06.530
The first thing that
we use Systrace for

00:28:06.530 --> 00:28:10.340
to analyze app startup
is view inflation.

00:28:10.340 --> 00:28:12.864
Here we have this inflate
section in a trace.

00:28:12.864 --> 00:28:14.780
This is from the very
beginning of calculator,

00:28:14.780 --> 00:28:17.930
from Activity Start
in calculator.

00:28:17.930 --> 00:28:20.360
And we have this really
long inflate section.

00:28:20.360 --> 00:28:24.320
But more importantly, we can
see the exact cost of inflating

00:28:24.320 --> 00:28:27.740
every view for calculator.

00:28:27.740 --> 00:28:29.690
This is really useful
to help you figure out

00:28:29.690 --> 00:28:34.580
the cost of a view hierarchy
or changing of view hierarchy.

00:28:34.580 --> 00:28:38.139
You can say, is it
actually worth 50

00:28:38.139 --> 00:28:40.180
milliseconds to inflate
all these ways right now?

00:28:40.180 --> 00:28:41.096
Could I do this later?

00:28:41.096 --> 00:28:43.250
Could I do something
else instead?

00:28:43.250 --> 00:28:45.020
You have to come up
with whatever solution

00:28:45.020 --> 00:28:46.520
is right for your application.

00:28:46.520 --> 00:28:48.440
But Systrace can
help you figure out

00:28:48.440 --> 00:28:51.420
what is actually happening
today in your application.

00:28:51.420 --> 00:28:55.490
So you can come up with those
improvements and those ideas

00:28:55.490 --> 00:28:58.470
for future changes to your app.

00:29:01.810 --> 00:29:04.120
Another thing that
Systrace tells you is you

00:29:04.120 --> 00:29:07.480
can tell exactly when
application startup ended

00:29:07.480 --> 00:29:09.470
from the user's point of view.

00:29:09.470 --> 00:29:11.830
There's more than just bind
application and Activity

00:29:11.830 --> 00:29:14.380
Start in application startup.

00:29:14.380 --> 00:29:16.510
Here you can actually see
the UI thread and render

00:29:16.510 --> 00:29:17.884
thread of your
application, which

00:29:17.884 --> 00:29:20.920
are the two most important
threads in making

00:29:20.920 --> 00:29:23.700
your application run at
60 frames per second.

00:29:23.700 --> 00:29:27.670
And we know that once
those threads have

00:29:27.670 --> 00:29:29.890
finished for the first time--

00:29:29.890 --> 00:29:34.540
here you could see the UI
thread running and finishing

00:29:34.540 --> 00:29:37.630
this choreographer doFrame
along with the render thread

00:29:37.630 --> 00:29:39.010
running at the same time--

00:29:39.010 --> 00:29:42.640
once that's done, the
app is actually loaded

00:29:42.640 --> 00:29:45.220
and ready for user input.

00:29:45.220 --> 00:29:48.100
At that point from the
user's point of view,

00:29:48.100 --> 00:29:49.300
app startup is done.

00:29:53.430 --> 00:29:58.560
Another useful thing in Systrace
is the resource tag, res.

00:29:58.560 --> 00:30:01.890
So you can look at
exactly what resources

00:30:01.890 --> 00:30:03.720
you're loading in
your application

00:30:03.720 --> 00:30:05.550
at any point in time.

00:30:05.550 --> 00:30:09.180
Usually, loading resources
is not a huge deal.

00:30:09.180 --> 00:30:12.300
Occasionally, we've seen
areas where resource loading

00:30:12.300 --> 00:30:13.660
can be expensive.

00:30:13.660 --> 00:30:15.910
It's worth checking
in your application.

00:30:15.910 --> 00:30:18.360
It will tell you, just
as the name of an event,

00:30:18.360 --> 00:30:23.370
exactly what resource you're
loading and how long it takes.

00:30:23.370 --> 00:30:25.277
And again, you can
figure out, is it worth

00:30:25.277 --> 00:30:26.610
letting this resource right now?

00:30:29.480 --> 00:30:32.540
All right, let's move to jank,
because that's the more fun

00:30:32.540 --> 00:30:34.040
one.

00:30:34.040 --> 00:30:38.150
Fixing jank with Systrace
is a two-step process.

00:30:38.150 --> 00:30:41.300
Number one, you need to figure
out where the jank actually

00:30:41.300 --> 00:30:44.660
happened because
maybe you can spot

00:30:44.660 --> 00:30:47.810
every time the system doesn't
run at 60 frames per second.

00:30:47.810 --> 00:30:51.140
But I've been doing this
full-time for a while now,

00:30:51.140 --> 00:30:52.460
I can't even do that.

00:30:52.460 --> 00:30:58.370
So Systrace can help make it
really obvious where exactly

00:30:58.370 --> 00:30:59.720
you dropped a frame.

00:30:59.720 --> 00:31:01.470
The second step that
you use Systrace

00:31:01.470 --> 00:31:04.070
for is working your
way backwards from the

00:31:04.070 --> 00:31:06.751
dropped frame to what
actually went wrong.

00:31:06.751 --> 00:31:08.750
And then you can figure
out what to do about it.

00:31:11.820 --> 00:31:14.120
So here we have a UI thread
and render thread, again,

00:31:14.120 --> 00:31:15.740
in an application.

00:31:15.740 --> 00:31:18.740
And we're running the thread,
or the application, normally.

00:31:18.740 --> 00:31:20.240
It's not a janky frame.

00:31:20.240 --> 00:31:25.300
It's just normal 60 frame
per second rendering.

00:31:25.300 --> 00:31:27.640
The UI thread is the
main application thread.

00:31:27.640 --> 00:31:32.330
That's what actually gets input
events from system server.

00:31:32.330 --> 00:31:35.130
Render thread actually gets
information from the UI thread

00:31:35.130 --> 00:31:38.000
and sends that to the GPU.

00:31:38.000 --> 00:31:40.460
This means that in order
to display a frame on time,

00:31:40.460 --> 00:31:42.470
the UI thread and
the render thread

00:31:42.470 --> 00:31:48.300
have to complete within 16.7
milliseconds every time.

00:31:48.300 --> 00:31:51.200
This gives Systrace a
nice kind of rhythm.

00:31:51.200 --> 00:31:57.050
You can get used to this
rhythm when you open a Systrace

00:31:57.050 --> 00:31:59.720
and say, oh yeah, I
dropped a frame there,

00:31:59.720 --> 00:32:03.170
because you can tell it
didn't quite line up.

00:32:03.170 --> 00:32:08.540
It makes it easy to spot
where the UI pipeline didn't

00:32:08.540 --> 00:32:12.140
run at a full 60
frames per second

00:32:12.140 --> 00:32:15.200
once you get used to this.

00:32:15.200 --> 00:32:19.430
Now if that's not enough, you
can look at SurfaceFlinger.

00:32:19.430 --> 00:32:21.640
So we're not going--
we don't have time

00:32:21.640 --> 00:32:23.690
to go through the
full Android pipeline.

00:32:23.690 --> 00:32:28.570
But the high level overview is,
your app will render a frame,

00:32:28.570 --> 00:32:31.190
and it will send that frame
over to SurfaceFlinger.

00:32:31.190 --> 00:32:33.530
SurfaceFlinger is
a system service

00:32:33.530 --> 00:32:37.330
that will take whatever app
is rendering on the screen,

00:32:37.330 --> 00:32:40.910
and it will combine that with
a navigation bar and the status

00:32:40.910 --> 00:32:45.410
bar, and actually send the
resulting full, completed

00:32:45.410 --> 00:32:50.060
composite frame to the display
to show up on the screen.

00:32:50.060 --> 00:32:52.250
What this means is
that SurfaceFlinger

00:32:52.250 --> 00:32:55.080
is the central source of truth.

00:32:55.080 --> 00:32:59.300
If ServiceFlinger thinks
you hit your frame deadline,

00:32:59.300 --> 00:33:01.190
you're running at 60
frames per second.

00:33:01.190 --> 00:33:03.560
If SurfaceFlinger says you
didn't deliver a frame,

00:33:03.560 --> 00:33:07.520
you know you didn't actually
hit 60 frames per second.

00:33:07.520 --> 00:33:11.450
And here the way we can do
that is we have a counter here.

00:33:11.450 --> 00:33:14.780
There is one counter per
application in a trace.

00:33:14.780 --> 00:33:19.640
This counter here is
alternating between zero and one

00:33:19.640 --> 00:33:22.370
for how many frames
the SurfaceFlinger have

00:33:22.370 --> 00:33:26.400
from this application that
are ready to be displayed.

00:33:26.400 --> 00:33:29.900
So you know that
if the counter goes

00:33:29.900 --> 00:33:33.320
to zero for more
than 16 milliseconds,

00:33:33.320 --> 00:33:36.530
you have definitely
missed a frame.

00:33:36.530 --> 00:33:41.416
This is the ultimate way to
know whether you had jank

00:33:41.416 --> 00:33:42.540
in your application or not.

00:33:45.360 --> 00:33:49.260
This gets us-- this helps us
spot where the problem is.

00:33:49.260 --> 00:33:52.650
It helps us know where you
actually dropped the frame.

00:33:55.240 --> 00:33:57.607
So what do you do when you
know where the problem is?

00:33:57.607 --> 00:34:00.270
You're going to work
your way backwards.

00:34:00.270 --> 00:34:02.010
So we're going to
look at SurfaceFlinger

00:34:02.010 --> 00:34:03.630
to work our way backwards.

00:34:03.630 --> 00:34:05.130
We're looking at
SurfaceFlinger just

00:34:05.130 --> 00:34:09.900
as an example of a
relatively simple chain here

00:34:09.900 --> 00:34:12.150
because application chains
can be more complicated.

00:34:12.150 --> 00:34:14.489
We don't quite have time.

00:34:14.489 --> 00:34:18.389
But usually, you want to
know why something woke up.

00:34:18.389 --> 00:34:21.810
So we have a running
state in the application,

00:34:21.810 --> 00:34:23.960
and we want to know
what made it runnable

00:34:23.960 --> 00:34:26.010
because that will tell
us why the thread woke up

00:34:26.010 --> 00:34:27.699
in the first place.

00:34:27.699 --> 00:34:30.929
So here I clicked the running
state on top of SurfaceFlinger,

00:34:30.929 --> 00:34:33.000
and I can hit the
left arrow, and I

00:34:33.000 --> 00:34:36.060
can see the runnable state.

00:34:36.060 --> 00:34:38.280
Now I have the runnable
state selected,

00:34:38.280 --> 00:34:40.303
and I want to go ahead
and highlight that.

00:34:40.303 --> 00:34:41.969
You can highlight
anything you currently

00:34:41.969 --> 00:34:45.469
have selected with the m key.

00:34:45.469 --> 00:34:47.840
Now we have a nice
little bar showing what

00:34:47.840 --> 00:34:50.989
we're looking at in the trace.

00:34:50.989 --> 00:34:54.469
In this runnable section, we
have an additional argument

00:34:54.469 --> 00:34:55.469
at the bottom here.

00:34:55.469 --> 00:34:59.210
And it says, wake
up from tid 529.

00:34:59.210 --> 00:35:02.990
This means that the
SurfaceFlinger thread

00:35:02.990 --> 00:35:06.170
was triggered by thread 529.

00:35:06.170 --> 00:35:08.060
Now I don't know
what thread 529 is,

00:35:08.060 --> 00:35:13.810
but I do know that thread 529
must be running at this point

00:35:13.810 --> 00:35:16.490
because if thread
529 wasn't running,

00:35:16.490 --> 00:35:18.680
it couldn't have woken
up SurfaceFlinger.

00:35:18.680 --> 00:35:22.010
So I can scroll back up
to the top of the trace

00:35:22.010 --> 00:35:25.400
to see what is actually
running on the CPU,

00:35:25.400 --> 00:35:27.350
and I see this
thing, event thread.

00:35:27.350 --> 00:35:29.540
So I'll click event thread.

00:35:29.540 --> 00:35:32.100
And event thread is
part of SurfaceFlinger.

00:35:32.100 --> 00:35:36.050
It's another thread inside of
the SurfaceFlinger process.

00:35:36.050 --> 00:35:38.060
And now I want to know
what woke up that event

00:35:38.060 --> 00:35:39.530
thread because
I'm working my way

00:35:39.530 --> 00:35:44.240
backwards to figure out
why SurfaceFlinger woke up

00:35:44.240 --> 00:35:46.280
at all here.

00:35:46.280 --> 00:35:49.670
So I'll scroll back down
and find event thread inside

00:35:49.670 --> 00:35:55.950
of SurfaceFlinger, and
there is the actual thread

00:35:55.950 --> 00:35:57.740
state for the event thread.

00:35:57.740 --> 00:35:59.240
We just have that
little colored bar

00:35:59.240 --> 00:36:01.281
to show that it's running
because it doesn't have

00:36:01.281 --> 00:36:03.680
any events during that time.

00:36:03.680 --> 00:36:06.260
We can click the runnable
section of the event thread

00:36:06.260 --> 00:36:11.150
and see that it woke
up from thread 4568.

00:36:11.150 --> 00:36:12.530
Now I cheated.

00:36:12.530 --> 00:36:14.780
I know what thread 4568 is.

00:36:14.780 --> 00:36:18.650
It is the display sync thread
that is also in SurfaceFlinger.

00:36:18.650 --> 00:36:21.800
So let's go to that one and see
what woke up the display sync

00:36:21.800 --> 00:36:24.410
thread.

00:36:24.410 --> 00:36:26.970
That's right down
there, we click it,

00:36:26.970 --> 00:36:30.580
we see wake up from tid 0.

00:36:30.580 --> 00:36:35.240
Tid 0 is a special
thing in a trace.

00:36:35.240 --> 00:36:38.030
And all it means is
that whatever thread

00:36:38.030 --> 00:36:42.800
you were looking at was woken
up by an interrupt or some sort.

00:36:42.800 --> 00:36:45.650
It was woken up by
an interrupt handler.

00:36:45.650 --> 00:36:48.951
Usually this means
a timer expired.

00:36:48.951 --> 00:36:50.450
This makes sense
for SurfaceFlinger.

00:36:50.450 --> 00:36:53.720
SurfaceFlinger will run
every 16 milliseconds.

00:36:53.720 --> 00:36:56.570
So a timer expired,
woke up this display

00:36:56.570 --> 00:36:58.720
syncronization thread,
which in turn woke up

00:36:58.720 --> 00:37:04.040
the event thread, which
then woke up SurfaceFlinger.

00:37:04.040 --> 00:37:06.270
If you see this in
your trace, it usually

00:37:06.270 --> 00:37:09.870
means that some timer expired
and woke up your thread,

00:37:09.870 --> 00:37:13.080
and that's why you're running.

00:37:13.080 --> 00:37:13.920
And that's it.

00:37:13.920 --> 00:37:17.760
That's the basics of what you
need to know to actually get

00:37:17.760 --> 00:37:19.150
somewhere with Systrace.

00:37:19.150 --> 00:37:21.590
Take some traces
of your application

00:37:21.590 --> 00:37:23.520
and just try to see
what's going on.

00:37:23.520 --> 00:37:24.360
Look at the system.

00:37:24.360 --> 00:37:28.590
Look at how frames are being
drawn and sent to the display,

00:37:28.590 --> 00:37:33.960
and how you're getting
touch input from the server.

00:37:33.960 --> 00:37:37.470
This kind of tracing backwards
via the runnable state

00:37:37.470 --> 00:37:40.260
is most of what we
do to understand

00:37:40.260 --> 00:37:42.210
how the system fits together.

00:37:42.210 --> 00:37:46.780
And you can use it to improve
your applications as well.

00:37:46.780 --> 00:37:51.120
Now if you want a lot more
advice on what you should do,

00:37:51.120 --> 00:37:56.200
as opposed to how to understand
what's going on today,

00:37:56.200 --> 00:37:57.920
I recommend you go to the--

00:37:57.920 --> 00:37:59.340
there's an additional
performance

00:37:59.340 --> 00:38:01.980
talk specifically
on the UI pipeline

00:38:01.980 --> 00:38:05.635
that Chet Haas and
Chris Crake are giving.

00:38:05.635 --> 00:38:08.040
It's at Friday at 1:30 PM.

00:38:08.040 --> 00:38:09.210
So definitely go to that.

00:38:09.210 --> 00:38:12.180
I know they're going to talk
a bunch about recycler view

00:38:12.180 --> 00:38:16.590
and optimizations there, which
is always a popular topic.

00:38:16.590 --> 00:38:18.281
So that's it.

00:38:18.281 --> 00:38:18.780
Thank you.

00:38:18.780 --> 00:38:20.636
[APPLAUSE]

00:38:20.636 --> 00:38:24.970
[MUSIC PLAYING]

