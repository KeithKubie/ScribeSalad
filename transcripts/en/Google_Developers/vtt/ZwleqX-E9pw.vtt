WEBVTT
Kind: captions
Language: en

00:00:01.390 --> 00:00:02.940
Welcome to this
episode of UXD, where

00:00:02.940 --> 00:00:04.940
we will talk about how
to create compelling user

00:00:04.940 --> 00:00:06.580
experiences that
will effectively

00:00:06.580 --> 00:00:08.310
engage your users
by understanding how

00:00:08.310 --> 00:00:10.660
visual attention
and memory work.

00:00:10.660 --> 00:00:12.420
The second episode of
the two-part series

00:00:12.420 --> 00:00:14.430
is all about
understanding memory.

00:00:14.430 --> 00:00:16.630
Please watch the first
part if you haven't already

00:00:16.630 --> 00:00:18.684
to learn more about
visual attention.

00:00:18.684 --> 00:00:20.350
I'm your host, Nazmul
Idris, a developer

00:00:20.350 --> 00:00:22.450
advocate passionate
about design and mobile.

00:00:22.450 --> 00:00:24.530
In this episode, I'll
talk about a few things

00:00:24.530 --> 00:00:26.310
that are related to
human memory and how

00:00:26.310 --> 00:00:30.270
they can be used to create
engaging experiences that

00:00:30.270 --> 00:00:33.060
really capture your
user's attention.

00:00:33.060 --> 00:00:36.290
Both attention and memory
are finite resources,

00:00:36.290 --> 00:00:38.360
and these resources
are further taxed

00:00:38.360 --> 00:00:40.370
if we have an environment
that provides us

00:00:40.370 --> 00:00:42.780
with a lot of stimulus,
like let's say,

00:00:42.780 --> 00:00:45.170
a busy airport, or
driving in heavy traffic,

00:00:45.170 --> 00:00:47.610
or being in a loud restaurant
with lot of people.

00:00:47.610 --> 00:00:49.951
Now, working memory is
a very limited resource,

00:00:49.951 --> 00:00:52.450
which means that we can only
keep so many things in our head

00:00:52.450 --> 00:00:55.170
before we forget them
in the short term.

00:00:55.170 --> 00:00:58.510
For example, when was the last
time this happened to you?

00:00:58.510 --> 00:01:01.010
Let's say, you walked to the
fridge to get something to eat,

00:01:01.010 --> 00:01:02.510
and by the time
you've gotten there,

00:01:02.510 --> 00:01:05.780
you've forgotten what
you wanted to eat.

00:01:05.780 --> 00:01:08.940
Now, people can't
really multitask either,

00:01:08.940 --> 00:01:11.280
since we just single
task and incur

00:01:11.280 --> 00:01:13.900
really expensive
context-switching costs.

00:01:13.900 --> 00:01:16.350
So it's really important to
respect these limitations

00:01:16.350 --> 00:01:19.560
in order to deliver user
experiences that will not just

00:01:19.560 --> 00:01:22.530
cause the user to tune
out because your app is

00:01:22.530 --> 00:01:25.820
overwhelming their
attention and their memory.

00:01:25.820 --> 00:01:28.120
So let's start with
primacy and recency.

00:01:28.120 --> 00:01:30.760
Let's say that you have a long
list of stuff to remember.

00:01:30.760 --> 00:01:33.480
You probably remember stuff
at the very top, which

00:01:33.480 --> 00:01:35.870
is called primacy, and
stuff at the very end, which

00:01:35.870 --> 00:01:37.210
is called recency.

00:01:37.210 --> 00:01:39.449
So how can you use
this in practice?

00:01:39.449 --> 00:01:40.865
Let's say that you
have to present

00:01:40.865 --> 00:01:43.290
the user with a
list of information.

00:01:43.290 --> 00:01:45.020
Make sure to put the
most important stuff

00:01:45.020 --> 00:01:47.590
at the very top of the list
and other important stuff

00:01:47.590 --> 00:01:48.760
at the very bottom.

00:01:48.760 --> 00:01:51.700
And less important stuff should
go somewhere in the middle.

00:01:51.700 --> 00:01:53.730
Similarly, if you've
got a list of actions

00:01:53.730 --> 00:01:56.650
that you have to present
a user with in a menu,

00:01:56.650 --> 00:01:58.890
you should follow
this idea, as well.

00:01:58.890 --> 00:02:01.860
The most important actions go to
the very top or the very bottom

00:02:01.860 --> 00:02:04.850
of the menu with less important
actions in the middle.

00:02:04.850 --> 00:02:06.312
Now, this also
applies to content

00:02:06.312 --> 00:02:08.270
that you're creating for
consumption on the web

00:02:08.270 --> 00:02:09.209
and on mobile.

00:02:09.209 --> 00:02:11.250
Make sure that you put
the really important stuff

00:02:11.250 --> 00:02:12.865
on the top and the bottom.

00:02:12.865 --> 00:02:14.490
This will ensure that
you're leveraging

00:02:14.490 --> 00:02:16.680
the way our memory
naturally works in order

00:02:16.680 --> 00:02:18.730
to get the user's attention.

00:02:18.730 --> 00:02:23.110
Now, another aspect of memory
is recall versus recognition.

00:02:23.110 --> 00:02:24.390
What am I talking about?

00:02:24.390 --> 00:02:26.860
Well, recall is having
to retrieve something

00:02:26.860 --> 00:02:29.670
from memory, which is actually
much more difficult for people

00:02:29.670 --> 00:02:30.950
than recognition.

00:02:30.950 --> 00:02:33.340
So generally it's a bad
idea to require a user

00:02:33.340 --> 00:02:35.600
to recall something
in an application.

00:02:35.600 --> 00:02:40.810
And it's best to replace it with
recognition wherever possible.

00:02:40.810 --> 00:02:42.350
For example, how
many times have you

00:02:42.350 --> 00:02:45.170
been frustrated when you were
presented with a login dialogue

00:02:45.170 --> 00:02:46.940
or form that required
you to recall

00:02:46.940 --> 00:02:49.250
both your username and password?

00:02:49.250 --> 00:02:51.340
Here's a great example
of using recognition

00:02:51.340 --> 00:02:54.790
rather than recall used
for login or authorization.

00:02:54.790 --> 00:02:57.740
It's from the Google application
specific password generator web

00:02:57.740 --> 00:02:59.420
app.

00:02:59.420 --> 00:03:01.960
In this example, it's
not asking the user

00:03:01.960 --> 00:03:04.270
to remember a
username and password.

00:03:04.270 --> 00:03:07.850
Rather they can just copy and
paste this generated password

00:03:07.850 --> 00:03:09.430
into another app
rather than having

00:03:09.430 --> 00:03:13.900
to remember this stuff
and type it in manually.

00:03:13.900 --> 00:03:15.540
Another best practice
around recall

00:03:15.540 --> 00:03:19.040
is to pre-populate fields
that users have already

00:03:19.040 --> 00:03:24.480
entered information into as they
flow between connected screens.

00:03:24.480 --> 00:03:26.530
A great example of this
is filling up long forms

00:03:26.530 --> 00:03:29.515
with lots of data that
has to be typed in.

00:03:29.515 --> 00:03:31.640
For example, when you're
applying for a credit card

00:03:31.640 --> 00:03:34.680
or creating, let's say,
a billing and shipping

00:03:34.680 --> 00:03:36.500
profile for an
e-commerce site, there

00:03:36.500 --> 00:03:39.170
can be a multi-step flow to
complete the process where

00:03:39.170 --> 00:03:42.780
you have to fill out three
or four forms in succession.

00:03:42.780 --> 00:03:44.550
Now, don't make the
user recall stuff

00:03:44.550 --> 00:03:46.980
they've already filled
out earlier in the form

00:03:46.980 --> 00:03:49.744
because this puts high
cognitive load on them.

00:03:49.744 --> 00:03:51.160
We have limited
short-term memory,

00:03:51.160 --> 00:03:53.181
and this is one of the
things that will tax it.

00:03:53.181 --> 00:03:55.430
Pre-populate information
that's already been provided,

00:03:55.430 --> 00:03:57.370
or provide a link to
this information when

00:03:57.370 --> 00:04:01.079
you can and your users
will appreciate you for it.

00:04:01.079 --> 00:04:03.620
Still don't think that it's a
big deal to fill out big forms?

00:04:03.620 --> 00:04:07.506
Well, shopping carts have an
average of 70% abandonment rate

00:04:07.506 --> 00:04:08.880
because there's
too much friction

00:04:08.880 --> 00:04:10.880
to fill out account
creation, shipping, billing,

00:04:10.880 --> 00:04:12.610
and payment form information.

00:04:12.610 --> 00:04:14.790
Fixing these issues aren't
just good for the user,

00:04:14.790 --> 00:04:17.720
but they're also great
for the bottom line.

00:04:17.720 --> 00:04:19.930
And ideally, if you
can totally bypass

00:04:19.930 --> 00:04:22.930
asking a user to fill out
information in the form,

00:04:22.930 --> 00:04:24.210
that's even better.

00:04:24.210 --> 00:04:26.040
For example, if you
use things like Sign

00:04:26.040 --> 00:04:27.800
in with Google and
Google Wallet where

00:04:27.800 --> 00:04:30.560
you can remove large chunks of
friction from your apps user

00:04:30.560 --> 00:04:32.840
experience by simply
using information

00:04:32.840 --> 00:04:35.780
that you need that the user has
already entered somewhere else,

00:04:35.780 --> 00:04:38.160
that's a good thing.

00:04:38.160 --> 00:04:40.740
Another example of using
recognition rather than recall

00:04:40.740 --> 00:04:43.260
can be seen on some
online banking sites.

00:04:43.260 --> 00:04:45.400
The idea is that you
select a picture when

00:04:45.400 --> 00:04:47.260
you create an
account, and you're

00:04:47.260 --> 00:04:50.550
the only one that knows what
picture you've selected.

00:04:50.550 --> 00:04:52.940
Then when you try to log
in to the site again,

00:04:52.940 --> 00:04:54.820
it will just show
you this picture.

00:04:54.820 --> 00:04:57.370
This process just asks
you to recognize a picture

00:04:57.370 --> 00:04:59.021
and not select it from memory.

00:04:59.021 --> 00:05:01.270
And it lets you know that
this is indeed your account.

00:05:01.270 --> 00:05:03.686
This is to confirm that you're
not logging into a phishing

00:05:03.686 --> 00:05:06.342
site, because they
wouldn't have this picture

00:05:06.342 --> 00:05:08.550
and instead they would ask
you to input a lot of data

00:05:08.550 --> 00:05:10.810
and not just display it.

00:05:10.810 --> 00:05:12.190
Now, another thing
that's related

00:05:12.190 --> 00:05:13.390
to memory which is
really important

00:05:13.390 --> 00:05:14.820
is something called
change aversion.

00:05:14.820 --> 00:05:16.319
This is a phenomenon
that causes you

00:05:16.319 --> 00:05:18.950
to hate, at first,
any significant change

00:05:18.950 --> 00:05:21.980
in the UI of your favorite
application or exterior

00:05:21.980 --> 00:05:23.540
styling of your favorite car.

00:05:23.540 --> 00:05:25.620
It's different than
what you remember.

00:05:25.620 --> 00:05:30.250
This is totally natural
and cannot be avoided,

00:05:30.250 --> 00:05:34.600
but it's possible to
mitigate its effects.

00:05:34.600 --> 00:05:37.520
This QR code links to an awesome
article in the Google Ventures

00:05:37.520 --> 00:05:41.060
Library written by user
researcher Aaron Sedley.

00:05:41.060 --> 00:05:42.230
Please read it in detail.

00:05:42.230 --> 00:05:44.560
And it covers various
tactics that you

00:05:44.560 --> 00:05:48.150
can use to mitigate the negative
effects of change version.

00:05:48.150 --> 00:05:51.220
Ideally, it's important to
gradually introduce changes

00:05:51.220 --> 00:05:53.190
so the user cannot
perceive a big,

00:05:53.190 --> 00:05:55.520
drastic change all at once.

00:05:55.520 --> 00:05:57.790
So if you look at the
evolution of the Porsche 911,

00:05:57.790 --> 00:06:00.010
for example, they've
made minor changes

00:06:00.010 --> 00:06:02.787
to a car that was first
created in the late '60s.

00:06:02.787 --> 00:06:04.370
And people still get
bent out of shape

00:06:04.370 --> 00:06:07.020
with every incremental
change that they make.

00:06:07.020 --> 00:06:11.710
So it's gradual change made
over 40 years happened too fast?

00:06:11.710 --> 00:06:14.230
All kidding aside, things
move much faster in software,

00:06:14.230 --> 00:06:15.270
especially on mobile.

00:06:15.270 --> 00:06:18.100
So it's best to gradually
introduce changes and give

00:06:18.100 --> 00:06:22.010
users a heads-up if there's
big changes that are coming.

00:06:22.010 --> 00:06:24.410
And if possible, even
give them the ability

00:06:24.410 --> 00:06:26.530
to toggle between
old and new versions,

00:06:26.530 --> 00:06:29.340
or even provide vestigial
remains of the old UI

00:06:29.340 --> 00:06:31.260
as they're being
migrated to the new one.

00:06:31.260 --> 00:06:35.790
And then gradually remove
functionality from the old one.

00:06:35.790 --> 00:06:37.990
Now, you can play with
change aversion in your app

00:06:37.990 --> 00:06:38.720
as it evolves.

00:06:38.720 --> 00:06:41.630
For example, if you want to
hide changes that you're making,

00:06:41.630 --> 00:06:43.940
you can actually make
very gradual changes

00:06:43.940 --> 00:06:45.870
between every
release of your app.

00:06:45.870 --> 00:06:48.170
On mobile apps, this is
harder to do than on web apps.

00:06:48.170 --> 00:06:51.630
On the web, you could just
make a few just-noticeable

00:06:51.630 --> 00:06:54.260
differences daily
over a period of days,

00:06:54.260 --> 00:06:57.029
and nobody will
probably even notice.

00:06:57.029 --> 00:06:59.320
On the other hand, if you
want to feature a big change,

00:06:59.320 --> 00:07:00.861
if you want to
highlight it, then you

00:07:00.861 --> 00:07:02.880
can never change
aversion to your benefit.

00:07:02.880 --> 00:07:05.990
To make an impact to an
existing user for app,

00:07:05.990 --> 00:07:08.720
you can make changes that
are greater than those which

00:07:08.720 --> 00:07:10.940
are just-noticeable
differences, and this

00:07:10.940 --> 00:07:12.840
will captivate their attention.

00:07:12.840 --> 00:07:14.950
So depending on how you
use change aversion,

00:07:14.950 --> 00:07:18.464
you can hide or feature
changes in your app.

00:07:18.464 --> 00:07:19.880
While people have
change aversion,

00:07:19.880 --> 00:07:22.420
there's another effect called
the mere-repeated-exposure

00:07:22.420 --> 00:07:25.560
effect, which is a
way to overcome this.

00:07:25.560 --> 00:07:27.170
Mere exposure is
a phenomenon where

00:07:27.170 --> 00:07:30.140
if someone is merely exposed to
something that they may or may

00:07:30.140 --> 00:07:32.400
not like repeatedly,
then over time

00:07:32.400 --> 00:07:35.350
they will tend to develop
a preference for it

00:07:35.350 --> 00:07:38.010
simply because they've
become familiar with it.

00:07:38.010 --> 00:07:40.960
And this is also called
the familiarity principle.

00:07:40.960 --> 00:07:43.400
This is essentially
how people form ideas

00:07:43.400 --> 00:07:47.280
around what is intuitive
in a user interface.

00:07:47.280 --> 00:07:50.510
What a user means when they say
a user interface is intuitive

00:07:50.510 --> 00:07:52.800
is that they're familiar
with it and that it's

00:07:52.800 --> 00:07:55.720
matched their expectations
based on their prior experience

00:07:55.720 --> 00:07:57.040
with software.

00:07:57.040 --> 00:08:01.430
This is why it's so important
to follow conventions.

00:08:01.430 --> 00:08:03.480
However, this is
also how conventions

00:08:03.480 --> 00:08:04.799
are formed in the first place.

00:08:04.799 --> 00:08:07.340
For example, when Android moved
from Gingerbread to Ice Cream

00:08:07.340 --> 00:08:09.090
Sandwich, that was
a radical departure

00:08:09.090 --> 00:08:10.810
in the design language,
which many people

00:08:10.810 --> 00:08:12.740
had change aversion to.

00:08:12.740 --> 00:08:16.450
However, today now that people
are used to Ice Cream Sandwich,

00:08:16.450 --> 00:08:20.737
Gingerbread-style apps just
look dated and out of place.

00:08:20.737 --> 00:08:22.320
These are all important
things for you

00:08:22.320 --> 00:08:24.980
to keep in mind as you decide
when to adopt new design

00:08:24.980 --> 00:08:27.040
languages and
platform capabilities,

00:08:27.040 --> 00:08:30.790
especially around mobile
since it evolves so rapidly.

00:08:30.790 --> 00:08:32.220
That's all the
time we have today.

00:08:32.220 --> 00:08:34.925
If you haven't already,
please be sure to join our UX

00:08:34.925 --> 00:08:35.799
community on Google+.

00:08:35.799 --> 00:08:39.500
It's a place where we can
continue this discussion,

00:08:39.500 --> 00:08:42.659
and you can meet others who
are just as passionate about UX

00:08:42.659 --> 00:08:43.840
as you are.

00:08:43.840 --> 00:08:46.058
Thanks for watching
and good-bye.

