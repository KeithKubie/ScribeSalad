WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:09.950
&gt;&gt; CHUNG: [SPEAKING IN FOREIGN LANGUAGE] Good
afternoon. Hi, everyone. I hope you guys having

00:00:09.950 --> 00:00:16.539
a great time so far and still awake. It's
in the afternoon. My name is Fred Chung. I'm

00:00:16.539 --> 00:00:20.490
a Developer Advocate at Google working on
Android, I'm actually working very closely

00:00:20.490 --> 00:00:27.250
with Tim. You guys just learned many things
about group-bearing great looking applications.

00:00:27.250 --> 00:00:32.860
And in this session, we're going to talk about
creating applications that are flexible enough

00:00:32.860 --> 00:00:37.809
to be able to work across different hardware
configurations and implementations, and different

00:00:37.809 --> 00:00:44.690
locales out there. So we're going to be discussing
some technical, you know, best practices and

00:00:44.690 --> 00:00:50.789
techniques that, as developers, you can leverage
to build your apps such that they are flexible.

00:00:50.789 --> 00:00:55.879
And I guess the expectation is that this is
an advanced topic. And I guess it would be

00:00:55.879 --> 00:01:01.530
helpful if you have done one or maybe a few
Android apps and you just learned about making

00:01:01.530 --> 00:01:04.820
your apps look good in the previous session
and now you want to make it, you know, even

00:01:04.820 --> 00:01:13.299
better. And by the way, if you have any feedback
and have access to Wi-Fi, use the link displayed

00:01:13.299 --> 00:01:19.250
up there to provide any feedback, we'd love
to hear it from you. Okay, let's get started.

00:01:19.250 --> 00:01:24.500
I think you've seen this slide earlier, right?
The point here is that we've seen a lot of

00:01:24.500 --> 00:01:30.270
momentum in the Android space in the--in the
previous few quarters and we are very excited

00:01:30.270 --> 00:01:36.189
about it. We are seeing a lot of support from
various players in the ecosystem including,

00:01:36.189 --> 00:01:43.500
obviously, the developers like you guys, users,
and the OEMs, right? As illustrated on the

00:01:43.500 --> 00:01:49.369
slide here, starting on the upper left-hand
corner, you have the Motorola Milestone device.

00:01:49.369 --> 00:01:54.079
You know, it's got a great physical keyboard,
big screen, and the right-hand side device,

00:01:54.079 --> 00:02:00.170
you know, it's an X10 device; also a very
great-looking device. Down below, we have,

00:02:00.170 --> 00:02:04.780
you know, the Galaxy Tab, seven-inch; a really,
really good looking device and I think you've--you

00:02:04.780 --> 00:02:09.039
guys probably have seen that as well. And
on the right-hand side lower corner, you have

00:02:09.039 --> 00:02:13.520
Google TV which was just launched a couple
of weeks ago--last week or a couple of weeks

00:02:13.520 --> 00:02:18.690
ago. So the point here is that with these
different foreign factors, large screens,

00:02:18.690 --> 00:02:24.830
small screens, physical keyboard, with trackball,
without trackball, the thing is with Android

00:02:24.830 --> 00:02:30.050
,right, and the various implementations out
there, it appeals to people with different

00:02:30.050 --> 00:02:35.050
hardware preferences, right? Some like physical
keyboards; some don't. And as developers,

00:02:35.050 --> 00:02:38.720
it's very, very important for you to understand
that there are various techniques that are

00:02:38.720 --> 00:02:43.750
available for you to create your application
to work across these multiple devices. And

00:02:43.750 --> 00:02:48.750
the good thing is that despite these different
screen sizes and screen densities, what we've

00:02:48.750 --> 00:02:54.540
found is that a lot of existing apps out there,
even, you know, those apps that were published

00:02:54.540 --> 00:03:01.040
before, for example, the Galaxy Tab was available,
these apps looked fine on the Galaxy Tab.

00:03:01.040 --> 00:03:04.910
They worked well on Galaxy Tab. Thanks to
the Android platform and we're going to look

00:03:04.910 --> 00:03:13.690
at, you know, some specifics on how it works.
Okay? Let's have a look at how Android as

00:03:13.690 --> 00:03:19.780
a system handles resource loading. So for
those of you that have built some apps, you

00:03:19.780 --> 00:03:23.820
probably are familiar with this directory
structure in Eclipse. This is actually a screenshot

00:03:23.820 --> 00:03:29.950
from Eclipse. And it's got a bunch of directory;
one of those is RES, R-E-S, which stands for

00:03:29.950 --> 00:03:36.300
resources. It includes things such as drawables.
What we call drawable refers to the bitmaps,

00:03:36.300 --> 00:03:42.400
the pictures that you like to put on your
application, layouts. You know, these layout

00:03:42.400 --> 00:03:49.840
XML files define the, you know, how your application
is presented to users, and Android does a

00:03:49.840 --> 00:03:55.340
pretty good job in separating out the presentation
logic from the business logic which makes

00:03:55.340 --> 00:04:00.040
it very, very easy. It's for you to reiterate
the layout if you wanted without affecting

00:04:00.040 --> 00:04:05.450
the business logic. And if you've noticed
on the screenshot, specifically drawable,

00:04:05.450 --> 00:04:13.200
you see a couple of funny identifiers next
to it; drawable-hdpi, drawable-mdpi. So what

00:04:13.200 --> 00:04:20.430
do these identifiers mean? Well, through these
qualifiers, these allow you to provide alternative

00:04:20.430 --> 00:04:26.220
resources for different configurations. What
that means is that for different pictures

00:04:26.220 --> 00:04:33.670
that you put in these different photos that
have the pre--the different suffixes, hdpi,

00:04:33.670 --> 00:04:39.410
mdpi, what happens is that at runtime, the
system will determine, "Hey, what's my current

00:04:39.410 --> 00:04:44.990
configuration?" And then it automatically
picks up--picks the pictures that you have

00:04:44.990 --> 00:04:53.070
prepared from these respective directories
and present to users. There's actually a bunch

00:04:53.070 --> 00:04:58.400
of, you know, qualifiers out there. There's
about a dozen of them, 12 of them. And most

00:04:58.400 --> 00:05:05.160
notably, I like to share with you four that
are related to today's topic, namely, the

00:05:05.160 --> 00:05:10.320
screen size, the screen density, right, because
these define sort of the different foreign

00:05:10.320 --> 00:05:15.760
factors that are available out there; and
screen orientation, right? You can--you know,

00:05:15.760 --> 00:05:21.440
always certain that your users would rotate
their device while using your application;

00:05:21.440 --> 00:05:27.440
and SDK versions. And we're going to talk
more about that today. You may ask, "Well,

00:05:27.440 --> 00:05:32.020
there are a lot of devices out there," right,
"with different screen sizes and density.

00:05:32.020 --> 00:05:37.260
How does the system actually match these different
screen sizes?" Right? Therefore, example,

00:05:37.260 --> 00:05:44.770
3.8-inch, 4-inch screen, right, how does the
system go about matching these different physical

00:05:44.770 --> 00:05:51.080
screen sizes with the identifiers that you've
defined? I think it's best described using

00:05:51.080 --> 00:05:57.180
a diagram like this. It's a three by three
matrix as you can see. Across the top, it

00:05:57.180 --> 00:06:04.060
defines the various buckets or categories
of densities. So we are talking about low-density,

00:06:04.060 --> 00:06:08.600
medium-density, and high-density. And the
vertical access, you have the different screen

00:06:08.600 --> 00:06:11.620
sizes; small, medium, large, right? Just like
when you go to Starbucks, for example. When

00:06:11.620 --> 00:06:16.960
you order coffee, you order different sizes
instead of the exact volume. How Android works

00:06:16.960 --> 00:06:21.990
is that, you know, it sort of maps the different
implementations out there to one of these

00:06:21.990 --> 00:06:28.290
buckets. For example, the G1 in the middle,
it is actually our baseline model. It is considered

00:06:28.290 --> 00:06:34.200
a normal screen and medium-density device.
To the right of the G1, you have the Droid

00:06:34.200 --> 00:06:41.840
X, the Nexus Ones; these are considered enormous
screen device and high-density devices. So

00:06:41.840 --> 00:06:47.180
through this mechanism, Android knows how
to map these different device implementations

00:06:47.180 --> 00:06:54.880
out there to one of the--one of the nine predefined
buckets, right here. And as I said earlier,

00:06:54.880 --> 00:07:00.669
if you look at the directory structure screenshot
here, it--at run time, the system would map

00:07:00.669 --> 00:07:08.860
the different layout in this case to a different
actual hardware. So that's screen size. Screen

00:07:08.860 --> 00:07:14.910
density works very similarly. If you look
at the directory structure up there, drawable-hidpi,

00:07:14.910 --> 00:07:22.370
drawable-lowdpi so you just create different
graphics, right? For example, if you have

00:07:22.370 --> 00:07:28.100
a graphical icon that represents your company,
you want to, you know, put the icons into

00:07:28.100 --> 00:07:40.400
these different directories.
So in terms of presenting drawables or these

00:07:40.400 --> 00:07:47.340
graphical elements on screen, I guess one
of the goals of the system is to make sure

00:07:47.340 --> 00:07:52.510
these different graphics appear at approximately
the same size across devices of different

00:07:52.510 --> 00:07:59.190
densities as illustrated on the three diagrams
here. So you have a low sort of a three grids,

00:07:59.190 --> 00:08:03.990
right? The one--the one on your left represents
a low DPI screen and the one to your right

00:08:03.990 --> 00:08:09.460
represents a higher density screen. And the
system is trying to make sure, for example,

00:08:09.460 --> 00:08:14.090
if you want to put a logo like the star. Let's
say, the star represents your company's logo.

00:08:14.090 --> 00:08:18.410
You want to--you want these stars to show
up at approximately the same size across different

00:08:18.410 --> 00:08:23.910
devices. And if you look at the number of
pixels involved in one of these stars or your

00:08:23.910 --> 00:08:30.419
company's logo, on the left hand side, right,
the number of pixels involved is fewer than

00:08:30.419 --> 00:08:38.999
those on the right hand side, right, in order
to retain the shape of the picture. And at

00:08:38.999 --> 00:08:44.439
run time, the system is going to either scale
the pictures up or down based on the availability

00:08:44.439 --> 00:08:54.310
of these graphics and the actual device that's
being run on. And when it comes to the generation

00:08:54.310 --> 00:08:58.930
of these graphics, for example, when you're
using your favorite photo editing software,

00:08:58.930 --> 00:09:04.850
Photoshop, or a GIMP, or whatever, I guess
the technique is that you always want to first

00:09:04.850 --> 00:09:09.519
of all, identify the buckets, the different
density buckets that you like to support,

00:09:09.519 --> 00:09:15.980
right? For example, you want to, say, support
all three, you always want to create the graphics

00:09:15.980 --> 00:09:22.699
with the highest density first, right, and
then scale them down based on these principles.

00:09:22.699 --> 00:09:28.829
For example, if the width of the highest density
graphic is 150, and then you want to scale

00:09:28.829 --> 00:09:37.649
it down by creating a smaller graphics with,
you know, 100 pixel in width because that's

00:09:37.649 --> 00:09:45.339
the difference that's represented by the three-grid
model. Well, so that's concept. Let's have

00:09:45.339 --> 00:09:50.310
a look at actual implementation. I drew this
picture. Is it pretty? I'm proud of it. So

00:09:50.310 --> 00:09:57.829
this is the actual screen shot that I took
from a G1 device. As you can recall, G1 device

00:09:57.829 --> 00:10:04.959
is classified as a medium screen size and
medium density. So it looks okay, right? What

00:10:04.959 --> 00:10:13.899
if I just use the same graphic and then render
it on a medium screen device and higher density

00:10:13.899 --> 00:10:20.379
device like the Nexus One? You'll get something
on the right. While it still works, the system,

00:10:20.379 --> 00:10:27.471
you know, does its magic to scale it up to
a screen of higher density, you can see that

00:10:27.471 --> 00:10:32.179
the graphics on the right is blurred, right?
Can you guys notice that difference? And then

00:10:32.179 --> 00:10:37.490
what if you want to optimize it, right? We
always want to make sure our applications

00:10:37.490 --> 00:10:42.990
look good as we learned from the previous
session, right? So you want to take the approach

00:10:42.990 --> 00:10:52.490
that I just described by introducing a higher
density graphics in the HDPI photo of drawable.

00:10:52.490 --> 00:10:59.220
And this is the result. And I don't know if
you can tell from the projection but I can,

00:10:59.220 --> 00:11:05.370
you know, noticeably see the difference in
crispiness of the picture in the middle and

00:11:05.370 --> 00:11:16.350
that's generated from--on the same device
on the Nexus One, but with the optimized assets.

00:11:16.350 --> 00:11:22.470
So we just learned that the system does actually
a pretty good job in auto scaling in the different

00:11:22.470 --> 00:11:28.670
images for you, right? What if you're getting
adventurous, right? What if you have actually

00:11:28.670 --> 00:11:34.929
identified ways that you think warrants the
needs for you to do the scaling itself, right?

00:11:34.929 --> 00:11:43.000
My advice is for you is don't do it. Let the
system do its job. The system knows to do

00:11:43.000 --> 00:11:48.970
it pretty well. And if you, for example, insist--if
you insist on doing it, I would like to ask

00:11:48.970 --> 00:11:54.160
you to re-think. Ask your colleagues, your--the
neighbors next to you, ask your boyfriends,

00:11:54.160 --> 00:11:59.660
girlfriends for their confirmation. Is this
the right thing for you to do? The point being,

00:11:59.660 --> 00:12:05.069
the system is smart enough and it knows how
to do it for you pretty well. But let's say

00:12:05.069 --> 00:12:10.369
you want to do it, right? Here's the step
involved. There are a couple of parameters

00:12:10.369 --> 00:12:18.170
involved if you look at the code snippets
when you want to render in Bitmap; bitmapfactory.options,

00:12:18.170 --> 00:12:23.980
right? It's–-it comes with a default options
and you want to overwrite it. And the specific

00:12:23.980 --> 00:12:29.649
two parameters that you want to overwrite
are the InDensity and the InTargetDensity.

00:12:29.649 --> 00:12:36.839
What these parameters mean is that the InDensity
is actually the density for the incoming drawable

00:12:36.839 --> 00:12:42.980
that you want to render. And the InTargetDensity
is the density of the actual device that the

00:12:42.980 --> 00:12:49.180
program is running on. So at run time, normally,
the system is going to scale your pixels based

00:12:49.180 --> 00:12:55.191
on this formula; InTargetDensity divided by
InDensity. And if you want to disable that

00:12:55.191 --> 00:12:59.980
auto-scaling effect, right? You want to, you
know, make sure that formula equates to one.

00:12:59.980 --> 00:13:06.879
And the way to do it is to make sure those
values match by, you know, manually setting

00:13:06.879 --> 00:13:12.790
the values to be identical for the three values
you see on the last bullet, okay? But again,

00:13:12.790 --> 00:13:19.529
I request you to re-think if you are kind
of wondering about whether it makes sense

00:13:19.529 --> 00:13:26.230
for you to manually manipulate the pictures.
Okay, we talked about screen sizes and densities.

00:13:26.230 --> 00:13:33.499
What about orientation as I alluded to you
earlier in the session? So as I mentioned

00:13:33.499 --> 00:13:38.850
earlier that users will probably rotate the
devices, right, you have the option of just

00:13:38.850 --> 00:13:46.489
letting the operating system handle the rotation
for you or you can disable it and decide to

00:13:46.489 --> 00:13:52.459
handle the rotation yourself. And keep in
mind that there are different hardware implementations

00:13:52.459 --> 00:14:00.160
out there, right? They are, you know, naturally
landscape devices, they are naturally portrait

00:14:00.160 --> 00:14:04.809
devices, and there are some square devices.
I guess the key point here is that when you

00:14:04.809 --> 00:14:10.009
are developing an application, don't always
assume that, okay, it's going be always be

00:14:10.009 --> 00:14:16.290
run on a milestone, for example, where users,
you know, have the tendency of holding it

00:14:16.290 --> 00:14:23.560
upright or in a portrait mode. Be flexible
to expect the possibility that they might

00:14:23.560 --> 00:14:29.040
have a natural tendency to use it in a landscape
mode. For tablet, for example, right? Why

00:14:29.040 --> 00:14:37.190
the device seven-inch Samsung tablet, for
example. I think the natural orientation is

00:14:37.190 --> 00:14:42.339
probably landscape. [INDISTINCT] a lot of
people would like to use it to read e-books

00:14:42.339 --> 00:14:49.079
or whatever, and therefore I guess the natural
orientation could be landscape. And if you

00:14:49.079 --> 00:14:53.449
want to determine the natural orientation
at run time, you can use code--this code snippet,

00:14:53.449 --> 00:15:00.059
right? You can get it--hand it to the display
object and read the orientation based on the

00:15:00.059 --> 00:15:05.389
get orientation API and that particularly
API's been duplicated. And if you are running

00:15:05.389 --> 00:15:11.569
on Froyo or if you're targeting on Froyo,
you want to use to get rotation API, okay?

00:15:11.569 --> 00:15:19.040
Let's talk a little bit about, you know, best
practices involved with creating flexible

00:15:19.040 --> 00:15:25.929
UIs. So there are two screen shots up there
while the two applications are perfectly functional,

00:15:25.929 --> 00:15:30.379
they look a little bit odd. The one on the
right looks a little bit odd, and the reason

00:15:30.379 --> 00:15:36.389
being those were generated using an Absolute
Layout. And for those of you that may not

00:15:36.389 --> 00:15:42.639
be familiar with Absolute Layout is that it's
a method to layout graphical elements on the

00:15:42.639 --> 00:15:49.629
UI. For example, you want to specify that,
"I want to place the input box five pixels

00:15:49.629 --> 00:15:56.290
below the top and 20 pixels to the right of
the left--of the left edge." And while this

00:15:56.290 --> 00:16:01.559
works on the screen shot on the left hand
side which was produced from G1 which is a

00:16:01.559 --> 00:16:06.649
low density device and a screen shot on the
right hand side is come--actually came from

00:16:06.649 --> 00:16:12.449
Nexus One which is a higher density device.
As we learned from the star diagrams, the

00:16:12.449 --> 00:16:19.109
three stars diagrams, the number of pixels
involved--while the number of pixels involved

00:16:19.109 --> 00:16:26.679
to define the input box might be identical,
it's narrower on higher density devices, right?

00:16:26.679 --> 00:16:35.399
So you can't reliably depend on Absolute Layout
and we advise you to kind of use another method

00:16:35.399 --> 00:16:41.389
which is Relative Layout. It is basically
a method to specify UI elements based on relative

00:16:41.389 --> 00:16:47.529
positioning with respect to other elements.
So let's use this example. You would say,

00:16:47.529 --> 00:16:53.809
"I want to put the input box to the right
of the label,” which is called input, just

00:16:53.809 --> 00:17:00.949
like that, and then the system would automatically
put it to the right of it. And then, you want

00:17:00.949 --> 00:17:08.240
to use something called DIP, density-independent
pixel, rather than absolute pixel because,

00:17:08.240 --> 00:17:13.230
again, you don't want--you want to avoid absolute
pixels for the various reasons that I just

00:17:13.230 --> 00:17:18.889
mentioned before and use this density-independent
pixel. What happens is that remember the three-by-three

00:17:18.889 --> 00:17:28.260
matrix, right? So that's--that defines the
logical pixel unit. And then once defined,

00:17:28.260 --> 00:17:32.789
the system would automatically scale that
based on the actual hardware implementation

00:17:32.789 --> 00:17:39.060
that the app is deployed on. And as far as
defining text size, you want to use something

00:17:39.060 --> 00:17:44.750
called SP instead of, again, absolute pixel
to define the size of the text because what

00:17:44.750 --> 00:17:52.370
we've seen is that while the text size may
look okay on one implementation, namely, for

00:17:52.370 --> 00:18:01.399
example, G1, it may look like a small font
on a Milestone, for example, just because,

00:18:01.399 --> 00:18:12.889
again, the differences in different screen
densities. Okay, here's another observation

00:18:12.889 --> 00:18:19.120
that I've learned over the months. This is
an actual screenshot that was taken from a

00:18:19.120 --> 00:18:26.320
Galaxy Tab which is defined as a high, you
know, large screen-sized and high density.

00:18:26.320 --> 00:18:33.320
And what happens is that if you have a Legacy
app, right? A Legacy app probably has the

00:18:33.320 --> 00:18:39.860
targetSdkVersion defined as something smaller
than four like a cupcake, a three or something.

00:18:39.860 --> 00:18:45.600
And then, you know, if you can recall back
in Version 3, the difference screen sizes

00:18:45.600 --> 00:18:54.649
were not introduced to the SDK. So the system
would think, "Okay, this app is not capable

00:18:54.649 --> 00:18:59.260
of being rendered on a larger screen, so I'm
going to put a border around it." This is

00:18:59.260 --> 00:19:04.630
something what we call a Shoebox. And, again,
while it works functionally, it doesn't look

00:19:04.630 --> 00:19:10.070
good, right? It's not appealing to your users
and that's not to the best of your interest.

00:19:10.070 --> 00:19:16.299
And one quick way to sort of a remedy this
situation is to make sure that in your Android

00:19:16.299 --> 00:19:25.399
Manifest, you have the support screens element
properly declaring the support of large screens,

00:19:25.399 --> 00:19:31.960
or medium screens, or any density to true.
That way, the system knows that, "Okay, this

00:19:31.960 --> 00:19:37.230
application is probably able to be rendered
on a bigger screen and it would stretch it

00:19:37.230 --> 00:19:49.559
to take the four sides of the screen." All
right. So we talked about the screen size

00:19:49.559 --> 00:19:55.700
and screen densities, the different form factors
that you need to be aware of. What about the

00:19:55.700 --> 00:20:01.179
different versions out there, right, because
as you probably can recall, we have brought

00:20:01.179 --> 00:20:08.299
out a few versions out there over the years.
And as illustrated in this picture here, right,

00:20:08.299 --> 00:20:17.410
this is a panoramic picture I took with my
G1 several days ago and as you can see, we

00:20:17.410 --> 00:20:24.340
have the various sculptures out there on the
lawn. This is coming from the Mountain View

00:20:24.340 --> 00:20:30.610
Headquarters. And traditionally, whenever
the team launches a new version, they put

00:20:30.610 --> 00:20:36.049
up a new sculpture. So as you can see the
cupcakes, the donuts, and whatever, over the

00:20:36.049 --> 00:20:40.870
years. So the expectation is that, you know,
there would always be multiple versions out

00:20:40.870 --> 00:20:47.990
there in the market and we're going to talk
a little about how to--how do you go about

00:20:47.990 --> 00:20:53.640
handling that in the future. And also one
more thing, last Friday, they put out--put

00:20:53.640 --> 00:20:59.600
out a new sculpture out there and that's what--not
what I'm going to talk about today. I don't

00:20:59.600 --> 00:21:08.820
have more information there. Okay, so we talked
with a lot of developers, right? A very--a

00:21:08.820 --> 00:21:13.309
question that comes up over and over again
is that, "Okay, you have multiple versions

00:21:13.309 --> 00:21:19.090
out there, which version should I target?"
Right? This is our smart answer to it; “It

00:21:19.090 --> 00:21:26.010
really depends.” And then there's a number
of reasons, right, there's a number of factors

00:21:26.010 --> 00:21:33.419
involved. And the two most important factors,
I think, are the number of users and the number

00:21:33.419 --> 00:21:38.840
of recent features or the number of advanced
features you want to implement. In this non-scientific

00:21:38.840 --> 00:21:44.590
graph that I drew--hand drawn, you can probably
see that, you know, the more advanced of a

00:21:44.590 --> 00:21:51.139
feature that you wanted to target, the fewer
the number of users that it probably can benefit.

00:21:51.139 --> 00:21:55.191
And the reason being, you know, it take--it
generally takes some time for users out there

00:21:55.191 --> 00:22:01.740
on the field to upgrade to newer versions
for whatever reasons. And the question really

00:22:01.740 --> 00:22:06.620
is, you're going to ask yourself, "Okay, for
the app that you are trying to develop, what's

00:22:06.620 --> 00:22:11.830
my feature sets?" Right? You want to look
at feature sets and then try to compare the

00:22:11.830 --> 00:22:17.260
various features that are available on the
various version of Android. For example, if

00:22:17.260 --> 00:22:21.800
you want to, you know, have a news widget
kind of thing, that was introduced way back

00:22:21.800 --> 00:22:27.169
in 1.5, which means that, you know, the SDK
version that you can use to target is probably--you

00:22:27.169 --> 00:22:32.049
can--you can go back all the way to 1.5 which
will appear to almost, you know, practically

00:22:32.049 --> 00:22:38.759
100% of the devices out there versus if you
want to target, you know, the data backup

00:22:38.759 --> 00:22:43.630
feature or live wallpaper features that are
introduced in more recent versions. You're

00:22:43.630 --> 00:22:47.870
going to have to just, you know, balance that
yourself to figure out, "Okay, what's my cost

00:22:47.870 --> 00:22:53.570
benefit? Additional features or relatively
speaking, fewer users?" But over time, you

00:22:53.570 --> 00:23:00.649
can sort of expect that users will be upgraded
to newer versions and newer devices that come

00:23:00.649 --> 00:23:11.269
out will be running newer versions. So here's
another tool that helps us make that decision

00:23:11.269 --> 00:23:15.710
like, which version should I target. And by
the way, this is publicly available on our

00:23:15.710 --> 00:23:21.200
websites and it basically illustrates that
over time, you know, it confirms the point

00:23:21.200 --> 00:23:26.919
that I just I make; over time, more and more
devices will have newer versions. And if you

00:23:26.919 --> 00:23:32.690
look at this graph, anything with Éclair
or 2.1, or more recent, we're talking about

00:23:32.690 --> 00:23:41.309
roughly 75% of devices out there, which is
pretty great. Okay, so with the different

00:23:41.309 --> 00:23:47.730
versions out there, right, I mentioned that
you can expect to see multiple versions out

00:23:47.730 --> 00:23:53.100
there; out two to three versions or whatever.
How do you go about creating an application

00:23:53.100 --> 00:23:58.200
that would work seamlessly across these different
versions? So, here's the thing that you want

00:23:58.200 --> 00:24:06.740
to figure out, right, with API changes. For
example, you're developing on 2.2, right,

00:24:06.740 --> 00:24:12.759
Froyo. You might be leveraging or using some
APIs that might not be available on older

00:24:12.759 --> 00:24:19.019
versions. How do you make sure the backward
compatibility of your application to maximize

00:24:19.019 --> 00:24:26.379
your reach? I guess the general recommendation
is leverage Java Reflection, right? At runtime,

00:24:26.379 --> 00:24:31.389
you want figure out, okay, on my--on the current
system that I'm running is the particular

00:24:31.389 --> 00:24:36.980
class or is the particular method that I'm
trying to use is available? And then you can

00:24:36.980 --> 00:24:42.730
provide a wrapper around that reflection logic,
right? Whenever you want to access that information

00:24:42.730 --> 00:24:47.960
from your business logic, you want to poke
the--poke the class and say, "Hey, is this

00:24:47.960 --> 00:24:53.710
class or is this method available at runtime?"
And if it is, use it. If not, you're going

00:24:53.710 --> 00:24:58.919
to have to have a backup plan. So here's the
general strategy in theory and let's have

00:24:58.919 --> 00:25:08.020
a look at some actual code. In this use case,
I'm trying to use the getDensity method from

00:25:08.020 --> 00:25:15.631
the canvas class, as you can see pointed to
you by the arrow, right? And this getDensity

00:25:15.631 --> 00:25:22.100
method specifically was introduced back in
level four or at Donut. What if I want to

00:25:22.100 --> 00:25:28.779
target Cupcake devices that don't have this
method available? So I would create this wrapper

00:25:28.779 --> 00:25:36.520
class called Canary with a static--method
is just a Java Reflection class that represents

00:25:36.520 --> 00:25:44.169
the method itself. And then you try to say,
get me the method called getDensity. And if

00:25:44.169 --> 00:25:50.070
that getDensity method is found on the runtime,
it will return the reference to that method

00:25:50.070 --> 00:25:56.429
and that reference, based on this code snippet,
it start in "mGetDensity" reference handle.

00:25:56.429 --> 00:26:01.201
If it's not found, an exception will be thrown
and, you know, you're going to have to do

00:26:01.201 --> 00:26:08.159
something differently. So that's the wrapper
method. And let's have a look at how this

00:26:08.159 --> 00:26:17.830
method should be used. We're talking about
the same class--the same wrapper class. And

00:26:17.830 --> 00:26:21.050
whenever you need to access the getDensity,
you want to do something like this, you want

00:26:21.050 --> 00:26:26.840
to check for the reference, right? If the
method was successfully identified, it's going

00:26:26.840 --> 00:26:33.769
to be available in the mGetDensity reference
or handle. If it's found, then invoke it.

00:26:33.769 --> 00:26:40.009
If it's not found in the [INDISTINCT] class,
you might want to do something different by

00:26:40.009 --> 00:26:46.730
having--in this particular instance, having
a default variable or something so that your

00:26:46.730 --> 00:26:54.019
application won't crash, which is a great
thing for users--from a user experience standpoint.

00:26:54.019 --> 00:27:00.450
So that was a new method, right? What about
you using a class that might not be familiar--I

00:27:00.450 --> 00:27:07.539
mean, that might not be available in the previous
version of Android? Very, very similar approach

00:27:07.539 --> 00:27:15.470
is used here. Again, create a wrapper class,
right? In the wrapper class within a static

00:27:15.470 --> 00:27:22.019
block, you want to try to load that class,
in this case, called EventLog, which was introduced

00:27:22.019 --> 00:27:28.490
in Froyo. It's something used to read diagnostic
information at the system level. You want

00:27:28.490 --> 00:27:35.100
to try to load this using the forName method,
okay? If it's found, everything is good. If

00:27:35.100 --> 00:27:40.919
it's not found, an exception will be thrown.
And then there's this checkAvailable--whoops.

00:27:40.919 --> 00:27:48.919
There's this checkAvailable method, which
is a static method, MT method, and the idea

00:27:48.919 --> 00:27:55.570
is that a caller can call this checkAvailable.
And since this is static, it would--it would

00:27:55.570 --> 00:28:03.519
invoke the execution of the static block above
it to check the forName and so on and so forth.

00:28:03.519 --> 00:28:09.660
Okay? And the third method in this wrapper
is the writeEvent, which is nothing but a

00:28:09.660 --> 00:28:19.289
wrapper for the actual class that you are
trying to invoke. And then here's the actual

00:28:19.289 --> 00:28:24.990
usage of the wrapper class. For example, in
this MyActivity, you want to use it, so you

00:28:24.990 --> 00:28:31.679
would do EventLogWrapper.checkAvailable. As
you can recall, this is the static method

00:28:31.679 --> 00:28:37.440
that is used to trigger the invocation of
the static block which calls forName, right?

00:28:37.440 --> 00:28:43.799
If forName works well, everything is good,
right? And then you want set the boolean to

00:28:43.799 --> 00:28:49.559
true. The boolean is about called mAPIAvailable,
set into true, indicating that, yes, the class

00:28:49.559 --> 00:28:55.009
is available, otherwise, if the exception
is affirmed which implies that the class is

00:28:55.009 --> 00:28:59.519
not available, then you would set that boolean
to false. So when you are actually trying

00:28:59.519 --> 00:29:04.159
to use this class, you would just check for
the, you know, the boolean value. If it's

00:29:04.159 --> 00:29:10.590
true, then it means that the class is available,
then use it. If not, do something differently.

00:29:10.590 --> 00:29:15.809
So this is one of the ways developers can
use to make sure they have maximum compatibility

00:29:15.809 --> 00:29:21.190
across different versions. But I would say
it--while this is a good method, it may not

00:29:21.190 --> 00:29:28.500
work for all features. For example, account
manager which is more involved than just making

00:29:28.500 --> 00:29:36.080
API cause, that's something that, you know,
that makes it very, very hard to use a strategy

00:29:36.080 --> 00:29:42.389
like this to maximize the compatibility. But
for the most part, you can leverage what I--what

00:29:42.389 --> 00:29:49.990
we just described to kind of make sure your
application is version-proof, sort of. Okay,

00:29:49.990 --> 00:29:56.940
we talked about, you know, version compatibility.
Let's move on to localization, right? We are

00:29:56.940 --> 00:30:04.960
talking about an international audience here.
You have pretty much have access to sell your

00:30:04.960 --> 00:30:10.960
application for Android market to the rest
of the other countries that support Android

00:30:10.960 --> 00:30:17.290
market. So let's have a quick look at localization
here. Here's a quick code snippet to show,

00:30:17.290 --> 00:30:23.520
you know, a button, you want to render a button
on the screen, and put a text on it. Voila,

00:30:23.520 --> 00:30:29.700
right? It works perfectly fine. But can this
be improved? We all, as programmers, are lazy,

00:30:29.700 --> 00:30:35.890
right? We have the tendency to just hot code
labels. And while it works, again, you know,

00:30:35.890 --> 00:30:40.100
it may not be that flexible in the event that
you want to localize your application to,

00:30:40.100 --> 00:30:46.960
say, English speaking countries or Spanish
speaking audience. So to do that, it's really

00:30:46.960 --> 00:30:51.429
simple. For those experienced programmers
out there, you guys should be all familiar

00:30:51.429 --> 00:30:58.490
with the resource bundles concept, same ideas
applicable here. In the values folder of your

00:30:58.490 --> 00:31:04.259
project, you just have to create different
values folders prefix or suffix rather by

00:31:04.259 --> 00:31:13.149
different languages and regions; for example
-ES, -PT region Brazil, for example. Within

00:31:13.149 --> 00:31:21.440
the strings.XML files that--which we'll see
later, it shows you that how you can put different

00:31:21.440 --> 00:31:28.840
languages into the different bundles. So this
is the setup. So how does it work at runtime?

00:31:28.840 --> 00:31:34.269
At runtime, the system would sort of go through
this logic, the four bullet points out there;

00:31:34.269 --> 00:31:39.210
what is my current system locale, right? It
could be Portuguese or something else, right,

00:31:39.210 --> 00:31:46.639
English or whatever. And the thing is it's
got a default version--default locale. And

00:31:46.639 --> 00:31:54.240
at runtime, the--it would query the app package,
the APK file to say, hey, if this developer

00:31:54.240 --> 00:31:59.129
has paid attention in Fret's talk and created
the different folders with the different localized

00:31:59.129 --> 00:32:04.619
strings, and if they did and if it's able
to find the corresponding folder that matches

00:32:04.619 --> 00:32:09.970
their current locale, then it would use it.
If it's not found, it falls back to the default,

00:32:09.970 --> 00:32:18.779
the values one without any suffixes. Okay,
here's an actual example of formatting string.

00:32:18.779 --> 00:32:24.870
You want to put a label and a text, right?
This is an application that tries to figure

00:32:24.870 --> 00:32:30.700
out the number of engineers needed to change
a light bulb. And in the different strings,

00:32:30.700 --> 00:32:36.740
you know, different localized strings, resource
files that I mentioned, you just put in the

00:32:36.740 --> 00:32:42.090
contents, the localized contents. The first
version, you know, it's Portuguese. I hope

00:32:42.090 --> 00:32:51.059
that's right. That's based on Google Translate
output. And the second strings.XML contains

00:32:51.059 --> 00:32:55.659
the strings, you know, in other language,
in English, in this case. Going back to the

00:32:55.659 --> 00:33:05.389
code snippets, this is how you would instantiate
this string by calling, you know, getResources.getString

00:33:05.389 --> 00:33:11.200
by referring to the R.string.question, which
automatically maps to one of these depending

00:33:11.200 --> 00:33:20.190
on, again, the current system locale. And
as you can see, you can also merge data at

00:33:20.190 --> 00:33:25.090
runtime. You can, you know, merge an integer
value to the string that--to be displayed

00:33:25.090 --> 00:33:34.429
on the UI. Okay, we’ve talked about localization.
How about from an Android market standpoint,

00:33:34.429 --> 00:33:39.639
right? Once you've developed your app, you've
tested your app, you want to distribute it.

00:33:39.639 --> 00:33:45.210
Android Market plays a very important role.
It's sort of a matchmaking role between, you

00:33:45.210 --> 00:33:50.220
know, apps and devices. On one hand, you have
a bunch of developers creating great apps,

00:33:50.220 --> 00:33:54.450
publishing apps. And on the other hand, you
have a bunch of devices checking in, "Hey,

00:33:54.450 --> 00:34:00.970
get me some apps. Get me some apps." And whenever
these devices check in, they report their

00:34:00.970 --> 00:34:06.509
device hardware capabilities. And different
hardware versions or different hardware models,

00:34:06.509 --> 00:34:10.980
as we've talked about, have different capabilities;
some have cameras, some don't, so on and so

00:34:10.980 --> 00:34:16.700
forth. And let’s see, you know, what sort
of mechanism Android Market has to make sure

00:34:16.700 --> 00:34:21.670
actually the intended audience gets access
to application. The worst thing that could

00:34:21.670 --> 00:34:25.950
happen is that if your application requires
camera and what if the device doesn't have

00:34:25.950 --> 00:34:33.020
a camera? That would be a bad user experience.
So there are two sides. On the application

00:34:33.020 --> 00:34:39.870
publishing side through Android Manifest,
you can create, you know, roughly six different

00:34:39.870 --> 00:34:45.670
filters, right? And I'm just calling out four
ones that are relevant to this talk; uses

00:34:45.670 --> 00:34:52.830
features, uses configurations. And these tags
actually tells the system, hey, my app actually

00:34:52.830 --> 00:34:59.620
will require telephony features, or it does
require OpenGL. Or in a case of users configuration,

00:34:59.620 --> 00:35:05.580
it says, okay, my app requires a physical
keyboard for whatever reason, or it uses SDK.

00:35:05.580 --> 00:35:12.570
My app requires a minimum version of SDK be
it Froyo or Cupcake or whatever. And then

00:35:12.570 --> 00:35:18.250
you can also define things such as the support
screen; what kind of screen sizes can my app

00:35:18.250 --> 00:35:25.810
support? So through these different cues,
Android Market knows, okay, here are the apps'

00:35:25.810 --> 00:35:32.420
capabilities or requirements. And then these
are created through Android Manifest. But

00:35:32.420 --> 00:35:37.110
through other methods, you can also specify,
okay, here's the geographical location I want

00:35:37.110 --> 00:35:43.520
to target. Here's the carrier restrictions
for making my apps available and native platform

00:35:43.520 --> 00:35:50.880
if your application uses NDK which we saw
in Tim's talk. It--you know, NDKs targets

00:35:50.880 --> 00:35:55.840
a specific hardware and then this is kind
of--these are kind of filtering criteria you

00:35:55.840 --> 00:36:02.050
can specify. And you can have a look at this
URL to understand the full definition of these

00:36:02.050 --> 00:36:08.900
different criteria. And also--so we talked
about app publishing aspect of it. A U.S.

00:36:08.900 --> 00:36:13.920
developer can say, "Okay, here are the requirements
for my app." But for those devices that are

00:36:13.920 --> 00:36:21.290
checking in, how do we make sure those devices
conform to a certain standard? And that's

00:36:21.290 --> 00:36:26.840
done through Android compatibility definition,
right? If you go to the URL, you can find

00:36:26.840 --> 00:36:32.930
that, you know, this definition defines things
such as the minimum requirements an Android

00:36:32.930 --> 00:36:39.700
compatible device must have. For example,
touch screens, USB slots, so on and so forth,

00:36:39.700 --> 00:36:44.000
it defines, you know, some of the minimum
requirements to be compatible with Android,

00:36:44.000 --> 00:36:51.050
and to ensure that these devices that are
checking in to Android Market actually conform

00:36:51.050 --> 00:36:56.640
to a certain standard so apps won't break.
And from an OEM standpoint, they would have

00:36:56.640 --> 00:37:02.190
to make sure that they run through the CTS,
compatibility test suites, to make sure they

00:37:02.190 --> 00:37:10.380
are compatible. Okay. So that's kind of completes
the whole cycle from app publishing to devices

00:37:10.380 --> 00:37:15.990
checking in, how Android markets make sure
your apps are only visible to the intended

00:37:15.990 --> 00:37:23.530
audience. Okay. I guess that wraps up my talk.
And to summarize, I want to say that it's

00:37:23.530 --> 00:37:28.040
actually pretty straightforward to make sure
your app could be, you know, compatible to

00:37:28.040 --> 00:37:34.390
various devices out there with different hardware
configurations and versions. And I strongly

00:37:34.390 --> 00:37:38.410
encourage you to have a look at our online
documentation for the information that we

00:37:38.410 --> 00:37:42.000
just discussed. Thank you very much. [SPEAKING
IN FOREIGN LANGUAGE].

