WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:07.830
&gt;&gt; RYAN: Hello, my name is Ray Ryan. And I'll
be talking to you today about how we architect

00:00:07.830 --> 00:00:15.850
applications at Google with an eye toward
actually putting them out for production.

00:00:15.850 --> 00:00:22.790
So, hello, and I need to remind you as we
all have been doing that there'll be live

00:00:22.790 --> 00:00:28.840
notes being taken at the Wave at that Bitly
link there, that you can queue up any questions.

00:00:28.840 --> 00:00:32.619
And we'll see if I remember how to run the
moderator application to take those off the

00:00:32.619 --> 00:00:38.030
screen as well from the microphone at the
end of the talk. So, we're going to talk about

00:00:38.030 --> 00:00:45.219
basically two things today; how does Google
architect its web apps and what is GWT 2.0

00:00:45.219 --> 00:00:50.879
and its new friend Roo, what are they going
to do to help you work that way too. This

00:00:50.879 --> 00:00:55.460
is going to build on stuff that I talked about
last year at our--at a talked with a very

00:00:55.460 --> 00:00:59.309
similar name. It seems like all of our talks
have the word architecture in them this year

00:00:59.309 --> 00:01:06.430
and last year. The big takeaways from that
were the MVP pattern that people keep talking

00:01:06.430 --> 00:01:12.509
about including Daniel and the excellent testing
talked he just gave here a moment ago, and

00:01:12.509 --> 00:01:18.070
to try to keep an app--keep your app in the
decoupled state. So, rather than having bits

00:01:18.070 --> 00:01:26.010
of it know about each other directly, try
to do a communication through an event bus--letting

00:01:26.010 --> 00:01:29.880
parts of the app post events to each other
without having to know so much about each

00:01:29.880 --> 00:01:32.720
other. Wow, this program doesn't work the
way I think it does, so I'm going to work

00:01:32.720 --> 00:01:40.049
through the next slide and pretend it wasn't
there. There--we have a bit of miscommunication

00:01:40.049 --> 00:01:44.210
and there won't be a demonstration of Roo
right now, but presume. Most of you saw or

00:01:44.210 --> 00:01:51.299
at keynote yesterday where we announce the
new relationship with the VMware where their

00:01:51.299 --> 00:01:58.069
very cool command line based rapid application
development system called Roo is able to generate

00:01:58.069 --> 00:02:03.659
GWT applications for you. Not so much to show
it off right now, but the basic idea is that

00:02:03.659 --> 00:02:08.410
one sits down with Spring Roo on types of
few commands dictating the kinds of entities

00:02:08.410 --> 00:02:13.670
when one's to work with on a JPA resistance
base system like, say, your employees and

00:02:13.670 --> 00:02:18.030
their expense reports and so on, what kind
of fields they have, you press a button and

00:02:18.030 --> 00:02:22.390
then, hey, presto, a GWT application pops
out. I think in the course of various demos

00:02:22.390 --> 00:02:26.750
today you've all seen the sorts of applications
that pop out, and I've got too much to talk

00:02:26.750 --> 00:02:32.190
about, so we're going to jump pass that and
look into how that app is architected, why

00:02:32.190 --> 00:02:36.150
is architected the way it is, and how you
can write that way too. So let's talk about

00:02:36.150 --> 00:02:40.150
production ready. What does that actually
mean? It means a lot of things here. You need

00:02:40.150 --> 00:02:45.010
your app to be well tested, secure. You need
to be paying attention to what's going on

00:02:45.010 --> 00:02:49.250
when your users are using the thing. It needs
to be able to scale so that you got lots of

00:02:49.250 --> 00:02:53.570
people able to use it, and you got at least
a decent number of developers where lots probably

00:02:53.570 --> 00:02:59.030
means more than one; able to work on the thing.
As a web application it needs to be bookmark

00:02:59.030 --> 00:03:03.970
friendly, it needs to be crawler friendly,
and it needs to appeal to more than just the

00:03:03.970 --> 00:03:08.700
English speaking fraction of the world. I'm
going to talk about the few techniques to

00:03:08.700 --> 00:03:14.920
achieve all these goals. The biggest one is
isolation, which knocks out a lot of these

00:03:14.920 --> 00:03:19.740
concerns right off the bat. We're going to
talk about instrumentation, which we're going

00:03:19.740 --> 00:03:23.230
to actually use to do that monitoring and
let yourself keep in touch with what your

00:03:23.230 --> 00:03:30.090
poor users are experiencing. We're going to
talk about trading your users with love suspicion

00:03:30.090 --> 00:03:35.620
to protect them from people who are pretending
to be themselves. And we're actually not going

00:03:35.620 --> 00:03:39.020
to talk about localization because we talked
about it a bit, actually, this morning not

00:03:39.020 --> 00:03:46.780
yesterday during the GWT UI overhaul talk.
So take a look at YouTube for that. All right

00:03:46.780 --> 00:03:53.870
so, isolation. This is the bulk of the talk
and the bulk of the time. There's a--I'll

00:03:53.870 --> 00:03:58.580
maybe do a bit of a departure from some of
the talks you've been seeing today and the

00:03:58.580 --> 00:04:03.810
talk I did last year, there's going to be
not whole lot of code in front of you today

00:04:03.810 --> 00:04:11.290
and a whole of boxes in the lines. And that's
the large part because the techniques I describe

00:04:11.290 --> 00:04:15.680
or, you know, pretty generally useful, the
code that we're providing to get to going

00:04:15.680 --> 00:04:19.810
on this. We're frankly right in the middle
of writing ourselves. We've released today

00:04:19.810 --> 00:04:27.561
the 2.1 snapshot of--or the snap shot of the
2.1 release of GWT, that embodies some of

00:04:27.561 --> 00:04:30.880
this stuff. A lot of it is going to change
before we actually get to the next snapshot

00:04:30.880 --> 00:04:34.620
until they release this. So we're going to
talk a lot more about the concepts that we're

00:04:34.620 --> 00:04:37.940
implementing toward and I'll try to be honest
about which one's exist yet and which one

00:04:37.940 --> 00:04:44.980
were still very vaporous. So I keep talking
about this Model Presenter View--Model View

00:04:44.980 --> 00:04:51.510
Presenter pattern where the idea is to make
sure that the bits that are worth testing

00:04:51.510 --> 00:04:57.190
actually stay here in the presenter, in the
middle that is the intermediary between whatever

00:04:57.190 --> 00:05:02.490
model objects you're working with and the
slow and cumbersome down based view objects

00:05:02.490 --> 00:05:08.720
that actually get them in front of your user.
And as mentioned earlier this gets discussed

00:05:08.720 --> 00:05:13.630
in really beautiful detail by Daniel Denalados
at the talk that he just wrapped up here.

00:05:13.630 --> 00:05:18.850
I really encourage you to go ahead and watch
that. There will be points over the rest of

00:05:18.850 --> 00:05:24.810
my talk where I contradict points that Daniel
just made. I'm wrong, he's right, and I'm

00:05:24.810 --> 00:05:32.490
going to go back and change some stuff now.
But there's no time now. So, on we go. So

00:05:32.490 --> 00:05:38.170
let's start--let's work our way down from
through this box, talk about the parts of

00:05:38.170 --> 00:05:44.200
the triad here and what are new app framework
and the Roo code generation they're going

00:05:44.200 --> 00:05:50.200
to do to get you there. When you're in a web
app, we've encouraged you to make your model,

00:05:50.200 --> 00:05:56.030
your so-called model a very simple object.
We don't really think that JavaBeans with

00:05:56.030 --> 00:06:00.270
property change events and that kind of thing
work terribly well. We encourage you instead

00:06:00.270 --> 00:06:08.520
to use more of a DTO for your--for your model
portion. The odds are that the object that

00:06:08.520 --> 00:06:13.600
has the--that embodies the things that the
users are thinking about is a dumb little

00:06:13.600 --> 00:06:17.310
bag of properties. Hopefully, it's the same
thing that came across the wire when you made

00:06:17.310 --> 00:06:21.490
your RPC request. And, in fact, that's how
we've implemented the system that ROO is generating

00:06:21.490 --> 00:06:29.300
to. We've got a JavaScript objects that--JSOP
loads that are created on the server request

00:06:29.300 --> 00:06:32.950
time that make it across the wire to reevaluate
the instant to reach the browser and they

00:06:32.950 --> 00:06:37.760
don't become anything more complicated than
that until as individual properties are asked

00:06:37.760 --> 00:06:43.190
for. But when you tell people who are building
an enterprise app and I've got this beautiful

00:06:43.190 --> 00:06:47.090
Java model and they're writing into this cool
GWT tool which should be able to do all of

00:06:47.090 --> 00:06:50.800
their job and they want to share their code
that they've got to go ahead and write something

00:06:50.800 --> 00:06:55.660
that look sort of like their model but really
not quite the same, they get all grumpy. And

00:06:55.660 --> 00:06:59.271
they say I don't want have to write the same
thing over again. Everybody tells me not to

00:06:59.271 --> 00:07:05.419
repeat myself, why are you guys making me
work so hard. And we're going to hit on the

00:07:05.419 --> 00:07:10.910
theme here where possible between Roo and
GWT, we're trying to let the tools do the

00:07:10.910 --> 00:07:18.000
repetition for you. So, where you are using
the tool like Roo to actually define your

00:07:18.000 --> 00:07:22.470
domain objects the guys who get to persists
on the server-side and you validation logic

00:07:22.470 --> 00:07:28.590
in business logic. And that kind of a thing
will run the tool that finds very similar

00:07:28.590 --> 00:07:33.470
looking data objects, DTOs extracts them out,
make sure they live in a form that can make

00:07:33.470 --> 00:07:39.120
it across the wire for XHR request and lets
you work on from there. So I have a little

00:07:39.120 --> 00:07:42.460
gear there to indicate you didn't have to
write that, the tool load it for you, and

00:07:42.460 --> 00:07:48.340
the tools are going to do it's best to maintain
it for you as well. This is sort of an idealized

00:07:48.340 --> 00:07:57.880
MVP platonic model view of this type of thing.
Let's look at more of what's actually going

00:07:57.880 --> 00:08:05.160
on in the code that's getting generated by
Roo right now. And you want to hold on to

00:08:05.160 --> 00:08:10.780
these slides because I noticed one of the
questions on the live Wave earlier was words,

00:08:10.780 --> 00:08:18.610
the documentation for this alleged application
framework, this is it. So what we're looking

00:08:18.610 --> 00:08:26.590
at here is on the right side of the screen,
it's what's going on the servers. So, we've--we're

00:08:26.590 --> 00:08:32.860
making a request for--to read for a bunch
of employee objects. Find mail, the employee

00:08:32.860 --> 00:08:36.979
objects or find me the employee objects from
10 to 50 because that's what showing in my

00:08:36.979 --> 00:08:45.569
exciting new database widget right now. We
provide the stack servlet not GWT RPC but

00:08:45.569 --> 00:08:51.170
a new ground-up implementation in part, because
we're probably too prone to reinvent the world

00:08:51.170 --> 00:08:55.709
and in part because we want to make sure that
what we're working on here is going to be

00:08:55.709 --> 00:09:01.809
mobile friendly, and GWT RPC can lead to heavy
weight code. A brand new reusable servlet

00:09:01.809 --> 00:09:07.149
that will take the employee, knows about the
DTO that corresponds of the employee, serializes

00:09:07.149 --> 00:09:16.720
the JSON, send that across the response to
coincide request factory object. And when

00:09:16.720 --> 00:09:22.800
we generated the DTO that we showed you before,
the employee record that comes out of--that

00:09:22.800 --> 00:09:28.430
corresponds to the employee domain object
we also generated a series of request objects

00:09:28.430 --> 00:09:35.920
for you. So your client code was able to instantiate
the find me so many employees or find me employees

00:09:35.920 --> 00:09:43.050
via this characteristic object which correspond
to static service methods that you define

00:09:43.050 --> 00:09:49.869
at Roo time on the server-side. I talk through
this backwards, but I'm just going to keep

00:09:49.869 --> 00:09:54.869
on talking. That we built for you as well
as the record that comes back on the other

00:09:54.869 --> 00:09:59.880
side. And so the flow on your code is, I know
I need to sense--I know I need to displace

00:09:59.880 --> 00:10:04.139
some stuff to my user, click all, instantiate
this request object that somebody else wrote

00:10:04.139 --> 00:10:09.510
for me, fired it off, and the DTOs come back
from me and I can concentrate on my presenter

00:10:09.510 --> 00:10:13.179
code. So that's the read side of the equation
but I don't just want to read these things,

00:10:13.179 --> 00:10:18.179
I also want to mess with them. So besides
the fact that we're providing you a family

00:10:18.179 --> 00:10:23.290
of request objects that correspond to the
finders that you declared you wanted, we also

00:10:23.290 --> 00:10:30.079
have a general sink request object. What's
going on in the bowels of our friendly request

00:10:30.079 --> 00:10:37.279
factory here is that it is keeping what should
eventually be but is not yet in the 2.1 snapshot

00:10:37.279 --> 00:10:46.040
a cache of these records, of these value objects.
So when--it's time for me to change one of

00:10:46.040 --> 00:10:51.351
these things, we've got convenient methods
for me to say, "I'm the presenter and I'm

00:10:51.351 --> 00:10:54.790
working on an employee record." I know an
employee record has a bunch of properties,

00:10:54.790 --> 00:11:00.879
like its name, like its boss, like its display
name, I'm going to set those up. And now,

00:11:00.879 --> 00:11:06.260
I want you to sink those to the server for
me, the code that you don't have to write

00:11:06.260 --> 00:11:12.199
that we provide, looks at the properties that
you've changed. If it sees that--to take just

00:11:12.199 --> 00:11:15.720
the difference between those and the properties
that we're actually received on the last request,

00:11:15.720 --> 00:11:23.700
sends that delta back down to the request
factory servlet where it's calls the standard

00:11:23.700 --> 00:11:30.499
service methods, like a JSR 303 validation
code fire, gathers up any errors that were

00:11:30.499 --> 00:11:35.490
reported, sends them back across the wire
for display if they were there, and otherwise

00:11:35.490 --> 00:11:42.079
sends back a "everything's okay" type of message.
At this point another per entity class that

00:11:42.079 --> 00:11:47.709
we generated for you, a change event is fired
off to the event bus to let in the other parts

00:11:47.709 --> 00:11:53.170
of your UI that are interested in employees,
hear about the fact that somebody, they don't

00:11:53.170 --> 00:11:57.699
know who, has mess with these things, presuming
that they were no validation errors. If there

00:11:57.699 --> 00:12:01.759
were errors, no broadcast, only the person
who fired off the request cheers about it.

00:12:01.759 --> 00:12:10.970
They'll display the errors and so fort and
so on. And the sink request can take care

00:12:10.970 --> 00:12:18.899
of any creation operation you need to do,
any updates, any deletes. The idea is that

00:12:18.899 --> 00:12:23.191
the pattern that we've been telling you to
write your apps toward for the last year,

00:12:23.191 --> 00:12:29.569
we tried to implement the bulk of it for you.
But still all we've taken out of the equation

00:12:29.569 --> 00:12:33.739
so far are DTOs. You're on your own with the
presenters. You're on your own with the views.

00:12:33.739 --> 00:12:38.499
And presenter themselves can be kind of a
repetitious thing at least on the on there

00:12:38.499 --> 00:12:42.220
outside. They all kind of need a way to get
their hands on the view they're going to write,

00:12:42.220 --> 00:12:46.550
you need to pass state into them, and you're
going to do at least some copy-paste getting

00:12:46.550 --> 00:12:49.899
started with those. And for that matter, we're
trying to generate the entire application

00:12:49.899 --> 00:12:55.429
for you. So, how are we going to get into
that business? What we've decided to do or

00:12:55.429 --> 00:12:58.930
I shouldn't say what we decided to do, it's
more of what we decided to steal from other

00:12:58.930 --> 00:13:05.529
people at Google who work harder than we do
an actually build applications, is a pattern

00:13:05.529 --> 00:13:13.779
called activities and the activity manager.
I talked last year about a place change concept,

00:13:13.779 --> 00:13:20.790
a notion of a system to listen for browser
history events and tell the rest of the app

00:13:20.790 --> 00:13:24.379
or the event bus, "Hey, there's been a new
place that's going on." But we didn't talk

00:13:24.379 --> 00:13:30.129
a whole lot about how to react well to those
place changes when they happen. Within the

00:13:30.129 --> 00:13:37.980
company kind of two semi-frameworks have grown
up, one building very literally the place

00:13:37.980 --> 00:13:43.269
change notion that I talked about and that
turn into a framework that nobody else quite

00:13:43.269 --> 00:13:49.149
understands and has figured out how to generalize,
and another written by Tim that were big fans

00:13:49.149 --> 00:13:52.899
of this new fangled Android thing that was
coming out of the time, and especially it's

00:13:52.899 --> 00:13:58.999
notion of activities. And we're leaning towards
stealing that one because more people had

00:13:58.999 --> 00:14:03.070
figured how to reuse it. The activity name
is really good, but I don't want to imply

00:14:03.070 --> 00:14:07.709
too much here because while we stole that
nice activity name, the life cycle here and

00:14:07.709 --> 00:14:12.660
everything doesn't look a whole lot like what
Android does, just more of the concept is

00:14:12.660 --> 00:14:18.290
the same. So just like we generated this DTOs
for you to serve as your model objects when

00:14:18.290 --> 00:14:22.629
you run your friend Roo and it generate a
nice app for you that your user can navigate

00:14:22.629 --> 00:14:28.429
through to edit things and display lists of
things, is generating instances of this activity

00:14:28.429 --> 00:14:34.699
interface to actually run the show for you.
What's actually going under the hood looks

00:14:34.699 --> 00:14:39.470
something like this, you say that our friend,
the place change event is still actually noted

00:14:39.470 --> 00:14:43.850
there and the code that's in the snapshot
right now. We have both place change footing

00:14:43.850 --> 00:14:50.670
around this sort of a primitive low-level
the user wants to go somewhere concept without

00:14:50.670 --> 00:14:56.610
a whole lot of actual behavior associated
to it, and as primary consumer is a new class

00:14:56.610 --> 00:15:03.379
called the activity manager. I just configured
with the map that's responsible for making

00:15:03.379 --> 00:15:09.101
decisions like when the users goes to a place
in the app called edit a record of idea or

00:15:09.101 --> 00:15:17.439
whatever, we're going to instantiate this
record editor activity presenter type of thing

00:15:17.439 --> 00:15:23.619
and started going. So we've got a nice little
life cycle going of the event bus; the event

00:15:23.619 --> 00:15:27.759
bus notifies anybody interested in the app,
"Hey, the users had a different place now."

00:15:27.759 --> 00:15:32.239
And the activity managers that are listening
first see what activity they're running at

00:15:32.239 --> 00:15:38.889
the moment, tell it to stop, go away, you
don't get to play anymore. And they look at

00:15:38.889 --> 00:15:45.189
configuration and find the next activity to
instantiate or to reuse, probably instantiate

00:15:45.189 --> 00:15:50.459
and tell it to start, and then that's it.
Nothing else goes on at this point until the

00:15:50.459 --> 00:15:54.779
activity has had the chance to fire off and
an asynchronous request back to the service

00:15:54.779 --> 00:16:00.309
to pick up whatever state that it needs to
render itself, to set up a widget that it

00:16:00.309 --> 00:16:07.769
may have handed after this asynchronous strip,
the activity manager gets a call back, "Here's

00:16:07.769 --> 00:16:14.079
my widget, I finally have something to show
you, display it to the user now." This is

00:16:14.079 --> 00:16:19.529
all a long wended way to say that the activity
is a nice little mini-application within your

00:16:19.529 --> 00:16:24.709
application that gets told by somebody, you
go now, makes an asynchronous request to get

00:16:24.709 --> 00:16:29.970
it state with any lock that's going to hit
a cache on the way and that actually go over

00:16:29.970 --> 00:16:33.300
the wire the second or third time that it's
called and short circuit right away, but maybe

00:16:33.300 --> 00:16:38.819
it won't. But asynchronously, it will finally
call back and say, "Here's some UI that is

00:16:38.819 --> 00:16:44.269
interesting for me and I'm going to present
it like you'd presented for me now." Because

00:16:44.269 --> 00:16:48.889
the activity is isolated like this, all it
knows about is that it's time for you to turn

00:16:48.889 --> 00:16:52.619
on, do what it knows how to do and then let
somebody else handle, actually, putting that

00:16:52.619 --> 00:16:58.549
state--get some view state in front of the
user, it can run in nice isolation. It's really

00:16:58.549 --> 00:17:03.499
easy for me to write a mini-application that
does nothing but test my individual activity.

00:17:03.499 --> 00:17:10.589
If I want to really focus on the expense report
editing logic in my app in an interactive

00:17:10.589 --> 00:17:16.089
way that I can refresh the browser while rebuilding
my entire app, I've got a way t do that. If

00:17:16.089 --> 00:17:21.540
I want to write a nice little isolated JRE
unit test. I've got a nice unit through which

00:17:21.540 --> 00:17:29.559
I can do that as well.
That's the basic point of the activity it's

00:17:29.559 --> 00:17:37.169
a standard pattern for your presenter code
to actually adhere to so that somebody else

00:17:37.169 --> 00:17:44.570
can be in charge of actually firing the things
up and firing them down. As I started to imply

00:17:44.570 --> 00:17:49.549
here, because the activity is so self sufficient,
because it's not relying on other parts of

00:17:49.549 --> 00:17:57.130
the app to have actually made upstream requests
and so on, is something that can run by itself

00:17:57.130 --> 00:18:03.010
and that's makes it a very bookmarkable and
a very crawlable piece of your application.

00:18:03.010 --> 00:18:09.100
Each activity is expected to be fired into
existence as a side effect of a browser history

00:18:09.100 --> 00:18:13.220
event when the user clicks on the back--on
the fourth button, maybe hits a bookmark and

00:18:13.220 --> 00:18:18.110
is really expected to be very self sufficient.
That means that it's very bookmarkable somebody

00:18:18.110 --> 00:18:24.279
is going to go to the example.com#report number
1, duh-duh-duh-duh-duh. And the activity should

00:18:24.279 --> 00:18:30.049
be able to take care of everything from there.
If you've been paying attention to what's

00:18:30.049 --> 00:18:35.120
been announced on various blogs, et cetera
of the past year, you'll know that Google

00:18:35.120 --> 00:18:42.240
now supports a convention away for Ajax applications
to declare themselves to be crawlable. So

00:18:42.240 --> 00:18:48.059
if you've written your app and is bookmarkable
manner, you introduce a little bang after

00:18:48.059 --> 00:18:53.159
the hash sign in your bookmarkable URL, you're
certainly giving a clue to the Googlebot that

00:18:53.159 --> 00:18:59.390
you are also a crawlable Ajax app. I'm not
going to go into the full crawlability life

00:18:59.390 --> 00:19:04.950
cycle here because that's covered in great
depth at the link that you see down here.

00:19:04.950 --> 00:19:11.820
But by building your App in the style, you're
a good portion of the way to making yourself

00:19:11.820 --> 00:19:17.250
available to the kind of indexing, getting
more hits and getting more users. Follow the

00:19:17.250 --> 00:19:24.720
link for more info, please. So we've got our
DTOs being generated, we've got our activities

00:19:24.720 --> 00:19:30.900
being manage force and the initial version
of them having been written for us by a code

00:19:30.900 --> 00:19:35.679
generator. We still have this view code to
write. And what you're shooting for with your

00:19:35.679 --> 00:19:40.220
view code is something that's too boring to
write and too boring--or too boring to test,

00:19:40.220 --> 00:19:43.910
which means it's probably not going to be
a whole lot of fun to write. So we are going

00:19:43.910 --> 00:19:51.820
to regenerate those for you as well, and we're
going to use a new GWT code generator to support

00:19:51.820 --> 00:19:57.350
you along the way. And new editor support
interface whose job is to do a lot of the

00:19:57.350 --> 00:20:04.750
data binding activities for you. And coming
up here we have about the only code slide

00:20:04.750 --> 00:20:12.980
that you'll see in the presentation today.
We're shooting for something like this, you

00:20:12.980 --> 00:20:16.710
imagine that you're looking at the code behind
a view that's going to take an employee record,

00:20:16.710 --> 00:20:22.370
let's go into put that in front of your user
with the name filled and the name text box

00:20:22.370 --> 00:20:28.910
and the display name and display text box
and so on. When you're finally writing that

00:20:28.910 --> 00:20:37.250
code that comes down to a lot of employee,
get name--or sorry--"employeetextbox.setvalue.employeerecord.getname"

00:20:37.250 --> 00:20:43.770
and that kind of stuff over and over again.
When it comes time to pull those--that information

00:20:43.770 --> 00:20:48.529
back out of the UI, you'll write a lot of
the same get methods; "textbox.getvalue" and

00:20:48.529 --> 00:20:54.169
set that into the record and it's really rather
tedious. It gets even more annoying when you

00:20:54.169 --> 00:20:58.190
get to the point of having validation errors
that you need to display to your users. The

00:20:58.190 --> 00:21:02.410
odds are that most of them you've tried to
do some the client side and we do intend to

00:21:02.410 --> 00:21:09.049
automate a lot of client said revalidation
for you not in a snapshot yet but will get

00:21:09.049 --> 00:21:13.809
it there. But most of the interesting validation,
especially, in the business logic validation

00:21:13.809 --> 00:21:19.100
is going to happen back in the server, at
which point a request will--been fired, a

00:21:19.100 --> 00:21:23.940
response will come back, and you'll have a
mass of errors tied to a particular field

00:21:23.940 --> 00:21:28.539
which you then have to route to the show to
the appropriate bid of UI, the same generated

00:21:28.539 --> 00:21:34.130
class should be responsible for noticing which
errors respond to which fields getting them

00:21:34.130 --> 00:21:37.690
tied to the appropriate bit of the UI and
put the cute little red flag at the right

00:21:37.690 --> 00:21:43.551
spot. The support class is also very capable
of letting you know if anything has actually

00:21:43.551 --> 00:21:47.920
changed here, so that when you want to write
your logic for, say, your save button. And

00:21:47.920 --> 00:21:52.090
whether that should be enabled or disabled,
there's automated way to ask, "Has the user

00:21:52.090 --> 00:21:56.380
actually typed any values that don't match
the backing model object that I'm displaying

00:21:56.380 --> 00:22:01.570
here right now." You've got an easy way to
know whether you need to warn the user, "Hey,

00:22:01.570 --> 00:22:05.049
you're about to leave this part of the app."
And throw up a warning about the changes that

00:22:05.049 --> 00:22:13.480
they are about to lose. So, this is a--when
I hinted at the beginning that there are contradictions

00:22:13.480 --> 00:22:18.860
between, what our friend, Daniel, said in
his testing talk and I've said right now,

00:22:18.860 --> 00:22:24.570
here's a spot where I suspect that we are
aiming at the wrong layer. The way the code

00:22:24.570 --> 00:22:28.190
is generating itself right now, what I'm implying
here right now is that you've actually got

00:22:28.190 --> 00:22:32.960
a fairly complicated view class that knows
about your value object. You can crumb a value

00:22:32.960 --> 00:22:36.520
object into it and you can do all kinds of
display, let the user mess with things and

00:22:36.520 --> 00:22:42.809
pull it back out again. The class does wind
up actually being very simple provided you're

00:22:42.809 --> 00:22:48.179
actually using the support object here to
do all the fairly complicated but mechanical

00:22:48.179 --> 00:22:51.891
marshalling in and marshalling out, maybe
that's the right space, maybe that's the wrong

00:22:51.891 --> 00:22:56.800
space. It may turn out that by the time we
shipped this monster in GWT 2.1, our friend,

00:22:56.800 --> 00:23:02.000
the data binding classes moved up into the
presenter level maybe, maybe not. But that's

00:23:02.000 --> 00:23:09.450
the approach that we're at right now. Okay.
So we've talked about isolation and we've

00:23:09.450 --> 00:23:13.470
hit a lot of the points that we said that
isolation would cover for us. We're well tested

00:23:13.470 --> 00:23:18.659
now because we can do all kinds of testing
on our nice isolated electivity objects. We've

00:23:18.659 --> 00:23:23.289
got a lot of developers going because my activity
doesn't know anything about your activity.

00:23:23.289 --> 00:23:27.080
They're not very likely to have side effects
on one another. We're bookmark friendly, we're

00:23:27.080 --> 00:23:31.729
crawlable because each of our little activities
can run in isolation from everybody else.

00:23:31.729 --> 00:23:37.860
We haven't really gotten to the lots of users
promise and none of this actually feeds into

00:23:37.860 --> 00:23:42.110
that, really have sort of--just sort of crammed
that one into the isolation theme because

00:23:42.110 --> 00:23:47.220
I like it the way it all shaped up and I wanted
to look it together. The way that we're getting

00:23:47.220 --> 00:23:52.460
there in the apps that we're generating with
Roo or that we're deploying on App Engine

00:23:52.460 --> 00:24:04.080
is by encouraging you at--to work in against
a subset of the JPA feature set. The app that

00:24:04.080 --> 00:24:09.529
you saw generated today or start generated
and demonstrated the keynote yesterday was

00:24:09.529 --> 00:24:16.259
a proper JPA app. It can be deployed to any
JPA backend and that includes the App Engine.

00:24:16.259 --> 00:24:21.240
And the reason that's able to be deployed
to the App Engine is that it's stayed very

00:24:21.240 --> 00:24:30.320
far away from relationship, reference features
of JPA. What happens with providers today,

00:24:30.320 --> 00:24:35.970
as your probably familiar with, is Google
specific persistence layer called the Datastore,

00:24:35.970 --> 00:24:41.179
and the Datastore can scale up to scary big
numbers of records and maintain all kinds

00:24:41.179 --> 00:24:45.690
of speed and responsiveness. But the way that
it can do that is by being very restrictive

00:24:45.690 --> 00:24:53.549
about what kinds of relationships you can
have between the records within an application.

00:24:53.549 --> 00:24:59.429
If you want to maintain that kind of scale
or the way should put it is when you're riding

00:24:59.429 --> 00:25:03.240
one these apps you cannot have a choice. Do
I want something that's going to be super

00:25:03.240 --> 00:25:08.429
portable and super scalable to Google levels?
And there's features of JPA that I should

00:25:08.429 --> 00:25:14.170
stay away from. And our intention is to have
Roo able to keep you on the guidelines, keep

00:25:14.170 --> 00:25:19.600
you within the boundaries for working to that
scale if you want to, or if you decide that

00:25:19.600 --> 00:25:24.300
you want to build and deploy anywhere, anywhere
except GAE because you just want things to

00:25:24.300 --> 00:25:27.980
be scaleable enough but you're not really
going to be doing millions of users and billions

00:25:27.980 --> 00:25:32.830
of records just the usual hundreds or dozens
or thousands for an enterprise app, go ahead

00:25:32.830 --> 00:25:40.990
and use the rest of the features. So regardless
of which of those styles that you choose,

00:25:40.990 --> 00:25:48.700
persistent side for your entity objects, and
let me say a little bit more about that, when

00:25:48.700 --> 00:25:54.030
you're making this choice between using real
references or not server- side, what you're

00:25:54.030 --> 00:26:00.139
actually choosing between is, does my employee
record include a boss field that is of type

00:26:00.139 --> 00:26:05.710
employee or does my employee record include
a boss field that is type long, the idea of

00:26:05.710 --> 00:26:12.129
my--the idea of my other related boss, my
rather related employee. Am I going to manually

00:26:12.129 --> 00:26:17.460
maintain the code for navigating from employee
to employee to his expense reports and so

00:26:17.460 --> 00:26:21.330
on or Am I going to use the features built
in the JPA to make this kind of thing more

00:26:21.330 --> 00:26:25.970
convenient like I'm used to. That's all server-side
decisions, that's all server-side cumbersome

00:26:25.970 --> 00:26:33.519
code; someone which we hope to actually automate
for you and there is support. Client side,

00:26:33.519 --> 00:26:37.390
it doesn't make a whole lot of a difference.
Client side you pretty much always want to

00:26:37.390 --> 00:26:43.451
be working in this--this record doesn't accidentally
pull along that record and accidentally pull

00:26:43.451 --> 00:26:49.399
along his related records and their records
and so on, kind of transitive explosion nonsense

00:26:49.399 --> 00:26:56.240
in your web browser code. That's why we pushed
the notion of going to DTOs in the first place,

00:26:56.240 --> 00:27:04.250
by not trying to bring over your server-side
business objects into your browser mechanically

00:27:04.250 --> 00:27:08.840
without thinking about it. You're never going
to be accidentally pulling across the entire

00:27:08.840 --> 00:27:14.559
object graph when all you really wanted was
to know somebody's first name. So whether

00:27:14.559 --> 00:27:19.680
you server-side code is working with full
references and pointers to pointers to pointers

00:27:19.680 --> 00:27:24.019
or not; client-side, your code will already
have been written in style of, "Okay, give

00:27:24.019 --> 00:27:27.749
me the employee. Okay, now give me the related
records. Okay, give me this, give me that."

00:27:27.749 --> 00:27:31.039
So you've actually a lot of flexibility in
about where you're going to choose to deploy

00:27:31.039 --> 00:27:38.840
regardless of which style you choose to write
in. So I think I've exhausted isolation. I've

00:27:38.840 --> 00:27:43.669
talked about that as much as I really can,
but we still have other things that we needed

00:27:43.669 --> 00:27:48.330
to do to have a production ready app. We need
to instrument it, we need to know what are

00:27:48.330 --> 00:27:52.690
users are actually going to be doing, and
there's a sort of three things that we need

00:27:52.690 --> 00:27:59.299
to do to get there. We need decent logging
we need stack traces so that when things go

00:27:59.299 --> 00:28:06.410
wrong we have hope for figuring out what actually
happened, and we need a pattern that we're

00:28:06.410 --> 00:28:11.929
referring to now user actions. Again, something
that's I'm stealing from several very successful

00:28:11.929 --> 00:28:18.330
Google teams, and let's go on to more depth
on each of those. So logging first and foremost

00:28:18.330 --> 00:28:23.960
is a pretty obvious thing that has been sadly
lacking inside the GWT tool kit proper for

00:28:23.960 --> 00:28:30.850
mail ever. There's a very popular package
that's outside of GWT, the GWT log package.

00:28:30.850 --> 00:28:36.620
You can find it on code.google.com. It's in
wide use within Google. It's in wide use externally

00:28:36.620 --> 00:28:41.360
to Google. A guy named Fred Sauer, we now
have--actually happens to work for us as its

00:28:41.360 --> 00:28:49.679
maintainer. As of GWT 2.1, you no longer have
to go outside of GWT in order to get what

00:28:49.679 --> 00:28:56.610
should be a fundamental service of your app.
We actually have honest to goodness Java Util

00:28:56.610 --> 00:29:01.269
logging emulation in GWT as of this snapshot
and it will be ready for primetime as 2.1

00:29:01.269 --> 00:29:06.620
actually ships. And the difference between
the Java Util loggin, let's move into GWT

00:29:06.620 --> 00:29:14.070
2.1 in Fred's excellent package is that we
actually were able to provide the standard

00:29:14.070 --> 00:29:19.350
Java Util logging API rather than having to
make some compromises. Fred isn't an exact

00:29:19.350 --> 00:29:24.110
match and for the very good reason that at
a time that it was written there was no way

00:29:24.110 --> 00:29:30.070
you could implement to a standard Java Util
logging API which encourage you to have logger

00:29:30.070 --> 00:29:35.370
objects around to talk to you directly rather
calling any aesthetic methods. There was no

00:29:35.370 --> 00:29:40.049
way that the GWT compiler of the day could
completely dead strip code written in such

00:29:40.049 --> 00:29:43.519
a style. What if you decided you want to turn
on the knob and make sure that what to put

00:29:43.519 --> 00:29:49.320
your users actually wasn't going to cause
in many trouble. Somewhere along the way the

00:29:49.320 --> 00:29:55.490
GWT compiler got a lot smarter, I'm not sure
exactly when or what happened, but when we

00:29:55.490 --> 00:30:01.450
sat down to--we just--we revisit this problem
and see if it's still the case that we have

00:30:01.450 --> 00:30:04.429
been convincing ourselves and telling--preaching
the people for years that you can't do that

00:30:04.429 --> 00:30:11.750
anymore, it just wasn't true. My officemate,
Una, did some tests and very empirically showed

00:30:11.750 --> 00:30:16.919
that no matter what kind of stuff you throw
at a logging object these days, if that logging

00:30:16.919 --> 00:30:22.690
object is instantiated through a code path,
it could never have returned anything but

00:30:22.690 --> 00:30:29.669
null. It will simply evaporate. I'm hand waving
a bit here about what the actual coding patterns

00:30:29.669 --> 00:30:32.879
are that you need to follow in order to make
sure that kind of thing a happens. But it's

00:30:32.879 --> 00:30:40.110
fairly straightforward. If you want to play
with this today, it's in the snapshot. Documentation

00:30:40.110 --> 00:30:43.360
will follow showing kind of dos and don'ts
about how to work with these things to keep

00:30:43.360 --> 00:30:50.660
the safe. But it'll all be there. So, anyway,
a long-winded digression; what you actually

00:30:50.660 --> 00:30:56.639
want to do with this client side logging to
keep an eye on what your users are up to is

00:30:56.639 --> 00:31:02.900
keep a buffer of the logs accumulating on
the client side. It's up to you to decide

00:31:02.900 --> 00:31:05.960
how much you actually you want to hold on
to, how much you want to send down right away.

00:31:05.960 --> 00:31:12.429
But there's no reason to be sending an RPC
request every time any kind of a logline happens.

00:31:12.429 --> 00:31:16.919
Kind of the meta-point here is just because
you can set a knob and dead strip all of your

00:31:16.919 --> 00:31:20.639
logging code if you want to, there's no particular
reason that you need to dead strip everything,

00:31:20.639 --> 00:31:25.620
if it's going to be useful to keep an eye
on the health of your app. Maybe you're just

00:31:25.620 --> 00:31:29.429
going to turn the trace level of knob up to
the info level knob or the super info level

00:31:29.429 --> 00:31:35.780
knob or something like that. But with each
logline that you leave in there, you accumulate

00:31:35.780 --> 00:31:41.399
them all, server side; and you listen to our
friendly event bus for announcements that

00:31:41.399 --> 00:31:47.470
there's a request that's about to hit the
user. Something I meant to go into in the

00:31:47.470 --> 00:31:52.700
request factory section of this. What I forgot
about is that it is our intention to have

00:31:52.700 --> 00:31:57.700
the request factory, provide both batching
and caching services for you. So that while

00:31:57.700 --> 00:32:01.540
you're a nice little isolated activity objects
are firing off the request for this and the

00:32:01.540 --> 00:32:06.610
request for that and so on, they're all going
through a nice centralized point in that service

00:32:06.610 --> 00:32:10.259
object, the request factory service object,
so that with each tick of the event loop,

00:32:10.259 --> 00:32:16.389
we can send an entire batch down for you.
And that gives us a nice train that are accumulated

00:32:16.389 --> 00:32:20.389
logging statements over the last event loop
tick or longer if that's appropriate to us,

00:32:20.389 --> 00:32:30.909
can go down into a single--to hitch a ride
along that same ride. Oops. Yes, there's more

00:32:30.909 --> 00:32:35.080
I want to say on this, but we'll come back
to it later, so I won't confuse myself now.

00:32:35.080 --> 00:32:41.450
So logging coming now but you can use it today
in the gwt-log package, and you probably already

00:32:41.450 --> 00:32:47.429
are. Stack traces. You've probably know that
you do get some kind of a Stack Trace on most

00:32:47.429 --> 00:32:51.809
modern browsers with one glaring exception.
But the interesting thing is that you actually

00:32:51.809 --> 00:32:56.369
want to get this information to the server.
You've actually had support for doing that

00:32:56.369 --> 00:33:02.139
kind of thing in GWT for a little while now.
I believe with GWT 2.0, if you rummage around,

00:33:02.139 --> 00:33:06.940
you'll find a convenient object called the
HttpThrowableReporter. And his job in life

00:33:06.940 --> 00:33:12.769
is to take a throwable and get it to the URL
of your choice in a simple little JSON format

00:33:12.769 --> 00:33:17.269
that you can then start logging server side
and keeping track of yourself. gwt-log, the

00:33:17.269 --> 00:33:21.619
package that we were just talking about comes
standard with the remote logging service,

00:33:21.619 --> 00:33:25.769
which is also capable of doing this kind of
thing. Grab a throwable, stick it in to a

00:33:25.769 --> 00:33:31.000
logging statement and it'll reach the server
at some convenient point. What people might

00:33:31.000 --> 00:33:37.639
be less familiar with is that it's possible
to make these exemptions actually useful.

00:33:37.639 --> 00:33:43.210
What happens normally with GWT compiled code
is lots of good obfuscation happens, we're

00:33:43.210 --> 00:33:46.850
squeezing all of the juice out, so that your
users don't have something bloated. But as

00:33:46.850 --> 00:33:51.370
a result of that if you're using gwt-log,
if you use the ThrowableReporter to capture

00:33:51.370 --> 00:33:54.940
these exemptions that happen in production
time, and send them down to your server, you

00:33:54.940 --> 00:34:00.210
get thingy little gibberishy sort of symbols
that its kind of hard to take--make--get any

00:34:00.210 --> 00:34:08.940
information out of. With GWT 2.0, it is possible
to re-symbolize these obfuscated stack traces.

00:34:08.940 --> 00:34:13.840
We've actually even documented that fact,
if you follow the URL that's on the screen

00:34:13.840 --> 00:34:19.310
there. And my apologies if it's too small
to read, but it is what it is. I'm sure that

00:34:19.310 --> 00:34:23.120
when you scribe back over to YouTube video
with a magnifying glass, it'll be no problem.

00:34:23.120 --> 00:34:32.060
If you follow that page, you'll see a recipe
of how to get these all done, but it is rather

00:34:32.060 --> 00:34:37.100
minimal documentation. We'll try to follow
up on this and get you a little more repeatable

00:34:37.100 --> 00:34:43.990
recipe. And it is also, of course, our intention
that the apps, like it generated by the Roo

00:34:43.990 --> 00:34:49.420
tools will have those kind of stuff configured
for you already. It's not there yet but it

00:34:49.420 --> 00:34:54.470
is on the roadmap and it should be part of
the 2.1 release. But these stack traces besides

00:34:54.470 --> 00:34:59.820
being obfuscated, although, now you know how
to solve that problem, are also kind of granular.

00:34:59.820 --> 00:35:04.900
If you even have the things, and the sizeable
portion of your users will be using browsers

00:35:04.900 --> 00:35:08.990
that don't provide them, the best they're
going to get you is function level--method

00:35:08.990 --> 00:35:15.530
level information. If you got a Stack Trace--an
exception that is thrown inside of a method

00:35:15.530 --> 00:35:20.050
that's 100 lines long, you're going to be
told--it was that method. That was the one

00:35:20.050 --> 00:35:23.251
where the problem was. But you've got no line
number information. There's not a lot you

00:35:23.251 --> 00:35:28.770
can do with that point. That problem also
has been as solved as it can be in GWT 2.0.

00:35:28.770 --> 00:35:34.180
There's a new knob that you can turn on called
Stack Trace Simulation. This gets you any

00:35:34.180 --> 00:35:39.351
kinds of exceptions at all on browsers that
don't actually provide stack traces, and it

00:35:39.351 --> 00:35:45.670
can be set--I've lost track of how configurable
it is. At one point the plan was to let you

00:35:45.670 --> 00:35:49.710
decide how much emulation it does. I know
that if you just turn the thing on by setting

00:35:49.710 --> 00:35:56.770
this property in a "gwt.xml" file. We actually
will keep track of line number information.

00:35:56.770 --> 00:36:03.300
Do all kinds of crazy stuff behind the scenes
to give you a full useful stack traces when

00:36:03.300 --> 00:36:07.490
they're thrown. The down side of doing all
of this is that does make your apps slower

00:36:07.490 --> 00:36:12.970
and makes your app fatter. Not as much slower
and fatter as you might fear, I think, the

00:36:12.970 --> 00:36:16.920
speed numbers that I recall on the order of
a factor of two or so. The code bloat was

00:36:16.920 --> 00:36:23.830
10s or 20% something like that. Don't quote
me on that, I'm making it up. It's enough

00:36:23.830 --> 00:36:27.040
of a difference that you don't really want
most of your users working like this, but

00:36:27.040 --> 00:36:30.020
it's small enough that you might be tempted
to actually sneak a few of them out there

00:36:30.020 --> 00:36:37.660
and make it available to people. One technique
that you might do is compile a version of

00:36:37.660 --> 00:36:42.390
your app that you can point your users at,
that has the emulation put in. So you get

00:36:42.390 --> 00:36:46.630
a report of, "This terrible thing is happening
when I ran my app." You can shoot a response

00:36:46.630 --> 00:36:49.720
back saying, "Well, could you ran the app
and add to it this nice little debug flag

00:36:49.720 --> 00:36:55.101
for me? And we'll see what you get, or I'll
watch my logs as it goes on." And you can

00:36:55.101 --> 00:37:00.770
use this configuration set-up in your "gwt.xml"
to make that possible for your users. You

00:37:00.770 --> 00:37:06.740
could use more complicated approaches to actually
define percentage experiments. One team does

00:37:06.740 --> 00:37:12.970
inside of Google. I believe, they said they
were going to, is for their Internet Explorer

00:37:12.970 --> 00:37:21.490
users who might need certain other profile--certain
other characteristics. I don't remember exactly.

00:37:21.490 --> 00:37:26.070
You know, a percentage of interesting users
to a version of the app that actually has

00:37:26.070 --> 00:37:31.520
the full instrumentation compiled in like
that and collect the exception reports that

00:37:31.520 --> 00:37:35.610
appear there, and so they actually have some
picture of what's been going on without slowing

00:37:35.610 --> 00:37:42.080
down everybody in the world as they do it.
And, again, once you have your hands on these

00:37:42.080 --> 00:37:48.000
exceptions client side, it's really not all
hard to let them trickle back to the server,

00:37:48.000 --> 00:37:54.600
log them, start running your apps on them,
that kind of a thing. So, instrumentation

00:37:54.600 --> 00:38:03.530
the final piece of the puzzle there are user
actions. Here, at my most hand-wavy. It's

00:38:03.530 --> 00:38:11.170
this code that has basically been designed
and been discussed among teams that use this

00:38:11.170 --> 00:38:16.180
technique inside the company. There's nothing
implemented yet in the snapshot. Monday morning,

00:38:16.180 --> 00:38:24.790
the ground breaking begins. But the simple
but tremendously powerful idea here is that

00:38:24.790 --> 00:38:29.190
you associate portions of your app, piece
of your app that the user can touch with unique

00:38:29.190 --> 00:38:35.480
strings, just something to identify them.
Link elements, buttons, tab items, that kind

00:38:35.480 --> 00:38:42.380
of a thing. It's really quite simple, in fact,
to set up your system in such a way that you

00:38:42.380 --> 00:38:47.590
can have these strings embedded in the "ui.xml"
files that actually define your user interface.

00:38:47.590 --> 00:38:54.050
So that when I use my magical user action
link widget, instead of the normal stock link

00:38:54.050 --> 00:38:58.060
widget. I can add an attribute that says,
"This is user action. The user has asked to

00:38:58.060 --> 00:39:04.640
edit something," that sort of a deal. Such
instrument in widgets when the user actually

00:39:04.640 --> 00:39:09.550
clicks them or whatever, make an announcement
to the event bus, because we like event buses.

00:39:09.550 --> 00:39:14.890
Somebody else is listening on the event bus
to hear whenever an UI element declares the

00:39:14.890 --> 00:39:21.070
user has started action X and they start the
timer. He's also listening to the event bus

00:39:21.070 --> 00:39:25.970
for RPC events that might happen as a side
effect of this user action having been started.

00:39:25.970 --> 00:39:31.450
So employees are requested, syncs operations
are made, that kind of a thing and keeps the

00:39:31.450 --> 00:39:40.120
timer going. As responses are received over
the next few--microseconds or hopefully microseconds,

00:39:40.120 --> 00:39:46.251
the activity manager is listening for a paired
event from the request factor announcing,

00:39:46.251 --> 00:39:50.380
"Okay, I've gotten the responses for this."
When it sees all the responses, matching all

00:39:50.380 --> 00:39:56.830
the requests that happened after that the
user did something, event was fired. The timer

00:39:56.830 --> 00:40:01.730
shuts down and we log something. And we're
back to taking advantage of our friend, the

00:40:01.730 --> 00:40:07.590
logging the system, to accumulate our user
action logs, client side and trickle them

00:40:07.590 --> 00:40:12.970
down to the server as they're actually needed.
With all of this stuff, we keep talking about

00:40:12.970 --> 00:40:18.900
accumulating things client side, letting them
ride the batch back down, it's up to you where

00:40:18.900 --> 00:40:22.350
you want to make the tradeoff of talking to
the server too much and bothering your users

00:40:22.350 --> 00:40:29.000
and talking to the server too little and losing
information. The team that's been particularly

00:40:29.000 --> 00:40:36.400
pioneering with the user action pattern started
off keeping, I think, their basic aoristic

00:40:36.400 --> 00:40:40.820
was whenever we see a request going down,
we'll flush our accumulation--our accumulated

00:40:40.820 --> 00:40:45.800
logs of user actions and whatever else. And
of nobody is asked the server for anything

00:40:45.800 --> 00:40:51.550
in 30 seconds, we'll fire off a request of
our own. That proved to be too long. A lot

00:40:51.550 --> 00:40:54.350
of information was being lost. It was still
hard to debug things. They're now at the point

00:40:54.350 --> 00:40:58.690
where I think that if no user action happens
for three seconds, they'll actually go ahead

00:40:58.690 --> 00:41:03.440
and force a request to go back to the server.
No users have noticed. It doesn't seem to

00:41:03.440 --> 00:41:09.130
impede performance at all. And they wind up
with a very sophisticated description of what

00:41:09.130 --> 00:41:13.890
users are up to, and in particular what chain
of events led to, perhaps, the exemption that

00:41:13.890 --> 00:41:18.040
got logged on the next after the user action
log was happening or it got intermingled in

00:41:18.040 --> 00:41:25.510
with the user action log. One other interesting
thing I'd want to point out here is this team

00:41:25.510 --> 00:41:30.941
made the conscious choice, rather than tying
these user action descriptions to activities--remember

00:41:30.941 --> 00:41:36.350
activities? We talked about those at the beginning.
Rather than deciding that our nice little

00:41:36.350 --> 00:41:40.700
isolated activities would be the unit of,
"Hey, the user's doing something. Let's make

00:41:40.700 --> 00:41:44.810
note of that and than start logging requests."
They wanted something a lot finer grained.

00:41:44.810 --> 00:41:52.860
Once I'm within an activity, I could be exposing
menus, hiding menus. I could be moving focus

00:41:52.860 --> 00:41:57.110
between things; a lot of stuff that doesn't
have anything to do with browser history or

00:41:57.110 --> 00:42:05.180
states within the application. And so, they
chose to actually make this a very micro instrumentation

00:42:05.180 --> 00:42:08.910
sort of feature. It's worked out nicely with
them and they've got one of the most beautifully

00:42:08.910 --> 00:42:12.990
designed apps in the company as a result.
I mean, not only can they keep an eye on the

00:42:12.990 --> 00:42:17.390
quality, the exception reports and bugs that
are happening. They also have a good notion

00:42:17.390 --> 00:42:21.220
of what features get used, what features don't
get used. They're able to keep--they're able

00:42:21.220 --> 00:42:25.450
to discover that--this really cool and important
feature that we just implemented and spent

00:42:25.450 --> 00:42:31.230
a month of engineering time on, nobody can
find it and nobody clicks it, maybe its time

00:42:31.230 --> 00:42:36.080
to move that around. The more information
you have, the more information you can react

00:42:36.080 --> 00:42:43.760
to. So that's monitoring. Now, let's talk
about suspicion. I don't have a huge amount

00:42:43.760 --> 00:42:48.660
to say here. I just want to point out a couple
of features that have found their way out

00:42:48.660 --> 00:42:55.670
from behind the curtain recently. What this
is all about is guarding against cross-site

00:42:55.670 --> 00:43:01.281
attacks. And there's a kind of a cute little
thing that's sort of snuck into--let me see.

00:43:01.281 --> 00:43:07.840
What did I say? I wrote it down there. I don't
have to remember. Its making its debut in

00:43:07.840 --> 00:43:17.420
GWT 2.1 and that is our habit of sending down
on every request in GWT RPC. A header that

00:43:17.420 --> 00:43:25.960
tells you the strong name of the particular
GWT-Permutation, your client code--excuse

00:43:25.960 --> 00:43:32.360
me. We set a header on every request with
this magic name X-GWT-Permutation. The header

00:43:32.360 --> 00:43:39.140
is actually there to help in stack trace the
obfuscation in order to know what symbols

00:43:39.140 --> 00:43:43.160
are actually there in the stack trace. You
have to know what flavor of your app was compiled,

00:43:43.160 --> 00:43:50.090
but a clever person noticed, "Hey, this header
is going down." Only XHR requests are allowed

00:43:50.090 --> 00:43:55.810
to set custom headers like this. XHR requests
are only allowed to return to the domain from

00:43:55.810 --> 00:44:01.160
which the code originated. So, it's difficult,
not quite impossible. I think versions of

00:44:01.160 --> 00:44:04.500
Flash will let you get around this. But they
aren't difficult from malicious code loaded

00:44:04.500 --> 00:44:10.520
through a script tag or by accidentally rendering
some user generated HTML to actually set such

00:44:10.520 --> 00:44:19.550
a header. And so, the GWT servlet that actually
fields good RPC request by default now will

00:44:19.550 --> 00:44:23.230
refuse a request that doesn't have this header
set. If that's causing you trouble for any

00:44:23.230 --> 00:44:28.300
reason, it's very easy to turn their protection
off. Its also nice point which you try to

00:44:28.300 --> 00:44:32.430
get a little bit more clever about what kind
of headers you're looking for. It's a nice

00:44:32.430 --> 00:44:37.791
override point in the app, but it's there
now. You're one step closer to save. Something

00:44:37.791 --> 00:44:46.560
else that has also appeared in the last 24
hours with very little fanfare is a--I guess

00:44:46.560 --> 00:44:50.920
it could call it a framework. A new framework
called SafeHTML. This is something that we've

00:44:50.920 --> 00:44:58.920
been using internally for quite a while now.
And it's a system for--I'll talk about what

00:44:58.920 --> 00:45:02.740
kind of a system it is, but let's talk a little
bit it first about where you can find it.

00:45:02.740 --> 00:45:07.310
The Wave team, among many other things, yesterday,
while announcing that they have opened themselves

00:45:07.310 --> 00:45:15.290
to all comers, also open source a whole lot
more stuff, including a full Wave web-based

00:45:15.290 --> 00:45:21.000
client that took their FedOne client. They've
made a web version of it. The code is totally

00:45:21.000 --> 00:45:25.590
open for you to mess with, including a lot
of the interesting display code that Daniel

00:45:25.590 --> 00:45:31.280
wrote. And in order for them to open source
that, they had to open source our nice little

00:45:31.280 --> 00:45:35.150
HTML scrubbing system SafeHTML. It's something
that we've been hoping to kind of get in to

00:45:35.150 --> 00:45:39.970
GWT at some point 2.2, 2.3, it's out their
now because another team got impatient. It's

00:45:39.970 --> 00:45:46.140
there for you to find rummaging around the
Wave open source code site and we'll incorporate

00:45:46.140 --> 00:45:53.300
into GWT a little bit more robustly at two-point
sometime, someday. So, what's SafeHTML basically

00:45:53.300 --> 00:46:01.440
does for you is it tries really hard to discourage
you from ever using the setinnerHtml call,

00:46:01.440 --> 00:46:07.680
the problem or the setHtml ware on widgets
setinnerHtml on done elements. The problem

00:46:07.680 --> 00:46:16.160
with that call is you--if it they got it builds
DOM. And it can build script blocks and it

00:46:16.160 --> 00:46:19.220
can do all kinds of things. And there's a
really good chance that when you're recalling

00:46:19.220 --> 00:46:23.360
it, you forgot to make sure that what you're
rendering there didn't come from your user

00:46:23.360 --> 00:46:29.700
who intentionally or accidentally wrote/script
rummage from my data and send it off to somebody

00:46:29.700 --> 00:46:37.470
else and dot, dot, dot, dot, dot, dot. What
SafeHTML framework does is it introduces interface

00:46:37.470 --> 00:46:44.240
called SafeHTML which promises that, "I am
some HTML that somebody very clever carefully

00:46:44.240 --> 00:46:50.750
assembled for you in a way that didn't come
from user sources that doesn't accidentally

00:46:50.750 --> 00:46:54.580
include extra angle braces to break things
and so on. And you can just go ahead and plug

00:46:54.580 --> 00:47:01.331
me in some place." It's--it doesn't get but
by the time it's incorporated into GWT proper

00:47:01.331 --> 00:47:08.250
it will come along with the revamping of our
widgets to deprecate setHtml methods and replace

00:47:08.250 --> 00:47:13.650
them with setsafeHtml methods to encourage
you when you do actually need to build bits

00:47:13.650 --> 00:47:20.470
of HTML. Use a convenient builder object that
knows how to stop these things together where

00:47:20.470 --> 00:47:25.630
they're accidentally having--rendering side
effects on you. It also includes a runtime

00:47:25.630 --> 00:47:30.570
such--that our friend, SafeHTML builder meant
to be more of a semi-compiled time type of

00:47:30.570 --> 00:47:35.160
thing. We have the SimpleHtmlSanitizer that
comes along with it for when you actually

00:47:35.160 --> 00:47:40.290
do need to take some information from the
user client side and run it through some--sanitizing

00:47:40.290 --> 00:47:47.570
before you put it in front of them. That's
the basic idea of it, but it's like I said,

00:47:47.570 --> 00:47:52.520
it's not in GWT yet but it's hugely useful,
it's hugely proven and I think it would be

00:47:52.520 --> 00:47:58.810
wise to go ahead and start grabbing it and
using it yourself. So that's about what I

00:47:58.810 --> 00:48:08.310
had prepared for you. Just to recap, this
is what we think production ready means and

00:48:08.310 --> 00:48:13.080
I think the main way that you get there is
a large part by keeping your bits of the app

00:48:13.080 --> 00:48:18.500
isolated from one another. You achieve the
scalability across lots of users if you want

00:48:18.500 --> 00:48:22.170
to do monstrously big things on App Engine
by similarly isolating your entities from

00:48:22.170 --> 00:48:28.250
one another. The data storage side; this gets
you crawlability, this gets you being bookmarked

00:48:28.250 --> 00:48:33.050
friendly, it might get you hits from--with
a search engine of your choice. Your app needs

00:48:33.050 --> 00:48:36.610
to be monitored and needs to be instrumented
so that you can take care of your users and

00:48:36.610 --> 00:48:41.460
see what they're actually up to, get some
eyeballs in their. And finally, your app needs

00:48:41.460 --> 00:48:46.360
to be a little bit wary of just what your
users are getting up to. And, of course, with

00:48:46.360 --> 00:48:52.180
our new relationship with VMware and Roo which
I am tremendously excited about, you shouldn't

00:48:52.180 --> 00:48:57.520
have to be working so hard to do all of this
stuff. We think that we can let you get a

00:48:57.520 --> 00:49:03.320
good part of the way their by generating an
app that sets you off in good habits and good

00:49:03.320 --> 00:49:09.090
style. An app that we can maintain at least
a good portion of the plumbing for you as

00:49:09.090 --> 00:49:16.960
your app grows and like that, a third point
that I forgot that I wanted to make. So that's

00:49:16.960 --> 00:49:29.050
it. Thank you. So I'm going to try to figure
out how to do the moderator thing, but I screwed

00:49:29.050 --> 00:49:34.870
it up last time and that was with the program
that I understood. Give me one second to try

00:49:34.870 --> 00:49:39.220
to get this going and then we'll take questions
from the microphones. That doesn't work. Does

00:49:39.220 --> 00:50:00.480
that work? Copy hyperlink URL. Well, that's
the addressor. Cool--I'm still--I'm not miring,

00:50:00.480 --> 00:50:11.990
am I? Okay. And, well, that comes up. Hi.
&gt;&gt; Quick question about safeHtml, do you guys

00:50:11.990 --> 00:50:13.829
have any support for a kind of like allowing
basic HTML?

00:50:13.829 --> 00:50:18.330
&gt;&gt; RYAN: Say that again, please.
&gt;&gt; Do you know if SafeHTML has any support

00:50:18.330 --> 00:50:25.820
for allowing basic HTML, you know, like image
tags or the, you know, bolds and [INDISTINCT]

00:50:25.820 --> 00:50:27.950
from the user?
&gt;&gt; RYAN: It's more the idea that you will

00:50:27.950 --> 00:50:35.240
use SafeHTML builder to put together stuff
like that rather than--I'm pretty sure that

00:50:35.240 --> 00:50:40.990
the sanitizer is not so ambitious to try to
distinguish safe from unsafe tags that user

00:50:40.990 --> 00:50:42.180
may provide.
&gt;&gt; Got you.

00:50:42.180 --> 00:50:45.640
&gt;&gt; RYAN: I think it's more about making easy
for you to assemble that kind of stuff as

00:50:45.640 --> 00:50:46.640
you need to.
&gt;&gt; Got you.

00:50:46.640 --> 00:50:52.330
&gt;&gt; RYAN: It also has a many temp--compile
templating system built in to it that I...

00:50:52.330 --> 00:50:57.220
&gt;&gt; So the assumption is you've already sanitized
on the way in? The users input...

00:50:57.220 --> 00:51:08.630
&gt;&gt; RYAN: Right. I'm trying to think of the
correct answer to that. It's more the assumption,

00:51:08.630 --> 00:51:13.080
you know, I can't remember the exact answer
there, but it's pretty well documented unlike

00:51:13.080 --> 00:51:17.359
a lot of the stuff that I've discussed today.
&gt;&gt; Cool. I'm sorry with that. Thanks.

00:51:17.359 --> 00:51:19.150
&gt;&gt; OK. Hi.
&gt;&gt; Hello. So, if you generate that much, do

00:51:19.150 --> 00:51:24.150
you actually need to generate it so you can
use it at runtime like maybe basic HTML and

00:51:24.150 --> 00:51:31.090
then use that HTML at runtime, it don't generate
code at all?

00:51:31.090 --> 00:51:35.500
&gt;&gt; RYAN: We tend to find that the more--we
try very hard to do as much as compile time

00:51:35.500 --> 00:51:39.800
as we can. It's sort of one of the central
[INDISTINCT] behind, how we approach this

00:51:39.800 --> 00:51:46.000
stuff. The more we do stuff at runtime, the
more we find the app gets bigger and the app

00:51:46.000 --> 00:51:52.660
slows down. That's why there's no reflection
in GWT, that's why there's no introspection.

00:51:52.660 --> 00:51:57.031
And what we're generating a lot of code here,
this is--every line of code that we generate

00:51:57.031 --> 00:52:00.010
is something that the compiler can consider
whether you've actually executing it, how

00:52:00.010 --> 00:52:04.670
your actually executing it, can in-line things
can throw away unused portions and so on.

00:52:04.670 --> 00:52:08.890
The more flexible we live things at runtime,
the more we have to leave there just in case

00:52:08.890 --> 00:52:15.290
you call it in a way that we won't be able
to tell if you do or you don't. In fact, the

00:52:15.290 --> 00:52:19.790
code does shifts in the snapshot right now.
Probably, errors are a bit too far onto the

00:52:19.790 --> 00:52:26.530
runtime side. Something that I didn't go into
here is the request factory code is set up

00:52:26.530 --> 00:52:31.170
right now so that you can--when you ask for
a particular record, you can actually indicate.

00:52:31.170 --> 00:52:34.910
And here's a set of properties that I want
you to include with this record as you bring

00:52:34.910 --> 00:52:41.180
it back over. We--that right now, that information
will happens at runtime and we're thinking

00:52:41.180 --> 00:52:44.490
that was perhaps the wrong move and that we
should turn it to more something that gets

00:52:44.490 --> 00:52:49.290
declared more statically, more declaratively
so that we're not being forced to keep so

00:52:49.290 --> 00:52:54.010
much information around free at runtime. Did
that answer your question?

00:52:54.010 --> 00:52:57.180
&gt;&gt; Yeah, almost, yeah, but there's some that--called
bloat [INDISTINCT] you have a lot of codes

00:52:57.180 --> 00:53:06.370
that's almost the same. So, if you don't generate
it, there is a chance the application will

00:53:06.370 --> 00:53:12.240
be smaller, maybe faster?
&gt;&gt; RYAN: You'd think that, and we shouldn't

00:53:12.240 --> 00:53:19.270
be completely cavalier in what we generate,
but, typically, when--sorry, I'm trying to

00:53:19.270 --> 00:53:23.730
understand the--I hereby promised to answer
the online questions offline after this but

00:53:23.730 --> 00:53:32.140
I can't figure this thing out. Typically,
the code that you generate, the compiler will

00:53:32.140 --> 00:53:36.300
get rid of it if you don't actually use it,
and the odds are that what your generating

00:53:36.300 --> 00:53:39.700
is something that you intended to present
there in the first place. For example, right

00:53:39.700 --> 00:53:47.000
now, the stuff that we've shown off here is
not very configurable. It does, in fact, look

00:53:47.000 --> 00:53:50.930
at every entity of define server side and
improve generate UI for you for that and RPC

00:53:50.930 --> 00:53:55.130
for that. I hope that we can make that a little
bit more selective. So while it's easy to

00:53:55.130 --> 00:53:59.650
generate something that will export everything,
you can get--you can take a little bit more

00:53:59.650 --> 00:54:05.180
control of if and say, "Well, here's the 20%
of my entity set that I actually want to make

00:54:05.180 --> 00:54:10.760
visible to the client." Go ahead and do that.
So we will not be quite so stupid, but I still

00:54:10.760 --> 00:54:15.300
think compile time rather than runtime is
the time to be doing that. Hi.

00:54:15.300 --> 00:54:23.640
&gt;&gt; Hi. So if you think of a big GWT app like
AdWords or Wave, it seems like a Roo generated

00:54:23.640 --> 00:54:26.691
interfaces can obviously hold up very far
into the development of app like that, right?

00:54:26.691 --> 00:54:29.480
Because it looks like it's really for CRUD
style interface.

00:54:29.480 --> 00:54:33.520
&gt;&gt; RYAN: Absolutely.
&gt;&gt; So in that case, can Roo just maintain

00:54:33.520 --> 00:54:37.310
like those DTOs and those event objects for
us and let us do the UI or as it basically

00:54:37.310 --> 00:54:40.720
all Roo or no Roo?
&gt;&gt; RYAN: No. It is very much the intent that

00:54:40.720 --> 00:54:48.030
Roo--and how Roo is working right now is kind
of generating two layers of stuff for you.

00:54:48.030 --> 00:54:52.350
It's got a set of classes that it treats as
very much mirrors, reflections of what's going

00:54:52.350 --> 00:54:56.080
on into the side that will keep updating and
keep updating. But on the first run, it also

00:54:56.080 --> 00:55:01.250
generates a bunch of UIs scaffold that it--puts
there for you for the first time and that's

00:55:01.250 --> 00:55:04.500
not going to touch it again. And one of the
most interesting challenges with this, and

00:55:04.500 --> 00:55:09.810
something that we've had been to learn from
then on the guys at VMware is just how to

00:55:09.810 --> 00:55:13.830
architect these things, so not only is it
something that you can reuse, but architected

00:55:13.830 --> 00:55:17.320
so that something that the different bits
are isolated from each other. So that, for

00:55:17.320 --> 00:55:22.250
example, the entry point that is configuring
all of this stuff to put in front of yours,

00:55:22.250 --> 00:55:27.940
in the first place, is isolated from, say,
the list of all possible entity editing places

00:55:27.940 --> 00:55:32.700
that Roo is going to update and extend and
extend and extend so that I can mess with

00:55:32.700 --> 00:55:35.809
the overall application structure while Roo
can keep maintaining the plumbing for me.

00:55:35.809 --> 00:55:39.740
&gt;&gt; So if we're going to build something like
AdWords, you could use completely custom UIs,

00:55:39.740 --> 00:55:43.791
not even use any Roo's generated UIs at all
but still get the automatic generation for

00:55:43.791 --> 00:55:46.010
the DTOs...
&gt;&gt; RYAN: That is very much the intention.

00:55:46.010 --> 00:55:52.030
The place where it's weakest in the snapshot
implementation right now is Roo is generating

00:55:52.030 --> 00:55:57.650
for you the list of possible locations within
the app to place objects, and we've screwed

00:55:57.650 --> 00:56:01.830
up making that something that you can extend
without actually having Roo collaborate everything

00:56:01.830 --> 00:56:04.850
you do or taking Roo totally out of the picture
there. So, we're still kind of working on

00:56:04.850 --> 00:56:07.329
that, and I think it will all settle in as
we get to real history implementation.

00:56:07.329 --> 00:56:09.559
&gt;&gt; So, you would intended...
&gt;&gt; RYAN: That's the goal.

00:56:09.559 --> 00:56:12.680
&gt;&gt; So, you'd intend that if someone's that
not using Roo, they would still use the activity

00:56:12.680 --> 00:56:15.130
paradigm that you shared with us...
&gt;&gt; RYAN: Oh, absolutely, absolutely there's

00:56:15.130 --> 00:56:17.411
nothing at all Roo specific about the activity
manager...

00:56:17.411 --> 00:56:22.830
&gt;&gt; Or request factory in that...
&gt;&gt; RYAN: Request factory, all of this should

00:56:22.830 --> 00:56:28.940
be usable without Roo. It's a bit laborious
to configure as things are at the moment.

00:56:28.940 --> 00:56:32.260
I think we can make it more concise, so that
while it's convenient to get it generated

00:56:32.260 --> 00:56:36.810
with Roo you should still be able to work
with it by hand, but we're getting there.

00:56:36.810 --> 00:56:41.250
Once you get above that level of the request
factory into the editor support and all this

00:56:41.250 --> 00:56:45.620
kind of the thing, we want very much for this
all to be usable whether or not you're working

00:56:45.620 --> 00:56:50.740
with Roo. Just like the new data widgets that
we've been discussing, some widgets that we've

00:56:50.740 --> 00:56:55.120
been discussing in other forms can work very
nicely with this role but don't require it.

00:56:55.120 --> 00:56:59.010
We want the other layers to work nicely together
but not require. We don't want to dictate

00:56:59.010 --> 00:57:03.569
to you absolutely every layer of how you work
with your app.

00:57:03.569 --> 00:57:05.200
&gt;&gt; Thanks.
&gt;&gt; RYAN: Uh-hmm. Hi.

00:57:05.200 --> 00:57:10.290
&gt;&gt; I can't wait for 2.1, since 2.0, we've
been--we started using code splitting and

00:57:10.290 --> 00:57:14.460
an application has grown pretty big. Another
thing, you know, if we can actually hosting

00:57:14.460 --> 00:57:20.750
our application like at least the static part
on CDN type system where the static files

00:57:20.750 --> 00:57:24.710
can be loaded from a different server.
&gt;&gt; RYAN: I'm having trouble understanding

00:57:24.710 --> 00:57:26.690
you. You've been using code splitting since
2.0?

00:57:26.690 --> 00:57:33.640
&gt;&gt; Since 2.0 and our application has grown
pretty large and we're hoping to actually

00:57:33.640 --> 00:57:42.680
host the static files on a CDN, something
like static.domain.com, and do you have any

00:57:42.680 --> 00:57:45.990
thoughts or best practices around...?
&gt;&gt; Rick Cromwell would like to take the microphone

00:57:45.990 --> 00:57:48.240
and answer that for you, which is good because
he's better than me.

00:57:48.240 --> 00:57:51.220
&gt;&gt; CROMWELL: We kind of had run into this
problem at Google. I think AdWords was doing

00:57:51.220 --> 00:57:56.390
the same thing. They wanted to host the static--resources
along different server. So Lex Spoon who is

00:57:56.390 --> 00:58:02.490
the architect of code splitting, just recently
came up with the thing called the cross-sight

00:58:02.490 --> 00:58:05.960
fragment loader--linker or something like
that. I can't remember the actual name. But

00:58:05.960 --> 00:58:10.100
it's specifically designed for this used case
so that you can put your static resources

00:58:10.100 --> 00:58:15.790
on a CDN, but keep the code split compiled
our facts on a different server. So, that

00:58:15.790 --> 00:58:19.530
definitely will be supported, I don't know
if it's in 2.1 or if it's in Trunk or...

00:58:19.530 --> 00:58:23.750
&gt;&gt; RYAN: I think, don't quote me on this,
but I believe that everything that's in Trunk

00:58:23.750 --> 00:58:27.641
right now is destined for 2.1. It's not all
in the snapshot, but I don't believe that

00:58:27.641 --> 00:58:32.580
we've yet set the boundary for what's going
in and what's going out. There's also been

00:58:32.580 --> 00:58:35.950
talk--this is not something that's being under
active development right now, but Bob Votaw

00:58:35.950 --> 00:58:40.680
keeps looking for an excuse to implement it.
We have our client bundle now. We're just

00:58:40.680 --> 00:58:45.840
able to compile in all of your resources and
so on. And what he'd like us to get to is

00:58:45.840 --> 00:58:49.950
something that--just take that to--a step
further and build what he calls the server

00:58:49.950 --> 00:58:55.500
bundle, where you're able to indicate a bunch
of resources that still are strongly typed

00:58:55.500 --> 00:58:59.420
and your code has API access to but which
we don't actually fetch until you want to

00:58:59.420 --> 00:59:02.850
use them. It's a little orthogonal to what
you're asking but the same kind of idea.

00:59:02.850 --> 00:59:05.740
&gt;&gt; All right, thank you.
&gt;&gt; Yup. I think this is the last question.

00:59:05.740 --> 00:59:12.240
&gt;&gt; All right. So activity managers; I'd looked
at some Roo generated code yesterday, that

00:59:12.240 --> 00:59:15.520
wasn't cleared to me whether an activity manager
lives at a global level where one listens

00:59:15.520 --> 00:59:21.470
for all activities or they're kind of localized?
&gt;&gt; RYAN: Typically, one has a global activity

00:59:21.470 --> 00:59:24.570
manager, but it's not a requirement. And then
the scaffolding app that we're actually generating

00:59:24.570 --> 00:59:30.120
right now, we actually have two of them. So
all of activity manager is somebody who's

00:59:30.120 --> 00:59:38.110
able to listen for place change events, history
events, figure out what's the appropriate

00:59:38.110 --> 00:59:41.420
presenter and view to put in front of the
user and put them there. And there's no reason

00:59:41.420 --> 00:59:46.160
that you can't have several of those working
at once. What we actually still need to do

00:59:46.160 --> 00:59:50.190
is figure out how to actually tile all of
this into the history mechanism and let them

00:59:50.190 --> 00:59:54.030
persist there, their state that way without
snapping on each other, without requiring

00:59:54.030 --> 00:59:58.570
each other. Stay tuned. And my clock is up,
so I think I have to get off of stage now.

00:59:58.570 --> 00:59:59.940
Thank you all.

