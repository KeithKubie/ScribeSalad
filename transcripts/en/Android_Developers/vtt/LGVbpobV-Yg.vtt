WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.402
[MUSIC PLAYING]

00:00:07.161 --> 00:00:08.410
DAVID HERMAN: Hello, everyone.

00:00:08.410 --> 00:00:11.970
Welcome to the deep dive
into Android Studio Profilers

00:00:11.970 --> 00:00:13.020
session.

00:00:13.020 --> 00:00:14.159
I'm David Herman.

00:00:14.159 --> 00:00:15.450
SHUKANG ZHOU: I'm Shukang Zhou.

00:00:15.450 --> 00:00:17.220
We are engineers
from the Profiler

00:00:17.220 --> 00:00:19.204
team in Android Studio.

00:00:19.204 --> 00:00:21.120
DAVID HERMAN: So before
we really got into it,

00:00:21.120 --> 00:00:22.620
we wanted to give
you all an outline

00:00:22.620 --> 00:00:24.690
of what to expect in this talk.

00:00:24.690 --> 00:00:27.420
Instead of sort of coming
from a high overview,

00:00:27.420 --> 00:00:29.580
instead we're going
to more narrowly focus

00:00:29.580 --> 00:00:32.430
on a few features that we
think can help you get a better

00:00:32.430 --> 00:00:34.530
handle on any codebase.

00:00:34.530 --> 00:00:38.250
We're also going to drop some
tips and tricks along the way.

00:00:38.250 --> 00:00:42.670
We're going to be profiling
a real app, Santa Tracker.

00:00:42.670 --> 00:00:45.800
Santa Tracker is
an app by Google

00:00:45.800 --> 00:00:49.690
which allows users to
track Santa on his course

00:00:49.690 --> 00:00:52.240
around the world
on Christmas Eve.

00:00:52.240 --> 00:00:55.570
The app also contains games,
and a couple of other extras.

00:00:58.802 --> 00:01:01.070
They release a new
app every year.

00:01:01.070 --> 00:01:02.720
We're going to be
using the one that is

00:01:02.720 --> 00:01:05.330
publicly available on GitHub.

00:01:05.330 --> 00:01:08.630
Finally, I want to mention
two talks about profilers

00:01:08.630 --> 00:01:11.420
that were previously given
this year, one at Google I/O,

00:01:11.420 --> 00:01:14.510
which did talk profilers
at a higher level,

00:01:14.510 --> 00:01:16.700
also introducing what
was new in Android Studio

00:01:16.700 --> 00:01:18.470
3.2 for profilers.

00:01:18.470 --> 00:01:21.110
And another one at
the Android Game Dev

00:01:21.110 --> 00:01:23.640
Summit, about
profiling your games.

00:01:23.640 --> 00:01:25.550
That talk focuses
a little bit more

00:01:25.550 --> 00:01:29.010
on performance, native
code, related tools,

00:01:29.010 --> 00:01:29.930
things like that.

00:01:32.840 --> 00:01:35.759
You can find those
videos on YouTube.

00:01:35.759 --> 00:01:37.300
If you're watching
this online, we've

00:01:37.300 --> 00:01:40.300
also included links to those
videos in the video description

00:01:40.300 --> 00:01:41.676
below.

00:01:41.676 --> 00:01:45.630
If this is your first time
learning about profilers--

00:01:45.630 --> 00:01:46.590
you're just curious--

00:01:46.590 --> 00:01:48.705
here's a very quick overview.

00:01:48.705 --> 00:01:52.560
The Studio Profilers
feature is divided

00:01:52.560 --> 00:01:56.880
into four main profilers,
one for CPU, one for memory,

00:01:56.880 --> 00:01:59.790
one for network,
and one for battery.

00:01:59.790 --> 00:02:03.177
There's also an
Event Profiler that's

00:02:03.177 --> 00:02:05.010
always on the top, which
lets you see things

00:02:05.010 --> 00:02:09.870
like user events such as
taps, keyboard events, screen

00:02:09.870 --> 00:02:12.030
rotations, and
lifecycle events--

00:02:12.030 --> 00:02:15.270
so when you're fragments and
activities start and stop.

00:02:15.270 --> 00:02:17.760
Anyway, that's enough talking.

00:02:17.760 --> 00:02:19.872
Let's jump into the demo.

00:02:19.872 --> 00:02:22.960
SHUKANG ZHOU: OK,
let's start the demo.

00:02:22.960 --> 00:02:28.260
So first, with one click on this
button, I can launch the app

00:02:28.260 --> 00:02:30.705
and start profilers.

00:02:30.705 --> 00:02:33.690
So today, we are
using Android Studio

00:02:33.690 --> 00:02:39.960
3.4 Canary 3, because that's
the latest of what we have.

00:02:39.960 --> 00:02:44.280
Since this is a Canary release,
it's not a stable release yet.

00:02:44.280 --> 00:02:46.300
So there might be some bugs.

00:02:46.300 --> 00:02:51.780
Please bear with us if anything
interesting happens today.

00:02:51.780 --> 00:02:54.270
The app we are using
today, the Santa Tracker,

00:02:54.270 --> 00:02:58.110
contains only Java code.

00:02:58.110 --> 00:03:03.050
So the Java apps will be
the focus of today's talk.

00:03:03.050 --> 00:03:06.790
So as you can see
in the profiler,

00:03:06.790 --> 00:03:10.600
we have four profilers, CPU,
Memory, Network, and Energy.

00:03:10.600 --> 00:03:15.460
You can click on any of them
to get more detailed data

00:03:15.460 --> 00:03:17.080
from that profiler.

00:03:17.080 --> 00:03:20.020
Let's jump to the CPU profiler.

00:03:20.020 --> 00:03:24.560
So here, as you can
see in the CPU profile,

00:03:24.560 --> 00:03:29.230
you can see the CPU utilization
and the thread state.

00:03:29.230 --> 00:03:32.270
It will be useful
to tell you when

00:03:32.270 --> 00:03:35.330
your app becomes CPU-bounded.

00:03:35.330 --> 00:03:40.850
And if you are examining two
related threads, one trick is--

00:03:40.850 --> 00:03:41.420
here--

00:03:41.420 --> 00:03:44.510
you can reorder the
threads any way you want.

00:03:47.681 --> 00:03:53.870
To know further data information
about which part of your code

00:03:53.870 --> 00:03:56.690
is executing, or how
they are executing,

00:03:56.690 --> 00:03:59.810
you need CPU recordings.

00:03:59.810 --> 00:04:02.990
And let me get a
little bit more space.

00:04:02.990 --> 00:04:05.720
So as you can see
here, there are

00:04:05.720 --> 00:04:08.430
four types of CPU recordings.

00:04:08.430 --> 00:04:10.600
So let's go to the first one.

00:04:10.600 --> 00:04:12.560
It's the sample Java method.

00:04:12.560 --> 00:04:17.130
Let's get a quick
recording on this one.

00:04:17.130 --> 00:04:20.990
So during this type
of CPU recording,

00:04:20.990 --> 00:04:25.110
the Java Virtual
Machine periodically

00:04:25.110 --> 00:04:29.640
will collect the call stacks
of all the other Java threads

00:04:29.640 --> 00:04:31.260
in your process.

00:04:31.260 --> 00:04:36.150
And then it will
present the stacks

00:04:36.150 --> 00:04:41.710
in this part, which is the
details of the recording.

00:04:41.710 --> 00:04:45.130
And after the recording is
done, the entire recording

00:04:45.130 --> 00:04:47.310
is automatically selected.

00:04:47.310 --> 00:04:50.780
And if you want to
take a closer look,

00:04:50.780 --> 00:04:55.495
there is a button called
Zoom to Selection.

00:04:55.495 --> 00:04:59.624
So if I click it, it will
fill the entire screen.

00:04:59.624 --> 00:05:03.550
And if you want to just see
a subrange of the recording,

00:05:03.550 --> 00:05:05.920
you can select using your mouse.

00:05:05.920 --> 00:05:09.190
If you want to select the
entire recording again,

00:05:09.190 --> 00:05:13.120
you can click this
small clock icon here.

00:05:13.120 --> 00:05:18.250
And sometimes you only want
to see a very specific point.

00:05:18.250 --> 00:05:21.670
In that case, you can to a
single click in this area,

00:05:21.670 --> 00:05:25.854
and you automatically
select something here.

00:05:25.854 --> 00:05:30.030
Now let's take a look
at the call stacks here.

00:05:30.030 --> 00:05:34.460
And let's select this range.

00:05:34.460 --> 00:05:36.340
That might be more interesting.

00:05:36.340 --> 00:05:41.480
So as you can see,
the profiler will

00:05:41.480 --> 00:05:46.460
color the cost from the Android
platform in orange, the method

00:05:46.460 --> 00:05:49.670
from the Java language
in blue, and it will also

00:05:49.670 --> 00:05:53.420
color any of your code and
the library code to green.

00:05:53.420 --> 00:05:58.070
So if you want to know
what method from your code

00:05:58.070 --> 00:06:01.440
is running, you will be
looking for the green stuff.

00:06:01.440 --> 00:06:03.860
So here we see some
green stuff here.

00:06:03.860 --> 00:06:07.880
And here, if you can see,
this is onDraw method

00:06:07.880 --> 00:06:10.220
from the Village View class.

00:06:10.220 --> 00:06:16.250
And if you see the codebase,
as you can easily see,

00:06:16.250 --> 00:06:19.520
the visit [INAUDIBLE] is
responsible to draw the clouds

00:06:19.520 --> 00:06:22.610
that is on this screen.

00:06:22.610 --> 00:06:28.970
So another thing I want
to talk about the sampling

00:06:28.970 --> 00:06:32.990
is you can do some customization
about this recording type.

00:06:32.990 --> 00:06:37.250
So you click this Edit
Configuration entry,

00:06:37.250 --> 00:06:39.350
and you can click
this plus sign.

00:06:39.350 --> 00:06:42.980
You are able to create
customized CPU configuration.

00:06:42.980 --> 00:06:46.190
For this sample Java
method recording type,

00:06:46.190 --> 00:06:48.860
you can change the
sampling intervals.

00:06:48.860 --> 00:06:53.150
So as most sampling
techniques go,

00:06:53.150 --> 00:06:56.810
the more frequently you
collect samples the more likely

00:06:56.810 --> 00:06:58.730
the data will be representative.

00:06:58.730 --> 00:07:01.440
However, that will
incur more overhead.

00:07:01.440 --> 00:07:04.590
So sometimes, depending
on your use case,

00:07:04.590 --> 00:07:07.100
you may want to
have several tries

00:07:07.100 --> 00:07:09.700
before you find the sweet spot.

00:07:09.700 --> 00:07:14.110
So as we have seen,
the sample Java method

00:07:14.110 --> 00:07:18.610
is very useful to get a
high-level picture of which

00:07:18.610 --> 00:07:21.826
part of the code it is running.

00:07:21.826 --> 00:07:23.930
In some other
scenarios, if you want

00:07:23.930 --> 00:07:28.340
to focus on a smaller
area, the second type

00:07:28.340 --> 00:07:31.400
of the recording,
trace Java method,

00:07:31.400 --> 00:07:33.150
will be more interesting.

00:07:33.150 --> 00:07:39.330
So let me collect another case.

00:07:39.330 --> 00:07:42.290
So in this type
of CPU recording,

00:07:42.290 --> 00:07:47.000
the Java Virtual Machine is
collecting the data every time

00:07:47.000 --> 00:07:51.500
when the execution enters
a method or exits a method.

00:07:51.500 --> 00:07:56.030
So therefore, there is a lot
more data being collected.

00:07:59.010 --> 00:08:03.740
So for example, if you really
want to try and understand

00:08:03.740 --> 00:08:08.840
exactly what methods
from my code are running,

00:08:08.840 --> 00:08:11.750
I will look for the
green stuff here.

00:08:11.750 --> 00:08:15.090
And you can see there
are a lot of things.

00:08:15.090 --> 00:08:17.420
And you may want to zoom in.

00:08:17.420 --> 00:08:21.020
So you can use the
W-A-S-D keys to zoom in.

00:08:21.020 --> 00:08:23.960
So the W will be the zoom in.

00:08:23.960 --> 00:08:26.110
As you can see, the
key I'm pressing.

00:08:26.110 --> 00:08:28.190
The S will be zoom out.

00:08:28.190 --> 00:08:30.490
The D will be
moving to the right.

00:08:30.490 --> 00:08:33.281
A will be moving to the left.

00:08:33.281 --> 00:08:37.460
So if you're a gamer, you
probably already know this.

00:08:37.460 --> 00:08:39.169
If you zoom in,
let's keep zooming in

00:08:39.169 --> 00:08:42.080
to see what are
these green stuff.

00:08:45.209 --> 00:08:48.000
So here we seen
in this, a big one

00:08:48.000 --> 00:08:50.280
is the one we just saw before.

00:08:50.280 --> 00:08:52.900
It's the onDraw method
from the Village View.

00:08:52.900 --> 00:08:55.920
They are responsible
for drawing the clouds.

00:08:55.920 --> 00:09:01.020
Here, this is the onDraw method
from the Snowflake View class.

00:09:01.020 --> 00:09:03.840
They are responsible to draw
all these snowflakes that

00:09:03.840 --> 00:09:05.400
are floating around.

00:09:05.400 --> 00:09:12.450
And if you look closely, there
are many very tiny green lines

00:09:12.450 --> 00:09:13.090
here.

00:09:13.090 --> 00:09:15.220
So you can further zoom in.

00:09:15.220 --> 00:09:16.690
You can further zoom in.

00:09:19.840 --> 00:09:22.830
So you can see this
is the onDraw method

00:09:22.830 --> 00:09:24.910
from the Snowflake class.

00:09:24.910 --> 00:09:27.200
This is also from
the snowflake class.

00:09:27.200 --> 00:09:30.360
This is also from
Snowflake class.

00:09:30.360 --> 00:09:36.840
So you may want to see what
exactly does this class go.

00:09:36.840 --> 00:09:40.320
So you Right-Click here,
and you can have a menu

00:09:40.320 --> 00:09:43.080
to jump to the source code.

00:09:43.080 --> 00:09:47.840
So you can see here, in
this Snowflake class,

00:09:47.840 --> 00:09:50.350
in this onDraw
method, we are doing

00:09:50.350 --> 00:09:54.820
some calculation about the
velocity, about an angle,

00:09:54.820 --> 00:09:55.960
about the size.

00:09:55.960 --> 00:09:57.180
Then we draw a circle.

00:09:57.180 --> 00:10:01.690
Then it's clear that every
snowflake on this screen

00:10:01.690 --> 00:10:04.040
will execute this method.

00:10:04.040 --> 00:10:11.120
That's why we are seeing so
many calls into this method.

00:10:11.120 --> 00:10:15.940
So as you can see,
trace Java method

00:10:15.940 --> 00:10:19.750
is very useful to
verify whether or not

00:10:19.750 --> 00:10:21.760
a method has been executed.

00:10:21.760 --> 00:10:26.702
It's also useful to verify how
often that method is executed.

00:10:29.870 --> 00:10:31.940
Another thing I want
to talk about here

00:10:31.940 --> 00:10:36.330
is about the four caps here.

00:10:36.330 --> 00:10:38.900
So the first one
is the call chart.

00:10:38.900 --> 00:10:41.420
So the call chart,
as we said, is

00:10:41.420 --> 00:10:46.500
representing all the call
stacks during the CPU recording.

00:10:46.500 --> 00:10:50.070
So the things to the left--

00:10:50.070 --> 00:10:52.265
well, let's select
the entire range.

00:10:52.265 --> 00:10:52.890
You can see it.

00:10:52.890 --> 00:10:55.650
So the call stacks
show up the left,

00:10:55.650 --> 00:10:58.310
where it happens first
in this recording.

00:10:58.310 --> 00:11:02.771
So the things to the right will
happen later in this recording.

00:11:02.771 --> 00:11:05.770
In the frame chart,
it7s similar to the call

00:11:05.770 --> 00:11:07.650
stacks, but it's upside down.

00:11:07.650 --> 00:11:09.680
So the root is at the bottom.

00:11:09.680 --> 00:11:14.760
And also, identified call
stacks are aggregated here.

00:11:14.760 --> 00:11:19.220
So it's very easy to see
the total time of method

00:11:19.220 --> 00:11:21.370
has been executed.

00:11:21.370 --> 00:11:26.950
The top-down is [INAUDIBLE]
has exactly the same data

00:11:26.950 --> 00:11:28.030
as the frame chart.

00:11:28.030 --> 00:11:31.840
It7s just represented
in a different view.

00:11:31.840 --> 00:11:33.820
So what's nice
about this view is

00:11:33.820 --> 00:11:37.220
you can sort of these
methods by the time.

00:11:37.220 --> 00:11:39.580
So the save time is
the time executing

00:11:39.580 --> 00:11:41.560
by this method itself.

00:11:41.560 --> 00:11:44.860
The children is the time
executed by the subroutines

00:11:44.860 --> 00:11:46.780
called by this method.

00:11:46.780 --> 00:11:51.610
And the total column is
the combination of the two.

00:11:51.610 --> 00:11:58.380
Bottom-up is looking at the call
stack upwards to the caller,

00:11:58.380 --> 00:12:03.480
basically from the method
to another function that

00:12:03.480 --> 00:12:04.740
called it.

00:12:04.740 --> 00:12:07.260
So here, it's very useful.

00:12:07.260 --> 00:12:10.140
If you expand it,
it's very useful

00:12:10.140 --> 00:12:15.180
to see where this
method is called,

00:12:15.180 --> 00:12:19.380
and how much time this method
has executed when it is

00:12:19.380 --> 00:12:21.270
called by that specific caller.

00:12:24.174 --> 00:12:27.120
And there is a third
type of CPU recording

00:12:27.120 --> 00:12:31.310
that is sample
native functions--

00:12:31.310 --> 00:12:33.840
C or C++ functions.

00:12:33.840 --> 00:12:38.020
And let's do also
another short trace here.

00:12:38.020 --> 00:12:42.590
And if you remember, I just
said this app, Santa Tracker,

00:12:42.590 --> 00:12:45.150
it contains Java-only code.

00:12:45.150 --> 00:12:49.260
So therefore, the call stacks,
assuming the call stacks

00:12:49.260 --> 00:12:52.100
collected by this
type of recording

00:12:52.100 --> 00:12:54.200
is not very interesting.

00:12:54.200 --> 00:12:57.110
They are mostly
the system calls.

00:12:57.110 --> 00:13:01.070
Some of them use the Android
framework native code.

00:13:01.070 --> 00:13:06.120
So however, if your app
has any native components,

00:13:06.120 --> 00:13:09.730
this type of recording
will be very handy.

00:13:09.730 --> 00:13:13.065
There is another type of CPU
recording called trace system

00:13:13.065 --> 00:13:14.010
to our calls.

00:13:14.010 --> 00:13:16.680
But before I go into
the details of that,

00:13:16.680 --> 00:13:18.840
I will hand the
demo back to Dave.

00:13:21.920 --> 00:13:22.970
DAVID HERMAN: Excellent.

00:13:22.970 --> 00:13:26.070
So CPU recordings
are very useful.

00:13:26.070 --> 00:13:28.670
However, sometimes there's an
exact function, or maybe just

00:13:28.670 --> 00:13:32.340
a couple of functions that
you know you want to analyze.

00:13:32.340 --> 00:13:35.460
And it's a little bit imprecise
to record, do something

00:13:35.460 --> 00:13:38.000
in your app, stop recording,
and then zooming in

00:13:38.000 --> 00:13:38.960
and search for it.

00:13:38.960 --> 00:13:43.046
Fortunately, we provide a
very simple solution for this.

00:13:43.046 --> 00:13:46.120
And I already added the code in.

00:13:46.120 --> 00:13:47.200
So let's talk about it.

00:13:47.200 --> 00:13:50.910
So the debug class is actually
part of the Android API.

00:13:50.910 --> 00:13:52.980
And the debug class
and many of its methods

00:13:52.980 --> 00:13:55.170
have, in fact, been
in the Android API

00:13:55.170 --> 00:13:58.020
since the very first
version, including these two.

00:13:58.020 --> 00:14:00.420
What the start method
tracing function does

00:14:00.420 --> 00:14:03.120
is it asks the system
to take a trace,

00:14:03.120 --> 00:14:05.760
save it with the filename you
provide, and then it puts it

00:14:05.760 --> 00:14:08.430
in a folder somewhere that you
can pull off your device later

00:14:08.430 --> 00:14:09.720
and inspect.

00:14:09.720 --> 00:14:12.450
That's really nice, but
on Studio profilers,

00:14:12.450 --> 00:14:13.510
we've got your back.

00:14:13.510 --> 00:14:15.910
We'll do all of
that work for you.

00:14:15.910 --> 00:14:18.009
So if you were
doing this manually,

00:14:18.009 --> 00:14:20.550
you'd probably be very careful
about the name that you chose.

00:14:20.550 --> 00:14:22.287
And if you're doing
multiple traces,

00:14:22.287 --> 00:14:24.120
you'd maybe choose
unique names so that they

00:14:24.120 --> 00:14:25.500
didn't overwrite each other.

00:14:25.500 --> 00:14:27.981
In our case, the name is not
going to show up in Studio.

00:14:27.981 --> 00:14:29.230
We don't really care about it.

00:14:29.230 --> 00:14:31.340
So call it whatever you want.

00:14:31.340 --> 00:14:34.680
Here, I'm going to start
doing it putting a recording

00:14:34.680 --> 00:14:36.040
around this function.

00:14:36.040 --> 00:14:38.040
So what I'm curious
about in this case,

00:14:38.040 --> 00:14:40.860
there's an activity in Santa
Tracker called the City Quiz.

00:14:40.860 --> 00:14:43.332
And the City Quiz loads
files from the disk.

00:14:43.332 --> 00:14:44.790
That's usually a
really good thing,

00:14:44.790 --> 00:14:46.380
where you want to know how
long it's going to take,

00:14:46.380 --> 00:14:47.963
and if it's doing
anything suspicious.

00:14:47.963 --> 00:14:48.870
Maybe it's not.

00:14:48.870 --> 00:14:50.790
We're going to take a look.

00:14:50.790 --> 00:14:52.860
But one thing I
do want to mention

00:14:52.860 --> 00:14:55.830
is when you call this start
method tracing function,

00:14:55.830 --> 00:14:57.670
it's doing a trace of your code.

00:14:57.670 --> 00:15:01.772
This is the more expensive,
precise, detailed one.

00:15:01.772 --> 00:15:02.730
So I'd be very careful.

00:15:02.730 --> 00:15:04.950
I wouldn't do this around
a large amount of code,

00:15:04.950 --> 00:15:06.533
just to make sure
that it doesn't take

00:15:06.533 --> 00:15:08.420
longer than you might expect.

00:15:08.420 --> 00:15:12.270
All right, let's actually
go into the City Quiz,

00:15:12.270 --> 00:15:14.122
which is down here.

00:15:14.122 --> 00:15:14.830
See what happens.

00:15:14.830 --> 00:15:17.329
Now, before I do this, I want
you to keep your eye over here

00:15:17.329 --> 00:15:18.852
in the Session panel.

00:15:18.852 --> 00:15:20.812
And you hit Play.

00:15:20.812 --> 00:15:21.687
It7s going to run in.

00:15:21.687 --> 00:15:23.145
And it's automatic
going to record.

00:15:23.145 --> 00:15:24.470
I didn't have to do anything.

00:15:24.470 --> 00:15:26.450
That's awesome.

00:15:26.450 --> 00:15:28.725
Let me back out.

00:15:28.725 --> 00:15:31.180
So as you can see here,
there's nothing new.

00:15:31.180 --> 00:15:34.660
This is exactly what Shukang
was just showing you before.

00:15:34.660 --> 00:15:36.400
It's just another trace.

00:15:36.400 --> 00:15:39.170
But you didn't have
to record it yourself.

00:15:39.170 --> 00:15:41.460
I think this is a good
moment to call out

00:15:41.460 --> 00:15:43.210
the lifecycle events
I talked a little bit

00:15:43.210 --> 00:15:45.230
about at the
beginning of the talk.

00:15:45.230 --> 00:15:47.350
As you can see, we're
doing a load here.

00:15:47.350 --> 00:15:49.150
We left our previous activity.

00:15:49.150 --> 00:15:51.350
And now we're into
this new activity.

00:15:51.350 --> 00:15:54.580
You can also see that if you put
your mouse over an activity, as

00:15:54.580 --> 00:15:58.630
of Android Studio 3.3, it will
also include the fragments that

00:15:58.630 --> 00:16:00.100
are active during that time.

00:16:00.100 --> 00:16:01.540
So that may be useful for you.

00:16:01.540 --> 00:16:02.300
But here we are.

00:16:02.300 --> 00:16:04.240
We're in this space
while we're still

00:16:04.240 --> 00:16:08.980
loading, before we've
actually entered the activity.

00:16:08.980 --> 00:16:10.860
And there's another
really great feature

00:16:10.860 --> 00:16:13.590
that I want to show you here,
which is this Filter button.

00:16:13.590 --> 00:16:16.280
When I press the Filter button,
it brings up a search box

00:16:16.280 --> 00:16:17.520
where I can type into it.

00:16:17.520 --> 00:16:19.950
Now I happen to
know that JSON has

00:16:19.950 --> 00:16:22.580
a function called readLiteral.

00:16:22.580 --> 00:16:24.120
So let me just type that in.

00:16:24.120 --> 00:16:25.590
Now one thing you
might notice here

00:16:25.590 --> 00:16:28.980
is this part of my
call chart dimmed out.

00:16:28.980 --> 00:16:31.109
And all parts here are not dim.

00:16:31.109 --> 00:16:32.400
They're still the normal color.

00:16:32.400 --> 00:16:34.260
So let me zoom in and see
if I can find where that is.

00:16:34.260 --> 00:16:35.100
So there we go.

00:16:35.100 --> 00:16:38.400
So we could see some instances
of this readLiteral function.

00:16:38.400 --> 00:16:42.390
Basically if my function is
an exact match, it will bold.

00:16:42.390 --> 00:16:45.240
If it's a function that calls
either into that function

00:16:45.240 --> 00:16:47.490
or is called out of that
function indirectly,

00:16:47.490 --> 00:16:49.500
the color will be left the same.

00:16:49.500 --> 00:16:51.410
And otherwise, it will dim.

00:16:51.410 --> 00:16:53.426
And it's really
useful to sort of get

00:16:53.426 --> 00:16:55.050
a good overview of
how much time you're

00:16:55.050 --> 00:16:56.550
spending in your
code on the function

00:16:56.550 --> 00:16:58.008
that you care about
versus what you

00:16:58.008 --> 00:16:59.580
don't have to pay attention to.

00:16:59.580 --> 00:17:02.670
All of the CPU detail
views support this.

00:17:02.670 --> 00:17:04.980
So the flame chart has
this similar dimming.

00:17:04.980 --> 00:17:07.980
Top-down and bottom-up will
strip out those functions

00:17:07.980 --> 00:17:08.730
that were dimmed.

00:17:08.730 --> 00:17:12.235
So if you're ever trying to
inspect some sort of method,

00:17:12.235 --> 00:17:13.859
and you're really
narrowing down on it,

00:17:13.859 --> 00:17:15.990
please give the
filter option a try,

00:17:15.990 --> 00:17:19.677
and see if you can sort of
focus on what you're looking at.

00:17:19.677 --> 00:17:21.510
Now the last thing to
call attention to here

00:17:21.510 --> 00:17:23.176
is, all of these
traces that we've done,

00:17:23.176 --> 00:17:26.200
if you mouse over them,
there is a Save button here.

00:17:26.200 --> 00:17:28.560
So you can actually
export your traces.

00:17:28.560 --> 00:17:30.920
If you do this, you can
give it to a co-worker,

00:17:30.920 --> 00:17:32.190
attach it to a bug--

00:17:32.190 --> 00:17:33.600
useful things like that.

00:17:33.600 --> 00:17:36.330
If somebody gives you a trace
file or you are loading one,

00:17:36.330 --> 00:17:38.820
you can just hit the plus
button over here, and load it

00:17:38.820 --> 00:17:40.290
from file.

00:17:40.290 --> 00:17:42.043
All right.

00:17:42.043 --> 00:17:45.480
OK, cool.

00:17:45.480 --> 00:17:47.070
SHUKANG ZHOU: Now
I'm going to talk

00:17:47.070 --> 00:17:49.830
about the last type
of CPU recording,

00:17:49.830 --> 00:17:52.102
the trace system calls.

00:17:52.102 --> 00:17:55.040
Trace system calls,
on this feature,

00:17:55.040 --> 00:17:59.240
was introduced in Android 3.2.

00:17:59.240 --> 00:18:03.530
It collects fine-grained
system events

00:18:03.530 --> 00:18:05.990
that's related to an
app7s performance.

00:18:05.990 --> 00:18:10.340
So you can investigate how your
app interacts with the system

00:18:10.340 --> 00:18:16.610
resource so that's
a system trace.

00:18:21.846 --> 00:18:26.490
So one thing-- again, I'm
using the Click to Zoom button

00:18:26.490 --> 00:18:30.330
here so that it's
very easy to see.

00:18:30.330 --> 00:18:32.140
One thing I want
to show you here--

00:18:32.140 --> 00:18:33.556
the first thing I
want to show you

00:18:33.556 --> 00:18:36.530
is in this thread state view.

00:18:36.530 --> 00:18:42.250
So if you click the range,
zoom to that selection again,

00:18:42.250 --> 00:18:45.419
and I will click here.

00:18:45.419 --> 00:18:47.191
[INAUDIBLE]

00:18:47.191 --> 00:18:51.220
So here, as you can see, you
can use your mouse, hover over,

00:18:51.220 --> 00:18:54.940
you can see this thread state
is runnable, become running,

00:18:54.940 --> 00:18:58.370
then become runnable,
become running again.

00:18:58.370 --> 00:19:03.700
So as you can see, we are
collecting every CPU scheduling

00:19:03.700 --> 00:19:04.810
operation.

00:19:04.810 --> 00:19:09.700
So at this level of details,
it's very easy for you

00:19:09.700 --> 00:19:13.930
to figure out exactly when
your thread becomes blocked.

00:19:13.930 --> 00:19:18.920
And that could be useful if
you have some threading issues.

00:19:18.920 --> 00:19:23.080
Another thing I want to show
using the trace system costs

00:19:23.080 --> 00:19:27.550
is to investigate slow UI jank.

00:19:27.550 --> 00:19:33.610
So slow UI rendering, also
called jank by some people,

00:19:33.610 --> 00:19:39.550
as you may know, that
is the [INAUDIBLE] UI

00:19:39.550 --> 00:19:42.590
does the work in two phases.

00:19:42.590 --> 00:19:45.340
The first phase happens
in the main thread.

00:19:45.340 --> 00:19:48.740
It determines what
is on the screen,

00:19:48.740 --> 00:19:50.890
including the layout
and the [INAUDIBLE]..

00:19:50.890 --> 00:19:54.310
It determines the what
by executing all the UI

00:19:54.310 --> 00:20:00.040
elements, such as all the
view classes in your app.

00:20:00.040 --> 00:20:03.040
So after the main threads
generate the what,

00:20:03.040 --> 00:20:06.340
they are passed to the
native render thread.

00:20:06.340 --> 00:20:10.090
The render thread will be
figure out how to draw them.

00:20:10.090 --> 00:20:15.310
Then the how will be passed
to the surface finger system

00:20:15.310 --> 00:20:17.890
process, and the
hardware who is actually

00:20:17.890 --> 00:20:19.910
performing the drawings.

00:20:19.910 --> 00:20:22.990
So that is giving
that background

00:20:22.990 --> 00:20:26.800
so we can see under
the frame area,

00:20:26.800 --> 00:20:30.310
we have this main, which
represents the main thread,

00:20:30.310 --> 00:20:32.700
the render represents
the render thread.

00:20:32.700 --> 00:20:37.750
So let me zoom out a little bit.

00:20:37.750 --> 00:20:43.150
So you can see here,
this is the first phase.

00:20:43.150 --> 00:20:48.202
And corresponding, the
second phase will be here.

00:20:48.202 --> 00:20:52.700
If you are targeting
a smooth UI--

00:20:52.700 --> 00:20:56.930
smooth animation at
60 frames per second,

00:20:56.930 --> 00:21:01.130
which is roughly 16
milliseconds per frame.

00:21:01.130 --> 00:21:03.490
So the two phases
combined together

00:21:03.490 --> 00:21:06.670
should be under 16 frames.

00:21:06.670 --> 00:21:09.640
If it is longer than
that, the profiler

00:21:09.640 --> 00:21:11.920
will color that frame to red.

00:21:11.920 --> 00:21:15.820
So as you know, this
is something slow.

00:21:15.820 --> 00:21:22.210
So if we zoom out more, you
can see a lot of frames.

00:21:22.210 --> 00:21:26.050
I think every one today is red.

00:21:26.050 --> 00:21:27.970
That means every
one is exceeding

00:21:27.970 --> 00:21:32.300
the 16 millisecond threshold.

00:21:32.300 --> 00:21:36.130
One factor is we are
using the emulator.

00:21:36.130 --> 00:21:40.400
Because the way the emulator
interacts with the system,

00:21:40.400 --> 00:21:43.870
you are going to
see more red frames

00:21:43.870 --> 00:21:46.420
than from our actual device.

00:21:46.420 --> 00:21:51.460
Before today's talk, I have
collected another trace

00:21:51.460 --> 00:21:53.830
using an actual physical device.

00:21:53.830 --> 00:21:56.710
And I have exported
that trace as a file.

00:21:56.710 --> 00:21:59.710
And now I want to import
that trace to show you.

00:21:59.710 --> 00:22:03.220
So as Dave said before,
you can use this plus sign

00:22:03.220 --> 00:22:06.555
to import a trace.

00:22:06.555 --> 00:22:08.900
That7s this trace.

00:22:12.530 --> 00:22:15.560
Because when you
trace system calls,

00:22:15.560 --> 00:22:19.050
everything-- the system-wide
events are collected.

00:22:19.050 --> 00:22:21.830
So you need to tell
the provider which

00:22:21.830 --> 00:22:23.480
process you want to look at.

00:22:23.480 --> 00:22:26.284
So we want to look
at Santa Tracker.

00:22:26.284 --> 00:22:31.010
And as you know, the Linux
from the system point of view,

00:22:31.010 --> 00:22:33.530
every process or every
thread, your name

00:22:33.530 --> 00:22:36.900
can be no longer
than 15 characters.

00:22:36.900 --> 00:22:39.240
So that's why this
one is actually

00:22:39.240 --> 00:22:41.270
the santatracker.debug.

00:22:41.270 --> 00:22:44.100
For some reason, the system
thinks this is the name.

00:22:44.100 --> 00:22:47.360
So if you select this one, you
are going to import this trace.

00:22:47.360 --> 00:22:50.000
And here, you can see
from the actual device,

00:22:50.000 --> 00:22:52.980
most of the frames
will be in gray.

00:22:52.980 --> 00:22:56.640
That indicates that they are
under 16 millisecond threshold.

00:22:56.640 --> 00:22:58.460
And so6e of the
frames are in the red

00:22:58.460 --> 00:23:00.320
because they are
over that threshold.

00:23:03.420 --> 00:23:09.150
You may wonder, how does
the profiler know how

00:23:09.150 --> 00:23:11.940
long these phases are taking?

00:23:11.940 --> 00:23:14.790
That is from the tracing point.

00:23:14.790 --> 00:23:18.180
So Android platform
engineers have

00:23:18.180 --> 00:23:24.060
added building tracing points
into some of the critical tasks

00:23:24.060 --> 00:23:25.810
in the Android system.

00:23:25.810 --> 00:23:31.590
So the example here is, if you
click the main thread here,

00:23:31.590 --> 00:23:35.530
these events are showing
from the trace events here.

00:23:35.530 --> 00:23:42.380
So if I zoo6 in here,
you will see this.

00:23:42.380 --> 00:23:46.350
These are trace event called
Choreographer doFra6e.

00:23:46.350 --> 00:23:48.800
So that's the first phase
we just talked about

00:23:48.800 --> 00:23:50.210
in the UI rendering.

00:23:50.210 --> 00:23:52.190
It happens in the main thread.

00:23:52.190 --> 00:23:54.260
If you click the
render thread, you

00:23:54.260 --> 00:23:56.670
can see there is an
event called drawFra6e.

00:23:56.670 --> 00:23:58.410
So that's the second phase.

00:23:58.410 --> 00:24:02.030
And you can also
see there are other

00:24:02.030 --> 00:24:04.620
tracing points in the system.

00:24:04.620 --> 00:24:06.020
They are all building syste6s.

00:24:06.020 --> 00:24:08.810
So they are available
on any Android phones,

00:24:08.810 --> 00:24:10.590
because they are building.

00:24:10.590 --> 00:24:13.370
And they are very useful to
get the timing information

00:24:13.370 --> 00:24:15.560
for some specific tasks.

00:24:15.560 --> 00:24:19.160
And actually you can have
your own trace points, too.

00:24:19.160 --> 00:24:21.430
And I'm going to demo that here.

00:24:21.430 --> 00:24:25.700
So today-- so here,
if we go into the top

00:24:25.700 --> 00:24:29.450
of the app, come back to
this view, we have the cloud.

00:24:29.450 --> 00:24:31.160
We have the snowflakes.

00:24:31.160 --> 00:24:38.640
I want to know exactly how long
6y code is spent joining them.

00:24:38.640 --> 00:24:41.000
So for the cloud, I go
to the Village View.

00:24:44.990 --> 00:24:50.060
So there should be
a onDraw method.

00:24:50.060 --> 00:24:52.120
So at the beginning
of the method,

00:24:52.120 --> 00:24:54.670
I add the instrumentation.

00:24:54.670 --> 00:24:58.330
The trace beginSection, you
need to provide a string,

00:24:58.330 --> 00:24:59.650
which is the section's name.

00:24:59.650 --> 00:25:03.130
At the end of the method, I
will end this trace event.

00:25:06.190 --> 00:25:09.520
For the snowflakes, it
goes to the Snowflake View.

00:25:09.520 --> 00:25:14.080
Again, it should be
in the onDraw method.

00:25:14.080 --> 00:25:16.210
I want to point out
the section name.

00:25:16.210 --> 00:25:18.460
You should pick
a name that 6akes

00:25:18.460 --> 00:25:21.100
sense to you so you
can recognize when

00:25:21.100 --> 00:25:24.430
you7re doing the CPU recording.

00:25:24.430 --> 00:25:27.630
So here we are doing the
Snowflake Android Dev Su66it

00:25:27.630 --> 00:25:28.510
2018.

00:25:28.510 --> 00:25:32.251
So that makes sense
for today's demo.

00:25:32.251 --> 00:25:35.060
So now I have added the
manual instrumentation.

00:25:35.060 --> 00:25:37.840
So I will rebuild this
app, and re-profile it.

00:25:43.210 --> 00:25:46.880
So while we are waiting for the
build, you may be wondering,

00:25:46.880 --> 00:25:50.300
if I want to know how long
the two methods are taking,

00:25:50.300 --> 00:25:53.330
why don't you use the
trace Java method,

00:25:53.330 --> 00:25:58.290
that type of CPU recording you
are talking about a moment ago?

00:25:58.290 --> 00:26:02.450
So I would say trace Java
method is very powerful.

00:26:02.450 --> 00:26:04.020
It's very easy to use.

00:26:04.020 --> 00:26:08.810
But it has significant overhead,
because the Java Virtual

00:26:08.810 --> 00:26:13.555
Machine is collecting data every
time when the execution enters

00:26:13.555 --> 00:26:17.360
a method, and every time when
the execution exits a method.

00:26:17.360 --> 00:26:22.580
So if you have a lot of
frequent small method calls,

00:26:22.580 --> 00:26:26.780
that overhead can quickly add
up and become very expensive.

00:26:26.780 --> 00:26:29.540
If you use the 6anual
instrumentation,

00:26:29.540 --> 00:26:32.990
for example like
using the trace API,

00:26:32.990 --> 00:26:37.980
you have the full control of
when and where to collect data.

00:26:37.980 --> 00:26:42.290
So if you use that wisely, the
overhead will be much smaller.

00:26:42.290 --> 00:26:45.230
And as a result, the
data you collected

00:26:45.230 --> 00:26:47.430
will be more accurate.

00:26:47.430 --> 00:26:50.930
So let's verify the
instrumentation we have.

00:26:50.930 --> 00:26:53.640
So you go to the CPU Profiler.

00:26:53.640 --> 00:26:57.200
We collect a trace of
trace system calls.

00:27:00.616 --> 00:27:06.455
And here, we zoo6 in.

00:27:06.455 --> 00:27:10.180
We see this event again,
choreographer doFra6e.

00:27:10.180 --> 00:27:14.590
This is from the main thread
that is responsible for all UI

00:27:14.590 --> 00:27:15.590
elements.

00:27:15.590 --> 00:27:23.910
And if you keep
zoo6ing, you can see

00:27:23.910 --> 00:27:27.100
this is the frame we just
added, Village View, who

00:27:27.100 --> 00:27:28.590
is joining the cloud.

00:27:28.590 --> 00:27:31.800
And this is the
Snowflake View, ATS 2018.

00:27:31.800 --> 00:27:37.940
That's the thing responsible
for joining the snowflakes.

00:27:37.940 --> 00:27:44.680
So this is how to use the trace
system calls CPU recording.

00:27:44.680 --> 00:27:49.100
So you may have heard of a very
similar tool called systrace.

00:27:49.100 --> 00:27:53.200
So actually my Google
co-worker [INAUDIBLE]

00:27:53.200 --> 00:27:56.980
gave a lightning talk
yesterday on the systrace.

00:27:56.980 --> 00:27:59.740
So it's an extremely
powerful tool,

00:27:59.740 --> 00:28:02.440
but the learning
curve of the systrace

00:28:02.440 --> 00:28:06.220
is a little bit steeper than
the Android Studio Profiler.

00:28:06.220 --> 00:28:11.970
So you may choose the tools
that best suits your needs.

00:28:11.970 --> 00:28:14.890
OK, that's for the
trace CPU recording.

00:28:14.890 --> 00:28:16.520
I will hand over the
demo back to Dave.

00:28:19.894 --> 00:28:20.930
DAVID HERMAN: All right.

00:28:20.930 --> 00:28:23.300
Let's leave the CPU Profiler
behind, and jump over

00:28:23.300 --> 00:28:26.150
to the Memory Profiler.

00:28:26.150 --> 00:28:28.250
First of all, I want to
draw everyone's attention

00:28:28.250 --> 00:28:31.280
to this allocation
tracking pull-down.

00:28:31.280 --> 00:28:34.910
Some quick history here,
in Android Studio 3.0,

00:28:34.910 --> 00:28:39.260
when targeting Android devices
with O or newer, what we did

00:28:39.260 --> 00:28:44.390
is we would collect a call stack
for every single allocation

00:28:44.390 --> 00:28:45.680
that your app made.

00:28:45.680 --> 00:28:49.100
We did it because it would
be very convenient to use

00:28:49.100 --> 00:28:50.690
to have that history.

00:28:50.690 --> 00:28:53.720
However, some of our users
reported that profilers

00:28:53.720 --> 00:28:55.670
were slowing their app down.

00:28:55.670 --> 00:28:58.700
After we investigated, it
turned out to be this feature.

00:28:58.700 --> 00:29:02.870
So starting in
Android Studio 3.3,

00:29:02.870 --> 00:29:06.491
we now give you the
option to configure this.

00:29:06.491 --> 00:29:07.740
Let me go ahead and look here.

00:29:07.740 --> 00:29:10.610
So we have None,
Sampled and Full.

00:29:10.610 --> 00:29:13.100
None disables the
feature, Full enables it,

00:29:13.100 --> 00:29:18.530
and Sampled attempts to collect
a subset of the allocations.

00:29:18.530 --> 00:29:22.770
That sort of gives you a general
look for how your app7s memory

00:29:22.770 --> 00:29:26.030
behavior is, while not actually
affecting your performance

00:29:26.030 --> 00:29:27.860
as much as a full one does.

00:29:27.860 --> 00:29:31.520
Now that being said, whether
or not Full affects your app

00:29:31.520 --> 00:29:33.170
or not can depend
on the host machine

00:29:33.170 --> 00:29:34.820
you're running
on, whether you're

00:29:34.820 --> 00:29:38.250
targeting a device or an
emulator, or even your code.

00:29:38.250 --> 00:29:42.950
If your app code has a
lot of small allocations

00:29:42.950 --> 00:29:46.639
in it like Santa Tracker
does, it can be slow.

00:29:46.639 --> 00:29:48.680
But I recommend playing
around with the features.

00:29:48.680 --> 00:29:51.210
I'm going to go ahead
here and turn Full on.

00:29:51.210 --> 00:29:52.560
I76 going to go live here.

00:29:52.560 --> 00:29:54.790
So you notice once
I turned on Full,

00:29:54.790 --> 00:29:57.980
this allocation indicator
started showing up.

00:29:57.980 --> 00:29:59.820
I want some interesting
things to happen.

00:29:59.820 --> 00:30:03.130
So I'll just go ahead
and rotate the device.

00:30:03.130 --> 00:30:04.470
I may grab you there.

00:30:04.470 --> 00:30:06.300
Rotate it back.

00:30:06.300 --> 00:30:08.089
move it back over there.

00:30:08.089 --> 00:30:09.880
So now let's go ahead
and take a look here.

00:30:09.880 --> 00:30:13.070
So all I need to do at any
point is just drag across,

00:30:13.070 --> 00:30:14.790
and I'm going to
be able to see all

00:30:14.790 --> 00:30:16.740
of the allocations
and the deallocations

00:30:16.740 --> 00:30:18.930
that happened during that range.

00:30:18.930 --> 00:30:21.120
This could be a
really lightweight way

00:30:21.120 --> 00:30:23.910
to sort of get a quick look
at what your memory is doing.

00:30:23.910 --> 00:30:26.400
There's an allocation
and deallocation count.

00:30:26.400 --> 00:30:28.980
So sometimes you might be able
to find memory leaks even just

00:30:28.980 --> 00:30:31.290
doing this.

00:30:31.290 --> 00:30:33.924
And then the other nice thing
is maybe if you have this on,

00:30:33.924 --> 00:30:35.340
and you're doing
some other stuff,

00:30:35.340 --> 00:30:37.890
you can actually go back
in time and select a range,

00:30:37.890 --> 00:30:40.020
and still see what's
going in your memory.

00:30:40.020 --> 00:30:43.786
Now I'm going to go ahead here
and turn it back off again.

00:30:43.786 --> 00:30:47.740
And you'll notice that
the allocation indicated

00:30:47.740 --> 00:30:50.350
that it stopped tracking
by doing an empty circle.

00:30:50.350 --> 00:30:55.030
If I did Sampled Mode, it
would put a half-filled circle.

00:30:55.030 --> 00:30:58.940
Now looking at these
objects, once I click on it,

00:30:58.940 --> 00:31:01.570
you can see every single one
that's currently allocated,

00:31:01.570 --> 00:31:05.410
as well as where
it was allocated.

00:31:05.410 --> 00:31:07.849
This is very useful to get
your handle on a codebase.

00:31:07.849 --> 00:31:10.390
You can click around this and
see where different objects are

00:31:10.390 --> 00:31:11.440
coming from.

00:31:11.440 --> 00:31:13.690
That being said,
it might not help

00:31:13.690 --> 00:31:17.080
you understand why a
memory leak happened, what

00:31:17.080 --> 00:31:18.890
is holding on to my memory.

00:31:18.890 --> 00:31:20.530
If you want to get
that information,

00:31:20.530 --> 00:31:22.910
you have to go over
here to this icon--

00:31:22.910 --> 00:31:25.740
this is the heap dump icon--

00:31:25.740 --> 00:31:27.170
and click the heap dump.

00:31:27.170 --> 00:31:30.540
So what I'm actually going to
do here, just to let you know,

00:31:30.540 --> 00:31:34.270
I could not find a leaking
activity or fragment

00:31:34.270 --> 00:31:36.380
in the Santa Tracker app.

00:31:36.380 --> 00:31:38.810
So, full disclosure,
I added one.

00:31:38.810 --> 00:31:40.750
And what I did is I
added a memory leak

00:31:40.750 --> 00:31:45.110
to this Penguin Swim game here.

00:31:45.110 --> 00:31:50.190
So actually let's go ahead
and go into the activity,

00:31:50.190 --> 00:31:51.800
and leave it.

00:31:51.800 --> 00:31:56.492
And let me actually
do another heap dump.

00:31:56.492 --> 00:31:58.880
All right, so we're about
to get a bunch of heap dump

00:31:58.880 --> 00:31:59.610
information here.

00:31:59.610 --> 00:32:03.350
So I know that the fragment
inside this activity

00:32:03.350 --> 00:32:04.970
is called swim fragment.

00:32:04.970 --> 00:32:08.340
So just like CPU, we have
the Filter button here.

00:32:14.004 --> 00:32:17.900
And I can filter out all
of the different objects,

00:32:17.900 --> 00:32:21.710
and find that, yep, sure
enough, this swimming fragment

00:32:21.710 --> 00:32:22.820
is still alive.

00:32:22.820 --> 00:32:25.640
And I'll click on it, I'll
select the active instance.

00:32:25.640 --> 00:32:28.250
There is a lot going
on here, so I'm

00:32:28.250 --> 00:32:31.250
going to take a moment to
sort of explain a little bit.

00:32:31.250 --> 00:32:34.490
And let's just take a step back
and take a moment to absorb it.

00:32:34.490 --> 00:32:38.450
So I really want to explain
what this depth idea is.

00:32:38.450 --> 00:32:40.790
So imagine all your
Java memory that

00:32:40.790 --> 00:32:44.840
can be cleaned up by the garbage
collector lives in this heap.

00:32:44.840 --> 00:32:47.120
There are some special
Java objects that

00:32:47.120 --> 00:32:48.770
live outside of this circle.

00:32:48.770 --> 00:32:51.310
Those are called GC roots.

00:32:51.310 --> 00:32:53.390
When you create a new
thread, that basically

00:32:53.390 --> 00:32:55.130
creates this special GC root.

00:32:55.130 --> 00:32:58.580
Or static variables are
an instance of a GC root.

00:32:58.580 --> 00:33:01.790
So what ends up happening
is you might, in a thread,

00:33:01.790 --> 00:33:04.999
create an instance of some
class that it, in turn, creates

00:33:04.999 --> 00:33:06.540
an instance of
another class, and it,

00:33:06.540 --> 00:33:08.180
in turn, so on and so forth.

00:33:08.180 --> 00:33:10.040
And so basically
what you're doing

00:33:10.040 --> 00:33:12.200
is you're creating this
long chain of objects,

00:33:12.200 --> 00:33:16.580
and each item in that chain
has further and further

00:33:16.580 --> 00:33:19.190
depth from the GC root.

00:33:19.190 --> 00:33:22.190
Now you may have heard that
cycles are not a problem

00:33:22.190 --> 00:33:23.450
to the garbage collector.

00:33:23.450 --> 00:33:25.779
I can point at you, and
then you point at you,

00:33:25.779 --> 00:33:26.820
and you point back at me.

00:33:26.820 --> 00:33:28.640
But if we can't all
be reached, that

00:33:28.640 --> 00:33:32.000
will all get removed by
the garbage collector.

00:33:32.000 --> 00:33:35.060
So one of the things to note
is when you take a heap dump,

00:33:35.060 --> 00:33:37.460
you might see a scary
amount of things

00:33:37.460 --> 00:33:42.350
holding on to my instance, but
a lot of those are harmless.

00:33:42.350 --> 00:33:44.720
A lot of them are
potentially just cycles.

00:33:44.720 --> 00:33:47.570
And one way that you can kind
of know-- it's not always true,

00:33:47.570 --> 00:33:49.400
but it's a good heuristic--

00:33:49.400 --> 00:33:53.600
is if the depth is greater
than your own depth.

00:33:53.600 --> 00:33:55.580
So let me explain why that is.

00:33:55.580 --> 00:33:59.600
So imagine that the garbage
collection root points to you.

00:33:59.600 --> 00:34:01.727
You create a child instance.

00:34:01.727 --> 00:34:04.310
And one of the things you do is
you give it your this pointer.

00:34:04.310 --> 00:34:05.640
So it's pointing back at you.

00:34:05.640 --> 00:34:06.765
That's a very common thing.

00:34:06.765 --> 00:34:07.908
Here, you point back at me.

00:34:07.908 --> 00:34:09.949
You're my child, but you
know who your parent is.

00:34:09.949 --> 00:34:12.830
So that means my
depth is then going

00:34:12.830 --> 00:34:15.860
to be added onto that
this pointer's depth.

00:34:15.860 --> 00:34:17.989
So that's a reason that
some of these depths

00:34:17.989 --> 00:34:19.697
here may indicate that
even though you're

00:34:19.697 --> 00:34:22.370
seeing that it's not an
issue, you'll also notice here

00:34:22.370 --> 00:34:24.949
that there's a few of these
items in the depth column

00:34:24.949 --> 00:34:26.719
where the depth is blank.

00:34:26.719 --> 00:34:29.060
That means that
there's actually no way

00:34:29.060 --> 00:34:33.290
to reach these at the moment
from any garbage collection

00:34:33.290 --> 00:34:33.860
root.

00:34:33.860 --> 00:34:35.510
So it will eventually
be cleaned up.

00:34:35.510 --> 00:34:38.270
Even though it's showing up
in the heap dump right now,

00:34:38.270 --> 00:34:39.920
you don't have to
worry about it.

00:34:39.920 --> 00:34:40.610
Just ignore it.

00:34:40.610 --> 00:34:42.697
It's as good as reclaimed.

00:34:42.697 --> 00:34:44.780
Just to make sure we
understand this a little bit,

00:34:44.780 --> 00:34:46.670
with a concrete
example, I'm actually

00:34:46.670 --> 00:34:49.219
going to look here at
this code, which is not

00:34:49.219 --> 00:34:50.510
the cause of our memory leak.

00:34:50.510 --> 00:34:51.920
Our depth is 1.

00:34:51.920 --> 00:34:55.380
This item's depth is 2.

00:34:55.380 --> 00:34:57.200
So what this is
saying is somewhere

00:34:57.200 --> 00:35:00.150
there is an instance
of a score view class.

00:35:00.150 --> 00:35:03.020
And that score view class
has a variable called share

00:35:03.020 --> 00:35:05.990
ClickListener,
whose value is me.

00:35:05.990 --> 00:35:11.330
So let's go ahead and take
a look at swimming fragment.

00:35:11.330 --> 00:35:15.360
And I'm going to search
for getScore view.

00:35:15.360 --> 00:35:17.570
So before, when I saw
this, I was trying

00:35:17.570 --> 00:35:17.810
to look through the code.

00:35:17.810 --> 00:35:19.262
I said, there's
gotta be some way

00:35:19.262 --> 00:35:21.470
that I'm going to get a
score view that points at me.

00:35:21.470 --> 00:35:23.011
And there's this
getScore view method

00:35:23.011 --> 00:35:24.320
inside my swimming fragment.

00:35:24.320 --> 00:35:26.840
If I jump to it, what
you're going to see is, yep,

00:35:26.840 --> 00:35:29.990
we create one, and we
pass in the this pointer.

00:35:29.990 --> 00:35:33.770
So that's sort of explaining
why there is a cycle there.

00:35:33.770 --> 00:35:35.780
I don't have to worry
about it, but at least it

00:35:35.780 --> 00:35:38.480
sort of explains why it's
showing up in the heap dump.

00:35:38.480 --> 00:35:43.220
Now you'll also notice there's
a lot of this$0 symbols.

00:35:43.220 --> 00:35:44.690
What's going on here--

00:35:44.690 --> 00:35:46.290
because you're going
to see it a lot.

00:35:46.290 --> 00:35:48.300
You all know what
the this pointer is,

00:35:48.300 --> 00:35:51.920
but if you are an inner class--
if you're a nested class

00:35:51.920 --> 00:35:54.860
and you need to have access
to your outer classes' fields,

00:35:54.860 --> 00:35:56.870
the way that it
works is the compiler

00:35:56.870 --> 00:36:00.962
generates a synthetic variable.

00:36:00.962 --> 00:36:03.170
And instead of calling it
this, because that's taken,

00:36:03.170 --> 00:36:04.770
it calls it this$0.

00:36:04.770 --> 00:36:08.990
So this$0 means the this that's
one level out of my scope.

00:36:08.990 --> 00:36:11.090
And any time you create
an inner class that

00:36:11.090 --> 00:36:14.240
has a reference to
its outer class,

00:36:14.240 --> 00:36:17.381
or you create a closure, an
anonymous class instance,

00:36:17.381 --> 00:36:18.380
it's going to have that.

00:36:18.380 --> 00:36:20.870
So if you're all using
lambdas in your code,

00:36:20.870 --> 00:36:22.330
or anonymous
classes, you're going

00:36:22.330 --> 00:36:23.930
to see a lot of these zeros.

00:36:23.930 --> 00:36:26.540
This one has a depth of 0,
which means it's a GC root.

00:36:26.540 --> 00:36:28.040
That makes it really suspicious.

00:36:28.040 --> 00:36:31.360
So let's jump to the source.

00:36:31.360 --> 00:36:33.640
Now hopefully I
might look at this

00:36:33.640 --> 00:36:36.400
and say, oh, I wrote
this long-running task.

00:36:36.400 --> 00:36:38.350
As you can see, it's
not a static class.

00:36:38.350 --> 00:36:39.350
It's a final class.

00:36:39.350 --> 00:36:42.040
So if it's not static, it's
going to hold onto a reference

00:36:42.040 --> 00:36:43.120
to the parent class.

00:36:43.120 --> 00:36:44.620
That's what's going on here.

00:36:44.620 --> 00:36:46.540
And I might say, oh,
this long-running task,

00:36:46.540 --> 00:36:49.445
I created it, but I
forgot to cancel it.

00:36:49.445 --> 00:36:51.070
So let's go ahead
and take a look here.

00:36:51.070 --> 00:36:53.680
Yep, sure enough, I
left it commented out

00:36:53.680 --> 00:36:55.020
for no good reason.

00:36:55.020 --> 00:36:57.070
Let me uncomment it there.

00:36:57.070 --> 00:36:59.770
And let's relaunch.

00:36:59.770 --> 00:37:02.215
So what we're going
to do now is--

00:37:02.215 --> 00:37:03.590
let me just make
sure it's saved.

00:37:03.590 --> 00:37:05.350
There we go.

00:37:05.350 --> 00:37:08.640
What we're going to do
now is reboot it just

00:37:08.640 --> 00:37:13.231
to make sure that in fact this
swimming fragment was released.

00:37:13.231 --> 00:37:14.730
One of the things
to keep an eye out

00:37:14.730 --> 00:37:16.500
for when you're hunting
for memory leaks

00:37:16.500 --> 00:37:19.590
is static variables
or singleton classes

00:37:19.590 --> 00:37:23.070
that are holding onto your
class or registering yourself

00:37:23.070 --> 00:37:25.350
with a listener, but
forgetting to remove it,

00:37:25.350 --> 00:37:28.350
or any of these inner
classes that for some reason

00:37:28.350 --> 00:37:30.905
may not end up stopping.

00:37:30.905 --> 00:37:33.030
And they're still running,
even though the activity

00:37:33.030 --> 00:37:35.280
is trying to exit.

00:37:35.280 --> 00:37:38.510
Are we profiling here?

00:37:38.510 --> 00:37:40.054
Yes, we are still going.

00:37:40.054 --> 00:37:41.720
And then another thing
I want to mention

00:37:41.720 --> 00:37:43.890
is it's not always
going to be this easy.

00:37:43.890 --> 00:37:46.850
You're not always going to
have this obvious culprit.

00:37:46.850 --> 00:37:48.650
So in that case,
what you're going

00:37:48.650 --> 00:37:51.654
to want to do is,
I would say, just

00:37:51.654 --> 00:37:52.820
try to get to know the code.

00:37:52.820 --> 00:37:54.960
Look for those things
that I talked about.

00:37:54.960 --> 00:37:56.960
Let's go ahead and enter.

00:37:56.960 --> 00:38:00.234
And we'll exit
here while I talk.

00:38:00.234 --> 00:38:03.720
And if you've cleaned it up,
even if you didn't find it

00:38:03.720 --> 00:38:05.220
through the heap
dump, the heap dump

00:38:05.220 --> 00:38:07.009
is still going to be
the source of truth.

00:38:07.009 --> 00:38:08.550
It's still going to
be the thing that

00:38:08.550 --> 00:38:11.790
guarantees to you that your
memory is actually reclaimed.

00:38:11.790 --> 00:38:13.380
So I'm going to go
ahead here, go back

00:38:13.380 --> 00:38:16.400
into the memory profiler.

00:38:16.400 --> 00:38:18.800
I'm going to click on
the garbage collector.

00:38:18.800 --> 00:38:23.884
So you may have noticed these
garbage collected events,

00:38:23.884 --> 00:38:25.050
automatically at the bottom.

00:38:25.050 --> 00:38:26.350
So for example,
there's a lot there.

00:38:26.350 --> 00:38:27.724
That's when the
garbage collector

00:38:27.724 --> 00:38:31.220
decided to collect on its own.

00:38:31.220 --> 00:38:33.700
But you can also click the
garbage collection button

00:38:33.700 --> 00:38:39.664
to manually cause it to get run.

00:38:39.664 --> 00:38:41.330
Now we still see
swimming fragment here.

00:38:41.330 --> 00:38:43.220
Let's see if the
depth is actually--

00:38:43.220 --> 00:38:45.169
so as you can see,
swimming fragment

00:38:45.169 --> 00:38:46.460
is still showing up, which is--

00:38:46.460 --> 00:38:47.270
I could be nervous.

00:38:47.270 --> 00:38:48.020
What happened?

00:38:48.020 --> 00:38:50.270
But the depth column
here is blank.

00:38:50.270 --> 00:38:53.360
Everything is just
basically waiting

00:38:53.360 --> 00:38:55.730
to be picked up by
the garbage collector.

00:38:55.730 --> 00:38:57.980
You can press the garbage
collector a few more times.

00:38:57.980 --> 00:39:01.460
One trick I like to do
is rotate the phone,

00:39:01.460 --> 00:39:03.069
and then rotate it again.

00:39:03.069 --> 00:39:05.360
Anytime you rotate an Android
phone, lots of fun things

00:39:05.360 --> 00:39:05.860
happen.

00:39:05.860 --> 00:39:08.280
It tells the garbage
collector things are going on.

00:39:08.280 --> 00:39:10.912
So in that case, let's just
do another heap dump here,

00:39:10.912 --> 00:39:12.620
and we'll see if the
swimming fragment is

00:39:12.620 --> 00:39:16.505
truly well and collected.

00:39:16.505 --> 00:39:18.720
I wish this came
with a drum roll.

00:39:18.720 --> 00:39:19.520
And there you go.

00:39:19.520 --> 00:39:20.082
It's gone.

00:39:20.082 --> 00:39:22.040
So the final thing I want
to quickly talk about

00:39:22.040 --> 00:39:23.664
is, if you're looking
at the heap dump,

00:39:23.664 --> 00:39:26.420
you're not always necessarily
hunting a memory leak.

00:39:26.420 --> 00:39:29.490
You might not know some
major class to look out for.

00:39:29.490 --> 00:39:32.570
So there's this concept of
shallow size and retained size.

00:39:32.570 --> 00:39:38.870
So shallow size is the size of
a single instance of some class

00:39:38.870 --> 00:39:40.250
that's been allocated.

00:39:40.250 --> 00:39:44.180
And retained size is all of
the things that's holding onto.

00:39:44.180 --> 00:39:47.090
So what you may
want to do is hunt--

00:39:47.090 --> 00:39:49.250
sort your shallow size,
sort your retained size,

00:39:49.250 --> 00:39:50.870
maybe investigate
to see if there's

00:39:50.870 --> 00:39:53.540
any sort of suspicious
memory things there,

00:39:53.540 --> 00:39:55.310
or maybe you could
clean up your design

00:39:55.310 --> 00:39:57.170
and remove some
memory there earlier.

00:39:57.170 --> 00:39:59.190
Anyway, that ends our demo.

00:39:59.190 --> 00:40:00.922
Hand it back to Shukang.

00:40:00.922 --> 00:40:01.880
Let's go to the slides.

00:40:04.450 --> 00:40:06.140
SHUKANG ZHOU: OK, cool.

00:40:06.140 --> 00:40:09.140
So to recap, in
today's demo we have

00:40:09.140 --> 00:40:12.230
shown to use CPU
Profiler and Memory

00:40:12.230 --> 00:40:15.590
Profiler to get a better
understanding of the codebase

00:40:15.590 --> 00:40:17.640
of the Santa Tracker app.

00:40:17.640 --> 00:40:21.380
And to be honest, Dave and
I don't know much about it

00:40:21.380 --> 00:40:23.980
before we are preparing
for this talk.

00:40:23.980 --> 00:40:27.950
And we also have shown
that we don't only

00:40:27.950 --> 00:40:31.250
use profilers to diagnose
performance issues.

00:40:31.250 --> 00:40:34.700
We also use the profilers
to help us understand

00:40:34.700 --> 00:40:37.370
the performance of this app.

00:40:37.370 --> 00:40:41.300
As we said before, there
are also network and energy

00:40:41.300 --> 00:40:42.890
profilers in Android Studio.

00:40:42.890 --> 00:40:46.410
But unfortunately, we don't
have time to cover them today.

00:40:46.410 --> 00:40:49.550
So please refer to our
online documents and talks

00:40:49.550 --> 00:40:51.790
to learn more.

00:40:51.790 --> 00:40:56.150
So we hope you have learned some
tricks and tips from our demo

00:40:56.150 --> 00:40:57.080
today.

00:40:57.080 --> 00:40:59.990
We hope they are useful
when you approach

00:40:59.990 --> 00:41:04.820
your own codebase with your
Studio Profilers at your site.

00:41:04.820 --> 00:41:07.190
Thank you very much
for attending our talk.

00:41:07.190 --> 00:41:08.990
[APPLAUSE]

00:41:09.890 --> 00:41:13.840
[MUSIC PLAYING]

