WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.530
[MUSIC PLAYING]

00:00:03.530 --> 00:00:06.350
CHET HAASE: Welcome to-- what
are we going to talk about?

00:00:06.350 --> 00:00:08.420
Let's talk about Android
development today.

00:00:08.420 --> 00:00:09.190
I'm Chet Haase.

00:00:09.190 --> 00:00:10.969
I'm on the Android
UI toolkit team.

00:00:10.969 --> 00:00:12.260
ROMAIN GUY: And I'm Romain Guy.

00:00:12.260 --> 00:00:13.560
I work on the Android team.

00:00:13.560 --> 00:00:16.270
I'm working on the new
graphics and layout stuff

00:00:16.270 --> 00:00:17.610
that hasn't been announced.

00:00:17.610 --> 00:00:19.212
CHET HAASE: How
incredibly vague.

00:00:19.212 --> 00:00:20.390
ROMAIN GUY: That's correct.

00:00:20.390 --> 00:00:22.840
CHET HAASE: So, today, we're
going to talk specifically

00:00:22.840 --> 00:00:24.800
about the naughty bits.

00:00:24.800 --> 00:00:26.819
I called it that
because I liked it.

00:00:26.819 --> 00:00:28.360
ROMAIN GUY: Because
you have no idea.

00:00:28.360 --> 00:00:29.750
CHET HAASE: I had no
idea, at the time.

00:00:29.750 --> 00:00:31.210
Like, I don't know what
we're going to talk about.

00:00:31.210 --> 00:00:33.570
But, you know what, I like
that title right there.

00:00:33.570 --> 00:00:35.220
So we're going to
keep that title.

00:00:35.220 --> 00:00:38.560
And we're going to make
it mean, today, basically,

00:00:38.560 --> 00:00:41.550
talking about a series
of articles that came out

00:00:41.550 --> 00:00:44.850
on medium.com that was a
collaboration of, basically,

00:00:44.850 --> 00:00:47.210
a lot of people on the
platform team at Android,

00:00:47.210 --> 00:00:49.877
where we tried to do
a brain dump of all

00:00:49.877 --> 00:00:52.460
the patterns and anti patterns
that we've seen over the years.

00:00:52.460 --> 00:00:55.630
App developers sort of taking
assumptions that they had about

00:00:55.630 --> 00:00:58.570
other platforms that they worked
on or other implementations,

00:00:58.570 --> 00:01:00.600
using the Java
programming language,

00:01:00.600 --> 00:01:03.180
and doing things that
are, essentially, wrong to

00:01:03.180 --> 00:01:05.080
do on Android, and ended
up with bad results.

00:01:05.080 --> 00:01:07.870
So we put all this information
into an incredibly long

00:01:07.870 --> 00:01:09.640
internal document, and
then we split it up

00:01:09.640 --> 00:01:15.291
into 10 very long documents
and put them up on medium.com.

00:01:15.291 --> 00:01:18.120
So I would encourage
everybody to check those out.

00:01:18.120 --> 00:01:21.810
I put up my name there,
just for self-gratification,

00:01:21.810 --> 00:01:25.350
but also because you
can, then, find it.

00:01:25.350 --> 00:01:26.540
So please check those out.

00:01:26.540 --> 00:01:28.248
But, specifically,
today's talk is around

00:01:28.248 --> 00:01:30.910
some of the information
in those articles.

00:01:30.910 --> 00:01:33.540
About four months ago we
were doing some user group

00:01:33.540 --> 00:01:35.790
and said, oh why don't we
do a talk around this thing.

00:01:35.790 --> 00:01:37.956
We have about an hour, let's
put all the information

00:01:37.956 --> 00:01:41.400
from 9200 pages worth of
information into this talk.

00:01:41.400 --> 00:01:43.160
And we went there,
and we gave the talk,

00:01:43.160 --> 00:01:45.670
and we got about a third of
the way through in an hour

00:01:45.670 --> 00:01:47.067
and a half was gone.

00:01:47.067 --> 00:01:48.650
So we're not going
to talk about that.

00:01:48.650 --> 00:01:49.700
We've already talked about that.

00:01:49.700 --> 00:01:50.790
Let's talk about
some other stuff

00:01:50.790 --> 00:01:51.900
that we haven't
talked about yet.

00:01:51.900 --> 00:01:53.650
ROMAIN GUY: And,
actually, how many of you

00:01:53.650 --> 00:01:56.260
have read those articles
already, just out of curiosity.

00:01:56.260 --> 00:01:57.285
CHET HAASE: OK,
the rest of you--

00:01:57.285 --> 00:01:58.326
ROMAIN GUY: You can stay.

00:01:58.326 --> 00:02:00.846
CHET HAASE: --go read them
now, and we will wait.

00:02:00.846 --> 00:02:05.287
[LAUGHTER]

00:02:05.287 --> 00:02:06.370
CHET HAASE: Are they done?

00:02:06.370 --> 00:02:07.328
ROMAIN GUY: I think so.

00:02:07.328 --> 00:02:09.160
CHET HAASE: OK,
good job everyone.

00:02:09.160 --> 00:02:10.880
Now, let's repeat
all that information

00:02:10.880 --> 00:02:12.200
in presentation form.

00:02:12.200 --> 00:02:14.490
So why is mobile so difficult?

00:02:14.490 --> 00:02:17.470
So we want to talk about some
of the higher level ideas.

00:02:17.470 --> 00:02:22.170
I would say, if you read nothing
else from that set of articles,

00:02:22.170 --> 00:02:23.530
then I would be very unhappy.

00:02:23.530 --> 00:02:26.380
But point two is,
I would say, if you

00:02:26.380 --> 00:02:28.700
read nothing else except the
first one of those, which

00:02:28.700 --> 00:02:30.866
is called "Understanding
the Mobile Context", that's

00:02:30.866 --> 00:02:33.560
sort of the bigger ideas of,
not just what the rules are,

00:02:33.560 --> 00:02:35.310
but why they actually matter.

00:02:35.310 --> 00:02:37.587
What's the context of
developing on mobile

00:02:37.587 --> 00:02:40.170
that makes it so very difficult,
and makes these rules so very

00:02:40.170 --> 00:02:44.570
important to get a
well-performing and nice user

00:02:44.570 --> 00:02:46.880
experience application
for your users?

00:02:46.880 --> 00:02:49.150
So let's talk about
some of those things.

00:02:49.150 --> 00:02:52.670
So memory, turns
out it's limited.

00:02:52.670 --> 00:02:54.240
It's very limited.

00:02:54.240 --> 00:02:57.770
So the phones that you have
in your pockets are probably,

00:02:57.770 --> 00:02:58.405
I don't know?

00:02:58.405 --> 00:02:59.770
ROMAIN GUY: Two or
three gigs of RAM.

00:02:59.770 --> 00:03:00.710
CHET HAASE: Yeah, two.

00:03:00.710 --> 00:03:01.530
Three?

00:03:01.530 --> 00:03:02.634
Is three common now?

00:03:02.634 --> 00:03:03.300
ROMAIN GUY: Yes.

00:03:03.300 --> 00:03:04.480
CHET HAASE: Four, maybe.

00:03:04.480 --> 00:03:08.190
Possibly as low as one
in a lot of the world.

00:03:08.190 --> 00:03:11.980
512 megs is actually
quite common.

00:03:11.980 --> 00:03:14.162
And it's not just common
on the older phones,

00:03:14.162 --> 00:03:16.120
it's also common on newer
phones that are being

00:03:16.120 --> 00:03:17.940
sold into cheaper markets.

00:03:17.940 --> 00:03:19.874
Right there's a weird
thing about Moore's law,

00:03:19.874 --> 00:03:21.290
where you assume
that everything's

00:03:21.290 --> 00:03:22.900
going to get faster and better.

00:03:22.900 --> 00:03:24.470
And, in general, it does, right?

00:03:24.470 --> 00:03:27.570
Moore's law does mean that it's
cheaper to make these things,

00:03:27.570 --> 00:03:30.390
but it doesn't mean that
the other things go away.

00:03:30.390 --> 00:03:32.780
Those same phones are
still in people's pockets,

00:03:32.780 --> 00:03:34.460
out there, being used every day.

00:03:34.460 --> 00:03:36.880
Moreover, it means
that the low end

00:03:36.880 --> 00:03:40.130
to today's sort of
reasonable mid-range phone

00:03:40.130 --> 00:03:43.270
is possibly going to be the
low range phone for a long time

00:03:43.270 --> 00:03:44.060
to come.

00:03:44.060 --> 00:03:46.387
So don't assume that, just
because you got a good deal

00:03:46.387 --> 00:03:48.470
on a phone that has a
reasonable amount of memory,

00:03:48.470 --> 00:03:50.590
that all of your users
have the same good deal

00:03:50.590 --> 00:03:51.540
in their location.

00:03:51.540 --> 00:03:53.831
ROMAIN GUY: And something
else that a lot of developers

00:03:53.831 --> 00:03:56.570
do, we tend to compare the
specifications of our phones

00:03:56.570 --> 00:03:59.620
to computers that we
know and use every day.

00:03:59.620 --> 00:04:02.310
So I see a lot of people
saying, three gigabytes

00:04:02.310 --> 00:04:03.165
of RAM on my phone.

00:04:03.165 --> 00:04:04.540
It's almost as
much as my laptop.

00:04:04.540 --> 00:04:06.290
I have four gigabytes
on my laptop.

00:04:06.290 --> 00:04:08.660
But, turns out that,
some of our phones today,

00:04:08.660 --> 00:04:10.660
they have as many,
or even more pixels,

00:04:10.660 --> 00:04:12.314
than a lot of
computers out there.

00:04:12.314 --> 00:04:13.980
I mean, even this
morning, I was working

00:04:13.980 --> 00:04:15.540
at my workstation that Google.

00:04:15.540 --> 00:04:19.260
I have a mac pro, a really beefy
machine with 64 gigs of RAM.

00:04:19.260 --> 00:04:22.380
And my 30 inch display
has just as many pixels

00:04:22.380 --> 00:04:25.020
on screen as my phone
that sits in my pocket.

00:04:25.020 --> 00:04:28.750
And, I actually looked at the
activity monitor on my mac,

00:04:28.750 --> 00:04:31.420
and my mac pro was using
20 gigabytes of RAM

00:04:31.420 --> 00:04:33.990
to drive the same
display as my phone does.

00:04:33.990 --> 00:04:37.500
So we don't have 20 gigabytes
of RAM, just yet, on Android.

00:04:37.500 --> 00:04:39.640
We'll get there, someday.

00:04:39.640 --> 00:04:42.160
But be very careful when
you make those comparisons,

00:04:42.160 --> 00:04:44.310
and it's something we're
going to get back to,

00:04:44.310 --> 00:04:46.960
like with CPU's and
GPU's, and storage.

00:04:46.960 --> 00:04:49.770
The numbers feel
familiar, but they

00:04:49.770 --> 00:04:52.504
don't mean the same thing as
they do on desktop and laptops.

00:04:52.504 --> 00:04:54.920
CHET HAASE: Another dynamic
that's important about memory,

00:04:54.920 --> 00:04:58.360
on Android, is everybody is
sharing this limited pool.

00:04:58.360 --> 00:05:00.320
Right, so if you are
taking up a lot of space

00:05:00.320 --> 00:05:03.220
for your activity,
when it launches,

00:05:03.220 --> 00:05:06.180
the system may have
to go around and kill

00:05:06.180 --> 00:05:09.122
other things to make it possible
for your activity to run.

00:05:09.122 --> 00:05:11.330
And then, when you go in
the background, and the user

00:05:11.330 --> 00:05:12.489
goes back to the launcher.

00:05:12.489 --> 00:05:14.530
That may take a while,
because maybe the launcher

00:05:14.530 --> 00:05:17.620
had to be killed in order to
allow your activity to run.

00:05:17.620 --> 00:05:19.474
And then, your
activity may also be

00:05:19.474 --> 00:05:20.890
killed when those
other activity's

00:05:20.890 --> 00:05:21.764
looking for a memory.

00:05:21.764 --> 00:05:23.442
Because, if you take
up a lot of memory,

00:05:23.442 --> 00:05:25.900
you're going to look really
juicy to the Task Manager, when

00:05:25.900 --> 00:05:27.240
it needs more memory to run.

00:05:27.240 --> 00:05:28.900
ROMAIN GUY: And
that's very important,

00:05:28.900 --> 00:05:30.990
because, I know that
your application is

00:05:30.990 --> 00:05:32.390
the most important application.

00:05:32.390 --> 00:05:33.510
It is to you.

00:05:33.510 --> 00:05:36.320
My applications are my most
important applications.

00:05:36.320 --> 00:05:39.660
But I've seen applications
that, basically,

00:05:39.660 --> 00:05:40.954
tried to game the system.

00:05:40.954 --> 00:05:42.370
And when they're
in the background

00:05:42.370 --> 00:05:43.830
they try to refresh
their caches.

00:05:43.830 --> 00:05:46.680
Or they do everything they
can to stay around in memory,

00:05:46.680 --> 00:05:49.270
so that, when the user gets
back to the application,

00:05:49.270 --> 00:05:51.597
they won't suffer
through a cold start up,

00:05:51.597 --> 00:05:52.680
so the app is still there.

00:05:52.680 --> 00:05:54.210
But, what they do
in the process,

00:05:54.210 --> 00:05:56.280
is they kill all the
other apps on the phone,

00:05:56.280 --> 00:05:58.700
so they make everybody
else look bad.

00:05:58.700 --> 00:06:00.702
So you have to work
with each other.

00:06:00.702 --> 00:06:02.160
We really want the
whole experience

00:06:02.160 --> 00:06:03.140
on the system to be good.

00:06:03.140 --> 00:06:04.660
It's not just about
your apps, not just

00:06:04.660 --> 00:06:06.118
about the standard
apps on Android,

00:06:06.118 --> 00:06:09.136
it's about the whole
experience throughout the day.

00:06:09.136 --> 00:06:10.510
CHET HAASE: Let's
talk about CPU.

00:06:10.510 --> 00:06:14.730
It turns out that it's
slower than the CPU's you're

00:06:14.730 --> 00:06:19.280
used to on desktop and server,
much, much, much slower.

00:06:19.280 --> 00:06:22.330
And, another dynamic that
people don't necessarily realize

00:06:22.330 --> 00:06:24.100
is, it's quite often throttled.

00:06:24.100 --> 00:06:27.250
So, in order to get the
maximum battery time

00:06:27.250 --> 00:06:29.140
that we can out of
these devices, we

00:06:29.140 --> 00:06:31.980
end up running things
as slowly as we possibly

00:06:31.980 --> 00:06:33.740
can for as long as we can.

00:06:33.740 --> 00:06:36.324
So we have clever things on
the system like doze mode

00:06:36.324 --> 00:06:38.490
that, hopefully, you heard
about earlier today, that

00:06:38.490 --> 00:06:40.437
allows us to just slow
down the entire system

00:06:40.437 --> 00:06:42.520
and not do much when the
system is not being used.

00:06:42.520 --> 00:06:44.920
But, even when things
are being actively used,

00:06:44.920 --> 00:06:47.630
the user is staring at the
screen reading information,

00:06:47.630 --> 00:06:50.630
the CPU is probably not
at its highest operating

00:06:50.630 --> 00:06:54.140
mode, because we detect that
there is no user interaction,

00:06:54.140 --> 00:06:57.000
there's nothing running
that may require that thing.

00:06:57.000 --> 00:06:58.610
But that means, in
general, that some

00:06:58.610 --> 00:07:01.880
of the things that you may
expect out of a CPU with,

00:07:01.880 --> 00:07:04.910
even the speed that it has
on common mobile devices,

00:07:04.910 --> 00:07:06.639
may not be true
in all situations.

00:07:06.639 --> 00:07:09.180
That you're not going to get
the performance that you thought

00:07:09.180 --> 00:07:10.780
you would have in these
common situations.

00:07:10.780 --> 00:07:12.650
ROMAIN GUY: I actually recently
got a very interesting question

00:07:12.650 --> 00:07:13.149
by email.

00:07:13.149 --> 00:07:15.050
Someone was asking
me-- was telling me

00:07:15.050 --> 00:07:16.880
that whatever algorithm
he was running

00:07:16.880 --> 00:07:18.640
was running slower
than he was expecting.

00:07:18.640 --> 00:07:20.265
So I was telling him
that it's probably

00:07:20.265 --> 00:07:22.390
throttling, because the
device was not busy enough,

00:07:22.390 --> 00:07:24.366
so the CPU was running
probably at 300,

00:07:24.366 --> 00:07:26.832
600, 900 megahertz,
something pretty low.

00:07:26.832 --> 00:07:28.790
And then he came back to
me saying, it's funny,

00:07:28.790 --> 00:07:32.040
when I shake my phone, then
my algorithm runs faster.

00:07:32.040 --> 00:07:33.000
And it's true.

00:07:33.000 --> 00:07:34.375
When you shake
your phone, you're

00:07:34.375 --> 00:07:37.360
probably waking up all
a bunch of sensors,

00:07:37.360 --> 00:07:39.650
which are, in turn, waking
up a bunch of processes.

00:07:39.650 --> 00:07:41.670
So we bump up the
frequency of the CPU

00:07:41.670 --> 00:07:42.880
and your app goes faster.

00:07:42.880 --> 00:07:44.564
[LAUGHTER]

00:07:44.564 --> 00:07:45.980
ROMAIN GUY: So you
could try that,

00:07:45.980 --> 00:07:48.146
if you want to send your
e-mail faster, or whatever.

00:07:48.146 --> 00:07:48.900
Shake your phone.

00:07:48.900 --> 00:07:51.360
Not recommended
to do it all day.

00:07:51.360 --> 00:07:54.370
But the reason why we
throttle, its battery life,

00:07:54.370 --> 00:07:57.270
but it's also thermal issues.

00:07:57.270 --> 00:07:59.510
The latest batch of
CPU's that we have,

00:07:59.510 --> 00:08:00.870
they're multiple cores.

00:08:00.870 --> 00:08:03.460
And the truth is, if we were
to turn on all the cores

00:08:03.460 --> 00:08:06.150
at the same time, at
the maximum frequency,

00:08:06.150 --> 00:08:08.310
your device will probably
the melt. Or, hopefully,

00:08:08.310 --> 00:08:12.240
reboot before it would melt.
But there's so much energy that

00:08:12.240 --> 00:08:16.340
your phone can dissipate that
we cannot run the device at its

00:08:16.340 --> 00:08:17.060
full speed.

00:08:17.060 --> 00:08:19.226
And be, also, very careful
with the numbers that you

00:08:19.226 --> 00:08:20.960
get by looking at
the back of the box,

00:08:20.960 --> 00:08:22.040
when you buy your phone.

00:08:22.040 --> 00:08:24.169
So you see it's a
two gigahertz CPU.

00:08:24.169 --> 00:08:25.710
It is not, because,
most of the time,

00:08:25.710 --> 00:08:26.700
we're going to run throttled.

00:08:26.700 --> 00:08:28.700
And you're going to
see it has eight cores.

00:08:28.700 --> 00:08:29.320
It doesn't.

00:08:29.320 --> 00:08:31.320
It has four little
cores, and for big cores,

00:08:31.320 --> 00:08:33.049
and we're going to use
some of them at some point,

00:08:33.049 --> 00:08:34.465
and some of them
at another point.

00:08:34.465 --> 00:08:37.010
We're not going to use all
of them at the same time.

00:08:37.010 --> 00:08:40.720
The best way to know what's
going on is to use Systrace.

00:08:40.720 --> 00:08:42.519
We covered that,
too, extensively

00:08:42.519 --> 00:08:44.570
at various conferences,
and you can probably

00:08:44.570 --> 00:08:45.670
find the talks on YouTube.

00:08:45.670 --> 00:08:48.090
But Systrace will show you
how many cores are active,

00:08:48.090 --> 00:08:49.506
and at what speed
they're running.

00:08:49.506 --> 00:08:52.050
And you may be really
surprised by what's going on.

00:08:52.050 --> 00:08:53.674
CHET HAASE: I like
the idea of shaking.

00:08:53.674 --> 00:08:56.056
Maybe, if you just played
the vibrate thing constantly,

00:08:56.056 --> 00:08:58.430
then that would provide enough
shaking to wake the phone.

00:08:58.430 --> 00:09:01.362
It's just techniques, just
performance techniques.

00:09:01.362 --> 00:09:02.570
All right, let's talk about--

00:09:02.570 --> 00:09:03.190
ROMAIN GUY: That
doesn't mean you

00:09:03.190 --> 00:09:05.070
should run the vibrator
in your application

00:09:05.070 --> 00:09:06.370
when you want it to go faster.

00:09:06.370 --> 00:09:09.230
Like that's-- don't
give them ideas.

00:09:09.230 --> 00:09:10.240
They're going to do it.

00:09:10.240 --> 00:09:11.659
[LAUGHTER]

00:09:11.659 --> 00:09:13.450
CHET HAASE: Maybe I
should hold up my hand,

00:09:13.450 --> 00:09:16.089
this is not-- I'm not
being serious, no.

00:09:16.089 --> 00:09:17.880
OK see the previous
slide, so all the stuff

00:09:17.880 --> 00:09:19.296
that we said about
CPU's certainly

00:09:19.296 --> 00:09:21.674
applies to the process
for the GPU, as well.

00:09:21.674 --> 00:09:23.090
There's some other
things that are

00:09:23.090 --> 00:09:24.920
specific to the graphics side.

00:09:24.920 --> 00:09:27.410
For one thing, texture
uploads are very expensive.

00:09:27.410 --> 00:09:29.150
A lot of things trigger
texture uploads,

00:09:29.150 --> 00:09:30.730
may or may not be obvious.

00:09:30.730 --> 00:09:32.270
Whenever we're drawing a path.

00:09:32.270 --> 00:09:36.575
Whenever we're entering
new characters of text.

00:09:36.575 --> 00:09:38.200
This is the first
time we've seen them.

00:09:38.200 --> 00:09:39.430
We're going to draw
them into a bitmap.

00:09:39.430 --> 00:09:41.294
That's going to get
uploaded as texture.

00:09:41.294 --> 00:09:42.835
Whenever we're doing
vector drawables

00:09:42.835 --> 00:09:45.400
or other things that
end up being software

00:09:45.400 --> 00:09:46.526
rendered into pads.

00:09:46.526 --> 00:09:48.400
Those are all texture
uploads, in addition to

00:09:48.400 --> 00:09:50.730
the obvious stuff of bitmaps.

00:09:50.730 --> 00:09:54.312
So those are expensive, as are
general fill rate operations.

00:09:54.312 --> 00:09:56.520
ROMAIN GUY: Well, it's just
related to the bandwidth.

00:09:56.520 --> 00:09:58.061
So just like texture
uploads, we have

00:09:58.061 --> 00:10:00.830
a lot of pixels on our devices,
and we need a lot of bandwidths

00:10:00.830 --> 00:10:02.337
to be able to feed the display.

00:10:02.337 --> 00:10:03.920
And you need to draw
all those pixels.

00:10:03.920 --> 00:10:06.730
We need to use internet
buffers, and all that stuff.

00:10:06.730 --> 00:10:09.480
And the bandwidths
on mobile has not

00:10:09.480 --> 00:10:12.550
growing at the same
speed as the rest

00:10:12.550 --> 00:10:14.800
of the system, so the CPU,
the GPU, or even the screen

00:10:14.800 --> 00:10:15.301
density.

00:10:15.301 --> 00:10:17.008
So it's still very
much a problem, today.

00:10:17.008 --> 00:10:19.250
And we covered that
extensively in previous talks

00:10:19.250 --> 00:10:21.830
where we mentioned things
like overdraw and blending

00:10:21.830 --> 00:10:24.750
and why you should avoid them.

00:10:24.750 --> 00:10:26.564
GPU's on mobile
have other issues.

00:10:26.564 --> 00:10:27.730
I mean, they're really good.

00:10:27.730 --> 00:10:30.480
They're incredible, given
they'll run on phones.

00:10:30.480 --> 00:10:31.910
But you can't
really compare them

00:10:31.910 --> 00:10:34.860
to desktop GPU's, or your
laptops, or even your consoles.

00:10:34.860 --> 00:10:36.760
I mean, just to
give you an idea,

00:10:36.760 --> 00:10:39.140
a fairly power efficient
GPU on a desktop

00:10:39.140 --> 00:10:42.430
uses about 175 watts of power.

00:10:42.430 --> 00:10:45.350
On a phone, if we can
dissipate four watts of power,

00:10:45.350 --> 00:10:48.376
it's really good.

00:10:48.376 --> 00:10:51.470
We can't do what they can do.

00:10:51.470 --> 00:10:53.330
Even if you conserve
the bandwidth,

00:10:53.330 --> 00:10:55.772
even if you're really
careful with your textures,

00:10:55.772 --> 00:10:57.480
our GPU's are still
very limited in terms

00:10:57.480 --> 00:11:00.820
of how many computations
they can do on every pixel.

00:11:00.820 --> 00:11:03.229
So, you probably don't care
if you're not writing open GR

00:11:03.229 --> 00:11:04.020
code, for instance.

00:11:04.020 --> 00:11:05.280
But if you're writing
a game, or open GI

00:11:05.280 --> 00:11:06.696
on your application,
something you

00:11:06.696 --> 00:11:10.130
need to be very careful about,
especially on older devices.

00:11:10.130 --> 00:11:14.260
No matter what, don't test only
on recent devices when it comes

00:11:14.260 --> 00:11:15.940
to GPU's.

00:11:15.940 --> 00:11:17.740
There's a huge gap
between a Nexus 6P

00:11:17.740 --> 00:11:20.012
and devices from two
or three years ago.

00:11:20.012 --> 00:11:21.970
CHET HAASE: There's also
an interesting dynamic

00:11:21.970 --> 00:11:24.509
that comes up when
you're looking at,

00:11:24.509 --> 00:11:26.800
as we said, fill rate that's
not necessarily keeping up

00:11:26.800 --> 00:11:27.770
with the curve of
everything else

00:11:27.770 --> 00:11:29.590
and these devices
that are coming out

00:11:29.590 --> 00:11:30.890
with amazing density.

00:11:30.890 --> 00:11:33.090
What was the-- was it the Nexus?

00:11:33.090 --> 00:11:36.460
--or the 6P is like 550 DPI.

00:11:36.460 --> 00:11:39.520
Just huge numbers, which is
really awesome for a screen

00:11:39.520 --> 00:11:40.190
resolution.

00:11:40.190 --> 00:11:43.000
But, if you imagine
that that's how many

00:11:43.000 --> 00:11:46.386
pixels we have to actually
fill in every single frame,

00:11:46.386 --> 00:11:49.010
then that's kind of problematic
if you don't have the bandwidth

00:11:49.010 --> 00:11:50.450
to actually do
that appropriately.

00:11:50.450 --> 00:11:52.590
Which is why we have a lot of
these recommendations around.

00:11:52.590 --> 00:11:53.570
ROMAIN GUY: But the
good news is that, we

00:11:53.570 --> 00:11:56.028
felt we were pretty much done
with density, because we have

00:11:56.028 --> 00:11:57.390
real so many pixels these days.

00:11:57.390 --> 00:11:59.600
But the VR just arrived.

00:11:59.600 --> 00:12:02.580
And for VR, you need
even more pixels.

00:12:02.580 --> 00:12:04.210
So it's going to get worse.

00:12:04.210 --> 00:12:05.710
CHET HAASE:
Fortunately, people only

00:12:05.710 --> 00:12:09.260
have two eyes so we
can only go so far.

00:12:09.260 --> 00:12:12.340
Memory, so, in general,
a lot of the tips

00:12:12.340 --> 00:12:14.290
that we have about
performance boiled down

00:12:14.290 --> 00:12:15.650
to tips about memory.

00:12:15.650 --> 00:12:19.780
Because, on Android, and the
run times we're talking about,

00:12:19.780 --> 00:12:21.840
memory is so closely
tied to performance.

00:12:21.840 --> 00:12:23.520
There's a lot of
dynamics around that.

00:12:23.520 --> 00:12:24.820
Let's talk about some of those.

00:12:24.820 --> 00:12:28.190
So when you require
more and more memory,

00:12:28.190 --> 00:12:30.680
you're basically allocating
a larger and larger heap.

00:12:30.680 --> 00:12:33.400
It takes more processing
power to actually allocate

00:12:33.400 --> 00:12:36.280
that heap to increment
the size over time.

00:12:36.280 --> 00:12:38.720
It also means that there's
going to be task thrashing.

00:12:38.720 --> 00:12:40.060
We were talking about
this before, if you

00:12:40.060 --> 00:12:41.476
take a lot of
memory, someone else

00:12:41.476 --> 00:12:43.500
has to die to ensure
that you can live,

00:12:43.500 --> 00:12:46.170
and vice versa when you
go in the background.

00:12:46.170 --> 00:12:48.670
Allocations are going to take
longer, because there's simply

00:12:48.670 --> 00:12:51.086
more information to wade through
for the garbage collector

00:12:51.086 --> 00:12:53.420
to actually figure out
where to put the thing,

00:12:53.420 --> 00:12:55.720
where the free space is.

00:12:55.720 --> 00:12:59.930
Collections are slower
for the same exact reason.

00:12:59.930 --> 00:13:04.330
And there's just general
more activity for the garbage

00:13:04.330 --> 00:13:07.390
collector to run through,
allocating, collecting, doing,

00:13:07.390 --> 00:13:10.010
hopefully not, but
probably, full GC's

00:13:10.010 --> 00:13:12.502
to actually get memory
back in the system.

00:13:12.502 --> 00:13:14.710
So we thought it would be
useful to walk through some

00:13:14.710 --> 00:13:17.380
of the ideas around garbage
allocation and collection

00:13:17.380 --> 00:13:20.310
in general so you can
understand the context of why

00:13:20.310 --> 00:13:21.740
this stuff costs so very much.

00:13:21.740 --> 00:13:24.450
ROMAIN GUY: So this is how
a garbage collector works.

00:13:24.450 --> 00:13:25.775
CHET HAASE: OK, any questions?

00:13:25.775 --> 00:13:27.050
[LAUGHTER]

00:13:27.050 --> 00:13:29.710
CHET HAASE: OK, so if we go
into the technical description,

00:13:29.710 --> 00:13:32.870
the squigglies on
the left indicate--

00:13:32.870 --> 00:13:34.490
actually I don't really know.

00:13:34.490 --> 00:13:35.866
I still [INAUDIBLE] something.

00:13:35.866 --> 00:13:38.480
ROMAIN GUY: Yeah, I am
disturbed by the squigglies.

00:13:38.480 --> 00:13:40.869
CHET HAASE: Somebody in
the squiggly dimension

00:13:40.869 --> 00:13:42.910
is trying to allocate
something, and they come up

00:13:42.910 --> 00:13:43.860
with a blue rectangle.

00:13:43.860 --> 00:13:44.690
I don't know why it's blue.

00:13:44.690 --> 00:13:45.690
I don't know why
it's a rectangle.

00:13:45.690 --> 00:13:47.314
But they want to
allocate space for it.

00:13:47.314 --> 00:13:49.350
So it looks at the
garbage, at the heap,

00:13:49.350 --> 00:13:51.449
and it says, OK, I want
to allocate this thing.

00:13:51.449 --> 00:13:52.990
We put it in there,
then we enumerate

00:13:52.990 --> 00:13:55.239
all the things that have
references in the enumeration

00:13:55.239 --> 00:13:55.760
phase.

00:13:55.760 --> 00:13:58.070
The mark phase says, OK,
what are the things that

00:13:58.070 --> 00:13:59.890
don't have references, because
those are the things that we

00:13:59.890 --> 00:14:00.810
can get rid of.

00:14:00.810 --> 00:14:02.200
And then we collect that, right?

00:14:02.200 --> 00:14:03.980
So we free up that little
red thing in the middle.

00:14:03.980 --> 00:14:05.271
We freed up the space for that.

00:14:05.271 --> 00:14:08.110
That is now space that can be
used for a future allocation

00:14:08.110 --> 00:14:09.340
in the heap.

00:14:09.340 --> 00:14:11.530
It's important to note
that on Dalvik, there's

00:14:11.530 --> 00:14:14.400
two different pauses that
happen during this process.

00:14:14.400 --> 00:14:16.210
There's a pause
during enumeration,

00:14:16.210 --> 00:14:19.320
while you actually walk the heap
and see where the references

00:14:19.320 --> 00:14:20.890
are to all these objects.

00:14:20.890 --> 00:14:24.760
And then there's the mark
phase that also has a pause.

00:14:24.760 --> 00:14:28.670
Part of the mark phases is,
OK, it can do that concurrently

00:14:28.670 --> 00:14:30.094
with other threads.

00:14:30.094 --> 00:14:31.510
But, part of it,
it needs to pause

00:14:31.510 --> 00:14:34.640
everything else in the system
at the end of that mark phase

00:14:34.640 --> 00:14:36.750
to, basically, do a post
process and say, OK,

00:14:36.750 --> 00:14:39.800
are there any changes since
I ran through the first one?

00:14:39.800 --> 00:14:41.780
ROMAIN GUY: And you
want to remember

00:14:41.780 --> 00:14:44.370
that a pause pauses all your
threads in your application.

00:14:44.370 --> 00:14:46.960
So it's not just the UI thread
that's going to be paused.

00:14:46.960 --> 00:14:48.390
We're going to pause
your background threads.

00:14:48.390 --> 00:14:50.306
That also means that a
background thread doing

00:14:50.306 --> 00:14:53.350
too much GC activity will
impact your UI thread, so

00:14:53.350 --> 00:14:54.625
your animations, your layouts.

00:14:54.625 --> 00:14:56.500
CHET HAASE: And you can
see these in the log.

00:14:56.500 --> 00:15:01.100
These are GC for allocates,
other GC operations,

00:15:01.100 --> 00:15:02.730
concurrent GC's.

00:15:02.730 --> 00:15:06.127
There's lots of information
about GC's in the log.

00:15:06.127 --> 00:15:07.960
You can see some of
these things coming out,

00:15:07.960 --> 00:15:11.050
and, if you wonder why
they're there, this is why.

00:15:11.050 --> 00:15:13.400
So, on ART, there
were improvements,

00:15:13.400 --> 00:15:15.290
huge improvements, made
to garbage collection

00:15:15.290 --> 00:15:16.385
allocation in general.

00:15:16.385 --> 00:15:18.510
One of the big improvements
was, there is no longer

00:15:18.510 --> 00:15:20.470
a pause during the
enumeration phase,

00:15:20.470 --> 00:15:22.510
and there is a smaller
pause during mark.

00:15:22.510 --> 00:15:24.880
But it is still a
stop the world pause.

00:15:24.880 --> 00:15:26.310
So, at the end of
the mark phase,

00:15:26.310 --> 00:15:28.670
they're going to do
a quick pause just

00:15:28.670 --> 00:15:32.900
to the collect the information
and move on from there.

00:15:32.900 --> 00:15:35.460
So, now, let's look at a
more problematic situation.

00:15:35.460 --> 00:15:37.110
This is the GC for
Alloc situation.

00:15:37.110 --> 00:15:39.280
You come in, someone
wants, yet again,

00:15:39.280 --> 00:15:40.799
a blue rectangle allocated.

00:15:40.799 --> 00:15:43.340
And it comes in and says, OK,
well I've got a space for that,

00:15:43.340 --> 00:15:44.756
how about a second
blue rectangle,

00:15:44.756 --> 00:15:47.850
because I had such a good time
allocating for the first one.

00:15:47.850 --> 00:15:49.480
And it walks through
the entire heap,

00:15:49.480 --> 00:15:53.160
and it cannot find a contiguous
block of space large enough

00:15:53.160 --> 00:15:55.911
for the second blue rectangle,
so it needs to free up space

00:15:55.911 --> 00:15:56.410
for that.

00:15:56.410 --> 00:16:00.170
Then it does a GC for Alloc,
and there's a huge pause, right?

00:16:00.170 --> 00:16:04.645
So this is the really
problematic thing about GC.

00:16:04.645 --> 00:16:06.770
Not just that it's a huge
pause, but it, basically,

00:16:06.770 --> 00:16:09.490
happens at exactly the
time you do not want it to.

00:16:09.490 --> 00:16:11.180
You may be in your
inner loop and you're

00:16:11.180 --> 00:16:13.880
doing something that
triggers an allocation, that

00:16:13.880 --> 00:16:17.010
triggers the need to
actually walk the entire heap

00:16:17.010 --> 00:16:19.250
and free everything
possible just to get memory

00:16:19.250 --> 00:16:20.450
to allocate that thing.

00:16:20.450 --> 00:16:22.600
Nothing can continue
in your program

00:16:22.600 --> 00:16:24.770
until that is
freed up for you so

00:16:24.770 --> 00:16:26.230
that it can be put on the heap.

00:16:26.230 --> 00:16:27.440
So you're, basically,
going to pause right

00:16:27.440 --> 00:16:29.300
in the middle of an
animation or a rendering

00:16:29.300 --> 00:16:30.966
or whatever, something
on the UI thread.

00:16:30.966 --> 00:16:33.410
ROMAIN GUY: And it is important
to know that GC for Alloc

00:16:33.410 --> 00:16:35.220
does not make any
guarantee that you'll

00:16:35.220 --> 00:16:37.552
be able to actually allocate
what you want to allocate.

00:16:37.552 --> 00:16:39.010
Because, if the
heap is fragmented,

00:16:39.010 --> 00:16:41.343
and we'll get back to that,
because there's been changes

00:16:41.343 --> 00:16:44.060
with ART, between when
the heap is fragmented,

00:16:44.060 --> 00:16:46.010
there might not be a
single slot available

00:16:46.010 --> 00:16:47.750
that's big enough
to fit your object.

00:16:47.750 --> 00:16:49.420
In which case, you
will get a crash,

00:16:49.420 --> 00:16:51.620
an out of memory exception.

00:16:51.620 --> 00:16:53.070
And, the interesting
part is, you

00:16:53.070 --> 00:16:56.980
could have dozens of megabytes
of free space in your heap,

00:16:56.980 --> 00:17:00.477
but, because of fragmentation,
allocation could fail and crash

00:17:00.477 --> 00:17:02.060
your application,
just because we need

00:17:02.060 --> 00:17:03.897
contiguous memory in the heap.

00:17:03.897 --> 00:17:05.230
It's actually fairly easy to do.

00:17:05.230 --> 00:17:08.410
You can try it for yourself if
you have a developing device.

00:17:08.410 --> 00:17:11.420
You can allocate a bunch
of objects in the list,

00:17:11.420 --> 00:17:14.779
and then you know every
other object in the list.

00:17:14.779 --> 00:17:16.690
You wait for a GC.

00:17:16.690 --> 00:17:18.310
So you will have
fragmented the heap.

00:17:18.310 --> 00:17:19.980
Try to allocate
another big object,

00:17:19.980 --> 00:17:22.000
and you will run out of
memory, even though you

00:17:22.000 --> 00:17:24.790
have a ton of memory available.

00:17:24.790 --> 00:17:27.210
And that happens a
lot with bitmaps,

00:17:27.210 --> 00:17:30.850
which is why, in ART,
they've introduced

00:17:30.850 --> 00:17:32.530
the concept of the large heap.

00:17:32.530 --> 00:17:34.980
So it's a special heap
for large objects.

00:17:34.980 --> 00:17:39.670
And bitmaps, in particular,
are good candidates for that.

00:17:39.670 --> 00:17:42.290
So not only does it help
with the heap fragmentation,

00:17:42.290 --> 00:17:44.480
because we know that
we're likely to find

00:17:44.480 --> 00:17:46.970
large contiguous space
in the large heap,

00:17:46.970 --> 00:17:49.950
but it will also make every
allocation and garbage

00:17:49.950 --> 00:17:52.300
collection in the coming
heap faster, because there

00:17:52.300 --> 00:17:54.929
will be less memory to look at.

00:17:54.929 --> 00:17:56.470
CHET HAASE: Another
the dynamic we've

00:17:56.470 --> 00:18:00.896
seen a lot is the prevalence of
low-end devices in the world.

00:18:00.896 --> 00:18:02.270
In general, we've
referenced this

00:18:02.270 --> 00:18:04.710
before in the context of memory.

00:18:04.710 --> 00:18:07.230
But, basically, the
device in your pocket,

00:18:07.230 --> 00:18:10.080
guaranteed it's faster
than most of your users.

00:18:10.080 --> 00:18:11.580
And it has more memory.

00:18:11.580 --> 00:18:13.950
So we're talking
about Moore's law.

00:18:13.950 --> 00:18:15.730
It doesn't always
apply, or, at least,

00:18:15.730 --> 00:18:17.370
it doesn't apply in
the way you expect.

00:18:17.370 --> 00:18:19.230
Those low end devices
are going to be

00:18:19.230 --> 00:18:21.187
in the world for a
long time to come.

00:18:21.187 --> 00:18:23.020
So your application
needs to deal with them,

00:18:23.020 --> 00:18:27.050
unless you simply
don't like those users.

00:18:27.050 --> 00:18:29.530
Smooth frame rate, so
this is an important one.

00:18:29.530 --> 00:18:32.312
We talk about 16
milliseconds a lot.

00:18:32.312 --> 00:18:34.020
I guess it's a number
that we like a lot.

00:18:34.020 --> 00:18:36.330
Basically, you have
60 frames a second.

00:18:36.330 --> 00:18:40.190
That boils down to
16.67 milliseconds

00:18:40.190 --> 00:18:41.950
that you have to do everything.

00:18:41.950 --> 00:18:44.590
Right, so you need to
process your input.

00:18:44.590 --> 00:18:47.860
You need to process your
animations for that frame.

00:18:47.860 --> 00:18:49.620
You need to do any
measure in layout that,

00:18:49.620 --> 00:18:51.286
hopefully didn't
happen in an animation,

00:18:51.286 --> 00:18:52.830
but sometimes it does.

00:18:52.830 --> 00:18:54.394
And process all the
drawing commands

00:18:54.394 --> 00:18:55.560
for the things that changed.

00:18:55.560 --> 00:18:57.410
And then those get sent
over the render thread.

00:18:57.410 --> 00:18:58.701
All of that stuff goes through.

00:18:58.701 --> 00:19:01.660
Everything has to happen in
16 milliseconds, in addition

00:19:01.660 --> 00:19:04.660
to anything else that was
going on in the system that

00:19:04.660 --> 00:19:06.340
may cause a pause there.

00:19:06.340 --> 00:19:09.420
Right, so 16 milliseconds,
if it doesn't happen by then,

00:19:09.420 --> 00:19:11.900
then you just missed
a frame, and you just

00:19:11.900 --> 00:19:14.320
missed the opportunity
for a smooth frame rate

00:19:14.320 --> 00:19:15.650
for your users.

00:19:15.650 --> 00:19:18.620
Another element of frame
rate that's not as obvious

00:19:18.620 --> 00:19:20.231
is that consistency is good.

00:19:20.231 --> 00:19:21.730
I would say, in
general, it's better

00:19:21.730 --> 00:19:24.280
to hit 30 frames a
second consistently,

00:19:24.280 --> 00:19:27.364
than it is to hit 60 frames
a second most of the time,

00:19:27.364 --> 00:19:29.280
and then occasionally
you're going to pop out.

00:19:29.280 --> 00:19:30.780
If you know you're
going to pop out,

00:19:30.780 --> 00:19:32.872
and there's nothing
you can do about it,

00:19:32.872 --> 00:19:35.330
then go back to the drawing
board and do something about it

00:19:35.330 --> 00:19:35.830
anyway.

00:19:35.830 --> 00:19:39.430
But it would be better
to sort of back off

00:19:39.430 --> 00:19:40.930
to a slower frame
rate, at least one

00:19:40.930 --> 00:19:42.320
that you can deliver
consistently.

00:19:42.320 --> 00:19:43.695
Otherwise, what
the user is going

00:19:43.695 --> 00:19:46.045
to see is, smooth, smooth,
smooth, pause, skip.

00:19:46.045 --> 00:19:47.670
Right, it's very
noticeable when you're

00:19:47.670 --> 00:19:49.610
going to drop frame
rate, just occasionally.

00:19:49.610 --> 00:19:50.810
It's a noticeable
blip on the screen.

00:19:50.810 --> 00:19:51.630
ROMAIN GUY: That's
actually something

00:19:51.630 --> 00:19:53.070
that, for those of
you who play games,

00:19:53.070 --> 00:19:54.819
is something fairly
common in video games,

00:19:54.819 --> 00:19:56.110
especially on consoles.

00:19:56.110 --> 00:20:00.280
Where video game
developers would rather

00:20:00.280 --> 00:20:02.180
target 30 frames
per second, than

00:20:02.180 --> 00:20:03.680
have a fluctuating
frame rate, which

00:20:03.680 --> 00:20:06.730
can be very distracting when
you need to plan missions,

00:20:06.730 --> 00:20:10.450
or have reflexes in
a multiplayer game.

00:20:10.450 --> 00:20:13.049
And, the thing is, on Android,
because we are Vsynced,

00:20:13.049 --> 00:20:14.590
there are different
types of Vsynced,

00:20:14.590 --> 00:20:16.465
but Android has always
been Vsynced, at least

00:20:16.465 --> 00:20:17.980
at the compositer level.

00:20:17.980 --> 00:20:19.730
When you miss a frame,
it's not like we're

00:20:19.730 --> 00:20:23.700
going to drop to 59
frames per second, or 58.

00:20:23.700 --> 00:20:25.570
You're going to go all
the way down to 30.

00:20:25.570 --> 00:20:27.153
So, if every other
frame, you're going

00:20:27.153 --> 00:20:29.370
to go 60 frames, 30
frames, 60 frames,

00:20:29.370 --> 00:20:31.310
and it's extremely
jarring for the user.

00:20:31.310 --> 00:20:34.190
So like Chet said,
if you cannot hit 60,

00:20:34.190 --> 00:20:37.482
you should maybe hit for
30 consistently, instead.

00:20:37.482 --> 00:20:39.190
CHET HAASE: Or pop up
a dialogue and tell

00:20:39.190 --> 00:20:40.273
them to shake their phone.

00:20:40.273 --> 00:20:41.950
[LAUGHTER]

00:20:41.950 --> 00:20:45.010
ROMAIN GUY: Or have a setting.

00:20:45.010 --> 00:20:48.430
CHET HAASE: Let's talk about
run time, so Dalvik verses ART.

00:20:48.430 --> 00:20:51.060
We talked about some of the
differences in the collectors,

00:20:51.060 --> 00:20:51.800
before.

00:20:51.800 --> 00:20:53.490
There's a really
important dynamic

00:20:53.490 --> 00:20:58.470
about whether they can
defragment the heap.

00:20:58.470 --> 00:21:00.650
So this was sort
of implied before,

00:21:00.650 --> 00:21:02.730
but Dalvik, basically,
once you allocate a thing,

00:21:02.730 --> 00:21:04.104
if it's going to
stay there, it's

00:21:04.104 --> 00:21:06.616
going to stay in exactly
the same place in the heap.

00:21:06.616 --> 00:21:08.490
There's no point at
which Dalvik can actually

00:21:08.490 --> 00:21:09.670
move things around.

00:21:09.670 --> 00:21:11.250
So, if you allocate
a bunch of stuff

00:21:11.250 --> 00:21:13.630
and then other stuff
goes away, the stuff

00:21:13.630 --> 00:21:15.995
that still allocated
and referenced somewhere

00:21:15.995 --> 00:21:17.370
is not going to
move, which means

00:21:17.370 --> 00:21:19.328
it can fragment over
time, and, eventually, you

00:21:19.328 --> 00:21:21.179
can run out of room to
allocate other items.

00:21:21.179 --> 00:21:23.220
Not because you don't have
the space in the heap,

00:21:23.220 --> 00:21:25.480
but because you don't
have the contiguous space.

00:21:25.480 --> 00:21:28.730
ART made a change where it can
actually defragment that heap.

00:21:28.730 --> 00:21:30.620
When the app goes
into the background,

00:21:30.620 --> 00:21:32.410
then there's an
appropriate idle time.

00:21:32.410 --> 00:21:34.880
So it will, eventually,
compensate for this.

00:21:34.880 --> 00:21:37.580
Although, possibly not in the
time that you need it, if it's

00:21:37.580 --> 00:21:38.380
in the foreground.

00:21:38.380 --> 00:21:39.963
ROMAIN GUY: An
interesting side effect

00:21:39.963 --> 00:21:41.810
is that, there used to
be a lot of JNI code

00:21:41.810 --> 00:21:44.270
out there that was wrong,
because the objects were never

00:21:44.270 --> 00:21:45.562
moving in Dalvik heap.

00:21:45.562 --> 00:21:47.770
If you're not careful about
how you get a pointer to,

00:21:47.770 --> 00:21:50.555
let's say a java byte
array, your code will work,

00:21:50.555 --> 00:21:52.430
because we're never
going to move that array.

00:21:52.430 --> 00:21:55.110
Then you move to ART, and
suddenly that array might move,

00:21:55.110 --> 00:21:58.430
and your pointer is
pointing to who knows what.

00:21:58.430 --> 00:22:04.726
And so, I think the JNI checks
are stricter now, with ART.

00:22:04.726 --> 00:22:07.350
So if you write JNI code, or it
you're going to write JNI code,

00:22:07.350 --> 00:22:08.516
be very carefully with that.

00:22:08.516 --> 00:22:10.390
Make sure you test
on ART and Dalvik,

00:22:10.390 --> 00:22:14.515
and follow the JNI conventions
in the documentation.

00:22:14.515 --> 00:22:16.390
CHET HAASE: Language
does not equal run time,

00:22:16.390 --> 00:22:17.610
and does not equal hardware.

00:22:17.610 --> 00:22:21.400
So I gave a different
variation of this talk

00:22:21.400 --> 00:22:24.740
at a conference a month ago
and someone asked a question

00:22:24.740 --> 00:22:27.160
afterwards along
the lines of, so

00:22:27.160 --> 00:22:29.090
when there's a new
release with the JDK

00:22:29.090 --> 00:22:30.780
how do you keep up
with the changes

00:22:30.780 --> 00:22:32.060
in the run time of something.

00:22:32.060 --> 00:22:33.910
And I realized,
people didn't quite

00:22:33.910 --> 00:22:35.770
understand the mental
model they needed to

00:22:35.770 --> 00:22:37.742
about what the
language is versus

00:22:37.742 --> 00:22:39.950
the runtime versus the
devices that we're running on.

00:22:39.950 --> 00:22:43.310
So I thought it would be worth
diagramming this for you.

00:22:43.310 --> 00:22:45.330
So these are all very
separate things, right?

00:22:45.330 --> 00:22:47.140
So we have this Java
programming language

00:22:47.140 --> 00:22:49.680
that we use in Android
that has absolutely nothing

00:22:49.680 --> 00:22:51.640
to do with the run times
on other platforms.

00:22:51.640 --> 00:22:53.945
The runtime is a separate
thing, whether it's

00:22:53.945 --> 00:22:56.320
Dalvik, whether it's ART,
whether it's some other runtime

00:22:56.320 --> 00:22:57.536
on some other system.

00:22:57.536 --> 00:22:59.660
And then there's the hardware
that it's running on,

00:22:59.660 --> 00:23:01.510
and it's sort of
important to understand

00:23:01.510 --> 00:23:05.890
that this stack is going to look
quite different for servers.

00:23:05.890 --> 00:23:08.020
So traditional Java
developers that

00:23:08.020 --> 00:23:10.070
are writing Java on
the back for servers,

00:23:10.070 --> 00:23:11.950
writing web apps,
whatever, they're

00:23:11.950 --> 00:23:14.220
going to be in a very different
environment than we're

00:23:14.220 --> 00:23:15.600
in on Android.

00:23:15.600 --> 00:23:18.670
So they are running over there
with some server runtime.

00:23:18.670 --> 00:23:21.050
It's moving, and it's
a compacting collector.

00:23:21.050 --> 00:23:22.837
It's got huge
heaps to deal with,

00:23:22.837 --> 00:23:24.420
and it deals of them
very efficiently,

00:23:24.420 --> 00:23:26.003
with the very different
system than we

00:23:26.003 --> 00:23:28.080
have in either Dalvik or ART.

00:23:28.080 --> 00:23:32.870
And then, you're on the server
and the CPU is really quick,

00:23:32.870 --> 00:23:35.250
and the memory is,
essentially, unlimited, right?

00:23:35.250 --> 00:23:38.190
Just huge gobs of memory that
you can do oodles of things

00:23:38.190 --> 00:23:38.690
with.

00:23:38.690 --> 00:23:40.560
Meanwhile, on
Android, which you can

00:23:40.560 --> 00:23:42.310
tell because it's
colored green, we

00:23:42.310 --> 00:23:44.100
have two different run times.

00:23:44.100 --> 00:23:46.160
We have Dalvik up until KitKat.

00:23:46.160 --> 00:23:48.700
I think ART it was
default in KitKat.

00:23:48.700 --> 00:23:52.050
So what the dynamics
are going to get around,

00:23:52.050 --> 00:23:55.365
the runtime, the performance of
the runtime, the optimizations

00:23:55.365 --> 00:23:57.740
taken, as well as some of the
garbage collector softwares

00:23:57.740 --> 00:23:59.610
we're talking about, depends
on which of those run times

00:23:59.610 --> 00:24:00.430
you're running on.

00:24:00.430 --> 00:24:01.780
And then there's
the actual hardware

00:24:01.780 --> 00:24:02.748
that you're running on.

00:24:02.748 --> 00:24:05.950
[LAUGHTER]

00:24:05.950 --> 00:24:07.970
ROMAIN GUY: It's even
shaped like a phone.

00:24:07.970 --> 00:24:08.870
CHET HAASE: It is.

00:24:08.870 --> 00:24:09.797
It's very accurate.

00:24:09.797 --> 00:24:10.880
I took that from the tool.

00:24:10.880 --> 00:24:13.150
It's a snapshot from the tool.

00:24:13.150 --> 00:24:15.770
So we have no compaction,
as we're talking about.

00:24:15.770 --> 00:24:17.070
We do not compact the heap.

00:24:17.070 --> 00:24:18.970
We can't be
fragmented on Dalvik.

00:24:18.970 --> 00:24:20.810
We can do idle time
compaction when

00:24:20.810 --> 00:24:23.257
the app is in the
background with the ART--

00:24:23.257 --> 00:24:24.840
ROMAIN GUY: So that
is very important,

00:24:24.840 --> 00:24:26.510
because we do compact the heap.

00:24:26.510 --> 00:24:28.380
Because it's an
expensive operation,

00:24:28.380 --> 00:24:31.090
it happens, like Chet said, when
your app is in the background.

00:24:31.090 --> 00:24:32.630
So that means you
can still run out

00:24:32.630 --> 00:24:35.640
of memory with a ton of free
memory in your heap, when

00:24:35.640 --> 00:24:36.700
you're in the foreground.

00:24:36.700 --> 00:24:39.116
So you still need to be very
careful with how you allocate

00:24:39.116 --> 00:24:42.574
and deallocate objects,
because you could run into one

00:24:42.574 --> 00:24:44.240
of those weird crash
reports that you'll

00:24:44.240 --> 00:24:47.120
get from your favorite
[INAUDIBLE] reporting tools,

00:24:47.120 --> 00:24:50.090
and you will not understand how
it can be run out of memory,

00:24:50.090 --> 00:24:51.910
and this is probably why.

00:24:51.910 --> 00:24:53.970
And, of course, do not
send your application

00:24:53.970 --> 00:24:56.610
to the background automatically
to defragment your heap.

00:24:56.610 --> 00:24:57.380
That's a bad idea.

00:24:57.380 --> 00:25:00.060
[LAUGHTER]

00:25:00.060 --> 00:25:02.470
ROMAIN GUY: Any idea you might
have based on what we say,

00:25:02.470 --> 00:25:03.411
don't do it.

00:25:03.411 --> 00:25:05.674
[LAUGHTER]

00:25:05.674 --> 00:25:07.090
CHET HAASE: If we
were to quantify

00:25:07.090 --> 00:25:10.750
the CPU for this platform,
it would be way slower.

00:25:10.750 --> 00:25:16.095
And the memory is, in general,
between 512 and two, or more.

00:25:16.095 --> 00:25:17.720
But it's really
important to remember--

00:25:17.720 --> 00:25:19.560
ROMAIN GUY: The technical
term is not enough.

00:25:19.560 --> 00:25:20.518
CHET HAASE: Not enough.

00:25:20.518 --> 00:25:22.640
Never enough.

00:25:22.640 --> 00:25:25.670
Also, on the UI thread,
some dynamics here,

00:25:25.670 --> 00:25:28.660
it's a single threaded UI
system for the most part.

00:25:28.660 --> 00:25:30.810
ROMAIN GUY: Well, it's a
single threaded UI system,

00:25:30.810 --> 00:25:32.601
except there's a render
thread, and you can

00:25:32.601 --> 00:25:34.090
have multiple single threads.

00:25:34.090 --> 00:25:35.798
CHET HAASE: OK so it's
a single threaded,

00:25:35.798 --> 00:25:38.480
multithreaded UI system.

00:25:38.480 --> 00:25:41.590
In general, you are always
doing things UI related,

00:25:41.590 --> 00:25:45.750
which means input processing,
animation, rendering on the UI

00:25:45.750 --> 00:25:46.250
thread.

00:25:46.250 --> 00:25:47.985
In general, it's a
single UI thread.

00:25:47.985 --> 00:25:49.443
ROMAIN GUY: Well,
little know fact,

00:25:49.443 --> 00:25:51.620
you can have multiple UI
threads in your process.

00:25:51.620 --> 00:25:53.514
Don't try to do this.

00:25:53.514 --> 00:25:55.680
It's only frame work people
who have to worry about.

00:25:55.680 --> 00:25:57.220
You can, but don't do it.

00:25:57.220 --> 00:25:58.678
CHET HAASE: We have
to test for it,

00:25:58.678 --> 00:26:01.120
but it's not really a situation
that comes up very often.

00:26:01.120 --> 00:26:03.990
When we are done with processing
all the rendering stuff,

00:26:03.990 --> 00:26:05.810
then we'll send it
over the render thread,

00:26:05.810 --> 00:26:07.140
which will then send it to GL.

00:26:07.140 --> 00:26:10.580
But you can still think of it
as being a single threaded UI

00:26:10.580 --> 00:26:14.310
system where all this stuff
sort of has to happen serially.

00:26:14.310 --> 00:26:18.760
And the trick, here, is to,
basically, eliminate everything

00:26:18.760 --> 00:26:22.037
that should not or does not
have to happen on the UI thread,

00:26:22.037 --> 00:26:23.870
because you really don't
want to stall that.

00:26:23.870 --> 00:26:26.280
Otherwise you're going
to cross that magical 16

00:26:26.280 --> 00:26:30.221
millisecond boundary and jank
the UI experience for the--

00:26:30.221 --> 00:26:32.470
ROMAIN GUY: So the best way
to make your app go faster

00:26:32.470 --> 00:26:33.630
is to stop writing code.

00:26:33.630 --> 00:26:34.710
So just go on vacation.

00:26:34.710 --> 00:26:37.166
And the best part is,
you can even justify it.

00:26:37.166 --> 00:26:39.600
[LAUGHTER]

00:26:39.600 --> 00:26:43.370
CHET HAASE: So, in storage,
performance varies.

00:26:43.370 --> 00:26:46.800
So just the raw performance
of these storage devices,

00:26:46.800 --> 00:26:49.150
we've also seen situations
where the more that's

00:26:49.150 --> 00:26:50.870
been allocated into
that storage system,

00:26:50.870 --> 00:26:52.530
the longer it takes
to deal with it.

00:26:52.530 --> 00:26:53.905
ROMAIN GUY: If
you're interested,

00:26:53.905 --> 00:26:56.140
you should look up
how non Flash works.

00:26:56.140 --> 00:26:57.140
It's pretty interesting.

00:26:57.140 --> 00:26:59.090
So the disk controllers
for Flash memory

00:26:59.090 --> 00:27:00.462
are extremely complicated.

00:27:00.462 --> 00:27:02.920
It turns out that Flash
memory is basically

00:27:02.920 --> 00:27:05.840
as a garbage collector.

00:27:05.840 --> 00:27:07.950
It's very interesting,
but the fact

00:27:07.950 --> 00:27:12.140
is that, the fuller your storage
is, the slower it can get.

00:27:12.140 --> 00:27:17.450
And things that multiple
random writes on the Flash

00:27:17.450 --> 00:27:18.624
can really kill performance.

00:27:18.624 --> 00:27:21.040
So, what happens is that, when
you have a lot of processes

00:27:21.040 --> 00:27:23.540
on the system, on Android for
instance, that they're writing

00:27:23.540 --> 00:27:26.130
to memory, to storage
memory, at the same time,

00:27:26.130 --> 00:27:27.750
things will really slow down.

00:27:27.750 --> 00:27:30.750
And we've had pretty bad issues
on past devices with that.

00:27:30.750 --> 00:27:32.290
It's mostly fixed these days.

00:27:32.290 --> 00:27:34.760
But so, if your app
stays in the background,

00:27:34.760 --> 00:27:36.260
and you're going
to do a lot of disk

00:27:36.260 --> 00:27:39.630
I/O-- try to be mindful of
the other apps, as well.

00:27:39.630 --> 00:27:42.480
Because you writing
stuff to the storage

00:27:42.480 --> 00:27:44.105
might impact the app
in the foreground.

00:27:44.105 --> 00:27:46.020
CHET HAASE: That dynamic
of storage makes sense.

00:27:46.020 --> 00:27:47.436
If you just think
about this week,

00:27:47.436 --> 00:27:49.920
Thanksgiving week in
particular, as people eat more,

00:27:49.920 --> 00:27:51.746
they get slower.

00:27:51.746 --> 00:27:54.190
[LAUGHTER]

00:27:54.190 --> 00:27:56.030
Storage size varies,
so you're not

00:27:56.030 --> 00:27:58.370
exactly sure what your
user is going to have.

00:27:58.370 --> 00:28:01.730
Is your app going to be able
to cope with that flexibility?

00:28:01.730 --> 00:28:05.130
And the APK size ends
up mattering because

00:28:05.130 --> 00:28:06.210
of these dynamics, right?

00:28:06.210 --> 00:28:09.050
Are you really going to be able
to fit on the user's device?

00:28:09.050 --> 00:28:12.010
And will there be noticeable
performance problems

00:28:12.010 --> 00:28:17.180
because it was just too bloated
for that particular performance

00:28:17.180 --> 00:28:19.480
dynamic on their system?

00:28:19.480 --> 00:28:21.670
In the network,
again, this is just

00:28:21.670 --> 00:28:23.340
like the CPU and memory issues.

00:28:23.340 --> 00:28:24.820
Turns out your
network is probably

00:28:24.820 --> 00:28:27.570
faster than your users'
networks, especially

00:28:27.570 --> 00:28:29.650
in some locales
across the world.

00:28:29.650 --> 00:28:33.380
They're dealing with incredibly
slow networks or data networks

00:28:33.380 --> 00:28:37.220
that, even when they're not
that slow, they may cost a lot.

00:28:37.220 --> 00:28:40.060
So maybe those users are not
on those networks as much

00:28:40.060 --> 00:28:40.770
as possible.

00:28:40.770 --> 00:28:43.530
ROMAIN GUY: A good way to test,
so you can use the emulator.

00:28:43.530 --> 00:28:45.270
You've seen the
presentations before.

00:28:45.270 --> 00:28:47.230
So there are ways to
emulate slower networks.

00:28:47.230 --> 00:28:49.360
Well, if you're
leaving the Bay Area

00:28:49.360 --> 00:28:55.240
you could just go take a hike on
the hills, by the 280 highway.

00:28:55.240 --> 00:28:57.464
The network is really bad there.

00:28:57.464 --> 00:28:59.630
So it's a good way to test,
and take some fresh air.

00:28:59.630 --> 00:29:01.546
And, again, you can
justify it with your boss.

00:29:01.546 --> 00:29:03.370
[LAUGHTER]

00:29:03.370 --> 00:29:05.370
CHET HAASE: Cheaper too,
this is a huge dynamic.

00:29:05.370 --> 00:29:09.380
Like, are you trying to sell
your application into places

00:29:09.380 --> 00:29:11.390
where they really try
to avoid using the data

00:29:11.390 --> 00:29:13.720
network for whatever reason?

00:29:13.720 --> 00:29:16.190
But are you very dependent
upon that for your application

00:29:16.190 --> 00:29:16.690
experience?

00:29:16.690 --> 00:29:19.310
Maybe there are ways that you
could write your application

00:29:19.310 --> 00:29:22.220
such that you can deal
with this situation better.

00:29:22.220 --> 00:29:24.900
Allow them to wait until
they're on a Wi-Fi network

00:29:24.900 --> 00:29:26.990
to deal with that, or whatever.

00:29:26.990 --> 00:29:30.530
And finally there's a couple
of-- these sort of marketing

00:29:30.530 --> 00:29:32.780
slogans, but they're really
important to keep in mind.

00:29:32.780 --> 00:29:34.530
One is, every device
is a village, right?

00:29:34.530 --> 00:29:37.090
This isn't just a touchy-feely
thing, this is a reality.

00:29:37.090 --> 00:29:40.160
That all of these activities
need to live together,

00:29:40.160 --> 00:29:42.376
and services need to live
together on the same system

00:29:42.376 --> 00:29:44.250
to make a reasonable
experience for the user.

00:29:44.250 --> 00:29:46.994
So, if your activity is
demanding a lot of memory,

00:29:46.994 --> 00:29:48.910
you're going to kick a
lot of other stuff out.

00:29:48.910 --> 00:29:50.350
So, that's great for
your activity, when

00:29:50.350 --> 00:29:51.470
it's in the
foreground, because it

00:29:51.470 --> 00:29:52.660
got the memory that it wanted.

00:29:52.660 --> 00:29:54.960
But, you know what, when the
user leaves your activity,

00:29:54.960 --> 00:29:57.200
and goes back, and has
to relaunch launcher

00:29:57.200 --> 00:29:59.984
because it even kicked that out,
because you asked for so much,

00:29:59.984 --> 00:30:01.900
that's probably not a
great experience, right?

00:30:01.900 --> 00:30:04.800
You're not contributing
to happiness for the user

00:30:04.800 --> 00:30:07.020
just because your
application was being greedy.

00:30:07.020 --> 00:30:08.853
And then when you go
in the background, when

00:30:08.853 --> 00:30:10.670
they run anything
else, you're activity

00:30:10.670 --> 00:30:12.940
is taking up so much
memory, that you're probably

00:30:12.940 --> 00:30:14.990
going to be killed as well.

00:30:14.990 --> 00:30:18.010
So, if all of these
things are going

00:30:18.010 --> 00:30:20.824
to be as greedy as possible
in this shared space,

00:30:20.824 --> 00:30:23.240
then it's just not going to
be a happy situation, overall.

00:30:23.240 --> 00:30:24.698
ROMAIN GUY: And
there are many ways

00:30:24.698 --> 00:30:27.560
you can deal with it fairly
easily and fairly efficiently.

00:30:27.560 --> 00:30:30.060
So I'm not going to name the
application, because I think

00:30:30.060 --> 00:30:34.510
it's one of ours, but I have
a test device, it's a Nexus 9,

00:30:34.510 --> 00:30:37.370
and I haven't even set up
a Google account on it.

00:30:37.370 --> 00:30:38.990
And every time I
boot the device,

00:30:38.990 --> 00:30:41.430
there's a process running that
clearly shouldn't be there,

00:30:41.430 --> 00:30:44.510
because I don't even have an
account for that application.

00:30:44.510 --> 00:30:46.204
So there's a service running.

00:30:46.204 --> 00:30:48.620
So, what you can do in your
application, in your manifest,

00:30:48.620 --> 00:30:51.130
you can disable things like
the broadcast receivers,

00:30:51.130 --> 00:30:52.150
the services.

00:30:52.150 --> 00:30:54.540
And until the user
actually does something

00:30:54.540 --> 00:30:57.030
in the application
that informs you

00:30:57.030 --> 00:31:00.640
that they want to use the
application, they signed in,

00:31:00.640 --> 00:31:02.260
they logged in,
or whatever, then

00:31:02.260 --> 00:31:05.080
you can programmatically enable
your service or your broadcast

00:31:05.080 --> 00:31:07.280
receiver and the system
will remember that.

00:31:07.280 --> 00:31:09.815
So, even across reboots,
your service will stay there.

00:31:09.815 --> 00:31:11.690
And it's really important,
because, that way,

00:31:11.690 --> 00:31:13.231
you will leave the
rest of the system

00:31:13.231 --> 00:31:17.044
free when the user is not that
interested in part of your app.

00:31:17.044 --> 00:31:18.710
CHET HAASE: App Standby
tries to address

00:31:18.710 --> 00:31:20.782
some of this dynamic,
where, if we notice

00:31:20.782 --> 00:31:22.240
that an application
is not actually

00:31:22.240 --> 00:31:26.520
being used by the user, then it
will not allow that application

00:31:26.520 --> 00:31:28.950
to start using our resources.

00:31:28.950 --> 00:31:30.770
Because, obviously,
the user has not

00:31:30.770 --> 00:31:33.260
requested that on
the app's behalf.

00:31:33.260 --> 00:31:34.760
But there's only
so much that we can

00:31:34.760 --> 00:31:36.843
do systematically and
automatically in the system.

00:31:36.843 --> 00:31:39.540
Your application knows
better what it needs

00:31:39.540 --> 00:31:41.200
and what it can disable.

00:31:41.200 --> 00:31:43.615
And then, finally,
the first item

00:31:43.615 --> 00:31:45.990
sort of leads to the second
which is, tragedy of commons,

00:31:45.990 --> 00:31:48.310
where if every
application on the device

00:31:48.310 --> 00:31:51.010
is acting greedily in
its own self-interest,

00:31:51.010 --> 00:31:53.460
then you just end up
with a bad experience

00:31:53.460 --> 00:31:55.560
overall, for every one
of those applications.

00:31:55.560 --> 00:31:58.060
Maybe it made sense for
you, because, obviously,

00:31:58.060 --> 00:32:00.650
the most important thing the
user could do on their phone

00:32:00.650 --> 00:32:03.390
is to play your cat
video application.

00:32:03.390 --> 00:32:06.610
But if everybody has
the same attitude,

00:32:06.610 --> 00:32:09.650
then it's going to end
up being bad overall.

00:32:09.650 --> 00:32:10.900
So let's go through some tips.

00:32:10.900 --> 00:32:13.570
So these are the
higher level concepts

00:32:13.570 --> 00:32:15.160
of why this stuff matters.

00:32:15.160 --> 00:32:17.390
Now let's go through some
of the actual items about--

00:32:17.390 --> 00:32:20.010
ROMAIN GUY: And, hopefully,
you have heard of those tips

00:32:20.010 --> 00:32:20.956
before.

00:32:20.956 --> 00:32:23.160
So, if you feel like
we're repeating ourselves,

00:32:23.160 --> 00:32:24.060
that's a good thing.

00:32:24.060 --> 00:32:25.685
And we're going to
talk about it again,

00:32:25.685 --> 00:32:27.246
until you stop making
those mistakes.

00:32:27.246 --> 00:32:28.494
[LAUGHTER]

00:32:28.494 --> 00:32:29.660
ROMAIN GUY: So, no overdraw.

00:32:29.660 --> 00:32:32.067
How many of you know
what overdraw is about?

00:32:32.067 --> 00:32:33.400
CHET HAASE: Well, it's getting--

00:32:33.400 --> 00:32:34.650
ROMAIN GUY: Better every year.

00:32:34.650 --> 00:32:37.040
Everybody who didn't raise their
hand, shame on you, as usual.

00:32:37.040 --> 00:32:37.650
CHET HAASE: Oh,
it's because they're

00:32:37.650 --> 00:32:39.390
busy reading the articles.

00:32:39.390 --> 00:32:40.810
ROMAIN GUY: I hope.

00:32:40.810 --> 00:32:43.480
So, if you want to know more,
I wrote an extensive piece

00:32:43.480 --> 00:32:45.430
on the subject.

00:32:45.430 --> 00:32:49.290
Just Google, I don't
know, Android overdraw.

00:32:49.290 --> 00:32:50.470
You'll find it.

00:32:50.470 --> 00:32:51.886
Basically, overdraw
is when you're

00:32:51.886 --> 00:32:53.950
repeating the same pixels
over and over again.

00:32:53.950 --> 00:32:56.540
We have tools on your phone
that help you catch overdraw,

00:32:56.540 --> 00:33:00.090
and we have multiple articles
that explain how to avoid it.

00:33:00.090 --> 00:33:02.870
Since KitKat, the
rendering pipeline

00:33:02.870 --> 00:33:06.460
does some automatic
removal of overdraw.

00:33:06.460 --> 00:33:07.340
It's not perfect.

00:33:07.340 --> 00:33:09.720
There are things that
we cannot guess for you.

00:33:09.720 --> 00:33:11.860
And, when you turn on
the overdraw detection

00:33:11.860 --> 00:33:14.250
tool on the device,
it has the side effect

00:33:14.250 --> 00:33:16.320
of disabling the optimization
so you can actually

00:33:16.320 --> 00:33:18.230
see where you are overdrawing.

00:33:18.230 --> 00:33:20.980
And the reasoning is,
if you're overdrawing,

00:33:20.980 --> 00:33:22.840
your also probably
creating too many views,

00:33:22.840 --> 00:33:24.930
running bitmaps
you might not need,

00:33:24.930 --> 00:33:26.910
making allocations
you don't need.

00:33:26.910 --> 00:33:29.677
So fixing overdraw
will also help

00:33:29.677 --> 00:33:32.260
other parts of your application,
like memory pressure, startup

00:33:32.260 --> 00:33:33.870
time.

00:33:33.870 --> 00:33:36.230
CHET HAASE: No
window backgrounds

00:33:36.230 --> 00:33:38.050
may seem like a good
idea at the time.

00:33:38.050 --> 00:33:38.920
They tend to--

00:33:38.920 --> 00:33:41.230
ROMAIN GUY: It was a good
idea a long time ago.

00:33:41.230 --> 00:33:44.990
CHET HAASE: They tend to
create artifacts on the screen.

00:33:44.990 --> 00:33:46.920
So, if you've ever
seen something

00:33:46.920 --> 00:33:48.820
like when the keyboard
comes up, you'll

00:33:48.820 --> 00:33:52.600
see either garbage or black
on the window in the space

00:33:52.600 --> 00:33:54.180
where the keyboard
is animating over,

00:33:54.180 --> 00:33:56.881
it's because someone decided
to assign a null window

00:33:56.881 --> 00:33:57.380
background.

00:33:57.380 --> 00:33:59.250
This is partly to
address the overdraw.

00:33:59.250 --> 00:34:01.760
They said, well, obviously,
I don't want a background

00:34:01.760 --> 00:34:03.680
to my window that
is then covered

00:34:03.680 --> 00:34:06.672
with an opaque background
of my main container,

00:34:06.672 --> 00:34:09.130
so I'm just going to remove
one of them to get rid of that.

00:34:09.130 --> 00:34:11.519
And it kind of
works in the main,

00:34:11.519 --> 00:34:13.310
but then there's these
specific cases where

00:34:13.310 --> 00:34:15.831
it causes artifacts,
keyboard animates up,

00:34:15.831 --> 00:34:18.080
and the window manager doesn't
know what to draw there

00:34:18.080 --> 00:34:20.034
because you told us null.

00:34:20.034 --> 00:34:21.409
Right, so how do
you draw a null?

00:34:21.409 --> 00:34:22.431
You don't do anything.

00:34:22.431 --> 00:34:24.139
So we don't do anything,
and then the GPU

00:34:24.139 --> 00:34:25.555
will just draw
some default there,

00:34:25.555 --> 00:34:27.449
which is either
black or garbage.

00:34:27.449 --> 00:34:30.179
So there's other situations that
can trigger that same artifact.

00:34:30.179 --> 00:34:32.960
The real way to handle
this is to actually have

00:34:32.960 --> 00:34:34.409
a window background,
and not have

00:34:34.409 --> 00:34:36.159
opaque on that main container.

00:34:36.159 --> 00:34:37.909
So you can still get
the benefit of having

00:34:37.909 --> 00:34:40.820
the background for the windows
so the window manager always

00:34:40.820 --> 00:34:44.010
knows what to draw when it
needs to, but then actually use

00:34:44.010 --> 00:34:47.889
that background as part of the
background of your application.

00:34:47.889 --> 00:34:49.650
Similarly, there's
artifacts caused

00:34:49.650 --> 00:34:53.130
by disabling the
starting window.

00:34:53.130 --> 00:34:55.322
Let's see, so the
main reason-- there

00:34:55.322 --> 00:34:57.530
are a few reasons to think
about the starting window.

00:34:57.530 --> 00:35:00.400
One is that you want to give
the user immediate response

00:35:00.400 --> 00:35:01.670
that something has happened.

00:35:01.670 --> 00:35:03.171
They tapped the
icon, they're trying

00:35:03.171 --> 00:35:05.211
to launch your application,
which, unfortunately,

00:35:05.211 --> 00:35:07.640
is going to take seven seconds
to launch because there's

00:35:07.640 --> 00:35:10.350
entirely too much happening
when you're creating activity.

00:35:10.350 --> 00:35:11.770
But, in the meantime,
we'd like to show them

00:35:11.770 --> 00:35:14.130
that something is happening, so
that they don't go and tap it

00:35:14.130 --> 00:35:15.504
again and wonder
what's going on,

00:35:15.504 --> 00:35:16.900
and then uninstall your app.

00:35:16.900 --> 00:35:18.620
So we quickly launch
the starting window,

00:35:18.620 --> 00:35:20.600
this takes a very
small amount of time,

00:35:20.600 --> 00:35:22.700
usually along the
lines of 200 to 400

00:35:22.700 --> 00:35:24.290
millisecond to bring
up this window.

00:35:24.290 --> 00:35:26.310
We basically peek
into the resources,

00:35:26.310 --> 00:35:28.184
into the theme of the
activity, and we say,

00:35:28.184 --> 00:35:29.850
OK, here's what a
window would generally

00:35:29.850 --> 00:35:31.100
look like for this activity.

00:35:31.100 --> 00:35:32.850
And we'll pull it up
there, and then we'll

00:35:32.850 --> 00:35:35.720
cross fade into the activity
as soon as it's ready to draw.

00:35:35.720 --> 00:35:38.830
And this includes, for example,
the launch window experience,

00:35:38.830 --> 00:35:42.546
if you've seen any of the
stuff running on M. We're

00:35:42.546 --> 00:35:43.670
doing the same exact thing.

00:35:43.670 --> 00:35:45.920
It's just a starting window
with a background that

00:35:45.920 --> 00:35:47.170
happens to have an icon in it.

00:35:47.170 --> 00:35:49.253
It's very quick for us to
figure out what this is,

00:35:49.253 --> 00:35:51.610
to load it in, and to
launch that starting window.

00:35:51.610 --> 00:35:54.400
And then we're cross-fading into
the activity as soon as we can.

00:35:54.400 --> 00:35:56.380
If you disable that
starting window,

00:35:56.380 --> 00:35:59.566
then there's situations where,
like the launch experience,

00:35:59.566 --> 00:36:01.940
where we really should be
drawing something for the user,

00:36:01.940 --> 00:36:05.810
and we cannot because
you told us not to.

00:36:05.810 --> 00:36:08.490
UI stalls, so this
relates to the single

00:36:08.490 --> 00:36:12.356
threaded, multithreaded
UI thread situation

00:36:12.356 --> 00:36:13.230
that we talked about.

00:36:13.230 --> 00:36:14.700
Or there's lots
of things that can

00:36:14.700 --> 00:36:18.170
cause us to stall in the
middle of doing UI processing,

00:36:18.170 --> 00:36:19.840
so it's good to
be wary of these.

00:36:19.840 --> 00:36:22.870
When you're inflating resources,
that's always on the UI thread.

00:36:22.870 --> 00:36:24.860
So, if you're doing a
particularly expensive

00:36:24.860 --> 00:36:28.110
inflation, if you're launching
a super expensive activity

00:36:28.110 --> 00:36:30.960
from another activity,
or if you have

00:36:30.960 --> 00:36:33.671
a deep hierarchy that you're
inflating along the way,

00:36:33.671 --> 00:36:35.420
then that may take
enough time that you're

00:36:35.420 --> 00:36:37.740
going to jank a frame
because of that.

00:36:37.740 --> 00:36:39.310
Handling events, you want to?

00:36:39.310 --> 00:36:40.560
I've been talking for a while.

00:36:40.560 --> 00:36:41.595
You talk.

00:36:41.595 --> 00:36:42.970
ROMAIN GUY: There
are some places

00:36:42.970 --> 00:36:44.480
where expensive
operations won't be

00:36:44.480 --> 00:36:47.140
that noticeable, for instance
when you click on a button.

00:36:47.140 --> 00:36:49.950
But then, the places where
you want a really be careful,

00:36:49.950 --> 00:36:52.730
so handling events, like we just
talked about, so on touch even.

00:36:52.730 --> 00:36:54.770
Then there's the
all measure method

00:36:54.770 --> 00:36:55.920
that's part of the layout.

00:36:55.920 --> 00:36:58.242
So you can keep going
through the slides.

00:36:58.242 --> 00:36:59.200
CHET HAASE: Here we go.

00:36:59.200 --> 00:37:04.050
ROMAIN GUY: OK, the on layout,
the on draw, keep going,

00:37:04.050 --> 00:37:05.980
and animations, of
course, are going

00:37:05.980 --> 00:37:07.920
to trigger all those callbacks.

00:37:07.920 --> 00:37:09.640
So those are really
the places where

00:37:09.640 --> 00:37:11.100
you want to optimize your code.

00:37:11.100 --> 00:37:14.770
Where you want to use
Systrace, use the profiler,

00:37:14.770 --> 00:37:18.210
use the GPU profiler, if you
have to, use tracer for GLES.

00:37:18.210 --> 00:37:21.310
And it's OK, I think, to
apply some micro optimizations

00:37:21.310 --> 00:37:23.680
in the spaces of code,
because they are so important.

00:37:23.680 --> 00:37:26.670
Like Chet mentioned,
you have 16 milliseconds

00:37:26.670 --> 00:37:28.290
to do everything you have to do.

00:37:28.290 --> 00:37:32.010
And, turns out, that in the
land of mobile, 16 milliseconds

00:37:32.010 --> 00:37:33.910
have a different duration.

00:37:33.910 --> 00:37:36.586
So, depending on how
fast your CPU's going,

00:37:36.586 --> 00:37:40.098
a millisecond might not to be
the same as the frame before.

00:37:40.098 --> 00:37:43.737
So 16 milliseconds, sometimes,
will be really hard to hit.

00:37:43.737 --> 00:37:46.320
You might also run into issues,
and that's an interesting one,

00:37:46.320 --> 00:37:50.110
where, if you optimized
your code too much,

00:37:50.110 --> 00:37:51.750
we're going to
slow down the CPU,

00:37:51.750 --> 00:37:53.740
so then your code is
going to run slower,

00:37:53.740 --> 00:37:57.410
and then you're not going to
be able to go fast enough.

00:37:57.410 --> 00:37:59.680
That happened to us before.

00:37:59.680 --> 00:38:02.630
And so, the system tries
to take that into account,

00:38:02.630 --> 00:38:07.750
but if you run into
that, well, good luck.

00:38:07.750 --> 00:38:10.220
CHET HAASE: Be scrappy,
avoid doing too much stuff.

00:38:10.220 --> 00:38:12.570
Complex view hierarchy is,
basically, the more views

00:38:12.570 --> 00:38:15.490
you have in there, the more
containers the deeper nested

00:38:15.490 --> 00:38:19.050
your hierarchy, the more stuff
we're doing on your behalf.

00:38:19.050 --> 00:38:21.260
Traversing, had to figure
out and validation, to do

00:38:21.260 --> 00:38:22.810
measure, and layout,
and all that stuff.

00:38:22.810 --> 00:38:24.510
ROMAIN GUY: And one of the--
so one of the worst things you

00:38:24.510 --> 00:38:26.181
can do, and this
is probably why we

00:38:26.181 --> 00:38:28.680
make that the default when you
create an activity in Android

00:38:28.680 --> 00:38:31.070
Studio is to use
a RelativeLayout

00:38:31.070 --> 00:38:32.160
at the top of your tree.

00:38:32.160 --> 00:38:33.680
[LAUGHTER]

00:38:33.680 --> 00:38:36.860
So if you go file a new
layout in Android Studio,

00:38:36.860 --> 00:38:39.927
just do select all, delete,
and start from scratch.

00:38:39.927 --> 00:38:41.760
CHET HAASE: Do you know
why we put it there?

00:38:41.760 --> 00:38:42.344
It's a test.

00:38:42.344 --> 00:38:43.010
ROMAIN GUY: Yes.

00:38:43.010 --> 00:38:44.660
[LAUGHTER]

00:38:44.660 --> 00:38:46.055
And you all failed it.

00:38:46.055 --> 00:38:48.793
[LAUGHTER]

00:38:48.793 --> 00:38:51.970
RelativeLayout in a lot
of cases, not all of them,

00:38:51.970 --> 00:38:53.707
will measure the children twice.

00:38:53.707 --> 00:38:56.040
And so, what happens when you
measure the children twice

00:38:56.040 --> 00:38:59.280
is that, some of those childrens
are view groups themselves,

00:38:59.280 --> 00:39:01.390
like LinearLayouts
or RelativeLayouts.

00:39:01.390 --> 00:39:04.872
And those cause their own
children to be measured twice,

00:39:04.872 --> 00:39:07.330
then those childrens have been
measured four times already.

00:39:07.330 --> 00:39:09.340
So we have some optimizations
in the framework

00:39:09.340 --> 00:39:11.550
to alleviate that issue.

00:39:11.550 --> 00:39:14.770
Especially starting with
KitKat, the optimizations

00:39:14.770 --> 00:39:16.200
have gotten a lot better.

00:39:16.200 --> 00:39:19.360
But you can imagine that, if
you have 10, 12, or 16 nested

00:39:19.360 --> 00:39:22.920
layouts, and every one of them
measures the children twice,

00:39:22.920 --> 00:39:25.190
you're going to spend a
lot of time doing your

00:39:25.190 --> 00:39:26.870
measuring your layout.

00:39:26.870 --> 00:39:29.662
So be careful with
RelativeLayout,

00:39:29.662 --> 00:39:30.370
and LinearLayout.

00:39:30.370 --> 00:39:34.830
If you use the weight attribute,
any child with a weight

00:39:34.830 --> 00:39:36.680
will be measured twice.

00:39:36.680 --> 00:39:39.490
So just be careful,
measure profile,

00:39:39.490 --> 00:39:42.100
and try to find a different
way of doing your layout

00:39:42.100 --> 00:39:43.120
if you can.

00:39:43.120 --> 00:39:45.450
CHET HAASE: Please launch
your activities fast.

00:39:45.450 --> 00:39:46.560
Present the UI quickly.

00:39:46.560 --> 00:39:48.851
So that's certainly the
purpose of the starting window,

00:39:48.851 --> 00:39:51.210
but it's also nice if you
can present the real content

00:39:51.210 --> 00:39:53.543
as quickly as possible so the
user is not sitting there,

00:39:53.543 --> 00:39:56.970
waiting for your amazing
cat video application.

00:39:56.970 --> 00:39:58.070
Defer extra work.

00:39:58.070 --> 00:40:01.130
We see a lot of activities
or application code

00:40:01.130 --> 00:40:03.400
that's doing a lot at start up.

00:40:03.400 --> 00:40:06.380
It has a static block where it's
initializing a bunch of stuff

00:40:06.380 --> 00:40:08.930
that it's going to
need eventually.

00:40:08.930 --> 00:40:10.262
Allocate it eventually, right?

00:40:10.262 --> 00:40:12.220
You don't have to do that
at start up, and make

00:40:12.220 --> 00:40:14.530
the user wait every time
they launch this thing.

00:40:14.530 --> 00:40:17.340
Instead, you can wait and do it
incrementally, as they actually

00:40:17.340 --> 00:40:18.727
need these things instead.

00:40:18.727 --> 00:40:20.560
ROMAIN GUY: Yeah, I can
give you one example

00:40:20.560 --> 00:40:23.910
of a the way the launcher
application, at least,

00:40:23.910 --> 00:40:24.524
used to work.

00:40:24.524 --> 00:40:26.190
I don't know about
the current launcher.

00:40:26.190 --> 00:40:29.650
But, back in the old days,
loading all the icons

00:40:29.650 --> 00:40:32.800
from this, from all APK's to
present the greed of icons

00:40:32.800 --> 00:40:35.520
was extremely expensive and
it took several seconds.

00:40:35.520 --> 00:40:39.320
So, what launcher was doing was,
loading three icons at a time.

00:40:39.320 --> 00:40:40.790
And after loading
three icons, it

00:40:40.790 --> 00:40:42.730
would post a message
in the UI queue

00:40:42.730 --> 00:40:45.204
to ask itself to go load
the next three icons.

00:40:45.204 --> 00:40:47.620
So, if you're fast enough, and
you open the grid of icons,

00:40:47.620 --> 00:40:50.824
you would see them be unloaded
by batches of three or six.

00:40:50.824 --> 00:40:52.240
But that was the
idea, so we could

00:40:52.240 --> 00:40:54.420
start the application
itself really quickly,

00:40:54.420 --> 00:40:55.770
under half a second.

00:40:55.770 --> 00:40:58.350
But then, it would keep
building it's own UI

00:40:58.350 --> 00:40:59.590
kind of under the hood.

00:40:59.590 --> 00:41:02.280
And, if you do it
right, a lot of it

00:41:02.280 --> 00:41:03.499
will be off screen, anyway.

00:41:03.499 --> 00:41:05.040
And, I'm sure, most
of you have never

00:41:05.040 --> 00:41:06.532
noticed that we are doing that.

00:41:06.532 --> 00:41:07.990
So, in a lot of
situations, you can

00:41:07.990 --> 00:41:11.250
try to use one of those tricks.

00:41:11.250 --> 00:41:14.500
CHET HAASE: Measure
cold start, so you

00:41:14.500 --> 00:41:17.000
want to figure out how long
it's taking for your application

00:41:17.000 --> 00:41:17.680
to launch.

00:41:17.680 --> 00:41:21.520
And then, work on that, optimize
it, make sure that it's faster

00:41:21.520 --> 00:41:22.769
than seven seconds.

00:41:22.769 --> 00:41:25.060
But then, how do you actually
verify that your work has

00:41:25.060 --> 00:41:26.580
been worth it?

00:41:26.580 --> 00:41:29.380
If you launch the application
and time that thing,

00:41:29.380 --> 00:41:32.110
and, actually, I posted
something on my blog

00:41:32.110 --> 00:41:34.300
recently, a couple
weeks ago, about ways

00:41:34.300 --> 00:41:37.140
that, basically, there's
a really helpful log,

00:41:37.140 --> 00:41:39.560
now, that will just tell you
how long this thing took.

00:41:39.560 --> 00:41:42.110
And then, some of the details
about that, I put on my blog,

00:41:42.110 --> 00:41:43.300
recently.

00:41:43.300 --> 00:41:46.732
Anyway, measure that on launch,
and see what that number is.

00:41:46.732 --> 00:41:48.565
And then, if you put
that in the background,

00:41:48.565 --> 00:41:50.476
and then you launch it
from the icon again,

00:41:50.476 --> 00:41:51.600
that's not the same number.

00:41:51.600 --> 00:41:52.876
That's called a warm start.

00:41:52.876 --> 00:41:54.500
Right, that activity
is already loaded.

00:41:54.500 --> 00:41:55.916
We're not actually
doing much work

00:41:55.916 --> 00:41:57.890
to bring it up when
it's still in memory,

00:41:57.890 --> 00:41:59.820
and still sort of running
in the background.

00:41:59.820 --> 00:42:01.150
So, instead, you
want to swipe it out.

00:42:01.150 --> 00:42:02.774
Just bring up recents
and swipe it out,

00:42:02.774 --> 00:42:04.860
and that will get you,
mostly, to the situation

00:42:04.860 --> 00:42:07.360
that you get on reboot, which
is running for the first time.

00:42:07.360 --> 00:42:08.890
Because that's really
what you want to measure.

00:42:08.890 --> 00:42:11.090
You want to measure
bringing in all your code,

00:42:11.090 --> 00:42:12.730
doing all your static
initialization,

00:42:12.730 --> 00:42:14.780
going through everything
that an activity does,

00:42:14.780 --> 00:42:16.989
every time it launches for
the first time after boot.

00:42:16.989 --> 00:42:19.571
ROMAIN GUY: And, once again, one
of the best tools you can use

00:42:19.571 --> 00:42:20.120
is Systrace.

00:42:20.120 --> 00:42:23.300
I remember, we once identified
an issue in the start

00:42:23.300 --> 00:42:24.870
up time of an application.

00:42:24.870 --> 00:42:26.929
And the interesting
thing that was happening

00:42:26.929 --> 00:42:28.720
was, the application
was using a background

00:42:28.720 --> 00:42:30.577
thread to offload
some of the work,

00:42:30.577 --> 00:42:31.660
to defer some of the work.

00:42:31.660 --> 00:42:33.070
But, at some point,
the UI thread

00:42:33.070 --> 00:42:35.290
needed the result from
that background thread.

00:42:35.290 --> 00:42:37.490
So the UI thread was
synchronizing on the background

00:42:37.490 --> 00:42:38.120
thread.

00:42:38.120 --> 00:42:39.828
But, by definition,
the background thread

00:42:39.828 --> 00:42:44.290
has a lower priority, so the
UI thread was mostly idle,

00:42:44.290 --> 00:42:47.450
waiting for lower priority
background thread to be done.

00:42:47.450 --> 00:42:49.845
So be careful with
that kind of issue.

00:42:49.845 --> 00:42:50.665
Use Systrace.

00:42:50.665 --> 00:42:52.290
Systrace will make
it very obvious when

00:42:52.290 --> 00:42:54.870
something like this happens.

00:42:54.870 --> 00:42:58.162
CHET HAASE: So some interaction
points to go over, allow

00:42:58.162 --> 00:43:00.120
the user to actually get
out of immersive mode,

00:43:00.120 --> 00:43:02.280
otherwise it's a
little frustrating.

00:43:02.280 --> 00:43:04.130
Immersive mode is
there for a reason,

00:43:04.130 --> 00:43:06.890
for full screen video
experiences or games,

00:43:06.890 --> 00:43:09.740
but it's also nice to actually
let the users out of the box,

00:43:09.740 --> 00:43:11.650
occasionally.

00:43:11.650 --> 00:43:14.170
So we've seen this, where
the starting window-- like

00:43:14.170 --> 00:43:16.840
when applications don't
disable the starting window,

00:43:16.840 --> 00:43:19.250
they don't necessarily do
the right thing with it.

00:43:19.250 --> 00:43:21.290
One of the worst
launch experiences

00:43:21.290 --> 00:43:23.570
I've seen from
several applications

00:43:23.570 --> 00:43:26.200
is, typically, a game
will have, like, they

00:43:26.200 --> 00:43:28.215
want to do their own
splash screen that's tuned

00:43:28.215 --> 00:43:29.340
to their application thing.

00:43:29.340 --> 00:43:30.590
So they have their
splash screen,

00:43:30.590 --> 00:43:32.430
and then they have their game
screen, which is quite a bit

00:43:32.430 --> 00:43:33.990
different from that,
you can sort of

00:43:33.990 --> 00:43:34.990
see how they're related.

00:43:34.990 --> 00:43:36.680
But, the best of
all is, they also

00:43:36.680 --> 00:43:38.607
have the starting
window, which has nothing

00:43:38.607 --> 00:43:39.690
to do with the other ones.

00:43:39.690 --> 00:43:41.820
So you get a starting
window up with some default

00:43:41.820 --> 00:43:43.770
theme that looks nothing
like the rest of the game.

00:43:43.770 --> 00:43:45.190
ROMAIN GUY: And, usually, in
games, the starting window

00:43:45.190 --> 00:43:46.760
you get is the
Gingerbread Starting

00:43:46.760 --> 00:43:49.760
Window, which is very sad.

00:43:49.760 --> 00:43:51.860
CHET HAASE: So don't
go with the sad window.

00:43:51.860 --> 00:43:54.380
So they'll bring up this one,
then, after three seconds,

00:43:54.380 --> 00:43:56.130
they'll bring out their
own splash screen,

00:43:56.130 --> 00:43:57.470
then they bring up their own.

00:43:57.470 --> 00:43:59.896
Much better to actually
set the information

00:43:59.896 --> 00:44:01.520
in the starting window
to actually look

00:44:01.520 --> 00:44:02.590
like the rest of
the application,

00:44:02.590 --> 00:44:04.298
whether it's the
status, or the nav bars,

00:44:04.298 --> 00:44:07.370
or just the themes and the
style attributes, overall.

00:44:07.370 --> 00:44:09.410
Just make it look like
it actually belongs.

00:44:09.410 --> 00:44:12.360
Or, even better, if you want
a splash screen experience,

00:44:12.360 --> 00:44:14.830
just tune the starting window
to be that splash screen

00:44:14.830 --> 00:44:15.950
experience instead.

00:44:15.950 --> 00:44:18.620
ROMAIN GUY: So, essentially,
when in your own create,

00:44:18.620 --> 00:44:21.780
you find yourself changing
styling, changing the title,

00:44:21.780 --> 00:44:23.220
the background of the window.

00:44:23.220 --> 00:44:25.410
You probably want to
do that from the theme,

00:44:25.410 --> 00:44:27.099
instead, in your manifest.

00:44:27.099 --> 00:44:29.390
There are sometimes good
reason to do it in [INAUDIBLE]

00:44:29.390 --> 00:44:32.560
because you're computing
data, but, every time you can,

00:44:32.560 --> 00:44:34.060
do it in XML instead,
and you'll get

00:44:34.060 --> 00:44:36.460
the correct starting window.

00:44:36.460 --> 00:44:38.350
CHET HAASE: Cache
your data locally.

00:44:38.350 --> 00:44:41.329
So don't make it necessary
to go back to the server

00:44:41.329 --> 00:44:42.620
and get that information again.

00:44:42.620 --> 00:44:45.510
We saw a demonstration
of this in Adam

00:44:45.510 --> 00:44:47.110
and [INAUDIBLE]
talk from yesterday.

00:44:47.110 --> 00:44:48.480
So, if you're going to
get that information,

00:44:48.480 --> 00:44:49.770
you went to a lot of
trouble to get it,

00:44:49.770 --> 00:44:51.561
wouldn't it be nice if
you kept it locally,

00:44:51.561 --> 00:44:54.424
so that, if a user goes back
to that information again,

00:44:54.424 --> 00:44:56.340
we don't have to make
another query across it.

00:44:56.340 --> 00:44:58.310
And also, cache
the input locally.

00:44:58.310 --> 00:45:01.360
So, if the user has input some
information into the system,

00:45:01.360 --> 00:45:03.070
make sure that you
retain that, so that,

00:45:03.070 --> 00:45:05.680
if there is something later that
depends on that information,

00:45:05.680 --> 00:45:08.610
we haven't simply
lost it along the way.

00:45:08.610 --> 00:45:12.817
We have exactly 20 seconds to
go and about 12 more slides,

00:45:12.817 --> 00:45:14.650
each of which is going
to take five minutes.

00:45:14.650 --> 00:45:17.180
ROMAIN GUY: So the fewer slides
we put in our presentations,

00:45:17.180 --> 00:45:18.795
the longer we talk
about each slide.

00:45:18.795 --> 00:45:21.410
So, next time we'll
have one slide.

00:45:21.410 --> 00:45:23.790
CHET HAASE: I think we'll
call it a day there.

00:45:23.790 --> 00:45:24.530
Thanks very much.

00:45:24.530 --> 00:45:26.960
We'll be outside, if
you have any questions.

00:45:26.960 --> 00:45:30.910
[MUSIC PLAYING]

