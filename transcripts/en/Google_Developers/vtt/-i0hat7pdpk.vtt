WEBVTT
Kind: captions
Language: en

00:00:06.060 --> 00:00:08.600
ROB PIKE: Hi everybody.

00:00:08.600 --> 00:00:10.250
Well, thanks for coming.

00:00:10.250 --> 00:00:13.840
We've got some important things
to talk about today.

00:00:13.840 --> 00:00:16.040
This session is called Writing
Web Apps in Go.

00:00:16.040 --> 00:00:17.930
My name is Rob Pike, I'm
presenting with Andrew

00:00:17.930 --> 00:00:21.440
Gerrand, and we're both members
of the Go team at

00:00:21.440 --> 00:00:24.460
Google in Mountain View
and in Sydney.

00:00:24.460 --> 00:00:26.960
During this session, if you have
feedback you'd like to

00:00:26.960 --> 00:00:30.280
give, or other items you'd like
to talk about, there's a

00:00:30.280 --> 00:00:32.140
link to the--

00:00:32.140 --> 00:00:34.580
the short link will give you
a site for feedback.

00:00:34.580 --> 00:00:37.120
And then, here's a couple
of hash tags that you

00:00:37.120 --> 00:00:38.210
might want to use.

00:00:38.210 --> 00:00:40.240
But you could also use
the golang hash tag,

00:00:40.240 --> 00:00:43.520
we won't get mad.

00:00:43.520 --> 00:00:47.660
So some of you might not know
what Go is exactly.

00:00:47.660 --> 00:00:49.320
So I thought we'd spend just
a couple of minutes talking

00:00:49.320 --> 00:00:51.400
about that.

00:00:51.400 --> 00:00:55.460
Go is a programming language
for the world of today.

00:00:55.460 --> 00:00:58.370
If you look at what happened
in the last 20 years or so,

00:00:58.370 --> 00:01:00.960
the computing environment has
changed a lot, and not all the

00:01:00.960 --> 00:01:03.040
languages have really
kept pace.

00:01:03.040 --> 00:01:07.120
So Go is designed inside Google
to be a fun, efficient

00:01:07.120 --> 00:01:09.960
and productive way to write
kind of software

00:01:09.960 --> 00:01:11.290
that we write at Google.

00:01:11.290 --> 00:01:14.090
Which mostly means things in the
manner of web servers and

00:01:14.090 --> 00:01:15.130
things like that.

00:01:15.130 --> 00:01:16.710
Most importantly of all
though, it's an

00:01:16.710 --> 00:01:17.610
open sourced language.

00:01:17.610 --> 00:01:19.600
Everything about it is
done in the open.

00:01:19.600 --> 00:01:23.010
It is not a proprietary thing
in any important way.

00:01:23.010 --> 00:01:26.070
It launched in November 2009 and
it had the goals of being

00:01:26.070 --> 00:01:29.930
fun to work in, efficient,
scalable, and very, very

00:01:29.930 --> 00:01:30.950
productive.

00:01:30.950 --> 00:01:33.550
And as I said, we designed it
for web servers, but it sort

00:01:33.550 --> 00:01:35.790
of works really well for
just about anything.

00:01:35.790 --> 00:01:37.400
Which is a bit of a
surprise to us.

00:01:37.400 --> 00:01:39.550
And so we now prefer to just
call it a good, general

00:01:39.550 --> 00:01:41.270
purpose language.

00:01:41.270 --> 00:01:43.320
And there are contributors now
from all around the world

00:01:43.320 --> 00:01:44.700
working on it.

00:01:44.700 --> 00:01:48.970
So today, I'm going to talk a
little bit what's go on since

00:01:48.970 --> 00:01:51.230
the last talk at IO
over a year ago.

00:01:51.230 --> 00:01:53.760
We're going to show you a web
server that's written in Go

00:01:53.760 --> 00:01:56.100
and how to deploy Go
in production.

00:01:56.100 --> 00:01:59.460
You might know a little bit
about what that's about today.

00:01:59.460 --> 00:02:01.420
We assume you know a little
bit about how to write web

00:02:01.420 --> 00:02:03.380
servers, maybe a little
bit about Go, but

00:02:03.380 --> 00:02:04.640
it's not totally important.

00:02:04.640 --> 00:02:06.680
You'll get the gist of it even
if you're completely new to

00:02:06.680 --> 00:02:07.690
the language.

00:02:07.690 --> 00:02:09.190
We've got some big
announcements, some of which

00:02:09.190 --> 00:02:11.850
have already leaked, which
is fine with us.

00:02:11.850 --> 00:02:13.790
And there's some
giveaways too.

00:02:13.790 --> 00:02:16.170
Last year we giveaway t-shirts,
maybe we'll give

00:02:16.170 --> 00:02:17.510
something else away today.

00:02:17.510 --> 00:02:19.860
So be sure to stick around to
the end when all the fun

00:02:19.860 --> 00:02:21.320
really comes together.

00:02:21.320 --> 00:02:23.580
So what's happened
in the past year?

00:02:23.580 --> 00:02:25.750
It's been a really
big year for Go.

00:02:25.750 --> 00:02:27.390
Tons of stuff happened.

00:02:27.390 --> 00:02:29.980
Perhaps the biggest news of
all has been that it's now

00:02:29.980 --> 00:02:33.990
supported on Windows, entirely
through the efforts of an open

00:02:33.990 --> 00:02:34.550
source community.

00:02:34.550 --> 00:02:37.840
We did none of this work
internally on the team at

00:02:37.840 --> 00:02:40.560
Google, which is very, very
satisfying for us.

00:02:40.560 --> 00:02:42.780
There's also a couple of
external application--

00:02:42.780 --> 00:02:45.160
sorry, external compilers
that have been done.

00:02:45.160 --> 00:02:47.380
There's a compiler in the works
called Ergo, and there's

00:02:47.380 --> 00:02:52.890
also an interpreter with JIT
that runs on Windows and is

00:02:52.890 --> 00:02:54.480
now starting to support .net.

00:02:54.480 --> 00:02:55.230
It's called Express Go.

00:02:55.230 --> 00:02:57.800
We're really excited
about that.

00:02:57.800 --> 00:03:00.310
Our own internal port
for the ARM is now

00:03:00.310 --> 00:03:01.530
very solid and available.

00:03:01.530 --> 00:03:04.770
It works on all kinds of phones
and things like that.

00:03:04.770 --> 00:03:07.890
GCC4.6, that release
includes GCC Go

00:03:07.890 --> 00:03:08.665
as an official language.

00:03:08.665 --> 00:03:12.970
It's included with things like
Ubuntu and stuff like that.

00:03:12.970 --> 00:03:15.330
There's SWIG support and
on and on and on.

00:03:15.330 --> 00:03:17.630
For those of us who write code
for a living, it's nice to be

00:03:17.630 --> 00:03:20.950
able to say that GDB is now well
supported or Go is now

00:03:20.950 --> 00:03:22.510
well supported by GDB.

00:03:22.510 --> 00:03:24.350
And here's a sort
of silly trace.

00:03:24.350 --> 00:03:27.390
It's kind of hard to show a
GDB slide that's not just

00:03:27.390 --> 00:03:28.380
modem noise.

00:03:28.380 --> 00:03:30.590
But you can see--

00:03:30.590 --> 00:03:31.660
do you know what modems are?

00:03:31.660 --> 00:03:34.240
Are you guys too young?

00:03:34.240 --> 00:03:37.960
You guys will recognize things
like the run time knowing

00:03:37.960 --> 00:03:41.660
about Go routines and you can
talk about threads, as well as

00:03:41.660 --> 00:03:42.840
Go routines and channels.

00:03:42.840 --> 00:03:44.460
And it's really quite nice.

00:03:44.460 --> 00:03:46.590
It's all symbolic debugging
now in GDB.

00:03:46.590 --> 00:03:49.790
And that's also getting
better all the time.

00:03:49.790 --> 00:03:51.890
In the past year, the language
has simplified.

00:03:51.890 --> 00:03:54.730
Unlike some other languages we
could name, we'd like to keep

00:03:54.730 --> 00:03:56.170
Go really clean and simple.

00:03:56.170 --> 00:03:58.370
And to that end, we've actually
removed some things

00:03:58.370 --> 00:04:00.100
from the language in order to
make the language better,

00:04:00.100 --> 00:04:01.790
which I think is a sign
of the kind of stuff

00:04:01.790 --> 00:04:02.840
we really care about.

00:04:02.840 --> 00:04:04.580
But the language actually gets
better through doing this.

00:04:04.580 --> 00:04:07.540
So non-blocking communication
operations went away because

00:04:07.540 --> 00:04:09.160
they were confusing
semantically.

00:04:09.160 --> 00:04:12.080
And it turns out the select
statement can provide all you

00:04:12.080 --> 00:04:13.760
need there anyway.

00:04:13.760 --> 00:04:16.420
We got rid of the closed
built-in because people tended

00:04:16.420 --> 00:04:17.300
to misuse it.

00:04:17.300 --> 00:04:20.589
It was very subtle to use
well and veru racy.

00:04:20.589 --> 00:04:23.710
We clarified the type sizes
for floats and complexes,

00:04:23.710 --> 00:04:24.910
which simplified some--

00:04:24.910 --> 00:04:27.430
made the math libraries
much nicer to use.

00:04:27.430 --> 00:04:28.880
Slices got simpler.

00:04:28.880 --> 00:04:31.000
The dot dot dot thing, which
is how you do variadics

00:04:31.000 --> 00:04:33.050
actually got a lot nicer.

00:04:33.050 --> 00:04:35.500
And we also put in an append
built-in, which clarified a

00:04:35.500 --> 00:04:36.210
lot of code.

00:04:36.210 --> 00:04:37.900
Comps and literals got
easier to type.

00:04:37.900 --> 00:04:41.130
But basically, the thing just
got sort of more regular and I

00:04:41.130 --> 00:04:42.260
think a lot cleaner.

00:04:42.260 --> 00:04:44.410
And it continues to develop.

00:04:44.410 --> 00:04:48.070
As I mentioned many times, it's
entirely open source.

00:04:48.070 --> 00:04:49.620
I mentioned the Windows port.

00:04:49.620 --> 00:04:51.620
We've had over a thousand
contributions from more than

00:04:51.620 --> 00:04:54.000
130 people around the world.

00:04:54.000 --> 00:04:56.980
We won a best of open source
award from InfoWorld, which

00:04:56.980 --> 00:04:58.150
was really nice.

00:04:58.150 --> 00:05:00.480
And I think what really pleased
me about this award

00:05:00.480 --> 00:05:03.220
was besides getting the award,
the citation really seems to

00:05:03.220 --> 00:05:05.350
understand what it is that
Go is trying to do.

00:05:05.350 --> 00:05:08.590
So it was very satisfying.

00:05:08.590 --> 00:05:09.030
Now.

00:05:09.030 --> 00:05:12.530
When we first launched Go in
November of 2009, we called it

00:05:12.530 --> 00:05:13.590
a systems language.

00:05:13.590 --> 00:05:16.210
And that seemed to
confuse people.

00:05:16.210 --> 00:05:18.140
People seemed to think that
means it's for writing really

00:05:18.140 --> 00:05:21.240
low-level, grungy code,
operating systems, maybe file

00:05:21.240 --> 00:05:22.500
systems, things like that.

00:05:22.500 --> 00:05:24.550
And I think Go is an interesting
language to do

00:05:24.550 --> 00:05:26.550
those in, but we had
a somewhat higher

00:05:26.550 --> 00:05:28.030
level, grander idea.

00:05:28.030 --> 00:05:31.190
It really was for the kind of
software we write at Google.

00:05:31.190 --> 00:05:34.070
But as I said before, it was a
bit of a surprise to us that

00:05:34.070 --> 00:05:36.260
it turned out to be a great
general purpose language.

00:05:36.260 --> 00:05:39.110
And people have been using it
to do a lot of scripting, a

00:05:39.110 --> 00:05:42.920
lot of sort of administrative
stuff, and various things that

00:05:42.920 --> 00:05:44.150
we really didn't have in mind.

00:05:44.150 --> 00:05:45.920
But it's turns out
to be good for.

00:05:45.920 --> 00:05:50.080
That said, it's still really
good for writing systems code,

00:05:50.080 --> 00:05:52.645
like web servers such as
the one that Andrew

00:05:52.645 --> 00:05:55.040
will now show you.

00:05:55.040 --> 00:05:55.890
Andrew.

00:05:55.890 --> 00:05:57.140
[APPLAUSE]

00:06:09.650 --> 00:06:11.900
ANDREW GERRAND: So my name's
Andrew and I'm going to show

00:06:11.900 --> 00:06:17.060
you the development of a
complete web application

00:06:17.060 --> 00:06:18.120
called Moustachio.

00:06:18.120 --> 00:06:22.560
And Moustachio is our bid into
this burgeoning market of

00:06:22.560 --> 00:06:24.490
photo and image sharing.

00:06:24.490 --> 00:06:28.040
Good way to get venture
capital I hear.

00:06:28.040 --> 00:06:31.610
The core functionality of this
program is the ability to

00:06:31.610 --> 00:06:34.360
upload an image or a photograph,
to draw a

00:06:34.360 --> 00:06:37.210
moustache on that photograph,
and then to share

00:06:37.210 --> 00:06:38.460
it with your friends.

00:06:41.100 --> 00:06:45.500
In this way, I hope to
demonstrate how Go shines at

00:06:45.500 --> 00:06:49.580
serving web pages in templated
HTML, handling file uploads,

00:06:49.580 --> 00:06:53.400
working with the file system,
and importantly, manipulating

00:06:53.400 --> 00:06:55.900
and decoding and encoding
images.

00:06:55.900 --> 00:06:58.410
And we'll also show
interacting with

00:06:58.410 --> 00:06:59.660
OAuth-authenticated APIs.

00:07:02.460 --> 00:07:07.130
So this is the simple
hello web server.

00:07:07.130 --> 00:07:13.470
If you access this web server on
port 8080 you will see the

00:07:13.470 --> 00:07:14.800
string hello world.

00:07:14.800 --> 00:07:16.790
And so the way this works
is we import the string

00:07:16.790 --> 00:07:20.800
formatting in HTTP packages,
we define an HTTP handler.

00:07:20.800 --> 00:07:23.970
And what the handler does is
simply write the string hello

00:07:23.970 --> 00:07:27.700
world to the HTTP response
writer and that sends that

00:07:27.700 --> 00:07:29.870
string as the HTTP response.

00:07:29.870 --> 00:07:33.590
And then in our main function,
we have a handle func call,

00:07:33.590 --> 00:07:37.490
which registers that handler
to our web root.

00:07:37.490 --> 00:07:40.000
And then a listen and serve call
to actually set up and

00:07:40.000 --> 00:07:42.840
run the web server.

00:07:42.840 --> 00:07:47.520
And so the beginning of our
Moustachio program will simply

00:07:47.520 --> 00:07:50.100
handle a file upload and show
the image to the user.

00:07:50.100 --> 00:07:54.900
And this is the request and
response flow of that process.

00:07:54.900 --> 00:07:58.115
So initially, when the user
visits Moustachio, they issue

00:07:58.115 --> 00:08:00.670
a get request and the
upload handler will

00:08:00.670 --> 00:08:02.260
serve them a form.

00:08:02.260 --> 00:08:07.260
And the form will include a file
input field, and then the

00:08:07.260 --> 00:08:10.170
user will post an image back
to the upload handler.

00:08:10.170 --> 00:08:13.200
And the upload handler will
save the image to disk,

00:08:13.200 --> 00:08:17.750
redirect them to /view with the
image ID, and then when

00:08:17.750 --> 00:08:20.160
the user requests /view, the
view handler will serve them

00:08:20.160 --> 00:08:22.070
the image data proper.

00:08:22.070 --> 00:08:24.610
So here's our simple
HTML form.

00:08:24.610 --> 00:08:26.630
I imagine it's familiar
to most of you.

00:08:26.630 --> 00:08:31.710
It's just a simple HTML form
with multi-platform data

00:08:31.710 --> 00:08:37.510
encoding type and a file
field named image.

00:08:37.510 --> 00:08:41.250
And so to create an upload
handler that displays that

00:08:41.250 --> 00:08:46.070
form, what we'll do is import
the template package and as a

00:08:46.070 --> 00:08:49.800
global variable, create the
variable upload template,

00:08:49.800 --> 00:08:52.015
which is the result of
calling must pass

00:08:52.015 --> 00:08:53.860
file on that template.

00:08:53.860 --> 00:08:58.680
So in our new upload handler, we
can call the execute method

00:08:58.680 --> 00:09:01.830
on that template to actually
write the template out as the

00:09:01.830 --> 00:09:03.790
HTTP response.

00:09:03.790 --> 00:09:06.415
And then in our main function,
we registered that handler to

00:09:06.415 --> 00:09:08.580
the web root.

00:09:08.580 --> 00:09:13.270
And now we need to expand that
upload handler to also

00:09:13.270 --> 00:09:16.440
accommodate handling
the uploaded file.

00:09:16.440 --> 00:09:20.820
So our original code for the
upload handler is still there

00:09:20.820 --> 00:09:24.095
under this if statement, if
method is not equal to post.

00:09:24.095 --> 00:09:26.090
So if they've just done
a get request, we

00:09:26.090 --> 00:09:27.300
serve them the form.

00:09:27.300 --> 00:09:31.050
If not we're handling a post
request. And so we pull the

00:09:31.050 --> 00:09:34.060
form file out of the HTTP
request, and then we open a

00:09:34.060 --> 00:09:36.160
temporary file using the
temp file function

00:09:36.160 --> 00:09:37.770
from the iUtil package.

00:09:37.770 --> 00:09:43.030
And then we copy the contents
of that form file upload to

00:09:43.030 --> 00:09:46.850
our temporary file, and then
redirect the user to /view

00:09:46.850 --> 00:09:49.990
with the name, the automatically
assigned name of

00:09:49.990 --> 00:09:51.530
that temporary file.

00:09:51.530 --> 00:09:55.320
And so one thing that is
important to notice here is

00:09:55.320 --> 00:09:58.040
that there's a lot of error
handling in this slide.

00:09:58.040 --> 00:10:00.300
And in Go we consider error
handling to be very important

00:10:00.300 --> 00:10:03.560
because unhandled errors
lead to bugs.

00:10:03.560 --> 00:10:05.720
But it doesn't have to
be this verbose.

00:10:05.720 --> 00:10:08.300
And so let's look at a
way of just cleaning

00:10:08.300 --> 00:10:10.290
up the error handling.

00:10:10.290 --> 00:10:12.910
We can clean it up a bit by
creating an error handler

00:10:12.910 --> 00:10:19.310
function that wraps our HTTP
handler and returns a new HTTP

00:10:19.310 --> 00:10:23.400
handler that will catch errors
effectively, and display a

00:10:23.400 --> 00:10:27.870
nice HTML page with
an error message.

00:10:27.870 --> 00:10:30.130
And so that's what this error
handler function does.

00:10:30.130 --> 00:10:32.450
It has a corresponding
error template.

00:10:32.450 --> 00:10:34.780
And in the same style as
the upload template.

00:10:34.780 --> 00:10:37.845
And then the important part here
is on this first line of

00:10:37.845 --> 00:10:39.520
the main function.

00:10:39.520 --> 00:10:42.450
We now wrap the upload function
with our error

00:10:42.450 --> 00:10:44.250
handler function.

00:10:44.250 --> 00:10:48.160
And then we modify our upload
function to use this new check

00:10:48.160 --> 00:10:52.370
function, which will panic if it
encounters an error, which

00:10:52.370 --> 00:10:55.040
will then be caught by
the error handler.

00:10:55.040 --> 00:10:57.530
And so you can see that compared
to a couple of slides

00:10:57.530 --> 00:11:00.520
ago, the error handling
is much simpler.

00:11:00.520 --> 00:11:05.060
Is just cause to check
parting in the error.

00:11:05.060 --> 00:11:08.740
And so now we need to define
a handler view to

00:11:08.740 --> 00:11:10.160
actually serve our image.

00:11:10.160 --> 00:11:13.470
And that will simply set the
content type to image so the

00:11:13.470 --> 00:11:15.220
browser will display
it as an image.

00:11:15.220 --> 00:11:17.960
And then call the serve file
helper to read the file from

00:11:17.960 --> 00:11:21.370
disk and write it to
the HTTP response.

00:11:21.370 --> 00:11:25.140
And then we need to add it with
handle func to our HTTP

00:11:25.140 --> 00:11:26.510
[? muxer. ?]

00:11:26.510 --> 00:11:30.590
And so I can demonstrate this
in action for you now.

00:11:30.590 --> 00:11:34.380
If I just running locally
on my machine.

00:11:39.570 --> 00:11:41.330
I'll upload an image.

00:11:41.330 --> 00:11:43.420
And there it is being
served back to me.

00:11:43.420 --> 00:11:44.670
My little friend here.

00:11:48.960 --> 00:11:50.210
So now let's talk about
moustaches.

00:11:52.890 --> 00:11:56.460
To draw our moustache, we're
going to use the freetype-go

00:11:56.460 --> 00:11:59.520
library, which is the Go
implementation of the FreeType

00:11:59.520 --> 00:12:01.870
font rendering library.

00:12:01.870 --> 00:12:03.690
And it has a rasterization
package

00:12:03.690 --> 00:12:05.540
called raster that draws--

00:12:05.540 --> 00:12:08.580
gives us anti-aliased curve
drawing primitives.

00:12:08.580 --> 00:12:11.830
And to use this library we
install it with Goinstall,

00:12:11.830 --> 00:12:14.280
which is out part of the
Go distribution.

00:12:14.280 --> 00:12:16.630
It's a tool for automatically
downloading and

00:12:16.630 --> 00:12:19.220
installing Go libraries.

00:12:19.220 --> 00:12:21.440
And we use goinstall
to install it.

00:12:21.440 --> 00:12:24.370
And once that's done, we can
import the package from the

00:12:24.370 --> 00:12:27.200
same name that we Go installed
it from, which is nice and

00:12:27.200 --> 00:12:28.090
convenient.

00:12:28.090 --> 00:12:31.230
And so to actually draw our
moustache, we'll use three

00:12:31.230 --> 00:12:32.920
Bezier curves.

00:12:32.920 --> 00:12:36.810
And we'll allow the user to
control the droop factor of

00:12:36.810 --> 00:12:41.310
the moustache by moving some
of the control points.

00:12:41.310 --> 00:12:43.860
And so the function to actually
draw the moustache

00:12:43.860 --> 00:12:44.560
looks like this.

00:12:44.560 --> 00:12:47.060
This is the first half.

00:12:47.060 --> 00:12:52.950
It takes an image.image, which
is Go's internal image format.

00:12:52.950 --> 00:12:55.000
Or part of the standard
library rather.

00:12:55.000 --> 00:12:59.910
It takes x and y coordinates for
the moustache, a size for

00:12:59.910 --> 00:13:02.250
the moustache, and the droop
factor for the moustache are

00:13:02.250 --> 00:13:04.720
very important.

00:13:04.720 --> 00:13:08.510
And at the top of this function
we've set up the

00:13:08.510 --> 00:13:12.590
rasterizer to paint onto our
image and set up a new

00:13:12.590 --> 00:13:13.590
rasterizer.

00:13:13.590 --> 00:13:17.950
And then this block of
essentially, just mathematics

00:13:17.950 --> 00:13:20.230
to define each of the control
points involved

00:13:20.230 --> 00:13:21.890
in drawing the moustache.

00:13:21.890 --> 00:13:24.060
It should be kind of familiar to
anybody who does any fixed

00:13:24.060 --> 00:13:26.660
programming I guess.

00:13:26.660 --> 00:13:30.970
And then on the next slide, we
actually draw the three curves

00:13:30.970 --> 00:13:33.650
from the left, around to the
right, and back down again.

00:13:33.650 --> 00:13:35.880
And at the bottom of the
function, we call rasterizer

00:13:35.880 --> 00:13:37.740
to actually draw to our image.

00:13:37.740 --> 00:13:39.230
And then we return the
resulting image.

00:13:39.230 --> 00:13:44.050
But there's one little detail
about that function that I

00:13:44.050 --> 00:13:44.720
haven't discussed.

00:13:44.720 --> 00:13:48.650
And that is that an image.image
value is an

00:13:48.650 --> 00:13:52.120
interface type in Go, which
means that it can represent

00:13:52.120 --> 00:13:54.420
any type of image.

00:13:54.420 --> 00:13:58.360
And that's appropriate in this
case because a user can upload

00:13:58.360 --> 00:13:59.150
any [INAUDIBLE],

00:13:59.150 --> 00:14:00.500
kind of valid image.

00:14:00.500 --> 00:14:04.140
And that might be in a variety
of different color spaces.

00:14:04.140 --> 00:14:06.940
It might be RGBA or a greyscale,
or a fixed-palette

00:14:06.940 --> 00:14:10.400
GIF file and so on.

00:14:10.400 --> 00:14:14.350
But the raster library works
best when it's used with an

00:14:14.350 --> 00:14:15.370
RGBA image.

00:14:15.370 --> 00:14:16.720
It's much easier to set up.

00:14:16.720 --> 00:14:19.290
And so at the top of the
moustache function, I have

00:14:19.290 --> 00:14:21.530
this call to the
function RGBA.

00:14:21.530 --> 00:14:26.810
And it passes in the provided
image and returns an RGBA

00:14:26.810 --> 00:14:28.570
version of that image.

00:14:28.570 --> 00:14:32.640
So let's take a look at how that
function actually works.

00:14:32.640 --> 00:14:36.410
The RGBA function first,
performs a type assertion.

00:14:36.410 --> 00:14:40.390
That's this first line of code
in the function there.

00:14:40.390 --> 00:14:43.250
But what this assertion is doing
is asking the interface,

00:14:43.250 --> 00:14:47.370
is your underlying concrete
type an RGBA image?

00:14:47.370 --> 00:14:53.550
And if it is, then this means
that we can just return that

00:14:53.550 --> 00:14:55.900
concrete type, we don't have to
do anymore processing, and

00:14:55.900 --> 00:14:58.470
that's the fast path
through here.

00:14:58.470 --> 00:15:02.780
Otherwise, we create a new
RGBA image and use the

00:15:02.780 --> 00:15:07.590
draw.draw function to actually
draw the existing image to our

00:15:07.590 --> 00:15:08.930
new RGBA image.

00:15:08.930 --> 00:15:10.880
And then return it.

00:15:10.880 --> 00:15:14.240
So this is a very idiomatic
way of introspecting into

00:15:14.240 --> 00:15:15.530
interfaces.

00:15:15.530 --> 00:15:20.140
It becomes very handy in
a lot of situations.

00:15:20.140 --> 00:15:23.470
So now that we have our
moustache drawing function,

00:15:23.470 --> 00:15:26.850
there's the matter of
integrating that function with

00:15:26.850 --> 00:15:31.990
the rest of our HTTP flow.

00:15:31.990 --> 00:15:38.270
So the first part of this
diagram is the same as in the

00:15:38.270 --> 00:15:39.660
first example.

00:15:39.660 --> 00:15:41.940
But then, instead of redirecting
to a view handler

00:15:41.940 --> 00:15:44.250
to simply view the image, we're

00:15:44.250 --> 00:15:46.260
redirecting to an edit handler.

00:15:46.260 --> 00:15:49.180
And this edit handler will
display an HTML page, which

00:15:49.180 --> 00:15:53.730
includes some JavaScript and
that JavaScript will provide

00:15:53.730 --> 00:15:57.500
edit controls and allow you to
place the moustache on the

00:15:57.500 --> 00:15:58.580
image and adjust it.

00:15:58.580 --> 00:16:01.980
And with each time you adjust
the image, adjust the

00:16:01.980 --> 00:16:05.690
moustache and move it around,
the image tag that shows that

00:16:05.690 --> 00:16:09.580
image will be updated to include
a new query string

00:16:09.580 --> 00:16:13.730
with these x, y, s and d
parameters to signify which

00:16:13.730 --> 00:16:17.200
parts of the image
should be shown.

00:16:17.200 --> 00:16:19.010
Where the moustache on the
image should be drawn.

00:16:19.010 --> 00:16:21.970
And then the image handler
will actually draw the

00:16:21.970 --> 00:16:23.980
moustache and return
that image.

00:16:23.980 --> 00:16:26.420
And so we're doing all of the
rendering of this moustache on

00:16:26.420 --> 00:16:30.840
the server side, but updating
it in real time.

00:16:30.840 --> 00:16:32.590
So the edit handler
is very simple.

00:16:32.590 --> 00:16:36.220
It's much like the first vision
of our upload handler.

00:16:36.220 --> 00:16:40.970
We just set up an edit template
reading edit.HTML.

00:16:40.970 --> 00:16:47.095
And the one difference is we
pass in the ID from our

00:16:47.095 --> 00:16:51.440
queries using the form value
method on request. So that the

00:16:51.440 --> 00:16:55.060
JavaScript can know which image
ID it's referring to

00:16:55.060 --> 00:16:56.970
when it's drawing the
image on the screen.

00:16:59.500 --> 00:17:03.410
And our image function
first opens the

00:17:03.410 --> 00:17:05.589
relevant file, image file.

00:17:05.589 --> 00:17:09.300
It decodes that image, then
it pulls the x, y, s and d

00:17:09.300 --> 00:17:13.760
parameters from the query
request. And then uses the

00:17:13.760 --> 00:17:16.280
moustache function to
draw on the image.

00:17:16.280 --> 00:17:18.940
And then it will serve the
resulting image as an encoded

00:17:18.940 --> 00:17:22.940
JPEG at the bottom
of that function.

00:17:22.940 --> 00:17:25.520
You see this is kind of a bit
repetitive and kind of

00:17:25.520 --> 00:17:26.890
unnecessarily verbose.

00:17:26.890 --> 00:17:28.810
We can sort of clean that up a
bit and make it a bit more

00:17:28.810 --> 00:17:31.730
general by just using
a helper closure.

00:17:31.730 --> 00:17:34.720
And we did find this closer
v, that takes a string and

00:17:34.720 --> 00:17:35.510
returns an integer.

00:17:35.510 --> 00:17:36.910
And that does the string
conversion

00:17:36.910 --> 00:17:39.570
from strings to ints.

00:17:39.570 --> 00:17:41.190
And this is necessary
because Go is

00:17:41.190 --> 00:17:43.160
aesthetically typed language.

00:17:43.160 --> 00:17:48.855
And so when we call moustache
and we use v of

00:17:48.855 --> 00:17:50.130
x, v of y, et cetera.

00:17:52.780 --> 00:17:54.770
So I'll just demo that now.

00:17:54.770 --> 00:17:56.020
The fun part.

00:18:01.500 --> 00:18:03.790
Upload our image, again.

00:18:03.790 --> 00:18:05.910
Now we actually have the
edit controls in place.

00:18:05.910 --> 00:18:07.730
I can place the moustache.

00:18:07.730 --> 00:18:10.700
And you'll see as I place the
moustache, as I move it

00:18:10.700 --> 00:18:15.160
around, here the image
query string changes.

00:18:15.160 --> 00:18:19.810
I can adjust the size, make it
big and bushy, or a little bit

00:18:19.810 --> 00:18:22.570
more sort of thin
and dignified.

00:18:22.570 --> 00:18:27.130
And also, adjust the droop
factor, the all-important.

00:18:27.130 --> 00:18:28.990
You can kind of go a little bit
extreme if you want, or

00:18:28.990 --> 00:18:30.460
all the way.

00:18:30.460 --> 00:18:34.335
I think it's a happy occasion,
so I"ll make it slightly

00:18:34.335 --> 00:18:35.585
upturned gentlemen.

00:18:38.670 --> 00:18:41.590
So now that we've drawn our
moustache, it's time to move

00:18:41.590 --> 00:18:44.755
on to sharing this hilarious
image with all of our friends.

00:18:49.230 --> 00:18:52.450
So this is the latter part
of the HTTP flow.

00:18:52.450 --> 00:18:56.420
From our edit.HTML template, and
we'll have a share link,

00:18:56.420 --> 00:19:00.570
which you might have seen when
I was demoing just then.

00:19:00.570 --> 00:19:06.330
And that share link will link
to the /share handler and

00:19:06.330 --> 00:19:12.020
passes in all the definition of
that image with moustache

00:19:12.020 --> 00:19:14.480
to the share handler.

00:19:14.480 --> 00:19:18.910
And the share handler creates
a redirect URL to Google's

00:19:18.910 --> 00:19:20.760
OAuth service.

00:19:20.760 --> 00:19:22.230
And if you're familiar with
OAuth service, this should

00:19:22.230 --> 00:19:24.140
make sense to you.

00:19:24.140 --> 00:19:27.680
And I hope it makes sense
to you regardless.

00:19:27.680 --> 00:19:29.810
And the share handler redirects
you to Google's

00:19:29.810 --> 00:19:33.770
OAuth service, and then the user
will perform the little

00:19:33.770 --> 00:19:37.190
authentication and permission
granting dance with Google's

00:19:37.190 --> 00:19:40.010
OAuth server, which usually
means logging in and clicking

00:19:40.010 --> 00:19:41.310
an accept button.

00:19:41.310 --> 00:19:44.150
And then the OAuth service
redirects the user back to our

00:19:44.150 --> 00:19:48.430
Moustachio App to /post, which
is our post handler.

00:19:48.430 --> 00:19:52.580
And it passes in an
authentication code and the

00:19:52.580 --> 00:19:53.590
image stayed.

00:19:53.590 --> 00:19:57.400
Which is those query parameters
from before.

00:19:57.400 --> 00:20:00.230
When the post handler receives
that data, it takes the

00:20:00.230 --> 00:20:02.880
authentication code and performs
its own interaction

00:20:02.880 --> 00:20:05.680
with the OAuth service,
exchanging that code for an

00:20:05.680 --> 00:20:06.410
authentication token.

00:20:06.410 --> 00:20:09.700
And then it uses that
authentication token to make

00:20:09.700 --> 00:20:13.780
its authenticated post
to Google Buzz.

00:20:13.780 --> 00:20:16.770
And then if that response
comes back OK, our post

00:20:16.770 --> 00:20:19.010
handler will draw a
congratulations, your image

00:20:19.010 --> 00:20:21.700
has been shared HTML
page and show the

00:20:21.700 --> 00:20:24.550
image back to the user.

00:20:24.550 --> 00:20:25.980
Fortunately, it's a lot
less complicated

00:20:25.980 --> 00:20:27.950
in the actual code.

00:20:27.950 --> 00:20:31.270
And to share the image on
Google Buzz, we need to

00:20:31.270 --> 00:20:32.430
authenticate with
OAuth as I said.

00:20:32.430 --> 00:20:34.620
And to do that, we'll use
the goauth2 library.

00:20:34.620 --> 00:20:36.780
And to install that again,
we can use goinstall.

00:20:36.780 --> 00:20:40.120
And again, we can import
it under that path.

00:20:40.120 --> 00:20:42.740
And to set up the OAuth
client, we need some

00:20:42.740 --> 00:20:44.890
configuration.

00:20:44.890 --> 00:20:49.050
And so we set a global variable
config, which is

00:20:49.050 --> 00:20:51.140
appointed to OAuth config.

00:20:51.140 --> 00:20:55.390
And we set the client ID and
client secret, which are

00:20:55.390 --> 00:20:59.290
obtained from the Google APIs
console or whoever your OAuth

00:20:59.290 --> 00:21:00.510
provider is.

00:21:00.510 --> 00:21:04.040
And we set some URLs to specify
authenticating with

00:21:04.040 --> 00:21:05.460
the Buzz service.

00:21:05.460 --> 00:21:08.540
And that we want to use Google's
OAuth service.

00:21:08.540 --> 00:21:10.970
That's what those three URLs
are. and the final and

00:21:10.970 --> 00:21:16.160
important URL is the redirect
URL, which is where OAuth

00:21:16.160 --> 00:21:18.980
should send the user back to
when the authentication

00:21:18.980 --> 00:21:20.460
exchange is completed.

00:21:20.460 --> 00:21:22.120
And that's our post handler.

00:21:22.120 --> 00:21:23.950
So our share handler
is very simple.

00:21:23.950 --> 00:21:25.620
It just looks like this.

00:21:25.620 --> 00:21:32.710
We call the OAuth config URL
method on our config object.

00:21:32.710 --> 00:21:38.160
And passing in the raw query,
which is our image definition

00:21:38.160 --> 00:21:40.500
and then redirect the
user to that URL, to

00:21:40.500 --> 00:21:42.140
Google's OAuth service.

00:21:42.140 --> 00:21:45.440
Once Google has redirected the
user back and they hit the

00:21:45.440 --> 00:21:49.420
post handler and the post
handler takes the

00:21:49.420 --> 00:21:51.570
authentication code
in the image.

00:21:51.570 --> 00:21:53.870
And at the top of this function,
we set up an OAuth

00:21:53.870 --> 00:21:57.350
transport with our
OAuth config.

00:21:57.350 --> 00:21:59.890
We take the code and call the
exchange method on that

00:21:59.890 --> 00:22:03.750
transport to authenticate that
transport with an access

00:22:03.750 --> 00:22:08.310
token, and then we call our post
photo function, which I

00:22:08.310 --> 00:22:12.850
haven't described yet passing in
an HTTP client made by the

00:22:12.850 --> 00:22:16.030
OAuth transport and a
URL that we want to

00:22:16.030 --> 00:22:18.000
post to our Buzz stream.

00:22:18.000 --> 00:22:23.120
And finally, if all of that
succeeded, we use the--

00:22:23.120 --> 00:22:26.310
we execute the post template,
which will be our screen

00:22:26.310 --> 00:22:30.210
saying, congratulations, your
image has been shared.

00:22:30.210 --> 00:22:33.080
So the post photo function is
fairly straightforward.

00:22:33.080 --> 00:22:36.950
It just forms a JSON-encoded
request, which I've omitted

00:22:36.950 --> 00:22:38.890
from this slide because
everybody seems to know what a

00:22:38.890 --> 00:22:41.020
JSON blob looks like.

00:22:41.020 --> 00:22:45.680
And then, makes an HTTP post
to the Buzz API using the

00:22:45.680 --> 00:22:48.320
provided HTTP client,
which is our OAuth

00:22:48.320 --> 00:22:50.810
authenticated HTTP client.

00:22:50.810 --> 00:22:57.280
So we just call the post method
on client to the Buzz

00:22:57.280 --> 00:23:03.530
API URL and type application
JSON and our JSON-encoded

00:23:03.530 --> 00:23:06.420
request.

00:23:06.420 --> 00:23:08.740
If an error occurs, we return
that error code or a custom

00:23:08.740 --> 00:23:10.540
error code.

00:23:10.540 --> 00:23:14.030
Or we just return nil if
everything went fine.

00:23:14.030 --> 00:23:16.120
This is more than you'll need
to do in the future to

00:23:16.120 --> 00:23:17.830
interact with Google APIs.

00:23:17.830 --> 00:23:21.360
A more general Go client for
Google APIs across the board

00:23:21.360 --> 00:23:22.890
is being developed.

00:23:22.890 --> 00:23:26.350
And it should simplify a lot
of this kind of code.

00:23:26.350 --> 00:23:29.030
So let's demo the sharing.

00:23:29.030 --> 00:23:32.010
So I have my gopher image.

00:23:32.010 --> 00:23:33.695
And I want to share it.

00:23:33.695 --> 00:23:36.400
So I click share.

00:23:36.400 --> 00:23:40.810
I get sent to Google and I'm
asked, Moustachio's requesting

00:23:40.810 --> 00:23:42.690
permission to manage
your Buzz activity.

00:23:42.690 --> 00:23:44.670
I allow the access.

00:23:44.670 --> 00:23:46.950
And then it says, your image
has been posted.

00:23:46.950 --> 00:23:49.430
And now if I go to my
Buzz stream, it

00:23:49.430 --> 00:23:50.650
should magically appear.

00:23:50.650 --> 00:23:52.130
And there it is.

00:23:52.130 --> 00:23:53.910
Ah, but the image is broken.

00:23:53.910 --> 00:23:58.300
And the reason why is because
if you look at the URL, I'm

00:23:58.300 --> 00:24:01.490
running on local host 8080 and
the Buzz service can't

00:24:01.490 --> 00:24:03.990
actually access my local machine
running on a private

00:24:03.990 --> 00:24:06.730
network to grab that
thumbnail.

00:24:06.730 --> 00:24:11.470
But when we move it to
production, I hope that this

00:24:11.470 --> 00:24:14.060
problem will be alleviated.

00:24:14.060 --> 00:24:18.090
So to talk about going to
production, I invite Rob back

00:24:18.090 --> 00:24:19.030
to demonstrate that.

00:24:19.030 --> 00:24:19.841
Thanks.

00:24:19.841 --> 00:24:21.091
[APPLAUSE]

00:24:26.230 --> 00:24:27.270
ROB PIKE: Thanks Andrew.

00:24:27.270 --> 00:24:29.210
While I was sitting back there
and Andrew was talking, I

00:24:29.210 --> 00:24:31.860
noticed there were relatively
few laptops open, but a

00:24:31.860 --> 00:24:33.700
surprisingly large number
of tablets.

00:24:33.700 --> 00:24:36.190
I don't know what
that's about.

00:24:36.190 --> 00:24:38.870
So once we have our little
Moustachio program running

00:24:38.870 --> 00:24:40.690
locally, we obviously want
to deploy it for

00:24:40.690 --> 00:24:42.100
the world to enjoy.

00:24:42.100 --> 00:24:46.030
And of course, that requires
a platform for doing it.

00:24:46.030 --> 00:24:48.950
And so we're delighted today
to announce that Go is

00:24:48.950 --> 00:24:51.024
supported on Google
App Engine.

00:24:51.024 --> 00:24:52.274
[APPLAUSE]

00:24:58.780 --> 00:25:01.025
ROB PIKE: Which means he's
going to need his flight

00:25:01.025 --> 00:25:04.710
goggles, or he's not going to be
able to be ready for this.

00:25:04.710 --> 00:25:05.960
OK.

00:25:07.870 --> 00:25:09.090
Now, I don't know how
many of you are

00:25:09.090 --> 00:25:11.150
familiar with App Engine.

00:25:11.150 --> 00:25:12.910
It's definitely a slightly
different way of

00:25:12.910 --> 00:25:13.580
building the app.

00:25:13.580 --> 00:25:15.260
But it's fundamentally
the same ideas.

00:25:15.260 --> 00:25:17.120
It's just some things are
different, some of the APIs

00:25:17.120 --> 00:25:18.020
change a little bit.

00:25:18.020 --> 00:25:21.700
So I'm going to talk in very
brief terms about the changes

00:25:21.700 --> 00:25:24.130
you need to make to the code
that Andrew showed in order to

00:25:24.130 --> 00:25:26.020
have it run on App Engine.

00:25:26.020 --> 00:25:29.620
One of the big differences is
that in the App Engine set up

00:25:29.620 --> 00:25:33.260
for Go, the main function is
actually run by App Engine.

00:25:33.260 --> 00:25:35.550
So the thing you write is not
a main, it's something that

00:25:35.550 --> 00:25:36.500
main calls.

00:25:36.500 --> 00:25:39.290
So the first and obvious change
is that we have to make

00:25:39.290 --> 00:25:40.050
a different package.

00:25:40.050 --> 00:25:42.150
So we call it package
Moustachio.

00:25:42.150 --> 00:25:44.200
And then we have to import a
couple of the App Engine

00:25:44.200 --> 00:25:47.430
relevant data APIs.

00:25:47.430 --> 00:25:48.890
The one we're going to be using
today is Data Store.

00:25:48.890 --> 00:25:50.210
You might have another
three or four

00:25:50.210 --> 00:25:51.440
depending on your program.

00:25:51.440 --> 00:25:54.130
And then we take the set up for
HTTP and move it out of

00:25:54.130 --> 00:25:56.250
our main function and
put it into an init.

00:25:56.250 --> 00:25:57.570
But that's a very mechanical
change.

00:25:57.570 --> 00:25:59.390
There's really nothing
interesting going on there.

00:25:59.390 --> 00:26:01.270
It's very simple.

00:26:01.270 --> 00:26:03.535
The big change happens because
on App Engine you can't read

00:26:03.535 --> 00:26:04.400
and write files.

00:26:04.400 --> 00:26:05.900
And it's sort of a fundamental
thing to the

00:26:05.900 --> 00:26:07.170
way App Engine works.

00:26:07.170 --> 00:26:09.650
A request might go to one
machine and then the next

00:26:09.650 --> 00:26:10.680
request of the same
clients goes

00:26:10.680 --> 00:26:11.600
through a different machine.

00:26:11.600 --> 00:26:13.570
If you write files, it's going
to be in the wrong place.

00:26:13.570 --> 00:26:14.780
So we just don't do that.

00:26:14.780 --> 00:26:17.480
Instead, there's a distributed
thing called data store and we

00:26:17.480 --> 00:26:20.950
store the image we're going to
play with inside App Engine's

00:26:20.950 --> 00:26:22.390
data store to make that work.

00:26:22.390 --> 00:26:24.880
To do that, we need to define
the piece of data that we can

00:26:24.880 --> 00:26:26.700
store inside the data store.

00:26:26.700 --> 00:26:28.240
And we call that an image.

00:26:28.240 --> 00:26:29.660
And this isn't a very
interesting one.

00:26:29.660 --> 00:26:31.230
It's just a block
of data stored

00:26:31.230 --> 00:26:33.440
inside an image structure.

00:26:33.440 --> 00:26:36.030
We could in fact, use blob store
for this app, which just

00:26:36.030 --> 00:26:37.780
is a bag of bits.

00:26:37.780 --> 00:26:40.480
But we made an image because the
data store's a little more

00:26:40.480 --> 00:26:42.250
interesting to work with
because it allows more

00:26:42.250 --> 00:26:45.180
experience if we want to add
providence information or

00:26:45.180 --> 00:26:47.250
other details to the image,
we could do that.

00:26:47.250 --> 00:26:48.990
Blob store would make
that harder.

00:26:48.990 --> 00:26:51.450
So now what we need to do is
figure out how to store the

00:26:51.450 --> 00:26:52.950
image inside the data store.

00:26:52.950 --> 00:26:56.020
And to do that, we need to
define a key that we can store

00:26:56.020 --> 00:26:56.940
the image under.

00:26:56.940 --> 00:26:59.700
And the easiest way to do that
is just to create a unique key

00:26:59.700 --> 00:27:01.320
from the data itself.

00:27:01.320 --> 00:27:02.660
And we can do that.

00:27:02.660 --> 00:27:04.610
Here's a really simple
function.

00:27:04.610 --> 00:27:05.950
Actually, quite a lot
going on in here.

00:27:05.950 --> 00:27:07.540
I'm not going to go through
it in detail.

00:27:07.540 --> 00:27:12.120
But what this does is take
a string of bytes, it's

00:27:12.120 --> 00:27:15.280
presumably the data from the
image, compute the SHA-1 hash

00:27:15.280 --> 00:27:18.770
of it, and then just take a
chunk out of that SHA-1 hash,

00:27:18.770 --> 00:27:20.950
hexify it, and use that
as a string that we

00:27:20.950 --> 00:27:22.540
can use as the key.

00:27:22.540 --> 00:27:25.220
It's truncated 16 bytes
of hex here.

00:27:25.220 --> 00:27:27.660
Obviously, you could make it a
full SHA-1 string, but then

00:27:27.660 --> 00:27:30.100
you get a URL a foot long and
we probably don't need that

00:27:30.100 --> 00:27:30.820
much protection.

00:27:30.820 --> 00:27:33.220
So that's a parameter
in principle, you

00:27:33.220 --> 00:27:35.300
could make it longer.

00:27:35.300 --> 00:27:37.140
Now once we've done that,
we have to take the file

00:27:37.140 --> 00:27:39.160
management code that Andrew
showed you and convert it to

00:27:39.160 --> 00:27:40.030
data store.

00:27:40.030 --> 00:27:42.230
And it doesn't actually change
all that much, but there's

00:27:42.230 --> 00:27:43.930
some details.

00:27:43.930 --> 00:27:49.310
So we grab the image before from
the request and now we

00:27:49.310 --> 00:27:50.600
just copied into a buffer.

00:27:50.600 --> 00:27:53.830
So we have a bytes buffer with
the image data inside it.

00:27:53.830 --> 00:27:56.250
Then we create this thing called
a context, which is an

00:27:56.250 --> 00:27:59.920
App Engine specific idea that is
associated with the request

00:27:59.920 --> 00:28:00.500
from the client.

00:28:00.500 --> 00:28:02.350
And that gives you a
place to do logging

00:28:02.350 --> 00:28:03.890
information, things like that.

00:28:03.890 --> 00:28:05.400
But it also gives you
the methods for

00:28:05.400 --> 00:28:07.170
things like making keys.

00:28:07.170 --> 00:28:09.920
Sorry, for accessing the
elements of the client's

00:28:09.920 --> 00:28:14.680
request. And we use it in order
to put the data inside.

00:28:14.680 --> 00:28:17.980
Because if we want to associate
the client with the

00:28:17.980 --> 00:28:19.080
data we're putting into it.

00:28:19.080 --> 00:28:22.490
So here we create a new key
using the key of the data we

00:28:22.490 --> 00:28:25.600
got, and then using the context
and the key, we store

00:28:25.600 --> 00:28:27.510
the data inside the
data store.

00:28:27.510 --> 00:28:30.010
And so now we have this hex
string that represents the

00:28:30.010 --> 00:28:31.900
data that we can use to
get it back later.

00:28:31.900 --> 00:28:35.760
Having done that as before, we
just redirect to the edit

00:28:35.760 --> 00:28:38.140
handler, but this time we're
using this key that we used

00:28:38.140 --> 00:28:40.310
instead of a file name.

00:28:40.310 --> 00:28:45.260
Once the request comes in for
the image, we recover the data

00:28:45.260 --> 00:28:47.730
just by sort of inverting
the process.

00:28:47.730 --> 00:28:50.290
Calculating what the
context is again.

00:28:50.290 --> 00:28:53.590
Using the ID from the form value
to recover the data and

00:28:53.590 --> 00:28:56.160
doing a datastore.get to
pull it out again.

00:28:56.160 --> 00:28:57.880
Checking errors of course,
all the time.

00:28:57.880 --> 00:28:59.620
And then once we've got the
data, we can just call

00:28:59.620 --> 00:29:01.770
image.decode on it just
as we did before.

00:29:04.540 --> 00:29:08.900
So one other major difference
when using App Engine is you

00:29:08.900 --> 00:29:10.450
can't just read and write
network sockets.

00:29:10.450 --> 00:29:13.640
You have to use this thing
called URL fetch API.

00:29:13.640 --> 00:29:17.770
And to do that, there's a fair
bit of adjustments you have to

00:29:17.770 --> 00:29:19.880
make to the way that the
OAuth flow works.

00:29:19.880 --> 00:29:21.830
But it doesn't change
all that much.

00:29:21.830 --> 00:29:26.330
The URL fetch API has this
concept of a transport that

00:29:26.330 --> 00:29:29.570
let's you describe how to make
requests through the App

00:29:29.570 --> 00:29:32.390
Engine infrastructure to general
HTTP interfaces.

00:29:32.390 --> 00:29:35.270
And all we really have to do
here is take the OAuth

00:29:35.270 --> 00:29:39.430
transport mechanism and insert
that into the structure for

00:29:39.430 --> 00:29:42.910
the transport for URL fetch,
which we do by constructing

00:29:42.910 --> 00:29:45.660
one of these transport
objects here.

00:29:45.660 --> 00:29:49.910
Having done that, it all just
kind of flows together.

00:29:49.910 --> 00:29:51.140
And that's really all
you've got to do.

00:29:51.140 --> 00:29:53.550
So with all that done, you
want to deploy it.

00:29:53.550 --> 00:29:54.520
What do you have to do?

00:29:54.520 --> 00:29:57.320
Well, the first thing you have
to do is describe to App

00:29:57.320 --> 00:29:59.020
Engine what your
app looks like.

00:29:59.020 --> 00:30:00.310
There's two parts to that.

00:30:00.310 --> 00:30:02.740
One is you have to write a
thing called app.yaml.

00:30:06.010 --> 00:30:07.620
Well, I think it's a ridiculous
name, but it's the

00:30:07.620 --> 00:30:09.500
one everyone knows.

00:30:09.500 --> 00:30:13.260
And inside that app.yaml file,
you write down a bunch of very

00:30:13.260 --> 00:30:15.660
simply defined fields, including
your app ID,

00:30:15.660 --> 00:30:18.740
runtime: go, which
is the big news.

00:30:18.740 --> 00:30:21.020
And then, say where the handlers
go and how they're

00:30:21.020 --> 00:30:23.830
associated with your program.

00:30:23.830 --> 00:30:26.940
This last line on the script,
it tells the development app

00:30:26.940 --> 00:30:30.710
server what kind of program
you're playing with here.

00:30:30.710 --> 00:30:33.210
Then to assemble the app, what
you need to do is take all

00:30:33.210 --> 00:30:34.810
your source code and
put it together in

00:30:34.810 --> 00:30:36.260
one directory hierarchy.

00:30:36.260 --> 00:30:38.550
And put the app.yaml
file at the root.

00:30:38.550 --> 00:30:41.190
It's an easy enough thing
to put the HTML files

00:30:41.190 --> 00:30:42.800
in the root as well.

00:30:42.800 --> 00:30:45.220
And then in the subdirectories
of various places you put the

00:30:45.220 --> 00:30:45.730
source code.

00:30:45.730 --> 00:30:49.040
We put the two files from
Moustachio into the Moustachio

00:30:49.040 --> 00:30:50.100
subdirectory.

00:30:50.100 --> 00:30:51.800
That makes the package
Moustachio.

00:30:51.800 --> 00:30:54.080
And then we also have to bring
along any third party apps

00:30:54.080 --> 00:30:56.240
that we needed that were not
part of the App Engine

00:30:56.240 --> 00:30:57.690
infrastructure by default.

00:30:57.690 --> 00:31:00.000
So here we need to bring along
the freetype-go and the

00:31:00.000 --> 00:31:01.170
goauth2 packages.

00:31:01.170 --> 00:31:03.920
And these get uploaded
from source.

00:31:03.920 --> 00:31:05.760
And then, once they're uploaded,
they will be

00:31:05.760 --> 00:31:08.940
compiled in the cloud and
deployed from a statically

00:31:08.940 --> 00:31:12.100
linked binary in the cloud.

00:31:12.100 --> 00:31:14.930
So to test it out once you've
got all this put together, you

00:31:14.930 --> 00:31:17.410
can run the development app
server with a thing that's

00:31:17.410 --> 00:31:20.020
very familiar-looking
to App Engine users.

00:31:20.020 --> 00:31:22.040
You just run the devappserver.py
with the path

00:31:22.040 --> 00:31:23.710
to your app and it brings
up the local thing.

00:31:23.710 --> 00:31:26.140
And at that point, you're
essentially running a program

00:31:26.140 --> 00:31:28.630
equivalent to what Andrew
showed you.

00:31:28.630 --> 00:31:31.810
Except the data store is just
local stuff on your machine.

00:31:31.810 --> 00:31:34.600
Once you're satisfied with that
story, you can use the

00:31:34.600 --> 00:31:38.030
app config to deploy the app
into Google's cloud using the

00:31:38.030 --> 00:31:40.970
app config update from exactly
the same tree.

00:31:40.970 --> 00:31:44.730
And once that's going, you can
access it in the cloud by your

00:31:44.730 --> 00:31:48.000
app ID .appspot.com.

00:31:48.000 --> 00:31:49.670
I wonder if it's
going to work.

00:31:49.670 --> 00:31:51.580
OK, let's see.

00:31:54.960 --> 00:31:56.580
No, I'm in the right place.

00:31:56.580 --> 00:31:59.030
OK.

00:31:59.030 --> 00:32:02.270
This is a version of Moustachio
at appspot.com,

00:32:02.270 --> 00:32:05.110
which is running in Google's
infrastructure.

00:32:05.110 --> 00:32:06.210
We've made it a little
prettier.

00:32:06.210 --> 00:32:08.360
We've put a little more graphics
in it, but the source

00:32:08.360 --> 00:32:10.850
code is largely the same as
the one we showed you.

00:32:10.850 --> 00:32:12.740
We just made it prettier
for the purpose.

00:32:12.740 --> 00:32:14.550
Now because it's in App Engine,
we need a different

00:32:14.550 --> 00:32:17.100
picture, one more
representative.

00:32:17.100 --> 00:32:19.010
So let's bring this guy up.

00:32:19.010 --> 00:32:21.450
And there he is.

00:32:21.450 --> 00:32:26.490
So we've now stored that image
inside the data store inside

00:32:26.490 --> 00:32:27.520
the Google cloud.

00:32:27.520 --> 00:32:29.030
We can play with him.

00:32:29.030 --> 00:32:31.220
I think this guy actually looks
like a French pilot now,

00:32:31.220 --> 00:32:34.400
so let's give him the
appropriate French look.

00:32:34.400 --> 00:32:35.740
Make it a little smaller.

00:32:39.070 --> 00:32:40.070
Yeah, there we go.

00:32:40.070 --> 00:32:41.710
And I think we want--

00:32:41.710 --> 00:32:42.650
that's a little too much.

00:32:42.650 --> 00:32:44.165
That's a little too Spanish.

00:32:44.165 --> 00:32:46.570
Let's go French.

00:32:46.570 --> 00:32:47.820
No, that's not right.

00:32:50.630 --> 00:32:51.510
There we go.

00:32:51.510 --> 00:32:52.000
There he is.

00:32:52.000 --> 00:32:53.760
There's our French pilot.

00:32:53.760 --> 00:32:56.620
And now of course, we want to
share it as we did before,

00:32:56.620 --> 00:32:58.010
which we do in the usual way.

00:32:58.010 --> 00:33:01.440
It says, do you want to share
to your Buzz access?

00:33:01.440 --> 00:33:05.540
And that icon as before is now
telling us that the real

00:33:05.540 --> 00:33:09.620
Moustachio guy wants to share
your Buzz information or Buzz

00:33:09.620 --> 00:33:10.390
authentication.

00:33:10.390 --> 00:33:14.040
You allow access and
it says it's there.

00:33:14.040 --> 00:33:15.385
So the image is still there.

00:33:15.385 --> 00:33:18.530
But now Enough we go to the
Buzz, it should be posted for

00:33:18.530 --> 00:33:20.670
real and we can click
in it, and all your

00:33:20.670 --> 00:33:22.030
friends can now see that.

00:33:22.030 --> 00:33:23.680
So that's live.

00:33:23.680 --> 00:33:24.930
[APPLAUSE]

00:33:31.360 --> 00:33:32.390
ROB PIKE: No demo
effect today.

00:33:32.390 --> 00:33:33.230
That's impressive.

00:33:33.230 --> 00:33:34.460
OK.

00:33:34.460 --> 00:33:37.760
All right, I think you're
probably asking at this point

00:33:37.760 --> 00:33:39.880
if you don't already,
what about me?

00:33:39.880 --> 00:33:40.790
Can I do this?

00:33:40.790 --> 00:33:41.860
The answer's yes,
I, can do this.

00:33:41.860 --> 00:33:43.380
Can you do this?

00:33:43.380 --> 00:33:45.510
Not quite yet, but almost.

00:33:45.510 --> 00:33:47.850
We're announcing that Go is
going to be a fully supported

00:33:47.850 --> 00:33:49.070
language on App Engine.

00:33:49.070 --> 00:33:51.210
Although, today it's launching
as an experimental feature,

00:33:51.210 --> 00:33:53.840
which limits how much you can
use it, number of users you

00:33:53.840 --> 00:33:57.170
can have, there's no billing,
experimental is a well-defined

00:33:57.170 --> 00:33:59.100
term in App Engine space
and Go is definitely an

00:33:59.100 --> 00:34:00.100
experimental feature.

00:34:00.100 --> 00:34:02.730
But, it's real and it works.

00:34:02.730 --> 00:34:04.960
As of today, the
SDK is publicly

00:34:04.960 --> 00:34:06.080
available for download.

00:34:06.080 --> 00:34:09.659
So right now you can go to the
site, grab the SDK and start

00:34:09.659 --> 00:34:14.880
writing an App Engine app in Go
that will run on your local

00:34:14.880 --> 00:34:18.250
machine to debug
it and test it.

00:34:18.250 --> 00:34:21.989
We're about to start sign-ups
for trusted testers for

00:34:21.989 --> 00:34:24.570
production into the
cloud for real.

00:34:24.570 --> 00:34:26.650
If you're interested
in being a trusted

00:34:26.650 --> 00:34:28.590
tester, there's a sign-up.

00:34:28.590 --> 00:34:31.330
The details are on our blog,
which is now live at

00:34:31.330 --> 00:34:32.860
blog.golang.org.

00:34:32.860 --> 00:34:35.429
And if you want to be
in there, sign up.

00:34:35.429 --> 00:34:37.670
We'll be rolling it out over
the next few weeks.

00:34:37.670 --> 00:34:41.310
Should be fully out within
a few weeks.

00:34:41.310 --> 00:34:43.280
Most of the App Engine APIs
you're familiar with from

00:34:43.280 --> 00:34:45.860
other languages are supported
and the list is growing and

00:34:45.860 --> 00:34:47.024
they're all being worked
on actively.

00:34:47.024 --> 00:34:50.650
And of course, they're all open
source, so feel free to

00:34:50.650 --> 00:34:53.020
look at what's going on there.

00:34:53.020 --> 00:34:56.060
I would like to make it very
clear that I did not do any of

00:34:56.060 --> 00:34:57.820
the work on this myself.

00:34:57.820 --> 00:34:59.870
This was entirely done
by the team.

00:34:59.870 --> 00:35:01.800
And I'd like to give a special
thanks to the guys who did all

00:35:01.800 --> 00:35:05.535
the hard work, which is David
Symons, Nigel Tao, Andrew

00:35:05.535 --> 00:35:06.670
Gerrand, who did talk.

00:35:06.670 --> 00:35:08.790
And plus we got a lot of help
from the App Engine people

00:35:08.790 --> 00:35:10.460
themselves and I would
like to thank them.

00:35:10.460 --> 00:35:12.038
So thanks guys.

00:35:12.038 --> 00:35:13.288
[APPLAUSE]

00:35:19.710 --> 00:35:23.720
ROB PIKE: OK, so in conclusion,
we think that Go

00:35:23.720 --> 00:35:25.870
is actually a great back-end
language for App Engine.

00:35:25.870 --> 00:35:28.410
And if you think about it, App
Engine is this really easy way

00:35:28.410 --> 00:35:33.230
to build, deploy scalable apps
into the infrastructure that

00:35:33.230 --> 00:35:34.370
Google provides.

00:35:34.370 --> 00:35:37.300
Go is a language for writing
scalable programs. It's just a

00:35:37.300 --> 00:35:37.920
perfect fit.

00:35:37.920 --> 00:35:40.440
And it should be.

00:35:40.440 --> 00:35:42.930
With this environment you get
an environment for building

00:35:42.930 --> 00:35:45.410
web apps that's really easy
and productive to use.

00:35:45.410 --> 00:35:47.490
It scales really well.

00:35:47.490 --> 00:35:48.700
The libraries are good.

00:35:48.700 --> 00:35:51.300
The language is good and getting
better all the time.

00:35:51.300 --> 00:35:52.980
It's also a true compiled
language.

00:35:52.980 --> 00:35:54.300
It's actually the
first compiled

00:35:54.300 --> 00:35:56.230
language for App Engine.

00:35:56.230 --> 00:35:59.080
Because Java goes through JVM.

00:35:59.080 --> 00:36:00.490
Python in interpreter.

00:36:00.490 --> 00:36:02.530
If you've got some really tight
code you need to do,

00:36:02.530 --> 00:36:04.690
like the image processing stuff
we showed you or maybe

00:36:04.690 --> 00:36:05.270
some [? crypto ?]

00:36:05.270 --> 00:36:08.000
stuff, something like that,
you can actually get right

00:36:08.000 --> 00:36:09.080
down to the bare metal in Go.

00:36:09.080 --> 00:36:12.560
And that's a really nice, new
option to have available.

00:36:12.560 --> 00:36:14.230
As I said, you can start
using it today.

00:36:14.230 --> 00:36:16.510
There is the link to
the downloads page.

00:36:16.510 --> 00:36:18.130
And the source code's
all online.

00:36:18.130 --> 00:36:21.170
You can be free to look at it,
comment, send us mail if you

00:36:21.170 --> 00:36:24.090
see bugs, play with it, maybe
make suggestions if you're

00:36:24.090 --> 00:36:25.700
interested in helping us
make it all better.

00:36:25.700 --> 00:36:30.400
And as of now, there should be
one public App Engine service,

00:36:30.400 --> 00:36:32.050
which is Moustachio.

00:36:32.050 --> 00:36:34.610
And I expect to see Moustachio's
all over the web

00:36:34.610 --> 00:36:37.440
by the end of business today.

00:36:37.440 --> 00:36:40.360
So if you want to know more
about Go, golang.org is a

00:36:40.360 --> 00:36:41.930
pretty big site.

00:36:41.930 --> 00:36:42.990
It's growing all the time.

00:36:42.990 --> 00:36:46.470
There's tutorials, videos, I
think this video should be

00:36:46.470 --> 00:36:48.550
posted there when
it's available.

00:36:48.550 --> 00:36:51.110
There's code walks and of
course, all the source code's

00:36:51.110 --> 00:36:55.440
accessible through the
code.google.com site.

00:36:55.440 --> 00:36:56.270
The spec is there.

00:36:56.270 --> 00:36:58.120
And by the way, to Go spec
compared to many other

00:36:58.120 --> 00:37:00.180
languages is quite concise
and very reasonable.

00:37:00.180 --> 00:37:03.500
It's not a huge languages,
it's quite approachable.

00:37:03.500 --> 00:37:06.450
We're moving offices now to a
new, smaller office that we

00:37:06.450 --> 00:37:09.580
have. And I might have to throw
away my C++ spec because

00:37:09.580 --> 00:37:12.580
there might not be room
in the new office.

00:37:12.580 --> 00:37:16.380
The Go blog has got all that,
all the stuff I talked about.

00:37:16.380 --> 00:37:19.110
And the newest page, the newest
entry, there has all

00:37:19.110 --> 00:37:22.300
the information that we've
talked about today.

00:37:22.300 --> 00:37:24.020
And then, if you want to hear
more about it or just come

00:37:24.020 --> 00:37:28.530
talk to us, their office hours
today sort of now until 3:00.

00:37:28.530 --> 00:37:30.820
We'll hang around until the end
of this session though.

00:37:30.820 --> 00:37:33.960
And then tomorrow there's an
App Engine office hours and

00:37:33.960 --> 00:37:34.890
we'll be there with them.

00:37:34.890 --> 00:37:36.760
And I'm sure that there's
questions that you'll have for

00:37:36.760 --> 00:37:39.070
them as well.

00:37:39.070 --> 00:37:43.050
So maybe we should start by
taking a few questions.

00:37:43.050 --> 00:37:45.510
Andrew, do you want
to come back up?

00:37:45.510 --> 00:37:48.250
We should probably
get the feedback.

00:37:48.250 --> 00:37:49.400
Is there a question [INAUDIBLE]

00:37:49.400 --> 00:37:49.700
page?

00:37:49.700 --> 00:37:50.670
No?

00:37:50.670 --> 00:37:51.960
ANDREW GERRAND: No, there's
no [INAUDIBLE].

00:37:51.960 --> 00:37:52.740
ROB PIKE: OK.

00:37:52.740 --> 00:37:56.120
So please use the microphones
for questions if you have any.

00:37:58.700 --> 00:38:00.110
No?

00:38:00.110 --> 00:38:01.360
Please come to the mike.

00:38:03.940 --> 00:38:05.490
Hi.

00:38:05.490 --> 00:38:08.230
Is there support for
asynchronous calls?

00:38:08.230 --> 00:38:10.630
ROB PIKE: Asynchronous calls?

00:38:10.630 --> 00:38:13.720
Well, App Engine, like all
web stuff, is kind of

00:38:13.720 --> 00:38:14.460
asynchronous.

00:38:14.460 --> 00:38:18.390
I mean you use a restful API to
construct an asynchronous

00:38:18.390 --> 00:38:19.600
callback through
the interface.

00:38:19.600 --> 00:38:21.360
That's basically how it works.

00:38:21.360 --> 00:38:22.290
I'm not sure what you're--

00:38:22.290 --> 00:38:24.540
ANDREW GERRAND: Do you
mean in a single

00:38:24.540 --> 00:38:25.570
handler, like making--

00:38:25.570 --> 00:38:27.880
In Go language.

00:38:27.880 --> 00:38:30.460
ANDREW GERRAND: So Go supports
some interesting concurrency

00:38:30.460 --> 00:38:32.940
permitives called go routines
and channels.

00:38:32.940 --> 00:38:36.130
And they're fully supported
under the App Engine runtime.

00:38:36.130 --> 00:38:39.340
And so it's possible say, if you
want to make multiple App

00:38:39.340 --> 00:38:41.390
Engine API calls.

00:38:41.390 --> 00:38:42.925
You can do then in separate Go

00:38:42.925 --> 00:38:44.560
routines and get the responses.

00:38:44.560 --> 00:38:46.460
And all of that should work.

00:38:46.460 --> 00:38:49.870
And the one difference between
running Go locally, in terms

00:38:49.870 --> 00:38:53.070
of its concurrency permitives
versus deploying to App Engine

00:38:53.070 --> 00:38:55.310
is that they all run in
a single operating

00:38:55.310 --> 00:38:57.430
system thread now.

00:38:57.430 --> 00:39:00.350
So you don't get any CPU
parallelism, but you do get

00:39:00.350 --> 00:39:03.000
the full benefits of that
concurrency permitives.

00:39:03.000 --> 00:39:04.510
ROB PIKE: That restriction
will get lifted.

00:39:04.510 --> 00:39:06.700
We plan to enable threading.

00:39:06.700 --> 00:39:09.040
But that's not to say that all
of your app has to run in a

00:39:09.040 --> 00:39:11.930
single thread because there
could be multiple instances on

00:39:11.930 --> 00:39:12.870
different computers.

00:39:12.870 --> 00:39:15.870
But for each instance, there
will be only a single thread

00:39:15.870 --> 00:39:17.120
running with all the
Go routines.

00:39:17.120 --> 00:39:20.650
But you still get all the nice
features of Go to be able to

00:39:20.650 --> 00:39:23.810
schedule multiple outstanding
requests and stuff like that.

00:39:23.810 --> 00:39:24.330
It works very nicely.

00:39:24.330 --> 00:39:26.140
ANDREW GERRAND: It's the same
limitation the currently

00:39:26.140 --> 00:39:28.820
applies to the Python
and Java runtimes.

00:39:28.820 --> 00:39:31.254
ROB PIKE: We really hope to
remove that restriction.

00:39:31.254 --> 00:39:33.560
Thank you.

00:39:33.560 --> 00:39:37.260
Can you just review why you
thought the world needed

00:39:37.260 --> 00:39:39.550
another programming language?

00:39:39.550 --> 00:39:43.070
And also, why Google are
investing so heavily in it.

00:39:43.070 --> 00:39:47.300
What's their motivation other
than yours, may be more

00:39:47.300 --> 00:39:49.900
academic interest. But theirs
clearly, should be more

00:39:49.900 --> 00:39:51.530
commercial.

00:39:51.530 --> 00:39:52.360
How do you--

00:39:52.360 --> 00:39:54.860
ROB PIKE: Well, it's a perfectly
good question.

00:39:54.860 --> 00:39:58.200
And I think we've answered it
many times in the past, but

00:39:58.200 --> 00:39:59.940
I'll answer it again.

00:39:59.940 --> 00:40:02.700
To be honest, there's already a
lot of programming language

00:40:02.700 --> 00:40:06.490
in the world, but none of them
seem to work well at doing the

00:40:06.490 --> 00:40:10.950
kind of software that we
develop inside Google.

00:40:10.950 --> 00:40:14.740
They work well enough, but
they don't solve all the

00:40:14.740 --> 00:40:17.290
problems together well.

00:40:17.290 --> 00:40:20.280
Most of our server software is
written in language like Java

00:40:20.280 --> 00:40:25.510
and C++, and those languages are
fairly large to write in.

00:40:25.510 --> 00:40:27.400
They take a lot of tools
to work well.

00:40:27.400 --> 00:40:30.470
We need distributed compilation
farms. Dependency

00:40:30.470 --> 00:40:33.200
management, particularly
C++ is a nightmare.

00:40:33.200 --> 00:40:36.320
And there's just a bunch of
things that tend to slow down

00:40:36.320 --> 00:40:39.450
development that are purely
mechanical and determined by

00:40:39.450 --> 00:40:42.060
the language rather than
necessarily the problem you're

00:40:42.060 --> 00:40:43.030
working on.

00:40:43.030 --> 00:40:46.950
On the other hand, it seemed
to us there was a chance to

00:40:46.950 --> 00:40:49.420
make nicer language that worked
better with modern

00:40:49.420 --> 00:40:51.965
hardware that understands
concurrency.

00:40:51.965 --> 00:40:54.350
parallelism, multi-core
machines, can support

00:40:54.350 --> 00:40:57.330
networking better, and
things like that.

00:40:57.330 --> 00:40:59.980
The answer is no, we never
needed a new language, but we

00:40:59.980 --> 00:41:02.760
thought it would really make
life better if we had one.

00:41:02.760 --> 00:41:04.430
It's starting to catch on.

00:41:04.430 --> 00:41:08.880
I think we found a sweet spot
for the balance between

00:41:08.880 --> 00:41:12.030
pragmatism and sort
of niceness.

00:41:12.030 --> 00:41:14.410
Now one of the things I will say
is that when we announced

00:41:14.410 --> 00:41:18.450
this language, a lot of the
programming community

00:41:18.450 --> 00:41:21.320
poo-pooed it because they didn't
understand why you

00:41:21.320 --> 00:41:22.670
would have a language
that wasn't

00:41:22.670 --> 00:41:24.780
theoretically, exciting.

00:41:24.780 --> 00:41:27.820
And the point was it's not
theoretically exciting, it's

00:41:27.820 --> 00:41:29.830
just very useful.

00:41:29.830 --> 00:41:34.240
And that pragmatic approach to
the design of the language is

00:41:34.240 --> 00:41:35.930
really what makes it
so productive.

00:41:35.930 --> 00:41:38.360
I've never used a language
I found more productive.

00:41:38.360 --> 00:41:39.990
I really think it's
a nice language.

00:41:39.990 --> 00:41:42.630
And if you don't enjoy using
it, then I'm not going to

00:41:42.630 --> 00:41:43.490
twist your arm about it.

00:41:43.490 --> 00:41:46.620
But I think you'll find if you
try it, which a lot of the

00:41:46.620 --> 00:41:49.100
naysayers have not done, that
it's actually way more

00:41:49.100 --> 00:41:51.954
effective than a lot
of people think.

00:41:51.954 --> 00:41:53.204
[UNINTELLIGIBLE PHRASE]

00:41:55.300 --> 00:41:56.032
ROB PIKE: Sorry?

00:41:56.032 --> 00:41:58.050
I do use it and I do like it.

00:41:58.050 --> 00:41:59.016
ROB PIKE: Please use
the microphone if

00:41:59.016 --> 00:42:00.380
you want to say something.

00:42:00.380 --> 00:42:02.040
He does use it and
he does like it.

00:42:02.040 --> 00:42:04.510
ROB PIKE: OK, thank you.

00:42:04.510 --> 00:42:05.710
At the front?

00:42:05.710 --> 00:42:08.390
Will you be supporting the
App Engine pipeline API?

00:42:08.390 --> 00:42:11.000
And if so, how does that balance
against what Andrew

00:42:11.000 --> 00:42:14.050
just brought up using separate
Go routines at the client

00:42:14.050 --> 00:42:16.770
level to process?

00:42:16.770 --> 00:42:18.555
ANDREW GERRAND: I might have to
ask someone from App Engine

00:42:18.555 --> 00:42:21.250
to answer that question
for you.

00:42:21.250 --> 00:42:25.890
We're sort of covering the
existing core functionality of

00:42:25.890 --> 00:42:28.740
App Engine first and before sort
of venturing out into the

00:42:28.740 --> 00:42:30.910
more experimental features.

00:42:30.910 --> 00:42:35.830
But our goal is certainly
to implement all of the

00:42:35.830 --> 00:42:39.530
functionality available
to the other runtimes.

00:42:39.530 --> 00:42:41.550
ROB PIKE: The App Engine
infrastructure is really

00:42:41.550 --> 00:42:43.690
designed to be pretty much
language neutral because of

00:42:43.690 --> 00:42:44.570
the way it works.

00:42:44.570 --> 00:42:47.060
It's just a matter of writing
the APIs and having them fit

00:42:47.060 --> 00:42:48.440
well in your language.

00:42:48.440 --> 00:42:50.700
If there's an API that is--

00:42:50.700 --> 00:42:52.450
well, there are a number of
APIs that are missing.

00:42:52.450 --> 00:42:54.895
But if there is one that you're
particularly interested

00:42:54.895 --> 00:42:57.510
in, let us know and we'll
give it priority to

00:42:57.510 --> 00:42:58.410
try to get it ready.

00:42:58.410 --> 00:43:01.980
It's not a big deal to write a
basic API to talk to one of

00:43:01.980 --> 00:43:03.310
these facilities.

00:43:03.310 --> 00:43:04.960
Getting the full rich
feature set could

00:43:04.960 --> 00:43:06.220
take a lot more time.

00:43:06.220 --> 00:43:08.850
But it's not our intention to
deliberately ignore any

00:43:08.850 --> 00:43:10.180
particular API.

00:43:10.180 --> 00:43:12.660
It was just what we needed to
be able to launch some demo

00:43:12.660 --> 00:43:14.460
apps and make it sort of
get off the ground.

00:43:14.460 --> 00:43:18.310
So we have things like data
store, blob store, the users

00:43:18.310 --> 00:43:22.020
API, mem cache, the basic set.

00:43:22.020 --> 00:43:23.790
Mail, right.

00:43:23.790 --> 00:43:25.920
And they'll all be there
at some point.

00:43:25.920 --> 00:43:26.690
Thank you.

00:43:26.690 --> 00:43:28.210
ANDREW GERRAND: It could be
also in the case of the

00:43:28.210 --> 00:43:31.570
pipeline system that it works
particularly well in Go

00:43:31.570 --> 00:43:33.060
because of Go's concurrency
support.

00:43:33.060 --> 00:43:35.780
But I don't know enough about
it to say for sure.

00:43:35.780 --> 00:43:37.510
ROB PIKE: Yeah, we also have
task queues, which I think is

00:43:37.510 --> 00:43:40.040
not in both the other
languages.

00:43:40.040 --> 00:43:41.310
ANDREW GERRAND: There's
a Java task--

00:43:41.310 --> 00:43:44.330
That's in Python too.

00:43:44.330 --> 00:43:45.270
ROB PIKE: Back?

00:43:45.270 --> 00:43:46.300
Yeah, thanks.

00:43:46.300 --> 00:43:48.000
This is a great discussion.

00:43:48.000 --> 00:43:50.060
I'm new to Go and one
of the concerns I

00:43:50.060 --> 00:43:52.110
have is library support.

00:43:52.110 --> 00:43:54.470
I was at NodeConf last week and
one thing that was really

00:43:54.470 --> 00:43:57.540
interesting was they talked
about dom on the server side

00:43:57.540 --> 00:44:00.440
and that opens up for a lot of
libraries that are available

00:44:00.440 --> 00:44:03.300
or previously only available
on the client side with

00:44:03.300 --> 00:44:04.730
JavaScript.

00:44:04.730 --> 00:44:07.370
So can you just talk about what
the true state of library

00:44:07.370 --> 00:44:09.600
support is, and are there any
future directions, like for

00:44:09.600 --> 00:44:13.070
example, being able to use
Python or Java libraries

00:44:13.070 --> 00:44:17.700
inside of App Engine
that talk with Go?

00:44:17.700 --> 00:44:20.405
ANDREW GERRAND: So in terms of
Go in general, library support

00:44:20.405 --> 00:44:22.920
is improving at a
very rapid pace.

00:44:22.920 --> 00:44:25.953
There are many, many external
libraries listed on our

00:44:25.953 --> 00:44:29.930
package dashboard, which is
linked to from golang.org.

00:44:29.930 --> 00:44:32.600
And those are for accessing
many different types of

00:44:32.600 --> 00:44:36.220
databases or [INAUDIBLE]

00:44:36.220 --> 00:44:37.880
support and so on.

00:44:37.880 --> 00:44:40.280
And graphics programming,
et cetera.

00:44:40.280 --> 00:44:45.520
But as far as linking non-Go
libraries to Go code in App

00:44:45.520 --> 00:44:48.590
Engine, that's definitely
an unknown.

00:44:48.590 --> 00:44:52.010
It makes the whole process of
sandboxing, the process for

00:44:52.010 --> 00:44:56.450
security purposes, much,
much more complicated.

00:44:56.450 --> 00:45:00.580
And that's why you can only
upload pure Go libraries to

00:45:00.580 --> 00:45:03.970
the Go App Engine runtime.

00:45:03.970 --> 00:45:06.920
But as far as being able to use
more and more libraries

00:45:06.920 --> 00:45:08.775
across languages, I mean it's
something that we'd definitely

00:45:08.775 --> 00:45:11.410
be interesting in doing, but I
don't have anything to say

00:45:11.410 --> 00:45:12.660
about it at this stage.

00:45:17.475 --> 00:45:20.740
I think one of the other
questions I have was want to

00:45:20.740 --> 00:45:22.980
echo what the previous gentleman
said, is that Go is

00:45:22.980 --> 00:45:27.640
great and I could see lots of
uses, but I also have lots of

00:45:27.640 --> 00:45:32.990
Java code that I would like to
have Go act as kind of the

00:45:32.990 --> 00:45:34.780
dispatcher around.

00:45:34.780 --> 00:45:37.710
But that there's no value to
convert from one language to

00:45:37.710 --> 00:45:40.120
another in many cases.

00:45:40.120 --> 00:45:46.140
But now my other question is,
how do you handle things like,

00:45:46.140 --> 00:45:49.425
where you have multiple
requests fired off and

00:45:49.425 --> 00:45:53.500
something as simple if none of
the requests return a certain

00:45:53.500 --> 00:45:57.055
amount of time, return a
default, I didn't really see

00:45:57.055 --> 00:45:57.640
an example of that.

00:45:57.640 --> 00:46:03.290
But I'd really love to see how
you handle a complex kind of a

00:46:03.290 --> 00:46:03.950
[UNINTELLIGIBLE]

00:46:03.950 --> 00:46:05.650
kind of thing with.

00:46:05.650 --> 00:46:07.910
Because I suspect that you have
some sort of conditional

00:46:07.910 --> 00:46:10.610
semantics around
how to do that.

00:46:10.610 --> 00:46:13.120
ROB PIKE: Yeah, there's a lot
of stuff in Go's concurrency

00:46:13.120 --> 00:46:15.790
support that makes that
stuff work well.

00:46:15.790 --> 00:46:18.500
There's actually, unrelated
to this stuff, there's

00:46:18.500 --> 00:46:19.940
stuff on the blog.

00:46:19.940 --> 00:46:23.930
There's been explanations of
timeouts in our use channels

00:46:23.930 --> 00:46:25.440
to coordinate things.

00:46:25.440 --> 00:46:27.830
The talk we gave last year
actually included a task queue

00:46:27.830 --> 00:46:31.720
manager presentation, which
is relevant to that.

00:46:31.720 --> 00:46:34.320
It's sort of hard to do it
spontaneously to explain it.

00:46:34.320 --> 00:46:37.070
But basically, you use go
routines and channels to

00:46:37.070 --> 00:46:40.900
construct the architecture and
you can time things out and

00:46:40.900 --> 00:46:43.010
it's actually very, very easy.

00:46:43.010 --> 00:46:45.570
It's arguably much easier than
using asynchronous call backs.

00:46:45.570 --> 00:46:47.980
But that could be largely
a matter of taste.

00:46:47.980 --> 00:46:50.620
But it's certainly easy to do
and I think a lot easier than

00:46:50.620 --> 00:46:53.500
certainly in Java.

00:46:53.500 --> 00:46:54.050
Back?

00:46:54.050 --> 00:46:55.352
Hi, yeah.

00:46:55.352 --> 00:46:57.880
How has memory manager
been done with Go?

00:46:57.880 --> 00:46:59.050
ROB PIKE: Memory management,
it's a fully

00:46:59.050 --> 00:47:00.910
garbage collected language.

00:47:00.910 --> 00:47:02.290
OK, great.

00:47:02.290 --> 00:47:05.410
ROB PIKE: It's actually better
than that though, because

00:47:05.410 --> 00:47:09.130
unlike most garbage collected
languages, you can have

00:47:09.130 --> 00:47:13.070
internal pointers, which means
that you can have a--

00:47:13.070 --> 00:47:14.910
for instance, if you have a
structure and you want to

00:47:14.910 --> 00:47:17.310
store a buffer, you can put
the buffer inside the

00:47:17.310 --> 00:47:19.430
structure and do only one
allocation for it.

00:47:19.430 --> 00:47:22.420
Which means only the overhead of
one collector as opposed to

00:47:22.420 --> 00:47:23.880
having to do a second allocation
to allocate the

00:47:23.880 --> 00:47:24.960
buffer offline.

00:47:24.960 --> 00:47:27.350
So it's like C in the sense you
have complete control over

00:47:27.350 --> 00:47:29.520
memory layout, but it's a
fully garbage collected

00:47:29.520 --> 00:47:30.740
language nonetheless.

00:47:30.740 --> 00:47:34.110
And it's also completely safe,
memory safe, type safe.

00:47:34.110 --> 00:47:39.150
So it's an interesting
data point.

00:47:39.150 --> 00:47:41.730
That brings me to my question.

00:47:41.730 --> 00:47:45.470
Modern machines depend a lot
on the CPU caches for

00:47:45.470 --> 00:47:46.610
performance.

00:47:46.610 --> 00:47:54.090
And garbage collection
algorithms tend to lose cache

00:47:54.090 --> 00:47:54.900
very rapidly.

00:47:54.900 --> 00:47:55.810
I was wondering how you handled

00:47:55.810 --> 00:47:57.230
that engineering trade-off?

00:47:57.230 --> 00:47:59.660
ROB PIKE: Well I sort of half
answered the question before.

00:47:59.660 --> 00:48:01.310
The thing is that if you--

00:48:01.310 --> 00:48:03.880
a garbage collector
isn't free.

00:48:03.880 --> 00:48:05.340
If you have a garbage collector,
there's an

00:48:05.340 --> 00:48:05.980
overhead to run it.

00:48:05.980 --> 00:48:07.020
There's no question
about that.

00:48:07.020 --> 00:48:08.970
There's also an overhead if
you're a programmer and you

00:48:08.970 --> 00:48:11.390
don't have a garbage collected
language to manage the memory.

00:48:11.390 --> 00:48:14.730
And we decided to make the
trade-off away from putting a

00:48:14.730 --> 00:48:16.880
load on the program, which means
the garbage collector

00:48:16.880 --> 00:48:18.070
has to be there.

00:48:18.070 --> 00:48:20.210
And also, for concurrent
languages, garbage collector's

00:48:20.210 --> 00:48:23.290
a must because you can't be
dealing with multiple threads,

00:48:23.290 --> 00:48:25.170
dealing with multiple bits
of memory and figuring

00:48:25.170 --> 00:48:26.210
out who owns what.

00:48:26.210 --> 00:48:28.080
But in return for that,
you have complete

00:48:28.080 --> 00:48:29.130
control over memory.

00:48:29.130 --> 00:48:31.290
So if you understand that it's
a garbage collected language,

00:48:31.290 --> 00:48:32.660
which you should if
you're writing

00:48:32.660 --> 00:48:34.030
performance intensive code.

00:48:34.030 --> 00:48:37.310
And you understand what the
costs are for allocating and

00:48:37.310 --> 00:48:39.832
freeing memory, it's possible to
construct your app so that

00:48:39.832 --> 00:48:42.160
it does only the minimum amount
of allocation beyond

00:48:42.160 --> 00:48:43.150
what's necessary.

00:48:43.150 --> 00:48:45.690
And so it ends up being in
principle, as efficient as

00:48:45.690 --> 00:48:47.000
say, a C program.

00:48:47.000 --> 00:48:49.450
And you have to know what you're
doing to get that.

00:48:49.450 --> 00:48:51.800
But at least it's possible.

00:48:51.800 --> 00:48:54.330
Whereas, in a language like Java
where you just have to

00:48:54.330 --> 00:48:56.410
let the system deal with the
memory, it's much harder to

00:48:56.410 --> 00:48:57.640
control allocation.

00:48:57.640 --> 00:48:59.590
For instance, if you get a
client request, in principle,

00:48:59.590 --> 00:49:01.460
you can put everything you need
into a single allocation

00:49:01.460 --> 00:49:04.020
and let the thing handle that.

00:49:04.020 --> 00:49:05.210
It's not easy to do that.

00:49:05.210 --> 00:49:07.860
But in principle. you could do a
single allocation per client

00:49:07.860 --> 00:49:08.740
and make it work.

00:49:08.740 --> 00:49:10.190
I mean I think that'd be
really a challenge.

00:49:10.190 --> 00:49:11.530
But you could do it.

00:49:11.530 --> 00:49:13.710
Whereas, it's not even possible
in most garbage

00:49:13.710 --> 00:49:14.670
collected languages.

00:49:14.670 --> 00:49:15.920
So we try to help you out.

00:49:18.300 --> 00:49:19.550
ANDREW GERRAND: Somebody
at the back.

00:49:21.570 --> 00:49:25.960
GWT and Android would be nice
places to see Go show up next.

00:49:25.960 --> 00:49:27.430
ROB PIKE: Yes, they would.

00:49:27.430 --> 00:49:31.610
Any time line plans,
skunk works?

00:49:31.610 --> 00:49:32.860
ROB PIKE: Can't talk about it.

00:49:37.870 --> 00:49:40.840
So can you talk a little but
more about the compiler that's

00:49:40.840 --> 00:49:44.310
used on Google App Engine?

00:49:44.310 --> 00:49:45.760
Is it open source also?

00:49:45.760 --> 00:49:46.820
ROB PIKE: It's open
source, yes.

00:49:46.820 --> 00:49:47.880
The compiler's open source.

00:49:47.880 --> 00:49:51.350
It is the bizarrely
named 6g compiler.

00:49:51.350 --> 00:49:57.660
So it's a 64 bit, x86 compiler
written in C, but it compiles

00:49:57.660 --> 00:49:59.540
Go code into--

00:49:59.540 --> 00:50:03.380
after the linker, a statically
linked binary that just gets

00:50:03.380 --> 00:50:04.730
deployed as the binary.

00:50:04.730 --> 00:50:06.180
So you upload your source
and it gets

00:50:06.180 --> 00:50:08.060
compiled by this cloud.

00:50:08.060 --> 00:50:10.570
If you go to golang.org you'll
find the links to the open

00:50:10.570 --> 00:50:11.850
source place.

00:50:11.850 --> 00:50:13.310
It's code.google.com/p/go.

00:50:13.310 --> 00:50:15.040
And the compiler's there.

00:50:15.040 --> 00:50:17.710
So fully open sourced compiler,
live, everything .

00:50:17.710 --> 00:50:18.600
It's all open source.

00:50:18.600 --> 00:50:21.740
So another question
about scripting.

00:50:21.740 --> 00:50:24.520
We'd like to see it run in
the browser too, Go.

00:50:24.520 --> 00:50:25.502
ROB PIKE: So would we.

00:50:25.502 --> 00:50:26.752
OK.

00:50:30.610 --> 00:50:31.890
ROB PIKE: Believe me,
we're on your side.

00:50:31.890 --> 00:50:34.180
We really are.

00:50:34.180 --> 00:50:35.430
Any more questions?

00:50:37.460 --> 00:50:39.400
Has our surprise arrived?

00:50:47.700 --> 00:50:48.070
Yes?

00:50:48.070 --> 00:50:48.708
ANDREW GERRAND: Yeah.

00:50:48.708 --> 00:50:50.340
[UNINTELLIGIBLE PHRASE]

00:50:50.340 --> 00:50:51.170
ROB PIKE: Was that a yes?

00:50:51.170 --> 00:50:51.550
OK.

00:50:51.550 --> 00:50:53.520
ANDREW GERRAND: Was that--
it was a yes.

00:50:53.520 --> 00:50:54.230
ROB PIKE: Was a yes.

00:50:54.230 --> 00:50:57.920
OK, as you leave, don't forget
to talk about what you heard

00:50:57.920 --> 00:50:58.970
here on Twitter.

00:50:58.970 --> 00:51:00.580
Check the feedback forms out.

00:51:00.580 --> 00:51:03.330
And also, you may find there's
a collection of gophers

00:51:03.330 --> 00:51:04.670
waiting outside for everybody.

00:51:04.670 --> 00:51:05.920
[APPLAUSE]

00:51:07.980 --> 00:51:08.990
ROB PIKE: Thanks everybody
for coming.

00:51:08.990 --> 00:51:10.420
Have fun.

