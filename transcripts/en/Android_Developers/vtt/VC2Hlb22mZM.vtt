WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:01.470
ASHISH SHARMA: Welcome.

00:00:01.470 --> 00:00:03.111
And thank you for coming.

00:00:07.770 --> 00:00:11.420
And first of all, I want
to thank everyone of you

00:00:11.420 --> 00:00:13.720
to have waited patiently
outside and in the line.

00:00:13.720 --> 00:00:14.790
I know it's really hot.

00:00:14.790 --> 00:00:16.530
So thank you for that.

00:00:16.530 --> 00:00:17.920
My name is Ashish Sharma.

00:00:17.920 --> 00:00:22.430
And I'm the tech lead of the
Volta team inside Android.

00:00:22.430 --> 00:00:24.280
And we focus on
making the battery

00:00:24.280 --> 00:00:27.180
lives of Android devices great.

00:00:27.180 --> 00:00:29.140
And I'm joined with
my colleague Meghan.

00:00:29.140 --> 00:00:29.530
MEGHAN DESAI: Hi, everyone.

00:00:29.530 --> 00:00:30.650
My name is Meghan Desai.

00:00:30.650 --> 00:00:32.816
I'm a product manager on
the Android framework team,

00:00:32.816 --> 00:00:35.810
working on battery life
and memory optimizations.

00:00:35.810 --> 00:00:37.310
ASHISH SHARMA: So
today, we're going

00:00:37.310 --> 00:00:41.550
to talk about two key
resources on any mobile device

00:00:41.550 --> 00:00:44.010
that, when running
low, can severely

00:00:44.010 --> 00:00:48.564
impact the way users use their
phones, battery and memory.

00:00:48.564 --> 00:00:50.230
We're going to look
at some optimization

00:00:50.230 --> 00:00:55.710
techniques and some platform
features, some APIs and battery

00:00:55.710 --> 00:00:59.610
diagnostic tools to take
away the pain from diagnosing

00:00:59.610 --> 00:01:00.590
battery problems.

00:01:00.590 --> 00:01:05.349
Because we know it's
a non-trivial problem.

00:01:05.349 --> 00:01:09.130
Battery life, or
extended battery life,

00:01:09.130 --> 00:01:11.960
is one at the top requested
features on mobile devices

00:01:11.960 --> 00:01:12.920
today.

00:01:12.920 --> 00:01:16.180
The phones in our pockets are
more powerful and more capable

00:01:16.180 --> 00:01:20.060
than any time before us.

00:01:20.060 --> 00:01:21.750
And there are
hundreds and thousands

00:01:21.750 --> 00:01:24.930
of applications that keep
us informed and entertained

00:01:24.930 --> 00:01:26.230
throughout the day.

00:01:26.230 --> 00:01:30.350
But if there is one thing
that all of us wish we had,

00:01:30.350 --> 00:01:33.030
it's a phone whose
battery doesn't

00:01:33.030 --> 00:01:35.130
die at the end of the day.

00:01:35.130 --> 00:01:36.580
Now, how many here
in the audience

00:01:36.580 --> 00:01:38.870
are worried that their
phones will not last

00:01:38.870 --> 00:01:40.711
through the end of the day?

00:01:40.711 --> 00:01:41.210
All right.

00:01:41.210 --> 00:01:42.790
Almost everyone.

00:01:42.790 --> 00:01:45.231
And to speak for
the same fact, we've

00:01:45.231 --> 00:01:46.605
seen that on the
Play Store there

00:01:46.605 --> 00:01:50.360
are hundreds, if not
more, of battery apps that

00:01:50.360 --> 00:01:53.540
claim to help extend battery
life of mobile devices,

00:01:53.540 --> 00:01:57.420
and some with as many as 100
million downloads or more.

00:01:57.420 --> 00:02:00.270
So clearly, it's a problem
that our users face.

00:02:00.270 --> 00:02:01.580
We care about.

00:02:01.580 --> 00:02:03.690
And we in the Volta
team in Android

00:02:03.690 --> 00:02:07.510
are very passionate
about making it awesome.

00:02:07.510 --> 00:02:10.669
So let's start looking
at where does the power

00:02:10.669 --> 00:02:13.790
on our mobile phones go?

00:02:13.790 --> 00:02:16.450
Turns out, when
the screen is on,

00:02:16.450 --> 00:02:18.790
it dominates the power
consumption on your phone

00:02:18.790 --> 00:02:20.502
more than anything else.

00:02:20.502 --> 00:02:22.960
When you have your screen on,
you're either playing a game,

00:02:22.960 --> 00:02:26.510
or watching a video, or maybe
you're surfing the internet.

00:02:26.510 --> 00:02:29.520
And screen turns out to be
a very expensive component

00:02:29.520 --> 00:02:32.820
on the device, which is
many orders of magnitude

00:02:32.820 --> 00:02:34.430
more, in terms of
power consumption,

00:02:34.430 --> 00:02:37.130
than most components
on the device.

00:02:37.130 --> 00:02:40.590
But our phones also spend a
lot of the time in our pockets

00:02:40.590 --> 00:02:43.190
when the screen's
off, like right now.

00:02:43.190 --> 00:02:44.720
I hope it is.

00:02:44.720 --> 00:02:48.830
So when the screen is
off and the user is not

00:02:48.830 --> 00:02:51.580
actively engaged or
interacting with the device,

00:02:51.580 --> 00:02:53.480
the power consumption
now starts getting

00:02:53.480 --> 00:02:56.990
dominated by the CPU and
the networking radios.

00:02:56.990 --> 00:02:59.690
So it might be an application
holding a Wakelock

00:02:59.690 --> 00:03:01.230
to do some activity.

00:03:01.230 --> 00:03:04.700
Or there might be a background
job, or a background sync,

00:03:04.700 --> 00:03:07.690
trying to access
the internet to sync

00:03:07.690 --> 00:03:09.030
some data in the background.

00:03:09.030 --> 00:03:12.550
And all of that costs power.

00:03:12.550 --> 00:03:18.480
So when it comes to optimizing
for power when the screen is

00:03:18.480 --> 00:03:23.470
off, we want you to think about
three main design principles,

00:03:23.470 --> 00:03:28.550
Reduce, Defer, and Coalesce
any and all background activity

00:03:28.550 --> 00:03:29.440
that you can.

00:03:29.440 --> 00:03:31.550
Now, what do I mean by this?

00:03:31.550 --> 00:03:35.020
Reducing the background activity
for an app when the user is not

00:03:35.020 --> 00:03:37.730
actively engaged, or is not
actively using the device,

00:03:37.730 --> 00:03:39.930
is something that only
application developers

00:03:39.930 --> 00:03:41.090
that only you can do.

00:03:41.090 --> 00:03:43.670
You know the logic of
your applications best.

00:03:43.670 --> 00:03:45.820
You know the constraints
that you're operating in.

00:03:45.820 --> 00:03:47.430
And you also know
what your users

00:03:47.430 --> 00:03:49.040
want from the application.

00:03:49.040 --> 00:03:51.160
But it's really,
really important

00:03:51.160 --> 00:03:53.846
that we try and stay
away from that urge,

00:03:53.846 --> 00:03:57.530
from that temptation, to
push data onto our devices

00:03:57.530 --> 00:04:00.790
and keep them fresh even
when the user is not actively

00:04:00.790 --> 00:04:02.090
using the app.

00:04:02.090 --> 00:04:03.580
All of you raised
your hands when

00:04:03.580 --> 00:04:05.730
I asked you if you thought
battery was important.

00:04:05.730 --> 00:04:07.770
And our users are just like us.

00:04:07.770 --> 00:04:11.740
So we really want you to think
about reducing any background

00:04:11.740 --> 00:04:15.990
activity that is possible
that you can help.

00:04:15.990 --> 00:04:18.950
For activity that you
cannot completely eliminate,

00:04:18.950 --> 00:04:20.910
and there's going to be
some cases like that,

00:04:20.910 --> 00:04:24.180
we want you to really think
hard about deferring it until

00:04:24.180 --> 00:04:26.510
the time when the
device is on charger.

00:04:26.510 --> 00:04:28.720
Because the moment the
device is plugged in,

00:04:28.720 --> 00:04:31.640
any activity that you do
essentially becomes free.

00:04:31.640 --> 00:04:35.300
And the user does not incur
any battery cost for it.

00:04:35.300 --> 00:04:37.670
And finally, we
realize, and we know,

00:04:37.670 --> 00:04:41.030
that there is going to be
cases where you cannot get rid

00:04:41.030 --> 00:04:41.950
of them completely.

00:04:41.950 --> 00:04:46.850
You cannot defer them until
the device gets on the charger.

00:04:46.850 --> 00:04:49.960
So for those, we
want you to start

00:04:49.960 --> 00:04:52.060
using the JobScheduler API.

00:04:52.060 --> 00:04:55.720
Because that is an API
that lets Android batch

00:04:55.720 --> 00:04:57.710
and coalesce a lot of
the background activity,

00:04:57.710 --> 00:05:01.080
not just from your applications,
but from other applications

00:05:01.080 --> 00:05:04.300
as well, in order to make
the most efficient use

00:05:04.300 --> 00:05:08.210
of the CPU and the background
networking traffic.

00:05:08.210 --> 00:05:09.710
Now, this is really important.

00:05:09.710 --> 00:05:11.670
I want to spend a minute here.

00:05:11.670 --> 00:05:14.425
Every time your device
wakes up from suspend,

00:05:14.425 --> 00:05:18.070
or it activates the mobile
radio to do any networking

00:05:18.070 --> 00:05:20.930
connectivity, be it for a very
small amount of data packet,

00:05:20.930 --> 00:05:24.230
there is a fixed cost that
needs to get incurred.

00:05:24.230 --> 00:05:26.800
Your device goes into
this high power state.

00:05:26.800 --> 00:05:29.060
And there is going to be a
fixed overhead every time

00:05:29.060 --> 00:05:30.018
you wake up the device.

00:05:30.018 --> 00:05:31.890
So there's an access cost.

00:05:31.890 --> 00:05:35.890
Now, the more applications
can batch together

00:05:35.890 --> 00:05:39.210
any of their background
activity and coalesce

00:05:39.210 --> 00:05:42.220
them, the more efficient
the system becomes.

00:05:42.220 --> 00:05:46.120
And power on the device can
be really, really reduced.

00:05:46.120 --> 00:05:48.720
Now, there are some
features in the platform,

00:05:48.720 --> 00:05:51.610
in the Android operating
system, that automatically

00:05:51.610 --> 00:05:54.640
help you do a lot of
this Defer and Coalesce

00:05:54.640 --> 00:05:55.832
in your applications.

00:05:55.832 --> 00:05:57.540
MEGHAN DESAI: Yeah,
that's right, Ashish.

00:05:57.540 --> 00:05:59.415
Let's start by reviewing
a couple of features

00:05:59.415 --> 00:06:03.001
we launched with the Marshmallow
release, Doze and App Standby.

00:06:03.001 --> 00:06:04.750
Say you leave your
phone on the nightstand

00:06:04.750 --> 00:06:06.832
overnight without
plugging it in.

00:06:06.832 --> 00:06:09.040
And you wake up in the
morning and your phone's dead.

00:06:09.040 --> 00:06:10.716
You're going to have a bad day.

00:06:10.716 --> 00:06:14.740
But what Doze tries to do is
coalesce a lot of that power

00:06:14.740 --> 00:06:16.740
[INAUDIBLE] background
activity that Ashish just

00:06:16.740 --> 00:06:19.156
talked about so that when you
do wake up in the morning,

00:06:19.156 --> 00:06:21.030
and you've left this
device unused overnight,

00:06:21.030 --> 00:06:22.430
it's not draining your battery.

00:06:22.430 --> 00:06:24.880
And you have some juice
left to go on with your day.

00:06:24.880 --> 00:06:27.117
So let's take a look
at how Doze works.

00:06:27.117 --> 00:06:29.200
Let's suppose these orange
bars that you're seeing

00:06:29.200 --> 00:06:31.360
are some kind of
background activity.

00:06:31.360 --> 00:06:34.474
And at some point, as I said,
you put this device down.

00:06:34.474 --> 00:06:35.140
It's stationary.

00:06:35.140 --> 00:06:36.860
So it's sitting on
your nightstand.

00:06:36.860 --> 00:06:37.877
It's on battery.

00:06:37.877 --> 00:06:38.710
It's not plugged in.

00:06:38.710 --> 00:06:39.844
And the screen's off.

00:06:39.844 --> 00:06:41.510
And the way we tell
that it's stationary

00:06:41.510 --> 00:06:43.760
is we use a significant
motion detector on the device.

00:06:43.760 --> 00:06:45.320
So that's required for Doze.

00:06:45.320 --> 00:06:47.730
And at some point, we realize,
oh, the device actually

00:06:47.730 --> 00:06:49.830
has been stationary
for quite some time.

00:06:49.830 --> 00:06:53.020
At that point, we actually do
a finer motion detection, just

00:06:53.020 --> 00:06:55.650
to make sure the device is not
in a steadily moving vehicle.

00:06:55.650 --> 00:06:57.450
We want to make sure
that it's stationary

00:06:57.450 --> 00:07:00.380
with respect to Earth
as the reference point.

00:07:00.380 --> 00:07:00.880
OK.

00:07:00.880 --> 00:07:03.970
If this happens, at that
point, the first phase of Doze

00:07:03.970 --> 00:07:04.960
kicks in.

00:07:04.960 --> 00:07:08.070
And this stays there for an
order of tens of minutes.

00:07:08.070 --> 00:07:11.650
At this point, applications
lose Wakelocks, Network Access,

00:07:11.650 --> 00:07:14.130
and there are no more
GPS or Wi-Fi scans.

00:07:14.130 --> 00:07:16.310
And their Jobs and
Syncs and Alarms

00:07:16.310 --> 00:07:19.230
get deferred until the
next maintenance window.

00:07:19.230 --> 00:07:22.940
So maintenance window is where
all that background activity

00:07:22.940 --> 00:07:23.930
gets coalesced to.

00:07:23.930 --> 00:07:25.631
This is where all
these restrictions

00:07:25.631 --> 00:07:27.880
are lifted for a brief period
of time for applications

00:07:27.880 --> 00:07:30.670
to be able to perform any kind
of pending background activity

00:07:30.670 --> 00:07:31.665
to refresh the content.

00:07:31.665 --> 00:07:33.040
So what we're
really trying to do

00:07:33.040 --> 00:07:35.590
is balance battery life
with the expectation

00:07:35.590 --> 00:07:38.470
of constant freshness that
users have on their devices.

00:07:38.470 --> 00:07:41.260
Now, the device continues
to be stationary,

00:07:41.260 --> 00:07:43.610
on battery with the
screen off, then, we

00:07:43.610 --> 00:07:46.250
can see this repeated pattern,
where the Doze windows are

00:07:46.250 --> 00:07:49.300
growing exponentially with
maintenance windows in between.

00:07:49.300 --> 00:07:52.320
And this will continue until
the Doze time, the green bars,

00:07:52.320 --> 00:07:55.090
get to about a few hours.

00:07:55.090 --> 00:07:57.260
So that's Doze in the
Marshmallow release.

00:07:57.260 --> 00:08:00.120
Now, we also wanted to
improve the power consumption

00:08:00.120 --> 00:08:03.250
of applications that you haven't
used over a period of time.

00:08:03.250 --> 00:08:07.450
And so to optimize that,
we launched App Standby.

00:08:07.450 --> 00:08:09.720
Let's keep going.

00:08:09.720 --> 00:08:13.570
Apps that are unused
after some period of time

00:08:13.570 --> 00:08:16.710
get considered to be on standby.

00:08:16.710 --> 00:08:19.320
So usage, in this case,
means applications

00:08:19.320 --> 00:08:21.570
that have had a foreground
service, some kind

00:08:21.570 --> 00:08:24.480
of an activity or process,
they have had a notification

00:08:24.480 --> 00:08:26.810
on the lock screen
that you've seen,

00:08:26.810 --> 00:08:29.847
or the app is explicitly
launched by the user.

00:08:29.847 --> 00:08:31.930
And if this hasn't happened
over a period of time,

00:08:31.930 --> 00:08:34.370
then that application
loses network access.

00:08:34.370 --> 00:08:36.549
And its jobs and
syncs are deferred

00:08:36.549 --> 00:08:37.970
while the device is on battery.

00:08:37.970 --> 00:08:40.210
So they're deferred to when
you plug in the device.

00:08:40.210 --> 00:08:43.270
But once you plug in the device,
if the application is still not

00:08:43.270 --> 00:08:45.294
used, then it will still
be considered standby.

00:08:45.294 --> 00:08:46.960
And the next time you
unplug the device,

00:08:46.960 --> 00:08:48.757
it will still, again,
lose network access,

00:08:48.757 --> 00:08:51.090
and its jobs and syncs will
be deferred to the next time

00:08:51.090 --> 00:08:52.343
the device gets plugged in.

00:08:52.343 --> 00:08:53.509
ASHISH SHARMA: Wait, Meghan.

00:08:53.509 --> 00:08:56.140
So you're saying if I have
an instant messaging app,

00:08:56.140 --> 00:08:58.230
and I don't receive a
message for a long time,

00:08:58.230 --> 00:09:00.570
and it goes in app
standby, then I

00:09:00.570 --> 00:09:03.100
might miss the incoming
instant messages or video

00:09:03.100 --> 00:09:04.940
calls because the app
is in App Standby?

00:09:04.940 --> 00:09:05.330
MEGHAN DESAI: No, no.

00:09:05.330 --> 00:09:07.560
Your instant messages are
going to make it through.

00:09:07.560 --> 00:09:10.236
So for that use case, we, as
part of Doze and App Standby,

00:09:10.236 --> 00:09:12.610
we launched something called
a high-priority Google Cloud

00:09:12.610 --> 00:09:14.990
Messaging message, which
now is Firebase Cloud

00:09:14.990 --> 00:09:17.110
Messaging, if you saw
the announcements today.

00:09:17.110 --> 00:09:19.300
So this high-priority
message, it's

00:09:19.300 --> 00:09:21.480
a push message that
grants the application

00:09:21.480 --> 00:09:23.680
temporary wakelock and
network access, independent

00:09:23.680 --> 00:09:25.980
of the device's Doze state,
or if the app happens

00:09:25.980 --> 00:09:27.240
to be in App Standby.

00:09:27.240 --> 00:09:29.860
And this allows the application
to react to the message

00:09:29.860 --> 00:09:32.610
and put up whatever immediate
notification it needs to put up

00:09:32.610 --> 00:09:34.630
to the user, whether
it's an instant message,

00:09:34.630 --> 00:09:36.620
or an incoming call.

00:09:36.620 --> 00:09:39.540
Normal Firebase Cloud
Messaging messages during Doze

00:09:39.540 --> 00:09:42.310
gets batched to the
maintenance windows.

00:09:42.310 --> 00:09:45.719
So for devices that don't
have Google Play services,

00:09:45.719 --> 00:09:47.510
this is where Google
Cloud Messaging lives,

00:09:47.510 --> 00:09:48.926
or Firebase Cloud
Messaging lives,

00:09:48.926 --> 00:09:52.180
for devices that don't have
Google Play services, we

00:09:52.180 --> 00:09:54.790
actually ship Doze and
App Standby disabled,

00:09:54.790 --> 00:09:56.040
by default in AOSP.

00:09:56.040 --> 00:09:58.155
And we instruct our
device vendors in markets

00:09:58.155 --> 00:09:59.530
where Google Play
Services is not

00:09:59.530 --> 00:10:01.280
available to work
with their ecosystems

00:10:01.280 --> 00:10:04.430
to identify an alternate
cloud push messaging service.

00:10:04.430 --> 00:10:08.334
So we don't have them
enable Doze and App

00:10:08.334 --> 00:10:10.250
Standby unless they have
Google Play services,

00:10:10.250 --> 00:10:12.639
or some alternate cloud-based
push messaging service.

00:10:12.639 --> 00:10:14.180
ASHISH SHARMA: So,
Meghan, that takes

00:10:14.180 --> 00:10:16.900
care of my instant messaging
and my video calling apps.

00:10:16.900 --> 00:10:18.370
But what about the
other use case?

00:10:18.370 --> 00:10:20.450
I often listen to
music on my device

00:10:20.450 --> 00:10:22.860
when it's just lying at home
and the music is playing off

00:10:22.860 --> 00:10:24.310
of my Bluetooth speakers.

00:10:24.310 --> 00:10:27.420
Does that mean that when
the device goes indoors

00:10:27.420 --> 00:10:28.379
my music stops playing?

00:10:28.379 --> 00:10:29.253
MEGHAN DESAI: No, no.

00:10:29.253 --> 00:10:30.804
We've got you covered
there, as well.

00:10:30.804 --> 00:10:33.220
We're going to make sure your
music keeps playing, Ashish.

00:10:33.220 --> 00:10:35.220
So for that use
case, we actually

00:10:35.220 --> 00:10:37.910
exempt foreground services
from Doze and App Standby.

00:10:37.910 --> 00:10:39.500
Often, when you're
playing music,

00:10:39.500 --> 00:10:41.110
music applications
rely on what's

00:10:41.110 --> 00:10:42.276
called a foreground service.

00:10:42.276 --> 00:10:45.930
This is a service that has to
have a persistent notification.

00:10:45.930 --> 00:10:48.430
And such a service is going
to be exempt from Doze and App

00:10:48.430 --> 00:10:48.930
Standby.

00:10:48.930 --> 00:10:51.807
So even though your
device will enter Doze,

00:10:51.807 --> 00:10:54.140
this service will retain its
network access and wakelock

00:10:54.140 --> 00:10:54.830
access.

00:10:54.830 --> 00:10:56.970
So it can still
play Ashish's music.

00:10:56.970 --> 00:10:58.440
ASHISH SHARMA:
All right, thanks.

00:10:58.440 --> 00:11:00.170
MEGHAN DESAI: I also said
that alarms get deferred.

00:11:00.170 --> 00:11:02.570
Now, there are some use cases
where alarms are important,

00:11:02.570 --> 00:11:04.150
part of what the
application needs

00:11:04.150 --> 00:11:05.532
to do on behalf of the user.

00:11:05.532 --> 00:11:06.990
So for those kinds
of use cases, we

00:11:06.990 --> 00:11:10.160
launched new alarm APIs that
will trigger in a limited way

00:11:10.160 --> 00:11:12.070
during Doze.

00:11:12.070 --> 00:11:15.300
And then, finally, for use cases
that cannot be accomplished

00:11:15.300 --> 00:11:19.620
by Doze and App Standby, we have
a Whitelist on the system that

00:11:19.620 --> 00:11:22.180
users can add applications to
that will cause the application

00:11:22.180 --> 00:11:24.110
to be exempt from
Doze and App Standby.

00:11:24.110 --> 00:11:26.242
Applications can also
prompt users at runtime

00:11:26.242 --> 00:11:28.200
to be added to this
Whitelist, but this is only

00:11:28.200 --> 00:11:31.165
for very specific, narrow,
acceptable use cases

00:11:31.165 --> 00:11:33.870
that you can read about
on our developer site.

00:11:33.870 --> 00:11:36.210
And doing so would trigger
a Play Store review

00:11:36.210 --> 00:11:38.690
before your application gets
published to the Play Store.

00:11:38.690 --> 00:11:40.690
ASHISH SHARMA: So all
this sounds great, Meghan.

00:11:40.690 --> 00:11:42.650
The features make a
lot of intuitive sense.

00:11:42.650 --> 00:11:47.280
Doze and App Standby for
cases when my device is not

00:11:47.280 --> 00:11:49.900
being used, or when I'm
not using my applications.

00:11:49.900 --> 00:11:51.350
How did we do?

00:11:51.350 --> 00:11:52.410
Do we have any numbers?

00:11:52.410 --> 00:11:52.740
MEGHAN DESAI: I think we do.

00:11:52.740 --> 00:11:53.700
I think we have some numbers.

00:11:53.700 --> 00:11:54.940
ASHISH SHARMA: Oh, great.

00:11:54.940 --> 00:11:58.590
So last year, when we
announced Marshmallow,

00:11:58.590 --> 00:12:02.180
we saw that Doze and App
Standby combined together

00:12:02.180 --> 00:12:05.470
can increase the standby
battery life of a Nexus 9 tablet

00:12:05.470 --> 00:12:07.220
almost twice.

00:12:07.220 --> 00:12:09.470
And so the battery life
almost doubled there.

00:12:09.470 --> 00:12:13.560
And we also saw up to
30% average improvement

00:12:13.560 --> 00:12:16.485
in the screen-off battery
life of Nexus 6 devices.

00:12:16.485 --> 00:12:18.610
There are in a control
group population of Googlers

00:12:18.610 --> 00:12:19.480
that we have.

00:12:19.480 --> 00:12:22.930
So clearly, Doze and App Standby
are very important features.

00:12:22.930 --> 00:12:25.630
And these principles
do seem to work.

00:12:25.630 --> 00:12:28.710
But I'm still thinking
about one thing.

00:12:28.710 --> 00:12:32.810
These cases make sense when I'm
not using my device or the apps

00:12:32.810 --> 00:12:33.830
that I'm not using.

00:12:33.830 --> 00:12:36.090
But what if I'm actually
walking around with my device

00:12:36.090 --> 00:12:38.480
like I am today and
I'm actively using

00:12:38.480 --> 00:12:39.647
all of the apps on my phone?

00:12:39.647 --> 00:12:41.354
MEGHAN DESAI: Yeah,
that's right, Ashish.

00:12:41.354 --> 00:12:43.339
It turns out that most
of the time our devices

00:12:43.339 --> 00:12:44.380
aren't stationary, right?

00:12:44.380 --> 00:12:47.150
We have them in our
hands, or in our pockets,

00:12:47.150 --> 00:12:49.760
and we're moving about the
world doing what we need to do.

00:12:49.760 --> 00:12:51.650
So we wanted to bring
the power of Doze,

00:12:51.650 --> 00:12:54.740
the battery gains of Doze,
to that situation as well.

00:12:54.740 --> 00:12:57.680
And that's why we're extending
Doze in the Android N-release.

00:12:57.680 --> 00:13:00.510
So let's take a look at
how that's going to work.

00:13:00.510 --> 00:13:04.130
Again, think of these orange
bars as background activity.

00:13:04.130 --> 00:13:05.989
And at some point, you
turn the screen off.

00:13:05.989 --> 00:13:07.530
And you put the
phone in your pocket.

00:13:07.530 --> 00:13:09.280
So it's not being
charged right now.

00:13:09.280 --> 00:13:12.100
Well, shortly after
that, and this time

00:13:12.100 --> 00:13:14.480
on the order of minutes,
so shortly after that,

00:13:14.480 --> 00:13:16.170
the first phase
of Doze kicks in.

00:13:16.170 --> 00:13:19.920
And now, this is a
lighter, gentler Doze

00:13:19.920 --> 00:13:22.320
than what you saw with
Marshmallow in that it's only

00:13:22.320 --> 00:13:24.660
going to restrict the
application's network access,

00:13:24.660 --> 00:13:27.397
and any of these jobs and
syncs will get deferred.

00:13:27.397 --> 00:13:29.230
When do they get deferred
to, you might ask?

00:13:29.230 --> 00:13:30.780
To the next maintenance window.

00:13:30.780 --> 00:13:32.660
So sort of the familiar
maintenance window

00:13:32.660 --> 00:13:35.470
and Doze repeated cycle
will ensue after that

00:13:35.470 --> 00:13:37.609
so long as the screen
continues to be off.

00:13:37.609 --> 00:13:40.150
And again, the idea here is that
we're balancing battery life

00:13:40.150 --> 00:13:42.507
with freshness of content.

00:13:42.507 --> 00:13:44.590
And in the maintenance
windows, these restrictions

00:13:44.590 --> 00:13:48.740
are lifted to allow any
pending activity to resume.

00:13:48.740 --> 00:13:51.130
And all this will end
when the screen comes on,

00:13:51.130 --> 00:13:54.070
or you plug in the device,
as you would expect.

00:13:54.070 --> 00:13:54.570
OK.

00:13:54.570 --> 00:13:57.450
So let's quickly review the
Doze that we just talked about

00:13:57.450 --> 00:14:00.910
in Marshmallow and figure out
how this extended Doze that I

00:14:00.910 --> 00:14:02.410
talked about will
work with the Doze

00:14:02.410 --> 00:14:03.868
that I talked about
in Marshmallow.

00:14:03.868 --> 00:14:06.390
So for that, we're going
to zoom into this red box

00:14:06.390 --> 00:14:08.380
on the screen.

00:14:08.380 --> 00:14:10.165
Let's take a look
at what happens.

00:14:10.165 --> 00:14:12.040
So as you'd expect, the
device is stationary.

00:14:12.040 --> 00:14:13.080
It's on battery.

00:14:13.080 --> 00:14:13.980
And it's screen off.

00:14:13.980 --> 00:14:16.710
But the amount of time hasn't
passed yet for Doze to trigger.

00:14:16.710 --> 00:14:18.380
Only a few minutes have passed.

00:14:18.380 --> 00:14:20.700
At this point, this extended
Doze, or this lighter,

00:14:20.700 --> 00:14:24.620
gentler version of Doze
will kick in, the N-release.

00:14:24.620 --> 00:14:27.914
And you'll see that same pattern
of Doze and maintenance window.

00:14:27.914 --> 00:14:30.080
And at some point, the
device will realize, oh, hey,

00:14:30.080 --> 00:14:32.770
the device actually has been
stationary for quite some time.

00:14:32.770 --> 00:14:34.728
And it's been stationary
for the amount of time

00:14:34.728 --> 00:14:35.974
required for Doze to kick in.

00:14:35.974 --> 00:14:38.390
And then, at that point, just
like it does in Marshmallow,

00:14:38.390 --> 00:14:41.950
the full set of Doze
restrictions will kick in.

00:14:41.950 --> 00:14:44.620
So at that point, applications,
again, will Wakelocks,

00:14:44.620 --> 00:14:46.453
their alarms will get
deferred, and there'll

00:14:46.453 --> 00:14:49.020
be no more GPS or Wi-Fi
scans because the device has

00:14:49.020 --> 00:14:51.630
been stationary.

00:14:51.630 --> 00:14:52.130
Great.

00:14:52.130 --> 00:14:54.730
So we were very excited
about the battery life

00:14:54.730 --> 00:14:56.410
gains of this extended Doze.

00:14:56.410 --> 00:14:58.080
But the even better
news for all of you

00:14:58.080 --> 00:15:00.079
is if you've already
optimized your applications

00:15:00.079 --> 00:15:03.430
for Doze and App Standby, you
don't need to do too much more.

00:15:03.430 --> 00:15:06.750
High-priority Firebase
Cloud Messaging messages

00:15:06.750 --> 00:15:09.480
continue to provide the
application temporary Wakelock

00:15:09.480 --> 00:15:10.980
and network access.

00:15:10.980 --> 00:15:13.680
And foreground services continue
to be exempt from Doze and App

00:15:13.680 --> 00:15:14.180
Standby.

00:15:14.180 --> 00:15:17.230
So we make sure that
Ashish's music keeps playing.

00:15:17.230 --> 00:15:18.510
ASHISH SHARMA: All right.

00:15:18.510 --> 00:15:19.301
MEGHAN DESAI: Cool.

00:15:19.301 --> 00:15:22.440
So we've been talking a lot
about background services

00:15:22.440 --> 00:15:23.834
and their impact
on battery life.

00:15:23.834 --> 00:15:25.500
We're going to switch
gears a little bit

00:15:25.500 --> 00:15:28.340
and talk about background
services and their impact

00:15:28.340 --> 00:15:30.690
on memory.

00:15:30.690 --> 00:15:33.476
So let's say you're trying
to do something on your phone

00:15:33.476 --> 00:15:35.100
and it's just really
slow and sluggish.

00:15:35.100 --> 00:15:37.266
Say you're trying to take
a picture with the camera,

00:15:37.266 --> 00:15:40.110
and you miss that moment because
your phone was just too slow.

00:15:40.110 --> 00:15:41.690
You know what I'm talking about.

00:15:41.690 --> 00:15:44.065
Background services have an
impact when the screen is on,

00:15:44.065 --> 00:15:45.390
as well.

00:15:45.390 --> 00:15:47.265
And that's what we're
going to focus on next.

00:15:47.265 --> 00:15:49.056
So again, let's say
you have an application

00:15:49.056 --> 00:15:51.270
you're trying to use,
that's the Top App here.

00:15:51.270 --> 00:15:52.750
At any given time,
there's a number

00:15:52.750 --> 00:15:55.190
of things happening in the
background, lots of stuff

00:15:55.190 --> 00:15:59.210
happening in the
background services.

00:15:59.210 --> 00:16:01.500
When a device enters a
low memory situation,

00:16:01.500 --> 00:16:04.960
or if it just happens to be a
low memory device, what happens

00:16:04.960 --> 00:16:07.170
is there's not enough
memory to run all that stuff

00:16:07.170 --> 00:16:09.210
in the background
while you're trying

00:16:09.210 --> 00:16:11.980
to use the device with
that thing at the top.

00:16:11.980 --> 00:16:13.830
Well, at that point,
Android is too busy

00:16:13.830 --> 00:16:16.000
trying to swap applications
in and out of memory

00:16:16.000 --> 00:16:18.500
to let them do what they need
to do in the background, which

00:16:18.500 --> 00:16:20.624
applies pressure on the
application you're actually

00:16:20.624 --> 00:16:21.335
trying to use.

00:16:21.335 --> 00:16:23.710
And the net result is that
you get this frustrating, slow

00:16:23.710 --> 00:16:25.400
experience of the device.

00:16:25.400 --> 00:16:28.220
So that's the problem
we're trying to tackle.

00:16:28.220 --> 00:16:30.030
But background work
is pretty important.

00:16:30.030 --> 00:16:33.290
So let's figure out why
background work is happening.

00:16:33.290 --> 00:16:35.130
One such trigger for
background service

00:16:35.130 --> 00:16:37.180
is something called
an implicit broadcast.

00:16:37.180 --> 00:16:39.090
A broadcast is
just a signal that

00:16:39.090 --> 00:16:41.980
gets sent out on the device
whenever something happens,

00:16:41.980 --> 00:16:43.540
the minute something changes.

00:16:43.540 --> 00:16:45.087
And the implicit
type of broadcast

00:16:45.087 --> 00:16:46.670
is the type that
gets sent to any app,

00:16:46.670 --> 00:16:48.401
or any application
can listen to it,

00:16:48.401 --> 00:16:50.900
versus the explicit side, which
would be something that gets

00:16:50.900 --> 00:16:53.570
sent to a specific application.

00:16:53.570 --> 00:16:57.566
What makes this particularly bad
is that often these broadcasts

00:16:57.566 --> 00:16:59.690
are listened to, the
receivers for these broadcasts

00:16:59.690 --> 00:17:02.380
are declared in a static
way in the application's

00:17:02.380 --> 00:17:03.690
manifest file.

00:17:03.690 --> 00:17:06.220
What that means is that the
application doesn't actually

00:17:06.220 --> 00:17:08.760
have to be running for it
to receive this broadcast

00:17:08.760 --> 00:17:09.920
and react to it.

00:17:09.920 --> 00:17:12.034
In fact, a broadcast
sent in this manner

00:17:12.034 --> 00:17:13.950
would cause the applications
that are not even

00:17:13.950 --> 00:17:16.430
running, but listening
for it, to be woken up,

00:17:16.430 --> 00:17:19.470
brought into memory, and
react to it in some way.

00:17:19.470 --> 00:17:21.756
And while Android is
too busy doing that,

00:17:21.756 --> 00:17:23.839
the application that you're
actually trying to use

00:17:23.839 --> 00:17:25.842
starts to be sluggish and slow.

00:17:25.842 --> 00:17:27.300
Let's take a quick
example of this,

00:17:27.300 --> 00:17:29.580
a broadcast called
CONNECTIVITY_CHANGE.

00:17:29.580 --> 00:17:33.280
This is a broadcast that
gets sent quite frequently

00:17:33.280 --> 00:17:34.290
on your device.

00:17:34.290 --> 00:17:36.560
You know, any time you
switch from Wi-Fi to cell,

00:17:36.560 --> 00:17:38.970
or back, or any kind of
connectivity change happens,

00:17:38.970 --> 00:17:40.430
this broadcast gets sent.

00:17:40.430 --> 00:17:42.390
And it turns out, a
lot of applications

00:17:42.390 --> 00:17:44.770
listen to this broadcast
in a static way,

00:17:44.770 --> 00:17:48.050
by declaring receivers
in the manifest file.

00:17:48.050 --> 00:17:50.231
And so, whenever this
broadcast gets sent,

00:17:50.231 --> 00:17:51.980
lots and lots of
applications are woken up

00:17:51.980 --> 00:17:53.950
to perform activity
in the background.

00:17:53.950 --> 00:17:56.677
And you get a frustrating
experience on your device.

00:17:56.677 --> 00:17:58.760
So this is the problem
that we're trying to solve.

00:17:58.760 --> 00:18:00.570
So what do we do?

00:18:00.570 --> 00:18:03.100
Well, we could just get
rid of background services

00:18:03.100 --> 00:18:07.190
and implicit broadcast
in Android All right.

00:18:07.190 --> 00:18:08.200
It's not that simple.

00:18:08.200 --> 00:18:10.950
Because background activity
is actually pretty important.

00:18:10.950 --> 00:18:12.560
So what we're
envisioning here is

00:18:12.560 --> 00:18:16.680
that applications perform
any background activity using

00:18:16.680 --> 00:18:19.240
exclusively JobScheduler jobs.

00:18:19.240 --> 00:18:23.090
And they reduce their reliance
on background services

00:18:23.090 --> 00:18:24.510
and statically
declared receivers

00:18:24.510 --> 00:18:26.130
for implicit broadcasts.

00:18:26.130 --> 00:18:27.850
Let's take a quick
look at what I mean.

00:18:27.850 --> 00:18:31.000
So what we envision here is
that applications' statically

00:18:31.000 --> 00:18:33.810
declared implicit broadcast
receivers would no longer get

00:18:33.810 --> 00:18:35.270
woken up.

00:18:35.270 --> 00:18:38.570
One time declared receivers
would continue to work.

00:18:38.570 --> 00:18:40.010
Explicit broadcast
receivers would

00:18:40.010 --> 00:18:43.530
continue to work, both declared
statically, or at one time.

00:18:43.530 --> 00:18:46.320
But the statically declared
implicit broadcast receivers

00:18:46.320 --> 00:18:48.992
would be the ones that
are specifically affected.

00:18:48.992 --> 00:18:50.450
Second, for background
services, we

00:18:50.450 --> 00:18:52.880
envision that apps are no longer
running background services,

00:18:52.880 --> 00:18:55.050
or dependent on that for any
kind of background execution.

00:18:55.050 --> 00:18:57.160
Now, I said, background
execution is important.

00:18:57.160 --> 00:19:01.000
And for that, we want developers
to use JobScheduler or Jobs.

00:19:01.000 --> 00:19:03.570
Now, foreground services
will still continue to work.

00:19:03.570 --> 00:19:06.180
So, Ashish, your music will
still continue to play.

00:19:06.180 --> 00:19:08.180
ASHISH SHARMA: Well, thank
you for that, Meghan.

00:19:08.180 --> 00:19:10.120
But all of this
sounds pretty scary.

00:19:10.120 --> 00:19:11.420
These are pretty big changes.

00:19:11.420 --> 00:19:12.740
Are they coming in N?

00:19:12.740 --> 00:19:14.680
Do we need to change
all of our apps

00:19:14.680 --> 00:19:17.802
in time for N,
which is very soon?

00:19:17.802 --> 00:19:19.260
MEGHAN DESAI: It's
not coming in N.

00:19:19.260 --> 00:19:21.080
But you need to
change your app soon.

00:19:21.080 --> 00:19:23.280
So today, we're just
giving you a preview

00:19:23.280 --> 00:19:25.420
of what we envision to
be the future of Android,

00:19:25.420 --> 00:19:27.836
where we think Android is going
with respect to background

00:19:27.836 --> 00:19:28.450
activity.

00:19:28.450 --> 00:19:30.110
We know that background
activity plays

00:19:30.110 --> 00:19:32.040
a huge factor in
both battery life

00:19:32.040 --> 00:19:34.587
and the overall
performance of the system.

00:19:34.587 --> 00:19:36.170
So this is sort of
where we are going.

00:19:36.170 --> 00:19:37.766
And we're planning
to launch these

00:19:37.766 --> 00:19:39.140
when we think
they're going to be

00:19:39.140 --> 00:19:40.780
ready in some future release.

00:19:40.780 --> 00:19:43.370
And they'll apply to the apps
that target that release.

00:19:43.370 --> 00:19:46.210
In the N-release, we want to
give you tools to start testing

00:19:46.210 --> 00:19:48.880
your applications under those
conditions and giving us

00:19:48.880 --> 00:19:51.570
feedback on, as you think about
changing your applications

00:19:51.570 --> 00:19:55.150
to use job scheduler,
where you can't.

00:19:55.150 --> 00:19:56.650
We're also removing
a few broadcasts

00:19:56.650 --> 00:20:00.070
that we think are particularly
harmful in the system today.

00:20:00.070 --> 00:20:02.610
And I'll talk about
that in just a second.

00:20:02.610 --> 00:20:06.310
So we have some adb commands
you can use today in the preview

00:20:06.310 --> 00:20:07.790
and apply them to
your application.

00:20:07.790 --> 00:20:10.230
Start testing to see what
happens, how your applications

00:20:10.230 --> 00:20:12.030
behave under these conditions.

00:20:12.030 --> 00:20:12.930
And send us feedback.

00:20:12.930 --> 00:20:15.295
Let us know what implicit
broadcasts that you're

00:20:15.295 --> 00:20:16.920
currently dependent
on in your manifest

00:20:16.920 --> 00:20:18.570
files that you
can't live without,

00:20:18.570 --> 00:20:20.810
what kind of background
services use cases you have

00:20:20.810 --> 00:20:24.260
that you can't move over
to job scheduler or jobs.

00:20:24.260 --> 00:20:26.862
OK, Ashish, so I think your
specific question was what's

00:20:26.862 --> 00:20:28.820
actually going to be
changing in the N-release,

00:20:28.820 --> 00:20:30.769
so let me talk a
little bit about that.

00:20:30.769 --> 00:20:32.810
First, I already talked
about CONNECTIVITY_CHANGE

00:20:32.810 --> 00:20:35.074
as being a particularly
harmful broadcast.

00:20:35.074 --> 00:20:36.740
So that's one that
we're getting rid of.

00:20:36.740 --> 00:20:39.770
So applications that are
targeting the N-release

00:20:39.770 --> 00:20:42.510
will no longer be woken up as
a result of this broadcast.

00:20:42.510 --> 00:20:44.410
This means that if you've
declared a receiver

00:20:44.410 --> 00:20:46.410
for this broadcast in
your manifest file, that's

00:20:46.410 --> 00:20:47.674
no longer going to work.

00:20:47.674 --> 00:20:49.340
If you declare it at
runtime, as I said,

00:20:49.340 --> 00:20:50.960
runtime receivers
for broadcast will

00:20:50.960 --> 00:20:53.210
continue to work because
your applications are already

00:20:53.210 --> 00:20:54.190
running at that point.

00:20:54.190 --> 00:20:56.565
And for other use cases, we
want you to use JobScheduler.

00:20:56.565 --> 00:21:01.110
And JobScheduler already has
network trigger semantics.

00:21:01.110 --> 00:21:04.320
The other two are
NEW_PICTURE and NEW_VIDEO.

00:21:04.320 --> 00:21:07.050
These are two more
implicit broadcasts

00:21:07.050 --> 00:21:09.790
that are sent right when
the user takes a picture.

00:21:09.790 --> 00:21:11.397
And they're sent by the camera.

00:21:11.397 --> 00:21:12.980
And that's sort of
the worst time when

00:21:12.980 --> 00:21:14.220
you want a lot of
other background stuff

00:21:14.220 --> 00:21:16.370
to be happening because
you want to focus on taking

00:21:16.370 --> 00:21:18.411
that next picture, or
whatever it is you're doing

00:21:18.411 --> 00:21:20.120
with the camera application.

00:21:20.120 --> 00:21:22.562
So starting with the
N-release, all applications

00:21:22.562 --> 00:21:24.270
will no longer be able
to send or receive

00:21:24.270 --> 00:21:25.590
these two broadcasts.

00:21:25.590 --> 00:21:28.970
So not just those targeting
N, all applications.

00:21:28.970 --> 00:21:31.000
And in fact, these
broadcasts are actually

00:21:31.000 --> 00:21:34.150
pretty important because they
unleash some pretty cool use

00:21:34.150 --> 00:21:34.780
cases.

00:21:34.780 --> 00:21:36.570
So one of them is
uploading photos.

00:21:36.570 --> 00:21:38.830
As soon as you take a photo,
you want that uploaded.

00:21:38.830 --> 00:21:40.350
But maybe you can wait.

00:21:40.350 --> 00:21:43.170
And so for that, we're
actually expanding

00:21:43.170 --> 00:21:46.110
JobScheduler to be able to be
triggered on content provider

00:21:46.110 --> 00:21:47.520
changes.

00:21:47.520 --> 00:21:49.600
So the media folder has
a content provider URI.

00:21:49.600 --> 00:21:51.910
That could be the trigger
whenever something updates

00:21:51.910 --> 00:21:55.980
there to upload that photo.

00:21:55.980 --> 00:21:57.760
And the cool thing
about this is that now,

00:21:57.760 --> 00:21:59.260
because you're using
Java scheduler,

00:21:59.260 --> 00:22:01.479
the system can optimize when
that action takes place.

00:22:01.479 --> 00:22:03.020
It doesn't have to
happen immediately

00:22:03.020 --> 00:22:04.540
when you're trying to
take that next picture.

00:22:04.540 --> 00:22:06.680
It can find the next
opportune time to do it,

00:22:06.680 --> 00:22:08.138
depending on the
memory conditions.

00:22:10.311 --> 00:22:10.810
Cool.

00:22:10.810 --> 00:22:12.750
So I've been talking a
lot about JobScheduler

00:22:12.750 --> 00:22:13.940
and how awesome it is.

00:22:13.940 --> 00:22:15.090
But just a show of
hands, how many of you

00:22:15.090 --> 00:22:16.590
have actually heard
of JobScheduler?

00:22:18.100 --> 00:22:19.850
ASHISH SHARMA: Well,
that's a good number.

00:22:19.850 --> 00:22:22.600
But I also see a lot of
the hands that are not up.

00:22:22.600 --> 00:22:24.870
So maybe it's a good
time for us to review

00:22:24.870 --> 00:22:28.120
what this really important
JobScheduler API really looks

00:22:28.120 --> 00:22:30.130
like and what the features are.

00:22:30.130 --> 00:22:32.430
Because you made it
sound very important.

00:22:32.430 --> 00:22:33.150
OK.

00:22:33.150 --> 00:22:35.670
Let's do a quick review
of the JobScheduler API

00:22:35.670 --> 00:22:38.780
so that everyone here
is on the same page.

00:22:38.780 --> 00:22:41.220
The JobScheduler
API, think of it

00:22:41.220 --> 00:22:44.230
like a wrapper around
any background activity.

00:22:44.230 --> 00:22:47.290
So any background sync,
any background activity

00:22:47.290 --> 00:22:49.590
that you have,
JobScheduler is the way

00:22:49.590 --> 00:22:52.220
to think about scheduling those.

00:22:52.220 --> 00:22:56.380
And this is slightly a paradigm
shift, where what you're doing

00:22:56.380 --> 00:23:00.260
is you're letting Android know
that I have some tasks that

00:23:00.260 --> 00:23:03.660
need to get done, and you
specify certain triggers when

00:23:03.660 --> 00:23:06.210
Android will schedule
those jobs for you,

00:23:06.210 --> 00:23:09.640
rather than something that you
try and take care of yourself.

00:23:09.640 --> 00:23:11.890
So let's take a
couple of examples.

00:23:11.890 --> 00:23:16.370
These triggers, when you request
Android to schedule your job,

00:23:16.370 --> 00:23:19.080
could be used on a
certain time window.

00:23:19.080 --> 00:23:22.365
So say you have a job that's
important, not exactly urgent.

00:23:22.365 --> 00:23:24.320
It doesn't need to
happen right away.

00:23:24.320 --> 00:23:27.480
You can tell Android
that, schedule this job

00:23:27.480 --> 00:23:29.840
any time within
the next one hour.

00:23:29.840 --> 00:23:32.850
And what Android would do is
once many applications are

00:23:32.850 --> 00:23:34.820
using the JobScheduler
API, it now

00:23:34.820 --> 00:23:37.470
has this context about
all the background

00:23:37.470 --> 00:23:40.270
activity from the different
apps that needs to happen.

00:23:40.270 --> 00:23:44.550
And it's going to do a good job
at scheduling your job at just

00:23:44.550 --> 00:23:48.050
the right time, so
that the efficiency

00:23:48.050 --> 00:23:51.550
of the CPU and the networking
radios can be maximized.

00:23:51.550 --> 00:23:54.450
Now, what you can also
do is specify triggers

00:23:54.450 --> 00:23:56.980
based on network connectivity,
or the type of network

00:23:56.980 --> 00:23:58.470
that becomes available.

00:23:58.470 --> 00:24:00.570
So say, for example,
an application

00:24:00.570 --> 00:24:03.850
that's uploading a whole
bunch of photos or videos

00:24:03.850 --> 00:24:05.370
that you might
have on your phone,

00:24:05.370 --> 00:24:08.350
now, it's a very good
idea for such an app

00:24:08.350 --> 00:24:13.610
to schedule or to specify a
trigger for of Wi-Fi network.

00:24:13.610 --> 00:24:15.200
Because what that's
going to do is,

00:24:15.200 --> 00:24:17.480
Wi-Fi typically
has more bandwidth.

00:24:17.480 --> 00:24:19.780
And it's less expensive,
in terms of money.

00:24:19.780 --> 00:24:23.850
And it costs also less power
than the cellular radio.

00:24:23.850 --> 00:24:26.110
So that can be a
constraint, or a trigger,

00:24:26.110 --> 00:24:27.740
that you can specify.

00:24:27.740 --> 00:24:32.350
And finally, the thing which is
my favorite, which comes back

00:24:32.350 --> 00:24:35.280
to the whole deferring until
the device is on charger,

00:24:35.280 --> 00:24:37.270
you can specify
that control too.

00:24:37.270 --> 00:24:39.570
So you can tell
that here's a job

00:24:39.570 --> 00:24:43.260
that I want to get
done and trigger it

00:24:43.260 --> 00:24:45.020
when the device is charging.

00:24:45.020 --> 00:24:46.420
But not just that.

00:24:46.420 --> 00:24:51.140
Because every time you
plug in the device may not

00:24:51.140 --> 00:24:53.220
be the best time for all
of the background jobs

00:24:53.220 --> 00:24:54.380
to start firing up.

00:24:54.380 --> 00:24:58.880
Say, for example, I saw
some power outlets outside.

00:24:58.880 --> 00:25:00.400
You've been here since morning.

00:25:00.400 --> 00:25:01.770
Your phones are running low.

00:25:01.770 --> 00:25:03.100
And you find that power outlet.

00:25:03.100 --> 00:25:06.200
And you plug in your device to
get maybe 5 minutes of charge.

00:25:06.200 --> 00:25:08.710
And right then, if all of the
photos and the videos that you

00:25:08.710 --> 00:25:11.360
took today start getting
uploaded to the cloud,

00:25:11.360 --> 00:25:14.400
that's going to be a not so
pleasant experience for you.

00:25:14.400 --> 00:25:16.120
Because your device
might get slow.

00:25:16.120 --> 00:25:19.110
But also, you might not get
enough charge out of the outlet

00:25:19.110 --> 00:25:21.220
because you're spending
all of that energy.

00:25:21.220 --> 00:25:23.040
So what you can
do is you can say

00:25:23.040 --> 00:25:25.420
the device should be
charging and should

00:25:25.420 --> 00:25:27.000
be relatively unused.

00:25:27.000 --> 00:25:29.240
Now Android's smart
enough to figure out

00:25:29.240 --> 00:25:31.750
when you are not
actively engaged

00:25:31.750 --> 00:25:33.280
or interacting with your device.

00:25:33.280 --> 00:25:35.360
So it'll wait a little
while, make sure

00:25:35.360 --> 00:25:37.200
that this is a nice
time to schedule

00:25:37.200 --> 00:25:40.210
all of those background jobs,
and it will trigger your job

00:25:40.210 --> 00:25:41.650
right then.

00:25:41.650 --> 00:25:45.000
So we have seen that the
JobScheduler API is really

00:25:45.000 --> 00:25:48.630
important and it will
help you optimize,

00:25:48.630 --> 00:25:51.120
defer, and coalesce your
background activity,

00:25:51.120 --> 00:25:54.870
not just based on battery
constraints or connectivity

00:25:54.870 --> 00:25:57.830
conditions, but also,
in terms of memory.

00:25:57.830 --> 00:26:01.410
So let's take a look at a quick
example of how the JobScheduler

00:26:01.410 --> 00:26:05.180
API works and how easy it
is, in a few lines of code,

00:26:05.180 --> 00:26:07.140
to get your jobs done.

00:26:07.140 --> 00:26:08.940
I'm showing you
a JobInfo object.

00:26:08.940 --> 00:26:11.100
Let's create an object
using a builder.

00:26:11.100 --> 00:26:13.960
We can specify a required
network capability

00:26:13.960 --> 00:26:16.540
to be that of network
type Unmetered.

00:26:16.540 --> 00:26:18.590
Now, what that
typically translates to

00:26:18.590 --> 00:26:21.150
is a network that doesn't
cost the user money.

00:26:21.150 --> 00:26:24.570
And most Wi-Fi networks
fall into that category.

00:26:24.570 --> 00:26:28.540
So in a way, you're specifying
the Wi-Fi connectivity here.

00:26:28.540 --> 00:26:32.980
What you are doing then is,
say I want my job, or my app,

00:26:32.980 --> 00:26:36.840
to sync up with my cloud
backend server every 24 hours.

00:26:36.840 --> 00:26:38.500
It doesn't have
to be by the hour,

00:26:38.500 --> 00:26:40.590
but once every day
is fine for me.

00:26:40.590 --> 00:26:46.030
So what I'm going to do is set
up a periodicity of 24 hours.

00:26:46.030 --> 00:26:47.680
And here comes
the favorite part,

00:26:47.680 --> 00:26:51.540
which is, you do this when
the device is on charger.

00:26:51.540 --> 00:26:54.350
So you specify the set
requires charging constraint.

00:26:54.350 --> 00:26:58.015
And those four lines, you can
schedule a job and it's done.

00:26:58.015 --> 00:27:00.540
Now, Meghan also talked about
something very interesting

00:27:00.540 --> 00:27:03.480
and an extension to
the JobScheduler API

00:27:03.480 --> 00:27:05.810
that we're introducing
in N, and that

00:27:05.810 --> 00:27:07.760
is to take into account
the memory conditions,

00:27:07.760 --> 00:27:09.800
or the RAM conditions
on your device.

00:27:09.800 --> 00:27:12.330
So now, JobScheduler
also supports

00:27:12.330 --> 00:27:15.110
triggers based on
content provider updates.

00:27:15.110 --> 00:27:17.200
So the example that
Meghan gave was,

00:27:17.200 --> 00:27:19.660
if you're trying to take
a picture, or that selfie,

00:27:19.660 --> 00:27:22.380
or of your kid, and
if at that moment,

00:27:22.380 --> 00:27:25.040
you've just taken a picture and
you want to click another shot,

00:27:25.040 --> 00:27:26.596
and if your phone
gets low, then that

00:27:26.596 --> 00:27:28.220
may not be a good
time for you to start

00:27:28.220 --> 00:27:29.520
uploading your pictures.

00:27:29.520 --> 00:27:33.090
And what you can do is now
you can tell JobScheduler

00:27:33.090 --> 00:27:36.610
that I'm listening for this
content provider update

00:27:36.610 --> 00:27:37.910
when a new picture appears.

00:27:37.910 --> 00:27:40.070
But there's a little bit
of wiggle room there.

00:27:40.070 --> 00:27:42.470
It doesn't have to start
right at the very second

00:27:42.470 --> 00:27:43.960
when the picture was taken.

00:27:43.960 --> 00:27:47.300
And the JobScheduler API
is intelligent enough

00:27:47.300 --> 00:27:51.050
to prioritize all of the
jobs for the processes,

00:27:51.050 --> 00:27:53.660
or for the application
that is in the foreground,

00:27:53.660 --> 00:27:55.740
or that is running
foreground service,

00:27:55.740 --> 00:27:58.410
to account for the fact that if
you're interacting with an app,

00:27:58.410 --> 00:28:00.840
all of the jobs for
that particular app

00:28:00.840 --> 00:28:04.390
should get priority, an
automatic priority, or all

00:28:04.390 --> 00:28:08.130
of the other jobs that may
not be as time critical.

00:28:08.130 --> 00:28:12.060
And finally, JobScheduler is
aware of the available RAM

00:28:12.060 --> 00:28:12.930
on your device.

00:28:12.930 --> 00:28:15.020
So depending on how
much RAM is available,

00:28:15.020 --> 00:28:18.422
it might choose to schedule
more than one job at the time.

00:28:18.422 --> 00:28:20.860
Or, if the memory
conditions are not ideal,

00:28:20.860 --> 00:28:23.840
or if you are running
low on memory,

00:28:23.840 --> 00:28:26.300
then only a few jobs, or
the top priority jobs,

00:28:26.300 --> 00:28:29.410
will get scheduled first
before all of the other ones

00:28:29.410 --> 00:28:30.760
get precedence.

00:28:30.760 --> 00:28:32.930
So these changes
are interesting.

00:28:32.930 --> 00:28:35.480
Let's take a look at
a quick code sample

00:28:35.480 --> 00:28:38.850
of how you want to use the
JobScheduler API for something

00:28:38.850 --> 00:28:43.880
like a NEW_PICTURES
content provider update.

00:28:43.880 --> 00:28:47.420
You get an instance of
your JobScheduler service.

00:28:47.420 --> 00:28:49.350
You create a builder object.

00:28:49.350 --> 00:28:52.630
And you specify now, instead
of in the last example,

00:28:52.630 --> 00:28:55.680
where we had specified
constraints on the network type

00:28:55.680 --> 00:28:57.890
and the periodicity,
what we add here

00:28:57.890 --> 00:29:01.400
is a trigger for a ContentUri
update for NEW_PICTURE.

00:29:01.400 --> 00:29:02.990
And you can schedule your job.

00:29:02.990 --> 00:29:03.820
And that's it.

00:29:03.820 --> 00:29:06.180
You're done.

00:29:06.180 --> 00:29:08.200
So this is all good.

00:29:08.200 --> 00:29:12.490
JobScheduler API was introduced
in Lollipop, which was API 21.

00:29:12.490 --> 00:29:15.440
We also have, and have
had for awhile, a backward

00:29:15.440 --> 00:29:20.350
compatibility library,
which lets you do almost all

00:29:20.350 --> 00:29:23.510
of those same things that I
talked about on devices that

00:29:23.510 --> 00:29:25.810
may be running a previous
version of Android,

00:29:25.810 --> 00:29:27.360
or an earlier
version of Android,

00:29:27.360 --> 00:29:29.530
and that is Google
GCMNetworkManager.

00:29:31.971 --> 00:29:32.470
Wait.

00:29:32.470 --> 00:29:34.760
This slide doesn't
say GCMNetworkManager.

00:29:34.760 --> 00:29:35.760
Meghan, what did you do?

00:29:35.760 --> 00:29:36.400
MEGHAN DESAI: Yeah,
yeah, that's right.

00:29:36.400 --> 00:29:38.730
It's actually Firebase
JobDispatcher.

00:29:38.730 --> 00:29:41.410
So today, as part of the
Firebase announcements,

00:29:41.410 --> 00:29:43.690
we're launching
Firebase JobDispatcher,

00:29:43.690 --> 00:29:46.409
which was formerly known
as GCMNetworkManager.

00:29:46.409 --> 00:29:48.200
The cool thing about
Firebase JobDispatcher

00:29:48.200 --> 00:29:49.616
though is that
it's an open source

00:29:49.616 --> 00:29:53.230
SDK that is, effectively,
providing you

00:29:53.230 --> 00:29:54.900
the same capabilities
that JobScheduler

00:29:54.900 --> 00:29:57.530
does in the platform, but in
a backwards compatible way.

00:29:57.530 --> 00:29:59.930
That is, it's a wrapper,
again, for background activity.

00:29:59.930 --> 00:30:01.388
It's available not
only on Android,

00:30:01.388 --> 00:30:03.450
but coming soon, also, on iOS.

00:30:03.450 --> 00:30:07.410
And it, on Android pre-Lollipop,
Google Play Services

00:30:07.410 --> 00:30:10.420
will act as the central
scheduling driver.

00:30:10.420 --> 00:30:13.140
On Lollipop and onwards, where
JobScheduler is available,

00:30:13.140 --> 00:30:14.780
it will just use JobScheduler.

00:30:14.780 --> 00:30:18.004
And then, on iOS, it will
use Grand Central Dispatch.

00:30:18.004 --> 00:30:18.920
So that's pretty cool.

00:30:18.920 --> 00:30:20.350
Let's take a quick
example of what

00:30:20.350 --> 00:30:21.850
JobDispatcher looks
like when you're

00:30:21.850 --> 00:30:23.470
performing background activity.

00:30:23.470 --> 00:30:25.760
So this is a quick example
of creating a simple job

00:30:25.760 --> 00:30:27.912
service that encapsulates
a code you need

00:30:27.912 --> 00:30:29.120
to perform in the background.

00:30:29.120 --> 00:30:31.720
This is the, whatever it is that
your application needs to do,

00:30:31.720 --> 00:30:34.470
in the background, you put
in that doWork function.

00:30:34.470 --> 00:30:40.280
And then, again, very simple,
create a job using the Job

00:30:40.280 --> 00:30:42.600
Builder from the Dispatcher.

00:30:42.600 --> 00:30:44.160
Give it the service
that you just

00:30:44.160 --> 00:30:46.250
created that's wrapping
around all the activity.

00:30:46.250 --> 00:30:48.000
And then, in this case,
I'm just giving it

00:30:48.000 --> 00:30:51.170
a constraint that I want it to
happen on an Unmetered network.

00:30:51.170 --> 00:30:52.390
And then, that's it.

00:30:52.390 --> 00:30:53.370
Then schedule.

00:30:53.370 --> 00:30:55.380
So pretty simple,
very easy to use

00:30:55.380 --> 00:30:58.400
to perform any kind of
background activity.

00:30:58.400 --> 00:31:01.890
So Ashish, we've been talking
a lot about very cool platform

00:31:01.890 --> 00:31:04.595
features, a lot of APIs
that we've introduced.

00:31:04.595 --> 00:31:06.970
And these sound like they're
going to have a huge impact.

00:31:06.970 --> 00:31:08.230
But how can we be
sure that they're

00:31:08.230 --> 00:31:09.520
going to make any difference?

00:31:09.520 --> 00:31:10.350
ASHISH SHARMA:
That's right, Meghan.

00:31:10.350 --> 00:31:12.220
It's not an easy
problem, something

00:31:12.220 --> 00:31:15.290
that I have personally suffered
with, or struggled with,

00:31:15.290 --> 00:31:17.930
for a while, and that is,
how do you really make sure

00:31:17.930 --> 00:31:19.470
that your app is
behaving the way

00:31:19.470 --> 00:31:22.830
that you intend it to be when
it comes to all of these battery

00:31:22.830 --> 00:31:24.774
optimizations?

00:31:24.774 --> 00:31:28.420
Or worse, what if your app
is draining more battery

00:31:28.420 --> 00:31:30.020
than you think it should?

00:31:30.020 --> 00:31:31.540
How do you diagnose that?

00:31:31.540 --> 00:31:34.250
So let me take a quick poll.

00:31:34.250 --> 00:31:37.140
How many of you have tried
diagnosing battery problems

00:31:37.140 --> 00:31:39.602
on your applications?

00:31:39.602 --> 00:31:40.310
MEGHAN DESAI: OK.

00:31:40.310 --> 00:31:40.590
Quite a few.

00:31:40.590 --> 00:31:41.450
ASHISH SHARMA: Some.

00:31:41.450 --> 00:31:45.190
Now, for the others who
did not raise their hands,

00:31:45.190 --> 00:31:47.500
was that because you
found it too hard

00:31:47.500 --> 00:31:49.110
to diagnose battery problems?

00:31:49.110 --> 00:31:52.390
Because I've been
in that same place.

00:31:52.390 --> 00:31:59.426
Well, you can be honest, but, so
diagnosing of battery problems

00:31:59.426 --> 00:32:00.800
can be really
tricky [INAUDIBLE].

00:32:00.800 --> 00:32:03.500
And good thing we have a tool.

00:32:03.500 --> 00:32:05.300
And we have some logs
on the device that

00:32:05.300 --> 00:32:07.590
can help us do that
in an easier fashion

00:32:07.590 --> 00:32:09.830
and not have to struggle
through all of the pain.

00:32:09.830 --> 00:32:13.530
Let's look at some of the
logs, or the types of logs,

00:32:13.530 --> 00:32:15.100
that are present on the device.

00:32:15.100 --> 00:32:17.900
Now, Android maintains
data structure

00:32:17.900 --> 00:32:20.790
in memory on all devices.

00:32:20.790 --> 00:32:23.730
And this log is
called Batterystats.

00:32:23.730 --> 00:32:27.950
Now, what Batterystats is is it
is a set of cumulative counters

00:32:27.950 --> 00:32:32.500
that go on incrementing while
your device is on battery.

00:32:32.500 --> 00:32:34.974
So since it's in
memory, and these

00:32:34.974 --> 00:32:36.890
are cumulative counters
that go on increasing,

00:32:36.890 --> 00:32:38.680
they need to get
reset at some point.

00:32:38.680 --> 00:32:41.420
And that point is when you've
fully charged your device,

00:32:41.420 --> 00:32:42.830
and you've just unplugged it.

00:32:42.830 --> 00:32:46.240
So say, for example, you
charge your device overnight.

00:32:46.240 --> 00:32:48.450
And you unplugged it
at 7 AM in the morning.

00:32:48.450 --> 00:32:52.450
And maybe it's about 10 and
a half hours since then.

00:32:52.450 --> 00:32:54.830
If you take a bug report
on your device now,

00:32:54.830 --> 00:32:57.570
then it would contain the whole
10 and a half hours' worth

00:32:57.570 --> 00:33:02.110
of Batterystats and counters
about various things happening

00:33:02.110 --> 00:33:05.090
on your device that we think
are relevant with respect

00:33:05.090 --> 00:33:06.160
to battery life.

00:33:06.160 --> 00:33:08.890
So things like how long
was the partial Wakelock

00:33:08.890 --> 00:33:11.090
held on the device
across all applications

00:33:11.090 --> 00:33:13.100
and on an application basis?

00:33:13.100 --> 00:33:15.890
Or how much data was transferred
over the mobile network

00:33:15.890 --> 00:33:17.430
or the Wi-Fi network?

00:33:17.430 --> 00:33:20.100
And what you can see
here is there's also

00:33:20.100 --> 00:33:23.002
a StartClock time which tells
you exactly when the stats were

00:33:23.002 --> 00:33:23.750
reset.

00:33:23.750 --> 00:33:25.250
So this is really
useful when you're

00:33:25.250 --> 00:33:29.070
trying to look at what all
happened on your device that

00:33:29.070 --> 00:33:31.450
may have caused the
battery to drain faster

00:33:31.450 --> 00:33:33.160
than what you would expect.

00:33:33.160 --> 00:33:35.820
The other type of log that
is present on the device

00:33:35.820 --> 00:33:38.130
is something that we
call Battery History.

00:33:38.130 --> 00:33:40.840
And what this is,
it is an event log

00:33:40.840 --> 00:33:45.550
of all of the state transitions
for components on your device,

00:33:45.550 --> 00:33:48.060
or for actions like
scheduling a wakelock,

00:33:48.060 --> 00:33:51.010
or an application
scheduling a job,

00:33:51.010 --> 00:33:54.350
or the device going into
suspend, coming out of suspend,

00:33:54.350 --> 00:33:57.020
or maybe it's the network
radio that got turned on.

00:33:57.020 --> 00:33:59.360
So there's a lot of
information here.

00:33:59.360 --> 00:34:03.130
And this would contain an event
log of a millisecond level

00:34:03.130 --> 00:34:06.640
granularity of everything
that happened on your device

00:34:06.640 --> 00:34:08.250
since the stats were reset.

00:34:08.250 --> 00:34:09.659
MEGHAN DESAI: A millisecond
level granularity?

00:34:09.659 --> 00:34:11.530
You're telling me that
I have to look at this

00:34:11.530 --> 00:34:13.270
to figure out what's going
on with the battery life

00:34:13.270 --> 00:34:13.880
on my device?

00:34:13.880 --> 00:34:14.320
ASHISH SHARMA: Yes.

00:34:14.320 --> 00:34:15.500
MEGHAN DESAI: There's going
to be hundreds of thousands

00:34:15.500 --> 00:34:16.385
of lines of this.

00:34:16.385 --> 00:34:18.260
ASHISH SHARMA: Well,
but it's fairly obvious.

00:34:18.260 --> 00:34:20.030
You can just make out
what the problem is.

00:34:20.030 --> 00:34:21.810
MEGHAN DESAI: Well, can I?

00:34:21.810 --> 00:34:23.520
ASHISH SHARMA: No,
I'm just kidding.

00:34:23.520 --> 00:34:25.630
We have a tool
that helps us make

00:34:25.630 --> 00:34:27.170
sense of this entire thing.

00:34:27.170 --> 00:34:29.469
And that's called
Battery Historian.

00:34:29.469 --> 00:34:31.190
Many of you might
be aware of this.

00:34:31.190 --> 00:34:33.672
And what this tool would
do is it would take

00:34:33.672 --> 00:34:35.130
all of those logs
that are present,

00:34:35.130 --> 00:34:36.800
the two logs that
I just mentioned

00:34:36.800 --> 00:34:38.510
that are present
in the bug report,

00:34:38.510 --> 00:34:40.170
and it would help
you look at them

00:34:40.170 --> 00:34:45.469
in a very intuitive and
interactive UI that makes clear

00:34:45.469 --> 00:34:47.790
what the problem
is on the device.

00:34:47.790 --> 00:34:48.370
So Meghan--

00:34:48.370 --> 00:34:49.120
MEGHAN DESAI: Wow.

00:34:49.120 --> 00:34:49.969
That's pretty cool.

00:34:49.969 --> 00:34:50.469
I like this.

00:34:50.469 --> 00:34:51.218
I like this a lot.

00:34:51.218 --> 00:34:53.179
So where do I see this though?

00:34:53.179 --> 00:34:55.090
Is this on my device
and setting somewhere?

00:34:55.090 --> 00:34:56.080
ASHISH SHARMA: No.

00:34:56.080 --> 00:34:58.080
I know you have a very
cool and powerful device,

00:34:58.080 --> 00:35:02.310
but going through these hundreds
of thousands of transitions

00:35:02.310 --> 00:35:03.920
on your small little
screen may not

00:35:03.920 --> 00:35:06.490
be a very pleasant experience,
especially when you're

00:35:06.490 --> 00:35:08.910
trying to diagnose battery
problems with your apps.

00:35:08.910 --> 00:35:11.440
So what this is
is, let me walk you

00:35:11.440 --> 00:35:13.910
through the workflow
of how this tool works.

00:35:13.910 --> 00:35:16.690
It is an open source
tool available on GitHub,

00:35:16.690 --> 00:35:17.900
ready for you to download.

00:35:17.900 --> 00:35:19.800
And you can look
at the source code,

00:35:19.800 --> 00:35:21.810
modify it any
which way you want.

00:35:21.810 --> 00:35:24.220
What you do is, you install
it on your computer.

00:35:24.220 --> 00:35:26.130
Now, you have your
development device

00:35:26.130 --> 00:35:29.960
on which you, for the
stats to be recent,

00:35:29.960 --> 00:35:32.110
because you want to have
a good starting point,

00:35:32.110 --> 00:35:34.850
you can either charge
the device up to 100%

00:35:34.850 --> 00:35:37.930
when the stats would get reset,
or there is an ADB command

00:35:37.930 --> 00:35:39.810
to actually manually
reset the start so you

00:35:39.810 --> 00:35:42.370
have a good initiation point.

00:35:42.370 --> 00:35:43.870
You can run your
experiment, which

00:35:43.870 --> 00:35:47.000
might last a few minutes,
or maybe a couple of hours.

00:35:47.000 --> 00:35:49.050
And at the end of it,
you take a bug report.

00:35:49.050 --> 00:35:51.760
And then, you upload that
bug report on your computer

00:35:51.760 --> 00:35:53.770
that you have the
Battery Historian tool

00:35:53.770 --> 00:35:59.860
to go back to this interactive,
visual interpretation of all

00:35:59.860 --> 00:36:01.139
the state transitions.

00:36:01.139 --> 00:36:01.930
MEGHAN DESAI: Cool.

00:36:01.930 --> 00:36:04.596
ASHISH SHARMA: So now that we're
clear on how the workflow works

00:36:04.596 --> 00:36:06.220
for Battery Historian,
I'd like you

00:36:06.220 --> 00:36:11.190
to come with me on a
slight tour of what

00:36:11.190 --> 00:36:13.090
are the features of this tool.

00:36:13.090 --> 00:36:16.980
Let's zoom into one of the
rows, or a few of these rows.

00:36:16.980 --> 00:36:20.040
What you're seeing is the top
line, which is CPU running.

00:36:20.040 --> 00:36:22.400
And what this indicates
is it indicates

00:36:22.400 --> 00:36:24.200
is whether your
device was in suspend,

00:36:24.200 --> 00:36:25.300
or was it out of suspend?

00:36:25.300 --> 00:36:28.390
So the solid black bars are
when your device was actually

00:36:28.390 --> 00:36:30.600
out of suspend and
doing some activity.

00:36:30.600 --> 00:36:32.230
Similarly, you can
see things like when

00:36:32.230 --> 00:36:35.910
was a Userspace Wakelock held
or when the screen was on.

00:36:35.910 --> 00:36:39.200
And the information about
any of your jobs or syncs

00:36:39.200 --> 00:36:40.740
will also appear here.

00:36:40.740 --> 00:36:45.140
And in this UI, you can zoom
in to every little event

00:36:45.140 --> 00:36:47.490
that you see, no
matter how long.

00:36:47.490 --> 00:36:49.980
And if you take your
cursor over that,

00:36:49.980 --> 00:36:51.910
it will show you a nice tutor.

00:36:51.910 --> 00:36:55.180
So say, for example, we are
at this point in the UI.

00:36:55.180 --> 00:36:56.220
We have zoomed in.

00:36:56.220 --> 00:36:58.890
And it tells me exactly
what the current time

00:36:58.890 --> 00:37:01.270
was at this instance.

00:37:01.270 --> 00:37:03.680
And the red
highlighted portion now

00:37:03.680 --> 00:37:07.860
shows you the battery
level drop from 73 to 72

00:37:07.860 --> 00:37:10.510
and how long it
took for the device

00:37:10.510 --> 00:37:13.120
to discharge from
73 to 72, giving you

00:37:13.120 --> 00:37:14.950
an indication of what
the average discharge

00:37:14.950 --> 00:37:16.400
rate was during that time.

00:37:16.400 --> 00:37:19.340
And you can see all of the
events lined up nicely.

00:37:19.340 --> 00:37:21.920
So you can actually
figure out when

00:37:21.920 --> 00:37:24.040
your device was discharging
rather fast, what

00:37:24.040 --> 00:37:27.430
were the events that were
happening on the device?

00:37:27.430 --> 00:37:29.710
Let me take you through
another example.

00:37:29.710 --> 00:37:32.060
So say you have
adopted or migrated

00:37:32.060 --> 00:37:34.580
your app to start
using JobScheduler now.

00:37:34.580 --> 00:37:38.470
How do you figure out when your
jobs are getting scheduled?

00:37:38.470 --> 00:37:42.220
So in the JobScheduler row, you
go on any one of those events.

00:37:42.220 --> 00:37:43.900
And if you are in
a zoomed out view,

00:37:43.900 --> 00:37:47.530
it might collapse a bunch
of these little jobs that

00:37:47.530 --> 00:37:49.150
didn't last as long.

00:37:49.150 --> 00:37:51.530
But it will give you
information about how many jobs

00:37:51.530 --> 00:37:54.940
were run in that particular
small box and for how long

00:37:54.940 --> 00:37:56.400
each of those jobs ran.

00:37:56.400 --> 00:37:58.380
And you can zoom in if you like.

00:37:58.380 --> 00:38:03.140
So it's a very
interactive and fun tool.

00:38:03.140 --> 00:38:05.070
I have a lot of
fun playing with it

00:38:05.070 --> 00:38:07.440
and diagnosing all
the battery problems.

00:38:07.440 --> 00:38:13.350
What I want you to do is look
at an example of Doze in action.

00:38:13.350 --> 00:38:16.670
So we've been talking about the
Doze mode in Marshmallow that

00:38:16.670 --> 00:38:21.210
was introduced and the lighter
version of Doze that was

00:38:21.210 --> 00:38:24.160
introduced in the N-release.

00:38:24.160 --> 00:38:27.030
So what I'm showing you
here is a bug report

00:38:27.030 --> 00:38:29.210
that I uploaded to the
Battery Historian tool.

00:38:29.210 --> 00:38:31.960
And the black line that
you see going down that's

00:38:31.960 --> 00:38:35.590
not exactly horizontal, that's
your instantaneous battery

00:38:35.590 --> 00:38:36.280
level.

00:38:36.280 --> 00:38:38.790
So typically, it would start
off with something high

00:38:38.790 --> 00:38:40.530
if you started with 100%.

00:38:40.530 --> 00:38:43.650
In this case, I manually
reset the stats.

00:38:43.650 --> 00:38:45.930
It starts somewhere around 50%.

00:38:45.930 --> 00:38:48.940
And then, what you
can see is, let's zoom

00:38:48.940 --> 00:38:51.010
into this little area.

00:38:51.010 --> 00:38:53.640
When your screen
was on, you can see

00:38:53.640 --> 00:38:57.250
that the frequency of your
jobs and syncs was fairly high.

00:38:57.250 --> 00:38:59.690
All of the jobs and
syncs were getting

00:38:59.690 --> 00:39:01.780
scheduled fairly periodically.

00:39:01.780 --> 00:39:04.600
But then, after the
screen has been turned off

00:39:04.600 --> 00:39:08.000
for a while, what you see in
the Doze line, or the Doze row,

00:39:08.000 --> 00:39:12.290
in orange, that's the lighter
version of Doze kicking in.

00:39:12.290 --> 00:39:15.310
So some applications
would lose network access.

00:39:15.310 --> 00:39:18.070
And you start to see that
now your jobs and your syncs

00:39:18.070 --> 00:39:21.480
are beginning to get
less and less frequent.

00:39:21.480 --> 00:39:23.970
And they're getting
batched together.

00:39:23.970 --> 00:39:27.940
And further out, after the
device has had its screen off

00:39:27.940 --> 00:39:30.080
for a while, and it
has been stationary,

00:39:30.080 --> 00:39:33.550
you see the device entering
this deeper Doze mode, which

00:39:33.550 --> 00:39:35.280
is shown in the blue row here.

00:39:35.280 --> 00:39:37.910
And when that
happens, now, we know

00:39:37.910 --> 00:39:40.210
that the device is not
being touched by the user,

00:39:40.210 --> 00:39:41.490
is not being used.

00:39:41.490 --> 00:39:43.950
And that's an opportunity
for the JobScheduler API

00:39:43.950 --> 00:39:47.570
to start throttling and batching
together a lot of the activity.

00:39:47.570 --> 00:39:50.430
So you see that
under the blue bars,

00:39:50.430 --> 00:39:52.650
the JobScheduler and the
SyncManager frequency

00:39:52.650 --> 00:39:54.100
is fairly infrequent.

00:39:54.100 --> 00:39:59.140
And they get scheduled during
the maintenance windows.

00:39:59.140 --> 00:40:01.510
Now, what's really
interesting is--

00:40:01.510 --> 00:40:05.200
and this slide will help you
get a perspective on what

00:40:05.200 --> 00:40:07.930
uses the most power on
your phones-- initially,

00:40:07.930 --> 00:40:10.380
when the screen was
on, my battery level

00:40:10.380 --> 00:40:11.826
was discharging really fast.

00:40:11.826 --> 00:40:13.200
So you see the
slope of the line?

00:40:13.200 --> 00:40:16.600
That's my battery level going
from 50 to maybe 30 very

00:40:16.600 --> 00:40:17.620
quickly.

00:40:17.620 --> 00:40:19.950
And after the screen
has been turned off

00:40:19.950 --> 00:40:21.920
and the Doze mode
has kicked in, that's

00:40:21.920 --> 00:40:24.150
when you start to see
that now my battery is not

00:40:24.150 --> 00:40:25.370
declining as fast.

00:40:25.370 --> 00:40:28.860
And it might have even lasted me
a couple of hours in that state

00:40:28.860 --> 00:40:31.050
without discharging a
whole lot of battery.

00:40:31.050 --> 00:40:32.820
And then, towards
the end, as soon

00:40:32.820 --> 00:40:35.720
as the screen is
turned back on, we

00:40:35.720 --> 00:40:37.830
see that the device
exited the Doze mode.

00:40:37.830 --> 00:40:39.720
And you go back to
that steep discharge

00:40:39.720 --> 00:40:42.302
of when I'm actually playing
a game or watching a video.

00:40:42.302 --> 00:40:44.010
MEGHAN DESAI: That's
pretty cool, Ashish.

00:40:44.010 --> 00:40:46.176
So all that stuff we were
talking about, coalescing,

00:40:46.176 --> 00:40:49.050
and deferring background
activity during Doze actually

00:40:49.050 --> 00:40:49.620
works.

00:40:49.620 --> 00:40:51.386
ASHISH SHARMA: That
is living proof.

00:40:51.386 --> 00:40:52.760
MEGHAN DESAI:
That's pretty cool.

00:40:52.760 --> 00:40:53.250
ASHISH SHARMA: OK.

00:40:53.250 --> 00:40:54.860
So the next thing
I want to show you

00:40:54.860 --> 00:40:58.180
is, I talked about
these accumulated stats.

00:40:58.180 --> 00:41:00.770
So the same tool, what
it would help you do

00:41:00.770 --> 00:41:02.560
is, once you've
uploaded the bug report,

00:41:02.560 --> 00:41:06.590
it will now show you all of this
information that was collected

00:41:06.590 --> 00:41:09.000
on the device, so
which jobs were

00:41:09.000 --> 00:41:11.200
run, for how long
they were run, which

00:41:11.200 --> 00:41:14.430
application required Wakelocks,
and for how long they did.

00:41:14.430 --> 00:41:17.430
And in general, for
the entire device,

00:41:17.430 --> 00:41:19.340
there's a whole bunch
of information here,

00:41:19.340 --> 00:41:22.060
such as the mobile radio
activity, which application

00:41:22.060 --> 00:41:24.850
used the most amount
of mobile traffic

00:41:24.850 --> 00:41:27.710
or Wi-Fi, number of Wi-Fi scans.

00:41:27.710 --> 00:41:30.540
And it helps you
get a good overview

00:41:30.540 --> 00:41:33.060
in a very quick
fashion on what exactly

00:41:33.060 --> 00:41:34.379
happened with your device.

00:41:34.379 --> 00:41:35.420
MEGHAN DESAI: So hold on.

00:41:35.420 --> 00:41:36.640
This has all been pretty cool.

00:41:36.640 --> 00:41:39.306
But I thought you said that this
was going to help me figure out

00:41:39.306 --> 00:41:40.759
issues with my application.

00:41:40.759 --> 00:41:41.550
ASHISH SHARMA: Yes.

00:41:41.550 --> 00:41:42.980
MEGHAN DESAI: Can I
do that with this?

00:41:42.980 --> 00:41:44.105
ASHISH SHARMA: Yes, Meghan.

00:41:44.105 --> 00:41:46.580
That leads me to
my very next slide,

00:41:46.580 --> 00:41:48.810
which is, there is an
App Selection bar there.

00:41:48.810 --> 00:41:52.210
So you can actually search for
your app and pick your app.

00:41:52.210 --> 00:41:55.580
And the moment you've done that,
you get taken to this App Stats

00:41:55.580 --> 00:41:58.880
view, which tells you all of
this same information just

00:41:58.880 --> 00:41:59.990
for your app.

00:41:59.990 --> 00:42:01.900
So you can look at
all the jobs that

00:42:01.900 --> 00:42:04.680
got fired, what all
processes you were running,

00:42:04.680 --> 00:42:07.080
how much mobile
data, or Wi-Fi data,

00:42:07.080 --> 00:42:10.680
sensors, all the good stuff
just there for your app.

00:42:10.680 --> 00:42:13.020
And the very cool thing
that I don't have it

00:42:13.020 --> 00:42:15.650
here in the slides is once
you've picked your application,

00:42:15.650 --> 00:42:19.260
if you go back and look to the
UI of the timeline of events,

00:42:19.260 --> 00:42:23.780
you will see that in the job
row, or the JobScheduler row,

00:42:23.780 --> 00:42:27.160
or the Sync row, only the jobs
and syncs for your applications

00:42:27.160 --> 00:42:27.820
will appear.

00:42:27.820 --> 00:42:29.790
And all else will disappear.

00:42:29.790 --> 00:42:34.250
So that can really get you a
visibility into how frequently

00:42:34.250 --> 00:42:38.000
your application was
scheduling all of these tasks.

00:42:38.000 --> 00:42:41.020
So we found this tool
to be very useful.

00:42:41.020 --> 00:42:45.010
But there is one case that has
been especially painful for me.

00:42:45.010 --> 00:42:48.160
And that is, when you
are developing an app,

00:42:48.160 --> 00:42:50.480
or say you made a
change in your app,

00:42:50.480 --> 00:42:54.740
and suddenly your device
is discharging very fast.

00:42:54.740 --> 00:42:56.070
Now, I write perfect code.

00:42:56.070 --> 00:42:57.570
I never make mistakes.

00:42:57.570 --> 00:42:59.670
But then, my device
is discharging fast.

00:42:59.670 --> 00:43:00.640
What did I do?

00:43:00.640 --> 00:43:05.150
And I'm in this position more
than I would like to admit.

00:43:05.150 --> 00:43:10.540
And I'm sure a lot of us have
been in this situation for one,

00:43:10.540 --> 00:43:11.750
or the other, time.

00:43:11.750 --> 00:43:14.275
And so for that, what we
have is an A/B Comparison

00:43:14.275 --> 00:43:15.700
mode in the same tool.

00:43:15.700 --> 00:43:19.130
So what you can do is you
can upload two bug reports.

00:43:19.130 --> 00:43:22.100
And if you have a good case
and you have a bad case,

00:43:22.100 --> 00:43:23.670
then what the tool
will let you do

00:43:23.670 --> 00:43:25.810
is it will highlight
all the biggest

00:43:25.810 --> 00:43:29.530
differences that it sees
between these two bug reports.

00:43:29.530 --> 00:43:32.220
So say, for example,
it's comparing now

00:43:32.220 --> 00:43:34.100
file 1 versus file 2.

00:43:34.100 --> 00:43:36.220
And it's telling
me that in file 1,

00:43:36.220 --> 00:43:40.400
it has used 7.5 times more
Wi-Fi data than the others.

00:43:40.400 --> 00:43:42.860
And the screen off
discharge rate on,

00:43:42.860 --> 00:43:45.570
let's say, the first one,
was less than 2.5 times,

00:43:45.570 --> 00:43:47.080
and a whole lot of
other good stuff.

00:43:47.080 --> 00:43:49.570
I haven't shown you
all of the detail.

00:43:49.570 --> 00:43:51.510
But if you upload
two bug reports,

00:43:51.510 --> 00:43:54.290
it will automatically normalize
those two bug reports.

00:43:54.290 --> 00:43:56.280
So say, if you have
one bug report that

00:43:56.280 --> 00:43:58.780
was taken for four hours, and
the other that was at two,

00:43:58.780 --> 00:44:01.827
it will automatically
normalize all of that

00:44:01.827 --> 00:44:03.910
and show you a good
comparison, which can give you

00:44:03.910 --> 00:44:06.385
a very good starting point
as to what actually changed

00:44:06.385 --> 00:44:08.390
on the device, whether
it was really my app,

00:44:08.390 --> 00:44:11.140
or some other app started
doing something that may have

00:44:11.140 --> 00:44:13.340
accounted for this difference.

00:44:13.340 --> 00:44:16.040
So that's an interesting mode.

00:44:16.040 --> 00:44:19.840
And to wrap up, I'd
like you to look

00:44:19.840 --> 00:44:23.670
at one last feature
on this tool, which

00:44:23.670 --> 00:44:25.220
is my personal favorite.

00:44:25.220 --> 00:44:27.900
And this is for the
true geeks out there.

00:44:27.900 --> 00:44:30.080
So if you have a
phone, and if you

00:44:30.080 --> 00:44:32.730
were able to modify your
phone to connect it to a power

00:44:32.730 --> 00:44:34.650
monitor, and say
you were recording

00:44:34.650 --> 00:44:38.150
the instantaneous current values
when the device was actually

00:44:38.150 --> 00:44:38.870
running.

00:44:38.870 --> 00:44:41.780
What you can do is you
can upload a bug report,

00:44:41.780 --> 00:44:44.150
and you can upload
these power readings,

00:44:44.150 --> 00:44:45.980
these instantaneous
current values,

00:44:45.980 --> 00:44:47.650
to the Battery Historian tool.

00:44:47.650 --> 00:44:50.116
And it will show
you a nice overlay

00:44:50.116 --> 00:44:53.020
of what your instantaneous
current draw was

00:44:53.020 --> 00:44:55.340
and what the device was
actually doing at the time.

00:44:55.340 --> 00:44:58.810
So here's, you know, this
is where for me, at least,

00:44:58.810 --> 00:44:59.890
all of it comes together.

00:44:59.890 --> 00:45:02.410
So you see when the CPA
was running, indicated

00:45:02.410 --> 00:45:04.670
in the black bars in
the top row, that's

00:45:04.670 --> 00:45:06.470
when your instantaneous
current draw was

00:45:06.470 --> 00:45:08.890
close to 800 milliamperes.

00:45:08.890 --> 00:45:11.190
But when the device
was in suspend,

00:45:11.190 --> 00:45:12.384
it was hardly anything.

00:45:12.384 --> 00:45:13.550
You can't even see it there.

00:45:13.550 --> 00:45:15.820
Because it's close to
about 4-5 milliamps.

00:45:15.820 --> 00:45:19.430
So there's several orders
of magnitude difference

00:45:19.430 --> 00:45:22.780
in the amount of power that's
discharged from your phone

00:45:22.780 --> 00:45:24.450
when you're actively
doing stuff.

00:45:24.450 --> 00:45:29.210
And when you do this, when
you use the JobScheduler API

00:45:29.210 --> 00:45:31.570
and start batching together
a lot of the activity,

00:45:31.570 --> 00:45:36.100
well, it's not hard to see that
your phone will now last much

00:45:36.100 --> 00:45:41.010
longer and really take away the
pain from having a device that

00:45:41.010 --> 00:45:41.920
doesn't last as long.

00:45:41.920 --> 00:45:43.730
MEGHAN DESAI: That's
really cool, Ashish.

00:45:43.730 --> 00:45:45.110
I'd love to have an
amp meter to look

00:45:45.110 --> 00:45:46.230
at what's going on my phone.

00:45:46.230 --> 00:45:46.390
ASHISH SHARMA: Yeah.

00:45:46.390 --> 00:45:48.980
There are detailed instructions
of this on the GitHub website

00:45:48.980 --> 00:45:50.230
on how to actually hook it up.

00:45:50.230 --> 00:45:51.559
So try it out if you like.

00:45:51.559 --> 00:45:52.350
MEGHAN DESAI: Cool.

00:45:52.350 --> 00:45:53.521
So what's next?

00:45:53.521 --> 00:45:56.020
Well, you saw how these simple
design principles that Ashish

00:45:56.020 --> 00:45:58.099
talked about, Reduce,
Defer, and Coalesce,

00:45:58.099 --> 00:46:00.390
go a long way in improving
battery life and performance

00:46:00.390 --> 00:46:01.065
of the device.

00:46:01.065 --> 00:46:02.440
So here's what we
want you to do.

00:46:02.440 --> 00:46:04.106
We want you to reduce
all the background

00:46:04.106 --> 00:46:05.690
activity in your applications.

00:46:05.690 --> 00:46:08.987
What you can't reduce, defer it
to when the device is charging.

00:46:08.987 --> 00:46:11.320
And what you can't defer to
when the device is charging,

00:46:11.320 --> 00:46:13.611
at least help us coalesce it
with other activity that's

00:46:13.611 --> 00:46:14.890
going on in the background.

00:46:14.890 --> 00:46:16.306
So go out there
and figure out how

00:46:16.306 --> 00:46:18.620
to use JobScheduler and
JobDispatcher instead

00:46:18.620 --> 00:46:20.080
of using background services.

00:46:20.080 --> 00:46:22.780
We actually have a
code lab up to walk you

00:46:22.780 --> 00:46:25.610
through some key use
cases around migrating

00:46:25.610 --> 00:46:27.840
from services to JobScheduler.

00:46:27.840 --> 00:46:30.690
Check out Battery Historian,
as Ashish mentioned.

00:46:30.690 --> 00:46:33.050
We also want you to start
removing your dependencies

00:46:33.050 --> 00:46:34.890
in your applications
on statically declared

00:46:34.890 --> 00:46:37.620
implicit broadcast receivers,
as well as on any background

00:46:37.620 --> 00:46:39.020
services, again.

00:46:39.020 --> 00:46:40.770
And send us any
feedback as you're

00:46:40.770 --> 00:46:43.080
doing that on where you
are unable to do that using

00:46:43.080 --> 00:46:44.964
JobScheduler or JobDispatcher.

00:46:44.964 --> 00:46:46.255
We would love to hear from you.

00:46:46.255 --> 00:46:48.900
We want to get there together.

00:46:48.900 --> 00:46:50.614
So with that, if you
have any questions,

00:46:50.614 --> 00:46:52.655
you can join us at office
hours right after this,

00:46:52.655 --> 00:46:57.740
at 6 o'clock on stage 9, as
well as tomorrow and Friday.

00:46:57.740 --> 00:46:59.910
Thank you so much for
being here this late.

00:46:59.910 --> 00:47:00.710
ASHISH SHARMA: Thank
you for coming.

00:47:00.710 --> 00:47:01.910
[APPLAUSE]

00:47:01.910 --> 00:47:07.660
[MUSIC PLAYING]

