WEBVTT
Kind: captions
Language: en

00:11:24.860 --> 00:11:26.368
 And you can see an example up 
here

00:11:26.369 --> 00:11:28.794
  on the slide  of kind of what
  this looks like with a sample

00:11:29.102 --> 00:11:31.420
  that we  built for a recipe 
recommendation

00:11:31.421 --> 00:11:33.652
  app.  And essentially,  what 
you

00:11:33.653 --> 00:11:37.384
  provide is you give the tool a
  list of phrases  or sentences

00:11:37.696 --> 00:11:39.919
  that you expect the user to 
say.

00:11:39.920 --> 00:11:45.163
 And you  can see that API.AI is
  automatically highlighting  

00:11:45.164 --> 00:11:47.279
individual
  entities out of those elements

00:11:47.686 --> 00:11:49.814
  that are  actually interesting
  to your application.  So for 

00:11:49.815 --> 00:11:52.244
this
   case, it's a recipe 

00:11:52.245 --> 00:11:53.857
recommendation,
  so we're looking for  things 

00:11:53.858 --> 00:11:56.382
like
  a protein, a temperature, a 

00:11:56.383 --> 00:11:59.830
type
  of dish,  and all of these 

00:11:59.831 --> 00:12:01.029
things
  are just recognized  

00:12:01.030 --> 00:12:04.560
automatically
  by API.AI.  Now, the other 

00:12:04.561 --> 00:12:06.074
really
  nice  thing about this tool is

00:12:06.075 --> 00:12:08.313
  you don't have to pick every  
single

00:12:08.314 --> 00:12:09.426
  element that you think the 
user

00:12:09.427 --> 00:12:11.233
  might say.   Because of the 
machine

00:12:11.234 --> 00:12:12.747
  learning element to this 
system,

00:12:12.748 --> 00:12:15.479
   you simply have to provide a
  number of samples up front  

00:12:15.480 --> 00:12:18.011
and
  then the system can 

00:12:18.012 --> 00:12:20.124
interpolate
  and interpret what a  user 

00:12:20.125 --> 00:12:21.755
might
  say so that you only have to 

00:12:21.756 --> 00:12:23.468
give
  it some  additional data and 

00:12:23.469 --> 00:12:26.392
then
  API.AI will always do the 

00:12:26.393 --> 00:12:28.393
right
   thing picking out all of it.

00:12:28.710 --> 00:12:30.928
 And then your back-end  
applications

00:12:30.929 --> 00:12:33.664
  has to simply respond to that
  structured  data.  So you no 

00:12:33.665 --> 00:12:35.299
longer
  have to try to interpret out 

00:12:35.300 --> 00:12:38.715
of
   the string the information 

00:12:38.716 --> 00:12:39.725
that
  you need.

00:12:39.726 --> 00:12:43.075
We've also announced the Google
  Assistant SCK,  which allows 

00:12:43.076 --> 00:12:44.375
you
  to because he had the Google 

00:12:44.376 --> 00:12:45.816
Assistant
   directly into your custom 

00:12:45.817 --> 00:12:47.215
hardware
  projects.  We provide  out of

00:12:47.216 --> 00:12:50.866
  the box support for Linux and
  Android things.   But the API

00:12:51.041 --> 00:12:56.104
  is based on GRPZ, so you could
  pretty much  import it to 

00:12:56.105 --> 00:12:57.935
anything.
 You can either use a button  

00:12:57.936 --> 00:12:59.883
trigger
  to trigger the assistant, or 

00:12:59.884 --> 00:13:02.985
you
  can use a  library for support

00:13:03.790 --> 00:13:05.418
.
 You can trigger it just like we

00:13:05.419 --> 00:13:06.745
  do  with consumer devices.  
All

00:13:06.746 --> 00:13:09.061
  you have to do is provide a  
microphone

00:13:09.062 --> 00:13:10.368
  and a speaker, and then you 
can

00:13:10.369 --> 00:13:14.605
  use the  actions on Google to
  implement additional 

00:13:14.606 --> 00:13:18.045
functionality,
   such as device control.

00:13:23.996 --> 00:13:27.029
.  Device
  makers can easily  integrate 

00:13:27.030 --> 00:13:29.245
devices
  with our home graph.  Home 

00:13:29.246 --> 00:13:30.965
graph
  knows  the state of all 

00:13:30.966 --> 00:13:32.190
connected
  devices so that when you ask  

00:13:32.191 --> 00:13:33.593
it
  to dim the lights just a 

00:13:33.594 --> 00:13:35.415
little
  bit, it knows how to  do that

00:13:35.416 --> 00:13:39.487
  in an intelligent way.  The 
user

00:13:39.488 --> 00:13:41.488
  makes

00:13:42.874 --> 00:13:48.349
 acquires  and then smart home 
controls those devices.  As a 

00:13:48.350 --> 00:13:51.564
device  maker, you don't have to
 worry about handleing with all 

00:13:51.565 --> 00:13:55.215
 of that speech input, just with
 requests with very  specific 

00:13:55.216 --> 00:13:59.762
values.  The user speaks what it
 wants and  smart home 

00:13:59.763 --> 00:14:02.275
coordinates across all their 
devices across  the home.  Even 

00:14:02.276 --> 00:14:07.936
across different device makers.
Firebase also has an amazing 

00:14:07.937 --> 00:14:10.871
suite of applications  and 
services that are useful for IOT

00:14:11.167 --> 00:14:14.211
.  Realtime database database, 
for example, makes it easy to 

00:14:14.212 --> 00:14:17.834
synchronize the  state of 
various devices across a mobile 

00:14:17.835 --> 00:14:22.975
app and between  various IOT 
devices in your application.  

00:14:22.976 --> 00:14:28.638
Authentication  is another 
example that enablers us to 

00:14:28.639 --> 00:14:31.575
associate devices  with the user
's account.  And with, boy, 

00:14:31.576 --> 00:14:35.715
things, all of  these are easier
 with IOT because it can use the

00:14:36.015 --> 00:14:40.860
 same  existing libraries and 
SDKs right on this devices.

00:14:44.497 --> 00:14:48.224
We also announced core back at I
O.  This is a  fully-managed 

00:14:48.225 --> 00:14:53.702
service on Google Cloud platform
 that  allows you to connect 

00:14:53.703 --> 00:14:56.620
millions of devices directly 
over  Google cloud.  Whether you

00:14:56.623 --> 00:14:58.945
 want to connect millions of  
devices and scale them 

00:14:58.946 --> 00:15:01.575
automatically, you have no need 
 to worry about provisioning the

00:15:01.775 --> 00:15:06.839
 infrastructure or adding  
visual.  It has native support 

00:15:06.840 --> 00:15:11.883
for standard protocols,  and you
 can access all of your

00:15:16.320 --> 00:15:20.779
 data globally disbursed  as one
 system.  It's great for maps 

00:15:20.780 --> 00:15:23.899
scale type of  provisioning.  
This is converse with the 

00:15:23.900 --> 00:15:27.853
Firebase user  case which works 
for individual user type cases. 

00:15:27.854 --> 00:15:29.857
 You  can use cloud services 
that are part of the cloud  

00:15:29.858 --> 00:15:35.717
platform, so BigQuery to analyze
 your massive scale data  and 

00:15:35.718 --> 00:15:41.670
visualize that for internal use 
as well.

00:15:41.933 --> 00:15:44.771
So that's sort of a whirlwind 
tour of all the  different 

00:15:44.772 --> 00:15:48.142
services that we have available 
for IOT and  the Google 

00:15:48.143 --> 00:15:51.161
Assistant.  I want you to be 
sure to play  with all of the 

00:15:51.162 --> 00:15:54.500
demos that we have in the IOT 
sandbox  and the assistant 

00:15:54.501 --> 00:15:57.532
sandbox, and our team will be on
 hand  to answer questions as 

00:15:57.533 --> 00:15:59.762
well.
Immediately following this 

00:15:59.763 --> 00:16:03.900
session, I'm headed  over to the
 IOT office hours for anyone who

00:16:03.903 --> 00:16:09.158
 has  additional questions about
 any of these platforms can  ask

00:16:09.161 --> 00:16:14.201
 me directly.  Later on today, 
we also have hands-on  training 

00:16:14.202 --> 00:16:16.429
for Android Things where you can
 get your hands  on some of 

00:16:16.430 --> 00:16:20.582
these devices and build them and
 play with  the application.  

00:16:20.583 --> 00:16:24.818
And we also have another one on 
Google  actions tomorrow.

00:16:25.378 --> 00:16:27.834
One more thing.  We want you to 
get started on the  right path 

00:16:27.835 --> 00:16:31.779
by building cool devices for IOT
.  So  everyone who has attended

00:16:32.089 --> 00:16:36.525
 this session today is going to 
 go home with one of our 

00:16:36.526 --> 00:16:40.984
developer kits for Android  
things.

00:16:41.573 --> 00:16:43.573
[Applause]

00:16:45.713 --> 00:16:51.813
Make sure you grab a card on 
your way out, and you  can pick 

00:16:51.814 --> 00:16:54.460
up the kit downstairs.  So thank
 you so much  for your time 

00:16:54.461 --> 00:16:56.876
today, and I hope you enjoy the 
rest of  the conference.

00:16:57.020 --> 00:16:59.020
[Applause]

00:49:22.128 --> 00:49:24.128
&gt;&gt; Hello, everybody,.
[Applause]

00:49:28.390 --> 00:49:33.562
If you think you're going to get
 me to say nothing nothing, I'm 

00:49:33.563 --> 00:49:39.276
going to say it.  Welcome to 
Poland,  obviously, and welcome 

00:49:39.277 --> 00:49:43.354
to this session on Kotlin.  I'm 
 sure a majority of you here 

00:49:43.355 --> 00:49:46.920
have heard of Kotlin.  Have  
seen a little bit of it.  Just 

00:49:46.921 --> 00:49:51.102
keep it to yourself.  And  we'll
 start to -- I'll show you a 

00:49:51.103 --> 00:49:53.761
bunch of different  things with 
Kotlin, and I will do it a 

00:49:53.762 --> 00:49:56.498
little bit  differently this 
time.  I'll compare it a little 

00:49:56.499 --> 00:50:03.295
bit to  some other programming 
language, and we will pick Java 

00:50:03.296 --> 00:50:08.594
 today to kind of give you a 
feel of where and what we  try 

00:50:08.595 --> 00:50:12.991
and provide you with value.  
Okay?  And just to get  started,

00:50:13.500 --> 00:50:17.556
 this is my main function, so 
you can see it up  there.  And I

00:50:17.558 --> 00:50:23.712
 can write "Hello"," and I can 
run this, and  that's as simple 

00:50:23.713 --> 00:50:26.708
as it gets.
So to start with, you don't have

00:50:27.155 --> 00:50:33.398
 a public static  void main and 
class, you just have basically 

00:50:33.399 --> 00:50:40.570
top-level  functions.  It's 
JavaScript, but in a good way.  

00:50:40.571 --> 00:50:43.106
And you  can basically define 
your function as you like.  So I

00:50:43.112 --> 00:50:46.851
  can say function, for instance
, print message, and then  have 

00:50:46.852 --> 00:50:52.493
a parameter here of string, and 
then print line,  and then the 

00:50:52.494 --> 00:50:56.349
message.  Okay?  And I can do 
string here  and do whatever I 

00:50:56.350 --> 00:51:00.872
want.
Now, notice that there's no 

00:51:00.873 --> 00:51:05.631
return type.  By  default, it's 
unit, and you can omit it if you

00:51:05.640 --> 00:51:10.390
 don't  have a return type.  And
 functions, again, concise, what

00:51:10.393 --> 00:51:13.699
  we try to do is make functions
 as simple as possible and  as 

00:51:13.700 --> 00:51:18.055
easy as possible to write and as
 concise as possible  to write 

00:51:18.056 --> 00:51:21.203
and a expression returns a value
, you can just  write that as 

00:51:21.204 --> 00:51:26.742
what we call a single function 
expression.   So I can write 

00:51:26.743 --> 00:51:32.303
that as X plus Y; right?  I 
don't need to  put the return 

00:51:32.304 --> 00:51:35.363
type, I don't need to open the 
curly  braces or close the curly

00:51:35.837 --> 00:51:38.771
 braces, just write it as  
simple as that.  And of course 

00:51:38.772 --> 00:51:44.028
you can call these  functions 
whatever you want.  Message or 

00:51:44.029 --> 00:51:46.272
something.   Okay?
Now, how does this help in terms

00:51:46.273 --> 00:51:49.476
 of, like, what  you already 
have.  Okay?  The syntax is a 

00:51:49.477 --> 00:51:54.122
little bit  more concise, and I 
write fun instead of not fun, 

00:51:54.123 --> 00:51:57.671
and I  write unit instead of 
void, but what does that give me

00:51:57.966 --> 00:52:00.386
?   Let's take a look at, for 
example, overloaded functions  

00:52:00.387 --> 00:52:05.943
in Java; right?  This is over
loaded methods in Java, and  I'm

00:52:05.947 --> 00:52:12.495
 going to -- now take a look at 
overloaded.  So you  can see 

00:52:12.496 --> 00:52:15.715
that this is already somewhere 
where it's  cutting down code.  

00:52:15.716 --> 00:52:18.348
I don't need to do this over
loaded  method anymore in Java. 

00:52:18.349 --> 00:52:21.591
 Obviously, this -- I'm putting 
 this outside in its own, like, 

00:52:21.592 --> 00:52:25.230
top-level function.  But  this 
could actually be a function of 

00:52:25.231 --> 00:52:29.880
a class.  So don't  worry about 
the class.  The class is here.  

00:52:29.881 --> 00:52:36.736
There you go go.  Now you've got
 the class.  There.  Now you've 

00:52:36.737 --> 00:52:41.186
got  the class.  Happy?  There. 
 People say, oh, there's no  

00:52:41.187 --> 00:52:44.008
classes in Kotlin.  Yes, there 
are.

00:52:44.420 --> 00:52:49.464
So what am I doing?  Essentially
, I'm just passing  in optional 

00:52:49.465 --> 00:52:52.398
parameters; right?  Simple as 
that.  Why do  I have to have 

00:52:52.399 --> 00:52:55.028
all of this with all of this 
code over  and over again if 

00:52:55.029 --> 00:52:57.868
essentially I'm doing the same 
thing  but with a different 

00:52:57.869 --> 00:53:00.089
number of parameters?  And then 
of  course I can call this, and 

00:53:00.090 --> 00:53:02.421
I can say, for example,

00:53:06.447 --> 00:53:11.700
 a  Val here.  By the way, it 
means immutable only.  If you  

00:53:11.701 --> 00:53:15.138
want to reassign something, 
declare it a bar.  My rule  of 

00:53:15.139 --> 00:53:22.203
thumb is don't do it.  Just 
declare it a Val.  And  then I 

00:53:22.204 --> 00:53:25.234
can do it here and then print 
message.  Okay?  So  I can pass 

00:53:25.235 --> 00:53:31.431
in one parameter, I can pass in 
two  parameters, I can pass in 

00:53:31.433 --> 00:53:39.230
three parameters.  And the  good
 thing is that you can see the 

00:53:39.231 --> 00:53:41.772
intelligent name of  the 
parameter, but we actually have 

00:53:41.773 --> 00:53:45.747
named parameter in  Kotlin too. 
 So if I want to pass in the 

00:53:45.748 --> 00:53:48.602
suffix first, I  can put in 
suffix and then here I would say

00:53:49.013 --> 00:53:52.962
 the prefix  and pass in the pre
fix, and then this would become 

00:53:52.963 --> 00:53:55.614
the  actual message; right?  I 
could alternate the order in  

00:53:55.615 --> 00:53:57.131
which
  I want to pass the parameter. 

00:53:57.132 --> 00:53:59.763
 And this is useful  of course 
not only for order, which why 

00:53:59.764 --> 00:54:05.840
would you want  to do it anyway?
  But it's useful when you have 

00:54:05.841 --> 00:54:10.896
multiple  function that has 200 
parameters and playing a game;  

00:54:10.897 --> 00:54:16.133
right?  So you can start to im
mute those things.  But  why 

00:54:16.134 --> 00:54:18.134
bother?  You could hack things 
together; right?

00:54:18.168 --> 00:54:21.996
Now, Kotlin does have classes, 
as I have shown you you, I've 

00:54:21.997 --> 00:54:23.997
created a class.  And one of the

00:54:29.774 --> 00:54:34.725
  quintessential examples we 
show, let's say custom Java,  

00:54:34.726 --> 00:54:38.059
and show custom Kotlin.  There 
you go.

00:54:38.263 --> 00:54:43.000
Now -- and, again, you're going 
to say big deal.   Any ID 

00:54:43.001 --> 00:54:46.432
generates this for me.  Yes, it 
does but the ID  doesn't 

00:54:46.433 --> 00:54:49.555
maintain it for you.  And the ID
 doesn't say  look at that 

00:54:49.556 --> 00:54:52.590
because that's just boilerplate 
what I've  generated for you; 

00:54:52.591 --> 00:54:56.024
right?  I don't know if someone
's  modified all of that code.

00:54:56.025 --> 00:54:59.655
So all of this, essentially, is 
declared with a  single line of 

00:54:59.656 --> 00:55:03.695
code.  And the data class over 
here when  I add the data modify

00:55:03.894 --> 00:55:07.530
ier to it, what essentially that
 is  doing is providing me with 

00:55:07.531 --> 00:55:11.765
some new functionality,  namely 
it's giving me equals, the hash 

00:55:11.766 --> 00:55:15.308
code, the two  string, and the 
copy, which we'll see in a 

00:55:15.309 --> 00:55:18.030
moment.
What you also notice here is 

00:55:18.031 --> 00:55:23.087
that essentially I'm  doing the 
whole property decoration and 

00:55:23.088 --> 00:55:26.533
constructor also  in a single 
line.  So here I'm declaring two

00:55:26.920 --> 00:55:29.561
 properties.   One of them is 
read only.  The others are read,

00:55:29.748 --> 00:55:34.288
 write.   And that in turn is 
also creating a constructor.  

00:55:34.289 --> 00:55:36.837
That's  the short syntax.  You 
could also do this in a longer  

00:55:36.838 --> 00:55:39.551
syntax.  One thing to notice if 
you're not familiar with  Kotlin

00:55:40.646 --> 00:55:42.785
 is we don't have fields and 
such.  We just have  properties.

00:55:43.278 --> 00:55:46.304
  And then you access these 
properties with  accessers.  

00:55:46.305 --> 00:55:49.651
There's no set.  There is, but 
it's under  the cover speed.  

00:55:49.652 --> 00:55:57.102
When you talk Java to Kotlin, 
you get  the Java to Kotlin, 

00:55:57.103 --> 00:56:02.154
Kotlin to Java, you get the 
approach  in each language.  But

00:56:02.490 --> 00:56:04.998
 if you're just working with  
Kotlin, you can just use them 

00:56:04.999 --> 00:56:08.813
directly.  So I can say,  for 
example, Val customer equals 

00:56:08.814 --> 00:56:16.086
customer Kotlin, and  then this 
will be one A, B, and then your 

00:56:16.087 --> 00:56:20.355
customer dot  e-mail equals 
something.  Okay?

00:56:22.042 --> 00:56:25.477
A lot of boilerplate you're 
saving there.  Now,  one thing 

00:56:25.478 --> 00:56:30.116
you also have is the copy class.
  So here, you  can see that I 

00:56:30.117 --> 00:56:35.662
have a data class context, and 
then a  list type e-mail.  And 

00:56:35.663 --> 00:56:40.215
if you do a copy context, it's  
going to copy everything for you

00:56:40.608 --> 00:56:42.366
; right?  So you're  going to 
get all of those different 

00:56:42.367 --> 00:56:45.458
properties, and you  can, in 
fact, overwrite and say I want 

00:56:45.459 --> 00:56:48.796
the company name  to be -- when 
I copy, I want, for example, the

00:56:48.991 --> 00:56:53.751
 company  name to be something 
else, and then it will -- and 

00:56:53.752 --> 00:56:57.073
then  it will default the other 
ones to whatever the value is.  

00:56:57.074 --> 00:56:59.687
 So you can overwrite the values
.  Okay?

00:57:00.105 --> 00:57:04.342
We use data classes, as you know
, we like data  classes.  

00:57:04.343 --> 00:57:08.678
Initially, we have two poles, 
and we got rid  of them because 

00:57:08.679 --> 00:57:12.215
one of the key aspects of Kotlin
 is to  write maintainable code.

00:57:12.603 --> 00:57:15.134
  Now, we can't guarantee that  
because, you know, we are 

00:57:15.135 --> 00:57:18.062
developers, and we can take  any
 language and make it completely

00:57:18.258 --> 00:57:20.573
 unreadable.

00:57:23.601 --> 00:57:27.841
  And  there's a difference 
between every coder's readable. 

00:57:27.842 --> 00:57:31.170
  The different issue is whether
 it's comprehensible,  which is 

00:57:31.171 --> 00:57:35.198
where we basically struggle.
But we do have pairs and triples

00:57:36.011 --> 00:57:38.326
; right?  So, for  instance, 
let's say that I have a function

00:57:38.727 --> 00:57:44.778
 that returns  pairs, so I just 
basically I can just return a 

00:57:44.779 --> 00:57:48.510
pair of  type of string, string,
 and we also have triples.  So 

00:57:48.511 --> 00:57:52.256
if  you go beyond triple, then 
we say for you to use a data  

00:57:52.257 --> 00:57:58.914
class.  So here I can just do 
pair, something else;  right?

00:57:59.920 --> 00:58:06.078
Now, if I call this function, 
how do I access  those 

00:58:06.079 --> 00:58:09.716
properties?  Well, the first one
 is with first.   And guess what

00:58:09.719 --> 00:58:12.337
 the second one's going to be?  
There you  go.  You are really 

00:58:12.338 --> 00:58:15.663
interactive, aren't you?
Anyway, so the second one is 

00:58:15.664 --> 00:58:18.990
going to be second.   Now, that 
kind of sucks because, hey, 

00:58:18.991 --> 00:58:21.618
we're talking  about readability
, comprehensiveability, and what

00:58:21.621 --> 00:58:26.277
 is  first, what is second?  So 
you have destructuring  variable

00:58:26.562 --> 00:58:31.913
.  So you can do, for example, 
name and e-mail  and then do 

00:58:31.914 --> 00:58:35.350
list as return pair; right?  And
 now I can  access those in a 

00:58:35.351 --> 00:58:38.979
much more nicer way, giving me 
context  and meaning of what 

00:58:38.980 --> 00:58:45.653
exactly it is that I'm accessing
.   So I can do print, line, 

00:58:45.654 --> 00:58:48.390
e-mail.  And this where you're  
working with data classes, you 

00:58:48.391 --> 00:58:50.698
get when you're working  with 
pairs, you get when you're 

00:58:50.699 --> 00:58:54.632
working with Lambdas,  and 
notice here it says you're not 

00:58:54.633 --> 00:58:59.917
actually using name.   So that 
is a hint that the compiler is 

00:58:59.918 --> 00:59:02.616
doing surfaceing.   What you can
 also do is use the underscore. 

00:59:02.617 --> 00:59:05.743
 And say  anything I don't use, 
I'll just use underscore for and

00:59:05.745 --> 00:59:11.492
  get rid of all of those hints.
But more importantly, tell the 

00:59:11.493 --> 00:59:13.534
developer that's  reading this 
code that this value is not 

00:59:13.535 --> 00:59:17.962
important.  And  as I said, this
 destructuring can work with 

00:59:17.963 --> 00:59:22.103
anything.   So, for instance, we
 have contacts or e-mail class, 

00:59:22.104 --> 00:59:25.019
so I  can say this is the name, 
name one, and this is the  

00:59:25.020 --> 00:59:30.161
e-mail one, and then do exactly 
the same for e-mail;  right?  So

00:59:30.765 --> 00:59:34.317
 I can say something.  Okay?
So it's not only with pairs, it 

00:59:34.318 --> 00:59:37.048
also works with  data classes.  
And it's basically following the

00:59:37.349 --> 00:59:40.566
  convention of the first 
parameter, the first position,  

00:59:40.567 --> 00:59:43.690
the second parameter, second 
position, so on and so  fourth.

00:59:43.691 --> 00:59:46.626
Where else do we try to improve 
on the boilerplate  code that 

00:59:46.627 --> 00:59:50.756
you write?  So how many of you 
love design  patterns?  Okay.  

00:59:50.757 --> 00:59:53.248
Don't be ashamed.

00:59:56.309 --> 01:00:00.242
  Single turn.  Let's  see.  
Single turn in Java; right?  Now

01:00:00.243 --> 01:00:03.790
, this is single  turn in Java, 
which is fantastic.  Not 

01:00:03.791 --> 01:00:08.915
advocating the  use of single, 
I'm just saying this is a single

01:00:09.115 --> 01:00:17.117
 in Java.   And let's take a 
look at the singleton in Kotlin.

01:00:17.488 --> 01:00:21.027
   That's a singleton in Kotlin 
because we essentially have  

01:00:21.028 --> 01:00:26.985
objects.  So much like in normal
 languages you have a  class, a 

01:00:26.986 --> 01:00:30.002
type, and then you create an 
instance of that  type.  In 

01:00:30.003 --> 01:00:33.851
JavaScript, you only have 
objects, and then  you try to 

01:00:33.852 --> 01:00:37.271
mimic everything you learn from 
another  language and bring 

01:00:37.272 --> 01:00:40.730
classes into JavaScript.  In 
Kotlin,  we have both.  We have 

01:00:40.731 --> 01:00:44.739
objects, it just represents the 
 single value, and classes.

01:00:44.938 --> 01:00:48.073
So here, I can just create an 
object, which is a  single 

01:00:48.074 --> 01:00:50.811
Kotlin, and it has a property, 
and of course I  can access this

01:00:50.995 --> 01:00:54.642
 by just saying singleton Kotlin
, and  property; right?  And 

01:00:54.643 --> 01:00:58.166
then assign a value.  No, you  
don't assign a value to global 

01:00:58.167 --> 01:01:01.901
things.  You don't have  single
ton things you change values on.

01:01:02.112 --> 01:01:04.925
  That's kind of a  no-no.  For 
read only, though, it's kind of 

01:01:04.926 --> 01:01:08.466
nice.  And  notice I'm not 
advocating and saying, well, 

01:01:08.467 --> 01:01:12.401
since Kotlin  makes singleton so
 easy, let me just create single

01:01:13.313 --> 01:01:17.242
tons  throughout my entire code 
base.  Nope, not saying that  

01:01:17.243 --> 01:01:19.460
either.
What else?  One thing we added 

01:01:19.461 --> 01:01:23.309
to Kotlin was the  concept of a 
type value.  So here I have, for

01:01:23.310 --> 01:01:26.642
 instance,  the data class, and 
I have a name, customer name, 

01:01:26.643 --> 01:01:30.988
and  e-mail.  Now, notice the 
customer name is the same thing 

01:01:30.989 --> 01:01:33.397
 as a string; right?  But it's 
providing me with more  

01:01:33.398 --> 01:01:36.740
semantics.  Here I have -- and I
 have done that using  this 

01:01:36.741 --> 01:01:42.969
thing over here called custom --
 type custom string string.  

01:01:42.970 --> 01:01:47.611
Meaning that this property is 
actually a type  string.  But to

01:01:48.022 --> 01:01:50.848
 provide more meaning, to 
provide more  semantics, I'm 

01:01:50.849 --> 01:01:54.580
using the name customer name.  
But I can  pass in it, will 

01:01:54.581 --> 01:02:00.025
verify this run time, this 
string, you  can pass string 

01:02:00.026 --> 01:02:01.544
where it's customer name, et 
cetera,.

01:02:01.545 --> 01:02:05.070
Now, this comes in useful, 
actually, sometimes  combining 

01:02:05.071 --> 01:02:09.825
this type with something else, 
the annotation.   And I'll show 

01:02:09.826 --> 01:02:13.462
you how this works.  So let's 
say that I  have a class, 

01:02:13.463 --> 01:02:18.303
customer, and we're going to not
 come here here.  And I'm going 

01:02:18.304 --> 01:02:24.250
to rename this -- actually, I 
just  comment it out.  And what 

01:02:24.251 --> 01:02:28.490
I've done here is essentially  
created a deprecated annotation 

01:02:28.491 --> 01:02:36.046
that comes with Kotlin  and say 
customer called customer and 

01:02:36.047 --> 01:02:39.198
this eventually  doesn't work.  
It will be implemented so that 

01:02:39.199 --> 01:02:46.335
you can do  alt enter.  And 
notice I'm saying customer is 

01:02:46.336 --> 01:02:50.070
awesome  customer; right?  So 
now what happens here it says  

01:02:50.071 --> 01:02:55.328
awesome customer deprecated, and
 you should use customer  

01:02:55.329 --> 01:02:57.733
instead; right?
Now, the good thing about that 

01:02:57.734 --> 01:03:01.875
is that this allows  you to re
factor things and rename things 

01:03:01.876 --> 01:03:05.210
without  potentially breaking 
people's codes.  But then you're

01:03:05.402 --> 01:03:09.341
  probably thinking why do I 
care about breaking people's  

01:03:09.342 --> 01:03:13.477
code?  Let me just do that 
myself.

01:03:13.567 --> 01:03:19.838
So it is actually quite useful 
in that sense, and  we use it 

01:03:19.839 --> 01:03:22.155
quite a bit.  You can do 
multiple face change.   Rename 

01:03:22.156 --> 01:03:24.481
something, and then issue a 
warning, and then on  the next 

01:03:24.482 --> 01:03:28.530
one, I will remove that 
deprecated and away we  go.  

01:03:28.531 --> 01:03:31.377
Nobody can complain because 
that's -- you don't  complain as

01:03:31.640 --> 01:03:35.178
 developers.
So -- that was a joke.

01:03:35.491 --> 01:03:40.121
Here's another example.  Of 
course, it's not funny  when you

01:03:40.122 --> 01:03:44.858
 say that was a joke.  I have 
condition  expressions Kotlin 

01:03:44.859 --> 01:03:47.885
and conditional expressions here
;  right?  So for now, let's 

01:03:47.886 --> 01:03:50.632
just focus on this one and the  
action closest one, and I have a

01:03:50.813 --> 01:03:54.857
 string parameter.  So  I'm 
comparing the string and zero, 

01:03:54.858 --> 01:03:57.589
assign a parameter to  it.  If 
not, whatever.  I've got another

01:03:57.781 --> 01:04:01.911
 case where I'm  returning a 
value, and then I've got a 

01:04:01.912 --> 01:04:04.559
switch statement  where I'm 
saying if it's case one, if it's

01:04:04.749 --> 01:04:08.373
 case two.  If  not, then if the
 value is within a specific 

01:04:08.374 --> 01:04:11.908
range, then  do this, et cetera,
.  Ignore that, it's going to 

01:04:11.909 --> 01:04:15.427
say, oh,  it's always going to 
be true or false.  But for the 

01:04:15.428 --> 01:04:17.428
case  of this demo, it doesn't 
matter.

01:04:17.459 --> 01:04:21.795
So what about Kotlin?  Where do 
we kind of try to  improve here?

01:04:22.101 --> 01:04:26.226
  Well, the first thing that you
 can see is  that an if and a 

01:04:26.227 --> 01:04:30.964
when in Kotlin is an expression.
  So  can I don't have -- well, 

01:04:30.965 --> 01:04:35.105
it can be treated as an  
expression or a statement.  But 

01:04:35.106 --> 01:04:38.342
I don't have to  explicitly 
declare a variable, assign that 

01:04:38.343 --> 01:04:41.045
variable  based on the actual 
branch.  I can just return that 

01:04:41.046 --> 01:04:44.476
as  the result of the expression
.  This is a single line of  

01:04:44.477 --> 01:04:49.023
expression.  If I have multiple 
lines, curly brackets,  then the

01:04:49.733 --> 01:04:53.556
 last line of that branch is 
going to be the  return value.  

01:04:53.557 --> 01:04:58.599
So here I'm doing value can be 
one, 20,  or I can write 

01:04:58.600 --> 01:05:00.816
multiple statements and then the
 last  value is going to be the 

01:05:00.817 --> 01:05:05.263
return value.  I could even  
return a string here; right?  

01:05:05.264 --> 01:05:08.799
But if I return a string,  the 
compiler's going to give me a 

01:05:08.800 --> 01:05:11.234
warning and say  conditional 
branch is returning the type 

01:05:11.235 --> 01:05:15.761
string, so I'm  casting the 
return type to any.  Any is the 

01:05:15.762 --> 01:05:18.581
top-level  object in Kotlin; 
right?  Meaning that if you want

01:05:18.780 --> 01:05:22.499
 to,  you can return a different
  type branch.  Why would you  

01:05:22.500 --> 01:05:26.559
want to?  I don't know.  But you
 can do it.  Well, there  are 

01:05:26.560 --> 01:05:31.876
cases, obviously.
Now, in a when statement, 

01:05:31.877 --> 01:05:36.122
similar to a case, but  we do 
allow pattern match.  So you can

01:05:36.123 --> 01:05:39.487
 see I have one, I  have two, 
which we had in Java case, and 

01:05:39.488 --> 01:05:43.910
then I have a  bunch of values 
three, four, five.  I can even 

01:05:43.911 --> 01:05:48.437
check  whether it's a type, I 
can even check whether it's in a

01:05:48.729 --> 01:05:51.858
  range, and I can even call a 
function and have the  function 

01:05:51.859 --> 01:05:55.314
calculate the value and return 
whether that's a  true or false 

01:05:55.315 --> 01:05:58.239
statement; right?
Point being what?  It is very 

01:05:58.240 --> 01:06:01.744
similar in code to  what you've 
seen in Java.  Difference being 

01:06:01.745 --> 01:06:06.179
that it's  saving you a lot of 
pain when you're writing this 

01:06:06.180 --> 01:06:10.929
code.   Okay?  It's allowing you
 to be more concise, more  

01:06:10.930 --> 01:06:12.840
expressive.  And that's 
essentially what Kotlin is about

01:06:12.841 --> 01:06:15.768
 about.  It's not about a single
 feature that you look at  and 

01:06:15.769 --> 01:06:18.487
say okay.  This is cool.  But I 
can do this in Java.   You can 

01:06:18.488 --> 01:06:21.840
do everything in Java.  And when
 I say Java, I  mean you can do 

01:06:21.841 --> 01:06:25.256
everything in assembly.  How 
many of you  here program in 

01:06:26.060 --> 01:06:30.612
Assembly?  Three people.  
Awesome.

01:06:32.760 --> 01:06:34.760
Still?

01:06:37.071 --> 01:06:41.397
  Right.  Now, another thing 
that we try to  help with is 

01:06:41.398 --> 01:06:44.722
Java.  This is your typical 
example; right?   If customers 

01:06:44.723 --> 01:06:50.672
don't know, if customer's name 
is don't  know, if customer's 

01:06:50.673 --> 01:06:54.520
Git name starts with blah, blah,
  blah, how do we solve this 

01:06:54.521 --> 01:06:57.846
program?  We do, but we don't 
don't.  Well, we do but I'll 

01:06:57.847 --> 01:07:05.206
tell you.  We -- yes.   Anyway, 
by default, we don't have types.

01:07:05.616 --> 01:07:09.339
  So when you  declare a type in
 Kotlin; right?  If I can't hear

01:07:09.637 --> 01:07:18.022
, and I  say my strength equals 
some value, and then I do my  

01:07:18.023 --> 01:07:21.334
strength equals null, that's not
 going to work because  it says 

01:07:21.335 --> 01:07:25.073
this type is not nullable; right
?  If I  initialize it to null, 

01:07:25.074 --> 01:07:29.217
then it will work.  You can also
  do explicit type decoration in

01:07:29.621 --> 01:07:34.973
 Kotlin, but you normally  don't
, so I do string, that is going 

01:07:34.974 --> 01:07:38.892
to give an error  because string
 is not nullable.  And one day I

01:07:38.894 --> 01:07:41.256
 will  write something, probably
.

01:07:41.313 --> 01:07:44.250
Now, what I can do to make this 
nullable is add a  question mark

01:07:44.546 --> 01:07:47.784
 and say this is now nullable; 
right?  So I  can assign a null

01:07:48.083 --> 01:07:51.023
able type to it.  Why would you 
want to  do this?  Again, try to

01:07:51.223 --> 01:07:55.856
 move away from nullable types. 
  In Kotlin by default, you 

01:07:55.857 --> 01:07:59.781
don't declare nullable types.   
However, we -- one of the 

01:07:59.782 --> 01:08:04.318
purposes of creating Kotlin  was
 to be able to interrupt with 

01:08:04.319 --> 01:08:07.445
all of the existing  Java code 
that we have and you have.  And 

01:08:07.446 --> 01:08:10.177
when you're  interrupting with 
Java, you're going to face null

01:08:10.694 --> 01:08:13.512
able  types.  So you need to 
have that question mark there  

01:08:13.513 --> 01:08:17.030
sometimes to be able to 
interrupt nullable types.  So in

01:08:17.032 --> 01:08:20.158
  the case of Kotlin what we're 
trying to do is make it a  

01:08:20.159 --> 01:08:23.394
little bit nicer to work with.  
So here, you see that  basically

01:08:23.696 --> 01:08:28.629
 the same kind of code -- in 
this case, I don't  have to do 

01:08:28.630 --> 01:08:31.822
any checks because it's a custom
 Kotlin, and  I'm saying that 

01:08:31.823 --> 01:08:35.488
it's not nullable.  Okay?
In this case, however, given 

01:08:35.489 --> 01:08:39.020
that this is coming  from Java, 
I can actually explicitly say 

01:08:39.021 --> 01:08:42.989
that this is  going to be a null
able type by adding a question 

01:08:42.990 --> 01:08:45.890
mark.   Since I say it's going 
to be a nullable type, then  

01:08:45.891 --> 01:08:50.231
Kotlin, I would have to do kind 
of, like, in line of if  

01:08:50.232 --> 01:08:55.980
customer is not null, then do 
something with it.  You  can do 

01:08:55.981 --> 01:09:00.523
a much shorter syntax with that 
by just using the  question mark

01:09:01.136 --> 01:09:03.341
 here.  So that's basically 
saying if  customer is not null,

01:09:03.342 --> 01:09:07.096
 then if name is not null, then 
it  starts with blah, blah, blah

01:09:07.494 --> 01:09:10.312
, and if that equals true,  then
 do something.  Okay?

01:09:10.608 --> 01:09:13.329
So when you're working with Java
, you have to  decide whether 

01:09:13.330 --> 01:09:16.755
the type you're actually working
 with is  nullable or not.  I 

01:09:16.756 --> 01:09:21.191
could actually remove this and 
say  there you go.  I now know 

01:09:21.192 --> 01:09:23.917
that this will never be null.   
So you could use the not null 

01:09:23.918 --> 01:09:28.371
annotations that different  
libraries provide, which kind of

01:09:29.069 --> 01:09:31.982
 recognize whether  that's going
 to be nullable or not.  What 

01:09:31.983 --> 01:09:36.826
you can't do  is remove that and
 then get null reference 

01:09:36.827 --> 01:09:41.060
exception run  time and then say
, well, didn't Kotlin say remove

01:09:41.475 --> 01:09:43.876
 null?   No, because you're 
explicitly saying that this is 

01:09:43.877 --> 01:09:46.507
null.
And as I always say, if you 

01:09:46.508 --> 01:09:49.828
really want to be  brave, what 
you can also do is declare this 

01:09:49.829 --> 01:09:57.206
as nullable,  and then do 
customer double exclamation ID 

01:09:57.207 --> 01:10:00.365
and that  means I don't care.  I
 missed my null reference, I 

01:10:00.366 --> 01:10:03.259
just  want you to blow up at run
 time.  Okay?

01:10:03.573 --> 01:10:07.595
So you can do that as well.  Why
 you add that?   Don't start -- 

01:10:07.596 --> 01:10:11.945
this is one of the main things 
that  people fall into.  The 

01:10:11.946 --> 01:10:15.564
trap when they start to port 
over  their Java code, initially

01:10:15.764 --> 01:10:18.596
 they're, like, oh, well, this  
is null, what should I do?  

01:10:18.597 --> 01:10:21.108
Double exclamation.  No, you  
don't.

01:10:21.920 --> 01:10:24.558
Not having null in the language 
is actually  forcing you to 

01:10:24.559 --> 01:10:30.182
think more essentially; right?  
Because  it's not a happy path. 

01:10:30.183 --> 01:10:33.634
 Normally when we do error  
control, well, if it's not null,

01:10:33.824 --> 01:10:37.249
 I'll do this.  And if  it's 
null, I'll pretend that nobody 

01:10:37.250 --> 01:10:40.997
saw anything.  Now  it's kind of
 saying what happens if it's not

01:10:41.889 --> 01:10:45.618
 null?  Well Well, I don't know.
So what else?  One of the things

01:10:45.841 --> 01:10:48.957
 in Kotlin is  extension 
functions; right?  So what I can

01:10:49.154 --> 01:10:58.367
 essentially  do is do fun, 
string, Krakow, and what that 

01:10:58.368 --> 01:11:05.821
will do is  is -- essentially --
 print line Krakow is great.  

01:11:05.822 --> 01:11:11.482
Okay?   So now I can say Poland 
and Krakow

01:11:14.515 --> 01:11:21.035
 are great.  Okay?  So  I've 
just added a new function to 

01:11:21.036 --> 01:11:26.539
crack out are great.   It's only
 done crack crack out

01:11:29.845 --> 01:11:36.970
 Krakow.  I can extend any type 
in Kotlin  or Java; right?

01:11:37.145 --> 01:11:40.648
So you're kind of thinking why 
would I want to do  this?  Again

01:11:40.649 --> 01:11:45.197
, to make code expressive.  Now,
 I normally  wouldn't do -- add 

01:11:45.198 --> 01:11:50.474
a function in my code base 
called  Krakow, we could do 

01:11:50.475 --> 01:11:55.999
something like case with 
inverted  German style; right?  

01:11:56.000 --> 01:12:00.022
I could do something like that; 
 right?  Because you know in 

01:12:00.023 --> 01:12:02.541
Germany they do inverted  things
; right?

01:12:02.965 --> 01:12:05.873
So this gives you, again, 
expressiveity.  I don't  have to

01:12:05.874 --> 01:12:09.712
 take a string class and inherit
 it from it, add  a new method 

01:12:09.713 --> 01:12:14.360
to be able to just add one more 
function.   Okay?  This is where

01:12:14.760 --> 01:12:17.468
 the beauty of this extension  
functions are.  And if you 

01:12:17.469 --> 01:12:20.698
actually look at the standard  
library, which you'll see in a 

01:12:20.699 --> 01:12:23.737
moment, most of the  
functionality you get are, in 

01:12:23.738 --> 01:12:26.453
fact, extension function  over 
generic types, meaning that you 

01:12:26.454 --> 01:12:31.197
get a whole bunch  of 
functionality independently of 

01:12:31.198 --> 01:12:34.239
the type of things  that you use
.  Whether it's strings, whether

01:12:34.435 --> 01:12:38.551
 it's  collections, et cetera,. 
 Okay?  And we'll see that when 

01:12:38.552 --> 01:12:44.110
 we take a look at Lambdas.
Now, Lambdas in Java, I have 

01:12:44.111 --> 01:12:47.339
Lambdas in Java.  If  I want to 
declare something in Java that's

01:12:47.549 --> 01:12:51.061
 a high-order  function, I can 
say, well, I can do it in two 

01:12:51.062 --> 01:12:54.804
ways.  I  could define an inter
face that takes two parameters, 

01:12:54.805 --> 01:12:59.230
or  I can do something like a by
 consumer or a by function  or a

01:12:59.432 --> 01:13:03.878
 whatever, and then have all of 
these different  types, and then

01:13:04.287 --> 01:13:07.209
 passing the parameters that I 
need, and  then the ID it will 

01:13:07.210 --> 01:13:09.741
say to me.  Okay.  This is a 
Lambda.   You don't have to 

01:13:09.742 --> 01:13:12.973
implement, you can just pass 
this in  as a Lambda just like 

01:13:12.974 --> 01:13:16.702
I'm using like using list on 
Java;  right?  Here, I'm 

01:13:16.703 --> 01:13:21.842
creating a new instance, but I 
can re replace that with Lambda.

01:13:23.359 --> 01:13:25.789
  You can do pretty much the 
same  thing in Kotlin; right?  

01:13:25.790 --> 01:13:29.037
Except, you don't have to have  
the specific type decoration, 

01:13:29.038 --> 01:13:33.345
you can just pass in  Lambda 
like that, and you will see that

01:13:33.349 --> 01:13:37.078
 this is omitting  the brackets 
like in a moment.

01:13:37.284 --> 01:13:41.113
But how do I declare high order 
function?   Essentially, we're 

01:13:41.114 --> 01:13:43.964
using always the same syntax.  I
  don't have to know about by

01:13:47.960 --> 01:13:50.588
 bifunctions or anything like  
that.  This is a function that 

01:13:50.589 --> 01:13:55.329
takes two interests and  returns
 an integer.  Here is a function

01:13:55.628 --> 01:13:59.360
 that takes no  parameters and 
returns void.  All right?  

01:13:59.361 --> 01:14:01.798
Technically,  it's not a 
function, but anyway.

01:14:02.093 --> 01:14:08.250
So always following the same 
syntax.  Always.  And  now I can

01:14:08.545 --> 01:14:12.073
 pass as a Lambda.  And when you
 want to invoke  it, you do 

01:14:12.074 --> 01:14:16.733
higher order, and you actually 
pass in the  Lambda, which is 

01:14:16.734 --> 01:14:19.953
this syntax.  And the same the 
last  parameter to a function is

01:14:20.149 --> 01:14:24.893
 another function, then I can  
omit; right?  And then what I 

01:14:24.894 --> 01:14:27.936
can do is make this multi 
multiline, which will make it a 

01:14:27.937 --> 01:14:31.463
little bit nicer.  And  you say 
why?  Well, then I could do 

01:14:31.464 --> 01:14:35.987
something like this.   I could 
take a greater function using, 

01:14:35.988 --> 01:14:44.052
for instance,  object, which is 
closeable, and then have a body.

01:14:44.250 --> 01:14:49.604
   Basically, what it's doing is
 going to invoke the body.   And

01:14:49.607 --> 01:14:53.140
 then I'll do finally, object 
close; right?  And then  what I 

01:14:53.141 --> 01:15:00.195
could do, imagine that I have 
about closeable  thing here, 

01:15:00.196 --> 01:15:04.442
whatever, will close it, 
whatever imagine  that that 

01:15:04.443 --> 01:15:11.290
works, and then I could do using
 closeable,  and then not have 

01:15:11.291 --> 01:15:13.903
to worry about that resource 
being  free.  Using is a 

01:15:13.904 --> 01:15:18.149
statement that we have in C#, 
and you  have a similar tribe of

01:15:18.444 --> 01:15:19.968
 resources.  But essentially  
giving

01:15:19.969 --> 01:15:24.001
  you that fluid key of feeling 
as if you are  adding 

01:15:24.002 --> 01:15:27.631
functionality to the language in
 a way that is  very expressive 

01:15:27.632 --> 01:15:29.862
and easy to read and understand.
  Okay?

01:15:30.649 --> 01:15:34.379
And all of these functions as I 
mentioned, we have have, like, 

01:15:34.380 --> 01:15:38.414
when working with functions, all
 of these  things are part of 

01:15:38.415 --> 01:15:41.836
the standard library.  So, by 
the way way, this is how you 

01:15:41.837 --> 01:15:45.675
create a list of numbers in 
Kotlin  one to 100, and then on 

01:15:45.676 --> 01:15:51.543
the numbers, I could do things  
like filter, it is less than 100

01:15:51.546 --> 01:15:57.997
.  So it is following  the same 
syntax as groovey saying that 

01:15:57.998 --> 01:16:01.623
the function I  pass in as a 
single parameter, I don't have 

01:16:01.624 --> 01:16:04.025
to  explicitly name that 
parameter.  So instead of doing 

01:16:04.026 --> 01:16:10.675
 something like X and then X is 
less than 100, I can  actually 

01:16:10.676 --> 01:16:15.428
convert into using implicit.  
Okay?  And then I  could change 

01:16:15.429 --> 01:16:17.456
these.  Map

01:16:22.279 --> 01:16:25.415
 get 100 or what have you.
So these functions, as I mention

01:16:25.804 --> 01:16:30.344
, they're  basically part of the
 standard library, you can see 

01:16:30.345 --> 01:16:33.173
the  extension function.  So I 
have all the functionality,  all

01:16:33.176 --> 01:16:35.819
 the different types of 
collections that I want to  use.

01:16:36.092 --> 01:16:39.128
  And Kotlin doesn't provide 
right now collection,  basically

01:16:39.533 --> 01:16:43.556
 interface it on top of Java's 
collection by  default moving 

01:16:43.557 --> 01:16:49.007
towards immutable.  So when I do
, for  instance, customers 

01:16:49.008 --> 01:16:51.943
equals all, and then a customer 
 Kotlin, that is going to create

01:16:52.149 --> 01:16:56.195
 an immutable customer  for me 
in Kotlin, and I can add a 

01:16:56.196 --> 01:17:00.999
second one, customer  Kotlin, 
and then whatever I want.  Okay?

01:17:01.209 --> 01:17:06.242
One other thing, difference with
 Java is that like  in Java, you

01:17:06.246 --> 01:17:08.246
 would

01:17:10.887 --> 01:17:15.021
 have the Java strings.  So the 
 equivalent of what I did is one

01:17:15.248 --> 01:17:21.404
, 100 is inth string.   The 
difference in Kotlin, all of 

01:17:21.405 --> 01:17:25.411
these lists are equally  
evaluated.  If you want to do 

01:17:25.412 --> 01:17:30.247
evaluation, what you do is  just
 write ask sequence, and you 

01:17:30.248 --> 01:17:33.168
could do that to any  collection
; right?  And if you want to do 

01:17:33.169 --> 01:17:36.002
to something a  little bit more 
complex than a collection, you 

01:17:36.003 --> 01:17:42.068
do top  level sequence, and then
 pass in a C and then generate  

01:17:42.069 --> 01:17:47.473
the code that you want to and 
then on that, map it to --  

01:17:47.474 --> 01:17:53.543
filter it, it is less than 100, 
and then for each, and  then 

01:17:53.544 --> 01:17:59.996
here print line, et cetera,.  
Okay?  One other thing  that 

01:17:59.997 --> 01:18:03.625
we've tried to, again, focusing 
on it is just more  compact, 

01:18:03.626 --> 01:18:08.585
more concise, easier to read.  
Another thing  that we have, 

01:18:08.586 --> 01:18:16.935
which is kind of nice is the 
return types.   Our way of 

01:18:16.936 --> 01:18:21.184
implementing algebraic data 
types, which is  kind of useful 

01:18:21.185 --> 01:18:23.635
where you essentially say a type
, a  function, for instance, is 

01:18:23.636 --> 01:18:24.902
returning one type or another 
another.

01:18:24.903 --> 01:18:27.952
 A type can be one type or 
another.  The way  that we 

01:18:27.953 --> 01:18:30.555
represent that in Kotlin is 
essentially through  a hierarchy

01:18:30.760 --> 01:18:34.292
 of classes.  But then what we 
do is add the  C modifyier, 

01:18:34.293 --> 01:18:36.824
which essentially means that 
this hierarchy  is closed.  

01:18:36.825 --> 01:18:41.657
Meaning that nobody else can 
ever inherit  from response; 

01:18:41.658 --> 01:18:45.583
right?  And these are inside, I 
can  actually take them outside 

01:18:45.584 --> 01:18:51.440
and then have something, like 
like, failure, success, and 

01:18:51.441 --> 01:18:56.776
response.  And then get rid  of 
all of these things.  And notice

01:18:57.095 --> 01:19:00.102
 -- I don't know if  you see it 
there, but this has gone green; 

01:19:00.103 --> 01:19:02.529
right?  This  has gone green 
because that's another thing 

01:19:02.530 --> 01:19:07.467
that we have  in Kotlin, which 
is smart pass.  Which 

01:19:07.468 --> 01:19:09.583
essentially means  saving having
 to type things over and over 

01:19:09.584 --> 01:19:15.835
again.  And  instead of casting 
these success, I can just assume

01:19:16.138 --> 01:19:18.867
 that  it is success because the
 compiler has done that.  So  

01:19:18.868 --> 01:19:22.189
these are some of the things 
that Kotlin has done to be  able

01:19:22.191 --> 01:19:28.256
 to let you work more concisely 
and more fluently  and more 

01:19:28.257 --> 01:19:29.696
rapidly and more fun.  Thank you
.

01:19:29.697 --> 01:19:31.697
[Applause]

01:25:54.881 --> 01:25:56.881
 THIS IS A CAPTION TEST.  THIS 
IS A CAPTION TEST. 

01:26:49.235 --> 01:26:51.324
Test.  Test.  This is a caption 
test.  Please standby for 

01:26:51.325 --> 01:26:55.483
realtime captions.  Testing 
testing one two three.  This is 

01:26:55.484 --> 01:26:57.553
a caption test.  Please standby 
for realtime

01:27:01.637 --> 01:27:05.826
 Test.  This is a captioning 
test.  

01:27:11.988 --> 01:27:13.988
 me see if the

01:27:16.082 --> 01:27:20.082
 paragraph still works? Nope, 
I'm going to have to redefine 

01:27:16.082 --> 01:27:18.082
it. 

01:28:26.480 --> 01:28:28.581
 Now let's test it.  Testing 
testing one two

01:28:34.725 --> 01:28:38.997
 And what does the paragraph 
look like? Test.  Test. 

01:28:53.461 --> 01:28:55.557
 Does it clear my screen now?

01:29:52.060 --> 01:29:56.204
        And now the definition 
is there.  There is quite a 

01:29:58.281 --> 01:30:00.281
delay. 

01:30:02.372 --> 01:30:04.372
 this is. 

01:30:16.542 --> 01:30:24.862
 Test.  This is a caption test. 
 Please standby for realtime 

01:30:24.863 --> 01:30:31.128
captions.  Testing testing one 
two three four five six seven.  

01:30:31.129 --> 01:30:33.129
Test.  Test.  Test. 

01:30:35.215 --> 01:30:37.330
 testing the closed captioning. 
 Testing testing testing.  This 

01:30:37.331 --> 01:30:39.331
is a caption

01:31:11.981 --> 01:31:13.981
 Test. 

01:34:29.306 --> 01:34:31.428
 Hello everybody.  How's it 
going? Having a good day so far?

01:34:35.541 --> 01:34:39.709
 with another talk? Cool! Okay. 
 Let's get going.  We're going 

01:34:39.710 --> 01:34:41.710
to do -- I hope

01:34:43.802 --> 01:34:50.068
 zero to app.  We're going to be
 building a universal translator

01:34:50.069 --> 01:34:56.297
 with cloud base right in front 
of your very eyes.  It takes 

01:34:56.298 --> 01:34:58.364
three of us to build an app all 
together.  I'm going to be doing

01:34:58.365 --> 01:35:02.521
 a lot of the talking and some 
of the coding.  Joining me is

01:35:06.598 --> 01:35:08.598
Hi, I'm

01:35:10.734 --> 01:35:12.845
that, let me tell you a story.  
Everybody likes story time, 

01:35:12.846 --> 01:35:16.995
right? I like story time.  I'm 
going to tell you a story about 

01:35:16.996 --> 01:35:23.245
science fiction.  I love sci-fi.
  Any other a fans in the

01:35:27.349 --> 01:35:29.474
 of my favorites is star trek.  
One of the things that makes it 

01:35:29.475 --> 01:35:33.614
so awesome is all of the 
different technology that's in 

01:35:33.615 --> 01:35:37.766
the show.  For example, we have 
the captain, who can ask a 

01:35:37.767 --> 01:35:41.895
computer with his own voice for 
a cup of tea, and the computer 

01:35:41.896 --> 01:35:43.966
will respond by making it 
magically appear.  And although 

01:35:43.967 --> 01:35:48.115
we can't make tea appear from 
air yet, we're actually making 

01:35:48.116 --> 01:35:56.422
good progress on a lot of Star 
Trek technology.  You can use 

01:35:56.423 --> 01:35:58.493
things like Google

01:36:02.622 --> 01:36:06.812
 cool technology from Star Trek 
was the universal translator.  

01:36:06.813 --> 01:36:10.952
The team would beam down on some
 foreign world and encounter 

01:36:10.953 --> 01:36:15.105
some alien race they had never 
seen before.  And within the 

01:36:15.106 --> 01:36:19.260
first couple words they uttered,
 they were instantly able to 

01:36:19.261 --> 01:36:21.261
communicate 

01:36:23.377 --> 01:36:25.377
 is a technology that I would 
love to

01:36:27.525 --> 01:36:31.756
 bit to do things like give 
talks, but I'm one of those 

01:36:31.757 --> 01:36:37.951
mono-lingual people.  I can only
 speak one language.  I'm 

01:36:37.952 --> 01:36:40.021
ashamed.  It would be great if I
 could communicate with people 

01:36:40.022 --> 01:36:46.260
in their preferred language more
 easily.  So we're going to 

01:36:46.261 --> 01:36:48.336
solve that problem using the 
technique we use to solve all 

01:36:48.337 --> 01:36:50.409
the problems in our life, which 
is

01:36:54.498 --> 01:36:58.685
 we're going to build mobile 
apps.  We want to work with 

01:36:58.686 --> 01:37:02.833
everyone, regardless of their 
specific preferred language or 

01:37:02.834 --> 01:37:09.045
platform.  So we want this to 
work on iOs and Android.  This 

01:37:09.046 --> 01:37:11.113
is where Firebase

01:37:15.220 --> 01:37:17.323
 Traditionally, we would have 
some challenges, because we 

01:37:17.324 --> 01:37:19.395
would probably want to spin up a
 big

01:37:23.484 --> 01:37:27.629
 cluster, maybe a post REST 
there.  Probably wire them into 

01:37:27.630 --> 01:37:31.811
some cool back-end APIs to pick 
up some of the heavy lifting, 

01:37:31.812 --> 01:37:33.812
but we

01:37:35.920 --> 01:37:38.084
 a different approach.  This is 
where Firebase can help us get a

01:37:38.085 --> 01:37:42.300
 lot in motion quickly.  
Firebase gives us, both in 

01:37:42.301 --> 01:37:46.492
addition to all sorts of cool 
back-end stuff, gives us a bunch

01:37:46.493 --> 01:37:50.656
 of client libraries, and easy 
bindings to make it easier than 

01:37:50.657 --> 01:37:52.657
ever to build stuff

01:37:54.752 --> 01:37:56.875
 can think about Firebase is 
it's my big bag of app 

01:37:56.876 --> 01:38:03.145
development goodies.  There are 
all sorts of things to make my 

01:38:03.146 --> 01:38:07.330
app and web development easier. 
 Hosting and deep

01:38:11.428 --> 01:38:15.610
 dynamic languages and crash 
reporting.  We're just going to 

01:38:15.611 --> 01:38:19.759
focus on a few of the different 
goodies.  We're going to talk 

01:38:19.760 --> 01:38:21.850
about cloud storage for 
Firebase.  We're going to talk 

01:38:21.851 --> 01:38:25.988
about authentication, and 
realtime database.  So let's dig

01:38:28.079 --> 01:38:32.263
 into each one of these a little
 bit deeper.  First, cloud 

01:38:32.264 --> 01:38:36.426
storage for Firebase.  A lot of 
modern applications have to move

01:38:36.427 --> 01:38:40.595
 binary chunks of stuff like 
bios.  Youing might have to 

01:38:40.596 --> 01:38:44.733
upload photos or some recorded 
audio that you want to move 

01:38:46.834 --> 01:38:48.913
around.  And Firebase for cloud 
storage makes this a lot easier,

01:38:48.914 --> 01:38:53.073
 because you have cool client 
libraries, and you don't have to

01:38:53.074 --> 01:38:55.184
 think much about it.  You just 
send your data off to the 

01:38:59.309 --> 01:39:01.416
 clients can automatically 
access that binary data really

01:39:05.521 --> 01:39:07.659
 advantage of all the cool 
infrastructure that Google 

01:39:07.660 --> 01:39:11.827
provides super fast, network, 
high reliability, all of the 

01:39:11.828 --> 01:39:13.828
stuff that you have

01:39:15.931 --> 01:39:18.064
Okay.  Now we have all of our 
biostuff dealt with.  Next we 

01:39:18.065 --> 01:39:20.065
want to

01:39:22.171 --> 01:39:24.171
 handle authentication. 

01:39:28.295 --> 01:39:30.396
 Authentication is important.  
You want to control a little 

01:39:30.397 --> 01:39:36.605
bit.  You want to make sure that
 only those of us on stage can 

01:39:36.606 --> 01:39:40.769
write data into our universal 
translator.  Some of you might 

01:39:40.770 --> 01:39:47.000
want to play some trickery on 
us, so we will use Firebase for 

01:39:47.001 --> 01:39:49.092
that.  Has anybody ever wrote 
their own authentication from 

01:39:49.093 --> 01:39:55.339
scratch? A couple people.  It's 
really kind of a pain whether 

01:39:55.340 --> 01:39:57.422
you're doing e-mail and password
 log-in.  You have to make sure 

01:39:57.423 --> 01:40:03.700
you're doing the right hashing. 
 Or if you're working with a

01:40:07.784 --> 01:40:09.877
 provider, and there's a lot 
there that we seem to do

01:40:13.953 --> 01:40:18.174
 authentication takes the parts 
of that and gives you easy 

01:40:18.175 --> 01:40:22.355
bindings to client libraries.  
One of the

01:40:26.452 --> 01:40:30.597
 cool things about Firebase is 
that you -- all of your users 

01:40:30.598 --> 01:40:32.671
have a single identifier that 
you can use to identify them 

01:40:32.672 --> 01:40:38.933
across your application.  Okay. 
 So we have authentication taken

01:40:38.934 --> 01:40:40.934
 care 

01:40:43.040 --> 01:40:45.169
 comes in, the realtime database
 is awesome.  This is how it 

01:40:47.253 --> 01:40:51.399
works.  So it is kind of like a 
big old ball of JSON in the sky.

01:40:51.400 --> 01:40:53.400
  We like JSON,

01:40:55.530 --> 01:40:57.530
 great.  You take any of your 
data

01:40:59.655 --> 01:41:05.918
 that you could represent as 
JSON, text, all of that stuff.  

01:41:05.919 --> 01:41:10.083
You have them write on a big 
tree of JSON.  This is where the

01:41:12.176 --> 01:41:14.176
 magic comes in. 

01:41:16.296 --> 01:41:20.469
 of having to deal with network 
asynchronous stuff, have your 

01:41:20.470 --> 01:41:24.656
clients tell Firebase what node 
or what sub tree or even a query

01:41:24.657 --> 01:41:26.726
 against a sub tree in that JSON
 blob that they care about. 

01:41:30.838 --> 01:41:32.975
 client libraries take care of 
calling your function whenever 

01:41:32.976 --> 01:41:39.222
there's a change.  We take care 
of validation and handling 

01:41:39.223 --> 01:41:43.397
online and offline network 
blips.  It handles it for you, 

01:41:43.398 --> 01:41:45.398
and it's

01:41:47.491 --> 01:41:49.656
 time, but you're here to see 
some code, right? We're going to

01:41:49.657 --> 01:41:55.913
 build the apps right now.  I'm 
going to hand it over to Bret, 

01:41:55.914 --> 01:41:57.968
who's going to help guide us 
through the

01:42:02.100 --> 01:42:06.385
 are we going to live-code an 
app in front of you today, we're

01:42:06.386 --> 01:42:10.562
 going to live code two apps.  
We have Kathy who will be 

01:42:10.563 --> 01:42:16.871
working on the iOS version, and 
Jen who will be working on the 

01:42:16.872 --> 01:42:18.872
Android version. 

01:42:20.973 --> 01:42:23.113
 here? So we've got a language 
picker.  This is going to set 

01:42:23.114 --> 01:42:27.286
the language that is my 
preferred language.  This will 

01:42:27.287 --> 01:42:29.368
be both the language that I'm 
speaking into the app, and also 

01:42:29.369 --> 01:42:33.509
the language that out here is 
spoken back to me as messages 

01:42:33.510 --> 01:42:37.670
come in.  Messages can be coming
 in from any language and their 

01:42:37.671 --> 01:42:41.874
point of origin, but when it 
gets to me, it will be 

01:42:41.875 --> 01:42:43.946
translated out loud into my 
preferred language.  You'll hit 

01:42:43.947 --> 01:42:48.109
the record button.  It will 
create an audio file local on 

01:42:48.110 --> 01:42:52.257
your device.  What we will code 
in front of you is how to upload

01:42:52.258 --> 01:42:54.340
 that to the cloud, do the 
processing, and turn the 

01:42:54.341 --> 01:42:56.341
translation 

01:42:58.486 --> 01:43:02.693
code.  We have preconfigured the
 apps.  We have fleshed out the 

01:43:02.694 --> 01:43:04.783
UI and used

01:43:14.890 --> 01:43:19.072
 create an instance to the 
Firebase off service,

01:43:23.194 --> 01:43:25.323
 have those references, we're 
going to prep some data, 

01:43:25.324 --> 01:43:29.477
including the file to be 
uploaded, before we actually do 

01:43:29.478 --> 01:43:33.654
the upload.  We're going to get 
two references.  One is where 

01:43:33.655 --> 01:43:37.817
we're going to upload the file, 
which would be under 

01:43:41.908 --> 01:43:44.040
 that we're going to up load 
this data.  We're going to set 

01:43:44.041 --> 01:43:50.286
some meta data.  Specifically, 
we'll set the audio file type.  

01:43:50.287 --> 01:43:56.519
AMR for Android and linear 16 
for iOS.  Once we have that data

01:43:56.520 --> 01:43:58.599
 set, let's perform the upload. 

01:44:02.700 --> 01:44:06.905
 Firebase's click file, which 
gives us a couple of listener 

01:44:06.906 --> 01:44:08.993
options.  If something goes 
wrong, we're going to show the 

01:44:08.994 --> 01:44:13.207
user that the upload failed.  In
 the case of success, we will 

01:44:13.208 --> 01:44:17.345
have a listener that takes 
metadata, specifically the type 

01:44:17.346 --> 01:44:21.481
of encoding, the language of 
origin, and the location of 

01:44:21.482 --> 01:44:25.663
cloud storage, and we're going 
to write this.  Because we're 

01:44:25.664 --> 01:44:27.752
writing it to the realtime 
database, this will enable all 

01:44:27.753 --> 01:44:31.923
of our clients to, in realtime, 
get updates when something 

01:44:34.003 --> 01:44:36.058
happens.  That's actually all 
the code that we need.  Let's 

01:44:36.059 --> 01:44:40.248
see a demo.  Fire this up in 

01:44:46.361 --> 01:44:48.361
right.  Let's try iOS.  

01:44:52.540 --> 01:44:54.659
English.  I'm going to make a 
recording.  Hello 

01:44:58.768 --> 01:45:00.886
 no.  It says failed to upload 
audio with

01:45:04.981 --> 01:45:09.187
 Our first demo failure of the 
day.  We want to see this error 

01:45:09.188 --> 01:45:13.352
message.  That's because we have
 no authentication and our 

01:45:13.353 --> 01:45:15.469
Firebase, our cloud storage is 
secure.  There are two ways to 

01:45:15.470 --> 01:45:17.555
get around the error.  The 
first, which I know a lot of you

01:45:19.645 --> 01:45:21.735
 do, is open it up for everyone.

01:45:25.855 --> 01:45:30.148
 and write to your storage 
bucket.  But that's not what 

01:45:30.149 --> 01:45:34.291
we're going to do.  We're going 
to put authentication on your 

01:45:34.292 --> 01:45:36.374
app to make sure that not 
everybody on the internet is 

01:45:36.375 --> 01:45:42.602
uploading files.  What could 
possibly go wrong? We will set 

01:45:42.603 --> 01:45:48.855
up the auth flow.  If the user 
is not authenticated, we will 

01:45:48.856 --> 01:45:53.038
use Firebase UI, which is an 
open source library, that has 

01:45:53.039 --> 01:45:57.229
social flows for all of your 
providers like Google, Twitter, 

01:45:59.295 --> 01:46:03.473
Facebook, and so forth.  It is 
UI out of the box that is 

01:46:03.474 --> 01:46:05.474
configureable, so you can get an

01:46:07.586 --> 01:46:11.745
 out-of-the-box UI that is 
configureable with very little 

01:46:11.746 --> 01:46:13.831
effort.  Let's try the demo 
again and hopefully get a little

01:46:13.832 --> 01:46:17.989
 better results.  With just a 
few lines of code, we're 

01:46:17.990 --> 01:46:19.990
enabling

01:46:22.115 --> 01:46:24.254
 now I'll sign in. 

01:46:28.342 --> 01:46:32.495
 As prompted.  And once I've 
signed in, make another 

01:46:32.496 --> 01:46:34.496
recording.  

01:46:40.693 --> 01:46:42.805
 Kathy.  Now to prove that 
wasn't a trick, we actually did 

01:46:42.806 --> 01:46:46.966
an upload.  Jen's got a console 
here in Firebase.  You can see 

01:46:46.967 --> 01:46:51.158
that it has the data about the 
file we just uploaded, like the 

01:46:51.159 --> 01:46:55.331
encoding type, file type, and 
also the location in cloud 

01:46:55.332 --> 01:46:59.480
storage.  Let's actually go to 
cloud storage and see the file 

01:46:59.481 --> 01:47:03.647
that we've just created when 
Kathy recorded her voice. 

01:47:07.784 --> 01:47:11.990
 to Jen's local workstation.  
We'll put it into our audio 

01:47:11.991 --> 01:47:13.991
player so you can actually hear

01:47:24.257 --> 01:47:26.381
 recording and uploading 
successfully.  There's only one 

01:47:26.382 --> 01:47:30.581
more thing that we need to add 
to our client.  When the 

01:47:30.582 --> 01:47:32.670
translation happens, we need to 
display that in the client and 

01:47:32.671 --> 01:47:36.844
play the text out loud.  Let's 
do that now.  Pop back over to 

01:47:36.845 --> 01:47:43.066
our code.  We're going to do a 
couple things.  We're going to 

01:47:43.067 --> 01:47:47.240
connect to the Firebase realtime
 database.  We're going to 

01:47:47.241 --> 01:47:53.510
listen on the translations node 
on the JSON tree.  We have a 

01:47:55.611 --> 01:47:59.773
translation node and every time 
something comes in, it gets a 

01:47:59.774 --> 01:48:06.021
new child node under that.  It's
 all asynchronous.  As they're 

01:48:06.022 --> 01:48:10.169
getting translated, it pop

01:48:14.265 --> 01:48:16.348
 pop lates it.  We're going to 
have a second listener just

01:48:20.470 --> 01:48:22.582
 way if we're listening for 
English, and it gets finished 

01:48:22.583 --> 01:48:24.667
first, then our app will get 

01:48:28.760 --> 01:48:30.760
updated

01:48:34.898 --> 01:48:37.039
 take the text that comes back 
from Firebase, and we're going 

01:48:37.040 --> 01:48:41.181
to pipe it to our update and 
play method here in our app, 

01:48:41.182 --> 01:48:47.436
which actually uses 
text-to-speech within the 

01:48:47.437 --> 01:48:49.547
Android and iOS apps to play 
that out loud.  Let's actually 

01:48:49.548 --> 01:48:57.927
load up the demo again.  And all
 right.  So the piece we don't 

01:48:57.928 --> 01:49:02.127
have yet is the part that 
actually takes the audio file, 

01:49:02.128 --> 01:49:06.295
listens to it, turns it into 
text, and then translates that 

01:49:06.296 --> 01:49:10.461
into another language.  But we 
actually do have that 

01:49:12.547 --> 01:49:18.829
technology.  So we've got some 
Gen powered translation.  So 

01:49:18.830 --> 01:49:23.009
what Jen's going to do is 
manually listen to the audio 

01:49:23.010 --> 01:49:27.174
file, go into the Firebase 
database, add a child under the 

01:49:27.175 --> 01:49:29.175
translation

01:49:33.270 --> 01:49:35.347
 object, and put in her desired 
translation: English in this 

01:49:35.348 --> 01:49:37.425
case.  You can see that it shows

01:49:41.523 --> 01:49:43.627
 I'm concerned, we have the 
pieces we need.  Audio files 

01:49:43.628 --> 01:49:45.697
recording, uploading, Jen doing 
the listening

01:49:49.785 --> 01:49:54.003
 know, everything is good.  So 
that's a problem.  So if you 

01:49:54.004 --> 01:50:00.251
need any translation between the
 hours 11:00 p.m. and 7:00 a.m.,

01:50:00.252 --> 01:50:06.499
 unfortunately our service will 
be offline.  If only there were 

01:50:06.500 --> 01:50:08.578
some buzzword that could do some
 of this for us.  Maybe 

01:50:08.579 --> 01:50:12.724
something like machine learning.
  Let's bring Kathy out and she 

01:50:12.725 --> 01:50:16.899
will talk to us about how we can
 solve this using Machine 

01:50:16.900 --> 01:50:18.900
Learning. 

01:50:20.994 --> 01:50:23.103
 avoid the problem of Jen having
 to manually translate all of 

01:50:23.104 --> 01:50:27.265
our recordings, we're going to 
plug in some software.  It would

01:50:27.266 --> 01:50:33.525
 be a cool project to design and
 train our own Machine Learning 

01:50:33.526 --> 01:50:37.721
models, that would take longer 
than we want now, as we want to 

01:50:37.722 --> 01:50:39.788
quickly get this app up and 
running.  So that's

01:50:43.917 --> 01:50:50.154
 where we go to Google Cloud 
machine learning pretraining 

01:50:52.238 --> 01:50:54.327
APIs.  There are a set to solve 
common use cases such as image 

01:50:56.409 --> 01:50:58.476
recognition, and in this case, 
we'll pick the two that are for 

01:50:58.477 --> 01:51:04.717
our app.  So we be using the 
cloud speech API to transcribe 

01:51:04.718 --> 01:51:10.954
audio recording into text, and 
then translation API to 

01:51:10.955 --> 01:51:13.031
translate among all the 
different languages.  So now do 

01:51:13.032 --> 01:51:15.109
we have all the components to 
make our app work? Seems like 

01:51:19.227 --> 01:51:25.522
 are we going to wire these cool
 cloud APIs into our app? 

01:51:25.523 --> 01:51:27.586
Traditionally with Firebase 
apps, you would bake everything 

01:51:27.587 --> 01:51:31.760
into the client, which is great 
because it's serverless.  But we

01:51:31.761 --> 01:51:35.942
 do run into a few challenges 
that many apps will come across 

01:51:35.943 --> 01:51:37.943
as they scale.  For example, 
your

01:51:40.024 --> 01:51:44.268
 our case, we have API keys that
 will be used with those two 

01:51:44.269 --> 01:51:50.540
cloud APIs, and may have some 
pre-release feature flagged code

01:51:52.643 --> 01:51:54.717
 packaged with your app that is 
possibly discoverable by users. 

01:51:58.831 --> 01:52:00.952
 logic that's 
resource-incensive.  Our end 

01:52:00.953 --> 01:52:05.110
user devices could have their 
battery drain quickly by 

01:52:05.111 --> 01:52:11.342
performing all of these 
translations.  And building 

01:52:11.343 --> 01:52:17.624
mobile applications across 
platforms often requires writing

01:52:17.625 --> 01:52:19.746
 logic multiple times.  We would
 prefer to avoid that, if 

01:52:21.837 --> 01:52:26.027
possible.  Our app has all of 
these challenges, but we can 

01:52:26.028 --> 01:52:30.211
mitigate them by moving our API 
secrets and resource-intensive 

01:52:30.212 --> 01:52:34.379
code into the cloud, where we 
can write the translation logic 

01:52:34.380 --> 01:52:38.567
once and have it work for 
Android and iOS apps.  What 

01:52:38.568 --> 01:52:40.643
might that actually look like, 
though? You might think first of

01:52:42.743 --> 01:52:46.879
 something like this, where you 
spin up some compute instances 

01:52:46.880 --> 01:52:51.108
that will trigger APIs.  But 
there's actually some complexity

01:52:51.109 --> 01:52:55.275
 to that.  As you scale, you'll 
have to deal with load 

01:52:55.276 --> 01:52:59.431
balancing, caching, rapid 
requests to your various 

01:52:59.432 --> 01:53:03.579
servers.  And soon you may end 
up actually managing something 

01:53:03.580 --> 01:53:05.685
that looks like this, which is 
more complexity than 

01:53:09.791 --> 01:53:13.966
 Google, we've been helping to 
manage your app architecture 

01:53:13.967 --> 01:53:15.967
stress for a long time. 

01:53:18.060 --> 01:53:20.135
 Google Cloud platform started 
with AppEngine in 2008, the 

01:53:20.136 --> 01:53:22.237
original platform as a service. 
 And while a lot has changed 

01:53:22.238 --> 01:53:26.389
since then, we've built on our 
decade of experience providing 

01:53:26.390 --> 01:53:30.541
compute solutions for your apps 
to deliver the right solution 

01:53:30.542 --> 01:53:36.744
for our use case.  So now, 
instead of this, we'll actually 

01:53:36.745 --> 01:53:45.070
use cloud function, which will 
serve as the glue for our 

01:53:45.071 --> 01:53:47.146
serverless app.  Now we have a 
new recipe that looks like this 

01:53:47.147 --> 01:53:53.386
where we'll put our app keys 
into our CloudFunctions and any 

01:53:53.387 --> 01:53:57.533
other secrets.  Have that be 
research intensive, and then 

01:53:57.534 --> 01:53:59.602
write the fmt and have them

01:54:07.686 --> 01:54:09.752
 execute the logic for both 
mobile apps.  Now Bret will show

01:54:09.753 --> 01:54:11.753
 us

01:54:13.860 --> 01:54:18.060
 get started, it's actually 
pretty simple.  We have a few 

01:54:18.061 --> 01:54:22.245
variables up top that include 
our credentials for using cloud 

01:54:22.246 --> 01:54:26.400
APIs as well as a function set 
here.  And then we'll start with

01:54:26.401 --> 01:54:30.634
 our first cloud function, which
 you specify trigger that 

01:54:30.635 --> 01:54:36.902
invokes the function, which in 
this case would be a new upload 

01:54:36.903 --> 01:54:41.075
of the audio recording to the 
Firebase realtime database, and 

01:54:41.076 --> 01:54:47.323
we listen on the upload node.  
And when we get a new upload in 

01:54:47.324 --> 01:54:55.632
that sub tree, we will pull some
 meta data from it, and then 

01:54:55.633 --> 01:54:59.839
make a call to the cloud speech 
API to get the transcript of the

01:54:59.840 --> 01:55:06.102
 text.  And we send along the 
location in cloud storage of the

01:55:06.103 --> 01:55:12.396
 actual binary data of the audio
 recording.  When we get back, 

01:55:12.397 --> 01:55:16.582
the transcript will write it 
back to the realtime database 

01:55:16.583 --> 01:55:21.471
under transcripts to set us up 
for the next part, which is 

01:55:21.472 --> 01:55:27.704
translation.  For translation, 
we'll create a second cloud 

01:55:27.705 --> 01:55:31.873
function, this time listening to
 the translation sub tree in the

01:55:31.874 --> 01:55:33.940
 realtime database.  Upon 
getting a new transcript 

01:55:33.941 --> 01:55:38.122
written, it will take that and 
it rate through all the 

01:55:38.123 --> 01:55:42.276
languages that our app supports 
and for each language make a 

01:55:42.277 --> 01:55:46.461
call to the translation API, get
 the translation and write it 

01:55:46.462 --> 01:55:52.698
back to our realtime database 
under translation.  At the end, 

01:55:52.699 --> 01:55:54.778
process all of our languages and
 signal that our function is 

01:55:54.779 --> 01:55:58.968
complete.  At this point, we 
have all the logic that we need 

01:55:58.969 --> 01:56:03.115
to make our app work.  And all 
we have left is to deploy the 

01:56:05.206 --> 01:56:11.436
function, which is pretty 
straightforward with a Firebase 

01:56:11.437 --> 01:56:13.508
deploy command, you can deploy 
all the functions that you've 

01:56:13.509 --> 01:56:17.684
written.  It might take a couple
 minutes, and we have precious 

01:56:17.685 --> 01:56:21.848
time here.  We have done the 
deployment.  This is what it 

01:56:21.849 --> 01:56:23.936
looks like.  I'll hand it back 
to Jen to show us what the 

01:56:23.937 --> 01:56:26.024
working translation app looks

01:56:30.115 --> 01:56:34.345
 need all of your help.  Those 
of you here present, and those 

01:56:34.346 --> 01:56:38.471
of you on the internet, via the 
live stream, I know you all have

01:56:38.472 --> 01:56:42.648
 some kind of computing device 
with you, and many of those 

01:56:42.649 --> 01:56:46.822
contain web browsers.  Go to 
this URL on your computing 

01:56:46.823 --> 01:56:51.007
thing.  If you want to be extra 
awesome, turn your volume up a 

01:56:51.008 --> 01:56:53.008
little bit, maybe all

01:56:55.116 --> 01:56:57.246
 there won't be a rickroll or 
anything like 

01:57:01.335 --> 01:57:07.611
 our app.  So we're going to go 
back over to see our app with 

01:57:07.612 --> 01:57:09.708
everything together.  So I'm 
going to switch over to the one 

01:57:09.709 --> 01:57:13.873
that's wired up to the 
CloudFunctions, and we're going 

01:57:13.874 --> 01:57:18.059
to give it a spin.  I mentioned 
that I'm a mono

01:57:22.139 --> 01:57:24.139
 language

01:57:26.242 --> 01:57:28.365
 another language and see it 
translate.  There's my terrible 

01:57:28.366 --> 01:57:32.540
attempt at a foreign language.  
Let's see.  So it's uploaded and

01:57:34.641 --> 01:57:36.736
 it's up in the cloud doing the 
translation. 

01:57:44.928 --> 01:57:49.117
 languages.  If we switch to 
English and we see good morning,

01:57:49.118 --> 01:57:53.300
 baby.  Okay.  So my Japanese is
 not that good.  Anybody want to

01:57:53.301 --> 01:57:55.301
 give me a reply

01:57:57.407 --> 01:58:01.620
 I do have a reply to you, Jen. 
 I will switch the language 

01:58:01.621 --> 01:58:07.863
picker to yet another language, 
and here we go. 

01:58:11.975 --> 01:58:13.975
Speaking 

01:58:16.123 --> 01:58:18.242
 should be triggering. 

01:58:28.402 --> 01:58:30.402
 know how to say good morning, 
kind

01:58:32.547 --> 01:58:34.694
 of people in the audience using
 it, and I heard a lot of 

01:58:34.695 --> 01:58:40.955
syllables in languages that I 
don't understand.  How did it 

01:58:40.956 --> 01:58:43.033
translate? Did anybody pick 
anything other than English, 

01:58:43.034 --> 01:58:45.034
French,

01:58:49.201 --> 01:58:51.201
 of.  It's

01:58:53.340 --> 01:58:55.340
 that in

01:58:56.419 --> 01:58:58.419
 our next version.  But, I think
 it's time for

01:59:00.524 --> 01:59:02.524
 take a little

01:59:04.695 --> 01:59:08.909
 peek at what we did the last 20
 minutes or so.  We went in with

01:59:08.910 --> 01:59:13.045
 a plan to help us translate and
 more easily communicate with 

01:59:13.046 --> 01:59:17.203
people all over the world.  And 
how we solved all of or problems

01:59:17.204 --> 01:59:21.391
 in life, by writing mobile 
apps.  We wrote two apps.  We 

01:59:21.392 --> 01:59:25.611
wrote an Android and iOS app.  
Once those were built, we also 

01:59:25.612 --> 01:59:27.706
built out a back end to connect 
those all together and to 

01:59:27.707 --> 01:59:33.969
connect into third-party APIs.  
So whereas in the past you might

01:59:33.970 --> 01:59:36.073
 have built something like this,
 which we could not have 

01:59:36.074 --> 01:59:42.317
possibly done in a half hour 
session.  But we have a new 

01:59:42.318 --> 01:59:46.481
arrow in our quiver with 
Firebase.  We're able to connect

01:59:46.482 --> 01:59:50.653
 all of the single and in 
between apps together and using 

01:59:50.654 --> 01:59:52.711
the various backend services and
 taking it a step firther with 

01:59:52.712 --> 01:59:58.959
cloud services.  This allows us 
to take advantage of all of the 

01:59:58.960 --> 02:00:01.054
cool stuff that Firebase has to 
offer and connect it to third 

02:00:01.055 --> 02:00:07.275
party APIs out there, whether 
they be APIs Google Cloud 

02:00:07.276 --> 02:00:13.534
platform or your own vendors or 
home brew APIs.  Here's where I 

02:00:13.535 --> 02:00:15.535
have a challenge

02:00:17.625 --> 02:00:19.755
 you have another arrow in your 
quiver that you can use to solve

02:00:19.756 --> 02:00:26.047
 all of your app problems.  I 
would challenge you to use this 

02:00:26.048 --> 02:00:28.114
formula and tell us about what 
you've built.  We love hearing 

02:00:28.115 --> 02:00:32.281
from you.  So go ahead, build 
stuff, and then let us know how 

02:00:32.282 --> 02:00:36.459
it goes.  We'd love to hear from
 you about questions, concerns, 

02:00:36.460 --> 02:00:38.460
and just awesome stuff you want 
to

02:00:42.625 --> 02:00:48.923
 you.  DMs are definitely 
welcome.  We'd love feedback on 

02:00:48.924 --> 02:00:53.073
our section as well.  Scan our 
QR code or go to the URL at the 

02:00:53.074 --> 02:00:55.074
bottom of the page and

02:19:23.780 --> 02:19:26.106
&gt;&gt; Hello, everybody, I'm James 
Daniel developer  relations with

02:19:26.201 --> 02:19:28.937
 Firebase.  And I'm here to talk
 to you  about all of the things

02:19:29.133 --> 02:19:37.122
 that you can do with Cloud  
Functions for Firebase.  So to 

02:19:37.123 --> 02:19:39.860
set the stage for my talk talk, 
I would like to talk about what 

02:19:39.861 --> 02:19:44.555
you could do in  the good ol' 
days before Firebase.  So a 

02:19:44.556 --> 02:19:49.341
traditional  application, you 
would interact with a 

02:19:49.342 --> 02:19:54.090
intermediate  server with API.  
Maybe this application, this API

02:19:54.281 --> 02:20:02.174
  server is written in Rail, 
maybe express.  It handles  all 

02:20:02.175 --> 02:20:05.403
of your server authentication 
project.  Server,  secrets, all 

02:20:05.404 --> 02:20:09.135
of that proprietary stuff, as 
well as all  the busy work, 

02:20:09.136 --> 02:20:12.983
computationally intense work.  
But it  can't 

02:20:52.842 --> 02:20:58.120
that's where Firebase comes in, 
and giving this  talk, I hope 

02:20:58.121 --> 02:21:01.071
you're at least familiar with 
Firebase.  So  Firebase 

02:21:01.072 --> 02:21:05.449
applications.  We've written an 
SDK for you, in

02:21:09.391 --> 02:21:12.742
  iOS, Android, mobile Web, and 
a lot of other frameworks,  and 

02:21:12.743 --> 02:21:18.085
that SDK communicates to the 
Firebase service.   There is no 

02:21:18.086 --> 02:21:22.124
intermediate intermediary 
gatekeeper.  Google handles all 

02:21:22.125 --> 02:21:23.729
 of
  that for you with a suite of 

02:21:23.730 --> 02:21:27.774
tools that are called  directly 
from the SDK itself.  Very 

02:21:27.775 --> 02:21:32.324
powerful manage  services that 
allow you to go on building an 

02:21:32.325 --> 02:21:36.372
app, rather  than working on all
 the boiler boilerplate.  So we 

02:21:36.373 --> 02:21:40.497
have  authentication, we have 
our realtime database, we have  

02:21:40.498 --> 02:21:45.241
cloud messages, and lots of more
 products there.  And  really, 

02:21:45.242 --> 02:21:48.590
it's to empower you to deliver 
products faster  without 

02:21:48.591 --> 02:21:53.332
worrying about all the DevOps 
and stuff like  that.

02:21:57.373 --> 02:22:02.527
  There's also a realtime 
database.  How this is  

02:22:02.528 --> 02:22:04.431
differentiated from a 
traditional database is the  

02:22:04.432 --> 02:22:08.375
realtime database syncnizes sync

02:22:11.403 --> 02:22:15.061
 synchronizes all the changes in
  milliseconds.  And this allows

02:22:15.445 --> 02:22:18.980
 you to build very rich  
applications for free with 

02:22:18.981 --> 02:22:24.044
Firebase.  None of this, you  
know, having to spin up servers 

02:22:24.045 --> 02:22:28.615
and juggle sockets and  lots of 
complicated things.  So nice 

02:22:28.616 --> 02:22:32.575
little addition to  the Firebase
 product.  And if you are to 

02:22:32.576 --> 02:22:36.716
build your own  servers, you 
would have to build all of that 

02:22:36.717 --> 02:22:41.992
as well.   But there are 
problems in this thick client 

02:22:41.993 --> 02:22:44.323
model
   promoted by Firebase.  Not 

02:22:44.324 --> 02:22:49.589
without its disadvantages;  
right?  So while Firebase gives 

02:22:49.590 --> 02:22:53.839
you a very powerful tool  to 
validate the data coming to your

02:22:54.155 --> 02:22:58.514
 database to validate  the users
 writing, reading files, this is

02:22:58.903 --> 02:23:03.375
 our rules  engine, there are 
things that you can't quite do 

02:23:03.376 --> 02:23:08.023
in  Firebase without Cloud 
Functions.  So say you wanted to

02:23:08.745 --> 02:23:14.840
  perform an expensive operation
.  You want to resize an  image 

02:23:14.841 --> 02:23:17.932
or transcode a video, this is 
something that would  burn up 

02:23:17.933 --> 02:23:23.676
your user's battery, very likely
 to uninstall  your application 

02:23:23.677 --> 02:23:26.930
if you do that, and just, you 
know,  it's going to make your 

02:23:26.931 --> 02:23:29.575
application slower.  And, again,
  it's just a lot of complexity.

02:23:29.977 --> 02:23:33.841
  It's just shifting that  
complexity to the clients.  So 

02:23:33.842 --> 02:23:38.023
now you need to know how  to re
size an image on iOS, Android, 

02:23:38.024 --> 02:23:42.209
and then you're  going to have 
to do it on the Web for all 

02:23:42.210 --> 02:23:46.289
kinds of trick trickery.  So say
 you didn't want to trust the 

02:23:46.290 --> 02:23:50.586
client.   The realtime database 
has a very powerful rule step 

02:23:50.587 --> 02:23:53.810
but  can't encapsulate 
everything in there.  Say you

02:23:53.818 --> 02:24:00.185
  wanted  to moderate images.  
Say you wanted to filter out the

02:24:02.238 --> 02:24:06.984
  language.  What if you have 
secrets, what if you have  

02:24:06.985 --> 02:24:12.468
private keys, API tokens?  
Things you don't want on the  

02:24:12.469 --> 02:24:15.225
client.  Clients can't be 
trusted; right?  It's just an  

02:24:15.226 --> 02:24:19.296
application on their phone.  It 
can be cracked open.   They can 

02:24:19.297 --> 02:24:22.529
look at the secrets.  They can 
grab those.  So  you don't want 

02:24:22.530 --> 02:24:26.695
to put things like your push 
notification  secrets in there 

02:24:26.696 --> 02:24:31.449
to allow peer to peer messaging.
  That  would be leaking this 

02:24:31.450 --> 02:24:34.404
and somebody could crack the  
application, grab that secret, 

02:24:34.405 --> 02:24:38.142
and message your users in  mass.
  That's no good.

02:24:38.853 --> 02:24:43.710
Say you have a proprietary 
algorithm and act with  a third 

02:24:43.711 --> 02:24:47.885
party or maybe you need to 
expose a classic HTTP  end point

02:24:47.976 --> 02:24:53.872
.  These are all things that are
 hard to do on  Firebase.  So in

02:24:53.873 --> 02:24:58.217
 the good ol' days, you'll say 
this was  easier.  You know, my 

02:24:58.218 --> 02:25:02.682
server, it's mine, I control it,
 I  can make whatever APIs I 

02:25:02.683 --> 02:25:07.969
want.  I can do whatever I want 
 to do on there.  So why don't 

02:25:07.970 --> 02:25:16.142
we combine them?  So say  we 
attach generic computes to 

02:25:16.143 --> 02:25:21.140
Firebase, just using it as  a 
regular old client.  So it's 

02:25:21.141 --> 02:25:24.278
listening to changing the  
database, it's then writing into

02:25:24.281 --> 02:25:27.944
 the database.  In fact,  until 
recently, this was pushed as a 

02:25:27.945 --> 02:25:31.913
best practice to  the Firebase 
team with tools like Firebase Q 

02:25:31.914 --> 02:25:36.184
where you  would write into part
 of the database things that you

02:25:36.185 --> 02:25:42.185
  wanted these listening clients
 to do, these workers.   But now

02:25:42.496 --> 02:25:46.544
 you have this problem again.  
Now you have these  workers, 

02:25:46.545 --> 02:25:50.693
these generic compute, you have 
to scale them,  you have to pay 

02:25:50.694 --> 02:25:53.840
for the excess capacity, and 
then you're  going to have all 

02:25:53.841 --> 02:25:56.375
kinds of trouble coming
  around where,  oh, what if two

02:25:56.669 --> 02:26:00.625
 workers are doing the same job?
  Then  you're going to have a 

02:26:00.626 --> 02:26:09.044
lot of bike shedding about the  
way the realtime Firebase 

02:26:09.045 --> 02:26:12.582
database.  And wasn't Firebase  
supposed to make all of this 

02:26:12.583 --> 02:26:17.561
easy, after all?  It  promised 
to make us deliver applications 

02:26:17.562 --> 02:26:21.029
faster and now  where you're 
bike shedding, talking about how

02:26:21.232 --> 02:26:23.555
 to scale  these workers and now
 we need to spin

02:26:26.790 --> 02:26:30.844
 up a DevOps team,  it's no good
.  So that's why recently the 

02:26:30.845 --> 02:26:38.088
Firebase team  launched Cloud 
Functions into beta.  So how 

02:26:38.089 --> 02:26:41.631
Cloud  Functions for Firebase 
works is instead of spinning up 

02:26:41.632 --> 02:26:46.349
 general compute and teaching it
 to Firebase, we have  event-

02:26:46.765 --> 02:26:49.813
driven code execution.  It will 
scale up with your  usage, and 

02:26:49.814 --> 02:26:53.292
then down to zero not when in 
use.  And  you're only paying 

02:26:53.293 --> 02:26:59.887
for those milliseconds that you 
use.   This allows us to provide

02:26:59.996 --> 02:27:05.839
 that allows you to stitch all  
of Firebase's products together.

02:27:07.164 --> 02:27:12.170
So I mentioned event driven.  So
 what this is is  you actually 

02:27:12.171 --> 02:27:16.725
write snippets of code that 
listen to an  event -- this is 

02:27:16.726 --> 02:27:21.200
Node.js code.  Those functions 
are each  isolated, they're all 

02:27:21.201 --> 02:27:23.770
running separately.  So if one 
of  them crashes, it doesn't 

02:27:23.771 --> 02:27:28.093
take down the other.  And  
Windows events come in, it will 

02:27:28.094 --> 02:27:31.757
execute that code, and  it will 
either

02:27:35.196 --> 02:27:38.158
 write back to the database or 
trigger  some other action.  So 

02:27:38.159 --> 02:27:42.920
you can do things like listen to
  a database write.  Then the 

02:27:42.921 --> 02:27:47.180
code can sanitize the input  and
 write to another spot on the 

02:27:47.181 --> 02:27:52.542
database.
So let's see this in action.

02:27:52.835 --> 02:27:57.201
All right.  So here's a very 
minimal example.   This is 

02:27:57.202 --> 02:28:01.042
probably the basic example every
 time you see  something, we 

02:28:01.043 --> 02:28:05.801
have a hello world function here
.  So this  is a HTTP function. 

02:28:05.802 --> 02:28:12.183
 This allows us to spin up.  
This  function is actually in 

02:28:12.184 --> 02:28:15.631
the express JS style, and it  
sends hello world.  So this is 

02:28:15.632 --> 02:28:18.689
an HTTP request.  It is  
synchronous.  We don't want to 

02:28:18.690 --> 02:28:24.140
be doing Async work on  this.  
We want to send a response as 

02:28:24.141 --> 02:28:29.655
quick as we can.
So let's jump to a more 

02:28:29.656 --> 02:28:33.148
complicated example.  So  here's
 one where we're actually 

02:28:33.149 --> 02:28:37.104
listening to the  database.  So 
up here, we're actually 

02:28:37.105 --> 02:28:40.722
initializeing  Firebase 
functions and the admin, SDK, 

02:28:40.723 --> 02:28:46.631
for Firebase.   We're pulling in
 the configuration and 

02:28:46.632 --> 02:28:51.913
initializeing  Firebase admin.  
We're then listening on the 

02:28:51.914 --> 02:28:56.794
database,  this, and those are 
wild cards.  Those will be 

02:28:56.795 --> 02:29:01.558
parsed  into our parameters.  
And then on create means it's a 

02:29:01.559 --> 02:29:07.232
 database insert.  Rather than 
an update or destroy.  It  sends

02:29:07.430 --> 02:29:12.994
 an event object.  We pull the 
current value, we  pull the user

02:29:13.215 --> 02:29:19.075
 name from that, the text, title
 body, and  we send it to the 

02:29:19.076 --> 02:29:26.505
room ID on a FCM topic.  So what
 does  this do?  When a message 

02:29:26.506 --> 02:29:31.492
is posted to a chat room, it  
will notify through FCM push 

02:29:31.493 --> 02:29:35.054
notifications all  subscribers. 
 Regardless of platform; right? 

02:29:35.055 --> 02:29:38.153
 This could  be iOS, this could 
be Android, this could be the 

02:29:38.154 --> 02:29:42.382
Web.   And magically, they're 
going to get this.  And very low

02:29:42.540 --> 02:29:45.759
  code.  We run this, this is an
 independent function, we  just 

02:29:45.760 --> 02:29:48.604
deploy this.
 And Google is going to handle 

02:29:48.605 --> 02:29:52.865
all of  the scaling up and 
scaling down as needed.

02:29:56.108 --> 02:29:59.759
So what type of things do we 
have?  You already  saw the 

02:29:59.760 --> 02:30:03.027
HTTPS function.  That allows you
 to send an  express JS response

02:30:03.908 --> 02:30:06.851
.  This express JS object, it 
doesn't  have to be as simple as

02:30:07.552 --> 02:30:11.105
 just that response send, you 
can  actually create an express 

02:30:11.106 --> 02:30:14.764
JS application.  It could be  
your full JSON API.

02:30:15.141 --> 02:30:22.390
So where I had that hello world,
 that will match  any path on 

02:30:22.391 --> 02:30:26.010
there.  So you could just have 
exports API  and then give it an

02:30:27.122 --> 02:30:35.710
 express application that has 
your  entire JSON API.  There's 

02:30:35.711 --> 02:30:44.621
also cloud triggers.  It  allows
 you to do durable publish, 

02:30:44.622 --> 02:30:48.768
scribe.  Say, if you  do have a 
server, you could be writing to 

02:30:48.769 --> 02:30:54.029
a pub/subqueue  and then have a 
Node.js executed whenever 

02:30:54.030 --> 02:30:56.903
anything  triggers on that.
Cloud storage for Firebase.  So 

02:30:56.904 --> 02:31:04.794
when files are  uploaded, you 
can perform operations on them. 

02:31:04.795 --> 02:31:08.564
 Firebase  hosting.  So this 
integration allows you when 

02:31:08.565 --> 02:31:14.734
you're  using Firebase ecstatic 
Web base hosting to write proxy 

02:31:14.735 --> 02:31:19.198
 calls.  So you can put in URL 
pattern matches that will  re

02:31:19.201 --> 02:31:25.568
direct you to cloud function.
So I mentioned the API kits.  

02:31:25.569 --> 02:31:31.348
There we go.  That  allows you 
to take our static hosting and 

02:31:31.349 --> 02:31:34.949
make it  dynamic.  There's also 
the Firebase realtime database, 

02:31:34.950 --> 02:31:38.151
 as you saw.  And there's 
Firebase authentication.  So  

02:31:38.152 --> 02:31:43.823
when users are created, you can 
trigger code.  So a good  use 

02:31:43.824 --> 02:31:48.879
case for this is say you're 
storing user settings or or -- 

02:31:48.880 --> 02:31:51.950
in a realtime database, and you 
want to set some  defaults there

02:31:52.322 --> 02:31:58.007
.  Or you want to interact with 
a third  party and say set up a 

02:31:58.008 --> 02:32:02.766
customer record in Stripe or  
subscribe them to your mailing 

02:32:02.767 --> 02:32:06.500
list on SendGrid.  You  can 
actually do this with that.  And

02:32:06.926 --> 02:32:10.572
 you can pull in  this third 
party libraries.  I mentioned 

02:32:10.573 --> 02:32:13.719
those are  Node.js.  So you can 
pull in these dependencies if 

02:32:13.720 --> 02:32:18.500
they  have a Node.js module 
available on NPM.

02:32:18.994 --> 02:32:23.757
And then there's Google 
Analytics for Firebase.   So 

02:32:23.758 --> 02:32:29.047
those great Google Analytics 
conversion vents, you  can 

02:32:29.048 --> 02:32:34.407
listen for them and trigger code
.  So say a user  does a NF 

02:32:34.408 --> 02:32:39.996
purchase, you could send them an
 FCM saying  thank you or say in

02:32:39.999 --> 02:32:43.433
 the database, marking them as a
 VIP  customer.  And there's 

02:32:43.434 --> 02:32:45.907
many more coming soon.  If 
you're  interested in the 

02:32:45.908 --> 02:32:47.934
additional triggers that are 
coming  with Cloud Functions for

02:32:48.038 --> 02:32:53.586
 Firebase, I recommend that you 
 join our alpha program.  So 

02:32:53.587 --> 02:33:00.508
Firebase.Google.com/alpha.
All right.  So I'm asking you to

02:33:00.510 --> 02:33:03.043
 take Cloud  Functions to your 
customers.  It wouldn't really 

02:33:03.044 --> 02:33:07.589
be fair  if I wasn't willing to 
embarrass myself on stage.  So  

02:33:07.590 --> 02:33:10.138
time for a live demo.

02:33:21.635 --> 02:33:24.482
All right.  So what I've created
 here is actually  an 

02:33:24.483 --> 02:33:30.762
integration with Twilio.  So 
praying to the live demo  gods 

02:33:30.763 --> 02:33:32.795
that this will work.

02:33:36.543 --> 02:33:44.622
  So let's start by saying  
hello.  It wants me to send 

02:33:44.623 --> 02:33:49.843
pictures.  Let's grab one  from 
my Web camera.

02:34:04.835 --> 02:34:12.051
  Now let's see what it says.  
It's  analyzing.  That's 

02:34:12.052 --> 02:34:14.075
promising.

02:34:17.668 --> 02:34:23.140
  Awesome. hair.  That's  what 
it picked up.  Let's send it 

02:34:23.141 --> 02:34:25.220
another one.

02:34:43.651 --> 02:34:49.710
   Analyzing.  Music.  Cloud 
vision didn't quite know what  

02:34:49.711 --> 02:34:55.073
to think of doc Brown.
So how did I accomplish this?  

02:34:55.074 --> 02:34:59.965
Let's show you the  code.
So here, I actually have my 

02:34:59.966 --> 02:35:05.633
Twilio messaging call  back.  So
 what I've done here is create 

02:35:05.634 --> 02:35:10.589
an HTTPS trigger trigger, Twilio
 messaging call back, I glanced 

02:35:10.590 --> 02:35:15.039
on this,  but that is actually 
the root of the URL.  So it will

02:35:15.042 --> 02:35:22.341
 be  my Cloud Functions domain/
Twiliomessaging cele callback  

02:35:22.342 --> 02:35:28.315
will actually be the URL, and 
that will be on that part,  so 

02:35:28.316 --> 02:35:31.932
this if you were setting up an 
API, you could just do do/API, 

02:35:31.933 --> 02:35:34.081
pass an express application.  
But in this case,  I'm just 

02:35:34.082 --> 02:35:38.526
going to define it all here.  So
 I have an  HTTPS on request, 

02:35:38.527 --> 02:35:43.887
express JS.  So this is actually
 a lot  of this code here is 

02:35:43.888 --> 02:35:49.900
just dealing with the format 
that  Twilio is sending me.  So 

02:35:49.901 --> 02:35:55.256
I'm looking at the number of  
pictures.  If it's zero, I say 

02:35:55.257 --> 02:36:01.226
send me pictures.  I'm  going to
 create a payload because -- 

02:36:01.227 --> 02:36:07.223
well, maybe the MMS MMSs were 
back.  Maybe it sent more than 

02:36:07.224 --> 02:36:09.659
one at the same  time.  So I'm 
going to insert these into the 

02:36:09.660 --> 02:36:13.891
realtime  database.  So here I 
go.  I loop over them, add to 

02:36:13.892 --> 02:36:19.763
this  update payload, and then I
 insert into the database

02:36:19.764 --> 02:36:26.141
  by  doing update, then I'm 
sending Twilio ML.  So this is  

02:36:26.142 --> 02:36:33.345
actually an XML API.  And here, 
you can actually see I  have a 

02:36:33.346 --> 02:36:40.090
little helper down here.  
Response type XML, send send.  

02:36:40.091 --> 02:36:48.793
And then the XML there.
So that is actually inserting 

02:36:48.794 --> 02:36:51.531
into the database.   I'll 
actually show you where those 

02:36:51.532 --> 02:36:57.403
are coming in.  So  there we 
have the inbound MMS.  You can 

02:36:57.404 --> 02:37:04.071
see them coming  to the database
.  And I have a couple other if 

02:37:04.072 --> 02:37:10.187
 parameters here that were not 
for the Roman two URL that  I 

02:37:10.188 --> 02:37:14.913
set.  So those are coming in 
from these pair of  functions.  

02:37:14.914 --> 02:37:18.043
So these functions here are 
independent of  each other.  

02:37:18.044 --> 02:37:20.664
They're running in parallel.  
They don't  know about each 

02:37:20.665 --> 02:37:25.929
other.  They're isolated.  So 
here,  they're both listening to

02:37:25.934 --> 02:37:29.295
 an inbound MMS, and they're  
listening for that insert.  So 

02:37:29.296 --> 02:37:33.053
what this is doing is  grabbing 
the image URL, and it's using 

02:37:33.054 --> 02:37:37.613
the cloud vision  API.  So 
that's just an N PM module that 

02:37:37.614 --> 02:37:40.939
I initialize.   And it's doing 
label detection on those.  I 

02:37:40.940 --> 02:37:46.436
send it, the  image URI and the 
format that the API wants, and 

02:37:46.437 --> 02:37:49.891
that's  a promise.  So I listen 
for the result of that, Parse it

02:37:50.778 --> 02:37:56.842
 it, and then I write it to the 
interface.  So this event  data 

02:37:56.843 --> 02:38:02.921
admin.  So these database writes
 by default are  coming in

02:38:02.922 --> 02:38:06.371
  as the user who inserted them 
into the  database.  So the 

02:38:06.372 --> 02:38:12.429
Firebase realtime database rules
 will  respect that.  If I use 

02:38:12.430 --> 02:38:18.815
admin ref, then it's saying I  
want to by bypass these rules.  

02:38:18.816 --> 02:38:22.088
This works in the context  of 
Cloud Functions.  And admin 

02:38:22.089 --> 02:38:23.882
initialize.
So here I can actually bypass 

02:38:23.883 --> 02:38:27.221
the rules.  So my  database 
rules if I wanted, I could 

02:38:27.222 --> 02:38:32.278
actually make it so  that label 
annotations was actually not 

02:38:32.279 --> 02:38:37.437
writeable.  But  the admin short
 circuit that.  And then, again,

02:38:37.641 --> 02:38:42.086
 so  that's grabbing the label 
annotations, this is also off  

02:38:42.087 --> 02:38:48.258
of a safe search annotation.  So
 what I'm doing there is  Parse

02:38:48.682 --> 02:38:50.913
ening, whether or not it's safe 
for work.

02:38:51.126 --> 02:38:58.203
So if I go back to my realtime 
database, we have  label 

02:38:58.204 --> 02:39:05.234
annotations.  So music, that's 
where that came  from.  

02:39:05.235 --> 02:39:08.894
Performing arts, performance.  
Well, I guess that  is 

02:39:08.895 --> 02:39:10.895
performing parts in a

02:39:14.152 --> 02:39:16.676
 arts in a performance; right?  
Let's look  at our safe search 

02:39:16.677 --> 02:39:19.914
annotation.  So it's not very 
likely  to the adult content and

02:39:20.621 --> 02:39:25.371
 unlikely to be violent.
So how did we actually then send

02:39:25.896 --> 02:39:31.947
 a response back  to the user?  
So let's take a look at our code

02:39:32.256 --> 02:39:36.814
.  So here  we go.  We're 
actually responding to the MMS 

02:39:36.815 --> 02:39:43.377
with label.   So we're listening
 to the database, this inbound M

02:39:43.777 --> 02:39:47.695
MS  push ID on update.  So here 
we're not just listening for  

02:39:47.696 --> 02:39:51.499
the insert.  We're listening for
 whenever this node in  the 

02:39:51.500 --> 02:39:55.864
database is actually updated.  
So we're pulling in  the current

02:39:56.139 --> 02:40:00.782
 value.  We're also pulling in 
the previous  value.  Label 

02:40:00.783 --> 02:40:04.048
annotations.  And what I'm 
looking for is  that the label 

02:40:04.049 --> 02:40:10.103
annotations are not null, and 
that it  didn't previously have 

02:40:10.104 --> 02:40:14.057
label annotations.  So what I'm 
 doing there is listening for 

02:40:14.058 --> 02:40:19.095
the insert of the label  
annotations.  From and to.  I 

02:40:19.096 --> 02:40:24.245
put together the body, and  then
 the Twilio client messaging 

02:40:24.246 --> 02:40:31.432
create different body.
And here, I'm actually returning

02:40:32.131 --> 02:40:36.984
 because the  database ones 
allow for asynchronous responses

02:40:38.710 --> 02:40:43.100
.  So it  expects either a 
promise return, hence the return

02:40:43.408 --> 02:40:47.290
 the  Twilio client messages 
create, which is a promise, or 

02:40:47.291 --> 02:40:50.505
an  object.  That's the return 
null.  If it doesn't return  

02:40:50.506 --> 02:40:53.810
either one of these, it's going 
to be treated as an  error 

02:40:53.811 --> 02:40:59.182
condition.
So that is sent by the Twilio 

02:40:59.183 --> 02:41:04.487
client API, which is  just an N 
PM library, and I actually 

02:41:04.488 --> 02:41:07.524
initialize it with  function 
config, so there's actually run 

02:41:07.525 --> 02:41:11.839
time config  that you can set so
 that your secrets are not in 

02:41:11.840 --> 02:41:14.368
your  code.

02:41:18.648 --> 02:41:21.575
So we have this safe search 
annotation.  Where  does that 

02:41:21.576 --> 02:41:27.359
come into play?  That's the last
 function here here.  So here, 

02:41:27.360 --> 02:41:33.950
I'm also listening.  And what 
I'm  looking for is, again, the 

02:41:33.951 --> 02:41:38.494
insertion of the safe search  
annotation.  I'm looking at the 

02:41:38.495 --> 02:41:42.132
previous value.  So  label 
annotations is null.  Safe 

02:41:42.133 --> 02:41:47.214
search, null, then  we're going 
to return null.  Else, look for 

02:41:47.215 --> 02:41:51.642
it being un unlikely or very un
likely.  If it's either one of 

02:41:51.643 --> 02:41:56.400
those,  it short circuits and 
goes back here.  So then, it  

02:41:56.401 --> 02:42:01.604
actually writes to a public 
images route.  And there, I  

02:42:01.605 --> 02:42:07.425
have made a static website.

02:42:11.151 --> 02:42:17.223
Where you can actually see these
.  So it's very  fast to respond

02:42:17.524 --> 02:42:23.726
 here.  That's actually because 
it's  through Firebase static 

02:42:23.727 --> 02:42:30.145
hosting, so it's behind the  
global CDM.  And to prove that I

02:42:30.146 --> 02:42:33.230
 can actually look at  the 
source code, and there you can 

02:42:33.231 --> 02:42:35.231
actually see all of  those 
responses.

02:42:35.657 --> 02:42:39.913
So before in Firebase hosting, 
you couldn't have  these dynamic

02:42:40.253 --> 02:42:48.602
 type responses.  And this is a 
node  application. through 

02:42:48.603 --> 02:42:52.707
express.
So here, I'm actually

02:42:56.383 --> 02:42:58.383
 using

02:43:00.022 --> 02:43:04.487
 a JS application.  And  then 
I'm exporting app as this.

02:43:09.716 --> 02:43:13.310
  And if I go to my  Firebase 
configuration,

02:43:17.117 --> 02:43:23.202
 I'm actually rewriting the  
entire site to go to that cloud 

02:43:23.203 --> 02:43:28.645
function.  So star, star  goes 
to that cloud function.

02:43:36.359 --> 02:43:38.359
All right.

02:43:44.047 --> 02:43:47.360
  Well, before, we had Cloud 
Functions  for Firebase, 

02:43:47.361 --> 02:43:51.214
Firebase developers in order to 
get any of  this functionality 

02:43:51.215 --> 02:43:55.978
would have to spin up their own 
 servers.  That's a lot of cost 

02:43:55.979 --> 02:44:03.243
you would have to, you  know, 
have DevOps, you would have to 

02:44:03.244 --> 02:44:12.136
worry -- you would  have to 
worry about down network or slow

02:44:12.342 --> 02:44:17.076
 network  connections, whereas 
the Firebase STKs take care of 

02:44:17.077 --> 02:44:20.105
all  of this for you.  As a 
result, you would have a lot, a 

02:44:20.106 --> 02:44:27.092
 lot of complexity.  Now with 
Cloud Functions for  Firebase, 

02:44:27.093 --> 02:44:31.778
this is no longer the case.  You
 can actually  spin up robust 

02:44:31.779 --> 02:44:34.939
Node.js code to listen to

02:44:38.057 --> 02:44:44.928
 rights on the  database.  You 
can use the pub/sub to listen to

02:44:44.929 --> 02:44:48.672
 any  workers you have, and we 
have the HTTPS that takes in  

02:44:48.673 --> 02:44:52.881
full express application.  And 
they can pull in any of  the 

02:44:52.882 --> 02:44:56.386
power libraries available to you
 on NPM.  So I hope  I was able 

02:44:56.387 --> 02:45:00.331
to convince you that with Cloud 
Functions  with Firebase, you 

02:45:00.332 --> 02:45:03.470
can do all of the things, and 
you  don't need a server.

02:45:03.501 --> 02:45:05.501
[Applause]

02:45:13.746 --> 02:45:15.746
Thank you.

03:19:09.353 --> 03:19:11.886
&gt;&gt; How is everybody doing?
&gt;&gt; Hello.

03:19:11.887 --> 03:19:16.851
&gt;&gt; All right.  All right.  Yeah,
 we made it work.   I'm David, I

03:19:16.858 --> 03:19:21.532
 am a partner at a New York City
-based  digital agency.  We work

03:19:21.828 --> 03:19:28.219
 with large brands, large  
companies to launch mobile apps.

03:19:28.220 --> 03:19:30.220
&gt;&gt; Hi, everyone,

03:19:32.383 --> 03:19:35.320
 my name is Seth Ladd,, and I 
work  at Google.

03:19:35.321 --> 03:19:38.780
&gt;&gt; We work with the latest 
technologies to launch  a app in

03:19:38.784 --> 03:19:41.495
 the United States in record 
time.

03:19:46.589 --> 03:19:51.194
&gt;&gt; So as an agency, we always 
face tight deadlines deadlines. 

03:19:51.195 --> 03:19:55.327
 Our clients are pushing us to 
do more,  faster, and cheaper.  

03:19:55.328 --> 03:19:57.776
So we're always looking for 
across  platform technologies, 

03:19:57.777 --> 03:20:00.007
special architectures like  
service architectures like 

03:20:00.008 --> 03:20:02.228
you've been seeing a lot of  
today to help us do things 

03:20:02.229 --> 03:20:06.210
quicker.  Our clients want us  
to deliver value, not lines of 

03:20:06.211 --> 03:20:09.280
code or overhead.  They  don't 
want want us to reinvent the 

03:20:09.281 --> 03:20:12.104
wheel.  So we've been  looking 
at these technologies, but we 

03:20:12.105 --> 03:20:15.954
always had a bit  of skepticism,
 a little bit of lack of 

03:20:15.955 --> 03:20:21.326
competence.   Until recently, 
when we started working with 

03:20:21.327 --> 03:20:25.390
Flutter and  Firebase.
&gt;&gt; And we're very glad you found

03:20:25.508 --> 03:20:30.370
 Flutter.  At  Flutter, we help 
teams build quality apps faster 

03:20:30.371 --> 03:20:33.554
and  easier.  That's what we're 
all about.  In fact, at  Google 

03:20:33.555 --> 03:20:37.211
for a while now, we've been 
helping teams build  successful 

03:20:37.212 --> 03:20:40.777
and business-critical apps.  So 
then the  question we asked 

03:20:40.778 --> 03:20:43.308
ourselves is could we replicate 
the  success of Flutter outside 

03:20:43.309 --> 03:20:45.844
of Google?
&gt;&gt; So to help us answer that, we

03:20:46.060 --> 03:20:48.592
 started working  with the 
Google developer agency program,

03:20:48.808 --> 03:20:53.485
 which is how  we met David and 
Posse.  We thought Flutter was a

03:20:53.793 --> 03:20:58.964
 great  fit for agencies and any
 team that wanted to move fast  

03:20:58.965 --> 03:21:04.638
without sacrificing quality and 
needing to reach all  users 

03:21:04.639 --> 03:21:09.697
across all of mobile.
&gt;&gt; When we dug into Flutter, we 

03:21:09.698 --> 03:21:12.252
finally thought we  found a 
platform that we could use 

03:21:12.253 --> 03:21:17.401
across iOS and  Android that 
built apps that were in

03:21:17.407 --> 03:21:21.054
distinguishable from  coding 
apps.  A strongly-typed language

03:21:21.359 --> 03:21:25.914
, which is very  Devonte to our 
developer, and a hot reload 

03:21:25.915 --> 03:21:29.995
feature that  once we started 
using it drastically increased 

03:21:29.996 --> 03:21:32.409
our  developers.  We were ready 
to dive into this technology.   

03:21:32.410 --> 03:21:36.463
But as an agency, we need a 
client as excited about it  as 

03:21:36.464 --> 03:21:39.694
we were.  Then it happened.  
Hamilton, the hit  Broadway 

03:21:39.695 --> 03:21:42.263
musical in New York City called 
us up to do an  app.  And when 

03:21:42.264 --> 03:21:45.387
we told them about Firebase and 
Flutter,  they were as excited 

03:21:45.388 --> 03:21:48.682
about this as we were.  Now, for
  this of you who don't know, 

03:21:48.683 --> 03:21:52.607
Hamilton the musical is a  huge 
deal in the U.S.  They have a 

03:21:52.608 --> 03:21:56.967
very large and very  passionate 
fan base.  The musical is 

03:21:56.968 --> 03:21:59.592
constantly sold out out.  It's 
nearly impossible to get tickets

03:22:00.324 --> 03:22:06.818
 to across  the U.S.  It has won
 11 Grammys, an Emmy, and more.

03:22:08.806 --> 03:22:12.871
&gt;&gt; When the Hamilton team came 
to us, all they  cared about was

03:22:13.390 --> 03:22:15.443
 creating great experiences for 
their  fans.  They wanted to 

03:22:15.444 --> 03:22:19.371
give their fans as much as they 
 could.  And they had no 

03:22:19.372 --> 03:22:22.298
internal tech team.  So the idea
  of maintaining two separate 

03:22:22.299 --> 03:22:26.362
code bases for iOS or  Android 
or a Fleet of servers even on 

03:22:26.363 --> 03:22:29.107
Google Cloud or  something easy 
like cloud infrastructure was 

03:22:29.108 --> 03:22:31.742
daunting to  them.  This is a 
lot of technology for basically 

03:22:31.743 --> 03:22:35.727
a bunch  of theater people who 
have no technology in experience

03:22:36.435 --> 03:22:40.200
.   So the promise of cross 
platform frameworks and  

03:22:40.201 --> 03:22:42.221
serverless architectures was 
really interesting.  And  most 

03:22:42.222 --> 03:22:45.163
importantly, they had an 
incrediblely-tight deadline.   

03:22:45.164 --> 03:22:48.102
For all the features they had to
 do, they only had three  months

03:22:48.805 --> 03:22:51.949
, and this deadline could not be
 moved.  So at  that point the 

03:22:51.950 --> 03:22:55.200
Flutter team was very excited 
and  honestly a little nervous. 

03:22:55.201 --> 03:23:00.490
 Remember, at that time, it  was
 still early for Flutter.  It 

03:23:00.491 --> 03:23:03.913
hadn't yet been used  for such a
 prominent five star consumer 

03:23:03.914 --> 03:23:06.888
app.  The  Hamilton team had
  a long list of really 

03:23:06.889 --> 03:23:10.323
important  features and im
movable deadline, so could it 

03:23:10.324 --> 03:23:12.147
work?
&gt;&gt; And as if that pressure 

03:23:12.148 --> 03:23:15.796
wasn't high enough, we  got a 
phone call from the COO of 

03:23:15.797 --> 03:23:20.263
Hamilton and said  Hamilton is 
really big.  Fans love it.  

03:23:20.264 --> 03:23:22.898
We've never  failed at anything 
and this app will not be the 

03:23:22.899 --> 03:23:24.959
first  time.
&gt;&gt; So this is exactly the kind 

03:23:24.960 --> 03:23:28.079
of challenge our  team was 
looking for so of course we said

03:23:28.262 --> 03:23:33.243
, yes, let's do  it.  The posse 
team, Hamilton team, and Flutter

03:23:33.649 --> 03:23:37.501
 would  build a plan to execute.
  Posse would build an app to  

03:23:37.502 --> 03:23:44.506
the specification requirements 
of Hamilton.  And to fix  all 

03:23:44.507 --> 03:23:47.119
the requirements and use cases 
for the app.

03:23:47.120 --> 03:23:49.555
&gt;&gt; To give you an idea of what's
 in this app and  how 

03:23:49.556 --> 03:23:52.190
complicated it was, there's a 
whole lot of features  in here. 

03:23:52.191 --> 03:23:56.859
 And, again, three short months.
  And so  there's a lottery that

03:23:57.175 --> 03:23:59.980
 tickets are really hard to get.
   You have to buy them a year 

03:23:59.981 --> 03:24:03.940
out and aftermarket they're,  
like, $1,000 a piece.  So they 

03:24:03.941 --> 03:24:08.819
have this lottery that  you can 
enter to win $10 tickets.  Tens 

03:24:08.820 --> 03:24:16.479
of thousands of  people go for 
these every day.  And also a 

03:24:16.480 --> 03:24:19.210
place to buy  Hamilton 
merchandise.  And you need 

03:24:19.211 --> 03:24:22.573
Stripe integration  to process 
payment all done on cloud based 

03:24:22.574 --> 03:24:29.034
functions.   And we have this 
Newham cam feature with overlays

03:24:29.234 --> 03:24:31.679
 at the  theaters and other 
places.  A ton of features.  And

03:24:31.681 --> 03:24:34.545
  that's just the tip of the 
iceberg.  And, again, we had  

03:24:34.546 --> 03:24:37.547
almost no time to do this.  So 
being able to do this  really 

03:24:37.548 --> 03:24:41.398
quickly and really effectively 
and beautifully  via custom 

03:24:41.399 --> 03:24:44.342
branded design was absolutely 
essential.  But  the legal 

03:24:44.343 --> 03:24:47.490
question for this was could we 
build an app  with Flutter and 

03:24:47.491 --> 03:24:50.056
with Firebase on this timeline 
with all

03:24:50.057 --> 03:24:52.703
   of these features in a way 
that the fans would love it  and

03:24:52.707 --> 03:24:55.833
 they would feel that it was in
distinguishable from a  native 

03:24:55.834 --> 03:24:59.076
app?
&gt;&gt; And, yes, the fans loved it. 

03:24:59.077 --> 03:25:02.405
 The media loved  it.  And both 
the Appstore and the play store 

03:25:02.406 --> 03:25:05.818
both  featured the app.
&gt;&gt; And its uptake surprised even

03:25:06.017 --> 03:25:08.637
 the Hamilton team team.  Since 
we've launched, we've had almost

03:25:09.057 --> 03:25:11.958
 a million  installs, nearly 
half a million active users, 

03:25:11.959 --> 03:25:15.990
already  taken two million lot
tery entries, and we are already

03:25:16.286 --> 03:25:19.411
  one of the fastest growing 
apps on the Google Cloud  

03:25:19.412 --> 03:25:25.356
Platform.  Flutter and Firebase,
 these aren't just toys.   These

03:25:25.557 --> 03:25:28.483
 are real things that work in 
production at  tremendously high

03:25:29.776 --> 03:25:32.399
 scale.
&gt;&gt; So Flutter and Firebase are a

03:25:32.701 --> 03:25:35.115
 huge reason that  we got this 
app to so many fans quickly.  

03:25:35.116 --> 03:25:38.741
The speed of  development and 
the features that are given to 

03:25:38.742 --> 03:25:40.857
us by  these tools really 
couldn't be matched for our 

03:25:40.858 --> 03:25:44.280
timeline.   So what we want to 
do now is we want to share some 

03:25:44.281 --> 03:25:46.818
 patterns and code to show you 
that you too can use these  

03:25:46.819 --> 03:25:49.740
tools, that you can accelerate 
your process and benefit  from 

03:25:49.741 --> 03:25:52.461
them just like we did.  And 
we're going to start  first with

03:25:52.678 --> 03:25:58.211
 Firebase.  So Firebase offers a
 ton of tools.   You may have 

03:25:58.212 --> 03:26:00.821
been to some talks already today
 where  they're talking about 

03:26:00.822 --> 03:26:03.219
all the ways that you can use  
Firebase.  The really fun thing 

03:26:03.220 --> 03:26:06.429
about Firebase is you  can use 
as many of these things or as 

03:26:06.430 --> 03:26:09.864
few of these  things as you want
.  If you just want to use 

03:26:09.865 --> 03:26:16.652
Google  Analytics, no problem.  
Just add SDK, events, you have  

03:26:16.653 --> 03:26:22.134
analytics.  This is new to us.  
We only use Firebase.   The 

03:26:22.135 --> 03:26:24.385
authentication product was one 
that saved us a  tremendous 

03:26:24.386 --> 03:26:27.820
amount of time.  You add the SDK
, your  authentication strategy

03:26:28.219 --> 03:26:32.207
  is prebaked for you, pretty 
much much.  E-mail, phone number

03:26:32.498 --> 03:26:38.184
, Google log in, anything you  
want to do, it's there.  Google 

03:26:38.185 --> 03:26:41.409
Cloud storage or public  let's 
see the

03:26:46.577 --> 03:26:50.341
 pub/sub pub/sub, it's almost 
trivial.  And then there's the  

03:26:50.342 --> 03:26:52.891
realtime data.  It's a different
 type of database than  probably

03:26:53.179 --> 03:26:57.624
 a lot of you are used to.  But 
it's realtime.   And that's 

03:26:57.625 --> 03:27:00.375
something that our team hadn't 
really  experienced before.  We 

03:27:00.376 --> 03:27:03.197
were used to apps where you make
  a request, you get a response.

03:27:03.711 --> 03:27:08.112
  The realtime database,  once 
you add the Firebase SDK, it's 

03:27:08.113 --> 03:27:11.039
right there.  Your  data is live
.  We're really proud of the 

03:27:11.040 --> 03:27:14.288
fact that our  application does 
not have a single port of re

03:27:14.293 --> 03:27:16.406
fresh  anywhere in the app.  
What you see is what you get 

03:27:16.407 --> 03:27:20.278
live  in realtime.  But for us, 
the real start story is Cloud  

03:27:20.279 --> 03:27:24.194
Functions, which is relatively 
new.  Before this, you  know, we

03:27:24.503 --> 03:27:27.548
 used Firebase for other pieces,
 but not really  as a full, 

03:27:27.549 --> 03:27:30.604
complete server.  Cloud 
Functions gives us  the tools we

03:27:30.610 --> 03:27:33.010
 need for this to be a 
first-class back-end.

03:27:33.011 --> 03:27:37.261
  We used it to integrate with 
Stripe API and all kinds of  

03:27:37.262 --> 03:27:41.827
third party services.  We use it
 to fan out our data.   We use 

03:27:41.828 --> 03:27:46.288
it as an API.
So we have all of these tools, 

03:27:46.289 --> 03:27:48.912
realtime database,  Cloud 
Functions, and one of the things

03:27:49.219 --> 03:27:51.679
 that when we were  getting 
started is we had to figure out 

03:27:51.680 --> 03:27:55.021
how to make an  API out of these
 tools.  We're used to building 

03:27:55.022 --> 03:27:58.864
out  express or Rails servers 
where the app makes a request  

03:27:58.865 --> 03:28:01.898
for your response.  You probably
 all build APIs like  that 

03:28:01.899 --> 03:28:04.361
before for your apps.  We were 
struggling with how  do we do 

03:28:04.362 --> 03:28:07.410
this, you know,?  We didn't want
 to build a Web  server because 

03:28:07.411 --> 03:28:10.043
what's the point of a serverless
  architecture if you're making 

03:28:10.044 --> 03:28:14.495
servers?  And then it hit  us.  
We had this connection already 

03:28:14.496 --> 03:28:17.548
do our realtime  database the 
ability to read and write data 

03:28:17.549 --> 03:28:22.635
at  incrediblely fast speeds.  
And we have Cloud Functions.   

03:28:22.636 --> 03:28:25.236
So we divide this asynchronous 
approach where we use the  

03:28:25.237 --> 03:28:29.528
database as a connectiveity 
connectiveity mechanism to do 

03:28:29.529 --> 03:28:33.746
the same work  that we would 
typically do with a Web search. 

03:28:33.747 --> 03:28:36.012
 So, for  example, let's say the
 app wants to do something.  For

03:28:36.013 --> 03:28:38.945
  instance, enter the lottery.  
What we do is we drop

03:28:38.946 --> 03:28:41.253
  a  request, write a request to
 the Firebase realtime  database

03:28:41.653 --> 03:28:45.390
, we trigger a cloud function 
based on that, the  cloud 

03:28:45.391 --> 03:28:49.550
function does what we need to do
.  Checks the user user, does 

03:28:49.551 --> 03:28:52.893
the work that we don't want the 
client to do.   We want it to be

03:28:53.294 --> 03:28:56.224
 controlled and protected on our
 server.   When it's done, it 

03:28:56.225 --> 03:28:59.191
writes a response back to the  
realtime database.  The database

03:28:59.681 --> 03:29:02.942
 -- or the app is  listening to 
this node on the database.  And 

03:29:02.943 --> 03:29:06.669
since it's  realtime, as soon as
 we make that response, the app 

03:29:06.670 --> 03:29:11.626
gets  it, this is if your Web 
API responded with some JSON,  

03:29:11.627 --> 03:29:14.467
and there we have it.  We have 
an API.  It was  incrediblely 

03:29:14.468 --> 03:29:18.532
powerful for us.  Once we saw 
this pattern,  not only was it 

03:29:18.533 --> 03:29:22.569
high performance, it saved us a 
ton of  time.  This app has zero

03:29:22.784 --> 03:29:26.038
 networking.  We had zero HTTPS 
 Web APIs at all.  Everything is

03:29:26.230 --> 03:29:29.059
 done through the  database.  So
 this was, like, mind-blowing to

03:29:29.063 --> 03:29:32.598
 us and  saved us a tremendous 
amount of time.  So to show you 

03:29:32.599 --> 03:29:35.649
 that this is real and to show 
you how easy it is to  build an 

03:29:35.650 --> 03:29:37.460
API
  using the realtime database 

03:29:37.461 --> 03:29:40.123
and Cloud  Functions, we're 
going to demo this pattern.  

03:29:40.124 --> 03:29:42.751
This  pattern is basically the 
same exact pattern we're using  

03:29:42.752 --> 03:29:45.589
in this app that tens of 
thousands and upwards, we're  

03:29:45.590 --> 03:29:48.030
getting into the hundreds of 
thousands of users are  using 

03:29:48.031 --> 03:29:55.293
every single day.
Can we go to the slides, please,

03:29:55.789 --> 03:29:59.233
?  Or the code.   Sorry.  The 
first thing I wanted to show you

03:29:59.438 --> 03:30:02.073
 was the  package of JSON.  The 
reason I wanted to show you this

03:30:02.373 --> 03:30:05.099
  was because on our team, we're
 always looking to  eliminate as

03:30:05.327 --> 03:30:08.974
 many dependencies as we can.  
We really  only need two to get 

03:30:08.975 --> 03:30:12.382
this started.  We need the 
Firebase  admin module to talk 

03:30:12.383 --> 03:30:15.432
to the database, pretty much to 
 read and write to Firebase from

03:30:15.434 --> 03:30:19.062
 our server, and we need  our 
Firebase functions library to 

03:30:19.063 --> 03:30:21.595
register functions and  define 
our triggers.  You may notice 

03:30:21.596 --> 03:30:25.129
that we are  actually doing dev 
dependencies, we're using 

03:30:25.130 --> 03:30:30.214
TypeScript  that you'll see in 
Web pack.  This is one that 

03:30:30.215 --> 03:30:33.960
really  improved our efficiency 
during the process.  So how do  

03:30:33.961 --> 03:30:38.152
we create a function?  It's 
incrediblely easy.  In this  

03:30:38.153 --> 03:30:41.659
case it's JavaScript -- well, 
TypeScript.  You would  write it

03:30:41.940 --> 03:30:43.971
 like any other JavaScript 
function.  Again,  there's no 

03:30:43.972 --> 03:30:48.019
node here, no express, no middle
 wear, body  parsers, nothing 

03:30:48.020 --> 03:30:50.957
like that.  All we do is we 
define a  trigger path, how

03:30:50.958 --> 03:30:53.816
  we want our function to be 
invoked.   In this particular 

03:30:53.817 --> 03:30:57.457
case, since we're doing our 
request  response API, we want 

03:30:57.458 --> 03:31:02.622
to on create when someone adds 
new  data to our database, at a 

03:31:02.623 --> 03:31:06.445
particular path that we've  
defined, in this case requests 

03:31:06.446 --> 03:31:10.739
lottery entry, user ID  push key
.  When new data is written to 

03:31:10.740 --> 03:31:13.885
that path, it's  going to wake 
up our function and do the work 

03:31:13.886 --> 03:31:18.917
that we  need it to do.  So 
we've defined this interlotry  

03:31:18.918 --> 03:31:21.549
function.
So the key thing here is why are

03:31:21.551 --> 03:31:25.455
 we doing this why  do we care? 
 Historically, you might put a 

03:31:25.456 --> 03:31:28.557
lot of this  work on the client 
side or Firebase gives you 

03:31:28.558 --> 03:31:32.480
direct  read, write access into 
your app into Firebase.  But we 

03:31:32.481 --> 03:31:35.833
 don't want people just to drop 
a lottery entry into the  

03:31:35.834 --> 03:31:39.199
database.  That's something that
 can be abused.  So we.   The 

03:31:39.200 --> 03:31:42.613
this to be protected behind the 
API.  When the event  fires, and

03:31:42.618 --> 03:31:45.139
 it's triggered, it passes this 
event into our  function.  Event

03:31:45.529 --> 03:31:49.901
 has a bunch of data that we can
 access  from that event.  So 

03:31:49.902 --> 03:31:53.257
this is where we can get from 
our  database path, you can get 

03:31:53.258 --> 03:31:57.493
the user ID, we can get the  
actual data that the app passes 

03:31:57.494 --> 03:32:00.001
to us in the request  that stays
 in the database.

03:32:00.364 --> 03:32:03.586
So it behaves kind of like a Web
 API, but it's  just a database.

03:32:03.791 --> 03:32:07.331
  The next thing we do is we do 
some  sensitive business logic. 

03:32:07.332 --> 03:32:09.892
 These are stubbed out for the  
purposes of the demo.  But maybe

03:32:10.166 --> 03:32:14.038
 we want to check if the  user's
 eligible or make sure the 

03:32:14.039 --> 03:32:16.889
lottery's still open or  do 
something that's private that we

03:32:16.894 --> 03:32:18.992
 don't want the world  to know 
about.  We can do all of those 

03:32:18.993 --> 03:32:22.081
here.  Just  normal JavaScript. 
 They can be calls to third 

03:32:22.082 --> 03:32:26.204
party  APIs, they can be 
asynchronous things, whatever we

03:32:26.209 --> 03:32:29.042
 want  to do.  But assuming 
everything's okay, we define our

03:32:29.342 --> 03:32:32.210
  entry data object, and then we
 can save it out to the  

03:32:32.211 --> 03:32:36.543
database.  Now, this particular 
area of the database,  like, our

03:32:36.757 --> 03:32:39.384
 lottery entries right here, 
this is something  that is 

03:32:39.385 --> 03:32:41.934
protected by database rules.  
Nobody can read or  write to 

03:32:41.935 --> 03:32:45.997
this.  Rewrite false.  This is 
really important  because we 

03:32:45.998 --> 03:32:48.961
only want our systems to be able
 to allow  people to create a 

03:32:48.962 --> 03:32:52.268
lottery entry.  By doing it in 
this  pattern, we can make sure 

03:32:52.269 --> 03:32:54.497
that our API's safe.  Once  
we're

03:32:54.498 --> 03:32:57.528
  done with that, the user has 
successfully saved  their 

03:32:57.529 --> 03:33:00.783
lottery entry, now we just need 
to write the  response back to 

03:33:00.784 --> 03:33:04.017
our response node in the 
database.  A  helper function 

03:33:04.018 --> 03:33:07.343
here called respond, we'll maybe
 post  some of this code 

03:33:07.344 --> 03:33:10.201
afterwards.  But this just 
basically  writes our response 

03:33:10.202 --> 03:33:13.090
object with data, chance ID  
generated through this and maybe

03:33:13.259 --> 03:33:17.003
 a message.  We write  that back
 to the response node.  And 

03:33:17.004 --> 03:33:20.826
since the app after  it made the
 request has an active listener 

03:33:20.827 --> 03:33:24.899
on the  response, as soon as we 
make that write, the app gets  

03:33:24.900 --> 03:33:28.234
the update and the spinner stops
 spinning and the app is  done. 

03:33:28.235 --> 03:33:34.492
 But there's a key point we want
 to make.  Unlike  a normal Web 

03:33:34.493 --> 03:33:36.636
request where the connection is 
open, and  you close that 

03:33:36.637 --> 03:33:38.568
connection, and it's hanging out
 there,  and you're waiting for 

03:33:38.569 --> 03:33:41.684
the response to finish, this is 
 asynchronous.  Once we make 

03:33:41.685 --> 03:33:45.556
that request, the database,  the
 cloud function's running in the

03:33:45.761 --> 03:33:48.789
 background, it's  almost 
totally detached from the end.  

03:33:48.790 --> 03:33:51.625
So even though we  respond here
  and say, hey, you're done.  

03:33:51.626 --> 03:33:56.616
Congrats.  We  can keep going.  
Our cloud function doesn't have 

03:33:56.617 --> 03:34:00.422
to stop  there.  We can maybe 
fan out the data to other areas 

03:34:00.423 --> 03:34:03.575
of  the database or send a push 
notification or something  else.

03:34:03.769 --> 03:34:06.295
  When we're finally done, you 
just return and tell  our 

03:34:06.296 --> 03:34:08.741
function we're done.
So it's really cool.  Again, it 

03:34:08.742 --> 03:34:14.556
saved us a  tremendous amount of
 time.  Can we go back to the 

03:34:14.557 --> 03:34:16.557
slides slides?

03:34:17.949 --> 03:34:20.420
  And there's a few key points I
 wanted to  highlight here.  

03:34:20.421 --> 03:34:24.139
This is -- we call this 
asynchronous  database-driven 

03:34:24.140 --> 03:34:28.815
API.  No network code at all.  
In our  team, we always spend 

03:34:28.816 --> 03:34:32.331
more time than we expect writing
  code to interface with some 

03:34:32.332 --> 03:34:36.449
sort of Web server.   Networking
 code that we don't like writing

03:34:36.681 --> 03:34:39.229
 that we have  to where he re: 
write all the time that our 

03:34:39.230 --> 03:34:42.253
clients  don't care about.  No 
network.  It was all handled by 

03:34:42.254 --> 03:34:46.235
 the Firebase SDK the second we 
were able to interact  with our 

03:34:46.236 --> 03:34:48.982
database.  The other thing is 
there's no  authentication or 

03:34:48.983 --> 03:34:53.836
error handleing.  Again, all 
baked into  the Firebase SDK.  

03:34:53.837 --> 03:34:57.501
It's incrediblely-high scale as 
well.   Firebase scales really 

03:34:57.502 --> 03:35:00.788
nicely, and it has this amazing 
 realtime performance that we 

03:35:00.789 --> 03:35:03.869
were worried about how is  this 
going to work performance-wise? 

03:35:03.870 --> 03:35:07.664
 But because it's  such a 
blazing-fast database, the 

03:35:07.667 --> 03:35:09.153
performance has been  really 
amazing.  And

03:35:09.154 --> 03:35:11.589
  perhaps most importantly for 
our  client and for us, no 

03:35:11.590 --> 03:35:14.651
servers to maintain.  We didn't 
 have to worry about the type of

03:35:15.017 --> 03:35:18.392
 Web server we're using,  who's 
going to patch the libraries and

03:35:18.715 --> 03:35:21.168
 all the operating  systems that
 our servers are running and how

03:35:21.426 --> 03:35:24.679
 are we  going to handle the 
scale and how are we going to 

03:35:24.680 --> 03:35:27.829
auto  scale whenever lottery 
opens?  Cloud Functions and  

03:35:27.830 --> 03:35:32.492
Firebase just did it all for us.
  So Firebase really  worked for

03:35:32.497 --> 03:35:35.401
 us.  It was a tremendous win 
for the project,  but it was 

03:35:35.402 --> 03:35:40.569
only half the story.  We also 
had to craft  the beautiful, 

03:35:40.570 --> 03:35:43.614
custom design for Hamilton to 
really  showcase their brand in 

03:35:43.615 --> 03:35:46.547
an app.  And for that, we turn  
to Flutter, and I'm going to 

03:35:46.548 --> 03:35:50.084
turn it over to

03:35:53.433 --> 03:35:56.193
 Seth now.
&gt;&gt; Thanks, Dave.  As we heard in

03:35:56.197 --> 03:36:00.026
 the beginning,  Flutter is a 
mobile app SDK that makes it 

03:36:00.027 --> 03:36:03.740
easier to  deliver high-quality 
apps.  At its technical core,  

03:36:03.741 --> 03:36:08.092
Flutter is a portable renderer 
and toolkit.  Now, all of  these

03:36:08.370 --> 03:36:10.809
 layers you see here are 
compiled to native arm  code for

03:36:11.144 --> 03:36:14.041
 fast startup and predictable 
performance.

03:36:14.256 --> 03:36:18.295
But even more importantly, this 
portable renderer  is shipped 

03:36:18.296 --> 03:36:22.918
inside of your app when you 
deploy your app  via IPAs, the 

03:36:22.919 --> 03:36:27.973
renderer toolkit and your code 
are all  bundled together and 

03:36:27.974 --> 03:36:31.108
shipped out.  This means that 
the  beautiful pixels that your 

03:36:31.109 --> 03:36:34.429
designers work so hard on and  
the beautiful UI that your 

03:36:34.430 --> 03:36:37.561
developers built is the same  
beautiful experience your users 

03:36:37.562 --> 03:36:41.902
will get, no matter what  OEM 
version or OS version they 

03:36:41.903 --> 03:36:45.141
happen to be running.   Now, of 
course, I could keep telling you

03:36:45.460 --> 03:36:47.962
 about it, but  it's much cooler
 to show you about Flutter.  So 

03:36:47.963 --> 03:36:53.224
let's go  to the demo set up 
here.

03:36:54.717 --> 03:36:57.848
Okay.  We're going to show three
 important parts  of Flutter, 

03:36:57.849 --> 03:36:59.849
which

03:37:01.272 --> 03:37:05.325
 David took advantage of when 
they  built the app.  The first 

03:37:05.326 --> 03:37:07.434
is the reactive widget library 
library, the second is hot re

03:37:07.436 --> 03:37:12.796
load, and the third is  Flutter
Fire.  Let's start by the 

03:37:12.797 --> 03:37:15.816
lottery screens here on  the 
phone.  This is an iOS phone and

03:37:15.818 --> 03:37:18.442
 a Android phone.   You can see 
that it's a beautiful brand 

03:37:18.443 --> 03:37:22.283
first design,  and the colors 
look similar down here.  So it 

03:37:22.284 --> 03:37:26.020
could  deliver a consistent UI 
experience across all the users 

03:37:26.021 --> 03:37:28.875
 across all of mobile.  But just
 because these look  identical 

03:37:28.876 --> 03:37:33.291
doesn't mean that they have to 
act identical.   Flutter and 

03:37:33.292 --> 03:37:38.422
posse know that users on iOS has
 a  particularly muffle memory 

03:37:38.423 --> 03:37:41.749
when they scroll and a  
particular scrolling friction on

03:37:41.872 --> 03:37:44.581
 Android that they are  used to.
  So let's look at that on 

03:37:44.582 --> 03:37:48.938
Android, you can see  the over
scroll glow.  And on iOS, you 

03:37:48.939 --> 03:37:52.793
get the bounce.   So the 
Hamilton app is beautiful and a 

03:37:52.794 --> 03:37:54.921
consistent brand  experience and
 still feels very natural to 

03:37:54.922 --> 03:37:59.436
users on both  platforms.
Okay.  So let's pick a piece of 

03:37:59.437 --> 03:38:02.568
this UI and show  you how we 
built this.  We're going to pick

03:38:03.270 --> 03:38:06.808
 the little  blue badge here, 
the active badge here to play 

03:38:06.809 --> 03:38:10.270
with and  show you how it works.
  So let's go to the code here. 

03:38:10.271 --> 03:38:13.095
  This is the code for that 
active badge.  And the first  

03:38:13.096 --> 03:38:16.200
thing that I want you to notice 
is that it's all code.   There's

03:38:16.412 --> 03:38:20.353
 no markup, there's no XML, no 
other language  that you have to

03:38:20.554 --> 03:38:22.980
 learn or build tools for.  It's
 a  single language with a 

03:38:22.981 --> 03:38:26.047
single set of libraries for you 
 to build your UI, manipulate 

03:38:26.048 --> 03:38:29.448
your UI, and build your  
business logic.  This means that

03:38:29.452 --> 03:38:32.384
 you get the power of  code and 
the power of IDEs like 

03:38:32.385 --> 03:38:35.911
refactoring, et cetera,  when 
you build all aspects of that 

03:38:35.912 --> 03:38:39.580
front-end.  The other  thing I 
want you to see is that this 

03:38:39.581 --> 03:38:43.000
lottery state badge badge, this 
active blue box right here is 

03:38:43.001 --> 03:38:47.727
itself a  widget.  Widgets in 
Flutter are the core, basic 

03:38:47.728 --> 03:38:51.267
building  blocks of all UI.  In 
fact, widgets themselves are 

03:38:51.268 --> 03:38:56.170
made  out of more widgets.  This
 composition model, this  

03:38:56.171 --> 03:38:57.834
composition
  architecture is very powerful.

03:38:57.835 --> 03:39:00.543
  You can re recompose the core 
widgets that we ship in our 

03:39:00.544 --> 03:39:04.866
toolkit,  things like padding 
and text to more beautiful, 

03:39:04.867 --> 03:39:06.773
higher  level widgets which 
themselves can be composed.  

03:39:06.774 --> 03:39:11.313
It's a  really good model.  Now 
let's look at what it's like to 

03:39:11.314 --> 03:39:14.619
 actually code this UI.  Let's 
say that we did some user  

03:39:14.620 --> 03:39:20.060
studies and this blue here made 
may be not working.  So we  sit 

03:39:20.061 --> 03:39:23.174
next to our designer and we say 
what are the colors  you've got?

03:39:23.473 --> 03:39:25.593
  Well, of course we have all 
the colors.   But we have code 

03:39:25.594 --> 03:39:28.804
completion, so you can see what 
the  options there are, so let's

03:39:28.919 --> 03:39:33.134
 say we want to try green.   So 
I'm going to jump over to the 

03:39:33.135 --> 03:39:38.476
console that's driving  these 
two apps.  As it's initializeing

03:39:38.688 --> 03:39:42.127
 the system here,.   Okay.  
Great.  It has changed live, hot

03:39:42.925 --> 03:39:45.354
 reloaded to  change from blue 
to green.  Thank you.

03:39:45.394 --> 03:39:47.394
[Applause]

03:39:49.484 --> 03:39:54.827
This hot reload system really 
enabled posse and  others to 

03:39:54.828 --> 03:39:57.966
iterate very quickly in their 
development  cycle.  But we can 

03:39:57.967 --> 03:40:00.404
do more than change colors.  
Let's  change math here.  Let's 

03:40:00.405 --> 03:40:03.842
say we want to change the size  
of this button here live.  So 

03:40:03.843 --> 03:40:07.873
we're going to go over and  re
load here and, oh, no.  So what 

03:40:07.874 --> 03:40:12.298
just happened?  Well,  most of 
the UI rendered just fine.  But 

03:40:12.299 --> 03:40:15.946
the widget here,  this active 
widget had a syntax error and 

03:40:15.947 --> 03:40:19.166
luckily, the  framework said I 
can render everything except 

03:40:19.167 --> 03:40:21.686
that one  widget that you had, 
and I'm going to show you what 

03:40:21.687 --> 03:40:26.748
that  error is, and it even 
tells me what the syntax error 

03:40:26.749 --> 03:40:31.014
is  here in the red little box. 
 Sure enough, it's a syntax  

03:40:31.015 --> 03:40:34.932
that forgot to finish.  Let's go
 here, type R, and the  time it 

03:40:34.933 --> 03:40:39.563
takes me to look back here, we 
have not only  recovered from a 

03:40:39.564 --> 03:40:45.357
syntax error, live without re
starting  the app, but it's much

03:40:45.431 --> 03:40:47.759
 bigger to see.
There's one more aspect I want 

03:40:47.760 --> 03:40:51.282
to show.  Let's tap  on this 
button a couple of times and add

03:40:51.682 --> 03:40:54.409
 some state to  our app.  
Hopefully, you can see I've 

03:40:54.410 --> 03:40:57.561
tapped each button  seven times.
  State your app is a user 

03:40:57.562 --> 03:40:59.669
logged in or do I  have any 
items in the cart?  In this case

03:40:59.967 --> 03:41:04.512
, how many  times have I tapped 
the button?  So we're going to 

03:41:04.513 --> 03:41:09.279
make  another change here.  
Let's go to save, active, R for 

03:41:09.280 --> 03:41:13.107
re reload and boom right there. 
 Not only do you get that  about

03:41:13.113 --> 03:41:16.134
 a second hot reload experience,
 but the state of  my app 

03:41:16.135 --> 03:41:19.262
remained live.  So it's a state
ful hot reload.   This is really

03:41:19.703 --> 03:41:23.619
 powerful when you want to work 
in that  one esoteric screen 

03:41:23.620 --> 03:41:26.562
seven levels down in your app 
after  you've logged in, et 

03:41:26.563 --> 03:41:30.077
cetera, et cetera, you're all 
the  way in your app, and you 

03:41:30.078 --> 03:41:32.795
don't have to restart that flow 
 every time you want to make 

03:41:32.796 --> 03:41:34.796
these changes.  Stateful hot  re
load.

03:41:35.048 --> 03:41:37.746
Now, the next thing I want to 
show you is right  now, we're 

03:41:37.747 --> 03:41:40.302
just adding numbers here when I 
tap the  button.  But let's make

03:41:40.400 --> 03:41:44.043
 it real.  Let's make it connect
  to Firebase in the cool Cloud 

03:41:44.044 --> 03:41:48.272
Functions that David  showed us 
earlier.  So Flutter has an 

03:41:48.273 --> 03:41:51.396
awesome package  manager where 
you could just declare your 

03:41:51.397 --> 03:41:55.324
dependencies,  get your plugins,
 get your third-party libraries 

03:41:55.325 --> 03:41:58.961
and of  course Firebase through 
the Flutter fire package is a  

03:41:58.962 --> 03:42:02.505
first class citizen here in the 
ecosystem.  So it's very  easy 

03:42:02.506 --> 03:42:05.339
to declare.  Now let's go over 
to the code that  handles this 

03:42:05.340 --> 03:42:09.092
button press and instead of just
  incrementing a counter, we're 

03:42:09.093 --> 03:42:11.183
going to enter the lottery 
lottery.  And let's look at the 

03:42:11.184 --> 03:42:13.230
code for entering the  lottery. 
 There's two things I want to 

03:42:13.231 --> 03:42:19.078
point out.  One  is these calls 
to set state.  This is a 

03:42:19.079 --> 03:42:21.495
framework feature  of Flutter 
where you can easily identify 

03:42:21.496 --> 03:42:23.300
where the state  of your 
application is changing.  It 

03:42:23.301 --> 03:42:26.735
makes it very easy  to look 
around your code and say this is

03:42:27.054 --> 03:42:30.297
 where you  update the state
  or domain model.  Second, it 

03:42:30.298 --> 03:42:33.398
tells the  framework rebuild 
your UI.  So this is that 

03:42:33.399 --> 03:42:34.841
reactive  part of the Flutter 
framework that we're talking 

03:42:34.842 --> 03:42:38.571
about.   The second thing I want
 to show is post action.  A very

03:42:39.164 --> 03:42:42.696
  cool function that David and 
his team wrote to  encapsulate 

03:42:42.697 --> 03:42:47.435
that Async request for response 
pattern that  we saw earlier for

03:42:47.633 --> 03:42:53.686
 Cloud Functions, et cetera,.
Let's jump in here real quick.  

03:42:53.687 --> 03:42:56.213
I want to show  normal Firebase 
code.  If you're used to 

03:42:56.214 --> 03:43:00.153
Firebase, these  APIs are going 
to feel very familiar.  It's all

03:43:00.490 --> 03:43:03.998
 brought  up into Flutter for 
you to access.

03:43:04.182 --> 03:43:06.499
So we've made a significant 
change to our  application here.

03:43:06.818 --> 03:43:10.928
  We've added a huge business 
logic and  code to our app.  Now

03:43:11.236 --> 03:43:14.470
 let's do final hot reload.  In 
 about sun second again, our app

03:43:14.768 --> 03:43:17.869
 is updated.  And when I  tap 
this button, we're now really 

03:43:17.870 --> 03:43:20.746
talking to realtime  database, 
which really listens for Cloud 

03:43:20.747 --> 03:43:25.281
Functions and  really awaits for
 a response all hot reloaded and

03:43:25.479 --> 03:43:31.564
 live  for you.  Come on, iOS.  
Yes.  Okay.  Okay.  So there's  

03:43:31.565 --> 03:43:34.266
obviously a lot more cool 
features to Flutter in  Firebase

03:43:34.867 --> 03:43:39.109
, but hopefully you've got a 
sense about how  fast, fun, and 

03:43:39.110 --> 03:43:41.950
easy it is to build UIs and 
connect it to  Firebase.  So the

03:43:42.668 --> 03:43:45.092
 question is if we can go back 
to the  slides is how did this 

03:43:45.093 --> 03:43:48.837
actually work for David and his 
 team?

03:43:51.938 --> 03:43:54.259
&gt;&gt; So Flutter was really, really
 important.  Again Again, we had

03:43:54.561 --> 03:43:57.687
 a really tight timeline, and we
 had a  client with high demands

03:43:58.090 --> 03:44:00.312
, both in terms of of the  
features and the experience we 

03:44:00.313 --> 03:44:03.346
wanted to deliver.  And  we 
wanted to deliver this beautiful

03:44:03.752 --> 03:44:07.198
 brand experience  across both 
platforms.  IOS and Android.  

03:44:07.199 --> 03:44:09.600
And we didn't  have time to make
 sure every little pixel was 

03:44:09.601 --> 03:44:12.747
perfect on  both platforms.  So 
Flutter really helped us there. 

03:44:12.748 --> 03:44:16.069
  Coding once, seeing the 
designs, but yet still feeling  

03:44:16.070 --> 03:44:18.824
very natural and feeling very 
native.  The other thing  is 

03:44:18.825 --> 03:44:21.322
that it allowed us to move 
really fast in experiment.   Our

03:44:21.654 --> 03:44:23.938
 designers were constantly, you 
know, tweaking things things, 

03:44:23.939 --> 03:44:27.207
the client always had new input 
or once they  would get a build,

03:44:27.273 --> 03:44:29.808
 they want want to change 
something.   So the ability to 

03:44:29.809 --> 03:44:32.947
move fast and use tools like hot
 re reload to modify that design

03:44:33.741 --> 03:44:36.460
 in realtime saved us a ton  of 
time.

03:44:36.668 --> 03:44:41.146
Also, in the long run, this 
Flutter provides an  amazing 

03:44:41.147 --> 03:44:43.623
ability to reduce our 
maintenance cost and also  

03:44:43.624 --> 03:44:46.436
decrease the cost of adding new 
features because every  single 

03:44:46.437 --> 03:44:49.824
time we need to fix a bug or 
change a design or  add a new 

03:44:49.825 --> 03:44:52.820
feature, we just have to do it 
one place.  And  our developers 

03:44:52.821 --> 03:44:56.260
say laying out UI with Flutter, 
 significantly faster than on 

03:44:56.261 --> 03:45:00.485
iOS or Android.  And the  hot re
load, you know, if you are all 

03:45:00.486 --> 03:45:02.933
mobile developers  here or if 
any of you are, waiting for your

03:45:03.010 --> 03:45:06.547
 application  to recompile and 
navigate down to where you need 

03:45:06.548 --> 03:45:09.573
to go,  this is real money.  
This is realtime.  Our clients 

03:45:09.574 --> 03:45:12.624
are  paying for us to redevelop 
these apps.  So our  developers 

03:45:12.625 --> 03:45:16.037
are not waiting for Xcode to re
develop the  application, that's

03:45:16.369 --> 03:45:19.094
 more time we're waiting on 
features.   And also because of 

03:45:19.095 --> 03:45:21.995
things like Flutter fire and 
Flutter Flutter's plugin system 

03:45:21.996 --> 03:45:24.953
and using tools like Firebase is
  and all of the great resources

03:45:25.122 --> 03:45:28.754
 we have at our disposal,  we 
spent less time building 

03:45:28.755 --> 03:45:30.368
plumbing, you know,  technical 
overhead

03:45:30.369 --> 03:45:34.003
  in order to make this app work
 and  more time working on 

03:45:34.004 --> 03:45:36.425
features.
So I'm wondering, has anyone 

03:45:36.426 --> 03:45:39.044
here faced incrediblely 
incredibly-tough deadline in the

03:45:39.253 --> 03:45:41.893
 work that you do?  Have  you 
ever felt pressure from, you 

03:45:41.894 --> 03:45:46.815
know, your bosses or  your 
senior leaders to ship more 

03:45:46.816 --> 03:45:50.658
features faster?  Have  you ever
 had a design team that wants to

03:45:50.856 --> 03:45:54.019
 iterate a  design quicker.  Hey
, I have a new design.  Can I 

03:45:54.020 --> 03:45:57.227
see it  on screen?  Or perhaps 
you have stakeholders in your  

03:45:57.228 --> 03:45:59.836
business that don't want to hear
 it about your cool  

03:45:59.837 --> 03:46:02.059
infrastructure solution or about
 the code you've written  to 

03:46:02.060 --> 03:46:05.009
optimize this, that, or the 
other thing.  They just  want to

03:46:05.012 --> 03:46:07.716
 see new features, you know,?  
What have you done  for me 

03:46:07.717 --> 03:46:10.939
lately?  What kind of value are 
you adding to our  business 

03:46:10.940 --> 03:46:14.167
application?
So Flutter and Firebase for us 

03:46:14.168 --> 03:46:18.104
was a tremendous  toolkit to 
deliver on those needs, you know

03:46:18.105 --> 03:46:23.241
,?  Tough  timeline.  Branded 
design, beautiful experience,  

03:46:23.242 --> 03:46:26.682
complicated features, protected 
operations and logic in  the 

03:46:26.683 --> 03:46:32.027
back-end.  And it's really easy 
to get started.   That's right 

03:46:32.028 --> 03:46:34.545
it's less than a minute to 
create a fire- fire-base project

03:46:34.760 --> 03:46:39.391
 and Flutter is object source.  
You  just get clone our repo and

03:46:39.859 --> 03:46:42.736
 even command Flutter create  to
 Bootstrap your first project.  

03:46:42.737 --> 03:46:45.666
We encourage you to  visit our 
office hours up on the third 

03:46:45.667 --> 03:46:48.603
floor, and we  have instructor-
led training for both Firebase 

03:46:48.604 --> 03:46:53.832
and  Flutter today and tomorrow.
&gt;&gt; And we hope that our talk 

03:46:53.833 --> 03:46:56.675
today inspires you  all.  That 
these aren't just cool 

03:46:56.676 --> 03:47:00.695
technologies.  Real  businesses 
at real scale are using these 

03:47:00.696 --> 03:47:04.114
out there today  to go run 
production code.  So we hope 

03:47:04.115 --> 03:47:06.755
that you can  embrace some of 
the learning you had here today 

03:47:06.756 --> 03:47:09.572
and try  something amazing.  
Thank you very much.

03:47:09.672 --> 03:47:11.672
[Applause]

04:03:48.135 --> 04:03:53.069
&gt;&gt; Hello, Krakow.  Give us a 
wave.  We have got a  lot, a lot

04:03:53.070 --> 04:03:58.309
 of content for you.  So on 
stage we have five  speakers 

04:03:58.310 --> 04:04:01.930
that are going to be talking 
about a variety of  topics.  So 

04:04:01.931 --> 04:04:05.758
I will start with some of the 
things that  may not know about 

04:04:05.759 --> 04:04:12.713
or some of the top tips.  That 
we, we  can have Marc give us an

04:04:12.804 --> 04:04:15.434
 update.  And then we have  
Santiago, who's going to give us

04:04:16.342 --> 04:04:26.105
 an update on ExoPplayer,  and 
then we have Aga, and

04:04:26.513 --> 04:04:31.567
 last but definitely not least, 
 we have Dan who is going to 

04:04:31.568 --> 04:04:33.568
talk about

04:04:35.983 --> 04:04:41.819
 audio.  So get  your hashtag 
ready.  My clock already started

04:04:42.122 --> 04:04:47.679
.  Let's  get going.  What I'm 
going to do is talk about three 

04:04:47.680 --> 04:04:53.019
 things.  And quite often, it's 
not immediately obvious  when 

04:04:53.020 --> 04:04:55.020
you

04:04:56.636 --> 04:05:04.180
 -- the first thing is if your 
app is slow,  please, please 

04:05:04.181 --> 04:05:08.631
tell us.  The only way to watch 
the  connect to the Internet by 

04:05:08.632 --> 04:05:13.662
the phone is through  Bluetooth.
  We have consequently added 

04:05:13.663 --> 04:05:18.997
both Wi-Fi and  cellular to the 
watch.  With 2.0, we have added 

04:05:18.998 --> 04:05:24.140
a new  way for you to connect, 
which is direct HTTP connection.

04:05:24.359 --> 04:05:25.963
   What this
  means is if you have 

04:05:25.964 --> 04:05:28.475
connection code base on  your 
mobile, you can just reuse 

04:05:28.476 --> 04:05:35.817
exactly the same code on  your 
watch.  So that's what's been 

04:05:35.818 --> 04:05:38.848
launched.  The  advantage of 
that is, of course, it can run 

04:05:38.849 --> 04:05:44.289
your app,  even if they're 
paired in the iPhone.  Because 

04:05:44.290 --> 04:05:48.724
it is  no additional component 
required on the phone.  Another 

04:05:48.725 --> 04:05:51.244
 advantage is that users can now
 directly install your  app on 

04:05:51.245 --> 04:05:56.592
the watch itself.  We have play 
store on the  watch so that the 

04:05:56.593 --> 04:06:00.323
user can download whatever they 
want  onto their most personal

04:06:00.433 --> 04:06:05.490
ized device.  And in order for  
you to tell us that your app 

04:06:05.491 --> 04:06:09.592
support this directly, all  you 
need to do is put on this 

04:06:09.593 --> 04:06:12.014
metadata check in your

04:06:15.838 --> 04:06:19.185
  Android ware app.  And after 
of that that, we will put  it on

04:06:19.186 --> 04:06:23.606
 the play store on your watch.  
And it will be both  accessible 

04:06:23.607 --> 04:06:26.119
to those users on a Android 
phone as well as  an iPhone.

04:06:26.524 --> 04:06:30.960
Next, standalone architecture.  
So many of you  have heard about

04:06:31.262 --> 04:06:35.804
 model view controller, so 
that's pretty  much done; right?

04:06:38.307 --> 04:06:42.433
  Your display logic on the 
device.   Done.  Lightning talk.

04:06:42.630 --> 04:06:49.698
  In reality, it's not quite 
that.   So today, the center of 

04:06:49.699 --> 04:06:52.931
gravity for the user is a lot of
  our mobile.  You have heard 

04:06:52.932 --> 04:06:57.557
about mobile first.  And  quite 
often, we forgot about all the 

04:06:57.558 --> 04:07:00.385
other factors that  a user 
already have.  And it doesn't 

04:07:00.386 --> 04:07:03.723
even need to be a  factor.  It 
can just be the same user with 

04:07:03.724 --> 04:07:10.677
another phone phone.  And this 
particular platform is 

04:07:10.678 --> 04:07:14.092
particularly  easy to go into if
 you have a user credential that

04:07:14.093 --> 04:07:17.317
 is  telephone-based.  Meaning 
that when a user log into one  

04:07:17.318 --> 04:07:20.647
device, you lock them out of 
another.  And I see this  

04:07:20.648 --> 04:07:23.390
assumption being built into app 
again and again.  And  when they

04:07:24.697 --> 04:07:28.618
 come to expand their apps, this
 really, really  hit them.  

04:07:28.619 --> 04:07:31.755
Because the user can only log 
into one device  at any one time

04:07:32.056 --> 04:07:37.695
.  So at the very, very minimum,
 I would  strongly encourage you

04:07:37.997 --> 04:07:40.419
 even if you just started  
Bootstrapping

04:07:40.420 --> 04:07:44.942
  or you're working on a project
 over the  weekend, build the 

04:07:44.943 --> 04:07:48.879
assumption that a user will have
 more  than one device.  So 

04:07:48.880 --> 04:07:53.117
allow multiple security tokens 
to  be active at one point.  You

04:07:53.138 --> 04:07:55.834
 don't need to build cloud- 
cloud-based messaging 

04:07:55.835 --> 04:08:00.482
synchronization.  None of that  
ever start.  Maybe when you get 

04:08:00.483 --> 04:08:02.606
your funding, you could  do that
.

04:08:02.897 --> 04:08:08.134
The next thing that we realize 
when we start  building 2.0, 

04:08:08.135 --> 04:08:13.375
which support log in is that a 
lot of the  time the user or the

04:08:13.473 --> 04:08:21.339
 first time the user access your
 app  could be device.  Which 

04:08:21.340 --> 04:08:24.665
means they may not have an  
account to sign in.  So if you 

04:08:24.666 --> 04:08:28.592
assume the user just has  the 
sign in button on the app, you 

04:08:28.593 --> 04:08:31.618
may be missing a  whole chunk of
 users.  So what we would 

04:08:31.619 --> 04:08:36.454
encourage you to  do as you 
build experiences, also put in a

04:08:37.151 --> 04:08:40.071
 register  button so that you 
can enable users that's coming 

04:08:40.072 --> 04:08:45.415
in by  other form factors, be it
 Android wear, Android TV to  

04:08:45.416 --> 04:08:48.340
actually register for your 
service the very first time  

04:08:48.341 --> 04:08:53.179
that they're logging in.
Last but not least, Android wear

04:08:53.272 --> 04:08:57.354
 for China.  So we  are in China
, and it is extremely popular.  

04:08:57.355 --> 04:09:01.586
It is our  second largest market
 around the world behind behind 

04:09:01.587 --> 04:09:06.114
the U.S.   And as you know, many
 of Google services are not  

04:09:06.115 --> 04:09:12.171
available in China.  And so one 
of the thing that you  should do

04:09:12.465 --> 04:09:16.104
 Google Play services on Android
 wear is that  to check it is 

04:09:16.105 --> 04:09:20.838
available.  So there's two ways 
to this  this.  One is when 

04:09:20.839 --> 04:09:22.839
you're connecting

04:09:24.243 --> 04:09:28.690
 to the Google Play  services, 
check if the API is available.

04:09:32.323 --> 04:09:34.430
  And second if  you have, say, 
five of them and three of them 

04:09:34.431 --> 04:09:36.866
connect,  and you still want 
them to work, then you could do 

04:09:36.867 --> 04:09:40.697
this  and say, you know, add API
 available.  And then check  

04:09:40.698 --> 04:09:45.538
that the API is actually 
available for your user.

04:09:45.835 --> 04:09:49.772
And there are three types of 
services that's  available in 

04:09:49.773 --> 04:09:54.010
China in a Google Play services 
package.   The first one is 

04:09:54.011 --> 04:09:59.457
Google Fit.  You can get the 
seven-day  count from that.  

04:09:59.458 --> 04:10:02.083
Second is fused location 
provider.  I  really, really 

04:10:02.084 --> 04:10:05.508
recommend that you use it.  It 
has a lot  of battery 

04:10:05.509 --> 04:10:08.428
optimization built in, as well 
as all the  different 

04:10:08.429 --> 04:10:15.879
combinations of way of getting 
location.  Last  but not least, 

04:10:15.880 --> 04:10:19.607
we have the wear data layer.  So
 a layer,  you would need Google

04:10:19.608 --> 04:10:24.046
 Play services.  And if you want
 to  compile just one against 

04:10:24.047 --> 04:10:30.176
the Google Play services just  
once, then you should.  Compile 

04:10:30.177 --> 04:10:35.028
with the version 10.2.0.   And 
what they've enabled you to do 

04:10:35.029 --> 04:10:38.265
is for your app to  run both in 
China and also outside of China.

04:10:38.464 --> 04:10:42.093
  So with  that, I will hand it 
over to Marc who will be talking

04:10:42.094 --> 04:10:44.094
  about Android TV.  Thank you.
[Applause]

04:10:46.214 --> 04:10:50.949
&gt;&gt; Thank you.  Yeah.  Let's talk
 about Android TV.   You may 

04:10:50.950 --> 04:10:54.385
have already seen the keynote 
where we announced  cool 

04:10:54.386 --> 04:10:58.216
features for Android TV coming 
soon.  I'm going to  talk about 

04:10:58.217 --> 04:11:00.742
two of them, one is the Google 
Assistant on  Android TV and the

04:11:02.552 --> 04:11:09.089
 other is the new home screen 
starting  with Android.  Google 

04:11:09.090 --> 04:11:13.125
Assistant goes Android TV, 
that's  not surprising.  We want

04:11:13.338 --> 04:11:17.083
 to have it on every platform  
available, so TV is the next 

04:11:17.084 --> 04:11:21.914
logical step.  What do you  need
 to do as a developer to make 

04:11:21.915 --> 04:11:24.834
your app integrated  with Google
 Assistant?  There are basically

04:11:25.633 --> 04:11:29.373
 two ways  Google Assistant 
interacts with your app.  First,

04:11:29.669 --> 04:11:35.100
 it  needs to find your app 
provides.  So it

04:11:38.927 --> 04:11:43.071
 is done by using  a search 
adviser.  And second, once the 

04:11:43.072 --> 04:11:46.693
company is found found, it needs
 a way to play, it needs a way 

04:11:46.694 --> 04:11:50.840
to remote  control your app for 
play back.  For this, it uses 

04:11:50.841 --> 04:11:55.272
the  media session API.  Both 
are kind of well-known  

04:11:55.273 --> 04:11:59.323
acknowledges.  We have on 
Android TV since the very  first

04:11:59.620 --> 04:12:02.747
 lounge a few years ago.  What 
you see here is that

04:12:02.748 --> 04:12:08.575
   all universal or global 
search is exactly feature on the

04:12:09.084 --> 04:12:14.120
  former Android TV versions, 
which uses search provider  as 

04:12:14.121 --> 04:12:17.135
well as the assistant does.  
Google Assistant now re reuses 

04:12:17.136 --> 04:12:21.276
the service and provides a new, 
more modern- modern-looking user

04:12:21.679 --> 04:12:27.318
 interface like you see here, 
the  presentation of the results

04:12:27.617 --> 04:12:32.477
.  Now users can choose from  
these movies and start play back

04:12:32.478 --> 04:12:37.197
.  These are well-known  
technologies, there is a lot of 

04:12:37.198 --> 04:12:40.605
documentation available  on 
developer Android.com.  There is

04:12:41.527 --> 04:12:47.150
 a tech guide making  TV apps 
searchable and also a lean back 

04:12:47.151 --> 04:12:53.293
sample code that  you can use 
and adapt for your app.  So now,

04:12:53.898 --> 04:12:58.445
 assistant  now found the 
content or the user found the 

04:12:58.446 --> 04:13:01.162
content he  wants to watch and 
now assistant uses the media 

04:13:01.163 --> 04:13:05.639
session  API to start play back.
  We see here

04:13:09.324 --> 04:13:15.980
 this call back you  and your 
app just need to delegate these 

04:13:15.981 --> 04:13:23.213
calls in this  case, and it's in
 a exoplayer.

04:13:24.524 --> 04:13:29.371
Media session as well is 
documented with the media  

04:13:29.372 --> 04:13:33.089
session and there is also media 
session extension for  exoplayer

04:13:33.404 --> 04:13:38.160
, which provides out of the box 
integration  with the media 

04:13:38.161 --> 04:13:40.161
session.

04:13:44.263 --> 04:13:50.607
  So now let's have a new lack 
at  the home screen of Android. 

04:13:50.608 --> 04:13:55.754
 You see this layout, the  arrow
 with favorite apps.  But then 

04:13:55.755 --> 04:13:59.383
you see channel rows rows.  
Programs which an app wants to 

04:13:59.384 --> 04:14:04.120
advertise to users  for 
recommendation.  Each app can at

04:14:04.121 --> 04:14:08.849
 least place one on  the home 
screen and the application takes

04:14:09.871 --> 04:14:13.683
 the data and  placed this row 
from a database, from a company 

04:14:13.684 --> 04:14:18.726
provider provider.  So your app 
needs to insert data into 

04:14:18.727 --> 04:14:21.867
exactly  this content provider. 
 Let's have a look how this 

04:14:21.868 --> 04:14:27.803
looks  in code.  We have here a 
sample, which adds to the  

04:14:27.804 --> 04:14:30.839
content provider.  At the very 
start, we just create a  builder

04:14:31.131 --> 04:14:35.777
, a builder instance in this 
case a channel  builder instance

04:14:36.368 --> 04:14:41.009
, which then populates with what
 we want  to use for our channel

04:14:41.606 --> 04:14:45.463
.
In the next step, we use now the

04:14:46.651 --> 04:14:50.881
 build content  values and 
insert these values into our 

04:14:50.882 --> 04:14:55.713
content provider  by the TV 
contract we are using.  And the 

04:14:55.714 --> 04:15:00.150
next step now  we want to add a 
logo to our channel.  So the 

04:15:00.151 --> 04:15:07.505
user can  easily recognize to 
which app a channel belongs and 

04:15:07.506 --> 04:15:13.136
uses  the channel logo method 
here, the channel ID, and the  

04:15:13.137 --> 04:15:16.571
logo.
And now finally, we want to make

04:15:16.885 --> 04:15:20.605
 this channel  visible on the 
home screen for this requested 

04:15:20.606 --> 04:15:24.245
to make it  browseable, with the
 request channel browseable

04:15:27.553 --> 04:15:31.698
 method.
Now we have such a channel 

04:15:31.699 --> 04:15:35.412
visible on the home  screen and 
of course we want to add 

04:15:35.413 --> 04:15:38.945
programs.  This  works in the 
very same way, only in a very 

04:15:38.946 --> 04:15:41.963
similar way.   Again, it creates
 a builder instance and this 

04:15:41.964 --> 04:15:47.600
time it's  a preview program 
builder instance and repopulate 

04:15:47.601 --> 04:15:51.336
the  data in this builder.  Most
 importantly, the channel ID,  

04:15:51.337 --> 04:15:55.255
of course, with which we link 
our program to a given  channel 

04:15:55.256 --> 04:16:01.295
we already create.  Once we add 
a type to the  description, we 

04:16:01.296 --> 04:16:05.827
can now take the content values 
again  built by our builder, and

04:16:06.137 --> 04:16:11.465
 insert it into the content  
provider of the TV contract.

04:16:14.493 --> 04:16:21.435
This API is already documented. 
 More detail on

04:16:24.570 --> 04:16:27.496
  developer.Android.comAndroid
.com, it provides you more 

04:16:27.497 --> 04:16:31.326
details with  how you can 
manipulate your channel and 

04:16:31.327 --> 04:16:36.060
program data in  the database.  
With this last point to our 

04:16:36.061 --> 04:16:40.398
sandbox where  you can play 
around with the new launch 

04:16:40.399 --> 04:16:44.131
screen and also  the Android TV 
office hours, we're happy to 

04:16:44.132 --> 04:16:47.358
answer your  questions about 
Android TV.  With this, I give 

04:16:47.359 --> 04:16:49.982
it over  to Santiago.  Thank you
 very much.

04:16:50.028 --> 04:16:52.028
[Applause]

04:16:55.624 --> 04:16:59.363
&gt;&gt; Hello.  Let's talk about 
ExoPlayer.  ExoPlayer  is an 

04:16:59.364 --> 04:17:01.696
application level media library 
for Android.  It's  an 

04:17:01.697 --> 04:17:07.526
alternative to Android's 
platform media player, and  it 

04:17:07.527 --> 04:17:11.072
has four main goals.  The first 
goal is to reduce the  effects 

04:17:11.073 --> 04:17:16.199
of fragmentation.  It has been 
one of the most  affected areas 

04:17:16.200 --> 04:17:21.588
by fragmentation.  And ExoPlayer
 moves a  majority of the media 

04:17:21.589 --> 04:17:25.509
player implementation to the  
application layer, so it's 

04:17:25.510 --> 04:17:29.154
possible to update through  
regular application updates, 

04:17:29.155 --> 04:17:35.697
hence reducing the effects  of 
fragmentation.  Most works 

04:17:35.698 --> 04:17:39.919
jellybean, onwards.  That  
covers a vast majority of 

04:17:39.920 --> 04:17:43.849
devices.
Our second goal and the least is

04:17:43.850 --> 04:17:48.788
 to provide  advanced features. 
 So you already possibly know 

04:17:48.789 --> 04:17:53.617
that  ExoPlayer supports some 
features, not currently  

04:17:53.618 --> 04:17:56.950
supported by the API.  This 
includes dash, streaming,  

04:17:56.951 --> 04:18:00.583
caching.  There are others.  But
 we are constantly  working to 

04:18:00.584 --> 04:18:06.332
add new features.  So our latest
 include a  set of tools for 

04:18:06.333 --> 04:18:12.181
downloading almost any kind of 
media.   There's also dynamic 

04:18:12.182 --> 04:18:16.717
play lists, so you can create  
dynamic play lists, modify them 

04:18:16.718 --> 04:18:24.168
on the fly, the  functionality 
is also built in the player.  So

04:18:24.573 --> 04:18:26.573
 if we  know with enough 
anticipation what media's coming

04:18:26.990 --> 04:18:33.839
, we  can shorten by a lot the 
gap between items in the play  

04:18:33.840 --> 04:18:39.793
list.  And even though very cool
 stuff with this, like,  for 

04:18:39.794 --> 04:18:44.934
example, brings me to my next 
picture, which is --  there's 

04:18:44.935 --> 04:18:50.467
this new component called audio 
processors,  which includes 

04:18:50.468 --> 04:18:53.801
features like the feedback 
adjustment all  the way back 

04:18:53.802 --> 04:18:59.440
from jellybean onwards and 
virtual reality.   And finally, 

04:18:59.441 --> 04:19:04.380
a slightly more technical level,
 there is  support for the full 

04:19:04.381 --> 04:19:09.726
now.  So
  we have had support for a  

04:19:09.727 --> 04:19:14.556
long time now.  And now we have 
it for the remaining  skin types

04:19:15.167 --> 04:19:17.220
.  Most interestingly

04:19:20.292 --> 04:19:25.142
 include this skin type  for HLS
.  So this is interesting for 

04:19:25.143 --> 04:19:32.806
content providers.   This is in 
by no means a list.

04:19:34.103 --> 04:19:36.927
So there are tons of use cases 
for ExoPlayer.  We  know, in 

04:19:36.928 --> 04:19:40.057
fact, no size fits all, so the 
ability to  customize is one of 

04:19:40.058 --> 04:19:42.479
the core principles in ExoPlayer
.

04:19:42.777 --> 04:19:48.522
So this is our third goal to 
allow customization.   So, say, 

04:19:48.523 --> 04:19:51.239
for example, if you have amazing
 content that  you want to 

04:19:51.240 --> 04:19:56.787
stream to devices, and you come 
out with a  custom ERM screen, 

04:19:56.788 --> 04:19:59.415
so you create a component, and 
you  check the player.  And then

04:19:59.708 --> 04:20:02.650
 after shipping and having  some
 metrics, you realize you also 

04:20:02.651 --> 04:20:07.974
want to tweak away,  you mess 
your band with because the 

04:20:07.975 --> 04:20:12.301
network conditions  conditions 
-- and, by the way, it's also 

04:20:12.302 --> 04:20:17.651
good to custom customize the 
mechanisms.  So you create 

04:20:17.652 --> 04:20:22.589
components for  that, you check 
on ExoPlayer, new metrics you 

04:20:22.590 --> 04:20:25.109
realize  that you would also 
customize -- you would also like

04:20:25.307 --> 04:20:30.448
 to  customize a way for the 
media.  So you also -- all of  

04:20:30.449 --> 04:20:34.478
these things you can inject into
 ExoPlayer.  There are  tons of 

04:20:34.479 --> 04:20:39.813
hot spots for injecting custom 
components in  ExoPlayer.  Very 

04:20:39.814 --> 04:20:42.759
different for levels.  And now 
I'm  going to speak about our 

04:20:42.760 --> 04:20:45.974
fourth bowl, which is enable  
integration with enabled 

04:20:45.975 --> 04:20:51.004
libraries.  Extensions are  
models with external 

04:20:51.005 --> 04:20:55.431
dependencies.  For example, the 
IMA  extension.

04:20:55.432 --> 04:21:00.478
 For media distributors who want
 to monetize  their media, this 

04:21:00.479 --> 04:21:04.602
extension, which is a wrapper 
around  the Google interactive 

04:21:04.603 --> 04:21:10.459
media SDK makes it extremely 
easy  to play ads on your 

04:21:10.460 --> 04:21:13.887
content.  And as a play list, 
it's  integrated into the player

04:21:14.295 --> 04:21:18.931
, so you can reduce and almost  
eliminate the way it cost by 

04:21:18.932 --> 04:21:25.677
buffering mid-rows during  media
 play back.

04:21:25.807 --> 04:21:33.748
There's Alice the Cast extension
, which is quite  now.  Users 

04:21:33.749 --> 04:21:37.478
effortlessly cast their content 
into cast castable devices, and 

04:21:37.479 --> 04:21:40.795
you can use your custom UI  
components, if any, you are 

04:21:40.796 --> 04:21:44.429
using to control ExoPlayer  to 
control play back on cast-

04:21:45.428 --> 04:21:49.165
compatible devices.   Chromecast
 and TV is not all we have in 

04:21:49.166 --> 04:21:51.791
mind.  There's  also the media 
extension, which allows 

04:21:51.792 --> 04:21:57.839
ExoPlayer to  publish media 
session, therefore, you can 

04:21:57.840 --> 04:22:00.654
control that  play back session 
from other apps in other devices

04:22:01.078 --> 04:22:07.634
.  And  the images that's being 
used on mobile device and  

04:22:07.635 --> 04:22:11.434
Android out.  So this is very 
interesting.

04:22:11.565 --> 04:22:16.081
So ExoPlayer can also be used, 
maybe you know, in  virtual 

04:22:16.082 --> 04:22:23.430
reality environments.  But the G
VR extension  also allows for 

04:22:23.431 --> 04:22:27.778
audio player.  Also, thanks to 
audio  process that I mentioned 

04:22:27.779 --> 04:22:31.907
before.  There are many other  
extensions.  Due to time 

04:22:31.908 --> 04:22:34.632
constraints, I'm not going to  
delve into them.  But I just 

04:22:34.633 --> 04:22:38.155
want to mention that most  of 
them or many of them can be used

04:22:38.850 --> 04:22:42.677
 to bundle your own  encoders.  
So you can make sure there's 

04:22:42.678 --> 04:22:48.121
specific code  you're looking 
for on all the devices.

04:22:48.725 --> 04:22:58.705
So that's -- for me, at least 
check the medium box box,

04:22:58.892 --> 04:23:02.826
 I hope to see you tomorrow at 
the office hours.   Thank you 

04:23:02.827 --> 04:23:04.827
very much.
[Applause]

04:23:13.998 --> 04:23:17.430
&gt;&gt; Thank you.  Today, I want to 
spend a little  time talking 

04:23:17.431 --> 04:23:21.865
about one of the APIs that we 
run with  Android Wear, and it 

04:23:21.866 --> 04:23:29.406
has to do with round screens.  
So  this is our new launcher 

04:23:29.407 --> 04:23:33.536
that I started working on about 
 a year and a half ago.  And 

04:23:33.537 --> 04:23:36.661
what we wanted to do with  this 
launcher is we wanted it to be 

04:23:36.662 --> 04:23:40.092
fast, we wanted it  to be used. 
 But most importantly, we wanted

04:23:40.405 --> 04:23:43.619
 it to fit  in with a curved 
screen that all the new watches 

04:23:43.620 --> 04:23:49.668
have.   So round watches are the
 most popular watches at the  

04:23:49.669 --> 04:23:54.002
moment.  Users love them, and 
they are much, much, much  more 

04:23:54.003 --> 04:23:56.827
popular than the square ones, so
 we wanted to  adjust our design

04:23:57.133 --> 04:24:00.658
 to that new trend and make it 
visually  more appealing and 

04:24:00.659 --> 04:24:05.101
more fitting with the round UI.
So this is how we wanted it to

04:24:10.346 --> 04:24:16.185
 look.  We needed to  figure out
 how to implement it.  So this 

04:24:16.186 --> 04:24:20.414
is what I got  from my designers
.  Here on the right-hand side, 

04:24:20.415 --> 04:24:23.338
which  generally when you first 
look at it, looks fabulous.   

04:24:23.339 --> 04:24:28.292
However, how it really feels 
like is something like this 

04:24:28.293 --> 04:24:32.510
this; right?  And that is 
because a lot of people forget  

04:24:32.511 --> 04:24:37.857
that the launcher is static.  
I'm not quite sure they  forget 

04:24:37.858 --> 04:24:40.781
but the launcher is not static. 
 You can scroll  it up and down.

04:24:40.978 --> 04:24:44.307
  And once you scroll it up and 
down, you  need to be able to 

04:24:44.308 --> 04:24:49.538
animate those elements into the 
 launcher alongside the curve.  

04:24:49.539 --> 04:24:53.475
And you don't only want  to 
animate them just like the yarn,

04:24:53.884 --> 04:24:56.297
 you want to scale  them.  So 
you can see the ones here at the

04:24:56.298 --> 04:25:00.932
 top are  slightly smaller than 
the ones in the center, which 

04:25:00.933 --> 04:25:05.701
are  the ones we want to focus 
on.

04:25:05.765 --> 04:25:11.812
So for regular lists, a lot of 
the work done by  Android 

04:25:11.813 --> 04:25:17.056
framework.  But nobody exactly 
thought about  round screens.  

04:25:17.057 --> 04:25:23.200
So this was a new challenge for 
us.  So  when I started looking 

04:25:23.201 --> 04:25:29.635
at the code, you can see on this
  left-hand side here how how 

04:25:29.636 --> 04:25:33.372
the straight works.  It's kind  
of straight.

04:25:33.397 --> 04:25:36.803
[Laughter]
And when you scroll it, every 

04:25:36.804 --> 04:25:40.544
single element in  the list 
moves by the same amount of 

04:25:40.545 --> 04:25:45.575
pixels at the same  time, which 
creates an illusion of scrolling

04:25:45.761 --> 04:25:50.002
.  It really  is super simple of
 function.  Now, this is not the

04:25:50.307 --> 04:25:53.841
 case,  obviously, with the 
curved list that we have here.  

04:25:53.842 --> 04:26:00.681
So  you can see that not only do
 we want to keep on the Yics Y  

04:26:00.682 --> 04:26:06.728
Y-axis.  We also for the curve 
want them with the X-axis 

04:26:06.729 --> 04:26:10.672
X-axis.  I'm okay with math, so 
I figured a function for  this. 

04:26:10.673 --> 04:26:17.211
 You can translate X to Y by 
using a very simple  circle base

04:26:17.413 --> 04:26:22.955
 function.  So I went back to my
 design team,  I built a 

04:26:22.956 --> 04:26:28.492
prototype and said, hey, guys, 
it's working  fine.  It's well.

04:26:29.104 --> 04:26:31.741
And I said this is really not 
good.  This is  terrible.  We 

04:26:31.742 --> 04:26:34.953
can't launch this.  There's no 
way.  It's  so bad.  It's so 

04:26:34.954 --> 04:26:39.592
horrible.  No way.  What we 
really want  is this.  We want 

04:26:39.593 --> 04:26:43.872
the circles to be equidistant 
from  each other, how you see 

04:26:43.873 --> 04:26:45.873
here.  Which

04:26:47.807 --> 04:26:51.323
 means you can't  linearly have 
the Y position exactly like you 

04:26:51.324 --> 04:26:58.272
would have  in the stateless.  
You not only need to translate 

04:26:58.273 --> 04:27:01.419
in the  X directions, you also 
need to do it in the Y 

04:27:01.420 --> 04:27:04.740
directions directions.  You can 
see there's a slight slope of 

04:27:04.741 --> 04:27:11.795
the  lines here and here.  Also,
 the slope goes up here but  on 

04:27:11.796 --> 04:27:15.327
the flip side here, on the 
bottom, it goes down.  So  it 

04:27:15.328 --> 04:27:21.389
doesn't make it easier at all.
So instead of changing just the 

04:27:21.390 --> 04:27:26.721
value of X, we  needed to change
 both the values of X and Y.  So

04:27:26.723 --> 04:27:30.749
 this is  a problem in Android 
because once you've changed the 

04:27:30.750 --> 04:27:38.404
X  or Y values, that triggers a 
new layout path each time.   So 

04:27:38.405 --> 04:27:42.444
if you're changing Y in a 
vertically-scrolling list,  you 

04:27:42.445 --> 04:27:46.276
will trigger a layout path on 
and on and on and on  because 

04:27:46.277 --> 04:27:51.708
the old values -- sorry, the new
 values treat it  as an old 

04:27:51.709 --> 04:28:00.368
value.  And this is obviously 
not what we  wanted or.  So 

04:28:00.369 --> 04:28:05.105
instead of changing the value of
 Y, we  decided to translate the

04:28:05.414 --> 04:28:09.938
 view by just a little bit.  So 
 that is a little difference 

04:28:09.939 --> 04:28:12.671
translation did not trigger  a 
layout path.

04:28:12.982 --> 04:28:18.809
So this was a simple solution, 
and to implement in  the launch

04:28:19.108 --> 04:28:23.146
er.  But as you can see, this is
 probably not  a unique problem.

04:28:23.454 --> 04:28:27.569
  So we cover that, actually, it
 works  for us for the curve.  

04:28:27.570 --> 04:28:32.299
But it could work for any other 
 path.  So that's why on the top

04:28:33.013 --> 04:28:37.745
 of the solution for the  launch
er, my team built an an API that

04:28:37.939 --> 04:28:45.001
 enables you to use  any chosen 
path, however funky it may be.  

04:28:45.002 --> 04:28:49.247
If you want  to implement it, 
you can.  I don't know why, but 

04:28:49.248 --> 04:28:54.883
you can can.  The only caveat is
 we will not give you the math. 

04:28:54.884 --> 04:28:59.620
  I've had enough of math.  So 
we will give you a  container, a

04:29:00.927 --> 04:29:06.160
 wearable recycleer view, but 
you need to  supply us with the 

04:29:06.161 --> 04:29:11.206
path.  And then how the path is 
used  is a little bit like this:

04:29:11.405 --> 04:29:15.027
So this will go live when it 
drops to open source,  this is 

04:29:15.028 --> 04:29:22.671
the curve that we use for the 
launcher.  I won't  bore you 

04:29:22.672 --> 04:29:26.020
with details, basically some 
extend there.   This is the kind

04:29:26.021 --> 04:29:28.021
 of map

04:29:30.944 --> 04:29:33.962
 that you might want to -- and  
then when you have the map for 

04:29:33.963 --> 04:29:36.781
the path, this is how you  would
 actually use it in code.  This 

04:29:36.782 --> 04:29:39.624
line here is the  crucial one.  
Where you just get the tangent 

04:29:39.625 --> 04:29:42.950
line for  the path you have and 
then apply the position to the  

04:29:42.951 --> 04:29:49.197
children in the view.
So here, again, this is the 

04:29:49.198 --> 04:29:53.535
general architecture  of the API
, this is all provided in the 

04:29:53.536 --> 04:29:57.384
where UI support  library, which
 is part of Android support 

04:29:57.385 --> 04:30:01.407
library, which  means I get open
 source, and this is the chosen 

04:30:01.408 --> 04:30:05.466
path  that you need to provide.
Was it specifically not provided

04:30:05.667 --> 04:30:08.387
 as the scaling,  but that's 
pretty trivial.  We didn't 

04:30:08.388 --> 04:30:12.318
provide it as part  of the API 
because you might want to put in

04:30:12.513 --> 04:30:16.545
  differentiate children into 
the wearable recycleer view.

04:30:16.842 --> 04:30:21.284
So to learn more about this API,
 you can search  for wearable 

04:30:21.285 --> 04:30:24.623
recycleer view, the call back 
and generally- generally-curved 

04:30:24.624 --> 04:30:29.853
layout Android Wear and the 
developer.   You can just Google

04:30:30.154 --> 04:30:33.494
 it.  There's plenty of stuff on
  slack overflow.  So that's all

04:30:33.591 --> 04:30:36.717
 for me.  I hope this is  going 
to be helpful.  And with that, 

04:30:36.718 --> 04:30:38.718
I'll hand it over.
[Applause]

04:30:41.870 --> 04:30:44.386
&gt;&gt; All right.  Thank you.  That 
was pretty awesome awesome.  All

04:30:44.387 --> 04:30:48.818
 right.  Let's jump right into 
audio  because, first of all, 

04:30:48.819 --> 04:30:53.656
we're short on time.  So, first 
 of all, why a new API?  We have

04:30:54.357 --> 04:30:57.280
 Java API.  We listened  to a 
lot of developer feedback and 

04:30:57.281 --> 04:31:00.910
you told us that  audio 
processing is really hard, and 

04:31:00.911 --> 04:31:03.529
we want to make it  easier to 
use.  All of these original APIs

04:31:04.333 --> 04:31:07.165
 go through  the original audio 
framework.  But since making 

04:31:07.166 --> 04:31:11.180
huge  changes there could 
potentially break lots of APIs, 

04:31:11.181 --> 04:31:14.616
 audio has a new server, so we 
could introduce a pretty  

04:31:14.617 --> 04:31:16.748
radical thing that could get us 
performance enhancements 

04:31:16.749 --> 04:31:18.764
enhancements.  So it uses the 
concept of streams.  And  in 

04:31:18.765 --> 04:31:21.479
this case, we can see a stream 
flowing from the mic  all the 

04:31:21.480 --> 04:31:25.012
way back to the app and all the 
way back to the  headphones.  

04:31:25.013 --> 04:31:27.939
And these streams are straight 
forward to  create using the 

04:31:27.940 --> 04:31:32.381
build your design pattern, which
 allows  you to create a builder

04:31:32.588 --> 04:31:35.000
 with your customization to  
create multiple screens.  And 

04:31:35.001 --> 04:31:37.216
this is kind of cool.  You  can 
set up

04:31:37.217 --> 04:31:40.243
  the builder as a rubber stamp 
to create audio  streams.  So in

04:31:40.244 --> 04:31:47.398
 this code, we have an aaudio 
stream  builder, and it gives 

04:31:47.399 --> 04:31:51.121
you the stereo output stream.  
And  here's how you would 

04:31:51.122 --> 04:31:53.451
request certain directions.  You
  get input and output stream 

04:31:53.452 --> 04:31:56.477
from this.  And once you set  up
 the stream, you can call the 

04:31:56.478 --> 04:31:59.529
stream on the builder.   And if 
you didn't set things like the 

04:31:59.530 --> 04:32:01.748
sample rate format format, 
you'll need to query them.  And 

04:32:01.749 --> 04:32:06.618
finally, you get  the frame 
reverseed the optimal read, 

04:32:06.619 --> 04:32:08.935
write size.
And this is kind of how this all

04:32:09.225 --> 04:32:12.662
 works.  In aaudio aaudio, a 
buffer refers to these arrays of

04:32:12.969 --> 04:32:18.307
 bursts.  And  the data is 
written in these bursts, which 

04:32:18.308 --> 04:32:20.730
actually turn  audio into 
something your headphones can 

04:32:20.731 --> 04:32:28.305
hear.  Yeah,  and in this 
diagram, this again rates 

04:32:28.306 --> 04:32:34.250
generates two bursts of data.   
And you can start and pause and 

04:32:34.251 --> 04:32:38.172
flush your screen.  We  do have 
functions that you can 

04:32:38.173 --> 04:32:41.313
synchronize these.  Again Again,
 it's a simple API.  We've got 

04:32:41.314 --> 04:32:44.743
six minutes.  So  how do we get 
data in and out of the streams? 

04:32:44.744 --> 04:32:53.213
 Okay.  So  for apps that don't 
need super low Latins latentcy. 

04:32:53.214 --> 04:32:55.825
 It returns  either the number 
of frames or the error.  And 

04:32:55.826 --> 04:33:00.055
this  blocking time can time out
, so we may only get part of  

04:33:00.056 --> 04:33:03.990
the frame written.  So we need 
to be sure to handle that  case.

04:33:03.991 --> 04:33:07.121
You need to be running on a 
special thread to do  your audio

04:33:07.220 --> 04:33:11.961
 processing one.  Maybe one that
 scheduled.   So you write this 

04:33:11.962 --> 04:33:15.687
call back function.  And aaudio 
will  patch you the stream 

04:33:15.688 --> 04:33:20.120
parameter.  The audio data buff 
and  the number of frames, and 

04:33:20.121 --> 04:33:24.062
then you can render your audio  
into the priority thread.  So 

04:33:24.063 --> 04:33:28.083
instead of call back  actually 
in the building.

04:33:28.499 --> 04:33:32.114
All right.  Some people are what
 I really want to  do is do 

04:33:32.115 --> 04:33:34.750
audio processing, that means I 
need to take  audio and turn 

04:33:34.751 --> 04:33:39.384
into something.  So how do I do 
that?   Take two or more input 

04:33:39.385 --> 04:33:44.426
streams and put it in a output? 
  So what we do in this simple 

04:33:44.427 --> 04:33:47.348
example, we're just passing  
data through the input and the 

04:33:47.349 --> 04:33:51.276
output, and we read the  input 
stream to a nonblocking read.  

04:33:51.277 --> 04:33:54.309
And that goes right  into the 
output buffer.  Notice, it may 

04:33:54.310 --> 04:33:57.830
take a couple of  calls for 
these two screens to synchronize

04:33:58.945 --> 04:34:04.292
.  Ta-da.   Finally, let's talk 
about dynamic latentcy tuning.  

04:34:04.293 --> 04:34:07.228
And  this is important because 
looking back at our previous  

04:34:07.229 --> 04:34:10.153
diagram, if we're glitching 
because we're getting  

04:34:10.154 --> 04:34:12.362
preemptive all the time, we 
might want to add another  burst

04:34:12.567 --> 04:34:17.306
 to our renderer.  So this is 
the way we do  simplified.  We 

04:34:17.307 --> 04:34:22.946
can detect overruns or underruns
 by  having exrun.  And if it 

04:34:22.947 --> 04:34:26.984
has changed since the last time 
time, you've had a glitch.  So 

04:34:26.985 --> 04:34:30.415
you can add another burst  to 
your buffer size.  Pretty 

04:34:30.416 --> 04:34:33.164
straight forward.
Once again, here is basic aaudio

04:34:33.339 --> 04:34:38.209
 using blocking  right.  We've 
got extreme stream builder, 

04:34:38.210 --> 04:34:40.515
pretty straight  forward, we 
press start, and then while 

04:34:40.516 --> 04:34:44.037
we're processing processing, we 
just write frames.  Like, kind 

04:34:44.038 --> 04:34:47.768
of how  audio should work; right
?.  Okay.  And then we close it,

04:34:47.967 --> 04:34:52.694
  and we're done because, you 
know, we're always done.   And 

04:34:52.695 --> 04:34:54.446
this is a API, so we close 
things.

04:34:54.447 --> 04:34:57.953
And here's a partial equivalent 
of what we would  have to do in 

04:34:57.954 --> 04:35:03.311
open SLAS.  So, again, the goal 
is not  make audio higher 

04:35:03.312 --> 04:35:05.711
performance, but it also makes 
it  easier to write these 

04:35:05.712 --> 04:35:08.747
programs entirely.  So now 
you're  saying, like, but wait. 

04:35:08.748 --> 04:35:13.704
 This is only an Android O.  How
  am I going to use this?  The 

04:35:13.705 --> 04:35:18.245
good news for that is we're  
actually working on a C++ 

04:35:18.246 --> 04:35:23.074
wrapper.  And this wrapper is  
not only going to target aaudio,

04:35:23.274 --> 04:35:26.495
 but it's going to work  on 
older Android platforms as well.

04:35:26.813 --> 04:35:32.841
  So you'll be able  to use this
 simplified ways with C++ on 

04:35:32.842 --> 04:35:35.890
both older and  newer versions 
of Android.  So pretty cool.  

04:35:35.891 --> 04:35:40.004
It's going  to have similar 
concepts, it's going to use DL 

04:35:40.005 --> 04:35:45.562
as I am sim ,or  it's going to 
have a back-end to talk to SLES.

04:35:45.761 --> 04:35:49.388
  Cool.   That's it.  We covered
 it in four minutes.  It's that 

04:35:49.389 --> 04:35:52.522
 easy.
And it really is.  Like, 

04:35:52.523 --> 04:35:55.963
honestly, you know, the  audio 
developers who have worked with 

04:35:55.964 --> 04:35:59.906
have used this  already have 
come back and said thank you.  

04:35:59.907 --> 04:36:06.060
And how many  people have 
actually tried using their audio

04:36:06.358 --> 04:36:09.881
 app?  See?   That's how popular
 it is.  Anyway, on behalf of 

04:36:09.882 --> 04:36:12.126
myself  and all of the 
presenters who come to the stage

04:36:12.408 --> 04:36:15.434
 to do  lightning talks, thank 
you, all, for coming.  And, you 

04:36:15.435 --> 04:36:17.971
 know, we're going to have 
office hours, so today, you  can

04:36:18.465 --> 04:36:22.099
 come to Android Wear office 
hours.  We're going to  have 

04:36:22.100 --> 04:36:24.922
Android auto office hours 
tomorrow and ExoPlayer.   So if 

04:36:24.923 --> 04:36:27.949
you have any burning questions, 
please come back  and talk to us

04:36:27.950 --> 04:36:31.375
.  You can also, if you see me 
out there,  I can try to answer 

04:36:31.376 --> 04:36:35.717
questions on Android -- on a
audio  would also be cool.  And 

04:36:35.718 --> 04:36:37.560
that's it.  Thank you, on  
behalf of the panel.

04:36:37.561 --> 04:36:39.561
[Applause]

04:48:32.791 --> 04:48:35.824
&gt;&gt; All right.  We ready?  Hello,
 GDD, Europe.   Thank you for 

04:48:35.825 --> 04:48:39.357
coming out and coming in for my 
talk.  I'm  Gus Class, and I'm a

04:48:39.668 --> 04:48:43.604
 developer programs engineer on 
the  Google Cloud IoT core 

04:48:43.605 --> 04:48:47.042
product.  And today I'm going to
  be talking about Google Cloud 

04:48:47.043 --> 04:48:50.984
IoT core.  This talk is a  
technical DVD dive.  This means 

04:48:50.985 --> 04:48:53.101
I'm going to be starting  at the
 high level going over the 

04:48:53.102 --> 04:48:57.080
architectural of the  product 
and then covering the product 

04:48:57.081 --> 04:49:00.070
features and then  finishing low
 level by just giving a quick 

04:49:00.071 --> 04:49:03.601
demo with the  product.  I want 
to warn you before I get through

04:49:03.607 --> 04:49:06.733
 this  is that I'm going to be 
covering a whole lot of things. 

04:49:06.734 --> 04:49:09.964
  And as an unfortunate side 
effect, the slides came out a  

04:49:09.965 --> 04:49:12.678
little bit denser than I would 
have liked.  So you may  be 

04:49:12.679 --> 04:49:14.897
tempted to read all the material
 on the slides and  all the text

04:49:15.103 --> 04:49:18.321
 in the diagrams, but please 
resist.  It's a  trap.

04:49:18.526 --> 04:49:21.036
So I'm going to do my best to 
make the slides  available 

04:49:21.037 --> 04:49:24.374
shortly after the talk.  But you
 can take it  all in and take 

04:49:24.375 --> 04:49:29.121
your time and enjoy the slides 
and look  at it with more detail

04:49:29.324 --> 04:49:32.145
.  The whole thing's going to be
  streamed as well, and it's 

04:49:32.146 --> 04:49:35.871
recorded, so don't feel like  
you need to take pictures.  If 

04:49:35.872 --> 04:49:39.618
something really kind of  jumps 
out at you as important, write 

04:49:39.619 --> 04:49:43.945
that down and use  it as a take 
away.  Just kind of let it go 

04:49:43.946 --> 04:49:47.177
along as it  goes and understand
 that we're covering a lot of  

04:49:47.178 --> 04:49:50.100
material.
So let's start with some 

04:49:50.101 --> 04:49:57.164
foundational concepts.   If you 
saw a talk before on IoT, the 

04:49:57.165 --> 04:49:59.698
speaker probably  started with 
something to the effect of in X 

04:49:59.699 --> 04:50:02.215
years,  you're going to have 
more devices connected to the  

04:50:02.216 --> 04:50:07.667
Internet than people.  The 
reality is that this actually 

04:50:07.668 --> 04:50:12.828
actually -- this event horizon 
has long since passed us.   And 

04:50:12.829 --> 04:50:15.142
we're starting to see instead a 
trend where there  are going to 

04:50:15.143 --> 04:50:18.164
be more connected devices than 
there are  devices that are not 

04:50:18.165 --> 04:50:23.309
connected.  So what is IoT 
really?   IoT is taking devices 

04:50:23.310 --> 04:50:26.261
that were not traditionally  
connected to the Internet and 

04:50:26.262 --> 04:50:29.379
then adding Internet  connective
ity to it.  And when you talk 

04:50:29.380 --> 04:50:32.501
about IoT, you  have to kind of 
scope it because there's a lot 

04:50:32.502 --> 04:50:36.539
of  different -- there's a lot 
of different types of IoT.   And

04:50:36.545 --> 04:50:38.771
 I like to think of it in these 
three categories.   You have 

04:50:38.772 --> 04:50:41.092
home brew and enthusiasts.  So 
you have people  that are taking

04:50:41.496 --> 04:50:47.446
 devices like args between 
Arduinos, and then giving  them 

04:50:47.447 --> 04:50:49.179
Internet capabilities, and then 
it gives you  capabilities

04:50:49.180 --> 04:50:52.199
  that you didn't have before.  
So, for  example, I can think of

04:50:52.206 --> 04:50:55.542
 it as I have a smart flower  
watering system.  And before I 

04:50:55.543 --> 04:50:59.057
was using data logging,  and now
 I have Internet connectiveity 

04:50:59.058 --> 04:51:01.589
to do that data  logging.  And 
Google provides a lot of this 

04:51:01.590 --> 04:51:07.345
stuff to  lobbyists in the AYI 
product.  And then the other 

04:51:07.346 --> 04:51:10.178
area  we have is consumer and 
devices.  And so this is things 

04:51:10.179 --> 04:51:13.506
 like you've got a fire alarm or
 a smoke detector, and  then you

04:51:13.712 --> 04:51:16.838
 inner connect it.  You Internet
 connect it so  that it can talk

04:51:17.352 --> 04:51:21.283
 to other is devices and do 
intelligent  things.  So

04:51:24.916 --> 04:51:26.224
 Google offers a lot of these 
things.

04:51:26.225 --> 04:51:28.948
And the other thing I want to 
talk about is  industrial and 

04:51:28.949 --> 04:51:31.790
commercial domain.  And this is 
where you  have a factory where 

04:51:31.791 --> 04:51:33.598
you have a traditionally 
mechanical  assembly line and 

04:51:33.599 --> 04:51:36.936
then now we've taken that 
factory,  we've added a lot of 

04:51:36.937 --> 04:51:40.477
sensors to it and added a lot of
  capabilities that we know 

04:51:40.478 --> 04:51:44.526
what's going on in that  factory
.  And now we're taking that 

04:51:44.527 --> 04:51:47.248
data, and then we're  putting it
 into the cloud so that we can 

04:51:47.249 --> 04:51:50.190
do intelligent  things with that
.  And so that last domain that 

04:51:50.191 --> 04:51:53.012
I was --  that I mentioned, 
industrial and commercial is 

04:51:53.013 --> 04:51:56.948
really  where cloud IoT core 
shines.  And for the consumer  

04:51:56.949 --> 04:52:02.117
device features, you should 
really check out Android.   So 

04:52:02.118 --> 04:52:06.656
why should I care about cloud 
IoT core?  I like to  think of 

04:52:06.657 --> 04:52:10.808
it like this.  If you're like me
, then you did  some home grew 

04:52:10.809 --> 04:52:14.029
enthusiasts scale IoT.  You were
 building  the device yourself. 

04:52:14.030 --> 04:52:16.571
 So you weren't really worried  
about things like he will gating

04:52:16.663 --> 04:52:19.613
 your devices, securing  it 
against its backers because you 

04:52:19.614 --> 04:52:21.323
have a security  through 
obscurity,

04:52:21.324 --> 04:52:23.640
  and you have an audience of 
one.  You  know how to manage 

04:52:23.641 --> 04:52:27.596
that device and so forth.  But 
what  if you were building, say,

04:52:27.654 --> 04:52:32.044
 1,000 devices?  Or 10,000  
devices?  Or you're moving up to

04:52:32.047 --> 04:52:34.964
 a million devices and  all of 
these devices need to be set up,

04:52:35.672 --> 04:52:38.204
 configured,  provisioned, 
security, and then you need to 

04:52:38.205 --> 04:52:41.232
scale out so  that when those 
devices are producing tons of 

04:52:41.233 --> 04:52:44.679
data, that  you're able to 
handle it.  So this is where 

04:52:44.680 --> 04:52:48.818
cloud shines shines.
So we have these systems where 

04:52:48.819 --> 04:52:50.226
you don't have to  worry about 
the capacity that you're 

04:52:50.227 --> 04:52:53.272
creating.  The  system will 
automatically scale up and down 

04:52:53.273 --> 04:52:56.398
to the needs  that you have.  
And so this is where -- this is 

04:52:56.399 --> 04:53:01.460
why you  should care about 
Google Cloud IoT core.  So I'm 

04:53:01.461 --> 04:53:04.991
going  to give you a background 
on what is IoT core?  Just bear 

04:53:04.992 --> 04:53:07.525
 with me, and I'll tell you 
about the products that are  

04:53:07.526 --> 04:53:12.775
important, and then we'll get 
into the exciting usage  

04:53:12.776 --> 04:53:15.995
scenarios.
So on the left, I have IoT core,

04:53:16.105 --> 04:53:19.227
 and currently,  it's a way of 
creating a registry where you 

04:53:19.228 --> 04:53:26.203
can define  where devices are, 
and then connecting your devices

04:53:26.903 --> 04:53:35.695
  using NQTT to then take your 
data and put it into pub/ 

04:53:35.696 --> 04:53:38.115
pub/sub and your data is now in 
Google's cloud.  And you  can 

04:53:38.116 --> 04:53:43.571
use it to trigger API calls or 
use data flow to  extract that 

04:53:43.572 --> 04:53:49.933
data from pub/sub and put it 
into bit query  and then do data

04:53:50.034 --> 04:53:52.257
 analytics on it.  So I'm going 
to tell  you a little bit more 

04:53:52.258 --> 04:53:53.871
about those products so that you
  can understand this better.

04:53:53.872 --> 04:53:57.913
So what is MQTT?  If you've 
heard about it before  before --

04:53:58.126 --> 04:54:01.548
 if you've worked in IoT before,
 you've  probably heard about MQ

04:54:02.260 --> 04:54:06.801
TT.  It is a standard that was  
designed by IB IBM in the '90s, 

04:54:06.802 --> 04:54:09.929
and it allows you to  securely 
connect devices and transmit 

04:54:09.930 --> 04:54:14.585
data and receive  messages from 
a published subscribe-like 

04:54:14.586 --> 04:54:17.418
solution.  It's  a binary 
protocol, so it's very efficient

04:54:17.516 --> 04:54:21.054
 on the line,  and it won't use 
as much power or require as much

04:54:22.448 --> 04:54:24.574
  processing power as a lot of 
other protocols that you  may be

04:54:24.777 --> 04:54:29.325
 familiar with.  And so it's 
sort of the de facto  standard, 

04:54:29.326 --> 04:54:33.570
which is why Google adopted it. 
 So what is  Google Cloud pub/

04:54:34.069 --> 04:54:36.596
sub?  Google Cloud

04:54:40.161 --> 04:54:44.255
 pub/sub is for  publishing and 
subscribing.  You create the 

04:54:44.256 --> 04:54:46.275
topics and  then subscribe to 
the topics and then receive 

04:54:46.276 --> 04:54:48.506
payloads  that were pushed into 
those topics.  And it's globally

04:54:48.805 --> 04:54:52.338
  distributed, and it's reliable
 so that you can get at  least 

04:54:52.339 --> 04:54:55.463
-- when you send messages 
through Google Cloud  pub/sub, 

04:54:55.464 --> 04:54:59.300
you know that they will be 
received by the  subscribers at 

04:54:59.301 --> 04:55:01.825
least
  once.  And so when you have 

04:55:01.826 --> 04:55:05.042
this  large globally-distributed
 system, you have to just  

04:55:05.043 --> 04:55:08.385
certain tradeoffs.  And one of 
those tradeoffs is that  you 

04:55:08.386 --> 04:55:10.823
don't know the order the 
messages came in.  And the  

04:55:10.824 --> 04:55:13.835
other is that the messages only 
last inside of that  store for 

04:55:13.836 --> 04:55:16.158
about seven days.  So what do 
you do about  that?  And this is

04:55:16.163 --> 04:55:18.885
 the last product that I want to
 talk  about before we start 

04:55:18.886 --> 04:55:21.414
talking about architectures.  So
  this is data flow.  What data 

04:55:21.415 --> 04:55:24.644
flow does is it allows you  to 
take the stream of messages that

04:55:24.948 --> 04:55:29.100
 come in through  pub/sub, and 
then ensure they're ordered 

04:55:29.101 --> 04:55:32.540
correctly or  make sure that 
they're only once existing 

04:55:32.541 --> 04:55:35.166
inside of your  persistence data
 storeers, and then you can take

04:55:35.264 --> 04:55:40.021
 them and  put them in other 
places, so you can ETL from 

04:55:40.022 --> 04:55:43.554
pub/sub  very easily using data 
flow.

04:55:43.952 --> 04:55:47.995
So -- excuse me,.  So what 
services are in cloud  IoT core?

04:55:48.397 --> 04:55:50.622
  And this is what I talked 
about very briefly  in that 

04:55:50.623 --> 04:55:53.337
first diagram showing high level
 architecture  for cloud IoT.  

04:55:53.338 --> 04:55:56.664
There's a device manager, which 
I like  to think of as just the 

04:55:56.665 --> 04:56:00.808
identity solution.  This device 
 manager knows which devices can

04:56:02.435 --> 04:56:06.161
 connect to this bridge,  and 
then it also will keep track of 

04:56:06.162 --> 04:56:09.900
-- it will keep  track of the 
last time that -- also to 

04:56:09.901 --> 04:56:12.523
metadata for  those devices, 
such as the last time it 

04:56:12.524 --> 04:56:14.524
connected and  the last time 
that configuration was sent to a

04:56:14.548 --> 04:56:18.371
 device.   And the device 
manager also allows you to send 

04:56:18.372 --> 04:56:20.788
specific  configurations down to
 a device, and I'll talk more  

04:56:20.789 --> 04:56:24.428
about this in a minute.
So the MQTT bridge is something 

04:56:24.429 --> 04:56:27.761
that works hand in  hand with 
the device manager to allow you 

04:56:27.762 --> 04:56:33.203
to communicate  directly to a 
single pub/sub queue.  And so 

04:56:33.204 --> 04:56:37.036
given these  collections of 
services, you can then start to 

04:56:37.037 --> 04:56:40.466
create  IoT solutions that are 
tailored to specific domains of 

04:56:40.467 --> 04:56:45.317
 problem.  And, again, this goes
 back to the commercial,  

04:56:45.318 --> 04:56:49.166
industrial applications first.  
And other architectures  and 

04:56:49.167 --> 04:56:52.607
other platforms can use it as 
well.  But when you  think about

04:56:52.614 --> 04:56:55.225
 this and the context of Android
 Things and  other solutions, 

04:56:55.226 --> 04:56:59.068
it's really well tailored to 
industrial industrial.  So the 

04:56:59.069 --> 04:57:03.089
first thing I want to talk about
 is  telemetry analytics.  And 

04:57:03.090 --> 04:57:08.541
this is when you have  something
 like a large weather station 

04:57:08.542 --> 04:57:12.872
distributed  around the world 
that are each simultaneously 

04:57:12.873 --> 04:57:15.396
parametric  data or position 
data that are moving around.  

04:57:15.397 --> 04:57:18.122
And in  this scenario what you 
would typically have is all of  

04:57:18.123 --> 04:57:22.877
those devices connecting with 
massive to cloud IoT core,  and 

04:57:22.878 --> 04:57:25.697
then cloud IoT core is going to 
work one to one with

04:57:25.698 --> 04:57:28.010
   pub/sub to take that data and
 then put it into Google's  

04:57:28.011 --> 04:57:33.565
cloud.  And then you would 
typically use Betty beta flow to

04:57:33.568 --> 04:57:37.508
  take that data and put it in a
 place with analytics.   And 

04:57:37.509 --> 04:57:42.150
then once that's there, you can 
use Google's  analytic product 

04:57:42.151 --> 04:57:46.288
such as data lab and studio to 
analyze  your data and make 

04:57:46.289 --> 04:57:48.495
predictions and so forth.
So the second thing I want to 

04:57:48.496 --> 04:57:51.225
talk about, the  second scenario
 I want to talk about is device 

04:57:51.226 --> 04:57:53.553
to device  communication.  So 
this is when you have one device

04:57:53.850 --> 04:57:58.293
, and  that device could be an 
Android Things device or it  

04:57:58.294 --> 04:58:04.653
could be a memory device like an
 ASPA266, and then that  device 

04:58:04.654 --> 04:58:07.182
is going to try to trigger 
another state on  another device

04:58:07.286 --> 04:58:11.117
 to change.  So we built a demo 
around  this where we had all of

04:58:11.118 --> 04:58:16.184
 these sensors inside the room, 
 and the sensors were run the so

04:58:16.186 --> 04:58:18.490
 that the objective when  the 
room reached a certain 

04:58:18.491 --> 04:58:20.607
temperature, we would have  
another device that would turn 

04:58:20.608 --> 04:58:23.939
on a fan.  So in this  scenario,
 you would have all of these 

04:58:23.940 --> 04:58:30.287
devices, and they  could be 
Android Things or, you know, 

04:58:30.288 --> 04:58:33.415
memory devices,  and that would 
connect IoT core, which would 

04:58:33.416 --> 04:58:36.451
pump the  data into pub/sub, 
which you could extract using 

04:58:36.452 --> 04:58:39.568
data  flow, and then you can use
 a cloud function to then go  

04:58:39.569 --> 04:58:44.518
back to the device manager for 
cloud IoT core to send a  

04:58:44.519 --> 04:58:46.837
configuration change to a second
 device.  And then that  second

04:58:46.949 --> 04:58:50.061
  device has the configuration 
change something,  like, turn on

04:58:50.062 --> 04:58:53.899
 your fan, start pumping water 
out of the  room, and so forth. 

04:58:53.900 --> 04:58:55.734
 And so I'm going to show you 
one  more pattern, then we're 

04:58:55.735 --> 04:58:58.153
going to start talking about  
the platform itself.  And this 

04:58:58.154 --> 04:59:00.668
last pattern is the same  thing 
that we had before, but I want 

04:59:00.669 --> 04:59:05.512
to put an Android  Things device
 in there explicitly.  And 

04:59:05.513 --> 04:59:08.137
because we want  to have 
something like state change 

04:59:08.138 --> 04:59:14.583
shared or shared  state between 
that device in the Android 

04:59:14.584 --> 04:59:20.633
companion app  or other Web view
.  So if you have some sort of 

04:59:20.634 --> 04:59:25.678
god view  for, say, a warehouse 
for all of these fans, you could

04:59:26.589 --> 04:59:29.526
  share that state and then 
share that state from a  

04:59:29.527 --> 04:59:32.850
Firebase.  So in this scenario 
we'll walk through very  quickly

04:59:33.060 --> 04:59:37.195
.  You have this device, and it 
connects to cloud  IoT core, and

04:59:37.200 --> 04:59:40.119
 then cloud IoT core will take 
at a data  and put it into 

04:59:40.120 --> 04:59:43.761
pub/sub, which could then go 
through  data flow, which then 

04:59:43.762 --> 04:59:46.571
could directly trigger state  
changes inside of that Firebase 

04:59:46.572 --> 04:59:48.906
realtime database.  And  then 
that --

04:59:48.907 --> 04:59:50.715
  because the state change's 
consistent  between that 

04:59:50.716 --> 04:59:53.841
database and Android Things, 
then the state  could be 

04:59:53.842 --> 04:59:56.965
triggered to turn on a lightbulb
.  So in this  specific example,

04:59:57.275 --> 05:00:01.937
 I was thinking of a device, the
 first  device or collection of 

05:00:01.938 --> 05:00:06.666
devices has a server so that  
when a room goes dark, the 

05:00:06.667 --> 05:00:09.892
lights turn on.  So this is  the
 foundation for kind of thinking

05:00:10.182 --> 05:00:13.821
 about the ways that  you can 
use this platform to do all 

05:00:13.822 --> 05:00:17.164
sorts of things that  people 
want to do with IoT.

05:00:17.465 --> 05:00:21.902
So now it's time to talk a 
little bit about the  first 

05:00:21.903 --> 05:00:24.407
component that is the -- the 
first service that is  enabled 

05:00:24.408 --> 05:00:28.445
through cloud IoT core, the 
device manager.  And  so I like 

05:00:28.446 --> 05:00:31.177
to think about the device 
manager as an  identity provider

05:00:31.695 --> 05:00:35.122
.  And so what this does -- what
 this  means is that it knows 

05:00:35.123 --> 05:00:38.543
the devices and their 
credentials  that can connect to

05:00:38.545 --> 05:00:41.074
 the service so that they can 
then  stream their data to us.

05:00:41.983 --> 05:00:46.603
So the device manager uses a 
resource model.  And  devices 

05:00:46.604 --> 05:00:49.736
are defined by using -- so 
there's a hierarchy.   So you 

05:00:49.737 --> 05:00:54.369
have each device associated with
 configuration at  the bottom, 

05:00:54.370 --> 05:00:58.199
and that device also will 
contain individual  

05:00:58.200 --> 05:01:01.339
configuration, and then you can 
use the -- and then  those 

05:01:01.340 --> 05:01:06.884
devices are placed into a 
registry, which contains  a list

05:01:06.981 --> 05:01:12.664
 of devices.  And then you can 
programmatically  add and remove

05:01:12.853 --> 05:01:14.853
 devices.
So

05:01:17.180 --> 05:01:19.602
 registryies are a way that you 
can largely  encapsulate devices

05:01:19.802 --> 05:01:25.555
 into a store.  And in doing so,
  registryies map devices from 

05:01:25.556 --> 05:01:30.807
the protocol bridge, cloud  
pub/sub topics and subscriptions

05:01:31.302 --> 05:01:40.585
 to pub/sub.  Sorry.
A little thirsty.  So typically 

05:01:40.586 --> 05:01:44.231
what you're going  to do is 
you're going to have a registry 

05:01:44.232 --> 05:01:47.764
that maps then  to a pub/sub 
topic, and then you're going to 

05:01:47.765 --> 05:01:51.082
probably  extract that data from
 that pub/sub topic using data  

05:01:51.083 --> 05:01:54.116
flow.  And then as such, like, 
you're probably going to  want 

05:01:54.117 --> 05:01:58.043
to have a single place where all
 of that data is  going and so 

05:01:58.044 --> 05:02:01.872
you can then -- we recommend 
that you  logically map 

05:02:01.873 --> 05:02:06.516
everything to a pub/sub topic 
and just  have a single registry

05:02:06.552 --> 05:02:08.552
.

05:02:14.885 --> 05:02:17.131
  So before you can add devices 
 to a registry, you have to be 

05:02:17.132 --> 05:02:19.761
able to create that  registry.  
So we have all of these 

05:02:19.762 --> 05:02:23.792
solutions for  creating 
registers, lifting registers, 

05:02:23.793 --> 05:02:27.029
deleting  registers, you can do 
it all program actually because 

05:02:27.030 --> 05:02:29.250
we  envision a lot of different 
ways that people will use  this.

05:02:29.444 --> 05:02:33.330
  In certain scenarios, you 
would have a device  manufacture

05:02:34.698 --> 05:02:39.428
  manufacturer who is going to 
provision all of the  registry

05:02:39.531 --> 05:02:42.850
ies for you.  So you can 
delegate these to a  device 

05:02:42.851 --> 05:02:46.089
manufacturer so that they can do
 that and  manufacture.  And 

05:02:46.090 --> 05:02:47.496
another
  scenarios, you're going to  

05:02:47.497 --> 05:02:49.904
want to be able to do the device
 provisioning later.  So  in 

05:02:49.905 --> 05:02:53.931
this way, we also support that 
scenario.

05:02:54.447 --> 05:02:57.164
So before you can connect a 
device, you have to  create that

05:02:57.964 --> 05:03:01.599
 device inside of device 
registry.  And so we  have what 

05:03:01.600 --> 05:03:04.917
you would expect.  It's a basic 
crud API or  creating, deleting,

05:03:05.228 --> 05:03:11.068
 reading, enlisting, and so 
forth  your devices.  And each 

05:03:11.069 --> 05:03:13.677
of the devices will have a  
unique identifier that's 

05:03:13.678 --> 05:03:15.091
associated with the device that 
 has returned from the API when 

05:03:15.092 --> 05:03:18.921
you create that device.   You 
can also get the device and then

05:03:19.229 --> 05:03:22.948
 get this  information.
But if you look on the JSON 

05:03:22.949 --> 05:03:24.773
representation, which  is 
probably really hard to see on 

05:03:24.774 --> 05:03:28.091
the screen, but the  JSON 
representation has all of this 

05:03:28.092 --> 05:03:30.213
metadata associated  with the 
device.  For example, you know, 

05:03:30.214 --> 05:03:32.623
the last time  that a 
acquisition was sent to the 

05:03:32.624 --> 05:03:34.932
device and you know  the last 
time the device connected and so

05:03:34.933 --> 05:03:39.571
 forth, and in  in -- and so the
 -- this is sort of the magic of

05:03:40.685 --> 05:03:44.023
 where  the device manager comes
 in place.  Because your device 

05:03:44.024 --> 05:03:46.137
device's connecting and because 
we had identity for that  device

05:03:46.231 --> 05:03:48.960
, we know the last time the 
configuration changes  came to 

05:03:48.961 --> 05:03:53.242
that device and information such
 as the state of  the device.

05:03:53.684 --> 05:03:57.419
So you can delegate -- again, 
you can delegate the  

05:03:57.420 --> 05:04:01.860
permissions for device creation 
deletion and so forth to  your 

05:04:01.861 --> 05:04:05.775
manufactured, or you can do it 
yourself.

05:04:05.978 --> 05:04:09.015
And so this is a good point to 
talk about identity identity.  

05:04:09.016 --> 05:04:12.528
So identity is knowing which 
device has  connected, and this 

05:04:12.529 --> 05:04:15.853
is the magic where all of that  
metadata such as the last 

05:04:15.854 --> 05:04:19.568
heartbeat that came from a  
device is made available and 

05:04:19.569 --> 05:04:23.395
things like wind  configuration 
changes came down to a device.  

05:04:23.396 --> 05:04:27.224
So you can  have -- and so when 
you create the identity for a 

05:04:27.225 --> 05:04:33.067
device device, you're going to 
use an an asymmetric encryption 

05:04:33.068 --> 05:04:38.017
to  give Google your public key 
that is associated with a  

05:04:38.018 --> 05:04:41.031
device credential.  And then 
your private key will be on  the

05:04:41.333 --> 05:04:44.850
 device so that you can use that
 private key to  create an 

05:04:44.851 --> 05:04:48.501
encrypted payload that you send 
to Google when  you connect.  

05:04:48.502 --> 05:04:52.411
And the -- and when you -- and 
something  that's kind of 

05:04:52.412 --> 05:04:54.539
special about our device 
configuration is  that we allow 

05:04:54.540 --> 05:04:59.873
you to create multiple 
certificates and  then put them 

05:04:59.874 --> 05:05:01.903
associated with the device is 
that you can  rotate and expire 

05:05:01.904 --> 05:05:04.204
those certificates.  So you 
would do  something like -- I 

05:05:04.205 --> 05:05:06.530
want to create a device today, 
and  then I'm

05:05:06.531 --> 05:05:09.453
  going to create three 
certificates.  The first  

05:05:09.454 --> 05:05:12.887
expires in a year, the second in
 two, and then the third  in 

05:05:12.888 --> 05:05:16.121
three.  So that way when you're 
effectively rotating  your keys 

05:05:16.122 --> 05:05:19.632
or device credentials.  And I 
want to note  never send anyone 

05:05:19.633 --> 05:05:27.897
your private keys.  It's, like, 
just  your password.

05:05:28.201 --> 05:05:30.914
So device configuration is the 
next thing I want  to talk about

05:05:31.220 --> 05:05:33.546
.  Every device has a 
configuration  associated with 

05:05:33.547 --> 05:05:36.057
it that is maintained by the 
device  management.  And so what

05:05:36.058 --> 05:05:40.402
 this means is that you have  
this -- something like the state

05:05:40.598 --> 05:05:43.534
 of the device or if you  want 
to have a fan turned on, you 

05:05:43.535 --> 05:05:47.842
could represent that  in binary 
data that I think is what it is 

05:05:47.843 --> 05:05:52.276
is a JSON  screen.  But we also 
-- you could also do something 

05:05:52.277 --> 05:05:55.394
like  a machine learning model 
that you pass down to a device  

05:05:55.395 --> 05:05:59.728
that is stored inside of binary 
data.  And then that  machine 

05:05:59.729 --> 05:06:02.276
learning model could be updated 
on the fly with  the 

05:06:02.277 --> 05:06:06.273
configuration.  So, again, the 
device configuration  is binary 

05:06:06.274 --> 05:06:09.608
data, but you're welcome to en
code other data  and send it as 

05:06:09.609 --> 05:06:12.322
that.  And we did this so that 
people  could have the flex

05:06:12.524 --> 05:06:16.162
ibility to send all sorts of 
data  down to the devices.  And 

05:06:16.163 --> 05:06:19.371
the device manager maintains  
ten versions of configurations 

05:06:19.372 --> 05:06:22.093
that you could roll back  if 
something goes wrong when you 

05:06:22.094 --> 05:06:24.715
send out a  configuration change
.

05:06:27.636 --> 05:06:31.072
device  configuration is that 
whenever your device 

05:06:31.073 --> 05:06:33.691
configuration  is changed, so 
you send a new version of a 

05:06:33.692 --> 05:06:36.210
configuration  associated with 
the device, that device will 

05:06:36.211 --> 05:06:44.480
receive a  notification many QTT
 -- in MQTT subscription device 

05:06:44.481 --> 05:06:48.199
 change.  So you also get the 
subscription every time you  

05:06:48.200 --> 05:06:51.928
check.  And developers can patch
 an old version and then  do 

05:06:51.929 --> 05:06:54.443
something like roll back to it 
if you want to use the  API in 

05:06:54.444 --> 05:06:59.482
that way.  And the device 
acknowledges when it's  it's -- 

05:06:59.483 --> 05:07:02.918
any time that a configuration 
comes down to a  device, the 

05:07:02.919 --> 05:07:09.055
device will notify Google that 
it has  acknowledged that 

05:07:09.056 --> 05:07:13.186
configuration changed.  And this
 is  done because we have at 

05:07:13.187 --> 05:07:18.125
least one delivery of messages  
and it could come down down to 

05:07:18.126 --> 05:07:21.348
devices.
A couple more details about 

05:07:21.349 --> 05:07:25.872
identity.  When you  connect to 
our MQTT end point, you need to 

05:07:25.873 --> 05:07:34.952
use TLS 1.1  or 1.2, and you 
need to use MQTT3.1.1.  I 

05:07:34.953 --> 05:07:37.367
encountered  issues in the past 
using the wrong version.  And go

05:07:38.373 --> 05:07:42.602
 back  to pub/sub, it has one 
delivery but not exactly as a  

05:07:42.603 --> 05:07:48.560
tradeoff.  So said only QOS one.
  So typically the way  that you

05:07:48.951 --> 05:07:53.790
 use MQTT is you specify the QOS
 when you create  the connection

05:07:54.601 --> 05:08:02.658
 stream.  So just make sure 
you're using M MQOS1.  So we 

05:08:02.659 --> 05:08:07.197
make our connection end point 
locally  available at MQTT.

05:08:07.198 --> 05:08:12.825
GoogleaPIs.com, and we support 
two  ports.  88, 83, which is 

05:08:12.826 --> 05:08:18.673
the standard QLS port and then  
443, which is firewall friendly.

05:08:18.674 --> 05:08:23.105
And then the last thing I want 
to talk about is  the MQQT 

05:08:23.106 --> 05:08:26.438
bridge.  And this is a way you 
can send  telemetry data from 

05:08:26.439 --> 05:08:29.764
using the device manager down to
 a  specific device.  And then 

05:08:29.765 --> 05:08:33.391
ways that -- the way that you  
send the configuration change 

05:08:33.392 --> 05:08:36.102
down to the device using  the 
device manager and the way that 

05:08:36.103 --> 05:08:40.437
you can do something  like send 
telemetry data, for example, in 

05:08:40.438 --> 05:08:43.157
one of those  examples earlier 
back to Google to store in cloud

05:08:43.559 --> 05:08:46.681
 and  then warehouse for 
analytics for later.

05:08:47.198 --> 05:08:52.528
So authentication, again, is 
done using an N QTT  client ID, 

05:08:52.529 --> 05:08:55.446
which is the -- so the ID is 
something like  the connection 

05:08:55.447 --> 05:08:58.481
string.  And that ID is going to
 be  unique per device.  And 

05:08:58.482 --> 05:09:02.104
then the other thing is that you
  need a user name, which Google

05:09:02.601 --> 05:09:04.827
 ignores, so you could put  
anything in your user name field

05:09:05.121 --> 05:09:09.951
.  And then for the  password, 
you have to calculate a jot.  

05:09:09.952 --> 05:09:14.177
And the jot is  that token that 
has an expiration so that this 

05:09:14.178 --> 05:09:16.904
way you  can prevent, again, 
certain types of brute force 

05:09:16.905 --> 05:09:22.063
attacks attacks.  And because 
that jot expires, you need to 

05:09:22.064 --> 05:09:27.299
have  an expiration time and an 
issue at time that is  

05:09:27.300 --> 05:09:30.605
calculated consistently with 
what Google expects.  So  you 

05:09:30.606 --> 05:09:35.544
can use Google's NTB server, 
which is time.Google 

05:09:35.545 --> 05:09:40.996
time.Google.com in order to get 
for free a issued at  time and 

05:09:40.997 --> 05:09:45.614
calculate the expiration.
So when you publish data, so the

05:09:46.726 --> 05:09:50.639
 telemetry data or  
configuration change twiring 

05:09:50.640 --> 05:09:53.976
from a device, you're going  to 
use the MQTT bridge.  And you 

05:09:53.977 --> 05:09:59.923
must use this pattern  of 
devices/device ID/events and 

05:09:59.924 --> 05:10:03.555
anything that comes  after 
events is going to have -- is 

05:10:03.556 --> 05:10:06.504
going to be created  with 
additional metadata, which we 

05:10:06.505 --> 05:10:09.906
refer to as a sub subtopic.  So 
if you want to create something 

05:10:09.907 --> 05:10:15.041
like an  alert, you would put 
that in devices/device ID/events

05:10:15.241 --> 05:10:17.758
/ ID/events/alerts, and then 
when the -- when you would  get 

05:10:17.759 --> 05:10:22.885
that data coming into pub/sub, 
it would have that  information 

05:10:22.886 --> 05:10:27.134
digital alert.
And so when you receive -- when 

05:10:27.135 --> 05:10:30.448
you want to  receive information
 on your devices, you're going 

05:10:30.449 --> 05:10:34.574
to  need to subscribe to a topic
.  And the topic that you  

05:10:34.575 --> 05:10:38.612
subscribe to must be devices 
slash your device ID slash  

05:10:38.613 --> 05:10:42.240
config.  Because right now the 
only data that can come  down 

05:10:42.241 --> 05:10:46.067
from Google Cloud IoT core to 
your devices is  configuration 

05:10:46.068 --> 05:10:48.577
change.
So, again, the device 

05:10:48.578 --> 05:10:50.292
configuration is received on  
the device when you connect and 

05:10:50.293 --> 05:10:55.027
any time that the  configuration
 changes and the final detail 

05:10:55.028 --> 05:10:57.153
that I  haven't mentioned before
 is that you do not get the  

05:10:57.154 --> 05:10:59.263
version number inside of the 
device configuration,  you're 

05:10:59.264 --> 05:11:04.083
welcome to insert it yourself, 
or you can also  request 

05:11:04.084 --> 05:11:08.519
specific versions.
So now that you've gotten a high

05:11:08.729 --> 05:11:12.450
 level overview of  what the 
platform is, I'm going to do a 

05:11:12.451 --> 05:11:18.603
quick demo.  Of  just kind of 
how these -- how the device 

05:11:18.604 --> 05:11:23.735
manager works,  and then how you
 connect using MQTT.

05:11:30.994 --> 05:11:35.731
Can everyone see okay?  Okay.  
This is good.

05:11:36.022 --> 05:11:40.052
So the first thing I'm going to 
do is so I'm in a  node sample 

05:11:40.053 --> 05:11:44.791
directory, and then I'm going to
 use the  device manager from 

05:11:44.792 --> 05:11:48.616
node in order to register a 
device  in a registry that I've 

05:11:48.617 --> 05:11:50.702
already created.

05:11:57.381 --> 05:12:01.780
  And so the  parameters -- oh,.
  Every time.

05:12:10.373 --> 05:12:14.409
  So I'm going to create a  
device using the device manager,

05:12:14.604 --> 05:12:18.428
 and this -- I'm going  to use 
an RSA256 certificate.  So I'm 

05:12:18.429 --> 05:12:21.856
just going to take  my -- I 
already generated in the 

05:12:21.857 --> 05:12:26.494
previous step a private  key and
 a public key using open SSL.  

05:12:26.495 --> 05:12:32.932
So this RSA cert  that I created
 will be sent to Google with a 

05:12:32.933 --> 05:12:39.183
request to  create a device.
But, yeah, so I'm going to 

05:12:39.184 --> 05:12:43.414
create a device with  the name 
hello, GDD, and then it's going 

05:12:43.415 --> 05:12:46.442
to be created  in a registry 
that I've already created called

05:12:46.641 --> 05:12:52.600
 MQTT test  Reg, and then I'm 
going to use the device 

05:12:52.601 --> 05:12:55.710
certificate.   And then when the
 device gets created, you 

05:12:55.711 --> 05:12:59.335
receive back  the identifier 
that Google calculates for it, 

05:12:59.336 --> 05:13:01.336
as well as  a configuration for 
that.

05:13:01.551 --> 05:13:05.079
And so now that I've created the
 device, I should  be able to 

05:13:05.080 --> 05:13:12.328
connect to the MQTT end point 
using that jot  for the device 

05:13:12.329 --> 05:13:14.329
calculating using its public 
certificate.   I'm going to copy

05:13:14.339 --> 05:13:19.935
 this because I keep forgetting 
forgetting my  device ID.

05:13:23.303 --> 05:13:25.597
Okay.  So now

05:13:33.086 --> 05:13:36.007
 -- so I'm going to install the 
 dependencies, which is, like, 

05:13:36.008 --> 05:13:39.404
an MQTT client.

05:14:10.257 --> 05:14:19.122
So, again, I'm going to use -- 
all right.  Today's  not my

05:14:21.162 --> 05:14:30.026
 day.  I'm going to hack it and 
see what the  parameters were.

05:14:34.052 --> 05:14:36.872
  So I'm going to have to pass 
in my  project ID, the registry 

05:14:36.873 --> 05:14:41.790
ID, device ID, and then the  
path to my public file.

05:15:35.055 --> 05:15:40.492
It totally worked earlier.  
Every time.  The demo  gods are 

05:15:40.493 --> 05:15:44.732
not on my side.  So I need to 
specify -- so I  at least need 

05:15:44.733 --> 05:15:48.853
to specify the private key file,
 the  project ID, the registry 

05:15:48.854 --> 05:15:53.478
ID, and the device ID.  Almost  
there.  I think just one more.

05:15:54.601 --> 05:15:58.372
Doesn't like it when I get a 
negative return.

05:16:04.200 --> 05:16:06.386
   Private key file.

05:16:12.370 --> 05:16:19.117
  There we go.  Yes.  Maybe.  
Okay.   Yes.  Now thank you.  

05:16:19.118 --> 05:16:20.725
Okay.
[Laughter]

05:16:20.726 --> 05:16:25.682
Okay.  So now the data should be
 coming into  pub/sub and if you

05:16:25.683 --> 05:16:31.216
 do a -- if I pull -- this looks
  really small.  There we go.  

05:16:31.217 --> 05:16:35.853
Now if I keep pulling this,  
eventually we should start 

05:16:35.854 --> 05:16:41.996
seeing this -- it is coming  in.
  Maybe I jumped the gun there.

05:16:42.205 --> 05:16:45.323
Sometimes it takes a little bit 
for the messages  to come 

05:16:45.324 --> 05:16:47.551
through on pub/sub.

05:16:50.670 --> 05:16:54.417
  Or maybe I put in the wrong  
registry, which happens.  

05:16:54.418 --> 05:16:56.740
Sometimes you forget.

05:17:01.965 --> 05:17:07.697
  And  then we're almost done.  
Let's see.  What did I do  

05:17:07.698 --> 05:17:11.603
before?  Oh, no, that looks 
right.

05:17:26.245 --> 05:17:28.676
So it does appear to be 
connecting.  It does  appear to 

05:17:28.677 --> 05:17:32.004
be transmitting those datas -- 
or it does  appear to be 

05:17:32.005 --> 05:17:37.652
transmitting the data into the 
pub/sub and  imagine if you will

05:17:37.953 --> 05:17:43.295
 of telemetry messages coming in
.  So  sometimes it can take a 

05:17:43.296 --> 05:17:45.917
while for the messages to appear
 appear, and it seems as though 

05:17:45.918 --> 05:17:48.635
that's what's happening  now.  
But that's pretty much all I 

05:17:48.636 --> 05:17:53.876
have.  So if we can  return to 
the slides, I have just one more

05:17:54.072 --> 05:18:01.101
 slide to show show.  Oh, did I?
  Let's see.

05:18:04.166 --> 05:18:13.216
  You caught the bug.  MQTT  
test dash.  I don't know.

05:18:17.351 --> 05:18:21.898
  Oh, when I'm reading -- oh,  
that's because -- the reason 

05:18:21.899 --> 05:18:25.318
these are different is this  is 
the subscription and then the 

05:18:25.319 --> 05:18:28.242
registry is entirely  
independent of that.  So there's

05:18:28.441 --> 05:18:31.374
 a topic that you  publish to, 
there's a registry associated 

05:18:31.375 --> 05:18:34.188
with that  topic, and then 
there's a subscription that 

05:18:34.189 --> 05:18:38.627
pulls from  that topic.  So -- 
yeah, so the subscriptioning is 

05:18:38.628 --> 05:18:41.339
going  to be different.  
Sometimes it does take a minute 

05:18:41.340 --> 05:18:44.774
for  the messages to get 
triggered inside of there, but I

05:18:44.775 --> 05:18:46.886
  think I'm
  doing something else wrong.

05:18:47.296 --> 05:18:56.368
But, yeah, that's it.  So we're 
currently in a  private beta.  

05:18:56.369 --> 05:18:59.403
And if we go back to the slides,
 we'll be  able to see where we 

05:18:59.404 --> 05:19:02.819
can get more information about 
that that.  So if you go to 

05:19:02.820 --> 05:19:07.559
cloud.Google.com/IoT core, you  
can sign up for the data and 

05:19:07.560 --> 05:19:12.187
learn more about the  product, 
such as details.  Yeah, so it's 

05:19:12.188 --> 05:19:16.421
like the cusp  of the exciting 
time for this product.  

05:19:16.422 --> 05:19:18.422
Sometimes things  will work,

05:19:20.961 --> 05:19:23.380
.
And so thank you for attending 

05:19:23.381 --> 05:19:25.087
my talk.  I really  appreciate 
your time.

05:19:25.088 --> 05:19:27.088
[Applause]

05:19:30.654 --> 05:19:34.010
And if you want to see more 
demos, and you want to  chat 

05:19:34.011 --> 05:19:36.686
with me more about the product, 
I'll be hanging out  at office 

