WEBVTT
Kind: captions
Language: en

00:00:02.440 --> 00:00:03.900
RYAN BOYD: Hi, everyone.

00:00:03.900 --> 00:00:06.030
Welcome back for those of you
who were in the first session

00:00:06.030 --> 00:00:07.340
here today.

00:00:07.340 --> 00:00:09.510
I'm happy to introduce
here Dan Holevoet.

00:00:09.510 --> 00:00:12.600
Dan Holevoet is the lead on our
developer relations team

00:00:12.600 --> 00:00:15.960
for App Engine, and he's going
to be here today talking about

00:00:15.960 --> 00:00:19.050
using Google Cloud Endpoints to
connect your mobile apps to

00:00:19.050 --> 00:00:21.170
the cloud without breaking
a sweat.

00:00:21.170 --> 00:00:23.590
For those you weren't here in
the first session, Cloud

00:00:23.590 --> 00:00:25.660
Endpoints is our technology
that allows you to take

00:00:25.660 --> 00:00:28.720
advantage of Google's underlying
API serving

00:00:28.720 --> 00:00:32.350
infrastructure that we use for
building many of our own APIs.

00:00:32.350 --> 00:00:35.540
And so Dan is going to talk to
you about how you can use that

00:00:35.540 --> 00:00:37.020
to build your APIs.

00:00:37.020 --> 00:00:37.380
Dan.

00:00:37.380 --> 00:00:39.350
DAN HOLEVOET: Thanks, Ryan.

00:00:39.350 --> 00:00:42.170
A little too many spoilers
in that there.

00:00:42.170 --> 00:00:44.640
People aren't going to have
any excitement here.

00:00:44.640 --> 00:00:44.820
Yes.

00:00:44.820 --> 00:00:47.450
So I'm Dan, and I'm here today
to talk to you about Cloud

00:00:47.450 --> 00:00:50.420
Endpoints as Ryan said, which
is a really cool way to

00:00:50.420 --> 00:00:55.540
connect your mobile backends
to clients running in

00:00:55.540 --> 00:00:57.800
JavaScript, Android,
or iOS devices.

00:00:57.800 --> 00:01:02.100
So to start off before I get
too far into the slides, if

00:01:02.100 --> 00:01:05.050
anyone wants to follow along
at home, I've got a QR code

00:01:05.050 --> 00:01:08.180
here you can use to grab the
slide link or short line at

00:01:08.180 --> 00:01:11.020
the top if you want to type
that into your laptops.

00:01:11.020 --> 00:01:12.270
I'll give you a second
to grab that.

00:01:30.060 --> 00:01:32.416
I see a few devices still
up in the air.

00:01:38.000 --> 00:01:39.560
Three, two, one.

00:01:39.560 --> 00:01:41.164
OK.

00:01:41.164 --> 00:01:42.040
All right.

00:01:42.040 --> 00:01:43.700
Perfect.

00:01:43.700 --> 00:01:47.090
So to start off, I'm going to
do a very brief overview of

00:01:47.090 --> 00:01:47.550
App Engine.

00:01:47.550 --> 00:01:47.840
I don't know.

00:01:47.840 --> 00:01:50.880
How many of you were in
the previous talk.

00:01:50.880 --> 00:01:51.150
OK.

00:01:51.150 --> 00:01:51.606
Most of you.

00:01:51.606 --> 00:01:53.550
So I'll go through this
really quick.

00:01:53.550 --> 00:01:56.870
So App Engine is a really great
way for you to build

00:01:56.870 --> 00:01:59.600
applications running on Google's
infrastructure that

00:01:59.600 --> 00:02:03.320
makes it easy to build, easy to
scale, and easy to maintain

00:02:03.320 --> 00:02:04.990
your applications running
in the cloud.

00:02:04.990 --> 00:02:08.740
So when I say easy to build,
you can write your

00:02:08.740 --> 00:02:10.740
applications in three languages,
three runtime that

00:02:10.740 --> 00:02:13.800
we have available, so that's
Java, Python, and Go.

00:02:13.800 --> 00:02:17.000
And in addition to that, we have
a bunch of services that

00:02:17.000 --> 00:02:19.720
make it easier for you to build
out these applications,

00:02:19.720 --> 00:02:23.320
so things like NoSQL datastore,
Cloud SQL,

00:02:23.320 --> 00:02:26.410
Memcache, different types of
environments that you can use

00:02:26.410 --> 00:02:29.670
to run your code, so like front
ends and backends, task

00:02:29.670 --> 00:02:33.200
queues for dividing up work
into small little tasks.

00:02:33.200 --> 00:02:36.260
And then you can run them in the
background, cron jobs for

00:02:36.260 --> 00:02:39.850
running things periodically, and
then a set of other APIs

00:02:39.850 --> 00:02:41.680
and services that you can
use that make your

00:02:41.680 --> 00:02:42.550
applications richer.

00:02:42.550 --> 00:02:46.130
So user's API that allows you
to have users log in with

00:02:46.130 --> 00:02:50.260
Google accounts, mail API for
sending email, and image API

00:02:50.260 --> 00:02:53.560
for manipulating images, URL
Fetch to basically interact

00:02:53.560 --> 00:02:55.740
with all the other web services
running on the

00:02:55.740 --> 00:02:59.510
internet, MAP producing, traffic
splitting, search, the

00:02:59.510 --> 00:03:00.790
list goes on and on.

00:03:00.790 --> 00:03:03.710
I'm not going to talk about all
those today, but you can

00:03:03.710 --> 00:03:05.120
see a full list if you go
to developers.googl

00:03:05.120 --> 00:03:08.540
e.com/appengine.

00:03:08.540 --> 00:03:10.400
App Engine also makes it
really easy to build

00:03:10.400 --> 00:03:12.220
applications at scale.

00:03:12.220 --> 00:03:16.510
This is an actual traffic graph
from an application that

00:03:16.510 --> 00:03:19.790
was experiencing a very
traffic-heavy event.

00:03:19.790 --> 00:03:23.350
I believe it was a concert on
their website, live streamed.

00:03:23.350 --> 00:03:26.420
So these peaks here, were
basically going from zero

00:03:26.420 --> 00:03:30.000
requests per second here on this
long bar on the left all

00:03:30.000 --> 00:03:33.460
the way up to a peak of 19,000
requests per second and then

00:03:33.460 --> 00:03:36.010
here a peak of 23,000
requests per second.

00:03:36.010 --> 00:03:39.870
So this is all happening about
over a period about an hour so

00:03:39.870 --> 00:03:43.180
you can see here these are
really significant spikes, and

00:03:43.180 --> 00:03:46.060
there's very deep troughs after
each of these fights

00:03:46.060 --> 00:03:49.920
because App Engine is very
quick to respond to high

00:03:49.920 --> 00:03:53.730
demand, and it's also a very
quick to scale back down once

00:03:53.730 --> 00:03:56.090
you no longer need
the resources.

00:03:56.090 --> 00:03:58.770
So you're not paying for
resources that you don't need

00:03:58.770 --> 00:04:01.470
because App Engine is scaling
up and down very quickly to

00:04:01.470 --> 00:04:03.660
respond to traffic.

00:04:03.660 --> 00:04:05.530
And then finally, I mentioned
App Engine is

00:04:05.530 --> 00:04:06.890
very easy to maintain.

00:04:06.890 --> 00:04:09.320
And I have a quote here from
one of our partners over at

00:04:09.320 --> 00:04:13.900
Rovio who's building web
applications on App Engine.

00:04:13.900 --> 00:04:16.630
And the important thing to
remember about App Engine is

00:04:16.630 --> 00:04:19.399
when you're deploying
applications onto App Engine,

00:04:19.399 --> 00:04:21.700
you're not worrying if the
server is going to stay up.

00:04:21.700 --> 00:04:24.540
Google has an entire team of
site reliability engineers

00:04:24.540 --> 00:04:28.560
making sure that applications
running in our data centers

00:04:28.560 --> 00:04:29.960
are staying alive.

00:04:29.960 --> 00:04:32.610
So this is something you don't
have to really think about

00:04:32.610 --> 00:04:36.690
once you deploy on our cloud.

00:04:36.690 --> 00:04:38.660
This is probably a slide that's
very familiar to you if

00:04:38.660 --> 00:04:40.160
you saw Ryan's presentation.

00:04:40.160 --> 00:04:42.460
This is a typical month in
the life of App Engine.

00:04:42.460 --> 00:04:45.540
We have a million active
applications running every

00:04:45.540 --> 00:04:49.010
month, more than two trillion
datastore operations, and then

00:04:49.010 --> 00:04:52.550
my favorite statistic, half of
all the active IP addresses in

00:04:52.550 --> 00:04:55.390
the world touch an App Engine
service actually every week,

00:04:55.390 --> 00:04:56.750
not every month.

00:04:56.750 --> 00:05:01.203
So these are things like
user-facing applications also

00:05:01.203 --> 00:05:03.770
servers talking to each other,
exchanging data, doing data

00:05:03.770 --> 00:05:07.280
processing, mobile applications,
connecting to a

00:05:07.280 --> 00:05:11.220
backend like I'll be talking
about today.

00:05:11.220 --> 00:05:15.010
So the real meat and potatoes,
why we're here today, building

00:05:15.010 --> 00:05:17.430
mobile backends with
App Engine.

00:05:17.430 --> 00:05:20.300
So this is probably a story
that many of you

00:05:20.300 --> 00:05:20.950
are familiar with.

00:05:20.950 --> 00:05:24.800
How many of you have
mobile apps?

00:05:24.800 --> 00:05:26.340
OK.

00:05:26.340 --> 00:05:27.490
That's a good guess.

00:05:27.490 --> 00:05:30.340
How many of you have backends
for those mobile applications,

00:05:30.340 --> 00:05:31.820
they don't just run a device?

00:05:31.820 --> 00:05:32.560
OK.

00:05:32.560 --> 00:05:35.450
Not as quite as many as I
expected, but a lot of you.

00:05:35.450 --> 00:05:36.880
So you start out.

00:05:36.880 --> 00:05:37.760
You buy a server.

00:05:37.760 --> 00:05:38.740
You put it somewhere.

00:05:38.740 --> 00:05:40.820
Maybe you're running a server
from someone that are

00:05:40.820 --> 00:05:42.640
co-located.

00:05:42.640 --> 00:05:45.050
You build a stack basically
picking what software it is

00:05:45.050 --> 00:05:46.260
you want to run.

00:05:46.260 --> 00:05:47.120
Maybe it's Apache.

00:05:47.120 --> 00:05:48.610
Maybe it's No JS.

00:05:48.610 --> 00:05:50.950
Whatever it is, you
install that.

00:05:50.950 --> 00:05:53.450
You figure out what services
you need to support your

00:05:53.450 --> 00:05:55.500
application, things like
chat, or mail, or

00:05:55.500 --> 00:05:57.610
maybe a search API.

00:05:57.610 --> 00:05:59.580
Then you think, OK, well, how am
I going to connect this to

00:05:59.580 --> 00:06:00.940
my mobile device?

00:06:00.940 --> 00:06:02.690
I'll probably write an API.

00:06:02.690 --> 00:06:03.950
Well, do I need authorization?

00:06:03.950 --> 00:06:05.530
Do I need authentication?

00:06:05.530 --> 00:06:08.020
What wire format should I use?

00:06:08.020 --> 00:06:10.130
Writes are important when I'm
sending them over the wire.

00:06:10.130 --> 00:06:11.590
These are mobile devices.

00:06:11.590 --> 00:06:14.230
I probably need compression.

00:06:14.230 --> 00:06:16.470
And then you think, OK, well,
I've got all these different

00:06:16.470 --> 00:06:17.550
platforms I'm targeting.

00:06:17.550 --> 00:06:20.350
I probably want to build a
wrapper for all of these

00:06:20.350 --> 00:06:21.030
clients, right?

00:06:21.030 --> 00:06:22.730
So maybe I want a JavaScript
client.

00:06:22.730 --> 00:06:23.730
Maybe I want a Java client.

00:06:23.730 --> 00:06:25.010
Maybe I want Objective
C client.

00:06:25.010 --> 00:06:28.190
Just target the major platforms
where I'm building

00:06:28.190 --> 00:06:30.000
these applications.

00:06:30.000 --> 00:06:33.010
And then you launch your
application, and you realize

00:06:33.010 --> 00:06:35.510
you need to start over because
the decisions that you made at

00:06:35.510 --> 00:06:37.780
the beginning of the process
turned out they didn't scale

00:06:37.780 --> 00:06:39.540
quite the way that you
wanted them to.

00:06:39.540 --> 00:06:42.350
And at this point, you realize
what you're actually spending

00:06:42.350 --> 00:06:45.350
your time on is not building
your application.

00:06:45.350 --> 00:06:48.440
It's worrying about all this
other stuff that wasn't the

00:06:48.440 --> 00:06:51.900
reason you started out
building mobile apps.

00:06:51.900 --> 00:06:53.770
You're not thinking about
cool features that you

00:06:53.770 --> 00:06:54.640
can add to your game.

00:06:54.640 --> 00:06:56.420
You're not thinking about
how you can monetize.

00:06:56.420 --> 00:06:58.280
You're not thinking how
you get more users.

00:06:58.280 --> 00:07:01.140
You're thinking about oh, my
server is going to crash,

00:07:01.140 --> 00:07:04.680
because I can only handle
10 more QPS before

00:07:04.680 --> 00:07:05.520
it explodes, right?

00:07:05.520 --> 00:07:06.980
And that's not a cool story.

00:07:06.980 --> 00:07:08.830
It's not a cool place to be.

00:07:08.830 --> 00:07:10.390
So this is a happy talk.

00:07:10.390 --> 00:07:12.580
And I'm going to talk to you
about how Endpoints solves a

00:07:12.580 --> 00:07:14.200
lot of these problems.

00:07:14.200 --> 00:07:17.560
So Endpoints allows you to
extend your App Engine

00:07:17.560 --> 00:07:21.530
backends by easily adding APIs
that you can consume from

00:07:21.530 --> 00:07:25.490
within mobile devices,
so that's JavaScript,

00:07:25.490 --> 00:07:27.870
Android, and iOS.

00:07:27.870 --> 00:07:30.190
And Endpoints has a lot of
different features that I'll

00:07:30.190 --> 00:07:30.740
talk about.

00:07:30.740 --> 00:07:32.800
So to start off, you
can build your

00:07:32.800 --> 00:07:34.770
backends in Java and Python.

00:07:34.770 --> 00:07:37.100
There's no ghost support at
the moment, but we're, of

00:07:37.100 --> 00:07:38.880
course, looking into that
because it's one of the

00:07:38.880 --> 00:07:41.880
languages supported
on App Engine.

00:07:41.880 --> 00:07:44.540
And all this is built on
Google's API infrastructure.

00:07:44.540 --> 00:07:47.460
So when you build APIs with
Endpoints running on App

00:07:47.460 --> 00:07:50.950
Engine, those APIs are being
hosted on the same API

00:07:50.950 --> 00:07:53.860
infrastructure that powers
Google's other APIs.

00:07:53.860 --> 00:07:56.730
So if you've ever used things
like the G+ API, or the

00:07:56.730 --> 00:07:59.900
calendar API, or the Tasks API,
all of those things run

00:07:59.900 --> 00:08:03.000
on the same infrastructure
that powers Endpoints.

00:08:03.000 --> 00:08:04.580
And there are some really cool
things that you can get

00:08:04.580 --> 00:08:06.690
because of that shared
infrastructure, and I'll talk

00:08:06.690 --> 00:08:08.970
a little bit more about
these later.

00:08:08.970 --> 00:08:12.520
But if you've ever used like the
API's Explorer as a way to

00:08:12.520 --> 00:08:15.750
try out new APIs or experiment
with APIs, you get that for

00:08:15.750 --> 00:08:18.340
free by using Endpoints
because it's the same

00:08:18.340 --> 00:08:19.590
infrastructure.

00:08:21.230 --> 00:08:24.220
All of these APIs are our using
JSON and they get free

00:08:24.220 --> 00:08:28.000
GZip compression over the wire,
so you're sending nice,

00:08:28.000 --> 00:08:31.770
efficient packets to your
mobile applications.

00:08:31.770 --> 00:08:33.789
We provide three client
libraries for

00:08:33.789 --> 00:08:34.980
all of these APIs.

00:08:34.980 --> 00:08:38.350
So if you're building Java or
Objective C applications, you

00:08:38.350 --> 00:08:41.200
get a nice, statically-typed
client library automatically

00:08:41.200 --> 00:08:42.600
generated for you.

00:08:42.600 --> 00:08:46.310
And the helper code that we're
writing works with the same

00:08:46.310 --> 00:08:50.020
library that you would use if
you were using those same

00:08:50.020 --> 00:08:51.050
other Google APIs.

00:08:51.050 --> 00:08:54.290
So if you're writing an app that
uses the Google+ API and

00:08:54.290 --> 00:08:57.360
whatever API it is that
you've built, you

00:08:57.360 --> 00:08:58.610
have one client library.

00:08:58.610 --> 00:09:00.470
So you're not worrying about
bloating all of your

00:09:00.470 --> 00:09:03.170
applications because you've
got one client library for

00:09:03.170 --> 00:09:04.150
this feature and another client

00:09:04.150 --> 00:09:04.850
library for this feature.

00:09:04.850 --> 00:09:06.850
It's the same client library.

00:09:06.850 --> 00:09:09.170
And then we also have a
JavaScript client library that

00:09:09.170 --> 00:09:12.850
you can use, of course, in
the web browser, and I'll

00:09:12.850 --> 00:09:16.060
demonstrate all of these
in a couple minutes.

00:09:16.060 --> 00:09:20.440
OAuth 2 is built right into the
product, so if you want to

00:09:20.440 --> 00:09:22.290
do authentication, it's really

00:09:22.290 --> 00:09:23.920
straightforward to set that up.

00:09:23.920 --> 00:09:26.930
You can log into your
applications using Google

00:09:26.930 --> 00:09:28.810
Account, and I'll actually talk
a little bit more about

00:09:28.810 --> 00:09:31.260
this later as well.

00:09:31.260 --> 00:09:32.360
And then we have some
great tooling

00:09:32.360 --> 00:09:34.220
support as part of Endpoints.

00:09:34.220 --> 00:09:37.420
So if any of you have used the
Google plug-in for Eclipse,

00:09:37.420 --> 00:09:41.880
we've extended that with the App
Engine features and also

00:09:41.880 --> 00:09:44.610
Endpoints features to make
it really easy to develop

00:09:44.610 --> 00:09:49.330
Endpoints APIs within the
development environment that

00:09:49.330 --> 00:09:50.450
you're familiar with.

00:09:50.450 --> 00:09:52.930
And of course, because this is
part of the App Engine SDK,

00:09:52.930 --> 00:09:55.230
you get the same local
development experience that

00:09:55.230 --> 00:09:57.410
you get with the rest of the
product, and you'll see that

00:09:57.410 --> 00:09:59.500
in a moment as well.

00:09:59.500 --> 00:10:01.420
So Endpoints, how
does it work?

00:10:01.420 --> 00:10:04.460
So you basically start out
writing backend code.

00:10:04.460 --> 00:10:06.500
All of my slides today are going
to be demonstrating the

00:10:06.500 --> 00:10:09.410
backends in Java, but rest
assured all this works and

00:10:09.410 --> 00:10:10.450
Python as well.

00:10:10.450 --> 00:10:13.050
And I've got lots of sample code
at the end of the slide

00:10:13.050 --> 00:10:16.080
deck that you can check
out later on.

00:10:16.080 --> 00:10:20.680
So we've got a very simple class
here that represents a

00:10:20.680 --> 00:10:25.460
game and we're taking
in a board object.

00:10:25.460 --> 00:10:27.820
We're going to update that
and send it back.

00:10:27.820 --> 00:10:29.420
Very straightforward code.

00:10:29.420 --> 00:10:31.990
So let's turn this
into an API.

00:10:31.990 --> 00:10:35.030
So the first thing we have
to do is, we add this API

00:10:35.030 --> 00:10:36.560
annotation here.

00:10:36.560 --> 00:10:37.970
And then we can basically
stop.

00:10:37.970 --> 00:10:42.350
This is all we actually have to
do in order to get an API.

00:10:42.350 --> 00:10:45.750
Everything else is done by our
SDK and the tooling that we

00:10:45.750 --> 00:10:48.690
provided, and you can get
an API from this.

00:10:48.690 --> 00:10:52.490
So this will turn it into
something like game Endpoint.

00:10:52.490 --> 00:10:55.590
By default, it will have one
method update game that takes

00:10:55.590 --> 00:10:56.980
one of these board objects.

00:10:56.980 --> 00:10:59.490
And there's certainly ways you
can customize this, which I'll

00:10:59.490 --> 00:11:02.580
talk about as I do
some live coding.

00:11:02.580 --> 00:11:04.240
But this is the bare
minimum you need in

00:11:04.240 --> 00:11:05.100
order to get an API.

00:11:05.100 --> 00:11:07.840
So it's very simple
to start with.

00:11:07.840 --> 00:11:10.630
So once you have this, we've
got some tooling

00:11:10.630 --> 00:11:11.500
that I talked about.

00:11:11.500 --> 00:11:14.070
This is basically a command that
you'd run on the command

00:11:14.070 --> 00:11:17.160
line that gives you your
Objective C client library.

00:11:17.160 --> 00:11:18.740
Generates a bunch of
files for you.

00:11:18.740 --> 00:11:21.350
Drop those into Xcode, and then
you can start consuming

00:11:21.350 --> 00:11:23.300
them with some lines
like this.

00:11:23.300 --> 00:11:26.540
So it's just a couple lines
of code in order to make a

00:11:26.540 --> 00:11:30.510
request to your API that's
running on App Engine.

00:11:30.510 --> 00:11:33.270
So maybe I've convinced some of
you that it's pretty neat,

00:11:33.270 --> 00:11:35.400
but I'm sure that there are
folks out there who'd really

00:11:35.400 --> 00:11:36.140
like to see a demo.

00:11:36.140 --> 00:11:41.767
So let's switch over
into Eclipse.

00:11:44.870 --> 00:11:45.240
All right.

00:11:45.240 --> 00:11:49.740
So I have this really simple
application, tic-tac-toe, that

00:11:49.740 --> 00:11:52.920
I have running on my
local machine here.

00:11:52.920 --> 00:11:57.490
Actually, all start out with
a demo of this app.

00:11:57.490 --> 00:11:59.875
So like I said very, very
simple application.

00:11:59.875 --> 00:12:01.520
This is definitely going
to make millions

00:12:01.520 --> 00:12:03.290
and millions of dollars.

00:12:03.290 --> 00:12:05.980
So you can see here I've got
this really simple board, and

00:12:05.980 --> 00:12:09.030
if I click on any of these
buttons, each time I hit one

00:12:09.030 --> 00:12:10.790
of these buttons, this is taking
the current state of

00:12:10.790 --> 00:12:13.960
the board, sending it off
to my app Engine server.

00:12:13.960 --> 00:12:17.400
The computer is filling in a
move, sending it back to me,

00:12:17.400 --> 00:12:19.450
and then when I win, because
the computer is not very

00:12:19.450 --> 00:12:22.410
smart, it's recording my score
for all posterity and then

00:12:22.410 --> 00:12:24.110
refreshing this list
at the bottom.

00:12:24.110 --> 00:12:27.810
So let's see how we'd build
something like that.

00:12:27.810 --> 00:12:30.310
So we start out with the
App Engine backend.

00:12:30.310 --> 00:12:32.750
So this is the code that
I've written here.

00:12:32.750 --> 00:12:35.230
So I have two types of
primitive objects.

00:12:35.230 --> 00:12:39.140
The first one is a board object,
very, very simple, and

00:12:39.140 --> 00:12:42.080
the second one that I'm looking
at here is the score

00:12:42.080 --> 00:12:44.540
object, which basically keeps
track of all the games that I

00:12:44.540 --> 00:12:46.390
previously played.

00:12:46.390 --> 00:12:49.040
So if you're familiar with App
Engine, you might recognize

00:12:49.040 --> 00:12:52.610
this actually or other
Java environments.

00:12:52.610 --> 00:12:57.030
You might recognize this as a
JDO class, so nothing changes

00:12:57.030 --> 00:12:57.550
about this.

00:12:57.550 --> 00:13:01.590
This is the same type of JDO
object that you would write in

00:13:01.590 --> 00:13:03.710
other environments or with
another part of App Engine

00:13:03.710 --> 00:13:05.690
that don't use Endpoints.

00:13:05.690 --> 00:13:07.750
So there's no changes
to this code it all.

00:13:07.750 --> 00:13:11.070
It just exists as
it did before.

00:13:11.070 --> 00:13:14.310
And then we have an Endpoint
class that basically reads and

00:13:14.310 --> 00:13:18.120
writes these objects and sends
them over the wire.

00:13:18.120 --> 00:13:20.700
So the first thing we want to
do if we want to make this

00:13:20.700 --> 00:13:25.200
class an endpoint, is we will
add this API annotation as I

00:13:25.200 --> 00:13:27.865
said before to make
sure we import the

00:13:27.865 --> 00:13:29.320
right packages here.

00:13:29.320 --> 00:13:32.630
And so what we're going to do
is we could just stop with

00:13:32.630 --> 00:13:35.080
this, and we would
have an API.

00:13:35.080 --> 00:13:37.350
But we'd like to customize
it a little bit.

00:13:37.350 --> 00:13:39.850
So what we're going to do first
is we're given a name.

00:13:39.850 --> 00:13:42.190
I can also do things
like specify what

00:13:42.190 --> 00:13:43.540
version I want to run.

00:13:43.540 --> 00:13:45.450
If you want to have multiple
versions of an API going at

00:13:45.450 --> 00:13:46.670
the same time, that's
totally fine.

00:13:46.670 --> 00:13:48.420
You can totally do that.

00:13:48.420 --> 00:13:51.880
By default, this will give me
V1 of the API, which seems

00:13:51.880 --> 00:13:54.330
perfectly fine for
demo purposes.

00:13:54.330 --> 00:13:58.290
And then by adding this
annotation, all of these other

00:13:58.290 --> 00:14:02.920
methods are automatically going
to be added to the API

00:14:02.920 --> 00:14:03.380
that I built.

00:14:03.380 --> 00:14:06.930
So I'll have a getMethod and
I'll have a listMethod that

00:14:06.930 --> 00:14:08.875
returns all the previous
scores that

00:14:08.875 --> 00:14:11.230
I've saved in my datastore.

00:14:11.230 --> 00:14:15.620
But we also have this other
endpoint or this other API as

00:14:15.620 --> 00:14:17.340
part of the same tic-tac-toe
API.

00:14:17.340 --> 00:14:20.230
This is a board endpoint that
allows me to interact with the

00:14:20.230 --> 00:14:21.410
current state of the board.

00:14:21.410 --> 00:14:24.890
So rather than having all of
these things sort of munged

00:14:24.890 --> 00:14:28.840
into one name space, I'm going
to give these custom names.

00:14:28.840 --> 00:14:31.660
So my API method now
will be scores.get

00:14:31.660 --> 00:14:34.920
rather than just GET.

00:14:34.920 --> 00:14:37.370
And you'll see the importance of
that a little bit later as

00:14:37.370 --> 00:14:40.110
I actually demonstrate how
to consume these APIs.

00:14:40.110 --> 00:14:42.600
So make sure we're importing
the right package there.

00:14:42.600 --> 00:14:45.390
And then we'll do the same
process for these other

00:14:45.390 --> 00:14:48.790
methods, so we've scores.list
and then scores.insert.

00:14:51.690 --> 00:14:55.550
And while I'm messing around
with this code, one quick note

00:14:55.550 --> 00:14:57.770
on how to do the authentication
piece here.

00:14:57.770 --> 00:15:00.530
So for the backend, this is
actually very simple.

00:15:00.530 --> 00:15:04.210
If I wanted to figure out who
the current user was making

00:15:04.210 --> 00:15:08.060
one of these requests, I just
add the user parameter into my

00:15:08.060 --> 00:15:09.820
method signature.

00:15:09.820 --> 00:15:12.470
There's one other thing that I
would need to do at the top

00:15:12.470 --> 00:15:15.740
here in this annotation, but
this is basically it.

00:15:15.740 --> 00:15:19.100
So I have this user object,
which represents the Google

00:15:19.100 --> 00:15:22.400
account that is making
the API request.

00:15:22.400 --> 00:15:24.920
And if you're familiar with App
Engine, this is the same

00:15:24.920 --> 00:15:29.340
user object calling
google.appengine.api.users

00:15:29.340 --> 00:15:31.060
that you would see
in other places.

00:15:31.060 --> 00:15:33.300
So if you're doing App Engine
sign in and other parts of

00:15:33.300 --> 00:15:35.960
your application, then you want
to compare those user

00:15:35.960 --> 00:15:38.090
objects to the ones you're
getting from Endpoints,

00:15:38.090 --> 00:15:39.300
they're exactly the same.

00:15:39.300 --> 00:15:42.980
It's very, very simple to OAuth
support into these APIs,

00:15:42.980 --> 00:15:45.410
which is not something that you
can usually say when it

00:15:45.410 --> 00:15:47.450
comes to OAuth.

00:15:47.450 --> 00:15:49.210
So we'll leave this
out for now.

00:15:49.210 --> 00:15:51.400
We'll talk about that a
little bit more later.

00:15:51.400 --> 00:15:55.820
So at this point, I basically
have my API already running.

00:15:55.820 --> 00:15:59.980
So what we'll do is we'll deploy
this to App Engine.

00:16:09.460 --> 00:16:10.980
Take a quick sip of my drink.

00:16:14.510 --> 00:16:14.780
All right.

00:16:14.780 --> 00:16:16.460
Now my API is serving.

00:16:16.460 --> 00:16:17.040
Excellent.

00:16:17.040 --> 00:16:18.990
So let's take a look at it.

00:16:18.990 --> 00:16:21.310
So I had this URL here running
on local host.

00:16:21.310 --> 00:16:25.480
We can actually switch over
to the one that's

00:16:25.480 --> 00:16:27.730
running on LIVE server.

00:16:27.730 --> 00:16:33.060
And the first thing that we're
going to look at is a

00:16:33.060 --> 00:16:37.120
discovery document, and this is
basically, a description of

00:16:37.120 --> 00:16:38.340
the API that I just wrote.

00:16:38.340 --> 00:16:40.420
And this isn't necessarily
intended for human

00:16:40.420 --> 00:16:41.270
consumption.

00:16:41.270 --> 00:16:43.720
It's mostly intended for
other parts of the API

00:16:43.720 --> 00:16:46.480
infrastructure to give us
things like the API's

00:16:46.480 --> 00:16:49.120
Explorer, which I'll show you in
a minute or for generating

00:16:49.120 --> 00:16:50.140
client libraries.

00:16:50.140 --> 00:16:54.800
So this discovery document
describes the state of my API.

00:16:54.800 --> 00:16:57.770
So it's the types of things
like, what objects am I my

00:16:57.770 --> 00:17:00.030
accepting and returning.

00:17:00.030 --> 00:17:06.500
What are the methods on my
API that I can call,

00:17:06.500 --> 00:17:07.800
and things like that.

00:17:07.800 --> 00:17:12.829
So if I have a URL parameter,
it shows up in here.

00:17:12.829 --> 00:17:17.349
If I have things that show up
in the body, like I want to

00:17:17.349 --> 00:17:19.339
insert a new score, that
shows up in the body.

00:17:19.339 --> 00:17:22.150
That you can see in here.

00:17:22.150 --> 00:17:27.500
And so with things like this,
I can then go into the API's

00:17:27.500 --> 00:17:31.460
Explorer and actually I can
do this quick link.

00:17:39.820 --> 00:17:44.060
And this will load, basically
allow me to explore all the

00:17:44.060 --> 00:17:46.520
APIs that I've deployed on to
my App Engine application so

00:17:46.520 --> 00:17:51.085
if I were to strip this off,
this would show me all of

00:17:51.085 --> 00:17:54.030
Google's APIs and we provide
this nice little shortcuts so

00:17:54.030 --> 00:17:57.150
that you can just filter down
to the APIs that you've

00:17:57.150 --> 00:17:58.770
deployed on your application.

00:17:58.770 --> 00:18:01.400
And so we've got the tic-tac-toe
API here.

00:18:01.400 --> 00:18:05.630
And so we can try things like
get the current move or get a

00:18:05.630 --> 00:18:08.280
computer's move given our
current state of the board.

00:18:08.280 --> 00:18:11.560
So the way that we represent
the board in this game is a

00:18:11.560 --> 00:18:14.660
one-dimensional array of
dashes, X's and O's.

00:18:14.660 --> 00:18:19.250
So this is basically playing an
X in the center square, so

00:18:19.250 --> 00:18:22.280
we'll send this off
to the computer.

00:18:22.280 --> 00:18:25.150
And we can see here this is
basically what our requests

00:18:25.150 --> 00:18:28.590
looks like, typical
format that you

00:18:28.590 --> 00:18:29.550
would be familiar with.

00:18:29.550 --> 00:18:32.180
So we're sending JSON from
the API's Explorer.

00:18:32.180 --> 00:18:34.150
This is what the body looks
like, and then we're getting

00:18:34.150 --> 00:18:39.100
back this response which looks
like a move of a zero in the

00:18:39.100 --> 00:18:41.380
top right corner.

00:18:41.380 --> 00:18:43.560
So the computer is
not very smart.

00:18:43.560 --> 00:18:44.935
It will just play randomly.

00:18:44.935 --> 00:18:47.250
If I keep running this,
it will keep

00:18:47.250 --> 00:18:48.900
generating new results.

00:18:48.900 --> 00:18:55.040
But that basically gives you an
idea of what the API call

00:18:55.040 --> 00:18:57.260
convention looks like and what
the responses would look like.

00:18:57.260 --> 00:18:59.790
So we could also try some of the
other things too so I can

00:18:59.790 --> 00:19:03.520
get a list of all the
previously-played games.

00:19:03.520 --> 00:19:07.400
And this will return this very
simple format, what the

00:19:07.400 --> 00:19:09.790
outcome was, when it was played,
things like that of

00:19:09.790 --> 00:19:12.170
all the previous games
that people played.

00:19:12.170 --> 00:19:13.420
Tic-tac-toe.

00:19:15.260 --> 00:19:19.970
And from this, it's actually
really simple to go into a

00:19:19.970 --> 00:19:21.530
very simple JavaScript client.

00:19:21.530 --> 00:19:22.950
So I have this application
running

00:19:22.950 --> 00:19:25.410
here live on our server.

00:19:25.410 --> 00:19:28.410
This is a very simple UI very
much like the Android one.

00:19:28.410 --> 00:19:31.430
Every time I make one of these
moves, it's sending a request

00:19:31.430 --> 00:19:36.320
off to my backend and
updating the game.

00:19:36.320 --> 00:19:38.910
And so if you actually were to
look at these JavaScript

00:19:38.910 --> 00:19:41.870
console, which hopefully you
guys can see here on the

00:19:41.870 --> 00:19:47.590
screen, I can play again.

00:19:47.590 --> 00:19:50.360
And you can see these requests
going off to my

00:19:50.360 --> 00:19:55.410
backend as I play.

00:19:55.410 --> 00:20:03.180
And my favorite thing is that
you can make calls to the

00:20:03.180 --> 00:20:05.410
client library right from
within the console, and

00:20:05.410 --> 00:20:07.960
because Chrome has auto
complete, you can actually

00:20:07.960 --> 00:20:12.280
experiment with the APIs
pretty easily.

00:20:12.280 --> 00:20:15.580
So you've got GAPI Client, which
is the code that you

00:20:15.580 --> 00:20:17.490
always see in a client
library.

00:20:17.490 --> 00:20:20.600
And then we're interesting cal
the tic-tac-toe API and we

00:20:20.600 --> 00:20:24.580
have the board method, and we
have the scores method.

00:20:24.580 --> 00:20:27.500
So let's call board.

00:20:27.500 --> 00:20:30.480
And we can call getMove.

00:20:30.480 --> 00:20:37.730
And we'll pass in state and
this is JavaScript, so of

00:20:37.730 --> 00:20:38.980
course, we need to callback.

00:20:41.730 --> 00:20:43.030
And we will log it.

00:20:47.150 --> 00:20:47.500
All right.

00:20:47.500 --> 00:20:53.030
So this is basically
the result--

00:20:53.030 --> 00:20:55.630
maybe I have a typo in my--

00:20:55.630 --> 00:20:56.880
Yes.

00:20:59.379 --> 00:21:01.861
There we go.

00:21:01.861 --> 00:21:02.410
All right.

00:21:02.410 --> 00:21:04.700
So we have this object that we
get back, and inside of the

00:21:04.700 --> 00:21:06.940
result is the currently-updated

00:21:06.940 --> 00:21:08.260
state of the board.

00:21:08.260 --> 00:21:10.950
So we can then consume that
within our application.

00:21:10.950 --> 00:21:12.970
Pretty simple.

00:21:12.970 --> 00:21:13.160
All right.

00:21:13.160 --> 00:21:17.830
So this sort of demonstrates
the Java backend and the

00:21:17.830 --> 00:21:20.570
JavaScript client case, but
you're probably also

00:21:20.570 --> 00:21:23.170
interested in building native
mobile applications as well.

00:21:23.170 --> 00:21:25.390
So let's jump back into Eclipse,
and we can see how

00:21:25.390 --> 00:21:28.090
you might consume one
of these clients

00:21:28.090 --> 00:21:30.530
or APIs within Android.

00:21:30.530 --> 00:21:33.600
So the first thing that I would
do within my Eclipse

00:21:33.600 --> 00:21:37.160
project is I would actually go
to the Google menu here, and I

00:21:37.160 --> 00:21:40.390
would generate client or Cloud
Endpoint client library.

00:21:40.390 --> 00:21:43.720
And so what this will do is, it
will send off a request to

00:21:43.720 --> 00:21:47.330
generate client libraries for
the API that I've just

00:21:47.330 --> 00:21:47.930
constructed.

00:21:47.930 --> 00:21:50.630
This will make a whole bunch
of network requests and

00:21:50.630 --> 00:21:53.990
basically download a zip file
for you, which you can copy

00:21:53.990 --> 00:21:55.060
into your project.

00:21:55.060 --> 00:21:57.350
Rather than demoing that, I
actually have an application

00:21:57.350 --> 00:21:59.650
already configured with the
appropriate files, which you

00:21:59.650 --> 00:22:02.540
see here on the left.

00:22:02.540 --> 00:22:06.700
And I have this activity class,
which I can use to

00:22:06.700 --> 00:22:08.640
interact with the API.

00:22:08.640 --> 00:22:11.590
So I've already done all the
work for generating that

00:22:11.590 --> 00:22:14.270
really simple UI the
you saw previously.

00:22:14.270 --> 00:22:16.900
So the thing that we're going
to add to this is the logic

00:22:16.900 --> 00:22:19.230
that allows us to make requests
over the network.

00:22:19.230 --> 00:22:21.380
So we have three important
things to call.

00:22:21.380 --> 00:22:24.410
So we have getTheComputerMove,
which happens every time I hit

00:22:24.410 --> 00:22:29.100
one of the squares and that
spawns an asynchronous task.

00:22:29.100 --> 00:22:31.010
We don't want to block
the UI thread.

00:22:31.010 --> 00:22:33.210
So the first thing that we're
going to do here is we're

00:22:33.210 --> 00:22:37.390
going to get a new board object
by calling service,

00:22:37.390 --> 00:22:40.340
which is basically an object
that we used to call our APIs.

00:22:40.340 --> 00:22:43.230
We're going to call board just
like we did in the JavaScript

00:22:43.230 --> 00:22:45.520
case because that's
the resource that

00:22:45.520 --> 00:22:46.380
we're interested in.

00:22:46.380 --> 00:22:50.910
And we're going to call getMove,
which is the method

00:22:50.910 --> 00:22:51.440
that we want to call.

00:22:51.440 --> 00:22:54.010
And we're going to pass
in our board object.

00:22:54.010 --> 00:22:57.560
So once we have this, we can
return it and we have this

00:22:57.560 --> 00:22:59.730
onPostExecute method.

00:22:59.730 --> 00:23:03.040
This is all standard Android
development experience here,

00:23:03.040 --> 00:23:07.980
which will check to see if
anyone's won and then update

00:23:07.980 --> 00:23:11.220
the state of the board, and if
no one has won, then it will

00:23:11.220 --> 00:23:13.580
go back to waiting
for the player.

00:23:13.580 --> 00:23:18.260
So if someone does win or lose
or tie, we will handle that

00:23:18.260 --> 00:23:20.940
case by spawning a different
asynchronous task.

00:23:20.940 --> 00:23:22.730
And this one will send
the result of the

00:23:22.730 --> 00:23:23.980
game off to the server.

00:23:23.980 --> 00:23:27.270
So here we have service.scores,
because scores

00:23:27.270 --> 00:23:31.190
is the resource we're interested
in, insert, which

00:23:31.190 --> 00:23:35.040
basically makes a request to
add a new score to the

00:23:35.040 --> 00:23:37.780
datastore, and then we'll
send that score

00:23:37.780 --> 00:23:39.120
as the subject here.

00:23:39.120 --> 00:23:43.450
We execute that, and
then we're done.

00:23:43.450 --> 00:23:46.590
And then finally, we have this
method which will get us the

00:23:46.590 --> 00:23:48.230
list of previously-played
games.

00:23:48.230 --> 00:23:50.530
So we'll do this one the
application loads or if we're

00:23:50.530 --> 00:23:52.790
interested in updating that list
of scores that was at the

00:23:52.790 --> 00:23:55.710
bottom of the game that
I showed you.

00:23:55.710 --> 00:23:59.980
And so to do that, again, this
is all very, very simple code,

00:23:59.980 --> 00:24:03.920
very similar in style across all
these different API calls.

00:24:03.920 --> 00:24:07.020
So we'll call
service.scores.list, and this

00:24:07.020 --> 00:24:10.020
will give us back a list of
scores, which we can then jump

00:24:10.020 --> 00:24:12.830
into a UI element within our
Android application.

00:24:12.830 --> 00:24:16.180
So now that I've done all of
that modification, we can run

00:24:16.180 --> 00:24:19.992
this again inside
of the emulator.

00:24:19.992 --> 00:24:21.940
Yes, this is the device
I'd like to use.

00:24:29.700 --> 00:24:30.680
All right.

00:24:30.680 --> 00:24:32.890
So tic-tac-toe is loaded.

00:24:32.890 --> 00:24:36.640
And like before, you can see
it's logging all these things

00:24:36.640 --> 00:24:37.890
on the bottom.

00:24:41.870 --> 00:24:44.060
All of my idle instances
appeared to have died.

00:24:44.060 --> 00:24:44.470
Yes.

00:24:44.470 --> 00:24:44.777
All right.

00:24:44.777 --> 00:24:45.730
So there we go.

00:24:45.730 --> 00:24:48.860
To make your requests, I can
hit these buttons here and

00:24:48.860 --> 00:24:50.370
play the game against
the computer.

00:24:50.370 --> 00:24:52.850
Again, it's still not
very smart, and so

00:24:52.850 --> 00:24:53.640
of course, I win.

00:24:53.640 --> 00:24:54.820
But there you have it.

00:24:54.820 --> 00:24:56.750
Pretty straightforward.

00:24:56.750 --> 00:24:58.020
So that covers the
Android case.

00:24:58.020 --> 00:25:03.060
And there is also iOS, so we
will jump over into actually

00:25:03.060 --> 00:25:05.070
first, the command line.

00:25:05.070 --> 00:25:09.460
So if you want to generate your
client iOS libraries, we

00:25:09.460 --> 00:25:11.700
have this nice script, the
service generator, which will

00:25:11.700 --> 00:25:15.290
generate the API library for you
and I can run this, point

00:25:15.290 --> 00:25:18.400
it to the output of my--

00:25:18.400 --> 00:25:20.080
basically, the discovery
document that I showed you

00:25:20.080 --> 00:25:23.380
before and will generate all
these files into this nice

00:25:23.380 --> 00:25:27.000
folder on the desktop here,
which I can then drag into my

00:25:27.000 --> 00:25:28.350
Xcode application.

00:25:28.350 --> 00:25:30.100
I've already done that
previously with

00:25:30.100 --> 00:25:30.860
this project here.

00:25:30.860 --> 00:25:34.120
You can see this set of files.

00:25:34.120 --> 00:25:36.720
And then we have a very similar
development experience

00:25:36.720 --> 00:25:39.300
to what we just did on Android
where we basically have a

00:25:39.300 --> 00:25:43.500
service object and then we're
making calls to our API.

00:25:43.500 --> 00:25:45.250
So you can see here,
when we're getting

00:25:45.250 --> 00:25:46.840
the computer move.

00:25:46.840 --> 00:25:50.670
We have this method which
queries the tic-tac-toe API.

00:25:50.670 --> 00:25:55.340
It queries for board, calling
getMove, and passing in an

00:25:55.340 --> 00:25:58.940
object, which is this
board object here.

00:25:58.940 --> 00:26:03.390
When we are interested in saving
the previous game,

00:26:03.390 --> 00:26:05.300
again, same type of calling
convention.

00:26:05.300 --> 00:26:08.400
We're querying for scores, we're
recalling Insert, and

00:26:08.400 --> 00:26:12.010
we're passing in an object
which is the score.

00:26:12.010 --> 00:26:15.310
And then when we're querying
the scores, we have

00:26:15.310 --> 00:26:19.470
queryForScoresList, list being
the method that we're calling.

00:26:19.470 --> 00:26:22.740
And then this will generate a
list of scores which we can

00:26:22.740 --> 00:26:24.410
then throw into a UI element.

00:26:24.410 --> 00:26:27.468
So let's run this now.

00:26:27.468 --> 00:26:31.400
And again, same sort of lame UI
that I have in the Android

00:26:31.400 --> 00:26:35.270
application, and I can click on
these squares, play against

00:26:35.270 --> 00:26:40.050
the computer, I win, it updates
my score, and so on.

00:26:40.050 --> 00:26:42.270
Now, to show that there's no
smoke and mirrors happening

00:26:42.270 --> 00:26:45.290
behind the scenes, let's
jump over to the App

00:26:45.290 --> 00:26:46.310
Engine admin console.

00:26:46.310 --> 00:26:49.200
And what this will demonstrate
is, you can actually look at

00:26:49.200 --> 00:26:51.750
the logs for each of the
requests that just came from

00:26:51.750 --> 00:26:53.250
all of these different
clients.

00:26:53.250 --> 00:26:55.670
So we can start here
at the bottom.

00:26:55.670 --> 00:26:58.640
These are my requests
coming from Chrome.

00:26:58.640 --> 00:27:03.110
So you can see over here on
the right side Chrome 25.

00:27:03.110 --> 00:27:05.480
Then in the middle here, we have
requests coming from the

00:27:05.480 --> 00:27:07.200
Google HTTP Java client.

00:27:07.200 --> 00:27:09.710
This is our Android
client library.

00:27:09.710 --> 00:27:12.810
And then finally, at the top
here, we have requests coming

00:27:12.810 --> 00:27:16.030
from the Google API Objective C
client library, which is, of

00:27:16.030 --> 00:27:19.900
course, the application running
on the iOS simulator.

00:27:19.900 --> 00:27:26.100
So you can see it's pretty
straightforward to build an

00:27:26.100 --> 00:27:29.780
application, an API to power
that application, and then

00:27:29.780 --> 00:27:33.670
connect it to all three of
these types of devices.

00:27:33.670 --> 00:27:40.260
So with that, you're probably
interested in giving it a try.

00:27:40.260 --> 00:27:43.310
So I have another QR code for
you if you'd like to grab that

00:27:43.310 --> 00:27:45.420
and play your own game
of tic-tac-toe

00:27:45.420 --> 00:27:46.670
feel free to do so.

00:27:53.280 --> 00:27:55.360
And if anyone doesn't get a
chance to grab this, I have

00:27:55.360 --> 00:28:00.230
links to all of the demo
applications that I've just

00:28:00.230 --> 00:28:04.320
showed you, and you can feel
free to download those and run

00:28:04.320 --> 00:28:07.910
them yourself when you're
back at home later.

00:28:10.430 --> 00:28:13.295
See a couple devices
still in the air.

00:28:21.860 --> 00:28:22.450
Going once.

00:28:22.450 --> 00:28:23.700
Going twice.

00:28:26.800 --> 00:28:27.490
Sold.

00:28:27.490 --> 00:28:28.510
All right.

00:28:28.510 --> 00:28:31.390
So the last piece that we're
going to talk about today is

00:28:31.390 --> 00:28:32.460
adding authentication.

00:28:32.460 --> 00:28:35.590
So adding authentication, as I
said before, it's relatively

00:28:35.590 --> 00:28:39.040
straightforward, but it's a
little bit difficult for me to

00:28:39.040 --> 00:28:41.650
demo, so I'm going to walk
through the slides, and if

00:28:41.650 --> 00:28:44.920
anyone's interested in trying
this, we have all the sample

00:28:44.920 --> 00:28:49.120
code provided at the end of the
deck, which you can then

00:28:49.120 --> 00:28:51.600
download and compile at home.

00:28:51.600 --> 00:28:53.280
So we're going to talk
particularly about the

00:28:53.280 --> 00:28:55.070
JavaScript case.

00:28:55.070 --> 00:28:58.470
So we have this application
backend that I made.

00:28:58.470 --> 00:29:01.230
We have this JavaScript client
that I demonstrated before.

00:29:01.230 --> 00:29:05.190
We're going to see what it takes
to add OAuth 2 into that

00:29:05.190 --> 00:29:05.900
application.

00:29:05.900 --> 00:29:08.170
So the first thing that we
need to do is we need to

00:29:08.170 --> 00:29:11.150
modify our API annotation.

00:29:11.150 --> 00:29:14.810
And this is basically
a one-line change.

00:29:14.810 --> 00:29:17.910
It's really a couple lines here
because I've abstracted

00:29:17.910 --> 00:29:20.110
out these client IDs into
their own class.

00:29:20.110 --> 00:29:22.480
it could be one line if
you wanted it to be.

00:29:22.480 --> 00:29:26.180
So this is the client ID
representing our JavaScript

00:29:26.180 --> 00:29:27.200
application.

00:29:27.200 --> 00:29:29.170
So if you're familiar with
OAuth 2, you're probably

00:29:29.170 --> 00:29:31.540
familiar with client IDs.

00:29:31.540 --> 00:29:34.060
If not, they're basically a
way that you can uniquely

00:29:34.060 --> 00:29:38.190
identify an application
running code.

00:29:38.190 --> 00:29:41.530
So here we're registering for
a client ID inside of the

00:29:41.530 --> 00:29:43.070
Google API's console.

00:29:43.070 --> 00:29:45.890
If you're, again, familiar with
other Google API's, it's

00:29:45.890 --> 00:29:49.370
exactly the same process you
would do in order to use any

00:29:49.370 --> 00:29:51.250
of those APIs.

00:29:51.250 --> 00:29:53.190
And this will give us basically
a string that

00:29:53.190 --> 00:29:56.140
represents our app, which we
can paste into this code.

00:29:56.140 --> 00:30:00.510
And this will get sent along
with requests for OAuth tokens

00:30:00.510 --> 00:30:03.886
that come from this JavaScript
application.

00:30:03.886 --> 00:30:06.400
So now the next thing we need
to do is, we need to modify

00:30:06.400 --> 00:30:12.220
our backend to accept this user
object that we get from

00:30:12.220 --> 00:30:12.960
the client libraries.

00:30:12.960 --> 00:30:16.820
So the way we do that is we add
in this user object here

00:30:16.820 --> 00:30:18.570
as I demonstrated before
in the code.

00:30:18.570 --> 00:30:22.210
This will be populated
automatically with the Google

00:30:22.210 --> 00:30:26.100
account of the user who has
sent us an OAuth token.

00:30:26.100 --> 00:30:28.960
Or in the case where there's
no OAuth token, the user

00:30:28.960 --> 00:30:29.545
object will be null.

00:30:29.545 --> 00:30:31.990
And we can figure out what to
do in that case depending on

00:30:31.990 --> 00:30:33.020
the application.

00:30:33.020 --> 00:30:34.300
So let's assume it's not null.

00:30:34.300 --> 00:30:37.600
If it's not null, then we're
going to set the player of the

00:30:37.600 --> 00:30:40.240
game to be whoever it is
represented by the token.

00:30:40.240 --> 00:30:45.010
So this will give us nice per
user scores in our datastore.

00:30:45.010 --> 00:30:48.100
And then in the case where
there's no user present, we

00:30:48.100 --> 00:30:50.880
throw an OAuth request exception
basically saying,

00:30:50.880 --> 00:30:52.790
hey, you need to sign
in, otherwise, you

00:30:52.790 --> 00:30:54.260
can't use this API.

00:30:54.260 --> 00:30:57.280
And this will give us a nice
HTTP status code that we would

00:30:57.280 --> 00:31:01.360
expect when the user
has to sign in.

00:31:01.360 --> 00:31:02.860
So that's all you need
to do in the backend.

00:31:02.860 --> 00:31:06.580
You just redeploy, automatically
works, and then

00:31:06.580 --> 00:31:07.960
it's just updating
your client.

00:31:07.960 --> 00:31:12.160
So in the example I showed you,
we're loading one API,

00:31:12.160 --> 00:31:13.260
tic-tac-toe.

00:31:13.260 --> 00:31:15.030
In this updated case,
we're also going to

00:31:15.030 --> 00:31:17.670
load the OAuth 2 API.

00:31:17.670 --> 00:31:19.620
And then once both of these
are called, we're going to

00:31:19.620 --> 00:31:21.340
attempt to sign in the user.

00:31:21.340 --> 00:31:23.990
So in the case that the user
is already signed in in the

00:31:23.990 --> 00:31:27.190
past, this will automatically
work and you'll be thrown

00:31:27.190 --> 00:31:31.310
right into the execution of your
primary code within the

00:31:31.310 --> 00:31:32.540
application.

00:31:32.540 --> 00:31:35.120
In the case where the user
hasn't signed in, this won't

00:31:35.120 --> 00:31:38.870
do anything, and you will need
to catch that behavior later,

00:31:38.870 --> 00:31:42.110
and I'll show you the right
way to do that.

00:31:42.110 --> 00:31:45.800
So basically, the sign-in
method, we have the client ID

00:31:45.800 --> 00:31:47.060
that we just created.

00:31:47.060 --> 00:31:49.390
We have scope, so basically,
we're interested in the email

00:31:49.390 --> 00:31:52.630
scope of the user in this
particular case, and then we

00:31:52.630 --> 00:31:54.550
have the mode.

00:31:54.550 --> 00:31:57.170
Mode basically determines
whether or not we want to try

00:31:57.170 --> 00:31:59.600
to automatically sign
the user in.

00:31:59.600 --> 00:32:03.580
If we put mode to true, we will
not get a pop-up window.

00:32:03.580 --> 00:32:06.090
And so that basically means,
don't ask the user for

00:32:06.090 --> 00:32:06.830
permission.

00:32:06.830 --> 00:32:07.730
Try to sign them in.

00:32:07.730 --> 00:32:09.580
If they've already signed
in, this will succeed.

00:32:09.580 --> 00:32:12.280
If they haven't signed in,
nothing will happen.

00:32:12.280 --> 00:32:17.350
So the user always has to
explicitly grant permission to

00:32:17.350 --> 00:32:18.230
user applications.

00:32:18.230 --> 00:32:20.470
This isn't going to do anything
sneaky behind the

00:32:20.470 --> 00:32:24.550
scenes, but once they've granted
that access, you can

00:32:24.550 --> 00:32:27.100
automatically sign them
in in the future.

00:32:27.100 --> 00:32:29.520
And then we're basically getting
a token calling a

00:32:29.520 --> 00:32:35.250
callback, again, very familiar
for JavaScript developers.

00:32:35.250 --> 00:32:38.120
And so this method here is
basically boilerplate code

00:32:38.120 --> 00:32:40.660
that you could copy into
your own applications.

00:32:40.660 --> 00:32:43.630
This is going to make sure
that the tokens are being

00:32:43.630 --> 00:32:48.210
stored in the right place and
basically, make sure that the

00:32:48.210 --> 00:32:51.030
user has actually signed in and
you have access to their

00:32:51.030 --> 00:32:51.780
email address.

00:32:51.780 --> 00:32:56.450
Once that's true, you then
call your endpoints.

00:32:56.450 --> 00:32:58.270
And then the final thing
you need to add

00:32:58.270 --> 00:33:00.210
is a sign-in button.

00:33:00.210 --> 00:33:02.660
And so the purpose of the
sign-in button, of course, is

00:33:02.660 --> 00:33:05.050
for the user that has never
signed into your application

00:33:05.050 --> 00:33:09.000
to click the button triggering
the invocation of this method

00:33:09.000 --> 00:33:11.860
here which will then
display a pop up.

00:33:11.860 --> 00:33:15.765
And so the pop up can only
happen if it's in response to

00:33:15.765 --> 00:33:16.520
a user action.

00:33:16.520 --> 00:33:20.370
So pop-up blockers are in most
modern browsers at this point.

00:33:20.370 --> 00:33:23.710
If you tried to throw a pop-up
window without the user doing

00:33:23.710 --> 00:33:24.820
anything, it would be blocked.

00:33:24.820 --> 00:33:27.410
But because they've clicked this
button, the pop-up window

00:33:27.410 --> 00:33:30.610
will actually display.

00:33:30.610 --> 00:33:33.190
So if anyone wants to try the
authenticated version of

00:33:33.190 --> 00:33:36.640
tic-tac-toe, one last
QR code for you.

00:33:36.640 --> 00:33:38.410
I'll leave this up here for
a second, and then I will

00:33:38.410 --> 00:33:39.940
demonstrate application
myself.

00:33:39.940 --> 00:33:42.350
You could probably guess
how it will go.

00:33:52.250 --> 00:33:54.380
All right.

00:33:54.380 --> 00:33:55.750
Tic-tac-toe.

00:33:55.750 --> 00:33:57.240
Let's sign in.

00:33:57.240 --> 00:33:59.280
So we hit this button.

00:33:59.280 --> 00:34:02.665
I'm already signed into my
Google account in other tabs,

00:34:02.665 --> 00:34:05.420
so there's no sign-in process
that I have to

00:34:05.420 --> 00:34:06.205
go through for that.

00:34:06.205 --> 00:34:08.590
You can see this is my test
account from the corner.

00:34:08.590 --> 00:34:11.100
So basically, the application
wants to

00:34:11.100 --> 00:34:12.239
know who I am on Google.

00:34:12.239 --> 00:34:17.870
That's code for uniquely
identify your Google account.

00:34:17.870 --> 00:34:20.610
And because they're going to
give me a user object with an

00:34:20.610 --> 00:34:23.500
App Engine, that also gives
access to the email address.

00:34:23.500 --> 00:34:25.920
So these are typical permissions
that you would see

00:34:25.920 --> 00:34:28.340
within other App Engine
applications.

00:34:28.340 --> 00:34:30.290
So that sounds reasonable
to me.

00:34:30.290 --> 00:34:31.739
So I'll access.

00:34:31.739 --> 00:34:34.440
I click the button, and
boom, I'm signed in.

00:34:34.440 --> 00:34:36.260
If we go to the bottom, I
haven't played any games

00:34:36.260 --> 00:34:38.790
previously, so we can
start playing here.

00:34:41.580 --> 00:34:42.170
I win.

00:34:42.170 --> 00:34:42.810
Surprise.

00:34:42.810 --> 00:34:44.389
And my high score
is now saved.

00:34:44.389 --> 00:34:48.840
But if I were to reload this,
I'm automatically sign in, and

00:34:48.840 --> 00:34:51.760
the games that I've played, only
I've played, are the ones

00:34:51.760 --> 00:34:52.860
that show up at the bottom.

00:34:52.860 --> 00:34:55.260
I'm sure some of you out there
have won your own games of

00:34:55.260 --> 00:34:59.000
tic-tac-toe, and they're not
basically polluting the list

00:34:59.000 --> 00:35:02.470
of high scores that I want
to see for myself.

00:35:02.470 --> 00:35:03.630
So that's pretty much it.

00:35:03.630 --> 00:35:09.200
So if anyone's curious how to
build their own APIs, we've

00:35:09.200 --> 00:35:12.200
got links here to the Endpoints
documentation and

00:35:12.200 --> 00:35:15.660
then we also have full sample
code for Java Backend, which

00:35:15.660 --> 00:35:18.610
includes this JavaScript
example, and then Android and

00:35:18.610 --> 00:35:20.370
iOS clients.

00:35:20.370 --> 00:35:22.000
And if there's Python developers
out there, we also

00:35:22.000 --> 00:35:27.920
have a parallel example for
building this with Python too.

00:35:27.920 --> 00:35:29.050
So that's it.

00:35:29.050 --> 00:35:30.980
So if anyone has any
questions, I'm

00:35:30.980 --> 00:35:32.230
happy to take them.

00:35:34.816 --> 00:35:36.304
Yes.

00:35:36.304 --> 00:35:37.554
AUDIENCE: [INAUDIBLE].

00:35:39.600 --> 00:35:41.450
DAN HOLEVOET: You mean within
Endpoints or on

00:35:41.450 --> 00:35:42.510
App Engine in general?

00:35:42.510 --> 00:35:44.060
AUDIENCE: [INAUDIBLE].

00:35:44.060 --> 00:35:45.445
DAN HOLEVOET: So there is--

00:35:45.445 --> 00:35:45.780
AUDIENCE: Can you repeat
the question?

00:35:45.780 --> 00:35:46.880
DAN HOLEVOET: Yes, I'll
repeat the question.

00:35:46.880 --> 00:35:50.340
So the question was, any chance
we could support Rails

00:35:50.340 --> 00:35:51.730
on App Engine.

00:35:51.730 --> 00:35:56.900
And so there is no automatic
support right now but there is

00:35:56.900 --> 00:35:58.390
support through the JVM.

00:35:58.390 --> 00:36:02.210
So if you're comfortable running
Rails through the JVM,

00:36:02.210 --> 00:36:04.720
that is something that
you could do.

00:36:04.720 --> 00:36:07.820
Endpoints itself probably isn't
going to work too well

00:36:07.820 --> 00:36:10.370
with that just because some of
the bindings aren't there.

00:36:10.370 --> 00:36:12.080
But you could write a generic
Rails application on APP

00:36:12.080 --> 00:36:15.630
Engine if you wanted to.

00:36:15.630 --> 00:36:16.880
Other questions?

00:36:19.522 --> 00:36:21.360
AUDIENCE: I have
two questions.

00:36:21.360 --> 00:36:22.642
DAN HOLEVOET: Sure.

00:36:22.642 --> 00:36:25.240
AUDIENCE: One is the last
session information on Go.

00:36:25.240 --> 00:36:28.660
Can you talk a little bit
advantage of using Go?

00:36:28.660 --> 00:36:31.093
The second question is, how
do you compare your

00:36:31.093 --> 00:36:34.450
service with AWS?

00:36:34.450 --> 00:36:35.950
DAN HOLEVOET: So the
two questions.

00:36:35.950 --> 00:36:37.720
The first question is, can I
talk a little bit more about

00:36:37.720 --> 00:36:40.150
Go, some of the advantages
of Go.

00:36:40.150 --> 00:36:43.830
And the second one is, how would
I compare this to AWS.

00:36:43.830 --> 00:36:45.920
So the first question--

00:36:45.920 --> 00:36:49.220
so Go is a language, of course,
designed by Google

00:36:49.220 --> 00:36:52.750
engineers primarily to solve a
lot of the problems that they

00:36:52.750 --> 00:36:56.130
encountered in building
complex applications.

00:36:56.130 --> 00:37:00.440
Within App Engine, there is some
unique advantages to Go

00:37:00.440 --> 00:37:03.305
such as incredibly fast start
up time, so we're talking on

00:37:03.305 --> 00:37:06.200
the order usually of
milliseconds when starting up

00:37:06.200 --> 00:37:08.360
new instances.

00:37:08.360 --> 00:37:11.020
But it's also a very
modern language.

00:37:11.020 --> 00:37:14.540
People really seem to enjoy
developing in Go.

00:37:14.540 --> 00:37:16.670
I haven't spent too much time
with it myself, so I'm maybe

00:37:16.670 --> 00:37:18.900
not the best person to ask.

00:37:18.900 --> 00:37:24.110
But if Google software engineers
love it and say it's

00:37:24.110 --> 00:37:26.790
great for building complex
applications, I trust their

00:37:26.790 --> 00:37:29.740
word on it.

00:37:29.740 --> 00:37:33.510
And I mean, like I said before,
there isn't currently

00:37:33.510 --> 00:37:36.310
support for Endpoints within
Go, but of course, it's

00:37:36.310 --> 00:37:39.000
something we're looking at
because it's one of the three

00:37:39.000 --> 00:37:41.780
languages supported
on App Engine.

00:37:41.780 --> 00:37:44.060
So for the second question,
how does App

00:37:44.060 --> 00:37:45.540
Engine compare to AWS?

00:37:45.540 --> 00:37:47.940
I mean, they're very, very
different products.

00:37:47.940 --> 00:37:52.070
There are probably other
competitors to App Engine that

00:37:52.070 --> 00:37:53.350
would make better comparisons.

00:37:53.350 --> 00:37:56.860
But I mean, with AWS, you're
getting your own VM.

00:37:56.860 --> 00:37:59.240
I'd be more willing to compare
that to Compute Engine than

00:37:59.240 --> 00:38:03.990
App Engine, which is basically a
managed environment for you.

00:38:03.990 --> 00:38:06.740
You're not tweaking VM settings
with an App Engine.

00:38:06.740 --> 00:38:10.730
You're deploying the code and
then the team of engineers at

00:38:10.730 --> 00:38:12.890
Google is really the one that's
worrying about all

00:38:12.890 --> 00:38:15.260
these configuration settings.

00:38:15.260 --> 00:38:17.120
With that said, there are things
that you can configure

00:38:17.120 --> 00:38:20.170
with an App Engine like how many
idle instances do I want

00:38:20.170 --> 00:38:24.280
to have, how long should they
remain alive before they get

00:38:24.280 --> 00:38:26.710
killed by the scheduler,
things like that.

00:38:26.710 --> 00:38:31.380
But it's basically a very
different type of environment

00:38:31.380 --> 00:38:33.460
than you would expect if you're
familiar with AWS.

00:38:36.100 --> 00:38:37.350
Other questions?

00:38:41.164 --> 00:38:43.630
AUDIENCE: [INAUDIBLE].

00:38:43.630 --> 00:38:44.670
DAN HOLEVOET: So are
Endpoints already

00:38:44.670 --> 00:38:46.010
available, is the question.

00:38:46.010 --> 00:38:49.110
So Endpoints were released
as an experimental

00:38:49.110 --> 00:38:51.410
feature last month.

00:38:51.410 --> 00:38:56.660
And if you're familiar with
our branding, experimental

00:38:56.660 --> 00:39:00.780
features can change, and we've
actually moved them past

00:39:00.780 --> 00:39:02.550
experimental into what we're
calling preview.

00:39:02.550 --> 00:39:05.240
And so those are features that
are well on their way to being

00:39:05.240 --> 00:39:08.500
GA at which inspires more of a
vote of confidence, I think,

00:39:08.500 --> 00:39:10.920
in people who are interested
in using them.

00:39:10.920 --> 00:39:12.860
So Endpoints are a
preview feature.

00:39:12.860 --> 00:39:15.550
Anyone has access to them if
they have an App Engine

00:39:15.550 --> 00:39:18.978
account, so for you
to try them.

00:39:18.978 --> 00:39:20.280
AUDIENCE: [INAUDIBLE].

00:39:20.280 --> 00:39:22.300
DAN HOLEVOET: We have a number
of people who are already

00:39:22.300 --> 00:39:25.500
using them for production
applications.

00:39:25.500 --> 00:39:29.000
And they haven't really seen
any issues with it.

00:39:29.000 --> 00:39:33.640
So it doesn't have the same SLAs
that we have for the GA

00:39:33.640 --> 00:39:37.518
features, but people have been
using them without problems.

00:39:37.518 --> 00:39:39.006
Yeah.

00:39:39.006 --> 00:39:40.256
AUDIENCE: [INAUDIBLE].

00:39:44.960 --> 00:39:45.930
DAN HOLEVOET: Sorry.

00:39:45.930 --> 00:39:47.570
Could you repeat the question
one more time?

00:39:47.570 --> 00:39:48.820
AUDIENCE: [INAUDIBLE].

00:39:51.070 --> 00:39:52.100
DAN HOLEVOET: Do
we have support

00:39:52.100 --> 00:39:53.280
for a long-held requests?

00:39:53.280 --> 00:39:57.600
I mean, no, not really.

00:39:57.600 --> 00:39:59.830
I think that's probably the type
of situation where you'd

00:39:59.830 --> 00:40:02.750
be better off with maybe
Compute Engine,

00:40:02.750 --> 00:40:05.670
something like that.

00:40:05.670 --> 00:40:07.920
That's not saying we couldn't
support them.

00:40:10.560 --> 00:40:11.160
I'm trying to think.

00:40:11.160 --> 00:40:15.340
I mean, we don't have support
for it right now.

00:40:15.340 --> 00:40:18.260
Other questions?

00:40:18.260 --> 00:40:19.071
Yeah.

00:40:19.071 --> 00:40:20.321
AUDIENCE: [INAUDIBLE].

00:40:24.730 --> 00:40:25.590
DAN HOLEVOET: Yep.

00:40:25.590 --> 00:40:27.330
AUDIENCE: [INAUDIBLE].

00:40:27.330 --> 00:40:30.650
So the question was on the
tic-tac-toe game, what happens

00:40:30.650 --> 00:40:33.060
when you're authorizing the end
user on Android or iOS.

00:40:33.060 --> 00:40:41.500
So I can actually show
you the iOS case.

00:40:41.500 --> 00:40:41.980
Let's see.

00:40:41.980 --> 00:40:44.475
Is this the right one?

00:40:49.990 --> 00:40:52.400
Yeah, so the basic idea,
I mean, it's

00:40:52.400 --> 00:40:57.970
very similar to the--

00:40:57.970 --> 00:40:59.840
there we go.

00:40:59.840 --> 00:41:00.140
OK.

00:41:00.140 --> 00:41:01.110
Maybe I can't show you.

00:41:01.110 --> 00:41:02.410
Sorry.

00:41:02.410 --> 00:41:05.020
Basically, on Android, there's
actually no consent screen it

00:41:05.020 --> 00:41:08.220
all, because the way we're
handling it is slightly

00:41:08.220 --> 00:41:11.580
different from the JavaScript
and iOS case.

00:41:11.580 --> 00:41:14.650
In that case, we're assuming
that a developer is speaking

00:41:14.650 --> 00:41:18.750
to his own application
automatically should know who

00:41:18.750 --> 00:41:20.080
the user is.

00:41:20.080 --> 00:41:23.490
And so in that case, there's
no consent screen.

00:41:23.490 --> 00:41:26.600
You automatically get access
to a user object

00:41:26.600 --> 00:41:28.030
on the server side.

00:41:28.030 --> 00:41:31.250
In the iOS case, it's similar
to the JavaScript one.

00:41:31.250 --> 00:41:33.080
So you have to sign in.

00:41:33.080 --> 00:41:36.030
It's using a web flow, so the
user will type in their

00:41:36.030 --> 00:41:37.945
credentials if they're not
already signed in.

00:41:37.945 --> 00:41:40.850
And you see that same consent
screen that I showed you that

00:41:40.850 --> 00:41:43.770
would be in line in the UI
rather than pop up, of course.

00:41:46.380 --> 00:41:48.397
But the backend code is
entirely the same.

00:41:48.397 --> 00:41:49.828
Yeah.

00:41:49.828 --> 00:41:51.078
AUDIENCE: [INAUDIBLE].

00:41:54.600 --> 00:41:54.860
DAN HOLEVOET: Sorry.

00:41:54.860 --> 00:41:55.530
Can you repeat that one?

00:41:55.530 --> 00:41:56.780
AUDIENCE: [INAUDIBLE].

00:41:58.790 --> 00:41:58.980
DAN HOLEVOET: Yeah.

00:41:58.980 --> 00:42:00.330
So Endpoints.

00:42:00.330 --> 00:42:01.820
The question was, does it
support native apps.

00:42:01.820 --> 00:42:02.876
Yes.

00:42:02.876 --> 00:42:05.860
So basically, you can write
web applications.

00:42:05.860 --> 00:42:06.825
You can write Android
applications.

00:42:06.825 --> 00:42:08.670
You can write IOS
applications.

00:42:08.670 --> 00:42:11.150
Works across all
three of those.

00:42:11.150 --> 00:42:17.030
And in the feature set that
we're targeting, initially, we

00:42:17.030 --> 00:42:20.840
really focused on mobile, but
there's other client libraries

00:42:20.840 --> 00:42:24.820
that are part of the Google
API infrastructure and

00:42:24.820 --> 00:42:27.110
services and environment.

00:42:27.110 --> 00:42:29.200
And it will actually work
well with those two.

00:42:29.200 --> 00:42:34.680
So if you want to write like a
Windows Phone app, we have a

00:42:34.680 --> 00:42:36.630
.net client library that
you can download.

00:42:36.630 --> 00:42:39.300
And we haven't gone through
the whole experience quite

00:42:39.300 --> 00:42:43.510
with the same level of detail
that we have with these three

00:42:43.510 --> 00:42:46.860
libraries that I mentioned, but
there is support in those

00:42:46.860 --> 00:42:48.680
other libraries at least
tentatively for

00:42:48.680 --> 00:42:51.328
this type of thing.

00:42:51.328 --> 00:42:52.272
Yeah.

00:42:52.272 --> 00:42:55.110
AUDIENCE: [INAUDIBLE].

00:42:55.110 --> 00:42:56.280
DAN HOLEVOET: Ah, ActionScript
client library.

00:42:56.280 --> 00:42:57.570
That as a good question.

00:42:57.570 --> 00:42:59.870
I can't remember off
the top of my head

00:42:59.870 --> 00:43:01.350
whether we have one.

00:43:01.350 --> 00:43:03.240
We either do have one or
there was discussion

00:43:03.240 --> 00:43:04.490
of one at some point.

00:43:04.490 --> 00:43:05.160
I can find out.

00:43:05.160 --> 00:43:07.670
AUDIENCE: [INAUDIBLE].

00:43:07.670 --> 00:43:08.300
DAN HOLEVOET: Yeah.

00:43:08.300 --> 00:43:09.176
ActionScript?

00:43:09.176 --> 00:43:10.920
AUDIENCE: [INAUDIBLE].

00:43:10.920 --> 00:43:12.170
DAN HOLEVOET: Yeah.

00:43:14.830 --> 00:43:15.560
Other questions?

00:43:15.560 --> 00:43:15.995
Yes.

00:43:15.995 --> 00:43:17.606
AUDIENCE: [INAUDIBLE].

00:43:17.606 --> 00:43:19.670
DAN HOLEVOET: Ah, Unity.

00:43:19.670 --> 00:43:22.320
So Yeah.

00:43:22.320 --> 00:43:26.760
I mean, so I mentioned there's
a C# client library.

00:43:26.760 --> 00:43:29.150
And of course, there's a
JavaScript client library.

00:43:29.150 --> 00:43:33.570
But I think that you would
probably need to do a bit of

00:43:33.570 --> 00:43:37.280
work to get it working
with Unity.

00:43:37.280 --> 00:43:41.275
So no out-of-the-box support.

00:43:41.275 --> 00:43:42.575
Anything else?

00:43:45.400 --> 00:43:46.140
Going once.

00:43:46.140 --> 00:43:46.470
Going twice.

00:43:46.470 --> 00:43:46.960
All right.

00:43:46.960 --> 00:43:48.270
Well, thank you all very
much for coming.

