WEBVTT
Kind: captions
Language: en

00:00:01.534 --> 00:00:03.434
Arne Roomann-Kurrik:
We're gonna talk about ways

00:00:03.434 --> 00:00:05.501
that you can optimize
your existing OpenSocial app

00:00:05.501 --> 00:00:08.033
in the context of
a high traffic application.

00:00:08.033 --> 00:00:10.234
If you have any questions
during the session,

00:00:10.234 --> 00:00:11.968
we'll take questions
afterwards,

00:00:11.968 --> 00:00:13.701
if we have
a little bit of extra time.

00:00:13.701 --> 00:00:16.000
There's a link here
to go to Google Moderator

00:00:16.000 --> 00:00:17.434
where you
can add a question,

00:00:17.434 --> 00:00:20.367
and if we can get to them
then we'll answer them.

00:00:20.367 --> 00:00:24.634
So to begin, let's talk
about what success means

00:00:24.634 --> 00:00:26.734
as a social application
developer.

00:00:26.734 --> 00:00:28.501
Obviously,
the more money you make

00:00:28.501 --> 00:00:29.767
the better you're doing.

00:00:29.767 --> 00:00:33.634
So the trouble with
this is that social eCPM

00:00:33.634 --> 00:00:38.200
is basically, like...
is very low compared

00:00:38.200 --> 00:00:41.567
to the rest of
the web-type industries.

00:00:41.567 --> 00:00:43.200
It's actually the lowest of

00:00:43.200 --> 00:00:45.601
news, entertainment,
technology, gaming.

00:00:45.601 --> 00:00:49.267
So basically,
for each page render

00:00:49.267 --> 00:00:51.067
of your social application,

00:00:51.067 --> 00:00:53.701
you're making less money
than other industries.

00:00:53.701 --> 00:00:55.634
The good thing
about this, though,

00:00:55.634 --> 00:00:58.701
is that you have direct access
to millions of signed in users.

00:00:58.701 --> 00:01:00.701
Usually if
your application's running

00:01:00.701 --> 00:01:02.234
inside of a social platform,

00:01:02.234 --> 00:01:04.334
those users have
a very low barrier to entry

00:01:04.334 --> 00:01:05.701
to install your application.

00:01:05.701 --> 00:01:07.400
And there's
also growth functionality

00:01:07.400 --> 00:01:08.968
built into a lot of platforms.

00:01:08.968 --> 00:01:11.567
So you can share your app,
invite your friends, et cetera.

00:01:11.567 --> 00:01:13.968
And so, social applications
see a lot of growth,

00:01:13.968 --> 00:01:15.367
and a lot of
very quick growth.

00:01:15.367 --> 00:01:19.501
So, um, even though
that the CPM is pretty low,

00:01:19.501 --> 00:01:21.734
you have growth
to make up for it.

00:01:21.734 --> 00:01:23.901
Now what this means in terms
of performance, though,

00:01:23.901 --> 00:01:26.167
is that small tweaks
really matter.

00:01:26.167 --> 00:01:28.367
And let's look
at a few quotes about

00:01:28.367 --> 00:01:30.801
how small tweaks
really do matter

00:01:30.801 --> 00:01:33.334
for large-scale
applications.

00:01:33.334 --> 00:01:34.767
Here's a quote
from Marissa Mayer,

00:01:34.767 --> 00:01:37.300
talking about how
when Google was deciding

00:01:37.300 --> 00:01:40.067
on how many results to return
in their search index.

00:01:40.067 --> 00:01:42.467
They actually did experiments
with different types of users

00:01:42.467 --> 00:01:45.634
to determine what
was the optimal number.

00:01:45.634 --> 00:01:47.734
And by increasing
the number of results,

00:01:47.734 --> 00:01:49.400
they actually
slowed down rendering time

00:01:49.400 --> 00:01:51.267
by about half a second.

00:01:51.267 --> 00:01:55.367
Now the group that actually
had the--more results

00:01:55.367 --> 00:01:57.601
wound up dropping off their
traffic by about 20%.

00:01:57.601 --> 00:01:59.934
That means about
20% fewer Google searches

00:01:59.934 --> 00:02:01.701
happened because
the page was slow.

00:02:01.701 --> 00:02:04.567
So if half a second of latency
makes that much difference,

00:02:04.567 --> 00:02:08.868
then you can see how important
it is to a big site like Google.

00:02:08.868 --> 00:02:10.801
Here's a quote from
Greg Linden at Amazon,

00:02:10.801 --> 00:02:15.000
talking about how Amazon
also did experiments

00:02:15.000 --> 00:02:17.634
with latency to see
how it would affect sales.

00:02:17.634 --> 00:02:20.701
When they increased
the page load by 0.1 seconds--

00:02:20.701 --> 00:02:22.267
that's 100 milliseconds--

00:02:22.267 --> 00:02:23.934
it cost them
1% of their sales.

00:02:23.934 --> 00:02:25.400
There's, like,
a direct correlation

00:02:25.400 --> 00:02:26.968
between latency
and the amount of sales

00:02:26.968 --> 00:02:29.467
that Amazon
was experiencing.

00:02:29.467 --> 00:02:32.400
Finally, last quote by Marissa

00:02:32.400 --> 00:02:34.300
is talking
about how Google Maps,

00:02:34.300 --> 00:02:38.400
after they first launched,
had a 100KB page load.

00:02:38.400 --> 00:02:41.100
Uh, now they have had
a lot of adoption quickly,

00:02:41.100 --> 00:02:42.901
but then they decided
that there was actually

00:02:42.901 --> 00:02:44.801
ways that they
could optimize their size.

00:02:44.801 --> 00:02:47.100
And they actually trimmed
about 30KB of JavaScript

00:02:47.100 --> 00:02:48.467
out of the initial download.

00:02:48.467 --> 00:02:52.634
Now dropping the 30KB,
actually, from that point on

00:02:52.634 --> 00:02:56.400
made Google Maps
grow by 30% in three weeks.

00:02:56.400 --> 00:02:58.200
So there
was actually, again,

00:02:58.200 --> 00:03:00.100
a direct correlation
between page size

00:03:00.100 --> 00:03:03.400
and the amount of growth
they experienced.

00:03:03.400 --> 00:03:05.601
So for this presentation,
we're going to measure

00:03:05.601 --> 00:03:08.100
the impact of changes
on large scale applications.

00:03:08.100 --> 00:03:09.767
So they're sort
of applications that once

00:03:09.767 --> 00:03:11.701
you actually make it,
like, reasonably large

00:03:11.701 --> 00:03:13.100
in the OpenSocial space,

00:03:13.100 --> 00:03:15.434
these are the tweaks
that will actually help you

00:03:15.434 --> 00:03:18.801
lower your costs and
then make your users happier.

00:03:18.801 --> 00:03:20.767
To do this,
we actually wrote

00:03:20.767 --> 00:03:22.534
a sample
OpenSocial application.

00:03:22.534 --> 00:03:24.667
And we rewrote it,
like, four times.

00:03:24.667 --> 00:03:29.133
And what that was
was each time we rewrote it,

00:03:29.133 --> 00:03:32.734
we isolated different strategies
to optimize the application.

00:03:32.734 --> 00:03:35.000
And then we
did metrics to count it

00:03:35.000 --> 00:03:37.100
and see what
the net effect was.

00:03:37.100 --> 00:03:40.467
The idea is
that we can show you--

00:03:40.467 --> 00:03:42.267
We can show you ways
that you can deliver

00:03:42.267 --> 00:03:43.801
a fast user experience.

00:03:43.801 --> 00:03:45.734
We can
also minimize the costs,

00:03:45.734 --> 00:03:49.133
so reducing the amount of server
charges that you need to spend.

00:03:49.133 --> 00:03:52.234
And then highlight
some new OpenSocial features

00:03:52.234 --> 00:03:53.400
that you
might not be aware of

00:03:53.400 --> 00:03:55.067
that you can
use in your apps today.

00:03:55.067 --> 00:03:57.367
Or, uh, yeah.

00:03:57.367 --> 00:04:00.901
So the app that we wrote
was called "Quartermile".

00:04:00.901 --> 00:04:05.400
Basically, it's very, uh--
Oh, sorry.

00:04:05.400 --> 00:04:08.801
Uh, it's...I'm sorry.

00:04:08.801 --> 00:04:11.634
[chuckles]

00:04:11.634 --> 00:04:12.968
Here we go.

00:04:12.968 --> 00:04:17.801
Uh, here's a live--
live demo of how the app works.

00:04:17.801 --> 00:04:19.067
I'm actually in Orkut
right now

00:04:19.067 --> 00:04:21.334
and I'm installing it
into the UI.

00:04:21.334 --> 00:04:25.000
Accepting ad application.

00:04:25.000 --> 00:04:26.734
You can see that--
the interface is

00:04:26.734 --> 00:04:28.234
that it's
a fitness application.

00:04:28.234 --> 00:04:30.234
And what it does
is when you first load it,

00:04:30.234 --> 00:04:32.067
it asks you what team
you'd like to be on.

00:04:32.067 --> 00:04:33.767
So here, I'm just
gonna pick one of the teams

00:04:33.767 --> 00:04:35.167
that my friends are
members of.

00:04:35.167 --> 00:04:38.634
And you can see, there's
actually team data coming in

00:04:38.634 --> 00:04:40.100
upon the load of the app.

00:04:40.100 --> 00:04:43.100
So on the middle column,
you can see

00:04:43.100 --> 00:04:45.000
the graphs about
what the fitness was.

00:04:45.000 --> 00:04:47.901
On the right, there's
individual fitness activities.

00:04:47.901 --> 00:04:49.434
What I'm doing
right now is I'm sending

00:04:49.434 --> 00:04:50.734
an invite
to one of my friends

00:04:50.734 --> 00:04:52.667
Just to invite them
to my team.

00:04:52.667 --> 00:04:54.801
So I joined a team,
and then now

00:04:54.801 --> 00:04:57.100
I'm getting one of
my friends to join me also.

00:04:57.100 --> 00:04:59.100
Now I'm gonna start entering
in some fitness data.

00:04:59.100 --> 00:05:01.734
So here I'm just typing it
in natural English--

00:05:01.734 --> 00:05:03.334
"I walked one mile yesterday."

00:05:03.334 --> 00:05:05.167
And I'm posting this activity.

00:05:05.167 --> 00:05:07.367
And when I post it,
the graphs update.

00:05:07.367 --> 00:05:09.801
And you can see
that there's now three people

00:05:09.801 --> 00:05:11.667
actively contributing
to this team.

00:05:11.667 --> 00:05:14.634
On the right hand side, there's
actually a list of activities.

00:05:14.634 --> 00:05:16.400
And my activity is
marked with

00:05:16.400 --> 00:05:19.267
the number of foodles
that activity is worth.

00:05:19.267 --> 00:05:21.400
So we kind of came up
with some metrics

00:05:21.400 --> 00:05:24.367
on, you know, running
is worth "X" number of foodles

00:05:24.367 --> 00:05:26.167
if you do it for so long,
and whatever.

00:05:26.167 --> 00:05:28.968
And we kind of standardize
all our exercises together.

00:05:28.968 --> 00:05:31.067
So in this case,
I'm typing in

00:05:31.067 --> 00:05:33.000
that I ran two miles
two days ago.

00:05:33.000 --> 00:05:36.300
And you can see
that the graph updates.

00:05:36.300 --> 00:05:40.267
Here, I'm doing
1,000 sit-ups on May 23rd.

00:05:42.501 --> 00:05:43.767
And the graph updates also.

00:05:43.767 --> 00:05:45.467
So there's different types
of exercises,

00:05:45.467 --> 00:05:48.167
kind of standardized
into one general data set.

00:05:48.167 --> 00:05:49.567
And this will
kind of just show you--

00:05:49.567 --> 00:05:51.200
this is the sort
of social application,

00:05:51.200 --> 00:05:52.868
you know, exercising
with your friends,

00:05:52.868 --> 00:05:55.767
that you would see
in a real ecosystem.

00:05:55.767 --> 00:05:58.634
I guess there's potential,
or maybe to flatter myself,

00:05:58.634 --> 00:06:01.234
there's potential
for it to grow pretty large.

00:06:01.234 --> 00:06:04.567
Uh, the backend is built
on Google App Engine.

00:06:04.567 --> 00:06:06.968
Basically, we structured
it so that

00:06:06.968 --> 00:06:10.000
the backend was called
via JSON RPC calls.

00:06:10.000 --> 00:06:12.701
Transferring data back
and forth from the frontends.

00:06:12.701 --> 00:06:16.367
The frontends were written
in many different ways,

00:06:16.367 --> 00:06:18.734
so actually if you were
at the previous session,

00:06:18.734 --> 00:06:20.934
"Google and the Social Web,"
you saw a few

00:06:20.934 --> 00:06:23.067
of those frontends running
in different containers.

00:06:23.067 --> 00:06:25.934
The one that we wrote for this
was a little bit different

00:06:25.934 --> 00:06:28.067
because we kept the same
functionality,

00:06:28.067 --> 00:06:31.334
and we just rewrote it to see
how we could optimize that.

00:06:31.334 --> 00:06:34.100
There's a few links here
on the slides.

00:06:34.100 --> 00:06:36.400
Feel free
to check them out later.

00:06:36.400 --> 00:06:38.467
All this stuff
will be posted online.

00:06:38.467 --> 00:06:42.801
And to measure it, we have three
different types of requests:

00:06:42.801 --> 00:06:45.300
basically, API requests
to the backend--

00:06:45.300 --> 00:06:46.767
the App Engine backend.

00:06:46.767 --> 00:06:49.701
We have API requests
to the OpenSocial APIs

00:06:49.701 --> 00:06:52.167
on the container
in which it runs.

00:06:52.167 --> 00:06:53.267
And then we have assets,

00:06:53.267 --> 00:06:56.000
like JavaScript,
CSS images, et cetera.

00:06:56.000 --> 00:06:58.567
And we're measuring on
four different metric points.

00:06:58.567 --> 00:07:02.133
Bandwidth per page view--
so the total download size

00:07:02.133 --> 00:07:04.968
that the server is serving up
every time the page is loaded.

00:07:04.968 --> 00:07:07.067
The number of
requests per page view.

00:07:07.067 --> 00:07:11.100
That's just counting the number
of individual HTTP requests,

00:07:11.100 --> 00:07:12.501
The latency per page view--

00:07:12.501 --> 00:07:14.667
so the amount of time
that it takes from the time

00:07:14.667 --> 00:07:17.067
that the app is loaded
until it's ready to use.

00:07:17.067 --> 00:07:22.467
And then CPU time is actually
a metric unique to App Engine.

00:07:22.467 --> 00:07:25.334
But what it is,
is basically how--

00:07:25.334 --> 00:07:28.801
a measure of how much
backend work we're doing.

00:07:28.801 --> 00:07:30.734
The reason
we're actually including this

00:07:30.734 --> 00:07:32.901
in the measurements
is we can actually

00:07:32.901 --> 00:07:35.234
do a cost calculation
on this later on.

00:07:35.234 --> 00:07:38.067
Now measuring each of these
individually is important

00:07:38.067 --> 00:07:40.734
because you can actually
sometimes tweak one

00:07:40.734 --> 00:07:42.334
while you're
not affecting the others.

00:07:42.334 --> 00:07:45.501
And you have certain amounts of
control over certain requests,

00:07:45.501 --> 00:07:47.033
and you don't really
over others.

00:07:47.033 --> 00:07:48.934
So being able to realize
what you can optimize

00:07:48.934 --> 00:07:51.000
and what you
can't optimize is important.

00:07:51.000 --> 00:07:54.434
So here are the raw numbers
for the "Naive" Implementation.

00:07:54.434 --> 00:07:56.200
And what we did was
we wrote this application

00:07:56.200 --> 00:07:57.400
as if you had just read

00:07:57.400 --> 00:07:59.267
the OpenSocial tutorial
for the first time.

00:07:59.267 --> 00:08:01.200
And you just started
writing this app,

00:08:01.200 --> 00:08:02.801
and you kind of
threw everything in there

00:08:02.801 --> 00:08:04.234
and got it together.

00:08:04.234 --> 00:08:06.667
You can see that
we broke it down again

00:08:06.667 --> 00:08:08.868
through API calls
to the Quartermile backend,

00:08:08.868 --> 00:08:10.934
through social
requests to OpenSocial,

00:08:10.934 --> 00:08:13.734
and then image and CSS
in JavaScript.

00:08:13.734 --> 00:08:17.534
And then finally,
the only metric which actually

00:08:17.534 --> 00:08:20.434
has a server
processing metric

00:08:20.434 --> 00:08:23.000
is API calls to
the Quartermile backend.

00:08:23.000 --> 00:08:25.734
'Cause the rest of it is
pretty much free for our server.

00:08:25.734 --> 00:08:29.801
Now when you
actually look at the raw--

00:08:29.801 --> 00:08:32.300
the first set of metrics
that we counted was,

00:08:32.300 --> 00:08:34.667
first of all,
the latency of the gadget.

00:08:34.667 --> 00:08:36.734
And we'll cover
more about this later,

00:08:36.734 --> 00:08:39.167
but this is basically
the gadget perceived latency.

00:08:39.167 --> 00:08:41.267
From the time that
the head of the gadget renders

00:08:41.267 --> 00:08:44.100
to the time that it's
first usable by the end user,

00:08:44.100 --> 00:08:46.734
it took us about 2.7 seconds.

00:08:46.734 --> 00:08:49.634
The next latency metric
is the page latency.

00:08:49.634 --> 00:08:51.601
So if you were
to just open up the iFrame

00:08:51.601 --> 00:08:52.868
in which this gadget ran,

00:08:52.868 --> 00:08:54.834
and then reload it
and measured that speed,

00:08:54.834 --> 00:08:56.767
that was about 3.5 seconds.

00:08:56.767 --> 00:08:59.601
Now, this is maybe
a little bit more accurate

00:08:59.601 --> 00:09:01.601
in terms of perceived latency,
just because

00:09:01.601 --> 00:09:03.300
it's the amount of time
that the user sees,

00:09:03.300 --> 00:09:04.667
not what the gadget sees.

00:09:04.667 --> 00:09:07.133
So it includes the round-trips
to our backend server.

00:09:07.133 --> 00:09:08.767
Finally,
the number of requests--

00:09:08.767 --> 00:09:10.734
it took
26 HTTP requests

00:09:10.734 --> 00:09:12.701
to render the gadget
for the first time,

00:09:12.701 --> 00:09:16.501
including images, CSS,
backend API calls, et cetera.

00:09:16.501 --> 00:09:18.067
And then we just
ran it through YSlow

00:09:18.067 --> 00:09:19.467
which we'll
talk about more later.

00:09:19.467 --> 00:09:23.167
But we got
a not so great score of 72.

00:09:23.167 --> 00:09:25.534
Finally,
the cost of this app...

00:09:25.534 --> 00:09:27.801
Just doing some numbers
and really thinking about

00:09:27.801 --> 00:09:29.767
like, how can we
put this in perspective

00:09:29.767 --> 00:09:31.033
to you as an app developer?

00:09:31.033 --> 00:09:32.834
Is--if you have a reasonable
amount of traffic--

00:09:32.834 --> 00:09:35.868
And reasonable
is actually fairly large

00:09:35.868 --> 00:09:38.100
by most web standards,
but for a social application

00:09:38.100 --> 00:09:42.234
is not really that huge--
is at 11 QPS on average.

00:09:42.234 --> 00:09:44.734
Winds up being about
a million page views a day,

00:09:44.734 --> 00:09:47.400
30 million over
the course of a month.

00:09:47.400 --> 00:09:49.100
And when we
actually did all that,

00:09:49.100 --> 00:09:51.234
then we found out
the app consumes about

00:09:51.234 --> 00:09:54.167
5 terabytes
of bandwidth traffic,

00:09:54.167 --> 00:09:58.167
and 1,859 hours of CPUs.

00:09:58.167 --> 00:10:00.701
Now, the great thing
about these two measurements

00:10:00.701 --> 00:10:02.834
is that App Engine actually
has set costs for these.

00:10:02.834 --> 00:10:06.534
So we can kind of estimate
what it would cost

00:10:06.534 --> 00:10:09.467
to add this amount of traffic
onto our existing app engine.

00:10:09.467 --> 00:10:13.000
Now keep in mind that this isn't
really a direct correlation

00:10:13.000 --> 00:10:14.901
of what you would pay to run
this app on App Engine,

00:10:14.901 --> 00:10:16.667
because App Engine
does have a free quota.

00:10:16.667 --> 00:10:19.200
And this is really just saying

00:10:19.200 --> 00:10:22.701
if you had a million extra
page views a day,

00:10:22.701 --> 00:10:26.367
you would be paying
about $900 a month more

00:10:26.367 --> 00:10:27.868
for that amount of traffic.

00:10:27.868 --> 00:10:30.133
It's certainly reasonable
for apps to scale that large.

00:10:30.133 --> 00:10:33.367
We have social apps going up to,
you know, the hundreds of QPS.

00:10:33.367 --> 00:10:38.067
So 11 isn't really--
isn't really that strange.

00:10:40.400 --> 00:10:42.334
Chris Chabot:
So when we're looking...

00:10:42.334 --> 00:10:43.467
[inaudible]

00:10:43.467 --> 00:10:44.834
...important to keep
in mind that

00:10:44.834 --> 00:10:47.100
gadgets are actually
web pages as well.

00:10:47.100 --> 00:10:49.467
They're a web page
embedded in an iFrame

00:10:49.467 --> 00:10:50.968
within a social profile.

00:10:50.968 --> 00:10:54.367
So any of the optimizations
that we know to do to web pages

00:10:54.367 --> 00:10:56.000
count for gadgets as well.

00:10:56.000 --> 00:10:58.100
So some of the tricks
that we'll be looking at

00:10:58.100 --> 00:11:00.367
is how to reduce
the size of the page,

00:11:00.367 --> 00:11:02.868
how to reduce
the amount of requests

00:11:02.868 --> 00:11:04.000
that a page needs to make

00:11:04.000 --> 00:11:05.367
to actually
make the gadget work

00:11:05.367 --> 00:11:06.934
and render
and be displayed,

00:11:06.934 --> 00:11:08.868
and we'll be looking
at the total latency

00:11:08.868 --> 00:11:10.567
that a gadget
has associated with it

00:11:10.567 --> 00:11:12.534
before you can start
interacting with it.

00:11:12.534 --> 00:11:15.267
To look at all
these different numbers

00:11:15.267 --> 00:11:17.567
and to be able to investigate
how your application is doing,

00:11:17.567 --> 00:11:19.167
there's a number
of tools for pretty much

00:11:19.167 --> 00:11:20.767
every mainstream web browser.

00:11:20.767 --> 00:11:23.133
If you're using Safari,
then the Web Inspector's

00:11:23.133 --> 00:11:24.567
the awesome tool to use.

00:11:24.567 --> 00:11:26.100
If you're using Firefox,

00:11:26.100 --> 00:11:28.734
then you've got Firebug and
YSlow to analyze your results.

00:11:28.734 --> 00:11:31.534
And in IE, you've
got tools like HttpWatch

00:11:31.534 --> 00:11:34.934
with which you can
analyze what's happening.

00:11:34.934 --> 00:11:36.267
So one of
the first big tricks

00:11:36.267 --> 00:11:37.667
that you have
with web development

00:11:37.667 --> 00:11:40.567
to make your application slower
is by concatenating

00:11:40.567 --> 00:11:42.767
all your JavaScript files
into one big file,

00:11:42.767 --> 00:11:46.267
concatenating all your CSS files
into one big file too.

00:11:46.267 --> 00:11:48.501
That way you only have
to download one big file

00:11:48.501 --> 00:11:51.300
instead of making several
requests to your backend server.

00:11:51.300 --> 00:11:54.534
Making a request to a server
over HTTP is really slow

00:11:54.534 --> 00:11:56.734
because you're making
a TCP/IP connection,

00:11:56.734 --> 00:11:58.601
you're talking protocol
with a server.

00:11:58.601 --> 00:12:01.234
So just by removing that
from downloading the app

00:12:01.234 --> 00:12:03.033
it already
becomes a lot faster.

00:12:03.033 --> 00:12:05.434
So you're using
a bit less bandwidth,

00:12:05.434 --> 00:12:07.567
your latency is going down,
and the amount of requests

00:12:07.567 --> 00:12:09.334
that you're making
is going down.

00:12:09.334 --> 00:12:11.467
Then the next step is
to compress those things.

00:12:11.467 --> 00:12:12.868
There's a number
of tools for that,

00:12:12.868 --> 00:12:15.567
like JSMin, YUI Compressor,
et cetera.

00:12:15.567 --> 00:12:17.767
And you can use that
to compress your JavaScripts.

00:12:17.767 --> 00:12:20.000
What it will do is it will
take your JavaScript,

00:12:20.000 --> 00:12:22.834
as you see here,
and it will remove everything

00:12:22.834 --> 00:12:24.734
that's not
"syntaxually" required.

00:12:24.734 --> 00:12:26.334
So spaces, line breaks--

00:12:26.334 --> 00:12:29.267
It will even go so far
sometimes as to rename variables

00:12:29.267 --> 00:12:32.667
to shorten names just
to save size.

00:12:32.667 --> 00:12:34.767
You can see the results
that you're getting

00:12:34.767 --> 00:12:36.334
using those tools
in your browsers.

00:12:36.334 --> 00:12:37.801
Like, here's
a little example of what

00:12:37.801 --> 00:12:39.200
it would look like
in Safari,

00:12:39.200 --> 00:12:40.801
and you see
a total download size.

00:12:40.801 --> 00:12:43.200
So when we did this
to Quartermile

00:12:43.200 --> 00:12:46.701
we noticed that we saved up
to 54% of the download size

00:12:46.701 --> 00:12:49.400
on this JavaScript
in the stylesheet assets.

00:12:49.400 --> 00:12:50.901
So that's a huge reduction

00:12:50.901 --> 00:12:52.834
in the amount of
bandwidth required,

00:12:52.834 --> 00:12:55.334
and you sped up your application
by quite a bit as well,

00:12:55.334 --> 00:12:59.434
resulting in a saving, well,
on this monthly amount of $61.

00:12:59.434 --> 00:13:01.734
So that's pretty damn good.

00:13:01.734 --> 00:13:04.334
The next thing you
want to look at is latency.

00:13:04.334 --> 00:13:06.367
When you're developing
your application you'll be

00:13:06.367 --> 00:13:09.167
working on your own server,
and you can use tools--

00:13:09.167 --> 00:13:11.434
again, like the
Web Inspector and Firebug--

00:13:11.434 --> 00:13:15.000
to see what the total loading
time of your application is.

00:13:15.000 --> 00:13:17.334
And that's a great trick, and
it's a great way to make sure

00:13:17.334 --> 00:13:19.767
that you're optimizing it
as much as possible.

00:13:19.767 --> 00:13:22.067
But at some point,
you get into the situation

00:13:22.067 --> 00:13:24.834
where your app is deployed
on a social networking site.

00:13:24.834 --> 00:13:26.601
And there's gonna
be people using it,

00:13:26.601 --> 00:13:28.467
and they're not gonna be
in the same ISB as you.

00:13:28.467 --> 00:13:30.601
They're not gonna be
in the same country as you.

00:13:30.601 --> 00:13:32.400
They might be
going through proxy servers,

00:13:32.400 --> 00:13:34.167
different network routes,
et cetera.

00:13:34.167 --> 00:13:35.901
So how do you measure that?

00:13:35.901 --> 00:13:37.300
And how do you figure out

00:13:37.300 --> 00:13:39.634
where in the world
your people are coming from

00:13:39.634 --> 00:13:42.200
and what their experience
of the application is?

00:13:42.200 --> 00:13:45.133
So we know we need to measure
this from different locations.

00:13:45.133 --> 00:13:47.334
We know that we need
to keep measuring it as well,

00:13:47.334 --> 00:13:48.901
because situations change.

00:13:48.901 --> 00:13:51.434
Your application can
suddenly become really popular,

00:13:51.434 --> 00:13:53.868
or maybe you gain a
lot of users in a country

00:13:53.868 --> 00:13:56.367
where you didn't expect
you would get a lot of users.

00:13:56.367 --> 00:13:58.133
And you might
want to invest in a city,

00:13:58.133 --> 00:14:01.167
and/or bringing a server
closer to those users

00:14:01.167 --> 00:14:03.801
so they get
a really fast experience too.

00:14:03.801 --> 00:14:06.033
So to be able to measure that

00:14:06.033 --> 00:14:07.734
you can't use
those standard tools anymore

00:14:07.734 --> 00:14:10.200
and you need to build something
yourself, some custom code.

00:14:10.200 --> 00:14:13.200
And here's an example of how
you would do this in JavaScript.

00:14:13.200 --> 00:14:15.067
For instance,
for measuring the latency,

00:14:15.067 --> 00:14:16.901
you could
create an image element,

00:14:16.901 --> 00:14:19.267
then you add
an onload function to it,

00:14:19.267 --> 00:14:20.834
and that forces
the web browser to actually

00:14:20.834 --> 00:14:22.667
always download that image.

00:14:22.667 --> 00:14:25.100
And then on the onload event,
you measure,

00:14:25.100 --> 00:14:27.734
"Hey, I started at this time,
and I ended at this time.

00:14:27.734 --> 00:14:30.267
So I know what my
network latency is now."

00:14:30.267 --> 00:14:32.667
This is great for
defining the network latency.

00:14:32.667 --> 00:14:34.834
Then there's also the latency
for, "How long does it take

00:14:34.834 --> 00:14:37.634
to make an API call
to my own backend server?"

00:14:37.634 --> 00:14:40.334
So you would put
the same type of code

00:14:40.334 --> 00:14:42.834
around the data calls
to your server as well.

00:14:42.834 --> 00:14:44.534
And you can combine
those graphs saying,

00:14:44.534 --> 00:14:46.968
"Well, here I see that my
network latency is really low,

00:14:46.968 --> 00:14:50.133
"but the latency for making
data calls is really high.

00:14:50.133 --> 00:14:52.200
"So now I know that
my servers are slowing down,

00:14:52.200 --> 00:14:54.133
"and I need to invest
in that to make sure that

00:14:54.133 --> 00:14:57.334
the latency keeps low and
my users keep on being happy."

00:14:59.300 --> 00:15:00.601
The next trick
that you can use

00:15:00.601 --> 00:15:02.400
from web development
is image spriting.

00:15:02.400 --> 00:15:04.434
Image spriting
is a technology where

00:15:04.434 --> 00:15:06.734
you take a number of images
and you combine it

00:15:06.734 --> 00:15:08.534
into one big image file.

00:15:08.534 --> 00:15:11.534
And you use stylesheets
to position that as a background

00:15:11.534 --> 00:15:13.667
in the element to
only show the bit of the image

00:15:13.667 --> 00:15:17.467
that you're interested
in displaying in that part.

00:15:17.467 --> 00:15:18.868
The big benefit to doing this

00:15:18.868 --> 00:15:20.434
is that you reduce
the amount of requests

00:15:20.434 --> 00:15:22.734
you're making to your server
by quite a bit again.

00:15:22.734 --> 00:15:24.400
You only have to download
one image file

00:15:24.400 --> 00:15:26.534
instead of having to download
10 or 20 of them.

00:15:26.534 --> 00:15:31.300
So the latency goes down,
total request count goes down,

00:15:31.300 --> 00:15:32.567
and you can use tools like--

00:15:32.567 --> 00:15:34.234
Well, YSlow
is one of my favorites

00:15:34.234 --> 00:15:35.834
because it shows
you both the situation

00:15:35.834 --> 00:15:37.734
when you have
a completely clean browser

00:15:37.734 --> 00:15:39.567
that's never
been to this page before,

00:15:39.567 --> 00:15:41.634
and it shows you when
you've gone there before

00:15:41.634 --> 00:15:43.167
and you've got a primed cache.

00:15:43.167 --> 00:15:45.734
So everything that's cacheable
is already in your cache.

00:15:45.734 --> 00:15:47.400
And it will show you
a beautiful breakdown

00:15:47.400 --> 00:15:49.000
of the amount
of requests you're making,

00:15:49.000 --> 00:15:53.667
what kind of a request count is
going to what type of resource.

00:15:53.667 --> 00:15:56.000
So when we applied
this image spriting technique

00:15:56.000 --> 00:15:59.267
to Quartermile,
we noticed that latency

00:15:59.267 --> 00:16:01.801
went down
by quite a bit--45%.

00:16:01.801 --> 00:16:03.501
And that's a really good save.

00:16:03.501 --> 00:16:06.133
However, we also noticed
that the size was going up,

00:16:06.133 --> 00:16:07.567
because there's
always a little bit

00:16:07.567 --> 00:16:09.767
of white space
in your bigger image.

00:16:09.767 --> 00:16:11.968
So the next thing we did
is that we optimized

00:16:11.968 --> 00:16:14.200
the palette of
the image file as well.

00:16:14.200 --> 00:16:16.067
So you're reducing
the palette size,

00:16:16.067 --> 00:16:17.567
means there's less
being stored.

00:16:17.567 --> 00:16:19.567
And we ended up actually
saving quite a bit

00:16:19.567 --> 00:16:21.133
on the size of it as well.

00:16:21.133 --> 00:16:24.234
And we went from 15
image requests to just 1,

00:16:24.234 --> 00:16:25.868
which is a big save indeed.

00:16:25.868 --> 00:16:28.367
So the saving
in the amount of dollars

00:16:28.367 --> 00:16:29.901
that you're doing here
isn't that big.

00:16:29.901 --> 00:16:31.200
The biggest saving is probably

00:16:31.200 --> 00:16:33.667
that your application
is gonna be a lot faster,

00:16:33.667 --> 00:16:35.901
which means that you're
gonna get happier users

00:16:35.901 --> 00:16:37.501
that are coming back
more often

00:16:37.501 --> 00:16:39.667
and using the application
more often as well.

00:16:41.501 --> 00:16:43.334
The last thing that
I want to cover in this bit

00:16:43.334 --> 00:16:46.400
about general web optimization
is caching headers.

00:16:46.400 --> 00:16:48.434
It's one of
the really nifty tricks.

00:16:48.434 --> 00:16:50.968
That's--your web browser
has seen this image before.

00:16:50.968 --> 00:16:53.534
It knows that it's still
valid--it's local copy--

00:16:53.534 --> 00:16:54.968
so it doesn't even
have to download.

00:16:54.968 --> 00:16:56.834
It doesn't have
to connect to your server.

00:16:56.834 --> 00:16:58.300
It can just
instantly display it

00:16:58.300 --> 00:16:59.634
without having
to do any actions.

00:16:59.634 --> 00:17:01.868
So it's the ultimate
optimization trick.

00:17:01.868 --> 00:17:04.901
The downside is that
not everybody's using this yet.

00:17:04.901 --> 00:17:07.934
So when you're
using dynamic languages,

00:17:07.934 --> 00:17:09.801
you can use whatever
language you're using

00:17:09.801 --> 00:17:12.334
to set a header
with a cache control max age

00:17:12.334 --> 00:17:14.634
as some really high number
into the future

00:17:14.634 --> 00:17:17.400
to tell the web browser,
"Hey, you can save this file.

00:17:17.400 --> 00:17:19.534
You don't have to
re-download it every time."

00:17:19.534 --> 00:17:22.067
For static files, you can
configure your web server

00:17:22.067 --> 00:17:25.133
to say, well, "Hey, whenever
you find a file of this type,

00:17:25.133 --> 00:17:27.534
"just append the caching
header to it so that

00:17:27.534 --> 00:17:29.701
the browser will know
it can cache that as well."

00:17:29.701 --> 00:17:30.801
And here's a little example

00:17:30.801 --> 00:17:33.000
of how you would configure
that in Apache,

00:17:33.000 --> 00:17:34.701
where we tell it, well,
anything that matches

00:17:34.701 --> 00:17:35.901
against the stylesheet--

00:17:35.901 --> 00:17:38.868
a JavaScript, a GIF file,
a JPEG, or a BMG--

00:17:38.868 --> 00:17:41.501
just append this
cache control header to it,

00:17:41.501 --> 00:17:44.000
and you can cache it for about
two years into the future.

00:17:44.000 --> 00:17:46.801
Now one of the things
that you might be worried about

00:17:46.801 --> 00:17:50.300
is, so if I change my CSS file,
my JavaScript file,

00:17:50.300 --> 00:17:52.667
howdo I tell the browser
to download it again?

00:17:52.667 --> 00:17:54.868
That's what we're using
cache-busting techniques for.

00:17:54.868 --> 00:17:56.501
And that's
basically appending, like,

00:17:56.501 --> 00:17:59.534
a version is some number
after the query screen.

00:17:59.534 --> 00:18:00.834
And the browser will
know, like,

00:18:00.834 --> 00:18:02.367
"Hey, this is
a different year row,"

00:18:02.367 --> 00:18:04.834
and download it again, and then
cache it again for two years.

00:18:08.501 --> 00:18:10.634
Roomann-Kurrik:
The next section that I'd like

00:18:10.634 --> 00:18:14.033
to talk about is beyond
normal web optimizations.

00:18:14.033 --> 00:18:15.701
What are the optimizations
that you can do

00:18:15.701 --> 00:18:18.901
because you're actually
running on a social network?

00:18:18.901 --> 00:18:20.734
So things that
the network servers

00:18:20.734 --> 00:18:23.133
are actually
gonna help you out with.

00:18:23.133 --> 00:18:25.934
Um, there's certainly
a good reason

00:18:25.934 --> 00:18:27.400
why they would
want to help you out--

00:18:27.400 --> 00:18:28.901
is because if
you have a social gadget

00:18:28.901 --> 00:18:31.234
and a small tweak
will make a significant

00:18:31.234 --> 00:18:32.801
impact on your revenue--

00:18:32.801 --> 00:18:35.367
If you're a social network
you've got the aggregate benefit

00:18:35.367 --> 00:18:36.701
of all of those tweaks,

00:18:36.701 --> 00:18:39.000
so if you can force
some of them to happen

00:18:39.000 --> 00:18:43.501
then obviously it's in their
best interests even more so.

00:18:43.501 --> 00:18:45.968
Some of the advantages
that a social network has

00:18:45.968 --> 00:18:47.133
that you don't really have

00:18:47.133 --> 00:18:49.701
is that they can control
what HTML they output.

00:18:49.701 --> 00:18:51.834
So even though
you're writing a gadget spec

00:18:51.834 --> 00:18:53.901
in an XML file and et cetera,

00:18:53.901 --> 00:18:55.934
eventually that
gets rendered into HTML

00:18:55.934 --> 00:18:57.501
and gets put out
by the social network.

00:18:57.501 --> 00:19:01.334
So they can really control
what content they deliver.

00:19:01.334 --> 00:19:04.300
And then second of all,
is that social networks

00:19:04.300 --> 00:19:07.834
usually will have better
infrastructure than your app.

00:19:07.834 --> 00:19:10.033
You know, they probably
have servers around the globe

00:19:10.033 --> 00:19:13.067
that they can use
to optimize requests

00:19:13.067 --> 00:19:15.701
and pages that
are served to their users.

00:19:15.701 --> 00:19:18.801
So along that line,

00:19:18.801 --> 00:19:22.901
OpenSocial offers a feature
called a Static Content Proxy.

00:19:22.901 --> 00:19:25.300
The idea is that
a social network is willing

00:19:25.300 --> 00:19:27.133
to absorb some
traffic for you, right?

00:19:27.133 --> 00:19:29.834
They're actually willing to host
some files on your behalf.

00:19:29.834 --> 00:19:31.834
And there's nothing you
really need to do to sign up

00:19:31.834 --> 00:19:35.434
or use this, except rewrite
one of--some of your URLs

00:19:35.434 --> 00:19:37.000
to take advantage of
this service.

00:19:37.000 --> 00:19:40.667
Some social networks host
these files on CDNs,

00:19:40.667 --> 00:19:42.234
which are
Content Delivery Networks.

00:19:42.234 --> 00:19:44.601
Basically, it's a
set of distributed servers

00:19:44.601 --> 00:19:46.067
that are
very heavily optimized

00:19:46.067 --> 00:19:49.567
for delivering static images
and assets to your end users.

00:19:49.567 --> 00:19:51.367
So first of all,
these servers are very close

00:19:51.367 --> 00:19:52.534
to your end users.

00:19:52.534 --> 00:19:54.968
And then when
the user requests an image,

00:19:54.968 --> 00:19:56.901
or a flash file,
or whatever,

00:19:56.901 --> 00:19:59.868
it actually goes to
a server that's closest to it

00:19:59.868 --> 00:20:03.067
and then the latency
is much quicker.

00:20:03.067 --> 00:20:06.701
This is really important when
your home servers are,

00:20:06.701 --> 00:20:08.267
like, centrally located.

00:20:08.267 --> 00:20:09.934
So for example, if you're
running a server

00:20:09.934 --> 00:20:11.601
here in San Francisco,
and you have

00:20:11.601 --> 00:20:13.033
a lot of users
in Brazil and India,

00:20:13.033 --> 00:20:15.400
instead of coming all the way
to your server to get data,

00:20:15.400 --> 00:20:19.100
they can actually go to a CDN
or whatever in India,

00:20:19.100 --> 00:20:21.234
and the experience is
vastly improved

00:20:21.234 --> 00:20:22.734
for most of those users.

00:20:22.734 --> 00:20:25.601
And the simple call
to do this inside of a gadget

00:20:25.601 --> 00:20:28.934
is to call
"gadgets.io.getProxyUrl."

00:20:28.934 --> 00:20:31.968
And that will just basically
take whatever URL you give it

00:20:31.968 --> 00:20:34.567
and put it on
this Static Content host.

00:20:34.567 --> 00:20:37.267
Naturally, you want
to keep in mind, though,

00:20:37.267 --> 00:20:38.868
that anything
that's hosted on this way

00:20:38.868 --> 00:20:41.701
is not gonna touch
your server or anything.

00:20:41.701 --> 00:20:44.300
So it'll be hit
the first time it's requested,

00:20:44.300 --> 00:20:45.968
but then after that
it'll probably

00:20:45.968 --> 00:20:47.868
effectively be cached
for a long time.

00:20:47.868 --> 00:20:50.634
So only put
stuff that really can--

00:20:50.634 --> 00:20:53.267
doesn't need to be dynamically
modified on each page render.

00:20:53.267 --> 00:20:57.501
Uh, secondly,
the social network controls

00:20:57.501 --> 00:21:00.300
what HTML it outputs
to the browser.

00:21:00.300 --> 00:21:02.167
So that means
that even though you say

00:21:02.167 --> 00:21:04.133
that there needs
to be an image file here

00:21:04.133 --> 00:21:06.701
and a JavaScript file there
and CSS there,

00:21:06.701 --> 00:21:08.934
they can actually
make some optimizations

00:21:08.934 --> 00:21:12.167
that will improve
the speed of your gadget

00:21:12.167 --> 00:21:14.267
without you even really
needing to be aware

00:21:14.267 --> 00:21:16.234
of certain optimizations.

00:21:16.234 --> 00:21:17.767
For example,
one thing that they'll do

00:21:17.767 --> 00:21:19.167
is concatenate
JavaScript files.

00:21:19.167 --> 00:21:20.667
So--like Chris mentioned.

00:21:20.667 --> 00:21:23.133
Another thing that they'll do
is run minification programs

00:21:23.133 --> 00:21:24.667
on the concatenated result.

00:21:24.667 --> 00:21:26.567
And then a third thing
they'll do is, you know,

00:21:26.567 --> 00:21:28.601
rearrange elements
in the page to make them

00:21:28.601 --> 00:21:30.200
more optimal for the browser.

00:21:30.200 --> 00:21:33.567
So things like putting
CSS at the top of the page

00:21:33.567 --> 00:21:35.300
so that the browser
gets it first

00:21:35.300 --> 00:21:38.067
and doesn't have to re-render
after it gets additional CSS.

00:21:38.067 --> 00:21:39.834
Or putting JavaScript
at the end of the page,

00:21:39.834 --> 00:21:42.634
so that it executes
after all the DOM is loaded.

00:21:42.634 --> 00:21:46.734
And it just delivers
a better experience, sorry.

00:21:46.734 --> 00:21:50.767
Naturally, this leads
to a little bit of confusion

00:21:50.767 --> 00:21:53.367
for app developers who
all of a sudden find themselves

00:21:53.367 --> 00:21:55.968
on a container that's doing
these kinds of optimizations.

00:21:55.968 --> 00:21:58.234
So say there's an image
that needs to be different

00:21:58.234 --> 00:22:00.334
every time the page
is loaded or something.

00:22:00.334 --> 00:22:02.000
You can actually opt-out
of having

00:22:02.000 --> 00:22:05.033
certain URLs and tags
be rewritten.

00:22:05.033 --> 00:22:07.567
And this little snippet here
just kind of shows

00:22:07.567 --> 00:22:10.467
how you can declaratively
adjust this rewriting.

00:22:10.467 --> 00:22:13.767
You have the option to include
URLs that need to be rewritten.

00:22:13.767 --> 00:22:16.067
You can have
the option to exclude URLs.

00:22:16.067 --> 00:22:18.834
And it'll take a glob pattern,
so you can just kind of

00:22:18.834 --> 00:22:21.767
define a pattern that should
be rewritten or should not be.

00:22:23.634 --> 00:22:26.200
Keeping in the vein
of things that you can do

00:22:26.200 --> 00:22:27.834
as an OpenSocial
application developer

00:22:27.834 --> 00:22:29.834
that you can't do
as a website developer,

00:22:29.834 --> 00:22:31.367
there's
a whole bunch of features

00:22:31.367 --> 00:22:34.300
that OpenSocial
kind of gives you.

00:22:34.300 --> 00:22:36.734
And the reason
it gives you these

00:22:36.734 --> 00:22:39.234
is certain optimizations
only make sense

00:22:39.234 --> 00:22:40.834
when you're
running a social app.

00:22:40.834 --> 00:22:44.334
And so when the OpenSocial
spec was created,

00:22:44.334 --> 00:22:47.334
a lot of conveniences
and functionality

00:22:47.334 --> 00:22:49.467
was put in just
with the thought that

00:22:49.467 --> 00:22:51.067
"Hey, we're gonna
have a lot of users

00:22:51.067 --> 00:22:53.167
"running apps that have
millions and millions

00:22:53.167 --> 00:22:55.167
"of users accessing them.

00:22:55.167 --> 00:22:59.601
So we'll make it easier
for developers at that scale."

00:22:59.601 --> 00:23:01.367
One thing that
I'd like to point out

00:23:01.367 --> 00:23:03.601
is that when you
examine the OpenSocial API,

00:23:03.601 --> 00:23:05.567
a lot of it seems
like it's a little bit

00:23:05.567 --> 00:23:08.133
possibly confusing,
or whatever.

00:23:08.133 --> 00:23:12.334
But a lot of the decisions were
made for the scaling reasons.

00:23:12.334 --> 00:23:14.100
And so when you're
designing your own APIs,

00:23:14.100 --> 00:23:15.467
like we did with Quartermile,

00:23:15.467 --> 00:23:17.167
we actually took
advantage of some of these

00:23:17.167 --> 00:23:19.601
and kind of mimicked
what was going on.

00:23:19.601 --> 00:23:22.634
For example, we
took advantage of batching.

00:23:22.634 --> 00:23:25.901
So the idea is that you
want to minimize HTTP requests.

00:23:25.901 --> 00:23:29.100
So whenever you're
doing a social call,

00:23:29.100 --> 00:23:30.834
if you do it incorrectly,

00:23:30.834 --> 00:23:33.567
then it'll be
causing one HTTP request

00:23:33.567 --> 00:23:35.000
each time
you make the call.

00:23:35.000 --> 00:23:38.200
So the first example here
is actually four lines of code

00:23:38.200 --> 00:23:39.801
that sends four HTTP requests.

00:23:39.801 --> 00:23:42.467
That's not optimal at all.

00:23:42.467 --> 00:23:45.067
It's actually--there's
a whole lot of reasons

00:23:45.067 --> 00:23:46.234
why this would be bad.

00:23:46.234 --> 00:23:50.801
But basically, what you
can do to alleviate this

00:23:50.801 --> 00:23:53.033
is do as much as you can
in a single trip.

00:23:53.033 --> 00:23:55.934
So you make a batch operation,

00:23:55.934 --> 00:23:57.000
and you add requests to it,

00:23:57.000 --> 00:23:58.801
and then you execute the batch.

00:23:58.801 --> 00:24:00.334
And then that
sends all of the requests

00:24:00.334 --> 00:24:01.767
together in one payload.

00:24:01.767 --> 00:24:04.334
The server processes it
all at once on it's backend

00:24:04.334 --> 00:24:06.767
and then sends you back all of
the responses at the same time.

00:24:06.767 --> 00:24:09.234
You're only really waiting
for one request to process.

00:24:09.234 --> 00:24:11.634
And using this approach,
we actually designed

00:24:11.634 --> 00:24:14.133
the Quartermile API to take
advantage of batching, too.

00:24:14.133 --> 00:24:15.334
So where we were making

00:24:15.334 --> 00:24:17.434
two OpenSocial requests,
we made one.

00:24:17.434 --> 00:24:20.267
And then when we made four
Quartermile API requests,

00:24:20.267 --> 00:24:22.467
we made one request also.

00:24:22.467 --> 00:24:28.200
This had the net effect
that you'll see here.

00:24:28.200 --> 00:24:29.901
It's actually
kind of interesting,

00:24:29.901 --> 00:24:32.701
because we didn't really see
what we were expecting to see

00:24:32.701 --> 00:24:35.367
when we made these
batching optimizations.

00:24:35.367 --> 00:24:38.067
One thing was latency
actually on average

00:24:38.067 --> 00:24:41.501
did increase very slightly--
like, by 13 milliseconds--

00:24:41.501 --> 00:24:45.400
which is certainly not
perceptible to the end user,

00:24:45.400 --> 00:24:48.801
but it's also not the greatest
benefit that we were expecting.

00:24:48.801 --> 00:24:51.534
And possibly part of
the reason we saw this

00:24:51.534 --> 00:24:55.067
was because we were testing
too close to our own servers.

00:24:55.067 --> 00:24:57.334
So, you know, it didn't really
make that much of a difference.

00:24:57.334 --> 00:24:59.534
Now, if you're actually
located in a position

00:24:59.534 --> 00:25:02.400
where making
HTTP requests to a server

00:25:02.400 --> 00:25:04.000
is actually very costly--

00:25:04.000 --> 00:25:07.300
For example, if you're in
a country that's several--

00:25:07.300 --> 00:25:10.334
you know, further away from
the servers, where India, like--

00:25:10.334 --> 00:25:12.267
For example,
if you were in India

00:25:12.267 --> 00:25:14.567
and you were hitting our
servers here in San Francisco,

00:25:14.567 --> 00:25:18.534
you might actually see
that number, like, increase,

00:25:18.534 --> 00:25:20.434
or you might see a better
benefit from batching.

00:25:20.434 --> 00:25:22.467
But we actually
didn't see it here.

00:25:22.467 --> 00:25:24.667
We did manage
to improve requests.

00:25:24.667 --> 00:25:26.334
So we dropped
two requests out.

00:25:26.334 --> 00:25:28.534
Actually--yeah, I guess.

00:25:28.534 --> 00:25:32.434
And we improved
the YSlow score by two points.

00:25:32.434 --> 00:25:36.033
The biggest change
that we actually saw

00:25:36.033 --> 00:25:38.133
was actually
the CPU time drops,

00:25:38.133 --> 00:25:41.434
mostly because the--Apparently
the App Engine backend

00:25:41.434 --> 00:25:44.234
had a bit of an overhead
for establishing a connection.

00:25:44.234 --> 00:25:46.334
And maybe it's the way
that we wrote the APIs,

00:25:46.334 --> 00:25:49.834
but doing many
operations in one loop--

00:25:49.834 --> 00:25:54.167
as opposed to setting up a new
HTTP connection, et cetera--

00:25:54.167 --> 00:25:57.167
will end up saving
just a little bit of CPU time.

00:25:57.167 --> 00:26:00.100
So we actually
saved $36 a month this way.

00:26:02.901 --> 00:26:06.000
Chris, yes, sir.

00:26:06.000 --> 00:26:08.434
Chabot: So with all these
optimizations in place,

00:26:08.434 --> 00:26:10.167
we're seeing
that the application

00:26:10.167 --> 00:26:11.767
is still
making a lot of requests.

00:26:11.767 --> 00:26:14.234
An OpenSocial application
gets requested

00:26:14.234 --> 00:26:16.834
by the social network site
to be rendered in step one.

00:26:16.834 --> 00:26:18.601
It will send the result back.

00:26:18.601 --> 00:26:21.367
It then will make a request
to the social network site,

00:26:21.367 --> 00:26:24.467
saying, "Hey, can you fetch some
information from a data server?"

00:26:24.467 --> 00:26:27.300
It processes that, sends it back
to the social networking site,

00:26:27.300 --> 00:26:29.367
which then gets
delivered to the gadget.

00:26:29.367 --> 00:26:32.367
So that's six steps of
sending information to and fro

00:26:32.367 --> 00:26:34.567
before you actually have
your fully rendered gadgets.

00:26:34.567 --> 00:26:36.968
So how do we improve on that?

00:26:36.968 --> 00:26:38.934
One of the really cool
new features,

00:26:38.934 --> 00:26:40.200
one of my favorite
from the new

00:26:40.200 --> 00:26:44.100
0.9 OpenSocial specification
is proxied content.

00:26:44.100 --> 00:26:46.868
Proxied content is a way
for you to be able to say,

00:26:46.868 --> 00:26:48.968
"I've got a gadget,
but the content of it

00:26:48.968 --> 00:26:50.868
"should come directly
from my server.

00:26:50.868 --> 00:26:52.434
I don't want to write it
in JavaScript."

00:26:52.434 --> 00:26:55.767
And one of the big benefits
is that it requires

00:26:55.767 --> 00:26:58.033
a lot less data
being posted around

00:26:58.033 --> 00:27:00.300
and exchanged between
all the different parties.

00:27:00.300 --> 00:27:03.934
So we went from six
different actions up to four.

00:27:03.934 --> 00:27:06.167
So your server
generates all the HTML

00:27:06.167 --> 00:27:08.634
based on the social information
that's being posted to it.

00:27:08.634 --> 00:27:10.067
That's called
the Data-Pipelining

00:27:10.067 --> 00:27:11.534
part of the specification.

00:27:11.534 --> 00:27:14.200
And there's actually
a preview version of it

00:27:14.200 --> 00:27:16.868
available on the sandboxes
from iGoogle and Orkut.

00:27:16.868 --> 00:27:19.334
So how we should
go about using this?

00:27:19.334 --> 00:27:22.033
Well, this would be
your gadget--XML style--

00:27:22.033 --> 00:27:24.634
where you define, "Hey,
I've got a contents section,

00:27:24.634 --> 00:27:26.601
"and this is the URL
where I want you

00:27:26.601 --> 00:27:29.801
to find--to fetch
the HTML for my gadget."

00:27:29.801 --> 00:27:32.267
And the part that you see inside
of the content section,

00:27:32.267 --> 00:27:34.100
those are
the data-pipelining tags.

00:27:34.100 --> 00:27:37.968
We've got a lot of documentation
on our wiki.OpenSocial site

00:27:37.968 --> 00:27:40.200
where you can find out
what tags are available,

00:27:40.200 --> 00:27:44.033
and how you can use them, and
in what ways they can be used

00:27:44.033 --> 00:27:46.334
to do all kinds of
really cool tricks with them.

00:27:46.334 --> 00:27:49.000
And then on your server
side of things

00:27:49.000 --> 00:27:51.067
where you generate the HTML,
you would receive

00:27:51.067 --> 00:27:53.734
the raw post, which is
basically a JSON blob

00:27:53.734 --> 00:27:55.400
that contains
all the social information

00:27:55.400 --> 00:27:57.834
that's being posted to your
server that you requested.

00:27:57.834 --> 00:28:00.067
So you can decode that,
and then you can just use it

00:28:00.067 --> 00:28:01.701
in your favorite
scripting language.

00:28:01.701 --> 00:28:03.667
In this case,
I'm using PHP.

00:28:03.667 --> 00:28:05.033
But you can
do this in any language

00:28:05.033 --> 00:28:07.000
that can decode a JSON string.

00:28:07.000 --> 00:28:09.300
So this way, you can
actually program something

00:28:09.300 --> 00:28:11.901
in your favorite environment,
in your favorite language,

00:28:11.901 --> 00:28:14.734
and it's gonna be really
fast and efficient as well.

00:28:14.734 --> 00:28:17.067
When we applied this
technique to Quartermile,

00:28:17.067 --> 00:28:19.367
we saw some really
substantial savings.

00:28:19.367 --> 00:28:22.067
As you can see,
the gadget latency went down

00:28:22.067 --> 00:28:25.968
from 2,700 milliseconds
to just over 1,000 milliseconds.

00:28:25.968 --> 00:28:28.033
So it's incredibly
fast and efficient.

00:28:28.033 --> 00:28:30.167
Even the total
page loading time went down

00:28:30.167 --> 00:28:31.801
by quite a substantial number.

00:28:31.801 --> 00:28:33.234
The amount of
requests we're making

00:28:33.234 --> 00:28:35.834
went down by quite a bit--
from 26 to 20.

00:28:35.834 --> 00:28:39.334
And the YSlow score shot up
by four points as well.

00:28:39.334 --> 00:28:42.067
So the total monthly savings
you would be making here

00:28:42.067 --> 00:28:45.734
is about $320
when applied to Quartermile.

00:28:45.734 --> 00:28:48.667
So one of the problems
you're gonna run into--

00:28:48.667 --> 00:28:50.634
one of the challenges,
I should say,

00:28:50.634 --> 00:28:53.167
is that the social network
site will be caching

00:28:53.167 --> 00:28:55.601
the result of the HTML
that you generated.

00:28:55.601 --> 00:28:57.434
And it will store it
based on both

00:28:57.434 --> 00:28:59.968
the user ID
and the application URL.

00:28:59.968 --> 00:29:02.534
So what happens
when your data changes?

00:29:02.534 --> 00:29:04.834
For instance, somebody posts
an activity in Quartermile.

00:29:04.834 --> 00:29:07.000
How do you tell
the social networking site

00:29:07.000 --> 00:29:08.634
to download
that information again

00:29:08.634 --> 00:29:10.934
so that you can generate
the latest information

00:29:10.934 --> 00:29:13.234
and send it to
the social networking site?

00:29:13.234 --> 00:29:15.267
That's what the
invalidation pattern is for.

00:29:15.267 --> 00:29:18.567
The invalidation pattern
is a new social endpoint

00:29:18.567 --> 00:29:21.434
where you tell it,
"I've got a URL here,

00:29:21.434 --> 00:29:23.334
"and for this user,
I want you to throw away

00:29:23.334 --> 00:29:27.033
all the cached information
and re-fetch it from my server."

00:29:27.033 --> 00:29:28.801
One of the things
that I wanted to note

00:29:28.801 --> 00:29:30.667
is that a lot
of people have asked,

00:29:30.667 --> 00:29:33.667
"So how does it know what
application this applies to?"

00:29:33.667 --> 00:29:37.067
Well, you're using a WAF to sign
the request to the server

00:29:37.067 --> 00:29:38.334
and a WAF consumer key

00:29:38.334 --> 00:29:40.434
is associated
with your application.

00:29:40.434 --> 00:29:43.234
So that's how it figures out
what its application ID is.

00:29:44.634 --> 00:29:46.100
So how would you
go about using this?

00:29:46.100 --> 00:29:49.667
You make a post
to invalidate your URL.

00:29:49.667 --> 00:29:51.801
You tell it, "Hey,
I've got a JSON blob here."

00:29:51.801 --> 00:29:53.167
And in the JSON blob,

00:29:53.167 --> 00:29:55.133
you've got the keys
that you want to invalidate.

00:29:55.133 --> 00:29:56.868
That's the invalidation keys.

00:29:56.868 --> 00:30:00.234
Now these keys can be anything,
like a URL of your gadget spec.

00:30:00.234 --> 00:30:03.767
It can be a message bundle.
It can be a user ID as well.

00:30:03.767 --> 00:30:05.367
And when you're
posting a user ID,

00:30:05.367 --> 00:30:08.234
you're telling it, "Flush
everything from your cache

00:30:08.234 --> 00:30:11.901
which is related to
my application and its users."

00:30:11.901 --> 00:30:14.934
So it will completely
clear out everything.

00:30:14.934 --> 00:30:17.767
One of the other challenges
you're going to run into

00:30:17.767 --> 00:30:19.501
when you're building
a social application

00:30:19.501 --> 00:30:21.367
that you're hoping
is going to be very popular

00:30:21.367 --> 00:30:24.400
is how to
make your database scale.

00:30:24.400 --> 00:30:27.267
Database scaling
is really important

00:30:27.267 --> 00:30:29.467
because when you're dealing
with social information

00:30:29.467 --> 00:30:31.901
you're gonna end up having
tens of millions of users

00:30:31.901 --> 00:30:33.300
if you're really lucky.

00:30:33.300 --> 00:30:35.100
So just doing
a plain query, saying,

00:30:35.100 --> 00:30:37.567
"Well, I want you to
match up all my friend lists,

00:30:37.567 --> 00:30:39.400
and match it up
against activities"--

00:30:39.400 --> 00:30:42.100
It's not going to be possible
in a normal database anymore,

00:30:42.100 --> 00:30:44.767
'cause there's gonna be too much
information stored in it.

00:30:44.767 --> 00:30:47.934
So one of the things
that I wanted to suggest

00:30:47.934 --> 00:30:50.300
is that if you're actually
building the application now--

00:30:50.300 --> 00:30:53.200
you're starting building it--
think about scaling.

00:30:53.200 --> 00:30:55.767
Think about things like
a master/slave architecture,

00:30:55.767 --> 00:30:58.434
where you've got one database
that you're doing your writes to

00:30:58.434 --> 00:31:00.133
and you've got
a number of slave nodes

00:31:00.133 --> 00:31:02.200
connected to it where you're
doing your read from.

00:31:02.200 --> 00:31:04.534
That way you can
use a lot more servers

00:31:04.534 --> 00:31:06.167
to make for a faster database.

00:31:06.167 --> 00:31:09.100
And that will get you
quite a bit of runway

00:31:09.100 --> 00:31:10.534
before you run out
of capacity.

00:31:10.534 --> 00:31:12.834
However, at some point,
replication is not

00:31:12.834 --> 00:31:14.100
gonna be efficient anymore

00:31:14.100 --> 00:31:15.701
because there's gonna
be I/O contention.

00:31:15.701 --> 00:31:17.767
There's gonna be so much
replication happening

00:31:17.767 --> 00:31:19.801
that your servers
are gonna be spending

00:31:19.801 --> 00:31:21.067
all their time on
replicating

00:31:21.067 --> 00:31:23.801
and not on providing data
to your application.

00:31:23.801 --> 00:31:26.567
So the next thing to think
about is database partitioning.

00:31:26.567 --> 00:31:29.067
Now, database partitioning
is something that you can do

00:31:29.067 --> 00:31:30.334
in a lot of ways.

00:31:30.334 --> 00:31:31.901
You can say,
"I'm gonna put my user table

00:31:31.901 --> 00:31:34.934
"in one database set, and I'm
gonna put my activities table

00:31:34.934 --> 00:31:35.934
in another database set."

00:31:35.934 --> 00:31:37.200
That's step one.

00:31:37.200 --> 00:31:38.934
But after a while,
you need to partition out

00:31:38.934 --> 00:31:40.367
those things as well

00:31:40.367 --> 00:31:43.300
and say, "Well, everything
from user ID 0 to 1 million

00:31:43.300 --> 00:31:45.334
"I'm gonna put
in one set of databases.

00:31:45.334 --> 00:31:47.901
"And everything from user ID
1 million to 2 million

00:31:47.901 --> 00:31:50.067
I'm gonna put in
another set of databases."

00:31:50.067 --> 00:31:51.501
Et cetera, et cetera.

00:31:51.501 --> 00:31:53.801
This should give you a lot of
runway and a lot of scalability.

00:31:53.801 --> 00:31:56.434
And the good news is that if you
are building on an app engine,

00:31:56.434 --> 00:31:58.033
like we did with Quartermile,

00:31:58.033 --> 00:32:00.133
all of this will have already
been figured out for you.

00:32:00.133 --> 00:32:02.200
And Google's provided all this
functionality

00:32:02.200 --> 00:32:03.400
already in BigTable.

00:32:03.400 --> 00:32:04.734
So you don't
have to worry too much

00:32:04.734 --> 00:32:06.901
about the scalability issues.

00:32:06.901 --> 00:32:10.334
The other thing that does apply
for App Engine users as well

00:32:10.334 --> 00:32:12.334
is to use memcache a lot.

00:32:12.334 --> 00:32:14.367
Cache everything that you can.

00:32:14.367 --> 00:32:16.734
So when you're generating
something from a database

00:32:16.734 --> 00:32:18.167
that's gonna
be used more often--

00:32:18.167 --> 00:32:20.434
like a list of activities,
or a list of friends--

00:32:20.434 --> 00:32:22.167
get it out of the database

00:32:22.167 --> 00:32:24.067
and then store it
in your data cache.

00:32:24.067 --> 00:32:26.000
That way, the next time
that you need that list,

00:32:26.000 --> 00:32:27.701
you can just
retrieve it from memory

00:32:27.701 --> 00:32:29.701
without having
to do an expensive query.

00:32:29.701 --> 00:32:31.868
And that's gonna
be quite an optimization.

00:32:31.868 --> 00:32:34.334
Another thing that
I wanted to mention is that

00:32:34.334 --> 00:32:36.400
when you are using those kind
of caching techniques,

00:32:36.400 --> 00:32:37.968
there might
be situations where you're,

00:32:37.968 --> 00:32:39.734
for instance,
you're looking for a user name

00:32:39.734 --> 00:32:42.234
starting with an "A"
in a friend list.

00:32:42.234 --> 00:32:43.434
So what you do
is you retrieve

00:32:43.434 --> 00:32:45.234
the entire friend list
from cache--

00:32:45.234 --> 00:32:47.167
which is an efficient
way of storing it, there--

00:32:47.167 --> 00:32:48.934
and then filter it
in the software

00:32:48.934 --> 00:32:51.000
instead of actually
doing another caching set,

00:32:51.000 --> 00:32:52.868
because then you're
gonna run out of memory,

00:32:52.868 --> 00:32:55.601
and that's gonna be
costly in the large scale.

00:32:55.601 --> 00:32:58.334
So software filtering
might feel unnatural

00:32:58.334 --> 00:32:59.734
when you use the databases,

00:32:59.734 --> 00:33:02.000
but when you're dealing
with large scale applications,

00:33:02.000 --> 00:33:04.167
it becomes almost a necessity.

00:33:04.167 --> 00:33:08.767
The last trick is by storing
information in JSON blobs,

00:33:08.767 --> 00:33:11.234
and this is something
that sites like Flickr

00:33:11.234 --> 00:33:13.834
but also applications
like iLike are doing.

00:33:13.834 --> 00:33:16.200
When you have large lists
of pictures, of movies,

00:33:16.200 --> 00:33:18.667
or music files, or whatever,

00:33:18.667 --> 00:33:21.400
joining up those tables
becomes very expensive.

00:33:21.400 --> 00:33:22.901
Then you'd be
talking about things

00:33:22.901 --> 00:33:26.100
like row overhead
and integer matchings and--

00:33:26.100 --> 00:33:28.400
So what you can do
is you take this playlist,

00:33:28.400 --> 00:33:31.200
and instead of storing it
in a standard database

00:33:31.200 --> 00:33:34.467
fashioned with IDs that
are relational to each other,

00:33:34.467 --> 00:33:38.033
you just store adjacent blob
structure in a database

00:33:38.033 --> 00:33:40.400
in a single entry with
the entire playlist in it.

00:33:40.400 --> 00:33:43.234
This way, you don't have
to do your relational matching

00:33:43.234 --> 00:33:46.567
and things are
gonna be a lot quicker.

00:33:46.567 --> 00:33:49.901
One of the other ways of dealing
with lots of information

00:33:49.901 --> 00:33:51.234
is background processing.

00:33:51.234 --> 00:33:53.334
At some point,
if people have hundreds

00:33:53.334 --> 00:33:54.534
of thousands of friends,

00:33:54.534 --> 00:33:56.501
it's just not
gonna be efficient anymore

00:33:56.501 --> 00:33:58.834
to go to your database
and query it for.

00:33:58.834 --> 00:34:02.434
"Hey, did my million friends do
something in the last 24 hours?"

00:34:02.434 --> 00:34:05.601
So instead what you could do
is use background processing.

00:34:05.601 --> 00:34:09.100
Background processing means
you store something in a queue,

00:34:09.100 --> 00:34:10.767
saying, "Hey,
there's been an activity."

00:34:10.767 --> 00:34:14.200
And another process on another
server will pick that up

00:34:14.200 --> 00:34:16.701
and slowly process through
all those activities,

00:34:16.701 --> 00:34:18.634
creating
the end results for you.

00:34:18.634 --> 00:34:20.234
And those end results are
actually stored

00:34:20.234 --> 00:34:22.901
in the database
or in your caching server.

00:34:22.901 --> 00:34:25.367
And the frontend application
just reached those results

00:34:25.367 --> 00:34:27.367
and without
actually calculating them.

00:34:27.367 --> 00:34:29.767
The good thing is that
this way you can prioritize it.

00:34:29.767 --> 00:34:31.567
You can use
different servers for it.

00:34:31.567 --> 00:34:34.100
You can say, "Well, this
is a really important activity

00:34:34.100 --> 00:34:36.234
"that I need you to do
right now while other things

00:34:36.234 --> 00:34:37.934
are okay to be delayed."

00:34:37.934 --> 00:34:40.067
So this gives you
a lot of design flexibility

00:34:40.067 --> 00:34:42.634
to make
a high volume data situation.

00:34:42.634 --> 00:34:46.267
Another benefit is that it
doesn't block user interaction.

00:34:46.267 --> 00:34:48.567
If we enter something
in Quartermile saying,

00:34:48.567 --> 00:34:50.367
"I ran for two miles
yesterday,"

00:34:50.367 --> 00:34:52.467
you don't want
the whole user interface

00:34:52.467 --> 00:34:55.133
to freeze for ten seconds
while it's updating

00:34:55.133 --> 00:34:56.534
all of those activity tables.

00:34:56.534 --> 00:34:58.267
So by putting
this in the background

00:34:58.267 --> 00:34:59.868
and putting it
in a different system,

00:34:59.868 --> 00:35:01.968
you're not
blocking end users either.

00:35:01.968 --> 00:35:06.734
The only downside is that users
see updates a little bit later

00:35:06.734 --> 00:35:09.000
because you're waiting
for the whole background process

00:35:09.000 --> 00:35:11.601
to pick it up and digest it
into its system.

00:35:11.601 --> 00:35:14.000
So updates might
be delayed by a few minutes.

00:35:14.000 --> 00:35:16.968
But again, that's
definitely a price worth paying

00:35:16.968 --> 00:35:20.767
to be able to scale up
to much larger data volumes.

00:35:20.767 --> 00:35:22.567
When you have your own server,
there's a lot of

00:35:22.567 --> 00:35:24.334
off-the-shelf
and open source systems

00:35:24.334 --> 00:35:25.601
that can do this for you.

00:35:25.601 --> 00:35:27.934
You could also write
your own script very easily

00:35:27.934 --> 00:35:30.200
inwhatever scripting language
you want to use.

00:35:30.200 --> 00:35:31.434
If you're on App Engine,

00:35:31.434 --> 00:35:34.701
we are gonna do
background processes soonish.

00:35:34.701 --> 00:35:37.667
Until then, you can use
a crontab, for instance.

00:35:37.667 --> 00:35:40.234
In App Engine you can
create a cron.yaml file

00:35:40.234 --> 00:35:42.067
and tell it, "Well,
I want you to process

00:35:42.067 --> 00:35:44.267
all activities
every one minute."

00:35:44.267 --> 00:35:46.067
And that process
can check your queue,

00:35:46.067 --> 00:35:47.667
and if there's
something to digest,

00:35:47.667 --> 00:35:49.300
it can do its manipulation

00:35:49.300 --> 00:35:51.400
and then store
the result in a database.

00:35:51.400 --> 00:35:54.767
And you've got a queuing system
even on a cron-type solution.

00:35:56.400 --> 00:35:58.567
Roomann-Kurrik:
So I'd actually would like

00:35:58.567 --> 00:36:00.334
to bring that in
and then talk about--

00:36:00.334 --> 00:36:02.200
when we were
designing Quartermile,

00:36:02.200 --> 00:36:04.601
we actually had a planning
session and sat down,

00:36:04.601 --> 00:36:07.200
and kind of thought,
"Well, how do we structure

00:36:07.200 --> 00:36:10.567
a datastore on App Engine
for a social application?"

00:36:10.567 --> 00:36:13.133
One of the first tenets
that we kind of came up with

00:36:13.133 --> 00:36:16.567
for how--or like, what we
really wanted to adhere to was

00:36:16.567 --> 00:36:19.467
to prefer to
enforce hard limits up front

00:36:19.467 --> 00:36:21.234
than deliver
a poor user experience.

00:36:21.234 --> 00:36:23.801
Basically saying that
if we have to limit it,

00:36:23.801 --> 00:36:27.000
limit certain users
in order to make

00:36:27.000 --> 00:36:29.200
everyone's experience
consistent and good.

00:36:29.200 --> 00:36:31.334
We're willing to do that.

00:36:31.334 --> 00:36:34.234
Also one of the first
decisions that we made

00:36:34.234 --> 00:36:36.868
was that friend joins
were very expensive, right?

00:36:36.868 --> 00:36:38.434
We looked at
the numbers for Orkut,

00:36:38.434 --> 00:36:40.334
and Orkut lets you
have 1,000 friends.

00:36:40.334 --> 00:36:43.000
Now, joining in 1,000
records may be possible.

00:36:43.000 --> 00:36:46.667
It's more difficult on
App Engine than, say, MySQL.

00:36:46.667 --> 00:36:48.734
But then we looked at MySpace,

00:36:48.734 --> 00:36:50.300
and you can have
hundreds of thousands,

00:36:50.300 --> 00:36:52.801
or you know, even
a million friends on MySpace.

00:36:52.801 --> 00:36:56.601
So basically,
we said no, that--

00:36:56.601 --> 00:37:00.067
we can't just arbitrarily share
data with every single person--

00:37:00.067 --> 00:37:02.501
every single friend of a user.

00:37:02.501 --> 00:37:05.901
Thankfully we were working
on a fitness application.

00:37:05.901 --> 00:37:07.601
You know, we came up
with that fairly early

00:37:07.601 --> 00:37:10.434
and said, "Do all 100,000
of my friends

00:37:10.434 --> 00:37:13.334
really need to see that
I did ten push-ups yesterday?"

00:37:13.334 --> 00:37:15.701
At least, do they
need to see it right away

00:37:15.701 --> 00:37:17.601
the second that I
put it into the system?

00:37:17.601 --> 00:37:20.167
So, uh, we said no
and decided,

00:37:20.167 --> 00:37:21.767
"Hey, maybe there's,
like, a team of people

00:37:21.767 --> 00:37:23.634
that you'd prefer
to work out with."

00:37:23.634 --> 00:37:26.534
So certainly, like, drawing
from my own experiences,

00:37:26.534 --> 00:37:28.701
sometimes there's just certain
people that you want to tell,

00:37:28.701 --> 00:37:30.834
"Hey, I just went
out for a seven mile run."

00:37:30.834 --> 00:37:32.167
But I don't
want to tell everyone,

00:37:32.167 --> 00:37:33.501
not right away at least.

00:37:33.501 --> 00:37:36.100
So we have this team system.

00:37:36.100 --> 00:37:38.601
We basically said that
when you first use the app,

00:37:38.601 --> 00:37:41.033
you have to either
pick a team or join a team.

00:37:41.033 --> 00:37:43.434
And then you can invite
your friends to, you know,

00:37:43.434 --> 00:37:44.801
have them join
your team as well.

00:37:44.801 --> 00:37:46.968
And you saw there with
the video that I demoed earlier.

00:37:46.968 --> 00:37:48.868
The side effect
of the team system is that

00:37:48.868 --> 00:37:51.133
because you have to invite
someone to your team,

00:37:51.133 --> 00:37:53.801
you're also implicitly inviting
them to use the application.

00:37:53.801 --> 00:37:56.367
So there's actually more
growth potential here too.

00:37:58.567 --> 00:37:59.934
So then
we started writing down

00:37:59.934 --> 00:38:02.033
what were the goals
for performance, right?

00:38:02.033 --> 00:38:04.400
We were using App Engine,
so we decided that we wanted

00:38:04.400 --> 00:38:07.667
to fetch all of the team's
data for a given week

00:38:07.667 --> 00:38:09.100
in one database query,
right?

00:38:09.100 --> 00:38:10.634
Because there's
limits on App Engine.

00:38:10.634 --> 00:38:13.234
You can only return
1,000 results max.

00:38:13.234 --> 00:38:15.534
So that was a nice limit
that we had to work with.

00:38:15.534 --> 00:38:17.701
If you were using MySQL,
maybe you would restructure it

00:38:17.701 --> 00:38:19.267
as a goal in a different way.

00:38:19.267 --> 00:38:23.634
Maybe you'd say the query
to get all of the team's data

00:38:23.634 --> 00:38:25.868
for a given week has to
return a certain number of--

00:38:25.868 --> 00:38:27.968
a certain amount
of time, for example.

00:38:27.968 --> 00:38:30.701
So the question is, how many
users can we put on a team

00:38:30.701 --> 00:38:32.434
knowing that
we have 1,000 results?

00:38:32.434 --> 00:38:34.234
And it's a pretty
simple calculation, right?

00:38:34.234 --> 00:38:36.434
We have 1,000 entries
return max.

00:38:36.434 --> 00:38:39.267
We are storing
one workout per entry,

00:38:39.267 --> 00:38:40.501
or one entry per workout.

00:38:40.501 --> 00:38:42.367
And we figured
that if you're working out

00:38:42.367 --> 00:38:45.601
three times a day,
that's about 20 updates a week--

00:38:45.601 --> 00:38:47.267
uh, you know, 21 really.

00:38:47.267 --> 00:38:49.968
But--and then, if you're working
out more than three times a day,

00:38:49.968 --> 00:38:52.167
then you're probably not, like,
having enough time to do

00:38:52.167 --> 00:38:54.567
all the social application stuff
that you're doing anyways.

00:38:54.567 --> 00:38:57.834
So fair enough,
we know our audience.

00:38:57.834 --> 00:39:01.300
1,000 results divided
by 20 updates a week

00:39:01.300 --> 00:39:03.334
means you can have
50 users a team.

00:39:03.334 --> 00:39:06.234
And when we do this query,
we can be guaranteed

00:39:06.234 --> 00:39:08.300
that in
a single datastore fetch,

00:39:08.300 --> 00:39:09.501
we can return all the results

00:39:09.501 --> 00:39:11.567
that we need to show
for a single view.

00:39:13.767 --> 00:39:17.234
Obviously not every app can have
this sort of limitation on--

00:39:17.234 --> 00:39:18.868
imposed on itself.

00:39:18.868 --> 00:39:21.467
So we did it hypothetically,

00:39:21.467 --> 00:39:23.300
do the implement--
the updates from your friends.

00:39:23.300 --> 00:39:25.667
You know, we wanted to say,
"How can we show what

00:39:25.667 --> 00:39:27.434
our friends
have been working on?"

00:39:27.434 --> 00:39:29.634
Certainly this
is a very slow query,

00:39:29.634 --> 00:39:32.901
slower depending on the number
of friends that you have.

00:39:32.901 --> 00:39:35.167
So what you basically
have to do is

00:39:35.167 --> 00:39:38.267
is use the OpenSocial REST APIs,
fetch it from App Engine,

00:39:38.267 --> 00:39:40.167
fetch all of the user's
friends from App Engine,

00:39:40.167 --> 00:39:41.801
see which ones
were updated recently,

00:39:41.801 --> 00:39:43.033
then sort the whole list

00:39:43.033 --> 00:39:45.601
and then return
that to the end user.

00:39:45.601 --> 00:39:49.100
Even if you're displaying only,
you know, the last ten updates,

00:39:49.100 --> 00:39:50.901
you still have to do this
for the entire list

00:39:50.901 --> 00:39:52.868
just to be sure that
you have the data there.

00:39:52.868 --> 00:39:56.100
So what we did was,
again, using cron,

00:39:56.100 --> 00:39:57.968
processed
this kind of information

00:39:57.968 --> 00:39:59.400
in the background
of App Engine--

00:39:59.400 --> 00:40:02.234
doing the fetch,
doing the calculation.

00:40:02.234 --> 00:40:04.234
And then
we decided that, hey--

00:40:04.234 --> 00:40:07.334
following Chris' advice,
we're going to store the results

00:40:07.334 --> 00:40:09.634
of this calculation
kind of in a big blob.

00:40:09.634 --> 00:40:13.033
But we had a few options
on where to put it.

00:40:13.033 --> 00:40:15.601
We could've put it
in the datastore again,

00:40:15.601 --> 00:40:17.300
and just
it would've been one fetch

00:40:17.300 --> 00:40:19.734
to return this
whole friends calculation.

00:40:19.734 --> 00:40:21.567
We could've
put it in memcache.

00:40:21.567 --> 00:40:22.834
It would've been even faster.

00:40:22.834 --> 00:40:24.300
It would've been
hosted in RAM.

00:40:24.300 --> 00:40:28.367
But we didn't really want
the overhead of one HTTP fetch,

00:40:28.367 --> 00:40:31.634
so we actually decided
to use OpenSocial App Data

00:40:31.634 --> 00:40:33.300
as a place to store it.

00:40:33.300 --> 00:40:35.467
Now, I love App Data.

00:40:35.467 --> 00:40:39.567
I think App Data is one of the
most misunderstood and misused

00:40:39.567 --> 00:40:41.767
portions of
the OpenSocial specification.

00:40:41.767 --> 00:40:43.801
Certainly I have
a quote to back that up

00:40:43.801 --> 00:40:45.400
because it's right there.

00:40:45.400 --> 00:40:49.167
But to be...
[chuckles]

00:40:49.167 --> 00:40:52.534
Uh, to be fair,
it's very fast.

00:40:52.534 --> 00:40:57.167
There's no fetch from
the gadget to your application

00:40:57.167 --> 00:40:59.501
when you're using App Data
as a store for data.

00:40:59.501 --> 00:41:01.501
That's because it's hosted on
the container site,

00:41:01.501 --> 00:41:03.234
and the container injects it
into the gadget

00:41:03.234 --> 00:41:04.667
when it gets rendered.

00:41:04.667 --> 00:41:07.767
So people misuse it
because they expect it

00:41:07.767 --> 00:41:09.067
to work
like a normal datastore

00:41:09.067 --> 00:41:11.033
that you'd have locally
on your own server.

00:41:11.033 --> 00:41:13.534
It's--they want
to put secrets in there.

00:41:13.534 --> 00:41:16.767
They want to, you know,
store passwords or credentials.

00:41:16.767 --> 00:41:18.434
They also want to store things

00:41:18.434 --> 00:41:20.501
like top scores
for the entire app.

00:41:20.501 --> 00:41:22.033
And you know,
oh, I want to put

00:41:22.033 --> 00:41:24.834
all my data that can't
be modified in there.

00:41:24.834 --> 00:41:28.000
And to be fair, it's
not really designed for that.

00:41:28.000 --> 00:41:30.000
It's public,
so anyone can see it.

00:41:30.000 --> 00:41:31.300
So if you put
a password in there,

00:41:31.300 --> 00:41:32.801
they can see
your password as well.

00:41:32.801 --> 00:41:35.000
It's also user writeable
via JavaScript.

00:41:35.000 --> 00:41:38.601
So even if you only code in
certain practices

00:41:38.601 --> 00:41:40.133
into the JavaScript
of your gadget,

00:41:40.133 --> 00:41:42.000
if you're using JavaScript
to write it

00:41:42.000 --> 00:41:44.200
to the app--App Data
on the container,

00:41:44.200 --> 00:41:46.634
then the end user
can modify that in Firebug

00:41:46.634 --> 00:41:48.901
and just put in
whatever they want.

00:41:48.901 --> 00:41:50.801
So if you're storing
something like a top score,

00:41:50.801 --> 00:41:53.868
that's arbitrarily
changeable.

00:41:53.868 --> 00:41:56.534
But what it's
really good for is storing

00:41:56.534 --> 00:41:59.167
this kind of rendered
bulk data as a cache.

00:41:59.167 --> 00:42:02.033
Because what it--it's injected
directly into the page

00:42:02.033 --> 00:42:03.801
when the page
is first loaded,

00:42:03.801 --> 00:42:04.934
and then you
can just call it

00:42:04.934 --> 00:42:06.200
and dump it
into a DIV element.

00:42:06.200 --> 00:42:07.601
So if you want to
store HTML in there,

00:42:07.601 --> 00:42:10.734
it's a very, very quick write
to display that HTML.

00:42:10.734 --> 00:42:13.267
There's almost
no overhead, essentially,

00:42:13.267 --> 00:42:16.200
when you're doing that.

00:42:17.801 --> 00:42:19.701
Um...

00:42:19.701 --> 00:42:23.200
Talking about different
strategies and limitations,

00:42:23.200 --> 00:42:27.501
there's certain optimizations
that will be forced upon you.

00:42:27.501 --> 00:42:29.434
And really,
if you think about it,

00:42:29.434 --> 00:42:31.801
there's certain things
as an app developer

00:42:31.801 --> 00:42:33.467
that I'm sure
you'd love to do,

00:42:33.467 --> 00:42:35.367
and the container's just
not gonna have any of it

00:42:35.367 --> 00:42:37.100
and not gonna
let you do anything.

00:42:37.100 --> 00:42:40.467
Certainly Quartermile
is a great example of this.

00:42:40.467 --> 00:42:45.267
So that the Naive implementation
made a few performance mistakes.

00:42:45.267 --> 00:42:47.667
We've already cut down
the performance by quite a bit.

00:42:47.667 --> 00:42:50.701
The container, like
we were talking about before,

00:42:50.701 --> 00:42:51.968
has a vested interest
in keeping

00:42:51.968 --> 00:42:54.100
the gadgets
that it's hosting fast.

00:42:54.100 --> 00:42:57.701
Obviously the user
sees the overall performance

00:42:57.701 --> 00:43:01.067
of the container,
and even if a certain gadget

00:43:01.067 --> 00:43:03.868
is slowing that down,
then the perception is

00:43:03.868 --> 00:43:05.567
that the container is slow.

00:43:05.567 --> 00:43:09.400
And so containers
might start influencing--

00:43:09.400 --> 00:43:11.868
or implementing constraints
to keep users honest.

00:43:11.868 --> 00:43:15.033
We actually
had two containers that

00:43:15.033 --> 00:43:18.434
we ran into challenges with--

00:43:18.434 --> 00:43:20.434
or maybe not challenges,
but just we had

00:43:20.434 --> 00:43:23.300
to be aware of limitations.

00:43:23.300 --> 00:43:26.000
So for example, the iGoogle--

00:43:26.000 --> 00:43:29.267
iGoogle is soon to be
instating a latency policy

00:43:29.267 --> 00:43:30.400
on their gadgets.

00:43:30.400 --> 00:43:32.534
Basically that
when you have a gadget

00:43:32.534 --> 00:43:34.534
that's running in iGoogle,
in the directory,

00:43:34.534 --> 00:43:37.267
there will be a little marker
next to it in the directory,

00:43:37.267 --> 00:43:41.834
saying, "This app is--might slow
down your iGoogle experience."

00:43:41.834 --> 00:43:44.567
It makes sense, right?

00:43:44.567 --> 00:43:46.367
Like, iGoogle wants
to be very fast.

00:43:46.367 --> 00:43:48.300
And as a great
illustration of this,

00:43:48.300 --> 00:43:52.300
I'm gonna show you a video
about an iGoogle page load.

00:43:52.300 --> 00:43:54.601
You'll also see, through
the course of this video,

00:43:54.601 --> 00:43:57.801
that there's kind of like an
implicit latency penalty anyway.

00:43:57.801 --> 00:44:01.601
And to basically
start that off...

00:44:01.601 --> 00:44:04.868
I hope that will play.

00:44:07.000 --> 00:44:08.267
Okay.

00:44:08.267 --> 00:44:09.567
So here I am
clicking over to one

00:44:09.567 --> 00:44:11.000
of my new tabs in iGoogle.

00:44:11.000 --> 00:44:15.234
And keep in mind--
what do you see first

00:44:15.234 --> 00:44:16.534
when the gadgets
start loading?

00:44:16.534 --> 00:44:18.467
Obviously there's weather,

00:44:18.467 --> 00:44:21.501
then next there's
a Flixster app,

00:44:21.501 --> 00:44:23.834
then there's
"The Wall Street Journal,"

00:44:23.834 --> 00:44:25.934
and then "New York Times."

00:44:25.934 --> 00:44:28.367
And then those last two apps
aren't even on my radar.

00:44:28.367 --> 00:44:30.701
By now I've already picked
what I want to work with.

00:44:30.701 --> 00:44:32.200
Maybe I want
to go see a movie.

00:44:32.200 --> 00:44:34.100
Maybe I want
to go check the weather.

00:44:34.100 --> 00:44:38.033
But my attention's not focused
on the two slowest apps.

00:44:38.033 --> 00:44:40.501
Obviously this video's
slowed down a bit.

00:44:40.501 --> 00:44:44.000
I actually
expanded it by twice--

00:44:44.000 --> 00:44:46.701
Well, it's about half as fast
as it would be normally.

00:44:46.701 --> 00:44:52.234
But you can see that when
you're in a profile of context

00:44:52.234 --> 00:44:53.901
that you're competing against

00:44:53.901 --> 00:44:55.167
the other gadgets
that are rendering

00:44:55.167 --> 00:44:57.334
for the end user's views,
right?

00:44:57.334 --> 00:44:58.801
If they're
not focused on your app

00:44:58.801 --> 00:45:00.367
and they're focused
on something else,

00:45:00.367 --> 00:45:02.567
they're not gonna engage
with your application as much.

00:45:02.567 --> 00:45:04.234
You're not gonna see
as much growth.

00:45:04.234 --> 00:45:06.801
So talking about, like,

00:45:06.801 --> 00:45:08.501
kind of these profile
or [indistinct]--

00:45:08.501 --> 00:45:11.634
or these profile pages, or
these home page sort of views

00:45:11.634 --> 00:45:14.767
is basically that
you have a lot of gadgets

00:45:14.767 --> 00:45:16.234
together, smushed together.

00:45:16.234 --> 00:45:19.000
And these are frequently some
of the most highly-trafficked

00:45:19.000 --> 00:45:21.234
portions of the site
that they're running on.

00:45:21.234 --> 00:45:24.901
For example, the iGoogle page
is people's home page,

00:45:24.901 --> 00:45:26.367
you know,
for their entire browser.

00:45:26.367 --> 00:45:29.501
So that's a huge
amount of traffic right there.

00:45:29.501 --> 00:45:32.567
Also, for Orkut,
profiles is, like, one of

00:45:32.567 --> 00:45:34.767
the biggest portions
of the Orkut site.

00:45:34.767 --> 00:45:38.000
Users love putting
gadgets on their profiles.

00:45:38.000 --> 00:45:39.734
It's kind of like
an expression,

00:45:39.734 --> 00:45:41.501
a way to sort of
say who they are.

00:45:41.501 --> 00:45:43.667
And so they put a lot
of different gadgets on them.

00:45:43.667 --> 00:45:45.734
And it does affect
the overall performance

00:45:45.734 --> 00:45:47.267
of the profile page
on Orkut.

00:45:47.267 --> 00:45:51.968
So Orkut wound up actually
turning off profile renders

00:45:51.968 --> 00:45:55.400
because of latency
and security issues, right?

00:45:55.400 --> 00:45:57.567
They didn't want
dynamic code executing.

00:45:57.567 --> 00:46:00.167
Thankfully they
turned them recently back on

00:46:00.167 --> 00:46:02.901
with a new OpenSocial 0.9
feature called Templates.

00:46:02.901 --> 00:46:05.534
Basically, Templates
is a way that you can declare

00:46:05.534 --> 00:46:07.267
what data
your application needs.

00:46:07.267 --> 00:46:10.000
And you can render it
in a declarative way as well.

00:46:10.000 --> 00:46:12.601
So there's no--
JavaScript being executed,

00:46:12.601 --> 00:46:15.601
even though templating looks
very similar to JavaScript.

00:46:15.601 --> 00:46:18.734
You can display social data,
data about your friends.

00:46:18.734 --> 00:46:21.400
You can display App Data,
so if you're using the cache,

00:46:21.400 --> 00:46:23.133
that's a great use for it.

00:46:23.133 --> 00:46:27.300
You can't use external fetches
or dynamic data fetches.

00:46:27.300 --> 00:46:30.801
Here's an example of
what a profile render

00:46:30.801 --> 00:46:32.467
in a template
might look like.

00:46:32.467 --> 00:46:34.634
You'll see,
I'm requiring two features:

00:46:34.634 --> 00:46:37.367
opensocial-data
and opensocial-templates.

00:46:37.367 --> 00:46:38.901
So that's the division here.

00:46:38.901 --> 00:46:40.501
First of all, you say
what data you need,

00:46:40.501 --> 00:46:43.067
and then the second is--
how am I going to show it?

00:46:43.067 --> 00:46:45.901
And you'll notice that when
I'm including the templates,

00:46:45.901 --> 00:46:48.400
I'm adding an
extra optional parameter

00:46:48.400 --> 00:46:49.667
called process-on-server.

00:46:49.667 --> 00:46:52.000
And that basically says
this template should be

00:46:52.000 --> 00:46:54.567
parsed by the server, don't
execute any of it client-side,

00:46:54.567 --> 00:46:56.434
strip out
any JavaScript, whatever.

00:46:56.434 --> 00:46:59.400
And that's more of
a security thing.

00:46:59.400 --> 00:47:01.300
Somewhat of
a performance thing too,

00:47:01.300 --> 00:47:02.467
because that rendered output

00:47:02.467 --> 00:47:04.334
can be cached
by the container.

00:47:04.334 --> 00:47:08.033
So the blue
little snippet at the top

00:47:08.033 --> 00:47:10.267
is a people request for
their friends in the viewer.

00:47:10.267 --> 00:47:13.434
And then the green at
the bottom is a repeating DIV

00:47:13.434 --> 00:47:16.467
that repeats on each friend
and outputs their name.

00:47:16.467 --> 00:47:18.300
You'll notice that
it's actually very similar

00:47:18.300 --> 00:47:19.968
to the PHP sample
that Chris posted

00:47:19.968 --> 00:47:21.834
for the
proxied content example.

00:47:23.901 --> 00:47:28.167
So we talked about a lot
of different optimizations,

00:47:28.167 --> 00:47:30.133
and I kind of want to bring
everything back together

00:47:30.133 --> 00:47:33.901
and kind of give you that high
level overview one more time.

00:47:33.901 --> 00:47:37.067
Basically we had three
different types of metrics

00:47:37.067 --> 00:47:38.801
that we were measuring on,

00:47:38.801 --> 00:47:42.567
and we found
different approaches

00:47:42.567 --> 00:47:45.100
affected different one--
each one differently.

00:47:45.100 --> 00:47:47.767
So for example, if we
wanted to reduce app size,

00:47:47.767 --> 00:47:49.868
we used
a JavaScript minification.

00:47:49.868 --> 00:47:52.534
Content rewriting,
use the dynamic--

00:47:52.534 --> 00:47:54.701
or use
the static content proxy.

00:47:54.701 --> 00:47:57.567
Data pipelining was
a great benefit for our gadget.

00:47:57.567 --> 00:47:59.667
And then
invalidation and setting

00:47:59.667 --> 00:48:03.000
our cache headers correctly
affected the app size--

00:48:03.000 --> 00:48:05.033
the download size--
the bandwidth that was used.

00:48:05.033 --> 00:48:06.868
Um, note that some of
these are in blue.

00:48:06.868 --> 00:48:08.501
Those are the ones
that are in aggregate,

00:48:08.501 --> 00:48:11.968
or are beneficial
over many views.

00:48:11.968 --> 00:48:13.934
They're not--so they're not
gonna affect

00:48:13.934 --> 00:48:15.400
the--a single app render.

00:48:15.400 --> 00:48:17.400
And that's why we don't
have real, like, metrics,

00:48:17.400 --> 00:48:19.868
because this is going to vary
from app to app.

00:48:19.868 --> 00:48:22.701
The benefit can be
really huge, though, you know?

00:48:22.701 --> 00:48:24.901
If you're caching
static content,

00:48:24.901 --> 00:48:28.067
then you can probably see,
like, 90% reduction in traffic.

00:48:28.067 --> 00:48:30.100
If you're
caching dynamic content,

00:48:30.100 --> 00:48:32.000
depending on the caching
that you're doing,

00:48:32.000 --> 00:48:33.234
you'll see less than that

00:48:33.234 --> 00:48:35.033
but it'll still
be a significant gain.

00:48:35.033 --> 00:48:36.234
So think
about all the numbers

00:48:36.234 --> 00:48:37.534
that we had
in this presentation,

00:48:37.534 --> 00:48:39.868
and you can go and
look online later, afterwards.

00:48:39.868 --> 00:48:42.701
But adjusting caching
can have, you know,

00:48:42.701 --> 00:48:47.901
tens of percentage points
impact on those numbers as well.

00:48:47.901 --> 00:48:49.467
Reducing
the number of requests

00:48:49.467 --> 00:48:52.567
was improved by JavaScript
minification, spriting,

00:48:52.567 --> 00:48:54.267
content rewriting--
because it kind of

00:48:54.267 --> 00:48:56.000
did those automatically
for us--

00:48:56.000 --> 00:48:57.868
and setting our cache headers.

00:48:57.868 --> 00:48:59.634
Again, cache
headers in aggregate,

00:48:59.634 --> 00:49:01.267
fewer requests over time.

00:49:01.267 --> 00:49:04.801
Finally, latency, basically
JavaScript minification,

00:49:04.801 --> 00:49:06.801
spriting,
rewriting, proxy, batching,

00:49:06.801 --> 00:49:09.200
optimizing the datastore--
everything we did

00:49:09.200 --> 00:49:13.200
Actually, I'm sorry, batching
should not be in that list.

00:49:13.200 --> 00:49:17.434
Everything but batching seemed
to have an impact on latency.

00:49:17.434 --> 00:49:19.467
Batching probably should,
we just didn't

00:49:19.467 --> 00:49:21.467
see it in the numbers.

00:49:21.467 --> 00:49:24.167
Keeping that in mind, we kind
of took everything together,

00:49:24.167 --> 00:49:27.434
and we tried to use as
many optimizations as possible.

00:49:27.434 --> 00:49:29.334
And we
have what's considered

00:49:29.334 --> 00:49:31.667
the most optimized
implementation.

00:49:31.667 --> 00:49:36.701
The net gain--obviously
we saved 1.6 seconds

00:49:36.701 --> 00:49:39.133
off of each page render
of our gadget.

00:49:39.133 --> 00:49:41.434
From the gadget's
point of view,

00:49:41.434 --> 00:49:47.434
we saved about 0.6 seconds from
the end user's point of view.

00:49:47.434 --> 00:49:49.734
We saved 20 HTTP requests.

00:49:49.734 --> 00:49:53.267
And we improved our
YSlow score by 17 points

00:49:53.267 --> 00:49:55.400
to a respectable 89.

00:49:55.400 --> 00:49:58.334
I'm sure we
could've pushed it more,

00:49:58.334 --> 00:50:01.868
but these changes are already,
like, fairly significant.

00:50:01.868 --> 00:50:05.267
We saved $325 off
of our monthly costs,

00:50:05.267 --> 00:50:08.133
assuming that we were a
fairly heavily trafficked app.

00:50:08.133 --> 00:50:10.434
So keeping in mind that,
you know, like,

00:50:10.434 --> 00:50:12.934
the costs might not be
staggering,

00:50:12.934 --> 00:50:16.934
but when you can shave,
you know, 0.6 seconds off

00:50:16.934 --> 00:50:18.234
of your gadget's
rendering time,

00:50:18.234 --> 00:50:20.367
what does that mean in terms
of usage and adoption

00:50:20.367 --> 00:50:21.734
for your gadget as well?

00:50:21.734 --> 00:50:24.334
We saw a direct correlation
on high-level sites,

00:50:24.334 --> 00:50:28.901
like Amazon and Google, between
latency and user adoption.

00:50:28.901 --> 00:50:31.901
So being able to
improve by this vast margin

00:50:31.901 --> 00:50:35.434
means significant impact
for your application.

00:50:35.434 --> 00:50:38.767
And because we're actually
running very close on time,

00:50:38.767 --> 00:50:42.000
if there's
any quick questions--

00:50:42.000 --> 00:50:43.734
I don't think
I set this up in time.

00:50:43.734 --> 00:50:47.501
So I'm going to check moderator
and see if anything--

00:50:47.501 --> 00:50:49.901
but if anyone wants to
come up and ask us questions

00:50:49.901 --> 00:50:52.367
for the next three minutes,
that'd be great.

00:50:52.367 --> 00:50:55.033
Chabot: So we only have
three minutes at the moment,

00:50:55.033 --> 00:50:57.100
but we also have
the OpenSocial office hours

00:50:57.100 --> 00:50:58.534
just down the hallway here.

00:50:58.534 --> 00:51:00.367
So if there's anything else
that we can't cover

00:51:00.367 --> 00:51:01.634
in the next three minutes,

00:51:01.634 --> 00:51:03.534
that would be
a great place to look us up.

00:51:03.534 --> 00:51:05.367
Cheers.

00:51:05.367 --> 00:51:08.400
So anyone? Questions?

00:51:10.400 --> 00:51:11.968
I think we're saving it
for the office hours.

00:51:11.968 --> 00:51:13.334
Cool.

00:51:13.334 --> 00:51:14.968
Roomann-Kurrik: Thank you.
Chabot: See you there, guys.

00:51:14.968 --> 00:51:16.000
[applause]

