WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:10.889
&gt;&gt; All right. So Peter Seibel describes himself
as a "writer turned programmer turned writer."

00:00:10.889 --> 00:00:16.760
I first became aware of him when I worked
for Sun and he worked for WebLogic.

00:00:16.760 --> 00:00:23.029
And he sent me a very convincing piece of
e-mail asking me to put chained exceptions

00:00:23.029 --> 00:00:26.070
into Java.
It convinced me, and so I did.

00:00:26.070 --> 00:00:30.380
So if you are a Java programmer who has benefited
from chained exceptions, you have Peter to

00:00:30.380 --> 00:00:35.740
thank.
Let's see. After that, he worked for a start-up

00:00:35.740 --> 00:00:39.030
that did Java-based transactional messaging
system.

00:00:39.030 --> 00:00:46.551
And then he took a couple years and wrote
this great common lisp book called what?

00:00:46.551 --> 00:00:55.210
Practical Common Lisp. It won a Jolt Award.
And then, he wrote this book called, "Coders

00:00:55.210 --> 00:00:57.431
at Work."
I could tell you all about it, but that would

00:00:57.431 --> 00:01:01.520
leave him with nothing to say.
So instead, why don't we give a warm welcome

00:01:01.520 --> 00:01:04.600
to Peter Seibel.

00:01:04.600 --> 00:01:07.130
&gt;&gt; [Clapping]

00:01:07.130 --> 00:01:16.800
Peter Seibel: So this book, as some of you
have seen -- a show of hands.

00:01:16.800 --> 00:01:19.990
Who's actually read it already?
Anyone? Josh. Couple. Okay.

00:01:19.990 --> 00:01:24.530
So you all have that to wait in store for
you hopefully.

00:01:24.530 --> 00:01:27.790
So I'll just give you a brief overview of
what the book is.

00:01:27.790 --> 00:01:32.970
It's 15 Q and A interviews with -- I like
to say -- "Notable computer programmers."

00:01:32.970 --> 00:01:37.050
I did not make any attempt to say, "These
are the 15 best programmers working on the

00:01:37.050 --> 00:01:39.690
planet."
I tried to make a book that was balanced in

00:01:39.690 --> 00:01:43.140
various ways so it wouldn't be all one kind
of programmer.

00:01:43.140 --> 00:01:47.830
I did also have a sort of bias -- for perhaps
obvious reasons -- of selecting programmers

00:01:47.830 --> 00:01:51.240
who I thought would be interesting to talk
to.

00:01:51.240 --> 00:01:58.360
So the totally indrawn, mad genius who only
grunts would not be a good candidate for an

00:01:58.360 --> 00:02:00.510
interview.
And so, those people -- despite their prodigious

00:02:00.510 --> 00:02:07.869
coding skills -- were left out.
But I think I got a good selection of people.

00:02:07.869 --> 00:02:12.510
Actually, the story of how I got this set
of people I did is a little bit interesting,

00:02:12.510 --> 00:02:17.019
but years ago, when I started working on this
book, I put up a website and asked for suggestions

00:02:17.019 --> 00:02:22.921
of names and made some wizi u1 stuff to let
people sort the names in various ways.

00:02:22.921 --> 00:02:26.909
And I ended up with about 284 suggestions
of names of programmers who someone thought

00:02:26.909 --> 00:02:31.250
would be worth interviewing.
And then, people sorted them in various ways.

00:02:31.250 --> 00:02:34.239
And I think, actually, Peter Norvig, your
 -- what is he now?

00:02:34.239 --> 00:02:37.810
Your V.P. of research, or whatever he is -- was
the top of the list.

00:02:37.810 --> 00:02:42.469
He might have lost at the very last minute.
John Carmack pulled ahead of him.

00:02:42.469 --> 00:02:45.489
John Carmack would have been a great guy to
have in this book, but he never replied to

00:02:45.489 --> 00:02:52.560
any of my e-mails or physical letters.
But, I whittled down that list to the 15 people

00:02:52.560 --> 00:02:57.010
who are in the book, and I'll just -- actually,
I was sort of curious to see.

00:02:57.010 --> 00:03:00.700
Since none of you mostly have read the book,
then you can just answer this.

00:03:00.700 --> 00:03:06.620
So who here has heard of Jamie Zawinski?
Raise your hand. About 50 percent.

00:03:06.620 --> 00:03:10.109
Brad Fitzpatrick, fellow Googler? About the
same.

00:03:10.109 --> 00:03:17.359
Douglas Crockford? A little less.
Brendan Eiche, Inventor of java script?

00:03:17.359 --> 00:03:24.389
Josh Block? Very nice.
Joe Armstrong, inventor of erlang. A few.

00:03:24.389 --> 00:03:29.819
Simon Peyton Jones? More.
Peter Norvig? Very good.

00:03:29.819 --> 00:03:37.090
Who doesn't know Peter Norvig?
Guy Steele? A lot. Yes, he's everywhere.

00:03:37.090 --> 00:03:45.629
Dan Ingalls, co-inventor of Smalltalk.
Peter Deutsche? El Peter Deutsche. Fewer.

00:03:45.629 --> 00:03:49.269
Ken Thompson, another Googler. Yes, inventor
of Unix.

00:03:49.269 --> 00:03:53.000
Fran Allen. There are a few.
Turing Award winner. You guys should know

00:03:53.000 --> 00:03:57.689
who she is.
Bernie Cosell? Nobody. See?

00:03:57.689 --> 00:04:00.879
I'm really proud of having Bernie Cosell in
this book because -- as you'll hear -- he's

00:04:00.879 --> 00:04:04.750
a really interesting guy.
And Donald Knuth? All right.

00:04:04.750 --> 00:04:07.009
You? You're out of here.

00:04:07.009 --> 00:04:08.009
&gt;&gt; [Laughter]

00:04:08.009 --> 00:04:13.739
Peter Seibel: So, I sat down with all of these
people.

00:04:13.739 --> 00:04:18.209
All of the interviews were done in person
over between four to six hours, all recorded

00:04:18.209 --> 00:04:24.560
on little digital recorders and laboriously
transcribed and then edited down.

00:04:24.560 --> 00:04:28.340
Probably about two-thirds of the raw transcript
was cut out to make the book.

00:04:28.340 --> 00:04:32.740
So if you think the book's too long, it could
have been a lot worse.

00:04:32.740 --> 00:04:38.729
And I sort of feel like this set of people
I interviewed -- we've all heard perhaps of

00:04:38.729 --> 00:04:43.650
Sturgeon's Law, that "90 percent of everything
is crud," which he invented thinking about

00:04:43.650 --> 00:04:47.690
science fiction but realized applied to everything.
These people are the other ten percent; all

00:04:47.690 --> 00:04:50.620
right?
If you read programming blogs or forums or

00:04:50.620 --> 00:04:55.120
read it or whatever, it sometimes can be dispiriting.
And you think, "Wow. All programmers actually

00:04:55.120 --> 00:04:59.699
are really idiots." -- including yourself
sometimes perhaps.

00:04:59.699 --> 00:05:06.229
But hopefully, if you read these interviews,
you'll realize that we're not all that way.

00:05:06.229 --> 00:05:10.560
These folks obviously had thought about their
craft.

00:05:10.560 --> 00:05:15.900
There were very few dogmatic points of view
on any of the latest back and forths about

00:05:15.900 --> 00:05:18.620
unit testing or test-driven development or
code ownership.

00:05:18.620 --> 00:05:25.129
Everyone had a sort of nuanced view of things,
which was refreshing.

00:05:25.129 --> 00:05:30.500
And basically, the goal of the book was to
talk to people about, you know, How did they

00:05:30.500 --> 00:05:37.159
become the programmers that they are today?
I think Apress sort of wanted a book that

00:05:37.159 --> 00:05:41.270
people could pick up and read and learn something
about how to be programmers.

00:05:41.270 --> 00:05:45.660
I think it got -- it's a little more subtle
than that however.

00:05:45.660 --> 00:05:49.560
I think Apress sort of thought, "Oh, we'll
just go ask a bunch of people a bunch of questions.

00:05:49.560 --> 00:05:51.780
Then it'll be very obvious.
People have actionable stuff they can take

00:05:51.780 --> 00:05:56.289
away and apply to their craft."
But I don't know if they're disappointed,

00:05:56.289 --> 00:06:01.580
but at least some of my reviewers are disappointed.
I -- like every author on the planet -- looks

00:06:01.580 --> 00:06:05.050
at the Amazon reviews.
Couple one star reviews on Amazon.

00:06:05.050 --> 00:06:09.030
One guy said, "I wanted more insight into
how to become a great coder, but you won't

00:06:09.030 --> 00:06:12.039
find that here."
Another guy said, "I want to know how they

00:06:12.039 --> 00:06:14.330
solve problems.
That's not a topic you'll find covered in

00:06:14.330 --> 00:06:20.580
this book."
But a friend of mine on the Lisp IRC Channel

00:06:20.580 --> 00:06:25.370
said to me the other day, "I was going to
say your book is more inspiring than enlightening,

00:06:25.370 --> 00:06:29.449
but after all, I think it is enlightening,
however subtly."

00:06:29.449 --> 00:06:34.860
And I think he's got it right.
I loathe to agree with the one star reviewers.

00:06:34.860 --> 00:06:35.860
&gt;&gt; [Laughter]

00:06:35.860 --> 00:06:42.879
Peter Seibel: -- in that, there is no royal
road to programming, right?

00:06:42.879 --> 00:06:47.370
It would be great if someone would interview
a bunch of folks like this and produce a book

00:06:47.370 --> 00:06:51.900
that you would read it and then say, "Aha!
That's how you become Donald Knuth.

00:06:51.900 --> 00:06:58.230
That's how you become Guy Steele -- in seven
days." [laughter] Right?

00:06:58.230 --> 00:07:05.259
But we know that's not really how it works.
And I was struck by that interviewing people

00:07:05.259 --> 00:07:10.949
that it's hard to get at what makes great
programmers great.

00:07:10.949 --> 00:07:14.259
We know that the people in this book are great
at what they do, because they've produced

00:07:14.259 --> 00:07:20.900
great stuff, but it's just a hard thing.
I mean, if you know -- you know all of probably

00:07:20.900 --> 00:07:24.360
 -- everyone here is a programmer, I assume?
More or less. Okay.

00:07:24.360 --> 00:07:28.439
So you know what goes on in your mind and
you know probably how hard it is to explain

00:07:28.439 --> 00:07:32.499
like, How do you make the decisions you make
when you code?

00:07:32.499 --> 00:07:35.879
And so, it's a hard thing to get at.
So I think we sort of have to read between

00:07:35.879 --> 00:07:42.199
the lines and also observe that these people
became who they became over a long time.

00:07:42.199 --> 00:07:45.639
And so, I started at the beginning of how
they started out.

00:07:45.639 --> 00:07:49.930
Four of them started with Basic.
Dijkstrais rolling over in his grave.

00:07:49.930 --> 00:07:55.539
Four of them started with Fortran and eight
of them started with Assembly.

00:07:55.539 --> 00:08:03.130
I think I counted Guy Steele in there twice.
And they started sort of how probably anyone

00:08:03.130 --> 00:08:06.770
started who started when they did.
Kids today starting will start somewhere else,

00:08:06.770 --> 00:08:11.490
but it's not obvious that they started out
very differently.

00:08:11.490 --> 00:08:16.849
Except that they all did seem to have hands
on experience with computers, particularly

00:08:16.849 --> 00:08:18.360
some of them at a time when that was very
unusual.

00:08:18.360 --> 00:08:23.570
So Donald Knuth happened to be at Case -- what
I guess is now Case Western Reserve -- but

00:08:23.570 --> 00:08:26.370
they had an IBM-650, and they let undergraduates
touch it.

00:08:26.370 --> 00:08:31.199
So he got to sit down with the machine and
debug programs and look at the programs in

00:08:31.199 --> 00:08:33.590
the manual and say, "I could do better than
that."

00:08:33.590 --> 00:08:38.620
And then discover that, in fact, he could.
But also how hard it was to debug a program.

00:08:38.620 --> 00:08:44.040
I think he said he "wrote a hundred line program
that had a hundred bugs in it."

00:08:44.040 --> 00:08:50.700
[laughter] So, sort of looking at what people
did, it really comes down to basics.

00:08:50.700 --> 00:09:00.700
The old three R's -- Reading, Writing, Arithmetic.
Reading -- some author or novelist said once,

00:09:00.700 --> 00:09:04.020
"There are two ways to learn to write -- read
and write." And it seems to me, looking at

00:09:04.020 --> 00:09:08.970
these interviews, that that's true for programmers
as well.

00:09:08.970 --> 00:09:14.350
Almost everybody I talked to made some mention
of reading other people's source code.

00:09:14.350 --> 00:09:20.910
A lot of them, that was really a formative
experience, as I'll show in a second.

00:09:20.910 --> 00:09:26.200
I didn't get the sense, however, that programmers
read as much maybe as they should.

00:09:26.200 --> 00:09:29.720
Or even some people sort of said we should
do it, but even they didn't really do it.

00:09:29.720 --> 00:09:32.250
Like, I imagine novelists probably read a
lot of novels.

00:09:32.250 --> 00:09:37.800
Like just regularly read novels.
Even among the people I interviewed, I didn't

00:09:37.800 --> 00:09:43.070
get the sense that anybody just sort of regularly
picked up a piece of code to read for fun.

00:09:43.070 --> 00:09:45.450
Some a little.
Brad Fitzpatrick actually sort of struck me

00:09:45.450 --> 00:09:47.640
as a little bit.
He just grabbed the android source code, get

00:09:47.640 --> 00:09:50.880
the Chrome source code, and just looked at
it to sort of see how it worked -- for no

00:09:50.880 --> 00:09:52.731
particular reason.
But mostly people read stuff that they were

00:09:52.731 --> 00:09:59.740
working on or that their team was working
on with some exceptions, and I'll go over

00:09:59.740 --> 00:10:03.770
them.
So Jamie Zawinski started out -- for those

00:10:03.770 --> 00:10:09.340
of you who don't know, he was an early employee
at Netscape, wrote the Unix version of mosaic

00:10:09.340 --> 00:10:16.250
or whatever it's called Netscape I guess,
before it was Mozilla -- but he actually got

00:10:16.250 --> 00:10:20.520
his start really at CMU.
He was hired as a high school student to work

00:10:20.520 --> 00:10:23.910
at then Scott Fellman's AI lab at CMU and
got to work on lisp machines and got this

00:10:23.910 --> 00:10:27.380
very old school.
He was sort of like the lisp culture was almost

00:10:27.380 --> 00:10:31.810
dying out and he as a very young person got
sort of enmeshed in that and sort of got it

00:10:31.810 --> 00:10:36.890
when other kids his age would have been playing
with Apple II's and stuff.

00:10:36.890 --> 00:10:42.090
So he was there working on these lisp machines
and so he basically said he ended up reading

00:10:42.090 --> 00:10:46.130
a lot of the code, you know for these lisp
machines just looking at how stuff worked.

00:10:46.130 --> 00:10:53.150
And I asked him if he was reading code that
he wanted to work on or is it just for curiosity.

00:10:53.150 --> 00:10:55.330
And he said, "Mostly I just wondered how that
works."

00:10:55.330 --> 00:10:58.700
The impulse to take things apart is a big
part of what gets people into this line of

00:10:58.700 --> 00:11:02.940
work.
And I certainly saw that in a lot of people.

00:11:02.940 --> 00:11:07.550
Brad Fitzpatrick described how he didn't used
to read code.

00:11:07.550 --> 00:11:13.820
He was programming since he was five years
old on a home brew Apple II that his father

00:11:13.820 --> 00:11:16.640
built.
The story of how that computer came into existence

00:11:16.640 --> 00:11:19.890
is in the book and it's amusing.
But he said, "There were a number of years

00:11:19.890 --> 00:11:23.550
when I wrote a lot of code and never read
anyone else's.

00:11:23.550 --> 00:11:26.620
Then I got on on the Internet, and there's
all this open source I could contribute to,

00:11:26.620 --> 00:11:30.250
but I was just scared shitless that it wasn't
my code and the whole design wasn't in my

00:11:30.250 --> 00:11:32.750
head -- that I couldn't dive in and understand
it."

00:11:32.750 --> 00:11:37.720
And he describes -- but he did eventually
start sending in some patches to game the

00:11:37.720 --> 00:11:41.300
TTK instant messenger.
And he said, "I was digging around in that

00:11:41.300 --> 00:11:45.490
code and I just saw the whole design.
Just seen parts of it I understood.

00:11:45.490 --> 00:11:48.960
I realized, after looking at other people's
code, that it wasn't that I memorized my own

00:11:48.960 --> 00:11:50.890
code.
I was starting to see patterns.

00:11:50.890 --> 00:11:54.320
I would see their code and I was like, "Oh,
okay. I understand the structure that they're

00:11:54.320 --> 00:11:56.600
going with."
[talking] And so he said, after that, he really

00:11:56.600 --> 00:12:01.860
enjoyed reading code, because as he says,
"Whenever I didn't understand some pattern,

00:12:01.860 --> 00:12:05.660
I was like, 'Why the fuck did he do it like
this?' And I would look around" -- Brad also

00:12:05.660 --> 00:12:11.680
gets the prize for most cursing in his interview.
[laughter] It's actually cut down in the book

00:12:11.680 --> 00:12:14.170
 -- "I would look around more, and I'd be
like, 'Wow, that's a really clever way to

00:12:14.170 --> 00:12:17.800
do that.' So I see how that pays off."
And so he said, "I would have done that earlier,

00:12:17.800 --> 00:12:21.050
but I was afraid to do it, because I was thinking
if it wasn't my code, I wouldn't understand

00:12:21.050 --> 00:12:24.060
it." [talking] So he sort of came over.
And as I said, he's the one who does seem

00:12:24.060 --> 00:12:29.890
to sort of just read code for fun.
Like I said, android, Chrome, Firefox, Open

00:12:29.890 --> 00:12:34.180
Office.
Douglas Crockford is a big fan of Knuth's

00:12:34.180 --> 00:12:38.350
Literate Programming, but even he said he
mostly read Knuth's prose instead of the actual

00:12:38.350 --> 00:12:42.730
code.
He's also a big fan of reading as a group

00:12:42.730 --> 00:12:45.550
activity -- sort of 'inspections' kind of
reading -- and also uses that in interviews.

00:12:45.550 --> 00:12:49.610
If you interview over at -- you get tired
of working here, you go over to Google, interview

00:12:49.610 --> 00:12:52.860
with Doug Crockford, he's going to say, "Bring
a piece of code that you wrote, and let's

00:12:52.860 --> 00:12:58.880
read through it together as a way of understanding
your skills." Brendan Eiche started out -- He

00:12:58.880 --> 00:13:02.540
was an undergrad -- he was really a physics
undergrad, but he got into some computing

00:13:02.540 --> 00:13:05.870
and they got a hold of the Unix source code
and they looked at that, and they looked at

00:13:05.870 --> 00:13:09.290
the C preprocessor which he described as an
amazing mess.

00:13:09.290 --> 00:13:16.510
And so he started trying to understand that,
trying to write a better one.

00:13:16.510 --> 00:13:23.170
Now, he does read some other code, I think
frameworks and stuff and java script obviously,

00:13:23.170 --> 00:13:30.730
he's also interested in python and ruby.
Josh Block didn't really say anything in particular

00:13:30.730 --> 00:13:37.380
about reading code, but I'm sure he approves.
Peter Norvig, when he was young -- in grad

00:13:37.380 --> 00:13:40.280
school, whatever -- he was at Berkeley, and
they had the source code of the Symbolics

00:13:40.280 --> 00:13:42.510
lisp machines.
And so, he took a look at that.

00:13:42.510 --> 00:13:44.260
And again, it was just sort of what he was
interested in.

00:13:44.260 --> 00:13:45.800
He was like, "Oh, this has an interesting
feature in it.

00:13:45.800 --> 00:13:49.370
Let me look into it.
How do they open files across the network,

00:13:49.370 --> 00:13:55.180
you know, just the same way as they open files
locally" -- which was newer then.

00:13:55.180 --> 00:14:01.090
And Guy Steele -- as always -- was very articulate
about stuff, so he wrote a lisp very early

00:14:01.090 --> 00:14:05.530
on, probably when he was in high school.
A lisp implementation for the, I guess, the

00:14:05.530 --> 00:14:09.540
IBM 1130, and he really credits the ability
to recode.

00:14:09.540 --> 00:14:11.610
He was hanging out at MIT as a high school
student.

00:14:11.610 --> 00:14:12.960
So they had the famous drawer of source code
listings.

00:14:12.960 --> 00:14:16.920
He says, "I would not have been able to implement
lisp for an 1130 without having access to

00:14:16.920 --> 00:14:19.510
existing implementations of lisp on another
computer.

00:14:19.510 --> 00:14:24.320
That was a very important part of my education."
And so he said, "Part of the problem that

00:14:24.320 --> 00:14:26.430
we face nowadays -- now that software has
become valuable and most software of any size

00:14:26.430 --> 00:14:29.260
is commercial -- is that we don't have a lot
of examples of good code to read."

00:14:29.260 --> 00:14:33.000
And he goes on to say, "Open source has helped
with that."

00:14:33.000 --> 00:14:38.040
He also read Tech.
So, how many people have actually looked at

00:14:38.040 --> 00:14:42.700
Tech, the program?
Knuth's book. Yeah, a few.

00:14:42.700 --> 00:14:47.780
I found -- I asked everybody about Literate
Programming and, obviously, Knuth was in favor.

00:14:47.780 --> 00:14:52.260
[laughter] Everyone else was a little mixed.
You know, there were people who were like

00:14:52.260 --> 00:14:55.490
this, "Interesting."
You know, "It's interesting to read."

00:14:55.490 --> 00:14:58.750
Or it'd be, "An interesting experiment to
do, but I wouldn't want to code that way all

00:14:58.750 --> 00:15:02.940
the time."
Other people like -- Ken Thompson is like,

00:15:02.940 --> 00:15:07.130
"No, that's just -- that's dumb.
It can't work, because you're writing everything

00:15:07.130 --> 00:15:09.510
twice."
And other people have said, "Yeah, it's interesting,

00:15:09.510 --> 00:15:13.480
but that toolkit was never right."
They only had it for C, or whatever.

00:15:13.480 --> 00:15:17.610
Guy Steele said, maybe if they had good tool
chains for literate programming in lisp he

00:15:17.610 --> 00:15:23.440
would have done it.
So it sort of struck me that Knuth's been

00:15:23.440 --> 00:15:29.570
out there arguing for this and really getting
nowhere on that front.

00:15:29.570 --> 00:15:33.260
Peter Deutsche -- he didn't really talk a
lot about code reading, but he again was at

00:15:33.260 --> 00:15:36.140
MIT with the drawer full of listings.
And I think he was sort of famous, because

00:15:36.140 --> 00:15:40.410
he also went -- and he was at MIT when he
was like 13 years old writing a lisp implementation

00:15:40.410 --> 00:15:43.890
for the PDP-1.
And I think sort of famously pulling listings

00:15:43.890 --> 00:15:49.120
out of the drawer and writing them to be twice
as good and really annoying people twice his

00:15:49.120 --> 00:15:51.250
age.
Ken Thompson also.

00:15:51.250 --> 00:15:55.610
So he's a great example of the early code
reading there being very important.

00:15:55.610 --> 00:16:00.670
He was at Cal.
They had this drum computer called the G15,

00:16:00.670 --> 00:16:04.800
and it had an interpreter for a language called
Intercom on it.

00:16:04.800 --> 00:16:08.420
And they would use a little bit in his double
E classes.

00:16:08.420 --> 00:16:12.010
And so, a friend of his -- a grad student
 -- had written an interpreter for Intercom.

00:16:12.010 --> 00:16:16.220
And so, he got a listing of that.
And over vacation -- Christmas vacation or

00:16:16.220 --> 00:16:19.000
something -- he said, "I read it and just
dissected it.

00:16:19.000 --> 00:16:22.090
I didn't know the language it was written
in, which happened to be Nelliac -- and it

00:16:22.090 --> 00:16:25.220
was just a marvelously written program.
And I learned programming.

00:16:25.220 --> 00:16:28.410
Nelliac, Intercom and how to interpret something,
everything, from that.

00:16:28.410 --> 00:16:32.720
I just sat and read it for probably the entire
vacation in a week, and then came back and

00:16:32.720 --> 00:16:35.860
asked some questions about it -- nagging little
bugs kind of things.

00:16:35.860 --> 00:16:41.280
After that, I knew how to program, and I was
pretty good at it." [laughter] Fran Allen,

00:16:41.280 --> 00:16:47.490
who's been a researcher at IBM forever.
She basically joined IBM in time to teach

00:16:47.490 --> 00:16:52.130
Fortran to IBM scientists.
Fortran had just been invented and she was

00:16:52.130 --> 00:16:55.510
on track to be a math teacher, but needed
to pay off her school debt, so took a job

00:16:55.510 --> 00:16:58.250
at IBM.
They said, "Oh, you're a teacher.

00:16:58.250 --> 00:17:02.010
Teach the scientist to use Fortran on all
their scientific stuff, because how else will

00:17:02.010 --> 00:17:07.059
we make everyone else use it if we won't use
it?" And she had to drag them kicking and

00:17:07.059 --> 00:17:08.910
screaming.
I observed that that's the last time scientists

00:17:08.910 --> 00:17:17.630
have adopted a new language.
[laughter] But she too -- other than the teaching

00:17:17.630 --> 00:17:24.410
 -- she started out as a programmer at IBM.
She worked on this operating system called

00:17:24.410 --> 00:17:27.770
the Monitored Automatic Debugging System.
And she said she really remembers reading

00:17:27.770 --> 00:17:29.750
the original program.
It was very elegant.

00:17:29.750 --> 00:17:37.440
Later on, she lead research teams.
She led the team that basically invented Static

00:17:37.440 --> 00:17:43.280
Single Assignment, you know, compiler technique.
And one of her employees had built a parser.

00:17:43.280 --> 00:17:47.030
This is actually the guy who wrote the parser
that's part of the Jikes Java compiler.

00:17:47.030 --> 00:17:48.730
I don't know if you guys are familiar with
that.

00:17:48.730 --> 00:17:54.770
And so, she wanted to understand that.
She said, "It's probably the best parser in

00:17:54.770 --> 00:17:57.900
the world."
It's on open source now, "and I wanted to

00:17:57.900 --> 00:18:00.880
understand it, so I took it and read it.
And I knew that Felipe Charles -- the man

00:18:00.880 --> 00:18:04.240
who had written it -- was a beautiful programmer.
The way I would approach understanding the

00:18:04.240 --> 00:18:07.780
new language or new implementation of some
very complex program, would be to take a program

00:18:07.780 --> 00:18:12.840
from somebody that I knew was a great programmer
and read it."

00:18:12.840 --> 00:18:15.600
And that sort of actually gets -- I'm going
to jump ahead a little bit, but Guy Steele

00:18:15.600 --> 00:18:22.070
said something about -- I guess I heard a
little bit about before, but he said, "One

00:18:22.070 --> 00:18:24.730
of the problems that a lot of people seem
to face with reading code is, it's hard to

00:18:24.730 --> 00:18:27.360
find good code." I mean, there's open source;
there's a gazillion things.

00:18:27.360 --> 00:18:29.360
But how do you know that the stuff that we
really ought to read?

00:18:29.360 --> 00:18:33.330
And Guy Steele said basically, "It's hard
to find good code that's worth reading.

00:18:33.330 --> 00:18:37.320
We haven't developed a body of accepted literature
that says, 'This is great code; everybody

00:18:37.320 --> 00:18:42.280
should read this.'" So it tends to be one-page
snippets and papers, chunks of code out of

00:18:42.280 --> 00:18:48.420
existing stuff.
So, you know, even he who was saying that

00:18:48.420 --> 00:18:51.900
and saying how important code reading was
 -- I asked him about some code he had actually

00:18:51.900 --> 00:18:56.410
read, and he gave me an example, but it had
been three or four years since.

00:18:56.410 --> 00:19:01.180
So, it's not like he's picking up new code
just to read for fun anymore, other than the

00:19:01.180 --> 00:19:06.130
stuff he's working on.
Some of the folks I talked to actually gave

00:19:06.130 --> 00:19:09.559
pretty good advice about how to read code,
I thought.

00:19:09.559 --> 00:19:13.890
In some ways maybe the most practical advice
in the book, because it's a daunting thing.

00:19:13.890 --> 00:19:15.700
Here's a big pile of code, How do you get
into it?

00:19:15.700 --> 00:19:20.590
Some people can just sort of start reading
and suck it all into their brain and eventually

00:19:20.590 --> 00:19:24.450
it's all there and they can understand it.
But I've never been able to do that.

00:19:24.450 --> 00:19:27.550
So Zawinski gave some advice.
Just, you know, you just dive in and start

00:19:27.550 --> 00:19:31.900
reading it and you can start at the bottom.
He said, "If you want to understand how Emax

00:19:31.900 --> 00:19:35.890
works, start at the bottom.
What are cons cells made of?

00:19:35.890 --> 00:19:39.580
If that doesn't work for you, sometimes starting
with the build system can give you an idea

00:19:39.580 --> 00:19:44.790
of how things are put together.
Just trying to build the damn thing will really

00:19:44.790 --> 00:19:48.550
show you -- actually and Brad Fitzpatrick
echoed a similar thought which is just, "pipe

00:19:48.550 --> 00:19:53.420
find into less while you're trying to build
the thing and sort of look around and you'll

00:19:53.420 --> 00:19:56.801
see how things are structured."
And then, I think it was Zawinski who said,

00:19:56.801 --> 00:20:02.540
"Once you get it built, you know, now you've
built your own version of Emax or Firefox.

00:20:02.540 --> 00:20:08.300
Now, you can just make one stupid little change
 -- change the title of some window -- and

00:20:08.300 --> 00:20:12.740
now, you've actually started working on the
program and understanding a little bit how

00:20:12.740 --> 00:20:18.950
it fits together."
Guy Steele talked about taking one function,

00:20:18.950 --> 00:20:21.700
you know.
You want to look at Emax -- think about, Well,

00:20:21.700 --> 00:20:25.240
somewhere it's got to insert a character.
Let's find that, take a task -- something

00:20:25.240 --> 00:20:29.450
that's going to happen -- and then, just find
the code that's going to show you how that,

00:20:29.450 --> 00:20:31.500
where that happens.
You know, eventually there's going to be something

00:20:31.500 --> 00:20:34.980
that increments some counter that moves the
cursor along in the buffer.

00:20:34.980 --> 00:20:39.290
And as you've traced that whole path, you'll
have looked at a lot of the code.

00:20:39.290 --> 00:20:46.990
Now, go back up to the top, pick another thing,
try that.

00:20:46.990 --> 00:20:53.520
Brendan Eiche took a different approach which
is often to take a big program, sort of hard

00:20:53.520 --> 00:20:57.160
to read, because, you know, they're hard.
Throw it into the debugger and just trace

00:20:57.160 --> 00:21:01.300
around sort of more dynamically.
Get a view that way of what's happening as

00:21:01.300 --> 00:21:03.710
the program runs.
And that will drag you through the source

00:21:03.710 --> 00:21:09.160
code in a way that's actually -- you're going
to see the flow of control.

00:21:09.160 --> 00:21:14.220
But he also did say, "Really understanding
it is this Gestalt process that involves looking

00:21:14.220 --> 00:21:17.380
at different angles of top and bottom and
different views of it, playing it in the debugger,

00:21:17.380 --> 00:21:20.191
stepping through in the debugger, incredibly
tedious that that can be."

00:21:20.191 --> 00:21:28.570
And he sort of cautioned that, "Simply reading
source code without firing it up and watching

00:21:28.570 --> 00:21:34.230
it in the debugger can be misleading in the
sense that you can go a long way reading source,

00:21:34.230 --> 00:21:36.410
but you can also get stuck.
You can get bored and convince yourself that

00:21:36.410 --> 00:21:40.540
you understand something that you don't."
I think the Zawinski approach of trying to

00:21:40.540 --> 00:21:41.540
change something is sort of also a guard against
that, right?

00:21:41.540 --> 00:21:47.930
If you actually try and change it, you'll
discover where your understanding has failed.

00:21:47.930 --> 00:21:54.520
Another way to read code that comes up more
in debugging two people mentioned.

00:21:54.520 --> 00:21:56.610
So Bernie Cosell, who none of you have heard
of.

00:21:56.610 --> 00:22:01.450
Bernie Cosell was one of the three software
guys who wrote the software for the IMPS,

00:22:01.450 --> 00:22:06.580
the Internet Message Processors at BBN that
first four nodes of which were the first four

00:22:06.580 --> 00:22:12.400
nodes of what is now the Internet.
So BBN had been contracted by ARPA to build

00:22:12.400 --> 00:22:16.380
this thing as basically an experiment.
And Bernie Cosell and two other guys wrote

00:22:16.380 --> 00:22:23.940
all the software in assembly for some hardened
Honeywell 316.

00:22:23.940 --> 00:22:28.890
So he was -- I've read in some -- you know
old software books, methodology books, they

00:22:28.890 --> 00:22:32.440
say you know, "One thing you should never
do is patch the binary."

00:22:32.440 --> 00:22:38.070
You know, you read that now and you're like,
"What do they mean by that 'patch the binary?'

00:22:38.070 --> 00:22:42.140
[laughter] "That sounds insane."
So when Bernie Cosell joined the IMP project,

00:22:42.140 --> 00:22:45.540
he was the third one on just by a couple months.
And so, the two other guys had done a little

00:22:45.540 --> 00:22:49.180
bit of work.
And one of the other guys seriously thought

00:22:49.180 --> 00:22:54.080
the best way to maintain their source was
they had, you know, the assembly listing and

00:22:54.080 --> 00:22:56.559
they would assemble the thing, and it would
be running.

00:22:56.559 --> 00:22:59.630
And then they'd find a bug.
And so, they would find, you know, the patch

00:22:59.630 --> 00:23:03.070
you needed to make.
And he would write in his notebook, you know,

00:23:03.070 --> 00:23:07.510
"At this place, put a jump to over here.
Have this little code.

00:23:07.510 --> 00:23:11.630
And then jump back to this address."
And they would load that patch onto the system,

00:23:11.630 --> 00:23:15.309
and he would have in his notebook.
So there was no source code listing of this

00:23:15.309 --> 00:23:19.430
system as it was running.
Because they just had patch after patch after

00:23:19.430 --> 00:23:21.860
patch piled on.
Now, the guy who was doing this was very disciplined

00:23:21.860 --> 00:23:25.890
with the notebook and he recorded everything
that happened, but to get the source, you

00:23:25.890 --> 00:23:30.750
had to take the original listing that was
how many weeks old, plus this guy's notebook,

00:23:30.750 --> 00:23:34.080
and apply the patches in the right order.
So Bernie Cosell came in and said -- like

00:23:34.080 --> 00:23:38.600
I think any sane person would say -- "This
is crazy!" And he went through the exercise

00:23:38.600 --> 00:23:42.490
over a weekend of applying all the patches
and generating a new listing.

00:23:42.490 --> 00:23:47.530
And then saying, you know -- come Monday there
was a still-running system but now was generated

00:23:47.530 --> 00:23:49.920
from a clean listing.
And he said, "From here on out, we're putting

00:23:49.920 --> 00:23:51.990
the patches in every night and generating
a new listing."

00:23:51.990 --> 00:23:58.640
So all of these guys were clearly sort of
masterful assembly programmers that they could

00:23:58.640 --> 00:24:04.290
even begin to get away with that.
And Cosell was at -- this was when BBN was

00:24:04.290 --> 00:24:10.020
just a hotbed of innovation.
I mean, they were doing the Internet.

00:24:10.020 --> 00:24:13.510
They were doing AI stuff.
They had a lot of connections with MIT there

00:24:13.510 --> 00:24:17.720
in Cambridge.
And they tended to hire people like Cosell,

00:24:17.720 --> 00:24:21.080
who were MIT dropouts, because they were just
as smart and a lot cheaper.

00:24:21.080 --> 00:24:27.780
[laughter] So he had sort of bailed on MIT
in the sophomore -- junior -- year.

00:24:27.780 --> 00:24:30.870
Went to work at BBN.
He developed a reputation.

00:24:30.870 --> 00:24:33.700
And he is mentioned in the book, "Where Wizards
Stay Up Late" -- which is about the inventing

00:24:33.700 --> 00:24:37.070
of the Internet.
He developed a reputation of being this masterful

00:24:37.070 --> 00:24:38.770
debugger.
And I asked him about that.

00:24:38.770 --> 00:24:42.830
And he said, "Well, that's sort of fake."
Because what happened was, they had these

00:24:42.830 --> 00:24:45.860
bugs that nobody could figure out.
And so, they'd give it to me.

00:24:45.860 --> 00:24:48.570
And I'd go and I'd read the code and I'd read
the code and I'd read the code until I got

00:24:48.570 --> 00:24:51.460
to a point where I didn't understand what
I was doing, and then, I would rewrite that

00:24:51.460 --> 00:24:56.080
part.
And he said, "This is a terrible way -- I

00:24:56.080 --> 00:24:59.440
can't believe I got away with it."
But he basically would build his own model

00:24:59.440 --> 00:25:05.330
 -- not of how the code did work, but how
it ought to work -- and get far enough in

00:25:05.330 --> 00:25:09.071
that then when he said, "Okay, where it seems
to be doing doesn't match what I think it

00:25:09.071 --> 00:25:11.920
ought to be doing; I'm just going to make
it do what I think it ought to be doing."

00:25:11.920 --> 00:25:16.260
And apparently got away with that over decades.
Another person who has apparently adopted

00:25:16.260 --> 00:25:22.700
this technique is Peter Norvig, who was also
a little shame-faced about it, but -- which

00:25:22.700 --> 00:25:26.390
goes a bit, I think also, to the point of
how hard it is to read code.

00:25:26.390 --> 00:25:29.960
If you didn't write it and you try and dig
into it, eventually it's just like, "You know

00:25:29.960 --> 00:25:32.910
what?
I don't understand this.

00:25:32.910 --> 00:25:41.200
I'll just rewrite it.
That'll be easier than figuring it out."

00:25:41.200 --> 00:25:46.070
So the one guy who was a real inspiration
on this point -- reading code -- is Donald

00:25:46.070 --> 00:25:51.840
Knuth -- inspiration on many things.
I mean, so this guy obviously reads.

00:25:51.840 --> 00:25:56.760
I mean, his job is to sort of read almost
everything in an area and distill it down

00:25:56.760 --> 00:26:01.050
into something the rest of us can pretend
to understand.

00:26:01.050 --> 00:26:08.360
So he talked about looking at Babylonian manuscripts
of how they described the algorithms in ancient

00:26:08.360 --> 00:26:13.830
Babylonia 4,000 years ago just to sort of
see how did they think about algorithms.

00:26:13.830 --> 00:26:18.120
And then, he found a Sanskrit document from
the 13th century about combinatorial math

00:26:18.120 --> 00:26:20.380
and really felt that this was actually quite
sweet.

00:26:20.380 --> 00:26:25.130
He felt like the guy who wrote this thing
in the 13th century in Sanskrit -- probably

00:26:25.130 --> 00:26:29.460
there was nobody he knew who understood what
he was talking about.

00:26:29.460 --> 00:26:36.340
[laughter] But he had these ideas about combinatorial
 -- what we now call combinatorial math -- and

00:26:36.340 --> 00:26:42.240
Knuth found a translation of this document,
and he felt like this guy was talking to him.

00:26:42.240 --> 00:26:44.730
Like, he understood him.
And he's like, "I had those same thoughts

00:26:44.730 --> 00:26:49.720
as I was getting started in computer programming."
And so, this poor guy -- he'll never know

00:26:49.720 --> 00:26:55.731
 -- but he actually did find someone who did
understood him in Donald Knuth.

00:26:55.731 --> 00:26:59.390
And so, Knuth talked -- this was in the context
of how important reading source materials

00:26:59.390 --> 00:27:05.790
are to him, and since source materials and
also computer code -- he said, "I was unable

00:27:05.790 --> 00:27:10.200
to pass that on to any of my students.
There are people alive now in computer science

00:27:10.200 --> 00:27:13.880
who are doing this well -- a few.
But I could count on the fingers of one hand

00:27:13.880 --> 00:27:17.730
the people who love source materials the way
I do." And he went on to describe all his

00:27:17.730 --> 00:27:22.600
collections of source code, various compilers
from the 60's that were written in interesting

00:27:22.600 --> 00:27:27.760
ways, and Dijkstra's source code to the THE
operating system which he hadn't read, but

00:27:27.760 --> 00:27:31.990
he's holding for a rainy day.
[laughter] And described one time he broke

00:27:31.990 --> 00:27:35.370
his arm -- he fell off his bike and broke
his arm and was laid up and couldn't really

00:27:35.370 --> 00:27:37.010
do much.
And so, he read source code for a month and

00:27:37.010 --> 00:27:39.450
that was a really important experience for
him.

00:27:39.450 --> 00:27:45.570
And so, I was sort of asking him the standard
question like, "Well, how do you do this?"

00:27:45.570 --> 00:27:51.460
And again, there's no royal road.
Like, he didn't have any easy answer to how

00:27:51.460 --> 00:27:54.910
you read source code, but I'll read this passage.
It's a little long, but I'll read it, because

00:27:54.910 --> 00:27:59.170
it's so inspiring to me about how he does
it.

00:27:59.170 --> 00:28:02.910
So he was saying, "Well, it's really worth
it for what it builds in your brain -- reading

00:28:02.910 --> 00:28:05.440
source code.
So how do I do it?

00:28:05.440 --> 00:28:09.080
There was a machine called the Bunker Rainbow
300, and somebody told me that the Fortran

00:28:09.080 --> 00:28:12.250
compiler for this machine was really amazingly
fast.

00:28:12.250 --> 00:28:16.450
And nobody had any idea how it worked.
I got a copy of the source code listing for

00:28:16.450 --> 00:28:18.720
it.
I didn't have a manual for the machine, so

00:28:18.720 --> 00:28:21.049
I wasn't even sure what the machine language
was.

00:28:21.049 --> 00:28:24.720
But, I took it as an interesting challenge.
I could figure out begin, and then I would

00:28:24.720 --> 00:28:27.490
start to decode.
The operation codes had some two lettered

00:28:27.490 --> 00:28:31.350
mnemonics and I could start to figure out,
"This probably was a load instruction, This

00:28:31.350 --> 00:28:34.070
probably was a branch."
And I knew it was a Fortran compiler.

00:28:34.070 --> 00:28:37.770
So at some point, it looked at column seven
of a card and that was where it would tell

00:28:37.770 --> 00:28:41.920
if it was a comment or not.
After three hours, I had figured out a little

00:28:41.920 --> 00:28:44.400
bit about the machine.
And then, I found these big branching tables.

00:28:44.400 --> 00:28:47.010
So it was a puzzle.
And I looked at how these primitives are used.

00:28:47.010 --> 00:28:49.940
How does that get used by higher levels in
the system?

00:28:49.940 --> 00:28:51.350
And that helped me get around.
But really" -- [talking] oops, I'm reading

00:28:51.350 --> 00:28:55.830
the wrong thing.
[reading] "It was a puzzle.

00:28:55.830 --> 00:29:02.600
And I kept making little charts like I'm working
at a security agency trying to decode a secret

00:29:02.600 --> 00:29:05.760
code, but I knew it worked and I knew it was
a Fortran compiler.

00:29:05.760 --> 00:29:07.970
It wasn't encrypted in the sense that it was
intentionally obscure.

00:29:07.970 --> 00:29:11.380
It was only in code, because I hadn't gotten
the manual for the machine.

00:29:11.380 --> 00:29:13.929
Eventually, I was able to figure out why this
compiler was so fast."

00:29:13.929 --> 00:29:17.429
[talking] And then, being the algorithms guy
 -- [reading] "Unfortunately, it wasn't because

00:29:17.429 --> 00:29:19.820
the algorithms were brilliant.
It was just because they'd used unstructured

00:29:19.820 --> 00:29:24.750
programming and hadn't optimized to the hilt.
It was just basically the way you solved some

00:29:24.750 --> 00:29:27.220
kind of unknown puzzle.
Make tables and charts and get little more

00:29:27.220 --> 00:29:31.350
information here, make a hypothesis.
In general, when I'm reading technical papers,

00:29:31.350 --> 00:29:34.910
it's the same challenge.
I'm trying to get into the author's mind,

00:29:34.910 --> 00:29:37.920
trying to figure out what the concept is.
The more you learn to read other people's

00:29:37.920 --> 00:29:41.580
stuff, the more you're able to invent your
own in the future, it seems to me."

00:29:41.580 --> 00:29:48.309
[talking] And, you know, I can just picture
Knuth here decoding -- I mean, he doesn't

00:29:48.309 --> 00:29:51.720
know what these op codes mean and he's reading
the source code.

00:29:51.720 --> 00:29:55.090
So then it's like, "Oh, I should be able to
read a C program, and understand it, right?"

00:29:55.090 --> 00:30:01.090
[laughter] Like, I know how the language works.
So he echoed sort of Guy Steele's thing saying,

00:30:01.090 --> 00:30:03.200
"We ought to publish code.
The lion's book is available.

00:30:03.200 --> 00:30:06.580
Bill Atkinson's programs are now publicly
available thanks to Apple.

00:30:06.580 --> 00:30:09.540
And it won't be too long before we're able
to read that.

00:30:09.540 --> 00:30:10.990
So I said, "Well, you know, open source is
out there."

00:30:10.990 --> 00:30:16.351
And he said, "Yeah, that's right."
But he also really echoed the idea that you

00:30:16.351 --> 00:30:20.850
should read more -- read code that's not -- what
does he say, "Don't read the people who code

00:30:20.850 --> 00:30:23.450
like you."
So I think, for him, the fact that he was

00:30:23.450 --> 00:30:27.299
decoding this machine -- this architecture
that he didn't even know -- was more valuable

00:30:27.299 --> 00:30:33.740
than just reading a bunch of code and something
that would have been a little more accessible.

00:30:33.740 --> 00:30:36.562
So he obviously is the father of literate
programming.

00:30:36.562 --> 00:30:44.180
He's the one who really advocates for people
reading code.

00:30:44.180 --> 00:30:49.500
It was interesting to me that everyone sort
of thought that was a good idea, but there

00:30:49.500 --> 00:30:55.480
wasn't as much of it as you might have thought.
The other bit -- reading -- writing, is the

00:30:55.480 --> 00:30:57.630
other one.
And I mean, writing code.

00:30:57.630 --> 00:31:04.920
A lot of people also thought writing English,
or prose, in your native language had some

00:31:04.920 --> 00:31:07.610
connection.
A lot of people thought -- Douglas Crockford

00:31:07.610 --> 00:31:10.700
said, "I am a writer."
I ask people, you know, "Are you an artist,

00:31:10.700 --> 00:31:12.340
a scientist, or craftsman?" He said, "I'm
a writer.

00:31:12.340 --> 00:31:16.210
Sometimes I write in English.
Sometimes I write in code." Other people thought

00:31:16.210 --> 00:31:21.360
there were just similarities in the way your
brain worked between writing prose and writing

00:31:21.360 --> 00:31:26.450
code.
Though, actually, Guy Steele -- who's probably

00:31:26.450 --> 00:31:31.919
one of the great technical writers -- was
the one who thought they were the most dissimilar.

00:31:31.919 --> 00:31:38.520
He felt like writing for computer is very
different, because the computer is so literal-minded,

00:31:38.520 --> 00:31:41.990
you just can't get away with as much as you
can writing for people.

00:31:41.990 --> 00:31:46.230
But, when it comes to writing code, this seems
 -- again, no royal road.

00:31:46.230 --> 00:31:49.710
You want to become a good programmer?
Write a lot of code.

00:31:49.710 --> 00:31:58.710
These people -- I think it's a necessary,
but perhaps not sufficient sadly, requirement

00:31:58.710 --> 00:32:04.700
if you -- a lot of these people, like probably
a lot of the people in this room were just

00:32:04.700 --> 00:32:08.560
driven to code.
I mean, they just code. That's what they do.

00:32:08.560 --> 00:32:11.470
Joe Armstrong said, "The really good programmers
spend a lot of time programming.

00:32:11.470 --> 00:32:15.010
I haven't seen very good programmers who don't
spend a lot of time programming.

00:32:15.010 --> 00:32:18.049
If I don't program for two or three days,
I need to do it."

00:32:18.049 --> 00:32:19.809
And then he went on to say, "You get better
at it.

00:32:19.809 --> 00:32:22.940
You get quicker at it.
The side effect of writing all this other

00:32:22.940 --> 00:32:26.370
stuff" -- and he was talking about just all
these random projects that he was working

00:32:26.370 --> 00:32:30.050
on -- "the side effect of writing all this
other stuff is, when you get to doing ordinary

00:32:30.050 --> 00:32:35.980
problems, you can do them very quickly."
And Knuth -- I asked him about if he still

00:32:35.980 --> 00:32:38.210
enjoyed programming, he said, "Oh, my God,
yes.

00:32:38.210 --> 00:32:41.980
I've got this need to program.
I wake up in the morning with sentences of

00:32:41.980 --> 00:32:44.900
a literate program.
Before breakfast -- I'm sure poets must feel

00:32:44.900 --> 00:32:49.320
this -- I have to go to the computer and write
this paragraph, and then I can eat and I'm

00:32:49.320 --> 00:32:54.010
happy.
It's a compulsion. That I have to admit."

00:32:54.010 --> 00:32:58.870
So basically all of these people, you know,
were the hacker -- they had the hacker thing

00:32:58.870 --> 00:33:02.040
going.
They just had to hack.

00:33:02.040 --> 00:33:07.280
Zawinski was working at CMU on stuff related
to AI, but he also was just digging into the

00:33:07.280 --> 00:33:10.380
graphics code on the lisp machines and writing
screensavers, which eventually landed him

00:33:10.380 --> 00:33:16.060
a job with Peter Norvig at Berkeley.
And when he was waiting for the linguist to

00:33:16.060 --> 00:33:20.600
tell him what to do, he spent more time writing
screensavers, and said later when he was working

00:33:20.600 --> 00:33:24.169
a gazillion hours a week at Netscape, he sometimes
thought, "Why did I leave the job where I

00:33:24.169 --> 00:33:29.920
was just writing screensavers?" [laughter]
Brad Fitzpatrick is just a coding machine

00:33:29.920 --> 00:33:33.100
as far as I can tell.
You know, started when he was five -- like

00:33:33.100 --> 00:33:36.620
I said -- on his Apple.
And his dad said he passed his dad up at six

00:33:36.620 --> 00:33:40.331
or seven, and just worked on, you know, the
stuff he was working on.

00:33:40.331 --> 00:33:46.290
He wrote a live journal because it was fun.
And a lot of people seem to be driven by the

00:33:46.290 --> 00:33:49.210
desire to have something.
They weren't just coding in the abstract.

00:33:49.210 --> 00:33:52.370
They were coding because they wanted to solve
a problem, you know?

00:33:52.370 --> 00:33:59.580
Brad wanted to have an online social website
so he could chat with his friends and post

00:33:59.580 --> 00:34:02.460
stupid stuff.
And so, he just did that.

00:34:02.460 --> 00:34:06.700
He describes in the book how he implemented
the comment system on Live Journal as a between-classes

00:34:06.700 --> 00:34:10.369
hack to annoy one of his friends, because
his friend had said something stupid and there

00:34:10.369 --> 00:34:12.440
was, at that time, no way to comment on Live
Journal pages.

00:34:12.440 --> 00:34:15.180
And so he said, "I need to make fun of him.
I need to put in a comment system."

00:34:15.180 --> 00:34:19.370
[laughter] And so, his friend when he saw
the comment was like, "What the fuck?

00:34:19.370 --> 00:34:24.980
We can comment now?" You know, a lot of people
started young.

00:34:24.980 --> 00:34:31.369
Josh Block here was writing chat programs
to be annoying for his science fair.

00:34:31.369 --> 00:34:35.659
Joe Armstrong -- we were talking about what
erlang was good for and what it wasn't.

00:34:35.659 --> 00:34:39.059
And he was saying, "Well, I do some image
manipulation, but I just have a C program

00:34:39.059 --> 00:34:42.220
that does the actual image manipulation, because
erlang wouldn't be that good for it.

00:34:42.220 --> 00:34:44.739
And I said, "Yeah, and plus, Image Magic has
already written.

00:34:44.739 --> 00:34:47.290
No need to rewrite it."
And he said, "Oh, that doesn't worry me in

00:34:47.290 --> 00:34:49.749
the slightest.
I think if I was doing it in OCaml, then I

00:34:49.749 --> 00:34:52.089
would go down and do it, because OCaml can
do that kind of efficiency.

00:34:52.089 --> 00:34:55.119
If I was a OCaml programmer, Okay, what do
I have to do?

00:34:55.119 --> 00:34:58.349
Implement, re-implement Image Magic? Right.
Off we go."

00:34:58.349 --> 00:35:01.489
And I said, "Just because it's fun?" And he
said, "Yeah, I like programming.

00:35:01.489 --> 00:35:04.900
Why not? You know?
I've always been saying that erlang is bad

00:35:04.900 --> 00:35:06.779
for image processing.
I've never actually tried.

00:35:06.779 --> 00:35:09.869
I feel it would be bad, but that might be
false.

00:35:09.869 --> 00:35:15.579
I should try.
Hmm... interesting. You shouldn't tempt me."

00:35:15.579 --> 00:35:19.210
Simon Peyton Jones spent his college years
between nine p.m. and three a.m. building

00:35:19.210 --> 00:35:25.670
hardware and trying to write a compiler in
BCPL while earning a degree during the day.

00:35:25.670 --> 00:35:29.970
Guy Steele was everywhere.
One of my favorite things from Guy Steele's

00:35:29.970 --> 00:35:32.579
interview was he taught himself APL from the
printout.

00:35:32.579 --> 00:35:36.130
He went -- there was a big trade show, and
IBM was there demonstrating their new APL,

00:35:36.130 --> 00:35:43.690
and he went up to the booth sort of at the
end of the show, and sort of looked -- I don't

00:35:43.690 --> 00:35:45.290
know.
Big puppy dog eyes, or something -- at the

00:35:45.290 --> 00:35:49.489
woman who was cleaning up the booth as she
was taking the printout on the terminal where

00:35:49.489 --> 00:35:51.509
they had been demonstrating the new APL for
the whole show.

00:35:51.509 --> 00:35:55.499
And she said, "Do you want this?" And he said,
[nodding] And she gave it to him.

00:35:55.499 --> 00:36:02.400
So he had days of printout of APL interactions,
and from that, taught himself the language.

00:36:02.400 --> 00:36:07.729
He also made money in high school writing
COBOL, of all things, that was his first job

00:36:07.729 --> 00:36:11.740
as a programmer -- writing a grading system
for, unfortunately, a different high school,

00:36:11.740 --> 00:36:16.670
so he didn't get to hack his own grades.
And he learned enough lisp just on his own

00:36:16.670 --> 00:36:21.690
to be the first person to score a perfect
score on a quiz that -- this guy at MIT was

00:36:21.690 --> 00:36:25.989
hiring lisp programmers gave everybody a quiz,
and he gave it to young 16-year-old Guy Steele,

00:36:25.989 --> 00:36:32.779
and Guy Steele aced it.
And Ken Thompson, also another coding machine.

00:36:32.779 --> 00:36:38.440
Just whatever he wanted -- when he wrote Unix
at Bell labs, he thought he was going to be

00:36:38.440 --> 00:36:43.470
fired for it, because they had just come off
Multix, which was seen as a huge disaster.

00:36:43.470 --> 00:36:48.700
And since they had come off the project, the
official thing -- they were doing research,

00:36:48.700 --> 00:36:52.180
but there were some things they were supposed
to research and some not, and operating systems

00:36:52.180 --> 00:36:57.381
was one of the "Not to be Researched" things.
But he had an itch to write Unix, and he figured,

00:36:57.381 --> 00:36:58.950
"Well, I'll write this, and they'll probably
fire me.

00:36:58.950 --> 00:37:04.200
But whatever, this is what I want to do."
And so, that's what he did.

00:37:04.200 --> 00:37:07.910
The rest is history -- he did computer chess
 -- hardware-aided computer chess, whatever

00:37:07.910 --> 00:37:12.670
struck his fancy.
Bernie Cosell, same way.

00:37:12.670 --> 00:37:17.119
And Knuth took a decade off to write his own
tech-setting system.

00:37:17.119 --> 00:37:20.540
All right, so.
And then, I'll just do a little bit on -- we've

00:37:20.540 --> 00:37:24.059
done reading, we've done writing...
Arithmetic.

00:37:24.059 --> 00:37:27.940
I asked everybody about how much math was
really required to be a programmer, and I

00:37:27.940 --> 00:37:34.569
certainly came out of math departments.
Actually, Thompson had an interesting observation

00:37:34.569 --> 00:37:37.839
that computer science came -- at different
universities -- out of two places.

00:37:37.839 --> 00:37:42.970
Some places, it came out of math -- Cornell,
whatever -- and some places, it came out of

00:37:42.970 --> 00:37:46.799
E.E. -- like Cal -- and you really saw this
split.

00:37:46.799 --> 00:37:51.339
You know, the theory guys came out of math,
and then, the systems -- the people who built

00:37:51.339 --> 00:37:55.540
Unix and whatever -- came out of the E.E.
track.

00:37:55.540 --> 00:37:58.859
But so, I asked people about "Do you need
to learn a lot of math?

00:37:58.859 --> 00:38:04.770
Do you need, you know, and then also -- sort
of related to that -- formal proofs?" There

00:38:04.770 --> 00:38:08.390
was some suggestion that sort of standard
math curriculum is not that useful for programmers.

00:38:08.390 --> 00:38:12.099
Like, ultimately calculus is not really what
you want to learn so much as maybe discreet

00:38:12.099 --> 00:38:19.109
math obviously but statistics or probability
might be more useful really than calculus.

00:38:19.109 --> 00:38:24.559
On the topic of proofs, most -- this was a
little interesting to me.

00:38:24.559 --> 00:38:28.099
Almost everybody I talked to poo-pooed the
notion of formal proofs.

00:38:28.099 --> 00:38:33.739
Again, Dijkstrais rolling in his grave, but
basically, the overall sentiment was pretty

00:38:33.739 --> 00:38:37.079
consistent, you know.
Crockford said, "I looked at them in the 70's,

00:38:37.079 --> 00:38:40.789
but it just wasn't working.
Things are too hard.

00:38:40.789 --> 00:38:44.049
Software is so complicated and go wrong in
so many ways."

00:38:44.049 --> 00:38:47.869
You know, people would say, "Assertions are
useful, but full-on formal proofs are just

00:38:47.869 --> 00:38:51.749
not going to happen.
Armstrong described taking a course into notational

00:38:51.749 --> 00:38:58.819
semantics and spending 14 pages trying to
prove that in two different schemes, you know,

00:38:58.819 --> 00:39:05.190
let X = 3, and let Y = 4, and X + Y = 7.
And then, 14 pages later, he's proven that.

00:39:05.190 --> 00:39:10.720
And he's like, "Well, how am I going to prove
the correctness of my erlang compiler?" Norvig

00:39:10.720 --> 00:39:15.410
said, "I rarely have a program that I can
prove correct.

00:39:15.410 --> 00:39:21.609
Is Google correct?" You get back these ten
pages, if it crashes, it's incorrect, but

00:39:21.609 --> 00:39:25.729
if you get back ten pages, are those the correct
ten pages?

00:39:25.729 --> 00:39:29.160
So that was down the line -- that was pretty
much -- nobody was interested in proving things

00:39:29.160 --> 00:39:33.140
correct.
Guy Steele, even Knuth likes to prove things

00:39:33.140 --> 00:39:37.750
informally correct, but doesn't just feel
like, same thing you know, you wouldn't know

00:39:37.750 --> 00:39:41.220
what all the assertions for even a simple
program would be.

00:39:41.220 --> 00:39:46.759
Guy Steele gave an excellent example of the
perhaps limited applicability of proofs, but

00:39:46.759 --> 00:39:53.599
he was given a review paper for Cacum that
was done by a student of David Greaves who

00:39:53.599 --> 00:40:02.819
was, himself, a student of Dikester.
And it was a proof of a parallel garbage collector,

00:40:02.819 --> 00:40:05.150
or proof of the correctness of this parallel
garbage collector.

00:40:05.150 --> 00:40:10.089
And they gave Steel the paper to review, and
he ground through this proof, checking the

00:40:10.089 --> 00:40:14.089
proof.
And it took him 25 hours to check every step

00:40:14.089 --> 00:40:21.079
of this proof, and at the end of the 25 hours,
he said, "There's a step here that I can't

00:40:21.079 --> 00:40:24.960
make look right."
And so, he turned that back in as his review,

00:40:24.960 --> 00:40:29.479
and it turned out that was a bug in the proof
that was therefore a bug in the program, because

00:40:29.479 --> 00:40:33.799
the proof proved that the program worked.
And so, then they found there was one little

00:40:33.799 --> 00:40:37.380
thing that had to be swapped and then they
redid the whole proof and they sent it back

00:40:37.380 --> 00:40:39.989
to him.
And he rechecked the proof, which took another

00:40:39.989 --> 00:40:46.289
25 hours.
And he could find no flaws in the proof.

00:40:46.289 --> 00:40:53.220
And so, you know, this sort of cuts both ways
in the sense that I ask, "What could you do

00:40:53.220 --> 00:40:56.320
just spent 25 hours and found the bug in the
program?" And he said, "No, no way."

00:40:56.320 --> 00:41:00.490
It was this incredibly -- this parallel garbage
collector with all these interactions and

00:41:00.490 --> 00:41:05.589
the proof abstracted it in a way that let
him, by finding the bug in the proof, it pointed

00:41:05.589 --> 00:41:11.170
to the bug in the code, but he never would
have said, "Ah, there's a bug in the code."

00:41:11.170 --> 00:41:14.969
On the other hand, it took him 50 hours, and
they still don't know, right?

00:41:14.969 --> 00:41:20.210
I observe that, you know, Dijkstrahas this
famous quote about, "You can't prove by testing

00:41:20.210 --> 00:41:24.410
that a program is bug-free.
You can only prove that you failed to find

00:41:24.410 --> 00:41:27.010
any bugs with your test."
And I said, "Well, it sort of sounds to me

00:41:27.010 --> 00:41:29.519
like, with the proof, you can't prove a program
is bug-free.

00:41:29.519 --> 00:41:34.249
You can only prove that, as far as you understand
your own proof, it hasn't turned up any bugs."

00:41:34.249 --> 00:41:42.930
And Steel basically agreed with that.
So, I found an interesting example of how

00:41:42.930 --> 00:41:47.249
it can work.
It's not totally an exotic quest to try and

00:41:47.249 --> 00:41:53.380
prove things correct, but also, how hard it
is until we get a little further along with

00:41:53.380 --> 00:41:58.619
automated theorem proving.
So I guess -- Oh, one last bit.

00:41:58.619 --> 00:42:04.819
So while we're on Dikester, another one of
my favorite moments -- obviously sad that

00:42:04.819 --> 00:42:09.750
Dijkstra wasn't around to be included in this
book, so he couldn't defend himself.

00:42:09.750 --> 00:42:13.869
But my favorite moment was, I asked a lot
of people about -- Dijkstrahas this famous

00:42:13.869 --> 00:42:18.289
paper on the cruelty of really teaching computing
science, in which he basically says, "Undergrads

00:42:18.289 --> 00:42:23.390
should come in and be given formal symbol
manipulation stuff with the predicate calculus

00:42:23.390 --> 00:42:28.660
for years of their education before they're
even allowed to touch -- to actually program."

00:42:28.660 --> 00:42:32.229
He describes, "We'll use this language, which
we'll be very careful to make sure has not

00:42:32.229 --> 00:42:37.469
been implemented anywhere on campus.
So nobody can actually program in it."

00:42:37.469 --> 00:42:42.920
And nobody seemed to think that was such a
great idea.

00:42:42.920 --> 00:42:46.369
[laughter] Josh Block said, "That's crazy.
There's a joy in telling the computer to do

00:42:46.369 --> 00:42:50.190
something and watching to do it.
I would not deprive students of that joy."

00:42:50.190 --> 00:42:55.700
But my favorite moment involved -- with all
due respect to Josh -- was when Knuth starts

00:42:55.700 --> 00:42:57.700
talking smack about Dikester.
That's good stuff.

00:42:57.700 --> 00:43:04.930
[laughter] Because who else really can anymore?
So Knuth said -- you know, I asked him about

00:43:04.930 --> 00:43:08.269
this thing, and he said, "But that's not the
way he learned either.

00:43:08.269 --> 00:43:11.880
He said a lot of great things and inspirational
things, but he's not always right.

00:43:11.880 --> 00:43:15.549
Neither am I, but my take on it is this -- take
a scientist in any field.

00:43:15.549 --> 00:43:19.339
The scientist gets older and says, "Oh, yes.
Some of the things I've been doing have a

00:43:19.339 --> 00:43:22.480
really great payoff, and other things I'm
not using anymore.

00:43:22.480 --> 00:43:25.499
I'm not going to have my students waste time
on the stuff that doesn't make giant steps.

00:43:25.499 --> 00:43:27.680
I'm not going to talk about low level stuff
at all.

00:43:27.680 --> 00:43:31.249
These theoretical concepts are really so powerful,
that's the whole story.

00:43:31.249 --> 00:43:35.300
Forget about how I got to this point."
I think that's a fundamental error made by

00:43:35.300 --> 00:43:38.369
scientists in every field.
They don't realize that when you're learning

00:43:38.369 --> 00:43:40.599
something, you've got to see something at
all levels.

00:43:40.599 --> 00:43:44.140
You've got to see the floor before you can
build the ceiling.

00:43:44.140 --> 00:43:47.859
That all goes into the brain, it gets shoved
down to the point where the older people forget

00:43:47.859 --> 00:43:55.430
that they needed it."
So that was, unfortunately, we can't ask Dijkstrato

00:43:55.430 --> 00:44:00.599
respond to that.
But so in the interest of leaving some time

00:44:00.599 --> 00:44:03.440
for questions, I think I'll just leave it
there.

00:44:03.440 --> 00:44:10.209
Actually, let me just close with this.
Several people -- including your own Ken Thompson

00:44:10.209 --> 00:44:13.490
 -- were sort of wondering about where modern
programming was going.

00:44:13.490 --> 00:44:16.720
And, you know, Ken Thompson said, "I don't
understand the code they write here at Google.

00:44:16.720 --> 00:44:23.640
It makes no sense to me." And Bernie Cosell,
who helped him run the Internet, is now actually

00:44:23.640 --> 00:44:25.859
a sheep farmer in Virginia.
So he's basically out of the game.

00:44:25.859 --> 00:44:30.769
Though he -- like everyone who's allegedly
retired, you know, the people I talk to -- they

00:44:30.769 --> 00:44:34.430
can't help but program.
But he says, "I don't envy modern programmers.

00:44:34.430 --> 00:44:37.029
It's going to get worse.
The simple things are getting packaged into

00:44:37.029 --> 00:44:40.880
libraries, leaving only the hard things.
The stuff is getting so complicated, but the

00:44:40.880 --> 00:44:43.880
standards that people are expecting are stunning."
And he talked about -- actually used Google

00:44:43.880 --> 00:44:47.680
maps as an example of something that like,
he knows what's going on under the covers,

00:44:47.680 --> 00:44:49.729
but he's like, "I don't think I could write
that code" -- which I doubt a little bit.

00:44:49.729 --> 00:44:56.309
And so, he closed saying, "There's a good
time to be an over-the-hill programmer emeritus,

00:44:56.309 --> 00:44:58.940
because you have a few props because you did
it once.

00:44:58.940 --> 00:45:02.360
But the world is so wondrous that you can
take advantage of it and maybe even get a

00:45:02.360 --> 00:45:07.380
little occasional credit for it without having
to still be able to do it.

00:45:07.380 --> 00:45:10.109
Whereas, if you're in college, if you major
in computer science, and you have to go out

00:45:10.109 --> 00:45:13.890
there and have to figure out how you're going
to add to this pile of stuff?

00:45:13.890 --> 00:45:27.680
Save me."
[laughter] So you guys are out here adding

00:45:27.680 --> 00:45:31.329
to the pile of stuff.
I'll take your questions.

00:45:31.329 --> 00:45:32.329
&gt;&gt; [Clapping]

00:45:32.329 --> 00:45:39.329
Q Peter, the way I see the difference between
what really good programmers can do and what

00:45:39.329 --> 00:45:45.210
ordinary people like me can do is like the
difference between me and a chess grand master

00:45:45.210 --> 00:45:52.249
is they can keep many, many, many more things
in mind at the same time than I can, which

00:45:52.249 --> 00:45:57.779
gives them the ability to find connections
and solve problems much more easily.

00:45:57.779 --> 00:46:00.180
Do other people see things that way?

00:46:00.180 --> 00:46:07.200
Peter Seibel: I think there were some -- I
asked a lot of people about sort of on that

00:46:07.200 --> 00:46:11.049
topic, but also -- and actually, the analogy
applies to chess as well little bit in the

00:46:11.049 --> 00:46:19.739
sense that I observed that sometimes the smartest
 -- 'smartest' in some definition of smart

00:46:19.739 --> 00:46:23.180
 -- people write the worst code -- the most
spaghetti code, because they can keep it in

00:46:23.180 --> 00:46:25.310
their minds, right?
There's all of these little tendrils that

00:46:25.310 --> 00:46:30.609
are all interlocked, and it all fits in their
head, and so they can do it.

00:46:30.609 --> 00:46:35.489
Whereas other people who are less smart in
that way, or smarter in another way, realize

00:46:35.489 --> 00:46:40.549
that like, even if you can do that, it's better
to Not, and find better ways of organizing

00:46:40.549 --> 00:46:43.540
things.
And a lot of people I asked sort of posed

00:46:43.540 --> 00:46:52.499
that like, "Have you found that?" Said, "Yes"
 -- that, I mean, there's at least two kinds

00:46:52.499 --> 00:46:58.210
of programmers in that sense.
I'm trying to think who really echoed that.

00:46:58.210 --> 00:47:05.140
I think Josh Block did.
But to get back to the chess analogy, that's

00:47:05.140 --> 00:47:09.729
sort of like, some people can just -- this
is at a much lower level, but I used to play

00:47:09.729 --> 00:47:12.289
chess with my dad when I was a kid, and he
used to beat me all the time.

00:47:12.289 --> 00:47:15.309
And then I actually learned how to play chess,
and I killed him.

00:47:15.309 --> 00:47:19.890
Because he was just basically smart and can
calculate a few moves ahead, which was enough

00:47:19.890 --> 00:47:24.549
to beat a little kid, but really had no understanding
of what he was doing.

00:47:24.549 --> 00:47:31.200
So it's sort of the same thing.
But I think that with grand master chess players

00:47:31.200 --> 00:47:34.229
and also with great programmers, it's not
just that they can do sort of do more of the

00:47:34.229 --> 00:47:36.589
same thing.
They look at it differently, right?

00:47:36.589 --> 00:47:41.390
A grand master looks at a chessboard and just
sees the position and sees where the forces

00:47:41.390 --> 00:47:44.380
are flowing.
And so, it's not that they're calculating

00:47:44.380 --> 00:47:48.069
 -- I mean they can -- when they get to the
end game, they calculate like crazy, but most

00:47:48.069 --> 00:47:51.440
of the time, they just look at the board and
say, "Oh, yeah.

00:47:51.440 --> 00:47:56.339
This is where the forces are flowing."
I mean -- I'm just speculating here -- the

00:47:56.339 --> 00:47:59.440
same for programmers.
Some people just sort of see how things fit

00:47:59.440 --> 00:48:06.769
together at a maybe deeper level and see the
consequences of bad choices.

00:48:06.769 --> 00:48:16.869
Q So I noticed that pretty much everything
you touched on is about the programmer working

00:48:16.869 --> 00:48:23.390
on something by himself.
That's mostly not what we do here.

00:48:23.390 --> 00:48:28.269
I don't know -- I mean, is it true that all
great programmers have to work by themselves

00:48:28.269 --> 00:48:32.719
because there's too much of a hindrance lapse
with others, or is there some insight into

00:48:32.719 --> 00:48:34.339
how we can work in teams?

00:48:34.339 --> 00:48:37.809
Peter Seibel: Right. So the question was,
So today, I've talked mostly about things

00:48:37.809 --> 00:48:40.619
that apply to people working alone, what about
working in teams?

00:48:40.619 --> 00:48:45.270
Which is obviously prevalent.
Yeah, I did. So buy the book and read it,

00:48:45.270 --> 00:48:52.690
because I did talk about that too.
Probably, due to the folks that I interviewed,

00:48:52.690 --> 00:48:58.109
I mean, a lot of them sort of came from a
little earlier era when the cowboy -- I think

00:48:58.109 --> 00:49:01.440
half the people I talked to said, "I'm the
last cowboy coder." So.

00:49:01.440 --> 00:49:05.960
[laughter] So I guess they can fight about
that.

00:49:05.960 --> 00:49:13.249
But, I did talk about how people like to work
with others.

00:49:13.249 --> 00:49:17.020
XP was a little more in good light when I
started thinking about the questions.

00:49:17.020 --> 00:49:19.059
I was sort of asking that.
But, you know, I asked people, "Did you ever

00:49:19.059 --> 00:49:23.079
pair program?" Not a lot of pair programming,
but lots of variants on it.

00:49:23.079 --> 00:49:29.119
People, you know, Josh called it "buddy programming"
and Joe Armstrong did a very similar thing.

00:49:29.119 --> 00:49:34.140
Write a bunch of code and then swap, you know.
Joe Armstrong wrote the early version of erlang,

00:49:34.140 --> 00:49:37.430
and then his friend Robert Virding took it
and completely rewrote it and then gave it

00:49:37.430 --> 00:49:39.390
back.
And Armstrong would completely rewrite that.

00:49:39.390 --> 00:49:41.660
And it went back and forth, and they had a
very different style.

00:49:41.660 --> 00:49:46.420
And they actually improved each other's -- he
thought -- code.

00:49:46.420 --> 00:49:49.380
Ken Thompson talks about how he liked to split
things up in teams.

00:49:49.380 --> 00:49:54.959
Peter Norvig mentioned -- talked, raised the
issue of -- when I asked about what do things

00:49:54.959 --> 00:49:57.809
people need to learn that they're not learning
in school?

00:49:57.809 --> 00:50:03.829
And he said, "Well, learning to work in teams
is not yet taught as much it ought -- and

00:50:03.829 --> 00:50:07.279
is really the important thing." Actually,
this book came out.

00:50:07.279 --> 00:50:15.400
I had had breakfast or a lisp get together
and Peter was there and I was fresh off of

00:50:15.400 --> 00:50:18.079
PCL and I was asking people, you know, "What
book should I write next?" And he said, "You

00:50:18.079 --> 00:50:21.160
should write a book about programming in groups."
And so, I went to Apress and said, "You know,

00:50:21.160 --> 00:50:22.940
I'm thinking about writing a book about programming
in groups."

00:50:22.940 --> 00:50:25.430
And they said, "Okay, that's great.
We'll be happy to publish that, but first,

00:50:25.430 --> 00:50:29.789
you should really do this book of interviews."
Because this book was Apress' idea, because

00:50:29.789 --> 00:50:32.900
of the earlier book, Founders at Work.
And so, they had the idea for it, and they

00:50:32.900 --> 00:50:35.549
said, "Well, you should really do this.
And then, it'll take you a few months."

00:50:35.549 --> 00:50:39.400
So that was several years ago.
[laughter] I don't write books fast.

00:50:39.400 --> 00:50:47.450
But anyway, you know, that is -- I think a
book done like this 20 years from now will

00:50:47.450 --> 00:50:53.459
have a very different -- will have learned
some stuff about that, that sadly, in a way,

00:50:53.459 --> 00:50:57.380
the people I interviewed didn't have as much
to say about because of the era they came

00:50:57.380 --> 00:51:00.170
up in for the most part.
Jamie Zawinski described in great detail,

00:51:00.170 --> 00:51:05.390
however, how the Netscape people would scream
and curse at each other all the time and how

00:51:05.390 --> 00:51:08.069
that was very productive.

00:51:08.069 --> 00:51:14.069
Q Did you notice a consistency of opinion
in terms of the tools of programming, such

00:51:14.069 --> 00:51:18.959
as ID's vs.
plain-text editors, or working interactively

00:51:18.959 --> 00:51:21.060
vs.
sitting down with a printout?

00:51:21.060 --> 00:51:26.670
Peter Seibel: Right. So the question was,
"Was there consistency in tools?" I'm tempted

00:51:26.670 --> 00:51:29.729
to be flip and say, "Yes, everybody uses Emax"
 -- because that was almost true.

00:51:29.729 --> 00:51:34.589
They were sort of -- and that camp was divided
between the people who were ashamed to still

00:51:34.589 --> 00:51:39.220
be using Emax and the people who were proud
to still be using Emax.

00:51:39.220 --> 00:51:43.769
[laughter] Some people like, "Oh, I should
really learn how to use an ID, but I don't."

00:51:43.769 --> 00:51:45.289
And other people were like, "Yeah, I looked
at those ID's.

00:51:45.289 --> 00:51:50.359
They're terrible.
I'm sticking with Emax." Though, on the tool

00:51:50.359 --> 00:51:58.029
front, a little -- partly just because of
the different eras that people started, there

00:51:58.029 --> 00:52:01.720
are different tool sets.
Dan Ingalls wrote the first version of Smalltalk

00:52:01.720 --> 00:52:06.599
in Basic, because that was the interactive,
programming environment he had available.

00:52:06.599 --> 00:52:09.761
He's always had a preference for interactive
programming environments, as you might guess,

00:52:09.761 --> 00:52:12.950
given the way Smalltalk turned out.
And so, he wrote the first version of Basic,

00:52:12.950 --> 00:52:16.660
because that was what he had.
He knew Fortran inside out, but that wouldn't

00:52:16.660 --> 00:52:23.420
have been a fun way to write it.
So a lot of people came up in the era of punch

00:52:23.420 --> 00:52:28.281
cards and dealt with that in different ways.
Like I mentioned earlier, a lot of people

00:52:28.281 --> 00:52:35.299
 -- even people who came up in that era had
hands-on experience, like I said, in a way

00:52:35.299 --> 00:52:37.989
that you might not expect.
So they -- you know, it was punch cards, but

00:52:37.989 --> 00:52:41.200
they would have access to the machine so they
could work sort of interactively that way.

00:52:41.200 --> 00:52:47.200
But as far as the actual tools people use
today, you know, it's sort of what you would

00:52:47.200 --> 00:52:49.920
expect.
There's a lot of Emax, and some people use

00:52:49.920 --> 00:52:55.229
ID's.
And Josh Block still prints stuff out and

00:52:55.229 --> 00:52:56.839
really looks at -- spreads it out all over
the floor.

00:52:56.839 --> 00:53:02.940
I think Guy Steele echoed that.
This is not now, but Guy Steele described

00:53:02.940 --> 00:53:07.910
implementing -- making a big change to the
Mac lisp system where they wanted to change

00:53:07.910 --> 00:53:12.299
the way I/O worked, and he printed out the
whole listing and took it to his parent's

00:53:12.299 --> 00:53:16.989
vacation house and spread it out all over
the floor and just worked with paper.

00:53:16.989 --> 00:53:20.219
So there's still that.
It's useful for some things.

00:53:20.219 --> 00:53:30.650
But no big shockers on the tool front, unless
you're expecting everybody to be using ID's.

00:53:30.650 --> 00:53:34.950
Then you'd be shocked.

00:53:34.950 --> 00:53:41.509
Q It's been, I think, 20 years since the book,
Programmers at Work, was published.

00:53:41.509 --> 00:53:47.630
Any difference between those interviews and,
you know, the culture shifts in the interviews

00:53:47.630 --> 00:53:48.630
that you did?

00:53:48.630 --> 00:53:53.140
Peter Seibel: So the question was there was
a book 20 years ago called Programmers at

00:53:53.140 --> 00:54:00.049
Work and what's changed?
Well, a bunch of stuff has changed.

00:54:00.049 --> 00:54:02.950
That book was -- there's a couple differences
just between the books.

00:54:02.950 --> 00:54:08.960
Because Programmers at Work was sort of at
the dawn of the PC Revolution, or whatever.

00:54:08.960 --> 00:54:14.569
They interviewed Bill Gates as a programmer,
because he sort of still was.

00:54:14.569 --> 00:54:20.619
And a lot of the people they interviewed were
working on microcomputers when those were

00:54:20.619 --> 00:54:23.950
new.
And so, in some ways, this book sort of goes

00:54:23.950 --> 00:54:29.770
on both sides of that, because a lot of the
people I interviewed really started before

00:54:29.770 --> 00:54:36.849
that era and worked on bigger machines.
There was this -- we sometimes forget -- there

00:54:36.849 --> 00:54:43.529
was this huge, in a way, step backwards.
At the time that PC's and micros came out,

00:54:43.529 --> 00:54:47.200
you know, all of a sudden it was back to writing
things in assembly and there was a point at

00:54:47.200 --> 00:54:50.319
which Microsoft said, "Okay, now we can start
using C."

00:54:50.319 --> 00:54:55.529
C is not so expensive that we can't -- it's
not too big and bloated -- we can move from

00:54:55.529 --> 00:54:59.890
assembly to C.
But at that same time, people were working

00:54:59.890 --> 00:55:03.140
on workstations.
They had lisp machines and the Smalltalk,

00:55:03.140 --> 00:55:10.860
and stuff was -- people were doing sort of
serious computation that got a little bit

00:55:10.860 --> 00:55:13.519
lost, and now, we're sort of finally coming
back around.

00:55:13.519 --> 00:55:17.719
The PC's have ramped up, and now they're powerful
enough that we can put up with the efficiencies

00:55:17.719 --> 00:55:25.940
of things like python and ruby and so forth.
So the other big difference between the two

00:55:25.940 --> 00:55:29.190
books is just that mine is a little more technically-oriented
I think.

00:55:29.190 --> 00:55:32.619
Programmers at Work was sort of -- everyone
was aware that there were these PC's, and

00:55:32.619 --> 00:55:35.799
they had -- IBM had the Charlie Chaplain ads
and, What is it all about?

00:55:35.799 --> 00:55:41.150
And so, Lammers was trying to get at that
for a little more general audience whereas

00:55:41.150 --> 00:55:47.299
mine was aimed at, "You are a programmer.
You want to know how these folks work." or

00:55:47.299 --> 00:55:51.380
think, or live, or whatever.
So yeah.

00:55:51.380 --> 00:55:55.150
And then, obviously anything that talks about
the Internet is, you know, that's changed

00:55:55.150 --> 00:56:00.920
how people look at programming.
Open source is much bigger now.

00:56:00.920 --> 00:56:05.759
Okay. We have time for one more question,
so you're it.

00:56:05.759 --> 00:56:16.339
Q So did anybody say something about negative
aspect of what they regret they see nowadays

00:56:16.339 --> 00:56:23.749
besides the obvious complexity of software?
Some trends they see as regrettable or something

00:56:23.749 --> 00:56:25.710
to be avoided and?

00:56:25.710 --> 00:56:34.589
Peter Seibel: Right. So the question is, Did
anyone have any worries about trends that

00:56:34.589 --> 00:56:37.670
are going the wrong direction as far as they're
concerned?

00:56:37.670 --> 00:56:41.529
Other than the complexity of software.
So that would be the main one.

00:56:41.529 --> 00:56:48.239
And I don't even know if people regretted
that so much as, you know, it should change

00:56:48.239 --> 00:56:56.059
just as it's inevitable.
I guess in a way the most interesting on -- there

00:56:56.059 --> 00:57:01.999
was some of that -- and probably the most
interesting was Donald Knuth.

00:57:01.999 --> 00:57:06.459
And it's hard to say, given who he is.
It's just part of -- he's a bit of a throw

00:57:06.459 --> 00:57:08.760
back.
The kinds of stuff he works on, he works on

00:57:08.760 --> 00:57:14.309
alone, and it's really not that big, you know,
compared to something like what you guys are

00:57:14.309 --> 00:57:19.209
building here.
But he was sort of very vehement about not

00:57:19.209 --> 00:57:24.099
liking black boxes.
You know, he said, "I recognize the use of

00:57:24.099 --> 00:57:29.199
black boxes and abstractions," but he said,
"I like to be able to open them up."

00:57:29.199 --> 00:57:33.019
You know and, "If there's an algorithm and
it's packaged up, I always think I can open

00:57:33.019 --> 00:57:37.200
it up and do it better."
And he gave an example -- this is sort of

00:57:37.200 --> 00:57:43.480
a simple example -- but if you have a, you
know, matrix multiply algorithm and then you

00:57:43.480 --> 00:57:48.480
want to use that sort of generic algorithm
for multiplying complex matrices, then it's

00:57:48.480 --> 00:57:52.499
4x, but if you can open it up on the inside,
there's an identity that lets you do it in

00:57:52.499 --> 00:57:55.359
3x time or whatever.
So you know, and I'm like, "Well, yeah.

00:57:55.359 --> 00:57:58.979
YOU can open up any box and make it better."
[laughter] "I'm not sure that's a good strategy

00:57:58.979 --> 00:58:04.140
for everyone."
But he was -- I mean, he felt like he seemed

00:58:04.140 --> 00:58:12.440
to regret that, you know, and I -- somewhere
here, he said, "There's overemphasis on reusable

00:58:12.440 --> 00:58:16.229
software where you never get to open up the
box and see what's inside.

00:58:16.229 --> 00:58:20.650
It's nice to have these black boxes, but almost
always, if you can look inside the box, you

00:58:20.650 --> 00:58:22.599
can improve it and make it better once you
know what's inside."

00:58:22.599 --> 00:58:31.089
And he just was saying, "So you get these
libraries and now you know that when you call

00:58:31.089 --> 00:58:35.839
this subroutine and you put XoYo, X1Y1, but
when you call this other subroutine, it's

00:58:35.839 --> 00:58:39.109
XoX1, YoY1, you get that right, and that's
your job."

00:58:39.109 --> 00:58:43.519
And he seemed to think that was sort of sad.
It's like, "It's no fun."

00:58:43.519 --> 00:58:52.319
He couldn't really say whether, you know,
Do we have to give up that fun to build big

00:58:52.319 --> 00:58:54.319
systems, or should we just stop trying to
build big systems?

00:58:54.319 --> 00:58:56.619
That's hard to say.
And he wasn't the only one.

00:58:56.619 --> 00:59:01.349
There was a little Joe Armstrong also echoed
this idea of, "It's good to open stuff up

00:59:01.349 --> 00:59:06.630
and not be put off by the abstractions."
And that sort of struck me -- as a friend

00:59:06.630 --> 00:59:11.710
of mine used to talk about -- the Jedi programming.
You are a Jedi. You have to build your own

00:59:11.710 --> 00:59:15.000
light saber.
So there's something to taking these things

00:59:15.000 --> 00:59:20.240
apart and figuring out how they work, but
obviously, you know, if we take apart everything,

00:59:20.240 --> 00:59:24.289
we'll never get anywhere.
There it is. Thank you.

00:59:24.289 --> 00:59:24.739
&gt;&gt; [Clapping]

