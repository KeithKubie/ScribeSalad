WEBVTT
Kind: captions
Language: en

00:00:01.300 --> 00:00:03.033
Morrill: All righty.

00:00:03.033 --> 00:00:06.567
Wow, this is a-a more packed
room than I expected

00:00:06.567 --> 00:00:08.367
considering
the little bit of news

00:00:08.367 --> 00:00:09.868
at the end
of the keynote there.

00:00:09.868 --> 00:00:11.968
I expected that all you guys
would be downstairs right now.

00:00:11.968 --> 00:00:14.100
But thanks for coming, anyway.

00:00:14.100 --> 00:00:16.334
Um...

00:00:18.968 --> 00:00:20.634
So my name is Dan Morrill.

00:00:20.634 --> 00:00:22.868
I'm with
Google Developer Relations.

00:00:22.868 --> 00:00:26.234
And I'm here today to, you know,
give you this presentation

00:00:26.234 --> 00:00:28.200
on "How Do I Code Thee?
Let Me Count the Ways."

00:00:28.200 --> 00:00:30.467
And really the point here
is to illustrate

00:00:30.467 --> 00:00:32.100
to you guys,
um, the various ways

00:00:32.100 --> 00:00:34.300
that you can build applications
on Android.

00:00:34.300 --> 00:00:36.234
So, you know, let's get started
and get right into it.

00:00:36.234 --> 00:00:38.734
So the first question I want
to answer is, "What is Android?"

00:00:38.734 --> 00:00:42.467
Um, well, you know,
at the bottom of Android,

00:00:42.467 --> 00:00:44.000
we have the Linux Kernel.

00:00:44.000 --> 00:00:45.367
And this is essentially
what we use

00:00:45.367 --> 00:00:46.734
for our
hardware abstraction layer.

00:00:46.734 --> 00:00:49.567
And this is where all the device
drivers live and so on.

00:00:49.567 --> 00:00:51.534
Um, above that we have
the native libraries

00:00:51.534 --> 00:00:54.767
for things like media...

00:00:54.767 --> 00:00:56.400
You know what?

00:00:56.400 --> 00:00:58.167
This isn't
what I want to do today

00:00:58.167 --> 00:00:59.534
'cause I think we've used
this slide

00:00:59.534 --> 00:01:01.801
at every single presentation
that we've ever done.

00:01:01.801 --> 00:01:02.901
I think it's time to put
this thing

00:01:02.901 --> 00:01:03.968
out to pasture and move on.

00:01:03.968 --> 00:01:05.000
So let me start over again.

00:01:05.000 --> 00:01:08.267
[cheers and applause]

00:01:08.267 --> 00:01:09.467
What is Android?

00:01:09.467 --> 00:01:10.934
Well, I want to make today
the case

00:01:10.934 --> 00:01:12.300
that Android
is really three things.

00:01:12.300 --> 00:01:15.667
The first is a chunk
of code for making phone calls.

00:01:15.667 --> 00:01:16.801
I owned one of those things.

00:01:16.801 --> 00:01:19.133
It was an awesome phone
back in the day.

00:01:19.133 --> 00:01:22.200
Um, and when I say it's a chunk
of code for making phone calls,

00:01:22.200 --> 00:01:24.167
what I really mean is,
you know, originally,

00:01:24.167 --> 00:01:27.534
cell phones had only
enough software to read input

00:01:27.534 --> 00:01:29.934
and drive the radio stack
to place a phone call--

00:01:29.934 --> 00:01:32.367
you know, single-function
devices and so on.

00:01:32.367 --> 00:01:33.901
And of course, you know,
obviously Android,

00:01:33.901 --> 00:01:36.367
as a, you know,
mobile-phone stack, has exactly

00:01:36.367 --> 00:01:37.767
that capability as well.

00:01:37.767 --> 00:01:40.334
So it's a chunk of code
for making calls.

00:01:40.334 --> 00:01:41.567
Android is also, you know,

00:01:41.567 --> 00:01:43.400
a robust network stack
and Internet client.

00:01:43.400 --> 00:01:45.501
And I remember, oh,
I don't even know, like,

00:01:45.501 --> 00:01:47.567
five or more years ago,
there was this TV commercial

00:01:47.567 --> 00:01:49.601
for one of the big carriers.

00:01:49.601 --> 00:01:51.968
Um, and it had a woman
who had a brand-new cell phone,

00:01:51.968 --> 00:01:53.234
and she was very proud of it.

00:01:53.234 --> 00:01:54.801
And she was bragging
about her new phone

00:01:54.801 --> 00:01:57.367
to, you know, a friend
or something like that.

00:01:57.367 --> 00:01:58.801
And the conversation went on
for a moment

00:01:58.801 --> 00:02:01.167
until somebody asked a question
that she couldn't answer,

00:02:01.167 --> 00:02:03.467
and the friend says, "Oh, well,
I'll just get my phone out

00:02:03.467 --> 00:02:05.667
and search the Internet
for it."

00:02:05.667 --> 00:02:08.300
And I remember this commercial,
because the woman said

00:02:08.300 --> 00:02:10.734
in this dejected, like,
most plaintive voice

00:02:10.734 --> 00:02:14.601
you can imagine, "You can get
the Internet on your phone?"

00:02:14.601 --> 00:02:16.067
And it was--
I just laughed out loud

00:02:16.067 --> 00:02:17.567
when I saw it,
not because it was funny,

00:02:17.567 --> 00:02:18.934
but because, to me, it's like,
that's something

00:02:18.934 --> 00:02:21.701
that I was already expecting
even five years ago.

00:02:21.701 --> 00:02:24.000
And so, you know, today,
you know, Android has

00:02:24.000 --> 00:02:26.067
a robust network stack
and Internet client.

00:02:26.067 --> 00:02:28.234
We've got a state-of-the-art
Web browser,

00:02:28.234 --> 00:02:32.534
you know, and a full TCIP--
TCP/IP stack.

00:02:32.534 --> 00:02:34.734
And, of course, the third thing,
and really the thing

00:02:34.734 --> 00:02:37.334
that I want to talk about most
today is Android is a platform

00:02:37.334 --> 00:02:38.868
for running code.

00:02:38.868 --> 00:02:39.868
Let me talk about that
a bit more.

00:02:39.868 --> 00:02:41.667
What do I mean
by running code?

00:02:41.667 --> 00:02:44.200
Well, Android has
an application model of its own.

00:02:44.200 --> 00:02:45.400
You guys are probably familiar

00:02:45.400 --> 00:02:47.868
or have heard
of the Dalvik virtual machine.

00:02:47.868 --> 00:02:49.467
And, you know, made available
to Dalvik

00:02:49.467 --> 00:02:51.934
is a variety of core framework
APIs and so on.

00:02:51.934 --> 00:02:53.434
Um, but, you know,
I love reading the press,

00:02:53.434 --> 00:02:55.367
because people, even today,
will still print things

00:02:55.367 --> 00:02:57.400
like, "Oh, you know, Google's
looking to extend its dominance

00:02:57.400 --> 00:02:59.100
to cell phones."

00:02:59.100 --> 00:03:00.868
That really isn't
what Android is about.

00:03:00.868 --> 00:03:03.868
We created Android
to be the open mobile platform

00:03:03.868 --> 00:03:05.067
that we needed.

00:03:05.067 --> 00:03:06.400
You know,
and so from that perspective,

00:03:06.400 --> 00:03:08.400
we don't really necessarily
"care," per se,

00:03:08.400 --> 00:03:10.834
how you guys build
your applications.

00:03:10.834 --> 00:03:13.701
We built the APIs
that run in Dalvik

00:03:13.701 --> 00:03:16.400
to be an intentionally
loosely coupled--

00:03:16.400 --> 00:03:19.067
and I like to describe them
as a federation of components.

00:03:19.067 --> 00:03:21.200
But basically what that means
is that your application

00:03:21.200 --> 00:03:23.234
consists of components
you write,

00:03:23.234 --> 00:03:25.634
as well as components
that you pull in

00:03:25.634 --> 00:03:28.868
from other applications that
are installed on the device.

00:03:28.868 --> 00:03:31.767
Um, and so those components
can include the Web.

00:03:31.767 --> 00:03:34.968
And they can, you know, also
include aspects of native code

00:03:34.968 --> 00:03:37.234
if you want to write code
that way as well.

00:03:37.234 --> 00:03:39.234
In other words, you know,
basically we just love code.

00:03:39.234 --> 00:03:41.901
Android is about letting
developers get their apps

00:03:41.901 --> 00:03:43.601
into users' hands
on a mobile device

00:03:43.601 --> 00:03:46.200
however, you know,
it works best for you.

00:03:46.200 --> 00:03:48.100
And so, you know,
in other words, you know,

00:03:48.100 --> 00:03:50.868
we welcome all code
from, you know, from anywhere.

00:03:50.868 --> 00:03:52.901
Yeah, I made this SPG myself.

00:03:52.901 --> 00:03:54.367
You can probably tell.

00:03:54.367 --> 00:03:57.434
Um, but, yeah, you know, really
we want to liberate your code

00:03:57.434 --> 00:03:59.067
and give you guys the openness
and freedom

00:03:59.067 --> 00:04:01.133
that you need
to build applications.

00:04:01.133 --> 00:04:03.067
So all that said,
that's the tone

00:04:03.067 --> 00:04:04.968
of what I want
to talk about today.

00:04:04.968 --> 00:04:06.000
So this is my agenda.

00:04:06.000 --> 00:04:07.100
You know, what I'm gonna do

00:04:07.100 --> 00:04:08.601
is I'm gonna demonstrate
to you guys

00:04:08.601 --> 00:04:10.300
three ways of writing code,

00:04:10.300 --> 00:04:12.968
kind of the three key ways
of writing code for Android.

00:04:12.968 --> 00:04:14.501
I'm gonna demonstrate
how to use them,

00:04:14.501 --> 00:04:16.734
so I'm gonna actually, you know,
show you some code and so on.

00:04:16.734 --> 00:04:17.901
And then towards the end,

00:04:17.901 --> 00:04:19.567
I'm also gonna draw
some conclusions,

00:04:19.567 --> 00:04:23.400
give you some useful comparisons
and statistics

00:04:23.400 --> 00:04:25.734
that you guys can use when
you're making your own decisions

00:04:25.734 --> 00:04:27.634
about application architecture.

00:04:27.634 --> 00:04:29.434
Throughout, I'm also going to,
you know, give you guys

00:04:29.434 --> 00:04:31.868
a taste of the road map
and some of the features

00:04:31.868 --> 00:04:33.067
that are coming.

00:04:33.067 --> 00:04:34.400
I do want to take
another moment

00:04:34.400 --> 00:04:36.234
to explain
what I'm not gonna cover.

00:04:36.234 --> 00:04:38.033
I'm gonna assume
that everybody here

00:04:38.033 --> 00:04:39.901
either already knows
how to build, you know,

00:04:39.901 --> 00:04:41.400
a Dalvik application for Android

00:04:41.400 --> 00:04:43.400
or knows how to build
an Ajax application,

00:04:43.400 --> 00:04:44.868
so I'm not gonna spend

00:04:44.868 --> 00:04:47.534
a lot of time talking about
the basics of app development.

00:04:47.534 --> 00:04:48.934
There's documentation online.

00:04:48.934 --> 00:04:51.801
There's, you know, other
sessions that you can go to

00:04:51.801 --> 00:04:54.434
today and tomorrow
to cover all that.

00:04:54.434 --> 00:04:56.934
Um, the other thing I'm not
gonna do is pass judgment.

00:04:56.934 --> 00:04:58.601
I'm not gonna give you
a pat answer.

00:04:58.601 --> 00:05:01.334
I'm not gonna give you,
you know, kind of a, you know,

00:05:01.334 --> 00:05:03.801
magic solution or an equation
that you solve for

00:05:03.801 --> 00:05:05.701
that tells you the right way
to build your application.

00:05:05.701 --> 00:05:08.033
My real aim here is to arm
you guys with the knowledge

00:05:08.033 --> 00:05:10.067
that you need to make
your own informed decisions

00:05:10.067 --> 00:05:11.767
about app development.

00:05:11.767 --> 00:05:14.234
So, you know, without further
ado, let's get into it.

00:05:14.234 --> 00:05:18.067
So what are the three flavors
of Android development?

00:05:18.067 --> 00:05:19.968
Well, first is native code,

00:05:19.968 --> 00:05:21.868
which runs on,
as I've alluded to before,

00:05:21.868 --> 00:05:23.534
a Dalvik virtual machine.

00:05:23.534 --> 00:05:25.133
This is a virtual machine
on the same order

00:05:25.133 --> 00:05:28.133
of, you know, a Java virtual
machine or a .Net CLR.

00:05:28.133 --> 00:05:30.067
It's a virtual machine
that runs some byte code.

00:05:30.067 --> 00:05:32.467
The second way is Ajax,

00:05:32.467 --> 00:05:34.701
who I believe is the guy
on the left.

00:05:34.701 --> 00:05:38.200
And Ajax is essentially
a technique for making

00:05:38.200 --> 00:05:42.000
dynamic user interfaces
in a Web browser,

00:05:42.000 --> 00:05:44.400
typically also talking
to the network

00:05:44.400 --> 00:05:48.234
and communicating to the server
for data operations.

00:05:48.234 --> 00:05:49.767
And then the third kind
is native code,

00:05:49.767 --> 00:05:52.567
which in the current builds
of Android include support

00:05:52.567 --> 00:05:57.100
for the ARM processor
written in C code.

00:05:57.100 --> 00:05:59.167
So let me then--
[clears throat] excuse me--

00:05:59.167 --> 00:06:01.667
jump into a bit more detail
about Dalvik.

00:06:06.100 --> 00:06:09.934
Um, but wait.
I actually need an example.

00:06:09.934 --> 00:06:12.801
Um, so what I want to do today
is--I've just described

00:06:12.801 --> 00:06:14.300
three different ways
of writing code.

00:06:14.300 --> 00:06:15.400
What I'm actually going to do

00:06:15.400 --> 00:06:18.400
is write the same app
all three ways,

00:06:18.400 --> 00:06:21.434
essentially the same app
using all three techniques.

00:06:21.434 --> 00:06:24.033
And so to do this
I need kind of a sample,

00:06:24.033 --> 00:06:26.801
or guinea pig, algorithm
to show you guys how this works

00:06:26.801 --> 00:06:28.567
and have
an apples-to-apples comparison.

00:06:28.567 --> 00:06:32.367
It needs to be externally--
or efficiently externalizable.

00:06:32.367 --> 00:06:34.434
And it has to make for
an interesting demonstration.

00:06:34.434 --> 00:06:36.667
I'm not just gonna show
you guys, um,

00:06:36.667 --> 00:06:38.968
you know, some things
without pretty pictures as well.

00:06:38.968 --> 00:06:41.200
So this is just a text
of what I'm going to describe

00:06:41.200 --> 00:06:42.968
on the next slide.

00:06:42.968 --> 00:06:44.734
So what I'm gonna do today,
and this is a shout-out

00:06:44.734 --> 00:06:46.901
to my friend and colleague
Kelly Norton,

00:06:46.901 --> 00:06:49.734
who, when I kind of whined
about needing an algorithm,

00:06:49.734 --> 00:06:51.701
the first words out of his mouth
were "K-Means clustering."

00:06:51.701 --> 00:06:53.567
So I looked it up, and I'm like,
"Ah, yes, that's perfect."

00:06:53.567 --> 00:06:56.901
Um, but what it is
is essentially it's a member

00:06:56.901 --> 00:06:58.100
of an algorithm family

00:06:58.100 --> 00:06:59.734
that Google actually uses
a lot internally

00:06:59.734 --> 00:07:03.300
for, you know,
"machine learning" style things,

00:07:03.300 --> 00:07:05.400
where we're, you know, doing
some text processing and so on.

00:07:05.400 --> 00:07:07.501
So it's apropos to Google.

00:07:07.501 --> 00:07:10.400
And the way it works is--
you see up there

00:07:10.400 --> 00:07:13.501
there's a number of gray squares
and then some colored red dots.

00:07:13.501 --> 00:07:15.234
The gray squares
are data points.

00:07:15.234 --> 00:07:17.033
And they're essentially
distributed, you know,

00:07:17.033 --> 00:07:18.834
however your data
is distributed.

00:07:18.834 --> 00:07:20.834
The way K-Means works
is basically you have

00:07:20.834 --> 00:07:23.000
one mean point,
which is the circles,

00:07:23.000 --> 00:07:25.467
associated with every cluster
that you want to create.

00:07:25.467 --> 00:07:28.367
So in the example depicted here,
which came from Wikipedia,

00:07:28.367 --> 00:07:32.534
they're actually three groups--
red, green, and blue--

00:07:32.534 --> 00:07:35.000
and they're clustering
those 12 gray points

00:07:35.000 --> 00:07:36.234
into the three groups.

00:07:36.234 --> 00:07:37.701
So the algorithm's
actually very simple.

00:07:37.701 --> 00:07:41.234
All you do is compute which mean
every point is closest to

00:07:41.234 --> 00:07:42.968
and associate it
with that cluster.

00:07:42.968 --> 00:07:45.667
Then after you've done
all of that,

00:07:45.667 --> 00:07:48.400
you iterate
over the groups again,

00:07:48.400 --> 00:07:50.734
and you recompute the centroid

00:07:50.734 --> 00:07:52.567
or, you know,
the mean or the average

00:07:52.567 --> 00:07:55.501
or the center point of each
cluster based on all the new--

00:07:55.501 --> 00:07:57.667
as the average of all
the new members in the group.

00:07:57.667 --> 00:07:58.901
And this is a greedy algorithm.

00:07:58.901 --> 00:08:00.601
You keep running it
until it converges

00:08:00.601 --> 00:08:03.067
or until you decide to stop.

00:08:03.067 --> 00:08:04.701
So that's the algorithm
that I'm going to implement.

00:08:04.701 --> 00:08:06.901
[clears throat]

00:08:06.901 --> 00:08:10.200
Um, and, you know, as you
can see here on the right,

00:08:10.200 --> 00:08:13.634
I don't think--yeah, there's
kind of a big black area

00:08:13.634 --> 00:08:15.200
in the upper left corner.

00:08:15.200 --> 00:08:16.868
That's actually
a dark-blue color,

00:08:16.868 --> 00:08:19.100
so sorry for the low visibility
on that.

00:08:19.100 --> 00:08:21.434
But as you can see,
it's essentially just plots

00:08:21.434 --> 00:08:25.434
each of the points according
to which group it is in

00:08:25.434 --> 00:08:26.801
by color-coded scheme.

00:08:26.801 --> 00:08:28.634
Okay, so now back to Dalvik.

00:08:28.634 --> 00:08:32.234
So Dalvik is...

00:08:32.234 --> 00:08:34.567
a virtual machine
as I mentioned earlier.

00:08:34.567 --> 00:08:38.434
And so it's similar
to the .Net CLR

00:08:38.434 --> 00:08:39.667
or a Java virtual machine.

00:08:39.667 --> 00:08:41.634
It's memory-protected,
garbage-collected,

00:08:41.634 --> 00:08:43.100
and life cycle-managed
and so on.

00:08:43.100 --> 00:08:46.200
It's optimized
for embedded machines, though,

00:08:46.200 --> 00:08:47.901
meaning that, you know,
one of the reasons

00:08:47.901 --> 00:08:49.901
why we didn't just adopt,
you know,

00:08:49.901 --> 00:08:51.567
say, a Java virtual machine
for Android

00:08:51.567 --> 00:08:55.234
is because the stack model that
a Java virtual machine defines

00:08:55.234 --> 00:08:56.567
introduces a lot of overhead

00:08:56.567 --> 00:08:58.067
when you're running
on a, you know,

00:08:58.067 --> 00:09:00.434
a register-based processor
and so on.

00:09:00.434 --> 00:09:02.701
And so for that reason we have
a custom byte code format,

00:09:02.701 --> 00:09:06.300
and the tool chain includes
a converter that translates

00:09:06.300 --> 00:09:09.901
to Dalvik byte code
from Java byte code.

00:09:09.901 --> 00:09:11.767
Um, so how do you write an app
on Dalvik?

00:09:11.767 --> 00:09:15.467
Well, generally you just write
Java source code.

00:09:15.467 --> 00:09:17.667
It goes through that compilation
and translation phase.

00:09:17.667 --> 00:09:21.634
And, you know, you make use
of the framework APIs

00:09:21.634 --> 00:09:23.234
that are provided
by the system,

00:09:23.234 --> 00:09:26.400
and that's things
like the view hierarchy

00:09:26.400 --> 00:09:29.267
and, you know,
network access and so on.

00:09:29.267 --> 00:09:33.100
Um, the APIs that need to be
are backed by native code,

00:09:33.100 --> 00:09:35.567
meaning that, you know, like,

00:09:35.567 --> 00:09:38.234
OpenGL, interprocess
communication, and so on,

00:09:38.234 --> 00:09:40.901
these all punch down
into native code out of Dalvik

00:09:40.901 --> 00:09:42.868
to do the actual work.

00:09:42.868 --> 00:09:44.968
And so, you know, we do support
the popular development tools.

00:09:44.968 --> 00:09:47.400
That's one of the reasons
why we went out of our way

00:09:47.400 --> 00:09:48.968
to include support
for the Java language,

00:09:48.968 --> 00:09:50.567
and we have
an Eclipse plug-in available,

00:09:50.567 --> 00:09:52.067
which, you know,
we have a screenshot

00:09:52.067 --> 00:09:54.000
of that running there.

00:09:54.000 --> 00:09:56.200
Um, so what can you do
with Dalvik?

00:09:56.200 --> 00:09:57.400
Well, the key thing with Dalvik

00:09:57.400 --> 00:09:59.033
is that you can do rich clients
with it.

00:09:59.033 --> 00:10:02.334
It's the richest form
of app development on Android.

00:10:02.334 --> 00:10:06.100
Um, you can do--you have full
control of the user interface.

00:10:06.100 --> 00:10:08.467
You can run code
in the background.

00:10:08.467 --> 00:10:09.767
You can share components

00:10:09.767 --> 00:10:12.300
either from applications
that you use yourself,

00:10:12.300 --> 00:10:16.167
or you can export components
that other applications can use.

00:10:16.167 --> 00:10:18.267
You have the option
to do tight integration

00:10:18.267 --> 00:10:19.701
with system events in UI.

00:10:19.701 --> 00:10:21.534
But again, I'm not gonna cover
all this in detail,

00:10:21.534 --> 00:10:23.167
'cause there's other sessions
you can go to

00:10:23.167 --> 00:10:24.901
and you can check
our online docs.

00:10:24.901 --> 00:10:27.067
So, you know, the other thing
I want to cover is, well,

00:10:27.067 --> 00:10:29.400
what can you not do, what are
the limitations of Dalvik?

00:10:29.400 --> 00:10:30.667
And, you know,
clearly not much.

00:10:30.667 --> 00:10:32.234
You know, we've built Android

00:10:32.234 --> 00:10:36.200
so that Dalvik is the primary,
you know, execution environment.

00:10:36.200 --> 00:10:37.734
It's the crossroads,
if you will,

00:10:37.734 --> 00:10:42.200
of all the other components
that--that I'll describe later.

00:10:42.200 --> 00:10:44.234
And that's really quite literal.
It is a crossroads.

00:10:44.234 --> 00:10:45.868
I don't expect you to understand
what that means, though,

00:10:45.868 --> 00:10:47.234
but by the end of the session,

00:10:47.234 --> 00:10:48.567
after I've gone
through all the demos,

00:10:48.567 --> 00:10:50.234
I think you guys
will understand what I mean

00:10:50.234 --> 00:10:52.067
when I say crossroads.

00:10:52.067 --> 00:10:53.534
Of course,
that doesn't necessarily mean

00:10:53.534 --> 00:10:55.667
that it's the right thing
for every application out there.

00:10:55.667 --> 00:10:58.367
If you're writing an application
that's performance-intensive

00:10:58.367 --> 00:11:00.934
and you need a lot of speed,
um, you know,

00:11:00.934 --> 00:11:03.234
sometimes it may make sense--
and I'll just foreshadow here--

00:11:03.234 --> 00:11:04.968
to use native code for that.

00:11:04.968 --> 00:11:07.701
In other cases, if you're
just building sort of an adjunct

00:11:07.701 --> 00:11:09.634
to a Web site and you just want
a mobile presence,

00:11:09.634 --> 00:11:11.734
you know, you may not need
things like tight integration

00:11:11.734 --> 00:11:13.100
and background processing,

00:11:13.100 --> 00:11:15.367
and in that case it may make
sense to go ahead and use

00:11:15.367 --> 00:11:17.400
an Ajax app for that.

00:11:17.400 --> 00:11:21.167
So let me stop, you know,
talking and just showing slides

00:11:21.167 --> 00:11:25.100
for just a moment
and jump out to Eclipse

00:11:25.100 --> 00:11:26.868
and do a quick demo for you.

00:11:26.868 --> 00:11:28.634
So here I have Eclipse

00:11:28.634 --> 00:11:32.400
with the Android plug-in ADT
installed.

00:11:32.400 --> 00:11:33.734
And the first thing
I'm going to do

00:11:33.734 --> 00:11:38.400
is import an existing project...

00:11:38.400 --> 00:11:42.167
um, from my demo directory.

00:11:45.567 --> 00:11:47.601
And so this is some code
that I wrote.

00:11:47.601 --> 00:11:49.534
[clears throat]

00:11:55.734 --> 00:12:00.167
And I have a quick error
that I have to correct.

00:12:03.234 --> 00:12:05.100
Oh, okay, good,
I recompiled it away.

00:12:05.100 --> 00:12:08.267
Um, so, yeah,
this is my project.

00:12:08.267 --> 00:12:11.167
Now, um, the first thing
that I want to start with

00:12:11.167 --> 00:12:14.667
is, you know, this one class
here called KMeansActivity.

00:12:14.667 --> 00:12:16.133
As you can see,
this is very simple.

00:12:16.133 --> 00:12:17.834
All this is essentially doing,

00:12:17.834 --> 00:12:19.734
if you're not super-familiar
with Android development--

00:12:19.734 --> 00:12:22.501
all this is really doing
is it's describing the creation

00:12:22.501 --> 00:12:24.033
of a single screen, you know,

00:12:24.033 --> 00:12:26.934
that takes up
my phone's display.

00:12:26.934 --> 00:12:30.400
And it essentially defines that
this layout that I've defined

00:12:30.400 --> 00:12:34.667
in an XML file is what
I should display in that screen.

00:12:34.667 --> 00:12:38.868
So if you look at that XML file,
which I'll open over here--

00:12:38.868 --> 00:12:42.701
um, you could just go
to the XML view--

00:12:42.701 --> 00:12:45.667
you can see that the entire view
itself was also very simple

00:12:45.667 --> 00:12:48.868
and consists of this K-Means
view class that I wrote.

00:12:48.868 --> 00:12:51.434
Okay, so let's look
at that view class.

00:12:51.434 --> 00:12:55.367
Um, this class has down here
a bunch of boilerplate

00:12:55.367 --> 00:12:57.400
for handling--
[clears throat] excuse me--

00:12:57.400 --> 00:13:00.300
surface changes,
so, like, the screen resizes,

00:13:00.300 --> 00:13:03.200
or the device reorients
or something like that.

00:13:03.200 --> 00:13:05.367
Um, but really
the magic happens up here.

00:13:05.367 --> 00:13:07.300
And what I'm doing
is I'm creating this class

00:13:07.300 --> 00:13:08.901
called KMeansThread.

00:13:08.901 --> 00:13:11.834
Now, if you want more detail on
what exactly is going on here,

00:13:11.834 --> 00:13:15.000
this is based
on the Lunar Lander demo

00:13:15.000 --> 00:13:17.801
in the STK sample code,
so you can check that out

00:13:17.801 --> 00:13:21.534
for a more kind of robust
example of how animation works.

00:13:21.534 --> 00:13:22.968
But it's adapted from that,

00:13:22.968 --> 00:13:25.467
and really all I'm doing
is I'm passing it

00:13:25.467 --> 00:13:27.634
a new thread, two arguments.

00:13:27.634 --> 00:13:30.801
One is this older object,
which is a handle to a canvas

00:13:30.801 --> 00:13:32.367
so that the thread can do
its own drawing

00:13:32.367 --> 00:13:34.100
directly into that surface,

00:13:34.100 --> 00:13:36.367
but the other thing
is this class here

00:13:36.367 --> 00:13:38.801
called the Dalvik clusterer.

00:13:38.801 --> 00:13:40.133
So let's look at that.

00:13:40.133 --> 00:13:42.701
Dalvik clusterer
is an implementation

00:13:42.701 --> 00:13:44.167
of this Clusterer interface.

00:13:44.167 --> 00:13:45.734
So let's go there real quick.

00:13:45.734 --> 00:13:47.734
And all Clusterer does
is define a point,

00:13:47.734 --> 00:13:51.367
and this is just a carrier class
or, you know,

00:13:51.367 --> 00:13:55.701
the NxNy coordinate pair and
a designation of which cluster

00:13:55.701 --> 00:13:57.667
that point
is currently associated with.

00:13:57.667 --> 00:13:59.667
So in other words, this is
kind of the raw data point

00:13:59.667 --> 00:14:01.734
that my algorithm operates over.

00:14:01.734 --> 00:14:03.334
And then it defines
this other method down here

00:14:03.334 --> 00:14:07.133
called Clusterer, which takes
a list of points and performs

00:14:07.133 --> 00:14:09.834
that K-Means clustering
that I described earlier.

00:14:09.834 --> 00:14:12.901
So if I go back to Dalvik,
then, you see that I over--

00:14:12.901 --> 00:14:15.000
I implement the Cluster method.

00:14:15.000 --> 00:14:17.267
I have this other method down
here, which is just computing

00:14:17.267 --> 00:14:20.300
the cartesian distance between
two points in a 2D plane.

00:14:20.300 --> 00:14:23.901
But really the magic happens
in this loop up here.

00:14:23.901 --> 00:14:26.901
So I initialize a bunch
of variables

00:14:26.901 --> 00:14:29.434
to, you know,
some insane value,

00:14:29.434 --> 00:14:32.267
but the loop I want to focus on
is this one here.

00:14:32.267 --> 00:14:34.901
You can see that this loop runs
until I decide

00:14:34.901 --> 00:14:37.000
that the algorithm
has converged,

00:14:37.000 --> 00:14:39.634
and, you know, this block here
is really where the heart

00:14:39.634 --> 00:14:41.033
of the algorithm happens,
and, as you can see,

00:14:41.033 --> 00:14:42.367
it's pretty simple.

00:14:42.367 --> 00:14:46.601
For every point in my list,
for every group,

00:14:46.601 --> 00:14:49.868
or, you know, every cluster
that I'm processing,

00:14:49.868 --> 00:14:53.067
compute the distance
between the current point

00:14:53.067 --> 00:14:55.601
and the current center
of the group,

00:14:55.601 --> 00:14:58.367
and then see if that distance
is less than the distance

00:14:58.367 --> 00:14:59.567
from the current point

00:14:59.567 --> 00:15:01.601
to the group
it's currently associated with.

00:15:01.601 --> 00:15:03.567
So in other words, I'm just
looking for the low watermark

00:15:03.567 --> 00:15:07.734
of the centroid, or mean,
of each group

00:15:07.734 --> 00:15:09.801
that the current point
is closest to.

00:15:09.801 --> 00:15:12.234
In other words, if the point
is determined to be closer

00:15:12.234 --> 00:15:14.567
to the current group than
the group it's currently in,

00:15:14.567 --> 00:15:17.067
I update the information here
to say that,

00:15:17.067 --> 00:15:19.767
"Okay, you're now in the new
group that you're closest to."

00:15:19.767 --> 00:15:22.467
Um, after that, I just have--
you know, if it converged,

00:15:22.467 --> 00:15:23.934
if there was no data change,
then that means

00:15:23.934 --> 00:15:26.434
that the algorithm is over,
and I can do an early break.

00:15:26.434 --> 00:15:29.300
And then in here, I just have
a block where I recompute

00:15:29.300 --> 00:15:33.067
the centroids as that last step
before the next iteration.

00:15:33.067 --> 00:15:34.167
So that's it.

00:15:34.167 --> 00:15:36.834
This is a pretty
straightforward,

00:15:36.834 --> 00:15:38.734
you know, algorithm.

00:15:38.734 --> 00:15:40.567
So let me run this for you.

00:15:40.567 --> 00:15:43.501
So I'll create a new launcher
called "KMeans."

00:15:51.467 --> 00:15:54.067
And run this...

00:15:54.067 --> 00:15:56.701
on my device...

00:15:56.701 --> 00:15:58.501
which I have here.

00:16:00.834 --> 00:16:02.567
And you can see
in the background,

00:16:02.567 --> 00:16:05.167
Eclipse is launching activity.

00:16:09.234 --> 00:16:11.167
And then there it is running.

00:16:11.167 --> 00:16:12.767
Okay, the autofocuser's having
a little bit of trouble there,

00:16:12.767 --> 00:16:16.167
but you can see
that what it's doing is--

00:16:16.167 --> 00:16:18.701
up here, there's two numbers
that are being drawn.

00:16:18.701 --> 00:16:21.400
The top number is the
rendering time in milliseconds,

00:16:21.400 --> 00:16:24.067
and the bottom number
is the computation time

00:16:24.067 --> 00:16:25.434
in milliseconds.

00:16:25.434 --> 00:16:26.667
And the point
that I want to make

00:16:26.667 --> 00:16:28.067
is that it renders actually
really fast,

00:16:28.067 --> 00:16:30.400
on the order
of 15 to 18 milliseconds.

00:16:30.400 --> 00:16:32.234
And that's the time it takes
to physically draw

00:16:32.234 --> 00:16:35.100
500 color-coded points
on the screen.

00:16:35.100 --> 00:16:37.701
But the computation time here
is quite clearly the bottleneck,

00:16:37.701 --> 00:16:42.234
on the order of almost a second
in some cases.

00:16:42.234 --> 00:16:44.667
So that's it.
That's the basic algorithm.

00:16:44.667 --> 00:16:46.534
This is the most boring
implementation of this

00:16:46.534 --> 00:16:48.567
that you're gonna see today.

00:16:48.567 --> 00:16:51.234
Um, consider it the baseline.

00:16:52.734 --> 00:16:55.367
So--So what are some examples
of Dalvik apps

00:16:55.367 --> 00:16:56.834
in the real world?

00:16:56.834 --> 00:16:59.334
Um, well, the core system apps
are all Dalvik applications.

00:16:59.334 --> 00:17:01.267
Here you see the dialer.

00:17:01.267 --> 00:17:03.901
And additionally, nearly all
of the apps currently available

00:17:03.901 --> 00:17:05.701
on the market,
such as Google Sky Map,

00:17:05.701 --> 00:17:06.868
which you see on the right here,

00:17:06.868 --> 00:17:09.634
are also, you know, Android--

00:17:09.634 --> 00:17:12.000
or, excuse me, are also
Dalvik applications.

00:17:12.000 --> 00:17:13.567
So what are some of the things
that we're gonna be working on

00:17:13.567 --> 00:17:15.234
in the future for Dalvik apps?

00:17:15.234 --> 00:17:17.767
Uh, well,
improved garbage collection,

00:17:17.767 --> 00:17:19.367
as well as, the team
has also started work

00:17:19.367 --> 00:17:21.567
on the Just-In-Time compiler

00:17:21.567 --> 00:17:24.000
and, you know, as always,
additional optimizations

00:17:24.000 --> 00:17:25.968
in the core libraries,
so, you know,

00:17:25.968 --> 00:17:28.167
some of the libraries
that are available to you

00:17:28.167 --> 00:17:29.634
will get faster over time.

00:17:29.634 --> 00:17:31.534
And then, of course, you know,
we're not gonna sit idle.

00:17:31.534 --> 00:17:33.100
Dalvik is the main place.

00:17:33.100 --> 00:17:37.167
It is the main embodiment of all
of the device framework APIs.

00:17:37.167 --> 00:17:38.400
And so things like Bluetooth,

00:17:38.400 --> 00:17:39.901
you know, peer-to-peer
networking, and so on,

00:17:39.901 --> 00:17:45.100
these will start to appear
in--in Dalvik APIs.

00:17:45.100 --> 00:17:47.667
So the next thing I want to do
is talk about Web apps

00:17:47.667 --> 00:17:49.601
or Ajax apps for a moment.

00:17:53.400 --> 00:17:56.801
So Ajax applications
are characterized,

00:17:56.801 --> 00:17:59.000
or at least I like to think
of them as being characterized,

00:17:59.000 --> 00:18:04.067
as really a separation
of your UI and your appearance

00:18:04.067 --> 00:18:07.400
in the form of, you know,
HTML and CSS and so on.

00:18:07.400 --> 00:18:10.400
Your declarative layout
as separate from the code

00:18:10.400 --> 00:18:12.767
that runs and mutates
your layout.

00:18:12.767 --> 00:18:16.567
And so the general model here
is that, you know,

00:18:16.567 --> 00:18:19.067
in an Ajax application
you have the browser running,

00:18:19.067 --> 00:18:20.634
you've specified

00:18:20.634 --> 00:18:24.434
a document tree and
the appearance in HTML and CSS,

00:18:24.434 --> 00:18:26.133
and you're running
some JavaScript code

00:18:26.133 --> 00:18:28.434
in the browser to, you know,
mutate or change.

00:18:28.434 --> 00:18:31.701
You add data, you remove data,
you animate things, and so on.

00:18:31.701 --> 00:18:33.968
You can do limited
network access at least

00:18:33.968 --> 00:18:36.400
in the old-school way
of doing Ajax

00:18:36.400 --> 00:18:38.934
via, you know, this notion
of XMLHttpRequest,

00:18:38.934 --> 00:18:41.000
which lets you issue requests
back to your server

00:18:41.000 --> 00:18:42.701
to store data, read data,

00:18:42.701 --> 00:18:44.567
perform other operations,
and so on.

00:18:44.567 --> 00:18:46.400
And then recently, there's
this thing that, you know,

00:18:46.400 --> 00:18:48.200
obviously you guys saw
quite a bit of

00:18:48.200 --> 00:18:49.767
in the keynote this morning

00:18:49.767 --> 00:18:52.968
about, you know, this canvas tag
that is relatively new.

00:18:52.968 --> 00:18:54.667
And this allows JavaScript
to do something

00:18:54.667 --> 00:18:56.767
that it couldn't do before,
which is direct painting.

00:18:56.767 --> 00:18:59.734
Now, in the keynote, you might
recall that Vic mentioned--

00:18:59.734 --> 00:19:01.067
you know,
he asked the question,

00:19:01.067 --> 00:19:02.834
"How do you draw
a diagonal line?"

00:19:02.834 --> 00:19:05.734
Similarly, in the old-school way
of doing JavaScript,

00:19:05.734 --> 00:19:07.667
if you're at all familiar
with that programming model,

00:19:07.667 --> 00:19:10.000
you probably realize it would
also be pretty difficult

00:19:10.000 --> 00:19:12.167
to do something as simple
as draw 500 color-coded points

00:19:12.167 --> 00:19:13.267
on the screen.

00:19:13.267 --> 00:19:14.767
Fortunately, we have
the canvas tag,

00:19:14.767 --> 00:19:17.067
and that gives us
a lot more flexibility and power

00:19:17.067 --> 00:19:20.501
in JavaScript applications
than we had before.

00:19:20.501 --> 00:19:22.734
So what about Ajax specifically
on Android?

00:19:22.734 --> 00:19:25.234
Um, so these are notes
on Android 1.5,

00:19:25.234 --> 00:19:28.400
which is the current version
that is being distributed

00:19:28.400 --> 00:19:30.467
to users worldwide.

00:19:30.467 --> 00:19:33.834
Um, the browser in Android
is based on WebKit,

00:19:33.834 --> 00:19:35.067
and currently it's based

00:19:35.067 --> 00:19:37.901
on the SquirrelFish JavaScript
virtual machine.

00:19:37.901 --> 00:19:41.234
Um, the specific version
of WebKit

00:19:41.234 --> 00:19:42.734
is equivalent to Safari 4 beta.

00:19:42.734 --> 00:19:46.334
But oops, due to a bug
in the browser code of 1.5,

00:19:46.334 --> 00:19:48.968
it's actually still reporting
as Safari 3.1.2.

00:19:48.968 --> 00:19:52.367
So you've got all of
the Safari 4 beta functionality

00:19:52.367 --> 00:19:53.601
and speed and so on.

00:19:53.601 --> 00:19:55.968
We're just misreporting
the user-agent string.

00:19:55.968 --> 00:19:58.567
It does include Gears 0.5.17.0,

00:19:58.567 --> 00:20:00.901
which is one
of the more recent Gears builds,

00:20:00.901 --> 00:20:03.601
including Geolocation support.

00:20:03.601 --> 00:20:05.767
Um, and then of course,
it does include support

00:20:05.767 --> 00:20:07.434
for that canvas tag
that I mentioned earlier

00:20:07.434 --> 00:20:10.467
and, in fact, has included that
even since version 1.0.

00:20:10.467 --> 00:20:11.801
Well, what can you do with this?

00:20:11.801 --> 00:20:13.701
Well, you know it's
a state-of-the-art browser,

00:20:13.701 --> 00:20:15.234
and so it's really good
at rendering static pages

00:20:15.234 --> 00:20:16.934
if that's really what
you want to do.

00:20:16.934 --> 00:20:19.200
But we're here
to talk about applications,

00:20:19.200 --> 00:20:21.267
which are quite a bit more
dynamic than just static pages.

00:20:21.267 --> 00:20:23.834
And so, you know, you can do
anything that you can do

00:20:23.834 --> 00:20:27.133
in, you know, a desktop browser
on Android.

00:20:27.133 --> 00:20:28.734
You can fetch data,

00:20:28.734 --> 00:20:31.400
and then, of course, the big
issue is, you know, HTML5.

00:20:31.400 --> 00:20:33.167
I hope you guys are excited
by some of the stuff

00:20:33.167 --> 00:20:34.501
you saw in the keynote.

00:20:34.501 --> 00:20:37.400
All that is coming to Dalv--

00:20:37.400 --> 00:20:38.734
or, excuse me,
it's coming to Android

00:20:38.734 --> 00:20:40.667
over time in the browser.

00:20:40.667 --> 00:20:41.934
Um, right now we've got Gears.

00:20:41.934 --> 00:20:43.334
That's what
you can start coding to today.

00:20:43.334 --> 00:20:46.734
And over time,
we'll shift over to HTML5.

00:20:46.734 --> 00:20:48.934
Um, but, yeah, I mean,
HTML5 lets you do everything

00:20:48.934 --> 00:20:49.934
that you'd like
to be able to do.

00:20:49.934 --> 00:20:51.167
You can access your location.

00:20:51.167 --> 00:20:52.834
You can run code out of band
in the background,

00:20:52.834 --> 00:20:55.801
store pages in data locally
and everything.

00:20:55.801 --> 00:20:58.234
So I mentioned this earlier.

00:20:58.234 --> 00:20:59.934
Android does not
currently have HTML5.

00:20:59.934 --> 00:21:01.334
It has elements of it.

00:21:01.334 --> 00:21:03.701
Over time, we're gonna be adding
more elements.

00:21:03.701 --> 00:21:05.868
And in the meantime,
you can use Gears.

00:21:05.868 --> 00:21:08.334
But the big things
that you can't do,

00:21:08.334 --> 00:21:09.834
even with this model,
on Android,

00:21:09.834 --> 00:21:11.601
are things
like background processing.

00:21:11.601 --> 00:21:14.567
And what I mean there is if the
browser's not running at all,

00:21:14.567 --> 00:21:17.501
you know, any application
that would normally run

00:21:17.501 --> 00:21:21.901
in your browser page context
is not executing.

00:21:21.901 --> 00:21:24.234
And so that does limit
what you can do to some extent,

00:21:24.234 --> 00:21:26.367
you know,
with an Ajax application.

00:21:26.367 --> 00:21:28.434
The only thing that you can't do
is you can't access the system

00:21:28.434 --> 00:21:29.701
in framework APIs.

00:21:29.701 --> 00:21:32.234
You know, so things like,
you know, GL,

00:21:32.234 --> 00:21:34.234
you know,
some of the networking APIs,

00:21:34.234 --> 00:21:36.734
the ability to open
arbitrary TCP/IP sockets.

00:21:36.734 --> 00:21:37.901
You can't do these things

00:21:37.901 --> 00:21:41.834
through a strict
Ajax application...

00:21:41.834 --> 00:21:43.234
by default.

00:21:43.234 --> 00:21:46.400
So hold that thought.
I'll come back to that later.

00:21:46.400 --> 00:21:48.334
So what I want to do now
is show you a quick demo

00:21:48.334 --> 00:21:51.334
of the same algorithm
that I showed you earlier,

00:21:51.334 --> 00:21:54.534
but this time implemented

00:21:54.534 --> 00:21:56.667
as, you know,
in a browser application.

00:21:56.667 --> 00:21:59.167
So this is--this browser
that I'm running here

00:21:59.167 --> 00:22:01.767
with--I believe that's Cut Man
up there--

00:22:01.767 --> 00:22:05.467
is Safari 4, one of the betas.

00:22:05.467 --> 00:22:08.400
So what I want to do is
go to this URL.

00:22:12.100 --> 00:22:15.234
This is a plain, old--
you can enter that URL

00:22:15.234 --> 00:22:16.834
in your own browser
if you want.

00:22:16.834 --> 00:22:19.434
It's just a plain, old app
engine instance that I'm using

00:22:19.434 --> 00:22:22.567
as a convenient way
to store some files.

00:22:22.567 --> 00:22:25.734
So this is...

00:22:25.734 --> 00:22:27.234
let me just rerun this
a few times,

00:22:27.234 --> 00:22:29.868
and you can see that, you know,
this is also doing

00:22:29.868 --> 00:22:33.033
the same thing here--
the same algorithm,

00:22:33.033 --> 00:22:34.300
you know, yellow here,
green here,

00:22:34.300 --> 00:22:36.367
purple, blue, orange, red.

00:22:36.367 --> 00:22:38.467
It's the exact same behavior

00:22:38.467 --> 00:22:40.033
as you just saw running
on the device over here

00:22:40.033 --> 00:22:42.601
but done in a desktop browser.

00:22:42.601 --> 00:22:44.734
Um, the first thing I want to do
is point out these speeds.

00:22:44.734 --> 00:22:46.567
Again, those same numbers
are the same ones

00:22:46.567 --> 00:22:47.734
that you just saw here.

00:22:47.734 --> 00:22:49.834
Nine milliseconds drawing time

00:22:49.834 --> 00:22:52.100
and six milliseconds
computation time.

00:22:52.100 --> 00:22:54.601
This is
a state-of-the-art browser.

00:22:54.601 --> 00:22:56.234
You know, on a desktop,
running at--

00:22:56.234 --> 00:22:57.834
I don't even know
how fast these things are,

00:22:57.834 --> 00:22:59.400
these MacBooks.

00:22:59.400 --> 00:23:01.367
Another thing I want to do,
though, is run this--

00:23:01.367 --> 00:23:05.033
you know, I also have installed
on my Mac here

00:23:05.033 --> 00:23:07.501
an early build of Chromium.

00:23:09.067 --> 00:23:11.567
And you can see here that this
is also screamingly fast.

00:23:11.567 --> 00:23:13.067
So these are, you know,

00:23:13.067 --> 00:23:14.734
state-of-the-art
desktop browsers,

00:23:14.734 --> 00:23:16.400
and that's the first point
I want to draw--

00:23:16.400 --> 00:23:17.968
or the first distinction
that I want to make.

00:23:17.968 --> 00:23:19.434
Let me just point this out
to you guys.

00:23:19.434 --> 00:23:21.067
You know, phones--

00:23:21.067 --> 00:23:22.801
it doesn't matter
what kind of a phone it is

00:23:22.801 --> 00:23:24.133
or what operating system
it's running.

00:23:24.133 --> 00:23:25.934
Phones are slow.

00:23:25.934 --> 00:23:27.834
And that isn't gonna change
for a long time.

00:23:27.834 --> 00:23:31.067
You know, they're fast enough
so that the user interface

00:23:31.067 --> 00:23:33.567
can feel smooth and fluid
and so on.

00:23:33.567 --> 00:23:34.901
But when it comes
right down to it,

00:23:34.901 --> 00:23:36.901
a lot of what you do
is just not ever gonna be

00:23:36.901 --> 00:23:38.467
as fast, for a long time,

00:23:38.467 --> 00:23:40.868
on one of these things
as it is on one of these things.

00:23:40.868 --> 00:23:41.901
And I'm not trying to say that

00:23:41.901 --> 00:23:43.567
to dissuade you
or anything like that.

00:23:43.567 --> 00:23:45.000
All I'm doing is just trying
to make sure

00:23:45.000 --> 00:23:47.100
that everybody understands
that, you know,

00:23:47.100 --> 00:23:49.734
these are much, you know,
more limited hardware

00:23:49.734 --> 00:23:51.234
than a desktop

00:23:51.234 --> 00:23:53.234
and not to fall
into the trap of thinking

00:23:53.234 --> 00:23:55.234
that, you know,
one size fits all.

00:23:55.234 --> 00:23:56.901
You've got to understand
your application.

00:23:56.901 --> 00:23:58.634
If speed is important
to your app,

00:23:58.634 --> 00:24:01.968
this is something that you
should maybe think about.

00:24:01.968 --> 00:24:03.734
Um, at any rate,
what I want to do now

00:24:03.734 --> 00:24:06.367
is show you the source code
for this thing.

00:24:06.367 --> 00:24:08.567
Um, so this
is the actual HTML page.

00:24:08.567 --> 00:24:11.400
As you can see,
it's super, super simple.

00:24:11.400 --> 00:24:14.467
Um, I have a canvas element
with an ID of "kmeans."

00:24:14.467 --> 00:24:16.234
I have a div, which is
this thing at the bottom

00:24:16.234 --> 00:24:17.734
where I draw--

00:24:17.734 --> 00:24:20.801
or where I display
the execution times.

00:24:20.801 --> 00:24:23.133
And then here I just call
the single JavaScript function

00:24:23.133 --> 00:24:24.501
called Draw.

00:24:24.501 --> 00:24:27.234
And it's defined in this
external file that I include

00:24:27.234 --> 00:24:30.300
called "kmeans.js."

00:24:30.300 --> 00:24:33.934
So this is just
a straight-up JavaScript code.

00:24:33.934 --> 00:24:36.734
You can see that I, you know,
allocate some variables

00:24:36.734 --> 00:24:38.167
and constants up here.

00:24:38.167 --> 00:24:39.767
I have, again,
an implementation

00:24:39.767 --> 00:24:44.200
as a separate function of that
cartesian distance function.

00:24:44.200 --> 00:24:47.267
And here's, again, the--
you know, the cluster algorithm

00:24:47.267 --> 00:24:50.901
where the heart
of the code goes on.

00:24:50.901 --> 00:24:53.701
Again, a block up front
of just initializing variables.

00:24:53.701 --> 00:24:55.400
And here again
is that main loop.

00:24:55.400 --> 00:24:57.133
This should look
a little familiar.

00:24:57.133 --> 00:25:00.234
This is literally a direct
transcription of the same code

00:25:00.234 --> 00:25:02.267
from Java into JavaScript.

00:25:02.267 --> 00:25:04.767
And you can see here,
you know, for every point,

00:25:04.767 --> 00:25:07.100
for every group,
compute the distance

00:25:07.100 --> 00:25:08.968
between the current point
and the current group,

00:25:08.968 --> 00:25:11.534
and if that distance
is less than the distance

00:25:11.534 --> 00:25:13.667
to the, you know,
point's current group,

00:25:13.667 --> 00:25:16.200
update the information and say
you now belong to the new group.

00:25:16.200 --> 00:25:19.100
I have the same early,
you know, loop break.

00:25:19.100 --> 00:25:22.067
I have the same centroid
calculation, you know,

00:25:22.067 --> 00:25:23.834
as the last step
in the iteration.

00:25:23.834 --> 00:25:29.634
And again, I have the same early
break-out after 15 iterations.

00:25:29.634 --> 00:25:32.934
Um, this reset function--
one thing I didn't mention

00:25:32.934 --> 00:25:34.601
about the Dalvik version
is that, when you run this,

00:25:34.601 --> 00:25:38.067
it's actually starting
by eliminating

00:25:38.067 --> 00:25:40.734
or basically regenerating
all of the input points

00:25:40.734 --> 00:25:44.434
to be a completely random set
of input.

00:25:44.434 --> 00:25:46.400
And so that's what
this reset function does.

00:25:46.400 --> 00:25:48.367
There's an equivalent method
in the Dalvik version

00:25:48.367 --> 00:25:50.534
you saw earlier
called Prepare.

00:25:50.534 --> 00:25:52.601
And then the final thing
is this Draw algorithm.

00:25:52.601 --> 00:25:54.234
Now, what I want to do
is actually--

00:25:54.234 --> 00:25:55.734
if I can do this--

00:25:55.734 --> 00:25:58.567
show these side by side,

00:25:58.567 --> 00:26:01.634
because I think this
is really cool.

00:26:01.634 --> 00:26:05.534
Where's the thread?

00:26:05.534 --> 00:26:07.801
You don't have the thread open.

00:26:10.400 --> 00:26:13.234
So the...

00:26:13.234 --> 00:26:16.534
Okay, here's the Draw method
in the Dalvik version.

00:26:29.334 --> 00:26:32.000
Okay, so, you know, again,
we do some initialization.

00:26:32.000 --> 00:26:33.267
We call the cluster algorithm.

00:26:33.267 --> 00:26:35.267
But this is really,
down here, the loop

00:26:35.267 --> 00:26:38.567
where the actual work gets done
in terms of drawing.

00:26:38.567 --> 00:26:40.868
And you can see here
that in the JavaScript version,

00:26:40.868 --> 00:26:43.767
using Canvas,
we get a handle to a context

00:26:43.767 --> 00:26:45.400
that we can actually draw on.

00:26:45.400 --> 00:26:47.667
Um, and then we come down
to the loop,

00:26:47.667 --> 00:26:50.634
and we just say, okay, well,
your current fill style,

00:26:50.634 --> 00:26:52.200
which is really
the drawing properties,

00:26:52.200 --> 00:26:55.901
is a black--pure black color.

00:26:55.901 --> 00:26:57.567
And all I do
is I just draw a rectangle

00:26:57.567 --> 00:26:59.434
encompassing the entire canvas,

00:26:59.434 --> 00:27:02.400
and that creates
the black background.

00:27:02.400 --> 00:27:07.100
And then on top of that,
I draw each point in turn,

00:27:07.100 --> 00:27:11.767
color-coded via the cluster
that it currently belongs in.

00:27:11.767 --> 00:27:14.367
And that is, astonishingly,
at least to me,

00:27:14.367 --> 00:27:18.901
similar to the Dalvik version,
where instead of--

00:27:18.901 --> 00:27:20.834
where the JavaScript version
actually has you set

00:27:20.834 --> 00:27:23.868
those drawing properties
on the canvas object itself,

00:27:23.868 --> 00:27:26.300
in Dalvik there's actually just
a separate container class

00:27:26.300 --> 00:27:29.400
for that that encapsulates
all the drawing properties

00:27:29.400 --> 00:27:30.734
called Paint.

00:27:30.734 --> 00:27:33.067
But other than that,
it's strikingly similar.

00:27:33.067 --> 00:27:37.300
I do a Draw ARGB, which
basically blanks the screen,

00:27:37.300 --> 00:27:41.868
and then I draw a point
in this case--

00:27:41.868 --> 00:27:44.367
in JavaScript Canvas all you can
draw is a rectangle with,

00:27:44.367 --> 00:27:46.734
you know, dimensions of 1x1.

00:27:46.734 --> 00:27:49.567
Um, but in Dalvik, you can
actually just draw a point.

00:27:49.567 --> 00:27:51.133
But, you know, again,
it's the same thing.

00:27:51.133 --> 00:27:52.934
I just pick each point
by the color

00:27:52.934 --> 00:27:54.167
of the cluster it's in.

00:27:54.167 --> 00:27:58.734
So these are very,
very similar drawing schemes

00:27:58.734 --> 00:28:00.667
or paradigms.

00:28:00.667 --> 00:28:04.868
So what I want to do now, then,
is switch back to the device

00:28:04.868 --> 00:28:08.400
and run this.

00:28:08.400 --> 00:28:11.133
So I'm launching the browser.

00:28:23.067 --> 00:28:24.234
And hopefully it picked it up

00:28:24.234 --> 00:28:27.234
from my browser history
correctly.

00:28:27.234 --> 00:28:29.501
Oh, I'm on edge.

00:28:31.767 --> 00:28:33.033
Okay, so there it was.

00:28:33.033 --> 00:28:34.467
I just loaded
the pure JavaScript version.

00:28:34.467 --> 00:28:36.367
And there again, you know,
it's very similar

00:28:36.367 --> 00:28:38.634
to the display that you just saw
on the desktop.

00:28:38.634 --> 00:28:40.067
But what I want to call
your attention to down here

00:28:40.067 --> 00:28:41.434
is these rendering times.

00:28:41.434 --> 00:28:44.234
334 milliseconds for drawing

00:28:44.234 --> 00:28:48.868
and 698 milliseconds
for the clustering computation.

00:28:48.868 --> 00:28:51.100
So, you know, on the whole,
it's a little bit--

00:28:51.100 --> 00:28:53.400
it's pretty comparable
in performance to Dalvik,

00:28:53.400 --> 00:28:55.067
although perhaps
a little bit slower.

00:28:55.067 --> 00:28:57.234
But that rendering time is--

00:28:57.234 --> 00:28:58.901
or at least it can be
for many applications--

00:28:58.901 --> 00:29:02.667
that rendering time
can be quite problematic.

00:29:02.667 --> 00:29:04.968
Um, and again, just compare that
to the desktop.

00:29:04.968 --> 00:29:07.534
You know, it's the exact same
JavaScript code,

00:29:07.534 --> 00:29:08.734
but it's running something
on the order

00:29:08.734 --> 00:29:11.400
of 10 or 20 times faster
on the desktop

00:29:11.400 --> 00:29:12.801
than it is
on one of these things.

00:29:12.801 --> 00:29:14.100
Again, I'm not trying
to dissuade you.

00:29:14.100 --> 00:29:17.501
Just be aware of that
as you design your applications.

00:29:22.067 --> 00:29:24.033
Okay, so that was an Ajax demo.

00:29:24.033 --> 00:29:25.334
What are some examples
of this?

00:29:25.334 --> 00:29:26.934
Well, you know, you saw some
earlier today.

00:29:26.934 --> 00:29:30.567
The Google Reader, which is one
of my favorite Web applications,

00:29:30.567 --> 00:29:32.901
you know, the Google Mail Client
that you guys have seen.

00:29:32.901 --> 00:29:36.434
There's obviously a number
of different Web applications

00:29:36.434 --> 00:29:39.067
that have been developed for
a certain fruit-flavored phone

00:29:39.067 --> 00:29:42.067
out there.

00:29:42.067 --> 00:29:43.801
So what's gonna come
in the future?

00:29:43.801 --> 00:29:46.167
Well, HTML5 is not
gonna sit still.

00:29:46.167 --> 00:29:48.901
You guys saw the future
of Web technologies in general,

00:29:48.901 --> 00:29:50.567
and hopefully many
of these things

00:29:50.567 --> 00:29:52.067
will start to become
standardized

00:29:52.067 --> 00:29:53.734
and get rolled into HTML5.

00:29:53.734 --> 00:29:57.133
Specifically for Android,
Gears today, HTML5 tomorrow.

00:29:57.133 --> 00:30:00.367
The team is already working--
the browser team's working

00:30:00.367 --> 00:30:03.000
on upgrading to a faster
JavaScript virtual machine.

00:30:03.000 --> 00:30:04.634
You guys may be aware
there's kind of three out there.

00:30:04.634 --> 00:30:06.567
There's TraceMonkey by Firefox,

00:30:06.567 --> 00:30:09.901
SquirrelFish Extreme
that Safari's using in V8,

00:30:09.901 --> 00:30:11.734
which is what Google's using
in Chrome,

00:30:11.734 --> 00:30:14.400
you know, and they're looking
at whether we can pull

00:30:14.400 --> 00:30:15.834
any of these three
into the browser

00:30:15.834 --> 00:30:17.968
and increase JavaScript
performance even more.

00:30:17.968 --> 00:30:20.167
You know, and then,
as for the other things you saw,

00:30:20.167 --> 00:30:23.734
like O3D, the 3D technology
that currently operates

00:30:23.734 --> 00:30:25.100
as a browser plug-in,

00:30:25.100 --> 00:30:26.501
things like that, you know,
who knows?

00:30:26.501 --> 00:30:29.234
It's likely that they'll
probably, you know, trail

00:30:29.234 --> 00:30:31.167
the mobile space, 'cause first
they need to get standardized

00:30:31.167 --> 00:30:33.634
and then mobile platforms
need to implement them.

00:30:33.634 --> 00:30:35.701
But, you know, the future
is bright.

00:30:35.701 --> 00:30:38.667
And it's pretty exciting,
at least to me.

00:30:38.667 --> 00:30:40.567
Now, I want to take
one last one.

00:30:40.567 --> 00:30:42.567
I asked you earlier
to hold a thought,

00:30:42.567 --> 00:30:44.234
and that thought was,

00:30:44.234 --> 00:30:45.868
you know, if you've got
an Ajax application,

00:30:45.868 --> 00:30:47.367
you can't necessarily
get access

00:30:47.367 --> 00:30:49.667
to a lot
of the core framework APIs.

00:30:49.667 --> 00:30:51.968
Well, there's--
one thing that you can do--

00:30:51.968 --> 00:30:54.200
here I'm showing
a Dalvik virtual machine.

00:30:54.200 --> 00:30:56.634
This would be a standard,
you know, Android application.

00:30:56.634 --> 00:30:58.200
Contained in that are a bunch
of Java objects

00:30:58.200 --> 00:31:01.467
that are communicating
with each other and so on.

00:31:01.467 --> 00:31:06.767
Also in this virtual machine,
as part of the view tree,

00:31:06.767 --> 00:31:09.734
is this notion that we have
of a WebView.

00:31:09.734 --> 00:31:12.601
Now, a WebView is literally just
a WebKit component

00:31:12.601 --> 00:31:14.601
wrapped up in the semantics
of an Android view,

00:31:14.601 --> 00:31:17.367
and it allows you
to pull HTML rendering

00:31:17.367 --> 00:31:20.701
embedded into your application
UI along with other widgets.

00:31:20.701 --> 00:31:23.033
But we also have this other
interesting little method

00:31:23.033 --> 00:31:25.534
that we've added called
addJavaScriptInterface.

00:31:25.534 --> 00:31:27.167
I'm gonna talk
about this a bit more later,

00:31:27.167 --> 00:31:29.234
but really what this does
is it lets you turn

00:31:29.234 --> 00:31:30.968
a standard Ajax application

00:31:30.968 --> 00:31:32.834
into, like,
a super Ajax application,

00:31:32.834 --> 00:31:34.701
or what I like
to call augmented Ajax.

00:31:34.701 --> 00:31:38.434
And what it really does is
it lets you inject functionality

00:31:38.434 --> 00:31:40.534
into your JavaScript code.

00:31:40.534 --> 00:31:41.734
I'm gonna demo this,

00:31:41.734 --> 00:31:43.701
but I'm gonna demo this
a little bit later.

00:31:43.701 --> 00:31:45.300
So I'm gonna ask you again

00:31:45.300 --> 00:31:47.601
to hold that thought
and come back to it.

00:31:47.601 --> 00:31:50.701
Um, so the third kind of key way
of developing applications

00:31:50.701 --> 00:31:52.501
for Android is this notion
of native code.

00:31:52.501 --> 00:31:54.734
What is this for?

00:31:54.734 --> 00:31:56.067
Well, it generally--

00:31:56.067 --> 00:31:58.501
you know, native code
is for doing heavy lifting.

00:32:00.167 --> 00:32:03.434
Um, this is a component
that you can kind of pull

00:32:03.434 --> 00:32:06.567
into an existing--or pull
into a Dalvik application,

00:32:06.567 --> 00:32:08.934
but really,
the Dalvik virtual machine

00:32:08.934 --> 00:32:09.934
is the one running the show.

00:32:09.934 --> 00:32:11.567
It's the app--it's the code

00:32:11.567 --> 00:32:13.667
that gets started
and starts running,

00:32:13.667 --> 00:32:16.167
loads up, you know,
the appropriate chunk

00:32:16.167 --> 00:32:18.067
of native code, and then starts
making calls into it

00:32:18.067 --> 00:32:20.767
via the Java Native Interface.

00:32:20.767 --> 00:32:25.901
To do this you need
a Native toolchain, including...

00:32:25.901 --> 00:32:28.334
you know, like
a GCC Cross-Compiler and so on

00:32:28.334 --> 00:32:30.567
so that you can actually compile
C or C++ code

00:32:30.567 --> 00:32:34.000
into a, you know,
an ARM ELF shared library

00:32:34.000 --> 00:32:35.400
that you can run on the device.

00:32:35.400 --> 00:32:38.601
So a work-in-progress, what
we call Native Development Kit,

00:32:38.601 --> 00:32:41.601
or NDK, which is a companion
and/or complement

00:32:41.601 --> 00:32:43.667
to the standard STK that you
guys are already familiar with.

00:32:43.667 --> 00:32:48.334
We recently added one
to the donut branch

00:32:48.334 --> 00:32:50.834
in the public Git repository.

00:32:50.834 --> 00:32:53.334
Um, so what I'm gonna do
a little later

00:32:53.334 --> 00:32:56.267
is gonna demo an early kind of
interim build for that thing,

00:32:56.267 --> 00:32:58.400
and I'll talk more
about that later.

00:32:58.400 --> 00:33:00.133
So what is this thing for?

00:33:00.133 --> 00:33:02.801
Well, it's really for physics
and mathematical simulations.

00:33:02.801 --> 00:33:05.133
Um, this K-Means clustering
algorithm

00:33:05.133 --> 00:33:06.901
that I'm showing you guys
is a great example.

00:33:06.901 --> 00:33:11.033
It's also for, you know, fast
loading of large-ish data files.

00:33:11.033 --> 00:33:14.200
So, you know, if you've got,
like, a really massive, say,

00:33:14.200 --> 00:33:17.434
XML document or some binary file
or something like that,

00:33:17.434 --> 00:33:20.267
and, you know, parsing it
in Java is too memory-intensive

00:33:20.267 --> 00:33:24.167
or too slow, you can write
C code instead

00:33:24.167 --> 00:33:27.100
and do the heavy lifting
that way.

00:33:27.100 --> 00:33:30.868
Another common use of this
is for input-management engines,

00:33:30.868 --> 00:33:34.133
i.e., onscreen keyboards,
and, you know,

00:33:34.133 --> 00:33:35.934
these are for things
like text prediction and so on.

00:33:35.934 --> 00:33:37.300
You know, user's sitting there,

00:33:37.300 --> 00:33:38.934
typing away furiously
on this thing.

00:33:38.934 --> 00:33:41.567
If you really, really, really
need a fast look-up,

00:33:41.567 --> 00:33:43.734
you know, this is a case
where you might use that.

00:33:43.734 --> 00:33:45.400
Other things
are custom virtual machines,

00:33:45.400 --> 00:33:47.767
you know, for things
like obsolete games and so on.

00:33:47.767 --> 00:33:50.334
Um, there's also, of course,
other things you can do there.

00:33:50.334 --> 00:33:52.767
You know, you can run--it's
just native code it's running.

00:33:52.767 --> 00:33:55.868
It can see in the process,
you know, address space

00:33:55.868 --> 00:33:57.868
all kinds of other libraries.

00:33:57.868 --> 00:34:00.901
The issue with using them isn't
so much whether you can use them

00:34:00.901 --> 00:34:02.701
but whether you should use them.

00:34:02.701 --> 00:34:04.234
And this is the same story
that we tell

00:34:04.234 --> 00:34:05.734
even when you're writing
Dalvik code.

00:34:05.734 --> 00:34:08.834
We have public APIs,
or supported APIs,

00:34:08.834 --> 00:34:10.534
and then unsupported APIs.

00:34:10.534 --> 00:34:12.734
And these are the ones that are
internal to the framework

00:34:12.734 --> 00:34:14.400
that we don't guarantee
consistency on,

00:34:14.400 --> 00:34:15.834
that can change over time.

00:34:15.834 --> 00:34:18.734
And that problem is obviously
a difficulty for developers.

00:34:18.734 --> 00:34:20.400
If you use one
of these, you know, frameworks

00:34:20.400 --> 00:34:24.000
in your Dalvik code
and we change that API,

00:34:24.000 --> 00:34:26.567
someday a user's gonna get,
you know, an over-the-air update

00:34:26.567 --> 00:34:29.400
to their device, and, you know,
their favorite application--

00:34:29.400 --> 00:34:31.033
your application's just gonna
stop working,

00:34:31.033 --> 00:34:32.501
because you're using
an unsupported API.

00:34:32.501 --> 00:34:34.434
That's a big problem
for you guys.

00:34:34.434 --> 00:34:35.834
It's a big problem for us.

00:34:35.834 --> 00:34:38.567
And the problem actually gets to
be quite a bit worse,

00:34:38.567 --> 00:34:39.767
you know,
if you use the native code,

00:34:39.767 --> 00:34:42.901
because not only
can we change the API

00:34:42.901 --> 00:34:45.400
for some of these libraries
that aren't public,

00:34:45.400 --> 00:34:47.501
we can actually change
the binary structure

00:34:47.501 --> 00:34:49.000
of them as well,
which can also break it,

00:34:49.000 --> 00:34:50.734
even if the API is the same.

00:34:50.734 --> 00:34:53.300
So in other words, don't use--
you know, don't fall

00:34:53.300 --> 00:34:55.801
to the temptation of using
other Native APIs in there,

00:34:55.801 --> 00:34:58.467
unless you're willing to accept
the extremely huge risks

00:34:58.467 --> 00:35:00.501
that go along with that
of having your app break

00:35:00.501 --> 00:35:02.667
on a future version.

00:35:02.667 --> 00:35:05.000
Um, so what can't you do?
I just mentioned this earlier.

00:35:05.000 --> 00:35:07.234
Currently, the only APIs
that we're guaranteeing,

00:35:07.234 --> 00:35:09.701
or that we plan
to guarantee stability for,

00:35:09.701 --> 00:35:12.133
are libm,
which is the math library,

00:35:12.133 --> 00:35:14.667
and libc,
which is the standard C library.

00:35:14.667 --> 00:35:16.634
We do have plans
to add more over time,

00:35:16.634 --> 00:35:19.534
but right now the focus
is on getting that early NDK

00:35:19.534 --> 00:35:20.734
that I just mentioned.

00:35:20.734 --> 00:35:22.067
We're trying to get that
polished up for release

00:35:22.067 --> 00:35:24.067
hopefully in the next few weeks.

00:35:24.067 --> 00:35:26.901
And so we'll add more over time,
but for the first version,

00:35:26.901 --> 00:35:29.100
those are the only ones
we're planning to support.

00:35:29.100 --> 00:35:31.734
The other thing you can't do
is hack the system.

00:35:31.734 --> 00:35:34.400
This native code thing
that I'm gonna show you

00:35:34.400 --> 00:35:37.234
does not represent, you know,
necessarily anything new.

00:35:37.234 --> 00:35:39.501
There's no special privileges
to native code.

00:35:39.501 --> 00:35:42.033
It's still subject to
the same sandboxing limitations

00:35:42.033 --> 00:35:45.634
as, you know, all the other code
that runs on an Android device.

00:35:45.634 --> 00:35:47.634
Um, so there's
no additional security risk,

00:35:47.634 --> 00:35:50.067
or security burden,
imposed by using native code

00:35:50.067 --> 00:35:52.667
in an application.

00:35:52.667 --> 00:35:55.400
So now what I want to do
is show you guys a quick demo.

00:35:57.367 --> 00:36:03.234
So I'm gonna come over here
and show you this directory.

00:36:03.234 --> 00:36:05.067
So this is--
as I mentioned earlier,

00:36:05.067 --> 00:36:08.300
this is an early build
of the Native Development Kit.

00:36:08.300 --> 00:36:10.434
You can actually do this
yourself if you go to the--

00:36:10.434 --> 00:36:12.767
check out the donut branch
from the public Git repository

00:36:12.767 --> 00:36:16.901
and go through the work of
building your own cross-compiler

00:36:16.901 --> 00:36:19.634
for whatever
your host platform is to ARM--

00:36:19.634 --> 00:36:21.667
the appropriate ARM family
and so on.

00:36:21.667 --> 00:36:22.934
So you can actually get this,

00:36:22.934 --> 00:36:26.100
but I have kind of
a preliminary build here.

00:36:26.100 --> 00:36:27.601
And the way
that this currently works

00:36:27.601 --> 00:36:29.067
is there's two directories.

00:36:29.067 --> 00:36:32.634
There's this apps directory
and this sources directory.

00:36:32.634 --> 00:36:36.367
Under the apps directory,
HDICT's How Do I Code Thee,

00:36:36.367 --> 00:36:39.567
is this one file
called application.mk...

00:36:42.734 --> 00:36:46.400
which really just defines
an entry for my code

00:36:46.400 --> 00:36:48.734
to be compiled and run.

00:36:48.734 --> 00:36:51.400
And you can see here that I set
the destination directory

00:36:51.400 --> 00:36:56.067
to be the directory where my
current Eclipse project lives.

00:36:56.067 --> 00:36:58.567
And then this is the name
of the specific library

00:36:58.567 --> 00:37:01.868
that I compile and then
some CFLAGS that I can set.

00:37:01.868 --> 00:37:04.901
The other directory
is the sources directory.

00:37:04.901 --> 00:37:08.567
And this is where
the actual C code lives.

00:37:08.567 --> 00:37:12.033
And so here I have
this nativecluster.c file

00:37:12.033 --> 00:37:14.267
and this android.mk file,

00:37:14.267 --> 00:37:16.501
which really just tell it
how to build.

00:37:16.501 --> 00:37:19.167
This has documentation, so I'm
not gonna go into the innards

00:37:19.167 --> 00:37:20.267
of how this works.

00:37:20.267 --> 00:37:23.000
But basically you just run
".mk APP="

00:37:23.000 --> 00:37:25.634
and then the name of the app.

00:37:25.634 --> 00:37:27.934
Um, actually,
I already built it recently,

00:37:27.934 --> 00:37:30.501
so I have to...

00:37:35.234 --> 00:37:36.667
And so then it runs a compile

00:37:36.667 --> 00:37:38.467
and then drops
the resulting .so file

00:37:38.467 --> 00:37:40.033
into my directory here.

00:37:40.033 --> 00:37:42.734
So...

00:37:42.734 --> 00:37:46.400
if I come back here and then
check out this libs directory,

00:37:46.400 --> 00:37:49.834
you'll see that I now have
a directory with--

00:37:49.834 --> 00:37:52.734
with the dynamically loadable
shared library

00:37:52.734 --> 00:37:53.901
in this new directory

00:37:53.901 --> 00:37:57.567
corresponding
to the current processor family.

00:37:57.567 --> 00:37:59.334
So that's how I get
the actual native code.

00:37:59.334 --> 00:38:02.033
Now, how do I actually use it?

00:38:02.033 --> 00:38:06.100
And so for that,
I actually have...

00:38:06.100 --> 00:38:08.767
another file in that directory,

00:38:08.767 --> 00:38:13.100
which is this file here,
NativeClusterer.java.

00:38:13.100 --> 00:38:15.033
And so if I--oops.

00:38:18.400 --> 00:38:23.133
So if I drag this
and include this in my project,

00:38:23.133 --> 00:38:26.501
now you see why I created
this Clusterer interface.

00:38:26.501 --> 00:38:29.234
Over here in the K-Means view,

00:38:29.234 --> 00:38:31.734
I'm basically just doing
a dependency injection here.

00:38:31.734 --> 00:38:34.067
I have an interface clusterer
that knows how to implement

00:38:34.067 --> 00:38:37.667
a clustering algorithm
in some way, shape, or form.

00:38:37.667 --> 00:38:41.734
And at first, I just use
the Dalvik version of it.

00:38:41.734 --> 00:38:44.133
But now that I have
this new Native implementation,

00:38:44.133 --> 00:38:46.701
I can change that over
to a Native Clusterer.

00:38:46.701 --> 00:38:48.367
And if I look
at this actual file,

00:38:48.367 --> 00:38:51.400
you'll see that, um--
incredibly simple.

00:38:51.400 --> 00:38:53.501
All I do
is a Static Initializer,

00:38:53.501 --> 00:38:56.801
load the specific library
that I want to load,

00:38:56.801 --> 00:39:00.167
and then, you know,
have a method cluster

00:39:00.167 --> 00:39:02.000
that in this case
is declared Native,

00:39:02.000 --> 00:39:04.133
and that's handled
by the C code.

00:39:04.133 --> 00:39:07.067
So let's check out that C code.

00:39:13.434 --> 00:39:17.133
So here again, you can see
that I have, again,

00:39:17.133 --> 00:39:19.100
that same cartesian distance
calculator.

00:39:19.100 --> 00:39:21.100
I have a struct
instead of a class

00:39:21.100 --> 00:39:23.300
for holding
the point XY coordinates

00:39:23.300 --> 00:39:25.667
in the current
cluster assignment.

00:39:25.667 --> 00:39:28.033
And then here, really,
it's just the same function

00:39:28.033 --> 00:39:29.467
that you've seen before.

00:39:29.467 --> 00:39:32.868
I have a block here,
which is the, you know,

00:39:32.868 --> 00:39:35.167
variable initialization.

00:39:35.167 --> 00:39:36.434
Then again the main loop.

00:39:36.434 --> 00:39:37.834
And once again, this should look
pretty familiar.

00:39:37.834 --> 00:39:41.267
You know, until I converge
for every point,

00:39:41.267 --> 00:39:45.534
um, for every cluster,
compute the distance.

00:39:45.534 --> 00:39:48.767
You know, if the current point
now belongs to a new group,

00:39:48.767 --> 00:39:50.367
you know,
update the assignments.

00:39:50.367 --> 00:39:55.200
The only thing that's new here
are really a few things

00:39:55.200 --> 00:39:59.901
such as here where I cache
some JNI objects,

00:39:59.901 --> 00:40:01.868
and this is just
for performance

00:40:01.868 --> 00:40:03.901
so I'm not constantly doing
a look-up

00:40:03.901 --> 00:40:05.467
in the middle of a tight loop.

00:40:05.467 --> 00:40:06.901
And then in here, I basically--

00:40:06.901 --> 00:40:08.667
this is like a Field(env)
reference

00:40:08.667 --> 00:40:11.000
in, you know, JNI parlance.

00:40:11.000 --> 00:40:13.033
And then, of course, I just have
to do this additional step

00:40:13.033 --> 00:40:14.234
of making sure that I keep track

00:40:14.234 --> 00:40:16.067
of, you know,
garbage collector references,

00:40:16.067 --> 00:40:18.968
so I don't overload
the virtual machine.

00:40:18.968 --> 00:40:22.234
Um, and then--
so down here I have, again,

00:40:22.234 --> 00:40:26.267
the same centroid
recalculation block.

00:40:26.267 --> 00:40:29.000
Now, there's one thing I want
to point out about this.

00:40:29.000 --> 00:40:31.400
You guys are probably familiar
with the fact that,

00:40:31.400 --> 00:40:33.467
in C, you typically don't have
the same kind

00:40:33.467 --> 00:40:37.334
of rich class libraries
as you have in, say,

00:40:37.334 --> 00:40:38.801
Java or JavaScript.

00:40:38.801 --> 00:40:41.701
So in the original version of
the Dalvik and Ajax versions,

00:40:41.701 --> 00:40:43.334
I actually had a bunch of,
you know, like, HashMaps

00:40:43.334 --> 00:40:45.167
and object-associative arrays
that I was using.

00:40:45.167 --> 00:40:47.367
And, you know, well,
these things are fast, right?

00:40:47.367 --> 00:40:48.801
They've been out
for a long time,

00:40:48.801 --> 00:40:50.167
and they're well optimized.

00:40:50.167 --> 00:40:52.601
In fact, they are, but in C,
I didn't have access

00:40:52.601 --> 00:40:53.767
to anything like that,
so what I did was

00:40:53.767 --> 00:40:55.267
I just kind of refactored
the algorithm

00:40:55.267 --> 00:41:00.834
to, um, basically be
a flat array-based structure,

00:41:00.834 --> 00:41:03.300
instead of having
to use HashMaps.

00:41:03.300 --> 00:41:05.067
I also flattened an inner loop.

00:41:05.067 --> 00:41:06.901
When I did that,

00:41:06.901 --> 00:41:08.501
you know, I said,
"Okay, I got it working in C."

00:41:08.501 --> 00:41:10.667
I'm like, "Well, it's not gonna
make any difference really,

00:41:10.667 --> 00:41:13.400
"but I'm gonna go back
and refactor JavaScript

00:41:13.400 --> 00:41:15.234
"and Java to use the same model

00:41:15.234 --> 00:41:17.200
so they had
an apples-to-apples comparison."

00:41:17.200 --> 00:41:20.734
Five times faster in both
JavaSource running in Dalvik

00:41:20.734 --> 00:41:22.234
and JavaScript.

00:41:22.234 --> 00:41:24.901
So I was kind of surprised
by that,

00:41:24.901 --> 00:41:26.934
but really, what it means,
again, is just another example.

00:41:26.934 --> 00:41:29.067
You know, these things--I'm not
gonna belabor this point,

00:41:29.067 --> 00:41:31.367
'cause you can go
to Jeff Sharkey's talk,

00:41:31.367 --> 00:41:32.567
I think, later today

00:41:32.567 --> 00:41:34.901
on, you know, battery life
and performance,

00:41:34.901 --> 00:41:37.033
but these things
are just not fast,

00:41:37.033 --> 00:41:38.901
and, you know,
a little change like that

00:41:38.901 --> 00:41:40.601
probably wouldn't matter much
on a desktop,

00:41:40.601 --> 00:41:42.868
but it matters a huge amount
on a mobile.

00:41:42.868 --> 00:41:45.234
So, um, when I did that,

00:41:45.234 --> 00:41:46.734
you know, the C version
that you see here

00:41:46.734 --> 00:41:50.701
kind of became the canonical
version of my algorithm.

00:41:50.701 --> 00:41:53.767
Aside from that, it uses
the exact same rendering--

00:41:53.767 --> 00:41:55.467
kind of pipeline
and rendering structure

00:41:55.467 --> 00:41:59.367
as the pure Dalvik version.

00:41:59.367 --> 00:42:01.501
So let me run this again.

00:42:08.734 --> 00:42:11.334
So it's installing it
in the background.

00:42:13.567 --> 00:42:15.701
Fires it up.

00:42:20.400 --> 00:42:23.400
And you can see there
that it's running a lot faster.

00:42:23.400 --> 00:42:26.400
Um, in fact, you can see
that, you know, the rendering

00:42:26.400 --> 00:42:27.901
is taking
about the same amount of time,

00:42:27.901 --> 00:42:29.968
but now I'm down to, like,
200 milliseconds.

00:42:29.968 --> 00:42:31.868
I think I've actually got
something else going on

00:42:31.868 --> 00:42:33.300
on my device at the moment,

00:42:33.300 --> 00:42:36.734
'cause it usually runs
at about 150 milliseconds for--

00:42:36.734 --> 00:42:40.334
you know, for the actual
calculation cycle.

00:42:40.334 --> 00:42:44.567
So obviously,
quite a bit faster, as expected.

00:42:44.567 --> 00:42:46.200
Okay, so...

00:42:46.200 --> 00:42:49.133
switching back
to the slides again.

00:42:49.133 --> 00:42:50.901
So, you know,
what are some examples

00:42:50.901 --> 00:42:51.901
of what you can do with this?

00:42:51.901 --> 00:42:53.400
Well, one
of my personal favorites

00:42:53.400 --> 00:42:55.400
is this thing called SCUMMVM,

00:42:55.400 --> 00:42:57.400
which is using--
which is an implementation

00:42:57.400 --> 00:43:01.000
of a LucasArts game engine so
that you can play classic games,

00:43:01.000 --> 00:43:02.901
and before you ask, yes,
I actually do have a license

00:43:02.901 --> 00:43:06.267
to Zak McKracken.

00:43:06.267 --> 00:43:10.200
One of my most cherished
software licenses, in fact.

00:43:10.200 --> 00:43:13.767
Some of our partners, Spotify,
are also using this technique

00:43:13.767 --> 00:43:18.067
to do some of their, um, uh...

00:43:18.067 --> 00:43:21.734
low-level music-related
encryption calculations.

00:43:21.734 --> 00:43:24.234
Unfortunately, I forgot to get
a screen shot of them.

00:43:24.234 --> 00:43:26.400
So sorry about that.

00:43:26.400 --> 00:43:28.634
So what's up for the future
of this technique?

00:43:28.634 --> 00:43:30.234
Well, as I mentioned earlier,

00:43:30.234 --> 00:43:32.567
you know, we're interested
in adding additional libraries,

00:43:32.567 --> 00:43:34.400
but, you know,
right now we're focused

00:43:34.400 --> 00:43:36.234
on, you know, polishing this
thing up

00:43:36.234 --> 00:43:37.901
and then trying to get this
out there for you guys

00:43:37.901 --> 00:43:39.567
as a, you know, standard tool

00:43:39.567 --> 00:43:41.567
that you can use
as a complement to the STK.

00:43:41.567 --> 00:43:43.234
So we haven't really,
you know, established

00:43:43.234 --> 00:43:44.501
what's gonna come
in the future,

00:43:44.501 --> 00:43:45.734
but one thing
I do want to stress

00:43:45.734 --> 00:43:47.234
is we have no plans
to make this

00:43:47.234 --> 00:43:49.501
sort of a separate
application stack.

00:43:49.501 --> 00:43:52.000
The model that you just saw,
where Dalvik starts

00:43:52.000 --> 00:43:53.868
and handles most
of the event logic and so on

00:43:53.868 --> 00:43:56.667
and calls out to C code,
that's the model

00:43:56.667 --> 00:43:58.901
that we're gonna be
focusing on.

00:43:58.901 --> 00:44:01.534
And what I mean by a separate
event stack is things like,

00:44:01.534 --> 00:44:03.801
you know, are you gonna be able
to write an application

00:44:03.801 --> 00:44:05.634
that's entirely in C
and never starts

00:44:05.634 --> 00:44:06.734
a Dalvik virtual machine?

00:44:06.734 --> 00:44:07.801
The answer to that is no.

00:44:07.801 --> 00:44:09.400
We think that, over time,
you know,

00:44:09.400 --> 00:44:10.734
the optimizations
that we're making

00:44:10.734 --> 00:44:11.901
to the core Dalvik libraries

00:44:11.901 --> 00:44:13.100
will make it
even more compelling

00:44:13.100 --> 00:44:15.300
than it is today
and that this will make

00:44:15.300 --> 00:44:19.934
for a nice balance between
those two programming models.

00:44:19.934 --> 00:44:21.868
Um, so now I want to do
a bonus demo.

00:44:21.868 --> 00:44:24.834
I promised you a demo
of something earlier.

00:44:24.834 --> 00:44:27.601
So let me come back here
to Eclipse.

00:44:27.601 --> 00:44:30.868
In fact, to Finder as well.

00:44:33.767 --> 00:44:36.734
So I have this site
that I showed you earlier,

00:44:36.734 --> 00:44:41.968
and I have another file here
called index2.html.

00:44:41.968 --> 00:44:44.434
So if I load this it does--
wait, this did nothing.

00:44:44.434 --> 00:44:45.801
Why did this do nothing?

00:44:45.801 --> 00:44:48.067
Um, well, it did nothing

00:44:48.067 --> 00:44:51.234
because this is the source
for the page.

00:44:51.234 --> 00:44:55.567
You get down to this point,
this line here,

00:44:55.567 --> 00:44:56.868
and it crashed,

00:44:56.868 --> 00:45:00.167
because what is this cluster
object in all capitals?

00:45:00.167 --> 00:45:02.434
I don't know what that is.

00:45:02.434 --> 00:45:06.734
So let me show you, you know,
what's going on here.

00:45:06.734 --> 00:45:11.267
So I have this new file here
called KMeansWebViewActivity,

00:45:11.267 --> 00:45:13.467
so I'm gonna drop this
into my project.

00:45:13.467 --> 00:45:17.467
The other thing
I'm going to do is...

00:45:17.467 --> 00:45:19.400
add this new layout

00:45:19.400 --> 00:45:22.400
to my project called Alternate.

00:45:22.400 --> 00:45:24.200
And so you'll see that, you
know, the WebViewActivity

00:45:24.200 --> 00:45:28.400
actually relies on that
alternate layout file

00:45:28.400 --> 00:45:31.767
to do its drawing,
so let me show you this code.

00:45:31.767 --> 00:45:33.901
If anybody can tell me how
to get rid of these properties

00:45:33.901 --> 00:45:37.067
and outline tabs permanently,
I would be forever in your debt.

00:45:37.067 --> 00:45:41.901
Um, but so here is
the new activity I just added.

00:45:41.901 --> 00:45:43.734
Again, this is a new screen
in the application.

00:45:43.734 --> 00:45:46.567
It's gonna do
some different kind of work.

00:45:46.567 --> 00:45:50.567
Um, and so here I have
this mysterious object class

00:45:50.567 --> 00:45:54.133
called ClusterProxy--
ClustererProxy.

00:45:54.133 --> 00:45:56.033
And it has a method
called Cluster,

00:45:56.033 --> 00:45:57.300
and I'll come back to that.

00:45:57.300 --> 00:45:58.734
So this is where, again, the--

00:45:58.734 --> 00:46:00.734
you know,
the initialization occurs.

00:46:00.734 --> 00:46:04.067
I set the--I specified
that this new alternate view

00:46:04.067 --> 00:46:06.100
is gonna be my current view.

00:46:06.100 --> 00:46:08.234
Um, and let's look
at that real quick.

00:46:08.234 --> 00:46:10.901
In contrast to the first one
of these I showed you,

00:46:10.901 --> 00:46:15.234
which was entirely
a custom view,

00:46:15.234 --> 00:46:17.467
like, the entire screen
was occupied by a custom view.

00:46:17.467 --> 00:46:19.501
In this case,
the entire screen is occupied

00:46:19.501 --> 00:46:23.133
by one of these Web views
that's included with Android.

00:46:23.133 --> 00:46:26.100
So then what I do is I grab
a handle to that Web view,

00:46:26.100 --> 00:46:29.734
and then
I enable JavaScript on it,

00:46:29.734 --> 00:46:31.901
and then I do this interesting
little line here.

00:46:31.901 --> 00:46:33.901
And this is that method
I alluded to earlier,

00:46:33.901 --> 00:46:35.734
addJavaScriptInterface.

00:46:35.734 --> 00:46:37.400
What this is doing
is it's injecting

00:46:37.400 --> 00:46:41.200
an instance
of this ClustererProxy

00:46:41.200 --> 00:46:45.200
into the JavaScript namespace
under the name Cluster.

00:46:45.200 --> 00:46:47.400
So what that means is,
if I go back to this thing,

00:46:47.400 --> 00:46:48.968
when you run this
on an Android--

00:46:48.968 --> 00:46:50.667
when you run this app
on an Android device,

00:46:50.667 --> 00:46:53.968
it's actually injected
a Java object

00:46:53.968 --> 00:46:56.968
with, you know,
appropriate shim stuff going on

00:46:56.968 --> 00:47:00.434
into the JavaScript namespace
for JavaScript code

00:47:00.434 --> 00:47:02.400
to actually make calls on.

00:47:02.400 --> 00:47:04.067
Um, in this case,
all it's doing

00:47:04.067 --> 00:47:07.901
is implementing the Clusterer--

00:47:07.901 --> 00:47:09.801
the K-Means clustering
algorithm.

00:47:09.801 --> 00:47:13.734
So I scroll up here...

00:47:13.734 --> 00:47:15.734
and look at this mysterious
clusterer object.

00:47:15.734 --> 00:47:19.400
You can see that all I do
is I do some data formatting

00:47:19.400 --> 00:47:22.567
to get the data from JavaScript
in a form that I can use it.

00:47:22.567 --> 00:47:25.067
I run the DalvikClusterer
on it,

00:47:25.067 --> 00:47:27.167
and then I kind of do
some formatting of the results

00:47:27.167 --> 00:47:29.200
and throw that back up
to JavaScript.

00:47:29.200 --> 00:47:32.534
So let me run this for you.

00:47:45.234 --> 00:47:46.801
Oh, and of course I forgot to--

00:47:46.801 --> 00:47:50.868
I need to add it
to the Android manifest first.

00:48:16.567 --> 00:48:18.033
Run this on my device.

00:48:18.033 --> 00:48:20.968
Switch back to the...

00:48:32.067 --> 00:48:33.367
So starting it up,

00:48:33.367 --> 00:48:35.801
and this is gonna look
a lot like the Web version,

00:48:35.801 --> 00:48:38.734
like the pure Ajax version...

00:48:38.734 --> 00:48:40.767
except that what
it's actually doing again,

00:48:40.767 --> 00:48:42.734
'cause I'm trapped
on the edge, it looks like,

00:48:42.734 --> 00:48:44.234
it's actually downloading
the thing,

00:48:44.234 --> 00:48:46.901
and this time it actually worked
on the Android browser.

00:48:46.901 --> 00:48:48.901
Um...

00:48:48.901 --> 00:48:51.067
so actually, you can't really
read the text at the bottom,

00:48:51.067 --> 00:48:53.167
and it's backwards anyway.

00:48:53.167 --> 00:48:57.167
But to relaunch this,
all I have to do is just quit...

00:48:59.234 --> 00:49:01.734
and rerun it.

00:49:09.901 --> 00:49:11.133
And there it is again.

00:49:11.133 --> 00:49:14.234
Um...

00:49:14.234 --> 00:49:16.033
I wish I could get it
to focus on the numbers.

00:49:16.033 --> 00:49:17.267
Okay.

00:49:17.267 --> 00:49:20.667
So in other words,
what I just did was I injected,

00:49:20.667 --> 00:49:23.234
you know,
the Dalvik Clusterer version

00:49:23.234 --> 00:49:24.901
of the clustering algorithm
into the code,

00:49:24.901 --> 00:49:27.400
but I warn you,
what I'm about to do

00:49:27.400 --> 00:49:30.234
I believe this to be banned
in 49 of the U.S. states,

00:49:30.234 --> 00:49:32.133
and most Western religions
will excommunicate you

00:49:32.133 --> 00:49:33.501
if you do this.

00:49:33.501 --> 00:49:36.868
What I'm actually going to do
is switch this over

00:49:36.868 --> 00:49:41.868
and use the Native Clusterer
and then rerun this application.

00:49:41.868 --> 00:49:43.734
So in other words,
what this is actually doing

00:49:43.734 --> 00:49:45.267
is this is starting
in JavaScript.

00:49:45.267 --> 00:49:46.667
That's where the code
is running.

00:49:46.667 --> 00:49:49.033
And instead of executing
the cluster algorithm

00:49:49.033 --> 00:49:50.501
in JavaScript,
it's calling to Dalvik,

00:49:50.501 --> 00:49:53.667
which is calling to--
through JNI down to C code.

00:49:53.667 --> 00:49:58.234
So I'm actually, you know,
running this code.

00:49:58.234 --> 00:50:00.167
Well, you can't see that 'cause
I didn't switch to the view.

00:50:00.167 --> 00:50:03.968
I'm actually running this
using the Native version.

00:50:03.968 --> 00:50:05.634
So you can actually see
the text there this time,

00:50:05.634 --> 00:50:08.200
and it's at 589 milliseconds.

00:50:08.200 --> 00:50:12.534
It actually was at approximately
1 second or 1.2 seconds

00:50:12.534 --> 00:50:14.133
in the previous version.

00:50:14.133 --> 00:50:15.934
So in other words, what I did
was I basically just took

00:50:15.934 --> 00:50:17.067
the Native version of the code

00:50:17.067 --> 00:50:19.400
and accessed that
from JavaScript.

00:50:19.400 --> 00:50:21.701
So if you think
about that, though,

00:50:21.701 --> 00:50:24.367
there's more to this
than just native code.

00:50:24.367 --> 00:50:25.734
Um, that class--

00:50:25.734 --> 00:50:27.734
that ClustererProxy object
can do anything.

00:50:27.734 --> 00:50:29.400
It can talk to location API.

00:50:29.400 --> 00:50:31.100
It can fire Intense
in the system.

00:50:31.100 --> 00:50:32.901
Really what this represents
is a way

00:50:32.901 --> 00:50:36.033
to augment your Ajax application
so that you can get access

00:50:36.033 --> 00:50:37.234
to the rest of the system.

00:50:37.234 --> 00:50:40.033
And this is--that's why we call
this technique,

00:50:40.033 --> 00:50:43.367
or I call this technique,
Augmented Ajax.

00:50:43.367 --> 00:50:45.467
So now I just kind of want
to wrap up

00:50:45.467 --> 00:50:48.367
and say how do you actually
choose what you want to do?

00:50:48.367 --> 00:50:49.601
So here's a table.

00:50:49.601 --> 00:50:51.467
First, I want to focus
on the middle column.

00:50:51.467 --> 00:50:53.534
First, look at the Dalvik
and the Native versions.

00:50:53.534 --> 00:50:56.133
They have the same rendering
time, which you would expect,

00:50:56.133 --> 00:50:58.234
since it's the same
rendering pipeline.

00:50:58.234 --> 00:51:01.634
Um, JavaScript, though--
and these results, by the way,

00:51:01.634 --> 00:51:06.400
are the average of ten trials
for each of these numbers

00:51:06.400 --> 00:51:08.567
when there was nothing else
running on the device.

00:51:08.567 --> 00:51:11.400
So the JavaScript version, which
is to say the Canvas version,

00:51:11.400 --> 00:51:13.667
runs at 303 milliseconds.

00:51:13.667 --> 00:51:16.367
Now, that's not slow by any
stretch of the imagination.

00:51:16.367 --> 00:51:19.567
Obviously, it's much slower
than a desktop equivalent,

00:51:19.567 --> 00:51:21.901
and it's quite a bit slower

00:51:21.901 --> 00:51:25.434
than the "native code" rendering
pipeline available to Dalvik,

00:51:25.434 --> 00:51:28.601
but for most human user
interactions, that's just fine.

00:51:28.601 --> 00:51:31.567
And also drawing 500, you know,
1x1 rectangles

00:51:31.567 --> 00:51:34.200
to a canvas
is not a common operation.

00:51:34.200 --> 00:51:37.000
So, you know, what this means
is that, you know,

00:51:37.000 --> 00:51:41.334
your takeaway here
should not be that you...

00:51:41.334 --> 00:51:43.801
that canvas is slow,
but really, just that--

00:51:43.801 --> 00:51:45.634
understand
what your application needs.

00:51:45.634 --> 00:51:47.534
You know, perhaps another way
to look at this data

00:51:47.534 --> 00:51:49.334
is in the third column
where I say the percent

00:51:49.334 --> 00:51:50.934
of rendering time.

00:51:50.934 --> 00:51:53.234
The rendering time takes
about 1/3 of the execution time

00:51:53.234 --> 00:51:55.267
of the JavaScript version,
but it takes,

00:51:55.267 --> 00:51:56.667
you know, depending on whether
you're running, you know,

00:51:56.667 --> 00:52:00.634
with or without Native
assistance between 2% and 12%

00:52:00.634 --> 00:52:03.300
of the total execution time
of the other models.

00:52:03.300 --> 00:52:04.501
But again this doesn't mean

00:52:04.501 --> 00:52:05.934
that it's slow
in any absolute sense.

00:52:05.934 --> 00:52:08.033
It just means,
understand your application.

00:52:08.033 --> 00:52:09.968
If you're doing
a lot of computation,

00:52:09.968 --> 00:52:12.934
you know, maybe you want
to look into native code.

00:52:12.934 --> 00:52:15.734
If you're, you know, just doing
a lot of UI updates,

00:52:15.734 --> 00:52:19.701
you know, maybe you can go ahead
and use the JavaScript version.

00:52:19.701 --> 00:52:24.234
Um, so I told you earlier
that I wasn't going to,

00:52:24.234 --> 00:52:26.234
you know, give you a formula
or anything,

00:52:26.234 --> 00:52:28.400
but instead I'll give you
this flowchart.

00:52:28.400 --> 00:52:31.067
So if you're deciding
how to build an application,

00:52:31.067 --> 00:52:32.634
you know, for an Android,
first you ask yourself,

00:52:32.634 --> 00:52:35.601
do you have an existing Web site
that you want to integrate with?

00:52:35.601 --> 00:52:37.300
If the answer is yes,
well, then the next question is,

00:52:37.300 --> 00:52:38.567
is that an Ajax site?

00:52:38.567 --> 00:52:39.901
Meaning that, are you--

00:52:39.901 --> 00:52:42.834
do you already have, like,
a dynamic user interface?

00:52:42.834 --> 00:52:44.167
If the answer is yes,

00:52:44.167 --> 00:52:45.601
then you've probably
already implemented it

00:52:45.601 --> 00:52:48.133
as something
like a REST Service.

00:52:48.133 --> 00:52:50.300
If you haven't--
wait, if you haven't,

00:52:50.300 --> 00:52:51.501
why are you in this room?

00:52:51.501 --> 00:52:53.834
Like, why is your site
not Ajaxy right now?

00:52:53.834 --> 00:52:55.334
Go to one of the other sessions
later today

00:52:55.334 --> 00:52:57.400
and learn how to build
a really cool, you know,

00:52:57.400 --> 00:52:59.334
Ajax-enabled site.

00:52:59.334 --> 00:53:01.234
Um, and so you're gonna come
back to a REST Service anyway.

00:53:01.234 --> 00:53:02.667
If you don't have
an existing Web site,

00:53:02.667 --> 00:53:04.067
and we've determined
that if you do,

00:53:04.067 --> 00:53:07.601
it's gonna be a REST site.

00:53:07.601 --> 00:53:09.133
You know, and if you need
a Web site,

00:53:09.133 --> 00:53:10.767
then, you know, you should go
ahead and build it as a REST.

00:53:10.767 --> 00:53:12.000
But, you know, at this point,

00:53:12.000 --> 00:53:13.400
you know,
the next question is, like,

00:53:13.400 --> 00:53:14.767
"Well, what does your app
actually do?"

00:53:14.767 --> 00:53:16.133
Does your app need
to be really fast?

00:53:16.133 --> 00:53:17.801
If it doesn't, you know,
in the sense--

00:53:17.801 --> 00:53:19.000
and by really fast,

00:53:19.000 --> 00:53:20.400
I mean, like,
does it do a lot of rendering,

00:53:20.400 --> 00:53:23.567
or does it, you know, do a lot
of computation?

00:53:23.567 --> 00:53:26.534
If it's just a plain old app,
Ajax may work fine for you.

00:53:26.534 --> 00:53:30.367
If it does need to be fast,
I'm not sure I believe you yet,

00:53:30.367 --> 00:53:32.334
but if you do say it needs
to be really fast,

00:53:32.334 --> 00:53:33.701
then, okay, go ahead
and use native code.

00:53:33.701 --> 00:53:35.000
If you don't--

00:53:35.000 --> 00:53:36.734
if it doesn't really need to be
screamingly fast,

00:53:36.734 --> 00:53:37.934
then, yeah,
that's what I thought.

00:53:37.934 --> 00:53:39.434
Go ahead and use Dalvik.

00:53:39.434 --> 00:53:40.767
So...

00:53:40.767 --> 00:53:42.534
but wait,
no, if you do use Ajax,

00:53:42.534 --> 00:53:44.300
then there's another
sort of ancillary question.

00:53:44.300 --> 00:53:46.467
Do you want to have the ability
to interact, you know,

00:53:46.467 --> 00:53:49.067
in fancy-pants ways
with notifications and so on?

00:53:49.067 --> 00:53:51.234
In which case, if you do,
you might need to use Dalvik

00:53:51.234 --> 00:53:52.901
or use
this Augmented Ajax technique

00:53:52.901 --> 00:53:54.400
that I showed you earlier.

00:53:54.400 --> 00:53:56.901
You know, but then there's kind
of an all-important question

00:53:56.901 --> 00:53:59.834
of, you know, "Wait, well, what
languages do you even know?"

00:53:59.834 --> 00:54:01.601
If you don't know JavaScript
and you don't want to learn it,

00:54:01.601 --> 00:54:03.634
is Ajax even an option for you?

00:54:03.634 --> 00:54:07.133
You know, so your options
are C/C++, Java, JavaScript,

00:54:07.133 --> 00:54:09.467
and, you know, these will go
back to one of the other models.

00:54:09.467 --> 00:54:14.467
It's like, you know, haven't
we seen this somewhere before?

00:54:14.467 --> 00:54:17.400
You know, and really the point
here--I'm making a joke,

00:54:17.400 --> 00:54:20.968
but in the end, what this
basically boils down to is go

00:54:20.968 --> 00:54:22.067
with what you know.

00:54:22.067 --> 00:54:23.334
There's more
than one way to go.

00:54:23.334 --> 00:54:25.033
There's more
than one way to do this.

00:54:25.033 --> 00:54:26.634
You know, we're not trying
to tell you

00:54:26.634 --> 00:54:28.968
that there's, you know,
one correct way

00:54:28.968 --> 00:54:30.367
to build applications.

00:54:30.367 --> 00:54:32.467
The way that we want you to
think of this is that, you know,

00:54:32.467 --> 00:54:35.868
the centroid, in a way, of your
application can be anywhere.

00:54:35.868 --> 00:54:38.834
It can be primarily Dalvik.
It can be primarily Ajax.

00:54:38.834 --> 00:54:40.434
It can, you know, have
a large component

00:54:40.434 --> 00:54:41.868
in native code.

00:54:41.868 --> 00:54:44.534
And you can pull in components
from any, you know, methodology

00:54:44.534 --> 00:54:47.567
or any aspect of the environment
that you want.

00:54:47.567 --> 00:54:50.200
You know, Dalvik apps
can embed Web views.

00:54:50.200 --> 00:54:51.467
Web apps can call into Dalvik.

00:54:51.467 --> 00:54:54.634
You know, apps can include
native pieces.

00:54:54.634 --> 00:54:57.567
Really, what it boils down to is
understand your application.

00:54:57.567 --> 00:54:59.234
You know, there's nothing wrong

00:54:59.234 --> 00:55:01.934
with wanting to use Dalvik
just because you know Java.

00:55:01.934 --> 00:55:05.033
There's nothing wrong with
wanting to reuse your Ajax site

00:55:05.033 --> 00:55:06.400
because you know JavaScript
really well,

00:55:06.400 --> 00:55:08.601
and you're a JavaScript ninja.

00:55:08.601 --> 00:55:11.200
And so again, just understand
the characteristics of your app,

00:55:11.200 --> 00:55:14.701
know what you want to build,
and go with what you know.

00:55:14.701 --> 00:55:15.734
So that's it.
That's all the material

00:55:15.734 --> 00:55:17.334
that I have for you today.

00:55:17.334 --> 00:55:19.734
And I'm happy to take
any questions.

00:55:19.734 --> 00:55:22.067
There are two microphones here.

00:55:22.067 --> 00:55:23.968
I guess we've only got
just a few minutes left,

00:55:23.968 --> 00:55:27.767
so thanks for your time,
and I appreciate you coming.

00:55:27.767 --> 00:55:31.267
[applause]

00:55:36.400 --> 00:55:37.567
So if you have a question,

00:55:37.567 --> 00:55:39.400
please head up
to one of the microphones

00:55:39.400 --> 00:55:41.434
so that everybody can hear--
they're recording the session.

00:55:41.434 --> 00:55:42.634
man:
Um, just real quick,

00:55:42.634 --> 00:55:44.767
what's the cost
of the JNI piece?

00:55:44.767 --> 00:55:46.267
So when you're calling out...

00:55:46.267 --> 00:55:47.501
Morrill:
That's a great question,

00:55:47.501 --> 00:55:48.834
and I actually
didn't measure that.

00:55:48.834 --> 00:55:50.767
So I didn't measure, like,
you know,

00:55:50.767 --> 00:55:52.601
the time before the call
and the time in the call

00:55:52.601 --> 00:55:54.033
and the time returning.

00:55:54.033 --> 00:55:56.300
Um, actually, if you want to
check out the source code there,

00:55:56.300 --> 00:55:59.834
that URL, it would actually be
very easy to modify my code

00:55:59.834 --> 00:56:01.033
to get those numbers,

00:56:01.033 --> 00:56:03.067
but I didn't specifically
run that test.

00:56:03.067 --> 00:56:04.400
man: Hey, Dan,

00:56:04.400 --> 00:56:06.901
what's the memory limitation
for the processes?

00:56:06.901 --> 00:56:10.234
Is it still 16 megabytes
if you invoke the native code,

00:56:10.234 --> 00:56:12.701
or you can exceed that?

00:56:12.701 --> 00:56:14.133
Morrill: That's
a good question, actually.

00:56:14.133 --> 00:56:17.534
I'm not entirely sure
what the answer to that is.

00:56:17.534 --> 00:56:20.367
16? Okay, yeah, it's enforced
at 16 megabytes per process,

00:56:20.367 --> 00:56:21.534
my colleague says.

00:56:21.534 --> 00:56:23.901
man: And the Java system
available memory

00:56:23.901 --> 00:56:26.901
will report that memory
over native code or...?

00:56:26.901 --> 00:56:28.901
Morrill: So Dalvik
will report the memory

00:56:28.901 --> 00:56:30.667
that is known to Dalvik.

00:56:30.667 --> 00:56:33.734
But you can use the standard,
you know, Linux tools

00:56:33.734 --> 00:56:36.167
to see what the total
process memory usage is.

00:56:36.167 --> 00:56:37.234
man: Thank you.

00:56:37.234 --> 00:56:38.400
Morrill:
Question over here?

00:56:38.400 --> 00:56:39.901
man:
I have a question for you.

00:56:39.901 --> 00:56:41.167
[clears throat]

00:56:41.167 --> 00:56:43.601
Before, what you were doing
was--you were doing

00:56:43.601 --> 00:56:45.300
all the computation
in native code,

00:56:45.300 --> 00:56:48.234
but then you were actually
drawing back in Dalvik.

00:56:48.234 --> 00:56:50.234
Do you have any plans
to extend this

00:56:50.234 --> 00:56:53.567
so that we can actually
just blip from native code

00:56:53.567 --> 00:56:54.901
or draw natively?

00:56:54.901 --> 00:56:56.434
Morrill:
An excellent question.

00:56:56.434 --> 00:56:58.501
You know, we're certainly aware
that that's something

00:56:58.501 --> 00:57:00.133
that people
want to be able to do.

00:57:00.133 --> 00:57:02.200
But, you know, as I said
earlier, for now we're focused

00:57:02.200 --> 00:57:05.634
on getting this thing launched
with, you know, some basic,

00:57:05.634 --> 00:57:07.901
you know, tools and so on,
and, you know, we'll work

00:57:07.901 --> 00:57:10.901
on adding additional APIs like
the ability to draw and so on

00:57:10.901 --> 00:57:13.534
in a future version perhaps.

00:57:13.534 --> 00:57:15.100
But if you want it here,
please, by all means,

00:57:15.100 --> 00:57:17.100
join our developer forum
and let us know.

00:57:17.100 --> 00:57:19.434
man: All right, thanks.
Morrill: Question here?

00:57:19.434 --> 00:57:22.234
man: You mentioned
that NDK will be available

00:57:22.234 --> 00:57:25.767
in donut branch,
but it's also there in cupcake.

00:57:25.767 --> 00:57:27.767
I believe we support it
in cupcake.

00:57:27.767 --> 00:57:31.033
Morrill: That's correct.
In fact, um...

00:57:31.033 --> 00:57:33.267
what this basically boils down
to is this one method

00:57:33.267 --> 00:57:35.334
called System.loadLibrary.

00:57:35.334 --> 00:57:37.367
System.loadLibrary existed
in Android 1.0.

00:57:37.367 --> 00:57:38.567
You can already do this.

00:57:38.567 --> 00:57:40.400
The only thing that's new
is the ability

00:57:40.400 --> 00:57:43.033
to have a toolchain...

00:57:43.033 --> 00:57:44.267
There's two things
that are new:

00:57:44.267 --> 00:57:47.501
the toolchain that is prebuilt
and compiles

00:57:47.501 --> 00:57:49.734
your C code down to native code

00:57:49.734 --> 00:57:53.734
and the guarantee
of a--of a couple libraries,

00:57:53.734 --> 00:57:56.567
in this case libm and libc,
that are guaranteed

00:57:56.567 --> 00:57:58.567
to be present
in a particular format.

00:57:58.567 --> 00:58:01.300
So those are the guarantees
that you didn't have before.

00:58:01.300 --> 00:58:03.234
From a technology perspective
you can already do this.

00:58:03.234 --> 00:58:06.701
From a practical, you know,
should-you-do-this perspective,

00:58:06.701 --> 00:58:08.200
until now,
you haven't been able to do it.

00:58:08.200 --> 00:58:12.234
But, yes, we are hoping to be
able to release this NDK

00:58:12.234 --> 00:58:16.901
for Android 1.5, even though
it's in the donut branch.

00:58:16.901 --> 00:58:18.133
man: Thank you.

00:58:18.133 --> 00:58:20.901
man: What is the extent
of support

00:58:20.901 --> 00:58:23.834
that you're planning to provide
in native code?

00:58:23.834 --> 00:58:27.400
So tomorrow will I be able
to create an activity

00:58:27.400 --> 00:58:29.067
from the native code?

00:58:29.067 --> 00:58:31.100
Morrill:
No, we don't plan to--

00:58:31.100 --> 00:58:34.601
the core of the application
stack will still be driven

00:58:34.601 --> 00:58:36.567
from Dalvik, so, like,
you know, that will handle

00:58:36.567 --> 00:58:39.267
all the event processing
application lifecycles,

00:58:39.267 --> 00:58:41.033
startup, teardown, and so on.

00:58:41.033 --> 00:58:43.234
Native code will remain
just a chunk of code

00:58:43.234 --> 00:58:45.601
that you can make calls into
through JNI.

00:58:45.601 --> 00:58:48.667
man: Yeah, I agree with that,
but suppose I start

00:58:48.667 --> 00:58:51.467
with the Dalvik,
the initial activity's created

00:58:51.467 --> 00:58:54.367
by the Dalvik, but later on,
if I want to create

00:58:54.367 --> 00:58:57.100
multiple activities
from the native code

00:58:57.100 --> 00:58:58.767
for the same application...

00:58:58.767 --> 00:59:00.601
Morrill: Oh, so are you asking
if you have,

00:59:00.601 --> 00:59:03.467
like, a thread
and you call--and you want--

00:59:03.467 --> 00:59:05.200
like, a thread running a native
code and you want to call

00:59:05.200 --> 00:59:07.167
into a Dalvik class,
is that what you're asking?

00:59:07.167 --> 00:59:08.334
man: Uh, yeah.

00:59:08.334 --> 00:59:09.434
Morrill:
Uh, I actually don't think

00:59:09.434 --> 00:59:11.033
we've thought
that far ahead yet.

00:59:11.033 --> 00:59:12.567
Another thing that it would be
great to hear your feedback

00:59:12.567 --> 00:59:14.767
about used cases and so on
in our developer forum.

00:59:14.767 --> 00:59:15.901
man: Okay.
Thank you.

00:59:15.901 --> 00:59:17.067
Morrill:
I think I'm out of time,

00:59:17.067 --> 00:59:19.067
so I want to wrap up again.

00:59:19.067 --> 00:59:20.200
And I'll be around.

00:59:20.200 --> 00:59:21.767
So be around all day
today and tomorrow,

00:59:21.767 --> 00:59:22.901
so I look forward to speaking
with many of you.

00:59:22.901 --> 00:59:26.534
Thanks.
[applause]

