WEBVTT
Kind: captions
Language: en

00:00:05.850 --> 00:00:06.910
So welcome, everyone.

00:00:06.910 --> 00:00:09.849
Thank you for
coming to this talk.

00:00:09.849 --> 00:00:10.640
My name is Etienne.

00:00:10.640 --> 00:00:11.470
I'm from Montreal.

00:00:11.470 --> 00:00:16.129
I'm an Android GDE, an
Android GDG organizer,

00:00:16.129 --> 00:00:18.770
so I like a lot of
Android related things

00:00:18.770 --> 00:00:20.090
as you can guess.

00:00:20.090 --> 00:00:22.960
And I'm actually pretty
passionate about VR.

00:00:22.960 --> 00:00:27.210
So this story
started when we went

00:00:27.210 --> 00:00:30.910
to a hack-a-thon in San
Francisco after I/O for VR

00:00:30.910 --> 00:00:32.360
at the Adobe offices.

00:00:32.360 --> 00:00:34.070
You have to play
around with Tango

00:00:34.070 --> 00:00:37.550
and different-- there were these
dive helmets for the Tango.

00:00:37.550 --> 00:00:39.290
It was quite fascinating.

00:00:39.290 --> 00:00:41.969
So I started basically
thinking, well,

00:00:41.969 --> 00:00:43.760
I have to start making
apps for this thing.

00:00:43.760 --> 00:00:44.660
This is interesting.

00:00:44.660 --> 00:00:46.450
I want to make
apps for Cardboard,

00:00:46.450 --> 00:00:48.820
greater coverage for people.

00:00:48.820 --> 00:00:51.140
Thing is, when you start
making Cardboard app--

00:00:51.140 --> 00:00:53.020
and I wanted to do it
with Java because I

00:00:53.020 --> 00:00:57.160
like challenges that way--
I had a lot to learn.

00:00:57.160 --> 00:00:59.890
I didn't actually know all
that much about OpenGL.

00:00:59.890 --> 00:01:02.235
I mucked about with
it ever since the '90s

00:01:02.235 --> 00:01:03.600
but it kept changing.

00:01:03.600 --> 00:01:05.900
I'm a bit lost with
what was going on,

00:01:05.900 --> 00:01:10.290
so things kept breaking every
time I changed a small detail.

00:01:10.290 --> 00:01:12.109
So that was really painful.

00:01:12.109 --> 00:01:13.650
So, not being a very
sensible person,

00:01:13.650 --> 00:01:15.790
I've been doing
this since last May

00:01:15.790 --> 00:01:18.530
and I'd like to share with you
some of the things I found out

00:01:18.530 --> 00:01:21.660
and some of the pitfalls
you could possibly avoid.

00:01:21.660 --> 00:01:24.430
All right, so I have
a few sections here.

00:01:24.430 --> 00:01:28.020
So this one's about
OpenGL theory.

00:01:28.020 --> 00:01:30.330
So to be aware of
the ecosystem, you

00:01:30.330 --> 00:01:32.132
have OpenGL-- which
is for desktops--

00:01:32.132 --> 00:01:34.090
and you have something
called OpenGL ES-- which

00:01:34.090 --> 00:01:35.300
is for mobile.

00:01:35.300 --> 00:01:39.100
Out there right now, OpenGL
ES 1 is sort of non-existent

00:01:39.100 --> 00:01:39.600
anymore.

00:01:39.600 --> 00:01:42.100
It's what you have on the
first versions of the devices.

00:01:42.100 --> 00:01:44.150
They had a
non-programmable pipeline.

00:01:44.150 --> 00:01:46.500
So I'm going to be saying
programmable pipeline a lot

00:01:46.500 --> 00:01:49.810
during this talk,
just fair warning.

00:01:49.810 --> 00:01:52.530
With ES 2, it brought
the programmable pipeline

00:01:52.530 --> 00:01:56.120
to the mobile world and
this was a good thing.

00:01:56.120 --> 00:01:59.470
So now we're in
2005-- 2015, thank

00:01:59.470 --> 00:02:03.950
you-- and we have OpenGL
ES 3.1 and something called

00:02:03.950 --> 00:02:06.270
the Android Extension Packs.

00:02:06.270 --> 00:02:10.039
So these add a ton of features.

00:02:10.039 --> 00:02:13.060
So you get compute
shaders, tensile textures,

00:02:13.060 --> 00:02:17.810
accelerated visual effect,
high quality ETC2/EAC texture

00:02:17.810 --> 00:02:20.730
compression, advanced texture
rendering, standardized picture

00:02:20.730 --> 00:02:24.000
size, render buffer formats,
more and more and more.

00:02:24.000 --> 00:02:26.380
And the Android
Extension Packs allow

00:02:26.380 --> 00:02:28.940
us to do things like this when
you're looking at an Android

00:02:28.940 --> 00:02:32.870
device such as Android
TVs, which might be running

00:02:32.870 --> 00:02:35.130
very powerful hardware.

00:02:35.130 --> 00:02:38.440
So these extension packs, you
install on a specific device

00:02:38.440 --> 00:02:40.510
and if the device's
hardware supports it,

00:02:40.510 --> 00:02:44.590
you get almost desktop
equivalent performance.

00:02:44.590 --> 00:02:47.590
So this was introduced at
I/O-- I think 2014, actually,

00:02:47.590 --> 00:02:52.110
and it's based on the
the Unreal Engine 5.

00:02:52.110 --> 00:02:54.650
And for the future we're going
to have something coming up

00:02:54.650 --> 00:02:55.970
called Vulkan.

00:02:55.970 --> 00:02:57.620
So, Vulkan was
announced this summer.

00:02:57.620 --> 00:02:58.690
It's a new initiative.

00:02:58.690 --> 00:03:02.730
If you've heard of Apple's Metal
for iOS, it's fairly similar.

00:03:02.730 --> 00:03:05.020
So the idea is that you're
even closer to the GPU.

00:03:05.020 --> 00:03:06.760
They strip away parts
of the framework

00:03:06.760 --> 00:03:10.610
that would make things
theoretically easier for you.

00:03:10.610 --> 00:03:13.120
This will likely lead
to more complex apps,

00:03:13.120 --> 00:03:16.630
but for developers, it will
give them far greater control.

00:03:16.630 --> 00:03:18.940
So, we still have to see
a bit more about that.

00:03:18.940 --> 00:03:20.220
It's just been announced.

00:03:20.220 --> 00:03:22.280
I haven't seen any
specs yet, so I

00:03:22.280 --> 00:03:23.900
think it's being
worked on currently

00:03:23.900 --> 00:03:27.820
at various manufacture
offices and things like that.

00:03:27.820 --> 00:03:31.440
So, you might be a bit dizzy
at this point because of all

00:03:31.440 --> 00:03:34.410
the alphabet soup and acronyms
I've been throwing around,

00:03:34.410 --> 00:03:35.910
and that is normal.

00:03:35.910 --> 00:03:37.880
The key take aways
from the previous slide

00:03:37.880 --> 00:03:39.960
are, plain OpenGLs for desktop.

00:03:39.960 --> 00:03:41.880
ES is for mobile devices.

00:03:41.880 --> 00:03:43.590
ES 2 is where you
started getting

00:03:43.590 --> 00:03:45.960
the programmable pipeline.

00:03:45.960 --> 00:03:49.760
ES 3.1 is what we'll
be looking at today.

00:03:49.760 --> 00:03:54.340
Things to keep in mind-- it's
supported on the Nexus 5.

00:03:54.340 --> 00:03:56.890
It's supported since
Lollipop, but some phones

00:03:56.890 --> 00:03:59.529
won't support it due to limited
hardware on these phones.

00:03:59.529 --> 00:04:01.570
So You're going to need
to programmatically check

00:04:01.570 --> 00:04:03.630
if you get into a
production kind of scenario.

00:04:07.150 --> 00:04:09.797
So let's look at
core OpenGL concepts

00:04:09.797 --> 00:04:11.630
we're going to be playing
around with today.

00:04:11.630 --> 00:04:14.380
So, we're going to go for
a minimum effective dose.

00:04:14.380 --> 00:04:17.579
I'm going to try to gloss
over a lot of stuff,

00:04:17.579 --> 00:04:21.724
because we only have
so much time and time

00:04:21.724 --> 00:04:23.570
is precious, right?

00:04:23.570 --> 00:04:26.630
So we're going to look at my
geometry, math, and core 3D

00:04:26.630 --> 00:04:31.510
concepts, and my idea is
that not a lot of people

00:04:31.510 --> 00:04:33.760
here in the audience have a
lot of previous experience

00:04:33.760 --> 00:04:34.460
with OpenGL.

00:04:34.460 --> 00:04:36.500
So I'm actually going
to ask this right now.

00:04:36.500 --> 00:04:40.690
Who here has actually wrote
an app using OpenGL ES 2 or 3?

00:04:40.690 --> 00:04:41.850
Right, so a few people.

00:04:41.850 --> 00:04:42.620
Good.

00:04:42.620 --> 00:04:45.730
Share notes with the others
if they look confused.

00:04:45.730 --> 00:04:47.897
So, our core concepts.

00:04:47.897 --> 00:04:49.605
We're going to be
talking about 3D space.

00:04:49.605 --> 00:04:52.730
You're probably familiar with
the idea of Euclidean space,

00:04:52.730 --> 00:04:53.310
right?

00:04:53.310 --> 00:04:54.780
x, y, and z.

00:04:54.780 --> 00:04:57.600
I had the honor of choosing
a graph where the axes are

00:04:57.600 --> 00:04:59.390
sort of long for OpenGL.

00:04:59.390 --> 00:05:05.220
So, just to clarify something,
on OpenGL this is x, this is y,

00:05:05.220 --> 00:05:05.910
and z is depth.

00:05:09.560 --> 00:05:13.040
Then we're going to be talking
about the vertex a lot,

00:05:13.040 --> 00:05:17.710
or something called
vertices, plural.

00:05:17.710 --> 00:05:20.960
The thing to note though,
which might be a bit confusing,

00:05:20.960 --> 00:05:24.300
is that we're going to be
talking of the vertex of course

00:05:24.300 --> 00:05:28.310
as points in, say, an object--
as part of like a triangle that

00:05:28.310 --> 00:05:31.035
composes the faces of the object
that we're going to render.

00:05:31.035 --> 00:05:33.160
But we're also going to be
talking about attributes

00:05:33.160 --> 00:05:34.790
hooked to that vertex.

00:05:34.790 --> 00:05:36.490
So it's not like
the pure math vertex

00:05:36.490 --> 00:05:37.910
that we're used to talk about.

00:05:37.910 --> 00:05:41.760
It will have other concepts
associated to it, like normals,

00:05:41.760 --> 00:05:45.340
color-- things like that.

00:05:45.340 --> 00:05:48.880
So, vertices assemble
into primitives.

00:05:48.880 --> 00:05:51.540
This is like the
old school graph

00:05:51.540 --> 00:05:55.620
from the OpenGL Red Book from
the '90s, or even earlier

00:05:55.620 --> 00:05:56.790
probably.

00:05:56.790 --> 00:05:58.830
The one we're going to
be playing with a lot

00:05:58.830 --> 00:06:01.802
is triangles.

00:06:01.802 --> 00:06:04.260
To make a distinction between
triangles and triangle strips

00:06:04.260 --> 00:06:06.210
or fans or all
these other things,

00:06:06.210 --> 00:06:09.360
you might be wondering, why
is this even in the spec?

00:06:09.360 --> 00:06:12.670
And just a quick-- we're
going to be talking

00:06:12.670 --> 00:06:14.080
about performance a little bit.

00:06:14.080 --> 00:06:17.300
One of the things with
OpenGL is that the more data

00:06:17.300 --> 00:06:20.530
you have to shove into the
pipeline, the slower it gets.

00:06:20.530 --> 00:06:23.670
So you might notice here that
a triangle strip, for example,

00:06:23.670 --> 00:06:28.630
uses up less vertices than the
plain old series of triangles

00:06:28.630 --> 00:06:29.940
because they share vertices.

00:06:32.960 --> 00:06:34.380
So, let's talk about models.

00:06:34.380 --> 00:06:36.900
So, these are wire frame models.

00:06:36.900 --> 00:06:39.930
As probably a lot of you know,
models are actually usually--

00:06:39.930 --> 00:06:41.620
well in this case, we're
going to talk about triangles

00:06:41.620 --> 00:06:43.203
as our primitives,
so all these models

00:06:43.203 --> 00:06:47.010
will be composed of
vertices that form

00:06:47.010 --> 00:06:49.387
triangles that form the model.

00:06:49.387 --> 00:06:51.470
The important point I want
to make with this slide

00:06:51.470 --> 00:06:53.030
is that when you
create a model, say

00:06:53.030 --> 00:06:55.270
we are going to
talk about a cube,

00:06:55.270 --> 00:06:57.830
the coordinates of
the vertices are

00:06:57.830 --> 00:07:02.892
going to be around
the 0, 0, 0-- origin.

00:07:02.892 --> 00:07:04.350
So everything is
always going to be

00:07:04.350 --> 00:07:07.980
relative to the origin,
more for management reasons

00:07:07.980 --> 00:07:11.250
as we'll see a bit later.

00:07:11.250 --> 00:07:13.830
So, another concept you
have to get your head around

00:07:13.830 --> 00:07:15.750
is transforms.

00:07:15.750 --> 00:07:18.000
So, we're talking about
translations-- moving

00:07:18.000 --> 00:07:20.300
an object in a different
point in space,

00:07:20.300 --> 00:07:24.510
rotations-- twisting
an object, and scaling

00:07:24.510 --> 00:07:27.349
is also one-- making
things bigger or smaller.

00:07:27.349 --> 00:07:29.140
What you might want to
note from this slide

00:07:29.140 --> 00:07:32.550
is that the order that you
apply operations is important.

00:07:32.550 --> 00:07:34.614
The good news here is
that the example code

00:07:34.614 --> 00:07:36.030
that comes with
the talk, all this

00:07:36.030 --> 00:07:37.380
has been taken care of for you.

00:07:37.380 --> 00:07:39.460
You don't have to
experiment and go, "oh,

00:07:39.460 --> 00:07:42.740
why is this moving all around
so wrong and I'm confused."

00:07:42.740 --> 00:07:44.810
So a lot of that
will be taken away,

00:07:44.810 --> 00:07:47.730
which is good when you
want to experiment.

00:07:47.730 --> 00:07:49.140
Just keep that in mind.

00:07:49.140 --> 00:07:52.040
You're going to get a bit
deeper into the rabbit hole.

00:07:52.040 --> 00:07:53.810
All right, linear algebra.

00:07:53.810 --> 00:07:57.320
Transforms imply matrices,
multiplication of matrices.

00:07:57.320 --> 00:08:02.440
So most people, their math
courses are far, far away

00:08:02.440 --> 00:08:04.470
and these are fuzzy
concepts, and you

00:08:04.470 --> 00:08:06.730
don't want to mess around
too much with that.

00:08:06.730 --> 00:08:09.130
The good news is
that this is all

00:08:09.130 --> 00:08:11.955
taken care of, mostly by DSDKs
and APIs, so we don't need

00:08:11.955 --> 00:08:13.080
to worry too much about it.

00:08:13.080 --> 00:08:16.030
You do need to understand
that all the operations I've

00:08:16.030 --> 00:08:19.220
talked about usually
end up in one big matrix

00:08:19.220 --> 00:08:21.710
and you multiply your
vertex by that matrix,

00:08:21.710 --> 00:08:25.460
and the vertex will be placed
into its proper space--

00:08:25.460 --> 00:08:27.740
its proper coordinate space.

00:08:27.740 --> 00:08:29.970
We'll come back to that.

00:08:29.970 --> 00:08:32.220
All right, another big concept.

00:08:32.220 --> 00:08:35.220
So, projections and cameras.

00:08:35.220 --> 00:08:38.049
So, when we're going to
configure our OpenGL pipeline,

00:08:38.049 --> 00:08:40.360
we're going to have to set
up rules of projection.

00:08:40.360 --> 00:08:42.070
So if you look at
the first figure,

00:08:42.070 --> 00:08:45.592
the idea here is we're telling
GL how to project things.

00:08:45.592 --> 00:08:48.050
So it involves telling it what
are the bounds of our view--

00:08:48.050 --> 00:08:50.310
the top, the bottom,
left, and right--

00:08:50.310 --> 00:08:53.240
and also involves giving
it some configuration

00:08:53.240 --> 00:08:56.440
so it kind of knows what
is far and what is close.

00:08:56.440 --> 00:08:58.960
So when it comes time
to project the vertices,

00:08:58.960 --> 00:09:02.430
we have a 3D space onto our
2D screen, or our 2D rendering

00:09:02.430 --> 00:09:06.480
area, it'll know how to
proportion these things.

00:09:06.480 --> 00:09:07.867
So this is through configuring.

00:09:07.867 --> 00:09:09.700
That, again, don't get
too worried about it.

00:09:09.700 --> 00:09:11.210
You'll see that line of code.

00:09:11.210 --> 00:09:12.626
You probably won't
even notice it.

00:09:12.626 --> 00:09:14.850
It's a one liner, but it's
a fairly simple thing.

00:09:14.850 --> 00:09:17.960
But you need to be aware of all
this theory, fix things when

00:09:17.960 --> 00:09:20.180
they start going wrong.

00:09:20.180 --> 00:09:22.750
The other diagram is just here
to illustrate that we also

00:09:22.750 --> 00:09:25.050
need to place our
models, but we also

00:09:25.050 --> 00:09:27.190
need to put the camera in there.

00:09:27.190 --> 00:09:31.630
So we have the concept of
objects in space projected

00:09:31.630 --> 00:09:33.680
onto a screen, but we
also have the concept

00:09:33.680 --> 00:09:37.200
of this camera that's moving
about and looking at things.

00:09:37.200 --> 00:09:39.120
So that's also an important
thing to remember,

00:09:39.120 --> 00:09:42.780
because that's going to be
another mathematical operation

00:09:42.780 --> 00:09:45.060
that we're going to
shovel under the carpet,

00:09:45.060 --> 00:09:46.893
but that's going to be
there and that you'll

00:09:46.893 --> 00:09:48.880
want to be aware of.

00:09:48.880 --> 00:09:50.400
So, lighting.

00:09:50.400 --> 00:09:51.640
Lighting is super exciting.

00:09:51.640 --> 00:09:55.290
So we'll learn how to implement
Lambertian reflectance.

00:09:55.290 --> 00:09:58.930
Lambertian reflectance is named
after Johann Heinrich Lambert,

00:09:58.930 --> 00:10:01.870
who introduced the concept
of perfect diffusion

00:10:01.870 --> 00:10:04.970
in his 1760 book, "Photometria."

00:10:04.970 --> 00:10:08.680
I actually have a few scans
from an early edition.

00:10:08.680 --> 00:10:10.250
Yeah, all right.

00:10:10.250 --> 00:10:12.120
Let's start that over.

00:10:12.120 --> 00:10:14.580
My only attempt at a joke today.

00:10:14.580 --> 00:10:15.570
Simple lighting, right?

00:10:15.570 --> 00:10:18.310
We want to keep things simple
and lighting, to be sure,

00:10:18.310 --> 00:10:21.200
is actually a super
important subject in OpenGL

00:10:21.200 --> 00:10:24.720
and it gets gnarly very quickly.

00:10:24.720 --> 00:10:26.470
So we want to avoid
that for today.

00:10:26.470 --> 00:10:29.560
We just want to have the base
minimum lighting model that we

00:10:29.560 --> 00:10:32.430
can use to start experimenting.

00:10:32.430 --> 00:10:34.570
So we do need to understand
two concepts again.

00:10:34.570 --> 00:10:36.890
Ambient lighting, which is
just the light that reaches

00:10:36.890 --> 00:10:39.880
an object after bouncing
around everywhere in the room.

00:10:39.880 --> 00:10:42.490
So it's your background
radiation lighting.

00:10:42.490 --> 00:10:45.450
It's the minimum amount of light
that a point on the surface

00:10:45.450 --> 00:10:47.851
is going to get by
default. And then

00:10:47.851 --> 00:10:49.600
you have something
called diffuse lighting

00:10:49.600 --> 00:10:51.830
we'll be playing with,
which is the light that

00:10:51.830 --> 00:10:55.570
reaches your eye after a source
of light-- the rays bounce off

00:10:55.570 --> 00:10:57.700
a surface and reach your eye.

00:10:57.700 --> 00:11:00.745
So here the amount of
light reaching your eye

00:11:00.745 --> 00:11:04.020
will be directly
proportional to the angle

00:11:04.020 --> 00:11:07.490
between the surface of the
object and the source of light.

00:11:07.490 --> 00:11:10.529
And that's what this
whole Lambert cosine

00:11:10.529 --> 00:11:12.070
law is going to be
about, which we're

00:11:12.070 --> 00:11:13.660
going to see on a few frames.

00:11:13.660 --> 00:11:15.700
But, again, very easy
to calculate all that

00:11:15.700 --> 00:11:16.865
stuff with OpenGL.

00:11:16.865 --> 00:11:18.240
Right now I'm
giving you context,

00:11:18.240 --> 00:11:20.698
so when you see that line of
code, you'll be like, oh yeah,

00:11:20.698 --> 00:11:23.690
it's that thing he
talked about earlier.

00:11:23.690 --> 00:11:26.480
Another important concept
related to the lighting

00:11:26.480 --> 00:11:27.720
is normals.

00:11:27.720 --> 00:11:30.490
So a normal is a
perpendicular vector

00:11:30.490 --> 00:11:34.880
pointing straight out of a
face or of a facet of a shape.

00:11:34.880 --> 00:11:36.590
But in our case,
we're going to have

00:11:36.590 --> 00:11:40.350
normals associated to vertices.

00:11:40.350 --> 00:11:43.240
And that's slightly
different, because if you

00:11:43.240 --> 00:11:47.180
look at the last diagram
here, we are seeing normals

00:11:47.180 --> 00:11:49.320
coming out of a bent shape.

00:11:49.320 --> 00:11:51.990
So what happens is that
you can make approximations

00:11:51.990 --> 00:11:54.230
with normals where,
even if you are actually

00:11:54.230 --> 00:11:57.740
playing with a triangle, that
triangle is part of a sphere.

00:11:57.740 --> 00:12:00.100
You can make it so that the
normals are pointing out

00:12:00.100 --> 00:12:03.090
from the center of the sphere,
so that helps the lighting

00:12:03.090 --> 00:12:05.410
model light this thing
as if it was a sphere

00:12:05.410 --> 00:12:10.090
and help you get the better
simulation of these shapes.

00:12:10.090 --> 00:12:12.320
So the other thing I
want to quickly say

00:12:12.320 --> 00:12:14.820
is that normals-- you might
all know this already--

00:12:14.820 --> 00:12:17.580
but it's worth mentioning that
normals are called normals

00:12:17.580 --> 00:12:20.820
because they are normalized
vectors, meaning that they have

00:12:20.820 --> 00:12:21.870
one unit lengths.

00:12:21.870 --> 00:12:25.250
You might remember that from
your old-- or in my case--

00:12:25.250 --> 00:12:27.441
old math courses.

00:12:27.441 --> 00:12:28.940
So, just to make a
little reference.

00:12:28.940 --> 00:12:31.760
All right, so, we've
talked about vertices

00:12:31.760 --> 00:12:33.420
and how in OpenGL
they are actually

00:12:33.420 --> 00:12:34.690
a combination of things.

00:12:34.690 --> 00:12:36.780
So, in this case, I just
wanted to show quickly

00:12:36.780 --> 00:12:41.830
that you have-- basically
we're going to have position,

00:12:41.830 --> 00:12:43.330
the normal, the color.

00:12:43.330 --> 00:12:45.580
And texture we're not going
to play around with today,

00:12:45.580 --> 00:12:47.230
but these are all
attributes that

00:12:47.230 --> 00:12:49.280
are hooked up with this
bundle of data that

00:12:49.280 --> 00:12:51.370
is a vertex in our pipeline.

00:12:51.370 --> 00:12:54.580
And on the right
side, I just wanted

00:12:54.580 --> 00:12:57.980
to point out and give you a hint
that if you've never done GLSL

00:12:57.980 --> 00:13:00.310
before, how that
language looks like.

00:13:00.310 --> 00:13:03.800
GLSL stands for Graphic
Language Shading-- no, wait.

00:13:03.800 --> 00:13:06.771
GL Shading Language, which
is kind of redundant.

00:13:06.771 --> 00:13:09.020
Maybe it's Graphical Library
Shading Language, rather,

00:13:09.020 --> 00:13:12.050
so it's not redundant at all.

00:13:12.050 --> 00:13:15.870
So just be aware of the
vec3, vec4, and vec2.

00:13:15.870 --> 00:13:19.590
That really represents an
area of floats in this case,

00:13:19.590 --> 00:13:20.100
all right?

00:13:20.100 --> 00:13:21.780
Just so you know.

00:13:21.780 --> 00:13:23.860
One of the few
last, complicated,

00:13:23.860 --> 00:13:25.560
gnarly diagrams I'm
going to show today.

00:13:25.560 --> 00:13:27.729
I'm not actually
going to go over this.

00:13:27.729 --> 00:13:30.020
Just wanted to point out if
you go to the khronos site,

00:13:30.020 --> 00:13:31.540
you can get the
full picture of what

00:13:31.540 --> 00:13:34.571
is the OpenGL pipeline
in big detail for 3.1.

00:13:34.571 --> 00:13:36.820
It's actually good reading
once you've gotten familiar

00:13:36.820 --> 00:13:38.320
with the basic
concepts and you want

00:13:38.320 --> 00:13:41.410
to start playing around
configuring your own set up.

00:13:41.410 --> 00:13:44.036
But let's skip over
that right now and look

00:13:44.036 --> 00:13:46.130
at a very high level view.

00:13:46.130 --> 00:13:47.830
You can think of
the OpenGL pipeline

00:13:47.830 --> 00:13:50.950
as a client server relationship,
a very simple one at that.

00:13:50.950 --> 00:13:55.210
You have your application,
which is running off of the CPU,

00:13:55.210 --> 00:13:59.600
talking to the OpenGL ES
framework client, which is also

00:13:59.600 --> 00:14:01.260
running off of the CPU.

00:14:01.260 --> 00:14:03.830
And you're talking to this to
configure this whole pipeline.

00:14:03.830 --> 00:14:05.840
You're going to be
feeding data in there,

00:14:05.840 --> 00:14:07.520
and that's all
happening in the CPU

00:14:07.520 --> 00:14:10.680
and CPU land is kind
of slow, and a transfer

00:14:10.680 --> 00:14:13.850
from CPU land to GPU land is
almost equivalent to a web

00:14:13.850 --> 00:14:15.550
call.

00:14:15.550 --> 00:14:18.320
That's really the key
idea of this slide

00:14:18.320 --> 00:14:22.190
that you should take away.

00:14:22.190 --> 00:14:25.190
The other thing is I had
to have a perfmatter slide.

00:14:25.190 --> 00:14:26.960
It has nothing to do
with the [INAUDIBLE].

00:14:26.960 --> 00:14:29.430
I couldn't find a way
to shove it in there.

00:14:29.430 --> 00:14:33.410
But this magic number,
0.016 milliseconds

00:14:33.410 --> 00:14:35.440
in this case, if
you're rendering

00:14:35.440 --> 00:14:39.200
goes over that, you're going
to make your users nauseous.

00:14:39.200 --> 00:14:42.450
Especially since we're not
talking about the Vive here.

00:14:42.450 --> 00:14:44.500
We're talking about
Cardboard on phones, which

00:14:44.500 --> 00:14:46.592
might not be all that great.

00:14:46.592 --> 00:14:49.050
So you're going to need to
start thinking about performance

00:14:49.050 --> 00:14:51.920
pretty early in the process.

00:14:51.920 --> 00:14:54.410
So the better way of doing
this, and you'll see it--

00:14:54.410 --> 00:14:57.610
we have it in our examples-- is
to have a frame rate indicator

00:14:57.610 --> 00:15:00.500
that you can keep an eye on so
that when you're experimenting,

00:15:00.500 --> 00:15:03.340
if ever you see that frame
rate drop dramatically--

00:15:03.340 --> 00:15:06.156
under 60 frames a second--
which you can't go over anyway,

00:15:06.156 --> 00:15:08.780
because the refresh rate of the
device is pretty much 60 frames

00:15:08.780 --> 00:15:10.260
a second.

00:15:10.260 --> 00:15:12.340
But when you start
dropping those frames,

00:15:12.340 --> 00:15:15.190
you have to ask yourself, OK,
I should start being careful.

00:15:15.190 --> 00:15:17.140
I should probably
change my approach,

00:15:17.140 --> 00:15:20.190
read a few optimization
articles, and start fixing it.

00:15:20.190 --> 00:15:23.910
So, early optimization I'm not
super fond of-- as most people

00:15:23.910 --> 00:15:28.600
aren't-- but early warning
signs, that's pretty good.

00:15:28.600 --> 00:15:31.430
So the simplified graph
for the OpenGL pipeline.

00:15:34.980 --> 00:15:36.800
The thing to know
here-- the color code.

00:15:36.800 --> 00:15:40.610
So the blue is mostly
happening in user space.

00:15:40.610 --> 00:15:42.830
It's happening in
your app in Java.

00:15:42.830 --> 00:15:45.269
So that's where you're going
to take all these vertices

00:15:45.269 --> 00:15:47.810
that you got from somewhere and
shove them into the pipeline.

00:15:47.810 --> 00:15:50.210
That's where you're going
to configure the pipeline

00:15:50.210 --> 00:15:52.380
and actually pass
it the programs

00:15:52.380 --> 00:15:55.120
that it's going to execute
at different steps.

00:15:55.120 --> 00:15:58.530
This is where most of the Java
code you're doing is happening.

00:15:58.530 --> 00:16:01.190
After that, the
vertex step is one

00:16:01.190 --> 00:16:03.180
of the first programmable
stages that you're

00:16:03.180 --> 00:16:06.540
going to give a program to
the pipeline to execute.

00:16:06.540 --> 00:16:09.330
This thing is running over
each of the vertices being

00:16:09.330 --> 00:16:10.720
fed into the pipeline.

00:16:10.720 --> 00:16:12.370
I know it's very
theoretical right now,

00:16:12.370 --> 00:16:14.161
but hopefully it will
start coming together

00:16:14.161 --> 00:16:15.310
in a few slides.

00:16:15.310 --> 00:16:17.450
I just want to get good basics.

00:16:17.450 --> 00:16:20.900
So those vertices, you're
going to be calculating on them

00:16:20.900 --> 00:16:23.160
and you're going to be
basically projecting them

00:16:23.160 --> 00:16:26.960
onto the screen, which will
allow then the green part--

00:16:26.960 --> 00:16:29.590
so the yellow parts are
programmable stages.

00:16:29.590 --> 00:16:31.261
Green part are fixed stages.

00:16:31.261 --> 00:16:32.510
You don't get to program them.

00:16:32.510 --> 00:16:35.200
They're part of the
OpenGL framework.

00:16:35.200 --> 00:16:37.490
And in this case,
what's going to happen

00:16:37.490 --> 00:16:39.100
is it's going to
take the vertex data

00:16:39.100 --> 00:16:42.100
and it's going to decide,
OK, so where on screen

00:16:42.100 --> 00:16:43.980
are these primitives?

00:16:43.980 --> 00:16:48.710
So it's going to map those
out, and once this is known,

00:16:48.710 --> 00:16:50.870
it goes on to the
fragment stage--

00:16:50.870 --> 00:16:52.890
the other programmable stage.

00:16:52.890 --> 00:16:55.140
Fragments are
basically programs that

00:16:55.140 --> 00:16:57.230
are there to paint a pixel.

00:16:57.230 --> 00:16:59.870
So, for each of the
pixels you have on screen,

00:16:59.870 --> 00:17:02.460
the fragment shader's
going to run once.

00:17:02.460 --> 00:17:07.069
So we'll see how we can do a lot
of fun stuff with that later.

00:17:07.069 --> 00:17:09.410
Finish up the chain,
the frame buffer.

00:17:09.410 --> 00:17:10.980
It's just there to
give you the hint

00:17:10.980 --> 00:17:14.020
that you can make a lot more
complex builds with the OpenGL

00:17:14.020 --> 00:17:17.069
pipeline, but you don't need to.

00:17:17.069 --> 00:17:20.200
You can basically see these two
steps and up to the GL surface

00:17:20.200 --> 00:17:22.319
view as I'm dumping a
bitmap to the screen.

00:17:24.900 --> 00:17:28.132
This slide is to reinforce
the idea-- which I don't find

00:17:28.132 --> 00:17:29.590
is very intuitive
for most people--

00:17:29.590 --> 00:17:34.240
that you first have vertices
that are being computed on,

00:17:34.240 --> 00:17:36.240
which are projected
onto a screen.

00:17:36.240 --> 00:17:39.900
And once that relationship
between the model and space

00:17:39.900 --> 00:17:43.610
and the actual screen is done,
then each of these pixels--

00:17:43.610 --> 00:17:46.690
the system knows which
shape they belong to.

00:17:46.690 --> 00:17:49.220
So it now knows what
computations to accomplish

00:17:49.220 --> 00:17:51.800
and what parameters to
pass to your program

00:17:51.800 --> 00:17:54.190
for it to calculate the
color of that pixel.

00:17:57.810 --> 00:18:00.260
The smallest light on the
power of parallel processing.

00:18:00.260 --> 00:18:02.260
So what we're
looking at here is--

00:18:02.260 --> 00:18:04.210
I couldn't find a good
video of it, sadly.

00:18:04.210 --> 00:18:06.610
It's an NVIDIA event where
the MythBusters where there

00:18:06.610 --> 00:18:09.220
to actually show why
is parallel processing

00:18:09.220 --> 00:18:12.510
much more awesome than
linear processing or a CPU.

00:18:12.510 --> 00:18:15.610
So all they had set
up is a paintball gun

00:18:15.610 --> 00:18:17.020
that was drawing the Mona Lisa.

00:18:17.020 --> 00:18:19.390
So they had the first
one instance at a time.

00:18:19.390 --> 00:18:22.110
The robot arm would paint a
wall with paintball pellets,

00:18:22.110 --> 00:18:23.360
which was kind of cool.

00:18:23.360 --> 00:18:26.240
And then they had a massive
array representing GPUs.

00:18:26.240 --> 00:18:30.610
A lot of them, running on
NVIDIA hardware-- presumably--

00:18:30.610 --> 00:18:32.140
painting a picture
really quickly.

00:18:32.140 --> 00:18:33.850
So that's the other thing
to think about is that,

00:18:33.850 --> 00:18:36.099
if that if program is running
for each and every pixel

00:18:36.099 --> 00:18:37.910
in your frame, it's
actually all running

00:18:37.910 --> 00:18:41.490
in parallel, which is how this
can be actually a fast process.

00:18:41.490 --> 00:18:43.050
OK, so some practice.

00:18:43.050 --> 00:18:44.750
Some actual code.

00:18:44.750 --> 00:18:45.640
Get ready.

00:18:45.640 --> 00:18:47.350
It's going to be heavy.

00:18:47.350 --> 00:18:49.140
Maybe not that
much, but, anyway.

00:18:49.140 --> 00:18:51.410
We're going to start with
vanilla Android OpenGL.

00:18:51.410 --> 00:18:53.770
So again, we have a few
people who played around

00:18:53.770 --> 00:18:56.806
with at least OpenGL, so you're
going to be familiar with this.

00:18:56.806 --> 00:18:58.680
I'm going to sell the
punchline a little bit.

00:18:58.680 --> 00:18:59.820
You'll see that
with Cardboard, you

00:18:59.820 --> 00:19:02.111
don't need to add that much
code to what you've already

00:19:02.111 --> 00:19:04.610
learned to actually get
the VR app running, which

00:19:04.610 --> 00:19:06.170
is the good news.

00:19:06.170 --> 00:19:10.310
So this class diagram, the
takeaway here-- GLSurfaceView

00:19:10.310 --> 00:19:11.370
is an actual view.

00:19:11.370 --> 00:19:13.030
It inherits from the view.

00:19:13.030 --> 00:19:16.140
And the thing that
actually draws to that view

00:19:16.140 --> 00:19:17.470
is a renderer.

00:19:17.470 --> 00:19:19.477
So that's a subclass
of GLSurfaceView.

00:19:19.477 --> 00:19:21.310
You are the person that
will implement that.

00:19:21.310 --> 00:19:23.250
That's more of an interface
or an abstract class.

00:19:23.250 --> 00:19:24.666
I'm not sure, I
should've checked.

00:19:24.666 --> 00:19:26.810
I will for the next talk.

00:19:26.810 --> 00:19:30.120
But basically you're going to be
implementing onSurfaceCreated,

00:19:30.120 --> 00:19:32.540
onSurfaceChange maybe--
most of the time mine

00:19:32.540 --> 00:19:35.200
is empty-- and onDrawFrame.

00:19:35.200 --> 00:19:39.112
So the action all happens in the
surface created and draw frame.

00:19:39.112 --> 00:19:41.320
Surface created to initialize
this whole big pipeline

00:19:41.320 --> 00:19:42.480
we've been talking about.

00:19:42.480 --> 00:19:44.740
Draw a frame just to
take the data that

00:19:44.740 --> 00:19:47.440
needs to be in the pipeline
for now, shove it down there,

00:19:47.440 --> 00:19:48.940
press draw, we're done.

00:19:48.940 --> 00:19:49.891
All right.

00:19:49.891 --> 00:19:51.390
Threading-- quick
note on threading.

00:19:51.390 --> 00:19:52.490
I made this nice,
little diagram,

00:19:52.490 --> 00:19:54.448
and I want to really go
quickly over it though.

00:19:56.700 --> 00:19:58.339
It's on its own render thread.

00:19:58.339 --> 00:20:00.380
The renderer is running
on its own render thread.

00:20:00.380 --> 00:20:02.726
It's got its own dedicated
GL rendering thread.

00:20:02.726 --> 00:20:04.350
So you have the same
kind of challenges

00:20:04.350 --> 00:20:05.790
that you have with
the UI thread.

00:20:05.790 --> 00:20:08.160
If you want to communicate
with your renderer,

00:20:08.160 --> 00:20:10.850
you need to go through something
like queueEventRunnable

00:20:10.850 --> 00:20:12.780
or some other
threading mechanism.

00:20:12.780 --> 00:20:13.690
OK?

00:20:13.690 --> 00:20:17.350
And this is so that you can
get reliable draw calls and all

00:20:17.350 --> 00:20:18.810
your 60 frames per second.

00:20:21.680 --> 00:20:22.890
Cardboard SDK.

00:20:22.890 --> 00:20:26.860
I promised it wouldn't be
much more difficult. It's not.

00:20:26.860 --> 00:20:29.945
There are, however,
a few new methods and

00:20:29.945 --> 00:20:32.570
in the stereo renderer, which is
the equivalent of the renderer

00:20:32.570 --> 00:20:33.880
we just looked at.

00:20:33.880 --> 00:20:36.950
So you have a few more
calls that come into play

00:20:36.950 --> 00:20:38.920
when Cardboard is there,
and we'll see which

00:20:38.920 --> 00:20:41.950
those are in a few seconds.

00:20:41.950 --> 00:20:45.150
You might notice at the
bottom here that we are still

00:20:45.150 --> 00:20:50.080
using jars in the libs folder.

00:20:50.080 --> 00:20:53.010
Somebody talk to that team
and get them on grade level,

00:20:53.010 --> 00:20:55.616
thank you.

00:20:55.616 --> 00:20:56.865
So setting up the GL Pipeline.

00:20:56.865 --> 00:21:00.150
The first step that we quickly
glossed over in the renderer.

00:21:00.150 --> 00:21:05.540
So onSurfaceCreated is being
called with an EGLConfig.

00:21:05.540 --> 00:21:07.240
I'll say it right up front.

00:21:07.240 --> 00:21:08.740
This might be called
more than once

00:21:08.740 --> 00:21:09.880
during the lifetime
of your program

00:21:09.880 --> 00:21:11.280
if you get called in, et cetera.

00:21:11.280 --> 00:21:13.880
So we have to be ready to
think about reinitializing

00:21:13.880 --> 00:21:15.000
everything.

00:21:15.000 --> 00:21:19.180
Now, that being said, here most
of the complexity of the steps

00:21:19.180 --> 00:21:22.560
is abstract in a class
I call geometry, which

00:21:22.560 --> 00:21:24.970
you can see in my actual
sample code that's

00:21:24.970 --> 00:21:27.410
available on my GitHub with a
link at the end of the talk.

00:21:27.410 --> 00:21:31.540
I just wanted to give you
the basics so we get started.

00:21:31.540 --> 00:21:33.960
So initBuffers.

00:21:33.960 --> 00:21:36.760
So that's step one.

00:21:36.760 --> 00:21:39.150
Then step two is going
to be in the GL program.

00:21:39.150 --> 00:21:41.010
So those yellow steps
in the pipeline,

00:21:41.010 --> 00:21:44.070
we're going to configure those
after setting up the buffers.

00:21:44.070 --> 00:21:46.524
And then, after we've
set up the programs,

00:21:46.524 --> 00:21:47.940
we're going to
initialize handles.

00:21:47.940 --> 00:21:49.810
So let's look at
each of those steps

00:21:49.810 --> 00:21:52.500
and break down what
they actually do.

00:21:52.500 --> 00:21:55.270
Step one, initializing buffers.

00:21:55.270 --> 00:21:58.130
This is basically
initializing a chunk of memory

00:21:58.130 --> 00:22:01.990
so that we can shove floats in
there that will be our vertices

00:22:01.990 --> 00:22:06.710
and our vertex attributes,
all bundled in there

00:22:06.710 --> 00:22:09.060
so that we can then
pass it to the pipeline.

00:22:09.060 --> 00:22:11.770
So, as you can see, it's
fairly straightforward code.

00:22:11.770 --> 00:22:15.700
Not much to say here except
you're almost in C land,

00:22:15.700 --> 00:22:16.670
but that's OK.

00:22:16.670 --> 00:22:19.080
You're going to have to get
used to it with OpenGL a bit.

00:22:19.080 --> 00:22:20.830
It's not that complicated.

00:22:20.830 --> 00:22:24.257
So step 2.1, initialize
in the GL program.

00:22:24.257 --> 00:22:25.840
I even bothered
putting this here just

00:22:25.840 --> 00:22:28.256
to remind you that we're talking
about the yellow stages--

00:22:28.256 --> 00:22:30.580
programmable stage
of the pipeline--

00:22:30.580 --> 00:22:33.340
to mention that vertex shader
code and fragment shader code

00:22:33.340 --> 00:22:35.000
are actually big string blobs.

00:22:35.000 --> 00:22:37.212
They're actually
the source code.

00:22:37.212 --> 00:22:38.670
That's what we're
passing in there.

00:22:42.510 --> 00:22:44.710
We won't dig into the
load shader method

00:22:44.710 --> 00:22:46.710
that you see at the
top, because it's

00:22:46.710 --> 00:22:50.220
pretty much the same process
as what's happening below here.

00:22:50.220 --> 00:22:53.740
So the first thing you
do is, you call GL-- so,

00:22:53.740 --> 00:22:55.481
notice they're all
static method calls.

00:22:55.481 --> 00:22:57.230
Every time you interact
with the pipeline,

00:22:57.230 --> 00:22:58.490
it's that kind of call.

00:22:58.490 --> 00:23:01.660
In this case, we're
using GLE ES 30.

00:23:01.660 --> 00:23:04.500
You might have been using
20 before or whatever,

00:23:04.500 --> 00:23:08.670
so the number changes depending
on features that you're using.

00:23:08.670 --> 00:23:10.920
So we're creating a program
and we're getting a handle

00:23:10.920 --> 00:23:11.270
to our program.

00:23:11.270 --> 00:23:12.936
So we're basically
telling the pipeline,

00:23:12.936 --> 00:23:14.450
create a program object for me.

00:23:14.450 --> 00:23:18.190
And it's giving us back
the pointer, pretty much.

00:23:18.190 --> 00:23:21.010
Then we can take-- we've
used the same kind of process

00:23:21.010 --> 00:23:23.690
to create handles to
vertex shader and fragment

00:23:23.690 --> 00:23:25.050
shader up top.

00:23:25.050 --> 00:23:27.300
So at that point, we
take those two handles

00:23:27.300 --> 00:23:29.280
that have been initialized
in the pipeline

00:23:29.280 --> 00:23:32.210
and we pass those two
shaders into the program

00:23:32.210 --> 00:23:35.427
to finish with a link call.

00:23:35.427 --> 00:23:37.260
So the fun part-- and
we'll see that later--

00:23:37.260 --> 00:23:39.884
is that when you do this, you're
going to actually get feedback

00:23:39.884 --> 00:23:42.870
from OpenGL as to whether or
not you have compile errors,

00:23:42.870 --> 00:23:44.770
and they're going
to be a bit verbose.

00:23:44.770 --> 00:23:47.850
So that's going to be
interesting in a few slides.

00:23:47.850 --> 00:23:50.370
All right, so, step three.

00:23:50.370 --> 00:23:52.470
So I've talked
about the handles,

00:23:52.470 --> 00:23:54.710
so this is how you get them.

00:23:54.710 --> 00:24:00.270
Literally give the string
that's going to be the-- well,

00:24:00.270 --> 00:24:03.540
we'll see in the shader that's
the actual variable name.

00:24:03.540 --> 00:24:04.770
So it's through a strain.

00:24:04.770 --> 00:24:08.310
Might seem a bit clumsy
of a way, but-- Yeah.

00:24:08.310 --> 00:24:12.100
All right so, this is our first
shader, the vertex shader.

00:24:12.100 --> 00:24:16.540
It's a fairly simple semi
pass-through vertex shader.

00:24:16.540 --> 00:24:19.030
So this means that we're
not doing much here

00:24:19.030 --> 00:24:25.620
except transforming our current
vertex into its final position,

00:24:25.620 --> 00:24:27.310
as I talked about earlier.

00:24:27.310 --> 00:24:31.460
So we apply model view and
projection transformations

00:24:31.460 --> 00:24:32.850
that are stored in this matrix.

00:24:32.850 --> 00:24:35.710
So one matrix can be a
bundle of transformation

00:24:35.710 --> 00:24:37.020
that you can apply in one shot.

00:24:37.020 --> 00:24:38.790
And that's what
we're doing here.

00:24:38.790 --> 00:24:40.580
So that lets us know
where that vertex is

00:24:40.580 --> 00:24:41.992
going to end up on screen.

00:24:41.992 --> 00:24:43.450
For the fragment
shader, it's going

00:24:43.450 --> 00:24:46.335
to come along afterwards
to get its list of pixels.

00:24:51.530 --> 00:24:54.200
While we're here, these
are-- we have to mention,

00:24:54.200 --> 00:24:56.680
these are the inputs that we
just used in our Java code.

00:24:56.680 --> 00:24:58.340
So I just want to
point those out

00:24:58.340 --> 00:25:01.670
so you make a direct mental
link between the two.

00:25:01.670 --> 00:25:03.790
And the outputs are
kind of important.

00:25:03.790 --> 00:25:06.100
And the syntax is actually
slightly different in ES 2

00:25:06.100 --> 00:25:08.450
for people who've
done ES 2 before.

00:25:08.450 --> 00:25:11.834
Like in and out I don't
believe were in GL ES 2.

00:25:11.834 --> 00:25:13.250
So it's good to
know these things,

00:25:13.250 --> 00:25:17.870
because your old things might
break if you start doing 3.13.

00:25:17.870 --> 00:25:19.364
And then the output
basically are

00:25:19.364 --> 00:25:20.780
things that are
going to be passed

00:25:20.780 --> 00:25:25.190
on-- varyings that are going
to be passed on to the fragment

00:25:25.190 --> 00:25:27.450
shader.

00:25:27.450 --> 00:25:30.024
So varyings, well, I won't get
into that concept right now,

00:25:30.024 --> 00:25:32.440
but we can talk about it later
if you're interested, maybe

00:25:32.440 --> 00:25:33.730
after the talk.

00:25:33.730 --> 00:25:35.670
So the last big point
here is that we're

00:25:35.670 --> 00:25:37.570
going to set our color--
our vColor-- that's

00:25:37.570 --> 00:25:40.340
going to be passed to
the fragment shader to 1.

00:25:40.340 --> 00:25:45.040
1, 1, 1, 1, which
means white pixel.

00:25:45.040 --> 00:25:48.550
Or rather, white vertex
attribute, I should say.

00:25:48.550 --> 00:25:51.090
And then next up
in the pipeline,

00:25:51.090 --> 00:25:53.280
as illustrated here,
we have our fragment

00:25:53.280 --> 00:25:55.960
shader with the color
being passed into it,

00:25:55.960 --> 00:25:59.250
and we see that all it's
doing is taking the color that

00:25:59.250 --> 00:26:01.567
was given to it by the vertex
shader and just saying,

00:26:01.567 --> 00:26:02.900
OK, that's the code of my pixel.

00:26:02.900 --> 00:26:03.550
That's it.

00:26:03.550 --> 00:26:04.570
Not doing anything.

00:26:04.570 --> 00:26:07.350
That's another
passed-through shader.

00:26:07.350 --> 00:26:10.080
All right so, what
does this give us?

00:26:10.080 --> 00:26:13.470
So, once the steps
in the pipeline

00:26:13.470 --> 00:26:17.399
have executed, following
a call to draw--

00:26:17.399 --> 00:26:19.190
I'm calling it simpleDraw
here because it's

00:26:19.190 --> 00:26:21.590
more of an example.

00:26:21.590 --> 00:26:24.130
So I just wanted to
show you how that works.

00:26:24.130 --> 00:26:27.266
So first step, we're
going to use the program.

00:26:27.266 --> 00:26:28.890
So if you remember
when we initialized,

00:26:28.890 --> 00:26:31.220
that's where we basically
tell OpenGL, OK, those

00:26:31.220 --> 00:26:34.490
shaders I've configured,
time to use them now.

00:26:34.490 --> 00:26:37.920
Then we pass data
to those shaders.

00:26:37.920 --> 00:26:39.450
So we already have our handles.

00:26:39.450 --> 00:26:41.980
We have our variables into
which we're pushing the data.

00:26:41.980 --> 00:26:45.270
So we're bridging the gap
between the two again.

00:26:45.270 --> 00:26:48.450
So we pass our
projection matrix--

00:26:48.450 --> 00:26:50.930
or our transform
matrix, sorry-- and then

00:26:50.930 --> 00:26:55.500
we also pass vertices and
normals in a big bunch.

00:26:55.500 --> 00:26:57.980
And then the last
call here, DrawArrays.

00:26:57.980 --> 00:27:00.830
So we're just basically
drawing a number of--

00:27:00.830 --> 00:27:04.620
and then we're giving it the
number of vertices in there.

00:27:04.620 --> 00:27:07.410
And you might notice that the
first parameter, GL_TRIANGLES,

00:27:07.410 --> 00:27:10.710
is us telling OpenGL, so I'm
passing you all these vertices

00:27:10.710 --> 00:27:12.060
and their triangles.

00:27:12.060 --> 00:27:14.640
It could've been triangle
strip if our information was

00:27:14.640 --> 00:27:16.340
configured differently,
but they're not.

00:27:16.340 --> 00:27:18.067
We're trying to
keep things simple.

00:27:18.067 --> 00:27:20.400
I didn't mention this, but
obviously at the bottom here,

00:27:20.400 --> 00:27:21.420
you see the result of this.

00:27:21.420 --> 00:27:23.753
It's a white square-- a white
cube, actually, what we're

00:27:23.753 --> 00:27:26.365
facing in our demo program.

00:27:28.986 --> 00:27:31.620
All right, basic lighting.

00:27:31.620 --> 00:27:33.840
So I'm trying to fly
through a lot of this stuff,

00:27:33.840 --> 00:27:36.374
so you can come and ask me
questions after if you're

00:27:36.374 --> 00:27:38.915
kind of like, uh, he went a bit
fast there, what the hell was

00:27:38.915 --> 00:27:39.414
that?

00:27:39.414 --> 00:27:41.892
So basic light model--
if we use the shader

00:27:41.892 --> 00:27:43.350
as we've configured
them right now,

00:27:43.350 --> 00:27:45.350
this is what we're going
to get when we're going

00:27:45.350 --> 00:27:47.260
to rotate our cube in space.

00:27:47.260 --> 00:27:49.520
Not exactly right.

00:27:49.520 --> 00:27:52.020
What we want is
this on the right.

00:27:52.020 --> 00:27:56.860
So, we need to have a minimum of
lighting in there for our scene

00:27:56.860 --> 00:27:58.390
to do any kind of sense.

00:27:58.390 --> 00:28:01.100
And we're not going to go beyond
minimum, because that rabbit

00:28:01.100 --> 00:28:02.950
hole is pretty deep--
and pretty awesome--

00:28:02.950 --> 00:28:05.950
but we want to get
somewhere today.

00:28:05.950 --> 00:28:08.290
So, how do we get to this?

00:28:08.290 --> 00:28:11.320
We need a light source.

00:28:11.320 --> 00:28:14.770
We're hard coding it
in the shader here,

00:28:14.770 --> 00:28:17.930
and you can see that at the
very top-- so the u_LightPos

00:28:17.930 --> 00:28:19.180
right there.

00:28:19.180 --> 00:28:23.590
But you can also know how
we apply the uMVMatrix here,

00:28:23.590 --> 00:28:24.662
not MVP.

00:28:24.662 --> 00:28:26.620
So there's an important
little distinction here

00:28:26.620 --> 00:28:28.990
that you'll see in
the example code.

00:28:28.990 --> 00:28:31.970
It's because you want to
put that light in 3D space,

00:28:31.970 --> 00:28:33.640
not projected on screen.

00:28:33.640 --> 00:28:36.710
Because you're still working
in the theoretical model so

00:28:36.710 --> 00:28:39.250
you want to put all the points
in space at the right place.

00:28:39.250 --> 00:28:41.541
So you're taking that light
and you're putting it here,

00:28:41.541 --> 00:28:44.040
and you want it to
be moved relative

00:28:44.040 --> 00:28:45.250
to the camera, et cetera.

00:28:45.250 --> 00:28:47.060
But you don't want it
projected on screen,

00:28:47.060 --> 00:28:48.643
because you're still
at the step where

00:28:48.643 --> 00:28:50.935
you're going to be
calculating theoretical stuff.

00:28:50.935 --> 00:28:52.460
You're not yet in screen space.

00:28:52.460 --> 00:28:56.100
So that's why the projection
part is not there.

00:28:56.100 --> 00:28:57.820
So, our point light source.

00:28:57.820 --> 00:29:03.370
Point light source-- one point
emits rays in all directions.

00:29:03.370 --> 00:29:05.660
Transforming the
vertex into eye space.

00:29:05.660 --> 00:29:09.810
So, we're applying the
same model view transform

00:29:09.810 --> 00:29:12.610
to our vertex and our normal,
because all these three

00:29:12.610 --> 00:29:16.410
things with the light
source are going

00:29:16.410 --> 00:29:19.700
to used in the calculations to
find out what color we should

00:29:19.700 --> 00:29:22.060
be giving our vertex.

00:29:24.620 --> 00:29:29.180
Then the way to find that out,
we get a light direction vector

00:29:29.180 --> 00:29:32.290
from the light
source to the vertex.

00:29:32.290 --> 00:29:35.220
So we find out what
that vertex is-- sorry,

00:29:35.220 --> 00:29:41.640
that vector is-- then we
calculate the famous Lambert

00:29:41.640 --> 00:29:42.490
factor.

00:29:42.490 --> 00:29:44.700
So that's actually
very, very simple.

00:29:44.700 --> 00:29:46.640
We just want the angle
between the normal

00:29:46.640 --> 00:29:49.050
and the light vectors,
and having that angle

00:29:49.050 --> 00:29:50.850
allows us to determine
what kind of shade

00:29:50.850 --> 00:29:53.790
we're going to give
to that surface.

00:29:53.790 --> 00:29:57.480
The 0.1 at the
bottom, actually--

00:29:57.480 --> 00:29:59.255
so the actual finding
out of the angle

00:29:59.255 --> 00:30:00.700
is the dot product we see there.

00:30:00.700 --> 00:30:03.540
So that dot method, being
called with modelViewNormal

00:30:03.540 --> 00:30:07.190
and lightVector, that's the
one that calculates the angle.

00:30:07.190 --> 00:30:11.480
And the max part, with the
second parameter being 0.1,

00:30:11.480 --> 00:30:13.320
that's the minimum
amount of light that's

00:30:13.320 --> 00:30:14.830
going to be on the surface.

00:30:14.830 --> 00:30:16.590
I talked about ambient light.

00:30:16.590 --> 00:30:18.600
This is ambient light,
and the dot product

00:30:18.600 --> 00:30:23.780
is the Lambert factor,
which is diffusion light.

00:30:23.780 --> 00:30:26.710
And then we multiply that
with the color of the object.

00:30:26.710 --> 00:30:27.890
So far, our object is white.

00:30:27.890 --> 00:30:28.960
We multiply it by white.

00:30:28.960 --> 00:30:32.800
It's going to give us a
varying factor, and we're done.

00:30:32.800 --> 00:30:34.780
All right so,
running that gave us

00:30:34.780 --> 00:30:37.440
the screenshot we saw earlier.

00:30:37.440 --> 00:30:40.190
So, let's enable the
Cardboard SDK now.

00:30:40.190 --> 00:30:41.230
Enough flat 3D.

00:30:41.230 --> 00:30:42.660
We're done.

00:30:42.660 --> 00:30:44.922
All right, so, very
simple first thing.

00:30:44.922 --> 00:30:45.755
This is your layout.

00:30:45.755 --> 00:30:47.670
You just want a
full on Cardboard

00:30:47.670 --> 00:30:51.170
view that fills out
your whole view space.

00:30:51.170 --> 00:30:55.710
Then your main activity-- in
this case, VRTalkActivity.

00:30:55.710 --> 00:30:58.500
So, these three lines
highlighted here

00:30:58.500 --> 00:31:01.210
are what you need to
actually configure your view.

00:31:01.210 --> 00:31:03.490
So you set VRModeEnabled
to whatever.

00:31:03.490 --> 00:31:05.450
In this case, I set
it to false just

00:31:05.450 --> 00:31:08.380
to show you what happens when
you don't have VR enabled.

00:31:08.380 --> 00:31:11.500
You're just seeing a plain,
magic window type thing.

00:31:11.500 --> 00:31:15.480
And turning it on just
gives us a stereoview.

00:31:15.480 --> 00:31:17.240
At this point,
what's happening is,

00:31:17.240 --> 00:31:19.600
we're calling the
draw methods twice

00:31:19.600 --> 00:31:23.800
for half the screen with
different camera perspectives--

00:31:23.800 --> 00:31:27.666
those two eyes-- and this is
the result. At this point,

00:31:27.666 --> 00:31:30.040
we can just slip this in a
Cardboard unit and we're good.

00:31:30.040 --> 00:31:30.873
We have stereoscopy.

00:31:36.160 --> 00:31:37.520
So, what does this look like?

00:31:37.520 --> 00:31:38.620
There's two parts now.

00:31:38.620 --> 00:31:40.330
Instead of just having
one draw command,

00:31:40.330 --> 00:31:43.130
we have two draw command.

00:31:43.130 --> 00:31:45.400
onNewFrame-- well,
it's not at all a draw

00:31:45.400 --> 00:31:48.570
command I should say, but it's
being called that every frame.

00:31:48.570 --> 00:31:50.710
And the idea here
is that anything

00:31:50.710 --> 00:31:52.990
that you wouldn't want to
set up twice for both eyes,

00:31:52.990 --> 00:31:55.840
because it's the same for both
eyes, you do that job here.

00:31:55.840 --> 00:31:58.560
In this case, if
you remember, we

00:31:58.560 --> 00:32:01.280
talked about the
projection cone earlier.

00:32:01.280 --> 00:32:02.860
So this is where we set it.

00:32:02.860 --> 00:32:08.470
So we do setLookAtM and we pass
all the parameters, so now,

00:32:08.470 --> 00:32:08.970
wait.

00:32:08.970 --> 00:32:09.720
No, that's not it.

00:32:09.720 --> 00:32:11.130
That's the camera position.

00:32:11.130 --> 00:32:11.630
Sorry.

00:32:11.630 --> 00:32:13.181
Confused things.

00:32:13.181 --> 00:32:13.680
Wrong thing.

00:32:13.680 --> 00:32:15.179
Anyway, so at this
point, what we're

00:32:15.179 --> 00:32:20.240
saying is basically we're
setting up our camera based

00:32:20.240 --> 00:32:23.730
on-- well, it is the
projection cone of sorts,

00:32:23.730 --> 00:32:25.780
but anyway, you'll
see in a second.

00:32:25.780 --> 00:32:26.280
Oh.

00:32:26.280 --> 00:32:29.630
Yeah, and before I miss that,
the set light position here

00:32:29.630 --> 00:32:32.400
would be a place where you
could set a moving light source,

00:32:32.400 --> 00:32:34.870
but we don't actually have
that in our current scene.

00:32:34.870 --> 00:32:37.480
But if we wanted our model
to dynamically update,

00:32:37.480 --> 00:32:39.020
we could do those
operations here,

00:32:39.020 --> 00:32:43.050
because you don't want to run
once for each eye, obviously.

00:32:43.050 --> 00:32:45.190
So, the actual onDrawEye
command, where things

00:32:45.190 --> 00:32:47.320
get a bit more interesting.

00:32:47.320 --> 00:32:51.020
So first thing that's good to
do is just to clear the buffers.

00:32:51.020 --> 00:32:52.670
So just basically
clear the screen

00:32:52.670 --> 00:32:53.700
so that you don't
see the results

00:32:53.700 --> 00:32:55.616
of the previous operation--
the previous frame

00:32:55.616 --> 00:32:57.630
being rendered--
having been rendered.

00:32:57.630 --> 00:33:01.290
And this is where we set up
our view from our frustrum.

00:33:01.290 --> 00:33:03.830
So we find out what the
ratio is for each eye,

00:33:03.830 --> 00:33:08.290
just so that our perspective--
we won't get a squished image.

00:33:08.290 --> 00:33:10.060
We do that one call
here, and that's

00:33:10.060 --> 00:33:14.430
what's going to set up
our whole cone of view.

00:33:14.430 --> 00:33:15.690
It's fairly simple.

00:33:15.690 --> 00:33:18.145
We define left, right,
bottom, top, near, and far.

00:33:29.850 --> 00:33:32.080
So, calculating the
view transform matrix.

00:33:32.080 --> 00:33:34.560
This is the part where
we take the camera

00:33:34.560 --> 00:33:39.230
position and the eye, basically,
and turn it into a view matrix.

00:33:39.230 --> 00:33:41.160
That's why we need both.

00:33:41.160 --> 00:33:44.170
So this is the part where you
basically-- the view is camera.

00:33:44.170 --> 00:33:48.450
Think of "v"-- the vMatrix
as the camera matrix.

00:33:48.450 --> 00:33:50.780
So at that point, we have
our projection matrix,

00:33:50.780 --> 00:33:52.610
we have our camera matrix.

00:33:52.610 --> 00:33:56.720
We know the heighth and
width of our viewport,

00:33:56.720 --> 00:33:59.912
so geometry, for reasons
of its own, uses that.

00:33:59.912 --> 00:34:01.370
Don't pay too much
attention to it.

00:34:01.370 --> 00:34:02.870
The important parts
are the updating

00:34:02.870 --> 00:34:05.560
of information coming
from the renderer

00:34:05.560 --> 00:34:08.179
so that you can draw stuff
based on the dynamically

00:34:08.179 --> 00:34:11.710
changing position of
the head of the user.

00:34:11.710 --> 00:34:13.650
And then the draw
command at the bottom.

00:34:13.650 --> 00:34:15.936
So we'll get back to what
actually happens in the draw

00:34:15.936 --> 00:34:17.870
command a bit later.

00:34:17.870 --> 00:34:20.860
So, this is the
part where things

00:34:20.860 --> 00:34:22.489
get a little bit more exciting.

00:34:22.489 --> 00:34:24.300
So what's the point of all this?

00:34:24.300 --> 00:34:26.050
At which point am I
starting to experiment

00:34:26.050 --> 00:34:28.139
and having fun,
because, to be honest,

00:34:28.139 --> 00:34:31.602
the part I'm talking about-- all
this is-- it's the boring bit.

00:34:31.602 --> 00:34:33.310
You want to see things
animate on screen.

00:34:33.310 --> 00:34:35.300
You want to create a world.

00:34:35.300 --> 00:34:38.590
You want to be creative
and fast and active

00:34:38.590 --> 00:34:39.712
and you want to do stuff.

00:34:39.712 --> 00:34:41.170
You just don't want
to poke around.

00:34:41.170 --> 00:34:43.404
So the problem that we
have is that-- well, OK.

00:34:43.404 --> 00:34:44.570
I'll talk about live coding.

00:34:44.570 --> 00:34:46.780
So we want to set up an
environment for live coding.

00:34:46.780 --> 00:34:48.030
What is live coding?

00:34:48.030 --> 00:34:51.340
It's not like live coding on
stage-- not today, I'm sorry.

00:34:51.340 --> 00:34:53.100
With Wi-Fi and
everything-- and you'll see

00:34:53.100 --> 00:34:55.150
I need the Wi-Fi
for my little demo--

00:34:55.150 --> 00:34:57.790
that would not have
been a great idea.

00:34:57.790 --> 00:35:01.210
Live coding is when
you have a code,

00:35:01.210 --> 00:35:04.950
build, run cycle that is so fast
it's basically instantaneous,

00:35:04.950 --> 00:35:07.770
so that you get instant response
as you type out your program.

00:35:07.770 --> 00:35:09.600
You see what's happening.

00:35:09.600 --> 00:35:15.240
So this is basically a
fragment shader editor online.

00:35:15.240 --> 00:35:18.880
So we're basically live
editing the shader.

00:35:18.880 --> 00:35:23.360
You see as I comment out
stuff, we can see it in action.

00:35:23.360 --> 00:35:25.970
So here we're just basically
varying the amount of color,

00:35:25.970 --> 00:35:30.860
depending on our x and our
y on a simple sine wave.

00:35:30.860 --> 00:35:33.179
So just poking about
very, very quickly, we

00:35:33.179 --> 00:35:35.220
can experiment and find
out how all of this works

00:35:35.220 --> 00:35:37.240
and get a very good
feeling for-- oh,

00:35:37.240 --> 00:35:40.770
so that's what a shader--
a fragment shader does--

00:35:40.770 --> 00:35:42.510
and you can come up with ideas.

00:35:42.510 --> 00:35:45.000
So, that instant feedback
loop is super important,

00:35:45.000 --> 00:35:47.030
and on Android everybody's
painfully aware

00:35:47.030 --> 00:35:49.810
than APK doesn't build
instantaneously, right?

00:35:49.810 --> 00:35:53.560
So if you want to get into that
world of quick experimentation,

00:35:53.560 --> 00:35:54.390
you're in trouble.

00:35:54.390 --> 00:35:56.540
It's not going to work.

00:35:56.540 --> 00:35:58.950
This is what I'm basically
showing you today--

00:35:58.950 --> 00:36:01.942
how to set that up--
because it's not that hard.

00:36:01.942 --> 00:36:03.400
I'll touch really,
really quickly--

00:36:03.400 --> 00:36:05.608
oh, I'm getting short on
time, so I'll skip on those.

00:36:05.608 --> 00:36:07.990
Ask me questions after.

00:36:07.990 --> 00:36:09.710
I'll be able to fill those in.

00:36:09.710 --> 00:36:11.550
So, the basic live
publishing tools

00:36:11.550 --> 00:36:13.850
that we have-- I use
IntelliJ with Node.js

00:36:13.850 --> 00:36:15.450
and it runs a small
JavaScript program

00:36:15.450 --> 00:36:18.360
that I can edit that will
actually push my geometry

00:36:18.360 --> 00:36:20.559
into the viewer unit.

00:36:20.559 --> 00:36:22.600
So what happens is, I have
my pipeline configured

00:36:22.600 --> 00:36:25.920
on my phone, and it's getting
live data-- not from itself,

00:36:25.920 --> 00:36:27.600
but from the internet.

00:36:27.600 --> 00:36:30.265
So using Firebase that way--
if you've played with Firebase,

00:36:30.265 --> 00:36:32.685
you know that its response
time is almost instantaneous--

00:36:32.685 --> 00:36:36.420
so I can push my geometry
and push my edited shader

00:36:36.420 --> 00:36:39.220
code straight into
Firebase, which broadcasts

00:36:39.220 --> 00:36:41.870
to however many viewer
units are actively

00:36:41.870 --> 00:36:43.970
subscribed to Firebase.

00:36:43.970 --> 00:36:46.880
That's fairly interesting.

00:36:46.880 --> 00:36:49.790
So you might be wondering how
to do real time reconfiguration.

00:36:49.790 --> 00:36:50.710
This slide's just
here to show you

00:36:50.710 --> 00:36:53.126
it's basically the same thing
we did at the initialization

00:36:53.126 --> 00:36:53.810
stage.

00:36:53.810 --> 00:36:55.370
You can just do
it between frames.

00:36:55.370 --> 00:36:58.440
You can just create a new shader
and compile it and run it.

00:36:58.440 --> 00:36:59.955
It also means--
well, we're going

00:36:59.955 --> 00:37:01.830
to get to shaders at
this point because we're

00:37:01.830 --> 00:37:02.746
talking about shaders.

00:37:02.746 --> 00:37:04.480
Again, I want it to
be very, very clear

00:37:04.480 --> 00:37:08.949
that vertex shaders, they run
a few times for each vertices

00:37:08.949 --> 00:37:10.990
and then the pixel shader,
the fragment shader is

00:37:10.990 --> 00:37:12.630
running in [INAUDIBLE], sorry.

00:37:12.630 --> 00:37:13.750
What can we do with this?

00:37:13.750 --> 00:37:16.420
So the geometry I've
been talking about

00:37:16.420 --> 00:37:18.510
is iterative geometry.

00:37:18.510 --> 00:37:22.890
So with OpenGL ES
3, you get a feature

00:37:22.890 --> 00:37:25.760
where you can define your
shape and you can actually

00:37:25.760 --> 00:37:29.650
make a ton of copies of it,
changing some attributes of it

00:37:29.650 --> 00:37:31.207
as you go along.

00:37:31.207 --> 00:37:33.540
So, this is the data structure--
I'm skipping a bit over

00:37:33.540 --> 00:37:36.360
because I want to get
to the good bits faster.

00:37:36.360 --> 00:37:42.940
So, this is me live editing
the geometry and IntelliJ.

00:37:42.940 --> 00:37:45.090
So I hope I did that
fast when I recorded it.

00:37:45.090 --> 00:37:46.551
Can see it's blinking.

00:37:46.551 --> 00:37:47.050
Right.

00:37:47.050 --> 00:37:49.424
So, what I'm doing is every
time I'm uncommenting a line,

00:37:49.424 --> 00:37:52.070
I'm rerunning the
JavaScript program,

00:37:52.070 --> 00:37:55.320
which is pushing new geometry
to Firebase, which is then

00:37:55.320 --> 00:37:57.730
coming back to the
units-- it's actually

00:37:57.730 --> 00:38:01.690
my physical unit next to
my laptop, in this case.

00:38:01.690 --> 00:38:03.990
So we're just adding
new shapes as we go.

00:38:03.990 --> 00:38:06.270
And we're just uncommenting
lines right here,

00:38:06.270 --> 00:38:08.300
so what you can easily
do at that point,

00:38:08.300 --> 00:38:10.670
start putting for loops in
there and creating cubes

00:38:10.670 --> 00:38:12.850
and creating your own spaces.

00:38:12.850 --> 00:38:14.450
That's a part we
won't get to today,

00:38:14.450 --> 00:38:16.340
but you can see
the possibilities,

00:38:16.340 --> 00:38:18.330
and you can start
experimenting very quickly.

00:38:21.370 --> 00:38:25.390
So, then the other thing that we
can start doing is deformation.

00:38:25.390 --> 00:38:27.740
So, I'm just
mentioning this to let

00:38:27.740 --> 00:38:29.960
you know what's possible
with the shaders,

00:38:29.960 --> 00:38:32.840
and which ways you can use
and abuse the pipeline.

00:38:32.840 --> 00:38:35.434
So in this case, what we're
doing is that, it's an example.

00:38:35.434 --> 00:38:36.850
The link is at the
bottom-- again,

00:38:36.850 --> 00:38:38.460
I'm going to share
the slides later--

00:38:38.460 --> 00:38:40.860
but this is an experiment
where you take a sphere,

00:38:40.860 --> 00:38:45.380
you apply noise to the
distance of a vertex

00:38:45.380 --> 00:38:47.460
to the center of
the sphere, and you

00:38:47.460 --> 00:38:48.860
get a deformation like this.

00:38:48.860 --> 00:38:51.700
You can come up with really,
really nice effects this way.

00:38:51.700 --> 00:38:54.110
Like, that demo ends up being
like an actual exploding

00:38:54.110 --> 00:38:56.220
ball of fire with
really nice effects,

00:38:56.220 --> 00:38:58.810
and there's about 20 lines
of shader code in there.

00:38:58.810 --> 00:39:00.640
And this kind of
stuff is for WebGL,

00:39:00.640 --> 00:39:02.130
but it's easily
applicable to all

00:39:02.130 --> 00:39:05.740
that I've shown you
today on Android.

00:39:05.740 --> 00:39:07.060
Quickly, the fragment shaders.

00:39:07.060 --> 00:39:09.539
So, texture mapping, you
probably know what that is.

00:39:09.539 --> 00:39:10.330
You have a texture.

00:39:10.330 --> 00:39:11.840
You're mapping it onto a shape.

00:39:11.840 --> 00:39:14.580
So you have to think, oh,
who's doing the job of that?

00:39:14.580 --> 00:39:15.820
It's the fragment shader.

00:39:15.820 --> 00:39:18.170
Fragment shader is getting
all that texture data--

00:39:18.170 --> 00:39:20.050
and since it's responsible
for painting the pixels--

00:39:20.050 --> 00:39:21.799
it's the one that's
going to be looking up

00:39:21.799 --> 00:39:23.950
those pixels in some cases
and taking them straight

00:39:23.950 --> 00:39:26.990
from the bitmap and dropping
them into the right projected

00:39:26.990 --> 00:39:29.030
space on those triangles.

00:39:29.030 --> 00:39:31.560
So, where does that
become interesting?

00:39:31.560 --> 00:39:33.630
So, you can abuse
the fragment shader

00:39:33.630 --> 00:39:35.740
to do kind of
interesting things.

00:39:35.740 --> 00:39:38.110
So, here I'm going
to show-- hopefully

00:39:38.110 --> 00:39:42.260
quickly-- how to abuse
it to start rendering

00:39:42.260 --> 00:39:44.400
geometric shapes
that have nothing

00:39:44.400 --> 00:39:46.942
to do with the actual rendering
that we're going to be doing.

00:39:46.942 --> 00:39:48.608
And the quick note I
wanted to show here

00:39:48.608 --> 00:39:50.170
is that, while
I'm editing this--

00:39:50.170 --> 00:39:53.720
so this is the ace editor
running in a web view,

00:39:53.720 --> 00:39:55.420
pushing-- every time
I type a change,

00:39:55.420 --> 00:39:59.701
it pushes the Firebase, comes
back to the viewer unit.

00:39:59.701 --> 00:40:01.450
And what we were seeing
at the bottom here

00:40:01.450 --> 00:40:03.120
was PID cat, logcat.

00:40:03.120 --> 00:40:06.440
So we're seeing the PID cat
output of the compile errors

00:40:06.440 --> 00:40:09.480
that I'm putting into
the web view right here.

00:40:09.480 --> 00:40:10.420
The chrome pane.

00:40:10.420 --> 00:40:13.830
So this allows you to play
around with the fragment shader

00:40:13.830 --> 00:40:17.630
and then, in this
case, the FPS is

00:40:17.630 --> 00:40:19.830
red to signal that
there's a compile error.

00:40:19.830 --> 00:40:21.430
You can look at your logs.

00:40:21.430 --> 00:40:23.751
You see which line, what
exactly you did wrong.

00:40:23.751 --> 00:40:25.750
You start editing and you
fix it really quickly.

00:40:25.750 --> 00:40:28.110
So that allows you to start
experimenting with shaders

00:40:28.110 --> 00:40:30.370
in a way that you probably
would have never done

00:40:30.370 --> 00:40:34.890
if you were just rebuilding
the APK every 10 minutes.

00:40:34.890 --> 00:40:37.700
Hopefully, we should
see the results of this,

00:40:37.700 --> 00:40:41.200
so I'm going to-- I'll just
let it run until it's done.

00:40:41.200 --> 00:40:44.090
So now, all of a sudden, we
just have this flat, polka dot

00:40:44.090 --> 00:40:45.240
pattern appearing here.

00:40:45.240 --> 00:40:46.910
So what's going on?

00:40:46.910 --> 00:40:49.429
So, it's really more of
a thought experiment,

00:40:49.429 --> 00:40:51.720
but I just wanted to introduce
the audience to the idea

00:40:51.720 --> 00:40:54.450
that there's something called
distance functions that

00:40:54.450 --> 00:40:57.870
allow you to play
around with flat space.

00:40:57.870 --> 00:41:00.850
So, in this case, we're
actually ignoring anything 3D.

00:41:00.850 --> 00:41:02.470
We're just rendering
these circles

00:41:02.470 --> 00:41:05.760
based on where we are
in the rendering pass,

00:41:05.760 --> 00:41:08.520
because a fragment shader
knows where on screen it is.

00:41:08.520 --> 00:41:11.560
So this allows you to do stuff
that's fairly interesting,

00:41:11.560 --> 00:41:14.620
and this is an example of such.

00:41:14.620 --> 00:41:16.470
Valve has a really
nice research paper

00:41:16.470 --> 00:41:19.836
where they explain how to
use the texture system.

00:41:19.836 --> 00:41:21.960
Instead of actually applying
and sticking a texture

00:41:21.960 --> 00:41:24.360
onto a triangle,
what they do is they

00:41:24.360 --> 00:41:27.950
take a high res texture
here-- like 4k by 4k.

00:41:27.950 --> 00:41:31.150
They extract out of it a
distance field patch-- which

00:41:31.150 --> 00:41:32.649
is another texture, really.

00:41:32.649 --> 00:41:34.440
But they pass this to
your fragment shader,

00:41:34.440 --> 00:41:37.340
and this is only basically
telling the shader, OK,

00:41:37.340 --> 00:41:40.130
if you're at this point, you're
this far away from inside

00:41:40.130 --> 00:41:42.260
or outside the letter.

00:41:42.260 --> 00:41:44.330
And using that, they
basically managed

00:41:44.330 --> 00:41:47.990
to implement something that
looks like vector graphics,

00:41:47.990 --> 00:41:52.360
but is actually stored in a
64 by 64 bitmap-- or texture,

00:41:52.360 --> 00:41:53.360
I should say.

00:41:53.360 --> 00:41:56.516
So, this is just to introduce
you to the idea that you can--

00:41:56.516 --> 00:41:58.390
once you start programming
your own pipeline,

00:41:58.390 --> 00:42:00.370
you can do very fancy
things, and there's

00:42:00.370 --> 00:42:02.580
a lot of people have done
a lot of fancy things,

00:42:02.580 --> 00:42:04.538
and research papers like
these you can actually

00:42:04.538 --> 00:42:06.640
look up on the internet
and they are very, very

00:42:06.640 --> 00:42:07.810
self-explanatory.

00:42:07.810 --> 00:42:12.980
You can apply all of this to
your programs in virtual space.

00:42:12.980 --> 00:42:16.180
This is a quick explanation
of the full screen

00:42:16.180 --> 00:42:18.450
fragment rendering trick.

00:42:18.450 --> 00:42:21.110
I'm going to not explain
it too, too much.

00:42:21.110 --> 00:42:24.280
But the idea here is that, if
you want to draw in flat space

00:42:24.280 --> 00:42:26.610
and only use the
fragment shader,

00:42:26.610 --> 00:42:30.084
you just need to put up
a full surface on screen.

00:42:30.084 --> 00:42:32.500
Like, you put up two triangles
that fill up the whole view

00:42:32.500 --> 00:42:34.479
screen, and you can
start playing around

00:42:34.479 --> 00:42:35.520
with the fragment shader.

00:42:35.520 --> 00:42:38.520
You might be saying,
well, what does that do?

00:42:38.520 --> 00:42:41.030
What can I do that's kind
of interesting with that?

00:42:41.030 --> 00:42:44.380
And, here, I'm going to
encourage you to go and look

00:42:44.380 --> 00:42:45.880
at Shardertoy.

00:42:45.880 --> 00:42:48.300
Shadertoy is a fragment
editing website.

00:42:48.300 --> 00:42:58.520
Basically with the WebGL APIs,
they abuse fragment shaders

00:42:58.520 --> 00:43:01.319
in an awesome way-- and
not just one awesome way.

00:43:01.319 --> 00:43:03.110
If you go there, you'll
get the source code

00:43:03.110 --> 00:43:04.410
for all these nice examples.

00:43:04.410 --> 00:43:06.370
If you actually
visit this web page,

00:43:06.370 --> 00:43:08.710
you'll see that all these
things are animated,

00:43:08.710 --> 00:43:11.450
and you can just
learn from the best

00:43:11.450 --> 00:43:14.170
and reuse that stuff
in your own examples.

00:43:14.170 --> 00:43:16.994
Like, you can see that there's
actual worlds being built here.

00:43:16.994 --> 00:43:18.660
You might be wondering,
how the hell can

00:43:18.660 --> 00:43:21.010
you do geometry if you're
just drawing pixels?

00:43:21.010 --> 00:43:22.181
How does that work?

00:43:22.181 --> 00:43:24.430
They're not even putting
geometries in these examples.

00:43:24.430 --> 00:43:26.110
It's two triangles
we're looking at.

00:43:28.649 --> 00:43:30.190
You're going to have
to explore that.

00:43:30.190 --> 00:43:32.610
Explore something called ray
marching, or come see me after.

00:43:32.610 --> 00:43:34.340
I'll give you the links to
the papers, because we're

00:43:34.340 --> 00:43:36.180
short on time and we
won't talk about that.

00:43:36.180 --> 00:43:37.043
Actually over time.

00:43:37.043 --> 00:43:37.543
Oh my God.

00:43:37.543 --> 00:43:38.980
Am I good?

00:43:38.980 --> 00:43:40.957
Well, kick me out
if I'm rambling.

00:43:40.957 --> 00:43:43.290
All right, so, one of the
things I want to point out too

00:43:43.290 --> 00:43:46.680
is they can do a search
for something called 2TC

00:43:46.680 --> 00:43:47.870
in Shadertoy.

00:43:47.870 --> 00:43:49.800
This is just to
impress everybody.

00:43:49.800 --> 00:43:52.640
They organized what was
called a two tweet contest.

00:43:52.640 --> 00:43:55.510
So the concept of
the two tweet contest

00:43:55.510 --> 00:44:00.950
is, you have however many
characters fit in two tweets,

00:44:00.950 --> 00:44:04.430
and that's how big your
shader can be-- text wise.

00:44:04.430 --> 00:44:08.640
So all these shaders
fit within two tweets.

00:44:08.640 --> 00:44:11.722
Whitespaces and
comments don't count.

00:44:11.722 --> 00:44:13.180
And these are all,
again, animated.

00:44:13.180 --> 00:44:15.030
If you just do that search
and go look that up.

00:44:15.030 --> 00:44:17.000
And all this stuff is
online, and the shaders

00:44:17.000 --> 00:44:20.270
are public, so you can learn
really interesting tricks.

00:44:20.270 --> 00:44:23.320
And if you start thinking this
way, it's not actually so hard,

00:44:23.320 --> 00:44:25.540
and I've done a few
proof of concepts

00:44:25.540 --> 00:44:28.130
where you can create,
say, 3D fractals

00:44:28.130 --> 00:44:32.940
and apply the VR
angle to it as well.

00:44:32.940 --> 00:44:35.990
So when you do that, you end up
creating spaces that are really

00:44:35.990 --> 00:44:36.970
interesting to explore.

00:44:36.970 --> 00:44:41.110
And the major point here
is that that's not so

00:44:41.110 --> 00:44:41.930
many lines of code.

00:44:41.930 --> 00:44:43.930
Once you grok how
this stuff works,

00:44:43.930 --> 00:44:46.030
you can be hyper
efficient and come up

00:44:46.030 --> 00:44:48.270
with incredible effects.

00:44:48.270 --> 00:44:51.040
And you don't have to have a
production crew next to you,

00:44:51.040 --> 00:44:52.870
spending hundreds
of dollars an hour

00:44:52.870 --> 00:44:54.587
to come up all
those nice assets.

00:44:54.587 --> 00:44:55.545
You can do it yourself.

00:44:58.320 --> 00:44:59.230
I'm almost done here.

00:44:59.230 --> 00:45:00.700
I just wanted to-- actually, no.

00:45:00.700 --> 00:45:01.910
We're skipping over those.

00:45:01.910 --> 00:45:04.170
All right, VR challenges.

00:45:04.170 --> 00:45:07.560
I'll take two minutes just to
overview the small problems

00:45:07.560 --> 00:45:08.370
with the platform.

00:45:08.370 --> 00:45:11.910
So, Cardboard--
that's awesome, right?

00:45:11.910 --> 00:45:14.220
But you might see where
I'm going with that.

00:45:14.220 --> 00:45:16.290
It's slightly problematic.

00:45:16.290 --> 00:45:17.410
That can be a drawback.

00:45:17.410 --> 00:45:19.580
It's not necessarily only
a drawback, but, you know.

00:45:19.580 --> 00:45:21.830
The other thing too we have
to think about when you're

00:45:21.830 --> 00:45:23.246
designing apps
with this, you only

00:45:23.246 --> 00:45:26.880
have one clicker-- in some cases
you don't have one at all--

00:45:26.880 --> 00:45:28.580
and you have to design for that.

00:45:28.580 --> 00:45:31.420
That's slightly
problematic as well.

00:45:31.420 --> 00:45:34.097
You can get creative and
start doing tilt-to-exit.

00:45:34.097 --> 00:45:35.180
So, that's not a bad idea.

00:45:35.180 --> 00:45:37.650
So, you can take examples
from the best apps out there

00:45:37.650 --> 00:45:40.600
and start implementing
them on your own.

00:45:40.600 --> 00:45:42.680
You have to start thinking
about head tracking.

00:45:42.680 --> 00:45:44.720
It's a super rich
source of information.

00:45:44.720 --> 00:45:47.350
You can do all sorts of
very interesting experiments

00:45:47.350 --> 00:45:48.240
with that.

00:45:48.240 --> 00:45:50.710
I've heard of a start up
that recently got finance

00:45:50.710 --> 00:45:53.810
in Montreal, and all
they do is run analytics

00:45:53.810 --> 00:45:56.845
to see where you're looking at
in the scene, where the head

00:45:56.845 --> 00:45:58.460
tracking is going,
what's interesting,

00:45:58.460 --> 00:46:01.350
and they're going to
resell that to advertisers.

00:46:01.350 --> 00:46:03.740
There's fun stuff
you can do there.

00:46:03.740 --> 00:46:08.237
Immersive audio-- if anybody
went to the HTC Vive try-out,

00:46:08.237 --> 00:46:09.570
you know what I'm talking about.

00:46:09.570 --> 00:46:11.980
It puts you into a
scene so much more.

00:46:11.980 --> 00:46:13.390
The slight con
there is that it's

00:46:13.390 --> 00:46:14.677
Cardboard we're talking about.

00:46:14.677 --> 00:46:16.260
Not everybody's going
to take the time

00:46:16.260 --> 00:46:18.012
to put on headphones
just for your app.

00:46:18.012 --> 00:46:19.720
So you have to be a
pretty compelling app

00:46:19.720 --> 00:46:21.790
to actually get somewhere.

00:46:21.790 --> 00:46:24.380
Some pitfalls of the
platform-- so it's

00:46:24.380 --> 00:46:27.340
food for thought for designing
your own apps, again, so some

00:46:27.340 --> 00:46:30.220
of the things that don't work
all that great-- centering

00:46:30.220 --> 00:46:31.680
and drift.

00:46:31.680 --> 00:46:33.737
So you can try any
Cardboard app a long

00:46:33.737 --> 00:46:35.820
while enough, especially
if you have a unit that's

00:46:35.820 --> 00:46:37.730
strapped to your head, you're
going to notice that you start

00:46:37.730 --> 00:46:40.080
off the game sitting this
way and at some point

00:46:40.080 --> 00:46:41.530
you're like, wait a minute,
I'm sitting to the side.

00:46:41.530 --> 00:46:43.430
I'm still looking
forward in the game.

00:46:43.430 --> 00:46:45.050
What's going on?

00:46:45.050 --> 00:46:48.360
And nobody seems to
think that maybe there

00:46:48.360 --> 00:46:50.972
should be some sort
of re-center switch,

00:46:50.972 --> 00:46:52.805
because, again, you're
sitting in your sofa.

00:46:56.290 --> 00:46:59.030
Your range of motion is
basically-- well, it's not nil,

00:46:59.030 --> 00:47:00.582
but it's very, very limited.

00:47:00.582 --> 00:47:01.540
So what's the solution?

00:47:01.540 --> 00:47:04.180
You suggest to people to
sit in a swivel chair?

00:47:04.180 --> 00:47:07.220
I guess that works,
although kind of gets tricky

00:47:07.220 --> 00:47:08.840
if you're alone
at home and, where

00:47:08.840 --> 00:47:10.200
did I put that glass again?

00:47:10.200 --> 00:47:12.670
Where's my coffee?

00:47:12.670 --> 00:47:14.960
Standing up with
Cardboard, actually,

00:47:14.960 --> 00:47:17.390
this is why I think it's
getting more clever in the way

00:47:17.390 --> 00:47:19.240
that they put it, then the
way they have to hold it,

00:47:19.240 --> 00:47:21.198
because when you're
standing up, you can't just

00:47:21.198 --> 00:47:23.200
flail around and whack
people in the head.

00:47:23.200 --> 00:47:25.636
So that's kind of interesting.

00:47:25.636 --> 00:47:28.380
The problem there though
is that your reflex to move

00:47:28.380 --> 00:47:31.360
is ingrained, like if
you're standing up,

00:47:31.360 --> 00:47:33.832
I am sure that you're
going to drift.

00:47:33.832 --> 00:47:35.540
For having tried it,
I can't help myself.

00:47:35.540 --> 00:47:37.498
At some point I just take
it off and, oh, crap,

00:47:37.498 --> 00:47:41.160
I'm three feet this way.

00:47:41.160 --> 00:47:42.830
So, what else?

00:47:42.830 --> 00:47:45.250
Guided experiences.

00:47:45.250 --> 00:47:48.620
Since your audience is captive,
you can guide their experience.

00:47:48.620 --> 00:47:51.210
So these are screenshots from
a lot of well-known things,

00:47:51.210 --> 00:47:54.030
I think, but just to
go over them again.

00:47:54.030 --> 00:47:58.250
So this is from Expeditions.

00:47:58.250 --> 00:48:01.230
So, over-ear headphones,
no distractions.

00:48:01.230 --> 00:48:04.000
So that's kind of interesting
if, in the case of Expeditions

00:48:04.000 --> 00:48:06.890
for example, the
students wear headphones

00:48:06.890 --> 00:48:09.460
so that they are not
distracted by the others

00:48:09.460 --> 00:48:11.040
and follow instructions more.

00:48:11.040 --> 00:48:12.980
And the instructor
has the microphone

00:48:12.980 --> 00:48:16.779
that can feed into
everybody's head, basically.

00:48:16.779 --> 00:48:17.820
You can guide your group.

00:48:17.820 --> 00:48:20.920
You can point big arrows at--
let's say-- where to look at.

00:48:20.920 --> 00:48:22.412
And what I've just
shown you, you

00:48:22.412 --> 00:48:23.870
should see that
I've just given you

00:48:23.870 --> 00:48:28.240
tools that allow you to publish
live to a huge group of people

00:48:28.240 --> 00:48:30.170
anything, basically, you want.

00:48:30.170 --> 00:48:33.280
So there's a pretty powerful
combination in there,

00:48:33.280 --> 00:48:36.340
and, again, it's with tools that
don't require a big production

00:48:36.340 --> 00:48:40.850
crew behind you to get
to somewhere interesting.

00:48:40.850 --> 00:48:44.120
The advantages with Cardboard--
back to reality is really easy.

00:48:44.120 --> 00:48:47.720
You don't have to strap
the thing off your head.

00:48:47.720 --> 00:48:50.414
Scripting-- so like Windy Day
with the little mouse there,

00:48:50.414 --> 00:48:51.830
everybody has
probably tried this.

00:48:51.830 --> 00:48:53.700
It has scripted actions.

00:48:53.700 --> 00:48:55.520
So it's being clever
in its use of,

00:48:55.520 --> 00:48:56.830
OK the user's actually looking.

00:48:56.830 --> 00:48:58.920
Now I can do something.

00:48:58.920 --> 00:49:00.650
These are all
considerations that you

00:49:00.650 --> 00:49:02.910
have to look into when
you're designing an app.

00:49:02.910 --> 00:49:04.860
Another thing I'd
recommend is, there's

00:49:04.860 --> 00:49:08.330
an actual design
pattern app from Google

00:49:08.330 --> 00:49:09.810
that you should really look at.

00:49:09.810 --> 00:49:11.900
That's very compelling and
it has some very clever ideas

00:49:11.900 --> 00:49:12.858
of where you should go.

00:49:15.470 --> 00:49:17.140
Almost done, two slides.

00:49:17.140 --> 00:49:19.970
I'm a bit over, but nobody
hates me, so that's good.

00:49:19.970 --> 00:49:22.262
Time for an upgrade.

00:49:22.262 --> 00:49:24.595
So this is the point where
you go, OK, Cardboard's nice,

00:49:24.595 --> 00:49:27.210
but I'd like to
make a proper set.

00:49:27.210 --> 00:49:29.180
So what can you do?

00:49:29.180 --> 00:49:31.410
So we have IonVR, our
sponsor at the barbecue.

00:49:31.410 --> 00:49:33.520
I tried their unit, really nice.

00:49:33.520 --> 00:49:36.222
The production units, I think,
should be very promising.

00:49:36.222 --> 00:49:38.430
I'm really looking forward
to what they come up with.

00:49:38.430 --> 00:49:39.721
Probably it's going to be soon.

00:49:46.780 --> 00:49:48.530
The Oculus gear
is actually super

00:49:48.530 --> 00:49:50.466
compelling for having tried it.

00:49:50.466 --> 00:49:52.840
The big advantage here is that
they put the touchpad here

00:49:52.840 --> 00:49:54.780
so you can interact
with your world.

00:49:54.780 --> 00:49:58.130
So that's very much
a must, and something

00:49:58.130 --> 00:49:59.540
very much lacking in Cardboard.

00:49:59.540 --> 00:50:01.870
Like this default
sort of platform,

00:50:01.870 --> 00:50:03.850
I want to interact
with the world.

00:50:03.850 --> 00:50:07.440
The Homido is actually a
very good headset as well,

00:50:07.440 --> 00:50:10.230
and they have an offer
for a Bluetooth remote

00:50:10.230 --> 00:50:14.900
that can be used, so that
for users can be interesting.

00:50:14.900 --> 00:50:18.110
Android Wear-- I'm not
sharing this with you yet,

00:50:18.110 --> 00:50:20.119
but eventually on the
example code side,

00:50:20.119 --> 00:50:21.910
there's going to be a
proof of concept I've

00:50:21.910 --> 00:50:23.500
built with Android
Wear where, instead

00:50:23.500 --> 00:50:25.260
of having to touch
your temple, you're

00:50:25.260 --> 00:50:26.950
going to touch your watch.

00:50:26.950 --> 00:50:29.120
And you can easily feed
events-- touch events--

00:50:29.120 --> 00:50:31.930
into your Cardboard app
when the watch is hooked up.

00:50:31.930 --> 00:50:33.440
It's actually super compelling.

00:50:33.440 --> 00:50:34.940
It's got some
interesting use-- seem

00:50:34.940 --> 00:50:38.430
like an interesting dynamics
because your hands are

00:50:38.430 --> 00:50:40.180
trapped when you do this.

00:50:40.180 --> 00:50:42.570
So you lose the
risk that the user

00:50:42.570 --> 00:50:45.930
is going to flail that hot
cup of coffee into the dog

00:50:45.930 --> 00:50:47.220
or whatever.

00:50:47.220 --> 00:50:49.230
So those are thoughts.

00:50:49.230 --> 00:50:52.990
Another thought here is that--
unless they've changed it

00:50:52.990 --> 00:50:54.540
in recent months--
as far as I know,

00:50:54.540 --> 00:50:57.210
if you sell physical
goods from an application,

00:50:57.210 --> 00:50:58.480
nobody takes a cut.

00:50:58.480 --> 00:51:04.140
That's true I believe from
Google Play and the Apple

00:51:04.140 --> 00:51:04.846
store.

00:51:04.846 --> 00:51:06.220
So that can always
be interesting

00:51:06.220 --> 00:51:08.510
if you want your users to
support Cardboard first,

00:51:08.510 --> 00:51:10.760
and if you want your users
to have the full experience

00:51:10.760 --> 00:51:13.210
and you can actually
upsell them on it,

00:51:13.210 --> 00:51:14.402
you can make money that way.

00:51:14.402 --> 00:51:16.110
That could be interesting,
because we all

00:51:16.110 --> 00:51:17.610
know selling apps
is not necessarily

00:51:17.610 --> 00:51:19.470
an easy proposition sometimes.

00:51:19.470 --> 00:51:22.710
So, that's one factor
you could consider,

00:51:22.710 --> 00:51:24.607
which is what this slide
was actually about.

00:51:24.607 --> 00:51:25.690
Sorry, I went ahead there.

00:51:25.690 --> 00:51:27.190
All right, I'm done.

00:51:27.190 --> 00:51:28.070
Thank you so much.

00:51:28.070 --> 00:51:30.700
I appreciate you being here.

