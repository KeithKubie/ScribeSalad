WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.160
This is a certificate from the Guinness World Records.

00:00:03.160 --> 00:00:05.440
It's for the largest functional microprocessor model

00:00:05.440 --> 00:00:08.040
which has 42,370 transistors

00:00:08.060 --> 00:00:11.000
and built by James Newman in the UK in Cambridge.

00:00:11.080 --> 00:00:13.800
And this is the mega processor.

00:00:16.160 --> 00:00:18.900
It's basically a micro processor

00:00:18.900 --> 00:00:21.040
made purely from transistors.

00:00:21.040 --> 00:00:22.860
And we're talking discrete transistors,

00:00:22.860 --> 00:00:24.940
the ones the ones that you can handle,

00:00:24.940 --> 00:00:26.260
not sort of the ones that are

00:00:26.260 --> 00:00:27.460
in the silicon chips we know.

00:00:27.460 --> 00:00:29.280
So it's a fully functional machine.

00:00:29.280 --> 00:00:32.240
It's made of these panels as you see

00:00:32.240 --> 00:00:33.800
around the room here.

00:00:33.800 --> 00:00:34.920
Each panel has its own

00:00:34.920 --> 00:00:37.660
specific function within the processor.

00:00:37.660 --> 00:00:39.540
So the memory is made of all these

00:00:39.540 --> 00:00:41.790
little transistors here, as the rest is,

00:00:41.790 --> 00:00:44.250
but each one has an LED on it as well.

00:00:44.250 --> 00:00:46.080
So the important thing about the mega processor

00:00:46.080 --> 00:00:48.160
is every single part of the machine,

00:00:48.160 --> 00:00:49.560
every single gate

00:00:49.560 --> 00:00:51.540
has an LED on its input and output,

00:00:51.540 --> 00:00:54.920
so you can see all the data everywhere in the machine,

00:00:54.920 --> 00:00:56.620
and actually how it's working as well.

00:00:56.620 --> 00:00:58.500
The memory actually kind of then functions

00:00:58.500 --> 00:00:59.800
a little bit more as a screen.

00:00:59.820 --> 00:01:02.020
So we have here a game of Tetris

00:01:02.020 --> 00:01:03.460
that's playing on there at the moment,

00:01:03.460 --> 00:01:04.760
we'll show you that in a minute.

00:01:04.760 --> 00:01:06.140
So we have the state machine,

00:01:06.140 --> 00:01:07.660
all computers have a state machine

00:01:07.660 --> 00:01:09.680
so it knows what it's doing at any one given time.

00:01:09.680 --> 00:01:12.420
All of the instruction decoding

00:01:12.420 --> 00:01:14.460
and the branch calculations, all that kind of thing,

00:01:14.460 --> 00:01:16.220
are done on these ones here.

00:01:16.840 --> 00:01:19.060
This panel is the special purpose registers.

00:01:19.060 --> 00:01:21.100
Arithmetic and logic control, the ALU,

00:01:21.100 --> 00:01:23.880
again the ALU part of all processors.

00:01:23.880 --> 00:01:26.320
So it has two "adders" in this machine

00:01:26.320 --> 00:01:27.660
adder 1, adder 2 there.

00:01:27.660 --> 00:01:29.980
And then the ALU control down the bottom.

00:01:29.980 --> 00:01:32.880
General purpose registers, so as you make a move

00:01:32.880 --> 00:01:34.420
you would move it to register one,

00:01:34.440 --> 00:01:36.420
and then out to maybe a special purpose register

00:01:36.420 --> 00:01:37.680
or memory depending on

00:01:37.680 --> 00:01:40.520
what operations you're doing.

00:01:40.520 --> 00:01:42.420
So all of this together

00:01:42.760 --> 00:01:45.080
forms effectively a microprocessor.

00:01:45.080 --> 00:01:47.100
So we have a number of LEDs okay,

00:01:47.100 --> 00:01:48.640
and you can see these LEDs are on.

00:01:48.640 --> 00:01:51.580
But if we focus in on just one little bit here,

00:01:51.580 --> 00:01:54.280
those five transistors make it an AND gate.

00:01:54.280 --> 00:01:56.820
So all of that lot is just one AND gate.

00:01:56.820 --> 00:01:58.900
And we can see on the two inputs to the AND

00:01:58.900 --> 00:02:01.860
we have one is on, one is off, the output is off.

00:02:01.860 --> 00:02:04.080
So for an AND gate the logic says:

00:02:04.440 --> 00:02:07.260
both inputs 1 and 2 have to be on.

00:02:07.520 --> 00:02:08.760
Okay, so that's the function,

00:02:08.760 --> 00:02:10.300
so we haven't, we've only got one of them on

00:02:10.300 --> 00:02:11.600
therefore the output is off.

00:02:11.600 --> 00:02:13.580
And this is just multiplied up.

00:02:13.580 --> 00:02:15.840
The whole system is using this kind of function.

00:02:15.840 --> 00:02:19.080
AND gates, OR gates, and XORs

00:02:19.080 --> 00:02:21.080
and various then combination of those.

00:02:21.700 --> 00:02:22.920
You can use,

00:02:22.920 --> 00:02:25.740
turn an AND gate into an inverter

00:02:25.740 --> 00:02:28.180
which some of them are done down there.

00:02:28.180 --> 00:02:29.980
And a microprocessor is just that.

00:02:29.980 --> 00:02:31.440
What we've got here is a machine

00:02:31.440 --> 00:02:33.320
that looks like it's not doing very much,

00:02:33.320 --> 00:02:35.800
it's kind of fairly static.

00:02:37.000 --> 00:02:39.260
But we have a special control over here,

00:02:39.760 --> 00:02:44.140
a huge rheostat out of some kind of 40's science film.

00:02:44.140 --> 00:02:44.940
What we can do,

00:02:44.940 --> 00:02:47.800
it's actually running at about 19 kilohertz at the minute.

00:02:47.800 --> 00:02:49.040
But we can slow it down.

00:02:49.040 --> 00:02:51.440
13 ... 10 ... 7 kilohertz.

00:02:51.440 --> 00:02:52.740
And as we slow it down

00:02:52.820 --> 00:02:54.140
we start to see

00:02:54.360 --> 00:02:55.280
the LEDs

00:02:55.520 --> 00:02:56.560
flickering a little bit.

00:02:56.560 --> 00:02:57.800
There's a little bit of flicker.

00:02:57.800 --> 00:02:59.860
So now we're at about 100 hertz

00:02:59.860 --> 00:03:01.900
and as we come down further ...

00:03:01.900 --> 00:03:03.060
10 Hertz ...

00:03:03.060 --> 00:03:05.920
Right. And now we're down at about roughly 2 hertz.

00:03:05.920 --> 00:03:07.660
So now we can start to see

00:03:08.160 --> 00:03:10.520
the individual instructions being operated.

00:03:10.520 --> 00:03:11.700
So again,

00:03:12.120 --> 00:03:13.200
it's running Tetris at the moment.

00:03:13.200 --> 00:03:15.020
It's actually in it's "Game Over" state.

00:03:15.600 --> 00:03:17.020
So at first the machine looked like

00:03:17.020 --> 00:03:17.900
it wasn't doing anything.

00:03:18.200 --> 00:03:19.580
But when we slow it down

00:03:19.580 --> 00:03:21.460
we see actually it is doing something.

00:03:21.460 --> 00:03:23.740
And one of our special purpose registers

00:03:24.380 --> 00:03:25.940
is the "Program Counter".

00:03:25.940 --> 00:03:28.380
So this is the part of the machine

00:03:28.380 --> 00:03:30.940
that keeps track of what instruction is being executed.

00:03:30.960 --> 00:03:33.000
[Sean] That's the PC there yeah?
[Jason] Yeah, "Program Counter".

00:03:33.000 --> 00:03:33.500
What we've got,

00:03:33.500 --> 00:03:34.200
we've got the binary:

00:03:34.200 --> 00:03:36.900
this is what's going on to the computer itself.

00:03:36.900 --> 00:03:38.520
But for us we've got a little display here

00:03:38.520 --> 00:03:40.720
that allows us to interpret that a little bit easier.

00:03:40.720 --> 00:03:42.955
So we can see that the instructions

00:03:42.960 --> 00:03:46.040
at memory locations 131 to 137

00:03:46.660 --> 00:03:48.720
are just going round and round in a loop.

00:03:49.360 --> 00:03:50.200
So even though the machine

00:03:50.200 --> 00:03:51.260
looked like it was doing nothing,

00:03:51.660 --> 00:03:53.400
it's running this little program

00:03:53.400 --> 00:03:54.880
between 131 and 137.

00:03:54.880 --> 00:03:55.940
And what that's saying

00:03:56.300 --> 00:03:56.800
is ...

00:03:57.220 --> 00:03:57.960
check out

00:03:58.580 --> 00:03:59.540
the peripheral input,

00:03:59.700 --> 00:04:00.500
the inputs here.

00:04:00.780 --> 00:04:02.440
So between 131 and 137

00:04:02.440 --> 00:04:03.600
it's just basically saying,

00:04:03.640 --> 00:04:04.640
"Is that button pressed?"

00:04:04.640 --> 00:04:06.420
So it just sits there in that loop.

00:04:06.420 --> 00:04:07.920
If I speed up a little bit

00:04:07.920 --> 00:04:09.220
and I now press that button,

00:04:10.140 --> 00:04:12.560
our program counter now shoots off.

00:04:12.860 --> 00:04:13.980
Let's slow it down again.

00:04:14.240 --> 00:04:15.720
So now we're in a different part of memory

00:04:16.040 --> 00:04:16.900
doing another operation.

00:04:16.900 --> 00:04:18.280
And you can see on the screen,

00:04:18.280 --> 00:04:20.080
so if I speed up the operations now,

00:04:20.460 --> 00:04:21.620
You can see that it's basically

00:04:21.620 --> 00:04:24.140
very very slowly clearing the screen.

00:04:24.700 --> 00:04:25.960
So the part of the program

00:04:25.960 --> 00:04:26.780
that is operating at the moment

00:04:26.780 --> 00:04:28.420
is just the "clear screen" operation.

00:04:28.420 --> 00:04:29.560
And I could speed that up,

00:04:30.340 --> 00:04:31.620
take it up to ...

00:04:33.100 --> 00:04:34.520
[Sean] And now it's playing the game again.

00:04:34.520 --> 00:04:35.800
[Jason] And now it's playing the game again.

00:04:35.800 --> 00:04:37.020
But again slowing it down,

00:04:37.020 --> 00:04:38.960
you can see just how long it takes to draw

00:04:39.420 --> 00:04:41.020
and calculate those pieces.

00:04:41.620 --> 00:04:43.020
So to update the screen

00:04:43.020 --> 00:04:45.460
there is a whole load of code that's being operated

00:04:45.460 --> 00:04:47.140
just to move that piece down the screen.

00:04:47.140 --> 00:04:48.820
And then we can speed it up, and now

00:04:49.120 --> 00:04:50.580
we have a kind of a functional game.

00:04:50.580 --> 00:04:51.640
It is going to slow obviously

00:04:51.640 --> 00:04:53.240
it's not very playable.

00:04:54.800 --> 00:04:56.140
And it can look at the inputs.

00:04:57.620 --> 00:04:59.960
And you can see how the controller here,

00:05:00.220 --> 00:05:00.920
as we move it,

00:05:01.200 --> 00:05:02.700
changes the LEDs.

00:05:02.700 --> 00:05:03.740
You've got the two inputs there.

00:05:03.740 --> 00:05:05.960
The button presses cause other

00:05:05.960 --> 00:05:08.200
inputs, and it is watching those all the time.

00:05:08.200 --> 00:05:09.940
James Newman, the madman that created it,

00:05:11.140 --> 00:05:12.800
really wanted to be able to

00:05:12.800 --> 00:05:14.520
shrink people down put them inside a computer

00:05:14.520 --> 00:05:15.820
just to be able to see how it works.

00:05:16.200 --> 00:05:17.040
That's really hard

00:05:18.120 --> 00:05:18.680
apparently.

00:05:19.080 --> 00:05:19.720
So

00:05:19.900 --> 00:05:21.060
he scaled up the processor,

00:05:21.060 --> 00:05:23.460
so allowed us to get inside, it as it were.

00:05:23.460 --> 00:05:25.020
So the idea is here,

00:05:25.020 --> 00:05:26.460
that this is an educational thing.

00:05:26.460 --> 00:05:28.640
This is the best way for anybody

00:05:28.880 --> 00:05:30.640
to understand things, simple stuff like

00:05:30.640 --> 00:05:33.080
the "fetch and execute cycle" of a computer.

00:05:33.080 --> 00:05:34.240
How this stuff works.

00:05:34.820 --> 00:05:36.900
So this is fantastic because what it allows us to do,

00:05:37.140 --> 00:05:39.360
if we halt the machine,

00:05:39.500 --> 00:05:40.260
we can now

00:05:40.420 --> 00:05:41.380
stop the processor

00:05:41.580 --> 00:05:43.100
and we can single step through

00:05:43.240 --> 00:05:43.740
every

00:05:43.900 --> 00:05:44.620
instruction.

00:05:44.820 --> 00:05:46.160
So every time we press

00:05:46.260 --> 00:05:47.060
the step button,

00:05:49.220 --> 00:05:50.500
we can now see

00:05:50.500 --> 00:05:51.860
the operations and the data

00:05:51.860 --> 00:05:53.480
moving around the system.

00:05:53.480 --> 00:05:54.840
[Sean] I'm just going to darken the camera

00:05:54.840 --> 00:05:56.260
so we can see the LEDs now

00:05:56.260 --> 00:05:57.280
but we might not see you.

00:05:57.780 --> 00:05:59.200
[Jason] And it's not necessarily

00:05:59.380 --> 00:06:01.380
one press per instruction.

00:06:01.380 --> 00:06:02.640
Some of these instructions take

00:06:02.780 --> 00:06:04.440
a number of clock cycles to operate.

00:06:05.160 --> 00:06:07.960
So a "divide" could take 16 clock cycles

00:06:08.100 --> 00:06:09.900
other instructions take less time.

00:06:10.780 --> 00:06:12.920
But we can see how that instruction is broken up.

00:06:13.160 --> 00:06:14.040
Step it through

00:06:14.040 --> 00:06:14.880
just to see

00:06:14.980 --> 00:06:17.240
how that data moves around the processor.

00:06:18.140 --> 00:06:19.320
You can't do that in any other way.

00:06:19.320 --> 00:06:21.120
There is no way to get inside a processor

00:06:21.120 --> 00:06:22.040
and see this stuff happen.

00:06:22.040 --> 00:06:23.200
I programmed in assembly language

00:06:23.200 --> 00:06:25.700
on 8031 processors and things like that,

00:06:26.180 --> 00:06:27.940
and I thought I was fairly low level,

00:06:27.940 --> 00:06:29.540
you know "programming at the metal" as they say.

00:06:30.140 --> 00:06:31.860
But actually when you see these things being executed

00:06:31.860 --> 00:06:34.140
you realize how much extra stuff is going on

00:06:34.800 --> 00:06:36.740
that even you as a sort of a low-level coder

00:06:38.400 --> 00:06:39.620
don't even, you're not even aware of it.

00:06:39.620 --> 00:06:40.180
And it's ...

00:06:40.520 --> 00:06:41.920
these things work so hard

00:06:42.700 --> 00:06:43.660
to do the,

00:06:43.660 --> 00:06:44.800
what seems simple stuff.

00:06:45.000 --> 00:06:46.800
[Sean] I'm imagining this is a processor

00:06:46.800 --> 00:06:48.380
in some smartphone somewhere.

00:06:48.500 --> 00:06:50.220
How big do you think the screen would be?

00:06:50.780 --> 00:06:52.000
[Jason] um ... ah ... that's ...

00:06:52.000 --> 00:06:53.500
okay, so that's an interesting question.

00:06:53.500 --> 00:06:54.500
If this was the memory

00:06:54.500 --> 00:06:56.220
that you had in your mobile phone today,

00:06:56.980 --> 00:06:58.220
the average mobile phone

00:06:58.800 --> 00:06:59.300
with

00:06:59.480 --> 00:07:00.720
say, I don't know,

00:07:00.720 --> 00:07:01.900
a gig of RAM,

00:07:02.700 --> 00:07:03.360
this panel

00:07:03.540 --> 00:07:04.260
as the RAM

00:07:04.260 --> 00:07:05.840
would be twice the size of the United Kingdom.

00:07:05.840 --> 00:07:07.420
So it's fairly low density

00:07:08.420 --> 00:07:09.980
and fairly impractical.

00:07:09.980 --> 00:07:10.600
But,

00:07:10.600 --> 00:07:11.140
you know,

00:07:11.140 --> 00:07:13.480
you can't see what's going on in your mobile phone.

00:07:13.480 --> 00:07:13.980
So ...

00:07:13.980 --> 00:07:14.480
But

00:07:14.540 --> 00:07:15.380
actually,

00:07:15.960 --> 00:07:16.940
what we should say

00:07:17.220 --> 00:07:18.280
that a lot of people just assume

00:07:18.280 --> 00:07:20.280
this is something like a model of a 6502

00:07:20.280 --> 00:07:21.980
or a Z80 processor from the 80's.

00:07:22.680 --> 00:07:25.040
It's not actually necessarily based on any one processor.

00:07:25.660 --> 00:07:26.260
it kind of

00:07:26.520 --> 00:07:28.740
uses good ideas from a number of different processors.

00:07:29.020 --> 00:07:30.260
So for a start it has

00:07:30.820 --> 00:07:32.400
"hardware divide" built in.

00:07:32.400 --> 00:07:33.980
It's actually a 16-bit machine as well.

00:07:35.060 --> 00:07:35.680
So,

00:07:35.880 --> 00:07:37.340
really it's kind of a ...

00:07:37.340 --> 00:07:38.960
I don't know, it's hard to equate it.

00:07:38.960 --> 00:07:40.360
But it's kind of a mid 90's-ish,

00:07:40.600 --> 00:07:42.100
or early 90's maybe,

00:07:43.060 --> 00:07:44.580
kind of equivalent processor.

00:07:44.820 --> 00:07:45.600
So it's really

00:07:45.780 --> 00:07:47.000
quite a quite a beast

00:07:47.000 --> 00:07:49.380
when you consider this thing is all just transistors.

00:07:53.120 --> 00:07:56.940
[ ambient music fades in ... ]

