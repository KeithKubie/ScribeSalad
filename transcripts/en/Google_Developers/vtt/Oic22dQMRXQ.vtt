WEBVTT
Kind: captions
Language: en

00:00:05.550 --> 00:00:06.410
JAKE ARCHIBALD: Good
morning, everyone.

00:00:06.410 --> 00:00:11.140
Welcome to the offline
part of the day.

00:00:11.140 --> 00:00:14.570
So my involvement with all the
offline stuff started a year

00:00:14.570 --> 00:00:16.770
and a half ago when
I joined Lanyard.

00:00:16.770 --> 00:00:18.020
And when I joined Lanyard--

00:00:25.286 --> 00:00:27.270
so can everyone hear me?

00:00:27.270 --> 00:00:27.810
Right, OK.

00:00:27.810 --> 00:00:28.730
I'll stay at this level.

00:00:28.730 --> 00:00:31.050
So a year and a half ago,
I started at Lanyard.

00:00:31.050 --> 00:00:34.450
When I started, they were
building an iPhone app.

00:00:34.450 --> 00:00:36.560
And they were doing this mainly
just to get a presence

00:00:36.560 --> 00:00:40.080
in the App Store, but also
because it gave them the

00:00:40.080 --> 00:00:42.430
opportunity to make data
available offline.

00:00:42.430 --> 00:00:45.000
And offline is important to
conference delegates because

00:00:45.000 --> 00:00:47.720
you're quite often on a plane
on the way there, so you've

00:00:47.720 --> 00:00:49.350
mostly got no connection
there.

00:00:49.350 --> 00:00:52.030
Or when you arrive in a foreign
country, you might be

00:00:52.030 --> 00:00:53.280
data roaming.

00:00:53.280 --> 00:00:56.220
So we don't want you to have to
pay a lot of money just to

00:00:56.220 --> 00:00:59.420
find out where the conference
is or what the sessions are.

00:00:59.420 --> 00:01:02.510
And even when you're at the
conference, obviously

00:01:02.510 --> 00:01:04.400
conferences have Wi-Fi.

00:01:04.400 --> 00:01:06.600
But it's a special brand of
Wi-Fi known as conference

00:01:06.600 --> 00:01:09.440
Wi-Fi, which is like Wi-Fi,
but it doesn't work.

00:01:09.440 --> 00:01:11.000
So you can't rely on
the connection.

00:01:11.000 --> 00:01:13.260
But obviously not everyone
has an iPhone.

00:01:13.260 --> 00:01:15.950
People have lots of different
kinds of devices.

00:01:15.950 --> 00:01:18.390
And we wanted Lanyard to
work on there as well.

00:01:18.390 --> 00:01:21.960
But most of these, quite a few
of these don't have an app

00:01:21.960 --> 00:01:24.130
platform, and we didn't have the
resource to go and build

00:01:24.130 --> 00:01:25.320
apps for all of then either.

00:01:25.320 --> 00:01:28.190
So we wanted to make a web
version of the app, and that

00:01:28.190 --> 00:01:30.510
was what I was there to do.

00:01:30.510 --> 00:01:32.140
And when I was given this task,
I was like, well, I

00:01:32.140 --> 00:01:34.590
really want to work offline
work in the

00:01:34.590 --> 00:01:35.360
web version as well.

00:01:35.360 --> 00:01:38.970
And I had this recollection of
this thing called AppCache.

00:01:38.970 --> 00:01:41.500
And I went and did some
preliminary research into it.

00:01:41.500 --> 00:01:42.740
And it looked really good.

00:01:42.740 --> 00:01:44.890
I could just add a
reference to a

00:01:44.890 --> 00:01:46.920
manifest on the HTML elements.

00:01:46.920 --> 00:01:49.090
And I could just list
all the stuff that I

00:01:49.090 --> 00:01:50.980
want to work offline.

00:01:50.980 --> 00:01:52.580
And it works.

00:01:52.580 --> 00:01:55.534
And I could also capture a set
of URLs, like everything that

00:01:55.534 --> 00:01:58.560
begins with avatars-- images,
avatars-- and then say, well,

00:01:58.560 --> 00:02:00.900
if you're offline, I want you
to serve that instead.

00:02:00.900 --> 00:02:01.830
And I was like, wow,
this sounds like

00:02:01.830 --> 00:02:03.330
a really good solution.

00:02:03.330 --> 00:02:07.330
It seemed like the API was this
big, cuddly teddy bear.

00:02:07.330 --> 00:02:09.892
And I kind of ran up and I
hugged the teddy bear and

00:02:09.892 --> 00:02:12.400
thought, together, we're going
to get through this.

00:02:12.400 --> 00:02:15.620
We can make the web
work offline.

00:02:15.620 --> 00:02:18.340
Of course it soon became obvious
that the lovely teddy

00:02:18.340 --> 00:02:20.520
bear that I was cuddling
was filled with

00:02:20.520 --> 00:02:23.970
razor blades and bees.

00:02:23.970 --> 00:02:27.055
And I got stung many,
many times.

00:02:27.055 --> 00:02:29.080
And the razor blades
dug into my skin.

00:02:29.080 --> 00:02:31.800
And I got the whole alphabet
of hepatitis.

00:02:31.800 --> 00:02:35.630
And it was a really
nasty experience.

00:02:35.630 --> 00:02:39.100
So you hear the word "gotcha"
a lot with AppCache.

00:02:39.100 --> 00:02:44.142
And the spec does seem
to do the unexpected.

00:02:44.142 --> 00:02:46.100
MALE SPEAKER: I think
your mic is on.

00:02:46.100 --> 00:02:46.620
JAKE ARCHIBALD: Ah, yeah.

00:02:46.620 --> 00:02:47.160
That would help.

00:02:47.160 --> 00:02:49.710
OK.

00:02:49.710 --> 00:02:50.820
Oh, that's nicer.

00:02:50.820 --> 00:02:55.330
OK, so when something is cached,
it will always come

00:02:55.330 --> 00:02:56.240
from the cache.

00:02:56.240 --> 00:02:58.890
If the AppCache has something to
give you, it will serve it

00:02:58.890 --> 00:02:59.990
straight from the cache.

00:02:59.990 --> 00:03:02.580
And so even if you're online,
you're going to get those

00:03:02.580 --> 00:03:04.230
cached assets.

00:03:04.230 --> 00:03:07.150
And the cache is only updated
if the manifest file itself

00:03:07.150 --> 00:03:09.330
changes, just a character
changes, even if that

00:03:09.330 --> 00:03:11.610
character is inside a comment.

00:03:11.610 --> 00:03:14.490
And the cache only updates if
all of the things you listed

00:03:14.490 --> 00:03:15.105
downloads successfully.

00:03:15.105 --> 00:03:21.870
If one of them 404s or 500s,
then the whole thing fails.

00:03:21.870 --> 00:03:25.290
I started drawing this diagram
to try and make sense of what

00:03:25.290 --> 00:03:27.970
AppCache was actually doing,
what the flow of information

00:03:27.970 --> 00:03:29.240
was, how it worked.

00:03:29.240 --> 00:03:32.130
And I did some talks based on
this, and I'm showing this

00:03:32.130 --> 00:03:33.350
diagram, going, look--

00:03:33.350 --> 00:03:34.670
look how terrible
that cache is.

00:03:34.670 --> 00:03:37.440
Look how complicated it is.

00:03:37.440 --> 00:03:39.700
But if you think about some code
you've written recently--

00:03:39.700 --> 00:03:41.950
even something fairly simple,
like, I don't know, form

00:03:41.950 --> 00:03:43.720
validation--

00:03:43.720 --> 00:03:45.940
if you drew it as
a flow chart, it

00:03:45.940 --> 00:03:47.160
would look like this.

00:03:47.160 --> 00:03:49.330
It would look this complicated,
probably more

00:03:49.330 --> 00:03:50.800
complicated.

00:03:50.800 --> 00:03:52.260
And that doesn't
make it wrong.

00:03:52.260 --> 00:03:54.100
And that doesn't make it
difficult to read.

00:03:54.100 --> 00:03:56.820
And that doesn't make
it hard to maintain.

00:03:56.820 --> 00:03:59.110
A lot of the gotchas that
AppCache has are actually

00:03:59.110 --> 00:04:00.870
quite sensible.

00:04:00.870 --> 00:04:03.930
So the cache is used even if
you're online, and that

00:04:03.930 --> 00:04:05.985
happens because it's really,
really fast.

00:04:05.985 --> 00:04:07.640
The exception is in fallback.

00:04:07.640 --> 00:04:10.050
So if it tries to request an
avatar, it's going to go to

00:04:10.050 --> 00:04:10.730
the network.

00:04:10.730 --> 00:04:12.500
And it's only going to
serve this if the

00:04:12.500 --> 00:04:14.950
network request fails.

00:04:14.950 --> 00:04:17.975
And that's really quick, in this
case, because you can go

00:04:17.975 --> 00:04:19.570
and get the avatar from the
network, and that's going to

00:04:19.570 --> 00:04:20.500
be really fast.

00:04:20.500 --> 00:04:23.520
It's even faster in this case
because it's going to fail

00:04:23.520 --> 00:04:24.840
really, really quickly.

00:04:24.840 --> 00:04:26.760
And you'll get the fallback
avatar instead.

00:04:26.760 --> 00:04:28.860
The problem case is this,
which I like to

00:04:28.860 --> 00:04:30.630
call the real world.

00:04:30.630 --> 00:04:36.080
And when your phone's in this
kind of state, it's like a

00:04:36.080 --> 00:04:38.670
one-legged dog.

00:04:38.670 --> 00:04:44.010
It thinks it can still play
fetch, but it can't.

00:04:44.010 --> 00:04:47.790
And you have to watch it drag
itself along the floor with

00:04:47.790 --> 00:04:49.750
its one leg.

00:04:49.750 --> 00:04:51.160
And it's heartbreaking.

00:04:51.160 --> 00:04:52.850
And with your phone it's really,
really irritating.

00:04:52.850 --> 00:04:56.800
Because you know that on the
device, on there is the data

00:04:56.800 --> 00:04:59.100
that is good enough
for you right now.

00:04:59.100 --> 00:05:00.110
But it won't give you it.

00:05:00.110 --> 00:05:02.620
It has to wait for minutes
before it decides it really

00:05:02.620 --> 00:05:04.630
can't make this connection.

00:05:04.630 --> 00:05:06.990
The spec doesn't really mention
offline very much.

00:05:06.990 --> 00:05:08.970
It only talks about connections
that succeeded or

00:05:08.970 --> 00:05:10.450
failed, all past tense.

00:05:10.450 --> 00:05:14.000
It doesn't try and predict
the state of the network.

00:05:14.000 --> 00:05:17.540
So cached data at first is good,
because it doesn't have

00:05:17.540 --> 00:05:20.730
any expectation of the network,
and that's great.

00:05:20.730 --> 00:05:21.660
And that's how apps behave.

00:05:21.660 --> 00:05:24.060
If you open Twitter on
your phone, you've

00:05:24.060 --> 00:05:25.200
got old data there.

00:05:25.200 --> 00:05:27.850
And then it goes and fetches new
data if it can, if there's

00:05:27.850 --> 00:05:29.950
a network connection.

00:05:29.950 --> 00:05:32.660
So complexity isn't
the problem here.

00:05:32.660 --> 00:05:33.340
What is the problem?

00:05:33.340 --> 00:05:35.260
Well, what is the AppCache
made of?

00:05:35.260 --> 00:05:37.090
There's a request cache.

00:05:37.090 --> 00:05:40.160
And we can add, remove, and
update items from this.

00:05:40.160 --> 00:05:41.410
And those updates are
transactional.

00:05:41.410 --> 00:05:42.060
It's all atomic.

00:05:42.060 --> 00:05:44.750
And it's pretty sensible.

00:05:44.750 --> 00:05:45.850
There's also a router.

00:05:45.850 --> 00:05:48.870
The router takes a network
connection and decides what it

00:05:48.870 --> 00:05:50.030
should do with it.

00:05:50.030 --> 00:05:52.180
So it can just serve stuff
straight from the cache

00:05:52.180 --> 00:05:55.410
without going to network, or
it can go to network, give

00:05:55.410 --> 00:05:57.860
that a go, and serve something
from the cache if that fails.

00:05:57.860 --> 00:06:00.515
And that's all quite
sensible as well.

00:06:00.515 --> 00:06:03.242
But what's our API into this?

00:06:03.242 --> 00:06:06.040
Our API is the manifest.

00:06:06.040 --> 00:06:08.980
So if I do this, I add
an empty manifest--

00:06:08.980 --> 00:06:10.870
well, just with the words
cache manifest--

00:06:10.870 --> 00:06:13.360
what this will do is it'll take
index.html and it will

00:06:13.360 --> 00:06:15.460
put that into the cache.

00:06:15.460 --> 00:06:17.970
And it will set up a routing
rule that says if that page is

00:06:17.970 --> 00:06:22.090
requested, serve it straight
from the cache.

00:06:22.090 --> 00:06:22.430
Really?

00:06:22.430 --> 00:06:24.460
Did I just tell it to
do all that, just

00:06:24.460 --> 00:06:27.650
with this empty file?

00:06:27.650 --> 00:06:29.910
Here I'm adding a lot more
static routes, and here I'm

00:06:29.910 --> 00:06:33.910
saying, hey, with this one line,
take fallback PNG, make

00:06:33.910 --> 00:06:35.930
that a cache entry, put
that into the cache.

00:06:35.930 --> 00:06:38.910
And if any of these URLs are
requested, set up a routing

00:06:38.910 --> 00:06:42.500
rule, try and fetch it from the
network first, and if that

00:06:42.500 --> 00:06:46.150
fails, then use this instead,
fallback PNG.

00:06:46.150 --> 00:06:49.630
And a failure means any HTTP
status code that starts with

00:06:49.630 --> 00:06:53.580
4, 404, anything that starts
with 5, or if there's a

00:06:53.580 --> 00:06:57.290
redirect to another domain.

00:06:57.290 --> 00:07:00.710
Did I really tell it to do
that with this one line?

00:07:00.710 --> 00:07:03.870
That's a lot of assumptions
to make.

00:07:03.870 --> 00:07:09.200
And if I, say, have on my HTML
page a link, an image to a

00:07:09.200 --> 00:07:15.630
picture of your cat from
Flickr-- do you have a cat?

00:07:15.630 --> 00:07:17.480
Who has a cat?

00:07:17.480 --> 00:07:19.910
Your cat-- good, Bruce's cat.

00:07:19.910 --> 00:07:22.330
What happens to the
image of that cat?

00:07:22.330 --> 00:07:25.220
OK, so an index.html file
is a get request.

00:07:25.220 --> 00:07:26.780
That's fine.

00:07:26.780 --> 00:07:27.960
Is it associated with manifest?

00:07:27.960 --> 00:07:28.530
Yes it is.

00:07:28.530 --> 00:07:29.670
We're going to use that.

00:07:29.670 --> 00:07:30.740
Is the URL AppCached?

00:07:30.740 --> 00:07:31.690
Yes it is.

00:07:31.690 --> 00:07:33.570
So it comes straight
from the cache.

00:07:33.570 --> 00:07:34.140
That's fine.

00:07:34.140 --> 00:07:34.820
Is it HTML?

00:07:34.820 --> 00:07:35.790
Yes it is.

00:07:35.790 --> 00:07:38.150
So for each get request on
the page, we're going

00:07:38.150 --> 00:07:38.860
to go back up here.

00:07:38.860 --> 00:07:40.810
And that's going to include
the picture of your cat.

00:07:40.810 --> 00:07:42.830
So is the URL AppCached?

00:07:42.830 --> 00:07:43.840
No.

00:07:43.840 --> 00:07:46.660
Is the URL in the network
section of the manifest?

00:07:46.660 --> 00:07:47.800
No.

00:07:47.800 --> 00:07:49.790
Does the URL match a
fallback prefix?

00:07:49.790 --> 00:07:50.490
No.

00:07:50.490 --> 00:07:52.100
We've got one for avatars
but not one for

00:07:52.100 --> 00:07:54.280
Bruce's cat, so no.

00:07:54.280 --> 00:07:56.900
Is there a star in the
network section?

00:07:56.900 --> 00:07:58.000
No.

00:07:58.000 --> 00:07:59.790
So the image will fail.

00:07:59.790 --> 00:08:02.040
And the picture of Bruce's
cat will not appear.

00:08:02.040 --> 00:08:03.850
It will appear as if there
was no network.

00:08:03.850 --> 00:08:07.470
Even if you're online, the
picture of that cat will fail

00:08:07.470 --> 00:08:08.570
to download.

00:08:08.570 --> 00:08:12.840
There is nothing here to me that
suggests that picture of

00:08:12.840 --> 00:08:15.250
Bruce's cat should not load.

00:08:15.250 --> 00:08:18.930
I don't know what the AppCache
has against Bruce's cat, but

00:08:18.930 --> 00:08:22.120
even online it's not
going to work.

00:08:22.120 --> 00:08:23.620
This is a downfall API.

00:08:23.620 --> 00:08:27.660
And by downfall, I don't mean
the shouty Hitler thing.

00:08:27.660 --> 00:08:29.670
I'm not suggesting AppCache
is like Hitler--

00:08:29.670 --> 00:08:31.820
although it is a bit.

00:08:31.820 --> 00:08:33.140
No, I mean the old board game.

00:08:33.140 --> 00:08:35.570
I don't know how people have
played this, but this is what

00:08:35.570 --> 00:08:37.140
I feel like when I'm dealing
with AppCache.

00:08:37.140 --> 00:08:38.510
I know what I'm trying to do.

00:08:38.510 --> 00:08:40.539
I'm trying to get my pieces
to the bottom.

00:08:40.539 --> 00:08:42.970
And I have a very limited set
of controls for that.

00:08:42.970 --> 00:08:46.060
But when I'm doing this, all
kinds of shit's happening in

00:08:46.060 --> 00:08:47.270
the background.

00:08:47.270 --> 00:08:49.940
And I don't know what's going
on until bits start falling

00:08:49.940 --> 00:08:53.020
out of the bottom that
I didn't expect.

00:08:53.020 --> 00:08:55.640
And I don't know which of my
actions actually contributed

00:08:55.640 --> 00:08:57.000
to that happening.

00:08:57.000 --> 00:08:58.400
I know the last one that
happens, but I don't

00:08:58.400 --> 00:09:01.790
everything that happened
before that.

00:09:01.790 --> 00:09:04.330
The manifest is simple in terms
of the character count,

00:09:04.330 --> 00:09:06.450
but there's too much implicit
going on here.

00:09:06.450 --> 00:09:10.000
A better API may involve more
typing but might set out

00:09:10.000 --> 00:09:11.870
exactly what's supposed
to happen.

00:09:11.870 --> 00:09:15.990
What if in your HTML you could
say, I want to register a

00:09:15.990 --> 00:09:18.050
JavaScript controller.

00:09:18.050 --> 00:09:21.010
This controllers going to take
care of all URLs on the

00:09:21.010 --> 00:09:22.590
origin, just slash-star.

00:09:22.590 --> 00:09:24.490
And here's my JavaScript file.

00:09:24.490 --> 00:09:26.050
And that was going to run
in some kind of worker.

00:09:26.050 --> 00:09:29.770
And here I could just say, so
for all these files, when the

00:09:29.770 --> 00:09:32.130
cache is supposed to update
itself, I want you to define a

00:09:32.130 --> 00:09:34.510
cache called static, and I want
you to cache all of those

00:09:34.510 --> 00:09:36.990
static URLs and do
it atomically.

00:09:36.990 --> 00:09:40.040
And then when there's a request,
I want you to have a

00:09:40.040 --> 00:09:42.970
look and see in the static cache
if there's something

00:09:42.970 --> 00:09:44.520
that matches the incoming URL.

00:09:44.520 --> 00:09:46.560
And if there is a resource,
prevent default.

00:09:46.560 --> 00:09:48.720
Don't do the default
browser action.

00:09:48.720 --> 00:09:51.160
Respond with that resource
from the cache.

00:09:51.160 --> 00:09:56.075
This is a lot more typing than
the equivalent that you did in

00:09:56.075 --> 00:09:58.250
the manifest, but it's
really explicit.

00:09:58.250 --> 00:10:01.070
You're setting up exactly
what you want to happen.

00:10:01.070 --> 00:10:04.180
There's no magic here.

00:10:04.180 --> 00:10:05.960
You can define your own magic.

00:10:05.960 --> 00:10:08.950
This is a bring your
own unicorn API.

00:10:08.950 --> 00:10:11.580
You do all that stuff
yourself.

00:10:11.580 --> 00:10:14.040
What if I could say, OK, I'm
going to set up a route for

00:10:14.040 --> 00:10:15.130
get requests.

00:10:15.130 --> 00:10:18.670
Anything that starts with
avatars, prevent the default.

00:10:18.670 --> 00:10:20.610
I want you to try and get
it from the network.

00:10:20.610 --> 00:10:23.860
But on an error, I want you to
see if we've got something,

00:10:23.860 --> 00:10:26.220
the fallback PNG in
the resource.

00:10:26.220 --> 00:10:27.700
And if there is, I'm
going to serve it.

00:10:27.700 --> 00:10:29.200
So that's the equivalent of
your fallback, but you're

00:10:29.200 --> 00:10:32.580
telling it exactly what to do.

00:10:32.580 --> 00:10:36.000
What if I could listen to
messages from the web page

00:10:36.000 --> 00:10:36.640
that's happening?

00:10:36.640 --> 00:10:39.210
So imagine something like DFT,
where there's issues.

00:10:39.210 --> 00:10:41.760
And the user might have said,
I want to cache this issue.

00:10:41.760 --> 00:10:44.140
So he posted a message saying,
cache the issue.

00:10:44.140 --> 00:10:44.740
And [INAUDIBLE]

00:10:44.740 --> 00:10:47.240
receives that, caches define
issue, and then the issue

00:10:47.240 --> 00:10:49.620
number, and the URLs
to cache for that.

00:10:49.620 --> 00:10:52.280
And then when those requests
come in, anything that's URL

00:10:52.280 --> 00:10:54.440
issue and a number, we're
going to deal with that.

00:10:54.440 --> 00:10:57.080
We're going to say get me the
cache for that issue.

00:10:57.080 --> 00:11:00.240
If we have that cached and we
have a URL inside that cache

00:11:00.240 --> 00:11:02.950
that matches what's being
requested, serve it.

00:11:02.950 --> 00:11:05.820
Otherwise, if the request type
is a navigate, as in, someone

00:11:05.820 --> 00:11:08.490
is changing page, it's going to
be a full reload, prevent

00:11:08.490 --> 00:11:09.220
the default.

00:11:09.220 --> 00:11:09.850
Respond--

00:11:09.850 --> 00:11:12.570
try and fetch it from the
network as normal.

00:11:12.570 --> 00:11:14.820
And if that fails, and the
status code was zero, which

00:11:14.820 --> 00:11:18.380
suggests a lack of network
connection, then serve a thing

00:11:18.380 --> 00:11:20.880
from the cache saying, no, I'm
afraid you don't have that

00:11:20.880 --> 00:11:22.520
issue cached, here's why.

00:11:22.520 --> 00:11:25.800
And that's something we can't
do with AppCache now.

00:11:25.800 --> 00:11:28.810
Maybe you could do stuff like
get stuff from local storage

00:11:28.810 --> 00:11:31.170
and then use Mustache to
render it, or whatever

00:11:31.170 --> 00:11:32.840
templating language
you included.

00:11:32.840 --> 00:11:35.470
We could just completely build
an app up from this experience

00:11:35.470 --> 00:11:37.560
and completely define how
it should behave.

00:11:37.560 --> 00:11:39.690
So even someone who is
unfamiliar with the API would

00:11:39.690 --> 00:11:41.370
have a good idea of
what it's doing.

00:11:41.370 --> 00:11:42.910
They wouldn't have to read a
whole spec to understand

00:11:42.910 --> 00:11:43.990
what's going on.

00:11:43.990 --> 00:11:46.960
What if we could do that?

00:11:46.960 --> 00:11:48.650
And I think that's what we're
going to discuss, or

00:11:48.650 --> 00:11:51.840
things around it.

00:11:51.840 --> 00:11:53.854
I don't how this transition--
you have to clap.

00:11:53.854 --> 00:12:10.270
[APPLAUSE]

00:12:10.270 --> 00:12:11.175
JAKE ARCHIBALD: Watch
out, watch out.

00:12:11.175 --> 00:12:13.012
I think that's Andrew's
seat, isn't it?

00:12:21.880 --> 00:12:24.230
ANDREW BETTIS: Right.

00:12:24.230 --> 00:12:28.440
So I realized when Jake started
that I completely

00:12:28.440 --> 00:12:30.100
forgot to big up all
the people on the

00:12:30.100 --> 00:12:32.150
panel before we started.

00:12:32.150 --> 00:12:37.640
So we have Jake, who's obviously
just given his talk.

00:12:37.640 --> 00:12:40.000
He's now developed relations
for Google,

00:12:40.000 --> 00:12:41.820
formerly from Lanyard.

00:12:41.820 --> 00:12:46.090
Mark Christian from Twitter,
who also created one of the

00:12:46.090 --> 00:12:49.986
first informative sites about
AppCache, appcachefaqs.info.

00:12:49.986 --> 00:12:54.860
Alex Russell, also from Google,
who is co-author of

00:12:54.860 --> 00:12:58.080
the proposal that Jake was just
talking about, with the

00:12:58.080 --> 00:13:00.210
navigation controller.

00:13:00.210 --> 00:13:03.350
And Jonas Sicking from Mozilla,
who has very kindly

00:13:03.350 --> 00:13:05.310
signed up at the very last
minute to replace [INAUDIBLE]

00:13:05.310 --> 00:13:07.850
Tobie Langel, who's
unfortunately unable to make

00:13:07.850 --> 00:13:10.020
it because he's ill.

00:13:10.020 --> 00:13:11.600
So let's get started.

00:13:14.430 --> 00:13:17.980
So we have loads of questions
in moderator about offline.

00:13:17.980 --> 00:13:22.590
And I think the most burning
one for me, and I think the

00:13:22.590 --> 00:13:28.900
one that's most relevant to
DFT is why is there such a

00:13:28.900 --> 00:13:30.830
constraint on what we
can do offline?

00:13:30.830 --> 00:13:35.340
Why do we have such tiny limits
on what we can store?

00:13:35.340 --> 00:13:38.490
And is this a problem that we
need to solve at the spec

00:13:38.490 --> 00:13:44.830
level, or do we need an entire
new technology to solve it?

00:13:44.830 --> 00:13:46.520
Jake, why don't you start?

00:13:46.520 --> 00:13:50.730
JAKE ARCHIBALD: OK, so if you're
building something,

00:13:50.730 --> 00:13:52.490
it's going to be running
on multiple devices.

00:13:52.490 --> 00:13:57.040
So you can't make too many
expectations of the amount of

00:13:57.040 --> 00:13:59.660
data that you would be able to
store on a particular device.

00:13:59.660 --> 00:14:02.260
That said, one of the things
we were looking at is the

00:14:02.260 --> 00:14:07.330
ability to request a
permanent cache.

00:14:07.330 --> 00:14:08.920
Because one of the problems
we've got with the current

00:14:08.920 --> 00:14:12.968
cache is the browser may
object at any point.

00:14:12.968 --> 00:14:14.844
Has my microphone
gone off again?

00:14:14.844 --> 00:14:15.782
Oh, whatever.

00:14:15.782 --> 00:14:18.000
So the browser can just get
rid of it at any point.

00:14:18.000 --> 00:14:19.250
Oh, hello.

00:14:21.680 --> 00:14:25.920
So what AppCache gives you is
it says, one of these assets

00:14:25.920 --> 00:14:27.560
is not going to be ejected
from the cache.

00:14:27.560 --> 00:14:29.540
If anything's going to be
ejected, they're all going to

00:14:29.540 --> 00:14:30.670
be ejected together.

00:14:30.670 --> 00:14:32.620
And the spec doesn't say that
this stuff's going to be

00:14:32.620 --> 00:14:33.980
around forever.

00:14:33.980 --> 00:14:36.740
So the idea is if we could
make it where you would

00:14:36.740 --> 00:14:40.550
request a permanent cache, maybe
of a particular size,

00:14:40.550 --> 00:14:42.250
then you could do
that and that.

00:14:42.250 --> 00:14:45.340
And because a user would agree
to give you that, they are

00:14:45.340 --> 00:14:47.700
also now in control of
uninstalling something.

00:14:47.700 --> 00:14:51.210
So if there is a lack of space,
like they run out of

00:14:51.210 --> 00:14:54.090
space on their phone, then it's
down to them to decide

00:14:54.090 --> 00:14:55.910
what to keep and what to lose.

00:14:55.910 --> 00:14:59.930
So they might go and say, well,
this small FT app is

00:14:59.930 --> 00:15:02.970
very important to me, whereas
these big game apps are not.

00:15:02.970 --> 00:15:05.000
And it's their decision
of what to do?

00:15:05.000 --> 00:15:08.870
ANDREW BETTIS: So what's the
limit on what's reasonable?

00:15:08.870 --> 00:15:11.490
What's reasonable for an app
to acclaim for its own

00:15:11.490 --> 00:15:13.770
exclusive use?

00:15:13.770 --> 00:15:14.650
ALE RUSSELL: How is
that a question

00:15:14.650 --> 00:15:16.631
for the app to answer?

00:15:16.631 --> 00:15:18.940
It's usually a question for
the user to answer.

00:15:18.940 --> 00:15:21.950
This is about the user agent
mediating the conversation

00:15:21.950 --> 00:15:25.972
between the app developer and
the user, who is the owner of

00:15:25.972 --> 00:15:26.880
the device.

00:15:26.880 --> 00:15:29.670
And so you're trying to enable
that conversation to happen in

00:15:29.670 --> 00:15:31.340
an informed way.

00:15:31.340 --> 00:15:32.960
And usually that doesn't
mean, can I

00:15:32.960 --> 00:15:35.010
have some bit of storage.

00:15:35.010 --> 00:15:37.810
It's usually did I mean
to install this thing?

00:15:37.810 --> 00:15:39.810
Did I mean to turn this into
a real thing that's not an

00:15:39.810 --> 00:15:42.942
ephemeral page that I happen
to load and unload.

00:15:42.942 --> 00:15:46.380
The question is, have my
expectations been violated by

00:15:46.380 --> 00:15:48.475
navigating naked
to a web page.

00:15:48.475 --> 00:15:50.455
Did that imply that
100 megabytes was

00:15:50.455 --> 00:15:53.010
taken on disk per page?

00:15:53.010 --> 00:15:55.948
If I'm going to Facebook every
day, maybe it does.

00:15:55.948 --> 00:15:57.065
Maybe that's a reasonable
thing to do.

00:15:57.065 --> 00:15:59.310
If I go to Twitter and I like
to see all my history, maybe

00:15:59.310 --> 00:16:00.680
that's the most reasonable
thing I

00:16:00.680 --> 00:16:01.780
could possibly imagine.

00:16:01.780 --> 00:16:04.670
But that's a decision that
I as a user should be

00:16:04.670 --> 00:16:05.790
at least part of.

00:16:05.790 --> 00:16:08.000
And so today we don't have
that way to mediate it.

00:16:08.000 --> 00:16:09.810
And so I [INAUDIBLE]

00:16:09.810 --> 00:16:14.892
there was an additional proposal
yesterday that Jonas

00:16:14.892 --> 00:16:18.625
and others at Mozilla were
working on to layer on top of

00:16:18.625 --> 00:16:24.360
this API that we have shown a
little bit of, the idea of a

00:16:24.360 --> 00:16:29.550
more declarative manifest that
has more to say about what the

00:16:29.550 --> 00:16:32.910
thing is that you would
take an action on.

00:16:32.910 --> 00:16:37.300
JONAS SICKING: There's
a few things here.

00:16:37.300 --> 00:16:40.131
First of all, you shouldn't
think of the web as being

00:16:40.131 --> 00:16:41.600
different from native
applications.

00:16:41.600 --> 00:16:44.170
Native applications, once you
install a native application,

00:16:44.170 --> 00:16:45.803
it can write as much
as it wants.

00:16:45.803 --> 00:16:48.885
Why should the web not be able
to do that, assuming the

00:16:48.885 --> 00:16:49.850
user's fine with it.

00:16:49.850 --> 00:16:53.852
So we need to have some way of
communicating between the

00:16:53.852 --> 00:16:59.540
application and the user that
the user thinks this website

00:16:59.540 --> 00:17:05.858
is important and then wants to
enable it to store data on the

00:17:05.858 --> 00:17:08.490
local device.

00:17:08.490 --> 00:17:13.539
So that is really something
we would need to enable.

00:17:13.539 --> 00:17:17.510
Google actually has some
interesting ideas here in the

00:17:17.510 --> 00:17:17.970
[INAUDIBLE]

00:17:17.970 --> 00:17:21.329
API, where they have this
concept of temporary storage

00:17:21.329 --> 00:17:22.609
and permanent storage.

00:17:22.609 --> 00:17:25.770
That concept is something we
are working on expanding so

00:17:25.770 --> 00:17:29.665
you can use that storage area to
store essentially anything

00:17:29.665 --> 00:17:31.915
that you can store locally, you
can choose to [INAUDIBLE]

00:17:31.915 --> 00:17:33.650
store permanently
or temporary.

00:17:33.650 --> 00:17:35.750
And the user can then
be involved.

00:17:35.750 --> 00:17:38.980
And we can also use heuristics
in the browser.

00:17:38.980 --> 00:17:42.405
Like, if we know that the user
is using a website a lot, we

00:17:42.405 --> 00:17:45.145
can grant that website more
implicit storage, and we can

00:17:45.145 --> 00:17:48.250
be more careful about when
we eject that data.

00:17:48.250 --> 00:17:51.180
Or we can also enable the
website to say, I want to

00:17:51.180 --> 00:17:52.610
really lock this down.

00:17:52.610 --> 00:17:56.080
And then once the user's OK with
that, we can guarantee

00:17:56.080 --> 00:17:58.014
that certain data is
available offline.

00:17:58.014 --> 00:18:01.970
So the goal should really be
that anything that native

00:18:01.970 --> 00:18:04.590
applications can do when it
comes to sorting data locally,

00:18:04.590 --> 00:18:05.520
the web should be able to do.

00:18:05.520 --> 00:18:09.640
And that shouldn't be
hard to accomplish.

00:18:09.640 --> 00:18:13.310
ANDREW BETTIS: Is it currently
a problem that a user giving

00:18:13.310 --> 00:18:18.170
explicit consent to store
something as an explicit

00:18:18.170 --> 00:18:20.090
intention to store, but
then the browser can

00:18:20.090 --> 00:18:21.660
implicitly purge it?

00:18:21.660 --> 00:18:25.340
Is that a bug, do you think,
currently in implementation?

00:18:25.340 --> 00:18:27.900
Should it be the case that
anything that's explicitly

00:18:27.900 --> 00:18:31.665
given permission to be stored
should be explicitly removed

00:18:31.665 --> 00:18:33.300
by the user?

00:18:33.300 --> 00:18:38.280
JONAS SICKING: I think we need
to enable the scenario where

00:18:38.280 --> 00:18:41.000
you're guaranteed that
something is wrong.

00:18:41.000 --> 00:18:45.940
The only way to guarantee that
something is wrong is to take

00:18:45.940 --> 00:18:49.322
up storage on the user's device,
which means taking

00:18:49.322 --> 00:18:50.830
resource away from the user.

00:18:50.830 --> 00:18:53.180
And so the user needs to be
involved in that decision.

00:18:53.180 --> 00:18:56.370
But in many cases, you don't
need that level of guarantee.

00:18:56.370 --> 00:19:00.730
And you could probably build
pretty good heuristics so that

00:19:00.730 --> 00:19:03.230
things mostly work without
the user being involved.

00:19:03.230 --> 00:19:08.760
But I also think that we need
to enable websites to say,

00:19:08.760 --> 00:19:10.780
hey, I really want to be able to
guarantee this to the user,

00:19:10.780 --> 00:19:13.230
in which case we can
have interaction.

00:19:13.230 --> 00:19:15.090
We can have a security
dialogue.

00:19:15.090 --> 00:19:18.710
But as long as we make that
flow nice and don't ask--

00:19:18.710 --> 00:19:24.340
like Firefox currently does,
asks you three times before it

00:19:24.340 --> 00:19:26.400
grants you that permission.

00:19:26.400 --> 00:19:29.570
It should be within the control
of the website when to

00:19:29.570 --> 00:19:30.420
ask the user.

00:19:30.420 --> 00:19:32.250
And it should only
be one question.

00:19:32.250 --> 00:19:34.773
The user should just say, yeah,
I'm OK with giving this

00:19:34.773 --> 00:19:37.551
website a little bit
more information.

00:19:37.551 --> 00:19:41.240
And we shouldn't need to ask
about individual [INAUDIBLE].

00:19:41.240 --> 00:19:43.450
ANDREW BETTIS: So can
I just a quick poll?

00:19:43.450 --> 00:19:46.130
Who here has run out of space
when they were building an

00:19:46.130 --> 00:19:48.840
offline app?

00:19:48.840 --> 00:19:51.670
So we have a few
people who've--

00:19:51.670 --> 00:19:53.630
OK, interesting.

00:19:53.630 --> 00:19:55.880
ALEX RUSSELL: I think it's
also a UX issue.

00:19:55.880 --> 00:19:58.670
There's the what is it
that I'm doing here?

00:19:58.670 --> 00:20:01.790
Are we going to ask users
honestly to go reason about

00:20:01.790 --> 00:20:05.070
their storage independently of
what the application is?

00:20:05.070 --> 00:20:07.530
I don't think that people,
generally speaking-- certainly

00:20:07.530 --> 00:20:13.220
not the app platform models
that we have today--

00:20:13.220 --> 00:20:15.690
I don't think people reason
about them independently.

00:20:15.690 --> 00:20:17.390
You have an application, and
that means that you have its

00:20:17.390 --> 00:20:19.320
data as well.

00:20:19.320 --> 00:20:22.300
And we don't really have a
reified idea of what an

00:20:22.300 --> 00:20:23.990
application is.

00:20:23.990 --> 00:20:28.180
That's the thing that we don't
have, as a unit of something

00:20:28.180 --> 00:20:30.130
that we can communicate
to end users today.

00:20:30.130 --> 00:20:32.680
And Mozilla's building an app
platform, and we're building

00:20:32.680 --> 00:20:33.480
an app platform.

00:20:33.480 --> 00:20:35.990
And they helped unify
that concept.

00:20:35.990 --> 00:20:38.420
And it feels to me like
helping to make that

00:20:38.420 --> 00:20:41.600
transition from I've got a page
to look, it's also an

00:20:41.600 --> 00:20:42.160
application--

00:20:42.160 --> 00:20:45.840
I think that's really the big
transition for everyone who's

00:20:45.840 --> 00:20:48.060
building apps, both conceptually
as you're

00:20:48.060 --> 00:20:51.230
building them and for users
who are consuming them.

00:20:51.230 --> 00:20:53.200
I'd like to talk more at some
point about what it means to

00:20:53.200 --> 00:20:55.780
transition as a builder thinking
about an app--

00:20:55.780 --> 00:20:57.080
ANDREW BETTIS: Well, your
microphone's not working.

00:20:57.080 --> 00:20:58.510
So next time you want to speak,
just let me know.

00:20:58.510 --> 00:21:01.940
And you can speak into mine.

00:21:01.940 --> 00:21:02.850
MALE SPEAKER: His
mic works fine.

00:21:02.850 --> 00:21:04.666
But he can't talk over his
shoulder to Andrew.

00:21:04.666 --> 00:21:06.940
He's got to talk directly
[INAUDIBLE].

00:21:06.940 --> 00:21:07.840
ALEX RUSSELL: Sorry
about that.

00:21:07.840 --> 00:21:09.500
MARK CHRISTIAN: So I think that
part of the problem with

00:21:09.500 --> 00:21:13.150
the situation right now is that
web applications feel a

00:21:13.150 --> 00:21:14.990
little bit different than
websites, but they're all

00:21:14.990 --> 00:21:16.440
running in the same universe.

00:21:16.440 --> 00:21:18.270
And when you're building an
application, you want to have

00:21:18.270 --> 00:21:21.090
quite a bit of control over
how you're storing your

00:21:21.090 --> 00:21:23.710
resources and managing the
user data, whereas

00:21:23.710 --> 00:21:26.460
historically, web APIs have been
more like suggestions to

00:21:26.460 --> 00:21:27.180
the user agent.

00:21:27.180 --> 00:21:30.940
It's up to the user agent to
interpret what's going on and

00:21:30.940 --> 00:21:32.840
deal with it appropriately.

00:21:32.840 --> 00:21:35.230
AppCache demonstrates that
there's a lot of assumptions

00:21:35.230 --> 00:21:37.040
built into that that don't
always work, and it makes it

00:21:37.040 --> 00:21:38.995
difficult to have a consistent
experience.

00:21:38.995 --> 00:21:41.880
So I think part of the problem
is actually philosophical.

00:21:41.880 --> 00:21:46.220
As we go forward and build a new
API, how much control do

00:21:46.220 --> 00:21:48.300
we want to let these
applications have?

00:21:48.300 --> 00:21:50.420
And it's a trust
issue as well.

00:21:50.420 --> 00:21:53.610
Going to a random website, how
much trust does that actually

00:21:53.610 --> 00:21:55.630
imply that user has?

00:21:55.630 --> 00:21:58.120
JAKE ARCHIBALD: I think we could
spend the whole of today

00:21:58.120 --> 00:22:00.000
trying to work out what the
difference between a website

00:22:00.000 --> 00:22:00.730
and a web app is.

00:22:00.730 --> 00:22:04.270
And I think at the end of it,
we'd say, well, does it

00:22:04.270 --> 00:22:06.150
actually matter?

00:22:06.150 --> 00:22:10.480
Once we've made that decision,
what would we do differently?

00:22:10.480 --> 00:22:14.560
So I think this API we're making
now would work fine for

00:22:14.560 --> 00:22:18.540
sites and work fine for apps.

00:22:18.540 --> 00:22:21.430
What do you see as the
difference between the two?

00:22:21.430 --> 00:22:24.130
MARK CHRISTIAN: Probably
persistence of storage and

00:22:24.130 --> 00:22:25.600
amount of storage.

00:22:25.600 --> 00:22:26.690
Those are the characteristics.

00:22:26.690 --> 00:22:29.870
Do you want a random website to
be able to dump a gigabyte

00:22:29.870 --> 00:22:31.580
of data onto your hard drive?

00:22:31.580 --> 00:22:32.510
JAKE ARCHIBALD: Well, I might
if it's Wikipedia.

00:22:32.510 --> 00:22:35.015
I might want to download
Wikipedia as a site.

00:22:35.015 --> 00:22:36.060
MARK CHRISTIAN: Yeah,
I might too.

00:22:36.060 --> 00:22:39.390
But there's no good model for
letting a user illustrate that

00:22:39.390 --> 00:22:40.868
that's actually what
they really wanted.

00:22:43.485 --> 00:22:46.680
JONAS SICKING: I think one
problem we have is that

00:22:46.680 --> 00:22:51.869
historically websites have been
these things where, as a

00:22:51.869 --> 00:22:54.720
browser, we treat them as--
we have no idea if this is

00:22:54.720 --> 00:22:56.280
something that the user
actually likes.

00:22:56.280 --> 00:22:59.540
It might be just some random
website that the user found

00:22:59.540 --> 00:23:01.520
through a link in
a spam email.

00:23:01.520 --> 00:23:04.820
And so we have this very
distrusting relationship of

00:23:04.820 --> 00:23:05.700
the website.

00:23:05.700 --> 00:23:09.915
And as we're trying to expand
the web into being able to do

00:23:09.915 --> 00:23:14.810
more things, we have to enable
the user to indicate, I

00:23:14.810 --> 00:23:16.510
actually trust this website.

00:23:16.510 --> 00:23:18.440
I actually enjoy this website.

00:23:18.440 --> 00:23:22.750
I want this website to be able
to do things that [INAUDIBLE]

00:23:22.750 --> 00:23:24.160
shouldn't be able to do.

00:23:24.160 --> 00:23:28.780
So we need some way, some
UX to enable the user to

00:23:28.780 --> 00:23:32.670
communicate to the browser that,
hey, it's OK for this

00:23:32.670 --> 00:23:37.550
website to get some extra
capabilities.

00:23:37.550 --> 00:23:41.960
So one way of doing this is
app platforms that both

00:23:41.960 --> 00:23:47.290
Firefox and Chrome OS is having,
which enables the

00:23:47.290 --> 00:23:49.905
users to go through this install
flow, at which point,

00:23:49.905 --> 00:23:54.760
you indicated that yeah, I trust
this website enough that

00:23:54.760 --> 00:23:56.490
I have installed it.

00:23:56.490 --> 00:23:59.560
We should enable those
capabilities not just through

00:23:59.560 --> 00:24:02.892
install flow but also through
other means where it's still a

00:24:02.892 --> 00:24:07.150
website, UX-wise, but you've
indicated some other way that

00:24:07.150 --> 00:24:10.160
it's OK for this guy to
use more resources.

00:24:10.160 --> 00:24:14.290
The two things in Firefox OS
that we're giving a website

00:24:14.290 --> 00:24:17.535
once it's installed is ability
to use resources and ability

00:24:17.535 --> 00:24:18.760
to annoy the user.

00:24:18.760 --> 00:24:23.140
So on the web, we built
pop-up blockers.

00:24:23.140 --> 00:24:26.400
We tried to disable this ability
of disabling the

00:24:26.400 --> 00:24:27.380
context menu.

00:24:27.380 --> 00:24:29.790
And a lot of the things that
it's really nice if the good

00:24:29.790 --> 00:24:32.120
guys can do but we don't want
the bad guys to do.

00:24:32.120 --> 00:24:38.030
And so if we can have some way
to use UX to indicate that

00:24:38.030 --> 00:24:41.100
this website should be able to
do things, then we can enable

00:24:41.100 --> 00:24:42.650
much more [INAUDIBLE].

00:24:42.650 --> 00:24:47.130
ANDREW BETTIS: Do you think that
using app runtimes as a

00:24:47.130 --> 00:24:51.230
solution to offline problems
is good enough?

00:24:51.230 --> 00:24:53.940
Or do you think that we ought
to be able to solve these

00:24:53.940 --> 00:24:56.680
problems without using
app runtime?

00:24:56.680 --> 00:24:58.290
JONAS SICKING: I think app
runtimes is a good way for us

00:24:58.290 --> 00:25:03.100
to experiment, but
it's an easy out.

00:25:03.100 --> 00:25:06.390
We have this traditional sense
of what an application is.

00:25:06.390 --> 00:25:11.320
And traditional users know what
it means to install an

00:25:11.320 --> 00:25:14.525
application, as far as I know
that this enables this

00:25:14.525 --> 00:25:17.120
application to do more things.

00:25:17.120 --> 00:25:20.080
I shouldn't install
it if I hate it.

00:25:20.080 --> 00:25:23.520
So it gives us an easy
out, but it's

00:25:23.520 --> 00:25:25.415
definitely not good enough.

00:25:25.415 --> 00:25:29.430
There needs to be a fluid
transition from being a

00:25:29.430 --> 00:25:32.760
potentially evil spam website
that the user has navigated to

00:25:32.760 --> 00:25:35.100
being a fully-trusted
installed app.

00:25:35.100 --> 00:25:36.330
It's a smooth transition.

00:25:36.330 --> 00:25:39.580
And the user, as you're slowly
getting more and more familiar

00:25:39.580 --> 00:25:41.990
with the website, it shouldn't
be a hard path.

00:25:41.990 --> 00:25:44.980
It should be, you trust it more
and more, and it gets

00:25:44.980 --> 00:25:47.002
more and more capabilities as
the user gives it more and

00:25:47.002 --> 00:25:49.591
more trust.

00:25:49.591 --> 00:25:53.430
App runtimes is definitely
not enough of an answer.

00:25:53.430 --> 00:25:54.760
JAKE ARCHIBALD: Yeah, we've been
through that same problem

00:25:54.760 --> 00:25:56.490
before with Flash.

00:25:56.490 --> 00:25:59.060
I mean, we went for so long with
not adding these APIs to

00:25:59.060 --> 00:26:01.840
HTML, saying, oh, if you want
those kind of capabilities, do

00:26:01.840 --> 00:26:02.900
it in a plug-in.

00:26:02.900 --> 00:26:04.970
And we're seeing the same again
with, oh, if you want

00:26:04.970 --> 00:26:07.040
those kind of things, just
do it in an app.

00:26:07.040 --> 00:26:10.340
We shouldn't let that stop us
making the platform better.

00:26:10.340 --> 00:26:14.080
ANDREW BETTIS: Jake and Alex,
you're proposing actually a

00:26:14.080 --> 00:26:18.460
controller that gives the
developer a lot of flexibility

00:26:18.460 --> 00:26:21.953
over how they respond to
offline situations.

00:26:24.530 --> 00:26:27.320
There's a great question in
Moderator which is, how would

00:26:27.320 --> 00:26:30.280
you propose to use that
to handle the

00:26:30.280 --> 00:26:32.266
one-legged dog scenario?

00:26:32.266 --> 00:26:37.910
ALEX RUSSELL: So I think
the answer to this is--

00:26:37.910 --> 00:26:40.850
it's a little bit circuitous,
so stick with me.

00:26:40.850 --> 00:26:43.100
The way AppCache works,
generally speaking, when it

00:26:43.100 --> 00:26:47.500
works, is to help you take the
shell of an application, the

00:26:47.500 --> 00:26:49.640
thing that will load content
and then display it to you

00:26:49.640 --> 00:26:52.730
while your offline, package that
up, and make it available

00:26:52.730 --> 00:26:54.390
to you at all points.

00:26:54.390 --> 00:26:56.920
What Jake showed you was a great
way for you to package

00:26:56.920 --> 00:27:00.890
up the shell of a content
application using AppCache.

00:27:00.890 --> 00:27:04.910
There's a related question,
which is inflated by the API

00:27:04.910 --> 00:27:07.520
of AppCache, unfortunately,
which is, how do I then deal

00:27:07.520 --> 00:27:10.010
with the content that I'm
loading inside this shell?

00:27:10.010 --> 00:27:11.850
Because every app you
load in native

00:27:11.850 --> 00:27:12.995
environment has this duality.

00:27:12.995 --> 00:27:15.520
I've got shell, and I've got a
library of content that I'm

00:27:15.520 --> 00:27:16.400
navigating.

00:27:16.400 --> 00:27:17.730
And if you think about the way
you're building things on the

00:27:17.730 --> 00:27:19.680
server, you do exactly
the same thing.

00:27:19.680 --> 00:27:24.120
You've got this node graph of
content that you're allowing

00:27:24.120 --> 00:27:25.890
users to transition through,
and they're

00:27:25.890 --> 00:27:27.510
all mapped to URLs.

00:27:27.510 --> 00:27:29.400
But you usually take the little
bit of content that's

00:27:29.400 --> 00:27:32.670
unique to that URL, and you
smash a gigantic template

00:27:32.670 --> 00:27:34.610
thing around it, and you spit
it all out as a string, and

00:27:34.610 --> 00:27:37.160
then you rehydrate it
on the client side.

00:27:37.160 --> 00:27:39.185
But that isn't what the URL
is really addressing.

00:27:39.185 --> 00:27:41.500
The URL addresses that little
bit of content, that unique

00:27:41.500 --> 00:27:44.640
bit of indivisible content
that you're

00:27:44.640 --> 00:27:45.700
serving at that URL.

00:27:45.700 --> 00:27:49.390
And it may be multiple nodes all
joined into one particular

00:27:49.390 --> 00:27:50.020
serialization.

00:27:50.020 --> 00:27:52.610
But that's sort of the idea.

00:27:52.610 --> 00:27:55.530
So the question is, how do
we enable people to build

00:27:55.530 --> 00:27:59.650
application architectures
offline, which easily give you

00:27:59.650 --> 00:28:03.080
that shell and the ability to
cache resources which you will

00:28:03.080 --> 00:28:05.140
load inside that shell, so that
you can discover them, so

00:28:05.140 --> 00:28:06.580
you can load them, you can
provide the fallback

00:28:06.580 --> 00:28:08.060
experience if you
don't have them.

00:28:08.060 --> 00:28:11.560
Today, AppCache rolls them
all into one manifest.

00:28:11.560 --> 00:28:14.190
Because today, if you actually
take the AppCache to its

00:28:14.190 --> 00:28:16.350
logical conclusion, what you
realize at the end of this

00:28:16.350 --> 00:28:18.870
long, painful journey-- which
Jake took, and which the Gmail

00:28:18.870 --> 00:28:21.160
team took, and which a lot of
people who have been building

00:28:21.160 --> 00:28:23.130
offline apps have taken
independently--

00:28:23.130 --> 00:28:24.900
is that AppCache is the
thing that you use

00:28:24.900 --> 00:28:26.000
to cache the shell.

00:28:26.000 --> 00:28:28.920
And for all other content, which
you would have liked to

00:28:28.920 --> 00:28:31.650
have given a nice URL, what you
do is you build an ad hoc

00:28:31.650 --> 00:28:34.410
synchronization protocol, you
put it in Web SQL Database or

00:28:34.410 --> 00:28:36.120
IndexDB or local storage.

00:28:36.120 --> 00:28:38.620
And then every time someone
navigates to that URL, you try

00:28:38.620 --> 00:28:41.280
to override what the browser
was going to do to navigate

00:28:41.280 --> 00:28:44.120
you, go get it out of the local
storage if you have it,

00:28:44.120 --> 00:28:45.600
and then perform your
own synchronization

00:28:45.600 --> 00:28:46.450
on that data model.

00:28:46.450 --> 00:28:48.930
So you have a data model which
is not represented at those

00:28:48.930 --> 00:28:50.100
URLs anymore.

00:28:50.100 --> 00:28:53.020
So the default model is
effectively URL hostile.

00:28:53.020 --> 00:28:55.730
And the only thing that's helped
by having it at a URL

00:28:55.730 --> 00:28:58.040
is loading the initial shell,
which is the least meaningful

00:28:58.040 --> 00:29:00.840
thing in terms of URL space.

00:29:00.840 --> 00:29:05.330
So what you'd really like to
do in all this is to help

00:29:05.330 --> 00:29:08.000
application owners understand
through the API that your

00:29:08.000 --> 00:29:10.050
caching two separate
sets of things.

00:29:10.050 --> 00:29:13.640
There's a shell, which is your
browser for your content.

00:29:13.640 --> 00:29:15.530
There's the browser that
you browse to different

00:29:15.530 --> 00:29:16.610
sites and apps with.

00:29:16.610 --> 00:29:19.210
But there's the browser that you
build for the content that

00:29:19.210 --> 00:29:21.290
you're surfacing inside
your app.

00:29:21.290 --> 00:29:23.190
And then there's the
content of the app.

00:29:23.190 --> 00:29:24.990
You need to treat them
independently, but you'd like

00:29:24.990 --> 00:29:27.490
them both to be cacheable
as HTTP resources.

00:29:27.490 --> 00:29:30.710
So the way to get there is
to change expectations.

00:29:30.710 --> 00:29:32.480
There's no app that you're
going to build that's

00:29:32.480 --> 00:29:35.150
meaningful that's not
offline by default.

00:29:35.150 --> 00:29:37.100
AppCache gets you part of the
way there, because it makes

00:29:37.100 --> 00:29:40.330
the resources for your app
shell offline by default.

00:29:40.330 --> 00:29:43.710
But it doesn't necessarily do
anything particular for the

00:29:43.710 --> 00:29:46.400
resources that you would like
to load inside that shell.

00:29:46.400 --> 00:29:48.880
So we have to make this
transition in thinking about

00:29:48.880 --> 00:29:52.950
building apps in this world,
which is, we're not building a

00:29:52.950 --> 00:29:55.500
series of HTML pages that you're
going to serialize at a

00:29:55.500 --> 00:30:00.390
URL fully formed from the server
side as strings that

00:30:00.390 --> 00:30:01.990
you're going to put back
into the cache.

00:30:01.990 --> 00:30:02.900
It's nonsensical.

00:30:02.900 --> 00:30:04.110
It doesn't work.

00:30:04.110 --> 00:30:05.570
Instead what you're going to do
is you're going to assume

00:30:05.570 --> 00:30:07.720
that there's a shell that's
booted, and you're moving

00:30:07.720 --> 00:30:10.110
between the cached resources,
and if you can get to them,

00:30:10.110 --> 00:30:11.820
the uncached ones.

00:30:11.820 --> 00:30:14.260
And that means that you're
always working from this local

00:30:14.260 --> 00:30:17.900
store of your shell and your
content in order to do

00:30:17.900 --> 00:30:18.690
everything.

00:30:18.690 --> 00:30:22.300
And that's the big transition
that has been conflated with

00:30:22.300 --> 00:30:25.330
the use of AppCache over time.

00:30:25.330 --> 00:30:27.970
And everyone discovers that
that's what AppCache implies,

00:30:27.970 --> 00:30:29.710
but it's not clear.

00:30:29.710 --> 00:30:31.370
And it's not clear that that's
how you have to build your

00:30:31.370 --> 00:30:32.940
application to be successful.

00:30:32.940 --> 00:30:35.850
JAKE ARCHIBALD: So I would see
the model working if you

00:30:35.850 --> 00:30:36.600
imagine an app--

00:30:36.600 --> 00:30:37.490
I think I'm all right.

00:30:37.490 --> 00:30:40.710
If you imagine an app--
no, I'm not.

00:30:40.710 --> 00:30:44.410
If you imagine an app where it's
a series of messages from

00:30:44.410 --> 00:30:45.750
people you're subscribed to--

00:30:45.750 --> 00:30:47.440
basically Twitter--

00:30:47.440 --> 00:30:49.230
if you visit the page and you
don't have a controller

00:30:49.230 --> 00:30:51.200
installed, and you don't have
JavaScript, the server is

00:30:51.200 --> 00:30:52.690
going to construct all
of this stuff.

00:30:52.690 --> 00:30:54.520
You'll have to wait for a
network who responds, and

00:30:54.520 --> 00:30:58.490
you'll get it how internet
should work today.

00:30:58.490 --> 00:31:00.860
If you have a controller
installed, it's going to

00:31:00.860 --> 00:31:04.710
respond with an empty content
shell of the UI, it's going to

00:31:04.710 --> 00:31:08.730
kick off an XHR or request on
your page, but it's going to

00:31:08.730 --> 00:31:10.980
have a header or query
strings saying, I'm

00:31:10.980 --> 00:31:12.280
OK with cached data.

00:31:12.280 --> 00:31:15.112
The controller is going to
see that and return the

00:31:15.112 --> 00:31:16.300
last data you saw.

00:31:16.300 --> 00:31:17.500
You're going to build
up the page.

00:31:17.500 --> 00:31:19.270
And that's going to
happen instantly.

00:31:19.270 --> 00:31:21.710
But then it will set off another
XHR, something in a

00:31:21.710 --> 00:31:25.370
query string, saying, I want
this data to come from online.

00:31:25.370 --> 00:31:28.600
And that connection will either
succeed, in which case

00:31:28.600 --> 00:31:31.120
you'll replace the content on
the screen with the new stuff,

00:31:31.120 --> 00:31:32.865
or it will fail, and you'll
fail silently.

00:31:32.865 --> 00:31:35.900
And that's your offline
experience.

00:31:35.900 --> 00:31:37.730
ANDREW BETTIS: Can I pick up--

00:31:37.730 --> 00:31:40.960
you were talking about the
failure scenario of trying to

00:31:40.960 --> 00:31:43.750
load content and then it failing
and falling back to

00:31:43.750 --> 00:31:44.940
content from cache.

00:31:44.940 --> 00:31:47.140
So the biggest problem we have
with AppCache with the

00:31:47.140 --> 00:31:49.840
fallback is that you can't
control that timeout.

00:31:49.840 --> 00:31:51.850
You can't determine how long
that's going to be, and it's

00:31:51.850 --> 00:31:53.990
usually longer than a user
is prepared to wait.

00:31:53.990 --> 00:31:56.230
So in the scenario of using a
navigation controller, in

00:31:56.230 --> 00:31:58.750
which you'd be able to configure
what that timeout

00:31:58.750 --> 00:32:00.376
is, how long are you
prepared to wait?

00:32:03.520 --> 00:32:04.550
ALEX RUSSELL: You have explicit
control under the

00:32:04.550 --> 00:32:07.700
controller scenario over
the loading process.

00:32:07.700 --> 00:32:11.730
So you are able to make
a decision when you're

00:32:11.730 --> 00:32:14.180
dispatching the request in the
first place, do I know that

00:32:14.180 --> 00:32:15.000
I'm offline?

00:32:15.000 --> 00:32:16.480
The only thing that we can
actually tell you from the

00:32:16.480 --> 00:32:19.020
browser's perspective about
your online versus offline

00:32:19.020 --> 00:32:21.460
state is that you are
definitively not connected to

00:32:21.460 --> 00:32:22.280
any network.

00:32:22.280 --> 00:32:24.150
We can't tell you whether or not
you can hit your server.

00:32:24.150 --> 00:32:25.900
We can't tell you anything about
what's reasonable in

00:32:25.900 --> 00:32:27.830
terms of expectation for
hitting your server.

00:32:27.830 --> 00:32:29.800
We can tell you if you're behind
a hostile proxy or

00:32:29.800 --> 00:32:33.080
inside of a captive portal
from some Wi-Fi thing.

00:32:33.080 --> 00:32:34.330
We can't tell you any of that.

00:32:34.330 --> 00:32:35.740
That's going to be up to
your application to

00:32:35.740 --> 00:32:36.690
have to figure out.

00:32:36.690 --> 00:32:39.080
And the way you do that is by
making one these requests and

00:32:39.080 --> 00:32:40.550
then watching what happens.

00:32:40.550 --> 00:32:45.450
So yes, you'll be able to cancel
the request and respond

00:32:45.450 --> 00:32:48.040
with I have no idea
what's going on.

00:32:48.040 --> 00:32:50.410
And it's going to be explicitly
under your control,

00:32:50.410 --> 00:32:52.550
which is to say that you'll
explicitly have to provide

00:32:52.550 --> 00:32:53.630
that functionality.

00:32:53.630 --> 00:32:57.030
But that's a damn sight better
than trying to have to figure

00:32:57.030 --> 00:33:00.360
out a way to make AppCache
do it right now.

00:33:00.360 --> 00:33:02.040
ANDREW BETTIS: And here's
another quick

00:33:02.040 --> 00:33:04.520
question from Moderator.

00:33:04.520 --> 00:33:08.100
Is there scope for a standard
way of synchronizing content

00:33:08.100 --> 00:33:12.710
from server to client
and vice versa?

00:33:12.710 --> 00:33:12.800
JONAS SICKING: So

00:33:12.800 --> 00:33:14.920
synchronization is really hard.

00:33:14.920 --> 00:33:17.205
Once you get into two-way
synchronization, which is what

00:33:17.205 --> 00:33:21.970
you often get into, there's
no standard way of

00:33:21.970 --> 00:33:23.080
synchronizing data.

00:33:23.080 --> 00:33:27.750
It's very, very application
specific, how you deal with

00:33:27.750 --> 00:33:29.000
merged conflicts.

00:33:30.930 --> 00:33:36.050
So one answer is simply no,
we can't solve this.

00:33:36.050 --> 00:33:39.020
There are some interesting
approaches that may work.

00:33:39.020 --> 00:33:42.016
So Couch, for example, does this
thing where it allows you

00:33:42.016 --> 00:33:44.170
to synchronize data, but
it doesn't actually

00:33:44.170 --> 00:33:44.990
deal with the merging.

00:33:44.990 --> 00:33:48.770
So you can pull down data, and
the local data that you end up

00:33:48.770 --> 00:33:52.460
with explicitly contains
the conflict.

00:33:52.460 --> 00:33:56.810
And then after the fact, once
you run code, then you can

00:33:56.810 --> 00:33:57.770
deal with that conflict.

00:33:57.770 --> 00:34:00.220
And so potentially we can build

00:34:00.220 --> 00:34:03.270
something around that model.

00:34:03.270 --> 00:34:06.255
But I think dealing with
synchronization is really,

00:34:06.255 --> 00:34:06.940
really hard.

00:34:06.940 --> 00:34:09.409
I think in the beginning
we need to just.

00:34:09.409 --> 00:34:10.980
ANDREW BETTIS: Are we just
asking for trouble here?

00:34:10.980 --> 00:34:13.030
I mean, are we just asking
to build something that

00:34:13.030 --> 00:34:15.610
developers will say, that
doesn't quite work the way I

00:34:15.610 --> 00:34:17.380
want it to, so I'm going
to build my own?

00:34:17.380 --> 00:34:20.909
ALEX RUSSELL: I think the thing
that will get you in

00:34:20.909 --> 00:34:23.449
trouble is making assumptions
about the developers' data

00:34:23.449 --> 00:34:25.239
model, which were not
collaborative.

00:34:25.239 --> 00:34:31.280
So if we provide developers a
data model which we constrain

00:34:31.280 --> 00:34:34.760
tightly, like, if we provide
a straight transition chart

00:34:34.760 --> 00:34:39.239
system that you can then speak
in high-level terms about the

00:34:39.239 --> 00:34:41.330
changes between the states of
your applications, and then we

00:34:41.330 --> 00:34:45.139
can watch those in a way that,
say, a SQL database watches

00:34:45.139 --> 00:34:47.469
the SQL queries that come in and
the transactions and the

00:34:47.469 --> 00:34:49.830
commits and you can then make a
binary log of them, then you

00:34:49.830 --> 00:34:51.370
can start to do something about
the synchronization of

00:34:51.370 --> 00:34:53.150
the high-level application
semantics.

00:34:53.150 --> 00:34:57.090
But as much as people would like
to pretend that HTML is

00:34:57.090 --> 00:34:59.450
semantic, it ain't.

00:34:59.450 --> 00:35:02.040
HTML today, in most of its use
cases, ain't semantic.

00:35:02.040 --> 00:35:04.690
You're not saying anything more
meaningful than div, div,

00:35:04.690 --> 00:35:06.290
div, div, div.

00:35:06.290 --> 00:35:09.320
And your mutations of HTML are
no more meaningful that show

00:35:09.320 --> 00:35:10.950
or hide this particular
piece of UI.

00:35:10.950 --> 00:35:13.700
They don't relate specifically,
in most cases,

00:35:13.700 --> 00:35:16.960
except in a tangential way, to
I'm changing this particular

00:35:16.960 --> 00:35:20.530
piece of state in my data model,
which is what you're

00:35:20.530 --> 00:35:21.540
trying to synchronize.

00:35:21.540 --> 00:35:24.390
And so we don't have a local
idea of a data model.

00:35:24.390 --> 00:35:26.670
Therefore we can't really cons
up the idea of a local

00:35:26.670 --> 00:35:28.090
synchronization store.

00:35:28.090 --> 00:35:31.530
I think that the next iteration
of the library wars

00:35:31.530 --> 00:35:34.610
will be about data models
locally and synchronization.

00:35:34.610 --> 00:35:36.470
My guess is that people are
going to start doing

00:35:36.470 --> 00:35:38.900
operational transform libraries
out of the woodwork.

00:35:38.900 --> 00:35:40.010
It's going to be amazing.

00:35:40.010 --> 00:35:42.720
We're starting to see this a
little bit with Meteor and

00:35:42.720 --> 00:35:45.360
some other libraries that are
starting to apply some good

00:35:45.360 --> 00:35:48.200
computer science to the
question of how do I

00:35:48.200 --> 00:35:50.590
differentiate what's happening
when I change it?

00:35:50.590 --> 00:35:53.230
How do I prevent merge conflicts
in the first place,

00:35:53.230 --> 00:35:56.090
by dealing in high-level
operations, and not in, oh

00:35:56.090 --> 00:35:58.770
look, some field was
added or removed?

00:35:58.770 --> 00:36:01.070
And we're starting to add good
support for being able to

00:36:01.070 --> 00:36:04.020
build these libraries into both
the language and the DOM.

00:36:04.020 --> 00:36:06.260
There's something called
object.observe and mutation

00:36:06.260 --> 00:36:08.740
observers, which are way of
observing those changes as

00:36:08.740 --> 00:36:11.600
they happen and responding to
high-level events and not the

00:36:11.600 --> 00:36:14.150
low-level primitives changing
out from underneath you.

00:36:14.150 --> 00:36:17.060
But we've got a very long way
collectively to go to get to

00:36:17.060 --> 00:36:20.410
an agreement whereby we as
browser vendors would feel, I

00:36:20.410 --> 00:36:24.460
think, reasonably comfortable
in blessing one particulars

00:36:24.460 --> 00:36:27.740
strategy for describing your
data and then another strategy

00:36:27.740 --> 00:36:31.100
for synchronizing it.

00:36:31.100 --> 00:36:33.550
ANDREW BETTIS: So has anyone
here implemented any kind of

00:36:33.550 --> 00:36:36.250
offline sync, any kind
of ability to

00:36:36.250 --> 00:36:38.530
synchronize data to browser?

00:36:38.530 --> 00:36:38.910
MALE SPEAKER: Yeah.

00:36:38.910 --> 00:36:41.090
ANDREW BETTIS: OK, so what's
your use case?

00:36:50.480 --> 00:36:54.560
MALE SPEAKER: It's exactly how
you just described it.

00:36:54.560 --> 00:36:58.920
The AppCache hosts the shell,
and everything else comes from

00:36:58.920 --> 00:37:00.070
local storage.

00:37:00.070 --> 00:37:04.470
So local storage is the user
data, AppCache is the shell.

00:37:04.470 --> 00:37:06.910
And it assumes from the
beginning that the user is

00:37:06.910 --> 00:37:12.760
going to have no data and then
tries to fetch over an AJAX

00:37:12.760 --> 00:37:15.625
request and feeds into
local storage.

00:37:18.910 --> 00:37:20.110
MARK CHRISTIAN: I think most
of the problems with

00:37:20.110 --> 00:37:24.830
synchronization are less data
model than we would think.

00:37:24.830 --> 00:37:28.260
I feel like it's actually
a feasible problem.

00:37:28.260 --> 00:37:30.980
If you look at stuff like
iCloud, you can offer a couple

00:37:30.980 --> 00:37:33.360
of pretty basic data
strategies.

00:37:33.360 --> 00:37:35.115
Like, I've got a key value
store, or I've

00:37:35.115 --> 00:37:36.260
got a record store.

00:37:36.260 --> 00:37:39.840
You don't need to build up
particularly complex models in

00:37:39.840 --> 00:37:42.170
the browser to actually
be able to support--

00:37:42.170 --> 00:37:47.160
there's this thing, it has a
GUID, and you can say whatever

00:37:47.160 --> 00:37:50.050
the most recent changed
version is works.

00:37:50.050 --> 00:37:52.640
ALEX RUSSELL: So you're positing
that one default

00:37:52.640 --> 00:37:55.880
strategy across multi-tenant
synchronization will work,

00:37:55.880 --> 00:37:58.090
that there's only a single user,
and that user's last

00:37:58.090 --> 00:37:59.970
change is going to be
synchronized and timed

00:37:59.970 --> 00:38:02.100
correctly across multiple
systems.

00:38:02.100 --> 00:38:04.840
And you're saying that there's
a closed form over the

00:38:04.840 --> 00:38:06.250
operations that I can take.

00:38:06.250 --> 00:38:08.990
You do need the closed form, but
you need the ability for

00:38:08.990 --> 00:38:11.440
applications to specify the
operations that they will

00:38:11.440 --> 00:38:14.420
allow on their data and what it
means for them to change a

00:38:14.420 --> 00:38:16.610
piece of data.

00:38:16.610 --> 00:38:20.980
Yes, you can bring users down to
one model of mutating data

00:38:20.980 --> 00:38:24.180
and what that semantic
is for mutation.

00:38:24.180 --> 00:38:27.230
And you can constrain the set of
things that they will then

00:38:27.230 --> 00:38:29.680
reasonably be able to do in
the app without hitting

00:38:29.680 --> 00:38:31.970
synchronization issues
based on this policy.

00:38:31.970 --> 00:38:35.710
You could do that, but I don't
feel like it's our job as a

00:38:35.710 --> 00:38:39.570
platform right now to make that
kind of a call in quite

00:38:39.570 --> 00:38:40.280
such a closed way.

00:38:40.280 --> 00:38:41.930
Because I don't think that we've
got the experience in

00:38:41.930 --> 00:38:43.730
our community for that's
the right thing to do.

00:38:43.730 --> 00:38:46.055
I can tell you right now that
that would not work for Gmail.

00:38:46.055 --> 00:38:47.880
It honestly would not
work for Gmail.

00:38:47.880 --> 00:38:48.850
It wouldn't work for Sync.

00:38:48.850 --> 00:38:50.050
It wouldn't have worked
for Wave.

00:38:50.050 --> 00:38:51.420
It doesn't work for Plus.

00:38:51.420 --> 00:38:53.120
It won't fly.

00:38:53.120 --> 00:38:55.220
ANDREW BETTIS: Mark, can you
tell us why Twitter doesn't

00:38:55.220 --> 00:38:57.770
currently use offline?

00:38:57.770 --> 00:38:59.974
MARK CHRISTIAN: Well, Twitter's
web platform is in a

00:38:59.974 --> 00:39:01.320
bit of flux.

00:39:01.320 --> 00:39:03.660
We're moving towards
a server as the

00:39:03.660 --> 00:39:04.660
ultimate source of truth.

00:39:04.660 --> 00:39:07.730
So we actually don't do any
client side rendering at all.

00:39:07.730 --> 00:39:11.400
So any navigation event, even
though it's happening AJAXly,

00:39:11.400 --> 00:39:14.090
is actually just injecting a
response from the server.

00:39:14.090 --> 00:39:18.070
So you can't really cache that
nearly as efficiently as you

00:39:18.070 --> 00:39:20.550
could a series of JSON
responses, for example,

00:39:20.550 --> 00:39:22.460
because they're full-page
responses.

00:39:22.460 --> 00:39:26.630
So not every AJAX model is going
to work as well with

00:39:26.630 --> 00:39:29.480
that sort of a strategy.

00:39:29.480 --> 00:39:31.280
Whether that changes
in the future, TBD.

00:39:31.280 --> 00:39:35.670
But basically, two competing
styles of how you want to have

00:39:35.670 --> 00:39:37.780
a fast responsive app, you have
something that lives on

00:39:37.780 --> 00:39:39.940
the server, something that lives
entirely on the client.

00:39:39.940 --> 00:39:43.790
And having something that can
react to both is actually a

00:39:43.790 --> 00:39:45.420
messy, terrible proposition
right now.

00:39:48.270 --> 00:39:51.090
JAKE ARCHIBALD: The way we did
that at Lanyard was we were

00:39:51.090 --> 00:39:55.590
rendering on the server with
Mustache and some data.

00:39:55.590 --> 00:39:57.320
And then when we were doing the
same on the client with

00:39:57.320 --> 00:40:00.170
offline, we were using the same
Mustache templates, and

00:40:00.170 --> 00:40:04.180
we were caching the same data
model in local storage, the

00:40:04.180 --> 00:40:04.870
same as you were.

00:40:04.870 --> 00:40:07.850
And obviously we'd rather be
doing that in AppCache.

00:40:07.850 --> 00:40:12.170
So yeah, you can still do the
progressive enhancement thing

00:40:12.170 --> 00:40:14.650
and have a client-based
app, and you're not

00:40:14.650 --> 00:40:16.260
duplicating too much data.

00:40:16.260 --> 00:40:21.940
And did anyone see the "B&amp;B"
article recently where they

00:40:21.940 --> 00:40:25.270
were talking about, hey, we've
decided to try this new,

00:40:25.270 --> 00:40:26.150
exciting idea.

00:40:26.150 --> 00:40:27.900
And what we're going to do is
we're going to render content

00:40:27.900 --> 00:40:30.810
on the server, and we're
going to send out an

00:40:30.810 --> 00:40:33.170
HTML string of content.

00:40:33.170 --> 00:40:34.710
And it's amazingly fast.

00:40:34.710 --> 00:40:35.960
You guys should all
be doing this.

00:40:38.470 --> 00:40:41.320
Yeah, we've been calling that
progressive enhancement.

00:40:41.320 --> 00:40:43.340
MARK CHRISTIAN: Well, that's
sort of our model too.

00:40:43.340 --> 00:40:46.145
Twitter's famously, remember,
the hashbang website a couple

00:40:46.145 --> 00:40:47.010
of years ago.

00:40:47.010 --> 00:40:49.750
It was actually pretty speedy
if you were on a MacBook Pro

00:40:49.750 --> 00:40:50.940
with the latest version
of Chrome.

00:40:50.940 --> 00:40:55.335
But if you were using IE7 in
Bangalore, it was actually an

00:40:55.335 --> 00:40:56.310
atrocious experience.

00:40:56.310 --> 00:40:58.600
And so the server side model
ends up working a lot better

00:40:58.600 --> 00:40:59.700
on the low end.

00:40:59.700 --> 00:41:03.080
And the problem with having two
rendering stacks, even if

00:41:03.080 --> 00:41:06.120
they're sharing templates, is
that you've got quirks between

00:41:06.120 --> 00:41:07.380
your view implementation.

00:41:07.380 --> 00:41:09.700
And that is a great way to kill
yourself with 1,000 paper

00:41:09.700 --> 00:41:12.210
cuts, especially if you're on
a large dev team with a few

00:41:12.210 --> 00:41:15.006
dozen developers trying to
keep it all in sync.

00:41:15.006 --> 00:41:16.210
JAKE ARCHIBALD: No, I completely
agree with that.

00:41:16.210 --> 00:41:18.190
Because we were using Mustache,
and we ended up

00:41:18.190 --> 00:41:22.610
pretty much owning, or making
massive contributions to about

00:41:22.610 --> 00:41:24.950
four different implementations
of Mustache the Python one,

00:41:24.950 --> 00:41:30.150
the Java one, the IOS one,
and the JavaScript one.

00:41:30.150 --> 00:41:31.090
MARK CHRISTIAN: There's one
developer at Twitter who's

00:41:31.090 --> 00:41:33.180
single-handedly written
two from scratch--

00:41:33.180 --> 00:41:34.590
Hogan and Eckersley--

00:41:34.590 --> 00:41:37.310
just because most of the
implementations had

00:41:37.310 --> 00:41:38.240
some sort of issue.

00:41:38.240 --> 00:41:39.910
ANDREW BETTIS: So are you
saying, then, that the only

00:41:39.910 --> 00:41:42.150
real use case for offline
technologies is when you

00:41:42.150 --> 00:41:44.320
actually want to build an
offline app rather than to

00:41:44.320 --> 00:41:45.970
improve the performance
of your app?

00:41:45.970 --> 00:41:48.220
MARK CHRISTIAN: Well,
application versus website--

00:41:48.220 --> 00:41:51.210
it's the same thing I
mentioned earlier.

00:41:51.210 --> 00:41:53.060
I feel like the offline
technologies are really good

00:41:53.060 --> 00:41:55.410
for building an app, like
the Lanyard thing.

00:41:55.410 --> 00:41:58.530
But they don't really map very
well towards a Twitter or even

00:41:58.530 --> 00:42:00.490
a Wikipedia kind of example.

00:42:00.490 --> 00:42:02.140
They just don't feel like a very
good fit for something

00:42:02.140 --> 00:42:04.840
where you're always pulling
in new data, and it's an

00:42:04.840 --> 00:42:06.990
unbounded amount of content
that you might

00:42:06.990 --> 00:42:08.300
want to pull in.

00:42:08.300 --> 00:42:09.270
JAKE ARCHIBALD: If you're
just looking to improve

00:42:09.270 --> 00:42:12.860
performance, that's what
the HTTP cache is for.

00:42:12.860 --> 00:42:16.740
The application cache is for
caching applications--

00:42:16.740 --> 00:42:19.630
it's for making it
work offline.

00:42:19.630 --> 00:42:22.160
If you can get a performance
benefit out of using it, then

00:42:22.160 --> 00:42:22.800
fair enough.

00:42:22.800 --> 00:42:28.822
But you are buying into making
an offline-first experience.

00:42:28.822 --> 00:42:31.960
ALEX RUSSELL: To be clear,
though, the new proposal would

00:42:31.960 --> 00:42:33.720
be a reasonable accelerator.

00:42:33.720 --> 00:42:35.870
If you don't ever handle any
navigation events but only

00:42:35.870 --> 00:42:40.130
resources, you could certainly
build a local high performance

00:42:40.130 --> 00:42:44.260
cache system to improve website
performance without

00:42:44.260 --> 00:42:47.240
biting off any offline
capability at all.

00:42:47.240 --> 00:42:48.680
ANDREW BETTIS: In what situation
would you want to do

00:42:48.680 --> 00:42:52.790
that versus using
the HTTP cache?

00:42:52.790 --> 00:42:54.410
ALEX RUSSELL: We've had good
input from the folks at

00:42:54.410 --> 00:42:57.610
Facebook that this is their core
use case for AppCache, is

00:42:57.610 --> 00:42:59.015
actually making things--

00:42:59.015 --> 00:42:59.880
or not a core.

00:42:59.880 --> 00:43:02.430
One of their most important use
cases was making things

00:43:02.430 --> 00:43:05.090
available faster.

00:43:05.090 --> 00:43:10.570
And at Google, I know that our
global teams have had similar

00:43:10.570 --> 00:43:12.660
needs, and AppCache
hasn't met them.

00:43:12.660 --> 00:43:15.505
So hopefully this new API
will meet those two.

00:43:15.505 --> 00:43:18.610
JONAS SICKING: Yeah, I think the
mental model that I've had

00:43:18.610 --> 00:43:23.340
recently is that it would be
great if we can make it work

00:43:23.340 --> 00:43:26.640
so that the online case
is very similar

00:43:26.640 --> 00:43:28.640
to the offline case.

00:43:28.640 --> 00:43:33.830
It's more a difference between
are you seeing controller

00:43:33.830 --> 00:43:36.710
slash app cache or you're not.

00:43:36.710 --> 00:43:40.950
So if we can make it so that
when you are using these new

00:43:40.950 --> 00:43:44.710
features for enabling offline
but you happen to be online,

00:43:44.710 --> 00:43:49.310
you can still download the data
and just download the

00:43:49.310 --> 00:43:53.300
data part and not the template
and the static content and use

00:43:53.300 --> 00:43:56.160
that cached version of that
increase performance.

00:43:56.160 --> 00:44:00.040
I'm definitely hoping that that
is a model we can get to,

00:44:00.040 --> 00:44:03.770
to basically make the online
application experience be more

00:44:03.770 --> 00:44:06.740
competitive with native--
where on native you're

00:44:06.740 --> 00:44:09.220
downloading your shell once.

00:44:09.220 --> 00:44:11.610
And then as you're using it,
you're just downloading the

00:44:11.610 --> 00:44:13.140
incremental data.

00:44:13.140 --> 00:44:15.920
We should be able to make the
same thing possible on the web

00:44:15.920 --> 00:44:17.170
to increase performance.

00:44:19.220 --> 00:44:21.840
JAKE ARCHIBALD: So the HTTP
cache is like this really busy

00:44:21.840 --> 00:44:23.700
room, and everyone's in there.

00:44:23.700 --> 00:44:26.840
And the browser's having to be
the bouncer at the door.

00:44:26.840 --> 00:44:30.430
And when other people want into
the room, the bouncer's

00:44:30.430 --> 00:44:34.020
going, look, you've had
too much to drink.

00:44:34.020 --> 00:44:35.220
You should get out.

00:44:35.220 --> 00:44:38.670
And then what Facebook have done
is gone, ah, but there's

00:44:38.670 --> 00:44:41.580
this quieter bar around
the corner.

00:44:41.580 --> 00:44:43.160
We're going to go there.

00:44:43.160 --> 00:44:45.920
But the thing is, if everyone
starts doing that, then that

00:44:45.920 --> 00:44:47.920
bar is going to have to hire a
bouncer, and they're going to

00:44:47.920 --> 00:44:50.000
start kicking people
out as well.

00:44:50.000 --> 00:44:52.260
It seems like a nice performance
enhancement now.

00:44:52.260 --> 00:44:53.922
But I think if everyone started
using it, we're going

00:44:53.922 --> 00:44:56.180
to get the same issues where if
everyone's stuffing fonts

00:44:56.180 --> 00:44:59.080
and images into local storage,
there's going to have to be a

00:44:59.080 --> 00:45:02.630
bouncer there that kicks
people out-- unless the

00:45:02.630 --> 00:45:04.190
website asked for a
permanent cache.

00:45:04.190 --> 00:45:07.030
But I don't think we want a
web where you just visit

00:45:07.030 --> 00:45:08.570
Facebook because you want to
look at a thing, and it's

00:45:08.570 --> 00:45:11.370
saying, Facebook wants to
install 5 megabytes worth of

00:45:11.370 --> 00:45:13.330
stuff just so you can see it.

00:45:13.330 --> 00:45:15.630
It's not for an offline
experience, it's just to look

00:45:15.630 --> 00:45:16.710
at the site.

00:45:16.710 --> 00:45:17.750
MARK CHRISTIAN: The interesting
characteristic

00:45:17.750 --> 00:45:21.330
about using AppCache for storing
the outer shell is

00:45:21.330 --> 00:45:24.640
that it lets you have a cache
where it's totally happy to

00:45:24.640 --> 00:45:26.680
start rendering the page with
the old version, without even

00:45:26.680 --> 00:45:28.140
going to see if there's
a new one.

00:45:28.140 --> 00:45:30.890
And that's something that HTTP
caching could theoretically be

00:45:30.890 --> 00:45:33.150
modified to have but doesn't.

00:45:33.150 --> 00:45:35.740
And it's an interesting
characteristic all its own.

00:45:35.740 --> 00:45:39.750
HTTP caching in general is best
described as bewildering.

00:45:39.750 --> 00:45:41.940
There's just so many options,
and it never quite does what

00:45:41.940 --> 00:45:42.910
you expect.

00:45:42.910 --> 00:45:45.340
And with all of AppCache's
problems, one thing that we

00:45:45.340 --> 00:45:47.790
can say is at least we can
expect that the data will be

00:45:47.790 --> 00:45:49.394
there when we ask
for it again.

00:45:54.010 --> 00:45:55.510
JONAS SICKING: I don't think the
bar around the corner is

00:45:55.510 --> 00:45:58.350
necessarily going to get
as packed as the

00:45:58.350 --> 00:46:01.210
initial HTTP cache bar.

00:46:01.210 --> 00:46:05.770
Because if we are good enough
at building the heuristics

00:46:05.770 --> 00:46:08.470
where maybe we don't download
AppCache the first time you

00:46:08.470 --> 00:46:09.250
visit a website.

00:46:09.250 --> 00:46:13.000
But if we see that you visit a
website every day, then we'll

00:46:13.000 --> 00:46:16.260
download the AppCache and we'll
keep it more tightly.

00:46:16.260 --> 00:46:20.820
So I think if we're more clever
than we are with HTTP

00:46:20.820 --> 00:46:24.840
cache, then I think we
can keep the good

00:46:24.840 --> 00:46:25.950
people in that bar.

00:46:25.950 --> 00:46:28.110
ANDREW BETTIS: Why do we need
another bar at all?

00:46:28.110 --> 00:46:31.800
Just hypothetically, why do we
not just have an extra cache

00:46:31.800 --> 00:46:34.450
control directive that gives
enhanced persistence within

00:46:34.450 --> 00:46:35.970
the HTTP cache?

00:46:35.970 --> 00:46:38.735
ALEX RUSSELL: I try to rephrase
this as, why is there

00:46:38.735 --> 00:46:39.985
no priority system?

00:46:39.985 --> 00:46:42.630
Why is their no user expressible
and collaborative

00:46:42.630 --> 00:46:43.770
priority system?

00:46:43.770 --> 00:46:46.730
So many of the cases where we
wind up fighting the browser

00:46:46.730 --> 00:46:50.590
as developers are cases where if
we could express our intent

00:46:50.590 --> 00:46:53.120
more clearly to the browser, the
browser could collaborate

00:46:53.120 --> 00:46:55.150
with the user to have
a better experience

00:46:55.150 --> 00:46:57.010
provided in many cases.

00:46:57.010 --> 00:47:00.180
We could then use the browser
to help express to the user,

00:47:00.180 --> 00:47:01.850
hey, this is what we're
trying to do here.

00:47:01.850 --> 00:47:05.460
And if you say to the browser,
listen, these resources are

00:47:05.460 --> 00:47:07.720
really dear to me, these are
slightly less dear, and these

00:47:07.720 --> 00:47:11.800
are totally ephemeral, I don't
really need them--

00:47:11.800 --> 00:47:19.160
the work that the folks are
doing on Quota API for the

00:47:19.160 --> 00:47:22.370
file system points in this
direction, where you're

00:47:22.370 --> 00:47:24.300
getting to a point where you can
start to collaborate with

00:47:24.300 --> 00:47:26.300
the system and say listen, these
are really important to

00:47:26.300 --> 00:47:27.515
me, these are less important.

00:47:27.515 --> 00:47:30.190
And I don't think we need to
back ourselves into hard

00:47:30.190 --> 00:47:33.780
guarantees, as long as we're
able to say that, by default,

00:47:33.780 --> 00:47:37.910
you're in the less privileged
group until you ask for a

00:47:37.910 --> 00:47:40.600
privilege, in which case you
take on responsibility to

00:47:40.600 --> 00:47:41.840
collaborate.

00:47:41.840 --> 00:47:42.690
You might be evicted.

00:47:42.690 --> 00:47:44.520
You might get events about
whether or not eviction is

00:47:44.520 --> 00:47:46.620
about to happen, and maybe you
should offer up some other

00:47:46.620 --> 00:47:49.050
thing to remove or try to remove
stuff for yourself.

00:47:49.050 --> 00:47:51.430
This is a well-worn path in
a lot of other operating

00:47:51.430 --> 00:47:55.330
systems, where you'll say,
hey, dear plug-in or dear

00:47:55.330 --> 00:47:57.240
application, we're running
low on storage.

00:47:57.240 --> 00:47:59.010
Can you please clean
some stuff up?

00:47:59.010 --> 00:48:02.570
Or where the OS tries to clean
things up for you if it winds

00:48:02.570 --> 00:48:03.710
up under pressure.

00:48:03.710 --> 00:48:05.250
At that point, you have to
have a conversation.

00:48:05.250 --> 00:48:07.480
And today we have no way to
have that conversation.

00:48:07.480 --> 00:48:09.620
So it's not that we necessarily
need a different

00:48:09.620 --> 00:48:12.420
bar or a different bouncer, but
I think those are just one

00:48:12.420 --> 00:48:15.070
way of saying we need multiple
levels of collaboration and

00:48:15.070 --> 00:48:17.520
cooperation, and we don't have
any of that right now.

00:48:17.520 --> 00:48:20.900
MARK CHRISTIAN: This goes to the
philosophical web idea of

00:48:20.900 --> 00:48:22.070
the user agent knows best.

00:48:22.070 --> 00:48:24.110
Even when we talk about some
of the new ideas, there's

00:48:24.110 --> 00:48:25.960
these heuristics on caching.

00:48:25.960 --> 00:48:28.780
And we've never really decided
to empower the app developer

00:48:28.780 --> 00:48:30.240
to have much of a say in this.

00:48:30.240 --> 00:48:31.145
ALEX RUSSELL: Well,
let's be clear.

00:48:31.145 --> 00:48:33.640
The user agent is in control.

00:48:33.640 --> 00:48:35.930
It may not know best, but it's
certainly in control, because

00:48:35.930 --> 00:48:38.400
we're putting users in control
of their system and their

00:48:38.400 --> 00:48:39.150
experience.

00:48:39.150 --> 00:48:44.250
So the imperative for the user
agent to have the last say is

00:48:44.250 --> 00:48:45.980
all about giving users
the last say.

00:48:45.980 --> 00:48:49.660
And so that's an inviolable
principle of a safe web.

00:48:49.660 --> 00:48:52.210
The answer was, well, shouldn't
we just count on

00:48:52.210 --> 00:48:53.030
everyone being nice?

00:48:53.030 --> 00:48:54.992
And the answer is,
no, advertisers.

00:48:54.992 --> 00:48:57.770
Duh.

00:48:57.770 --> 00:48:59.520
MARK CHRISTIAN: It's still a
very different model than

00:48:59.520 --> 00:49:00.500
native apps, though.

00:49:00.500 --> 00:49:02.940
And I'm not saying it's a
bad model, but it's just

00:49:02.940 --> 00:49:05.040
interesting that native apps
don't have the same set of

00:49:05.040 --> 00:49:05.700
constraints on them.

00:49:05.700 --> 00:49:08.500
Once they're on the app, then
they can do all of these

00:49:08.500 --> 00:49:09.510
things within the sandbox.

00:49:09.510 --> 00:49:11.520
And in general, the sandbox that
you'll get on a native

00:49:11.520 --> 00:49:15.030
platform is very much wider than
the sandbox that you'll

00:49:15.030 --> 00:49:16.830
get as a random website.

00:49:16.830 --> 00:49:19.240
JONAS SICKING: Yeah, but there's
still a very big

00:49:19.240 --> 00:49:21.770
difference from a random website
and a native app.

00:49:21.770 --> 00:49:25.630
Within a native app, the user
has made a decision that I

00:49:25.630 --> 00:49:30.410
care about this app, at the very
least enough to bother

00:49:30.410 --> 00:49:32.300
with download time.

00:49:32.300 --> 00:49:36.220
But it's even more to the point
that the user has said,

00:49:36.220 --> 00:49:40.560
I trust this website to
do a lot of things.

00:49:40.560 --> 00:49:42.640
Most native apps can take
over your system.

00:49:42.640 --> 00:49:45.970
So the user has clearly
indicated that there's some

00:49:45.970 --> 00:49:46.460
amount of trust.

00:49:46.460 --> 00:49:50.560
And so we can't really ever give
the random website that

00:49:50.560 --> 00:49:53.390
the user's visiting the first
time the same amount of trust

00:49:53.390 --> 00:49:54.830
as a native app has.

00:49:54.830 --> 00:49:58.570
But this is where I think this
smooth transition from going

00:49:58.570 --> 00:50:01.790
from untrusted to trusted
needs to happen.

00:50:01.790 --> 00:50:03.380
ANDREW BETTIS: Is it ever
reasonable that you could

00:50:03.380 --> 00:50:05.410
visit a random website and it
could prompt you saying, this

00:50:05.410 --> 00:50:07.350
website wants to completely take
over your computer, do

00:50:07.350 --> 00:50:08.360
you want to allow this?

00:50:08.360 --> 00:50:10.880
ALEX RUSSELL: Sure, we
have that today.

00:50:10.880 --> 00:50:16.370
JONAS SICKING: I don't think we
should have the question to

00:50:16.370 --> 00:50:19.450
the user, click the yes button
if you want your system

00:50:19.450 --> 00:50:21.340
entirely taken over, click
the no button if not.

00:50:21.340 --> 00:50:24.520
Because some people will click
the yes button not knowing

00:50:24.520 --> 00:50:25.010
what their doing.

00:50:25.010 --> 00:50:28.520
So we need to be more
careful than that.

00:50:28.520 --> 00:50:30.840
ALEX RUSSELL: I like to think
about this as what are you

00:50:30.840 --> 00:50:32.050
getting back for friction?

00:50:32.050 --> 00:50:35.350
So in native apps, there's
much more friction to

00:50:35.350 --> 00:50:37.120
discovery and use.

00:50:37.120 --> 00:50:40.360
I have to know that I want it
or be told that I want it or

00:50:40.360 --> 00:50:44.120
be advertised to as something I
should want and then go buy

00:50:44.120 --> 00:50:46.140
it off the friction of
finding this thing.

00:50:46.140 --> 00:50:48.370
Whereas the web has this amazing
model where there's a

00:50:48.370 --> 00:50:52.490
zero friction to navigate
and use a new thing.

00:50:52.490 --> 00:50:53.590
Identity is a problem.

00:50:53.590 --> 00:50:55.920
We've got a lot of other things
which add incidental

00:50:55.920 --> 00:50:58.700
friction over time, but
generally speaking, we have

00:50:58.700 --> 00:51:03.020
paid application developers back
1,000 fold for putting

00:51:03.020 --> 00:51:05.480
something on the web by reducing
the friction to using

00:51:05.480 --> 00:51:07.090
to almost nothing.

00:51:07.090 --> 00:51:09.310
And native app models induce
this friction.

00:51:09.310 --> 00:51:12.850
And I think that Jonas is
entirely correct that that

00:51:12.850 --> 00:51:15.620
smooth transition needs to get
you to a point where in order

00:51:15.620 --> 00:51:17.520
to get the same capabilities
that you would give to a

00:51:17.520 --> 00:51:19.560
native app, you have to have
the same level of friction.

00:51:19.560 --> 00:51:24.020
Because the constraints that you
impose at those points are

00:51:24.020 --> 00:51:28.010
reasonable, and both sets of
system authors have made

00:51:28.010 --> 00:51:29.810
choices about which constraints
are going to

00:51:29.810 --> 00:51:34.190
impose at each level of friction
under all the same

00:51:34.190 --> 00:51:35.070
considerations.

00:51:35.070 --> 00:51:38.990
They're saying, if you browse to
an ephemeral web page, then

00:51:38.990 --> 00:51:41.120
you get whatever level
of effort you put

00:51:41.120 --> 00:51:42.220
into browsing there.

00:51:42.220 --> 00:51:45.630
And if you install something,
you get maybe more privilege

00:51:45.630 --> 00:51:47.970
and more process available
to you.

00:51:47.970 --> 00:51:49.360
And I think that's
the right model.

00:51:49.360 --> 00:51:52.210
And so yeah, I think that's
going to be the endpoint, is

00:51:52.210 --> 00:51:53.760
well, it will have that
much friction.

00:51:53.760 --> 00:51:55.820
And having that much friction
will get you that much.

00:51:55.820 --> 00:51:56.850
MARK CHRISTIAN: The smooth
gradient's a really

00:51:56.850 --> 00:51:57.660
interesting model.

00:51:57.660 --> 00:52:00.620
But I just think that as we're
designing new APIs, we should

00:52:00.620 --> 00:52:03.780
make sure that we actually try
to figure out, what does that

00:52:03.780 --> 00:52:04.750
smooth gradient look like?

00:52:04.750 --> 00:52:07.980
And how can we make the APIs
flexible enough to have a

00:52:07.980 --> 00:52:10.210
difference between it's either
working completely or it

00:52:10.210 --> 00:52:12.010
doesn't work at all?

00:52:12.010 --> 00:52:13.840
ANDREW BETTIS: I think we should
probably move on and

00:52:13.840 --> 00:52:16.190
talk about what we can do today
rather than what we

00:52:16.190 --> 00:52:16.990
should be doing tomorrow.

00:52:16.990 --> 00:52:22.030
So one of the most popular
questions we have is--

00:52:22.030 --> 00:52:24.730
a lot of people are stuffing
fonts, images, and JavaScript

00:52:24.730 --> 00:52:26.660
in local storage for
fasting loading.

00:52:26.660 --> 00:52:31.590
Should we be discouraging
this, which is something

00:52:31.590 --> 00:52:32.160
[INAUDIBLE]

00:52:32.160 --> 00:52:33.460
was saying at [INAUDIBLE]

00:52:33.460 --> 00:52:34.810
and us as well.

00:52:34.810 --> 00:52:38.340
So what would you say
to that, Alex?

00:52:38.340 --> 00:52:39.400
ALEX RUSSELL: Is it
working for you?

00:52:39.400 --> 00:52:42.410
If so, go for it.

00:52:42.410 --> 00:52:44.750
I mean, I come from a dirty
JavaScript hacker background.

00:52:44.750 --> 00:52:47.170
Man, if it works, run.

00:52:47.170 --> 00:52:48.100
Run with it as far as it goes.

00:52:48.100 --> 00:52:48.590
But measure.

00:52:48.590 --> 00:52:49.390
Measure, measure, measure.

00:52:49.390 --> 00:52:52.030
If it's actually faster,
heck yes.

00:52:52.030 --> 00:52:52.890
Make the web faster.

00:52:52.890 --> 00:52:54.600
Go, do it.

00:52:54.600 --> 00:52:57.020
ANDREW BETTIS: So do we need
to be aware of what pain

00:52:57.020 --> 00:52:58.620
that's storing up for
us in the future?

00:52:58.620 --> 00:53:01.850
And how much pain is that
storing up for us in future?

00:53:01.850 --> 00:53:02.280
ALEX RUSSELL: A lot.

00:53:02.280 --> 00:53:07.490
So let me tell you
all about it.

00:53:07.490 --> 00:53:11.630
So you'll notice if you're
stuffing a lot of stuff into

00:53:11.630 --> 00:53:14.960
local storage that you'll see
some really strange behavioral

00:53:14.960 --> 00:53:19.110
differences between IE9 and 10,
and Firefox and Chrome,

00:53:19.110 --> 00:53:23.100
with regards to potentially
getting out of sync across

00:53:23.100 --> 00:53:26.050
tabs or across Windows with
regards to try to communicate

00:53:26.050 --> 00:53:27.120
over a local storage.

00:53:27.120 --> 00:53:28.300
Well, why is that?

00:53:28.300 --> 00:53:30.460
Local storage is a
synchronous API.

00:53:30.460 --> 00:53:33.510
This is generally speaking in
terms of web API design a

00:53:33.510 --> 00:53:34.960
terrible, terrible thing.

00:53:34.960 --> 00:53:36.010
This is a bad thing.

00:53:36.010 --> 00:53:39.450
It's the reason that IndexDB
is coming along--

00:53:39.450 --> 00:53:41.790
which is available, I think, in
IE10 and it's available in

00:53:41.790 --> 00:53:44.187
Chrome and it's coming along
in other places, too.

00:53:44.187 --> 00:53:45.350
JAKE ARCHIBALD: Another
terrible, terrible thing.

00:53:45.350 --> 00:53:45.660
ALEX RUSSELL: I know.

00:53:45.660 --> 00:53:48.230
It's harder to use, right?

00:53:48.230 --> 00:53:49.310
So that was the pain.

00:53:49.310 --> 00:53:55.190
So that pain generated this new
system which isn't widely

00:53:55.190 --> 00:53:56.860
enough deployed yet.

00:53:56.860 --> 00:54:02.090
And so folks find out that
there's an implicit cross tab

00:54:02.090 --> 00:54:05.765
synchronization issue with local
storage because the API

00:54:05.765 --> 00:54:07.890
is synchronous for all the tabs
that can see the same

00:54:07.890 --> 00:54:08.740
local store.

00:54:08.740 --> 00:54:09.730
This isn't great.

00:54:09.730 --> 00:54:11.010
This is actually relatively
terrible.

00:54:11.010 --> 00:54:12.920
So we need an asynchronous
version of local storage.

00:54:12.920 --> 00:54:14.720
So one of these you're biting
off is a huge performance

00:54:14.720 --> 00:54:17.420
issue because you'll start
loading your web page, you'll

00:54:17.420 --> 00:54:20.900
ask local storage early in the
document load to go grab you

00:54:20.900 --> 00:54:22.770
some resource, and you
think it's fast.

00:54:22.770 --> 00:54:25.040
Except we're brand
new to this.

00:54:25.040 --> 00:54:27.630
We might have put this in a
SQLite database on a per local

00:54:27.630 --> 00:54:29.540
store or per origin basis.

00:54:29.540 --> 00:54:32.350
We have to go do synchronize IO
to go load that database,

00:54:32.350 --> 00:54:34.790
block that web page, by the way,
while we're doing this,

00:54:34.790 --> 00:54:38.250
block the main thread, go do a
bunch of IO, and then give you

00:54:38.250 --> 00:54:39.780
the answer.

00:54:39.780 --> 00:54:41.040
This is terrible for
performance.

00:54:41.040 --> 00:54:41.910
ANDREW BETTIS: OK, so I get it.

00:54:41.910 --> 00:54:42.195
I get it.

00:54:42.195 --> 00:54:42.690
It's painful.

00:54:42.690 --> 00:54:46.030
So should we just not do it
and wait for this amazing

00:54:46.030 --> 00:54:47.450
navigation controller
to appear?

00:54:47.450 --> 00:54:48.590
ALEX RUSSELL: No, you
should measure.

00:54:48.590 --> 00:54:49.920
You should measure,
measure, measure.

00:54:49.920 --> 00:54:51.950
And once you've measured, you'll
have an answer about

00:54:51.950 --> 00:54:52.960
whether or not it's
better or worse.

00:54:52.960 --> 00:54:54.210
But you won't until
you measure.

00:54:57.550 --> 00:54:59.390
JONAS SICKING: So I
think there's two

00:54:59.390 --> 00:55:01.430
separate questions here.

00:55:01.430 --> 00:55:05.010
Taking resources and storing
them locally on the client

00:55:05.010 --> 00:55:09.790
side, I think, it's a good
workaround to do until we get

00:55:09.790 --> 00:55:14.990
things like this controller
thing, until we fix AppCache,

00:55:14.990 --> 00:55:17.800
until we get other mechanisms in
place that actually make it

00:55:17.800 --> 00:55:20.610
a pleasurable experience to
develop these solutions.

00:55:25.970 --> 00:55:30.850
So the local storage issue of
being asynchronous API--

00:55:30.850 --> 00:55:32.840
please to measure it, but it's
actually really, really hard

00:55:32.840 --> 00:55:33.230
to measure.

00:55:33.230 --> 00:55:39.030
The problem is that what a lot
of asynchronous IO, which A,

00:55:39.030 --> 00:55:41.320
is very, very dependent
on a device.

00:55:41.320 --> 00:55:42.460
You can't measure it locally.

00:55:42.460 --> 00:55:46.700
You need to measure it on
your users' devices.

00:55:46.700 --> 00:55:51.850
The other problem is that it's
not a performance hit that

00:55:51.850 --> 00:55:54.100
happens every time you
use local storage.

00:55:54.100 --> 00:55:57.650
It happens probably the
first time you see it.

00:55:57.650 --> 00:55:59.370
And even just like calling--

00:55:59.370 --> 00:56:01.270
we've had some benchmarks that
the first thing it does, it

00:56:01.270 --> 00:56:03.480
calls localStorage.clear
and then it

00:56:03.480 --> 00:56:04.875
starts using local storage.

00:56:04.875 --> 00:56:07.020
But at the time you called the
localStorage.clear, that's

00:56:07.020 --> 00:56:08.920
actually when the performance
hit happens.

00:56:08.920 --> 00:56:11.030
Local storage, I would say,
is hard enough to measure

00:56:11.030 --> 00:56:12.970
performance of that
you probably

00:56:12.970 --> 00:56:13.940
will not get it right.

00:56:13.940 --> 00:56:18.540
What we're doing in Firefox at
22, 21 or something is we're

00:56:18.540 --> 00:56:20.880
actually going to pre-load local
storage before we're

00:56:20.880 --> 00:56:22.310
even running scripts.

00:56:22.310 --> 00:56:23.790
So that performance hit
is not something

00:56:23.790 --> 00:56:25.410
you can't even measure.

00:56:25.410 --> 00:56:28.320
And the reason we're doing that
is because hopefully in

00:56:28.320 --> 00:56:31.800
those cases, we can do this
IO before we're even

00:56:31.800 --> 00:56:34.200
attempting to use it.

00:56:34.200 --> 00:56:39.130
It does have the effect that
we're going to do more IO for

00:56:39.130 --> 00:56:43.330
each and every page on your
website as soon as you use

00:56:43.330 --> 00:56:44.540
local storage.

00:56:44.540 --> 00:56:49.860
But that's to avoid halting
the thread and having your

00:56:49.860 --> 00:56:52.700
site look up while you're
doing this IO.

00:56:52.700 --> 00:56:55.890
So local storage's performance
is really, really tricky.

00:56:55.890 --> 00:57:00.350
So IndexDB has issues.

00:57:00.350 --> 00:57:02.040
Those are, in big
part, my fault.

00:57:02.040 --> 00:57:05.130
I'm one of the editors
for that spec.

00:57:05.130 --> 00:57:07.650
We do need something like
asynchronous local storage,

00:57:07.650 --> 00:57:10.520
which is as simple as local
storage but doesn't have the

00:57:10.520 --> 00:57:12.190
synchronous problem.

00:57:12.190 --> 00:57:15.480
So that hopefully
will come soon.

00:57:15.480 --> 00:57:18.600
ALEX RUSSELL: I'm hoping
for that, too.

00:57:18.600 --> 00:57:23.260
ANDREW BETTIS: OK, so in the
meantime, do you think that

00:57:23.260 --> 00:57:28.380
the fact that developers love
local storage and don't like

00:57:28.380 --> 00:57:32.730
APIs like IndexDB is an
indication that we need to

00:57:32.730 --> 00:57:39.035
simplify IndexDB and Web SQL
and those sort of APIs?

00:57:39.035 --> 00:57:40.010
ALEX RUSSELL: Yes, absolutely.

00:57:40.010 --> 00:57:42.800
So one of the things that I've
been working on over the last

00:57:42.800 --> 00:57:46.540
couple of months is to add
a futures primitive.

00:57:46.540 --> 00:57:48.740
So you might have promises
in your libraries.

00:57:48.740 --> 00:57:50.980
We're just going to ignore the
fight over what it means to

00:57:50.980 --> 00:57:51.530
have a promise.

00:57:51.530 --> 00:57:52.490
We're going to call
it a future.

00:57:52.490 --> 00:57:53.410
It's a different thing.

00:57:53.410 --> 00:57:54.160
Same API.

00:57:54.160 --> 00:57:57.010
.then, and then you can add
whatever callbacks you want to

00:57:57.010 --> 00:57:59.520
success and failure,
accept or reject.

00:57:59.520 --> 00:58:00.060
OK, cool.

00:58:00.060 --> 00:58:03.010
So we're building a spec for
futures for DOM, so we can

00:58:03.010 --> 00:58:06.460
start to reinterpret a lot of
these asynchronous things in a

00:58:06.460 --> 00:58:07.490
more unified way.

00:58:07.490 --> 00:58:09.760
Because events aren't really the
right model for something

00:58:09.760 --> 00:58:12.170
that is a single request.

00:58:12.170 --> 00:58:14.390
If I get one thing out of local
storage, I'm only asking

00:58:14.390 --> 00:58:15.040
for one thing back.

00:58:15.040 --> 00:58:17.940
I'm not asking for a potential
stream of things to happen

00:58:17.940 --> 00:58:19.750
zero or more times in
the future, which

00:58:19.750 --> 00:58:20.540
is the event model.

00:58:20.540 --> 00:58:25.370
So I have hope that we'll be
able to build a saner version

00:58:25.370 --> 00:58:28.090
of a lot of these APIs to stop
using events and stop using

00:58:28.090 --> 00:58:32.810
implicit asynchronicity and end
of term behavior and make

00:58:32.810 --> 00:58:36.440
it much more explicit in the
APIs, do an asynchronous local

00:58:36.440 --> 00:58:40.820
storage on top of something like
this, and then Web Crypto

00:58:40.820 --> 00:58:45.700
and IndexDB, I think all these
APIs can be retrofitted with

00:58:45.700 --> 00:58:48.240
this model so that we get a
much more rational API.

00:58:48.240 --> 00:58:51.620
I think a lot of this is down to
the APIs not really having

00:58:51.620 --> 00:58:53.090
great idioms baked into them.

00:58:53.090 --> 00:58:55.330
And it's one of these
traditional DOM versus the

00:58:55.330 --> 00:58:58.000
rest of the JavaScript world
discussions, which I'm happy

00:58:58.000 --> 00:59:00.440
to talk to you about over
beer endlessly.

00:59:00.440 --> 00:59:01.840
ANDREW BETTIS: So how long
until we get navigation

00:59:01.840 --> 00:59:03.090
controller?

00:59:07.510 --> 00:59:09.770
JAKE ARCHIBALD: I'm not taking
responsibility for that.

00:59:09.770 --> 00:59:14.510
JONAS SICKING: So the space of
fixing the AppCache where

00:59:14.510 --> 00:59:19.770
navigation controller is a very
interesting proposal is

00:59:19.770 --> 00:59:24.200
something that for some reason
we had a very, very hard time

00:59:24.200 --> 00:59:26.940
actually getting to the point
of having proposals.

00:59:26.940 --> 00:59:29.810
I would say we've been working
on this for well over a year

00:59:29.810 --> 00:59:33.390
and a half, probably two years,
on just people ranting

00:59:33.390 --> 00:59:35.820
about how much AppCache
sucks, but there has

00:59:35.820 --> 00:59:36.870
not been any proposals.

00:59:36.870 --> 00:59:38.180
There are now two proposals.

00:59:38.180 --> 00:59:39.700
There's the controller thing.

00:59:39.700 --> 00:59:42.760
Mozilla also has a proposal that
we're hopefully going to

00:59:42.760 --> 00:59:45.660
present very soon.

00:59:45.660 --> 00:59:47.930
And I think that's an enormously
good first step.

00:59:47.930 --> 00:59:52.550
What we need to do once we have
these proposals is to get

00:59:52.550 --> 00:59:54.370
feedback from everyone
that has been

00:59:54.370 --> 00:59:55.620
complaining about AppCache.

00:59:59.180 --> 01:00:01.810
The two proposals are actually
very complementary, so they

01:00:01.810 --> 01:00:04.980
actually combine very well.

01:00:04.980 --> 01:00:06.530
If you had these two
things, would

01:00:06.530 --> 01:00:07.930
that solve your problems?

01:00:07.930 --> 01:00:11.670
Or would this just be
a less sucky way?

01:00:11.670 --> 01:00:15.080
So we have a very
good first step.

01:00:15.080 --> 01:00:17.930
It will take a little bit to
get this stuff implemented,

01:00:17.930 --> 01:00:22.530
but I think it'll take a lot
less than the well over a year

01:00:22.530 --> 01:00:26.050
that we've been complaining
about AppCache.

01:00:26.050 --> 01:00:29.470
JAKE ARCHIBALD: So on the
simple APIs, do we build

01:00:29.470 --> 01:00:32.060
something really low level and
maybe a bit more complicated

01:00:32.060 --> 01:00:33.475
to deal with, or do
we just try and go

01:00:33.475 --> 01:00:35.660
as simple as possible?

01:00:35.660 --> 01:00:38.850
We want something as simple
as possible, but look what

01:00:38.850 --> 01:00:39.950
happened to AppCache.

01:00:39.950 --> 01:00:42.440
They made something that was
really, really simple, but

01:00:42.440 --> 01:00:44.830
they didn't know what people
really wanted to do with it,

01:00:44.830 --> 01:00:46.295
so they made some things
simple and useless.

01:00:48.980 --> 01:00:52.847
Whereas with local storage, that
was the simple and easy

01:00:52.847 --> 01:00:55.290
to use but had massive
performance problems.

01:00:55.290 --> 01:00:58.150
So I like the world where you
might have something like

01:00:58.150 --> 01:01:01.130
IndexDB, where it's what you can
do with it-- there's loads

01:01:01.130 --> 01:01:02.090
you can do with it--

01:01:02.090 --> 01:01:04.000
but then have a look at what
the use cases are.

01:01:04.000 --> 01:01:06.570
See what code you see people
repeating over and over.

01:01:06.570 --> 01:01:08.790
What are people using libraries
for, and how can we

01:01:08.790 --> 01:01:09.910
get that into the problem?

01:01:09.910 --> 01:01:11.730
You see that happening
with the DOM now.

01:01:11.730 --> 01:01:13.960
querySelectorAll was one
of those things.

01:01:13.960 --> 01:01:15.010
We see jQuery doing it.

01:01:15.010 --> 01:01:17.930
We can make jQuery faster by
having that on the platform,

01:01:17.930 --> 01:01:20.370
and people maybe wouldn't
have to use jQuery

01:01:20.370 --> 01:01:21.570
if that's the case.

01:01:21.570 --> 01:01:24.580
So that's what I see going
with the navigation

01:01:24.580 --> 01:01:25.290
controller.

01:01:25.290 --> 01:01:28.920
Some of the code that I showed
on there was stuff I made up.

01:01:28.920 --> 01:01:31.460
There was a routing function,
which is something that

01:01:31.460 --> 01:01:33.800
probably won't be there in the
initial spec, but it's

01:01:33.800 --> 01:01:36.420
something you can create
yourself or something a

01:01:36.420 --> 01:01:39.380
library can give you.

01:01:39.380 --> 01:01:43.110
And we'll be able to see what
people are doing and if

01:01:43.110 --> 01:01:45.950
there's common patterns or a lot
of repeated code, then we

01:01:45.950 --> 01:01:49.150
can put that in the platform and
make it quicker and make

01:01:49.150 --> 01:01:50.406
it less typing.

01:01:50.406 --> 01:01:52.600
MARK CHRISTIAN: Yeah, we can
trust that libraries will come

01:01:52.600 --> 01:01:52.790
into existence.

01:01:52.790 --> 01:01:54.920
It's something that we can
rely on on the web.

01:01:54.920 --> 01:01:58.310
So we should build for
flexibility instead of stupid

01:01:58.310 --> 01:02:00.600
simplicity.

01:02:00.600 --> 01:02:01.760
ANDREW BETTIS: Well,
we're out of time.

01:02:01.760 --> 01:02:03.000
So thanks, everyone.

01:02:03.000 --> 01:02:03.900
And that's the end
of the panel.

01:02:03.900 --> 01:02:10.500
[APPLAUSE]

