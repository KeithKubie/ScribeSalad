WEBVTT
Kind: captions
Language: en

00:00:02.510 --> 00:00:09.269
&gt;&gt;Susannah Raub: Welcome. This talk is how
Maps API v3 came to be; tips, tricks, and

00:00:09.269 --> 00:00:14.120
lessons learned in developing across-platform
desktop and mobile API.

00:00:14.120 --> 00:00:21.120
My colleague, oh, before I start I would like
to remind you that we will have, you can follow

00:00:23.369 --> 00:00:29.250
LiveNotes and ask questions about this session
on GoogleWave at this highly intuitive bitly

00:00:29.250 --> 00:00:36.250
URL here: CNQIOK.
So, I'm Susannah Raub. I'm a developer on

00:00:37.699 --> 00:00:41.510
the Google Maps API v3.
This is my colleague, Marc Ridey.

00:00:41.510 --> 00:00:42.159
&gt;&gt;Marc: Hello.

00:00:42.159 --> 00:00:47.219
&gt;&gt;Susannah Raub: And the real star of the
show is the Maps API v3 who graduated from

00:00:47.219 --> 00:00:51.460
labs just yesterday.
So, big congratulations to, to our little

00:00:51.460 --> 00:00:51.989
marker friend here.

00:00:51.989 --> 00:00:52.649
[Applause]

00:00:52.649 --> 00:00:58.769
&gt;&gt;Susannah Raub: And we're going to share
with you today things that we've learned in

00:00:58.769 --> 00:01:03.709
developing this API so that it runs well on
both desktop and mobile devices.

00:01:03.709 --> 00:01:09.400
This really was designed first for mobile.
The whole point of the project was to work

00:01:09.400 --> 00:01:13.710
well on mobiles.
So, we're going to start by talking about

00:01:13.710 --> 00:01:20.510
latency; the impact of it, the causes of it,
defining it, reducing it. Then, share with

00:01:20.510 --> 00:01:23.700
you our architecture we've used, mostly to
combat latency.

00:01:23.700 --> 00:01:29.030
I'll then hand it over to Marc to share with
you some of the technologies that we've studied

00:01:29.030 --> 00:01:33.230
and used in developing this to work on each
platform.

00:01:33.230 --> 00:01:38.850
And he'll also talk some about debugging on
Android mobile devices.

00:01:38.850 --> 00:01:41.730
[pause]

00:01:41.730 --> 00:01:46.300
So, in getting started, I'm going to share
with you some background on why we're here

00:01:46.300 --> 00:01:52.230
today with the experience of the Maps API
one year ago.

00:01:52.230 --> 00:01:59.230
So taking you back to April 2009, this is
your map.

00:01:59.530 --> 00:02:02.310
[pause]

00:02:02.310 --> 00:02:09.310
I'll stop it there. And so, after about 17
seconds, we finally have finished downloading

00:02:19.629 --> 00:02:26.359
175 kilobytes of uncompressed JavaScript and
four, if we're very lucky, but normally six

00:02:26.359 --> 00:02:31.260
images to render that map.
In those 17 seconds, if I was better prepared,

00:02:31.260 --> 00:02:36.090
I could have gone, made a coffee, maybe come
back, but probably found else to do; not a

00:02:36.090 --> 00:02:39.779
very good user experience.
This is really what we call "latency." Let

00:02:39.779 --> 00:02:46.329
me back up and define it first.
There are a few kinds of latency. First, there's

00:02:46.329 --> 00:02:49.029
"user-perceived latency."
This is the time until the page appears to

00:02:49.029 --> 00:02:53.099
be usable.
In our case, this is when the map tiles, the

00:02:53.099 --> 00:02:57.480
map imagery has loaded.
At this point, the user can look at the map

00:02:57.480 --> 00:03:03.060
and start processing what's happening.
It seems to be usable.

00:03:03.060 --> 00:03:06.400
Next is "page ready time." This is when it
really is usable.

00:03:06.400 --> 00:03:11.760
And this, for us, is when the map is zoomable
and draggable; so, when the user can actually

00:03:11.760 --> 00:03:16.680
interact with it.
And we separate these, because the user can

00:03:16.680 --> 00:03:20.310
start to figure out what they're going to
do with the page.

00:03:20.310 --> 00:03:23.680
It takes a moment to process what's going
to happen; what they're going to do before

00:03:23.680 --> 00:03:26.489
they actually start doing it, before they
started dragging.

00:03:26.489 --> 00:03:31.120
Preferably we want that draggable, that zooming
capability, to be there when they actually

00:03:31.120 --> 00:03:35.549
start to use it.
Then, there's "page load time." And this is

00:03:35.549 --> 00:03:40.430
the time until all elements are present.
We've really focused on reducing user-perceived

00:03:40.430 --> 00:03:45.579
latency and the page ready time.
The page load time that we consider in there

00:03:45.579 --> 00:03:51.059
is having all the controls loaded, being able
to load other things like directions and other

00:03:51.059 --> 00:03:56.469
components of the map.
On the desktop, we can measure latency using

00:03:56.469 --> 00:04:01.340
tools like HttpWatch in both Internet Explorer
and Firefox.

00:04:01.340 --> 00:04:06.680
It gives us a breakdown of each request, how
much time it takes, where the time is spent

00:04:06.680 --> 00:04:12.659
between waiting for the server, downloading,
whether the request has been processed by

00:04:12.659 --> 00:04:16.989
the cache or not.
And it's really given us a good understanding

00:04:16.989 --> 00:04:21.780
and we've been able to optimize a lot of things
over the years since the beginning of Maps

00:04:21.780 --> 00:04:28.780
and v2 -- Maps API v2. By using tools like
HttpWatch to understand the sources of latency.

00:04:31.260 --> 00:04:35.950
But, for any of you who've developed a mobile,
you're probably well aware that desktop and

00:04:35.950 --> 00:04:40.670
mobile just aren't the same.
There's different causes of latency on the

00:04:40.670 --> 00:04:43.550
mobile, and we need different tools to measure
it.

00:04:43.550 --> 00:04:47.190
There's, we can take what we've learned from
the desktop and apply a lot of it to mobile

00:04:47.190 --> 00:04:54.190
devices, but not all of it.
So, for understanding why it was taking 17

00:04:56.690 --> 00:05:03.410
seconds to load the API, we had to set up
a new system to do that; not just using HttpWatch.

00:05:03.410 --> 00:05:10.190
We noticed that loading the map took a really
long time, not just over the 3G network that

00:05:10.190 --> 00:05:15.540
has high latency, but also over wireless.
So, we knew that it wasn't just the network

00:05:15.540 --> 00:05:18.930
speed that was impacting the speed of our
map loading.

00:05:18.930 --> 00:05:25.930
So to figure out what was going on, we used
the iPhone configuration tool and were able

00:05:26.310 --> 00:05:31.490
to connect via a proxy server we had running
outside of our Corp network so that we could

00:05:31.490 --> 00:05:37.520
access it on the 3G network.
We have a Fiddler proxy running on that server

00:05:37.520 --> 00:05:42.290
that all requests go through and that we can
watch in Fiddler what's happening with each

00:05:42.290 --> 00:05:45.250
request.
So this graph that I'm showing you, this chart

00:05:45.250 --> 00:05:51.700
that I'm showing you here, is the breakdown
of the Maps API v3 loads.

00:05:51.700 --> 00:05:58.560
So you can see between Lines 3 and 4, this
is the time that our big JavaScript file is

00:05:58.560 --> 00:06:02.680
downloading.
It's not 175 kilobytes uncompressed anymore,

00:06:02.680 --> 00:06:06.570
but it's still -- this is the time that it's
loading, it's parsing, it's executing -- 

00:06:06.570 --> 00:06:11.590
before we begin to download our static imagery.
So what did we find?

00:06:11.590 --> 00:06:18.330
We found that there is some overhead in downloading
 -- or in parsing -- loading and parsing each

00:06:18.330 --> 00:06:22.990
JavaScript file.
Plus some amount of time it takes to parse

00:06:22.990 --> 00:06:29.990
and load it based on its size.
So, this chart is showing you that as the

00:06:30.900 --> 00:06:37.900
file size increases, the amount of time to
load and parse is increasing, but the network

00:06:38.710 --> 00:06:42.650
time isn't necessarily; it's reflected in
that, but we don't believe that's the major

00:06:42.650 --> 00:06:45.490
source here.
We believe it's time taken on the phone; that

00:06:45.490 --> 00:06:51.220
it's due to the limited CPU resources for
this JavaScript to parse.

00:06:51.220 --> 00:06:53.860
It is very dependent, though, on the hardware
and the OS.

00:06:53.860 --> 00:06:59.000
So, I have two charts here -- one on some
older -- on an older iPhone running a slightly

00:06:59.000 --> 00:07:03.090
outdated OS.
And we see that the time decreases on newer

00:07:03.090 --> 00:07:07.240
hardware on a newer OS.
The important thing here, though, is that

00:07:07.240 --> 00:07:11.610
this is much improved from last year where
we were seeing a bigger overhead and a bigger

00:07:11.610 --> 00:07:16.710
time but milliseconds per kilobyte load and
parse time.

00:07:16.710 --> 00:07:22.430
So, things are improving.
But, with discovering that the size of the

00:07:22.430 --> 00:07:27.230
JavaScript really matters, that we really
see this linear increase, potentially even

00:07:27.230 --> 00:07:34.230
exponential increase in loading and parsing
larger files. We've needed to reduce the size.

00:07:35.330 --> 00:07:40.880
And we were doing this, but for you writing
your applications, you're going to use the

00:07:40.880 --> 00:07:44.960
compilers that exist to greatly reduce your
code size.

00:07:44.960 --> 00:07:50.440
They optimize for code size reduction by doing
things like obfuscating property names.

00:07:50.440 --> 00:07:56.220
So you can continue to use your beautiful,
readable, verbose, well-named, good style,

00:07:56.220 --> 00:08:03.220
variable names, but not have that impact the
size of your final download by using a compiler

00:08:04.250 --> 00:08:08.639
that's going to make them all short; make
them A and B and C.

00:08:08.639 --> 00:08:15.420
The compilers also are a fantastic thing for
error checking and for helping you use good

00:08:15.420 --> 00:08:20.350
practices in writing your JavaScript.
Some of these that exist are Closure, GWT,

00:08:20.350 --> 00:08:25.690
the Google Web Toolkit, as well as a number
of other ones that you can find out more about

00:08:25.690 --> 00:08:29.380
online.
The other thing that they do is, many of them

00:08:29.380 --> 00:08:35.340
have built-in module, or fragment systems
that will split your JavaScript into multiple

00:08:35.340 --> 00:08:40.270
components so that you can download only the
parts that you need instead of the big download

00:08:40.270 --> 00:08:44.770
all at once.
That said, we want to reduce the number of

00:08:44.770 --> 00:08:47.850
downloads.
So, we don't want to just put all of our components

00:08:47.850 --> 00:08:52.090
into little tiny JavaScript files.
Remember, there's an overhead on a mobile

00:08:52.090 --> 00:08:58.230
device for each download.
So -- and a common technique for images is

00:08:58.230 --> 00:09:01.279
image spriting.
Instead of downloading these three marker

00:09:01.279 --> 00:09:08.279
images, we can put them all in one image and
crop them in the browser using divs.

00:09:08.750 --> 00:09:14.960
With JavaScript -- we want to -- after we've
split things into our modules, we want to

00:09:14.960 --> 00:09:18.510
then combine them back together.
When we know that two components are going

00:09:18.510 --> 00:09:22.000
to always be used together; they're better
off being served as one.

00:09:22.000 --> 00:09:29.000
When we started bundling some of our modules,
we saw huge latency improvement on the mobile

00:09:29.610 --> 00:09:33.550
devices.
So, instead of downloading three requests

00:09:33.550 --> 00:09:39.240
for 15 to 25 kilobytes, we want to just download
one that's 57 kilobytes.

00:09:39.240 --> 00:09:46.240
This is in the example of our API.
Now, caching is one of our favorite techniques

00:09:48.370 --> 00:09:53.000
for reducing latency; not having to make a
round trip to the server, just accessing data

00:09:53.000 --> 00:09:57.190
from the browser's cache.
But, mobiles are far more constrained than

00:09:57.190 --> 00:10:01.950
desktops when it comes to caching.
Their file size restrictions, the total size

00:10:01.950 --> 00:10:05.310
of the cache, is limited.
And maybe, most importantly, they're cleared

00:10:05.310 --> 00:10:09.089
much more frequently.
For example, on the iPhone, when you close

00:10:09.089 --> 00:10:12.450
every tab in Safari and close Safari, it clears
the cache.

00:10:12.450 --> 00:10:19.450
For our API, we really depend on caching.
We expect that, because the API is quite popular,

00:10:19.950 --> 00:10:25.160
that people may visit one site and download
the JavaScript and tiles.

00:10:25.160 --> 00:10:29.960
And then, when they visit another site, those
files and images are already in their cache

00:10:29.960 --> 00:10:33.930
or in some cache near them -- a server cache
near them.

00:10:33.930 --> 00:10:38.890
With mobile, we can no longer depend on that.
We need to make things fast as if they're

00:10:38.890 --> 00:10:42.100
always downloading our files for the first
time.

00:10:42.100 --> 00:10:47.240
Fortunately, the cache, as well as the parsing
time for JavaScript, the cache is also improving

00:10:47.240 --> 00:10:52.240
with each OS and hardware release.
A year ago, we were seeing things that the

00:10:52.240 --> 00:10:59.240
iPhone could cache up to 20 items of no more
than 25 kilobytes uncompressed in its cache.

00:11:00.220 --> 00:11:05.680
Now, we're caching many more files and many
larger files.

00:11:05.680 --> 00:11:10.640
Things are looking up.
Next, though, you can -- as an alternative

00:11:10.640 --> 00:11:15.920
to the cache -- if you can't count on that
data being there, there's the HTML5 database.

00:11:15.920 --> 00:11:22.029
It's great for static files, because it allows
you to store data for your site on the phone

00:11:22.029 --> 00:11:24.730
itself.
It's not great for dynamic content however,

00:11:24.730 --> 00:11:29.320
and it's not easy to use cross-domain.
So, for our API, we've looked into it and

00:11:29.320 --> 00:11:33.960
it doesn't make much sense for us because
we're always changing our versions and we're

00:11:33.960 --> 00:11:39.240
running cross-domain -- everything we do is
cross-domain -- that -- not the solution for

00:11:39.240 --> 00:11:46.240
us, but a great idea for regular applications
out there on the web.

00:11:46.330 --> 00:11:51.690
So now, we'll share with you some of the architecture
choices we've made to reduce latency.

00:11:51.690 --> 00:11:58.690
We recall that it took, to download that initial
map, 175 kilobytes of uncompressed JavaScript

00:12:00.740 --> 00:12:04.370
and six images.
There's two things we need to improve there:

00:12:04.370 --> 00:12:10.990
We would like to request fewer images and
we'd like to request them earlier.

00:12:10.990 --> 00:12:17.820
The way that our API works, we need the full
interface to download -- that full library

00:12:17.820 --> 00:12:24.360
to download -- with all of the classes and
methods the developer can call.

00:12:24.360 --> 00:12:30.839
And then, once that has downloaded, the developer
can create a map, set the center and zoom

00:12:30.839 --> 00:12:34.010
and map type, and at that point, we can start
downloading images.

00:12:34.010 --> 00:12:39.550
That's a lot to happen.
And because that interface to get -- just

00:12:39.550 --> 00:12:46.550
to create a G Map 2 and sender and set zoom
 -- that needs to come with the full 175 kilobytes.

00:12:47.000 --> 00:12:52.050
And we've made this promise to developers
of this large, synchronous, public interface.

00:12:52.050 --> 00:12:58.490
There's a lot of classes and a lot of methods
in the API, and many of them, when you call

00:12:58.490 --> 00:13:03.050
some method, you expect some other piece of
data available right then synchronously.

00:13:03.050 --> 00:13:06.790
So changing that contract was really our real
limitation.

00:13:06.790 --> 00:13:13.790
So, the full sequence here of what happens
 -- we download what we call the "bootstrap."

00:13:13.890 --> 00:13:18.540
This is what then specifies what version 
-- either specified or the latest version

00:13:18.540 --> 00:13:23.460
of the API is that we're going to download.
Then, we download that full interface library.

00:13:23.460 --> 00:13:29.440
Then, we download the rest of the users or
the developer's page.

00:13:29.440 --> 00:13:34.060
We then need to wait for the map to be initialized.
And, at that point, we can load images.

00:13:34.060 --> 00:13:38.750
Then, we load everything else -- the drag
initialization or the controls -- other things

00:13:38.750 --> 00:13:43.520
on the map.
So, we need to make that last blue part --

00:13:43.520 --> 00:13:49.040
 that load images -- much earlier, or shrink
the size of those steps before it.

00:13:49.040 --> 00:13:52.860
And that was our goal in developing Maps API
v3.

00:13:52.860 --> 00:13:59.270
What we chose to do is use a Model-View-Controller
architecture -- MVC.

00:13:59.270 --> 00:14:05.810
In this pattern, the models store state synchronously
and that's all they do.

00:14:05.810 --> 00:14:11.660
We then have views that are responsible for
rendering that state.

00:14:11.660 --> 00:14:18.160
And that can all be done asynchronously --
 meaning, they can all be downloaded later

00:14:18.160 --> 00:14:21.770
in the pipeline.
We then have controllers that are go-betweens

00:14:21.770 --> 00:14:26.020
between them.
I won't spend too much time talking about

00:14:26.020 --> 00:14:27.790
them.
So, our initial download in v3 only contains

00:14:27.790 --> 00:14:31.680
these models.
And then, the views and the controllers are

00:14:31.680 --> 00:14:34.940
loaded on demand.
This means that, if you never create a marker,

00:14:34.940 --> 00:14:40.630
we only have put a few hundred bytes in the
API that just give you the interface for the

00:14:40.630 --> 00:14:46.050
marker but no actual marker functionality.
So, it looks like this.

00:14:46.050 --> 00:14:50.940
Here's an example of the marker.
Oh, and -- so, the models that we put in that

00:14:50.940 --> 00:14:54.690
first download are things like the Map, the
Marker, the InfoWindow.

00:14:54.690 --> 00:14:58.040
Those are all examples of models.
If you've developed a V3, you're familiar

00:14:58.040 --> 00:15:03.720
with these classes -- they are simple -- 
what we call "MVC objects" that set and get

00:15:03.720 --> 00:15:08.709
properties and do nothing else.
So, with the marker, it has a position.

00:15:08.709 --> 00:15:13.940
It's in lat/long space.
The view works in pixel space and all it does

00:15:13.940 --> 00:15:18.490
is render things in the DOM.
But that's the bulk of the code with the marker

00:15:18.490 --> 00:15:23.550
is calculating where it should be positioned
in the DOM and styling it correctly and all

00:15:23.550 --> 00:15:26.430
the things that go along with creating image
elements.

00:15:26.430 --> 00:15:32.050
We have a controller that sits between these
two things that converts between the lat/long

00:15:32.050 --> 00:15:36.709
space and the pixel space, meaning that this
view is totally independent of anything having

00:15:36.709 --> 00:15:39.830
to do with the map.
It really -- we could have this marker view

00:15:39.830 --> 00:15:46.190
be totally unrelated to a map.
Or say, put it in a Street View object and

00:15:46.190 --> 00:15:50.149
render it exactly the same, because all it
does is render images in a div.

00:15:50.149 --> 00:15:56.210
So -- and this works on an event-based system
 -- so, when we set the position on the marker

00:15:56.210 --> 00:16:00.640
 -- on the marker model, it then triggers
an event to the position controller.

00:16:00.640 --> 00:16:06.690
The position controller has the right inputs
to convert that from a lat/long to a pixel

00:16:06.690 --> 00:16:10.690
position.
It then sets its own pixel position which

00:16:10.690 --> 00:16:16.350
triggers an event on the marker view.
And the marker view can then position itself

00:16:16.350 --> 00:16:19.810
in the DOM.
This means that, as the developer, you called

00:16:19.810 --> 00:16:23.810
set position. We then did all this behind-the-scene
stuff, which was all asynchronous -- you don't

00:16:23.810 --> 00:16:26.930
really care.
You'll then get notified if we change the

00:16:26.930 --> 00:16:32.209
position again with one of those same events.
But there's no need to have a lot of synchronous

00:16:32.209 --> 00:16:39.209
functionality here.
So, in the end, the marker is very small,

00:16:39.519 --> 00:16:43.290
having limited -- just setters and getters
 -- limited functionality.

00:16:43.290 --> 00:16:49.740
And you get events when things do change.
So, the next thing we need to optimize --

00:16:49.740 --> 00:16:56.740
 and this -- the MVC architecture allowed
us, with an interface almost as large as v2's

00:16:58.279 --> 00:17:03.640
 -- to reduce that 175 kilobytes uncompressed
to 32 kilobytes uncompressed.

00:17:03.640 --> 00:17:08.720
Which compressed is about 11 or 12 kilobytes
that you download in order for us to get your

00:17:08.720 --> 00:17:13.079
center, your zoom, your map type, so that
we can start rendering the map.

00:17:13.079 --> 00:17:17.850
The other thing that we have living in our
main.js -- that we call it -- that first download,

00:17:17.850 --> 00:17:22.799
the big one -- is, code to render a single
map tile.

00:17:22.799 --> 00:17:27.049
We use our static map server, that when you
set the center and the zoom and the map type

00:17:27.049 --> 00:17:31.480
 -- because you can do that once you download
that first component -- that main.js -- once

00:17:31.480 --> 00:17:36.040
you've set those we contact our static map
server, get a map to fit exactly your div,

00:17:36.040 --> 00:17:40.360
and load that one first.
And then, fill in on top of it the regular

00:17:40.360 --> 00:17:46.410
tiles that allow for the infinite zooming.
So, instead of downloading to get that map

00:17:46.410 --> 00:17:51.559
to appear initially -- instead of downloading
six images of about 25 kilobytes each -- 

00:17:51.559 --> 00:17:57.500
we download one image that's 40 kilobytes.
This cuts a few seconds off of our load time.

00:17:57.500 --> 00:18:04.500
It brings what would be probably seven to
eight seconds down to four or five seconds

00:18:04.630 --> 00:18:10.240
for that user-perceived latency on a mobile
device.

00:18:10.240 --> 00:18:14.710
Now, it's great to study this in a controlled
environment and to study latency.

00:18:14.710 --> 00:18:19.620
We also -- it's very important for us to measure
this in the real world.

00:18:19.620 --> 00:18:26.620
We track how long our maps take so that we
can see the impact of certain changes on latency

00:18:28.570 --> 00:18:33.900
and see what our users are actually experiencing;
see when things make it, see when changes

00:18:33.900 --> 00:18:38.610
make it better and see when it makes it worse.
So, we see here, in a few months time, we

00:18:38.610 --> 00:18:45.610
saw our small maps get faster and our big
maps maybe get slower.

00:18:45.710 --> 00:18:51.500
This graph that I'm showing you -- the upper
line for very little traffic compared to the

00:18:51.500 --> 00:18:53.210
lower line.
So, it's hard to know exactly what's going

00:18:53.210 --> 00:18:55.390
on.
But this shows us we need to spend more time

00:18:55.390 --> 00:19:02.390
with big maps on an iPhone perhaps.
Another way to reduce latency is to pre-fetch

00:19:03.620 --> 00:19:07.460
 -- that, when you know a user is going to
do something and they're going to do something

00:19:07.460 --> 00:19:12.530
soon, to pre-fetch that data -- to load it
in the background -- so it's ready when you

00:19:12.530 --> 00:19:15.520
want to use it.
This is great for latency.

00:19:15.520 --> 00:19:20.470
Remember though, it can be bad for users 
-- particularly users not in the U.S.

00:19:20.470 --> 00:19:24.950
They may have limited or expensive data.
And they don't really like it when sites start

00:19:24.950 --> 00:19:29.220
downloading a lot of stuff in the background.
It can also slow down other things that are

00:19:29.220 --> 00:19:32.049
going on in the site.
So pre-fetch with caution.

00:19:32.049 --> 00:19:38.520
Pre-fetch when it is highly likely that somebody
is going to want to use this content.

00:19:38.520 --> 00:19:43.370
With that, I'm going to turn over the mic
to Marc Ridey, my colleague on the Maps API

00:19:43.370 --> 00:19:47.549
v3 team, who's going to take you through some
of the technologies that we've been studying

00:19:47.549 --> 00:19:48.590
and using.

00:19:48.590 --> 00:19:54.860
&gt;&gt;Marc Ridey: Okay. So, technology -- I'm
going to talk to you about graphics, geolocation,

00:19:54.860 --> 00:20:01.720
and touch and mouse events.
Graphics technology -- you have quite a range

00:20:01.720 --> 00:20:08.210
of graphics technology available.
There is Scalable Vector Graphics, VML.

00:20:08.210 --> 00:20:13.210
There is Canvas, Canvas 2D, Canvas 3D.
There is CSS Transform.

00:20:13.210 --> 00:20:17.460
The problem with those technologies is really
that you haven't got all of them on every

00:20:17.460 --> 00:20:20.000
browser.
You have a mix of support between browsers.

00:20:20.000 --> 00:20:23.030
You have a mix of support between applying
systems.

00:20:23.030 --> 00:20:26.640
Touch events and mouse events are supported
on some browsers and not on others.

00:20:26.640 --> 00:20:31.460
So you have to adapt.
The main point is that you're going to have

00:20:31.460 --> 00:20:37.990
to create different path for your sites --
 different ways of rendering things -- and

00:20:37.990 --> 00:20:43.299
take the most appropriate one, depending on
the type of browsers that you're facing.

00:20:43.299 --> 00:20:50.299
So, we use a lot of graphics-intensive capabilities
in the polys, StreetView and in some of our

00:20:50.580 --> 00:20:53.669
controls -- the compass control, for example.
So, I'm going to talk about some of those

00:20:53.669 --> 00:20:56.860
things.
And I'm going to go through and trying to

00:20:56.860 --> 00:21:01.010
give you a bit of an idea of where this different
technologies fits -- what the good things

00:21:01.010 --> 00:21:05.230
and the bad things are about them -- and where
they are supported.

00:21:05.230 --> 00:21:10.919
So, let's start with Scalar Vector Graphics.
So, Scalar Vector Graphics is great for rendering

00:21:10.919 --> 00:21:17.919
polyline, polygons, 2D vector information.
It's quite fast. It has a lot of advantages.

00:21:19.809 --> 00:21:25.400
It's retain mode, which means that if you
load data into an SVG control, it will remember

00:21:25.400 --> 00:21:28.660
it.
And if you need to modify the thickness of

00:21:28.660 --> 00:21:34.260
a line, you just find that line element, change
the thickness attribute, and the display will

00:21:34.260 --> 00:21:38.910
be changed.
It's quite fast once the model is loaded.

00:21:38.910 --> 00:21:43.750
Because it's DOM-based, it actually has very
good mouse event support.

00:21:43.750 --> 00:21:48.970
So, if you click on a sub-element of an SVG
control, you'll get a click event that tells

00:21:48.970 --> 00:21:52.760
you exactly which element has been clicked.
So, if you have a number of polygons on your

00:21:52.760 --> 00:21:56.650
screen and you click on one, it will tell
you that that particular polygon has been

00:21:56.650 --> 00:21:58.929
clicked, and it gives you the location of
the polygon.

00:21:58.929 --> 00:22:05.290
So, all this is great -- good mouse support,
good DOM support, good fast support for polyline,

00:22:05.290 --> 00:22:07.700
polygon.
The trade-off is that if you want to work

00:22:07.700 --> 00:22:10.780
with images, well, it's not really designed
to work with images.

00:22:10.780 --> 00:22:16.780
You can do transforms for images, but the
performance is really a bit bad.

00:22:16.780 --> 00:22:21.750
It's also opaque to mouse events.
So, if you have a very large SVG control,

00:22:21.750 --> 00:22:26.100
you can't really receive mouse events behind
it, even if it's transparent.

00:22:26.100 --> 00:22:30.730
So that also creates some problems if you
place an SVG element in the middle of your

00:22:30.730 --> 00:22:36.090
screen.
Support-wise -- it's supported by Firefox,

00:22:36.090 --> 00:22:42.950
by Safari, by Chrome, but it's not supported
by Android and it's not supported by Internet

00:22:42.950 --> 00:22:47.360
Explorer.
So, for Internet Explorer, where you have

00:22:47.360 --> 00:22:49.669
DNA on that, they both appear about the same
time.

00:22:49.669 --> 00:22:53.620
I don't remember which one came first.
And I don't know if it's Microsoft that started

00:22:53.620 --> 00:22:57.110
to make a different SVG or SVG simplified
VML.

00:22:57.110 --> 00:23:01.570
Not sure, I think there's some arguments there,
but they work the same way.

00:23:01.570 --> 00:23:04.470
The syntax is a bit different, but they're
both DOM-based.

00:23:04.470 --> 00:23:07.330
They're both retain mode.
They both have similar mouse supports.

00:23:07.330 --> 00:23:12.500
So, in a sense, what we find in our code is
we have a lot of common code between SVG and

00:23:12.500 --> 00:23:15.450
VML.
And when we dictate that it's IE, we render

00:23:15.450 --> 00:23:18.570
the information in VML.
When we dictate that it's not IE, we render

00:23:18.570 --> 00:23:22.679
it in SVG.
So very similar programming pattern there.

00:23:22.679 --> 00:23:28.630
The nice thing about VML and SVG is that you
can either create that data through JavaScript;

00:23:28.630 --> 00:23:35.630
create elements and then set attributes, or
you can directly create a lot of HTML, a string

00:23:36.470 --> 00:23:40.440
that define your whole SVG or VML element,
and load that into your browser.

00:23:40.440 --> 00:23:46.549
So you can pre-prepare the data service site
and fit it as part of your page.

00:23:46.549 --> 00:23:51.070
So, when you have to do more image-intensive
work, you're left with Canvas.

00:23:51.070 --> 00:23:54.970
So Canvas 2D -- it's fairly fast for manipulating
images.

00:23:54.970 --> 00:24:00.350
You can transform images; you can crop images.
So, quite good.

00:24:00.350 --> 00:24:03.240
It's not really designed to do polyline and
is polygons.

00:24:03.240 --> 00:24:07.580
It can do it, but the problem with Canvas
is that it's not retain mode.

00:24:07.580 --> 00:24:13.870
So, it means that, if I draw a hundred polygons,
I have to make thousands of calls to Canvas

00:24:13.870 --> 00:24:18.730
to say, "Start here, draw there, draw there,
draw there, draw there, draw there," and so

00:24:18.730 --> 00:24:20.480
on.
And "move there and draw again and move there

00:24:20.480 --> 00:24:23.919
and draw again."
If I want to change one small attribute or

00:24:23.919 --> 00:24:28.620
the position of one point, it's like a piece
of paper -- erase everything, and draw the

00:24:28.620 --> 00:24:32.250
whole thing again.
So you don't really have the capability of

00:24:32.250 --> 00:24:35.690
being able to modify a small part of your
Canvas.

00:24:35.690 --> 00:24:41.460
The other part is, because it's a big piece
of paper, you have no mouse support.

00:24:41.460 --> 00:24:45.260
In a sense that, if somebody clicks on the
Canvas, you'll get a message that says "The

00:24:45.260 --> 00:24:50.539
Canvas has been clicked, and this is the xy-position."
If you've got a hundred polygons that have

00:24:50.539 --> 00:24:54.130
been drawn, you're going to have to find,
in JavaScript, which polygon was clicked,

00:24:54.130 --> 00:24:56.870
based on you're going to have to do your own
hit test.

00:24:56.870 --> 00:25:03.080
There's no support in Canvas for click event
support.

00:25:03.080 --> 00:25:06.260
Browser-wise, it's well supported.
Only Internet Explorer doesn't support it.

00:25:06.260 --> 00:25:13.260
So, it's not bad.
Performance is -- really depends on browser

00:25:13.570 --> 00:25:18.120
and on the plotting systems.
I'll show you later a table of the statistics

00:25:18.120 --> 00:25:21.600
I extracted in my work on StreetView, and
you'll see that you can't take things for

00:25:21.600 --> 00:25:25.410
granted, even when you look at a single browser
and think that the performance is going to

00:25:25.410 --> 00:25:29.799
be the same across all the plotting system.
It's really not the case.

00:25:29.799 --> 00:25:33.950
So, if you have to do something fast, do it
in Canvas 3D.

00:25:33.950 --> 00:25:38.860
That would be great, but it's only supported
on 19 bit at the moment.

00:25:38.860 --> 00:25:43.750
But it's fast. It is extremely fast. It's
retain mode.

00:25:43.750 --> 00:25:47.450
You load all your geometry in WebGL and you
can access it.

00:25:47.450 --> 00:25:50.820
You can modify it.
You don't really have to continuously, like

00:25:50.820 --> 00:25:56.500
in Canvas 2D, redraw everything.
The mouse support is just as bad as Canvas

00:25:56.500 --> 00:25:58.870
2D.
You will know that your Canvas has been clicked,

00:25:58.870 --> 00:26:00.830
but you don't really know where it's been
clicked.

00:26:00.830 --> 00:26:07.830
So, it has its good and its bad.
Now, CSS Transforms -- it doesn't completely

00:26:10.549 --> 00:26:16.250
belong in this category, but you can apply
CSS transform on DOM element to do animation

00:26:16.250 --> 00:26:19.900
and to do a bit of transform.
So, if you don't need to draw things, but

00:26:19.900 --> 00:26:25.200
you just need to transform some of the element,
look into CSS transform. It's great for animations.

00:26:25.200 --> 00:26:29.570
You can do CSS-based animation instead of
modifying the position of your elements.

00:26:29.570 --> 00:26:34.480
And you can time them just by setting a style
with a timing and a start/end position.

00:26:34.480 --> 00:26:41.480
You can create animations in CSS transform
that will be really fast.

00:26:41.500 --> 00:26:46.789
Okay. So, what's happening there really is
that you end up with a code that has the IE

00:26:46.789 --> 00:26:50.480
path, VML and HTML, and then, the rest of
the world.

00:26:50.480 --> 00:26:56.350
Maybe it will change with IE9, but for the
moment you really end up with a GL-type approach

00:26:56.350 --> 00:27:02.440
for your graphics.
So, this is the table of rendering.

00:27:02.440 --> 00:27:08.870
So, when I render Street View, every time
you pen, I have to render a complete frame.

00:27:08.870 --> 00:27:12.669
It's a lot of image cropping -- a lot of image
transformations.

00:27:12.669 --> 00:27:17.789
It's thousands of calls into Canvas.
So, this is really pushing Canvas to the limit.

00:27:17.789 --> 00:27:21.780
If you have to draw a few polygons and things
like that you'll never have this kind of problem.

00:27:21.780 --> 00:27:26.140
But, if you start having to do thousands of
call to Canvas, this is the type of performance

00:27:26.140 --> 00:27:30.549
you're going to be looking at.
So, as you can see, Chrome on Linux, Chrome

00:27:30.549 --> 00:27:37.549
on Windows, Firefox on Linux, Safari on MacBook
and Windows, performance is not bad.

00:27:38.020 --> 00:27:44.530
Okay, from 25 millisecond to 100 millisecond.
It's gives fairly good penning.

00:27:44.530 --> 00:27:51.530
But then, Chrome on Mac, Firefox on Mac, Firefox
on Windows -- the performance there is just

00:27:51.919 --> 00:27:55.150
unusable.
If you have start having five frames a second

00:27:55.150 --> 00:28:01.080
or two frames a second, just -- you can't
really do any penning or any animation on

00:28:01.080 --> 00:28:04.020
this kind of thing.
I've put here the iPad and iTouch figures

00:28:04.020 --> 00:28:09.409
 -- so, iPad at 800 milliseconds and iTouch
at 1900 milliseconds.

00:28:09.409 --> 00:28:14.559
So you get a frame every two seconds.
Same thing, not usable.

00:28:14.559 --> 00:28:21.539
And the new FroYo is at 314 milliseconds.
So, it's still what? Six times faster than

00:28:21.539 --> 00:28:27.190
the iTouch, but not quite usable if you want
to do image-intensive work.

00:28:27.190 --> 00:28:34.190
So, in this situation, what we've done with
Street View is that for Linux Chrome and Linux

00:28:34.909 --> 00:28:41.909
Windows we actually use the Canvas 2D implementation
and, for everybody else, we use the HTML4

00:28:42.970 --> 00:28:49.460
implementation which I will demonstrate shortly.
Now, WebGL -- that's where it gets exciting.

00:28:49.460 --> 00:28:53.110
These are the timing for the same work done
in WebGL.

00:28:53.110 --> 00:28:59.850
So rendering a frame in WebGL on Chrome Linux
 -- 0.9 millisecond.

00:28:59.850 --> 00:29:04.039
Rendering the same frame on Safari WebGL 
-- 1.5 milliseconds.

00:29:04.039 --> 00:29:09.780
Rendering it on Firefox -- on Window's XP
 -- 1.1 millisecond. Okay?

00:29:09.780 --> 00:29:14.840
So, at that level, just the performance --
 the user interface -- is smooth.

00:29:14.840 --> 00:29:19.620
It's all done in JavaScript talking to WebGL,
but it's really nice -- really have great

00:29:19.620 --> 00:29:24.630
performance.
And I just can't wait to have WebGL just coming

00:29:24.630 --> 00:29:31.630
out directly in mainstream.
Okay. So, what we ended up using?

00:29:33.289 --> 00:29:39.460
For polygons and polylines, SVG and VML.
For most browsers, we fall back to Canvas

00:29:39.460 --> 00:29:43.480
for Android because there's no SVG and VML
support.

00:29:43.480 --> 00:29:48.330
For animation, we use CSS transforms.
We have no animation on IE.

00:29:48.330 --> 00:29:54.409
For image transformation we use Canvas.
And we have no image transformation on IE

00:29:54.409 --> 00:30:00.890
and on Android.
And for 3D transform, when it's there, we'll

00:30:00.890 --> 00:30:04.260
be using WebGL.
I'm hoping it's coming soon.

00:30:04.260 --> 00:30:10.299
I haven't heard about anything from IE9, so
I wouldn't hold my breath either.

00:30:10.299 --> 00:30:16.260
Okay. So let me show you a couple of demos.
And what I'm trying to show you there is that

00:30:16.260 --> 00:30:23.260
those technologies can be mixed.
So, where am I?

00:30:24.500 --> 00:30:30.559
So, when we looked at this view here, what's
happening is, we have -- it's hard to see

00:30:30.559 --> 00:30:34.950
on the white card there -- okay.
So, what I've got there is, I've got a links

00:30:34.950 --> 00:30:37.070
control.
That links control is an SVG control.

00:30:37.070 --> 00:30:42.559
I've got mouse support, I can do rollovers,
I can change the style -- that's my SVG control.

00:30:42.559 --> 00:30:46.450
I've got another SVG control here which is
my compass control.

00:30:46.450 --> 00:30:52.049
So I can rotate things when my view changes.
And then, on the background, I actually have

00:30:52.049 --> 00:30:59.049
here on HTML4 layer for Street View, because
the performance on Chrome MacIntosh for Canvas

00:30:59.620 --> 00:31:05.990
2D wasn't good enough.
So, if I switch to the Webkit Safari, which

00:31:05.990 --> 00:31:12.990
is the night build, that is a similar view,
but here the performance -- that's WebGL,

00:31:13.049 --> 00:31:19.380
okay?
This is this kind of thing.

00:31:19.380 --> 00:31:22.070
You know, that's the kind of thing you're
going to be able to do with WebGL.

00:31:22.070 --> 00:31:25.240
So, what I've got there is, I've got a background
with WebGL.

00:31:25.240 --> 00:31:31.760
But, on top of that background, I still have
the SVG control for my links and the SVG control

00:31:31.760 --> 00:31:34.900
for my compass.
So you mix the technology and use the one

00:31:34.900 --> 00:31:41.900
that best fits what you need to do, okay?
So, if we switch to this little guy.

00:31:51.020 --> 00:31:54.049
Sorry.

00:31:54.049 --> 00:31:57.090
[pause]

00:31:57.090 --> 00:31:59.950
Okay.
So, if we switch to this little guy, we have

00:31:59.950 --> 00:32:05.299
the same thing.
And here, it's actually an HTML background

00:32:05.299 --> 00:32:09.710
and the links control that we can hardly see
under the zoom button, but the links control

00:32:09.710 --> 00:32:14.200
is actually a Canvas control.
And Canvas doesn't support text rendering

00:32:14.200 --> 00:32:18.460
so, actually, we didn't put the text.
It's also a small display, so we didn't really

00:32:18.460 --> 00:32:25.440
have the space to fit the text for those twits.
And because Canvas doesn't have mouse support,

00:32:25.440 --> 00:32:31.390
what I've got on top of that Canvas control
is I've got transparent div that have been

00:32:31.390 --> 00:32:35.820
CSS transformed.
So, they follow on top of the arrow.

00:32:35.820 --> 00:32:39.559
So, when you click on the arrows, you're not
actually clicking the Canvas controls, you're

00:32:39.559 --> 00:32:43.659
clicking some transparent div.
So, just think about all these things, and

00:32:43.659 --> 00:32:48.980
think about how you can mix and match the
different technologies.

00:32:48.980 --> 00:32:55.980
All right, let's go back to --

00:33:07.289 --> 00:33:10.340
[pause]

00:33:10.340 --> 00:33:17.340
No, it's gone.

00:33:19.490 --> 00:33:22.549
[pause]

00:33:22.549 --> 00:33:27.010
Okay.
So, a few things to also remember.

00:33:27.010 --> 00:33:31.480
Canvas 2D performance will increase every
time your Canvas size increase.

00:33:31.480 --> 00:33:35.650
So you've got a number of problems.
One, as window Canvas bigger, you tend to

00:33:35.650 --> 00:33:38.929
make more call.
In our case, make more call to Canvas.

00:33:38.929 --> 00:33:42.059
You have more peak source to render for the
engine.

00:33:42.059 --> 00:33:46.150
And those two things combined means that it
really gets slow.

00:33:46.150 --> 00:33:52.960
It gets more than linearly worse.
So you don't want to use Canvas on a very

00:33:52.960 --> 00:33:58.730
large desktop and just draw all over the place.
The performance is not going to be good.

00:33:58.730 --> 00:34:03.720
There are a number of bugs with those technologies.
So, for example, I found there's a bug where

00:34:03.720 --> 00:34:09.480
you combine treaty transforms with touch events.
So, things that you have to choose sometime

00:34:09.480 --> 00:34:13.899
in different technologies.
Canvas, up until FroYo, had no support for

00:34:13.899 --> 00:34:17.690
images on Canvas -- there was a bug there.
That's been fixed with FroYo this week.

00:34:17.690 --> 00:34:22.750
So. it's good news.
WebGL only support it on night build.

00:34:22.750 --> 00:34:27.530
And there is bugs when you enable CSS transform
events.

00:34:27.530 --> 00:34:32.929
We've -- the support for embedded objects.
So, when you try to combine having a flash

00:34:32.929 --> 00:34:37.849
object and putting CSS transform to position
it in a different location, you're not going

00:34:37.849 --> 00:34:42.940
to get a very good result.
So, just be aware of all these things.

00:34:42.940 --> 00:34:46.909
Okay. So let's talk about -- I'll be very
quick on geolocation.

00:34:46.909 --> 00:34:49.929
The reason I want to be very quick on it is,
really, it's not difficult.

00:34:49.929 --> 00:34:52.629
It's been covered in a number of sessions
today.

00:34:52.629 --> 00:34:58.859
But the point to take home is that if you
want to do geolocation, use the W 3C implementation.

00:34:58.859 --> 00:35:02.380
It's available in Firefox. It's available
on mobile devices.

00:35:02.380 --> 00:35:09.380
And if you don't have geolocation available
built into the device, fall back to GoogleGears.

00:35:10.010 --> 00:35:14.750
The two objects have the same interface.
So, if you have that little piece of code

00:35:14.750 --> 00:35:20.089
in your application, you can just look at
if you have the geolocation available or if

00:35:20.089 --> 00:35:24.640
you have GoogleGears available, and then,
just do your request, okay?

00:35:24.640 --> 00:35:29.140
We don't provide it at the moment as part
of the API simply because it's just a few

00:35:29.140 --> 00:35:34.380
lines of code you can put yourself.
We use it as part of a preview we have seen

00:35:34.380 --> 00:35:41.380
a few days -- yesterday on the place of API.
So, mouse and touch event -- it's not a very

00:35:43.589 --> 00:35:48.380
good news for mobiles at the moment.
So there is very good support for touch event

00:35:48.380 --> 00:35:54.000
on the iPhone, iPad, iTouch.
There is fairly good support for touch event

00:35:54.000 --> 00:35:56.820
on Android.
I mean, "fairly good" because there is no

00:35:56.820 --> 00:36:03.820
support at the moment for Pinch-type event.
And then, after that, there is very much nothing.

00:36:04.760 --> 00:36:09.359
We've tested the S16. We've tested Palm OS.
We've tested a number of devices.

00:36:09.359 --> 00:36:15.800
And, up until now, those events are not available.
So, when you interact with the browser, you

00:36:15.800 --> 00:36:19.300
can see that the browser will scale when you
pinch or will react.

00:36:19.300 --> 00:36:23.560
But the fact is, at the JavaScript level,
you're not getting those events.

00:36:23.560 --> 00:36:30.560
So, that's a bit of a problem.
The sequence of events you're getting is also

00:36:30.940 --> 00:36:34.290
a bit different for each of the browsers.
So you're going to have to be careful in your

00:36:34.290 --> 00:36:37.730
code.
Some browsers are going to swap the sequence

00:36:37.730 --> 00:36:40.050
of events.
They're going to give you click events and

00:36:40.050 --> 00:36:43.089
not give you mouse events or they're going
to give you mouse events and not click events.

00:36:43.089 --> 00:36:47.320
So mobile technology at the moment -- there
isn't that much of a standard.

00:36:47.320 --> 00:36:52.140
And you're going to have to test every device
as you go.

00:36:52.140 --> 00:36:56.940
This is, at the moment, what the world looks
like for events.

00:36:56.940 --> 00:36:59.500
So, there is very good support for iPhone,
iPad.

00:36:59.500 --> 00:37:04.589
There is good support on Android.
And on the Samsungs, the Palm OS, the Nokias

00:37:04.589 --> 00:37:10.390
we have tested, it's just click events.
The Nokia is doing something quite weird where

00:37:10.390 --> 00:37:14.109
they simulate mouse over when you touch the
screen.

00:37:14.109 --> 00:37:20.930
So if you touch your screen on the Nokia browser,
it will give you a mouse over event.

00:37:20.930 --> 00:37:25.000
And when you move a mouse -- move then a mouse
out -- and when you let go, it will give you

00:37:25.000 --> 00:37:27.859
a sequence of mouse up, mouse down, mouse
click.

00:37:27.859 --> 00:37:34.859
So it makes for things a bit difficult.
Okay. Let's talk about debugging.

00:37:36.210 --> 00:37:40.780
Susannah just brushed a bit about it.
So, debugging on desktop on the iPhone and

00:37:40.780 --> 00:37:45.990
the Android.
Debugging on desktop, really, ten years of

00:37:45.990 --> 00:37:52.030
development have done things fairly well.
We use Firebug on Firefox -- Visual Debugger

00:37:52.030 --> 00:37:57.200
in the developer toolbar -- it's on Explorer.
We use Developer Consonance SpeedTracker.

00:37:57.200 --> 00:38:03.460
If you haven't heard about SpeedTracker, find
the recording of the Chrome sessions that

00:38:03.460 --> 00:38:06.589
were on yesterday and today and learn about
SpeedTracker.

00:38:06.589 --> 00:38:12.190
It's really a great tool. And Safari with
the WebInspector.

00:38:12.190 --> 00:38:18.070
Now, what do you do on the iPhone?
Susannah brushed on it. So, there isn't much.

00:38:18.070 --> 00:38:25.070
You do some console tracking, and you enable
the debugger mode on Safari and get a few

00:38:25.510 --> 00:38:27.660
lines of text.
It's a bit annoying, but that's all you're

00:38:27.660 --> 00:38:32.920
going to be able to do.
If you want to do some performance testing,

00:38:32.920 --> 00:38:36.490
research the use of the iPhone Configuration
Utility.

00:38:36.490 --> 00:38:41.000
That will let you set proxy settings on your
3G settings.

00:38:41.000 --> 00:38:44.660
If you launch your iPhone configuration utility,
find the advent settings.

00:38:44.660 --> 00:38:50.270
Set up the proxy and set that configuration
on to your phone, and then, all your Http

00:38:50.270 --> 00:38:55.800
traffic will go to a proxy server.
If you've got a window's machine, you install

00:38:55.800 --> 00:39:01.180
Fiddler on it, enable it to become an external
proxy -- you will get the kind of charts that

00:39:01.180 --> 00:39:05.030
this is giving you. Okay?
So you'll be able to find the start time,

00:39:05.030 --> 00:39:11.560
the end time, the duration of all your transfers.
You'll be able to see the request header and

00:39:11.560 --> 00:39:13.480
response header of all the requests you've
made.

00:39:13.480 --> 00:39:18.520
So that allows you to monitor all your AJAX
queries, to look at what you were sending

00:39:18.520 --> 00:39:21.599
and receiving.
So it's a great debugging tool for AJAX-style

00:39:21.599 --> 00:39:25.660
application.
If you want to do the same thing on Android,

00:39:25.660 --> 00:39:32.660
bit more difficult on some -- simple on others.
To do tracking, the best way is to plug in

00:39:32.820 --> 00:39:38.290
your Android into a USB port and run the ADB
utility on your desktop.

00:39:38.290 --> 00:39:45.290
So, go and download the Android SDK, install
the USB drivers that the SDK will prompt you

00:39:46.210 --> 00:39:50.170
to install, and then, launch the ADB log CAD
application.

00:39:50.170 --> 00:39:54.359
When you plug in your Android on your PC,
it will automatically stream all the information

00:39:54.359 --> 00:39:59.400
that the Android is displaying directly on
the text console.

00:39:59.400 --> 00:40:04.160
So you'll get information on the inside of
the Android a lot of track information.

00:40:04.160 --> 00:40:09.990
But among all this, you'll see all the http
trace -- so great tool.

00:40:09.990 --> 00:40:16.560
To do http proxy, simply go to the network
settings of your Android and find your network

00:40:16.560 --> 00:40:21.700
access point names and under each access point
name you can go to the settings and add the

00:40:21.700 --> 00:40:25.990
proxy value.
If you set a proxy and a port -- same thing

00:40:25.990 --> 00:40:29.789
 -- you can get all your 3G traffic to be
redirected to a proxy -- Fiddler proxy --

00:40:29.789 --> 00:40:34.190
 and get all the queries that you're making.
So quite nice.

00:40:34.190 --> 00:40:39.780
This was broken in 2.1, but I think it's being
fixing for you.

00:40:39.780 --> 00:40:44.480
Okay. That's the end of our presentation.

00:40:44.480 --> 00:40:49.780
&gt;&gt;Susannah Raub: But we would like to remind
you that you can get qualified as a Google

00:40:49.780 --> 00:40:54.980
developer.
So, to be recognized for your work as a developer

00:40:54.980 --> 00:40:59.520
in your expertise.
And we will now be taking questions, both

00:40:59.520 --> 00:41:03.520
from the floor and from Wave.

00:41:03.520 --> 00:41:08.960
[discussing quietly]

00:41:08.960 --> 00:41:15.960
&gt;&gt;Marc Ridey: So have you got any questions?
I can also answer some Street View questions

00:41:21.780 --> 00:41:22.460
if you're interested.

00:41:22.460 --> 00:41:26.119
[pause]

00:41:26.119 --> 00:41:33.119
&gt;&gt;Q: Have you come up with any recommendations
aside from what we had last year for clustering

00:41:35.020 --> 00:41:37.770
large amounts of markers?

00:41:37.770 --> 00:41:39.970
&gt;&gt;Marc Ridey: Use KML.

00:41:39.970 --> 00:41:40.950
&gt;&gt;Q: KML?

00:41:40.950 --> 00:41:47.950
&gt;&gt;Marc Ridey: Yes, even for a small amount
of geometry, I think past 50 markers, you're

00:41:50.160 --> 00:41:56.320
going to find that 50 markers or info Windows
or polyline, things like that, KML will give

00:41:56.320 --> 00:41:57.470
you better performance.

00:41:57.470 --> 00:42:02.720
&gt;&gt;Susannah Raub: You can also check out the
marker clusters that are available online

00:42:02.720 --> 00:42:08.339
including one that you had in the front row.
Yep.

00:42:08.339 --> 00:42:11.420
&gt;&gt;Q: Do you have any suggestions for measuring
like CPU load of the browser?

00:42:11.420 --> 00:42:16.640
Sometimes it's easy to measure JavaScript
pausing or running too long.

00:42:16.640 --> 00:42:19.420
But sometimes, different ways of rendering
things take more.

00:42:19.420 --> 00:42:21.770
&gt;&gt;Marc Ridey: Have you looked at SpeedTracker?

00:42:21.770 --> 00:42:23.640
&gt;&gt;Q: No, not deeply, actually.

00:42:23.640 --> 00:42:29.150
&gt;&gt;Marc Ridey: Okay, so SpeedTracker will give
you information on CPU usage for everything

00:42:29.150 --> 00:42:33.849
in the browser on Chrome.
So it will tell you how much CPU to the millisecond

00:42:33.849 --> 00:42:39.640
you spend on parsing, on rendering, on doing
server request.

00:42:39.640 --> 00:42:45.190
So it's a very good tool for doing that.
In particular, it will highlight to you if

00:42:45.190 --> 00:42:50.690
you have combinations of -- if you have some
bad JavaScript that constantly modify DOM

00:42:50.690 --> 00:42:53.410
elements.
So you have a loop where you set attributes

00:42:53.410 --> 00:42:56.160
and do something else, set attributes, do
something else, and it will show you that

00:42:56.160 --> 00:43:00.010
the browser is continuously doing render of
that render of that render of that.

00:43:00.010 --> 00:43:04.339
And it will help you identify this kind of
performance heat.

00:43:04.339 --> 00:43:11.339
So SpeedTracker will go to the CPU level to
show you where all the time is spent in executing

00:43:12.430 --> 00:43:13.410
JavaScript.

00:43:13.410 --> 00:43:16.220
&gt;&gt;Q: Cool.
Do you know -- does anything in IE do that?

00:43:16.220 --> 00:43:18.930
&gt;&gt;Marc Ridey: No, I don't think so.

00:43:18.930 --> 00:43:19.839
[chuckling]

00:43:19.839 --> 00:43:24.410
&gt;&gt;Q: Thanks, thanks a lot.

00:43:24.410 --> 00:43:31.410
&gt;&gt;Q: Is there anything to effect the scale
of a marker in the Maps v3 API?

00:43:32.349 --> 00:43:39.349
&gt;&gt;Marc Ridey: Yes, there's a new parameter
in marker image called "scale image" that

00:43:39.880 --> 00:43:44.960
will let you scale a marker.
Have a look at the documentation.

00:43:44.960 --> 00:43:48.270
And I've got a blog post that explains a bit
how it's done as well.

00:43:48.270 --> 00:43:50.480
&gt;&gt;Q: I was going to say that you mentioned
that there was really no alternative to debugging

00:43:50.480 --> 00:43:57.480
on a certain platform other than just saying
console.log.

00:44:00.420 --> 00:44:02.849
You could always just put things to the page
itself, because I have personal experience

00:44:02.849 --> 00:44:03.560
with not liking that.
Because if you don't homogenize that object

00:44:03.560 --> 00:44:03.810
or leave a console log in there, it breaks
it from any browsers that don't have that

00:44:03.770 --> 00:44:04.930
there.
So just a word of advice if anybody has had

00:44:04.930 --> 00:44:05.180
that issue.

00:44:05.109 --> 00:44:12.109
&gt;&gt;Susannah Raub: Yes, we also use that technique
from time to time, particularly when we need

00:44:12.310 --> 00:44:18.780
to go back and debug things also on IE6, and
 –

00:44:18.780 --> 00:44:22.200
&gt;&gt;Q: Anything that doesn't have a console.

00:44:22.200 --> 00:44:29.200
&gt;&gt;Marc Ridey: It's okay for debugging, but
affects performance.

00:44:29.450 --> 00:44:33.369
So, if you're trying to do performance test,
it's a bit of a problem, because you cause

00:44:33.369 --> 00:44:38.570
the browser to rerender or to reprocess its
DOM.

00:44:38.570 --> 00:44:43.730
&gt;&gt;Susannah Raub: We can take this question
from the Wave.

00:44:43.730 --> 00:44:47.310
&gt;&gt;Q: Is there a feature planned for v3 that
covers similar functionality to Mapplets?

00:44:47.310 --> 00:44:52.950
&gt;&gt;Susannah Raub: Not currently. But the Issue
Tracker is your friend. Yes.

00:44:52.950 --> 00:44:59.950
&gt;&gt;Q: Hi there. I have a question about the
zooming supports built into mobile browsers,

00:45:00.810 --> 00:45:06.000
pinch zoom or press the little buttons.
Did you try to make use of any of those or

00:45:06.000 --> 00:45:10.770
just disable them totally?
What did you do when you came across the zooming

00:45:10.770 --> 00:45:13.079
support that's built into browsers and how
do you handle that?

00:45:13.079 --> 00:45:20.079
&gt;&gt;Susannah Raub: So we disabled the default
 -- or we canceled the default events for

00:45:20.470 --> 00:45:27.220
the touch events so that we don't scale the
page when you're in the map.

00:45:27.220 --> 00:45:34.220
So as long as your pinch is inside the map,
we won't scale -- or your drag is inside the

00:45:37.609 --> 00:45:38.710
map, we won't drag the page.
And I think it's either "canceled" or "stop

00:45:38.710 --> 00:45:38.960
propagation."

00:45:38.710 --> 00:45:42.099
&gt;&gt;Marc Ridey: That's only for the iPhone obviously,
because for the other browsers, you don't

00:45:42.099 --> 00:45:45.849
get that event, so you have no capability
of canceling it. You can.

00:45:45.849 --> 00:45:49.020
&gt;&gt;Susannah Raub: Well, Android, you get it,
but just not for Pinch.

00:45:49.020 --> 00:45:49.640
But same thing for your drag.

00:45:49.640 --> 00:45:55.880
&gt;&gt;Marc Ridey: You can set some metatags at
the top of your page to restrict zooming altogether.

00:45:55.880 --> 00:46:01.040
So for our test pages and particular -- it's
quite standard for the iPhone to set the tag

00:46:01.040 --> 00:46:06.280
at the top to say "min zoom / max zoom is
one, no user zooming," and so on.

00:46:06.280 --> 00:46:10.859
And that stops the pinching from having a
zoom effect if you want the UI to stay always

00:46:10.859 --> 00:46:11.770
the same size.

00:46:11.770 --> 00:46:17.310
&gt;&gt;Susannah Raub: And for a full-screen web
app, you would most likely want that feature.

00:46:17.310 --> 00:46:24.310
In fact, the map will render best when the
scale is set and you don't allow -- once you

00:46:24.970 --> 00:46:31.970
start scaling a page on a desktop or on the
mobile, we get artifacts between tiles and

00:46:33.530 --> 00:46:40.400
 -- it's life kind of with the browsers. Mm-hmm?

00:46:40.400 --> 00:46:45.300
&gt;&gt;Q: One more question. Do you have any plans
to support middle mouse scroll zoom sensitivity?

00:46:45.300 --> 00:46:49.240
Like, for example, using the Apple magic mouse
on the MacBooks, or anything?

00:46:49.240 --> 00:46:53.339
It's really sensitive, so it causes the zoom
to just –

00:46:53.339 --> 00:46:55.440
&gt;&gt;Susannah Raub: We've seen that, haven't
we?

00:46:55.440 --> 00:47:02.079
I think we've observed that.
File it at Issue in the Issue Tracker.

00:47:02.079 --> 00:47:08.690
It's something that we should probably fix
on the MacBook -- just haven't prioritized

00:47:08.690 --> 00:47:13.150
it yet.
We're using more MacBooks now, so you can

00:47:13.150 --> 00:47:16.790
expect it.
Yeah, that might happen sooner now that it's

00:47:16.790 --> 00:47:19.320
in our daily life.

00:47:19.320 --> 00:47:25.520
&gt;&gt;Q: Sorry, one more. Have you guys been telling
ppk of QuirksMode about your findings with

00:47:25.520 --> 00:47:29.839
these events on different mobile phones?
I'm sure he'd be interested -- or getting

00:47:29.839 --> 00:47:30.920
it from him?

00:47:30.920 --> 00:47:33.770
&gt;&gt;Susannah Raub: We have not talked to him.
We look at his stuff sometimes.

00:47:33.770 --> 00:47:35.770
&gt;&gt;Q: Yeah, he has an extensive chart of all
this stuff.

00:47:35.770 --> 00:47:41.329
I'm sure he'd be really happy if you told
him of this stuff or just linked him to this

00:47:41.329 --> 00:47:44.810
presentation, because he keeps a big master
table that a lot of people use for compatibility.

00:47:44.810 --> 00:47:50.510
&gt;&gt;Susannah Raub: Yeah, we refer to that one,
so.

00:47:50.510 --> 00:47:54.750
Any other questions?

00:47:54.750 --> 00:47:56.160
[pause]

00:47:56.160 --> 00:48:01.060
All right. Well, thank you.
And good luck developing your cross-platform

00:48:01.060 --> 00:48:02.849
web applications.
We look forward to seeing them.

00:48:02.849 --> 00:48:03.099
[Applause]

