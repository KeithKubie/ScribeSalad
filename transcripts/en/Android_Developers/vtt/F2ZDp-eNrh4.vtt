WEBVTT
Kind: captions
Language: en

00:00:00.590 --> 00:00:01.880
RAY: Hello, everyone.

00:00:01.880 --> 00:00:03.890
Thank you so much for
joining us this afternoon.

00:00:03.890 --> 00:00:06.754
I hope you guys didn't have to
wait too long in the hot sun,

00:00:06.754 --> 00:00:08.545
although secretly I
was hoping that there'd

00:00:08.545 --> 00:00:11.530
be a long line for our talk.

00:00:11.530 --> 00:00:12.280
My name is Ray.

00:00:12.280 --> 00:00:14.310
I'm a product manager on
the Android media team,

00:00:14.310 --> 00:00:18.880
and I'm responsible
for Android Pro Audio.

00:00:18.880 --> 00:00:20.610
Android Pro Audio
is an initiative

00:00:20.610 --> 00:00:23.000
that we launched last
year to bring together

00:00:23.000 --> 00:00:28.900
device makers, silicon
partners, and Android engineers

00:00:28.900 --> 00:00:34.060
to provide a true professional
performance audio platform

00:00:34.060 --> 00:00:37.060
for Android app developers.

00:00:37.060 --> 00:00:40.200
This means being
able to write apps

00:00:40.200 --> 00:00:43.470
that use MIDI,
high-resolution input

00:00:43.470 --> 00:00:47.260
and output, USB digital
audio, floating point,

00:00:47.260 --> 00:00:50.590
audio processing and all
of that with a round trip

00:00:50.590 --> 00:00:52.365
latency of less than
20 milliseconds.

00:00:55.060 --> 00:00:57.030
Now when we announced
this initiative,

00:00:57.030 --> 00:00:59.040
we knew it was going to
be a multi-year effort

00:00:59.040 --> 00:01:03.630
with a lot of moving parts,
some out of our control.

00:01:03.630 --> 00:01:05.280
But even though it's
been only a year,

00:01:05.280 --> 00:01:07.610
we've actually seen some
really exciting developments

00:01:07.610 --> 00:01:09.814
from our hardware and
software partners.

00:01:09.814 --> 00:01:12.230
And so with that, I'd like to
introduce you to Dan to show

00:01:12.230 --> 00:01:15.379
some really cool audio apps.

00:01:15.379 --> 00:01:16.295
DAN GALPIN: All right.

00:01:19.170 --> 00:01:20.050
Thank you very much.

00:01:20.050 --> 00:01:21.020
I'm Dan Galpin.

00:01:21.020 --> 00:01:24.710
I'm a developer advocate and
I work with a lot of partners

00:01:24.710 --> 00:01:27.970
to help build great audio
experiences on Android.

00:01:27.970 --> 00:01:31.120
And I wanted to first do a call
out to my colleague Don Turner.

00:01:31.120 --> 00:01:32.490
He couldn't be here today.

00:01:32.490 --> 00:01:34.050
So this is Don
"Turntable" Turner

00:01:34.050 --> 00:01:36.710
as a young guy working
on his Pro Audio stuff.

00:01:36.710 --> 00:01:39.130
And then, of course, this
is what his desk actually

00:01:39.130 --> 00:01:40.100
looks like today.

00:01:40.100 --> 00:01:41.160
It's a little neater.

00:01:41.160 --> 00:01:44.577
But there is a lot of passion
in this team about Pro Audio.

00:01:44.577 --> 00:01:46.910
And I just want to make it
clear, every single one of us

00:01:46.910 --> 00:01:48.380
up here is a musician.

00:01:48.380 --> 00:01:50.550
Every single one
of us up here cares

00:01:50.550 --> 00:01:53.060
passionately about what we do.

00:01:53.060 --> 00:01:55.530
All right, it's not
that mind-blowing,

00:01:55.530 --> 00:01:57.140
but it's still pretty darn cool.

00:01:57.140 --> 00:01:59.030
So let me get started
with the first demo.

00:01:59.030 --> 00:02:02.250
This is on a Nexus 9,
and we're running DRC.

00:02:02.250 --> 00:02:04.877
And a lot of people seen
apps like this-- OK,

00:02:04.877 --> 00:02:07.210
if we can have the audio
output, tell me that's working.

00:02:07.210 --> 00:02:09.181
All right.

00:02:09.181 --> 00:02:10.139
OK, that's pretty cool.

00:02:10.139 --> 00:02:11.675
We got some nice low bass here.

00:02:11.675 --> 00:02:13.470
But what's really
neat about this

00:02:13.470 --> 00:02:15.287
is in addition to
this low bass, I've

00:02:15.287 --> 00:02:17.341
also got this keyboard
plugged in here.

00:02:17.341 --> 00:02:19.340
And what I can do is I
can do these high patches

00:02:19.340 --> 00:02:20.840
at the same time,
and this is taking

00:02:20.840 --> 00:02:25.380
advantage of a feature we added
in Android M to do proper MIDI.

00:02:25.380 --> 00:02:28.131
And what's really cool about
this is in addition to actually

00:02:28.131 --> 00:02:30.130
being able to do MIDI
output like this is doing,

00:02:30.130 --> 00:02:31.720
you'll also see MIDI input.

00:02:31.720 --> 00:02:33.770
And this device can
actually reconfigure

00:02:33.770 --> 00:02:36.680
itself to act as a
MIDI audio interface.

00:02:36.680 --> 00:02:38.910
You can plug this into
a PC and it actually

00:02:38.910 --> 00:02:40.210
looks just like a MIDI device.

00:02:40.210 --> 00:02:42.520
And this is cool
because DRC actually

00:02:42.520 --> 00:02:46.032
can work as a MIDI synthesizer
for your desktop workstation,

00:02:46.032 --> 00:02:46.740
which is awesome.

00:02:46.740 --> 00:02:49.370
And we actually have an example
of this over in the Pro Audio

00:02:49.370 --> 00:02:51.480
sandbox for all of you
guys that are here.

00:02:51.480 --> 00:02:54.040
All right, so the next demo,
I'm going to pull this out.

00:02:54.040 --> 00:02:55.780
The next demo I'm
going to show off

00:02:55.780 --> 00:02:57.775
is something very, very cool.

00:03:02.326 --> 00:03:03.700
And this is the
one I really wish

00:03:03.700 --> 00:03:05.860
Don could have been
here for, because Don

00:03:05.860 --> 00:03:08.645
is like an amazing, amazing DJ.

00:03:08.645 --> 00:03:13.400
I, on the other hand, am
like super rank amateur.

00:03:13.400 --> 00:03:15.194
But we're going
to show edjing app

00:03:15.194 --> 00:03:17.610
and, we're going to show this
really awesome device, which

00:03:17.610 --> 00:03:19.460
has powered itself off.

00:03:19.460 --> 00:03:20.690
Let me switch this off again.

00:03:20.690 --> 00:03:22.400
Hold on, give me
like a moment here.

00:03:22.400 --> 00:03:23.450
This is what's great.

00:03:23.450 --> 00:03:28.860
You know getting live demos
when I'm like, come on.

00:03:28.860 --> 00:03:29.360
Come on.

00:03:29.360 --> 00:03:30.383
Work, work, work.

00:03:33.554 --> 00:03:35.804
Yes, all right,
so-- now I've got

00:03:35.804 --> 00:03:36.970
to do this all from scratch.

00:03:36.970 --> 00:03:38.761
This was all set up
for you guys beforehand

00:03:38.761 --> 00:03:40.910
so there'd be none of this
kind of stuff going on,

00:03:40.910 --> 00:03:43.710
but that's what's great
about doing this stuff live.

00:03:43.710 --> 00:03:45.660
So we can hear the
audio from that.

00:03:45.660 --> 00:03:46.680
And this is really cool.

00:03:46.680 --> 00:03:50.250
It's showing off really,
really cool low latency

00:03:50.250 --> 00:03:54.240
Bluetooth, along with
low latency audio.

00:03:54.240 --> 00:03:56.382
And so I can go and mix
between these two tracks.

00:03:56.382 --> 00:03:57.340
And that's what DJs do.

00:03:57.340 --> 00:03:58.790
They create rhythmic
patterns by going

00:03:58.790 --> 00:04:00.480
between two different
tracks like this,

00:04:00.480 --> 00:04:02.500
and you see how
responsive this app is.

00:04:02.500 --> 00:04:04.720
Of course, I can also do
the stuff like scratch

00:04:04.720 --> 00:04:06.970
against the record, as well.

00:04:06.970 --> 00:04:11.390
So that is an example of doing
really cool Pro Audio work DJ

00:04:11.390 --> 00:04:12.550
style here on Android.

00:04:12.550 --> 00:04:13.270
I'm going to unplug this.

00:04:13.270 --> 00:04:14.720
I'm going to show one
more app on this device,

00:04:14.720 --> 00:04:16.136
though, so we can
keep this going.

00:04:16.136 --> 00:04:18.589
And this app really
needs no introduction.

00:04:18.589 --> 00:04:22.460
All I have to say is thanks
to our partners here at Korg,

00:04:22.460 --> 00:04:26.970
we're doing K Oscillator
here on Android.

00:04:26.970 --> 00:04:28.010
Really, really awesome.

00:04:28.010 --> 00:04:30.570
Again, super thank you
to them for the support

00:04:30.570 --> 00:04:32.620
of Android Pro Audio.

00:04:32.620 --> 00:04:35.190
OK, I've got one last demo.

00:04:35.190 --> 00:04:38.370
One last demo to
show you guys here.

00:04:38.370 --> 00:04:43.650
And last but certainly,
certainly not least,

00:04:43.650 --> 00:04:45.430
here we are.

00:04:45.430 --> 00:04:49.740
OK, it should be all
plugged in and connected.

00:04:49.740 --> 00:04:54.702
All right, so this is the
noise synthesizer from ROLI.

00:04:54.702 --> 00:04:55.410
And this is cool.

00:04:55.410 --> 00:04:57.079
You're seeing a
virtual seaboard rise,

00:04:57.079 --> 00:04:58.370
which is an amazing instrument.

00:04:58.370 --> 00:04:59.953
If you're here at
I/O you can actually

00:04:59.953 --> 00:05:02.490
check one out in our Pro Audio
sandbox and get to play on it

00:05:02.490 --> 00:05:05.230
yourself with this
amazing multi-touch panel.

00:05:05.230 --> 00:05:08.180
What's really cool is that
it's not just a keyboard,

00:05:08.180 --> 00:05:10.810
but I can move up and down
to get different effects.

00:05:10.810 --> 00:05:13.770
I can also slide across
here to do pitch bending.

00:05:13.770 --> 00:05:16.180
And of course,
fully multi-touch,

00:05:16.180 --> 00:05:17.140
fully multi-channel.

00:05:17.140 --> 00:05:19.470
And it's really, really powerful
what you can do with this.

00:05:19.470 --> 00:05:20.970
You can create
almost any instrument

00:05:20.970 --> 00:05:22.600
with incredible
amounts of expression.

00:05:22.600 --> 00:05:25.050
And this is all running on
the Juice platform, which

00:05:25.050 --> 00:05:28.180
has been updated so that anyone
can build amazing Pro Audio

00:05:28.180 --> 00:05:30.370
apps with really, really
low latency audio.

00:05:30.370 --> 00:05:34.350
So a big shout-out to
our partners and friends

00:05:34.350 --> 00:05:36.660
over at ROLI for putting
this together for us.

00:05:36.660 --> 00:05:39.129
And again, there's some
amazing, amazing people.

00:05:39.129 --> 00:05:40.545
If you go onto
YouTube, just watch

00:05:40.545 --> 00:05:43.180
what people do with the C board,
watch people do with noise.

00:05:43.180 --> 00:05:45.504
It's absolutely,
absolutely incredible.

00:05:45.504 --> 00:05:47.170
So that's the kind
of stuff we're doing.

00:05:47.170 --> 00:05:50.350
Really low latency audio, really
professional applications.

00:05:50.350 --> 00:05:54.160
All right, you can go
back to the slides now.

00:05:54.160 --> 00:05:57.600
All right, so--

00:05:57.600 --> 00:05:59.430
RAY: So I know I've
seen this in rehearsal,

00:05:59.430 --> 00:06:01.580
but that was super impressive
every time I see it.

00:06:01.580 --> 00:06:02.800
Thank you so much.

00:06:02.800 --> 00:06:11.140
And again, thank you to our
partners, ROLI, edjing, DRC,

00:06:11.140 --> 00:06:12.440
by Imaginando.

00:06:12.440 --> 00:06:13.585
Thank you so much.

00:06:13.585 --> 00:06:14.710
DAN GALPIN: So thanks, Ray.

00:06:14.710 --> 00:06:16.022
I hope you agree.

00:06:16.022 --> 00:06:17.480
These are some
awesome experiences.

00:06:17.480 --> 00:06:19.570
Now, developing apps
like this isn't easy

00:06:19.570 --> 00:06:22.029
and our partners have run into
many problems along the way.

00:06:22.029 --> 00:06:23.445
So I'd like to
share with you some

00:06:23.445 --> 00:06:25.250
of the most common
problems they encounter

00:06:25.250 --> 00:06:26.830
and the solutions,
so you don't have

00:06:26.830 --> 00:06:28.230
to go through the
same level of pain

00:06:28.230 --> 00:06:29.600
when you're developing
your audio apps.

00:06:29.600 --> 00:06:31.150
Now, to make this
more interesting-- we

00:06:31.150 --> 00:06:32.460
saw a preview of
this-- I'm going

00:06:32.460 --> 00:06:34.001
to put some code on
the screen, and I

00:06:34.001 --> 00:06:35.730
want you to see if
you can figure out

00:06:35.730 --> 00:06:37.120
what the problem is with this

00:06:37.120 --> 00:06:37.830
code?

00:06:37.830 --> 00:06:40.030
OK, does anyone--
come on, I want hands.

00:06:40.030 --> 00:06:41.800
What's the problem
with this code?

00:06:41.800 --> 00:06:44.020
Anyone?

00:06:44.020 --> 00:06:45.620
OK, yes.

00:06:45.620 --> 00:06:48.500
AUDIENCE: So it has
a fixed sample rate--

00:06:48.500 --> 00:06:50.400
DAN GALPIN: It has a
fixed sample rate, yes.

00:06:50.400 --> 00:06:50.899
OK.

00:06:50.899 --> 00:06:52.681
That is excellent.

00:06:52.681 --> 00:06:53.180
Thank you.

00:06:53.180 --> 00:06:53.719
Thank you.

00:06:53.719 --> 00:06:56.010
You can tell we've got people
doing Pro Audio out here.

00:06:56.010 --> 00:06:57.620
It's fixed, and
that's a problem,

00:06:57.620 --> 00:07:00.235
because every Android device
has a preferred rate that

00:07:00.235 --> 00:07:01.690
is set by the system.

00:07:01.690 --> 00:07:05.040
And it's usually
not 44.1 kilohertz.

00:07:05.040 --> 00:07:06.859
So not only is this
a fixed sample rate,

00:07:06.859 --> 00:07:08.650
but it's usually going
to be the wrong one.

00:07:08.650 --> 00:07:12.547
And if that happens, your audio
is going to be on a re-sampler.

00:07:12.547 --> 00:07:14.130
And so it's not going
to be able to go

00:07:14.130 --> 00:07:16.030
through the fast path,
which means you're not going

00:07:16.030 --> 00:07:17.320
to get the lowest latency.

00:07:17.320 --> 00:07:18.970
So how do we solve this?

00:07:18.970 --> 00:07:22.530
We can use the AudioManager API
and query for the device audio

00:07:22.530 --> 00:07:24.790
property and pass
that over to OpenSL.

00:07:24.790 --> 00:07:27.030
Yes, and I know what you're
saying, and being like,

00:07:27.030 --> 00:07:29.760
wait, I'm having to use JNI.

00:07:29.760 --> 00:07:30.900
Like, what?

00:07:30.900 --> 00:07:33.390
Look, this is a very
small amount of JNI.

00:07:33.390 --> 00:07:35.300
It's very, very little effort.

00:07:35.300 --> 00:07:38.450
And honestly, this is an
enormous performance gain.

00:07:38.450 --> 00:07:39.900
And it's really pretty simple.

00:07:39.900 --> 00:07:42.260
So once again, this is how
you get the native sample

00:07:42.260 --> 00:07:43.880
rate for the device.

00:07:43.880 --> 00:07:44.380
OK.

00:07:44.380 --> 00:07:47.200
Another problem is I'm
getting high audio latency

00:07:47.200 --> 00:07:48.990
on every single device.

00:07:48.990 --> 00:07:50.310
Why would this happen?

00:07:50.310 --> 00:07:53.970
All right, so tell me
what's wrong with this code.

00:07:53.970 --> 00:07:55.840
This one's actually
pretty straightforward.

00:07:55.840 --> 00:07:56.340
Anyone?

00:07:56.340 --> 00:07:58.430
Anyone?

00:07:58.430 --> 00:08:00.300
Why do I always
see the same hands?

00:08:00.300 --> 00:08:01.800
RAY: There's another
one back there.

00:08:01.800 --> 00:08:02.245
DAN GALPIN: No, there is.

00:08:02.245 --> 00:08:02.640
There is.

00:08:02.640 --> 00:08:03.140
OK.

00:08:03.140 --> 00:08:04.202
Shout it out.

00:08:04.202 --> 00:08:05.792
AUDIENCE: It has
too much buffer.

00:08:05.792 --> 00:08:07.500
DAN GALPIN: It's got
too big of a buffer.

00:08:07.500 --> 00:08:08.750
It's got too much buffer.

00:08:08.750 --> 00:08:10.140
Yes.

00:08:10.140 --> 00:08:12.084
We should have, like,
parting gifts for this.

00:08:12.084 --> 00:08:12.750
This is awesome.

00:08:12.750 --> 00:08:13.450
OK.

00:08:13.450 --> 00:08:15.470
So yes, that's
exactly the problem.

00:08:15.470 --> 00:08:17.190
Not only that it's a fixed size.

00:08:17.190 --> 00:08:21.330
So it's way too large for low
latency output at 4,000 frames.

00:08:21.330 --> 00:08:22.730
We're talking 83 milliseconds.

00:08:22.730 --> 00:08:25.000
Now back in the old
days of Android, back

00:08:25.000 --> 00:08:27.094
when I first started
ages ago, that actually

00:08:27.094 --> 00:08:28.260
wasn't that big of a buffer.

00:08:28.260 --> 00:08:31.030
But today, our devices
are way faster than that.

00:08:31.030 --> 00:08:35.106
So we're talking about
83 milliseconds of just

00:08:35.106 --> 00:08:35.730
in this buffer.

00:08:35.730 --> 00:08:38.229
So you're not going to get super
low latency audio that way.

00:08:38.229 --> 00:08:39.460
So what's the solution?

00:08:39.460 --> 00:08:42.330
Of course what we want to do is
go back and ask AudioManager,

00:08:42.330 --> 00:08:45.052
say, what is the best buffer
size we should be using?

00:08:45.052 --> 00:08:46.010
What's the optimal one?

00:08:46.010 --> 00:08:47.530
And the device will tell us.

00:08:47.530 --> 00:08:50.350
And then if you use that
buffer size in your OpenSL ES

00:08:50.350 --> 00:08:53.720
callbacks, like this, you're
going to get the fast mixer,

00:08:53.720 --> 00:08:57.340
you're going to get the best
audio playback in your apps.

00:08:57.340 --> 00:09:00.180
OK, well, this doesn't
solve all of your problems,

00:09:00.180 --> 00:09:02.640
because what happens
if you actually

00:09:02.640 --> 00:09:05.470
are doing this cool
synthesizer that you wrote

00:09:05.470 --> 00:09:08.530
and you're hearing glitches,
but you notice, like,

00:09:08.530 --> 00:09:11.180
wait, I tap the screen
and my glitches go away?

00:09:11.180 --> 00:09:14.020
OK, so what you're seeing
here is Android trying

00:09:14.020 --> 00:09:15.890
to do stuff about battery life.

00:09:15.890 --> 00:09:16.390
OK?

00:09:16.390 --> 00:09:18.681
And what happens is, if you're
not touching the screen,

00:09:18.681 --> 00:09:21.100
Android goes, well, you're
not doing anything important.

00:09:21.100 --> 00:09:23.120
No one's interacting with me.

00:09:23.120 --> 00:09:24.900
And so it scales back the CPU.

00:09:24.900 --> 00:09:27.000
And this results
in late callbacks,

00:09:27.000 --> 00:09:29.731
because you aren't able
to do as many work cycles.

00:09:29.731 --> 00:09:32.230
This is actually something we
call the interactive scheduler

00:09:32.230 --> 00:09:34.334
at work actually trying
to help you save battery.

00:09:34.334 --> 00:09:36.750
Except you really don't want
that, because you really want

00:09:36.750 --> 00:09:38.350
cool audio playback.

00:09:38.350 --> 00:09:43.180
So there is actually a way
to sort of work around this.

00:09:43.180 --> 00:09:46.670
And it's kind of a hack
trick horrible thing

00:09:46.670 --> 00:09:50.830
that we'll have a better
solution for very soon.

00:09:50.830 --> 00:09:52.230
But create a workaround.

00:09:52.230 --> 00:09:52.730
I like that.

00:09:52.730 --> 00:09:53.290
Yeah.

00:09:53.290 --> 00:09:54.450
So this is what happens.

00:09:54.450 --> 00:09:56.710
So the system decides
to throttle the CPU

00:09:56.710 --> 00:09:59.080
based on how often the user
is touching the screen.

00:09:59.080 --> 00:10:01.639
So what we can do is
we send fake touches

00:10:01.639 --> 00:10:03.930
and convince it that the
screen is still being touched.

00:10:03.930 --> 00:10:04.599
AUDIENCE: Oh.

00:10:04.599 --> 00:10:05.390
DAN GALPIN: I know.

00:10:05.390 --> 00:10:07.067
Here are the groans
from the aud-- hey,

00:10:07.067 --> 00:10:10.100
hey, look, don't shoot
the messenger, OK?

00:10:10.100 --> 00:10:12.969
I mean-- but no, this--
so now Android will go,

00:10:12.969 --> 00:10:14.760
OK, the screen is
constantly being touched.

00:10:14.760 --> 00:10:16.670
It thinks that it's
in interactive mode.

00:10:16.670 --> 00:10:18.480
And this is really important
if you're doing something

00:10:18.480 --> 00:10:20.050
like input, or if
you're using-- even

00:10:20.050 --> 00:10:22.460
if you're doing, like, a VR
app and you're using sensors.

00:10:22.460 --> 00:10:24.001
Like, you're not
touching the screen.

00:10:24.001 --> 00:10:25.540
Android might say,
well, I shouldn't

00:10:25.540 --> 00:10:27.210
be doing anything now.

00:10:27.210 --> 00:10:29.450
But so this does
actually, actually work.

00:10:29.450 --> 00:10:31.580
It convinces Android the
screen is being touched.

00:10:31.580 --> 00:10:34.891
And seriously, like, yeah, we're
going to do something better.

00:10:34.891 --> 00:10:35.390
OK.

00:10:35.390 --> 00:10:37.150
Last problem is the
one I hear the most.

00:10:37.150 --> 00:10:38.970
You know, it's, we spend
a lot of time debugging.

00:10:38.970 --> 00:10:40.428
We get audio glitches
and crackles.

00:10:40.428 --> 00:10:42.174
They've done all the
other things right.

00:10:42.174 --> 00:10:43.840
And for example, we've
got an app that's

00:10:43.840 --> 00:10:47.040
running on a device with
an 192-frame sized buffer,

00:10:47.040 --> 00:10:49.080
and it's a sample rate
of 48 kilohertz, which

00:10:49.080 --> 00:10:50.538
means you're going
to get callbacks

00:10:50.538 --> 00:10:52.172
every four milliseconds.

00:10:52.172 --> 00:10:53.630
And in those four
milliseconds, you

00:10:53.630 --> 00:10:57.210
have to generate 192
frames of audio data.

00:10:57.210 --> 00:10:59.850
And if you don't, you're
going to get a glitch.

00:10:59.850 --> 00:11:03.754
But the problem is that,
in fact, the cause of it

00:11:03.754 --> 00:11:05.920
is that you're not always
able to supply it in time.

00:11:05.920 --> 00:11:08.390
And the reason-- the
real question is why?

00:11:08.390 --> 00:11:10.230
Why was your app not
always able to actually

00:11:10.230 --> 00:11:12.220
supply this data in time?

00:11:12.220 --> 00:11:13.670
And there are two
possible causes.

00:11:13.670 --> 00:11:15.854
One of them is you
might be blocking,

00:11:15.854 --> 00:11:18.020
or you might be doing too
much work in the callback.

00:11:18.020 --> 00:11:21.880
And let's take a quick look
at some causes of those.

00:11:21.880 --> 00:11:24.390
So first thing you want to
do is check for any blocks

00:11:24.390 --> 00:11:25.750
in the audio callback.

00:11:25.750 --> 00:11:28.370
This means going through your
code and just analyzing it.

00:11:28.370 --> 00:11:30.630
You know, examining it
and checking for things

00:11:30.630 --> 00:11:33.230
like waiting on other threads.

00:11:33.230 --> 00:11:34.676
JNI calls, which
basically is kind

00:11:34.676 --> 00:11:36.050
of like waiting
on other threads,

00:11:36.050 --> 00:11:39.390
because it adds synchronization
which could block you.

00:11:39.390 --> 00:11:40.239
Memory allocations.

00:11:40.239 --> 00:11:41.780
Believe it or not,
memory allocations

00:11:41.780 --> 00:11:43.460
actually can block you.

00:11:43.460 --> 00:11:44.680
Not shocking.

00:11:44.680 --> 00:11:46.180
System calls also can block.

00:11:46.180 --> 00:11:48.100
And of course, you
can use Systrace

00:11:48.100 --> 00:11:51.440
with audio, sched, and freq, How
many people here use Systrace?

00:11:51.440 --> 00:11:52.330
Raise hands.

00:11:52.330 --> 00:11:54.090
That is not nearly enough.

00:11:54.090 --> 00:11:55.610
More people should use Systrace.

00:11:55.610 --> 00:11:57.110
It is an awesome, awesome tool.

00:11:57.110 --> 00:11:59.068
If you want to learn more
about using Systrace,

00:11:59.068 --> 00:12:02.530
you come to my session, or come
online for tomorrow at 9:00

00:12:02.530 --> 00:12:04.500
AM over in Ursa Minor OK.

00:12:04.500 --> 00:12:06.944
And I'll be talking
about Systrace.

00:12:06.944 --> 00:12:08.360
Once you're
eliminated any blocks,

00:12:08.360 --> 00:12:09.840
you need to figure out how
much work you're doing.

00:12:09.840 --> 00:12:12.020
And you can do this
using clock_gettime,

00:12:12.020 --> 00:12:14.057
as this gives you
nanosecond accuracy.

00:12:14.057 --> 00:12:16.015
And logging inside the
callback is problematic,

00:12:16.015 --> 00:12:17.550
so you want to keep
that to a minimum.

00:12:17.550 --> 00:12:20.049
And a trick you can use is to
keep a count of the callbacks,

00:12:20.049 --> 00:12:22.172
and we log one every
x number of calls.

00:12:22.172 --> 00:12:24.630
And there's even better tricks,
like keeping a ring buffer.

00:12:24.630 --> 00:12:27.255
Or you can use the Trace command
with Systrace, which is pretty

00:12:27.255 --> 00:12:28.990
cool, to create trace segments.

00:12:28.990 --> 00:12:31.060
There's a native API
we added in M for that,

00:12:31.060 --> 00:12:34.245
so it doesn't even force a
JNI call, which is great.

00:12:34.245 --> 00:12:36.120
And then the other thing
that can drastically

00:12:36.120 --> 00:12:38.580
affect your performance is
your build configuration.

00:12:38.580 --> 00:12:42.284
Always make sure that you do
not debug your debug build.

00:12:42.284 --> 00:12:43.950
I know this doesn't
make sense, but when

00:12:43.950 --> 00:12:45.400
you're doing
performance debugging,

00:12:45.400 --> 00:12:47.240
you always want to make
sure you're actually

00:12:47.240 --> 00:12:49.560
looking at your release
build, because it's

00:12:49.560 --> 00:12:50.750
going to be a lot faster.

00:12:50.750 --> 00:12:52.100
We take out a lot of things.

00:12:52.100 --> 00:12:54.700
Also make sure to check
your compiler flags.

00:12:54.700 --> 00:12:57.320
You know, hardware
float and neon

00:12:57.320 --> 00:12:59.890
can make a massive,
massive difference.

00:12:59.890 --> 00:13:02.310
Please check out our
high-performance audio website

00:13:02.310 --> 00:13:06.080
where we publish the flags
that we actually use as a team.

00:13:06.080 --> 00:13:08.080
So make sure the compiler
is actually generating

00:13:08.080 --> 00:13:08.955
what you think it is.

00:13:08.955 --> 00:13:11.889
Use, like, WA and ASLH to
dump annotated assembly

00:13:11.889 --> 00:13:12.680
if you're not sure.

00:13:12.680 --> 00:13:13.721
And this is really great.

00:13:13.721 --> 00:13:15.810
If you've ever wanted to
learn what compilers do

00:13:15.810 --> 00:13:19.246
and just how great they can be,
and sometimes how not great,

00:13:19.246 --> 00:13:21.120
take a look at the
assembly that's generated.

00:13:21.120 --> 00:13:23.234
It's very, very eye-opening.

00:13:23.234 --> 00:13:25.400
OK, and this is kind of the
hardest and most painful

00:13:25.400 --> 00:13:26.470
one for me.

00:13:26.470 --> 00:13:29.390
Don't use more than 20%
of your callback budget

00:13:29.390 --> 00:13:31.140
to generate data.

00:13:31.140 --> 00:13:33.130
And so what this means
is that if you're

00:13:33.130 --> 00:13:36.920
seeing you're taking more than
about a quarter of that time,

00:13:36.920 --> 00:13:39.230
what you should do is
try to scale back things.

00:13:39.230 --> 00:13:42.040
Scale back effects, scale
back the amount of polyphony,

00:13:42.040 --> 00:13:45.239
because the chances are
you're going to get a glitch.

00:13:45.239 --> 00:13:47.280
And or even worse, get a
whole bunch of glitches.

00:13:47.280 --> 00:13:48.930
Or maybe the device
will even heat up.

00:13:48.930 --> 00:13:52.670
So giving your-- by trying
to take only about 20% to 25%

00:13:52.670 --> 00:13:54.990
of that time, you really,
really radically reduce

00:13:54.990 --> 00:13:56.270
the chances of glitching.

00:13:56.270 --> 00:13:58.894
And ultimately, we want
to make this better.

00:13:58.894 --> 00:14:00.310
And we're working
to increase this

00:14:00.310 --> 00:14:03.310
both with bug fixes in N,
which Glen will talk about,

00:14:03.310 --> 00:14:05.490
and by working closely
with our Silicon partners.

00:14:05.490 --> 00:14:07.680
But for now, especially on
older devices-- and we're

00:14:07.680 --> 00:14:10.720
talking about current
Android-- sticking to this rule

00:14:10.720 --> 00:14:14.610
will give you the best ability
on a wide range of devices.

00:14:14.610 --> 00:14:17.510
So that's about all the war
stories I have time for today.

00:14:17.510 --> 00:14:19.570
But you can read more
about all of this

00:14:19.570 --> 00:14:22.177
and keep up with any new
developments on the Android Pro

00:14:22.177 --> 00:14:22.760
Audio webpage.

00:14:25.600 --> 00:14:26.732
All right.

00:14:26.732 --> 00:14:30.428
[APPLAUSE]

00:14:31.360 --> 00:14:32.950
RAY: So as you
can see, it really

00:14:32.950 --> 00:14:36.110
is possible to write a
great professional audio app

00:14:36.110 --> 00:14:37.480
on Android.

00:14:37.480 --> 00:14:41.680
Dan, thank you for all the
tips, the pitfalls to avoid,

00:14:41.680 --> 00:14:43.740
and the best practices.

00:14:43.740 --> 00:14:44.710
Thank you for that.

00:14:44.710 --> 00:14:45.666
DAN GALPIN: All right.

00:14:45.666 --> 00:14:47.040
RAY: And of course,
it should not

00:14:47.040 --> 00:14:51.276
be that difficult to make
a great Android audio app.

00:14:51.276 --> 00:14:52.900
So we're not going
to be happy until we

00:14:52.900 --> 00:14:56.300
have an easy-to-use API
and an audio platform that

00:14:56.300 --> 00:15:01.120
can guarantee consistent,
predictable performance.

00:15:01.120 --> 00:15:03.280
And that's also
something that's not

00:15:03.280 --> 00:15:07.880
just available in a few devices,
but on a myriad of devices.

00:15:07.880 --> 00:15:11.140
So we're a little ways off from
finishing our Android ProAudio

00:15:11.140 --> 00:15:13.690
story, but we've done
some really important work

00:15:13.690 --> 00:15:14.820
this year.

00:15:14.820 --> 00:15:16.560
And to give you a
progress report,

00:15:16.560 --> 00:15:21.410
I want to introduce you to Glen
"Latency Crusher" [? Castin. ?]

00:15:21.410 --> 00:15:25.320
[APPLAUSE]

00:15:25.617 --> 00:15:27.950
[? GLEN CASTIN: ?] I like
that name, "Latency Pressure."

00:15:27.950 --> 00:15:29.915
It's much better than
my other nickname, which

00:15:29.915 --> 00:15:34.080
is Glitch [? Castin. ?] It
was really painful for me

00:15:34.080 --> 00:15:35.870
to see Dan talking
about glitches,

00:15:35.870 --> 00:15:38.280
because I spend a lot of my
time thinking about glitches

00:15:38.280 --> 00:15:39.840
and listening to them.

00:15:39.840 --> 00:15:41.590
Anyway.

00:15:41.590 --> 00:15:46.080
So for me, I really
believe that creativity

00:15:46.080 --> 00:15:48.110
should be for everyone,
that everyone should

00:15:48.110 --> 00:15:50.180
feel empowered to be creative.

00:15:50.180 --> 00:15:53.500
And we all deserve it.

00:15:53.500 --> 00:15:55.380
It shouldn't just
be for a select few.

00:15:55.380 --> 00:15:58.840
And I believe that there's
billions of people out there,

00:15:58.840 --> 00:16:02.260
including Android users, who
should be able to be creative.

00:16:02.260 --> 00:16:04.720
In my family, we're musicians.

00:16:04.720 --> 00:16:07.470
Four of us play
piano, including me.

00:16:07.470 --> 00:16:11.510
And I'd like to introduce to
you my son, rap master Raden--

00:16:11.510 --> 00:16:12.330
Aiden.

00:16:12.330 --> 00:16:14.290
He likes to create music, too.

00:16:14.290 --> 00:16:17.170
He plays acoustic piano, and
also electronic keyboards

00:16:17.170 --> 00:16:18.410
and microphone.

00:16:18.410 --> 00:16:22.340
Unfortunately, he doesn't
play music on Android.

00:16:22.340 --> 00:16:24.520
Not yet.

00:16:24.520 --> 00:16:26.190
And this gives me
such a pain, even more

00:16:26.190 --> 00:16:27.410
than hearing glitches.

00:16:27.410 --> 00:16:29.250
And the reason is
because Android just

00:16:29.250 --> 00:16:32.420
hasn't had the consistent
level of high performance

00:16:32.420 --> 00:16:35.260
that creative audio
applications need.

00:16:35.260 --> 00:16:39.209
And Aiden's not satisfied,
and other musicians

00:16:39.209 --> 00:16:41.500
haven't been ready yet-- or
haven't been satisfied yet,

00:16:41.500 --> 00:16:43.520
either.

00:16:43.520 --> 00:16:46.130
Creative audio applications
require a lot of CPU.

00:16:46.130 --> 00:16:48.080
They require it consistently.

00:16:48.080 --> 00:16:49.860
They need to run every
few milliseconds.

00:16:49.860 --> 00:16:51.930
This is a pro level
of performance.

00:16:51.930 --> 00:16:53.850
And that's why we
call it ProAudio.

00:16:53.850 --> 00:16:56.520
The pro is for the pro
level of performance,

00:16:56.520 --> 00:16:58.850
not for who happens
to be using it.

00:16:58.850 --> 00:17:00.895
We believe that ProAudio,
again, is for everyone.

00:17:03.450 --> 00:17:04.800
That's where Android comes in.

00:17:04.800 --> 00:17:05.673
That's our strength.

00:17:05.673 --> 00:17:07.339
One of our strengths
is being able to be

00:17:07.339 --> 00:17:08.990
accessible to many, many people.

00:17:08.990 --> 00:17:12.910
The openness, the wide range of
form factors and price points.

00:17:16.290 --> 00:17:20.450
My work mission is to
reduce audio latency,

00:17:20.450 --> 00:17:22.069
to improve
performance, to reduce

00:17:22.069 --> 00:17:23.660
glitches, things like that.

00:17:23.660 --> 00:17:26.667
We introduced the ProAudio
program overall a year ago,

00:17:26.667 --> 00:17:28.750
but actually, I've been
working with my colleagues

00:17:28.750 --> 00:17:32.700
for over three years now,
initially on latency.

00:17:32.700 --> 00:17:36.490
In 2013 at I/O, we announced
some major reductions

00:17:36.490 --> 00:17:39.620
in output latency, along
with my colleagues.

00:17:39.620 --> 00:17:41.590
And then the next year,
we announced reductions

00:17:41.590 --> 00:17:43.420
in input latency.

00:17:43.420 --> 00:17:46.690
The following years, we
talked about USB audio,

00:17:46.690 --> 00:17:50.830
which enables really
high-quality audio interfaces.

00:17:50.830 --> 00:17:54.897
And we also introduced MIDI,
which is what makes music tick.

00:17:54.897 --> 00:17:55.605
That's my slogan.

00:17:58.520 --> 00:18:02.940
One thing we found, though, was
that features were not enough,

00:18:02.940 --> 00:18:04.800
that we had to have
this consistent level

00:18:04.800 --> 00:18:05.820
of performance.

00:18:05.820 --> 00:18:08.640
And both our app
developers and our users

00:18:08.640 --> 00:18:10.740
needed a way that
they could tell really

00:18:10.740 --> 00:18:12.130
easily whether a
device was going

00:18:12.130 --> 00:18:14.160
to be capable of that
level of performance

00:18:14.160 --> 00:18:16.150
and have all the
features they needed.

00:18:16.150 --> 00:18:18.330
So we introduced last
year this thing that we

00:18:18.330 --> 00:18:20.640
call the ProAudio feature flag.

00:18:20.640 --> 00:18:23.230
It brings together
all the key things

00:18:23.230 --> 00:18:25.690
that you need for pro
level of performance--

00:18:25.690 --> 00:18:32.154
low latency, MIDI, USB,
the 24-bit data path.

00:18:32.154 --> 00:18:33.820
And I'm probably
missing something else,

00:18:33.820 --> 00:18:36.120
but it has basically
all the core elements.

00:18:36.120 --> 00:18:40.040
It gives us something to
shoot for-- us personally,

00:18:40.040 --> 00:18:41.480
and the Android framework team.

00:18:41.480 --> 00:18:44.220
And it also gives our OEM
partners and our Silicon

00:18:44.220 --> 00:18:46.490
partners something that
they can shoot for.

00:18:46.490 --> 00:18:49.050
I mentioned that one
of Android's strengths

00:18:49.050 --> 00:18:51.280
is the diversity
of our ecosystem.

00:18:51.280 --> 00:18:53.660
We have a large number of
different form factors,

00:18:53.660 --> 00:18:55.660
different price points,
and things like that.

00:18:55.660 --> 00:18:58.580
And for Android, it's not
realistic, at this point,

00:18:58.580 --> 00:19:00.790
to expect that we can
get Android ProAudio

00:19:00.790 --> 00:19:02.260
performance everywhere.

00:19:02.260 --> 00:19:04.281
And we acknowledge that
with the ProAudio flag.

00:19:04.281 --> 00:19:06.280
So now we have something
to shoot for, something

00:19:06.280 --> 00:19:07.681
to differentiate.

00:19:07.681 --> 00:19:09.930
And certainly, yes, I would
like to have more and more

00:19:09.930 --> 00:19:11.290
devices support that.

00:19:11.290 --> 00:19:13.960
But initially, it's
our first step.

00:19:13.960 --> 00:19:17.970
And at the beginning, we only
had a few devices in the Nexus

00:19:17.970 --> 00:19:21.720
family that claimed the ProAudio
flag, but things are changing.

00:19:21.720 --> 00:19:25.160
I see hope now for additional
devices from other OEMs,

00:19:25.160 --> 00:19:28.090
from other Silicon makers, that
are also going to be supporting

00:19:28.090 --> 00:19:28.930
the ProAudio flag.

00:19:28.930 --> 00:19:30.400
So please stay tuned for that.

00:19:35.630 --> 00:19:38.970
So I mentioned earlier that
in one of my-- my main day job

00:19:38.970 --> 00:19:41.620
is getting rid of glitches
and decreasing latency.

00:19:41.620 --> 00:19:44.777
It turns out that we can't do
that all just in the framework.

00:19:44.777 --> 00:19:46.860
Certainly part of it is
in the portable framework,

00:19:46.860 --> 00:19:49.620
but a lot of it has to do with
the device-dependent code.

00:19:49.620 --> 00:19:51.960
So I work really
closely with partners.

00:19:51.960 --> 00:19:56.200
These include partners
within the-- fellow Googlers

00:19:56.200 --> 00:19:59.690
in the Android framework, and
kernel teams and performance

00:19:59.690 --> 00:20:02.980
teams, but also
external partners.

00:20:02.980 --> 00:20:08.170
Device OEMs, Silicon makers,
people like such as that.

00:20:08.170 --> 00:20:11.370
There's one partner that I've
been working with in particular

00:20:11.370 --> 00:20:13.610
that I want to mention now.

00:20:13.610 --> 00:20:15.020
He's a fellow Googler.

00:20:15.020 --> 00:20:17.010
He works in the Chrome OS team.

00:20:17.010 --> 00:20:20.695
And he's really helped us
to investigate and challenge

00:20:20.695 --> 00:20:22.590
some of the
assumptions that we've

00:20:22.590 --> 00:20:24.124
been making about latency.

00:20:24.124 --> 00:20:25.790
Let me give an example
of one assumption

00:20:25.790 --> 00:20:28.380
that I used to make that
was totally incorrect.

00:20:28.380 --> 00:20:31.360
People would say, oh, your
round-trip latency is whatever.

00:20:31.360 --> 00:20:32.960
You know, 20
milliseconds or whatever.

00:20:32.960 --> 00:20:34.250
What's the output latency?

00:20:34.250 --> 00:20:37.530
And I would say, well, I don't
know, but let's call it a half.

00:20:37.530 --> 00:20:39.290
Or maybe it's a little
more than a half.

00:20:39.290 --> 00:20:41.420
Well, that's not good enough.

00:20:41.420 --> 00:20:43.710
And I'd like to introduce Mark.

00:20:43.710 --> 00:20:46.870
He's a physicist by training,
and he cares about numbers

00:20:46.870 --> 00:20:47.900
and getting them right.

00:20:47.900 --> 00:20:52.550
And even better than that,
he works with lasers.

00:20:52.550 --> 00:20:53.946
MARK: Thanks.

00:20:53.946 --> 00:20:57.170
[APPLAUSE]

00:20:57.170 --> 00:20:57.670
Hi.

00:20:57.670 --> 00:20:58.390
My name is Mark.

00:20:58.390 --> 00:21:00.510
I work on the Chrome
OS touch team,

00:21:00.510 --> 00:21:01.910
and we care a lot about latency.

00:21:01.910 --> 00:21:03.880
And I'm guessing a
lot of you do, too.

00:21:03.880 --> 00:21:05.132
Now, it's not only latency.

00:21:05.132 --> 00:21:06.590
There are a bunch
of different ways

00:21:06.590 --> 00:21:09.570
an application can interact
with the physical world.

00:21:09.570 --> 00:21:11.980
And all of the interaction
channels listed here

00:21:11.980 --> 00:21:14.630
have a typical latency
of milliseconds or tens

00:21:14.630 --> 00:21:16.090
of milliseconds.

00:21:16.090 --> 00:21:19.370
Now, timing physical events
with millisecond accuracy

00:21:19.370 --> 00:21:20.540
is not rocket science.

00:21:20.540 --> 00:21:21.998
But when you're
trying to time them

00:21:21.998 --> 00:21:24.290
relative to events that
happen inside the CPU,

00:21:24.290 --> 00:21:25.455
it gets pretty messy.

00:21:25.455 --> 00:21:27.600
It looks something like this.

00:21:27.600 --> 00:21:29.449
And then when you try
to touch the device

00:21:29.449 --> 00:21:31.990
and, like, use the touchscreen
with all those probes sticking

00:21:31.990 --> 00:21:35.000
out of the guts of the phone,
it gets very frustrating.

00:21:35.000 --> 00:21:36.800
I tried it.

00:21:36.800 --> 00:21:39.600
That's one of the reasons that
the numbers we usually see

00:21:39.600 --> 00:21:41.570
are round-trip latencies.

00:21:41.570 --> 00:21:45.240
I'll be using [INAUDIBLE]
application as an example here.

00:21:45.240 --> 00:21:50.400
My plan of event looks
something like this.

00:21:50.400 --> 00:21:52.740
So the round-trip
latency, in this case,

00:21:52.740 --> 00:21:55.520
is the time from the moment
somebody touches the screen

00:21:55.520 --> 00:21:58.330
and until sounds comes out.

00:21:58.330 --> 00:22:01.380
But the subsystems invoked
in such a round-trip

00:22:01.380 --> 00:22:04.650
represent a bunch of different
engineering teams, often spread

00:22:04.650 --> 00:22:06.410
across different companies.

00:22:06.410 --> 00:22:09.880
And if there is a bug, who
should be looking for it?

00:22:09.880 --> 00:22:13.560
Blame wars are no fun.

00:22:13.560 --> 00:22:15.170
And as a physicist,
I love-- I have

00:22:15.170 --> 00:22:17.550
a little obsession with good
measurement instruments.

00:22:17.550 --> 00:22:18.966
And for the last
several months, I

00:22:18.966 --> 00:22:20.610
have-- I was lucky
to work on building

00:22:20.610 --> 00:22:23.200
one that does exactly
the kind of measurements

00:22:23.200 --> 00:22:26.040
that we are looking for.

00:22:26.040 --> 00:22:28.890
The basic idea is that we use
a device that synchronizes

00:22:28.890 --> 00:22:30.590
clocks with a phone.

00:22:30.590 --> 00:22:32.370
And then we can
separately measure

00:22:32.370 --> 00:22:35.470
the time that passes from the
moment we touch the screen

00:22:35.470 --> 00:22:37.499
and until the app got the event.

00:22:37.499 --> 00:22:39.290
And in the other
direction, from the moment

00:22:39.290 --> 00:22:43.700
that app initiated some output
and some visible or audible

00:22:43.700 --> 00:22:47.080
change has been produced.

00:22:47.080 --> 00:22:49.000
We called it the
WALT latency timer.

00:22:49.000 --> 00:22:51.410
Now, this is a very early
prototype in AudioSetup,

00:22:51.410 --> 00:22:53.380
but it's fairly simple.

00:22:53.380 --> 00:22:55.160
This is a more
recent device that

00:22:55.160 --> 00:22:57.520
can measure latency on
most of the channels

00:22:57.520 --> 00:22:59.050
that I've mentioned earlier.

00:22:59.050 --> 00:23:02.410
The good news is that it can
work without the need to modify

00:23:02.410 --> 00:23:04.942
the device, or even route it.

00:23:04.942 --> 00:23:06.900
And we have recently
open-sourced this project.

00:23:06.900 --> 00:23:09.370
It's now all on GitHub.

00:23:09.370 --> 00:23:12.480
And WALT has produced some
interesting results for Android

00:23:12.480 --> 00:23:14.910
audio, and for touch, as well.

00:23:14.910 --> 00:23:15.957
Back to Glen.

00:23:15.957 --> 00:23:17.831
[? GLEN CASTIN: ?]
So one thing here--

00:23:17.831 --> 00:23:21.760
[APPLAUSE]

00:23:21.760 --> 00:23:22.640
Thank you, Mark.

00:23:22.640 --> 00:23:24.390
One thing here that
shocked me was seeing

00:23:24.390 --> 00:23:27.370
that the audio output latency
here was 13 and the input

00:23:27.370 --> 00:23:27.980
was five.

00:23:27.980 --> 00:23:30.090
You know, I'd been telling
people incorrectly,

00:23:30.090 --> 00:23:31.700
oh, just guess half and half.

00:23:31.700 --> 00:23:33.050
Well, I was totally wrong.

00:23:33.050 --> 00:23:35.080
When you think about
it, it makes more sense.

00:23:35.080 --> 00:23:37.040
It has to do with
the number of buffers

00:23:37.040 --> 00:23:39.660
and where they are in the
pipeline and things like that.

00:23:39.660 --> 00:23:42.030
But it just shows
you how important

00:23:42.030 --> 00:23:44.860
it is to actually measure
things, and not just guess.

00:23:50.040 --> 00:23:54.600
So together, working in
the Android framework team

00:23:54.600 --> 00:23:58.830
together with our partners in
the kernel team, performance

00:23:58.830 --> 00:24:01.840
team, our Silicon
partners, our OEM partners,

00:24:01.840 --> 00:24:05.890
we've made a lot of progress in
reducing latency and improving

00:24:05.890 --> 00:24:06.720
performance.

00:24:06.720 --> 00:24:09.540
I want to now turn the
subject to what we're

00:24:09.540 --> 00:24:11.780
doing-- what we've just
been working on just

00:24:11.780 --> 00:24:16.820
the last few months so you have
sort of a feeling of what we're

00:24:16.820 --> 00:24:17.990
up to right now.

00:24:17.990 --> 00:24:21.090
And I'll talk about what's
going on in the N release.

00:24:21.090 --> 00:24:24.330
First of all, I've made a
lot of mistakes in my career.

00:24:24.330 --> 00:24:26.040
I'm happy to admit that.

00:24:26.040 --> 00:24:29.010
One of them was I was
so aggressive at trying

00:24:29.010 --> 00:24:32.570
to reduce latency that
I took some shortcuts

00:24:32.570 --> 00:24:35.080
and cut some corners that
have, in retrospect, turned out

00:24:35.080 --> 00:24:37.220
to be not advisable.

00:24:37.220 --> 00:24:43.524
One of those was, on the output
side in the device driver,

00:24:43.524 --> 00:24:44.940
we've always had
double buffering.

00:24:44.940 --> 00:24:46.910
And there's some very
good reasons for that.

00:24:46.910 --> 00:24:51.030
But on the app level, we were
encouraging app developers

00:24:51.030 --> 00:24:55.170
to do single buffering in the
application, with the rationale

00:24:55.170 --> 00:24:58.030
being that the app could
provide the data immediately

00:24:58.030 --> 00:24:59.990
and everything would be OK.

00:24:59.990 --> 00:25:02.750
That works fine for apps
that create sine waves.

00:25:02.750 --> 00:25:06.730
But fortunately-- or
unfortunately, those

00:25:06.730 --> 00:25:08.580
are not real ProAudio apps.

00:25:08.580 --> 00:25:10.630
Real ProAudio apps,
such as the ones

00:25:10.630 --> 00:25:14.900
that you saw Dan demo earlier,
use a huge amount of CPU.

00:25:14.900 --> 00:25:17.910
And they would like to
use way more than 20%.

00:25:17.910 --> 00:25:20.300
And to do that,
and do it reliably

00:25:20.300 --> 00:25:23.900
without glitching, even
under stressful conditions,

00:25:23.900 --> 00:25:26.140
you need to have double
buffering in the application

00:25:26.140 --> 00:25:26.640
level.

00:25:26.640 --> 00:25:29.600
So I'm happy to announce
that in N, we're finally

00:25:29.600 --> 00:25:32.450
enabling double,
or even further,

00:25:32.450 --> 00:25:34.100
buffering in the
application level

00:25:34.100 --> 00:25:35.670
for those apps that need it.

00:25:35.670 --> 00:25:38.851
And with an accompanying very
slight increase in latency,

00:25:38.851 --> 00:25:39.350
of course.

00:25:39.350 --> 00:25:41.207
But it's usually not important.

00:25:41.207 --> 00:25:42.790
Then the other thing
I want to mention

00:25:42.790 --> 00:25:45.230
is, for those of you
who love the SGK,

00:25:45.230 --> 00:25:46.720
the SGK is still there.

00:25:46.720 --> 00:25:50.490
And we've improved the audio
latency on the audio track

00:25:50.490 --> 00:25:52.510
APIs, too, so that
you can take advantage

00:25:52.510 --> 00:25:54.310
of some of the
improvements we've been

00:25:54.310 --> 00:25:58.140
making in latency there, too.

00:25:58.140 --> 00:26:01.400
You've heard at both the
keynote and lots of sessions

00:26:01.400 --> 00:26:04.120
this week about our VR effort.

00:26:04.120 --> 00:26:07.520
And VR is very focused on
performance, especially

00:26:07.520 --> 00:26:09.020
predictable performance.

00:26:09.020 --> 00:26:11.370
It turns out that
VR is, by nature,

00:26:11.370 --> 00:26:15.040
a real-time kind of application,
very similar to ProAudio.

00:26:15.040 --> 00:26:17.390
And their needs are
very similar to ours.

00:26:17.390 --> 00:26:18.890
So we've been
working very closely

00:26:18.890 --> 00:26:21.402
with VR and the
performance teams.

00:26:21.402 --> 00:26:22.860
Right now, the
features that you've

00:26:22.860 --> 00:26:25.640
heard about with VR, such
as sustained performance

00:26:25.640 --> 00:26:29.020
mode, those are only
available for VR as of now.

00:26:29.020 --> 00:26:30.980
However, we are
working together,

00:26:30.980 --> 00:26:34.570
and I really hope to be able to
bring those kind of performance

00:26:34.570 --> 00:26:38.310
guarantees to other vertical
domains, such as ProAudio

00:26:38.310 --> 00:26:42.464
and any other use
cases like that.

00:26:42.464 --> 00:26:43.880
As long as we're
talking about VR,

00:26:43.880 --> 00:26:47.230
I wanted to mention there's
a VR session tomorrow

00:26:47.230 --> 00:26:48.130
morning at 9:00 AM.

00:26:48.130 --> 00:26:50.220
I hope you can attend.

00:26:50.220 --> 00:26:53.670
One of my colleagues is
presenting on VR audio.

00:26:53.670 --> 00:26:55.660
And also, we also have
another presentation

00:26:55.660 --> 00:26:58.790
by Dan tomorrow morning
also, competing with that,

00:26:58.790 --> 00:26:59.480
on the NDK.

00:26:59.480 --> 00:27:01.440
So both should be
of interest to you,

00:27:01.440 --> 00:27:03.420
and hopefully you
can split yourselves

00:27:03.420 --> 00:27:05.760
to go to both sessions.

00:27:05.760 --> 00:27:07.460
OK.

00:27:07.460 --> 00:27:10.960
So here again is the website
for all things audio,

00:27:10.960 --> 00:27:11.970
for all things ProAudio.

00:27:11.970 --> 00:27:15.150
It's
bit.ly/high-performance-audio.

00:27:15.150 --> 00:27:19.750
If you don't remember any other
URL, please remember that one.

00:27:19.750 --> 00:27:22.590
So although we have been making
progress over the last three

00:27:22.590 --> 00:27:25.640
years, I do want to acknowledge
that we're not done yet.

00:27:25.640 --> 00:27:28.660
And we certainly have a
lot more work left ahead

00:27:28.660 --> 00:27:31.610
of us, and some of which I
know about, some of which

00:27:31.610 --> 00:27:34.904
I can't predict yet, because
we haven't hit them yet.

00:27:34.904 --> 00:27:36.320
What I will share
with you is what

00:27:36.320 --> 00:27:38.740
we're working on right
now that we know about.

00:27:38.740 --> 00:27:42.560
And I'm acknowledging that,
yes, these are problems.

00:27:42.560 --> 00:27:45.770
And the good thing, though,
is, despite these problems,

00:27:45.770 --> 00:27:48.410
it is possible to get
real work done on Android,

00:27:48.410 --> 00:27:52.350
as you've seen these
four apps earlier.

00:27:52.350 --> 00:27:55.780
The first thing is more
predictable CPU scheduling

00:27:55.780 --> 00:27:58.740
and CPU bandwidth so that
you don't need tricks

00:27:58.740 --> 00:28:00.300
like the fake touch.

00:28:00.300 --> 00:28:04.250
And also so that you can use
more than 20% of the CPU.

00:28:04.250 --> 00:28:05.960
The next is our API.

00:28:05.960 --> 00:28:09.570
We recognize that open
SLES is a hard-to-use API.

00:28:09.570 --> 00:28:11.850
It requires a lot
of boilerplate code.

00:28:11.850 --> 00:28:15.720
And just saying open
SLES is awkward.

00:28:15.720 --> 00:28:17.800
I want a simpler name.

00:28:17.800 --> 00:28:19.650
So we're listening
to developers.

00:28:19.650 --> 00:28:22.710
And I can't make any promises
yet about what it will be

00:28:22.710 --> 00:28:25.330
or what it will look like, but
we are working on a new API.

00:28:25.330 --> 00:28:28.100
And don't worry if
you love open SLES.

00:28:28.100 --> 00:28:31.360
It will still be there.

00:28:31.360 --> 00:28:33.560
Finally, round-trip latency.

00:28:33.560 --> 00:28:35.670
Currently, our goal
for the ProAudio flag

00:28:35.670 --> 00:28:37.330
is 20 milliseconds.

00:28:37.330 --> 00:28:40.330
And that is good for
many, many applications,

00:28:40.330 --> 00:28:43.300
especially applications that
only do output-only processing,

00:28:43.300 --> 00:28:48.250
because then they don't--
their latency is only a portion

00:28:48.250 --> 00:28:48.820
of this.

00:28:48.820 --> 00:28:51.840
However, there are applications
such as guitar processing,

00:28:51.840 --> 00:28:53.720
voice processing,
that can benefit

00:28:53.720 --> 00:28:55.120
from even lower latency.

00:28:55.120 --> 00:28:58.480
So we are working towards that
magic 10-millisecond round-trip

00:28:58.480 --> 00:29:00.010
latency figure.

00:29:00.010 --> 00:29:04.320
And I want to achieve that
without causing power problems.

00:29:04.320 --> 00:29:06.070
It turns out, in
the lab, we have

00:29:06.070 --> 00:29:09.140
hit 10 millisecond round-trip,
but it used too much power.

00:29:09.140 --> 00:29:12.520
And so it's not really
ready for release yet.

00:29:12.520 --> 00:29:14.980
So I won't be done
with this effort

00:29:14.980 --> 00:29:18.620
until Aiden is happy
being creative on Android,

00:29:18.620 --> 00:29:22.370
and until all of you are happy
being creative on Android.

00:29:22.370 --> 00:29:24.824
Thank you for coming today.

00:29:24.824 --> 00:29:28.568
[APPLAUSE]

00:29:30.187 --> 00:29:32.520
At this point, I want to
switch to some acknowledgments.

00:29:32.520 --> 00:29:34.830
You already heard some
acknowledgements from Dan

00:29:34.830 --> 00:29:38.550
about our app partners, a few
of whom are in the room today.

00:29:38.550 --> 00:29:40.560
So look for them later on.

00:29:40.560 --> 00:29:43.190
For me personally, though,
the people that I work with

00:29:43.190 --> 00:29:46.996
most closely are F
and F F And I want

00:29:46.996 --> 00:29:49.120
to acknowledge a few of
them by name, although I've

00:29:49.120 --> 00:29:50.390
worked with many of them.

00:29:50.390 --> 00:29:53.100
First of all,
Qualcomm has really

00:29:53.100 --> 00:29:56.640
worked hard to reduce the audio
latency in their signal path,

00:29:56.640 --> 00:29:58.050
especially in the DSP.

00:29:58.050 --> 00:30:00.520
They've been optimizing
that recently.

00:30:00.520 --> 00:30:03.430
Another company I'd like
to acknowledge is NVIDIA.

00:30:03.430 --> 00:30:05.990
They've been
focusing on improving

00:30:05.990 --> 00:30:10.300
performance and reliability
and stability of scheduling

00:30:10.300 --> 00:30:12.410
and task wake-up.

00:30:12.410 --> 00:30:16.615
I'm really thrilled to announce
that the demos that you saw

00:30:16.615 --> 00:30:17.990
today, at least
one of the demos,

00:30:17.990 --> 00:30:22.560
was done on the NVIDIA
Shield K1, and using an early

00:30:22.560 --> 00:30:27.770
build of Android that supports
Android ProAudio flag.

00:30:27.770 --> 00:30:31.110
And for more information,
please check out these URLs.

00:30:31.110 --> 00:30:33.960
NVIDIA will be happy
to-- if you sign up

00:30:33.960 --> 00:30:38.920
for their-- to let you download
over OTA a special developer

00:30:38.920 --> 00:30:42.430
preview of their
Android ProAudio access.

00:30:42.430 --> 00:30:44.769
And if you have questions
about that later on,

00:30:44.769 --> 00:30:46.060
we have people in the audience.

00:30:46.060 --> 00:30:49.660
We have [INAUDIBLE]-- thank
you, [INAUDIBLE]-- and Bill,

00:30:49.660 --> 00:30:52.130
who can also answer your
questions about Android

00:30:52.130 --> 00:30:53.920
ProAudio on NVIDIA.

00:30:53.920 --> 00:30:55.440
There's one company,
though, that I

00:30:55.440 --> 00:30:59.900
want to acknowledge that I
work with even more than-- I

00:30:59.900 --> 00:31:01.720
want to give them very
special thank you.

00:31:01.720 --> 00:31:03.230
And that's Samsung Mobile.

00:31:03.230 --> 00:31:06.610
The reason is is that we're kind
of late to the ProAudio party.

00:31:06.610 --> 00:31:08.780
We started thinking
about it a few years ago,

00:31:08.780 --> 00:31:10.720
but it turns out
Samsung Mobile has

00:31:10.720 --> 00:31:13.620
been-- has had that on their
radar for many, many years.

00:31:13.620 --> 00:31:16.700
They saw a real gap
in Android compared

00:31:16.700 --> 00:31:19.970
to our competitor platforms,
and they started working on it.

00:31:19.970 --> 00:31:21.470
And over the last
few years, they've

00:31:21.470 --> 00:31:24.720
been working on the
Samsung ProAudio SDK,

00:31:24.720 --> 00:31:27.130
evolving it, coming out
with multiple releases,

00:31:27.130 --> 00:31:30.750
and along with accompanying apps
that work well on the ProAudio

00:31:30.750 --> 00:31:31.430
SDK.

00:31:31.430 --> 00:31:35.060
So I want to acknowledge
Samsung Mobile and invite both

00:31:35.060 --> 00:31:38.610
[? Tamin ?] [? Cho ?] and Johnny
[? Zhou ?] up to the stage.

00:31:38.610 --> 00:31:39.720
Thank you.

00:31:39.720 --> 00:31:40.700
[APPLAUSE]

00:31:40.700 --> 00:31:43.384
Do you have a mic?

00:31:43.384 --> 00:31:44.378
Thank you.

00:31:44.378 --> 00:31:46.863
Thank you.

00:31:46.863 --> 00:31:49.845
Thank you.

00:31:49.845 --> 00:31:52.169
Yeah, OK.

00:31:52.169 --> 00:31:54.460
[? JOHNNY ZHOU: Hello. ?] My
name is Johnny [? Zhou. ?]

00:31:54.460 --> 00:31:56.418
I'm product owner of
Samsung Professional Audio

00:31:56.418 --> 00:31:58.510
and SoundCamp.

00:31:58.510 --> 00:32:02.950
I really appreciate Glen and
Ray inviting us on this stage.

00:32:02.950 --> 00:32:06.100
As you saw in this
session, Android ProAudio

00:32:06.100 --> 00:32:08.210
has great potential
and opportunities

00:32:08.210 --> 00:32:10.030
for Android developers.

00:32:10.030 --> 00:32:13.330
And I believe it will
be great-- even greater

00:32:13.330 --> 00:32:16.534
with Samsung Professional
Audio and its collaboration

00:32:16.534 --> 00:32:17.450
with Android ProAudio.

00:32:19.970 --> 00:32:21.490
Our lead engineer,
[? Tamin Cho, ?]

00:32:21.490 --> 00:32:24.502
will give you more
details about it.

00:32:24.502 --> 00:32:27.890
[APPLAUSE]

00:32:27.890 --> 00:32:31.620
[? TAMIN CHO: Hi. ?]
Samsung Professional Audio--

00:32:31.620 --> 00:32:36.280
also called SAPA for short--
is Samsung's own professional

00:32:36.280 --> 00:32:38.160
audio framework.

00:32:38.160 --> 00:32:42.830
It was first released in 2013,
and it has two major features.

00:32:42.830 --> 00:32:46.010
Of course, the first one
is the low latency audio.

00:32:46.010 --> 00:32:48.650
The first version showed the
60-millisecond round-trip

00:32:48.650 --> 00:32:51.190
latency on Galaxy Note 2.3.

00:32:51.190 --> 00:32:53.680
And the second one is
the interapplication

00:32:53.680 --> 00:32:56.831
of their routing, which allows
the streaming audio and MIDI

00:32:56.831 --> 00:32:58.206
between the current
applications.

00:33:02.120 --> 00:33:03.210
Yes.

00:33:03.210 --> 00:33:08.040
Lots more details about the
interapplication audio routing.

00:33:08.040 --> 00:33:11.810
So here is an audio
application you made.

00:33:11.810 --> 00:33:16.180
And you want to add some
effects to the sound.

00:33:16.180 --> 00:33:19.200
Then you have to
build every effects

00:33:19.200 --> 00:33:23.950
into the same
application, or using SAPA

00:33:23.950 --> 00:33:28.660
you can connect your app
to other effects apps.

00:33:28.660 --> 00:33:31.870
You can connect as
many apps you want,

00:33:31.870 --> 00:33:38.180
depending on the CPU in whatever
form, in serial and parallel,

00:33:38.180 --> 00:33:41.760
with no additional delay.

00:33:41.760 --> 00:33:44.720
SAPA's interapplication
audio routing

00:33:44.720 --> 00:33:48.990
is based on the well-known
JACK audio connection kit.

00:33:48.990 --> 00:33:52.140
So if you're familiar
with the JACK [INAUDIBLE],

00:33:52.140 --> 00:33:56.350
then you just say gotcha.

00:33:56.350 --> 00:34:02.370
So with this, even you
can build a PC like a DAWF

00:34:02.370 --> 00:34:06.250
so you can load multiple
plug-in instruments and effects,

00:34:06.250 --> 00:34:09.560
run them simultaneously,
and mix the sounds.

00:34:09.560 --> 00:34:12.610
It's highly extensible.

00:34:12.610 --> 00:34:16.889
And Samsung also provide
the own DWF, which

00:34:16.889 --> 00:34:18.420
is a plug-in architecture.

00:34:18.420 --> 00:34:21.219
So you just make a
plug-in and use that.

00:34:24.070 --> 00:34:31.070
SAPA-- in order to achieve the
low latencies, SAPA actually--

00:34:31.070 --> 00:34:34.800
we made SAPA independent
from the audio-- Android

00:34:34.800 --> 00:34:37.580
audio system.

00:34:37.580 --> 00:34:42.750
So this why SAPA is only
available on Samsung devices.

00:34:42.750 --> 00:34:49.070
But within this year, SAPA
is running on the Android

00:34:49.070 --> 00:34:54.610
audio system because, thanks
to the Android ProAudio,

00:34:54.610 --> 00:34:59.470
the low latency is available
on Android audio system.

00:34:59.470 --> 00:35:03.810
That means SAPA is also
available on known Samsung

00:35:03.810 --> 00:35:05.710
devices.

00:35:05.710 --> 00:35:06.420
So Sam--

00:35:06.420 --> 00:35:08.570
[APPLAUSE]

00:35:08.570 --> 00:35:11.230
Thank you.

00:35:11.230 --> 00:35:14.960
So Samsung decided for
the next flagship device,

00:35:14.960 --> 00:35:18.310
our next flagship device, we
going to support the Android

00:35:18.310 --> 00:35:20.880
[? ProAudio ?] {} hardware flag.

00:35:20.880 --> 00:35:21.960
Thank you.

00:35:21.960 --> 00:35:24.050
And if you need
more information,

00:35:24.050 --> 00:35:26.560
please refer to the URL here.

00:35:26.560 --> 00:35:30.510
And send the questions
to sapa@samsung.com.

00:35:30.510 --> 00:35:35.150
And if you have any urgent
question, ask me or Johnny.

00:35:35.150 --> 00:35:37.550
[? GLEN CASTIN: ?] Thank you
so much for coming today.

00:35:37.550 --> 00:35:40.390
We look forward to seeing
you at the demo booth, too.

00:35:40.390 --> 00:35:41.800
Thank you.

00:35:41.800 --> 00:35:45.450
[MUSIC PLAYING]

