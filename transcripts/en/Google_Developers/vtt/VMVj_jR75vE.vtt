WEBVTT
Kind: captions
Language: en

00:00:09.234 --> 00:00:11.178
MALE SPEAKER: Bidelman [KOREAN].

00:00:11.178 --> 00:00:12.733
[APPLAUSE]

00:00:12.733 --> 00:00:13.608
ERIC BIDELMAN: Hello.

00:00:16.530 --> 00:00:18.870
Everyone say cheese.

00:00:18.870 --> 00:00:20.345
Thanks for coming.

00:00:22.970 --> 00:00:24.470
So we're going to
talk about Polymer

00:00:24.470 --> 00:00:28.420
for the next 40 to 45 minutes.

00:00:28.420 --> 00:00:30.020
I'm really excited
about Polymer.

00:00:30.020 --> 00:00:31.790
Polymer is a new
library for the web

00:00:31.790 --> 00:00:34.090
that we're building
at Google to help

00:00:34.090 --> 00:00:37.310
developers use Web Components.

00:00:37.310 --> 00:00:39.170
So a little bit
about myself so you

00:00:39.170 --> 00:00:41.409
know who is talking
to you up here.

00:00:41.409 --> 00:00:42.450
My name is Eric Bidelman.

00:00:42.450 --> 00:00:44.830
I work on the Google
Chrome team as part

00:00:44.830 --> 00:00:47.200
of the Developer Relations team.

00:00:47.200 --> 00:00:51.470
You can follow me on Google+ or
Twitter or my website, there,

00:00:51.470 --> 00:00:56.100
that I try to blog on, but
unsuccessfully, very much.

00:00:56.100 --> 00:00:57.460
HTML5 Rocks articles.

00:00:57.460 --> 00:00:59.440
I write a lot of
stuff for HTML5 Rocks.

00:00:59.440 --> 00:01:02.350
So if you want to learn
about all this cool stuff I'm

00:01:02.350 --> 00:01:05.459
going to talk about today, feel
free to visit those articles

00:01:05.459 --> 00:01:06.450
there.

00:01:06.450 --> 00:01:08.540
Does anybody see the
Easter egg in this picture?

00:01:08.540 --> 00:01:13.650
There's a little-- the
incognito guy for Chrome.

00:01:13.650 --> 00:01:14.650
He's on my glasses.

00:01:17.600 --> 00:01:19.190
It's pretty cool.

00:01:19.190 --> 00:01:20.170
So Web Components.

00:01:20.170 --> 00:01:21.330
What are Web Components?

00:01:21.330 --> 00:01:24.220
How many people have heard
about Web Components in general,

00:01:24.220 --> 00:01:26.739
or the technology behind it?

00:01:26.739 --> 00:01:27.530
A couple of people?

00:01:27.530 --> 00:01:28.029
OK.

00:01:28.029 --> 00:01:30.190
You guys are in
for a real treat.

00:01:30.190 --> 00:01:32.844
Anybody that is a web developer
in the audience, I think,

00:01:32.844 --> 00:01:34.510
understands this stuff
once they see it.

00:01:34.510 --> 00:01:35.660
It's very, very powerful.

00:01:35.660 --> 00:01:38.020
And there's a lot of
stuff that the browsers

00:01:38.020 --> 00:01:42.370
are adding in order to make
developers' lives easier.

00:01:42.370 --> 00:01:43.410
So Web Components.

00:01:43.410 --> 00:01:44.680
An example of a web component.

00:01:44.680 --> 00:01:47.080
The blink tag is
back in the browser.

00:01:47.080 --> 00:01:50.342
But this time, you can implement
it as a new custom element.

00:01:50.342 --> 00:01:52.300
So essentially, that's
what Web Components are.

00:01:52.300 --> 00:01:55.570
That's one facet
of Web Components--

00:01:55.570 --> 00:01:58.384
you can implement
new tags in HTML.

00:01:58.384 --> 00:02:00.550
And this one-- it doesn't
use the browser internals.

00:02:00.550 --> 00:02:06.120
It just uses CSS animations
to do the blinking effect.

00:02:06.120 --> 00:02:08.203
You guys are probably
familiar with this one here.

00:02:08.203 --> 00:02:10.470
[MUSIC_-_PSY,_"GANGNAM_STYLE"]

00:02:10.470 --> 00:02:12.640
ERIC BIDELMAN: But what
this gangnam-style tag does

00:02:12.640 --> 00:02:15.319
is somebody declares
this tag on their page,

00:02:15.319 --> 00:02:17.860
and boom-- as soon as somebody
hovers over this little thing,

00:02:17.860 --> 00:02:21.380
it plays the song using
the Web Audio API.

00:02:21.380 --> 00:02:24.630
And there's a little dance
using CSS animations.

00:02:24.630 --> 00:02:26.630
It's kind of a silly
example of a web component.

00:02:26.630 --> 00:02:28.750
But again, all
somebody has to do

00:02:28.750 --> 00:02:30.520
is declare this thing
on a page, and they

00:02:30.520 --> 00:02:31.936
get all this other
stuff for free,

00:02:31.936 --> 00:02:35.420
encapsulated in this component.

00:02:35.420 --> 00:02:38.370
But we can do more than just
regular tags or silly examples.

00:02:38.370 --> 00:02:42.770
We can actually wrap up entire
applications and functionality

00:02:42.770 --> 00:02:44.310
inside of a tag.

00:02:44.310 --> 00:02:48.510
So as a user, I can declare
the photo-booth tag on my page.

00:02:48.510 --> 00:02:51.040
And this particular
example just wraps

00:02:51.040 --> 00:02:53.770
the getUserMedia API
that Alex talked about.

00:02:53.770 --> 00:02:55.930
So I'll allow that.

00:02:55.930 --> 00:02:58.500
So it runs a little bit of
JavaScript in the background.

00:02:58.500 --> 00:03:00.750
And so as a user, I just
have this thing on my page,

00:03:00.750 --> 00:03:03.495
and boom-- I have photo sharing,
sort of video capabilities

00:03:03.495 --> 00:03:07.620
with a little CSS filter
action right on my page.

00:03:07.620 --> 00:03:10.020
And it's even got an
API to do snapshotting,

00:03:10.020 --> 00:03:11.050
which is kind of cool.

00:03:11.050 --> 00:03:12.780
It just renders out to a canvas.

00:03:12.780 --> 00:03:15.280
But again, all of this comes
for free just by somebody

00:03:15.280 --> 00:03:17.026
putting that on their page.

00:03:17.026 --> 00:03:18.150
It's getting kind of crazy.

00:03:20.770 --> 00:03:23.970
If you don't like the way the
native HTML elements behave--

00:03:23.970 --> 00:03:25.880
say, you're not too
excited about a button,

00:03:25.880 --> 00:03:27.810
doesn't look really
good, you have

00:03:27.810 --> 00:03:30.260
to add a click handler
to it or something--

00:03:30.260 --> 00:03:31.730
you can create a
web component that

00:03:31.730 --> 00:03:34.050
says my button is a
special type of button.

00:03:34.050 --> 00:03:35.570
It's going to be a mega button.

00:03:35.570 --> 00:03:37.770
And this mega button
is not a normal button.

00:03:37.770 --> 00:03:41.470
It actually, when I mouse over
it, it has some crazy CSS.

00:03:41.470 --> 00:03:43.371
And it's actually got--

00:03:43.371 --> 00:03:43.870
[MOO]

00:03:43.870 --> 00:03:46.130
ERIC BIDELMAN: --a default
behavior that moos at you.

00:03:46.130 --> 00:03:48.680
So again, kind of interesting
and silly for the web.

00:03:48.680 --> 00:03:51.650
But I can basically redefine
the way native buttons

00:03:51.650 --> 00:03:53.915
behave in HTML by
using Web Components.

00:03:58.830 --> 00:04:01.560
So if you take a look at
actually real world examples

00:04:01.560 --> 00:04:04.880
on the web today, a really
sort of quintessential example

00:04:04.880 --> 00:04:06.540
is a tab component.

00:04:06.540 --> 00:04:07.740
These are everywhere.

00:04:07.740 --> 00:04:10.260
Every library has
a tab component.

00:04:10.260 --> 00:04:12.040
This is what it
looks like in jQuery.

00:04:12.040 --> 00:04:13.600
There's a bunch of markup.

00:04:13.600 --> 00:04:15.810
Some of it's meaningless to me.

00:04:15.810 --> 00:04:20.079
You're overloading ULs and LIs.

00:04:20.079 --> 00:04:22.600
This is what I
believe what YUI does.

00:04:22.600 --> 00:04:25.156
Instead of a declarative
markup approach,

00:04:25.156 --> 00:04:27.030
they've taken more of
a JavaScript approach--

00:04:27.030 --> 00:04:28.490
an imperative approach.

00:04:28.490 --> 00:04:30.990
So you include your
HTML in JavaScript,

00:04:30.990 --> 00:04:33.630
and then you call
a render method.

00:04:33.630 --> 00:04:35.810
This is Angular's
version of creating

00:04:35.810 --> 00:04:37.665
what they call directives--
custom elements.

00:04:37.665 --> 00:04:39.040
Their version of
custom elements.

00:04:39.040 --> 00:04:40.917
And so you write a lot
of JavaScript code.

00:04:40.917 --> 00:04:42.500
And the reason all
these are different

00:04:42.500 --> 00:04:45.670
is because the APIs in the
browser-- in the web platform--

00:04:45.670 --> 00:04:48.200
haven't existed,
until now, to be

00:04:48.200 --> 00:04:50.720
able to really, really define
what a tab component means

00:04:50.720 --> 00:04:53.810
semantically, and
easily, and consistently

00:04:53.810 --> 00:04:55.590
across these
different frameworks.

00:04:55.590 --> 00:04:57.099
This is Kendo UI's version.

00:04:57.099 --> 00:04:58.140
This is Sencha's version.

00:04:58.140 --> 00:04:59.995
Every one is different.

00:04:59.995 --> 00:05:01.130
It's pretty insane.

00:05:01.130 --> 00:05:04.585
It's insane as this picture.

00:05:04.585 --> 00:05:06.600
But what about--
not just components.

00:05:06.600 --> 00:05:09.112
What about whole applications?

00:05:09.112 --> 00:05:10.570
If you take a look
at the DevTools,

00:05:10.570 --> 00:05:13.070
if you open up Gmail--
how many people

00:05:13.070 --> 00:05:16.426
think that his source
code is readable?

00:05:16.426 --> 00:05:17.160
Yeah, nobody.

00:05:17.160 --> 00:05:18.060
Exactly.

00:05:18.060 --> 00:05:19.640
So it's all divs.

00:05:19.640 --> 00:05:20.650
We call this div soup.

00:05:20.650 --> 00:05:22.300
It's meaningless to a developer.

00:05:22.300 --> 00:05:23.390
I can't maintain this.

00:05:23.390 --> 00:05:24.890
I have no idea what it's doing.

00:05:24.890 --> 00:05:28.060
Some of the stuff is obfuscated
for performance reasons.

00:05:28.060 --> 00:05:31.260
But at its core, we don't
have the primitive tools

00:05:31.260 --> 00:05:34.592
to describe what
Gmail should be.

00:05:34.592 --> 00:05:36.026
What?

00:05:36.026 --> 00:05:37.460
What?

00:05:37.460 --> 00:05:39.620
This is how we build web
applications, you guys.

00:05:39.620 --> 00:05:41.540
And it feels really dirty to me.

00:05:41.540 --> 00:05:44.350
But what if Gmail Chat, for
instance, looked like this?

00:05:44.350 --> 00:05:45.720
What if it was meaningful again?

00:05:45.720 --> 00:05:47.860
What if markup was meaningful?

00:05:47.860 --> 00:05:49.620
So instead of a
bunch of divs, I had

00:05:49.620 --> 00:05:51.910
something like a
Hangouts module tag--

00:05:51.910 --> 00:05:53.710
a custom element
to describe this.

00:05:53.710 --> 00:05:56.200
Inside of that, we
have a hangout-chat.

00:05:56.200 --> 00:05:57.950
I'm chatting with Paul and Addy.

00:05:57.950 --> 00:06:01.110
Just an HTML attribute
that I've added.

00:06:01.110 --> 00:06:04.410
My profile ID is included
in this HTML element.

00:06:04.410 --> 00:06:06.620
Inside of that, I
have a discussion tag.

00:06:06.620 --> 00:06:07.700
This is totally legible.

00:06:07.700 --> 00:06:09.020
It totally makes sense.

00:06:09.020 --> 00:06:10.790
And each one of these
tags is a message.

00:06:10.790 --> 00:06:14.470
And it's got semantic data,
such as my profile, the date

00:06:14.470 --> 00:06:15.977
and time it was sent.

00:06:15.977 --> 00:06:17.560
And it really, really
just makes sense

00:06:17.560 --> 00:06:19.400
from a developer standpoint.

00:06:19.400 --> 00:06:20.510
I have a demo of this.

00:06:20.510 --> 00:06:24.051
This is my web component,
my Gmail Chat Hangout web

00:06:24.051 --> 00:06:24.550
component.

00:06:24.550 --> 00:06:26.710
I'm talking to Paul
Irish down here.

00:06:26.710 --> 00:06:27.627
And I can type to him.

00:06:27.627 --> 00:06:29.001
I'm going to try
to type with one

00:06:29.001 --> 00:06:30.760
hand, just a bunch
of characters.

00:06:30.760 --> 00:06:32.840
I can create a new
component in each one

00:06:32.840 --> 00:06:35.120
of these-- I'm talking
to Larry Page now.

00:06:35.120 --> 00:06:35.855
He knows Spanish.

00:06:39.540 --> 00:06:40.760
But these have functionality.

00:06:40.760 --> 00:06:44.600
These components wrap up
this collapsible widget.

00:06:44.600 --> 00:06:45.810
I can add new ones.

00:06:45.810 --> 00:06:49.500
And if I dive into this
using the DevTools,

00:06:49.500 --> 00:06:52.760
I can see that ultimately
what I've implemented here

00:06:52.760 --> 00:06:54.430
is that the Hangout module.

00:06:54.430 --> 00:06:56.180
Inside a hangout-module,
we have a bunch--

00:06:56.180 --> 00:06:57.690
we have the discussion tag.

00:07:01.600 --> 00:07:04.910
And inside of these, we have the
custom element hangout-message.

00:07:04.910 --> 00:07:06.527
And so I've done
this using Polymer.

00:07:06.527 --> 00:07:08.360
And that's what I'm
going to talk about now.

00:07:08.360 --> 00:07:10.340
But it just makes
sense when you're

00:07:10.340 --> 00:07:13.781
implementing this stuff
using Web Components.

00:07:13.781 --> 00:07:15.460
So this feels really good.

00:07:15.460 --> 00:07:19.490
I'm really happy about this
direction as a web developer.

00:07:19.490 --> 00:07:23.100
So the better tools that we're
adding to the web platform

00:07:23.100 --> 00:07:25.480
come in sort of three or
four different flavors.

00:07:25.480 --> 00:07:28.250
And the whole Web Components
notion-- they all share

00:07:28.250 --> 00:07:30.910
this umbrella
term-- is made up by

00:07:30.910 --> 00:07:33.310
several different
specifications.

00:07:33.310 --> 00:07:34.950
And so the first is Shadow DOM.

00:07:34.950 --> 00:07:36.490
Shadow DOM's a
new API that we're

00:07:36.490 --> 00:07:38.670
adding to the
browser that allows

00:07:38.670 --> 00:07:41.430
you to do DOM and
style encapsulation.

00:07:41.430 --> 00:07:43.430
So styles don't bleed
into your component.

00:07:43.430 --> 00:07:45.930
Styles that you define
inside don't bleed out.

00:07:45.930 --> 00:07:49.310
That makes a lot of sense when
you're talking Web Components.

00:07:49.310 --> 00:07:50.710
HTML templates.

00:07:50.710 --> 00:07:52.160
Proper templating in a browser.

00:07:52.160 --> 00:07:55.740
The template element allows you
to define sections of markup

00:07:55.740 --> 00:07:56.900
to be used for later.

00:07:56.900 --> 00:07:59.060
This is really handy
when you're stamping out

00:07:59.060 --> 00:08:01.710
a bunch of dynamic DOM.

00:08:01.710 --> 00:08:04.050
Custom elements is
another specification

00:08:04.050 --> 00:08:05.570
as part of Web Components.

00:08:05.570 --> 00:08:10.120
And this is sort of the
core API behind this stuff.

00:08:10.120 --> 00:08:12.510
It allows you to create new
tags and tell the browser

00:08:12.510 --> 00:08:15.590
about the gangnam-style
tag or the photo-booth tag.

00:08:15.590 --> 00:08:19.450
And you can also extend existing
elements if you want to.

00:08:19.450 --> 00:08:22.370
And the last piece of the
Web Components ecosystem

00:08:22.370 --> 00:08:24.860
is what's called HTML imports.

00:08:24.860 --> 00:08:25.860
And this is really cool.

00:08:25.860 --> 00:08:28.380
It's a very, very simple API.

00:08:28.380 --> 00:08:29.900
Essentially, we get a link tag.

00:08:29.900 --> 00:08:32.110
And instead of a
rel="stylesheet",

00:08:32.110 --> 00:08:33.470
it's a rel="import".

00:08:33.470 --> 00:08:35.750
And you can reference
an HTML file.

00:08:35.750 --> 00:08:37.799
And it's essentially
like a #include,

00:08:37.799 --> 00:08:39.480
if you're familiar
C++ for the web.

00:08:39.480 --> 00:08:43.480
You get to bring in another file
of HTML, CSS, and JavaScript

00:08:43.480 --> 00:08:44.370
all bundled together.

00:08:44.370 --> 00:08:46.370
And then somebody can
bring that into their page

00:08:46.370 --> 00:08:47.684
and start using it.

00:08:47.684 --> 00:08:48.600
So that's really cool.

00:08:48.600 --> 00:08:50.440
It's a way to
distribute and bundle

00:08:50.440 --> 00:08:53.600
common markup, common
JavaScript, and common CSS.

00:08:56.450 --> 00:08:59.410
Alongside of these four
main specifications,

00:08:59.410 --> 00:09:02.540
we have other primitives that
we're adding-- the browser

00:09:02.540 --> 00:09:04.950
to adding-- to do things
like data binding.

00:09:04.950 --> 00:09:06.950
If you're making a web
application these days

00:09:06.950 --> 00:09:09.850
in a framework-- Angular,
Ember, one of these frameworks--

00:09:09.850 --> 00:09:12.130
likely is that you're going
to be using data binding.

00:09:12.130 --> 00:09:13.954
This is really popular.

00:09:13.954 --> 00:09:15.370
And so some of the
primitives that

00:09:15.370 --> 00:09:17.840
are going to allow this to
be native in the browser

00:09:17.840 --> 00:09:19.690
are things like Object.observe.

00:09:19.690 --> 00:09:22.130
So being able to get changes
when a JavaScript object

00:09:22.130 --> 00:09:24.800
changes-- get notifications
of what's going on,

00:09:24.800 --> 00:09:26.387
what has changed.

00:09:26.387 --> 00:09:28.220
And so that increases
performance and allows

00:09:28.220 --> 00:09:30.950
you to write really,
really slick web apps.

00:09:30.950 --> 00:09:31.980
Template is an example.

00:09:31.980 --> 00:09:34.610
Being able to stamp
out dynamic markup.

00:09:34.610 --> 00:09:37.290
And Mutation Observers,
sort of the equivalent

00:09:37.290 --> 00:09:39.040
of Object.observe in the DOM.

00:09:39.040 --> 00:09:42.160
So being able to decide
and make modifications

00:09:42.160 --> 00:09:43.644
when DOM has actually changed.

00:09:43.644 --> 00:09:45.060
So if somebody
removes a note, you

00:09:45.060 --> 00:09:47.445
can get a notification for that.

00:09:47.445 --> 00:09:49.840
So all in all, a
bunch of new APIs.

00:09:49.840 --> 00:09:52.380
I'm not going to talk about
these at any detail today.

00:09:52.380 --> 00:09:55.390
I'm going to talk more at a high
level, at the Polymer level.

00:09:55.390 --> 00:09:57.820
But essentially they're
a collection of new APIs

00:09:57.820 --> 00:09:59.870
that you as web
developers can play with.

00:10:04.480 --> 00:10:04.980
All right.

00:10:04.980 --> 00:10:07.879
So let's talk about Polymer.

00:10:07.879 --> 00:10:08.670
So what is Polymer?

00:10:08.670 --> 00:10:12.901
How many people have
even heard of Polymer?

00:10:12.901 --> 00:10:13.400
Cool.

00:10:13.400 --> 00:10:14.191
A couple of people.

00:10:14.191 --> 00:10:14.710
Awesome.

00:10:14.710 --> 00:10:18.130
So my take on Polymer is--
and the goals of Polymer--

00:10:18.130 --> 00:10:20.130
is that it's a new
library for the web.

00:10:20.130 --> 00:10:21.790
It's a JavaScript library.

00:10:21.790 --> 00:10:23.570
It's built on top
of Web Components.

00:10:23.570 --> 00:10:27.050
That is very at its
core-- Web Components--

00:10:27.050 --> 00:10:30.410
and the specifications
that I talked about before.

00:10:30.410 --> 00:10:32.670
And it's designed to
leverage the evolving web

00:10:32.670 --> 00:10:34.489
platform in modern browsers.

00:10:34.489 --> 00:10:36.030
And what that really
means is that we

00:10:36.030 --> 00:10:39.610
want to teach developers how
to use some of these new APIs

00:10:39.610 --> 00:10:42.160
and use them all
really well together.

00:10:42.160 --> 00:10:43.850
As you've seen in
this last slide,

00:10:43.850 --> 00:10:45.760
there's a bunch of
new stuff coming.

00:10:45.760 --> 00:10:49.820
We want to highlight an opinion,
a way to use all this together.

00:10:49.820 --> 00:10:51.240
Each one of these
technologies can

00:10:51.240 --> 00:10:53.300
be used totally
separate by themselves.

00:10:53.300 --> 00:10:56.060
That's part of this
magical picture.

00:10:56.060 --> 00:10:59.090
But together, they really form
an awesome, awesome story.

00:11:02.790 --> 00:11:03.860
So what is Polymer?

00:11:03.860 --> 00:11:06.310
This is a diagram that we have.

00:11:06.310 --> 00:11:10.900
It's our architectural
conceptual diagram.

00:11:10.900 --> 00:11:11.920
First, it's a library.

00:11:11.920 --> 00:11:15.680
It's about 48 kilobytes for
the evolving web platform.

00:11:15.680 --> 00:11:19.320
And it enables the use of
things like custom elements

00:11:19.320 --> 00:11:23.670
and pointer events and Shadow
Dom and HTML imports today

00:11:23.670 --> 00:11:25.836
using polyfill libraries.

00:11:25.836 --> 00:11:27.460
And so we actually
have, as I mentioned

00:11:27.460 --> 00:11:29.670
before, an explicit goal
to support the latest

00:11:29.670 --> 00:11:31.380
version of every browser.

00:11:31.380 --> 00:11:34.620
And one reason behind that is
because polyfilling something

00:11:34.620 --> 00:11:37.485
like Shadow DOM-- which, if you
are familiar with the details,

00:11:37.485 --> 00:11:40.310
or you read more later and
your mind sort of warps

00:11:40.310 --> 00:11:44.230
because it's a very,
very complex topic.

00:11:44.230 --> 00:11:46.540
And actually supporting
that in older browsers

00:11:46.540 --> 00:11:48.640
with limited
JavaScript capabilities

00:11:48.640 --> 00:11:50.615
is almost impossible.

00:11:50.615 --> 00:11:51.740
So it's a polyfill library.

00:11:51.740 --> 00:11:52.940
That's this red layer.

00:11:52.940 --> 00:11:55.020
That's sort of the
foundation all of Polymer's

00:11:55.020 --> 00:11:55.765
built on top of.

00:11:55.765 --> 00:11:57.020
It's built on top
of Web Components.

00:11:57.020 --> 00:11:59.455
And you can think of that
red layer as that foundation.

00:12:02.480 --> 00:12:04.100
The next layer up--
the yellow layer--

00:12:04.100 --> 00:12:08.900
is what we call the Polymer
core library, the sugaring APIs.

00:12:08.900 --> 00:12:12.620
It's a little bit of extra
special sauce, if you will,

00:12:12.620 --> 00:12:15.280
that sits on top of
the fundamental APIs.

00:12:15.280 --> 00:12:17.560
But it makes things really
easy for you to develop.

00:12:17.560 --> 00:12:20.410
So I'm going to show you some
of those examples in a bit.

00:12:20.410 --> 00:12:22.660
But it makes developing Web
Components a lot easier.

00:12:22.660 --> 00:12:25.300
Let's just put it that way.

00:12:25.300 --> 00:12:26.980
And it also
expresses our opinion

00:12:26.980 --> 00:12:29.730
on how to use these
different APIs together,

00:12:29.730 --> 00:12:32.000
which I think is really awesome.

00:12:32.000 --> 00:12:34.090
One level up from that
is the green part.

00:12:34.090 --> 00:12:35.080
These are the elements.

00:12:35.080 --> 00:12:38.870
So we're interested in building
a comprehensive set of UI

00:12:38.870 --> 00:12:41.590
elements and just
general awesome utility

00:12:41.590 --> 00:12:42.770
elements for the web.

00:12:42.770 --> 00:12:45.060
So these, again, sit on
top of Web Components.

00:12:45.060 --> 00:12:46.570
They use the Polymer core.

00:12:46.570 --> 00:12:49.580
And they sort of
represent the visual layer

00:12:49.580 --> 00:12:52.520
of what we think Web
Components can be.

00:12:52.520 --> 00:12:53.880
So it's a lot of stuff.

00:12:53.880 --> 00:12:55.860
And we have three
main philosophies.

00:12:55.860 --> 00:12:58.110
And basically, you'll hear
me say this again and again

00:12:58.110 --> 00:13:00.590
and again, and that's to
utilize the modern web platform.

00:13:00.590 --> 00:13:03.970
We want to sort of push the
limit of where the web can go.

00:13:03.970 --> 00:13:05.460
The second one is interesting.

00:13:05.460 --> 00:13:08.560
And it's conceptually hard
for people to understand this

00:13:08.560 --> 00:13:11.040
when they first are
introduced to Web Components.

00:13:11.040 --> 00:13:12.630
And it's that everything is DOM.

00:13:12.630 --> 00:13:14.550
We really want to make
markup king again.

00:13:14.550 --> 00:13:18.090
You saw the example
of the Hangouts Chat.

00:13:18.090 --> 00:13:19.140
That's all declarative.

00:13:19.140 --> 00:13:20.100
It's very declarative.

00:13:20.100 --> 00:13:22.360
And as a user of that
code, it's very easy

00:13:22.360 --> 00:13:24.270
to write a web app
just using markup.

00:13:24.270 --> 00:13:26.395
The browser understands HTML.

00:13:26.395 --> 00:13:28.940
So everything is an
element, the green layer.

00:13:28.940 --> 00:13:30.690
And the last one is
eliminate boilerplate.

00:13:30.690 --> 00:13:32.200
Who likes to write
a bunch of code

00:13:32.200 --> 00:13:34.056
over and over and over again?

00:13:34.056 --> 00:13:36.360
I should put my hand
down because I hate that.

00:13:36.360 --> 00:13:37.440
And we do too on Polymer.

00:13:37.440 --> 00:13:39.750
We want to make
your lives easier.

00:13:39.750 --> 00:13:41.250
Nobody's going to
use Web Components

00:13:41.250 --> 00:13:43.250
if you have to write
1,000 lines of code just

00:13:43.250 --> 00:13:46.170
to get one component done.

00:13:46.170 --> 00:13:47.560
So we want to be opinionated.

00:13:47.560 --> 00:13:50.310
We want to teach developers
how to use this stuff.

00:13:50.310 --> 00:13:53.730
We want you to be able to pick
and choose the parts you want.

00:13:53.730 --> 00:13:56.114
If you remember the
architecture stack,

00:13:56.114 --> 00:13:57.655
you can sort of, as
a developer, come

00:13:57.655 --> 00:14:00.454
in at any one of these levels
and pick and choose the part

00:14:00.454 --> 00:14:01.620
that you want to develop on.

00:14:01.620 --> 00:14:03.817
If you just want to
use the raw APIs,

00:14:03.817 --> 00:14:04.900
you can use the polyfills.

00:14:04.900 --> 00:14:06.590
If you want to use
the special sauce,

00:14:06.590 --> 00:14:07.770
you can use Polymer core.

00:14:07.770 --> 00:14:10.060
If you want to use our elements,
just drop them on your page

00:14:10.060 --> 00:14:12.601
and you don't even have to worry
about doing any development.

00:14:12.601 --> 00:14:15.194
That's totally cool as well.

00:14:15.194 --> 00:14:16.610
And we want to
evolve with the web

00:14:16.610 --> 00:14:19.850
and be a constant feedback
loop to the standards process.

00:14:19.850 --> 00:14:23.370
This is really, really
important on Blink and Chrome.

00:14:23.370 --> 00:14:25.440
The Polymer team is
constantly talking

00:14:25.440 --> 00:14:27.390
to the Blink engineers,
the Chrome engineers,

00:14:27.390 --> 00:14:30.490
about performance issues,
or how do I do this,

00:14:30.490 --> 00:14:33.570
or why is this sort of
slow in the browser.

00:14:33.570 --> 00:14:35.520
And so we want to
inform and make

00:14:35.520 --> 00:14:38.700
these APIs rock solid for
developers to play with.

00:14:41.749 --> 00:14:44.290
So I want to invert that pyramid
and start with the elements.

00:14:44.290 --> 00:14:47.520
I want to highlight this
notion of the green area, which

00:14:47.520 --> 00:14:49.140
is embrace DOM.

00:14:49.140 --> 00:14:50.592
Everything is an element.

00:14:50.592 --> 00:14:51.800
What does this actually mean?

00:14:54.750 --> 00:14:57.340
So the first thing that
we have is actually

00:14:57.340 --> 00:14:58.700
this polymer-ajax element.

00:14:58.700 --> 00:15:01.100
This is an example element
that we've created.

00:15:01.100 --> 00:15:05.830
And so we can actually perform
AJAX using DOM, using markup.

00:15:05.830 --> 00:15:06.800
What?

00:15:06.800 --> 00:15:07.770
That's crazy.

00:15:07.770 --> 00:15:10.330
But it's actually really,
really powerful and really cool.

00:15:10.330 --> 00:15:12.220
So we have this
polymer-ajax element.

00:15:12.220 --> 00:15:14.720
And as a user, I
put this on my page.

00:15:14.720 --> 00:15:18.360
I give it an URL of a
JSON feed, for instance.

00:15:18.360 --> 00:15:21.970
And it's also got this
configurable params attribute

00:15:21.970 --> 00:15:25.645
that I can pass in a
serialized JSON object.

00:15:25.645 --> 00:15:27.020
So we're going to
essentially get

00:15:27.020 --> 00:15:31.400
this feed, this YouTube
playlist, as a JSON feed.

00:15:31.400 --> 00:15:32.720
So I drop it on my page.

00:15:32.720 --> 00:15:36.770
And I read the documentation
about this particular element.

00:15:36.770 --> 00:15:38.350
And I recognize and
see that it fires

00:15:38.350 --> 00:15:40.680
this polymer-response event.

00:15:40.680 --> 00:15:42.414
So when that feed
has been processed,

00:15:42.414 --> 00:15:43.830
and then the request
has been made

00:15:43.830 --> 00:15:47.250
under the hood on that element,
I can listen for that event

00:15:47.250 --> 00:15:50.664
and then use your standard
JSON parse to get at the data

00:15:50.664 --> 00:15:51.580
that it returns to me.

00:15:51.580 --> 00:15:53.430
So I can run this real
quick and show you

00:15:53.430 --> 00:15:55.790
it's exactly what I
have on this page.

00:15:55.790 --> 00:15:58.515
So I have just this element
declared on this page.

00:15:58.515 --> 00:16:00.640
I'm listening for
this polymer-response.

00:16:00.640 --> 00:16:03.720
And boom-- I have my instant
playlist of YouTube videos.

00:16:03.720 --> 00:16:07.390
So the important takeaway
here is that it's just markup.

00:16:07.390 --> 00:16:10.650
The only code I've written is
your standard query selector,

00:16:10.650 --> 00:16:12.760
your standard add
event listener.

00:16:12.760 --> 00:16:13.540
It's just DOM.

00:16:13.540 --> 00:16:15.490
It's just HTML elements.

00:16:15.490 --> 00:16:18.225
I've just defined a new
functionality, a new behavior,

00:16:18.225 --> 00:16:20.930
and that's being able
to do AJAX using markup.

00:16:27.980 --> 00:16:30.370
That slide is out of place.

00:16:30.370 --> 00:16:31.650
Everything is an element.

00:16:31.650 --> 00:16:34.020
We can do things like
reading files in DOM.

00:16:34.020 --> 00:16:36.490
So how many people are familiar
with the FileReader API?

00:16:36.490 --> 00:16:40.739
Being able to read
files in HTML5?

00:16:40.739 --> 00:16:41.530
So you can do this.

00:16:41.530 --> 00:16:43.160
This is a FileReader API.

00:16:43.160 --> 00:16:45.300
And what this element
does is essentially wraps

00:16:45.300 --> 00:16:46.877
that JavaScript API.

00:16:46.877 --> 00:16:48.460
So instead of writing
a bunch of code,

00:16:48.460 --> 00:16:51.010
I can just declare this
Polymer file on my page.

00:16:51.010 --> 00:16:54.320
And I can configure this readas
attribute that it defines.

00:16:54.320 --> 00:16:57.200
I can decide to read the
file as a data URL, an array

00:16:57.200 --> 00:16:59.020
buffer, a binary
string, or text.

00:16:59.020 --> 00:17:02.480
This sort of just maps
to that JavaScript API.

00:17:02.480 --> 00:17:03.720
And same type of deal.

00:17:03.720 --> 00:17:05.599
I'll wait for the
polymer-result event.

00:17:05.599 --> 00:17:07.640
I'll attach that listener.

00:17:07.640 --> 00:17:12.170
And then I can process this
element's .result property.

00:17:12.170 --> 00:17:15.800
This file object also has a
blob property you can set,

00:17:15.800 --> 00:17:18.490
so this is how you actually
pass in the file to read.

00:17:18.490 --> 00:17:21.550
In this case, I'm just setting
it to this string, abc.

00:17:21.550 --> 00:17:23.109
And then I call its read method.

00:17:23.109 --> 00:17:26.071
So this Polymer file
element has an API.

00:17:26.071 --> 00:17:27.029
It's got a read method.

00:17:27.029 --> 00:17:30.180
It's got a result property
that I can get at that data.

00:17:30.180 --> 00:17:32.730
And all I do, again, is just
declare this on the page.

00:17:32.730 --> 00:17:34.380
So I'll hit Run.

00:17:34.380 --> 00:17:36.200
And boom-- I've read
this file that I've

00:17:36.200 --> 00:17:37.720
set using the read method.

00:17:37.720 --> 00:17:39.450
It's given me a data URL back.

00:17:39.450 --> 00:17:42.620
And if I open that, you can
see, up at the top there,

00:17:42.620 --> 00:17:45.230
the data URL that's
produced is that abc.

00:17:45.230 --> 00:17:46.170
So that's really cool.

00:17:46.170 --> 00:17:49.540
You can imagine attaching
this element to a file input,

00:17:49.540 --> 00:17:52.520
for instance, and then
having the user select files.

00:17:52.520 --> 00:17:54.550
And then reading that
using nothing but markup,

00:17:54.550 --> 00:17:55.925
instead of a bunch
of JavaScript.

00:18:00.139 --> 00:18:01.180
Everything is an element.

00:18:01.180 --> 00:18:02.661
What about things like layout?

00:18:02.661 --> 00:18:03.160
All right.

00:18:03.160 --> 00:18:05.070
We have CSS for layout.

00:18:05.070 --> 00:18:07.240
What if we made that
more declarative?

00:18:07.240 --> 00:18:08.290
Something like this.

00:18:08.290 --> 00:18:11.990
So we have a polymer-flex-layout
element that we've created.

00:18:11.990 --> 00:18:13.960
And these are ideas we're
sort of toying with.

00:18:13.960 --> 00:18:15.626
What does a web
component look like that

00:18:15.626 --> 00:18:17.510
is sort of a utility element?

00:18:17.510 --> 00:18:20.020
It's responsible for
managing its children.

00:18:20.020 --> 00:18:25.590
So this Polymer flexbox layout
essentially wraps CSS flexbox.

00:18:25.590 --> 00:18:27.750
And it's got parameters
that you can configure.

00:18:27.750 --> 00:18:30.530
So it's got this vertical
one that my children are

00:18:30.530 --> 00:18:33.450
being rendered in a
flexbox column right now.

00:18:33.450 --> 00:18:34.580
Instead, I can switch this.

00:18:34.580 --> 00:18:36.450
So if declare this
element like this,

00:18:36.450 --> 00:18:38.697
without that vertical
attribute, that container

00:18:38.697 --> 00:18:40.155
knows what to do
with its children.

00:18:40.155 --> 00:18:43.180
It applies the CSS for flexbox.

00:18:43.180 --> 00:18:47.810
And you can see that now I have
flexbox in a row orientation.

00:18:47.810 --> 00:18:49.990
Inside of it, I
can also customize

00:18:49.990 --> 00:18:52.360
how my elements flex using
this special attribute

00:18:52.360 --> 00:18:54.280
that this element knows about.

00:18:54.280 --> 00:18:57.080
So all of this stuff is sort
of wrapped up and encapsulated.

00:18:57.080 --> 00:18:59.830
And this particular element
is aware of its surroundings,

00:18:59.830 --> 00:19:00.420
essentially.

00:19:00.420 --> 00:19:02.626
And it renders
stuff using flexbox.

00:19:02.626 --> 00:19:04.750
I don't know if you guys
have tried to use flexbox,

00:19:04.750 --> 00:19:07.881
but it's a little bit difficult
to understand sometimes.

00:19:07.881 --> 00:19:09.630
And I can add a bunch
of children to this.

00:19:09.630 --> 00:19:11.100
And each one of
these just knows what

00:19:11.100 --> 00:19:13.030
to do because it's part
of this container that

00:19:13.030 --> 00:19:14.680
understand CSS flexbox.

00:19:14.680 --> 00:19:16.209
You can reorient these.

00:19:16.209 --> 00:19:17.250
And so it all just works.

00:19:17.250 --> 00:19:19.190
And so this is really
cool because we're

00:19:19.190 --> 00:19:21.700
using an element to do layout.

00:19:21.700 --> 00:19:23.624
And structurally,
you can read this

00:19:23.624 --> 00:19:25.290
and understand exactly
what's happening.

00:19:27.920 --> 00:19:29.560
And we're actually
working and sort

00:19:29.560 --> 00:19:32.490
of experimenting with a
number of different non-visual

00:19:32.490 --> 00:19:33.010
elements.

00:19:33.010 --> 00:19:35.660
So these are a few examples
that we've been toying with.

00:19:35.660 --> 00:19:39.619
So you have things for layout,
like flexbox and CSS grid.

00:19:39.619 --> 00:19:41.160
We have a couple of
tags to do views.

00:19:41.160 --> 00:19:45.425
So polymer-page is sort of a
single page app type thing,

00:19:45.425 --> 00:19:48.730
that you can implement
a single page app.

00:19:48.730 --> 00:19:50.410
Elements for libraries.

00:19:50.410 --> 00:19:53.610
Things to bring in shared
state and Google JavaScript

00:19:53.610 --> 00:19:55.470
libraries.

00:19:55.470 --> 00:19:56.620
A couple of data elements.

00:19:56.620 --> 00:19:57.650
So this is really cool.

00:19:57.650 --> 00:19:59.770
This one, polymer-localstorage,
essentially

00:19:59.770 --> 00:20:02.590
just wraps the HTML5
local storage API.

00:20:02.590 --> 00:20:03.980
You give it some
data, and boom--

00:20:03.980 --> 00:20:07.120
it just handles storing
that data for you offline.

00:20:07.120 --> 00:20:09.969
You saw AJAX and JSONP.

00:20:09.969 --> 00:20:12.135
And there's also things for
behavior and interaction

00:20:12.135 --> 00:20:13.770
that we're experimenting with.

00:20:13.770 --> 00:20:17.450
So signaling-- sending
events to other components

00:20:17.450 --> 00:20:19.800
and sort of notifying those.

00:20:19.800 --> 00:20:21.960
A polymer-selector, being
able to do tri-state,

00:20:21.960 --> 00:20:23.830
sort of a selection-type widget.

00:20:23.830 --> 00:20:25.210
These are very common things.

00:20:25.210 --> 00:20:27.520
A lot of these that you
do in a standard web app.

00:20:27.520 --> 00:20:30.420
And we've essentially just
packaged these up as an element

00:20:30.420 --> 00:20:33.500
that you can just drop in
your page and start using.

00:20:33.500 --> 00:20:35.070
Conceptually, it's
a little bit weird

00:20:35.070 --> 00:20:37.260
that you're including
some markup on your page.

00:20:37.260 --> 00:20:40.786
Like polymer-localstorage--
it doesn't render anything.

00:20:40.786 --> 00:20:42.160
It's sort of this
utility element

00:20:42.160 --> 00:20:43.830
that just exists on the page.

00:20:43.830 --> 00:20:45.820
But once you see the
examples later on,

00:20:45.820 --> 00:20:49.720
I think it'll really
start to make sense.

00:20:49.720 --> 00:20:52.490
So as part of this green layer
as well-- this Polymer stack---

00:20:52.490 --> 00:20:55.830
we're also experimenting with
the UI that sort of sits on top

00:20:55.830 --> 00:20:58.250
of these core utility elements.

00:20:58.250 --> 00:20:59.900
And just a couple examples here.

00:20:59.900 --> 00:21:02.915
You have your standard tab
widget, your toggle strips,

00:21:02.915 --> 00:21:05.280
your toolbar elements.

00:21:05.280 --> 00:21:07.450
You have things like
polymer-ui-card,

00:21:07.450 --> 00:21:11.137
which essentially gives you
sort of swiping capabilities.

00:21:11.137 --> 00:21:12.595
So you just drop
this on your page,

00:21:12.595 --> 00:21:14.053
and you get touch
for free, you get

00:21:14.053 --> 00:21:16.080
swiping for free, which
is really, really nice.

00:21:16.080 --> 00:21:19.310
You don't have to worry about
any of that stuff anymore.

00:21:19.310 --> 00:21:22.340
Your sidebar-type menu
item, implementing

00:21:22.340 --> 00:21:24.897
some widgets that
sort of follow you,

00:21:24.897 --> 00:21:26.230
and this arrow that follows you.

00:21:26.230 --> 00:21:27.900
A lot of this stuff
is just really

00:21:27.900 --> 00:21:29.525
natural in the world
of Web Components.

00:21:33.035 --> 00:21:34.160
And this one's pretty cool.

00:21:34.160 --> 00:21:36.580
This one-- if you
polymer-ui-theme-aware,

00:21:36.580 --> 00:21:39.060
if you embed this
within a container,

00:21:39.060 --> 00:21:42.320
the whole page or the container
takes on the theme that you

00:21:42.320 --> 00:21:43.250
specify.

00:21:43.250 --> 00:21:45.450
So it's a really kind of
an interesting and cool way

00:21:45.450 --> 00:21:48.820
to do theming of an entire web
app just by placing in one tag.

00:21:51.660 --> 00:21:53.620
A lot of these-- I
will mention the UI,

00:21:53.620 --> 00:21:57.370
polymer-ui-- use those
underlying non-visual elements

00:21:57.370 --> 00:21:58.560
to get the job done.

00:21:58.560 --> 00:22:00.090
So they reuse the components.

00:22:00.090 --> 00:22:03.130
And that's actually one awesome
benefit of Web Components,

00:22:03.130 --> 00:22:04.330
is that they're reusable.

00:22:04.330 --> 00:22:06.630
You don't have to start
over each and every time

00:22:06.630 --> 00:22:07.770
you create an app.

00:22:07.770 --> 00:22:10.496
You can reuse the existing
functionality and sort of mix

00:22:10.496 --> 00:22:11.370
in new functionality.

00:22:16.370 --> 00:22:19.470
So that's a little bit
about thinking declaratively

00:22:19.470 --> 00:22:20.900
as elements first.

00:22:20.900 --> 00:22:24.300
Now let's talk about how you
actually build a web component.

00:22:24.300 --> 00:22:26.570
And that's where this yellow
layer, the Polymer core

00:22:26.570 --> 00:22:30.190
sugar APIs come in.

00:22:30.190 --> 00:22:31.680
The philosophy of
this section is

00:22:31.680 --> 00:22:33.177
we want to eliminate
boilerplate.

00:22:33.177 --> 00:22:34.760
There's a lot of
tedious code that you

00:22:34.760 --> 00:22:38.290
have to write in order to
work with these standards--

00:22:38.290 --> 00:22:40.640
the Shadow DOM, the
custom elements.

00:22:40.640 --> 00:22:42.490
And we want to make
that very, very easy.

00:22:42.490 --> 00:22:45.185
So we're taking a
declarative approach.

00:22:45.185 --> 00:22:46.810
The first couple ones
you'll see here--

00:22:46.810 --> 00:22:49.780
core features of Polymer--
they're all declarative.

00:22:49.780 --> 00:22:52.070
So instead of registering
elements in JavaScript,

00:22:52.070 --> 00:22:53.560
you're declaring
them using what we

00:22:53.560 --> 00:22:56.110
call the polymer-element syntax.

00:22:56.110 --> 00:22:57.740
You can extend the
elements very easily

00:22:57.740 --> 00:23:01.000
with this extends
property that we have.

00:23:01.000 --> 00:23:02.830
You could do things
like data binding.

00:23:02.830 --> 00:23:06.000
So if I want to data bind
this inputs value to the foo

00:23:06.000 --> 00:23:08.220
property, I can do that
with the double mustache.

00:23:08.220 --> 00:23:11.352
Very similar to any other
framework out there.

00:23:11.352 --> 00:23:12.810
Declarative events
are pretty cool.

00:23:12.810 --> 00:23:15.250
You don't have to do things
like attach an event listener.

00:23:15.250 --> 00:23:18.690
You can basically just use on
dash, whatever event you want.

00:23:18.690 --> 00:23:22.724
And then give it the handler
that you want to be called.

00:23:22.724 --> 00:23:23.640
Publishing properties.

00:23:23.640 --> 00:23:25.140
A lot of this stuff
I'll go through.

00:23:25.140 --> 00:23:27.929
Being able to detect
when a property changes.

00:23:27.929 --> 00:23:29.720
Somebody changes
something on your element,

00:23:29.720 --> 00:23:31.450
you want to be
notified for that.

00:23:31.450 --> 00:23:34.860
And you get a callback
for that if you define it.

00:23:34.860 --> 00:23:36.830
So the moral, the
takeaway here is

00:23:36.830 --> 00:23:38.640
that we want to be
declarative as possible,

00:23:38.640 --> 00:23:41.570
and we want to write less code.

00:23:41.570 --> 00:23:44.500
And what I mean by writing less
code is something like this.

00:23:44.500 --> 00:23:47.780
This is an example of
creating a custom element--

00:23:47.780 --> 00:23:50.270
my-input at the
bottom here-- that's

00:23:50.270 --> 00:23:52.520
the tag we're creating--
without using Polymer.

00:23:52.520 --> 00:23:54.001
This is what you have to do.

00:23:54.001 --> 00:23:56.000
So the first thing is
you'll have a template tag

00:23:56.000 --> 00:23:58.510
with some markup
that you'll declare.

00:23:58.510 --> 00:24:01.122
Maybe it's got some styles
in it to style this input.

00:24:01.122 --> 00:24:02.830
And then you write a
bunch of JavaScript.

00:24:02.830 --> 00:24:05.370
You write a prototype object.

00:24:05.370 --> 00:24:08.990
You create shadow root using
the ShadowRoot API for this.

00:24:08.990 --> 00:24:10.220
And it's kind of messy.

00:24:10.220 --> 00:24:11.590
This is very repetitive.

00:24:11.590 --> 00:24:13.215
If you're implementing
a web component,

00:24:13.215 --> 00:24:16.400
you would have to do
this each and every time.

00:24:16.400 --> 00:24:18.570
And then you call
document.register at the bottom

00:24:18.570 --> 00:24:20.011
here.

00:24:20.011 --> 00:24:21.510
So instead, what
we've done is we've

00:24:21.510 --> 00:24:23.770
decided to take a
declarative approach.

00:24:23.770 --> 00:24:26.750
We want to preach and
practice what we preach.

00:24:26.750 --> 00:24:29.410
And so instead of writing
a bunch of JavaScript,

00:24:29.410 --> 00:24:30.940
you declare a Polymer element.

00:24:30.940 --> 00:24:33.450
So you just declare this
using this special tag,

00:24:33.450 --> 00:24:36.400
which itself is implemented
using the primitives.

00:24:36.400 --> 00:24:38.770
It's implemented using
document.register, which

00:24:38.770 --> 00:24:42.430
I think is really cool and
sort of an "Inception" moment.

00:24:42.430 --> 00:24:45.810
But you Polymer element, the
tag that you want to declare,

00:24:45.810 --> 00:24:46.880
MyInput.

00:24:46.880 --> 00:24:48.780
You can pass in a
constructor, so people

00:24:48.780 --> 00:24:51.210
can use the new
operator in JavaScript

00:24:51.210 --> 00:24:52.487
to create [INAUDIBLE].

00:24:52.487 --> 00:24:54.570
And the important piece
of this particular example

00:24:54.570 --> 00:24:56.640
is this noscript attribute here.

00:24:56.640 --> 00:24:59.166
And that basically just means--
this element is dead simple.

00:24:59.166 --> 00:25:01.040
It's just a bunch of
markup with some styles.

00:25:01.040 --> 00:25:02.940
It doesn't have an
API in JavaScript.

00:25:02.940 --> 00:25:05.970
It doesn't have any
properties that are set.

00:25:05.970 --> 00:25:07.830
And then we just
include that template

00:25:07.830 --> 00:25:10.465
that we had before in
the previous example.

00:25:10.465 --> 00:25:12.840
And that's how you define a
custom element using Polymer.

00:25:12.840 --> 00:25:14.300
It's all declarative.

00:25:14.300 --> 00:25:17.000
People can then declare
MyInput on their page.

00:25:17.000 --> 00:25:19.975
They can create it in
JavaScript using createElement.

00:25:19.975 --> 00:25:21.980
Or they can use new.

00:25:21.980 --> 00:25:24.900
The point is, it's the
same web platform and APIs

00:25:24.900 --> 00:25:26.220
that exist before.

00:25:26.220 --> 00:25:30.072
You're just allowing developers
to create new elements.

00:25:30.072 --> 00:25:33.070
If you want to, we can
use default attributes.

00:25:33.070 --> 00:25:35.950
So this is pretty cool if you
have something like Bootstrap,

00:25:35.950 --> 00:25:38.140
and you want to include
maybe a common CSS

00:25:38.140 --> 00:25:40.870
class on every element
that's created.

00:25:40.870 --> 00:25:44.010
In this case, including
other attributes

00:25:44.010 --> 00:25:45.870
in your Polymer
element definition

00:25:45.870 --> 00:25:49.070
will include those on the
element when it's created.

00:25:49.070 --> 00:25:52.120
So somebody declares
MyInput on their page.

00:25:52.120 --> 00:25:54.610
And every instance
that's created in the DOM

00:25:54.610 --> 00:25:57.250
will actually include that
class active in that custom

00:25:57.250 --> 00:25:57.750
attribute.

00:26:02.610 --> 00:26:04.785
But as you saw, we have
more complex elements.

00:26:04.785 --> 00:26:07.160
So what about the photo booth
application or the "Gangnam

00:26:07.160 --> 00:26:08.757
Style" application?

00:26:08.757 --> 00:26:11.340
At some point, you're probably
going to need to define an API.

00:26:11.340 --> 00:26:13.798
You're going to need to give
your elements some properties,

00:26:13.798 --> 00:26:15.080
some functions.

00:26:15.080 --> 00:26:17.430
So what we can do with
this is actually take off

00:26:17.430 --> 00:26:21.790
the noscript at the top, and we
can inline some script inside

00:26:21.790 --> 00:26:23.470
of our Polymer
element definition.

00:26:23.470 --> 00:26:25.460
So now we're
working with markup,

00:26:25.460 --> 00:26:27.360
we're working with
styles, and we're

00:26:27.360 --> 00:26:30.890
working with script inside of
this self-contained component.

00:26:30.890 --> 00:26:32.717
So we'll call the
Polymer constructor

00:26:32.717 --> 00:26:34.800
and pass in the name of
the tag we want to create.

00:26:37.850 --> 00:26:40.250
The second thing we can do
is we can beef this thing up.

00:26:40.250 --> 00:26:42.340
So we want to give it
a couple properties.

00:26:42.340 --> 00:26:45.700
We can give it a type property
and default it to text.

00:26:45.700 --> 00:26:47.840
We can give this
element a color property

00:26:47.840 --> 00:26:49.400
and default it to orange.

00:26:49.400 --> 00:26:52.710
And we can also define methods,
such as the created callback,

00:26:52.710 --> 00:26:55.880
to be notified of when
things happen on our element.

00:26:55.880 --> 00:26:57.300
So essentially
what we're doing is

00:26:57.300 --> 00:26:59.190
defining an API
for this element.

00:27:02.996 --> 00:27:05.370
I will also mention that we
can clean this up quite a bit

00:27:05.370 --> 00:27:06.050
if you want to.

00:27:06.050 --> 00:27:08.430
Your standard web
development best practices

00:27:08.430 --> 00:27:11.750
still exist in the
world of Web Components.

00:27:11.750 --> 00:27:14.030
Instead of having inline
style tags, if you want,

00:27:14.030 --> 00:27:15.900
you can reference a style sheet.

00:27:15.900 --> 00:27:20.020
Instead of referencing
inline script tags,

00:27:20.020 --> 00:27:22.860
you can reference an
external JavaScript file.

00:27:22.860 --> 00:27:24.410
So if you're a fan
of CoffeeScript,

00:27:24.410 --> 00:27:27.060
if you're a fan of
Less or Compass,

00:27:27.060 --> 00:27:30.550
you can totally use those
pre-compiled languages

00:27:30.550 --> 00:27:36.250
and then embed those inside
of your component to use.

00:27:36.250 --> 00:27:39.310
It's also, for those who are
familiar with Content Security

00:27:39.310 --> 00:27:40.870
Policy, CSP.

00:27:40.870 --> 00:27:43.930
This a great way to get around
the issues that CSP has.

00:27:47.270 --> 00:27:49.070
Where this really
gets sort of magical

00:27:49.070 --> 00:27:51.670
is through published
properties in data binding.

00:27:51.670 --> 00:27:53.700
And this is one of
Polymer's core features,

00:27:53.700 --> 00:27:56.770
and what we think is
very, very powerful.

00:27:56.770 --> 00:27:59.360
So this is the exact element
that I had in the last slide.

00:27:59.360 --> 00:28:01.180
It's got that input tag.

00:28:01.180 --> 00:28:03.230
And we're making
a special input.

00:28:03.230 --> 00:28:06.510
The only difference here now is
that I have this inline style

00:28:06.510 --> 00:28:08.100
tag for the color.

00:28:08.100 --> 00:28:09.960
So I've just moved
that from a style tag,

00:28:09.960 --> 00:28:11.510
just directly on
the element there.

00:28:11.510 --> 00:28:13.760
But you can see there's a
little bit of an issue here.

00:28:13.760 --> 00:28:15.980
I've got this type
property on my element,

00:28:15.980 --> 00:28:18.170
and I've also got this color
property on my element.

00:28:18.170 --> 00:28:21.280
But they're being duplicated in
the markup up at the top here.

00:28:21.280 --> 00:28:23.060
That's kind of
ridiculous, so why

00:28:23.060 --> 00:28:24.690
don't we switch
those to mustaches?

00:28:24.690 --> 00:28:28.560
So instead, now we can use data
binding to tie this element's

00:28:28.560 --> 00:28:30.700
type property and
its color property

00:28:30.700 --> 00:28:33.110
to the values of that input.

00:28:33.110 --> 00:28:36.560
So those two are now linked
via mustaches and data binding.

00:28:36.560 --> 00:28:38.350
Very, very cool.

00:28:38.350 --> 00:28:42.610
Something else we can do is we
can publish these properties.

00:28:42.610 --> 00:28:45.040
So using this
attributes attribute

00:28:45.040 --> 00:28:46.920
on our Polymer
element definition,

00:28:46.920 --> 00:28:48.630
I can say I want
to publish the type

00:28:48.630 --> 00:28:51.480
property of my element,
and my color property,

00:28:51.480 --> 00:28:54.220
and allow users of my
element to actually pass

00:28:54.220 --> 00:28:56.110
in those as attributes.

00:28:56.110 --> 00:28:59.890
So you can see, as a
user of my element,

00:28:59.890 --> 00:29:01.690
they can override
my default orange

00:29:01.690 --> 00:29:03.849
color with the red value
using an attribute.

00:29:03.849 --> 00:29:05.640
So that's what the
published properties do.

00:29:05.640 --> 00:29:07.600
It essentially takes
your JavaScript world,

00:29:07.600 --> 00:29:12.270
and says-- OK, allow people
to customize me via HTML.

00:29:12.270 --> 00:29:16.891
And that's where the declarative
nature comes into this as well.

00:29:16.891 --> 00:29:18.140
And we can go crazy with this.

00:29:18.140 --> 00:29:21.520
We can add a bunch of data
binding inside of our element,

00:29:21.520 --> 00:29:25.560
and link things together just by
using synchronous data binding.

00:29:25.560 --> 00:29:30.320
So for example, I can add
value property on MyInput

00:29:30.320 --> 00:29:31.950
and then link that
to a text area.

00:29:31.950 --> 00:29:34.410
So every time somebody types
in the input, my text area

00:29:34.410 --> 00:29:37.860
is just updated automagically
via that data binding.

00:29:37.860 --> 00:29:39.830
So things become
very, very powerful.

00:29:39.830 --> 00:29:42.020
And you ultimately have
to write less code.

00:29:42.020 --> 00:29:43.940
You're not attaching
event listeners

00:29:43.940 --> 00:29:44.957
or watching for changes.

00:29:44.957 --> 00:29:46.540
It all just works
via the data binding

00:29:46.540 --> 00:29:47.540
in published properties.

00:29:50.050 --> 00:29:51.050
So a real world example.

00:29:51.050 --> 00:29:54.240
This, using some of the
sugaring APIs in the real world,

00:29:54.240 --> 00:29:57.530
is to use the
polymer AJAX element

00:29:57.530 --> 00:29:59.480
inside of another element.

00:29:59.480 --> 00:30:01.240
So maybe you're creating
this new element.

00:30:01.240 --> 00:30:03.414
It's called youtube-videos.

00:30:03.414 --> 00:30:05.830
And then people can declare
it on their page at the bottom

00:30:05.830 --> 00:30:08.830
here and query for cat
videos or Chrome videos,

00:30:08.830 --> 00:30:10.000
or whatever they want.

00:30:10.000 --> 00:30:12.800
And they can customize it
just by this query parameter.

00:30:12.800 --> 00:30:16.570
So we publish that query
string, that query property.

00:30:16.570 --> 00:30:19.290
Inside of polymer-ajax, it's
the same thing as we had before.

00:30:19.290 --> 00:30:21.839
But we're not writing
any JavaScript anymore.

00:30:21.839 --> 00:30:23.255
From the outside
[? row, ?] we had

00:30:23.255 --> 00:30:25.910
to write JavaScript to
listen for a response,

00:30:25.910 --> 00:30:28.140
and process that using JSON.

00:30:28.140 --> 00:30:30.490
Instead, we can just set
up data binding on some

00:30:30.490 --> 00:30:32.510
of the properties that it has.

00:30:32.510 --> 00:30:34.425
So for instance, it had
that params property

00:30:34.425 --> 00:30:36.506
if you remember from before.

00:30:36.506 --> 00:30:38.130
Instead of passing
a serialized object,

00:30:38.130 --> 00:30:42.710
we can pass in a
data-bound variable params.

00:30:42.710 --> 00:30:45.252
And so I can set that to an
actual object in my element

00:30:45.252 --> 00:30:46.480
when it's created.

00:30:46.480 --> 00:30:50.110
So we have binding via
object, which is really cool.

00:30:50.110 --> 00:30:54.370
Instead of using the alt=json,
it's got this awesome handle

00:30:54.370 --> 00:30:56.850
as parameter-- if you read
the API documentation,

00:30:56.850 --> 00:31:00.320
that we can configure
it to do JSON requests.

00:31:00.320 --> 00:31:02.370
And instead of
hooking up JavaScript

00:31:02.370 --> 00:31:04.620
to process the
Polymer response, we

00:31:04.620 --> 00:31:07.920
can data bind to this
attribute, and use a property.

00:31:07.920 --> 00:31:11.210
And essentially when this file--
or when this request-- is made,

00:31:11.210 --> 00:31:12.800
the response is
going to be filled.

00:31:12.800 --> 00:31:15.700
And we can do things like
render out template data

00:31:15.700 --> 00:31:17.490
inside of our element.

00:31:17.490 --> 00:31:18.570
So synchronous.

00:31:18.570 --> 00:31:19.970
Basically, you
can set up binding

00:31:19.970 --> 00:31:22.940
for anything that cares
about a certain property.

00:31:22.940 --> 00:31:23.690
And it just works.

00:31:23.690 --> 00:31:25.830
It just sort of updates itself.

00:31:25.830 --> 00:31:27.860
You can use the template
element to repeat over

00:31:27.860 --> 00:31:30.000
the list of entries
and print out

00:31:30.000 --> 00:31:31.635
an LI title for
each one of those.

00:31:31.635 --> 00:31:34.100
And so that's really, really
a core fundamental thing

00:31:34.100 --> 00:31:35.630
of Polymer, is
using data binding.

00:31:41.990 --> 00:31:44.000
Another real world
example is reusing

00:31:44.000 --> 00:31:47.120
the polymer-file element
inside of another element.

00:31:47.120 --> 00:31:50.074
So we can create
this read-me element.

00:31:50.074 --> 00:31:51.990
And this one's pretty
cool because it actually

00:31:51.990 --> 00:31:53.490
uses data binding as well.

00:31:53.490 --> 00:31:54.600
So no JavaScript here.

00:31:54.600 --> 00:31:58.780
Instead, we're binding to
that result property it sets.

00:31:58.780 --> 00:31:59.990
This is a Polymer feature.

00:31:59.990 --> 00:32:01.970
It's called a changed watcher.

00:32:01.970 --> 00:32:04.270
So when my result
property changes,

00:32:04.270 --> 00:32:06.644
my resultChanged
method will be called.

00:32:06.644 --> 00:32:07.560
So that's really nice.

00:32:07.560 --> 00:32:10.760
You can observe
properties really easily.

00:32:10.760 --> 00:32:12.270
And something else
this element does

00:32:12.270 --> 00:32:15.450
is set up a default
declarative click handler.

00:32:15.450 --> 00:32:18.410
So instead of doing things like
attaching an event listener,

00:32:18.410 --> 00:32:22.130
I just declare on-click,
and give it a string.

00:32:22.130 --> 00:32:25.640
And the string maps to a method
on my prototype, on my element.

00:32:25.640 --> 00:32:27.760
And so when somebody
clicks this element,

00:32:27.760 --> 00:32:29.870
it's basically going
to start the file read.

00:32:29.870 --> 00:32:31.780
And it's going to call
that element's API.

00:32:31.780 --> 00:32:34.644
It's going to call
its read method.

00:32:34.644 --> 00:32:37.310
One other cool little feature is
sort of this jQuery-like syntax

00:32:37.310 --> 00:32:37.851
that we have.

00:32:37.851 --> 00:32:41.100
It's called automatic node
finding, at the top here.

00:32:41.100 --> 00:32:44.780
And it essentially allows
you to do $., and then

00:32:44.780 --> 00:32:47.149
the ID of an element
inside of your element

00:32:47.149 --> 00:32:48.190
to sort of get at things.

00:32:48.190 --> 00:32:50.510
So it's very easy to pull
things out of the DOM.

00:32:55.354 --> 00:32:57.020
You saw an example
of some of the things

00:32:57.020 --> 00:32:58.440
we've added to the template tag.

00:32:58.440 --> 00:33:00.430
So template, again,
is a new primitive

00:33:00.430 --> 00:33:03.020
that's part of
the Web Components

00:33:03.020 --> 00:33:04.742
collection of specifications.

00:33:04.742 --> 00:33:06.450
But what we've done
in Polymer is sort of

00:33:06.450 --> 00:33:07.540
beefed it up a little bit.

00:33:07.540 --> 00:33:09.850
So you can do things like
conditional templates.

00:33:09.850 --> 00:33:12.050
Just activate this
section of markup,

00:33:12.050 --> 00:33:13.430
if this property is true.

00:33:13.430 --> 00:33:15.820
And this is using
data binding again.

00:33:15.820 --> 00:33:17.830
Or you can do things
like expressions.

00:33:17.830 --> 00:33:20.460
If isActive is true,
or alwaysShow is true,

00:33:20.460 --> 00:33:23.230
show this particular
section of markup.

00:33:23.230 --> 00:33:25.710
In the previous example,
you also saw iteration.

00:33:25.710 --> 00:33:27.390
And you could have
multiple levels

00:33:27.390 --> 00:33:30.200
of iteration iterating
over a property as well.

00:33:30.200 --> 00:33:33.470
So for users and user, stamp
out this particular markup.

00:33:33.470 --> 00:33:36.300
And then within that, you
can have named scopes.

00:33:36.300 --> 00:33:40.190
So this user has a files object
that you can then iterate over.

00:33:40.190 --> 00:33:42.490
So really powerful stuff,
creating markup dynamically

00:33:42.490 --> 00:33:45.871
based on a data model,
rather than just declaring it

00:33:45.871 --> 00:33:46.370
statically.

00:33:49.369 --> 00:33:51.160
Another feature we have
is anywhere you use

00:33:51.160 --> 00:33:53.210
mustaches-- these double
mustaches for data

00:33:53.210 --> 00:33:55.620
binding-- you can
set up expressions.

00:33:55.620 --> 00:33:58.190
So you can do things
like addition.

00:33:58.190 --> 00:34:03.530
Jill has her daughter's
children plus her son's children

00:34:03.530 --> 00:34:05.725
equals her grandchildren.

00:34:05.725 --> 00:34:07.100
Something else
that's pretty cool

00:34:07.100 --> 00:34:09.139
is you can dynamically
apply classes

00:34:09.139 --> 00:34:12.060
to elements internal
to your component.

00:34:12.060 --> 00:34:14.780
So for example, if
user selected is true,

00:34:14.780 --> 00:34:18.510
and user type is super, it's
going to apply the active class

00:34:18.510 --> 00:34:20.098
and the big class
on my div there.

00:34:20.098 --> 00:34:21.639
That's pretty handy
if you want to do

00:34:21.639 --> 00:34:24.590
just sort of dynamic styling.

00:34:24.590 --> 00:34:27.179
And the last version of this
is conditional attributes.

00:34:27.179 --> 00:34:29.969
And this is really nice for
things like Boolean attributes.

00:34:29.969 --> 00:34:33.320
If you have a checked
attribute with the checked,

00:34:33.320 --> 00:34:35.550
and then the question
mark at the end,

00:34:35.550 --> 00:34:37.350
it basically says
add this attribute

00:34:37.350 --> 00:34:38.870
if this property is true.

00:34:38.870 --> 00:34:41.230
So again, really, really
utilizing the data

00:34:41.230 --> 00:34:42.647
binding capabilities.

00:34:42.647 --> 00:34:44.480
And if it's not true,
that checked property,

00:34:44.480 --> 00:34:46.896
or that checked attribute,
won't be applied in the markup.

00:34:50.230 --> 00:34:52.230
I want to take you on a
quick tour on everything

00:34:52.230 --> 00:34:54.604
is an element, and show you
some of this stuff in action.

00:34:56.780 --> 00:34:59.980
Actually, I think have it
ready to go right here.

00:34:59.980 --> 00:35:01.850
This a tool we
showed off at I/O.

00:35:01.850 --> 00:35:04.560
And it's basically
a playground for you

00:35:04.560 --> 00:35:06.970
to come in and
play with elements.

00:35:06.970 --> 00:35:09.220
And these are some
basic, bare bones

00:35:09.220 --> 00:35:10.470
elements that we've created.

00:35:10.470 --> 00:35:13.620
But it's essentially-- I can
show you some of these really

00:35:13.620 --> 00:35:14.120
quickly.

00:35:14.120 --> 00:35:16.495
We have our Tabs widget, and
it just works as you expect.

00:35:16.495 --> 00:35:19.630
We have a Star Rating
widget that works.

00:35:19.630 --> 00:35:20.700
There's a Toggle Button.

00:35:20.700 --> 00:35:22.783
And these are some of the
things that I've showed.

00:35:22.783 --> 00:35:24.890
And if we actually dive
into the code here,

00:35:24.890 --> 00:35:27.300
you can see that everything
is a custom element.

00:35:27.300 --> 00:35:29.810
We have the g-tabs
element, g-ratings element,

00:35:29.810 --> 00:35:33.180
g-togglebutton element.

00:35:33.180 --> 00:35:35.850
So what we can do is we combine
these all together using

00:35:35.850 --> 00:35:38.620
Polymer.

00:35:38.620 --> 00:35:41.050
So I'll use the
double mustaches,

00:35:41.050 --> 00:35:44.200
and I'll bind to this
selected property--

00:35:44.200 --> 00:35:46.030
this attribute
that it publishes.

00:35:46.030 --> 00:35:48.340
I can bind this value
of the Ratings widget

00:35:48.340 --> 00:35:50.200
to the same property.

00:35:50.200 --> 00:35:52.122
And some place in
here-- well, if I

00:35:52.122 --> 00:35:54.830
add another one,
what should I add?

00:35:54.830 --> 00:35:58.410
Let's add the Menu because
the Menu has different states.

00:35:58.410 --> 00:36:00.420
So basically, this
code just updated.

00:36:00.420 --> 00:36:02.460
It's got the declarative
version of that g-menu.

00:36:02.460 --> 00:36:05.280
And it's got also a
selected attribute

00:36:05.280 --> 00:36:06.842
that is defaulted to zero.

00:36:06.842 --> 00:36:08.300
Instead, I'll just
switch that over

00:36:08.300 --> 00:36:09.940
to using data binding as well.

00:36:09.940 --> 00:36:11.870
So now I've linked all
three of these selected

00:36:11.870 --> 00:36:14.800
states to the same property.

00:36:14.800 --> 00:36:17.030
And hopefully, if I
select one of these,

00:36:17.030 --> 00:36:18.660
you can see that
they all update.

00:36:18.660 --> 00:36:20.949
So as I select one
in one element,

00:36:20.949 --> 00:36:22.240
the Ratings widget is changing.

00:36:22.240 --> 00:36:25.182
And there's an off by
one error, but whatever.

00:36:25.182 --> 00:36:26.390
And the Menu's also changing.

00:36:26.390 --> 00:36:29.230
And if I do the same-- if
I click this one-- again,

00:36:29.230 --> 00:36:32.847
everything's just kept in sync
via data binding in Polymer.

00:36:32.847 --> 00:36:34.680
What's really neat about
this particular app

00:36:34.680 --> 00:36:38.560
is that you can actually
embed it inside of itself.

00:36:38.560 --> 00:36:41.369
So you can do sort of
an inception-type thing.

00:36:41.369 --> 00:36:43.160
And that's really thanks
to Web Components.

00:36:43.160 --> 00:36:45.020
Everything is compartmentalized.

00:36:45.020 --> 00:36:47.610
Everything is self-contained
and encapsulated.

00:36:47.610 --> 00:36:49.260
So you can have the
app within the app,

00:36:49.260 --> 00:36:51.220
within the app within the app.

00:36:51.220 --> 00:36:54.416
It's really crazy, but it all
works thanks to Shadow DOM.

00:36:58.520 --> 00:37:00.790
So we talked a little
bit about the elements.

00:37:00.790 --> 00:37:01.970
So everything is an element.

00:37:01.970 --> 00:37:03.011
What does that look like?

00:37:03.011 --> 00:37:03.940
The green layer.

00:37:03.940 --> 00:37:07.090
The core layer, which is the
yellow stuff-- data binding,

00:37:07.090 --> 00:37:08.495
changed watchers.

00:37:08.495 --> 00:37:10.870
And I really, really just want
to iterate on the platform

00:37:10.870 --> 00:37:11.930
level.

00:37:11.930 --> 00:37:13.690
The stuff that
Polymer is built on

00:37:13.690 --> 00:37:15.586
is ultimately the web platform.

00:37:15.586 --> 00:37:17.460
We're not implementing
a bunch of JavaScript.

00:37:17.460 --> 00:37:19.245
We're actually
using the APIs that

00:37:19.245 --> 00:37:22.580
are being added to the browser.

00:37:22.580 --> 00:37:24.020
So a couple things on this.

00:37:24.020 --> 00:37:26.520
The first is that if you're
familiar with custom elements--

00:37:26.520 --> 00:37:29.590
custom elements have the
notion of life cycle callbacks.

00:37:29.590 --> 00:37:32.254
These are methods that you can
implement on an element that

00:37:32.254 --> 00:37:34.170
basically gives you
notifications of when it's

00:37:34.170 --> 00:37:37.950
created, when it's inserted
into the page, when it leaves

00:37:37.950 --> 00:37:41.020
the DOM, and also when
the attribute changes.

00:37:41.020 --> 00:37:44.007
So you get to know what
happens on your element.

00:37:44.007 --> 00:37:46.090
And Polymer has first class
support for this stuff

00:37:46.090 --> 00:37:48.100
because again, at its
fundamental level,

00:37:48.100 --> 00:37:49.995
everything is built
from that web platform.

00:37:54.440 --> 00:37:56.960
I will mention one quick
example of using something

00:37:56.960 --> 00:38:00.140
like this is maybe you have
a really complex element that

00:38:00.140 --> 00:38:01.970
opens an index DB database.

00:38:01.970 --> 00:38:04.390
Or you're doing
something very complex.

00:38:04.390 --> 00:38:06.580
And then when the
element actually

00:38:06.580 --> 00:38:09.037
is removed from the DOM,
you want to do cleanup.

00:38:09.037 --> 00:38:11.370
You want to clean up the
database, you want to close it.

00:38:11.370 --> 00:38:13.620
And that's what these methods
are really designed for,

00:38:13.620 --> 00:38:17.920
is to be able to do
complex things like that.

00:38:17.920 --> 00:38:19.690
Insertion points
are a complex topic.

00:38:19.690 --> 00:38:22.390
It's part of Shadow
DOM, but Polymer also

00:38:22.390 --> 00:38:24.450
has first class
support for this.

00:38:24.450 --> 00:38:27.755
So insertion points are
really cool because you

00:38:27.755 --> 00:38:30.202
can have a user use your
Tabs widget, for example.

00:38:30.202 --> 00:38:32.410
And they include a bunch of
markup inside of the Tabs

00:38:32.410 --> 00:38:32.910
widget.

00:38:32.910 --> 00:38:36.440
Maybe title tags that
are H2s, and section tags

00:38:36.440 --> 00:38:37.910
for the content itself.

00:38:37.910 --> 00:38:40.420
And inside of your Shadow
DOM, the polymer-element--

00:38:40.420 --> 00:38:43.570
the web component--
you use content tags.

00:38:43.570 --> 00:38:44.880
These are insertion points.

00:38:44.880 --> 00:38:47.440
And you can select out
very specific markup

00:38:47.440 --> 00:38:49.950
from the user's
markup and render that

00:38:49.950 --> 00:38:52.590
into particular locations
inside of your element.

00:38:52.590 --> 00:38:54.892
And so it's really cool
because you can say,

00:38:54.892 --> 00:38:56.725
I just care about these
particular elements,

00:38:56.725 --> 00:39:00.850
and I'm presenting you to
look like a Tabs widget.

00:39:00.850 --> 00:39:02.460
So I actually have
an example of this.

00:39:02.460 --> 00:39:05.680
It's a little experiment
I did using AngularJS,

00:39:05.680 --> 00:39:07.250
which is an awesome framework.

00:39:07.250 --> 00:39:10.810
And at the top here, you
have a web component version.

00:39:10.810 --> 00:39:13.550
And you have an Angular
directive-- their version

00:39:13.550 --> 00:39:15.940
of custom elements
at the bottom here.

00:39:15.940 --> 00:39:17.890
You can see the markup
is strikingly similar,

00:39:17.890 --> 00:39:20.400
and I've designed
it to look that way.

00:39:20.400 --> 00:39:21.960
But the code is very different.

00:39:21.960 --> 00:39:24.120
So the code for the
Polymer element,

00:39:24.120 --> 00:39:26.575
it's all declarative
and whatnot.

00:39:26.575 --> 00:39:30.400
And Angular, they have their
own API to create directives.

00:39:30.400 --> 00:39:32.300
But the really needs
anything about this

00:39:32.300 --> 00:39:34.930
is that you can-- because
everything is an element

00:39:34.930 --> 00:39:38.750
and everything is DOM-- I've
set up data binding using

00:39:38.750 --> 00:39:40.160
Angular's data binding.

00:39:40.160 --> 00:39:42.280
So this is an
Angular application.

00:39:42.280 --> 00:39:44.270
I have my web component here.

00:39:44.270 --> 00:39:46.930
And I'm binding the heading
property to this attribute

00:39:46.930 --> 00:39:47.854
here.

00:39:47.854 --> 00:39:49.520
And you can see the
Angular version also

00:39:49.520 --> 00:39:50.840
has this same attribute.

00:39:50.840 --> 00:39:53.610
So now these two are
linked via data binding.

00:39:53.610 --> 00:39:55.330
And so this is
outside of Polymer.

00:39:55.330 --> 00:39:57.230
It's two frameworks sort
of working together.

00:39:57.230 --> 00:40:00.017
And you can see
when I update this,

00:40:00.017 --> 00:40:01.350
both those headings are updated.

00:40:01.350 --> 00:40:03.016
And that's really the
core concept here,

00:40:03.016 --> 00:40:04.160
is that everything is DOM.

00:40:04.160 --> 00:40:05.701
And because everything
is an element,

00:40:05.701 --> 00:40:08.922
it just feels like native HTML.

00:40:08.922 --> 00:40:09.755
Nothing has changed.

00:40:12.407 --> 00:40:14.615
Shadow DOM also has the
ability to do scoped styling.

00:40:14.615 --> 00:40:17.010
Really, really awesome
feature of Shadow DOM.

00:40:17.010 --> 00:40:19.020
So styles don't creep
into your element,

00:40:19.020 --> 00:40:20.020
styles don't bleed out.

00:40:20.020 --> 00:40:23.140
Anything you define in it
will just sort of be there.

00:40:23.140 --> 00:40:24.750
The two properties
that Shadow DOM

00:40:24.750 --> 00:40:26.510
has for this,
apply-author-styles and

00:40:26.510 --> 00:40:29.360
reset-style-inheritance, are
also first class citizens.

00:40:29.360 --> 00:40:32.570
You just define them on your
Polymer element definition.

00:40:32.570 --> 00:40:34.650
And then that's how
you control the look

00:40:34.650 --> 00:40:35.795
and feel of your component.

00:40:39.795 --> 00:40:41.920
The last piece that we have
first class support for

00:40:41.920 --> 00:40:43.460
is HTML imports.

00:40:43.460 --> 00:40:45.560
And they're really,
really simple to use.

00:40:45.560 --> 00:40:47.380
You just declare a
link rel="import"

00:40:47.380 --> 00:40:49.750
and reference an HTML file.

00:40:49.750 --> 00:40:51.900
But this becomes
really powerful when,

00:40:51.900 --> 00:40:53.720
say, I create a new
component, and I

00:40:53.720 --> 00:40:55.375
want to reuse someone
else's toolbar.

00:40:55.375 --> 00:40:57.870
I really am a fan of
somebody else's toolbar.

00:40:57.870 --> 00:41:00.440
I really like their
menu item tag.

00:41:00.440 --> 00:41:04.170
I can use two imports to bring
those into my application.

00:41:04.170 --> 00:41:05.700
And then define a new element.

00:41:05.700 --> 00:41:09.730
Define an awesome menu element,
and reuse those toolbar

00:41:09.730 --> 00:41:12.770
menu items inside
of my own element.

00:41:12.770 --> 00:41:15.690
And then package this
up using an import,

00:41:15.690 --> 00:41:17.750
put it up on a URL someplace.

00:41:17.750 --> 00:41:20.600
And people can then
bring this whole package

00:41:20.600 --> 00:41:21.860
into their application.

00:41:21.860 --> 00:41:23.790
So they can then use
my awesome menu tag

00:41:23.790 --> 00:41:26.764
just by referencing my resource.

00:41:26.764 --> 00:41:28.430
This is really, really
cool, because you

00:41:28.430 --> 00:41:29.860
can imagine a
world-- or something

00:41:29.860 --> 00:41:33.300
like Twitter Bootstrap--
exist as a web component.

00:41:33.300 --> 00:41:36.050
And so you get all the
CSS, all the JavaScript,

00:41:36.050 --> 00:41:40.930
and all of the HTML as
one relocatable resource.

00:41:40.930 --> 00:41:43.830
That's something new that
the web hasn't had before.

00:41:43.830 --> 00:41:45.040
So Polymer is many things.

00:41:45.040 --> 00:41:46.830
This is, again, our
architecture stack

00:41:46.830 --> 00:41:50.560
based on the foundation that
the course of specifications--

00:41:50.560 --> 00:41:53.699
the sugaring layer, the
elements that we're building.

00:41:53.699 --> 00:41:55.490
The little guy on the
top is the blue part.

00:41:55.490 --> 00:41:56.864
That's the apps
that you're going

00:41:56.864 --> 00:41:59.590
to build on top Web Components
using the entire stack,

00:41:59.590 --> 00:42:03.410
or just pieces of the stack--
whatever you want to do.

00:42:03.410 --> 00:42:05.870
I encourage you guys to
absolutely go and check out

00:42:05.870 --> 00:42:08.580
our website,
polymer-project.org.

00:42:08.580 --> 00:42:13.270
It's actually a shining example
of using Web Components.

00:42:13.270 --> 00:42:16.290
We're sort of dogfooding Web
Components all over the place.

00:42:16.290 --> 00:42:18.920
Our build page, in particular,
has these little widgets on it.

00:42:18.920 --> 00:42:21.420
These are just Polymer
elements, Web Components.

00:42:21.420 --> 00:42:24.270
So you can see that this
uses the polymer-ajax element

00:42:24.270 --> 00:42:28.471
to query a resource and get the
data back, if tests are passing

00:42:28.471 --> 00:42:28.970
or not.

00:42:28.970 --> 00:42:30.678
Looks like we're doing
pretty well today.

00:42:33.914 --> 00:42:35.330
And it's also got
more information

00:42:35.330 --> 00:42:38.010
on the elements and
the core technologies.

00:42:38.010 --> 00:42:40.010
If you want to learn more
about that red layer--

00:42:40.010 --> 00:42:42.180
the platform layer
that's being added

00:42:42.180 --> 00:42:44.390
to all the modern
browsers-- I encourage

00:42:44.390 --> 00:42:46.570
you to check out my
presentation at Google

00:42:46.570 --> 00:42:49.195
I/O, webcomponentsshift.com.

00:42:49.195 --> 00:42:52.350
Again, the HTML5
Rocks articles are

00:42:52.350 --> 00:42:54.360
absolutely amazing and
very, very detailed.

00:42:54.360 --> 00:42:57.127
So if you really want to get
down and dirty with this stuff,

00:42:57.127 --> 00:42:58.335
go check out these resources.

00:43:01.540 --> 00:43:03.706
Lastly, I'll leave you of
why you should be excited,

00:43:03.706 --> 00:43:05.370
and why I'm excited
for this stuff.

00:43:05.370 --> 00:43:07.840
As a web developer,
my productivity

00:43:07.840 --> 00:43:10.003
has actually skyrocketed
building stuff

00:43:10.003 --> 00:43:11.140
off Web Components.

00:43:11.140 --> 00:43:14.970
Again, I can create a component
and reuse that everywhere.

00:43:14.970 --> 00:43:17.580
It's DOM, it's
JavaScript, and it's CSS.

00:43:17.580 --> 00:43:20.364
You saw the tab example
before with the jQuery version

00:43:20.364 --> 00:43:22.280
and the Ember version
and the Angular version.

00:43:22.280 --> 00:43:23.580
They're all different.

00:43:23.580 --> 00:43:25.860
What if they all built
their tab components off

00:43:25.860 --> 00:43:27.870
of Web Components,
and the APIs were

00:43:27.870 --> 00:43:31.070
very easy and intuitive to use?

00:43:31.070 --> 00:43:32.770
You can say what you mean again.

00:43:32.770 --> 00:43:35.099
Somebody else can
read my markup, that's

00:43:35.099 --> 00:43:36.890
just a bunch of custom
elements, and really

00:43:36.890 --> 00:43:38.931
understand what's going
on in the web application

00:43:38.931 --> 00:43:40.320
that I'm creating.

00:43:40.320 --> 00:43:42.280
Re-usability.

00:43:42.280 --> 00:43:43.419
Don't reinvent the wheel.

00:43:43.419 --> 00:43:44.710
Interact with other frameworks.

00:43:44.710 --> 00:43:50.290
You saw the example with Angular
talking to a web component.

00:43:50.290 --> 00:43:53.504
And the last one is
good software practices.

00:43:53.504 --> 00:43:54.920
Good paradigms
that we've used all

00:43:54.920 --> 00:43:56.610
over the place in
other languages,

00:43:56.610 --> 00:43:57.820
bringing those to the web.

00:43:57.820 --> 00:43:59.790
So thanks to Shadow
DOM, we have things

00:43:59.790 --> 00:44:02.440
like object-oriented
programming to some extent.

00:44:02.440 --> 00:44:04.940
We have encapsulation
to some extent.

00:44:04.940 --> 00:44:07.610
And that stuff that hasn't
been able to be achieved

00:44:07.610 --> 00:44:12.250
before outside of the
world of Web Components.

00:44:12.250 --> 00:44:14.900
So with that, I really
appreciate you guys' time.

00:44:14.900 --> 00:44:17.170
Thank you for listening to
me ramble to you up here.

00:44:17.170 --> 00:44:19.330
Hopefully I didn't
speak too fast.

00:44:19.330 --> 00:44:22.870
I will put these slides
up on a URL some place.

00:44:22.870 --> 00:44:25.230
Feel free to follow me
on Google+ or Twitter.

00:44:25.230 --> 00:44:28.220
And I will post the links there,
along with the demos and stuff

00:44:28.220 --> 00:44:29.520
that you saw today.

00:44:29.520 --> 00:44:32.610
So I'm happy to take
questions now or later.

00:44:32.610 --> 00:44:33.832
Thank you for your time.

00:44:33.832 --> 00:44:39.244
[APPLAUSE]

00:44:45.550 --> 00:44:48.603
ERIC BIDELMAN: Are you
guys all just blown away?

00:44:48.603 --> 00:44:49.391
Yeah, question.

00:44:49.391 --> 00:44:50.016
AUDIENCE: Yeah.

00:44:50.016 --> 00:44:51.801
I thank you for a very
good presentation.

00:44:51.801 --> 00:44:52.842
ERIC BIDELMAN: Thank you.

00:44:52.842 --> 00:44:58.517
AUDIENCE: So my question is that
one of the issues for Polymer

00:44:58.517 --> 00:45:02.010
could be a deployment
of all our browsers.

00:45:02.010 --> 00:45:07.000
So could you share
current status of that?

00:45:07.000 --> 00:45:09.150
ERIC BIDELMAN: Sure.

00:45:09.150 --> 00:45:11.690
Whoa, I just totally slid out.

00:45:11.690 --> 00:45:14.700
As I mentioned before, actually
one explicit goal of Polymer

00:45:14.700 --> 00:45:18.850
is to support the latest version
of every modern, evergreen

00:45:18.850 --> 00:45:21.140
browser, which means
the browsers that

00:45:21.140 --> 00:45:22.360
update themselves.

00:45:22.360 --> 00:45:24.970
And one reason we really
wanted to focus on this

00:45:24.970 --> 00:45:26.870
is one, for technical reasons.

00:45:26.870 --> 00:45:29.620
It's very hard to
polyfill certain APIs

00:45:29.620 --> 00:45:32.615
in libraries that don't support
certain JavaScript features.

00:45:32.615 --> 00:45:35.030
Because ultimately,
everything that this sits on

00:45:35.030 --> 00:45:37.670
is enabled through polyfill
libraries in JavaScript

00:45:37.670 --> 00:45:40.380
until the browsers
have these modern APIs,

00:45:40.380 --> 00:45:43.890
so you can get rid of
that red layer completely.

00:45:43.890 --> 00:45:45.390
And the other reason
is that we want

00:45:45.390 --> 00:45:48.670
to stay up to date
with the web platform.

00:45:48.670 --> 00:45:52.840
So as things like web animations
get added to the web platform

00:45:52.840 --> 00:45:55.760
as the native API, we want to
use that right away in Polymer

00:45:55.760 --> 00:45:59.080
to do really cool, slick
animations for our elements.

00:45:59.080 --> 00:46:01.175
Things like pointer events,
when those are native.

00:46:01.175 --> 00:46:02.550
Some of this stuff
is never going

00:46:02.550 --> 00:46:03.800
to come to older web browsers.

00:46:03.800 --> 00:46:07.250
So it's going to be very hard
for us to sort of envision

00:46:07.250 --> 00:46:10.820
and show developers really
the true path forward.

00:46:10.820 --> 00:46:12.840
Having said that, we
have pretty good support

00:46:12.840 --> 00:46:14.730
across the board for
the different browsers.

00:46:14.730 --> 00:46:17.280
And mobile is also
pretty well supported.

00:46:17.280 --> 00:46:20.470
but super old browsers,
unfortunately, it's

00:46:20.470 --> 00:46:21.595
very, very challenging.

00:46:29.220 --> 00:46:29.850
Question, yes?

00:46:29.850 --> 00:46:32.402
AUDIENCE: Yeah, I'm
wondering what's

00:46:32.402 --> 00:46:37.114
the performance implementation
of Web Components?

00:46:37.114 --> 00:46:42.570
I think that you should
indicate using the [INAUDIBLE].

00:46:46.042 --> 00:46:49.762
The other thing, the
other [INAUDIBLE] kind

00:46:49.762 --> 00:46:52.490
of a browser itself.

00:46:52.490 --> 00:46:55.466
And I'm wondering, where
are the [INAUDIBLE] using

00:46:55.466 --> 00:47:00.697
a component should
be in this catalog.

00:47:00.697 --> 00:47:01.530
ERIC BIDELMAN: Yeah.

00:47:01.530 --> 00:47:02.430
That's a really good question.

00:47:02.430 --> 00:47:04.920
And I'll just repeat it for
anybody that didn't hear it.

00:47:04.920 --> 00:47:07.820
The question was, what's the
performance characteristic

00:47:07.820 --> 00:47:11.020
of Web Components compared
to other sort of libraries

00:47:11.020 --> 00:47:14.410
and frameworks, essentially.

00:47:14.410 --> 00:47:16.620
So one thing about
this is right now,

00:47:16.620 --> 00:47:19.300
if you use Polymer in a
browser that doesn't support

00:47:19.300 --> 00:47:22.370
the native APIs, you're
going to be using libraries.

00:47:22.370 --> 00:47:25.100
You are going to be using
JavaScript libraries.

00:47:25.100 --> 00:47:27.910
One reason frameworks
exist today

00:47:27.910 --> 00:47:31.480
is to help developers
build web applications.

00:47:31.480 --> 00:47:34.120
And they've gone through
sort of great lengths

00:47:34.120 --> 00:47:37.090
to implement their widgets,
their libraries, their core

00:47:37.090 --> 00:47:40.570
APIs because the primitives--
these fundamental technologies

00:47:40.570 --> 00:47:42.980
of the platform-- Shadow
DOM, custom elements--

00:47:42.980 --> 00:47:44.175
haven't existed.

00:47:44.175 --> 00:47:46.740
Now I can imagine-- and really
hope-- we get to a point

00:47:46.740 --> 00:47:51.290
someday where every framework
uses a lot of these platform

00:47:51.290 --> 00:47:52.180
capabilities.

00:47:52.180 --> 00:47:54.930
So the whole web gets
faster because everybody's

00:47:54.930 --> 00:47:58.020
using the raw APIs
added to the browser.

00:47:58.020 --> 00:48:00.590
Excuse me.

00:48:00.590 --> 00:48:02.970
Right now in Polymer,
you get libraries.

00:48:02.970 --> 00:48:05.952
But in browsers that
support these APIs natively,

00:48:05.952 --> 00:48:07.160
things are much, much better.

00:48:07.160 --> 00:48:08.800
You can use the
native platform APIs.

00:48:08.800 --> 00:48:10.030
So it's part of the browser.

00:48:10.030 --> 00:48:11.684
It's part of your stack.

00:48:11.684 --> 00:48:13.600
And so that's really the
cool part about this,

00:48:13.600 --> 00:48:17.410
is that if you choose to buy
into Web Components today,

00:48:17.410 --> 00:48:20.040
that extra layer of
library sort of goes away.

00:48:20.040 --> 00:48:22.810
And so things just automatically
work and get faster.

00:48:25.280 --> 00:48:27.780
Performance in general is, I
think, a very challenging topic

00:48:27.780 --> 00:48:29.947
because it covers many,
many different facets.

00:48:29.947 --> 00:48:32.280
So I think you'll hear some
really awesome presentations

00:48:32.280 --> 00:48:37.036
today in everything from
rendering to network to browser

00:48:37.036 --> 00:48:38.160
and JavaScript performance.

00:48:42.580 --> 00:48:43.080
Yes?

00:48:43.080 --> 00:48:44.891
AUDIENCE: I see that
you're [? about ?] there.

00:48:44.891 --> 00:48:46.932
How far can you go
[INAUDIBLE] Internet Explorer?

00:48:49.570 --> 00:48:50.470
ERIC BIDELMAN: Yeah.

00:48:50.470 --> 00:48:52.920
This table is not
even that up to date.

00:48:52.920 --> 00:48:55.140
Internet Explorer
10 is the browser

00:48:55.140 --> 00:48:57.625
we're choosing to support
because it has some

00:48:57.625 --> 00:48:59.000
of the JavaScript
APIs that allow

00:48:59.000 --> 00:49:02.005
us to polyfill Shadow DOM.

00:49:02.005 --> 00:49:05.320
Having said that, it doesn't
have mutation observers, which

00:49:05.320 --> 00:49:09.430
I think is why this
has a limited usable.

00:49:09.430 --> 00:49:12.370
So IE 11 just came out,
which has mutation observers,

00:49:12.370 --> 00:49:14.590
even though they're
a little bit flaky.

00:49:14.590 --> 00:49:17.522
So that is going to be really
the true version of IE that

00:49:17.522 --> 00:49:19.480
is going to support a
lot of this native stuff.

00:49:28.330 --> 00:49:30.272
Any other questions?

00:49:30.272 --> 00:49:30.772
Yes.

00:49:33.718 --> 00:49:39.520
AUDIENCE: [INAUDIBLE] of when
you [INAUDIBLE] You [INAUDIBLE]

00:49:39.520 --> 00:49:43.965
may or may not want the
users of the new element

00:49:43.965 --> 00:49:48.420
to [INAUDIBLE] inside
the element [INAUDIBLE].

00:49:48.420 --> 00:49:53.700
And [? altogether ?] that the
user of the element, if they

00:49:53.700 --> 00:49:57.825
want to change
something, or they

00:49:57.825 --> 00:50:04.174
want to find a variant of
the element by, for example,

00:50:04.174 --> 00:50:08.142
[INAUDIBLE] the custom element.

00:50:08.142 --> 00:50:12.507
Do you have any control
over [INAUDIBLE] elements?

00:50:12.507 --> 00:50:13.340
ERIC BIDELMAN: Yeah.

00:50:13.340 --> 00:50:15.400
So the question was,
how much flexibility

00:50:15.400 --> 00:50:18.391
do you have controlling--
when you use somebody else's

00:50:18.391 --> 00:50:20.640
component on your page, can
you customize it yourself?

00:50:20.640 --> 00:50:24.020
Can you drill into it and
maybe tweak it a little bit?

00:50:24.020 --> 00:50:26.780
And then also, maybe as
a component author, can

00:50:26.780 --> 00:50:29.610
I do things sort of
outside of my box?

00:50:29.610 --> 00:50:31.450
And the answer is yes.

00:50:31.450 --> 00:50:32.970
So this is the web platform.

00:50:32.970 --> 00:50:34.491
You can do anything you want.

00:50:34.491 --> 00:50:35.990
It's JavaScript,
you can do anything

00:50:35.990 --> 00:50:38.780
you want to [? limited
?] capabilities.

00:50:38.780 --> 00:50:40.940
And that's part of what
Shadow DOM gives us,

00:50:40.940 --> 00:50:45.920
is it raises the bar to be
able to drill down into things.

00:50:45.920 --> 00:50:49.040
It gives us things like DOM
encapsulation and styling

00:50:49.040 --> 00:50:50.030
encapsulation.

00:50:50.030 --> 00:50:52.660
But in JavaScript, I can
totally, as another developer,

00:50:52.660 --> 00:50:54.500
drill down into
someone's Shadow DOM

00:50:54.500 --> 00:50:56.479
and maybe tweak
things if I want.

00:50:56.479 --> 00:50:58.520
And that's just sort of
a fundamental way the web

00:50:58.520 --> 00:51:01.380
and JavaScript works,

00:51:01.380 --> 00:51:04.360
You could also say as
an element consumer,

00:51:04.360 --> 00:51:08.100
if I'm using somebody
else's tab strip widget.

00:51:08.100 --> 00:51:11.565
I can choose to bring that into
my app, and then extend that.

00:51:11.565 --> 00:51:12.940
If I don't like
the way it looks,

00:51:12.940 --> 00:51:14.890
if I don't like
its APIs, if I want

00:51:14.890 --> 00:51:19.122
to add new and additional
APIs on top of that element,

00:51:19.122 --> 00:51:20.830
I can choose to extend
that element using

00:51:20.830 --> 00:51:23.386
Web Components and
the extends attribute.

00:51:23.386 --> 00:51:24.760
And then give it
a different look

00:51:24.760 --> 00:51:28.070
and feel, or flare it
up with some extra APIs.

00:51:28.070 --> 00:51:31.760
So the APIs in general
are there to help

00:51:31.760 --> 00:51:32.910
you do things like that.

00:51:32.910 --> 00:51:36.500
But they also allow you to sort
of have this encapsulate world

00:51:36.500 --> 00:51:37.090
as well.

00:51:37.090 --> 00:51:39.490
So there's some guarantee
that your component

00:51:39.490 --> 00:51:43.470
remains a component how
you intended it to be.

00:51:43.470 --> 00:51:45.210
That's a good question.

00:51:45.210 --> 00:51:45.710
Cool.

00:51:45.710 --> 00:51:46.990
So I think we're out of time.

00:51:46.990 --> 00:51:48.650
Feel free to come and
ask me questions any time

00:51:48.650 --> 00:51:49.510
throughout the day.

00:51:49.510 --> 00:51:50.300
Thank you.

00:51:50.300 --> 00:52:04.545
[APPLAUSE]

