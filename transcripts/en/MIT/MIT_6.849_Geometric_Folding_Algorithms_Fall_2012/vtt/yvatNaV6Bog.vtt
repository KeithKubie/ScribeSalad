WEBVTT
Kind: captions
Language: en

00:00:03.280 --> 00:00:04.740
PROFESSOR: All
right, so lecture 11

00:00:04.740 --> 00:00:09.200
was about generic
rigidity of linkages.

00:00:09.200 --> 00:00:14.400
So we've got bars and vertices
connected together in a graph.

00:00:14.400 --> 00:00:16.870
And generically, the
graph is all that matters.

00:00:16.870 --> 00:00:20.150
And we characterize in two
ways, Henneberg construction

00:00:20.150 --> 00:00:25.027
and Laman when graphs
are generically rigid.

00:00:25.027 --> 00:00:27.110
And in particular, there
was this pebble algorithm

00:00:27.110 --> 00:00:29.110
that was supposed to tell
you in polynomial time

00:00:29.110 --> 00:00:31.510
whether you're a graph
was Laman or not.

00:00:31.510 --> 00:00:35.266
And everyone pretty much asked
about this, about the details,

00:00:35.266 --> 00:00:37.140
including myself when
I watched it like, huh,

00:00:37.140 --> 00:00:38.870
that seems a little sketchy.

00:00:38.870 --> 00:00:40.620
So I thought I'd spend
most of today going

00:00:40.620 --> 00:00:43.630
through how that
algorithm works exactly

00:00:43.630 --> 00:00:47.580
and also why it's correct, which
is definitely not obviously.

00:00:47.580 --> 00:00:54.030
It vaguely feels correct, but
we'll see why it actually is.

00:00:54.030 --> 00:01:02.170
Remember Laman's Theorem,
Laman characterization

00:01:02.170 --> 00:01:11.400
is that your graph is
generically rigid if and only

00:01:11.400 --> 00:01:27.090
if every subgraph-- let's
say every k vertices induces

00:01:27.090 --> 00:01:28.760
at most to 2k minus 3 edges.

00:01:32.580 --> 00:01:33.700
That's part one.

00:01:33.700 --> 00:01:35.400
And you also need
that the number

00:01:35.400 --> 00:01:42.840
of edges overall in
the graph is 2n minus 3

00:01:42.840 --> 00:01:45.575
where n is the total
number vertices.

00:01:45.575 --> 00:01:47.450
So this was just the
degree of freedom count.

00:01:47.450 --> 00:01:51.110
You have 2n degrees of freedom
for every vertex minus 3

00:01:51.110 --> 00:01:54.140
for the rigid motions, two
translations, one rotation.

00:01:54.140 --> 00:01:56.990
So that's the number of
edges you should have total.

00:01:56.990 --> 00:01:57.490
Sorry.

00:01:57.490 --> 00:01:59.156
This is for minimally
generically rigid.

00:02:02.280 --> 00:02:05.710
And then to make it
balance, you want

00:02:05.710 --> 00:02:08.800
to guarantee that every
k vertices doesn't

00:02:08.800 --> 00:02:09.765
have too many edges.

00:02:09.765 --> 00:02:11.140
Because if it has
too many edges,

00:02:11.140 --> 00:02:12.740
there'd be too few
somewhere else.

00:02:12.740 --> 00:02:14.614
This part would be
overbrace, some other part

00:02:14.614 --> 00:02:16.590
would be underbrace,
and you'd be flexible.

00:02:16.590 --> 00:02:19.180
That's the intuition.

00:02:19.180 --> 00:02:21.560
And so the tricky
part comes down

00:02:21.560 --> 00:02:25.690
to how do you check whether
every k vertices induces

00:02:25.690 --> 00:02:28.950
2k minus 3 edges because they're
exponentially many choices.

00:02:28.950 --> 00:02:32.457
There's 2 to the n different
choices of subsets or vertices.

00:02:32.457 --> 00:02:34.040
For each of them,
you'd have to check.

00:02:34.040 --> 00:02:35.290
That's no good.

00:02:35.290 --> 00:02:37.000
So the algorithm
wants to check this.

00:02:37.000 --> 00:02:39.050
And I'm going to
call this property

00:02:39.050 --> 00:02:40.925
the 2k minus 3 property.

00:02:44.110 --> 00:02:46.560
And we're going to warm up
with a simpler problem, which

00:02:46.560 --> 00:02:51.810
is to check to the 2k
property without the minus 3.

00:02:51.810 --> 00:03:02.610
So 2k property is
just every k vertices

00:03:02.610 --> 00:03:08.200
induce at most 2k edges.

00:03:11.050 --> 00:03:12.990
So this'll be a little
easier to think about,

00:03:12.990 --> 00:03:17.014
more or less the same, a
lot easier to argue about.

00:03:17.014 --> 00:03:18.930
And then we'll see how
to modify the algorithm

00:03:18.930 --> 00:03:21.840
to check the 2k
minus 3 property.

00:03:21.840 --> 00:03:26.170
Was the property clear and
in particular inducing?

00:03:26.170 --> 00:03:30.450
Inducing means that you
have some set of vertices,

00:03:30.450 --> 00:03:33.310
and there's the rest of the
vertices, n minus k of them.

00:03:33.310 --> 00:03:37.200
You only look at edges where
both endpoints are in the set,

00:03:37.200 --> 00:03:39.750
both of them are
among the k vertices.

00:03:39.750 --> 00:03:45.531
So you ignore vertices that have
one end in k and the other end

00:03:45.531 --> 00:03:46.030
outside.

00:03:46.030 --> 00:03:49.670
And you ignore, obviously, edges
that have both ends outside.

00:03:49.670 --> 00:03:50.660
Just count these guys.

00:03:54.000 --> 00:03:57.010
So how do we do this?

00:03:57.010 --> 00:03:58.310
Give you the algorithm.

00:03:58.310 --> 00:04:02.000
Actually, let me first give
you the idea of the algorithm

00:04:02.000 --> 00:04:04.840
before we go to the
actual algorithm.

00:04:04.840 --> 00:04:07.680
And this is review,
but pretty soon we'll

00:04:07.680 --> 00:04:10.055
get to stuff that wasn't
covered in lecture.

00:04:24.280 --> 00:04:33.501
So the idea is every vertex
has two pebbles inside of it.

00:04:33.501 --> 00:04:37.300
I'll draw as two red dots.

00:04:37.300 --> 00:04:41.924
And they can cover
incident edges.

00:04:41.924 --> 00:04:43.090
So they can't move very far.

00:04:43.090 --> 00:04:45.600
They have to stay
basically on the inside

00:04:45.600 --> 00:04:47.260
or on the boundary
of the vertex.

00:04:47.260 --> 00:04:49.560
That's how I'm going to draw it.

00:04:49.560 --> 00:05:03.245
Each pebble can cover
one incident edge.

00:05:08.910 --> 00:05:12.605
So for example,
there's a little graph.

00:05:16.680 --> 00:05:18.976
I could take--
let's maybe I leave

00:05:18.976 --> 00:05:20.350
one of the pebbles
in the middle.

00:05:20.350 --> 00:05:24.120
I can move one of the pebbles
to cover one of the edges.

00:05:24.120 --> 00:05:25.870
So I'll put it this
intersection to denote

00:05:25.870 --> 00:05:29.000
it's covering this edge, but it
still belongs to this vertex.

00:05:29.000 --> 00:05:30.460
Pebbles cannot change vertices.

00:05:30.460 --> 00:05:32.970
They have to stay local.

00:05:32.970 --> 00:05:35.860
These two pebbles could
just stay where they are.

00:05:35.860 --> 00:05:37.740
Here, we could put
one pebble here,

00:05:37.740 --> 00:05:41.334
another pebble there, one
pebble here, one pebble here.

00:05:41.334 --> 00:05:43.000
This is what I call
a pebble cover cause

00:05:43.000 --> 00:05:46.750
every edge is covered
by some pebble.

00:05:46.750 --> 00:05:54.710
That's the goal in a pebble
cover is to cover every edge.

00:05:57.950 --> 00:05:59.125
You need to cover it once.

00:06:04.270 --> 00:06:11.030
And the pebbles can either cover
an edge or they can be free.

00:06:11.030 --> 00:06:13.630
Free if they're just
hanging out in the inside

00:06:13.630 --> 00:06:16.450
here not being
used for anything.

00:06:16.450 --> 00:06:18.470
So our goal is to
find pebble covers.

00:06:18.470 --> 00:06:21.420
But the first claim, why do
I care about pebble covers,

00:06:21.420 --> 00:06:23.470
I claimed that
having a pebble cover

00:06:23.470 --> 00:06:26.520
is equivalent to
the 2k property.

00:06:26.520 --> 00:06:28.960
So that's what I want to show.

00:06:37.979 --> 00:06:39.020
So let's start with that.

00:06:39.020 --> 00:06:41.860
This is why
everything is working.

00:06:41.860 --> 00:06:46.940
A graph has a 2k property if and
only if it has a pebble cover.

00:06:51.740 --> 00:06:55.730
So that's why we care about
these pebble coverings.

00:06:55.730 --> 00:07:01.090
And this is actually
pretty easy to prove

00:07:01.090 --> 00:07:04.630
and gives a lot of intuition
for why everything works here.

00:07:04.630 --> 00:07:09.240
So let's start with
the left direction.

00:07:09.240 --> 00:07:11.180
So suppose I have
a pebble cover.

00:07:11.180 --> 00:07:13.470
Suppose somehow I've
achieved this property,

00:07:13.470 --> 00:07:17.500
covering all the edges, using
only two pebbles per vertex.

00:07:17.500 --> 00:07:20.690
I claim that we then
satisfy the 2k property.

00:07:20.690 --> 00:07:22.940
2k property says you
take any key vertices,

00:07:22.940 --> 00:07:24.510
you induce at most
two key edges.

00:07:24.510 --> 00:07:28.220
So let's consider k vertices.

00:07:28.220 --> 00:07:30.600
Someone chooses k vertices.

00:07:30.600 --> 00:07:32.206
doesn't matter which.

00:07:32.206 --> 00:07:36.810
It should hold for all
of them, for all choices.

00:07:36.810 --> 00:07:40.290
So we've got a k vertices here.

00:07:40.290 --> 00:07:42.900
n minus k vertices remaining.

00:07:42.900 --> 00:07:45.360
We claim that the number
of edges induced by those k

00:07:45.360 --> 00:07:47.670
vertices is at most 2k.

00:07:47.670 --> 00:07:49.980
So look at one of these
edges that's wholly inside,

00:07:49.980 --> 00:07:51.555
that's induced by
these k vertices.

00:07:55.381 --> 00:08:00.370
I claim, well, that edge
must be covered by a pebble.

00:08:00.370 --> 00:08:01.190
Which pebble?

00:08:01.190 --> 00:08:05.840
Well, either this one or
one on the other side.

00:08:05.840 --> 00:08:08.040
But the point is it
is covered by a pebble

00:08:08.040 --> 00:08:10.920
among these vertices.

00:08:10.920 --> 00:08:14.790
My concern is, well, maybe you
worry about an edge like this.

00:08:18.590 --> 00:08:20.650
Or, maybe you worry
about a pebble

00:08:20.650 --> 00:08:23.290
here that's covering this
edge, but that edge is not

00:08:23.290 --> 00:08:25.300
one of the induced edges.

00:08:25.300 --> 00:08:27.420
So these vertices are relevant.

00:08:27.420 --> 00:08:33.740
It's just the pebbles inside,
just among these 2k pebbles.

00:08:33.740 --> 00:08:36.840
So in here, there
are 2k pebbles.

00:08:36.840 --> 00:08:40.159
They must fully cover
the induced subgraph.

00:08:40.159 --> 00:08:42.890
They must cover all
the edges in here.

00:08:42.890 --> 00:08:45.470
That means they're
at most 2k edges

00:08:45.470 --> 00:08:49.390
because there's one
pebble per edge at least.

00:08:49.390 --> 00:08:51.410
And so there's 2k
pebbles in here.

00:08:51.410 --> 00:08:55.640
This means they're at
must 2k induced edges.

00:09:01.340 --> 00:09:02.200
Clear?

00:09:02.200 --> 00:09:05.320
That's the obvious direction.

00:09:05.320 --> 00:09:08.424
This doesn't really exploit
very much about pebbles.

00:09:08.424 --> 00:09:10.465
The other direction is a
little more interesting.

00:09:13.360 --> 00:09:15.000
Why should these
pebble covers exist?

00:09:15.000 --> 00:09:16.720
Because they seem
pretty constrained.

00:09:16.720 --> 00:09:19.046
Pebbles can't move very far.

00:09:19.046 --> 00:09:24.300
It's not really clearly
the same, but it is.

00:09:24.300 --> 00:09:26.940
So if we have the 2k property--

00:09:26.940 --> 00:09:31.170
So now we know that every
subgraph of k vertices

00:09:31.170 --> 00:09:33.210
induces at most 2k edges.

00:09:33.210 --> 00:09:35.565
Now, we want to prove that
a pebble cover exists.

00:09:40.030 --> 00:09:42.760
I'm going to wait.

00:09:42.760 --> 00:09:46.180
It will become
obvious momentarily.

00:09:46.180 --> 00:09:48.332
This is fun.

00:09:48.332 --> 00:09:50.040
Sometimes, it's easier
to prove a theorem

00:09:50.040 --> 00:09:51.610
than it is to come
up with an algorithm.

00:09:51.610 --> 00:09:54.026
But in this case, it's easier
to come up with an algorithm

00:09:54.026 --> 00:09:55.280
than it is to prove a theorem.

00:09:55.280 --> 00:09:58.580
And you can use the algorithm
itself to prove the theorem,

00:09:58.580 --> 00:10:00.440
so I'm going to prove
this in a moment.

00:10:00.440 --> 00:10:01.030
Stay tuned.

00:10:04.820 --> 00:10:06.305
Meanwhile, we have an algorithm.

00:10:09.120 --> 00:10:10.620
This algorithm is
an example of what

00:10:10.620 --> 00:10:14.220
we call an incremental style
algorithm where you imagine

00:10:14.220 --> 00:10:16.260
starting with the
empty graph and then

00:10:16.260 --> 00:10:19.870
you put in all the edges
that belong one at a time.

00:10:19.870 --> 00:10:23.760
So add edges one at a time
starting from nothing.

00:10:29.140 --> 00:10:33.000
One detail is we're going to
imagine as edges get added,

00:10:33.000 --> 00:10:34.840
we want to direct them.

00:10:34.840 --> 00:10:46.240
We're going to direct edges
from the pebble that covers them

00:10:46.240 --> 00:10:49.410
to the other side.

00:10:49.410 --> 00:10:58.220
So if we have an edge and
we have a pebble over here,

00:10:58.220 --> 00:11:00.590
than I'm going to imagine
the edge as being directed

00:11:00.590 --> 00:11:04.220
from the pebble
to the other side.

00:11:04.220 --> 00:11:06.880
That's just for convenience
for expressing the algorithm

00:11:06.880 --> 00:11:09.530
in a moment.

00:11:09.530 --> 00:11:14.860
So now this is for
the 2k property.

00:11:14.860 --> 00:11:17.155
We'll get to an algorithm
for 2k minus 3 a little bit.

00:11:29.150 --> 00:11:34.990
So now we have a 4 loop over
the edge is we're going to add.

00:11:34.990 --> 00:11:39.270
And when I immediately add an
edge, it will not be covered,

00:11:39.270 --> 00:11:44.000
so it's not directed,
just some edge v-w.

00:11:44.000 --> 00:11:45.610
I would like to
put a pebble here,

00:11:45.610 --> 00:11:47.995
but it could be
both pebbles at w

00:11:47.995 --> 00:11:49.650
are occupied for
some other edges.

00:11:49.650 --> 00:11:54.450
It could be the
pebbles for v are also

00:11:54.450 --> 00:11:55.942
occupied for some other edges.

00:11:55.942 --> 00:11:56.900
That would be annoying.

00:11:56.900 --> 00:12:00.400
I want to somehow reassign
a pebble to cover this edge,

00:12:00.400 --> 00:12:17.800
so what I'm going to
do inside this 4 loop

00:12:17.800 --> 00:12:23.840
is search for available pebbles.

00:12:23.840 --> 00:12:26.580
And in this case, what
turns out to be right

00:12:26.580 --> 00:12:31.700
is a directed path in
this directed graph

00:12:31.700 --> 00:12:37.310
from either v or w
to a free pebble.

00:12:45.790 --> 00:12:48.010
Either I find one or I don't.

00:12:48.010 --> 00:12:52.505
If I find one, let's
say from v, there's

00:12:52.505 --> 00:12:57.020
some edge and then some other
edge and some other edge.

00:12:57.020 --> 00:12:58.821
And eventually, I
find a free pebble.

00:12:58.821 --> 00:13:01.320
Remember a free pebble is one
that's floating on the inside,

00:13:01.320 --> 00:13:03.340
not being used for anything.

00:13:03.340 --> 00:13:05.700
So what does my
picture look like?

00:13:05.700 --> 00:13:07.610
Remember edges are
directed from the pebbles.

00:13:07.610 --> 00:13:09.870
That means there was a pebble
at v being used for that edge.

00:13:09.870 --> 00:13:11.360
There was a pebble
at this vertex

00:13:11.360 --> 00:13:12.425
being used for that edge.

00:13:12.425 --> 00:13:13.800
There was a pebble
at this vertex

00:13:13.800 --> 00:13:16.560
being used for that edge.

00:13:16.560 --> 00:13:18.280
In this case, what do I do?

00:13:24.120 --> 00:13:25.050
AUDIENCE: Reverse.

00:13:25.050 --> 00:13:26.840
PROFESSOR: Reverse them, yeah.

00:13:26.840 --> 00:13:28.680
Just reverse all the edges.

00:13:28.680 --> 00:13:32.060
So I have this edge, v-w, here.

00:13:32.060 --> 00:13:33.920
I want to put a
pebble here, so I'm

00:13:33.920 --> 00:13:38.650
going to reassign this guy
to be over there, this guy

00:13:38.650 --> 00:13:42.310
to be over there, this guy
to be over there, and so on.

00:13:42.310 --> 00:13:48.500
So I end up with--
that's in the way.

00:13:48.500 --> 00:13:50.420
Put w over here.

00:13:50.420 --> 00:13:52.190
The new picture
is I have v and w.

00:13:55.132 --> 00:13:56.965
And I'm going to have
left 4 directed edges.

00:14:01.540 --> 00:14:06.790
So now this pebble got
assigned to be here.

00:14:06.790 --> 00:14:09.150
I can't draw left apparently.

00:14:09.150 --> 00:14:09.970
The other left.

00:14:12.385 --> 00:14:13.510
This pebble assigned there.

00:14:13.510 --> 00:14:15.940
This pebble, the free
pebble, gets used up.

00:14:15.940 --> 00:14:18.410
And now we've got a
free pebble over here.

00:14:18.410 --> 00:14:21.580
And now we can assign it
to be on the edge v-w.

00:14:21.580 --> 00:14:23.920
So if I can find such a
path from v or from w,

00:14:23.920 --> 00:14:25.685
I'm happy because
then I can reassign.

00:14:38.370 --> 00:14:45.660
If I find such a path, I just
shift the pebbles like that,

00:14:45.660 --> 00:14:46.600
and I'm done.

00:14:51.010 --> 00:14:52.320
But what if I can't?

00:14:52.320 --> 00:14:54.310
This is the critical
issue, and it is also

00:14:54.310 --> 00:14:56.340
core to this part
of the proof that we

00:14:56.340 --> 00:14:59.690
haven't discover--
haven't yet done.

00:14:59.690 --> 00:15:01.504
Why would we hope
for pebble covers

00:15:01.504 --> 00:15:02.670
to exist in the first place?

00:15:02.670 --> 00:15:04.410
We don't know.

00:15:04.410 --> 00:15:06.810
I claim if this
algorithm fails to find

00:15:06.810 --> 00:15:10.400
a path in this situation,
then you can immediately

00:15:10.400 --> 00:15:13.600
say you do not satisfy
the 2k property.

00:15:13.600 --> 00:15:15.965
I'd like to say there's
no pebble cover,

00:15:15.965 --> 00:15:17.090
but that's a little harder.

00:15:17.090 --> 00:15:22.160
I'm going to say you do not
satisfy the 2k property.

00:15:33.820 --> 00:15:37.750
And we actually know
already, from this part,

00:15:37.750 --> 00:15:39.232
pebble cover
implies 2k property.

00:15:39.232 --> 00:15:41.190
The contrapositive, which
we've already proved,

00:15:41.190 --> 00:15:44.010
is if you do not
satisfy the 2k property,

00:15:44.010 --> 00:15:45.950
you do not have a pebble cover.

00:15:45.950 --> 00:15:48.810
So that will actually guarantee
correctness of the algorithm.

00:15:48.810 --> 00:15:51.530
If I can prove this part,
that it violates 2k property,

00:15:51.530 --> 00:15:54.270
then I'll know there was no
pebble cover, and I'm done.

00:15:56.960 --> 00:15:59.090
So why is this true.

00:15:59.090 --> 00:16:05.970
I claim if you look at
all the nodes reachable

00:16:05.970 --> 00:16:13.490
by directed paths
from v and w, then

00:16:13.490 --> 00:16:18.620
that is a set of nodes that
induce more than 2k edges.

00:16:18.620 --> 00:16:22.820
So let's say their k
nodes you can reach.

00:16:22.820 --> 00:16:26.050
I claim there will be more
than 2k edges among them.

00:16:26.050 --> 00:16:26.550
Why?

00:16:29.570 --> 00:16:34.510
It's fun to have proof in
the middle of an algorithm.

00:16:34.510 --> 00:16:38.540
So here we've got to
v and w, and these

00:16:38.540 --> 00:16:41.160
are the k nodes that are
reachable from v and w, which

00:16:41.160 --> 00:16:46.150
means all of the other edges
are pointing into this set.

00:16:46.150 --> 00:16:48.264
And then, over here,
we have everybody else.

00:16:48.264 --> 00:16:49.430
I mean it might be everyone.

00:16:49.430 --> 00:16:54.050
But potentially, there's
some vertices over here.

00:16:54.050 --> 00:16:56.690
All the edges are directed
from right to left,

00:16:56.690 --> 00:17:00.350
otherwise we could
reach more stuff.

00:17:00.350 --> 00:17:01.680
So what's the situation?

00:17:01.680 --> 00:17:03.740
v-w is uncovered.

00:17:03.740 --> 00:17:05.216
There's no pebbles
that cover it.

00:17:10.660 --> 00:17:12.750
Every other edge is
covered because there's

00:17:12.750 --> 00:17:15.079
only one uncovered
edge at any moment.

00:17:15.079 --> 00:17:17.240
These edges are all
covered from this end.

00:17:17.240 --> 00:17:19.839
That's what these
directions mean, which

00:17:19.839 --> 00:17:21.980
means all the
pebbles in here are

00:17:21.980 --> 00:17:25.160
used to cover induced edges.

00:17:25.160 --> 00:17:28.640
So all the pebbles in here
are covering induced edges,

00:17:28.640 --> 00:17:32.180
and yet, there's one induced
edge that is not covered.

00:17:32.180 --> 00:17:34.130
Now they're exactly 2k pebbles.

00:17:34.130 --> 00:17:36.120
They're all being used.

00:17:36.120 --> 00:17:38.890
I'm assuming here you never
have two pebbles covering

00:17:38.890 --> 00:17:44.520
the same edge, so that
means-- so there's 2k pebbles.

00:17:44.520 --> 00:17:48.290
They're all used to cover
induced edges, which

00:17:48.290 --> 00:17:54.220
implies you have
exactly 2k plus 1 edges.

00:17:54.220 --> 00:17:56.800
Plus 1 is v-w.

00:17:56.800 --> 00:18:00.970
That means that means the
graph that we've created so far

00:18:00.970 --> 00:18:02.314
violates the 2k property.

00:18:02.314 --> 00:18:03.980
Now, we haven't added
all the edges yet,

00:18:03.980 --> 00:18:05.438
but if we add more
edge, it's going

00:18:05.438 --> 00:18:07.430
to get even worse potentially.

00:18:07.430 --> 00:18:10.780
If we have 2k plus 1 edges
now, in the actual graph,

00:18:10.780 --> 00:18:14.660
we'll have at least
2k plus 1 edges.

00:18:14.660 --> 00:18:18.450
So if this search
fails, you know

00:18:18.450 --> 00:18:21.367
that you violate the
2k property, which

00:18:21.367 --> 00:18:23.200
means you know that
there's no pebble cover.

00:18:23.200 --> 00:18:25.260
So that proves correctness
of the algorithm.

00:18:25.260 --> 00:18:28.230
Now we can come
back to this claim.

00:18:28.230 --> 00:18:38.460
This follows, by correctness
of the algorithm, why.

00:18:38.460 --> 00:18:40.950
We want to prove if we
have the 2k property,

00:18:40.950 --> 00:18:42.440
then you have a pebble copper.

00:18:42.440 --> 00:18:48.090
Well, if I have the 2k property,
this algorithm will work.

00:18:48.090 --> 00:18:50.700
This case can never
happen because it can only

00:18:50.700 --> 00:18:52.390
happen when you violate
the 2k property.

00:18:52.390 --> 00:18:55.270
So if you have the 2k
property, this algorithm,

00:18:55.270 --> 00:18:56.450
you can keep running it.

00:18:56.450 --> 00:18:57.692
You will always find a path.

00:18:57.692 --> 00:18:59.150
You'll be able to
shift the pebbles

00:18:59.150 --> 00:19:02.440
and always cover things, and
so you get a pebble cover

00:19:02.440 --> 00:19:04.011
from the algorithm.

00:19:04.011 --> 00:19:04.510
The end.

00:19:07.600 --> 00:19:09.850
That's how you argue that
if you have the 2k property,

00:19:09.850 --> 00:19:11.600
you get a pebble cover.

00:19:11.600 --> 00:19:13.014
And it's nifty.

00:19:13.014 --> 00:19:14.430
Without this
algorithm, this would

00:19:14.430 --> 00:19:17.660
be quite tricky to specify.

00:19:17.660 --> 00:19:20.330
But the algorithm tells
you where the violation

00:19:20.330 --> 00:19:24.220
would be, tells you where you
would violate the 2k property.

00:19:24.220 --> 00:19:27.880
And that lets you prove
the claim ultimately.

00:19:27.880 --> 00:19:30.580
Any questions about that.

00:19:30.580 --> 00:19:32.840
This, I think, is the
heart of pebble algorithms

00:19:32.840 --> 00:19:33.960
and why they work.

00:19:33.960 --> 00:19:35.360
It's the cleanest part.

00:19:35.360 --> 00:19:38.840
It gets a little bit messier
to do the 2k minus 3 thing,

00:19:38.840 --> 00:19:41.380
so we'll move to that next.

00:19:41.380 --> 00:19:44.890
Maybe before we go there, we
can talk about the running time

00:19:44.890 --> 00:19:51.445
of the algorithm for
those so inclined.

00:20:07.680 --> 00:20:10.200
So the heart of the
algorithm is this step,

00:20:10.200 --> 00:20:14.330
search for directed path
for v or w to a free pebble.

00:20:14.330 --> 00:20:17.010
This is essentially some of
the nodes have free pebbles.

00:20:17.010 --> 00:20:19.370
Those are like good nodes.

00:20:19.370 --> 00:20:21.340
But basically, we've
got a directed graph.

00:20:21.340 --> 00:20:25.930
We want to find all the nodes
that are reachable from v,

00:20:25.930 --> 00:20:28.940
see if there's any good
nodes that have free pebbles,

00:20:28.940 --> 00:20:30.607
search from all
the nodes from w.

00:20:30.607 --> 00:20:32.940
This you could do with a depth
first search or a breadth

00:20:32.940 --> 00:20:35.360
first search or your
favorite search algorithm.

00:20:35.360 --> 00:20:36.297
Takes linear time.

00:20:36.297 --> 00:20:38.130
Order the number of
vertices plus the number

00:20:38.130 --> 00:20:41.350
of edges in the graph.

00:20:41.350 --> 00:20:43.990
We do this search v times.

00:20:47.090 --> 00:20:47.860
Why v times?

00:20:54.210 --> 00:20:57.950
So we add edges one at a time.

00:20:57.950 --> 00:21:01.560
We're hoping that we
have the 2k property.

00:21:01.560 --> 00:21:03.480
The 2k property implies
that, in particular,

00:21:03.480 --> 00:21:05.980
there at most 2v edges.

00:21:05.980 --> 00:21:08.550
So in general, we
do this e times.

00:21:08.550 --> 00:21:09.880
We keep adding edges.

00:21:09.880 --> 00:21:13.850
We would add e edges
to the graph hopefully.

00:21:13.850 --> 00:21:16.960
In general, e can be much
larger than v in a graph. e

00:21:16.960 --> 00:21:20.330
could v squared, the worst case.

00:21:20.330 --> 00:21:23.310
But this algorithm
will fail by the time

00:21:23.310 --> 00:21:25.950
you add 2k plus 1 edges
because then you definitely

00:21:25.950 --> 00:21:28.740
don't satisfy the 2k property
over the entire graph,

00:21:28.740 --> 00:21:30.410
so particularly you
won't satisfy it

00:21:30.410 --> 00:21:31.580
on some subset of vertices.

00:21:34.320 --> 00:21:36.560
So you will only have to
run this loop v times,

00:21:36.560 --> 00:21:39.170
not e times-- or 2v times.

00:21:39.170 --> 00:21:42.320
So this is a little bit
smaller, and so this product

00:21:42.320 --> 00:21:47.670
is v squared plus ve.

00:21:47.670 --> 00:21:51.060
Normally, we write ve, but
this is slightly more precise,

00:21:51.060 --> 00:21:53.370
which is the same
as Bellman Ford

00:21:53.370 --> 00:21:56.490
algorithm if you've
taken algorithms.

00:21:56.490 --> 00:21:59.680
I'll just mention that there is
an algorithm slightly fancier

00:21:59.680 --> 00:22:02.370
that just requires this term.

00:22:02.370 --> 00:22:05.390
This is possible.

00:22:05.390 --> 00:22:08.300
You don't need this ve part.

00:22:08.300 --> 00:22:11.795
but it's beside the point
to our goal, which is just

00:22:11.795 --> 00:22:14.320
to understand when
things are rigid,

00:22:14.320 --> 00:22:16.980
when they're not in an
efficient amount of time.

00:22:16.980 --> 00:22:19.680
So this is polynomial
in any case.

00:22:19.680 --> 00:22:22.127
This also the best known
algorithm, v squared.

00:22:22.127 --> 00:22:23.960
Open problem is whether
you could do better.

00:22:27.770 --> 00:22:29.067
Questions?

00:22:29.067 --> 00:22:29.566
Yeah?

00:22:29.566 --> 00:22:35.530
AUDIENCE: Is there more than 2v
edges instead of, [INAUDIBLE]

00:22:35.530 --> 00:22:37.612
that [INAUDIBLE] problem.

00:22:37.612 --> 00:22:39.570
PROFESSOR: Yes, there
are more than to v edges.

00:22:39.570 --> 00:22:40.300
Oh, right!

00:22:40.300 --> 00:22:41.630
So there's done.

00:22:41.630 --> 00:22:42.815
Great.

00:22:42.815 --> 00:22:44.940
You can just check in the
beginning, are there more

00:22:44.940 --> 00:22:45.980
than to v edges.

00:22:45.980 --> 00:22:52.880
If so, you do not satisfy the 2k
property, and so you can stop.

00:22:52.880 --> 00:22:55.600
So that takes constant time to
check those cases, otherwise e

00:22:55.600 --> 00:22:56.780
is small.

00:22:56.780 --> 00:22:58.910
And then you only
take the square time.

00:22:58.910 --> 00:23:00.166
Thanks.

00:23:00.166 --> 00:23:00.665
That's key.

00:23:06.520 --> 00:23:10.420
So that was the 2k property.

00:23:10.420 --> 00:23:14.080
Let's do 2k minus 3.

00:23:28.960 --> 00:23:30.530
For the 2k minus
3 algorithm, it's

00:23:30.530 --> 00:23:33.880
going to be pretty much
the same as this algorithm.

00:23:33.880 --> 00:23:36.900
So in particular, every
vertex is to attach pebbles.

00:23:36.900 --> 00:23:38.720
Each pebble can cover
when it's in an edge,

00:23:38.720 --> 00:23:40.060
otherwise it's free.

00:23:40.060 --> 00:23:42.730
Our goal is to cover every edge.

00:23:42.730 --> 00:23:44.120
But it's slightly differently.

00:23:44.120 --> 00:23:46.640
We have to deal with
this minus 3 business.

00:23:46.640 --> 00:24:00.620
And for that we need
another claim, which

00:24:00.620 --> 00:24:07.740
is that a graph has a
2k minus 3 property if

00:24:07.740 --> 00:24:14.640
and only if g plus three
copies of an edge e

00:24:14.640 --> 00:24:30.610
has the 2k property for
every edge, e and g.

00:24:30.610 --> 00:24:35.097
Should probably say g has.

00:24:35.097 --> 00:24:36.930
So I want to know whether
my-- ultimately, I

00:24:36.930 --> 00:24:39.040
care whether my graph has
a 2k minus 3 property.

00:24:39.040 --> 00:24:41.620
This is most of the
Laman condition.

00:24:41.620 --> 00:24:43.330
It's the hard part to check.

00:24:43.330 --> 00:24:45.920
And 2k property is what
I know how to check.

00:24:45.920 --> 00:24:48.190
So I claim all you need
to do to check it--

00:24:48.190 --> 00:24:49.770
this would actually
be an algorithm.

00:24:49.770 --> 00:24:52.680
For every edge, turn
that single edge

00:24:52.680 --> 00:24:55.470
into four copies of the
edge, add three more,

00:24:55.470 --> 00:24:57.510
check whether it
has the 2k property,

00:24:57.510 --> 00:25:00.390
remove those extra three
copies, take the next edge,

00:25:00.390 --> 00:25:03.150
add three copies,
check the 2k property.

00:25:03.150 --> 00:25:07.280
So with another
factor of e, which

00:25:07.280 --> 00:25:11.750
has to be order v, if you're
willing to spend v cubed time,

00:25:11.750 --> 00:25:15.240
you can just run this
algorithm for each edge,

00:25:15.240 --> 00:25:19.580
quadruple it, see whether it
still has the 2k property.

00:25:19.580 --> 00:25:22.330
So that's the connection
between these 2 things.

00:25:22.330 --> 00:25:23.502
Let me prove this claim.

00:25:23.502 --> 00:25:25.210
And then I'll tell
you a better algorithm

00:25:25.210 --> 00:25:26.501
that only takes v squared time.

00:25:33.069 --> 00:25:35.450
Which one's easier?

00:25:35.450 --> 00:25:39.525
In both cases, I want
to take k vertices.

00:25:44.790 --> 00:25:48.215
And then I'll do in
this direction first.

00:25:51.090 --> 00:25:53.900
So how do we prove this?

00:25:53.900 --> 00:25:56.580
First, this is
actually really easy.

00:25:56.580 --> 00:25:59.330
Suppose g has a 2k
minus 3 property.

00:25:59.330 --> 00:26:02.170
So if I have k
vertices here, I know

00:26:02.170 --> 00:26:06.470
that the number of edges in
here is at most 2k minus 3.

00:26:06.470 --> 00:26:07.915
So here's k vertices.

00:26:07.915 --> 00:26:09.540
Looking at the number
of induced edges,

00:26:09.540 --> 00:26:13.270
it's going to be
at most 2k minus 3.

00:26:13.270 --> 00:26:16.440
What I'm claiming is then
if I quadruple an edge,

00:26:16.440 --> 00:26:22.370
if I add three new edges, I have
at most 2k edges afterwards.

00:26:22.370 --> 00:26:23.730
I think that's pretty clear.

00:26:23.730 --> 00:26:25.780
2k minus 3 would be 4 at most.

00:26:25.780 --> 00:26:28.400
If I add three copies of any
edge, could be in this set

00:26:28.400 --> 00:26:30.770
or outside the set
would be even better,

00:26:30.770 --> 00:26:33.740
the number of edges inside
the set will be at most 2k.

00:26:33.740 --> 00:26:36.080
So this is in g.

00:26:36.080 --> 00:26:45.620
This implies there's at
most 2k and g plus thrice e.

00:26:45.620 --> 00:26:47.360
This is non-standard
notation by the way.

00:26:47.360 --> 00:26:50.080
It just means add three
copies of that edge.

00:26:50.080 --> 00:26:55.330
So we would normally
draw that like this,

00:26:55.330 --> 00:26:58.020
four copies of the edge.

00:26:58.020 --> 00:27:02.700
So that was half of the
claim, pretty trivial.

00:27:02.700 --> 00:27:04.230
The other half is
almost as trivial.

00:27:09.620 --> 00:27:12.930
So on the other
direction, we assume

00:27:12.930 --> 00:27:16.980
that g plus 3e has this
property for every edge.

00:27:16.980 --> 00:27:20.620
And now we need to prove
that g has a 2k minus 3

00:27:20.620 --> 00:27:22.359
property for every
set of k vertices.

00:27:22.359 --> 00:27:24.150
So we're looking at
that set of k vertices.

00:27:24.150 --> 00:27:26.430
We want to argue
that in g, there's

00:27:26.430 --> 00:27:28.790
at most 2k minus 3 edges.

00:27:28.790 --> 00:27:33.020
What we know is that in here,
in g plus 3 e for any e--

00:27:33.020 --> 00:27:37.850
so it's a little awkward--
but let me start by drawing g.

00:27:37.850 --> 00:27:40.520
We want to claim that the
number of edges in here

00:27:40.520 --> 00:27:43.260
is at most 2k minus 3, so
I'll put a question mark.

00:27:47.180 --> 00:27:49.410
So there are 2
possibilities here.

00:27:49.410 --> 00:27:53.090
It could be either this
graph is completely empty.

00:27:53.090 --> 00:27:55.710
If there are no edges in
here, then surely there

00:27:55.710 --> 00:27:58.210
are at most 2k minus
3 of them, assuming k

00:27:58.210 --> 00:28:02.440
is bigger than 1, which
I haven't mentioned.

00:28:02.440 --> 00:28:04.850
But throughout here, I need
the k is bigger than 1.

00:28:04.850 --> 00:28:07.335
You can never have negative
1 edges on subgraphs,

00:28:07.335 --> 00:28:10.840
so the 2k in the 2k
minus 3 property only

00:28:10.840 --> 00:28:13.630
hold for at least 2 vertices.

00:28:13.630 --> 00:28:14.300
K is at least 2.

00:28:17.070 --> 00:28:19.250
So if there are no
edges, find I'm done.

00:28:19.250 --> 00:28:23.270
If there are edges in here,
then I can do this trick.

00:28:23.270 --> 00:28:24.160
So there's some edge.

00:28:24.160 --> 00:28:25.830
Pick your favorite edge.

00:28:25.830 --> 00:28:29.360
Call it e in this subset.

00:28:29.360 --> 00:28:33.427
Produce out of it
g plus 3e, which

00:28:33.427 --> 00:28:35.260
just looks like the
same thing, but now it's

00:28:35.260 --> 00:28:38.280
got four copies of that edge.

00:28:38.280 --> 00:28:42.590
This we know has at
most 2k edges in here.

00:28:42.590 --> 00:28:44.440
The original graph
is exactly the same

00:28:44.440 --> 00:28:46.610
except it lacks those
three edges, therefore,

00:28:46.610 --> 00:28:49.380
there's at most 2k
minus 3 of them.

00:28:49.380 --> 00:28:53.190
So it's really the same
proof in both directions.

00:28:53.190 --> 00:28:55.430
Here, you have to
use your freedom

00:28:55.430 --> 00:28:56.990
in choosing e to
choose an edge that

00:28:56.990 --> 00:28:59.090
is induced in this subgraph.

00:28:59.090 --> 00:29:00.910
You can't choose some
other edge out here.

00:29:05.300 --> 00:29:05.800
Question?

00:29:05.800 --> 00:29:09.062
AUDIENCE: So this seems
kind of cheap because we're

00:29:09.062 --> 00:29:15.440
using the graph as a
linkage in the end,

00:29:15.440 --> 00:29:21.245
so adding these extra edges,
they all collapse into one.

00:29:21.245 --> 00:29:22.370
PROFESSOR: Ah, interesting.

00:29:22.370 --> 00:29:22.870
Right.

00:29:22.870 --> 00:29:26.040
So why this feels
like cheating because,

00:29:26.040 --> 00:29:29.110
from a linkage
perspective, these 2 guys

00:29:29.110 --> 00:29:30.550
have exactly the
same constraints.

00:29:30.550 --> 00:29:32.229
AUDIENCE: Yeah.

00:29:32.229 --> 00:29:33.020
PROFESSOR: I agree.

00:29:33.020 --> 00:29:34.420
It's weird.

00:29:34.420 --> 00:29:38.350
At this point, this is a device.

00:29:38.350 --> 00:29:40.240
You could think of
it as adding edges.

00:29:40.240 --> 00:29:42.210
Another way to think
of it is this edge

00:29:42.210 --> 00:29:45.250
has to be covered
by four pebbles.

00:29:45.250 --> 00:29:47.310
That's probably a
little more intuitive.

00:29:47.310 --> 00:29:49.140
So having to cover an
edge by four pebbles,

00:29:49.140 --> 00:29:51.540
essentially, is
pinning the edge.

00:29:51.540 --> 00:29:53.880
Because on the one hand, you
have a single pebble just

00:29:53.880 --> 00:29:55.611
to say this is an edge.

00:29:55.611 --> 00:29:57.110
And then you have
three more pebbles

00:29:57.110 --> 00:29:59.040
to eat up the translations
and rotations.

00:29:59.040 --> 00:30:01.480
That's intuitively
what's going on.

00:30:01.480 --> 00:30:04.470
I agree this looks weird.

00:30:04.470 --> 00:30:07.310
And at this point, we're just
playing the graph theory game

00:30:07.310 --> 00:30:08.740
and ignoring the linkages.

00:30:08.740 --> 00:30:11.090
That's the short
answer why this is OK.

00:30:11.090 --> 00:30:13.110
But ultimately,
intuitively, what's going on

00:30:13.110 --> 00:30:15.180
is that these three
edges are just

00:30:15.180 --> 00:30:18.750
representing the translations
and rotations being eaten.

00:30:18.750 --> 00:30:21.940
And they have to be
somehow eatable universally

00:30:21.940 --> 00:30:22.660
at every edge.

00:30:22.660 --> 00:30:24.944
That's what this is saying.

00:30:24.944 --> 00:30:26.610
I don't have a great
intuition for that,

00:30:26.610 --> 00:30:29.450
but it is-- pretty
sure you do need

00:30:29.450 --> 00:30:31.525
to say for every edge,
not just some edge.

00:30:35.950 --> 00:30:39.060
So at this point, you have
a polynomial time algorithm,

00:30:39.060 --> 00:30:40.360
so I'm done.

00:30:40.360 --> 00:30:44.260
But let me briefly mention
how you could make it faster

00:30:44.260 --> 00:30:50.360
by modifying this algorithm to
do the 2k minus 3 situation.

00:30:50.360 --> 00:30:54.630
Dare I-- I won't literally
modify the algorithm.

00:30:54.630 --> 00:30:57.090
I'll write a new version.

00:30:57.090 --> 00:30:59.520
But I'm going to use that
as a subroutine basically.

00:31:15.990 --> 00:31:26.150
And so algorithm
2k minus 3 version.

00:31:26.150 --> 00:31:27.766
So it's going to
be the same style.

00:31:27.766 --> 00:31:29.390
We're going to add
edges one at a time.

00:31:29.390 --> 00:31:32.010
We'll direct the edges in the
same way for each added edge

00:31:32.010 --> 00:31:33.610
v-w.

00:31:33.610 --> 00:31:40.540
I'll just write for
each added edge v-w.

00:31:45.700 --> 00:31:51.400
Before I just tried to add the
edge and cover it with pebble.

00:31:51.400 --> 00:31:53.270
Now, I want to cover
it with four pebbles.

00:31:53.270 --> 00:31:56.120
I want to basically add
the edge four times.

00:32:07.150 --> 00:32:12.660
I'm going to write as
above to mean this step.

00:32:12.660 --> 00:32:14.500
So every time I add
the edge, I search

00:32:14.500 --> 00:32:18.520
for a directed path from
v or w for free pebble.

00:32:18.520 --> 00:32:22.000
When I find it, I
do the pebble shift.

00:32:22.000 --> 00:32:24.170
I do that four times.

00:32:24.170 --> 00:32:26.490
Then basically, I have
four pebbles on the edge,

00:32:26.490 --> 00:32:28.989
or you could think of them as
being four copies of the edge,

00:32:28.989 --> 00:32:30.560
each has one pebble.

00:32:30.560 --> 00:32:33.480
Either I succeed and I get all
four, or I don't get all four.

00:32:36.500 --> 00:32:43.530
On success, this is just
a temporary measure.

00:32:43.530 --> 00:32:46.480
At that point, I'm going to
delete three of the copies.

00:32:46.480 --> 00:32:48.800
Put it back to a
regular single edge.

00:32:48.800 --> 00:32:54.077
This frees three
pebbles for future use.

00:32:54.077 --> 00:32:55.910
So I don't want every
edge to be quadrupled.

00:32:58.832 --> 00:33:00.790
I don't want them all to
be quadrupled at once.

00:33:00.790 --> 00:33:02.430
I want to try
quadrupling one edge,

00:33:02.430 --> 00:33:03.950
then try quadrupling
the next edge,

00:33:03.950 --> 00:33:05.210
try quadrupling the next edge.

00:33:05.210 --> 00:33:07.720
But when I'm
quadrupling an edge,

00:33:07.720 --> 00:33:10.690
all the other edges
exist as single edges.

00:33:10.690 --> 00:33:12.980
So I delete the three copies.

00:33:12.980 --> 00:33:15.070
And then this four loop
continues and tries

00:33:15.070 --> 00:33:17.400
the next edge.

00:33:17.400 --> 00:33:21.590
On failure-- here I'm
going to say something

00:33:21.590 --> 00:33:23.590
more interesting-- Normally,
on failure I'd say,

00:33:23.590 --> 00:33:26.500
well, you don't satisfy
the 2k minus 3 property.

00:33:26.500 --> 00:33:27.690
Game over.

00:33:27.690 --> 00:33:31.820
But you can be a little
more sophisticated.

00:33:31.820 --> 00:33:34.970
Just say delete all
the copies of e.

00:33:34.970 --> 00:33:36.960
I guess there's four of them.

00:33:36.960 --> 00:33:40.690
Whatever pebbles you can
acquire, you give them up.

00:33:40.690 --> 00:33:43.470
Delete the edge and
call the edge redundant.

00:33:48.870 --> 00:33:50.470
Basically, in this
case, you could

00:33:50.470 --> 00:33:53.850
argue that edge was superfluous
for rigidity purposes.

00:33:53.850 --> 00:33:55.650
You didn't need it.

00:33:55.650 --> 00:33:57.800
So the algorithm
doesn't just fail.

00:33:57.800 --> 00:34:00.230
It says this was a useless edge.

00:34:00.230 --> 00:34:02.320
And it'll tell you
which edges are useful,

00:34:02.320 --> 00:34:05.660
which ones are non-redundant
from a rigidity standpoint.

00:34:05.660 --> 00:34:12.989
And then when you're done,
you will be rigid if and only

00:34:12.989 --> 00:34:23.690
if the number of non-redundant
edges that remain

00:34:23.690 --> 00:34:27.139
equals 2n minus 3.

00:34:27.139 --> 00:34:29.690
So that's the last part
of the Laman check.

00:34:29.690 --> 00:34:31.870
So this is giving you a
little bit more information

00:34:31.870 --> 00:34:34.719
than just do I satisfy
the 2k minus 3 property.

00:34:34.719 --> 00:34:37.204
To get that, you just check
whether you ever failed.

00:34:37.204 --> 00:34:38.620
But in this case,
you can actually

00:34:38.620 --> 00:34:41.590
see, ah, these are
the useless edges.

00:34:41.590 --> 00:34:44.489
They're those overbracing edges.

00:34:44.489 --> 00:34:45.980
Everything else is useful.

00:34:45.980 --> 00:34:48.630
And if I end up having enough
useful edges to n minus 3

00:34:48.630 --> 00:34:51.980
of them, then I know I'm rigid.

00:34:51.980 --> 00:34:53.530
Otherwise, I'm going
to be flexible.

00:34:53.530 --> 00:34:56.144
So this gives you all
the information you want.

00:34:56.144 --> 00:34:57.560
With a little bit
more effort, you

00:34:57.560 --> 00:35:02.040
could even figure out if I'm
flexible, which parts are rigid

00:35:02.040 --> 00:35:06.160
and which parts can move
relative to each other.

00:35:06.160 --> 00:35:07.700
This, of course,
generically rigid.

00:35:10.300 --> 00:35:14.970
Finally, let me show you
this thing in action.

00:35:14.970 --> 00:35:18.010
So look over there.

00:35:18.010 --> 00:35:21.780
This is an implementation
by Audrey Lee-Saint John.

00:35:21.780 --> 00:35:24.050
And so here's a simple graph.

00:35:24.050 --> 00:35:26.765
You can probably see this
top part is flexible.

00:35:26.765 --> 00:35:28.070
It's quadrilateral.

00:35:28.070 --> 00:35:31.149
Bottom part is overbraced.

00:35:31.149 --> 00:35:32.440
This is in 2 dimensions, right?

00:35:32.440 --> 00:35:33.856
So just triangles
would be enough,

00:35:33.856 --> 00:35:36.750
but I've added an
extra edge here.

00:35:36.750 --> 00:35:38.920
And this is going to check
the Laman condition one

00:35:38.920 --> 00:35:40.240
step at a time.

00:35:40.240 --> 00:35:42.340
So we start with 2
pebbles everywhere.

00:35:42.340 --> 00:35:44.650
We start by adding
that top edge.

00:35:44.650 --> 00:35:46.640
Right now, there are four
pebbles on that edge,

00:35:46.640 --> 00:35:47.223
so it's great.

00:35:47.223 --> 00:35:48.250
I can just add the edge.

00:35:48.250 --> 00:35:51.262
Let's say I added it four times.

00:35:51.262 --> 00:35:52.470
There are four pebbles there.

00:35:52.470 --> 00:35:54.770
But then in the end,
I just need one.

00:35:54.770 --> 00:35:56.470
So let's skip that step.

00:35:56.470 --> 00:36:00.190
And now I've got the one
pebble from b, and we're happy.

00:36:00.190 --> 00:36:03.270
So that is its own
rigid component.

00:36:03.270 --> 00:36:05.700
Next, let's add this edge ef.

00:36:05.700 --> 00:36:09.010
So this also has four
pebbles on it, so we're done.

00:36:09.010 --> 00:36:09.810
Next, we have cd.

00:36:09.810 --> 00:36:11.690
That also has-- you
could change the order

00:36:11.690 --> 00:36:13.398
if you think this
one's a little trivial.

00:36:13.398 --> 00:36:14.940
Now is when the action happens.

00:36:14.940 --> 00:36:17.690
Let's add this edge bc.

00:36:17.690 --> 00:36:21.380
So currently, it is only
covered by three pebbles.

00:36:21.380 --> 00:36:23.910
But we need a fourth.

00:36:23.910 --> 00:36:27.620
So we're going to take one
of these free pebbles on a

00:36:27.620 --> 00:36:29.150
and move it along b.

00:36:29.150 --> 00:36:31.960
We found that by starting
from b and searching out

00:36:31.960 --> 00:36:33.160
and finding a free pebble.

00:36:33.160 --> 00:36:34.576
So we just flip that edge.

00:36:34.576 --> 00:36:35.950
Now we've got a
free pebble on b.

00:36:35.950 --> 00:36:39.930
Now we've got four pebbles on
bc, and we can add the edge.

00:36:39.930 --> 00:36:42.280
But we only actually
take one of them.

00:36:42.280 --> 00:36:44.550
So I'm skipping the part
where we add the four copies

00:36:44.550 --> 00:36:48.310
and immediately remove three
of them because that's silly.

00:36:48.310 --> 00:36:48.810
Cool.

00:36:48.810 --> 00:36:50.910
So that's its own rigid
component it turns out.

00:36:50.910 --> 00:36:53.320
Each of these things
is independently--

00:36:53.320 --> 00:36:55.690
the colors represent
rigid components.

00:36:55.690 --> 00:36:57.820
And right now nothing
is tied together.

00:36:57.820 --> 00:36:58.780
Everything's flexible.

00:36:58.780 --> 00:36:59.450
Flexible at b.

00:36:59.450 --> 00:37:01.750
Flexible at c.

00:37:01.750 --> 00:37:05.499
Let's add this diagonal df.

00:37:05.499 --> 00:37:07.040
So right now, it
only has one pebble,

00:37:07.040 --> 00:37:08.750
which means we
need four pebbles.

00:37:08.750 --> 00:37:10.960
So we're actually going
to have to get one at f,

00:37:10.960 --> 00:37:12.376
and we're going
to have to get one

00:37:12.376 --> 00:37:14.880
at d because there can
only be two at each.

00:37:14.880 --> 00:37:18.367
So first, we'll do I
guess a search from d,

00:37:18.367 --> 00:37:20.470
and we immediately
find a pebble.

00:37:20.470 --> 00:37:21.820
We move it down there.

00:37:21.820 --> 00:37:22.810
Great.

00:37:22.810 --> 00:37:24.160
Then, we search from f.

00:37:24.160 --> 00:37:25.330
We find a pebble there.

00:37:25.330 --> 00:37:26.270
We move it.

00:37:26.270 --> 00:37:26.770
Boom!

00:37:26.770 --> 00:37:31.346
We've got our edge,
added all four pebbles.

00:37:31.346 --> 00:37:33.220
Eventually we're going
to run out of pebbles,

00:37:33.220 --> 00:37:35.380
but right now, we
are very flexible.

00:37:35.380 --> 00:37:36.630
Let's add this other diagonal.

00:37:36.630 --> 00:37:37.950
This should also be possible.

00:37:37.950 --> 00:37:41.000
Right now, there's one
pebble at e, one pebble at c.

00:37:41.000 --> 00:37:43.350
We've got to find
two more pebbles.

00:37:43.350 --> 00:37:44.900
So first, we'll
follow this edge.

00:37:44.900 --> 00:37:45.930
Find a free pebble at f.

00:37:45.930 --> 00:37:47.660
That was easy.

00:37:47.660 --> 00:37:51.242
Next, we'll look at from c.

00:37:51.242 --> 00:37:53.060
There's only one way
we can go from c.

00:37:53.060 --> 00:37:54.380
We can't follow the back edge.

00:37:54.380 --> 00:37:55.650
Got to go forward.

00:37:55.650 --> 00:37:57.810
Got a pebble at d.

00:37:57.810 --> 00:37:59.040
Flip it around.

00:37:59.040 --> 00:38:03.360
Now, we've got four pebbles on
c and e, so we can add the edge.

00:38:05.980 --> 00:38:07.030
Now, let's add ef.

00:38:07.030 --> 00:38:10.810
Right now, we've only got
one pebble, yet we need four.

00:38:10.810 --> 00:38:12.444
So let's start by
searching from a.

00:38:12.444 --> 00:38:13.860
Oh, we found a
pebble immediately.

00:38:13.860 --> 00:38:17.570
In general, we would have
to follow many edges.

00:38:17.570 --> 00:38:19.419
So there's a from f.

00:38:19.419 --> 00:38:20.710
There are two ways we could go.

00:38:20.710 --> 00:38:22.710
Either one of them would
have given us a pebble.

00:38:22.710 --> 00:38:24.110
Let's flip the yellow edge.

00:38:24.110 --> 00:38:24.610
Boom!

00:38:24.610 --> 00:38:28.507
We've got f, one pebble,
but we need another one.

00:38:28.507 --> 00:38:30.840
Now, we cannot get another
pebble from e because we just

00:38:30.840 --> 00:38:33.200
flipped the edge, but we
can get a pebble from d,

00:38:33.200 --> 00:38:36.580
so we flip that edge.

00:38:36.580 --> 00:38:41.350
And now we can add the
edge af to more edges.

00:38:41.350 --> 00:38:43.770
It's a little tedious.

00:38:43.770 --> 00:38:45.920
So next is cf.

00:38:45.920 --> 00:38:48.030
We're running out
of pebbles here.

00:38:48.030 --> 00:38:51.450
There's only five pebbles
total in the system.

00:38:51.450 --> 00:38:53.890
We need four of them
right here because we're

00:38:53.890 --> 00:38:56.050
getting almost rigid.

00:38:56.050 --> 00:38:57.190
So let's see.

00:38:57.190 --> 00:38:59.306
We've got cf.

00:38:59.306 --> 00:39:01.179
Let's start from
searching from f.

00:39:01.179 --> 00:39:02.470
There's only one way we can go.

00:39:02.470 --> 00:39:03.178
We find a pebble.

00:39:03.178 --> 00:39:04.550
We flip it around.

00:39:04.550 --> 00:39:07.220
Now we've got c.

00:39:07.220 --> 00:39:08.870
There's only one
way to go from c.

00:39:08.870 --> 00:39:10.900
We find the pebble at e.

00:39:10.900 --> 00:39:12.120
And we flip it around.

00:39:12.120 --> 00:39:14.960
Now we've got the two pebbles.

00:39:14.960 --> 00:39:15.991
Cool.

00:39:15.991 --> 00:39:17.490
So we've got the
three pebbles here,

00:39:17.490 --> 00:39:20.230
which are representing our
translations and rotations.

00:39:20.230 --> 00:39:22.190
The only other pebble
left is this one,

00:39:22.190 --> 00:39:24.770
which is basically representing
the degree of freedom

00:39:24.770 --> 00:39:26.490
in this quadrilateral.

00:39:26.490 --> 00:39:28.990
So when we go to add the
last edge, which is-- so

00:39:28.990 --> 00:39:31.030
at this point, this is
a ridge it component

00:39:31.030 --> 00:39:33.290
because of the triangles.

00:39:33.290 --> 00:39:35.260
And we go to add
the last edge, we

00:39:35.260 --> 00:39:38.310
will fail to find
enough pebbles.

00:39:38.310 --> 00:39:38.930
Let's see.

00:39:38.930 --> 00:39:40.430
We can find three of them.

00:39:40.430 --> 00:39:42.060
We can grab the one from e.

00:39:42.060 --> 00:39:45.860
Or let's see so-- it's
not going to show us.

00:39:45.860 --> 00:39:50.410
But from e, we can grab
f, the pebble at f.

00:39:50.410 --> 00:39:52.160
From d, we can grab
the pebble at c.

00:39:52.160 --> 00:39:54.541
From d, we can grab
the other pebble at f.

00:39:54.541 --> 00:39:56.040
We've got three
pebbles, but there's

00:39:56.040 --> 00:39:59.560
no way to get to this pebble
because both of these edges

00:39:59.560 --> 00:40:00.800
are directed down.

00:40:00.800 --> 00:40:04.150
So you can never get from the
below part to the above part.

00:40:04.150 --> 00:40:06.230
So it's not obvious
that this is working.

00:40:06.230 --> 00:40:08.400
That's what the proof is for.

00:40:08.400 --> 00:40:11.410
But at least you
see it in action.

00:40:11.410 --> 00:40:14.716
I'll just run it very
quickly for another graph.

00:40:14.716 --> 00:40:17.600
Let's say a big one.

00:40:17.600 --> 00:40:20.220
This one is minimally,
generically rigid.

00:40:20.220 --> 00:40:23.250
So it's fun to
watch for a while.

00:40:23.250 --> 00:40:27.935
You get pebbles moving around.

00:40:27.935 --> 00:40:29.820
In this case, you
have some longer paths

00:40:29.820 --> 00:40:33.090
you have to follow to
get enough pebbles.

00:40:33.090 --> 00:40:35.515
It depends a lot on the
insertion order that you use.

00:40:41.950 --> 00:40:46.006
So in each case, you need four
pebbles, two on each side.

00:40:46.006 --> 00:40:47.380
And if so, you
can add your edge.

00:40:47.380 --> 00:40:48.270
Otherwise, you can't.

00:40:48.270 --> 00:40:50.990
What I haven't described
is this color coding

00:40:50.990 --> 00:40:54.190
which is figuring out when
you have rigid components.

00:40:54.190 --> 00:40:57.632
Roughly speaking, to find
what your rigid component is--

00:40:57.632 --> 00:41:00.090
if you're an edge, you want to
know what rigid component am

00:41:00.090 --> 00:41:04.480
I in-- you basically just
search for all the vertices

00:41:04.480 --> 00:41:07.510
that are reachable
from your edge.

00:41:07.510 --> 00:41:09.240
Those are all in
your rigid component.

00:41:09.240 --> 00:41:11.242
That's what we saw.

00:41:11.242 --> 00:41:13.075
So this graph happens
to be minimally rigid,

00:41:13.075 --> 00:41:16.161
and it detects that.

00:41:16.161 --> 00:41:17.660
But then it can be
a little bit more

00:41:17.660 --> 00:41:19.180
as in your rigid component.

00:41:19.180 --> 00:41:24.350
Some of the incoming
edges-- let's see.

00:41:24.350 --> 00:41:26.390
Draw a picture.

00:41:26.390 --> 00:41:30.410
So here's everything
you can reach from v-w.

00:41:30.410 --> 00:41:32.430
And say you're following
an incoming edge here

00:41:32.430 --> 00:41:34.692
from some other vertex u.

00:41:34.692 --> 00:41:36.400
And then suppose these
are all the things

00:41:36.400 --> 00:41:38.540
you can reach from you.

00:41:38.540 --> 00:41:41.110
If there are zero
pebbles out here,

00:41:41.110 --> 00:41:43.622
then this whole thing
is a rigid component.

00:41:43.622 --> 00:41:44.830
And you just keep doing that.

00:41:44.830 --> 00:41:46.360
You check an incoming edge.

00:41:46.360 --> 00:41:49.090
If there's zero pebbles
in that reachable piece,

00:41:49.090 --> 00:41:50.000
then you merge.

00:41:50.000 --> 00:41:51.000
And you keep doing that.

00:41:51.000 --> 00:41:53.594
Those are all the things that
are rigidly attached to you.

00:41:53.594 --> 00:41:54.510
So I won't prove that.

00:41:54.510 --> 00:41:56.820
It's a little tricky to
prove, but it's fairly easy

00:41:56.820 --> 00:41:57.400
to compute.

00:41:57.400 --> 00:41:59.200
And you could actually do it
in the same amount of time.

00:41:59.200 --> 00:42:00.790
As you're building
this thing up,

00:42:00.790 --> 00:42:02.694
you can do the color
coding to figure out

00:42:02.694 --> 00:42:04.860
which things are in the
same component, which things

00:42:04.860 --> 00:42:07.880
are in different components.

00:42:07.880 --> 00:42:09.820
Let's see.

00:42:09.820 --> 00:42:17.110
So another fun fact
is this little part.

00:42:17.110 --> 00:42:20.870
This says it's the
2k minus 3 property.

00:42:20.870 --> 00:42:25.130
The same algorithm you could
use to check 5k minus 27,

00:42:25.130 --> 00:42:29.960
or whatever you want, for fixed
numbers like two and three,

00:42:29.960 --> 00:42:33.960
the same pebble
algorithm can detect

00:42:33.960 --> 00:42:37.256
that ak minus b property.

00:42:37.256 --> 00:42:39.630
And that's actually useful
for a lot of different things.

00:42:39.630 --> 00:42:42.550
This is done originally
by Lee and Streinu.

00:42:42.550 --> 00:42:47.000
Same lee, and Streinu
we'll be seeing

00:42:47.000 --> 00:42:51.460
some of her results in a
couple of classes as well.

00:42:51.460 --> 00:42:59.970
For example-- so this is
that-- 3D body and bar.

00:42:59.970 --> 00:43:02.410
So actually let me
show you the kind

00:43:02.410 --> 00:43:04.610
of scenario we're
thinking about.

00:43:04.610 --> 00:43:06.140
So I mentioned 3D.

00:43:06.140 --> 00:43:11.050
If we have vertices
and bars between them,

00:43:11.050 --> 00:43:13.950
we don't know how to
characterize generic rigidity.

00:43:13.950 --> 00:43:16.710
But a slightly different
problem, which is 3D bodies,

00:43:16.710 --> 00:43:18.880
these are polyhedron.

00:43:18.880 --> 00:43:22.380
And they have bars
connected between them.

00:43:22.380 --> 00:43:27.600
This we know how to solve
in 3D and in any dimension.

00:43:27.600 --> 00:43:32.600
And so this is a picture
of not only having--

00:43:32.600 --> 00:43:35.430
so their bodies can
spin unlike vertices.

00:43:35.430 --> 00:43:36.410
Vertices can't rotate.

00:43:36.410 --> 00:43:38.182
Nothing happens when
you rotate a vertex.

00:43:38.182 --> 00:43:39.890
Bodies have this extra
degree of freedom.

00:43:43.567 --> 00:43:45.400
So there are two things
we're allowing here,

00:43:45.400 --> 00:43:48.010
one is to add a hinge
between two bodies

00:43:48.010 --> 00:43:50.000
and the other is to add
bars connecting them

00:43:50.000 --> 00:43:51.410
from various random points.

00:43:51.410 --> 00:43:54.050
And it's generic, so these
points will never coincide.

00:43:54.050 --> 00:43:56.600
I think that's what makes
this different from a vertex.

00:43:56.600 --> 00:43:58.250
Vertex bars always coincide.

00:43:58.250 --> 00:44:01.090
Here, they all just
attach to generic points.

00:44:01.090 --> 00:44:05.470
So it turns out you can
simulate a hinge by five bars.

00:44:05.470 --> 00:44:07.680
They're equivalent.

00:44:07.680 --> 00:44:13.235
So both of these can be
captured by 6K minus 6 property.

00:44:13.235 --> 00:44:15.360
Turns out these things will
be generically rigid if

00:44:15.360 --> 00:44:17.850
and only if you satisfy
the 6K minus 6 property

00:44:17.850 --> 00:44:21.930
and you have exactly
6K minus 6 bars.

00:44:21.930 --> 00:44:27.150
And this is proved by
two or three people.

00:44:27.150 --> 00:44:30.020
I mean you need to add
two results together,

00:44:30.020 --> 00:44:33.130
one from the '90s and
one from much older,

00:44:33.130 --> 00:44:34.900
I think, in graph theory.

00:44:34.900 --> 00:44:41.260
But in particular, Tae
was involved from 1984.

00:44:41.260 --> 00:44:41.919
And it's funny.

00:44:41.919 --> 00:44:44.460
The paper starts out with, if
you ask any structural engineer

00:44:44.460 --> 00:44:45.959
if you have two
bodies how many bars

00:44:45.959 --> 00:44:48.716
you have to add to rigidify
them, they will say six.

00:44:48.716 --> 00:44:50.090
I'm like, OK, I
didn't know that.

00:44:50.090 --> 00:44:52.130
But six is the right answer.

00:44:52.130 --> 00:44:56.340
And that's why the
6K minus 6 basically.

00:44:56.340 --> 00:44:58.340
And and we can use
this pebble algorithm

00:44:58.340 --> 00:45:01.240
to solve that for
free basically.

00:45:01.240 --> 00:45:04.380
And this is actually
implemented here

00:45:04.380 --> 00:45:05.660
in the same kind of software.

00:45:05.660 --> 00:45:09.910
I'll just run it quickly
because it's a lot of pebbles.

00:45:09.910 --> 00:45:12.910
Every vertex has six pebbles.

00:45:12.910 --> 00:45:15.370
You just keep going.

00:45:15.370 --> 00:45:22.930
You need to cover every
edge with how many pebbles?

00:45:22.930 --> 00:45:25.440
Before it was four,
so now it should be 7,

00:45:25.440 --> 00:45:29.460
I believe, one more
than the six here.

00:45:29.460 --> 00:45:32.060
So 6k minus 6.

00:45:32.060 --> 00:45:35.570
Anyway, this graph,
while it's not obvious,

00:45:35.570 --> 00:45:37.850
is minimally rigid
in this world.

00:45:37.850 --> 00:45:42.570
And it corresponds exactly
to the left example.

00:45:42.570 --> 00:45:45.425
It's hard to see because
we've replaced the hinges here

00:45:45.425 --> 00:45:47.590
by six bars.

00:45:47.590 --> 00:45:51.290
So that's why we got all the
six-- all the duplicated edges.

00:45:51.290 --> 00:45:53.870
Here, you see the duplicated
are different from a rigidity

00:45:53.870 --> 00:45:56.490
standpoint because having three
edges between the same pair

00:45:56.490 --> 00:45:59.970
of objects is no longer just
the same as having one edge

00:45:59.970 --> 00:46:02.310
because they attach
to different points.

00:46:02.310 --> 00:46:03.070
Each one can spin.

00:46:03.070 --> 00:46:05.170
These are universal
joints by the way.

00:46:05.170 --> 00:46:08.510
So these bars can
rotate around the body.

00:46:08.510 --> 00:46:09.540
The body can spin.

00:46:09.540 --> 00:46:10.940
Lots of things can happen.

00:46:10.940 --> 00:46:12.760
But this is enough to rigidify.

00:46:12.760 --> 00:46:15.940
Is there a question?

00:46:15.940 --> 00:46:16.480
Cool.

00:46:16.480 --> 00:46:17.646
I'm not going to prove that.

00:46:17.646 --> 00:46:20.635
You can read the papers
if you're interested.

00:46:20.635 --> 00:46:21.510
But it's interesting.

00:46:21.510 --> 00:46:26.470
Bodies and bars are so much
easier than other things.

00:46:26.470 --> 00:46:29.680
One other thing you can do
is called angular rigidity.

00:46:29.680 --> 00:46:33.920
This is a fairly new
result by same people.

00:46:33.920 --> 00:46:36.350
If you have a bunch of
lines in 3D, and you

00:46:36.350 --> 00:46:37.550
have angular constraints.

00:46:37.550 --> 00:46:40.060
In this case, every
triple of these lines

00:46:40.060 --> 00:46:42.720
has an angular constraint that
it must be equal to alpha.

00:46:42.720 --> 00:46:44.820
That's what's drawn on
this spherical picture.

00:46:44.820 --> 00:46:46.660
Over here, we have two bodies.

00:46:46.660 --> 00:46:47.810
So here we have lines.

00:46:47.810 --> 00:46:49.310
Here, we have bodies.

00:46:49.310 --> 00:46:52.890
And there are three
constraints that

00:46:52.890 --> 00:46:57.600
fix the angles between how the
angles meet at these bodies.

00:46:57.600 --> 00:47:00.960
And they claim is that both
of these are angularly rigid,

00:47:00.960 --> 00:47:03.950
meaning things can
still slide up and down,

00:47:03.950 --> 00:47:06.560
but the angles are all fixed.

00:47:06.560 --> 00:47:10.040
And you can test this again.

00:47:10.040 --> 00:47:13.490
This case actually turns out
it's the 2k minus 3 property

00:47:13.490 --> 00:47:15.370
again, same as Laman.

00:47:15.370 --> 00:47:17.304
This one, I've forgotten.

00:47:17.304 --> 00:47:17.970
I have to check.

00:47:17.970 --> 00:47:21.440
I think it's 3k minus 3.

00:47:21.440 --> 00:47:23.350
Yeah, 3k minus 3.

00:47:23.350 --> 00:47:25.440
So cool things.

00:47:25.440 --> 00:47:27.580
One last question.

00:47:27.580 --> 00:47:28.730
Connected banana.

00:47:28.730 --> 00:47:33.340
So there's this three banana
example-- or two banana

00:47:33.340 --> 00:47:33.840
example.

00:47:33.840 --> 00:47:37.007
I'm getting ahead of
myself-- which was weird.

00:47:37.007 --> 00:47:39.590
You have this one banana on the
left, one banana on the right.

00:47:39.590 --> 00:47:43.290
And there's this implicit,
implied hinge, as they call it,

00:47:43.290 --> 00:47:44.329
between the two points.

00:47:44.329 --> 00:47:46.370
The whole thing is flexible,
but if you check it,

00:47:46.370 --> 00:47:47.860
it satisfies the Lama condition.

00:47:47.860 --> 00:47:50.930
It satisfies 3k
minus 6, which is

00:47:50.930 --> 00:47:53.840
what it should be
for 3D rigidity.

00:47:53.840 --> 00:47:55.830
This is a 3D.

00:47:55.830 --> 00:47:58.250
Now, this graph is--
seems trivial-- I

00:47:58.250 --> 00:48:00.530
mean it seems easy to figure
out that this is flexible

00:48:00.530 --> 00:48:02.010
because there's a two cut.

00:48:02.010 --> 00:48:04.040
There are two vertices
you can remove

00:48:04.040 --> 00:48:06.430
that disconnect the
graph into two pieces.

00:48:06.430 --> 00:48:09.580
So if you could just subdivide,
do the left part separately

00:48:09.580 --> 00:48:12.930
from the right part, you should
be able to figure this out.

00:48:12.930 --> 00:48:15.650
Unfortunately, this example
can be made more connected,

00:48:15.650 --> 00:48:17.690
and that's what
the question was.

00:48:17.690 --> 00:48:20.740
So this is an old
example by Henry Crapo.

00:48:23.690 --> 00:48:26.600
A modification by
Walter Whiteley

00:48:26.600 --> 00:48:29.740
is that if you add a single
point here and attach it

00:48:29.740 --> 00:48:33.380
to those two points--
sorry, those three points--

00:48:33.380 --> 00:48:37.550
this will be three connected,
still be flexible, and still

00:48:37.550 --> 00:48:40.835
satisfy Laman because we added
three edges and one vertex,

00:48:40.835 --> 00:48:43.990
so it still satisfies Laman.

00:48:43.990 --> 00:48:44.850
So that sucks.

00:48:44.850 --> 00:48:46.670
We think, oh, maybe
four connected.

00:48:46.670 --> 00:48:49.470
Well, you can make it
four connected, too,

00:48:49.470 --> 00:48:51.500
by adding a triangle
in the center

00:48:51.500 --> 00:48:55.720
and connecting these six,
adding these 6 connections.

00:48:55.720 --> 00:48:57.690
Well, what about 5 connected?

00:48:57.690 --> 00:48:59.940
Well, five connected,
you can also do.

00:48:59.940 --> 00:49:03.670
And this is an example
called the banana spider.

00:49:03.670 --> 00:49:05.400
Although it seems a
bit of a misnomer.

00:49:05.400 --> 00:49:07.710
It should be-- but I
guess banana spiders

00:49:07.710 --> 00:49:10.060
are actual object--
actual species.

00:49:10.060 --> 00:49:11.620
This really should
be a banana insect

00:49:11.620 --> 00:49:14.760
because this guy
has six legs, three

00:49:14.760 --> 00:49:16.640
on the left, three on the right.

00:49:16.640 --> 00:49:18.842
So if it is an
octahedron in the center,

00:49:18.842 --> 00:49:20.550
and then you add these
three connections,

00:49:20.550 --> 00:49:23.490
and you can actually prove
that any graph you have,

00:49:23.490 --> 00:49:27.480
any example that's maybe only
one or two or three connected,

00:49:27.480 --> 00:49:30.770
whatever, you can make it five
connected by whenever you have

00:49:30.770 --> 00:49:33.650
two four connected components--
or five things components

00:49:33.650 --> 00:49:37.800
I guess-- just add a spider
in the middle to bridge them,

00:49:37.800 --> 00:49:40.210
and it will be as
flexible as before.

00:49:40.210 --> 00:49:41.960
And it will still satisfy Laman.

00:49:41.960 --> 00:49:46.549
So five connectivity doesn't
buy you anything unfortunately.

00:49:46.549 --> 00:49:48.340
I guess you could ask
for six connectivity,

00:49:48.340 --> 00:49:51.840
but six connectivity,
I think, is impossible

00:49:51.840 --> 00:49:53.955
because you only have
3n minus 6 edges.

00:49:56.530 --> 00:49:58.220
That's the limit.

00:49:58.220 --> 00:50:01.070
So sadly, connectivity is not
the right-- doesn't buy us

00:50:01.070 --> 00:50:02.160
anything.

00:50:02.160 --> 00:50:09.160
And that's what we know about
vertex and bar structures in 3D

00:50:09.160 --> 00:50:09.800
sadly.

00:50:09.800 --> 00:50:11.990
Tough open problem.

00:50:11.990 --> 00:50:15.400
Any questions?

00:50:15.400 --> 00:50:17.900
That's it for today.

