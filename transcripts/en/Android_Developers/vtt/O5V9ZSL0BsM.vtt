WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.864
[MUSIC PLAYING]

00:00:07.184 --> 00:00:08.850
ESTEBAN DE LA CANAL:
My name is Esteban.

00:00:08.850 --> 00:00:12.770
I'm the lead of the
profilings in Android Studio,

00:00:12.770 --> 00:00:15.590
and today I'm going to show you
all the new features we have

00:00:15.590 --> 00:00:18.300
in Android Studio 3.2 and
some of the features that we

00:00:18.300 --> 00:00:21.880
launched in Android Studio
3.1 in the profilers.

00:00:25.480 --> 00:00:26.080
Right.

00:00:26.080 --> 00:00:29.710
So I'm going to be doing a
demo for most of the session,

00:00:29.710 --> 00:00:32.900
but just in case you haven't
seen the profilers before--

00:00:32.900 --> 00:00:36.490
just to get an idea, how many
of you have used the profilers?

00:00:36.490 --> 00:00:37.570
OK.

00:00:37.570 --> 00:00:39.820
That's great.

00:00:39.820 --> 00:00:41.320
Well, I was going
to explain that we

00:00:41.320 --> 00:00:44.410
have these profilers to you,
but most of you have seen them.

00:00:44.410 --> 00:00:45.880
But we have a new
profiler that I'm

00:00:45.880 --> 00:00:47.420
going to be introducing today.

00:00:47.420 --> 00:00:50.010
That is the energy profiler.

00:00:50.010 --> 00:00:51.610
As you know, we
have the monitors

00:00:51.610 --> 00:00:54.400
that show you light
telemetry from the app.

00:00:54.400 --> 00:01:00.070
We have the CPU network memory,
and the new energy profiler.

00:01:00.070 --> 00:01:03.520
And you can dive into any
of those, and, for example,

00:01:03.520 --> 00:01:05.319
inspect your
network request, see

00:01:05.319 --> 00:01:07.510
where you made a
request from code,

00:01:07.510 --> 00:01:10.930
see what you actually
downloaded, what was sent.

00:01:10.930 --> 00:01:14.230
You can also dive into
the memory profiler,

00:01:14.230 --> 00:01:16.000
see the breakdown
of the memory, see

00:01:16.000 --> 00:01:17.620
how many objects
you have allocated,

00:01:17.620 --> 00:01:20.710
where you allocated them.

00:01:20.710 --> 00:01:23.410
You can also dive
into the CPU profiler.

00:01:23.410 --> 00:01:26.080
I'm going to be showing you
some new cool features that we

00:01:26.080 --> 00:01:32.080
added there in 3.2,
specifically systrace.

00:01:32.080 --> 00:01:34.570
Again, I'm going to ask the
question, how many of you

00:01:34.570 --> 00:01:37.030
have used systrace before?

00:01:37.030 --> 00:01:37.940
OK.

00:01:37.940 --> 00:01:38.440
Cool.

00:01:38.440 --> 00:01:41.320
Now systrace is-- we
started with the first steps

00:01:41.320 --> 00:01:45.070
of integrating systrace into
the Android Studio CPU profiler.

00:01:45.070 --> 00:01:48.860
I'm going to be demoing
that in a few moments.

00:01:48.860 --> 00:01:52.390
And last but not least is
the new energy profiler

00:01:52.390 --> 00:01:57.250
that will guide you in
finding problems in your app

00:01:57.250 --> 00:02:02.290
that could lead to energy
profiling-- energy issues.

00:02:02.290 --> 00:02:05.210
I talk more about that at
the end of the session.

00:02:05.210 --> 00:02:07.120
And with that, that's it.

00:02:07.120 --> 00:02:08.820
That's all the
slides that I have.

00:02:08.820 --> 00:02:11.830
So I'm going to move
to the demo now.

00:02:11.830 --> 00:02:13.600
And I have to make a disclaimer.

00:02:13.600 --> 00:02:18.960
So all the features that I'm
going to be demoing today,

00:02:18.960 --> 00:02:21.900
I am Android Studio
3.2 Canary, and there

00:02:21.900 --> 00:02:25.200
is a reason why they are not
in the stable release yet.

00:02:25.200 --> 00:02:28.000
So we might be in
for a bumpy ride,

00:02:28.000 --> 00:02:31.267
but I wanted to show
you what we have.

00:02:31.267 --> 00:02:32.850
And you know, if it
crashes we'll just

00:02:32.850 --> 00:02:35.530
keep it between us and
people watching on YouTube

00:02:35.530 --> 00:02:37.560
and that's it.

00:02:37.560 --> 00:02:38.640
All right.

00:02:38.640 --> 00:02:42.673
So I wrote last
week this clock app.

00:02:42.673 --> 00:02:46.650
It's a simple clock
app that has the clock.

00:02:46.650 --> 00:02:51.910
It has a stopwatch that you can
click and it does something.

00:02:51.910 --> 00:02:54.040
And it has a timer.

00:02:54.040 --> 00:02:55.800
And I want to profile
it with you guys.

00:02:55.800 --> 00:03:00.240
So let's first start
with network profiler.

00:03:00.240 --> 00:03:04.320
So this app has a lot
of features that a clock

00:03:04.320 --> 00:03:05.950
app should not have.

00:03:05.950 --> 00:03:08.010
For example, it needs
internet access.

00:03:08.010 --> 00:03:09.859
It needs to access location.

00:03:09.859 --> 00:03:11.650
It has a lot of things
so we can demo this.

00:03:11.650 --> 00:03:15.600
So please do not write
the clock app like this.

00:03:15.600 --> 00:03:18.550
So one of the features it has is
you can change the background.

00:03:18.550 --> 00:03:23.070
So if the internet
connection is good enough,

00:03:23.070 --> 00:03:25.630
this thing is going to start
downloading some images right

00:03:25.630 --> 00:03:26.130
now.

00:03:26.130 --> 00:03:28.320
There we go.

00:03:28.320 --> 00:03:30.840
You can dive in into
the network profiler.

00:03:30.840 --> 00:03:32.910
You surely have
seen this before.

00:03:32.910 --> 00:03:36.730
And you can see all the network
requests that have been done.

00:03:36.730 --> 00:03:39.420
You can click on them and
see the actual payload.

00:03:39.420 --> 00:03:41.910
Something new that
was added in 3.1

00:03:41.910 --> 00:03:45.330
is the ability for us
to see what we send,

00:03:45.330 --> 00:03:46.830
not just what we
receive, but we can

00:03:46.830 --> 00:03:52.002
see the payload or the
custom headers that we use.

00:03:52.002 --> 00:03:53.585
In this case, I have
one custom header

00:03:53.585 --> 00:03:58.630
that says Google I/O. There
is another new feature in 3.1

00:03:58.630 --> 00:04:03.330
for the network profiler,
and that is the threads view.

00:04:03.330 --> 00:04:07.320
So as you see here, we
show you the request

00:04:07.320 --> 00:04:13.560
in a timeline, but if you choose
threads view, what you can see

00:04:13.560 --> 00:04:18.160
is on which thread--

00:04:18.160 --> 00:04:19.980
let me close this, so
we have more space.

00:04:19.980 --> 00:04:20.860
There we go.

00:04:20.860 --> 00:04:24.980
So you can see each request
on which thread it was made.

00:04:24.980 --> 00:04:28.200
And if we have more like this.

00:04:28.200 --> 00:04:30.510
I'm using a standard
asynchronous task, which

00:04:30.510 --> 00:04:33.845
uses a default executer that
will run them sequentially,

00:04:33.845 --> 00:04:34.720
and you can see them.

00:04:34.720 --> 00:04:35.970
And if they were
reusing the same thread,

00:04:35.970 --> 00:04:37.230
you can see them too.

00:04:37.230 --> 00:04:42.210
But if in your app, you have a
more complex threading request,

00:04:42.210 --> 00:04:45.400
you can use this view
to see what's going on.

00:04:45.400 --> 00:04:47.370
So those are the
two new features

00:04:47.370 --> 00:04:51.640
on the network profiler
that we've added in 3.1.

00:04:51.640 --> 00:04:55.190
And now I'm going to move
to the memory profiler.

00:04:55.190 --> 00:04:56.890
Let me go to the next session.

00:04:59.964 --> 00:05:01.380
If you have seen
this view before,

00:05:01.380 --> 00:05:02.800
we split up how
much memory you're

00:05:02.800 --> 00:05:04.710
using into different
components, but we also

00:05:04.710 --> 00:05:08.760
show you the number of
objects you have allocated.

00:05:08.760 --> 00:05:12.660
If you are profiling on an
Android or your phone or newer,

00:05:12.660 --> 00:05:13.450
we have--

00:05:13.450 --> 00:05:17.340
and this is super cool-- we have
a feature called live location

00:05:17.340 --> 00:05:18.270
tracking.

00:05:18.270 --> 00:05:21.120
Remember back in the day--
it was probably last year--

00:05:21.120 --> 00:05:23.670
when you had to do
a location tracking,

00:05:23.670 --> 00:05:26.984
you had to click on a button
to record the locations

00:05:26.984 --> 00:05:28.150
and then you would see them.

00:05:28.150 --> 00:05:30.630
Well, if we wanted to
know what happened here,

00:05:30.630 --> 00:05:33.020
we can see that the
object line going up,

00:05:33.020 --> 00:05:34.800
as being garbage
collector is going up,

00:05:34.800 --> 00:05:36.870
as being garbage collected.

00:05:36.870 --> 00:05:39.741
So if you want to see what's
happening, just select a range,

00:05:39.741 --> 00:05:42.240
and we will have the information
of every single object that

00:05:42.240 --> 00:05:46.150
was allocated there, at
which time it was allocated,

00:05:46.150 --> 00:05:49.180
and where in your code.

00:05:49.180 --> 00:05:50.350
It was allocated.

00:05:50.350 --> 00:05:51.960
And you can slide
this window and you

00:05:51.960 --> 00:05:53.620
can see this thing changing.

00:05:53.620 --> 00:05:56.290
So if I slide it over a
garbage collection period,

00:05:56.290 --> 00:05:59.650
you will see which
objects were deallocated

00:05:59.650 --> 00:06:00.720
Let me close this window.

00:06:04.030 --> 00:06:04.549
There we go.

00:06:04.549 --> 00:06:06.840
We can see that there was a
lot of strings deallocated.

00:06:06.840 --> 00:06:09.570
So we can start actually
having a look at this app

00:06:09.570 --> 00:06:13.710
and see how bad it is written.

00:06:13.710 --> 00:06:15.480
For example, if I
select this and I

00:06:15.480 --> 00:06:17.525
want to see what
was allocated, I

00:06:17.525 --> 00:06:19.650
can see that there were a
lot of strings allocated.

00:06:19.650 --> 00:06:23.190
I can click on any one of those
and see where I allocated them,

00:06:23.190 --> 00:06:25.620
and I allocated them
inside an onDraw.

00:06:25.620 --> 00:06:26.910
This is not a good idea.

00:06:26.910 --> 00:06:29.670
If you have a custom view and
you allocate a lot of strings

00:06:29.670 --> 00:06:33.260
there, bad things will happen.

00:06:33.260 --> 00:06:36.120
And we'll see more about that
through the CPU profiler.

00:06:36.120 --> 00:06:38.190
But this is already
starting to tell us

00:06:38.190 --> 00:06:42.900
signals about what my
app is doing wrong.

00:06:42.900 --> 00:06:46.380
Another new thing
that we added in 3.2

00:06:46.380 --> 00:06:50.994
is the ability to see
JNI global references.

00:06:50.994 --> 00:06:53.160
This is very important
because a lot of memory leaks

00:06:53.160 --> 00:06:55.771
occur because one JNI
global reference is created,

00:06:55.771 --> 00:06:58.020
and then we don't know when
we created it and we don't

00:06:58.020 --> 00:06:59.140
know where it is.

00:06:59.140 --> 00:07:03.660
So when you select a range,
what we have here in my app,

00:07:03.660 --> 00:07:06.610
every time I download an image,
I run a filter through it

00:07:06.610 --> 00:07:11.560
in C++ to darken it so
the font can be seen.

00:07:11.560 --> 00:07:14.030
And I have a global
reference there.

00:07:14.030 --> 00:07:16.350
And I hope I did it right.

00:07:16.350 --> 00:07:20.750
So we have a special heap,
which we call the JNI heap,

00:07:20.750 --> 00:07:22.860
but when you select
it, you can see

00:07:22.860 --> 00:07:27.810
all the global references that
existed in this range of time.

00:07:27.810 --> 00:07:29.520
In this case, I have
this entry, and I

00:07:29.520 --> 00:07:33.000
know I created one but
it should have been gone.

00:07:33.000 --> 00:07:36.290
So let me go live here
and select a range.

00:07:40.570 --> 00:07:41.610
And here it is.

00:07:41.610 --> 00:07:44.302
This is my global--

00:07:44.302 --> 00:07:46.010
this is every image
that I've downloaded.

00:07:46.010 --> 00:07:48.900
I'm still holding a JNI
global reference to it.

00:07:48.900 --> 00:07:52.940
And I can actually navigate
to the C++ line of code when I

00:07:52.940 --> 00:07:55.950
created that global
reference I never let go.

00:07:55.950 --> 00:07:59.340
So I hope this is useful
to track down problems

00:07:59.340 --> 00:08:02.810
with global references.

00:08:02.810 --> 00:08:06.420
And one more thing.

00:08:06.420 --> 00:08:09.420
You probably have been seeing
all the time on the left

00:08:09.420 --> 00:08:13.470
that we have a new panel
called the Sessions panel.

00:08:13.470 --> 00:08:16.560
Well, now we allow you
to see previous sessions

00:08:16.560 --> 00:08:18.900
that you have been profiled,
so you can navigate back

00:08:18.900 --> 00:08:20.070
and compare previous runs.

00:08:20.070 --> 00:08:21.540
If you're working on
optimizing your app,

00:08:21.540 --> 00:08:23.460
and say, what did I
change, you can go back

00:08:23.460 --> 00:08:24.390
and see through the sessions.

00:08:24.390 --> 00:08:26.250
Well, at the end of
the demo, hopefully we

00:08:26.250 --> 00:08:29.610
can go back and see what we
optimized and what happened.

00:08:29.610 --> 00:08:33.340
But that opened the door for
us to do things like this.

00:08:33.340 --> 00:08:36.059
Now we can import a file.

00:08:36.059 --> 00:08:39.210
I'm going to import a heap dump.

00:08:39.210 --> 00:08:41.539
And this heap dump is
being imported directly

00:08:41.539 --> 00:08:44.150
to the new profilers,
and it creates

00:08:44.150 --> 00:08:46.080
what we call a fixation
for it, and you

00:08:46.080 --> 00:08:47.880
can analyze the
heap dump as you're

00:08:47.880 --> 00:08:49.320
used to in the profilers.

00:08:49.320 --> 00:08:52.210
You can also import
traces for CPU.

00:08:52.210 --> 00:08:55.340
And everything we can
export, we can import too.

00:08:55.340 --> 00:09:01.780
So that's pretty handy
on-- this is new in 3.2.

00:09:01.780 --> 00:09:04.470
And this is what I wanted
to show for memory.

00:09:04.470 --> 00:09:07.436
And now we're going to go to
CPU and spend most of the time

00:09:07.436 --> 00:09:07.936
there.

00:09:10.768 --> 00:09:11.268
Right.

00:09:15.409 --> 00:09:16.450
This is the live session.

00:09:19.030 --> 00:09:22.480
And I'm going to show you
one feature that you have.

00:09:22.480 --> 00:09:23.140
All right.

00:09:23.140 --> 00:09:26.920
So one thing that
we wanted to add

00:09:26.920 --> 00:09:29.720
was the ability to profile
since the beginning.

00:09:29.720 --> 00:09:32.190
So if it is a profile,
you know this,

00:09:32.190 --> 00:09:33.940
and if you want to
profile your app start,

00:09:33.940 --> 00:09:37.060
you have to go to CPU profiler
and click record so you

00:09:37.060 --> 00:09:38.190
can see what's happening.

00:09:38.190 --> 00:09:45.440
Well, in 3.2, what you can do is
if you go to the Profiling tab,

00:09:45.440 --> 00:09:48.310
we have an option that
says start recording

00:09:48.310 --> 00:09:50.560
a method trace on startup.

00:09:50.560 --> 00:09:51.700
So I have this dex.

00:09:51.700 --> 00:09:54.190
You can choose the
configuration that you want.

00:09:54.190 --> 00:09:58.150
In this case, I'm going to use
a sample Java configuration,

00:09:58.150 --> 00:09:59.640
and I'm going to rerun the app.

00:10:03.532 --> 00:10:04.032
Cool.

00:10:08.424 --> 00:10:13.470
Now, you can see that
the app restarted.

00:10:13.470 --> 00:10:16.570
The profilers to me directly
to the CPU profiler,

00:10:16.570 --> 00:10:19.090
and there is already
a capture in progress

00:10:19.090 --> 00:10:20.560
from the very
beginning of the app.

00:10:20.560 --> 00:10:23.292
So I'm going to stop
it now, and we're

00:10:23.292 --> 00:10:25.000
going to investigate
what happened there.

00:10:27.650 --> 00:10:30.211
Let's take a few
seconds to get the data.

00:10:30.211 --> 00:10:30.710
Cool.

00:10:33.435 --> 00:10:35.810
I don't know if you can see
the resolution on the screen,

00:10:35.810 --> 00:10:41.450
but let's have a
look and see that.

00:10:41.450 --> 00:10:43.550
I'm going to select the
very beginning of the app.

00:10:43.550 --> 00:10:45.591
In fact, you can see that
the capture has started

00:10:45.591 --> 00:10:48.270
even before our telemetry
could start getting data

00:10:48.270 --> 00:10:50.280
from the app, right?

00:10:50.280 --> 00:10:52.730
Our telemetry started here,
but the app started before,

00:10:52.730 --> 00:10:54.320
and we can see the data.

00:10:54.320 --> 00:10:57.500
And if we keep
zooming in there, you

00:10:57.500 --> 00:11:02.240
can see the first onCreate
of my main activity.

00:11:02.240 --> 00:11:05.470
And even before that we
can see, one of the dexes

00:11:05.470 --> 00:11:07.710
were lowered at the very,
very beginning of your app.

00:11:07.710 --> 00:11:10.960
So with this mechanism you can
profile from the very beginning

00:11:10.960 --> 00:11:14.000
and optimize the startup
time of your app.

00:11:16.569 --> 00:11:18.110
But let's have a
look at this capture

00:11:18.110 --> 00:11:22.010
and see if those strings
we saw before are actually

00:11:22.010 --> 00:11:24.570
causing some problems.

00:11:24.570 --> 00:11:26.780
One of my favorite views
in the CPU profiler

00:11:26.780 --> 00:11:28.440
is the Flame chart.

00:11:28.440 --> 00:11:33.762
The Flame chart aggregates
all the call stacks

00:11:33.762 --> 00:11:34.970
that have the same beginning.

00:11:34.970 --> 00:11:37.130
So you can see it's
basically the top-down tree,

00:11:37.130 --> 00:11:38.810
but in a visual way.

00:11:38.810 --> 00:11:43.460
And you can see that one of the
biggest things is my onDraw.

00:11:43.460 --> 00:11:46.360
The way I roll this
out is on every frame

00:11:46.360 --> 00:11:48.200
I'm rendering everything again.

00:11:48.200 --> 00:11:49.620
That's not a good
way of doing it,

00:11:49.620 --> 00:11:52.620
but it's a really good
example for the profilers.

00:11:52.620 --> 00:11:55.010
So you can see
that I'm rendering,

00:11:55.010 --> 00:11:58.160
and there is a lot of
things at the top that have

00:11:58.160 --> 00:12:00.110
to do with string formatting.

00:12:00.110 --> 00:12:04.580
And this could be the
source of our string problem

00:12:04.580 --> 00:12:05.430
that we saw before.

00:12:05.430 --> 00:12:10.370
So it's another symptom that
your app is not doing well.

00:12:10.370 --> 00:12:15.740
One thing that I always say
about our profilers is that we

00:12:15.740 --> 00:12:18.020
cannot really tell you
what's wrong in your app.

00:12:18.020 --> 00:12:19.880
We can only tell you
what your app is doing,

00:12:19.880 --> 00:12:21.380
and then it's up
to you to say, oh,

00:12:21.380 --> 00:12:23.160
I didn't expect this to happen.

00:12:23.160 --> 00:12:26.930
Because as you can see, my app
looks fine, but under the hood

00:12:26.930 --> 00:12:27.750
it's not.

00:12:27.750 --> 00:12:31.505
So let's say you have a bug
on a label that you put wrong,

00:12:31.505 --> 00:12:32.880
and it's in a
different position.

00:12:32.880 --> 00:12:33.650
You're running your app.

00:12:33.650 --> 00:12:35.040
You see it there, and
say, oh, it's wrong.

00:12:35.040 --> 00:12:36.120
I need to fix this.

00:12:36.120 --> 00:12:38.780
But if you have something like
a performance issue wrong,

00:12:38.780 --> 00:12:39.680
you won't see it.

00:12:39.680 --> 00:12:42.820
You won't see it until even--
we'll talk about battery later,

00:12:42.820 --> 00:12:45.380
and you will see it
in the field, right?

00:12:45.380 --> 00:12:48.260
So we want our profilers to
be another window to your app,

00:12:48.260 --> 00:12:51.470
so that you can run your app
while seeing the profilers

00:12:51.470 --> 00:12:54.200
and then you see the problems
there because something

00:12:54.200 --> 00:12:56.420
that you did not expect
starts showing up,

00:12:56.420 --> 00:13:00.230
like me doing a lot of string
formatting inside an onDraw

00:13:00.230 --> 00:13:01.920
call.

00:13:01.920 --> 00:13:11.200
So let's go to the
code, where I have my--

00:13:11.200 --> 00:13:11.880
can you see?

00:13:11.880 --> 00:13:13.070
Yeah.

00:13:13.070 --> 00:13:17.450
So I have my onDraw, and I have
a function called drawtime,

00:13:17.450 --> 00:13:21.650
where I draw the
time on my app, and I

00:13:21.650 --> 00:13:25.040
have wrote a function
called drawTimeString

00:13:25.040 --> 00:13:27.350
that uses string formatting
to draw the time,

00:13:27.350 --> 00:13:29.490
and that is probably
not a good idea.

00:13:29.490 --> 00:13:31.820
So that's just a
single incident.

00:13:31.820 --> 00:13:34.210
I have another
function that writes--

00:13:34.210 --> 00:13:36.360
that draws the time
without using strings,

00:13:36.360 --> 00:13:37.647
and we're going to try it.

00:13:37.647 --> 00:13:39.230
Oh, before we do
that, let me show you

00:13:39.230 --> 00:13:40.410
one thing that we have here.

00:13:40.410 --> 00:13:43.030
So, how many of you are
familiar with this line

00:13:43.030 --> 00:13:45.003
of code, Trace.beginSection?

00:13:45.003 --> 00:13:46.010
Do a raise of hands.

00:13:46.010 --> 00:13:47.000
Cool.

00:13:47.000 --> 00:13:52.040
So what this line does,
together with the end section,

00:13:52.040 --> 00:13:53.780
they will create
a systrace event

00:13:53.780 --> 00:13:55.760
that you can use
systrace to see.

00:13:55.760 --> 00:13:58.400
So before I make
my optimization,

00:13:58.400 --> 00:14:04.170
I'm going to show
you what happens

00:14:04.170 --> 00:14:07.440
if I take a capture using
the system trace method.

00:14:10.600 --> 00:14:12.826
So this is running
systrace under the hood,

00:14:12.826 --> 00:14:14.700
and you don't have to
go to the Python script

00:14:14.700 --> 00:14:19.500
anymore and get it, and then
get it back on the HTML view.

00:14:19.500 --> 00:14:22.560
We will instead show
it to you right here

00:14:22.560 --> 00:14:26.340
in our app in Android studio.

00:14:26.340 --> 00:14:28.560
OK.

00:14:28.560 --> 00:14:31.650
Remember what I mentioned
about the bumpy ride?

00:14:31.650 --> 00:14:33.588
This is it.

00:14:33.588 --> 00:14:34.560
Oopsie.

00:14:34.560 --> 00:14:38.140
Let me restart the emulator,
and we'll will do it again.

00:14:41.486 --> 00:14:44.360
There we go.

00:14:44.360 --> 00:14:45.850
Please, please try this at home.

00:14:45.850 --> 00:14:48.370
File bugs, we will fix them.

00:14:48.370 --> 00:14:50.450
And when we get this
table, these issues

00:14:50.450 --> 00:14:51.440
will be all sorted out.

00:14:54.690 --> 00:14:56.820
There we go.

00:14:56.820 --> 00:14:59.960
I'm going to go to the CPU
profiler, and use system trace.

00:15:06.290 --> 00:15:07.310
Second time's the charm.

00:15:07.310 --> 00:15:08.390
OK.

00:15:08.390 --> 00:15:10.760
So we have system trace here.

00:15:10.760 --> 00:15:14.460
Let me select and zoom
into the selection.

00:15:14.460 --> 00:15:16.160
Cool.

00:15:16.160 --> 00:15:20.350
One thing that you notice
here, that first of all, we

00:15:20.350 --> 00:15:22.970
have a new section there
called the kernel section

00:15:22.970 --> 00:15:25.310
where we show you all the CPUs.

00:15:25.310 --> 00:15:28.490
And if you pay
close attention, we

00:15:28.490 --> 00:15:31.040
re-render all the
thread information,

00:15:31.040 --> 00:15:32.850
getting all the
data from systrace.

00:15:32.850 --> 00:15:36.530
So before there's
thread information,

00:15:36.530 --> 00:15:39.600
we get sampling the
prog file system.

00:15:39.600 --> 00:15:41.030
So it's not very accurate.

00:15:41.030 --> 00:15:43.220
But as soon as you take
a systrace capture,

00:15:43.220 --> 00:15:45.380
you can see exactly where--

00:15:45.380 --> 00:15:48.200
what your thread is
doing at every moment.

00:15:48.200 --> 00:15:50.720
And more than that, if
I select one of those,

00:15:50.720 --> 00:15:55.790
we highlight above on which CPU
your thread is being scheduled.

00:15:55.790 --> 00:15:58.040
So you can look at
thread contention

00:15:58.040 --> 00:16:02.300
or all those things that are
kicking you out of the CPU.

00:16:02.300 --> 00:16:03.980
There is a
fundamental difference

00:16:03.980 --> 00:16:06.980
in the way we show systrace
here with the way you see it

00:16:06.980 --> 00:16:08.780
in the HTML view.

00:16:08.780 --> 00:16:10.610
Here we focus on your app.

00:16:10.610 --> 00:16:15.380
So everything here that
is highlighted green,

00:16:15.380 --> 00:16:17.700
even the dark green
is just your app.

00:16:17.700 --> 00:16:19.520
You can still go and
see the other events

00:16:19.520 --> 00:16:23.330
and see what is taking CPU or
where you're being kicked out,

00:16:23.330 --> 00:16:24.421
but we focus on your app.

00:16:24.421 --> 00:16:25.920
We show you the
threads of your app,

00:16:25.920 --> 00:16:29.670
so you don't have to navigate
that gigantic HTML page.

00:16:29.670 --> 00:16:32.240
And we use all the other
things that you know about,

00:16:32.240 --> 00:16:33.230
all the other captures.

00:16:33.230 --> 00:16:36.140
We use them for systrace,
for example, Flame chart

00:16:36.140 --> 00:16:38.060
or a top-down view.

00:16:38.060 --> 00:16:42.130
So let me zoom in
the moment in time.

00:16:42.130 --> 00:16:45.740
There we can see our frames.

00:16:45.740 --> 00:16:47.306
So I have here--

00:16:47.306 --> 00:16:51.100
let me zoom in more and choose
actually my main thread.

00:16:51.100 --> 00:16:53.130
There we go.

00:16:53.130 --> 00:16:55.530
So we can see the
ChoreographerduFrame,

00:16:55.530 --> 00:17:01.830
and further down, we can see the
onDraw on my custom component,

00:17:01.830 --> 00:17:05.420
and we can see the draw time.

00:17:05.420 --> 00:17:08.230
Remember in the code-- let me go
back to the code and show you.

00:17:08.230 --> 00:17:11.569
In draw time, we
have clock draw time

00:17:11.569 --> 00:17:14.000
around the section
around my temp string,

00:17:14.000 --> 00:17:17.089
and you can see that I'm
rendering it three times, one

00:17:17.089 --> 00:17:19.220
for every section
of my app, and we

00:17:19.220 --> 00:17:22.400
can see how long each one
of those is taking, right?

00:17:22.400 --> 00:17:26.390
So I'm taking 38 milliseconds
to render a frame.

00:17:26.390 --> 00:17:29.160
If you want your app to run
that on 60 frames per second,

00:17:29.160 --> 00:17:32.940
you have to render under
17-ish milliseconds.

00:17:32.940 --> 00:17:35.190
Now, I'm way over that.

00:17:35.190 --> 00:17:39.290
In fact, one of my goals to draw
time is taking 11 milliseconds.

00:17:39.290 --> 00:17:41.520
So what I have is
not doing well.

00:17:41.520 --> 00:17:44.150
It looked OK, but imagine you
ship this and people complain.

00:17:44.150 --> 00:17:47.360
This is one of the things
that I was mentioning about.

00:17:47.360 --> 00:17:49.880
You look at your
app, but look at it

00:17:49.880 --> 00:17:53.180
through the profiler glass
to see if it's doing OK.

00:17:53.180 --> 00:17:58.030
Now let's optimize, and take
another systrace capture.

00:17:58.030 --> 00:18:02.506
I'm going to change the
implementation of draw time.

00:18:02.506 --> 00:18:03.880
Now instead of
using the strings,

00:18:03.880 --> 00:18:06.122
I'm using my custom formatting.

00:18:06.122 --> 00:18:07.580
Instead of using
the string format,

00:18:07.580 --> 00:18:09.227
I'm using my custom formatting.

00:18:09.227 --> 00:18:10.810
We'll run it again
with these changes,

00:18:10.810 --> 00:18:12.460
and we'll run it
through systrace

00:18:12.460 --> 00:18:14.498
and see how that
affected my app.

00:18:17.511 --> 00:18:18.010
Cool.

00:18:18.010 --> 00:18:19.930
There it is.

00:18:19.930 --> 00:18:23.640
When I go to CPU profiler,
systrace is chosen for me.

00:18:23.640 --> 00:18:25.231
And I'm starting a capture.

00:18:25.231 --> 00:18:26.980
Just a few seconds
should do because there

00:18:26.980 --> 00:18:30.257
are a lot of frames
that happen in there.

00:18:30.257 --> 00:18:31.340
Cool, and we have it here.

00:18:35.280 --> 00:18:36.970
Right.

00:18:36.970 --> 00:18:38.810
Main thread selected.

00:18:38.810 --> 00:18:40.180
Zoom into a specific frame.

00:18:40.180 --> 00:18:42.370
We have the ChoreographerduFrame
in the framework,

00:18:42.370 --> 00:18:45.050
and then it goes down
to the clock onDraw.

00:18:45.050 --> 00:18:49.300
And you cannot see any more
the draw time functions

00:18:49.300 --> 00:18:52.300
because they are tiny,
tiny specks down there,

00:18:52.300 --> 00:18:56.370
each one of them now
taking 71 microseconds,

00:18:56.370 --> 00:19:01.461
and the onDraw is
13 milliseconds now.

00:19:01.461 --> 00:19:01.960
Woo-hoo.

00:19:01.960 --> 00:19:03.160
So we did that.

00:19:03.160 --> 00:19:05.260
Now I'm still under
60 frames per seconds

00:19:05.260 --> 00:19:07.480
because my app is
bad in other places,

00:19:07.480 --> 00:19:11.360
but at least we
optimized one part of it.

00:19:11.360 --> 00:19:11.860
Cool.

00:19:11.860 --> 00:19:14.720
And that's systrace.

00:19:14.720 --> 00:19:17.730
And let me mention
again sessions.

00:19:17.730 --> 00:19:19.890
So remember I said, you
can go back and compare.

00:19:19.890 --> 00:19:22.420
Well, I have my previous
sessions here on the left,

00:19:22.420 --> 00:19:25.587
and we can see the previous
systrace run that we did.

00:19:25.587 --> 00:19:26.170
So here it is.

00:19:26.170 --> 00:19:28.660
I can select it again, and
look at the main thread

00:19:28.660 --> 00:19:31.600
and see how bad my time was.

00:19:31.600 --> 00:19:35.170
And then I go back to the
currently running session,

00:19:35.170 --> 00:19:36.380
and you can keep all of this.

00:19:36.380 --> 00:19:37.700
And of course, if
you right-click,

00:19:37.700 --> 00:19:39.730
you can export the trace
and send you on debug,

00:19:39.730 --> 00:19:43.720
or on a heap dump, you can
export these things right here

00:19:43.720 --> 00:19:45.350
from the Session panel.

00:19:45.350 --> 00:19:49.160
Well, let me click this.

00:19:49.160 --> 00:19:49.790
Right.

00:19:49.790 --> 00:19:52.970
And that's our--
twenty minutes-- that's

00:19:52.970 --> 00:19:55.760
our integration with systrace.

00:19:55.760 --> 00:20:00.930
So there is another way
of capturing CPU data.

00:20:00.930 --> 00:20:06.350
And that is through an
API in the debugger.

00:20:06.350 --> 00:20:07.980
Let me go to a line of code.

00:20:11.510 --> 00:20:12.860
Here it is.

00:20:12.860 --> 00:20:15.950
So I have my stopwatch,
and I'm going

00:20:15.950 --> 00:20:18.860
to change it so every time
that I start my stopwatch,

00:20:18.860 --> 00:20:21.470
I'm going to run
start method tracing,

00:20:21.470 --> 00:20:23.270
and every time
that I stop it, I'm

00:20:23.270 --> 00:20:26.150
going to stop method tracing.

00:20:26.150 --> 00:20:31.830
I need to import the debuggers,
and I'm going to rerun the app.

00:20:31.830 --> 00:20:36.710
Now before this,
once you run the API,

00:20:36.710 --> 00:20:38.480
you have to go and
fetch this file

00:20:38.480 --> 00:20:41.960
and open it in either any
of your favorite profilers

00:20:41.960 --> 00:20:44.300
that can open a trace file.

00:20:44.300 --> 00:20:47.030
But right now if I'm
in the CPU profiler

00:20:47.030 --> 00:20:51.920
and I use my stopwatch,
this is what happens.

00:20:51.920 --> 00:20:54.890
So now I'm taking a capture
and the studio profiler's

00:20:54.890 --> 00:20:56.960
detected that a capture's
been taking place,

00:20:56.960 --> 00:20:58.130
and we're showing you this.

00:20:58.130 --> 00:21:00.320
And when I stop it, I
don't need to go and fetch

00:21:00.320 --> 00:21:01.640
the file from anywhere.

00:21:01.640 --> 00:21:04.110
We pull it from the device
and we show it right there.

00:21:04.110 --> 00:21:07.820
So if I start and I stop,
and I start and I stop,

00:21:07.820 --> 00:21:08.686
all this captures.

00:21:08.686 --> 00:21:10.310
They're actually
overwriting each other

00:21:10.310 --> 00:21:12.040
because they use the
same filing device,

00:21:12.040 --> 00:21:15.180
or pulling it and
showing them on Studio.

00:21:15.180 --> 00:21:17.169
So that's super handy
when you want to profile

00:21:17.169 --> 00:21:18.210
exactly a moment in time.

00:21:22.294 --> 00:21:24.710
You can navigate to all of
them, and you can see them here

00:21:24.710 --> 00:21:27.440
in the Sessions panel.

00:21:27.440 --> 00:21:30.120
That's pretty cool.

00:21:30.120 --> 00:21:40.180
One more thing we added in 3.1,
another way of capturing CPU

00:21:40.180 --> 00:21:45.140
usage using the C++ sampling
tool called Simpleperf.

00:21:45.140 --> 00:21:48.960
If you go to the documentation
in androiddevelopers.com,

00:21:48.960 --> 00:21:51.230
you will find documentation
about Simpleperf.

00:21:51.230 --> 00:21:54.710
We have a version of Simpleperf
inside Android Studio and it

00:21:54.710 --> 00:21:58.670
allows you to sample C++ code
and see the entire call stack

00:21:58.670 --> 00:22:02.032
of your C++ program.

00:22:02.032 --> 00:22:04.240
I'm not going to demo that
because I don't have a lot

00:22:04.240 --> 00:22:06.951
of C++.

00:22:06.951 --> 00:22:07.450
Cool.

00:22:07.450 --> 00:22:10.380
So that's CPU profiling.

00:22:10.380 --> 00:22:14.950
And let me move to the
energy profiler now.

00:22:14.950 --> 00:22:18.350
So energy is tricky.

00:22:18.350 --> 00:22:21.100
Energy is tricky because there
are two main sources that

00:22:21.100 --> 00:22:23.270
use energy on your phone.

00:22:23.270 --> 00:22:24.562
Well, the screen is obviously--

00:22:24.562 --> 00:22:25.936
I'm not even
counting the screen.

00:22:25.936 --> 00:22:26.760
The screen is bad.

00:22:26.760 --> 00:22:29.747
It uses a lot of energy, but
the user is using the phone.

00:22:29.747 --> 00:22:31.330
So if you're using
a game, right, it's

00:22:31.330 --> 00:22:32.740
all the time using the screen.

00:22:32.740 --> 00:22:36.010
But the battery drain
problems usually

00:22:36.010 --> 00:22:38.980
happen when we use CPU or
network when the user is not

00:22:38.980 --> 00:22:41.410
aware of this, or maybe when
we as developers are not

00:22:41.410 --> 00:22:42.130
aware of this.

00:22:42.130 --> 00:22:45.960
So let me go live.

00:22:45.960 --> 00:22:49.790
I'm using a fair amount
of CPU on this app.

00:22:49.790 --> 00:22:54.610
And if I go into
the energy profiler,

00:22:54.610 --> 00:22:58.600
we classify this as a
light use of energy.

00:22:58.600 --> 00:23:01.300
We would show you here
things that-- this

00:23:01.300 --> 00:23:02.920
is a really good model, right?

00:23:02.920 --> 00:23:06.850
So we show things that represent
how much energy you would

00:23:06.850 --> 00:23:09.020
be using on a modern phone.

00:23:09.020 --> 00:23:11.020
I'm not refining how much
energy the emulator is

00:23:11.020 --> 00:23:15.510
using obviously, but
this is for us to see.

00:23:15.510 --> 00:23:17.354
OK, I'm doing well or
I'm not doing well.

00:23:17.354 --> 00:23:19.520
I'm going to show you some
things that show up here.

00:23:19.520 --> 00:23:22.870
But obviously the two big
factors are CPU and network.

00:23:22.870 --> 00:23:25.470
And it's not, you know--
the obvious thing is OK,

00:23:25.470 --> 00:23:28.620
just don't use CPU
and network, but how?

00:23:28.620 --> 00:23:31.240
Or why am I using
that in the field?

00:23:31.240 --> 00:23:34.000
And the problem is not
actually when we use it.

00:23:34.000 --> 00:23:36.590
The problem is that we
don't know we're using it.

00:23:36.590 --> 00:23:39.790
So let's say I have a wake
lock that runs run amok,

00:23:39.790 --> 00:23:42.880
and we don't know where it
is, and that's using CPU.

00:23:42.880 --> 00:23:46.030
Or I have an alarm that
I didn't set up correctly

00:23:46.030 --> 00:23:49.660
and that is waking my app, and
I'm making network requests.

00:23:49.660 --> 00:23:53.650
So it's not about
the actual energy.

00:23:53.650 --> 00:23:57.490
It's about all these things that
you could be doing incorrectly

00:23:57.490 --> 00:23:59.875
that could cause battery
drain in the long term.

00:23:59.875 --> 00:24:01.750
And this is part of what
I was saying before,

00:24:01.750 --> 00:24:03.957
that if you look at your
app, if you look at my app,

00:24:03.957 --> 00:24:04.915
it seems to be running.

00:24:04.915 --> 00:24:06.070
It seems to be fine.

00:24:06.070 --> 00:24:07.861
If I were to push this
up to the Play Store

00:24:07.861 --> 00:24:09.920
and you started
it on your phone,

00:24:09.920 --> 00:24:12.310
this is going to be the most
expensive, battery-speaking,

00:24:12.310 --> 00:24:14.650
clock you ever
have on your phone.

00:24:14.650 --> 00:24:16.300
I'm going to drain
your battery, right,

00:24:16.300 --> 00:24:18.008
and I don't know it
when I'm seeing this.

00:24:18.008 --> 00:24:20.110
So by looking at
the profilers, we

00:24:20.110 --> 00:24:24.370
can see that constantly
this is draining CPU,

00:24:24.370 --> 00:24:26.890
and we can start
investigating why.

00:24:26.890 --> 00:24:28.690
Like I said, the
common mistakes are

00:24:28.690 --> 00:24:31.750
I have a wake lock that I don't
release, or I have an alarm.

00:24:31.750 --> 00:24:34.210
So we wanted to give
you a window so you

00:24:34.210 --> 00:24:35.500
can see the things happening.

00:24:35.500 --> 00:24:37.666
The same way if you have a
label in the wrong place,

00:24:37.666 --> 00:24:39.970
you can see it, we
want to show you

00:24:39.970 --> 00:24:42.610
if you have an alarm
that you didn't cancel,

00:24:42.610 --> 00:24:44.510
or you have an alarm
in the wrong place,

00:24:44.510 --> 00:24:45.718
we're going to show you that.

00:24:45.718 --> 00:24:50.380
So let me show you this piece
of my app where I have a timer.

00:24:50.380 --> 00:24:56.340
So here, I can run let's
say a 10-second timer.

00:24:56.340 --> 00:24:59.240
And you can see the bottom
of the energy profiler,

00:24:59.240 --> 00:25:01.320
that there is a yellow
line that showed up.

00:25:01.320 --> 00:25:04.720
If I put the tool tip on it,
that's an alarm or a job.

00:25:04.720 --> 00:25:06.520
We show you both there.

00:25:06.520 --> 00:25:09.670
And you can see that
when the timer stopped,

00:25:09.670 --> 00:25:11.330
the alarm went away.

00:25:11.330 --> 00:25:14.920
And if I start the timer
again, again I have the alarm.

00:25:14.920 --> 00:25:16.840
And this, actually when
I was developing this,

00:25:16.840 --> 00:25:20.260
was useful for me to see,
OK, am I doing it right?

00:25:20.260 --> 00:25:22.960
When I stop the timer,
does my alarm go away?

00:25:22.960 --> 00:25:25.250
When I start it again,
do I call it back?

00:25:25.250 --> 00:25:28.240
So this allows you to see this.

00:25:28.240 --> 00:25:33.220
Please don't use alarms
for a timer on a clock.

00:25:33.220 --> 00:25:37.540
I also have a wake
lock on my stopwatch.

00:25:37.540 --> 00:25:40.030
Again, don't use wake
lock for a stopwatch.

00:25:40.030 --> 00:25:42.780
And you can see that when I
start it, I apply a wake lock,

00:25:42.780 --> 00:25:45.010
and when I stop it, I let it go.

00:25:45.010 --> 00:25:46.840
And I can see that
it is working fine.

00:25:46.840 --> 00:25:49.454
If the red line keeps
going, I have a bug, right?

00:25:49.454 --> 00:25:51.370
My app will look the
same, and I will ship it,

00:25:51.370 --> 00:25:52.600
and people will have
problems, but you

00:25:52.600 --> 00:25:54.850
can see it through this
window that-- whether it's

00:25:54.850 --> 00:25:56.410
fine or not.

00:25:56.410 --> 00:26:01.190
And we also track locations.

00:26:01.190 --> 00:26:03.455
So if you are acquiring
location like I'm doing now,

00:26:03.455 --> 00:26:05.080
we have this purple
line that shows you

00:26:05.080 --> 00:26:07.360
that your current location.

00:26:07.360 --> 00:26:09.310
The emulator has a
really handy feature

00:26:09.310 --> 00:26:14.710
that you can actually tell it
when to send a location event.

00:26:14.710 --> 00:26:19.610
So in our model, we show
you that that is actually

00:26:19.610 --> 00:26:22.460
using energy.

00:26:22.460 --> 00:26:25.150
And again, you can see it in the
purple bar, and if I stop it--

00:26:27.760 --> 00:26:30.580
there we go-- the
purple bar is gone.

00:26:30.580 --> 00:26:34.670
But more than that, as you
are used to in our profilers,

00:26:34.670 --> 00:26:38.410
we can select a range
and we can show you

00:26:38.410 --> 00:26:42.910
that you had an alarm, that
you had a location request.

00:26:42.910 --> 00:26:44.940
If I move back, we can
select the wake lock

00:26:44.940 --> 00:26:46.290
and I'll do it in a second.

00:26:46.290 --> 00:26:49.690
More than that, I
can show you where

00:26:49.690 --> 00:26:52.390
the location was acquired,
which kind of provider--

00:26:52.390 --> 00:26:54.820
I'm using a GPS provider,
so we can see that.

00:26:54.820 --> 00:26:57.480
We can see the interval times
that I chose when the code--

00:26:57.480 --> 00:26:59.800
I triggered it to have a
toggle location that happens

00:26:59.800 --> 00:27:01.900
when I click the button.

00:27:01.900 --> 00:27:06.970
And if I click on
the alarm, not only

00:27:06.970 --> 00:27:08.660
I can see when I set
it the first time,

00:27:08.660 --> 00:27:10.300
but when I reset it,
when I cancel it.

00:27:10.300 --> 00:27:13.030
So you can see all the
places in the code that

00:27:13.030 --> 00:27:16.990
was triggered so I can debug
problems when this is not

00:27:16.990 --> 00:27:18.640
happening correctly.

00:27:18.640 --> 00:27:22.415
Let me go back
and show you the--

00:27:22.415 --> 00:27:24.380
the wake lock, it's right there.

00:27:24.380 --> 00:27:25.000
I select.

00:27:25.000 --> 00:27:27.312
You can see the wake lock.

00:27:27.312 --> 00:27:29.020
And you can see every
time that I started

00:27:29.020 --> 00:27:32.967
and I stopped the stopwatch,
I was acquiring and releasing

00:27:32.967 --> 00:27:35.050
the wake lock, and you can
see all the call stacks

00:27:35.050 --> 00:27:36.670
for when that happened.

00:27:36.670 --> 00:27:37.960
So this is the power of this.

00:27:37.960 --> 00:27:40.970
This is not to say, OK,
you're using a lot of battery.

00:27:40.970 --> 00:27:41.470
Yeah.

00:27:41.470 --> 00:27:44.680
I'm again, I want to use
batteries, so it's fine.

00:27:44.680 --> 00:27:48.021
The power of this is so that
you can see that your app is

00:27:48.021 --> 00:27:49.270
doing what you think is doing.

00:27:49.270 --> 00:27:53.850
And if it's not, you
should go in and fix it.

00:27:53.850 --> 00:27:56.320
So.

00:27:56.320 --> 00:27:58.040
Cool.

00:27:58.040 --> 00:27:59.300
That's the energy profiler.

00:27:59.300 --> 00:28:01.730
Let me show you one more
thing that I want to show you.

00:28:04.740 --> 00:28:07.620
On the left, we have
the Sessions panel.

00:28:07.620 --> 00:28:11.860
And let's go back in time.

00:28:11.860 --> 00:28:16.750
I can stop the current
session like this.

00:28:16.750 --> 00:28:20.440
And then you can click
on older sessions,

00:28:20.440 --> 00:28:24.040
and we can start comparing
all the captures that we did,

00:28:24.040 --> 00:28:28.120
back from when I
started the talk here,

00:28:28.120 --> 00:28:29.890
and this was the
first time we ran it,

00:28:29.890 --> 00:28:33.340
and we keep all this information
until you restart Studio.

00:28:33.340 --> 00:28:35.650
So you can compare runs.

00:28:35.650 --> 00:28:38.460
And let me show
you the last thing,

00:28:38.460 --> 00:28:39.732
and I want to close with that.

00:28:39.732 --> 00:28:41.440
I'm going to close a
few minutes earlier.

00:28:44.900 --> 00:28:45.460
All right.

00:28:45.460 --> 00:28:49.020
Like I said before, I'm
rendering every frame.

00:28:49.020 --> 00:28:50.980
I'm doing something that
I should not be doing,

00:28:50.980 --> 00:28:53.110
that is I'm invalidating
the view all the time,

00:28:53.110 --> 00:28:55.644
and that is using a lot of CPU.

00:28:55.644 --> 00:28:57.460
So let's go back to
my activity where

00:28:57.460 --> 00:28:59.540
I have the code that does this.

00:28:59.540 --> 00:29:03.610
So I have my model that
I update every frame,

00:29:03.610 --> 00:29:06.070
and then I invalidate
all the time.

00:29:06.070 --> 00:29:09.340
My model has the ability to
know when it has changed,

00:29:09.340 --> 00:29:13.210
so I'm only going to
invalidate the canvas whenever

00:29:13.210 --> 00:29:15.430
something has changed.

00:29:15.430 --> 00:29:17.890
And we're going to see
the impact that that has

00:29:17.890 --> 00:29:21.460
on energy, CPU, and so forth.

00:29:21.460 --> 00:29:23.690
We're in the app again.

00:29:23.690 --> 00:29:24.190
There we go.

00:29:30.180 --> 00:29:33.030
You can see now that the energy
profiler most of the time

00:29:33.030 --> 00:29:33.990
now is below light.

00:29:33.990 --> 00:29:35.340
It was above medium before.

00:29:35.340 --> 00:29:37.920
We can compare it with
previous sessions.

00:29:37.920 --> 00:29:42.850
But of course when
I have to render,

00:29:42.850 --> 00:29:45.370
we can see that the energy
usage starts going up.

00:29:45.370 --> 00:29:50.217
This is because I'm
rerendering my view every time.

00:29:50.217 --> 00:29:51.550
And you can see the effect here.

00:29:51.550 --> 00:29:53.980
You can see it on the
memory profiler too,

00:29:53.980 --> 00:29:56.949
if I go back to the
memory profiler.

00:29:56.949 --> 00:29:59.240
Remember that line that was
going up, up, up, and being

00:29:59.240 --> 00:30:00.010
garbage-collected?

00:30:00.010 --> 00:30:00.626
That is gone.

00:30:00.626 --> 00:30:02.500
I do have some objects
that are being created

00:30:02.500 --> 00:30:06.280
and they will be claimed
later, like here,

00:30:06.280 --> 00:30:09.995
but it's not as it was before.

00:30:09.995 --> 00:30:11.420
Cool.

00:30:11.420 --> 00:30:17.000
And let me stop the demo
and go back to the slides.

00:30:20.600 --> 00:30:21.800
Thank you.

00:30:21.800 --> 00:30:28.150
[MUSIC PLAYING]

