WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.000
So now that you know what the SAT problem is,

00:00:03.000 --> 00:00:06.000
how do we actually show that SAT is NP-complete?

00:00:06.000 --> 00:00:11.000
So what was the main ideas that Cook and Levin used to prove this,

00:00:11.000 --> 00:00:14.000
because it still sounds quite difficult doesn't it?

00:00:14.000 --> 00:00:17.000
To show that SAT is NP-complete, what we basically have to show

00:00:17.000 --> 00:00:23.000
is that for any problem in NP there is a polynomial time reduction to SAT,

00:00:23.000 --> 00:00:26.000
and before we go into the details of this proof,

00:00:26.000 --> 00:00:31.000
I want to show you the 3 main ideas that are used to show this.

00:00:31.000 --> 00:00:34.000
So the first one is, well, it's not really an idea,

00:00:34.000 --> 00:00:38.000
it's the trivial definition of what it means that a problem lies in NP.

00:00:38.000 --> 00:00:40.000
If a problem lies in NP,

00:00:40.000 --> 00:00:45.000
that means it can be solved in polynomial time by a non-deterministic RAM.

00:00:45.000 --> 00:00:47.000
So why do we state this?

00:00:47.000 --> 00:00:49.000
Going back to the definition actually allows us

00:00:49.000 --> 00:00:52.000
to make a very useful observation,

00:00:52.000 --> 00:00:54.000
because if we can solve the problem in

00:00:54.000 --> 00:00:56.000
polynomial time on a non-deterministic RAM,

00:00:56.000 --> 00:01:00.000
then that means there must be some polynomial time algorithm.

00:01:00.000 --> 00:01:02.000
Of course, that algorithm is going to use if-better function

00:01:02.000 --> 00:01:05.000
because it's running on a non-deterministic RAM,

00:01:05.000 --> 00:01:08.000
but we know that if a problem is in NP,

00:01:08.000 --> 00:01:12.000
then even without explicitly having to come up with this algorithm,

00:01:12.000 --> 00:01:15.000
we know there must be one because otherwise this problem would not be in NP.

00:01:15.000 --> 00:01:17.000
Which brings us to the third point, and that is the

00:01:17.000 --> 00:01:19.000
main idea that Cook and Levin had,

00:01:19.000 --> 00:01:24.000
and that is instead of having to show that any problem

00:01:24.000 --> 00:01:28.000
in NP can be encoded as a Boolean formula,

00:01:28.000 --> 00:01:33.000
what they did is they showed that any algorithm

00:01:33.000 --> 00:01:35.000
can be encoded as a Boolean formula,

00:01:35.000 --> 00:01:38.000
because if you can show that, with certain constraints of course,

00:01:38.000 --> 00:01:41.000
but basically the idea is if you can show that any algorithm

00:01:41.000 --> 00:01:44.000
can be encoded as a Boolean formula,

00:01:44.000 --> 00:01:50.000
then you can also encode this polynomial time algorithm here as a Boolean formula,

00:01:50.000 --> 00:01:53.000
which can then be used to solve an NP-complete problem.

00:01:53.000 --> 00:01:55.000
So if you can encode any algorithm,

00:01:55.000 --> 00:01:59.000
then you can also encode any algorithm that will solve a problem in NP.

00:01:59.000 --> 00:02:01.000
And of course, we're going to go into the details,

00:02:01.000 --> 00:02:03.000
but that was their main observation.

00:02:03.000 --> 00:02:06.000
They showed that we should not look at the problems in NP,

00:02:06.000 --> 00:02:10.000
but we should actually look at the algorithms that solve those problems in NP,

00:02:10.000 --> 00:02:13.000
and we know there must always be such an algorithm because

00:02:13.000 --> 99:59:59.000
otherwise the problems wouldnâ€™t be in NP.

