WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:01:26.749
[MUSIC PLAYING]

00:01:39.790 --> 00:01:39.870
BRAD GREEN: Hi.

00:01:39.870 --> 00:01:41.000
Good morning, everyone.

00:01:41.000 --> 00:01:41.840
I'm Brad Green.

00:01:41.840 --> 00:01:45.230
I'm a director here at Google,
and I'm in charge of the

00:01:45.230 --> 00:01:47.110
AngularJS project.

00:01:47.110 --> 00:01:50.720
Today we're going to be talking
about the MEAN stack.

00:01:50.720 --> 00:01:52.770
This is a little bit different
than things I

00:01:52.770 --> 00:01:54.070
usually talk about.

00:01:54.070 --> 00:01:58.430
Angular is a client-side
templating framework.

00:01:58.430 --> 00:02:00.290
But it's not a full picture.

00:02:00.290 --> 00:02:03.290
It's only the part that runs
inside the browser.

00:02:03.290 --> 00:02:06.450
Today we're going to talk about
the other pieces that

00:02:06.450 --> 00:02:08.229
you might select as
the backend--

00:02:08.229 --> 00:02:10.830
the server pieces for
your application.

00:02:10.830 --> 00:02:16.570
Today I'm joined by Val Karpov
from MongoDB, Ward Bell from

00:02:16.570 --> 00:02:17.640
IdeaBlade--

00:02:17.640 --> 00:02:19.370
who's going to be talking
BreezeJS--

00:02:19.370 --> 00:02:22.020
and then Al Tsang
from StrongLoop.

00:02:22.020 --> 00:02:26.280
And we're going to start off
with Val, who coined the term

00:02:26.280 --> 00:02:31.170
the "MEAN" stack, and MEAN
standing for Mongo, Express,

00:02:31.170 --> 00:02:33.430
AngularJS, and Node.

00:02:33.430 --> 00:02:36.980
And Val, would you take us
through a little bit about the

00:02:36.980 --> 00:02:41.180
history of how you came to pick
the stack and why you

00:02:41.180 --> 00:02:43.565
thought it was a great idea?

00:02:43.565 --> 00:02:44.010
VALERI KARPOV: Absolutely.

00:02:44.010 --> 00:02:45.960
Thanks, Brad.

00:02:45.960 --> 00:02:48.145
Let me just pull up my slide.

00:02:54.680 --> 00:02:55.470
Cool.

00:02:55.470 --> 00:02:56.170
So hi, guys.

00:02:56.170 --> 00:02:57.670
My name is Valeri Karpov.

00:02:57.670 --> 00:03:00.580
I'm currently a Kernel Tools
engineer at MongoDB.

00:03:00.580 --> 00:03:03.120
And I am the one who originally
coined the MEAN

00:03:03.120 --> 00:03:06.215
stack in a blog post on
the official MongoDB

00:03:06.215 --> 00:03:08.860
blog back in May.

00:03:08.860 --> 00:03:10.900
Here are some links to some of
my other stuff if you're

00:03:10.900 --> 00:03:13.000
interested in reading more
about the MEAN stack.

00:03:13.000 --> 00:03:15.500
But let's get started.

00:03:15.500 --> 00:03:17.780
So a little bit more about me,
just so you all don't think

00:03:17.780 --> 00:03:19.710
I'm some random guy
on the internet--

00:03:19.710 --> 00:03:21.190
little bit of my back story.

00:03:21.190 --> 00:03:25.050
I was originally the CTO of
SCVNGR, now known as LevelUp.

00:03:25.050 --> 00:03:27.460
I've been using AngularJS
for a very long time--

00:03:27.460 --> 00:03:29.370
since 2010--

00:03:29.370 --> 00:03:32.010
mostly because I follow Misko
Hevery who originally wrote

00:03:32.010 --> 00:03:34.260
the library [INAUDIBLE] working
very closely because I

00:03:34.260 --> 00:03:37.720
was an intern under
him in 2009.

00:03:37.720 --> 00:03:41.840
I got started using the MEAN
stack when I was working on

00:03:41.840 --> 00:03:45.130
the Ascot Project, which was
a fashion tech startup that

00:03:45.130 --> 00:03:47.390
we'll be talking about
a little bit later.

00:03:47.390 --> 00:03:49.540
And that startup has
since folded.

00:03:49.540 --> 00:03:54.370
I'm currently working for
MongoDB on an internal

00:03:54.370 --> 00:03:57.280
continuous integration
project.

00:03:57.280 --> 00:03:59.730
So what are we going to
be talking about?

00:03:59.730 --> 00:04:03.010
The talk will be about basically
why my team first

00:04:03.010 --> 00:04:05.990
started using the MEAN stack for
Ascot Project and why we

00:04:05.990 --> 00:04:09.100
ditched Ruby on Rails, why the
MEAN stack is great for

00:04:09.100 --> 00:04:12.430
prototyping, and how the MEAN
stack makes automated testing

00:04:12.430 --> 00:04:14.430
super easy.

00:04:14.430 --> 00:04:19.149
So as Brad mentioned, the MEAN
stacks for MongoDB, ExpressJS,

00:04:19.149 --> 00:04:20.769
AngularJS, and NodeJS.

00:04:20.769 --> 00:04:24.090
A little bit more about each of
the individual components.

00:04:24.090 --> 00:04:26.300
MongoDB is a document
database.

00:04:26.300 --> 00:04:31.030
It's to bridge the gap between
a document store like Redis

00:04:31.030 --> 00:04:34.260
and a database like your
standard mySQL.

00:04:34.260 --> 00:04:37.810
We want to get you the
performance and ease of use of

00:04:37.810 --> 00:04:40.330
a document store with
the rich feature

00:04:40.330 --> 00:04:42.640
set of an SQL database.

00:04:42.640 --> 00:04:46.030
So you can do things like build
indices, use a rich

00:04:46.030 --> 00:04:48.930
query language, and
do aggregation.

00:04:48.930 --> 00:04:53.450
But what you're storing is
essentially objects.

00:04:53.450 --> 00:04:56.000
You're not trying to fit
things into columns.

00:04:56.000 --> 00:04:59.870
You're just storing what is
semantically a J file.

00:04:59.870 --> 00:05:03.280
ExpressJS is a light web
framework on top of NodeJS

00:05:03.280 --> 00:05:06.750
that gives you a bunch of helper
methods to write out

00:05:06.750 --> 00:05:11.300
routes and do MVC on the server
without obscuring the

00:05:11.300 --> 00:05:13.800
things that make NodeJS
particularly awesome.

00:05:13.800 --> 00:05:14.710
AngularJS--

00:05:14.710 --> 00:05:16.500
you probably have heard
a lot about it.

00:05:16.500 --> 00:05:19.300
I like to describe it as
basically a magical library

00:05:19.300 --> 00:05:22.640
that makes everything
client-side super easy.

00:05:22.640 --> 00:05:26.820
And NodeJS is an event-driven
IO framework for JavaScript

00:05:26.820 --> 00:05:29.030
that runs on the server side.

00:05:29.030 --> 00:05:30.960
Essentially letting
you write a very

00:05:30.960 --> 00:05:34.310
concurrent server very easily.

00:05:34.310 --> 00:05:37.120
So the origins about
the MEAN stack--

00:05:37.120 --> 00:05:40.960
the team that I was working on
Ascot Project with was my team

00:05:40.960 --> 00:05:45.620
from TigerLabs which is an
incubator program from 2012.

00:05:45.620 --> 00:05:47.960
We're working on a project
called TonightLife.

00:05:47.960 --> 00:05:50.540
Now, TonightLife was essentially
an events

00:05:50.540 --> 00:05:53.220
aggregation framework that
basically showed you cool

00:05:53.220 --> 00:05:55.290
events that were coming
up in your area hand

00:05:55.290 --> 00:05:57.420
curated by our team.

00:05:57.420 --> 00:06:00.740
We had an AngularJS client for
the web, and then we had our

00:06:00.740 --> 00:06:03.450
iOS and Android clients
as well.

00:06:03.450 --> 00:06:07.700
The Rails backend and the
combination of Angular, iOS,

00:06:07.700 --> 00:06:10.810
and Android was not particularly
the best way of

00:06:10.810 --> 00:06:11.840
doing this.

00:06:11.840 --> 00:06:14.820
We had too many testing tools
and no way of sort of

00:06:14.820 --> 00:06:16.920
integrating all of
them together.

00:06:16.920 --> 00:06:20.720
So we had a little bit of unit
testing on the server.

00:06:20.720 --> 00:06:24.270
We had some unit testing for
Android and iOS clients--

00:06:24.270 --> 00:06:26.850
no real unit testing
for Angular.

00:06:26.850 --> 00:06:30.060
So all these testing tools
ended up being a mess.

00:06:30.060 --> 00:06:32.270
We couldn't test
the integration

00:06:32.270 --> 00:06:33.870
between all these tools.

00:06:33.870 --> 00:06:38.340
We also had a lot of different
HTTP requests going on.

00:06:38.340 --> 00:06:41.460
Every time somebody hit a
route, we would often be

00:06:41.460 --> 00:06:45.090
hitting the Facebook API three,
four, five times.

00:06:45.090 --> 00:06:47.880
And in order to get that to work
fast, we would have to

00:06:47.880 --> 00:06:50.820
make these HTTP requests concur,
basically running at

00:06:50.820 --> 00:06:52.910
the same time instead of
blocking the server

00:06:52.910 --> 00:06:54.380
while they were out.

00:06:54.380 --> 00:06:58.860
But when you start introducing
threads in Rails, or in any

00:06:58.860 --> 00:07:02.260
other language, you introduce
extra complexity and you

00:07:02.260 --> 00:07:04.340
introduce a lot of
room for bugs.

00:07:04.340 --> 00:07:09.340
And we ended up running into
a lot of odd-race missions.

00:07:09.340 --> 00:07:12.220
And finally, debugging database
interactions was a

00:07:12.220 --> 00:07:13.470
bit of a pain.

00:07:16.470 --> 00:07:19.970
We were using ActiveRecord,
which is an ORM--

00:07:19.970 --> 00:07:21.740
Object Relational Model--

00:07:21.740 --> 00:07:24.770
that took the objects that we
were working with on the

00:07:24.770 --> 00:07:29.140
server side and converted them
into a bunch of SQL feeds.

00:07:29.140 --> 00:07:33.560
Now, the ORM did its own magic,
so we were not able to

00:07:33.560 --> 00:07:37.710
see objects on the client side,
and we couldn't really

00:07:37.710 --> 00:07:42.280
see how they would look to the
server and how they would look

00:07:42.280 --> 00:07:45.220
in the database after the
ORM was done with it.

00:07:45.220 --> 00:07:48.240
And all of this added up to
us having about 2 and 1/2

00:07:48.240 --> 00:07:50.910
developers and five different
languages--

00:07:50.910 --> 00:07:54.800
SQL, Ruby, Objective-C, Android,
and JavaScript--

00:07:54.800 --> 00:07:58.250
that we had sort of juggle
in order to get

00:07:58.250 --> 00:07:59.850
our product to work.

00:07:59.850 --> 00:08:03.260
So when we decided to fold
TonightLife, we decided that

00:08:03.260 --> 00:08:06.570
we needed something different
for our next project.

00:08:06.570 --> 00:08:09.090
And that's where the Ascot
Project came in.

00:08:09.090 --> 00:08:12.170
We decided that, for the
purposes of building out a

00:08:12.170 --> 00:08:16.420
clean, simple product that would
work always, we wanted

00:08:16.420 --> 00:08:20.930
to basically build it in one
day and go to AngelHack in

00:08:20.930 --> 00:08:25.730
Washington, DC, in
November 2012.

00:08:25.730 --> 00:08:31.160
For that, we settled on the
MEAN stack minus Angular.

00:08:31.160 --> 00:08:33.179
Part of the reasons behind that
is, one, we wanted to

00:08:33.179 --> 00:08:35.030
have a very simple data model.

00:08:35.030 --> 00:08:39.679
So Ascot Project's business was
essentially being able to

00:08:39.679 --> 00:08:42.990
tag product information
in images.

00:08:42.990 --> 00:08:46.970
You would have this overlay that
would show you where this

00:08:46.970 --> 00:08:49.670
product was the picture and
where you could buy it.

00:08:49.670 --> 00:08:51.615
And then we convert a
billion [INAUDIBLE]

00:08:51.615 --> 00:08:54.620
from the [INAUDIBLE].

00:08:54.620 --> 00:08:57.740
Now, with MongoDB, we could
easily store this all at one

00:08:57.740 --> 00:09:01.020
collection as opposed to having
separate tables for

00:09:01.020 --> 00:09:06.160
tags and for products and for
images, which made our lives a

00:09:06.160 --> 00:09:07.790
lot easier.

00:09:07.790 --> 00:09:09.780
Also, we could do
parallelization much more

00:09:09.780 --> 00:09:13.270
effectively with NodeJS simply
because NodeJS is

00:09:13.270 --> 00:09:14.560
event-driven.

00:09:14.560 --> 00:09:17.740
It's all through callbacks.

00:09:17.740 --> 00:09:20.177
So we didn't have to
write any threads.

00:09:20.177 --> 00:09:24.130
And on the backend, every time
you saved an image, what we

00:09:24.130 --> 00:09:29.420
would do is we would basically
ping out an HTTP request to

00:09:29.420 --> 00:09:32.610
several different affiliate link
providers and sort of get

00:09:32.610 --> 00:09:35.600
ourselves the best affiliate
link for the particular

00:09:35.600 --> 00:09:36.770
[INAUDIBLE].

00:09:36.770 --> 00:09:41.720
Originally, we decided to go
without AngularJS because we

00:09:41.720 --> 00:09:44.050
had some trouble with it
previously when we were

00:09:44.050 --> 00:09:47.220
working on version 0.9.19--

00:09:47.220 --> 00:09:50.140
was the one that we were
using for TonightLife.

00:09:50.140 --> 00:09:53.142
So we wrote the tagger in
jQuery, and that turned out to

00:09:53.142 --> 00:09:55.720
be a terrible, terrible,
terrible idea.

00:09:55.720 --> 00:09:59.070
We had about 800 lines of
spaghetti code in jQuery that

00:09:59.070 --> 00:10:01.200
we would never be able
to maintain.

00:10:01.200 --> 00:10:03.660
So we rewrote in Angular.

00:10:03.660 --> 00:10:06.180
It ended up being about
only 80 lines of code.

00:10:06.180 --> 00:10:08.380
And we had 100% test
coverage--

00:10:08.380 --> 00:10:12.830
or unit test coverage-- on it,
which was absolutely perfect.

00:10:12.830 --> 00:10:17.590
So the philosophy of the MEAN
stack and what we believe that

00:10:17.590 --> 00:10:19.660
this stack should be able
to help you do.

00:10:19.660 --> 00:10:23.730
Ideally, any web stack should
help you prototype--

00:10:23.730 --> 00:10:26.780
be able to build your product as
fast as possible and get it

00:10:26.780 --> 00:10:28.710
out there into the hands
of your users.

00:10:28.710 --> 00:10:32.000
Should be able to test it
automatically so that you

00:10:32.000 --> 00:10:36.100
never push legitimately broken
code through-- product will

00:10:36.100 --> 00:10:39.400
probably always work
as advertised.

00:10:39.400 --> 00:10:40.500
And adapt--

00:10:40.500 --> 00:10:43.580
you want to be able to change
quickly, iterate on feedback,

00:10:43.580 --> 00:10:46.120
and make your product awesome
for your users.

00:10:46.120 --> 00:10:47.220
And then you want the scale.

00:10:47.220 --> 00:10:52.940
You want to make sure that you
can both add more machines to

00:10:52.940 --> 00:10:56.800
your server deployment easily
and be able to utilize the

00:10:56.800 --> 00:10:59.420
resources that you
have as well.

00:10:59.420 --> 00:11:01.610
Now what we're going to talk
about in this talk is only the

00:11:01.610 --> 00:11:03.040
first two steps.

00:11:03.040 --> 00:11:06.350
Because the other two steps will
require a separate talk

00:11:06.350 --> 00:11:07.850
all in themselves.

00:11:07.850 --> 00:11:10.760
But we're going to talk about
how you can build--

00:11:10.760 --> 00:11:14.280
what the MEAN stack gives you
to enable you to build a

00:11:14.280 --> 00:11:16.900
usable product very,
very fast.

00:11:16.900 --> 00:11:20.060
And then how you can also test
that product so your users

00:11:20.060 --> 00:11:21.660
never see your code break.

00:11:21.660 --> 00:11:25.150
I will sum this up as, build
fast and don't break things--

00:11:25.150 --> 00:11:28.420
sort of the opposite of the
Facebook philosophy of build

00:11:28.420 --> 00:11:29.850
fast and break things.

00:11:29.850 --> 00:11:32.060
Works well for Facebook because
they have a lot of

00:11:32.060 --> 00:11:34.350
users, and everybody uses them,
despite the face that

00:11:34.350 --> 00:11:37.380
their code is broken
quite often.

00:11:37.380 --> 00:11:40.590
As a small startup, I don't
believe that you can afford--

00:11:40.590 --> 00:11:45.080
or as a small new app that
you're trying to get people

00:11:45.080 --> 00:11:47.300
within your workplace to use.

00:11:47.300 --> 00:11:50.830
You don't want to ship broken
code because you're losing

00:11:50.830 --> 00:11:53.230
your users' faith
in your product.

00:11:53.230 --> 00:11:55.950
And every time something breaks
when it shouldn't, that

00:11:55.950 --> 00:11:57.360
just means people are
less likely to

00:11:57.360 --> 00:11:59.140
be using your product.

00:11:59.140 --> 00:12:03.890
So let's talk about what enables
you to build fast with

00:12:03.890 --> 00:12:05.160
the MEAN stack.

00:12:05.160 --> 00:12:08.800
one, it's super easy to set up
on Windows OSX and Linux.

00:12:08.800 --> 00:12:11.990
You can check out subguide
on my blog.

00:12:11.990 --> 00:12:14.690
All you need to do is install
NodeJS and MongoDB.

00:12:14.690 --> 00:12:18.950
And again, I will put this up
SlideShare after this talk, so

00:12:18.950 --> 00:12:21.570
don't worry too much about
having to click that link

00:12:21.570 --> 00:12:22.810
immediately.

00:12:22.810 --> 00:12:25.620
But one of the problems that we
had with Rails is, I don't

00:12:25.620 --> 00:12:28.415
know if you guys ever managed
to successfully set up Rails

00:12:28.415 --> 00:12:32.060
on Ubuntu, but I spent several
hours one afternoon last

00:12:32.060 --> 00:12:33.400
summer doing that.

00:12:33.400 --> 00:12:36.700
And I still could never
get it to work.

00:12:36.700 --> 00:12:39.480
So thankfully, I
punted on that.

00:12:39.480 --> 00:12:43.730
And now I get work done on my
Windows 8 machine, on my

00:12:43.730 --> 00:12:46.590
MacBook, and on my multiple
Linux servers.

00:12:46.590 --> 00:12:49.150
It works as advertised
on all of them.

00:12:51.720 --> 00:12:54.670
The other big advantage of the
MEAN stack is, Since you're

00:12:54.670 --> 00:12:57.330
writing the same language,
you're storing the same

00:12:57.330 --> 00:12:59.620
objects on all levels.

00:12:59.620 --> 00:13:04.430
Now, the dream with NodeJS was
the ability to basically write

00:13:04.430 --> 00:13:05.840
your server in the
same language as

00:13:05.840 --> 00:13:07.340
you write your clients.

00:13:07.340 --> 00:13:12.980
MongoDB adds and sort of
completes that promise.

00:13:12.980 --> 00:13:16.200
And it enables you to store
what are semantically JSON

00:13:16.200 --> 00:13:21.470
objects into your database and
then query using JSON as well.

00:13:21.470 --> 00:13:25.820
So here's a simple example
of how this looks.

00:13:25.820 --> 00:13:29.670
This is the MEAN stack
to do repo on GitHub.

00:13:29.670 --> 00:13:33.530
I will post a link that
in a later slide.

00:13:33.530 --> 00:13:37.980
The UI essentially allows you
to create a task or to-do

00:13:37.980 --> 00:13:42.310
similar to what you would
in your Gmail.

00:13:42.310 --> 00:13:45.460
So we're going to say I want to
finish my MEAN stack talk,

00:13:45.460 --> 00:13:48.680
and it's due on October
3, which is today.

00:13:48.680 --> 00:13:50.200
And so Angular--

00:13:50.200 --> 00:13:52.100
if you're not entirely
familiar with

00:13:52.100 --> 00:13:54.820
how AngularJS works--

00:13:54.820 --> 00:13:58.565
the one feature that basically
makes it as magical as it is

00:13:58.565 --> 00:14:01.730
is called two-way data bind.

00:14:01.730 --> 00:14:05.770
Two-way data binding gives you
the ability to declare an HTML

00:14:05.770 --> 00:14:09.410
element and would then attribute
to the HTML element.

00:14:09.410 --> 00:14:15.250
Say that the contents of this
particular element should be

00:14:15.250 --> 00:14:18.370
tied to this particular
JavaScript variable.

00:14:18.370 --> 00:14:20.860
So when the JavaScript variable
changes, the contents

00:14:20.860 --> 00:14:22.620
of the HTML element change.

00:14:22.620 --> 00:14:25.660
And when the contents of the
HTML element change, like this

00:14:25.660 --> 00:14:32.350
text area that you see on your
screen, the JavaScript

00:14:32.350 --> 00:14:35.500
variable will change to reflect
the new value as

00:14:35.500 --> 00:14:37.360
entered by the user.

00:14:37.360 --> 00:14:40.210
So here I just typed in, "Finish
MEAN stack talk,"

00:14:40.210 --> 00:14:44.850
clicked on October 3, and my
JSON object has changed to

00:14:44.850 --> 00:14:49.330
reflect this particular
state of affairs.

00:14:49.330 --> 00:14:54.540
So I have a new to-do-- finish
MEAN stack talk, October 3.

00:14:54.540 --> 00:14:58.070
And this dynamic template will
be passed, as is, down to the

00:14:58.070 --> 00:15:00.710
database, as we'll see
in the next slide.

00:15:00.710 --> 00:15:03.460
So this is some output
from NodeJS.

00:15:03.460 --> 00:15:05.700
I've started my Node app
I'm going to get

00:15:05.700 --> 00:15:07.440
from the command line.

00:15:07.440 --> 00:15:13.570
And when I click be the Add
button in the previous view, I

00:15:13.570 --> 00:15:17.960
do a post to todo.json, and
this is the output.

00:15:17.960 --> 00:15:20.600
This is some logging output that
shows you the JSON object

00:15:20.600 --> 00:15:22.700
that I get on the server side.

00:15:22.700 --> 00:15:25.720
And as you can see, the server
has pretty much the same view

00:15:25.720 --> 00:15:28.820
of the object as
the client did.

00:15:28.820 --> 00:15:30.510
Basically this JSON--

00:15:30.510 --> 00:15:34.260
the same yields with the
addition of an underscore ID

00:15:34.260 --> 00:15:37.380
field for the convenience of
MongoDB in order to be able to

00:15:37.380 --> 00:15:39.160
index on that.

00:15:39.160 --> 00:15:43.790
And then, when we save over to
MongoDB, we can pull up the

00:15:43.790 --> 00:15:46.950
MongoDB shell, which is actually
legitimately--

00:15:46.950 --> 00:15:49.190
you interface with the shell
using JavaScript.

00:15:49.190 --> 00:15:52.950
And MongoDB stores what is
technically a superset of

00:15:52.950 --> 00:15:55.420
JSON, but when you're dealing
with JavaScript,

00:15:55.420 --> 00:15:57.630
it is exactly JSON.

00:15:57.630 --> 00:16:03.460
So the MongoDB shell will show
us the exact same object as we

00:16:03.460 --> 00:16:06.440
saw on the client with the
addition of an ID and a

00:16:06.440 --> 00:16:10.070
double-underscore V, which is
a version number that the

00:16:10.070 --> 00:16:13.640
NodeJS layer occasionally
adds.

00:16:13.640 --> 00:16:17.480
With MongoDB's dynamic schema,
basically with MongoDB, you

00:16:17.480 --> 00:16:21.740
can store anything into
any table or any

00:16:21.740 --> 00:16:22.960
collection that you want.

00:16:22.960 --> 00:16:23.870
MongoDB calls it--

00:16:23.870 --> 00:16:27.380
the equivalent of an SQL
table as a corruption.

00:16:27.380 --> 00:16:28.760
There's no need for rake.

00:16:28.760 --> 00:16:31.970
All you would need to do to be
able to insert a different

00:16:31.970 --> 00:16:34.520
type of object is,
well, nothing.

00:16:34.520 --> 00:16:40.810
You could wipe your collection
and then start putting in new

00:16:40.810 --> 00:16:43.130
types of objects.

00:16:43.130 --> 00:16:46.020
But you don't necessarily
have to.

00:16:46.020 --> 00:16:49.330
So what is the advantage
of this?

00:16:49.330 --> 00:16:52.100
Unless you're doing server-side
validation, you

00:16:52.100 --> 00:16:57.450
only need to change your HTML
to store different data, or

00:16:57.450 --> 00:17:00.680
different data types,
in your database.

00:17:00.680 --> 00:17:03.540
So if you're going to build
something very fast, and you

00:17:03.540 --> 00:17:06.869
don't necessarily care about
doing things like making sure

00:17:06.869 --> 00:17:09.319
that the data being inserted
is correct because the only

00:17:09.319 --> 00:17:11.740
people that are going to use
data are you and your handful

00:17:11.740 --> 00:17:15.460
of selected testers, you don't
necessarily want to waste the

00:17:15.460 --> 00:17:20.930
time trying to say, OK, let me
say this column is going to be

00:17:20.930 --> 00:17:23.170
a 32-bit integer.

00:17:23.170 --> 00:17:24.690
No, it's just a waste.

00:17:24.690 --> 00:17:27.690
I want to be able to say, OK,
input type equals number.

00:17:27.690 --> 00:17:30.270
Let me add another input
type equals number.

00:17:30.270 --> 00:17:32.560
That represents a
different field.

00:17:32.560 --> 00:17:36.060
And all of that is going to
passed the server and to the

00:17:36.060 --> 00:17:37.830
database as is.

00:17:37.830 --> 00:17:42.510
This makes it very, very easy to
write a usable product very

00:17:42.510 --> 00:17:48.330
fast and then add service-line
validation and sanity checks

00:17:48.330 --> 00:17:50.460
and correctness checks later.

00:17:50.460 --> 00:17:55.840
It's also easy to debug because
your database is going

00:17:55.840 --> 00:17:59.180
to look exactly the same as
what your client sees.

00:17:59.180 --> 00:18:01.065
So you don't have to worry about
mentally translating,

00:18:01.065 --> 00:18:04.110
OK, this is how my object
looks in JSON.

00:18:04.110 --> 00:18:07.760
This is how it's going to look
in the database in all of

00:18:07.760 --> 00:18:09.190
these different columns.

00:18:09.190 --> 00:18:11.320
It's going to also lower
the barrier to entry to

00:18:11.320 --> 00:18:13.810
understanding your code base
because you're only writing

00:18:13.810 --> 00:18:15.620
JavaScript and storing JSON.

00:18:15.620 --> 00:18:19.930
You're not going to be writing
SQL queries, writing Ruby on

00:18:19.930 --> 00:18:23.660
the server, and then writing
JavaScript from it.

00:18:23.660 --> 00:18:25.790
There's a little bit of
a limitation to this.

00:18:25.790 --> 00:18:29.760
If you have multiple clients or
don't necessarily serve up

00:18:29.760 --> 00:18:33.540
your JavaScript with each page
load, you might have some

00:18:33.540 --> 00:18:39.180
difficulties with changing
the underlying routes.

00:18:39.180 --> 00:18:42.660
But that's a problem for
after prototyping.

00:18:42.660 --> 00:18:44.600
And don't break things--

00:18:44.600 --> 00:18:46.720
automated testing makes
life super easy.

00:18:46.720 --> 00:18:49.690
And when you only write
JavaScript, you only need a

00:18:49.690 --> 00:18:51.170
couple of testing frameworks.

00:18:51.170 --> 00:18:54.000
And all of your integration
tests come for free with

00:18:54.000 --> 00:18:55.250
angular-scenario.

00:18:56.950 --> 00:18:58.310
So Karma--

00:18:58.310 --> 00:19:01.670
if you haven't heard of Karma,
it is a phenomenal, phenomenal

00:19:01.670 --> 00:19:05.610
test runner that allows you to
basically launch a bunch of

00:19:05.610 --> 00:19:09.020
browsers and run all of your
client-side, server-side, and

00:19:09.020 --> 00:19:11.530
angular-scenario end-to-end
tests automatically

00:19:11.530 --> 00:19:13.470
each time you save.

00:19:13.470 --> 00:19:18.115
This makes it very, very easy to
basically just change code

00:19:18.115 --> 00:19:21.330
very quickly and make sure
that you haven't broken

00:19:21.330 --> 00:19:25.100
anything that is of any
significant importance.

00:19:25.100 --> 00:19:28.910
Again, angular-scenario does a
great job of sort of give you

00:19:28.910 --> 00:19:34.270
a smoke test of, have I broken
any particular page or flow

00:19:34.270 --> 00:19:37.990
that the user depends on.

00:19:37.990 --> 00:19:41.760
Nowadays the gold standard of
automated testing is called

00:19:41.760 --> 00:19:43.950
continuous integration.

00:19:43.950 --> 00:19:46.420
It works in different ways
in different places.

00:19:46.420 --> 00:19:48.810
Google has been using continuous
integration, if I

00:19:48.810 --> 00:19:53.120
recall, since 2006 or
2007 internally.

00:19:53.120 --> 00:19:56.640
However, the way that we like
to do it at MongoDB is for

00:19:56.640 --> 00:20:00.350
each commit, you run
a huge suite of

00:20:00.350 --> 00:20:03.650
tests on each git commit.

00:20:03.650 --> 00:20:06.460
And Karma allows you to
integrate easily with some

00:20:06.460 --> 00:20:11.270
existing open source continuous
integration suites

00:20:11.270 --> 00:20:14.240
such as Jenkins, Semaphore,
and Travis.

00:20:14.240 --> 00:20:16.970
You can find more information
about that off of the

00:20:16.970 --> 00:20:19.750
karma-runner.github.io.

00:20:19.750 --> 00:20:24.330
So, all in all, this gives the
MEAN stack the advantage that

00:20:24.330 --> 00:20:28.740
we can basically build our
code fast, add things as

00:20:28.740 --> 00:20:33.320
necessary, and then being able
to automatically test from the

00:20:33.320 --> 00:20:33.970
very beginning.

00:20:33.970 --> 00:20:36.190
Basically getting the gold
standard of automated

00:20:36.190 --> 00:20:38.210
testing-- continuous
integration--

00:20:38.210 --> 00:20:41.740
for free right from the start
instead of having

00:20:41.740 --> 00:20:44.240
to bake it in later.

00:20:44.240 --> 00:20:46.450
So that's all I have.

00:20:46.450 --> 00:20:49.200
Thank you guys very much
for listening.

00:20:49.200 --> 00:20:52.580
I look forward to hearing the
rest of the guys from

00:20:52.580 --> 00:20:54.140
IdeaBlade and StrongLoop
talking now.

00:20:54.140 --> 00:20:56.040
So thanks for listening again.

00:20:56.040 --> 00:20:57.790
Have a good one.

00:20:57.790 --> 00:20:59.730
BRAD GREEN: Val, thanks a lot.

00:20:59.730 --> 00:21:03.410
So I'll remind folks who are out
in the audience, we will

00:21:03.410 --> 00:21:05.670
probably have some time for
questions at the end.

00:21:05.670 --> 00:21:10.640
And there's a link at the top of
the YouTube live page that

00:21:10.640 --> 00:21:13.970
you can click on and type a
question or vote on questions

00:21:13.970 --> 00:21:15.580
that you see there.

00:21:15.580 --> 00:21:19.490
So we're going to move now to
Ward Bell from IdeaBlade to

00:21:19.490 --> 00:21:24.510
talk about BreezeJS and its role
in simplifying managing

00:21:24.510 --> 00:21:27.120
the data streams that come
from the backend.

00:21:33.560 --> 00:21:34.690
WARD BELL: Well that's--

00:21:34.690 --> 00:21:35.400
hi.

00:21:35.400 --> 00:21:36.000
I'm Ward.

00:21:36.000 --> 00:21:40.020
I'm going to flip over
to my screen here.

00:21:40.020 --> 00:21:45.110
And I trust that you
are now seeing--

00:21:45.110 --> 00:21:46.330
yes, you are.

00:21:46.330 --> 00:21:48.480
You are now seeing my screen.

00:21:48.480 --> 00:21:54.440
So I'm here to talk about the
MEAN stack as well when it

00:21:54.440 --> 00:21:56.960
intersects Breeze.

00:21:56.960 --> 00:21:58.310
Hi I'm Ward Bell.

00:21:58.310 --> 00:21:59.930
There's my Twitter handle,
and there's my

00:21:59.930 --> 00:22:01.920
Breeze Twitter handle.

00:22:01.920 --> 00:22:06.345
And I am a founder
of IdeaBlade.

00:22:06.345 --> 00:22:09.340
We are a company that helps
people build business

00:22:09.340 --> 00:22:10.000
applications--

00:22:10.000 --> 00:22:12.350
forms-over-data applications,
mostly.

00:22:12.350 --> 00:22:14.990
And we do it with infrastructure
products and

00:22:14.990 --> 00:22:17.840
also professional services.

00:22:17.840 --> 00:22:23.000
We help train, mentor, and,
in many cases, build the

00:22:23.000 --> 00:22:24.250
applications for our clients.

00:22:26.910 --> 00:22:28.585
And these days--

00:22:28.585 --> 00:22:29.650
did I have that?

00:22:29.650 --> 00:22:31.420
Yeah, I'd say that about--

00:22:31.420 --> 00:22:33.530
let me back up.

00:22:33.530 --> 00:22:35.810
The kinds of applications we're
talking about here with

00:22:35.810 --> 00:22:39.790
respect to Angular are single
page applications.

00:22:39.790 --> 00:22:43.400
Applications that are written in
HTML and CSS and JavaScript

00:22:43.400 --> 00:22:47.580
and are executing predominantly
on the client.

00:22:47.580 --> 00:22:50.840
And, in our practice, we're
seeing about 50% of our

00:22:50.840 --> 00:22:54.000
current engagements are
building this kind of

00:22:54.000 --> 00:22:55.250
application.

00:22:57.620 --> 00:23:00.560
You don't want to start from
absolute scratch, so we're

00:23:00.560 --> 00:23:05.490
recommending, for a presentation
framework, most

00:23:05.490 --> 00:23:06.990
the time, we're recommending
Angular.

00:23:06.990 --> 00:23:07.990
That's what people want.

00:23:07.990 --> 00:23:11.050
That's where the momentum is,
and we go where they go.

00:23:11.050 --> 00:23:15.130
We actually think it's great,
so how nice is that?

00:23:15.130 --> 00:23:19.290
And then, for data management,
we're recommending a product

00:23:19.290 --> 00:23:22.030
that we've written-- it's open
source-- called Breeze--

00:23:22.030 --> 00:23:24.560
BreezeJS.

00:23:24.560 --> 00:23:26.350
So here's what I want
to talk about.

00:23:26.350 --> 00:23:29.230
I want to talk about why you
might be interested in Breeze

00:23:29.230 --> 00:23:31.670
for your Angular application
development.

00:23:31.670 --> 00:23:35.180
I'd like to show you how
Breeze works in action.

00:23:35.180 --> 00:23:38.739
And then I'd like to show you
Breeze as it relates to the--

00:24:01.120 --> 00:24:03.530
Just a minute, folks.

00:24:03.530 --> 00:24:03.890
Let's see.

00:24:03.890 --> 00:24:05.140
Ward, can we hear you again?

00:24:09.050 --> 00:24:09.470
How about that?

00:24:09.470 --> 00:24:10.110
Can you hear me now?

00:24:10.110 --> 00:24:11.730
BRAD GREEN: Yes, we can.

00:24:11.730 --> 00:24:12.780
WARD BELL: OK.

00:24:12.780 --> 00:24:15.030
We seem to have lost the screen
share, so let me try

00:24:15.030 --> 00:24:16.280
that again.

00:24:19.760 --> 00:24:20.650
You are now seeing it.

00:24:20.650 --> 00:24:21.160
OK.

00:24:21.160 --> 00:24:22.040
I'll pick it up.

00:24:22.040 --> 00:24:22.870
BRAD GREEN: Great.

00:24:22.870 --> 00:24:25.790
WARD BELL: So I was saying
that Angular is a

00:24:25.790 --> 00:24:28.300
presentation framework.

00:24:28.300 --> 00:24:31.070
And just a second.

00:24:36.240 --> 00:24:39.260
What I mean by that is that it
helps present information to

00:24:39.260 --> 00:24:42.650
users and then respond
to their input.

00:24:42.650 --> 00:24:44.980
It's a framework to
help you do that.

00:24:44.980 --> 00:24:47.470
It's a library to help
you do that.

00:24:47.470 --> 00:24:50.640
And that means that you're
focusing on putting

00:24:50.640 --> 00:24:54.210
information on the glass, moving
from screen to screen,

00:24:54.210 --> 00:24:56.340
binding data to the DOM.

00:24:56.340 --> 00:24:59.580
Those are its primary
capabilities.

00:24:59.580 --> 00:25:02.370
It has some other supporting
ones, but that's really what

00:25:02.370 --> 00:25:04.800
it's about.

00:25:04.800 --> 00:25:08.040
And we often talk about the
patterns that are in use--

00:25:08.040 --> 00:25:10.810
MVC, MVVM, MV-whatever--

00:25:10.810 --> 00:25:13.800
its Model View Controller,
Model View View Model.

00:25:13.800 --> 00:25:16.410
But where's the M?

00:25:16.410 --> 00:25:19.220
Where's the M-- the model?

00:25:19.220 --> 00:25:22.370
And I think, for many people
first approaching their single

00:25:22.370 --> 00:25:24.200
page apps, they say, well, you
know, I'll just make a bunch

00:25:24.200 --> 00:25:27.630
of Ajax calls, and I'll
bind the results.

00:25:27.630 --> 00:25:30.130
And if I that's what I want to
do, I can reach into the

00:25:30.130 --> 00:25:33.280
Angular bag and pull out $http,
or I can pull out

00:25:33.280 --> 00:25:38.472
$resource if the backend is
written in a REST-y style.

00:25:38.472 --> 00:25:42.990
But I want to suggest to you
that this view is incomplete.

00:25:42.990 --> 00:25:47.900
Because, business apps anyway,
it's not really a matter of

00:25:47.900 --> 00:25:50.790
making an Ajax call and then
grabbing the data and throwing

00:25:50.790 --> 00:25:52.710
the data onto the screen.

00:25:52.710 --> 00:25:56.536
And I want to put some pressure
on you on this

00:25:56.536 --> 00:26:04.330
thought that $http is just a
way to access JSON data.

00:26:04.330 --> 00:26:06.620
Now you could come back to me
and say, well, you know, do I

00:26:06.620 --> 00:26:07.380
really need any more?

00:26:07.380 --> 00:26:09.470
I know I'm going to have
to write some code, but

00:26:09.470 --> 00:26:12.760
seriously, what do I
need a library for?

00:26:12.760 --> 00:26:15.950
So I want to ask you some
questions about your

00:26:15.950 --> 00:26:16.900
application.

00:26:16.900 --> 00:26:18.090
I want to ask you--

00:26:18.090 --> 00:26:19.820
I'm going to ask you a series
of questions about your

00:26:19.820 --> 00:26:20.400
application.

00:26:20.400 --> 00:26:22.010
And I'm not going to give you
a chance to answer, but I'm

00:26:22.010 --> 00:26:24.200
going to give you a chance
to think about.

00:26:24.200 --> 00:26:29.120
So my first thought is, is your
model all one type or

00:26:29.120 --> 00:26:30.430
does it involve multiple
types?

00:26:30.430 --> 00:26:34.050
I mean, how many times do you
do a Todo application?

00:26:34.050 --> 00:26:36.080
I don't write Todo applications,
and businesses

00:26:36.080 --> 00:26:37.220
generally don't.

00:26:37.220 --> 00:26:40.200
Instead, they tend to write
applications that have

00:26:40.200 --> 00:26:41.290
multiple entities.

00:26:41.290 --> 00:26:43.730
And these entities--

00:26:43.730 --> 00:26:45.160
are they interrelated?

00:26:45.160 --> 00:26:47.330
Well, let's take a look at
a really classic one.

00:26:47.330 --> 00:26:49.590
You've got customers and orders
and line items and all

00:26:49.590 --> 00:26:50.240
that other stuff.

00:26:50.240 --> 00:26:53.460
And you expect to be
able to move from

00:26:53.460 --> 00:26:56.370
one of those to another.

00:26:56.370 --> 00:27:00.710
So when you think about this
complex object graph, how

00:27:00.710 --> 00:27:04.050
often do you retrieve that?

00:27:04.050 --> 00:27:05.400
How do you retrieve it?

00:27:05.400 --> 00:27:07.340
Do you retrieve the whole graph
at once, or do you read

00:27:07.340 --> 00:27:08.940
parts of it?

00:27:08.940 --> 00:27:11.630
When do you retrieve it?

00:27:11.630 --> 00:27:13.910
My impression is that people
don't grab the whole database

00:27:13.910 --> 00:27:14.780
and load it at all at once.

00:27:14.780 --> 00:27:17.990
So how do you maneuver
around in this?

00:27:17.990 --> 00:27:20.460
How do you get from a customer
to an order, from an order to

00:27:20.460 --> 00:27:25.150
a line item, over time,
on the client side?

00:27:25.150 --> 00:27:28.010
Ask yourself of this data, are
any of the data really, truly

00:27:28.010 --> 00:27:31.120
stable during the life
of the session?

00:27:31.120 --> 00:27:32.570
Shippers and products
and suppliers

00:27:32.570 --> 00:27:33.610
aren't going to change.

00:27:33.610 --> 00:27:35.910
Customers, orders, and
line items do.

00:27:35.910 --> 00:27:40.810
So should you pre-fetch and
cache these stable items in

00:27:40.810 --> 00:27:44.620
order to make your application
perform well?

00:27:44.620 --> 00:27:46.390
How are you going to
populate picklists?

00:27:46.390 --> 00:27:49.390
How are you going to relate
those picklists to the

00:27:49.390 --> 00:27:54.290
customers and orders and line
items that reach to them?

00:27:54.290 --> 00:27:57.250
Do you have multiple views
of the same object?

00:27:57.250 --> 00:27:59.720
Angular is all about creating
multiple views.

00:27:59.720 --> 00:28:02.450
So, for example, if I had two
applications here, I might

00:28:02.450 --> 00:28:04.960
have the speaker on one screen
and speaker on another.

00:28:04.960 --> 00:28:06.920
Or I might have an editing
screen as well

00:28:06.920 --> 00:28:08.390
as a display screen.

00:28:08.390 --> 00:28:09.750
Same object.

00:28:09.750 --> 00:28:12.680
How do I maintain that object
across screens without making

00:28:12.680 --> 00:28:16.770
extra trips to the server?

00:28:16.770 --> 00:28:18.430
Do you save all the changes
immediately?

00:28:18.430 --> 00:28:21.500
A lot of demos I see, you change
the name and boom, it

00:28:21.500 --> 00:28:22.670
gets saved.

00:28:22.670 --> 00:28:25.160
That's not the way most business
applications work.

00:28:25.160 --> 00:28:28.130
You often have workflows,
and you're accumulating

00:28:28.130 --> 00:28:32.300
information before the user's
ready to commit it.

00:28:32.300 --> 00:28:34.260
They accumulate changes
during workflows.

00:28:34.260 --> 00:28:38.090
So how do you know which
entities are dirty?

00:28:38.090 --> 00:28:39.940
How do you know which ones are
going to save when the time

00:28:39.940 --> 00:28:40.760
comes to save them?

00:28:40.760 --> 00:28:42.010
You can't save everything.

00:28:44.100 --> 00:28:45.920
It's also the case that, during
a workflow, you'll have

00:28:45.920 --> 00:28:47.690
some inserts, updates
and, deletes.

00:28:47.690 --> 00:28:50.830
If you're modifying an order,
you'll probably add some line

00:28:50.830 --> 00:28:53.540
items, remove some line items.

00:28:53.540 --> 00:28:55.110
You need to do that in
a single transaction.

00:28:55.110 --> 00:28:56.540
How do you think
transactionally?

00:28:56.540 --> 00:28:57.545
How do you prepare
a transaction

00:28:57.545 --> 00:28:59.830
from the client side?

00:28:59.830 --> 00:29:02.790
Can the user cancel the changes
when they suddenly

00:29:02.790 --> 00:29:03.940
decide that they didn't
want to make those

00:29:03.940 --> 00:29:04.850
changes after all?

00:29:04.850 --> 00:29:07.120
How do they roll back
to a previous state?

00:29:07.120 --> 00:29:10.200
Do you have to make another
trip to the server?

00:29:10.200 --> 00:29:12.760
Another question-- do you
validate changes on the client

00:29:12.760 --> 00:29:14.760
for a better user experience?

00:29:14.760 --> 00:29:16.650
I mean, I realize you have to
validate on the server in

00:29:16.650 --> 00:29:19.860
order to make the data integrity
right, but don't you

00:29:19.860 --> 00:29:22.905
want to tell the user right
away, before they try and save

00:29:22.905 --> 00:29:27.270
it, that there's a problem and
help guide them to a solution?

00:29:27.270 --> 00:29:29.750
Do you think of these validation
rules as part of

00:29:29.750 --> 00:29:31.700
your business model logic?

00:29:31.700 --> 00:29:34.145
I mean, is it true, no matter
what view it is on there, that

00:29:34.145 --> 00:29:37.540
that email address
has to be proper?

00:29:37.540 --> 00:29:40.110
Well, if they are part of the
business rules, why would you

00:29:40.110 --> 00:29:43.140
go around putting business rules
that belong in the model

00:29:43.140 --> 00:29:44.760
into your HTML?

00:29:44.760 --> 00:29:47.410
Why would go in there in HTML5
and add attributes there?

00:29:47.410 --> 00:29:49.120
And how are you going to get
a desire to do that?

00:29:49.120 --> 00:29:51.240
And how are you going
to maintain it?

00:29:51.240 --> 00:29:53.100
Shouldn't the model
drive that UI?

00:29:53.100 --> 00:29:56.610
Shouldn't the model validation
drive what appears on the UI

00:29:56.610 --> 00:29:58.305
when there's a validation
violation?

00:30:01.000 --> 00:30:02.700
What if the user closes
the browser in the

00:30:02.700 --> 00:30:04.220
middle of the work?

00:30:04.220 --> 00:30:05.000
Happens all the time.

00:30:05.000 --> 00:30:07.750
I go up there, click
something, oops.

00:30:07.750 --> 00:30:09.730
Users do that.

00:30:09.730 --> 00:30:11.740
What if they had unsaved work?

00:30:11.740 --> 00:30:14.110
How would you preserve
it and restore it?

00:30:14.110 --> 00:30:16.070
If this is a business
application, not just some

00:30:16.070 --> 00:30:18.960
consumer site, they're not
going to be very happy.

00:30:18.960 --> 00:30:20.400
They're not going to be very
productive unless you have

00:30:20.400 --> 00:30:23.190
some mechanism for doing that.

00:30:23.190 --> 00:30:26.110
So I don't think you can find
answers to these questions

00:30:26.110 --> 00:30:31.860
just in making Ajax calls
with http or $resource.

00:30:31.860 --> 00:30:34.200
But I think you can find
these answers when

00:30:34.200 --> 00:30:35.950
you're using Breeze.

00:30:35.950 --> 00:30:38.430
And of course you could write
it all yourself--

00:30:38.430 --> 00:30:39.780
thousands of lines--

00:30:39.780 --> 00:30:42.180
or you might consider using a
library to help you just as

00:30:42.180 --> 00:30:44.620
you say to yourself, well, I
could write it all in jQuery,

00:30:44.620 --> 00:30:48.320
but I think I'd rather
use Angular.

00:30:48.320 --> 00:30:51.530
Let's take a look at an
application briefly that just

00:30:51.530 --> 00:30:55.340
does some of the things that
I'm talking about.

00:30:55.340 --> 00:31:00.230
It's an application that is--

00:31:00.230 --> 00:31:02.200
it's a sample from John Papa.

00:31:02.200 --> 00:31:05.020
And it's about come out on his
Pluralsight course on Angular

00:31:05.020 --> 00:31:06.190
and Breeze.

00:31:06.190 --> 00:31:08.470
And here is in action.

00:31:08.470 --> 00:31:10.450
When I load it up--

00:31:10.450 --> 00:31:11.260
I'll just start it up.

00:31:11.260 --> 00:31:14.450
And there's a bunch of toasts
here telling you

00:31:14.450 --> 00:31:17.890
diagnostically what's going on
as it loads at all from--

00:31:17.890 --> 00:31:19.330
or loads various parts
of things and

00:31:19.330 --> 00:31:20.930
certain things are happening.

00:31:20.930 --> 00:31:21.730
I can go in.

00:31:21.730 --> 00:31:24.040
And it's really about code camps
and sessions, and you've

00:31:24.040 --> 00:31:25.580
all attended conferences
before.

00:31:25.580 --> 00:31:28.660
So I can go and have a session,
and I'm going to

00:31:28.660 --> 00:31:29.220
another screen.

00:31:29.220 --> 00:31:34.800
Notice I'm pivoting around
something that was expressed

00:31:34.800 --> 00:31:36.380
this way in one view.

00:31:36.380 --> 00:31:37.380
And then I'm going here.

00:31:37.380 --> 00:31:39.790
And by the way, I've cached this
data, so I'm restoring it

00:31:39.790 --> 00:31:40.330
from cache.

00:31:40.330 --> 00:31:42.232
So I don't have to make
another server trip.

00:31:45.040 --> 00:31:49.960
If I whack this like this, I'm
getting a response back

00:31:49.960 --> 00:31:51.910
telling me that there's
an error here.

00:31:51.910 --> 00:31:53.730
Well, that's because I don't
know what the title is.

00:31:53.730 --> 00:31:54.250
But, you know what?

00:31:54.250 --> 00:31:56.130
Life doesn't stop when I don't
know what the title is.

00:31:56.130 --> 00:31:58.710
So I should be able to
go away and continue

00:31:58.710 --> 00:32:00.180
working on other things.

00:32:00.180 --> 00:32:02.020
Well, but if I go back
in, I want to know

00:32:02.020 --> 00:32:04.220
exactly where I was.

00:32:04.220 --> 00:32:07.820
That's because I'm keeping a
work in progress, which will

00:32:07.820 --> 00:32:11.610
help me navigate back
to the ones that I

00:32:11.610 --> 00:32:13.190
was working on before.

00:32:13.190 --> 00:32:15.560
And that work in progress
could, as it is in this

00:32:15.560 --> 00:32:19.290
example, be stored in local
storage, so that, were I to

00:32:19.290 --> 00:32:20.670
close this, and I'm
not going to.

00:32:20.670 --> 00:32:25.740
Instead I will do is I will go
back to sessions, and I will

00:32:25.740 --> 00:32:29.660
rerun the thing and say let's
pick up where I left off.

00:32:29.660 --> 00:32:31.830
That's kind of the equivalent
of closing the browser.

00:32:31.830 --> 00:32:32.790
There it is.

00:32:32.790 --> 00:32:33.550
Aha.

00:32:33.550 --> 00:32:34.360
I'm working on it.

00:32:34.360 --> 00:32:37.000
And now I'm working
on that session.

00:32:37.000 --> 00:32:40.050
So you see just some of the
kinds of things that I was

00:32:40.050 --> 00:32:43.012
talking about in there.

00:32:45.790 --> 00:32:47.040
Let me go back.

00:32:51.180 --> 00:32:53.400
So the thing I just showed you,
which is a code camp or

00:32:53.400 --> 00:32:56.200
sample, and will be available
on Pluralsight--

00:32:56.200 --> 00:32:57.760
great course--

00:32:57.760 --> 00:33:02.770
is an Angular app, but it's
backed by a SQL database.

00:33:02.770 --> 00:33:07.260
I want to show you, because
we're talking about the MEAN

00:33:07.260 --> 00:33:09.930
stack and Mongo and Node and
Express, I want to show you

00:33:09.930 --> 00:33:10.780
another application--

00:33:10.780 --> 00:33:12.500
also an Angular application--

00:33:12.500 --> 00:33:18.310
that is written to
talk to Mongo.

00:33:18.310 --> 00:33:20.850
And let me find that.

00:33:20.850 --> 00:33:22.100
That's right up here.

00:33:24.640 --> 00:33:25.890
Wrong one.

00:33:29.170 --> 00:33:31.780
You can actually get the sample
I'm about to show you

00:33:31.780 --> 00:33:33.370
from our Breeze sample site.

00:33:33.370 --> 00:33:34.410
And here it is.

00:33:34.410 --> 00:33:38.380
Here is Zza, our pizza place.

00:33:38.380 --> 00:33:41.540
And we can go and
order a pizza.

00:33:41.540 --> 00:33:43.560
Maybe I want to make my own.

00:33:43.560 --> 00:33:46.480
I'll pick a price for it,
and maybe I want to pick

00:33:46.480 --> 00:33:51.500
my sauce and meat.

00:33:51.500 --> 00:33:53.960
And I know I want to have some
salad with it, so I'll come

00:33:53.960 --> 00:33:57.020
over here, and I've got that.

00:33:57.020 --> 00:33:59.700
And maybe I'll go back, and
I'll add it to my cart.

00:33:59.700 --> 00:34:01.380
And I can look at my cart.

00:34:01.380 --> 00:34:01.680
OK.

00:34:01.680 --> 00:34:04.860
So this has that kind of
Angular, move around on the

00:34:04.860 --> 00:34:09.520
screen kind of thing, navigate
back and forth, keep track of

00:34:09.520 --> 00:34:13.550
your stuff, do validations, make
selections, and all that

00:34:13.550 --> 00:34:14.290
kind of thing

00:34:14.290 --> 00:34:16.800
Looks just like--

00:34:16.800 --> 00:34:19.590
it could as easily have been
written against a SQL database

00:34:19.590 --> 00:34:23.130
in which you could imagine with
the underlying parts are.

00:34:23.130 --> 00:34:25.400
And in fact, there is a version
of this application

00:34:25.400 --> 00:34:27.610
that does run against
a SQL database.

00:34:27.610 --> 00:34:30.100
But this one is running
against Mongo.

00:34:30.100 --> 00:34:32.969
And I want to show you a little
bit about what the

00:34:32.969 --> 00:34:34.905
implications of that are.

00:34:34.905 --> 00:34:37.203
Hold a second while
I control--

00:34:42.989 --> 00:34:44.020
that's where that is.

00:34:44.020 --> 00:34:48.210
So if the data that you had just
seen there about-- that

00:34:48.210 --> 00:34:50.409
were driving the
pizza parlor--

00:34:50.409 --> 00:34:55.909
were represented in SQL, you
would see individual tables

00:34:55.909 --> 00:34:56.679
for each of the items--

00:34:56.679 --> 00:35:00.550
Orders, OrderItems,
OrderItemOptoins, OrderStatus.

00:35:00.550 --> 00:35:05.030
But because this is Mongo that
we're talking to, in fact,

00:35:05.030 --> 00:35:07.120
what I've got for an
order is not--

00:35:07.120 --> 00:35:10.150
I don't have OrderItems
and OrderItemOptions.

00:35:10.150 --> 00:35:12.480
I have a document.

00:35:12.480 --> 00:35:15.370
Because Mongo is particularly
good at

00:35:15.370 --> 00:35:18.760
representing things as documents.

00:35:18.760 --> 00:35:21.410
Of course, not everything can
be in the same document, and

00:35:21.410 --> 00:35:22.190
I'll show you that.

00:35:22.190 --> 00:35:24.860
So some of the items are sort of
like drop-down lists, like

00:35:24.860 --> 00:35:27.340
what the products are and what
the product sizes are.

00:35:27.340 --> 00:35:29.240
And some of them are other kinds
of volatile objects,

00:35:29.240 --> 00:35:29.940
like customers.

00:35:29.940 --> 00:35:31.110
And they're all interrelated.

00:35:31.110 --> 00:35:34.890
So you still have navigations
between elements of documents,

00:35:34.890 --> 00:35:37.490
but you also have this notion
of a document representation

00:35:37.490 --> 00:35:40.810
instead of a table
orientation.

00:35:40.810 --> 00:35:43.170
And we can play a little
bit with that.

00:35:43.170 --> 00:35:45.710
Here's a view over the order.

00:35:45.710 --> 00:35:47.916
And you'll notice that--

00:35:47.916 --> 00:35:50.400
I just happened to be looking at
one of them in particular.

00:35:50.400 --> 00:35:53.190
And I can-- oh, by the way, you
don't have to deal with

00:35:53.190 --> 00:35:55.880
primitive type, so here's an
address with a [INAUDIBLE]

00:35:55.880 --> 00:35:57.340
type--

00:35:57.340 --> 00:36:00.380
with what we call a complex
type-- an embedded type.

00:36:00.380 --> 00:36:02.770
And you have OrderItems.

00:36:02.770 --> 00:36:05.900
So here is a pizza,
and it has options

00:36:05.900 --> 00:36:07.200
like barbecued chicken.

00:36:07.200 --> 00:36:08.750
So you see it's really
a document.

00:36:08.750 --> 00:36:14.850
This is no way representable as
a row within a data table.

00:36:14.850 --> 00:36:17.460
Now one of the things that
I think is particularly

00:36:17.460 --> 00:36:19.150
interesting about this
sample is that the

00:36:19.150 --> 00:36:20.700
front end is the same.

00:36:20.700 --> 00:36:22.270
It's still the same Angular.

00:36:22.270 --> 00:36:24.560
It's still the same Breeze.

00:36:24.560 --> 00:36:27.970
But all we've done, with a few
minor adjustments, is switch

00:36:27.970 --> 00:36:32.540
back to being able to
tweak the backend--

00:36:32.540 --> 00:36:34.330
give you a backend--

00:36:34.330 --> 00:36:39.540
that's running in Node and
Express with Mongo.

00:36:39.540 --> 00:36:42.860
And we're able to twist the
model so that it can deal in

00:36:42.860 --> 00:36:47.480
Breeze with documents, not just
with table structures.

00:36:47.480 --> 00:36:51.330
And just a quick look.

00:36:51.330 --> 00:36:54.340
Usually the server side is
fairly simple, as you were

00:36:54.340 --> 00:36:55.000
hearing earlier.

00:36:55.000 --> 00:36:58.550
It's pretty easy to get going
in this MEAN stack.

00:36:58.550 --> 00:37:05.270
So I have a simple HTML, but
this is the-- all you have to

00:37:05.270 --> 00:37:08.220
do on the Express server--
this kind of web server--

00:37:08.220 --> 00:37:11.250
and you just figure out what
things you want to use, and

00:37:11.250 --> 00:37:13.710
you figure out what your routes
are, and you route

00:37:13.710 --> 00:37:15.020
those things to--

00:37:15.020 --> 00:37:16.650
well, we have some Breeze
components for Node

00:37:16.650 --> 00:37:18.050
that make it easier.

00:37:18.050 --> 00:37:21.120
And you're off and running.

00:37:21.120 --> 00:37:24.970
As I said, this sample is
available to you from our

00:37:24.970 --> 00:37:27.030
samples page.

00:37:27.030 --> 00:37:32.800
So that is kind of an overview
in which I'm trying to

00:37:32.800 --> 00:37:35.800
encourage you to think about
data as a more significant

00:37:35.800 --> 00:37:38.985
problem than simply
going for Ajax.

00:37:38.985 --> 00:37:43.000
That you can combine
Angular and Breeze.

00:37:43.000 --> 00:37:47.090
That you can have a SQL backend,
or a Mongo backend--

00:37:47.090 --> 00:37:50.370
Breeze is agnostic with
respect to that.

00:37:50.370 --> 00:37:51.970
And so you can have it the
way you want it-- maybe

00:37:51.970 --> 00:37:53.020
prototype it in one.

00:37:53.020 --> 00:37:55.710
Or maybe you have a hybrid
application, which has a mix

00:37:55.710 --> 00:37:58.020
of a Mongo database, a
document-oriented database,

00:37:58.020 --> 00:37:59.220
and a SQL database.

00:37:59.220 --> 00:38:04.070
And you can unify those on the
client side with a Breeze app.

00:38:04.070 --> 00:38:04.480
Thank you.

00:38:04.480 --> 00:38:08.280
We'll probably get to the
resources later in the show,

00:38:08.280 --> 00:38:11.360
but I'll just say it now that
there are some courses that

00:38:11.360 --> 00:38:13.880
you could look at on Pluralsight
to learn about

00:38:13.880 --> 00:38:16.410
Breeze, about the application
that I just showed you.

00:38:16.410 --> 00:38:18.220
There's John Papa's course.

00:38:18.220 --> 00:38:20.360
You can go online with us.

00:38:20.360 --> 00:38:25.180
And just think that your rich
data, it really is a breeze.

00:38:25.180 --> 00:38:26.440
Back to you, Brad.

00:38:26.440 --> 00:38:27.900
BRAD GREEN: Ward,
thanks so much.

00:38:27.900 --> 00:38:28.530
That was awesome.

00:38:28.530 --> 00:38:30.600
I think Breeze is
very exciting.

00:38:30.600 --> 00:38:32.690
So we're going to go over
to Al Tsang now.

00:38:32.690 --> 00:38:34.040
Al is with StrongLoop.

00:38:34.040 --> 00:38:36.890
He's going to talk about how
Mongo can work for the

00:38:36.890 --> 00:38:38.190
enterprise in the
mobile space.

00:38:40.810 --> 00:38:41.770
AL TSANG: Thanks, Brad.

00:38:41.770 --> 00:38:42.090
Hi, everyone.

00:38:42.090 --> 00:38:44.390
This is Al Tsang, CTO
of StrongLoop.

00:38:44.390 --> 00:38:46.800
I'll go ahead and get started
by sharing my screen.

00:38:53.080 --> 00:38:55.920
Here we go.

00:38:55.920 --> 00:38:58.610
So brief presentation.

00:38:58.610 --> 00:39:00.890
Thanks, everyone,
for having me.

00:39:00.890 --> 00:39:03.450
We're going to go ahead and
talk about LoopBack.

00:39:03.450 --> 00:39:06.990
Again, as Brad had mentioned,
LoopBack is a mobile backend

00:39:06.990 --> 00:39:11.230
in which you can hook your
Angular application to.

00:39:11.230 --> 00:39:14.116
We're focused on the
mobile space.

00:39:14.116 --> 00:39:15.960
LoopBack is an Open
Source Mobile

00:39:15.960 --> 00:39:18.390
Backend-as-a-Service, or mBaaS.

00:39:18.390 --> 00:39:20.080
And it features BACN.

00:39:20.080 --> 00:39:22.950
And I'll get to what
BACN's all about.

00:39:22.950 --> 00:39:25.550
So real briefly, a little
bit about StrongLoop.

00:39:25.550 --> 00:39:28.750
We were founded at the
end of 2012 by Bert

00:39:28.750 --> 00:39:30.870
Belder and Ben Noordhuis.

00:39:30.870 --> 00:39:32.505
They're two core maintainers
in NodeJS.

00:39:32.505 --> 00:39:35.030
They've been there since the
beginning the project.

00:39:35.030 --> 00:39:36.990
Along with myself and a
friend and colleague

00:39:36.990 --> 00:39:38.500
of mine named Raymond--

00:39:38.500 --> 00:39:42.511
We built the mobile backend
for shutterfly.com.

00:39:42.511 --> 00:39:45.940
As a company, we develop and
support StrongLoop Suite.

00:39:45.940 --> 00:39:48.550
It's our product offering
by subscription.

00:39:48.550 --> 00:39:50.250
It contains three components--

00:39:50.250 --> 00:39:53.440
so LoopBack-- the open source
mBaaS that we talked about.

00:39:53.440 --> 00:39:56.270
LoopBack is built on top of
StrongNode, which is a

00:39:56.270 --> 00:39:59.720
certified package of Node and
select certified community

00:39:59.720 --> 00:40:02.780
modules that are commonly
used in the enterprise.

00:40:02.780 --> 00:40:05.640
And we round out our offering
with StrongOps, which is a

00:40:05.640 --> 00:40:08.000
real-time performance
monitoring

00:40:08.000 --> 00:40:09.430
and operational dashboard.

00:40:09.430 --> 00:40:11.590
This lets you not only visualize
what's going

00:40:11.590 --> 00:40:12.740
on with your apps.

00:40:12.740 --> 00:40:16.600
We intend on making it be
operational, so actually do

00:40:16.600 --> 00:40:20.590
something with for apps--
scale it, triage it,

00:40:20.590 --> 00:40:22.130
so on and so forth.

00:40:22.130 --> 00:40:25.030
As a company, and as a good
citizen of open source, we

00:40:25.030 --> 00:40:29.860
also contribute to Node and its
rich ecosystem within npm.

00:40:29.860 --> 00:40:31.915
So we've done contributions
to node-inspector and

00:40:31.915 --> 00:40:34.760
node-reggie, and we continually
comb over the Node

00:40:34.760 --> 00:40:37.950
universe to figure out what's
there in the community that

00:40:37.950 --> 00:40:41.220
could be leveraged in
the enterprise.

00:40:41.220 --> 00:40:43.450
So let me start by outlining
sort of the problem of what

00:40:43.450 --> 00:40:45.740
we're trying to solve
with LoopBack.

00:40:45.740 --> 00:40:48.390
Mobile devices need
to get to data.

00:40:48.390 --> 00:40:50.950
If you think about all the
applications running on your

00:40:50.950 --> 00:40:54.120
smartphone, look at the ones
that actually do something

00:40:54.120 --> 00:40:56.820
useful or are productive
within the enterprise.

00:40:56.820 --> 00:40:57.650
They need data.

00:40:57.650 --> 00:41:02.020
They don't need just data that
exists in the cloud that's new

00:41:02.020 --> 00:41:03.890
or native to the mobile
application.

00:41:03.890 --> 00:41:07.170
They need data that's there,
that's like your banking data.

00:41:07.170 --> 00:41:09.280
So this poses a bunch
of challenges.

00:41:09.280 --> 00:41:12.600
Number one, the data itself,
there's authentication,

00:41:12.600 --> 00:41:15.950
authorization, and accounting
issues.

00:41:15.950 --> 00:41:18.960
Oftentimes, the data's not
even in the right format.

00:41:18.960 --> 00:41:22.360
Like it's in XML, where it's in
a bunch of rows of tables.

00:41:22.360 --> 00:41:23.680
There's too much of that data.

00:41:23.680 --> 00:41:26.450
Can you imagine if your mobile
device asked for the customer

00:41:26.450 --> 00:41:29.860
master at a large B-to-C company
like one that we

00:41:29.860 --> 00:41:30.860
worked for at Shutterfly.

00:41:30.860 --> 00:41:33.760
You'd get back 6 million-plus
rows.

00:41:33.760 --> 00:41:37.180
And then, on top of that,
there's multiple data sources.

00:41:37.180 --> 00:41:39.990
Even if you had just one
database, you'd probably have

00:41:39.990 --> 00:41:43.310
a bunch of instances
of that database.

00:41:43.310 --> 00:41:46.675
And lastly, you wouldn't even
want all those devices to be

00:41:46.675 --> 00:41:50.110
hitting your backends
directly.

00:41:50.110 --> 00:41:53.960
So today, we're going to be
centering around our use case

00:41:53.960 --> 00:41:58.060
and example around this mythical
military equipment

00:41:58.060 --> 00:42:02.140
rental surplus vendor
called Blackpool.

00:42:02.140 --> 00:42:05.070
And in this illustration, we
have this said warmonger, and

00:42:05.070 --> 00:42:07.490
he's looking for an
Apache helicopter.

00:42:07.490 --> 00:42:08.620
And he needs it by tomorrow
because he's

00:42:08.620 --> 00:42:10.310
about to wage a war.

00:42:10.310 --> 00:42:14.680
So from this mobile device, he
wants to look up, using a

00:42:14.680 --> 00:42:18.230
geocode lookup on his device
getting his coordinates, a

00:42:18.230 --> 00:42:20.980
list of rental locations that
might have inventory for

00:42:20.980 --> 00:42:24.130
Apache helicopters against
Blackpool.

00:42:24.130 --> 00:42:26.400
Once he actually finds something
from the mobile

00:42:26.400 --> 00:42:28.790
device, he needs to actually
reserve it.

00:42:28.790 --> 00:42:30.460
And upon reserving
it, he needs to

00:42:30.460 --> 00:42:31.950
authenticate who he is.

00:42:31.950 --> 00:42:34.310
Does he have a credit
limit, for example?

00:42:34.310 --> 00:42:36.580
Getting his profile-- is
even authorized to do

00:42:36.580 --> 00:42:38.030
something like this?

00:42:38.030 --> 00:42:41.170
And finally, post payment,
which sets another set of

00:42:41.170 --> 00:42:43.590
challenges and transactions.

00:42:43.590 --> 00:42:47.295
So as you can see, this is not
very efficient doing all from

00:42:47.295 --> 00:42:47.950
the mobile device.

00:42:47.950 --> 00:42:52.720
You could, but you'd run
into a bunch of issues.

00:42:52.720 --> 00:42:56.150
Our answer is to basically
develop mobile middleware

00:42:56.150 --> 00:43:01.590
optimized for this use case and
leverage enterprise data

00:43:01.590 --> 00:43:03.460
on the backend.

00:43:03.460 --> 00:43:06.100
So this is our solution.

00:43:06.100 --> 00:43:09.030
A Mobile Backend-as-a-Service,
or mBaaS, you can think of it

00:43:09.030 --> 00:43:12.210
as an open source Parse you
control, if you're familiar

00:43:12.210 --> 00:43:16.520
with the vendor Parse that
was acquired by Facebook.

00:43:16.520 --> 00:43:19.130
So if you want to think about
it in terms of MEAN, think

00:43:19.130 --> 00:43:21.900
about it as MEAN gone mobile.

00:43:21.900 --> 00:43:25.140
LoopBack actually utilizes
ExpressJS.

00:43:25.140 --> 00:43:28.010
So you can use
Express-compatible middleware

00:43:28.010 --> 00:43:31.440
by using app.use with your
favorite middleware and extend

00:43:31.440 --> 00:43:32.840
upon LoopBack.

00:43:32.840 --> 00:43:35.470
We basically connect devices
to browsers--

00:43:35.470 --> 00:43:38.040
connect devices and other
devices to the

00:43:38.040 --> 00:43:39.900
enterprise data itself.

00:43:39.900 --> 00:43:42.070
It's all written
in Node, proven

00:43:42.070 --> 00:43:43.590
language for mobile backends.

00:43:43.590 --> 00:43:46.920
We've seen this use case used
over and over again.

00:43:46.920 --> 00:43:49.752
And it's open source, so
you can extend on it.

00:43:49.752 --> 00:43:53.230
And A key differentiator for us
is that it's on premises or

00:43:53.230 --> 00:43:53.850
in your cloud.

00:43:53.850 --> 00:43:56.460
You decide where to
run LoopBack.

00:43:56.460 --> 00:43:58.350
We have SDKs for iOS.

00:43:58.350 --> 00:44:00.600
Android we're just polishing
up right now.

00:44:00.600 --> 00:44:02.960
We're developing our
JavaScript SDK.

00:44:02.960 --> 00:44:05.070
And we have BACN.

00:44:05.070 --> 00:44:11.240
BACN is what relates us to our
front-end implementation, and

00:44:11.240 --> 00:44:13.780
I'll talk more about
that in a second.

00:44:13.780 --> 00:44:17.160
And then we have the rest of
StrongLoop's suite, which is

00:44:17.160 --> 00:44:19.010
the bundling of the other
components that

00:44:19.010 --> 00:44:20.180
round out our offering.

00:44:20.180 --> 00:44:24.160
So operationally monitor your
stuff that's going on in

00:44:24.160 --> 00:44:27.750
LoopBack as well as the core
fundamentals of Node that

00:44:27.750 --> 00:44:30.820
powers the app.

00:44:30.820 --> 00:44:33.830
Real briefly, then,
the architecture.

00:44:33.830 --> 00:44:35.110
Again, we have Mongo.

00:44:35.110 --> 00:44:36.420
We have all these
data sources.

00:44:36.420 --> 00:44:39.110
What we've built is basically a
layer of abstraction called

00:44:39.110 --> 00:44:41.020
the data source juggler.

00:44:41.020 --> 00:44:43.600
From the data source juggler,
you get back a model--

00:44:43.600 --> 00:44:46.320
something that you can actually
relate to as a mobile

00:44:46.320 --> 00:44:47.450
[INAUDIBLE].

00:44:47.450 --> 00:44:50.320
And as you build models and
define these models against

00:44:50.320 --> 00:44:53.920
your data sources, we
[INAUDIBLE] a REST API.

00:44:53.920 --> 00:44:57.760
We also have a gateway that
allows you to secure the API,

00:44:57.760 --> 00:45:01.190
[INAUDIBLE] off to, mediate with
it to be able to change

00:45:01.190 --> 00:45:03.000
from different content
payloads.

00:45:03.000 --> 00:45:05.050
And it acts as a reverse
proxy to multiple

00:45:05.050 --> 00:45:07.510
instances of API servers.

00:45:07.510 --> 00:45:11.130
All of this data is stored
in a repository in JSON.

00:45:11.130 --> 00:45:15.260
And we use basically the
underlyings of git and others

00:45:15.260 --> 00:45:17.420
at the distribute source control
mechanism so that you

00:45:17.420 --> 00:45:20.070
can unify multiple LoopBack
instances into

00:45:20.070 --> 00:45:23.020
one single run time.

00:45:23.020 --> 00:45:24.100
Now let's talk about BACN.

00:45:24.100 --> 00:45:25.050
Why did we call it BACN?

00:45:25.050 --> 00:45:27.100
Well, who doesn't like bacon?

00:45:27.100 --> 00:45:32.280
BACN stands for Bootstrap,
Angular, Cordova, and Node.

00:45:32.280 --> 00:45:35.070
What we're betting on here is
a front-end framework for

00:45:35.070 --> 00:45:38.170
LoopBack to develop mobile
web apps or hybrid apps.

00:45:38.170 --> 00:45:40.190
And we're looking forward to
partnering with the Google

00:45:40.190 --> 00:45:43.270
Angular team to carve out the
niche for Angular formal

00:45:43.270 --> 00:45:45.360
mobile web.

00:45:45.360 --> 00:45:48.290
And now I'd like to jump
into a quick demo.

00:45:48.290 --> 00:45:50.810
If you'd like to follow along,
or follow up with this demo,

00:45:50.810 --> 00:45:53.510
you can go to our docs
page and go to

00:45:53.510 --> 00:45:54.760
LoopBack Quick Start.

00:45:54.760 --> 00:45:57.210
We have Quick Starts for all
three of our components.

00:45:57.210 --> 00:45:59.740
And then you can continue on
with the BACN sample, which we

00:45:59.740 --> 00:46:02.356
just released last
night on GitHub.

00:46:11.160 --> 00:46:14.730
All right, so to get started,
the first thing you would want

00:46:14.730 --> 00:46:16.710
to do is get to our
get started page.

00:46:16.710 --> 00:46:19.670
If you register on our site and
go to our downloads page,

00:46:19.670 --> 00:46:22.930
you can go ahead and pick which
platform that you'd like

00:46:22.930 --> 00:46:23.700
to develop in.

00:46:23.700 --> 00:46:27.880
Or, alternatively, we have this
neato Cloud9-based IDE,

00:46:27.880 --> 00:46:30.030
in which you don't even have
to download anything.

00:46:30.030 --> 00:46:33.380
You just start with LoopBack,
and the rest of StrongLoop's

00:46:33.380 --> 00:46:36.430
going to be running
in the cloud.

00:46:36.430 --> 00:46:39.350
From there, as I mentioned
before, go to our docs page.

00:46:39.350 --> 00:46:42.240
And then, from the docs page,
go ahead and click LoopBack,

00:46:42.240 --> 00:46:44.030
and we have this Quick Start.

00:46:44.030 --> 00:46:46.490
So the first thing we want
to do is, again, install

00:46:46.490 --> 00:46:47.940
StrongLoop Suite.

00:46:47.940 --> 00:46:50.440
And then you're going to go
ahead and initialize the

00:46:50.440 --> 00:46:53.540
StrongLoop Suite sample
application.

00:46:53.540 --> 00:46:57.060
For the sake of time, I've
gone ahead and done that.

00:46:57.060 --> 00:47:01.280
And I've installed it
already on my Mac.

00:47:01.280 --> 00:47:03.640
So I'm going to go ahead and
run the application now.

00:47:10.440 --> 00:47:12.440
And it starts up.

00:47:12.440 --> 00:47:15.110
And in another browser--

00:47:15.110 --> 00:47:16.700
just go ahead and close these.

00:47:22.120 --> 00:47:26.410
So what you're seeing here is
the physical manifestation of

00:47:26.410 --> 00:47:29.700
a RESTful API for Blackpool.

00:47:29.700 --> 00:47:33.380
And we have these model entities
that are out there--

00:47:33.380 --> 00:47:34.520
weapons.

00:47:34.520 --> 00:47:38.020
So you can play with this
RESTful API all

00:47:38.020 --> 00:47:39.640
through this page.

00:47:39.640 --> 00:47:41.890
So getting a collection
of weapons, get a

00:47:41.890 --> 00:47:43.880
weapon, buy an ID.

00:47:43.880 --> 00:47:46.355
We offer is very similar
syntax to

00:47:46.355 --> 00:47:48.030
what Mongo has, right?

00:47:48.030 --> 00:47:51.630
Mongo query language has been
a fantastic example of being

00:47:51.630 --> 00:47:55.820
able to get to sort of a
JSON-oriented query structure.

00:47:55.820 --> 00:47:58.910
So, in this case,
I have weapons.

00:47:58.910 --> 00:48:02.010
Give me the ones that are have
an effective range greater

00:48:02.010 --> 00:48:04.562
than 900 hydrogen just give
me the first three.

00:48:04.562 --> 00:48:07.470
You can continue to play
along with this API.

00:48:07.470 --> 00:48:10.565
And again, as you build these
models and defined them

00:48:10.565 --> 00:48:14.310
against their underlying data
sources, we build an API.

00:48:14.310 --> 00:48:17.450
And what we've done is build
and API explorer.

00:48:17.450 --> 00:48:20.060
So you can actually go ahead
and click on, for example,

00:48:20.060 --> 00:48:23.980
locations and get a
list of locations.

00:48:23.980 --> 00:48:25.280
Try it out.

00:48:25.280 --> 00:48:29.360
Get back the same JSON output.

00:48:29.360 --> 00:48:30.610
So that's the API explorer.

00:48:33.110 --> 00:48:36.570
So from here, from the Quick
Start then, we jump into the

00:48:36.570 --> 00:48:37.990
Getting Started Guide.

00:48:37.990 --> 00:48:41.240
And the Getting Started Guide
basically allows you to

00:48:41.240 --> 00:48:43.300
consume this RESTful API.

00:48:43.300 --> 00:48:45.550
And we're going to go ahead
and do that now.

00:48:45.550 --> 00:48:49.660
And instead of using our mobile
client that we have

00:48:49.660 --> 00:48:53.470
natively for iOS, we're going
to go ahead and use BACN.

00:48:53.470 --> 00:48:58.620
So what I [INAUDIBLE] ahead and
did to save time is clone

00:48:58.620 --> 00:49:01.330
the BACN repo, and
I'm going to go

00:49:01.330 --> 00:49:02.710
ahead and run the client.

00:49:06.790 --> 00:49:10.295
So normally, I would do this in
the emulator on Android or

00:49:10.295 --> 00:49:13.570
on iOS or whatnot, but I'm going
to go ahead and do this

00:49:13.570 --> 00:49:16.480
in the browser because this is a
little bit hard to see here.

00:49:16.480 --> 00:49:23.620
So let's go ahead and run the
same thing going on in Chrome.

00:49:23.620 --> 00:49:28.290
And hopefully that's a lot
bigger and better to see here.

00:49:28.290 --> 00:49:30.040
So this is our BACN app.

00:49:30.040 --> 00:49:31.470
It's all in Angular.

00:49:31.470 --> 00:49:34.140
In fact, let's take a
look at the code.

00:49:34.140 --> 00:49:35.710
Really simple.

00:49:35.710 --> 00:49:38.070
In the main, we have a bunch
of routes to define.

00:49:38.070 --> 00:49:41.510
We've defined our resource group
which binds, by local

00:49:41.510 --> 00:49:45.800
host, the RESTful API coming
from the sample app, to the

00:49:45.800 --> 00:49:48.330
Angular SPA.

00:49:48.330 --> 00:49:51.450
We have a bunch of controllers
that actually drive the logic.

00:49:51.450 --> 00:49:55.080
And as I move on to the
tutorial, if I go to page one,

00:49:55.080 --> 00:49:56.750
this is just text.

00:49:56.750 --> 00:50:00.580
This is lesson one, and I'll get
to lesson one in a second.

00:50:00.580 --> 00:50:03.230
We have a bunch of services that
we've defined as well, as

00:50:03.230 --> 00:50:04.270
an Angular module.

00:50:04.270 --> 00:50:08.020
So we've actually defined this
model called ammo and bound it

00:50:08.020 --> 00:50:10.090
to the RESTful endpoint.

00:50:10.090 --> 00:50:12.900
Same thing for weapons
and locations.

00:50:12.900 --> 00:50:15.540
Really simple stuff.

00:50:15.540 --> 00:50:19.560
OK so going back to
the application.

00:50:19.560 --> 00:50:21.760
So, lesson one-- so to
illustrate the power of

00:50:21.760 --> 00:50:25.750
LoopBack, what we've done is
we've basically developed

00:50:25.750 --> 00:50:28.630
three lessons to show some
of the key highlights.

00:50:28.630 --> 00:50:34.780
So lesson one is all about the
model and having a schema-less

00:50:34.780 --> 00:50:37.360
definition of what that model
is on the database.

00:50:37.360 --> 00:50:40.490
And what I mean by that is, if
I actually go to the models

00:50:40.490 --> 00:50:46.440
directory and I look at ammo,
you can see that its

00:50:46.440 --> 00:50:48.270
properties are null.

00:50:48.270 --> 00:50:53.150
And in my Angular app, I've
gone in to find properties

00:50:53.150 --> 00:50:56.207
that I'm going to go ahead and
put in-- so name, caliber, and

00:50:56.207 --> 00:50:58.220
a Boolean on whether or not
it's armor piercing.

00:51:01.210 --> 00:51:04.500
So let's go ahead and curl this
application's data store.

00:51:04.500 --> 00:51:06.820
We're using the in-memory
database, which mirrors

00:51:06.820 --> 00:51:09.085
exactly like Mongo except
it's not persistent.

00:51:12.130 --> 00:51:15.050
And I get back null without
its carriage return,

00:51:15.050 --> 00:51:17.570
conveniently.

00:51:17.570 --> 00:51:19.540
So using the Angular app, and
then I'm going to go ahead and

00:51:19.540 --> 00:51:20.900
hit the send request.

00:51:20.900 --> 00:51:25.440
So super-duper ammo,
re-curl, and boom.

00:51:25.440 --> 00:51:26.640
There you go.

00:51:26.640 --> 00:51:28.220
Same thing--

00:51:28.220 --> 00:51:32.850
rail gun 80 cals, absolutely
armor-piercing.

00:51:32.850 --> 00:51:33.710
[BEEP]

00:51:33.710 --> 00:51:35.000
[BEEP]

00:51:35.000 --> 00:51:36.200
AL TSANG: Whoops.

00:51:36.200 --> 00:51:38.200
[BEEP]

00:51:38.200 --> 00:51:39.200
[BEEP-BEEP]

00:51:39.200 --> 00:51:39.700
AL TSANG: Oh.

00:51:39.700 --> 00:51:41.200
It's stuck on this.

00:51:41.200 --> 00:51:42.450
There we go.

00:51:44.700 --> 00:51:46.070
And there we go.

00:51:46.070 --> 00:51:50.200
So again, a schema-less
model that's defined.

00:51:50.200 --> 00:51:52.530
And you define its
model properties

00:51:52.530 --> 00:51:55.010
on the Angular client.

00:51:55.010 --> 00:51:55.660
So that's lesson one.

00:51:55.660 --> 00:52:00.390
Lesson two, real quick now,
illustrates existing data.

00:52:00.390 --> 00:52:03.670
So we've acknowledged at
LoopBack that enterprises have

00:52:03.670 --> 00:52:04.450
existing data.

00:52:04.450 --> 00:52:06.830
And that, although it's nice
to define new data for your

00:52:06.830 --> 00:52:10.310
mobile apps, you want to
leverage your existing data.

00:52:10.310 --> 00:52:13.630
So I'm going to go ahead and
re-run the application now.

00:52:13.630 --> 00:52:18.400
And instead of connecting to
our memory adapter, we're

00:52:18.400 --> 00:52:20.210
going to go ahead and
connect to a running

00:52:20.210 --> 00:52:21.460
live instance of Oracle.

00:52:26.250 --> 00:52:29.520
And just to give you a flavor
of what's going on here--

00:52:42.340 --> 00:52:44.740
all right.

00:52:44.740 --> 00:52:50.410
Table name, user tables--

00:52:50.410 --> 00:52:53.910
and go ahead and describe
inventory--

00:52:53.910 --> 00:52:55.160
actually product.

00:52:55.160 --> 00:52:57.410
That's what we're going
to be showcasing here.

00:52:57.410 --> 00:52:59.670
And I'm going to get back,
basically, the records that

00:52:59.670 --> 00:53:01.300
are going against this
Oracle database.

00:53:05.950 --> 00:53:09.320
So what's going on with this is
we're calling controller.

00:53:09.320 --> 00:53:11.010
That's basically sending
requests.

00:53:11.010 --> 00:53:14.680
And what's nice about Angular
is that it's very easy to

00:53:14.680 --> 00:53:17.110
figure out what's going on with
these controllers and

00:53:17.110 --> 00:53:17.600
what they're doing.

00:53:17.600 --> 00:53:21.710
So in this case, I'm simply
hitting up weapons, which was

00:53:21.710 --> 00:53:25.950
a linked through LoopBack to the
products table, querying

00:53:25.950 --> 00:53:28.720
it, and getting back and binding
that to this view.

00:53:28.720 --> 00:53:33.240
And again, through to the power
of, as Val put it, data

00:53:33.240 --> 00:53:34.650
binding being bidirectional.

00:53:34.650 --> 00:53:37.470
There's a whole slew of things
you can do here.

00:53:37.470 --> 00:53:40.610
From a mobile application's
perspective, you have issues

00:53:40.610 --> 00:53:43.960
like data sync, like save
eventually, save and forget.

00:53:43.960 --> 00:53:48.580
But this gives us a rich
interface to be able to get to

00:53:48.580 --> 00:53:51.690
meet the demands of what you
would normally build within

00:53:51.690 --> 00:53:54.980
the native platform.

00:53:54.980 --> 00:53:58.380
In the interest of time, I'm
going to stop there and

00:53:58.380 --> 00:54:02.390
continue on with concluding
out LoopBack.

00:54:02.390 --> 00:54:05.890
[BEEP]

00:54:05.890 --> 00:54:07.660
So that's the demo.

00:54:07.660 --> 00:54:10.640
If you would like to go ahead
and follow along, or follow

00:54:10.640 --> 00:54:12.360
up, go ahead and go to
the Quick Starts.

00:54:12.360 --> 00:54:15.280
We have Quick Starts, again,
for all three components.

00:54:15.280 --> 00:54:16.780
A quick look at the roadmap.

00:54:16.780 --> 00:54:19.870
So we just released this,
literally, two weeks ago.

00:54:19.870 --> 00:54:24.010
And we're solidifying
our JavaScript SDK.

00:54:24.010 --> 00:54:25.750
We just finished Android.

00:54:25.750 --> 00:54:27.480
That's in testing right now.

00:54:27.480 --> 00:54:28.700
As an mBaaS--

00:54:28.700 --> 00:54:30.690
part of the reason why you
wouldn't want to adopt an

00:54:30.690 --> 00:54:32.360
mBaaS is because
we've already--

00:54:32.360 --> 00:54:35.470
we want to actually pre-build
mobile models for the most

00:54:35.470 --> 00:54:36.430
common use cases.

00:54:36.430 --> 00:54:40.460
So, like user for user
registration, file for storing

00:54:40.460 --> 00:54:42.290
files and other [INAUDIBLE].

00:54:42.290 --> 00:54:46.860
LBGeoPoint is our geopoint for
geonavigation and other

00:54:46.860 --> 00:54:49.090
calculations on a
mobile device.

00:54:49.090 --> 00:54:52.010
And of course, push
notification.

00:54:52.010 --> 00:54:53.570
We're also working
on an editor.

00:54:53.570 --> 00:54:55.000
Again, all in Angular.

00:54:55.000 --> 00:54:56.320
That makes it even easier.

00:54:56.320 --> 00:54:58.430
So you don't have to navigate
through code if you don't want

00:54:58.430 --> 00:55:00.270
to, or use the CLI.

00:55:00.270 --> 00:55:01.930
And mobile app management--

00:55:01.930 --> 00:55:05.440
so how to actually develop your
apps that actually tie in

00:55:05.440 --> 00:55:07.630
backends with your APIs.

00:55:07.630 --> 00:55:09.210
And of course, more
connectors--

00:55:09.210 --> 00:55:10.170
we have MySQL.

00:55:10.170 --> 00:55:11.100
That's already done.

00:55:11.100 --> 00:55:15.070
And we're looking to evaluate
enterprise systems.

00:55:15.070 --> 00:55:15.820
So what's next?

00:55:15.820 --> 00:55:17.240
Go ahead and please
try LoopBack and

00:55:17.240 --> 00:55:18.510
register on our site.

00:55:18.510 --> 00:55:20.540
We have their docs page
as I mentioned before.

00:55:20.540 --> 00:55:23.000
We also have a community that
we've established, called

00:55:23.000 --> 00:55:25.350
node-republic, that
we sponsor.

00:55:25.350 --> 00:55:27.620
And if you have any questions,
please feel

00:55:27.620 --> 00:55:29.080
free to contact me.

00:55:29.080 --> 00:55:32.265
Here's my contact information
at the end here.

00:55:32.265 --> 00:55:34.430
And that's pretty much it.

00:55:34.430 --> 00:55:35.470
Back to you, Brad.

00:55:35.470 --> 00:55:36.340
BRAD GREEN: Wonderful, Al.

00:55:36.340 --> 00:55:37.020
Thanks so much.

00:55:37.020 --> 00:55:38.670
I know I've already had
breakfast, but for some

00:55:38.670 --> 00:55:42.150
reason, I'm hungry for bacon
here [INAUDIBLE].

00:55:42.150 --> 00:55:44.200
I want to thank all
of our speakers--

00:55:44.200 --> 00:55:46.670
Val, Ward, and Al-- for joining
us this morning.

00:55:46.670 --> 00:55:49.390
And for everyone watching,
thanks for joining.

00:55:49.390 --> 00:55:50.610
We'll see you on the web.

00:55:50.610 --> 00:55:51.870
Please ask us questions.

00:55:51.870 --> 00:55:53.560
Please try out these
technologies.

00:55:53.560 --> 00:55:55.530
We're excited to see what
you guys build.

00:55:55.530 --> 00:55:56.160
We'll see you later.

00:55:56.160 --> 00:55:57.410
Bye bye.

00:56:09.960 --> 00:57:17.248
[MUSIC PLAYING]

