WEBVTT
Kind: captions
Language: en

00:00:02.750 --> 00:00:07.630
&gt;&gt;Michael Mahemoff: Thanks for coming today.
My name is Mike, and this is Paul.

00:00:07.630 --> 00:00:10.450
&gt;&gt;Paul Kinlan: Hi.
&gt;&gt;Michael Mahemoff: We're talking today about

00:00:10.450 --> 00:00:15.890
mobile web development, how you can go from
a zero -- that's your very basic raw web app

00:00:15.890 --> 00:00:19.830
-- all the way up to a hero on the various
mobile devices.

00:00:19.830 --> 00:00:23.700
You can see up there we've got feedback links
and on the bottom of each slide we've got

00:00:23.700 --> 00:00:26.060
the link to Moderator, too, if you want to
ask any questions.

00:00:26.060 --> 00:00:37.670
So let's see. So HTML5 is here and it's mobile.
You've heard a lot about HTML5 today, of course,

00:00:37.670 --> 00:00:42.579
in the keynote and some of the other talks.
I'm not going to spend ages convincing you

00:00:42.579 --> 00:00:47.260
about the benefits and the power of HTML5.
What I will say, though, is that HTML5 is

00:00:47.260 --> 00:00:53.120
also here on the various mobile form factors.
Many phones today, and tablets and so on,

00:00:53.120 --> 00:00:59.809
they all support quite advanced HTML5 browsers
and run times, and we think that mobile is

00:00:59.809 --> 00:01:04.720
an awesome platform to be looking at if you
want to reach many of these users.

00:01:04.720 --> 00:01:10.420
Firstly, mobile is a very convenient form
factor for people. It's something that people

00:01:10.420 --> 00:01:15.310
can actually use when they're standing in
a line, when they're sitting on the couch

00:01:15.310 --> 00:01:20.781
or in the pool, as the case may be, and they've
always got it. And if you want your people

00:01:20.781 --> 00:01:24.900
to be always using your app, that's a great
way is to have it somewhere where it's always

00:01:24.900 --> 00:01:30.270
at the person's fingertips.
It's also a very personal sort of form factor.

00:01:30.270 --> 00:01:35.860
People tend to have one particular device
that they've always got with them at all times

00:01:35.860 --> 00:01:40.830
and they've got all their personal data and
all their friends and so on on it, so you

00:01:40.830 --> 00:01:44.700
get that kind of relationship with the user
by being on the device.

00:01:44.700 --> 00:01:50.770
Mobiles are also a very natural sort of form
factor these days. That wasn't always the

00:01:50.770 --> 00:01:55.810
case, but now the kind of device that we're
carrying around with us happens to be a device

00:01:55.810 --> 00:01:59.670
that's very much touch-based, and that's the
way that humans have always worked. We like

00:01:59.670 --> 00:02:04.869
to manipulate things with our hands. Much
more natural than being hunched over with

00:02:04.869 --> 00:02:11.330
this superficial kind of very recent -- in
the scale of things -- invention of a keyboard.

00:02:11.330 --> 00:02:17.180
So actually being able to hook into that and
actually working our apps to be natural and

00:02:17.180 --> 00:02:23.360
feel, that's sort of our tactile user interface,
is a big win.

00:02:23.360 --> 00:02:28.000
And probably the most important thing for
you guys as developers is the fact that mobile

00:02:28.000 --> 00:02:33.680
is an insanely popular platform at this time.
Many people here -- probably actually everyone

00:02:33.680 --> 00:02:39.010
here actually has at least two mobile devices,
as of yesterday, because you almost all have

00:02:39.010 --> 00:02:44.700
a mobile phone and you all now have a tablet
as well. And I'm guessing there are probably

00:02:44.700 --> 00:02:49.910
people here with five, six, and twelve mobile
devices. So that's just individuals, but there's

00:02:49.910 --> 00:02:54.680
also people across the whole world who don't
have any other computer device. The mobile

00:02:54.680 --> 00:03:00.004
is the main way they actually get connected
with the rest of the world.

00:03:00.004 --> 00:03:06.900
The flip side to all these great awesome benefits
of mobile is the development side of things

00:03:06.900 --> 00:03:12.590
can be a little bit of work.
You've got all these different platforms.

00:03:12.590 --> 00:03:15.379
We love Android, but it's not the only mobile
platform out there. There's still iOS, BlackBerry,

00:03:15.379 --> 00:03:24.030
and many more in this, you know, huge long
tail of mobile platforms out there.

00:03:24.030 --> 00:03:27.200
And especially so when you consider the various
form factors.

00:03:27.200 --> 00:03:32.849
This is not just about the phone that you
carry with you anymore. This is about the

00:03:32.849 --> 00:03:37.290
older phones that other people might be carrying
around, the traditional feature phones, and

00:03:37.290 --> 00:03:42.750
many of them do have some basic browsing capability.
We want to be able to reach those users too.

00:03:42.750 --> 00:03:47.330
And of course we want to scale up to those
very advanced mobile platforms that we have

00:03:47.330 --> 00:03:54.370
now like tablets.
HTML5 then presents itself as a promising

00:03:54.370 --> 00:04:00.349
opportunity, because the web runs on, as you
know, traditional form factors like desktops

00:04:00.349 --> 00:04:06.090
and notebooks and laptops. We've been running
browsers on these things for many years. But

00:04:06.090 --> 00:04:11.099
more recently, we've had the web running on
all these mobile form factors as well, from

00:04:11.099 --> 00:04:16.959
phones and the much more advanced smartphones
and tablets to the more exotic sort of devices

00:04:16.959 --> 00:04:21.910
like music players and eBook readers too.
Most of these kinds of devices, and certainly

00:04:21.910 --> 00:04:26.050
any phone that you would actually get these
days, any tablet, you would be astonished

00:04:26.050 --> 00:04:31.090
if it didn't have a browser, and in fact,
many of these browsers are based on engines

00:04:31.090 --> 00:04:37.470
like Webkit, very sophisticated, advanced
capabilities, and some of the benefits of

00:04:37.470 --> 00:04:43.770
performance and so on that we're actually
starting to see in the desktop as well.

00:04:43.770 --> 00:04:48.270
So HTML5 is a platform. It does all these
things. It does amazing user interfaces like

00:04:48.270 --> 00:04:52.970
you've seen today in the keynote. It does
-- the capabilities are actually behind of

00:04:52.970 --> 00:04:58.430
scenes as well, the sort of networking and
offline capabilities that have only been available

00:04:58.430 --> 00:05:02.970
to native apps until recently. We're starting
to get to a point where we're actually -- where

00:05:02.970 --> 00:05:08.480
we've got these comparable features in the
HTML5 stack.

00:05:08.480 --> 00:05:13.680
So it is an awesome opportunity to actually
take advantage of HTML5 to reach all of those

00:05:13.680 --> 00:05:18.440
mobile users and get all those benefits, but
we have to think about these two aspects,

00:05:18.440 --> 00:05:24.240
which is firstly user experience. We want
to hold our heads up high, as HTML developers.

00:05:24.240 --> 00:05:27.750
We want to actually be able to say, you know,
"Yeah, this is actually a really compelling,

00:05:27.750 --> 00:05:33.169
rich, multimedia experience, just like you're
used to on modern mobile devices," and at

00:05:33.169 --> 00:05:37.990
the same time, we're developers, right? We're
all developers here. We really care about

00:05:37.990 --> 00:05:42.729
making our life easier too. We don't want
to have to end up writing a million and one

00:05:42.729 --> 00:05:47.070
different apps for all of these different
form factors. We want to think about ways

00:05:47.070 --> 00:05:52.470
to optimize between these two forces of user
experience and developer experience.

00:05:52.470 --> 00:05:59.160
&gt;&gt;Paul Kinlan: So we've identified these kind
of six fundamental challenges that you as

00:05:59.160 --> 00:06:05.440
developers today face building these rich,
awesome user experiences for the mobile web.

00:06:05.440 --> 00:06:09.479
The first and probably one of the most important
is, you know, different interaction styles.

00:06:09.479 --> 00:06:14.039
How do you build applications and can you
build applications that work across all the

00:06:14.039 --> 00:06:17.740
different types of form factors that we mentioned
earlier? Can you build an application that

00:06:17.740 --> 00:06:23.240
works across the Opera Mini style devices
or tablets, smartphones, you know, the whole

00:06:23.240 --> 00:06:28.639
range? Is it possible just to build one application
that is deployed across all these different

00:06:28.639 --> 00:06:32.610
types of devices?
Users expect their applications to load in

00:06:32.610 --> 00:06:37.759
like pretty much instantly and respond quickly
to their, you know, gestures and commands.

00:06:37.759 --> 00:06:42.350
Is it possible to build applications that
-- you know, with the types of speed and interactivity

00:06:42.350 --> 00:06:46.000
that we get from the native platforms on the
mobile web?

00:06:46.000 --> 00:06:51.770
And we're all used to this. We've used our
web browser and we've been on a train or kind

00:06:51.770 --> 00:06:58.020
of a semipermanent Internet connection. We
just can't use our web browser. But is it

00:06:58.020 --> 00:07:03.210
actually possible to build applications that
work entirely when you're offline or in the

00:07:03.210 --> 00:07:07.340
cases where you've got this kind of intermittent
Internet connection?

00:07:07.340 --> 00:07:12.009
Each of these devices has a marketplace or
a store built directly into them, so, you

00:07:12.009 --> 00:07:16.569
know, how can we get our applications discovered
when we're building mobile Web applications?

00:07:16.569 --> 00:07:21.470
Is it possible?
If you look at the -- kind of the trend of

00:07:21.470 --> 00:07:27.060
browser development, you'll notice that the
primary input mechanisms has always been keys

00:07:27.060 --> 00:07:32.220
and mouse, but with all these new types of
devices primarily being touch-based, can we

00:07:32.220 --> 00:07:37.479
build applications that aren't just responsive
to kind of the single presses but the rich

00:07:37.479 --> 00:07:42.161
gestures that we expect from native applications.
So is that possible on the mobile web today?

00:07:42.161 --> 00:07:48.759
And we kind of have to forget about the different
form factors. Is it possible to build applications

00:07:48.759 --> 00:07:53.759
that are responsive to the variety of different
screen sizes that we see? In just one class

00:07:53.759 --> 00:07:56.490
of device -- say smartphones or even tablets
-- they've all got different -- fundamentally

00:07:56.490 --> 00:08:03.440
different size screens and resolutions. Can
we build applications that, you know, look

00:08:03.440 --> 00:08:07.539
great on all these types of devices?
So I have a question for you all. Raise your

00:08:07.539 --> 00:08:11.721
hand if you think we can solve every single
one of these challenges today on the mobile

00:08:11.721 --> 00:08:15.900
web.
I've got a couple of people.

00:08:15.900 --> 00:08:18.699
&gt;&gt;Michael Mahemoff: A lot of confidence here.
&gt;&gt;Paul Kinlan: So we can accept that. We can

00:08:18.699 --> 00:08:24.301
expand that a little bit easier. Can we solve
any of these challenges today on the mobile

00:08:24.301 --> 00:08:27.870
web?
A couple more people.

00:08:27.870 --> 00:08:30.000
Well, no, we can't.
&gt;&gt;Michael Mahemoff: Sorry.

00:08:30.000 --> 00:08:34.260
[Laughter]
&gt;&gt;Paul Kinlan: So we have 45 minutes for questions.

00:08:34.260 --> 00:08:36.570
Has anyone got any?
[Laughter]

00:08:36.570 --> 00:08:41.060
&gt;&gt;Paul Kinlan: You know, of course we can
solve these problems, and we're here today

00:08:41.060 --> 00:08:46.040
to try and educate you in ways that, you know,
we think we can build these applications to

00:08:46.040 --> 00:08:52.230
take advantage of all the latest modern advancements
in web browse technology, but also kind of

00:08:52.230 --> 00:08:56.190
give that, you know, user experience that
users expect from applications, regardless

00:08:56.190 --> 00:08:59.680
of whether they're native or whether they're
actually on the web platform.

00:08:59.680 --> 00:09:03.570
So I would like to introduce an application
we've written today called IO Reader. It's

00:09:03.570 --> 00:09:09.740
a special demo application just for today.
The code will be live at the end of this presentation.

00:09:09.740 --> 00:09:14.880
And essentially it's a news reading application.
It embodies all of the -- kind of the problems

00:09:14.880 --> 00:09:19.450
that we face on the mobile web today. We want
our applications to work offline but most

00:09:19.450 --> 00:09:24.700
Web applications don't, and we think we've
built our application to solve all these challenges.

00:09:24.700 --> 00:09:28.630
It's built using all the modern web technologies
that we as, you know, kind of progressive

00:09:28.630 --> 00:09:34.070
web developers use today, so things like node
and Modernizer and everything. And without

00:09:34.070 --> 00:09:37.339
much further ado, we're going to jump into
a demo.

00:09:37.339 --> 00:09:43.950
So we've built this application. It's on the
mobile -- the smartphone form factor, and

00:09:43.950 --> 00:09:46.519
if you've seen -- oh, here we go. Move it
up.

00:09:46.519 --> 00:09:49.779
If you've ever seen the news and weather native
application, you'll notice it looks quite

00:09:49.779 --> 00:09:52.920
familiar.
We have the traditional kind of scroll inside

00:09:52.920 --> 00:09:58.070
the application. And then we can also embed
your click-on and read an article. We have

00:09:58.070 --> 00:10:03.990
the nice gesture support so we can fling articles.
The really cool thing about this is we're

00:10:03.990 --> 00:10:09.070
actually using consistent URLs throughout
this whole application structure, so we can

00:10:09.070 --> 00:10:17.970
take advantage of some native capabilities
such as share. So we can share individual

00:10:17.970 --> 00:10:21.920
pieces of functionality or pages from our
Web app, the kind of things that everyone

00:10:21.920 --> 00:10:26.880
expects from Web apps. We just built this
application to take advantage of that.

00:10:26.880 --> 00:10:32.329
We have nice usage of the browser-based back
button, and as you'll see, we didn't actually

00:10:32.329 --> 00:10:36.560
reload the page. The whole user experience
was contained inside our application. It just

00:10:36.560 --> 00:10:40.399
kind of works really nicely.
We've got the ability, also, to take advantage

00:10:40.399 --> 00:10:46.380
of gestures like the gestures that we see
on these native platforms like swipes.

00:10:46.380 --> 00:10:51.810
And then we've also got some nice little piece
of -- hopefully this will work -- yeah. So

00:10:51.810 --> 00:10:55.300
we've got a refresh functionality. The kind
of things that we're starting to see in the

00:10:55.300 --> 00:11:00.230
-- say the mobile native platforms for, say,
refreshing and reloading data, we've built

00:11:00.230 --> 00:11:03.540
that into this application, too.
It also supports device orientation changes,

00:11:03.540 --> 00:11:10.950
so again, we can still swipe between the articles.
It's just a really nice example of an application

00:11:10.950 --> 00:11:17.480
which we've built just using plain HTML JavaScript
that works across smartphones.

00:11:17.480 --> 00:11:23.300
But as we said before, the mobile web isn't
just about smartphones and building applications

00:11:23.300 --> 00:11:29.670
that work on phones. It's also about tablets.
So the same application with the exact same

00:11:29.670 --> 00:11:35.709
HTML, 90% of the same JavaScript, is targeted
to the tablet form factor, and as you can

00:11:35.709 --> 00:11:40.591
see, it's -- well, the functionality is equivalent
to the application that we had. We had the

00:11:40.591 --> 00:11:46.410
categories and articles. We had the dynamic
loading of data into the articles, so it's

00:11:46.410 --> 00:11:52.089
quick and responsive to your commands. But
it's definitely optimized for the tablet experience

00:11:52.089 --> 00:11:58.110
so we can go through these articles. The really
cool thing is, we had an engineer from the

00:11:58.110 --> 00:12:01.540
Mountain View office build this application.
Mike actually built the smartphones application

00:12:01.540 --> 00:12:08.740
as well. And we didn't have to talk to each
other too much.

00:12:08.740 --> 00:12:13.029
But, yeah, we have this tablet application.
It looks absolutely beautiful.

00:12:13.029 --> 00:12:14.029
&gt;&gt;Michael Mahemoff: So I'm going to shift
back here.

00:12:14.029 --> 00:12:18.589
So we actually just went through those six
challenges that we've identified as the main

00:12:18.589 --> 00:12:22.649
challenges we think HTML5 developers need
to solve if they want to actually make their

00:12:22.649 --> 00:12:30.980
apps work nicely on the mobile, and we've
shown you these apps here, smartphone and

00:12:30.980 --> 00:12:37.720
tablet. So we want to take you through now,
how have we solved each of these six challenges.

00:12:37.720 --> 00:12:42.800
And the first of those challenges is dealing
with different interaction styles.

00:12:42.800 --> 00:12:46.930
We want to actually make sure that we're actually
looking at different form factors, like the

00:12:46.930 --> 00:12:52.310
phone versus the tablet, as not just about
the fact that we've got extra screen width

00:12:52.310 --> 00:12:56.639
or extra resolution, but actually about the
sorts of interactions people have come to

00:12:56.639 --> 00:13:00.230
expect. I think you've already seen that with
the phone, that it's the sort of thing you

00:13:00.230 --> 00:13:03.950
can just get quick information, click and
do something. The tablet sort of interface

00:13:03.950 --> 00:13:09.550
is more about exploring and you get pictures
and it's that sort of more browsing experience,

00:13:09.550 --> 00:13:13.139
a bit more of a relaxed experience.
And our intuition is, we want to go across

00:13:13.139 --> 00:13:18.760
the board with each of our form factors writing
separate UIs and separate actually mini applications

00:13:18.760 --> 00:13:25.590
based on the common core.
We start with the principle that we just have

00:13:25.590 --> 00:13:30.399
HTML. This is really how the web is supposed
to work. It's supposed to work as structured,

00:13:30.399 --> 00:13:35.750
semantic content, and with HTML5 we get extra
structure. We can actually have these tags

00:13:35.750 --> 00:13:40.470
like header and section, which are -- give
a bit more meaning to what's actually on the

00:13:40.470 --> 00:13:45.029
page. And this, in itself, is a great thing.
This is actually what is sitting on the Internet

00:13:45.029 --> 00:13:48.970
for this app. And when you've got that content
sitting on the Internet, people can make use

00:13:48.970 --> 00:13:54.230
of it. You've already got a kind of API without
having to go and deliberately create one,

00:13:54.230 --> 00:13:58.120
and it's something that people can make use
of and it's great for SEO and for accessibility.

00:13:58.120 --> 00:14:03.480
And it's also great for people who have these
older kind of browsers as well. Anyone here

00:14:03.480 --> 00:14:11.230
use Lynx? Okay. A few fans.
So this is the real version of Lynx here,

00:14:11.230 --> 00:14:16.880
so we've got our app sitting in Lynx and let
me see. I can open up an article and it's

00:14:16.880 --> 00:14:21.470
quite readable from just a very basic browser.
So our idea is that we can go all the way

00:14:21.470 --> 00:14:28.400
up from the zero browser to the hero browser.
Likewise, we can actually do this with mobile

00:14:28.400 --> 00:14:33.899
as well, so we've got another demo here on
Opera Mini.

00:14:33.899 --> 00:14:40.700
And Opera Mini, if you don't know, is a very
basic sort of browser that does a lot of image

00:14:40.700 --> 00:14:44.970
compression and strips a lot of JavaScript
to make it a very minimal experience for people

00:14:44.970 --> 00:14:49.240
who don't have high bandwidth.
So our app works nicely on that too.

00:14:49.240 --> 00:14:55.389
Sorry. It's not very well lit up there, but
hopefully you can see that.

00:14:55.389 --> 00:14:59.310
And same thing. You can then open up individual
articles.

00:14:59.310 --> 00:15:04.010
So all based on that principle that you have
just some bit of common markup and the whole

00:15:04.010 --> 00:15:10.690
thing works nicely without any JavaScript
at all.

00:15:10.690 --> 00:15:14.199
But that's not -- the benefit of that is not
just about the fact that there are people

00:15:14.199 --> 00:15:18.160
using these browsers like Lynx and Opera Mini,
it is also about just the fact that that's

00:15:18.160 --> 00:15:23.220
how we've architected our applications. We
actually start with that common base and then

00:15:23.220 --> 00:15:28.690
each of those layers can actually build on
top of that. So, you know, that's our idea.

00:15:28.690 --> 00:15:34.029
Here we use this principle of progressive
enhancement from the basic app. So we go from

00:15:34.029 --> 00:15:39.209
that very basic app, add these extra layers,
to actually make it a compelling experience

00:15:39.209 --> 00:15:41.860
and one that's relevant to each of the form
factors.

00:15:41.860 --> 00:15:48.110
We use the principle of feature detection
to actually see if a single feature is there.

00:15:48.110 --> 00:15:52.589
If we can use it, then we will actually go
ahead and use it on this browser.

00:15:52.589 --> 00:15:57.949
That's kind of the point about when we say
that HTML5 runs so-called everywhere, it is

00:15:57.949 --> 00:16:01.699
not a magic bullet much. It is not like saying
you just create your app once and it will

00:16:01.699 --> 00:16:06.740
magically work everywhere. That can sometimes
be the case. It is more about recognizing

00:16:06.740 --> 00:16:11.630
that you have got this common stack of technologies
running on all of these different devices.

00:16:11.630 --> 00:16:16.040
And if you can put a little bit of intelligence
in your app about dealing with these different

00:16:16.040 --> 00:16:20.399
types of devices, then you get the benefit
of all the re-use of that common code base

00:16:20.399 --> 00:16:26.579
and the fact that you only have to learn about
one set of widgets and one language.

00:16:26.579 --> 00:16:30.980
But we're going beyond the idea of feature
detection in this talk, and we are introducing

00:16:30.980 --> 00:16:37.250
a concept that we're calling form factor detection.
And our intuition being, that you can't just

00:16:37.250 --> 00:16:42.410
algorithm away the distinction between a mobile
and a desktop and a TV. You want just say,

00:16:42.410 --> 00:16:46.861
Oh, we are dealing with a TV now, so we will
just add an extra 27 columns to our reader

00:16:46.861 --> 00:16:50.220
app.
It is more about understanding what are the

00:16:50.220 --> 00:16:55.490
users trying to do with a TV. It is a lean-back,
more of a lazy, perhaps a social experience.

00:16:55.490 --> 00:17:00.910
With a phone, it is, I want the information
now. With a desktop, it is something you might

00:17:00.910 --> 00:17:06.130
spend hours and hours working on. So you have
to have qualitatively different sorts of interfaces

00:17:06.130 --> 00:17:10.880
for this but you don't want to have a million
different interfaces for every model and every

00:17:10.880 --> 00:17:14.330
device.
We are trying to go for this happy medium

00:17:14.330 --> 00:17:18.949
here with the idea of a form factor and actually
acknowledging that that's really the thing

00:17:18.949 --> 00:17:24.509
that we want to be targeting.
So we created this library called formfactorjs

00:17:24.509 --> 00:17:28.870
which, basically, does the best job it can
to detect what's the current form factor this

00:17:28.870 --> 00:17:33.030
app is running in.
If it is a phone, then it will run -- it will

00:17:33.030 --> 00:17:38.010
load these libraries and JavaScript and CSS.
And if it is a desktop, it will load these

00:17:38.010 --> 00:17:44.370
other ones so you can build these small layers.
That's what we're aiming for, is a big core

00:17:44.370 --> 00:17:48.390
of common logic. You have already seen it
with the phone and the tablet. They are using

00:17:48.390 --> 00:17:54.270
the same markup. They have the same content
for doing things -- or the same code for doing

00:17:54.270 --> 00:17:59.160
things like retrieving the actual articles
that you have seen on the reader, retrieving

00:17:59.160 --> 00:18:05.490
the categories, caching them, actually being
aware of what the user is doing. All of that

00:18:05.490 --> 00:18:09.710
is actually common code, and we create these
small layers -- we love to call them awesome

00:18:09.710 --> 00:18:16.110
layers -- for just very specific code that's
relevant to the user interface.

00:18:16.110 --> 00:18:19.600
So this is the kind of thing you'll see if
you actually look at one of those awesome

00:18:19.600 --> 00:18:26.270
layers. It is the phone, JavaScript and it
is able to respond to semantic events. That's

00:18:26.270 --> 00:18:32.169
the contract that you have to conform to in
our architecture if you want to actually respond

00:18:32.169 --> 00:18:36.480
to events like when the users just change
the category, when the users change the article.

00:18:36.480 --> 00:18:40.360
You can't actually jump in. You can't actually
provide some custom JavaScript. But a lot

00:18:40.360 --> 00:18:46.990
of that is taken care by the common code on
both the client and the server.

00:18:46.990 --> 00:18:52.940
On the HTML and CSS side, we also have a patent
we use where we actually identify that there

00:18:52.940 --> 00:18:58.230
are particular states in our apps. As well
as having distinct form factors, within each

00:18:58.230 --> 00:19:03.060
-- within our app, we have distinct states.
We go from a menu state where you're seeing

00:19:03.060 --> 00:19:07.580
all of the categories and maybe a welcome
screen to a category state where you are looking

00:19:07.580 --> 00:19:12.309
at a single category like music and technology.
And then we go to an individual article when

00:19:12.309 --> 00:19:17.679
you are actually reading the article.
Whether you are looking at the phone or the

00:19:17.679 --> 00:19:22.419
tablet or even the very basic interfaces,
you've always got those three states. Again,

00:19:22.419 --> 00:19:27.500
the contract is if you are writing a layer,
you're going to fill in the CSS for how the

00:19:27.500 --> 00:19:32.880
app should look in that state. And by putting
that class on the route element, you can actually

00:19:32.880 --> 00:19:39.990
define the entire CSS for your app, the entire
style of each component in the CSS for that

00:19:39.990 --> 00:19:44.270
particular user interface for that particular
form factor.

00:19:44.270 --> 00:19:49.770
And we see that here. This is the kind of
CSS you'll see for the phone, where it's doing

00:19:49.770 --> 00:19:53.960
things like if we're in the article state,
then we'll show the active article with overflow

00:19:53.960 --> 00:19:58.990
visible. So we actually show the extra content
and so on and so forth. We create all that

00:19:58.990 --> 00:20:02.090
style for each of those states. That's what
you can do.

00:20:02.090 --> 00:20:05.620
If you have already written the phone layer
and you are going on to create the tablet

00:20:05.620 --> 00:20:09.929
layer, it is very straightforward. You know
exactly what you have to do. You just basically

00:20:09.929 --> 00:20:14.760
fill in what do I need to do when I'm responding
to those events on the JavaScript slide and

00:20:14.760 --> 00:20:22.440
what's the CSS like on the HTML and CSS side.
We actually use a framework called LESS instead

00:20:22.440 --> 00:20:28.350
of raw CSS. LESS is one of several frameworks
going around right now that's a kind of CSS++.

00:20:28.350 --> 00:20:33.950
It is not a complete new language. It adds
a little bit of syntactic sugar that we found

00:20:33.950 --> 00:20:41.330
very convenient for this sort of architecture.
You can see here, you can do what you can't

00:20:41.330 --> 00:20:48.270
do in normal CSS, which is you can actually
have a hierarchy, pretty intuitive. It is

00:20:48.270 --> 00:20:49.270
just the same as having article state before
all of those things.

00:20:49.270 --> 00:20:54.559
Another benefit of these high-level CSS frameworks
is we have the idea of macros. So no more

00:20:54.559 --> 00:20:58.720
repeating the same color code 27 times in
your style sheet. We can actually have a single

00:20:58.720 --> 00:21:03.710
color palette style sheet. We can then reuse
that across all of the different form factors.

00:21:03.710 --> 00:21:07.299
If we want to tweak our branding, we can just
do that all in one place.

00:21:07.299 --> 00:21:13.270
&gt;&gt;Paul Kinlan: How do we build applications
that are quick, nearly instant to load and

00:21:13.270 --> 00:21:18.600
then respond rapidly to the user's gestures
and commands? Well, we built our application

00:21:18.600 --> 00:21:23.150
as a single-page app.
The theory being behind this is we don't want

00:21:23.150 --> 00:21:28.500
to have the user transition between Article
A, Article B and then have a five-second delay

00:21:28.500 --> 00:21:32.360
with a white screen of the application doing
nothing. It kind of really breaks that whole

00:21:32.360 --> 00:21:37.190
user experience and isn't something that you
see in native applications.

00:21:37.190 --> 00:21:41.000
Single-page apps aren't actually a new concept.
If you have been doing a lot of kind of AJAX

00:21:41.000 --> 00:21:45.490
development recently in the past ten years,
eight years, you will be used to this type

00:21:45.490 --> 00:21:50.770
of thing. It is really good on mobile-style
devices because you don't exactly know what

00:21:50.770 --> 00:21:54.929
type of network you are dealing with it. It
would be a low-latency network, WiFi connection,

00:21:54.929 --> 00:21:58.740
or a high-latency network.
Single-page applications, they keep all the

00:21:58.740 --> 00:22:05.090
logic and functionality inside that one page,
but incrementally they are all data. You just

00:22:05.090 --> 00:22:08.730
manage it through JavaScript. It is nothing
amazingly special, but it really improves

00:22:08.730 --> 00:22:14.710
that whole user experience.
As you saw earlier on from the Lynx demo,

00:22:14.710 --> 00:22:21.210
our whole DOM, our whole object model for
this application is -- it is semantically

00:22:21.210 --> 00:22:25.090
defined. So it is consistent across all these
browsers.

00:22:25.090 --> 00:22:29.640
The main thing that you will notice is when
we saw in the Lynx demo you navigate from

00:22:29.640 --> 00:22:35.409
article to another article. That navigation
is just handled by a normal Lynx.

00:22:35.409 --> 00:22:39.340
So what you do with a browser that supports
JavaScript and you want to keep them inside

00:22:39.340 --> 00:22:44.601
this single-page app, again it is a very similar
thing. If you have ever used a JQuery, you

00:22:44.601 --> 00:22:50.090
basically just hijack the browser click, do
some of your custom business logic, so in

00:22:50.090 --> 00:22:53.630
this case a fetch article, and then just prevent
the default action from occurring.

00:22:53.630 --> 00:22:57.059
I mean, we have been doing these things for
quite a while. It is just one of those nice

00:22:57.059 --> 00:23:01.900
little things that we did inside our application
that really just makes this whole experience

00:23:01.900 --> 00:23:07.170
kind of cohesive and inside that one page.
But the question that everyone asks when you

00:23:07.170 --> 00:23:11.870
build these single-page apps is, well, single-page
apps break the Web because they don't allow

00:23:11.870 --> 00:23:18.870
you to deep link. They very rarely keep the
state inside the URL. We kind of solved that

00:23:18.870 --> 00:23:24.770
by playing -- expanding our use of the history
API. So it is kind of worth going through

00:23:24.770 --> 00:23:28.679
the history -- a brief history of history,
I suppose, of how actual browsers have managed

00:23:28.679 --> 00:23:33.920
navigation over the last couple of years.
In 2,000 when we were all building our Pearl

00:23:33.920 --> 00:23:38.830
apps and everything, we had a URL structure
that normally closely mimicked the directory

00:23:38.830 --> 00:23:44.450
and file -- the directory and file structure.
So you would have a category and inside that

00:23:44.450 --> 00:23:47.280
category you might say, Well, this is a list
of technology articles and the server would

00:23:47.280 --> 00:23:52.150
actually render that out and send it to the
client. As AJAX took off and we started building

00:23:52.150 --> 00:23:56.870
applications which were pretty much inside
this single-page container, we still wanted

00:23:56.870 --> 00:24:03.760
to have the ability to bookmark individual
pieces of state. So you would use the hash-tag

00:24:03.760 --> 00:24:07.980
or -- the hash-tag, sorry, that's a Twitterrism.
You would use a document fragment syntax that's

00:24:07.980 --> 00:24:11.880
there to kind of indicate some state and make
it bookmarkable.

00:24:11.880 --> 00:24:15.679
But the problem obviously with using the document
fragment is that the server never sees this

00:24:15.679 --> 00:24:19.539
data so your application can't be built by
the server in its entirety. You will load

00:24:19.539 --> 00:24:24.850
it in the browser and then the browser will
go and fetch some data.

00:24:24.850 --> 00:24:29.820
Again, not only because the server can't respond
with all the data upfront, the search engines

00:24:29.820 --> 00:24:33.789
are having a whole lot of trouble actually
being able to actually parse the data in a

00:24:33.789 --> 00:24:41.140
consistent manner. So some search engines
try to standardize on a common format for

00:24:41.140 --> 00:24:46.650
using a document fragment syntax to indicate
a particular bit of state inside your browser.

00:24:46.650 --> 00:24:51.510
But that wasn't great. But if you look at
the URLs that, say, modern Web developers

00:24:51.510 --> 00:24:58.159
are using today, they look pretty much exactly
the same as they did in 2000. What is the

00:24:58.159 --> 00:25:02.789
difference between now and then? Well, the
main difference is that use of the HTML5 history

00:25:02.789 --> 00:25:09.270
API. It is a really simple API. It, basically,
allows you to change the URL of the browser

00:25:09.270 --> 00:25:15.270
purely from the client's side.
As you can see from this code here, it is

00:25:15.270 --> 00:25:18.809
a simple command called push state. Basically
you give the browser the URL you want it to

00:25:18.809 --> 00:25:24.980
be on the screen, the title so it looks nice
when you bookmark it, and maybe some application-specific

00:25:24.980 --> 00:25:30.000
states. We didn't need any particular JavaScript
objects inside our app pushed into the history

00:25:30.000 --> 00:25:33.299
but you can do that.
And then as the user is navigating around

00:25:33.299 --> 00:25:37.039
the application using forwards and backwards
buttons, there is an event that fires pop

00:25:37.039 --> 00:25:41.679
state, which essentially you just hook into
here. And in our application, we just chose

00:25:41.679 --> 00:25:45.470
to listen to the document location. You can
actually do whatever you want inside this

00:25:45.470 --> 00:25:50.710
function. We just said, Well, we're going
to look at document location, parse it out

00:25:50.710 --> 00:25:54.539
and then go and fetch the category data. So
if the URL match business, we would fetch

00:25:54.539 --> 00:25:59.380
the business data.
But especially in user application, you never

00:25:59.380 --> 00:26:04.130
know all of the URLs that your application
will encompass. You might know all the categories,

00:26:04.130 --> 00:26:09.909
but you won't know every single article. So
managing your code like this isn't great.

00:26:09.909 --> 00:26:12.990
So we made a framework called Leviroutes.
It is on Getup as well.

00:26:12.990 --> 00:26:19.140
We made a framework called Leviroutes, which
is basically a URL routing framework. If you

00:26:19.140 --> 00:26:24.770
have ever used App Engine or Ruby On Rails,
the syntax is relatively similar. It, basically,

00:26:24.770 --> 00:26:30.101
allows to you define specific URL types inside
your JavaScript, inside your client and then

00:26:30.101 --> 00:26:35.010
respond to them with your own kind of custom
business logic. So in our case if the article

00:26:35.010 --> 00:26:39.220
looks like a category -- or the URL, sorry,
looks like a category, we go and fetch the

00:26:39.220 --> 00:26:43.710
category data. And then if the article -- sorry,
I keep saying this. If the URL looks like

00:26:43.710 --> 00:26:48.870
an article, we then go and fetch the article
data. It's actually pretty simple, but it

00:26:48.870 --> 00:26:55.990
allows you to keep -- keep your application-specific
logic to a minimum and just make it very readable.

00:26:55.990 --> 00:27:02.110
So we saw from the Lynx demo we were rendering
data from the server. All the application

00:27:02.110 --> 00:27:07.870
data, in our case categories and articles
is being generated by the server. But also

00:27:07.870 --> 00:27:12.440
at the same time, we had these really rich
interactive applications on, say, the smartphone

00:27:12.440 --> 00:27:17.809
and tablet where all the data was located
into the client at one time. So that presents

00:27:17.809 --> 00:27:20.900
a problem.
You need to have potentially two templates,

00:27:20.900 --> 00:27:25.550
manage them in potentially different languages,
whether it is Python and Pearl and then on

00:27:25.550 --> 00:27:29.250
the client side in JavaScript. How did you
go about doing it?

00:27:29.250 --> 00:27:35.200
We used a basic technique called dual-side
templating, and we combine that with a framework

00:27:35.200 --> 00:27:40.279
called Mustache which, basically, allows you
to maintain one common template across client

00:27:40.279 --> 00:27:43.539
and server.
As long as your data format is consistent

00:27:43.539 --> 00:27:47.040
throughout your entire application, you can
basically just render the same data. It substitutes

00:27:47.040 --> 00:27:52.721
all the variable names, renders some nice
HTML and then you present that to the client.

00:27:52.721 --> 00:28:02.100
Sorry.
&gt;&gt;Michael Mahemoff: Okay. So we are actually

00:28:02.100 --> 00:28:07.049
talking about offline here. You already saw
some of the offline apps mentioned in the

00:28:07.049 --> 00:28:13.049
keynote today, like "New York Times" reader
and "Sports Illustrated" was mentioned. So

00:28:13.049 --> 00:28:16.260
this is possible now on the Web. There are
technologies that let us do it. And fortunately

00:28:16.260 --> 00:28:22.160
enough for us, there are technologies that
allow us to do it in the phones and mobile

00:28:22.160 --> 00:28:25.820
devices as well.
You've actually just seen these apps actually

00:28:25.820 --> 00:28:31.390
work offline on the various devices.
The first of those technologies -- And there

00:28:31.390 --> 00:28:36.799
is really two of them that work side by side.
The first is AppCache. And this is the ability

00:28:36.799 --> 00:28:41.380
to actually store the entire application logic
on the device, just like you would install

00:28:41.380 --> 00:28:47.770
an app from the Android market. It would be
sitting there on your device. It will be there

00:28:47.770 --> 00:28:52.440
even when the user is not connected.
To use AppCache, it is really straightforward

00:28:52.440 --> 00:28:57.390
actually. In the basic case, you just link
to the cache manifest file from your HTML

00:28:57.390 --> 00:29:04.049
tag. And in the cache manifest, you simply
list all of the assets of your app. And those

00:29:04.049 --> 00:29:07.480
-- that's the JavaScript, the CSS images and
so on.

00:29:07.480 --> 00:29:13.620
The first time the user visits your app, the
browser will download all of the assets you've

00:29:13.620 --> 00:29:18.350
listed in the manifest. And the next time
they visit it, it will immediately serve those

00:29:18.350 --> 00:29:23.420
assets. It won't even check to the server
at all. It will actually work offline.

00:29:23.420 --> 00:29:28.390
Every time you do visit, if you are online,
it will keep checking and it will download

00:29:28.390 --> 00:29:33.179
in the background all the new assets whenever
that one file changes. So if you are connected,

00:29:33.179 --> 00:29:37.440
all that ever happens is just a single request
to see if the cache manifest has changed.

00:29:37.440 --> 00:29:42.010
And if you are offline, the application keeps
working as normal.

00:29:42.010 --> 00:29:47.309
The other side of this is storing actually
data which might be, for instance, an email

00:29:47.309 --> 00:29:51.080
the user is composing. In this case, it is
actually articles you've read. We've kept

00:29:51.080 --> 00:29:58.730
it pretty simple here. We've used LocalStorage,
which is a very basic, easy-to-use API. It

00:29:58.730 --> 00:30:03.390
gives you, basically, just a JavaScript object.
LocalStorage, you can use it. You can treat

00:30:03.390 --> 00:30:07.890
it as just a JavaScript object where you can
say, localstorage.food equals bar and later

00:30:07.890 --> 00:30:13.440
on you retrieve it with localstorage.food.
And that's an object that only your domain

00:30:13.440 --> 00:30:19.470
can see. No other Web apps can get hold of
that, read it and write it, and it's a very

00:30:19.470 --> 00:30:24.200
simple interface. That's why there are also
these other ones that have actually got more

00:30:24.200 --> 00:30:29.290
complexity to them. They give you the benefits
of speed and so on, but not quite as simple.

00:30:29.290 --> 00:30:34.669
So we've got that with Web SQL database. It's
basically an entire SQL database sitting in

00:30:34.669 --> 00:30:39.460
the browser. You can imagine that's going
to be quite complex. It does have great performance

00:30:39.460 --> 00:30:44.279
characteristics in terms of being able to
search for a lot of data or being able to

00:30:44.279 --> 00:30:50.500
just do things asynchronously, which is the
way a lot of the Web apps work.

00:30:50.500 --> 00:30:55.191
But that's actually being deprecated, so it
is actually quite widely supported as well

00:30:55.191 --> 00:31:03.000
in the current -- because it's in Webkit,
it's actually in the two apps that you've

00:31:03.000 --> 00:31:04.750
actually -- or the two devices you've already
seen here, but at the same time it is being

00:31:04.750 --> 00:31:07.289
deprecated. It's never made it to mainstream
use across all of the desktop browsers.

00:31:07.289 --> 00:31:11.980
So what now seems to be the way of the future
is indexed database. It's already there in

00:31:11.980 --> 00:31:18.540
Chrome and in FireFox on the desktop and hopefully
it will make its way to the mobile browsers

00:31:18.540 --> 00:31:21.580
soon, and it kind of gives you the best of
both worlds. A lot of simplicity you get from

00:31:21.580 --> 00:31:27.140
local storage, but the speed and performance
characteristics of Web SQL.

00:31:27.140 --> 00:31:33.809
&gt;&gt;Paul Kinlan: So we said for each of these
devices they have a marketplace, a store built

00:31:33.809 --> 00:31:39.919
in, for users to go and find applications.
Luckily, the web is no different. But let's

00:31:39.919 --> 00:31:45.110
just kind of jump back to our idea of having
a consistent common URL structure.

00:31:45.110 --> 00:31:49.400
It's really important. We can't stress it
enough. If you combine a consistent URL structure

00:31:49.400 --> 00:31:54.470
across your app on the client side and the
server side using the HTML history and potentially

00:31:54.470 --> 00:32:00.020
the dual side templating, it's really easy
for search engines to go and aggregate your

00:32:00.020 --> 00:32:03.940
content. If it's entirely client side application,
it's really hard for search engines to be

00:32:03.940 --> 00:32:09.000
able to go and do the job that they do best
and deliver users to your application.

00:32:09.000 --> 00:32:14.390
But it's not always about just search engines.
You know, each of these devices do have native

00:32:14.390 --> 00:32:18.529
marketplaces on.
You can use services such as Phonegap, for

00:32:18.529 --> 00:32:25.290
instance, to actually just package your application
-- package your application up into, you know

00:32:25.290 --> 00:32:29.530
-- using an existing Web application, you
can use it, package it up, and then deliver

00:32:29.530 --> 00:32:34.039
it into these native marketplaces.
But again, it's not just about native devices.

00:32:34.039 --> 00:32:37.950
There are a lot of different web stores.
If you're building a desktop application -- I

00:32:37.950 --> 00:32:40.690
think Seth was talking about it yesterday,
or there was a talk about it yesterday about

00:32:40.690 --> 00:32:44.220
the Web Store. Chrome Web Store is a great
place for you to go and get your applications

00:32:44.220 --> 00:32:50.440
discovered. But from the mobile context, there
are a lot of third-party, you know, web stores

00:32:50.440 --> 00:32:53.230
available. It's just relatively easily to
get into them as well.

00:32:53.230 --> 00:32:56.799
So we have a whole range, a whole spectrum
of different ways to get your application

00:32:56.799 --> 00:33:00.340
discovered from traditional search engines.
The power of the web is that these search

00:33:00.340 --> 00:33:03.909
engines can index your data, but then you
can also go a little bit more native.

00:33:03.909 --> 00:33:10.710
&gt;&gt;Michael Mahemoff: Touch. We want to get
our apps working with touch the same way the

00:33:10.710 --> 00:33:13.340
native apps do, and it's amazing when you
think about these gestures, things like swiping

00:33:13.340 --> 00:33:17.700
and pinch-to-zoom.
When you use a device these days, they feel

00:33:17.700 --> 00:33:22.190
so natural but they've only been around for
a couple of years, so it's -- it is something

00:33:22.190 --> 00:33:24.940
that actually just works with the way we think
as humans, and I think we want to be able

00:33:24.940 --> 00:33:30.010
to cooperate with that thinking and actually
implement that in our apps.

00:33:30.010 --> 00:33:34.500
Fortunately, we have this, again, with HTML5,
and you've seen it in the IO Reader layers,

00:33:34.500 --> 00:33:38.450
the ones that are actually specifically related
to touch devices.

00:33:38.450 --> 00:33:45.480
We have this with touch events. So we don't
have to work around this like the earlier

00:33:45.480 --> 00:33:51.730
browsers were doing with your old-school mouse
events. You've actually got built-in touch

00:33:51.730 --> 00:33:57.559
support with events like touchstart and touchend.
As far as those gestures, those things like

00:33:57.559 --> 00:34:02.360
swiping and fling and pinch zoom, those are
starting to come into the standard. They're

00:34:02.360 --> 00:34:07.220
not all there yet. So what we did in in this
app is we created a little library to help

00:34:07.220 --> 00:34:12.790
with it that would actually detect when the
user's done a significant swipe action, significant

00:34:12.790 --> 00:34:16.159
enough to actually register and respond to
it.

00:34:16.159 --> 00:34:21.520
So this is actually a little library where
you attach it to an object, also jQuery based,

00:34:21.520 --> 00:34:24.909
and it actually will fire when the user's
actually done that swipe action in one direction

00:34:24.909 --> 00:34:28.720
and let go, whether it's horizontal or vertical.
It also fires as the user is moving, moving

00:34:28.720 --> 00:34:35.149
their fingers back and forth, so that you
actually saw the stories being swiped back

00:34:35.149 --> 00:34:40.389
and forth on the phone, or up and down, so
we actually can respond to that as the user

00:34:40.389 --> 00:34:45.540
is doing it, which is a much better way to
design user interfaces than five seconds later.

00:34:45.540 --> 00:34:50.339
And we can also do click, which is what happens
when the user opens the article, and long

00:34:50.339 --> 00:34:54.950
hold. We need to implement those things, because
if we're capturing all the touch events, they

00:34:54.950 --> 00:35:01.130
won't always fire, the actual built-in click
event won't always fire, so we need the library

00:35:01.130 --> 00:35:06.610
to do the whole thing.
We actually found it really convenient to

00:35:06.610 --> 00:35:11.520
develop a lot of this app on the desktop,
even in the case of the phone API -- or the

00:35:11.520 --> 00:35:15.800
phone form factor, because the desktop is
where you're actually coding, so it's really

00:35:15.800 --> 00:35:20.970
easy to be able to switch windows and see
how the app is working. And it's also where

00:35:20.970 --> 00:35:26.620
you can actually take advantage of tools like
the Chrome dev tools to actually do your debugging.

00:35:26.620 --> 00:35:32.619
So to that end, we actually built into this
library a few switches to make sure that it

00:35:32.619 --> 00:35:38.320
will work nicely with mouse events as well,
if there is no touch support there.

00:35:38.320 --> 00:35:40.700
And also, just a tip about debugging is you
can actually debug on the device. We were

00:35:40.700 --> 00:35:46.880
doing that in the later stages of this project
and with Android it's actually really easy.

00:35:46.880 --> 00:35:49.480
There's an URL up there where I've just put
a few steps in. Just to attach your device

00:35:49.480 --> 00:35:56.349
by USB or you can do the same thing on the
emulator and you just have to run a couple

00:35:56.349 --> 00:36:00.410
of commands and in a couple of minutes you've
actually got console logging there. You can

00:36:00.410 --> 00:36:04.680
log your own messages and you can also see
error messages coming from the browsing environment.

00:36:04.680 --> 00:36:11.780
Just a final note and a bit of a caveat on
this whole area of touch interfaces.

00:36:11.780 --> 00:36:18.090
It's really easy to fall into the so-called
uncanny valley. It's a term from robotics

00:36:18.090 --> 00:36:22.910
that means you've got kind of close to there,
but eerily slightly not there and something's

00:36:22.910 --> 00:36:27.869
just a little bit off.
So the recommendation here is: Try to stay

00:36:27.869 --> 00:36:32.060
right away from that. If you don't think you're
going to get very close, you know, just make

00:36:32.060 --> 00:36:36.430
something that's very different. There are
many successful apps you can see on the various

00:36:36.430 --> 00:36:42.040
mobile marketplaces which are a very idiosyncratic
interface. You see a lot of games that devise

00:36:42.040 --> 00:36:45.820
their own mechanisms for menus and so on.
It is actually possible to do that. You don't

00:36:45.820 --> 00:36:50.580
have to emulate the native look and feel.
But -- so if you're going to do that, you

00:36:50.580 --> 00:36:54.940
know, stay clear away from it. If you're going
to do what we've tried to do here, we recommend,

00:36:54.940 --> 00:36:58.530
you know, trying to take the time to make
it as close as possible so you don't end up

00:36:58.530 --> 00:37:04.849
in that weird middle ground.
&gt;&gt;Paul Kinlan: So we mentioned early on about

00:37:04.849 --> 00:37:08.849
the form factor detection and how the differing
like interaction styles that you have for

00:37:08.849 --> 00:37:14.240
the different types of devices is really important.
However, in each of those classes of devices,

00:37:14.240 --> 00:37:19.760
there are a whole multitude of -- you know,
of different screen sizes and, you know, different

00:37:19.760 --> 00:37:23.300
capabilities, and how do you actually build
your applications to cater to that.

00:37:23.300 --> 00:37:26.461
It's actually quite simple in the end.
The first thing that we did in our application

00:37:26.461 --> 00:37:32.210
was we defined a viewport. The viewport is
basically there to stop the existing web from

00:37:32.210 --> 00:37:39.079
completely breaking in mobile devices. So
it defines this kind of -- well, it basically

00:37:39.079 --> 00:37:44.340
tends to be like say a 1024-by-768 browser
so that the pages can render correctly, and

00:37:44.340 --> 00:37:48.690
then it will scale the page down to fit the
screen or allow you to zoom in and zoom out,

00:37:48.690 --> 00:37:54.070
so that you can pan around it, and not actually
have to have the web developer of the existing

00:37:54.070 --> 00:37:58.820
site, you know, cater especially to your device.
But when we're building these applications,

00:37:58.820 --> 00:38:03.630
we don't want that functionality, so it's
-- it's relatively easy. We're basically saying

00:38:03.630 --> 00:38:08.640
this virtual viewport has to be the exact
same size as the device width. And that basically

00:38:08.640 --> 00:38:13.460
allows you to get sometimes a near one-to-one
correspondence between physical device screen

00:38:13.460 --> 00:38:16.780
size and, you know, what's reported to your
application.

00:38:16.780 --> 00:38:23.140
But you still have the ability to enable zoom
and zoom-out and all the kind of traditional-based

00:38:23.140 --> 00:38:27.510
pinch-based gestures inside your application.
We chose not to do it in our application.

00:38:27.510 --> 00:38:32.130
We said, you know, we're like specifically
targeting smartphones. We're going to have

00:38:32.130 --> 00:38:37.070
to design our application to work well across
all these devices. We don't need to have zoom

00:38:37.070 --> 00:38:41.210
in and zoom out and the traditional, you know,
pinch gesture, so we've disabled it.

00:38:41.210 --> 00:38:47.150
But it's -- how do I say this? It's entirely
up to you. If you have an application which

00:38:47.150 --> 00:38:52.210
is suited to zoom in/zoom out and the native
-- you know, those native abilities, keep

00:38:52.210 --> 00:38:57.599
them in. We chose not to do it in our app.
And the next is media queries.

00:38:57.599 --> 00:39:02.040
With form factor detection, we're definitely
not trying to get rid of the idea of media

00:39:02.040 --> 00:39:05.100
queries. We're just trying to make it more
manageable for us to build applications that

00:39:05.100 --> 00:39:09.950
are responsive to the different screen sizes.
It's a lot easier to build an application

00:39:09.950 --> 00:39:15.190
that will respond to different smartphone
screen sizes or different tablet screen sizes

00:39:15.190 --> 00:39:20.760
than have to have one style that responds
to all of them at the same time.

00:39:20.760 --> 00:39:23.260
And media queries are just a great way to
build applications that are at least aware

00:39:23.260 --> 00:39:28.480
of the type of screen, the size screen, that
they're on, and in our case, when we showed

00:39:28.480 --> 00:39:32.460
the demo of the smartphone, we had two different
orientations, a portrait and a landscape.

00:39:32.460 --> 00:39:38.010
You can just target different CSS to say the
landscape mode. Maybe hide some images because

00:39:38.010 --> 00:39:42.460
you value vertical space. And then in the
portrait mode, you just go and show all the

00:39:42.460 --> 00:39:47.360
images because you've got a lot of vertical
space and there's a lot more freedom in that

00:39:47.360 --> 00:39:49.369
mode.
So we're actually getting quite close to the

00:39:49.369 --> 00:39:54.240
end.
It's -- so we're just kind of going -- all

00:39:54.240 --> 00:39:58.060
those images are gone. Cool.
[Laughter]

00:39:58.060 --> 00:39:59.920
So they're supposed to be nice text. We've
solved them. So we think we've done an okay

00:39:59.920 --> 00:40:04.170
job at solving, you know, these six different
interaction styles -- or six different problems

00:40:04.170 --> 00:40:07.780
of -- you know, that we face as mobile web
developers.

00:40:07.780 --> 00:40:11.410
The different interaction styles are managed
through form factor detection, so you can

00:40:11.410 --> 00:40:15.790
target specific user interaction styles to
the different types of devices.

00:40:15.790 --> 00:40:19.410
We've shown you how, you know, single-page
apps, traditional AJAX methods, can really

00:40:19.410 --> 00:40:24.589
help improve your application just by incrementally
loading the data and not having this jarring

00:40:24.589 --> 00:40:33.040
experience when you're navigating from one
page to the next. And then with --

00:40:33.040 --> 00:40:34.040
&gt;&gt;Michael Mahemoff: Are we going to do a relay
--

00:40:34.040 --> 00:40:36.160
&gt;&gt;Paul Kinlan: Yeah. No. Then using appcache,
not only can you make new application load,

00:40:36.160 --> 00:40:40.200
you know, instantly, you can just make it
work offline as well, and then if you combine

00:40:40.200 --> 00:40:44.760
that with local storage, you can at least
keep the data, you know, in memory and in

00:40:44.760 --> 00:40:49.040
browser, so that the user doesn't have that
experience of being completely offline.

00:40:49.040 --> 00:40:52.730
We can make our applications discoverable.
Things like the server side templating and

00:40:52.730 --> 00:40:56.940
the client side -- the dual side templating
technique we talked about allow you to render

00:40:56.940 --> 00:41:02.170
and present data to search engines really
efficiently, get that -- and get discovered.

00:41:02.170 --> 00:41:06.630
And then you can obviously use the native
frameworks as well to actually package your

00:41:06.630 --> 00:41:09.040
Web application.
We've shown you who you can build applications

00:41:09.040 --> 00:41:13.220
that are responsive not just to basic touch
commands but the gestures as well. There's

00:41:13.220 --> 00:41:16.730
a nice little library Mike wrote. And then
just using the viewport and media queries,

00:41:16.730 --> 00:41:21.620
we can actually build applications that are
responsive to the different screen sizes.

00:41:21.620 --> 00:41:26.640
&gt;&gt;Michael Mahemoff: So the idea here has not
been just about targeting the mobile devices,

00:41:26.640 --> 00:41:31.450
but about using this technology of HTML5 to
reach all of the different types of devices

00:41:31.450 --> 00:41:38.050
you might care for, to expose your services
to, to users, and to that end we've also got

00:41:38.050 --> 00:41:44.120
these other types of apps as well.
So we've got a desktop app. So this is not

00:41:44.120 --> 00:41:47.560
the desktop app. That's the TV app here, so
I'll show you the TV first.

00:41:47.560 --> 00:41:54.000
So this is actually where we've got the TV
where it's that experience where you're 10

00:41:54.000 --> 00:41:59.290
foot back, you want to just get a bit of an
overview about what the stories are. You can

00:41:59.290 --> 00:42:01.839
see them easily.
And taking -- taking into account the user

00:42:01.839 --> 00:42:05.280
interface on the input side and the output
side.

00:42:05.280 --> 00:42:10.020
So on the input side, I'm able to control
all of this. I can use a pointing device if

00:42:10.020 --> 00:42:14.460
I want, a mouse, but I'm able to control all
of it just with the keyboard with just the

00:42:14.460 --> 00:42:18.230
arrow keys, you know, which you would have
on a very basic remote control. So that's

00:42:18.230 --> 00:42:21.030
the input side only.
Output side, you can see how it gives you

00:42:21.030 --> 00:42:27.250
that very big overview.
And in the case of the desktop app -- ooooh.

00:42:27.250 --> 00:42:36.260
Have we got a problem? Okay. I'll leave it
to the screen shot. You can see that later.

00:42:36.260 --> 00:42:39.950
Some problems. Sometimes with the offlining,
it can be a problem where if it's a slow connection,

00:42:39.950 --> 00:42:43.099
which seems to be the case here, I think,
you can actually get something going, so -- oh,

00:42:43.099 --> 00:42:47.640
yeah, we can switch over to here.
So sometimes you'll get a situation where

00:42:47.640 --> 00:42:51.430
it downloads some of it but not all of it,
which we haven't optimized for, but you can

00:42:51.430 --> 00:42:55.030
see it here.
So you get -- again, you get the ability to

00:42:55.030 --> 00:42:58.670
use keyboard shortcuts which kind of fits
in with the natural style that people assume

00:42:58.670 --> 00:43:01.000
should be there on the desktop, as well as
the mouse.

00:43:01.000 --> 00:43:05.140
So again, it's that input style of keyboard
shortcuts and mouse, and the output style

00:43:05.140 --> 00:43:10.040
just taking advantage of all the features
of a standard desktop browser.

00:43:10.040 --> 00:43:13.770
Let's jump back.
And the point about this has been that we're

00:43:13.770 --> 00:43:18.270
able to develop this all quite independently
from one another, so we actually -- Paul did

00:43:18.270 --> 00:43:23.420
most of the work on the architecture and the
core logic of the app and each of us wrote

00:43:23.420 --> 00:43:27.609
the separate layers. Two of us were in London,
two of us were over here in Mountain View,

00:43:27.609 --> 00:43:31.930
and we didn't have to do that much communication
between each other, because it was just a

00:43:31.930 --> 00:43:35.020
standard contract for how we'd actually write
these apps.

00:43:35.020 --> 00:43:42.260
So you can see here, you know, the vast majority
of the logic in IO Reader is able to be reused.

00:43:42.260 --> 00:43:46.400
And I think that's about it.
So you can see the code's going online. The

00:43:46.400 --> 00:43:51.200
actual -- the actual news source that you
see, it's coming from the guardian API. It's

00:43:51.200 --> 00:44:02.310
probably going to be one too many hits for
their API if we leave that running, so it's

00:44:02.310 --> 00:44:06.200
really something where you can actually plug
in your own data source and you could actually

00:44:06.200 --> 00:44:10.339
do, you know, something for your own apps
or for any other kind of services that are

00:44:10.339 --> 00:44:12.370
on the web. That's a separate module that's
part of IO Reader on the server side. It's

00:44:12.370 --> 00:44:13.850
a node component that you can actually write
your own to get different sort of data. And

00:44:13.850 --> 00:44:15.290
there are various open source libraries as
well that we've used in here that you'll be

00:44:15.290 --> 00:44:20.800
able to see. When the slides come online,
you'll have those links.

00:44:20.800 --> 00:44:26.010
But for right now, we've got a link to Moderator.
I don't know, has anyone -- what we did. There's

00:44:26.010 --> 00:44:27.820
another one that doesn't work online. Maybe
we should switch to the link on there.

00:44:27.820 --> 00:44:30.079
&gt;&gt;Paul Kinlan: Should we give it a go?
&gt;&gt;Michael Mahemoff: Yeah. We're just going

00:44:30.079 --> 00:44:31.970
to jump to the link that we've got in the
slides.

00:44:31.970 --> 00:44:39.280
But meanwhile, we do have time for questions
and we're interested to know like if you've

00:44:39.280 --> 00:44:42.690
got any challenges you've come across or any
other tips. We'd like to hear about them.

00:44:42.690 --> 00:44:46.680
So please, if you've got questions, come up.
Otherwise, we'll look at Moderator as well

00:44:46.680 --> 00:44:48.630
in a moment, once we're back online.
&gt;&gt; Hi.

00:44:48.630 --> 00:44:53.060
&gt;&gt;Michael Mahemoff: Hi.
&gt;&gt; Can you talk about the interaction between

00:44:53.060 --> 00:45:00.150
the manifest file and which files are downloaded
compared to the script tags and the style

00:45:00.150 --> 00:45:07.240
tags that are in the head compared to the
-- that slide you showed with Modernizer which

00:45:07.240 --> 00:45:12.550
actually selects which styles --
&gt;&gt;Paul Kinlan: Yeah. So we actually -- we

00:45:12.550 --> 00:45:17.770
didn't have an amazing amount of scripts inside
our application, so each individual form factor

00:45:17.770 --> 00:45:22.619
is actually embedded in the one sheet.
So if you look at the code, it's maybe two

00:45:22.619 --> 00:45:27.340
lines -- two bits of JavaScript for smartphone,
two files for desktop, and we just downloaded

00:45:27.340 --> 00:45:33.700
all of them because it's relatively low latency
at the moment. This actually allows you to

00:45:33.700 --> 00:45:37.230
quickly flip in between the form factors and
not have to re-download any new assets and

00:45:37.230 --> 00:45:45.350
then validate your appcache.
&gt;&gt; And so does the manifest file -- all of

00:45:45.350 --> 00:45:47.859
those files get downloaded and they're all
referenced in the head as well?

00:45:47.859 --> 00:45:49.460
&gt;&gt;Paul Kinlan: Yeah, they're referenced -- well,
there are some core assets that are referenced

00:45:49.460 --> 00:45:55.890
from the head. The common controller is in
the head, and then each of the -- the -- like

00:45:55.890 --> 00:46:01.030
the phone JavaScript and the iPad -- or the
tablet JavaScript, at least, is referenced

00:46:01.030 --> 00:46:04.650
in the form factor loader.
Because it's on the server side, we have control

00:46:04.650 --> 00:46:07.510
over, you know, what's gets rendered where,
so we know all the files that are needed for

00:46:07.510 --> 00:46:10.740
the whole entire application, so they are
always available at the moment.

00:46:10.740 --> 00:46:16.119
&gt;&gt;Michael Mahemoff: Take one from Moderator.
&gt;&gt;Paul Kinlan: Yeah. Should we just do one

00:46:16.119 --> 00:46:21.000
from Moderator? Just pick the first one. JQuery,
mobile, SproutCore mobile, Sencha Touch, what's

00:46:21.000 --> 00:46:27.350
being used? In our application, we didn't
use anything specific. It was just all normal

00:46:27.350 --> 00:46:31.410
JavaScript.
Did you want to explain the differences?

00:46:31.410 --> 00:46:34.450
&gt;&gt;Michael Mahemoff: Briefly, the differences
between these three frameworks, I guess get

00:46:34.450 --> 00:46:39.030
JQuery mobile, it is a very new framework.
It has got a very permissive license. And

00:46:39.030 --> 00:46:45.080
it is very much like JQuery, very much a microkernel
with some very basic sort of widgets at the

00:46:45.080 --> 00:46:50.510
moment and the ability to do theming as well.
But it is very much a standard sort of open

00:46:50.510 --> 00:46:56.480
source project like JQuery.
The other two are more commercially backed.

00:46:56.480 --> 00:47:05.359
In fact, both of those, SproutCore and Sencha,
are here at I/O and Sandbox is, if you want

00:47:05.359 --> 00:47:10.099
to talk to them.
SproutCore is aiming to be an app where you

00:47:10.099 --> 00:47:19.560
can sort of write just HTML, focus on something
that might even be desktop-related or actually

00:47:19.560 --> 00:47:31.950
take advantage of some of their widgets and
then they are aiming to offer services on

00:47:31.950 --> 00:47:41.921
top of that. So I think it is a little bit
of a less commercial license because it is

00:47:41.921 --> 00:47:57.050
not jewel license like Sencha Touch. It also
has got the MIT license like JQuery. So you

00:47:57.050 --> 00:48:07.920
can use it however you want.
And then they are planning to sort of add

00:48:07.920 --> 00:48:17.200
extra services to it like being able to package
things up and distribute to stores and do

00:48:17.200 --> 00:48:23.020
caching and so on. Sencha Touch is starting
to become a very big commercial operation.

00:48:23.020 --> 00:48:31.309
You can still use it as a GPL3 license. They
have got some very sophisticated widgets available.

00:48:31.309 --> 00:48:33.930
So as always, horses to courses and check
them all out.

00:48:33.930 --> 00:48:39.400
&gt;&gt;&gt; My question is in regards to the offline
of a Web app. If I had an app where a user

00:48:39.400 --> 00:48:43.820
could post, let's say, information through
the Web app and they were offline, is there

00:48:43.820 --> 00:48:49.130
a method or a technology that then the device
or the app would recognize they are online

00:48:49.130 --> 00:48:54.910
and push that back to my site or the app?
&gt;&gt;Paul Kinlan: So that means each of the devices

00:48:54.910 --> 00:49:01.819
normal has an event, I think -- online is
an event on the document so you can at least

00:49:01.819 --> 00:49:11.200
tell when you're on. It doesn't work across
all devices because it depends on whether

00:49:11.200 --> 00:49:20.250
the network interface is up.
&gt;&gt;Michael Mahemoff: Actually, that originally

00:49:20.250 --> 00:49:34.200
wasn't supported on Chrome because they had
the intuition that you should actually just

00:49:34.200 --> 00:49:46.920
be trying to push it online. And if it doesn't
work, you handle the exception.

00:49:46.920 --> 00:49:57.920
&gt;&gt;Paul Kinlan: One thing we do do in our application
at least is we don't necessarily post any

00:49:57.920 --> 00:50:08.609
data, but we intercept every request as best
we can for fetching the data so we can then

00:50:08.609 --> 00:50:15.170
cache it. I think the same thing applies when
you are trying to post data. You can basically

00:50:15.170 --> 00:50:21.400
get the on-error states on XML HTTP request
and then respond to it that way and then just

00:50:21.400 --> 00:50:29.660
make sure the data is cached.
&gt;&gt;Michael Mahemoff: It makes a good point

00:50:29.660 --> 00:50:36.800
because we need more libraries to do this
sort of thing. We are starting to get some

00:50:36.800 --> 00:50:38.270
libraries like Lawn Chair and PersistJS that
will eventually have different layers probably

00:50:38.270 --> 00:50:41.960
to sort of fall back depending on what mechanism
is there for LocalStorage.

00:50:41.960 --> 00:50:47.460
What we need is actually higher-level libraries
that will do things like caching and syncing.

00:50:47.460 --> 00:50:53.300
They are not really there yet in JavaScript.
&gt;&gt;&gt; Thank you.

00:50:53.300 --> 00:51:09.530
&gt;&gt;&gt; This isn't a question. It is just a comment
about console.log. Console.log on Android

00:51:09.530 --> 00:51:27.160
is not universal to every single Android device.
For example, the HTC -- mostly HTC lines,

00:51:27.160 --> 00:51:33.560
not the dex one but the commercially available
HTC lines do not have console.log. That's

00:51:33.560 --> 00:51:39.520
why it is a good idea to actually develop
your mobile application in the emulator instead

00:51:39.520 --> 00:51:44.440
of the device in this one case.
&gt;&gt;Paul Kinlan: It is actually interesting.

00:51:44.440 --> 00:51:51.720
You can do About call on some of the Android
devices, and you can get -- if it supports

00:51:51.720 --> 00:52:00.180
console, you can actually get a console log
inside the application on the device as well.

00:52:00.180 --> 00:52:04.490
&gt;&gt;Michael Mahemoff: Right now you type about.debug
and use it to toggle or not.

00:52:04.490 --> 00:52:08.109
(Speaker off microphone.)
&gt;&gt;Michael Mahemoff: Let's take one from the

00:52:08.109 --> 00:52:11.170
Moderator. Next one: Is what's your take on
app versus mobile Web sites?

00:52:11.170 --> 00:52:14.300
&gt;&gt;Paul Kinlan: Depends on the content, I think.
&gt;&gt;Michael Mahemoff: It does, yeah.

00:52:14.300 --> 00:52:18.819
&gt;&gt;Paul Kinlan: If it is content-based, it
is a site. If it is functionality, then it

00:52:18.819 --> 00:52:23.400
is more app-like.
&gt;&gt;Michael Mahemoff: I think we are seeing

00:52:23.400 --> 00:52:32.520
the same thing. Paul and I have worked a lot
on the Chrome Web store. I think it is also

00:52:32.520 --> 00:52:57.390
about being aware of the fact that apps do
have special privileges. They can do things

00:52:57.390 --> 00:53:10.860
like inapp payments easily and maybe they've
got other ability to get involved with the

00:53:10.860 --> 00:53:14.140
hardware and so on. They can also communicate
back and forth.

00:53:14.140 --> 00:53:23.980
There are techniques that you can use on the
various platforms like the kinds of things

00:53:23.980 --> 00:53:47.170
Phone Gap does that let you communicate with
native capabilities. So if you actually do

00:53:47.170 --> 00:53:56.500
need to tune into those native capabilities.
You can do that with apps as well. I think

00:53:56.500 --> 00:54:06.530
there is always a role for Web sites.
And actually with phones, you got the ability

00:54:06.530 --> 00:54:17.030
to send a SMS with a link in it so it is really
convenient for people to just click on a link

00:54:17.030 --> 00:54:21.119
from an SMS as well as they might see it in
Twitter or something. All those things don't

00:54:21.119 --> 00:54:27.009
open in apps. They open in phones, so you
still need at least some mobile Web presence.

00:54:27.009 --> 00:54:33.230
&gt;&gt;&gt; I have a couple of questions. What's the
best way -- Normally you detect a difference

00:54:33.230 --> 00:54:37.830
between the phone and desktop. Like, usually
you use the user agent. So is that the best

00:54:37.830 --> 00:54:40.621
way or you go -- what is the best way to handle
it?

00:54:40.621 --> 00:54:42.920
&gt;&gt;Paul Kinlan: Yes, that's actually a very
good question. So how do you actually detect

00:54:42.920 --> 00:54:45.720
the differences between the devices? We've
actually used a combination of user agent

00:54:45.720 --> 00:54:47.540
string check-in in the JavaScript side of
things. But then specific media queries as

00:54:47.540 --> 00:54:51.411
well.
So the formfactorjs can take a whole lot of

00:54:51.411 --> 00:54:57.490
different expressions that will determine
whether it is a particular device class or

00:54:57.490 --> 00:55:00.180
not.
&gt;&gt;Michael Mahemoff: In the case of formfactorjs,

00:55:00.180 --> 00:55:05.690
we have left that kind of modular so it is
actually down to a community that doesn't

00:55:05.690 --> 00:55:09.330
yet exist. That would be the concept, you
would be able to have a whole grassroots collection.

00:55:09.330 --> 00:55:11.319
&gt;&gt;Paul Kinlan: Yeah. We have media queries
like TV and pretty much only TV support the

00:55:11.319 --> 00:55:16.359
media TV query. So you can basically use that
media query to say we definitely think you

00:55:16.359 --> 00:55:20.650
are on TV and then download these assets.
It is a combination.

00:55:20.650 --> 00:55:27.819
&gt;&gt;Michael Mahemoff: It is always a messy approach.
It is not very clean cut. That's why we also

00:55:27.819 --> 00:55:34.480
provide the ability to jump back to the standard
desktop app, and it's something that's a bit

00:55:34.480 --> 00:55:41.780
controversial doing this sort of thing.
We feel like the standard approaches that

00:55:41.780 --> 00:55:44.790
people talk about in terms of feature detection
and responsive Web design, they are just not

00:55:44.790 --> 00:55:45.790
enough to have quite distinct user interfaces
for these different form factors. Even if

00:55:45.790 --> 00:55:48.599
it is messy, we would rather have some sort
of guess about the form factor.

00:55:48.599 --> 00:55:52.359
&gt;&gt;&gt; Okay. And another question was, like,
normally in applications, if you have sort

00:55:52.359 --> 00:55:53.359
of an event where you click it, like it is
a map coordinate, you click it and it will

00:55:53.359 --> 00:55:54.359
launch a map UI. So say, for example, if I
were to develop something for picture, if

00:55:54.359 --> 00:55:55.359
someone clicks and holds on the picture, if
I want to raise to set as a a wallpaper or

00:55:55.359 --> 00:55:56.359
something like that, is there a way possible
right now?

00:55:56.359 --> 00:55:57.359
&gt;&gt;Paul Kinlan: That's kind of more Android
specific. I'm under the impression that the

00:55:57.359 --> 00:55:58.359
applications respond to when those intents
broadcast from inside within your Web application.

00:55:58.359 --> 00:55:59.359
The other way around, I don't think you can
-- I don't think -- it won't launch the browser

00:55:59.359 --> 00:56:00.359
naturally unless the browser is actually listening
to that intent.

00:56:00.359 --> 00:56:01.359
&gt;&gt;&gt; Maybe I didn't clarify. If I have a Web
application and I'm browsing, like, pictures,

00:56:01.359 --> 00:56:02.359
from that, is there a way, like, to have new
intents as to -- if some application is registered

00:56:02.359 --> 00:56:03.359
for, say, if you click on it, in the browser
itself and then you want to set it as -- you

00:56:03.359 --> 00:56:04.359
want to crop that wallpaper or set that as
a wallpaper, can you do that?

00:56:04.359 --> 00:56:05.359
&gt;&gt;Michael Mahemoff: Not that I know of. You
just have the ability what we show, which

00:56:05.359 --> 00:56:06.359
is the share feature. That's as far as I know.
There are standards so there are standard

00:56:06.359 --> 00:56:07.359
protocols for doing things like launching
the phone, if you want to show a phone number,

00:56:07.359 --> 00:56:08.359
you can do a tel prefix and so on but not
in a general sense as far as I know.

00:56:08.359 --> 00:56:09.359
&gt;&gt;&gt; Thank you.
&gt;&gt;Michael Mahemoff: Thank you. Maybe time

00:56:09.359 --> 00:56:10.359
for one more question.
&gt;&gt;Paul Kinlan: Should we do one more question

00:56:10.359 --> 00:56:11.359
from here.
&gt;&gt;Michael Mahemoff: And then we'll wrap up.

00:56:11.359 --> 00:56:12.359
&gt;&gt;Paul Kinlan: A good example out there of
a real-life HTML5 implementation that runs

00:56:12.359 --> 00:56:13.359
on desktop, phone and tablet with offline
capability? Gmail seems like a poster child

00:56:13.359 --> 00:56:14.359
more than any others.
So Gmail doesn't. IO Reader? That's a great

00:56:14.359 --> 00:56:15.359
--
&gt;&gt;Michael Mahemoff: Yeah. I think the "real

00:56:15.359 --> 00:56:16.359
life" was intended there for a reason.
&gt;&gt;Paul Kinlan: Yeah. Exactly. So this is one

00:56:16.359 --> 00:56:17.359
of the things that we're trying to do. We're
trying to reach developers and help them build

00:56:17.359 --> 00:56:18.359
applications this way because I don't think
that many people are building those types

00:56:18.359 --> 00:56:19.359
of apps at the moment.
&gt;&gt;Michael Mahemoff: I'll give you a couple

00:56:19.359 --> 00:56:20.359
of examples. One interesting one to look at
is bit.ly, bit.ly's own app. It works nicely

00:56:20.359 --> 00:56:21.359
on the mobiles. It does canvas graphics to
actually generate charts, which is basically

00:56:21.359 --> 00:56:22.359
the same thing it does on the desktop, and
it seems to be quite natural on both of those.

00:56:22.359 --> 00:56:23.359
And also look at Netflix. There's a long article
on Function Source Log recently about how

00:56:23.359 --> 00:56:24.359
Netflix is targeting over 400 different types
of devices with HTML5. It's not really the

00:56:24.359 --> 00:56:25.359
same app but it is actually the fact that
they are using the same technology stack,

00:56:25.359 --> 00:56:26.359
again and again, based on HTML5 and actually
they're specifically aiming it keep it within

00:56:26.359 --> 00:56:27.359
Webkit.
&gt;&gt;Paul Kinlan: Actually, can I answer one

00:56:27.359 --> 00:56:28.359
about the pushstate? We've got a question
about is the window.pushstate history manipulation

00:56:28.359 --> 00:56:29.359
supported on all major platforms or is it
just a feature for future applications?

00:56:29.359 --> 00:56:30.359
It's not supported on every single platform
at the moment. Webkit has got a really good

00:56:30.359 --> 00:56:31.359
coverage of pushstate. The reason why we created
a wrapper library is because we can't always

00:56:31.359 --> 00:56:32.359
rely on the fact -- or this routes framework,
we can't always rely on the fact that pushstate

00:56:32.359 --> 00:56:33.359
is supported.
So the application -- if you use Lynx, you'd

00:56:33.359 --> 00:56:34.359
see it use the document fragment to indicate
active articles and things like that, so the

00:56:34.359 --> 00:56:35.359
whole routing framework can take advantage
of on-hash change or just normal on-load events

00:56:35.359 --> 00:56:36.359
as well to actually detect the current state
of the application. So we haven't got full

00:56:36.359 --> 00:56:37.359
coverage. I think more browsers are going
to support it because this -- I mean, literally

00:56:37.359 --> 00:56:38.359
it's the fact that you can have a single consistent
URL structure on the server side. On the client

00:56:38.359 --> 00:56:39.359
side, it just makes it so powerful.
&gt;&gt;Michael Mahemoff: Okay. So let's take one

00:56:39.359 --> 00:56:40.359
final question from the audience here and
then we'll wrap up.

00:56:40.359 --> 00:56:41.359
&gt;&gt; Thanks. How are you using Mustache? Were
you actually sending different markup to each

00:56:41.359 --> 00:56:42.359
client and like transporting JSON or was it
all CSS based?

00:56:42.359 --> 00:56:43.359
&gt;&gt;Paul KinlanActually, we've got the same
consistent HTML DOM structure throughout the

00:56:43.359 --> 00:56:44.359
whole of the application and across all the
different types of devices.

00:56:44.359 --> 00:56:45.359
Moustache was just there to -- when we get
data back from the article. So we will go

00:56:45.359 --> 00:56:49.599
and make a request to the guardian API, and
it's in its own format, and we -- we've like

00:56:49.599 --> 00:56:53.470
munched that into a consistent object model
for our side.

00:56:53.470 --> 00:56:57.960
If it's an AJAX request, it's JSON to the
client and then rendered using that same template

00:56:57.960 --> 00:57:01.410
that is held on the server side, and the server
is -- again, because it's all node and it's

00:57:01.410 --> 00:57:05.040
a JSON object, we just basically render the
same thing.

00:57:05.040 --> 00:57:08.960
&gt;&gt;Michael Mahemoff: But the reason we use
Mustache -- because it's all node, we could

00:57:08.960 --> 00:57:12.119
have used anything, right? Because it's actually
Javascript on either side.

00:57:12.119 --> 00:57:16.220
We just used Mustache really as a proof of
concept. We wanted to show that even if we

00:57:16.220 --> 00:57:20.220
did our server in Python or whatever, we'd
still be able to use that same pattern of

00:57:20.220 --> 00:57:25.500
taking the same data structure, but on the
server the data structure is like a raw data

00:57:25.500 --> 00:57:32.140
structure. It's not really represented as
a string of JSON. It's just a data structure

00:57:32.140 --> 00:57:33.140
that gets pushed into the Mustache library.
Whereas on the browser, it is actually JSON

00:57:33.140 --> 00:57:40.351
that gets pulled down by XHR and processed
on demand as the user actually requests that

00:57:40.351 --> 00:57:41.940
content.
Yeah. I think we're done. Okay.

00:57:41.940 --> 00:57:43.770
&gt;&gt;Paul Kinlan: Thank you.
&gt;&gt;Michael Mahemoff: Thank you.

00:57:43.770 --> 00:57:43.990
%%%Chuck3end

