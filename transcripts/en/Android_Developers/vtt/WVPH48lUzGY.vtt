WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.470
[MUSIC PLAYING]

00:00:06.916 --> 00:00:08.398
[APPLAUSE]

00:00:12.472 --> 00:00:13.680
ADAM POWELL: Hello, everyone.

00:00:13.680 --> 00:00:15.520
Good morning, and
welcome to Fragments

00:00:15.520 --> 00:00:17.660
In An Architecture
Components World.

00:00:17.660 --> 00:00:21.290
So over time, Fragment
APIs have kind of evolved.

00:00:21.290 --> 00:00:23.462
And as of the release of
Architecture Components,

00:00:23.462 --> 00:00:24.920
a lot of people
have been asking us

00:00:24.920 --> 00:00:27.299
questions like, how do all
these things fit together?

00:00:27.299 --> 00:00:29.840
So hopefully, we'll be able to
answer some of those questions

00:00:29.840 --> 00:00:31.080
today.

00:00:31.080 --> 00:00:33.500
But first, just a
little bit of history.

00:00:33.500 --> 00:00:35.600
The Fragment APIs go back to--

00:00:35.600 --> 00:00:38.360
2010 was when they were
first initially written,

00:00:38.360 --> 00:00:42.140
2011 when they hit a little bit
more widespread availability.

00:00:42.140 --> 00:00:44.420
And really, it kind of
comes down to the idea

00:00:44.420 --> 00:00:46.250
that at the very
beginning, everybody just

00:00:46.250 --> 00:00:47.625
kind of started
with the activity

00:00:47.625 --> 00:00:49.579
when you were writing
an Android app.

00:00:49.579 --> 00:00:51.620
It was kind of your main
method with a lifecycle.

00:00:51.620 --> 00:00:54.410
It's the entry point to your
application from the system.

00:00:54.410 --> 00:00:56.150
The launcher will
launch your activity.

00:00:56.150 --> 00:01:00.620
You get all the onCreate,
onStart, Resume, et cetera,

00:01:00.620 --> 00:01:04.019
events that you
all know and love.

00:01:04.019 --> 00:01:05.200
It'll create views for you.

00:01:05.200 --> 00:01:07.070
It creates the window,
gives you a place

00:01:07.070 --> 00:01:09.200
to inflate your view
hierarchy where you do

00:01:09.200 --> 00:01:11.360
most of your UI work.

00:01:11.360 --> 00:01:13.460
It binds the view content
from your app state.

00:01:13.460 --> 00:01:15.720
Or at least this is where
people tended to do it.

00:01:15.720 --> 00:01:18.350
Keep in mind that this was
fairly early on in Android's

00:01:18.350 --> 00:01:19.910
public lifecycle here.

00:01:19.910 --> 00:01:22.602
Everybody kind of had this
habit of piling everything

00:01:22.602 --> 00:01:24.560
into one activity, because
apps were a lot more

00:01:24.560 --> 00:01:27.240
simple than they are today.

00:01:27.240 --> 00:01:30.110
And of course, you listen to
UI events and update that app

00:01:30.110 --> 00:01:32.580
state from there as well.

00:01:32.580 --> 00:01:34.520
So there are so many
incoming events,

00:01:34.520 --> 00:01:36.770
it really kind of became
this plumbing exercise

00:01:36.770 --> 00:01:38.790
to try to break it up yourself.

00:01:38.790 --> 00:01:43.760
So people ended up with these
very monolithic activities.

00:01:43.760 --> 00:01:45.500
And then something
else happened, too.

00:01:45.500 --> 00:01:47.730
Android tablets kind
of became a thing.

00:01:47.730 --> 00:01:50.330
So we kind of thought, how
do you make a tablet UI?

00:01:50.330 --> 00:01:53.459
Well, you take one phone UI,
you take another phone UI,

00:01:53.459 --> 00:01:56.000
and you smack them together,
and you have a tablet UI, right?

00:01:56.000 --> 00:01:57.394
I mean, what could go wrong?

00:01:57.394 --> 00:01:59.060
So we needed to answer
this question of,

00:01:59.060 --> 00:02:02.090
how do I stick two phone
UIs together and make sure

00:02:02.090 --> 00:02:04.689
that it still works on a phone?

00:02:04.689 --> 00:02:06.980
And Fragments were kind of
our answer to this question.

00:02:10.020 --> 00:02:12.620
So as an example
here, this approach

00:02:12.620 --> 00:02:14.750
actually worked pretty
well for some applications.

00:02:14.750 --> 00:02:16.620
Gmail is a great example.

00:02:16.620 --> 00:02:18.740
So if you take a look
here, you have the list

00:02:18.740 --> 00:02:22.340
of conversations to your
current conversation

00:02:22.340 --> 00:02:24.020
that you're taking a look at.

00:02:24.020 --> 00:02:25.910
And there's not a
whole lot of difference

00:02:25.910 --> 00:02:27.847
here between the
phone version that you

00:02:27.847 --> 00:02:29.930
drill into versus something
that you can show side

00:02:29.930 --> 00:02:31.240
by side in a two pane UI.

00:02:35.990 --> 00:02:37.550
So Fragments were
really designed

00:02:37.550 --> 00:02:39.260
to make sure that you
could do one thing,

00:02:39.260 --> 00:02:42.960
and that was to allow splitting
up these huge activity classes.

00:02:42.960 --> 00:02:44.779
This was something
that, again, we

00:02:44.779 --> 00:02:46.820
were seeing the pain that
developers were feeling

00:02:46.820 --> 00:02:48.486
that their activity
classes were getting

00:02:48.486 --> 00:02:50.040
really big and hard to manage.

00:02:50.040 --> 00:02:52.130
So we wanted to
see, could we allow

00:02:52.130 --> 00:02:54.890
for you to decouple some
of the various things

00:02:54.890 --> 00:02:57.530
that your activity classes
are doing to sort of relieve

00:02:57.530 --> 00:02:59.580
a little bit of that pressure?

00:02:59.580 --> 00:03:01.670
So that means that anything
a Fragment can do--

00:03:01.670 --> 00:03:04.010
or anything an Activity
can do, a Fragment

00:03:04.010 --> 00:03:05.410
had to be able to do, too.

00:03:05.410 --> 00:03:07.310
And that guided a whole
lot of the API design

00:03:07.310 --> 00:03:09.260
from the beginning.

00:03:09.260 --> 00:03:11.840
So that meant that you needed
to have lifecycle events.

00:03:11.840 --> 00:03:14.480
That meant that you needed
to be able to manage a view

00:03:14.480 --> 00:03:16.099
hierarchy.

00:03:16.099 --> 00:03:17.890
It meant that you needed
to be able to deal

00:03:17.890 --> 00:03:19.340
with saved instance state.

00:03:19.340 --> 00:03:22.280
So packaging everything up
into a bundle or a parcelables

00:03:22.280 --> 00:03:24.920
so that if your application
got killed in the background,

00:03:24.920 --> 00:03:28.520
you could restore from
that in a clean way.

00:03:28.520 --> 00:03:31.490
And other things as well, like
non-configuration instance

00:03:31.490 --> 00:03:32.630
object passing.

00:03:32.630 --> 00:03:34.790
And that's always kind of
a mouthful, but I mean,

00:03:34.790 --> 00:03:37.400
this is kind of the way that
you can pass any old object back

00:03:37.400 --> 00:03:40.670
and forth across a configuration
change that doesn't actually

00:03:40.670 --> 00:03:43.160
kill your process.

00:03:43.160 --> 00:03:44.940
Back stacks were
another really big one.

00:03:44.940 --> 00:03:47.570
Because suddenly if you were
dealing with a single activity

00:03:47.570 --> 00:03:49.739
where you were navigating
between fragments,

00:03:49.739 --> 00:03:52.030
we wanted to make sure that
we preserved that same back

00:03:52.030 --> 00:03:53.446
stack behavior
that you're used to

00:03:53.446 --> 00:03:57.720
from just calling start
activity from screen to screen.

00:03:57.720 --> 00:04:01.020
So along the way, we
asked the question,

00:04:01.020 --> 00:04:02.870
can we fix some other
APIs that were really

00:04:02.870 --> 00:04:05.850
kind of a pain in the
neck in Android to use?

00:04:05.850 --> 00:04:08.660
On retained non-configuration
instance-- again,

00:04:08.660 --> 00:04:10.730
kind of a mouthful.

00:04:10.730 --> 00:04:12.350
This method kind of
had some problems,

00:04:12.350 --> 00:04:14.480
because you only got
one object that you

00:04:14.480 --> 00:04:18.500
could pass from activity
instance to activity instance.

00:04:18.500 --> 00:04:20.720
We didn't give you any
easy or standardized way

00:04:20.720 --> 00:04:23.280
to multiplex different
objects together.

00:04:23.280 --> 00:04:25.986
So for example, if you were
composing multiple libraries,

00:04:25.986 --> 00:04:27.610
we didn't give you
a whole lot of help.

00:04:27.610 --> 00:04:30.980
This was all boilerplate that
you had to write yourself.

00:04:30.980 --> 00:04:34.850
Activity show dialog, does
anybody remember this?

00:04:34.850 --> 00:04:35.480
A few people.

00:04:35.480 --> 00:04:37.305
OK.

00:04:37.305 --> 00:04:38.930
IAN LAKE: Please
forget it immediately.

00:04:38.930 --> 00:04:40.880
ADAM POWELL: Please
forget it, yeah.

00:04:40.880 --> 00:04:44.300
So this was essentially a way
to get the activity itself

00:04:44.300 --> 00:04:47.150
to sort of do something
that we knew was missing

00:04:47.150 --> 00:04:48.800
and kind of a pain in the neck.

00:04:48.800 --> 00:04:53.000
This allowed you to make the
activity on the other side

00:04:53.000 --> 00:04:54.950
after a configuration
change, the new instance

00:04:54.950 --> 00:04:58.405
of your activity re-show what
is semantically the same dialog.

00:05:01.130 --> 00:05:04.220
We also had this thing, Local
Activity Manager, TabHost.

00:05:04.220 --> 00:05:06.890
Does anybody remember this one?

00:05:06.890 --> 00:05:11.420
Wow, that is a lot more hands
than I thought I would see.

00:05:11.420 --> 00:05:13.740
Some of you might remember
this from, for example,

00:05:13.740 --> 00:05:17.030
the original Dialer and Contacts
app back in kind of the Android

00:05:17.030 --> 00:05:18.560
2.0 days.

00:05:18.560 --> 00:05:22.250
And as you've swapped between
tabs between the normal number

00:05:22.250 --> 00:05:24.825
pad and your contact list
or call log, et cetera,

00:05:24.825 --> 00:05:26.450
those were actually
separate activities

00:05:26.450 --> 00:05:29.090
showing within a smaller
window within an activity.

00:05:29.090 --> 00:05:31.520
This idea of nesting
activities was something

00:05:31.520 --> 00:05:33.819
that we started
offering very early.

00:05:33.819 --> 00:05:35.360
It had a lot of
other issues, though.

00:05:35.360 --> 00:05:37.490
Activities made a
whole lot of promises

00:05:37.490 --> 00:05:39.230
that Local Activity
Manager had a lot

00:05:39.230 --> 00:05:40.522
of trouble trying to uphold.

00:05:40.522 --> 00:05:42.980
So we wanted to try and tighten
that interface a little bit

00:05:42.980 --> 00:05:45.830
better for something
composable like Fragments that

00:05:45.830 --> 00:05:47.420
would be able to
do the same thing

00:05:47.420 --> 00:05:51.224
but with a little bit
more expected behavior.

00:05:51.224 --> 00:05:51.890
IAN LAKE: Right.

00:05:51.890 --> 00:05:55.640
So this whole idea of being
able to break up your activity

00:05:55.640 --> 00:05:58.610
and make it into kind
of composable pieces.

00:05:58.610 --> 00:06:01.130
We had this giant
monolith of an activity,

00:06:01.130 --> 00:06:04.310
and there's other methods
of kind of factoring it out

00:06:04.310 --> 00:06:05.340
into different pieces.

00:06:05.340 --> 00:06:08.250
But for Fragments,
basically the approach

00:06:08.250 --> 00:06:12.860
was you move that loosely
related code, those view

00:06:12.860 --> 00:06:16.910
and all of the state around that
view into a separate fragment.

00:06:16.910 --> 00:06:19.280
And you basically
just keep doing this

00:06:19.280 --> 00:06:21.020
until you've kind
of segmented out

00:06:21.020 --> 00:06:23.090
your activity into
something that

00:06:23.090 --> 00:06:25.140
looks slightly more reasonable.

00:06:25.140 --> 00:06:27.050
You may have a couple
of fragments in here

00:06:27.050 --> 00:06:31.130
that kind of have their
own specific requirements

00:06:31.130 --> 00:06:32.870
and their own specific UI.

00:06:32.870 --> 00:06:36.830
And your activity just becomes
more of a shell for this.

00:06:36.830 --> 00:06:40.130
But soon after we started
getting into this,

00:06:40.130 --> 00:06:43.090
and when it came up to around
Jelly Bean, people were like,

00:06:43.090 --> 00:06:46.160
but this isn't enough.

00:06:46.160 --> 00:06:48.710
What if one of my Fragments
has a ViewPager in it

00:06:48.710 --> 00:06:52.200
that also has Fragments
as each one of its pages?

00:06:52.200 --> 00:06:54.770
So we get into
this, all right, now

00:06:54.770 --> 00:06:58.380
let's break up the Fragments
into smaller pieces.

00:06:58.380 --> 00:07:00.800
So of course, the
only way, well,

00:07:00.800 --> 00:07:05.900
if Fragments aren't enough, then
you just add more Fragments.

00:07:05.900 --> 00:07:08.840
In this case, child
Fragments became a thing.

00:07:08.840 --> 00:07:10.730
So now each one
of these Fragments

00:07:10.730 --> 00:07:14.640
could then be broken
up into smaller pieces.

00:07:14.640 --> 00:07:18.080
So this allowed us to kind of,
again, kind of decouple things.

00:07:18.080 --> 00:07:20.030
And we built a lot
of code around trying

00:07:20.030 --> 00:07:25.010
to make this nested state
work really well to varying

00:07:25.010 --> 00:07:27.770
levels of degree of success.

00:07:27.770 --> 00:07:31.410
But it's gotten a
lot better over time.

00:07:31.410 --> 00:07:35.690
So with these things in mind,
every one of those Fragments,

00:07:35.690 --> 00:07:39.320
whether it's a small thing
just managing a view,

00:07:39.320 --> 00:07:42.590
or if it's a retained
instance Fragment,

00:07:42.590 --> 00:07:44.990
every single one
of these Fragments

00:07:44.990 --> 00:07:47.240
give you lifecycle hooks.

00:07:47.240 --> 00:07:49.820
Every single one of them
has back stack management

00:07:49.820 --> 00:07:51.500
associated with them.

00:07:51.500 --> 00:07:54.950
Every single one of them
has a retained object

00:07:54.950 --> 00:07:58.100
that it can do across
configuration changes.

00:07:58.100 --> 00:08:00.440
And all of them are
stored statefully

00:08:00.440 --> 00:08:02.200
in your Fragment Manager.

00:08:02.200 --> 00:08:05.750
That means that the
existence of that Fragment

00:08:05.750 --> 00:08:08.520
is actually part of
the state of your app.

00:08:08.520 --> 00:08:10.970
So when your app
dies and comes back,

00:08:10.970 --> 00:08:13.020
that existence in
the Fragment Manager

00:08:13.020 --> 00:08:15.680
is actually a really
important part that, at least

00:08:15.680 --> 00:08:17.360
from Fragment's
perspective, that we're

00:08:17.360 --> 00:08:20.720
going to do on your behalf.

00:08:20.720 --> 00:08:23.180
And of course, they all
have their own ability

00:08:23.180 --> 00:08:25.260
to have a view subtree.

00:08:25.260 --> 00:08:29.600
So that piece of your UI
that they manage themselves.

00:08:29.600 --> 00:08:31.460
And of course, we
also allow things

00:08:31.460 --> 00:08:33.950
like Fragments being
inflatable and put right

00:08:33.950 --> 00:08:38.840
into your XML files and
be able to re-use them

00:08:38.840 --> 00:08:40.120
across multiple layouts.

00:08:40.120 --> 00:08:42.169
And again, this is
also kind of hooking

00:08:42.169 --> 00:08:44.600
into these same processes.

00:08:44.600 --> 00:08:51.800
But the biggest issue we found
is that all these Fragments

00:08:51.800 --> 00:08:57.800
do all of these things at
once, whether you want them

00:08:57.800 --> 00:08:59.440
to or not.

00:08:59.440 --> 00:09:01.910
And most of the time,
you're only actually using

00:09:01.910 --> 00:09:04.520
one or two of these
things and not

00:09:04.520 --> 00:09:07.340
the full 16 things
that fragments

00:09:07.340 --> 00:09:12.320
do that you get as kind
of a bundle of deal.

00:09:12.320 --> 00:09:14.990
So that means that
some of these things,

00:09:14.990 --> 00:09:17.450
like the stateful
restoration, means

00:09:17.450 --> 00:09:20.630
you have a lot of patterns that
look like this where you have

00:09:20.630 --> 00:09:25.530
to make sure that the Fragment
Manager is in the right state.

00:09:25.530 --> 00:09:28.160
So in this case, we're actually
checking, well, all right,

00:09:28.160 --> 00:09:30.410
is there no saved
instance state, i.e.,

00:09:30.410 --> 00:09:33.260
are we in a fresh
run of this activity?

00:09:33.260 --> 00:09:36.740
And oh, now I need to add
my Fragment to my layout.

00:09:36.740 --> 00:09:38.780
So if you've ever
gotten this approach

00:09:38.780 --> 00:09:41.270
where you have one
Fragment over another one,

00:09:41.270 --> 00:09:44.930
yeah, that's this kind
of stateful restoration

00:09:44.930 --> 00:09:49.040
actually being something
that was a useful bit,

00:09:49.040 --> 00:09:53.570
but at the same point, maybe not
exactly what you were expecting

00:09:53.570 --> 00:09:56.150
or something that you even
wanted, in some cases.

00:09:56.150 --> 00:09:58.550
But for Fragments, you
kind of got all of them

00:09:58.550 --> 00:10:00.290
together in a package deal.

00:10:02.870 --> 00:10:07.400
But last year, we kind of
took a more holistic approach

00:10:07.400 --> 00:10:09.500
to how we do APIs.

00:10:09.500 --> 00:10:11.510
And this really kind
of started with a lot

00:10:11.510 --> 00:10:14.120
of the work we did on
architecture components.

00:10:14.120 --> 00:10:16.250
So all of the
architecture components

00:10:16.250 --> 00:10:19.640
have really tried to focus
in on doing one thing

00:10:19.640 --> 00:10:22.640
well rather than being
kind of the kitchen sink

00:10:22.640 --> 00:10:25.140
kind of approach.

00:10:25.140 --> 00:10:27.790
So for example,
lifecycle observers--

00:10:27.790 --> 00:10:30.770
the ability to have
lifecycle, and that on resume,

00:10:30.770 --> 00:10:33.050
on start, as kind
of a piece that

00:10:33.050 --> 00:10:36.050
is completely independent
from other things, something

00:10:36.050 --> 00:10:40.070
that you can register just
if you care about lifecycle.

00:10:40.070 --> 00:10:43.505
Similarly for a ViewModel,
we created a new primitive,

00:10:43.505 --> 00:10:47.000
a new object,
specifically for that kind

00:10:47.000 --> 00:10:51.730
of retained instance state or
cross configuration changes.

00:10:51.730 --> 00:10:54.970
And of course, this
year, just yesterday,

00:10:54.970 --> 00:10:58.290
we announced a new navigation
architecture component.

00:10:58.290 --> 00:11:00.880
Kind of working out the much
higher level architecture

00:11:00.880 --> 00:11:04.630
on how you build your UI and
put these things together

00:11:04.630 --> 00:11:07.720
and really trying to tackle
just the specific problem of how

00:11:07.720 --> 00:11:11.125
do you move from one
screen to the next screen.

00:11:11.125 --> 00:11:13.540
So all these things were
kind of really focused

00:11:13.540 --> 00:11:15.850
on doing one thing well.

00:11:15.850 --> 00:11:19.240
And we're trying to bring
a lot of that to Fragments.

00:11:19.240 --> 00:11:21.910
But that means that we kind
of have a lot of legacy

00:11:21.910 --> 00:11:24.286
to go along with that.

00:11:24.286 --> 00:11:25.900
ADAM POWELL: That's right.

00:11:25.900 --> 00:11:28.300
So part of this is that
Fragments were really

00:11:28.300 --> 00:11:31.137
designed around this idea
of very loose dependencies

00:11:31.137 --> 00:11:33.220
and loose guarantees about
some of the interaction

00:11:33.220 --> 00:11:34.980
between them.

00:11:34.980 --> 00:11:37.479
So another kind of
quiz for the audience.

00:11:37.479 --> 00:11:39.520
How many of you know the
answer to this question?

00:11:39.520 --> 00:11:41.800
Does a child Fragment's
onCreate method run

00:11:41.800 --> 00:11:45.190
before or after its
parent's onCreate method?

00:11:45.190 --> 00:11:48.940
How many of you are confident
that you know the answer?

00:11:48.940 --> 00:11:50.840
Not a whole lot.

00:11:50.840 --> 00:11:52.090
How many of you--

00:11:52.090 --> 00:11:54.140
IAN LAKE: No idea.

00:11:54.140 --> 00:11:54.920
Is that an option?

00:11:54.920 --> 00:11:55.810
ADAM POWELL: How
many of you thought

00:11:55.810 --> 00:11:58.210
you knew the answer before
I asked the question,

00:11:58.210 --> 00:12:00.820
and then you started
questioning yourself?

00:12:00.820 --> 00:12:02.950
Yeah, OK.

00:12:02.950 --> 00:12:04.654
I'll fully admit
that sometimes I

00:12:04.654 --> 00:12:06.070
have to double
check this as well,

00:12:06.070 --> 00:12:08.890
because the answer
really kind of depends on

00:12:08.890 --> 00:12:10.270
whether the parent
is an activity

00:12:10.270 --> 00:12:11.727
or if the parent's a Fragment.

00:12:11.727 --> 00:12:13.060
What version are you running on?

00:12:13.060 --> 00:12:15.460
Are you talking about
android.app.fragments

00:12:15.460 --> 00:12:17.830
or the support
library Fragments?

00:12:17.830 --> 00:12:20.650
Because the answer has
been different over time.

00:12:20.650 --> 00:12:21.950
We've changed this around.

00:12:21.950 --> 00:12:23.980
And if you were trying
to design a fragment that

00:12:23.980 --> 00:12:26.380
worked across all versions
of Android that was writing

00:12:26.380 --> 00:12:27.880
to the framework
Fragments, you had

00:12:27.880 --> 00:12:29.620
to deal with these rules
kind of changing out

00:12:29.620 --> 00:12:30.786
from under you a little bit.

00:12:30.786 --> 00:12:33.790
You couldn't count on anything.

00:12:33.790 --> 00:12:35.710
So one of the things
that we allowed for here

00:12:35.710 --> 00:12:38.290
with lifecycle observers
is that we really

00:12:38.290 --> 00:12:41.350
wanted to give a very strict
ordering of the callbacks.

00:12:41.350 --> 00:12:43.840
You have a strict last
in, first out callback

00:12:43.840 --> 00:12:46.300
ordering for all lifecycle
observers in any given

00:12:46.300 --> 00:12:47.194
lifecycle.

00:12:47.194 --> 00:12:48.610
This is important
because it means

00:12:48.610 --> 00:12:51.970
that you can set up dependencies
between lifecycle observers

00:12:51.970 --> 00:12:54.490
and use lifecycle observers
as the implementation

00:12:54.490 --> 00:12:57.990
details of a particular activity
instance or fragment instance,

00:12:57.990 --> 00:12:59.350
as the case may be.

00:12:59.350 --> 00:13:01.330
You can make sure to
maintain guarantees

00:13:01.330 --> 00:13:03.520
between certain
lifecycle events so

00:13:03.520 --> 00:13:05.050
that any other
lifecycle observers

00:13:05.050 --> 00:13:07.570
that other libraries
you may be using

00:13:07.570 --> 00:13:09.310
can take advantage
of those guarantees

00:13:09.310 --> 00:13:13.040
that you've configured.

00:13:13.040 --> 00:13:15.020
Lifecycle observers
are created by you.

00:13:15.020 --> 00:13:17.690
We don't try to recreate
them via reflection, which

00:13:17.690 --> 00:13:20.720
means that you can use any
sort of creation pattern

00:13:20.720 --> 00:13:23.820
that you may find
useful within your app.

00:13:23.820 --> 00:13:25.784
So this seems like a
really small thing,

00:13:25.784 --> 00:13:27.200
but it was a big
piece of feedback

00:13:27.200 --> 00:13:29.060
that we got with Fragments.

00:13:29.060 --> 00:13:30.560
The implication of
that, though, is

00:13:30.560 --> 00:13:33.710
that you no longer get stateful
restoration by the system.

00:13:33.710 --> 00:13:37.380
Now, again, in some cases,
this is exactly what you want.

00:13:37.380 --> 00:13:40.310
You want to make sure that
you have a single control flow

00:13:40.310 --> 00:13:42.770
path as you're configuring
your lifecycle observers.

00:13:42.770 --> 00:13:45.074
You don't want to
be checking, hey,

00:13:45.074 --> 00:13:47.240
is my instant state going
to bring this back for me?

00:13:47.240 --> 00:13:49.240
I don't want to end up
with two of these things.

00:13:49.240 --> 00:13:50.704
So on and so forth.

00:13:50.704 --> 00:13:51.370
IAN LAKE: Right.

00:13:51.370 --> 00:13:53.540
So one of these
really common patterns

00:13:53.540 --> 00:13:55.910
that we saw a lot of
app developers using

00:13:55.910 --> 00:14:00.470
is actually a headless fragment,
a fragment without a UI

00:14:00.470 --> 00:14:04.420
that was used basically only
to receive onStart onStop

00:14:04.420 --> 00:14:06.150
lifecycle events.

00:14:06.150 --> 00:14:08.840
So for a lot of these
kind of approaches,

00:14:08.840 --> 00:14:11.030
lifecycle observers
are going to give you

00:14:11.030 --> 00:14:17.000
the same kind of API service,
but with a lot smaller kind

00:14:17.000 --> 00:14:19.220
of API that you
don't actually need

00:14:19.220 --> 00:14:21.710
all of the things of Fragment.

00:14:21.710 --> 00:14:24.230
So what does this
actually look like?

00:14:26.780 --> 00:14:29.510
You might have just a
simple lifecycle observer

00:14:29.510 --> 00:14:31.010
that does analytics calls.

00:14:31.010 --> 00:14:34.820
And your analytics library
might want onStart onStop

00:14:34.820 --> 00:14:37.460
of a particular lifecycle.

00:14:37.460 --> 00:14:40.610
So the thing here
is that this is

00:14:40.610 --> 00:14:45.210
an independent piece from
Fragments, from activities.

00:14:45.210 --> 00:14:48.050
That has a couple of super
important things in that one.

00:14:48.050 --> 00:14:50.120
You can test it independently.

00:14:50.120 --> 00:14:52.400
You don't have to spin
up the whole world just

00:14:52.400 --> 00:14:53.750
to test this piece.

00:14:53.750 --> 00:14:56.390
You can test it in isolation.

00:14:56.390 --> 00:14:59.990
Also because you can
create this observer,

00:14:59.990 --> 00:15:02.330
you can use whatever
methods you want.

00:15:02.330 --> 00:15:05.540
If you want to use a dependency
injection kind of model

00:15:05.540 --> 00:15:09.590
and inject in your dependencies,
that is really easy

00:15:09.590 --> 00:15:12.890
to do in this model
rather than trying

00:15:12.890 --> 00:15:16.400
to do it in the scope of
an activity or Fragment

00:15:16.400 --> 00:15:18.330
or doing that kind of thing.

00:15:18.330 --> 00:15:22.550
So this gives you a lot more
power to kind of split out

00:15:22.550 --> 00:15:24.620
this into a composable piece.

00:15:24.620 --> 00:15:26.390
So if you're building
a library, you

00:15:26.390 --> 00:15:29.750
can just use this same
lifecycle observer

00:15:29.750 --> 00:15:33.500
across all of your fragments
or all of your activities

00:15:33.500 --> 00:15:35.480
and not have to
duplicate that data

00:15:35.480 --> 00:15:39.320
or worry about, OK, well, what
state is my instance state in?

00:15:39.320 --> 00:15:42.420
You can just always say, add
the observer, and we're done.

00:15:42.420 --> 00:15:44.690
There's no more work
you need to do here.

00:15:44.690 --> 00:15:46.830
So this offers a lot
simpler alternative

00:15:46.830 --> 00:15:48.090
for this specific use case.

00:15:54.034 --> 00:15:56.450
ADAM POWELL: We've got some
glowing slides to get through.

00:15:56.450 --> 00:15:59.120
OK.

00:15:59.120 --> 00:16:01.490
So retained instance
Fragments were really

00:16:01.490 --> 00:16:03.980
designed to outlive an activity.

00:16:03.980 --> 00:16:06.650
These were basically
just a setter

00:16:06.650 --> 00:16:10.010
on a Fragment to say, hey,
retain my instant state

00:16:10.010 --> 00:16:13.510
across configuration changes.

00:16:13.510 --> 00:16:15.260
This was a pretty
useful thing, because it

00:16:15.260 --> 00:16:17.420
meant that you could save
handles to expensive data

00:16:17.420 --> 00:16:18.200
or operations.

00:16:18.200 --> 00:16:20.330
If you start some
sort of query that

00:16:20.330 --> 00:16:21.950
might take a little
bit to complete,

00:16:21.950 --> 00:16:23.600
you don't want to restart
that just because somebody

00:16:23.600 --> 00:16:25.530
rotated the screen or
something got re-sized.

00:16:27.965 --> 00:16:29.340
It meant that you
could reconnect

00:16:29.340 --> 00:16:33.660
to these same operations after
that configuration change.

00:16:33.660 --> 00:16:37.070
But really, please,
don't do UI during this.

00:16:37.070 --> 00:16:39.774
This was another one of those
kind of headache pain point

00:16:39.774 --> 00:16:40.440
sorts of things.

00:16:40.440 --> 00:16:42.660
Fragments do
everything all at once.

00:16:42.660 --> 00:16:44.850
But these were two
things that just really

00:16:44.850 --> 00:16:46.969
did not taste great together.

00:16:46.969 --> 00:16:48.510
The reasoning for
this is, of course,

00:16:48.510 --> 00:16:51.646
that views hold onto the
context that created them.

00:16:51.646 --> 00:16:54.270
Well, what context do you use to
create views most of the time?

00:16:54.270 --> 00:16:55.780
Well, it ends up
being the activity.

00:16:55.780 --> 00:16:58.230
You don't want to hold onto a
reference to an old activity

00:16:58.230 --> 00:17:01.469
after a configuration change
and end up using the same views.

00:17:01.469 --> 00:17:03.510
Now, technically, it's
possible to do this right.

00:17:03.510 --> 00:17:05.460
You can go ahead and
drop all your references

00:17:05.460 --> 00:17:08.970
in onDestroy view,
recreate the view after you

00:17:08.970 --> 00:17:11.310
come around the other side.

00:17:11.310 --> 00:17:14.077
This was way too difficult
to get right all of the time,

00:17:14.077 --> 00:17:15.660
just because references
to these views

00:17:15.660 --> 00:17:18.480
end up leaking out and getting
everywhere no matter what

00:17:18.480 --> 00:17:19.859
you try to do.

00:17:19.859 --> 00:17:23.069
So this was something that
was really just kind of a foot

00:17:23.069 --> 00:17:24.910
gun waiting to hurt people.

00:17:28.329 --> 00:17:31.600
IAN LAKE: But of course, in the
architecture component world,

00:17:31.600 --> 00:17:35.070
there's a different solution for
this retained instance pattern.

00:17:35.070 --> 00:17:38.050
And that comes in the
model of ViewModels.

00:17:38.050 --> 00:17:40.480
So this was kind of
a brand new class.

00:17:40.480 --> 00:17:43.510
And to be honest, the class
doesn't really do a whole lot.

00:17:43.510 --> 00:17:46.700
It's how it connects
to the overall system.

00:17:46.700 --> 00:17:50.260
So instead of being,
again, part of the fragment

00:17:50.260 --> 00:17:54.490
APIs, this is a more general
purpose thing, something

00:17:54.490 --> 00:17:58.600
that you can attach to any
activity or any Fragment

00:17:58.600 --> 00:18:01.030
or any ViewModel
store owner, if you're

00:18:01.030 --> 00:18:03.160
building your own framework.

00:18:03.160 --> 00:18:06.460
And the main thing
that's different here,

00:18:06.460 --> 00:18:09.010
just kind of like the
lifecycle observers,

00:18:09.010 --> 00:18:14.150
is that we are not the owner
of creating those objects.

00:18:14.150 --> 00:18:16.750
So by default, we
provide a factory

00:18:16.750 --> 00:18:20.230
that just creates a new instance
or creates a new instance

00:18:20.230 --> 00:18:23.090
and attaches your
application context to it.

00:18:23.090 --> 00:18:26.470
But at the same point, this is a
super powerful hook for, again,

00:18:26.470 --> 00:18:29.270
kind of adding in those
extra dependencies.

00:18:29.270 --> 00:18:31.520
So if you're using
dependency injection,

00:18:31.520 --> 00:18:33.400
again, you have
kind of the hooks

00:18:33.400 --> 00:18:36.700
you need to hook into
the view model creation

00:18:36.700 --> 00:18:39.450
and pass those just as
a constructor parameter.

00:18:39.450 --> 00:18:42.910
There really doesn't need to
be a more complicated structure

00:18:42.910 --> 00:18:43.480
than that.

00:18:46.300 --> 00:18:49.330
But you get into the same
problem of, OK, well,

00:18:49.330 --> 00:18:51.520
how do I connect my UI?

00:18:51.520 --> 00:18:53.620
And the other
piece of the puzzle

00:18:53.620 --> 00:18:56.770
here is a different architecture
component called live data.

00:18:56.770 --> 00:19:00.730
And LiveData is kind of
all about a lifecycle aware

00:19:00.730 --> 00:19:02.020
observer.

00:19:02.020 --> 00:19:06.220
So in this model, in this
world, your view model

00:19:06.220 --> 00:19:08.470
is the one who's
storing the data.

00:19:08.470 --> 00:19:12.670
And it's the LiveData that
it has that it can then

00:19:12.670 --> 00:19:16.240
pass to the activity
or Fragment as they

00:19:16.240 --> 00:19:18.670
get created and recreated.

00:19:18.670 --> 00:19:23.830
And that Fragment or activity
can just observe the LiveData

00:19:23.830 --> 00:19:26.500
that the view model owns.

00:19:26.500 --> 00:19:28.750
So this model kind of
separates things out

00:19:28.750 --> 00:19:30.940
where instead of it
being the view model that

00:19:30.940 --> 00:19:34.480
needs to hold onto a
reference to views,

00:19:34.480 --> 00:19:38.050
the activity can then
pull the information out

00:19:38.050 --> 00:19:40.910
of the view model.

00:19:40.910 --> 00:19:44.410
So I think for a
lot of use cases

00:19:44.410 --> 00:19:47.290
where you're using a retained
instance state specifically

00:19:47.290 --> 00:19:52.350
to kind of store this expensive
data and do that kind of work,

00:19:52.350 --> 00:19:54.730
ViewModels offer a
really good alternative

00:19:54.730 --> 00:19:57.970
to retained instance Fragments.

00:19:57.970 --> 00:20:01.390
So what's a super
simple one look like?

00:20:01.390 --> 00:20:04.340
Well, in this case, we're going
to use an Android ViewModel.

00:20:04.340 --> 00:20:06.830
So here we get a reference
to your application,

00:20:06.830 --> 00:20:08.870
your application context.

00:20:08.870 --> 00:20:10.300
So this is really
useful if you're

00:20:10.300 --> 00:20:14.240
doing things like a service
locator kind of pattern.

00:20:14.240 --> 00:20:18.400
But the important thing here
is that the ViewModel stores

00:20:18.400 --> 00:20:20.620
an instance of a LiveData.

00:20:20.620 --> 00:20:24.760
In this case, a LiveData that
has a list of our fancily

00:20:24.760 --> 00:20:27.370
named expensive data class.

00:20:27.370 --> 00:20:31.090
Now, normally, you'd put this
in line, but slides are hard.

00:20:31.090 --> 00:20:32.980
So here we're
using it, and we're

00:20:32.980 --> 00:20:37.420
getting our data from a
room database, a simple ORM

00:20:37.420 --> 00:20:38.960
database.

00:20:38.960 --> 00:20:41.860
But you can really get
this data from anywhere

00:20:41.860 --> 00:20:45.790
or set up kind of the
correct lifecycle event

00:20:45.790 --> 00:20:49.210
here so that your
LiveData can kind of get

00:20:49.210 --> 00:20:51.430
into the right state.

00:20:51.430 --> 00:20:55.780
But that means that your
actual Fragments or Activities

00:20:55.780 --> 00:20:59.440
don't need to know where
this data came from.

00:20:59.440 --> 00:21:02.110
It's encapsulated
in the ViewModel.

00:21:02.110 --> 00:21:03.910
And again, we're
in this same thing

00:21:03.910 --> 00:21:07.360
where we can now test this
new model in isolation.

00:21:07.360 --> 00:21:09.250
We don't need to
create Activities.

00:21:09.250 --> 00:21:11.170
We don't need to
create Fragments

00:21:11.170 --> 00:21:13.220
to get to this same ViewModel.

00:21:13.220 --> 00:21:15.490
We can just use
them in isolation

00:21:15.490 --> 00:21:18.370
and make sure that all
of the work we need here

00:21:18.370 --> 00:21:20.680
to get our expensive
data and make sure

00:21:20.680 --> 00:21:23.980
that it's in the right state
can all be done kind of separate

00:21:23.980 --> 00:21:27.207
from the actual UI
pieces of the framework.

00:21:29.772 --> 00:21:30.730
ADAM POWELL: All right.

00:21:30.730 --> 00:21:33.188
So everybody's favorite topic
when it comes to the Fragment

00:21:33.188 --> 00:21:35.590
API is Fragment transactions.

00:21:35.590 --> 00:21:39.370
Because this is a
statement that's said

00:21:39.370 --> 00:21:43.660
by pretty much no one ever.

00:21:43.660 --> 00:21:46.180
Fragment transactions are
asynchronous by default.

00:21:46.180 --> 00:21:48.790
If you call commit on
a Fragment transaction,

00:21:48.790 --> 00:21:51.280
then that ends up
getting posted for later,

00:21:51.280 --> 00:21:54.070
and it'll occur kind of
on the next normal handler

00:21:54.070 --> 00:21:55.870
pulse of your main thread.

00:21:55.870 --> 00:21:58.160
Or if another lifecycle
event is coming up,

00:21:58.160 --> 00:22:00.580
we'll go ahead and execute
all the pending transactions,

00:22:00.580 --> 00:22:02.830
bring it to a consistent
state before we

00:22:02.830 --> 00:22:05.200
move to that next state.

00:22:05.200 --> 00:22:07.459
Now, this actually has
a few benefits to it,

00:22:07.459 --> 00:22:09.250
believe it or not, for
as much as everybody

00:22:09.250 --> 00:22:11.020
gets kind of
frustrated about it.

00:22:11.020 --> 00:22:12.610
And the biggest one
is that you don't

00:22:12.610 --> 00:22:15.320
have any re-entrant
Fragment operations.

00:22:15.320 --> 00:22:18.340
This means that if you end
up manipulating Fragments

00:22:18.340 --> 00:22:20.552
within, say, the onCreate
of another fragment,

00:22:20.552 --> 00:22:22.510
then you don't start
getting into a state where

00:22:22.510 --> 00:22:24.700
you have a half
initialized Fragment

00:22:24.700 --> 00:22:28.340
while you're waiting to bring
another Fragment up to speed.

00:22:28.340 --> 00:22:30.310
Now, this is a source
of countless bugs.

00:22:30.310 --> 00:22:34.570
I think that it was even just
earlier this week, last week,

00:22:34.570 --> 00:22:37.210
that we were helping a
developer troubleshoot

00:22:37.210 --> 00:22:39.850
some other re-entrant behavior
bugs that were coming from view

00:22:39.850 --> 00:22:41.800
callbacks, for example.

00:22:41.800 --> 00:22:44.170
And this was the
sort of thing that

00:22:44.170 --> 00:22:46.090
can be really, really subtle.

00:22:46.090 --> 00:22:47.920
And the asynchronous
Fragment transactions

00:22:47.920 --> 00:22:49.270
sidestep all of it.

00:22:49.270 --> 00:22:52.000
And that was kind of convenient.

00:22:52.000 --> 00:22:55.660
The drawbacks are, of course,
that the observed state

00:22:55.660 --> 00:22:57.760
at any given point in
time doesn't actually

00:22:57.760 --> 00:23:00.380
reflect any of the
queued transactions.

00:23:00.380 --> 00:23:02.260
So this is a huge problem.

00:23:02.260 --> 00:23:05.230
This basically means that
if one piece of your code

00:23:05.230 --> 00:23:08.380
submits a Fragment transaction,
another piece of your code

00:23:08.380 --> 00:23:11.050
tries to read something out of
state that that Fragment would

00:23:11.050 --> 00:23:12.520
have set up for
you, whether that's

00:23:12.520 --> 00:23:14.770
another view hierarchy that
would have gotten attached

00:23:14.770 --> 00:23:16.870
to sort of a
sub-hierarchy of your UI,

00:23:16.870 --> 00:23:19.390
or whether that's just some
data about a pending operation,

00:23:19.390 --> 00:23:22.430
say, for one of these
retained instance Fragments.

00:23:22.430 --> 00:23:25.180
This essentially means that
you can't trust anything

00:23:25.180 --> 00:23:26.710
about the current
state of the app.

00:23:26.710 --> 00:23:29.230
It means that you can
have various data races

00:23:29.230 --> 00:23:31.150
just within the
normal main thread

00:23:31.150 --> 00:23:32.890
handler of your application.

00:23:32.890 --> 00:23:35.680
We've even seen people run
into the issues of sort

00:23:35.680 --> 00:23:38.107
of the layered Fragments
on top of one another

00:23:38.107 --> 00:23:40.690
because of this issue, because
they were checking the Fragment

00:23:40.690 --> 00:23:45.250
Manager to see, hey, what is my
current UI pane, for example,

00:23:45.250 --> 00:23:46.466
that's currently there.

00:23:46.466 --> 00:23:47.590
It said, oh, look, nothing.

00:23:47.590 --> 00:23:48.610
I don't have anything to do.

00:23:48.610 --> 00:23:50.410
Let me go ahead and make
a new Fragment transaction

00:23:50.410 --> 00:23:51.493
and stick something there.

00:23:51.493 --> 00:23:53.549
But there was already
something in flight.

00:23:53.549 --> 00:23:55.090
So this was something
that was really

00:23:55.090 --> 00:23:56.215
kind of a pain in the neck.

00:23:56.215 --> 00:23:58.720
And everybody loved when the
commit now API was added,

00:23:58.720 --> 00:24:00.982
because it lets you do
something immediately as long

00:24:00.982 --> 00:24:03.190
as you promised that you
weren't going to do anything

00:24:03.190 --> 00:24:04.990
with your current
Fragment Manager as part

00:24:04.990 --> 00:24:06.321
of that transaction.

00:24:09.090 --> 00:24:11.400
IAN LAKE: But we kind
of get to this point

00:24:11.400 --> 00:24:14.280
where, OK, now we have all
these fragment transaction

00:24:14.280 --> 00:24:19.410
code in your app and very
subtle changes that you may not

00:24:19.410 --> 00:24:22.090
pick up in a simple
CL all of a sudden

00:24:22.090 --> 00:24:24.960
are changing the whole
behavior of your app.

00:24:24.960 --> 00:24:26.790
And we really took
a look at this

00:24:26.790 --> 00:24:28.710
and we said, well,
should you really

00:24:28.710 --> 00:24:32.700
have to be writing all of these
Fragment transactions by hand?

00:24:32.700 --> 00:24:35.710
For so many of the use cases,
we can do a little bit better

00:24:35.710 --> 00:24:36.210
here.

00:24:36.210 --> 00:24:39.150
We can do a lot better
here, especially

00:24:39.150 --> 00:24:41.040
for the really common cases.

00:24:41.040 --> 00:24:42.990
So we built Navigation.

00:24:42.990 --> 00:24:44.670
A brand new
architecture component

00:24:44.670 --> 00:24:47.880
that's really kind of focused
on that screen to screen

00:24:47.880 --> 00:24:52.830
transitions between
Fragments or other UI pieces.

00:24:52.830 --> 00:24:56.280
Because we really wanted to make
it work well with Fragments.

00:24:56.280 --> 00:24:59.160
Fragments are a really
great way of getting access

00:24:59.160 --> 00:25:02.430
to lifecycle observers
and ViewModels

00:25:02.430 --> 00:25:06.480
and also being an
owner of a view.

00:25:06.480 --> 00:25:08.430
And those are really
kind of the main pieces

00:25:08.430 --> 00:25:14.330
you need when you're trying
to build a good Android app.

00:25:14.330 --> 00:25:17.430
At the same point, we realize
there's a lot of things

00:25:17.430 --> 00:25:21.390
that Fragments do that
we don't really want you

00:25:21.390 --> 00:25:23.680
to have to deal with yourself.

00:25:23.680 --> 00:25:26.490
So one of the things with
Navigation that we really

00:25:26.490 --> 00:25:30.480
focused on was actually
being able to take ownership

00:25:30.480 --> 00:25:35.010
of the back stack, make
sure that the Navigation

00:25:35.010 --> 00:25:38.607
component can actually handle
that back stack for you,

00:25:38.607 --> 00:25:41.190
whether you're using Fragments
or you're using something else.

00:25:41.190 --> 00:25:45.060
The ownership of that back stack
kind of lays with navigation.

00:25:45.060 --> 00:25:48.210
That gives us a lot more
flexibility and a lot more

00:25:48.210 --> 00:25:51.540
ability to be a little bit more
prescriptive and a little bit

00:25:51.540 --> 00:25:55.420
more opinionated on what
is a good thing to do

00:25:55.420 --> 00:25:59.370
and what's a not so great thing
to do and kind of give you

00:25:59.370 --> 00:26:02.790
a lot of the same power
of Fragment transactions

00:26:02.790 --> 00:26:06.630
without actually having to
touch one with your bare hands.

00:26:06.630 --> 00:26:09.240
Because again, we're
trying to make things

00:26:09.240 --> 00:26:15.480
so that you have all of the
power without necessarily

00:26:15.480 --> 00:26:18.420
the headache and
the problems that

00:26:18.420 --> 00:26:23.580
run across some of the
things that Adam pointed out.

00:26:23.580 --> 00:26:26.820
So we're going to be talking
in detail about Navigation

00:26:26.820 --> 00:26:28.320
tomorrow morning at 8:30.

00:26:28.320 --> 00:26:30.224
I know you're all early risers.

00:26:30.224 --> 00:26:32.640
But I wanted to give you a
little bit of a preview of kind

00:26:32.640 --> 00:26:34.620
of how simple this could be.

00:26:34.620 --> 00:26:36.630
So we actually offer
a helper method

00:26:36.630 --> 00:26:38.490
where if you want
to click a button

00:26:38.490 --> 00:26:42.420
and do a full screen
transition to another Fragment,

00:26:42.420 --> 00:26:45.690
we have a create navigate
OnClickListener that

00:26:45.690 --> 00:26:48.330
literally just does just that.

00:26:48.330 --> 00:26:50.640
All you need to do
is pass in the ID

00:26:50.640 --> 00:26:52.530
of one of those
destinations that you've

00:26:52.530 --> 00:26:55.090
set up in Navigation.

00:26:55.090 --> 00:26:57.060
Now, this looks a
little bit magical.

00:26:57.060 --> 00:27:00.660
So what is this actually
doing under the covers?

00:27:00.660 --> 00:27:04.140
Well, really what it's doing is
it's using this nav controller

00:27:04.140 --> 00:27:05.370
object.

00:27:05.370 --> 00:27:08.190
And one of the things
that I find super useful

00:27:08.190 --> 00:27:10.770
about Navigation
is you can actually

00:27:10.770 --> 00:27:15.090
find that nav controller from
any view or any Fragment that's

00:27:15.090 --> 00:27:17.100
been created by Navigation.

00:27:17.100 --> 00:27:18.970
So here we're using
a call in extension,

00:27:18.970 --> 00:27:20.610
which makes it a lot easier.

00:27:20.610 --> 00:27:24.730
If you're in the Java land,
it's just a static method.

00:27:24.730 --> 00:27:27.930
But here we can find
from any view we can just

00:27:27.930 --> 00:27:31.080
say find nav controller and
get an instance of our nav

00:27:31.080 --> 00:27:31.830
controller.

00:27:31.830 --> 00:27:33.780
And then just call Navigate.

00:27:33.780 --> 00:27:39.330
And this Navigate call knows
how to do Fragment transactions.

00:27:39.330 --> 00:27:41.220
So our nav controller,
in this case,

00:27:41.220 --> 00:27:44.550
is set up with a
Fragment navigator.

00:27:44.550 --> 00:27:48.180
Our own class that knows all
about the correct behavior

00:27:48.180 --> 00:27:50.550
of doing Fragment
transactions and how

00:27:50.550 --> 00:27:54.090
to do all of that work for
you so that from your code's

00:27:54.090 --> 00:27:56.370
perspective, you can
just call Navigate,

00:27:56.370 --> 00:27:59.430
and we'll do the
right thing for you.

00:27:59.430 --> 00:28:01.410
So obviously, there's
a lot more here.

00:28:01.410 --> 00:28:04.620
Like, if you want
to pass arguments,

00:28:04.620 --> 00:28:06.060
you can do a bundle approach.

00:28:06.060 --> 00:28:09.060
We also have a lot more things
around that specific case

00:28:09.060 --> 00:28:11.490
that we'll be talking
about tomorrow as well,

00:28:11.490 --> 00:28:14.640
as well as studying things
like separate animations

00:28:14.640 --> 00:28:15.830
and other objects in here.

00:28:15.830 --> 00:28:17.580
So you have a lot
of the same power,

00:28:17.580 --> 00:28:21.690
but you can also make it
really easy to use and move

00:28:21.690 --> 00:28:24.240
a lot of the code that
used to be a Fragment

00:28:24.240 --> 00:28:27.300
transaction that you'd have to
make really sure that you got

00:28:27.300 --> 00:28:31.470
right into something that
Navigation can understand

00:28:31.470 --> 00:28:32.400
and help with.

00:28:35.360 --> 00:28:37.610
So Adam, we've talked
to a lot of things

00:28:37.610 --> 00:28:40.550
about why not Fragments.

00:28:40.550 --> 00:28:42.360
But this is kind
of a Fragment talk.

00:28:42.360 --> 00:28:44.360
ADAM POWELL: I think
that's why everyone's here.

00:28:44.360 --> 00:28:45.030
IAN LAKE: Yeah.

00:28:45.030 --> 00:28:47.060
So why Fragments?

00:28:47.060 --> 00:28:48.190
It's 2018.

00:28:48.190 --> 00:28:49.190
ADAM POWELL: It is 2018.

00:28:49.190 --> 00:28:51.620
So what are fragments
still good for

00:28:51.620 --> 00:28:54.800
after we've sort of carved off
some of these other extension

00:28:54.800 --> 00:28:56.390
points?

00:28:56.390 --> 00:28:58.044
So before we talk
about that, I think

00:28:58.044 --> 00:28:59.960
it's kind of important
to go into a little bit

00:28:59.960 --> 00:29:02.840
about the package layering
involved in the Android

00:29:02.840 --> 00:29:05.120
framework, specifically
android.widget

00:29:05.120 --> 00:29:07.800
versus android.app.

00:29:07.800 --> 00:29:09.860
Now, android.widget is
really kind of designed

00:29:09.860 --> 00:29:12.350
to hold all the
mechanism for your UI.

00:29:12.350 --> 00:29:14.810
That means that this is all
the stuff that shows state

00:29:14.810 --> 00:29:18.020
to the user and things that
reports user interaction

00:29:18.020 --> 00:29:20.960
events back to other higher
level portions of your app.

00:29:20.960 --> 00:29:22.179
And really that's it.

00:29:22.179 --> 00:29:23.720
Anything that's in
the widget package

00:29:23.720 --> 00:29:26.750
is really meant to only
do these two things.

00:29:26.750 --> 00:29:29.030
Whereas android.app, which
is where Fragments live,

00:29:29.030 --> 00:29:31.280
Activities live,
so on and so forth,

00:29:31.280 --> 00:29:33.620
that's where your policy goes.

00:29:33.620 --> 00:29:37.200
This is what defines what
state to bind to widgets.

00:29:37.200 --> 00:29:40.010
This is what defines how you
should respond to those user

00:29:40.010 --> 00:29:42.290
interaction events and
how to issue changes

00:29:42.290 --> 00:29:43.190
to your data model.

00:29:43.190 --> 00:29:45.290
Anything kind of at
that layer or above,

00:29:45.290 --> 00:29:46.935
no matter how you
may factor it, this

00:29:46.935 --> 00:29:51.140
is kind of how it breaks down.

00:29:51.140 --> 00:29:53.180
So this also brings
us to this idea

00:29:53.180 --> 00:29:55.220
of inflatable components,
which is something

00:29:55.220 --> 00:29:56.930
that comes up quite a bit.

00:29:56.930 --> 00:29:59.180
Since you can inflate a
Fragment from a layout,

00:29:59.180 --> 00:30:01.400
people found out
really quickly that you

00:30:01.400 --> 00:30:04.040
can use a Fragment to
compose some of your views

00:30:04.040 --> 00:30:06.380
together and create
basically a custom view,

00:30:06.380 --> 00:30:08.630
but with a Fragment.

00:30:08.630 --> 00:30:10.460
And really some of
this kind of comes in

00:30:10.460 --> 00:30:13.700
because people start asking,
just if this view had

00:30:13.700 --> 00:30:17.480
a lifecycle, I could something.

00:30:17.480 --> 00:30:20.240
But really, you kind of want
to use that as a stopping point

00:30:20.240 --> 00:30:21.740
and just kind of
ask yourself, what

00:30:21.740 --> 00:30:24.290
is it about this
particular view,

00:30:24.290 --> 00:30:28.470
remember, mechanism only,
that needs a lifecycle?

00:30:28.470 --> 00:30:30.740
Views should really
only be showing data

00:30:30.740 --> 00:30:33.290
that they're given,
or publishing user

00:30:33.290 --> 00:30:36.320
interaction events if
the user clicks, touches,

00:30:36.320 --> 00:30:39.800
or performs any other action
on the views themselves.

00:30:39.800 --> 00:30:42.080
None of these things
need lifecycle events

00:30:42.080 --> 00:30:43.770
to accomplish that goal.

00:30:43.770 --> 00:30:46.310
So you should really kind of
watch out and figure out, OK,

00:30:46.310 --> 00:30:50.201
do you need some sort of policy
layer that sits above that?

00:30:50.201 --> 00:30:51.950
This is where Fragments
are really useful,

00:30:51.950 --> 00:30:55.640
because you can compose them
of higher level controls.

00:30:55.640 --> 00:30:57.900
It means that they can
be self sufficient.

00:30:57.900 --> 00:30:59.150
They have their own lifecycle.

00:30:59.150 --> 00:31:03.320
They know how to hook
into some of these things.

00:31:03.320 --> 00:31:06.200
It means that inflated
attributes can actually

00:31:06.200 --> 00:31:08.210
become Fragment arguments.

00:31:08.210 --> 00:31:10.940
So you can make these
things super self sufficient

00:31:10.940 --> 00:31:13.730
and implement
crosscutting UI policies

00:31:13.730 --> 00:31:15.800
that you don't have to
worry about in terms

00:31:15.800 --> 00:31:19.280
of the overarching top
level parent context.

00:31:19.280 --> 00:31:22.360
This ends up being really
useful for things like even just

00:31:22.360 --> 00:31:24.830
something as simple as ads,
something where you really

00:31:24.830 --> 00:31:27.050
do need to control for
a lifecycle about when

00:31:27.050 --> 00:31:29.810
a user comes and goes,
perform a request out

00:31:29.810 --> 00:31:31.820
to the network to fetch
the content that you're

00:31:31.820 --> 00:31:32.511
going to show.

00:31:32.511 --> 00:31:34.010
But really, you
don't want that code

00:31:34.010 --> 00:31:38.144
getting all over throughout the
rest of your application logic.

00:31:38.144 --> 00:31:40.310
You can use this for other
sorts of independent info

00:31:40.310 --> 00:31:44.360
cards, things that are,
again, fully self-contained.

00:31:44.360 --> 00:31:46.010
And the parent
doesn't actually need

00:31:46.010 --> 00:31:47.990
to be involved in any
of the data routing

00:31:47.990 --> 00:31:51.260
from your central repository
or whatever other sort of model

00:31:51.260 --> 00:31:54.369
you're using under the hood
in order to get that on screen

00:31:54.369 --> 00:31:55.910
and get the user
interacting with it.

00:31:58.770 --> 00:32:01.130
So one example of using the
fragment arguments for this

00:32:01.130 --> 00:32:02.105
is on screen here.

00:32:02.105 --> 00:32:03.980
This is the sort of
thing that could probably

00:32:03.980 --> 00:32:06.120
benefit from some
extensions or helpers.

00:32:06.120 --> 00:32:08.180
But overall, it's not too bad.

00:32:08.180 --> 00:32:09.980
If you define a
styleable to go ahead

00:32:09.980 --> 00:32:11.960
and inflate some
of those arguments,

00:32:11.960 --> 00:32:14.254
just assign the values to
the bundle, set it there,

00:32:14.254 --> 00:32:15.920
and then you can route
all of this logic

00:32:15.920 --> 00:32:17.270
through your normal
Fragment argument

00:32:17.270 --> 00:32:19.686
handling that appears throughout
the rest of your Fragment

00:32:19.686 --> 00:32:20.724
implementation.

00:32:23.455 --> 00:32:25.080
IAN LAKE: So one of
the other use cases

00:32:25.080 --> 00:32:27.410
that we found really
useful for using

00:32:27.410 --> 00:32:30.600
Fragments is this kind of
app screen kind of model.

00:32:30.600 --> 00:32:34.100
So where a Fragment is
taking the vast majority

00:32:34.100 --> 00:32:38.330
of the screen, it's really
the main content of your app.

00:32:38.330 --> 00:32:41.720
And this is really kind of where
Navigation comes in and really

00:32:41.720 --> 00:32:44.510
kind of takes away a lot of
the rough edges of Fragments.

00:32:44.510 --> 00:32:47.330
So you're just left with
the architecture component

00:32:47.330 --> 00:32:50.610
hooks and a view.

00:32:50.610 --> 00:32:54.020
So in this model,
it's a lot easier

00:32:54.020 --> 00:32:56.840
to move towards a
single activity app.

00:32:56.840 --> 00:32:59.120
If you listened
to Chet yesterday,

00:32:59.120 --> 00:33:00.650
this is kind of
our recommendation

00:33:00.650 --> 00:33:03.440
going forward, to
kind of use activities

00:33:03.440 --> 00:33:05.720
just as an entry
point into your app.

00:33:05.720 --> 00:33:08.270
And then your content,
the actual things

00:33:08.270 --> 00:33:12.950
that the UI, the pieces that
developers or users actually

00:33:12.950 --> 00:33:16.190
work with, are the
Fragments of your app.

00:33:16.190 --> 00:33:19.670
The actual content
is in Fragments.

00:33:19.670 --> 00:33:23.300
So with this model, the only
thing the Activity needs to do

00:33:23.300 --> 00:33:25.550
is handle kind of
Common App Chrome.

00:33:25.550 --> 00:33:28.670
So if you're using
an action bar still,

00:33:28.670 --> 00:33:32.510
or if you're using
bottom nav or a side nav,

00:33:32.510 --> 00:33:35.570
these would be good things
that the Activity can manage.

00:33:35.570 --> 00:33:39.110
But the rest of it can be
decoupled destinations,

00:33:39.110 --> 00:33:40.400
decoupled screens.

00:33:40.400 --> 00:33:42.860
All of these Fragments can
be much more independent

00:33:42.860 --> 00:33:47.460
from one another rather than
being tightly coupled together.

00:33:47.460 --> 00:33:50.390
So this allows us to kind
of move a lot of the things

00:33:50.390 --> 00:33:55.160
that normally you'd have to
deal with manually into a system

00:33:55.160 --> 00:33:57.830
that we can help you
out a lot more on.

00:33:57.830 --> 00:34:00.350
So for Navigation,
for example, we're

00:34:00.350 --> 00:34:02.450
going to give you
the hooks that you

00:34:02.450 --> 00:34:06.650
need to set up the transitions
and animations needed

00:34:06.650 --> 00:34:09.170
to transition between
these screens.

00:34:09.170 --> 00:34:11.960
And it's something that
can be done in Navigation

00:34:11.960 --> 00:34:16.250
rather than something
you have to do by hand.

00:34:16.250 --> 00:34:19.460
Of course, these aren't
mutually exclusive, right?

00:34:19.460 --> 00:34:23.600
You can still add a
Fragment to your layout

00:34:23.600 --> 00:34:26.489
or have nested Fragments
underneath these things.

00:34:26.489 --> 00:34:29.389
So it's not an all or
nothing kind of an approach.

00:34:29.389 --> 00:34:34.100
It's just one method that, yes,
this larger kind of content

00:34:34.100 --> 00:34:36.800
based fragment is still
a really good way of kind

00:34:36.800 --> 00:34:39.949
of bridging the gap
between the android.app

00:34:39.949 --> 00:34:43.940
world and the widget world.

00:34:43.940 --> 00:34:47.750
Another use case that
is still super useful

00:34:47.750 --> 00:34:50.510
is around DialogFragment.

00:34:50.510 --> 00:34:53.480
Again, we talked about
the activity show dialog.

00:34:53.480 --> 00:34:56.570
I hope everyone forgot
that by now, like I said.

00:34:56.570 --> 00:35:00.350
But DialogFragment is really
kind of the same approach

00:35:00.350 --> 00:35:03.170
where instead of
it being something

00:35:03.170 --> 00:35:09.070
that you need to manage and make
sure is visible or not visible,

00:35:09.070 --> 00:35:12.890
it really kind of helps
encapsulate the interaction

00:35:12.890 --> 00:35:14.330
between a floating UI.

00:35:14.330 --> 00:35:16.550
Like, if you have a
really important question

00:35:16.550 --> 00:35:19.910
to ask the user, a
dialog is probably

00:35:19.910 --> 00:35:22.154
a useful case in some manner.

00:35:22.154 --> 00:35:23.570
But it's also
something that we've

00:35:23.570 --> 00:35:25.220
started to see a lot more.

00:35:25.220 --> 00:35:28.400
In Android P, for instance,
the biometric prompt

00:35:28.400 --> 00:35:30.830
for fingerprint is
now something that

00:35:30.830 --> 00:35:34.860
is in a dialog kind of model.

00:35:34.860 --> 00:35:38.320
So this is actually something
that we found really useful.

00:35:38.320 --> 00:35:40.850
And part of it is
that we can leverage

00:35:40.850 --> 00:35:43.850
some of that instant
state restoration

00:35:43.850 --> 00:35:47.600
that you get for free as part
of Fragments with your dialog.

00:35:47.600 --> 00:35:50.570
This means that you've asked
a really important question.

00:35:50.570 --> 00:35:54.920
Otherwise, why would you show a
dialog and interrupt the user?

00:35:54.920 --> 00:35:59.150
But you really don't want that
to disappear when you resize

00:35:59.150 --> 00:36:01.850
your screen on the
Pixelbook or rotate

00:36:01.850 --> 00:36:03.685
your device on your phone.

00:36:03.685 --> 00:36:05.060
It's a really
important question.

00:36:05.060 --> 00:36:08.210
We want to make sure that we
do some of this instant state

00:36:08.210 --> 00:36:11.600
restoration for you.

00:36:11.600 --> 00:36:16.490
At the same point, dialogs
aren't just a floating UI.

00:36:16.490 --> 00:36:20.690
There's also bottom sheets and
bottom sheet DialogFragment

00:36:20.690 --> 00:36:24.470
specifically built around
kind of having different kinds

00:36:24.470 --> 00:36:26.450
of floating UIs.

00:36:26.450 --> 00:36:29.390
UIs that live above
your main content,

00:36:29.390 --> 00:36:32.660
without necessarily being just
the dimmed background kind

00:36:32.660 --> 00:36:37.250
of traditional dialog of yore.

00:36:37.250 --> 00:36:39.500
So we're really trying
to get to this point

00:36:39.500 --> 00:36:41.690
where, yes, using
a DialogFragment

00:36:41.690 --> 00:36:44.270
is great if you have
this UI that you really

00:36:44.270 --> 00:36:45.500
don't want to lose.

00:36:45.500 --> 00:36:47.590
It's really important
for the user.

00:36:47.590 --> 00:36:52.260
Obviously, for things
that the user could lose,

00:36:52.260 --> 00:36:54.430
it's probably not a dialog
that you want to use.

00:36:54.430 --> 00:36:59.330
It's probably a snack bar
or another approach here.

00:36:59.330 --> 00:37:01.620
This is my favorite part
about DialogFragment.

00:37:01.620 --> 00:37:04.390
There's literally nothing
more you need to do.

00:37:04.390 --> 00:37:09.670
You call show or show now
for the synchronous method,

00:37:09.670 --> 00:37:11.320
and that's it.

00:37:11.320 --> 00:37:13.180
Very much kind of
this model where

00:37:13.180 --> 00:37:16.690
we're going to do the
Fragment transactions for you.

00:37:16.690 --> 00:37:19.300
Again, we don't want
to be in a model

00:37:19.300 --> 00:37:23.410
where you have to do a lot
of complicated work yourself.

00:37:23.410 --> 00:37:26.830
For a DialogFragment, you
can literally just call show,

00:37:26.830 --> 00:37:30.010
and it'll do the right
thing, and it'll get you back

00:37:30.010 --> 00:37:30.940
into the right state.

00:37:33.740 --> 00:37:35.067
ADAM POWELL: All right.

00:37:35.067 --> 00:37:36.650
So one of the other
things that people

00:37:36.650 --> 00:37:38.240
tend to use Fragments
for quite a bit

00:37:38.240 --> 00:37:43.100
is managing options menus, and
specifically merging some menus

00:37:43.100 --> 00:37:45.380
into a common toolbar,
into an action bar

00:37:45.380 --> 00:37:47.100
that's global to your Activity.

00:37:47.100 --> 00:37:48.710
So Fragments
support option menus

00:37:48.710 --> 00:37:50.640
because Activities
support options menus.

00:37:50.640 --> 00:37:52.550
This kind of calls back to
that initial design goal,

00:37:52.550 --> 00:37:54.425
where Fragments had to
be able to do anything

00:37:54.425 --> 00:37:56.610
that an Activity could do.

00:37:56.610 --> 00:37:58.970
And the most common
use case in this today

00:37:58.970 --> 00:38:01.220
is for calling set
support action bar

00:38:01.220 --> 00:38:03.650
for your toolbar, which
then sort of binds

00:38:03.650 --> 00:38:08.360
whatever your current context
is to a particular toolbar

00:38:08.360 --> 00:38:10.280
within your UI.

00:38:10.280 --> 00:38:12.980
Now, this is really great if you
have some Fixed Common Chrome.

00:38:12.980 --> 00:38:16.340
So in the navigation world,
if your toolbar never

00:38:16.340 --> 00:38:18.770
changes between
screens, then this

00:38:18.770 --> 00:38:20.520
is really handy
because this means

00:38:20.520 --> 00:38:22.520
that you can populate
that with whatever actions

00:38:22.520 --> 00:38:25.640
are relevant for what's
in your main content.

00:38:25.640 --> 00:38:27.920
Fragment Pager Adapter is
another really great one

00:38:27.920 --> 00:38:29.720
that people use this
for quite a bit.

00:38:29.720 --> 00:38:32.570
If the actions change across
pages, then all of this

00:38:32.570 --> 00:38:33.640
is just handled for you.

00:38:33.640 --> 00:38:36.280
The system takes care of it.

00:38:36.280 --> 00:38:38.900
Now, the alternative
to this is that you

00:38:38.900 --> 00:38:43.080
can go ahead and directly manage
the menus as toolbar view data.

00:38:43.080 --> 00:38:45.530
So most of the time
today, your UIs

00:38:45.530 --> 00:38:49.940
are such that the toolbar or
other sort of menu management

00:38:49.940 --> 00:38:51.800
is really kind of
part of the content.

00:38:51.800 --> 00:38:53.060
I mean, this was something
that you saw back

00:38:53.060 --> 00:38:55.640
in a lot of hollow UIs, where
the action bar was always

00:38:55.640 --> 00:38:56.900
Fixed Common Chrome.

00:38:56.900 --> 00:38:58.520
But now you have
these collapsing app

00:38:58.520 --> 00:39:01.099
bar layouts and things that
are much more sophisticated,

00:39:01.099 --> 00:39:03.140
to the point where doing
this sort of global wire

00:39:03.140 --> 00:39:05.473
up is almost jumping through
hoops that you don't really

00:39:05.473 --> 00:39:06.210
need.

00:39:06.210 --> 00:39:08.000
So don't make it more
complicated than it

00:39:08.000 --> 00:39:09.440
needs to be.

00:39:09.440 --> 00:39:11.450
If you don't have
Common Chrome for this,

00:39:11.450 --> 00:39:16.700
then directly managing some of
the toolbar menus as view data

00:39:16.700 --> 00:39:17.779
is as simple as this.

00:39:17.779 --> 00:39:19.070
It's a couple of lines of code.

00:39:19.070 --> 00:39:20.120
There's not a whole lot to it.

00:39:20.120 --> 00:39:22.400
You inflate your menu, you
attach a click listener.

00:39:22.400 --> 00:39:23.840
And you can keep all of
this a little bit more

00:39:23.840 --> 00:39:25.370
self-contained
rather than having

00:39:25.370 --> 00:39:27.577
this leak out into the
whole Activity options menu

00:39:27.577 --> 00:39:28.160
at that point.

00:39:31.367 --> 00:39:32.950
So one of the other
things that we get

00:39:32.950 --> 00:39:36.340
asked a lot is about
testing Fragments.

00:39:36.340 --> 00:39:39.080
Testing Fragments is a whole lot
easier than testing Activities.

00:39:39.080 --> 00:39:41.299
You don't have to
spin up the entirety

00:39:41.299 --> 00:39:43.840
of the world and an entire new
Activity with sort of the back

00:39:43.840 --> 00:39:47.890
and forth in an instrumentation
test to the Activity Manager

00:39:47.890 --> 00:39:50.030
to make this work.

00:39:50.030 --> 00:39:53.030
The nice part about this is
that from quite a few years ago,

00:39:53.030 --> 00:39:55.480
we've had this class
Fragment Controller that

00:39:55.480 --> 00:39:57.280
is able to drive the lifecycle.

00:39:57.280 --> 00:40:00.370
So you can go ahead and
you can create just a test

00:40:00.370 --> 00:40:03.040
Fragment Manager test
Fragment Controller that

00:40:03.040 --> 00:40:07.000
can test those larger Fragment
components in isolation,

00:40:07.000 --> 00:40:09.120
away from everything else
that might be happening

00:40:09.120 --> 00:40:10.540
in the Activity Manager.

00:40:10.540 --> 00:40:13.090
We use this pretty extensively
for the existing support

00:40:13.090 --> 00:40:14.890
library tests ourselves.

00:40:14.890 --> 00:40:17.720
Now, we make this possible,
but truth be told,

00:40:17.720 --> 00:40:21.100
this is really not the best
interface for doing it.

00:40:21.100 --> 00:40:23.569
It ends up looking a
little bit like this.

00:40:23.569 --> 00:40:25.360
Or you could go through
some of the support

00:40:25.360 --> 00:40:27.896
library tests in
AOSP and see kind

00:40:27.896 --> 00:40:29.770
of the example of some
of the utility methods

00:40:29.770 --> 00:40:32.450
that we've set up for this.

00:40:32.450 --> 00:40:35.380
We should really probably
wrap this in some better move

00:40:35.380 --> 00:40:36.500
to state type of method.

00:40:36.500 --> 00:40:38.083
This is one of those
cases where we've

00:40:38.083 --> 00:40:42.240
fallen into a trap ourselves
of something's possible.

00:40:42.240 --> 00:40:43.410
It's maybe not great.

00:40:43.410 --> 00:40:45.660
The rest is kind of left as
an exercise to the reader.

00:40:45.660 --> 00:40:47.920
And we kind of just need
to do better on this part.

00:40:50.501 --> 00:40:52.250
IAN LAKE: Yeah, so one
of the other pieces

00:40:52.250 --> 00:40:55.400
that kind of came
alongside of Fragments,

00:40:55.400 --> 00:40:58.100
more from a convenience
method than anything else,

00:40:58.100 --> 00:41:00.530
were Loaders, a
kind of precursor

00:41:00.530 --> 00:41:03.470
to a lot of what we've done
in architecture components

00:41:03.470 --> 00:41:05.670
on doing retained
instance states.

00:41:05.670 --> 00:41:07.640
And one of the things
we've done recently

00:41:07.640 --> 00:41:11.600
is actually tried to
decouple them from Fragments.

00:41:11.600 --> 00:41:13.970
So how do we actually do this?

00:41:13.970 --> 00:41:16.970
Well, instead of being
their own special thing,

00:41:16.970 --> 00:41:19.070
we actually rebuilt
them on a lot

00:41:19.070 --> 00:41:20.740
of the architecture components.

00:41:20.740 --> 00:41:24.650
Using these new primitives we
have a LiveData and ViewModel

00:41:24.650 --> 00:41:27.860
to kind of make these a
totally independent thing.

00:41:27.860 --> 00:41:31.370
So now you can actually use
Loaders in any lifecycle owner

00:41:31.370 --> 00:41:32.830
ViewModel store owner class.

00:41:32.830 --> 00:41:35.150
So Activity, Fragment,
if you're building

00:41:35.150 --> 00:41:36.920
your own kind of thing.

00:41:36.920 --> 00:41:40.560
It works equally well
in all of those cases.

00:41:40.560 --> 00:41:41.880
So what does this mean?

00:41:41.880 --> 00:41:43.370
Well, it really
just means that you

00:41:43.370 --> 00:41:44.940
have the same Loader
you always do,

00:41:44.940 --> 00:41:48.350
but instead of calling get
support Fragment or Loader

00:41:48.350 --> 00:41:51.270
Manager, you can just
call get instance.

00:41:51.270 --> 00:41:54.090
And we'll do all
the hookup for you.

00:41:54.090 --> 00:41:56.670
We know that you're in
a lifecycle observer,

00:41:56.670 --> 00:41:59.270
so we know how to hook
all that stuff up for you.

00:41:59.270 --> 00:42:03.950
And we really were able to kind
of cut out a lot of the stuff,

00:42:03.950 --> 00:42:07.700
cut a lot of the custom
behavior here so that we

00:42:07.700 --> 00:42:09.980
can kind of rely
on these new things

00:42:09.980 --> 00:42:14.330
to give you stronger
guarantees around lifecycle.

00:42:14.330 --> 00:42:17.240
So we've talked a
lot about Fragments,

00:42:17.240 --> 00:42:19.970
and we've talked a lot
about Fragments in the past,

00:42:19.970 --> 00:42:23.270
and we've talked about
Fragments in 2018.

00:42:23.270 --> 00:42:25.250
But there's another
question-- where are we

00:42:25.250 --> 00:42:26.210
going with Fragments?

00:42:26.210 --> 00:42:28.910
What do we still have to do?

00:42:28.910 --> 00:42:32.070
So some of this is just
coming down to building

00:42:32.070 --> 00:42:33.980
in those stronger guarantees.

00:42:33.980 --> 00:42:36.500
Trying to separate
the desired behavior,

00:42:36.500 --> 00:42:38.810
things that we
specifically set out

00:42:38.810 --> 00:42:42.830
to put in, versus incidental
behavior, more behavior that

00:42:42.830 --> 00:42:46.580
has just been
around for six years

00:42:46.580 --> 00:42:51.120
and is not necessarily something
that is a codified standard.

00:42:51.120 --> 00:42:53.300
So we're trying to move
towards more of a model

00:42:53.300 --> 00:42:56.360
where you can be very
confident in exactly

00:42:56.360 --> 00:43:00.230
what's going to happen when
you're using Fragments.

00:43:00.230 --> 00:43:03.600
Another case is trying
to do the same thing

00:43:03.600 --> 00:43:07.460
that we did with Loader
Manager in reimplementing

00:43:07.460 --> 00:43:11.030
some of these existing APIs on
top of these new primitives.

00:43:11.030 --> 00:43:14.060
For example, being
able to rewrite

00:43:14.060 --> 00:43:16.010
a lot of the
internals of Fragments

00:43:16.010 --> 00:43:18.500
so they're actually
using lifecycle observers

00:43:18.500 --> 00:43:20.030
under the covers.

00:43:20.030 --> 00:43:23.150
So these kinds of things
allow us to kind of make sure

00:43:23.150 --> 00:43:27.170
that all of our components
are on the same page

00:43:27.170 --> 00:43:30.210
and really doing the same thing.

00:43:30.210 --> 00:43:31.910
So a few other things--

00:43:31.910 --> 00:43:35.120
again, trying to
move towards a world

00:43:35.120 --> 00:43:40.550
where we have the correct
set of signals and activity

00:43:40.550 --> 00:43:44.600
callbacks so that any
interested components can be it.

00:43:44.600 --> 00:43:48.470
That means that Fragments
are not a special snowflake

00:43:48.470 --> 00:43:49.380
anymore.

00:43:49.380 --> 00:43:53.510
They're just another component,
another tool in your toolbox,

00:43:53.510 --> 00:43:56.930
using the same composable
hooks that you'd always have.

00:43:56.930 --> 00:44:00.050
So really trying to play
well with other components

00:44:00.050 --> 00:44:03.140
so that it's not an
either/or, it's a both.

00:44:03.140 --> 00:44:05.420
That we can work
together, that you can use

00:44:05.420 --> 00:44:09.500
fragments alongside other
components, and it just works.

00:44:09.500 --> 00:44:11.630
ADAM POWELL: All right.

00:44:11.630 --> 00:44:14.570
So Options menus are, of
course, one other thing

00:44:14.570 --> 00:44:17.879
that we still don't have a great
answer for this in terms of how

00:44:17.879 --> 00:44:18.920
we want to decouple this.

00:44:18.920 --> 00:44:21.740
I mean, in a lot of ways I
would like for Options menus

00:44:21.740 --> 00:44:24.500
just kind of as a
concept to be deprecated.

00:44:24.500 --> 00:44:26.420
But for right now, we
still need to make sure

00:44:26.420 --> 00:44:28.460
that we meet all those
same use cases for when

00:44:28.460 --> 00:44:30.260
you do have Common Chrome
or for when you're paging

00:44:30.260 --> 00:44:31.551
through some different content.

00:44:35.870 --> 00:44:37.090
Next one maybe?

00:44:37.090 --> 00:44:38.320
There we go.

00:44:38.320 --> 00:44:40.360
OK, so
android.app.fragmentmanager,

00:44:40.360 --> 00:44:42.680
some of you have noticed, is
now officially deprecated.

00:44:42.680 --> 00:44:44.680
So no more of this kind
of behavior changing out

00:44:44.680 --> 00:44:47.650
from under you having to design
against different variants

00:44:47.650 --> 00:44:48.380
of it.

00:44:48.380 --> 00:44:50.860
This works a whole lot
better in the Android X

00:44:50.860 --> 00:44:52.690
packages and support
library before it,

00:44:52.690 --> 00:44:54.440
because this means
that you no longer have

00:44:54.440 --> 00:44:57.522
to worry about all the bugs
that were fixed over time.

00:44:57.522 --> 00:44:59.980
It allows us to make larger
changes to the behavior in API.

00:44:59.980 --> 00:45:01.813
Please send us your
wish list for the things

00:45:01.813 --> 00:45:04.020
that you'd like to see us
do for some of this too.

00:45:04.020 --> 00:45:07.670
We are going to be over in the
sandbox area right after this.

00:45:07.670 --> 00:45:09.040
So please come say hello.

00:45:09.040 --> 00:45:11.290
Tell us what you'd
like to see next.

00:45:11.290 --> 00:45:12.940
And thank you very
much for coming.

00:45:12.940 --> 00:45:14.920
[APPLAUSE]

00:45:16.900 --> 00:45:19.758
[MUSIC PLAYING]

