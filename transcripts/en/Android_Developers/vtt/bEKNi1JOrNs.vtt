WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:06.201
[MUSIC PLAYING]

00:00:06.201 --> 00:00:09.380
SERGEI VASILINETC:
Good morning, everyone.

00:00:09.380 --> 00:00:10.130
My name is Sergei.

00:00:10.130 --> 00:00:12.620
This is Adam and
Yigit with me today,

00:00:12.620 --> 00:00:15.780
and we will speak about
LifeCycle problems.

00:00:15.780 --> 00:00:21.240
So probably many of you attended
yesterday at Yigit's talk

00:00:21.240 --> 00:00:24.670
where he introduced new
architecture components.

00:00:24.670 --> 00:00:27.550
He introduced LiveData,
ViewModel, new persistence

00:00:27.550 --> 00:00:28.540
slide named Room.

00:00:28.540 --> 00:00:31.900
And today we will focus
on the LifeCycle part

00:00:31.900 --> 00:00:34.990
of these architectural
components.

00:00:34.990 --> 00:00:37.715
So we will speak again about
LiveData And ViewModel.

00:00:37.715 --> 00:00:41.140
We will speak about LifeCycle
honors and LifeCycle that

00:00:41.140 --> 00:00:45.210
are basics for these libraries.

00:00:45.210 --> 00:00:49.150
But we will have more details.

00:00:49.150 --> 00:00:51.890
We will have some reasoning
behind our decisions.

00:00:51.890 --> 00:00:56.360
So if you attended yesterday,
it will be still interesting.

00:00:56.360 --> 00:00:57.900
If you didn't
attend yesterday, we

00:00:57.900 --> 00:00:59.600
will reintroduce
all of these things

00:00:59.600 --> 00:01:03.370
so you will
understand everything.

00:01:03.370 --> 00:01:07.480
So let's see what we have today.

00:01:07.480 --> 00:01:11.280
Today we have an activity
in the fragments.

00:01:11.280 --> 00:01:14.300
I'll start with is that not
for length length but dozens

00:01:14.300 --> 00:01:17.330
and dozens line of lines.

00:01:17.330 --> 00:01:22.190
And this line's the results
from a very natural process.

00:01:22.190 --> 00:01:24.690
Google pay services
asked to register them

00:01:24.690 --> 00:01:25.670
in onStart methods.

00:01:25.670 --> 00:01:29.620
It's Your own components need
to know about this LifeCycle

00:01:29.620 --> 00:01:34.640
event, so you need to forward
them in some kind of API.

00:01:34.640 --> 00:01:38.100
And correspondingly,
on onStop method,

00:01:38.100 --> 00:01:42.530
you have to call all
pairings stop methods,

00:01:42.530 --> 00:01:44.900
and it's very easy
to forget one.

00:01:44.900 --> 00:01:46.880
And will result in [INAUDIBLE].

00:01:46.880 --> 00:01:51.950
It will drain the
user's battery,

00:01:51.950 --> 00:01:54.920
and they will enjoy
your app a bit less.

00:01:54.920 --> 00:01:58.190
Which is probably healthier for
them, but we think that's bad.

00:01:58.190 --> 00:02:02.180
And they think the
answer in this situation

00:02:02.180 --> 00:02:04.130
is to introduce LifeCycle
aware components.

00:02:04.130 --> 00:02:06.770
So components which
handle LifeCycle.

00:02:06.770 --> 00:02:08.539
And the first step
in this direction

00:02:08.539 --> 00:02:11.750
is to introduce LifeCycle
as a first class citizen.

00:02:11.750 --> 00:02:13.550
So it's a very
simple object which

00:02:13.550 --> 00:02:17.370
answers the question, what is
the current state right now?

00:02:17.370 --> 00:02:19.130
And notifies you
about new events.

00:02:19.130 --> 00:02:22.340
And then no feature is important
but sounds ridiculous right

00:02:22.340 --> 00:02:26.060
now, events and states
are different things.

00:02:26.060 --> 00:02:28.540
So let's see what I mean.

00:02:28.540 --> 00:02:31.610
Your case is instantiated
in initialized state.

00:02:31.610 --> 00:02:37.965
And all creation phases
pass very routinely.

00:02:37.965 --> 00:02:39.680
OnCreate, create the state.

00:02:39.680 --> 00:02:42.460
OnStart, start the state,
same thing for resume.

00:02:42.460 --> 00:02:45.070
But the road down is a
bit more interesting.

00:02:45.070 --> 00:02:48.920
So onPause event, leads
you from a resume state

00:02:48.920 --> 00:02:50.480
back to a starting state.

00:02:50.480 --> 00:02:53.490
Not some new pause state,
or something like that.

00:02:53.490 --> 00:02:57.870
And the reason for this is
from a system perspective,

00:02:57.870 --> 00:03:01.880
the states after onPause event
and onStart event are the same

00:03:01.880 --> 00:03:05.790
because the sets of the actions
that you are allowed to do

00:03:05.790 --> 00:03:07.010
is the same.

00:03:07.010 --> 00:03:11.960
And the same is true for
onStop and Creative state.

00:03:11.960 --> 00:03:14.350
And last event is onDestroy.

00:03:14.350 --> 00:03:18.390
It's pretty straightforward.

00:03:18.390 --> 00:03:20.150
It brings it to destroy state.

00:03:20.150 --> 00:03:21.730
Your activity is destroyed.

00:03:21.730 --> 00:03:25.720
It's going to be thrown
away and garbage collected.

00:03:25.720 --> 00:03:28.020
So let's make our
component LifeCycle aware.

00:03:28.020 --> 00:03:29.390
That's super straightforward.

00:03:29.390 --> 00:03:32.780
We take it with LifeCycle
observer interface,

00:03:32.780 --> 00:03:34.350
accepted interface.

00:03:34.350 --> 00:03:40.320
To get the actual events, we add
annotation and pass the events

00:03:40.320 --> 00:03:43.200
that we are interested in,
you can pass multiple events

00:03:43.200 --> 00:03:43.950
if you want to.

00:03:43.950 --> 00:03:48.180
The last step is to add
ourselves as an observer.

00:03:48.180 --> 00:03:53.910
And we may have a
potential problem here.

00:03:53.910 --> 00:03:57.810
What if the activity is
already started at this point?

00:03:57.810 --> 00:04:02.730
Does this mean that we are
going to receive onStop event,

00:04:02.730 --> 00:04:05.970
and and we didn't
receive onStart.

00:04:05.970 --> 00:04:09.540
And our component probably
is not ready for this.

00:04:09.540 --> 00:04:12.570
But it took care
of it, and we bring

00:04:12.570 --> 00:04:14.412
the observer to correct state.

00:04:14.412 --> 00:04:15.370
So what does this mean?

00:04:15.370 --> 00:04:17.670
Let's take this example,
which I just discussed.

00:04:17.670 --> 00:04:20.610
From activity perspective
onStart and onCreate

00:04:20.610 --> 00:04:26.250
create already happened, and
after that we add an observer.

00:04:26.250 --> 00:04:31.740
But observer will still receive
onCreate and onStart events

00:04:31.740 --> 00:04:34.950
immediately when
they were registered.

00:04:34.950 --> 00:04:38.130
So let's take one step further.

00:04:38.130 --> 00:04:39.870
OnResume, same situation.

00:04:39.870 --> 00:04:41.400
Resume state will
bring to resume

00:04:41.400 --> 00:04:45.550
state we got an onResume
event in addition to onCreate

00:04:45.550 --> 00:04:46.610
and onStart.

00:04:46.610 --> 00:04:48.660
A bit more
interesting situation,

00:04:48.660 --> 00:04:54.590
onPause In this situation, we
are in a start state as well as

00:04:54.590 --> 00:04:55.830
we learned.

00:04:55.830 --> 00:04:59.060
So we bring the oberserver
to the correct state

00:04:59.060 --> 00:05:00.030
which is start.

00:05:00.030 --> 00:05:04.040
So it's a similar situation
as we had one minute ago.

00:05:04.040 --> 00:05:06.930
Observer will receive
onCreate and onStart events,

00:05:06.930 --> 00:05:09.090
and that's it.

00:05:09.090 --> 00:05:13.460
So we don't have a
problem in this code.

00:05:13.460 --> 00:05:17.240
So how to get this
magical lifecycle object?

00:05:17.240 --> 00:05:20.940
We have this interface
which is super simple,

00:05:20.940 --> 00:05:25.060
but this probably doesn't
help much right now.

00:05:25.060 --> 00:05:26.580
And the actual
question is who are

00:05:26.580 --> 00:05:29.600
LifeCycle owners out of box.

00:05:29.600 --> 00:05:34.310
And the answer in this question
is support library fragments

00:05:34.310 --> 00:05:35.630
and support activities.

00:05:35.630 --> 00:05:40.140
But unfortunately, this is
true only in the bright future.

00:05:40.140 --> 00:05:44.300
And right now we have
LifeCycle activity

00:05:44.300 --> 00:05:46.040
and LifeCycle fragment.

00:05:46.040 --> 00:05:49.520
But at the point
of 1.0 release, we

00:05:49.520 --> 00:05:53.720
will merge our library to
support libraries so you

00:05:53.720 --> 00:05:56.070
don't have to use them later.

00:05:56.070 --> 00:05:59.400
And now Adam will speak
about some key differences

00:05:59.400 --> 00:06:02.242
between fragment and
LifeCyle observers

00:06:02.242 --> 00:06:04.200
ADAM POWELL: So if you've
been following along,

00:06:04.200 --> 00:06:06.616
you probably recognize some
similarities with the fragment

00:06:06.616 --> 00:06:07.950
API in this as well.

00:06:07.950 --> 00:06:10.850
So at this point we've got
these two different components.

00:06:10.850 --> 00:06:12.480
Which one do you use?

00:06:12.480 --> 00:06:14.870
Well, as the slides are
already spoiling for you,

00:06:14.870 --> 00:06:17.594
this really isn't an
either- or question.

00:06:17.594 --> 00:06:20.010
One of these things doesn't
necessarily replace the other.

00:06:20.010 --> 00:06:22.040
And here's why.

00:06:22.040 --> 00:06:25.830
Fragments, on one hand, that
everybody knows and loves,

00:06:25.830 --> 00:06:28.190
are statefully
managed and recreated

00:06:28.190 --> 00:06:32.030
after either a process death,
an activity recreation,

00:06:32.030 --> 00:06:35.630
or recreation of any hosts that
you have the fragment within.

00:06:35.630 --> 00:06:37.760
Fragments manage views
and also interact

00:06:37.760 --> 00:06:39.620
with the navigation
stack, which are

00:06:39.620 --> 00:06:42.230
things that are firmly out
of scope of what LifeCycle

00:06:42.230 --> 00:06:43.880
observers are meant to do.

00:06:43.880 --> 00:06:45.740
Instead, LifeCycle
observers are meant

00:06:45.740 --> 00:06:47.930
to enable more granular
factoring of your code,

00:06:47.930 --> 00:06:50.360
whether you're in an
activity or a fragment.

00:06:50.360 --> 00:06:51.110
They're stateless.

00:06:51.110 --> 00:06:53.570
So that means that they
must be registered each time

00:06:53.570 --> 00:06:54.770
the owner is recreated.

00:06:54.770 --> 00:06:56.186
We're not going
to try to recreate

00:06:56.186 --> 00:06:57.290
these magically for you.

00:06:57.290 --> 00:06:59.150
They don't have any
concept of instant state

00:06:59.150 --> 00:07:00.780
that they carry
around with them.

00:07:00.780 --> 00:07:02.510
So these are meant to be
very, very lightweight,

00:07:02.510 --> 00:07:04.968
so that you don't have a whole
lot of additional management

00:07:04.968 --> 00:07:06.170
overhead.

00:07:06.170 --> 00:07:09.470
And last, there's no relation
to the viewer navigation

00:07:09.470 --> 00:07:10.010
management.

00:07:10.010 --> 00:07:12.470
These really are meant
to be very tightly

00:07:12.470 --> 00:07:16.330
scoped, isolated components.

00:07:16.330 --> 00:07:17.950
So they can really
help everyone.

00:07:17.950 --> 00:07:21.040
It means that it's much
simpler to integrate libraries

00:07:21.040 --> 00:07:23.860
with your code, as long as
those libraries have provided

00:07:23.860 --> 00:07:26.124
LifeCycle observer
aware components.

00:07:26.124 --> 00:07:28.540
It means that you can break
up those really large fragment

00:07:28.540 --> 00:07:31.300
or activity classes to make
them much simpler to understand

00:07:31.300 --> 00:07:32.440
for a reader.

00:07:32.440 --> 00:07:35.200
And you can provide much
more granular guarantees

00:07:35.200 --> 00:07:38.660
around what operations are valid
at any given point in time.

00:07:38.660 --> 00:07:41.860
You can make it so that if
an operation happens then

00:07:41.860 --> 00:07:44.050
you're guaranteed to
be in a correct state

00:07:44.050 --> 00:07:45.130
when something is called.

00:07:48.060 --> 00:07:50.685
So LifeCycle owner
as already introduced

00:07:50.685 --> 00:07:51.900
is just an interface.

00:07:51.900 --> 00:07:53.630
Anyone can implement this.

00:07:53.630 --> 00:07:55.680
This means that you
can improve testability

00:07:55.680 --> 00:07:56.802
by creating your own.

00:07:56.802 --> 00:07:59.010
You can create your own sort
of fragment-like library

00:07:59.010 --> 00:08:01.170
implementations if
you feel so inclined.

00:08:01.170 --> 00:08:03.330
But you can also create
composite life cycles.

00:08:03.330 --> 00:08:06.780
Life cycles that span across
other smaller lifecycle

00:08:06.780 --> 00:08:08.010
definitions.

00:08:08.010 --> 00:08:10.710
So you can answer questions
like, is my app visible?

00:08:10.710 --> 00:08:12.750
So this is a really
common composite lifecycle

00:08:12.750 --> 00:08:15.000
that many of you may
be interested in.

00:08:15.000 --> 00:08:17.160
It lets you do things
like session management

00:08:17.160 --> 00:08:19.530
to track a particular
session across perhaps

00:08:19.530 --> 00:08:23.100
some sort of a flow
or a series of logged

00:08:23.100 --> 00:08:24.870
in versus logged out events.

00:08:24.870 --> 00:08:29.020
And it may help you
with analytics as well.

00:08:29.020 --> 00:08:32.280
So we have the process LifeCycle
owner as kind of a component

00:08:32.280 --> 00:08:35.350
that I think a lot of you will
be interested in for this.

00:08:35.350 --> 00:08:39.059
It's the composite lifecycle of
all the activities in your app.

00:08:39.059 --> 00:08:41.010
So there's no configuration
changes to handle,

00:08:41.010 --> 00:08:44.440
because we're not going to be
dealing with those from these.

00:08:44.440 --> 00:08:46.350
The process LifeCycle
owner just stays

00:08:46.350 --> 00:08:48.000
alive through the whole process.

00:08:48.000 --> 00:08:50.041
But that also means that
you don't get state risk

00:08:50.041 --> 00:08:52.660
restoration after process death
like we mentioned earlier.

00:08:52.660 --> 00:08:54.600
So that means that
you don't have

00:08:54.600 --> 00:08:56.905
to handle saving and
restoring that state

00:08:56.905 --> 00:08:59.280
but at the same time, you need
to remember to re-register

00:08:59.280 --> 00:09:02.199
these process lifecycle-based
observers if that's something

00:09:02.199 --> 00:09:03.240
that you're working with.

00:09:05.750 --> 00:09:09.110
So many indirect
components provide a lot

00:09:09.110 --> 00:09:11.330
of deep plumbing
layers for things

00:09:11.330 --> 00:09:13.790
that you can plug
into and work with.

00:09:13.790 --> 00:09:15.800
But a lot of times
we've kind of omitted

00:09:15.800 --> 00:09:17.720
the idea of higher
level components that

00:09:17.720 --> 00:09:20.210
make use of that plumbing
so that you can just plug

00:09:20.210 --> 00:09:21.280
play and go.

00:09:21.280 --> 00:09:24.300
So do we have anything more
high level than the bare events

00:09:24.300 --> 00:09:25.530
and states here?

00:09:25.530 --> 00:09:26.800
YIGIT BOYAR: Maybe we do.

00:09:26.800 --> 00:09:27.760
I will show you.

00:09:27.760 --> 00:09:28.870
ADAM POWELL: Great

00:09:28.870 --> 00:09:30.530
YIGIT BOYAR: Thanks, Adam.

00:09:30.530 --> 00:09:33.680
So it's so nice
now you can observe

00:09:33.680 --> 00:09:37.310
a LifeCycle is well-defined,
is a first class citizen.

00:09:37.310 --> 00:09:40.530
But you still need to
deal with these things.

00:09:40.530 --> 00:09:44.780
And we told like, there's
some common LifeCycle problems

00:09:44.780 --> 00:09:47.100
that we should be able to
solve with this component.

00:09:47.100 --> 00:09:48.860
So we'll look at the
problems that people

00:09:48.860 --> 00:09:51.740
are having, and
this was probably

00:09:51.740 --> 00:09:54.110
the most major problem
we've been seeing,

00:09:54.110 --> 00:09:56.320
the untimely UI updates.

00:09:56.320 --> 00:09:58.920
It's like your activity
receives a callback,

00:09:58.920 --> 00:10:00.530
but the activity's
already stopped.

00:10:00.530 --> 00:10:03.050
They tried to start a
new activity and crashes.

00:10:03.050 --> 00:10:06.010
Or it tries to add a
fragment and crashes.

00:10:06.010 --> 00:10:09.410
If an activity or a
fragment is stopped,

00:10:09.410 --> 00:10:12.317
there is no reason to
update that activity.

00:10:12.317 --> 00:10:13.400
You don't want to do that.

00:10:13.400 --> 00:10:16.190
If the activity happens to
become visible again, then

00:10:16.190 --> 00:10:17.480
you want to do it.

00:10:17.480 --> 00:10:20.480
So we realized that this
is a very common problem,

00:10:20.480 --> 00:10:23.990
and we wanted to solve this with
a higher level component which

00:10:23.990 --> 00:10:26.060
we call LiveData.

00:10:26.060 --> 00:10:29.780
When we look at the
LiveData in detail,

00:10:29.780 --> 00:10:32.840
it's actually an
observable data holder.

00:10:32.840 --> 00:10:35.180
It just holds on
to some information

00:10:35.180 --> 00:10:36.490
that you can observe.

00:10:36.490 --> 00:10:38.270
Now the difference
between LiveData

00:10:38.270 --> 00:10:41.225
and your other observables
in data mining or RxJava

00:10:41.225 --> 00:10:45.350
or whatever, is that
LiveData is LifeCycle aware.

00:10:45.350 --> 00:10:48.020
It knows about
Android life cycles,

00:10:48.020 --> 00:10:50.030
and when you want to
observe a LiveData,

00:10:50.030 --> 00:10:52.580
you can pass in this
LifeCycle so that it

00:10:52.580 --> 00:10:54.480
can manage your subscription.

00:10:54.480 --> 00:10:57.210
The nice thing about LiveData
that is that you observe,

00:10:57.210 --> 00:10:59.340
and that's all you do.

00:10:59.340 --> 00:11:00.860
So if we look at
the usage example,

00:11:00.860 --> 00:11:02.210
let's say we have an activity.

00:11:02.210 --> 00:11:04.110
We receive a LiveData
from somewhere.

00:11:04.110 --> 00:11:08.040
It doesn't really matter, and
now we call observe on it.

00:11:08.040 --> 00:11:10.160
And when we are
calling observe, we

00:11:10.160 --> 00:11:13.600
are passing this, which
is the LiveData owner.

00:11:13.600 --> 00:11:14.780
That's all you need to say.

00:11:14.780 --> 00:11:18.770
I want to observe this
LiveData within this LifeCycle.

00:11:18.770 --> 00:11:21.830
Which also means if
this LifeCycle is gone,

00:11:21.830 --> 00:11:23.150
I don't want to observe it.

00:11:23.150 --> 00:11:26.550
Or if this LifeCycle is stopped,
I don't want to receive events.

00:11:30.466 --> 00:11:32.340
And then once you do
this, that's all you do.

00:11:32.340 --> 00:11:34.410
You don't need to
write onStart, onStop.

00:11:34.410 --> 00:11:37.870
We want Android to want
to look more like this.

00:11:37.870 --> 00:11:40.040
You initialze things as
more like find and forget.

00:11:40.040 --> 00:11:43.060
You initialize, and you're done.

00:11:43.060 --> 00:11:45.990
So let's look at what happens
when our activity starts

00:11:45.990 --> 00:11:47.910
observing that LiveData.

00:11:47.910 --> 00:11:52.560
So onCreate, it called observe,
it said LiveData is observable.

00:11:52.560 --> 00:11:54.630
And as soon as the
activity starts,

00:11:54.630 --> 00:11:56.470
it starts receiving
data changes.

00:11:56.470 --> 00:11:59.490
So whenever the
LiveData value changes,

00:11:59.490 --> 00:12:01.950
we displace that event
back to your observer

00:12:01.950 --> 00:12:03.530
inside the activity.

00:12:03.530 --> 00:12:05.450
It can also be a fragment.

00:12:05.450 --> 00:12:07.260
Let's say a user
decides to rotate

00:12:07.260 --> 00:12:09.090
the activity at this moment.

00:12:09.090 --> 00:12:11.540
So you know that the
activity will be stopped.

00:12:11.540 --> 00:12:13.320
And what happens
at the same time,

00:12:13.320 --> 00:12:16.110
the LiveData happens
to be updated.

00:12:16.110 --> 00:12:18.990
If that happens, we are not
going to tell the activity

00:12:18.990 --> 00:12:22.590
about this change because there
cannot be any reason for you

00:12:22.590 --> 00:12:27.210
to update the UI, because
it already stopped.

00:12:27.210 --> 00:12:29.640
Similarly, if the
activity is destroyed,

00:12:29.640 --> 00:12:31.980
we will automatically
remove that subscription

00:12:31.980 --> 00:12:34.320
because that activity is gone.

00:12:34.320 --> 00:12:36.990
There is no reason to
keep a reference back

00:12:36.990 --> 00:12:39.240
to that activity.

00:12:39.240 --> 00:12:41.010
Now we said the
activity was rotating,

00:12:41.010 --> 00:12:42.630
so you know that
Android is going

00:12:42.630 --> 00:12:44.880
to recreate that activity.

00:12:44.880 --> 00:12:48.270
And then we are observing
the same LiveData back.

00:12:48.270 --> 00:12:49.985
As soon as that
activity starts, it's

00:12:49.985 --> 00:12:53.190
going to receive
last available data.

00:12:53.190 --> 00:12:57.720
So your UI is going to have the
data before it gets a chance

00:12:57.720 --> 00:12:59.790
to draw.

00:12:59.790 --> 00:13:01.920
So similarly, I
say the user hits

00:13:01.920 --> 00:13:05.330
the Home button, which means
the activity will be stopped.

00:13:05.330 --> 00:13:08.700
Again, if the LiveData changes
while the activity is stopped,

00:13:08.700 --> 00:13:10.840
it's not going to
receive any events.

00:13:10.840 --> 00:13:14.010
Even if the data changes,
we are not going to tell it.

00:13:14.010 --> 00:13:17.280
But as soon as if the user
comes back to the application,

00:13:17.280 --> 00:13:19.510
we will give it the
last available data.

00:13:19.510 --> 00:13:22.990
So this is why we call LiveData
is not just a stream of events.

00:13:22.990 --> 00:13:26.910
It holds onto the data so
that if any observer comes,

00:13:26.910 --> 00:13:30.430
it receives the last
available value.

00:13:30.430 --> 00:13:33.620
And then eventually, the user
backs out of that activity,

00:13:33.620 --> 00:13:37.830
and then we remove
that subscription.

00:13:37.830 --> 00:13:40.730
You can also extend
the LiveData class.

00:13:40.730 --> 00:13:45.950
Because LiveData provides
two really handy callbacks.

00:13:45.950 --> 00:13:48.410
The first one is called
onactive which means

00:13:48.410 --> 00:13:50.930
you have an active observer.

00:13:50.930 --> 00:13:52.580
Another one is
called oninactive,

00:13:52.580 --> 00:13:54.370
which means you don't
have any observers,

00:13:54.370 --> 00:13:56.450
so don't bother
changing your value

00:13:56.450 --> 00:14:00.020
if it is something
that you care about.

00:14:00.020 --> 00:14:03.800
You probably ask now what
is an active observer?

00:14:03.800 --> 00:14:06.220
An active observer
is an observer

00:14:06.220 --> 00:14:09.680
whose attached LifeCycle
is started or resumed.

00:14:09.680 --> 00:14:12.890
So it's like a fragment that's
currently visible to the user.

00:14:12.890 --> 00:14:15.380
If the fragment is
on the back stack,

00:14:15.380 --> 00:14:16.660
the user is not seeing it.

00:14:16.660 --> 00:14:18.260
It stopped, so it's not active.

00:14:18.260 --> 00:14:22.430
There's no reason to do
any work for that fragment.

00:14:22.430 --> 00:14:24.850
Let's see how we can take
advantage of these named

00:14:24.850 --> 00:14:25.770
callbacks.

00:14:25.770 --> 00:14:28.270
We are going to create
a new location LiveData

00:14:28.270 --> 00:14:31.190
class, which presents
the location of something

00:14:31.190 --> 00:14:32.580
on the device.

00:14:32.580 --> 00:14:37.920
So we say this data holds
an instance of a location.

00:14:37.920 --> 00:14:40.460
In cross-sector, we just
get the location manager

00:14:40.460 --> 00:14:41.850
from the system service.

00:14:41.850 --> 00:14:43.670
There's nothing fancy here.

00:14:43.670 --> 00:14:47.210
We have a listener whenever
the system server sends us

00:14:47.210 --> 00:14:50.830
any location, we just
call setValue on us.

00:14:50.830 --> 00:14:51.530
This all you do.

00:14:51.530 --> 00:14:53.460
There is no LifeCycle
handling here.

00:14:53.460 --> 00:14:56.120
You just call setValue,
and LiveData takes

00:14:56.120 --> 00:14:57.710
care of handling the LifeCycle.

00:14:57.710 --> 00:15:00.080
And you may have any
number of observers.

00:15:00.080 --> 00:15:02.450
It doesn't really matter.

00:15:02.450 --> 00:15:04.850
So we want to override onactive.

00:15:04.850 --> 00:15:07.340
The very first active
observer comes.

00:15:07.340 --> 00:15:10.280
We want to start listening
to the system service.

00:15:10.280 --> 00:15:14.300
Similarly, when the last
active observer goes away,

00:15:14.300 --> 00:15:19.140
we want to stop observing
the system service.

00:15:19.140 --> 00:15:21.800
Now if you look at that
location LiveData class

00:15:21.800 --> 00:15:24.020
we just created in the
previous example, let's look

00:15:24.020 --> 00:15:26.210
at the properties of that class.

00:15:26.210 --> 00:15:28.100
First of all, it
is LifeCycle area.

00:15:28.100 --> 00:15:31.280
It knows when to start
itself, when to stop itself.

00:15:31.280 --> 00:15:34.340
You just don't need
to babysit it anymore.

00:15:34.340 --> 00:15:36.110
It is self-sufficient.

00:15:36.110 --> 00:15:37.140
You start it.

00:15:37.140 --> 00:15:39.480
You forget about it.

00:15:39.480 --> 00:15:40.470
It can be a singleton.

00:15:40.470 --> 00:15:42.620
Like all of the subscriptions
are automatically

00:15:42.620 --> 00:15:43.850
managed for you.

00:15:43.850 --> 00:15:47.090
So if the data is logically
singleton your codebase,

00:15:47.090 --> 00:15:50.030
you can make the LiveData
instance singleton.

00:15:50.030 --> 00:15:51.710
So there's this
thing where normally

00:15:51.710 --> 00:15:54.800
if you keep referencing
an activity or a fragment

00:15:54.800 --> 00:15:57.720
from a certain context,
that will be a big no no.

00:15:57.720 --> 00:16:00.350
But if you are using
LiveData it is yes yes,

00:16:00.350 --> 00:16:05.340
because we manage the
substitution for you.

00:16:05.340 --> 00:16:08.550
So you also don't need to
subclass LiveData all the time.

00:16:08.550 --> 00:16:10.910
So if you just need
an instance of it

00:16:10.910 --> 00:16:12.790
but you already
have the value, you

00:16:12.790 --> 00:16:14.990
could use this mutable
LiveData class,

00:16:14.990 --> 00:16:18.770
which comes inside the library
that has a public setter.

00:16:18.770 --> 00:16:21.170
But usually when you
are using this class,

00:16:21.170 --> 00:16:24.530
internally you will have
it but the API you expose

00:16:24.530 --> 00:16:26.360
will just return a
LiveData, because you

00:16:26.360 --> 00:16:28.370
don't want to expose
the fact that anyone

00:16:28.370 --> 00:16:31.470
can set the value on it.

00:16:31.470 --> 00:16:34.920
Now when we were designing
these LifeCycle components,

00:16:34.920 --> 00:16:38.730
the LiveData, see we
spent a lot of time

00:16:38.730 --> 00:16:41.380
to get rid of one exception.

00:16:41.380 --> 00:16:43.350
This fragment exception that I--

00:16:43.350 --> 00:16:50.520
[APPLAUSE]

00:16:50.520 --> 00:16:54.350
We really wanted to say, please,
no more fragment transaction

00:16:54.350 --> 00:16:55.460
exceptions.

00:16:55.460 --> 00:16:58.570
So LiveData guarantees that
if you received anywhere,

00:16:58.570 --> 00:17:00.910
you could run a
fragment transaction.

00:17:00.910 --> 00:17:05.310
And to see how we are making
it part of the history,

00:17:05.310 --> 00:17:10.119
I want to invite Adam
back to explain it to us.

00:17:10.119 --> 00:17:11.540
ADAM POWELL: All
right, so anyone

00:17:11.540 --> 00:17:13.206
who has received one
of these exceptions

00:17:13.206 --> 00:17:15.290
realizes that it
doesn't just come

00:17:15.290 --> 00:17:18.710
from trying to do something
when you just completely stopped

00:17:18.710 --> 00:17:20.349
and you absolutely know it.

00:17:20.349 --> 00:17:21.890
These exceptions
tend to come in when

00:17:21.890 --> 00:17:26.010
you get into very intricate,
nested life cycles.

00:17:26.010 --> 00:17:28.910
So we wanted to make sure to be
very thoughtful about defining

00:17:28.910 --> 00:17:34.190
how the LifeCycle observer
callbacks are invoked and when.

00:17:34.190 --> 00:17:37.400
So in a case like
this, what happens?

00:17:37.400 --> 00:17:42.120
You have defined handler
for the stop event.

00:17:42.120 --> 00:17:44.872
So in the container
your activity onStop,

00:17:44.872 --> 00:17:47.330
you want to make sure that you
don't get an onChanged event

00:17:47.330 --> 00:17:48.770
after the onStop has happened.

00:17:52.660 --> 00:17:54.570
But in order for
that to happen, what

00:17:54.570 --> 00:17:56.490
needs to be true
about when we actually

00:17:56.490 --> 00:18:00.030
invoke all of the
onStop listeners

00:18:00.030 --> 00:18:02.610
that are attached
to these observers.

00:18:02.610 --> 00:18:05.770
So we have to define a
really strict order for this.

00:18:05.770 --> 00:18:09.420
So as we go through create
and start and onResume,

00:18:09.420 --> 00:18:11.940
we know that we need
to invoke the LifeCycle

00:18:11.940 --> 00:18:15.480
observers after the
container event happens.

00:18:15.480 --> 00:18:18.090
So you know in your
observer that everything

00:18:18.090 --> 00:18:20.461
about your LifeCycle
owner has been configured.

00:18:20.461 --> 00:18:21.960
If you check any
state about it, you

00:18:21.960 --> 00:18:25.397
know that you're already
completely in that state.

00:18:25.397 --> 00:18:27.480
But that means something
really special for coming

00:18:27.480 --> 00:18:29.470
back down the other direction.

00:18:29.470 --> 00:18:33.540
It means that when the activity
starts to become paused,

00:18:33.540 --> 00:18:34.995
you want your
LifeCycle observers

00:18:34.995 --> 00:18:36.870
to be able to shut down
anything that they're

00:18:36.870 --> 00:18:39.060
doing before the activity
does all of the work

00:18:39.060 --> 00:18:41.400
to actually become paused.

00:18:41.400 --> 00:18:42.810
Similar for stop.

00:18:42.810 --> 00:18:44.850
And this is where
this becomes really

00:18:44.850 --> 00:18:47.220
important for the fragment
transaction exception.

00:18:47.220 --> 00:18:49.260
You want to make
sure that you're

00:18:49.260 --> 00:18:52.440
recording, that you're fully
stopped before the fragment

00:18:52.440 --> 00:18:54.600
system goes through
and flags everything

00:18:54.600 --> 00:18:58.180
as being completely locked out.

00:18:58.180 --> 00:19:01.410
So what that means is that the
stop event of your LifeCycle

00:19:01.410 --> 00:19:04.770
observer will always be invoked
before the activity onStop

00:19:04.770 --> 00:19:10.710
or before the full stop event
for your container happens.

00:19:10.710 --> 00:19:13.260
So this seems really similar
to some other libraries

00:19:13.260 --> 00:19:15.480
that some people may
have seen in the past.

00:19:15.480 --> 00:19:16.600
Can you talk about that?

00:19:16.600 --> 00:19:22.530
SERGEI VASILINETC: Yes, when we
create new observable pattern,

00:19:22.530 --> 00:19:26.220
nowadays this question
is unavoidable.

00:19:26.220 --> 00:19:29.220
Is it another RxJava?

00:19:29.220 --> 00:19:32.490
And the answer to
this question is, yes,

00:19:32.490 --> 00:19:34.740
because we want to promote
a reactive programming

00:19:34.740 --> 00:19:37.980
model, especially when it
comes to the relationship

00:19:37.980 --> 00:19:40.710
between your UI and the
state [INAUDIBLE] UI.

00:19:40.710 --> 00:19:45.490
We want you to react on
the changes of the state.

00:19:45.490 --> 00:19:48.300
So it means that it's a
reactive programming model.

00:19:48.300 --> 00:19:51.000
But on the other hand, no.

00:19:51.000 --> 00:19:54.840
Because it's the LifeCycle
aware out of box,

00:19:54.840 --> 00:19:57.930
as Yigit mentioned,
and it's much easier.

00:19:57.930 --> 00:20:02.940
As many of you may know,
the learning curve of RxJava

00:20:02.940 --> 00:20:04.560
is super steep.

00:20:04.560 --> 00:20:08.850
And if you have an
Android learner curve,

00:20:08.850 --> 00:20:13.350
and after that we add RxJava
learning curve on top of it,

00:20:13.350 --> 00:20:16.050
it becomes very
hard to new people

00:20:16.050 --> 00:20:19.420
to start to develop
on our platform.

00:20:19.420 --> 00:20:25.890
So we can't just say to them,
oh let's go, just learn this,

00:20:25.890 --> 00:20:27.330
that's it. .

00:20:27.330 --> 00:20:32.310
No, but if you already
learned RxJava,

00:20:32.310 --> 00:20:37.020
we don't expect you to migrate
from it to our solution.

00:20:37.020 --> 00:20:41.280
Because you already
passed the learning curve,

00:20:41.280 --> 00:20:45.960
you and your coworkers are
comfortable with it, fine.

00:20:45.960 --> 00:20:48.190
We are totally fine with this.

00:20:48.190 --> 00:20:51.330
But one thing we ask
you to do is to be sure

00:20:51.330 --> 00:20:53.920
that you manage LifeCycle.

00:20:53.920 --> 00:20:58.210
RxJava has common
approaches to solve this.

00:20:58.210 --> 00:21:02.430
Be sure to use it and
everything will be fine.

00:21:02.430 --> 00:21:09.885
But when you start a new app,
I think this model is the best.

00:21:09.885 --> 00:21:15.010
The best is to start the project
with LiveData, because it's

00:21:15.010 --> 00:21:17.310
simpler, it's faster,
it's lightweight,

00:21:17.310 --> 00:21:20.270
it's well integrated
with a framework.

00:21:20.270 --> 00:21:24.970
And if you feel like you love
reacting programming a lot,

00:21:24.970 --> 00:21:28.480
you want to bring it
not only to relation

00:21:28.480 --> 00:21:31.930
between UI and the state.

00:21:31.930 --> 00:21:33.430
You want to bring
it to the business

00:21:33.430 --> 00:21:36.340
part of your application.

00:21:36.340 --> 00:21:41.070
Then you may consider
the addition of RxJava,

00:21:41.070 --> 00:21:44.230
because it gives you more power.

00:21:44.230 --> 00:21:47.140
And we will actually
help you to do that.

00:21:47.140 --> 00:21:51.790
We have this extension
to our library, which

00:21:51.790 --> 00:21:55.780
gives a possibility to create
LiveData from Publisher

00:21:55.780 --> 00:21:58.930
and create Publisher
from LiveData.

00:21:58.930 --> 00:22:03.970
So this integration
should be quite smooth.

00:22:03.970 --> 00:22:07.330
But I want to highlight a
key difference between RxJava

00:22:07.330 --> 00:22:08.080
and LiveData.

00:22:08.080 --> 00:22:11.980
So as Yigit already
said, LiveData

00:22:11.980 --> 00:22:13.870
is a holder and not a stream.

00:22:13.870 --> 00:22:17.320
So we have a reference
to the last value,

00:22:17.320 --> 00:22:20.290
and observers immediately
receive the last value when

00:22:20.290 --> 00:22:24.820
they start to observe LiveData.

00:22:24.820 --> 00:22:27.550
And now the big difference
is a threading model.

00:22:27.550 --> 00:22:31.840
As you know, RxJava has a very
sophisticated threading model.

00:22:31.840 --> 00:22:35.390
It's extremely powerful,
but in most cases,

00:22:35.390 --> 00:22:37.610
you probably don't need it.

00:22:37.610 --> 00:22:40.360
And we have everything
on the main thread.

00:22:40.360 --> 00:22:42.190
And the reason for
this is we want

00:22:42.190 --> 00:22:47.150
to give you all these guarantees
about when we will notify you

00:22:47.150 --> 00:22:50.740
about state changes.

00:22:50.740 --> 00:22:56.200
And we can't do this
on a background thread.

00:22:56.200 --> 00:22:58.330
We have just the one exception.

00:22:58.330 --> 00:23:00.850
We have a post
value method which

00:23:00.850 --> 00:23:03.720
just is a method
which trampoline value

00:23:03.720 --> 00:23:07.725
from a background thread to the
main thread and sets it there.

00:23:07.725 --> 00:23:08.770
It's super simple.

00:23:08.770 --> 00:23:11.400
So quick summary of what
we have at this point.

00:23:11.400 --> 00:23:13.870
LiveData events,
observable pattern

00:23:13.870 --> 00:23:16.460
which respects these events.

00:23:16.460 --> 00:23:20.090
But there is one big thing
which is not covered yet.

00:23:20.090 --> 00:23:23.590
And this is how to handle
onConfigurationChanges.

00:23:23.590 --> 00:23:28.690
In 2017, almost nine
years after Android

00:23:28.690 --> 00:23:32.050
was first time released, we
still discuss this question.

00:23:32.050 --> 00:23:34.090
And this is a totally
legit question.

00:23:34.090 --> 00:23:38.290
And we hear it constantly
from new Android developers.

00:23:38.290 --> 00:23:40.730
Many of you probably know
whats the deal with it.

00:23:40.730 --> 00:23:44.770
But let's take a look at
this oversimplified example,

00:23:44.770 --> 00:23:47.830
but it's still very vivid.

00:23:47.830 --> 00:23:50.050
So he wants to show
this information

00:23:50.050 --> 00:23:52.060
about user and your activity.

00:23:52.060 --> 00:23:54.830
And you want to make
some web service request.

00:23:54.830 --> 00:24:00.340
We will use LiveData to get
this result. It's super simple.

00:24:00.340 --> 00:24:02.800
When the request is just
started, it's empty.

00:24:02.800 --> 00:24:06.620
When the request
response is received,

00:24:06.620 --> 00:24:11.740
we put it to
LiveData as a value.

00:24:11.740 --> 00:24:14.070
And later we'll update our UI.

00:24:14.070 --> 00:24:19.917
We will notify the activity, and
it will do everything it needs.

00:24:19.917 --> 00:24:22.250
So what happens if the activity
is going to [INAUDIBLE].

00:24:22.250 --> 00:24:25.750
We're going to
make a call twice,

00:24:25.750 --> 00:24:28.560
and I hope that you don't
call web service right

00:24:28.560 --> 00:24:29.740
into your activity.

00:24:29.740 --> 00:24:33.670
But you probably have
some abstractions

00:24:33.670 --> 00:24:36.010
that does something
like that, which

00:24:36.010 --> 00:24:41.040
goes to a network, which goes
to caching and persistence

00:24:41.040 --> 00:24:43.030
storages.

00:24:43.030 --> 00:24:47.170
And all the separations
are synchronized by nature.

00:24:47.170 --> 00:24:51.070
So communication of these
components are synchronized.

00:24:51.070 --> 00:24:55.510
And you probably don't want to
make these calls twice anyway.

00:24:55.510 --> 00:24:58.060
So what you want
to do is to cache.

00:24:58.060 --> 00:25:01.470
This is our data,
like in our example.

00:25:01.470 --> 00:25:04.480
And what are the ways
today to do that?

00:25:04.480 --> 00:25:06.960
Well, one of a
proposed way to do it

00:25:06.960 --> 00:25:10.570
is a Fragment.setRetainInstance,
and Yigit

00:25:10.570 --> 00:25:12.340
can rant about this for hours.

00:25:12.340 --> 00:25:14.770
Unfortunately, we don't
have time for this today.

00:25:14.770 --> 00:25:17.600
But I just say that
the only effect

00:25:17.600 --> 00:25:19.900
that you have to run
fragment transaction

00:25:19.900 --> 00:25:22.400
is terrifying for
a lot of people.

00:25:22.400 --> 00:25:25.780
People go nuts and
another possible way

00:25:25.780 --> 00:25:29.960
to solve this is loaders, but
we don't fit here well as well.

00:25:29.960 --> 00:25:33.010
So we decided to tackle
this problem once again

00:25:33.010 --> 00:25:35.230
and create ViewModel.

00:25:35.230 --> 00:25:36.030
So what is this?

00:25:36.030 --> 00:25:39.070
ViewModel is an object
which is associated

00:25:39.070 --> 00:25:41.440
with a fragment or an
activity, but is retained

00:25:41.440 --> 00:25:43.750
during configuration changes.

00:25:43.750 --> 00:25:48.190
So its scope is a kind of a
logical scope of your activity.

00:25:48.190 --> 00:25:51.300
So what does this mean?

00:25:51.300 --> 00:25:51.900
Let's see.

00:25:51.900 --> 00:25:54.220
If we have access time and
the current moment, and we

00:25:54.220 --> 00:25:55.540
can predict the future.

00:25:55.540 --> 00:25:57.670
And we know that activity
is going to be created,

00:25:57.670 --> 00:25:59.390
and this means that
all construction

00:25:59.390 --> 00:26:01.690
events are going to happen.

00:26:01.690 --> 00:26:05.440
During onCreate we will request
ViewModel for the first time.

00:26:05.440 --> 00:26:07.780
We will create it, and
after that this activity

00:26:07.780 --> 00:26:10.850
just uses this ViewModel.

00:26:10.850 --> 00:26:12.220
Very simple.

00:26:12.220 --> 00:26:16.060
Now we predict that the
activity is going to be rotated.

00:26:16.060 --> 00:26:20.700
Let's see what's going to
happen with our ViewModel.

00:26:20.700 --> 00:26:27.400
We will receive events,
onPause, onStop, and onDestroy.

00:26:27.400 --> 00:26:30.880
But when all the
segments are cured

00:26:30.880 --> 00:26:34.090
and your activity is
destroyed, it's thrown away

00:26:34.090 --> 00:26:38.210
and is garbage collected,
ViewModel survived it.

00:26:38.210 --> 00:26:42.070
And the new activity, which was
created in place the old one

00:26:42.070 --> 00:26:44.510
uses the same, old object.

00:26:44.510 --> 00:26:48.520
So you can easily cache
there LiveData as we want to

00:26:48.520 --> 00:26:50.690
or something else.

00:26:50.690 --> 00:26:52.720
The last case, what
is going to happen

00:26:52.720 --> 00:26:55.600
if you have finished goal?

00:26:55.600 --> 00:26:58.280
Once again, we will receive
these destruction events,

00:26:58.280 --> 00:27:01.570
but this time,
ViewModel is available

00:27:01.570 --> 00:27:03.130
until onDestroy method.

00:27:03.130 --> 00:27:08.340
During onDestroy method, we
will call onClear on this.

00:27:08.340 --> 00:27:11.860
Which notifies you if you have
any currently running actions

00:27:11.860 --> 00:27:15.610
or any resources
its time to close.

00:27:15.610 --> 00:27:18.900
And after that, it's
going to be destroyed

00:27:18.900 --> 00:27:20.150
and garbage collected as well.

00:27:20.150 --> 00:27:24.310
So at the point when your
activity is destroyed,

00:27:24.310 --> 00:27:27.340
it's not going to be
recreated it again.

00:27:27.340 --> 00:27:30.980
Your ViewModel is gone as well.

00:27:30.980 --> 00:27:37.970
So let's quickly make
our sample in ViewModel.

00:27:37.970 --> 00:27:40.900
So it starts with
instantiating-- with creation

00:27:40.900 --> 00:27:43.270
of ViewModel class.

00:27:43.270 --> 00:27:47.860
We want to cache for user data
to create a fill for that.

00:27:47.860 --> 00:27:50.680
We agree our activity needs
to access this LiveData,

00:27:50.680 --> 00:27:52.450
so we create a getter for this.

00:27:52.450 --> 00:27:55.960
And finally, getter is
extremely straightforward.

00:27:55.960 --> 00:27:59.530
If we already requested the
data, we just return it.

00:27:59.530 --> 00:28:04.780
If the data is now, we'll
request it from a web service

00:28:04.780 --> 00:28:06.580
and return it.

00:28:06.580 --> 00:28:07.422
Fine.

00:28:07.422 --> 00:28:08.880
We had [INAUDIBLE]
on our activity.

00:28:08.880 --> 00:28:12.580
Now we need to get this
LiveData from ViewModel.

00:28:12.580 --> 00:28:18.370
To get it, we need to create
to get ViewModel somehow.

00:28:18.370 --> 00:28:19.450
So this is how we do it.

00:28:19.450 --> 00:28:21.970
Let's take a precise look at it.

00:28:21.970 --> 00:28:25.000
First of all, we need to get
ViewModel provider object.

00:28:25.000 --> 00:28:27.250
This is an object
which is associated

00:28:27.250 --> 00:28:28.570
with a fragment or an activity.

00:28:28.570 --> 00:28:34.270
It knows how to get already
existing ViewModel from it

00:28:34.270 --> 00:28:36.740
or how to create a new one.

00:28:36.740 --> 00:28:39.250
If there is no
existing ViewModel.

00:28:39.250 --> 00:28:44.650
After that, we request
our myActivity ViewModel,

00:28:44.650 --> 00:28:48.617
and later everything
is quite simple.

00:28:48.617 --> 00:28:49.450
We get the userData.

00:28:49.450 --> 00:28:54.730
We observe it to update the UI.

00:28:54.730 --> 00:28:59.860
So what are the rules
of usage of ViewModel?

00:28:59.860 --> 00:29:04.660
So ViewModel manages
the data for the UI.

00:29:04.660 --> 00:29:08.290
It means that it
speaks with business

00:29:08.290 --> 00:29:11.510
parts of your application
to retrieve the data.

00:29:11.510 --> 00:29:15.470
So it may be a repository
pattern or any other pattern

00:29:15.470 --> 00:29:17.890
that they use.

00:29:17.890 --> 00:29:22.450
It also, it's for its
user modifications

00:29:22.450 --> 00:29:24.140
back to these components.

00:29:24.140 --> 00:29:26.720
And now a good
case for ViewModel

00:29:26.720 --> 00:29:30.730
is acting as a communication
layer between fragments

00:29:30.730 --> 00:29:32.530
in one activity.

00:29:32.530 --> 00:29:36.490
And Yigit will speak
about this later.

00:29:36.490 --> 00:29:40.840
But prior to this,
things that you must not

00:29:40.840 --> 00:29:42.560
do in your ViewModel.

00:29:42.560 --> 00:29:46.580
So first of all,
you must not access

00:29:46.580 --> 00:29:51.870
views and any other
UI- related entities.

00:29:51.870 --> 00:29:54.670
The reason for
that, they are going

00:29:54.670 --> 00:29:57.010
to be created during
configuration change.

00:29:57.010 --> 00:30:02.400
If you try to use them, you will
ever use stale data from there,

00:30:02.400 --> 00:30:05.250
ever to leak them.

00:30:05.250 --> 00:30:09.230
That's going to finish bad.

00:30:09.230 --> 00:30:12.280
And it's fragmented
or activity's job

00:30:12.280 --> 00:30:17.110
to bind the data which you
will get from a ViewModel

00:30:17.110 --> 00:30:21.260
with actual UI,
text use, buttons.

00:30:21.260 --> 00:30:23.190
I don't know what else.

00:30:23.190 --> 00:30:26.590
And one more thing,
there are sources

00:30:26.590 --> 00:30:31.120
which sound more harmless
like strings or drawable,

00:30:31.120 --> 00:30:33.790
and you may think,
I may cash it here.

00:30:33.790 --> 00:30:38.020
No, they depend on current
configuration state of state

00:30:38.020 --> 00:30:38.800
as well.

00:30:38.800 --> 00:30:43.360
So yes, right now you may
have just one resource

00:30:43.360 --> 00:30:46.540
for every configuration,
but later, you

00:30:46.540 --> 00:30:49.870
will add in the same resource
for a different configuration.

00:30:49.870 --> 00:30:54.010
You will easily forget
to update your ViewModel.

00:30:54.010 --> 00:30:58.540
And you may not notice
this, but your users

00:30:58.540 --> 00:31:00.250
will see the invalid UI.

00:31:00.250 --> 00:31:02.230
And this is just ugly.

00:31:02.230 --> 00:31:06.970
And now Yigit will speak about
Inter Fragment communications.

00:31:10.510 --> 00:31:12.270
YIGIT BOYAR: So I
want to talk about one

00:31:12.270 --> 00:31:16.050
of my favorite features
about ViewModel,

00:31:16.050 --> 00:31:19.020
which is communicating
between multiple fragments

00:31:19.020 --> 00:31:21.980
of the same activity.

00:31:21.980 --> 00:31:25.200
It's good that UI like this,
like the Gmail on the tablet

00:31:25.200 --> 00:31:29.500
where on the left side you pick
an email and on the right side,

00:31:29.500 --> 00:31:31.860
it shows the contents
of the email.

00:31:31.860 --> 00:31:34.560
Now usually you will
implement this as a fragment

00:31:34.560 --> 00:31:37.940
on the left which picks
something from the list,

00:31:37.940 --> 00:31:39.780
and another fragment
on the right, which

00:31:39.780 --> 00:31:42.960
shows how to show the
contents of an email

00:31:42.960 --> 00:31:45.330
so that if you're on the
phone you can reuse the same

00:31:45.330 --> 00:31:48.150
fragments but separate
from each other.

00:31:48.150 --> 00:31:52.170
Now if you ever tried to write
a UI like this, if you ever

00:31:52.170 --> 00:31:55.105
tried to make these two
fragments talk to each other,

00:31:55.105 --> 00:31:56.220
it's a pain in the neck.

00:31:56.220 --> 00:31:57.240
It's very, very hard.

00:31:57.240 --> 00:31:59.510
Like you need to
create an interface.

00:31:59.510 --> 00:32:01.530
But then what if
one fragment gets

00:32:01.530 --> 00:32:03.540
created before the other one.

00:32:03.540 --> 00:32:05.940
An activity needs to
talk to each other.

00:32:05.940 --> 00:32:07.931
Or like when the
activities are restored,

00:32:07.931 --> 00:32:09.430
you don't really
know which fragment

00:32:09.430 --> 00:32:11.340
will be restored first.

00:32:11.340 --> 00:32:14.880
It is really hard to
manage this state.

00:32:14.880 --> 00:32:21.020
But we can actually solve this
very elegantly using ViewModel.

00:32:21.020 --> 00:32:23.930
So let's say so these two
families actually want

00:32:23.930 --> 00:32:26.390
to talk about a selected email.

00:32:26.390 --> 00:32:29.060
This is the information
they want to share.

00:32:29.060 --> 00:32:30.950
So let's put it
inside a ViewModel

00:32:30.950 --> 00:32:33.920
and we are going to call
this shared ViewModel.

00:32:33.920 --> 00:32:36.130
So it has a mutable
LiveData inside it

00:32:36.130 --> 00:32:41.430
which you call selected, and it
provides two very simple APIs.

00:32:41.430 --> 00:32:45.410
The first one says, set the
select email to this email.

00:32:45.410 --> 00:32:49.610
Another one says, get the
selected email as a LiveData.

00:32:49.610 --> 00:32:52.510
It's a really simple ViewModel.

00:32:52.510 --> 00:32:56.030
But now once we have this,
let's go back to our fragments

00:32:56.030 --> 00:32:58.260
and see how we can use this.

00:32:58.260 --> 00:33:00.920
So inside the content
fragment, which is the one

00:33:00.920 --> 00:33:03.650
that wants to display the
contents of the email.

00:33:03.650 --> 00:33:07.550
It wants to know when the
selected email changes.

00:33:07.550 --> 00:33:09.930
So we're going to go-- so
we have already seen this.

00:33:09.930 --> 00:33:12.470
You can go to ViewModel
providers class

00:33:12.470 --> 00:33:15.230
and get the ViewModel
providers of this fragment.

00:33:15.230 --> 00:33:19.170
But we actually want ViewModel
not from this fragment,

00:33:19.170 --> 00:33:21.330
we want it from our activity.

00:33:21.330 --> 00:33:25.480
So all you have to do tell it
to do it from your activity.

00:33:25.480 --> 00:33:28.520
Now it's going to return your
ViewModel in the activity

00:33:28.520 --> 00:33:33.140
scope, and I will say, get
for the shared ViewModel.

00:33:33.140 --> 00:33:35.770
Now, the very first time one
of the fragments called this,

00:33:35.770 --> 00:33:37.460
we are going to
create a new one.

00:33:37.460 --> 00:33:39.520
When the other
fragment comes alive,

00:33:39.520 --> 00:33:42.830
it's going to receive the
same ViewModel instance.

00:33:42.830 --> 00:33:44.100
And I will do the same thing.

00:33:44.100 --> 00:33:46.650
So this one says, get
the selected email.

00:33:46.650 --> 00:33:48.662
Start observing on it.

00:33:48.662 --> 00:33:50.540
Really similarly, in
the select fragment

00:33:50.540 --> 00:33:54.500
which was the one on the
left by user pics and email,

00:33:54.500 --> 00:33:57.410
we get the same ViewModel.

00:33:57.410 --> 00:34:00.680
And whenever the user selects
an email from the list,

00:34:00.680 --> 00:34:03.080
we just call the
ViewModel- related method

00:34:03.080 --> 00:34:05.120
to change the selected email.

00:34:05.120 --> 00:34:08.239
Now these two fragments
talking to each other

00:34:08.239 --> 00:34:10.710
without actually
talking to each other.

00:34:10.710 --> 00:34:13.730
How does this really happen?

00:34:13.730 --> 00:34:15.380
So if we go back to our UI.

00:34:15.380 --> 00:34:18.679
So we have the selector on the
left, the content on the right.

00:34:18.679 --> 00:34:21.320
But if you look at the
details, actually both of these

00:34:21.320 --> 00:34:23.060
are talking to a
shared ViewModel.

00:34:23.060 --> 00:34:25.040
They never talk to each other.

00:34:25.040 --> 00:34:28.580
The video of this solution is
that if you're on the phone,

00:34:28.580 --> 00:34:31.280
let's say one fragment
replaces the other one,

00:34:31.280 --> 00:34:33.080
there's no room for error.

00:34:33.080 --> 00:34:35.270
Like the fragment still
talks to a ViewModel.

00:34:35.270 --> 00:34:37.370
ViewModels always that
nothing will crash.

00:34:37.370 --> 00:34:39.770
They don't even care
the other one is there.

00:34:42.810 --> 00:34:45.349
Okay, so this is a
lot of information,

00:34:45.349 --> 00:34:47.670
and there's further
details about how

00:34:47.670 --> 00:34:49.170
these life cycles work.

00:34:49.170 --> 00:34:51.330
We really spent a
lot of time to make

00:34:51.330 --> 00:34:55.260
these handle most common
used cases on Android.

00:34:55.260 --> 00:34:58.620
So we come in just
the first trade out.

00:34:58.620 --> 00:35:03.150
You could try it
now, in [INAUDIBLE].

00:35:03.150 --> 00:35:05.850
Please check out all of the
architecture components.

00:35:05.850 --> 00:35:08.640
These are things that actually
work very well together.

00:35:08.640 --> 00:35:11.070
We have an architecture
guide which shows you

00:35:11.070 --> 00:35:15.330
how to use these things together
to write a good application.

00:35:15.330 --> 00:35:16.980
And also check our code labs.

00:35:16.980 --> 00:35:20.490
We have code lab sections that
will give you a first glimpse

00:35:20.490 --> 00:35:23.841
of how LifeCycles work.

00:35:23.841 --> 00:35:24.340
Thank you

00:35:24.340 --> 00:35:26.815
[APPLAUSE]

00:35:26.815 --> 00:35:29.055
[MUSIC PLAYING]

