WEBVTT
Kind: captions
Language: en

00:00:00.080 --> 00:00:02.430
The following content is
provided under a Creative

00:00:02.430 --> 00:00:03.810
Commons license.

00:00:03.810 --> 00:00:06.050
Your support will help
MIT OpenCourseWare

00:00:06.050 --> 00:00:10.170
continue to offer high quality
educational resources for free.

00:00:10.170 --> 00:00:12.690
To make a donation or to
view additional materials

00:00:12.690 --> 00:00:16.600
from hundreds of MIT courses,
visit MIT OpenCourseWare

00:00:16.600 --> 00:00:17.305
at ocw.mit.edu.

00:00:20.814 --> 00:00:22.730
PROFESSOR: Right, so now
I'm going to walk you

00:00:22.730 --> 00:00:24.140
through some examples.

00:00:24.140 --> 00:00:29.490
And just so you know where
this stuff is-- so you all

00:00:29.490 --> 00:00:31.440
have your LLGrid accounts.

00:00:31.440 --> 00:00:33.900
And in your LLGrid accounts--
and I'm looking over here

00:00:33.900 --> 00:00:35.440
because these people are
going to check to make sure

00:00:35.440 --> 00:00:36.880
I don't say anything wrong.

00:00:36.880 --> 00:00:38.780
So this is, by the way,
this is [INAUDIBLE]

00:00:38.780 --> 00:00:40.670
over here and Julie Mullin.

00:00:40.670 --> 00:00:45.780
They are our expert consultants,
PhDs in computational science,

00:00:45.780 --> 00:00:47.420
that help you all.

00:00:47.420 --> 00:00:50.400
And we're all eternally
grateful to them

00:00:50.400 --> 00:00:54.080
for helping us get all
this technology to work.

00:00:54.080 --> 00:00:58.060
So if you go to
your LLGrid account,

00:00:58.060 --> 00:01:02.332
there should be a link
in there called Tools.

00:01:02.332 --> 00:01:04.040
This is where all the
software is that we

00:01:04.040 --> 00:01:05.750
provide as part of LLGrid.

00:01:05.750 --> 00:01:08.510
And there'll be one
called d4m_api in there.

00:01:08.510 --> 00:01:11.340
So there'll be a
folder just like this.

00:01:11.340 --> 00:01:17.490
And just so you know-- so all
the lectures are there for you.

00:01:17.490 --> 00:01:20.530
And I am putting them all
in for public release.

00:01:20.530 --> 00:01:23.160
And all the software we're going
to post on the internet too.

00:01:23.160 --> 00:01:26.140
And so just make
it easier for you

00:01:26.140 --> 00:01:28.530
to use, use with
your government-- use

00:01:28.530 --> 00:01:30.492
with your sponsors,
use with your projects,

00:01:30.492 --> 00:01:31.450
all that kind of stuff.

00:01:31.450 --> 00:01:34.860
We try and do that so that
people aren't constantly asking

00:01:34.860 --> 00:01:36.100
us, well, what can I share?

00:01:36.100 --> 00:01:38.058
It's like, I'm going to
put it on the internet.

00:01:38.058 --> 00:01:38.950
So there you go.

00:01:42.240 --> 00:01:44.360
We want to focus on the
examples directory here.

00:01:47.100 --> 00:01:50.860
The order of the examples
is numerical order.

00:01:50.860 --> 00:01:53.960
So we are going to
go through examples

00:01:53.960 --> 00:01:56.640
in the folder called one
and then two and then three.

00:01:56.640 --> 00:01:58.890
And this really corresponds
to kind of the first three

00:01:58.890 --> 00:02:01.590
lectures, then the
next three lectures,

00:02:01.590 --> 00:02:04.650
then the next
three lectures, OK?

00:02:04.650 --> 00:02:08.720
And so today, we're going to
go in here to this first one.

00:02:08.720 --> 00:02:11.465
And then here is kind of like
the first three of those three.

00:02:11.465 --> 00:02:12.840
We're going to go
and we're going

00:02:12.840 --> 00:02:17.530
to review this set here, OK?

00:02:17.530 --> 00:02:22.180
So these are the-- the examples
of have this sort of-- they

00:02:22.180 --> 00:02:23.760
basically take the
first two letters

00:02:23.760 --> 00:02:29.540
of the folder-- in this case,
[INAUDIBLE] intro AI 1234.

00:02:29.540 --> 00:02:30.810
Those are the actual examples.

00:02:30.810 --> 00:02:34.297
If you see other files in there,
those are supporting files.

00:02:34.297 --> 00:02:35.505
You don't run those directly.

00:02:38.040 --> 00:02:40.940
So I'm going to start my--
I'm going to-- I always run

00:02:40.940 --> 00:02:41.960
MATLAB from the shell.

00:02:41.960 --> 00:02:44.150
Other people run
it from the IDE.

00:02:44.150 --> 00:02:47.320
I'm going to create
a shell here.

00:02:51.930 --> 00:02:53.100
[INAUDIBLE] folder.

00:02:53.100 --> 00:02:56.350
I'm going to start my MATLAB up.

00:02:56.350 --> 00:02:58.050
This will take a
minute because we're

00:02:58.050 --> 00:03:06.238
reusing 2012B, which is a little
bit slower on this computer.

00:03:06.238 --> 00:03:07.210
All right, there we go.

00:03:13.016 --> 00:03:14.640
And you'll be pleased
to know I develop

00:03:14.640 --> 00:03:18.312
all the [? D form ?] software
on this little computer.

00:03:18.312 --> 00:03:20.020
And people are going,
well, why don't you

00:03:20.020 --> 00:03:23.410
get a big giant workstation
to develop your programs on?

00:03:23.410 --> 00:03:25.900
It's like, well, because
if it feels OK for me

00:03:25.900 --> 00:03:27.810
on this computer, I
know that most of you

00:03:27.810 --> 00:03:29.270
have much better computers.

00:03:29.270 --> 00:03:32.830
And it will feel-- should feel
very, very, very good for you.

00:03:32.830 --> 00:03:34.251
All right, so we're
in the folder.

00:03:34.251 --> 00:03:36.750
And I'm just going to run the
first program-- AI1_SetupTEST.

00:03:43.780 --> 00:03:46.080
Actually, before we
even get into that,

00:03:46.080 --> 00:03:47.830
the first thing you're
going to want to do

00:03:47.830 --> 00:03:51.920
is check before you run
this that your D4M code has

00:03:51.920 --> 00:03:52.910
been properly set up.

00:03:52.910 --> 00:03:55.545
The simplest way to do that
is when you start MATLAB,

00:03:55.545 --> 00:04:00.930
if you type help D4M
and you get a list

00:04:00.930 --> 00:04:03.990
of all the functions
in D4M, then

00:04:03.990 --> 00:04:08.050
that means that your
path is set up properly.

00:04:08.050 --> 00:04:11.580
And this is just a list of
all the different functions.

00:04:11.580 --> 00:04:13.900
We break them down
in different types.

00:04:13.900 --> 00:04:16.329
You've got a little sort
of like how to set up here,

00:04:16.329 --> 00:04:19.100
although a lot of this stuff
isn't-- is written for more

00:04:19.100 --> 00:04:20.772
people on the outside world.

00:04:20.772 --> 00:04:22.230
And we go through
all the functions

00:04:22.230 --> 00:04:23.929
and we categorize the functions.

00:04:23.929 --> 00:04:25.720
You know, some are
functions that we really

00:04:25.720 --> 00:04:28.020
expect to use all the time.

00:04:28.020 --> 00:04:30.590
Some are functions
that you might use once

00:04:30.590 --> 00:04:31.745
in kind of rare instances.

00:04:31.745 --> 00:04:33.950
And then we also have
functions like, look,

00:04:33.950 --> 00:04:35.200
you really-- they're there.

00:04:35.200 --> 00:04:36.010
They're in the library.

00:04:36.010 --> 00:04:37.830
These are really not meant
for you to use, though.

00:04:37.830 --> 00:04:39.780
They're really internal
supporting functions.

00:04:39.780 --> 00:04:42.050
But they're there
in the library.

00:04:42.050 --> 00:04:45.840
All right, so that's the
first thing you want to check

00:04:45.840 --> 00:04:47.910
is to make sure that's set up.

00:04:47.910 --> 00:04:54.680
If you have any issues, send
email to grid-help@ll.mit.edu

00:04:54.680 --> 00:04:57.340
and the people will help
you in and check it out.

00:04:57.340 --> 00:05:01.180
And don't be surprised if
some of you do have an issue.

00:05:01.180 --> 00:05:03.640
This is the first time
we've really rolled it out

00:05:03.640 --> 00:05:05.300
to such a large audience.

00:05:05.300 --> 00:05:07.920
And so we absolutely
expect people to have

00:05:07.920 --> 00:05:12.338
little things that will pop up.

00:05:12.338 --> 00:05:17.960
All right, so I'm going to
run the first example here.

00:05:17.960 --> 00:05:21.010
I should say we also have
tested all the stuff.

00:05:21.010 --> 00:05:26.920
For those of you who are utterly
averse to commercial software,

00:05:26.920 --> 00:05:28.850
depending on your
religious preferences,

00:05:28.850 --> 00:05:31.120
we also run with
GNU Octave, which

00:05:31.120 --> 00:05:32.840
is the GPL version
for those of you

00:05:32.840 --> 00:05:36.570
who refuse to run
non-free software.

00:05:36.570 --> 00:05:38.860
And so this-- all
this stuff should also

00:05:38.860 --> 00:05:41.520
work with that as well
just for those people who

00:05:41.520 --> 00:05:43.710
prefer to use that
type of environment.

00:05:43.710 --> 00:05:46.350
But generally,
MATLAB-- you know,

00:05:46.350 --> 00:05:48.840
it's pretty available here.

00:05:48.840 --> 00:05:53.870
And so we certainly
encourage you to use that.

00:05:53.870 --> 00:05:57.760
So we're going to run
the first test here.

00:05:57.760 --> 00:06:01.730
AI1_SetupTEST-- Go.

00:06:01.730 --> 00:06:03.390
Yay, it worked.

00:06:03.390 --> 00:06:07.400
It's embarrassing when you're
recording and these don't work.

00:06:07.400 --> 00:06:10.740
So I'm going to walk you through
some really rudimentary stuff

00:06:10.740 --> 00:06:13.780
here in this example.

00:06:13.780 --> 00:06:16.850
So one of the things in D4M
that you're dealing with a lot

00:06:16.850 --> 00:06:22.880
is lists of strings--
long list of strings,

00:06:22.880 --> 00:06:26.470
millions of distinct strings.

00:06:26.470 --> 00:06:28.980
Now, MATLAB has
data structures that

00:06:28.980 --> 00:06:33.185
do support lists of strings,
cell arrays being one of them.

00:06:33.185 --> 00:06:35.560
There's other data structure
that you can use to do that.

00:06:35.560 --> 00:06:36.920
They naturally support these.

00:06:36.920 --> 00:06:42.400
But they tend to be very
memory intensive and very slow.

00:06:42.400 --> 00:06:45.700
And so given our
whole thing here

00:06:45.700 --> 00:06:47.970
is we have a real
focus on performance,

00:06:47.970 --> 00:06:49.480
me giving you a
great tool that's

00:06:49.480 --> 00:06:54.520
1,000 times slower than other
techniques is not very helpful.

00:06:54.520 --> 00:06:57.470
So we are going to be
dealing with list of strings

00:06:57.470 --> 00:06:58.090
all the time.

00:06:58.090 --> 00:07:03.140
And so in D4M, a list of strings
is a row vector of characters,

00:07:03.140 --> 00:07:03.640
OK?

00:07:03.640 --> 00:07:05.140
I've highlighted here.

00:07:05.140 --> 00:07:09.540
And the last character in the
row vector is the delimiter.

00:07:09.540 --> 00:07:11.290
In this case, it's the comma.

00:07:11.290 --> 00:07:12.620
You're at the end.

00:07:12.620 --> 00:07:14.210
That is the delimiter.

00:07:14.210 --> 00:07:17.910
It can be whatever
you want it to be.

00:07:17.910 --> 00:07:19.140
It can be semicolon.

00:07:19.140 --> 00:07:20.655
It can be a dash.

00:07:20.655 --> 00:07:22.500
It can be a space.

00:07:22.500 --> 00:07:27.080
I tend to recommend new line,
which is ASCII character 10--

00:07:27.080 --> 00:07:29.130
very safe delimiter.

00:07:29.130 --> 00:07:33.540
But whatever that last character
is, that's the limiter.

00:07:33.540 --> 00:07:36.530
And you could have different
lists, different strings

00:07:36.530 --> 00:07:37.980
with different delimiters.

00:07:37.980 --> 00:07:41.730
It should handle those
situations just fine.

00:07:44.820 --> 00:07:47.800
But within a list
of strings, it needs

00:07:47.800 --> 00:07:51.060
to be that-- that last
character will be the delimiter.

00:07:51.060 --> 00:07:55.270
So I'm actually
creating here a list.

00:07:55.270 --> 00:07:57.270
I'm going to creating a
set of triples here-- r,

00:07:57.270 --> 00:07:59.380
which is the rows, c,
which is the columns, v,

00:07:59.380 --> 00:08:01.000
which is the values.

00:08:01.000 --> 00:08:03.870
And so I have an
r, which is this.

00:08:03.870 --> 00:08:06.650
I have a set of c
here, which is this.

00:08:06.650 --> 00:08:08.960
Vector here and then
a list of values--

00:08:08.960 --> 00:08:11.910
and the values in
this case are just

00:08:11.910 --> 00:08:15.120
appending the row and the
column together with a dash.

00:08:15.120 --> 00:08:18.360
And all three of
these use the comma

00:08:18.360 --> 00:08:22.109
as-- it's the last character--
as the delimiter, all right?

00:08:22.109 --> 00:08:24.400
And now I'm going to create
an associative array, which

00:08:24.400 --> 00:08:27.610
is the fundamental
data structure in D4M.

00:08:27.610 --> 00:08:29.750
It's what allows us to
bridge linear algebra

00:08:29.750 --> 00:08:31.430
and strings together.

00:08:31.430 --> 00:08:35.080
So this is a constructor command
for an associative array--

00:08:35.080 --> 00:08:36.190
so Assoc.

00:08:36.190 --> 00:08:41.030
And then we give it
a list of row keys.

00:08:41.030 --> 00:08:44.080
These are called-- we often call
them keys-- list of column keys

00:08:44.080 --> 00:08:46.710
and a list of string values.

00:08:46.710 --> 00:08:49.740
And this construct the
associative array a.

00:08:49.740 --> 00:08:51.660
And in MATLAB, since
I haven't terminated

00:08:51.660 --> 00:08:54.127
this with a semicolon, it
will now will print out

00:08:54.127 --> 00:08:54.960
the list of triples.

00:08:54.960 --> 00:08:57.970
So now you can see the list of
triples we can construct here

00:08:57.970 --> 00:09:07.810
was row a, column a, value a-a,
row aa, column a, value aa-a,

00:09:07.810 --> 00:09:10.310
and I won't read the whole list.

00:09:10.310 --> 00:09:10.810
Yes, Darryl.

00:09:10.810 --> 00:09:12.101
AUDIENCE: Question. [INAUDIBLE]

00:09:16.850 --> 00:09:19.850
PROFESSOR: That is an artifact
of this printing out display.

00:09:19.850 --> 00:09:23.710
It will show you the delimiter
that you actually used here

00:09:23.710 --> 00:09:26.707
just as-- and it's
good to know that you--

00:09:26.707 --> 00:09:28.040
AUDIENCE: It's not really there.

00:09:28.040 --> 00:09:29.150
PROFESSOR: It's
not really there.

00:09:29.150 --> 00:09:30.810
Yeah, I mean, it's there
and it's not there.

00:09:30.810 --> 00:09:32.240
But it's showing
you the delimiter.

00:09:32.240 --> 00:09:34.630
And after a while, you just
kind of learn to ignore that.

00:09:34.630 --> 00:09:36.921
The only time this does become
a little bit of an issue

00:09:36.921 --> 00:09:40.060
is that that is the
newline character.

00:09:40.060 --> 00:09:42.130
Then the formatting
gets a little bit--

00:09:42.130 --> 00:09:44.080
and we've actually
built in routines

00:09:44.080 --> 00:09:45.913
that allow you to take
an associative array,

00:09:45.913 --> 00:09:48.630
replace the delimiter with
something nicer in one command

00:09:48.630 --> 00:09:52.940
so that you can print it out and
doesn't look so crazy if you're

00:09:52.940 --> 00:09:54.587
using a new line.

00:09:54.587 --> 00:09:56.670
Typically, though, you
tend to be doing this print

00:09:56.670 --> 00:09:58.460
out command on small things.

00:09:58.460 --> 00:10:01.840
So it's fine.

00:10:01.840 --> 00:10:04.440
So that's the whole
list, you see there,

00:10:04.440 --> 00:10:08.650
of all the different entries.

00:10:08.650 --> 00:10:12.590
If you use the disp
command, it will actually

00:10:12.590 --> 00:10:17.700
display the internal structure
of the associative array.

00:10:17.700 --> 00:10:23.110
And an associative array object
in D4M has four fields total.

00:10:23.110 --> 00:10:24.020
That's it.

00:10:24.020 --> 00:10:26.970
We do everything with
just four fields.

00:10:26.970 --> 00:10:30.190
And the four fields
are a set of row keys.

00:10:30.190 --> 00:10:34.410
This is a lexicographically
sorted list

00:10:34.410 --> 00:10:37.590
of the unique row keys.

00:10:37.590 --> 00:10:40.200
And it's stored
as a string list.

00:10:40.200 --> 00:10:43.600
So in this case, we had
six unique row keys.

00:10:43.600 --> 00:10:49.420
And we have six entries
in this row string list.

00:10:49.420 --> 00:10:52.390
Likewise, the column
is the same thing.

00:10:52.390 --> 00:10:54.360
We have these six
unique entries.

00:10:54.360 --> 00:10:57.400
And you see they inherit
the delimiter that

00:10:57.400 --> 00:10:58.750
was passed into them.

00:10:58.750 --> 00:11:02.730
If I'd used different ones, you
would see different delimiters.

00:11:02.730 --> 00:11:09.050
And then the value, which
is another list that

00:11:09.050 --> 00:11:14.490
shows all the different
strings, OK, and then

00:11:14.490 --> 00:11:19.870
a matrix, which shows--
which is a six by six matrix.

00:11:19.870 --> 00:11:24.520
So this is a six by
six associative array.

00:11:24.520 --> 00:11:26.490
And this is the pointer.

00:11:26.490 --> 00:11:31.460
Basically, the value stored in a
six by six sparse matrix points

00:11:31.460 --> 00:11:34.470
to the index of the value.

00:11:34.470 --> 00:11:36.884
So you can view that as
a pointer to the values.

00:11:36.884 --> 00:11:38.300
And this is how
we can have values

00:11:38.300 --> 00:11:40.180
that are actually strings.

00:11:40.180 --> 00:11:41.520
That may not be quite clear.

00:11:41.520 --> 00:11:43.430
There's an easier
way to do this.

00:11:43.430 --> 00:11:45.430
So we have a little routine
function here called

00:11:45.430 --> 00:11:51.840
displayFull, which produces a
nice tabular view of the data.

00:11:51.840 --> 00:11:56.120
So here's the row keys, the
column keys, and the values.

00:11:56.120 --> 00:11:58.900
And you see this was the
matrix I constructed.

00:11:58.900 --> 00:12:03.480
You had a full first
column and a full first row

00:12:03.480 --> 00:12:06.320
and then values
along the diagonal.

00:12:09.340 --> 00:12:13.651
And then what we're going to
do is we want to save this.

00:12:13.651 --> 00:12:14.650
We want to write it out.

00:12:14.650 --> 00:12:16.233
So we're going to
write it out to-- we

00:12:16.233 --> 00:12:18.660
have a function
[INAUDIBLE] assoc to CSV.

00:12:18.660 --> 00:12:20.490
So I pass an associative array.

00:12:20.490 --> 00:12:25.144
I give it the row terminator and
the column separator and a file

00:12:25.144 --> 00:12:26.560
name and we'll
write that data out

00:12:26.560 --> 00:12:30.750
to a CSV file, which
is very convenient.

00:12:30.750 --> 00:12:32.230
[INAUDIBLE] actually hide that.

00:12:32.230 --> 00:12:37.490
You can see here
is the CSV file.

00:12:37.490 --> 00:12:38.780
So you can look at it.

00:12:38.780 --> 00:12:41.030
There's the CSV file.

00:12:41.030 --> 00:12:44.322
You can zoom in on that for you.

00:12:44.322 --> 00:12:45.260
Can you see?

00:12:45.260 --> 00:12:45.760
There we go.

00:12:45.760 --> 00:12:50.890
Those are our six rows, six
columns against first row,

00:12:50.890 --> 00:12:54.485
against first column, and
our diagonal, all right?

00:12:58.480 --> 00:13:00.810
All right, so
let's go back here.

00:13:00.810 --> 00:13:04.990
Now let's go to
our next example,

00:13:04.990 --> 00:13:07.376
which is going to be AI2.

00:13:07.376 --> 00:13:09.000
And now we're going
to talk about how--

00:13:09.000 --> 00:13:11.839
we sort of described how we put
data into an associative array.

00:13:11.839 --> 00:13:14.380
We're now going to talk about
how we query it or get data out

00:13:14.380 --> 00:13:16.191
of the associative array.

00:13:16.191 --> 00:13:18.190
And one thing that's very
nice about the queries

00:13:18.190 --> 00:13:20.730
that I will show you as
we get to the later parts

00:13:20.730 --> 00:13:22.399
of the [? course ?]
we do databases,

00:13:22.399 --> 00:13:24.440
whether you're querying
an associate array that's

00:13:24.440 --> 00:13:29.010
in memory or binding to
a table, it's the same.

00:13:29.010 --> 00:13:31.510
We try and make it so
that almost everything you

00:13:31.510 --> 00:13:34.580
would do in an associate array,
you could also do on a table.

00:13:34.580 --> 00:13:36.810
So you can write your
programs in associative arrays

00:13:36.810 --> 00:13:38.560
and then switch a
couple things and now it

00:13:38.560 --> 00:13:41.610
should also work on tables
in the database the same way.

00:13:41.610 --> 00:13:43.300
And so we try and
preserve that concept.

00:13:43.300 --> 00:13:47.150
The only difference is that a
table [? in ?] databases just

00:13:47.150 --> 00:13:50.880
can be much, much bigger than
an associative array you would

00:13:50.880 --> 00:13:54.275
have in your memory space.

00:13:54.275 --> 00:13:55.900
All right, so you're
going to run that.

00:13:55.900 --> 00:13:57.996
That's the next example.

00:13:57.996 --> 00:13:59.370
So the first thing
we did is when

00:13:59.370 --> 00:14:00.820
we wrote out the
associate array,

00:14:00.820 --> 00:14:01.720
we're going to read it back in.

00:14:01.720 --> 00:14:03.560
So we have a nice
function here called

00:14:03.560 --> 00:14:07.605
ReadCSV that reads CSV files.

00:14:10.720 --> 00:14:14.150
Just so you know,
Microsoft Excel

00:14:14.150 --> 00:14:18.850
does write out a
non-standard CSV file.

00:14:18.850 --> 00:14:21.090
Microsoft Excel
[INAUDIBLE] common-- that

00:14:21.090 --> 00:14:30.310
is, if you have a row that is
empty after a certain point,

00:14:30.310 --> 00:14:35.540
it won't write out those commas,
which is technically probably

00:14:35.540 --> 00:14:37.947
not conformant with the
official CSV format,

00:14:37.947 --> 00:14:40.530
although I don't know there is
a sufficiently written down CSV

00:14:40.530 --> 00:14:41.120
format, right?

00:14:41.120 --> 00:14:43.171
You can describe it in one line.

00:14:43.171 --> 00:14:44.920
So you just have to
be careful about that.

00:14:44.920 --> 00:14:48.085
If you see this issue, people
write out a CSV from Excel.

00:14:48.085 --> 00:14:54.240
And if there's an empty
last-- if it's last row is not

00:14:54.240 --> 00:14:59.160
fully dense or if its last
column is not a dense column,

00:14:59.160 --> 00:15:03.440
you can get this issue and
it will screw this stuff up.

00:15:03.440 --> 00:15:06.490
We also don't support
quoted strings.

00:15:06.490 --> 00:15:08.835
Way to do that, though,
is to create a TSV file.

00:15:08.835 --> 00:15:10.470
So put tabs in there.

00:15:10.470 --> 00:15:15.367
And we support tab-- just, if
you just call this a TSV file,

00:15:15.367 --> 00:15:16.825
when you write it
out, you can have

00:15:16.825 --> 00:15:19.449
your separator via tab
instead of column, a comma,

00:15:19.449 --> 00:15:20.490
and then you're all good.

00:15:20.490 --> 00:15:22.590
And so that's how
we support that.

00:15:22.590 --> 00:15:25.335
So we're going to now-- so
that's how you read it in.

00:15:25.335 --> 00:15:26.960
And now we're going
to do a whole bunch

00:15:26.960 --> 00:15:27.900
of different queries.

00:15:27.900 --> 00:15:30.840
These are all what are
relatively complicated queries.

00:15:30.840 --> 00:15:36.430
So the first one here
is get me rows a and b.

00:15:36.430 --> 00:15:39.920
So if I pass in a string
list just like the-- whoops,

00:15:39.920 --> 00:15:43.000
didn't want to do that.

00:15:43.000 --> 00:15:43.890
Let's see here.

00:15:43.890 --> 00:15:47.550
We pass in a string list of the
same type that I have before.

00:15:47.550 --> 00:15:51.640
And I just say this exact
same type of indexing

00:15:51.640 --> 00:15:54.349
that we normally have in
MATLAB where you're like,

00:15:54.349 --> 00:15:55.640
I want to get it a set of rows.

00:15:55.640 --> 00:15:56.990
I give it a set of rows.

00:15:56.990 --> 00:16:00.890
And so this says,
get me rows a and b.

00:16:00.890 --> 00:16:02.980
And give me the
whole row-- colon--

00:16:02.980 --> 00:16:06.550
use the standard MATLAB syntax
that colon means full row.

00:16:06.550 --> 00:16:08.780
Likewise, if a was a
binding to a table,

00:16:08.780 --> 00:16:11.610
it would deliver the exact
same query to the database

00:16:11.610 --> 00:16:15.130
and return the exact same
thing in associative array.

00:16:15.130 --> 00:16:17.680
Here's another more
complicated that says get me

00:16:17.680 --> 00:16:22.560
all rows containing a.

00:16:22.560 --> 00:16:25.702
So our wild card character
is a little liberal here.

00:16:25.702 --> 00:16:27.660
It will just give you
anything containing an a.

00:16:27.660 --> 00:16:30.620
It doesn't really respect
beginnings or endings

00:16:30.620 --> 00:16:31.860
or anything like that.

00:16:31.860 --> 00:16:34.100
It's kind of a
regular expression.

00:16:34.100 --> 00:16:40.490
And this says get any row
containing a and column's one

00:16:40.490 --> 00:16:41.440
through three.

00:16:41.440 --> 00:16:44.391
So we can use numerical indexes.

00:16:44.391 --> 00:16:45.890
Sometimes, you're
just like, I don't

00:16:45.890 --> 00:16:47.014
care what the row keys are.

00:16:47.014 --> 00:16:50.220
Just give me the first 10
columns or the first 10 rows.

00:16:50.220 --> 00:16:55.380
And that will return this, OK?

00:16:55.380 --> 00:17:00.370
This is one feature that does
not work on all databases.

00:17:00.370 --> 00:17:05.109
Some database have a
concept-- the numerical index

00:17:05.109 --> 00:17:05.770
of a column.

00:17:05.770 --> 00:17:07.240
And some databases do not.

00:17:07.240 --> 00:17:10.919
So it's dependent on
the actual database.

00:17:10.919 --> 00:17:11.710
Here's another one.

00:17:11.710 --> 00:17:12.849
This is a range query.

00:17:12.849 --> 00:17:16.200
So if you remember in MATLAB,
if you do colon and two values,

00:17:16.200 --> 00:17:17.450
it gives you a range.

00:17:17.450 --> 00:17:19.060
So we can do a range query here.

00:17:19.060 --> 00:17:25.140
So a-- give me all
columns a through b.

00:17:25.140 --> 00:17:26.650
If you really
wanted to just get--

00:17:26.650 --> 00:17:29.100
we have something called a
starts with, which is something

00:17:29.100 --> 00:17:30.683
like-- a lot of
times, you'll be like,

00:17:30.683 --> 00:17:33.470
I want to just get the
rows or the columns that

00:17:33.470 --> 00:17:35.000
begin with a certain string.

00:17:35.000 --> 00:17:37.280
So we have a little
shorthand routine here

00:17:37.280 --> 00:17:38.530
that constructs that for you.

00:17:38.530 --> 00:17:42.572
So this says, get me all
rows starting with a and c.

00:17:42.572 --> 00:17:44.530
Likewise, I can do the
same thing with columns.

00:17:44.530 --> 00:17:46.835
I can say get me
columns a and b.

00:17:46.835 --> 00:17:53.960
I can say get me all columns
that contain a with columns--

00:17:53.960 --> 00:17:55.520
with rows one through three.

00:17:55.520 --> 00:17:57.930
Like I said, I can do
column ranges here.

00:17:57.930 --> 00:18:00.790
I can say, give me
all columns a to b.

00:18:00.790 --> 00:18:03.180
Likewise, I can do the
starts with command

00:18:03.180 --> 00:18:08.540
as well as give me all
columns starting with a or c.

00:18:08.540 --> 00:18:10.910
And then finally, I
think this kind of fun,

00:18:10.910 --> 00:18:13.210
we can actually
query the values.

00:18:13.210 --> 00:18:14.900
Again, this is a
feature that's not

00:18:14.900 --> 00:18:17.100
in-- [? it's ?] supported
with the database.

00:18:17.100 --> 00:18:19.570
But it is supported with
the associate array, which

00:18:19.570 --> 00:18:23.850
is if I say get me all-- return
an associative array were

00:18:23.850 --> 00:18:29.830
all the values are greater than
b-- I'm sorry, less than b, OK?

00:18:29.830 --> 00:18:32.760
So let me just show you
what that looks like.

00:18:32.760 --> 00:18:34.509
So this was that query.

00:18:34.509 --> 00:18:35.800
And this is what it looks like.

00:18:35.800 --> 00:18:37.950
So I do display
a-- and you see now

00:18:37.950 --> 00:18:41.810
we don't have any
values that begin

00:18:41.810 --> 00:18:45.230
with a b-- all the values, OK?

00:18:45.230 --> 00:18:47.080
Another thing that
we should notice here

00:18:47.080 --> 00:18:50.830
is that this is now a three
by three matrix, not a six

00:18:50.830 --> 00:18:52.700
by six matrix.

00:18:52.700 --> 00:18:56.900
Associative arrays
never store an empty row

00:18:56.900 --> 00:18:58.160
or an empty column.

00:18:58.160 --> 00:19:01.350
That is a big difference
between traditional sparse

00:19:01.350 --> 00:19:04.142
linear algebra and
associative arrays.

00:19:04.142 --> 00:19:05.600
In sparse linear
algebra, you could

00:19:05.600 --> 00:19:09.000
have a row of all
zero-- an empty row

00:19:09.000 --> 00:19:11.700
or an empty column, not
an associative arrays.

00:19:11.700 --> 00:19:15.567
Associative arrays,
you either have--

00:19:15.567 --> 00:19:17.650
there's going to be-- if
you have a row or column,

00:19:17.650 --> 00:19:19.200
it's going to have
an [? entry-- ?] yes.

00:19:19.200 --> 00:19:20.075
AUDIENCE: [INAUDIBLE]

00:19:26.280 --> 00:19:29.090
PROFESSOR: So
basically, all it does--

00:19:29.090 --> 00:19:33.510
so it's basically-- so if we
had a value to begin with,

00:19:33.510 --> 00:19:35.820
c, that would also
not be included.

00:19:35.820 --> 00:19:37.800
So it's basically--
lexographically, we

00:19:37.800 --> 00:19:41.070
compare the value aa with b.

00:19:41.070 --> 00:19:43.600
And we say, is it
lexographically before b?

00:19:43.600 --> 00:19:45.031
If so, it satisfies
the condition.

00:19:45.031 --> 00:19:45.906
AUDIENCE: [INAUDIBLE]

00:19:50.700 --> 00:19:51.610
PROFESSOR: Yes, yes.

00:19:51.610 --> 00:19:55.090
So that's the policy
that we [? made-- ?]

00:19:55.090 --> 00:19:57.380
so strictly, the algebra
of associate arrays

00:19:57.380 --> 00:19:59.670
doesn't require
lexographical ordering.

00:19:59.670 --> 00:20:01.580
That's an implementation fact.

00:20:01.580 --> 00:20:04.440
It's a very important
implementation fact.

00:20:04.440 --> 00:20:07.780
We are constantly maintaining
lexicographical order

00:20:07.780 --> 00:20:10.009
inside the data structure.

00:20:10.009 --> 00:20:10.550
Yeah, Darryl?

00:20:10.550 --> 00:20:11.425
AUDIENCE: [INAUDIBLE]

00:20:13.745 --> 00:20:15.620
PROFESSOR: That's right,
yeah-- three by six,

00:20:15.620 --> 00:20:17.630
sorry, three by six.

00:20:17.630 --> 00:20:21.230
Yes, yes-- because these
are full here, right?

00:20:21.230 --> 00:20:26.510
But you see that the ones--
none of the ones with b in it

00:20:26.510 --> 00:20:29.290
happened because they
didn't satisfy criteria.

00:20:29.290 --> 00:20:30.620
So therefore, they're empty.

00:20:30.620 --> 00:20:34.540
And so therefore-- so just
very important thing to know.

00:20:34.540 --> 00:20:36.445
All right, moving on
here to the next--

00:20:36.445 --> 00:20:37.320
AUDIENCE: [INAUDIBLE]

00:20:40.307 --> 00:20:42.140
PROFESSOR: You define
other [? orderings. ?]

00:20:42.140 --> 00:20:45.410
The mathematics would
no doubt admit that.

00:20:45.410 --> 00:20:48.560
It's really backed in, though,
into the implementation.

00:20:48.560 --> 00:20:52.790
I mean, because we rely on
the MATLAB sort command--

00:20:52.790 --> 00:20:55.250
and as far as I know,
that does not allow

00:20:55.250 --> 00:20:57.570
you to have other orderings.

00:20:57.570 --> 00:20:59.300
Now, you could
obviously do rehashed.

00:20:59.300 --> 00:21:02.075
You could hash your rows
and keys to some other thing

00:21:02.075 --> 00:21:05.010
and then have an associate array
that maps those back and forth.

00:21:05.010 --> 00:21:08.254
And in fact, people do that
all the time and just have--

00:21:08.254 --> 00:21:09.170
and you could do that.

00:21:09.170 --> 00:21:10.950
But that's how-- and if
you really, really want

00:21:10.950 --> 00:21:12.250
the order-- the
main thing, though,

00:21:12.250 --> 00:21:13.350
is to kind of think
of it, though,

00:21:13.350 --> 00:21:15.141
is that the ordering
doesn't really matter.

00:21:15.141 --> 00:21:17.960
It's really a device that
allows me to do fast lookups.

00:21:17.960 --> 00:21:23.380
And you shouldn't really
care about the ordering.

00:21:23.380 --> 00:21:25.660
So let's move on to
the next example.

00:21:25.660 --> 00:21:28.550
So actually-- so
we're going to do AI3.

00:21:28.550 --> 00:21:32.640
So now we're going to do
some math on this stuff, OK?

00:21:32.640 --> 00:21:35.050
So here we go.

00:21:35.050 --> 00:21:37.539
All right, so once
again, I read in my data

00:21:37.539 --> 00:21:39.205
that I constructed
in the first example.

00:21:42.570 --> 00:21:46.679
The values of that
data are strings.

00:21:46.679 --> 00:21:48.220
But if I want to do
math, sometimes I

00:21:48.220 --> 00:21:49.714
don't want to do
math on strings.

00:21:49.714 --> 00:21:51.380
Sometimes, I want to
do math on numbers.

00:21:51.380 --> 00:21:54.450
So in D4M, the associate
arrays can also

00:21:54.450 --> 00:21:58.250
be numbers, which can be
very convenient for doing

00:21:58.250 --> 00:21:59.970
mathematical operations.

00:21:59.970 --> 00:22:04.670
And so what we have here
is we have this command

00:22:04.670 --> 00:22:07.990
called dblLogi, which
is a shorthand for--

00:22:07.990 --> 00:22:11.530
and it's kind of cut
off here-- applying

00:22:11.530 --> 00:22:15.209
logical to the associate array,
which takes all the values

00:22:15.209 --> 00:22:17.000
and converts them just
to a zero or a one--

00:22:17.000 --> 00:22:18.510
basically throws
away the strings.

00:22:18.510 --> 00:22:21.150
Or if it was a numeric value,
just [INAUDIBLE] are you there?

00:22:21.150 --> 00:22:21.950
You're a one.

00:22:21.950 --> 00:22:24.680
You're not there, you're
a zero or you're empty.

00:22:24.680 --> 00:22:26.950
And then since we
can't do arithmetic

00:22:26.950 --> 00:22:30.170
on logicals in MATLAB, we have
to bump them back into doubles.

00:22:30.170 --> 00:22:32.250
So we do this so
often, we've actually

00:22:32.250 --> 00:22:35.170
made a little shorthand
here where we call dblLogi.

00:22:35.170 --> 00:22:37.670
And you'll see that all the
time in the class because I just

00:22:37.670 --> 00:22:39.711
don't like to type all
the characters [INAUDIBLE]

00:22:39.711 --> 00:22:42.770
writing double logical
gets very redundant.

00:22:42.770 --> 00:22:44.930
Now, if we go and look
at that data again,

00:22:44.930 --> 00:22:47.050
we see when you do
displayFull that

00:22:47.050 --> 00:22:49.260
instead of where
before we had values

00:22:49.260 --> 00:22:52.730
of these various strings,
we just now have numbers--

00:22:52.730 --> 00:22:53.630
just ones.

00:22:53.630 --> 00:22:54.750
So that's convenient.

00:22:54.750 --> 00:22:56.840
Now I can do arithmetic on them.

00:22:56.840 --> 00:23:00.111
So let me do the
first thing here.

00:23:00.111 --> 00:23:01.610
One of the things
I might want to do

00:23:01.610 --> 00:23:06.030
is sum all the rows-- so
the MATLAB sum command.

00:23:06.030 --> 00:23:09.150
It's basically-- you're giving
it essentially the dimension

00:23:09.150 --> 00:23:10.090
to eliminate.

00:23:10.090 --> 00:23:13.320
The first dimension we want
to eliminate or sum over

00:23:13.320 --> 00:23:14.525
is the row dimensions.

00:23:14.525 --> 00:23:17.810
So that means it's
summing up all these rows.

00:23:17.810 --> 00:23:20.614
It's basically squishing the
matrix and summing them up.

00:23:20.614 --> 00:23:22.280
And now we have a new
associative array,

00:23:22.280 --> 00:23:25.490
which is essentially a one
by six associative array.

00:23:25.490 --> 00:23:28.240
You see now that the
row key is empty.

00:23:28.240 --> 00:23:30.140
Because when we
sum, the definitions

00:23:30.140 --> 00:23:32.560
of the rows sort
of kind of go away.

00:23:32.560 --> 00:23:35.310
So we don't-- you don't have
to have strings to be your row

00:23:35.310 --> 00:23:35.810
keys.

00:23:35.810 --> 00:23:40.100
You can have numeric row keys.

00:23:40.100 --> 00:23:44.590
Just leave the row entry empty.

00:23:44.590 --> 00:23:46.880
But there are some
cautions with that as well.

00:23:46.880 --> 00:23:48.796
So when we sum that and
you see [INAUDIBLE] we

00:23:48.796 --> 00:23:50.489
have all the
columns, the values,

00:23:50.489 --> 00:23:52.030
because they're not
strings, are just

00:23:52.030 --> 00:23:56.440
stored in this a matrix itself.

00:23:56.440 --> 00:23:59.230
And you see that we had six
and two and two and two and two

00:23:59.230 --> 00:23:59.840
and two.

00:23:59.840 --> 00:24:02.530
So when we sum these up, that's
exactly what you would expect.

00:24:05.360 --> 00:24:08.480
Moving along, we
can do the columns.

00:24:08.480 --> 00:24:09.760
So here I'm going to sum.

00:24:09.760 --> 00:24:12.750
And then I'm going to do display
full, which is the same as just

00:24:12.750 --> 00:24:13.890
kind of listing it.

00:24:13.890 --> 00:24:19.425
And we see here we now sum the--
compressed all the columns.

00:24:19.425 --> 00:24:20.550
So we have a column vector.

00:24:20.550 --> 00:24:23.560
And this shows the row
labels of that column vector.

00:24:23.560 --> 00:24:26.510
We now have a new column
label, which is just one.

00:24:26.510 --> 00:24:28.800
And then you see the actual
values there-- again,

00:24:28.800 --> 00:24:30.070
a very useful thing.

00:24:30.070 --> 00:24:32.160
People do this all
the time summing

00:24:32.160 --> 00:24:35.620
of their rows and columns.

00:24:35.620 --> 00:24:37.620
Let's do a simple join.

00:24:37.620 --> 00:24:43.010
So I'm going to say give me
a column vector A. Get me

00:24:43.010 --> 00:24:45.540
another column vector b, right?

00:24:45.540 --> 00:24:48.500
And now I'm going to
join these two together.

00:24:48.500 --> 00:24:52.440
Now, I could just do aa and ab.

00:24:52.440 --> 00:24:54.720
But I'd get an empty matrix.

00:24:54.720 --> 00:24:57.270
The reason is because it
would attempt to do the joins

00:24:57.270 --> 00:24:59.470
and they would have
different column labels.

00:24:59.470 --> 00:25:02.060
And so when we do joins,
we're intersecting

00:25:02.060 --> 00:25:06.300
the two sets of row and
column keys together.

00:25:06.300 --> 00:25:08.740
And if they have sep-- those
are just separate columns.

00:25:08.740 --> 00:25:11.950
They add them together,
they have no intersection.

00:25:11.950 --> 00:25:14.440
However, if we have this
function called no call, which

00:25:14.440 --> 00:25:16.190
is actually blows
away the column

00:25:16.190 --> 00:25:19.272
and basically gives them all,
in this case a column value one,

00:25:19.272 --> 00:25:20.480
we can now add them together.

00:25:20.480 --> 00:25:22.630
And we can actually
find where these two

00:25:22.630 --> 00:25:26.390
things have a common value.

00:25:26.390 --> 00:25:28.285
So that's a fairly
simple way to do a join.

00:25:30.830 --> 00:25:34.650
This is something called a facet
search, which basically says,

00:25:34.650 --> 00:25:37.080
all right, I'm going to
join these things together.

00:25:37.080 --> 00:25:42.740
So I'm going to create
a column vector.

00:25:42.740 --> 00:25:45.680
But then I'm going to
transpose that over here.

00:25:45.680 --> 00:25:46.610
So I transpose it.

00:25:46.610 --> 00:25:48.193
And then I'm going
to multiply it back

00:25:48.193 --> 00:25:49.385
with the original matrix.

00:25:49.385 --> 00:25:52.840
This gives me a count of
essentially all-- given

00:25:52.840 --> 00:25:56.630
all columns, all
rows that contained--

00:25:56.630 --> 00:26:01.300
had an entry in column a and B,
can you now sum up their rows?

00:26:01.300 --> 00:26:04.270
And this is a fairly--
this is actually

00:26:04.270 --> 00:26:07.710
the mathematical basis of, if
you ever do in Google search

00:26:07.710 --> 00:26:11.090
it does auto-find,
it's essentially

00:26:11.090 --> 00:26:12.670
trying to do this
type of operation.

00:26:12.670 --> 00:26:15.230
It's trying to guess what the
next most popular topic would

00:26:15.230 --> 00:26:16.022
be.

00:26:16.022 --> 00:26:18.230
And this is essentially--
this mathematical operation

00:26:18.230 --> 00:26:19.370
does that kind of thing.

00:26:19.370 --> 00:26:21.745
We actually have a bunch
of applications in lab

00:26:21.745 --> 00:26:23.930
that use this quite heavily.

00:26:23.930 --> 00:26:26.851
And I can display the
transpose of that--

00:26:26.851 --> 00:26:28.100
so to make it a column vector.

00:26:28.100 --> 00:26:31.140
And as you see here, we
have a bunch of columns here

00:26:31.140 --> 00:26:32.570
and then values.

00:26:32.570 --> 00:26:35.195
And then we can actually do
things like sum and normalize.

00:26:35.195 --> 00:26:36.910
So we can divide.

00:26:36.910 --> 00:26:38.620
So I'm going to normalize them.

00:26:38.620 --> 00:26:39.700
You can display that.

00:26:39.700 --> 00:26:41.780
You see now you get the
probabilities associated

00:26:41.780 --> 00:26:43.310
with these things.

00:26:43.310 --> 00:26:45.300
Just basically, you
can just kind of

00:26:45.300 --> 00:26:48.340
go on your way doing math.

00:26:48.340 --> 00:26:50.870
This shows essentially the
correlation of the columns

00:26:50.870 --> 00:26:51.530
a and b.

00:26:51.530 --> 00:26:54.340
But why not just do all
the correlations at once?

00:26:54.340 --> 00:26:57.680
So I'll focus on here.

00:26:57.680 --> 00:26:59.190
So we have this
function square in,

00:26:59.190 --> 00:27:01.440
which is the same as a
transpose a but a little bit

00:27:01.440 --> 00:27:05.130
faster if you're just squaring
something with itself.

00:27:05.130 --> 00:27:07.680
I'm going to get the
diagonal of that.

00:27:07.680 --> 00:27:12.880
So if I use this function Adj,
which stands for adjacency,

00:27:12.880 --> 00:27:15.570
it'll just pop out that
a matrix by itself.

00:27:15.570 --> 00:27:17.130
Whenever you use
Adj, you're getting

00:27:17.130 --> 00:27:21.340
a straight sparse MATLAB matrix.

00:27:21.340 --> 00:27:23.010
And you can do any
operation on that

00:27:23.010 --> 00:27:24.550
that you want that
MATLAB supports.

00:27:24.550 --> 00:27:26.460
So it's a really-- I
highly recommend that.

00:27:26.460 --> 00:27:28.130
If you can't figure
out how to do it

00:27:28.130 --> 00:27:29.505
with associate
arrays [INAUDIBLE]

00:27:29.505 --> 00:27:31.250
just pop up that
adjacency matrix.

00:27:31.250 --> 00:27:32.160
Do whatever you want.

00:27:32.160 --> 00:27:34.790
And then you can just-- as long
as you didn't change the size,

00:27:34.790 --> 00:27:38.500
you can just stuff it right
back in at essentially no cost.

00:27:38.500 --> 00:27:41.261
So this is basically
copies that field out.

00:27:41.261 --> 00:27:42.760
And we're going to
get the diagonal.

00:27:42.760 --> 00:27:43.965
The reason we want
to get the diagonal

00:27:43.965 --> 00:27:46.810
is when we do correlations, we
always get this dense diagonal.

00:27:46.810 --> 00:27:48.250
I want to eliminate that.

00:27:48.250 --> 00:27:53.370
So I'm going to then now
take the adjacency matrix

00:27:53.370 --> 00:27:57.370
of the original correlation
matrix, subtract the diagonal.

00:27:57.370 --> 00:27:59.490
And then we have this
function [? putAdj, ?] which

00:27:59.490 --> 00:28:03.440
is kind of the inverse
of Adj, which just says

00:28:03.440 --> 00:28:05.060
I have an associative array.

00:28:05.060 --> 00:28:08.650
Replace that a with this.

00:28:08.650 --> 00:28:13.760
No checking, instantaneous
copy, very fast,

00:28:13.760 --> 00:28:15.620
but make sure it's
the right size.

00:28:15.620 --> 00:28:19.580
If it's the wrong size
or you've reoriented

00:28:19.580 --> 00:28:21.580
the columns in some way
or the rows in some way,

00:28:21.580 --> 00:28:23.070
then it won't make any sense.

00:28:23.070 --> 00:28:25.572
So it's a little bit
of an advanced feature,

00:28:25.572 --> 00:28:26.780
but it's a very powerful one.

00:28:26.780 --> 00:28:30.360
You can pop stuff in and out of
these structures very quickly.

00:28:30.360 --> 00:28:32.750
And that way, if you
ever need to do math

00:28:32.750 --> 00:28:35.800
that we don't support, you
can just do that directly.

00:28:35.800 --> 00:28:38.000
And so if we look
at that, we see

00:28:38.000 --> 00:28:41.970
what you would expect-- a
nice correlation matrix here,

00:28:41.970 --> 00:28:46.800
symmetric with no diagonal
and the counts of each one.

00:28:46.800 --> 00:28:50.300
Right here-- so let me
move on to the next example

00:28:50.300 --> 00:28:54.320
here, which is AI4.

00:28:54.320 --> 00:28:56.330
And this just shows
you different ways

00:28:56.330 --> 00:28:59.030
to construct associative
arrays, some of the various kind

00:28:59.030 --> 00:29:01.770
of more degenerate cases.

00:29:01.770 --> 00:29:05.550
So I have a bench [INAUDIBLE]
creating a string here

00:29:05.550 --> 00:29:07.760
and a bunch of numeric values.

00:29:07.760 --> 00:29:11.580
The point here is when you
construct an associative array,

00:29:11.580 --> 00:29:13.090
one, we have full
support for all

00:29:13.090 --> 00:29:15.370
these degenerate
empty conditions.

00:29:15.370 --> 00:29:17.465
You give me anything
with any kind of empty,

00:29:17.465 --> 00:29:20.020
we're going to return an
empty associative array.

00:29:20.020 --> 00:29:22.822
MATLAB has outstanding
support for empty objects.

00:29:22.822 --> 00:29:24.030
You can just keep on passing.

00:29:24.030 --> 00:29:26.040
You don't have
to-- we basically--

00:29:26.040 --> 00:29:28.090
what I'm saying is we
do a lot of checking.

00:29:28.090 --> 00:29:30.310
If the thing is
empty, short circuit,

00:29:30.310 --> 00:29:31.730
return an empty type of thing.

00:29:31.730 --> 00:29:33.770
So you're not having
to constantly check

00:29:33.770 --> 00:29:37.740
if something is empty or
not in order to proceed.

00:29:37.740 --> 00:29:38.890
So that's what we do there.

00:29:38.890 --> 00:29:41.290
That's just showing you
all these [? supported. ?]

00:29:41.290 --> 00:29:44.210
In addition, you
can do mixed types.

00:29:44.210 --> 00:29:46.240
So when you construct
an associative array,

00:29:46.240 --> 00:29:49.820
if one of the values is a
scalar-- like, for instance,

00:29:49.820 --> 00:29:50.650
you can have that.

00:29:50.650 --> 00:29:54.680
You don't-- you know normally,
as in the MATLAB sparse

00:29:54.680 --> 00:29:57.220
constructor, when you
give it a set of triples,

00:29:57.220 --> 00:29:58.760
they all have to
be the same length.

00:29:58.760 --> 00:30:01.560
Or any one of them can-- or
any of them can be scalars.

00:30:01.560 --> 00:30:05.220
So this just says, I have
a bunch of columns strings,

00:30:05.220 --> 00:30:08.630
a bunch of numeric values.

00:30:08.630 --> 00:30:10.690
Oh and by the way, they
all have the same row.

00:30:10.690 --> 00:30:15.200
So this is a very quick way
to construct a row vector.

00:30:15.200 --> 00:30:19.200
I don't have to go and
replicate this a that many times

00:30:19.200 --> 00:30:20.710
to make this work.

00:30:20.710 --> 00:30:23.710
Likewise here, I could
have a numeric value

00:30:23.710 --> 00:30:30.070
for the actual rows, a
string value for the columns.

00:30:30.070 --> 00:30:31.910
And I want everyone to
have the same value.

00:30:31.910 --> 00:30:34.470
They're all going to
have the value of a.

00:30:34.470 --> 00:30:36.680
And you can do
variations on that theme.

00:30:36.680 --> 00:30:41.380
So you do-- these are fast
ways to create row columns, row

00:30:41.380 --> 00:30:43.830
vectors, or column
vectors or values

00:30:43.830 --> 00:30:45.630
with all or constant
numeric value

00:30:45.630 --> 00:30:47.930
and other types of
things like that.

00:30:47.930 --> 00:30:50.164
And then we can just
display one of these.

00:30:50.164 --> 00:30:52.580
And you see here-- I think it
was which one we displayed--

00:30:52.580 --> 00:30:55.220
this first one, which is a row.

00:30:55.220 --> 00:30:57.507
And you can see when you
display that, it just

00:30:57.507 --> 00:30:58.590
has one value for the row.

00:30:58.590 --> 00:30:59.923
These are the different columns.

00:30:59.923 --> 00:31:01.302
These are the different values.

00:31:01.302 --> 00:31:02.760
Then again, if we
display full, you

00:31:02.760 --> 00:31:06.230
see in the tabular form
that's what you have.

00:31:06.230 --> 00:31:10.640
So that brings us to the
end of the first lecture.

00:31:10.640 --> 00:31:14.830
I'm happy to stay for questions
that people might have.

00:31:14.830 --> 00:31:18.260
Please go and check out
your LLGrid account.

00:31:18.260 --> 00:31:19.680
Copy the examples.

00:31:19.680 --> 00:31:21.807
Don't try and work
out of the-- you'll

00:31:21.807 --> 00:31:24.140
get, like, permission denied
errors and stuff like that.

00:31:24.140 --> 00:31:26.180
Copy the examples to
your home directory.

00:31:26.180 --> 00:31:27.990
Try and get your D4M working.

00:31:27.990 --> 00:31:29.870
Try and run just
this first example.

00:31:29.870 --> 00:31:32.730
Make sure it behaves the
same way that we had here.

00:31:32.730 --> 00:31:36.680
And then send
email to grid-help.

00:31:36.680 --> 00:31:38.770
And then as we get
into the next week,

00:31:38.770 --> 00:31:41.522
we'll do homeworks that are a
little bit more substantive.

00:31:41.522 --> 00:31:43.480
But this is just to make
sure the technology is

00:31:43.480 --> 00:31:45.870
working for you.

00:31:45.870 --> 00:31:49.250
And that's-- we'll
wrap it up there.

00:31:49.250 --> 00:31:50.930
Thank you.

