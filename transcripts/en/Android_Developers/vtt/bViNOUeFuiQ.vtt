WEBVTT
Kind: captions
Language: en

00:00:06.515 --> 00:00:08.140
PIERRE LECESNE: Hi, everyone.

00:00:08.140 --> 00:00:10.597
I'm Pierre, and I'm a Software
Engineer on Google Play.

00:00:10.597 --> 00:00:11.930
ANTHONY MORRIS: Hi, everyone.

00:00:11.930 --> 00:00:14.554
I'm Anthony, also a Software
Engineer on Google Play.

00:00:14.554 --> 00:00:18.749
IBRAHIM KARAHAN: And I'm
Ibo, a Partner Developer Advocate at Google.

00:00:18.749 --> 00:00:20.540
PIERRE LECESNE:
Well, some of you

00:00:20.540 --> 00:00:22.550
might just be coming
from the previous session

00:00:22.550 --> 00:00:26.450
at the amphitheater, which
gave an overview of Google Play

00:00:26.450 --> 00:00:29.330
Dynamic Delivery and its
new publishing format

00:00:29.330 --> 00:00:31.640
called the Android
App Bundle and how

00:00:31.640 --> 00:00:34.220
this will make apps smaller.

00:00:34.220 --> 00:00:36.740
In this session, we will
do a technical deep dive

00:00:36.740 --> 00:00:38.790
on this new publishing format.

00:00:38.790 --> 00:00:42.170
We will cover what it
contains, how to build it,

00:00:42.170 --> 00:00:46.105
how to publish it, but also the
different ways you can test it.

00:00:46.105 --> 00:00:49.520
We'll also cover how Google
Play generates and serves

00:00:49.520 --> 00:00:53.220
the APKs to end users.

00:00:53.220 --> 00:00:57.590
So let's start with the format
of the Android App Bundle.

00:00:57.590 --> 00:01:00.306
The Android App Bundle
is a zip archive.

00:01:00.306 --> 00:01:02.180
It contains the files
you're already familiar

00:01:02.180 --> 00:01:06.920
with in APKs, such as text files
and with resources, assets,

00:01:06.920 --> 00:01:09.710
native libraries.

00:01:09.710 --> 00:01:12.590
It's important to realize that
the app bundle and the APK

00:01:12.590 --> 00:01:16.680
are two distinct formats
with two different purposes.

00:01:16.680 --> 00:01:20.600
The app bundle is a purely
a publishing format,

00:01:20.600 --> 00:01:24.120
so it cannot be directly
installed on a device.

00:01:24.120 --> 00:01:26.270
It also contains
some metadata files

00:01:26.270 --> 00:01:28.320
that don't end up in
the final APKs, that

00:01:28.320 --> 00:01:32.480
just help the tools build
the APKs the right way.

00:01:32.480 --> 00:01:37.370
Finally, the format of the app
bundle is stricter than APK.

00:01:37.370 --> 00:01:39.140
We want to ensure that
the tools can fully

00:01:39.140 --> 00:01:42.860
understand the
files in the bundle

00:01:42.860 --> 00:01:46.140
so that they can
generate valid APKs.

00:01:46.140 --> 00:01:51.104
Now let's open up one app bundle
and look at what's inside.

00:01:51.104 --> 00:01:56.660
So if you open that bundle,
this is what you should expect.

00:01:56.660 --> 00:01:58.960
So this should look
familiar to a lot of people.

00:01:58.960 --> 00:02:00.400
Instead of
reinventing the wheel,

00:02:00.400 --> 00:02:03.610
we decided to reuse some
of the structure of APKs

00:02:03.610 --> 00:02:08.440
and only modify what we needed
to better describe the files.

00:02:08.440 --> 00:02:11.050
So we'll be free
to go through them.

00:02:11.050 --> 00:02:14.230
To start with,
the app bundle has

00:02:14.230 --> 00:02:15.760
support for having
multiple modules,

00:02:15.760 --> 00:02:17.560
as you may have heard before.

00:02:17.560 --> 00:02:21.110
And we'll tell you more
about module shortly.

00:02:21.110 --> 00:02:23.830
For now, just know that
the top-level directories

00:02:23.830 --> 00:02:26.900
in the app bundle are
the names of the modules.

00:02:26.900 --> 00:02:29.660
There is always a module
named base in the module,

00:02:29.660 --> 00:02:30.342
in the bundle.

00:02:30.342 --> 00:02:32.050
And that's the one
we're looking at here.

00:02:34.870 --> 00:02:37.070
The Android manifest
is still present.

00:02:37.070 --> 00:02:39.400
New project is a real XML file.

00:02:39.400 --> 00:02:42.430
In the APKs, you may
notice a binary format.

00:02:42.430 --> 00:02:45.860
In the app bundle, it's
compiled into a protocol buffer

00:02:45.860 --> 00:02:48.850
format, which allows us to
transform it more easily.

00:02:51.420 --> 00:02:53.850
As opposed to APK,
the dex files are

00:02:53.850 --> 00:02:56.900
under a directory named dex.

00:02:56.900 --> 00:02:58.820
The Android
resources, the assets,

00:02:58.820 --> 00:03:01.350
and the negative libraries,
on the other hand,

00:03:01.350 --> 00:03:04.350
follow the same directory
structure as in an APK.

00:03:04.350 --> 00:03:06.770
The only difference
are the XML resources,

00:03:06.770 --> 00:03:09.710
which are also compiled into
a protocol buffer format,

00:03:09.710 --> 00:03:10.930
instead of the binary format.

00:03:13.600 --> 00:03:16.900
The file resources.pb
is the resource table.

00:03:16.900 --> 00:03:19.960
It's the equivalent of
the file resources.arac

00:03:19.960 --> 00:03:22.540
that you may have
seen in your APKs.

00:03:22.540 --> 00:03:24.820
It describes the resources
present in your app

00:03:24.820 --> 00:03:26.950
and the targeting.

00:03:26.950 --> 00:03:31.240
The .pb extension-- it's in a
protocol buffer format, which,

00:03:31.240 --> 00:03:33.940
again, makes it easier for
tools to transform it before

00:03:33.940 --> 00:03:36.410
it's converted into its
binary form in the APK.

00:03:39.070 --> 00:03:41.710
The assets.pb and
native.pb files

00:03:41.710 --> 00:03:44.290
are the equivalent of the
resource table for assets

00:03:44.290 --> 00:03:45.880
and native libraries.

00:03:45.880 --> 00:03:48.940
So they only exist if you have
asset or native libraries,

00:03:48.940 --> 00:03:51.640
and they also describe
the targeting of the files

00:03:51.640 --> 00:03:55.570
in their respective directories.

00:03:55.570 --> 00:03:57.760
As I've mentioned before,
the resource table,

00:03:57.760 --> 00:04:00.390
the asset table, and the
native libraries table

00:04:00.390 --> 00:04:03.070
describe the targeting
of the files of your app.

00:04:03.070 --> 00:04:05.620
So let me explain
what I mean by that.

00:04:05.620 --> 00:04:08.440
File targeting is
the description

00:04:08.440 --> 00:04:13.120
of what type of device or user
a given file is targeted for.

00:04:13.120 --> 00:04:16.720
It's a central concept in
Google Play dynamic delivery,

00:04:16.720 --> 00:04:19.240
since understanding
the targeting of files

00:04:19.240 --> 00:04:23.330
means we can serve to a given
user only the files they need.

00:04:23.330 --> 00:04:27.070
And this is what allows
us to make apps smaller.

00:04:27.070 --> 00:04:30.750
The app bundle reuses the
targeting that exists in APKs.

00:04:30.750 --> 00:04:32.650
You're already
familiar with this,

00:04:32.650 --> 00:04:36.540
so I'll just go and
run through it quickly.

00:04:36.540 --> 00:04:38.650
For resources, you
specify, for example,

00:04:38.650 --> 00:04:41.560
HDPI in the directory
name of your resource

00:04:41.560 --> 00:04:48.920
to target HDPI devices, or you
add fr to target French users.

00:04:48.920 --> 00:04:51.500
For native libraries,
it's the same.

00:04:51.500 --> 00:04:53.700
You add the architecture
to the directory.

00:04:53.700 --> 00:04:55.480
Again, nothing new here.

00:04:55.480 --> 00:04:58.600
The app bundle
works the same way.

00:04:58.600 --> 00:05:01.420
Now we realize that
for some of you,

00:05:01.420 --> 00:05:04.290
assets represent a
big part of your app.

00:05:04.290 --> 00:05:07.670
So the app bundle also
supports assets targeting.

00:05:07.670 --> 00:05:09.970
We're starting with
language targeting,

00:05:09.970 --> 00:05:12.300
and we will soon be adding
texture compression formats

00:05:12.300 --> 00:05:14.340
and graphics API versions.

00:05:14.340 --> 00:05:17.340
So we can serve only the
relevant assets to the users

00:05:17.340 --> 00:05:19.830
and reduce further the size
of your apps and games.

00:05:22.540 --> 00:05:26.250
This is how you would create
a targeted asset directory.

00:05:26.250 --> 00:05:27.640
While making use
of the hash sign

00:05:27.640 --> 00:05:31.210
to identify an asset
directory that has targeting,

00:05:31.210 --> 00:05:33.280
then comes the key
which defines which

00:05:33.280 --> 00:05:36.190
dimensions we are
targeting-- for example,

00:05:36.190 --> 00:05:40.300
lang for the language, tcf for
texture compression formats,

00:05:40.300 --> 00:05:41.710
et cetera.

00:05:41.710 --> 00:05:43.965
And then comes the value
associated with a key.

00:05:43.965 --> 00:05:47.390
Well, let's see some examples.

00:05:47.390 --> 00:05:50.257
Here's an example of a
directory containing assets

00:05:50.257 --> 00:05:51.340
for users speaking French.

00:05:54.080 --> 00:05:56.360
This is another example
of an asset directory,

00:05:56.360 --> 00:05:59.720
targeted based on the texture
compression format here,

00:05:59.720 --> 00:06:02.660
targeting devices that
support the format etc1.

00:06:06.980 --> 00:06:09.110
Now that you know more
about the app bundle format,

00:06:09.110 --> 00:06:10.840
I'll hand it over
to Anthony, who

00:06:10.840 --> 00:06:14.260
will tell you how we use this
to serve smaller apps to users.

00:06:16.814 --> 00:06:18.230
ANTHONY MORRIS :
Thanks, Pierre.

00:06:18.230 --> 00:06:19.280
Hi, everyone.

00:06:19.280 --> 00:06:21.170
So Pierre was just
explaining to you

00:06:21.170 --> 00:06:23.030
how we're changing
the format of what

00:06:23.030 --> 00:06:24.602
you publish to the Play Store.

00:06:24.602 --> 00:06:26.060
And now I'm going
to explain to you

00:06:26.060 --> 00:06:29.420
how we're changing the format
of what we serve to users,

00:06:29.420 --> 00:06:31.490
and how we use this
to deliver only

00:06:31.490 --> 00:06:32.960
what is needed for each user.

00:06:35.470 --> 00:06:38.200
Now, we start with split APKs.

00:06:38.200 --> 00:06:40.730
So in Android Lollipop, we
added a feature to the Android

00:06:40.730 --> 00:06:43.250
platform called split APKs.

00:06:43.250 --> 00:06:47.540
Split APKs allow multiple APKs
to be installed on a device

00:06:47.540 --> 00:06:50.935
and behave as if they
were part of a single app.

00:06:50.935 --> 00:06:52.610
These split APKs
can be installed

00:06:52.610 --> 00:06:55.490
in different combinations
on different devices,

00:06:55.490 --> 00:07:01.500
and they can be installed in one
go up front or piece by piece.

00:07:01.500 --> 00:07:05.220
Now, a split APK has the
same format as a normal APK.

00:07:05.220 --> 00:07:09.600
They can contain Java code index
files, native code, resources,

00:07:09.600 --> 00:07:11.250
and assets directories.

00:07:11.250 --> 00:07:13.320
And once split
APKs are installed,

00:07:13.320 --> 00:07:18.240
these can all be accessed as
if they were in a single APK.

00:07:18.240 --> 00:07:20.130
And furthermore,
each application

00:07:20.130 --> 00:07:21.960
has the same package
name and version

00:07:21.960 --> 00:07:23.580
code with all the
other ones that

00:07:23.580 --> 00:07:25.500
are installed on the
device, and that must all

00:07:25.500 --> 00:07:28.210
be signed with the same key.

00:07:28.210 --> 00:07:30.710
So now, let's take a look at
how we can take the Android App

00:07:30.710 --> 00:07:36.680
Bundle and generate split APKs
that we then serve to devices.

00:07:36.680 --> 00:07:39.350
So we start by looking
in the app bundle

00:07:39.350 --> 00:07:42.020
and finding everything that
is common to all the devices

00:07:42.020 --> 00:07:44.120
and putting them in a base APK.

00:07:44.120 --> 00:07:46.730
So this would include
the Android manifest file

00:07:46.730 --> 00:07:50.400
and the dex files, for instance.

00:07:50.400 --> 00:07:52.330
Then we generate a
different split APK

00:07:52.330 --> 00:07:54.510
for each screen density.

00:07:54.510 --> 00:07:56.420
Each split will contain
all the durables

00:07:56.420 --> 00:07:59.210
that would have been selected
by the Android framework

00:07:59.210 --> 00:08:00.610
on a device with that density.

00:08:04.310 --> 00:08:07.000
We can also generate
a different split APK

00:08:07.000 --> 00:08:10.490
for each native architecture
containing native libraries

00:08:10.490 --> 00:08:13.390
of that architecture.

00:08:13.390 --> 00:08:15.240
And we can generate
a different split

00:08:15.240 --> 00:08:17.370
for each language
supported by your app,

00:08:17.370 --> 00:08:20.830
putting each language's
strings in a different APK.

00:08:20.830 --> 00:08:23.340
Now, together, we call
these splits configurations

00:08:23.340 --> 00:08:24.820
splits or config splits.

00:08:27.480 --> 00:08:30.320
Now, when we go to serve
an app to a device,

00:08:30.320 --> 00:08:32.780
we only need to serve a
subset of these splits,

00:08:32.780 --> 00:08:35.870
instead of serving
everything to every device.

00:08:35.870 --> 00:08:38.840
So say I have a
Samsung Galaxy J5.

00:08:38.840 --> 00:08:43.080
We will install the base APK,
as well as the xhdpi density

00:08:43.080 --> 00:08:46.400
split, the ARM architecture
split, and the English language

00:08:46.400 --> 00:08:49.860
split, because I
only speak English.

00:08:49.860 --> 00:08:52.010
But it can get a bit
trickier than that.

00:08:52.010 --> 00:08:54.210
Pierre speaks both
French and English,

00:08:54.210 --> 00:08:56.880
and he specifies both of
those languages in his device

00:08:56.880 --> 00:08:58.040
settings.

00:08:58.040 --> 00:09:01.020
So in his device, a Pixel
2 XL, in addition to

00:09:01.020 --> 00:09:02.505
the right density
and architecture

00:09:02.505 --> 00:09:06.322
splits, we will serve both the
French and the English language

00:09:06.322 --> 00:09:07.155
split to his device.

00:09:10.230 --> 00:09:12.770
Now, suppose Pierre then
moves to Brazil and learns

00:09:12.770 --> 00:09:14.120
Portuguese.

00:09:14.120 --> 00:09:17.710
He might then add Portuguese
as a language on his device.

00:09:17.710 --> 00:09:19.890
Now, when he does
this, the Play Store

00:09:19.890 --> 00:09:23.210
recognizes this and will attempt
to download the Portuguese

00:09:23.210 --> 00:09:27.440
language split for all apps
that use splits on the device.

00:09:27.440 --> 00:09:29.590
And if the device is
not online at the time,

00:09:29.590 --> 00:09:31.090
then we will download
those language

00:09:31.090 --> 00:09:34.020
splits at the next opportunity.

00:09:34.020 --> 00:09:37.330
And so that's how
config splits work.

00:09:37.330 --> 00:09:38.955
But as I mentioned
at the start, splits

00:09:38.955 --> 00:09:41.390
are only supported on
Lollipop and above.

00:09:41.390 --> 00:09:45.230
This covers about 85% of users
at the moment, but most of you

00:09:45.230 --> 00:09:48.620
still target pre L
devices, which is great.

00:09:48.620 --> 00:09:50.320
And for these devices,
the app bundle

00:09:50.320 --> 00:09:53.860
still allows us to achieve
some of the size savings

00:09:53.860 --> 00:09:57.670
by generating standalone APKs
containing specific densities

00:09:57.670 --> 00:09:59.200
and architectures.

00:09:59.200 --> 00:10:02.680
So instead of generating splits,
as we would do for L plus,

00:10:02.680 --> 00:10:05.040
we would generate this
matrix of standalone APKs.

00:10:07.800 --> 00:10:10.620
We briefly considered
extending this to language

00:10:10.620 --> 00:10:12.670
splits as well, but we
did some of the sums,

00:10:12.670 --> 00:10:15.120
and it got a little
bit out of hand.

00:10:15.120 --> 00:10:17.270
But now, for Pre
L devices, we have

00:10:17.270 --> 00:10:20.265
to include all the languages
in each of the standalone APKs.

00:10:22.890 --> 00:10:25.140
Now when we go to
serve the app, we

00:10:25.140 --> 00:10:28.490
choose the best single
APK for your device.

00:10:28.490 --> 00:10:31.620
So if we have my first Android
device-- a Galaxy Nexus--

00:10:31.620 --> 00:10:35.659
we would serve the hdpi
arm standalone APK.

00:10:35.659 --> 00:10:37.200
You might recognize
this because this

00:10:37.200 --> 00:10:38.699
is similar to what
you may have done

00:10:38.699 --> 00:10:39.960
in the past with multi APK.

00:10:42.490 --> 00:10:43.996
But let's put this all together.

00:10:43.996 --> 00:10:46.387
The picture looks like
this, and you actually

00:10:46.387 --> 00:10:48.720
don't actually need to worry
about the details about how

00:10:48.720 --> 00:10:50.980
all these split
APKs are generated

00:10:50.980 --> 00:10:53.620
or standalone APKs
are generated.

00:10:53.620 --> 00:10:56.620
All you have to do is
upload a single app bundle,

00:10:56.620 --> 00:10:59.470
and then Play generates the
right splits and selects

00:10:59.470 --> 00:11:01.410
the right ones to
serve for each device.

00:11:05.300 --> 00:11:07.280
And the dimensions
we've discussed so far

00:11:07.280 --> 00:11:08.980
are only the beginning.

00:11:08.980 --> 00:11:12.170
Pierre discussed how the app
bundle lets you target assets

00:11:12.170 --> 00:11:15.410
by graphics API, and we will
soon generate config splits

00:11:15.410 --> 00:11:16.540
based on that.

00:11:16.540 --> 00:11:18.810
We'll also start
generating config

00:11:18.810 --> 00:11:21.900
splits to take advantage
of new platform features.

00:11:21.900 --> 00:11:24.850
And we'll start with supporting
uncompressed native libraries

00:11:24.850 --> 00:11:25.895
on m-class devices.

00:11:29.150 --> 00:11:31.010
Now I'll ask Ibo
to come up to take

00:11:31.010 --> 00:11:34.936
a look at how much we can reduce
app size by using this app

00:11:34.936 --> 00:11:36.007
bundle.

00:11:36.007 --> 00:11:37.507
IBRAHIM KARAHAN:
Thank you, Anthony.

00:11:40.130 --> 00:11:44.760
Now that we know how Play serves
split APKs to your devices,

00:11:44.760 --> 00:11:48.870
we're going to talk about the
size savings with app bundles.

00:11:48.870 --> 00:11:52.920
We found out that, on average,
apps published with app bundles

00:11:52.920 --> 00:11:59.790
are 20% smaller, and that
is 20% savings every time

00:11:59.790 --> 00:12:03.330
your application is
downloaded or upgraded.

00:12:03.330 --> 00:12:06.780
Now let's look at how
we reached this number.

00:12:06.780 --> 00:12:09.310
We analyzed all the
applications in Play Store

00:12:09.310 --> 00:12:12.580
with more than one
million downloads.

00:12:12.580 --> 00:12:15.270
And we found out
that for strings, we

00:12:15.270 --> 00:12:21.480
can save over 95% of their size
by using the language splits.

00:12:21.480 --> 00:12:23.750
For images, this is 45%.

00:12:23.750 --> 00:12:29.190
And for native libraries, we
can save 20% of their sizes.

00:12:29.190 --> 00:12:34.140
This means if every app
were to move to app bundles,

00:12:34.140 --> 00:12:38.610
we would save approximately
10 petabytes of data per day

00:12:38.610 --> 00:12:41.460
from app downloads and updates.

00:12:41.460 --> 00:12:45.840
That is 10 million gigabytes,
or 300 million music videos

00:12:45.840 --> 00:12:47.790
on YouTube.

00:12:47.790 --> 00:12:52.590
And on top of that, users
could see an extra 300 megabyte

00:12:52.590 --> 00:12:57.690
of disk space for more photos,
more apps, or more music

00:12:57.690 --> 00:12:59.960
on their devices.

00:12:59.960 --> 00:13:02.910
So now let's look at
actual size savings

00:13:02.910 --> 00:13:06.510
that are some of our early
access program and partners.

00:13:06.510 --> 00:13:10.560
So we're going to
start with Twitter.

00:13:10.560 --> 00:13:13.440
Twitter-- we're already
publishing with multi APKs

00:13:13.440 --> 00:13:16.410
before with architecture splits.

00:13:16.410 --> 00:13:19.020
However, their
application is translated

00:13:19.020 --> 00:13:22.740
into a lot of languages, and
it supports multiple screen

00:13:22.740 --> 00:13:24.670
densities.

00:13:24.670 --> 00:13:27.770
They still get lots of
savings with publishing

00:13:27.770 --> 00:13:32.190
with app bundles, which is
20% increase in the size.

00:13:32.190 --> 00:13:36.360
Plus, they don't have to
serve with multi APKs anymore.

00:13:36.360 --> 00:13:41.120
The next one is TextPlus, which
wasn't using multi APKs before.

00:13:41.120 --> 00:13:43.590
With app bundles--

00:13:43.590 --> 00:13:51.370
26% size savings across all
dimensions with app bundles.

00:13:51.370 --> 00:13:54.810
Jaumo's app is half
of its original size,

00:13:54.810 --> 00:13:58.020
and this is because they have
a large [INAUDIBLE] library.

00:13:58.020 --> 00:14:03.670
And they supported multiple
architectures in a single APK.

00:14:03.670 --> 00:14:06.430
Now let's look at how we
can build an app bundle,

00:14:06.430 --> 00:14:09.910
and you can start saving now.

00:14:09.910 --> 00:14:12.690
The latest Android
Studio 3.2 Canary

00:14:12.690 --> 00:14:16.600
has full support for
Android app bundles.

00:14:16.600 --> 00:14:18.820
Now we're going to see
a new option to build

00:14:18.820 --> 00:14:21.400
a bundle in the Build menu.

00:14:21.400 --> 00:14:25.390
[INAUDIBLE] everything assigned
app bundle is easy as well.

00:14:25.390 --> 00:14:29.530
We're going to just select your
app module, product flavor,

00:14:29.530 --> 00:14:31.470
and build type,
and Android Studio

00:14:31.470 --> 00:14:35.350
is going to create an app
bundle for you'll, sign,

00:14:35.350 --> 00:14:37.081
which is ready for publishing.

00:14:39.850 --> 00:14:42.100
For those who
prefer command line

00:14:42.100 --> 00:14:45.620
or wish to integrate with
automated build systems,

00:14:45.620 --> 00:14:50.800
the new Gradle Android plugin
provides a new set of tasks

00:14:50.800 --> 00:14:52.626
to build Android app bundles.

00:14:52.626 --> 00:14:56.110
Just remember, this is what
you use-- the assemble task

00:14:56.110 --> 00:14:59.290
on the command line
to create the APK.

00:14:59.290 --> 00:15:01.200
Now for app bundles,
you're going

00:15:01.200 --> 00:15:04.300
to switch to the bundle command.

00:15:04.300 --> 00:15:07.160
Similar to the assemble
tasks, bundle tasks

00:15:07.160 --> 00:15:09.280
also allow you to
build a specific flavor

00:15:09.280 --> 00:15:11.360
of your application.

00:15:11.360 --> 00:15:14.980
Once the bundle
task finishes, it's

00:15:14.980 --> 00:15:17.800
going to create an app
bundle in the output folder,

00:15:17.800 --> 00:15:20.630
with the flavor and
the build type chosen.

00:15:20.630 --> 00:15:26.380
The built architect
is called bundle.iad.

00:15:26.380 --> 00:15:29.410
Bundle tasks are compatible
with the signing configs

00:15:29.410 --> 00:15:32.100
in your build.gradle files.

00:15:32.100 --> 00:15:34.330
And with a single
gradle task, you

00:15:34.330 --> 00:15:37.150
can produce app
bundles that are signed

00:15:37.150 --> 00:15:41.140
and ready for publishing.

00:15:41.140 --> 00:15:45.520
And also, with app bundles,
Play will automatically

00:15:45.520 --> 00:15:49.390
split your application into
architecture, screen density,

00:15:49.390 --> 00:15:52.320
and language splits
by default. You

00:15:52.320 --> 00:15:55.480
don't need to do
any configurations.

00:15:55.480 --> 00:15:57.790
However, we also
want our developers

00:15:57.790 --> 00:16:00.390
to have full control
over their splits.

00:16:00.390 --> 00:16:04.180
So if for any reason you would
like to disable splitting

00:16:04.180 --> 00:16:08.185
by any dimension, you can do so
by using the newly introduced

00:16:08.185 --> 00:16:10.520
bundle block here.

00:16:10.520 --> 00:16:13.240
Now Pierre's going to talk
about how to publish your app

00:16:13.240 --> 00:16:14.410
bundle in the Play Console.

00:16:17.660 --> 00:16:19.250
PIERRE LECESNE: Thanks, Ibo.

00:16:19.250 --> 00:16:21.990
All right, so you have
built an app bundle.

00:16:21.990 --> 00:16:23.810
Now let's look at how
you can publish it

00:16:23.810 --> 00:16:26.780
on Google Play Console.

00:16:26.780 --> 00:16:30.200
First, you must enroll in
App Signing by Google Play.

00:16:30.200 --> 00:16:32.210
For those who remember,
we launched this program

00:16:32.210 --> 00:16:34.340
at Google I/O last year.

00:16:34.340 --> 00:16:37.520
When enrolling, you securely
transfer your release key

00:16:37.520 --> 00:16:40.280
to Google Play.

00:16:40.280 --> 00:16:42.470
Play then uses this
release key to sign

00:16:42.470 --> 00:16:44.630
the generated APKs
on your behalf

00:16:44.630 --> 00:16:48.370
before sending them to users.

00:16:48.370 --> 00:16:51.100
But note that if you
keep uploading APKs

00:16:51.100 --> 00:16:52.880
on your production
tap track, when

00:16:52.880 --> 00:16:55.870
you test the app bundle
in the test track,

00:16:55.870 --> 00:16:58.710
Play will not resign
the uploaded APKs.

00:16:58.710 --> 00:17:00.760
And we did this so
you can feel confident

00:17:00.760 --> 00:17:03.190
trying the app bundle on
a small audience first,

00:17:03.190 --> 00:17:05.245
without affecting your
current production users.

00:17:08.490 --> 00:17:10.800
Once you're enrolled, you
can manage your releases,

00:17:10.800 --> 00:17:12.730
just like you did for APKs.

00:17:12.730 --> 00:17:14.187
Create a new release--

00:17:14.187 --> 00:17:16.770
drop the app bundles in the same
location, where you currently

00:17:16.770 --> 00:17:21.079
drop APKs and wait
for the upload.

00:17:21.079 --> 00:17:24.720
Once uploaded, you can review
your release and release out.

00:17:24.720 --> 00:17:25.730
That's it.

00:17:25.730 --> 00:17:27.940
And I can't stress this enough--

00:17:27.940 --> 00:17:31.860
No more multi APKs to deal with.

00:17:31.860 --> 00:17:34.170
Play Console has created,
in the background,

00:17:34.170 --> 00:17:37.060
all the APKs for the
supported devices for you.

00:17:39.870 --> 00:17:42.120
Now you have uploaded
your app bundle,

00:17:42.120 --> 00:17:44.400
and Play has done all the
heavy lifting for you--

00:17:44.400 --> 00:17:45.390
great.

00:17:45.390 --> 00:17:48.150
But wouldn't it be nice to
be able to have an overview

00:17:48.150 --> 00:17:50.430
of what Play has generated?

00:17:50.430 --> 00:17:52.770
Well, we have built a
new tool in Play Console

00:17:52.770 --> 00:17:55.190
called Bundle Explorer.

00:17:55.190 --> 00:17:58.680
Bundle Explorer lets you
navigate your uploaded bundles.

00:17:58.680 --> 00:18:01.660
Let's have a look.

00:18:01.660 --> 00:18:05.050
On the first screen, you can
see at the top right corner

00:18:05.050 --> 00:18:08.230
the size savings you gain
by publishing a bundle.

00:18:08.230 --> 00:18:11.290
Here we saved over a
quarter of your app.

00:18:11.290 --> 00:18:13.660
Of course, this is
different by device.

00:18:13.660 --> 00:18:18.370
So we calculated this using a
popular device configuration.

00:18:18.370 --> 00:18:21.360
You will also find below the
list of device configurations

00:18:21.360 --> 00:18:25.060
and the total size of the
APK service to those devices.

00:18:25.060 --> 00:18:27.100
Can even click on a few
devices and see which

00:18:27.100 --> 00:18:31.000
devices are in each bucket.

00:18:31.000 --> 00:18:34.480
You can even search for any
supported device by name

00:18:34.480 --> 00:18:36.820
to download the set of
generated APKs that is

00:18:36.820 --> 00:18:39.320
served to that specific device.

00:18:39.320 --> 00:18:40.870
This will be super
helpful when you

00:18:40.870 --> 00:18:44.210
get that bug report on
that specific device,

00:18:44.210 --> 00:18:47.040
and you want to get exactly
what the user has gotten

00:18:47.040 --> 00:18:49.840
and what APKs were served.

00:18:49.840 --> 00:18:52.390
So you just search for
the name, click Download,

00:18:52.390 --> 00:18:54.790
and you'll get the set of
APKs that Play has served.

00:18:58.010 --> 00:18:59.990
Of course, we haven't
forgotten all of you

00:18:59.990 --> 00:19:02.060
who use our publishing API.

00:19:02.060 --> 00:19:06.200
Uploading app bundles is also
available using our API today.

00:19:06.200 --> 00:19:07.930
You will find all
the documentation

00:19:07.930 --> 00:19:12.620
at developers.google.com/android
publisher.

00:19:12.620 --> 00:19:15.810
And now, hand it
over to Anthony.

00:19:15.810 --> 00:19:18.890
ANTHONY MORRIS:
Thanks, Pierre.

00:19:18.890 --> 00:19:21.350
So we've now learned
how to build and publish

00:19:21.350 --> 00:19:22.820
an Android app bundle.

00:19:22.820 --> 00:19:24.410
But before we
finalize a release,

00:19:24.410 --> 00:19:27.110
we'd still like to
do a round of tests.

00:19:27.110 --> 00:19:29.780
However, we've seen that
the app bundle on its own

00:19:29.780 --> 00:19:31.430
is not installable.

00:19:31.430 --> 00:19:33.740
So how do you test it?

00:19:33.740 --> 00:19:36.890
First, we know that
during development, you

00:19:36.890 --> 00:19:39.740
can install APKs
built from the app

00:19:39.740 --> 00:19:41.600
directly from Android Studio.

00:19:41.600 --> 00:19:44.040
So you don't need
to do anything here.

00:19:44.040 --> 00:19:46.880
However, for QA teams, we
know that they don't always

00:19:46.880 --> 00:19:49.970
have access to the source
code in Android Studio.

00:19:49.970 --> 00:19:52.870
So let me talk you through the
story of three developers--

00:19:52.870 --> 00:19:54.590
Alice, Bob, and Clare--

00:19:54.590 --> 00:19:57.130
and how they choose to test
their app bundle with their QA

00:19:57.130 --> 00:20:00.050
items.

00:20:00.050 --> 00:20:01.900
So let's start with Alice.

00:20:01.900 --> 00:20:04.510
Alice uses the newly
released internal test

00:20:04.510 --> 00:20:07.930
track from the Play Console.

00:20:07.930 --> 00:20:10.870
The internal track is
similar to alpha beta tracks,

00:20:10.870 --> 00:20:13.000
that you may already
be familiar with.

00:20:13.000 --> 00:20:15.640
But it differs in that
there is almost no delay

00:20:15.640 --> 00:20:19.330
between the upload of
the bundle and the update

00:20:19.330 --> 00:20:21.790
being available on
the tester's device--

00:20:21.790 --> 00:20:25.900
really quick turnaround
for your QA testing.

00:20:25.900 --> 00:20:27.730
Going through the
Play Console, Alice

00:20:27.730 --> 00:20:30.250
has the confidence that what
the QA team will receive

00:20:30.250 --> 00:20:33.280
on their device is byte
to byte equal with what

00:20:33.280 --> 00:20:38.380
end users will get when you
push your release to production.

00:20:38.380 --> 00:20:40.270
And let's see how
Alice sets this up--

00:20:40.270 --> 00:20:41.280
really simple.

00:20:41.280 --> 00:20:44.980
So Alice creates a list of
emails of up to 100 QA testers

00:20:44.980 --> 00:20:47.280
that are eligible for
the internal test track.

00:20:47.280 --> 00:20:49.960
Her QA testers follow
the update link

00:20:49.960 --> 00:20:53.580
and then now receive the
bundles that are uploaded

00:20:53.580 --> 00:20:55.170
to the internal test track.

00:20:55.170 --> 00:20:57.810
That's it.

00:20:57.810 --> 00:21:00.480
But we know that not all of you
have access to the Play Console

00:21:00.480 --> 00:21:02.280
during your QA cycles.

00:21:02.280 --> 00:21:06.145
So let's hear from
Pierre about Bob's story.

00:21:06.145 --> 00:21:08.520
PIERRE LECESNE:
Indeed, Bob doesn't have access

00:21:08.520 --> 00:21:09.960
to the Play Console.

00:21:09.960 --> 00:21:13.170
He prefers also to test
things locally on his machine

00:21:13.170 --> 00:21:15.630
before uploading
anything, but he still

00:21:15.630 --> 00:21:18.030
wants to test what
the users will get.

00:21:18.030 --> 00:21:19.750
So how does he do that?

00:21:19.750 --> 00:21:22.440
Well, to generate
APKs from the bundle,

00:21:22.440 --> 00:21:25.410
Play uses a new tool
called Bundletool.

00:21:25.410 --> 00:21:28.170
So for Bob to reproduce
locally the builds,

00:21:28.170 --> 00:21:31.440
he can simply download
Bundletool and write

00:21:31.440 --> 00:21:34.180
a few simple commands.

00:21:34.180 --> 00:21:37.340
Bundletool has a command
called Build APKs, which

00:21:37.340 --> 00:21:39.380
takes an Android app
bundle and creates

00:21:39.380 --> 00:21:41.950
what we call an APK set archive.

00:21:41.950 --> 00:21:44.870
An APK set contains
a collection of APKs

00:21:44.870 --> 00:21:47.790
ready to be
installed on devices.

00:21:47.790 --> 00:21:50.300
Another command
called install APKs

00:21:50.300 --> 00:21:53.900
takes that APK set
archive, extracts the APKs,

00:21:53.900 --> 00:21:56.730
and install them on that device.

00:21:56.730 --> 00:22:00.780
Let's see some real
command line work.

00:22:00.780 --> 00:22:02.660
So here's the command
[? recent ?] by Bob

00:22:02.660 --> 00:22:05.690
calling build-apks,
passing the app bundle,

00:22:05.690 --> 00:22:09.770
and saying where he wants
the APK set to be created.

00:22:09.770 --> 00:22:12.480
And by passing the
flag-connected device,

00:22:12.480 --> 00:22:15.170
Bundletool will build APKs
just for the device currently

00:22:15.170 --> 00:22:18.710
connected to his machine.

00:22:18.710 --> 00:22:20.250
And if Bob wants
to generate APKs,

00:22:20.250 --> 00:22:23.450
say, for someone else on
his team without having

00:22:23.450 --> 00:22:25.790
the physical device
at hand, it can still

00:22:25.790 --> 00:22:28.520
provide a file that
contains the specifications

00:22:28.520 --> 00:22:31.050
of the device in a JSON format.

00:22:31.050 --> 00:22:33.920
And you can see here an
extract of such file, which

00:22:33.920 --> 00:22:37.400
provides the information about
the APIs this device supports,

00:22:37.400 --> 00:22:41.200
supported languages, the screen
density, and the APK version.

00:22:44.240 --> 00:22:47.880
Bundletool has also come in to
generate such device spec file.

00:22:47.880 --> 00:22:52.160
So you don't have to find
the device spec online,

00:22:52.160 --> 00:22:53.787
or you don't have to
write it yourself.

00:22:53.787 --> 00:22:55.370
You just run this
command, and it will

00:22:55.370 --> 00:22:58.650
generate this file for you.

00:22:58.650 --> 00:23:00.840
Also, because Bob wants
to install these APKs

00:23:00.840 --> 00:23:04.440
on the device, the APKs need to
be signed with a private key.

00:23:04.440 --> 00:23:06.840
So he passes the
path to the keystore.

00:23:06.840 --> 00:23:09.390
All the APKs contained
in the APK set

00:23:09.390 --> 00:23:14.860
will then be signed and directly
installable on Bob's device.

00:23:14.860 --> 00:23:17.860
And here's the invocation of
the install APKs command, which

00:23:17.860 --> 00:23:20.080
extracts the APKs
from the APK set

00:23:20.080 --> 00:23:22.960
and installs them directly
on the connected device--

00:23:22.960 --> 00:23:25.640
easy.

00:23:25.640 --> 00:23:28.000
So that was Bob and
his local testing.

00:23:28.000 --> 00:23:30.040
Now Ibo will tell
you Claire's story.

00:23:33.345 --> 00:23:34.720
IBRAHIM KARAHAN:
Claire's working

00:23:34.720 --> 00:23:37.060
for a medium-sized
company, and they

00:23:37.060 --> 00:23:41.300
set up a continuous integration
tool to fill their application.

00:23:41.300 --> 00:23:44.170
Every day, the QA
team pulls a nightly

00:23:44.170 --> 00:23:47.770
build of the application,
installs in multiple devices,

00:23:47.770 --> 00:23:52.300
and tests if the application
is working correctly.

00:23:52.300 --> 00:23:55.150
Claire wants to
help the QA team,

00:23:55.150 --> 00:23:56.935
and she uses the
Bundletool again

00:23:56.935 --> 00:24:01.470
to generate the
APK set in the CI.

00:24:01.470 --> 00:24:04.050
She uses a command that's
very similar to what

00:24:04.050 --> 00:24:05.970
Bob used earlier.

00:24:05.970 --> 00:24:09.390
But this time, she omits
the device spec flag,

00:24:09.390 --> 00:24:12.180
and she generates an
APK set, which contains

00:24:12.180 --> 00:24:14.665
APKs for all possible devices.

00:24:17.560 --> 00:24:22.420
Now the QA team will just
grab APK set from the CI.

00:24:22.420 --> 00:24:24.190
They're going to
connect the device

00:24:24.190 --> 00:24:27.480
and run the
install-apks command.

00:24:27.480 --> 00:24:30.580
Bundletool then will read
the device configuration

00:24:30.580 --> 00:24:33.310
from the attached
device, will extract

00:24:33.310 --> 00:24:37.420
APKs that matches this
configuration from the APK set,

00:24:37.420 --> 00:24:40.300
and then install
them onto the device.

00:24:40.300 --> 00:24:42.100
This is the same
selection that Play

00:24:42.100 --> 00:24:45.880
does when serving APKs
for a given device.

00:24:48.700 --> 00:24:51.280
One more thing that
Bundletool can do

00:24:51.280 --> 00:24:56.002
is to generate a universal APK
by passing the universal flag.

00:24:56.002 --> 00:25:01.440
The universal APK is a single
APK that contains the file--

00:25:01.440 --> 00:25:05.080
all the files for
all the devices.

00:25:05.080 --> 00:25:09.280
Because of that, it can be
installed in any device.

00:25:09.280 --> 00:25:12.820
Well, it really
doesn't represent

00:25:12.820 --> 00:25:15.250
what your users
will receive when

00:25:15.250 --> 00:25:18.430
they install the
application from Play Store.

00:25:18.430 --> 00:25:23.100
However, this is a convenient
way to pass an APK to a user

00:25:23.100 --> 00:25:27.540
when you don't know what
device they are running.

00:25:27.540 --> 00:25:32.890
Bundletool is also the tool used
to build an Android App Bundle,

00:25:32.890 --> 00:25:36.190
and Gradle uses it
behind the scenes.

00:25:36.190 --> 00:25:38.100
We're going to
work with the other

00:25:38.100 --> 00:25:41.350
build chains, toolchains,
to integrate build tool

00:25:41.350 --> 00:25:44.940
so that you can build an
Android App Bundle, regardless

00:25:44.940 --> 00:25:48.460
of any toolchain
you may be using.

00:25:48.460 --> 00:25:51.520
And finally, we want to
be transparent about how

00:25:51.520 --> 00:25:53.440
we generate the
APKs we delivered

00:25:53.440 --> 00:25:58.270
to your users, which is why we
are open sourcing Bundletool.

00:25:58.270 --> 00:26:02.683
You can go today to get
github.com/google/bundletool

00:26:02.683 --> 00:26:06.280
to download an executable
or [? builded ?] it from

00:26:06.280 --> 00:26:08.630
the source.

00:26:08.630 --> 00:26:11.650
Now Pierre is going to
talk about another way

00:26:11.650 --> 00:26:15.517
to make your applications
even smaller.

00:26:15.517 --> 00:26:17.100
PIERRE LECESNE: Thanks, Ibo.

00:26:17.100 --> 00:26:18.870
With Google Play
Dynamic Delivery,

00:26:18.870 --> 00:26:21.120
we're also introducing
a new way to break up

00:26:21.120 --> 00:26:24.390
your app into separate
features and deliver only those

00:26:24.390 --> 00:26:27.700
that are needed for each user.

00:26:27.700 --> 00:26:30.100
Suppose you have a
recipe app, and you

00:26:30.100 --> 00:26:32.860
want to keep the
initial download small.

00:26:32.860 --> 00:26:35.500
You observe that while
all your users like

00:26:35.500 --> 00:26:39.100
to browse for recipes, only
a small fraction choose

00:26:39.100 --> 00:26:41.620
to actually add a new recipe.

00:26:41.620 --> 00:26:44.590
And you notice that this
functionality takes up

00:26:44.590 --> 00:26:46.990
significant space in your app.

00:26:46.990 --> 00:26:50.410
What you can do is break that
feature out into its own module

00:26:50.410 --> 00:26:53.630
and serve it only when needed.

00:26:53.630 --> 00:26:56.660
We can see how it
looks for user here.

00:26:56.660 --> 00:26:59.645
Let's open the app.

00:26:59.645 --> 00:27:01.730
And so when the user
wants to add the recipe,

00:27:01.730 --> 00:27:03.970
he clicks on the little
plus at the bottom.

00:27:03.970 --> 00:27:07.250
And you can see that
in the background,

00:27:07.250 --> 00:27:10.710
the module is downloaded
and installed.

00:27:10.710 --> 00:27:14.610
And just after a few seconds,
the module is ready to be used.

00:27:17.630 --> 00:27:19.690
So which parts of
your app should you

00:27:19.690 --> 00:27:21.970
break out as separate features?

00:27:21.970 --> 00:27:25.450
If only a small fraction of
your users use that feature,

00:27:25.450 --> 00:27:27.940
that could be a good
candidate, especially

00:27:27.940 --> 00:27:31.120
if that feature takes up
significant space in your app.

00:27:31.120 --> 00:27:34.189
Finally, consider if your
users can wait a few seconds

00:27:34.189 --> 00:27:35.230
before using the feature.

00:27:39.690 --> 00:27:41.780
Once you've decided
which feature to create,

00:27:41.780 --> 00:27:44.370
this is how it should look
like in the app bundle.

00:27:44.370 --> 00:27:46.186
In addition to the
base directory,

00:27:46.186 --> 00:27:47.810
there are now also
separate directories

00:27:47.810 --> 00:27:50.060
for each of the
modules of the app.

00:27:50.060 --> 00:27:52.490
The format of these
directories is exactly

00:27:52.490 --> 00:27:55.430
the same as the format of the
base that I covered earlier.

00:27:57.990 --> 00:28:00.950
And this is the APKs that
Play would generate from it.

00:28:00.950 --> 00:28:04.050
For each module, we will
produce a set of splits

00:28:04.050 --> 00:28:06.175
consisting of a feature
split and config

00:28:06.175 --> 00:28:07.210
splits for that module.

00:28:11.220 --> 00:28:14.640
Anthony mentioned earlier that's
split APKS were only introduced

00:28:14.640 --> 00:28:18.260
with Android Lollipop
to support 3L devices,

00:28:18.260 --> 00:28:20.490
you can mark modules
to be refused,

00:28:20.490 --> 00:28:23.900
and Bundletool will generate a
single APK with the specified

00:28:23.900 --> 00:28:25.540
modules merged together.

00:28:30.130 --> 00:28:32.710
Now that we have covered
how dynamic features work,

00:28:32.710 --> 00:28:34.630
let me hand you over to
Ibo, who will show you

00:28:34.630 --> 00:28:37.288
how to create them.

00:28:37.288 --> 00:28:40.105
IBRAHIM KARAHAN: Thanks, Pierre.

00:28:40.105 --> 00:28:42.850
To create a dynamic
module, all you need to do

00:28:42.850 --> 00:28:46.240
is download Android
Studio 3.2 Canary

00:28:46.240 --> 00:28:49.660
and use the dynamic
feature wizard included.

00:28:49.660 --> 00:28:52.880
Click on the New
Module in File menu,

00:28:52.880 --> 00:28:54.420
choose the dynamic module.

00:28:54.420 --> 00:28:57.340
And so typing in your module's
name, Android Studio is going

00:28:57.340 --> 00:29:01.280
is going to create a new
dynamic module for you.

00:29:01.280 --> 00:29:04.300
You can also do the
same thing manually

00:29:04.300 --> 00:29:06.970
by editing the manifest
and build.gradle files.

00:29:06.970 --> 00:29:10.940
You're going to start with the
manifest of your new module.

00:29:10.940 --> 00:29:13.390
The first step is to
declare this module

00:29:13.390 --> 00:29:17.380
as a new split APK of your app.

00:29:17.380 --> 00:29:20.230
To do so, you going to
add the split attribute

00:29:20.230 --> 00:29:23.830
in the manifest tag
and give a name, which

00:29:23.830 --> 00:29:27.640
is vrviewer in this example.

00:29:30.250 --> 00:29:33.580
The next step is to add
the module tag, which

00:29:33.580 --> 00:29:36.910
is going to declare a
module, and you're going

00:29:36.910 --> 00:29:39.280
to give a title to the module.

00:29:39.280 --> 00:29:42.970
This tag is used by Play
Store to identify the modules

00:29:42.970 --> 00:29:46.480
of your application.

00:29:46.480 --> 00:29:50.150
Next, you declare this
module as an on-demand module

00:29:50.150 --> 00:29:53.450
by adding the
onDemand attribute.

00:29:53.450 --> 00:29:55.880
This means that
this module is only

00:29:55.880 --> 00:29:58.700
going to be delivered
to the user's device

00:29:58.700 --> 00:30:01.460
when the app requests
it from the Play Store,

00:30:01.460 --> 00:30:04.050
instead of delivering
it at install time.

00:30:04.050 --> 00:30:08.210
Of course, we now know that
on-demand modules are only

00:30:08.210 --> 00:30:10.710
supported on L plus devices.

00:30:10.710 --> 00:30:15.900
So if you choose to also provide
this module in 3L devices,

00:30:15.900 --> 00:30:18.380
you're going to
add the fusing tag

00:30:18.380 --> 00:30:21.320
to instruct Play
Store to include

00:30:21.320 --> 00:30:24.860
this module alongside the
base module at install time,

00:30:24.860 --> 00:30:30.920
when delivering to 3L devices
or in the universal APK.

00:30:30.920 --> 00:30:33.670
Now look at the
build.gradle files.

00:30:33.670 --> 00:30:37.110
We're going to start
with the dynamic module.

00:30:37.110 --> 00:30:41.390
The first thing is that we're
now using a new plugin called

00:30:41.390 --> 00:30:45.120
com.android.dynamic-feature.

00:30:45.120 --> 00:30:47.720
The second thing is
we add the base module

00:30:47.720 --> 00:30:51.740
as a dependency to
this module so that we

00:30:51.740 --> 00:30:55.040
can access the functionality
included in the base module.

00:30:57.560 --> 00:31:01.090
The only change required in the
build.gradle file of the base

00:31:01.090 --> 00:31:04.480
module is to add the
dynamic features list

00:31:04.480 --> 00:31:08.260
and put all the dynamic
module names into this list.

00:31:08.260 --> 00:31:11.930
This is to instruct gradle
to make the resources stored

00:31:11.930 --> 00:31:16.100
in the base module available
to those dynamic modules.

00:31:16.100 --> 00:31:19.680
Now Anthony is going to show you
how you can use those modules

00:31:19.680 --> 00:31:23.560
with the new Play Core Library.

00:31:23.560 --> 00:31:26.120
ANTHONY MORRIS: Thanks, Ibo.

00:31:26.120 --> 00:31:27.860
So let's take a
look at how you go

00:31:27.860 --> 00:31:30.980
about requesting on-demand
modules to be installed, when

00:31:30.980 --> 00:31:33.410
you want them to be installed.

00:31:33.410 --> 00:31:35.480
So in order to interact
with the Play Store,

00:31:35.480 --> 00:31:38.510
we are introducing
a split install API

00:31:38.510 --> 00:31:42.260
as part of a new library
called the Play Core Library.

00:31:42.260 --> 00:31:44.870
Now the Play Core Library
is a Java client library

00:31:44.870 --> 00:31:48.140
that communicates with the
Play to have IPC on the device.

00:31:48.140 --> 00:31:49.970
And then the Play
Store communicates

00:31:49.970 --> 00:31:53.150
with Play's servers to download
these on-demand modules when

00:31:53.150 --> 00:31:55.320
you request them.

00:31:55.320 --> 00:31:57.480
Let's take a look at
a bit of the code.

00:31:57.480 --> 00:32:00.399
The API is structured using
the same task framework

00:32:00.399 --> 00:32:02.690
that you're probably familiar
with from the Google Play

00:32:02.690 --> 00:32:06.980
Services API and
FireBase APIs on Android.

00:32:06.980 --> 00:32:09.770
Installation of splits is
coordinated by a class called

00:32:09.770 --> 00:32:12.130
the splitInstallManager.

00:32:12.130 --> 00:32:14.570
You construct a request
with all the models

00:32:14.570 --> 00:32:16.190
that you wish to
download, and then

00:32:16.190 --> 00:32:18.940
you invoke startInstall
to trigger the Play

00:32:18.940 --> 00:32:21.780
to download the splits required
for those requested modules.

00:32:24.640 --> 00:32:26.590
The API also allows
you to listen

00:32:26.590 --> 00:32:30.640
for updates throughout the
download and install process.

00:32:30.640 --> 00:32:34.030
You can use this to display
progress and download

00:32:34.030 --> 00:32:36.190
progress in the install
progress to your users,

00:32:36.190 --> 00:32:39.239
while they are waiting for the
on-demand feature to download.

00:32:39.239 --> 00:32:40.780
You saw this in the
video that Pierre

00:32:40.780 --> 00:32:43.530
showed when it was downloading
the address of the module.

00:32:46.100 --> 00:32:49.430
For large modules, you'll need
to obtain user confirmation

00:32:49.430 --> 00:32:52.910
prior to the download by
the split install API.

00:32:52.910 --> 00:32:55.460
You'll need to do this
whenever the app requests

00:32:55.460 --> 00:32:57.850
more than 10 megabytes
of on-demand modules

00:32:57.850 --> 00:32:58.930
to be downloaded.

00:33:01.510 --> 00:33:03.970
However, there is an
alternative option

00:33:03.970 --> 00:33:07.600
for installing these modules,
which if they aren't required

00:33:07.600 --> 00:33:10.930
immediately for immediate use,
and we call this the deferred

00:33:10.930 --> 00:33:14.110
installation API.

00:33:14.110 --> 00:33:17.320
If you use this simple one line
to request a deferred install

00:33:17.320 --> 00:33:19.060
of a module, then
the module will

00:33:19.060 --> 00:33:22.187
be downloaded at a
convenient time for the user.

00:33:22.187 --> 00:33:23.770
This is generally
when the user is not

00:33:23.770 --> 00:33:27.160
using the device, and its
charging in its own Wi-Fi.

00:33:27.160 --> 00:33:30.940
And because of this, we allow
you to install larger modules

00:33:30.940 --> 00:33:33.850
by the API, without
requiring user confirmation,

00:33:33.850 --> 00:33:35.930
up to 100 megabytes.

00:33:35.930 --> 00:33:37.810
So this is a really
user-friendly way

00:33:37.810 --> 00:33:40.430
to download large on-demand
modules for your app.

00:33:43.570 --> 00:33:46.710
You can also use the split
install API to manage

00:33:46.710 --> 00:33:48.210
your on-demand modules.

00:33:48.210 --> 00:33:50.880
So you can see which modules
are currently installed.

00:33:50.880 --> 00:33:53.400
And if you user no
longer needs that module,

00:33:53.400 --> 00:33:56.070
you can request for the
module to be uninstalled,

00:33:56.070 --> 00:33:58.790
freeing up the precious
disk space for your users

00:33:58.790 --> 00:34:01.320
and reducing the footprint
of your app on their device.

00:34:04.670 --> 00:34:07.660
Now when you go and
install an on-demand module

00:34:07.660 --> 00:34:12.000
on N Plus devices, the app
does not need to be restarted.

00:34:12.000 --> 00:34:13.750
So the code is
available immediately

00:34:13.750 --> 00:34:17.949
upon install completing and
new resources and assets

00:34:17.949 --> 00:34:22.120
are available once you
refresh your context object.

00:34:22.120 --> 00:34:25.570
However, on Android
L/M, installing splits

00:34:25.570 --> 00:34:27.610
requires the app
to restart, if you

00:34:27.610 --> 00:34:29.550
want to install them properly.

00:34:29.550 --> 00:34:32.150
But to avoid this,
we've included

00:34:32.150 --> 00:34:34.900
a split compact
library, which emulates

00:34:34.900 --> 00:34:37.210
the installation
of a split on L/M

00:34:37.210 --> 00:34:38.920
until the app goes
into the background

00:34:38.920 --> 00:34:40.670
and we can properly install it.

00:34:40.670 --> 00:34:42.699
And so this split
compact library

00:34:42.699 --> 00:34:45.170
means that your app
doesn't need to restart,

00:34:45.170 --> 00:34:49.210
and almost all the
things inside this module

00:34:49.210 --> 00:34:51.920
are immediately
available to your app.

00:34:51.920 --> 00:34:53.980
You can set this split
compact library up

00:34:53.980 --> 00:34:55.600
in a very similar
way to how you might

00:34:55.600 --> 00:35:01.450
be familiar with setting up the
Multidex library in your apps.

00:35:01.450 --> 00:35:04.320
Finally, when you release
an update to your app,

00:35:04.320 --> 00:35:07.210
Play will automatically
update both the base module

00:35:07.210 --> 00:35:10.060
and any on-demand modules
that are already installed.

00:35:10.060 --> 00:35:12.820
So the versions of your
modules that are on a device

00:35:12.820 --> 00:35:14.440
are always in sync.

00:35:14.440 --> 00:35:16.010
They're always at
the same version.

00:35:16.010 --> 00:35:18.510
And partners tell us that this
is something that they really

00:35:18.510 --> 00:35:20.970
like about this model.

00:35:20.970 --> 00:35:23.670
All right, so let's
wrap this all up.

00:35:23.670 --> 00:35:27.450
Starting today, all developers
can build Android App Bundles

00:35:27.450 --> 00:35:30.810
in Android Studio 3.2 Canary.

00:35:30.810 --> 00:35:34.230
And they'll be able to publish
these on Play to all users.

00:35:34.230 --> 00:35:36.840
So I encourage all of you
to try this out and see

00:35:36.840 --> 00:35:39.300
how much smaller your app
can be just by switching

00:35:39.300 --> 00:35:41.800
to the Android App Bundle.

00:35:41.800 --> 00:35:44.400
Now, we will be rolling
out modularization

00:35:44.400 --> 00:35:46.920
to developers over
the coming months.

00:35:46.920 --> 00:35:49.710
From today, you can start
building modularized apps

00:35:49.710 --> 00:35:52.050
in the Studio Canary,
and you can publish them

00:35:52.050 --> 00:35:55.530
to the internal and alpha
tracks within the Play console.

00:35:55.530 --> 00:35:58.020
But we'll be opening up
publishing and production

00:35:58.020 --> 00:36:00.930
tracks as a beta over
the coming months.

00:36:00.930 --> 00:36:03.330
And if you're interested, you
can register your interest

00:36:03.330 --> 00:36:08.210
in modularization at
the link provided.

00:36:08.210 --> 00:36:11.200
And with that, thank you,
everyone, for coming.

00:36:11.200 --> 00:36:13.609
If you have any questions,
you can grab us afterwards.

00:36:13.609 --> 00:36:15.150
I don't think we
have time right now.

00:36:15.150 --> 00:36:17.733
Or you can grab us over the next
couple of days in the Sandbox

00:36:17.733 --> 00:36:19.747
C, just behind the stage.

00:36:19.747 --> 00:36:20.330
And thank you.

00:36:20.330 --> 00:36:22.022
Have a great I/O.

00:36:22.022 --> 00:36:26.020
[MUSIC PLAYING]

