WEBVTT
Kind: captions
Language: en

00:00:06.040 --> 00:00:07.200
WOLFF DOBSON: Hi, I'm
Wolff Dobson.

00:00:07.200 --> 00:00:08.130
DAN GALPIN: I'm Dan Galpin.

00:00:08.130 --> 00:00:09.380
BRUNO OLIVEIRA: And I'm
Bruno Oliveira.

00:00:12.310 --> 00:00:13.930
DAN GALPIN: So, money.

00:00:13.930 --> 00:00:16.350
True, there are many people who
make games just for fun.

00:00:16.350 --> 00:00:18.520
But of course, to many
developers, making money from

00:00:18.520 --> 00:00:20.130
games is a crucial part
of their business.

00:00:20.130 --> 00:00:21.180
BRUNO OLIVEIRA: But they've
still got to

00:00:21.180 --> 00:00:21.900
have some fun, right?

00:00:21.900 --> 00:00:23.270
DAN GALPIN: Well, of course.

00:00:23.270 --> 00:00:25.670
So one of the questions we often
get from developers is

00:00:25.670 --> 00:00:28.140
how do I make money
on Android games?

00:00:28.140 --> 00:00:30.340
If you're a developer, you
probably wish there was easy

00:00:30.340 --> 00:00:32.100
command to do that.

00:00:32.100 --> 00:00:35.500
But the truth is, it's
not that simple.

00:00:35.500 --> 00:00:37.710
BRUNO OLIVEIRA: Same thing with
many other questions we

00:00:37.710 --> 00:00:40.230
get, like, how do I
get discovered?

00:00:40.230 --> 00:00:41.560
How do I get featured?

00:00:41.560 --> 00:00:43.650
How do I get that five-star
rating?

00:00:43.650 --> 00:00:46.500
How do I get rid of those
pesky bad reviews?

00:00:46.500 --> 00:00:49.030
How do I make users
play my game?

00:00:49.030 --> 00:00:51.760
And how do I actually
make them buy stuff?

00:00:51.760 --> 00:00:54.360
That's a whole bunch
of questions.

00:00:54.360 --> 00:00:56.760
DAN GALPIN: Sometimes, these
questions miss a fundamental

00:00:56.760 --> 00:00:59.390
point, and that point is that
at the center of everything,

00:00:59.390 --> 00:01:01.190
there is a user.

00:01:01.190 --> 00:01:02.460
We like users.

00:01:02.460 --> 00:01:06.380
They are fascinating,
baffling creatures.

00:01:06.380 --> 00:01:08.120
BRUNO OLIVEIRA: So instead of
actually trying to answer

00:01:08.120 --> 00:01:10.060
those questions up there,
we'll focus on

00:01:10.060 --> 00:01:11.220
what's really important.

00:01:11.220 --> 00:01:12.390
And it's that guy.

00:01:12.390 --> 00:01:15.550
Successful games are the ones
that have many users and where

00:01:15.550 --> 00:01:17.180
those users are happy.

00:01:17.180 --> 00:01:20.050
If you do that, the odds that
you make tons of money or even

00:01:20.050 --> 00:01:23.350
be featured on Google
Play goes up a lot.

00:01:23.350 --> 00:01:24.800
WOLFF DOBSON: Which is why
we're going to focus on

00:01:24.800 --> 00:01:27.500
driving game installs and making
a great user experience

00:01:27.500 --> 00:01:29.600
along with the mechanics of
actually collecting money from

00:01:29.600 --> 00:01:30.690
your players.

00:01:30.690 --> 00:01:33.760
So let's talk about sign
in with Google.

00:01:33.760 --> 00:01:35.470
One think you can do to
grow your game is

00:01:35.470 --> 00:01:36.620
to use social features.

00:01:36.620 --> 00:01:38.970
We did a user survey recently
and found that users

00:01:38.970 --> 00:01:41.880
overwhelmingly trusted Google
to sign in across the web.

00:01:41.880 --> 00:01:44.230
This is because users trust
Google not spam their stream.

00:01:44.230 --> 00:01:45.880
You can share only what you
want or share it with the

00:01:45.880 --> 00:01:46.980
right people.

00:01:46.980 --> 00:01:51.150
Last year, we added APIs to
enable users to log in with

00:01:51.150 --> 00:01:53.490
their Hulu Plus identity, and
this year, we had access to

00:01:53.490 --> 00:01:54.320
the Social Graph.

00:01:54.320 --> 00:01:56.540
So quick update from Google+--

00:01:56.540 --> 00:01:59.160
500 million users makes Google+
one of the fastest

00:01:59.160 --> 00:02:07.060
growing social networks
in history.

00:02:07.060 --> 00:02:09.320
We've grown from just 150
million users between last

00:02:09.320 --> 00:02:10.220
year and last December.

00:02:10.220 --> 00:02:11.850
More than half of our
users are mobile.

00:02:11.850 --> 00:02:15.040
We have 135 million active
monthly users in the stream,

00:02:15.040 --> 00:02:17.960
and they spend about 12
minutes there daily.

00:02:17.960 --> 00:02:18.820
That's a lot of people.

00:02:18.820 --> 00:02:21.030
That's a lot of people who
can be playing your game.

00:02:21.030 --> 00:02:23.200
If you think about it, Google+
is truly at the heart of our

00:02:23.200 --> 00:02:25.520
efforts to create a simpler and
more intuitive experience

00:02:25.520 --> 00:02:26.480
for all our users.

00:02:26.480 --> 00:02:28.220
It's our social spine
that binds all of

00:02:28.220 --> 00:02:29.560
Google's products together.

00:02:29.560 --> 00:02:32.190
We have 120 Google+ integrations
to date that

00:02:32.190 --> 00:02:34.850
makes the user experience
better on Google.

00:02:34.850 --> 00:02:36.245
When you see your friends'
recommendations in Google

00:02:36.245 --> 00:02:38.810
Play, you don't think about that
as Google+, but it comes

00:02:38.810 --> 00:02:39.820
from that infrastructure.

00:02:39.820 --> 00:02:42.230
We're seeing a positive impact
across all our products.

00:02:42.230 --> 00:02:44.930
But what does sign in
do for developers?

00:02:44.930 --> 00:02:46.500
Well first and foremost,
it will help

00:02:46.500 --> 00:02:47.415
drive Android installs.

00:02:47.415 --> 00:02:50.040
There's a huge cliff getting
users to install your app

00:02:50.040 --> 00:02:52.590
before they can play it, and
we can help with that.

00:02:52.590 --> 00:02:54.110
I'll show how in a minute.

00:02:54.110 --> 00:02:55.620
Secondly is getting user
growth through

00:02:55.620 --> 00:02:56.740
targeted social sharing.

00:02:56.740 --> 00:02:58.850
Google+ allows you to share the
right information with the

00:02:58.850 --> 00:02:59.460
right people.

00:02:59.460 --> 00:03:01.950
So that means gamers sharing
information with gamers.

00:03:01.950 --> 00:03:04.390
You also have access to Google+
profiles and Social

00:03:04.390 --> 00:03:05.540
Graph, which will give
you a lot of

00:03:05.540 --> 00:03:07.050
information about your users.

00:03:07.050 --> 00:03:09.130
And finally, users
obviously trust

00:03:09.130 --> 00:03:11.560
Google as a login provider.

00:03:11.560 --> 00:03:14.040
So what does this look
like in a game?

00:03:14.040 --> 00:03:16.490
Here's my game, "Nostalgic
Racer," with Google+ sign in,

00:03:16.490 --> 00:03:19.640
and it's got a Google+
login button.

00:03:19.640 --> 00:03:22.120
You can fit into your interface
any way you want.

00:03:22.120 --> 00:03:24.660
If you click on that, I get a

00:03:24.660 --> 00:03:26.490
Google-provided permissions dialogue.

00:03:26.490 --> 00:03:27.530
There are two halves to it.

00:03:27.530 --> 00:03:29.380
The first indicates that
I am sharing my Social

00:03:29.380 --> 00:03:30.300
Graph with this app.

00:03:30.300 --> 00:03:32.820
From this dialogue, you can even
edit which subset of the

00:03:32.820 --> 00:03:33.790
graph you want it to see.

00:03:33.790 --> 00:03:35.790
I might not want to share
friends and family with this

00:03:35.790 --> 00:03:39.340
app, but I want to share
all my gamer friends.

00:03:39.340 --> 00:03:42.130
Second half controls who
might see that I am

00:03:42.130 --> 00:03:42.910
playing this game.

00:03:42.910 --> 00:03:44.600
So if you want your high school
friends to see that you

00:03:44.600 --> 00:03:48.030
are playing but not your mom,
you can make that happen.

00:03:48.030 --> 00:03:51.090
So after I click OK, I'm back
to the game, and you can see

00:03:51.090 --> 00:03:53.010
that I am completely
logged in.

00:03:53.010 --> 00:03:55.920
Well technically, Bruno is
completely logged in.

00:03:55.920 --> 00:03:58.370
If your users have signed in
to Google+ on their phone--

00:03:58.370 --> 00:04:00.820
and this is very, very likely--
using G+ Sign-In gets

00:04:00.820 --> 00:04:03.660
them signed in with one dialogue
very efficiently,

00:04:03.660 --> 00:04:05.090
with as little as two
clicks if they

00:04:05.090 --> 00:04:06.610
like the default settings.

00:04:06.610 --> 00:04:08.730
So you, the game developer,
now have access to their

00:04:08.730 --> 00:04:10.870
profile information, and you
have a better idea of who's

00:04:10.870 --> 00:04:11.600
playing your game.

00:04:11.600 --> 00:04:13.480
And you can see their Social
Graph, so you can see if they

00:04:13.480 --> 00:04:16.120
have friends who also play this
game or friends who might

00:04:16.120 --> 00:04:17.640
want to play this game.

00:04:17.640 --> 00:04:19.910
Now, let's say I play this game
a whole lot and get an

00:04:19.910 --> 00:04:22.570
awesome time on one of the
tracks in "Nostalgic Racer." I

00:04:22.570 --> 00:04:24.660
want to post about it, and I
want to make an interactive

00:04:24.660 --> 00:04:27.340
post about this track
in particular.

00:04:27.340 --> 00:04:29.610
So let's see an interactive
post.

00:04:29.610 --> 00:04:31.550
Here's one that I'm doing
to Todd and Bruno.

00:04:31.550 --> 00:04:34.720
I've mentioned them by name, and
I'm giving them a button

00:04:34.720 --> 00:04:37.160
to click to challenge me
on 8-Bit Speedway.

00:04:37.160 --> 00:04:38.350
The two big things here--

00:04:38.350 --> 00:04:40.620
first, with the Social Graph
data available, you can see

00:04:40.620 --> 00:04:42.640
which of my friends are playing
"Nostalgic Racer" and

00:04:42.640 --> 00:04:44.300
pre-fill the dialogue
with their names.

00:04:44.300 --> 00:04:46.980
And secondly, by mentioning
Todd and Bruno by name,

00:04:46.980 --> 00:04:49.080
they're really going
to see this.

00:04:49.080 --> 00:04:51.630
Since I've mentioned them
explicitly, depending on their

00:04:51.630 --> 00:04:53.630
settings, they're going to see
a notification on their G+

00:04:53.630 --> 00:04:55.930
stream, their email,
the web, even a

00:04:55.930 --> 00:04:56.960
notification on their phone.

00:04:56.960 --> 00:05:00.020
It's a really high
visibility share.

00:05:00.020 --> 00:05:01.580
So here's the post
in the stream.

00:05:01.580 --> 00:05:04.390
You've got a Challenge button,
and people will come to play.

00:05:04.390 --> 00:05:06.700
On the web, if you click on the
Challenge button, it might

00:05:06.700 --> 00:05:09.600
take you to your developer
website that will show them

00:05:09.600 --> 00:05:11.190
how to install the game.

00:05:11.190 --> 00:05:13.290
On your phone, if you click
on this link, you will go

00:05:13.290 --> 00:05:14.800
straight to the app itself.

00:05:14.800 --> 00:05:16.770
There are dozens of actions
you can choose.

00:05:16.770 --> 00:05:17.780
Challenges is one of them.

00:05:17.780 --> 00:05:20.370
That button can go to the exact
level in your game or

00:05:20.370 --> 00:05:22.060
provide some kind of help
in a social game,

00:05:22.060 --> 00:05:23.610
anything you want.

00:05:23.610 --> 00:05:24.920
And this is huge.

00:05:24.920 --> 00:05:26.540
If you click on one of these
links but you haven't

00:05:26.540 --> 00:05:29.520
installed the Android app, it
will take you directly to the

00:05:29.520 --> 00:05:30.740
Play Store.

00:05:30.740 --> 00:05:31.490
That's awesome.

00:05:31.490 --> 00:05:33.950
That's a great way to
drive installs.

00:05:33.950 --> 00:05:36.380
There's tons more
with Google+.

00:05:36.380 --> 00:05:38.540
We have over-the-air installs
off your website.

00:05:38.540 --> 00:05:39.970
We have analytics.

00:05:39.970 --> 00:05:43.530
We have +1 button sharing, and
we even have the Hangouts API

00:05:43.530 --> 00:05:44.290
for the web.

00:05:44.290 --> 00:05:48.610
So check it out on
developers.google.com/+.

00:05:48.610 --> 00:05:50.650
So sign in with Google+ can help
bring audience installs

00:05:50.650 --> 00:05:53.600
to your game, but you game has
to be awesome for those

00:05:53.600 --> 00:05:54.790
players have fun.

00:05:54.790 --> 00:05:58.490
Dan's going to talk
about that.

00:05:58.490 --> 00:06:03.630
DAN GALPIN: My name is Dan,
and I am an Android gamer.

00:06:03.630 --> 00:06:06.140
Really.

00:06:06.140 --> 00:06:08.430
One of the great things that
happened between last year at

00:06:08.430 --> 00:06:11.910
GDC and this year is that we
published quality guidelines.

00:06:11.910 --> 00:06:13.700
To get to these quality
guidelines, go to

00:06:13.700 --> 00:06:16.720
developer.android.com
and click Distribute

00:06:16.720 --> 00:06:18.045
and click App Quality.

00:06:21.380 --> 00:06:24.950
So here they are, core app
quality guidelines.

00:06:24.950 --> 00:06:28.360
There's a lot of stuff here that
games often get wrong.

00:06:28.360 --> 00:06:30.730
We've been telling game
developers for years to make

00:06:30.730 --> 00:06:33.340
sure their game navigates the
Android way with the Back

00:06:33.340 --> 00:06:35.510
button being used to
close their game.

00:06:35.510 --> 00:06:37.810
And we're gratified that
users seem to agree.

00:06:37.810 --> 00:06:41.190
Bad back button support
leads to bad reviews.

00:06:41.190 --> 00:06:43.690
Remember that this also applies
to the volume buttons.

00:06:43.690 --> 00:06:45.100
Let the system handle
them, and show the

00:06:45.100 --> 00:06:47.830
default volume controls.

00:06:47.830 --> 00:06:50.650
One thing that our Featuring
QA team cares lots about is

00:06:50.650 --> 00:06:52.350
making sure that your
game doesn't have a

00:06:52.350 --> 00:06:53.950
vestigial menu key.

00:06:53.950 --> 00:06:56.480
To remove it, target the latest
SDK that you can test

00:06:56.480 --> 00:06:59.380
on, which, of course,
should be 17.

00:06:59.380 --> 00:07:02.130
Targeting the most recent SDK
version also turns off

00:07:02.130 --> 00:07:05.210
compatibility hacks that can
impact game performance, so

00:07:05.210 --> 00:07:07.570
it's a good thing.

00:07:07.570 --> 00:07:10.360
Don't spam your users
with notifications.

00:07:10.360 --> 00:07:13.090
Also, offer your users precise
control over which

00:07:13.090 --> 00:07:14.980
notifications they are
shown and when.

00:07:14.980 --> 00:07:16.830
You'll not only get better
ratings, but you'll also

00:07:16.830 --> 00:07:20.010
encourage users with newer
devices to not use the Android

00:07:20.010 --> 00:07:23.870
method of blocking all
notifications.

00:07:23.870 --> 00:07:25.560
Don't use permissions
that you don't need.

00:07:25.560 --> 00:07:27.860
It's really unlikely that you'll
need to get access to

00:07:27.860 --> 00:07:30.110
sensitive user data.

00:07:30.110 --> 00:07:34.140
From last year, here's stuff
not to require, really.

00:07:34.140 --> 00:07:37.380
Feel free to pause and look
more closely at this list.

00:07:37.380 --> 00:07:40.480
And don't consider this
an exhaustive list.

00:07:40.480 --> 00:07:44.230
And sending/receiving SMS is
particularly bad, but using

00:07:44.230 --> 00:07:46.110
any of these permissions will
make it difficult to get a

00:07:46.110 --> 00:07:48.220
game featured.

00:07:48.220 --> 00:07:53.590
We've also talked quite a bit
about audio, because no one

00:07:53.590 --> 00:07:56.050
likes random audio coming
from their pants,

00:07:56.050 --> 00:07:58.560
especially your boss.

00:07:58.560 --> 00:08:01.490
Do time consuming tasks
in the background.

00:08:01.490 --> 00:08:03.780
Develop with strict
mode enabled.

00:08:03.780 --> 00:08:06.290
Make sure that you don't
get red flashes.

00:08:06.290 --> 00:08:08.260
Our testers will do it.

00:08:08.260 --> 00:08:10.460
Also make sure that you support
graphics for lots of

00:08:10.460 --> 00:08:11.810
form factors.

00:08:11.810 --> 00:08:15.100
It turns out that our quality
team mostly has access to our

00:08:15.100 --> 00:08:16.450
Nexus devices.

00:08:16.450 --> 00:08:18.810
And if your game can work well
with reasonable text sizes and

00:08:18.810 --> 00:08:21.410
touch targets on all of our
Nexus devices, there's a good

00:08:21.410 --> 00:08:23.590
chance the game will work
well on other devices.

00:08:23.590 --> 00:08:26.820
We also test on some other
extremely popular and

00:08:26.820 --> 00:08:28.250
problematic devices.

00:08:28.250 --> 00:08:30.550
If you're text isn't legible
or if the game requires

00:08:30.550 --> 00:08:33.490
smaller fingers, we
have a problem.

00:08:33.490 --> 00:08:35.570
And of course, if you want to
get featured, you'd better

00:08:35.570 --> 00:08:38.250
have a great feature graphic.

00:08:38.250 --> 00:08:41.530
Remember that many users will
see your graphic on a phone.

00:08:41.530 --> 00:08:45.910
Phones are small, and the same
1024 times 500 bitmap that you

00:08:45.910 --> 00:08:48.405
see on the web Google Play Store
is scaled down by Google

00:08:48.405 --> 00:08:51.550
Play to fit the smaller form
factor of a phone.

00:08:51.550 --> 00:08:54.330
You'll need to have large text
with excellent contrast if it

00:08:54.330 --> 00:08:56.010
will be readable.

00:08:56.010 --> 00:08:59.250
This title is legible, but on
the device, this subtitle is

00:08:59.250 --> 00:09:00.010
pretty much gone.

00:09:00.010 --> 00:09:02.750
And since I can't necessarily
recognize that stylized ball

00:09:02.750 --> 00:09:05.090
as a soccer ball, on the device,
I might miss the

00:09:05.090 --> 00:09:07.620
reference to the game I love.

00:09:07.620 --> 00:09:10.310
But the best part about our core
app quality guidelines is

00:09:10.310 --> 00:09:14.530
they come with tests you
can hand your QA team.

00:09:14.530 --> 00:09:17.800
So remember, to find out
more about this, got to

00:09:17.800 --> 00:09:21.700
developer.android.com, and
under the Distribute tab,

00:09:21.700 --> 00:09:25.780
select App Quality.

00:09:25.780 --> 00:09:28.220
We've also talked about game
controllers in the past.

00:09:28.220 --> 00:09:30.510
We've added support for standard
HID game controllers

00:09:30.510 --> 00:09:32.570
in Honeycomb, and it have been
gratifying to see so many

00:09:32.570 --> 00:09:35.650
games having some form of
limited support for them.

00:09:35.650 --> 00:09:38.740
So one of my favorite games is
"Nostalgic Racer," and I was

00:09:38.740 --> 00:09:40.660
really excited to see that
they have support for

00:09:40.660 --> 00:09:42.660
nostalgic controller.

00:09:42.660 --> 00:09:45.210
I spent lots for my nostalgic
controller, so I'm the kind of

00:09:45.210 --> 00:09:47.390
gamer that sees the cost
of your game as being

00:09:47.390 --> 00:09:49.640
incremental.

00:09:49.640 --> 00:09:51.910
And then I find that the menus
don't navigate, and there

00:09:51.910 --> 00:09:53.920
isn't a good set of
default controls.

00:09:53.920 --> 00:09:56.540
And I can't use nostalgic
controller with the game when

00:09:56.540 --> 00:09:59.030
my Nexus 10 is connected
to my TV.

00:09:59.030 --> 00:10:00.960
So make gamers like me happy.

00:10:00.960 --> 00:10:03.310
Ship games that really support
controllers, in

00:10:03.310 --> 00:10:05.020
menus and in the game.

00:10:05.020 --> 00:10:06.710
If you're going to have
elaborate configuration

00:10:06.710 --> 00:10:07.910
screens, great.

00:10:07.910 --> 00:10:09.930
But also have great defaults.

00:10:09.930 --> 00:10:11.840
Almost every controller
will work well in

00:10:11.840 --> 00:10:13.600
menus with these settings.

00:10:13.600 --> 00:10:16.080
And if your game only needs
digital controls or buttons,

00:10:16.080 --> 00:10:19.180
this will be a great
set of defaults.

00:10:19.180 --> 00:10:22.630
One thing to note is that I
suggest supporting both D-pad

00:10:22.630 --> 00:10:26.620
center and A. And the reason for
this is that, while most

00:10:26.620 --> 00:10:28.790
HID controllers will have these
buttons-- and we do a

00:10:28.790 --> 00:10:33.110
great job of mapping these to
reasonable defaults for D-pad

00:10:33.110 --> 00:10:34.740
and D-pad center.

00:10:34.740 --> 00:10:37.620
But for some reason, we decided
to map both A and B to

00:10:37.620 --> 00:10:38.870
the back button.

00:10:38.870 --> 00:10:41.510
And this doesn't really make
sense to most users as they

00:10:41.510 --> 00:10:43.850
are typically used to having
the A button perform an

00:10:43.850 --> 00:10:45.020
affirmative action.

00:10:45.020 --> 00:10:47.490
So make sure to actually
map the button that

00:10:47.490 --> 00:10:49.880
way within your UI.

00:10:49.880 --> 00:10:51.720
Here are some other you might
want to consider, but you

00:10:51.720 --> 00:10:54.560
shouldn't rely on these
buttons being there--

00:10:54.560 --> 00:10:57.190
some more buttons the standard
controllers will have.

00:10:57.190 --> 00:10:59.500
One other note, you get generic
motion events for

00:10:59.500 --> 00:11:00.730
analog joysticks.

00:11:00.730 --> 00:11:03.015
You also get them from D-pads
that are set up as hat

00:11:03.015 --> 00:11:04.560
switches, which is
very common.

00:11:04.560 --> 00:11:07.205
A single-motion event, however,
can have both a hat

00:11:07.205 --> 00:11:09.090
switch and analog motion.

00:11:09.090 --> 00:11:11.765
And if you had the analog event,
you must handle the hat

00:11:11.765 --> 00:11:14.070
switch event as well if you wish
to use the adding your

00:11:14.070 --> 00:11:16.440
game because otherwise the
system will think you've

00:11:16.440 --> 00:11:19.050
handled the analog event and
you won't get the generated

00:11:19.050 --> 00:11:20.980
D-pad event.

00:11:20.980 --> 00:11:25.740
So here are some common axes
that controllers will have.

00:11:25.740 --> 00:11:27.060
BRUNO OLIVEIRA: So,
in-app billing.

00:11:27.060 --> 00:11:28.400
In-app billing is actually
pretty cool.

00:11:28.400 --> 00:11:30.290
Every time we talk about in-app
billing to someone, we

00:11:30.290 --> 00:11:33.610
sort of expect them to go
something like this.

00:11:33.610 --> 00:11:36.500
But then, to our surprise, in
previous versions of the API,

00:11:36.500 --> 00:11:40.220
some people went
more like that.

00:11:40.220 --> 00:11:42.630
We didn't really understand
why that happened because

00:11:42.630 --> 00:11:44.840
in-app billing is actually
pretty simple.

00:11:44.840 --> 00:11:47.490
You just do that, and the item
is purchased, right?

00:11:47.490 --> 00:11:48.320
It's no problem.

00:11:48.320 --> 00:11:50.600
DAN GALPIN: Wait, don't you
have to do more than that?

00:11:50.600 --> 00:11:51.420
BRUNO OLIVEIRA: More
than that?

00:11:51.420 --> 00:11:52.510
OK, I'm actually
oversimplifying

00:11:52.510 --> 00:11:53.700
just a little bit.

00:11:53.700 --> 00:11:56.130
You actually have to have the
code that handles the purchase

00:11:56.130 --> 00:11:57.600
state changes.

00:11:57.600 --> 00:11:59.370
But then it's still not
that complicated.

00:11:59.370 --> 00:12:01.300
DAN GALPIN: But what if
the app is sleeping?

00:12:01.300 --> 00:12:03.690
BRUNO OLIVEIRA: OK, if the app
is sleeping when that happens,

00:12:03.690 --> 00:12:06.070
then you should probably just
add a broadcast receiver just

00:12:06.070 --> 00:12:07.500
make sure you don't
miss that message.

00:12:07.500 --> 00:12:08.620
But that's still
pretty simple.

00:12:08.620 --> 00:12:09.880
DAN GALPIN: But broadcasters
receives can't

00:12:09.880 --> 00:12:10.860
run for a long time.

00:12:10.860 --> 00:12:12.370
So what if you have to do
lots of database work or

00:12:12.370 --> 00:12:13.370
networking?

00:12:13.370 --> 00:12:14.580
BRUNO OLIVEIRA: Hmm,
that's true.

00:12:14.580 --> 00:12:16.270
Real applications have
to do that, right?

00:12:16.270 --> 00:12:19.530
So you should probably just
add a very simple and

00:12:19.530 --> 00:12:22.860
straightforward service,
something like that.

00:12:22.860 --> 00:12:25.700
And that's going to take care
of handling that for you.

00:12:25.700 --> 00:12:27.450
As you could see, the code is
very straightforward and

00:12:27.450 --> 00:12:28.820
simple to understand.

00:12:28.820 --> 00:12:31.570
DAN GALPIN: But what if you're
using managed items?

00:12:31.570 --> 00:12:33.340
Don't you need to make sure
that you persist those,

00:12:33.340 --> 00:12:35.670
because you can't call Google
Play very often

00:12:35.670 --> 00:12:36.960
to check for them?

00:12:36.960 --> 00:12:37.720
DAN GALPIN: That's true.

00:12:37.720 --> 00:12:40.010
So everybody loves
databases, right?

00:12:40.010 --> 00:12:43.280
So I think you can just add some
database code to your app

00:12:43.280 --> 00:12:45.550
just to make sure that you
store the purchases.

00:12:45.550 --> 00:12:47.460
And then you don't have to make
the calls all the time.

00:12:47.460 --> 00:12:50.530
Oh, and they should also
obfuscate that some way,

00:12:50.530 --> 00:12:55.230
because otherwise, users can
just hack into that and alter.

00:12:55.230 --> 00:12:58.180
But it's still pretty
simple, right?

00:12:58.180 --> 00:12:59.300
You don't believe me.

00:12:59.300 --> 00:13:01.700
So why does it get
so complicated?

00:13:01.700 --> 00:13:03.750
Let's start with the simplest
possible case.

00:13:03.750 --> 00:13:05.670
So the user just wants
to buy something.

00:13:05.670 --> 00:13:08.710
And they buy something, and it
gets delivered to the app.

00:13:08.710 --> 00:13:11.040
So, so far, no problem, right?

00:13:11.040 --> 00:13:11.900
DAN GALPIN: Thanks, bro.

00:13:11.900 --> 00:13:12.520
BRUNO OLIVEIRA: Exactly.

00:13:12.520 --> 00:13:14.350
So not a problem so far.

00:13:14.350 --> 00:13:17.570
But suppose that instead,
the app is sleeping.

00:13:17.570 --> 00:13:18.910
What happens in that case?

00:13:18.910 --> 00:13:21.270
In that case, if the app is
not running, sleeping, or

00:13:21.270 --> 00:13:22.960
something else, a different
guy has

00:13:22.960 --> 00:13:23.750
to pick up the package.

00:13:23.750 --> 00:13:25.140
And that guy is the broadcast
receiver.

00:13:25.140 --> 00:13:27.840
And then that guy has to take
care of delivering the package

00:13:27.840 --> 00:13:30.380
to the app when it wakes up.

00:13:30.380 --> 00:13:31.250
DAN GALPIN: Thanks, bro.

00:13:31.250 --> 00:13:31.680
BRUNO OLIVEIRA: Exactly.

00:13:31.680 --> 00:13:33.640
And that's when problems can
happen, because suppose that

00:13:33.640 --> 00:13:36.920
that guy is not as reliable as
you think, and he drops the

00:13:36.920 --> 00:13:39.850
package or loses the package.

00:13:39.850 --> 00:13:41.940
So in V2, there are actually
many components that have to

00:13:41.940 --> 00:13:43.660
work together to ensure
that the user's

00:13:43.660 --> 00:13:45.140
purchase is handled correctly.

00:13:45.140 --> 00:13:46.930
And it can get a little
complicated.

00:13:46.930 --> 00:13:48.940
In comparison, here is
what the Version 3

00:13:48.940 --> 00:13:49.860
diagram looks like.

00:13:49.860 --> 00:13:52.360
No, actually, let's use more
of the slide for that.

00:13:52.360 --> 00:13:53.640
That's not going to fit.

00:13:53.640 --> 00:13:55.940
Let's use a full slide.

00:13:55.940 --> 00:13:56.650
That's better.

00:13:56.650 --> 00:13:59.800
So the diagram for V2 is very
simple, but it has seven

00:13:59.800 --> 00:14:00.610
sub-components.

00:14:00.610 --> 00:14:02.100
And we're going to spend the
next several minutes

00:14:02.100 --> 00:14:04.570
discussing each of the
components, sub-components,

00:14:04.570 --> 00:14:06.310
and also the sub-sub-components.

00:14:06.310 --> 00:14:07.860
DAN GALPIN: And they're
pastels.

00:14:07.860 --> 00:14:09.170
BRUNO OLIVEIRA: Exactly.

00:14:09.170 --> 00:14:09.930
Actually, just kidding.

00:14:09.930 --> 00:14:11.520
This is the diagram for
in-app billing V3.

00:14:11.520 --> 00:14:12.770
It's much simpler, right?

00:14:12.770 --> 00:14:15.600
So the main improvement in V3
is that API calls are now

00:14:15.600 --> 00:14:16.230
synchronous.

00:14:16.230 --> 00:14:18.240
So this means that your
application can get a response

00:14:18.240 --> 00:14:19.170
right away.

00:14:19.170 --> 00:14:20.630
And it's much more
straightforward to think

00:14:20.630 --> 00:14:21.060
about, too.

00:14:21.060 --> 00:14:23.160
For instance, if you want to
buy something like 50 gold

00:14:23.160 --> 00:14:25.340
coins, all they have to do is
make a request that looks

00:14:25.340 --> 00:14:27.880
something like, buy
50 gold coins.

00:14:27.880 --> 00:14:28.950
And guess what.

00:14:28.950 --> 00:14:31.780
If the purchase is OK, the API
is going to return something

00:14:31.780 --> 00:14:35.430
that's pretty simple--
like say, OK.

00:14:35.430 --> 00:14:39.470
And if you are used to V2, you
probably remember that listing

00:14:39.470 --> 00:14:42.540
the items that are owned by a
particular user is a very

00:14:42.540 --> 00:14:43.600
expensive operation.

00:14:43.600 --> 00:14:45.940
So you couldn't call
it all the time.

00:14:45.940 --> 00:14:48.080
So you had to do that
very sparingly.

00:14:48.080 --> 00:14:51.400
So your whole code had to be
structured around that

00:14:51.400 --> 00:14:52.990
limitation.

00:14:52.990 --> 00:14:55.510
In contrast, in V3, Google Play
actually implements a

00:14:55.510 --> 00:14:57.780
client-side cache and takes care
of keeping that in sync

00:14:57.780 --> 00:14:59.150
with the server for you.

00:14:59.150 --> 00:15:02.120
This means that calling restore
purchases is actually

00:15:02.120 --> 00:15:04.870
very cheap, and you can do that
as often as you need.

00:15:04.870 --> 00:15:06.800
For example, you could just
do that every time the

00:15:06.800 --> 00:15:11.630
application starts, so you know
what items the user owns.

00:15:11.630 --> 00:15:14.220
So I probably sound like I'm
trying to sell you something.

00:15:14.220 --> 00:15:16.990
So if you're a developer, then
over the years, you're

00:15:16.990 --> 00:15:19.160
probably grown a healthy
mistrust of people that don't

00:15:19.160 --> 00:15:21.060
show you any code.

00:15:21.060 --> 00:15:23.640
So, let's stop with the sales
and move on to something

00:15:23.640 --> 00:15:25.910
that's entirely different.

00:15:25.910 --> 00:15:28.240
So let's talk about
selling stuff.

00:15:28.240 --> 00:15:30.700
Before you can make any V3 API
calls, you have to check that

00:15:30.700 --> 00:15:31.870
it's actually supported.

00:15:31.870 --> 00:15:34.840
You can do that by using the
isBillingSupported API call.

00:15:34.840 --> 00:15:37.450
The good news is that the in-app
billing Version 3 API

00:15:37.450 --> 00:15:40.150
is supported on all devices
running Froyo and above and a

00:15:40.150 --> 00:15:41.100
recent version of
the Play Store.

00:15:41.100 --> 00:15:43.310
And that corresponds
to over 90% of the

00:15:43.310 --> 00:15:45.670
currently active devices.

00:15:45.670 --> 00:15:48.140
Now, how do you get a list of
the items that the user owns?

00:15:48.140 --> 00:15:49.480
You just call getPurchases.

00:15:49.480 --> 00:15:51.680
Remember that this call is
actually pretty cheap.

00:15:51.680 --> 00:15:53.890
And also notice that you get the
results right away without

00:15:53.890 --> 00:15:57.560
having to implement any
funny callbacks.

00:15:57.560 --> 00:15:59.270
Now, this is the moment
your application has

00:15:59.270 --> 00:16:00.320
been waiting for.

00:16:00.320 --> 00:16:03.010
It's that profound, unique,
magical moment of modern

00:16:03.010 --> 00:16:05.570
technology where the user
realizes that your virtual

00:16:05.570 --> 00:16:09.220
item is so cool and so awesome
that they are actually willing

00:16:09.220 --> 00:16:11.900
to give you real money for it.

00:16:11.900 --> 00:16:14.220
Most important of all, at that
moment, you have the user's

00:16:14.220 --> 00:16:18.160
trust, so imagine what happens
if you take the user's money

00:16:18.160 --> 00:16:19.670
and then lose the purchase.

00:16:19.670 --> 00:16:21.620
That's a pretty bad
experience, right?

00:16:21.620 --> 00:16:23.760
So again, they've paid
for something, and

00:16:23.760 --> 00:16:24.950
they didn't get it.

00:16:24.950 --> 00:16:27.540
The least you can expect after
that is a bad review, and

00:16:27.540 --> 00:16:29.500
you're probably going to have
to refund that money.

00:16:29.500 --> 00:16:31.790
And the user is probably not
going to be a user anymore, so

00:16:31.790 --> 00:16:33.600
that's something
to be avoided.

00:16:33.600 --> 00:16:36.470
So this is why V3 actually makes
it easier not to lose

00:16:36.470 --> 00:16:39.435
purchases by making all items
managed, which means Google

00:16:39.435 --> 00:16:42.190
Play keeps track of those
purchases for you.

00:16:42.190 --> 00:16:44.450
So how do you launch
this purchase flow?

00:16:44.450 --> 00:16:46.750
You can call getBuyIntent to get
an intent that's going to

00:16:46.750 --> 00:16:49.070
launch the purchase window.

00:16:49.070 --> 00:16:50.590
And then you launch
that intent using

00:16:50.590 --> 00:16:51.840
startIntentSenderForResult.

00:16:53.950 --> 00:16:55.930
The results of that purchase are
going to come back through

00:16:55.930 --> 00:16:58.510
your activities onActivityResult
callback.

00:16:58.510 --> 00:17:01.330
At that point, you get the
purchase response code, the

00:17:01.330 --> 00:17:05.089
purchase data, and
the signature.

00:17:05.089 --> 00:17:07.900
And that's pretty much all there
is for a simple app.

00:17:07.900 --> 00:17:09.780
So on start up, you call
getPurchases to see

00:17:09.780 --> 00:17:10.960
what the user owns.

00:17:10.960 --> 00:17:13.400
When the use wants to purchase
something, you call

00:17:13.400 --> 00:17:15.619
getBuyIntent and then
launch that intent.

00:17:15.619 --> 00:17:18.990
And on your onActivityResult
callback,

00:17:18.990 --> 00:17:22.050
you handle that purchase.

00:17:22.050 --> 00:17:24.644
And notice that it's actually
pretty hard to lose a

00:17:24.644 --> 00:17:25.190
purchase this way.

00:17:25.190 --> 00:17:27.180
You actually have to make an
effort to lose a purchase,

00:17:27.180 --> 00:17:29.440
because even if your application
crashed right

00:17:29.440 --> 00:17:32.470
after you started the purchase
flow and you never got the

00:17:32.470 --> 00:17:34.850
purchase result, it's all right,
because next time your

00:17:34.850 --> 00:17:37.710
application executes, you're
going call getPurchases, and

00:17:37.710 --> 00:17:40.140
you're going to realize that the
user has bought that item.

00:17:40.140 --> 00:17:43.160
So that purchase is not lost.

00:17:43.160 --> 00:17:44.770
Now, let's talk about
consumption.

00:17:44.770 --> 00:17:47.420
So, consumable items are
a new feature in V3.

00:17:47.420 --> 00:17:51.600
So to understand how it works,
let's do it like that.

00:17:51.600 --> 00:17:53.550
Somewhere inside Google
Play, there is a box

00:17:53.550 --> 00:17:54.290
with my name on it.

00:17:54.290 --> 00:17:54.750
I know.

00:17:54.750 --> 00:17:55.660
I've seen it.

00:17:55.660 --> 00:17:58.340
And inside are all
my virtual items.

00:17:58.340 --> 00:18:00.690
So what happens when Bruno
buys COOL ITEM?

00:18:00.690 --> 00:18:03.820
When I buy COOL ITEM, an item
called COOL ITEM appears

00:18:03.820 --> 00:18:05.030
inside that box.

00:18:05.030 --> 00:18:08.120
If you then ask Google Play,
what items does Bruno own,

00:18:08.120 --> 00:18:11.060
it's going to return Bruno
owns COOL ITEM.

00:18:11.060 --> 00:18:13.030
If I consume that item,
what happens?

00:18:13.030 --> 00:18:15.230
The item goes away in flames,
just like that.

00:18:15.230 --> 00:18:17.700
I've seen it happen.

00:18:17.700 --> 00:18:20.890
In that case, I don't own
that item anymore.

00:18:20.890 --> 00:18:23.360
And if I ask Google Play, what
items does Bruno own, it's

00:18:23.360 --> 00:18:24.970
going to return the empty set.

00:18:24.970 --> 00:18:26.450
So consuming an item
just means that

00:18:26.450 --> 00:18:28.940
it's no longer there.

00:18:28.940 --> 00:18:30.160
So how do you do that in code?

00:18:30.160 --> 00:18:32.830
You just call the
consumePurchases method, and

00:18:32.830 --> 00:18:35.490
you just pass it the purchase
token that you got from the

00:18:35.490 --> 00:18:38.030
getPurchases.

00:18:38.030 --> 00:18:40.380
One question that naturally
arises is when should I

00:18:40.380 --> 00:18:41.390
consume something?

00:18:41.390 --> 00:18:43.590
That's actually up to you
to decide how to use the

00:18:43.590 --> 00:18:44.330
Consumption API.

00:18:44.330 --> 00:18:47.420
But we're going to talk about
two of the most-used methods.

00:18:47.420 --> 00:18:50.940
You can either consume the item
when it's actually used,

00:18:50.940 --> 00:18:51.770
or you can consume it

00:18:51.770 --> 00:18:53.560
immediately when it's purchased.

00:18:53.560 --> 00:18:57.060
Both of them have advantages
and disadvantages.

00:18:57.060 --> 00:18:59.640
To explain method one, I'm going
to give a quick example.

00:18:59.640 --> 00:19:01.360
So that's me.

00:19:01.360 --> 00:19:03.720
Anyway, that's the
stick figure me.

00:19:03.720 --> 00:19:06.230
And those are the items that
I own in Google Play.

00:19:06.230 --> 00:19:09.390
Like everybody else, I walk
around with a hit point bar of

00:19:09.390 --> 00:19:10.310
top of my head.

00:19:10.310 --> 00:19:12.810
And as you know, it's a pretty
dangerous world out there for

00:19:12.810 --> 00:19:14.120
stick figure characters.

00:19:14.120 --> 00:19:16.860
So I'm probably thinking, before
I venture out there

00:19:16.860 --> 00:19:19.880
battling bugs, I am better
off buying a potion.

00:19:19.880 --> 00:19:23.250
So I buy this potion, and then
I own this potion, correct?

00:19:23.250 --> 00:19:27.830
And then I go out and venture
into the wild world of

00:19:27.830 --> 00:19:28.690
programming.

00:19:28.690 --> 00:19:30.800
And in the course of my
adventures, I battle several

00:19:30.800 --> 00:19:33.480
bugs, and I end up losing a
whole bunch of hit points.

00:19:33.480 --> 00:19:35.210
Then I decide to use
that potion.

00:19:35.210 --> 00:19:36.960
At that point, your application
is going to

00:19:36.960 --> 00:19:40.320
consume the potion and then give
me a full hit point bar.

00:19:40.320 --> 00:19:42.760
So that's how it works.

00:19:42.760 --> 00:19:44.480
That's a perfectly good
method, but it has a

00:19:44.480 --> 00:19:45.770
significant limitation.

00:19:45.770 --> 00:19:48.410
So it has to do with how Google
Play actually thinks

00:19:48.410 --> 00:19:49.240
about things.

00:19:49.240 --> 00:19:51.710
So Google Play only
really knows two

00:19:51.710 --> 00:19:53.760
numbers, zero and one.

00:19:53.760 --> 00:19:56.800
If your game actually requires
that I should be able to buy

00:19:56.800 --> 00:19:59.150
more than one potion, then this
method doesn't work for

00:19:59.150 --> 00:20:02.140
you, because if it's a really
dangerous world out there and

00:20:02.140 --> 00:20:05.190
I'm going to need more than one
healing potion with me,

00:20:05.190 --> 00:20:07.040
then I can't do that
using this method.

00:20:07.040 --> 00:20:09.810
Because as soon as you try to
buy a second potion, what's

00:20:09.810 --> 00:20:11.980
going to happen is that Google
Play is going to notice that I

00:20:11.980 --> 00:20:14.140
already have a potion, so it's
going to see there's a potion

00:20:14.140 --> 00:20:14.600
right there.

00:20:14.600 --> 00:20:16.400
Why are you asking
for a second one?

00:20:16.400 --> 00:20:17.660
That makes no sense.

00:20:17.660 --> 00:20:19.660
Google Play can only
count to one.

00:20:19.660 --> 00:20:21.330
So you need a better method
if you're going

00:20:21.330 --> 00:20:23.100
to implement that.

00:20:23.100 --> 00:20:27.530
And that method is immediate
consumption.

00:20:27.530 --> 00:20:29.900
In this case, your application
is responsible for managing

00:20:29.900 --> 00:20:30.980
the user's inventory.

00:20:30.980 --> 00:20:33.680
Notice my excellent rendering
of a plastic bag there.

00:20:33.680 --> 00:20:37.190
So when I buy something, you
immediately consume it, and

00:20:37.190 --> 00:20:39.570
then you put it into my plastic
bag or inventory or

00:20:39.570 --> 00:20:42.430
wallet or anything else
in your application.

00:20:42.430 --> 00:20:44.670
And from that point on, you are
the one responsible for

00:20:44.670 --> 00:20:46.880
managing the item.

00:20:46.880 --> 00:20:48.925
So if I buy a second one, that's
all right with Google

00:20:48.925 --> 00:20:52.160
Play because it doesn't know
that I have another one.

00:20:52.160 --> 00:20:54.950
So I consume that one and add
it to my inventory, and

00:20:54.950 --> 00:20:57.070
everything works.

00:20:57.070 --> 00:20:59.310
If you're using this method two,
it's very important to

00:20:59.310 --> 00:21:01.720
also check on start up if there
any outstanding items

00:21:01.720 --> 00:21:03.090
that you need to consume.

00:21:03.090 --> 00:21:06.130
For example, suppose that your
application crashed right

00:21:06.130 --> 00:21:07.170
before consuming an item.

00:21:07.170 --> 00:21:09.060
You purchased something,
and then you crashed.

00:21:09.060 --> 00:21:11.370
What happens is that next time
you start up, you should check

00:21:11.370 --> 00:21:14.130
the user's inventory and make
sure that there's nothing

00:21:14.130 --> 00:21:14.920
consumable there.

00:21:14.920 --> 00:21:17.050
If there is something consumable
that should have

00:21:17.050 --> 00:21:19.520
been consumed, this is the time
when you consume it and

00:21:19.520 --> 00:21:21.870
credit it to the user's
inventory to make sure that

00:21:21.870 --> 00:21:24.350
they didn't lose
that purchase.

00:21:24.350 --> 00:21:26.560
So summarizing, on start up,
you call getPurchases.

00:21:26.560 --> 00:21:29.090
If you find a potion,
you consume it.

00:21:29.090 --> 00:21:30.740
When the user wants to purchase
something, you call

00:21:30.740 --> 00:21:33.540
getBuyIntent and then launch
that BuyIntent to get of the

00:21:33.540 --> 00:21:34.810
purchase flow.

00:21:34.810 --> 00:21:37.540
On your activity's
onActivityResult callback if

00:21:37.540 --> 00:21:38.940
the purchase of was successful,
it's ready to

00:21:38.940 --> 00:21:40.460
consume it.

00:21:40.460 --> 00:21:42.800
When you get the result from the
consumption, you add it to

00:21:42.800 --> 00:21:45.310
the inventory, if it was
successful, of course.

00:21:45.310 --> 00:21:47.910
Now, let's move on to
a very important

00:21:47.910 --> 00:21:49.670
subject, which is security.

00:21:49.670 --> 00:21:52.370
So believe it or not, in the
interwebs, there are some

00:21:52.370 --> 00:21:54.950
shady characters out there--
shocking, I know--

00:21:54.950 --> 00:21:58.230
that may be trying to take your
stuff without paying.

00:21:58.230 --> 00:22:01.190
I don't really know what the
technical term is, but I'll

00:22:01.190 --> 00:22:04.180
say they are pirates, mostly
because we spent a really long

00:22:04.180 --> 00:22:06.970
time drawing this character, and
I had to use it somewhere.

00:22:06.970 --> 00:22:09.620
So every time you see a purchase
in your application,

00:22:09.620 --> 00:22:13.090
you should ask yourself, is
that purchase legitimate?

00:22:13.090 --> 00:22:14.990
And a pirate's job is going
to be to try to

00:22:14.990 --> 00:22:16.510
convince you that it is.

00:22:16.510 --> 00:22:20.170
And your job is to detect
that they are lying.

00:22:20.170 --> 00:22:21.910
No one can actually stop
piracy altogether.

00:22:21.910 --> 00:22:24.650
I would be lying to you
if I said as much.

00:22:24.650 --> 00:22:27.150
But you can actually make life
pretty hard for pirates.

00:22:27.150 --> 00:22:29.100
So here are some defenses
you can employ--

00:22:29.100 --> 00:22:31.830
developer payload, signature
verification, and server-side

00:22:31.830 --> 00:22:33.430
the validation.

00:22:33.430 --> 00:22:35.200
Let's talk about developer
payload.

00:22:35.200 --> 00:22:37.360
Developer payload is actually
something really simple.

00:22:37.360 --> 00:22:40.030
Its just a tag that gets
attached to every purchase.

00:22:40.030 --> 00:22:41.850
And whenever you query
for that purchase, it

00:22:41.850 --> 00:22:43.100
comes back with it.

00:22:43.100 --> 00:22:44.780
So you should use it
to identify the

00:22:44.780 --> 00:22:45.670
owner of the purchase.

00:22:45.670 --> 00:22:47.400
And the reason why you want to
identify the owner of the

00:22:47.400 --> 00:22:49.680
purchase is to prevent
a replay attack.

00:22:49.680 --> 00:22:53.790
So how does that kind
of attack work?

00:22:53.790 --> 00:22:56.920
OK, so again, that's me,
a stick figure again.

00:22:56.920 --> 00:22:59.945
Like everyone else, not only I
have a hit point bar, but I

00:22:59.945 --> 00:23:01.540
also have an evil twin.

00:23:01.540 --> 00:23:03.040
So it's that guy over there.

00:23:03.040 --> 00:23:07.060
That guy, apart from having a
goatee, isn't very honest.

00:23:07.060 --> 00:23:09.210
And last week, he actually
picked up my phone and did a

00:23:09.210 --> 00:23:12.220
database dump on the items I had
and then tried to replay

00:23:12.220 --> 00:23:15.360
them on his device, hoping
to get items for free.

00:23:15.360 --> 00:23:18.240
So when Onurb, my evil twin,
runs your application, you'll

00:23:18.240 --> 00:23:21.620
check what items he owns, and
you'll see this purchase.

00:23:21.620 --> 00:23:24.120
Now, all you have to do is check
the developer payload,

00:23:24.120 --> 00:23:26.060
and you'll know that it's a fake
because it says belongs

00:23:26.060 --> 00:23:28.640
to Bruno, and it's Onurb that's
trying to use it.

00:23:28.640 --> 00:23:32.330
And it's hard for Onurb to fake
that developer payload

00:23:32.330 --> 00:23:35.990
because every purchase is signed
with a private key that

00:23:35.990 --> 00:23:36.980
only we have.

00:23:36.980 --> 00:23:40.470
So it's very difficult for him
to alter that signature.

00:23:40.470 --> 00:23:42.930
So speaking about signatures,
so what is signature

00:23:42.930 --> 00:23:43.640
verification?

00:23:43.640 --> 00:23:47.020
Well, every application has a
private key and a public key.

00:23:47.020 --> 00:23:49.860
The private key is known only to
Google, and the public key

00:23:49.860 --> 00:23:51.010
is known to you.

00:23:51.010 --> 00:23:53.670
Every time we send a purchase
response, we sign that

00:23:53.670 --> 00:23:55.350
purchase with the private key.

00:23:55.350 --> 00:23:57.830
And then you can verify that
signature with the public key.

00:23:57.830 --> 00:24:00.870
So this means that nobody else
outside of Google can actually

00:24:00.870 --> 00:24:05.020
send you a correctly
signed purchase.

00:24:05.020 --> 00:24:08.020
So if you check that, you can
be reasonably sure that the

00:24:08.020 --> 00:24:10.040
purchase is legitimate.

00:24:10.040 --> 00:24:14.000
Now, signature verification is
not actually very difficult.

00:24:14.000 --> 00:24:15.470
You can implement it
just using the

00:24:15.470 --> 00:24:16.860
standard Java framework.

00:24:16.860 --> 00:24:18.160
But it comes with our sample.

00:24:18.160 --> 00:24:20.430
So if you are just basing your
code on our sample, you don't

00:24:20.430 --> 00:24:22.750
even have to implement that.

00:24:22.750 --> 00:24:25.680
Even though signature
verification is pretty cool,

00:24:25.680 --> 00:24:28.630
thinking that client-side
security alone is enough would

00:24:28.630 --> 00:24:31.600
be a big mistake, because
regardless of how secure you

00:24:31.600 --> 00:24:34.040
make things, phones
can be hacked.

00:24:34.040 --> 00:24:36.310
So you should definitely add
server-side security to your

00:24:36.310 --> 00:24:37.950
application.

00:24:37.950 --> 00:24:40.560
On the server side, you should
check the signature again,

00:24:40.560 --> 00:24:42.640
just in case the client
has been compromised.

00:24:42.640 --> 00:24:44.525
A cool thing you can do in the
server that you can't do in

00:24:44.525 --> 00:24:46.790
the client is to check order
numbers, because since you are

00:24:46.790 --> 00:24:49.900
receiving every order from every
user, you can check if a

00:24:49.900 --> 00:24:52.900
given order number is a
duplicate from another number

00:24:52.900 --> 00:24:54.980
that you actually delivered
to someone else.

00:24:54.980 --> 00:24:57.080
And it's very important that
you secure the handshake,

00:24:57.080 --> 00:25:00.590
because it's not going to do
you any good if you have a

00:25:00.590 --> 00:25:02.740
perfectly good signature
verification, order number

00:25:02.740 --> 00:25:04.060
verification method
and then the

00:25:04.060 --> 00:25:06.010
handshake is very insecure.

00:25:06.010 --> 00:25:10.280
So make sure that the handshake
is also very secure.

00:25:10.280 --> 00:25:13.430
So just giving you a summary of
the security methods that

00:25:13.430 --> 00:25:14.860
we presented--

00:25:14.860 --> 00:25:17.430
if you don't do anything, you
are essentially a sitting

00:25:17.430 --> 00:25:21.370
duck, and anything can be used
to exploit your application.

00:25:21.370 --> 00:25:24.200
If you do only client-side
signature verification, you

00:25:24.200 --> 00:25:26.300
are protected against the man
in the middle attack.

00:25:26.300 --> 00:25:28.800
So it's going to be hard
to replay purchases.

00:25:28.800 --> 00:25:32.180
If in addition to that, you
use the unique developer

00:25:32.180 --> 00:25:35.430
payload, then you are also
going to be relatively

00:25:35.430 --> 00:25:38.100
protected against purchase
replay attacks.

00:25:38.100 --> 00:25:40.310
If you add server-side
verification to that, you're

00:25:40.310 --> 00:25:43.360
also going to be safe against a
rarer form of attack, which

00:25:43.360 --> 00:25:46.310
is framework compromise.

00:25:46.310 --> 00:25:48.490
The actual combination of
methods that's appropriate for

00:25:48.490 --> 00:25:50.450
your application is largely
your decision.

00:25:50.450 --> 00:25:52.980
We just wanted to outline to
you some of the security

00:25:52.980 --> 00:25:55.110
methods that are the
most popular.

00:25:55.110 --> 00:25:57.080
DAN GALPIN: And one
more thing.

00:25:57.080 --> 00:25:59.480
One of the things that you as
game developers have been

00:25:59.480 --> 00:26:01.730
asking for ever since the launch
of in-app billing in

00:26:01.730 --> 00:26:04.590
Google Play is the ability
to get real-time pricing

00:26:04.590 --> 00:26:07.390
information so that you could
actually display the actual

00:26:07.390 --> 00:26:10.750
price that Google Play will
be charging your users.

00:26:10.750 --> 00:26:12.640
And it turns out that's one
of the main things we've

00:26:12.640 --> 00:26:14.460
added in IAB V3.

00:26:14.460 --> 00:26:16.630
BRUNO OLIVEIRA: Imagine if it
was even localized to the

00:26:16.630 --> 00:26:16.900
user's language.

00:26:16.900 --> 00:26:17.590
DAN GALPIN: And it is.

00:26:17.590 --> 00:26:18.410
BRUNO OLIVEIRA: And it is.

00:26:18.410 --> 00:26:19.660
DAN GALPIN: So you
can actually do

00:26:19.660 --> 00:26:20.630
quite a lot with that.

00:26:20.630 --> 00:26:24.670
So that's pretty much all we
have on in-app billing and on

00:26:24.670 --> 00:26:25.540
game quality.

00:26:25.540 --> 00:26:26.840
BRUNO OLIVEIRA: We
hope you enjoyed.

