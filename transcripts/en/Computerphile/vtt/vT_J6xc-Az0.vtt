WEBVTT
Kind: captions
Language: en-GB

00:00:00.000 --> 00:00:04.589
&gt;&gt; DFB: It's a great pleasure today to welcome back
an old friend - Professor Brian Kernighan, now of

00:00:04.589 --> 00:00:09.429
Princeton University, previously at Bell
Labs. For those of you who would like to know

00:00:09.429 --> 00:00:13.960
how we met in the first instance, we have
already prepared a Computerphile video on

00:00:13.960 --> 00:00:18.859
this very topic. You can refer to the
"Great 202 Jailbreak" which is all about

00:00:18.859 --> 00:00:23.029
computerized typesetting in the very
early 1980s. So, welcome back

00:00:23.029 --> 00:00:29.410
Brian! It's only been 30-odd years
since you last spoke to us here.

00:00:29.410 --> 00:00:36.640
And we're delighted to have you here in the more
intimate "Computerphile" context. 

00:00:36.640 --> 00:00:44.030
Perhaps I could begin by asking you, just a little
bit, about "What was it like to work at Bell Labs. ?"

00:00:44.030 --> 00:00:48.149
&gt;&gt; BWK: Right, so first let me say it's actually a
pleasure to be back at Nottingham and

00:00:48.149 --> 00:00:52.110
this is not the same digs as you had 30-odd years ago.

00:00:52.110 --> 00:00:57.170
It's definitely fun to be back.  What
was it like at Bell Labs.? Well I first

00:00:57.170 --> 00:01:02.059
went to Bell Labs., I think, in 1967,
I had ... I was at the time a graduate

00:01:02.059 --> 00:01:06.510
student in computer science, except it
was before computer science - it was

00:01:06.510 --> 00:01:12.580
electrical engineering at Princeton and
I was lucky enough to get a summer job

00:01:12.580 --> 00:01:17.970
at Bell Labs and so I spent two summers
there actually working on a couple of

00:01:17.970 --> 00:01:21.390
different things - one of which became my
thesis. But it was a wonderful place

00:01:21.390 --> 00:01:25.000
because there were an enormous number of
really good people doing really

00:01:25.000 --> 00:01:29.060
interesting things and nobody telling
you what to do. That's kind of a rewarding

00:01:29.060 --> 00:01:34.900
environment and so it was so good that
when I graduated from Princeton I didn't

00:01:34.900 --> 00:01:38.840
even interview any other place. I just said "OK
I'll go to Bell Labs, they offered me a job

00:01:38.840 --> 00:01:43.690
why not do it?". And that was a decision that
was extremely lucky, and I've

00:01:43.690 --> 00:01:50.000
never regretted it. What it was like was,
I would guess that in one single large-ish

00:01:50.000 --> 00:01:54.370
building then we're probably 4,000
people, of whom about 2,000 were

00:01:54.370 --> 00:01:59.400
probably PhD's in various forms of
science: physics, chemistry and materials

00:01:59.400 --> 00:02:05.430
and then on - call it the 'softer' end -
of mathematics and the relatively new field of

00:02:05.430 --> 00:02:07.870
computer science, at that point.

00:02:07.870 --> 00:02:11.940
A large number of really, really excellent
people and the environment was "You can

00:02:11.940 --> 00:02:17.420
do anything you want" because the revenue
source for Bell Labs was very stable.

00:02:17.420 --> 00:02:21.440
It was part of AT&amp;T which, in effect,
provided telephone service for the whole

00:02:21.440 --> 00:02:26.360
country and the way it did it at that time
... AT&amp;T was a regulated monopoly which

00:02:26.360 --> 00:02:29.930
meant that they had in effect a
guaranteed rate of return and they

00:02:29.930 --> 00:02:35.530
peeled a tiny piece of that off for
research to improve telephone service in

00:02:35.530 --> 00:02:39.760
the country - that was the quid pro quo.
And because of that there was no

00:02:39.760 --> 00:02:44.730
shortage of resources and no management
direction that said you have to do

00:02:44.730 --> 00:02:50.040
something that will save the company in
the next quarter. That was really very

00:02:50.040 --> 00:02:54.270
satisfying and so most people worked on
things that were in some way long term,

00:02:54.270 --> 00:02:59.100
or at least whose immediate application
wasn't obvious. Hard to beat that

00:02:59.100 --> 00:03:03.200
environment, I think, and I think I was
there for over 30 years and I was never

00:03:03.200 --> 00:03:08.200
once told what I should be working on.
The way it worked was, at the end of each

00:03:08.200 --> 00:03:11.890
year, you had to write down on one side
of one piece of paper what you had done

00:03:11.890 --> 00:03:14.870
during the year and they used that to
determine how much they'd pay you next year.

00:03:14.870 --> 00:03:24.640
&gt;&gt; DFB: So, I'm all in favour of this benevolent 
monopoly environment because, after all, it gave 
us UNIX.

00:03:24.640 --> 00:03:30.560
And as we all know UNIX changed everything.
it really, really did in the computer science field

00:03:30.560 --> 00:03:37.620
But one of the recurring themes of all your work
over the years was, if you like, little languages and

00:03:37.620 --> 00:03:43.260
software tools. In the "202 Jailbreak" movie
I think I referred to your "pic", y' know,

00:03:43.260 --> 00:03:49.500
the little pre-processor for doing line-diagrams within 
typeset documents. But that's by no means the only one,

00:03:49.500 --> 00:03:53.080
so, again, was this just you

00:03:53.080 --> 00:04:00.330
or was there a lot of mutual interest in the little 
languages - things joined together with UNIX pipelines -

00:04:00.330 --> 00:04:05.580
that sort of approach?  
&gt;&gt;  BWK: I that the interest was perhaps latent there 
and then when

00:04:05.580 --> 00:04:09.320
the pipeline mechanism was invented
- which was some combination of Doug

00:04:09.320 --> 00:04:13.920
McIlroy with an idea and Ken Thompson
with an implementation - when that came

00:04:13.920 --> 00:04:18.000
along people started to think more
consciously of how you could combine

00:04:18.000 --> 00:04:22.890
programs so that this program could do
something and produce output that went to

00:04:22.890 --> 00:04:26.410
this program, and the combination would
do something richer and more interesting.

00:04:26.410 --> 00:04:34.169
I think it's hard to see ... in particular
that showed up in some of the document

00:04:34.169 --> 00:04:39.070
preparation tools fairly early on
because, among other things, there were

00:04:39.070 --> 00:04:44.090
limits on how big a program could be.
This was ... hard to think back that far but

00:04:44.090 --> 00:04:50.870
a big machine at the time would have 64
Kbytes - Kbytes by the way, not

00:04:50.870 --> 00:04:56.410
Mbytes or Gbytes - and so that meant that
any individual program could not

00:04:56.410 --> 00:05:01.970
actually be very big and so there was a
natural tendency to write small programs

00:05:01.970 --> 00:05:05.370
and then the pipe mechanism and
basically input-output redirection made it

00:05:05.370 --> 00:05:11.669
possible to link one program to another.
And certainly for the work that Lorinda Cherry

00:05:11.669 --> 00:05:17.210
and I did on 'eqn' - which was a language for
typesetting mathematical expressions - the

00:05:17.210 --> 00:05:19.900
existing formatting program 'troff'

00:05:19.900 --> 00:05:23.110
precursor of things like TEX today -

00:05:23.110 --> 00:05:27.610
that was already a big program by the
standards of the time; it just barely fit

00:05:27.610 --> 00:05:33.050
in to the memory for user programs and so
adding more to it was not feasible, you

00:05:33.050 --> 00:05:38.810
couldn't actually do it. And so what we
did instead was to create an entirely

00:05:38.810 --> 00:05:42.810
separate program connect them with a
pipeline and then if the program is

00:05:42.810 --> 00:05:47.460
going to be separate you could have it
represent - recognize - a different language.

00:05:47.460 --> 00:05:51.660
It doesn't have to actually do the same
language because it's a separate program

00:05:51.660 --> 00:05:55.860
and I think that that was a place where,
perhaps, necessity was the mother of

00:05:55.860 --> 00:05:59.930
invention that it actually worked out
quite well and then further document

00:05:59.930 --> 00:06:02.380
preparation programs - you mentioned 'pic'
a moment ago -

00:06:02.380 --> 00:06:09.570
further document preparation programs
had that same property that they were

00:06:09.570 --> 00:06:14.760
separate programs, separate languages,
tailored to the particular job that they

00:06:14.760 --> 00:06:19.810
were trying to do. And so that separation of
concerns worked out really well forced on us,

00:06:19.810 --> 00:06:24.790
in some ways, by not having very much in
the way of computing resources. 

00:06:24.790 --> 00:06:31.240
&gt;&gt; DFB: So although it was forced upon you, was there 
a great sense of surprise about  "Wow! you actually gain
power and flexibility doing it this way"

00:06:31.240 --> 00:06:37.350
&gt;&gt; BWK: Yeah - and I think people started to think 
I know I remember fairly clearly at this

00:06:37.350 --> 00:06:41.860
point that when the pipe mechanism was
first invented - and it was literally

00:06:41.860 --> 00:06:47.400
not more than a day or so of existence,
in some sense, people started to say "Hey!

00:06:47.400 --> 00:06:51.000
wait a minute - this is very easy we can
connect programs together. But we may

00:06:51.000 --> 00:06:54.780
have to change the way the programs are
implemented, in a trivial way, so that

00:06:54.780 --> 00:06:57.990
they read from their standard input -
guaranteed - they write to their standard

00:06:57.990 --> 00:07:02.080
output - guaranteed - and then you can glue
them together". And then there was this burst

00:07:02.080 --> 00:07:06.550
of making straightforward changes to the programs 
so that they would fit in pipelines and then

00:07:06.550 --> 00:07:09.880
people doing interesting pipelines with them

00:07:09.880 --> 00:07:14.520
inventing crazy combinations that did things.
One of the finest examples was one that

00:07:14.520 --> 00:07:19.600
Steve Johnson did for finding spelling
mistakes - potential spelling mistakes - in

00:07:19.600 --> 00:07:23.090
the document. You take a document; you
convert into words - that's one program.

00:07:23.090 --> 00:07:26.460
You sort the words that's another
program; you compare them against the

00:07:26.460 --> 00:07:30.720
dictionary - that's another program and
you print the ones that are in the

00:07:30.720 --> 00:07:34.920
document but not in the dictionary. And
that's another program, and so this multi-

00:07:34.920 --> 00:07:40.650
element pipeline was our first cut at a
spelling mistake detection program.

00:07:40.650 --> 00:07:47.730
&gt;&gt; DFB: Good heavens! Yeah! I suppose the 
thing you also have to learn, as I found to my
cost - by experience, is you've got to be somewhat

00:07:47.730 --> 00:07:56.740
careful when a thing has to be in a pipeline 
but has to be transparent, y'know, when you've 
always got to think

00:07:56.740 --> 00:08:02.080
about how might what I'm sending down the
line foul up by being picked up too early

00:08:02.080 --> 00:08:06.680
by something that I didn't expect. But there
again - small price to pay.

00:08:06.680 --> 00:08:10.200
&gt;&gt; BWK: But there's a nice example of that in
sorting - if you think about it - if

00:08:10.200 --> 00:08:15.340
you have a sort program in the middle of a 
pipeline it's a full-stop, because the downstream

00:08:15.340 --> 00:08:18.940
programs can't do anything else until
the sort program has done its job

00:08:18.940 --> 00:08:23.070
because it has to see all the input
before it can sort. But the fact that

00:08:23.070 --> 00:08:26.470
it's a full-stop doesn't matter to the user

00:08:26.470 --> 00:08:30.330
- it looks like it's just a continuous
process - and so the packaging of that

00:08:30.330 --> 00:08:32.419
it actually quite important - to do it well.

00:08:32.419 --> 00:08:38.229
&gt;&gt; DFB:  I think when I first came to UNIX I was
pretty familiar with the idea of what

00:08:38.229 --> 00:08:43.200
used to be called the job-control interpreter 
so there was no great surprise in

00:08:43.200 --> 00:08:49.150
encountering the UNIX 'shell'. But again, by
the time we're talking about late version 6 UNIX,

00:08:49.150 --> 00:08:58.560
version 7 - late '70s early '80s - all of
a sudden it was as if, from nowhere, you'd got
the idea of other flexible interpreted

00:08:58.560 --> 00:09:05.490
languages and I'm thinking of course,
primarily, of Awk So how did that come about?
&gt;&gt; BWK: Right,  so I think part

00:09:05.490 --> 00:09:08.890
of it - you mentioned the shells - I think
part of it comes about because the

00:09:08.890 --> 00:09:13.310
shells were used to combine programs and
you could do other things with the data

00:09:13.310 --> 00:09:16.260
as it was passing through, in a very
simple way. But the shells were not very

00:09:16.260 --> 00:09:20.730
good programming languages and so you wanted
to do more with them.

00:09:20.730 --> 00:09:27.050
Awk itself had three or four different
inspirations, I think, one of them not as

00:09:27.050 --> 00:09:31.230
well advertised at this point, I guess,
was a language done by Mark Rochkind in

00:09:31.230 --> 00:09:36.330
which he had designed a language for validating
data that was  ...  came from telephone

00:09:36.330 --> 00:09:40.700
switching systems - or something like that -
where all it did was to look for

00:09:40.700 --> 00:09:44.800
patterns of input and when it saw a
line that matched one of those patterns

00:09:44.800 --> 00:09:49.160
it printed it because it was ... or  perhaps
didn't match it ... it was some kind of error

00:09:49.160 --> 00:09:56.460
It was in effect a very simple streaming program. 
So that would be one influence from the outside and

00:09:56.460 --> 00:10:03.970
I had been interested in somehow having a
programming tool -  some kind of tool - where

00:10:03.970 --> 00:10:11.020
I could manipulate text and numbers more
or less together - kind of  equally easily. C programs

00:10:11.020 --> 00:10:14.780
were good at numbers but very bad at
text and the shell wasn't really very

00:10:14.780 --> 00:10:18.770
good at text and terrible at numbers. So I
was kind of interested in that sort of

00:10:18.770 --> 00:10:25.070
thing. Al Aho, who was in the office
next to me,  was very interested in

00:10:25.070 --> 00:10:29.850
regular expression technology' He'd just
finished 'egrep' which is an extended

00:10:29.850 --> 00:10:34.100
version of 'grep' - a much richer set
of regular expressions and very

00:10:34.100 --> 00:10:39.610
efficient implementation. Peter
Weinberger, who was on the other side of

00:10:39.610 --> 00:10:45.110
Al, was very interested in database-
related things he had just finished doing

00:10:45.110 --> 00:10:48.750
a tiny relational database for UNIX. So
here's this combination of three people,

00:10:48.750 --> 00:10:54.029
right together, interested in things
that sort of loosely are related to each

00:10:54.029 --> 00:10:59.579
other, but not much, and so we started
talking about what do you want, what

00:10:59.579 --> 00:11:03.160
could we do, what could we build here,
that would be an interesting tool and

00:11:03.160 --> 00:11:08.300
in some weird way it's a generalization of
'grep' and 'sed'. It includes a much richer

00:11:08.300 --> 00:11:13.610
set of regular expression stuff and there's
this database flavour. Peter knew about

00:11:13.610 --> 00:11:18.510
RPG, a report generator thing, and so I
don't whether you'd call it the great

00:11:18.510 --> 00:11:24.350
combination, or the mishmash, of these
things, put together, led us to designing

00:11:24.350 --> 00:11:30.579
'awk' and then doing the first implementation. It
wasn't a great deal of work I think at this

00:11:30.579 --> 00:11:35.230
point, if my memory is right, Peter did the
first implementation of it over a

00:11:35.230 --> 00:11:42.339
weekend - 3 or 4 days at most. A lot of it was
easy because we had the right tools at

00:11:42.339 --> 00:11:46.890
hand, in particular we had 'yacc' which was
the parser-generator that Steve

00:11:46.890 --> 00:11:53.730
Johnson and Al Aho had built. That made it easy
to define the syntax of the language so

00:11:53.730 --> 00:11:56.959
that you could parse statements in that
language and then you could hang

00:11:56.959 --> 00:12:01.709
semantic actions on it and that
existence of 'yacc' led to a whole bunch of

00:12:01.709 --> 00:12:07.720
different interesting tools in the UNIX
environment;  'eqn' which we talked about

00:12:07.720 --> 00:12:12.589
a few moments ago was done with 'yacc', for
example;  'pic' which you mentioned was done

00:12:12.589 --> 00:12:17.010
with 'yacc'. So, it was a very very effective
tool for building new languages and so

00:12:17.010 --> 00:12:20.630
that's another reason why I think people
thought in terms of language. "I've a tool

00:12:20.630 --> 00:12:23.649
that makes it easy to build language - so
let me just do it."

00:12:23.649 --> 00:12:27.200
&gt;&gt; DFB: My memory is of the sort of 
feeling of liberation,

00:12:27.200 --> 00:12:33.010
of setting up a 'sed' and 'awk' pipeline, driven 
from the shell, I just thought it was absolutely

00:12:33.010 --> 00:12:36.920
great. And yet there seemed out in the big wide world

00:12:36.920 --> 00:12:49.460
- although there was a lot of admiration for the work 
you did - that some people felt that re-integration might 
be a  positive advantage. I'm thinking, of course, of 'perl'. 
What's your take on this sort of tradeoff, if you like,  

00:12:49.460 --> 00:12:54.970
between having everything integrated so that all the
communication between what's happening

00:12:54.970 --> 00:13:05.080
is internal and therefore perhaps "more efficient"  in
quotes - I don't know - versus doing it the pipeline way?

00:13:05.080 --> 00:13:05.660
&gt;&gt; BWK: I think it's a  tradeoff !

00:13:05.660 --> 00:13:08.720
I think is precisely a tradeoff that
there's no single right answer. It

00:13:08.720 --> 00:13:12.870
depends on the application. There's some
things for which a quick and dirty

00:13:12.870 --> 00:13:17.600
sequence of separate programs works really
well. You just do it - you're done - you

00:13:17.600 --> 00:13:21.340
don't have to think about it. If you're doing
something more complicated, perhaps

00:13:21.340 --> 00:13:26.240
something which is going to last longer,
then integrating it into a single

00:13:26.240 --> 00:13:30.550
program is probably a better choice but
without looking at a particular

00:13:30.550 --> 00:13:36.230
situation I don't think I would know
which one to use. 'Perl' was definitely

00:13:36.230 --> 00:13:42.110
built as a reaction to 'awk';  'awk' had 
a lot of limitations at the time and some

00:13:42.110 --> 00:13:45.930
of the limitations were artificial
because the version that we were using

00:13:45.930 --> 00:13:50.110
internally was not the version that was
available outside. AT&amp;T in its wisdom

00:13:50.110 --> 00:13:56.140
decided that they wouldn't release the
richer version and so some of what

00:13:56.140 --> 00:14:00.410
Larry Wall did would have been
obviated by a newer version of 'awk', but

00:14:00.410 --> 00:14:02.060
then of course he added an enormous number

00:14:02.060 --> 00:14:07.650
very useful features to it and made it a
much richer scripting language and one which

00:14:07.650 --> 00:14:11.210
you could build bigger programs. I think
one of the issues for all of this is

00:14:11.210 --> 00:14:15.480
"How big is the ultimate program going to
be, or even the one that you're building

00:14:15.480 --> 00:14:19.810
right away"?  If you're doing something
that's only a couple of lines long 'awk'

00:14:19.810 --> 00:14:24.560
is great. I mean it really is. I don't think
anything beats it for one liners - and

00:14:24.560 --> 00:14:29.480
where "one" is a metaphor for "two or
three". But when you get bigger than that

00:14:29.480 --> 00:14:32.910
it doesn't scale very well because it
doesn't have any of the things that prevent

00:14:32.910 --> 00:14:38.390
you from doing something stupid - or, at least,
finding out when you did - and so, for

00:14:38.390 --> 00:14:44.810
bigger programs, you want something that
has more going for it. I think what's

00:14:44.810 --> 00:14:47.590
going on in modern programming language
is this more and more that kind of ...

00:14:47.590 --> 00:14:57.070
&gt;&gt; DFB:  Yeah! I think I can see a little bit of that ...
What I loved about it, of course, was its pattern-matching ability 
and then matching that pattern you took

00:14:57.070 --> 00:15:03.000
that action but again, I found the hard way, that 
what can be sometimes rather awkward is if in 

00:15:03.000 --> 00:15:07.620
the combined script you have two distinct
routes through it - 

00:15:07.620 --> 00:15:12.960
for two distinct purposes. It can be very difficult,
sometimes, disentangling those when things go

00:15:12.960 --> 00:15:18.610
wrong as inevitably they do.
&gt;&gt; BWK: The pattern-action paradigm is really, really good it

00:15:18.610 --> 00:15:23.500
is a great model for certain kinds of
computation; 'grap' is a pattern-action

00:15:23.500 --> 00:15:27.460
program; 'sed' is a pattern-action
program; 'yacc' is a pattern-action program

00:15:27.460 --> 00:15:31.600
'lex' - all of those tools have that same
model.  Here's some patterns and you read the

00:15:31.600 --> 00:15:34.970
input and if it pattern-matches, do the
corresponding action. So they're all

00:15:34.970 --> 00:15:39.210
great but there are plenty of things
that don't fall into that. If you want to

00:15:39.210 --> 00:15:43.510
make two passes over something, or if you
gotta remember complicated state it doesn't

00:15:43.510 --> 00:15:48.300
work as well. And what I've discovered
when I write 'awk' programs is often

00:15:48.300 --> 00:15:53.540
rather than trying to figure out how to
keep track of state from one

00:15:53.540 --> 00:15:59.910
line to another on the input, I read the
whole input into a giant array and then

00:15:59.910 --> 00:16:07.040
do traditional indexing computations on 
the array. It's just easier.
&gt;&gt; DFB:  Yeah! And again, adding the

00:16:07.040 --> 00:16:13.550
associative facility in that array that you can 
index into it via strings, and so on  - that's 
another big plus as well.

00:16:13.550 --> 00:16:20.149
But this business of you having a powerful
version of what you're doing at Bell Labs but

00:16:20.149 --> 00:16:23.149
the powers-that-be deciding

00:16:23.149 --> 00:16:30.709
supposedly, I guess, under very great stress 
of external pressure, as to exactly what should be

00:16:30.709 --> 00:16:38.480
released, with a UNIX release to the outside world,  
on the usual basis, from what I gather, that it's 
just not fair, say the other

00:16:38.480 --> 00:16:42.329
computer companies - you've got all these bright
people producing this stuff but they're cross-subsidised

00:16:42.329 --> 00:16:51.550
from our telephone bills. Were you, as a research 
community aware of that problem  all the time? 

00:16:51.550 --> 00:16:54.670
&gt;&gt; BWK: We were certainly aware of it. I don't think 
we paid a tremendous amount of attention to

00:16:54.670 --> 00:16:59.980
it, but it came up from time to time. It came up
... I think the reason that the 'awk' version

00:16:59.980 --> 00:17:04.370
where the official mechanism didn't want
to release a newer version of 'awk' was

00:17:04.370 --> 00:17:08.199
a perfectly legitimate concern with
standardization. You want to have

00:17:08.199 --> 00:17:12.669
something that other people can count on
its behaviour and properties. If you put out

00:17:12.669 --> 00:17:16.030
a new version - now you have two versions -
and there's potential confusion in the

00:17:16.030 --> 00:17:19.589
market and they weren't ready to do that.
So it was a combination of trying to

00:17:19.589 --> 00:17:24.659
present a unified version of something
and then wanting to actually own what it

00:17:24.659 --> 00:17:28.319
was that they were putting out and
supporting. So I think that one was

00:17:28.319 --> 00:17:34.450
legitimate. The cross subsidy issue, I
think, for people in research, basically

00:17:34.450 --> 00:17:39.470
didn't really show up. It was much more of
a legal concern and I think most of

00:17:39.470 --> 00:17:44.059
what was going on in our particular
domain was sufficiently down in the

00:17:44.059 --> 00:17:49.840
noise that it didn't affect us. It did,
probably, affect the people who were

00:17:49.840 --> 00:17:54.790
doing UNIX commercially - which was not
the research people - but the research

00:17:54.790 --> 00:18:00.510
people started with what had been done
... sorry, the commercialization people started

00:18:00.510 --> 00:18:02.520
with what had been done in research and
then, of course, added

00:18:02.520 --> 00:18:05.830
lots of things that made it a better

00:18:05.830 --> 00:18:11.900
commercial product. And they definitely, at 
various time,s had to worry about this 
cross-subsidy

00:18:11.900 --> 00:18:16.420
issue. It comes back to the fact that AT&amp;T
was a regulated public monopoly, getting

00:18:16.420 --> 00:18:21.270
a guaranteed rate of return on their
investments and so, yes, are you cross

00:18:21.270 --> 00:18:26.520
subsidizing by competing using money that other 
people were forced to buy your product with.

00:18:26.520 --> 00:18:34.140
&gt;&gt; DFB: Yes, I remember well going to 
presentations about our licensing terms for

00:18:34.140 --> 00:18:43.030
UNIX - and being warned about how careful we had 
to be, not to let commercial usage get mixed in with 
our educational usage, and so on. 

00:18:43.030 --> 00:19:01.280
But do you think, in the end, that had that not
been so restrictive and onerous by AT&amp;T, that the 
need to develop Linux might not ever have occurred?
&gt;&gt; BWK: That is an excellent question

00:19:01.280 --> 00:19:12.370
I don't think I have an answer - certainly not an
informed or accurate answer. I think probably if there

00:19:12.370 --> 00:19:16.210
had been the equivalent of open source,
at the time, really open source, then

00:19:16.210 --> 00:19:20.610
perhaps there would be less different
versions of UNIX floating around and

00:19:20.610 --> 00:19:26.500
there might be not be one done by this really 
bright student in Finland. Yeah, I think possibly

00:19:26.500 --> 00:19:30.420
that would have changed the game because
I know that some of the software

00:19:30.420 --> 00:19:39.610
development - associated with UNIX broadly -
was people trying to go around the AT&amp;T 
licensing considerations.

00:19:39.610 --> 00:19:49.210
&gt;&gt; DFB: Yeah, Of course we encountered that in our 
typesetting adventures that, basically, the whole business
of reverse-engineering, jailbreaking, whatever you want 
to call it - that you

00:19:49.210 --> 00:19:55.240
did was really motivated by the fact
that the whole concept of "Open-ness" just

00:19:55.240 --> 00:20:08.059
wasn't there, in the '70s and '80s. You just 
had to have closed systems, There was no way out of it.
Did you realize, at the time, how pioneering you were 
being, in a way, about all of this?

00:20:08.059 --> 00:20:11.710
&gt;&gt; BWK: No, I don't think so, certainly not on the
typesetting front, where I don't think it

00:20:11.710 --> 00:20:15.990
was pioneering. It was simply trying to
remove an impediment. We couldn't use the

00:20:15.990 --> 00:20:22.400
typesetter with the software that came with it. 
It was unusable. And so, again of necessity, we had to

00:20:22.400 --> 00:20:27.290
do something to make it so that we could
actually do what we wanted to do, because

00:20:27.290 --> 00:20:33.179
their software systems weren't up to what we
wanted to do. More broadly, the openness

00:20:33.179 --> 00:20:39.150
that you see today, in language design
and operating systems and so on, I don't

00:20:39.150 --> 00:20:44.030
think we predicted that in any way
either. Not clear how you make money

00:20:44.030 --> 00:20:48.850
doing that and of course a lot of
systems at the time - certainly in the

00:20:48.850 --> 00:20:52.160
seventies and eighties this was the
lifeblood of the companies that provided

00:20:52.160 --> 00:20:57.970
the service and so they couldn't just
give it away and make it back in ...

00:20:57.970 --> 00:20:58.760
What do you make it back in?  Public relations? 

00:20:58.760 --> 00:21:05.940
&gt;&gt; DFB: No you have to make it back by turning
yourself and saying "You can get the free

00:21:05.940 --> 00:21:07.540
open version but if you want really good backup

00:21:07.540 --> 00:21:15.040
we're the people to give it." But, of course,
that's not a stance that companies were prepared to 
take in those days.

00:21:15.040 --> 00:21:22.930
Again, I mean, as we both know, it happened with
computer hardware -  it certainly happened again with 
typesetting hardware. They  could not envisage a scene 

00:21:22.930 --> 00:21:29.710
where they didn't sell the hardware bundled with 
the software.
&gt;&gt; BWK: That certainly  was the model for a long

00:21:29.710 --> 00:21:34.700
long time, and in fact in early days, the IBM days, 
let's say in the '60s and '70s

00:21:34.700 --> 00:21:40.120
IBM made all of their money on the
hardware and the software was kind of

00:21:40.120 --> 00:21:46.410
given away as part of it. 
&gt;&gt; DFB: Yes it was all sorts of
ramifications over this side of the Atlantic

00:21:46.410 --> 00:21:57.840
about "When will IBM be forced to unbundle?"
I remember the word very clearly indeed. Aanyway, 
after 'awk' I get the impression that then, over 
the next few years, you moved into other areas of

00:21:57.840 --> 00:22:04.500
interest that had been around for a while - things
like tcl / tk, which I've never used, so could you say

00:22:04.500 --> 00:22:06.070
something about that?

00:22:06.070 --> 00:22:16.050
&gt;&gt; BWK: Yeah, tcl / tk is really two pieces. 
This is just wonderful work by John Ousterhout 
who, at the time, was at Berkeley; now at Stanford.

00:22:16.050 --> 00:22:23.840
And what John did with 'tcl', TCL, the tool
control language which was basically an

00:22:23.840 --> 00:22:28.570
interpreted language, a scripting
language if you like, that made it very

00:22:28.570 --> 00:22:33.120
easy to extend by adding C functions so
that the essence of it was that you

00:22:33.120 --> 00:22:36.320
could write code in this, but you would
be mostly calling functions that have

00:22:36.320 --> 00:22:42.740
been written in C. As a language it's
bizarre and I've told John that

00:22:42.740 --> 00:22:48.660
on a number of occasions but it was very 
very powerful you could actually do a lot with it and

00:22:48.660 --> 00:22:53.429
then 'tk' was an instance of a set of C
functions that would do something

00:22:53.429 --> 00:22:57.360
interesting. And it was basically a set
of graphics routines that worked with

00:22:57.360 --> 00:23:04.990
X11, so that you could very easily draw
things of real complexity and richness on a

00:23:04.990 --> 00:23:11.240
screen. I think as a graphics package it
is a great improvement on all of its

00:23:11.240 --> 00:23:17.429
successors. It's just a remarkably
efficient, effective and rich environment.

00:23:17.429 --> 00:23:22.890
So I used that for a number of years, doing
quick and dirty user interfaces for a

00:23:22.890 --> 00:23:27.600
variety of things and even one that was
used for a while inside Bell Labs. There was

00:23:27.600 --> 00:23:34.260
a project, ill-conceived I think, at least
in retrospect, for doing wireless

00:23:34.260 --> 00:23:37.490
systems that would work well inside
buildings -  especially big buildings

00:23:37.490 --> 00:23:43.600
- like hospitals and big stores. And so 
to do that you need something that will tell

00:23:43.600 --> 00:23:47.990
you how electromagnetic radiation propagates
within the building, so you have an

00:23:47.990 --> 00:23:54.020
elaborate model for EM propagation. You have
to know where things are in the buildings

00:23:54.020 --> 00:23:57.320
where are  the walls, what are they made of, what
are the floors - all of that kind of thing

00:23:57.320 --> 00:24:03.710
and then, from that, you can say "If I put
base station equipment - routers if you like -

00:24:03.710 --> 00:24:08.230
in various places in the building then I can
figure out what the coverage in the

00:24:08.230 --> 00:24:13.940
building is. But that's all kind of low-level,
radio, sort of thing. How do you make that

00:24:13.940 --> 00:24:19.140
accessible to somebody who might be, y'know, 
an engineer trying to design this stuff or

00:24:19.140 --> 00:24:23.570
somebody with not any of the real radio
background? And so what we did was to

00:24:23.570 --> 00:24:30.650
design a system that had all of that
prediction of propagation models and on

00:24:30.650 --> 00:24:34.230
top of that a user interface which would
show you

00:24:34.230 --> 00:24:37.840
slices through the building; show you where the
walls were - and things like that - and say "If

00:24:37.840 --> 00:24:40.730
you put a base station there this is what
the propagation is gonna look like over

00:24:40.730 --> 00:24:43.910
the building". And then. in addition, we
could even optimize

00:24:43.910 --> 00:24:46.780
that so that it would tell you "This is
where you ought to put the base stations

00:24:46.780 --> 00:24:51.970
given the number you propose to do". And I
wrote that user interface. That was 

00:24:51.970 --> 00:24:56.050
my part of it. I wrote that user
interface in tcl / tk it was really,

00:24:56.050 --> 00:25:01.050
really effective and surprisingly easy. I
remember being on a conference call with

00:25:01.050 --> 00:25:07.380
some people who were the ultimate users -
intended users - of the system and they

00:25:07.380 --> 00:25:10.830
said "You know, we really need a feature
to do something." I don't remember what the

00:25:10.830 --> 00:25:13.940
feature was and they kept talking about
the feature during the conference call.

00:25:13.940 --> 00:25:18.080
And while they were doing it I was
sitting in my office. I implemented it

00:25:18.080 --> 00:25:28.710
in 'tk' - because it was just so easy. It was really, really great  
&gt;&gt; DFB: So, this was your transition into the world of graphics 
and graphics terminals in a way?
&gt;&gt; BWK: Because early in those days, yeah, because we

00:25:28.710 --> 00:25:33.110
finally had terminals that weren't just text.
&gt;&gt; DFB: Exactly! And I think one of the

00:25:33.110 --> 00:25:37.870
things that was of interest -  great interest - to
us. You could see the huge strength of UNIX in

00:25:37.870 --> 00:25:50.050
the days of dumb terminals, if you like. But how was it 
going to cope with the great graphics onslaught in the 
late '80s? Now I think, looking back on it, there were 
all sorts of

00:25:50.050 --> 00:25:57.130
internal projects on your own terminals, and so on,
were there not?
 &gt;&gt; BWK: Yeah,  we had weird terminals.

00:25:57.130 --> 00:26:01.930
The one that I remember most clearly
was the Tektronix 4014 ?? - some random

00:26:01.930 --> 00:26:06.030
number -  I can't remember. There's lots of
random numbers in computing! But it was a big thing

00:26:06.030 --> 00:26:13.400
big green screen. But it had a sort
of vector graphics kind of thing where

00:26:13.400 --> 00:26:17.040
you could draw lines. You couldn't do
much beyond that - no shading or anything.

00:26:17.040 --> 00:26:21.380
So there were some graphics done with
that and then eventually we started to

00:26:21.380 --> 00:26:28.540
get color terminals that were bitmap, not 
vector and so there was a lot of interest in

00:26:28.540 --> 00:26:32.620
software to drive those sorts of things.
I didn't do very much of that by that

00:26:32.620 --> 00:26:36.330
point I was using other people's
libraries because that's a specialized technical

00:26:36.330 --> 00:26:38.620
area - to do that well.

00:26:38.620 --> 00:26:47.440
&gt;&gt; DFB: But in that sense, that was really where
collaboration outside of Bell Labs. had to come in 
- for things like X Windows, and so on, to become 
a standard ? 

00:26:47.440 --> 00:26:52.790
So, were you reasonably cool about that at Bell Labs.?  
You didn't feel that you ought to be totally dominating

00:26:52.790 --> 00:26:56.850
this field?
&gt;&gt; BWK:  I don't think - I certainly didn't care in 
the slightest

00:26:56.850 --> 00:27:03.270
there were people around me who, I think,
thought that X was very big, very

00:27:03.270 --> 00:27:08.750
complicated - and perhaps unnecessarily so.
I know that Rob Pike, in particular, did

00:27:08.750 --> 00:27:14.929
some really good work with overlapping
bitmap graphics so that if you have , y'know,

00:27:14.929 --> 00:27:19.340
two windows on a screen and you do something 
with them then you get a very efficient, rapid,  
update and he

00:27:19.340 --> 00:27:24.400
did some of the very first work on that
- very efficient algorithms - that I guess

00:27:24.400 --> 00:27:28.690
eventually found their way into X.
And so there were people interested in

00:27:28.690 --> 00:27:36.030
bit-blit, the technical things of bit mapping.
But I had drifted out of that at that

00:27:36.030 --> 00:27:42.090
point, so I didn't pay much attention to it. 
&gt;&gt; DFB: I think I've hogged the line of

00:27:42.090 --> 00:27:47.240
questioning for far too long, Brian, 
So, actually, cameramean Sean - Computerphile 
people will know - is

00:27:47.240 --> 00:27:56.280
expert at shouting questions, as well as doing
filming. So, over to you, Sean!

