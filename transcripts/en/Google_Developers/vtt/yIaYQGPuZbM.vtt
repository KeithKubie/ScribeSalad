WEBVTT
Kind: captions
Language: en

00:00:47.803 --> 00:00:49.803
   (Please stand by.

00:00:54.285 --> 00:00:56.285
The GOOGLE I/O 2018 session The 
Web: 

00:00:57.570 --> 00:01:01.185
State of the Union will begin 
shortly on Stage 2.)

00:04:40.815 --> 00:04:42.815
(Music playing.

00:04:43.823 --> 00:04:45.823
)

00:09:29.596 --> 00:09:34.992
   (The GOOGLE I/O 2018 session 
The Web: State of the Union will

00:09:34.993 --> 00:09:37.256
begin at the top of the hour.  
Please stand by.

00:09:40.263 --> 00:09:42.263
)

00:14:52.482 --> 00:14:55.326
   (The session The Web: State 
of the 

00:14:58.624 --> 00:15:01.123
Union will begin in 
approximately five minutes.  

00:15:01.124 --> 00:15:03.124
Please continue to stand by.

00:15:04.136 --> 00:15:06.136
)

00:17:20.695 --> 00:17:22.695
)

00:17:26.506 --> 00:17:28.506
(The GOOGLE I/O 2018 session on 
Stage 

00:17:32.418 --> 00:17:34.489
2, The Web: State of the Union, 
will begin momentarily.

00:17:37.493 --> 00:17:39.493
)

00:17:46.708 --> 00:17:50.580
   knowns welcome.  Thank you 
for joining.  Our session will 

00:17:50.581 --> 00:17:52.581
begin soon.
   (Music playing.

00:17:53.595 --> 00:17:55.595
)

00:18:00.579 --> 00:18:02.579
momentarily.)

00:18:03.719 --> 00:18:07.428
   &gt;&gt; ANNOUNCER:  Welcome.  
Thank you for joining.  Our 

00:18:07.429 --> 00:18:09.429
session will begin soon.
   (Music playing.

00:18:10.658 --> 00:18:12.658
)

00:18:50.189 --> 00:18:54.101
   &gt;&gt; ANNOUNCER:  At this time, 
please find your seat.  Our 

00:18:54.102 --> 00:18:56.102
session will begin soon.

00:19:38.523 --> 00:19:40.523
(Music playing.

00:19:41.534 --> 00:19:43.534
)

00:20:27.453 --> 00:20:29.490
   &gt;&gt;&gt; good afternoon, everyone 
and 

00:20:32.945 --> 00:20:34.945
welcome to the The Web: State of
the Union.

00:20:36.624 --> 00:20:38.659
I'm Ben gallon brat.
   &gt;&gt; MALTE UBL:  And I'm Malte 

00:20:38.660 --> 00:20:40.277
Ubl.
   &gt;&gt; BEN GALBRAITH:  We are 

00:20:40.278 --> 00:20:42.532
going to highlight what we are 
excited about.

00:20:43.555 --> 00:20:45.555
&gt;&gt; MALTE UBL:  We will talk 
through 

00:20:46.653 --> 00:20:48.517
the latest libraries and 
frameworks we are working on to 

00:20:48.518 --> 00:20:50.578
make you more productive.
   &gt;&gt; BEN GALBRAITH:  We have a 

00:20:50.579 --> 00:20:54.060
lot to cover in the session.  
Let's dive right in.

00:20:54.665 --> 00:20:57.118
&gt;&gt; MALTE UBL:  Let's go.
   All right.

00:20:58.961 --> 00:21:00.961
&gt;&gt; MALTE UBL:  The web has 
special 

00:21:02.862 --> 00:21:06.585
meaning for us at Google because
the core froab.  We are making 

00:21:06.586 --> 00:21:08.586
it open and accessible to the 
web.

00:21:10.878 --> 00:21:13.327
It is important for us that the 
web is healthy and driving.

00:21:14.752 --> 00:21:17.196
&gt;&gt; BEN GALBRAITH:  The web 
significance canned significant 

00:21:17.197 --> 00:21:19.683
new APIs and capabilities.
   &gt;&gt; MALTE UBL:  Probably the 

00:21:19.684 --> 00:21:21.684
most 

00:21:22.770 --> 00:21:25.461
important API in the last ten 
years is service worker.  Since 

00:21:25.462 --> 00:21:27.462
the beginning of the web it has 

00:21:28.727 --> 00:21:31.372
been about pagers the user 
requests and the browser 

00:21:31.373 --> 00:21:33.373
rendered and we changed that to 
top level abstraction that goes 

00:21:35.286 --> 00:21:37.286
beyond what a page can do, 
receiving 

00:21:39.961 --> 00:21:42.215
events like push, handle, data 
synchronization even after the 

00:21:42.216 --> 00:21:44.216
page went away.

00:21:47.311 --> 00:21:49.311
You can make robust offline web 
pages.

00:21:49.578 --> 00:21:51.820
Service worker has been in a 
good amount of browsers for 

00:21:51.821 --> 00:21:54.800
awhile but now they are 
basically everywhere.

00:21:59.851 --> 00:22:01.851
With Mac OS this Mayur and 
microchip 

00:22:03.536 --> 00:22:05.774
worker last week put out every 
single major modern browser 

00:22:05.775 --> 00:22:07.232
supports the standard.
   &gt;&gt; BEN GALBRAITH:  This is a 

00:22:07.233 --> 00:22:11.989
huge moment for the web and we 
are excited about it.  We have 

00:22:11.990 --> 00:22:14.315
been using progressive web app 
to explain the new improvements 

00:22:14.316 --> 00:22:16.333
and the gradual roll out of 
service worker 

00:22:19.400 --> 00:22:21.623
illustrates the bit here.  PWAs 
that are written progressively 

00:22:21.624 --> 00:22:26.573
to take advantage of browser 
feeps as they are available can 

00:22:26.574 --> 00:22:29.832
seamlessly upgrade with no need 
to redeploy.  PWAs are 

00:22:29.833 --> 00:22:31.833
everywhere.

00:22:34.373 --> 00:22:36.373
I want to share a few examples.

00:22:38.049 --> 00:22:40.709
Let's start with  OFO, global 
bike sharing company which is 

00:22:40.710 --> 00:22:42.710
coming to the Bay area soon.

00:22:45.791 --> 00:22:46.815
&gt;&gt; MALTE UBL:  Another one, all 
right.  Been you can never have 

00:22:46.816 --> 00:22:48.816
too many.

00:22:52.285 --> 00:22:53.313
This uses the GPS to find the 
camera all directly in the 

00:22:53.314 --> 00:22:56.958
browser.  That's it.  You can 
start riding the bike.  I love 

00:22:56.959 --> 00:23:00.220
this  example.  It shows the 
power of the web's low friction 

00:23:00.221 --> 00:23:04.490
model.  You skip all the steps 
of finding an app in the store 

00:23:04.491 --> 00:23:09.624
and installing it.
   So mother's day is coming up 

00:23:09.625 --> 00:23:13.308
next week.
   &gt;&gt; MALTE UBL:  Uh-oh.

00:23:15.743 --> 00:23:17.743
&gt;&gt; BEN GALBRAITH:  It makes 1800
flowers a good mention.

00:23:20.867 --> 00:23:23.517
50 percent more of their 
customers bought things after 

00:23:23.518 --> 00:23:25.518
they rolled out this app.

00:23:30.252 --> 00:23:33.328
Let's take a look at editor 
globo in Brazil.  They saw a 50 

00:23:33.329 --> 00:23:35.329
percent increase in 

00:23:37.235 --> 00:23:39.235
users time are spending on their
site.

00:23:39.327 --> 00:23:41.823
&gt;&gt; MALTE UBL:  Starbucks rolled 
out the PWA and saw their daily 

00:23:41.824 --> 00:23:43.824
and monthly users double.

00:23:47.221 --> 00:23:49.667
because in works well on 
desktops, users can order from 

00:23:49.668 --> 00:23:51.668
their desk and 

00:23:52.722 --> 00:23:54.722
Google found this-e -- Starbucks
found 

00:23:55.970 --> 00:23:57.628
this is something users want 
better than.

00:23:57.629 --> 00:23:59.629
&gt;&gt; BEN GALBRAITH:  Across all 
sites 

00:24:01.284 --> 00:24:02.734
with Google we saw upgrading 
with PWA delivers average 20 

00:24:02.735 --> 00:24:05.974
percent boost to the website 
conversion rate.  That's 20 

00:24:05.975 --> 00:24:07.975
percent more people who wind 

00:24:09.266 --> 00:24:11.266
up  transacting on the site as a
result.

00:24:12.532 --> 00:24:13.964
This PWA movement we have been 
talking about is not just lip 

00:24:13.965 --> 00:24:15.965
service.

00:24:17.262 --> 00:24:18.690
All modern web capabilities 
deliver a materially better 

00:24:18.691 --> 00:24:20.691
experience and it shows up in 
the bottom lune of the 

00:24:22.309 --> 00:24:24.309
businesses that we've all built 
on the web.

00:24:25.354 --> 00:24:27.355
&gt;&gt; MALTE UBL:  All right, Ben, 
since we are at Google I/O.

00:24:30.651 --> 00:24:32.651
It would be a good time to talk 
about 

00:24:34.540 --> 00:24:36.540
what Google itself is doing in 
the PWA space.

00:24:36.969 --> 00:24:39.231
Let's start with Google search. 
This is now backed about by 

00:24:39.232 --> 00:24:41.232
service 

00:24:42.896 --> 00:24:44.896
worker, makes loading  faster 
and more reliably.

00:24:47.403 --> 00:24:49.403
It drops download time by 50 
percent 

00:24:50.666 --> 00:24:52.898
and they are not -- at the scale
of storage as a huge user 

00:24:52.899 --> 00:24:54.899
experience.

00:24:56.770 --> 00:24:58.819
The service worker enables a 
whole category of new speakers.

00:25:03.751 --> 00:25:05.751
When you are search and you're 
offline you get a error message.

00:25:05.968 --> 00:25:07.968
With service worker, they will 
notify 

00:25:09.854 --> 00:25:11.893
you when you are back online and
your information is ready.

00:25:12.935 --> 00:25:15.352
&gt;&gt; BEN GALBRAITH:  Here is 
bulletin.  They have a PWA and 

00:25:15.353 --> 00:25:17.353
another example of the use on 
the web.

00:25:20.258 --> 00:25:22.258
They are all about capturing 
time 

00:25:23.543 --> 00:25:25.790
sensitive news events as they 
unfold so you can get to the 

00:25:25.791 --> 00:25:27.791
site of the action without 
friction.

00:25:29.660 --> 00:25:31.110
The bulletin team has a super 
development story because they 

00:25:31.111 --> 00:25:33.111
can get 

00:25:35.160 --> 00:25:37.160
to Android, iOS and more without
a 

00:25:38.426 --> 00:25:40.301
single progressive use base.
   &gt;&gt; MALTE UBL:  Another study 

00:25:40.302 --> 00:25:42.302
has a 

00:25:43.965 --> 00:25:45.994
low cost device for gaining 
access to fast growing markets 

00:25:45.995 --> 00:25:47.995
like India.

00:25:50.078 --> 00:25:52.078
Map skills, service worker is 
added to the web screen.

00:25:55.820 --> 00:25:58.657
It is for low network, it is 
good for less reliable networks 

00:25:58.658 --> 00:26:00.658
and uses less 

00:26:02.329 --> 00:26:03.547
money when your Internet is 
metered.

00:26:03.548 --> 00:26:06.437
&gt;&gt; BEN GALBRAITH:  This 
represents 15 percent of all 

00:26:06.438 --> 00:26:08.715
time spent on Chrome and Android
and 20 percent on Chrome for 

00:26:11.561 --> 00:26:13.625
desktop and over 30,000 years of
video are watched daily in 

00:26:13.626 --> 00:26:15.626
Chrome worldwide.

00:26:16.684 --> 00:26:18.684
I think this actually may be my 
kids alone.  Maybe.

00:26:20.771 --> 00:26:21.793
So a bunch of media specific 
work has been happening on the 

00:26:21.794 --> 00:26:23.794
platform.

00:26:25.124 --> 00:26:27.976
First the platforms gained a 
bunch of new media features, 

00:26:27.977 --> 00:26:30.006
like the new API with lock 
screen controls on the screer 

00:26:34.099 --> 00:26:36.099
and Vimeo is an example of a 
user who 

00:26:37.346 --> 00:26:39.346
integrated this and has seen 
strong usage.

00:26:42.270 --> 00:26:44.270
There is the media capabilities 
API, 

00:26:45.521 --> 00:26:50.429
you can make inr ninth choices. 
Pictures and picture support.  

00:26:50.430 --> 00:26:52.266
This is across desktop and 
mobile devices and new 

00:26:52.267 --> 00:26:56.982
presentation API that allows you
to explicitly control what you 

00:26:56.983 --> 00:26:59.765
show on secondary displays and 
let's talk about offline support

00:26:59.766 --> 00:27:01.766
for a minute.

00:27:02.883 --> 00:27:04.883
It is a major use case for many 
parts 

00:27:06.806 --> 00:27:08.806
of the world that limits access 
to high width bandwidth.

00:27:11.291 --> 00:27:13.291
So globo and boots are enabling 
the 

00:27:14.783 --> 00:27:16.783
new web line APIs into their Web
sites 

00:27:19.517 --> 00:27:21.517
and there's next generation open
royalty free code ECC coming.

00:27:26.026 --> 00:27:28.026
We developed partnership with 30
media 

00:27:29.492 --> 00:27:32.354
companies and 30 percent -- this
will have a big impact, shipping

00:27:32.355 --> 00:27:36.025
in Chrome later this year.
   Okay.  So we have been 

00:27:36.026 --> 00:27:38.507
focused on mobile but now I want
to talk about desktop for a 

00:27:38.508 --> 00:27:41.159
minute.  It is an audience that 
remains in the 

00:27:44.831 --> 00:27:47.062
billions and productivity web 
apps like G suite kin continue 

00:27:47.063 --> 00:27:51.737
to grow.  And like Starbucks, 
mobile focused experiences are 

00:27:51.738 --> 00:27:53.738
finding big traction when they 
come over to desktop.

00:27:56.224 --> 00:27:58.039
We are starting to take mobile 
lessons over to the desktop and 

00:27:58.040 --> 00:28:00.040
one of the things we are doing 
is adding support 

00:28:03.345 --> 00:28:05.345
for add to home screen to 
Chrome.

00:28:07.221 --> 00:28:09.221
Once you install PWA to the 
desktop it 

00:28:11.287 --> 00:28:13.287
gets its own icon and top level 
window.

00:28:16.184 --> 00:28:18.278
Findly you can use alt tab or 
cmd-tab to get to Windows and 

00:28:18.279 --> 00:28:20.732
because it is powered by the 
full Chrome browser you 

00:28:24.750 --> 00:28:29.034
get access to Chrome's browser 
afford answers like auto fill.  

00:28:29.035 --> 00:28:31.762
These features are available in 
beta in ChromeOS today and they 

00:28:31.763 --> 00:28:33.800
will ship to everyone in June 
and we'll follow with Windows 

00:28:33.801 --> 00:28:38.897
and Mac later this year.
   Also a big Spotify fan.  I'm 

00:28:38.898 --> 00:28:40.898
excited about the next spim.

00:28:41.965 --> 00:28:43.793
They are shipping for PWA 
features and you can experience 

00:28:43.794 --> 00:28:47.869
it now on ChromeOS.  It's a 
great fit.  The web gives music 

00:28:47.870 --> 00:28:53.151
fans a fast and convenient way 
to get right into Spotify and 

00:28:53.152 --> 00:28:55.152
listen to favorite songs and 
desktop 

00:28:56.238 --> 00:28:58.238
PWA is a itch client that allows
for 

00:29:00.721 --> 00:29:02.721
play back of music and it has 
Spotify 

00:29:04.229 --> 00:29:06.229
for remotely playing music or 
through 

00:29:07.289 --> 00:29:10.161
speakers or other features and 
Spotify apps that are running.  

00:29:10.162 --> 00:29:12.444
You can get into it with no 
installation hurdles or updates 

00:29:12.445 --> 00:29:14.491
to manage.
   &gt;&gt; MALTE UBL:  Well, that is 

00:29:14.492 --> 00:29:17.965
cool but let's talk about 
something even more exciting.  

00:29:17.966 --> 00:29:19.966
Email.

00:29:22.678 --> 00:29:25.532
I imagine half my life in Gmail 
and super awesome update we 

00:29:25.533 --> 00:29:27.533
original.

00:29:28.787 --> 00:29:30.787
It is the original web app and 
now a 

00:29:33.085 --> 00:29:35.521
desk PWA with these knew 
features will be a true top 

00:29:35.522 --> 00:29:39.290
level window.  You can treat it 
like any other app running on 

00:29:39.291 --> 00:29:41.326
the operating system.  The 
boundaries between websites and 

00:29:44.014 --> 00:29:45.637
apps are blurring on desktop as 
well.

00:29:45.638 --> 00:29:47.638
&gt;&gt; BEN GALBRAITH:  There is 
another example I want to share.

00:29:48.490 --> 00:29:50.490
Auto-CAD.

00:29:52.347 --> 00:29:54.576
So auto-CAD popularized computer
aided design since initial 

00:29:54.577 --> 00:29:59.287
release in 19 Yao and continues 
to innovate today.  There is 

00:29:59.288 --> 00:30:01.533
estimated two to 5 million 
auto-CAD drawings files opened 

00:30:01.534 --> 00:30:03.534
every day 

00:30:05.006 --> 00:30:08.909
and billions of them are stored 
in hosted file services.  This 

00:30:08.910 --> 00:30:10.910
is a great fit for these types 
of files.

00:30:12.484 --> 00:30:14.484
They set out to create a 
web-based 

00:30:15.986 --> 00:30:18.395
editor years ago but found their
complex optimized code base was 

00:30:18.396 --> 00:30:21.673
impractical to write in 
Javascript.  So enter web 

00:30:21.674 --> 00:30:23.674
assembly.

00:30:24.945 --> 00:30:26.972
It is a new standard that allows
execution of code right in the 

00:30:26.973 --> 00:30:31.884
browser and gives this code 
access to web APIs.  This opens 

00:30:31.885 --> 00:30:33.885
up a bunch of interesting 

00:30:34.968 --> 00:30:36.968
new use cases for the web like 
enabling 

00:30:38.037 --> 00:30:40.037
large C++ code bases, 
performance 

00:30:41.935 --> 00:30:44.182
sensitive code run in the 
browser such as immediate code 

00:30:44.183 --> 00:30:46.183
and enables games on the web.

00:30:47.630 --> 00:30:50.287
Unreal and unity, really popular
gaming engines can target web 

00:30:50.288 --> 00:30:52.288
assembly 

00:30:53.992 --> 00:30:55.992
and using web GL ugh do high 
performance 3D gaming.

00:30:57.879 --> 00:30:59.879
Best part, web assembly is 
available 

00:31:01.583 --> 00:31:04.879
today across the major modern 
brossers in mobile and desktop. 

00:31:04.880 --> 00:31:07.115
First time in the history of the
web that we had abroadly 

00:31:07.116 --> 00:31:09.116
available 

00:31:10.371 --> 00:31:11.608
alternative to Javascript across
browser.

00:31:11.609 --> 00:31:13.609
&gt;&gt; MALTE UBL:  Another big 
moment, actually.

00:31:13.873 --> 00:31:15.873
&gt;&gt; BEN GALBRAITH:  Let's get 
back to 

00:31:16.954 --> 00:31:19.626
auto-CAD, they launched a new 
app in Mayur that was able to 

00:31:19.627 --> 00:31:21.627
take the 

00:31:22.888 --> 00:31:24.888
35-year-old code base, older 
than the 

00:31:26.764 --> 00:31:28.771
web itself.
   &gt;&gt; MALTE UBL:  Older than me 

00:31:28.772 --> 00:31:29.755
almost.
   &gt;&gt; BEN GALBRAITH:  And they 

00:31:29.756 --> 00:31:34.382
are able to bring it to the web 
and auto-CAD is universally 

00:31:34.383 --> 00:31:35.596
accessible on all devices 
instantly.  If you are away from

00:31:35.597 --> 00:31:40.915
your workstation you can make 
edits to CAD drawings regardless

00:31:40.916 --> 00:31:43.366
of operating system and the 
engineering team has a shared 

00:31:43.367 --> 00:31:45.389
C++ code base.  As they make 
changes they are easily 

00:31:46.820 --> 00:31:51.110
integrated into the web  app.
   So web assembly in Chrome is 

00:31:51.111 --> 00:31:53.111
powered 

00:31:55.568 --> 00:31:57.399
by V8, the Javascript engine.  
Good time to talk about 

00:31:57.400 --> 00:31:59.400
performance.

00:32:01.228 --> 00:32:01.775
We are optimizing for real world
website and in partnership with 

00:32:01.776 --> 00:32:06.090
the community we created a new 
benchmark called speed meter 2.

00:32:09.553 --> 00:32:12.429
This measures Java performance 
in a web app  reimplemented in a

00:32:12.430 --> 00:32:16.103
dozen web frameworks and we are 
pleased to share that over the 

00:32:16.104 --> 00:32:18.104
past year our performance 

00:32:20.181 --> 00:32:22.413
on the score has dramatically 
improved including 112 percent 

00:32:22.414 --> 00:32:25.092
improvement with react with 
significant performance gains 

00:32:28.586 --> 00:32:30.586
across other frameworks, as you 
can see.

00:32:30.835 --> 00:32:32.835
&gt;&gt; MALTE UBL:  Your react apps 
will 

00:32:33.881 --> 00:32:34.895
run twice as fast to compared to
a year ago on the same  

00:32:34.896 --> 00:32:36.896
hardware.

00:32:38.118 --> 00:32:38.137
That's amazing.
   &gt;&gt; BEN GALBRAITH:  In 

00:32:38.138 --> 00:32:40.138
addition to 

00:32:41.328 --> 00:32:44.632
this VM has a bunch of new 
Javascript features.  Be sure to

00:32:44.633 --> 00:32:46.633
check out the talk for in 
details.

00:32:47.702 --> 00:32:49.702
&gt;&gt; MALTE UBL:  It's really 
excited with the next topic.

00:32:52.602 --> 00:32:54.451
Who has put it and found out it 
doesn't work the same way with 

00:32:54.452 --> 00:32:59.559
other browser.  Like 50 years 
ago we developed for IE and it 

00:32:59.560 --> 00:33:01.560
didn't work in Firefox.

00:33:04.267 --> 00:33:05.887
The browsing exainlts have not 
changed.  There is light at the 

00:33:05.888 --> 00:33:07.888
end of the channel.

00:33:10.593 --> 00:33:12.629
In your own project do you have 
unitest?  Do you feel bad about 

00:33:12.630 --> 00:33:16.701
it?  The web never had anything 
about that.  Web standards are 

00:33:16.702 --> 00:33:19.416
finally a thing.  Automated 
tests are shared amongst 

00:33:21.872 --> 00:33:24.337
browsers to develop 
implementations to make sure 

00:33:24.338 --> 00:33:26.338
that when service organize 

00:33:28.010 --> 00:33:30.010
comes out you have new 
capabilities.

00:33:31.275 --> 00:33:33.275
Browsers are becoming compatible
and 

00:33:34.551 --> 00:33:35.775
we want to thank the countless 
volunteers helping with 

00:33:35.776 --> 00:33:37.776
compatibility.

00:33:39.786 --> 00:33:41.776
As you can see in the chart, 
only one browser is going down 

00:33:41.777 --> 00:33:45.023
over time but all  features of 
the engine are going up.  There 

00:33:45.024 --> 00:33:48.934
is a lot of work to do.  We are 
excited that things are going on

00:33:48.935 --> 00:33:50.162
the right track.
   &gt;&gt; BEN GALBRAITH:  Going to 

00:33:50.163 --> 00:33:54.446
shift gears now and move on from
the Web Platform to the tools,  

00:33:54.447 --> 00:33:58.321
libraries and frameworks that we
are working on here at Google to

00:33:58.322 --> 00:34:00.559
make web development more 
productive.  Let's get started 

00:34:00.560 --> 00:34:04.829
with the tool that we ship to 
every Chrome user worldwide.  

00:34:04.830 --> 00:34:07.487
Chrome's own dev tools.  
Millions of developers use this 

00:34:07.488 --> 00:34:10.336
every single day and it keeps 
getting better and better.

00:34:12.634 --> 00:34:15.491
Please welcome Paul Irish, here 
to give us a taste of what is 

00:34:15.492 --> 00:34:17.492
now this year.
   (Applause.

00:34:19.920 --> 00:34:21.920
) &gt;&gt;&gt;

00:34:23.089 --> 00:34:25.089
PAUL IRISH:  Thank you, Ben.  
All right.

00:34:26.780 --> 00:34:31.898
So it's 2018, right?  The world 
is  asynchronous.  When we are 

00:34:31.899 --> 00:34:36.192
debugging, we can't necessarily 
step through code line-by-line. 

00:34:36.193 --> 00:34:38.866
We have timers and promises and 
network activities to contend 

00:34:38.867 --> 00:34:40.867
with.
   So the Chrome dev tools have 

00:34:44.155 --> 00:34:48.440
transformed to adapt to this new
asynchronous world as well.  Let

00:34:48.441 --> 00:34:50.441
me show what it was like a year 
ago.

00:34:51.711 --> 00:34:53.338
We have this little function, 
time out with console log within

00:34:53.339 --> 00:34:57.625
it.  And we'll just take a look 
at what happened.  So this is 

00:34:57.626 --> 00:35:00.279
Chrome from a year ago.  I want 
to step into the console, into 

00:35:02.727 --> 00:35:05.603
the set time out to pause in the
console log.  When I hit step 

00:35:05.604 --> 00:35:07.677
into, we step past it.  It is 
not really what you want.

00:35:10.539 --> 00:35:13.392
In today's Chrome, we have the 
same code.  We step in and jump 

00:35:13.393 --> 00:35:18.101
into the invocation in the set 
time out.  Now we are paused 

00:35:18.102 --> 00:35:21.800
right on that log method point.
   So this is what we expect 

00:35:21.801 --> 00:35:23.801
when we hit set time out, right?

00:35:26.082 --> 00:35:28.733
Set time out, like stepping,  
debugging, this should match our

00:35:31.193 --> 00:35:34.436
expectations of being in the 
asynchronous world.  I showed 

00:35:34.437 --> 00:35:37.089
this with time out but you can 
expect the same kind of 

00:35:37.090 --> 00:35:39.330
debugging upgrades when you work
with Web Platform 

00:35:42.376 --> 00:35:44.376
features like post message, web 
workers, and more.

00:35:46.857 --> 00:35:48.857
So speaking of features, Web 
Platform evolves quickly, right?

00:35:52.200 --> 00:35:54.462
Now, a as it evolves we as 
developers have to feel 

00:35:54.463 --> 00:35:57.378
comfortable with the new APIs, 
new objects and how our code 

00:35:57.580 --> 00:35:59.580
interacts.

00:36:00.684 --> 00:36:02.684
The console has been our home 
base for that  exploration.

00:36:04.995 --> 00:36:06.995
So I'm excited to share with you
a 

00:36:08.276 --> 00:36:10.102
brand new dev tools feature that
I think  revolutionizes how we 

00:36:10.103 --> 00:36:13.362
interact with the console.  We 
call it Eager Eval.

00:36:16.625 --> 00:36:18.684
The best way to explain it is 
with a demo.  Let's do that.

00:36:20.514 --> 00:36:23.785
Switch over to my machine here. 
Okay.  So we have this little 

00:36:23.786 --> 00:36:27.290
code right here, a regular 
expression we are going to call 

00:36:27.291 --> 00:36:29.744
exec on it.  We have a string.  
Let me finish off this string.

00:36:30.556 --> 00:36:33.806
   All right.  Now, as I finish 
off everything, watch this.

00:36:37.075 --> 00:36:39.101
Now, I didn't hit enter yet, but
I'm already getting the results 

00:36:39.102 --> 00:36:42.558
of this evaluation.  The cool 
thing is, we are going to update

00:36:42.559 --> 00:36:44.559
this as we type.  So let me go 
over here.

00:36:47.879 --> 00:36:50.540
Will this even work if I change 
this to using parens around -- 

00:36:50.541 --> 00:36:53.853
no.  All right.  So the regular 
expression is a little brittle.

00:36:56.938 --> 00:36:58.938
I'll admit it, okay.

00:37:01.424 --> 00:37:03.471
But I do see, okay the zero to 9
range.  We could actually 

00:37:03.472 --> 00:37:05.472
improve this.  Actually, all 
three of them.

00:37:08.004 --> 00:37:10.656
Let's select all three and 
replace it with slash D and 

00:37:10.657 --> 00:37:12.697
yeah, okay, looks like we are 
still pulling out the same 

00:37:12.698 --> 00:37:16.186
stuff.  So that's good.
   The other thing I wanted to 

00:37:16.187 --> 00:37:19.664
do, I wanted to pull the area 
code out of this phone number 

00:37:19.665 --> 00:37:21.665
right here.

00:37:22.959 --> 00:37:24.976
While we have the multiple 
cursors, let's go ahead and add 

00:37:24.977 --> 00:37:28.260
capture groups to the regular 
expression.  All right!  Boom, 

00:37:28.261 --> 00:37:33.582
boom, boom.  Capture, capture, 
capture.  Area code is 1.  All 

00:37:33.583 --> 00:37:35.583
right.  Sweet.

00:37:37.042 --> 00:37:39.490
In a few short moments we 
explored and API, found a bug, 

00:37:39.491 --> 00:37:42.732
made improvement and got the 
result we were looking for.  

00:37:42.733 --> 00:37:44.394
Pretty awesome.
   Let's switch back to the 

00:37:44.395 --> 00:37:46.395
slides.

00:37:49.353 --> 00:37:51.353
So really, that demo was just a 
taste.

00:37:52.438 --> 00:37:54.438
Eager Eval enables you to work 
with 

00:37:57.937 --> 00:38:00.434
all sorts of Javascript 
language, and the power thing 

00:38:00.435 --> 00:38:04.734
about it is that you can gernt 
there will be no side  effects. 

00:38:04.735 --> 00:38:06.735
The way that we enable this is 
we 

00:38:08.011 --> 00:38:10.071
introduce a new mode in V8 where
we attempt to evaluate 

00:38:10.072 --> 00:38:12.072
Javascripts.

00:38:14.401 --> 00:38:16.401
If its about to cause aside 
effect we just bail.

00:38:17.692 --> 00:38:20.148
Speaking of V8 we have been 
working heart to bring the same 

00:38:20.149 --> 00:38:24.820
dev tools experience from the 
back end -- sorry, from the 

00:38:24.821 --> 00:38:26.821
front end to the back end by 

00:38:29.969 --> 00:38:31.969
making it a good tool for 
NodeJS.

00:38:33.850 --> 00:38:35.521
You can use the same tool set on
the server that you normally do 

00:38:35.522 --> 00:38:37.350
on the client.
   We have covered a lot of 

00:38:37.351 --> 00:38:40.207
ground on this.  If you would 
like to see more, check 

00:38:43.880 --> 00:38:45.880
out the dev tools talk where we 
will be diving deeper into this.

00:38:47.164 --> 00:38:48.992
Thank you guys very much.
   (Applause.)

00:38:48.993 --> 00:38:51.256
&gt;&gt; BEN GALBRAITH:  Thanks, Paul.
So if you didn't notice on the 

00:38:51.257 --> 00:38:55.322
slide, Paul's session starts 
bright and early tomorrow, but 

00:38:55.323 --> 00:38:57.989
it's worth the effort to get an 
early start.  I encourage you to

00:38:57.990 --> 00:39:00.642
attend.
   Okay.  I want to talk about 

00:39:00.643 --> 00:39:03.297
another feature called 
Lighthouse.  This gives you 

00:39:03.298 --> 00:39:05.298
clear guidance on how the 
website can be improved and 

00:39:06.795 --> 00:39:08.233
categories such as performance, 
accessibility, capabilities and 

00:39:08.234 --> 00:39:10.479
more.
   People are actually using 

00:39:10.480 --> 00:39:12.480
this.

00:39:13.548 --> 00:39:16.063
So far this year over 500,000 
developers have used it to 

00:39:16.064 --> 00:39:18.064
analyze over 2 million pages.

00:39:20.300 --> 00:39:21.716
So we are working hard to make 
Lighthouse better.  This year we

00:39:21.717 --> 00:39:23.717
are launching a new version 3.

00:39:26.003 --> 00:39:28.258
0 with refined UI and higher 
quality insights and announcing 

00:39:28.259 --> 00:39:32.554
new Lighthouse API to bring 
insights into the workflow and 

00:39:32.555 --> 00:39:34.833
enable integration with other 
tools and platforms.

00:39:37.388 --> 00:39:39.640
Lighthouse generates insights 
but in the real world there are 

00:39:39.641 --> 00:39:43.140
variables that influence how 
your site performs like variable

00:39:43.141 --> 00:39:44.352
network conditions or the 
different devices that people 

00:39:44.353 --> 00:39:48.430
are using.  So late last year we
launched the Chrome user 

00:39:48.431 --> 00:39:52.917
experience report to help with 
this.  It contains real world 

00:39:52.918 --> 00:39:57.431
performance data showing how 
Chrome users are experiencing 

00:39:57.432 --> 00:39:59.432
over 4 million global  domains.

00:40:03.250 --> 00:40:05.259
You can analyze the data set 
yourself using the free big 

00:40:05.260 --> 00:40:08.253
query tool.  We also integrated 
it into the page 

00:40:11.285 --> 00:40:12.304
feed insights tool, the easiest 
way to see this data.  You can 

00:40:12.305 --> 00:40:14.777
compare yourself to your 
competitors which can be very 

00:40:14.778 --> 00:40:17.849
motivating.
   Okay.  So we also introduced 

00:40:17.850 --> 00:40:22.137
the Puppeteer open source 
project last year.  This is a 

00:40:22.138 --> 00:40:24.832
NodeJS library for controlling 
the headless Chrome.

00:40:28.559 --> 00:40:30.559
It gives you access to rendering
engine and dev tools.

00:40:33.244 --> 00:40:35.244
This project is on fire with 3 
million 

00:40:37.677 --> 00:40:40.996
installs and used by 600MPM 
projects.  You never know about 

00:40:40.997 --> 00:40:42.997
these things.

00:40:44.274 --> 00:40:46.274
Most important of all it has 
30,000 GitHub  stars.

00:40:46.508 --> 00:40:48.508
&gt;&gt; MALTE UBL:  That is the most 
important.

00:40:48.566 --> 00:40:52.672
&gt;&gt; BEN GALBRAITH:  It may be.  
It went 1.0 in January and opens

00:40:52.673 --> 00:40:54.673
up a bunch of 

00:40:56.550 --> 00:40:57.984
interesting use cases to 
integrate Chrome into your 

00:40:57.985 --> 00:41:00.418
workflow.
   We are releasing a new 

00:41:00.419 --> 00:41:04.298
Workbox library.  This makes 
common worker service scenarios 

00:41:04.299 --> 00:41:06.340
significantly easier.  With it 
you can transform code like 

00:41:10.238 --> 00:41:12.238
this, about creating cache files
into this.

00:41:13.097 --> 00:41:15.967
&gt;&gt; MALTE UBL:  I think Workbox 
is the most under utilized 

00:41:15.968 --> 00:41:18.007
library in user.  I recommend 
that you start with workloads.

00:41:21.470 --> 00:41:23.470
It is incredibly easy instead of
rolling your own.

00:41:23.534 --> 00:41:25.534
&gt;&gt; BEN GALBRAITH:  Okay.

00:41:26.594 --> 00:41:29.461
If done poorly, sign up and sign
in can be a big friction point 

00:41:29.462 --> 00:41:31.462
for users.

00:41:32.519 --> 00:41:34.586
One-tap sign up and auto sign in
library currently in early 

00:41:34.587 --> 00:41:36.587
access can drive really big 
impact.

00:41:37.471 --> 00:41:40.100
&gt;&gt; MALTE UBL:  What is the name?
   &gt;&gt; BEN GALBRAITH:  Name is is

00:41:40.101 --> 00:41:43.570
one of the hardest problems in 
computer science.  That is the 

00:41:43.571 --> 00:41:45.571
name.

00:41:46.850 --> 00:41:50.124
This library controls a one-tap 
sign in experience.  No typing, 

00:41:50.125 --> 00:41:53.978
no identity provider to remember
and no password to create.  When

00:41:53.979 --> 00:41:58.715
users return to your site they 
can sign back in really easily. 

00:41:58.716 --> 00:42:00.380
It works by drafting off of the 
existing sign in that the user 

00:42:00.381 --> 00:42:05.501
has to the device with the 
Google property like Gmail.  It 

00:42:05.502 --> 00:42:07.502
is based on the credential 
manager web standard.

00:42:08.551 --> 00:42:10.393
There are a few examples I want 
to share here, where the 

00:42:10.394 --> 00:42:14.286
benefits come in.  First ret 
PHIN a real estate company here 

00:42:14.287 --> 00:42:19.383
in the U.S. saw 80 percent 
increase in sign ups after 

00:42:19.384 --> 00:42:21.384
implementing the one-tap library

00:42:25.309 --> 00:42:27.309
and Trevago, one of the leading 
hotel 

00:42:30.984 --> 00:42:33.193
companies, saw 200 percent 
increase in reservations after 

00:42:33.194 --> 00:42:37.644
using this.  Payments is another
way where ops can go a long way 

00:42:37.645 --> 00:42:40.092
and we recently made Google Pay 
available on the web.

00:42:41.738 --> 00:42:42.966
&gt;&gt; MALTE UBL:  That's a good 
name.

00:42:42.967 --> 00:42:44.967
&gt;&gt; BEN GALBRAITH:  Took us 
awhile to get there.

00:42:47.284 --> 00:42:49.360
You can accept users from 
payments payments from users who

00:42:49.361 --> 00:42:51.361
have saved their information on 
the Google account.

00:42:54.272 --> 00:42:56.272
It is available to anywhere  
people.

00:42:58.790 --> 00:43:01.259
Platforms like smopify allow you
to buy with a single click.

00:43:04.143 --> 00:43:06.352
This lets -- web components.  
You can now use primitives that 

00:43:06.353 --> 00:43:10.452
are baked into the Web Platform 
itself.  It has only been in the

00:43:10.453 --> 00:43:12.453
past few 

00:43:14.137 --> 00:43:16.806
months that web components have 
major support and there are 

00:43:16.807 --> 00:43:18.807
polyfills to reach all of them.

00:43:21.089 --> 00:43:22.720
They give you a nice reusable 
chunk of code that you can pass 

00:43:22.721 --> 00:43:27.200
around and create them with just
about every major framework.  We

00:43:27.201 --> 00:43:29.658
created a website called custom 
elements everywhere with up to 

00:43:29.659 --> 00:43:31.924
date compatibility information 
on.

00:43:36.236 --> 00:43:38.236
In preact, view and many others 
are 

00:43:40.130 --> 00:43:42.130
entirely -- and angular elements

00:43:44.004 --> 00:43:46.031
released angular elements to use
exen components within an 

00:43:46.032 --> 00:43:48.032
angular app.

00:43:50.536 --> 00:43:52.536
Speaking of web components we 
created 

00:43:53.836 --> 00:43:56.680
polymer to help your team 
achieve reuse or custom didn'ts 

00:43:56.681 --> 00:44:01.386
or other develops.  This week 
the team is releasing the next 

00:44:01.387 --> 00:44:03.387
major version, 3.

00:44:04.639 --> 00:44:06.639
0 which adds  MPM and model 
you'lls so 

00:44:07.718 --> 00:44:09.718
it works seam llsly.

00:44:11.170 --> 00:44:13.170
It is unveiling a few cutting 
edge 

00:44:15.990 --> 00:44:18.871
products here at I/O that have 
fast loading web apps.  One is 

00:44:18.872 --> 00:44:20.872
lit HTML.

00:44:24.325 --> 00:44:26.325
A 3D -- this has the latest 
females 

00:44:28.186 --> 00:44:30.453
that enables a web app to froal 
which gives a snappy fients 

00:44:30.454 --> 00:44:32.454
face.

00:44:34.361 --> 00:44:36.361
Using the library you can create

00:44:39.035 --> 00:44:41.035
library components that work 
alongside some of your elements.

00:44:42.743 --> 00:44:45.631
It is leveraging the Web 
Platform to make the apps more 

00:44:45.632 --> 00:44:48.069
efficient and developing easier.
   &gt;&gt; MALTE UBL:  You just went 

00:44:48.070 --> 00:44:50.070
through a lot of stuff which 
actually brings me 

00:44:52.947 --> 00:44:54.604
to the next topic, talking to 
developers, one message comes up

00:44:54.605 --> 00:44:56.605
over and over again.

00:44:58.913 --> 00:45:00.913
Hey, Chrome team you push all 
these 

00:45:02.436 --> 00:45:04.872
new features at I/O, but frankly
it is a bit overwhelming and we 

00:45:04.873 --> 00:45:08.141
are lost on what to do.  
Obviously there may not be many 

00:45:08.142 --> 00:45:10.142
of you here.

00:45:12.224 --> 00:45:14.494
This is great for experts who 
like to dive deep on  topics, 

00:45:14.495 --> 00:45:16.495
but not everybody 

00:45:17.558 --> 00:45:19.807
is like that and not every 
company can afford to be up to 

00:45:19.808 --> 00:45:21.808
date with the best practices.

00:45:23.706 --> 00:45:25.706
You start out with a expert 
team, 

00:45:26.780 --> 00:45:28.780
people with less context, it's 
important 

00:45:31.459 --> 00:45:34.936
for your web app to remain 
stable as you age.  You must 

00:45:34.937 --> 00:45:37.170
bring these folks along as well 
and allow them to create great 

00:45:37.783 --> 00:45:39.783
experiences.

00:45:41.088 --> 00:45:45.192
That's where the project I work 
on, AMP, comes in.  This is a 

00:45:45.193 --> 00:45:47.193
web component library for 

00:45:49.476 --> 00:45:51.476
building reliably fast websites.

00:45:53.600 --> 00:45:55.600
Using brass and ought 98ed 
guidance to 

00:45:57.005 --> 00:45:59.005
success, map deploys great user 

00:46:00.274 --> 00:46:02.274
experience and incredible skill 
scale.

00:46:06.402 --> 00:46:09.076
There are 6 billion AMP pages 
and they continue to load well 

00:46:09.077 --> 00:46:11.944
under one second measure from 
Google search under the median.

00:46:15.248 --> 00:46:17.248
This translates into business 
success.

00:46:19.170 --> 00:46:21.170
30 percent increase on their  
AMP.

00:46:23.119 --> 00:46:25.119
Shop clues, 20 percent, Chinese 
new 

00:46:27.379 --> 00:46:28.825
site saw 2X increase in time on 
site and 40 percent decrease in 

00:46:28.826 --> 00:46:30.826
bounce rate.

00:46:32.286 --> 00:46:34.770
Talk about AMP and eCommerce, 
Ali Express went all in on AMP.

00:46:38.463 --> 00:46:41.359
They went for many of their 
pages and back end to turn it 

00:46:41.360 --> 00:46:43.642
into a progressive web app and 
they have seen great  results.

00:46:47.333 --> 00:46:50.397
AMP is sometimes seen as 
specific to Google search.  This

00:46:50.398 --> 00:46:52.398
is a metric that filters out 

00:46:54.068 --> 00:46:55.692
graphic from Google search and 
saw 31 percent increase in 

00:46:55.693 --> 00:46:57.693
search rate.

00:47:01.260 --> 00:47:03.260
They have been using it succeed 
30 in ads as well.

00:47:04.487 --> 00:47:06.487
If you are making AMP ages, take
them to your AdWords account.

00:47:09.400 --> 00:47:11.855
As we mentioned earlier, we are 
focusing on great experiences on

00:47:11.856 --> 00:47:16.201
the web.  AMP stories is such a 
project because constant 

00:47:16.202 --> 00:47:18.202
consumption on mobile is 
changing.

00:47:21.298 --> 00:47:23.365
Life size full screen projects 
are becoming more popular every 

00:47:23.366 --> 00:47:28.714
day.  This development happens 
exclusively in native apps.  The

00:47:28.715 --> 00:47:31.969
web is literally the best 
platform to build these.  It has

00:47:31.970 --> 00:47:33.970
all the capabilities needed to 
create content but the technical

00:47:36.248 --> 00:47:39.103
investment that each single 
publisher would have to make to 

00:47:39.104 --> 00:47:41.958
implement them is  prohibitive. 
They are drawn to walled gardens

00:47:41.959 --> 00:47:43.998
that make things easy 
end-to-end.

00:47:48.479 --> 00:47:50.318
With AMP stories, they capture 
story telling they are able to 

00:47:50.319 --> 00:47:53.156
publish on their website with 
minimal technical  investments.

00:47:56.668 --> 00:47:58.668
Instead of components with web, 
they 

00:48:00.741 --> 00:48:03.805
have support with vertical 
video, and interaction.  They 

00:48:03.806 --> 00:48:05.848
are designed for mobile but work
great on desktop.

00:48:07.477 --> 00:48:09.477
AMP stories is a radical shift.

00:48:10.953 --> 00:48:14.636
We are progressively enhancing 
the plain old web page.  We are 

00:48:14.637 --> 00:48:16.699
working on best in class 
features using web components 

00:48:16.700 --> 00:48:19.558
that can be added to a document 
with minimal froiment.

00:48:24.244 --> 00:48:26.086
This is' merse sieve light boxes
and VAOs that stay on the screen

00:48:26.087 --> 00:48:28.087
as you scroll.

00:48:29.953 --> 00:48:32.606
The goal, to summarize and get 
to add as many web pages as 

00:48:32.607 --> 00:48:34.607
possible, 

00:48:36.502 --> 00:48:38.502
continuing to meet user 
expectations.

00:48:40.174 --> 00:48:42.217
This can be summarizing as a lot
of exciting thing but I wanted 

00:48:42.218 --> 00:48:48.746
to touch on a different example.
AMP is for everyone.  It comes 

00:48:48.747 --> 00:48:50.747
with limitations which is not 

00:48:51.997 --> 00:48:53.997
the right, being opinion eight 
the means 

00:48:55.505 --> 00:48:58.152
some people have different 
opinion.  Some people say I 

00:48:58.153 --> 00:49:03.114
don't want to use AMP.  That is 
what the web is all about and we

00:49:03.115 --> 00:49:05.115
are committed to making it 
happen.

00:49:07.413 --> 00:49:09.413
Look at the core features that 
AMP brought.

00:49:10.668 --> 00:49:12.503
Instant loading, seamless 
integration.  The first two 

00:49:12.504 --> 00:49:14.504
explain themselves.

00:49:15.751 --> 00:49:19.270
We talk about the next one, 
seamless navigation later.  

00:49:19.271 --> 00:49:21.271
Google search provides the same 

00:49:22.881 --> 00:49:25.111
innovative experience for AMP 
today for all users to implement

00:49:25.112 --> 00:49:27.112
a new set of standards.

00:49:28.184 --> 00:49:30.472
If you don't want to use it, 
super  cool.  Let's take a look 

00:49:30.473 --> 00:49:32.473
at some of the 

00:49:34.141 --> 00:49:36.141
factors that show the AMP 
experience.

00:49:37.202 --> 00:49:39.202
As I mentioned, AMP pages load 
in well 

00:49:40.665 --> 00:49:42.665
under one second with the Chrome
users 

00:49:44.786 --> 00:49:46.786
saying there is fast web page 
load.

00:49:49.465 --> 00:49:51.465
Pages meet or exceed the 
standards.

00:49:52.530 --> 00:49:55.169
Web page loads super quickly but
is not interactive because 

00:49:55.170 --> 00:50:00.269
Javascript blocks the thread.  
Not a good user experience.  We 

00:50:00.270 --> 00:50:02.712
have metrics that give you a 
holistic experience like the 

00:50:02.713 --> 00:50:05.209
user has when they visit a page.

00:50:08.775 --> 00:50:10.760
Another feature is privacy 
preserving loading.  With he 

00:50:10.761 --> 00:50:14.286
want to explain.  To achieve 
instant loading download the 

00:50:14.287 --> 00:50:16.549
resource before the user clicks.
Otherwise it will be in the way 

00:50:16.550 --> 00:50:18.580
and things won't be instant, 
especially in mobile.

00:50:23.891 --> 00:50:25.891
With, we built methods for this.

00:50:27.352 --> 00:50:29.352
In pre-fetching it is not what 
the 

00:50:30.853 --> 00:50:32.853
user expects in terms of 
privacy.

00:50:34.313 --> 00:50:36.574
There is a cookie that sends you
an ad based on that although you

00:50:36.575 --> 00:50:41.499
never ended up going to the 
page.  AMP does not have this 

00:50:41.500 --> 00:50:43.500
problem.

00:50:44.553 --> 00:50:45.588
We want to bring the privacy 
friendly features to the wider 

00:50:45.589 --> 00:50:47.589
web.

00:50:49.048 --> 00:50:51.686
That's where the web packaging 
comes in.  It allows you to 

00:50:51.687 --> 00:50:53.687
bundle up the web 

00:50:55.947 --> 00:51:02.834
content and allow other parties 
to keep the ... https.  Faster 

00:51:02.835 --> 00:51:04.994
Javascript loading can form the 
missing primitive behind a more 

00:51:06.007 --> 00:51:08.007
decentralized web.

00:51:09.313 --> 00:51:11.366
It allows for instant loading 
for all content in the web for 

00:51:11.367 --> 00:51:13.367
packages.

00:51:16.696 --> 00:51:18.327
It has one AMP specific, there 
are all these things that we 

00:51:18.328 --> 00:51:20.553
don't like.  We couldn't be more
excited.

00:51:23.443 --> 00:51:25.270
Okay, I talk about how this 
standard is brand new but we 

00:51:25.271 --> 00:51:27.981
actually implement it in Chrome.
You can try it behind the flag 

00:51:27.982 --> 00:51:29.982
today.

00:51:32.248 --> 00:51:34.248
My team is open source tool, the

00:51:35.317 --> 00:51:37.317
Google team built a tool that 
works with the packages.

00:51:39.797 --> 00:51:41.797
And other companies make web 
packages for the content.

00:51:45.541 --> 00:51:47.541
To give this an impression of 
how this all works together.

00:51:50.917 --> 00:51:51.119
Please welcome Ludo from 
Pinterest.

00:51:51.120 --> 00:51:53.385
&gt;&gt; LUDO ANTONOV:  Thank you.  
Our focus is to help people 

00:51:53.386 --> 00:51:57.486
around the world discover and do
the things they love.  We wanted

00:51:57.487 --> 00:51:59.487
to create a seamless experience 
on the mobile web that puts 

00:52:02.194 --> 00:52:04.437
the right content in front of 
our users enabling them to take 

00:52:04.438 --> 00:52:06.438
advantage of 

00:52:07.509 --> 00:52:09.743
discovering content and browsing
without slow load times or have 

00:52:09.744 --> 00:52:13.002
it flow direct to the app.  This
is why we are excited to show 

00:52:13.003 --> 00:52:15.003
how 

00:52:17.526 --> 00:52:18.547
we are using AMP, PWA and 
packaging today in the product.

00:52:18.548 --> 00:52:21.615
   Start with a simple search 
and switch to the demo.

00:52:23.667 --> 00:52:25.714
So I have a five-year-old at 
home.  She loves to make things.

00:52:28.162 --> 00:52:30.162
And so I'm looking for some 
spring craft ideas for her.

00:52:32.793 --> 00:52:35.239
So here you will see that when I
click on the AMP page it loads 

00:52:35.240 --> 00:52:37.240
really fast.

00:52:38.538 --> 00:52:40.586
Even though we are on an AMP 
page you notice that the URL 

00:52:40.587 --> 00:52:43.259
says Pinterest.com.  This is 
made possible by the web 

00:52:46.509 --> 00:52:48.324
packaging technology that 
enables us to publish content 

00:52:48.325 --> 00:52:52.246
that can be served directly from
the Google cache.  It is a big 

00:52:52.247 --> 00:52:54.247
win for the privacy of our 

00:52:55.378 --> 00:52:57.007
users as all of their actions 
are now contained within the 

00:52:57.008 --> 00:52:59.008
Pinterest.com origin.

00:53:01.263 --> 00:53:03.263
From here you will see that when
I 

00:53:07.024 --> 00:53:09.918
click on this I was seamlessly 
teen the app.  I can take 

00:53:09.919 --> 00:53:13.372
further action like save this to
my work ... oops.

00:53:18.692 --> 00:53:20.692
But more importantly also once 
I'm on 

00:53:22.167 --> 00:53:24.806
our PWA app, then I can add 
Pinterest to the home screen and

00:53:24.807 --> 00:53:26.807
from there show all 

00:53:29.106 --> 00:53:31.985
the cool ideas that I have 
collected for my daughter so 

00:53:31.986 --> 00:53:33.986
that we can do them together.

00:53:36.864 --> 00:53:39.124
So at Pinterest we are committed
to making world class experience

00:53:39.125 --> 00:53:41.125
for our yours users.

00:53:44.856 --> 00:53:46.687
We were the first platform to 
scale and working with AMP and 

00:53:46.688 --> 00:53:49.131
we have been able to shave 70 
percent of load times 

00:53:52.856 --> 00:53:54.856
per our users over billions of 
pages and millions of users.

00:53:56.410 --> 00:53:58.250
This is in a nutshell how our 
mobile web experience is 

00:53:58.251 --> 00:54:00.251
evolving to help 

00:54:01.320 --> 00:54:03.320
people around the world find 
insure 

00:54:04.334 --> 00:54:06.334
sphraition

00:54:08.086 --> 00:54:10.530
to find inspiration.
   (Applause.).

00:54:12.169 --> 00:54:14.169
&gt;&gt; MALTE UBL:  We allow package 
loading of web fault.

00:54:17.085 --> 00:54:19.143
As a I said earlier, the 
standard is fill being finalized

00:54:19.144 --> 00:54:21.144
and not ready to ship.

00:54:22.402 --> 00:54:24.676
We expect significant changes 
due to input from other  

00:54:24.677 --> 00:54:27.349
browsers and users.  We are 
building the infrastructure for 

00:54:29.189 --> 00:54:31.697
you to make packages.  Stay  
tuned for other announcements 

00:54:33.321 --> 00:54:35.821
this year.
   Summarizing, across the 

00:54:35.822 --> 00:54:39.494
global we are seeing amazing 
success as a result of the PWAs 

00:54:39.495 --> 00:54:41.495
in their websites.

00:54:42.549 --> 00:54:44.549
If you have a AMP page check out
the 

00:54:45.838 --> 00:54:49.330
new components super easily 
enhance the user  experience.  

00:54:49.331 --> 00:54:51.331
If you love to benefit from 
Google's 

00:54:52.858 --> 00:54:54.858
expertise to create web apps, 
through 

00:54:56.743 --> 00:54:58.587
willing toes like, bring AMP's 
reliable user experience to the 

00:54:58.588 --> 00:55:00.855
wider web.
   &gt;&gt; BEN GALBRAITH:  It is 

00:55:00.856 --> 00:55:04.357
great to see what is happening 
with AMP.  Throughout this talk 

00:55:04.358 --> 00:55:07.441
we have highlighted examples 
where the web connects users 

00:55:07.442 --> 00:55:09.675
right to content.  Without any 
installation steps.

00:55:13.124 --> 00:55:15.124
We see this low friction model 
of web 

00:55:16.414 --> 00:55:18.414
links as being akin to the super
power of the platform.

00:55:20.113 --> 00:55:22.366
As Malte mentioned web packaging
is an exciting emerging standard

00:55:22.367 --> 00:55:24.367
for a bunch of reasons.

00:55:26.047 --> 00:55:28.096
I'm glad that AMP is able to use
it to solve your issues but 

00:55:28.097 --> 00:55:30.097
there is a bigger opportunity 
here.

00:55:32.624 --> 00:55:34.879
For web packaging to help lean 
into the super power and go from

00:55:34.880 --> 00:55:39.359
fast load types to no load times
whatsoever and do it for the 

00:55:39.360 --> 00:55:43.257
entire platform, not just AMP.
   So what would this kind of 

00:55:43.258 --> 00:55:47.961
truly instant friction free 
experience look like?  We would 

00:55:47.962 --> 00:55:49.962
like to show you a prototype.

00:55:51.884 --> 00:55:56.152
   Mall malt here is a demo that
the Google imagine team is 

00:55:56.153 --> 00:55:59.820
exploring.  You are looking 
through storage and you click 

00:55:59.821 --> 00:56:01.821
one of the results, right?

00:56:03.073 --> 00:56:05.327
You go to enlarge the image, 
makes sense.  How do you go to 

00:56:05.328 --> 00:56:07.976
the web page where the image 
came from.  Today you have to 

00:56:07.977 --> 00:56:10.857
click a little button.  You 
might do that but also might not

00:56:11.283 --> 00:56:14.340
do that.  What if instead you 
could scroll to the page 

00:56:14.341 --> 00:56:17.406
instead?
   We think that with this 

00:56:17.407 --> 00:56:22.896
experience there will be 
significant higher number of 

00:56:22.897 --> 00:56:25.754
people actually move to the next
wage page which will be amazing 

00:56:25.755 --> 00:56:29.219
for publishing content and user 
experience as well.  This is one

00:56:29.220 --> 00:56:31.220
example.

00:56:35.152 --> 00:56:37.152
We are super excited to make the
web 

00:56:39.076 --> 00:56:41.076
the most seamless and 
frictionless experience.

00:56:41.335 --> 00:56:43.335
&gt;&gt; BEN GALBRAITH:  We are 
running out of time.

00:56:45.216 --> 00:56:46.633
The web presents a compelling 
fantastic business opportunity 

00:56:46.634 --> 00:56:51.529
for all of us.  Use our insight 
tools like Lighthouse to 

00:56:51.530 --> 00:56:53.160
understand where your site is 
falling short where you have 

00:56:53.161 --> 00:56:55.628
opportunity to get better and 
upgrade your site using the 

00:56:57.688 --> 00:57:01.376
latest Web Platform features.
   &gt;&gt; MALTE UBL:  Use AMP to 

00:57:01.377 --> 00:57:06.087
create rich content and commerce
experience and get consistently 

00:57:06.088 --> 00:57:07.724
high quality results.
   &gt;&gt; BEN GALBRAITH:  Use other 

00:57:07.725 --> 00:57:09.725
library 

00:57:12.454 --> 00:57:17.366
areas like framework, polymer 
and angular.  And join us this 

00:57:17.367 --> 00:57:21.037
November at the Chrome dev 
summit in San Francisco where we

00:57:21.038 --> 00:57:23.294
will gather as a community to 
talk more about the path forward

00:57:23.295 --> 00:57:27.367
for the web.  Sign up at this 
URL for more information and we 

00:57:27.368 --> 00:57:29.819
hope to see you there.  Finally,
thank you for attending the talk

00:57:29.820 --> 00:57:33.489
today.  We hope you enjoyed it. 
Thank you.

00:57:33.490 --> 00:57:35.490
(Applause.

00:57:36.506 --> 00:57:38.506
)

00:57:39.637 --> 00:57:41.637
   (Standing by.)

00:57:45.147 --> 00:57:47.147
   &gt;&gt; ANNOUNCER:  Thank you for 
joining this session.

00:57:56.173 --> 00:57:57.802
Brand ambassadors will help you 
find your place to the next 

00:57:57.803 --> 00:57:59.803
session.

00:58:03.140 --> 00:58:05.404
If you are registered for the 
next session in this room, we 

00:58:05.405 --> 00:58:07.405
ask you to 

00:58:10.075 --> 00:58:12.075
clear the room and join the line
outside.

00:58:14.917 --> 00:58:16.917
)

01:00:17.527 --> 01:00:19.527
   (Please stand by.

01:00:23.461 --> 01:00:26.223
The Stage 2 session Lessons from
Spectre and Meltdown, and How 

01:00:26.224 --> 01:00:28.224
the Whole Web is 

01:00:29.329 --> 01:00:31.329
Getting Safer will begin at the 
top of the hour.

01:00:32.733 --> 01:00:34.733
)

01:05:46.816 --> 01:05:48.816
)

01:06:08.876 --> 01:06:10.876
(

01:06:13.466 --> 01:06:17.599
The Stage 2 session Lessons from
Spectre and Meltdown, and How 

01:06:13.466 --> 01:06:15.466
the Whole Web is 

01:06:19.135 --> 01:06:22.671
Getting Safer will begin in 
approximately 15 minutes.  

01:06:22.672 --> 01:06:24.672
Please continue to stand by.

01:06:25.674 --> 01:06:27.674
)

01:10:17.205 --> 01:10:19.205
)

01:12:36.998 --> 01:12:39.943
(GOOGLE I/O 2018 session on 
Stage 2, Lessons from Spectre 

01:12:39.944 --> 01:12:44.081
and Meltdown, and How the Whole 
Web is Getting Safer, will begin

01:12:44.082 --> 01:12:46.082
in approximately seven minutes.

01:12:47.086 --> 01:12:49.086
)

01:15:14.008 --> 01:15:16.008
)

01:17:33.556 --> 01:17:36.058
   &gt;&gt; ANNOUNCER:  At this time 
please find your seat.

01:17:39.184 --> 01:17:41.184
Our session will begin soon.
   (Music playing.

01:17:42.412 --> 01:17:44.412
)

01:19:25.293 --> 01:19:27.293
   &gt;&gt; ANNOUNCER:  Welcome.  
Thank you for joining.

01:19:30.684 --> 01:19:32.684
Our session will begin soon.
   (Music playing.

01:19:33.692 --> 01:19:35.692
)

01:20:23.294 --> 01:20:29.593
   (The session is about to 
begin.  Standing by.)

01:20:40.543 --> 01:20:44.856
   &gt;&gt; CHRIS PALMER:  Hi, 
everybody.  Thanks for coming.  

01:20:44.857 --> 01:20:46.857
I know you have a good selection
of entertainment this afternoon.

01:20:48.958 --> 01:20:51.670
So I'm glad so many of you chose
security.  Hopefully we'll have 

01:20:51.671 --> 01:20:54.120
some good fun.  A little bit of 
fear, not too much.

01:20:57.405 --> 01:21:00.069
So today I am going to talk 
about lessons that we learned 

01:21:00.070 --> 01:21:02.070
from the Spectre and Meltdown 
vulnerabilities.

01:21:04.948 --> 01:21:07.401
I'm Chris Palmer from the Chrome
security team.  We will be 

01:21:07.402 --> 01:21:09.402
giving this talk in two parts.

01:21:10.694 --> 01:21:12.985
I'll talk about Spectre and 
Meltdown and how we defended 

01:21:12.986 --> 01:21:14.986
against it.

01:21:16.240 --> 01:21:18.494
In the second half my colleague,
Emily Schechter from Chrome 

01:21:18.495 --> 01:21:21.366
security will talk about what 
you developers can do to make 

01:21:23.663 --> 01:21:26.138
the most of all of defensive 
work we have been doing, in 

01:21:26.139 --> 01:21:30.437
addition not just about Spectre 
and Meltdown but other good 

01:21:30.438 --> 01:21:32.438
stuff on the web and for 
extensions too.

01:21:34.312 --> 01:21:36.754
So we will talk about what 
Spectre is and why it hurts the 

01:21:36.755 --> 01:21:41.872
web; what we are doing to defend
against it in a way that doesn't

01:21:41.873 --> 01:21:43.873
damage the Web Platform itself.

01:21:45.168 --> 01:21:47.429
And we gt a little close to that
as some of you may know and I'll

01:21:47.430 --> 01:21:51.548
talk about what that was about 
and what we are going to do to 

01:21:51.549 --> 01:21:53.549
get back to good.

01:21:55.236 --> 01:21:56.864
And then as I was saying, there 
is general advances that Emily 

01:21:56.865 --> 01:21:59.343
is also going to talk about.  
There's some good stuff there.

01:22:00.607 --> 01:22:02.858
   So you may have seen this 
logo.

01:22:06.538 --> 01:22:09.380
It is one of those logod 
vulnerabilities.  Meltdown is a 

01:22:09.381 --> 01:22:13.504
variant of it that affects the 
operating system kernel.  We are

01:22:13.505 --> 01:22:15.918
not going to talk about that 
because we are focused on the 

01:22:15.919 --> 01:22:19.187
web and what we have to do in 
sort of non-kernel space to be 

01:22:19.188 --> 01:22:22.255
safe.
   So our concern is the open 

01:22:22.256 --> 01:22:25.106
Web Platform.  I would encourage
all of you to check 

01:22:30.198 --> 01:22:32.198
out the Spectre attack.

01:22:33.487 --> 01:22:36.376
com website which describes the 
both  attacks, the 

01:22:36.377 --> 01:22:38.377
vulnerabilities and also 

01:22:42.467 --> 01:22:44.467
the Google project 0 blog where 
Jan 

01:22:46.483 --> 01:22:48.497
Horne, one of the  discoverers 
of this set of problems goes 

01:22:48.498 --> 01:22:52.834
into extreme technical depth 
which you may enjoy.  I won't 

01:22:52.835 --> 01:22:54.904
get too heavy in this talk.  
We'll talk about what you need 

01:22:54.905 --> 01:22:59.183
to know to get the impact of it.
   These vulnerabilities became 

01:22:59.184 --> 01:23:02.270
public in January of this year. 
As a whole team of people who 

01:23:03.950 --> 01:23:06.389
discovered it, people from Graz 
University in Austria, 

01:23:06.390 --> 01:23:08.390
University of 

01:23:10.050 --> 01:23:13.115
Adelaide and Rambus and 
independent researchers.  

01:23:13.116 --> 01:23:15.116
Everyone sort of had an angle on
these things.

01:23:16.400 --> 01:23:18.679
These are hardware 
vulnerabilities, not software 

01:23:18.680 --> 01:23:22.765
vulnerabilities.   Fixing it is 
a different situation than the 

01:23:22.766 --> 01:23:24.766
usual software patch.

01:23:25.804 --> 01:23:27.804
We had to do a lot of work in 
Chrome to get through it.

01:23:29.713 --> 01:23:32.383
It was moderately terrifying.  
By moderately I mean extremely.

01:23:35.669 --> 01:23:37.669
And by extremely terrifying, I 
mean don't panic.

01:23:40.172 --> 01:23:42.227
It is handled and you can do 
stuff and we did stuff and it is

01:23:42.228 --> 01:23:44.228
going to be okay.  We'll get 
through it.

01:23:45.752 --> 01:23:47.984
But, you know, it was a little 
scary.  I lost some sleep.

01:23:50.016 --> 01:23:52.883
On the Chrome side, a lot of 
people did a lot of work to make

01:23:52.884 --> 01:23:54.884
this defense happen.

01:23:57.177 --> 01:23:59.828
I'm sort of the messenger today,
but the V8 team, the will 

01:23:59.829 --> 01:24:02.678
Project Zero team and there's a 
whole team called the site 

01:24:05.953 --> 01:24:08.204
isolation team and you'll be 
hearing about them.  They did a 

01:24:08.205 --> 01:24:11.884
lot of work to get us through 
this little adventure.  I'm sort

01:24:11.885 --> 01:24:13.885
of presenting on their behalf.

01:24:15.133 --> 01:24:17.133
I was just sort of the guy.  
They did all the real work.

01:24:21.903 --> 01:24:23.903
So the main impact of Spectre 
and 

01:24:25.990 --> 01:24:28.836
Meltdown is the hardware has a 
bit of a problem where if two 

01:24:28.837 --> 01:24:33.767
programs are running on the same
chip, they now have a -- they 

01:24:33.768 --> 01:24:37.700
can lose confidentiality 
guarantee from each other.  One 

01:24:37.701 --> 01:24:39.533
can read the  secrets of the 
other.  So that is a bad 

01:24:39.534 --> 01:24:43.035
problem.  The hardware is 
supposed to protect against 

01:24:43.036 --> 01:24:45.036
that.

01:24:46.336 --> 01:24:48.159
The way it happens is most 
modern hardware has a feature 

01:24:48.160 --> 01:24:53.665
called speculative execution 
where when you are about to 

01:24:53.666 --> 01:24:55.666
branch for an if statement, for 

01:24:56.966 --> 01:24:59.054
example, even before you know if
the if condition is going to 

01:24:59.055 --> 01:25:04.166
turn out to be true the computer
starts executing the if block 

01:25:04.167 --> 01:25:06.167
because if it does turn out to 

01:25:07.240 --> 01:25:08.462
be true, I the time you figure 
that out some of the work is 

01:25:08.463 --> 01:25:10.463
already done.

01:25:12.422 --> 01:25:14.869
It's a form of small scale 
parallelism and it really helps 

01:25:14.870 --> 01:25:17.531
performance a lot.  It's a huge 
advance.

01:25:20.567 --> 01:25:22.567
So what happens if the 
instructions, 

01:25:23.887 --> 01:25:26.407
if the if branch is not taken?  
Then what?  Does that work?  You

01:25:26.408 --> 01:25:30.128
don't see it.  It doesn't happen
in your program.  What happens 

01:25:30.129 --> 01:25:32.129
is, the computer never retires 
those instructions.

01:25:34.446 --> 01:25:36.939
So the work gets thrown away 
with no side effects on the 

01:25:36.940 --> 01:25:40.630
registers or memory or anything 
like that.  Except there's one 

01:25:40.631 --> 01:25:42.631
little catch.

01:25:43.697 --> 01:25:45.697
The cache memory in the chip to 
speed 

01:25:47.356 --> 01:25:49.609
up memory accesses, side effects
of loading memory that had to be

01:25:49.610 --> 01:25:53.968
done during speculation remain. 
And an attacker can observe 

01:25:53.969 --> 01:25:56.823
those side effects on the shared
cache resource.

01:25:59.886 --> 01:26:02.396
That can happen both within and 
across privilege boundaries, 

01:26:02.397 --> 01:26:04.397
like across user 

01:26:05.437 --> 01:26:07.437
to kernel, across from one 
process to 

01:26:08.534 --> 01:26:10.534
another, and on the web across 
origins.

01:26:12.201 --> 01:26:14.844
So that is a pretty bad problem 
and here is a little snippet of 

01:26:14.845 --> 01:26:16.845
how this might happen.

01:26:18.511 --> 01:26:22.223
This is what we are calling a 
speculation gadget.  It is a 

01:26:22.224 --> 01:26:24.703
snippet of code that either 
might appear in a program 

01:26:24.704 --> 01:26:26.704
naturally or 

01:26:27.966 --> 01:26:30.214
the attacker might create it, 
cause it to be in the program 

01:26:30.215 --> 01:26:32.215
such as with 

01:26:34.514 --> 01:26:36.514
Javascript, and this example is 
probably 

01:26:37.581 --> 01:26:39.234
the  simplest possible way to 
explain one variant of the 

01:26:39.235 --> 01:26:44.152
attack.  There are several other
variants.  This example is taken

01:26:44.153 --> 01:26:47.626
from the Spectre paper.  I 
didn't make this up.  I 

01:26:47.627 --> 01:26:49.673
definitely suggest reading the 
paper.  It is very fun.

01:26:51.096 --> 01:26:53.096
So what happens in the attack.

01:26:54.764 --> 01:26:56.764
The attacker controls X, this 
index to array 1.

01:26:59.419 --> 01:27:03.144
It is out of bounds, beyond the 
boundaries of that array.  The 

01:27:03.145 --> 01:27:05.145
attacker can also flush or cause

01:27:06.400 --> 01:27:09.264
to be loaded some stuff into 
cache memory.  There is various 

01:27:09.265 --> 01:27:11.265
ways to achieve that.  Previous 
research showed how.

01:27:13.748 --> 01:27:15.748
There's an out of bounds secret 

01:27:18.246 --> 01:27:20.276
beyond the edge of array 1 that 
we'll call K that the attacker 

01:27:20.277 --> 01:27:22.277
wants to learn.  That is 
breaking the confidentiality 

01:27:22.530 --> 01:27:24.967
guarantee.
   The attacker causes that to 

01:27:24.968 --> 01:27:26.968
get in cache.

01:27:28.505 --> 01:27:30.336
So accessing it is fast as 
opposed to accessing things out 

01:27:30.337 --> 01:27:33.837
of main memory which is fairly 
slow relative to the CPU speed.

01:27:33.838 --> 01:27:37.507
   So what happens here is 
obviously we are going to do a 

01:27:37.508 --> 01:27:40.559
bounds check because, of course,
you would.  That causes 

01:27:40.560 --> 01:27:42.603
speculative execution.  It might
be the case, for example, 

01:27:46.043 --> 01:27:48.043
that fetching array 1 size from 
main memory is going to be slow.

01:27:49.546 --> 01:27:51.807
It is not in cache, let's say.  
The computer is going to start 

01:27:51.808 --> 01:27:56.326
doing that Y equals array 2 and 
then that's when the attack 

01:27:56.327 --> 01:28:02.027
happens.  Because what happens 
is, that causes that memory to 

01:28:02.028 --> 01:28:05.302
get loaded into cache memory.  
Then accessing it later will be 

01:28:05.303 --> 01:28:07.945
fast.  And that gives the 
attacker, who can 

01:28:11.650 --> 01:28:13.650
control and see array 2 the 
ability to 

01:28:16.949 --> 01:28:19.596
determine if for a guess N, for 
every possible value of X, call 

01:28:19.597 --> 01:28:22.453
it N, just keep guessing in a 
four-loop.

01:28:25.506 --> 01:28:27.564
Eventually the attacker will see
that accessing N is fast and 

01:28:27.565 --> 01:28:29.565
then they will 

01:28:31.049 --> 01:28:34.952
know -- or accessing N as an 
index of array 1 is fast.  Then 

01:28:34.953 --> 01:28:36.953
they will know that's the same 
value as the secret.

01:28:39.668 --> 01:28:41.693
And this scales 
subexponentially.  It is 

01:28:41.694 --> 01:28:43.934
actually practical to do.  You 
don't have to guess all possible

01:28:44.547 --> 01:28:46.547
values of K.

01:28:48.615 --> 01:28:50.615
You get to guess byte by byte 
and additively take time.

01:28:52.897 --> 01:28:54.897
So the attacker can just run 
this in 

01:28:57.986 --> 01:28:59.986
a fore loop and they learn stuff
out of 

01:29:01.880 --> 01:29:03.880
bounds, stuff they shouldn't be 
able to do.

01:29:05.068 --> 01:29:09.366
How do we defend?  There is this
bad side  effect.  So you might 

01:29:09.367 --> 01:29:11.860
think as a lot of people at 
first did:  Why don't we just 

01:29:11.861 --> 01:29:14.736
turn off speculation?  That 
would be great.  The problem 

01:29:14.737 --> 01:29:18.003
goes away.  Or what if we just 
didn't have cache memory 

01:29:18.004 --> 01:29:22.541
anymore?  Well, that is 
completely untenable from a 

01:29:22.542 --> 01:29:24.542
performance perspective.

01:29:25.821 --> 01:29:27.821
We really need speculation and 
we 

01:29:28.865 --> 01:29:30.111
really need a large shared cache
to have low cost high 

01:29:30.112 --> 01:29:32.112
performance.  It is not  really 
negotiable.

01:29:34.208 --> 01:29:37.090
So we have to use a smarter 
approach than the sort of big 

01:29:37.091 --> 01:29:40.792
dumb hammer that you might 
imagine at first.  How does this

01:29:40.793 --> 01:29:43.071
impact the web?  It had a huge 
impact on operating 

01:29:46.341 --> 01:29:47.352
systems and Hypervisers and 
that's other people have worried

01:29:47.353 --> 01:29:49.353
about that.  I'm worried about 
the web.

01:29:54.334 --> 01:29:56.591
So the problem sort of could 
generalize, but I'm just going 

01:29:56.592 --> 01:29:58.592
to focus 

01:29:59.857 --> 01:30:01.857
on the same origin policy, which
is what 

01:30:04.357 --> 01:30:05.631
we are hoping to achieve as our 
main security principle in the 

01:30:05.632 --> 01:30:11.806
web.  Here is a picture of a 
typical renderer project.  

01:30:11.807 --> 01:30:14.058
Chrome is a multiprocess 
architecture and it is running 

01:30:14.059 --> 01:30:16.059
various processes to 

01:30:17.330 --> 01:30:19.367
run your various tabs and in any
one renderer process there might

01:30:19.368 --> 01:30:22.040
be several different origins 
happening at the same time.

01:30:25.729 --> 01:30:29.608
In this case, we've got innocent
origins A, B, and C.  But 

01:30:29.609 --> 01:30:31.233
there's also a hostile origin 
running in the same address 

01:30:31.234 --> 01:30:33.234
space.

01:30:35.946 --> 01:30:37.946
And that origin can either 
discover 

01:30:39.421 --> 01:30:41.310
or cause to be created 
speculation gadgets like in the 

01:30:41.311 --> 01:30:43.563
previous slide.  Then it can 
start reading data that 

01:30:46.876 --> 01:30:48.876
belong to origins A, B, and C 
inside the same process.

01:30:51.784 --> 01:30:54.241
So that is a loss of 
confidentiality across origins 

01:30:54.242 --> 01:30:56.242
which is extremely bad for the 
web.

01:30:58.775 --> 01:31:00.802
Like I said, I lost some sleep, 
but don't worry, we are going to

01:31:00.803 --> 01:31:03.876
take care of it.
   So the new baseline that we 

01:31:03.877 --> 01:31:05.877
now 

01:31:08.802 --> 01:31:11.081
operate in is just, we assume 
that any code running in a given

01:31:11.082 --> 01:31:13.746
address space in a given process
can read the whole address 

01:31:13.747 --> 01:31:16.815
space.  That's a significant 
change from the previous status 

01:31:16.816 --> 01:31:20.487
quo.
   So to do the attack, though, 

01:31:20.488 --> 01:31:25.803
it is not  automatic.  The 
attacker needs a couple things. 

01:31:25.804 --> 01:31:27.847
They need a CPU that does do 
speculation, which turns out to 

01:31:27.848 --> 01:31:29.848
be not all CPUs.

01:31:32.769 --> 01:31:34.401
Certain low end ARM processors 
don't.  So those are actually 

01:31:34.402 --> 01:31:36.876
safe.  But pretty much every 
other machine does.

01:31:40.141 --> 01:31:43.378
Every Intel desktop you've got, 
every iPhone, high end Android. 

01:31:43.379 --> 01:31:45.379
So the attacker gets that.

01:31:47.270 --> 01:31:48.493
You need a CPU with a shared 
cache.  Again every machine has 

01:31:48.494 --> 01:31:53.021
that.  The attacker has that.  
You need a high resolution clock

01:31:53.022 --> 01:31:55.022
to the attacker can time the 
difference 

01:31:58.298 --> 01:32:00.377
between accessing stuff out of 
cache versus accessing stuff out

01:32:00.378 --> 01:32:04.332
of main memory.  The better 
resolution of that clock the 

01:32:04.333 --> 01:32:06.793
easier to achieve the attack.  
Even fairly low resolution 

01:32:06.794 --> 01:32:09.461
clocks could still work, at 
least in theory.

01:32:12.527 --> 01:32:14.527
So a clock and there's tons of 
clocks in the Web Platform.

01:32:16.850 --> 01:32:18.725
Then the presence of such 
gadgets, speculation gadgets or 

01:32:18.726 --> 01:32:23.039
the ability to create them which
obviously Javascript lets you 

01:32:23.040 --> 01:32:25.332
write whatever you want.
   So all the preconditions are 

01:32:25.333 --> 01:32:27.333
met on the web.

01:32:29.434 --> 01:32:31.515
So to defend, the first thing we
want to do is break those 

01:32:31.516 --> 01:32:33.516
preconditions.

01:32:35.409 --> 01:32:38.060
So the one that came to mind, 
everybody at first was like:  

01:32:38.061 --> 01:32:40.061
Let's get rid of high precision 
clocks.

01:32:43.983 --> 01:32:48.500
That's turns out to be not  
really fees ib, unfortunately.  

01:32:48.501 --> 01:32:50.501
The Web Platform has a whole 
bunch of 

01:32:51.554 --> 01:32:55.643
clocks, APIs that are clocks on 
purpose, like performance.now 

01:32:55.644 --> 01:32:57.644
and there are APIs that turn out
to 

01:32:59.799 --> 01:33:02.503
be clocks by accident or 
implicit clocks such as Shared 

01:33:02.504 --> 01:33:04.504
Array Buffer.

01:33:05.559 --> 01:33:08.432
Everyone know what Shared Array 
Buffer is?  Some, a few?  It is 

01:33:08.433 --> 01:33:13.345
a thing.  It is a way to let you
share data between a worker and 

01:33:13.346 --> 01:33:16.211
mor main thread, for example.  
Than  turns out to be a 

01:33:16.212 --> 01:33:18.212
nanosecond 

01:33:19.319 --> 01:33:20.975
scale clock because the worker 
can just increment a counter in 

01:33:20.976 --> 01:33:25.120
the Shared Array Buffer and the 
main thread can say oh, hey, 

01:33:25.121 --> 01:33:28.000
what is our value now?  That is 
about how many milliseconds, 

01:33:30.069 --> 01:33:32.069
sorry, nanoseconds have passed. 
So it's a clock.

01:33:34.557 --> 01:33:36.557
In order to make exploitation 
not be 

01:33:37.829 --> 01:33:41.122
too easy we actually turned off 
Shared Array Buffer.  Even 

01:33:41.123 --> 01:33:44.225
shortly after shipping it, which
is a real bummer for us.  We did

01:33:44.226 --> 01:33:46.226
not want to do that.  People 
need it to make cool 

01:33:46.884 --> 01:33:49.537
applications on the web.  And we
want the web to be cool and 

01:33:51.781 --> 01:33:53.781
powerful and to enable 
interesting applications.

01:33:54.841 --> 01:33:56.695
So we had a big old argument 
about whether or not we were 

01:33:56.696 --> 01:33:59.560
really going to do that.  But we
did.  We are bringing it back 

01:33:59.561 --> 01:34:03.021
and I'll explain how.  But 
unfortunately, I think that did 

01:34:04.064 --> 01:34:06.529
gain us something.  I think the 
easiest route to 

01:34:10.418 --> 01:34:13.521
exploitation was  avoided in 
that, by doing that.  And other 

01:34:13.522 --> 01:34:15.761
browsers did similar things.  
And we all collaborated to sort 

01:34:15.762 --> 01:34:20.492
of figure out how we are going 
to do this in a way that doesn't

01:34:20.493 --> 01:34:22.493
hurt the web so we are all on 
the same page.

01:34:22.741 --> 01:34:26.801
I should mention that.  That's 
kind of a happy story that comes

01:34:26.802 --> 01:34:31.175
out of this.  A really good 
collaboration between the 

01:34:31.176 --> 01:34:32.806
security teams of a lot of 
different browser vendors.  It 

01:34:32.807 --> 01:34:35.076
has been a great experience for 
all of us.  I think we are going

01:34:35.077 --> 01:34:37.952
to come out with a much better 
web thanks to the help of 

01:34:38.359 --> 01:34:42.845
everyone.  And we are going to 
bring Shared Array Buffer back 

01:34:42.846 --> 01:34:45.093
once we made the web safe for 
clocks, which sounds like a 

01:34:45.094 --> 01:34:49.605
funny thing to say.
   So as I was sort of getting 

01:34:49.606 --> 01:34:51.606
at we 

01:34:52.895 --> 01:34:55.586
don't want to lightly toy with 
the Web Platform.  It has to be 

01:34:55.587 --> 01:34:59.050
stable so that you can build 
stuff on it.  If we are taking 

01:34:59.051 --> 01:35:01.514
APIs away or changing how they 
behave, it is not a good 

01:35:02.129 --> 01:35:04.976
developer experience.  And that 
therefore is not a good user 

01:35:05.576 --> 01:35:10.291
experience, obviously.  So we 
can't do that too much.  And we 

01:35:10.292 --> 01:35:12.292
did not do it lightly.

01:35:14.811 --> 01:35:16.811
And going forward, our goal is 
to be  

01:35:18.069 --> 01:35:20.511
very, very careful and ship -- 
even more careful than before --

01:35:20.512 --> 01:35:23.165
and ship things that we believe 
that we won't ever have to 

01:35:23.166 --> 01:35:25.166
unship.

01:35:27.855 --> 01:35:29.855
That is a tall  order, but super
bad 

01:35:31.135 --> 01:35:32.554
emergencies like Spectre have 
sort of recalibrated our 

01:35:32.555 --> 01:35:34.602
thinking as to what kinds of 
things are possible.

01:35:37.886 --> 01:35:41.165
And that's kind of been fun, a 
good adventure.  Frightening 

01:35:41.166 --> 01:35:43.166
form of fun that I kind of 
enjoy.

01:35:43.205 --> 01:35:45.205
Other things we can do.

01:35:46.243 --> 01:35:48.243
Think back about that gadget.

01:35:50.126 --> 01:35:52.359
What if we could turn off 
speculation, not across the 

01:35:52.360 --> 01:35:54.360
board because that is not 
tenable for performance reasons.

01:35:57.287 --> 01:36:00.154
But what if we could just like 
for this if check, when checking

01:36:00.155 --> 01:36:02.196
array bounds, definitely make 
sure you fully 

01:36:05.249 --> 01:36:06.910
checked it before you then 
speculate further.  You can do 

01:36:06.911 --> 01:36:10.803
that actually.  Different CPU 
architectures have different 

01:36:10.804 --> 01:36:13.725
instructions to let you say 
don't go past this point until 

01:36:13.726 --> 01:36:18.205
you loaded this thing from 
memory and so on.  You can sort 

01:36:18.206 --> 01:36:20.206
of turn off speculation on a 
microscale.

01:36:23.559 --> 01:36:25.559
And the V8 team here I cannily 
worked 

01:36:26.861 --> 01:36:29.308
to do as much of that as they 
can to get rid of speculation 

01:36:29.309 --> 01:36:31.309
gadgets in the 

01:36:32.564 --> 01:36:33.601
Runtime and change how they 
compile code to not generate any

01:36:33.602 --> 01:36:37.483
gadgets.  That is a very 
difficult thing.  They had to do

01:36:37.484 --> 01:36:40.127
a lot of work.
   And unfortunately, it doesn't

01:36:40.128 --> 01:36:45.012
get us all the way across the 
finish line, but it definitely 

01:36:45.013 --> 01:36:47.043
again, like turning off Shared 
Array Buffer it got us a little 

01:36:50.731 --> 01:36:52.807
breathing room to get through to
this point to now where we can 

01:36:52.808 --> 01:36:55.876
do more long-term things.
   There's the low-level 

01:36:55.877 --> 01:36:59.194
defenses, but the web needs more
than just that.  We have to real

01:36:59.195 --> 01:37:03.812
I do something about the origin 
boundary per se.  We have to 

01:37:03.813 --> 01:37:06.072
uphold that thing directly.  
That's what we are trying to do.

01:37:13.072 --> 01:37:15.072
So think about a malicious site 
that 

01:37:16.367 --> 01:37:18.433
can take over a renderer such as
by memory corruption or a logic 

01:37:18.434 --> 01:37:20.434
bug.

01:37:21.892 --> 01:37:24.550
Something that we call universal
cross site scripting and that is

01:37:24.551 --> 01:37:29.084
a bad bug.  They can cause other
origins that they want to attack

01:37:29.085 --> 01:37:31.085
to be loaded in the renderer.

01:37:33.319 --> 01:37:34.124
So we knew all along that we 
needed a good way to defend 

01:37:34.125 --> 01:37:36.125
against that.

01:37:37.431 --> 01:37:39.431
So years ago we started cooking 
one up.

01:37:40.707 --> 01:37:43.561
We call it Site Isolation.  It 
turns out that Site Isolation is

01:37:46.232 --> 01:37:47.663
super useful for Spectre also, 
pretty much for the same reason.

01:37:47.664 --> 01:37:49.724
   What it does, it is a 
rethinking of 

01:37:52.803 --> 01:37:54.803
how we apportioned origins to 
processes.

01:37:56.070 --> 01:37:58.070
In the past it is based on 
resource 

01:37:59.370 --> 01:38:01.840
consumption and how busy is this
renderer, do we need a new one, 

01:38:01.841 --> 01:38:04.103
can we reuse one that has a 
light load?

01:38:09.437 --> 01:38:11.437
Now we are going to instead 
line-up 

01:38:13.135 --> 01:38:15.135
sites with their processes, 
their dedicated to them.

01:38:17.502 --> 01:38:19.502
That gets hostile overage ins 
out of 

01:38:20.582 --> 01:38:22.582
our address space of innocent 
origins.

01:38:22.614 --> 01:38:24.869
Here is a picture of the status 
quo, a sort of block diagram of 

01:38:24.870 --> 01:38:27.897
the technology stack.  You have 
your hardware, you have 

01:38:31.189 --> 01:38:32.640
kernel mode or ring 0 you have 
user mode or ring 3.  You have 

01:38:32.641 --> 01:38:37.615
your kernel.  There's other user
land processes.  There is the 

01:38:37.616 --> 01:38:39.616
browser which is spawning 

01:38:41.747 --> 01:38:43.562
a renderer or maybe ten to run 
origins A, B, C, D, whatever 

01:38:43.563 --> 01:38:45.563
else you have going.  So that is
the status quo.

01:38:48.258 --> 01:38:50.088
We are changing that in a way 
that seems simple when you draw 

01:38:50.089 --> 01:38:52.741
a picture, but it is an 
incredible amount of work.

01:38:56.240 --> 01:38:57.923
We had to fundamentally rethink 
basic assumptions about Chrome's

01:38:57.924 --> 01:39:00.367
architecture in order to achieve
this.

01:39:04.253 --> 01:39:07.764
Navigation, it -- Javascript 
APIs, it crosses the board.  It 

01:39:07.765 --> 01:39:10.613
is quite interesting.
   Now site A, B, C, and D will 

01:39:10.614 --> 01:39:14.459
get their own renderer processes
and they will be isolated from 

01:39:14.460 --> 01:39:16.460
each other.

01:39:20.188 --> 01:39:22.188
If D turns evil it can, via 
Spectre, 

01:39:23.808 --> 01:39:25.808
it can read whatever it wants 
out of its 

01:39:26.815 --> 01:39:28.815
own process an A, B, and C are 
safe elsewhere.

01:39:28.838 --> 01:39:31.775
Here is another picture, a call 
back.  You can see now that the 

01:39:31.776 --> 01:39:37.327
hostile site is in its own 
address space safely isolated 

01:39:37.328 --> 01:39:39.328
from the good friends A, B, and 
C.

01:39:40.592 --> 01:39:42.424
So this is a great solution.  We
think it is the way forward for 

01:39:42.425 --> 01:39:45.090
a variety of reasons, not just 
Spectre.

01:39:48.397 --> 01:39:50.880
Like I was saying it is also a 
good defense against universal 

01:39:50.881 --> 01:39:55.811
process scripting.  There are 
limitations.  One for thing I 

01:39:55.812 --> 01:39:57.812
have been saying site, not 
origin.

01:39:59.958 --> 01:40:01.958
A site is something we define as
being 

01:40:03.456 --> 01:40:05.456
the effective top level domain 
+1 label below that.

01:40:07.412 --> 01:40:09.412
So like NHS.gov.U.K.

01:40:13.552 --> 01:40:15.552
That is the effective top level 

01:40:20.584 --> 01:40:22.584
domain, NHS1 level below, sim 
allocated 

01:40:26.344 --> 01:40:28.344
com, one level below, Bing or 
whatever.

01:40:28.979 --> 01:40:31.008
So the whole host name includes 
the port number.  For both of 

01:40:31.009 --> 01:40:33.009
these, scheme matters too.

01:40:34.697 --> 01:40:36.697
You can't be the same site if 
you are 

01:40:39.398 --> 01:40:41.398
HTTP as the same https verse of 
your site.

01:40:44.533 --> 01:40:47.400
The effective tld +1 or eTLD.  
As you can imagine we will be 

01:40:47.401 --> 01:40:50.668
loading or launching more 
processes, so that uses more 

01:40:50.669 --> 01:40:52.669
memory.

01:40:54.430 --> 01:40:56.430
Unfortunately, a little more Ram
is going to be required.

01:40:58.136 --> 01:41:00.162
Last, there's the thing called 
cross origin read blocking, 

01:41:00.163 --> 01:41:04.944
which is a crucial part of Site 
Isolation that requires you to 

01:41:04.945 --> 01:41:07.809
do a little bit of work.  It is 
not a heavy lift.  Don't worry 

01:41:07.810 --> 01:41:12.124
too much.  Emily will explain 
how you can get the most of it 

01:41:12.125 --> 01:41:15.796
and why it is important.
   But it is a crucial thing 

01:41:15.797 --> 01:41:17.850
that you will all want to take a
look at.

01:41:19.485 --> 01:41:21.485
The final thing that we are 
changing 

01:41:23.780 --> 01:41:25.418
how we do for Spectre is before 
we give super important 

01:41:25.419 --> 01:41:27.419
information to a 

01:41:29.748 --> 01:41:31.748
renderer like auto fill form 
data, your 

01:41:32.791 --> 01:41:35.528
passwords, payment instruments, 
we are going to gate that on 

01:41:35.529 --> 01:41:38.621
some cation that the user, the 
person really wants to do it.

01:41:42.688 --> 01:41:44.741
There boant won't be any sort of
automatic giving of super 

01:41:44.742 --> 01:41:46.742
sensitive information to 
renderers.

01:41:48.010 --> 01:41:50.238
So the person is going to be 
maybe a little more in the loop 

01:41:50.239 --> 01:41:52.239
on some things than they have in
the past.

01:41:54.994 --> 01:41:57.053
I really think that's important 
especially given the fact that a

01:41:57.054 --> 01:41:59.940
site being more broadly defined 
than an 

01:42:04.244 --> 01:42:06.959
origin, a site may contain some 
potentially hostile origins in 

01:42:06.960 --> 01:42:09.430
its same site instance, 
therefore in the same process.

01:42:13.515 --> 01:42:15.515
For example, super important 
thing, that  example.

01:42:17.604 --> 01:42:22.536
com and forgotten old Wordpress 
installation dot example.com.  

01:42:22.537 --> 01:42:25.213
Those are currently in the same 
site, obviously.  In the 

01:42:25.214 --> 01:42:27.869
long-term we would like to get 
back to something closer to the 

01:42:27.870 --> 01:42:30.724
origin definition.
   Anyway, we are going to make 

01:42:30.725 --> 01:42:35.442
sure that people want to do 
things before we give 

01:42:35.443 --> 01:42:38.108
information to renderers.
   There's things you can do 

01:42:38.109 --> 01:42:42.448
about this, including cross 
origin re-blocking.  That's 

01:42:42.449 --> 01:42:44.449
where Emily comes in from 

01:42:46.106 --> 01:42:47.135
Chrome security team and she's 
got some good information for 

01:42:47.136 --> 01:42:49.417
you.  Please give her a warm 
welcome.

01:42:49.418 --> 01:42:51.418
(Applause.

01:42:52.423 --> 01:42:53.348
)
   &gt;&gt; EMILY SCHECHTER:  All 

01:42:53.349 --> 01:42:55.349
right.

01:42:56.400 --> 01:43:00.299
So thanks so much, Chris, for 
enlightening us about Spectre.  

01:43:00.300 --> 01:43:02.300
For overviewing ways that we are

01:43:03.367 --> 01:43:04.406
making Chrome and the Web 
Platform safer with Site 

01:43:04.407 --> 01:43:06.923
Isolation.
   Now I know all of you may be 

01:43:08.344 --> 01:43:10.832
wondering what you can do about 
all of this.  It turns out there

01:43:10.833 --> 01:43:15.916
are actually lots of things that
you as web developers can do to 

01:43:15.917 --> 01:43:18.963
best amp up your defenses.
   So I'll go over some steps 

01:43:18.964 --> 01:43:24.282
that you should take to keep 
your web project secure.  First 

01:43:24.283 --> 01:43:27.183
I'll talk about steps that you 
should take to get the most of 

01:43:27.184 --> 01:43:31.865
Spectre defenses.  Then I'll 
talk about some general security

01:43:31.866 --> 01:43:33.507
recommendations for website 
developers and for extension 

01:43:33.508 --> 01:43:38.002
developers.
   So first let's talk about the

01:43:40.278 --> 01:43:42.321
Spectre-specific defenses.  
There are two specific areas 

01:43:42.322 --> 01:43:47.823
that you'll want to think about 
as a web developer.  Getting the

01:43:47.824 --> 01:43:52.349
most out of cross origin read 
blocking and cookie health.  So 

01:43:52.350 --> 01:43:54.387
I'll explain what both of these 
are and about how you should 

01:43:54.388 --> 01:43:57.497
think about them.
   First we'll talk about the 

01:43:57.498 --> 01:44:01.810
feature that Chris mentioned 
called cross origin read 

01:44:01.811 --> 01:44:06.516
blocking and how you can get the
most of it.  So Chris just 

01:44:06.517 --> 01:44:09.389
talked about how Site Isolation 
will put different sites into 

01:44:09.989 --> 01:44:15.747
different processes.  Even when 
all cross origin pages are put 

01:44:15.748 --> 01:44:17.997
into separate processes, pages 
can still legitimately request 

01:44:17.998 --> 01:44:23.567
some cross origin subresources 
such as images and Javascript.  

01:44:23.568 --> 01:44:26.244
So to help prevent sensitive 
information from leaking, Site 

01:44:26.245 --> 01:44:30.126
Isolation includes this cross 
origin read blocking feature 

01:44:30.127 --> 01:44:32.153
that limits which network  
responses are delivered to the 

01:44:32.154 --> 01:44:35.013
renderer process.
   So why does this matter?

01:44:38.098 --> 01:44:40.984
Well, imagine an attacker 
creating an image tag that 

01:44:40.985 --> 01:44:42.985
includes a JSON file with 

01:44:44.033 --> 01:44:46.691
sensitive information like maybe
your bank balance.  Without Site

01:44:46.692 --> 01:44:48.751
Isolation the contents of the 
JSON file would make it to the 

01:44:52.205 --> 01:44:54.282
renderer process' memory, at 
which point the renderer notices

01:44:54.283 --> 01:44:57.141
that it is not a valid image 
format and doesn't render the 

01:44:57.142 --> 01:45:01.616
image.  But now we have Spectre.
Now there is a way to 

01:45:01.617 --> 01:45:03.617
potentially read 

01:45:04.759 --> 01:45:05.964
that chunk of memory.
   So cross origin read blocking

01:45:05.965 --> 01:45:10.269
would actually prevent the 
contents of this file from ever 

01:45:10.270 --> 01:45:12.270
entering the memories of 

01:45:13.285 --> 01:45:15.285
the process that the renderer is
running 

01:45:17.454 --> 01:45:18.342
because the mind pipe is  
blocked by cross origin read 

01:45:18.343 --> 01:45:19.998
blocking.
   So let's breakdown how this 

01:45:19.999 --> 01:45:21.999
works.

01:45:23.272 --> 01:45:26.136
A website can request two types 
of URLs from a server:  Data 

01:45:26.137 --> 01:45:28.137
resources and media resources.

01:45:30.618 --> 01:45:32.618
So here data resources includes 
text or code-like resources.

01:45:36.796 --> 01:45:38.796
So had the MultiModal, XML, JSON
files.

01:45:39.264 --> 01:45:41.520
A website is able to receive 
data resources from its own 

01:45:41.521 --> 01:45:43.521
domain or other 

01:45:45.005 --> 01:45:47.048
domains with permissive CORS 
headers.  Cross origin data 

01:45:47.049 --> 01:45:49.122
resources come from a different 
site than the page that requests

01:45:49.123 --> 01:45:54.672
them.  They do not have CORS 
headers that would make them 

01:45:54.673 --> 01:45:57.166
accessible.
   Media resources could include

01:45:57.167 --> 01:45:59.167
things like Javascript or CSS.

01:46:02.497 --> 01:46:07.268
Immediate media resources could 
be included from any site.  The 

01:46:07.269 --> 01:46:09.511
cross origin read blocking 
policy prevents a process from 

01:46:09.512 --> 01:46:11.560
receiving these data resources 
from other origins if 

01:46:16.263 --> 01:46:18.263
they have an HTML XML or JSON 
MIME type 

01:46:20.162 --> 01:46:22.162
and there is an X content type 
options 

01:46:23.424 --> 01:46:25.424
nosniff response header and if 
CORS 

01:46:26.704 --> 01:46:28.704
doesn't explicitly allow access 
to the document.

01:46:29.551 --> 01:46:31.591
Data resources blocked by this 
policy are presented to the 

01:46:31.592 --> 01:46:34.246
process as empty, although the 
request does still happen in the

01:46:34.247 --> 01:46:36.247
background.

01:46:37.974 --> 01:46:40.630
So here is an example for random
site.com where we have two cross

01:46:40.631 --> 01:46:45.174
origin subresources from your 
bank.com which might be some 

01:46:45.175 --> 01:46:48.026
pretty sensitive information.  
The first looks like an image 

01:46:48.027 --> 01:46:51.481
but bit actually includes JSON 
and it does not include a CORS 

01:46:51.482 --> 01:46:55.578
header.  So it will be blocked.
   In the second request it is 

01:46:55.579 --> 01:47:00.259
fetching JSON but it does 
include CORS.  If there is a 

01:47:00.260 --> 01:47:02.477
legal access control allow 
origin header on the response, 

01:47:02.478 --> 01:47:04.518
it will be allowed.

01:47:07.581 --> 01:47:09.819
So what this means is that to 
benefit from cross origin read 

01:47:09.820 --> 01:47:11.820
blocking you need 

01:47:13.506 --> 01:47:16.361
to send the right contend type 
headers so the cross origin read

01:47:16.362 --> 01:47:18.824
blocking can recognize the 
content as sensitive and block 

01:47:18.825 --> 01:47:20.825
it.

01:47:23.966 --> 01:47:25.966
You should also tell the browser
not to MIME sniff.

01:47:30.406 --> 01:47:32.406
We try to confirm that it is 
correct 

01:47:34.261 --> 01:47:36.261
but you are better off doing the
the 

01:47:37.701 --> 01:47:39.701
right thing yourself that is 
cross origin read blocking.

01:47:40.615 --> 01:47:42.855
Let's move on to cookie health. 
If we go back to the previous 

01:47:42.856 --> 01:47:47.997
example where the attacker 
created an image tag that 

01:47:47.998 --> 01:47:49.998
included a JSON file with 
sensitive 

01:47:51.038 --> 01:47:53.499
data, this actually only works 
if your bank.com has stored a 

01:47:53.500 --> 01:47:55.500
cookie that automatically  logs 
the user in.

01:47:58.465 --> 01:48:00.465
And cookies typically get sent 
for all requests to the website.

01:48:01.514 --> 01:48:03.546
That sets the cookie even if the
request is made by a third-party

01:48:03.547 --> 01:48:07.252
using the image tag.
   Now we have same site 

01:48:07.253 --> 01:48:09.466
cookies.  They are a new 
attribute that specify 

01:48:12.471 --> 01:48:14.529
that a cookie should only be 
attached to a request that 

01:48:14.530 --> 01:48:16.530
originates from the same site.

01:48:17.970 --> 01:48:19.970
Hence the name same site 
cookies.

01:48:22.513 --> 01:48:26.618
Right now Chrome and Firefox are
supporting this attribute.  If 

01:48:26.619 --> 01:48:28.619
you are not using Javascript, 
there 

01:48:31.126 --> 01:48:32.994
are ways you can stop the 
cookies data from the rendering 

01:48:32.995 --> 01:48:34.995
process.

01:48:36.258 --> 01:48:38.939
You can set the cookies 
attribute which prevents the 

01:48:38.940 --> 01:48:40.940
cookie from being 

01:48:42.209 --> 01:48:44.209
accessed on  supported site 
scripts like Chrome.

01:48:46.315 --> 01:48:48.315
If HTTP is possible, you can 
limit 

01:48:49.792 --> 01:48:52.264
the exposure by not reading 
document.cookie unless it's  

01:48:52.265 --> 01:48:55.722
absolutely necessary.
   So that wraps up how you as a

01:48:55.723 --> 01:48:58.827
web developer should make 
changes to best mitigate 

01:48:58.828 --> 01:49:03.112
Spectre.  We have this 
information posted online on our

01:49:03.113 --> 01:49:05.552
web fundamentals article.  
Definitely check back there for 

01:49:05.553 --> 01:49:08.011
more updates.
   So now that we've talked 

01:49:08.012 --> 01:49:12.905
about ways to mitigate Spectre, 
let's talk about other ways that

01:49:12.906 --> 01:49:16.194
you can keep your web projects 
safe.  I say projects here 

01:49:16.195 --> 01:49:19.443
because many of these methods 
are applicable for both websites

01:49:19.444 --> 01:49:23.121
and Chrome Extensions.
   So there are three overall 

01:49:23.122 --> 01:49:27.857
categories to think about 
improving security for your site

01:49:27.858 --> 01:49:31.555
or  extension.  The first is 
using web security standards.

01:49:35.435 --> 01:49:37.127
So https is one of our favorite 
topics on the Chrome security 

01:49:37.128 --> 01:49:41.408
team.  I would be remiss if I 
didn't remind you that when 

01:49:41.409 --> 01:49:45.767
sending or requesting data you 
should always avoid HTTP.  This 

01:49:45.768 --> 01:49:48.040
is important for website 
developers an it is also 

01:49:48.041 --> 01:49:50.041
important for extension 
developers too.

01:49:51.955 --> 01:49:53.955
You should never be using plain 
HTTP in your extension.

01:49:56.896 --> 01:49:59.815
Https is just the bare minimum 
that web users today expect in 

01:49:59.816 --> 01:50:03.077
terms of site security.
   At 4:00 p.m. today, right 

01:50:03.078 --> 01:50:05.078
after this talk, but over 

01:50:09.993 --> 01:50:11.848
on stage 6, Adrian and Dan Mac 
he will Wayne will talk about 

01:50:11.849 --> 01:50:17.536
trends we are seeing and the 
latest and greatest updates in 

01:50:17.537 --> 01:50:19.537
UI changes in Chrome.  Go check 
out that talk.

01:50:21.849 --> 01:50:24.744
If you are not using https, 
check out our setup guide to 

01:50:24.745 --> 01:50:27.813
figure out how to get started.
   Content security policy 

01:50:27.814 --> 01:50:29.886
provides a rich set of 
directives that enable 

01:50:33.128 --> 01:50:35.988
granular control over the 
resources that a page is allowed

01:50:35.989 --> 01:50:37.989
to load and where it is loaded 
from.

01:50:41.154 --> 01:50:42.579
This is an awesome way to help 
prevent cross origin scripting 

01:50:42.580 --> 01:50:44.580
attacks and you 

01:50:45.879 --> 01:50:47.314
can use their policy violation 
reporting tools that you may not

01:50:47.315 --> 01:50:49.315
know about.

01:50:50.584 --> 01:50:51.808
I recommend that you check out 
the web fundamentals article to 

01:50:51.809 --> 01:50:53.809
learn more.

01:50:55.260 --> 01:50:57.260
Extension developers, CSP is for
you too.

01:50:58.996 --> 01:51:00.199
You should include an explicit 
CSP for the extension in the 

01:51:00.200 --> 01:51:03.044
manifest.
   So if you are using content 

01:51:03.045 --> 01:51:05.045
security 

01:51:06.529 --> 01:51:08.993
policy in your policy it might 
look something like this.  If 

01:51:08.994 --> 01:51:11.643
the extension is only loading 
resources from itself you can 

01:51:11.644 --> 01:51:17.214
register CSP.  If the extension 
needs to include scripts from 

01:51:17.215 --> 01:51:19.215
specific codes they can be 
included here as well.

01:51:21.167 --> 01:51:23.167
So that is just a quick primer 
about 

01:51:24.292 --> 01:51:26.292
what you should know in terms of
web security standards.

01:51:27.841 --> 01:51:29.841
Now let's move on to protecting 
developer accounts.

01:51:30.493 --> 01:51:32.575
This one is actually 
particularly important for 

01:51:32.576 --> 01:51:34.673
developers of Chrome Extensions.
If you are a developer of a 

01:51:34.674 --> 01:51:39.180
Chrome Extension you might not 
realize it, but you actually now

01:51:39.181 --> 01:51:41.816
have a lot of power because your
code is running on a lot of 

01:51:43.453 --> 01:51:45.453
users' browsers.

01:51:46.517 --> 01:51:48.517
If your developer account is 
proceed 

01:51:50.034 --> 01:51:51.872
miced, an attacker could push 
malicious code directly to a the

01:51:51.873 --> 01:51:53.873
look of users.

01:51:55.151 --> 01:51:58.410
This seems like you've become a 
juicy target for attackers.  

01:51:58.411 --> 01:52:01.297
What this means, you should 
definitely take extra care to 

01:52:01.298 --> 01:52:03.750
protect your developer account. 
Google released the advanced 

01:52:05.778 --> 01:52:08.238
protection program to safeguard 
the Google accounts of those 

01:52:08.239 --> 01:52:11.522
most at risk of targeted 
attacks.  It includes phishing 

01:52:11.523 --> 01:52:15.254
protection with a physical 
security key.   Safeguarding 

01:52:15.255 --> 01:52:17.718
your emails and files by 
limiting access to non-Google 

01:52:17.719 --> 01:52:23.311
services.  And blocking 
fraudulent account access with 

01:52:23.312 --> 01:52:25.312
extra steps to verify that it's 
you.

01:52:27.641 --> 01:52:29.896
But if the advanced protection 
program is not for you you 

01:52:29.897 --> 01:52:32.763
should definitely still take 
other measures to protect your 

01:52:32.764 --> 01:52:37.098
accounts.  For example you 
should enable two factor 

01:52:37.099 --> 01:52:40.996
authentication and preferably 
with a security key.

01:52:42.642 --> 01:52:46.518
Finally I'll talk about price 
protection.  And here I'll -- 

01:52:46.519 --> 01:52:48.549
privacy protection and here I'll
focus on permission.

01:52:51.626 --> 01:52:53.626
First, permissions best 
practices for 

01:52:55.319 --> 01:52:57.319
web developers and then I'll 
talk about 

01:52:58.372 --> 01:53:00.372
permissions best practices for 
extension  developers.

01:53:00.391 --> 01:53:02.391
On the web when you use certain 

01:53:06.319 --> 01:53:08.319
powerful APIs like key location 
or push 

01:53:10.365 --> 01:53:11.442
locations, Chrome will ask the 
user for permission to use that 

01:53:11.443 --> 01:53:17.170
powerful ape.  It is important 
for you as a developer for you 

01:53:17.171 --> 01:53:19.603
to ask your users how you will 
be using that information.  If 

01:53:19.604 --> 01:53:21.654
users understand the value that 
permission brings at the time 

01:53:21.655 --> 01:53:23.655
when you ask for it.

01:53:27.166 --> 01:53:30.241
So, for example, here we have a 
hypothetical airline web app.  

01:53:30.242 --> 01:53:31.873
You can see there's a check box 
at the bottom of the screen for 

01:53:31.874 --> 01:53:34.734
user to indicate that they want 
notifications for flight delays.

01:53:38.377 --> 01:53:40.377
So after a user checks this box,
is a 

01:53:42.768 --> 01:53:44.022
great time to ask for the push 
notification permission because 

01:53:44.023 --> 01:53:46.974
the value of getting 
notifications for flight  delays

01:53:46.975 --> 01:53:49.015
is really clear.
   A much worse user experience 

01:53:49.016 --> 01:53:51.260
would be, for example, just 
spamming the user 

01:53:54.318 --> 01:53:56.550
on page load all the time for a 
bunch of permissions that might 

01:53:56.551 --> 01:54:00.016
seem random at that point.
   So now I'll move to 

01:54:00.017 --> 01:54:04.465
permissions best practices for 
extension developers.  We will 

01:54:04.466 --> 01:54:06.742
cover two best practices.  
Reducing required permissions 

01:54:06.743 --> 01:54:09.831
and using optimal permissions.

01:54:13.760 --> 01:54:15.760
So first reduce required 
permissions.

01:54:17.015 --> 01:54:18.637
The APIs and extension can 
access is specified in the 

01:54:18.638 --> 01:54:21.532
permissions field of the 
manifest and the more 

01:54:21.533 --> 01:54:26.016
permissions are granted the more
avenues and  attacker has to 

01:54:26.017 --> 01:54:29.543
intercept information.  Only the
APIs that an extension depends 

01:54:29.544 --> 01:54:34.208
on should be listed.
   Extensions that are using 

01:54:34.209 --> 01:54:36.209
host 

01:54:38.269 --> 01:54:40.350
permissions to inject scripts 
can often substitute asset tab 

01:54:40.351 --> 01:54:42.351
instetted.

01:54:44.008 --> 01:54:45.855
The activeTab permission will 
grant temporary access to the 

01:54:45.856 --> 01:54:48.506
current activeTab only when the 
urine vox the 

01:54:52.187 --> 01:54:55.044
permission and access is cut off
when the user navigates away 

01:54:55.045 --> 01:54:57.045
from or closes the  tab.

01:54:59.198 --> 01:55:02.239
This serves as a good use for 
many URLs.

01:55:04.279 --> 01:55:06.124
You should also empower users to
choose which features and 

01:55:06.125 --> 01:55:09.570
permissions they need from an 
extension by including optional 

01:55:09.571 --> 01:55:14.734
permissions.  If a feature is 
not essential to the core 

01:55:14.735 --> 01:55:17.192
functionality of an extension 
make it optional and move the 

01:55:17.193 --> 01:55:19.193
API or domain into the optimal 
permissions field.

01:55:22.329 --> 01:55:27.284
   Here is what using optional 
permissions looks like in our 

01:55:27.285 --> 01:55:30.150
manifest.  Okay.  We just 
covered a lot of best practices.

01:55:32.414 --> 01:55:34.848
We covered how you can take 
advantage of protections from 

01:55:34.849 --> 01:55:39.142
Spectre and we  covered other 
best practices to keep your 

01:55:39.143 --> 01:55:41.386
website or your extension safe 
using web security  standards, 

01:55:41.387 --> 01:55:43.570
developer account protection, 
and permissions best practices.

01:55:45.828 --> 01:55:50.331
   At Chrome we believe in 
creating a web that is easy to 

01:55:50.332 --> 01:55:53.993
use securely by default and we 
continue to work on security 

01:55:53.994 --> 01:55:56.234
protections that make the entire
web safer.

01:55:57.784 --> 01:56:00.424
So as developers, go out there, 
take advantage of these tips and

01:56:00.425 --> 01:56:05.139
resources so that together we 
can continue to build a platform

01:56:05.140 --> 01:56:08.898
and ecosystem that is safe by 
default for everyone.  Let us 

01:56:08.899 --> 01:56:10.899
know if you have any feedback on
the talk.

01:56:12.811 --> 01:56:14.250
We'll be in the web Sandbox area
after the talk if you have any 

01:56:14.251 --> 01:56:16.768
questions.
   Thanks.

01:56:16.769 --> 01:56:18.769
(Applause.

01:56:19.770 --> 01:56:21.770
)

01:56:23.756 --> 01:56:26.751
   (Music playing.)

01:56:31.752 --> 01:56:36.665
   &gt;&gt; ANNOUNCER:  Thank you for 
joining this session.  Brand 

01:56:36.666 --> 01:56:38.746
ambassadors will assist with  
directing you through the 

01:56:38.747 --> 01:56:41.221
designated exits.  We will be 
making room for those who 

01:56:42.055 --> 01:56:44.083
registered for the next session.
If you reg spheared for the next

01:56:46.539 --> 01:56:49.004
session in this room, please 
clear the room and return via 

01:56:49.005 --> 01:56:51.005
the registration line outside.  
Thank you.

01:56:54.061 --> 01:56:56.061
)

01:58:04.978 --> 01:58:06.978
   (The session concluded.

01:58:09.426 --> 01:58:11.426
)

01:59:40.046 --> 01:59:42.046
(

01:59:45.304 --> 01:59:47.304
The GOOGLE I/O 2018 session 
What's New 

01:59:48.313 --> 01:59:50.313
in the Android Runtime (ART)

01:59:54.347 --> 01:59:56.347
will begin in approximately 20 
minutes on Stage 2.

01:59:58.362 --> 02:00:00.362
)

02:00:14.533 --> 02:00:16.533
   (Please stand by.

02:00:22.374 --> 02:00:24.620
The GOOGLE I/O 2018 session 
What's New in the Android 

02:00:24.621 --> 02:00:27.320
Runtime (ART) will begin on 
Stage 2 in approximately 20 

02:00:27.321 --> 02:00:29.321
minutes.

02:00:30.348 --> 02:00:32.348
)

02:10:11.966 --> 02:10:12.577
(The GOOGLE I/O 2018 Stage 2 
session What's New in the 

02:10:12.578 --> 02:10:14.578
Android Runtime (ART) 

02:10:15.641 --> 02:10:17.066
will begin in approximately ten 
minutes.  Please continue to 

02:10:17.067 --> 02:10:19.067
stand by.

02:10:20.068 --> 02:10:22.068
)

02:12:41.001 --> 02:12:43.995
(Music playing.)

02:15:47.171 --> 02:15:49.171
(The next Stage 2 session will 
begin 

02:15:50.857 --> 02:15:52.728
in approximately five minutes.  
What's New in the Android 

02:15:52.729 --> 02:15:54.729
Runtime (ART).

02:15:56.346 --> 02:15:58.346
)

02:17:28.284 --> 02:17:33.205
   &gt;&gt; ANNOUNCER:  At this time 
please find your seat.  Our 

02:17:33.206 --> 02:17:35.206
session will begin soon.
   (Music playing.

02:17:36.214 --> 02:17:38.214
)

02:20:39.428 --> 02:20:41.428
   &gt;&gt; MATHIEU CHARTIER:  Hello, 
everyone.

02:20:43.343 --> 02:20:45.592
This is Matthew and this is my 
colleague Calin and today we 

02:20:45.593 --> 02:20:47.593
will be 

02:20:50.782 --> 02:20:52.973
going over what is new on 
Android Runtime, also known as 

02:20:52.974 --> 02:20:58.747
ART.  What is ART?  Well, ART is
the software layer in between 

02:20:58.748 --> 02:21:00.748
the plirks and the operating 
system.

02:21:03.823 --> 02:21:06.468
It provides a mechanism for 
executing Java language and 

02:21:06.469 --> 02:21:08.916
call-in in  applications.
   To accomplish this ART does 

02:21:08.917 --> 02:21:10.917
two things.

02:21:13.092 --> 02:21:14.729
It executes Dex files, the 
intermediate representation of 

02:21:14.730 --> 02:21:16.960
Android applications through a 
hybrid model 

02:21:20.042 --> 02:21:22.042
consisting of the 
interpretation, just 

02:21:23.161 --> 02:21:25.161
in time compilation and profile 
base ahead of time compilation.

02:21:26.649 --> 02:21:28.898
   ART also does memory 
management for 

02:21:32.173 --> 02:21:34.173
Android applications through an 

02:21:35.778 --> 02:21:37.778
automatic recollect  clammation 
through a Garbage Collector.

02:21:40.411 --> 02:21:42.860
This is a concurrent compacting 
garb clang so there is less jank

02:21:42.861 --> 02:21:44.861
in your applications.

02:21:49.403 --> 02:21:52.303
Now, let's look at how ART 
changed over the years.  Over 

02:21:52.304 --> 02:21:54.304
the years there have been many 
improvements to art.

02:21:58.055 --> 02:22:00.055
In Nougat we introduced profile 

02:22:01.104 --> 02:22:02.121
compilation to reduce memory 
usage and reduce storage 

02:22:02.122 --> 02:22:04.122
requirements.

02:22:08.244 --> 02:22:12.138
Also in Nougat we added a git 
must like Dalvik used to have.  

02:22:12.139 --> 02:22:15.640
This was done to remove the need
for optimizing apps.  That was a

02:22:15.641 --> 02:22:17.641
big problem during Android 
system updates.

02:22:23.487 --> 02:22:25.538
And in Oreo we added a new 
concurrent compacting Garbage 

02:22:25.539 --> 02:22:27.539
Collector to have 

02:22:28.789 --> 02:22:31.650
less jank as well as accelerate 
applications.  As you can see on

02:22:31.651 --> 02:22:33.651
the slide this new 

02:22:35.543 --> 02:22:38.187
Garbage Collector enables a now 
bum pointer allocator 17 times 

02:22:38.188 --> 02:22:40.188
faster than 

02:22:41.224 --> 02:22:43.224
the  allocator in Dalvik or 
KitKat.

02:22:44.946 --> 02:22:48.195
Now, we talked about what 
happened in the past.  What's 

02:22:48.196 --> 02:22:51.048
new in Android P?  First of all,
there are new compiler 

02:22:53.304 --> 02:22:56.182
optimization s to help 
accelerate the performance of 

02:22:56.183 --> 02:22:58.183
call-in code in Android.

02:22:59.445 --> 02:23:01.882
This is especially important 
since Kotlins the first class 

02:23:01.883 --> 02:23:04.745
programming language for Android
development.

02:23:08.266 --> 02:23:10.091
Next up, we have memory and 
storage optimizations to help 

02:23:10.092 --> 02:23:12.092
entry level 

02:23:13.767 --> 02:23:15.767
devices such as Android Go  
devices.

02:23:16.878 --> 02:23:19.115
This is important to help 
improve the performance for the 

02:23:19.116 --> 02:23:22.031
next billion users.
   Finally we have cloud 

02:23:22.032 --> 02:23:24.674
profiles.  Device  collected 
profiles from the 

02:23:27.798 --> 02:23:29.658
just in time profiler are 
uploaded and aggregated in the 

02:23:29.659 --> 02:23:31.659
cloud to enable faster 

02:23:32.794 --> 02:23:34.794
performance directly after 
installation of applications.

02:23:35.840 --> 02:23:37.840
   Okay.

02:23:39.517 --> 02:23:41.517
So let's start with Kotlin.

02:23:43.199 --> 02:23:44.868
Last year we announced Kotlin as
the first class officially 

02:23:44.869 --> 02:23:47.128
supported programming language 
for Android 

02:23:50.580 --> 02:23:51.192
development and we began to 
investigate  performance.  Why 

02:23:51.193 --> 02:23:53.193
Kotlin?

02:23:54.256 --> 02:23:56.498
It is a safe,  expressive, 
concise object oriented language

02:23:56.499 --> 02:23:58.499
that is 

02:24:01.027 --> 02:24:03.027
designed to be interoperability 
with Java language.

02:24:06.161 --> 02:24:08.622
The reason ART focuses on 
optimizes Kotlin so the 

02:24:08.623 --> 02:24:10.623
developers can leverage 

02:24:12.269 --> 02:24:14.269
all language features by having 
fast and jank-free applications.

02:24:20.502 --> 02:24:23.794
Let's see how Kotlin oppedzs are
performed outside of Runtime.  

02:24:23.795 --> 02:24:25.430
Usually they are performed in an
investigative manner and there 

02:24:25.431 --> 02:24:29.084
is an order of preference for 
fixing performance issues so 

02:24:29.085 --> 02:24:31.085
that the most 

02:24:32.165 --> 02:24:34.165
amount of Kotlin applications 
can 

02:24:35.437 --> 02:24:37.437
actually benefit from the 
applications.

02:24:44.027 --> 02:24:46.027
The first preamps is call link.

02:24:47.123 --> 02:24:49.123
Google and JetBrains work 
closely 

02:24:51.626 --> 02:24:54.525
together on all implementations 
on fixes issues.  If we fix a 

02:24:54.526 --> 02:24:57.219
performance here it will be able
to be deployed flow the most 

02:24:58.031 --> 02:25:00.031
Kotlin applications.

02:25:01.507 --> 02:25:03.507
Alternatively if that doesn't 
work we 

02:25:05.188 --> 02:25:07.188
consider   fixes the issue 
inside of 

02:25:10.317 --> 02:25:12.172
byte code converts which enables
existing versions of the 

02:25:12.173 --> 02:25:16.052
platform to get the performance 
fix F that option doesn't work, 

02:25:16.053 --> 02:25:18.333
the last operation is to fix the
performance issue in the Android

02:25:20.180 --> 02:25:22.832
Runtime also known as ART.  So 
the reason that we might not 

02:25:22.833 --> 02:25:24.833
want 

02:25:26.119 --> 02:25:27.348
to fix an ART right away, ART is
updated as part of the Android 

02:25:27.349 --> 02:25:30.414
platform.  That means that not 
all devices will get the fix.

02:25:31.433 --> 02:25:35.726
   Now, let's look at an 
example.

02:25:38.393 --> 02:25:40.622
One example of a Kotlin 
optimization is the parameter 

02:25:40.623 --> 02:25:45.332
null check.  As you can see 
here, this is a simple method 

02:25:45.333 --> 02:25:47.333
that just returns the length of 
a 

02:25:49.279 --> 02:25:51.316
string, but the string is 
nullable.  So what this means is

02:25:51.317 --> 02:25:53.317
that the compile 

02:25:54.401 --> 02:25:58.055
Erin certificates a null check 
into the function byte code.  So

02:25:58.056 --> 02:26:00.289
actually verifies that the 
string is not null and throws 

02:26:00.290 --> 02:26:03.339
the corresponding exception if 
required.  Implemented in the 

02:26:03.340 --> 02:26:05.340
bytecode the first step is 
loading the name of the 

02:26:08.261 --> 02:26:10.914
parameter and then invoking a 
separate function to do the 

02:26:10.915 --> 02:26:13.155
actual null check.
   There is some extra overhead 

02:26:13.156 --> 02:26:15.423
here as you might see because 
the invocation in 

02:26:19.304 --> 02:26:20.921
the common case you could the 
extra invocation to do the 

02:26:20.922 --> 02:26:24.813
function to return the null 
check.  If required, they call 

02:26:24.814 --> 02:26:26.814
the third 

02:26:28.904 --> 02:26:32.173
function to throw the parameter 
as a null check.  These are 

02:26:32.174 --> 02:26:34.174
commonly required for Java 

02:26:35.481 --> 02:26:37.481
language and Kotlin 
interoperability 

02:26:39.544 --> 02:26:41.544
because goof language does not 
have null property.

02:26:42.403 --> 02:26:44.403
How can we optimize this?

02:26:45.880 --> 02:26:48.129
If we look at the byte code, we 
can in line the method that does

02:26:48.130 --> 02:26:51.483
the null check into the caller. 
After inlining, this improves 

02:26:51.687 --> 02:26:56.375
performance.  There is one less 
invocation and from here you can

02:26:56.376 --> 02:26:58.376
see one other thing we can 

02:26:59.416 --> 02:27:01.054
do is that the name of the 
parameter is not actually 

02:27:01.055 --> 02:27:03.055
required unless the will 
argument is null.

02:27:05.744 --> 02:27:07.592
So from here we can do code 
syncing to move loading as a 

02:27:07.593 --> 02:27:09.593
parameter name inside the 
conditional.

02:27:12.093 --> 02:27:14.093
The overall these two 
optimization s 

02:27:15.564 --> 02:27:17.564
help performance by removing one
cation 

02:27:21.670 --> 02:27:23.670
and one loadings a string 
literal.

02:27:24.735 --> 02:27:25.949
We also track cot lip 
performance on various 

02:27:25.950 --> 02:27:27.950
benchmarks.

02:27:29.279 --> 02:27:31.972
Other improvements include 
improved opens loops.

02:27:36.303 --> 02:27:38.303
Incontinue sick methods 
taylorred for 

02:27:39.829 --> 02:27:41.829
Kotlin code to enhance 
performance there.

02:27:43.105 --> 02:27:45.105
The Kotlin team is always 
working on this pop answer.

02:27:46.163 --> 02:27:48.163
What about memory and storage 
improvements?

02:27:50.473 --> 02:27:52.473
So since ART is responsibility 
for 

02:27:54.129 --> 02:27:56.129
Java language and Kotlin, it is 

02:27:57.631 --> 02:27:58.220
important that they don't use 
too much mem or space on the 

02:27:58.221 --> 02:28:03.107
device.  There have been several
improvements on this area 

02:28:03.108 --> 02:28:05.108
including the amount of 

02:28:06.436 --> 02:28:08.474
space and memory usage by Dex 
files.

02:28:11.925 --> 02:28:13.925
Now why are Ram and storage 
important 

02:28:15.179 --> 02:28:17.179
in optimization important in 
recall last 

02:28:18.241 --> 02:28:20.241
year we introduced a new 
initiative.

02:28:21.920 --> 02:28:24.571
Android Go on entry level 
devices.  Since these devices 

02:28:24.572 --> 02:28:26.572
typically have one 

02:28:28.057 --> 02:28:29.899
gigabyte or less of Ram and 
eight gigabytes or less of 

02:28:29.900 --> 02:28:31.900
storage, it is kind 

02:28:33.152 --> 02:28:35.405
of important to focus on 
optimizing these areas so the 

02:28:35.406 --> 02:28:37.406
users can run enough 
applications and install as many

02:28:39.085 --> 02:28:40.718
applications or more 
applications than they would 

02:28:40.719 --> 02:28:43.999
otherwise be able to.
   Now, this isn't just for 

02:28:44.000 --> 02:28:48.828
Android Go.  Premium devices 
also benefit from optimization s

02:28:48.829 --> 02:28:50.829
in these two areas.  Since they 
have more resources 

02:28:53.758 --> 02:28:55.758
normally it is to a lesser 
degree.

02:28:57.663 --> 02:28:59.735
Anyway, before we talk about Ram
and storage optimizations, let's

02:28:59.736 --> 02:29:01.736
do a little 

02:29:04.823 --> 02:29:06.695
bit of review on how 
optimization applications work 

02:29:06.696 --> 02:29:10.753
on Android devices.  Application
comes in a package kit known as 

02:29:10.754 --> 02:29:12.754
an APK weds.

02:29:14.865 --> 02:29:16.865
Inside of the APK weds there are
one 

02:29:18.732 --> 02:29:20.557
or more Dalvik executable files 
that ART uses to compile or 

02:29:20.558 --> 02:29:25.070
interpret your application.
   These Dex files are required 

02:29:25.071 --> 02:29:29.174
to be quickly accessed during 
execution.  They are mapped  

02:29:29.175 --> 02:29:31.380
directly into memory during 
application startup so that ART 

02:29:33.038 --> 02:29:35.478
can have quick access.  This 
means that there is a startup 

02:29:37.756 --> 02:29:40.209
cost as well as the Ram cost 
proportional to the size of the 

02:29:40.210 --> 02:29:42.084
Dex file.
   Finally, Dex files are 

02:29:42.085 --> 02:29:45.523
usually stored twice on the 
device.  The first place they 

02:29:45.524 --> 02:29:49.990
are stored is inside of the 
application package kit.  The 

02:29:49.991 --> 02:29:52.222
second place they are stored is 
in an extracted form that ART 

02:29:52.223 --> 02:29:54.223
can have faster access during 
application start 

02:29:57.463 --> 02:29:59.463
up without needing to extract 
from the zip file each time.

02:30:01.150 --> 02:30:05.217
Let's take a closer look at the 
content of Dex files.  Within a 

02:30:05.218 --> 02:30:06.633
Dex file there are several  
sections containing different 

02:30:06.634 --> 02:30:11.526
types of data related to the 
application.  But where is the 

02:30:11.527 --> 02:30:13.527
space going in the Dex file?

02:30:15.989 --> 02:30:18.038
One way to do this is you can 
calculate where the space is 

02:30:18.039 --> 02:30:20.689
going for each Dex file and 
average out the results.

02:30:24.380 --> 02:30:25.812
This chart here is for the top 
99 most downloaded applications 

02:30:25.813 --> 02:30:27.813
in the Play Store.

02:30:31.358 --> 02:30:32.573
You can see the largest is the 
code he can instructions used by

02:30:32.574 --> 02:30:35.646
ART.  The next largest section 
is the string data section.

02:30:38.912 --> 02:30:40.912
This section contains the string

02:30:42.580 --> 02:30:44.617
literals downloaded, class names
and field names combined these 

02:30:44.618 --> 02:30:50.383
two sections are around 64 
percent of the Dex files.  They 

02:30:50.384 --> 02:30:52.384
are pretty important areas to 
optimize.

02:30:53.856 --> 02:30:55.856
Let's see if there is a way we 
can 

02:30:56.990 --> 02:30:58.990
reduce the size of these 
sections.

02:31:00.812 --> 02:31:02.812
One new feature introduced in 
Android P is called CompactDex.

02:31:05.931 --> 02:31:08.365
The golf CompactDex is simple:  
Reduce the size of Dex files to 

02:31:08.366 --> 02:31:12.262
get memory and storage savings 
on the device.  From the 

02:31:12.263 --> 02:31:14.263
previous slide we saw that some 
sections are larger than others.

02:31:16.369 --> 02:31:18.618
So it is important to just focus
on the largest sections to get 

02:31:18.619 --> 02:31:20.619
the most savings.

02:31:23.756 --> 02:31:25.756
Run the code items, there are 
more 

02:31:28.670 --> 02:31:29.901
often deduplicated and have the 
headers shrunk inside of the 

02:31:29.902 --> 02:31:34.193
application.  And another thing 
here worth noting about string 

02:31:34.194 --> 02:31:39.124
data is that large applications 
frequently ship multiple Dex 

02:31:39.125 --> 02:31:41.125
files in their APK because of 
Dex 

02:31:43.210 --> 02:31:45.210
format limitations smekly the 
64K limit 

02:31:47.028 --> 02:31:49.028
means they can only have

02:31:50.161 --> 02:31:51.196
64,000 methods in the Dex files 
before needing another one in 

02:31:51.197 --> 02:31:53.197
the application.

02:31:54.265 --> 02:31:56.499
Every time you add another Dex 
files it causes duplication of 

02:31:56.500 --> 02:31:58.937
string data that otherwise could
be stored only once.

02:32:02.636 --> 02:32:04.866
CompactDex streengs this by 
providing deduplication across 

02:32:04.867 --> 02:32:07.519
the files in APK.
   Now, let's go to the 

02:32:07.520 --> 02:32:09.568
generation process.

02:32:12.842 --> 02:32:15.704
First let's look at how Dex 
files are processed on Oreo.

02:32:19.557 --> 02:32:21.835
The first step run by Dex code 
the ahead of time compiler are 

02:32:21.836 --> 02:32:24.090
that the files are extracted 
from APK and stored 

02:32:30.868 --> 02:32:32.722
in a D Dex filer so they can be 
loaded more efficiently during 

02:32:32.723 --> 02:32:35.575
application start up.  One thing
worth noting is the profile.

02:32:39.442 --> 02:32:41.709
The profile as introduced in 
Nougat is essentially data about

02:32:41.710 --> 02:32:43.710
the application execution 
including which methods are 

02:32:45.187 --> 02:32:47.187
executed during startup, what 
methods 

02:32:49.750 --> 02:32:51.750
are hot or compiled by the git 
compiler and what is loaded.

02:32:54.241 --> 02:32:56.241
On Oreo we are already 
optimizing the 

02:32:59.154 --> 02:33:02.235
files stored in the D Dex 
container by applying.  And 

02:33:02.236 --> 02:33:05.082
which methods to compile based 
on what methods are hottest in 

02:33:05.083 --> 02:33:07.083
the Dex file.

02:33:08.998 --> 02:33:10.998
Now, let's look at Dex 
processing on Android P.

02:33:15.567 --> 02:33:17.567
In Android P, the out of time 
compiler 

02:33:20.065 --> 02:33:20.888
has a more CompactDex by 
representation inside the 

02:33:20.889 --> 02:33:22.889
container.

02:33:25.020 --> 02:33:27.884
One new introduce is the shared 
data section, data present in 

02:33:27.885 --> 02:33:30.341
multiple Dex files will be in 
the shared data files 

02:33:35.029 --> 02:33:36.861
only one it deduplicates data 
common hi shared and one of the 

02:33:36.862 --> 02:33:39.512
most shared is the string data 
which is how we reduce the 

02:33:44.419 --> 02:33:45.843
large string data section we saw
earlier.

02:33:45.844 --> 02:33:47.481
Since this is done on the device
that means that all existing 

02:33:47.482 --> 02:33:52.802
applications get the benefits of
CompactDex without needing to 

02:33:52.803 --> 02:33:57.219
recompilation pile their APKs.
   Okay.  So let's look at one 

02:33:57.220 --> 02:34:00.693
example of how we shrink the Dex
code items.  Apart from the 

02:34:00.694 --> 02:34:03.338
instructions each code item has 
ab 16 bite header and then most 

02:34:05.573 --> 02:34:07.573
of the values in the header are 
usually small values.

02:34:09.884 --> 02:34:11.741
What we do here is we shrink the
field in the header to be four 

02:34:11.742 --> 02:34:14.171
bits each.  We have an optional 
free header to 

02:34:17.690 --> 02:34:19.690
extend them as requiredment.

02:34:21.375 --> 02:34:23.403
The pre-header is zero bytes in 
most cases but can be 12 bytes 

02:34:23.404 --> 02:34:25.404
in the worst case.

02:34:28.267 --> 02:34:29.788
So other than the pre-header, we
also shrink the instruction 

02:34:29.789 --> 02:34:31.789
count.  Since the affirm method 
is not going 

02:34:33.856 --> 02:34:36.141
to be that large we shrink this 
down to 11 bits instead of 32 

02:34:36.142 --> 02:34:38.595
bits and use the five remaining 
bits for flags that are 

02:34:39.410 --> 02:34:42.578
specific.
   Finally we move the debug 

02:34:42.579 --> 02:34:47.678
information into a separate 
space efficient table to help 

02:34:47.679 --> 02:34:49.679
enable more deduplication of the
code items.

02:34:52.020 --> 02:34:54.020
Overall this optimization saves 
around 

02:34:55.090 --> 02:34:57.955
12 bytes per code item in the 
CompactDex file.

02:35:01.423 --> 02:35:05.767
And here are the results for the
top 99 most downloaded APKs.  

02:35:05.768 --> 02:35:08.036
The average space required by 
the Dex times on the device is 

02:35:08.037 --> 02:35:13.746
11.6 percent smaller.  And other
than the stored savings you also

02:35:13.747 --> 02:35:16.201
get memory savings because the 
Dex files are resident in memory

02:35:16.202 --> 02:35:18.202
during application usage.

02:35:20.116 --> 02:35:21.958
At least partially resident 
memory.

02:35:21.959 --> 02:35:23.959
One more thing here.

02:35:25.043 --> 02:35:29.138
Let's go over the late yowt 
optimizations a bit.  Even 

02:35:29.139 --> 02:35:31.817
though we introduced the git 
profiles in Android N we did not

02:35:31.818 --> 02:35:36.293
have any layout optimizations 
back then.  What that means, Dex

02:35:36.294 --> 02:35:38.294
is randomly 

02:35:39.381 --> 02:35:41.381
ordered and not disregarding the
usage pattern.

02:35:44.186 --> 02:35:45.851
In Android O we added this type 
of optimization that groups the 

02:35:45.852 --> 02:35:49.915
methods used during application 
startup toghtd and the methods 

02:35:49.916 --> 02:35:51.916
that are hot that means 

02:35:52.981 --> 02:35:54.981
the code is frequently accessed 
during execution together.

02:35:57.059 --> 02:36:00.141
This seems like a pretty big win
so far.  Let's see what we did 

02:36:00.142 --> 02:36:03.413
for Android P.
   In Android P we have more 

02:36:03.414 --> 02:36:08.110
flexible profile information 
which enables us to put the 

02:36:08.111 --> 02:36:11.001
methods used only during startup
together.  This helps reduce the

02:36:11.002 --> 02:36:14.474
amount of memory used because 
the application or operating 

02:36:14.475 --> 02:36:18.958
system can remove those pages 
from memory after startup.  We 

02:36:18.959 --> 02:36:21.611
also put the hot code together 
since it is frequently accessed 

02:36:21.612 --> 02:36:23.612
during execution.

02:36:25.122 --> 02:36:26.953
Finally we put the code that was
never touched at all during 

02:36:26.954 --> 02:36:28.954
execution at the 

02:36:30.484 --> 02:36:32.484
end so it is not loaded in 
memory unless required.

02:36:34.565 --> 02:36:36.565
The reason that the layout are 

02:36:41.269 --> 02:36:43.269
important, they reduce locality 
and.

02:36:43.700 --> 02:36:45.700
If you improve the locality here
you 

02:36:48.142 --> 02:36:49.969
get startup benefiting here, 
memory, and reduction of memory 

02:36:49.970 --> 02:36:53.246
usage.  Now to Calin for cloud 
profiles.

02:36:53.247 --> 02:37:00.400
(Applause.)
   &gt;&gt; CALIN JURAVLE:  Thank you,

02:37:00.401 --> 02:37:04.088
Matthew.  Hello, everyone.  My 
name is Calin and I'm here today

02:37:04.089 --> 02:37:06.714
to present to you how we plan to
improve 

02:37:09.773 --> 02:37:11.773
and scale up the Android Runtime
profiling infrastructure.

02:37:14.865 --> 02:37:15.896
However before we start 
profiling, is an over  loaded 

02:37:15.897 --> 02:37:17.897
term.

02:37:19.164 --> 02:37:21.164
When we speak about profiling in

02:37:24.033 --> 02:37:26.066
today's presentation we will 
talk about the metadata that is 

02:37:26.067 --> 02:37:29.267
going to be fit into a profile 
guided optimization process.

02:37:31.916 --> 02:37:34.404
We are going to see how we 
extend the on device 

02:37:34.405 --> 02:37:36.405
capabilities in order to drive 

02:37:38.055 --> 02:37:40.055
performance right against all 
time.

02:37:43.162 --> 02:37:48.268
   Before we gum into what is 
new and how actually it works 

02:37:48.269 --> 02:37:50.269
let me briefly 

02:37:51.586 --> 02:37:53.586
remind you how Android juice 
guided profile optimization.

02:37:55.663 --> 02:37:57.663
This is a technique we 
introduced in 

02:37:58.721 --> 02:38:00.721
Android Nougat as part of a 
hybrid execution model.

02:38:02.631 --> 02:38:03.658
That means that the code can be 
in three different optimization 

02:38:03.659 --> 02:38:06.917
states at the same time.
   The primary goal of this 

02:38:06.918 --> 02:38:10.367
technique is to improve all key 
metrics of the application 

02:38:10.368 --> 02:38:13.860
performance.  We are talking 
about faster application tart 

02:38:13.861 --> 02:38:18.368
tup time.  Reduced memory 
footprint.  A better user 

02:38:18.369 --> 02:38:20.434
experience by providing less 
jank during usage.

02:38:24.309 --> 02:38:26.967
Less disk space used by the 
compiler artifact which means 

02:38:26.968 --> 02:38:28.968
more disk space for our users 
and nonetheless increased 

02:38:31.475 --> 02:38:33.475
battery life because we do have 

02:38:34.561 --> 02:38:35.792
optimization when the quia's not
used rather than during the use 

02:38:35.793 --> 02:38:38.247
time.
   How does this work?

02:38:41.299 --> 02:38:43.299
It all starts when the Play 
Store installs the application.

02:38:45.619 --> 02:38:47.246
But first we do very, very light
optimization and we have the 

02:38:47.247 --> 02:38:52.183
application ready to go for the 
user.  But first launch the 

02:38:52.184 --> 02:38:57.683
application will start in what 
we call an interpretation mode. 

02:38:57.684 --> 02:39:00.185
The Runtime executes the 
application code, it discovers 

02:39:00.186 --> 02:39:03.429
the most frequently used method 
and most important methods to be

02:39:03.430 --> 02:39:05.430
optimized.

02:39:07.304 --> 02:39:09.304
That's when a git system kicks 
in that will optimize the code.

02:39:12.257 --> 02:39:14.086
During this time, the JIT system
also records what we call the 

02:39:14.087 --> 02:39:16.087
profile information.

02:39:18.788 --> 02:39:20.403
This profile information 
essentially encapsulate data 

02:39:20.404 --> 02:39:22.847
about the methods that are being
executed and about the classes 

02:39:24.479 --> 02:39:26.327
that are being  loaded.
   Every now and then we dump 

02:39:26.328 --> 02:39:32.492
this profile to disk so that we 
can reuse it later.  Once the 

02:39:32.493 --> 02:39:34.493
device is put aside and is 

02:39:36.987 --> 02:39:39.035
not in use, a stage which we 
call idle maintenance mode, we 

02:39:39.036 --> 02:39:41.036
are going to use 

02:39:42.283 --> 02:39:44.283
the profile to drive profile 
guided optimization.

02:39:46.523 --> 02:39:49.384
The result is an optimized app 
that will eventually replace the

02:39:49.385 --> 02:39:52.446
original state.
   Now, when the user relaunches

02:39:52.447 --> 02:39:54.447
the app 

02:39:57.340 --> 02:39:59.340
it will have a much messier 
startup 

02:40:00.611 --> 02:40:02.844
time, better steady state 
execution and overall the 

02:40:02.845 --> 02:40:04.845
battery will drain less.

02:40:06.332 --> 02:40:08.332
In this state the application 
will be 

02:40:09.646 --> 02:40:11.646
interpreted just in time 
compiled or pre-optimized.

02:40:13.815 --> 02:40:17.557
Now, just how efficient is this 
technique?  We gathered some 

02:40:17.558 --> 02:40:22.483
data from the field for Google 
maps applicants.  Here you can 

02:40:22.484 --> 02:40:24.484
see two charts.

02:40:26.539 --> 02:40:28.539
The left one presents data from 
a marshmallow build.

02:40:31.124 --> 02:40:32.959
You can see the startup time is 
pretty constant over time.  It 

02:40:32.960 --> 02:40:36.624
does not fluctuate.  This is 
pretty much expected.  You don't

02:40:36.625 --> 02:40:38.625
want to have a deviation here 
practice.

02:40:39.077 --> 02:40:41.932
However on the right-hand side 
you can see that in Nougat the 

02:40:41.933 --> 02:40:43.933
startup time drops over time.

02:40:47.656 --> 02:40:49.493
Eventually it stabilizes, being 
about 25 percent faster than it 

02:40:49.494 --> 02:40:54.393
used to be in the install time. 
This is great news.  It means 

02:40:54.394 --> 02:40:56.431
that the more the user uses the 
app, the more we can optimize 

02:40:56.432 --> 02:40:59.114
it.  Over time the performance 
gets better and better.

02:41:03.195 --> 02:41:07.073
   This is great.  But we can do
better and we want to do better.

02:41:10.019 --> 02:41:11.843
There shouldn't be, we shouldn't
need to wait for optimal 

02:41:11.844 --> 02:41:13.844
performance.

02:41:15.940 --> 02:41:18.260
And our goal with cloud profile 
is to deliver near optimal 

02:41:18.261 --> 02:41:22.335
performance right after install 
time without having to wait for 

02:41:22.336 --> 02:41:26.641
the application to be profiled.
   So let's see how this is 

02:41:26.642 --> 02:41:31.733
going to work.  Let me introduce
you to the idea of cloud 

02:41:31.734 --> 02:41:33.734
profile.

02:41:37.109 --> 02:41:39.109
This is based on making two key 
observations.

02:41:41.381 --> 02:41:43.381
First one, is that usually apps 
have 

02:41:44.847 --> 02:41:46.847
many commonly used code paths 
shared 

02:41:48.127 --> 02:41:50.127
between a multitude of users and
devices.

02:41:53.039 --> 02:41:56.283
Take, for example, 
(indiscernible) startup time.  

02:41:56.284 --> 02:41:58.583
Each device will have its own 
specific steps.  However, 

02:41:58.584 --> 02:42:01.472
globally we can extract the 
common intersection of all those

02:42:01.473 --> 02:42:04.712
classes and there is available 
data for us to optimize upon.

02:42:08.620 --> 02:42:10.620
Second we noticed most app 
developers 

02:42:11.929 --> 02:42:13.929
put all of their apps 
incrementally 

02:42:15.190 --> 02:42:17.221
starting with alpha beta 
channels, one, 2 percent of 

02:42:17.222 --> 02:42:19.499
their database.
   The idea behind cloud profile

02:42:19.500 --> 02:42:21.500
is to 

02:42:24.606 --> 02:42:26.025
use this initial set of A beta 
users to bootstrap performance 

02:42:26.026 --> 02:42:28.026
for the rest of the users.

02:42:30.336 --> 02:42:32.336
How is it going to work?

02:42:33.827 --> 02:42:35.670
Once we have an initial set of 
devices, we are going to extract

02:42:35.671 --> 02:42:41.286
the profile information about 
your APK from those devices.  We

02:42:41.287 --> 02:42:45.623
are going to upload that 
information to play.  And there 

02:42:45.624 --> 02:42:48.468
we are going to combine 
everything.  We are going to 

02:42:48.469 --> 02:42:50.534
aggregate whatever comes in and 
we are going to generate 

02:42:53.584 --> 02:42:55.584
what we call oi CORS headers 
application profile.

02:42:57.691 --> 02:42:59.969
This CORS headers profile will 
contain information which is 

02:42:59.970 --> 02:43:02.399
relevant across all device 
executions and not just a single

02:43:02.400 --> 02:43:05.466
one.
   When a new device requests 

02:43:05.467 --> 02:43:10.031
for the application to be 
installed, we are going to 

02:43:10.032 --> 02:43:12.505
deliver this CORS headers 
profile alongside the main 

02:43:12.506 --> 02:43:17.832
application APK to the device.  
Locally, the device will be able

02:43:17.833 --> 02:43:19.833
to 

02:43:22.334 --> 02:43:23.969
use that data to perform profile
guided optimizations right at 

02:43:23.970 --> 02:43:25.970
install time.

02:43:27.673 --> 02:43:29.709
That will deliver and improved 
startup performance and much 

02:43:29.710 --> 02:43:33.402
better steady state performance 
over time.

02:43:37.281 --> 02:43:39.281
Now, having profiles in the 
cloud 

02:43:41.264 --> 02:43:43.264
offers much more opportunities 
than 

02:43:44.401 --> 02:43:46.915
directly inferencing the 
performance with profile guided 

02:43:46.916 --> 02:43:48.916
optimization.

02:43:50.000 --> 02:43:52.446
The CORS headers profile offers 
data, for example for developers

02:43:52.447 --> 02:43:57.323
to act upon.  We believe there 
is enough information there so 

02:43:57.324 --> 02:43:59.975
that developers can tune their 
own application.  We are going 

02:43:59.976 --> 02:44:01.976
to explore how we can share this
data later.

02:44:07.336 --> 02:44:10.193
Now, we can see in this workflow
that to deliver such a thing, we

02:44:10.194 --> 02:44:12.194
need to 

02:44:13.457 --> 02:44:15.457
Android from Android platform 
and play alike.

02:44:17.155 --> 02:44:18.371
Today's presentation we are 
going to focus on the Android 

02:44:18.372 --> 02:44:24.536
platform.
   -- Android P support.  What 

02:44:24.537 --> 02:44:27.212
did we do in P to support this 
lifecycle?  We added new 

02:44:27.213 --> 02:44:29.213
interfaces that will 

02:44:30.509 --> 02:44:31.944
allow us to extract the profile 
and bootstrap the information 

02:44:31.945 --> 02:44:35.405
from the cloud.
   The functionality is 

02:44:35.406 --> 02:44:37.406
available to all 

02:44:39.074 --> 02:44:41.074
system level apps which acquired
the necessary  permissions.

02:44:43.629 --> 02:44:45.629
And in our case play is just a 
consumerrer.

02:44:47.277 --> 02:44:49.943
The two APIs I'm talking about 
are profile extraction and these

02:44:49.944 --> 02:44:51.944
are exposed 

02:44:53.199 --> 02:44:55.199
via a new platform manager 
called ART manager.

02:44:56.271 --> 02:44:58.271
The second API is profile 
installation.

02:45:00.130 --> 02:45:01.985
And this is seemingly integrated
in the current  installer 

02:45:01.986 --> 02:45:04.872
session.  What we did here is to
add a new kind 

02:45:07.923 --> 02:45:09.923
of installation artifact that 
the platform understands.

02:45:14.704 --> 02:45:16.740
We called this Dex metadata 
file.  Essentially in a similar 

02:45:16.741 --> 02:45:18.741
way to the 

02:45:20.251 --> 02:45:22.107
APK, the Dex metadata files are 
archived, which will contain 

02:45:22.108 --> 02:45:24.108
information 

02:45:25.556 --> 02:45:27.556
in how the Runtime can optimize 
the application.

02:45:29.693 --> 02:45:31.960
Initially this Dex metadata 
files will contain the CORS 

02:45:31.961 --> 02:45:33.961
headers profile that I mentioned
about earlier.

02:45:36.098 --> 02:45:38.532
But install time play will 
deliver these files if they are 

02:45:38.533 --> 02:45:43.822
available to the device, where 
they will be streamlined into 

02:45:43.823 --> 02:45:47.928
the Dex optimizer on the device.
   It is worthwhile mentioning 

02:45:47.929 --> 02:45:53.675
that we will offer support for 
Google Play dynamic delivery.  

02:45:53.676 --> 02:45:56.570
So if you plan to split the 
functionality of your 

02:45:56.571 --> 02:46:01.499
application a bit in different 
APKs, all the APKs will have 

02:46:01.500 --> 02:46:06.803
their own Dex metadata file.
   So let's take a look how 

02:46:06.804 --> 02:46:11.216
everything fits together from 
the device perspective.  You 

02:46:11.217 --> 02:46:13.217
remember that I presented this 

02:46:14.484 --> 02:46:16.484
diagram in the beginning, 
showing how 

02:46:17.817 --> 02:46:19.817
the profiling works locally.

02:46:22.677 --> 02:46:24.677
Let's focus here just on the 
profile on the application.

02:46:28.329 --> 02:46:30.328
Once we will give, once we 
manage to capture a profile 

02:46:30.329 --> 02:46:32.524
file, we are going to upload 
this information to play.

02:46:34.969 --> 02:46:37.435
On play, as I mentioned, we will
aggregate the data with many, 

02:46:37.436 --> 02:46:39.879
many other profiles.  When we 
have a CORS headers profile we 

02:46:43.352 --> 02:46:45.352
are going to deliver it for new 
users as a CORS headers profile.

02:46:53.000 --> 02:46:57.309
The idea of the COR profile is 
not to place on device.  It is 

02:46:57.310 --> 02:46:59.310
only for optimization.

02:47:00.379 --> 02:47:02.213
Instead of starting with a 
completed blank state about the 

02:47:02.214 --> 02:47:04.214
application, we 

02:47:05.903 --> 02:47:07.528
already know what are the most 
commonly used paths and start 

02:47:07.529 --> 02:47:09.529
the optimization Z from there.

02:47:12.423 --> 02:47:14.423
So now essentially what was a 
pure 

02:47:16.319 --> 02:47:17.747
on-device profile, it is just 
extended to the cloud  

02:47:17.748 --> 02:47:19.748
component.

02:47:25.494 --> 02:47:27.494
Now, I keep talking about this 
COR profile.

02:47:28.784 --> 02:47:31.648
It is important to dedicate a 
bit more attention to  it.  So 

02:47:31.649 --> 02:47:34.109
let's talk a bit how we are 
going to build it.

02:47:37.596 --> 02:47:40.244
We already know that on device 
from one execution to the other,

02:47:40.245 --> 02:47:42.475
the profile is aggregating quite
well.

02:47:45.766 --> 02:47:48.410
They reach a safe point pretty 
fast.  That means it will not 

02:47:48.411 --> 02:47:50.462
re-optimize the application over
and over and over again.

02:47:53.319 --> 02:47:55.319
After a few optimization steps 
we will stop.

02:47:57.249 --> 02:48:00.107
However, the data from one 
device, how well that works when

02:48:00.108 --> 02:48:03.154
you try to do it across devices?
How many samples you will need 

02:48:03.155 --> 02:48:07.838
to order to get to a robust, 
reliable profile?

02:48:11.099 --> 02:48:12.932
We looked at our own Google 
applications and tried to figure

02:48:12.933 --> 02:48:14.933
that out.

02:48:17.030 --> 02:48:19.477
Here you can see a plot which 
represents the amount of 

02:48:19.478 --> 02:48:22.140
information in the core profile 
relative to the total 

02:48:25.184 --> 02:48:27.184
number of obligations.

02:48:29.049 --> 02:48:31.716
The Y axis represents the amount
of information and the actual 

02:48:31.717 --> 02:48:36.002
value, merit value is not 
important there.  What is 

02:48:36.003 --> 02:48:38.003
important from this graph is 

02:48:40.711 --> 02:48:43.568
that actually from 20, 30 kind 
of number of profile 

02:48:43.569 --> 02:48:45.569
aggregations, the information 

02:48:47.041 --> 02:48:49.072
in the profile reaches a 
plateau.  And that is very 

02:48:49.073 --> 02:48:51.337
important.  It sends a very 
important message.

02:48:56.037 --> 02:48:58.682
It means that the alpha beta 
channel uses will provide us 

02:48:58.683 --> 02:49:00.683
with enough data to build a CORS
headers  profile.

02:49:03.586 --> 02:49:05.205
It means the majority of the 
profile users of your 

02:49:05.206 --> 02:49:07.206
application will always 

02:49:09.931 --> 02:49:11.931
have the best possible 
experience.

02:49:13.609 --> 02:49:15.644
So how do we actually aggregate 
the information?

02:49:18.729 --> 02:49:20.729
I mentioned before that in the 
profile 

02:49:22.030 --> 02:49:25.069
you will find information about 
classes and method.  On device 

02:49:25.070 --> 02:49:27.110
this is roughly how it looks 
like.  We are going to take all 

02:49:27.111 --> 02:49:31.413
the executions that we have seen
before and we will create a 

02:49:31.414 --> 02:49:33.414
union of everything that is 
seen.

02:49:35.539 --> 02:49:37.601
In the aggregated profile you 
will have information about 

02:49:37.602 --> 02:49:39.602
classes, methods 

02:49:40.898 --> 02:49:42.898
about everything that you've 
seen.

02:49:44.999 --> 02:49:46.999
On cloud, however, we don't  
really want everything.

02:49:50.259 --> 02:49:52.336
We only want the common executed
path and what we are doing 

02:49:52.337 --> 02:49:56.277
instead of having a union, we 
will be having a smart 

02:49:56.278 --> 02:50:00.564
intersection.  We will be only 
keeping the information relevant

02:50:00.565 --> 02:50:03.459
to all executions.
   Meaning we are going to 

02:50:03.460 --> 02:50:05.703
filter out all the outliers.

02:50:09.568 --> 02:50:11.568
The result is what we call the 
COR 

02:50:12.647 --> 02:50:15.304
profile which only keeps the 
most common samples.  That is 

02:50:15.305 --> 02:50:17.337
what is going to get eventually 
to the device.

02:50:19.975 --> 02:50:21.975
How well does this work?

02:50:23.275 --> 02:50:25.275
Let's look again at data 
captured from Google app.

02:50:28.569 --> 02:50:30.177
We look at this across a variety
of applications and here are 

02:50:30.178 --> 02:50:32.178
some representative ones.

02:50:35.687 --> 02:50:37.542
In this step you can find 
examples on native code, for 

02:50:37.543 --> 02:50:39.543
example Google camera.

02:50:41.677 --> 02:50:43.677
Or applications which have are 
much more Java oriented.

02:50:46.348 --> 02:50:48.385
Say Google maps or Google Docs. 
For Google camera, for example, 

02:50:48.386 --> 02:50:50.386
you 

02:50:51.902 --> 02:50:54.340
get startup time improvement of 
12.6 percent which is excellent 

02:50:54.341 --> 02:50:57.847
even if the application itself 
doesn't have a lot of Java code.

02:51:00.899 --> 02:51:02.916
However for maps or docs, 
heavily Java based you can see 

02:51:02.917 --> 02:51:04.917
the optimizations 

02:51:06.011 --> 02:51:08.011
improves the startup time by 
about 28 percent or 43 percent.

02:51:08.654 --> 02:51:13.764
   Across the border you can see
an average of about 20 percent 

02:51:13.765 --> 02:51:17.819
improvement and that obviously 
depends on what the application 

02:51:17.820 --> 02:51:19.820
is doing, how much Java code is 
being used and so on.

02:51:25.993 --> 02:51:28.452
Now, I mentioned in the 
beginning that besides improving

02:51:28.453 --> 02:51:30.453
the application 

02:51:33.066 --> 02:51:35.128
performance directly via profile
guided optimization, the profile

02:51:35.129 --> 02:51:39.429
offers much more opportunities. 
I am going to present a short 

02:51:39.430 --> 02:51:44.514
use case study and walk you 
through some important aspects 

02:51:44.515 --> 02:51:46.968
that the profile can reveal 
about your application.

02:51:49.458 --> 02:51:52.313
During the use case study I'm 
going to focus on a single 

02:51:52.314 --> 02:51:54.314
question:  Are you 

02:51:55.365 --> 02:51:57.365
shipping unnecessary code to the
client?

02:51:58.438 --> 02:52:03.352
Are you?
   Let's take a look at some 

02:52:03.353 --> 02:52:05.353
data.

02:52:08.042 --> 02:52:10.042
Again, this case study reflects 
the 

02:52:13.517 --> 02:52:15.517
state of some Google.

02:52:17.273 --> 02:52:19.273
On profile we average 14, 15 
percent 

02:52:20.736 --> 02:52:24.000
of the code and 85 percent of 
the code remains unprofiled.  

02:52:24.001 --> 02:52:26.306
When you spread the 
distribution, for example, some 

02:52:26.307 --> 02:52:28.307
maps five to 10 percent of 

02:52:30.591 --> 02:52:32.613
the code gets profiled and some 
others 60 percent of the code 

02:52:32.614 --> 02:52:34.614
gets profiled.

02:52:36.290 --> 02:52:38.290
This is a rather intriguing 
result.

02:52:39.385 --> 02:52:41.385
And the reason for that is that 
if the 

02:52:43.100 --> 02:52:44.974
code is not  profiled, most 
likely that means that it might 

02:52:44.975 --> 02:52:47.189
not have been execute the.

02:52:50.293 --> 02:52:53.137
Obviously that is for a good 
case.  I mean, the code, for 

02:52:53.138 --> 02:52:55.398
example, can be unexpected error
codes path, right?

02:52:58.678 --> 02:53:00.731
We all want the applications to 
be reliable and robust and the 

02:53:00.732 --> 02:53:03.386
error handling must be there.  
Hopefully it never gets 

02:53:03.387 --> 02:53:08.518
executed.  You may have backward
compatibility code, support for 

02:53:08.519 --> 02:53:10.759
previous API level and such.  
You may have features which are 

02:53:10.760 --> 02:53:12.760
not 

02:53:15.486 --> 02:53:17.486
used on all devices and have 
very features targeted.

02:53:18.989 --> 02:53:22.478
And you might also have a lot of
unnecessary code lying around.  

02:53:22.479 --> 02:53:27.863
Maybe including libraries that 
you don't really use.  Now, it's

02:53:27.864 --> 02:53:32.968
a bit hard to breakdown the 
percentage for this categories. 

02:53:32.969 --> 02:53:34.969
There can be other reasons why 
we didn't profile the code.

02:53:37.435 --> 02:53:40.305
But the key distribution here is
a strong indication there is a 

02:53:40.306 --> 02:53:42.546
lot of room for improvement for 
APK.

02:53:45.835 --> 02:53:47.679
The code can be reorganized or 
cleaned down for better 

02:53:47.680 --> 02:53:49.680
efficiency.

02:53:52.644 --> 02:53:54.692
For example, Google Play 
introduced dynamic delivery 

02:53:54.693 --> 02:53:56.727
scheme which may help you reduce
the code that you share by 

02:53:59.167 --> 02:54:01.033
targeting features only to 
certain users and that's 

02:54:01.034 --> 02:54:05.337
something you might want to look
at and take advantage of.

02:54:07.372 --> 02:54:10.003
So we believe that there is 
quite a bit of unnecessary code 

02:54:10.004 --> 02:54:12.004
lying around, at 

02:54:13.459 --> 02:54:16.314
least in our own APK.  Now, 
since we focused on the code 

02:54:16.315 --> 02:54:18.357
that  actually doesn't get 
profiled, is there 

02:54:22.476 --> 02:54:25.562
anything that we can extract out
of the profile code?

02:54:28.835 --> 02:54:31.060
To understand this, let me talk 
a bit about different categories

02:54:31.061 --> 02:54:34.987
of profile code.  When the 
application code is being 

02:54:38.020 --> 02:54:39.282
profiled, the Runtime will try 
to label it depending on its 

02:54:39.283 --> 02:54:44.971
state.  It will have a label for
the startup category.  For the 

02:54:44.972 --> 02:54:48.245
post startup category and for 
the hot category.  Obviously 

02:54:48.246 --> 02:54:50.687
these are self-explanatory.  The
hot category of the code is 

02:54:53.680 --> 02:54:56.318
essentially what the Runtime 
deems to be the most important 

02:54:56.319 --> 02:54:58.319
part of your code.

02:54:59.324 --> 02:55:01.324
It is important to keep in mind 
that these are not disjoined.

02:55:03.620 --> 02:55:05.620
Say, for example, that the 
method  Fu 

02:55:07.274 --> 02:55:09.274
is being skewed, either during 
startup 

02:55:10.318 --> 02:55:12.974
or executed during post startup 
time and also marked as hot, for

02:55:12.975 --> 02:55:14.975
example if you 

02:55:17.263 --> 02:55:19.263
have very heavy usage during 
that method.

02:55:19.748 --> 02:55:22.216
If you know the code executed 
during startup time, if you 

02:55:22.217 --> 02:55:25.909
focus on that you will be able 
to lower the startup time of the

02:55:25.910 --> 02:55:27.910
application.

02:55:29.909 --> 02:55:32.562
That is the impression that your
users will have of your 

02:55:32.563 --> 02:55:35.767
application will be very good.  
If you start with the post 

02:55:35.768 --> 02:55:37.768
startup 

02:55:40.262 --> 02:55:42.911
code that will help you lay out 
the Dex bicode.  That will lead 

02:55:42.912 --> 02:55:47.581
to memory improvement and much 
smoother on the device.

02:55:50.242 --> 02:55:52.302
But for the hot code, this is 
the code that should get the 

02:55:52.303 --> 02:55:54.303
most attention 

02:55:55.364 --> 02:55:57.364
for your optimization efforts.

02:56:01.638 --> 02:56:03.522
It is the code that is most 
heavy heavily executed by the 

02:56:03.523 --> 02:56:08.210
Runtime.  The Runtime deems it 
is very beneficial using that 

02:56:08.211 --> 02:56:12.685
time there.  For  example, if 
you start with that, you try to 

02:56:12.686 --> 02:56:14.920
improve the quality and 
performance of your app, this is

02:56:14.921 --> 02:56:16.921
where 

02:56:18.414 --> 02:56:20.414
you should spend your effort, 
initial effort.

02:56:21.080 --> 02:56:23.539
This is important, how much of 
your code is actually being 

02:56:23.540 --> 02:56:25.540
marked as hot.

02:56:26.593 --> 02:56:28.842
If everything is  hot, then 
everything can be optimized, 

02:56:28.843 --> 02:56:31.290
which is not really useful.

02:56:35.559 --> 02:56:37.559
Let me show you the breakdown of
these three categories.

02:56:40.459 --> 02:56:42.459
In this graph, you can see on 
the red 

02:56:43.731 --> 02:56:46.006
column the percentages for the 
profile code and the not profile

02:56:46.007 --> 02:56:48.007
code.

02:56:49.069 --> 02:56:51.087
This will sum up to 100 percent 
and it is what I showed you 

02:56:51.088 --> 02:56:55.568
earlier.  They are here just for
references.  The blue boxes show

02:56:55.569 --> 02:56:57.569
the percentages of 

02:56:58.840 --> 02:57:00.840
the startup code, the post 
startup code 

02:57:02.059 --> 02:57:06.524
and hot one relative to the Dex 
bicode.  Don't expect it to add 

02:57:06.525 --> 02:57:09.206
to 100 percent.  One piece of 
code can be in different 

02:57:10.246 --> 02:57:12.246
categories at the same time.

02:57:13.528 --> 02:57:16.183
As you can see here, the 
average, on average about 10 

02:57:16.184 --> 02:57:18.184
percent of the 

02:57:19.848 --> 02:57:22.693
application Dex bytecode is 
being marked as hot.  This 

02:57:22.694 --> 02:57:24.694
indicates that when you focus on

02:57:25.744 --> 02:57:27.777
your app optimization, you can 
dedicate attention only starting

02:57:27.778 --> 02:57:32.449
with just a small part of your 
application code base.  

02:57:32.450 --> 02:57:34.450
Obviously if you spend time on 
all the 

02:57:35.503 --> 02:57:37.503
other parts as well, but this is
where you should start from.

02:57:45.902 --> 02:57:47.951
With this let me go over a quick
review of what we presented 

02:57:47.952 --> 02:57:49.952
today.

02:57:51.016 --> 02:57:53.016
And the main benefits.

02:57:55.093 --> 02:57:57.536
We started with Kotlin and we 
described few optimization s we 

02:57:57.537 --> 02:58:02.621
added that focused on Kotlin 
performance.  We described 

02:58:02.622 --> 02:58:05.294
briefly how we approach Kotlin 
optimizations and that we first 

02:58:08.154 --> 02:58:10.779
tried to seek improvement in the
Kotlin compiler.

02:58:14.255 --> 02:58:16.255
We moved to memory and storage 
optimizations.

02:58:17.909 --> 02:58:19.938
My colleague Matthew introduced 
you to the concept of exact 

02:58:19.939 --> 02:58:21.939
desks.

02:58:23.615 --> 02:58:26.073
This is a new Dex format 
available just on device and 

02:58:26.074 --> 02:58:31.773
focuses on the memory saving.
   And finally, I presented you 

02:58:31.774 --> 02:58:36.064
the idea of cloud profile.  And 
we talk about how we can 

02:58:36.065 --> 02:58:38.065
bootstrap 

02:58:39.972 --> 02:58:41.972
the profile guided optimizations
using a 

02:58:43.845 --> 02:58:46.521
small percentage of alpha beta 
channel users in order to lead 

02:58:46.522 --> 02:58:48.750
important performance 
improvements right after 

02:58:52.703 --> 02:58:55.186
start time for the majority of 
the production  users.

02:58:56.804 --> 02:58:58.441
With this I would like to thank 
you for your attention and four 

02:58:58.442 --> 02:59:00.442
your presence.

02:59:02.713 --> 02:59:04.342
And I want to invite you all to 
Android Runtime office hours 

02:59:04.343 --> 02:59:08.392
tomorrow where we can answer any
questions you have about today's

02:59:08.393 --> 02:59:10.393
presentation or Runtime in 
general.

02:59:12.926 --> 02:59:14.798
We are going to be half past 5 
in section A.

02:59:14.799 --> 02:59:16.799
Thank you so much.
   (Applause.

02:59:18.006 --> 02:59:20.006
)

02:59:25.645 --> 02:59:27.645
   (Music playing.

02:59:28.649 --> 02:59:30.649
)

02:59:44.701 --> 02:59:46.701
   &gt;&gt; ANNOUNCER:  Thank you for 
joining this session.

02:59:50.696 --> 02:59:52.514
Brand ambassadors will assist 
with through the designated 

02:59:52.515 --> 02:59:56.198
exits.  We will make room for 
those who registered for the 

02:59:56.199 --> 03:00:01.290
next session.  If you registered
for the next session in this 

03:00:01.291 --> 03:00:04.119
room we ask that you clear the 
room and return to the 

03:00:04.120 --> 03:00:06.120
registration line outside.  
Thank you.

03:00:16.776 --> 03:00:18.776
(The session concluded.

03:00:19.801 --> 03:00:21.801
)

03:07:22.345 --> 03:07:24.345
The Stage 2 session Drawn Out: 
How 

03:07:26.220 --> 03:07:26.844
Android Renders the UI will 
begin in approximately 13 

03:07:26.845 --> 03:07:28.845
minutes.

03:07:29.863 --> 03:07:31.863
)

03:12:12.233 --> 03:12:14.233
(Music playing.

03:12:15.281 --> 03:12:17.281
)

03:12:30.649 --> 03:12:32.649
(Standing by for the GOOGLE I/O 
2018 

03:12:33.665 --> 03:12:36.034
Stage 2 session Drawn Out: How 
Android Renders the UI.

03:12:39.058 --> 03:12:41.058
)

03:16:44.543 --> 03:16:46.543
(Music playing.

03:16:47.545 --> 03:16:49.545
)

03:17:32.013 --> 03:17:34.044
   &gt;&gt; ANNOUNCER:  At this time, 
please find your seat.

03:17:37.522 --> 03:17:39.522
Our session will begin soon.

03:19:24.467 --> 03:19:26.467
(The session is about to begin.

03:19:27.476 --> 03:19:29.476
)

03:20:45.793 --> 03:20:47.639
&gt;&gt;&gt; hi, welcome to our talk four
Drawn Out: How Android Renders 

03:20:47.640 --> 03:20:49.483
the UI.
   Somebody in some position 

03:20:49.484 --> 03:20:55.010
decided it was  actually going 
to be called how to optimize 

03:20:55.011 --> 03:20:58.267
your app for top rendering 
performance or something.  That 

03:20:58.268 --> 03:21:01.567
wasn't what the talk was about. 
We changed it back.  Instead we 

03:21:01.568 --> 03:21:03.405
are going to tell you the 
details of how actually stuff 

03:21:03.406 --> 03:21:05.406
works.

03:21:06.684 --> 03:21:12.368
I'm Chet Haase from the Android 
toolkit and I'm Romaine guy.  I 

03:21:12.369 --> 03:21:13.394
do realtime graphics.
   &gt;&gt; CHET HAASE:  That is kind 

03:21:13.395 --> 03:21:16.863
of what we are doing that.  We 
have given ergs veries of this 

03:21:16.864 --> 03:21:20.944
talk before and thought we were 
done and realized enough stuff 

03:21:20.945 --> 03:21:24.611
has changed inside the system, 
maybe it's time to go through 

03:21:24.612 --> 03:21:26.612
this again and see where we're 
at.

03:21:26.882 --> 03:21:28.882
This is our attempt to do that. 
Let's go.

03:21:30.786 --> 03:21:32.613
So first of all there is this 
word rendering.  What do we mean

03:21:32.614 --> 03:21:34.614
by that?

03:21:37.735 --> 03:21:40.575
Normally it means melting fat in
order to clarify it.  That is 

03:21:40.576 --> 03:21:42.576
not what we are talking about.

03:21:44.470 --> 03:21:46.937
We are talking about the actual 
process of turning the check 

03:21:46.938 --> 03:21:51.865
boxes and everything into pixels
that users can look at.  There 

03:21:51.866 --> 03:21:53.886
are a lot of details we are 
glossing over today because we 

03:21:53.887 --> 03:21:57.216
only have 40 minutes to do this.
   But we'll dump a lot of 

03:21:57.217 --> 03:22:00.270
details on you along the way.
   First of all, I'm going to 

03:22:00.271 --> 03:22:02.914
take you through.  There will be
a bunch of colored dots 

03:22:06.842 --> 03:22:08.842
on the top, a visual cue for the
rest of 

03:22:10.504 --> 03:22:12.542
the talk m I'll walk through the
life of what happens to the flow

03:22:12.543 --> 03:22:14.578
of pixels on the screen.  We 
have the choreographer.

03:22:17.866 --> 03:22:20.518
That kibes in usually 60 times a
second and says hey, Vsync this 

03:22:20.519 --> 03:22:24.777
is the interval at which the 
frame is being synced.  Buffers 

03:22:24.778 --> 03:22:27.277
flip on to the screen.  It's a 
good time for us to process a 

03:22:29.276 --> 03:22:31.270
lot of information and handle 
rendering that information as a 

03:22:31.271 --> 03:22:33.271
result of that.
   We get a Vsync operation.

03:22:36.630 --> 03:22:39.089
That is sent up to the Java DSM 
land and we are on the UI 

03:22:39.090 --> 03:22:43.592
thread.  All of a sudden we need
to process input events  

03:22:43.593 --> 03:22:45.593
triggering changes in 
properties.

03:22:46.846 --> 03:22:48.846
We need to run anti-animation.

03:22:51.113 --> 03:22:53.113
That may trigger things like 
layout and validation.

03:22:55.178 --> 03:22:57.022
We do the whole Traversal path, 
measuring views to see how large

03:22:57.023 --> 03:23:00.927
they are, laying them out, 
positioning them where they need

03:23:00.928 --> 03:23:02.928
to be and drawing them.  Once 
all of that information is done 

03:23:04.384 --> 03:23:06.628
we sync the result of that 
information over to the thing 

03:23:06.629 --> 03:23:09.890
called the render thread.
   And the render thread takes 

03:23:09.891 --> 03:23:11.891
that and 

03:23:12.955 --> 03:23:14.955
says, okay, I'm going to then 
execute these.

03:23:16.620 --> 03:23:19.294
I'm going to basically turn 
these into native versions of 

03:23:19.295 --> 03:23:24.163
all that information we produced
at the Java layer and going to 

03:23:24.164 --> 03:23:25.379
get a buffer from the GPU so I 
have a place to write this 

03:23:25.380 --> 03:23:27.853
information.  Then I'm going to 
actually issue all 

03:23:31.774 --> 03:23:35.112
these GPU commands, the OpenGL 
stuff over there.  I swap the 

03:23:35.113 --> 03:23:37.596
buffer and turn it over to the 
GPU and the graphic system does 

03:23:39.868 --> 03:23:42.552
something called compositing.
   &gt;&gt; ROMAIN GUY:  Compositing 

03:23:42.553 --> 03:23:46.259
is something we never explained 
before.  We will go know a 

03:23:46.260 --> 03:23:48.737
little bit of detail about this 
part of the rendering 

03:23:50.184 --> 03:23:50.789
architecture.
   &gt;&gt; CHET HAASE:  The colored 

03:23:50.790 --> 03:23:55.093
dots on the top of the screen 
will be denoting where we are in

03:23:55.094 --> 03:23:57.581
the process as we work through a
few examples.

03:23:59.608 --> 03:24:01.458
Here is a simple example.  
Suppose that we have a user and 

03:24:01.459 --> 03:24:05.119
the user clicks on an item.  I 
wrote this awesome recycler view

03:24:07.152 --> 03:24:09.406
application that looks exact lie
like this.  I know it is because

03:24:09.407 --> 03:24:11.407
that's a screen shot from my 
awesome application.

03:24:13.876 --> 03:24:15.876
It is a recycler view with a 
bunch of items in it.

03:24:18.153 --> 03:24:20.153
When the user clicks on one an 
amazing thing happens.

03:24:21.689 --> 03:24:23.690
It turns to a random color on 
the background.  It's 

03:24:23.691 --> 03:24:26.350
incredible.  I could give you 
the source but it's complicated.

03:24:28.395 --> 03:24:29.602
I'm not sure you would 
understand it.

03:24:29.603 --> 03:24:31.603
Here is the layout.

03:24:33.284 --> 03:24:35.917
There is a constraint lout, a 
recycler view and populated in 

03:24:35.918 --> 03:24:38.169
Runtime with random items in 
there.

03:24:41.620 --> 03:24:43.465
The view hierarchy looks 
basically like this.  No, 

03:24:43.466 --> 03:24:49.030
exactly like this.  You work 
down from the deCOR view and you

03:24:49.031 --> 03:24:50.863
have the framelayout, I'm not 
sure why we have the deep 

03:24:50.864 --> 03:24:53.723
nesting there, whatever history.
We have a bunch of stuff for 

03:24:53.724 --> 03:24:56.888
action bar in there.  None of 
that matters.  What we are 

03:24:56.889 --> 03:24:59.369
concerned about here, what is 
actually going in the content 

03:24:59.577 --> 03:25:02.419
hierarchy.  That's what you can 
affect with your application.

03:25:03.834 --> 03:25:08.334
   We have constraintlayout and 
all of the items, specifically 

03:25:08.335 --> 03:25:11.788
these are the items on screen 
because those are the only ones 

03:25:11.789 --> 03:25:14.873
that are actually being measured
and laid out and drawn.

03:25:15.064 --> 03:25:19.345
All right.  So what happens?  
Let's walk through this example 

03:25:19.346 --> 03:25:22.408
and walk through the entire flow
that we went through at the 

03:25:22.409 --> 03:25:26.072
beginning.  User clicks.  
There's a Vsync operation.  That

03:25:26.073 --> 03:25:29.949
gets sent up.  We process input.
During the input phase we notice

03:25:29.950 --> 03:25:34.754
that this is a click.  I'm 
glossing over details here.  

03:25:34.755 --> 03:25:37.212
Actually we will notice first 
there was a down and then an up 

03:25:37.213 --> 03:25:40.700
and then processed as a click.  
Take it for granted eventually 

03:25:40.701 --> 03:25:42.738
we are going to process a click 
here.

03:25:45.194 --> 03:25:48.052
That ends up in this item click 
methods I have in this amazingly

03:25:48.053 --> 03:25:53.267
complex example.  We are going 
to set the background color to a

03:25:53.268 --> 03:25:55.531
random color.  That's why I 
called the method random.

03:25:58.797 --> 03:26:00.797
That gets sent over to the set 

03:26:01.866 --> 03:26:03.866
background color in Java that 
does a 

03:26:04.919 --> 03:26:07.408
bunch of stuff to set the color 
on the pack ground drawable and 

03:26:07.409 --> 03:26:10.684
calls this railed date.  
Invalidation is a process, it 

03:26:10.685 --> 03:26:12.685
doesn't redraw the views.

03:26:14.590 --> 03:26:16.217
It's telling the view hierarchy 
that something needs to be 

03:26:16.218 --> 03:26:18.218
redrawn.
   So you get a click.

03:26:20.543 --> 03:26:23.611
That happens on the item down at
the bottom.  So that item 2, you

03:26:23.612 --> 03:26:26.115
see it surrounded by green.  We 
have a little invalidate method 

03:26:27.166 --> 03:26:31.474
that gets called on that.  That 
basically walks up the tree.  

03:26:31.475 --> 03:26:33.475
Calls a series of methods all 
the way up the tree.

03:26:35.554 --> 03:26:37.554
The view knows that it needs to 
be redrawn but to propagate that

03:26:39.443 --> 03:26:41.483
information all the way up the 
hierarchy so we can redraw all 

03:26:41.484 --> 03:26:43.945
the things on the way down 
later.

03:26:45.969 --> 03:26:47.969
We call invalidate child all the
way 

03:26:49.238 --> 03:26:51.238
up the hierarchy ending up in a 
massive 

03:26:54.140 --> 03:26:57.262
class we have called U root 
input.Java.  We have the child 

03:26:57.263 --> 03:26:59.731
there which does nothing except 
say I need to schedule a 

03:27:02.420 --> 03:27:04.465
Traversal, which means I got 
information that somebody 

03:27:04.466 --> 03:27:06.466
invalidated somewhere.

03:27:07.953 --> 03:27:09.389
That means I need to run my 
Traversal code later in the 

03:27:09.390 --> 03:27:11.045
process.
   Traversal is the process of 

03:27:11.046 --> 03:27:13.728
doing all of the phases 
necessary for actuallying 

03:27:14.555 --> 03:27:16.585
rendering that frame.  
Specifically it does measure, 

03:27:16.586 --> 03:27:18.586
how big 

03:27:20.265 --> 03:27:22.265
the views are; lay out, setting 
the 

03:27:24.744 --> 03:27:26.821
views, position and size, and 
draw the views, scheduling a 

03:27:26.822 --> 03:27:28.880
Traversal.
   That will happen at some 

03:27:28.881 --> 03:27:32.168
later time and that later time 
is now.  In the same frame we 

03:27:32.169 --> 03:27:34.855
end up in the Traversal code in 
this perform Traversals method.

03:27:37.913 --> 03:27:39.913
It is going to do a perform draw
which 

03:27:41.430 --> 03:27:43.901
ends up calling a draw view on 
to core view and that will 

03:27:43.902 --> 03:27:46.760
propagate all the way down.  The
draw method actually ends up in 

03:27:46.761 --> 03:27:48.761
an 

03:27:51.701 --> 03:27:53.114
optimization that we implemented
back in.

03:27:53.115 --> 03:27:55.576
&gt;&gt; ROMAIN GUY:  Honeycomb?
   &gt;&gt; CHET HAASE:  A display 

03:27:55.577 --> 03:28:00.083
list which stores the rendering 
information.  If you look at the

03:28:00.084 --> 03:28:02.322
way the button code is written 
or view code in general we 

03:28:05.779 --> 03:28:08.448
call graphics commands in van 
vast, I don't know, drawable, 

03:28:08.449 --> 03:28:11.495
draw a line or whatever, but 
these end up as operations in a 

03:28:11.496 --> 03:28:16.787
display list.  This is a compact
way of representing those 

03:28:16.788 --> 03:28:18.206
operations as well as the 
parameters through the 

03:28:18.207 --> 03:28:22.481
operations.
   So we call get display list. 

03:28:22.482 --> 03:28:24.929
The DecorView did not change.  
It is going to say I didn't 

03:28:24.930 --> 03:28:29.878
change but I can certainly get 
the display list from my child 

03:28:29.879 --> 03:28:31.910
and all the way down the tree 
until it gets to item two and 

03:28:31.911 --> 03:28:35.781
says oh, I did change.  When 
invalidate was called on me that

03:28:38.619 --> 03:28:40.619
triggered something so I know I 
need to redraw myself.

03:28:46.194 --> 03:28:47.870
Get display list is a draw view 
so it generates its own display 

03:28:47.871 --> 03:28:49.871
list.

03:28:50.936 --> 03:28:53.840
It ends up in the draw method 
and that ends up in the display 

03:28:53.841 --> 03:28:55.841
list for that.

03:28:57.140 --> 03:28:59.209
For this item, basically react 
information and text information

03:28:59.210 --> 03:29:03.084
and pretty basic.  We have the 
display list for the entire 

03:29:03.085 --> 03:29:05.529
hierarchy.  It wasn't just the 
view itself but we 

03:29:10.230 --> 03:29:11.869
have the view hierarchy itself 
is in the display list all the 

03:29:11.870 --> 03:29:16.823
way down.  We have the display 
list for the entire tree.  

03:29:16.824 --> 03:29:18.824
That's all we need to do on the 
UI thread.

03:29:19.449 --> 03:29:21.480
We need to sync that to the 
render thread, a separate thread

03:29:21.481 --> 03:29:25.792
actually dealing with the GPU 
side of this operation.  On the 

03:29:25.793 --> 03:29:28.043
Java side we produced all the 
information.  On the native side

03:29:28.044 --> 03:29:30.706
we  actually produce, we take 
that information and sync it 

03:29:30.707 --> 03:29:33.992
over to the GPU.
   So we have the sync operation

03:29:33.993 --> 03:29:38.681
where basically we copy a handle
over there.  And we also copy 

03:29:38.682 --> 03:29:40.935
some related information.  We 
copy the damage area because it 

03:29:40.936 --> 03:29:45.084
is important to know that that 
item 2, that's the only thing 

03:29:45.085 --> 03:29:49.011
that changed during that frame, 
which means we don't need to 

03:29:49.012 --> 03:29:51.657
redraw anything else outside of 
that area.  We need to copy over

03:29:51.658 --> 03:29:56.593
the clip bounds there so we know
what needs to be redrawn.  We 

03:29:56.594 --> 03:29:58.622
are also going to do some 
optimization stuff like 

03:29:58.623 --> 03:30:00.623
uploading bitmaps.

03:30:01.765 --> 03:30:03.413
This is a good time to do it at 
the beginning of the frame, give

03:30:03.414 --> 03:30:07.702
those time to turn that into.
   &gt;&gt; ROMAIN GUY:  We are 

03:30:07.703 --> 03:30:09.747
uploading the non-hardware bit 
map, a new type of 

03:30:15.946 --> 03:30:18.813
bitmap which was done on Android
O.  When it comes time to draw 

03:30:18.814 --> 03:30:23.345
we have to make a copy of the 
bitmap on the GPU.  This takes 

03:30:23.346 --> 03:30:25.346
extensive time.

03:30:26.835 --> 03:30:29.495
We are using the hardware maps 
available in Oreo.  You can skip

03:30:29.496 --> 03:30:31.766
the Java side of the equation 
and have a bitmap that lives 

03:30:32.782 --> 03:30:34.782
only onment GPU.

03:30:36.062 --> 03:30:38.062
If you never modify the bitmap 
again 

03:30:39.357 --> 03:30:42.019
this is a efficient way to store
your bitmaps on the memory.

03:30:45.300 --> 03:30:47.300
&gt;&gt; CHET HAASE:  We mentioned the
render threld.

03:30:50.416 --> 03:30:51.831
There is native code, no call 
outs to application code or 

03:30:51.832 --> 03:30:56.348
Java.  It just talks to the GPU.
We did this first in Lollipop.

03:30:59.397 --> 03:31:01.397
We did something we did 
pre-render thread.

03:31:02.900 --> 03:31:04.772
We display listed the 
information and we send the 

03:31:04.773 --> 03:31:07.030
display list information to the 
GPU.  It is sort of serial.

03:31:10.923 --> 03:31:13.399
The render thread is able to do 
something automatically like 

03:31:13.400 --> 03:31:15.400
circular 

03:31:16.507 --> 03:31:19.360
reveal as well as ripple 
animations and render drawable 

03:31:19.361 --> 03:31:22.803
informations can happen on the 
render thread.  Something that 

03:31:22.804 --> 03:31:27.692
can happen without installing 
the UI thread.  The UI thread 

03:31:27.693 --> 03:31:29.693
can do things after it 

03:31:31.429 --> 03:31:33.700
is idle, like some of the idle 
prefect for the render view that

03:31:33.701 --> 03:31:38.012
was done last year.
   Render thread kicks in.  We 

03:31:38.013 --> 03:31:39.442
synced everything, have the 
display list and damage area.

03:31:39.443 --> 03:31:44.985
   We turn the display list into
something we called DL ops.  

03:31:44.986 --> 03:31:47.031
Display list operations.  So you
can see that we have that fill 

03:31:47.653 --> 03:31:49.917
operation in the middle.  That 
is the thing that we turned 

03:31:49.918 --> 03:31:52.810
green there.
   And then we have some 

03:31:52.811 --> 03:31:55.519
optimizations that we performed.
   &gt;&gt; ROMAIN GUY:  We have 

03:31:55.520 --> 03:31:58.787
various optimization Z.  For 
instance if you do alpha 

03:31:58.788 --> 03:32:03.926
rendering or if you set hardware
layer on the view we try to 

03:32:03.927 --> 03:32:06.581
identify the drawing commands 
that need to be targeted to 

03:32:06.582 --> 03:32:11.348
those layers and move them at 
the beginning of the frame.  

03:32:11.349 --> 03:32:12.784
These do state changes inside 
the CPU which are extremely 

03:32:12.785 --> 03:32:16.664
expensive.  Without doing this 
kind of optimization you would 

03:32:16.665 --> 03:32:19.768
see horrible performance.  Not 
because the GPU itself will be 

03:32:19.965 --> 03:32:23.308
slow.  It will be waiting for 
the CPU to give it instructions.

03:32:27.015 --> 03:32:29.015
The other one we are going to do
next is real story and matching.

03:32:30.742 --> 03:32:32.742
You can look in this example 
because 

03:32:34.406 --> 03:32:35.637
we have a list of item we 
interleave a lot of things that 

03:32:35.638 --> 03:32:37.638
are similar.

03:32:39.901 --> 03:32:44.423
We are going to draw text and 
draw a rectangle in text again. 

03:32:44.424 --> 03:32:46.061
We are changing the state of the
GPU several times but if the 

03:32:46.062 --> 03:32:49.375
comments don't overlap we can 
draw all the triangles and text 

03:32:49.376 --> 03:32:51.376
together.

03:32:52.651 --> 03:32:55.533
This is part of the realtime 
batching.  If we look at a bunch

03:32:55.534 --> 03:32:59.844
of text that is the same color 
and font, they don't have to be 

03:32:59.845 --> 03:33:01.845
different draw text calls.

03:33:02.909 --> 03:33:04.909
It can be similar ones that 
cover the entire screen.

03:33:05.360 --> 03:33:07.360
&gt;&gt; CHET HAASE:  You can see 
here, the 

03:33:08.842 --> 03:33:10.842
entire fill ops has text which 
will end 

03:33:12.960 --> 03:33:14.960
up being render text copies from
the mip catch.

03:33:17.815 --> 03:33:19.470
It has text and fill and text 
and fill and all of these 

03:33:19.471 --> 03:33:22.300
operations interlaid.  Then we 
have a series of fills and a 

03:33:23.340 --> 03:33:25.373
series of text operations.  They
can even be  batched together to

03:33:28.455 --> 03:33:30.455
be more optimal which we will 
see here.

03:33:30.892 --> 03:33:33.124
&gt;&gt; ROMAIN GUY:  This is an 
example of Gmail that was in the

03:33:33.125 --> 03:33:38.248
Honeycomb era.  You can see we 
modified the pipeline to slow 

03:33:38.249 --> 03:33:41.351
down the rendering and this is 
how Gmail was drawing.  We draw 

03:33:41.352 --> 03:33:44.016
they will in the exact order 
that they exist in the hierarchy

03:33:44.017 --> 03:33:48.911
in your code actually like all 
the draw calls that you make on 

03:33:48.912 --> 03:33:51.390
canvas or respective otherment 
unfortunately like I said it is 

03:33:51.391 --> 03:33:53.834
very inefficient.  After 
batching and merging and 

03:33:54.846 --> 03:33:56.686
rendering we get this.
   You can see in particular 

03:33:56.687 --> 03:34:00.866
that all the stars were drawn at
the same time.  And most of the 

03:34:00.867 --> 03:34:03.532
text appear all at once.  What 
is interesting is we are drawing

03:34:05.985 --> 03:34:08.920
all the list item bag grounds 
one after the other.  That is 

03:34:08.921 --> 03:34:11.213
good, the reordering worked.  
The batching didn't work partly 

03:34:14.665 --> 03:34:16.665
because the items are slightly 
overlapping.

03:34:19.311 --> 03:34:21.304
When comments overlap we have to
make sure that the alpha views 

03:34:21.305 --> 03:34:23.757
are correct.  And in so the 
effect really depends on the 

03:34:23.758 --> 03:34:25.758
application.

03:34:27.017 --> 03:34:29.504
If I remember correctly in 
KitKat the settings application 

03:34:29.505 --> 03:34:32.379
was, we could dru the whole 
screen in about six draw calls 

03:34:35.466 --> 03:34:38.806
instead of dozens and dozens as 
seen by the view hierarchy.  

03:34:38.807 --> 03:34:41.470
This was important for us.
   &gt;&gt; CHET HAASE:  This work on 

03:34:41.471 --> 03:34:46.354
today's devices saves a 
millisecond which doesn't sound 

03:34:46.355 --> 03:34:48.355
like much until you realize we 
have to do everything in 16.

03:34:53.109 --> 03:34:55.346
There was a huge improvement 
that caused Android not to be as

03:34:55.347 --> 03:34:58.846
janky.
   Now we have the clip reject. 

03:34:58.847 --> 03:35:02.087
Now we feed in the information 
about the damage area.  So we 

03:35:02.088 --> 03:35:04.336
know where item 2 was on the 
screen and we know we don't need

03:35:04.337 --> 03:35:07.808
to draw anything outside of 
that.  As we are processing the 

03:35:07.809 --> 03:35:10.887
DL ops we know we can throw away
anything that is drawing outside

03:35:10.888 --> 03:35:13.952
of that area.  And in graphics 
that is called a trivial reject.

03:35:19.110 --> 03:35:19.921
We trivially reject all the DL 
ops not intersecting with that 

03:35:19.922 --> 03:35:21.922
area.

03:35:23.211 --> 03:35:24.658
We need to draw some fill and 
text and a line.

03:35:24.659 --> 03:35:26.659
We do that.

03:35:27.747 --> 03:35:29.990
In the process of doing that we 
do a get buffer.  This is an 

03:35:29.991 --> 03:35:34.696
implicit operation.  We don't 
request a buffer.  As soon as we

03:35:34.697 --> 03:35:39.836
start doing GPU operations, the 
GPU hands us the buffer, more 

03:35:39.837 --> 03:35:41.837
particularly the Surface layer 
hands us the buffer.

03:35:42.092 --> 03:35:44.366
We issue the commands.  This is 
a series of GL commands.

03:35:47.436 --> 03:35:48.907
As you can see on the slide it 
says GL commands, basically the 

03:35:48.908 --> 03:35:54.216
equivalent of what we need for 
doing the fill or the text, 

03:35:54.217 --> 03:35:55.056
bitmaps, copies, lines, 
whatever.

03:35:55.057 --> 03:35:58.928
We swap the buffer.  So this is 
us saying we are done with all 

03:35:58.929 --> 03:36:00.978
of our rendering operations.  We
are ready to display this frame 

03:36:00.979 --> 03:36:02.979
on 

03:36:04.247 --> 03:36:07.318
the screen at the request of 
Surface Flinger.  We are done 

03:36:07.319 --> 03:36:09.319
drawing with the buffer, you can
swap with the one in front and 

03:36:11.458 --> 03:36:13.458
it will put it on the screen.

03:36:14.926 --> 03:36:17.193
Meaning while in Surface flapper
which Romaine will talk about 

03:36:17.194 --> 03:36:21.783
layer but it takes all of the 
Windows on the screen.  We see 

03:36:21.784 --> 03:36:24.631
the navigation bar, status bar 
and actual content window for 

03:36:24.632 --> 03:36:26.632
our combination.

03:36:28.958 --> 03:36:31.031
It combines those in the 
compositor, pullets it on the 

03:36:31.032 --> 03:36:36.214
screen and ta-da, we're done.
   That was a simple example.  

03:36:36.215 --> 03:36:38.242
Let's look at a super 
complicated example.  This is in

03:36:38.243 --> 03:36:42.947
two phases.  We are going to 
drag the list up.  Drag it and 

03:36:42.948 --> 03:36:46.848
as we drag it we are going to 
move the items a little bit.  

03:36:46.849 --> 03:36:50.216
Eventually if we keep moving 
them we have a new item appear. 

03:36:50.217 --> 03:36:51.448
We will look at two versions of 
this.  There is the move only 

03:36:51.449 --> 03:36:53.449
version.

03:36:55.520 --> 03:36:57.569
As we drag it up, a -- not a new
item appears.  Everything shifts

03:36:57.570 --> 03:36:58.999
a little bit up.
   First of all we need to 

03:36:59.000 --> 03:37:01.000
process the down.

03:37:02.058 --> 03:37:05.540
So we have a Vsync that says 
time to process input  events.  

03:37:05.541 --> 03:37:07.541
We do that and we end up in code
like 

03:37:09.259 --> 03:37:10.474
this on touch event in recycler 
view it says there was a down 

03:37:10.475 --> 03:37:13.345
operation.  All it needs to do 
is register where that down 

03:37:13.346 --> 03:37:16.604
happened.  It doesn't need to 
process anything.  Nothing 

03:37:16.605 --> 03:37:18.841
changed on the screen.  We 
registered that the user 

03:37:18.842 --> 03:37:23.133
actually pressed down.  We 
record that for later.  There is

03:37:23.134 --> 03:37:25.597
no auth, we don't do anything of
the rest of the stuff we talk 

03:37:25.598 --> 03:37:28.061
about because nothing changed.
   All right.  They keep 

03:37:28.062 --> 03:37:31.600
dragging.  We end up in similar 
code.  We process input on the 

03:37:31.601 --> 03:37:34.680
next frame.  Okay, on touch 
event.  We know that they 

03:37:34.681 --> 03:37:39.607
actually moved.  We know how 
much they moved because we saved

03:37:39.608 --> 03:37:43.072
the old X and Y and we will 
calculate the delta.  Now we 

03:37:43.073 --> 03:37:46.326
call this thing called off set 
top and bottom.  Basically for 

03:37:46.327 --> 03:37:48.327
all the screws on the 

03:37:49.382 --> 03:37:51.382
screen we simply move them in Y.

03:37:52.444 --> 03:37:54.485
Offset top and bottom, it is an 
invalidation odd tho to do but 

03:37:54.486 --> 03:37:59.454
slightly different.  Invalidate 
view property.  This is an 

03:37:59.455 --> 03:38:01.928
optimization we put in in 
probably Honeycomb second 

03:38:01.929 --> 03:38:03.929
release or something with 
display list properties.

03:38:05.999 --> 03:38:08.266
When I talked about display 
lists earlier there was a Nuance

03:38:08.267 --> 03:38:11.371
I left out.  We have the 
information about the operations

03:38:11.372 --> 03:38:13.372
and parameters for the  graphics
operations but we have 

03:38:15.036 --> 03:38:16.455
information about some core 
display list properties which 

03:38:16.456 --> 03:38:20.125
are basically properties of the 
view like translation property, 

03:38:20.126 --> 03:38:24.595
rotation, alpha.  These are 
properties which we don't need 

03:38:24.596 --> 03:38:26.861
to re-render the view to  
change.  We can simply change 

03:38:26.862 --> 03:38:31.192
them in the display list 
structure itself.  They get 

03:38:31.193 --> 03:38:33.873
picked up at GPU issue time.  It
is a very fast operation to do  

03:38:33.874 --> 03:38:39.045
that.  Instead of revalidating 
everything in that view all we 

03:38:39.046 --> 03:38:42.967
say is change the translation 
property in that view.  The way 

03:38:42.968 --> 03:38:46.011
that happens is, we call 
invalidate view property.  That 

03:38:46.012 --> 03:38:48.044
propagates all the way up the 
tree.  We need to know at the 

03:38:48.045 --> 03:38:53.160
top layer what happens, but it 
is a much more optimal step.  

03:38:53.161 --> 03:38:55.161
This ends up in scheduled 
Traversals 

03:38:57.044 --> 03:38:59.734
as it did before in the draw, 
ends up in perform Traversals, 

03:38:59.735 --> 03:39:01.978
but perform draw can do more of 
this because the display list 

03:39:02.383 --> 03:39:06.046
didn't change.  We only changed 
display list products NTS of it.

03:39:08.703 --> 03:39:10.732
We can sync that over to the 
render threads and execute that,

03:39:10.733 --> 03:39:14.699
turn that into display list ops,
get the buffer.  Basically 

03:39:14.700 --> 03:39:16.933
everything is as before.
   All right, let's go through 

03:39:16.934 --> 03:39:20.454
the second phase of that super 
complicated example.  User keeps

03:39:20.455 --> 03:39:24.730
dragging.  As they drag, a new 
item respect respect as on the 

03:39:24.731 --> 03:39:26.731
bottom.

03:39:27.858 --> 03:39:29.704
Vsync, process the inspot, end 
up with a method like this.  We 

03:39:29.705 --> 03:39:31.751
know they moved.  That means 
that we need to trigger the 

03:39:33.789 --> 03:39:36.060
creation and the bind of that 
new item there.  That ends up in

03:39:36.061 --> 03:39:38.061
code like this where we actually
add a view to the parent.

03:39:40.991 --> 03:39:43.633
The recycler view is going to 
get a new view, going to call 

03:39:43.634 --> 03:39:48.131
requestlayout.  Requestlayout is
kind of like invalidation.  

03:39:48.132 --> 03:39:50.168
Instead of saying I need to be 
redrawn, it says I need to be 

03:39:50.169 --> 03:39:53.075
remeasured and relayed out.  
That could side effect everybody

03:39:53.076 --> 03:39:58.217
there.  We basically propagate a
requestlayout up the tree like 

03:39:58.218 --> 03:40:03.565
invalidation and do measure and 
lay out on the entire tree to 

03:40:03.566 --> 03:40:04.835
see what happened there.
   Requestlayout happens on the 

03:40:04.836 --> 03:40:07.080
parent and propagates all the 
way up.

03:40:09.748 --> 03:40:10.766
And that ends up again in 
schedule Traversals, our 

03:40:10.767 --> 03:40:14.657
friends.  Then perform 
Traversals, not talking about 

03:40:14.658 --> 03:40:16.713
the draw stuff now.  We are 
going to do a perform measure 

03:40:18.323 --> 03:40:21.242
and perform lay out.  It is 
asking all of the views how big 

03:40:22.055 --> 03:40:24.055
they would like to be.   It's a 
request.

03:40:25.367 --> 03:40:26.821
Layout says this is how big you 
are going to be and this is 

03:40:26.822 --> 03:40:30.289
where you are going to be 
positioned.  It is a negotiation

03:40:30.290 --> 03:40:33.594
between the views and their 
parents according to all of the 

03:40:33.595 --> 03:40:35.595
con traints in the system.
   We do a perform measure that 

03:40:36.887 --> 03:40:38.719
basically calls measure at the 
top and that propagates all the 

03:40:38.720 --> 03:40:42.599
way down and then we have all 
the information about how big 

03:40:42.600 --> 03:40:44.600
all the views want to be.  And 
that is good enough for us to 

03:40:47.089 --> 03:40:48.940
calculate the layout informs and
we propagate layout all the way 

03:40:48.941 --> 03:40:50.986
down the tree.  Once that 
happens on the item and the 

03:40:53.032 --> 03:40:54.268
parent that changed, we actually
lay out that item and we are 

03:40:54.269 --> 03:40:56.918
ready to go.  Now we can 
actually draw things and 

03:40:57.952 --> 03:41:01.427
everything is as before.
   So the Nuance here was just 

03:41:01.428 --> 03:41:03.693
the lay out size except an 
important Nuance is 

03:41:08.436 --> 03:41:10.484
we are talking about all of this
requestlayout and measure 

03:41:10.485 --> 03:41:12.485
happening for 

03:41:13.948 --> 03:41:16.387
this recycler information, 
however recycler view optimizes 

03:41:16.388 --> 03:41:20.490
in.  It knows enough about 
parent and children that it can 

03:41:20.491 --> 03:41:23.157
offset the views instead of 
doing the requestlayout it 

03:41:26.639 --> 03:41:29.124
can move the items out of the 
way.  So this is for the request

03:41:29.125 --> 03:41:31.125
view as 

03:41:33.013 --> 03:41:34.648
well as the older list view.
   &gt;&gt; ROMAIN GUY:  Now suffers 

03:41:34.649 --> 03:41:36.715
Flinger compilation posits all 
the views on the screen.

03:41:39.984 --> 03:41:42.242
This it is always interesting to
run something new in technology 

03:41:42.243 --> 03:41:44.243
and you 

03:41:46.762 --> 03:41:49.602
understand some of the 
philosophies behind Surface 

03:41:49.603 --> 03:41:52.098
texture or the immediate code.  
Before we can understand 

03:41:52.099 --> 03:41:54.099
composition 

03:41:55.145 --> 03:41:56.998
we have to understand a very 
important concept called the 

03:41:56.999 --> 03:41:58.999
buffer cue.

03:42:00.476 --> 03:42:02.704
The BufferQueue is just a queue 
of buffers, where graphics 

03:42:02.705 --> 03:42:08.480
buffers live.  Typically we have
one to three buffers, different 

03:42:08.481 --> 03:42:12.344
options internally.  When we set
it up we can request how many we

03:42:12.345 --> 03:42:14.345
want.

03:42:15.484 --> 03:42:18.173
Very importantly a BufferQueue 
has two  endpoints, the producer

03:42:18.174 --> 03:42:21.023
and consumers.  The way we use a
BufferQueue, the 

03:42:24.726 --> 03:42:26.781
producer calls a method called, 
it grabs the buffer from the 

03:42:26.782 --> 03:42:28.782
queue and owns it.

03:42:31.310 --> 03:42:33.310
It can be setting the pixel 
data, 

03:42:34.315 --> 03:42:36.491
using  OpenGL, canvas, doesn't 
matter.

03:42:38.566 --> 03:42:40.566
This is what happens when you 
call 

03:42:41.683 --> 03:42:42.924
sweat buffers at the end when we
are producing content inside the

03:42:42.925 --> 03:42:45.810
buffer.  When the producer is on
producing the 

03:42:49.474 --> 03:42:52.933
content, he calls it and gives 
it back to the BufferQueue.  The

03:42:52.934 --> 03:42:54.782
consumer can grab the next 
buffer in the view yiewrg 

03:42:54.783 --> 03:42:59.699
acquire.  He calls acquire 
buffer.  Takes the first buffer 

03:42:59.700 --> 03:43:04.015
in the queue, does whatever 
needs to be done with it and 

03:43:04.016 --> 03:43:06.016
when he's done he puts it back 
by calling release.

03:43:06.672 --> 03:43:09.132
So it is a pretty simple 
concept.  Of course if you were 

03:43:09.133 --> 03:43:11.133
to look at the 

03:43:12.398 --> 03:43:14.018
code all the header files, it's 
pretty complicated in part 

03:43:14.019 --> 03:43:16.678
because the two ends of the 
BufferQueue can live in 

03:43:16.679 --> 03:43:18.679
different processes.

03:43:19.948 --> 03:43:21.010
This is exactly what happens 
with our Surface compositor 

03:43:21.011 --> 03:43:26.130
works.  When you create a window
in the system, you have a 

03:43:26.131 --> 03:43:28.131
manager and Surface Flinger.

03:43:30.199 --> 03:43:32.199
The manager is the producer in 
the 

03:43:33.493 --> 03:43:35.529
sneer and Surface Flinger is the
Megger.  This is what is done 

03:43:35.530 --> 03:43:37.530
automatically for 

03:43:39.444 --> 03:43:42.310
you when you create a activity. 
Internally we create a window 

03:43:42.311 --> 03:43:47.206
object.  That has a sibling on 
the Surface Flinger side called 

03:43:47.207 --> 03:43:52.105
a layer.  The names can be 
confusing because in graphics we

03:43:52.106 --> 03:43:54.949
have to deal with buffers and 
queues and that's all we do and 

03:43:54.950 --> 03:43:59.032
we quickly run out of names.  
The graphics team, we have 

03:43:59.033 --> 03:44:01.033
Surface and 

03:44:02.087 --> 03:44:05.610
Surface text you ares and layer 
and so it's a little bit messy. 

03:44:05.611 --> 03:44:07.611
We have a layer, basically a 
window.

03:44:09.921 --> 03:44:12.573
And the layer is the confidence 
in the system that creates and 

03:44:12.574 --> 03:44:15.210
owns of the BufferQueue for 
your.

03:44:19.516 --> 03:44:22.224
We have a way to send then 
points by creating a Surface.  

03:44:22.225 --> 03:44:24.265
Whenever you see a Surface in 
one of the APIs you have the 

03:44:24.266 --> 03:44:26.266
producer end point 

03:44:28.017 --> 03:44:29.648
of a BufferQueue that lives 
somewhere else in the  system, 

03:44:29.649 --> 03:44:31.649
your process or 

03:44:33.075 --> 03:44:35.075
some other O.

03:44:37.903 --> 03:44:39.903
Most of time in the Surface 
Flinger.

03:44:40.137 --> 03:44:42.137
As a developer, you are going to
deal 

03:44:44.866 --> 03:44:46.866
with the Surface -- with the 
Surface view.

03:44:49.588 --> 03:44:51.588
The window, we cut a hole 
through the 

03:44:53.245 --> 03:44:55.324
surface and ask the window 
manager and Surface Flinger to 

03:44:55.325 --> 03:44:58.177
create a new Surface and we 
pretend they are part of the 

03:44:58.178 --> 03:45:00.178
same window but they are not.

03:45:02.251 --> 03:45:04.532
They are two different surfaces,
two different Surface views and 

03:45:04.533 --> 03:45:08.036
completely independent from one 
another.  If you use a Surface 

03:45:08.037 --> 03:45:10.037
view you are 

03:45:12.592 --> 03:45:15.646
going to use OpenGL or Vulkan or
media player.  In this case we 

03:45:15.647 --> 03:45:17.647
have GIS.

03:45:18.925 --> 03:45:20.925
It is going to call a buff, do 

03:45:22.004 --> 03:45:24.004
rendering, and go back into the 
BufferQueue.

03:45:26.918 --> 03:45:29.359
If you use a Surface texture, so
your  producer -- sorry, the 

03:45:29.360 --> 03:45:32.423
consumer will be OpenGL.  So you
create a surface texture by 

03:45:34.068 --> 03:45:36.068
giving it a texture ID.

03:45:37.361 --> 03:45:39.625
In that case the surface texture
creates and owns the Surface 

03:45:39.626 --> 03:45:44.742
view.  This will often be in 
your other than process.  You 

03:45:44.743 --> 03:45:47.381
have to pass that to some 
producer.  To do this you create

03:45:47.382 --> 03:45:51.048
the end points yourself by 
creating a surface.  There's a 

03:45:51.049 --> 03:45:54.297
construct of surface that takes 
the surface  texture.  You 

03:45:54.298 --> 03:45:59.270
create your surface.  You send 
it to some other application.  

03:45:59.271 --> 03:46:01.271
And then when you OpenGL code is
ready 

03:46:02.341 --> 03:46:03.367
to render it calls acquire to 
get the buffer from the 

03:46:03.368 --> 03:46:08.286
BufferQueue.  It does the 
rendering   and itself produces 

03:46:08.287 --> 03:46:11.151
a buffer inside another queue 
and when it's done it can call 

03:46:11.152 --> 03:46:13.371
re-east.
   Texture view is the widget 

03:46:13.372 --> 03:46:15.372
that is 

03:46:18.314 --> 03:46:20.314
part of a UI tool that you can 
use for Surface texture.

03:46:21.985 --> 03:46:24.446
The render that we talked about 
is the consumer of the Surface 

03:46:24.447 --> 03:46:26.882
texture.  You are responsible 
forgetting the 

03:46:29.947 --> 03:46:31.947
texture from the view and give 
it to a producer of your choose.

03:46:34.029 --> 03:46:36.029
Think of it as an image view 
that you 

03:46:38.587 --> 03:46:40.845
can update efficiently using 
hard works.  In recent years we 

03:46:40.846 --> 03:46:45.612
used to tell you that texture 
view was the solution instead of

03:46:45.613 --> 03:46:47.613
Surface view when you wanted 

03:46:49.065 --> 03:46:51.065
to integrate a video or OpenGL 
rendering 

03:46:52.145 --> 03:46:54.827
inside the complex, once you 
have a list view or card view or

03:46:54.828 --> 03:47:00.371
anything animated because it was
made of two different Windows 

03:47:00.372 --> 03:47:02.223
twat not efficient for that and 
not synchronized with your own  

03:47:02.224 --> 03:47:04.877
application.  This has been 
fixed in recent  versions of 

03:47:04.878 --> 03:47:09.610
Android.  Most of the time you 
should use Surface view instead 

03:47:09.611 --> 03:47:11.611
of texture view.

03:47:13.284 --> 03:47:15.284
Use texture view only when you 
are SAN switched  between --

03:47:19.608 --> 03:47:21.331
&gt;&gt; CHET HAASE:  I think it was 
the O release.

03:47:21.332 --> 03:47:23.332
&gt;&gt; ROMAIN GUY:  O or N.  We have
to test.

03:47:24.194 --> 03:47:25.219
&gt;&gt; CHET HAASE:  But recent.
   &gt;&gt; ROMAIN GUY:  Here is a 

03:47:25.220 --> 03:47:29.112
list of consumers and users in 
the platform.  Open GIS is a 

03:47:29.113 --> 03:47:33.231
producer.  It can also be a 
consumer.  Remember when Chet 

03:47:33.232 --> 03:47:35.897
was says saying that in the 
lifecycle of a frame at some 

03:47:38.557 --> 03:47:40.390
point we get a buffer, that's 
when we call DC buffer from the 

03:47:40.391 --> 03:47:43.873
thread.  This is done when we do
the first draw call.

03:47:48.136 --> 03:47:49.770
When with he call the driver 
that we are done with the frame 

03:47:49.771 --> 03:47:52.222
it will produce the frame and 
put it back in the BufferQueue.

03:47:56.575 --> 03:47:59.059
You can use like Vulkan, media 
player and code deck.  Many 

03:47:59.060 --> 03:48:01.060
others.

03:48:02.156 --> 03:48:04.852
We have created multiple windows
that have their own layer.

03:48:08.120 --> 03:48:10.792
Surface Flinger knows about 
those.  They talk to something 

03:48:10.793 --> 03:48:15.950
called the hollow composer, a 
hardware abstraction layer that 

03:48:15.951 --> 03:48:20.331
we use because we want to avoid 
using the GPU.  When we need to 

03:48:20.332 --> 03:48:23.835
composite all the windows on 
screen.  One is to save battery,

03:48:23.836 --> 03:48:26.097
more efficient that way.  But we
want to make sure you have 

03:48:27.932 --> 03:48:29.789
access to all of the capability 
of the GPU.  We don't take it 

03:48:29.790 --> 03:48:31.790
away from you.

03:48:33.050 --> 03:48:34.680
In pass we heard you should 
limit the number of windows on 

03:48:34.681 --> 03:48:37.323
the screen and you'll see why in
a few slide.

03:48:39.633 --> 03:48:41.633
We have a block of hardware that
is 

03:48:43.368 --> 03:48:45.850
really fast, multiple bitmaps 
and come pot iting them on the 

03:48:45.851 --> 03:48:47.851
screen.  We talked about this.

03:48:50.573 --> 03:48:52.573
The way it looks, the hollow 
composer is a protocol.

03:48:56.977 --> 03:48:58.977
I will explain the hollow 
composer, 

03:49:00.711 --> 03:49:03.556
now we use hollow composer two 
which is more complicated.  I 

03:49:03.557 --> 03:49:05.557
won't describe it but it 
basically works the same way.

03:49:07.636 --> 03:49:09.636
Surface Flinger has a bunch of 
layers.

03:49:11.099 --> 03:49:13.806
We are going to call compare and
send all the layers to the 

03:49:13.807 --> 03:49:15.807
hollow composer 

03:49:17.090 --> 03:49:19.090
and ask it what it wants us to 
do with each layer.

03:49:22.704 --> 03:49:24.324
It is a proprietary piece of 
freer in the phone or tablet you

03:49:24.325 --> 03:49:26.325
are using.

03:49:27.991 --> 03:49:29.991
We can't write to all the 
drivers for 

03:49:31.065 --> 03:49:33.065
-- in this case we have a layer,
the 

03:49:35.155 --> 03:49:36.991
hole low will composer writes 
overlay, understanding the pixel

03:49:36.992 --> 03:49:42.339
format of that window an tells 
us that it can handle it and do 

03:49:42.340 --> 03:49:44.340
the composition for that window.

03:49:45.404 --> 03:49:47.048
It is telling us overlay for the
second and third layer.  That is

03:49:47.049 --> 03:49:51.961
great.  All the composition can 
be done automatically for us on 

03:49:51.962 --> 03:49:53.962
our behalf in an efficient way.

03:49:55.440 --> 03:49:57.440
All our layers are matched to 
overlays we call set.

03:49:59.569 --> 03:50:01.812
We send all the hollow composer 
for actual come pongs and the 

03:50:01.813 --> 03:50:04.669
hollow composer sends everything
to the screen.

03:50:05.274 --> 03:50:10.804
More complex example.  We have a
number of  layers we prepare.  

03:50:10.805 --> 03:50:12.805
For the first one everything 
goes fine.

03:50:14.533 --> 03:50:16.533
Hollow composer says overlay, it
can handle it.

03:50:19.263 --> 03:50:21.520
The next one it stays (?).  It 
could be because you are using 

03:50:23.766 --> 03:50:26.632
rotation and the hollow composer
doesn't know how to handle 

03:50:26.633 --> 03:50:29.086
rotation or we have too many 
layers on the screen or any 

03:50:31.528 --> 03:50:32.354
number of reasons that are 
specific to that hollow 

03:50:32.355 --> 03:50:34.397
composer.
   &gt;&gt; CHET HAASE:  This was more

03:50:34.398 --> 03:50:36.398
common 

03:50:37.475 --> 03:50:39.475
to devices three or four or 
longer years ago.

03:50:40.145 --> 03:50:41.160
&gt;&gt; ROMAIN GUY:  We used to have 
four hardware layers you could 

03:50:41.161 --> 03:50:43.161
use.  That's five -- that's 
four.

03:50:46.895 --> 03:50:48.523
On pixel 2, without going into 
too much detail, you have 

03:50:48.524 --> 03:50:50.524
basically seven.  Much better 
than it used to be.

03:50:54.888 --> 03:50:56.888
If you have a pixel 2XL, we use 
two of 

03:50:58.322 --> 03:51:02.324
those layers to draw those round
Karen corners.  You don't have 

03:51:02.325 --> 03:51:04.379
seven, you have five.  Lots of 
dates, complicated.

03:51:07.433 --> 03:51:09.433
You don't need to know the 
details.

03:51:10.111 --> 03:51:13.369
We have one -- we have two 
layers that are frame buffer.  

03:51:13.370 --> 03:51:15.370
That is where the hard part 
starts for 

03:51:16.843 --> 03:51:19.498
us because when we have layers 
that are not handled by the 

03:51:19.499 --> 03:51:21.499
hollow composer we 

03:51:23.432 --> 03:51:25.432
need to use the GPU to compose 
them ourselves.

03:51:26.317 --> 03:51:27.947
In this situation we need to 
create basically a scratch 

03:51:27.948 --> 03:51:31.486
buffer, another layer in a 
format that we know the hollow 

03:51:31.487 --> 03:51:33.487
composer can accept.

03:51:34.566 --> 03:51:37.251
And then we use custom OpenGL 
code to do the composition 

03:51:37.252 --> 03:51:39.294
ourselves of those two layers.  
Then once we are done with that 

03:51:39.295 --> 03:51:44.221
part we are left with only two  
layers.  We know that those can 

03:51:44.222 --> 03:51:48.598
(?).  So that's what we do.  We 
call set and then issue up on 

03:51:48.599 --> 03:51:50.891
the screen.
   &gt;&gt; CHET HAASE:  If you are 

03:51:50.892 --> 03:51:52.892
curious, 

03:51:54.000 --> 03:51:56.000
sometime you can run this 
command, AB 

03:51:57.687 --> 03:52:00.951
shell dump as Surface Flinger.
   &gt;&gt; ROMAIN GUY:  Capital S, 

03:52:00.952 --> 03:52:02.952
capital F.
   &gt;&gt; CHET HAASE:  Important.

03:52:05.229 --> 03:52:07.275
It will spill out more 
information than you want but it

03:52:07.276 --> 03:52:09.519
will show you a table of the 
windows on the screen and 

03:52:11.773 --> 03:52:14.671
whether they are currently 
represented as overlays or frame

03:52:14.672 --> 03:52:16.324
buffer.
   &gt;&gt; ROMAIN GUY:  You have to 

03:52:16.325 --> 03:52:19.801
run this comment quickly because
there are tons of optimization Z

03:52:19.802 --> 03:52:24.522
internally.  What can happen is 
if layers have been on the 

03:52:24.523 --> 03:52:26.965
screen for awhile and we know 
they are not changing, the 

03:52:26.966 --> 03:52:28.966
hardware 

03:52:30.039 --> 03:52:33.349
composer may be collapsing them 
into a single layer.  The output

03:52:33.350 --> 03:52:35.801
is sometimes list misleading.  
You may see the result of 

03:52:35.802 --> 03:52:38.848
optimization s based on time.  
Usually you should run this when

03:52:38.849 --> 03:52:42.737
you are running animation or 
something is changing on the 

03:52:42.738 --> 03:52:45.217
screen, that will be the most 
valuable information for you.

03:52:45.218 --> 03:52:47.218
   A few other things we.  
Talked about.

03:52:52.715 --> 03:52:55.089
We used to tell you to use the 
invalidate, only part of your 

03:52:55.090 --> 03:52:57.090
view that you knew needed to be 
repainted.

03:53:01.644 --> 03:53:03.644
This was with older Android 
voices because ...

03:53:06.603 --> 03:53:09.500
Early in the early days of 
software rendering, we were 

03:53:09.501 --> 03:53:13.198
maximumming out the GPU.  Those 
were important savings.  You 

03:53:13.199 --> 03:53:15.665
don't need to do this anymore.  
On recent versions of Android 

03:53:15.666 --> 03:53:19.977
before, this was  actually 
ignored by the system.  What 

03:53:19.978 --> 03:53:22.854
happens, every time you go 
invalidate or invalidate with 

03:53:22.855 --> 03:53:24.855
rectangle 

03:53:27.142 --> 03:53:28.575
with the view, the renderer will
recompute that area and you 

03:53:28.576 --> 03:53:30.576
don't have to worry about it.

03:53:32.500 --> 03:53:35.375
Not only is it not necessary 
anymore for savings but also 

03:53:35.376 --> 03:53:37.376
because it is error prone.

03:53:40.612 --> 03:53:41.638
Easy to have a rendering error 
and get (indiscernible) on the 

03:53:41.639 --> 03:53:45.937
screen.  Chet and I fixed so 
many bugs linked to the use of 

03:53:45.938 --> 03:53:48.597
those APIs and the framework 
itself still has bugs around 

03:53:48.798 --> 03:53:51.252
that.  Now you don't have to 
worry about it.

03:53:54.741 --> 03:53:56.389
Recycler view will do 
pre-fetching of items ahead of 

03:53:56.390 --> 03:53:57.000
time.
   &gt;&gt; CHET HAASE:  We mentioned 

03:53:57.001 --> 03:54:02.307
this earlier.  This is one of 
the wins we are having from 

03:54:02.308 --> 03:54:06.600
having a separate render thread.
There is idle time.  Renderer 

03:54:06.601 --> 03:54:08.601
was done with the work after the
sync.

03:54:10.064 --> 03:54:12.149
It can use that time 
productively for fetching things

03:54:12.150 --> 03:54:14.227
that it knows it might need in 
the next few frames.

03:54:15.454 --> 03:54:17.507
&gt;&gt; ROMAIN GUY:  We have a 
concept of actual display, there

03:54:17.508 --> 03:54:19.579
is an API you can use, for 
example when we take a screen 

03:54:22.027 --> 03:54:23.893
shot or record a video or when 
we do casting, Chrome casting, 

03:54:23.894 --> 03:54:25.894
for instance.

03:54:28.995 --> 03:54:31.668
What we are effectively doing is
asking suferg Flinger to display

03:54:31.669 --> 03:54:37.293
to another surface, another way 
of producing a Surface.  If you 

03:54:37.294 --> 03:54:39.294
are interested there is a 

03:54:41.641 --> 03:54:43.641
sample application of graphicka.

03:54:44.718 --> 03:54:46.587
Written by the graphics team 
from a few years ago, a 

03:54:46.588 --> 03:54:48.588
collection of things 

03:54:50.490 --> 03:54:52.348
that you can do with the media 
encoder, with Surface view, an 

03:54:52.349 --> 03:54:56.297
interesting piece of code to 
look at.  Color transform, in 

03:54:56.298 --> 03:54:59.776
Android O, we induced color 
management.  That is one of the 

03:54:59.777 --> 03:55:01.777
transforms we can 

03:55:02.851 --> 03:55:05.499
apply, things like night light, 
also color transforms, we have 

03:55:05.500 --> 03:55:07.953
color blind installation.  Those
can be handled by the hollow 

03:55:10.198 --> 03:55:12.198
composer in specific situations 
and it 

03:55:13.884 --> 03:55:16.360
can be the cause for performance
issues.  For instance, awhile 

03:55:16.361 --> 03:55:18.361
back, night light 

03:55:19.412 --> 03:55:23.382
was not supported, I believe, on
the N5X or N6P.  One of the 

03:55:23.383 --> 03:55:25.383
reason, the hardware, the 
drivers that could do the color 

03:55:28.973 --> 03:55:30.973
transform, we had to fall back 
to GPU, 

03:55:32.441 --> 03:55:34.441
it was sense I have, hurting the
battery.

03:55:34.715 --> 03:55:36.969
There are many more details 
about the rendering.  This is a 

03:55:36.970 --> 03:55:38.970
high level overview.

03:55:40.884 --> 03:55:41.698
We give a number of talks in the
past that explain in more 

03:55:41.699 --> 03:55:44.187
details what we do, for 
instance, in the UI renderer 

03:55:44.188 --> 03:55:48.733
itself, how we do the batching, 
merging.  If you are  

03:55:48.734 --> 03:55:50.188
interested.
   &gt;&gt; CHET HAASE:  Shadow 

03:55:50.189 --> 03:55:52.880
calculation is interesting.  We 
have a talk where we talk about 

03:55:53.274 --> 03:55:56.936
those details.  Where does it 
fit in the rendering pipeline is

03:55:56.937 --> 03:56:00.408
every clever.  Yes, lots more 
going on there.  Hopefully this 

03:56:00.409 --> 03:56:03.274
gives you a general sense of how
things work on Android.

03:56:04.282 --> 03:56:06.137
&gt;&gt; ROMAIN GUY:  With that we are
done.  We may have time for one 

03:56:06.138 --> 03:56:08.138
question?
   &gt;&gt; ROMAIN GUY:  If you have a

03:56:09.474 --> 03:56:11.474
question you can walk to one of 
the mics?

03:56:12.146 --> 03:56:14.008
After that we will have to run 
away from here to go to our next

03:56:14.009 --> 03:56:16.455
session.
   &gt;&gt; CHET HAASE:  Yes.  Doesn't

03:56:16.456 --> 03:56:18.456
look like it.
   &gt;&gt; ROMAIN GUY:  No questions?

03:56:18.716 --> 03:56:20.716
   &gt;&gt; CHET HAASE:  I think we're
done.

03:56:23.002 --> 03:56:24.625
&gt;&gt; ROMAIN GUY:  Oh, one 
question.

03:56:24.626 --> 03:56:26.626
&gt;&gt; CHET HAASE:  You just wanted 
to build a little suspense.

03:56:27.707 --> 03:56:28.960
&gt;&gt; ROMAIN GUY:  I was afraid 
that everything we said was 

03:56:28.961 --> 03:56:30.990
clear.
   &gt;&gt;Audience:  Hi.

03:56:34.084 --> 03:56:35.920
The question is, in Android 
performance you had a suggestion

03:56:35.921 --> 03:56:37.921
that we 

03:56:39.418 --> 03:56:43.935
have to have no more than two 
and a half layers of overlay.  

03:56:43.936 --> 03:56:47.460
One view is above another and so
on.  Is it a problem now?  What 

03:56:47.461 --> 03:56:48.280
is --
   &gt;&gt; CHET HAASE:  That's the 

03:56:48.281 --> 03:56:51.977
point we were talking about 
earlier.  On older devices 

03:56:51.978 --> 03:56:53.978
certainly in the 

03:56:56.070 --> 03:56:58.532
Honeycomb area all prevalent 
devices had four overlays.  It 

03:56:58.533 --> 03:57:00.533
was easy to flip into that 
situation.

03:57:00.579 --> 03:57:02.579
&gt;&gt; ROMAIN GUY:  Talking about 
overlays or over draw.

03:57:04.528 --> 03:57:06.528
&gt;&gt;Audience:  Sorry, I mean over 
draw.

03:57:06.964 --> 03:57:08.964
&gt;&gt; ROMAIN GUY:  Bandwidth has 
not really increased.

03:57:11.032 --> 03:57:13.066
Now all the GPUs we have are 
called tires and blending is 

03:57:13.067 --> 03:57:16.160
actually fast on the GPU.  So 
over draw is not as important as

03:57:16.161 --> 03:57:18.161
it used to be.

03:57:20.331 --> 03:57:23.200
I wouldn't worry about it too 
much.  If you see performance 

03:57:23.201 --> 03:57:27.721
issues, take a look at that and 
zoo if it is an issue.  Over 

03:57:27.722 --> 03:57:30.174
draw is interesting to look at 
not because of the rendering 

03:57:32.420 --> 03:57:33.844
performance, but maybe you are 
doing too many views or too much

03:57:33.845 --> 03:57:38.167
in general.  It is something to 
look at, but it is not the most 

03:57:38.168 --> 03:57:40.168
important thing you should be 
looking at.

03:57:40.821 --> 03:57:42.678
&gt;&gt; CHET HAASE:  We have to run 
to the next talk.  We will stop 

03:57:42.679 --> 03:57:44.679
it there.  Thank you.
   (Applause.

03:57:46.296 --> 03:57:50.587
)
   (Music playing.)

03:57:56.223 --> 03:58:00.847
   &gt;&gt; ANNOUNCER:  Thank you for 
joining this session.  Brand 

03:58:00.848 --> 03:58:02.683
ambassadors will assist with  
directing you through the 

03:58:02.684 --> 03:58:04.684
designated exit.

03:58:05.932 --> 03:58:07.004
We will be making room for those
who registered for the next 

03:58:07.005 --> 03:58:11.348
session.  If you registered for 
the next session in this room we

03:58:11.349 --> 03:58:13.612
ask that you please clear the 
room and return via the 

03:58:14.627 --> 03:58:15.846
registration line outside.  
Thank you.

03:58:15.847 --> 03:58:21.131
(Music playing.)
   (The session concluded.)

04:00:26.895 --> 04:00:28.895
(Please stand by for the

04:00:30.825 --> 04:00:32.825
GOOGLE I/O 2018

04:00:34.634 --> 04:00:38.367
Stage 2 session The Future of 
the Android App Model and 

04:00:34.634 --> 04:00:36.634
Distribution on Google Play.

04:00:38.261 --> 04:00:40.261
)

04:08:45.702 --> 04:08:47.702
(Music playing.

04:08:48.703 --> 04:08:50.703
)

04:08:53.918 --> 04:08:56.205
(Standing by for the GOOGLE I/O 
2018 Stage 2 session The Future 

04:08:56.206 --> 04:08:58.206
of the Android App Model and 
Distribution on Google Play.

04:08:59.832 --> 04:09:01.832
)

04:11:16.234 --> 04:11:18.918
(The 5:00 o'clock Stage 2 
session will begin in 

04:11:18.919 --> 04:11:20.919
approximately ten minutes.  
Standing by.

04:11:22.544 --> 04:11:24.544
)

04:15:42.127 --> 04:15:44.127
)

04:15:48.542 --> 04:15:48.752
(The GOOGLE I/O 2018 Stage 2 
session The Future of the 

04:15:48.753 --> 04:15:50.611
Android App Model and 
Distribution on Google Play will

04:15:50.612 --> 04:15:54.351
begin momentarily.  Please 
continue to stand by.

04:15:57.355 --> 04:15:59.355
)

04:18:03.005 --> 04:18:07.327
   &gt;&gt; ANNOUNCER:  At this time, 
please find your seat.  Our 

04:18:07.328 --> 04:18:09.328
session will begin soon.
   (Music playing.

04:18:10.525 --> 04:18:12.525
)

04:18:42.480 --> 04:18:44.746
(Standing by for the GOOGLE I/O 
2018 Stage 2 session Build the 

04:18:44.747 --> 04:18:46.747
Nw Modular Android App Bundle.

04:18:48.784 --> 04:18:50.784
)

04:19:13.212 --> 04:19:15.212
(Standing by for the Stage 2

04:19:16.790 --> 04:19:17.225
session The Future of the 
Android App Model and 

04:19:17.226 --> 04:19:19.226
Distribution on Google Play.

04:19:20.266 --> 04:19:23.714
) the Future of the Android App 
Model and Distribution on Google

04:19:23.715 --> 04:19:25.936
Play:  Build the New Modular 
Android App Bundle.

04:19:28.939 --> 04:19:30.939
)

04:19:48.746 --> 04:19:50.746
)

04:20:04.513 --> 04:20:05.968
(The session Build the New 
Modular Android App Bundle is 

04:20:05.969 --> 04:20:07.969
about to begin.

04:20:08.969 --> 04:20:10.969
)

04:20:30.184 --> 04:20:32.184
   &gt;&gt;&gt; hi, everyone.

04:20:34.274 --> 04:20:37.152
I'm Pierre and I'm a software 
engineer on Google Play &gt;&gt;&gt; hi, 

04:20:37.153 --> 04:20:40.078
everyone I'm Anthony, also a 
software.

04:20:49.646 --> 04:20:52.342
&gt;&gt;&gt; I'm ib ham at  Google.
   &gt;&gt; PIERRE LECESNE:  Some of.

04:20:52.343 --> 04:20:54.579
   &gt;&gt; ANTHONY MORRIS:  This new 

04:20:59.544 --> 04:21:02.416
publishing format called.
   We will do a technical deep 

04:21:02.417 --> 04:21:07.347
dive on the format and cover 
what it contains, how to build 

04:21:07.348 --> 04:21:09.781
it, how to publish it but also 
the different ways you can test 

04:21:09.782 --> 04:21:11.782
it.

04:21:15.259 --> 04:21:17.259
We will also cover how Google 
Play

04:21:18.375 --> 04:21:20.375
conserves the APKs.

04:21:24.905 --> 04:21:27.557
Let's start with the format of 
the app bundle, it contains 

04:21:27.558 --> 04:21:30.428
everything you are familiar 
with, Dex files and resources 

04:21:32.467 --> 04:21:37.284
assets, native libraries.
   It is important to realize 

04:21:37.285 --> 04:21:39.285
that the 

04:21:40.565 --> 04:21:44.835
app bundle and APK weds are two 
distinction formats.  The app 

04:21:44.836 --> 04:21:46.836
bundle is a publishing format 

04:21:47.961 --> 04:21:49.961
and cannot be  directly 
installed on a device.

04:21:53.352 --> 04:21:55.383
It also contains metadata files 
that don't end up in the APKs.

04:22:00.918 --> 04:22:02.918
They help them fill the APKs the
rate way.

04:22:04.986 --> 04:22:06.986
The tools can fully understand 
files 

04:22:08.672 --> 04:22:10.672
in the bundle so that it can 
generate valid APKs.

04:22:13.370 --> 04:22:17.720
Now, let's open up one App 
Bundle and see what is inside.  

04:22:17.721 --> 04:22:19.721
If you open up an App Bundle 
this is what you should expect.

04:22:20.173 --> 04:22:22.643
   So this should look familiar 
to a lot of people.

04:22:25.760 --> 04:22:28.262
Instead of reinventing the wheel
we decided to reuse Nevada the 

04:22:28.263 --> 04:22:31.761
structure of APK and only modify
what we needed to better 

04:22:31.762 --> 04:22:35.638
describe the file.  So we will 
be free to go through them.

04:22:38.943 --> 04:22:41.815
To start with, the App Bundle 
has support for multiple modules

04:22:41.816 --> 04:22:43.816
as you heard before.

04:22:45.557 --> 04:22:48.213
We will tell you more about 
modules shortly.  Know that the 

04:22:48.214 --> 04:22:50.500
top level directories in the App
Bundle are the names of the 

04:22:50.705 --> 04:22:52.705
modules.

04:22:55.199 --> 04:22:57.240
There is always a module named 
base in the bun and that's what 

04:22:57.241 --> 04:22:59.241
we are looking at here.

04:23:02.765 --> 04:23:05.018
The Android manifest is still 
project.  It is a real XML file.

04:23:10.134 --> 04:23:12.134
In the APKs it is binary and in 
the 

04:23:14.325 --> 04:23:18.028
App Bundle is is compiled so we 
can transform it more easily.  

04:23:18.029 --> 04:23:20.029
As opposed toe APK, the Dex 
files are 

04:23:21.728 --> 04:23:23.728
under directory name Dex.

04:23:25.403 --> 04:23:27.728
The resources, assets and 
libraries follow the same 

04:23:27.729 --> 04:23:30.181
directory structure as in APK.  
The only difference are the XML 

04:23:32.012 --> 04:23:34.012
resources which are also 
compiled into a 

04:23:35.882 --> 04:23:37.882
protocol format instead of the 
binary format.

04:23:41.617 --> 04:23:44.287
The file resources is the 
resource table, the equivalent 

04:23:44.288 --> 04:23:48.249
of the resources that you have 
seen in your APKs.  It describes

04:23:48.250 --> 04:23:52.787
the resources present in your 
app and targeting.  The.

04:23:59.984 --> 04:24:01.984
.pb extension makes it easier 
for tails 

04:24:04.662 --> 04:24:06.703
to format before transformed 
positive APK.

04:24:07.288 --> 04:24:09.332
The native files are the 
equivalent of the resource table

04:24:09.333 --> 04:24:12.625
for assets and native libraries.
They only exist if you have 

04:24:12.626 --> 04:24:17.334
assets on native libraries and 
describe the targeting of the 

04:24:17.335 --> 04:24:19.335
files in the respective 
directories.

04:24:21.046 --> 04:24:23.296
As I mentioned before, the 
resource tables, the asset tail 

04:24:23.297 --> 04:24:26.820
and the native libraries table 
describe the targeting of the 

04:24:26.821 --> 04:24:28.914
files of your app.  Let me 
explain what it means by that.

04:24:31.168 --> 04:24:35.446
   Fun targeting is the 
description of what type of 

04:24:35.447 --> 04:24:37.447
device or user a given file is 
targeted for.

04:24:40.216 --> 04:24:42.056
It is a trail concept in Google 
Play dynamic delivery since 

04:24:42.057 --> 04:24:46.550
understanding the targeting of 
files means we can serve to a 

04:24:46.551 --> 04:24:49.048
given user only the files they 
need and this is what allows us 

04:24:49.049 --> 04:24:53.369
to make apps smaller.
   The App Bundle reuses the 

04:24:53.370 --> 04:24:57.447
targeting that exists in packs. 
You are already familiar with 

04:24:57.448 --> 04:25:00.717
this so I'll run through it 
quickly.

04:25:04.386 --> 04:25:06.386
Resources, we specify, for 
example, 

04:25:09.492 --> 04:25:11.492
hdpi in the directory of your 
devices.

04:25:12.761 --> 04:25:14.837
Or add FR to target French 
users.  On native libraries, it 

04:25:14.838 --> 04:25:16.838
is the same.  You add the 
architecture to the directory.

04:25:17.279 --> 04:25:19.279
   Again, nothing new hearing.

04:25:22.203 --> 04:25:24.203
The App Bundle works the same 
way.

04:25:25.250 --> 04:25:27.506
Now we realized that for some of
you, assets represent a big part

04:25:27.507 --> 04:25:29.507
of your app.

04:25:31.206 --> 04:25:33.271
So the App Bundle also supports 
asset targeting.  We are 

04:25:33.272 --> 04:25:35.272
starting with language 

04:25:37.139 --> 04:25:39.370
targeting and we will soon we 
added format and graphics 

04:25:39.371 --> 04:25:43.232
versions so we can serve only 
the relevant assets to the users

04:25:43.233 --> 04:25:46.074
and reduce further the size of 
your apps and games.

04:25:48.555 --> 04:25:50.555
This is how you would create a 
targeted asset directory.

04:25:53.079 --> 04:25:55.079
While making use of the hash 
sign to 

04:25:57.649 --> 04:25:59.649
identify a directory that has 
targeting.

04:26:00.908 --> 04:26:02.908
Then comesment key, for example,
Lang 

04:26:04.473 --> 04:26:06.912
for the language, CCF for 
compression format, et cetera 

04:26:06.913 --> 04:26:08.913
and then comes the value 
associated with the key.

04:26:10.359 --> 04:26:13.026
Let's see some examples.  Here 
is an example of a directory 

04:26:15.262 --> 04:26:17.313
containing assets for users 
speaking French.

04:26:19.563 --> 04:26:21.563
This is another example of an 
asset 

04:26:23.084 --> 04:26:25.734
directory targeted based on the 
texture compression format.  

04:26:25.735 --> 04:26:27.735
Here targeting devices that 
support 

04:26:30.430 --> 04:26:32.875
the far Matt  ETC1.
   Now that you know more about 

04:26:32.876 --> 04:26:34.876
the 

04:26:36.154 --> 04:26:38.154
format I will hand it over to 
Anthony 

04:26:40.256 --> 04:26:44.562
who tells you how we use this to
serve smaller apps for users.  

04:26:44.563 --> 04:26:46.563
Thoan hi thanks, Pierre.  Hi, 
everyone.

04:26:51.140 --> 04:26:53.176
I am going to explain to you how
we are changing the format of 

04:26:53.177 --> 04:26:57.244
what we serve to users and how 
we use this to deliver only what

04:26:57.245 --> 04:26:59.245
is needed for each user.

04:27:03.224 --> 04:27:05.224
Now, we start with Split APKs.

04:27:07.528 --> 04:27:09.782
Drew an droiled Lollipop we 
added a feature called Split 

04:27:09.783 --> 04:27:13.461
APKs which allow multiple APKs 
to be installed on a device and 

04:27:13.462 --> 04:27:16.775
behave as if they were part of a
single app.  The Split APKs can 

04:27:16.776 --> 04:27:18.776
be installed in different 
combinations on different 

04:27:20.656 --> 04:27:22.714
devices and they can be 
installed in one go up front or 

04:27:22.715 --> 04:27:27.656
piece-by-piece.
   Now, a Split APK has the same

04:27:27.657 --> 04:27:29.657
format as a normal pack.

04:27:33.441 --> 04:27:35.441
They can contain Java code in 
Dex 

04:27:36.510 --> 04:27:38.510
files, native code and resource 
directories.

04:27:40.379 --> 04:27:44.716
Once the  APKs are installed 
they can act as a single APK.  

04:27:44.717 --> 04:27:47.196
Furthermore each Split APK says 
the same package name and 

04:27:47.197 --> 04:27:51.089
version code with all the other 
ones installed on the device and

04:27:51.090 --> 04:27:53.090
must all be signed with the same
kit.

04:27:54.780 --> 04:27:56.780
So now let's take a look at how 
we 

04:27:58.083 --> 04:28:00.118
can take the Android App Bundle 
and generate APKs that we then 

04:28:00.119 --> 04:28:02.573
serve to devices.
   So we start by looking in the

04:28:02.574 --> 04:28:06.494
App Bundle and finding 
everything that is common to all

04:28:06.495 --> 04:28:10.429
the  devices and putting those 
in a base APK.  This would 

04:28:10.430 --> 04:28:13.114
include the Android Manifest 
file and the Dex files, for 

04:28:13.325 --> 04:28:15.767
instance.
   Then we generate a different 

04:28:15.768 --> 04:28:20.048
Split APK for each screen 
density.  Each split will 

04:28:20.049 --> 04:28:24.542
contain all the drawables that 
would have been selected by the 

04:28:24.543 --> 04:28:26.543
Android framework on a device 

04:28:27.822 --> 04:28:30.300
with that density.
   We can also generate a 

04:28:30.301 --> 04:28:34.588
different Split APK for each 
native architecture containing 

04:28:34.589 --> 04:28:36.637
native  libraries of that 
architecture.

04:28:38.675 --> 04:28:41.113
And we can generate a different 
split for each language 

04:28:41.114 --> 04:28:43.114
supported by your app, 

04:28:44.810 --> 04:28:46.810
putting each language's strings 
in a different APK.

04:28:47.274 --> 04:28:49.274
Together we call these splits 

04:28:50.369 --> 04:28:52.369
configuration splits or config 
splits.

04:28:54.239 --> 04:28:56.687
Now when we go to serve an app 
through a device we only need to

04:28:56.688 --> 04:29:00.152
serve a subset of these splits 
instead of serving everything to

04:29:00.153 --> 04:29:02.153
every device.

04:29:04.433 --> 04:29:06.433
Say I have a samsung Galaxy 5.

04:29:07.491 --> 04:29:09.491
We install the base APK as well 
as the 

04:29:11.363 --> 04:29:14.006
identity split, the ARM 
infrastructure split and English

04:29:14.007 --> 04:29:16.007
language split because I only 
speak English.

04:29:18.731 --> 04:29:20.731
It can get trickier.

04:29:23.417 --> 04:29:25.879
Peer speaks both English and 
French and specifies both 

04:29:25.880 --> 04:29:28.331
languaging the in addition to 
the right density and 

04:29:30.357 --> 04:29:32.816
architecture split we serve both
the French and English language 

04:29:32.817 --> 04:29:36.336
split to his device.
   Now, suppose Pierre then 

04:29:36.337 --> 04:29:38.337
moves to Brazil and learns 
Portuguese.

04:29:41.225 --> 04:29:44.325
He might add Portuguese as a ang
on his device.  When he does 

04:29:44.326 --> 04:29:46.326
this, the Play Store recognizes 
this and will attempt to 

04:29:47.812 --> 04:29:50.446
download the Portuguese language
splits for all apps that use 

04:29:50.447 --> 04:29:52.483
splits on the device.
   And if the device is not 

04:29:52.484 --> 04:29:56.434
online at the time, then we will
download those language splits 

04:29:56.435 --> 04:29:59.899
at the next opportunity.
   So that is how config splits 

04:29:59.900 --> 04:30:01.900
work.

04:30:03.966 --> 04:30:06.430
But as I mentioned at the start,
bits are only supported on 

04:30:06.431 --> 04:30:08.681
Lollipop and above.  That covers
85 percent of users at the 

04:30:12.568 --> 04:30:14.568
moment but most of you target 
pre-L devices which is great.

04:30:17.490 --> 04:30:19.715
These the App Bundle allows us 
to achieve some of the savings 

04:30:19.716 --> 04:30:21.716
by achieving 

04:30:25.347 --> 04:30:28.327
stand alone APKs through -- 
instead of generating splits as 

04:30:28.328 --> 04:30:30.328
we would do for L 

04:30:32.603 --> 04:30:36.076
plus we do the (?) stand alone 
APKs.  We considered the 

04:30:36.077 --> 04:30:39.137
language splits as well but did 
some of the sums and it got out 

04:30:39.138 --> 04:30:41.138
of hand.

04:30:43.000 --> 04:30:45.000
Now for pre-L devices we include
all 

04:30:47.304 --> 04:30:49.304
of the languages in all of the 
pre-L APKs.

04:30:50.162 --> 04:30:52.005
When we go to serve the app we 
choose the best single APK for 

04:30:52.006 --> 04:30:54.006
the device.

04:30:56.544 --> 04:30:58.544
If we have my first Android 
tbais, the 

04:31:01.497 --> 04:31:04.956
Galaxyness sus, we serve the 
stand alone ARM APK.  This is 

04:31:04.957 --> 04:31:07.404
similar to what you may have 
done in the past with multiAPK.

04:31:07.405 --> 04:31:11.487
   Put this all together.  The 
picture looks like this.  You 

04:31:11.488 --> 04:31:14.346
will actually don't need to 
worry about the details about 

04:31:14.347 --> 04:31:17.413
how all these Split APKs are 
generated or stand alone APKs 

04:31:17.414 --> 04:31:23.100
are generated.  All you have to 
do is upload a single App Bundle

04:31:23.101 --> 04:31:25.179
and play generates the right 
splits and selects the right 

04:31:25.180 --> 04:31:30.944
ones to serve for each device.
   And the dimensions we've 

04:31:30.945 --> 04:31:35.029
discussed so far are only the 
beginning.  Pierre discussed how

04:31:35.030 --> 04:31:37.269
the App Bundle lets you target 
assets by graphics ape.

04:31:41.165 --> 04:31:44.833
We will soon generate configure 
IGT splits based on that.  We 

04:31:44.834 --> 04:31:47.712
will generate config splits that
take advantage of new platform 

04:31:47.713 --> 04:31:49.713
features 

04:31:52.317 --> 04:31:54.317
and uncompressed native 
libraries on N plus devices.

04:31:56.449 --> 04:31:58.449
I'll ask Ibo to come up and take
a 

04:31:59.749 --> 04:32:02.196
look at how much we can reduce 
app size by reducing the App 

04:32:02.197 --> 04:32:04.040
Bundle.
   (Applause.)

04:32:04.041 --> 04:32:06.041
&gt;&gt; IBRAHIM KARAHAN:  Thank you, 
Anthony.

04:32:07.924 --> 04:32:09.758
Let me know how play serves 
Split APKs to your devices we 

04:32:09.759 --> 04:32:12.628
are going to talk about the size
savings with App Bundles.

04:32:16.118 --> 04:32:18.118
We found out on average apps 
published 

04:32:19.189 --> 04:32:21.189
with App Bundles are 20 percent 
smaller.

04:32:23.362 --> 04:32:25.626
And that is 20 percent savings 
every time your application is 

04:32:25.627 --> 04:32:29.280
downloaded or upgraded.  Now, 
let's look at how we reach to 

04:32:29.704 --> 04:32:32.758
this number.
   We analyze all the 

04:32:32.759 --> 04:32:35.598
applications in Play Store with 
more than 1 million downloads.

04:32:39.931 --> 04:32:42.177
And we found out that for 
strings we can save over 95 

04:32:42.178 --> 04:32:45.240
percent of their size by using 
the language splits.

04:32:47.675 --> 04:32:50.532
For images this is 45 percent.  
And for native libraries, we can

04:32:50.533 --> 04:32:52.569
save 20 percent of their sizes.

04:32:57.701 --> 04:33:00.183
This means if every app were to 
move to App Bundles we would 

04:33:00.184 --> 04:33:02.184
save 

04:33:03.187 --> 04:33:05.187
approximately

04:33:06.569 --> 04:33:08.569
ten petabytes per day from app 
downloads and upgrades.

04:33:11.535 --> 04:33:13.535
300 million music videos on 
YouTube.

04:33:14.790 --> 04:33:16.790
On top of that, users could see 
an 

04:33:19.331 --> 04:33:21.331
extra 300 megabytes of extra 
disk space 

04:33:22.591 --> 04:33:24.591
for more photos, apps or more 
music on their devices.

04:33:26.295 --> 04:33:28.295
So now let's look at actual size

04:33:29.990 --> 04:33:31.439
savings that are some of our 
early access program and 

04:33:31.440 --> 04:33:34.477
partners.  We are going to start
with Twitter.

04:33:37.348 --> 04:33:39.194
Twitter were already publishing 
with multiAPKs before, with 

04:33:39.195 --> 04:33:41.195
architecture splits.

04:33:44.141 --> 04:33:46.792
However, their application is 
translated into a lot of 

04:33:46.793 --> 04:33:48.793
languages and 

04:33:50.090 --> 04:33:52.090
supports multiple screens.

04:33:56.024 --> 04:33:58.024
They get less savings publishing
with 

04:34:00.324 --> 04:34:02.324
App Bundles decreasing 20 
percent in 

04:34:05.636 --> 04:34:07.636
size and no longer serve 
multiAPKs.

04:34:09.735 --> 04:34:11.806
With App Bundles, they achieved 
26 percent size savings across 

04:34:11.807 --> 04:34:16.771
all dimensions with app BUNs.

04:34:20.959 --> 04:34:23.625
Jaumo's half is -- app is half 
of the original size.  They have

04:34:23.626 --> 04:34:26.060
a large library and supported 
multiple architectures in a 

04:34:26.467 --> 04:34:29.547
single APK.
   Now, let's look at how we can

04:34:29.548 --> 04:34:33.278
build an App Bundle and you can 
start saving now.

04:34:37.620 --> 04:34:39.620
The latest Android studio 3.

04:34:42.613 --> 04:34:44.613
2 Canary has possibility of 
building now bun.

04:34:46.912 --> 04:34:48.912
You see the options to build a 
bun in the app menu.

04:34:52.213 --> 04:34:54.670
We are going to select the App 
Bundle, app module, product 

04:34:54.671 --> 04:34:56.671
flavor and build 

04:34:57.744 --> 04:34:59.989
type and Android studio is going
to create an App Bundle for you,

04:34:59.990 --> 04:35:03.274
which is ready for publishing.

04:35:06.600 --> 04:35:09.037
For those who prefer command 
line or wish to integrate with 

04:35:09.038 --> 04:35:11.038
automated build 

04:35:13.564 --> 04:35:15.564
systems the new Android and 
grade he 

04:35:17.863 --> 04:35:20.734
will plug in has tests to build 
App Bundle.  Remember this is 

04:35:20.735 --> 04:35:23.191
what you use the assembled task 
on the command line to create 

04:35:23.192 --> 04:35:25.489
the APK.  For App Bundles you 
are going to 

04:35:28.997 --> 04:35:30.997
switch to the bun command, 
similar to 

04:35:33.733 --> 04:35:35.733
the assemble tasks, bundles 
allows us to 

04:35:37.620 --> 04:35:41.146
build a specific application of 
-- of your application.  Once 

04:35:41.147 --> 04:35:43.415
the buns have finishes, it will 
create in the output folder with

04:35:43.416 --> 04:35:45.459
the fliefer understand build 
type chosen.

04:35:48.722 --> 04:35:50.722
The build architect is called 
bundle dot IAB.

04:35:52.170 --> 04:35:54.170
Build he will tasks are 
compatible 

04:35:56.880 --> 04:35:58.880
with the  signing config in your
build dot Gradle files.

04:36:02.447 --> 04:36:05.112
With a single Gradle task you 
can produce files that are 

04:36:05.113 --> 04:36:07.113
signed and ready for publishing.

04:36:09.884 --> 04:36:11.884
With app bundles play will 

04:36:14.403 --> 04:36:15.613
automatically split your 
application into language splits

04:36:15.614 --> 04:36:18.670
by default.  You don't need to 
do any configurations.

04:36:22.767 --> 04:36:23.992
However, this article wants to 
have full control over the 

04:36:23.993 --> 04:36:25.993
splits.

04:36:27.453 --> 04:36:29.512
So if for any reason you would 
like to disable splitting by any

04:36:29.513 --> 04:36:31.513
dimension you 

04:36:33.067 --> 04:36:36.952
can do so by using the newly 
introduced bundle block here.  

04:36:36.953 --> 04:36:38.953
Now Pierre is going to talk 
about how 

04:36:40.023 --> 04:36:42.054
to publish your app bundle in 
the Play Console.

04:36:43.496 --> 04:36:45.496
&gt;&gt; PIERRE LECESNE:  Thanks, Ibo.

04:36:46.509 --> 04:36:48.762
All right you have build an app 
bunld em.  Let's look at how you

04:36:48.763 --> 04:36:50.763
can publish it on Google Play 
console.

04:36:53.455 --> 04:36:55.455
First you must enroll in app 
signing by Google Play.

04:36:58.347 --> 04:37:00.347
For those who resh we launched 
this at Google IO last year.

04:37:03.457 --> 04:37:07.150
When enrolling you secure your 
release key to Google Play.  

04:37:07.151 --> 04:37:09.151
Play then uses the release key 
to sign 

04:37:10.812 --> 04:37:12.259
the generated APKs on your 
behalf before serving them to 

04:37:12.260 --> 04:37:14.495
users.
   But note that if you keep 

04:37:14.496 --> 04:37:19.684
uploading APKs on your 
production track, while you test

04:37:19.685 --> 04:37:22.614
the App Bundle in the test 
track, play will not resign the 

04:37:22.615 --> 04:37:24.615
uploaded APKs.

04:37:26.151 --> 04:37:28.614
We did this so you can feel 
confident trying the App Bundle 

04:37:28.615 --> 04:37:31.933
on a small audience first 
without affecting your current 

04:37:31.934 --> 04:37:34.594
production users.
   Once you enrolled we can 

04:37:34.595 --> 04:37:38.256
manage the releases just hike 
you did for APKs.  Create a new 

04:37:38.257 --> 04:37:40.257
release.

04:37:41.332 --> 04:37:43.332
Drop the App Bundles in a 
similar 

04:37:44.835 --> 04:37:49.018
location where you currently 
drop APKs and watch the upload. 

04:37:49.019 --> 04:37:51.116
Once uploaded you can register 
your release and roll it out.  

04:37:51.117 --> 04:37:53.117
That's it.

04:37:54.849 --> 04:37:57.915
I can't stress enough, no more 
multiAPKs to deal with.  Play 

04:37:57.916 --> 04:38:00.647
Console has created in the bag 
ground all the APKs of the 

04:38:00.648 --> 04:38:05.983
supported devices for you.
   Now, you have uploaded your 

04:38:05.984 --> 04:38:07.984
App 

04:38:09.922 --> 04:38:12.834
Bundle and play has done all the
heavy lifting for you.  Great.  

04:38:12.835 --> 04:38:14.916
Wouldn't it be nice to have an 
overview of what play has 

04:38:14.917 --> 04:38:17.173
generated?  We have built a new 
tool in Play 

04:38:20.655 --> 04:38:22.655
Console called bundle explorer 
which 

04:38:24.333 --> 04:38:26.333
lets you navigate your uploaded 
bundles.

04:38:26.819 --> 04:38:28.819
Let's have a look on the first 
screen 

04:38:29.882 --> 04:38:32.348
you can see at the top right 
corner this size savings you 

04:38:32.349 --> 04:38:34.997
gained by publishing a bundle.  
Here we saved over a quarter of 

04:38:34.998 --> 04:38:36.998
your app.  Of course this is 
different by device.

04:38:39.910 --> 04:38:44.000
So we clailted this using a 
popular device configuration.  

04:38:44.001 --> 04:38:46.052
You will also find below the 
list of device configurations 

04:38:46.053 --> 04:38:51.140
and the total size of the APKs 
served to those devices.  Even 

04:38:51.141 --> 04:38:53.141
click on view devices and see 

04:38:54.637 --> 04:38:56.637
which devices are in each 
bucket.

04:38:56.878 --> 04:38:59.743
You can even search for any 
supported device by name to 

04:38:59.744 --> 04:39:01.973
download the set of generated 
APKs that is served to that 

04:39:02.391 --> 04:39:07.569
specific device.  This will be 
super helpful when you get that 

04:39:07.570 --> 04:39:09.834
bug report on that specific 
device and you want to get 

04:39:09.835 --> 04:39:13.142
exactly what the user has 
gotten.  And what the APKs that 

04:39:13.143 --> 04:39:18.834
were served.  So you just search
for the name, click download and

04:39:18.835 --> 04:39:21.490
you'll get the set of APKs that 
play has served.

04:39:23.943 --> 04:39:25.956
Of course, we have not forgotten
all of you who use our 

04:39:25.957 --> 04:39:27.957
publishing API.

04:39:29.243 --> 04:39:31.762
Uploading App Bundles is 
available using our API today.

04:39:37.707 --> 04:39:40.389
You will find further 
information at Google 

04:39:40.390 --> 04:39:43.053
gom/publisher.  I hand it over 
to Anthony.

04:39:44.285 --> 04:39:46.338
&gt;&gt; ANTHONY MORRIS:  Thanks, 
Pierre.  We learned how to build

04:39:46.339 --> 04:39:50.909
and publish Android App Bundle 
before we finalize we would like

04:39:50.910 --> 04:39:54.836
to do a round of tech.  However,
we've seen that the App Bundle 

04:39:54.837 --> 04:39:57.074
on its own is not installable.  
How do you test it?

04:40:00.799 --> 04:40:02.799
First we note that during 
development 

04:40:03.903 --> 04:40:05.331
you can install APKs built from 
the App Bundle directly from 

04:40:05.332 --> 04:40:07.587
Android studio.  You don't need 
to do anything here.

04:40:10.716 --> 04:40:13.201
However, for QA teams we know 
that they don't always have 

04:40:13.202 --> 04:40:15.679
access to the source code in 
Android studio.

04:40:21.020 --> 04:40:24.018
Let me take through Alice, Bob 
and Claire and how they choose 

04:40:24.019 --> 04:40:26.313
to test with the QA team.
   Start with Alice.

04:40:29.447 --> 04:40:31.124
She uses the newly released 
internal test track from the 

04:40:31.125 --> 04:40:33.125
Play Console.

04:40:34.249 --> 04:40:36.502
The internal track is similar to
alpha and beta tracks that you 

04:40:36.503 --> 04:40:39.616
may already be familiar with.  
But it differs in that there is 

04:40:39.617 --> 04:40:44.157
almost no delay between the 
upload of the bundle and the 

04:40:44.158 --> 04:40:46.158
update being available on the 
tester oh's device.

04:40:49.059 --> 04:40:51.059
Quick turn arounds for your QA 
testing.

04:40:51.492 --> 04:40:53.526
Going through the Play Console, 
Alice has the confidence that 

04:40:53.527 --> 04:40:58.915
what the QA team will receive on
their device is byte for byte 

04:40:58.916 --> 04:41:00.916
equal with what end users will 
get 

04:41:02.225 --> 04:41:04.225
when you push your release to 
production.

04:41:04.268 --> 04:41:06.268
Let's see how Alice sets this 
up.  Really  simple.

04:41:08.779 --> 04:41:10.779
Alice creates a list of emails 
of up 

04:41:12.084 --> 04:41:15.263
to 100 testers eligible for the 
test track.  They are opt in at 

04:41:15.264 --> 04:41:17.264
length and now 

04:41:18.449 --> 04:41:19.901
receive the bundles uploaded to 
the internal test track.  That's

04:41:19.902 --> 04:41:23.260
it.
   But we know that not all of 

04:41:23.261 --> 04:41:26.419
you have access to the Play 
Console during your QA cycle.

04:41:29.463 --> 04:41:31.463
Let's hear from Pierre about 
Bob's story.

04:41:31.523 --> 04:41:33.777
&gt;&gt; PIERRE LECESNE:  Indeed, Bob 
doesn't have access to the Play 

04:41:33.778 --> 04:41:35.778
Console.

04:41:37.045 --> 04:41:38.930
He prefers also to testing 
locally on his machine before 

04:41:38.931 --> 04:41:41.035
uploading anything.  But he 
still wants to test what the 

04:41:41.658 --> 04:41:43.658
users will get.  How does he do 
that?

04:41:45.973 --> 04:41:47.973
Well, to generate APKs from the 

04:41:49.494 --> 04:41:52.582
bundle, play users a new tool 
called bundle will too.  For Bob

04:41:52.583 --> 04:41:54.583
to reproduce locally the build 

04:41:55.687 --> 04:41:58.157
he can simply download bundle 
tool and write a few simple 

04:41:58.158 --> 04:42:01.031
commands.
   Bundle tool has a comment 

04:42:01.032 --> 04:42:03.032
called 

04:42:04.722 --> 04:42:07.616
build APKs which takes Android 
APK bundle and creates APK set 

04:42:07.617 --> 04:42:11.923
archive.  This is a collection 
of APKs ready to be installed on

04:42:11.924 --> 04:42:13.924
devices.

04:42:15.217 --> 04:42:17.217
Another comment called install 
APKs 

04:42:18.706 --> 04:42:20.774
tests that APK archive, extracts
the APKs and installs them on 

04:42:20.775 --> 04:42:24.043
this device.  Let's see some 
real command line  work.

04:42:31.799 --> 04:42:33.799
So here is the command by Bob 
called 

04:42:35.237 --> 04:42:37.237
build petition, and where he 
wants it to 

04:42:39.097 --> 04:42:40.767
be, by  passing -- build packs 
just for the device  currently 

04:42:40.768 --> 04:42:42.768
connected to his machine.

04:42:45.872 --> 04:42:47.970
And if Bob wants to generate 
APKs for someone else on his 

04:42:47.971 --> 04:42:50.198
team without having the physical
device at hand he can still 

04:42:52.293 --> 04:42:54.568
provide a file that contains the
specifications of the device in 

04:42:54.569 --> 04:42:58.484
a JSON format and you can see 
here an extract of such file 

04:42:58.485 --> 04:43:00.485
which provides the 

04:43:02.358 --> 04:43:04.196
information about the ABIs, this
device words, supported 

04:43:04.197 --> 04:43:06.197
languages, screen 

04:43:08.471 --> 04:43:10.471
density and the NTK version.

04:43:11.532 --> 04:43:13.532
Bundle tool has a command to 
generate 

04:43:15.239 --> 04:43:17.072
such file so you don't have to 
find the device expect online or

04:43:17.073 --> 04:43:20.529
don't have to write it yourself.
You run this command and it will

04:43:22.980 --> 04:43:25.490
generate this command for you.
   Also because Bob wants to 

04:43:25.491 --> 04:43:28.771
install the APKs on the device, 
they need to be signed with a 

04:43:28.772 --> 04:43:33.717
private key.  He passes the path
to the key store.  All the APKs 

04:43:33.718 --> 04:43:36.602
contained in the APK set will 
then be signed and directly 

04:43:37.833 --> 04:43:40.870
installable on Bob's device.
   And here is the invocation of

04:43:40.871 --> 04:43:42.871
the 

04:43:45.382 --> 04:43:48.038
install APKs comnld which 
extracts the APKs and installs 

04:43:48.039 --> 04:43:51.530
them on the device.  Easy.
   So that was Bob.  And his 

04:43:51.531 --> 04:43:53.531
local testing.

04:43:54.990 --> 04:43:57.439
Now  Ibo will tell you Claire's 
story.

04:43:58.251 --> 04:44:00.280
&gt;&gt; IBRAHIM KARAHAN:  Claire is 
working for a medium sized 

04:44:00.281 --> 04:44:03.734
company.  And they set up a 
continuous integration tool to 

04:44:03.735 --> 04:44:05.735
build their application.

04:44:08.614 --> 04:44:11.317
Every day the create team holds 
a nightly build of the 

04:44:11.318 --> 04:44:15.734
application, installs in 
multiple devices and tests if 

04:44:15.735 --> 04:44:17.735
the application is working 
correctly.

04:44:18.787 --> 04:44:21.693
Claire wants to help the create 
team and she uses the bundle 

04:44:21.694 --> 04:44:25.187
tool again to generate the APK 
set in this  CI.

04:44:27.659 --> 04:44:29.927
She uses a command that is very 
similar to what Bob used 

04:44:29.928 --> 04:44:31.928
earlier, but 

04:44:33.235 --> 04:44:35.235
this time she omits the device 
type flag 

04:44:36.305 --> 04:44:38.381
and she generates an APK set 
which contains APKs for all 

04:44:38.382 --> 04:44:40.846
possible devices.

04:44:46.260 --> 04:44:48.260
Now, the QA team will just grab 
the APK set from the CI.

04:44:51.610 --> 04:44:53.610
They run the install APKs 
command.

04:44:54.257 --> 04:44:56.311
Bundle tool will read the device
configuration from the attached 

04:44:56.312 --> 04:44:58.312
device, 

04:44:59.614 --> 04:45:01.614
will extract the APKs that 
matches this 

04:45:02.707 --> 04:45:04.545
configuration from the APK set 
and then install them on to the 

04:45:04.546 --> 04:45:09.420
device.  This is the same 
selection that play does when 

04:45:09.421 --> 04:45:14.918
serving APKs for a given device.
   One more thing that bundle 

04:45:14.919 --> 04:45:16.919
tool can 

04:45:18.010 --> 04:45:19.684
do is to generate a universal 
APK by passing the universal 

04:45:19.685 --> 04:45:21.685
flag.

04:45:23.974 --> 04:45:26.646
The universal APK is a single 
APK that contains the file, all 

04:45:26.647 --> 04:45:28.785
the files for that matches all 
the devices.

04:45:34.775 --> 04:45:36.775
Because of that, it can be 
installed in any device.

04:45:37.799 --> 04:45:39.629
Well, it really doesn't 
represent what your users will 

04:45:39.630 --> 04:45:42.121
receive when they install the 
applications from Play Store.

04:45:45.985 --> 04:45:48.026
However, this is a convenient 
way to pass an APK to the user 

04:45:48.027 --> 04:45:51.692
when you don't know what device 
they are running.

04:45:54.126 --> 04:45:56.165
Bundle tool is also the tool 
used to build Android App 

04:45:56.166 --> 04:45:58.166
Bundle.

04:46:00.247 --> 04:46:03.120
And Gradle uses it behind the 
scenes.  We are going to work 

04:46:03.121 --> 04:46:05.965
with the other build tool chains
to integrate build 

04:46:09.661 --> 04:46:11.661
tool so that you can build and 
Android 

04:46:13.119 --> 04:46:15.119
App Bundle using any tool you 
may be using.

04:46:15.752 --> 04:46:18.205
Finally we want to be 
transparent about how we 

04:46:18.206 --> 04:46:22.755
generate the packs we deliver to
your users, which is why we are 

04:46:22.756 --> 04:46:25.034
open sourcing bundle tool.  You 
can go today to GitHub.

04:46:29.118 --> 04:46:31.766
com/Google/bundle tool to 
download an executable or build 

04:46:31.767 --> 04:46:34.800
it from the source.
   Now, Pierre is going to talk 

04:46:34.801 --> 04:46:40.573
about another way to make your 
applications even smaller.

04:46:42.188 --> 04:46:44.188
&gt;&gt; PIERRE LECESNE:  Thanks, Ibo.

04:46:48.288 --> 04:46:50.545
With dynamic delivery we 
introduce a new way to tbraik up

04:46:50.546 --> 04:46:52.785
those into different features 
and deliver only those for each 

04:46:52.786 --> 04:46:57.281
user.  Suppose you have a recipe
app and want to keep the initial

04:46:57.282 --> 04:46:59.526
download small.  You observe 
that while all your users 

04:47:02.846 --> 04:47:05.341
like to browse recipes, only a 
small fraction choose to 

04:47:05.342 --> 04:47:08.311
actually add a new recipe.  You 
notice that this functionality 

04:47:10.332 --> 04:47:12.332
takes up significant space in 
your app.

04:47:12.395 --> 04:47:15.279
What you can do is break that 
feature out into its own module 

04:47:15.280 --> 04:47:19.578
and serve it only when needed.
   We can see how it looks for a

04:47:19.579 --> 04:47:21.579
user here.

04:47:23.653 --> 04:47:28.745
Let's open the app.  When the 
user wants to add a recipe, he 

04:47:28.746 --> 04:47:30.746
clicks a little plus on the 
bottom 

04:47:31.823 --> 04:47:33.868
and you can see in the 
background the module is 

04:47:33.869 --> 04:47:35.869
downloaded and installed.

04:47:37.371 --> 04:47:39.371
And just after a few seconds, 
the 

04:47:40.422 --> 04:47:42.422
module is ready to be used.

04:47:44.089 --> 04:47:45.517
So which part of your app should
you break out as separate 

04:47:45.518 --> 04:47:47.518
features?

04:47:48.566 --> 04:47:51.010
If only a small fraction of your
users use that feature, that 

04:47:51.011 --> 04:47:55.494
could be a good candidate, 
especially if that feature takes

04:47:55.495 --> 04:47:57.495
up significant space in your 
app.

04:47:57.953 --> 04:48:00.425
Finally, consider if your users 
can wait a few seconds before 

04:48:00.426 --> 04:48:05.098
using the feature.
   Once you've decided which 

04:48:05.099 --> 04:48:07.955
feature to create, this is how 
it should look like in the App 

04:48:07.956 --> 04:48:12.231
Bundle.  In addition to the base
directory there are now separate

04:48:12.232 --> 04:48:16.304
directories for each of the 
modules of the app.  The format 

04:48:16.305 --> 04:48:18.327
of the directories is exactly 
the same as the format of the 

04:48:20.344 --> 04:48:22.344
base that I covered earlier.

04:48:25.481 --> 04:48:27.481
And this is the APKs display 
that would be generated.

04:48:30.771 --> 04:48:32.771
Each module has a set of sets  

04:48:34.430 --> 04:48:36.430
consisting of future splits and 
config splits for that module.

04:48:39.334 --> 04:48:41.334
Anthony mentioned that Split 
APKs were 

04:48:42.810 --> 04:48:44.810
only introduced with Android 
Lollipop.

04:48:48.357 --> 04:48:49.986
You can mark -- single APK with 
a specified module merged 

04:48:49.987 --> 04:48:51.987
together.

04:48:53.450 --> 04:48:58.122
   Now that we have covered how 
dynamic features work, let me 

04:48:58.123 --> 04:49:01.577
hand it over to Ibo who will 
show you how to create them.

04:49:02.809 --> 04:49:04.809
&gt;&gt; IBRAHIM KARAHAN:  Thanks, 
Pierre.

04:49:06.046 --> 04:49:08.046
To create a dynamic module all 
you 

04:49:09.900 --> 04:49:11.900
need to do is download Android 
3.

04:49:13.209 --> 04:49:15.209
2 Canary and use the dynamic 
feature Wizard included.

04:49:16.875 --> 04:49:18.922
Click on the new module and file
menu.  Choose the dynamic 

04:49:18.923 --> 04:49:20.923
module.

04:49:22.392 --> 04:49:24.392
While typing in the name, 
Android 

04:49:26.537 --> 04:49:28.759
studio will create a new dynamic
module for you.  You can also do

04:49:28.760 --> 04:49:32.293
the same thing manually by 
editing the manifest and build 

04:49:32.294 --> 04:49:34.294
up Gradle files.

04:49:35.509 --> 04:49:37.763
You start with the manifest of 
your new module.  The first step

04:49:37.764 --> 04:49:43.503
is to declare this module as a 
new Split APK of your app.  To 

04:49:43.504 --> 04:49:45.504
do so, you are going to add the 

04:49:46.594 --> 04:49:48.594
split attribute in the manifest 
tag and 

04:49:50.884 --> 04:49:51.889
give a name which is VR 
underscore viewer in this 

04:49:51.890 --> 04:49:53.890
example.

04:49:55.145 --> 04:50:00.062
   The next step is to add a 
module tag which is going to 

04:50:00.063 --> 04:50:02.507
declare a module and you are 
going to give a title to the 

04:50:02.707 --> 04:50:04.707
module.

04:50:05.772 --> 04:50:08.313
This tag is used by Play Store 
to identify the modules of your 

04:50:08.314 --> 04:50:13.623
application.
   Next you declare this module 

04:50:13.624 --> 04:50:17.275
as an on-demand module by adding
the on-demand attribute.

04:50:21.324 --> 04:50:22.363
This means that this module is 
only going to be delivered to 

04:50:22.364 --> 04:50:26.670
the user's device when the app  
requests it from the Play Store 

04:50:26.671 --> 04:50:28.671
instead of  delivering it in 
install time.

04:50:33.783 --> 04:50:35.783
Of course, we now know that 
dpoamed 

04:50:36.815 --> 04:50:38.815
modules are only available on N 
plus devices.

04:50:42.156 --> 04:50:45.010
If you choose to provide this to
pre-L devices you use the fusing

04:50:45.011 --> 04:50:47.011
device to instruct Play Store to
include this 

04:50:54.399 --> 04:50:56.399
module along the module at 
install time 

04:51:00.493 --> 04:51:04.342
or in the APK.
   Start with the dike module.  

04:51:04.343 --> 04:51:06.343
The first thing, we are now 
using a 

04:51:09.426 --> 04:51:11.426
new plug in called ...

04:51:12.703 --> 04:51:14.703
the second thing is, we add the 
base 

04:51:15.946 --> 04:51:18.183
module as dependency to this 
module so that we can access the

04:51:18.184 --> 04:51:20.849
functionality included in the 
base module.

04:51:23.526 --> 04:51:26.187
The will only change required in
the build out Gradle file of the

04:51:26.188 --> 04:51:28.188
base module 

04:51:29.503 --> 04:51:32.382
is to add the dynamic features 
list and put all the dynamic 

04:51:32.383 --> 04:51:34.383
module names into this replies 
list.

04:51:37.338 --> 04:51:39.338
This  instructs Gradle to make 
the 

04:51:40.597 --> 04:51:42.597
resources in the base module 
available to those modules.

04:51:45.740 --> 04:51:47.740
Anthony will show you how to use
those 

04:51:49.630 --> 04:51:51.630
modules with the new Play Store 
library.

04:51:51.634 --> 04:51:53.634
&gt;&gt; ANTHONY MORRIS:  Thanks, Ibo.

04:51:54.680 --> 04:51:56.917
Take a look at how you request 
on-demand modules to be 

04:51:56.918 --> 04:52:00.581
installed when you want them 
installed.  In order to interact

04:52:00.582 --> 04:52:02.582
with the Play 

04:52:05.094 --> 04:52:07.157
Store we are introducing a split
install pape as part of the play

04:52:07.158 --> 04:52:09.400
call library.  This is a Java 
client library that 

04:52:12.650 --> 04:52:15.567
communicates with the Play Store
via IPC on the device and the 

04:52:15.568 --> 04:52:17.568
Play Store 

04:52:18.681 --> 04:52:20.874
communicates with play servers 
to download new modules when you

04:52:20.875 --> 04:52:24.550
request them.  Take a look at 
the code.  It is structured 

04:52:24.551 --> 04:52:27.288
using the sale task framework 
you are probably familiar with 

04:52:31.567 --> 04:52:33.567
from the Google Play services 
and API services on the.

04:52:35.675 --> 04:52:38.386
This is a class called the split
install  manager.  You can 

04:52:38.387 --> 04:52:40.387
construct a request with all 

04:52:41.654 --> 04:52:43.282
the modules you wish to download
and invoke star install to 

04:52:43.283 --> 04:52:45.283
trigger the Play 

04:52:49.230 --> 04:52:51.230
Store to install the triggers 
for those modules.

04:52:52.522 --> 04:52:54.365
The API allows you to listen to 
updates throughout the download 

04:52:54.366 --> 04:52:56.366
and install process.

04:52:58.031 --> 04:52:59.457
You can use this to display 
progress, download progress and 

04:52:59.458 --> 04:53:03.923
the install progress to your 
users while they are waiting for

04:53:03.924 --> 04:53:05.924
the on-demand features to 
download.

04:53:07.430 --> 04:53:09.792
You saw this in the video Pierre
showed when it was downloading 

04:53:09.793 --> 04:53:11.793
the recipe module.

04:53:14.518 --> 04:53:17.494
For large modules you need to 
obtain user information prior to

04:53:17.495 --> 04:53:19.495
the download.

04:53:20.825 --> 04:53:22.825
You need to do this whenever the
strow 

04:53:25.075 --> 04:53:27.075
the requests more than ten Meg 
of requests to be downloaded.

04:53:29.352 --> 04:53:31.352
However, there is an alternative

04:53:32.810 --> 04:53:34.810
option for installing the 
modules if 

04:53:36.345 --> 04:53:39.853
they are not used for immediate 
use, deferred installation API. 

04:53:39.854 --> 04:53:42.317
If you use the simple one line 
to request a deferred install of

04:53:42.318 --> 04:53:44.318
a module, 

04:53:45.386 --> 04:53:46.198
then the module will be 
downloaded at a convenient time 

04:53:46.199 --> 04:53:50.928
for the user.  This is generally
when the user is not using the 

04:53:50.929 --> 04:53:53.999
device and it is charging and on
WiFi.  Because of this we allow 

04:53:54.000 --> 04:53:56.000
you to 

04:53:57.100 --> 04:53:59.335
install larger modules via this 
API without requiring user 

04:53:59.336 --> 04:54:03.434
confirmation, up to 100 
megabytes.  This is a user 

04:54:03.435 --> 04:54:05.435
friendly way to 

04:54:06.897 --> 04:54:08.897
download large on-demand modules
for your app.

04:54:10.786 --> 04:54:13.671
You can also use the split 
install API to manage your 

04:54:13.672 --> 04:54:16.111
on-demand modules so you can see
which modules are currently 

04:54:17.928 --> 04:54:20.171
installed and if the user no 
longer needs that module you can

04:54:20.172 --> 04:54:25.544
request that it be uninstalled 
freeing up space for your users 

04:54:25.545 --> 04:54:27.827
and reducing the footprint of 
your app on their device.

04:54:32.082 --> 04:54:34.540
Now, when you go and install an 
on-demand module on N plus 

04:54:34.541 --> 04:54:38.406
devices the apps do not need to 
be restarted.  The code is 

04:54:38.407 --> 04:54:40.647
available immediately upon the 
install completing and new 

04:54:40.648 --> 04:54:44.704
resources and assets are 
available once you refresh your 

04:54:44.705 --> 04:54:46.705
context object.

04:54:48.577 --> 04:54:51.233
However, on Android L and M, 
installing splits requires the 

04:54:51.234 --> 04:54:53.272
app to restart if you want to 
install them properly.

04:54:56.998 --> 04:54:58.998
But to avoid this we've included
a 

04:55:01.427 --> 04:55:03.884
split come Pat library which 
emulates the install on L and M 

04:55:03.885 --> 04:55:05.929
until we can get to the 
background and properly install 

04:55:06.144 --> 04:55:10.410
it.  This means that your app 
doesn't need to restart and all 

04:55:10.411 --> 04:55:13.328
the things inside this, or 
almost all the things inside 

04:55:14.754 --> 04:55:16.754
this module are immediately 
available to your app.

04:55:19.468 --> 04:55:21.468
You can set this split come Pat 

04:55:23.356 --> 04:55:25.382
library up similar to a multiDex
library in your apps.

04:55:27.413 --> 04:55:29.863
Finally, when you release an 
update to your app play will 

04:55:29.864 --> 04:55:34.128
automatically update both the 
base module and any on-demand 

04:55:34.129 --> 04:55:36.770
modules that it already  
installed.  So the versions of 

04:55:36.771 --> 04:55:39.242
your modules on a device are 
always in sync, always at the 

04:55:41.317 --> 04:55:43.392
same version an partners tell us
this is something that they 

04:55:43.393 --> 04:55:47.518
really like about this model.
   All right.  Let's wrap this 

04:55:47.519 --> 04:55:49.519
all up.

04:55:50.805 --> 04:55:52.805
Starting today all the 
developers can 

04:55:54.274 --> 04:55:56.972
build Android App Bundles in 
Android 3.2 Canary and they will

04:55:56.973 --> 04:56:02.082
be able to publish these on play
to all users.  I encourage all 

04:56:02.083 --> 04:56:04.339
of you to try this out and see 
how much smaller wore app can be

04:56:06.191 --> 04:56:09.041
by switching to the Android App 
Bundle.  We will be rolling out 

04:56:09.042 --> 04:56:11.042
modularization to developers 
over the coming months.

04:56:13.792 --> 04:56:16.127
From today you can start 
building modularized from the 

04:56:16.128 --> 04:56:18.128
studio to Canary 

04:56:21.919 --> 04:56:25.402
and publish them to the internal
and alpha tract.  And then to 

04:56:25.403 --> 04:56:27.664
beta over the comes months.  If 
interested you can register your

04:56:30.710 --> 04:56:32.710
interest in modularization at 
the link provided.

04:56:33.796 --> 04:56:36.286
And with that, thank you, 
everyone, for coming.  If you 

04:56:36.287 --> 04:56:38.785
have any questions, you can grab
us afterwards.  I don't think we

04:56:38.786 --> 04:56:40.786
have time right now.

04:56:41.869 --> 04:56:44.742
Or you can grab us over the next
couple of days in the Sandbox C 

04:56:44.743 --> 04:56:46.743
behind the stage.

04:56:49.223 --> 04:56:50.458
And thank you, have a great I/O.
   (Applause.)

04:56:50.459 --> 04:56:52.459
(Music playing.

04:56:53.480 --> 04:56:55.480
)

04:56:57.910 --> 04:56:59.910
   (The session concluded.

04:57:02.563 --> 04:57:04.563
)

