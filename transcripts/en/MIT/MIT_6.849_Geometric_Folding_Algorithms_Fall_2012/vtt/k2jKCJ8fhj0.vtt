WEBVTT
Kind: captions
Language: en

00:01:11.736 --> 00:01:12.610
PROFESSOR: All right.

00:01:12.610 --> 00:01:15.050
Let's get started.

00:01:15.050 --> 00:01:17.920
So we're continuing on
the theme of linkages.

00:01:17.920 --> 00:01:21.025
And just a brief recollection
from last time-- and also

00:01:21.025 --> 00:01:22.400
changing definitions
a little bit

00:01:22.400 --> 00:01:24.860
and throwing away some
details we won't need-- we

00:01:24.860 --> 00:01:28.730
have the idea of a graph, which
is just vertices and edges.

00:01:28.730 --> 00:01:31.540
And then if we
added edge lengths,

00:01:31.540 --> 00:01:33.590
if we put a number
on each of the edges,

00:01:33.590 --> 00:01:35.420
we've got what we
call the linkage.

00:01:35.420 --> 00:01:39.600
And then if we actually embed
that picture into the plane,

00:01:39.600 --> 00:01:42.410
or into 3D, or whatever
space we're working in,

00:01:42.410 --> 00:01:45.280
into d-dimensional
space, then we

00:01:45.280 --> 00:01:47.270
call that a configuration
of the linkage.

00:01:47.270 --> 00:01:49.950
And in general, there might
be many configurations

00:01:49.950 --> 00:01:51.040
of one linkage.

00:01:51.040 --> 00:01:53.210
If it's going to
fold or move around,

00:01:53.210 --> 00:01:57.060
there is infinitely many
configurations of a linkage.

00:01:57.060 --> 00:01:59.580
And what today is
about is basically when

00:01:59.580 --> 00:02:02.560
there's only one configuration,
versus when there's many,

00:02:02.560 --> 00:02:04.610
at least locally.

00:02:04.610 --> 00:02:06.575
So this is the
concept of rigidity.

00:02:12.220 --> 00:02:19.170
So if we have some
linkage configuration--

00:02:19.170 --> 00:02:25.600
some configuration
of some linkage--

00:02:25.600 --> 00:02:30.010
then we call it
flexible if it can

00:02:30.010 --> 00:02:33.540
move from that configuration
in a non-trivial way.

00:02:39.970 --> 00:02:44.930
So we want a non-trivial
motion starting

00:02:44.930 --> 00:02:45.930
from that configuration.

00:02:50.710 --> 00:02:54.380
And you'll notice that in my
definition of linkage here,

00:02:54.380 --> 00:02:56.550
I did not specify that
some of the vertices

00:02:56.550 --> 00:02:59.230
could be pinned to the
plane or pinned to 3D,

00:02:59.230 --> 00:03:01.240
because we needed
that a lot last time.

00:03:01.240 --> 00:03:07.940
A bunch of our gadgets had fixed
vertices-- pinned vertices.

00:03:07.940 --> 00:03:09.990
I'm going to throw that
away, and the price

00:03:09.990 --> 00:03:11.660
I pay is that whatever
linkage I build

00:03:11.660 --> 00:03:14.280
can float around in my space.

00:03:14.280 --> 00:03:17.750
And so I need to add this
non-trivial specification

00:03:17.750 --> 00:03:24.020
to say that it's not
just a rigid motion.

00:03:24.020 --> 00:03:26.185
It's not just a translation
and/or rotation.

00:03:30.240 --> 00:03:32.000
That's rigid motion.

00:03:32.000 --> 00:03:34.630
So you ignore translations
and rotations, for example,

00:03:34.630 --> 00:03:35.601
by pinning.

00:03:35.601 --> 00:03:37.100
But you can also
just see-- what are

00:03:37.100 --> 00:03:39.310
all the motions I
can do from here?

00:03:39.310 --> 00:03:43.320
If it's just in 2D,
if it's just the three

00:03:43.320 --> 00:03:46.020
dimensions of I can
translate in two ways,

00:03:46.020 --> 00:03:49.600
and I can rotate in one way,
then we don't call it flexible,

00:03:49.600 --> 00:03:50.490
we call it rigid.

00:03:59.950 --> 00:04:02.870
And today is all about
distinguishing rigid scenarios

00:04:02.870 --> 00:04:05.240
from flexible scenarios.

00:04:05.240 --> 00:04:07.790
And yesterday-- or
last class-- was all

00:04:07.790 --> 00:04:10.229
about making things
flexible, and making

00:04:10.229 --> 00:04:11.770
things flexible in
an interesting way

00:04:11.770 --> 00:04:13.480
so that we computed
some polynomial.

00:04:13.480 --> 00:04:15.450
Today, we're really
interested in the case

00:04:15.450 --> 00:04:16.950
where we can make things rigid.

00:04:16.950 --> 00:04:19.709
There are some places,
some situations,

00:04:19.709 --> 00:04:22.079
where you want
things to not move,

00:04:22.079 --> 00:04:23.760
like you're building a building.

00:04:23.760 --> 00:04:25.260
Unless you're really
cool and you're

00:04:25.260 --> 00:04:26.820
making a reconfigurable
building,

00:04:26.820 --> 00:04:28.730
you want it to not move.

00:04:28.730 --> 00:04:30.240
You want it to be rigid.

00:04:30.240 --> 00:04:34.450
And so some classic examples
of this are the truss.

00:04:34.450 --> 00:04:38.790
This is a standard planar
truss of some nearby bridge.

00:04:38.790 --> 00:04:41.670
I have another truss
for the architects.

00:04:41.670 --> 00:04:48.420
It's an octet truss-- or at
least various sections of it

00:04:48.420 --> 00:04:49.530
in the Brussels airport.

00:04:49.530 --> 00:04:51.863
You see these a lot in airports,
especially in ceilings.

00:04:51.863 --> 00:04:54.510
And trusses all over the
place, especially in bridges.

00:04:54.510 --> 00:04:57.090
And they are rigid linkages.

00:04:57.090 --> 00:05:01.440
You've got vertices,
you've got edges.

00:05:01.440 --> 00:05:02.982
In principle, they
could hinge there,

00:05:02.982 --> 00:05:05.190
though they're not usually
designed to allow hinging.

00:05:05.190 --> 00:05:07.460
But the point is even if
they are allowed to hinge,

00:05:07.460 --> 00:05:11.710
it will be a rigid 3D
linkage configuration.

00:05:11.710 --> 00:05:13.580
And these are very
simple examples

00:05:13.580 --> 00:05:19.950
we would like to generalize to
understand the general picture.

00:05:19.950 --> 00:05:21.450
Turns out, the
general picture in 3D

00:05:21.450 --> 00:05:22.699
is not really well understood.

00:05:22.699 --> 00:05:23.990
It's quite complicated.

00:05:23.990 --> 00:05:27.010
But in 2D, which is what
we'll be working in today,

00:05:27.010 --> 00:05:29.010
there's a very good answer,
and it's very clean,

00:05:29.010 --> 00:05:31.880
and you can characterize
all the good rigid 2D

00:05:31.880 --> 00:05:33.700
structures to some extent.

00:05:38.100 --> 00:05:41.170
Let me elaborate a little bit.

00:05:41.170 --> 00:05:44.250
One annoying thing
about rigidity

00:05:44.250 --> 00:05:55.230
is that it depends on the
configuration, not just

00:05:55.230 --> 00:05:56.705
the linkage or the graph.

00:06:00.940 --> 00:06:02.720
So let me draw you a picture.

00:06:05.650 --> 00:06:07.515
Suppose we have a
rigified square.

00:06:07.515 --> 00:06:10.740
I'm going to work
in two dimensions.

00:06:10.740 --> 00:06:11.600
Add some triangles.

00:06:11.600 --> 00:06:12.580
So this thing is rigid.

00:06:12.580 --> 00:06:14.850
A bunch of triangles
in the plane.

00:06:14.850 --> 00:06:20.920
And let's say I do
that, verses-- and I'm

00:06:20.920 --> 00:06:23.974
going to allow crossings here.

00:06:23.974 --> 00:06:25.390
It doesn't really
matter too much.

00:06:37.490 --> 00:06:40.430
If I draw this right-- and
I've done a little better.

00:06:40.430 --> 00:06:43.950
It's easier when I have
a grid-- my graph paper.

00:06:43.950 --> 00:06:45.650
In this situation,
the configuration

00:06:45.650 --> 00:06:48.350
should be rigid, because
this part is rigid,

00:06:48.350 --> 00:06:52.860
and these three
bars are held taut,

00:06:52.860 --> 00:06:54.520
because these vertices
are effectively

00:06:54.520 --> 00:06:56.600
pinned to the rest
of this framework.

00:06:56.600 --> 00:06:58.050
And this is at full length.

00:06:58.050 --> 00:07:00.150
You can't really hinge here.

00:07:00.150 --> 00:07:05.780
Whereas if I flip this triangle
through that vertical line,

00:07:05.780 --> 00:07:07.350
flip that over, I
get this triangle.

00:07:07.350 --> 00:07:09.350
And I did the same thing
for the other triangle.

00:07:09.350 --> 00:07:10.440
I didn't have to.

00:07:10.440 --> 00:07:13.090
But now, suddenly-- and you
can't do that by a motion.

00:07:13.090 --> 00:07:14.910
But if I consider this
other configuration

00:07:14.910 --> 00:07:18.010
where that's the case,
then suddenly these guys,

00:07:18.010 --> 00:07:20.990
which have exactly the same
lengths as they did before,

00:07:20.990 --> 00:07:23.060
have some slack, and
now you can think

00:07:23.060 --> 00:07:26.880
of this as a quadrilateral
which can flex separately.

00:07:26.880 --> 00:07:30.360
So this guy's flexible,
and this guy's rigid.

00:07:32.940 --> 00:07:36.640
This is annoying,
because we'd like

00:07:36.640 --> 00:07:43.086
to-- think of a truss,
or something like this.

00:07:43.086 --> 00:07:44.960
You don't think about
exactly how it's drawn.

00:07:44.960 --> 00:07:46.530
You just think, oh, well,
there's this structure.

00:07:46.530 --> 00:07:47.420
It's got vertices.

00:07:47.420 --> 00:07:49.870
It's like squares
with diagonals.

00:07:49.870 --> 00:07:51.725
Does it work if
they're skewed squares?

00:07:55.030 --> 00:07:57.060
This presumably works.

00:07:57.060 --> 00:07:58.710
We think, oh,
triangles are rigid.

00:07:58.710 --> 00:08:00.762
It shouldn't matter
exactly how they're drawn.

00:08:00.762 --> 00:08:02.220
And it turns out,
most of the time,

00:08:02.220 --> 00:08:03.719
it doesn't matter
how they're drawn.

00:08:03.719 --> 00:08:05.710
This is kind of a
very special case,

00:08:05.710 --> 00:08:07.850
and I want to
formalize that notion

00:08:07.850 --> 00:08:11.240
of "special case" and
"most of the time."

00:08:11.240 --> 00:08:17.920
Because in particular, if I
gave you a particular linkage

00:08:17.920 --> 00:08:20.870
configuration, and I
ask you, is it rigid?

00:08:31.250 --> 00:08:35.510
As I mentioned in the last
class, this is coNP-hard.

00:08:38.070 --> 00:08:40.655
So almost certainly
there's no good algorithm

00:08:40.655 --> 00:08:42.630
to tell you whether
a given linkage

00:08:42.630 --> 00:08:46.590
configuration like this--
versus this-- is rigid.

00:08:46.590 --> 00:08:49.117
That's disconcerting,
because I want

00:08:49.117 --> 00:08:50.950
to have a good
characterization of rigidity.

00:08:50.950 --> 00:08:52.658
And this is true, even
in two dimensions.

00:08:54.770 --> 00:08:57.810
So we're going to change
the problem a little bit

00:08:57.810 --> 00:09:00.817
so suddenly it becomes easy.

00:09:00.817 --> 00:09:02.650
We're going to be a
little bit less precise.

00:09:02.650 --> 00:09:04.775
We're not going be able to
distinguish between this

00:09:04.775 --> 00:09:06.427
and this, but almost
all the time--

00:09:06.427 --> 00:09:08.510
like if this thing just
had a little bit of slack,

00:09:08.510 --> 00:09:09.735
it would be flexible.

00:09:09.735 --> 00:09:11.860
So we're going to ignore
the fact that occasionally

00:09:11.860 --> 00:09:15.750
this thing is taut, and most
of the time, this picture

00:09:15.750 --> 00:09:18.410
would be flexible most
of the ways you draw it.

00:09:22.810 --> 00:09:24.740
All right.

00:09:24.740 --> 00:09:26.610
This is the idea of
generic rigidity.

00:09:35.900 --> 00:09:37.710
We've talked about
generic situations

00:09:37.710 --> 00:09:40.430
before in a single
vertex piece patterns.

00:09:40.430 --> 00:09:42.730
We said, well,
generically, no two angles

00:09:42.730 --> 00:09:44.580
are ever going to be
the same if we just

00:09:44.580 --> 00:09:46.600
sort of perturb
everything a little bit.

00:09:46.600 --> 00:09:48.570
We're going to take
the same idea here.

00:09:48.570 --> 00:09:51.440
And so, for example,
no two edge lengths

00:09:51.440 --> 00:09:52.960
are going to be
the same, but we're

00:09:52.960 --> 00:09:55.690
going to assume a lot more
than that to make life easier.

00:09:59.040 --> 00:10:03.810
The general goal is to
think about the graph-- not

00:10:03.810 --> 00:10:06.825
the linkage, and not
the configuration.

00:10:10.990 --> 00:10:14.220
I want to say that
rigidity is usually

00:10:14.220 --> 00:10:15.290
a property of the graph.

00:10:22.730 --> 00:10:25.310
Most the time, it doesn't matter
what your edge lengths are,

00:10:25.310 --> 00:10:27.060
it doesn't matter
exactly how you draw it,

00:10:27.060 --> 00:10:28.920
it just matters how
things are connected.

00:10:28.920 --> 00:10:30.670
Are they triangles?

00:10:30.670 --> 00:10:34.150
What is that
combinatorial structure?

00:10:34.150 --> 00:10:35.500
The geometry falls out of it.

00:10:35.500 --> 00:10:41.150
I need one term so I can talk
about graphs in a realization.

00:10:48.460 --> 00:10:50.475
This is just shorthand.

00:10:50.475 --> 00:10:52.130
It'll make my life a lot easier.

00:10:52.130 --> 00:10:56.130
It's a configuration of
a linkage of the graph.

00:11:00.440 --> 00:11:01.834
We have three levels.

00:11:01.834 --> 00:11:04.250
The graph, which is just the
combinatorial infrastructure,

00:11:04.250 --> 00:11:05.680
linkage, where you add
the edge lengths, and then

00:11:05.680 --> 00:11:07.410
a configuration
where you draw it.

00:11:07.410 --> 00:11:09.110
I'm going to jump all
the way to the end

00:11:09.110 --> 00:11:10.797
and say, if I
start with a graph,

00:11:10.797 --> 00:11:12.630
I want to go all the
way to a configuration.

00:11:12.630 --> 00:11:14.300
That's a realization.

00:11:14.300 --> 00:11:17.010
And so you can think
of a realization

00:11:17.010 --> 00:11:18.600
as just some mapping.

00:11:18.600 --> 00:11:21.770
It looks exactly
like a configuration.

00:11:21.770 --> 00:11:23.309
Just forget about
the edge lengths.

00:11:23.309 --> 00:11:25.100
You can put the vertices
wherever you want,

00:11:25.100 --> 00:11:26.683
because you haven't
said what the edge

00:11:26.683 --> 00:11:28.590
lengths are supposed to be.

00:11:28.590 --> 00:11:31.210
So by taking a graph and
drawing it in the plane--

00:11:31.210 --> 00:11:33.669
this is going to be our
situation-- you can compute

00:11:33.669 --> 00:11:35.460
what the edge lengths
become, and then see,

00:11:35.460 --> 00:11:37.321
does it flex given
those edge lengths?

00:11:37.321 --> 00:11:38.820
So as soon as you
draw in the plane,

00:11:38.820 --> 00:11:40.070
the edge lengths become fixed.

00:11:40.070 --> 00:11:42.570
But before that, they're
free to be whatever you want.

00:11:42.570 --> 00:11:44.460
You just embed every
vertex into the plane,

00:11:44.460 --> 00:11:47.050
and you get a realization.

00:11:47.050 --> 00:11:48.620
And now I want to
define the notion

00:11:48.620 --> 00:11:52.800
of a generic realization.

00:11:52.800 --> 00:11:58.470
And this is a subtle notion, and
it's a little tricky to define.

00:11:58.470 --> 00:12:00.122
So I'm going to
give the intuition.

00:12:00.122 --> 00:12:02.580
And I will give a definition--
we'll see another definition

00:12:02.580 --> 00:12:03.535
next class, in fact.

00:12:06.090 --> 00:12:12.530
But it's a pretty intuitive
notion, especially

00:12:12.530 --> 00:12:14.070
the way I'll be using it.

00:12:14.070 --> 00:12:16.120
I want to somehow
avoid things that

00:12:16.120 --> 00:12:18.680
are rare-- degenerate
situations.

00:12:18.680 --> 00:12:22.120
And mathematically, that means
lower dimensional situations.

00:12:22.120 --> 00:12:25.430
In general, a
realization-- remember,

00:12:25.430 --> 00:12:34.720
we can think of it as a point
in d times n dimensional space.

00:12:34.720 --> 00:12:38.020
If n is a number vertices,
d is the dimension of space

00:12:38.020 --> 00:12:38.995
that they live in.

00:12:38.995 --> 00:12:40.870
Then we could just write
down the coordinates

00:12:40.870 --> 00:12:42.340
of every vertex separately.

00:12:42.340 --> 00:12:44.797
And the realization
space is just that.

00:12:44.797 --> 00:12:46.005
You can do whatever you want.

00:12:49.190 --> 00:12:53.740
So we would like to throw away
lower dimensional subspaces

00:12:53.740 --> 00:12:55.680
of that that just
make our life easier.

00:12:55.680 --> 00:13:01.000
So for example, I'd like to say
no three points are co-linear.

00:13:05.890 --> 00:13:08.060
So if I take three
points in the plane,

00:13:08.060 --> 00:13:10.930
it's pretty unlikely they
lie on a common line.

00:13:10.930 --> 00:13:13.991
It happens with probability
zero if I had random points.

00:13:13.991 --> 00:13:15.490
Even if I didn't
have random points,

00:13:15.490 --> 00:13:17.365
I just take arbitrary
points and then perturb

00:13:17.365 --> 00:13:21.270
them a tiny bit in a random
neighborhood-- little epsilon

00:13:21.270 --> 00:13:25.230
disk-- then with probability
zero, they will be aligned.

00:13:25.230 --> 00:13:28.550
So I can say a whole bunch of
things like this, maybe no four

00:13:28.550 --> 00:13:35.000
points con-cyclic, which
means lies in a common circle.

00:13:35.000 --> 00:13:35.910
You know, Latin.

00:13:39.566 --> 00:13:43.000
In 3D, you'd assume no
four points are coplanar.

00:13:43.000 --> 00:13:44.220
All these sorts of things.

00:13:44.220 --> 00:13:48.560
In general, what
we can throw away

00:13:48.560 --> 00:13:57.445
is any non-trivial
rational algebraic--

00:13:57.445 --> 00:13:59.565
how many adjectives
can I get in here?

00:13:59.565 --> 00:14:01.775
I think that's all
of them-- equation.

00:14:09.230 --> 00:14:11.025
You can, for example,
write the fact

00:14:11.025 --> 00:14:12.740
that three points
lie in a common line

00:14:12.740 --> 00:14:15.880
as a polynomial with
integer coefficients--

00:14:15.880 --> 00:14:17.780
or definitely
rational coefficients.

00:14:17.780 --> 00:14:19.940
And generally, you take
any polynomial you want,

00:14:19.940 --> 00:14:22.220
it explains some
geometric property.

00:14:22.220 --> 00:14:25.010
If it has rational coefficients,
and it's nontrivial,

00:14:25.010 --> 00:14:28.300
meaning that it's not always
true-- so sometimes it's true,

00:14:28.300 --> 00:14:29.210
sometimes it's false.

00:14:29.210 --> 00:14:32.050
That's all I mean
here-- then you

00:14:32.050 --> 00:14:35.160
can just-- suppose
that doesn't happen.

00:14:35.160 --> 00:14:37.060
Because if you have
an equation, that

00:14:37.060 --> 00:14:38.630
describes a lower
dimensional space.

00:14:38.630 --> 00:14:40.320
You start with d
times n dimensions.

00:14:40.320 --> 00:14:45.080
If you add a constraint on the
coordinates of some vertices--

00:14:45.080 --> 00:14:47.770
over here we have
all the coordinates

00:14:47.770 --> 00:14:48.810
of all the vertices.

00:14:48.810 --> 00:14:50.060
That's what we're thinking of.

00:14:50.060 --> 00:14:51.650
You take any
polynomial over those.

00:14:51.650 --> 00:14:53.370
If that holds, then
that was degenerate,

00:14:53.370 --> 00:14:55.144
and you can throw that away.

00:14:55.144 --> 00:14:57.310
And it may sound weird,
because there are infinitely

00:14:57.310 --> 00:15:00.190
many of these equations,
but for the mathematicians,

00:15:00.190 --> 00:15:01.960
they're only countably many.

00:15:01.960 --> 00:15:05.250
So if you take these spaces,
you take a whole bunch

00:15:05.250 --> 00:15:07.570
of lower dimensional spaces
times countable number,

00:15:07.570 --> 00:15:08.990
it's still lower dimensional.

00:15:08.990 --> 00:15:11.114
And so you can afford to
throw away all this stuff.

00:15:11.114 --> 00:15:13.270
If that doesn't make sense,
don't worry about it.

00:15:13.270 --> 00:15:15.360
I will tell you various
times when we're just

00:15:15.360 --> 00:15:16.960
assuming that we're generic.

00:15:16.960 --> 00:15:18.620
It'll seem like magic,
because whenever

00:15:18.620 --> 00:15:20.490
I get into a situation I
don't like, I'll just say, oh,

00:15:20.490 --> 00:15:21.448
but that's not generic.

00:15:21.448 --> 00:15:22.560
And we move on.

00:15:22.560 --> 00:15:25.990
But this is the formal
version that makes that safe.

00:15:25.990 --> 00:15:28.710
We'll see another version
that's a little more intuitive

00:15:28.710 --> 00:15:29.310
next time.

00:15:29.310 --> 00:15:32.260
But we need other concepts.

00:15:32.260 --> 00:15:35.424
So this it implies that
degenerate situations

00:15:35.424 --> 00:15:36.340
are lower dimensional.

00:15:40.860 --> 00:15:45.234
And what other good
facts do we have?

00:15:45.234 --> 00:15:46.650
So lower dimensional
means this is

00:15:46.650 --> 00:15:48.220
going to happen with
probability zero,

00:15:48.220 --> 00:15:49.970
if you perturb your
vertices a little bit.

00:15:54.130 --> 00:15:57.070
So in particular,
this scenario-- this

00:15:57.070 --> 00:16:00.609
is sort of the generic picture,
where there's some slack here.

00:16:00.609 --> 00:16:02.650
This is extremely rare,
because in particular, we

00:16:02.650 --> 00:16:04.840
have four points co-linear.

00:16:04.840 --> 00:16:07.210
And that's not going to
happen in a generic situation.

00:16:07.210 --> 00:16:09.880
So we would say that this
graph-- a bunch of triangles,

00:16:09.880 --> 00:16:12.590
plus these three bars
connecting the endpoints--

00:16:12.590 --> 00:16:14.970
is generically flexible.

00:16:14.970 --> 00:16:18.040
Most of the time,
it will be flexible.

00:16:18.040 --> 00:16:29.732
And fun fact is
that for any graph--

00:16:29.732 --> 00:16:31.840
and this is not
obvious, but it's

00:16:31.840 --> 00:16:44.915
true-- it's either generically
rigid or generically flexible.

00:16:54.580 --> 00:16:59.610
Generically rigid means that all
generic realizations are rigid.

00:17:09.480 --> 00:17:16.149
And generically flexible
means all generic realizations

00:17:16.149 --> 00:17:17.690
are flexible.

00:17:17.690 --> 00:17:20.290
I'm going to start abbreviating,
because these adjectives get

00:17:20.290 --> 00:17:25.880
really long, especially
with the adverb form.

00:17:25.880 --> 00:17:29.980
So when I said
rigidity is usually

00:17:29.980 --> 00:17:32.660
a property of the graph,
this is what I meant.

00:17:32.660 --> 00:17:35.555
Either you take all the generic
realizations of your graph,

00:17:35.555 --> 00:17:37.430
and they're either all
rigid or all flexible.

00:17:37.430 --> 00:17:39.721
There's going to be the lower
dimensional subsets where

00:17:39.721 --> 00:17:41.351
maybe it's the other way around.

00:17:41.351 --> 00:17:42.850
I'll give you some
examples of that.

00:17:46.050 --> 00:17:54.680
So here-- what the
heck did I draw?

00:17:54.680 --> 00:17:56.932
That's funny.

00:17:56.932 --> 00:17:58.140
One of the edges moved on me.

00:18:00.780 --> 00:18:05.450
If I take a picture
like this-- OK,

00:18:05.450 --> 00:18:07.889
this is flexible, because
I have a quadrilateral here

00:18:07.889 --> 00:18:09.680
that can flex independent
of the triangles.

00:18:09.680 --> 00:18:13.830
But suppose I add a bar between
this vertex and this vertex

00:18:13.830 --> 00:18:18.210
which somehow connects the two
sides of that quadrilateral.

00:18:18.210 --> 00:18:20.945
When this special
case, the way I

00:18:20.945 --> 00:18:23.290
drew, where these triangles
are identical and this

00:18:23.290 --> 00:18:25.475
is a nice rectangle,
this thing is flexible.

00:18:28.420 --> 00:18:34.290
You take this triangle, and
I want to flex the quad,

00:18:34.290 --> 00:18:39.930
so if I rotate the whole thing
like this-- I think it works.

00:18:43.880 --> 00:18:46.117
It twists at the same time.

00:18:46.117 --> 00:18:47.450
Yeah, it's a little hard to see.

00:18:47.450 --> 00:18:49.500
But because these
guys are all parallel,

00:18:49.500 --> 00:18:52.711
this thing can keep them
all parallel, I think,

00:18:52.711 --> 00:18:54.210
and keep all the
distances the same.

00:18:54.210 --> 00:18:56.502
AUDIENCE: All of them are
parallel and the same length?

00:18:56.502 --> 00:18:58.334
PROFESSOR: All parallel
and the same length.

00:18:58.334 --> 00:18:59.700
It's necessary for this to work.

00:18:59.700 --> 00:19:02.360
But you take a generic drawing--
if I perturb this at all,

00:19:02.360 --> 00:19:04.610
it will be rigid.

00:19:04.610 --> 00:19:14.274
so this is rarely flexible,
but generically it's rigid.

00:19:14.274 --> 00:19:15.815
And I have an example
of the reverse.

00:19:27.290 --> 00:19:31.460
The way I've drawn this, where
all these guys in extension

00:19:31.460 --> 00:19:35.200
meet up, and all these guys
are parallel, and so on,

00:19:35.200 --> 00:19:36.840
you can check--
it's a little hard

00:19:36.840 --> 00:19:40.660
to see-- but it's rarely rigid.

00:19:40.660 --> 00:19:44.945
In this case it's rigid, but
generically, it's flexible.

00:19:49.380 --> 00:19:50.930
I wouldn't take this on faith.

00:19:50.930 --> 00:19:55.190
For me to check this, I had
to constructed in Cinderella,

00:19:55.190 --> 00:19:56.440
and then see that it moves.

00:19:56.440 --> 00:19:58.190
And when these things
are almost parallel,

00:19:58.190 --> 00:19:59.450
it moves just a little bit.

00:19:59.450 --> 00:20:01.075
And you can see that
in the limit, when

00:20:01.075 --> 00:20:05.160
all these things line up
nicely, it doesn't move at all.

00:20:05.160 --> 00:20:07.150
The point is that there
are these exceptions.

00:20:07.150 --> 00:20:09.080
That's all you need to believe.

00:20:09.080 --> 00:20:11.995
But most the time, we're
going to get the right answer.

00:20:11.995 --> 00:20:13.370
And so, the rest
of this class is

00:20:13.370 --> 00:20:15.260
about characterizing when
a graph is generically

00:20:15.260 --> 00:20:16.610
rigid or generically flexible.

00:20:16.610 --> 00:20:18.110
It's a nice problem,
because it just

00:20:18.110 --> 00:20:19.790
depends on the
combinatorial structure,

00:20:19.790 --> 00:20:21.790
but occasionally, it will
give the wrong answer.

00:20:21.790 --> 00:20:24.590
If you've set things up
with very special geometry,

00:20:24.590 --> 00:20:25.990
it might be the
other way around.

00:20:25.990 --> 00:20:26.489
Question?

00:20:26.489 --> 00:20:30.922
AUDIENCE: Is it fair to think
the rigidity is happening right

00:20:30.922 --> 00:20:33.420
before it no longer works?

00:20:33.420 --> 00:20:34.270
PROFESSOR: Yeah.

00:20:34.270 --> 00:20:35.456
Right.

00:20:35.456 --> 00:20:37.080
The rigidity is kind
of happening right

00:20:37.080 --> 00:20:37.920
before it breaks.

00:20:37.920 --> 00:20:40.130
In some sense, there is a
nontrivial motion there,

00:20:40.130 --> 00:20:42.740
it just happens
to be super short.

00:20:42.740 --> 00:20:44.560
It's hard to define
that formally,

00:20:44.560 --> 00:20:46.580
but intuitively, that's
what's happening.

00:20:46.580 --> 00:20:51.710
And you can think of this thing
as being a little bit wobbly,

00:20:51.710 --> 00:20:53.910
but not technically flexible.

00:20:53.910 --> 00:20:56.470
There's actually a formal
notion of wobbly in the rigidity

00:20:56.470 --> 00:21:02.540
literature, which we probably
will talk about next class.

00:21:02.540 --> 00:21:04.010
Would this be wobbly?

00:21:04.010 --> 00:21:04.630
Probably.

00:21:04.630 --> 00:21:07.320
I'd have to think about it.

00:21:07.320 --> 00:21:08.910
Wobbly is a computable notion.

00:21:08.910 --> 00:21:10.510
It's nice.

00:21:10.510 --> 00:21:12.900
So rigidity theory is
actually pretty old.

00:21:12.900 --> 00:21:16.150
In the mechanical, structural
engineering worlds,

00:21:16.150 --> 00:21:21.910
it goes back to Cremona
In the 17th, 18th century.

00:21:21.910 --> 00:21:23.390
The mathematics
even is pretty old.

00:21:23.390 --> 00:21:28.520
The next big theorem we'll
talk about is from 1911.

00:21:28.520 --> 00:21:31.470
It's probably one of the
earliest formal mathematical

00:21:31.470 --> 00:21:35.280
treatments, and it started to
address exactly this issue.

00:21:35.280 --> 00:21:37.050
In two dimensions,
which graphs are rigid,

00:21:37.050 --> 00:21:40.420
which are flexible
in the generic sense?

00:21:40.420 --> 00:21:44.970
It's become pretty popular and
interesting in the last 10,

00:21:44.970 --> 00:21:49.730
20 years, and a
lot more action--

00:21:49.730 --> 00:21:51.400
a lot more theorems and whatnot.

00:21:51.400 --> 00:21:55.560
Today we're going to talk
mostly about old things.

00:21:55.560 --> 00:21:59.630
Next class we'll do some newer
things in the rigidity world.

00:21:59.630 --> 00:22:01.870
I got interested in rigidity
because it turned out

00:22:01.870 --> 00:22:05.727
to be really important
for folding linkages.

00:22:05.727 --> 00:22:07.560
Not just telling whether
a linkage is rigid,

00:22:07.560 --> 00:22:11.170
which is important for things
like building rigid structures,

00:22:11.170 --> 00:22:13.820
but for actually folding
things and showing

00:22:13.820 --> 00:22:16.370
that you can fold the linkage
from any configuration

00:22:16.370 --> 00:22:17.390
to any other.

00:22:17.390 --> 00:22:20.410
Turns out rigidity is
really useful for that.

00:22:20.410 --> 00:22:22.730
And that's not at all obvious.

00:22:22.730 --> 00:22:26.680
It's kind of a surprise,
and a fun surprise.

00:22:26.680 --> 00:22:28.360
We'll be talking
about that next class.

00:22:28.360 --> 00:22:30.860
Today, sort of classic
stuff-- understanding

00:22:30.860 --> 00:22:33.820
when 2D graphs are rigid.

00:22:33.820 --> 00:22:35.680
I'll give you an idea
why 3D is much harder.

00:22:38.300 --> 00:22:42.270
OK, we need one more notion.

00:22:42.270 --> 00:22:46.160
This is a real long-winded
thing-- minimally

00:22:46.160 --> 00:22:52.440
generically rigid graph.

00:22:55.350 --> 00:22:57.230
So the new addition
here is minimally.

00:22:57.230 --> 00:23:04.710
This is going to be some
generically rigid graph,

00:23:04.710 --> 00:23:06.390
and it also has
the property that

00:23:06.390 --> 00:23:13.220
removing any edge makes the
graph generically flexible.

00:23:19.072 --> 00:23:20.530
So it's minimal in
the sense that I

00:23:20.530 --> 00:23:24.550
can't get rid of any edges and
still be generically rigid.

00:23:24.550 --> 00:23:26.640
So the idea is,
let's characterize

00:23:26.640 --> 00:23:28.150
minimally generically
rigid graphs.

00:23:28.150 --> 00:23:31.020
If I can characterize those,
then the generically rigid ones

00:23:31.020 --> 00:23:32.754
are just those plus
some more edges.

00:23:32.754 --> 00:23:34.420
You could throw in
extra edges-- it only

00:23:34.420 --> 00:23:35.419
makes things more rigid.

00:23:35.419 --> 00:23:37.030
It's more constraints.

00:23:37.030 --> 00:23:39.560
But I'm really interested
in the boundary

00:23:39.560 --> 00:23:42.180
between generically region
and generically flexible,

00:23:42.180 --> 00:23:44.740
and this is exactly the
boundary on the rigid side--

00:23:44.740 --> 00:23:45.680
just barely rigid.

00:23:48.980 --> 00:23:55.320
So first thing-- if you've
done structural engineering,

00:23:55.320 --> 00:24:00.000
this will start to
look familiar-- is

00:24:00.000 --> 00:24:03.950
how many edges should a
minimally generically rigid

00:24:03.950 --> 00:24:05.300
graph have?

00:24:05.300 --> 00:24:08.980
And we can think of this in
a very intuitive way, which

00:24:08.980 --> 00:24:11.870
is-- let's see.

00:24:11.870 --> 00:24:15.120
If I don't have any
edges, every vertex

00:24:15.120 --> 00:24:16.769
can float around separately.

00:24:16.769 --> 00:24:18.310
So the number of
degrees of freedom--

00:24:18.310 --> 00:24:22.660
the dimensionality of my
realization space, in fact--

00:24:22.660 --> 00:24:25.250
is in two dimensions
two times m.

00:24:25.250 --> 00:24:28.090
I'm going to do to 2D first.

00:24:28.090 --> 00:24:31.232
Every vertex has two
degrees of freedom.

00:24:31.232 --> 00:24:33.690
Now I would like to reduce the
number of degrees of freedom

00:24:33.690 --> 00:24:35.390
to what number?

00:24:38.240 --> 00:24:39.190
AUDIENCE: Zero.

00:24:39.190 --> 00:24:39.960
PROFESSOR: Zero.

00:24:39.960 --> 00:24:43.173
It's often a good answer, but
sadly not the right one here.

00:24:43.173 --> 00:24:43.845
AUDIENCE: Two.

00:24:43.845 --> 00:24:44.470
PROFESSOR: Two.

00:24:44.470 --> 00:24:45.940
Close.

00:24:45.940 --> 00:24:46.720
AUDIENCE: Three.

00:24:46.720 --> 00:24:47.560
PROFESSOR: Three.

00:24:47.560 --> 00:24:48.389
Right guess.

00:24:48.389 --> 00:24:50.055
We'll just keep trying
all the integers.

00:24:52.717 --> 00:24:54.300
I mentioned this at
the very beginning

00:24:54.300 --> 00:24:55.889
that if the best
we could hope for

00:24:55.889 --> 00:24:57.680
is that there are three
degrees of freedom,

00:24:57.680 --> 00:24:59.888
we'll never be able to get
rid of the two translation

00:24:59.888 --> 00:25:03.030
degrees and the one rotation
degree in two dimensions.

00:25:03.030 --> 00:25:07.370
In general, it is d
times d plus 1 over 2

00:25:07.370 --> 00:25:12.130
is the number of dimensions of
rigid motions in d dimensions.

00:25:12.130 --> 00:25:14.750
And here we start with dn.

00:25:14.750 --> 00:25:17.220
So that's in d dimensions.

00:25:17.220 --> 00:25:19.560
This is really how many
edges you should have,

00:25:19.560 --> 00:25:23.150
because if I have
exactly 2n minus 3 edges,

00:25:23.150 --> 00:25:25.400
I will have started with
2n degrees of freedom.

00:25:25.400 --> 00:25:28.230
Every edge that I
add is one equation,

00:25:28.230 --> 00:25:30.660
so it should reduce
my dimension by one

00:25:30.660 --> 00:25:33.580
in the generic sense--
it's a generic case--

00:25:33.580 --> 00:25:35.920
and the best I can hope for
is to get down to three.

00:25:35.920 --> 00:25:38.310
If you put in more edges,
you won't get any more rigid.

00:25:38.310 --> 00:25:41.580
I mean, you'll still be rigid,
but if I want the minimal case,

00:25:41.580 --> 00:25:44.020
this is really the
best I should hope for.

00:25:44.020 --> 00:25:45.900
And this is just a rough sketch.

00:25:45.900 --> 00:25:48.530
This is proved more
formally in the notes here,

00:25:48.530 --> 00:25:51.140
but this really
is a formal thing.

00:25:51.140 --> 00:25:53.800
Again, if you take some
polynomial equation,

00:25:53.800 --> 00:25:57.160
most of the time
it's going to define

00:25:57.160 --> 00:26:00.370
a space that is one
dimension lower.

00:26:00.370 --> 00:26:03.610
So in the generic situation,
every equation you add

00:26:03.610 --> 00:26:06.062
will remove exactly
one degree of freedom.

00:26:06.062 --> 00:26:08.270
There are rare scenarios
where it doesn't remove any,

00:26:08.270 --> 00:26:11.467
and they're rare scenarios
where it removes more than one,

00:26:11.467 --> 00:26:13.050
and I have some
pictures of them here.

00:26:13.050 --> 00:26:16.006
But most of the
time, this is right.

00:26:16.006 --> 00:26:17.630
And we are in the
generic case, so most

00:26:17.630 --> 00:26:20.450
the time is all we need.

00:26:20.450 --> 00:26:22.000
So this gives us an idea.

00:26:22.000 --> 00:26:25.690
And about how many people have
heard of 2n minus 3 before

00:26:25.690 --> 00:26:28.010
in this structural
engineering context?

00:26:28.010 --> 00:26:29.900
A few.

00:26:29.900 --> 00:26:31.770
And sometimes, people
end the story there.

00:26:31.770 --> 00:26:34.404
But this is not enough
to be generically rigid.

00:26:34.404 --> 00:26:36.695
This is a necessary condition,
but it's not sufficient.

00:26:39.200 --> 00:26:41.682
And you can check
all these examples.

00:26:41.682 --> 00:26:42.720
It should match up.

00:26:42.720 --> 00:26:43.970
I haven't checked them myself.

00:26:57.830 --> 00:26:59.640
All right.

00:26:59.640 --> 00:27:01.750
Let's start
characterizing this thing.

00:27:11.640 --> 00:27:14.450
We're going to see two
characterizations of minimally

00:27:14.450 --> 00:27:17.620
generically rigid graphs.

00:27:17.620 --> 00:27:21.190
First one is very intuitive,
nice to work with by hand,

00:27:21.190 --> 00:27:23.494
but doesn't-- at least
as far as I can tell,

00:27:23.494 --> 00:27:24.910
it doesn't turn
into an algorithm.

00:27:24.910 --> 00:27:30.370
I think we've tried in
past years, but it has not.

00:27:30.370 --> 00:27:33.660
And the other one
is more algorithmic,

00:27:33.660 --> 00:27:35.750
but a little bit hard to intuit.

00:27:53.380 --> 00:27:55.120
So this is what both
theorems look like.

00:27:55.120 --> 00:27:56.953
A graph is minimally
generically rigid in 2D

00:27:56.953 --> 00:28:05.120
if and only if-- for Henneberg,
this is from the 1911 result--

00:28:05.120 --> 00:28:08.540
it can be built.

00:28:25.276 --> 00:28:25.900
Oh, by the way.

00:28:25.900 --> 00:28:28.035
Maybe the reason people
haven't seen 2n minus three

00:28:28.035 --> 00:28:29.660
is because they're
used to the 3D case.

00:28:29.660 --> 00:28:30.910
There it's 2n minus 6.

00:28:30.910 --> 00:28:33.610
How many people have
seen 3n minus 6?

00:28:33.610 --> 00:28:34.290
Same people.

00:28:34.290 --> 00:28:35.780
All right.

00:28:35.780 --> 00:28:37.390
Thought I'd try.

00:28:37.390 --> 00:28:39.237
All right.

00:28:39.237 --> 00:28:41.070
You guys should take
structural engineering.

00:28:48.370 --> 00:28:50.770
So this is the form
of the theorem.

00:28:50.770 --> 00:28:53.600
The idea is we're starting
with a single edge connecting

00:28:53.600 --> 00:28:56.610
two vertices, which is
minimally generically rigid.

00:28:56.610 --> 00:28:58.960
All it can do is
rotate and translate.

00:28:58.960 --> 00:29:01.340
And the claim is whatever
you want to build,

00:29:01.340 --> 00:29:06.990
I can build it using just
two types of operations.

00:29:06.990 --> 00:29:11.730
First type is I take something
that I've already built.

00:29:11.730 --> 00:29:14.840
I add one new vertex,
and I attach it

00:29:14.840 --> 00:29:18.530
to two existing vertices.

00:29:18.530 --> 00:29:20.890
So everything in
the circle is old,

00:29:20.890 --> 00:29:25.214
and the new thing is that
vertex and those two guys.

00:29:25.214 --> 00:29:27.284
AUDIENCE: Everything
is old and rigid.

00:29:27.284 --> 00:29:27.950
PROFESSOR: Yeah.

00:29:27.950 --> 00:29:29.616
This is something
that you could already

00:29:29.616 --> 00:29:31.822
build from this-- I
mean, in particular,

00:29:31.822 --> 00:29:33.530
that will be minimally
generically rigid.

00:29:33.530 --> 00:29:36.000
But that's not what
we're saying right now.

00:29:36.000 --> 00:29:38.300
You start from the edge, and
you just keep doing this.

00:29:38.300 --> 00:29:41.030
So I can turn it into a
triangle, for example.

00:29:41.030 --> 00:29:43.500
Just keep taking things that
I already know how to build,

00:29:43.500 --> 00:29:46.730
add one vertex and two edges.

00:29:46.730 --> 00:29:48.600
The other type of
operation, I take

00:29:48.600 --> 00:29:50.660
something I've already built.

00:29:50.660 --> 00:29:55.220
I take three of the
vertices in there,

00:29:55.220 --> 00:30:01.010
and there's already an edge
between them-- at least one.

00:30:01.010 --> 00:30:03.040
There might be more.

00:30:03.040 --> 00:30:08.360
And I add three edges
connecting to a new vertex,

00:30:08.360 --> 00:30:12.800
and I delete that old edge.

00:30:12.800 --> 00:30:17.130
So I add three, I remove one.

00:30:17.130 --> 00:30:18.960
Either I add two
and remove zero,

00:30:18.960 --> 00:30:20.884
or I add three and remove one.

00:30:20.884 --> 00:30:22.550
This should make
sense, because if we're

00:30:22.550 --> 00:30:25.850
going to get about
two edges per vertex,

00:30:25.850 --> 00:30:28.070
this is just the starting case.

00:30:28.070 --> 00:30:30.320
If I want two edges
per vertex, I really

00:30:30.320 --> 00:30:34.239
should only be adding two edges
for every vertex that I add.

00:30:34.239 --> 00:30:35.780
So these are two
things you could do.

00:30:35.780 --> 00:30:37.654
And you could imagine
a more complicated ones

00:30:37.654 --> 00:30:39.410
where I add four
edges, remove two.

00:30:39.410 --> 00:30:41.020
You don't have to
worry about that.

00:30:41.020 --> 00:30:43.554
You only have to worry
about these two scenarios.

00:30:43.554 --> 00:30:44.970
That's enough to
build everything.

00:30:48.460 --> 00:30:56.270
Maybe we can do an example
before we prove this theorem.

00:30:56.270 --> 00:30:58.526
I'm not going to
prove all the parts.

00:30:58.526 --> 00:30:59.650
I'm going to give a sketch.

00:31:03.960 --> 00:31:06.850
In particular, to prove
it, I need technology

00:31:06.850 --> 00:31:08.540
that we'll develop next class.

00:31:08.540 --> 00:31:11.250
So it's a little hard to
do in a self-contained way.

00:31:11.250 --> 00:31:12.875
But let's start with
an easy example.

00:31:18.637 --> 00:31:19.720
You may remember this one.

00:31:19.720 --> 00:31:22.590
When I drew everything
parallel and the triangles

00:31:22.590 --> 00:31:25.360
were identical, then
this thing was flexible.

00:31:25.360 --> 00:31:27.940
But most of the time,
generically, this is rigid,

00:31:27.940 --> 00:31:31.365
and we can prove that by
doing these operations.

00:31:34.680 --> 00:31:37.900
So somehow I start with an edge.

00:31:37.900 --> 00:31:40.129
I have to do operations
to end up here.

00:31:40.129 --> 00:31:41.420
That's a little hard to-- yeah.

00:31:41.420 --> 00:31:42.702
Question.

00:31:42.702 --> 00:31:44.322
AUDIENCE: Does the
removed edge have

00:31:44.322 --> 00:31:47.329
to be between two of
the three vertices?

00:31:47.329 --> 00:31:49.620
PROFESSOR: The removed edge
has to be among those three

00:31:49.620 --> 00:31:50.465
vertices.

00:31:50.465 --> 00:31:51.840
And there might
be more than one.

00:31:51.840 --> 00:31:53.256
You would just
remove one of them.

00:31:53.256 --> 00:31:55.390
You get to remove
whichever one you want.

00:31:55.390 --> 00:31:57.780
Good question.

00:31:57.780 --> 00:32:02.540
So if we were lucky
and adventurous,

00:32:02.540 --> 00:32:06.210
we could just try going here
and hope that we end up there.

00:32:06.210 --> 00:32:09.054
But we don't want to draw all
the possible things we could

00:32:09.054 --> 00:32:10.470
make, because
that's all minimally

00:32:10.470 --> 00:32:11.920
generically rigid graphs.

00:32:11.920 --> 00:32:14.830
It's a lot easier
to think backwards,

00:32:14.830 --> 00:32:17.850
as often the case in puzzles.

00:32:17.850 --> 00:32:23.000
If I want to make this, what was
the last operation that I did?

00:32:23.000 --> 00:32:25.550
It must have been
one of these two.

00:32:25.550 --> 00:32:27.420
And every vertex here
has degree three,

00:32:27.420 --> 00:32:29.210
has three incident edges.

00:32:29.210 --> 00:32:32.572
So probably it was
a Type II operation.

00:32:32.572 --> 00:32:34.530
So there's going to be
a Type II operation that

00:32:34.530 --> 00:32:35.940
results in this thing.

00:32:35.940 --> 00:32:38.032
Let's say, I don't
know, this vertex.

00:32:38.032 --> 00:32:39.990
And here I still have to
be a little bit lucky,

00:32:39.990 --> 00:32:43.020
but it's not quite as lucky.

00:32:43.020 --> 00:32:50.590
OK so I'm going to
try not to cheat here.

00:32:50.590 --> 00:32:53.350
So we remove that
vertex, and we also

00:32:53.350 --> 00:32:56.500
remove some edge
among these guys.

00:32:56.500 --> 00:33:01.531
So I'm going to guess
that I removed that edge.

00:33:01.531 --> 00:33:04.010
I think that'll work.

00:33:04.010 --> 00:33:04.970
I have to be careful.

00:33:04.970 --> 00:33:08.082
I could have removed this edge.

00:33:08.082 --> 00:33:08.915
There are two cases.

00:33:11.690 --> 00:33:14.490
I'll explain later what
we need to check here.

00:33:14.490 --> 00:33:16.830
Well, now I see a
nice Type I operation.

00:33:16.830 --> 00:33:20.500
I'll just get rid
of that vertex.

00:33:20.500 --> 00:33:21.540
Good.

00:33:21.540 --> 00:33:23.120
So Type I operation.

00:33:23.120 --> 00:33:29.430
I'm left with this, and I see
two more Type I operations.

00:33:29.430 --> 00:33:30.780
I'll do them one at a time.

00:33:38.840 --> 00:33:41.145
Ta da.

00:33:41.145 --> 00:33:42.020
I think that's right.

00:33:42.020 --> 00:33:43.580
We can play it forwards
just to double check,

00:33:43.580 --> 00:33:44.704
but I started with an edge.

00:33:44.704 --> 00:33:47.130
I added one vertex connected
to the existing two.

00:33:47.130 --> 00:33:50.080
I added another vertex
connecting to two existing.

00:33:50.080 --> 00:33:52.470
I added another vertex
connected to two existing.

00:33:52.470 --> 00:33:55.650
And then the tricky one--
I added this vertex here,

00:33:55.650 --> 00:33:59.830
I connected it to these three,
and I removed this edge.

00:33:59.830 --> 00:34:02.610
So because this works
forwards, this theorem

00:34:02.610 --> 00:34:04.880
tells us that graph is
minimally generically rigid.

00:34:04.880 --> 00:34:06.817
Now we have a way to test.

00:34:06.817 --> 00:34:08.400
Now, the algorithm
is a little tricky,

00:34:08.400 --> 00:34:10.589
because I had a choice here.

00:34:10.589 --> 00:34:11.880
In this case, it didn't matter.

00:34:11.880 --> 00:34:13.463
In the notes, there's
an example where

00:34:13.463 --> 00:34:16.360
if you do the wrong
choice-- you go backwards

00:34:16.360 --> 00:34:19.344
and you add in the wrong
edge-- it doesn't work.

00:34:19.344 --> 00:34:21.719
You don't become minimally
generically rigid, essentially

00:34:21.719 --> 00:34:24.070
because one part
gets too many edges,

00:34:24.070 --> 00:34:25.770
and another part has too few.

00:34:25.770 --> 00:34:27.800
Here, I got it balanced,
and it worked out.

00:34:27.800 --> 00:34:29.550
And when you're good
at visualizing these,

00:34:29.550 --> 00:34:32.170
this is an easy way-- like
on your problem set two--

00:34:32.170 --> 00:34:34.760
this is an easy way to check,
to prove to me that things

00:34:34.760 --> 00:34:36.620
are minimally generically rigid.

00:34:36.620 --> 00:34:38.469
Just have to be
a little careful.

00:34:38.469 --> 00:34:43.190
If you fail, and you fail to
get back to start in this way,

00:34:43.190 --> 00:34:44.340
that doesn't tell you much.

00:34:44.340 --> 00:34:45.830
You just may have messed up.

00:34:45.830 --> 00:34:48.732
You may have made the
wrong choice along the way.

00:34:48.732 --> 00:34:50.190
But when it works,
you know that it

00:34:50.190 --> 00:34:52.814
works, because you
can play it forwards.

00:34:52.814 --> 00:34:53.798
AUDIENCE: [INAUDIBLE]

00:34:59.244 --> 00:34:59.910
PROFESSOR: Yeah.

00:34:59.910 --> 00:35:02.280
By forward, I mean starting
from the single edge

00:35:02.280 --> 00:35:05.260
and following the arrows in
the way that they're pointing.

00:35:05.260 --> 00:35:08.500
So going backwards is a little
bit of a lucky black art,

00:35:08.500 --> 00:35:09.480
whatever.

00:35:09.480 --> 00:35:12.110
But once you succeed, you
can play it forwards and say,

00:35:12.110 --> 00:35:13.835
oh yeah, that clearly works.

00:35:13.835 --> 00:35:15.729
Another question.

00:35:15.729 --> 00:35:18.103
AUDIENCE: Do you know if it
matters whether you do Type I

00:35:18.103 --> 00:35:20.540
or Type II operations
first, if you have choices?

00:35:20.540 --> 00:35:22.540
PROFESSOR: Does it matter
Type I versus Type II?

00:35:22.540 --> 00:35:25.530
I don't think it matters in
general, just with Type II,

00:35:25.530 --> 00:35:26.582
you have to be careful.

00:35:26.582 --> 00:35:28.040
Type one, I like
to do immediately,

00:35:28.040 --> 00:35:29.860
because there's no choice.

00:35:29.860 --> 00:35:31.420
You just do them.

00:35:31.420 --> 00:35:32.430
Type Is are always safe.

00:35:32.430 --> 00:35:34.780
Type II, it depends which edge.

00:35:34.780 --> 00:35:37.010
And I should call these
anti-type II operations

00:35:37.010 --> 00:35:38.840
when you go backwards.

00:35:38.840 --> 00:35:42.050
Anti-Type II, it depends
which edge you add.

00:35:42.050 --> 00:35:44.335
So I like to do Type Is
whenever I have the chance.

00:35:47.530 --> 00:35:49.460
All right.

00:35:49.460 --> 00:35:52.680
Let me sketch a proof
of this theorem.

00:36:08.790 --> 00:36:11.500
There are two directions
we need to prove.

00:36:11.500 --> 00:36:15.240
We need to prove that if
we build such a thing,

00:36:15.240 --> 00:36:16.690
it is minimally
generically rigid.

00:36:16.690 --> 00:36:17.680
I'm going to start with that.

00:36:17.680 --> 00:36:19.054
And the other one
we need to show

00:36:19.054 --> 00:36:22.180
is that everything can
be built in this way.

00:36:22.180 --> 00:36:23.990
The first direction
is not too hard,

00:36:23.990 --> 00:36:27.330
although it's still not trivial.

00:36:27.330 --> 00:36:31.177
And this direction works
in any dimension, in fact.

00:36:31.177 --> 00:36:32.760
It doesn't need to
be two dimensional.

00:36:32.760 --> 00:36:35.795
It's the other
direction that's harder.

00:36:44.680 --> 00:36:50.150
So let's suppose I have a
generically rigid graph,

00:36:50.150 --> 00:36:51.895
and I do a Type I operation.

00:36:55.120 --> 00:36:56.890
And I get a graph call G prime.

00:37:04.200 --> 00:37:07.160
I claim that the resulting
graph will also be generically

00:37:07.160 --> 00:37:10.490
rigid and vice versa.

00:37:10.490 --> 00:37:14.910
So doing a Type I operation does
not affect generic rigidity.

00:37:14.910 --> 00:37:21.380
This may be obvious, but
let me explain it to you.

00:37:21.380 --> 00:37:24.470
There's again two directions
you need to prove.

00:37:24.470 --> 00:37:28.480
And let's start with-- which
one do I start with?-- this way.

00:37:32.690 --> 00:37:36.230
So I want to show that if
the new graph is rigid,

00:37:36.230 --> 00:37:38.510
than the old graph is rigid.

00:37:38.510 --> 00:37:40.010
An easier way to
think about that

00:37:40.010 --> 00:37:43.370
is if the old graph
is flexible, then

00:37:43.370 --> 00:37:45.506
the new graph
should be flexible.

00:37:45.506 --> 00:37:46.005
Hm.

00:37:46.005 --> 00:37:47.410
That sounds all right.

00:37:47.410 --> 00:37:53.260
So I have G flexible
generically.

00:37:53.260 --> 00:37:57.560
I want to show that
G prime is flexible.

00:37:57.560 --> 00:38:03.890
So here's G-- what I called old
before-- and it flexes somehow.

00:38:03.890 --> 00:38:07.730
And now I have this
guy that I add on.

00:38:07.730 --> 00:38:11.900
These bars are rigid, but it
can come along for the ride.

00:38:11.900 --> 00:38:15.240
If I move these two
points somewhat,

00:38:15.240 --> 00:38:17.120
I'll still be able
to draw this guy.

00:38:17.120 --> 00:38:20.240
It is defined by the
intersection of two circles,

00:38:20.240 --> 00:38:25.655
one circle centered here,
another circle centered here.

00:38:25.655 --> 00:38:27.780
Those two circles actually
intersect in two points.

00:38:27.780 --> 00:38:30.760
But if I move these
guys continuously,

00:38:30.760 --> 00:38:34.120
this guy can track continuously
along the intersection

00:38:34.120 --> 00:38:39.660
of those two circles, except
in one special case, which

00:38:39.660 --> 00:38:42.360
is when the three
points are collinear.

00:38:42.360 --> 00:38:45.410
So if this is the old,
and here's my new guy,

00:38:45.410 --> 00:38:49.110
and this is taut, and these
guys move away from each other,

00:38:49.110 --> 00:38:51.070
then this guy fails to exist.

00:38:51.070 --> 00:38:51.890
Boom.

00:38:51.890 --> 00:38:53.950
But that's not generic.

00:38:53.950 --> 00:38:56.600
So here's where I
get these genericity.

00:38:56.600 --> 00:38:58.880
This in particular would
have three points collinear.

00:38:58.880 --> 00:38:59.960
So that's forbidden.

00:38:59.960 --> 00:39:04.310
So in a generic situation-- and
I should be putting generically

00:39:04.310 --> 00:39:08.157
here-- if I can generically
flex the original graph,

00:39:08.157 --> 00:39:09.740
I'll still be able
to generically flex

00:39:09.740 --> 00:39:11.680
after I add the vertex.

00:39:11.680 --> 00:39:13.240
Cool.

00:39:13.240 --> 00:39:14.100
That's pretty easy.

00:39:16.355 --> 00:39:18.480
The other direction-- I
mean, it's almost the same.

00:39:18.480 --> 00:39:22.610
So now if I have
G rigid, I claim

00:39:22.610 --> 00:39:27.250
that G prime is generically
rigid-- I should be putting

00:39:27.250 --> 00:39:32.060
generic everywhere here-- for
essentially the same reason.

00:39:32.060 --> 00:39:34.764
If I can't move these
vertices-- this vertex

00:39:34.764 --> 00:39:36.930
is again defined by the
intersection of two circles.

00:39:36.930 --> 00:39:38.700
It could be here or
here, but we're only

00:39:38.700 --> 00:39:40.650
thinking about
continuous motions.

00:39:40.650 --> 00:39:42.070
Motion means continuous.

00:39:42.070 --> 00:39:44.260
I can't instantaneously
jump over here.

00:39:44.260 --> 00:39:45.940
I have to stay right there.

00:39:45.940 --> 00:39:48.900
These guys don't move-- and I
mean that in a relative sense.

00:39:48.900 --> 00:39:50.890
Of course, they can
translate and rotate--

00:39:50.890 --> 00:39:54.290
but if they don't move
away from each other,

00:39:54.290 --> 00:39:57.970
this guy can't do
anything interesting.

00:39:57.970 --> 00:40:00.920
So if the original thing is
rigid, the new thing is rigid.

00:40:00.920 --> 00:40:06.190
I'll start going a little
faster, but that's the idea.

00:40:06.190 --> 00:40:08.620
This is a start, but
what we really care about

00:40:08.620 --> 00:40:09.795
is minimal generic rigidity.

00:40:29.650 --> 00:40:33.930
And this is also if and only if.

00:40:33.930 --> 00:40:36.650
If your original graph is
minimally generically rigid,

00:40:36.650 --> 00:40:39.612
then your new graph
from a Type I operation

00:40:39.612 --> 00:40:41.320
will also be minimally
generically rigid,

00:40:41.320 --> 00:40:42.330
and vice versa.

00:40:42.330 --> 00:40:44.200
So minimality is also preserved.

00:40:44.200 --> 00:40:48.410
So this is a super
safe operation.

00:40:48.410 --> 00:40:49.250
I won't prove this.

00:40:49.250 --> 00:40:51.490
But it's almost the same
proof, except instead

00:40:51.490 --> 00:40:54.659
of thinking about G, you
think about G minus 1 edge,

00:40:54.659 --> 00:40:57.200
because that's what you worry
about in the minimal situation.

00:40:57.200 --> 00:40:59.074
We've already shown that
the generic rigidity

00:40:59.074 --> 00:41:01.710
part is preserved
in either direction,

00:41:01.710 --> 00:41:08.310
doing Type I or anti-Type I.
But for minimality right here,

00:41:08.310 --> 00:41:10.089
we want to think about
removing any edge,

00:41:10.089 --> 00:41:11.880
and whether that gives
generic flexibility.

00:41:11.880 --> 00:41:15.730
So we just do the same thing,
but with G minus e, and G prime

00:41:15.730 --> 00:41:18.630
minus e, where e is
somewhere in the old part.

00:41:18.630 --> 00:41:19.880
And it's the same argument.

00:41:24.110 --> 00:41:27.370
And so you'd write
substitute all instances of G

00:41:27.370 --> 00:41:31.010
with G minus e.

00:41:31.010 --> 00:41:33.060
That's pretty old and geeky.

00:41:33.060 --> 00:41:38.595
Probably no one knows what that
means, but you get the idea.

00:41:38.595 --> 00:41:40.500
All right.

00:41:40.500 --> 00:41:43.980
Now, we get to
Type II operations.

00:41:43.980 --> 00:41:45.400
It's a little more subtle.

00:41:45.400 --> 00:41:48.220
if I said this with Type
II, it would be false.

00:41:48.220 --> 00:41:50.110
So life it's harder.

00:41:50.110 --> 00:41:52.750
And this is all about the fact
that anti-Type II operations

00:41:52.750 --> 00:41:56.581
are not unique, and you've got
to be careful in how you do it.

00:41:56.581 --> 00:41:57.830
It does work in one direction.

00:42:03.160 --> 00:42:05.480
If the input is minimally
generically rigid,

00:42:05.480 --> 00:42:06.740
then the new one will be.

00:42:20.070 --> 00:42:22.102
But it doesn't work in
the other direction.

00:42:22.102 --> 00:42:24.060
Now at this point, I'm
not going to prove this.

00:42:24.060 --> 00:42:26.490
This is actually a
lot harder to prove.

00:42:26.490 --> 00:42:28.970
At least, I don't know of a
simple, straightforward proof

00:42:28.970 --> 00:42:31.090
like this one, where
you just construct it.

00:42:31.090 --> 00:42:35.610
The easy way I know how to
prove it uses next class.

00:42:35.610 --> 00:42:38.190
So we're not going
to bother proving it.

00:42:38.190 --> 00:42:39.620
It should be intuitive enough.

00:42:39.620 --> 00:42:41.720
Certainly in thinking
about degrees of freedom

00:42:41.720 --> 00:42:44.785
it's correct, but you've got
to be more careful than that.

00:42:47.281 --> 00:42:49.280
I want to talk more about
the reverse direction.

00:42:53.054 --> 00:42:54.470
At this point, by
the way, we have

00:42:54.470 --> 00:42:58.602
proved one direction
of our big theorem.

00:42:58.602 --> 00:43:01.060
We've proved that if you can
build something with these two

00:43:01.060 --> 00:43:04.070
operations, it is minimally
generically rigid,

00:43:04.070 --> 00:43:07.245
because when we start
out with an edge,

00:43:07.245 --> 00:43:09.470
this is the base case
of our induction.

00:43:09.470 --> 00:43:11.900
This guy is minimally
generically rigid.

00:43:11.900 --> 00:43:14.560
And then every operation
I do, I know I'm safe,

00:43:14.560 --> 00:43:17.310
because I start with G being
minimally generically rigid.

00:43:17.310 --> 00:43:19.420
If I do a Type I
operation, it will still

00:43:19.420 --> 00:43:22.420
be minimally generically rigid,
and same thing for Type II

00:43:22.420 --> 00:43:23.030
operations.

00:43:23.030 --> 00:43:25.940
So in that direction,
we're golden.

00:43:25.940 --> 00:43:29.910
But I'd really like
to know, is there

00:43:29.910 --> 00:43:33.620
some converse of three,
this third property?

00:43:33.620 --> 00:43:37.450
And I will tell you a converse
of the third property.

00:43:37.450 --> 00:43:45.640
Suppose I have a minimally
generically rigid graph G

00:43:45.640 --> 00:43:46.651
prime.

00:43:46.651 --> 00:43:49.150
And I'm not assuming that it's
made from a Type II operation

00:43:49.150 --> 00:43:51.460
yet.

00:43:51.460 --> 00:43:55.550
But suppose it has
a degree-3 vertex--

00:43:55.550 --> 00:43:57.175
vertex with three
incident edges.

00:44:02.290 --> 00:44:18.330
Then G prime is the result
of a Type II operation

00:44:18.330 --> 00:44:33.920
of some minimally generically
rigid graph G. So this is

00:44:33.920 --> 00:44:39.450
saying that there is hope
in working backwards.

00:44:39.450 --> 00:44:41.580
Here I had two choices
of Type II operations.

00:44:41.580 --> 00:44:43.579
I think in this case, it
didn't actually matter,

00:44:43.579 --> 00:44:46.330
but in general, it matters
which one you choose.

00:44:46.330 --> 00:44:51.330
And this is saying
there is a choice,

00:44:51.330 --> 00:44:54.140
there is an anti-Type II
operation, a backwards II

00:44:54.140 --> 00:44:56.990
operation, that
results in something

00:44:56.990 --> 00:44:58.644
that is minimally
generically rigid.

00:44:58.644 --> 00:45:00.310
And if it's minimally
generically rigid,

00:45:00.310 --> 00:45:02.560
by induction, I
can keep going on.

00:45:02.560 --> 00:45:05.010
And so eventually I
will get back to start.

00:45:05.010 --> 00:45:07.780
And this is what we
need to show in order

00:45:07.780 --> 00:45:09.560
to believe one half
of this theorem

00:45:09.560 --> 00:45:12.050
that if your thing is
minimally generically rigid,

00:45:12.050 --> 00:45:16.030
there is a way to
build it like this.

00:45:16.030 --> 00:45:18.940
And the way you build it is if
there's a Type I operation--

00:45:18.940 --> 00:45:20.480
anti-Type I operation do that.

00:45:20.480 --> 00:45:25.320
If there's an anti-Type II
operation, do the right one.

00:45:25.320 --> 00:45:26.550
Let the right one in.

00:45:26.550 --> 00:45:30.429
Do the right instance of an
anti-Type II operation that

00:45:30.429 --> 00:45:32.720
gives you something that's
minimally generically rigid.

00:45:32.720 --> 00:45:34.559
If you preserve minimal
generic rigidity,

00:45:34.559 --> 00:45:36.850
you know you can keep going,
because you have a smaller

00:45:36.850 --> 00:45:39.530
graph And so by induction
you can keep going.

00:45:43.000 --> 00:45:44.850
I'm not going to
prove four either,

00:45:44.850 --> 00:45:49.075
because it again uses technology
we haven't yet developed.

00:45:51.610 --> 00:45:53.820
But there's one more
part of this theorem

00:45:53.820 --> 00:45:56.820
that we haven't proved.

00:45:56.820 --> 00:45:57.860
This sounds great.

00:45:57.860 --> 00:46:01.460
We do anti-type I operations.

00:46:01.460 --> 00:46:02.590
When can we do those?

00:46:02.590 --> 00:46:06.200
We can do those when we
have a vertex of degree-2.

00:46:06.200 --> 00:46:08.530
Then we can get rid of it.

00:46:08.530 --> 00:46:10.590
And what property
four over there

00:46:10.590 --> 00:46:14.250
says that if I have a vertex of
degree-3, I can get rid of it,

00:46:14.250 --> 00:46:16.930
and add some edge to compensate.

00:46:16.930 --> 00:46:20.620
But what if I don't have any
vertices of degree-2 or 3?

00:46:20.620 --> 00:46:21.680
That would suck.

00:46:33.150 --> 00:46:37.750
So this is now the other
half of this theorem.

00:46:42.310 --> 00:46:42.920
All right.

00:46:42.920 --> 00:46:45.110
Well, we know by
the thing I just

00:46:45.110 --> 00:46:50.580
erased that the number
of edges is 2n minus 3.

00:46:50.580 --> 00:46:52.360
So just to recall,
we're assuming now

00:46:52.360 --> 00:46:54.970
we have something that's
minimally generically rigid.

00:46:54.970 --> 00:46:57.220
We already did a degree
of freedom analysis

00:46:57.220 --> 00:47:00.690
to show the number edges
must be 2n minus 3.

00:47:00.690 --> 00:47:03.466
Now, we need to somehow find
either an anti-Type I operation

00:47:03.466 --> 00:47:05.090
or an anti-Type II
operation so that we

00:47:05.090 --> 00:47:07.429
can go all the way
to a single edge

00:47:07.429 --> 00:47:08.845
and find a Henneberg
construction.

00:47:15.719 --> 00:47:16.385
Any suggestions?

00:47:18.889 --> 00:47:19.930
People know graph theory?

00:47:26.378 --> 00:47:26.880
All right.

00:47:26.880 --> 00:47:28.338
On the one hand,
we have the number

00:47:28.338 --> 00:47:31.180
of edges, and the
other hand, we care

00:47:31.180 --> 00:47:33.370
about the degrees of vertices.

00:47:33.370 --> 00:47:35.370
Anyone know a relation
between those two things?

00:47:38.830 --> 00:47:39.839
Yeah.

00:47:39.839 --> 00:47:41.246
AUDIENCE: Two.

00:47:41.246 --> 00:47:44.529
Every edge contributes
two to the total Henneberg

00:47:44.529 --> 00:47:45.940
[INAUDIBLE].

00:47:45.940 --> 00:47:49.070
PROFESSOR: If I take
the sum of the degrees

00:47:49.070 --> 00:47:54.520
of the vertices-- sum
over all vertices--

00:47:54.520 --> 00:47:56.260
this is really intuitive.

00:47:56.260 --> 00:47:58.900
I add up how many edges are
incident to this vertex,

00:47:58.900 --> 00:48:01.810
then I add up how many edges
are incident to this vertex,

00:48:01.810 --> 00:48:04.610
then I add up how many edges
are incident to this vertex.

00:48:04.610 --> 00:48:07.560
I count every edge twice,
because it has two ends.

00:48:07.560 --> 00:48:10.720
So some of the degrees is
twice the number of edges.

00:48:10.720 --> 00:48:12.430
I'll write that this way.

00:48:12.430 --> 00:48:15.940
E is the set of edges
that's the size of that.

00:48:15.940 --> 00:48:17.610
This is called the
handshaking lemma.

00:48:17.610 --> 00:48:20.540
It says if everyone in this
room shakes hands with everyone

00:48:20.540 --> 00:48:23.032
else-- if I go around and
shake hands with everybody--

00:48:23.032 --> 00:48:24.490
the total number
of handshakes will

00:48:24.490 --> 00:48:31.500
be twice the number of pairs
of people that shook hands.

00:48:31.500 --> 00:48:32.860
No.

00:48:32.860 --> 00:48:36.110
If we do some set
of handshakes--

00:48:36.110 --> 00:48:37.540
so that's the graph scenario.

00:48:37.540 --> 00:48:41.220
So some of us shake
hands, and I count

00:48:41.220 --> 00:48:43.440
how many handshakes
I did, and everybody

00:48:43.440 --> 00:48:46.047
counts how many handshakes
they did, we add them all up,

00:48:46.047 --> 00:48:48.380
it will be exactly twice the
number of actual handshakes

00:48:48.380 --> 00:48:49.600
that took place.

00:48:49.600 --> 00:48:51.220
That's this statement.

00:48:51.220 --> 00:48:54.920
That's why it's called
the handshaking lemma.

00:48:54.920 --> 00:49:00.160
This is good news, because we
know this number is 4n minus 6

00:49:00.160 --> 00:49:02.800
here.

00:49:02.800 --> 00:49:05.410
So what could these
degrees look like?

00:49:05.410 --> 00:49:07.320
There's n of them.

00:49:07.320 --> 00:49:09.040
Number of vertices is n.

00:49:09.040 --> 00:49:11.930
That's the neat definition of n.

00:49:11.930 --> 00:49:15.230
So on average what
could these degrees be?

00:49:15.230 --> 00:49:17.396
They have to be less than four.

00:49:17.396 --> 00:49:23.080
The average degree has
to be at least a little

00:49:23.080 --> 00:49:25.500
bit less than four,
because in summation, you

00:49:25.500 --> 00:49:28.537
get 4n minus a little bit.

00:49:28.537 --> 00:49:30.120
So the average degree
in the summation

00:49:30.120 --> 00:49:31.460
must be a little
bit less than four.

00:49:31.460 --> 00:49:33.860
Now, some of them are bigger,
some of them are smaller.

00:49:33.860 --> 00:49:36.235
But if the average is less
than four, then in particular,

00:49:36.235 --> 00:49:39.570
there must be one
guy less than four.

00:49:39.570 --> 00:49:47.660
Some vertex has
degree less than four.

00:49:47.660 --> 00:49:51.350
So it could either be
zero, one, two, or three.

00:49:51.350 --> 00:49:53.640
Two and three, we're OK.

00:49:53.640 --> 00:49:57.060
One can't happen,
because we are supposed

00:49:57.060 --> 00:49:58.700
to be minimally
generically rigid.

00:49:58.700 --> 00:50:01.820
If I have a degree1
vertex and some stuff,

00:50:01.820 --> 00:50:03.040
this guy can spin around.

00:50:03.040 --> 00:50:04.600
It's not minimally
generically rigid.

00:50:04.600 --> 00:50:07.040
If I have a degree-0
vertex, it can float around.

00:50:07.040 --> 00:50:08.960
It's not minimally
generically rigid,

00:50:08.960 --> 00:50:11.160
assuming you have
more than one vertex.

00:50:11.160 --> 00:50:14.240
So I guess this is
the situation where

00:50:14.240 --> 00:50:16.370
you have more than
one vertex, otherwise

00:50:16.370 --> 00:50:18.740
you can't build it
from a single edge.

00:50:18.740 --> 00:50:22.430
Assuming you have-- so I should
put n greater than one here.

00:50:25.590 --> 00:50:28.660
So then you get a degree2
vertex or a degree-3 vertex.

00:50:28.660 --> 00:50:34.450
You use either property
two or property four

00:50:34.450 --> 00:50:38.550
to make an anti-Type I or
anti-Type II operation.

00:50:38.550 --> 00:50:40.830
You'll still have a minimally
generically rigid graph.

00:50:40.830 --> 00:50:41.810
You keep going.

00:50:41.810 --> 00:50:44.750
By the end, you'll
have a single edge.

00:50:44.750 --> 00:50:46.750
That's the only case
when you get stuck,

00:50:46.750 --> 00:50:48.620
because actually-- see, I lied.

00:50:48.620 --> 00:50:50.810
Here, I have two
degree-1 vertices.

00:50:50.810 --> 00:50:55.400
That's the only situation where
you can have degree-1 vertices.

00:50:55.400 --> 00:50:58.577
And that's when you get stuck.

00:50:58.577 --> 00:51:00.910
You have two degree-1 vertices,
but then I have an edge.

00:51:00.910 --> 00:51:01.460
I'm done.

00:51:05.180 --> 00:51:07.630
Questions?

00:51:07.630 --> 00:51:11.060
Obviously, I elided a
couple of key details here,

00:51:11.060 --> 00:51:13.801
but other than that, it's
pretty straightforward.

00:51:13.801 --> 00:51:14.300
Yeah.

00:51:14.300 --> 00:51:18.314
AUDIENCE: What if you have
more edges than you need?

00:51:18.314 --> 00:51:20.230
PROFESSOR: If I have
more edges than you need,

00:51:20.230 --> 00:51:24.070
then this does not
capture such structures.

00:51:24.070 --> 00:51:28.160
This is just about
minimal generic rigidity.

00:51:28.160 --> 00:51:32.110
But if I have some graph
that is generically rigid,

00:51:32.110 --> 00:51:35.830
it will be a graph I can build
this way, plus more edges.

00:51:35.830 --> 00:51:38.760
Now, how to identify what edges
I should remove so that I could

00:51:38.760 --> 00:51:43.050
do this Henneberg construction
is unclear at this point,

00:51:43.050 --> 00:51:46.460
and that's the purpose
of the next theorem.

00:51:46.460 --> 00:51:47.450
So good question.

00:52:01.550 --> 00:52:03.900
It turns out there's
an algorithm, which

00:52:03.900 --> 00:52:06.490
given a generically rigid
graph, will tell you

00:52:06.490 --> 00:52:09.260
which edges you can
throw away, so that you

00:52:09.260 --> 00:52:11.790
get a minimally
generically rigid graph.

00:52:11.790 --> 00:52:16.190
And that algorithm uses
the following theorem.

00:52:16.190 --> 00:52:29.090
This one is from the '70s
by a guy named Laman.

00:52:29.090 --> 00:52:33.970
It starts the same
as Henneberg above.

00:52:33.970 --> 00:52:43.950
Graph is minimally
generically rigid in 2D

00:52:43.950 --> 00:52:53.844
if and only if it
has 2n minus 3 edges.

00:52:53.844 --> 00:52:55.760
And again, I'm assuming
the number of vertices

00:52:55.760 --> 00:52:56.590
is bigger than one.

00:53:00.121 --> 00:53:02.620
So far, this is just our regular
degree or freedom analysis.

00:53:02.620 --> 00:53:04.090
But I said this wasn't enough.

00:53:04.090 --> 00:53:05.262
You something else.

00:53:05.262 --> 00:53:06.345
Here's the something else.

00:53:10.296 --> 00:53:12.960
If I take a subset of
vertices-- and let's say

00:53:12.960 --> 00:53:23.360
there's k of them--
then that induces

00:53:23.360 --> 00:53:25.830
at most 2k minus 3 edges.

00:53:29.071 --> 00:53:30.820
So this-- again, minimal
generic rigidity.

00:53:30.820 --> 00:53:33.265
I'm still not directly
talking about the bigger case.

00:53:33.265 --> 00:53:35.169
We'll worry about that later.

00:53:35.169 --> 00:53:36.710
So there's the fewest
possible edges.

00:53:36.710 --> 00:53:39.220
That means 2n minus 3.

00:53:39.220 --> 00:53:41.090
But now, essentially
what I want to say

00:53:41.090 --> 00:53:44.220
is that there aren't too
many edges in any one place,

00:53:44.220 --> 00:53:46.830
and therefore the edges
are well distributed.

00:53:46.830 --> 00:53:50.840
So if I take some subset of the
vertices-- so here's my graph,

00:53:50.840 --> 00:53:55.330
and I take some crazy subset--
any blob the vertices I want,

00:53:55.330 --> 00:53:57.830
I look at what are
all the edges inside

00:53:57.830 --> 00:54:01.270
between vertices in that set?

00:54:01.270 --> 00:54:03.300
I don't want to have too many.

00:54:03.300 --> 00:54:05.730
I don't want to have more than
what I should-- 2k minus 3

00:54:05.730 --> 00:54:07.610
if there's k vertices in here.

00:54:07.610 --> 00:54:11.914
If I had more--
for example, that's

00:54:11.914 --> 00:54:13.080
minimally generically rigid.

00:54:13.080 --> 00:54:16.810
If I did that anywhere
in the graph--

00:54:16.810 --> 00:54:19.240
this has 2n minus 2 edges.

00:54:19.240 --> 00:54:20.870
It's too many.

00:54:20.870 --> 00:54:22.470
Or 2k minus 2 edges.

00:54:22.470 --> 00:54:23.870
K is four here.

00:54:23.870 --> 00:54:26.220
If I put that in some bigger
graph and the bigger graph

00:54:26.220 --> 00:54:28.800
has 2n minus 3, and I
wasted an edge here,

00:54:28.800 --> 00:54:31.430
that means somewhere
else, it will be flexible.

00:54:31.430 --> 00:54:33.520
So it's a bit of
a weird condition.

00:54:33.520 --> 00:54:35.380
You might think this should say
greater than or equal to be.

00:54:35.380 --> 00:54:36.338
It'd be more intuitive.

00:54:36.338 --> 00:54:37.345
That would be wrong.

00:54:37.345 --> 00:54:40.465
The theorem isn't true when you
put greater than or equal to,

00:54:40.465 --> 00:54:41.840
because you could
choose vertices

00:54:41.840 --> 00:54:43.500
that have no edges between them.

00:54:43.500 --> 00:54:45.590
There's going to
be a lot of them.

00:54:45.590 --> 00:54:48.100
But if you make sure there
aren't too many anywhere,

00:54:48.100 --> 00:54:51.436
then it turns out it will
be just right everywhere.

00:54:51.436 --> 00:54:55.040
It's like three little
bears or something.

00:54:55.040 --> 00:54:58.370
So some generalized version
of three little bears.

00:54:58.370 --> 00:54:59.794
K little bears.

00:54:59.794 --> 00:55:02.421
[LAUGHTER]

00:55:02.421 --> 00:55:02.920
All right.

00:55:02.920 --> 00:55:04.630
So this is a very cool theorem.

00:55:04.630 --> 00:55:07.830
It's not obviously algorithmic,
because it says, oh, you just

00:55:07.830 --> 00:55:11.080
check every subset of k
vertices for all values of k.

00:55:11.080 --> 00:55:12.590
There's exponentially
many subsets.

00:55:12.590 --> 00:55:14.540
It's not a good
algorithm by itself,

00:55:14.540 --> 00:55:17.220
but it turns out you can
make it into an algorithm.

00:55:17.220 --> 00:55:18.624
I'll talk about
that in a moment.

00:55:18.624 --> 00:55:20.290
First, we're going
to prove the theorem.

00:55:23.769 --> 00:55:27.470
OK, I have to speed up a little.

00:55:27.470 --> 00:55:28.770
All right.

00:55:28.770 --> 00:55:29.980
Let me sketch this proof.

00:55:29.980 --> 00:55:31.970
It's really easy,
because we already

00:55:31.970 --> 00:55:34.650
have this great characterization
of minimally generically

00:55:34.650 --> 00:55:35.664
rigid graphs.

00:55:35.664 --> 00:55:37.830
It's just things you can
build by Type I and Type II

00:55:37.830 --> 00:55:39.740
operations.

00:55:39.740 --> 00:55:43.930
So if I want to show
the forward direction,

00:55:43.930 --> 00:55:46.360
that if I have a minimally
generic thing-- i.e.

00:55:46.360 --> 00:55:51.250
It can be built this way--
then it has 2n minus 3 edges.

00:55:51.250 --> 00:55:53.430
Well, that we already know.

00:55:53.430 --> 00:55:56.420
And then the other thing is
that every subset of k vertices

00:55:56.420 --> 00:56:00.960
has at most 2k minus
3 edges among them.

00:56:00.960 --> 00:56:04.770
So think about it here.

00:56:04.770 --> 00:56:07.010
So maybe this is my graph.

00:56:07.010 --> 00:56:11.210
It's produced by a Type
I operation at the end.

00:56:11.210 --> 00:56:14.580
Well, it takes some
subset of the vertices.

00:56:14.580 --> 00:56:17.720
Either the subset contains
this vertex, or it doesn't.

00:56:17.720 --> 00:56:20.080
If it doesn't
contain this vertex,

00:56:20.080 --> 00:56:22.210
then it's a subset
just in the old graph.

00:56:22.210 --> 00:56:23.936
And by induction,
my theorem will

00:56:23.936 --> 00:56:25.920
hold, because that's
a smaller graph.

00:56:25.920 --> 00:56:29.580
If it's a subset that
includes this guy,

00:56:29.580 --> 00:56:33.330
then it's whatever the
subset contains over here,

00:56:33.330 --> 00:56:36.610
plus 2 edges minus 1 vertex.

00:56:36.610 --> 00:56:37.780
And that just works out.

00:56:37.780 --> 00:56:40.300
Over here, there's going
to be k minus 1 vertices,

00:56:40.300 --> 00:56:43.430
so it'll be two times k
minus 1 minus 3 at most.

00:56:43.430 --> 00:56:45.640
We add two edges,
we add one vertex.

00:56:45.640 --> 00:56:47.150
That's exactly
what this predicts.

00:56:47.150 --> 00:56:49.820
You should add two
edges for every vertex.

00:56:49.820 --> 00:56:50.830
So that's fine.

00:56:50.830 --> 00:56:53.890
The Type II, same deal.

00:56:53.890 --> 00:56:56.480
But in general, I'm
adding three edges,

00:56:56.480 --> 00:56:59.350
removing one, and
adding one vertex.

00:56:59.350 --> 00:57:03.370
And that's again true in the
subsets, not just overall.

00:57:03.370 --> 00:57:06.341
I take a subset containing
this guy or not.

00:57:06.341 --> 00:57:08.090
You have to check all
the cases, depending

00:57:08.090 --> 00:57:09.480
on whether it contains
this guy or this guy

00:57:09.480 --> 00:57:10.530
or this guy, or not.

00:57:10.530 --> 00:57:15.430
But in all cases, this
inequality still holds.

00:57:15.430 --> 00:57:15.930
How's that?

00:57:21.230 --> 00:57:26.030
It's a bunch of case work, but
all really straightforward, so

00:57:26.030 --> 00:57:27.530
believe me.

00:57:27.530 --> 00:57:30.340
The hard part is
the other direction.

00:57:30.340 --> 00:57:34.740
If I'm told that this is true--
all the subsets don't have

00:57:34.740 --> 00:57:38.250
too many edges-- then I claim I
can actually build it this way,

00:57:38.250 --> 00:57:41.860
or I claim that somehow it's
minimally generically rigid.

00:57:41.860 --> 00:57:45.284
And we are, in fact, going
to build it using Henneberg

00:57:45.284 --> 00:57:46.825
constructions, using
these properties

00:57:46.825 --> 00:57:50.671
that we proved-- one,
two, three, four.

00:57:50.671 --> 00:57:51.170
All right.

00:57:51.170 --> 00:57:52.840
So what do we know?

00:57:52.840 --> 00:57:55.250
We know that there
are 2n minus 3 edges.

00:57:55.250 --> 00:57:57.250
Hey, I already have
a great argument

00:57:57.250 --> 00:57:59.042
for when the number of
edges is 2n minus 3.

00:57:59.042 --> 00:58:01.625
I do the handshaking lemma, and
I know that the sum of degrees

00:58:01.625 --> 00:58:02.340
is 4n minus 6.

00:58:02.340 --> 00:58:04.790
Therefore, I know the average
degree is less than four.

00:58:04.790 --> 00:58:06.676
Great.

00:58:06.676 --> 00:58:07.300
Problem solved.

00:58:07.300 --> 00:58:14.380
Therefore, I know
there's a vertex

00:58:14.380 --> 00:58:17.630
of degree less than four.

00:58:17.630 --> 00:58:20.500
It could be zero,
one two, or three.

00:58:20.500 --> 00:58:21.125
Can it be zero?

00:58:25.010 --> 00:58:27.045
Hope not.

00:58:27.045 --> 00:58:28.710
How do I prove it's not zero?

00:58:28.710 --> 00:58:32.315
I know how to prove
it's not one, think.

00:58:37.570 --> 00:58:39.820
I have to cheat here.

00:58:39.820 --> 00:58:40.320
Aha.

00:58:40.320 --> 00:58:41.010
Right, right.

00:58:41.010 --> 00:58:42.214
OK, good.

00:58:42.214 --> 00:58:43.970
Duh.

00:58:43.970 --> 00:58:44.470
All right.

00:58:44.470 --> 00:58:46.510
Number of edges is 2n minus 3.

00:58:46.510 --> 00:58:49.187
Suppose my graph
looked like this,

00:58:49.187 --> 00:58:51.020
where there's no edges
incident to this guy.

00:58:51.020 --> 00:58:53.810
Well, how many edges
does this have?

00:58:53.810 --> 00:58:54.730
2n minus 3 still.

00:58:54.730 --> 00:58:56.480
I didn't remove any.

00:58:56.480 --> 00:58:59.590
So I've got n minus 1 vertices,
yet I have 2n minus 3 edges?

00:58:59.590 --> 00:59:01.170
That ain't right.

00:59:01.170 --> 00:59:02.440
So that can't happen.

00:59:02.440 --> 00:59:07.630
Similarly here, if I
have one edge here,

00:59:07.630 --> 00:59:10.750
then the number of
edges inside this blob--

00:59:10.750 --> 00:59:13.970
everything except that one
vertex-- would be 2n minus 2,

00:59:13.970 --> 00:59:16.010
I guess.

00:59:16.010 --> 00:59:22.040
But it should really have at
most 2 times n minus 1 minus 3,

00:59:22.040 --> 00:59:26.610
which is 2n minus 4.

00:59:26.610 --> 00:59:29.460
Sorry, I did this wrong.

00:59:29.460 --> 00:59:31.120
2n minus 3.

00:59:31.120 --> 00:59:32.010
This should be 4.

00:59:32.010 --> 00:59:33.846
This should be 5.

00:59:33.846 --> 00:59:36.450
I'll get it right eventually.

00:59:36.450 --> 00:59:39.220
So if I remove one edge from
2n minus 3, I get 2n minus 4.

00:59:39.220 --> 00:59:41.590
I had the sign error.

00:59:41.590 --> 00:59:43.860
But I'm supposed to have
2 times n minus 1-- that's

00:59:43.860 --> 00:59:47.890
the number vertices over here--
minus 3, which is 2n minus 5.

00:59:47.890 --> 00:59:49.740
So I have the wrong
number of edges.

00:59:49.740 --> 00:59:51.870
In fact, it should equal.

00:59:51.870 --> 00:59:52.370
Whatever.

00:59:52.370 --> 00:59:54.822
At most, at most.

00:59:54.822 --> 00:59:56.280
We know in every
subset-- here, I'm

00:59:56.280 --> 00:59:58.020
taking a subset of
n minus 1 vertices.

00:59:58.020 --> 00:59:59.650
I have at most 2k minus 3.

00:59:59.650 --> 01:00:01.380
Here k is n minus 1.

01:00:01.380 --> 01:00:03.380
So I can't have degree-1,
I can't have degree-0.

01:00:03.380 --> 01:00:08.040
Therefore, in fact, it's
either degree2 or 3.

01:00:11.490 --> 01:00:16.130
If it's degree-2, I'm done.

01:00:16.130 --> 01:00:17.390
I'm happy.

01:00:17.390 --> 01:00:23.785
If it's degree--2, then I
do an anti-Type I operation.

01:00:29.680 --> 01:00:32.500
So that's this scenario.

01:00:32.500 --> 01:00:35.070
If I have any degree-2
Vertex, I remove it.

01:00:38.350 --> 01:00:39.921
And I want to
induct on the rest.

01:00:39.921 --> 01:00:41.170
Now, what do I need to induct?

01:00:41.170 --> 01:00:45.200
I need to know that
this property still

01:00:45.200 --> 01:00:47.570
holds on my smaller graph.

01:00:47.570 --> 01:00:50.510
When I remove this vertex,
I want the remaining graph

01:00:50.510 --> 01:00:52.970
to still have this property.

01:00:52.970 --> 01:00:55.260
Does it have 2n minus 3
edges, for the new value

01:00:55.260 --> 01:00:57.844
of n, n being n minus 1 now?

01:00:57.844 --> 01:00:59.260
Yeah, because I
removed two edges.

01:00:59.260 --> 01:01:00.180
I removed one vertex.

01:01:00.180 --> 01:01:02.260
So it still has the
right number of edges.

01:01:02.260 --> 01:01:03.930
We've already checked that.

01:01:03.930 --> 01:01:06.530
And I need to check that
every subset of the vertices

01:01:06.530 --> 01:01:09.950
over here has at most
2k minus 3 edges.

01:01:09.950 --> 01:01:11.720
That's still true,
because before I

01:01:11.720 --> 01:01:14.350
had to consider all subsets
containing this one or not.

01:01:14.350 --> 01:01:17.150
Now I'm just looking at
subsets that don't contain it.

01:01:17.150 --> 01:01:21.460
So I still have the
Laman conditions

01:01:21.460 --> 01:01:25.930
holding for the
smaller graph in here.

01:01:25.930 --> 01:01:33.100
Therefore, I can
induct, and we're done.

01:01:33.100 --> 01:01:35.439
And we're done because then
we conclude that the smaller

01:01:35.439 --> 01:01:36.980
graph is minimally
generically rigid.

01:01:36.980 --> 01:01:41.026
And then property two tells
us that this thing's minimally

01:01:41.026 --> 01:01:43.400
generically rigid, and then
I add this vertex, two edges,

01:01:43.400 --> 01:01:45.370
it'll still be minimally
generically rigid.

01:01:45.370 --> 01:01:47.500
And that's what I
wanted to conclude

01:01:47.500 --> 01:01:50.890
in the left
implication direction.

01:01:50.890 --> 01:01:52.730
The hard case is degree three.

01:01:55.810 --> 01:01:58.610
Again, there's more than
one Type II operation.

01:01:58.610 --> 01:02:00.960
I already wave my
hands, claiming

01:02:00.960 --> 01:02:06.130
that there is an operation you
can do so that the result is

01:02:06.130 --> 01:02:07.410
minimally generically rigid.

01:02:12.580 --> 01:02:13.640
But is that enough?

01:02:13.640 --> 01:02:16.400
I have to think about
it for a second.

01:02:16.400 --> 01:02:18.045
It's minimally
generically rigid.

01:02:23.880 --> 01:02:24.835
Ah, it's not enough.

01:02:24.835 --> 01:02:27.040
It's annoying.

01:02:27.040 --> 01:02:28.970
That's what I thought.

01:02:28.970 --> 01:02:30.660
I'm not surprised,
but I'm re-surprised.

01:02:30.660 --> 01:02:31.160
Whatever.

01:02:33.780 --> 01:02:35.690
For this theory
property to hold,

01:02:35.690 --> 01:02:39.050
I need that the graph I have
is minimally generically rigid.

01:02:39.050 --> 01:02:40.670
That's what I want to prove.

01:02:40.670 --> 01:02:42.890
I don't know that that's true.

01:02:42.890 --> 01:02:44.790
So I can't use property four.

01:02:44.790 --> 01:02:45.520
Sucks to be me.

01:02:48.419 --> 01:02:50.960
I'm trying to prove the graph
is minimally generically rigid.

01:02:50.960 --> 01:02:54.110
All I have is degree-3 vertex,
and I have Laman's condition.

01:02:54.110 --> 01:02:58.640
I don't know whether property
four applies to my scenario.

01:02:58.640 --> 01:03:02.030
So we've got to do work.

01:03:02.030 --> 01:03:04.120
And wow.

01:03:11.480 --> 01:03:13.520
See what I can do to this proof.

01:03:35.050 --> 01:03:38.335
In the degree-3 case, I want to
find an anti-Type II operation.

01:03:41.170 --> 01:03:44.390
Presumably they're out
there, but I need a good one.

01:03:44.390 --> 01:03:48.050
For me, good means it should
preserve the Laman condition.

01:03:48.050 --> 01:03:50.760
So after I do the anti-Type
II, after I delete those three

01:03:50.760 --> 01:03:54.690
edges, delete the vertex,
add one edge back,

01:03:54.690 --> 01:03:56.060
I want this to still hold.

01:03:59.292 --> 01:04:00.750
Now, there's
essentially two things

01:04:00.750 --> 01:04:03.470
that could go wrong
for this to still hold.

01:04:03.470 --> 01:04:07.240
One is you go to add an
edge, and it's already there.

01:04:07.240 --> 01:04:10.650
If it's already there, you
can't really add it again,

01:04:10.650 --> 01:04:12.680
and then the number of
edges will be wrong.

01:04:12.680 --> 01:04:15.480
You always want to have
2n minus 3 as you go down.

01:04:15.480 --> 01:04:17.560
If I try to add an edge
and it doesn't work out--

01:04:17.560 --> 01:04:19.230
because the whole point is
I'm supposed to remove three,

01:04:19.230 --> 01:04:19.930
add one.

01:04:19.930 --> 01:04:21.680
If I don't actually
succeed in adding one,

01:04:21.680 --> 01:04:23.700
it'll be the wrong number.

01:04:23.700 --> 01:04:25.700
So first thing you
need to check is

01:04:25.700 --> 01:04:28.990
that-- so I take
this degree-3 vertex.

01:04:28.990 --> 01:04:31.040
Here it is.

01:04:31.040 --> 01:04:34.410
Now it's all about its
neighbors, these three guys.

01:04:34.410 --> 01:04:38.510
If all three of those exist,
I would be in trouble.

01:04:38.510 --> 01:04:40.544
Fortunately, that can't happen.

01:04:40.544 --> 01:04:42.460
This is the picture I
drew that cannot happen.

01:04:42.460 --> 01:04:43.320
This is over-braced.

01:04:43.320 --> 01:04:44.510
There's too many edges here.

01:04:44.510 --> 01:04:46.360
This is a subset
of four vertices.

01:04:46.360 --> 01:04:49.130
It has more than
2k minus 3 edges.

01:04:49.130 --> 01:04:50.870
So by Laman's condition,
this can't hold.

01:04:50.870 --> 01:04:53.490
Some edge must be missing.

01:04:53.490 --> 01:04:55.510
That's the one we'll target.

01:04:55.510 --> 01:04:57.565
So at least there's an
edge that's missing.

01:04:57.565 --> 01:05:00.060
That's property one.

01:05:00.060 --> 01:05:02.840
There's another thing that
could go wrong, though,

01:05:02.840 --> 01:05:05.550
which is I go to
add in this edge,

01:05:05.550 --> 01:05:08.570
and somehow the other part
of the condition-- the subset

01:05:08.570 --> 01:05:11.210
property-- doesn't hold.

01:05:11.210 --> 01:05:13.747
Now, what could that
possibly look like?

01:05:13.747 --> 01:05:15.455
It would have to be
a subset of vertices.

01:05:20.120 --> 01:05:23.690
It should at least contain
these two vertices.

01:05:23.690 --> 01:05:28.030
Actually, it probably
shouldn't contain this one.

01:05:28.030 --> 01:05:31.186
This requires some thinking.

01:05:31.186 --> 01:05:33.310
I mean, if it contained
this one, it's no big deal.

01:05:33.310 --> 01:05:36.535
I mean, it's got do one
more vertex, two more edges.

01:05:36.535 --> 01:05:37.035
Who cares.

01:05:40.250 --> 01:05:43.840
But if you just look at
one of these subsets,

01:05:43.840 --> 01:05:46.140
then in this subset,
you're adding an edge.

01:05:46.140 --> 01:05:49.400
That's in general a bad idea,
because if it had exactly 2k

01:05:49.400 --> 01:05:51.900
minus 3 before and
now I add an edge,

01:05:51.900 --> 01:05:53.581
it'll have too many edges.

01:05:53.581 --> 01:05:54.330
That would be bad.

01:05:54.330 --> 01:05:56.400
So somehow I want to
say there's some place I

01:05:56.400 --> 01:06:00.940
can add an edge where there
was slack, where there

01:06:00.940 --> 01:06:03.950
were less than 2k minus 3 edges.

01:06:03.950 --> 01:06:08.370
And so when I add
this in, I'm OK.

01:06:08.370 --> 01:06:10.140
It's a little tricky to argue.

01:06:10.140 --> 01:06:13.700
What we do is
suppose-- we're going

01:06:13.700 --> 01:06:15.700
to argue by contradiction.

01:06:15.700 --> 01:06:18.220
If this is impossible-- so
I'm going to try for these two

01:06:18.220 --> 01:06:20.303
vertices, then I'll try
it for these two vertices,

01:06:20.303 --> 01:06:22.890
then I'll try for these
two-- three choices.

01:06:22.890 --> 01:06:27.310
If they all fail, I claim
there's a contradiction.

01:06:27.310 --> 01:06:29.890
And I will try to
sketch this for you.

01:06:29.890 --> 01:06:34.170
So let's say there are Si-- I
have some subset of vertices

01:06:34.170 --> 01:06:39.880
Si-- and i is one,
two, or three.

01:06:39.880 --> 01:06:44.540
And this will turn out
to be the bad case.

01:06:44.540 --> 01:06:48.900
Suppose that it contains--
I didn't give these labels.

01:06:48.900 --> 01:06:54.510
This is V, V1, V2, V3.

01:06:54.510 --> 01:06:58.190
So it's going to
contain Vi plus 1 and Vi

01:06:58.190 --> 01:07:05.030
plus 2-- those are the
other two vertices from i--

01:07:05.030 --> 01:07:09.940
but not V. Not the vertex that
I added, because that turns out

01:07:09.940 --> 01:07:11.130
not to matter.

01:07:11.130 --> 01:07:18.170
And suppose that it induces
exactly 2k-- what's k here?

01:07:18.170 --> 01:07:27.885
Size of Si-- minus 3 edges.

01:07:27.885 --> 01:07:29.630
It has Si edges.

01:07:29.630 --> 01:07:33.480
If it has exactly 2Si minus 3
edges, I can't add another one.

01:07:33.480 --> 01:07:36.360
And if this is true for
this pair and for this pair

01:07:36.360 --> 01:07:38.600
and for this pair,
then I'm screwed.

01:07:38.600 --> 01:07:41.490
So suppose that it's true for
all three pairs of these Sis.

01:07:45.660 --> 01:07:46.520
Fun fact.

01:07:46.520 --> 01:07:51.825
Let's look at all of the
edges among S1 and S2.

01:07:51.825 --> 01:07:53.950
Let's start combining these
sets in different ways.

01:08:00.114 --> 01:08:01.280
Speed through this a little.

01:08:05.380 --> 01:08:08.330
Something called
inclusion-exclusion principle,

01:08:08.330 --> 01:08:11.760
which is I have these
two sets S1 and S2.

01:08:11.760 --> 01:08:14.200
They might overlap, who knows.

01:08:14.200 --> 01:08:18.979
But if I count all the edges
in both of them together,

01:08:18.979 --> 01:08:23.029
that's kind of like counting all
the edges in here-- all of Si--

01:08:23.029 --> 01:08:24.587
and counting all
the edges in S2--

01:08:24.587 --> 01:08:26.420
and then removing the
intersection because I

01:08:26.420 --> 01:08:27.674
double-counted there.

01:08:27.674 --> 01:08:29.410
AUDIENCE: It's like probability.

01:08:29.410 --> 01:08:30.300
PROFESSOR: It's
like probability.

01:08:30.300 --> 01:08:31.466
This is inclusion-exclusion.

01:08:31.466 --> 01:08:33.010
It exists all over the place.

01:08:33.010 --> 01:08:34.135
Usually it's combinatorics.

01:08:36.660 --> 01:08:39.517
But it's not quite
accurate here,

01:08:39.517 --> 01:08:41.600
and that's why there's a
greater than or equal to.

01:08:41.600 --> 01:08:42.849
Because we're counting
edges not vertices,

01:08:42.849 --> 01:08:44.520
it's a little messier,
because there's

01:08:44.520 --> 01:08:47.250
some edges you miss, like
an edge from this vertex

01:08:47.250 --> 01:08:49.149
over to this vertex.

01:08:49.149 --> 01:08:51.380
You'll still count twice.

01:08:51.380 --> 01:08:52.850
But hey, it's close enough.

01:08:52.850 --> 01:08:54.710
Greater than or equal to.

01:08:54.710 --> 01:08:55.540
OK?

01:08:55.540 --> 01:09:02.754
Now, I claim this thing should
only have one vertex in it.

01:09:02.754 --> 01:09:04.210
How the heck could I claim that?

01:09:04.210 --> 01:09:06.460
Well, let's suppose that it
has at least two vertices.

01:09:08.950 --> 01:09:10.930
And then I'm going to
get a contradiction.

01:09:10.930 --> 01:09:18.000
So I guess I really mean
this-- that Si intersects S2.

01:09:18.000 --> 01:09:20.390
I claim these intersections
have to be pretty tiny.

01:09:20.390 --> 01:09:22.850
The reason is, if
it weren't, what

01:09:22.850 --> 01:09:25.399
do I know about the
edges induced by S1?

01:09:25.399 --> 01:09:28.130
Well, it's a subset, so it
satisfies the 2K minus 3

01:09:28.130 --> 01:09:29.550
property.

01:09:29.550 --> 01:09:32.383
So it's going to be greater
than or equal to, right?

01:09:34.899 --> 01:09:38.600
Actually, I'd already assumed
the number of edges induced

01:09:38.600 --> 01:09:41.170
here is exactly twice
the Sis minus 3.

01:09:41.170 --> 01:09:46.660
So this will be exactly
equal to 2 times S1 minus 3.

01:09:46.660 --> 01:09:52.460
It's 2 times S2 minus 3, and
then the same thing there.

01:09:52.460 --> 01:09:52.960
OK?

01:09:52.960 --> 01:09:56.660
But this is some subset.

01:09:56.660 --> 01:09:59.870
As long as it has at
least two vertices-- yeah,

01:09:59.870 --> 01:10:02.264
this should be k
greater than or one.

01:10:02.264 --> 01:10:03.930
Things don't quite
work with one vertex,

01:10:03.930 --> 01:10:05.580
because then it says
2 times 1 minus 3.

01:10:05.580 --> 01:10:07.550
It should have negative 1 edges.

01:10:07.550 --> 01:10:08.210
Ain't so.

01:10:08.210 --> 01:10:10.180
It's got zero edges.

01:10:10.180 --> 01:10:13.630
So you need more than one
vertex for this to apply.

01:10:13.630 --> 01:10:14.840
But now I have some subset.

01:10:14.840 --> 01:10:17.260
It has at least two
vertices, let's say.

01:10:17.260 --> 01:10:20.240
So it has at most
2k minus 3 edges.

01:10:20.240 --> 01:10:25.787
So this is going to
be at most-- it's

01:10:25.787 --> 01:10:27.495
confusing because
everything's backwards.

01:10:30.740 --> 01:10:33.310
Well, it's going to be
another two times the size

01:10:33.310 --> 01:10:34.272
of this thing minus 3.

01:10:34.272 --> 01:10:36.230
So I'm just going to
collect them all together.

01:10:36.230 --> 01:10:41.050
We have S1, we have S2, and
the one that we just added

01:10:41.050 --> 01:10:46.780
was S1 intersect S2 minus 9.

01:10:46.780 --> 01:10:47.840
It's three 3s.

01:10:52.178 --> 01:10:56.200
But this thing--
and I got it wrong.

01:10:56.200 --> 01:10:57.485
There's a sign error.

01:10:57.485 --> 01:10:59.160
I got two sign errors.

01:10:59.160 --> 01:11:01.020
There's a minus here.

01:11:01.020 --> 01:11:03.280
There's 2k minus 3.

01:11:03.280 --> 01:11:06.340
And so this is going
to be two negative 3s,

01:11:06.340 --> 01:11:08.890
then there's going to be
a negative negative 3.

01:11:08.890 --> 01:11:10.277
2 wrongs make a right.

01:11:10.277 --> 01:11:11.360
It should be 3 in the end.

01:11:14.710 --> 01:11:15.650
OK.

01:11:15.650 --> 01:11:18.130
Now, this thing.

01:11:18.130 --> 01:11:18.720
What's that?

01:11:21.928 --> 01:11:22.890
AUDIENCE: The union.

01:11:22.890 --> 01:11:24.650
PROFESSOR: It's the
size of the union.

01:11:24.650 --> 01:11:26.275
Here it's exact,
because we're counting

01:11:26.275 --> 01:11:29.650
vertices instead of edges.

01:11:29.650 --> 01:11:31.810
It's this plus this
minus the intersection

01:11:31.810 --> 01:11:33.590
from double counting.

01:11:33.590 --> 01:11:34.090
Huh.

01:11:34.090 --> 01:11:38.082
So two times that size minus 3.

01:11:38.082 --> 01:11:39.930
Hmm.

01:11:39.930 --> 01:11:43.060
So I looked at the edges
induced by the union.

01:11:43.060 --> 01:11:45.940
I got those at
least to k minus 3.

01:11:45.940 --> 01:11:46.460
So what--?

01:11:49.450 --> 01:11:51.150
Right.

01:11:51.150 --> 01:11:53.740
It doesn't sound like
a contradiction yet.

01:11:53.740 --> 01:11:56.018
We want it to be
at most 2k minus 3

01:11:56.018 --> 01:12:01.670
but I think there's a
property I didn't prove yet.

01:12:01.670 --> 01:12:02.490
Great.

01:12:02.490 --> 01:12:02.990
All right.

01:12:02.990 --> 01:12:04.637
So what.

01:12:04.637 --> 01:12:05.970
Let's look back at this picture.

01:12:15.480 --> 01:12:21.290
So if I take S1 union S2,
S1 hits these two guys-- 2

01:12:21.290 --> 01:12:25.650
and 3-- S2 hits these
two guys-- 1 and 3.

01:12:25.650 --> 01:12:28.290
In their union, they're
going to hit all three.

01:12:28.290 --> 01:12:31.150
So the set is going
to look like this.

01:12:31.150 --> 01:12:37.055
It's going to contain V1, V2,
V3, but not V. Interesting.

01:12:39.780 --> 01:12:42.580
I know that if I
put V in, I still

01:12:42.580 --> 01:12:44.720
have at most 2k minus 3 edges.

01:12:44.720 --> 01:12:48.690
If I remove V, I remove
one vertex and three edges.

01:12:48.690 --> 01:12:50.550
Three edges for
the price of one.

01:12:50.550 --> 01:12:52.610
Or for the price
of two, I guess.

01:12:52.610 --> 01:12:55.410
Normally if I remove a vertex,
I should remove only two edges.

01:12:55.410 --> 01:12:58.180
If I cut out V, I
remove three edges.

01:12:58.180 --> 01:13:00.260
Therefore, this
set that includes

01:13:00.260 --> 01:13:03.570
V1, V2, V3 has to have slack.

01:13:03.570 --> 01:13:08.780
It can't have 2k minus 3 edges,
because-- this should be OK.

01:13:08.780 --> 01:13:11.850
The bigger set should
be at most 2k minus 3.

01:13:11.850 --> 01:13:14.580
When I remove a vertex
and remove three edges,

01:13:14.580 --> 01:13:16.660
there's going to be too
few edges over here.

01:13:16.660 --> 01:13:18.390
Two few edges is OK.

01:13:18.390 --> 01:13:20.510
It would be strictly
less than 2k minus 3,

01:13:20.510 --> 01:13:22.982
and here I'm claiming
it's at least 2k minus 3.

01:13:22.982 --> 01:13:23.940
That's a contradiction.

01:13:30.670 --> 01:13:32.460
Now, it turns out, I'm
not done, because I

01:13:32.460 --> 01:13:34.820
was in two levels
of contradiction.

01:13:34.820 --> 01:13:37.586
So what this contradicts
is this assumption

01:13:37.586 --> 01:13:39.960
that there are at least two
vertices in the intersection.

01:13:39.960 --> 01:13:42.459
Now, I know there can't be two
vertices in the intersection.

01:13:42.459 --> 01:13:43.570
It's got to be fewer.

01:13:43.570 --> 01:13:46.580
Could be zero, but
it can't really

01:13:46.580 --> 01:13:52.760
be zero, because S2
and S2 both contain V3.

01:13:52.760 --> 01:13:54.760
So it's got to be exactly one.

01:13:54.760 --> 01:13:58.120
In fact-- it's the crazy proof.

01:13:58.120 --> 01:14:00.826
When I read this,
I was like, really?

01:14:00.826 --> 01:14:02.890
It works, though.

01:14:02.890 --> 01:14:04.240
You can do all of them.

01:14:04.240 --> 01:14:09.972
This is going to equal exactly
V1 and S1 intersect S3.

01:14:09.972 --> 01:14:11.180
You can do this for any pair.

01:14:11.180 --> 01:14:13.930
So this is going to be V2.

01:14:13.930 --> 01:14:16.040
So all these intersections
have size one,

01:14:16.040 --> 01:14:17.780
and we know what it is.

01:14:17.780 --> 01:14:18.390
So what?

01:14:26.640 --> 01:14:38.230
Well, now if I take the
union of all of them--

01:14:38.230 --> 01:14:39.580
there's only this sharing.

01:14:39.580 --> 01:14:41.440
There's only three shared guys.

01:14:41.440 --> 01:14:45.360
So I get twice the
size of all them, which

01:14:45.360 --> 01:14:53.305
is S1 plus S2 plus S3 minus 3.

01:14:56.360 --> 01:14:57.450
Not twice.

01:14:57.450 --> 01:15:00.520
Sorry, just that.

01:15:00.520 --> 01:15:02.857
Who cares.

01:15:02.857 --> 01:15:04.565
Take all the edges
induced by those guys.

01:15:09.290 --> 01:15:16.250
At the very least, that's
going to be-- good.

01:15:16.250 --> 01:15:16.750
Now I see.

01:15:21.140 --> 01:15:23.150
I think that'd
actually be equal.

01:15:23.150 --> 01:15:25.310
But the point is they
don't share any edges.

01:15:25.310 --> 01:15:26.976
Because they only
share a single vertex,

01:15:26.976 --> 01:15:28.940
there's no room to
share any edges.

01:15:28.940 --> 01:15:32.530
So these guys should be
probably equal to each other.

01:15:32.530 --> 01:15:34.330
Edges induced by all
of them versus edges

01:15:34.330 --> 01:15:36.160
induced by each of
them individually.

01:15:36.160 --> 01:15:40.050
Here the whole is equal
to the sum of the parts.

01:15:40.050 --> 01:15:44.440
And this is going to be
2 times number of S1s

01:15:44.440 --> 01:15:49.385
plus number of S2s plus
number of S3s minus 9.

01:15:53.760 --> 01:15:55.130
This should be equal.

01:15:55.130 --> 01:15:57.812
We assumed that
they were exactly

01:15:57.812 --> 01:15:58.895
the right number of edges.

01:16:01.530 --> 01:16:03.960
So this is the usual problem.

01:16:07.570 --> 01:16:10.940
This can't happen by the
same argument we did here.

01:16:10.940 --> 01:16:14.170
If we include V1, V2, V3
and we don't include V,

01:16:14.170 --> 01:16:15.950
we've got to have too few edges.

01:16:15.950 --> 01:16:18.910
And here we're saying we have
exactly the right number.

01:16:18.910 --> 01:16:21.705
Can't happen.

01:16:21.705 --> 01:16:24.690
AUDIENCE: [INAUDIBLE]

01:16:24.690 --> 01:16:26.190
PROFESSOR: It's a
slight discrepancy

01:16:26.190 --> 01:16:28.200
between the 9 and the 3.

01:16:28.200 --> 01:16:28.880
Sorry, question?

01:16:28.880 --> 01:16:31.710
AUDIENCE: [INAUDIBLE].

01:16:31.710 --> 01:16:32.960
PROFESSOR: There's no 2 here.

01:16:32.960 --> 01:16:35.900
Here I'm counting vertices,
here I'm counting edges.

01:16:35.900 --> 01:16:39.210
So I get a 2 here.

01:16:39.210 --> 01:16:47.200
This thing is equal
to this thing plus 3.

01:16:53.400 --> 01:16:55.000
Ah, algebra.

01:16:55.000 --> 01:16:56.240
I multiply the 2 by the 3.

01:16:56.240 --> 01:16:56.810
I get 6.

01:16:56.810 --> 01:16:58.030
It cancels with the 9.

01:16:58.030 --> 01:16:59.242
I get minus 3.

01:16:59.242 --> 01:17:01.450
So this says I should have
exactly the right number--

01:17:01.450 --> 01:17:03.661
twice the size of
the set minus 3.

01:17:03.661 --> 01:17:04.410
That can't happen.

01:17:04.410 --> 01:17:05.910
I have to have at
least one fewer.

01:17:05.910 --> 01:17:07.780
That's what we argued.

01:17:07.780 --> 01:17:08.300
It's messy.

01:17:08.300 --> 01:17:09.460
You should read the notes.

01:17:09.460 --> 01:17:12.900
But that proves Laman's theorem.

01:17:12.900 --> 01:17:15.185
Now, in the remaining
four minutes,

01:17:15.185 --> 01:17:18.622
I want to tell you
two more cool things.

01:17:18.622 --> 01:17:19.580
Three more cool things.

01:17:19.580 --> 01:17:21.960
Great.

01:17:21.960 --> 01:17:22.770
All right.

01:17:22.770 --> 01:17:27.360
First thing is you can turn
this into an algorithm.

01:17:27.360 --> 01:17:29.355
How do you turn it
into an algorithm?

01:17:29.355 --> 01:17:30.880
It's a crazy idea.

01:17:30.880 --> 01:17:33.390
Roughly speaking,
in every vertex,

01:17:33.390 --> 01:17:37.230
you imagine there's two little
pebbles sitting on the vertex.

01:17:37.230 --> 01:17:40.670
And then there's a bunch of
edges incident to that vertex.

01:17:40.670 --> 01:17:44.760
You can assign each of these
pebbles to one of those edges.

01:17:44.760 --> 01:17:46.830
Something like that.

01:17:46.830 --> 01:17:50.050
You get to choose each, but
I only have two of them.

01:17:50.050 --> 01:17:53.910
I do that for every vertex.

01:17:53.910 --> 01:17:57.190
So something like that.

01:17:57.190 --> 01:17:58.855
If I can cover all
the edges-- there's

01:17:58.855 --> 01:18:01.300
a slight extra
condition-- but if I

01:18:01.300 --> 01:18:06.740
can cover all the edge in
this way, I claim I'm rigid.

01:18:06.740 --> 01:18:08.670
Well, not cover all the edges.

01:18:08.670 --> 01:18:11.290
If I can get all the
pebbles off the vertices

01:18:11.290 --> 01:18:16.030
without them hitting each
other, then I'm rigid.

01:18:16.030 --> 01:18:18.220
I might have more extra
edges that aren't covered.

01:18:18.220 --> 01:18:19.360
Those are the extra edges.

01:18:19.360 --> 01:18:20.530
You should throw them away.

01:18:20.530 --> 01:18:21.510
That's over-bracing.

01:18:21.510 --> 01:18:23.255
It's too much to be rigid.

01:18:23.255 --> 01:18:26.770
But if I can get all
these pebbles off somehow,

01:18:26.770 --> 01:18:30.340
then I have roughly the right
number of edges for vertices.

01:18:30.340 --> 01:18:32.110
And while it's not
obvious, it turns out

01:18:32.110 --> 01:18:35.050
you will satisfy Laman's
condition in that situation.

01:18:35.050 --> 01:18:37.600
And so it turns out to just
be a graph searching problem.

01:18:37.600 --> 01:18:39.370
You have to push
the pebbles around

01:18:39.370 --> 01:18:42.350
in order to get them
off the vertices.

01:18:42.350 --> 01:18:45.400
You don't have a lot of choices
where the pebbles can go.

01:18:45.400 --> 01:18:54.600
And it turns out to be basically
m calls to path connectivity

01:18:54.600 --> 01:18:56.090
operations.

01:18:56.090 --> 01:18:57.740
So I've just given two graphs.

01:18:57.740 --> 01:19:00.140
So I'm given a
connected graph, which

01:19:00.140 --> 01:19:02.560
is the ways that I can
move the pebbles around.

01:19:02.560 --> 01:19:05.330
I just want to know, can
I do a chain reaction

01:19:05.330 --> 01:19:10.240
of pebble twitches till I
get this one moved away?

01:19:10.240 --> 01:19:11.920
So it's just a
depth first search.

01:19:11.920 --> 01:19:12.510
Whatever.

01:19:12.510 --> 01:19:15.860
So this cost linear time.

01:19:15.860 --> 01:19:18.320
I think we could probably
get away with n operations

01:19:18.320 --> 01:19:23.004
each linear time
in number of edges.

01:19:23.004 --> 01:19:24.545
So the total amount
of time is number

01:19:24.545 --> 01:19:26.550
of vertices times
number of edges.

01:19:26.550 --> 01:19:29.550
M is the number of edges.

01:19:29.550 --> 01:19:30.750
Polynomial time.

01:19:30.750 --> 01:19:31.740
Life is good.

01:19:31.740 --> 01:19:32.400
Open problem.

01:19:32.400 --> 01:19:33.335
Can you do better?

01:19:33.335 --> 01:19:34.960
But that's been around
for a long time.

01:19:34.960 --> 01:19:36.400
We've tried it before.

01:19:36.400 --> 01:19:38.760
Seems quite challenging.

01:19:38.760 --> 01:19:40.190
Bigger open problem.

01:19:40.190 --> 01:19:42.240
What about 3D?

01:19:42.240 --> 01:19:47.450
In 3D, there these annoying
situations, like this one.

01:19:52.460 --> 01:19:54.030
Two tetrahedra
glued along a face.

01:20:02.510 --> 01:20:05.920
Take two-- we call this a
banana-- take two bananas.

01:20:05.920 --> 01:20:09.300
Joined them at vertices,
the opposing vertices.

01:20:09.300 --> 01:20:11.900
This thing is flexible, right?

01:20:11.900 --> 01:20:13.900
You just rotate through here.

01:20:13.900 --> 01:20:15.110
It's generically flexible.

01:20:15.110 --> 01:20:16.443
It doesn't matter how I draw it.

01:20:16.443 --> 01:20:17.870
You can rotate
through that axis.

01:20:17.870 --> 01:20:21.080
But it has 2n minus 6
edges, and every subset

01:20:21.080 --> 01:20:22.980
has at most 3n minus 6 edges.

01:20:22.980 --> 01:20:25.020
So Laman doesn't hold.

01:20:25.020 --> 01:20:27.740
Does the generalized version
of Henneberg's theorem hold?

01:20:27.740 --> 01:20:29.240
We don't know.

01:20:29.240 --> 01:20:30.851
I think maybe yes.

01:20:30.851 --> 01:20:32.600
If you want to work
on 3D rigidity-- which

01:20:32.600 --> 01:20:36.080
is a little scary, because a
lot of people worked on it--

01:20:36.080 --> 01:20:38.040
I think Henneberg might
be a good way to go.

01:20:38.040 --> 01:20:39.210
It might not lead
to an algorithm,

01:20:39.210 --> 01:20:41.335
but at least you might get
a nice characterization.

01:20:44.580 --> 01:20:45.080
It'd be fun.

01:20:45.080 --> 01:20:47.510
I think Henneberg would
make a great puzzle.

01:20:47.510 --> 01:20:51.120
By working forward not backward,
it's quite challenging.

01:20:51.120 --> 01:20:52.400
Other fun things.

01:20:55.160 --> 01:20:58.840
Let me tell you briefly
about polyhedra.

01:20:58.840 --> 01:21:03.400
Polyhedra are fun, and they
exist in three dimensions.

01:21:03.400 --> 01:21:04.940
Here's a polyhedron.

01:21:04.940 --> 01:21:09.430
It's a convex polygon-- it's
Buckminster Fuller Geodesic

01:21:09.430 --> 01:21:16.940
Dome in Montreal--
and it's convex.

01:21:16.940 --> 01:21:18.780
It's made of triangles.

01:21:18.780 --> 01:21:19.800
Is that rigid?

01:21:19.800 --> 01:21:21.070
It looks like it.

01:21:21.070 --> 01:21:26.290
Hasn't fallen down yet-- it's
been there for 40 years now.

01:21:26.290 --> 01:21:28.290
Indeed, you can prove
that thing is rigid,

01:21:28.290 --> 01:21:32.210
and this is the basis
for geodesic domes.

01:21:32.210 --> 01:21:36.260
Turns out, if you have a convex
polyhedron-- so 3D I said

01:21:36.260 --> 01:21:36.940
is really hard.

01:21:36.940 --> 01:21:38.940
But this does not look
like a convex polyhedron.

01:21:38.940 --> 01:21:44.470
So what if you had a 3D linkage
that is the surface of a convex

01:21:44.470 --> 01:21:46.870
polyhedron and every
face is a triangle?

01:21:49.860 --> 01:21:51.749
I mean, ignoring the
floor for a little bit,

01:21:51.749 --> 01:21:53.040
but you can deal with that too.

01:21:53.040 --> 01:21:55.530
Every face here is a triangle.

01:21:55.530 --> 01:21:59.460
It may be easier to
see in this diagram.

01:21:59.460 --> 01:22:00.290
So it's a linkage.

01:22:00.290 --> 01:22:02.660
It's a bunch of triangles.

01:22:02.660 --> 01:22:05.110
That thing willl be
generically rigid.

01:22:05.110 --> 01:22:08.100
And even rigid-- never
mind generically.

01:22:08.100 --> 01:22:11.000
You can prove this
thing is rigid,

01:22:11.000 --> 01:22:16.890
and it was proved, roughly
speaking, by Alexandrov,

01:22:16.890 --> 01:22:24.310
let's say, or Den--
the early to mid 1900s.

01:22:24.310 --> 01:22:26.220
That's cool.

01:22:26.220 --> 01:22:30.770
And that doesn't mean that there
aren't other configurations.

01:22:30.770 --> 01:22:33.000
So here's a convex
polyhedron, and you

01:22:33.000 --> 01:22:35.080
could triangulate
the sides also.

01:22:35.080 --> 01:22:38.880
And there's a non-convex
realization of that.

01:22:38.880 --> 01:22:41.980
But as long as you stay
convex, and if you move--

01:22:41.980 --> 01:22:43.220
this requires a big jump.

01:22:43.220 --> 01:22:45.700
And you can show that if you
have a convex polyhedron,

01:22:45.700 --> 01:22:49.400
in order for it to flex
continuously, well, it can't.

01:22:49.400 --> 01:22:51.850
In order to flex at
all, it has to jump

01:22:51.850 --> 01:22:53.370
into a non-convex state.

01:22:53.370 --> 01:22:55.360
But there's a fun
thing that happens

01:22:55.360 --> 01:22:57.281
when you look at
non-convex polyhedra.

01:22:57.281 --> 01:22:59.530
And it's really hard to see
this polyhedron, this dent

01:22:59.530 --> 01:23:03.590
on the backside, but you can
cut this out and make one.

01:23:03.590 --> 01:23:06.840
And it's a non-convex
polyhedron,

01:23:06.840 --> 01:23:08.820
and it does have
a continuous flex.

01:23:08.820 --> 01:23:11.940
It's a flexible linkage.

01:23:11.940 --> 01:23:14.930
It's triangulated,
but it's not convex,

01:23:14.930 --> 01:23:17.290
and so Alexandrov's
theorem doesn't apply.

01:23:17.290 --> 01:23:21.660
And you can move
it continuously.

01:23:21.660 --> 01:23:23.550
It's a flexible linkage.

01:23:23.550 --> 01:23:27.600
Fun fact-- when it moves,
the volume stays constant.

01:23:27.600 --> 01:23:29.016
It's called the
bellow's theorem--

01:23:29.016 --> 01:23:33.230
it was open for many years--
by Connelly and others.

01:23:33.230 --> 01:23:37.800
And so in fact, you take any--
not just this polyhedron--

01:23:37.800 --> 01:23:39.915
you take any polyhedron
that can flex--

01:23:39.915 --> 01:23:43.050
it has to be non-convex--
its volume will stay constant

01:23:43.050 --> 01:23:44.790
throughout the whole motion.

01:23:44.790 --> 01:23:47.470
So if you've ever
played with the bellows,

01:23:47.470 --> 01:23:51.390
you may think this is not
true, because bellows pump air

01:23:51.390 --> 01:23:53.750
in and out somehow.

01:23:53.750 --> 01:23:56.380
And the theorem is well, you
can't build a bellows out

01:23:56.380 --> 01:23:56.880
of linkages.

01:23:59.400 --> 01:24:02.492
You could maybe build
bellows out a paper,

01:24:02.492 --> 01:24:06.560
or a flexible material, but
if you cannot triangulate that

01:24:06.560 --> 01:24:09.150
surface, you cannot
make it a metal bellows.

01:24:09.150 --> 01:24:11.270
Never mind if they
exist in reality.

01:24:11.270 --> 01:24:15.550
They are theoretically
impossible to build.

01:24:15.550 --> 01:24:18.260
I don't know-- are
there metal bellows?

01:24:18.260 --> 01:24:18.960
That's it.

01:24:18.960 --> 01:24:22.890
And next time, we will talk
about more rigidity and things

01:24:22.890 --> 01:24:25.010
called tensegrities,
which even more exciting.

01:24:25.010 --> 01:24:27.343
And we'll see how this ties
into actually getting things

01:24:27.343 --> 01:24:30.910
to fold from point A to point
B, not just do they fold at all.

01:24:30.910 --> 01:24:32.790
It's all related.

