WEBVTT
Kind: captions
Language: en

00:00:05.772 --> 00:00:06.980
CHRIS MCKENZIE: Good morning.

00:00:06.980 --> 00:00:08.310
Welcome.

00:00:08.310 --> 00:00:09.120
Hi.

00:00:09.120 --> 00:00:10.310
I'm Chris McKenzie.

00:00:10.310 --> 00:00:14.080
I'm a UX designer on Daydream,
Google's virtual reality

00:00:14.080 --> 00:00:16.190
platform.

00:00:16.190 --> 00:00:18.800
In the leadup to
releasing Daydream

00:00:18.800 --> 00:00:22.500
last year, our team
faced many challenges.

00:00:22.500 --> 00:00:25.660
And one of those challenges
that was particularly tricky

00:00:25.660 --> 00:00:28.510
was designing for
screens in VR--

00:00:28.510 --> 00:00:32.229
making sure that text
was easily readable,

00:00:32.229 --> 00:00:35.220
that buttons were easily
clickable and lists

00:00:35.220 --> 00:00:37.660
were easily scrollable.

00:00:37.660 --> 00:00:41.520
And another challenge was
that this is virtual reality,

00:00:41.520 --> 00:00:44.600
and when you hear
those words, your mind

00:00:44.600 --> 00:00:47.870
tends to go straight
to the third dimension.

00:00:47.870 --> 00:00:52.820
You're thinking of 3D tools,
fantastic environments,

00:00:52.820 --> 00:00:58.220
surreal use cases, like I want
to build a castle on Mars.

00:00:58.220 --> 00:01:02.500
So these are really juicy,
challenging design problems

00:01:02.500 --> 00:01:03.790
to go after.

00:01:03.790 --> 00:01:08.450
But what we found was if we ever
had to have the user bring up

00:01:08.450 --> 00:01:12.020
a menu of options or read
through a dense amount

00:01:12.020 --> 00:01:15.780
of content, or pretty
much read anything,

00:01:15.780 --> 00:01:17.840
we found ourselves
designing what

00:01:17.840 --> 00:01:20.400
was essentially screens in VR.

00:01:20.400 --> 00:01:23.130
And this isn't too surprising.

00:01:23.130 --> 00:01:26.210
We're surrounded by screens
in real life all the time.

00:01:26.210 --> 00:01:29.504
We're all looking at two large
screens on stage right now.

00:01:29.504 --> 00:01:30.920
Some of you are
looking at screens

00:01:30.920 --> 00:01:32.680
in the palm of your hand.

00:01:32.680 --> 00:01:35.940
A considerable amount of
the content that we consume

00:01:35.940 --> 00:01:38.992
is packaged in a 2D form.

00:01:38.992 --> 00:01:41.630
And some basic
physiology behind this

00:01:41.630 --> 00:01:45.020
is that while we
exist in a 3D world,

00:01:45.020 --> 00:01:47.900
we see that world at
a projection of light

00:01:47.900 --> 00:01:49.730
hitting the back of our eyes.

00:01:49.730 --> 00:01:51.760
And our brain does
a good job of fusing

00:01:51.760 --> 00:01:55.170
that together and figuring
out some sense of depth.

00:01:55.170 --> 00:01:58.420
But we really only see
what his line of sight.

00:01:58.420 --> 00:02:02.020
I can't look around an opaque
object, like this podium,

00:02:02.020 --> 00:02:05.480
without physically
moving around it.

00:02:05.480 --> 00:02:09.539
And I have to read text
spread out on 2D planes.

00:02:09.539 --> 00:02:12.620
I can't read it as a
stack of letters going off

00:02:12.620 --> 00:02:13.400
into the distance.

00:02:13.400 --> 00:02:16.280
I can't look around them.

00:02:16.280 --> 00:02:18.550
So this makes
projected 2D content

00:02:18.550 --> 00:02:22.680
a really efficient form
of consuming information.

00:02:22.680 --> 00:02:25.810
And this is no different in
VR as it is in real life.

00:02:25.810 --> 00:02:29.760
The challenge in VR is that
all of the existing techniques

00:02:29.760 --> 00:02:32.740
and tools that we've used
to design for screens,

00:02:32.740 --> 00:02:36.220
for real life screens,
didn't necessarily apply,

00:02:36.220 --> 00:02:41.200
or they weren't as transferable
into virtual reality.

00:02:41.200 --> 00:02:45.200
What I'm going to go over today
is some concepts and ideas

00:02:45.200 --> 00:02:48.560
that our team has developed
over time to try and simplify

00:02:48.560 --> 00:02:49.786
this problem.

00:02:49.786 --> 00:02:51.285
And then my colleague,
Adam Glazier,

00:02:51.285 --> 00:02:56.130
is going to go over how we apply
those concepts in practice.

00:02:56.130 --> 00:03:00.810
So I'm going to start with
talking about a concept called

00:03:00.810 --> 00:03:03.770
virtual screens.

00:03:03.770 --> 00:03:07.390
So what if we could
take the basic concepts,

00:03:07.390 --> 00:03:10.290
the basic properties of
screens in real life,

00:03:10.290 --> 00:03:13.320
boil that down to
its essence, and then

00:03:13.320 --> 00:03:17.200
use that as a tool to
design for screens in VR?

00:03:17.200 --> 00:03:20.710
This is the basic idea
behind virtual screens.

00:03:20.710 --> 00:03:25.610
So what is it that all of
these screens have in common?

00:03:25.610 --> 00:03:30.870
To start, they all have an
intended viewing distance,

00:03:30.870 --> 00:03:35.100
how far away we've designed
these screens to be viewed.

00:03:35.100 --> 00:03:36.910
This can obviously be arranged.

00:03:36.910 --> 00:03:38.820
For the screens on
stage here, these

00:03:38.820 --> 00:03:41.520
were meant to be seen by
the first row, hopefully all

00:03:41.520 --> 00:03:43.500
the way back into the back row.

00:03:43.500 --> 00:03:45.070
It's just easiest
to think of this

00:03:45.070 --> 00:03:48.290
as what is the optimal distance
that these screens were

00:03:48.290 --> 00:03:50.740
intended to be viewed from.

00:03:50.740 --> 00:03:52.670
And that intended
viewing distance

00:03:52.670 --> 00:03:55.280
will inform the
size of the screen

00:03:55.280 --> 00:04:00.540
in addition to the size and
density of the content therein.

00:04:00.540 --> 00:04:02.300
So this is a really
important concept

00:04:02.300 --> 00:04:04.890
to get across if I want
to design for many screens

00:04:04.890 --> 00:04:06.970
across many different distances.

00:04:06.970 --> 00:04:10.160
And as content creators,
it's easy to take

00:04:10.160 --> 00:04:12.510
for granted all of the
thought and design that

00:04:12.510 --> 00:04:16.240
goes into any particular screen
that we're creating content

00:04:16.240 --> 00:04:17.860
for.

00:04:17.860 --> 00:04:20.649
Now in VR, we have to
do all of that legwork,

00:04:20.649 --> 00:04:23.910
and then create the content
that goes on the screen.

00:04:23.910 --> 00:04:26.040
And we have to do it for
every type of screen.

00:04:26.040 --> 00:04:30.810
We're not just mobile UI
designers or laptop UI

00:04:30.810 --> 00:04:31.400
designers.

00:04:31.400 --> 00:04:33.360
We're billboard designers.

00:04:33.360 --> 00:04:35.010
We're stop sign designers.

00:04:35.010 --> 00:04:37.950
We're exit signs across
the room designers.

00:04:37.950 --> 00:04:40.860
We have to cover
all of these cases.

00:04:40.860 --> 00:04:43.070
One way to do that--

00:04:43.070 --> 00:04:45.340
to create content that's
consistent across all

00:04:45.340 --> 00:04:47.550
of these different
types of screens--

00:04:47.550 --> 00:04:51.170
is to use angular units,
to make sure everything

00:04:51.170 --> 00:04:54.120
has the same angular size.

00:04:54.120 --> 00:04:55.870
And what I mean by
that is that even

00:04:55.870 --> 00:04:58.690
though the A on the
billboard in the back

00:04:58.690 --> 00:05:03.360
is much larger than the A on
the smartphone in the front,

00:05:03.360 --> 00:05:05.730
from the user's point
of view, they're

00:05:05.730 --> 00:05:09.080
going to appear to look
pretty much the same.

00:05:09.080 --> 00:05:13.200
This is because they have
the same angular size.

00:05:13.200 --> 00:05:14.830
This is a really
powerful concept.

00:05:14.830 --> 00:05:17.250
If we can design
all of our layouts

00:05:17.250 --> 00:05:19.587
in any sort of
angular unit, that

00:05:19.587 --> 00:05:22.170
means that we don't have to care
about how far away the screen

00:05:22.170 --> 00:05:24.232
will be placed later on.

00:05:24.232 --> 00:05:26.190
It will be just as
readable, whether it's right

00:05:26.190 --> 00:05:31.760
up next to the user's
face or 20 meters away.

00:05:31.760 --> 00:05:34.170
Now, finding this unit
was a little tricky.

00:05:34.170 --> 00:05:37.900
And so the team went on
a little bit of a journey

00:05:37.900 --> 00:05:40.460
to figure out what
we should use.

00:05:40.460 --> 00:05:42.050
We started with degrees.

00:05:42.050 --> 00:05:45.360
It's a very common angular unit.

00:05:45.360 --> 00:05:48.530
The problem with
degrees was you only

00:05:48.530 --> 00:05:53.420
have 360 of them
for a full rotation.

00:05:53.420 --> 00:05:55.770
So it's not a lot of
granularity there.

00:05:55.770 --> 00:05:57.340
UIs tend to have more.

00:05:57.340 --> 00:06:02.100
So if have a UI that's
60 degrees across, which

00:06:02.100 --> 00:06:05.999
is a very large UI, you only
have 60 units to work with.

00:06:05.999 --> 00:06:07.790
You're going to have
to deal with decimals,

00:06:07.790 --> 00:06:10.370
and decimals are messy
and hard to remember.

00:06:10.370 --> 00:06:15.010
In this particular example,
we have an example of--

00:06:15.010 --> 00:06:19.120
it's comfortably
readable body text.

00:06:19.120 --> 00:06:23.050
And that happens to be 1.375
degrees from what we found

00:06:23.050 --> 00:06:25.500
with today's current headsets.

00:06:25.500 --> 00:06:28.490
Now, that's just a really
hard number to remember.

00:06:28.490 --> 00:06:32.135
So we could step it up, and
we can go to minutes of arc.

00:06:32.135 --> 00:06:32.760
These are nice.

00:06:32.760 --> 00:06:36.596
You get 60 minutes
of arc per degree.

00:06:36.596 --> 00:06:38.220
And you get to use
this fun little tick

00:06:38.220 --> 00:06:42.760
mark at the end, which
gives you the fidelity--

00:06:42.760 --> 00:06:46.080
definitely 82, I don't have
to deal with decimals anymore.

00:06:46.080 --> 00:06:47.730
I have a whole
number to work with,

00:06:47.730 --> 00:06:50.560
and that's great, although
82 is a very large number

00:06:50.560 --> 00:06:53.037
for readable body text.

00:06:53.037 --> 00:06:54.120
That's more of a nit pick.

00:06:54.120 --> 00:07:00.550
The problem with minute of
arc, or degrees, or arcminutes,

00:07:00.550 --> 00:07:04.890
or arcseconds, is that
all of these angular units

00:07:04.890 --> 00:07:07.590
are hard to translate
to an actual size

00:07:07.590 --> 00:07:09.120
at a given distance.

00:07:09.120 --> 00:07:12.380
So in this case, we have
an A with an angular size

00:07:12.380 --> 00:07:14.410
of 82 arcminutes.

00:07:14.410 --> 00:07:20.279
And if I were to say that A is
a meter away, how tall is it,

00:07:20.279 --> 00:07:21.820
we wouldn't be able
to calculate that

00:07:21.820 --> 00:07:24.910
very easily without
pulling out a calculator.

00:07:24.910 --> 00:07:28.200
So what our team wanted to do
was basically have its cake

00:07:28.200 --> 00:07:28.920
and eat it, too.

00:07:28.920 --> 00:07:32.700
We wanted an angular unit that
would not change with distance,

00:07:32.700 --> 00:07:34.910
but then could be
easily transferred

00:07:34.910 --> 00:07:37.550
to a metric size, an
actual world space

00:07:37.550 --> 00:07:40.590
size at a given distance.

00:07:40.590 --> 00:07:43.310
Radians do straddle this
line to some extent.

00:07:43.310 --> 00:07:46.150
We explored that to
a certain degree--

00:07:46.150 --> 00:07:47.290
pun intended-- as well.

00:07:47.290 --> 00:07:54.170
But we decided that radians are
bound to the arc of a circle,

00:07:54.170 --> 00:07:56.600
and that's just a constraint
that we wouldn't need

00:07:56.600 --> 00:07:59.940
to be limited by for our UIs.

00:07:59.940 --> 00:08:04.480
So internally, we started
using this unit we call a dmm,

00:08:04.480 --> 00:08:07.180
and that stands for
distance-independent

00:08:07.180 --> 00:08:08.140
millimeter.

00:08:08.140 --> 00:08:12.240
It's kind of a playoff of
the density-independent pixel

00:08:12.240 --> 00:08:16.560
from Android that we used
to design UI layouts in.

00:08:16.560 --> 00:08:17.690
So what is a dmm?

00:08:17.690 --> 00:08:24.650
A dmm can be described as one
millimeter at a meter away.

00:08:24.650 --> 00:08:27.530
But it can also be
described as two millimeters

00:08:27.530 --> 00:08:30.920
at two meters away,
and a half a millimeter

00:08:30.920 --> 00:08:32.760
at a half meter away.

00:08:32.760 --> 00:08:34.559
All of these were one dmm.

00:08:34.559 --> 00:08:38.740
So it's an angular unit that
just follows a millimeter as it

00:08:38.740 --> 00:08:40.540
scales off into the distance.

00:08:43.490 --> 00:08:44.360
How do we use these?

00:08:44.360 --> 00:08:47.070
Let's look at a more
concrete example.

00:08:47.070 --> 00:08:49.540
In the upper left-hand
corner of this diagram,

00:08:49.540 --> 00:08:52.840
I have a screen space layout
that I have measured in dmms.

00:08:52.840 --> 00:08:55.740
All of my UI elements
are measured in dmms.

00:08:55.740 --> 00:09:01.340
It's 400 dmms by 480 dmms tall.

00:09:01.340 --> 00:09:03.030
And then down
below, I've applied

00:09:03.030 --> 00:09:09.560
that layout in world space to
three separate virtual screens.

00:09:09.560 --> 00:09:13.100
All of these virtual screens
have a different intended

00:09:13.100 --> 00:09:14.880
viewing distance.

00:09:14.880 --> 00:09:17.420
The first screen, the
smallest one on the left,

00:09:17.420 --> 00:09:22.270
was intended to be viewed
from one meter away.

00:09:22.270 --> 00:09:25.550
I call this the identity
position of a virtual screen.

00:09:25.550 --> 00:09:28.320
Nothing really changes too much
here between our screen space

00:09:28.320 --> 00:09:30.450
coordinates and our
world space coordinates.

00:09:30.450 --> 00:09:33.790
40 dmms tall is 40
millimeters tall.

00:09:33.790 --> 00:09:35.180
Easy enough.

00:09:35.180 --> 00:09:37.320
Then let's move on
to the second screen.

00:09:37.320 --> 00:09:40.920
That was intended to be
viewed two meters away.

00:09:40.920 --> 00:09:46.420
So in this case, all we did was
scale that screen up by two.

00:09:46.420 --> 00:09:48.680
And now, even though
the screen is twice

00:09:48.680 --> 00:09:51.470
as big as the other
screen that was intended

00:09:51.470 --> 00:09:54.750
to be viewed one meter
away, from the vantage point

00:09:54.750 --> 00:09:57.790
that both of these screens are
intended to be viewed from,

00:09:57.790 --> 00:09:59.930
they will look the
same to the user.

00:09:59.930 --> 00:10:02.470
They will have the
same angular size.

00:10:02.470 --> 00:10:04.510
Text will just as
readable, buttons

00:10:04.510 --> 00:10:08.150
will be just as clickable,
and motion will appear

00:10:08.150 --> 00:10:11.590
to move the same as well.

00:10:11.590 --> 00:10:13.490
So this is really
nice, because I

00:10:13.490 --> 00:10:16.110
wouldn't want the large
screen in the background

00:10:16.110 --> 00:10:19.470
to be animating slower than
the screens in the foreground

00:10:19.470 --> 00:10:24.110
just because the content in it
has to move a further distance.

00:10:24.110 --> 00:10:26.830
It would feel too
sluggish or lumbering.

00:10:26.830 --> 00:10:28.830
And this is something
that happens in real life

00:10:28.830 --> 00:10:31.170
with phones and TVs.

00:10:31.170 --> 00:10:35.080
The angular movement-- the
angular motion, I should say,

00:10:35.080 --> 00:10:38.854
of the content on those screens
is pretty much the same.

00:10:38.854 --> 00:10:40.270
Because otherwise,
you would think

00:10:40.270 --> 00:10:42.070
it's too slow or too fast.

00:10:42.070 --> 00:10:44.452
Now, if you did walk up to
that screen in the back that

00:10:44.452 --> 00:10:46.910
was intended to be viewed three
meters away-- if you walked

00:10:46.910 --> 00:10:51.240
all way up to it, it would
appear to be too fast.

00:10:51.240 --> 00:10:54.400
It would also appear to
have much too large text,

00:10:54.400 --> 00:10:58.440
and the textures in it would
probably be too blurry.

00:10:58.440 --> 00:11:00.300
That wouldn't be
the greatest vantage

00:11:00.300 --> 00:11:02.000
point to view that screen.

00:11:02.000 --> 00:11:03.880
This is OK, because
you're going to get

00:11:03.880 --> 00:11:05.420
the same thing if
you walked right

00:11:05.420 --> 00:11:07.520
up to your own television.

00:11:07.520 --> 00:11:09.410
Neither of these
screens were intended

00:11:09.410 --> 00:11:13.830
to be viewed from that
particular distance.

00:11:13.830 --> 00:11:17.820
So now we have a consistent
screen space layout system

00:11:17.820 --> 00:11:20.540
that we can apply to any
screen at any distance.

00:11:20.540 --> 00:11:24.460
And we can come up with
guidelines and components

00:11:24.460 --> 00:11:27.170
that are sized once
and scaled later.

00:11:27.170 --> 00:11:30.550
This is going to save
us a ton of time.

00:11:30.550 --> 00:11:32.970
And it's important to
note that we are not

00:11:32.970 --> 00:11:34.930
bound by width and height.

00:11:34.930 --> 00:11:38.960
Your screen space-- everything
you're measuring in dmms

00:11:38.960 --> 00:11:40.480
can also have z.

00:11:40.480 --> 00:11:42.380
Because this is virtual reality.

00:11:42.380 --> 00:11:44.510
We have some super
powers here that

00:11:44.510 --> 00:11:47.560
go beyond what screens in
real life are bound to.

00:11:47.560 --> 00:11:52.860
In this particular case, our UI
elements have some thickness,

00:11:52.860 --> 00:11:56.930
and we're also using
depth to indicate hover.

00:11:56.930 --> 00:11:58.480
And this can be used
to great effect.

00:11:58.480 --> 00:12:02.190
It can also be used
to detrimental effect.

00:12:02.190 --> 00:12:06.410
With great power comes
great responsibility.

00:12:06.410 --> 00:12:07.980
The rule of thumb
that I like to use

00:12:07.980 --> 00:12:11.070
is the further away
you get from a purely

00:12:11.070 --> 00:12:16.420
two dimensional representation
of content, the less efficient

00:12:16.420 --> 00:12:19.450
it will become at
conveying the idea you're

00:12:19.450 --> 00:12:21.710
trying to get across.

00:12:21.710 --> 00:12:23.810
So in this case, this
comes in the form of-- we

00:12:23.810 --> 00:12:26.280
have thickness to our
elements, so now users

00:12:26.280 --> 00:12:29.990
have to see this extra edge
on the lip of these cards.

00:12:29.990 --> 00:12:32.390
There's parallax of
foreground content

00:12:32.390 --> 00:12:34.560
moving against the background.

00:12:34.560 --> 00:12:36.250
There's extra shadows.

00:12:36.250 --> 00:12:40.450
Also in VR, my eyes are
converging at different depth

00:12:40.450 --> 00:12:42.790
points on this UI.

00:12:42.790 --> 00:12:45.920
My eyes are ever so
slightly converging

00:12:45.920 --> 00:12:50.410
to hit the labels
versus the backgrounds.

00:12:50.410 --> 00:12:52.840
This is extravisual
information that the user

00:12:52.840 --> 00:12:55.810
is going to have to process
before they even get

00:12:55.810 --> 00:12:59.220
to what your UI is all about.

00:12:59.220 --> 00:13:03.100
So again, depth can be
used to great effect,

00:13:03.100 --> 00:13:06.280
just within moderation.

00:13:06.280 --> 00:13:08.730
Another superpower that
virtual screens have

00:13:08.730 --> 00:13:15.290
is the ability to distort or
shape your UI to any contour.

00:13:15.290 --> 00:13:16.990
And this is really great.

00:13:16.990 --> 00:13:19.930
We can't do this as
much in real life.

00:13:19.930 --> 00:13:21.670
But in VR, now we can
have flat screens,

00:13:21.670 --> 00:13:24.290
curved screens, folded
screens, detached screens.

00:13:24.290 --> 00:13:27.010
They can all be floating
around the user.

00:13:27.010 --> 00:13:29.770
And whatever you
do to that contour

00:13:29.770 --> 00:13:33.360
is making a statement about
how that screen should be used,

00:13:33.360 --> 00:13:36.020
or how the content therein
should be displayed.

00:13:39.460 --> 00:13:42.210
So we can put all
these things together.

00:13:42.210 --> 00:13:44.830
And then when we put all
these things together,

00:13:44.830 --> 00:13:47.610
we need to make sure that our
ergonomic constraints still

00:13:47.610 --> 00:13:50.510
fit to the users
that we're actually

00:13:50.510 --> 00:13:53.210
making this content for,
and in the use cases

00:13:53.210 --> 00:13:54.695
that they're using it for.

00:13:54.695 --> 00:13:58.840
And luckily, we can
use dmms to lay out

00:13:58.840 --> 00:14:03.030
guidelines for areas that are
in view or just out of view

00:14:03.030 --> 00:14:04.980
if the user turns their head.

00:14:04.980 --> 00:14:06.570
Adam is going to
get more into detail

00:14:06.570 --> 00:14:11.420
about this later when he shows
off some of our guidelines.

00:14:11.420 --> 00:14:13.470
One other thing I just
really touched upon,

00:14:13.470 --> 00:14:15.820
and that's because it could
really have its own talk,

00:14:15.820 --> 00:14:17.440
is input.

00:14:17.440 --> 00:14:21.100
This model works really well
for input, and particularly

00:14:21.100 --> 00:14:22.500
ray-based input.

00:14:22.500 --> 00:14:27.800
Because rays are fairly
predictable things.

00:14:27.800 --> 00:14:30.250
They get more and more
frenetic as you get away

00:14:30.250 --> 00:14:31.850
from the origin.

00:14:31.850 --> 00:14:36.150
And because we're scaling
our UIs with distance,

00:14:36.150 --> 00:14:38.050
that means that all
of our hit areas

00:14:38.050 --> 00:14:42.750
are also scaling to catch that
ever-growing margin of error.

00:14:42.750 --> 00:14:45.660
So we can measure all of
our button hit areas in dmms

00:14:45.660 --> 00:14:47.800
as well.

00:14:47.800 --> 00:14:50.560
So I just talked about a
lot of different properties

00:14:50.560 --> 00:14:54.010
of what makes a virtual screen.

00:14:54.010 --> 00:14:56.050
But if you only remember
two of those today,

00:14:56.050 --> 00:14:59.280
it's that every virtual
screen has an intended viewing

00:14:59.280 --> 00:15:03.330
distance, how far away we
have designed this screen

00:15:03.330 --> 00:15:05.570
to be viewed by a user.

00:15:05.570 --> 00:15:07.560
And because we've come
up with that rule,

00:15:07.560 --> 00:15:11.920
it means that now we can
design our screen UI elements

00:15:11.920 --> 00:15:14.500
in a normalized
screen space, measured

00:15:14.500 --> 00:15:18.640
in dmms, that won't change
based on the distance

00:15:18.640 --> 00:15:21.900
that the screen is actually
going to be viewed from.

00:15:21.900 --> 00:15:25.730
Now, how do we use
this in practice?

00:15:25.730 --> 00:15:27.630
For that, I'm going
to hand things over

00:15:27.630 --> 00:15:30.410
to Adam so he can talk
about how we're applying

00:15:30.410 --> 00:15:31.740
these concepts in our process.

00:15:34.370 --> 00:15:35.170
Thank you.

00:15:35.170 --> 00:15:37.620
[APPLAUSE]

00:15:41.540 --> 00:15:43.090
ADAM GLAZIER: Thanks, Chris.

00:15:43.090 --> 00:15:44.520
So over the past
year, we've been

00:15:44.520 --> 00:15:48.110
using this system of dmms and
the intended viewing distance

00:15:48.110 --> 00:15:50.930
to design our apps for
the Daydream platform

00:15:50.930 --> 00:15:54.782
as well as Earth VR, which
is on Oculus and VIVE.

00:15:54.782 --> 00:15:56.990
So I'm going to walk you
through how we've done that.

00:15:56.990 --> 00:16:01.020
So just to back
up a second, it's

00:16:01.020 --> 00:16:04.290
really efficient, when
designing for a mobile screen,

00:16:04.290 --> 00:16:06.160
to use a laptop.

00:16:06.160 --> 00:16:07.300
You can work really fast.

00:16:07.300 --> 00:16:08.670
You can design fast.

00:16:08.670 --> 00:16:11.770
The screen density is different,
but you get used to that.

00:16:11.770 --> 00:16:16.220
You check your design on your
phone once or twice a day.

00:16:16.220 --> 00:16:20.830
You start to build an
understanding of, on my laptop,

00:16:20.830 --> 00:16:24.530
text sizes, button
sizes look larger.

00:16:24.530 --> 00:16:26.470
But you adapt.

00:16:26.470 --> 00:16:28.760
So we can do the
same thing for VR.

00:16:28.760 --> 00:16:30.630
We can design on the laptop.

00:16:30.630 --> 00:16:33.250
We can start to build a
mental model of the size

00:16:33.250 --> 00:16:37.380
and shape of things using dmms,
and then check them every once

00:16:37.380 --> 00:16:38.370
in awhile in Daydream.

00:16:40.960 --> 00:16:45.780
And this is important
because for those of you who

00:16:45.780 --> 00:16:48.680
work with 2D designers
or are 2D designers,

00:16:48.680 --> 00:16:52.060
you understand how
much consideration goes

00:16:52.060 --> 00:16:54.980
into creating a 2D interface.

00:16:54.980 --> 00:16:58.230
And the tools are
optimized for that.

00:16:58.230 --> 00:17:01.000
And for 3D, the inverse is true.

00:17:01.000 --> 00:17:03.490
If you're used to
building 3D things,

00:17:03.490 --> 00:17:06.109
these are extraordinarily
complex tools,

00:17:06.109 --> 00:17:08.800
and they are a completely
different way of thinking.

00:17:08.800 --> 00:17:11.319
So it's actually
beneficial to be

00:17:11.319 --> 00:17:15.599
able to work in these two
domains and have them cross.

00:17:15.599 --> 00:17:18.930
So today I'm going
to show you how

00:17:18.930 --> 00:17:21.589
we've done this workflow
using Sketch in Unity,

00:17:21.589 --> 00:17:26.010
but you could use any 2D app,
like Illustrator, Photoshop,

00:17:26.010 --> 00:17:29.895
or any 3D app, like Unreal,
or Maya, or Cinema 4D.

00:17:32.750 --> 00:17:35.750
So the way I like to
start is take a screenshot

00:17:35.750 --> 00:17:37.440
of the environment
that my UI is going

00:17:37.440 --> 00:17:40.540
to be in, exactly where it's
going to be when the user first

00:17:40.540 --> 00:17:43.300
gets in.

00:17:43.300 --> 00:17:44.980
And if we zoom in
to Sketch, you'll

00:17:44.980 --> 00:17:47.270
see that every
pixel equals a dmm.

00:17:47.270 --> 00:17:51.720
So this makes it super easy to
do red lines for developers.

00:17:51.720 --> 00:17:55.730
So when a font size
is 24, pixel is high,

00:17:55.730 --> 00:17:58.310
I know that it's
going to be 24 dmms,

00:17:58.310 --> 00:17:59.640
and that that will be readable.

00:18:03.510 --> 00:18:06.680
So before we get designing, you
need to understand something

00:18:06.680 --> 00:18:07.820
about ergonomics.

00:18:07.820 --> 00:18:10.050
There's not just the
ergonomics of your neck,

00:18:10.050 --> 00:18:12.880
but there's ergonomics
of your eye.

00:18:12.880 --> 00:18:18.100
The human eye can look positive
or minus horizontally and up

00:18:18.100 --> 00:18:22.760
and down about 30 to
35 degrees comfortably.

00:18:22.760 --> 00:18:27.270
So no matter how wide the field
of view is in your headset--

00:18:27.270 --> 00:18:30.505
just imagine a user is sitting
on a couch comfortably.

00:18:30.505 --> 00:18:32.630
They're not going to want
to move their head around

00:18:32.630 --> 00:18:35.380
too much, and their
eyes aren't going

00:18:35.380 --> 00:18:38.980
to want to move more than
about 30, 35 degrees.

00:18:38.980 --> 00:18:45.140
So you want to keep your primary
UI elements within this area.

00:18:45.140 --> 00:18:48.130
Then the next ergonomic
factor is the neck.

00:18:48.130 --> 00:18:50.300
So this is this outer region.

00:18:50.300 --> 00:18:53.510
It spans about 120 degrees.

00:18:53.510 --> 00:18:58.130
And that takes into account the
amount that the person's eyes

00:18:58.130 --> 00:19:00.450
can move plus their neck.

00:19:00.450 --> 00:19:02.670
Like I said, sitting
on a couch, this

00:19:02.670 --> 00:19:04.920
is the dominant posture for VR.

00:19:04.920 --> 00:19:08.190
Even though we all say swivel
chairs are the best, most

00:19:08.190 --> 00:19:12.880
people doing VR day over day
end up on the couch or in bed.

00:19:15.450 --> 00:19:17.490
Finally, there's
the horizon line.

00:19:17.490 --> 00:19:21.070
Ergonomically, people's
heads look down

00:19:21.070 --> 00:19:27.600
or face down about minus 10,
plus 10 to plus 15 degrees,

00:19:27.600 --> 00:19:30.290
and then our eyes
tend to look up.

00:19:30.290 --> 00:19:32.520
So your visual
center ends up being

00:19:32.520 --> 00:19:39.056
comfortably around plus six
degrees below the horizon line.

00:19:39.056 --> 00:19:40.430
What this means
is you don't want

00:19:40.430 --> 00:19:43.700
to have your UIs dead
center in the horizon line,

00:19:43.700 --> 00:19:46.830
because users will end
up feeling like they

00:19:46.830 --> 00:19:48.220
have to look up to see your UI.

00:19:51.236 --> 00:19:53.570
So once we understand
those ergonomics,

00:19:53.570 --> 00:19:55.690
now we need to
understand readability.

00:19:55.690 --> 00:20:02.100
And based on the screen
density today of, for instance,

00:20:02.100 --> 00:20:07.280
the smaller pixel phone, we came
up with these recommended text

00:20:07.280 --> 00:20:14.630
sizes that are readable for
people with various eyesight

00:20:14.630 --> 00:20:17.630
qualities.

00:20:17.630 --> 00:20:21.280
So these text sizes will go
down over time as pixel density

00:20:21.280 --> 00:20:22.240
increases.

00:20:22.240 --> 00:20:27.570
But right now, this is a safe
set of text sizes to use.

00:20:27.570 --> 00:20:32.020
And in terms of the
target size, if you're

00:20:32.020 --> 00:20:35.760
using a ray-based input,
like the Daydream controller

00:20:35.760 --> 00:20:39.750
to point and click on things,
the minimum hit target size

00:20:39.750 --> 00:20:42.950
we found that's comfortable
is about 64 dmms

00:20:42.950 --> 00:20:45.130
with 16 dmms of padding.

00:20:45.130 --> 00:20:49.780
So this won't go down over time.

00:20:49.780 --> 00:20:53.480
The Daydream controller is
within an imperceptible limit

00:20:53.480 --> 00:20:55.990
of human muscles.

00:20:55.990 --> 00:20:59.510
So while the text sizes
go down, these hit sizes

00:20:59.510 --> 00:21:00.700
will stay the same.

00:21:00.700 --> 00:21:03.010
And these will be
the same on the VIVE

00:21:03.010 --> 00:21:06.790
or any other platform that
has good quality tracking.

00:21:09.444 --> 00:21:11.110
So here's an example
of all those things

00:21:11.110 --> 00:21:15.000
I've just discussed in a
sketch template to spec.

00:21:15.000 --> 00:21:17.820
So everything is
specified in dmms.

00:21:17.820 --> 00:21:21.240
All the text sizes are
within the readable limit,

00:21:21.240 --> 00:21:24.760
and all the UI is
within the primary zone

00:21:24.760 --> 00:21:27.820
that we know is
comfortable for users.

00:21:27.820 --> 00:21:28.690
So that's good.

00:21:28.690 --> 00:21:30.060
We designed the front of our UI.

00:21:30.060 --> 00:21:32.560
Now we need to
tell the developer

00:21:32.560 --> 00:21:35.490
how this lives in 3D space.

00:21:35.490 --> 00:21:38.880
So here's an example of
we did in Street View.

00:21:38.880 --> 00:21:42.530
We put the UI at
2 and 1/2 meters.

00:21:42.530 --> 00:21:47.200
The UI is sitting about six
degrees below the horizon line.

00:21:47.200 --> 00:21:49.860
Or you could measure
that in millimeters,

00:21:49.860 --> 00:21:51.920
which is about 260.

00:21:51.920 --> 00:21:54.620
And then as you can see,
the navigation elements

00:21:54.620 --> 00:21:58.860
are actually closer to
the user and pointed

00:21:58.860 --> 00:21:59.970
towards the user's head.

00:22:03.620 --> 00:22:08.520
And then from the top view, we
started with a flat projection,

00:22:08.520 --> 00:22:12.410
but we found this to be unfair
to the content on the sides,

00:22:12.410 --> 00:22:15.370
because the content
starts to skew.

00:22:15.370 --> 00:22:17.710
It just feels a little odd.

00:22:17.710 --> 00:22:22.210
The outer cards didn't
feel as important.

00:22:22.210 --> 00:22:25.280
So we tried angling the UI.

00:22:25.280 --> 00:22:27.580
This works well
for certain things.

00:22:27.580 --> 00:22:29.990
But because of our
scrolling mechanism,

00:22:29.990 --> 00:22:32.130
it made it more complicated
for the developers

00:22:32.130 --> 00:22:36.180
to build scrolling and
this folding effect.

00:22:36.180 --> 00:22:40.250
So then we moved to
a cylindrical contour

00:22:40.250 --> 00:22:43.180
where all the UI is
being bent on a cylinder.

00:22:43.180 --> 00:22:46.710
And as you can see, the
navigation element in the front

00:22:46.710 --> 00:22:49.030
is also bent.

00:22:49.030 --> 00:22:52.100
This felt really--
it felt really

00:22:52.100 --> 00:22:54.740
odd to bend the small elements.

00:22:54.740 --> 00:23:00.800
I don't know if it's just being
in this world long enough,

00:23:00.800 --> 00:23:02.470
but it just didn't feel right.

00:23:02.470 --> 00:23:04.850
So we found that doing
two things-- one,

00:23:04.850 --> 00:23:08.270
relaxing the center
point of that cylinder.

00:23:08.270 --> 00:23:12.600
So if I go back, you can see
the center point we started.

00:23:12.600 --> 00:23:15.770
So it's basically a
cylinder around the user.

00:23:15.770 --> 00:23:17.730
And we moved it so
that the center point

00:23:17.730 --> 00:23:19.560
is behind the user.

00:23:19.560 --> 00:23:25.720
So what that does is it
relaxes that contour of the UI.

00:23:25.720 --> 00:23:29.330
It feels a little
less claustrophobic

00:23:29.330 --> 00:23:30.870
and a little more natural.

00:23:30.870 --> 00:23:34.310
And also, when you have
[INAUDIBLE] tracking,

00:23:34.310 --> 00:23:37.550
you get a nicer parallax effect.

00:23:37.550 --> 00:23:42.440
And the UI looks better from
multiple angles, versus when

00:23:42.440 --> 00:23:44.570
the cylinder is
centered in your head,

00:23:44.570 --> 00:23:47.130
it really only looks
good from one angle.

00:23:47.130 --> 00:23:50.260
And you'll see that the
smaller nav element is using

00:23:50.260 --> 00:23:52.130
just a flat projection here.

00:23:55.560 --> 00:23:59.350
So when it gets time
to export your assets,

00:23:59.350 --> 00:24:02.450
we recommend exporting
at 1x right now.

00:24:02.450 --> 00:24:06.370
But this is going to vary a
lot as screen density goes up.

00:24:06.370 --> 00:24:08.140
But for the next
one or two years,

00:24:08.140 --> 00:24:10.370
1x will probably be fine.

00:24:10.370 --> 00:24:12.130
We found that in
some rare cases,

00:24:12.130 --> 00:24:16.490
an engineer might implement
an asset in a particular way

00:24:16.490 --> 00:24:20.430
where exporting it at a higher
resolution works better.

00:24:20.430 --> 00:24:23.700
But we recommend starting at 1x.

00:24:23.700 --> 00:24:26.300
And so what that
means is one pixel--

00:24:26.300 --> 00:24:33.800
you export a 240 by 480
asset, and it's 240 by 480.

00:24:33.800 --> 00:24:37.500
So when we bring
this into Unity,

00:24:37.500 --> 00:24:44.630
you can see here that we have an
empty object called the parent

00:24:44.630 --> 00:24:46.050
UI.

00:24:46.050 --> 00:24:48.130
And the scale is set to 1.

00:24:48.130 --> 00:24:52.540
The position is set
to 1 meter away.

00:24:52.540 --> 00:24:55.630
And inside that,
we have a canvas.

00:24:55.630 --> 00:24:59.230
And because canvas units
in Unity are set to meters,

00:24:59.230 --> 00:25:04.110
we need to scale the
canvas down by 1,000.

00:25:04.110 --> 00:25:07.460
And what this does is
it allows us to use dmms

00:25:07.460 --> 00:25:08.520
in the canvas element.

00:25:08.520 --> 00:25:12.100
So now that the
canvas is scaled down,

00:25:12.100 --> 00:25:17.390
whole units, like a button
defined as 100 dmms wide,

00:25:17.390 --> 00:25:18.646
we can just type in 100.

00:25:18.646 --> 00:25:20.145
We don't have to
mess with decimals.

00:25:22.980 --> 00:25:26.280
And so now that we
have this all set up,

00:25:26.280 --> 00:25:29.060
we can just move the parent UI.

00:25:29.060 --> 00:25:31.460
And we scale it by the
amount we're moving it.

00:25:31.460 --> 00:25:33.990
So if we move it to
3, we scale it by 3.

00:25:33.990 --> 00:25:39.700
And all of the
elements retain the--

00:25:39.700 --> 00:25:42.381
they look the same to the user
from that intended viewing

00:25:42.381 --> 00:25:42.880
distance.

00:25:47.140 --> 00:25:51.900
So from all of this work, we
put together a sketch file

00:25:51.900 --> 00:25:54.500
to get you started.

00:25:54.500 --> 00:25:56.410
It's full of UI
components, and we'll

00:25:56.410 --> 00:25:59.454
be adding more over
the year to it.

00:25:59.454 --> 00:26:00.870
But it's enough
to get you started

00:26:00.870 --> 00:26:03.700
with layouts and
buttons and font sizes,

00:26:03.700 --> 00:26:06.910
and things like that.

00:26:06.910 --> 00:26:08.770
So if you'd like
to get those, just

00:26:08.770 --> 00:26:11.000
go to our developers guidelines.

00:26:11.000 --> 00:26:14.170
It's developers.google.com/vr.

00:26:14.170 --> 00:26:17.210
And just look in the
Resources section.

00:26:17.210 --> 00:26:18.220
Thank you.

00:26:18.220 --> 00:26:21.270
[APPLAUSE]

