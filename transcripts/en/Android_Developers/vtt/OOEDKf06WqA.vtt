WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.820
[MUSIC PLAYING]

00:00:02.820 --> 00:00:04.230
XAVIER DUCROHET: Hello.

00:00:04.230 --> 00:00:06.354
My name is Xavier Ducrohet.

00:00:06.354 --> 00:00:08.270
MICHAL BENDOWSKI: My
name is Michal Bendowski.

00:00:08.270 --> 00:00:10.159
JEROME DOCHEZ: And
I'm Jerome Dochez.

00:00:10.159 --> 00:00:11.700
MICHAL BENDOWSKI:
And let us tell you

00:00:11.700 --> 00:00:12.950
about down the
Android Build System,

00:00:12.950 --> 00:00:15.510
especially a couple of features
that you may not know about.

00:00:15.510 --> 00:00:18.270
So let me start with the
performance checklist.

00:00:18.270 --> 00:00:22.020
That is all the things that you
should make sure are in order

00:00:22.020 --> 00:00:24.130
when you're trying to
improve your build times.

00:00:24.130 --> 00:00:27.490
So first of all, please
make sure to use the daemon.

00:00:27.490 --> 00:00:29.896
That is already the case if
you're building from Studio.

00:00:29.896 --> 00:00:32.520
But if, for some reason, you're
building from the commandline--

00:00:32.520 --> 00:00:34.061
like, for example,
when you're trying

00:00:34.061 --> 00:00:37.100
to merge your build times, make
sure you use the --daemon flag

00:00:37.100 --> 00:00:41.090
or enable it permanently
using the Gradle properties.

00:00:41.090 --> 00:00:44.390
Secondly, please make sure to
give the daemon enough memory.

00:00:44.390 --> 00:00:45.940
That is especially
important when

00:00:45.940 --> 00:00:48.350
using the in-process
texting support that Xav

00:00:48.350 --> 00:00:50.450
mentioned earlier today.

00:00:50.450 --> 00:00:53.350
You can use the
org.gradle.jvmargs property

00:00:53.350 --> 00:00:56.450
to set the heap size
that the daemon will use.

00:00:56.450 --> 00:00:59.550
On the other hand, if you find
that your builds are making

00:00:59.550 --> 00:01:01.610
your computer
unresponsive, you may

00:01:01.610 --> 00:01:04.910
want to limit the total number
of threads that you will use.

00:01:04.910 --> 00:01:07.610
And you can use the
android.threadPoolSize property

00:01:07.610 --> 00:01:09.100
to do that.

00:01:09.100 --> 00:01:11.730
Next, make sure you use
the latest build tools,

00:01:11.730 --> 00:01:14.966
specifically 23.0.2 is
the latest one currently.

00:01:14.966 --> 00:01:16.340
And it's very
important to use it

00:01:16.340 --> 00:01:18.860
because of the fixed
dex merger that Xav also

00:01:18.860 --> 00:01:20.380
mentioned earlier.

00:01:20.380 --> 00:01:21.625
Get an SSD.

00:01:21.625 --> 00:01:24.840
The sad truth is that
building 100 applications

00:01:24.840 --> 00:01:27.170
requires a lot of
I/O operations, which

00:01:27.170 --> 00:01:30.600
means they actually run a
lot faster on a fast drive.

00:01:30.600 --> 00:01:32.780
And lastly, make sure
you don't use timestamps

00:01:32.780 --> 00:01:35.370
or commit numbers in your
build files, or at least

00:01:35.370 --> 00:01:36.520
not for your debug builds.

00:01:36.520 --> 00:01:39.900
I'll come back to it
later in the presentation.

00:01:39.900 --> 00:01:42.620
But it's really easy to make
your builds non-incremental

00:01:42.620 --> 00:01:45.260
if things are too dynamic.

00:01:45.260 --> 00:01:46.070
OK.

00:01:46.070 --> 00:01:49.730
As mentioned, please try
the dexInProcess flag.

00:01:49.730 --> 00:01:51.934
It's not enabled
by default in 2.0,

00:01:51.934 --> 00:01:53.600
but it actually makes
a huge difference.

00:01:53.600 --> 00:01:58.030
So please try it and let us
know if it works for you.

00:01:58.030 --> 00:02:00.830
Also, consider having
a dedicated development

00:02:00.830 --> 00:02:03.420
flavor with minSdkVersion 21.

00:02:03.420 --> 00:02:05.930
The API-level 21
introduced some features

00:02:05.930 --> 00:02:08.090
that we tried to
emulate at build time

00:02:08.090 --> 00:02:12.640
for other devices like MultiDex,
but also vector drawables.

00:02:12.640 --> 00:02:15.250
If the MinSdk is
set to 21, then we

00:02:15.250 --> 00:02:17.070
have to do less at
build time, which

00:02:17.070 --> 00:02:18.980
means the builds are faster.

00:02:18.980 --> 00:02:21.030
As we mentioned earlier,
Studio will soon

00:02:21.030 --> 00:02:24.675
start to infer the minSdk
number based on the device you

00:02:24.675 --> 00:02:25.790
are targeting.

00:02:25.790 --> 00:02:28.546
But for now, having such a
flavor is probably a good idea.

00:02:28.546 --> 00:02:29.360
OK.

00:02:29.360 --> 00:02:31.660
Let's talk about testing now.

00:02:31.660 --> 00:02:33.910
I hope you already
know that we support

00:02:33.910 --> 00:02:37.670
unit test that execute locally
on your development computer.

00:02:37.670 --> 00:02:40.560
But just to reiterate, there
is a dedicated test source

00:02:40.560 --> 00:02:42.760
set where you can
put your unit tests.

00:02:42.760 --> 00:02:45.020
There is a matching
testCompile configuration

00:02:45.020 --> 00:02:47.830
for all your test dependencies.

00:02:47.830 --> 00:02:50.320
And we support all the
usual testing frameworks,

00:02:50.320 --> 00:02:52.760
although we recommend
you use Unit 4.

00:02:52.760 --> 00:02:55.250
There's a separate session
purely about testing right

00:02:55.250 --> 00:02:56.210
after this one.

00:02:56.210 --> 00:03:00.200
So I recommend you attend or
watch the recording later.

00:03:00.200 --> 00:03:02.800
Let me just say that what you
currently aim at supporting

00:03:02.800 --> 00:03:05.550
is to allow you to test
your business logic.

00:03:05.550 --> 00:03:07.450
That is the part
of your app that is

00:03:07.450 --> 00:03:09.510
naturally specific to Android.

00:03:09.510 --> 00:03:12.267
Any Android code that you end up
calling will throw exceptions.

00:03:12.267 --> 00:03:13.850
So you will have to
refactor your code

00:03:13.850 --> 00:03:16.710
to either avoid it or mock
those parts using a library

00:03:16.710 --> 00:03:19.170
like Mockito, for example.

00:03:19.170 --> 00:03:20.070
OK.

00:03:20.070 --> 00:03:22.200
When running JUnit
from the command line,

00:03:22.200 --> 00:03:24.690
it's important to
remember that the test

00:03:24.690 --> 00:03:27.770
task you may know from
Gradle in Android projects

00:03:27.770 --> 00:03:32.200
is actually an encore task that
triggers the real testing tasks

00:03:32.200 --> 00:03:34.430
for each variant independently.

00:03:34.430 --> 00:03:36.890
So for example, that would
trigger testReleaseUnitTest

00:03:36.890 --> 00:03:38.500
and testDebugUnitTest.

00:03:38.500 --> 00:03:41.140
Unless your business logic
does something different

00:03:41.140 --> 00:03:43.740
depending on the variant,
it's probably enough for you

00:03:43.740 --> 00:03:46.060
to just run Gradle testDebug.

00:03:48.670 --> 00:03:49.170
OK.

00:03:49.170 --> 00:03:52.320
If you need to configure your
test runs-- like, for example,

00:03:52.320 --> 00:03:57.140
you may want to increase the
heap size for the test runner.

00:03:57.140 --> 00:04:01.110
You can use the testOptions
unitTests.all block.

00:04:01.110 --> 00:04:03.670
That will apply the given
configuration closure

00:04:03.670 --> 00:04:07.080
to all the variant-specific
test tasks I mentioned earlier.

00:04:07.080 --> 00:04:09.910
And it's important to remember
that these settings are not

00:04:09.910 --> 00:04:11.850
picked up by Studio currently.

00:04:11.850 --> 00:04:13.600
So this is only useful
if you are invoking

00:04:13.600 --> 00:04:15.920
test through Gradle,
like, for example,

00:04:15.920 --> 00:04:19.880
in a continuous
integration server.

00:04:19.880 --> 00:04:23.330
Another testing feature you may
not know about are separate,

00:04:23.330 --> 00:04:25.620
dedicated test
projects, which allow

00:04:25.620 --> 00:04:29.020
you to keep your main code
and your test code separately,

00:04:29.020 --> 00:04:32.050
which can be useful if you need
this additional flexibility

00:04:32.050 --> 00:04:34.180
and also if your code
is already organized

00:04:34.180 --> 00:04:36.700
this way from the Eclipse days.

00:04:36.700 --> 00:04:38.970
The easiest way to get
started with this feature

00:04:38.970 --> 00:04:42.780
is probably to copy the template
from the Android Testing

00:04:42.780 --> 00:04:44.450
Templates repository.

00:04:44.450 --> 00:04:48.100
But let me give you a brief
overview of what's involved.

00:04:48.100 --> 00:04:52.100
So the first step is to
set the publishNonDefault

00:04:52.100 --> 00:04:54.330
on your main
application project.

00:04:54.330 --> 00:04:56.640
And then you create a
separate project that

00:04:56.640 --> 00:04:59.270
uses com.android.test plug-in.

00:04:59.270 --> 00:05:01.760
You specify which
project you want to test

00:05:01.760 --> 00:05:03.520
and which variant
you want to test.

00:05:03.520 --> 00:05:05.620
Most likely, you
also want to specify

00:05:05.620 --> 00:05:09.250
the testInstrumentationRunner
to be the one from Test Support

00:05:09.250 --> 00:05:11.050
Library.

00:05:11.050 --> 00:05:13.880
Then you put your testing
code in the main source

00:05:13.880 --> 00:05:15.900
set of your test project.

00:05:15.900 --> 00:05:18.040
That's something to remember.

00:05:18.040 --> 00:05:20.850
And currently, you still have
to put an instrumentation

00:05:20.850 --> 00:05:23.250
tag in your test
project manifest

00:05:23.250 --> 00:05:26.800
to specify the package of the
application you want to test,

00:05:26.800 --> 00:05:29.871
although we hope to get
rid of this step soon.

00:05:29.871 --> 00:05:30.370
OK?

00:05:30.370 --> 00:05:32.900
And once all of
the setup is done,

00:05:32.900 --> 00:05:36.940
you can run the usual
connectedAndroidTest task

00:05:36.940 --> 00:05:39.770
on your test project.

00:05:39.770 --> 00:05:40.270
OK.

00:05:40.270 --> 00:05:41.960
Another issue that
shows up quite often

00:05:41.960 --> 00:05:45.730
when people write testing
code is the dependency version

00:05:45.730 --> 00:05:50.530
conflict, which,
like, shows up when

00:05:50.530 --> 00:05:53.700
you're using the same library
in your main and test code.

00:05:53.700 --> 00:05:55.870
So what exactly is
the problem there?

00:05:55.870 --> 00:05:58.620
The problem is that at runtime,
your main APK and your test

00:05:58.620 --> 00:06:01.710
APK share the same process
and the same class path,

00:06:01.710 --> 00:06:04.540
which means they have to use the
same version of every library

00:06:04.540 --> 00:06:06.400
even if some of
those libraries were

00:06:06.400 --> 00:06:09.270
pulled in as
transitive dependencies

00:06:09.270 --> 00:06:10.995
of other libraries.

00:06:10.995 --> 00:06:12.870
Like, a common example
is support annotations

00:06:12.870 --> 00:06:16.130
in your main APK and then older
version of support annotations

00:06:16.130 --> 00:06:19.470
that is pulled in by some
of the test dependencies.

00:06:19.470 --> 00:06:22.680
So in this case, we choose
to be very explicit about

00:06:22.680 --> 00:06:25.890
what's going on, and we force
you to make a decision whether

00:06:25.890 --> 00:06:28.640
you want to change the version
of the library that's used

00:06:28.640 --> 00:06:32.510
by your main APK or the version
used by the test APK, which,

00:06:32.510 --> 00:06:36.250
in theory, may cause some of
the libraries in this example

00:06:36.250 --> 00:06:39.480
runner to misbehave,
although, in practice,

00:06:39.480 --> 00:06:41.334
usually they don't.

00:06:41.334 --> 00:06:43.750
So the easiest way to solve
this problem when you actually

00:06:43.750 --> 00:06:47.070
encounter is to add
another test dependency

00:06:47.070 --> 00:06:49.180
to your build.gradle
file that explicitly

00:06:49.180 --> 00:06:52.560
depends on the same
version of your library

00:06:52.560 --> 00:06:55.910
as your production code.

00:06:55.910 --> 00:06:56.410
OK?

00:06:56.410 --> 00:06:58.937
And now Xav will tell you
about native supports.

00:06:58.937 --> 00:06:59.770
XAVIER DUCROHET: OK.

00:06:59.770 --> 00:07:02.690
So starting with the new
version of the plug-in

00:07:02.690 --> 00:07:04.890
that we just released, we
have better native support

00:07:04.890 --> 00:07:06.901
than we did before.

00:07:06.901 --> 00:07:10.000
At I/O, I mentioned a new
plug-in that we're working on,

00:07:10.000 --> 00:07:12.830
the model-based plug-in, which
is a new API in the Gradle

00:07:12.830 --> 00:07:13.810
build system.

00:07:13.810 --> 00:07:19.989
And part of those API is the
ability to build native code.

00:07:19.989 --> 00:07:21.530
So without going
through the makefile

00:07:21.530 --> 00:07:24.110
that we have right
now in the NDK.

00:07:24.110 --> 00:07:26.770
So we made some additional
progress, not a whole lot,

00:07:26.770 --> 00:07:29.210
but we are progressing.

00:07:29.210 --> 00:07:30.930
So the first thing
to think about

00:07:30.930 --> 00:07:33.360
if you want to use it
and try it is that we

00:07:33.360 --> 00:07:34.670
have different plug-ins, right?

00:07:34.670 --> 00:07:36.419
Normally, it's
com.android.application and

00:07:36.419 --> 00:07:38.220
com.android.library.

00:07:38.220 --> 00:07:40.070
And now we have--
to replace them,

00:07:40.070 --> 00:07:41.680
to use the new
plug-in API, you have

00:07:41.680 --> 00:07:43.620
to use
com.android.model.application

00:07:43.620 --> 00:07:44.770
and library.

00:07:44.770 --> 00:07:46.980
And then we have
a third plug-in,

00:07:46.980 --> 00:07:50.100
which is a plug-in that
only generate an .so.

00:07:50.100 --> 00:07:52.086
It doesn't generate
anything specific Android.

00:07:52.086 --> 00:07:53.960
I mean, that .so is
meant to work on Android,

00:07:53.960 --> 00:07:57.350
but there's no Android
packaging around it.

00:07:57.350 --> 00:08:00.990
In all three cases, we
directly use the Gradle APIs

00:08:00.990 --> 00:08:03.470
to build native code,
but we configure them

00:08:03.470 --> 00:08:06.580
with the native tool
chain coming from the NDK.

00:08:06.580 --> 00:08:10.800
So the arm tool chain, the x86
too chain, and all of that.

00:08:10.800 --> 00:08:13.620
So if you are
using that plug-in,

00:08:13.620 --> 00:08:14.920
the DSL a little bit different.

00:08:14.920 --> 00:08:15.420
All right?

00:08:15.420 --> 00:08:17.301
I think we mentioned
that at I/O also.

00:08:17.301 --> 00:08:18.800
And there's some
documentation here.

00:08:18.800 --> 00:08:20.810
You should go to that
link and look at it.

00:08:20.810 --> 00:08:23.210
But basically, the
biggest difference

00:08:23.210 --> 00:08:26.000
is that everything is
under the model element.

00:08:26.000 --> 00:08:28.232
And then here, you
can see ndk.with.

00:08:28.232 --> 00:08:30.690
Again, the .with is something
we want to get rid of at some

00:08:30.690 --> 00:08:31.880
point.

00:08:31.880 --> 00:08:33.309
You just define the model name.

00:08:33.309 --> 00:08:35.350
And then it will create
a library with that name,

00:08:35.350 --> 00:08:38.049
and it will just take care
of everything, basically.

00:08:38.049 --> 00:08:39.990
And then under that
NDK element, you

00:08:39.990 --> 00:08:43.240
can also configure your
CFlag, your linker flag,

00:08:43.240 --> 00:08:46.090
and all of that.

00:08:46.090 --> 00:08:47.129
And something new.

00:08:47.129 --> 00:08:48.670
So some of that was
already presented

00:08:48.670 --> 00:08:49.756
in an earlier version.

00:08:49.756 --> 00:08:51.380
Something that was
not presented before

00:08:51.380 --> 00:08:53.890
was the ability to do
inter-module dependencies.

00:08:53.890 --> 00:08:55.630
So we're now hooking
up with, again,

00:08:55.630 --> 00:08:59.550
the new dependency management
that this new Gradle plug-in

00:08:59.550 --> 00:09:00.932
API brings.

00:09:00.932 --> 00:09:02.890
So you'll be able to do
dependencies like that.

00:09:02.890 --> 00:09:06.251
As you can see, it's a very
different DSL from before.

00:09:06.251 --> 00:09:06.750
Right?

00:09:06.750 --> 00:09:11.010
Before, you had the dependencies
block as a root element.

00:09:11.010 --> 00:09:15.170
Here, it's under each
source set element.

00:09:15.170 --> 00:09:16.470
So it's a little bit different.

00:09:16.470 --> 00:09:17.761
And there's some option, right?

00:09:17.761 --> 00:09:20.410
You see that it's not compile,
or debug compile, or anything.

00:09:20.410 --> 00:09:22.927
You just say what you
want to depend on.

00:09:22.927 --> 00:09:24.510
But you can have
some options on that.

00:09:24.510 --> 00:09:26.230
Like, if you want to
do a static linkage,

00:09:26.230 --> 00:09:28.590
you would do project library,
and then linkage static,

00:09:28.590 --> 00:09:29.490
things like that.

00:09:29.490 --> 00:09:31.670
I recommend heavily
that you look

00:09:31.670 --> 00:09:35.840
at the documentation for Gradle
itself to see all the things,

00:09:35.840 --> 00:09:37.990
because it's an area
that moves a lot.

00:09:37.990 --> 00:09:40.940
So you should
definitely look at that.

00:09:40.940 --> 00:09:44.020
And then I want to talk about
extending the Android plug-in.

00:09:44.020 --> 00:09:46.660
We know a lot of you do
a lot of things in there.

00:09:46.660 --> 00:09:50.970
Some of you even create plug-ins
for other people to use.

00:09:50.970 --> 00:09:52.360
Every time we
update the plug-in,

00:09:52.360 --> 00:09:55.310
we see people using third-party
plug-in being broken up,

00:09:55.310 --> 00:09:57.320
because the new
version of our plug-in

00:09:57.320 --> 00:09:59.620
is not compatible with
some third-party plug-in.

00:09:59.620 --> 00:10:02.310
And it's an area that we know is
becoming more and more painful.

00:10:02.310 --> 00:10:04.822
And we want to
solve the problem.

00:10:04.822 --> 00:10:07.280
It's not something that we're
going to solve super quickly.

00:10:07.280 --> 00:10:10.370
But there's a few things to
look at when you are doing that.

00:10:10.370 --> 00:10:13.820
So the first thing is we see
a lot of plug-ins just trying

00:10:13.820 --> 00:10:16.230
to access tasks by name.

00:10:16.230 --> 00:10:19.470
You know, the plug-in wants
to hook up in some task

00:10:19.470 --> 00:10:21.700
and then just do a
get task by name.

00:10:21.700 --> 00:10:23.140
And that's just,
like, a problem,

00:10:23.140 --> 00:10:25.794
because we're not guaranteeing
that those names are not

00:10:25.794 --> 00:10:26.460
going to change.

00:10:26.460 --> 00:10:29.260
This is not part of
our official API.

00:10:29.260 --> 00:10:31.700
Even Studio does not use
those names directly, right?

00:10:32.235 --> 00:10:34.360
In the information that's
really exported by Gradle

00:10:34.360 --> 00:10:37.670
through the tuning API,
part of that information

00:10:37.670 --> 00:10:39.380
contains the name
of the task to core,

00:10:39.380 --> 00:10:41.480
so that in case we
change it in the plug-in,

00:10:41.480 --> 00:10:43.000
Studio doesn't
need to be changed.

00:10:43.000 --> 00:10:44.480
It just reads the
information from the model.

00:10:44.480 --> 00:10:45.540
So you should do the same.

00:10:45.540 --> 00:10:46.165
Do not do that.

00:10:46.165 --> 00:10:50.400
Now, if you do that for your
own build script, that's fine.

00:10:50.400 --> 00:10:52.710
It's your problem to
fix when we break you.

00:10:52.710 --> 00:10:55.430
But if you're publishing
plug-in for other people to use,

00:10:55.430 --> 00:10:58.720
then you should be
very aware of that.

00:10:58.720 --> 00:11:00.340
Another thing to be
aware of, really,

00:11:00.340 --> 00:11:01.790
is how the afterEvaluate work.

00:11:01.790 --> 00:11:04.970
We see a lot of people who
are very confused about that.

00:11:04.970 --> 00:11:08.110
And afterEvaluate is
just basically a callback

00:11:08.110 --> 00:11:13.940
that is called after the main
DSL is passed and executed.

00:11:13.940 --> 00:11:15.750
And so we register one.

00:11:15.750 --> 00:11:18.030
As soon as you do
apply plug-in android,

00:11:18.030 --> 00:11:19.250
we actually register one.

00:11:19.250 --> 00:11:21.730
And that's where we're going
to create all of our tasks.

00:11:21.730 --> 00:11:24.880
And so if you try
to manipulate task

00:11:24.880 --> 00:11:27.240
before-- even though I said
you shouldn't, but if you're

00:11:27.240 --> 00:11:28.800
doing it, then you
should definitely

00:11:28.800 --> 00:11:32.900
do it in afterEvaluate,
because it's not working.

00:11:32.900 --> 00:11:35.990
But you can't actually
manipulate other things

00:11:35.990 --> 00:11:38.170
in afterEvaluate and task.

00:11:38.170 --> 00:11:42.367
If you want to change build
types or do some custom

00:11:42.367 --> 00:11:44.200
logic that's going to
change product flavor,

00:11:44.200 --> 00:11:47.770
it's kind of too late, because
your own afterEvaluate happens

00:11:47.770 --> 00:11:48.935
after hours.

00:11:48.935 --> 00:11:50.226
And so you know, it's too late.

00:11:50.226 --> 00:11:51.480
You have already
created the variance.

00:11:51.480 --> 00:11:52.646
We already created the task.

00:11:52.646 --> 00:11:55.910
And it's kind of late.

00:11:55.910 --> 00:11:58.760
So the right way, really,
to access our tasks

00:11:58.760 --> 00:12:00.680
is through the Variant API.

00:12:00.680 --> 00:12:05.910
So we have this DSL, where you
can do applicationVariants.all.

00:12:05.910 --> 00:12:07.220
And then you get a closure.

00:12:07.220 --> 00:12:10.170
And that gives you access
to the variant, each task,

00:12:10.170 --> 00:12:11.150
and all of that.

00:12:11.150 --> 00:12:13.302
Now, the trick here
is I just said, hey,

00:12:13.302 --> 00:12:15.010
you need to access
task in afterEvaluate,

00:12:15.010 --> 00:12:17.460
but that's not in
afterEvaluate, that code.

00:12:17.460 --> 00:12:19.610
The trick here is that all.

00:12:19.610 --> 00:12:21.620
It's something
specific to Gradle

00:12:21.620 --> 00:12:22.730
on the Gradle collection.

00:12:22.730 --> 00:12:24.830
And that, basically,
it's register

00:12:24.830 --> 00:12:26.170
the closure [INAUDIBLE].

00:12:26.170 --> 00:12:28.920
And it will apply that to
all existing and future

00:12:28.920 --> 00:12:30.500
item in the collection.

00:12:30.500 --> 00:12:33.370
So by the time you call that,
the collection will be empty.

00:12:33.370 --> 00:12:35.480
But every time we create
a variant and its task

00:12:35.480 --> 00:12:37.900
and we add it to the collection,
then your closure gets called.

00:12:37.900 --> 00:12:38.399
OK.

00:12:38.399 --> 00:12:40.490
So what can you do
with that object?

00:12:40.490 --> 00:12:43.160
You can do some basic things
like greying the name,

00:12:43.160 --> 00:12:43.660
for example.

00:12:43.660 --> 00:12:44.887
Now, that name is unique.

00:12:44.887 --> 00:12:45.720
So it's very useful.

00:12:45.720 --> 00:12:48.150
If you want to create
per variant task,

00:12:48.150 --> 00:12:50.080
you should use
that name as part,

00:12:50.080 --> 00:12:52.000
you know, like foo
plus getName, and then

00:12:52.000 --> 00:12:55.120
you know that it's going to
be unique for every variant.

00:12:55.120 --> 00:12:59.820
The DirName is one or
more segmented folders.

00:12:59.820 --> 00:13:04.200
Very useful to, again,
store your custom task data,

00:13:04.200 --> 00:13:08.280
do buildDir/interme
diate/Foo/getDirName

00:13:08.280 --> 00:13:10.844
and you know it's unique
for all the different tasks.

00:13:10.844 --> 00:13:12.260
You can also get
other information

00:13:12.260 --> 00:13:14.080
like the application ID.

00:13:14.080 --> 00:13:14.910
That's computed.

00:13:14.910 --> 00:13:16.910
It's a merge of
the product flavor

00:13:16.910 --> 00:13:20.030
and the suffix in the build
type, and things like that.

00:13:20.030 --> 00:13:24.400
You can also get access to the
build types, product flavor.

00:13:24.400 --> 00:13:27.070
Those are read-only.

00:13:27.070 --> 00:13:28.830
We've seen people change them.

00:13:28.830 --> 00:13:30.580
And so a few releases
ago, we actually now

00:13:30.580 --> 00:13:31.890
give you a read-only
version of them.

00:13:31.890 --> 00:13:33.130
You should not change them.

00:13:33.130 --> 00:13:35.510
They are shared across all
the different variants.

00:13:35.510 --> 00:13:37.280
So if you're trying
to change them,

00:13:37.280 --> 00:13:40.090
you need to change them before
you access the Variant API.

00:13:40.090 --> 00:13:43.892
You need to change that
in the regular DSL.

00:13:43.892 --> 00:13:45.600
We also give you access
to the task name.

00:13:45.600 --> 00:13:48.360
So that's where you want
to go and create the task

00:13:48.360 --> 00:13:50.026
rather than doing it by name.

00:13:50.026 --> 00:13:51.400
And we know that
a lot of you are

00:13:51.400 --> 00:13:52.816
trying to get those
tasks in order

00:13:52.816 --> 00:13:54.660
to do things like
inserting steps

00:13:54.660 --> 00:13:57.220
in between two different
task and things like that.

00:13:57.220 --> 00:13:59.808
And you have to be very careful
about what you're doing there,

00:13:59.808 --> 00:14:01.680
right?

00:14:01.680 --> 00:14:04.420
I'll go back in a little
bit about the Task API.

00:14:04.420 --> 00:14:08.142
But there's some things
that you want to do.

00:14:08.142 --> 00:14:09.850
For example, if you're
trying to generate

00:14:09.850 --> 00:14:11.308
what we consider
to be source code,

00:14:11.308 --> 00:14:15.750
whether that's Java source
code or Android resources,

00:14:15.750 --> 00:14:18.720
you shouldn't try to go in and
hook that manually yourself.

00:14:18.720 --> 00:14:22.300
We have some entry points
in the Variant API called

00:14:22.300 --> 00:14:24.050
Register Java-generating Task.

00:14:24.050 --> 00:14:27.300
There's actually some parameter
to that, like your task.

00:14:27.300 --> 00:14:32.240
And you should basically have
your plug-in add a new source

00:14:32.240 --> 00:14:35.170
folder to the regular Java
source folder list, right?

00:14:35.170 --> 00:14:37.400
It's like its multiple
source folder, not just one.

00:14:37.400 --> 00:14:39.380
So you can add a new
one to that collection

00:14:39.380 --> 00:14:41.340
and then have your task
just write to that,

00:14:41.340 --> 00:14:43.892
register your task with
that, and then we'll

00:14:43.892 --> 00:14:45.350
call it what it
needs to be called.

00:14:45.350 --> 00:14:47.272
Studio will know about it.

00:14:47.272 --> 00:14:48.730
And then you know,
it will work end

00:14:48.730 --> 00:14:50.550
to end rather than
having you kind

00:14:50.550 --> 00:14:52.410
of trying to find
the task manually

00:14:52.410 --> 00:14:55.040
and hooking things up together.

00:14:55.040 --> 00:14:57.375
You definitely don't want
to go into the javac task

00:14:57.375 --> 00:14:59.750
and try to give it additional
source folder there, right?

00:14:59.750 --> 00:15:02.170
Just tell us what the source
folder is, give us your task,

00:15:02.170 --> 00:15:04.354
and then we'll take
care of things for you.

00:15:04.354 --> 00:15:05.895
Now, if you look at
some of the task,

00:15:05.895 --> 00:15:08.130
you know, we don't
really have a proper API.

00:15:08.130 --> 00:15:10.122
So you may have looked
at our source code

00:15:10.122 --> 00:15:11.330
and seen something like that.

00:15:11.330 --> 00:15:13.455
It's like, hey, you know,
here's some public stuff,

00:15:13.455 --> 00:15:14.750
and here's some private stuff.

00:15:14.750 --> 00:15:15.916
Don't use the private stuff.

00:15:15.916 --> 00:15:17.850
It will break or
it will break you.

00:15:17.850 --> 00:15:20.500
That's why it says PRIVATE.

00:15:20.500 --> 00:15:23.380
The public stuff
may break anyway,

00:15:23.380 --> 00:15:27.700
because we haven't been very
good about really considering

00:15:27.700 --> 00:15:29.640
that a public API.

00:15:29.640 --> 00:15:34.000
It's definitely something
we want to do in the future.

00:15:34.000 --> 00:15:35.970
And we know that a
lot of people want

00:15:35.970 --> 00:15:38.610
to inject stuff between
two particular steps.

00:15:38.610 --> 00:15:40.900
And that's between
javac and dx, right?

00:15:40.900 --> 00:15:41.960
We know about that.

00:15:41.960 --> 00:15:45.500
And so we've been looking at
ways of solving that problem

00:15:45.500 --> 00:15:47.750
rather than having you go
and look at the source code,

00:15:47.750 --> 00:15:49.710
and see, hey, what
does the dx task do,

00:15:49.710 --> 00:15:51.870
and how do I inject it
additional [INAUDIBLE],

00:15:51.870 --> 00:15:52.897
or whatever?

00:15:52.897 --> 00:15:55.480
So if you look at it here, you
know, that's a default project.

00:15:55.480 --> 00:15:55.960
You create it.

00:15:55.960 --> 00:15:57.584
It just goes straight
from javac to dx.

00:15:57.584 --> 00:15:59.130
And that's easy.

00:15:59.130 --> 00:16:03.050
But in reality, you have
additional optional steps

00:16:03.050 --> 00:16:05.650
already-- jacoco, which
could or could not run,

00:16:05.650 --> 00:16:08.110
and then ProGuard, which
could or could not run.

00:16:08.110 --> 00:16:09.790
And then we just
added instant run.

00:16:09.790 --> 00:16:14.640
So imagine you trying to add
a couple of other bytecode

00:16:14.640 --> 00:16:18.210
manipulation thing and trying
to have to all of that together.

00:16:18.210 --> 00:16:21.329
You know, hey, what if I'm
plug in A, and it's plug in B,

00:16:21.329 --> 00:16:22.870
so that I can hook
myself separately?

00:16:22.870 --> 00:16:25.220
So we just wanted to
fix all that, right?

00:16:25.220 --> 00:16:29.870
So starting in 1.5, actually,
we introduced a Transform API

00:16:29.870 --> 00:16:33.080
that the goal is to
solve that problem.

00:16:33.080 --> 00:16:35.640
So it's just a
pipeline of transforms.

00:16:35.640 --> 00:16:37.404
It's not a pipeline.

00:16:37.404 --> 00:16:38.570
It's a very steady pipeline.

00:16:38.570 --> 00:16:42.830
It's mostly helping us set up
those different optional steps.

00:16:42.830 --> 00:16:44.770
We want the API to be
very simple in term

00:16:44.770 --> 00:16:46.180
of adding a new transform.

00:16:46.180 --> 00:16:48.280
And so it's not
something that you

00:16:48.280 --> 00:16:51.860
can manipulate after the fact.

00:16:51.860 --> 00:16:55.100
The API doesn't talk
at all about task.

00:16:55.100 --> 00:16:59.290
We don't want you to think about
manipulating task, handling

00:16:59.290 --> 00:17:00.850
the dependencies between them.

00:17:00.850 --> 00:17:02.600
All you have to tell
us is, you know, hey,

00:17:02.600 --> 00:17:05.349
what do you want to transform
and things like that.

00:17:05.349 --> 00:17:07.564
We take care of
the rest for you.

00:17:07.564 --> 00:17:09.369
We do support different types.

00:17:09.369 --> 00:17:14.530
So for now on the public API,
we support Java bytecode classes

00:17:14.530 --> 00:17:17.569
and non-Android
resources, things

00:17:17.569 --> 00:17:18.897
that you would find in a jar.

00:17:18.897 --> 00:17:20.980
And it's important, because,
for example, ProGuard

00:17:20.980 --> 00:17:22.690
manipulates those.

00:17:22.690 --> 00:17:24.089
And we also support dex file.

00:17:24.089 --> 00:17:26.460
Though it's not available
through the public API,

00:17:26.460 --> 00:17:28.790
we might change that a
little bit in the future.

00:17:28.790 --> 00:17:31.400
But for now, that's
not the case.

00:17:31.400 --> 00:17:33.460
The way we package and
merge resource libraries

00:17:33.460 --> 00:17:35.989
is actually also going
through that pipeline.

00:17:35.989 --> 00:17:37.530
And then we support
different scopes.

00:17:37.530 --> 00:17:39.850
So for example,
jacoco, we only run it

00:17:39.850 --> 00:17:44.060
on the project scope, only
the main app project module.

00:17:44.060 --> 00:17:45.910
Instantion also right
now only at project.

00:17:45.910 --> 00:17:48.280
But we'll add the submodule to
it, so you'll be able to say,

00:17:48.280 --> 00:17:49.930
hey, I want to run
on those two scopes.

00:17:49.930 --> 00:17:51.910
ProGuard will run on
all of the scopes,

00:17:51.910 --> 00:17:53.910
because it really want
to look at all the source

00:17:53.910 --> 00:17:55.470
code of all of it.

00:17:55.470 --> 00:17:58.830
So to implement a transform,
we have a abstract class

00:17:58.830 --> 00:18:00.434
called Transform.

00:18:00.434 --> 00:18:01.850
There's a few
method to implement.

00:18:01.850 --> 00:18:02.380
getName.

00:18:02.380 --> 00:18:03.570
It has to be unique.

00:18:03.570 --> 00:18:07.330
We actually use that to
generate the task name.

00:18:07.330 --> 00:18:11.514
getInputType is what you want
to transform, classes or dex.

00:18:11.514 --> 00:18:13.180
So ContentType is
actually an interface.

00:18:13.180 --> 00:18:16.030
But there's a separate
enum default content

00:18:16.030 --> 00:18:18.850
type that contains the
type you can change,

00:18:18.850 --> 00:18:22.670
because we have a private enum
for the internal-only types.

00:18:22.670 --> 00:18:23.830
Scope is an enum.

00:18:23.830 --> 00:18:26.685
And getScope will give you the
scope you want to manipulate.

00:18:26.685 --> 00:18:29.000
isIncremental-- whether
your task can or cannot be

00:18:29.000 --> 00:18:29.600
incremental.

00:18:29.600 --> 00:18:31.667
If you can't really
tell us force,

00:18:31.667 --> 00:18:33.000
then we'll optimize some things.

00:18:33.000 --> 00:18:35.040
Or we won't do some
work when we call you.

00:18:35.040 --> 00:18:37.640
And then finally,
the Transform method.

00:18:37.640 --> 00:18:40.120
So you get a context to get
some information about Gradle,

00:18:40.120 --> 00:18:42.330
not the task, but a few things.

00:18:42.330 --> 00:18:43.509
You get your inputs.

00:18:43.509 --> 00:18:45.050
You get some reference
inputs, right?

00:18:45.050 --> 00:18:49.270
When we run ProGuard, if
it's in a test app that's

00:18:49.270 --> 00:18:54.250
testing something, it needs to
have access to the tested code.

00:18:54.250 --> 00:18:59.660
And so the Gradle Transform
actually ask part of the scope

00:18:59.660 --> 00:19:01.750
that it ask it has a
getReference scope.

00:19:01.750 --> 00:19:03.710
That's not an abstract
method, but you

00:19:03.710 --> 00:19:05.109
can implement it anyway.

00:19:05.109 --> 00:19:06.650
And you can say it
has a scope that's

00:19:06.650 --> 00:19:08.047
called, like, Tested Code.

00:19:08.047 --> 00:19:10.130
So you can ask for that,
too, to get access to it.

00:19:10.130 --> 00:19:11.380
You're not supposed to touch it.

00:19:11.380 --> 00:19:12.080
You're not supposed to write it.

00:19:12.080 --> 00:19:14.190
But you can get access
to it to read it.

00:19:14.190 --> 00:19:16.000
And then Transform
Method Provider

00:19:16.000 --> 00:19:18.580
allows you to create
different type of outputs.

00:19:18.580 --> 00:19:21.460
And then whether that particular
run is incremental or not.

00:19:21.460 --> 00:19:23.209
And there's some
additional features on it

00:19:23.209 --> 00:19:25.510
like secondary file input,
secondary file output.

00:19:25.510 --> 00:19:28.180
For about, ProGuard
outputs its mapping file

00:19:28.180 --> 00:19:30.360
as a [INAUDIBLE] output,
things like that.

00:19:30.360 --> 00:19:34.070
And I encourage you to
look at the Java doc.

00:19:34.070 --> 00:19:37.600
So to use it, just do a
dependency on the Transform API

00:19:37.600 --> 00:19:40.530
artifact either in your own
plug-in or directly in your

00:19:40.530 --> 00:19:41.360
build script.

00:19:41.360 --> 00:19:45.634
And then there's
a global, for now,

00:19:45.634 --> 00:19:47.550
Android point in the
DSL, a registerTransform.

00:19:47.550 --> 00:19:49.480
And then give us the instance.

00:19:49.480 --> 00:19:51.020
If you give an
instance like that,

00:19:51.020 --> 00:19:54.090
it's a single instance that will
be used for all the variants.

00:19:54.090 --> 00:19:56.240
So make it stateless.

00:19:56.240 --> 00:19:59.290
But it's fairly easy to do.

00:19:59.290 --> 00:20:04.120
So all of those are using the
transform right now since 1.5.

00:20:04.120 --> 00:20:06.400
As I mentioned, Jacoco,
ProGuard, the new shrinker,

00:20:06.400 --> 00:20:09.010
instant run, dex.

00:20:09.010 --> 00:20:11.460
And because dex is
not a transform,

00:20:11.460 --> 00:20:14.650
we kind of remove
the regular dex task.

00:20:14.650 --> 00:20:18.109
So if you're currently trying
to use accessing the dex task,

00:20:18.109 --> 00:20:19.400
you're going to have a problem.

00:20:19.400 --> 00:20:21.550
And we want to fix that.

00:20:21.550 --> 00:20:24.780
It's not technically gone, but
it will throw an exception.

00:20:24.780 --> 00:20:27.380
So in term of order, this
is the order in which

00:20:27.380 --> 00:20:29.390
we will run the transform.

00:20:29.390 --> 00:20:32.760
And there's no way right
now to change that.

00:20:32.760 --> 00:20:34.852
It's really in term of
the third-party one.

00:20:34.852 --> 00:20:36.060
There could be more than one.

00:20:36.060 --> 00:20:38.018
But it's really first
come, first serve, right?

00:20:38.018 --> 00:20:40.660
It's like as you apply custom
plug-ins, that will drive

00:20:40.660 --> 00:20:43.416
the order of those transforms.

00:20:43.416 --> 00:20:44.540
So we have some limitation.

00:20:44.540 --> 00:20:45.800
So as I mentioned,
they are global,

00:20:45.800 --> 00:20:46.770
they are not co-variant.

00:20:46.770 --> 00:20:48.270
But we do want to
fix that hopefully

00:20:48.270 --> 00:20:49.891
for 2.0, for the final version.

00:20:49.891 --> 00:20:51.890
And you cannot change the
order through the API.

00:20:51.890 --> 00:20:53.720
And it's something we need to
figure out, because there's

00:20:53.720 --> 00:20:54.511
some issues, right?

00:20:54.511 --> 00:20:57.040
Like, ProGuard will merge
all the scope together

00:20:57.040 --> 00:20:57.940
into a single java.

00:20:57.940 --> 00:20:59.439
I talked about that
in my other talk

00:20:59.439 --> 00:21:01.765
about how it's generating
out a single JAR file.

00:21:01.765 --> 00:21:02.890
Then you shrink your dozen.

00:21:02.890 --> 00:21:05.220
Then you shrink
your outputs one.

00:21:05.220 --> 00:21:08.210
For every scope that it reads,
it outputs a single output.

00:21:08.210 --> 00:21:10.650
So if you have something that
needs to read just one scope

00:21:10.650 --> 00:21:12.650
and something that merge
all the scope together,

00:21:12.650 --> 00:21:14.230
then the order will fail.

00:21:14.230 --> 00:21:17.821
So we need to solve that somehow
in the API at some point.

00:21:17.821 --> 00:21:18.320
OK.

00:21:18.320 --> 00:21:19.970
So that's the Transform API.

00:21:19.970 --> 00:21:22.370
Again, the doc is
there, the Java doc.

00:21:22.370 --> 00:21:23.250
Go look at it.

00:21:23.250 --> 00:21:24.090
Give us feedback.

00:21:24.090 --> 00:21:25.830
The API is marked
as beta right now,

00:21:25.830 --> 00:21:28.410
because we want to
be able to change it.

00:21:28.410 --> 00:21:33.210
Please use it, and let us
know if you run into trouble.

00:21:33.210 --> 00:21:33.710
OK.

00:21:33.710 --> 00:21:37.844
I want to go very quickly
through inspecting your builds.

00:21:37.844 --> 00:21:40.010
We know that this is something
that some people have

00:21:40.010 --> 00:21:40.530
a lot of issues.

00:21:40.530 --> 00:21:41.580
They don't really
understand what's

00:21:41.580 --> 00:21:42.630
going on with their build.

00:21:42.630 --> 00:21:44.480
And so there's actually
a few task in Gradle

00:21:44.480 --> 00:21:45.970
that will lead you to do that.

00:21:45.970 --> 00:21:48.900
The dependencies one
is a standard task.

00:21:48.900 --> 00:21:50.860
It's not provided
by our plug-in.

00:21:50.860 --> 00:21:52.900
It gives you your
actual dependencies.

00:21:52.900 --> 00:21:54.930
So you can see all the
transitive dependencies

00:21:54.930 --> 00:21:55.480
and all of that.

00:21:55.480 --> 00:21:57.938
It has some interesting features
like showing you which one

00:21:57.938 --> 00:22:00.592
gets promoted to a new version.

00:22:00.592 --> 00:22:02.800
Just because you have two
version of it in your graph

00:22:02.800 --> 00:22:05.350
and one is higher than the
other one, well, in the path

00:22:05.350 --> 00:22:07.010
that lower, you
will still see that.

00:22:07.010 --> 00:22:08.750
Even though it says
23.0.1, it's actually

00:22:08.750 --> 00:22:13.520
using 23.1.1, because somewhere
else, you do depend on 23.1.1.

00:22:13.520 --> 00:22:15.239
And then if you have
multiple version

00:22:15.239 --> 00:22:16.780
of the same dependency
in your graph,

00:22:16.780 --> 00:22:17.990
so it will show that to you.

00:22:17.990 --> 00:22:20.660
So for example, here,
support-v4 is used twice.

00:22:20.660 --> 00:22:23.510
And so the first time, it shows
you it's transitive dependency.

00:22:23.510 --> 00:22:25.260
The second time, there's
a small asterisk saying,

00:22:25.260 --> 00:22:26.890
hey, you know, you've
seen that before.

00:22:26.890 --> 00:22:28.973
And each one show you the
transitive dependencies.

00:22:28.973 --> 00:22:32.490
So that's what that
little asterisk mean.

00:22:32.490 --> 00:22:35.550
Now, this will show you
per configuration object.

00:22:35.550 --> 00:22:38.360
And if you build your
debug variant, for example,

00:22:38.360 --> 00:22:40.625
we actually take the
compile configuration,

00:22:40.625 --> 00:22:42.700
we take the debug
compile configuration,

00:22:42.700 --> 00:22:45.370
and we kind of put them
together, and resolve them

00:22:45.370 --> 00:22:46.500
at one, right?

00:22:46.500 --> 00:22:49.610
So even though here it's
the compile configuration

00:22:49.610 --> 00:22:54.130
and we're resolving to
support annotation 23.1.1, if,

00:22:54.130 --> 00:22:56.730
in debug compile,
I'm using 24, then

00:22:56.730 --> 00:22:58.030
ultimately, it will use 24.

00:22:58.030 --> 00:23:01.490
So you really want to look at it
at the variant level globally.

00:23:01.490 --> 00:23:03.550
And so we have these
Android dependencies task

00:23:03.550 --> 00:23:04.490
that does just that.

00:23:04.490 --> 00:23:07.430
It's at the global-- you
know, that debut here

00:23:07.430 --> 00:23:10.100
is actually a full variant.

00:23:10.100 --> 00:23:11.700
So you can use that.

00:23:11.700 --> 00:23:13.550
We have one for sourceSets.

00:23:13.550 --> 00:23:15.010
So I know that
sometime developers

00:23:15.010 --> 00:23:15.750
are adding sourceSets.

00:23:15.750 --> 00:23:18.470
I'm not sure whether or not it's
actually adding the source sets

00:23:18.470 --> 00:23:20.260
and not knowing which
are the folders.

00:23:20.260 --> 00:23:21.470
Just look at it.

00:23:21.470 --> 00:23:23.260
And then for each, you
see the source set,

00:23:23.260 --> 00:23:25.520
you see the actual compile
configuration associated

00:23:25.520 --> 00:23:28.069
with it, you see
the actual source

00:23:28.069 --> 00:23:29.485
set object that
you can manipulate

00:23:29.485 --> 00:23:30.700
in your build.gradle.

00:23:30.700 --> 00:23:32.600
So it's very convenient.

00:23:32.600 --> 00:23:36.184
And then, finally, we have
the report signing task.

00:23:36.184 --> 00:23:38.100
If you're configuring
your signing through it,

00:23:38.100 --> 00:23:40.190
you can just do that
report you have.

00:23:40.190 --> 00:23:42.310
If you provide it with
a password somehow,

00:23:42.310 --> 00:23:43.930
then we can show
the fingerprint.

00:23:43.930 --> 00:23:45.230
That can be useful.

00:23:45.230 --> 00:23:46.846
And things like that.

00:23:46.846 --> 00:23:47.690
All right.

00:23:47.690 --> 00:23:49.450
And with that-- thank you.

00:23:49.450 --> 00:23:49.950
[INAUDIBLE]

00:23:49.950 --> 00:23:50.991
JEROME DOCHEZ: All right.

00:23:50.991 --> 00:23:53.240
So let's talk a little
bit about instant run.

00:23:53.240 --> 00:23:55.810
I'm not going to give a very
deep, technical description

00:23:55.810 --> 00:23:56.980
of how it works.

00:23:56.980 --> 00:23:59.410
But I think it's important
that you understand

00:23:59.410 --> 00:24:01.530
some of its concepts,
because it may

00:24:01.530 --> 00:24:04.440
impact you doing your
iterative development cycles.

00:24:04.440 --> 00:24:06.809
So what happened
with instant run

00:24:06.809 --> 00:24:08.850
is that you start with a
class that you've loaded

00:24:08.850 --> 00:24:10.100
inside your virtual machine.

00:24:10.100 --> 00:24:13.490
And that class has many fields
and a couple of methods.

00:24:13.490 --> 00:24:14.340
It's loaded.

00:24:14.340 --> 00:24:16.410
And as your
application is running,

00:24:16.410 --> 00:24:19.230
most likely, you start having
instances of that class around.

00:24:19.230 --> 00:24:20.510
And this has been created.

00:24:20.510 --> 00:24:22.000
At that point, your
application is running.

00:24:22.000 --> 00:24:24.458
But you realize that it is not
running the way you want it.

00:24:24.458 --> 00:24:27.260
So you go back to
the ID, and you

00:24:27.260 --> 00:24:29.670
start writing code to
change the behavior

00:24:29.670 --> 00:24:31.140
of that particular class.

00:24:31.140 --> 00:24:33.200
Once you hit the
button, insert run,

00:24:33.200 --> 00:24:35.560
we're going to be compiling
just this particular class.

00:24:35.560 --> 00:24:37.726
We're going to be dexing
just this particular class.

00:24:37.726 --> 00:24:40.325
And we're going to be delivering
just this particular classes

00:24:40.325 --> 00:24:40.950
to the runtime.

00:24:40.950 --> 00:24:42.780
So that's why it's super fast.

00:24:42.780 --> 00:24:44.890
So at the runtime
level, we're going

00:24:44.890 --> 00:24:46.490
to create a new class loader.

00:24:46.490 --> 00:24:48.031
And in that class
loader, we're going

00:24:48.031 --> 00:24:51.560
to load what we call
the override class.

00:24:51.560 --> 00:24:54.900
So first thing to realize is
that we never actually reload

00:24:54.900 --> 00:24:55.695
the Foo class.

00:24:55.695 --> 00:24:58.610
The Foo class has
only been loaded once.

00:24:58.610 --> 00:25:01.190
And it will be
always loaded once.

00:25:01.190 --> 00:25:03.680
Never reloaded.

00:25:03.680 --> 00:25:06.370
Instead, it would be loading as
many override class as we want,

00:25:06.370 --> 00:25:07.930
because we use a
new class loader.

00:25:07.930 --> 00:25:10.705
If you continue writing
more code in this Foo class,

00:25:10.705 --> 00:25:13.080
we'll just ditch the previous
version of the class loader

00:25:13.080 --> 00:25:15.210
with this override
version, and we'll

00:25:15.210 --> 00:25:18.692
have a new one coming in
place replacing the Foo.

00:25:18.692 --> 00:25:20.400
So once we have set
up this class loader,

00:25:20.400 --> 00:25:22.330
we loaded the Foo
override inside it.

00:25:22.330 --> 00:25:25.040
As you can see, all the
methods of the original class

00:25:25.040 --> 00:25:28.440
have been moved to static
methods on the override,

00:25:28.440 --> 00:25:31.150
and the new code is
actually implemented

00:25:31.150 --> 00:25:33.570
within these methods.

00:25:33.570 --> 00:25:35.560
Now we just have to
do one more thing.

00:25:35.560 --> 00:25:36.770
It's to redirect.

00:25:36.770 --> 00:25:38.890
So we redirect from
the original Foo class

00:25:38.890 --> 00:25:42.511
every method implementation
to the new one.

00:25:42.511 --> 00:25:43.010
OK.

00:25:43.010 --> 00:25:46.111
So that's how it works
at the very high level.

00:25:46.111 --> 00:25:47.360
Very simplistic demonstration.

00:25:47.360 --> 00:25:50.030
But various things
to understand is

00:25:50.030 --> 00:25:52.870
this concept of this original
class, which never changes,

00:25:52.870 --> 00:25:55.494
and the override class, which
we can change many times.

00:25:55.494 --> 00:25:56.910
One other thing
which is important

00:25:56.910 --> 00:26:00.390
again is that if you create more
instances of this Foo class,

00:26:00.390 --> 00:26:02.420
we're going to be using
the original class.

00:26:02.420 --> 00:26:04.140
So the instances
will all be coming

00:26:04.140 --> 00:26:05.329
from the exact same class.

00:26:05.329 --> 00:26:07.370
And it's particularly
important if you store them

00:26:07.370 --> 00:26:08.690
in a collection.

00:26:08.690 --> 00:26:10.630
You want them to be of
the same type, right?

00:26:10.630 --> 00:26:13.390
So again, remember that
the Foo class will remain,

00:26:13.390 --> 00:26:16.290
and all of the instances
that will ever be created

00:26:16.290 --> 00:26:19.320
will be from the original class.

00:26:19.320 --> 00:26:20.850
What does that mean?

00:26:20.850 --> 00:26:25.520
First of all, the override class
will appear in stack traces.

00:26:25.520 --> 00:26:28.350
If you generate a
stack trace, let's say

00:26:28.350 --> 00:26:31.602
another point to exception
was my own favorite bug,

00:26:31.602 --> 00:26:33.810
you will see the override
class in your stack traces.

00:26:33.810 --> 00:26:36.590
So you should not be surprised
to see these classes appearing.

00:26:36.590 --> 00:26:38.750
We could potentially
remove them,

00:26:38.750 --> 00:26:40.690
but we decided that
it's probably better

00:26:40.690 --> 00:26:43.430
to not try to mess too much
with the stack tracing,

00:26:43.430 --> 00:26:44.750
and leave it.

00:26:44.750 --> 00:26:47.608
But you must be aware
that it may appear.

00:26:47.608 --> 00:26:50.000
The more subtle
thing that may happen

00:26:50.000 --> 00:26:55.480
is that new method
calls only generate--

00:26:55.480 --> 00:26:58.570
the new code is only invoked
through new method calls.

00:26:58.570 --> 00:27:02.560
That means that if you are
running a particular method,

00:27:02.560 --> 00:27:05.780
and you have the while loop
or the for loop inside,

00:27:05.780 --> 00:27:09.280
and you change that
class implementation,

00:27:09.280 --> 00:27:12.810
it's not going to change
the thread which is actually

00:27:12.810 --> 00:27:14.980
running the current
version of the code.

00:27:14.980 --> 00:27:17.620
Only when somebody else is
going to code that method will

00:27:17.620 --> 00:27:19.527
the new code kick in.

00:27:19.527 --> 00:27:21.110
So that's particularly
tricky when you

00:27:21.110 --> 00:27:23.120
think about recursive course.

00:27:23.120 --> 00:27:25.254
So at first,
recursive course, say,

00:27:25.254 --> 00:27:26.670
is going to call
itself 100 times.

00:27:26.670 --> 00:27:28.610
The first 10 times
it call itself,

00:27:28.610 --> 00:27:30.790
it's the old version
of the class.

00:27:30.790 --> 00:27:32.900
Now suddenly, you're
going to swap the class,

00:27:32.900 --> 00:27:35.164
and it's going to start
calling the method again.

00:27:35.164 --> 00:27:36.830
And because it's a
new call of a method,

00:27:36.830 --> 00:27:39.246
it's going to kick in into the
new implementation you just

00:27:39.246 --> 00:27:40.100
provided.

00:27:40.100 --> 00:27:42.890
So it's going to call itself
90 times with this new code.

00:27:42.890 --> 00:27:45.470
But then as it will
come back and unwind

00:27:45.470 --> 00:27:47.200
the tail of your
recursive codes,

00:27:47.200 --> 00:27:50.371
it's going to come back to the
original method implementation.

00:27:50.371 --> 00:27:51.870
So you can see here,
this is getting

00:27:51.870 --> 00:27:53.750
into really muddy territory.

00:27:53.750 --> 00:27:57.190
And you should be aware that you
could have surprising results

00:27:57.190 --> 00:28:00.710
when you start missing,
obviously, the implementations.

00:28:00.710 --> 00:28:03.160
The best way, when you think
this kind of stuff happening,

00:28:03.160 --> 00:28:05.317
is just to force a
code restart, which

00:28:05.317 --> 00:28:06.900
is basically you
stop the application,

00:28:06.900 --> 00:28:08.204
and you restart it.

00:28:08.204 --> 00:28:09.870
And don't expect this
is going to happen

00:28:09.870 --> 00:28:12.245
very often, because there's
not that many recursive codes

00:28:12.245 --> 00:28:14.710
or stuff like that
happening in Android world.

00:28:14.710 --> 00:28:18.510
But something you
should be aware of.

00:28:18.510 --> 00:28:20.790
Again, I already touched it.

00:28:20.790 --> 00:28:22.070
Methods are replaced.

00:28:22.070 --> 00:28:25.110
Not really classes are reloaded.

00:28:25.110 --> 00:28:26.290
We do not reload classes.

00:28:26.290 --> 00:28:28.248
I know it sounds like we
are reloading classes,

00:28:28.248 --> 00:28:29.580
but we really are not.

00:28:29.580 --> 00:28:32.010
We are replacing
method implementations.

00:28:32.010 --> 00:28:33.877
So classes are loaded once.

00:28:33.877 --> 00:28:34.710
What does that mean?

00:28:34.710 --> 00:28:39.440
That means the class
initializer is only run once.

00:28:39.440 --> 00:28:41.730
And if you change your
class initializer,

00:28:41.730 --> 00:28:44.260
we will flag this as
an incompatible change.

00:28:44.260 --> 00:28:46.280
As you know by now, the
instant run technology

00:28:46.280 --> 00:28:47.850
is only supporting
basically changing

00:28:47.850 --> 00:28:49.270
method implementations.

00:28:49.270 --> 00:28:52.190
But if you change a field or
if you had to remove a method,

00:28:52.190 --> 00:28:54.232
we will actually restart
the application for you.

00:28:54.232 --> 00:28:55.773
Same thing for the
class initializer.

00:28:55.773 --> 00:28:57.930
If it changes, we will
restart the application,

00:28:57.930 --> 00:29:00.700
because it's an
incompatible change.

00:29:00.700 --> 00:29:03.130
Static variables are
not relationized either.

00:29:03.130 --> 00:29:05.830
So if you have a class and
you have some static variables

00:29:05.830 --> 00:29:08.340
which are not final, and you
started changing their values

00:29:08.340 --> 00:29:11.070
through the code,
suddenly you [INAUDIBLE]

00:29:11.070 --> 00:29:14.250
that particular class
version to a new version

00:29:14.250 --> 00:29:18.350
even if the code that
was actually initializing

00:29:18.350 --> 00:29:19.930
these values in
[INAUDIBLE], it's

00:29:19.930 --> 00:29:22.281
not going to change the
values of those static fields.

00:29:22.281 --> 00:29:22.780
All right?

00:29:22.780 --> 00:29:27.100
So you should not expect
things to be reinitialized.

00:29:27.100 --> 00:29:29.620
Again, the class has
already been loaded.

00:29:29.620 --> 00:29:32.710
It's just going to
continue living its life.

00:29:32.710 --> 00:29:34.810
Same thing for instances.

00:29:34.810 --> 00:29:37.150
You may have already created
instances of the class

00:29:37.150 --> 00:29:39.360
that you are going to update.

00:29:39.360 --> 00:29:41.360
And we are not, like,
destroying those instances

00:29:41.360 --> 00:29:43.120
or trying to extract
their field's values

00:29:43.120 --> 00:29:44.970
and putting them
into some new object.

00:29:44.970 --> 00:29:45.630
No.

00:29:45.630 --> 00:29:47.510
Those instances stays around.

00:29:47.510 --> 00:29:51.100
And the instances fields
remain at the same values

00:29:51.100 --> 00:29:54.130
that your application
has already set them.

00:29:54.130 --> 00:29:56.770
That's also very true, of
course, for singleton objects.

00:29:56.770 --> 00:29:58.530
Again, that's kind
of a situation where

00:29:58.530 --> 00:30:02.584
you could expect or you possibly
would expect that because it's

00:30:02.584 --> 00:30:04.000
a singleton object,
somehow, we're

00:30:04.000 --> 00:30:07.180
going to recreate it with
the new version of the class.

00:30:07.180 --> 00:30:08.190
No, we are not.

00:30:08.190 --> 00:30:10.240
It's going to be the
same singleton object.

00:30:10.240 --> 00:30:12.750
The only difference is that all
of its method implementation

00:30:12.750 --> 00:30:14.830
would be redirected
to the new code.

00:30:14.830 --> 00:30:17.990
So if you are initializing
the fields of your singleton

00:30:17.990 --> 00:30:19.930
object a certain
way, don't expect

00:30:19.930 --> 00:30:23.000
it to be reset just
because you changed

00:30:23.000 --> 00:30:25.880
the constructor in the
new version of the class.

00:30:25.880 --> 00:30:28.910
Sure, the constructor would set
the fields to the new values

00:30:28.910 --> 00:30:30.080
if it was to be executed.

00:30:30.080 --> 00:30:33.010
But because it's a singleton,
it's not going to be executed.

00:30:33.010 --> 00:30:36.210
Therefore, you're going to
get the old field's values.

00:30:36.210 --> 00:30:39.229
So it's important to
understand all of this.

00:30:39.229 --> 00:30:40.770
At the end of the
day, you should not

00:30:40.770 --> 00:30:41.690
worry too much about it.

00:30:41.690 --> 00:30:43.731
But it's possible that
sometimes your application

00:30:43.731 --> 00:30:46.680
does not really behave the
way you think it should go.

00:30:46.680 --> 00:30:50.230
And that's most likely because
maybe the code you've just

00:30:50.230 --> 00:30:53.370
modified does not work well with
the state of the application

00:30:53.370 --> 00:30:53.870
it's in.

00:30:53.870 --> 00:30:57.930
You should just
restart in such cases.

00:30:57.930 --> 00:30:58.990
All right.

00:30:58.990 --> 00:31:01.030
We also want to talk a
little bit about recipes.

00:31:01.030 --> 00:31:03.240
So these are important
things that we would

00:31:03.240 --> 00:31:04.920
like to raise awareness about.

00:31:04.920 --> 00:31:11.330
And the first one is another
way of generating multi-APKs

00:31:11.330 --> 00:31:12.770
which are ABI-specific.

00:31:12.770 --> 00:31:14.890
So in the past, when
you wanted to reduce

00:31:14.890 --> 00:31:17.820
the size of your APKs, one
of the trick was to say,

00:31:17.820 --> 00:31:20.500
I want to have an APK which is
specific to a particular API.

00:31:20.500 --> 00:31:23.260
And I'm only going to be
supporting the 86 in this

00:31:23.260 --> 00:31:25.640
particular case, where I'm
going to be shipping only

00:31:25.640 --> 00:31:29.220
the .so file that are running
for this particular API.

00:31:29.220 --> 00:31:31.570
And in this example,
you could also

00:31:31.570 --> 00:31:35.120
specify that you wanted a full,
which would have the ability

00:31:35.120 --> 00:31:38.990
to run on any possible
devices irrespective

00:31:38.990 --> 00:31:41.580
of its particular API.

00:31:41.580 --> 00:31:44.450
However, it would be,
obviously, a very big APK.

00:31:44.450 --> 00:31:46.580
So in the newer
version, you should not

00:31:46.580 --> 00:31:47.900
use product flavors for that.

00:31:47.900 --> 00:31:50.316
You should use product flavors
to define your applications

00:31:50.316 --> 00:31:53.264
and not how we package
the resulting APK.

00:31:53.264 --> 00:31:54.680
And the new way
of doing things is

00:31:54.680 --> 00:31:59.540
by using these new splits
declarations inside your model,

00:31:59.540 --> 00:32:00.580
inside the DSL.

00:32:00.580 --> 00:32:02.640
And the way to do
that is by either

00:32:02.640 --> 00:32:07.140
using ABI densities or language,
depending on which type of APK

00:32:07.140 --> 00:32:08.004
you'd like.

00:32:08.004 --> 00:32:10.295
And what it's going to generate
in this particular case

00:32:10.295 --> 00:32:11.780
is four APKs.

00:32:11.780 --> 00:32:16.710
Three APKs will be specific to
a particular ABI-- 86, mips.

00:32:16.710 --> 00:32:19.380
And one would be the universal
one again, which contains

00:32:19.380 --> 00:32:24.580
all the possible API SO files.

00:32:24.580 --> 00:32:27.770
This way, you will get a
much smaller APK each time,

00:32:27.770 --> 00:32:29.980
and you do not pollute
your product declaration,

00:32:29.980 --> 00:32:34.460
the product flavor declaration,
as you had to do before.

00:32:34.460 --> 00:32:36.320
Next one is the
Resource Shrinker.

00:32:36.320 --> 00:32:38.650
So for many years,
we've had the ability

00:32:38.650 --> 00:32:41.986
to shrink the code
using ProGuard.

00:32:41.986 --> 00:32:44.360
And that's particularly useful
when you import a library,

00:32:44.360 --> 00:32:48.340
and you may be only using 5%
of the library facilities.

00:32:48.340 --> 00:32:50.320
You don't want to ship
all the code associated

00:32:50.320 --> 00:32:51.069
with that library.

00:32:51.069 --> 00:32:53.404
So you use ProGuard, and you
kind of strip all the code

00:32:53.404 --> 00:32:54.320
that you're not using.

00:32:54.320 --> 00:32:56.420
However, it was not
stripping the resources

00:32:56.420 --> 00:32:59.800
associated with that particular
code that is being stripped.

00:32:59.800 --> 00:33:03.820
So we now have the ability to
have a resource shrinker that

00:33:03.820 --> 00:33:08.010
can piggyback on the
actual program file

00:33:08.010 --> 00:33:10.210
to figure out what are
the class that are really

00:33:10.210 --> 00:33:13.820
necessary for the application
and which are not necessary,

00:33:13.820 --> 00:33:16.500
and make educated
decisions about

00:33:16.500 --> 00:33:18.900
whether or not some
resources are necessary.

00:33:18.900 --> 00:33:22.480
So when you use ProGuard to
release your application,

00:33:22.480 --> 00:33:25.020
you should most likely
always shrink your resources.

00:33:25.020 --> 00:33:27.840
And it's going to result
in a much smaller APK

00:33:27.840 --> 00:33:32.450
size, which is great for users.

00:33:32.450 --> 00:33:34.220
Next one, I think,
is back to Michal.

00:33:34.220 --> 00:33:34.860
MICHAL BENDOWSKI: Yep.

00:33:34.860 --> 00:33:35.290
JEROME DOCHEZ: Thank you.

00:33:35.290 --> 00:33:36.670
MICHAL BENDOWSKI: Thank you.

00:33:36.670 --> 00:33:37.650
OK.

00:33:37.650 --> 00:33:40.610
This one most of you
probably already figured out.

00:33:40.610 --> 00:33:43.260
But let me just talk
about it real quick.

00:33:43.260 --> 00:33:45.240
If your project has
multiple subprojects,

00:33:45.240 --> 00:33:47.560
it's a very good idea to
share the same versions

00:33:47.560 --> 00:33:50.430
of dependencies,
and your SDK levels,

00:33:50.430 --> 00:33:52.850
and tools version between
all those projects.

00:33:52.850 --> 00:33:55.140
So the way we recommend you
do it is using the Gradle

00:33:55.140 --> 00:33:56.900
extensions mechanism.

00:33:56.900 --> 00:33:59.480
That is use the ext
block in your root,

00:33:59.480 --> 00:34:01.290
top-level Gradle file.

00:34:01.290 --> 00:34:03.730
And then inside
this block, you can

00:34:03.730 --> 00:34:06.820
create properties to call the
constants you want to share.

00:34:06.820 --> 00:34:10.010
You may want to use the Groovy
syntax for defining maps.

00:34:10.010 --> 00:34:11.980
So like I did here for deps.

00:34:11.980 --> 00:34:14.690
And then you can reference those
values using the root project

00:34:14.690 --> 00:34:19.481
prefix in all your
other build files.

00:34:19.481 --> 00:34:19.980
OK.

00:34:19.980 --> 00:34:22.294
Another tricky part
that sometimes people

00:34:22.294 --> 00:34:25.940
are surprised about is the
scoping roles in build files.

00:34:25.940 --> 00:34:28.989
So as much as Groovy
scoping has its edge cases,

00:34:28.989 --> 00:34:31.900
the basics are the same
as you know from Java.

00:34:31.900 --> 00:34:35.431
So the dependencies block in
the current block-- and Xav

00:34:35.431 --> 00:34:36.889
mentioned things
are actually a bit

00:34:36.889 --> 00:34:38.097
different in the new plug-in.

00:34:38.097 --> 00:34:40.250
But in the current plug-in,
the dependencies block

00:34:40.250 --> 00:34:43.810
is a top-level property of
the overall project context.

00:34:43.810 --> 00:34:47.010
So the fact that you reference
it from some nested call

00:34:47.010 --> 00:34:49.159
deep within the Android
block doesn't really

00:34:49.159 --> 00:34:50.920
change the meaning
of the call, so

00:34:50.920 --> 00:34:54.989
that even if you would expect
this call on the screen

00:34:54.989 --> 00:34:58.600
to add a dependency only to the
given flavor, the free flavor,

00:34:58.600 --> 00:35:00.350
it doesn't actually do that.

00:35:00.350 --> 00:35:03.220
What you should be doing instead
is put the dependencies block

00:35:03.220 --> 00:35:05.100
at the very bottom
at the top level

00:35:05.100 --> 00:35:06.620
to make it clear
what's going on.

00:35:06.620 --> 00:35:09.420
And if you want to add a
dependency only to a given

00:35:09.420 --> 00:35:12.560
flavor, you should use
the specific configuration

00:35:12.560 --> 00:35:15.210
that we have for this flavor.

00:35:15.210 --> 00:35:15.710
OK.

00:35:15.710 --> 00:35:17.222
Let's talk about
flavors in general.

00:35:17.222 --> 00:35:19.680
I hope you already know that
flavors are a good way for you

00:35:19.680 --> 00:35:21.880
to create different
variants of your application

00:35:21.880 --> 00:35:23.480
other than build types.

00:35:23.480 --> 00:35:25.030
In the next talk,
Jose may actually

00:35:25.030 --> 00:35:26.990
talk about how you can
use flavors for testing.

00:35:29.940 --> 00:35:32.180
Like, what should you do if
you want to differentiate

00:35:32.180 --> 00:35:34.614
your app in more way than one?

00:35:34.614 --> 00:35:36.280
So let's imagine you
have a free version

00:35:36.280 --> 00:35:37.990
of your app and the
premium version,

00:35:37.990 --> 00:35:41.220
but you also want to sell
it in blue and red flavors,

00:35:41.220 --> 00:35:43.850
because you believe that will
actually increase the sales.

00:35:43.850 --> 00:35:47.150
So instead of creating all
the combinations manually,

00:35:47.150 --> 00:35:50.360
what we suggest you do is
use the built-in support

00:35:50.360 --> 00:35:54.070
for flavor dimensions that you
have in the Android plug-in.

00:35:54.070 --> 00:35:56.790
So you can define one-name
dimensions like price and color

00:35:56.790 --> 00:35:57.700
in this case.

00:35:57.700 --> 00:36:00.560
Then for every
flavor, you specify

00:36:00.560 --> 00:36:02.820
which dimension this
flavor belongs to.

00:36:02.820 --> 00:36:04.990
And the additional
advantage of doing it

00:36:04.990 --> 00:36:08.630
this way is that you get
dedicated source sets for,

00:36:08.630 --> 00:36:11.960
for example, red-only resources,
and blue-only resources,

00:36:11.960 --> 00:36:14.920
and premium-only code that
is shared between the premium

00:36:14.920 --> 00:36:17.250
red and premium blue variants.

00:36:17.250 --> 00:36:19.951
So that's very convenient.

00:36:19.951 --> 00:36:20.450
OK.

00:36:20.450 --> 00:36:25.580
But what happens if not all
the combinations of build

00:36:25.580 --> 00:36:27.410
types and flavors make sense?

00:36:27.410 --> 00:36:29.240
At the start of
the presentation,

00:36:29.240 --> 00:36:31.720
I mentioned a
development-only flavor.

00:36:31.720 --> 00:36:33.560
It probably doesn't
make much sense

00:36:33.560 --> 00:36:36.020
to ever combine it with
a release build type,

00:36:36.020 --> 00:36:38.660
because we never really want
to distribute the development

00:36:38.660 --> 00:36:39.550
variant.

00:36:39.550 --> 00:36:43.420
So what we can do is use
the variant filter method

00:36:43.420 --> 00:36:45.430
on the Android
block, which allows

00:36:45.430 --> 00:36:48.320
you to register a closure.

00:36:48.320 --> 00:36:51.620
And the closure will be called
for every about-to-be-created

00:36:51.620 --> 00:36:54.804
variant and will be passed
a variant filter object.

00:36:54.804 --> 00:36:56.220
You can use this
object to inspect

00:36:56.220 --> 00:36:59.860
the build types and the flavors
of the variant in question.

00:36:59.860 --> 00:37:02.190
And you can also set
the Ignore flag on it

00:37:02.190 --> 00:37:05.530
to indicate that this particular
combination should be skipped.

00:37:05.530 --> 00:37:07.410
So you can think of
the variant filter

00:37:07.410 --> 00:37:09.760
object of an instance
of such an interface

00:37:09.760 --> 00:37:11.760
when there's one setter
for the Ignore flag

00:37:11.760 --> 00:37:15.770
and there are getters for build
types, flavors, and the shared

00:37:15.770 --> 00:37:17.920
settings from the
default config shared

00:37:17.920 --> 00:37:20.021
between all the variants.

00:37:20.021 --> 00:37:20.520
OK.

00:37:20.520 --> 00:37:21.960
Let's talk about
vector drawables,

00:37:21.960 --> 00:37:25.180
which is a feature
we've added in 1.5.

00:37:25.180 --> 00:37:27.010
So what vector
drawable support does

00:37:27.010 --> 00:37:30.610
at build time is whenever we
find an Android vector drawable

00:37:30.610 --> 00:37:33.520
XML file in your
Drawables directory,

00:37:33.520 --> 00:37:35.640
we will rename this
file to be within

00:37:35.640 --> 00:37:38.620
the anydpi_v21 directory.

00:37:38.620 --> 00:37:42.050
And we will also generate
a number of PNG images, one

00:37:42.050 --> 00:37:46.200
for each density, for all
the devices to pick up.

00:37:46.200 --> 00:37:49.170
You can control the set of
densities that we generate,

00:37:49.170 --> 00:37:52.930
so if you don't want to package
load dpi images in your APK,

00:37:52.930 --> 00:37:54.710
you can choose to do so.

00:37:54.710 --> 00:37:56.360
This setting is per flavor.

00:37:56.360 --> 00:37:59.770
So you can have a default set
of densities in default config

00:37:59.770 --> 00:38:02.780
and then override it
for a particular flavor.

00:38:02.780 --> 00:38:05.900
And you can also set the
set of generated densities

00:38:05.900 --> 00:38:11.501
to an empty list set, which will
disable the feature altogether.

00:38:11.501 --> 00:38:12.000
OK.

00:38:12.000 --> 00:38:14.230
Lastly, since we have
some more time left,

00:38:14.230 --> 00:38:17.272
let's just mention
real quick BuildConfig.

00:38:17.272 --> 00:38:19.480
BuildConfig is a class that
we generate at build time

00:38:19.480 --> 00:38:21.580
for each and every variant.

00:38:21.580 --> 00:38:25.350
You can use it to
inspect which build

00:38:25.350 --> 00:38:28.020
type and flavor were used to
actually compile your given

00:38:28.020 --> 00:38:28.870
variant.

00:38:28.870 --> 00:38:31.950
You can use it to, at runtime,
execute different code,

00:38:31.950 --> 00:38:34.080
depending on the given flavor.

00:38:34.080 --> 00:38:36.790
So for example, you may want
to write an If statement

00:38:36.790 --> 00:38:39.640
that checks if
flavor is premium.

00:38:39.640 --> 00:38:43.440
And you can also add additional
fields to the BuildConfig class

00:38:43.440 --> 00:38:46.480
by using a BuildConfig
field method on build

00:38:46.480 --> 00:38:48.510
types [INAUDIBLE] flavors.

00:38:48.510 --> 00:38:50.210
So in this case,
if I really want

00:38:50.210 --> 00:38:53.600
to hard-code the build date
into my BuildConfig class,

00:38:53.600 --> 00:38:54.204
I can do it.

00:38:54.204 --> 00:38:55.870
As I mentioned at the
start, I will only

00:38:55.870 --> 00:38:57.420
do it for the release builds.

00:38:57.420 --> 00:39:00.460
So in the release builds,
I will put a string field

00:39:00.460 --> 00:39:02.750
called BUILD_DATE in my class.

00:39:02.750 --> 00:39:09.120
The values are pasted as is
into the buildConfig Java source

00:39:09.120 --> 00:39:10.720
file, which means
you have to make

00:39:10.720 --> 00:39:14.430
sure the quotes are in place.

00:39:14.430 --> 00:39:16.960
And here, I assume there is a
formatTime function somewhere

00:39:16.960 --> 00:39:18.162
in the build script.

00:39:18.162 --> 00:39:20.370
So that will allow me to
actually reference the build

00:39:20.370 --> 00:39:21.860
date in my release builds.

00:39:21.860 --> 00:39:26.880
For debug builds, I want to
hard-code a constant value,

00:39:26.880 --> 00:39:29.380
so that my builds are
actually up to date.

00:39:29.380 --> 00:39:31.290
You can imagine that
if formatTime actually

00:39:31.290 --> 00:39:34.300
changed every second, my builds
would never be up to date,

00:39:34.300 --> 00:39:39.000
because every time I run Gradle,
BuildConfig source would be

00:39:39.000 --> 00:39:41.160
different, which means I
would have to compile it,

00:39:41.160 --> 00:39:43.535
which means I would have to
redex your entire application

00:39:43.535 --> 00:39:45.895
every time just because
this value changed,

00:39:45.895 --> 00:39:48.020
which is why we recommend
you do this kind of stuff

00:39:48.020 --> 00:39:51.370
only for release builds,
never debug builds.

00:39:51.370 --> 00:39:53.990
And if you need to, you can
also define the resValues, which

00:39:53.990 --> 00:40:00.330
will do the same thing, but it
would put the values as a value

00:40:00.330 --> 00:40:02.541
resource, as a string resource.

00:40:02.541 --> 00:40:03.041
OK?

00:40:03.041 --> 00:40:03.541
Yeah?

00:40:03.541 --> 00:40:05.980
That's it and that's all
we have for you today.

00:40:05.980 --> 00:40:07.934
Let's go into the Q&amp;A session.

00:40:07.934 --> 00:40:09.850
XAVIER DUCROHET: There's
two mics in the back.

00:40:09.850 --> 00:40:12.760
If you want to ask a
question, please go there.

00:40:12.760 --> 00:40:15.586
We have time probably for
just a handful of them.

00:40:15.586 --> 00:40:17.032
Yup.

00:40:17.032 --> 00:40:20.190
AUDIENCE: I have a question
about shrink resources.

00:40:20.190 --> 00:40:25.090
I see my PNG files are
not in the build APK.

00:40:25.090 --> 00:40:28.140
But the IDs are still in
the [INAUDIBLE] Java file.

00:40:28.140 --> 00:40:33.820
And it's causing wave
crashes on Samsung devices.

00:40:33.820 --> 00:40:38.940
And I saw a solution was
to replace those PNG files

00:40:38.940 --> 00:40:42.410
with, like, one-pixel resource.

00:40:42.410 --> 00:40:45.694
Can you say something about
that, about shrink resources?

00:40:45.694 --> 00:40:47.610
XAVIER DUCROHET: So the
way the shrinker works

00:40:47.610 --> 00:40:51.130
is that it looks for code
that uses those IDs, right?

00:40:51.130 --> 00:40:55.490
But it is not
removing the R class.

00:40:55.490 --> 00:40:58.380
I would be surprised
why, on some devices,

00:40:58.380 --> 00:41:00.800
they actually-- like,
if your code does not

00:41:00.800 --> 00:41:04.500
reference that ID-- and we're
trying to be very conservative.

00:41:04.500 --> 00:41:06.350
There's some cases
where we don't

00:41:06.350 --> 00:41:08.590
remove stuff that could be
removed, because we're not

00:41:08.590 --> 00:41:09.140
sure.

00:41:09.140 --> 00:41:09.810
It's difficult, right?

00:41:09.810 --> 00:41:10.800
We just look at the bytecode.

00:41:10.800 --> 00:41:12.050
We don't know the actual call.

00:41:12.050 --> 00:41:13.650
We just say, hey, 42.

00:41:13.650 --> 00:41:15.970
OK, maybe that's a resource ID.

00:41:15.970 --> 00:41:19.050
So when we're sure that that
ID is not available anywhere,

00:41:19.050 --> 00:41:20.090
we remove it.

00:41:20.090 --> 00:41:23.840
So I'm not sure why that would
still be called on some device,

00:41:23.840 --> 00:41:24.362
you said?

00:41:24.362 --> 00:41:25.320
AUDIENCE: I don't know.

00:41:25.320 --> 00:41:26.305
[INTERPOSING VOICES]

00:41:26.305 --> 00:41:27.930
AUDIENCE: There is
bug report for that.

00:41:27.930 --> 00:41:29.150
So.

00:41:29.150 --> 00:41:31.066
JEROME DOCHEZ: I seem
to remember that Samsung

00:41:31.066 --> 00:41:33.540
was pre-caching and the IDE
would find any application

00:41:33.540 --> 00:41:35.770
something like that.

00:41:35.770 --> 00:41:36.270
So.

00:41:36.270 --> 00:41:37.625
XAVIER DUCROHET: OK.

00:41:37.625 --> 00:41:40.080
Yeah, I don't have a good
solution for you, in that case.

00:41:40.080 --> 00:41:41.580
JEROME DOCHEZ: I think the
good solution for now is shrink

00:41:41.580 --> 00:41:42.896
resource is false. [LAUGHS]

00:41:42.896 --> 00:41:43.520
AUDIENCE: Yeah.

00:41:43.520 --> 00:41:44.436
XAVIER DUCROHET: Yeah.

00:41:44.436 --> 00:41:48.305
I mean, we could also rewrite
the R class to remove things.

00:41:48.305 --> 00:41:50.430
The thing, also, that you
are doing if you are just

00:41:50.430 --> 00:41:52.800
removing the assets, right, we
are not actually removing them

00:41:52.800 --> 00:41:53.590
from the Resource table.

00:41:53.590 --> 00:41:54.510
So it's possible that
would be a problem.

00:41:54.510 --> 00:41:54.606
JEROME DOCHEZ: Right.

00:41:54.606 --> 00:41:56.064
So I thought there
was a mode where

00:41:56.064 --> 00:42:01.290
we'd put the smallest possible
PNG to replace the actual one,

00:42:01.290 --> 00:42:03.640
so that Samsung would be
happy, it would find it.

00:42:03.640 --> 00:42:06.941
So but it still doesn't work?

00:42:06.941 --> 00:42:09.440
AUDIENCE: I don't believe that
thing is happening right now.

00:42:09.440 --> 00:42:09.860
So.

00:42:09.860 --> 00:42:10.165
XAVIER DUCROHET: OK.

00:42:10.165 --> 00:42:11.950
We should talk about
that after [INAUDIBLE].

00:42:11.950 --> 00:42:12.260
JEROME DOCHEZ: We
should talk about it,

00:42:12.260 --> 00:42:14.051
because I thought it
was already happening.

00:42:14.051 --> 00:42:15.150
XAVIER DUCROHET: OK.

00:42:15.150 --> 00:42:19.390
AUDIENCE: Is there
any development

00:42:19.390 --> 00:42:25.020
on native dependencies that
would actually also bundle

00:42:25.020 --> 00:42:27.440
headers in a case of
native dependencies

00:42:27.440 --> 00:42:32.737
that would be deployed to
MVN repository, for example?

00:42:32.737 --> 00:42:33.570
XAVIER DUCROHET: No.

00:42:33.570 --> 00:42:34.977
I actually don't know.

00:42:34.977 --> 00:42:37.060
That's probably more a
question for Gradle, right?

00:42:37.060 --> 00:42:41.820
Like, if you have a module that
only outputs a .so-- and I know

00:42:41.820 --> 00:42:46.340
you can't have headers, because
the intermodule dependency

00:42:46.340 --> 00:42:49.062
supports that at
the Gradle level.

00:42:49.062 --> 00:42:51.520
But I don't know what happened
if you tried to publish that

00:42:51.520 --> 00:42:53.010
to any sort of repository.

00:42:53.010 --> 00:42:55.687
You would have to check
with Gradle itself.

00:42:55.687 --> 00:42:56.770
I've seen hands somewhere.

00:42:56.770 --> 00:42:59.570
So yeah.

00:42:59.570 --> 00:43:03.340
AUDIENCE: Is it possible to
debug why instant run decided

00:43:03.340 --> 00:43:05.600
not to do an instant run
on a particular instance--

00:43:05.600 --> 00:43:08.130
like, if you changed a
field, it can tell you,

00:43:08.130 --> 00:43:10.790
like, it's because you
changed this field?

00:43:10.790 --> 00:43:11.620
JEROME DOCHEZ: Yes.

00:43:11.620 --> 00:43:15.026
If you add a field
and the instant run

00:43:15.026 --> 00:43:16.400
decided that it
needs to restart,

00:43:16.400 --> 00:43:17.530
is that what you're asking?

00:43:17.530 --> 00:43:17.890
AUDIENCE: Yeah.

00:43:17.890 --> 00:43:18.800
But I was just
wondering, is there

00:43:18.800 --> 00:43:21.450
some sort of logging that'll
tell you why it didn't run?

00:43:21.450 --> 00:43:22.241
JEROME DOCHEZ: Yes.

00:43:22.241 --> 00:43:24.160
The IDE will tell
you, application

00:43:24.160 --> 00:43:26.185
restarted because
you added a field

00:43:26.185 --> 00:43:28.060
or because the static
initializer [INAUDIBLE]

00:43:28.060 --> 00:43:29.100
because we added a method.

00:43:29.100 --> 00:43:29.800
It will tell you.

00:43:29.800 --> 00:43:30.770
XAVIER DUCROHET: Is that
a balloon, or is that--

00:43:30.770 --> 00:43:32.020
JEROME DOCHEZ: It's a balloon.

00:43:32.020 --> 00:43:34.230
When you run, there will be
a balloon that tells you,

00:43:34.230 --> 00:43:35.665
restarted because of--

00:43:35.665 --> 00:43:38.040
XAVIER DUCROHET: Yeah.

00:43:38.040 --> 00:43:41.340
AUDIENCE: Is there a way,
when you build a debug build,

00:43:41.340 --> 00:43:44.390
to make it have a different
package name as a release

00:43:44.390 --> 00:43:44.946
build?

00:43:44.946 --> 00:43:45.820
XAVIER DUCROHET: Yes.

00:43:45.820 --> 00:43:48.800
In build type, there is
something called application ID

00:43:48.800 --> 00:43:49.900
suffix.

00:43:49.900 --> 00:43:53.000
So if you do any
suffix, it appends that

00:43:53.000 --> 00:43:54.580
to your regular package name.

00:43:54.580 --> 00:43:57.462
So if you put .debug, then the
debug build will contain that

00:43:57.462 --> 00:43:58.170
new package name.

00:43:58.170 --> 00:44:00.710
And you can install it side by
side with the release package

00:44:00.710 --> 00:44:01.392
if you want.

00:44:01.392 --> 00:44:03.600
AUDIENCE: If I have, like,
custom views in XML files,

00:44:03.600 --> 00:44:05.327
do those get upgraded?

00:44:05.327 --> 00:44:06.160
XAVIER DUCROHET: No.

00:44:06.160 --> 00:44:10.370
Then you would have to make a
copy of that particular layout,

00:44:10.370 --> 00:44:12.550
put it in the source
debug [INAUDIBLE] folder,

00:44:12.550 --> 00:44:14.550
so that you would have a
custom version of that.

00:44:14.550 --> 00:44:16.210
We know that it's
something that people

00:44:16.210 --> 00:44:17.585
want to have
placeholder in those

00:44:17.585 --> 00:44:18.876
and to replace them on the fly.

00:44:18.876 --> 00:44:20.989
It's something we will
probably do at some point.

00:44:20.989 --> 00:44:21.530
AUDIENCE: OK.

00:44:21.530 --> 00:44:22.134
Thank you.

00:44:22.134 --> 00:44:24.300
XAVIER DUCROHET: I think
we are running out of time.

00:44:24.300 --> 00:44:26.450
We will be at the office
hours all afternoon,

00:44:26.450 --> 00:44:28.280
so feel free to
come and talk to us.

00:44:28.280 --> 00:44:30.154
And a fireside chat
also this afternoon

00:44:30.154 --> 00:44:31.320
if you want to ask question.

00:44:31.320 --> 00:44:32.110
Thank you.

00:44:32.110 --> 00:44:35.160
[MUSIC PLAYING]

