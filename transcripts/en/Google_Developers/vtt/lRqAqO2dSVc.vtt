WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:07.824
[MUSIC PLAYING]

00:00:17.610 --> 00:00:18.700
JAREK WILKIEWICZ: Hello,
and welcome to

00:00:18.700 --> 00:00:20.120
YouTube Develops Live.

00:00:20.120 --> 00:00:22.760
My name is Jarek Wilkiewicz, and
as always, we have a very

00:00:22.760 --> 00:00:24.490
exciting show for you today.

00:00:24.490 --> 00:00:27.740
I am honored to introduce
my guest today, Max

00:00:27.740 --> 00:00:28.140
Kanat-Alexander.

00:00:28.140 --> 00:00:29.430
How are you doing, Max?

00:00:29.430 --> 00:00:29.970
MAX KANAT-ALEXANDER: Great.

00:00:29.970 --> 00:00:30.760
Thanks, Jarek.

00:00:30.760 --> 00:00:34.290
JAREK WILKIEWICZ: And Max will
talk about code simplicity.

00:00:34.290 --> 00:00:38.640
You might know that he's the
author of a book named aptly

00:00:38.640 --> 00:00:41.580
"Code Simplicity," published
by O'Reilly.

00:00:41.580 --> 00:00:42.950
When did the book come out?

00:00:42.950 --> 00:00:44.010
MAX KANAT-ALEXANDER:
Last April.

00:00:44.010 --> 00:00:44.800
JAREK WILKIEWICZ: OK, great.

00:00:44.800 --> 00:00:47.810
So if you haven't read the book,
today Max will give you

00:00:47.810 --> 00:00:49.980
an overview of what
it is about.

00:00:49.980 --> 00:00:54.330
And hopefully, you will be able
to learn more after this

00:00:54.330 --> 00:00:59.590
talk, and reach out and get the
book to get the details.

00:00:59.590 --> 00:01:02.520
So let's talk a little
bit about you, Max.

00:01:02.520 --> 00:01:04.410
So can you tell me what
got you into software

00:01:04.410 --> 00:01:05.670
in the first place?

00:01:05.670 --> 00:01:08.220
MAX KANAT-ALEXANDER:
Yeah, sure.

00:01:08.220 --> 00:01:11.440
I think that it started
when I was younger.

00:01:11.440 --> 00:01:13.570
And I think like a lot of
programmers, probably when I

00:01:13.570 --> 00:01:16.700
was in elementary school, they
sat me down in front of a

00:01:16.700 --> 00:01:18.230
machine with Logo.

00:01:18.230 --> 00:01:19.090
JAREK WILKIEWICZ:
I remember Logo.

00:01:19.090 --> 00:01:20.170
MAX KANAT-ALEXANDER: Yeah.

00:01:20.170 --> 00:01:22.340
Most programmers that I talk
to, actually they started

00:01:22.340 --> 00:01:25.640
either with Logo or with
HyperCard, because it was a

00:01:25.640 --> 00:01:27.860
system that allowed you
to immediately see the

00:01:27.860 --> 00:01:29.150
results of your work.

00:01:29.150 --> 00:01:31.990
And I think, to this day, for
most programmers, the magic of

00:01:31.990 --> 00:01:35.330
programming is asking the
computer to do something and

00:01:35.330 --> 00:01:37.210
then seeing it actually
happen.

00:01:37.210 --> 00:01:39.470
And I, to this day think,
that's actually a really

00:01:39.470 --> 00:01:43.220
important experience for brand
new programmers to have.

00:01:43.220 --> 00:01:45.590
If you load them down for their
very first experience

00:01:45.590 --> 00:01:48.470
with a bunch of theory and
don't let them actually

00:01:48.470 --> 00:01:50.740
accomplish something or give
them very complex tools to

00:01:50.740 --> 00:01:53.650
start off with, then people
don't become as interested in

00:01:53.650 --> 00:01:54.020
programming.

00:01:54.020 --> 00:01:56.660
But when you give somebody that
little turtle and you

00:01:56.660 --> 00:01:58.570
just be like, hey, here's some
commands you can use to move

00:01:58.570 --> 00:02:00.380
the turtle around the screen
and it draws lines.

00:02:00.380 --> 00:02:02.240
Then you're like, oh my
gosh, this is magical.

00:02:02.240 --> 00:02:03.980
Then people suddenly
interested in being

00:02:03.980 --> 00:02:04.190
programmers.

00:02:04.190 --> 00:02:04.440
JAREK WILKIEWICZ: Cool.

00:02:04.440 --> 00:02:08.120
So it looks like got into
software because of a turtle.

00:02:08.120 --> 00:02:08.850
MAX KANAT-ALEXANDER:
Yeah, I think so.

00:02:08.850 --> 00:02:10.226
JAREK WILKIEWICZ: So tell
me more about-- what

00:02:10.226 --> 00:02:11.620
do you do at YouTube?

00:02:11.620 --> 00:02:12.870
MAX KANAT-ALEXANDER: Sure.

00:02:12.870 --> 00:02:18.930
So I am the technical lead for
developer productivity, which

00:02:18.930 --> 00:02:22.380
means that I am in charge of the
tools that the developers

00:02:22.380 --> 00:02:23.540
use internally.

00:02:23.540 --> 00:02:27.350
I'm in charge of promoting best
practices throughout the

00:02:27.350 --> 00:02:28.600
organization.

00:02:28.600 --> 00:02:31.270
And basically, just
unblocking people.

00:02:31.270 --> 00:02:34.350
In a technical sense, making
sure that everything is happy

00:02:34.350 --> 00:02:39.050
and that code is simple and easy
to work with, and those

00:02:39.050 --> 00:02:39.770
sorts of things.

00:02:39.770 --> 00:02:40.070
JAREK WILKIEWICZ: OK.

00:02:40.070 --> 00:02:42.895
So in a nutshell, making sure
that YouTube will work as

00:02:42.895 --> 00:02:43.380
advertised?

00:02:43.380 --> 00:02:44.330
MAX KANAT-ALEXANDER: Yes.

00:02:44.330 --> 00:02:45.930
Or at least making sure that
YouTube will work as

00:02:45.930 --> 00:02:48.390
advertised in the future.

00:02:48.390 --> 00:02:49.250
JAREK WILKIEWICZ: OK.

00:02:49.250 --> 00:02:53.190
Yeah, I know this is a great
segue to your presentation,

00:02:53.190 --> 00:02:55.860
because I know that you're
talking about the future value

00:02:55.860 --> 00:02:58.480
of the software and the
maintenance and so forth.

00:02:58.480 --> 00:03:02.820
So let's transition into the
more formal part of this

00:03:02.820 --> 00:03:03.850
presentation today.

00:03:03.850 --> 00:03:05.140
And I'll hand it over to you.

00:03:05.140 --> 00:03:06.960
And tell us more about
code simplicity.

00:03:06.960 --> 00:03:07.590
MAX KANAT-ALEXANDER: Sure.

00:03:07.590 --> 00:03:08.290
Great.

00:03:08.290 --> 00:03:10.810
So first, let me give a little
bit more overview of who I am

00:03:10.810 --> 00:03:12.180
so everybody understands.

00:03:12.180 --> 00:03:14.100
Like I said, I'm the technical
lead for development

00:03:14.100 --> 00:03:15.790
productivity at YouTube.

00:03:15.790 --> 00:03:17.760
I used to be the chief architect
of a particular

00:03:17.760 --> 00:03:20.930
piece of open source software
called Bugzilla, which I spent

00:03:20.930 --> 00:03:21.960
many years refactoring.

00:03:21.960 --> 00:03:24.080
It used to have a very
bad code base.

00:03:24.080 --> 00:03:26.990
And it was a code base, which
actually, everybody had to see

00:03:26.990 --> 00:03:28.500
because everybody wants
to customize their

00:03:28.500 --> 00:03:29.610
bug tracking system.

00:03:29.610 --> 00:03:31.030
So it wasn't just the developers
who were being

00:03:31.030 --> 00:03:33.150
affected by the bad code base,
but it was actually a lot of

00:03:33.150 --> 00:03:35.530
our users because they actually
had to modify the

00:03:35.530 --> 00:03:37.820
code, unlike many products.

00:03:37.820 --> 00:03:40.360
And I wrote a book called "Code
Simplicity." I also have

00:03:40.360 --> 00:03:42.860
a blog by the same name
at that domain name,

00:03:42.860 --> 00:03:44.520
codesimplicity.com.

00:03:44.520 --> 00:03:45.880
And I have a lot of
other things.

00:03:45.880 --> 00:03:48.490
And there's a link to
my personal website

00:03:48.490 --> 00:03:50.920
there on the slide.

00:03:50.920 --> 00:03:54.700
And today, I'm going to be
talking about software.

00:03:54.700 --> 00:03:58.280
And in particular, I'm going to
be talking about the laws

00:03:58.280 --> 00:04:00.750
of software, and basically
fundamental principles that we

00:04:00.750 --> 00:04:04.630
can use to make good decisions
about software.

00:04:04.630 --> 00:04:06.560
So one of the problems that we
have today is that software

00:04:06.560 --> 00:04:09.510
development is really complex.

00:04:09.510 --> 00:04:11.180
When I talk to most programmers,
the systems that

00:04:11.180 --> 00:04:13.820
they're doing with are
very complex systems.

00:04:13.820 --> 00:04:16.640
And so many people feel like
that's just the way that life

00:04:16.640 --> 00:04:17.940
is in the world of software
development

00:04:17.940 --> 00:04:19.490
because it's so pervasive.

00:04:19.490 --> 00:04:21.399
Well, it doesn't actually
have to be that way.

00:04:21.399 --> 00:04:23.360
There are projects that aren't
complex, which sort of

00:04:23.360 --> 00:04:26.240
disproves this theory that
that's just the way it is.

00:04:26.240 --> 00:04:28.890
And I did a lot of research into
why this was happening

00:04:28.890 --> 00:04:29.470
for people.

00:04:29.470 --> 00:04:31.680
And what I discovered is that
the fundamental underlying

00:04:31.680 --> 00:04:32.930
reasons have to do with
understanding.

00:04:35.830 --> 00:04:38.780
Particularly, understanding how
to make decisions, what

00:04:38.780 --> 00:04:42.000
principles to follow.

00:04:42.000 --> 00:04:44.700
And the more junior an engineer
is, the harder it is

00:04:44.700 --> 00:04:47.740
for them to know-- how do I know
that this decision is the

00:04:47.740 --> 00:04:49.330
right decision?

00:04:49.330 --> 00:04:53.190
And the reason that that's hard
is because in the field

00:04:53.190 --> 00:04:55.370
of software engineering, most of
our most important lessons

00:04:55.370 --> 00:04:57.190
are learned through
experience.

00:04:57.190 --> 00:04:59.250
And that means that not
everybody has all the

00:04:59.250 --> 00:04:59.750
experience.

00:04:59.750 --> 00:05:01.260
And particularly, the newer
you are, the less

00:05:01.260 --> 00:05:02.220
experience you have.

00:05:02.220 --> 00:05:04.960
And since there's always new
people coming into the field,

00:05:04.960 --> 00:05:07.330
there's always a lot of IT
people with not enough

00:05:07.330 --> 00:05:09.990
experience to make decisions
who have to make decisions.

00:05:09.990 --> 00:05:12.030
Because that's basically one of
your most important jobs as

00:05:12.030 --> 00:05:14.830
a programmer, is to
make decisions.

00:05:14.830 --> 00:05:16.550
And even if you're an
experienced programmer, you

00:05:16.550 --> 00:05:18.750
might not have all of the
experience required to make

00:05:18.750 --> 00:05:21.300
the right decisions for every
situation because your

00:05:21.300 --> 00:05:22.900
experience might not have
covered that situation.

00:05:22.900 --> 00:05:24.500
So you might still be
new in something.

00:05:27.950 --> 00:05:32.490
And also, not everybody has
the same vocabulary.

00:05:32.490 --> 00:05:34.980
If we want to talk about
these concepts, we

00:05:34.980 --> 00:05:35.860
need words to share.

00:05:35.860 --> 00:05:40.010
We need ideas that
we can agree on.

00:05:40.010 --> 00:05:42.390
A couple years ago, the idea
of technical debt, for

00:05:42.390 --> 00:05:45.300
example, became very popular
and widespread.

00:05:45.300 --> 00:05:47.720
And before that, we didn't
have a word for that.

00:05:47.720 --> 00:05:49.460
And when people didn't have a
word for that, it was much,

00:05:49.460 --> 00:05:50.730
much harder for them
to talk about.

00:05:50.730 --> 00:05:52.550
But now it's easy for everyone
to talk about.

00:05:52.550 --> 00:05:55.470
And particularly, it's easy
for technical people to

00:05:55.470 --> 00:05:58.860
communicate to nontechnical
managers about why they need

00:05:58.860 --> 00:06:01.730
to do the work that they're
trying to do to

00:06:01.730 --> 00:06:03.180
improve code quality.

00:06:03.180 --> 00:06:05.990
And that's what I want to have
people be able to do is to be

00:06:05.990 --> 00:06:09.540
able to talk about why they're
doing what they're doing in an

00:06:09.540 --> 00:06:10.760
intelligent way.

00:06:10.760 --> 00:06:14.080
Because once you can communicate
about it, you can

00:06:14.080 --> 00:06:15.910
get team agreement on it,
and you can actually

00:06:15.910 --> 00:06:19.190
make progress forward.

00:06:19.190 --> 00:06:22.590
So my solution to this problem
was to come up with something

00:06:22.590 --> 00:06:25.840
that I called the laws of
software design, which are

00:06:25.840 --> 00:06:27.600
basically the most fundamental
or most

00:06:27.600 --> 00:06:29.640
important facts about software.

00:06:29.640 --> 00:06:31.920
And today, I'm just going to
give a real whirlwind tour.

00:06:31.920 --> 00:06:33.810
Obviously, there's a whole book
on this subject, which is

00:06:33.810 --> 00:06:36.620
my book, "Code Simplicity." And
I'm just going to touch on

00:06:36.620 --> 00:06:38.080
it really lightly, and
the book goes into it

00:06:38.080 --> 00:06:39.330
in much more detail.

00:06:42.430 --> 00:06:44.366
So one of the things that people
tell me after I read

00:06:44.366 --> 00:06:45.420
them some of these things
is they say,

00:06:45.420 --> 00:06:46.440
well, that was obvious.

00:06:46.440 --> 00:06:48.080
I already knew a lot
of those things.

00:06:48.080 --> 00:06:50.190
Well, that might be true.

00:06:50.190 --> 00:06:53.140
But what matters here is that
there's a sea of data in the

00:06:53.140 --> 00:06:54.130
field of software engineering.

00:06:54.130 --> 00:06:55.350
There's all kinds of opinions.

00:06:55.350 --> 00:06:57.320
There's all kinds
of information.

00:06:57.320 --> 00:07:00.140
And what matters is that we pick
out the most important

00:07:00.140 --> 00:07:05.920
pieces and we recognize that
those are the pieces that we

00:07:05.920 --> 00:07:07.980
use to judge our decisions
against.

00:07:07.980 --> 00:07:10.740
Because otherwise there's lots
of conflicting data.

00:07:10.740 --> 00:07:14.070
There's lots of different ways
we can make decisions.

00:07:14.070 --> 00:07:17.160
We need to know what the most
important information is, so

00:07:17.160 --> 00:07:21.950
that we can use those to judge
other information.

00:07:21.950 --> 00:07:24.210
That's why you need a structure
of information, so

00:07:24.210 --> 00:07:27.100
that you can use the senior
information to judge the more

00:07:27.100 --> 00:07:29.560
junior information.

00:07:29.560 --> 00:07:32.000
And when people tell me that
this is obvious-- so, just for

00:07:32.000 --> 00:07:35.220
a second, like off the top of
your head, could you list the

00:07:35.220 --> 00:07:37.970
five or six most important
facts about software

00:07:37.970 --> 00:07:39.920
engineering?

00:07:39.920 --> 00:07:41.290
Just think about that
for a second.

00:07:41.290 --> 00:07:42.540
I'll give you a couple
seconds.

00:07:46.990 --> 00:07:47.960
That's hard, right?

00:07:47.960 --> 00:07:50.000
It's hard to just pick out--
like, oh my gosh, off the top

00:07:50.000 --> 00:07:51.450
my head, what are the
five most important

00:07:51.450 --> 00:07:52.550
things that I know?

00:07:52.550 --> 00:07:55.110
And also, as I mentioned before,
we need to be able to

00:07:55.110 --> 00:07:56.840
communicate these ideas
to other developers.

00:07:56.840 --> 00:07:59.240
So even if we kind of inherently
or instinctively

00:07:59.240 --> 00:08:02.720
knew some of these things, it's
very hard for a lot of us

00:08:02.720 --> 00:08:05.160
to put them into words, and
thus explain them to more

00:08:05.160 --> 00:08:09.100
junior developers or explain
them to our managers.

00:08:09.100 --> 00:08:11.420
And if we can't do that, we
can't make progress forward

00:08:11.420 --> 00:08:13.970
because software development in
the real world is mostly a

00:08:13.970 --> 00:08:15.080
team activity.

00:08:15.080 --> 00:08:16.510
JAREK WILKIEWICZ: So I have
a question about the

00:08:16.510 --> 00:08:17.670
last point you made.

00:08:17.670 --> 00:08:20.960
You're saying that we need to
be able to communicate the

00:08:20.960 --> 00:08:22.860
ideas and communicate
about the idea.

00:08:22.860 --> 00:08:25.530
So can you explain what
the difference is?

00:08:25.530 --> 00:08:28.270
MAX KANAT-ALEXANDER: Sure.

00:08:28.270 --> 00:08:33.870
There's not really a lot
of difference, but--

00:08:33.870 --> 00:08:37.370
the ideas themselves
are the laws.

00:08:37.370 --> 00:08:40.049
And then communicating about the
ideas would be like, well,

00:08:40.049 --> 00:08:45.090
how are we going to use these
in our day-to-day work?

00:08:45.090 --> 00:08:48.000
So we're going to dive
right into it.

00:08:48.000 --> 00:08:49.920
And our first principle
is what I call

00:08:49.920 --> 00:08:50.880
the purpose of software.

00:08:50.880 --> 00:08:53.090
And this is not exactly a law.

00:08:53.090 --> 00:08:56.010
The book talks about the
definition that I'm using for

00:08:56.010 --> 00:08:58.140
these words, which is slightly
different than the traditional

00:08:58.140 --> 00:09:01.580
definitions that people
have for these words.

00:09:01.580 --> 00:09:04.160
Basically, I'm very much opposed
to inventing new

00:09:04.160 --> 00:09:07.890
words, so I just tend to take
existing words and use them in

00:09:07.890 --> 00:09:10.020
ways that are valid in English,
but which people are

00:09:10.020 --> 00:09:12.110
not necessarily always
as familiar with.

00:09:12.110 --> 00:09:12.970
But this is not a law.

00:09:12.970 --> 00:09:15.380
This is sort of a guiding
principle.

00:09:15.380 --> 00:09:20.180
When you have a science or a
way of looking at data, you

00:09:20.180 --> 00:09:24.100
need a way to know that- you
need to know what you're

00:09:24.100 --> 00:09:24.650
accomplishing.

00:09:24.650 --> 00:09:28.390
You need to have a guideline by
which you can judge whether

00:09:28.390 --> 00:09:31.040
or not your laws are
accomplishing what you're

00:09:31.040 --> 00:09:31.400
trying to do.

00:09:31.400 --> 00:09:32.420
You need a purpose.

00:09:32.420 --> 00:09:34.190
You need to know where
you're going.

00:09:34.190 --> 00:09:38.920
And then you can say, this
science or this study is valid

00:09:38.920 --> 00:09:40.770
because it accomplishes
this purpose.

00:09:40.770 --> 00:09:45.210
And that's more or less the only
way to validate many of

00:09:45.210 --> 00:09:45.590
these things.

00:09:45.590 --> 00:09:47.450
Particularly in something
that's almost a social

00:09:47.450 --> 00:09:49.800
science, like software
engineering.

00:09:49.800 --> 00:09:52.610
And I looked around for a very
long time for a phrase that I

00:09:52.610 --> 00:09:54.870
thought would encompass the
purpose of all software.

00:09:54.870 --> 00:09:57.250
And I found one that I have not
been able to disprove yet.

00:09:57.250 --> 00:10:00.450
And that is that software
exists to help people.

00:10:00.450 --> 00:10:02.275
Sometimes people come up to me
immediately after I say this

00:10:02.275 --> 00:10:03.930
and they're like, well,
what about viruses?

00:10:03.930 --> 00:10:06.460
Well, viruses do exist
to help people.

00:10:06.460 --> 00:10:07.950
They just exist to help
different people than you'd

00:10:07.950 --> 00:10:09.050
think, or help people
in different

00:10:09.050 --> 00:10:10.520
ways than you'd think.

00:10:10.520 --> 00:10:11.780
When you talked to
virus writers--

00:10:11.780 --> 00:10:13.420
I remember reading an interview
with a virus writer

00:10:13.420 --> 00:10:14.370
many years ago.

00:10:14.370 --> 00:10:16.710
And he said, I'm trying
to help people realize

00:10:16.710 --> 00:10:18.830
how stupid they are.

00:10:18.830 --> 00:10:20.920
Or, how much more careful
they should

00:10:20.920 --> 00:10:22.670
be with their computers.

00:10:22.670 --> 00:10:25.820
Or sometimes, if they're virus
writers for a government or

00:10:25.820 --> 00:10:27.580
for an intelligence
organization, then they're

00:10:27.580 --> 00:10:28.970
helping that government
or they're helping the

00:10:28.970 --> 00:10:30.300
intelligence organization.

00:10:30.300 --> 00:10:35.110
And so there's definitely a
subjective aspect to this.

00:10:35.110 --> 00:10:37.110
But what's most important here
is that software is not

00:10:37.110 --> 00:10:38.640
written to help the computer.

00:10:38.640 --> 00:10:40.920
Even if you're writing
libraries, you're writing

00:10:40.920 --> 00:10:42.670
those libraries to help
other programmers,

00:10:42.670 --> 00:10:43.570
not to help the computer.

00:10:43.570 --> 00:10:47.040
Even network stack stuff
is there to help

00:10:47.040 --> 00:10:48.130
somebody, some person.

00:10:48.130 --> 00:10:50.830
It's not there to help
the computer.

00:10:50.830 --> 00:10:53.300
And I mentioned there's a
subjective component to this,

00:10:53.300 --> 00:10:54.850
but I would like to encourage
people to be more

00:10:54.850 --> 00:10:56.330
objective about it.

00:10:56.330 --> 00:11:02.230
To look at, how do you actually
help people on the

00:11:02.230 --> 00:11:03.000
broad scale?

00:11:03.000 --> 00:11:04.800
How do you help people
across the world?

00:11:04.800 --> 00:11:06.920
How do you help people in your
organization or in other

00:11:06.920 --> 00:11:08.370
organizations?

00:11:08.370 --> 00:11:09.730
And then also, how do
you help yourself?

00:11:09.730 --> 00:11:10.890
I mean, that is valid.

00:11:10.890 --> 00:11:13.610
It might be a little less
important on the scale, but

00:11:13.610 --> 00:11:15.390
it's still an important fact.

00:11:15.390 --> 00:11:18.440
And part of the subjective
component is that the word

00:11:18.440 --> 00:11:20.480
"help--" like, what
is helpful to

00:11:20.480 --> 00:11:22.050
different people is different.

00:11:22.050 --> 00:11:25.290
But the word has a dictionary
definition, and it means to

00:11:25.290 --> 00:11:27.810
make it easier for a person to
do something, often to do part

00:11:27.810 --> 00:11:28.640
of the work of a person.

00:11:28.640 --> 00:11:30.820
That is, more or less, straight
out of the Webster's

00:11:30.820 --> 00:11:33.030
Third New International
Dictionary.

00:11:33.030 --> 00:11:36.250
And this is also useful because
you can state the

00:11:36.250 --> 00:11:39.150
specific purpose for your
software by picking the group

00:11:39.150 --> 00:11:40.690
of people you're
trying to help.

00:11:40.690 --> 00:11:42.760
And then, what you're trying
to help them do.

00:11:42.760 --> 00:11:46.420
So for example, if I write a
piece of accounting software

00:11:46.420 --> 00:11:48.770
for accountants and it's
designed to help accountants

00:11:48.770 --> 00:11:51.810
do taxes for others, then I can
just say the purpose of my

00:11:51.810 --> 00:11:54.000
software is to help accountants
do taxes.

00:11:54.000 --> 00:11:56.390
And one of the nice things about
this is it allows us to

00:11:56.390 --> 00:12:01.310
very specifically state what
the focus of our system is.

00:12:01.310 --> 00:12:03.250
And more focused systems
are usually

00:12:03.250 --> 00:12:05.230
better for their users.

00:12:05.230 --> 00:12:07.660
It also allows us to rank
features, so we can be like,

00:12:07.660 --> 00:12:10.340
hey, this feature helps
accountants do taxes more than

00:12:10.340 --> 00:12:11.230
other features.

00:12:11.230 --> 00:12:13.250
It gives us a guideline against
which we can actually

00:12:13.250 --> 00:12:15.210
use to make these judgments.

00:12:15.210 --> 00:12:16.712
JAREK WILKIEWICZ: So the
manifestation of that would be

00:12:16.712 --> 00:12:18.958
some sort of a human-centric
design?

00:12:18.958 --> 00:12:21.320
And I think, to a certain
extent, use cases or

00:12:21.320 --> 00:12:24.310
contextual design falls into
that category, where you

00:12:24.310 --> 00:12:26.360
actually have somebody
in mind when you're

00:12:26.360 --> 00:12:27.602
building it, right?

00:12:27.602 --> 00:12:29.540
MAX KANAT-ALEXANDER: Yeah.

00:12:29.540 --> 00:12:32.510
I think it's important many
times to not have just one

00:12:32.510 --> 00:12:34.770
person in mind, because you're
trying to help a

00:12:34.770 --> 00:12:35.960
whole group of people.

00:12:35.960 --> 00:12:42.090
And so I've occasionally seen
this model fall flat if people

00:12:42.090 --> 00:12:45.010
try to do too much
categorization of their users.

00:12:45.010 --> 00:12:46.670
But I think some categorization
of your users

00:12:46.670 --> 00:12:49.420
is good, as long as you either
try to find a set of

00:12:49.420 --> 00:12:51.730
categories that are broad
enough that they cover

00:12:51.730 --> 00:12:55.300
everyone or you recognize that
you're not covering everyone

00:12:55.300 --> 00:12:58.710
and that ultimately, the purpose
is to help the whole

00:12:58.710 --> 00:12:59.340
group of people.

00:12:59.340 --> 00:12:59.520
JAREK WILKIEWICZ: Sure.

00:12:59.520 --> 00:13:01.355
That's the purpose of
personas, right?

00:13:01.355 --> 00:13:02.690
This is what people
use personas for?

00:13:02.690 --> 00:13:03.770
MAX KANAT-ALEXANDER:
Yeah, exactly.

00:13:03.770 --> 00:13:08.060
And I've seen people misuse
personas in these cases.

00:13:08.060 --> 00:13:09.840
And so I always want to be
careful when people are using

00:13:09.840 --> 00:13:13.990
personas that they're using them
intelligently, because

00:13:13.990 --> 00:13:15.240
that's what makes
them valuable.

00:13:17.670 --> 00:13:19.900
So now we get into our first
law, and this first law is

00:13:19.900 --> 00:13:23.200
something that I call the
equation of software design.

00:13:23.200 --> 00:13:27.120
And it basically states that the
desirability of any change

00:13:27.120 --> 00:13:29.250
is directly proportional to the
value of the change, which

00:13:29.250 --> 00:13:32.460
is how much it helps people, our
previous law, versus the

00:13:32.460 --> 00:13:34.280
effort involved in making the
change, which is just the

00:13:34.280 --> 00:13:36.380
total time that it takes to make
the change, including all

00:13:36.380 --> 00:13:37.870
the work that you have
to do-- bug tracking,

00:13:37.870 --> 00:13:39.660
everything like that.

00:13:39.660 --> 00:13:41.300
And what we can use
this for is we can

00:13:41.300 --> 00:13:42.720
use it to rank decisions.

00:13:42.720 --> 00:13:44.950
In the field of software design,
there's no absolutely

00:13:44.950 --> 00:13:47.410
right or absolutely
wrong decisions.

00:13:47.410 --> 00:13:48.550
There's only decisions that are

00:13:48.550 --> 00:13:50.560
better than other decisions.

00:13:50.560 --> 00:13:53.180
And eventually, sometimes you
get to the point where there

00:13:53.180 --> 00:13:56.930
are two or three decisions that
are all equally good.

00:13:56.930 --> 00:13:59.000
But usually, then you're
in a good state.

00:13:59.000 --> 00:14:01.320
As long as you've eliminated all
the bad decisions and you

00:14:01.320 --> 00:14:03.010
have a bunch of different
decisions that are good that

00:14:03.010 --> 00:14:06.180
you can pick between,
I'm happy for you

00:14:06.180 --> 00:14:07.430
to have that problem.

00:14:10.520 --> 00:14:15.590
Although, however, this is the
overly simplistic version of

00:14:15.590 --> 00:14:17.340
the equation.

00:14:17.340 --> 00:14:21.550
Because really, in reality,
desirability and software has

00:14:21.550 --> 00:14:22.720
a time component to it.

00:14:22.720 --> 00:14:24.570
We maintain systems over time.

00:14:24.570 --> 00:14:27.290
So the full version of the
equation looks like this.

00:14:27.290 --> 00:14:30.700
It says that the desirability
of any particular change is

00:14:30.700 --> 00:14:33.520
proportional to the sum of the
value now plus the future

00:14:33.520 --> 00:14:36.550
value and inversely proportional
to the effort of

00:14:36.550 --> 00:14:39.640
implementation plus the
effort of maintenance.

00:14:39.640 --> 00:14:42.643
Now, one thing that we can look
at here-- and what I mean

00:14:42.643 --> 00:14:44.410
by value now is I mean the value
basically right when you

00:14:44.410 --> 00:14:50.920
release it, or right when
it hits the user.

00:14:50.920 --> 00:14:54.400
It depends, but you'll have a
sense for yourself of when the

00:14:54.400 --> 00:14:56.030
now is versus when
the future is.

00:14:56.030 --> 00:14:57.900
And the effort of implementation
is all the

00:14:57.900 --> 00:15:00.380
effort that it took to get to
the value now, the immediate

00:15:00.380 --> 00:15:02.470
value of the system.

00:15:02.470 --> 00:15:04.000
And like I said, usually
that's when

00:15:04.000 --> 00:15:06.840
it's released to users.

00:15:06.840 --> 00:15:08.380
First is future--

00:15:08.380 --> 00:15:10.460
and those are both constants.

00:15:10.460 --> 00:15:11.440
So the value now and
the effort of

00:15:11.440 --> 00:15:13.450
implementation are constants.

00:15:13.450 --> 00:15:15.500
And the value in the future
is a function of time.

00:15:15.500 --> 00:15:17.730
And the effort of maintenance
is a function of time.

00:15:17.730 --> 00:15:20.680
And software tends to have very
long time lines, which

00:15:20.680 --> 00:15:22.920
means that, in general, we
tend to be looking at the

00:15:22.920 --> 00:15:25.830
limit of this equation as time
goes on, or time approaches

00:15:25.830 --> 00:15:28.620
infinity for those of us who did
calculus, which is a lot

00:15:28.620 --> 00:15:31.260
of programmers.

00:15:31.260 --> 00:15:36.370
And so what happens is the
equation actually reduces at

00:15:36.370 --> 00:15:39.860
the limit to the desirability of
any particular change being

00:15:39.860 --> 00:15:42.680
proportional to the future
value and inversely

00:15:42.680 --> 00:15:45.160
proportional to its effort
of maintenance only.

00:15:45.160 --> 00:15:49.010
That the constants drop away
as you go into the future.

00:15:49.010 --> 00:15:51.620
And I think that this is
something that people often

00:15:51.620 --> 00:15:53.960
forget when they're very caught
up in the effort of

00:15:53.960 --> 00:15:55.690
implementation, because there's
a lot of effort in

00:15:55.690 --> 00:15:58.390
implementation and the effort
of maintenance in the future

00:15:58.390 --> 00:15:59.330
is not yet realized.

00:15:59.330 --> 00:16:00.550
You don't see it yet.

00:16:00.550 --> 00:16:03.480
But it's there and it's usually
much more important.

00:16:03.480 --> 00:16:07.630
Particularly because when you
make changes to your system,

00:16:07.630 --> 00:16:09.920
you're influencing the
maintenance of other parts of

00:16:09.920 --> 00:16:10.450
your system.

00:16:10.450 --> 00:16:12.030
So you're increasing the
maintenance of the overall

00:16:12.030 --> 00:16:14.410
system and you're making
everything less desirable as

00:16:14.410 --> 00:16:16.790
you add more and more
maintenance in the future.

00:16:16.790 --> 00:16:19.790
So it's important for us to
think now about how we reduce

00:16:19.790 --> 00:16:21.330
future maintenance.

00:16:21.330 --> 00:16:22.520
JAREK WILKIEWICZ: One question
about this equation.

00:16:22.520 --> 00:16:24.970
So you were talking earlier
about technical debt.

00:16:24.970 --> 00:16:28.230
So how does technical debt
picture into this?

00:16:28.230 --> 00:16:31.070
Does it increase the em
right off the bat?

00:16:31.070 --> 00:16:32.190
How does it work?

00:16:32.190 --> 00:16:32.870
MAX KANAT-ALEXANDER:
That's pretty much

00:16:32.870 --> 00:16:34.660
exactly what it does.

00:16:34.660 --> 00:16:39.090
So a good guideline is that you
can accumulate technical

00:16:39.090 --> 00:16:42.940
debt for about three weeks
without it affecting you.

00:16:42.940 --> 00:16:46.100
And then, about three weeks into
it, the technical debt

00:16:46.100 --> 00:16:48.120
that you incurred three weeks
ago will actually start

00:16:48.120 --> 00:16:50.750
slowing you down so much that it
wasn't worth incurring the

00:16:50.750 --> 00:16:51.910
technical debt.

00:16:51.910 --> 00:16:52.190
JAREK WILKIEWICZ: Interesting.

00:16:52.190 --> 00:16:54.330
MAX KANAT-ALEXANDER: Yeah.

00:16:54.330 --> 00:16:55.980
And that is what you're doing,
you're increasing the effort

00:16:55.980 --> 00:16:58.340
of maintenance.

00:16:58.340 --> 00:17:01.370
And our goal as software
designers, if we talk about

00:17:01.370 --> 00:17:03.520
the field of software design
as a sort of a subset of

00:17:03.520 --> 00:17:06.460
software engineering, is to
avoid situations where the

00:17:06.460 --> 00:17:08.869
future value becomes outweighed
by the effort of

00:17:08.869 --> 00:17:09.760
maintenance.

00:17:09.760 --> 00:17:12.619
The idea is that the future
value of any change you make

00:17:12.619 --> 00:17:15.470
increases and increases and
increases, and the effort of

00:17:15.470 --> 00:17:16.410
maintenance decreases.

00:17:16.410 --> 00:17:19.740
That's the ideal, but any
situation in which the future

00:17:19.740 --> 00:17:22.170
value increases faster
than the effort--

00:17:22.170 --> 00:17:23.550
they could both go up.

00:17:23.550 --> 00:17:25.690
As long as the future value is
getting bigger and bigger and

00:17:25.690 --> 00:17:28.230
bigger, you're fine.

00:17:28.230 --> 00:17:31.310
But what this tells us most
importantly is that it's more

00:17:31.310 --> 00:17:34.260
important to reduce the effort
of maintenance than it is to

00:17:34.260 --> 00:17:36.080
reduce the effort of
implementation.

00:17:36.080 --> 00:17:39.490
That if you have to do sort of
a balancing of work, you want

00:17:39.490 --> 00:17:42.040
to do more work at
implementation time if that

00:17:42.040 --> 00:17:44.300
means less work at
maintenance time.

00:17:44.300 --> 00:17:46.580
However, there's definitely
some catches to that.

00:17:46.580 --> 00:17:50.010
You don't want to add a lot of
complexity to the system in

00:17:50.010 --> 00:17:53.010
order to sort of handle future
maintenance that you don't

00:17:53.010 --> 00:17:54.450
know whether it's going to
be necessary or not.

00:17:54.450 --> 00:17:55.430
And we're going to
get into that.

00:17:55.430 --> 00:17:57.110
JAREK WILKIEWICZ: This is very
difficult to do, though.

00:17:57.110 --> 00:17:57.750
MAX KANAT-ALEXANDER: Yes.

00:17:57.750 --> 00:17:59.680
This is very difficult to do.

00:17:59.680 --> 00:18:02.975
Although, I have some guidelines
that I think--

00:18:02.975 --> 00:18:04.300
JAREK WILKIEWICZ: You're going
to show us how to do it?

00:18:04.300 --> 00:18:05.590
MAX KANAT-ALEXANDER: Yeah.

00:18:05.590 --> 00:18:06.660
This is my goal.

00:18:06.660 --> 00:18:07.410
JAREK WILKIEWICZ: Looking
forward to it.

00:18:07.410 --> 00:18:10.140
MAX KANAT-ALEXANDER: Yeah.

00:18:10.140 --> 00:18:14.990
Now, one thing though, to know
about the future, is that it's

00:18:14.990 --> 00:18:16.020
very hard to predict.

00:18:16.020 --> 00:18:18.480
Like I said, software has
very long time lines.

00:18:18.480 --> 00:18:21.330
Even things that you expect to
live for a very short period

00:18:21.330 --> 00:18:25.220
of time are likely to live
for months or years.

00:18:25.220 --> 00:18:27.080
And that the farther things
get into the future, the

00:18:27.080 --> 00:18:30.490
harder and harder it
is to predict.

00:18:30.490 --> 00:18:39.050
And as a result, any time that
you start predicting the

00:18:39.050 --> 00:18:40.730
future, you have a chance
of being wrong.

00:18:40.730 --> 00:18:43.490
Any time you start making a
decision now based on the

00:18:43.490 --> 00:18:45.590
specifics of something you
think will happen in the

00:18:45.590 --> 00:18:48.070
future, there's a reasonable
chance you'll be wrong.

00:18:48.070 --> 00:18:49.780
Most people, they know
what they're

00:18:49.780 --> 00:18:50.940
going to have for lunch.

00:18:50.940 --> 00:18:53.270
And maybe they have some sense
of when they're going to be

00:18:53.270 --> 00:18:54.070
leaving work.

00:18:54.070 --> 00:18:56.260
But if you think about all the
times that you were wrong

00:18:56.260 --> 00:18:59.350
about when you were going to
leave work, you can realize

00:18:59.350 --> 00:19:02.060
that it doesn't have to be a
very long time horizon before

00:19:02.060 --> 00:19:03.900
your predictions start
becoming relatively

00:19:03.900 --> 00:19:05.610
inaccurate.

00:19:05.610 --> 00:19:08.120
And since we're designing these
systems where our future

00:19:08.120 --> 00:19:11.490
is really important, it's
important that we don't make

00:19:11.490 --> 00:19:14.540
inaccurate statements
about the future.

00:19:14.540 --> 00:19:17.800
One of the most disastrous
errors that programmers make

00:19:17.800 --> 00:19:22.240
is making some statement about
the future when, in fact, you

00:19:22.240 --> 00:19:23.400
can't know that.

00:19:23.400 --> 00:19:28.530
When you act as though you can
know, when really you can't.

00:19:28.530 --> 00:19:30.330
For example, people say,
we will never have

00:19:30.330 --> 00:19:31.950
to reuse this code.

00:19:31.950 --> 00:19:33.190
You don't know that.

00:19:33.190 --> 00:19:36.240
You might be right, you
might be wrong.

00:19:36.240 --> 00:19:38.570
People might say, well, we'll
never have to handle any other

00:19:38.570 --> 00:19:41.710
input to this method than what
it's getting now, or input to

00:19:41.710 --> 00:19:43.050
this class than what
it's getting now.

00:19:43.050 --> 00:19:45.560
Well, you might be right,
you might be wrong.

00:19:45.560 --> 00:19:48.460
And sometimes you do have
to make assumptions.

00:19:48.460 --> 00:19:50.920
For example, with
internationalization, it can

00:19:50.920 --> 00:19:53.570
be very hard to bolt
that on later.

00:19:53.570 --> 00:19:56.750
But you have to be aware that
what you're doing is an

00:19:56.750 --> 00:19:58.730
assumption.

00:19:58.730 --> 00:20:02.630
And you have to make it in some
way that it doesn't block

00:20:02.630 --> 00:20:05.520
you in for the future.

00:20:05.520 --> 00:20:08.900
It doesn't cause your future
to become unchangeable or

00:20:08.900 --> 00:20:12.380
inflexible because you
could be wrong.

00:20:12.380 --> 00:20:13.950
You always have to sort
of hedge your bets.

00:20:17.170 --> 00:20:18.340
For example, with
internationalization

00:20:18.340 --> 00:20:21.390
frameworks, what I tell people
is you might start off only

00:20:21.390 --> 00:20:23.430
need the thing in English.

00:20:23.430 --> 00:20:25.930
So just try to use
internationalization framework

00:20:25.930 --> 00:20:28.340
that adds very, very little
complexity to the system.

00:20:28.340 --> 00:20:29.520
And we're going to get
into why that is a

00:20:29.520 --> 00:20:30.390
little bit more later.

00:20:30.390 --> 00:20:33.640
But that will basically make
sure that you're not going to

00:20:33.640 --> 00:20:36.070
box yourself in.

00:20:36.070 --> 00:20:38.760
What I recommend to developers
is that--

00:20:38.760 --> 00:20:40.480
and this is going to sound a
little contradictory and I'm

00:20:40.480 --> 00:20:42.310
going to get into this
resolution of the

00:20:42.310 --> 00:20:45.060
contradiction, is that you
don't make specific

00:20:45.060 --> 00:20:46.870
predictions about the future.

00:20:46.870 --> 00:20:49.350
Instead, what you should do is
you should understand the

00:20:49.350 --> 00:20:53.420
principles of software design
and use those principles and

00:20:53.420 --> 00:20:56.990
the rules and best practices to
understand how you can make

00:20:56.990 --> 00:20:59.870
decisions now that will lead
to a good future no matter

00:20:59.870 --> 00:21:01.120
what happens.

00:21:04.110 --> 00:21:05.850
I told you at the beginning for
the equation of software

00:21:05.850 --> 00:21:07.610
design, I said the most
important thing is the effort

00:21:07.610 --> 00:21:09.090
of maintenance and the future
value, which is

00:21:09.090 --> 00:21:09.770
all about the future.

00:21:09.770 --> 00:21:12.750
And then I told you, but really,
don't make decisions

00:21:12.750 --> 00:21:14.660
about the future.

00:21:14.660 --> 00:21:16.160
So this sounds like
a contradiction,

00:21:16.160 --> 00:21:17.940
but really it's not.

00:21:17.940 --> 00:21:20.980
There's a difference between
designing right now in a way

00:21:20.980 --> 00:21:23.740
that is guaranteed to reduce
future maintenance, which is

00:21:23.740 --> 00:21:26.390
what I want you to do, versus
attempting to predict

00:21:26.390 --> 00:21:29.580
something specific about the
future, like this platform

00:21:29.580 --> 00:21:30.830
will always be maintained.

00:21:33.720 --> 00:21:35.970
Or, there's going to
be x number of

00:21:35.970 --> 00:21:38.990
developers using our framework.

00:21:38.990 --> 00:21:42.470
Or, nobody will ever
need another

00:21:42.470 --> 00:21:43.820
part of this API response.

00:21:46.350 --> 00:21:48.600
Those are decisions, specific
things about the future that

00:21:48.600 --> 00:21:49.920
you're predicting that
you can't know.

00:21:49.920 --> 00:21:54.400
Whereas, if you say, OK, right
now, we know that the purpose

00:21:54.400 --> 00:21:55.300
of software is to help people.

00:21:55.300 --> 00:21:57.100
The purpose of software is going
to always be to help

00:21:57.100 --> 00:22:00.010
people, and so that can guide
our future decisions.

00:22:00.010 --> 00:22:02.780
That's a good way of making a
decision about the future, is

00:22:02.780 --> 00:22:06.620
things that you know will always
be true and will always

00:22:06.620 --> 00:22:10.360
help things be better, rather
than very specific things that

00:22:10.360 --> 00:22:12.850
you might be wrong about.

00:22:12.850 --> 00:22:15.410
So one of the things that we
can know about the future,

00:22:15.410 --> 00:22:16.610
with fair certainty--

00:22:16.610 --> 00:22:18.480
with actually, total
certainty--

00:22:18.480 --> 00:22:21.270
is that the longer your program
exists, the more

00:22:21.270 --> 00:22:24.010
probable it is that any piece
of it will have to change.

00:22:24.010 --> 00:22:25.410
Basically you can think
of this as a

00:22:25.410 --> 00:22:27.310
reflection of entropy.

00:22:27.310 --> 00:22:31.200
That the universe is going to
change around you, and that as

00:22:31.200 --> 00:22:34.500
long as you want your system
to continue to help people,

00:22:34.500 --> 00:22:35.680
you're going to have
to change it.

00:22:35.680 --> 00:22:37.610
Because you're going to have
to adapt it to the changing

00:22:37.610 --> 00:22:39.640
needs of the universe.

00:22:39.640 --> 00:22:42.660
Or, maybe it doesn't even fully
fulfill its users needs

00:22:42.660 --> 00:22:44.530
yet, which is most pieces
of software.

00:22:44.530 --> 00:22:47.490
You're still adding features
to fully fulfill, even the

00:22:47.490 --> 00:22:49.380
presently known needs.

00:22:49.380 --> 00:22:52.630
It's impossible to make a system
that doesn't change but

00:22:52.630 --> 00:22:55.620
continues to help people just
as well as it does now.

00:22:55.620 --> 00:22:58.650
The helpfulness of a piece
of software decays

00:22:58.650 --> 00:23:00.030
if it is not changed.

00:23:00.030 --> 00:23:03.200
Many people believe that it is
possible to do this and they

00:23:03.200 --> 00:23:05.630
make bad decisions based
on this belief.

00:23:10.590 --> 00:23:13.150
Now, when people get into trying
to change pieces of

00:23:13.150 --> 00:23:15.560
software, there's three
major classes of

00:23:15.560 --> 00:23:16.740
mistakes that they make.

00:23:16.740 --> 00:23:18.950
And I give a whole presentation
on these three

00:23:18.950 --> 00:23:20.860
major classes and there's a
whole section in the book

00:23:20.860 --> 00:23:23.220
about them, but here I'm
just going to go

00:23:23.220 --> 00:23:26.170
over them really briefly.

00:23:26.170 --> 00:23:28.790
The first is that they write
code that isn't needed.

00:23:28.790 --> 00:23:33.400
They think, I'm going to need
this code in the future, and

00:23:33.400 --> 00:23:35.770
so they write it now.

00:23:35.770 --> 00:23:37.860
And there's this philosophy in
extreme programming called you

00:23:37.860 --> 00:23:40.190
ain't going to need it, which
sort of forbids doing this.

00:23:40.190 --> 00:23:43.840
But I think that that phrasing
is wrong, because--

00:23:43.840 --> 00:23:45.160
and it's hard to convince
people that way.

00:23:45.160 --> 00:23:46.890
Because sometimes
you do need it.

00:23:46.890 --> 00:23:47.950
Sometimes you were right
and you did need

00:23:47.950 --> 00:23:48.940
this piece of software.

00:23:48.940 --> 00:23:50.950
But what you don't know is you
don't know what the real

00:23:50.950 --> 00:23:54.890
requirements of the future are
until you reach the future.

00:23:54.890 --> 00:23:57.650
So you don't know exactly how
the software should be written

00:23:57.650 --> 00:23:59.430
or what's the most ideal
way to write it

00:23:59.430 --> 00:24:00.510
until the future comes.

00:24:00.510 --> 00:24:03.030
So what usually ends up
happening is you write it now,

00:24:03.030 --> 00:24:04.320
and then you don't
need it now.

00:24:04.320 --> 00:24:06.260
And then you end up rewriting it
in the future when the real

00:24:06.260 --> 00:24:08.570
future comes, or you don't
rewrite it and then you have

00:24:08.570 --> 00:24:10.840
to hack around it because it's
not what you really need.

00:24:10.840 --> 00:24:13.040
So you're basically wasting
effort right now by writing

00:24:13.040 --> 00:24:17.110
software that you're going
to need in the future.

00:24:17.110 --> 00:24:19.430
The second is not making the
code easy to change.

00:24:19.430 --> 00:24:22.160
And usually, this is just
lack of design.

00:24:22.160 --> 00:24:24.300
Like the simplest way to do
this is just to not think

00:24:24.300 --> 00:24:26.560
about the design, not understand
best practices.

00:24:26.560 --> 00:24:28.190
If you're working in an
object-oriented language,

00:24:28.190 --> 00:24:30.180
don't write object-oriented
code.

00:24:30.180 --> 00:24:31.950
If you're working in a
functional language, don't

00:24:31.950 --> 00:24:34.220
write sensible functional
patterns.

00:24:34.220 --> 00:24:37.630
Don't think about the design
of your functions.

00:24:37.630 --> 00:24:40.830
And you're going to get into a
system that just is enormously

00:24:40.830 --> 00:24:42.380
difficult to change.

00:24:42.380 --> 00:24:45.120
And the change is the one
constant that we have that

00:24:45.120 --> 00:24:45.740
we're sure about.

00:24:45.740 --> 00:24:47.120
So that's the thing that
you really do need to

00:24:47.120 --> 00:24:48.370
design for, is change.

00:24:51.220 --> 00:24:53.320
And so there's two.

00:24:53.320 --> 00:24:55.330
I probably should have written
them on the slide--

00:24:55.330 --> 00:24:59.640
rigid design and--

00:24:59.640 --> 00:25:01.330
JAREK WILKIEWICZ: So the third
one you have listed here is

00:25:01.330 --> 00:25:02.960
being too generic.

00:25:02.960 --> 00:25:06.090
And frankly, this is one of the
traps that I find myself

00:25:06.090 --> 00:25:07.340
falling into all the time.

00:25:07.340 --> 00:25:10.370
And it's related to the first
one, because I'm trying to

00:25:10.370 --> 00:25:12.650
anticipate the need, so I
want to make it generic.

00:25:12.650 --> 00:25:14.550
But then it's really
complicated design.

00:25:14.550 --> 00:25:17.560
So how do you find the balance
between allowing for future

00:25:17.560 --> 00:25:19.660
change, like you said in the
previous slide, because change

00:25:19.660 --> 00:25:20.180
is going to come.

00:25:20.180 --> 00:25:21.560
This is inevitable.

00:25:21.560 --> 00:25:24.855
But then, at the same time, not
being too generic so the

00:25:24.855 --> 00:25:28.010
code is easy to read and so
forth, like this is something

00:25:28.010 --> 00:25:29.505
that I personally
struggled with.

00:25:29.505 --> 00:25:30.010
MAX KANAT-ALEXANDER:
Yeah, that's a

00:25:30.010 --> 00:25:31.630
really great question.

00:25:31.630 --> 00:25:33.870
And it was something that I
struggled with too for a while

00:25:33.870 --> 00:25:34.540
in my career.

00:25:34.540 --> 00:25:38.090
And I found a principle that
basically resolves it.

00:25:38.090 --> 00:25:40.570
And so yeah, so being too
generic is a problem.

00:25:40.570 --> 00:25:41.960
And it's a very serious
problem.

00:25:41.960 --> 00:25:44.520
So what I see is that junior
engineers tend to have the

00:25:44.520 --> 00:25:47.640
under-designing problem and
senior engineers tend to have

00:25:47.640 --> 00:25:50.030
this over-engineering problem,
being too generic.

00:25:50.030 --> 00:25:53.180
Because they've experienced the
pain of inflexible systems

00:25:53.180 --> 00:25:54.760
and now they want to
handle the problem.

00:25:54.760 --> 00:25:58.010
But then, they design a system
that is generic in ways that

00:25:58.010 --> 00:25:59.370
they don't know if it
needs to be generic

00:25:59.370 --> 00:26:00.840
or not for the future.

00:26:00.840 --> 00:26:03.910
And my principle is that
you can handle this

00:26:03.910 --> 00:26:06.240
problem if you just--

00:26:06.240 --> 00:26:10.350
very similar to a lot of the
other solutions here is, if

00:26:10.350 --> 00:26:13.420
you focus on being only as
generic as you need to be

00:26:13.420 --> 00:26:17.220
right now and you get really
accustomed to refactoring.

00:26:17.220 --> 00:26:20.410
So it is important to be as
generic as the system

00:26:20.410 --> 00:26:22.360
presently needs it to be.

00:26:22.360 --> 00:26:24.700
But whenever you're making
predictions about future

00:26:24.700 --> 00:26:28.320
genericness, you could be
wrong and you could be

00:26:28.320 --> 00:26:29.790
wasting your time.

00:26:29.790 --> 00:26:31.640
And in fact, it's likely that
you're wasting your time

00:26:31.640 --> 00:26:34.080
because you could just wait for
the future to arrive and

00:26:34.080 --> 00:26:36.055
then re-design the system
appropriately then.

00:26:39.910 --> 00:26:43.450
So what I encourage people to
do is be as generic as you

00:26:43.450 --> 00:26:48.000
need to be so that you never
duplicate code and that your

00:26:48.000 --> 00:26:52.170
system always remains
simple enough.

00:26:52.170 --> 00:26:54.180
And particularly, that
it remains stable.

00:26:54.180 --> 00:26:56.450
So sometimes you need a level
of genericness to, for

00:26:56.450 --> 00:26:58.870
example, handle multi-threading
appropriately,

00:26:58.870 --> 00:27:00.790
even though there's only
one part of your system

00:27:00.790 --> 00:27:02.410
that's using it.

00:27:02.410 --> 00:27:05.210
But more often, what you'll find
is you suddenly have two

00:27:05.210 --> 00:27:06.720
things that look similar.

00:27:06.720 --> 00:27:11.340
And at that very instant,
that's when you need the

00:27:11.340 --> 00:27:12.030
generic functionality.

00:27:12.030 --> 00:27:14.710
But you need it to be only as
generic as it needs to be to

00:27:14.710 --> 00:27:16.680
handle those two
specific cases.

00:27:16.680 --> 00:27:17.606
JAREK WILKIEWICZ: Got it.

00:27:17.606 --> 00:27:17.990
Cool.

00:27:17.990 --> 00:27:19.030
MAX KANAT-ALEXANDER: Cool.

00:27:19.030 --> 00:27:20.990
And that actually, pretty much
wraps up that slide for us.

00:27:23.670 --> 00:27:27.680
So that brings us onto our next
law, which is the law of

00:27:27.680 --> 00:27:28.510
defect probability.

00:27:28.510 --> 00:27:30.510
And this is a fairly well-known
fact, but I think

00:27:30.510 --> 00:27:32.670
it's useful to categorize it up
here as something that we

00:27:32.670 --> 00:27:34.140
can use to make decisions
about it on

00:27:34.140 --> 00:27:35.580
a very senior level.

00:27:35.580 --> 00:27:38.280
And it says, "the chance of
introducing a defect into your

00:27:38.280 --> 00:27:40.670
program is proportional to the
size of changes you make to

00:27:40.670 --> 00:27:41.600
it."

00:27:41.600 --> 00:27:43.930
I mean, this is obvious, but
it's useful for the framework

00:27:43.930 --> 00:27:47.010
purposes to point out that
defects are basically things

00:27:47.010 --> 00:27:49.370
that don't help people.

00:27:49.370 --> 00:27:51.450
I mean, that's not the exact
definition of a bug, but it's

00:27:51.450 --> 00:27:52.970
a good way to look at it.

00:27:52.970 --> 00:27:56.270
There are no perfect
programmers.

00:27:56.270 --> 00:28:00.110
Studies tend to show that very
good programmers, the best

00:28:00.110 --> 00:28:05.050
programmers will introduce 1
bug per about 100 lines of

00:28:05.050 --> 00:28:06.460
codes that they're writing.

00:28:06.460 --> 00:28:09.310
And that under the very best
possible circumstances,

00:28:09.310 --> 00:28:11.090
meaning the strictest
guidelines, meaning you're

00:28:11.090 --> 00:28:13.490
moving very slowly and you're
doing a lot of testing and

00:28:13.490 --> 00:28:17.250
it's just an onerous burden,
programmers will introduce

00:28:17.250 --> 00:28:19.490
about one bug for every thousand
lines of code that

00:28:19.490 --> 00:28:19.820
they write.

00:28:19.820 --> 00:28:23.020
But that is extreme
circumstances.

00:28:23.020 --> 00:28:27.910
So you're going to add
bugs, basically.

00:28:27.910 --> 00:28:30.270
And you're going to add them
mostly in proportion to the

00:28:30.270 --> 00:28:32.430
size of the changes that you're
making to the system.

00:28:34.950 --> 00:28:39.290
And if we combine all three of
our laws, so our equation of

00:28:39.290 --> 00:28:41.320
software design and the law of
change and the law of defect

00:28:41.320 --> 00:28:43.530
probability, we start to
develop a philosophy.

00:28:43.530 --> 00:28:45.390
And this is a philosophy that
many people know, but this

00:28:45.390 --> 00:28:48.970
helps justify why we should
be doing this.

00:28:48.970 --> 00:28:50.940
The best design is the one
that allows for the most

00:28:50.940 --> 00:28:52.886
change outside of us in the
environment, because that's

00:28:52.886 --> 00:28:54.820
what we're dealing with,
with the least

00:28:54.820 --> 00:28:56.000
change in the software.

00:28:56.000 --> 00:28:58.310
Or, at least, with small changes
or reasonably sized

00:28:58.310 --> 00:28:59.560
changes in the software.

00:29:01.680 --> 00:29:04.030
But it's important, like I said,
not to fall into the

00:29:04.030 --> 00:29:07.050
trap of being too generic
to accomplish this.

00:29:07.050 --> 00:29:10.080
It's not like, oh, we're going
to make everything into a

00:29:10.080 --> 00:29:12.790
configuration file because
that allows us to

00:29:12.790 --> 00:29:13.990
not change the code.

00:29:13.990 --> 00:29:16.210
But the problem is that you're
adding complexity presently.

00:29:16.210 --> 00:29:18.470
And we're going to get
into why that's bad.

00:29:18.470 --> 00:29:22.430
And so I find that really
strictly designing for the

00:29:22.430 --> 00:29:24.500
present and for your present
requirements and for things

00:29:24.500 --> 00:29:27.350
that you know certainly
without excluding the

00:29:27.350 --> 00:29:29.820
possibility of future
requirements is the best way

00:29:29.820 --> 00:29:32.060
to accomplish this.

00:29:32.060 --> 00:29:33.906
Just basically to keep in mind
that there's going to be

00:29:33.906 --> 00:29:36.380
future requirements, and that
you want to keep your system

00:29:36.380 --> 00:29:37.770
easy to refactor.

00:29:37.770 --> 00:29:42.620
Not necessarily tiny numbers of
lines of code change, but

00:29:42.620 --> 00:29:45.000
small logical changes
or simple to make

00:29:45.000 --> 00:29:45.780
those logical changes.

00:29:45.780 --> 00:29:47.360
Easy to make those
logical changes.

00:29:47.360 --> 00:29:48.470
JAREK WILKIEWICZ: Though,
refactoring likely increase

00:29:48.470 --> 00:29:51.400
the number of lines of code that
need to change, right?

00:29:51.400 --> 00:29:51.810
MAX KANAT-ALEXANDER: Yes.

00:29:51.810 --> 00:29:52.950
So there is that trade-off.

00:29:52.950 --> 00:29:57.030
But what happens is, if you
design this way, you need to

00:29:57.030 --> 00:30:00.610
refactor less and less and
less as time goes on.

00:30:00.610 --> 00:30:03.480
And this is great because the
safest time to have defects in

00:30:03.480 --> 00:30:06.150
your system is when you're
very early in

00:30:06.150 --> 00:30:07.710
the development cycle.

00:30:07.710 --> 00:30:10.240
So the fact that there's more
refactoring at the beginning

00:30:10.240 --> 00:30:12.060
of the development cycle than
there is at the end is

00:30:12.060 --> 00:30:13.310
actually ideal.

00:30:15.730 --> 00:30:18.925
Now finally, well, this is
actually our final law, but we

00:30:18.925 --> 00:30:20.840
have finally gotten to
the keystone law.

00:30:20.840 --> 00:30:22.150
And this is the most important
part of the book.

00:30:22.150 --> 00:30:23.910
And this is the part that I
spend the longest time on,

00:30:23.910 --> 00:30:25.220
even though here we're
going to spend very

00:30:25.220 --> 00:30:26.520
little time on it.

00:30:26.520 --> 00:30:28.350
And that is the law
of simplicity.

00:30:28.350 --> 00:30:31.990
And it tells us how to reduce
the future effort of

00:30:31.990 --> 00:30:34.500
maintenance without
having to predict

00:30:34.500 --> 00:30:36.100
anything about the future.

00:30:36.100 --> 00:30:38.250
And it says the ease of
maintenance of any piece of

00:30:38.250 --> 00:30:40.820
software is proportional to
the simplicity of its

00:30:40.820 --> 00:30:42.370
individual pieces.

00:30:42.370 --> 00:30:44.220
And what do I mean
by simplicity?

00:30:44.220 --> 00:30:49.060
Well, the easiest way to think
about simplicity is, how easy

00:30:49.060 --> 00:30:54.290
can each piece of this system
be understood and correctly

00:30:54.290 --> 00:30:56.040
used by others?

00:30:56.040 --> 00:30:57.990
How fast is it for me to--

00:30:57.990 --> 00:30:59.270
I look at this piece of code.

00:30:59.270 --> 00:31:01.810
I understand exactly what its
purpose is, and I know

00:31:01.810 --> 00:31:04.650
instantly the right way to use
it so it's impossible for me

00:31:04.650 --> 00:31:06.840
to mess it up or make bugs with
it or introduce problems

00:31:06.840 --> 00:31:08.240
into the system.

00:31:08.240 --> 00:31:10.800
Now, you'll notice that I didn't
say the simplicity of

00:31:10.800 --> 00:31:14.340
the complexity of the whole
system, I said only its

00:31:14.340 --> 00:31:15.810
individual pieces.

00:31:15.810 --> 00:31:18.180
And the reason is that any
piece of software of

00:31:18.180 --> 00:31:22.820
reasonable size or even of
average size, is so complex

00:31:22.820 --> 00:31:25.460
that no human being can hold it
in their mind all at once.

00:31:25.460 --> 00:31:27.880
If you think of even pieces of
software with very simple

00:31:27.880 --> 00:31:28.440
feature sets.

00:31:28.440 --> 00:31:29.880
For example, Twitter.

00:31:29.880 --> 00:31:32.510
It does like fundamentally
three or four things when

00:31:32.510 --> 00:31:33.870
you're looking at it
from the outside.

00:31:33.870 --> 00:31:35.800
It's just a list of 140
characters things.

00:31:35.800 --> 00:31:37.070
You can follow people.

00:31:37.070 --> 00:31:38.380
They can follow you.

00:31:38.380 --> 00:31:39.380
You can search.

00:31:39.380 --> 00:31:41.180
You can make lists.

00:31:41.180 --> 00:31:43.230
And people have profiles.

00:31:43.230 --> 00:31:45.700
And that's really the major
functionality of the system.

00:31:45.700 --> 00:31:47.210
And talking to you about
it here, it's very

00:31:47.210 --> 00:31:47.850
easy to talk about.

00:31:47.850 --> 00:31:50.030
But I can promise you that
the code base of

00:31:50.030 --> 00:31:51.740
Twitter is so complex--

00:31:51.740 --> 00:31:54.750
I haven't seen it, but I'm sure
that no human being could

00:31:54.750 --> 00:31:56.300
hold it in their mind
all at once.

00:31:56.300 --> 00:31:58.950
So you always have a
very complex system

00:31:58.950 --> 00:32:00.360
for your entire system.

00:32:00.360 --> 00:32:03.080
And your only hope is to the
parts that people need--

00:32:03.080 --> 00:32:06.390
but the thing is, nobody needs
to understand the entire

00:32:06.390 --> 00:32:08.520
system all at once in
order to modify it.

00:32:08.520 --> 00:32:11.010
If they do, your system is
hopelessly complex and

00:32:11.010 --> 00:32:12.760
impossible to modify.

00:32:12.760 --> 00:32:15.090
That is a system where you
have not enough design.

00:32:15.090 --> 00:32:17.200
This sort of ties back into
our earlier system.

00:32:17.200 --> 00:32:19.590
And what you're trying to do is
you're trying to make the

00:32:19.590 --> 00:32:21.860
parts that people need to modify
or the parts people

00:32:21.860 --> 00:32:24.570
need to understand, simple
enough that they can

00:32:24.570 --> 00:32:25.750
understand and modify them.

00:32:25.750 --> 00:32:28.030
And this also gives you
guidelines for sort of how you

00:32:28.030 --> 00:32:29.060
would componentize
your system.

00:32:29.060 --> 00:32:32.820
You would componentize it in a
way that people can understand

00:32:32.820 --> 00:32:35.080
the parts that they
need to change.

00:32:35.080 --> 00:32:37.665
It's also important because
complexity is compounding.

00:32:40.810 --> 00:32:47.780
So when you have one piece of
your system and it adds

00:32:47.780 --> 00:32:49.430
complexity, and then you have
another piece of your system,

00:32:49.430 --> 00:32:51.760
you add another change and
it adds complexity.

00:32:51.760 --> 00:32:53.680
And then you add another change
and it adds complexity

00:32:53.680 --> 00:32:55.780
to the whole system, you're
increasing the complexity of

00:32:55.780 --> 00:32:58.130
each previous piece every time
you add a new piece.

00:32:58.130 --> 00:33:02.420
And so you need to be sure that
you're focusing on the

00:33:02.420 --> 00:33:05.010
simplicity of the individual
pieces, so that they're adding

00:33:05.010 --> 00:33:07.070
as little complexity as possible
to the rest of the

00:33:07.070 --> 00:33:09.380
system, or so that they're not
compounding the complexity of

00:33:09.380 --> 00:33:12.320
the entire system.

00:33:12.320 --> 00:33:15.770
And as far as how you accomplish
this and where this

00:33:15.770 --> 00:33:18.630
complexity comes from, that's
a whole chapter of the book,

00:33:18.630 --> 00:33:21.260
which is actually, many
sub-chapters.

00:33:21.260 --> 00:33:22.610
It's the largest part
of the book.

00:33:22.610 --> 00:33:25.220
JAREK WILKIEWICZ: And in your
experience, how do you measure

00:33:25.220 --> 00:33:26.890
simplicity or complexity?

00:33:26.890 --> 00:33:28.950
I know in the past people have
used, like cyclomatic

00:33:28.950 --> 00:33:31.540
complexity to try to use tools
and things like that.

00:33:31.540 --> 00:33:33.650
How do you actually do that?

00:33:33.650 --> 00:33:36.880
Is it something that we just
know or something more formal?

00:33:36.880 --> 00:33:39.900
Or do you get into that in-depth
in the book and we

00:33:39.900 --> 00:33:41.760
should just refer our live
viewers today to the book?

00:33:41.760 --> 00:33:41.950
MAX KANAT-ALEXANDER: No,

00:33:41.950 --> 00:33:43.760
actually, it's a good question.

00:33:43.760 --> 00:33:46.800
So I think that in
the industry--

00:33:46.800 --> 00:33:49.560
and there has been a lot of
opposition to metrics, because

00:33:49.560 --> 00:33:53.190
they've been misused to judge
developers, to judge

00:33:53.190 --> 00:33:54.740
individual developers.

00:33:54.740 --> 00:33:57.250
I think metrics are valuable.

00:33:57.250 --> 00:33:59.940
And they can give you hints
of where you should

00:33:59.940 --> 00:34:00.820
look at your code.

00:34:00.820 --> 00:34:03.260
Things like cyclomatic
complexity can be useful for

00:34:03.260 --> 00:34:04.720
understanding the complexity--

00:34:04.720 --> 00:34:07.510
finding your most complex
functions.

00:34:07.510 --> 00:34:09.960
Cyclomatic complexity is not
necessarily good for finding,

00:34:09.960 --> 00:34:13.330
say, the complexity of your
entire system, or even of a

00:34:13.330 --> 00:34:14.360
whole class.

00:34:14.360 --> 00:34:16.304
But it's good for finding
some bad candidates.

00:34:19.100 --> 00:34:21.070
If your code base is
particularly problematic, then

00:34:21.070 --> 00:34:25.270
it's going to find those most
problematic functions.

00:34:25.270 --> 00:34:29.010
But it's not the most reliable
indicator of complexity of the

00:34:29.010 --> 00:34:30.909
whole system.

00:34:30.909 --> 00:34:33.949
In my experience, the most
reliable indicator of

00:34:33.949 --> 00:34:37.060
complexity of the system is
asking the developers what

00:34:37.060 --> 00:34:38.489
they think.

00:34:38.489 --> 00:34:42.760
Because most developers in most
systems have a sense of--

00:34:42.760 --> 00:34:45.860
even if they don't have a sense
of this is complex, they

00:34:45.860 --> 00:34:48.380
have a sense of this is
frustrating or I can't move as

00:34:48.380 --> 00:34:50.940
quickly as I need to.

00:34:50.940 --> 00:34:53.670
Or it's hard to make changes
to this part of the system.

00:34:53.670 --> 00:34:56.110
They have a sense of fragility,
which indicates

00:34:56.110 --> 00:34:57.540
complexity.

00:34:57.540 --> 00:34:59.880
And they have a sense of
velocity, which indicates

00:34:59.880 --> 00:35:00.860
complexity.

00:35:00.860 --> 00:35:02.790
And the nice thing about that
is it's a relatively

00:35:02.790 --> 00:35:03.590
independent metric.

00:35:03.590 --> 00:35:06.990
You don't need some other metric
to measure it against.

00:35:06.990 --> 00:35:10.000
And like I said, there is a
social science aspect to

00:35:10.000 --> 00:35:11.250
software engineering.

00:35:11.250 --> 00:35:16.810
And so I'm more likely
to go and--

00:35:16.810 --> 00:35:19.060
and there's also, of course,
quote unquote, "expert

00:35:19.060 --> 00:35:21.430
judgement." Expert judgment
is also a reasonable

00:35:21.430 --> 00:35:23.310
way of doing this.

00:35:23.310 --> 00:35:25.350
If you have somebody who is an
expert and they look at the

00:35:25.350 --> 00:35:28.780
system and they say, well,
this is pretty complex.

00:35:28.780 --> 00:35:31.910
And then you can validate that
with all the other developers

00:35:31.910 --> 00:35:34.300
saying, oh, yeah, we agree that
there's a problem here.

00:35:34.300 --> 00:35:36.800
Maybe they don't see that the
problem is complexity, but

00:35:36.800 --> 00:35:38.210
they see there's
a problem here.

00:35:38.210 --> 00:35:40.290
That's much more what
I tend to go on.

00:35:40.290 --> 00:35:42.280
When I come into a project and
I want to find out what the

00:35:42.280 --> 00:35:44.720
complexity is like, I go around
and I talk to the

00:35:44.720 --> 00:35:45.540
individual developers.

00:35:45.540 --> 00:35:47.000
I say, what's blocking you?

00:35:47.000 --> 00:35:49.300
What are the problems
that you have?

00:35:49.300 --> 00:35:50.010
What's frustrating?

00:35:50.010 --> 00:35:50.940
Are there other teams?

00:35:50.940 --> 00:35:52.390
Are there other parts of the
system that you find

00:35:52.390 --> 00:35:54.130
hard to work with?

00:35:54.130 --> 00:35:55.650
JAREK WILKIEWICZ: I guess it's
no secret that Google does a

00:35:55.650 --> 00:35:56.680
lot of code reviews.

00:35:56.680 --> 00:35:59.540
So I think for developers who
are watching us right now,

00:35:59.540 --> 00:36:02.340
they could also use the code
review process as a great

00:36:02.340 --> 00:36:06.070
indication of simplicity or
complexity of their modules

00:36:06.070 --> 00:36:07.370
based on the feedback
they're getting?

00:36:07.370 --> 00:36:08.370
MAX KANAT-ALEXANDER:
Yeah, absolutely.

00:36:08.370 --> 00:36:10.570
I mean, particularly if you
have good code reviewers.

00:36:10.570 --> 00:36:12.860
One of the things I'd love to
do some day is write a book

00:36:12.860 --> 00:36:15.430
about good code review because
I actually have a lot to say

00:36:15.430 --> 00:36:17.290
about it and I've never really
gotten to write it up.

00:36:17.290 --> 00:36:19.270
But there's a lot of good
things to know there.

00:36:19.270 --> 00:36:21.080
Actually, just since you asked,
I'm going to talk about

00:36:21.080 --> 00:36:21.850
a couple of them.

00:36:21.850 --> 00:36:23.890
One of them is you want to make
sure that you understand

00:36:23.890 --> 00:36:25.010
every line of code.

00:36:25.010 --> 00:36:26.930
And you never want to assume
that you don't understand it

00:36:26.930 --> 00:36:29.420
just because you're stupid.

00:36:29.420 --> 00:36:31.390
Because software is a
knowledge system.

00:36:31.390 --> 00:36:33.440
This is actually the philosophy
that underlies code

00:36:33.440 --> 00:36:34.600
simplicity on all
these things.

00:36:34.600 --> 00:36:37.470
There's this sort of philosophy
of knowledge that

00:36:37.470 --> 00:36:38.150
underlies it.

00:36:38.150 --> 00:36:41.300
And it's that software is
a system of knowledge.

00:36:41.300 --> 00:36:42.420
That's basically what
it is, right?

00:36:42.420 --> 00:36:45.610
That's what code is,
is it's just the

00:36:45.610 --> 00:36:47.155
representation of ideas.

00:36:50.510 --> 00:36:52.430
Since they're ideas, what's most
important about that is

00:36:52.430 --> 00:36:54.560
that they can be understood
or seen.

00:36:54.560 --> 00:36:57.410
And if you're being communicated
an idea that you

00:36:57.410 --> 00:37:00.740
can't understand, then you
shouldn't assume that it's

00:37:00.740 --> 00:37:01.760
because you're stupid.

00:37:01.760 --> 00:37:04.020
You should assume that it's
because the idea is too hard

00:37:04.020 --> 00:37:05.100
to understand.

00:37:05.100 --> 00:37:07.790
You are also a programmer,
right?

00:37:07.790 --> 00:37:10.130
If I had to pick just one thing
to talk to people about

00:37:10.130 --> 00:37:12.810
code review, I'd be like, just
keep asking people, could you

00:37:12.810 --> 00:37:13.360
clarify this?

00:37:13.360 --> 00:37:14.130
Could you clarify this?

00:37:14.130 --> 00:37:16.310
Could you clarify this?

00:37:16.310 --> 00:37:16.715
JAREK WILKIEWICZ: Cool.

00:37:16.715 --> 00:37:17.120
Very helpful.

00:37:17.120 --> 00:37:19.580
MAX KANAT-ALEXANDER: Yeah.

00:37:19.580 --> 00:37:20.050
Great.

00:37:20.050 --> 00:37:23.310
And that brings us to
our last law, which

00:37:23.310 --> 00:37:25.840
is the law of testing.

00:37:25.840 --> 00:37:28.820
There's this famous quote from
Knuth, which is "Beware of

00:37:28.820 --> 00:37:31.610
bugs in the above code, I have
only proved it correct.

00:37:31.610 --> 00:37:35.550
I have not actually
tried to run it."

00:37:35.550 --> 00:37:40.830
And basically, what this tells
us is that to a large degree,

00:37:40.830 --> 00:37:43.650
what we know about code we know
empirically, which means

00:37:43.650 --> 00:37:48.620
by observation, by test
or experiment.

00:37:48.620 --> 00:37:51.870
The system is so complex that
it's hard to make judgements

00:37:51.870 --> 00:37:53.340
about it or statements about
in the abstract.

00:37:53.340 --> 00:37:55.930
Also, software runs on real
machines and you can't always

00:37:55.930 --> 00:37:59.080
predict the behavior of the real
world in response to your

00:37:59.080 --> 00:38:01.290
software without actually
running the real world against

00:38:01.290 --> 00:38:03.750
your software.

00:38:03.750 --> 00:38:07.200
And our law here is that the
degree to which you know how

00:38:07.200 --> 00:38:09.500
your software behaves is
the degree to which

00:38:09.500 --> 00:38:10.770
you've tested it.

00:38:10.770 --> 00:38:13.350
And another way to say this
would be unless you tested it,

00:38:13.350 --> 00:38:14.640
you don't know if it works.

00:38:14.640 --> 00:38:15.950
But what does works mean?

00:38:15.950 --> 00:38:16.860
People don't tell you.

00:38:16.860 --> 00:38:18.490
Like, I hear a lot of people,
particularly in the field of

00:38:18.490 --> 00:38:21.130
testing say, oh, we want to be
sure that the software works.

00:38:21.130 --> 00:38:22.110
But what does works mean?

00:38:22.110 --> 00:38:25.160
Works means it behaves as
you intended it to.

00:38:25.160 --> 00:38:26.930
And that's what your tests
are really telling you.

00:38:26.930 --> 00:38:28.970
They're not really telling you
works or doesn't work.

00:38:28.970 --> 00:38:31.000
They're telling you about the
behavior of your system.

00:38:31.000 --> 00:38:34.090
And the nice thing about this
law is it helps us have an

00:38:34.090 --> 00:38:37.660
idea of what we should test
and how we should test it,

00:38:37.660 --> 00:38:40.240
which I think can be very
contentious facts in a team

00:38:40.240 --> 00:38:42.360
when you don't have
some guideline.

00:38:42.360 --> 00:38:45.600
Otherwise, people just start
looking at code coverage.

00:38:45.600 --> 00:38:48.580
They say, oh, well, our goal is
to have 100% code coverage.

00:38:48.580 --> 00:38:51.260
But you might have tests which
run the code but aren't

00:38:51.260 --> 00:38:53.550
actually testing the behavior or
telling you anything about

00:38:53.550 --> 00:38:54.660
the behavior of it.

00:38:54.660 --> 00:38:57.470
And thus, aren't valid test,
even though your coverage

00:38:57.470 --> 00:38:58.720
number is very high.

00:39:02.830 --> 00:39:06.730
So people often ask me, well,
so we've got these laws.

00:39:06.730 --> 00:39:07.720
How do I actually use them?

00:39:07.720 --> 00:39:09.310
Well, like I said, you
use them to make

00:39:09.310 --> 00:39:10.120
decisions about software.

00:39:10.120 --> 00:39:13.010
And so I'm going to go over a
couple of situations that

00:39:13.010 --> 00:39:15.560
people commonly come across and
say how we can apply the

00:39:15.560 --> 00:39:18.610
laws to make sensible and good
decisions in those areas.

00:39:18.610 --> 00:39:20.990
So first, let's try answering
a question.

00:39:20.990 --> 00:39:22.870
A common question is,
I've got a test.

00:39:22.870 --> 00:39:24.440
Should I have a mock
in this test?

00:39:24.440 --> 00:39:25.640
Should I mock out some
part of this test?

00:39:25.640 --> 00:39:27.680
And for anybody who's watching
who doesn't know, a mock is

00:39:27.680 --> 00:39:30.560
basically a piece-- a fake part
of the system that you

00:39:30.560 --> 00:39:34.750
use to ensure reliability
or speed.

00:39:34.750 --> 00:39:36.720
There's just some part of your
system that you don't want to

00:39:36.720 --> 00:39:38.600
have there in your test, you
don't want to have the real

00:39:38.600 --> 00:39:41.110
one, so you want to
use a fake piece.

00:39:41.110 --> 00:39:43.960
So we basically have three
principles we can use to

00:39:43.960 --> 00:39:46.090
evaluate the decision of
when to use a mock.

00:39:46.090 --> 00:39:47.910
And the first is that--

00:39:47.910 --> 00:39:50.030
our law of testing, which we
just went over, the degree to

00:39:50.030 --> 00:39:51.810
which you know how your software
behaves is the degree

00:39:51.810 --> 00:39:53.000
to which you've tested it.

00:39:53.000 --> 00:39:55.250
When you have a mock
in your test, you

00:39:55.250 --> 00:39:56.870
are testing the mock.

00:39:56.870 --> 00:39:59.320
You are not testing
the system.

00:39:59.320 --> 00:40:02.570
And you have to realize that
you might be overlooking an

00:40:02.570 --> 00:40:06.250
interaction between your
component and the other

00:40:06.250 --> 00:40:09.170
component that is not
being tested because

00:40:09.170 --> 00:40:09.970
you're testing the mock.

00:40:09.970 --> 00:40:13.110
And testing the mock is
inherently useless.

00:40:13.110 --> 00:40:15.920
You care how your software
behaves, you don't care how

00:40:15.920 --> 00:40:16.630
your mock behaves.

00:40:16.630 --> 00:40:20.340
That's not what you're
trying to figure out.

00:40:20.340 --> 00:40:23.930
Secondly, is that the longer
your program exists, the more

00:40:23.930 --> 00:40:27.440
probable it is that any piece
of it will have to change.

00:40:27.440 --> 00:40:29.280
And tests are also part
of your system.

00:40:29.280 --> 00:40:30.460
They're also code
in the system.

00:40:30.460 --> 00:40:32.540
And you're going to have to
maintain the test just like

00:40:32.540 --> 00:40:35.100
you're going to have to maintain
the software itself.

00:40:35.100 --> 00:40:37.880
And when you add mocks, you're
adding more code.

00:40:37.880 --> 00:40:39.220
You're adding more code
both to the mocks.

00:40:39.220 --> 00:40:41.190
And frequently, you're also
adding more code to the tests

00:40:41.190 --> 00:40:41.690
themselves.

00:40:41.690 --> 00:40:44.520
And this is adding to your
effort of maintenance.

00:40:44.520 --> 00:40:48.460
However, the purpose of software
is to help people.

00:40:48.460 --> 00:40:50.050
And even tests have
this purpose.

00:40:50.050 --> 00:40:51.530
Who are tests helping?

00:40:51.530 --> 00:40:53.470
Tests are helping a fair bit,
a fair number of people.

00:40:53.470 --> 00:40:56.600
But mostly, most importantly,
tests are helping the

00:40:56.600 --> 00:40:57.850
developers.

00:41:00.930 --> 00:41:02.890
Really, this is senior
to all other things.

00:41:02.890 --> 00:41:05.360
The purpose of software to help
people is senior to all

00:41:05.360 --> 00:41:05.780
other things.

00:41:05.780 --> 00:41:08.710
You can disregard all things if
you believe that you have

00:41:08.710 --> 00:41:13.100
an argument which means this
will help people more.

00:41:13.100 --> 00:41:16.290
And since tests are helping
programmers, there's a couple

00:41:16.290 --> 00:41:18.600
of things that don't
help programmers.

00:41:18.600 --> 00:41:23.140
And those are slow tests
and flaky tests.

00:41:23.140 --> 00:41:25.040
And by flaky tests, for anybody
who doesn't know, I

00:41:25.040 --> 00:41:26.790
mean tests that--

00:41:26.790 --> 00:41:29.655
they fail when there's nothing
wrong with your software.

00:41:29.655 --> 00:41:32.330
And they fail randomly and
they aren't predictive.

00:41:32.330 --> 00:41:39.150
So if a mock makes
your test faster,

00:41:39.150 --> 00:41:40.690
then that helps people.

00:41:40.690 --> 00:41:45.430
And that is a really good
use of the mock.

00:41:45.430 --> 00:41:48.240
If it turns a test that is
unreliable into a test that is

00:41:48.240 --> 00:41:51.380
reliable, then that's also
a very good mock.

00:41:51.380 --> 00:41:53.400
There might be some
non-deterministic behavior and

00:41:53.400 --> 00:41:55.610
you need to make that behavior
deterministic for your test.

00:41:55.610 --> 00:41:57.750
And that's a very good
case to use a mock.

00:41:57.750 --> 00:42:00.850
But we should take it into
consideration the previous two

00:42:00.850 --> 00:42:04.960
things, so the law of testing,
which tells us that when we

00:42:04.960 --> 00:42:07.440
fake things, we probably want
to fake as little of them as

00:42:07.440 --> 00:42:10.040
possible as we need to make
things fast or deterministic

00:42:10.040 --> 00:42:12.430
or helpful to the people who are
running the tests in some

00:42:12.430 --> 00:42:14.920
way or another, helpful to the
developer of the tests or

00:42:14.920 --> 00:42:16.020
helpful to the other
developers who

00:42:16.020 --> 00:42:16.830
are running the test.

00:42:16.830 --> 00:42:18.880
By the way, I want to point
that out, that it's not

00:42:18.880 --> 00:42:21.910
necessarily the developer who's
writing the test who is

00:42:21.910 --> 00:42:24.820
being helped by the test, it
is the other developers who

00:42:24.820 --> 00:42:26.730
are using the system and who
want to know that their

00:42:26.730 --> 00:42:30.030
changes didn't break you.

00:42:30.030 --> 00:42:31.090
They're some of the
most important

00:42:31.090 --> 00:42:32.380
people to care about.

00:42:32.380 --> 00:42:34.690
People who can have certainty
that they don't need to

00:42:34.690 --> 00:42:37.430
manually test every part of your
system just because they

00:42:37.430 --> 00:42:38.715
change something about
their system.

00:42:41.980 --> 00:42:45.080
But we want to be sure that
we're mocking out as little as

00:42:45.080 --> 00:42:46.900
we need in order for
them to be helpful.

00:42:46.900 --> 00:42:51.340
And that also helps keep our
mocks small in general, so

00:42:51.340 --> 00:42:53.220
that they don't need
to be maintained.

00:42:53.220 --> 00:42:55.290
Or you want to have one
centralized mock, so that it's

00:42:55.290 --> 00:42:57.750
easier to maintain just that
one mock and you're not

00:42:57.750 --> 00:43:00.880
inventing a bunch of
mocks all the time.

00:43:00.880 --> 00:43:02.540
JAREK WILKIEWICZ: One comment
I have about this is, in my

00:43:02.540 --> 00:43:08.260
experience, using mocks in my
unit tests was very beneficial

00:43:08.260 --> 00:43:10.170
to the speed and reliability.

00:43:10.170 --> 00:43:12.730
But I found that most of my bugs
were actually found in

00:43:12.730 --> 00:43:16.610
integration tests, which
use the real system.

00:43:16.610 --> 00:43:18.660
But then those where typically
unreliable

00:43:18.660 --> 00:43:20.190
and slow and so forth.

00:43:20.190 --> 00:43:23.260
So it's always difficult
to reconcile these two

00:43:23.260 --> 00:43:25.260
conflicting goals.

00:43:25.260 --> 00:43:27.190
So how do you do that
in your experience?

00:43:27.190 --> 00:43:28.660
MAX KANAT-ALEXANDER: So there's
a couple of ways to

00:43:28.660 --> 00:43:29.320
accomplish it.

00:43:29.320 --> 00:43:31.530
Obviously, the ideal way to
accomplish it is to design

00:43:31.530 --> 00:43:37.030
your system in such a way that
you don't need to mock out

00:43:37.030 --> 00:43:39.400
very much in order for the
system to be fast or

00:43:39.400 --> 00:43:40.880
deterministic.

00:43:40.880 --> 00:43:43.290
All you need to do is mock out
the network, like the I/O

00:43:43.290 --> 00:43:45.710
calls for example, and then
everything else is fast enough

00:43:45.710 --> 00:43:47.070
for the tests to run.

00:43:47.070 --> 00:43:49.080
And your goal should be that the
tests run in a couple of

00:43:49.080 --> 00:43:50.410
seconds, ideally.

00:43:50.410 --> 00:43:53.280
Because what you want is you
want a test suite that

00:43:53.280 --> 00:43:55.290
developers can run over and over
and over while they're

00:43:55.290 --> 00:43:57.030
doing development.

00:43:57.030 --> 00:43:59.310
Like when you save a file, it'd
be great if the test just

00:43:59.310 --> 00:44:03.150
ran instantly so you knew,
oh, look, I've got a bug.

00:44:03.150 --> 00:44:04.780
Nobody will even see
it in production.

00:44:04.780 --> 00:44:07.190
Sometimes people will say, oh,
my tests aren't useful because

00:44:07.190 --> 00:44:11.010
they never fail on the
continuous integration build,

00:44:11.010 --> 00:44:13.620
on the continuous build.

00:44:13.620 --> 00:44:15.840
But that's not where tests
are most useful.

00:44:15.840 --> 00:44:18.170
Tests are most useful for the
developer who's actually

00:44:18.170 --> 00:44:24.880
making the changes right now and
letting them know that as

00:44:24.880 --> 00:44:26.750
they go, oh, look, I've
made a mistake.

00:44:26.750 --> 00:44:28.800
I can immediately fix
that mistake.

00:44:28.800 --> 00:44:31.950
The CI system, the Continuous
Integration system, that's

00:44:31.950 --> 00:44:34.250
useful for the release
engineers, so that they know

00:44:34.250 --> 00:44:36.080
that things aren't broken.

00:44:36.080 --> 00:44:38.970
And it's useful for the
architects of the system so

00:44:38.970 --> 00:44:40.500
that they can see, oh, things
are going wrong.

00:44:44.240 --> 00:44:47.430
So another way to deal with
this is just to have split

00:44:47.430 --> 00:44:51.550
test suites, is to have the fast
tests that run while the

00:44:51.550 --> 00:44:53.890
developers are working, and
then the integration tests

00:44:53.890 --> 00:44:55.960
only run in continuous
integration.

00:44:55.960 --> 00:45:00.070
it's a less ideal situation
because it means, like you

00:45:00.070 --> 00:45:02.160
said, that you won't
catch as many bugs.

00:45:05.380 --> 00:45:07.700
It really depends
on the project.

00:45:07.700 --> 00:45:12.790
With a smaller number of
developers, I err on the side

00:45:12.790 --> 00:45:15.750
of just making everything
an integration test.

00:45:15.750 --> 00:45:18.810
And with a larger number of
developers, I err on the side

00:45:18.810 --> 00:45:19.830
of faster tests.

00:45:19.830 --> 00:45:20.245
JAREK WILKIEWICZ: Cool.

00:45:20.245 --> 00:45:21.490
I think that's a
good heuristic.

00:45:21.490 --> 00:45:21.760
MAX KANAT-ALEXANDER: Yeah.

00:45:21.760 --> 00:45:24.250
JAREK WILKIEWICZ: Thanks.

00:45:24.250 --> 00:45:25.330
MAX KANAT-ALEXANDER:
So next, let's

00:45:25.330 --> 00:45:28.100
look at a design question.

00:45:28.100 --> 00:45:30.200
One question that comes up is,
should I design this piece of

00:45:30.200 --> 00:45:31.030
code defensively?

00:45:31.030 --> 00:45:34.150
That is, should I make sure
that it doesn't crash no

00:45:34.150 --> 00:45:35.750
matter what happens
possibly, right?

00:45:35.750 --> 00:45:41.240
Like it handles all possible
inputs, and it clones all the

00:45:41.240 --> 00:45:43.120
objects that you pass it so
that it doesn't modify

00:45:43.120 --> 00:45:44.500
anything outside of it.

00:45:44.500 --> 00:45:47.090
And it does a bunch of things to
make sure that nothing bad

00:45:47.090 --> 00:45:48.240
ever happens.

00:45:48.240 --> 00:45:51.660
So the first question, the first
principle we can use

00:45:51.660 --> 00:45:53.690
here, is that the ease of
maintenance of any piece of

00:45:53.690 --> 00:45:55.470
software is proportional to
the simplicity of its

00:45:55.470 --> 00:45:56.720
individual pieces.

00:45:59.940 --> 00:46:01.580
And there's also the equation
of software design that I've

00:46:01.580 --> 00:46:04.790
got there, where we care about
the effort of future

00:46:04.790 --> 00:46:05.730
maintenance.

00:46:05.730 --> 00:46:06.830
So that's really what
we care about.

00:46:06.830 --> 00:46:12.300
And when we are adding code to
the system, we are usually

00:46:12.300 --> 00:46:13.200
making it more complex.

00:46:13.200 --> 00:46:14.530
That's not always true.

00:46:14.530 --> 00:46:17.560
But if you're adding code that
adds logical components, like

00:46:17.560 --> 00:46:19.720
actual new logic to the system,
then you are adding

00:46:19.720 --> 00:46:20.990
complexity.

00:46:20.990 --> 00:46:24.300
Sometimes more code is simpler,
like longer names are

00:46:24.300 --> 00:46:25.480
sometimes a little bit better
than shorter name.

00:46:25.480 --> 00:46:27.340
It depends on the circumstance,
and I talk about

00:46:27.340 --> 00:46:29.692
that in the book, too.

00:46:29.692 --> 00:46:32.630
Including a guideline about
how to name things, which

00:46:32.630 --> 00:46:34.120
people have found
fairly helpful.

00:46:37.540 --> 00:46:39.850
But in this case, when we're
adding defensiveness, we are

00:46:39.850 --> 00:46:41.460
definitely adding complexity.

00:46:41.460 --> 00:46:45.970
When we're handling all kinds
of different inputs, we're

00:46:45.970 --> 00:46:46.480
adding complexity.

00:46:46.480 --> 00:46:48.080
Also, as I mentioned
before, software

00:46:48.080 --> 00:46:49.590
is a system of knowledge.

00:46:49.590 --> 00:46:55.260
And if you hide errors, you
are making it hard to know

00:46:55.260 --> 00:46:57.800
things about the system, which
is the most important thing

00:46:57.800 --> 00:47:00.040
that you want to be able to do,
is you want to be able to

00:47:00.040 --> 00:47:02.120
reason about or make
statements about

00:47:02.120 --> 00:47:04.820
your software systems.

00:47:04.820 --> 00:47:08.610
And when you hide errors, it
becomes very difficult to

00:47:08.610 --> 00:47:11.520
reason about the behavior
of the system.

00:47:11.520 --> 00:47:12.960
Particularly for
the developers.

00:47:12.960 --> 00:47:16.660
However, as I mentioned before,
the future is full of

00:47:16.660 --> 00:47:18.490
unforeseeable consequences.

00:47:18.490 --> 00:47:21.880
And some functions, or some
classes, or some scripts, or

00:47:21.880 --> 00:47:26.060
some binaries, are in situations
where they can't

00:47:26.060 --> 00:47:28.340
predict the input that
they're going to get.

00:47:28.340 --> 00:47:29.850
So there's really a divide.

00:47:29.850 --> 00:47:33.690
There's internal code, which
can predict and make a

00:47:33.690 --> 00:47:36.360
contract with the rest of the
system about what input it

00:47:36.360 --> 00:47:39.850
accepts, and then there's
external externally-facing

00:47:39.850 --> 00:47:44.660
code, which cannot predict the
input it's going to get.

00:47:44.660 --> 00:47:48.180
And in this case, you have to
be defensive because of the

00:47:48.180 --> 00:47:50.520
unforeseeable consequences
of the future.

00:47:50.520 --> 00:47:53.510
And sometimes also, like at a
very high level of the system,

00:47:53.510 --> 00:47:56.940
you want to have an exception
handler that's like, we don't

00:47:56.940 --> 00:47:58.450
want to crash the system.

00:47:58.450 --> 00:48:02.360
Obviously, if the YouTube API
crashed every time that it got

00:48:02.360 --> 00:48:06.180
unexpected input, we wouldn't
have a YouTube API.

00:48:06.180 --> 00:48:08.380
It just wouldn't
be functioning.

00:48:08.380 --> 00:48:12.110
It gets unexpected input
continuously.

00:48:12.110 --> 00:48:16.300
So in this case, that
defensiveness is critical.

00:48:16.300 --> 00:48:18.800
But when you look at structuring
your code for

00:48:18.800 --> 00:48:20.380
this, you still want to
consider the ease of

00:48:20.380 --> 00:48:22.150
maintenance and simplicity.

00:48:22.150 --> 00:48:24.310
So what you want to probably
do is, if you know that

00:48:24.310 --> 00:48:27.270
there's a whole section or part
of the system that you're

00:48:27.270 --> 00:48:29.440
going to want to have be
defensive, you want to try to

00:48:29.440 --> 00:48:32.000
come up with a framework that
actually makes it as easy to

00:48:32.000 --> 00:48:34.770
maintain this defensiveness
as possible.

00:48:34.770 --> 00:48:36.450
And it's not just a bunch
of custom code in

00:48:36.450 --> 00:48:38.280
every single function.

00:48:38.280 --> 00:48:40.160
People have validation
frameworks and you want to try

00:48:40.160 --> 00:48:41.190
to evaluate--

00:48:41.190 --> 00:48:42.400
find a good validation
framework.

00:48:42.400 --> 00:48:44.580
And I talk in the book about how
to evaluate technologies

00:48:44.580 --> 00:48:46.780
and you can use some of
those principles.

00:48:46.780 --> 00:48:48.780
And so that gives us
a pretty good way

00:48:48.780 --> 00:48:49.720
of making this decision.

00:48:49.720 --> 00:48:53.410
And I think one of the things
that I've tried to show in

00:48:53.410 --> 00:48:56.050
this talk is that these are
not dogmatic principles.

00:48:56.050 --> 00:48:58.260
I'm not telling you
what to do.

00:48:58.260 --> 00:49:01.090
Instead, I'm telling you how
to make judgments in the

00:49:01.090 --> 00:49:02.020
situation that you're in.

00:49:02.020 --> 00:49:04.100
Because honestly, every
development

00:49:04.100 --> 00:49:05.080
situation is different.

00:49:05.080 --> 00:49:07.110
Every development situation
is custom.

00:49:07.110 --> 00:49:09.960
And only the people on the
ground and who are looking at

00:49:09.960 --> 00:49:12.690
that system right there can
make accurate judgments.

00:49:12.690 --> 00:49:15.210
There's no dogmatic
system that works

00:49:15.210 --> 00:49:17.430
in 100% of the time.

00:49:17.430 --> 00:49:20.465
The only reliable system
is developer judgment.

00:49:24.910 --> 00:49:28.170
And that brings us, if my slide
will advance, to the end

00:49:28.170 --> 00:49:29.110
of the talk.

00:49:29.110 --> 00:49:30.810
As I said, I have a blog.

00:49:30.810 --> 00:49:32.840
I'm also available for
speaking stuff.

00:49:32.840 --> 00:49:36.420
I'm happy to come to companies
and talk to people.

00:49:36.420 --> 00:49:40.460
This is really my
mission in life.

00:49:40.460 --> 00:49:42.480
As far as money, I
work at Google.

00:49:42.480 --> 00:49:43.940
I get paid fine.

00:49:43.940 --> 00:49:46.850
I have no problem with that.

00:49:46.850 --> 00:49:50.890
And so I'm not here just
to make money.

00:49:50.890 --> 00:49:53.040
I'm here really to help people
out and that's one of the

00:49:53.040 --> 00:49:54.360
reasons I like to go
around and talk.

00:49:54.360 --> 00:49:57.650
And there's also a book that I
wrote, which you can get to

00:49:57.650 --> 00:49:58.150
from the link.

00:49:58.150 --> 00:49:59.960
And it has lots of other
things, like where does

00:49:59.960 --> 00:50:01.600
complexity come from?

00:50:01.600 --> 00:50:03.590
It has a checklist that tells
you when you should rewrite

00:50:03.590 --> 00:50:04.500
your system.

00:50:04.500 --> 00:50:06.560
It has a checklist that tells
you when you should choose to

00:50:06.560 --> 00:50:09.750
reinvent the wheel, so reinvent
an existing system.

00:50:09.750 --> 00:50:11.530
And it has a ton of real-world
examples for

00:50:11.530 --> 00:50:13.890
all of these things.

00:50:13.890 --> 00:50:15.760
JAREK WILKIEWICZ: This is a
great segue to a couple of the

00:50:15.760 --> 00:50:17.530
questions that we have
in our moderator.

00:50:17.530 --> 00:50:20.270
I was just looking and let's go

00:50:20.270 --> 00:50:21.480
through this pretty quickly.

00:50:21.480 --> 00:50:25.290
These are from Tim Wintle, who
is our Google Developer Expert

00:50:25.290 --> 00:50:27.560
based out in UK.

00:50:27.560 --> 00:50:28.930
Hello, Tim.

00:50:28.930 --> 00:50:32.550
So first question, "In the
equation of software design,

00:50:32.550 --> 00:50:34.990
how would you value
a blocking change?

00:50:34.990 --> 00:50:37.960
For example, an underlying
infrastructure change which

00:50:37.960 --> 00:50:40.770
doesn't reduce maintenance or
add value immediately, but

00:50:40.770 --> 00:50:42.820
opens up a whole range
of possible

00:50:42.820 --> 00:50:44.610
features, potential value?

00:50:44.610 --> 00:50:45.640
MAX KANAT-ALEXANDER: That's
a great question.

00:50:45.640 --> 00:50:47.780
So I would look at that as
future value, which is

00:50:47.780 --> 00:50:51.460
actually really great.

00:50:51.460 --> 00:50:55.282
And it's important that it be
based on something that you

00:50:55.282 --> 00:50:56.830
know is needed now.

00:50:56.830 --> 00:51:00.960
You can look at the present
situation and you can be like,

00:51:00.960 --> 00:51:03.830
we know that this scaling
situation is needed, or we

00:51:03.830 --> 00:51:05.800
know that this piece of
infrastructure needs to be

00:51:05.800 --> 00:51:07.960
used by the developers
in a particular way.

00:51:07.960 --> 00:51:12.150
We've gone to the developers and
we've actually asked them,

00:51:12.150 --> 00:51:13.890
what specifically do you need?

00:51:13.890 --> 00:51:16.355
And then, we implemented
that specific thing.

00:51:16.355 --> 00:51:19.190
Or we used our judgment to
fulfill their needs.

00:51:19.190 --> 00:51:20.950
Obviously, you don't
want to just do

00:51:20.950 --> 00:51:22.420
whatever your users say.

00:51:25.030 --> 00:51:26.400
It's always the developers.

00:51:26.400 --> 00:51:28.510
I have a blog post that I wrote,
which I think might be

00:51:28.510 --> 00:51:31.180
my most recent blog post called
"Users Have Problems,

00:51:31.180 --> 00:51:35.730
Developers Have Solutions." If
you're writing infrastructure,

00:51:35.730 --> 00:51:37.700
then your users are
other programmers.

00:51:37.700 --> 00:51:39.210
So you want to find out what
their problems are, but you

00:51:39.210 --> 00:51:40.550
don't want to let them dictate
your solutions.

00:51:40.550 --> 00:51:42.080
And you want to come up with
the solutions, but you want

00:51:42.080 --> 00:51:46.190
those solutions to be based
on real-world problems.

00:51:46.190 --> 00:51:50.550
And so that way, you are making
a better future based

00:51:50.550 --> 00:51:51.760
on present time information.

00:51:51.760 --> 00:51:53.000
JAREK WILKIEWICZ: So you have
to be pragmatic about it.

00:51:53.000 --> 00:51:57.480
Don't fall for the latest shiny
thing because it may

00:51:57.480 --> 00:51:58.250
actually bite you

00:51:58.250 --> 00:51:59.130
MAX KANAT-ALEXANDER:
Yeah, exactly.

00:51:59.130 --> 00:51:59.390
JAREK WILKIEWICZ: Great.

00:51:59.390 --> 00:52:02.250
So the second question is, "The
law of simplicity seems

00:52:02.250 --> 00:52:03.900
to justify SOAs.

00:52:03.900 --> 00:52:06.620
But at some point, dependency
management becomes complex

00:52:06.620 --> 00:52:09.060
between intercorrecting
services.

00:52:09.060 --> 00:52:12.300
How do you avoid passing the
overall systems complexity up

00:52:12.300 --> 00:52:13.240
to operations?

00:52:13.240 --> 00:52:15.290
For example, SREs at Google."

00:52:15.290 --> 00:52:19.880
And for those of you that are
not familiar with the concept,

00:52:19.880 --> 00:52:22.710
Google has a specific set of
engineers that are focused on

00:52:22.710 --> 00:52:25.390
these types of deployment
issues.

00:52:25.390 --> 00:52:25.650
MAX KANAT-ALEXANDER: Yeah.

00:52:25.650 --> 00:52:27.350
So that's an interesting
question.

00:52:27.350 --> 00:52:29.550
And as far as Service-Oriented
Architectures, which is what

00:52:29.550 --> 00:52:33.040
SOA stands for if anybody
doesn't know that, I think

00:52:33.040 --> 00:52:35.240
that that varies.

00:52:35.240 --> 00:52:40.800
I do encourage it for larger
teams in particular, because

00:52:40.800 --> 00:52:43.320
it enforces API boundaries.

00:52:43.320 --> 00:52:47.110
And that is often one of the
best ways to lead to broad

00:52:47.110 --> 00:52:51.030
scale system simplicity is
enforcement of API boundaries.

00:52:51.030 --> 00:52:53.640
What I would say is that if
you're going to write a

00:52:53.640 --> 00:52:55.510
service-oriented architecture
and you're going to have the

00:52:55.510 --> 00:53:01.400
operations people or SREs like
we have at Google, you need to

00:53:01.400 --> 00:53:06.430
make sure that your tooling
is up to speed.

00:53:06.430 --> 00:53:10.000
That you have a system that
allows operations to manage

00:53:10.000 --> 00:53:13.580
the complexity here in
some simple way.

00:53:13.580 --> 00:53:16.910
That there is some consistency
between how your services

00:53:16.910 --> 00:53:19.990
behave, how they're brought up,
how they're brought down,

00:53:19.990 --> 00:53:25.160
how they report information
about themselves, how you get

00:53:25.160 --> 00:53:28.550
data about their current
performance, their current

00:53:28.550 --> 00:53:31.670
memory usage, and things
like that.

00:53:31.670 --> 00:53:34.470
And don't skimp out
on the tooling.

00:53:34.470 --> 00:53:38.790
Don't think, oh, well, we've
made our side of the bargain.

00:53:38.790 --> 00:53:40.380
On the software engineer
side, we've made

00:53:40.380 --> 00:53:43.080
everything so simple.

00:53:43.080 --> 00:53:45.410
And then just decide, oh, we're
going to dump all the

00:53:45.410 --> 00:53:49.290
complexity on the SREs, which
I've definitely seen happen at

00:53:49.290 --> 00:53:50.380
various places.

00:53:50.380 --> 00:53:51.640
People will go, oh.

00:53:51.640 --> 00:53:55.490
They don't think about the fact
that this system is going

00:53:55.490 --> 00:53:58.580
to have to run in production.

00:53:58.580 --> 00:54:00.720
And people are going to need to
understand things about it

00:54:00.720 --> 00:54:04.740
not just at development time,
but also at production time.

00:54:04.740 --> 00:54:09.110
JAREK WILKIEWICZ: I think from
my experience, building that

00:54:09.110 --> 00:54:11.640
into the system, such as
reporting all these system

00:54:11.640 --> 00:54:15.320
health metrics, really nicely
avoids the problem of getting

00:54:15.320 --> 00:54:16.910
the 3:00 AM phone call.

00:54:16.910 --> 00:54:18.710
Because chances are there's
someone who is actually

00:54:18.710 --> 00:54:20.820
on-call and they'll take care
of it for you as long as you

00:54:20.820 --> 00:54:23.390
have actually thought about
exposing that in your software

00:54:23.390 --> 00:54:24.840
in the first place.

00:54:24.840 --> 00:54:25.310
MAX KANAT-ALEXANDER: Yeah.

00:54:25.310 --> 00:54:27.030
So there's also a personal
motivation there, which is

00:54:27.030 --> 00:54:28.256
that you don't want to
be called at 3:00 AM.

00:54:28.256 --> 00:54:28.640
JAREK WILKIEWICZ: Absolutely.

00:54:28.640 --> 00:54:29.753
MAX KANAT-ALEXANDER: Yeah, I
don't want to be called at

00:54:29.753 --> 00:54:30.640
3:00 AM, ever.

00:54:30.640 --> 00:54:31.550
JAREK WILKIEWICZ: We have
one more question.

00:54:31.550 --> 00:54:35.650
And this is a question from
Jeremy Walker, my colleague.

00:54:35.650 --> 00:54:37.970
And the question is, "Is Google
Developers relations

00:54:37.970 --> 00:54:39.040
hiring?"

00:54:39.040 --> 00:54:39.590
I'll take that.

00:54:39.590 --> 00:54:40.820
Yes, we are hiring.

00:54:40.820 --> 00:54:44.490
In order to learn more, go to
developers.google.com/jobs and

00:54:44.490 --> 00:54:47.030
you'll see all the positions
that we have open, and you can

00:54:47.030 --> 00:54:48.110
apply there.

00:54:48.110 --> 00:54:49.850
Well, I think we ran
out of time.

00:54:49.850 --> 00:54:51.720
Thank you very much,
Max, for coming.

00:54:51.720 --> 00:54:54.210
I think this was a very
interesting and very

00:54:54.210 --> 00:54:55.230
enlightening talk.

00:54:55.230 --> 00:54:58.560
I think I'm definitely going to
buy the book after this and

00:54:58.560 --> 00:55:00.450
read up more about it.

00:55:00.450 --> 00:55:01.300
Thank you.

00:55:01.300 --> 00:55:03.530
And then for those of you
watching, thank you very much

00:55:03.530 --> 00:55:04.270
for your time.

00:55:04.270 --> 00:55:07.600
And we'll see you again live
on YouTube at Wednesday at

00:55:07.600 --> 00:55:09.530
10:00 AM Pacific,
like every week.

00:55:09.530 --> 00:55:09.830
Bye.

00:55:09.830 --> 00:55:11.080
MAX KANAT-ALEXANDER: Bye.

00:55:19.130 --> 00:56:09.935
[MUSIC PLAYING]

