WEBVTT
Kind: captions
Language: en

00:00:00.270 --> 00:00:04.210
At this point what we have, is an unoptimized

00:00:04.210 --> 00:00:09.170
version of the abstract behavioral spec. Implemented, ready to

00:00:09.170 --> 00:00:12.264
run, but it is unoptimized. Remember that as component-based

00:00:12.264 --> 00:00:13.980
design, there's going to be a lot of crap that

00:00:13.980 --> 00:00:15.670
is going to be there in terms of the

00:00:15.670 --> 00:00:18.840
interfaces between the components that have been assembled together.

00:00:18.840 --> 00:00:21.470
To build the complex system. One word of caution

00:00:21.470 --> 00:00:26.070
though, I mentioned that using IO automata is fantastic

00:00:26.070 --> 00:00:28.630
from the point of view proving that, the

00:00:28.630 --> 00:00:32.950
properties that we want in the original subsystem

00:00:32.950 --> 00:00:35.474
is actually met by the behavior spec. That

00:00:35.474 --> 00:00:38.820
is facilitated by the IO automata framework. But this

00:00:38.820 --> 00:00:41.740
path that we took going from the abstract

00:00:41.740 --> 00:00:44.870
to concrete behavior spec, to the implementation finally

00:00:44.870 --> 00:00:48.530
ending up with unoptimized version. Which is executable

00:00:48.530 --> 00:00:51.920
there is no guarantee that this an optimized version,

00:00:51.920 --> 00:00:55.070
of code that we produced is actually meeting

00:00:55.070 --> 00:00:57.920
this behavioral spec. Or in other words this

00:00:57.920 --> 00:01:01.700
leg of design exercise proving properties. Of the

00:01:01.700 --> 00:01:04.810
spec. That it meets what we set out for

00:01:04.810 --> 00:01:08.980
the original subsystem, is in no way guaranteeing

00:01:08.980 --> 00:01:12.300
that those properties are actually in the implementation. There's

00:01:12.300 --> 00:01:14.690
no easy way to show that the OCAML

00:01:14.690 --> 00:01:18.460
implementation is the same as the IO autometer specification.

00:01:18.460 --> 00:01:21.420
This brings to mind a famous quote that is attributed

00:01:21.420 --> 00:01:24.390
to Don Knuth. Many of you. We know him as

00:01:24.390 --> 00:01:27.260
an expert in algorithm development. He's written several books on

00:01:27.260 --> 00:01:30.570
it. And a quote that is attributed to him is beware

00:01:30.570 --> 00:01:34.420
of bugs in the above quote. I've only proved it

00:01:34.420 --> 00:01:37.910
connects, not tried it. [LAUGH] So in other words, he is,

00:01:37.910 --> 00:01:40.530
he's and expert in developing algorithm but he's saying I

00:01:40.530 --> 00:01:43.830
need convert the algorithm to code. There's no way to prove

00:01:43.830 --> 00:01:46.480
that the code is actually, faithfully reproducing the

00:01:46.480 --> 00:01:49.700
algorithm. That's sort of the same thing that is

00:01:49.700 --> 00:01:51.720
going on here as well. That we have an

00:01:51.720 --> 00:01:56.160
abstract behavioral spec. We can prove properties about the

00:01:56.160 --> 00:01:59.810
behavioral spec, and we can convince that whatever

00:01:59.810 --> 00:02:02.390
we set out for the subsystem is actually met,

00:02:02.390 --> 00:02:05.250
in terms of the specification but there is no

00:02:05.250 --> 00:02:09.060
way to prove. That this implementation is actually faithfully

00:02:09.060 --> 00:02:12.250
reproducing the behavioral spec. This is the software

00:02:12.250 --> 00:02:15.300
originating road map, for synthesizing a complex system

00:02:15.300 --> 00:02:17.530
starting from the behavioral spec, all the way

00:02:17.530 --> 00:02:21.170
to an un-optimized implementation of the system. So

00:02:21.170 --> 00:02:22.770
those are the first two pieces of the

00:02:22.770 --> 00:02:26.980
puzzle, namely specification. And then implementation. And the

00:02:26.980 --> 00:02:28.850
third piece of the puzzle of course is

00:02:28.850 --> 00:02:33.140
going from this unoptimized version to the optimized version.

