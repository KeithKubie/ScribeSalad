WEBVTT
Kind: captions
Language: en

00:00:09.040 --> 00:00:11.176
PAUL IRISH: Welcome to The
Breakpoint with Paul Irish and

00:00:11.176 --> 00:00:12.380
Addy Osmani.

00:00:12.380 --> 00:00:14.680
Today we're gonna show you some
cool stuff inside the

00:00:14.680 --> 00:00:17.380
DevTools, tell you a little
bit about hardware

00:00:17.380 --> 00:00:20.620
acceleration, and hopefully
teach you about some

00:00:20.620 --> 00:00:23.790
JavaScript language tooling that
should really help your

00:00:23.790 --> 00:00:25.340
kind of team productivity
and ability to

00:00:25.340 --> 00:00:27.480
maintain large products.

00:00:27.480 --> 00:00:30.385
So first off, we're gonna kick
off immediately with a demo.

00:00:30.385 --> 00:00:33.560
And if we go to my screen, I'm
gonna show Wikipedia here.

00:00:33.560 --> 00:00:35.120
So we have just a standard--

00:00:35.120 --> 00:00:39.430
this is the Wikipedia
page for Wikipedia.

00:00:39.430 --> 00:00:45.180
Now what I want to do is I want
to look at how it loads.

00:00:45.180 --> 00:00:48.515
Some people on the Chrome team
were actually looking at this

00:00:48.515 --> 00:00:50.220
on the Nexus 7 tablet.

00:00:50.220 --> 00:00:55.580
And it has a little bit of
a weight as the page is

00:00:55.580 --> 00:00:55.780
[INAUDIBLE].

00:00:55.780 --> 00:00:58.420
So, actually if I just
load the page--

00:00:58.420 --> 00:01:00.820
I'll get rid of the
DevTools for now--

00:01:00.820 --> 00:01:04.209
and I'm moving my hands
on the track pad

00:01:04.209 --> 00:01:07.640
to scroll it a bunch.

00:01:07.640 --> 00:01:10.050
You can see it's--

00:01:10.050 --> 00:01:11.580
OK, I kind of missed
my target.

00:01:11.580 --> 00:01:16.380
But there's a good three second
delay as the page is

00:01:16.380 --> 00:01:19.690
loading before it starts
getting responsive.

00:01:19.690 --> 00:01:22.240
You can test this out
yourself right now.

00:01:22.240 --> 00:01:23.840
But what I'm gonna do is I'm
gonna show that in the

00:01:23.840 --> 00:01:25.220
DevTools timeline.

00:01:25.220 --> 00:01:28.250
So, let's hit Record.

00:01:28.250 --> 00:01:34.860
And now I'm gonna go back
and refresh the page.

00:01:34.860 --> 00:01:37.690
And we're waiting
for the spike.

00:01:37.690 --> 00:01:39.600
There it is.

00:01:39.600 --> 00:01:40.130
All right.

00:01:40.130 --> 00:01:42.950
So right here, this
big yellow spike.

00:01:42.950 --> 00:01:45.740
So yellow is JavaScript inside
the timeline here.

00:01:45.740 --> 00:01:50.420
And if I scroll down a bit--

00:01:50.420 --> 00:01:52.770
if there's too much blue for
you, you can always just

00:01:52.770 --> 00:01:56.810
uncheck the blue on the very,
very bottom down here.

00:01:56.810 --> 00:01:58.060
I'll do that for now.

00:02:00.550 --> 00:02:02.060
And you see this guy here.

00:02:02.060 --> 00:02:06.820
So this is a 3.5 second frame,
3.5 seconds where the

00:02:06.820 --> 00:02:11.740
browser's not responsive
to the user at all.

00:02:11.740 --> 00:02:13.080
So, this is pretty
interesting.

00:02:13.080 --> 00:02:17.590
So we have these three big
yellow blocks where it looks

00:02:17.590 --> 00:02:20.130
like we're evaluating
script over here.

00:02:20.130 --> 00:02:23.070
Let's open them up.

00:02:23.070 --> 00:02:25.130
And looks interesting.

00:02:25.130 --> 00:02:29.810
So we have kind of this
waterfall look where there's a

00:02:29.810 --> 00:02:31.870
few things going on.

00:02:31.870 --> 00:02:34.020
And if you look over on the
right-hand side, it looks like

00:02:34.020 --> 00:02:37.690
a lot of recalculate style,
recalculate style.

00:02:37.690 --> 00:02:39.670
Here we have recalculate
style going back

00:02:39.670 --> 00:02:40.600
and forth with layouts.

00:02:40.600 --> 00:02:46.960
So this is the situation called
layout thrashing.

00:02:46.960 --> 00:02:51.340
For right now, let's focus
on this layout style--

00:02:51.340 --> 00:02:52.800
sorry, recalculate style.

00:02:52.800 --> 00:02:56.130
So, the fact it's doing the same
thing over and over again

00:02:56.130 --> 00:02:57.650
is usually an indication
to you that

00:02:57.650 --> 00:02:59.200
something might be wrong.

00:02:59.200 --> 00:03:01.150
And we can find out what's
going on here.

00:03:01.150 --> 00:03:04.280
So if we just hover in this
area, we get the tool tip.

00:03:04.280 --> 00:03:07.060
And we get the actual call
stack on why we're

00:03:07.060 --> 00:03:08.410
recalculating the style.

00:03:08.410 --> 00:03:10.920
First, our layouts were
invalidated at some point

00:03:10.920 --> 00:03:12.300
during the add embedded CSS.

00:03:12.300 --> 00:03:16.000
And then our recalc was
forced, again, in

00:03:16.000 --> 00:03:18.680
add embedded CSS.

00:03:18.680 --> 00:03:18.820
OK.

00:03:18.820 --> 00:03:19.720
Interesting.

00:03:19.720 --> 00:03:24.190
So, if I click through, well,
it's all minified, but we can

00:03:24.190 --> 00:03:24.920
address that.

00:03:24.920 --> 00:03:28.080
So I'm gonna click the pretty
print on the very bottom.

00:03:28.080 --> 00:03:29.120
We pretty print.

00:03:29.120 --> 00:03:31.120
And just to make sure that we're
looking at the right

00:03:31.120 --> 00:03:33.020
spot, we're gonna go back
to timeline and

00:03:33.020 --> 00:03:35.910
click through again.

00:03:35.910 --> 00:03:36.790
And here we go.

00:03:36.790 --> 00:03:40.750
So we're looking at embedded
CSS right here.

00:03:40.750 --> 00:03:42.820
And it jumped me to this
line actually.

00:03:42.820 --> 00:03:48.450
So what add embedded CSS is
doing is Wikipedia loads a

00:03:48.450 --> 00:03:53.850
bunch of its modules into the
page kind of lazily as this

00:03:53.850 --> 00:03:56.960
page is loading, and then
if there's any styles

00:03:56.960 --> 00:03:57.690
associated with it.

00:03:57.690 --> 00:03:59.790
So they actually have like
a little tool tip module.

00:03:59.790 --> 00:04:01.980
And they load in jQuery
UI for a widget

00:04:01.980 --> 00:04:03.750
farther down the page.

00:04:03.750 --> 00:04:05.290
And then CSS needs to
go into the page.

00:04:05.290 --> 00:04:10.340
And, in order to deal with a
IE bug where you could only

00:04:10.340 --> 00:04:14.720
have up to, I think, 32 style
sheets per page, they reuse an

00:04:14.720 --> 00:04:16.070
existing style element.

00:04:16.070 --> 00:04:18.209
So it's an inline style element,
and they just append

00:04:18.209 --> 00:04:19.920
more content into the
bottom of it.

00:04:22.620 --> 00:04:26.160
Which makes sense if you only
have a maximum of 32 possible

00:04:26.160 --> 00:04:28.700
style sheets available to you.

00:04:28.700 --> 00:04:32.660
But it doesn't make a lot
of sense otherwise.

00:04:32.660 --> 00:04:36.720
So here we have, basically,
there's a few techniques for

00:04:36.720 --> 00:04:37.640
adding in new styles.

00:04:37.640 --> 00:04:39.520
One is using stylesheet.csstext
which is

00:04:39.520 --> 00:04:41.950
only supported, I
think, by IE.

00:04:41.950 --> 00:04:43.840
But that might have changed.

00:04:43.840 --> 00:04:46.230
And otherwise, we create a
little text node, and we just

00:04:46.230 --> 00:04:48.390
inject it into a
style element.

00:04:48.390 --> 00:04:49.740
Basically the same thing.

00:04:49.740 --> 00:04:53.590
But what these two techniques
do is it just says to the

00:04:53.590 --> 00:04:56.240
browser, hey, you know all those
styles that you were

00:04:56.240 --> 00:04:59.430
keeping tracking of and you knew
the computed style of all

00:04:59.430 --> 00:05:03.740
the elements of the page, throw
all that out because I

00:05:03.740 --> 00:05:05.720
just changed the world and
you're gonna have to

00:05:05.720 --> 00:05:07.590
recalculate everything else.

00:05:07.590 --> 00:05:12.600
And so this, if we look at the
timeline, happens about 20

00:05:12.600 --> 00:05:16.870
times or so as the
page is loading.

00:05:16.870 --> 00:05:19.110
And so the browser is just doing
all this work again and

00:05:19.110 --> 00:05:21.520
again and again, doing the
same recalculation of the

00:05:21.520 --> 00:05:25.910
style with a very small little
difference at the end.

00:05:25.910 --> 00:05:27.470
And it turns out WebKit
actually--

00:05:27.470 --> 00:05:29.550
we were digging into this
and we looked through

00:05:29.550 --> 00:05:31.260
the source of WebKit.

00:05:31.260 --> 00:05:34.650
WebKit actually has a fast path
for if you're just adding

00:05:34.650 --> 00:05:39.110
a few new actual styles at
the end of the document.

00:05:39.110 --> 00:05:41.250
And it doesn't have to
recalculate the world.

00:05:41.250 --> 00:05:42.950
It can just kind of augment
what it knows

00:05:42.950 --> 00:05:44.060
with the new styles.

00:05:44.060 --> 00:05:45.440
And it's fast.

00:05:45.440 --> 00:05:48.460
But here, we're clearly not
hitting this fast path because

00:05:48.460 --> 00:05:58.630
every single recalculate is
taking, wow, 130 milliseconds.

00:05:58.630 --> 00:06:02.660
When a frame is 16.6
milliseconds, 130 milliseconds

00:06:02.660 --> 00:06:04.530
is a long, long time.

00:06:07.490 --> 00:06:09.840
So this is a bit of a problem.

00:06:09.840 --> 00:06:12.740
But luckily, we've gotten in
touch with some of the

00:06:12.740 --> 00:06:17.330
developers at Wikipedia and
Wikimedia to adjust this.

00:06:17.330 --> 00:06:20.830
And we've fixed it
in two places.

00:06:20.830 --> 00:06:23.100
So one is this recalculation
of style.

00:06:23.100 --> 00:06:25.730
Like I said, these come
in from modules.

00:06:25.730 --> 00:06:30.055
And so one of the approaches
that we did is we just batch

00:06:30.055 --> 00:06:30.960
it all together, right.

00:06:30.960 --> 00:06:34.690
We have new styles come in from
seven different places.

00:06:34.690 --> 00:06:36.700
Let's just smush them all
together into one string and

00:06:36.700 --> 00:06:40.190
inject it at once.

00:06:40.190 --> 00:06:43.440
And so then we can basically
take these 20 recalculations

00:06:43.440 --> 00:06:46.990
of styles and bring it down
to about five or so.

00:06:46.990 --> 00:06:48.660
So that's a really big win.

00:06:48.660 --> 00:06:51.710
The second is we're not gonna
continue to augment an

00:06:51.710 --> 00:06:55.400
existing style tag, instead
we're going to create new

00:06:55.400 --> 00:06:59.394
ones, except in the
case of IE.

00:06:59.394 --> 00:07:02.850
IE 6 through 9, where that style
sheet limit is still in

00:07:02.850 --> 00:07:05.790
force, we'll still continue
to do this little trick.

00:07:05.790 --> 00:07:09.440
Lastly, I wanted to show this
kind of layout thrashing.

00:07:09.440 --> 00:07:14.170
So, what we can see, actually,
on a hover of the layout where

00:07:14.170 --> 00:07:17.970
we have the little icon--

00:07:17.970 --> 00:07:20.610
so the icon is there because a
forced synchronous layout is a

00:07:20.610 --> 00:07:24.510
possible performance
bottleneck.

00:07:24.510 --> 00:07:26.505
And so what this
means is that--

00:07:26.505 --> 00:07:28.510
so we see that the layout
was invalidated because

00:07:28.510 --> 00:07:29.865
we added new stuff.

00:07:29.865 --> 00:07:32.110
But the layout was
forced here.

00:07:32.110 --> 00:07:34.790
Basically, browser needs to
deliver what the geometry of

00:07:34.790 --> 00:07:39.570
the page is to where we
are in this curCSS.

00:07:39.570 --> 00:07:41.750
This is actually inside
of jQuery.

00:07:41.750 --> 00:07:44.940
So if we look down, it looks
like our loader that is bring

00:07:44.940 --> 00:07:47.820
in these modules is
doing some stuff.

00:07:47.820 --> 00:07:50.680
It's now injecting some
styles into the page.

00:07:50.680 --> 00:07:52.850
And now we're going
through jQuery.

00:07:52.850 --> 00:07:55.990
And looks like we have to
augment with our height.

00:07:55.990 --> 00:08:00.320
And if I click in this curCSS,
yes, I just used

00:08:00.320 --> 00:08:02.390
get computed style.

00:08:02.390 --> 00:08:05.390
And we're about to
figure out what

00:08:05.390 --> 00:08:06.700
the style is of something.

00:08:06.700 --> 00:08:14.150
So apparently, right inside
here, we have to do something

00:08:14.150 --> 00:08:17.900
that looks like we're setting
the width of the page or the

00:08:17.900 --> 00:08:20.620
height of an element.

00:08:20.620 --> 00:08:23.080
And in order to do that in
jQuery, it needs to use get

00:08:23.080 --> 00:08:24.710
computed style.

00:08:24.710 --> 00:08:29.020
So basically, the browser
says, stop everything.

00:08:29.020 --> 00:08:30.810
Let me get this value.

00:08:30.810 --> 00:08:31.080
OK.

00:08:31.080 --> 00:08:32.380
Here you go.

00:08:32.380 --> 00:08:34.740
And then immediately after that,
we're gonna recalculate

00:08:34.740 --> 00:08:36.990
all the styles again and
again and again.

00:08:36.990 --> 00:08:40.710
So there's a few ways
to address this.

00:08:40.710 --> 00:08:44.610
In this case you can get all
your truth out of the DOMs.

00:08:44.610 --> 00:08:46.300
You need to get computed
style.

00:08:46.300 --> 00:08:48.960
You need to get an offset
top, et cetera.

00:08:48.960 --> 00:08:53.660
Do those all together, and then
make changes to what the

00:08:53.660 --> 00:08:56.060
styles of the page should be.

00:08:56.060 --> 00:08:57.870
That's probably the best
way to handle this.

00:08:57.870 --> 00:09:01.691
When you see a pattern going
back and forth like this, you

00:09:01.691 --> 00:09:03.230
know that it could be better.

00:09:03.230 --> 00:09:04.150
So.

00:09:04.150 --> 00:09:08.140
Anyways, the good news here is
every page on Wikipedia was

00:09:08.140 --> 00:09:09.460
slow before.

00:09:09.460 --> 00:09:11.540
And the fix actually should
be rolling out

00:09:11.540 --> 00:09:13.270
within a week or so.

00:09:13.270 --> 00:09:16.080
And so you should be seeing a
benefit and be able to scroll

00:09:16.080 --> 00:09:22.350
immediately on both desktop and
on tablet immediately upon

00:09:22.350 --> 00:09:25.120
loading the page, which I'm
real excited about.

00:09:25.120 --> 00:09:27.060
So Addy, how's it going?

00:09:27.060 --> 00:09:27.700
ADDY OSMANI: Really awesome.

00:09:27.700 --> 00:09:31.130
So, I'm gonna be talking
about GPU acceleration.

00:09:31.130 --> 00:09:33.850
Now, traditionally, browsers
have relied quite heavily on

00:09:33.850 --> 00:09:35.920
the CPU for rendering pages.

00:09:35.920 --> 00:09:38.410
And it's only in the last few
years that we've realized that

00:09:38.410 --> 00:09:41.350
involving the GPU in compositing
those pages can

00:09:41.350 --> 00:09:44.200
yield us some really nice
performance benefits.

00:09:44.200 --> 00:09:46.920
In Chrome, we've actually for
a while now had this concept

00:09:46.920 --> 00:09:49.960
of a composite layer for
minimizing repaints and

00:09:49.960 --> 00:09:52.350
basically using GPU
acceleration.

00:09:52.350 --> 00:09:55.070
And the idea is if you're
using something like

00:09:55.070 --> 00:09:58.070
Translate3d with a WebKit
transform, that'll get

00:09:58.070 --> 00:10:01.680
promoted to a composition layer
before it gets animated.

00:10:01.680 --> 00:10:05.870
Now, GPU acceleration of your
DOM elements has a number of

00:10:05.870 --> 00:10:06.980
different benefits.

00:10:06.980 --> 00:10:09.250
It's a little bit more efficient
to draw things to

00:10:09.250 --> 00:10:10.050
the screen.

00:10:10.050 --> 00:10:12.480
And you avoid issues like
hopping over really large

00:10:12.480 --> 00:10:15.440
amounts of data from the
video to system memory.

00:10:15.440 --> 00:10:17.940
So I'm actually gonna show you
an example of a site that's

00:10:17.940 --> 00:10:20.240
taking advantage of
GPU acceleration.

00:10:20.240 --> 00:10:21.770
And it's this nice
demo by David

00:10:21.770 --> 00:10:23.490
DeSandro called Undulate.

00:10:23.490 --> 00:10:26.130
So the idea is I move my cursor
around and I get this

00:10:26.130 --> 00:10:28.690
really nice fluid animation.

00:10:28.690 --> 00:10:31.520
If you open up your DevTools
and you go to Settings,

00:10:31.520 --> 00:10:34.300
there's actually a really nice
feature the gives you insights

00:10:34.300 --> 00:10:36.860
into what DOM elements are being
manipulated at a GPU

00:10:36.860 --> 00:10:40.570
level called Show Composited
Layer Borders under Rendering.

00:10:40.570 --> 00:10:44.170
So I go and I enable Show
Composited Layer Borders.

00:10:44.170 --> 00:10:46.660
Now what you can now see is
around each of the circles on

00:10:46.660 --> 00:10:49.450
screen, there's a little golden
border indicating that

00:10:49.450 --> 00:10:52.410
that element is being
manipulated at a GPU level, or

00:10:52.410 --> 00:10:54.630
that it's using hardware
compositing.

00:10:54.630 --> 00:10:56.160
Now that's really awesome.

00:10:56.160 --> 00:10:58.120
Just to confirm again, remember
I was talking about

00:10:58.120 --> 00:11:01.260
translate3d with a WebKit
transform earlier, and that's

00:11:01.260 --> 00:11:02.760
basically what they're
using here.

00:11:02.760 --> 00:11:04.230
So I've just shown
you Undulate.

00:11:04.230 --> 00:11:06.960
And the next example I'm gonna
show you is Isotope, which is

00:11:06.960 --> 00:11:09.020
another plug-in by
David DeSandro.

00:11:09.020 --> 00:11:12.910
Now, if I go into my DevTools
and I enable Show Composite

00:11:12.910 --> 00:11:16.890
Layer Borders once again, what
you'll notice is that all of

00:11:16.890 --> 00:11:19.780
these elements, they're taking
advantage of GPU acceleration,

00:11:19.780 --> 00:11:21.450
every single one of these.

00:11:21.450 --> 00:11:23.070
And that's helping
in this case.

00:11:23.070 --> 00:11:26.030
This is actually using, once
again, WebKit transform with

00:11:26.030 --> 00:11:27.100
translate3d.

00:11:27.100 --> 00:11:28.850
And it's doing it properly.

00:11:28.850 --> 00:11:30.940
Another thing you may have come
across for the past few

00:11:30.940 --> 00:11:33.730
years is something called
a null transform hack.

00:11:33.730 --> 00:11:36.860
Now the null transfer hack
basically allows you to force

00:11:36.860 --> 00:11:39.540
GPU acceleration of a DOM
element, meaning it's gonna

00:11:39.540 --> 00:11:42.060
get promoted to its own
composite layer.

00:11:42.060 --> 00:11:44.760
Now, a few years ago this hack
was a lot more relevant.

00:11:44.760 --> 00:11:47.230
It basically gave you some great
mileage in your page

00:11:47.230 --> 00:11:50.150
whenever you found
that it was slow.

00:11:50.150 --> 00:11:52.860
And it played its part.

00:11:52.860 --> 00:11:55.900
But Chrome has been getting
much better at handling

00:11:55.900 --> 00:11:57.930
compositing in the background
for you so that you don't have

00:11:57.930 --> 00:11:59.380
to use hacks like these.

00:11:59.380 --> 00:12:01.700
However, there are gonna be
cases where you might get a

00:12:01.700 --> 00:12:03.130
little bit of mileage
out of it.

00:12:03.130 --> 00:12:04.650
Be careful when you're
using it.

00:12:04.650 --> 00:12:08.390
The only case where I suggest
actually using translateZ is

00:12:08.390 --> 00:12:10.310
where you have a measurably
high paint

00:12:10.310 --> 00:12:11.690
cost on a DOM element.

00:12:11.690 --> 00:12:13.800
So if you have a measurably high
paint cost, you've used

00:12:13.800 --> 00:12:16.410
timeline, you've used our other
tools to figure out if

00:12:16.410 --> 00:12:20.040
there's a high paint cost on a
DOM element, then maybe tryout

00:12:20.040 --> 00:12:22.770
the translateZ hack and see if
you get some mileage from it.

00:12:22.770 --> 00:12:25.270
One other demo that took
advantage of the translateZ

00:12:25.270 --> 00:12:27.930
hack is Google Space
by Mr. [? Dube. ?]

00:12:27.930 --> 00:12:30.920
Now, what he found was that he
was animating this stuff in

00:12:30.920 --> 00:12:33.140
his page, and it was just going
really, really slow.

00:12:33.140 --> 00:12:34.990
He wasn't really sure why.

00:12:34.990 --> 00:12:37.280
And he took advantage of the
null transform hack.

00:12:37.280 --> 00:12:39.880
And basically, I've got
composite layer borders on at

00:12:39.880 --> 00:12:42.670
the moment, and look
what happens.

00:12:42.670 --> 00:12:45.420
It's now animating a little
bit more smoothly.

00:12:45.420 --> 00:12:47.620
You can see the composite layer
borders are on each of

00:12:47.620 --> 00:12:48.410
our elements.

00:12:48.410 --> 00:12:50.280
And it's a little
bit more smooth.

00:12:50.280 --> 00:12:53.170
It's a little bit more buttery,
and that looks good.

00:12:53.170 --> 00:12:55.520
You have to be really, really
careful when you're using the

00:12:55.520 --> 00:12:58.010
null transfer hack, however,
because if you go and you

00:12:58.010 --> 00:13:00.480
apply it to every single element
in your page, you're

00:13:00.480 --> 00:13:03.180
basically gonna offload a
whole lot to the GPU.

00:13:03.180 --> 00:13:06.440
You have a limited amount of
VRAM on desktop, on mobile.

00:13:06.440 --> 00:13:09.380
And you just want to make sure
that you're not bursting that.

00:13:09.380 --> 00:13:11.930
It's less likely that it's gonna
happen on desktop, a lot

00:13:11.930 --> 00:13:13.790
more mobile.

00:13:13.790 --> 00:13:15.160
And I'm actually
gonna show you.

00:13:15.160 --> 00:13:18.910
So, The Guardian is a website
that performs sort of OK.

00:13:18.910 --> 00:13:21.480
So this is like a newspaper
in the UK.

00:13:21.480 --> 00:13:24.870
And this site performs sort
of OK on desktop.

00:13:24.870 --> 00:13:29.830
If I go back into sort of my
DevTools, I've got Show

00:13:29.830 --> 00:13:31.770
Composite Layer Borders on.

00:13:31.770 --> 00:13:35.860
And I go and I add basically a
null transform to everything

00:13:35.860 --> 00:13:37.650
on the page--

00:13:37.650 --> 00:13:43.510
so WebKit transform
translateZ(0).

00:13:43.510 --> 00:13:45.460
What you'll now see is that
there is a composite layer

00:13:45.460 --> 00:13:47.490
border being drawn around
everything 'cause it's all

00:13:47.490 --> 00:13:48.440
being promoted.

00:13:48.440 --> 00:13:50.800
And this page is actually gonna
run a little bit more

00:13:50.800 --> 00:13:53.870
slowly than it was before
because absolutely everything

00:13:53.870 --> 00:13:55.780
is being offloaded to the GPU.

00:13:55.780 --> 00:13:57.060
That's not a good thing.

00:13:57.060 --> 00:13:59.660
Now let's take a look at what
this does on mobile.

00:13:59.660 --> 00:14:02.950
So, I've got my Android
phone with me.

00:14:02.950 --> 00:14:07.630
I've got Chrome beta
currently running.

00:14:07.630 --> 00:14:09.240
So this is the experience.

00:14:09.240 --> 00:14:10.900
So let me show you
what I've got.

00:14:10.900 --> 00:14:14.870
This is what the experience
looks like without me enabling

00:14:14.870 --> 00:14:16.445
the null transform hack
on absolutely every

00:14:16.445 --> 00:14:17.290
element on this page.

00:14:17.290 --> 00:14:18.430
So I'm scrolling through.

00:14:18.430 --> 00:14:20.390
Their mobile experience is
actually pretty decent.

00:14:20.390 --> 00:14:22.240
You see I'm able to scroll
through the entire page.

00:14:22.240 --> 00:14:25.550
And it's not too bad
to be honest.

00:14:25.550 --> 00:14:28.120
Let's go in, and let's see what
happens if I actually

00:14:28.120 --> 00:14:29.430
enable this hack.

00:14:29.430 --> 00:14:34.145
So, WebKit transform
translateZ(0).

00:14:40.650 --> 00:14:44.200
And now watch.

00:14:47.470 --> 00:14:49.770
It actually takes a
while to scroll.

00:14:49.770 --> 00:14:51.920
I know it's, again, subtle,
but it's actually taking a

00:14:51.920 --> 00:14:53.700
while to scroll through
this page.

00:14:53.700 --> 00:14:58.500
It is not as smooth
as it was before.

00:14:58.500 --> 00:15:00.400
And so you need to be very
careful whenever you're using

00:15:00.400 --> 00:15:02.010
the translateZ hack.

00:15:02.010 --> 00:15:03.610
You don't want to
blow your VRAM.

00:15:03.610 --> 00:15:06.150
You don't want to put too much
pressure on your GPU.

00:15:06.150 --> 00:15:09.740
Now, for people that are
wondering why isn't Chrome

00:15:09.740 --> 00:15:12.020
trying to do more of this stuff
automatically for me?

00:15:12.020 --> 00:15:15.280
Why are people still needing to
use these translateZ hacks?

00:15:15.280 --> 00:15:17.560
So if you go to Chrome Flags,
you can actually take a look

00:15:17.560 --> 00:15:20.340
at some of the work we've been
doing to further compositing.

00:15:20.340 --> 00:15:22.850
And there are actually two
experiments in particular that

00:15:22.850 --> 00:15:24.270
you can go and you
can play with.

00:15:24.270 --> 00:15:27.530
You can enable GPU compositing
on basically all of the pages

00:15:27.530 --> 00:15:28.640
that you browse on.

00:15:28.640 --> 00:15:31.210
And you can actually also enable
threaded compositing

00:15:31.210 --> 00:15:33.890
which gives you an additional
thread for web page

00:15:33.890 --> 00:15:34.340
compositing.

00:15:34.340 --> 00:15:37.100
And it just gives you things
like smooth scrolling, even

00:15:37.100 --> 00:15:39.150
when the main thread, which is
where a lot of the action

00:15:39.150 --> 00:15:41.250
happens, is unresponsive.

00:15:41.250 --> 00:15:42.820
So go and play with
those things.

00:15:42.820 --> 00:15:45.090
We're currently still
benchmarking performance of

00:15:45.090 --> 00:15:46.300
compositing across all pages.

00:15:46.300 --> 00:15:48.640
But in most cases, it's actually
gonna perform pretty

00:15:48.640 --> 00:15:52.680
well, at least as good as using
the translateZ hack

00:15:52.680 --> 00:15:54.830
across all these elements
on your page.

00:15:54.830 --> 00:15:58.010
So the takeaway from this is
be very careful when you're

00:15:58.010 --> 00:16:00.700
using null transfer hacks
in your pages.

00:16:00.700 --> 00:16:03.200
Make sure that if you're
applying them that you have a

00:16:03.200 --> 00:16:06.010
measurably high paint cost on
those DOM elements where you

00:16:06.010 --> 00:16:07.410
are applying them.

00:16:07.410 --> 00:16:08.960
And just be careful when
using these things.

00:16:08.960 --> 00:16:09.710
Make sure to measure.

00:16:09.710 --> 00:16:11.890
Measurement is the most
important thing when you're

00:16:11.890 --> 00:16:14.680
doing any sort of performance
optimization on your pages.

00:16:14.680 --> 00:16:15.720
So, yeah.

00:16:15.720 --> 00:16:16.950
That's it for me.

00:16:16.950 --> 00:16:18.720
PAUL IRISH: I was just gonna add
on a few things to that.

00:16:18.720 --> 00:16:24.100
There's been a few updates in
kind of the compositing

00:16:24.100 --> 00:16:26.920
situation in Chrome.

00:16:26.920 --> 00:16:34.750
So, for any composited layers,
if you've taken like a DIV

00:16:34.750 --> 00:16:38.260
before and rotated it 45 degrees
and you had text

00:16:38.260 --> 00:16:40.080
inside there, you might have
noticed that the text quality

00:16:40.080 --> 00:16:42.080
is not so sharp.

00:16:42.080 --> 00:16:45.990
So, it'll now look great as
long as that DIV has a

00:16:45.990 --> 00:16:46.880
background.

00:16:46.880 --> 00:16:49.580
So that's a somewhat recent
change, probably about two

00:16:49.580 --> 00:16:51.550
weeks ago or so.

00:16:51.550 --> 00:16:55.070
So it's opaque composited layers
get anti-aliasing.

00:16:55.070 --> 00:17:00.490
The other is that fixed position
layers are now

00:17:00.490 --> 00:17:03.650
composited for you automatically
in a few

00:17:03.650 --> 00:17:04.230
situations.

00:17:04.230 --> 00:17:10.569
One, if you're on Android,
then it's done for you.

00:17:10.569 --> 00:17:16.349
On desktop right now, it's in
many cases you may have to use

00:17:16.349 --> 00:17:18.980
something like the null
transform if it's a situation

00:17:18.980 --> 00:17:21.240
where it really has benefit.

00:17:21.240 --> 00:17:23.790
In high DPI situations.

00:17:23.790 --> 00:17:27.520
So you're on your retina machine
or on another laptop

00:17:27.520 --> 00:17:34.650
with a really high resolution,
a Chrome Book pixel even, any

00:17:34.650 --> 00:17:37.940
fixed position layers are
now composited as well.

00:17:37.940 --> 00:17:40.160
So you're gonna see the same
kind of performance increase.

00:17:40.160 --> 00:17:41.090
So it's a really good thing.

00:17:41.090 --> 00:17:46.060
And this will be coming to
situations where it's not high

00:17:46.060 --> 00:17:54.260
DPI very soon once we can get
text anti-aliasing on these

00:17:54.260 --> 00:17:55.170
layers as well.

00:17:55.170 --> 00:18:00.950
So, we want to make sure the
type looks good before we flip

00:18:00.950 --> 00:18:04.660
the switch and give the
compositing performance boost

00:18:04.660 --> 00:18:05.720
to everyone.

00:18:05.720 --> 00:18:08.760
So, that's kind of the update.

00:18:08.760 --> 00:18:09.520
Lots of things have
been changing

00:18:09.520 --> 00:18:10.710
in this area recently.

00:18:10.710 --> 00:18:12.760
So, there we go.

00:18:12.760 --> 00:18:17.900
Lastly, I wanted to show
just a few slides.

00:18:17.900 --> 00:18:23.850
And this is some great stuff
that a lot of this comes from

00:18:23.850 --> 00:18:26.120
work and research done
by Ariya Hidayat.

00:18:26.120 --> 00:18:30.580
And Ariya created Esprima,
also created PhantomJS.

00:18:30.580 --> 00:18:34.450
He's a platform architect
over at Sencha.

00:18:34.450 --> 00:18:39.570
But there's a lot of great
tools now available for

00:18:39.570 --> 00:18:44.350
JavaScript language authoring
and editing, debugging,

00:18:44.350 --> 00:18:45.350
continuous integration.

00:18:45.350 --> 00:18:46.740
And I want to show
a few of them.

00:18:46.740 --> 00:18:50.590
And the first thing that I want
to say is that a lot of

00:18:50.590 --> 00:18:54.570
teams set up style guides,
especially for JavaScript.

00:18:54.570 --> 00:18:55.860
And I think this is
a great thing.

00:18:55.860 --> 00:18:58.780
And I think that things like
JSHint have really allowed us

00:18:58.780 --> 00:19:02.820
to have maintainable rules that
we can kind of agree on

00:19:02.820 --> 00:19:06.200
and say for this project,
this makes sense.

00:19:06.200 --> 00:19:10.590
And so, the most important thing
I think is that every

00:19:10.590 --> 00:19:12.870
code style rule that
you have, it should

00:19:12.870 --> 00:19:13.920
be backed by tooling.

00:19:13.920 --> 00:19:17.590
So you should not say something
about your use of

00:19:17.590 --> 00:19:21.970
commas or spaces around
assignments that you cannot

00:19:21.970 --> 00:19:22.730
enforce with tooling.

00:19:22.730 --> 00:19:26.640
Because it's a waste of our
time, like human's time, to be

00:19:26.640 --> 00:19:30.140
worrying about style inside
our JavaScript.

00:19:30.140 --> 00:19:32.010
And I see this in open source
or poll request.

00:19:32.010 --> 00:19:35.130
And the first comments will be
like, yeah, well, put some

00:19:35.130 --> 00:19:37.330
more white space here.

00:19:37.330 --> 00:19:39.390
It's not a good use
of our time.

00:19:39.390 --> 00:19:43.780
So, I'm gonna show a few pieces
of tooling that exist

00:19:43.780 --> 00:19:46.470
for this sort of thing and other
pieces of JavaScript

00:19:46.470 --> 00:19:48.630
authorizing.

00:19:48.630 --> 00:19:52.660
First, a little bit ago, I
think back when I was in

00:19:52.660 --> 00:19:57.720
London, Addy and I, and we had
on Sindre Sorhus, and he

00:19:57.720 --> 00:20:01.330
talked a little bit about a
few of the project level

00:20:01.330 --> 00:20:02.650
collaboration techniques.

00:20:02.650 --> 00:20:05.230
So one is setting up a
gitattributes file where you

00:20:05.230 --> 00:20:07.520
specify * text=auto.

00:20:07.520 --> 00:20:09.230
Make sure that your line
endings are good.

00:20:09.230 --> 00:20:09.660
Do it.

00:20:09.660 --> 00:20:11.810
That's great.

00:20:11.810 --> 00:20:15.150
EditorConfig has gotten new
enhancements since we talked

00:20:15.150 --> 00:20:15.950
about it last.

00:20:15.950 --> 00:20:21.400
So it used to only define
how end of lines are

00:20:21.400 --> 00:20:23.620
done, indent style.

00:20:23.620 --> 00:20:26.620
It now covers things like a
extra line at the end of the

00:20:26.620 --> 00:20:28.690
file, a few other things.

00:20:28.690 --> 00:20:30.810
They're all really good, the
kinds of defaults that you go

00:20:30.810 --> 00:20:34.610
up into your editor to make
sure that you apply.

00:20:34.610 --> 00:20:36.085
No trailing white space.

00:20:36.085 --> 00:20:38.440
Things like that.

00:20:38.440 --> 00:20:42.250
So, that's great for all code,
not just JavaScript.

00:20:42.250 --> 00:20:46.860
And really makes just
collaboration easier.

00:20:46.860 --> 00:20:49.330
Rules can be set per project.

00:20:49.330 --> 00:20:51.510
JSHint, which I just
mentioned.

00:20:51.510 --> 00:20:53.650
In a jshintrc file you
can define your

00:20:53.650 --> 00:20:55.080
rules for the project.

00:20:55.080 --> 00:20:59.380
And every Sublime Text
and the VIM plug-ins

00:20:59.380 --> 00:21:01.050
all honor this file.

00:21:01.050 --> 00:21:03.390
Grunt, as well, honors this
file if it's placed in the

00:21:03.390 --> 00:21:05.350
root of your project.

00:21:05.350 --> 00:21:09.550
So that even if a project
differs from another one, you

00:21:09.550 --> 00:21:13.630
can define what your JSHint
settings are, and everyone

00:21:13.630 --> 00:21:16.070
that's collaborating there
will honor them.

00:21:16.070 --> 00:21:17.240
It's really good.

00:21:17.240 --> 00:21:20.340
So a few more things that are
available for JavaScript

00:21:20.340 --> 00:21:21.840
language tooling.

00:21:21.840 --> 00:21:26.720
So this is a use of a precommit
hook inside Git that

00:21:26.720 --> 00:21:30.240
will validate that your code
is syntactically correct.

00:21:30.240 --> 00:21:32.780
So, we're using a binary
called esvalidate.

00:21:32.780 --> 00:21:37.220
It uses Esprima, that's
a node binary.

00:21:37.220 --> 00:21:41.400
And basically, this just makes
sure that you cannot commit to

00:21:41.400 --> 00:21:44.530
Git unless esvalidate
passes it.

00:21:44.530 --> 00:21:45.930
So this is not a linter.

00:21:45.930 --> 00:21:48.040
This is just a validator.

00:21:48.040 --> 00:21:52.010
So it's just like everything
is syntactically correct.

00:21:52.010 --> 00:21:53.615
It matches ECMAScript
standards.

00:21:56.130 --> 00:21:57.940
Plato is a fantastic project.

00:21:57.940 --> 00:22:02.530
So this is a visualization of
Plato data, but it exists is a

00:22:02.530 --> 00:22:04.490
node binary as well.

00:22:04.490 --> 00:22:08.930
Gives some ideas around
maintainability index, an

00:22:08.930 --> 00:22:11.190
estimated number of bugs,
which is a kind of

00:22:11.190 --> 00:22:12.380
controversial idea.

00:22:12.380 --> 00:22:15.370
But it has a lot to do with the
cyclomatic complexity--

00:22:15.370 --> 00:22:19.670
whatever that means-- of
code, lint errors.

00:22:19.670 --> 00:22:22.760
And so you can kind of
get a sense for--

00:22:22.760 --> 00:22:25.300
one of the things I think is
really interesting is taking

00:22:25.300 --> 00:22:28.030
something like the
maintainability index and

00:22:28.030 --> 00:22:30.220
charting that over time and
kind of a continuous

00:22:30.220 --> 00:22:30.900
integration thing.

00:22:30.900 --> 00:22:33.750
So being able to see that over
the life of a project and to

00:22:33.750 --> 00:22:39.170
know that when some big new
feature landed in, the code

00:22:39.170 --> 00:22:42.900
inside the project got
significantly more complex and

00:22:42.900 --> 00:22:43.610
hard to maintain.

00:22:43.610 --> 00:22:45.200
I think that's a fantastic
thing to kind of

00:22:45.200 --> 00:22:47.820
visualize for the team.

00:22:47.820 --> 00:22:49.410
This is a Boolean trap finder.

00:22:49.410 --> 00:22:55.980
So, Boolean traps is an API
design flaw where you use a

00:22:55.980 --> 00:22:59.540
Boolean in your API
to define that.

00:22:59.540 --> 00:23:04.810
So in this top one, this is
a real-world example.

00:23:04.810 --> 00:23:09.030
New slider false actually means
that it should be a

00:23:09.030 --> 00:23:11.820
vertical slider and not
a horizontal slider.

00:23:11.820 --> 00:23:13.970
Bad API design.

00:23:13.970 --> 00:23:14.460
This could be much better.

00:23:14.460 --> 00:23:19.080
You pass in an object that says
vertical equals true.

00:23:19.080 --> 00:23:23.250
And we can just detect all these
across the project and

00:23:23.250 --> 00:23:25.590
make sure that we aren't doing
something like this.

00:23:28.450 --> 00:23:29.360
So, polluting variables.

00:23:29.360 --> 00:23:31.870
So, if we have a variable that
we don't define in at least a

00:23:31.870 --> 00:23:33.990
global, we should be notified
immediately.

00:23:33.990 --> 00:23:39.400
JSHint captures much of this,
but using, in this case,

00:23:39.400 --> 00:23:42.720
node-leaky does this by
using Esprima as well.

00:23:42.720 --> 00:23:44.650
Always smart to check.

00:23:44.650 --> 00:23:47.230
I've seen a few projects that
have changed their style guide

00:23:47.230 --> 00:23:49.610
and said we were all double
quotes, and now we're

00:23:49.610 --> 00:23:50.670
switching to all
single quotes.

00:23:50.670 --> 00:23:53.260
And it's a little bit hard to
search and replace for.

00:23:53.260 --> 00:23:56.690
But tooling can actually just
tackle this completely 'cause

00:23:56.690 --> 00:24:01.040
we can just parse the text
into a JavaScript AST, or

00:24:01.040 --> 00:24:05.610
abstract syntax tree, change
all of our quotes, and then

00:24:05.610 --> 00:24:09.780
code generation it back
into our source.

00:24:09.780 --> 00:24:14.570
And we can be confident that
it will still be completely

00:24:14.570 --> 00:24:15.820
valid JavaScript.

00:24:18.290 --> 00:24:20.210
Copy paste mistake detection.

00:24:20.210 --> 00:24:23.230
I believe this is actually
already in WebStorm.

00:24:23.230 --> 00:24:26.870
So let's say if I copy this
first line here, paste it down

00:24:26.870 --> 00:24:30.890
here, and I'm changing the
x1 to x2 but I forget

00:24:30.890 --> 00:24:33.800
to do it over here.

00:24:33.800 --> 00:24:38.530
We had a pretty bad bug in
WebKit for one day where

00:24:38.530 --> 00:24:39.510
someone did this.

00:24:39.510 --> 00:24:45.040
It's almost exactly this
code example, and it's

00:24:45.040 --> 00:24:46.330
a copy paste mistake.

00:24:46.330 --> 00:24:49.016
So this can now be detected.

00:24:49.016 --> 00:24:51.080
And you can be notified.

00:24:51.080 --> 00:24:53.640
It's a really smart thing.

00:24:53.640 --> 00:24:57.450
Like I was talking about style
guides, CodePainter is a tool

00:24:57.450 --> 00:25:00.980
that can reformat the JavaScript
that you're working

00:25:00.980 --> 00:25:03.860
on to fit a style guide.

00:25:03.860 --> 00:25:07.020
So, single quotes, double
quotes, white space around

00:25:07.020 --> 00:25:10.770
arguments, things like that,
CodePainter can just do the

00:25:10.770 --> 00:25:14.300
formatting for you, which I
think it would dramatically

00:25:14.300 --> 00:25:19.690
change a lot on how people
collaborate on projects and to

00:25:19.690 --> 00:25:22.170
worry about things like style.

00:25:22.170 --> 00:25:24.426
This is Travis.

00:25:24.426 --> 00:25:28.120
So Travis CI I is a free
hosted, open source,

00:25:28.120 --> 00:25:29.850
continuous integration setup.

00:25:29.850 --> 00:25:34.340
So, this is a Dojo 2 running
inside Travis.

00:25:34.340 --> 00:25:37.920
So on every commit to this
repository, Travis goes pulls

00:25:37.920 --> 00:25:41.580
down the latest, installs a
bunch of node dependencies,

00:25:41.580 --> 00:25:44.870
and then it connects up to Sauce
Labs, which has a lot of

00:25:44.870 --> 00:25:47.070
browsers in the cloud.

00:25:47.070 --> 00:25:49.660
Connect up with these browsers
using Selenium.

00:25:49.660 --> 00:25:54.240
And then we execute a test
suite inside all these

00:25:54.240 --> 00:25:57.640
browsers, so Firefox and
Internet Explorer, and running

00:25:57.640 --> 00:25:59.710
our test suite just
to make sure that,

00:25:59.710 --> 00:26:01.365
indeed, everything passes.

00:26:04.430 --> 00:26:08.340
Really powerful stuff to get
that immediate feedback of for

00:26:08.340 --> 00:26:11.675
every single commit, how am I
doing against all my platforms

00:26:11.675 --> 00:26:14.800
and all my test suites with
every commit and every poll

00:26:14.800 --> 00:26:16.050
request, too.

00:26:19.110 --> 00:26:21.150
Right now, Travis will come
back and give you a little

00:26:21.150 --> 00:26:23.610
badge and say all
tests passing.

00:26:23.610 --> 00:26:25.830
I'm excited about other products
doing this too using

00:26:25.830 --> 00:26:28.150
something like the GitHub's
commit status API.

00:26:28.150 --> 00:26:34.500
So, for instance, for meeting
style guidelines or meeting

00:26:34.500 --> 00:26:37.540
performance goals or not
making sure that that

00:26:37.540 --> 00:26:43.140
maintainability complexity
thresholds are not violated.

00:26:43.140 --> 00:26:45.480
We can get that kind of
feedback immediately.

00:26:45.480 --> 00:26:48.850
And it should all be automatic
because we as humans should

00:26:48.850 --> 00:26:53.750
not be testing these things
manually on every single time

00:26:53.750 --> 00:26:56.520
and can let the tooling
support this for us.

00:26:56.520 --> 00:26:58.890
So I think we have a little
bit a room to grow there.

00:26:58.890 --> 00:27:00.670
So this is JIRA.

00:27:00.670 --> 00:27:02.780
But this is just a view of all
the things that I just

00:27:02.780 --> 00:27:05.660
mentioned could be looked at
over time over the life cycle

00:27:05.660 --> 00:27:09.110
of a project in a continuous
integration environment.

00:27:09.110 --> 00:27:10.860
And the last one I have--

00:27:10.860 --> 00:27:13.150
not really related but
I think it's cool--

00:27:13.150 --> 00:27:16.610
so this is fighting-layout-bugs
is a CSS

00:27:16.610 --> 00:27:21.050
testing tool that can be used
inside of a continuous

00:27:21.050 --> 00:27:21.670
integration setup.

00:27:21.670 --> 00:27:24.340
It integrates very
well with Maven.

00:27:24.340 --> 00:27:26.490
So if you have a Java stack,
it's great for that.

00:27:26.490 --> 00:27:27.810
And so it does a few things.

00:27:27.810 --> 00:27:33.760
It detects some common layout
bugs where you might have made

00:27:33.760 --> 00:27:36.410
a mistake in the CSS or
might have not tested.

00:27:36.410 --> 00:27:37.490
So take for example
DetectTextNearOr

00:27:37.490 --> 00:27:38.740
OverlappingVerticalEdge.

00:27:41.810 --> 00:27:45.130
And so what this does
is it actually just

00:27:45.130 --> 00:27:46.870
looks at the page--

00:27:46.870 --> 00:27:50.550
and I think it uses PhantomJS,
I believe--

00:27:50.550 --> 00:27:54.940
and finds situations where text
overlaps or goes right up

00:27:54.940 --> 00:27:58.360
against another element in a way
that the software thinks

00:27:58.360 --> 00:27:59.370
is incorrect.

00:27:59.370 --> 00:28:03.150
And it will highlight it to you
to hopefully be like there

00:28:03.150 --> 00:28:04.400
might be a layout bug here.

00:28:08.750 --> 00:28:12.550
This has actually been out for
about three years or so.

00:28:16.360 --> 00:28:18.970
Some of these projects have
been out for a while, but

00:28:18.970 --> 00:28:21.470
we're seeing a little bit more
adoption these days of them

00:28:21.470 --> 00:28:23.500
which I think is really
good things.

00:28:23.500 --> 00:28:27.050
So, I guess that's
about it for me.

00:28:27.050 --> 00:28:27.770
How are we doing, Addy?

00:28:27.770 --> 00:28:29.080
Does that all make sense?

00:28:29.080 --> 00:28:30.130
ADDY OSMANI: Yeah.

00:28:30.130 --> 00:28:32.950
So we talked about snippets
a few episodes back.

00:28:32.950 --> 00:28:36.040
And they're basically a really
neat way to create, edit,

00:28:36.040 --> 00:28:39.280
store, or execute JavaScript
inside the DevTools.

00:28:39.280 --> 00:28:41.560
So if there are like custom
utilities that you always like

00:28:41.560 --> 00:28:44.300
having available at the console
or inside the tools,

00:28:44.300 --> 00:28:46.840
you can just save those as a
snippet and always have them

00:28:46.840 --> 00:28:49.320
available to you whenever
you restart Chrome.

00:28:49.320 --> 00:28:51.360
Now I've got some great
news to share today.

00:28:51.360 --> 00:28:53.840
Snippets are actually moving
out of experiments.

00:28:53.840 --> 00:28:56.000
And that's gonna be happening
sometime soon.

00:28:56.000 --> 00:28:58.600
We've also added a really neat
shortcut to snippets.

00:28:58.600 --> 00:29:00.820
So if you have an existing
snippet and you just want to

00:29:00.820 --> 00:29:02.655
run it without actually clicking
inside the interface,

00:29:02.655 --> 00:29:05.810
there's a cool new keyboard
shortcut, which is control or

00:29:05.810 --> 00:29:07.240
command plus enter.

00:29:07.240 --> 00:29:10.840
So here I've got a snippet
called GrepJS by Nick Decosta.

00:29:10.840 --> 00:29:12.660
It's a really nice
utility to have.

00:29:12.660 --> 00:29:15.310
It'll basically grep over
different objects and find

00:29:15.310 --> 00:29:16.200
things for you.

00:29:16.200 --> 00:29:19.890
But, I'm basically grepping over
the navigator object for

00:29:19.890 --> 00:29:21.000
geo because I'm looking for the

00:29:21.000 --> 00:29:22.760
geolocation support in there.

00:29:22.760 --> 00:29:25.720
So I'm basically gonna go and
use my command-enter.

00:29:25.720 --> 00:29:27.500
And as you can see, it's
gone and it's run

00:29:27.500 --> 00:29:28.900
my snippet for me.

00:29:28.900 --> 00:29:31.030
I expand out, and I can see,
OK, well there's the

00:29:31.030 --> 00:29:33.190
geolocation that I
was looking for.

00:29:33.190 --> 00:29:34.730
It's just really neat.

00:29:34.730 --> 00:29:38.110
I've seen a ton of people create
really useful utilities

00:29:38.110 --> 00:29:39.310
and just saving them
as snippets.

00:29:39.310 --> 00:29:41.620
It's great to always have
access to them.

00:29:41.620 --> 00:29:43.385
So just check it out.

00:29:43.385 --> 00:29:44.860
Snippets are really,
really awesome.

00:29:44.860 --> 00:29:49.280
And, actually on this same page,
there is a post I was

00:29:49.280 --> 00:29:51.730
hoping to suggest people
check out by my

00:29:51.730 --> 00:29:53.460
colleague Paul Lewis.

00:29:53.460 --> 00:29:56.100
And it basically discusses a
little bit more about those

00:29:56.100 --> 00:29:58.360
layer creation hacks and
the null transforms and

00:29:58.360 --> 00:30:00.370
translateZs and all
that stuff.

00:30:00.370 --> 00:30:01.650
It's a really awesome post.

00:30:01.650 --> 00:30:04.750
He goes into a lot more detail
about this stuff than I have.

00:30:04.750 --> 00:30:05.400
But check it out.

00:30:05.400 --> 00:30:07.580
We will link you up
to it later on.

00:30:07.580 --> 00:30:10.210
But, yeah, it's really useful.

00:30:10.210 --> 00:30:14.370
Paul also has a paint survey
out at the moment where he

00:30:14.370 --> 00:30:18.710
asks developers do you have a
paint bottleneck in your apps

00:30:18.710 --> 00:30:19.670
at the moment?

00:30:19.670 --> 00:30:23.000
So far it looks like a lot of
people think they may have a

00:30:23.000 --> 00:30:24.890
paint bottleneck but aren't
entirely sure how

00:30:24.890 --> 00:30:26.480
to diagnosis things.

00:30:26.480 --> 00:30:28.680
We're gonna be looking at that
stuff sometime soon.

00:30:28.680 --> 00:30:31.980
And I think Paul's gonna talk a
little bit more about that.

00:30:31.980 --> 00:30:35.410
PAUL IRISH: Paint cost
in another episode.

00:30:35.410 --> 00:30:40.810
But we're really eager to hear
more from you guys on what are

00:30:40.810 --> 00:30:43.470
your paint points when
identifying what is

00:30:43.470 --> 00:30:48.580
contributing to paint issues,
both on mobile and desktop,

00:30:48.580 --> 00:30:50.890
and figuring out how we can
better support you guys inside

00:30:50.890 --> 00:30:53.670
the DevTools with good
solutions for that.

00:30:53.670 --> 00:30:56.745
So, we'd love to get more of
your feedback regarding that

00:30:56.745 --> 00:30:58.346
kind of stuff.

00:30:58.346 --> 00:30:58.810
ADDY OSMANI: Defintely.

00:30:58.810 --> 00:31:00.830
PAUL IRISH: Anyways, thank you
guys very much for watching.

00:31:00.830 --> 00:31:01.580
It's been a pleasure.

00:31:01.580 --> 00:31:02.930
And we'll see you again soon.

