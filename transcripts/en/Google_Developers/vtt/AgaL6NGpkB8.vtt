WEBVTT
Kind: captions
Language: en

00:00:00.801 --> 00:00:01.734
Slatkin:
Welcome to my talk.

00:00:01.734 --> 00:00:05.267
This is "Building Scalable,
Complex Apps on App Engine."

00:00:05.267 --> 00:00:06.567
I am Brett Slatkin.

00:00:06.567 --> 00:00:10.467
I am a software engineer
on the Google App Engine team.

00:00:10.467 --> 00:00:13.701
And...yeah.
So let's just jump right in.

00:00:13.701 --> 00:00:15.667
So the agenda--
here's the agenda.

00:00:15.667 --> 00:00:19.033
So we're gonna talk
about two subjects today

00:00:19.033 --> 00:00:20.601
that are, I think,
really interesting

00:00:20.601 --> 00:00:23.200
for building
App Engine apps.

00:00:23.200 --> 00:00:24.334
The first one
is list properties.

00:00:24.334 --> 00:00:26.534
We're gonna talk
about what they are,

00:00:26.534 --> 00:00:27.868
how they work.

00:00:27.868 --> 00:00:29.334
I'm gonna give you
a concrete example

00:00:29.334 --> 00:00:30.701
of microblogging

00:00:30.701 --> 00:00:33.334
to illustrate
why they're useful.

00:00:33.334 --> 00:00:35.067
And then we're gonna talk
about maximizing the performance

00:00:35.067 --> 00:00:37.767
of list properties,

00:00:37.767 --> 00:00:39.801
with some detail in there.

00:00:39.801 --> 00:00:41.567
The second topic
is merge-join.

00:00:41.567 --> 00:00:43.033
We're gonna talk
about what it is,

00:00:43.033 --> 00:00:45.534
how it works,
and list property magic--

00:00:45.534 --> 00:00:47.601
some really cool things
you can do with App Engine

00:00:47.601 --> 00:00:50.534
that people don't realize
is actually possible.

00:00:50.534 --> 00:00:53.234
And the concrete example
there that I'm going to show

00:00:53.234 --> 00:00:55.300
is modeling
the social graph.

00:00:55.300 --> 00:00:58.367
And again,
there's some other detail.

00:00:58.367 --> 00:01:00.701
I didn't get hooked up
on the Moderator thing

00:01:00.701 --> 00:01:03.267
in time for this, but I have
just set up my own here--

00:01:03.267 --> 00:01:05.801
tinyurl.com/complextalk.

00:01:05.801 --> 00:01:09.200
So please hop on,
put in some questions,

00:01:09.200 --> 00:01:10.501
if you're confused
by anything,

00:01:10.501 --> 00:01:12.868
vote up on anything,

00:01:12.868 --> 00:01:16.801
hopefully that'll work.

00:01:16.801 --> 00:01:18.133
All right, so let's--
let's go in here.

00:01:18.133 --> 00:01:20.534
So I guess the one little thing
I wanted to say

00:01:20.534 --> 00:01:22.400
before all this was...

00:01:22.400 --> 00:01:24.367
it's been
a really exciting year

00:01:24.367 --> 00:01:26.133
on App Engine,
on the App Engine Team--

00:01:26.133 --> 00:01:27.501
seeing all the developers
do all these things,

00:01:27.501 --> 00:01:30.067
seeing our developers
wrap their heads around

00:01:30.067 --> 00:01:31.767
all the crazy things
that we ask you to do

00:01:31.767 --> 00:01:33.434
with our datastore.

00:01:33.434 --> 00:01:36.200
I am gonna make this
even harder for you

00:01:36.200 --> 00:01:37.701
to understand,
maybe.

00:01:37.701 --> 00:01:39.234
I'm gonna just throw you
into the fire a little bit

00:01:39.234 --> 00:01:41.834
because people
seem to like that.

00:01:41.834 --> 00:01:44.334
So if I'm going too fast
or it's a little complicated,

00:01:44.334 --> 00:01:47.200
please ask me a question--

00:01:47.200 --> 00:01:48.834
especially on Moderator--

00:01:48.834 --> 00:01:50.634
but hopefully
it'll make sense.

00:01:50.634 --> 00:01:53.767
But, you know,
if it doesn't make sense,

00:01:53.767 --> 00:01:55.601
hopefully I'll explain it
in a later slide

00:01:55.601 --> 00:01:57.434
and so, yeah,
just bear with me

00:01:57.434 --> 00:01:59.567
is what I'm trying to say.

00:01:59.567 --> 00:02:02.200
Okay, so what
is a list property?

00:02:02.200 --> 00:02:04.667
So it's just another property
in the datastore.

00:02:04.667 --> 00:02:07.501
It has multiple values.

00:02:07.501 --> 00:02:09.934
So it's an ordered list
that maintains its order.

00:02:09.934 --> 00:02:13.934
So when you write the entity
or you retrieve the entity,

00:02:13.934 --> 00:02:15.434
it comes back
in the same order--

00:02:15.434 --> 00:02:16.968
this property
comes back as a list

00:02:16.968 --> 00:02:19.267
in the same order
that you wrote it.

00:02:19.267 --> 00:02:22.701
Now, when you query,
it uses an equals filter.

00:02:22.701 --> 00:02:26.000
But the interesting thing
is that when you do that query,

00:02:26.000 --> 00:02:29.300
it matches any of the possible
values in that list.

00:02:29.300 --> 00:02:32.167
So the entity will match
for any individual item

00:02:32.167 --> 00:02:34.701
in that list.

00:02:34.701 --> 00:02:38.467
And...and one of the things
that's also funny

00:02:38.467 --> 00:02:40.701
is that--because of the way
that App Engine works,

00:02:40.701 --> 00:02:42.734
the default sort order
on list properties

00:02:42.734 --> 00:02:44.133
is not very useful.

00:02:44.133 --> 00:02:47.200
It's kind of complicated,
and we'll get into why.

00:02:47.200 --> 00:02:49.167
So you have to sometimes
use composite indexes

00:02:49.167 --> 00:02:50.734
if you want
some distinct ordering

00:02:50.734 --> 00:02:51.968
with list properties.

00:02:51.968 --> 00:02:53.834
You'll understand
what I mean in a minute.

00:02:53.834 --> 00:02:55.033
But they're
very easy to use.

00:02:55.033 --> 00:02:56.567
I mean,
here's an example right here.

00:02:56.567 --> 00:02:58.200
I have a "Favorites"
model class.

00:02:58.200 --> 00:03:01.334
I have a list of colors,

00:03:01.334 --> 00:03:04.701
and then I have the user
that those favorites belong to.

00:03:04.701 --> 00:03:06.100
If I want to assign
a list property,

00:03:06.100 --> 00:03:07.801
I just--it's a list;
I just assign it.

00:03:07.801 --> 00:03:11.334
That's it.
That's all there is to it.

00:03:11.334 --> 00:03:14.367
Now, why would you
want to do this, you know?

00:03:14.367 --> 00:03:16.234
Like, this is
a many-to-one relationship

00:03:16.234 --> 00:03:17.501
that I am modeling.

00:03:17.501 --> 00:03:19.000
Why would you do this
as opposed to

00:03:19.000 --> 00:03:21.033
inserting a new entry
in the database

00:03:21.033 --> 00:03:24.667
for each--for each part
of the one-to-many relationship?

00:03:24.667 --> 00:03:26.133
Well, there's a few reasons.

00:03:26.133 --> 00:03:29.267
First, you can densely
pack information.

00:03:29.267 --> 00:03:32.267
You can track lists
of related items in a way

00:03:32.267 --> 00:03:36.534
that's much more efficient
in terms of space and CPU.

00:03:36.534 --> 00:03:38.868
You could also use
multiple lists in parallel

00:03:38.868 --> 00:03:40.167
to store "tuples."

00:03:40.167 --> 00:03:42.400
So two lists in parallel
would be a pair.

00:03:42.400 --> 00:03:45.467
Three would be a triple...
so on.

00:03:45.467 --> 00:03:47.501
It's also just
kind of easier to use.

00:03:47.501 --> 00:03:48.868
If you look at this example,

00:03:48.868 --> 00:03:51.000
this would be a standard
one-to-many relationship

00:03:51.000 --> 00:03:52.467
in the datastore.

00:03:52.467 --> 00:03:55.267
Here again I have the--
a single entity

00:03:55.267 --> 00:03:56.601
representing
a favorite color.

00:03:56.601 --> 00:03:59.467
And I would write multiple
of these for each user.

00:03:59.467 --> 00:04:01.834
And then to find the--a list
of somebody's favorite colors,

00:04:01.834 --> 00:04:03.400
I would actually
have to do a query

00:04:03.400 --> 00:04:05.467
and retrieve the data.

00:04:05.467 --> 00:04:08.367
So, you know, that's
a lot more complicated

00:04:08.367 --> 00:04:12.200
than just saying
.colors.

00:04:12.200 --> 00:04:15.434
But, more importantly,
list properties are great

00:04:15.434 --> 00:04:17.367
for answering
set membership questions.

00:04:17.367 --> 00:04:18.934
And this is where
the queries come in.

00:04:18.934 --> 00:04:21.267
So which colors--
like, here,

00:04:21.267 --> 00:04:22.934
an example
is which color is like--

00:04:22.934 --> 00:04:25.601
which users
like the color yellow?

00:04:25.601 --> 00:04:28.067
And so here
is an example.

00:04:28.067 --> 00:04:30.634
I say, "Give me
all favorite colors

00:04:30.634 --> 00:04:32.868
where the favorite color
is yellow."

00:04:32.868 --> 00:04:34.634
It gives me back
the results,

00:04:34.634 --> 00:04:36.000
and then I can pull out
the usernames.

00:04:36.000 --> 00:04:38.000
It's a simple query
to give me

00:04:38.000 --> 00:04:40.000
some pretty
interesting information

00:04:40.000 --> 00:04:42.067
very easily.

00:04:42.067 --> 00:04:43.934
Now, this seems
really simple,

00:04:43.934 --> 00:04:46.100
but this actually
has a great fan-out capability.

00:04:46.100 --> 00:04:48.334
I can--I can cut
across all of my data.

00:04:48.334 --> 00:04:51.300
I can match kind of any--
any value of yellow

00:04:51.300 --> 00:04:52.801
in users' lists
of favorite colors

00:04:52.801 --> 00:04:55.033
across all FavoriteColor
entities.

00:04:55.033 --> 00:04:57.467
So we'll get more into
what "fan-out" means later.

00:04:57.467 --> 00:05:02.467
But there's--there's some
really useful things in here.

00:05:02.467 --> 00:05:04.200
Now, why would you
use list properties,

00:05:04.200 --> 00:05:07.200
again, over the normal
one-to-many relationship?

00:05:07.200 --> 00:05:09.200
Well, first of all,
each list item

00:05:09.200 --> 00:05:10.601
only has
an index entry.

00:05:10.601 --> 00:05:13.200
So normally when you take a--
the App Engine datastore

00:05:13.200 --> 00:05:14.400
and you write an entity,

00:05:14.400 --> 00:05:15.667
you're writing
into multiple indexes.

00:05:15.667 --> 00:05:18.300
You write the entity itself
into the entities table

00:05:18.300 --> 00:05:20.067
and you write
into the "by kind" index.

00:05:20.067 --> 00:05:22.767
And you write into each of
the different property indexes.

00:05:22.767 --> 00:05:24.133
And you write
into composite indexes.

00:05:24.133 --> 00:05:25.501
And so there's
a bunch of overhead

00:05:25.501 --> 00:05:27.801
with actually
storing that entity.

00:05:27.801 --> 00:05:29.601
And with a list item,

00:05:29.601 --> 00:05:31.667
you only actually
add one index row.

00:05:31.667 --> 00:05:33.267
That's it.

00:05:33.267 --> 00:05:36.000
So--so where, you know,
a normal entity, right,

00:05:36.000 --> 00:05:38.100
would have, say, five,
this would only have one.

00:05:38.100 --> 00:05:39.634
So less storage.

00:05:39.634 --> 00:05:41.767
You also save
the space of the keys

00:05:41.767 --> 00:05:43.667
of that entity in that index,

00:05:43.667 --> 00:05:47.200
which also saves you
more space.

00:05:47.200 --> 00:05:50.434
And so, ultimately,
you're just saving space.

00:05:50.434 --> 00:05:53.133
And it's easier to understand.

00:05:53.133 --> 00:05:56.300
It's just a list.

00:05:56.300 --> 00:05:57.834
There are a couple
of gotchas, though.

00:05:57.834 --> 00:05:59.167
It doesn't come
for free, you know.

00:05:59.167 --> 00:06:00.567
It's all about trade-offs.

00:06:00.567 --> 00:06:03.000
So, you know,
list properties use more CPU

00:06:03.000 --> 00:06:04.934
for serializing
and deserializing

00:06:04.934 --> 00:06:07.200
than--than doing it
the other way.

00:06:07.200 --> 00:06:08.501
When you access the entity,

00:06:08.501 --> 00:06:10.300
you have to serialize
and deserialize the whole list.

00:06:10.300 --> 00:06:13.300
We'll get into what that means
and why that's bad.

00:06:13.300 --> 00:06:15.067
The other thing is,
like I said,

00:06:15.067 --> 00:06:16.868
the sort orders aren't
very useful on their own.

00:06:16.868 --> 00:06:19.167
So if you--
if you want to use

00:06:19.167 --> 00:06:20.634
list properties
and sort orders,

00:06:20.634 --> 00:06:22.567
you need to use
a composite index.

00:06:22.567 --> 00:06:24.734
And you need
to be careful that

00:06:24.734 --> 00:06:27.434
you only use
one list property

00:06:27.434 --> 00:06:28.834
in a composite index

00:06:28.834 --> 00:06:30.834
or else you get
this "exploding" problem.

00:06:30.834 --> 00:06:32.968
What is exploding and
what is an exploding index?

00:06:32.968 --> 00:06:34.767
So here's the idea:

00:06:34.767 --> 00:06:36.968
You have a list property
with 1,000 entries in it.

00:06:36.968 --> 00:06:38.400
And then you have
another list property

00:06:38.400 --> 00:06:39.734
with 1,000 entries in it.

00:06:39.734 --> 00:06:42.100
If you want to build
a composite index on both,

00:06:42.100 --> 00:06:45.300
you need the--the cross product
of all of them.

00:06:45.300 --> 00:06:47.934
So you actually need
1 million index entries

00:06:47.934 --> 00:06:50.400
to represent
all the possible combinations

00:06:50.400 --> 00:06:52.434
of how
those could pair up.

00:06:52.434 --> 00:06:54.167
And that's--
that's the explosion

00:06:54.167 --> 00:06:55.734
in storage space.

00:06:55.734 --> 00:06:58.601
So watch out for that.

00:06:58.601 --> 00:07:00.734
But there's a lot of stuff
you can do that's useful

00:07:00.734 --> 00:07:02.567
with creating
on just one list property.

00:07:02.567 --> 00:07:04.801
And I'll explain.

00:07:04.801 --> 00:07:07.934
So let's get into
our concrete example.

00:07:07.934 --> 00:07:10.033
I feel like
every conference I've seen

00:07:10.033 --> 00:07:11.467
in the last two years

00:07:11.467 --> 00:07:13.200
has somebody explaining

00:07:13.200 --> 00:07:16.000
how to make your favorite
microblogging service scale.

00:07:16.000 --> 00:07:17.667
For real, this time,
on my platform,

00:07:17.667 --> 00:07:19.701
I--I swear to you--

00:07:19.701 --> 00:07:21.501
I guess I'm guilty of that.

00:07:21.501 --> 00:07:23.467
But microblogging is actually
a very interesting example.

00:07:23.467 --> 00:07:24.701
So microblogging--

00:07:24.701 --> 00:07:28.567
I mean stuff like
Jaiku, Twitter, identi.ca,

00:07:28.567 --> 00:07:30.968
some of the other ones
out there.

00:07:30.968 --> 00:07:33.868
And it's basically
a very high speed feed

00:07:33.868 --> 00:07:35.467
of small messages.

00:07:35.467 --> 00:07:37.834
It represents the publish
and subscribe use case.

00:07:37.834 --> 00:07:40.133
It's also broadcast,
multicast--

00:07:40.133 --> 00:07:41.434
kind of the same thing.

00:07:41.434 --> 00:07:43.133
The general idea is
the user sends a message

00:07:43.133 --> 00:07:45.968
and it goes
to many other users...

00:07:45.968 --> 00:07:47.234
a lot of users.

00:07:47.234 --> 00:07:49.000
In some cases,
millions of them.

00:07:49.000 --> 00:07:50.734
And it's a great example
of fan-out,

00:07:50.734 --> 00:07:52.467
because
one simple user action--

00:07:52.467 --> 00:07:54.834
typing in your 140 characters,
pushing return--

00:07:54.834 --> 00:07:56.801
causes a lot of work
to happen,

00:07:56.801 --> 00:07:58.934
causes a lot of data
that needs to be surfaced,

00:07:58.934 --> 00:08:01.234
a lot of people
that need to be notified,

00:08:01.234 --> 00:08:02.734
and it's so easy to do

00:08:02.734 --> 00:08:04.934
that you're constantly trying
to catch up with this work.

00:08:04.934 --> 00:08:07.000
That's why
it's hard to scale this.

00:08:07.000 --> 00:08:09.167
And that's just
the nature of fan-out.

00:08:09.167 --> 00:08:10.767
It's hard.

00:08:10.767 --> 00:08:13.501
So let's talk about
an example of fan-out,

00:08:13.501 --> 00:08:15.133
kind of the naive way
of doing it.

00:08:15.133 --> 00:08:18.167
Now, fan-out is hard
because it can be inefficient.

00:08:18.167 --> 00:08:22.334
You can require
duplicate data.

00:08:22.334 --> 00:08:25.434
And so this is kind of
the email example.

00:08:25.434 --> 00:08:27.300
If you imagine
that each of these users--

00:08:27.300 --> 00:08:29.968
"B," "C," and "D"--
are different email users

00:08:29.968 --> 00:08:32.400
on different email servers,

00:08:32.400 --> 00:08:34.667
when SMTP
wants to send a message,

00:08:34.667 --> 00:08:35.968
what does it do?

00:08:35.968 --> 00:08:37.501
Well, it sends
a copy of the message

00:08:37.501 --> 00:08:39.234
to each SMTP server.

00:08:39.234 --> 00:08:42.033
So that's copying
all the bandwidth, all the data.

00:08:42.033 --> 00:08:44.334
Each SMTP server
needs to manage it differently,

00:08:44.334 --> 00:08:46.801
and all the users
get their own copy.

00:08:46.801 --> 00:08:49.968
And eventually they download it
to their own machine,

00:08:49.968 --> 00:08:54.501
and there's just a lot
of duplicate work happening.

00:08:54.501 --> 00:08:55.934
Now, this is
kind of a testament

00:08:55.934 --> 00:08:57.367
to why SMTP works so well.

00:08:57.367 --> 00:08:59.000
It's scaled just fine.

00:08:59.000 --> 00:09:02.000
But the throughput's
kind of lower in some ways.

00:09:02.000 --> 00:09:04.200
And the fan-out's
usually pretty low.

00:09:04.200 --> 00:09:06.033
People don't usually send
emails to a million people.

00:09:06.033 --> 00:09:10.334
They send it to 100
or a listserv.

00:09:10.334 --> 00:09:13.300
A better way
to do fan-out is like this.

00:09:13.300 --> 00:09:15.234
You know,
not duplicate any data.

00:09:15.234 --> 00:09:17.701
So ideally
we'd kind of do--

00:09:17.701 --> 00:09:19.534
do message sending
by reference.

00:09:19.534 --> 00:09:22.334
We'd have user "A"
send a message.

00:09:22.334 --> 00:09:25.300
The message would be--
have all of the different...

00:09:25.300 --> 00:09:27.868
users who should get it
annotated on it,

00:09:27.868 --> 00:09:29.968
And then they would just
receive it by reference.

00:09:29.968 --> 00:09:31.601
We would be able to figure out,
"Oh, here are the messages

00:09:31.601 --> 00:09:34.901
that user 'B'
should receive."

00:09:34.901 --> 00:09:37.901
So let's talk about
how to do that model

00:09:37.901 --> 00:09:39.901
using a traditional
relational database.

00:09:39.901 --> 00:09:42.000
This is probably
what it would look like.

00:09:42.000 --> 00:09:43.434
There's probably
a better way to do it,

00:09:43.434 --> 00:09:45.834
but this is the first thing
that I think would come to mind.

00:09:45.834 --> 00:09:47.367
You have a table of users.

00:09:47.367 --> 00:09:49.334
You have a table of messages.

00:09:49.334 --> 00:09:53.267
Then you have the table of
messages that users should get.

00:09:53.267 --> 00:09:55.934
So each user has an I.D.
and some properties--

00:09:55.934 --> 00:09:57.434
their name, et cetera.

00:09:57.434 --> 00:09:58.701
You have a table
of the messages,

00:09:58.701 --> 00:10:00.167
the body of the message,
title,

00:10:00.167 --> 00:10:01.667
time it was sent,
et cetera.

00:10:01.667 --> 00:10:04.067
And then you have a--
the relationship

00:10:04.067 --> 00:10:05.734
between these two
primary I.D.s,

00:10:05.734 --> 00:10:08.567
which is the join table.

00:10:08.567 --> 00:10:10.767
So how would you
do this in SQL?

00:10:10.767 --> 00:10:13.501
Well, if you want to find
messages for the user "X,"

00:10:13.501 --> 00:10:15.801
you would do a join.

00:10:15.801 --> 00:10:19.367
You'd select from messages
all the user messages--

00:10:19.367 --> 00:10:21.200
select from messages
all messages

00:10:21.200 --> 00:10:24.033
with a "join"
on the UserMessages table

00:10:24.033 --> 00:10:27.767
using message_id to join
the two tables together.

00:10:27.767 --> 00:10:32.267
So that's basically
connecting the dots.

00:10:32.267 --> 00:10:34.033
And then you would say,

00:10:34.033 --> 00:10:35.901
"Now only give me
the ones for user 'X.'"

00:10:35.901 --> 00:10:38.234
And that's how you
get that list.

00:10:38.234 --> 00:10:40.000
But there are no joins
on App Engine.

00:10:40.000 --> 00:10:41.968
So how do you do this?

00:10:41.968 --> 00:10:43.901
How would you
implement this on App Engine?

00:10:43.901 --> 00:10:45.133
The answer
is list properties.

00:10:45.133 --> 00:10:51.067
They--they come
to our rescue here.

00:10:51.067 --> 00:10:53.167
So with App Engine,

00:10:53.167 --> 00:10:55.701
I define
a simple message class.

00:10:55.701 --> 00:10:57.434
This is a--
just a DB model.

00:10:57.434 --> 00:10:59.434
I'm doing this in Python just
'cause it's a little shorter.

00:10:59.434 --> 00:11:02.601
I say,
"Here's my sender."

00:11:02.601 --> 00:11:04.400
I have a list
of receivers.

00:11:04.400 --> 00:11:06.033
These are the people
that should get my messages

00:11:06.033 --> 00:11:07.601
by reference.

00:11:07.601 --> 00:11:10.868
Then I have a body, which is
the actual body of the message.

00:11:10.868 --> 00:11:13.667
Now, to figure out
what messages I get,

00:11:13.667 --> 00:11:15.667
I just do a simple query.

00:11:15.667 --> 00:11:18.968
I say, "Give me all the messages
where I'm a receiver."

00:11:18.968 --> 00:11:21.767
Seems pretty natural.
There are no joins.

00:11:21.767 --> 00:11:23.901
It's just--it's just done.

00:11:23.901 --> 00:11:26.534
And this is essentially
how Jaiku works

00:11:26.534 --> 00:11:27.868
at its core--

00:11:27.868 --> 00:11:29.701
this simple idea
of doing fan-out

00:11:29.701 --> 00:11:33.801
with list properties.

00:11:33.801 --> 00:11:36.300
Now, with JDO
you can do the same thing.

00:11:36.300 --> 00:11:38.033
Here, again,

00:11:38.033 --> 00:11:40.634
you have the autogenerated I.D.
of the message.

00:11:40.634 --> 00:11:42.400
You have a sender,
you have the body,

00:11:42.400 --> 00:11:44.567
and you have
a list of receivers.

00:11:44.567 --> 00:11:46.234
Exactly the same idea.

00:11:46.234 --> 00:11:49.567
To do the query--
I'm sorry.

00:11:49.567 --> 00:11:52.367
Everyone get it?

00:11:52.367 --> 00:11:54.667
All right.

00:11:54.667 --> 00:11:56.567
To do the query
you do exactly the same thing.

00:11:56.567 --> 00:11:58.200
It's a list property
with an equals filter.

00:11:58.200 --> 00:11:59.567
You get
your PersistenceManager,

00:11:59.567 --> 00:12:01.667
you create your query
on the Message.class,

00:12:01.667 --> 00:12:04.601
you filter on the receivers
using an equals filter,

00:12:04.601 --> 00:12:06.434
and then you
get back a message.

00:12:06.434 --> 00:12:09.868
And at that point,
results.receivers

00:12:09.868 --> 00:12:16.100
is the list of receivers
that you want to--to access.

00:12:16.100 --> 00:12:19.200
Okay, so let's have a--
let's have a go.

00:12:19.200 --> 00:12:21.834
Let me show you the actual--
let me show you it in action.

00:12:21.834 --> 00:12:24.033
So this is
a little app I wrote

00:12:24.033 --> 00:12:26.834
called
"Publish-subscribe test."

00:12:26.834 --> 00:12:28.400
The source code's
available online.

00:12:28.400 --> 00:12:30.334
I have a link to it later.

00:12:30.334 --> 00:12:34.000
And this lets me demonstrate
how this works.

00:12:34.000 --> 00:12:36.334
So to make this simple,
I just made it

00:12:36.334 --> 00:12:38.868
so that you specify the number
of receivers you want.

00:12:38.868 --> 00:12:40.434
And it'll go
and send that message

00:12:40.434 --> 00:12:42.367
to that many receivers.

00:12:42.367 --> 00:12:45.434
So here I can
have my nickname: Brett.

00:12:45.434 --> 00:12:48.267
I want to send it to,
say, 100 receivers,

00:12:48.267 --> 00:12:51.033
and say, "Hi from I/O."

00:12:51.033 --> 00:12:54.434
Then I submit.
Great. Message sent.

00:12:54.434 --> 00:12:56.033
So now if I look
at Message 1,

00:12:56.033 --> 00:12:59.100
I can retrieve it.

00:12:59.100 --> 00:13:01.000
And then I have
a list of them here.

00:13:01.000 --> 00:13:03.167
I think--I think I have
too many examples in here.

00:13:03.167 --> 00:13:06.033
I didn't do paging yet,
but it's in there.

00:13:06.033 --> 00:13:08.300
And I'll get to why
I have all these--

00:13:08.300 --> 00:13:10.234
all this demi-data
in just a sec.

00:13:16.601 --> 00:13:18.634
Right.
So pretty simple.

00:13:18.634 --> 00:13:20.334
Really easy.
Really simple query.

00:13:20.334 --> 00:13:22.634
Easy to do writes.

00:13:22.634 --> 00:13:25.501
So let's talk about
the performance of this, though.

00:13:25.501 --> 00:13:27.968
So index writes are done
in parallel on BigTable.

00:13:27.968 --> 00:13:30.934
That means that it's fast.
It's really fast.

00:13:30.934 --> 00:13:33.434
You can update a list property
with 1,000 items.

00:13:33.434 --> 00:13:35.934
That'll actually do
1,000 different writes

00:13:35.934 --> 00:13:38.400
to BigTable simultaneously
in parallel,

00:13:38.400 --> 00:13:40.501
which is--
that's a lot of throughput.

00:13:40.501 --> 00:13:45.968
The write time complexity,
cost CPU time, the latency--

00:13:45.968 --> 00:13:48.701
it scales linearly
with the number of items.

00:13:48.701 --> 00:13:50.400
And right now we limit--

00:13:50.400 --> 00:13:52.901
we limit you to 5,000
indexed properties per entity

00:13:52.901 --> 00:13:55.501
kind of for safety.

00:13:55.501 --> 00:13:57.767
And the storage cost
is about the same

00:13:57.767 --> 00:13:59.868
as a relational
database system.

00:13:59.868 --> 00:14:01.267
In a relational database,

00:14:01.267 --> 00:14:02.767
you'd have that
user messages table.

00:14:02.767 --> 00:14:06.000
You'd have the user key
and you'd have the message key

00:14:06.000 --> 00:14:07.367
in the join table,

00:14:07.367 --> 00:14:10.133
and that would be your cost
of sending a message.

00:14:10.133 --> 00:14:11.901
You'd have to write
different rows for each person

00:14:11.901 --> 00:14:13.467
that needs
to receive the message.

00:14:13.467 --> 00:14:15.701
In the datastore,
it's exactly the same way.

00:14:15.701 --> 00:14:17.033
You have the entity key

00:14:17.033 --> 00:14:18.801
and then you have
the list property value--

00:14:18.801 --> 00:14:20.200
the person
who should receive it.

00:14:20.200 --> 00:14:23.434
And those are the only things
that you need to store.

00:14:23.434 --> 00:14:28.033
So it's just primary keys.

00:14:28.033 --> 00:14:30.334
But there's a downside--
I kind of hinted at it--

00:14:30.334 --> 00:14:32.100
Serialization.

00:14:32.100 --> 00:14:34.934
So the problem is that

00:14:34.934 --> 00:14:36.467
writes have
to pack your list

00:14:36.467 --> 00:14:39.033
into one serialized
protocol buffer.

00:14:39.033 --> 00:14:41.067
Protocol buffers
are an internal tool--

00:14:41.067 --> 00:14:42.634
it's now external,
available for you.

00:14:42.634 --> 00:14:45.334
It's a very quick
serialization

00:14:45.334 --> 00:14:47.834
marshaling
kind of protocol.

00:14:47.834 --> 00:14:50.434
And it's really fast,
and it's space efficient.

00:14:50.434 --> 00:14:53.200
But even so, if you
have 1,000, 2,000 items,

00:14:53.200 --> 00:14:55.601
that packaging
can take a little while.

00:14:55.601 --> 00:14:57.567
Now, for writes
this is okay

00:14:57.567 --> 00:14:59.067
because writes
are relatively infrequent.

00:14:59.067 --> 00:15:01.601
They're a lot less
frequent than reads.

00:15:01.601 --> 00:15:03.534
The killer here is that

00:15:03.534 --> 00:15:07.067
queries also have to unpackage
all the result entities.

00:15:07.067 --> 00:15:09.033
So if you remember
our message class--

00:15:09.033 --> 00:15:11.100
I'm gonna zip back here.

00:15:11.100 --> 00:15:14.167
Our message class
has a list of receivers.

00:15:14.167 --> 00:15:15.868
If you have
1,000 receivers in there,

00:15:15.868 --> 00:15:17.400
that's gonna take
a little while

00:15:17.400 --> 00:15:18.734
if you receive just one.

00:15:18.734 --> 00:15:21.801
Now, what if you
want to take 100 messages?

00:15:21.801 --> 00:15:24.601
Then you have to deserialize
100 times 1,000--

00:15:24.601 --> 00:15:28.434
100,000 different
list property values--

00:15:28.434 --> 00:15:29.834
from your entities.

00:15:29.834 --> 00:15:32.467
And that serialization cost
gets pretty high.

00:15:32.467 --> 00:15:37.167
So we've got a problem.

00:15:37.167 --> 00:15:39.868
And it's--
it uses a lot of CPU.

00:15:39.868 --> 00:15:44.267
It uses a lot of latency,
datastore latency,

00:15:44.267 --> 00:15:46.367
so end user latency
is pretty high.

00:15:46.367 --> 00:15:49.033
It's--it's--
it's just not very good.

00:15:49.033 --> 00:15:51.100
And so now you're saying,

00:15:51.100 --> 00:15:52.601
"Well, why are you telling me
about all this stuff

00:15:52.601 --> 00:15:54.767
if I can't use it,"
right?

00:15:54.767 --> 00:15:56.601
Well, luckily,
I have a solution.

00:15:56.601 --> 00:15:58.434
But we'll get to it.

00:15:58.434 --> 00:16:00.767
So really,
when I query for messages,

00:16:00.767 --> 00:16:02.467
I only really want
the message information.

00:16:02.467 --> 00:16:04.033
I don't really care
about the index

00:16:04.033 --> 00:16:06.000
that got me the information
after the fact.

00:16:06.000 --> 00:16:08.300
The problem with App Engine:
a little--in a bit

00:16:08.300 --> 00:16:11.167
is that, you know, you're
carrying your indexes with you

00:16:11.167 --> 00:16:12.767
because you're using
a denormalized schema

00:16:12.767 --> 00:16:13.968
a lot of the time.

00:16:13.968 --> 00:16:17.267
The receivers list
is a denormalized index.

00:16:17.267 --> 00:16:18.667
And when you
retrieve an entity,

00:16:18.667 --> 00:16:21.133
you pull
that whole index down also.

00:16:21.133 --> 00:16:22.968
But we don't really care
about the list property

00:16:22.968 --> 00:16:24.267
after we query.

00:16:24.267 --> 00:16:25.734
We, you know, we only
care about the message body,

00:16:25.734 --> 00:16:27.968
the sender,
and metainformation.

00:16:27.968 --> 00:16:30.734
So what if we could selectively
skip certain properties

00:16:30.734 --> 00:16:32.501
when we're querying?

00:16:32.501 --> 00:16:34.200
So, for instance,
the receivers list--

00:16:34.200 --> 00:16:36.501
just don't give it
back to me.

00:16:36.501 --> 00:16:38.300
Then we could avoid
the serialization cost.

00:16:38.300 --> 00:16:41.434
Then we'd just get the message
bodies that we care about.

00:16:41.434 --> 00:16:43.868
And ideally we could do
something like what SQL does,

00:16:43.868 --> 00:16:45.133
where we can just say,
"Hey," you know,

00:16:45.133 --> 00:16:47.167
"give me only these
columns of the table."

00:16:47.167 --> 00:16:49.133
But you can't do that.

00:16:49.133 --> 00:16:50.834
We don't have support
for that yet.

00:16:50.834 --> 00:16:52.167
Still trying to figure out
how that works

00:16:52.167 --> 00:16:56.434
with our whole all-around
scheme in the DB module.

00:16:56.434 --> 00:16:57.868
But we have a solution.

00:16:57.868 --> 00:16:59.968
And that's something called
the relation index entity.

00:16:59.968 --> 00:17:01.501
This is kind of
a new thing.

00:17:01.501 --> 00:17:03.033
I don't--I don't know
what the best name for it is,

00:17:03.033 --> 00:17:05.567
but I'm calling it
a relational index entity.

00:17:05.567 --> 00:17:06.868
So the idea
is really simple.

00:17:06.868 --> 00:17:10.334
Let's split the message
into two entities, okay?

00:17:10.334 --> 00:17:11.868
The first one
is the message model.

00:17:11.868 --> 00:17:13.267
That contains
what we care about.

00:17:13.267 --> 00:17:14.634
It has the body,
and the sender,

00:17:14.634 --> 00:17:16.734
and the metainformation that
we actually want to access

00:17:16.734 --> 00:17:18.634
once we've done the query.

00:17:18.634 --> 00:17:21.534
Then we have another one,
which is the MessageIndex.

00:17:21.534 --> 00:17:23.701
And the MessageIndex
just has

00:17:23.701 --> 00:17:25.067
the fields
we want to query on.

00:17:25.067 --> 00:17:27.701
Nothing else.
So here they are.

00:17:27.701 --> 00:17:29.467
You can see,
I just split it in half.

00:17:29.467 --> 00:17:32.033
That's all I did.

00:17:32.033 --> 00:17:33.501
Now, the key thing

00:17:33.501 --> 00:17:35.334
is that we put them
in the same entity group

00:17:35.334 --> 00:17:37.634
so that we can transactionally
operate on both of them

00:17:37.634 --> 00:17:38.968
at the same time.

00:17:38.968 --> 00:17:43.000
And we make the MessageIndex
a child of the message.

00:17:43.000 --> 00:17:45.834
What that means is that
the MessageIndex primary key

00:17:45.834 --> 00:17:49.167
implicitly points to the--
to the messages--

00:17:49.167 --> 00:17:51.300
to its parents'
primary key.

00:17:51.300 --> 00:17:53.267
In the App Engine datastore,

00:17:53.267 --> 00:17:55.501
all primary keys
include the full path

00:17:55.501 --> 00:17:59.200
of--of that entity
and its parent elements.

00:17:59.200 --> 00:18:01.334
So...so in this case,

00:18:01.334 --> 00:18:03.000
if we had
just the MessageIndex,

00:18:03.000 --> 00:18:05.267
I know who its parent is
just by looking at the key.

00:18:05.267 --> 00:18:08.501
All I need is the key.

00:18:08.501 --> 00:18:10.901
So a new thing
that we just launched--

00:18:10.901 --> 00:18:12.934
I think it was in
our 1.2.2 launch

00:18:12.934 --> 00:18:14.300
just a couple of weeks ago--

00:18:14.300 --> 00:18:18.033
was something called
the key-only query.

00:18:18.033 --> 00:18:20.868
And a key-only query
lets me do...

00:18:20.868 --> 00:18:24.501
a key-only fetch
on the message index type.

00:18:24.501 --> 00:18:25.868
What does that mean?

00:18:25.868 --> 00:18:29.234
So I want to do a query
and only get back the keys

00:18:29.234 --> 00:18:30.667
that match.

00:18:30.667 --> 00:18:32.434
Then I want
to transform those keys

00:18:32.434 --> 00:18:36.000
to de-reference the pointer
to their parents, essentially.

00:18:36.000 --> 00:18:38.133
And then I want to fetch
the actual messages

00:18:38.133 --> 00:18:40.601
that I care about in batch,
very quickly.

00:18:40.601 --> 00:18:42.601
And so here's
an example of that.

00:18:42.601 --> 00:18:43.934
I do a GQL query.
I say,

00:18:43.934 --> 00:18:45.701
"Select the key
from the MessageIndex."

00:18:45.701 --> 00:18:47.334
Just show me
the matching entities.

00:18:47.334 --> 00:18:50.067
Don't pull down
the whole MessageIndex entity.

00:18:50.067 --> 00:18:51.834
Don't--don't deserialize
the list properties.

00:18:51.834 --> 00:18:54.701
Just avoid it.
Just give me the keys.

00:18:54.701 --> 00:18:56.100
And then, you see,
on the next line I say

00:18:56.100 --> 00:18:57.601
keys = k.parent.

00:18:57.601 --> 00:19:00.367
That traverses the key
to give me the parent entity,

00:19:00.367 --> 00:19:02.133
which is a message.

00:19:02.133 --> 00:19:05.167
And then I say
db.get(keys)

00:19:05.167 --> 00:19:07.868
and that gets all of those keys
in parallel.

00:19:07.868 --> 00:19:10.434
Now, under the covers,

00:19:10.434 --> 00:19:12.434
this is what App Engine's
datastore is doing anyway.

00:19:12.434 --> 00:19:14.100
This is--this is--
this is how we work.

00:19:14.100 --> 00:19:15.701
We--we scan one index,

00:19:15.701 --> 00:19:17.133
we figure out
all the keys you need,

00:19:17.133 --> 00:19:19.501
and then we grab them all from
the actual entities table

00:19:19.501 --> 00:19:20.634
in parallel.

00:19:20.634 --> 00:19:21.934
Ryan Barrett's talk

00:19:21.934 --> 00:19:23.467
on "Under the Covers
of the App Engine Datastore"

00:19:23.467 --> 00:19:24.701
gets into some--
from last year

00:19:24.701 --> 00:19:26.167
gets into some really
interesting detail

00:19:26.167 --> 00:19:28.400
about how that works.

00:19:28.400 --> 00:19:30.501
But hopefully
you can see the efficiency

00:19:30.501 --> 00:19:31.801
we're gonna get from this,

00:19:31.801 --> 00:19:33.234
because we've
completely avoided

00:19:33.234 --> 00:19:36.067
all of the list property
deserialization.

00:19:36.067 --> 00:19:37.667
We can--
we can just figure out

00:19:37.667 --> 00:19:39.267
what--what entities
we need to get,

00:19:39.267 --> 00:19:40.701
go and retrieve them,

00:19:40.701 --> 00:19:42.567
and then--
and then pull down

00:19:42.567 --> 00:19:46.667
the part of the message
we actually care about.

00:19:46.667 --> 00:19:51.267
So I--I have this written up
also in that same demo.

00:19:51.267 --> 00:19:53.400
And what's cool
is I have a little check box

00:19:53.400 --> 00:19:55.868
to do either--
either of the examples.

00:19:55.868 --> 00:19:58.801
So I have a little timing box
I can click on.

00:19:58.801 --> 00:20:00.934
Then I click "Retrieve".

00:20:00.934 --> 00:20:02.601
So you'll see this
is retrieving, I think,

00:20:02.601 --> 00:20:04.734
ten list property entities,

00:20:04.734 --> 00:20:06.601
ten message entities.

00:20:06.601 --> 00:20:09.367
Each one has
2,000 receivers in it.

00:20:09.367 --> 00:20:12.000
And it takes 1.3 seconds.

00:20:12.000 --> 00:20:15.267
That is a really long time.
That is way too long.

00:20:15.267 --> 00:20:17.834
1.6--
so it's got some variants.

00:20:17.834 --> 00:20:20.267
It's--it's way too slow.

00:20:20.267 --> 00:20:22.801
That's just for ten.

00:20:22.801 --> 00:20:24.400
But if I change this
to use the key-only ones--

00:20:24.400 --> 00:20:27.767
again, I have ten entities
in there--

00:20:27.767 --> 00:20:30.334
oh, need timing on.

00:20:30.334 --> 00:20:32.300
You see it's a lot faster.

00:20:32.300 --> 00:20:34.200
It's--it's ten times faster.

00:20:34.200 --> 00:20:36.334
It's--it's sometimes faster
than ten times faster.

00:20:36.334 --> 00:20:38.400
It's--it's way better.

00:20:38.400 --> 00:20:40.934
And this is because I'm avoiding
all the serialization costs

00:20:40.934 --> 00:20:44.901
associated with
serializing and deserializing

00:20:44.901 --> 00:20:48.767
those list properties.

00:20:48.767 --> 00:20:51.501
So what's the conclusion here?

00:20:51.501 --> 00:20:53.234
Relation index entities

00:20:53.234 --> 00:20:54.834
give us
much better performance.

00:20:54.834 --> 00:20:56.734
We have the same cost
for doing writes

00:20:56.734 --> 00:21:00.434
but reads are ten times
faster and cheaper.

00:21:00.434 --> 00:21:02.501
We have--ten times
faster and cheaper

00:21:02.501 --> 00:21:03.801
than the old way
of doing it,

00:21:03.801 --> 00:21:07.300
where we had to do
deserialization.

00:21:07.300 --> 00:21:09.367
And we have the best of both
worlds with list properties.

00:21:09.367 --> 00:21:10.934
We have very low
storage costs

00:21:10.934 --> 00:21:13.701
because we only write
one index row

00:21:13.701 --> 00:21:16.400
for each list value

00:21:16.400 --> 00:21:18.000
and the low CPU cost

00:21:18.000 --> 00:21:22.267
because the queries
are really easy to do.

00:21:22.267 --> 00:21:24.634
So this is a way
of doing fan-out.

00:21:24.634 --> 00:21:26.801
It's a very efficient
way of doing fan-out.

00:21:26.801 --> 00:21:29.133
Now, what if we want
to keep going further?

00:21:29.133 --> 00:21:31.434
What if we need
more fan-out?

00:21:31.434 --> 00:21:34.100
I said there was a limit
of 5,000 entit--

00:21:34.100 --> 00:21:36.801
5,000 index rows.

00:21:36.801 --> 00:21:39.400
Well, in that case,
if we need more indexes,

00:21:39.400 --> 00:21:41.167
you can just write
multiple index--

00:21:41.167 --> 00:21:43.634
relation index entities
per message.

00:21:43.634 --> 00:21:45.334
There's nothing stopping you

00:21:45.334 --> 00:21:47.834
from having multiple
child entities

00:21:47.834 --> 00:21:50.200
that refer back
to their parent.

00:21:50.200 --> 00:21:52.367
You can add these index entities
in the background

00:21:52.367 --> 00:21:54.467
using our new
Task Queue API

00:21:54.467 --> 00:21:56.100
which I'll
talk about tomorrow.

00:21:56.100 --> 00:21:58.734
And I think this
provides a solution

00:21:58.734 --> 00:21:59.968
to the million-fan-out
problem.

00:21:59.968 --> 00:22:01.400
I think that
the million-fan-out problem

00:22:01.400 --> 00:22:03.033
is kind of
a really hard problem

00:22:03.033 --> 00:22:04.367
that people have been
talking and talking about

00:22:04.367 --> 00:22:06.067
how to solve for a while.

00:22:06.067 --> 00:22:07.567
And I think
this'll let you do it.

00:22:07.567 --> 00:22:09.267
I think the other thing
that's cool about this

00:22:09.267 --> 00:22:11.167
is that you don't have
to migrate your schema to do it.

00:22:11.167 --> 00:22:13.100
If you say, "Hey,
I need an index on 'X'"

00:22:13.100 --> 00:22:14.400
suddenly
for this user,

00:22:14.400 --> 00:22:17.234
just go through and write
a new relation index

00:22:17.234 --> 00:22:19.000
for each of your users
as a child element.

00:22:19.000 --> 00:22:20.300
That's all you have to do.

00:22:20.300 --> 00:22:21.901
You don't have to change
any of your schema.

00:22:21.901 --> 00:22:23.400
They're just
totally decoupled--

00:22:23.400 --> 00:22:25.367
your indexes and your data.

00:22:25.367 --> 00:22:27.200
So the final picture
of what you'll have

00:22:27.200 --> 00:22:29.367
is you'll have the message,
which is what you care about,

00:22:29.367 --> 00:22:30.934
and then just
a series of indexes

00:22:30.934 --> 00:22:32.868
written as child entities.

00:22:32.868 --> 00:22:35.567
And you use those child entities
as references

00:22:35.567 --> 00:22:37.400
to the parent
to find the parent,

00:22:37.400 --> 00:22:41.167
but then don't--
you don't deserialize them ever.

00:22:41.167 --> 00:22:42.634
And--and what
you're doing here really

00:22:42.634 --> 00:22:43.834
is kind of accessing

00:22:43.834 --> 00:22:46.000
a lower-level
BigTable-like interface

00:22:46.000 --> 00:22:48.834
of doing row range
and index scans.

00:22:48.834 --> 00:22:51.701
So if you have a problem
doing fan-out,

00:22:51.701 --> 00:22:53.901
doing set membership
fan-out,

00:22:53.901 --> 00:22:56.601
I encourage you
to look at list properties.

00:23:01.734 --> 00:23:03.300
Okay.

00:23:03.300 --> 00:23:05.100
This going okay so far?

00:23:05.100 --> 00:23:06.734
People with me?
Yeah?

00:23:06.734 --> 00:23:08.534
I see some nods.
That's good.

00:23:08.534 --> 00:23:10.501
Okay, so merge-join.

00:23:10.501 --> 00:23:14.200
Merge-join
is a funny word.

00:23:14.200 --> 00:23:17.567
Merge-join is--
is a--is the secret sauce

00:23:17.567 --> 00:23:19.734
that I don't think
people realize is there.

00:23:19.734 --> 00:23:21.634
So what is it?

00:23:21.634 --> 00:23:23.067
Well, people say,
"Oh, App Engine,

00:23:23.067 --> 00:23:24.334
"I'm not gonna use
App Engine.

00:23:24.334 --> 00:23:25.701
App Engine
doesn't support joins."

00:23:25.701 --> 00:23:27.334
Well, that's not true,
actually.

00:23:27.334 --> 00:23:29.334
We don't support
natural joins

00:23:29.334 --> 00:23:31.367
or inner joins
or outer joins.

00:23:31.367 --> 00:23:35.467
Those are useful joins.
We don't support those.

00:23:35.467 --> 00:23:37.834
But we do support
merge-joins.

00:23:37.834 --> 00:23:40.167
A merge-join is a self-join.

00:23:40.167 --> 00:23:41.868
We can join tables
with its--

00:23:41.868 --> 00:23:44.167
we can join
a table with itself.

00:23:44.167 --> 00:23:45.767
And what that means
is you can combine

00:23:45.767 --> 00:23:47.701
multiple equality filters--

00:23:47.701 --> 00:23:50.801
multiple equality tests
in a single query.

00:23:50.801 --> 00:23:52.534
And so what
that lets you do

00:23:52.534 --> 00:23:55.334
is determine Venn-diagram-like
overlaps in sets.

00:23:55.334 --> 00:23:57.400
So an example
is something very useful

00:23:57.400 --> 00:23:59.467
for your business
application:

00:23:59.467 --> 00:24:03.434
I want to see the overlap
of spots, horns, and legs.

00:24:03.434 --> 00:24:06.367
Obviously that's a cow--
four legs.

00:24:06.367 --> 00:24:08.334
Now, if I want to do a query
to figure out this data

00:24:08.334 --> 00:24:10.634
in some taxonomy
of animals,

00:24:10.634 --> 00:24:13.868
merge-join is what
you can use to do it.

00:24:13.868 --> 00:24:18.200
I'll show you why.

00:24:18.200 --> 00:24:21.133
But why would you
want to use merge-join?

00:24:21.133 --> 00:24:22.667
Well, it's great
for exploring your data,

00:24:22.667 --> 00:24:26.000
data mining-like
operations.

00:24:26.000 --> 00:24:27.868
There's--the practical
limit of equality tests

00:24:27.868 --> 00:24:29.067
is pretty high.

00:24:29.067 --> 00:24:31.868
You can have ten or more
filters pretty easily.

00:24:31.868 --> 00:24:33.901
And you don't have
to build indexes in advance

00:24:33.901 --> 00:24:35.234
to do these queries.

00:24:35.234 --> 00:24:37.367
So if you're doing
a Venn-diagram-like query,

00:24:37.367 --> 00:24:38.634
you don't even
have to build an index.

00:24:38.634 --> 00:24:40.033
You can just do it right now.

00:24:40.033 --> 00:24:42.267
You can--you can even do it
from the shell application

00:24:42.267 --> 00:24:45.400
right in your deployed
App Engine app.

00:24:45.400 --> 00:24:48.567
And that's--that great
for doing ad hoc queries

00:24:48.567 --> 00:24:49.934
if you want
to figure out something.

00:24:49.934 --> 00:24:52.400
It also reduces cost,
'cause indexes take space,

00:24:52.400 --> 00:24:55.067
index has to take time
to build.

00:24:55.067 --> 00:24:56.367
And you can actually provide

00:24:56.367 --> 00:24:57.567
some pretty
advanced functionality

00:24:57.567 --> 00:25:00.100
with Venn-diagram-like
operations.

00:25:00.100 --> 00:25:02.367
So an example
is what you have in Gmail.

00:25:02.367 --> 00:25:05.067
Think of a Gmail filter

00:25:05.067 --> 00:25:06.767
or a Gmail search
that you can do.

00:25:06.767 --> 00:25:08.200
You have various labels
applied,

00:25:08.200 --> 00:25:10.767
read/unread status,
a month, year, day,

00:25:10.767 --> 00:25:12.868
number of replies,
recipients, et cetera.

00:25:12.868 --> 00:25:14.400
These are all
properties of a message.

00:25:14.400 --> 00:25:15.634
If you think about it,

00:25:15.634 --> 00:25:18.667
these are all just
Venn-diagram-like overlaps

00:25:18.667 --> 00:25:20.100
in sets.

00:25:20.100 --> 00:25:22.167
All you're doing
is testing set membership.

00:25:22.167 --> 00:25:25.067
But you're doing those--
those tests in parallel,

00:25:25.067 --> 00:25:29.534
together,
in a single filter.

00:25:29.534 --> 00:25:31.434
So what's an example
of merge-join?

00:25:31.434 --> 00:25:34.467
Well, here's my very useful
animal class.

00:25:34.467 --> 00:25:36.501
I have a list
of what it has--

00:25:36.501 --> 00:25:37.868
in this case, horns.

00:25:37.868 --> 00:25:39.734
The color is spotted.

00:25:39.734 --> 00:25:41.567
And it has four legs.

00:25:41.567 --> 00:25:45.000
And if I want to do a query
to find animals like this animal

00:25:45.000 --> 00:25:46.934
I--I can just
do this query:

00:25:46.934 --> 00:25:48.467
SELECT * FROM ANIMAL

00:25:48.467 --> 00:25:51.934
where the color is spots,
has horns, legs 4.

00:25:51.934 --> 00:25:55.033
Now, that doesn't
look like a join.

00:25:55.033 --> 00:25:57.567
But it is
if you think about it.

00:25:57.567 --> 00:26:00.334
And I'll show you
what I mean.

00:26:02.667 --> 00:26:05.901
Well, I'll show you
what I mean in a second

00:26:05.901 --> 00:26:07.133
and why it's relevant.

00:26:07.133 --> 00:26:08.367
But let's talk about

00:26:08.367 --> 00:26:10.300
how this actually works
in App Engine.

00:26:10.300 --> 00:26:13.167
So...so--well, first
let's talk about how

00:26:13.167 --> 00:26:14.734
it works
in a relational database.

00:26:14.734 --> 00:26:16.701
Well, the relational database
usually--

00:26:16.701 --> 00:26:18.767
the query planner
has histograms.

00:26:18.767 --> 00:26:20.334
The query planner
knows that

00:26:20.334 --> 00:26:22.367
I have this many entity--

00:26:22.367 --> 00:26:25.400
this many records
that have spots in this value.

00:26:25.400 --> 00:26:27.901
I have this many records
that have horns in this value.

00:26:27.901 --> 00:26:30.100
I have this many records
that have four legs.

00:26:30.100 --> 00:26:32.200
And then it determines
a query plan

00:26:32.200 --> 00:26:33.567
to do the smallest--

00:26:33.567 --> 00:26:35.367
to scan through
the smallest result set.

00:26:35.367 --> 00:26:37.434
And then it starts just
either going through memory,

00:26:37.434 --> 00:26:38.767
or through B-trees on disk,

00:26:38.767 --> 00:26:40.534
to go and actually
do a linear scan

00:26:40.534 --> 00:26:41.734
through all of your entities

00:26:41.734 --> 00:26:43.534
and then find
the matching one.

00:26:43.534 --> 00:26:46.834
And that's--that's how--
that's how SQL's doing it.

00:26:46.834 --> 00:26:48.934
So...so how do we do that?

00:26:48.934 --> 00:26:51.467
We don't have histograms.

00:26:51.467 --> 00:26:55.334
Well, first of all,
it's not available in BigTable.

00:26:55.334 --> 00:26:57.801
There are
similar optimizations

00:26:57.801 --> 00:26:59.767
that work like this
in other DB systems.

00:26:59.767 --> 00:27:02.734
But this is some
special sauce that we have,

00:27:02.734 --> 00:27:04.267
we've had since launch.

00:27:04.267 --> 00:27:06.934
So, first of all,
we store all property indexes

00:27:06.934 --> 00:27:09.667
in sorted order,
ascending order.

00:27:09.667 --> 00:27:11.200
If you know anything
about BigTable,

00:27:11.200 --> 00:27:12.501
that should sound familiar

00:27:12.501 --> 00:27:13.701
because that's
what BigTable does.

00:27:13.701 --> 00:27:14.901
So it's--
everything is stored

00:27:14.901 --> 00:27:17.300
in lexical order,
ascending order.

00:27:17.300 --> 00:27:19.868
And then,
the datastore

00:27:19.868 --> 00:27:23.567
essentially does
a merge-sort at runtime.

00:27:23.567 --> 00:27:26.634
So we take
this sorted list

00:27:26.634 --> 00:27:30.901
and we merge it with itself
in different locations.

00:27:30.901 --> 00:27:33.133
And we use a zig-zag algorithm
to make this efficient,

00:27:33.133 --> 00:27:35.167
to efficiently join tables.

00:27:35.167 --> 00:27:38.400
And what this lets us do
is scan a single BigTable index

00:27:38.400 --> 00:27:40.334
in parallel,
and it's so easy, and--

00:27:40.334 --> 00:27:42.234
Yeah.
This is really hard.

00:27:42.234 --> 00:27:43.734
This is not
a Google interview question,

00:27:43.734 --> 00:27:45.367
but it sure sounds like one.

00:27:45.367 --> 00:27:47.234
And I'm not going to be able
to explain this

00:27:47.234 --> 00:27:48.534
without actually
showing you how it works.

00:27:48.534 --> 00:27:50.100
So let me show you
what it works.

00:27:50.100 --> 00:27:51.667
I can talk about
"zig-zag" and merge

00:27:51.667 --> 00:27:52.901
and scans and all this stuff,

00:27:52.901 --> 00:27:55.567
but you just need to see it
to understand it.

00:27:55.567 --> 00:27:58.400
So here's--
let's say this is

00:27:58.400 --> 00:28:00.300
a BigTable index,
okay?

00:28:00.300 --> 00:28:04.167
These are--the tables
represent property indexes.

00:28:04.167 --> 00:28:06.767
Now, this is
in ascending order.

00:28:06.767 --> 00:28:08.534
You'll see that,
for each property,

00:28:08.534 --> 00:28:11.334
I have its value:
color=red.

00:28:11.334 --> 00:28:13.267
And then I have
the primary key

00:28:13.267 --> 00:28:14.567
of the entity.

00:28:14.567 --> 00:28:17.067
So...
color equals red ants,

00:28:17.067 --> 00:28:19.100
spotted bear,
spotted cow,

00:28:19.100 --> 00:28:20.968
white dog.

00:28:20.968 --> 00:28:24.167
And these are different sections
of the same BigTable,

00:28:24.167 --> 00:28:26.400
effectively,
which is the animal--

00:28:26.400 --> 00:28:29.267
the animal property table.

00:28:29.267 --> 00:28:30.534
So the first thing I do--

00:28:30.534 --> 00:28:32.033
if you go back
to the GQL Query--

00:28:32.033 --> 00:28:35.567
I'm gonna do--I'm doing
three separate equality filters.

00:28:35.567 --> 00:28:39.868
I'm doing one on color,
has, and legs.

00:28:39.868 --> 00:28:43.534
So first I--
so I start with a color.

00:28:43.534 --> 00:28:45.701
Then I scan through BigTable
to the row

00:28:45.701 --> 00:28:49.400
that matches spots.

00:28:49.400 --> 00:28:51.701
Then I say, "Okay,
that sounds great."

00:28:51.701 --> 00:28:53.868
I found spots. I found
the first part of my filter.

00:28:53.868 --> 00:28:57.133
So this part--
this equality--

00:28:57.133 --> 00:29:00.133
this equality test
has been matched.

00:29:00.133 --> 00:29:01.834
So now it moves on
to the next one,

00:29:01.834 --> 00:29:03.334
which is has.

00:29:03.334 --> 00:29:05.167
And then it scans through
and goes, "Ah!

00:29:05.167 --> 00:29:09.200
Now I found this key
with horns that also matches."

00:29:09.200 --> 00:29:11.501
But what's important here,

00:29:11.501 --> 00:29:13.534
if you look
for number one,

00:29:13.534 --> 00:29:14.734
the key
I have matched is bear.

00:29:14.734 --> 00:29:18.100
For number two,
the key I have matched is cow.

00:29:18.100 --> 00:29:22.267
Now cow is lexically,
alphabetically after bear,

00:29:22.267 --> 00:29:24.000
which means that
bear is wrong.

00:29:24.000 --> 00:29:26.067
We need to actually find
the next thing after bear.

00:29:26.067 --> 00:29:28.133
But we need to find
the next thing after bear

00:29:28.133 --> 00:29:31.267
but before cow
or equal to cow.

00:29:31.267 --> 00:29:35.100
So this is the "zig."
We move number one.

00:29:35.100 --> 00:29:37.567
We say, "Okay, well,
these keys don't match."

00:29:37.567 --> 00:29:38.968
Bear and cow don't match.

00:29:38.968 --> 00:29:40.968
So we'll start moving
the window on number one

00:29:40.968 --> 00:29:42.501
so we match cow.

00:29:42.501 --> 00:29:43.968
We need those keys to match

00:29:43.968 --> 00:29:45.234
because if we don't have
a matching key,

00:29:45.234 --> 00:29:48.734
we don't have
a matching result.

00:29:48.734 --> 00:29:51.133
So now we're satisfied again
with two filters.

00:29:51.133 --> 00:29:53.267
We have color equals spots,
key is cow,

00:29:53.267 --> 00:29:55.067
has is horns,
key is cow.

00:29:55.067 --> 00:29:58.467
We've--we've satisfied
these two equality tests.

00:29:58.467 --> 00:30:00.801
But now we move on
to the next one.

00:30:00.801 --> 00:30:02.801
We start off
with legs=4.

00:30:02.801 --> 00:30:05.400
The first thing--
result we get is a cat.

00:30:05.400 --> 00:30:07.300
Again,
the key does not match.

00:30:07.300 --> 00:30:10.701
Lexically, the key cat
is before cow.

00:30:10.701 --> 00:30:13.000
So again,
we do a BigTable scan

00:30:13.000 --> 00:30:15.200
to scan after this--
this row

00:30:15.200 --> 00:30:19.300
but before a--a cow,

00:30:19.300 --> 00:30:20.968
which are the other results
we have.

00:30:20.968 --> 00:30:23.434
And that's the "zag."

00:30:23.434 --> 00:30:26.868
And that moves--that moves
the--that iterator down.

00:30:26.868 --> 00:30:29.100
And now we have a match.

00:30:29.100 --> 00:30:32.100
We have--the key--
the keys all are the same

00:30:32.100 --> 00:30:35.467
and all of the equality
tests are satisfied.

00:30:35.467 --> 00:30:38.801
So we've joined
this table with itself.

00:30:42.534 --> 00:30:44.834
Okay.
Does that make sense?

00:30:44.834 --> 00:30:47.767
Cool.

00:30:47.767 --> 00:30:49.567
So I like zig-zag.
I think it's pretty cool.

00:30:49.567 --> 00:30:52.634
Good name.
Good word.

00:30:52.634 --> 00:30:54.801
So let's go with
the concrete example.

00:30:54.801 --> 00:30:56.167
What would you actually
use this for?

00:30:56.167 --> 00:30:59.000
So let's talk about
modeling the social graph.

00:30:59.000 --> 00:31:03.067
So a social graph is
just a good example for this.

00:31:03.067 --> 00:31:05.100
You can model
all kinds of graphs.

00:31:05.100 --> 00:31:07.167
Graphs are very useful
for doing all kinds of things.

00:31:07.167 --> 00:31:09.501
So anything you
can represent with nodes

00:31:09.501 --> 00:31:11.634
and relationships between
nodes, vertices, whatever,

00:31:11.634 --> 00:31:14.601
you can--
you can do this way.

00:31:14.601 --> 00:31:16.467
So a social--
the social graph's useful

00:31:16.467 --> 00:31:18.334
because the questions
are easy.

00:31:18.334 --> 00:31:21.033
So, you know,
each user has a profile

00:31:21.033 --> 00:31:22.334
and a set of friends.

00:31:22.334 --> 00:31:24.934
We're gonna use merge-join
on list properties

00:31:24.934 --> 00:31:27.033
to do some magic for us.

00:31:27.033 --> 00:31:29.868
So merge-join lets us answer
all these great questions

00:31:29.868 --> 00:31:31.901
about relationships.

00:31:31.901 --> 00:31:33.567
First of all,
who are my friends?

00:31:33.567 --> 00:31:36.033
Who are my friends
in San Francisco?

00:31:36.033 --> 00:31:38.234
Which friends
do I have in common

00:31:38.234 --> 00:31:40.100
with somebody else?

00:31:40.100 --> 00:31:42.467
Which friends do I have
in common with somebody else

00:31:42.467 --> 00:31:44.968
in San Francisco--

00:31:44.968 --> 00:31:47.501
where somebody else
is a specific person?

00:31:47.501 --> 00:31:49.467
And if you look at a lot
of social sites out there,

00:31:49.467 --> 00:31:51.133
these are
the queries you see.

00:31:51.133 --> 00:31:53.067
These are the--
you know, the--

00:31:53.067 --> 00:31:54.868
on the main profile pages
and dashboards.

00:31:54.868 --> 00:31:56.367
They say, "Hey," you know,

00:31:56.367 --> 00:31:59.501
"you have these friends
in common," and so and so.

00:31:59.501 --> 00:32:01.767
Now, for simplicity
I'm just gonna do

00:32:01.767 --> 00:32:03.234
relationships two-way.

00:32:03.234 --> 00:32:06.000
There's no reason you
couldn't use this for a DAG.

00:32:06.000 --> 00:32:09.534
It's just easier this way.

00:32:09.534 --> 00:32:11.767
So...

00:32:11.767 --> 00:32:13.400
here's my group of friends.

00:32:13.400 --> 00:32:14.667
These are the people:

00:32:14.667 --> 00:32:16.667
Mel, Bob, Stu, Willie,
Lenny, Carl.

00:32:16.667 --> 00:32:18.000
Maybe the names
are familiar.

00:32:18.000 --> 00:32:19.467
They live
in three locations.

00:32:19.467 --> 00:32:22.300
The lines are the friendships
between them.

00:32:22.300 --> 00:32:24.634
Now, if we want
to answer a query like:

00:32:24.634 --> 00:32:26.400
Who's a mutual friend
of Willie and Carl?

00:32:26.400 --> 00:32:29.000
That's easy.
It's Lenny.

00:32:29.000 --> 00:32:30.501
There he is.

00:32:30.501 --> 00:32:34.834
You see that relationship
with the arrows.

00:32:34.834 --> 00:32:36.501
Similarly,
if we want to figure out

00:32:36.501 --> 00:32:39.434
who's a mutual friend of Bob
and Willie in San Francisco,

00:32:39.434 --> 00:32:40.934
we know that's Stu.

00:32:40.934 --> 00:32:43.167
Now, you see how this is
a Venn-diagram-like query.

00:32:43.167 --> 00:32:44.501
That's what
we're figuring out.

00:32:44.501 --> 00:32:48.801
But we're operating
on a graph.

00:32:48.801 --> 00:32:51.400
Now, how would you do this
with a relational system?

00:32:51.400 --> 00:32:53.067
You'd have a person table,

00:32:53.067 --> 00:32:54.400
which has the user
and their location,

00:32:54.400 --> 00:32:56.901
and then you'd have
a table of friends.

00:32:56.901 --> 00:32:58.834
You'd normalize it somehow

00:32:58.834 --> 00:33:00.033
to make sure you
don't have duplicates,

00:33:00.033 --> 00:33:01.634
but you'd have User "A"
and User "B"

00:33:01.634 --> 00:33:06.334
and their friends.

00:33:06.334 --> 00:33:09.234
And then to--
so then simple queries like:

00:33:09.234 --> 00:33:11.267
Who--who are
the friends of user "X"?

00:33:11.267 --> 00:33:12.601
You'd just do
a simple join

00:33:12.601 --> 00:33:14.200
between the users table
and the friends table.

00:33:14.200 --> 00:33:15.968
You say, "Give me
all the users,

00:33:15.968 --> 00:33:17.634
"join on friends,

00:33:17.634 --> 00:33:21.033
where the user I.D.
matches the friend I.D."

00:33:21.033 --> 00:33:22.834
And--and so here,

00:33:22.834 --> 00:33:24.968
the first--the first part
I have, user_b_id,

00:33:24.968 --> 00:33:27.400
that's the join property.

00:33:27.400 --> 00:33:30.734
And then the constraint is
user_a equals "X" equals me.

00:33:30.734 --> 00:33:31.901
So show me all my friends.

00:33:31.901 --> 00:33:34.000
Show me all the friends
of user "X."

00:33:34.000 --> 00:33:35.267
And if you want to filter
by location

00:33:35.267 --> 00:33:39.868
you just add another filter
to the users table.

00:33:39.868 --> 00:33:41.634
And that gets
more complicated

00:33:41.634 --> 00:33:43.300
when you want to do
a graph query.

00:33:43.300 --> 00:33:44.934
If you want to do
a graph query, now,

00:33:44.934 --> 00:33:46.100
you want to figure out:

00:33:46.100 --> 00:33:48.400
Give me all the friends
common to "X" and "Y."

00:33:48.400 --> 00:33:51.601
So you
SELECT * FROM Users,

00:33:51.601 --> 00:33:54.300
INNER JOIN on Friends 1
and Friends 2--

00:33:54.300 --> 00:33:55.767
'cause you're joining
on the same table

00:33:55.767 --> 00:33:58.334
so you need two representations
of that table.

00:33:58.334 --> 00:33:59.767
You need
to figure out where

00:33:59.767 --> 00:34:01.767
the user_id equals
f1 user I.D.

00:34:01.767 --> 00:34:03.634
and the other user_id
equals f2 user I.D.

00:34:03.634 --> 00:34:05.133
And then you
also need constraints

00:34:05.133 --> 00:34:07.767
to make sure that you have
user "X" and user "Y"

00:34:07.767 --> 00:34:10.200
and then an actual merge
that actually does the join,

00:34:10.200 --> 00:34:11.501
which is that last line.

00:34:11.501 --> 00:34:12.901
It's pretty complicated.

00:34:12.901 --> 00:34:16.367
But if you're familiar
with SQL, that--that works.

00:34:16.367 --> 00:34:18.300
But we don't have inner joins
on App Engine

00:34:18.300 --> 00:34:19.868
like we're using here.

00:34:19.868 --> 00:34:22.300
And--and we don't,
you know,

00:34:22.300 --> 00:34:23.934
and people have said
we don't have joins.

00:34:23.934 --> 00:34:25.367
Well, we do have
merge-join.

00:34:25.367 --> 00:34:26.767
We can do self-joins.

00:34:26.767 --> 00:34:29.067
The only really important
part of this is the last line,

00:34:29.067 --> 00:34:34.534
which is joining
the two tables together.

00:34:34.534 --> 00:34:37.000
So here's how we do
it in App Engine.

00:34:37.000 --> 00:34:39.400
We have a person,
they have a location,

00:34:39.400 --> 00:34:41.868
and they have
a list of friends.

00:34:41.868 --> 00:34:43.434
And we do
a really simple query.

00:34:43.434 --> 00:34:45.067
So it's
very natural sounding.

00:34:45.067 --> 00:34:47.100
It's:
Give me all the people

00:34:47.100 --> 00:34:50.100
where they have this friend
and they have that friend

00:34:50.100 --> 00:34:52.701
in San Francisco.

00:34:52.701 --> 00:34:53.968
That's it.

00:34:53.968 --> 00:34:55.868
That answers--that answers
the question.

00:34:55.868 --> 00:34:57.334
It'll de-dup.

00:34:57.334 --> 00:34:59.968
It'll give you
unique result sets.

00:34:59.968 --> 00:35:01.634
It'll do that
merge-join query

00:35:01.634 --> 00:35:02.834
and give it to you.

00:35:02.834 --> 00:35:04.701
And you can add
as many filters as you need

00:35:04.701 --> 00:35:09.334
up to a practical limit.

00:35:09.334 --> 00:35:11.000
So let's demo this.

00:35:11.000 --> 00:35:12.934
I'm gonna kind of go back

00:35:12.934 --> 00:35:14.501
so you can actually
see these examples.

00:35:14.501 --> 00:35:16.901
So...

00:35:16.901 --> 00:35:18.667
I have two--
two things here.

00:35:18.667 --> 00:35:20.901
So I'm--
let's say I'm Carl,

00:35:20.901 --> 00:35:24.801
and I want to see...

00:35:24.801 --> 00:35:27.267
and I'm looking at Willie.

00:35:27.267 --> 00:35:28.868
And I want to say:

00:35:28.868 --> 00:35:30.801
Who are the friends
who are common

00:35:30.801 --> 00:35:34.801
to...Carl and Willie?

00:35:34.801 --> 00:35:37.300
So you remember...

00:35:37.300 --> 00:35:39.267
Carl and Willie, right?

00:35:39.267 --> 00:35:41.534
Who are the friends
common to Carl and Willie?

00:35:41.534 --> 00:35:43.734
And it's Lenny.

00:35:43.734 --> 00:35:45.534
Oh!

00:35:45.534 --> 00:35:49.067
So Carl, Willie--
Lenny is a common friend.

00:35:49.067 --> 00:35:50.534
So there we go.

00:35:50.534 --> 00:35:52.901
Pretty easy to--to parse.

00:35:52.901 --> 00:35:54.834
Similarly, you can see
the friends Lenny and Stu

00:35:54.834 --> 00:35:58.934
as being Willie's friends.

00:35:58.934 --> 00:36:01.434
Now the next one
was answering:

00:36:01.434 --> 00:36:04.367
Who is a mutual friend of Bob
and Willie in San Francisco?

00:36:07.667 --> 00:36:10.367
And here I have this tab.

00:36:10.367 --> 00:36:13.634
So...friends in common
to Bob and Willie

00:36:13.634 --> 00:36:15.100
in San Francisco.

00:36:15.100 --> 00:36:16.934
And this application
will let you

00:36:16.934 --> 00:36:18.601
model these relationships

00:36:18.601 --> 00:36:19.868
and do all
the various queries.

00:36:19.868 --> 00:36:21.534
And it shows all the different
queries you can do

00:36:21.534 --> 00:36:24.534
with a social graph.

00:36:24.534 --> 00:36:27.067
And so you can use this

00:36:27.067 --> 00:36:29.467
kind of as an example app

00:36:29.467 --> 00:36:32.400
for how to do merge-join
where merge-join is useful.

00:36:37.133 --> 00:36:38.601
So what's the performance?

00:36:38.601 --> 00:36:40.033
Obviously this can't
come for free, right?

00:36:40.033 --> 00:36:42.934
So merge-join scales with
the number of filters you have

00:36:42.934 --> 00:36:45.133
and the size
of the result set.

00:36:45.133 --> 00:36:46.434
The result set--

00:36:46.434 --> 00:36:48.033
so that means
it's best for queries

00:36:48.033 --> 00:36:49.767
with fewer results,

00:36:49.767 --> 00:36:53.300
say, less than 100,
less than a few hundred.

00:36:53.300 --> 00:36:55.334
If you have a lot
of overlapping data

00:36:55.334 --> 00:36:58.234
or a lot of results that could
potentially match the merge-join

00:36:58.234 --> 00:37:00.334
that could be problematic.

00:37:00.334 --> 00:37:01.934
But usually that's okay

00:37:01.934 --> 00:37:04.100
because a lot of these queries--
you're trying to find overlaps.

00:37:04.100 --> 00:37:06.534
You're trying to add more
and more equalities filters,

00:37:06.534 --> 00:37:08.367
trying to narrow
that set of messages.

00:37:08.367 --> 00:37:09.767
You're looking for
a needle in a haystack.

00:37:09.767 --> 00:37:13.767
This is really useful
for answering those questions.

00:37:13.767 --> 00:37:15.033
And the great thing is

00:37:15.033 --> 00:37:16.934
it has similar performance
as list properties.

00:37:16.934 --> 00:37:19.200
So it has
the same read/write speed.

00:37:19.200 --> 00:37:20.601
There's no storage overhead.

00:37:20.601 --> 00:37:22.300
There are no
extra indexes to write.

00:37:22.300 --> 00:37:25.634
And exactly in the same way
with list properties

00:37:25.634 --> 00:37:26.968
and relation indexes,

00:37:26.968 --> 00:37:29.200
you can avoid all
the serialization costs

00:37:29.200 --> 00:37:30.868
by using relation indexes.

00:37:30.868 --> 00:37:36.834
So you can do all this
for exactly the same costs.

00:37:36.834 --> 00:37:39.067
Now, there are some gotchas.

00:37:39.067 --> 00:37:41.801
You need to watch out
for pathological datasets.

00:37:41.801 --> 00:37:45.000
Too many overlapping values
causes a lot of zig-zagging,

00:37:45.000 --> 00:37:46.300
like I said.

00:37:46.300 --> 00:37:47.834
That's, effectively, where

00:37:47.834 --> 00:37:50.934
we have to keep scanning through
the keys to find matches,

00:37:50.934 --> 00:37:52.267
and we have to keep going

00:37:52.267 --> 00:37:54.033
between our two different
windows in the merge-join

00:37:54.033 --> 00:37:57.367
to find an overlapping set.

00:37:57.367 --> 00:37:59.434
I think that if
your result set's small,

00:37:59.434 --> 00:38:02.501
then the chances of this
are very low.

00:38:02.501 --> 00:38:04.968
But you should go back through
this, you know, merge-join

00:38:04.968 --> 00:38:06.501
and just think through,
you know,

00:38:06.501 --> 00:38:09.701
what it's doing to understand
the potential for this.

00:38:09.701 --> 00:38:12.100
Effectively, it's--
when you have to keep scanning

00:38:12.100 --> 00:38:13.767
and scanning and scanning
inch by inch

00:38:13.767 --> 00:38:17.901
to find matches,
back and forth.

00:38:17.901 --> 00:38:19.567
Another thing
that's really important

00:38:19.567 --> 00:38:22.634
is that this doesn't work
with composite indexes.

00:38:22.634 --> 00:38:26.834
So the--the exploding
index combinations

00:38:26.834 --> 00:38:29.467
won't work here--
keep this from working.

00:38:29.467 --> 00:38:32.701
And that's because when you
have multiple equals filters--

00:38:32.701 --> 00:38:35.300
we're using merge-join
to do the merge.

00:38:35.300 --> 00:38:37.100
Now, the second
you apply a sort order,

00:38:37.100 --> 00:38:40.701
or you have any kind
of inequality filter

00:38:40.701 --> 00:38:42.434
you need to add to this,

00:38:42.434 --> 00:38:43.934
it breaks down,
because we need to--

00:38:43.934 --> 00:38:47.334
we need to store,
in our index, the--

00:38:47.334 --> 00:38:50.367
the cross product
of all of those list properties.

00:38:50.367 --> 00:38:53.634
So...so that
gets really, really big

00:38:53.634 --> 00:38:57.734
really fast, like I said,
and it won't work.

00:38:57.734 --> 00:38:59.767
What that means is
you can't apply sort orders

00:38:59.767 --> 00:39:02.133
to some things
that are used this way.

00:39:02.133 --> 00:39:05.467
Now, that's--that's not--
that's not good.

00:39:05.467 --> 00:39:07.534
But there's a couple
of things you can do.

00:39:07.534 --> 00:39:10.067
So, you know,
you can sort in memory.

00:39:10.067 --> 00:39:12.033
For a small results set,
that's okay,

00:39:12.033 --> 00:39:13.701
especially if you use
relation indexes.

00:39:13.701 --> 00:39:15.734
The--the actual size of
that data is very low

00:39:15.734 --> 00:39:17.667
and it's cacheable.

00:39:17.667 --> 00:39:19.968
The other thing is that,
if you remember

00:39:19.968 --> 00:39:22.501
from the relation index code
that I showed you,

00:39:22.501 --> 00:39:25.634
first we got all the keys
and then we transformed the keys

00:39:25.634 --> 00:39:28.734
and then we retrieved the actual
entities we care about.

00:39:28.734 --> 00:39:31.167
There's no reason you can't
do some filtering up front.

00:39:31.167 --> 00:39:33.033
If there's something
that you know about your keys

00:39:33.033 --> 00:39:34.734
that you can filter them
further,

00:39:34.734 --> 00:39:37.200
you can do that filtering
way in advance

00:39:37.200 --> 00:39:40.033
and, you know,
filter at the key level

00:39:40.033 --> 00:39:42.234
before you even retrieve
the--the entities.

00:39:42.234 --> 00:39:44.601
So that--that's another way
of optimizing this.

00:39:44.601 --> 00:39:47.801
But...it's really--
it's really best

00:39:47.801 --> 00:39:50.367
for membership tests,
Venn diagram tests

00:39:50.367 --> 00:39:55.634
where the sorting is done
after the fact.

00:39:55.634 --> 00:39:56.868
Okay.

00:39:56.868 --> 00:39:58.901
So we're gonna do
a little bit of wrap-up

00:39:58.901 --> 00:40:01.901
and then we're gonna
get to some questions.

00:40:01.901 --> 00:40:05.534
So I encourage you
to use list properties,

00:40:05.534 --> 00:40:08.400
use merge-join
for many things.

00:40:08.400 --> 00:40:11.234
I believe that this can solve
fan-out for your application.

00:40:11.234 --> 00:40:16.767
It'll let you scale
fan-out problems very well,

00:40:16.767 --> 00:40:18.701
especially when combined
with our Task Queue API.

00:40:18.701 --> 00:40:20.634
This'll let you,
you know,

00:40:20.634 --> 00:40:22.901
have a large set of entities

00:40:22.901 --> 00:40:25.033
that match a certain index

00:40:25.033 --> 00:40:27.701
without a problem.

00:40:27.701 --> 00:40:30.968
You can use this same idea
to match geospacial info.

00:40:30.968 --> 00:40:32.601
So instead of a list
of my friends,

00:40:32.601 --> 00:40:33.834
I could have a list
of coordinates,

00:40:33.834 --> 00:40:36.067
or a list
of geographical regions,

00:40:36.067 --> 00:40:39.300
or bounding boxes
on a globe,

00:40:39.300 --> 00:40:41.300
and do queries on that.

00:40:41.300 --> 00:40:44.467
Again, these are
set membership problems.

00:40:44.467 --> 00:40:47.701
Now if I add
merge-join to the party,

00:40:47.701 --> 00:40:49.033
I can do relationship graphs.

00:40:49.033 --> 00:40:50.434
I can do a bunch
of graph operations

00:40:50.434 --> 00:40:52.000
that are very interesting.

00:40:52.000 --> 00:40:53.801
I could also do
"fuzzy" values.

00:40:53.801 --> 00:40:57.133
So if you have any--
any, you know, fuzzy values

00:40:57.133 --> 00:40:58.467
that you need to store,

00:40:58.467 --> 00:40:59.868
you can do that
with list properties.

00:40:59.868 --> 00:41:02.601
For instance,
I can store today's date.

00:41:02.601 --> 00:41:05.868
I can store the month,
today's date,

00:41:05.868 --> 00:41:08.834
or I can store the year,
the month, the day,

00:41:08.834 --> 00:41:10.767
today's date, you know,

00:41:10.767 --> 00:41:12.567
the hour, the minute,
the second--

00:41:12.567 --> 00:41:13.834
I can store a whole list

00:41:13.834 --> 00:41:15.334
of all these different
resolutions of data

00:41:15.334 --> 00:41:17.067
and then query
on any one of them

00:41:17.067 --> 00:41:19.834
to get a different subsection
of the data.

00:41:19.834 --> 00:41:23.467
So a lot of people,
when they do a query on time,

00:41:23.467 --> 00:41:24.767
they say,
"Oh, give me everything

00:41:24.767 --> 00:41:26.501
between these two times."

00:41:26.501 --> 00:41:28.968
And that's not the right way
to think about this.

00:41:28.968 --> 00:41:30.734
You need to think about
converting your theories

00:41:30.734 --> 00:41:32.667
into set membership tests.

00:41:32.667 --> 00:41:34.934
So compute those memberships
at write time

00:41:34.934 --> 00:41:37.801
and you'll enjoy
very fast reads.

00:41:37.801 --> 00:41:39.534
If you want to find
everything from today,

00:41:39.534 --> 00:41:41.467
just mark it
as being from today.

00:41:41.467 --> 00:41:43.767
If you want to find
everything from this hour,

00:41:43.767 --> 00:41:45.200
when you write the--

00:41:45.200 --> 00:41:46.801
when you write
an entity to the data store,

00:41:46.801 --> 00:41:48.267
mark it
as being from today

00:41:48.267 --> 00:41:49.634
at this hour.

00:41:49.634 --> 00:41:51.834
And then all you have to do
to retrieve the data

00:41:51.834 --> 00:41:53.167
is a single equality filter.

00:41:53.167 --> 00:41:54.601
That's it.
There's no--

00:41:54.601 --> 00:41:58.901
There's no inequality filters
required.

00:41:58.901 --> 00:42:00.534
If you want to see the demos,

00:42:00.534 --> 00:42:02.567
I have put them up available
with source code.

00:42:02.567 --> 00:42:03.801
This is hopefully useful.

00:42:03.801 --> 00:42:05.100
It takes a little while
to get them up otherwise--

00:42:05.100 --> 00:42:07.434
pubsub-test.appspot.com

00:42:07.434 --> 00:42:09.868
and
dagpeople.appspot.com.

00:42:09.868 --> 00:42:11.367
It's Python code.

00:42:11.367 --> 00:42:15.467
And you can do
all these same things in JDO.

00:42:15.467 --> 00:42:18.033
And we're working on
further optimizations for JDO,

00:42:18.033 --> 00:42:19.767
but it's all
functionally equivalent.

00:42:19.767 --> 00:42:21.968
There's more information
on our site:

00:42:21.968 --> 00:42:25.501
code.google.com/appengine.

00:42:25.501 --> 00:42:28.701
So now let's go
to some questions.

00:42:28.701 --> 00:42:31.901
Let me load this up.

00:42:31.901 --> 00:42:34.534
[applause]

00:42:34.534 --> 00:42:36.467
Thanks.

00:42:41.934 --> 00:42:43.834
So yeah, there are mics
here and here

00:42:43.834 --> 00:42:46.434
you can come up to.

00:42:46.434 --> 00:42:47.701
Yeah, cool.

00:42:47.701 --> 00:42:49.067
So I'll just start off
with some of these

00:42:49.067 --> 00:42:50.834
and then, if you
have any other questions,

00:42:50.834 --> 00:42:53.434
please step up
to the mic.

00:42:53.434 --> 00:42:56.067
And if you want to duck out,
thanks for coming.

00:42:56.067 --> 00:42:57.534
So...

00:42:57.534 --> 00:42:59.234
"What about ReferenceProperty
and ReferenceListProperty?

00:42:59.234 --> 00:43:01.067
"Are they as efficient
as StringListProperty?

00:43:01.067 --> 00:43:03.734
Can we apply the same practices
you described in your talk?"

00:43:03.734 --> 00:43:05.968
Yes, you can.
You can.

00:43:05.968 --> 00:43:09.033
The only reason you don't
want to do this, necessarily,

00:43:09.033 --> 00:43:11.934
is because ReferenceProperties
include keys.

00:43:11.934 --> 00:43:14.167
And keys can be
bulky sometimes.

00:43:14.167 --> 00:43:15.968
It has the kind,
the app I.D.,

00:43:15.968 --> 00:43:19.667
and the primary I.D. or name
of the entity

00:43:19.667 --> 00:43:21.067
in that key.

00:43:21.067 --> 00:43:22.901
So in terms
of actual storage space,

00:43:22.901 --> 00:43:26.334
you know, a key might be,
you know, 50 bytes

00:43:26.334 --> 00:43:28.567
and a single string
might be 10.

00:43:28.567 --> 00:43:31.000
So it depends
on how hardcore

00:43:31.000 --> 00:43:33.634
you're trying to do
your optimizations.

00:43:33.634 --> 00:43:35.634
But, yeah, you can
use ReferenceProperties

00:43:35.634 --> 00:43:38.801
if you want
to do it that way.

00:43:38.801 --> 00:43:41.167
So...

00:43:41.167 --> 00:43:42.501
"How well does
list property scale?

00:43:42.501 --> 00:43:44.234
"How many entries
can we put in it

00:43:44.234 --> 00:43:45.734
and not suffer
in performance?"

00:43:45.734 --> 00:43:47.334
Hopefully
I answered that one.

00:43:47.334 --> 00:43:49.200
For writes,
you're gonna pay a cost

00:43:49.200 --> 00:43:51.100
to do that serialization,

00:43:51.100 --> 00:43:52.267
to put it in the datastore.

00:43:52.267 --> 00:43:53.601
But to retrieve it back,

00:43:53.601 --> 00:43:55.167
you can avoid
that serialization cost

00:43:55.167 --> 00:43:58.801
and overhead.

00:43:58.801 --> 00:44:00.133
Yeah.

00:44:00.133 --> 00:44:03.033
man:
I wanted to ask...

00:44:03.033 --> 00:44:05.467
in merge-join,
about the work clause.

00:44:05.467 --> 00:44:08.200
You explained the method,
with the zig-zag...

00:44:08.200 --> 00:44:09.968
algorithm works.

00:44:09.968 --> 00:44:12.167
So it seems that it matters,

00:44:12.167 --> 00:44:15.367
the order of the clauses
inside the work clause

00:44:15.367 --> 00:44:16.934
for the zig-zag to work.

00:44:16.934 --> 00:44:20.267
And hence it affects
on the performance.

00:44:20.267 --> 00:44:22.000
Is that true?

00:44:22.000 --> 00:44:23.968
Slatkin: So sorry, could you
repeat that one more time?

00:44:23.968 --> 00:44:26.601
man: Does the order of the
statement in the work clause...

00:44:26.601 --> 00:44:27.767
Slatkin:
Oh.

00:44:27.767 --> 00:44:30.534
man: Affect the performance
of the query?

00:44:30.534 --> 00:44:31.767
Slatkin: Right.
That's a good question.

00:44:31.767 --> 00:44:34.100
Yeah, so the question,
I guess,

00:44:34.100 --> 00:44:35.801
is--does the--yeah.

00:44:35.801 --> 00:44:37.300
Does the order
of the equality filters

00:44:37.300 --> 00:44:39.901
in the merge-join
affect the performance?

00:44:39.901 --> 00:44:41.300
I believe, yes, it does.

00:44:41.300 --> 00:44:44.167
So if you--if you know
that you have a certain property

00:44:44.167 --> 00:44:46.767
that has a high correlation
to the results set,

00:44:46.767 --> 00:44:49.634
you should list that first.

00:44:49.634 --> 00:44:51.234
I think that we don't--
we don't have histograms

00:44:51.234 --> 00:44:53.434
and we don't have
a query planner to use them,

00:44:53.434 --> 00:44:55.634
so any hints
you can give us

00:44:55.634 --> 00:44:59.100
on the way to find
your results set is--is useful.

00:44:59.100 --> 00:45:01.067
And I think that
setting the equality--

00:45:01.067 --> 00:45:02.868
the order of the equality
filters will do that.

00:45:02.868 --> 00:45:04.200
I need to confirm that,

00:45:04.200 --> 00:45:05.801
but that's
a really good question.

00:45:05.801 --> 00:45:07.067
man:
It's not a big difference.

00:45:07.067 --> 00:45:08.267
Slatkin:
It's not a big difference?

00:45:08.267 --> 00:45:11.167
So, yeah, Ryan implemented it
along with Max,

00:45:11.167 --> 00:45:12.534
and he says it doesn't
make a big difference.

00:45:12.534 --> 00:45:14.434
I guess BigTable scanning
is very fast

00:45:14.434 --> 00:45:18.133
so that could be
a good explanation.

00:45:18.133 --> 00:45:22.033
Any other questions?
Yep.

00:45:22.033 --> 00:45:25.133
man: So if you have, say,
a list of objects

00:45:25.133 --> 00:45:27.501
that each have a price,

00:45:27.501 --> 00:45:30.000
and the price is dynamic,

00:45:30.000 --> 00:45:35.467
but you want to be able
to search on...

00:45:35.467 --> 00:45:37.634
objects that have a price
above a certain value.

00:45:37.634 --> 00:45:40.834
Is it possible
to do range queries

00:45:40.834 --> 00:45:45.367
without having to build a bunch
of fancy indexes behind them,

00:45:45.367 --> 00:45:47.334
because the data
might be changing?

00:45:47.334 --> 00:45:48.734
Slatkin:
Yeah, so...yeah.

00:45:48.734 --> 00:45:50.868
So that's--yeah,
so, you know,

00:45:50.868 --> 00:45:52.133
if you have data
that's changing,

00:45:52.133 --> 00:45:53.601
and you don't
want to have to have

00:45:53.601 --> 00:45:55.734
indexes for range queries,
how do you do it?

00:45:55.734 --> 00:45:58.100
So this is--this is
kind of the--

00:45:58.100 --> 00:46:00.033
the answer
to these kinds of questions

00:46:00.033 --> 00:46:02.267
usually is
precompute your views

00:46:02.267 --> 00:46:03.901
at write time.

00:46:03.901 --> 00:46:06.067
So if I have, you know,

00:46:06.067 --> 00:46:07.367
an example would be
an auction site.

00:46:07.367 --> 00:46:09.567
Show me everything between
the price of 0 and 5

00:46:09.567 --> 00:46:11.667
5 and 20,
20 and 100,

00:46:11.667 --> 00:46:13.601
100 and 1,000.

00:46:13.601 --> 00:46:16.234
You know that those are
going to be your views.

00:46:16.234 --> 00:46:18.901
When you update
the price of an item,

00:46:18.901 --> 00:46:22.834
add it--add that slice of data
to your list property.

00:46:22.834 --> 00:46:25.100
And then you can query
just for set membership.

00:46:25.100 --> 00:46:26.734
You don't have to do
a range query.

00:46:26.734 --> 00:46:29.601
And if you need
to change your ranges later,

00:46:29.601 --> 00:46:30.868
or add more ranges,

00:46:30.868 --> 00:46:32.567
you just can write
some relation index entities

00:46:32.567 --> 00:46:33.834
to do that,

00:46:33.834 --> 00:46:35.300
or you can update the ones
you already have.

00:46:35.300 --> 00:46:37.868
And our Task Queue API that
we'll be talking about tomorrow

00:46:37.868 --> 00:46:40.767
will greatly increase the--
your ability to do that.

00:46:40.767 --> 00:46:42.968
But yeah, I mean,
when you have code

00:46:42.968 --> 00:46:44.601
to update that index,

00:46:44.601 --> 00:46:46.167
just--just--you know,

00:46:46.167 --> 00:46:47.734
re...just, you know,

00:46:47.734 --> 00:46:49.901
change--change the way you're
slicing your--your fuzziness.

00:46:49.901 --> 00:46:51.200
That's what a fuzzy query is.

00:46:51.200 --> 00:46:55.467
That's a really
good example of one.

00:46:55.467 --> 00:46:58.033
We got some negative questions.
That's good.

00:46:58.033 --> 00:47:01.300
[chuckles]

00:47:01.300 --> 00:47:03.400
"Doesn't
the relation index entity

00:47:03.400 --> 00:47:05.267
suffer from
the n+1 select problem?"

00:47:05.267 --> 00:47:07.601
Who asked this question, and
could you please come to a mic?

00:47:07.601 --> 00:47:10.834
I don't know
the n+1 select problem.

00:47:10.834 --> 00:47:14.200
Anybody?
You, okay.

00:47:14.200 --> 00:47:16.834
Can you tell us--what is
the n+1 select problem?

00:47:16.834 --> 00:47:21.100
man: When you select--
when you select the...

00:47:21.100 --> 00:47:24.133
the actual number
of elements first,

00:47:24.133 --> 00:47:26.734
and then it does the select
for each of the element.

00:47:26.734 --> 00:47:28.534
If you go back
to the slide...

00:47:28.534 --> 00:47:29.734
Slatkin: Yeah.

00:47:29.734 --> 00:47:31.300
man: There was
a "for" loop order.

00:47:31.300 --> 00:47:33.133
Slatkin:
Oh.

00:47:33.133 --> 00:47:35.200
So...

00:47:35.200 --> 00:47:37.467
you're talking about...

00:47:37.467 --> 00:47:41.534
relation index...
so this one.

00:47:41.534 --> 00:47:42.868
Is this what
you're talking about?

00:47:42.868 --> 00:47:44.701
man: Yes, this one.
There's a "for" loop, right?

00:47:44.701 --> 00:47:47.067
Slatkin: This loop. That's
what you're talking about?

00:47:47.067 --> 00:47:48.367
man: Yep.

00:47:48.367 --> 00:47:49.734
Slatkin: So that loop
is just going over

00:47:49.734 --> 00:47:51.200
the index result set.

00:47:51.200 --> 00:47:54.167
Those entities
have already been...

00:47:54.167 --> 00:47:57.367
So this is a list of keys,
these indexes here.

00:47:57.367 --> 00:47:58.734
They're not separate queries.

00:47:58.734 --> 00:48:01.501
They are not--they don't
require SELECTs.

00:48:01.501 --> 00:48:03.267
man: And when you do
the db.get of keys

00:48:03.267 --> 00:48:05.267
you actually get
everything at once.

00:48:05.267 --> 00:48:07.868
Slatkin: Exactly.
So...so you're doing one SELECT,

00:48:07.868 --> 00:48:10.801
one set of BigTable scans--
actually, one BigTable scan

00:48:10.801 --> 00:48:12.767
to get all the keys.

00:48:12.767 --> 00:48:14.267
And then you're taking
all those keys,

00:48:14.267 --> 00:48:18.367
transforming them, and doing
one, like, hash table lookup

00:48:18.367 --> 00:48:20.067
to pull
all those values back.

00:48:20.067 --> 00:48:22.033
So you don't have--
there's no n+1 problem.

00:48:22.033 --> 00:48:25.133
It's just--it's one query,
one get.

00:48:25.133 --> 00:48:27.200
Cool.

00:48:27.200 --> 00:48:30.767
I have one more...

00:48:30.767 --> 00:48:32.200
I think this one's
a little out of scope,

00:48:32.200 --> 00:48:36.300
so, yeah, I can answer this
for you later.

00:48:36.300 --> 00:48:39.467
This one: "You talked about
avoiding list deserialization

00:48:39.467 --> 00:48:42.734
"for--you talked about avoiding
list deserialization for reads.

00:48:42.734 --> 00:48:43.934
"What about for writes?

00:48:43.934 --> 00:48:45.400
"Can we add a list value
without deserializing

00:48:45.400 --> 00:48:47.234
and serializing
the entire list?"

00:48:47.234 --> 00:48:49.467
So there's a trade-off here.

00:48:49.467 --> 00:48:53.267
You could just write
another message index entity.

00:48:53.267 --> 00:48:55.234
That has a lot
of costs associated with it.

00:48:55.234 --> 00:48:58.801
So you're paying--
the trade-off--the trade-off is

00:48:58.801 --> 00:49:02.634
storage space
or CPU time.

00:49:02.634 --> 00:49:04.467
You could write a new entity

00:49:04.467 --> 00:49:05.934
with that index value,

00:49:05.934 --> 00:49:08.000
a new relation index...

00:49:08.000 --> 00:49:09.767
when you need
a new index value.

00:49:09.767 --> 00:49:11.968
But then that's
a whole other entity

00:49:11.968 --> 00:49:13.567
and it has
all of its associated indexes

00:49:13.567 --> 00:49:15.133
and costs of the keys
and so on.

00:49:15.133 --> 00:49:18.267
So you need to figure out
that trade-off for yourself.

00:49:18.267 --> 00:49:20.067
If you don't really care
about storage space so much,

00:49:20.067 --> 00:49:21.234
then that's
a really good solution.

00:49:21.234 --> 00:49:24.300
But storage
is usually pretty cheap.

00:49:24.300 --> 00:49:26.367
So I could see the trade-off.

00:49:26.367 --> 00:49:28.234
But writes are also
very infrequent,

00:49:28.234 --> 00:49:30.200
so it could make sense
to update things.

00:49:30.200 --> 00:49:32.634
It would be awesome
if we had a way

00:49:32.634 --> 00:49:34.200
of just appending
to a list property

00:49:34.200 --> 00:49:35.667
without having to retrieve it.

00:49:35.667 --> 00:49:36.934
That would be
the ideal solution.

00:49:36.934 --> 00:49:38.133
And then we wouldn't
have to do any of this.

00:49:38.133 --> 00:49:39.334
You'd just say,
"Oh, yeah,

00:49:39.334 --> 00:49:40.868
"append this value
to a string list

00:49:40.868 --> 00:49:42.467
"and don't even
come back to me.

00:49:42.467 --> 00:49:44.467
I just want you to do it."

00:49:44.467 --> 00:49:45.667
And that--
that would be--

00:49:45.667 --> 00:49:47.601
that would be one way
to solve this also.

00:49:47.601 --> 00:49:49.300
Yeah.

00:49:49.300 --> 00:49:51.200
man: Yeah. What makes
a relation index entity

00:49:51.200 --> 00:49:52.834
better than
just a join entity,

00:49:52.834 --> 00:49:55.801
where you would have
the reference to the message

00:49:55.801 --> 00:49:57.133
and the reference
to the user?

00:49:57.133 --> 00:49:59.601
Slatkin:
Right, so...

00:49:59.601 --> 00:50:01.534
on the join entity--
so yeah.

00:50:01.534 --> 00:50:02.968
So--so the question is,
yeah.

00:50:02.968 --> 00:50:05.434
What makes a relation index
better than a join entity?

00:50:05.434 --> 00:50:07.534
A relation index, effectively,
is a join entity.

00:50:07.534 --> 00:50:08.801
That's what it's doing.

00:50:08.801 --> 00:50:10.434
It's serving
the same purpose.

00:50:10.434 --> 00:50:13.367
The reason that it's useful is
that it's a child of the parent.

00:50:13.367 --> 00:50:18.267
So if you saw...oh.

00:50:18.267 --> 00:50:19.534
Right here.

00:50:19.534 --> 00:50:21.734
The message index
is a child of its parent.

00:50:21.734 --> 00:50:25.567
So we can scan for
message indexes very quickly,

00:50:25.567 --> 00:50:27.934
get their keys, and then figure
out what their parents are.

00:50:27.934 --> 00:50:29.767
We can de-reference
that pointer really quickly

00:50:29.767 --> 00:50:32.234
in memory with a minimal amount
of serialization.

00:50:32.234 --> 00:50:34.200
If you do this the other way,

00:50:34.200 --> 00:50:36.100
with just, like,
one-to-many relationships,

00:50:36.100 --> 00:50:38.801
or with queries,
or...

00:50:38.801 --> 00:50:41.834
yeah, with a standard, like,
one-to-many relationship style.

00:50:41.834 --> 00:50:43.434
Because we don't have joins,

00:50:43.434 --> 00:50:45.300
you'd have to first
do a query

00:50:45.300 --> 00:50:46.767
for ten items,

00:50:46.767 --> 00:50:48.501
and then do a query
for each of those results

00:50:48.501 --> 00:50:50.701
to actually
find the references.

00:50:50.701 --> 00:50:52.400
And that's--that's
the problem.

00:50:52.400 --> 00:50:54.133
So...so, yeah,
MessageIndex

00:50:54.133 --> 00:50:55.934
is essentially a join table.

00:50:55.934 --> 00:50:58.100
It's a speed-up,
like that.

00:50:58.100 --> 00:50:59.467
Yeah.

00:50:59.467 --> 00:51:02.033
Dredge: Hi, Ert Dredge
from Universal Metaphor.

00:51:02.033 --> 00:51:03.434
Do you have suggestions

00:51:03.434 --> 00:51:05.434
when we're doing
our initial data architecture

00:51:05.434 --> 00:51:07.367
for helping to implement
these suggestions

00:51:07.367 --> 00:51:10.133
that might not be obvious
from the talk itself?

00:51:10.133 --> 00:51:11.534
Slatkin: Yeah,
that's a great question.

00:51:11.534 --> 00:51:15.234
So are there optimizations
that you should make

00:51:15.234 --> 00:51:17.400
when implementing your data

00:51:17.400 --> 00:51:20.000
or modeling your data
not captured here?

00:51:20.000 --> 00:51:22.067
Well,
there are a few things.

00:51:22.067 --> 00:51:24.534
There is a few kind of hidden--
hidden parts of this

00:51:24.534 --> 00:51:26.300
that--that we need
to be more clear about.

00:51:26.300 --> 00:51:29.467
For instance, how do you compute
the cost of indexes?

00:51:29.467 --> 00:51:31.300
And how do you--
like, storage costs.

00:51:31.300 --> 00:51:34.334
And how do you compute
the cost of...

00:51:34.334 --> 00:51:36.200
also the datastore
storage itself?

00:51:36.200 --> 00:51:39.067
We're working on making this
more clear to people

00:51:39.067 --> 00:51:41.367
so they can actually kind of
calculate their index--

00:51:41.367 --> 00:51:43.667
their--the index size
that their data would have.

00:51:43.667 --> 00:51:45.267
And how to figure out

00:51:45.267 --> 00:51:46.934
the overhead
of having composite indexes

00:51:46.934 --> 00:51:48.467
and list properties.

00:51:48.467 --> 00:51:51.367
So that's something
that would be best for you--

00:51:51.367 --> 00:51:52.601
when you're modeling
your data, you say,

00:51:52.601 --> 00:51:54.200
"Oh, well, if I need
this composite query,

00:51:54.200 --> 00:51:55.968
that could explode,"
or that, you know,

00:51:55.968 --> 00:51:57.534
"that's gonna require
an extra row,"

00:51:57.534 --> 00:52:00.567
and then that has
a large cost.

00:52:00.567 --> 00:52:02.467
Another thing
to remember is that

00:52:02.467 --> 00:52:04.234
in a standard SQL database,

00:52:04.234 --> 00:52:06.000
primary key is usually
just an integer

00:52:06.000 --> 00:52:08.701
which has a very small
amount of storage space.

00:52:08.701 --> 00:52:10.934
With us,
we also have I.D.s,

00:52:10.934 --> 00:52:13.267
numerical I.D.s
that are primary keys,

00:52:13.267 --> 00:52:15.133
but our keys, like I said,

00:52:15.133 --> 00:52:17.100
encode the full path
to the element.

00:52:17.100 --> 00:52:19.868
That includes the app I.D.,
the kind,

00:52:19.868 --> 00:52:22.968
any child and parent
relationships are in there,

00:52:22.968 --> 00:52:24.701
finally down
to the primary key.

00:52:24.701 --> 00:52:28.400
And so, it's useful--
it sounds funny,

00:52:28.400 --> 00:52:32.100
but it's useful to actually
use kind names that are short

00:52:32.100 --> 00:52:34.167
and to use key names
that are short,

00:52:34.167 --> 00:52:36.667
because it reduces
the amount of index space

00:52:36.667 --> 00:52:38.067
you have to write,

00:52:38.067 --> 00:52:39.567
which is kind of
a funny thing.

00:52:39.567 --> 00:52:41.701
Another one
that's kind of similar

00:52:41.701 --> 00:52:44.334
is there's a lot of
really interesting things

00:52:44.334 --> 00:52:45.767
you can do around encoding.

00:52:45.767 --> 00:52:48.200
So one of the ones I know--
I forget the name of it.

00:52:48.200 --> 00:52:50.434
If someone remembers it,
shout it out.

00:52:50.434 --> 00:52:51.701
There's this type
of encoding

00:52:51.701 --> 00:52:53.300
where if you know something's
going to be--

00:52:53.300 --> 00:52:54.767
happen really frequently,

00:52:54.767 --> 00:52:57.234
you should just--you should
make its representation

00:52:57.234 --> 00:52:59.133
be as short as possible.

00:52:59.133 --> 00:53:01.000
There we go.
Huffman encoding, yeah.

00:53:01.000 --> 00:53:02.734
So if you can do that--

00:53:02.734 --> 00:53:04.467
if you know that,
you know,

00:53:04.467 --> 00:53:06.234
like, you're gonna
have a celebrity

00:53:06.234 --> 00:53:08.000
and they're gonna be using
your microblogging system

00:53:08.000 --> 00:53:09.434
all the time,

00:53:09.434 --> 00:53:10.868
or you have one node
that's connected to everything,

00:53:10.868 --> 00:53:12.801
you want its primary key
to be very short.

00:53:12.801 --> 00:53:14.734
Because its--its value
is going to be

00:53:14.734 --> 00:53:16.000
in a lot of different lists.

00:53:16.000 --> 00:53:17.234
It's going to be
in a lot of relationships.

00:53:17.234 --> 00:53:18.567
It's going to have
a lot of index rows.

00:53:18.567 --> 00:53:20.133
And you want
to minimize its size.

00:53:20.133 --> 00:53:22.234
And so if you can use
that kind of encoding technique

00:53:22.234 --> 00:53:25.734
you can really minimize
your storage space a lot.

00:53:25.734 --> 00:53:27.567
Cool.

00:53:27.567 --> 00:53:29.334
Over here.

00:53:29.334 --> 00:53:31.234
man: Is there any way
to do like queries

00:53:31.234 --> 00:53:33.367
or full text search?

00:53:33.367 --> 00:53:34.734
Slatkin: To do like queries
or full text search.

00:53:34.734 --> 00:53:36.968
So, yeah,
so the best answer we have--

00:53:36.968 --> 00:53:38.234
there--okay, three answers.

00:53:38.234 --> 00:53:40.634
So the first answer
is that we have

00:53:40.634 --> 00:53:42.968
a "poor man's"
full text search,

00:53:42.968 --> 00:53:47.767
which is the Google App Engine
ext search module

00:53:47.767 --> 00:53:49.434
that Ryan Barrett wrote.

00:53:49.434 --> 00:53:51.868
That just uses merge-join,
like I've described here,

00:53:51.868 --> 00:53:53.801
to do full text queries.

00:53:53.801 --> 00:53:56.300
It doesn't have
ranking and ordering,

00:53:56.300 --> 00:53:58.267
and it has a bunch
of other problems,

00:53:58.267 --> 00:54:01.734
but it's really good
for simple stuff.

00:54:01.734 --> 00:54:04.200
And, like I said, it's good
for a small result set.

00:54:04.200 --> 00:54:05.767
So if you know
that you're only gonna get

00:54:05.767 --> 00:54:08.133
20...20 results,
100 results,

00:54:08.133 --> 00:54:10.601
and then can sort them
in memory, it's great.

00:54:10.601 --> 00:54:13.267
In terms
of full text search,

00:54:13.267 --> 00:54:16.667
then you need something like
a real full text search.

00:54:16.667 --> 00:54:19.033
This is, you know...
you need ranking

00:54:19.033 --> 00:54:21.868
and you need all kinds
of duplicate elimination

00:54:21.868 --> 00:54:23.267
and all kinds of stuff.

00:54:23.267 --> 00:54:25.434
This is something that
we know our users want,

00:54:25.434 --> 00:54:27.200
we're asked about
all the time.

00:54:27.200 --> 00:54:28.767
I don't have
anything to announce

00:54:28.767 --> 00:54:30.734
but we know you want it.

00:54:30.734 --> 00:54:32.367
You know,
"This is Google.

00:54:32.367 --> 00:54:33.868
"They don't have
full text search.

00:54:33.868 --> 00:54:35.133
What's going on?"
Yeah, we know.

00:54:35.133 --> 00:54:37.300
[laughter]
It's hard, actually.

00:54:37.300 --> 00:54:39.367
So...

00:54:39.367 --> 00:54:41.634
we're--we're--that's
the best answer I can give you.

00:54:41.634 --> 00:54:45.801
I think there's a number three,
but I forgot what it was.

00:54:45.801 --> 00:54:47.467
See if there was...

00:54:47.467 --> 00:54:48.968
where did that--ah.

00:54:48.968 --> 00:54:51.334
Is there anything else...

00:54:51.334 --> 00:54:54.734
[indistinct chatter]

00:54:54.734 --> 00:54:56.534
Oh, this one's
putting it down.

00:54:56.534 --> 00:54:58.133
"One of the reasons for you
giving us list properties

00:54:58.133 --> 00:54:59.467
"is to save storage space.

00:54:59.467 --> 00:55:00.734
"Since Google is handling
storage, why do we care?"

00:55:00.734 --> 00:55:02.267
Billing is enabled.

00:55:02.267 --> 00:55:04.901
You can store...yeah.

00:55:04.901 --> 00:55:06.968
You can--you can store
gigabytes of data.

00:55:06.968 --> 00:55:09.167
It's not just one gig
of free quota.

00:55:09.167 --> 00:55:12.067
Quotas--you can get
that quota really high now.

00:55:12.067 --> 00:55:13.434
And it's pretty cheap.

00:55:13.434 --> 00:55:15.200
So you can store a lot of data
without even knowing it.

00:55:15.200 --> 00:55:17.501
So...yeah, you know.

00:55:17.501 --> 00:55:19.501
We try to instill
the best practices

00:55:19.501 --> 00:55:22.934
in our programming model,
in our APIs.

00:55:22.934 --> 00:55:24.534
But we can't always do that,

00:55:24.534 --> 00:55:26.734
and so this is kind of
a cautionary tale

00:55:26.734 --> 00:55:29.300
to tell you to--
to think about storage

00:55:29.300 --> 00:55:31.000
before you--
before you actually

00:55:31.000 --> 00:55:34.200
rack up a big bill
or something.

00:55:34.200 --> 00:55:36.100
I think
I'm out of questions, and...

00:55:36.100 --> 00:55:37.367
so thanks a lot
for coming.

00:55:37.367 --> 00:55:40.033
Again, I really appreciate it.
[applause]

