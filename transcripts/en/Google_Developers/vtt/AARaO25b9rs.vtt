WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.150
&gt;&gt; COVITZ: All right. Welcome, everybody.
We're really excited to be here with you today

00:00:05.150 --> 00:00:09.559
to introduce something that we've been working
really hard on that called the Google Wave

00:00:09.559 --> 00:00:16.540
Media APIs. And we're excited to tell you
what this is all about. Wave Media APIs, sort

00:00:16.540 --> 00:00:21.510
of, bridge the gap between wave and other
systems. And this is, if you've been, you

00:00:21.510 --> 00:00:25.340
know, listening to the other talks that have
happened, you know, yesterday and today that

00:00:25.340 --> 00:00:32.560
sort of the theme. We have federation, we
have enterprise talks, we've liberated robots,

00:00:32.560 --> 00:00:37.230
we've done lots of things and this is, sort
of, the next step in that process. How do

00:00:37.230 --> 00:00:43.800
you get rich content in to and out of wave
and how do you manipulate, play, and have

00:00:43.800 --> 00:00:50.220
fun with that content all while still staying
in within wave? Before we get started I wanted

00:00:50.220 --> 00:00:55.280
to navigate everybody to the live wave for
this session. There you can find notes being

00:00:55.280 --> 00:00:59.760
taken, discussions being had, you can ask
questions. We'll also take questions at the

00:00:59.760 --> 00:01:04.830
end of the session from the microphones here
in the audience, so please go there and have

00:01:04.830 --> 00:01:11.920
fun while you're enjoying the talk. Just a
quick recap on what wave is. I'm sure after

00:01:11.920 --> 00:01:17.600
two days of using wave throughout Google I/O
and the year after we've launched it, it's

00:01:17.600 --> 00:01:22.360
probably or hopefully it's clear to you what
wave is really well suited for and we feel

00:01:22.360 --> 00:01:28.431
its best suited for collaboration. Collaboration
means many things and collaboration; you can

00:01:28.431 --> 00:01:34.570
use collaboration for number of purposes collaborating
on and around business, documents, processes,

00:01:34.570 --> 00:01:40.780
and meetings. In the education space, research
projects, different learning sessions, let

00:01:40.780 --> 00:01:45.160
a teacher or professor monitor what's going
on with the learning of their students. And

00:01:45.160 --> 00:01:50.490
in the consumer space, you can collaborate
on photo albums, party planning, community

00:01:50.490 --> 00:01:57.600
groups you name it; everything that you can
collaborate on. What makes wave especially

00:01:57.600 --> 00:02:05.920
great is that wave infuses communication in
and around your collaboration. This is what

00:02:05.920 --> 00:02:11.140
really steam lines it. You can find out, you
can talk about a particular aspect of a document.

00:02:11.140 --> 00:02:17.191
You can focus in on an aspect of that document.
You can also converse about it and lastly

00:02:17.191 --> 00:02:22.140
wave is live and real-time. You don't have
to wait to find out what someone thinks about,

00:02:22.140 --> 00:02:26.450
what's your typing, they can see that you're
typing right now, they can jump in and they

00:02:26.450 --> 00:02:32.930
can interact with you as well. Before I go
to into rich content, I forgot to introduce

00:02:32.930 --> 00:02:38.290
myself and my teammates. I'm Seth and this
is Jimin and Phil.

00:02:38.290 --> 00:02:39.871
&gt;&gt; LI: Hi.
&gt;&gt; COVITZ: And we're all engineers on the

00:02:39.871 --> 00:02:45.880
Google Wave team. Jimin and Phil will be helping
me out a little bit later in this talk going

00:02:45.880 --> 00:02:53.050
to go into deeper detail on how all of these
APIs work. In particular, what is rich content?

00:02:53.050 --> 00:02:58.459
So you know what a wave is, you know how waves
work. What is rich content? Rich content is

00:02:58.459 --> 00:03:04.130
basically any external content from a source
outside of wave. It can be from an external

00:03:04.130 --> 00:03:10.209
system, from an external application. It can
be, you know, photos, documents, diagrams;

00:03:10.209 --> 00:03:15.080
it can be proprietary file formats that your
enterprise may have, whatever it is that is

00:03:15.080 --> 00:03:22.380
rich content. With rich content users expect
to be able to do everything they can do at

00:03:22.380 --> 00:03:28.170
rich content on the desktop. They expect to
be able to import it, view it, play it, convert

00:03:28.170 --> 00:03:33.420
it to various things, apply transformations
from one format to another format, publish

00:03:33.420 --> 00:03:37.970
it to their blog or to their website or their
content management system and synchronize

00:03:37.970 --> 00:03:42.470
it with other systems they may have. Just
to give you a little taste, why don't we do

00:03:42.470 --> 00:03:52.110
a little demo for you?
So here I am in wave. I'm going to create

00:03:52.110 --> 00:03:58.160
a new wave. I'm going to add Jimin and Phil
to this wave and say we're getting hungry

00:03:58.160 --> 00:04:02.780
because it's getting a little late, and I'm
going to see if they want to have some Chinese

00:04:02.780 --> 00:04:08.930
food. Now typically what would happen at this
point is I would find a PDF of a menu or something

00:04:08.930 --> 00:04:14.400
there and I would drag it and upload it to
the wave as this is happening. You can watch

00:04:14.400 --> 00:04:20.840
it upload over the network connection. The
PDF is upload and the PDF is converted. Prior

00:04:20.840 --> 00:04:25.120
to today what would happen is you would see
the PDF in wave and you would say, "That's

00:04:25.120 --> 00:04:29.160
great." You would go and you would download
it and you review it and you start to come

00:04:29.160 --> 00:04:35.020
back to the wave to talk about it. Now with
the media APIs, we can import the content

00:04:35.020 --> 00:04:41.240
of the PDF directly into Wave. So I'm going
to drag one of my media API robots here called

00:04:41.240 --> 00:04:46.831
import PDF to this wave. It's going to scan
the PDF and then replace it with the content

00:04:46.831 --> 00:04:53.680
of the wave to quote Vic from this morning.
Boom, there it goes. Now once it's here, I

00:04:53.680 --> 00:04:57.900
can, you know, clear up anything that's not
important. Phil and Jimin can come in and

00:04:57.900 --> 00:05:03.710
talk about what they like, I can talk about
what I like. We can place our order and enjoy

00:05:03.710 --> 00:05:09.380
our Chinese food. So this is an example of
bringing content from another source or actually

00:05:09.380 --> 00:05:16.430
from a real document into wave. Now I'm going
to give you another example, maybe a richer

00:05:16.430 --> 00:05:21.260
example of how or what we can do with these
APIs and robots that are using these APIs.

00:05:21.260 --> 00:05:27.150
I'm going to start a new wave and we're going
to call these slides. We're going to make

00:05:27.150 --> 00:05:32.949
some slides. I'm going to add Jimin and Phil
to this wave and each of us is going to collaborate

00:05:32.949 --> 00:05:43.419
on a slideshow we want to give. Like what
are we going to do after I/O? So after I/O--hmm.

00:05:43.419 --> 00:05:48.850
Should we take a vacation? Jimin is already
reading my mind and she's creating a slide

00:05:48.850 --> 00:05:57.880
about what, where we should on the vacation
and how long should we take? Should we take

00:05:57.880 --> 00:06:05.160
Larz and Greg with us? I don't know. They
both have thumbs up, they're coming with us.

00:06:05.160 --> 00:06:10.430
So, we created a simple thing in wave because
we're not good at really creating presentations.

00:06:10.430 --> 00:06:15.430
We just made some bulleted list on things
that we might want to share. And because we're

00:06:15.430 --> 00:06:19.420
not great at creating presentations, what
I'd really like to do is I'd really wish there

00:06:19.420 --> 00:06:25.009
was a robot out there that could take this
and create a nice presentation for me. And

00:06:25.009 --> 00:06:32.130
luckily I have one of those robots here. So
I drag this media API export robot. It's going

00:06:32.130 --> 00:06:38.009
to look at the content in the wave and it's
going to create a PowerPoint just like that.

00:06:38.009 --> 00:06:51.610
I clicked on it and we'll take a look at it
and here you go. It took the PowerPoint; it

00:06:51.610 --> 00:06:58.169
created some nice styling for me, and Phil,
for Phil and Jimin. Eat lots of food, I agree

00:06:58.169 --> 00:07:02.890
with that too. So that gives an example of
how we can take that content that was simply

00:07:02.890 --> 00:07:08.190
created in wave out of bunch of rich formatting
and styling, export it in another format,

00:07:08.190 --> 00:07:14.860
and reattach that content back into the wave.
In a similar vein, you might get presentations

00:07:14.860 --> 00:07:19.990
from other people that you want to import
back into wave. So what if we took this presentation

00:07:19.990 --> 00:07:25.650
and we pulled it back into wave using an import
robot. And when you see we can stack robots

00:07:25.650 --> 00:07:30.350
like this and multiple robots can apply different
transformations. So this robot takes a little

00:07:30.350 --> 00:07:40.330
bit more time because it has to process the
information and render it into a series of

00:07:40.330 --> 00:07:47.300
images. Thank you. That robot likes to take
its time. And now we have the same PowerPoint

00:07:47.300 --> 00:07:52.020
presentation that we collaborated on here
in wave that we can share with our friends.

00:07:52.020 --> 00:08:03.819
All made possible by the power of the media
APIs. So introducing the wave media APIs,

00:08:03.819 --> 00:08:12.310
what this APIs were offering? For the first
time, give the developer full access to attachments.

00:08:12.310 --> 00:08:17.870
Robots can create, fetch, delete attachments
as much as they want, as often as they want,

00:08:17.870 --> 00:08:22.460
in any way that they want. They have full
access to the binary data, so they can manipulate

00:08:22.460 --> 00:08:28.330
the attachments as well as, you know, other
things. We also are introducing gadgets and

00:08:28.330 --> 00:08:33.000
giving gadgets the ability to have access
to these same attachments. If you notice at

00:08:33.000 --> 00:08:37.820
the beginning while I was playing the soundtrack
at the beginning of the talk, the soundtrack

00:08:37.820 --> 00:08:43.210
was actually pulling from an MP3 that was
loaded into the wave. The gadget was being

00:08:43.210 --> 00:08:47.830
used to view the MP3 not host it somewhere
else but the MP3 that I had dragged and dropped

00:08:47.830 --> 00:08:53.540
earlier into wave. So you can view documents,
you manipulate documents, you can play media

00:08:53.540 --> 00:08:58.910
all within the gadgets, all within the wave.
And lastly, we're going to show you some extensions

00:08:58.910 --> 00:09:04.360
on how you can bundle this capabilities into
extensions that can be shared with co-workers

00:09:04.360 --> 00:09:09.060
and the other people working in your work
group to get more work done efficiently, more

00:09:09.060 --> 00:09:13.700
efficiently. And with that I'm going to hand
it over to Jimin who's going to tell you in

00:09:13.700 --> 00:09:21.320
more detail about how the robot APIs works.
&gt;&gt; LI: Thank you, Seth. So what has a wave

00:09:21.320 --> 00:09:27.660
robot attachment to APIs? So those are the
APIs that can make wave robot create, delete,

00:09:27.660 --> 00:09:36.580
or update attachments from a blip. With this
new functionality, there are a lot more like

00:09:36.580 --> 00:09:43.649
new use-cases. For example, wave robot can
now import attachment content from another

00:09:43.649 --> 00:09:48.260
attachment into Google Wave. Another example
is that they can export a wave content out

00:09:48.260 --> 00:09:57.170
into an attachment, or they can read one attachment
and convert it to one type, from one type

00:09:57.170 --> 00:10:06.490
to another type. So first, I'm going to introduce
the read API. So Wave Attachment Read API,

00:10:06.490 --> 00:10:13.140
what you can do is you can retrieve attachment
information. So you can gather the attachment

00:10:13.140 --> 00:10:19.250
content. There are two ways you can get attachment
content, first way is you use to getters for

00:10:19.250 --> 00:10:24.610
the data to get attachment content. Behind
the scene, the getter will first get the attachment

00:10:24.610 --> 00:10:33.290
URL and then will fetch the URL content and
then will present the content to you. Of course,

00:10:33.290 --> 00:10:41.080
the second way is that you can always do the
same by getting the attachment URL and fetch

00:10:41.080 --> 00:10:44.210
the content to yourself. Attachments also
have several attributes. Attachment ID is

00:10:44.210 --> 00:10:50.660
a unique ID assigned to the attachment. Attachment
caption is a caption or filename of the attachment.

00:10:50.660 --> 00:10:56.490
And the attachment URL is a URL that you can
use to download the attachments. And, of course,

00:10:56.490 --> 00:11:04.089
the last one is a MIME Type, which is an Internet
media type. Wave Attachment Read API. One

00:11:04.089 --> 00:11:11.290
use-case, as I just mentioned, is you can--during
the import use-case, which it'll first, read

00:11:11.290 --> 00:11:16.770
an attachment from Google Wave and then you
read that content and you convert that content

00:11:16.770 --> 00:11:24.000
and then you do the import. With this, I'm
going to show you a demo. So first, I'm going

00:11:24.000 --> 00:11:32.339
create a new wave and I'm going to call it
the import. And after that, I'm going to drag

00:11:32.339 --> 00:11:41.839
a text file and I want to import the content
of the text file into Google Wave. So what

00:11:41.839 --> 00:11:48.730
I can do is I can ask my favorite robot called
the import robot to do this. It will read

00:11:48.730 --> 00:11:54.470
the attachment content, and will convert that
into string and then will delete the attachment

00:11:54.470 --> 00:12:06.019
and replace it with attachment content. So
this is the flow that I just showed to you.

00:12:06.019 --> 00:12:13.990
For import to work, user first needs to upload
files and then the robot being added to wave.

00:12:13.990 --> 00:12:17.310
And the robot will fetch the binary data and
the robot converts and inserts the content.

00:12:17.310 --> 00:12:29.910
And below you can see the details of the flow.
All right, so let's take a closer look at

00:12:29.910 --> 00:12:39.510
the code. How does it work? So first, I want
to make sure that I can read the entire wavelet.

00:12:39.510 --> 00:12:47.430
So I specify this by using the "context=context.ALL()".
And then after that, I overwrite one function

00:12:47.430 --> 00:12:54.550
called on "OnWaveletSelfAdded". This will
be triggered whenever I add a robot to this

00:12:54.550 --> 00:13:02.300
wave. And my robot, not only it can do the
import case, it also can do the export case.

00:13:02.300 --> 00:13:08.540
To make this happen, I'm using the "proxyingFor".
So, as you can see, one is proxying for the

00:13:08.540 --> 00:13:19.050
import. It is act as an import robot. And
the one is proxying for export is act as an

00:13:19.050 --> 00:13:27.480
export robot. So let's take a look at the
import function and to see how the robot works

00:13:27.480 --> 00:13:41.290
to import the text. So first, it will gather
attachment element. It will gather first the

00:13:41.290 --> 00:13:46.800
attachment element of this blip. And then
after that, it will use the "attachment.getData"

00:13:46.800 --> 00:13:52.570
to get the attachment data. And it will convert
the attachment data into a string. And then

00:13:52.570 --> 00:14:02.230
it will use a replace function to replace
the attachment with the string. So next, I'm

00:14:02.230 --> 00:14:10.870
going to talk about attachment write API.
Wave Attachment Write API, what you can do?

00:14:10.870 --> 00:14:18.690
You can create an attachment with captioned
and the attachment data in byte array. You

00:14:18.690 --> 00:14:25.590
can delete an attachment by removing the corresponding
element. Or you can update the attachment

00:14:25.590 --> 00:14:34.130
by replacing it with a new attachment. One
use-case for the attachment write API is the

00:14:34.130 --> 00:14:40.180
export case. Where you can create a wave,
you put some content into the wave, and you

00:14:40.180 --> 00:14:46.389
can drag an export robot and the robot will
get all the content from the wave and actually

00:14:46.389 --> 00:14:53.139
put it out with some attachment and then using
attachment write API to put attachment back

00:14:53.139 --> 00:14:58.490
into Google Wave. So I'm going to give you
a demo on that. So this is my import robot

00:14:58.490 --> 00:15:02.130
that just created this file. Now, I'm going
to drag my export robot which will read this

00:15:02.130 --> 00:15:07.512
content and then create a file based on the
content. And this is the export data text.

00:15:07.512 --> 00:15:36.110
When you click and then you can see the text
content. So this is the export flow that I

00:15:36.110 --> 00:15:42.610
just did. So first, user creates contents,
after that the user asks robot, and the robot

00:15:42.610 --> 00:15:49.740
can work the content and then robot attach
the content. So this is a flow of the export

00:15:49.740 --> 00:15:55.560
flow. The user will add as a robot, and the
wave will send robot, add event, the robot

00:15:55.560 --> 00:16:02.240
will convert the data and then eventually
attach the content back to Wave. So now you

00:16:02.240 --> 00:16:09.000
learn to like write and read API. And with
this write and read API, there's a lot of

00:16:09.000 --> 00:16:14.970
things you can do. So one demo I want to show--oh
before I go that far, I'd probably want to

00:16:14.970 --> 00:16:23.740
show the code of the export. So for export
code, first, I'm going to iterate over all

00:16:23.740 --> 00:16:30.230
the blips in the wavelet. And for each blip
in the wavelet, I'm going to get a blip content

00:16:30.230 --> 00:16:39.649
and then I'm going to append that into a string
builder. So after that, I'm going to create

00:16:39.649 --> 00:16:41.620
an attachment element. I'll specify one parameter
which is caption and that the other parameter

00:16:41.620 --> 00:16:47.940
which is data. So I convert the data to the
byte array. And after that, I call append

00:16:47.940 --> 00:16:54.579
to append the attachment to the reply blip.
So with the read and the write API, there's

00:16:54.579 --> 00:17:08.970
a lot you can do. So one example I have is
called the Origami Photo Album. So at first,

00:17:08.970 --> 00:17:21.549
I needed to take a look at my pictures. And
for this demo to work, I need the help from

00:17:21.549 --> 00:17:33.879
my Origami robot. So those are the pictures
I took last year while we visited London.

00:17:33.879 --> 00:17:40.659
And I want to show the pictures to my friend
in a nicer format. So for that, the Origami

00:17:40.659 --> 00:17:50.320
demo robot will do this. So let's see how
it works. So the Origami Photo Album Robot

00:17:50.320 --> 00:17:55.380
will compose two different styles of pictures.
And each picture will have four different--will

00:17:55.380 --> 00:18:03.139
compose it by for different small pictures,
and for it to work. So first, it will--using

00:18:03.139 --> 00:18:14.980
the read API to get all the image attachment
URLs. After that, the robot will fetch the

00:18:14.980 --> 00:18:24.729
URL content itself and then it will resize
the images and then it will compose the images

00:18:24.729 --> 00:18:31.480
into two different styles. And each style
will have like four pictures on it. And after

00:18:31.480 --> 00:18:35.499
that, the last type is it's going to use attachment
write API to insert the pictures back to the

00:18:35.499 --> 00:18:41.159
Wave. So let's see how it works. So here you
go. You have two pictures. I'm going to use

00:18:41.159 --> 00:18:45.669
the attachment slideshow to show this picture.
And as you can see these are the palace and

00:18:45.669 --> 00:18:46.970
the subway, taxi, and the garden near the
palace. And, of course, the other picture,

00:18:46.970 --> 00:18:52.690
you have days of London and nights of London.
And I believe this is the [INDISTINCT] the

00:18:52.690 --> 00:19:05.240
fourth installation of the [INDISTINCT] which
was released last May. And. it was on, at

00:19:05.240 --> 00:19:10.169
[INDISTINCT] like last October. So the next
example I want to show you of using the read

00:19:10.169 --> 00:19:27.809
and the write API, it is called the Bar Chart.
So I have a file called the World Population.

00:19:27.809 --> 00:19:42.710
So if I take a look at this file and you can
see our world population for the last 30 years.

00:19:42.710 --> 00:19:50.470
From year '80, we have 4.4 billion people
and then last year we have around like 6.7

00:19:50.470 --> 00:19:59.970
billion people. And, I want to show this,
you know, a nice chart so that I can see the

00:19:59.970 --> 00:20:07.019
trend clearly. For that, I'm going to drag
the bar chart robot. So this robot will use

00:20:07.019 --> 00:20:13.200
attachment read API to read the file and after
that it converts the file into some chart

00:20:13.200 --> 00:20:22.140
and it's using the attachment write API to
create a chart, to insert a chart back into

00:20:22.140 --> 00:20:38.389
Wave, and this is the chart. So this bar chart
robot, what does it do? Let's recap here.

00:20:38.389 --> 00:20:46.159
So first, it creates the bar chart based on
the text file data. So first it will read

00:20:46.159 --> 00:20:52.299
the attachment data and then it create bar
chart and then it will insert the attachment

00:20:52.299 --> 00:20:59.879
back into Google Wave. And with this, I'm
going to hand over to Phil talking about the

00:20:59.879 --> 00:21:04.019
Gadget Viewer API.
&gt;&gt; LIAO: Thank you. So as Seth just showed

00:21:04.019 --> 00:21:10.809
you an MP3 player is a viewer and, but you
could also build viewers for in lining PDFs

00:21:10.809 --> 00:21:21.259
or spreadsheets. Now I'm going to show you
how you would use a viewer as an end user.

00:21:21.259 --> 00:21:32.169
So first you install the viewer.
It is already installed so I'm going to uninstall

00:21:32.169 --> 00:21:38.970
it and install it again but, you don't have
to do that. The first time you install a viewer

00:21:38.970 --> 00:21:45.570
it would ask you for permission but this is
second time so it remembers and it just goes

00:21:45.570 --> 00:22:04.249
through. Okay. Now I'll start a new wave and
I'm going to take a text file,

00:22:04.249 --> 00:22:10.460
and drag it. Okay. So I have a text file and
now the user would say, open the menu, and

00:22:10.460 --> 00:22:22.470
expand with the ASCII viewer. And you have
a cat that waves its tail. All right, okay.

00:22:22.470 --> 00:22:33.919
So end of demo. So when you click, open with,
we involved the gadget, the viewer and we

00:22:33.919 --> 00:22:40.039
give it that attachment URL and that viewer
would take that URL, download the data and

00:22:40.039 --> 00:22:47.999
do something with it then it displays it to
the user. So that is the viewer API. Basically,

00:22:47.999 --> 00:22:56.330
we give you the URL and you do something with
it. So, this is the complete text of a text

00:22:56.330 --> 00:23:04.860
viewer. It's very simple, it's a normal OpenSocial
gadget that uses wave API and let me take

00:23:04.860 --> 00:23:13.369
you through the steps. So first, you'll initialize
the gadget, in this initialization code you

00:23:13.369 --> 00:23:20.919
tell wave that you're interested in the state
change event. So when wave opens your gadget,

00:23:20.919 --> 00:23:28.320
it'll tell you that you have a new state attribute
called attachment URL and it has a new value.

00:23:28.320 --> 00:23:33.629
So now you can do something with it. So in
this case, we're making a request to get the

00:23:33.629 --> 00:23:40.909
contents of the URL and when that's finished,
we have a callback on URL fetch and we take

00:23:40.909 --> 00:23:48.159
the text file and put it in the content container.
Now you have a simple text viewer and it's

00:23:48.159 --> 00:23:54.509
actually quite useful. So, when you have a
system crash and you have a multiple JFile,

00:23:54.509 --> 00:24:00.070
you don't want to email it back and forth
and have coded text after coded text and coded

00:24:00.070 --> 00:24:05.360
text, instead you would view your text file,
your log for JFile in the wave and then you

00:24:05.360 --> 00:24:13.759
could discuss it in wave so you don't get
this email back and forth, it's very useful.

00:24:13.759 --> 00:24:20.340
Now if you're doing the MP3 player then you
would insert a flash gadget and give it the

00:24:20.340 --> 00:24:26.289
URL and it will play music for you. We have
something more complicated you sent that URL

00:24:26.289 --> 00:24:32.499
through AJAX to some server and it does some
processing and it makes a nice presentation

00:24:32.499 --> 00:24:41.359
for you. So now that you have viewers and
importers, exporters you will like share them

00:24:41.359 --> 00:24:46.629
with your friends, co-workers so you would
make extensions, package them as extensions

00:24:46.629 --> 00:24:57.399
so that you have an installer that you could
share and let me show you. So, the first thing

00:24:57.399 --> 00:25:07.849
you want to do is you go to your featured
extensions gallery and you find the one that's

00:25:07.849 --> 00:25:19.229
for developers only. So, this one is the extensions
that let you install other extensions so when

00:25:19.229 --> 00:25:29.889
you install it out you will see the installer
in your toolbar, so. When I create a new wave,

00:25:29.889 --> 00:25:49.629
this little icon here is your extensions installer.
Okay. Okay. So now it'd ask me for a manifest.

00:25:49.629 --> 00:26:20.229
So, I'm going to type in the manifest, the
address of the manifest. And, actually, I

00:26:20.229 --> 00:26:25.629
already have installed it so it comes back
that says, do you want to uninstall it? But,

00:26:25.629 --> 00:26:29.539
I'm not going through that again. So now you
can share this wave with everyone and they

00:26:29.539 --> 00:26:46.090
could also install the text viewer. So let
me go back to the cat. And I could open it

00:26:46.090 --> 00:26:56.470
with the regular text viewer, so it shows
you how I actually created the animation.

00:26:56.470 --> 00:27:10.739
And we could go back to the waving cat with
the other viewer. Okay. So this is the installer

00:27:10.739 --> 00:27:18.000
site, and now, let me show what goes into
the manifest. So the first half is the viewer

00:27:18.000 --> 00:27:23.969
manifest and the important attribute here,
the important tag is the attachment code.

00:27:23.969 --> 00:27:29.489
It's a new element we put in our manifest.
The attachment could tell us the wave that

00:27:29.489 --> 00:27:36.279
your extension is going to work with attachments.
And in this manifest, you tell it a name and

00:27:36.279 --> 00:27:43.429
you give it the address of the gadget since
that's all you need to install a viewer. Now

00:27:43.429 --> 00:27:52.080
for an importer you would use this manifest
at the bottom and the important thing you're

00:27:52.080 --> 00:27:59.249
looking for is the add participants action
that tell us wave that this extension will

00:27:59.249 --> 00:28:07.219
act as a participant in the wave. Now in this
tag you'll have a Participant ID and it, you

00:28:07.219 --> 00:28:15.739
give it the name of the robot. In this case,
it's a media-api@appspot.com and then you'll

00:28:15.739 --> 00:28:24.349
add the import-text to tell wave that this
extension is going to use the media API robot

00:28:24.349 --> 00:28:31.529
to import text. So as you saw in Jimin's code,
she has one robot that act both as an importer

00:28:31.529 --> 00:28:39.249
and exporter, in this manifest create a user
where that robot is acting on behalf of the

00:28:39.249 --> 00:28:48.220
import text user in that context. Okay, now
Seth will summarize.

00:28:48.220 --> 00:28:54.409
&gt;&gt; COVITZ: Thanks, Phil, and thanks, Jimin.
Just to summarize the detailed changes of

00:28:54.409 --> 00:29:00.029
what we've added to the robots and gadgets
APIs. Specifically for robots, we've added

00:29:00.029 --> 00:29:04.889
a new element, the attachment element with
the following properties. This element acts

00:29:04.889 --> 00:29:10.100
much like the other elements in wave. You
can insert them, replace them, append them,

00:29:10.100 --> 00:29:14.700
delete them, et cetera. The difference is
the data property because the data property

00:29:14.700 --> 00:29:19.639
actually holds a byte stream which is the
content of your attachment and that's how

00:29:19.639 --> 00:29:24.859
you can both create attachments and modify
attachments, so create a new attachments or

00:29:24.859 --> 00:29:31.219
delete them. For the Gadgets API, specifically
what we've added is this attachment URL state

00:29:31.219 --> 00:29:35.710
injection. That to be clear, this is sort
of the convention to the gadget to let it

00:29:35.710 --> 00:29:42.379
know I'm being used in the capacity of URL.
When the user clicks the Open With menu, selects

00:29:42.379 --> 00:29:47.789
the gadget that they want to view this content
with, we instantiate the gadget and inject

00:29:47.789 --> 00:29:52.049
that property in there. The gadget checks
for the existence of the property and then

00:29:52.049 --> 00:29:56.610
knows they can now fetch the attachment data
and render the attachment in line within the

00:29:56.610 --> 00:30:02.789
wave. And lastly, we added extensions for
import, export, and viewer. Look for those

00:30:02.789 --> 00:30:07.889
extensions to be more entirely integrated
into the user experience for uploading, downloading

00:30:07.889 --> 00:30:16.539
files in the future. With this, I just want
to again say that this is another step in

00:30:16.539 --> 00:30:22.379
terms of integration. The theme of Google
Wave at Google I/O, one of the themes is getting

00:30:22.379 --> 00:30:27.980
work done with groups of people and to help
that, you often need to integrate with other

00:30:27.980 --> 00:30:33.200
systems and we've showed you a number of ways
at the Enterprise Talk, these robots and gadgets

00:30:33.200 --> 00:30:38.330
to do that. In the federation talk to federated
with other systems. And here, with the media

00:30:38.330 --> 00:30:44.749
APIs to be able to actually both get data
content, binary data content into and out

00:30:44.749 --> 00:30:49.659
of wave for the purposes of importing into
wave and collaborating on and around it or

00:30:49.659 --> 00:30:55.429
for the purposes of synchronizing with other
systems that data and content. So we want

00:30:55.429 --> 00:31:03.419
to let, everyone go to code.google.com/apis/wave,
there's a new documentation there. There's

00:31:03.419 --> 00:31:08.399
also a new robot client libraries for Java
and Python that you can download and start

00:31:08.399 --> 00:31:16.039
playing with these APIs today. And with that,
we're going to switch over to the live wave

00:31:16.039 --> 00:31:20.549
and see what sort of questions we have. We'll
also take questions from the audience, if

00:31:20.549 --> 00:31:23.450
anybody wants to come up to the speaker and
ask questions.

00:31:23.450 --> 00:31:31.309
&gt;&gt; Hi, can I specify in gadget manifest to
the MIME type to which it applies of URL?

00:31:31.309 --> 00:31:37.179
&gt;&gt; COVITZ: So, the question was, can we apply
specific, have the gadget apply only just

00:31:37.179 --> 00:31:40.419
specific MIME types? That's not currently
implemented...

00:31:40.419 --> 00:31:42.099
&gt;&gt; Uh-hmm.
&gt;&gt; COVITZ: ...but that is coming soon. It

00:31:42.099 --> 00:31:46.789
is definitely our intent as the users will
have lots of gadget viewers and they'll have

00:31:46.789 --> 00:31:51.860
lots of import and export robots that it clearly
doesn't make sense for each robot to be able

00:31:51.860 --> 00:31:56.639
to apply to each type so we'd be able to narrow
it down for the types that only that robot

00:31:56.639 --> 00:32:01.450
or gadget is comfortable manipulating.
&gt;&gt; And what about MIME type assigning? So,

00:32:01.450 --> 00:32:07.009
for instance, I upload some, my preparatory
format, it has a known extension for Google

00:32:07.009 --> 00:32:14.769
Wave. How would I, what is, I think it will
application binary or something, so how will

00:32:14.769 --> 00:32:20.759
I, can I get the URL? Will it have the extension,
I mean, just windows extension or something?

00:32:20.759 --> 00:32:26.969
&gt;&gt; COVITZ: Right, for custom file, for file
types, we haven't really, we don't really

00:32:26.969 --> 00:32:30.229
have a solution for that yet, but we will
be working on that.

00:32:30.229 --> 00:32:32.859
&gt;&gt; Uh-hmm.
&gt;&gt; COVITZ: ...because we want to be able to

00:32:32.859 --> 00:32:38.580
detect the MIME type on our end. We also do
anti-virus checking to make sure that the

00:32:38.580 --> 00:32:43.149
content is safe to be included in the wave.
But for priority formats where we won't possibly

00:32:43.149 --> 00:32:47.489
be able to detect all the formats and we will
want to have a way for you to specify the

00:32:47.489 --> 00:32:52.059
formats so then your associated viewer and
other things can act on them.

00:32:52.059 --> 00:32:56.399
&gt;&gt; Well, at least, can I have, change the
extensional regex on name or something?

00:32:56.399 --> 00:32:59.669
&gt;&gt; COVITZ: Some of that works on a regex on
a name?

00:32:59.669 --> 00:33:02.659
&gt;&gt; Yeah.
&gt;&gt; COVITZ: That's a very good idea. I think

00:33:02.659 --> 00:33:04.460
we can look into that.
&gt;&gt; Okay, thank you.

00:33:04.460 --> 00:33:09.850
&gt;&gt; COVITZ: Next question.
&gt;&gt; I saw there are other two properties on

00:33:09.850 --> 00:33:13.929
the attachment element with attachment URL
and data. And I don't think I quite got the

00:33:13.929 --> 00:33:24.139
section [INDISTINCT]. Is that, are those two
different options for the same, kind of thing,

00:33:24.139 --> 00:33:26.970
is that like, given source and data URI syntax
sort of thing so can either embed it directly

00:33:26.970 --> 00:33:30.959
or have for or do URL?
&gt;&gt; COVITZ: Do you want to answer that?

00:33:30.959 --> 00:33:36.719
&gt;&gt; LI: I can't quite get your question, can
you repeat that part?

00:33:36.719 --> 00:33:40.440
&gt;&gt; Are the data properties in the attachment
URL properties on the...

00:33:40.440 --> 00:33:45.799
&gt;&gt; LI: Oh yeah, so, is your question is about
what's the difference between data property

00:33:45.799 --> 00:33:47.529
and the attachment URL property?
&gt;&gt; Yeah.

00:33:47.529 --> 00:33:57.339
&gt;&gt; LI: So attachment URL is just a regular
URL or a string like any other URL. So with

00:33:57.339 --> 00:34:04.089
this URL, you can use URL fetch here to gather
data. And the attachment to data is that real

00:34:04.089 --> 00:34:09.919
attachment of data in a binary array.
&gt;&gt; COVITZ: So to go, to add it more to a Jimin's

00:34:09.919 --> 00:34:14.770
answer, they both refer to the same thing.
So you have the URL and you can then go fetch

00:34:14.770 --> 00:34:20.629
the content yourself or you can say get data
and it will fetch the content for you. So,

00:34:20.629 --> 00:34:25.079
in some cases you may want your robot to process
the data right there in which case you might

00:34:25.079 --> 00:34:29.809
just say get data. In other cases you may
want to send the URL off to another server

00:34:29.809 --> 00:34:33.750
that you own and have that process the data
and return it back. So, in that case, you

00:34:33.750 --> 00:34:35.709
might just want to send the URL and not the
data itself.

00:34:35.709 --> 00:34:40.579
&gt;&gt; Okay, so if attachment URL is not empty
then the data property should be identical

00:34:40.579 --> 00:34:44.240
to the content at the URL?
&gt;&gt; COVITZ: Exactly.

00:34:44.240 --> 00:34:50.370
&gt;&gt; Okay, thank you.
&gt;&gt; COVITZ: Question?

00:34:50.370 --> 00:34:56.220
&gt;&gt; Yes, when you do a replace on a attachment,
do you get a different URL?

00:34:56.220 --> 00:34:59.740
&gt;&gt; COVITZ: When you do a, when you replace
an attachment within the wave, do you get

00:34:59.740 --> 00:35:02.140
a new URL?
&gt;&gt; Yeah, do you get a new URL or, and does

00:35:02.140 --> 00:35:07.470
the old one still viable?
&gt;&gt; COVITZ: Yes. So, in wave, attachments are

00:35:07.470 --> 00:35:11.680
immutable which means when you change the
attachment, you're actually making a new attachment.

00:35:11.680 --> 00:35:17.299
And the attachments, the old attachment remains
for the purposes of playback. So you can always

00:35:17.299 --> 00:35:20.561
go back to playback in history and you want
to see the attachment at that state in the

00:35:20.561 --> 00:35:29.800
past, so yes. Wherever you create a new attachment,
you will get a new URL or if you replace one.

00:35:29.800 --> 00:35:31.250
&gt;&gt; Have a new ID?
&gt;&gt; COVITZ: Yes.

00:35:31.250 --> 00:35:34.190
&gt;&gt; LI: Yes.
&gt;&gt; COVITZ: You'll have a new ID.

00:35:34.190 --> 00:35:38.029
&gt;&gt; So if [INDISTINCT], there's no way to [INDISTINCT]?
&gt;&gt; COVITZ: The question again?

00:35:38.029 --> 00:35:46.940
&gt;&gt; [INDISTINCT] there's no way [INDISTINCT]?
&gt;&gt; COVITZ: So the question was if a robot

00:35:46.940 --> 00:35:52.500
updates in attachment, how to link the two
together? So, currently, there wouldn't be

00:35:52.500 --> 00:35:57.529
linked other than the history of the playback.
So your robot would have to keep track of

00:35:57.529 --> 00:36:04.230
the [INDISTINCT] of the attachment IDs itself.
Question?

00:36:04.230 --> 00:36:16.900
&gt;&gt; If you add more than one attachment files,
the attachment to URL, does attachment to

00:36:16.900 --> 00:36:21.420
URL returns array of URLs?
&gt;&gt; COVITZ: For the robot?

00:36:21.420 --> 00:36:26.800
&gt;&gt; I mean, we can add more than one attachment
file to it.

00:36:26.800 --> 00:36:29.520
&gt;&gt; COVITZ: Yes, you can attach as many attachments
as you like.

00:36:29.520 --> 00:36:37.440
&gt;&gt; Yeah? So, but, the key for attachment is
just attachment URL.

00:36:37.440 --> 00:36:40.250
&gt;&gt; COVITZ: The key is the attachment ID?
&gt;&gt; Behind.

00:36:40.250 --> 00:36:48.680
&gt;&gt; COVITZ: Or the attachment URL, yes.
&gt;&gt; So, how should I handle more than one attachment

00:36:48.680 --> 00:36:51.500
files?
&gt;&gt; COVITZ: So, the question was how to add

00:36:51.500 --> 00:36:57.089
more than one attachment? So in the API example
that Jimin showed, you could create a new

00:36:57.089 --> 00:37:00.990
attachment element and then you can insert
it anywhere within the wave. So if you want

00:37:00.990 --> 00:37:05.220
to attach more than one thing, you just create
more than one element and insert them in series

00:37:05.220 --> 00:37:09.820
or in multiple blips or in the same blip or
whatever you would like.

00:37:09.820 --> 00:37:14.240
&gt;&gt; Okay, thank you.
&gt;&gt; COVITZ: I'll take a question from the [INDISTINCT],

00:37:14.240 --> 00:37:19.970
what kind of limits can we expect for attachment
size, number of types embeddability? So in

00:37:19.970 --> 00:37:27.820
terms of size, the current size for an attachment
in wave is 20 megabytes, and as we continue

00:37:27.820 --> 00:37:32.440
to work with this, we may look to expand that
but that's the current limit. In terms of

00:37:32.440 --> 00:37:38.109
number, you can add as many attachments as
you like until you fill the user quota, a

00:37:38.109 --> 00:37:45.390
user's quota. We do attachment duplication
detection on the backend. So if you attach

00:37:45.390 --> 00:37:49.720
the same attachment in multiple times in separate
ways, you won't, that won't be charge against

00:37:49.720 --> 00:37:55.990
your quota, but eventually, you will run out
of quota if you attach a large number of objects.

00:37:55.990 --> 00:38:01.630
In terms of type as we have said before, you
can attach literally any type at all. Embeddability,

00:38:01.630 --> 00:38:06.740
I'm not quite sure with that means. But the
attachments can be embedded in the wave so

00:38:06.740 --> 00:38:10.720
you can see them. And of course with the viewers,
you can actually view them as embedded objects

00:38:10.720 --> 00:38:16.550
in the wave. I guess, that answers that question.
Audience question?

00:38:16.550 --> 00:38:24.589
&gt;&gt; Yes, since waves are essentially XML documents,
right? So this is the data base64 encoded

00:38:24.589 --> 00:38:33.079
or how exactly is that included there?
&gt;&gt; COVITZ: So, data in wave is XML. The data

00:38:33.079 --> 00:38:39.190
for the attachment is stored in binary, in
our backend servers. In terms of fetching

00:38:39.190 --> 00:38:45.750
the data, it does HTTPget back to our servers
to fetch the binary data into the robot so

00:38:45.750 --> 00:38:49.660
it's not base64 encoded when you have it,
when you add it.

00:38:49.660 --> 00:38:59.859
&gt;&gt; So that data property of the attachment
element is not sent with the wave it's retrieve

00:38:59.859 --> 00:39:03.160
on what, when needed?
&gt;&gt; COVITZ: That's correct, that's correct.

00:39:03.160 --> 00:39:06.079
&gt;&gt; Okay.
&gt;&gt; COVITZ: Now, when the attachment is created,

00:39:06.079 --> 00:39:13.170
it is actually encoded in base64 and return
back and the response to the event when it

00:39:13.170 --> 00:39:22.670
was created. So we do pass it in that operation
and the JSON back to our server. But when

00:39:22.670 --> 00:39:27.619
it's fetched, so in the read case, it's pulled
directly from the server as binary.

00:39:27.619 --> 00:39:32.990
&gt;&gt; Okay, so there's a separate request for
each attachment in addition to the...

00:39:32.990 --> 00:39:33.990
&gt;&gt; COVITZ: Right.
&gt;&gt; ...initial. Okay.

00:39:33.990 --> 00:39:37.380
&gt;&gt; COVITZ: Right, as you may have heard with
robots, you can specify which data and how

00:39:37.380 --> 00:39:43.119
much data you want to pulled down in response
to an event. And we didn't feel that users

00:39:43.119 --> 00:39:47.910
would want bandwidth soaked up with large
attachments coming down in response to every

00:39:47.910 --> 00:39:54.180
event so that's why we go and fetch the attachments
only on demands when the APIs is called.

00:39:54.180 --> 00:40:01.150
&gt;&gt; Okay, so are the attachments separate,
in a sort of separate file or stored from

00:40:01.150 --> 00:40:03.089
the wave...
&gt;&gt; COVITZ: That's correct.

00:40:03.089 --> 00:40:04.530
&gt;&gt; ...wavelets and...?
&gt;&gt; COVITZ: That's correct.

00:40:04.530 --> 00:40:09.400
&gt;&gt; All right, thank you.
&gt;&gt; COVITZ: And there's one more question here

00:40:09.400 --> 00:40:15.009
on the [INDISTINCT] on the moderator which
is can we use that in-browser datastore for

00:40:15.009 --> 00:40:24.000
large media files? So we do use that in-browser
datastore. We currently use gears to buffer

00:40:24.000 --> 00:40:28.700
some of the files as they're being uploaded.
We're not currently using the datastore for

00:40:28.700 --> 00:40:32.500
files that are downloaded but it's something
that we've talked about and also we're looking

00:40:32.500 --> 00:40:39.109
HTML5 to be able to cache more of those files
on the client to improve performance of paging

00:40:39.109 --> 00:40:46.119
and looking at large numbers of images in
attachments and things like that. Are there

00:40:46.119 --> 00:40:51.840
any more questions? Well, with that, we want
to take everyone for staying for our talk.

00:40:51.840 --> 00:40:57.030
We really appreciate it. We hope you all tryout
these APIs and make some really great and

00:40:57.030 --> 00:40:58.660
exciting things. Thank you very much.

