WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.768
[MUSIC PLAYING]

00:00:03.422 --> 00:00:04.880
BRETT MCGOWEN: All
right, everyone.

00:00:04.880 --> 00:00:05.630
Thanks for coming out.

00:00:05.630 --> 00:00:06.921
Let's go ahead and get started.

00:00:06.921 --> 00:00:08.150
My name is Brett McGowen.

00:00:08.150 --> 00:00:11.770
And I'm a developer advocate
at Google for the Google Cloud

00:00:11.770 --> 00:00:13.060
Platform.

00:00:13.060 --> 00:00:16.770
You can follow me here
on Twitter @brettmcg.

00:00:16.770 --> 00:00:18.284
So a little bit
more about myself.

00:00:18.284 --> 00:00:20.200
Like I said, I'm a
developer advocate focusing

00:00:20.200 --> 00:00:21.960
on the Google Cloud platform.

00:00:21.960 --> 00:00:24.230
I work in the New
York City office.

00:00:24.230 --> 00:00:27.500
But I do have to say even
though I live in New York,

00:00:27.500 --> 00:00:29.411
I'm from Texas.

00:00:29.411 --> 00:00:32.240
AUDIENCE: Yee haw!

00:00:32.240 --> 00:00:34.190
BRETT MCGOWEN: Yes, much better.

00:00:34.190 --> 00:00:34.730
Yes.

00:00:34.730 --> 00:00:36.795
How do you know if
someone is from Texas?

00:00:36.795 --> 00:00:37.920
AUDIENCE: They'll tell you.

00:00:37.920 --> 00:00:39.045
BRETT MCGOWEN: Don't worry.

00:00:39.045 --> 00:00:41.730
They'll tell you.

00:00:41.730 --> 00:00:43.050
All right.

00:00:43.050 --> 00:00:44.870
So I'm going talk
about Cloud Spin today.

00:00:44.870 --> 00:00:46.940
And Cloud Spin is
this demo that's

00:00:46.940 --> 00:00:49.940
over here to my
left that is set up

00:00:49.940 --> 00:00:52.010
to show off some
of the technology

00:00:52.010 --> 00:00:53.950
that we have in the
Google Cloud platform.

00:00:53.950 --> 00:00:57.256
And we thought it would be
pretty cool, instead of just

00:00:57.256 --> 00:00:58.630
walking through
a bunch of slides

00:00:58.630 --> 00:01:00.510
and showing off a bunch of
the features that we have.

00:01:00.510 --> 00:01:01.910
What if we actually
built something?

00:01:01.910 --> 00:01:03.368
And then I'll walk
you through what

00:01:03.368 --> 00:01:06.610
we built, why we chose
what we did as we built it.

00:01:06.610 --> 00:01:09.130
And hopefully you can take that
away into your own projects

00:01:09.130 --> 00:01:10.838
and understand maybe
how you can leverage

00:01:10.838 --> 00:01:13.660
the power of the Google Cloud
platform in your own work.

00:01:13.660 --> 00:01:15.180
So this is my chance.

00:01:15.180 --> 00:01:17.930
This is my chance for
fake fame and fake glory.

00:01:17.930 --> 00:01:21.390
I got to be a fake
CEO for three weeks.

00:01:21.390 --> 00:01:23.009
I always wanted to be a CEO.

00:01:23.009 --> 00:01:24.800
And now, I could sell
a product that no one

00:01:24.800 --> 00:01:28.180
would pay for that's
going absolutely nowhere.

00:01:28.180 --> 00:01:30.250
So it's not a real
product from Google.

00:01:30.250 --> 00:01:31.300
This is just a tech demo.

00:01:31.300 --> 00:01:34.610
It's a fun thing to show off
and give material for this talk.

00:01:34.610 --> 00:01:37.382
So it's not going to get
released in the Play store.

00:01:37.382 --> 00:01:38.590
We're not going to charge it.

00:01:38.590 --> 00:01:41.990
But that was a story I wanted
to tell, like we're a startup.

00:01:41.990 --> 00:01:43.950
And we wanted to
approach it that way.

00:01:43.950 --> 00:01:45.010
This is for real.

00:01:45.010 --> 00:01:48.370
We want to think about
costs like a startup would.

00:01:48.370 --> 00:01:51.420
We want to think about time
to market like a startup would

00:01:51.420 --> 00:01:52.980
and really, like
a developer would.

00:01:52.980 --> 00:01:54.790
You want to spend your
time writing code.

00:01:54.790 --> 00:01:57.420
You don't want to spend your
time managing infrastructure,

00:01:57.420 --> 00:01:59.420
orchestrating things
like from a cloud

00:01:59.420 --> 00:02:02.504
perspective, virtual
machines, things like that.

00:02:02.504 --> 00:02:03.420
So we had three weeks.

00:02:03.420 --> 00:02:04.836
We were specifically
building this

00:02:04.836 --> 00:02:07.271
for a series of events
called GCP Next, which

00:02:07.271 --> 00:02:08.979
we did in a bunch of
cities around the US

00:02:08.979 --> 00:02:10.060
and around the world.

00:02:10.060 --> 00:02:12.840
We wanted a fun demo to show
off, make it interactive,

00:02:12.840 --> 00:02:15.210
and help teach people
about the cloud.

00:02:15.210 --> 00:02:17.322
So we thought, all
right, this is the market

00:02:17.322 --> 00:02:18.280
we're going to disrupt.

00:02:18.280 --> 00:02:19.770
It's photo booths.

00:02:19.770 --> 00:02:21.390
So instead of a
photo booth you guys

00:02:21.390 --> 00:02:22.920
have seen probably in the mall.

00:02:22.920 --> 00:02:26.120
They have them at bar mitzvahs
and birthdays and weddings.

00:02:26.120 --> 00:02:28.940
You get in this photo booth, and
you-- no, you and your friend

00:02:28.940 --> 00:02:32.020
get in this photo-- no, you
and your five or six friends

00:02:32.020 --> 00:02:33.760
cram in this tiny photo booth.

00:02:33.760 --> 00:02:36.740
And you're all wearing a
Viking and giant sunglasses

00:02:36.740 --> 00:02:38.340
and a big feather boa.

00:02:38.340 --> 00:02:40.900
And then it counts down--
one, two, three, click.

00:02:40.900 --> 00:02:42.630
One, two, three, click.

00:02:42.630 --> 00:02:43.890
One, two, three, click.

00:02:43.890 --> 00:02:46.060
And then it prints out that
little strip of photos.

00:02:46.060 --> 00:02:47.160
You guys know what
I'm talking about?

00:02:47.160 --> 00:02:47.930
So that was our dream.

00:02:47.930 --> 00:02:50.180
We're going to revolutionize
the photo booth industry.

00:02:50.180 --> 00:02:53.340
And we're going to make
something worthy of 2016,

00:02:53.340 --> 00:02:56.156
a 3D, floating,
spinning photo booth.

00:02:56.156 --> 00:02:57.030
So this is our dream.

00:02:57.030 --> 00:02:59.150
And we call it Cloud Spin.

00:02:59.150 --> 00:03:01.600
So first, we had to get
to designing Cloud Spin.

00:03:01.600 --> 00:03:03.320
So this is our
engineering diagram.

00:03:03.320 --> 00:03:06.460
You can tell it's an engineering
diagram because it has numbers.

00:03:06.460 --> 00:03:09.090
For example, I had to remember
what on Earth a radius was when

00:03:09.090 --> 00:03:10.340
we were putting this together.

00:03:10.340 --> 00:03:12.120
So this outlays how it works.

00:03:12.120 --> 00:03:13.540
We've got 19 Nexus 6 phones.

00:03:13.540 --> 00:03:15.290
It's 180 degrees.

00:03:15.290 --> 00:03:18.000
One phone every 10 degrees.

00:03:18.000 --> 00:03:18.710
So we took this.

00:03:18.710 --> 00:03:19.570
We sent it to marketing.

00:03:19.570 --> 00:03:20.580
And we said, all
right, this is what

00:03:20.580 --> 00:03:21.810
we want to do for our demo.

00:03:21.810 --> 00:03:24.550
They said, OK, we've
made a few minor changes.

00:03:24.550 --> 00:03:25.530
Looks very different.

00:03:25.530 --> 00:03:26.980
You can see there is
no numbers on this.

00:03:26.980 --> 00:03:28.854
That's because this is
the marketing diagram.

00:03:28.854 --> 00:03:30.320
This is the engineering diagram.

00:03:30.320 --> 00:03:31.970
This is the marketing diagram.

00:03:31.970 --> 00:03:34.060
This is the engineering diagram.

00:03:34.060 --> 00:03:36.410
I worked on this one.

00:03:36.410 --> 00:03:38.850
But you can see in
the end who won.

00:03:38.850 --> 00:03:40.820
Clearly, marketing won
because it looks exactly

00:03:40.820 --> 00:03:42.025
like the diagram they gave.

00:03:42.025 --> 00:03:43.900
This the first time I've
ever given this talk

00:03:43.900 --> 00:03:46.550
where I actually had a picture
of it right next to it.

00:03:46.550 --> 00:03:49.075
So it's an inception
moment right now.

00:03:49.075 --> 00:03:49.950
So don't be confused.

00:03:49.950 --> 00:03:51.050
That's the real one over there.

00:03:51.050 --> 00:03:52.091
This is just for display.

00:03:54.600 --> 00:03:55.790
So this was our goal.

00:03:55.790 --> 00:03:56.914
This was the final product.

00:03:56.914 --> 00:03:58.980
But let me talk you
through how we got there.

00:03:58.980 --> 00:04:01.340
So how does this
work, conceptually?

00:04:01.340 --> 00:04:03.470
So the first thing
that happens is

00:04:03.470 --> 00:04:06.040
the user gets in the center
of the phones in the cameras.

00:04:06.040 --> 00:04:08.130
They jump up, and then
they all take a picture

00:04:08.130 --> 00:04:10.475
at the exact same second.

00:04:10.475 --> 00:04:12.850
And then we stitch it together,
and we make that animated

00:04:12.850 --> 00:04:13.970
graphic that you saw.

00:04:13.970 --> 00:04:15.540
So sounds super-easy, right?

00:04:15.540 --> 00:04:16.852
It's a very short talk.

00:04:16.852 --> 00:04:18.060
Actually, it's pretty tricky.

00:04:18.060 --> 00:04:19.940
And we ran into a lot of
problems along the way.

00:04:19.940 --> 00:04:21.398
But let me talk
about what are some

00:04:21.398 --> 00:04:24.610
of the things we were trying to
solve, some problems to solve.

00:04:24.610 --> 00:04:27.130
One is literally just
how do you take a picture

00:04:27.130 --> 00:04:30.570
at the exact same second
across all these phones?

00:04:30.570 --> 00:04:32.890
That sounds easy.

00:04:32.890 --> 00:04:35.530
But we'll talk about some of
the challenges you ran into.

00:04:35.530 --> 00:04:37.113
What are some of the
other challenges?

00:04:37.113 --> 00:04:39.590
Just coordinating all the
phones together, just 20 things.

00:04:39.590 --> 00:04:41.048
That's a lot of
data to move around

00:04:41.048 --> 00:04:42.460
to worry about synchronizing.

00:04:42.460 --> 00:04:44.970
The app needs to
report, am I my crashed?

00:04:44.970 --> 00:04:45.660
Am I working?

00:04:45.660 --> 00:04:46.660
Am I uploading?

00:04:46.660 --> 00:04:47.770
Am I on Wi-Fi?

00:04:47.770 --> 00:04:49.140
What is my status?

00:04:49.140 --> 00:04:51.480
So that's another thing
we have to worry about.

00:04:51.480 --> 00:04:54.652
File storage-- we had to
put these videos somewhere.

00:04:54.652 --> 00:04:56.110
We had to put the
images somewhere.

00:04:56.110 --> 00:04:58.200
We have to do
something with that.

00:04:58.200 --> 00:05:00.800
Scale-- so in our
fake start up world,

00:05:00.800 --> 00:05:02.940
we're going to be
unbelievably successful.

00:05:02.940 --> 00:05:05.760
We're going to be in bars
across-- bars-- well,

00:05:05.760 --> 00:05:09.970
maybe some bars-- I'm thinking
about the after party.

00:05:09.970 --> 00:05:12.376
They're going to be in
malls across the country

00:05:12.376 --> 00:05:13.250
and the world, right?

00:05:13.250 --> 00:05:14.919
So we've got to scale up.

00:05:14.919 --> 00:05:16.960
Another thing we think
about is image processing.

00:05:16.960 --> 00:05:19.040
How do we actually
process all these images?

00:05:19.040 --> 00:05:20.240
Where do we do that?

00:05:20.240 --> 00:05:21.100
How does that work?

00:05:21.100 --> 00:05:22.964
And how does that tie
into everything else?

00:05:22.964 --> 00:05:24.630
We need to think about
controlling cost,

00:05:24.630 --> 00:05:26.161
like as a startup.

00:05:26.161 --> 00:05:27.910
We don't have unlimited
funds to run this.

00:05:27.910 --> 00:05:30.460
So we have to think,
how can we run

00:05:30.460 --> 00:05:32.609
as minimal resources
as possible while

00:05:32.609 --> 00:05:34.650
still being able to scale
up when this inevitably

00:05:34.650 --> 00:05:37.007
becomes wildly successful?

00:05:37.007 --> 00:05:38.840
What if we want to
create multiple versions?

00:05:38.840 --> 00:05:41.480
So right now, this one just
has kind of one version where

00:05:41.480 --> 00:05:42.715
they're frozen in the air.

00:05:42.715 --> 00:05:44.090
And I'll show you
some variations

00:05:44.090 --> 00:05:45.090
maybe that we could do.

00:05:45.090 --> 00:05:47.381
So we had to think about how
do we architect our system

00:05:47.381 --> 00:05:48.650
to make that happen?

00:05:48.650 --> 00:05:50.900
And then just debugging and
logging, not that anything

00:05:50.900 --> 00:05:52.530
has ever gone wrong in
the history of software.

00:05:52.530 --> 00:05:55.300
But if something goofs up and
something is down or something

00:05:55.300 --> 00:05:58.300
crashes, how do we find
out the state of things?

00:05:58.300 --> 00:06:00.620
And then how do we fix it?

00:06:00.620 --> 00:06:02.280
All right, so taking the photos.

00:06:02.280 --> 00:06:04.550
So this is how do
we get 19 cameras

00:06:04.550 --> 00:06:06.880
to take a photo all
at the exact second?

00:06:06.880 --> 00:06:09.200
Any ideas?

00:06:09.200 --> 00:06:10.976
Yes?

00:06:10.976 --> 00:06:13.863
AUDIENCE: You tell them all
to take it at a certain time

00:06:13.863 --> 00:06:15.140
according to a clock.

00:06:15.140 --> 00:06:16.800
BRETT MCGOWEN: Yes,
so you tell them

00:06:16.800 --> 00:06:20.100
everyone take a photo at
this exact time, right?

00:06:20.100 --> 00:06:24.410
And you can even give it an epic
time stamp to the millisecond,

00:06:24.410 --> 00:06:26.450
and tell them all to do that.

00:06:26.450 --> 00:06:27.690
But here's the catch.

00:06:27.690 --> 00:06:29.610
They're all slightly off.

00:06:29.610 --> 00:06:32.490
So if you look at
the time, they all

00:06:32.490 --> 00:06:33.710
seem to be on the same time.

00:06:33.710 --> 00:06:35.180
But actually, when you
get down to that level,

00:06:35.180 --> 00:06:36.679
even if they're all
in network time,

00:06:36.679 --> 00:06:38.380
there's a little
bit of variance.

00:06:38.380 --> 00:06:41.090
And so we have to get
within 20 milliseconds.

00:06:41.090 --> 00:06:43.816
Otherwise, this one will
have me at this position.

00:06:43.816 --> 00:06:45.440
But the next one,
I'll be falling down.

00:06:45.440 --> 00:06:47.064
And the next one,
I'll be falling down.

00:06:47.064 --> 00:06:49.340
But then the third
one took earlier.

00:06:49.340 --> 00:06:52.189
So it's a very jagged effect,
so within 20 milliseconds.

00:06:52.189 --> 00:06:53.730
But that was the
first thing we tried

00:06:53.730 --> 00:06:56.390
was just using time and
sending it to all of them.

00:06:56.390 --> 00:06:58.710
Any other ideas how
we could do that?

00:06:58.710 --> 00:06:59.650
Yeah?

00:06:59.650 --> 00:07:01.060
AUDIENCE: Video frames.

00:07:01.060 --> 00:07:02.850
BRETT MCGOWEN: So
video frames, OK.

00:07:02.850 --> 00:07:04.605
So what do you mean?

00:07:04.605 --> 00:07:09.131
AUDIENCE: Take a piece of
video and try to match up

00:07:09.131 --> 00:07:10.430
the frames together.

00:07:10.430 --> 00:07:13.020
BRETT MCGOWEN: Yeah, so
this is a good idea-- video,

00:07:13.020 --> 00:07:14.270
and then try to match them up.

00:07:14.270 --> 00:07:16.380
Any other ideas?

00:07:16.380 --> 00:07:19.138
Yeah.

00:07:19.138 --> 00:07:21.349
AUDIENCE: [INAUDIBLE].

00:07:21.349 --> 00:07:22.390
BRETT MCGOWEN: I'm sorry.

00:07:22.390 --> 00:07:23.486
Send a what signal?

00:07:23.486 --> 00:07:24.402
AUDIENCE: [INAUDIBLE].

00:07:26.305 --> 00:07:28.680
BRETT MCGOWEN: OK, so you can
send a push signal and say,

00:07:28.680 --> 00:07:29.820
take it now.

00:07:29.820 --> 00:07:30.760
We also tried that.

00:07:30.760 --> 00:07:32.470
And we tried it with a product
called Firebase, which I'll

00:07:32.470 --> 00:07:33.760
talk about in a little bit.

00:07:33.760 --> 00:07:36.970
The problem with that is even
super-fast response times,

00:07:36.970 --> 00:07:40.400
just random internet network
traffic, even if they're

00:07:40.400 --> 00:07:43.720
all in the same local
network, is enough variance

00:07:43.720 --> 00:07:45.580
that you run into the
jagged frame of effect

00:07:45.580 --> 00:07:48.020
where they're not taking it
all at the exact same time.

00:07:48.020 --> 00:07:52.164
So what we ended up
doing is-- oh yeah.

00:07:52.164 --> 00:07:53.830
Here's one of the
things I talked about.

00:07:53.830 --> 00:07:56.330
So we need to
coordinate 19 phones.

00:07:56.330 --> 00:07:58.660
So an issue that we
ran into is that even

00:07:58.660 --> 00:08:00.530
if we had some magic
technology that

00:08:00.530 --> 00:08:02.110
could send a command
to every phone

00:08:02.110 --> 00:08:05.360
at the exact same nanosecond--
take a photo-- they all

00:08:05.360 --> 00:08:08.310
got the command at the exact
same trillionth of a second

00:08:08.310 --> 00:08:10.900
in time-- there's
a random hardware

00:08:10.900 --> 00:08:13.110
delay that we can't control.

00:08:13.110 --> 00:08:17.510
And that is actually varied
enough to disrupt our video.

00:08:17.510 --> 00:08:19.600
So that was a huge problem.

00:08:19.600 --> 00:08:22.492
So any kind of
time-based solution

00:08:22.492 --> 00:08:24.200
was basically off the
table at that point

00:08:24.200 --> 00:08:25.616
because even if
in a perfect world

00:08:25.616 --> 00:08:28.330
we could get them to
coordinate, we'd say now.

00:08:28.330 --> 00:08:30.100
So camera 1 would
take it instantly.

00:08:30.100 --> 00:08:33.780
Camera 2 would take it
ah, now, even if they

00:08:33.780 --> 00:08:35.049
got it the exact same second.

00:08:35.049 --> 00:08:37.850
So that was really
difficult to deal with.

00:08:37.850 --> 00:08:42.500
So what we ended up
doing is taking a video.

00:08:42.500 --> 00:08:43.809
So this is my coworker Ray.

00:08:43.809 --> 00:08:45.800
He worked with me
on this project.

00:08:45.800 --> 00:08:47.320
He was actually
giving this talk.

00:08:47.320 --> 00:08:51.690
And I snuck this video
in without him knowing.

00:08:51.690 --> 00:08:53.190
And he almost
murdered me afterwards

00:08:53.190 --> 00:08:55.130
because he was like,
I can't believe

00:08:55.130 --> 00:08:56.770
I had to give this
talk with me jumping

00:08:56.770 --> 00:08:58.780
like an idiot for a minute.

00:08:58.780 --> 00:09:01.790
So ever since then, I've made
sure to put it in every talk

00:09:01.790 --> 00:09:04.540
because it just
makes me so happy.

00:09:04.540 --> 00:09:05.360
So this is it.

00:09:05.360 --> 00:09:08.692
Basically, this is an animated
GIF of him jumping up and down.

00:09:08.692 --> 00:09:09.400
And it's a video.

00:09:09.400 --> 00:09:12.410
So a video is essentially like
a burst mode-- frame, frame,

00:09:12.410 --> 00:09:13.919
frame, frame, frame.

00:09:13.919 --> 00:09:16.210
So if you get enough cameras
doing frame, frame, frame,

00:09:16.210 --> 00:09:21.170
frame, frame, frame, inevitably
some frame on each camera

00:09:21.170 --> 00:09:22.585
will be the same moment in time.

00:09:22.585 --> 00:09:24.960
So then we have to come up
with a problem like, how do we

00:09:24.960 --> 00:09:28.740
know which frame will match up?

00:09:28.740 --> 00:09:29.990
How do we identify the frames?

00:09:29.990 --> 00:09:31.573
There's a few ways
we wanted to do it.

00:09:31.573 --> 00:09:32.650
One was flash.

00:09:32.650 --> 00:09:35.292
So we could maybe have
like a bright flash.

00:09:35.292 --> 00:09:36.750
And then we could
analyze the video

00:09:36.750 --> 00:09:39.210
and we could say, oh,
which frame is slightly

00:09:39.210 --> 00:09:40.900
brighter than the others?

00:09:40.900 --> 00:09:42.660
And then once we found
that bright frame,

00:09:42.660 --> 00:09:44.660
we know that that's
the same moment

00:09:44.660 --> 00:09:47.120
in time across all the cameras.

00:09:47.120 --> 00:09:50.620
But that was hard too because
there's very different lighting

00:09:50.620 --> 00:09:52.140
environments that we were in.

00:09:52.140 --> 00:09:53.720
Some places are super-bright.

00:09:53.720 --> 00:09:57.180
And we'd have to get a crazy
bright flash to make it work.

00:09:57.180 --> 00:10:02.220
Also, it was hard for
us to get a flash that

00:10:02.220 --> 00:10:04.240
sat nicely in one frame.

00:10:04.240 --> 00:10:06.640
So sometimes it would kind of
bleed over into two frames.

00:10:06.640 --> 00:10:07.620
And then it started
getting wonky

00:10:07.620 --> 00:10:09.430
because this one's a
little bit brighter.

00:10:09.430 --> 00:10:10.930
And this one is a
little bit darker.

00:10:10.930 --> 00:10:12.530
So it was a little bit tricky.

00:10:12.530 --> 00:10:15.420
I tried using timestamp,
maybe like an NTP server

00:10:15.420 --> 00:10:19.080
so they could all say, I know
my offset is slightly different.

00:10:19.080 --> 00:10:21.250
And if I'm picking this
time from the server that

00:10:21.250 --> 00:10:25.400
says, use frame 0 plus
2 seconds or whatever,

00:10:25.400 --> 00:10:26.585
it could find it that way.

00:10:26.585 --> 00:10:27.960
But that turned
out to be tricky.

00:10:27.960 --> 00:10:29.650
Like I said, we only
had three weeks.

00:10:29.650 --> 00:10:31.830
So what we went is
with an audio marker.

00:10:31.830 --> 00:10:34.600
So you guys have seen
in old-timey movies--

00:10:34.600 --> 00:10:37.560
not even old-timey, current
time, the clapboard, right?

00:10:37.560 --> 00:10:39.250
So if a scene is
about to happen,

00:10:39.250 --> 00:10:43.970
they say Cloud Spin--
the Movie, take 76, clap.

00:10:43.970 --> 00:10:44.470
Right?

00:10:44.470 --> 00:10:46.067
And it's got a timestamp on it.

00:10:46.067 --> 00:10:48.400
And they use that so that all
the different cameras that

00:10:48.400 --> 00:10:51.050
are pointed at the same moment
can sync up their audio.

00:10:51.050 --> 00:10:55.960
So essentially, we took
that idea and used that.

00:10:55.960 --> 00:10:58.080
We immediately ran into a
few issues, one of which

00:10:58.080 --> 00:11:02.050
is-- did anyone have an Android
and iPhone back in the day?

00:11:02.050 --> 00:11:03.820
And you would have
the headphones

00:11:03.820 --> 00:11:05.050
that had the little mic.

00:11:05.050 --> 00:11:07.070
And it worked on iPhone,
but not on Android.

00:11:07.070 --> 00:11:08.470
And it worked on Android,
but not on iPhone.

00:11:08.470 --> 00:11:10.011
You guys know what
I'm talking about?

00:11:10.011 --> 00:11:12.820
It works now, but
back then it didn't.

00:11:12.820 --> 00:11:15.535
So it turns out there's two
different standards in case

00:11:15.535 --> 00:11:16.160
you're curious.

00:11:16.160 --> 00:11:18.460
The one of the left is
created by, I think,

00:11:18.460 --> 00:11:20.260
Nokia back in the day.

00:11:20.260 --> 00:11:22.290
And so it's got these bands.

00:11:22.290 --> 00:11:24.650
So the left signal,
right signal, microphone,

00:11:24.650 --> 00:11:26.440
and the ground.

00:11:26.440 --> 00:11:31.350
So then when the iPhone
came out, Apple innovated.

00:11:31.350 --> 00:11:34.650
And they switched
the bottom two.

00:11:34.650 --> 00:11:37.110
I don't know why, but they did.

00:11:37.110 --> 00:11:39.092
So that caused us
no end of headache.

00:11:39.092 --> 00:11:40.300
So we had to figure that out.

00:11:40.300 --> 00:11:43.500
And I just thought that
was an amusing thing.

00:11:43.500 --> 00:11:45.580
So we said, how do we
get this audio signal

00:11:45.580 --> 00:11:47.460
into all of these phones?

00:11:47.460 --> 00:11:49.520
So I went to one
of my coworkers.

00:11:49.520 --> 00:11:51.160
And he was like,
Brett, I got it.

00:11:51.160 --> 00:11:52.410
So he goes to the white board.

00:11:52.410 --> 00:11:53.760
He's frantically drawing on it.

00:11:53.760 --> 00:11:54.690
He draws this crazy scheme.

00:11:54.690 --> 00:11:55.540
He says, come check it out.

00:11:55.540 --> 00:11:58.206
I've got the solution for how to
split the audio signal into all

00:11:58.206 --> 00:11:59.790
those cameras, into
all those phones.

00:11:59.790 --> 00:12:02.350
And I walk and I said, what?

00:12:02.350 --> 00:12:03.690
I have no idea what this is.

00:12:03.690 --> 00:12:06.420
I'm not an audio engineer.

00:12:06.420 --> 00:12:07.880
Can you explain this to me?

00:12:07.880 --> 00:12:09.630
And he said, ah, I'll
do something better.

00:12:09.630 --> 00:12:12.140
I will make you a device
that splits the audio.

00:12:12.140 --> 00:12:13.520
I was like, all right, cool.

00:12:13.520 --> 00:12:14.950
So he leaves.

00:12:14.950 --> 00:12:16.400
And two days later,
he comes back.

00:12:16.400 --> 00:12:18.724
And he gives me this.

00:12:18.724 --> 00:12:20.390
I still don't know
what to do with this.

00:12:20.390 --> 00:12:22.848
All I know is how to plug things
into the top of the phone.

00:12:22.848 --> 00:12:24.510
Can we work with that?

00:12:24.510 --> 00:12:26.210
We tried to get this to work.

00:12:26.210 --> 00:12:27.110
It didn't.

00:12:27.110 --> 00:12:29.430
And to this day, it sits
on my coworker's desk just

00:12:29.430 --> 00:12:31.089
taunting me of our failure.

00:12:31.089 --> 00:12:32.380
Where do you plug something in?

00:12:32.380 --> 00:12:34.250
I have no idea.

00:12:34.250 --> 00:12:36.910
So we actually ended up using
off-the-shelf components.

00:12:36.910 --> 00:12:38.929
So this is a normal
audio splitter.

00:12:38.929 --> 00:12:40.970
Actually, I got one of
these at a vending machine

00:12:40.970 --> 00:12:41.750
in the airport.

00:12:41.750 --> 00:12:44.650
So it's totally off the shelf.

00:12:44.650 --> 00:12:47.770
And we basically have one
tablet that plays a beep.

00:12:47.770 --> 00:12:51.014
It gets split once
into four splitters,

00:12:51.014 --> 00:12:52.680
and then from those
splitters gets split

00:12:52.680 --> 00:12:53.970
five times into each phone.

00:12:53.970 --> 00:12:56.880
So that's how we can
take an audio marker

00:12:56.880 --> 00:13:00.959
and split it into all 19 phones.

00:13:00.959 --> 00:13:02.750
So again, the objective
of what we're doing

00:13:02.750 --> 00:13:04.140
is each camera is
taking a video.

00:13:04.140 --> 00:13:06.380
And we're going to play
a beep on one frame

00:13:06.380 --> 00:13:10.730
at the exact same time
across all the phones.

00:13:10.730 --> 00:13:11.860
I will play this video.

00:13:11.860 --> 00:13:13.270
And we don't have audio.

00:13:13.270 --> 00:13:14.900
So I will emulate
the beep for you.

00:13:17.750 --> 00:13:18.470
Beep.

00:13:18.470 --> 00:13:19.730
Yeah.

00:13:19.730 --> 00:13:23.040
So you can imagine that beep
actually being a beep going

00:13:23.040 --> 00:13:25.171
into all the phones.

00:13:25.171 --> 00:13:25.670
All right.

00:13:25.670 --> 00:13:27.490
So now, we conceptually
have how we're

00:13:27.490 --> 00:13:29.680
going to mark the frame
across all of them.

00:13:29.680 --> 00:13:32.070
How do we actually coordinate
between all those phones?

00:13:32.070 --> 00:13:34.440
That's a lot to deal with.

00:13:34.440 --> 00:13:36.210
It's really complicated.

00:13:36.210 --> 00:13:37.771
So we tried to
write it manually.

00:13:37.771 --> 00:13:39.520
It ended up being a
huge pain in the butt.

00:13:39.520 --> 00:13:42.660
And after a day of lost
productivity, said forget this.

00:13:42.660 --> 00:13:44.647
We need to do something else.

00:13:44.647 --> 00:13:47.230
So just to get into a little bit
of what we had to coordinate,

00:13:47.230 --> 00:13:48.355
there was a bunch of stuff.

00:13:48.355 --> 00:13:49.980
One is just camera app status.

00:13:49.980 --> 00:13:50.690
Am I ready?

00:13:50.690 --> 00:13:51.860
Am I uploading?

00:13:51.860 --> 00:13:54.560
Am I crashed, heaven forbid?

00:13:54.560 --> 00:13:56.740
So that's things that
cameras need to report out.

00:13:56.740 --> 00:13:58.948
We also needed to get some
settings into the cameras.

00:13:58.948 --> 00:14:03.272
So we need to do things like
ISO or shutter speed, exposure.

00:14:03.272 --> 00:14:05.230
So if we're in different
lighting environments,

00:14:05.230 --> 00:14:08.066
like it's a little bit darker
now versus brighter later,

00:14:08.066 --> 00:14:09.690
we want to be able
to change some value

00:14:09.690 --> 00:14:11.400
and instantly have
all the phones pick up

00:14:11.400 --> 00:14:13.810
those new values for the camera.

00:14:13.810 --> 00:14:15.430
Internal versus external mic.

00:14:15.430 --> 00:14:18.410
Like I said, we're feeding the
audio signal into every phone.

00:14:18.410 --> 00:14:20.180
So we need to know if
one comes unplugged

00:14:20.180 --> 00:14:22.456
and is just using ambient
noise from around us.

00:14:22.456 --> 00:14:24.080
We need to know about
that because it's

00:14:24.080 --> 00:14:25.990
going to pick up a very
different peak audio

00:14:25.990 --> 00:14:27.580
signal than everything else.

00:14:27.580 --> 00:14:29.980
We want we want everything
to be isolated just

00:14:29.980 --> 00:14:33.017
in that audio cable so that
it's quiet except for the beep.

00:14:33.017 --> 00:14:34.850
And then a timestamp
to start the recording.

00:14:34.850 --> 00:14:36.500
So we need to tell
them like, hey,

00:14:36.500 --> 00:14:38.791
by such and such time-- we
were talking about timestamp

00:14:38.791 --> 00:14:41.500
earlier-- it's not necessarily
the definitive time

00:14:41.500 --> 00:14:42.390
of the photo.

00:14:42.390 --> 00:14:44.830
But by this time, you
need to be recording.

00:14:44.830 --> 00:14:47.379
So we want to communicate
that to all those phones.

00:14:47.379 --> 00:14:48.670
And for this, we used Firebase.

00:14:48.670 --> 00:14:49.650
Has anyone used Firebase?

00:14:49.650 --> 00:14:50.810
Are we familiar with it all?

00:14:50.810 --> 00:14:51.310
Yes.

00:14:51.310 --> 00:14:52.400
So Firebase is awesome.

00:14:52.400 --> 00:14:54.730
I highly encourage
you to check it out.

00:14:54.730 --> 00:15:00.210
At its most basic level,
it's a NoSQL JSON database.

00:15:00.210 --> 00:15:03.120
But the thing that it
does that's super magical

00:15:03.120 --> 00:15:05.570
is near real-time,
near instantaneous

00:15:05.570 --> 00:15:08.040
updates across all
subscribers to the database.

00:15:08.040 --> 00:15:13.280
So by way of example, we want
to have all the phones share

00:15:13.280 --> 00:15:16.460
the same timestamp for when
they're recording a video.

00:15:16.460 --> 00:15:18.190
So we can write that
value in Firebase.

00:15:18.190 --> 00:15:20.267
And within less than
a second typically,

00:15:20.267 --> 00:15:21.850
all the phones have
gotten that value.

00:15:21.850 --> 00:15:23.760
And it happens super-magically.

00:15:23.760 --> 00:15:26.940
I'll show you that code
in a second-- one second,

00:15:26.940 --> 00:15:28.387
here it is.

00:15:28.387 --> 00:15:28.970
So here it is.

00:15:28.970 --> 00:15:30.790
So we're just instantiating--
this is the Android code.

00:15:30.790 --> 00:15:33.160
So this is the code that
is running on the camera.

00:15:33.160 --> 00:15:36.690
And it is communicating its
status and its app version

00:15:36.690 --> 00:15:40.510
up to Firebase so that our
control app or our visualizer

00:15:40.510 --> 00:15:42.910
or somebody can
take a look at it.

00:15:42.910 --> 00:15:45.120
So we just create a
new Firebase instance.

00:15:45.120 --> 00:15:46.180
We point it to a URL.

00:15:46.180 --> 00:15:50.010
So here it would be whatever
Firebase is /cameras/7 would be

00:15:50.010 --> 00:15:51.749
camera 7.

00:15:51.749 --> 00:15:53.290
This is just a plain
old Java object.

00:15:53.290 --> 00:15:54.020
There's nothing magic.

00:15:54.020 --> 00:15:55.978
And then you say camera
status camerasStatusRef

00:15:55.978 --> 00:15:58.090
.setValue(nCameraStatus).

00:15:58.090 --> 00:16:00.750
And within less
than a second, that

00:16:00.750 --> 00:16:04.250
has been communicated
up to the server.

00:16:04.250 --> 00:16:06.090
So here is the reverse.

00:16:06.090 --> 00:16:08.170
So here is I am
on my control app.

00:16:08.170 --> 00:16:09.670
This is the control
app on the left.

00:16:09.670 --> 00:16:12.480
So the green is the app state.

00:16:12.480 --> 00:16:13.410
So green is good.

00:16:13.410 --> 00:16:14.680
Green is ready.

00:16:14.680 --> 00:16:16.630
It also has the app
version embedded in there.

00:16:16.630 --> 00:16:18.910
And then that's with an
internal or external mic.

00:16:18.910 --> 00:16:20.900
So the settings is in Firebase.

00:16:20.900 --> 00:16:24.800
So these are, again, the
ISO, the exposure, the tone.

00:16:24.800 --> 00:16:26.750
So we can play
some specific tone

00:16:26.750 --> 00:16:30.770
if we find that a
higher tone gets

00:16:30.770 --> 00:16:34.640
picked up more easily or
a lower tone or so forth.

00:16:34.640 --> 00:16:37.920
Our frequency is 2,600 Hertz.

00:16:37.920 --> 00:16:39.910
If you don't know what
that is, look it up.

00:16:39.910 --> 00:16:43.017
I will not talk
about this on stage.

00:16:43.017 --> 00:16:43.850
So how does it work?

00:16:43.850 --> 00:16:45.780
So there's a Start
Countdown button.

00:16:45.780 --> 00:16:47.050
So I hit the button.

00:16:47.050 --> 00:16:48.270
And here, it's eight seconds.

00:16:48.270 --> 00:16:50.228
So we're going to count
down for eight seconds.

00:16:50.228 --> 00:16:52.150
So it will take
eight seconds, add it

00:16:52.150 --> 00:16:55.677
to the current timestamp, and
update this value in Firebase.

00:16:55.677 --> 00:16:57.260
And, again, within
less than a second,

00:16:57.260 --> 00:16:59.540
every phone now has
the time that it

00:16:59.540 --> 00:17:02.614
knows it needs to be recording.

00:17:02.614 --> 00:17:04.280
So how did it actually
record the video?

00:17:04.280 --> 00:17:05.672
Where did that code come from?

00:17:05.672 --> 00:17:06.880
This was a project on GitHub.

00:17:06.880 --> 00:17:09.680
And it's called
Android Camera2Video.

00:17:09.680 --> 00:17:12.910
And it is put out by Google
as sort of a sample reference

00:17:12.910 --> 00:17:15.920
project for how to record
video with a camera.

00:17:15.920 --> 00:17:19.970
So what I did is I used this to
learn the API, by which I mean

00:17:19.970 --> 00:17:24.179
I copied and pasted, and pretty
much verbatim just stuck it

00:17:24.179 --> 00:17:24.682
in the app.

00:17:24.682 --> 00:17:26.140
But in all seriousness,
it actually

00:17:26.140 --> 00:17:27.780
is a great project
to learn the API,

00:17:27.780 --> 00:17:29.904
even though I'm embarrassed
that I pretty much just

00:17:29.904 --> 00:17:31.227
copied out of it.

00:17:31.227 --> 00:17:33.310
All right, so let's talk
a little bit about cloud.

00:17:33.310 --> 00:17:34.541
So here's our team.

00:17:34.541 --> 00:17:36.290
So I'm in New York
City, like I mentioned.

00:17:36.290 --> 00:17:38.206
My coworker Ray, he's
the guy with the camera.

00:17:38.206 --> 00:17:40.210
We worked on the Android
stuff in New York.

00:17:40.210 --> 00:17:42.210
And we said, OK, it's
time to work on cloud.

00:17:42.210 --> 00:17:43.626
So we do what all
good development

00:17:43.626 --> 00:17:45.375
teams do, and we outsourced it.

00:17:45.375 --> 00:17:47.750
So we gave it to our colleague
in San Francisco and said,

00:17:47.750 --> 00:17:50.440
hey, let us know how it goes.

00:17:50.440 --> 00:17:53.990
No, just kidding-- well, mostly.

00:17:53.990 --> 00:17:56.150
So I just wanted
to show you that.

00:17:56.150 --> 00:17:58.750
And I'll talk a bit in
a second like what we

00:17:58.750 --> 00:18:00.820
used to make this more easily.

00:18:00.820 --> 00:18:02.890
But using cloud,
it was easy for us

00:18:02.890 --> 00:18:04.980
to have distributed
development teams.

00:18:04.980 --> 00:18:08.220
We can all work on things
without mucking around too much

00:18:08.220 --> 00:18:11.040
with API definition
and things like that.

00:18:11.040 --> 00:18:13.000
Again, we wanted to
build and build quickly--

00:18:13.000 --> 00:18:15.450
the theme of this talk.

00:18:15.450 --> 00:18:17.370
So here's our architecture.

00:18:17.370 --> 00:18:19.226
We have the devices.

00:18:19.226 --> 00:18:21.600
Each one takes a video and
uploads it to an input bucket.

00:18:21.600 --> 00:18:25.370
So this is a storage
bucket of some kind.

00:18:25.370 --> 00:18:28.330
Then the input bucket from
there, somebody needs to know,

00:18:28.330 --> 00:18:30.930
hey, there's something
to do with something.

00:18:30.930 --> 00:18:32.300
We need to notify somebody.

00:18:32.300 --> 00:18:34.055
So that's a
notification processor.

00:18:34.055 --> 00:18:35.430
Then we want to
take that request

00:18:35.430 --> 00:18:37.600
and we want to stick it
in a queue of some kind.

00:18:40.830 --> 00:18:42.700
We don't want to work
on it right away.

00:18:42.700 --> 00:18:44.283
I'll talk a little
bit more about why.

00:18:44.283 --> 00:18:47.780
But mostly, it's because if
we get flooded with requests

00:18:47.780 --> 00:18:49.730
and we don't have enough
resources to keep up,

00:18:49.730 --> 00:18:51.590
we want to stick those
requests in a queue

00:18:51.590 --> 00:18:52.760
so they don't get lost.

00:18:52.760 --> 00:18:54.647
And then we can
pick them up later.

00:18:54.647 --> 00:18:56.230
From there, we're
going to extract it.

00:18:56.230 --> 00:18:57.860
So we're going to look
at the audio signal.

00:18:57.860 --> 00:19:00.220
We're going to find that one
frame that has that beep.

00:19:00.220 --> 00:19:01.560
We're going to put
into a stitching queue

00:19:01.560 --> 00:19:03.960
when it's done so that when
all the frames are done,

00:19:03.960 --> 00:19:05.990
we're going to actually
take all of them.

00:19:05.990 --> 00:19:07.573
So these are all the
individual frames

00:19:07.573 --> 00:19:08.790
that have been extracted.

00:19:08.790 --> 00:19:12.150
And we will stitch them together
into a final animated GIF.

00:19:12.150 --> 00:19:16.280
So I walk through this in a
little more detail as we go.

00:19:16.280 --> 00:19:19.020
So the first step, video uploads
and notification processing.

00:19:19.020 --> 00:19:22.370
So, again, file storage, we
have to put this somewhere.

00:19:22.370 --> 00:19:24.985
These are the three Google
Cloud platform storage options,

00:19:24.985 --> 00:19:28.850
or three of them, Cloud
Datastore, Cloud SQL, and Cloud

00:19:28.850 --> 00:19:29.410
Storage.

00:19:29.410 --> 00:19:30.159
So what are these?

00:19:30.159 --> 00:19:34.880
So Cloud Datastore is a NoSQL
managed database from Google.

00:19:34.880 --> 00:19:36.910
We use it internally,
a similar technology,

00:19:36.910 --> 00:19:40.320
to do about 4.5 trillion
operations a month.

00:19:40.320 --> 00:19:43.760
So it's very, very scalable
and very, very fast.

00:19:43.760 --> 00:19:46.280
Cloud SQL is managed MySQL.

00:19:46.280 --> 00:19:48.500
So what is Cloud Storage?

00:19:48.500 --> 00:19:53.040
Cloud Storage is where you can
put cat videos or, in our case,

00:19:53.040 --> 00:19:54.930
jumping people videos.

00:19:54.930 --> 00:20:00.302
So this is binary storage so
you can put blobs of whatever.

00:20:00.302 --> 00:20:01.760
So you can have
massive file sizes.

00:20:01.760 --> 00:20:03.880
Ours are like maybe
10 or 20 megs.

00:20:03.880 --> 00:20:06.440
But you can put a gig or a
terabyte or whatever of data

00:20:06.440 --> 00:20:07.940
that you want.

00:20:07.940 --> 00:20:10.820
Here's the code to
get into to upload it.

00:20:10.820 --> 00:20:13.482
So, again, this is
on the Android side.

00:20:13.482 --> 00:20:15.440
So the Android has finished
recording the video

00:20:15.440 --> 00:20:19.080
and now wants to upload
it to cloud storage.

00:20:19.080 --> 00:20:22.560
So I left off the credentials
so you cannot hack me.

00:20:22.560 --> 00:20:24.560
But this is essentially
a service account

00:20:24.560 --> 00:20:26.460
that we had that we
used for Cloud Spin.

00:20:26.460 --> 00:20:29.980
But you can also use OAuth 2
to have maybe an individual use

00:20:29.980 --> 00:20:33.930
their own credentials on the
phone or something like that.

00:20:33.930 --> 00:20:36.930
You point it to your
project and then set

00:20:36.930 --> 00:20:38.299
the MIME type, so video MP4.

00:20:38.299 --> 00:20:40.340
I'm not going to get into
the weeds in this code,

00:20:40.340 --> 00:20:43.550
but just show you generally
what it looks like.

00:20:43.550 --> 00:20:44.690
And then you execute.

00:20:44.690 --> 00:20:45.527
And you upload.

00:20:45.527 --> 00:20:47.110
So then what happens
after you upload?

00:20:47.110 --> 00:20:52.149
We need to tell an API that
there's a video to work on.

00:20:52.149 --> 00:20:54.440
So this is something called
Object Change Notifications

00:20:54.440 --> 00:20:55.981
that we have in
Google Cloud Storage.

00:20:55.981 --> 00:20:59.320
And what that does is rather
than the phone calling an API

00:20:59.320 --> 00:21:04.080
and saying, hey, I just uploaded
this video to the cloud,

00:21:04.080 --> 00:21:06.810
we actually have the storage
mechanism do it for us.

00:21:06.810 --> 00:21:08.920
So this was nice working
in the distributed team

00:21:08.920 --> 00:21:12.970
because I had no idea what the
next step in the process was.

00:21:12.970 --> 00:21:16.507
I just uploaded my video to
the Cloud Storage bucket.

00:21:16.507 --> 00:21:18.090
And then my colleague
in San Francisco

00:21:18.090 --> 00:21:20.710
had configured it so
it would automatically

00:21:20.710 --> 00:21:22.924
call the API, the next
step in the chain.

00:21:22.924 --> 00:21:23.840
So that's really nice.

00:21:23.840 --> 00:21:25.140
So you can configure that.

00:21:25.140 --> 00:21:28.570
It's also good so if you move
where that endpoint lives

00:21:28.570 --> 00:21:31.530
to a different service or
a different cloud provider

00:21:31.530 --> 00:21:33.590
or a different region
or different whatever,

00:21:33.590 --> 00:21:37.420
you can change the storage
mechanism where you

00:21:37.420 --> 00:21:38.720
are uploading the videos to.

00:21:38.720 --> 00:21:41.690
And you don't have to upload
your APK on your Android

00:21:41.690 --> 00:21:42.330
device.

00:21:42.330 --> 00:21:44.440
So it's just uploading
to the same place.

00:21:44.440 --> 00:21:46.920
It doesn't need to know
there's a new API endpoint.

00:21:46.920 --> 00:21:48.920
So that's really nice.

00:21:48.920 --> 00:21:52.700
So three options for Google
Cloud Storage-- standard,

00:21:52.700 --> 00:21:55.224
reduced availability,
and nearline.

00:21:55.224 --> 00:21:56.890
I'm not going to get
too salesy on this,

00:21:56.890 --> 00:21:59.070
but from a developer
perspective, what

00:21:59.070 --> 00:21:59.810
does this mean?

00:21:59.810 --> 00:22:02.250
One, they all share the same
API, which is super-nice.

00:22:02.250 --> 00:22:03.670
So as you're
developing apps, you

00:22:03.670 --> 00:22:07.950
don't have to rework your
API design or consumption,

00:22:07.950 --> 00:22:09.940
depending on which
storage option you use.

00:22:09.940 --> 00:22:11.990
Standard storage is
our standard storage,

00:22:11.990 --> 00:22:13.990
standard online storage.

00:22:13.990 --> 00:22:18.580
And the nearline is our
equivalent to a tape storage.

00:22:18.580 --> 00:22:21.220
So this would be your
archival thing, so

00:22:21.220 --> 00:22:23.869
things you don't need
access to immediately.

00:22:23.869 --> 00:22:25.910
So you'll notice that the
speed drops down as you

00:22:25.910 --> 00:22:28.330
go left to right, as does cost.

00:22:28.330 --> 00:22:31.250
So to give you a sense
of how slow is nearline,

00:22:31.250 --> 00:22:33.740
it's like on the order
of four to two seconds,

00:22:33.740 --> 00:22:34.780
something like that.

00:22:34.780 --> 00:22:38.010
So it's actually, compared to a
lot of other long-term storage

00:22:38.010 --> 00:22:41.490
options from other cloud
providers is pretty fast.

00:22:41.490 --> 00:22:44.220
Four seconds to get essentially
your long-term search storage

00:22:44.220 --> 00:22:46.090
is excellent.

00:22:46.090 --> 00:22:48.670
One other things we'll
talk about is edge caching.

00:22:48.670 --> 00:22:50.930
There's another feature
of Google Cloud Storage.

00:22:50.930 --> 00:22:53.700
So what this is is as
users from around the world

00:22:53.700 --> 00:22:56.310
are requesting files
from your storage system,

00:22:56.310 --> 00:22:57.810
it will automatically
propagate them

00:22:57.810 --> 00:22:59.351
to data centers near
them physically.

00:22:59.351 --> 00:23:01.900
So that will reduce
their load times.

00:23:01.900 --> 00:23:04.460
So you can imagine if
we take this contraption

00:23:04.460 --> 00:23:07.190
and make a huge social
network around it,

00:23:07.190 --> 00:23:10.006
as people around the
world are requesting

00:23:10.006 --> 00:23:12.630
to see other people's images or
whatever, it will automatically

00:23:12.630 --> 00:23:14.130
propagate those to
data centers that

00:23:14.130 --> 00:23:15.430
are closer to where they are.

00:23:15.430 --> 00:23:16.820
And it does it automatically.

00:23:16.820 --> 00:23:18.105
It's not a CDN.

00:23:18.105 --> 00:23:19.580
It's not like a
guaranteed cache.

00:23:19.580 --> 00:23:21.204
But it is sort of a
best-effort cache.

00:23:21.204 --> 00:23:23.370
And it's kind of nice because
you get it essentially

00:23:23.370 --> 00:23:25.017
out of the box.

00:23:25.017 --> 00:23:27.350
So the next thing I'm going
to talk about is App Engine.

00:23:27.350 --> 00:23:29.590
Has anyone used App Engine
or heard of App Engine?

00:23:29.590 --> 00:23:30.340
Yeah, a few of us.

00:23:30.340 --> 00:23:34.560
So this is probably our
most popular platform

00:23:34.560 --> 00:23:36.920
as a service offering.

00:23:36.920 --> 00:23:39.870
I like to say the dream of App
Engine is you write your code

00:23:39.870 --> 00:23:41.910
and then you upload
it, and it just runs.

00:23:41.910 --> 00:23:45.112
It scales up to as
high as you need

00:23:45.112 --> 00:23:47.320
and scales down to essentially
zero if you don't need

00:23:47.320 --> 00:23:47.820
anything.

00:23:47.820 --> 00:23:49.730
So this is nice.

00:23:49.730 --> 00:23:53.190
So you don't have to worry
about what's the load on my app?

00:23:53.190 --> 00:23:55.500
Do I need to have certain
metrics like my CPU

00:23:55.500 --> 00:23:57.757
is spiking across my cluster.

00:23:57.757 --> 00:24:00.340
So I need to have some process
to automatically scale this out

00:24:00.340 --> 00:24:02.770
to more machines.

00:24:02.770 --> 00:24:07.770
It supports Python, PHP,
Java, and Go out of the box.

00:24:07.770 --> 00:24:10.255
And then there's some ways
to do Node.js as well.

00:24:10.255 --> 00:24:12.130
It does some cool things
too like versioning.

00:24:12.130 --> 00:24:15.570
So you can say, hey, I want
to give 20% of my visitors

00:24:15.570 --> 00:24:16.800
this version of the code.

00:24:16.800 --> 00:24:18.230
I want to give 80% this version.

00:24:18.230 --> 00:24:20.740
So you can do some A/B
testing that way to see

00:24:20.740 --> 00:24:22.581
which one performs better.

00:24:22.581 --> 00:24:24.080
And the most important
thing is it's

00:24:24.080 --> 00:24:26.540
managed by Google
SREs, which means

00:24:26.540 --> 00:24:30.720
if there needs to be
security patches rolled out--

00:24:30.720 --> 00:24:34.520
if your app needs to scale up
from 1 to 2 to 3 to 10 servers,

00:24:34.520 --> 00:24:36.250
App Engine just takes
care of it for you.

00:24:36.250 --> 00:24:37.840
And if it goes down,
the Google SREs

00:24:37.840 --> 00:24:39.670
are monitoring all of
that infrastructure,

00:24:39.670 --> 00:24:41.290
and they will fix it.

00:24:41.290 --> 00:24:44.810
You don't have to worry about
individual machines going down.

00:24:44.810 --> 00:24:47.900
Our team is managing it for you.

00:24:47.900 --> 00:24:48.400
All right.

00:24:48.400 --> 00:24:50.570
So speaking of scale,
here's this dude.

00:24:50.570 --> 00:24:53.120
He's rocking out
on his air guitar.

00:24:53.120 --> 00:24:54.800
Maybe he's in Austin, Texas.

00:24:54.800 --> 00:24:57.360
Here's a dude
fighting an Android.

00:24:57.360 --> 00:24:59.730
He's maybe in Amsterdam.

00:24:59.730 --> 00:25:02.760
Here's some team doing a team
building exercise in Japan.

00:25:02.760 --> 00:25:04.570
These are actually
all real photos.

00:25:04.570 --> 00:25:06.410
But say it gets this popular.

00:25:06.410 --> 00:25:07.460
It's around the world.

00:25:07.460 --> 00:25:08.930
And people are
doing wacky things.

00:25:08.930 --> 00:25:12.630
And we have to start
worrying about scale.

00:25:12.630 --> 00:25:15.700
So this is no longer one
setup with some minor amount

00:25:15.700 --> 00:25:16.510
of infrastructure.

00:25:16.510 --> 00:25:17.710
This is getting real, y'all.

00:25:17.710 --> 00:25:19.380
Our fake startup
is getting real.

00:25:19.380 --> 00:25:21.105
It's still fake.

00:25:21.105 --> 00:25:21.980
So how do we do that?

00:25:21.980 --> 00:25:24.410
So we need to put things
into a queue of some kind

00:25:24.410 --> 00:25:28.620
to absorb those requests so
that we can store them and work

00:25:28.620 --> 00:25:30.420
on them later.

00:25:30.420 --> 00:25:32.520
Let's do a quick thing--
push versus pull.

00:25:32.520 --> 00:25:35.540
So push is like requests
go into the queue.

00:25:35.540 --> 00:25:37.952
And then the queue
finds someone to tell.

00:25:37.952 --> 00:25:38.910
And then it tells them.

00:25:38.910 --> 00:25:39.810
That's a push.

00:25:39.810 --> 00:25:41.427
A pull is it goes
into the queue,

00:25:41.427 --> 00:25:43.760
and then someone who becomes
available-- so some process

00:25:43.760 --> 00:25:45.510
or whatever that's
available to work on it

00:25:45.510 --> 00:25:49.980
will then ask, hey,
give me the next item.

00:25:49.980 --> 00:25:52.910
In our instance, we're going
to use a pull subscription

00:25:52.910 --> 00:25:55.160
because we want to scale
up as many image processors

00:25:55.160 --> 00:25:57.000
as we want and then
scale them down.

00:25:57.000 --> 00:26:00.400
And then they'll take care
of requesting the next thing.

00:26:00.400 --> 00:26:03.290
So for this, we used a
product called Cloud Pub/Sub.

00:26:03.290 --> 00:26:06.600
Cloud Pub/Sub can be used for
a lot of things, one of which

00:26:06.600 --> 00:26:07.315
is a queue.

00:26:07.315 --> 00:26:08.940
At the end of the
day, ultimately, it's

00:26:08.940 --> 00:26:10.490
a publish subscribe system.

00:26:10.490 --> 00:26:12.890
And I'll show you what that
looks like in a second.

00:26:12.890 --> 00:26:14.807
But this is a fully
managed service by Google.

00:26:14.807 --> 00:26:16.973
So if you have messages you
need to put into a queue

00:26:16.973 --> 00:26:18.770
or whatever, you can
use Cloud Pub/Sub.

00:26:18.770 --> 00:26:21.210
And you don't have to
install any software.

00:26:21.210 --> 00:26:23.240
You don't have to spin
up any virtual machines.

00:26:23.240 --> 00:26:25.740
You don't have to worry about
how big your node cluster is

00:26:25.740 --> 00:26:26.930
or anything like that.

00:26:26.930 --> 00:26:29.760
You turn it on, and you can
start pushing messages into it

00:26:29.760 --> 00:26:31.780
or receiving them.

00:26:31.780 --> 00:26:32.830
So how does it work?

00:26:32.830 --> 00:26:34.100
We have an extractor.

00:26:34.100 --> 00:26:36.080
In our case, the
extractor is the process

00:26:36.080 --> 00:26:37.240
that looks at the video.

00:26:37.240 --> 00:26:39.780
And it's finding that one
frame that has that beep.

00:26:39.780 --> 00:26:42.914
So it's analyzing
the audio track

00:26:42.914 --> 00:26:45.330
looking for the beep-- so frame
1, frame 2, frame 3, frame

00:26:45.330 --> 00:26:46.090
4, and so on.

00:26:46.090 --> 00:26:48.090
So once it finds the
right frame with the beep,

00:26:48.090 --> 00:26:51.320
it's pulling that
frame out into a JPEG.

00:26:51.320 --> 00:26:52.350
So that's our extractor.

00:26:52.350 --> 00:26:55.440
So once it has that
frame extracted,

00:26:55.440 --> 00:26:58.740
it's going to put it
into a frames topic

00:26:58.740 --> 00:27:00.570
so that, ultimately,
once they're all done,

00:27:00.570 --> 00:27:04.100
someone else can pick that up
and stitch them all together.

00:27:04.100 --> 00:27:05.715
So in this case,
we have a stitcher.

00:27:05.715 --> 00:27:07.840
A stitcher is the process
that takes all the frames

00:27:07.840 --> 00:27:08.798
and puts them together.

00:27:08.798 --> 00:27:10.920
And it's listening
on that frames topic.

00:27:10.920 --> 00:27:13.500
So once the extractor is
done, it posts a message,

00:27:13.500 --> 00:27:15.000
and the stitcher picks it up.

00:27:15.000 --> 00:27:18.600
So here is what our
original stitcher creates.

00:27:18.600 --> 00:27:21.010
It is essentially
what you see here.

00:27:21.010 --> 00:27:23.850
It's spinning from left
or right or whatever.

00:27:23.850 --> 00:27:26.092
And he's like frozen in
the air the whole time.

00:27:26.092 --> 00:27:27.550
But say we wanted
to do variations.

00:27:27.550 --> 00:27:29.910
Say we wanted to do like
other versions of Cloud Spin

00:27:29.910 --> 00:27:32.500
besides just one frozen in air.

00:27:32.500 --> 00:27:34.410
So we could do that
easily with Cloud Pub/Sub

00:27:34.410 --> 00:27:38.310
by having other stitchers that
create alternate versions also

00:27:38.310 --> 00:27:41.980
listening to that frames topic.

00:27:41.980 --> 00:27:44.910
So the extractor still is
just publishing one message.

00:27:44.910 --> 00:27:48.330
It doesn't know who is even
consuming it on the other side.

00:27:48.330 --> 00:27:50.720
It doesn't need to know that
there's one, two, three now

00:27:50.720 --> 00:27:52.360
instead of just one.

00:27:52.360 --> 00:27:54.750
So let's see what
these could look

00:27:54.750 --> 00:27:57.440
like with some other variations.

00:27:57.440 --> 00:27:59.560
So here's one that
actually takes the video

00:27:59.560 --> 00:28:00.615
from the first camera.

00:28:03.980 --> 00:28:06.400
I guess it's using the
center camera, stops,

00:28:06.400 --> 00:28:07.740
and it's going to spin
all the way to the left,

00:28:07.740 --> 00:28:09.365
all the way back to
the right, and then

00:28:09.365 --> 00:28:11.397
use the video on the right one.

00:28:11.397 --> 00:28:12.230
So that's different.

00:28:12.230 --> 00:28:13.896
So there's actually
movement in this GIF

00:28:13.896 --> 00:28:16.240
rather than just
the initial one.

00:28:16.240 --> 00:28:18.504
And then, similarly, you can
start at one of the ends,

00:28:18.504 --> 00:28:20.920
spin all the way over, and
then finish and play the video.

00:28:20.920 --> 00:28:23.490
So those are some variations
we can do with Cloud Spin.

00:28:23.490 --> 00:28:27.649
And with Pub/Sub, again,
you publish one message

00:28:27.649 --> 00:28:28.190
to the topic.

00:28:28.190 --> 00:28:30.790
And then however many stitchers
have different versions,

00:28:30.790 --> 00:28:33.830
they subscribe to that
topic and stitch them later.

00:28:33.830 --> 00:28:37.585
So let's go back to
some interesting photos.

00:28:37.585 --> 00:28:39.960
So while we're all building
on this cloud infrastructure,

00:28:39.960 --> 00:28:44.860
we built this off of a
really half-assed prototype.

00:28:44.860 --> 00:28:47.450
Now we need to do it for
real because our deadline is

00:28:47.450 --> 00:28:47.950
looming.

00:28:47.950 --> 00:28:50.810
So let me take you inside
our secret startup lab.

00:28:50.810 --> 00:28:53.750
This is in New York in
this other, other building

00:28:53.750 --> 00:28:57.990
that no one even knew we
owned or had an office in.

00:28:57.990 --> 00:29:00.630
So we were working
in this office.

00:29:00.630 --> 00:29:01.830
No one knew who we were.

00:29:01.830 --> 00:29:05.410
And we were putting together
this ridiculous prototype.

00:29:05.410 --> 00:29:07.740
It was really cheap,
really scrappy,

00:29:07.740 --> 00:29:11.210
because we didn't know for
sure that this would work.

00:29:11.210 --> 00:29:14.630
And when I say scrappy,
I mean really scrappy.

00:29:14.630 --> 00:29:17.620
So these are selfie sticks,
if you can see that.

00:29:17.620 --> 00:29:19.880
We literally put a phone
on top of a selfie stick

00:29:19.880 --> 00:29:21.367
and used it as a tripod.

00:29:21.367 --> 00:29:23.200
I don't know if anyone
has tried to do this.

00:29:23.200 --> 00:29:26.220
But it is actually the least
stable way you can possibly

00:29:26.220 --> 00:29:27.840
hold up a cell phone.

00:29:27.840 --> 00:29:29.860
I would roll over
to my coworkers desk

00:29:29.860 --> 00:29:31.630
to tell them something,
and just the wind

00:29:31.630 --> 00:29:33.050
of me rolling by
the selfie stick

00:29:33.050 --> 00:29:34.299
would cause it to topple over.

00:29:34.299 --> 00:29:36.156
And I'd have to
dive under the floor

00:29:36.156 --> 00:29:38.530
to save this phone so I didn't
have to explain to my boss

00:29:38.530 --> 00:29:42.160
why I smashed a $600 cell
phone on the ground because

00:29:42.160 --> 00:29:43.080
of a selfie stick.

00:29:43.080 --> 00:29:45.490
So yeah, we set up
a bunch of selfie

00:29:45.490 --> 00:29:49.670
sticks to act as
makeshift tripods.

00:29:49.670 --> 00:29:53.090
We were trying to find
the right distance

00:29:53.090 --> 00:29:56.000
from where the person is to
where the edge of the cameras

00:29:56.000 --> 00:29:56.740
are.

00:29:56.740 --> 00:29:59.929
And we didn't have
any measuring tape.

00:29:59.929 --> 00:30:02.470
I was like, guys, we work for
a multi-billion dollar company.

00:30:02.470 --> 00:30:04.730
And we don't have
any measuring tape.

00:30:04.730 --> 00:30:08.470
But for some reason, my coworker
had police crime scene tape

00:30:08.470 --> 00:30:10.195
in his desk.

00:30:10.195 --> 00:30:12.320
To this day, I did not ask
because I don't actually

00:30:12.320 --> 00:30:15.006
want to know why he had
crime scene tape in his desk.

00:30:15.006 --> 00:30:16.630
So we had to measure
it out using that.

00:30:16.630 --> 00:30:18.707
And it actually turns out
that the ideal distance

00:30:18.707 --> 00:30:20.290
between the person
getting their photo

00:30:20.290 --> 00:30:24.840
taken and the cameras
is eight CAUTIONs.

00:30:24.840 --> 00:30:28.110
A CAUTION is about a foot,
in case you're curious.

00:30:28.110 --> 00:30:29.880
A CAUTION unit is
not something that I

00:30:29.880 --> 00:30:32.620
was familiar with
until this project.

00:30:32.620 --> 00:30:34.030
So, yeah, it was pretty scrappy.

00:30:34.030 --> 00:30:35.450
But eventually we
got it working.

00:30:35.450 --> 00:30:37.120
We felt like, OK, this is good.

00:30:37.120 --> 00:30:38.440
We're feeling good.

00:30:38.440 --> 00:30:40.190
And then we said, let's
get some lighting.

00:30:40.190 --> 00:30:42.550
So this was our intern Matt.

00:30:42.550 --> 00:30:44.300
Matt, super-brilliant guy.

00:30:44.300 --> 00:30:46.350
He wrote the first
version of the software

00:30:46.350 --> 00:30:49.007
that analyzes the video to
find the frame with the beat.

00:30:49.007 --> 00:30:49.840
So he's super-smart.

00:30:49.840 --> 00:30:52.400
He's like, guys, I cannot
figure out this lighting.

00:30:52.400 --> 00:30:54.000
Can you please help me out?

00:30:54.000 --> 00:30:56.320
And so we came over,
and we're like, come on.

00:30:56.320 --> 00:30:57.540
We can figure this out.

00:30:57.540 --> 00:31:00.160
We could not figure out why
these lights weren't working.

00:31:00.160 --> 00:31:02.770
It wasn't until I was putting
this presentation together

00:31:02.770 --> 00:31:05.770
that I realized why this
light wasn't working.

00:31:05.770 --> 00:31:07.687
It's because it's
not plugged in.

00:31:07.687 --> 00:31:10.020
I literally was looking at
this photo, and I went, like,

00:31:10.020 --> 00:31:10.610
oh, my god.

00:31:10.610 --> 00:31:13.480
That's why we never figured it
out, because it's unplugged.

00:31:13.480 --> 00:31:15.630
So I don't know what
this says about me.

00:31:15.630 --> 00:31:20.130
But whatever, anyway,
so it was fun.

00:31:20.130 --> 00:31:21.360
So we got that all working.

00:31:21.360 --> 00:31:23.890
We eventually got
our lights working.

00:31:23.890 --> 00:31:25.530
Selfie sticks were not working.

00:31:25.530 --> 00:31:27.090
So we got actual tripods.

00:31:27.090 --> 00:31:27.900
We went all out.

00:31:27.900 --> 00:31:29.930
We bought a full
set of 20 phones.

00:31:29.930 --> 00:31:31.730
We set it up in
this little room.

00:31:31.730 --> 00:31:33.640
People always ask, why
is it a green screen?

00:31:33.640 --> 00:31:34.610
Are you superimposing?

00:31:34.610 --> 00:31:36.901
I was like, no, that was just
the color of the curtain.

00:31:36.901 --> 00:31:40.669
So yeah, that was
not very exciting.

00:31:40.669 --> 00:31:41.460
So it was all good.

00:31:41.460 --> 00:31:43.220
We were feeling good about life.

00:31:43.220 --> 00:31:46.790
That is, until I tried to use
the bathroom in this office.

00:31:46.790 --> 00:31:48.774
So I don't know why.

00:31:48.774 --> 00:31:50.440
This has nothing to
do with the project.

00:31:50.440 --> 00:31:54.229
I just think it's a terrifying
and hilarious anecdote.

00:31:54.229 --> 00:31:55.770
So every time I went
to the bathroom,

00:31:55.770 --> 00:31:58.350
there's this picture of
this lady in the wall.

00:31:58.350 --> 00:32:01.070
First of all, I don't know why a
super-creepy photo is in there.

00:32:01.070 --> 00:32:04.770
I didn't pee for three
weeks, basically.

00:32:04.770 --> 00:32:05.630
But all right.

00:32:05.630 --> 00:32:07.960
That's creepy, but it's a
regular amount of creepy.

00:32:07.960 --> 00:32:10.950
Where it gets super creepy
is if you look more closely,

00:32:10.950 --> 00:32:13.230
you see that someone
had cut out her eyes.

00:32:13.230 --> 00:32:16.040
And behind her eyes
were more eyes.

00:32:16.040 --> 00:32:18.787
There were eyes behind her eyes.

00:32:18.787 --> 00:32:21.120
And at first, I thought it
was one of those "Scooby Doo"

00:32:21.120 --> 00:32:23.720
cartoon situations where there's
a painting and someone is

00:32:23.720 --> 00:32:25.920
watching you from behind it.

00:32:25.920 --> 00:32:27.710
But no, it's just
regular painting eyes.

00:32:27.710 --> 00:32:29.710
So anyway, do you
all want to stare

00:32:29.710 --> 00:32:32.530
at this creepy, terrifying
photo for a while?

00:32:32.530 --> 00:32:33.173
No?

00:32:33.173 --> 00:32:33.900
Let's move on.

00:32:33.900 --> 00:32:34.437
Sure?

00:32:34.437 --> 00:32:35.020
AUDIENCE: Yes.

00:32:35.020 --> 00:32:36.700
BRETT MCGOWEN: All right.

00:32:36.700 --> 00:32:40.320
All right, so extracting
and stitching.

00:32:40.320 --> 00:32:41.296
Back to the real stuff.

00:32:41.296 --> 00:32:43.420
These are the bits of the
project that are actually

00:32:43.420 --> 00:32:45.890
running the code that's
actually analyzing the video

00:32:45.890 --> 00:32:48.352
and finding the frame,
extracting the JPEG,

00:32:48.352 --> 00:32:50.310
and the bit that's
stitching them all together.

00:32:50.310 --> 00:32:52.450
So once it has all the
JPEGs, stitching it together

00:32:52.450 --> 00:32:54.910
into a final, animated GIF.

00:32:54.910 --> 00:32:59.110
So here is what that looks like
on the architecture diagram,

00:32:59.110 --> 00:33:00.610
the extractor and the stitcher.

00:33:00.610 --> 00:33:04.079
So, again, from the phones
to a storage bucket,

00:33:04.079 --> 00:33:06.370
it tells App Engine, which
is a notification processor.

00:33:06.370 --> 00:33:07.245
It goes into a queue.

00:33:07.245 --> 00:33:08.710
And the extractor picks it up.

00:33:08.710 --> 00:33:10.260
So what is the extractor doing?

00:33:10.260 --> 00:33:12.570
The extractor is looking
at the audio intensity

00:33:12.570 --> 00:33:14.440
level of the video clip.

00:33:14.440 --> 00:33:16.780
And it's finding the
one frame that is

00:33:16.780 --> 00:33:18.510
higher than all the other ones.

00:33:18.510 --> 00:33:22.650
Can anyone tell me where
that is on this graph?

00:33:22.650 --> 00:33:23.860
Yes.

00:33:23.860 --> 00:33:27.258
It is right there
about frame 79.

00:33:27.258 --> 00:33:29.426
That's the beep.

00:33:29.426 --> 00:33:31.800
So it's basically code that's
looking at the audio level.

00:33:31.800 --> 00:33:34.394
And it's finding the one frame
that has the highest beep.

00:33:34.394 --> 00:33:35.060
Here's the code.

00:33:35.060 --> 00:33:37.530
Again, I'm not going to get
into a ton of detail on it.

00:33:37.530 --> 00:33:40.600
But essentially,
we're using a library

00:33:40.600 --> 00:33:42.250
called MoviePy,
which is essentially

00:33:42.250 --> 00:33:44.550
a Python wrapper around FFmpeg.

00:33:44.550 --> 00:33:46.650
So I don't know if you
guys have used FFmpeg.

00:33:46.650 --> 00:33:49.510
It's a command line tool to
do all kinds of crazy stuff

00:33:49.510 --> 00:33:51.710
with images and
videos and whatnot.

00:33:51.710 --> 00:33:54.810
It's super complicated
and super powerful.

00:33:54.810 --> 00:33:58.110
So MoviePy is like a
nice wrapper around it.

00:33:58.110 --> 00:33:59.750
It's literally a Python script.

00:33:59.750 --> 00:34:03.920
It takes a video as an input and
it saves a JPEG as an output .

00:34:03.920 --> 00:34:09.150
So the formula here is
it's looking for something

00:34:09.150 --> 00:34:14.659
that is more than four times
above the standard deviation

00:34:14.659 --> 00:34:18.107
of the audio level of this
frame, for what it's worth.

00:34:18.107 --> 00:34:19.690
We've actually changed
it now to where

00:34:19.690 --> 00:34:24.030
it's just find the highest
volume, which was much easier.

00:34:24.030 --> 00:34:24.530
All right.

00:34:24.530 --> 00:34:26.699
So now that extracts one frame.

00:34:26.699 --> 00:34:29.110
So we have a whole bunch of
these extractors actually

00:34:29.110 --> 00:34:30.300
running in parallel.

00:34:30.300 --> 00:34:31.810
So rather than
taking camera one,

00:34:31.810 --> 00:34:33.590
finding the frame, camera
two, finding the frame,

00:34:33.590 --> 00:34:34.340
this is the cloud.

00:34:34.340 --> 00:34:36.690
We're going to spin
up 20 processes,

00:34:36.690 --> 00:34:37.969
so they can all pick a video.

00:34:37.969 --> 00:34:39.469
And they can all
pull out one frame.

00:34:39.469 --> 00:34:41.400
So it can happen
very, very quickly.

00:34:41.400 --> 00:34:43.179
So say we've got 20 frames.

00:34:43.179 --> 00:34:44.500
They've all been extracted.

00:34:44.500 --> 00:34:46.153
Now we need to
stitch them together.

00:34:48.820 --> 00:34:51.679
This all runs, incidentally,
on our Compute Engine offering.

00:34:51.679 --> 00:34:54.159
So Compute Engine is
our infrastructure

00:34:54.159 --> 00:34:55.590
as a service offering.

00:34:55.590 --> 00:34:57.729
So what that essentially
means in basic terms

00:34:57.729 --> 00:34:59.020
is our virtual machines, right?

00:34:59.020 --> 00:35:00.395
You can spin up
a virtual machine

00:35:00.395 --> 00:35:05.620
that has CentOS or Debian
or Ubuntu or whatever.

00:35:05.620 --> 00:35:07.254
I want this much RAM.

00:35:07.254 --> 00:35:08.420
I want this as a hard drive.

00:35:08.420 --> 00:35:09.660
I want an SSD.

00:35:09.660 --> 00:35:13.090
I want this many
processors that are

00:35:13.090 --> 00:35:16.936
this fast-- kind of customize
it to what you want.

00:35:16.936 --> 00:35:18.560
So that's called
Google Compute Engine.

00:35:18.560 --> 00:35:20.260
So these are virtual
machines you can

00:35:20.260 --> 00:35:22.470
install whatever you want on.

00:35:22.470 --> 00:35:24.390
They're managed by you.

00:35:24.390 --> 00:35:27.170
So one thing-- I want
to put my sales hat back

00:35:27.170 --> 00:35:30.639
on for a second-- that I
think is cool about our cloud

00:35:30.639 --> 00:35:32.680
is that you can provision
virtual machines super,

00:35:32.680 --> 00:35:33.540
super quickly.

00:35:33.540 --> 00:35:35.250
And so for a fake
start up project,

00:35:35.250 --> 00:35:36.880
this was important
because we kind of

00:35:36.880 --> 00:35:39.430
wanted to run as few virtual
machines as possible.

00:35:39.430 --> 00:35:42.215
But then we wanted to be ready
that if all of a sudden, Cloud

00:35:42.215 --> 00:35:45.230
Spin is in malls all across
America and the world,

00:35:45.230 --> 00:35:49.170
and Sunday morning comes and
everyone goes out to the mall

00:35:49.170 --> 00:35:50.650
and starts using
it all at once, we

00:35:50.650 --> 00:35:52.775
want to be able to scale
up our compute power very,

00:35:52.775 --> 00:35:53.430
very quickly.

00:35:53.430 --> 00:35:56.910
So when I say fast virtual
machine provisioning,

00:35:56.910 --> 00:35:59.450
I'm talking about a
thousand virtual machines

00:35:59.450 --> 00:36:02.130
on the order of minutes--
less than 10 minutes,

00:36:02.130 --> 00:36:03.755
just a few minutes.

00:36:03.755 --> 00:36:04.630
So it's really quick.

00:36:04.630 --> 00:36:08.090
So we can keep our resources
low and control costs.

00:36:08.090 --> 00:36:12.530
And then when we need to scale
up, we can do it very quickly.

00:36:12.530 --> 00:36:14.060
So how do we autoscale that?

00:36:14.060 --> 00:36:16.690
So, again, these are
essentially Python scripts

00:36:16.690 --> 00:36:19.290
that are running and extracting
images and stitching them

00:36:19.290 --> 00:36:21.310
all together to
create this video.

00:36:21.310 --> 00:36:23.740
How do we scale that?

00:36:23.740 --> 00:36:26.200
We're using a thing called
Compute Engine Autoscaler.

00:36:26.200 --> 00:36:28.116
To kind of walk you
through the diagram here--

00:36:28.116 --> 00:36:31.160
there's a bunch of boxes-- you
essentially create an instance

00:36:31.160 --> 00:36:31.800
group template.

00:36:31.800 --> 00:36:33.090
So this is the
recipe of-- this is

00:36:33.090 --> 00:36:34.890
what I want my virtual
machine to look like.

00:36:34.890 --> 00:36:36.556
I want all the virtual
machines in here,

00:36:36.556 --> 00:36:39.176
again, to have
this OS, CPU, RAM.

00:36:39.176 --> 00:36:40.800
And then you can have
a startup script.

00:36:40.800 --> 00:36:44.210
So say, as soon as this
virtual machine comes online,

00:36:44.210 --> 00:36:45.180
install my software.

00:36:45.180 --> 00:36:46.481
So it's ready to go.

00:36:46.481 --> 00:36:47.980
And then you have
an Autoscaler that

00:36:47.980 --> 00:36:50.130
plugs into some kind of metric.

00:36:50.130 --> 00:36:56.717
So you could use
something like CPU usage

00:36:56.717 --> 00:36:58.300
across my cluster
of virtual machines.

00:36:58.300 --> 00:37:00.980
So once my CPU starts
spiking on average,

00:37:00.980 --> 00:37:02.500
start adding more at this rate.

00:37:02.500 --> 00:37:03.209
Network traffic.

00:37:03.209 --> 00:37:05.750
So if I start getting hammered
with a lot of network traffic,

00:37:05.750 --> 00:37:07.150
scale up at this rate.

00:37:07.150 --> 00:37:09.930
One of the things you can do
is you can tie it into Pub/Sub,

00:37:09.930 --> 00:37:11.740
which we talked
about, and say, hey,

00:37:11.740 --> 00:37:14.940
however many videos are
waiting to get processed,

00:37:14.940 --> 00:37:16.840
spin up that many extractors.

00:37:16.840 --> 00:37:17.815
Why not?

00:37:17.815 --> 00:37:20.190
Our billing goes down to 10
minute increments rather than

00:37:20.190 --> 00:37:20.690
an hour.

00:37:20.690 --> 00:37:24.260
So it's actually
not that expensive.

00:37:24.260 --> 00:37:26.260
Say we have 10 extractor
processes out there.

00:37:26.260 --> 00:37:27.600
We're waiting for 10 videos.

00:37:27.600 --> 00:37:29.770
But then 1,000 come
in all at once.

00:37:29.770 --> 00:37:33.690
We could spin up to
1,000 extractors,

00:37:33.690 --> 00:37:35.790
chop down all of
those super-quickly,

00:37:35.790 --> 00:37:37.904
and then release
those extractors.

00:37:37.904 --> 00:37:39.570
And that way, we can
scale up as quickly

00:37:39.570 --> 00:37:42.620
as possible without
maintaining all that scale.

00:37:42.620 --> 00:37:43.950
And it does it automatically.

00:37:43.950 --> 00:37:48.110
This autoscaler and managed
template group do that for us

00:37:48.110 --> 00:37:50.217
once we configure it.

00:37:50.217 --> 00:37:52.300
So next, I'm going to talk
about containerization.

00:37:52.300 --> 00:37:55.227
I'm going to breeze through
containers because we're

00:37:55.227 --> 00:37:56.310
getting along in the talk.

00:37:56.310 --> 00:37:57.790
But has anyone
heard of containers

00:37:57.790 --> 00:37:59.530
or familiar with it all?

00:37:59.530 --> 00:38:00.420
Yeah.

00:38:00.420 --> 00:38:03.670
I think Brian may have a thing
or two to say about that.

00:38:03.670 --> 00:38:06.580
So let me give you this
totally sweet continuum

00:38:06.580 --> 00:38:09.240
of efficiency and flexibility.

00:38:09.240 --> 00:38:11.400
So on the upper left,
you have Compute Engine,

00:38:11.400 --> 00:38:13.390
which is our virtual
machine offering.

00:38:13.390 --> 00:38:15.900
It is as flexible as
you need it to be.

00:38:15.900 --> 00:38:17.130
It can literally do anything.

00:38:17.130 --> 00:38:19.912
It's a virtual machine for
you to install whatever.

00:38:19.912 --> 00:38:21.370
But you have to
manage it yourself.

00:38:21.370 --> 00:38:22.710
You have to configure scaling.

00:38:22.710 --> 00:38:24.240
You have to worry about scaling.

00:38:24.240 --> 00:38:25.990
You have to provision them.

00:38:25.990 --> 00:38:29.390
You have to install security
updates, and patches,

00:38:29.390 --> 00:38:30.530
and things like that.

00:38:30.530 --> 00:38:32.660
You have to manage it yourself.

00:38:32.660 --> 00:38:35.280
So that's less efficient
as a developer.

00:38:35.280 --> 00:38:37.880
On the bottom right, we have App
Engine, which I talked about.

00:38:37.880 --> 00:38:39.250
Again, the dream of App Engine.

00:38:39.250 --> 00:38:40.140
Write your code.

00:38:40.140 --> 00:38:42.132
Here you go, App
Engine, run it for me.

00:38:42.132 --> 00:38:44.590
I don't care about what you
have to do to make that happen.

00:38:44.590 --> 00:38:46.899
I don't care how many
virtual machines you need.

00:38:46.899 --> 00:38:48.940
I don't care what version
of the operating system

00:38:48.940 --> 00:38:49.689
you're running on.

00:38:49.689 --> 00:38:51.360
You are responsible for it.

00:38:51.360 --> 00:38:52.860
But it's a little
bit less flexible.

00:38:52.860 --> 00:38:53.984
So there's some trade-offs.

00:38:53.984 --> 00:38:56.860
You can't run a process
longer than 60 seconds.

00:38:56.860 --> 00:38:58.730
You can't write
to the local disk.

00:38:58.730 --> 00:39:00.940
You can't do literally
everything you want.

00:39:00.940 --> 00:39:03.076
So there are some trade-offs.

00:39:03.076 --> 00:39:05.450
So there's got to be something
up here in the upper right

00:39:05.450 --> 00:39:07.726
that's quite flexible
and quite efficient.

00:39:07.726 --> 00:39:08.850
And we'll see what that is.

00:39:08.850 --> 00:39:10.500
Incidentally, I don't
know what this gray box

00:39:10.500 --> 00:39:12.230
is where it's not at
all flexible and not

00:39:12.230 --> 00:39:13.069
at all efficient.

00:39:13.069 --> 00:39:14.985
But I'm pretty sure we
used it at my last job.

00:39:19.780 --> 00:39:24.720
Container Engine is Google's
container orchestration

00:39:24.720 --> 00:39:25.220
offering.

00:39:25.220 --> 00:39:26.890
So you might be asking,
well, what is a container?

00:39:26.890 --> 00:39:28.820
Not everyone knows what a
container-- let me give you

00:39:28.820 --> 00:39:30.050
the super-quick version.

00:39:30.050 --> 00:39:31.600
And if you have
more questions, I

00:39:31.600 --> 00:39:35.050
will be here afterwards
to talk to you about that.

00:39:35.050 --> 00:39:38.360
So let's go back to the
olden days, way back when, of

00:39:38.360 --> 00:39:44.279
say the early 2000s where you
just had a dedicated machine.

00:39:44.279 --> 00:39:45.820
So if you're like
me, I had a startup

00:39:45.820 --> 00:39:48.790
and I just had like one
machine literally under my desk

00:39:48.790 --> 00:39:51.269
in a closet that was running
everything from my startup.

00:39:51.269 --> 00:39:52.560
It was running our mail server.

00:39:52.560 --> 00:39:53.750
It was running our web server.

00:39:53.750 --> 00:39:54.660
It was running our database.

00:39:54.660 --> 00:39:55.701
It was running all those.

00:39:55.701 --> 00:39:58.540
So every app we had
was on our machine.

00:39:58.540 --> 00:39:59.790
And it shared the same kernel.

00:39:59.790 --> 00:40:01.250
And it shared the
same libraries.

00:40:01.250 --> 00:40:03.730
Well, you run into a
few issues with that.

00:40:03.730 --> 00:40:05.760
Specifically, around
sharing libraries

00:40:05.760 --> 00:40:07.340
where maybe this
version of the app

00:40:07.340 --> 00:40:09.610
needs this version
of the library.

00:40:09.610 --> 00:40:11.880
This other app needs
a different version.

00:40:11.880 --> 00:40:13.670
So sometimes they
step on each other.

00:40:13.670 --> 00:40:16.330
If app tanks, it
takes everything down.

00:40:16.330 --> 00:40:17.470
And that sucks.

00:40:17.470 --> 00:40:21.290
So we then moved to a way
called virtual machines.

00:40:21.290 --> 00:40:24.850
So this is each app gets
its own virtual machine-- so

00:40:24.850 --> 00:40:27.579
its own set of libraries
and its own kernel.

00:40:27.579 --> 00:40:29.620
And that's nice because
it's completely isolated.

00:40:29.620 --> 00:40:32.462
If one of the apps tanks, it
doesn't take anything down.

00:40:32.462 --> 00:40:34.420
You know what version of
everything you have is

00:40:34.420 --> 00:40:36.870
because it's
dedicated to that app.

00:40:36.870 --> 00:40:39.070
But it has a big drawback.

00:40:39.070 --> 00:40:42.690
It's like you have a whole
OS just for this other app.

00:40:42.690 --> 00:40:43.910
And that feels like a lot.

00:40:43.910 --> 00:40:45.430
And you have to
manage it as if it

00:40:45.430 --> 00:40:47.164
were its own dedicated machine.

00:40:47.164 --> 00:40:48.580
So it's a huge
amount of overhead.

00:40:48.580 --> 00:40:50.370
So that's a little
bit of overkill.

00:40:50.370 --> 00:40:51.680
So we have containers.

00:40:51.680 --> 00:40:53.670
This is the new
way, ta da, where

00:40:53.670 --> 00:40:57.040
instead of a whole virtual
machine for each app,

00:40:57.040 --> 00:40:59.860
they all share the
same OS kernel.

00:40:59.860 --> 00:41:03.630
But they are isolated from each
other to appear to each app

00:41:03.630 --> 00:41:06.660
as if it has its own OS,
but it doesn't really.

00:41:06.660 --> 00:41:11.100
It's sort of a process
isolation model or analogy.

00:41:11.100 --> 00:41:14.437
So each app has its own
libraries specific to it.

00:41:14.437 --> 00:41:16.395
It could have any version
of whatever it wants.

00:41:16.395 --> 00:41:18.103
It doesn't talk to
any of the other apps.

00:41:18.103 --> 00:41:20.380
If one app tanks, it
doesn't take anything down.

00:41:20.380 --> 00:41:22.950
But you don't have literally
a whole operating system.

00:41:22.950 --> 00:41:25.260
So this gives you a couple
of advantages, one of which

00:41:25.260 --> 00:41:28.030
is you can start up a
container super quickly,

00:41:28.030 --> 00:41:29.230
like within seconds.

00:41:29.230 --> 00:41:31.496
So imagine you need a
new virtual machine.

00:41:31.496 --> 00:41:33.870
It literally has to boot up
a virtual machine, like boop,

00:41:33.870 --> 00:41:39.394
starting, and you get all your
Linux startup scripts running.

00:41:39.394 --> 00:41:40.310
So that takes a while.

00:41:40.310 --> 00:41:42.643
But a container could start
up literally within seconds.

00:41:42.643 --> 00:41:47.150
We have a whole demo-- I
won't, but I can show you--

00:41:47.150 --> 00:41:48.200
that illustrates that.

00:41:48.200 --> 00:41:51.564
So we would like to do
that, because as fast as it

00:41:51.564 --> 00:41:53.980
is to spin up a virtual machine
on Google Compute Engine--

00:41:53.980 --> 00:41:57.180
so like I said, within a minute
or two or three-- containers

00:41:57.180 --> 00:42:00.330
are way faster.

00:42:00.330 --> 00:42:01.880
Do I want to get into this?

00:42:01.880 --> 00:42:03.282
So what is a container?

00:42:03.282 --> 00:42:03.990
How does it work?

00:42:03.990 --> 00:42:04.990
Or how do you define it?

00:42:04.990 --> 00:42:06.076
It's also really nice.

00:42:06.076 --> 00:42:07.700
That's my other half
of the sales pitch

00:42:07.700 --> 00:42:10.239
for containers is that
you sort of declare

00:42:10.239 --> 00:42:12.030
what the environment
is you want to run in.

00:42:12.030 --> 00:42:13.970
So you say, I want to
run an Ubuntu version

00:42:13.970 --> 00:42:19.680
X with PHP version Y with my
custom app code version Z.

00:42:19.680 --> 00:42:22.821
And you declare it in
a configuration file.

00:42:22.821 --> 00:42:25.320
And then you can run it in the
cloud with that configuration

00:42:25.320 --> 00:42:25.640
file.

00:42:25.640 --> 00:42:28.140
You can run it on your desktop
with that configuration file.

00:42:28.140 --> 00:42:30.670
You can run it in QA,
staging, production.

00:42:30.670 --> 00:42:32.460
It's all running off
of that same file.

00:42:32.460 --> 00:42:35.150
So your app will behave the
exact same way everywhere,

00:42:35.150 --> 00:42:37.490
because you have
defined declaratively

00:42:37.490 --> 00:42:38.410
all your dependencies.

00:42:38.410 --> 00:42:41.010
And that's really
nice because it

00:42:41.010 --> 00:42:43.750
helps you avoid the problem
of-- it works on my machine.

00:42:43.750 --> 00:42:45.530
And it works in
development environment.

00:42:45.530 --> 00:42:46.530
And it works in staging.

00:42:46.530 --> 00:42:48.070
But it don't work in production.

00:42:48.070 --> 00:42:49.740
You can actually
say, I want them

00:42:49.740 --> 00:42:53.160
to all have the exact
same runtime environment.

00:42:53.160 --> 00:42:57.887
So hopefully, one day, we'll
put Cloud Spin into containers

00:42:57.887 --> 00:42:59.720
using Container Engine--
it is in containers

00:42:59.720 --> 00:43:03.820
now-- Container Engine,
which is Google's container

00:43:03.820 --> 00:43:04.820
orchestration tool.

00:43:04.820 --> 00:43:06.570
So hopefully, I didn't
bait and switch you

00:43:06.570 --> 00:43:08.528
so you thought that it
was on Container Engine.

00:43:08.528 --> 00:43:10.840
But it is in containers.

00:43:10.840 --> 00:43:12.154
So we're almost done.

00:43:12.154 --> 00:43:13.195
We're at the homestretch.

00:43:15.469 --> 00:43:18.010
We've gotten all the way through
from App Engine Notification

00:43:18.010 --> 00:43:19.339
Processor put into a queue.

00:43:19.339 --> 00:43:20.630
We've extracted all the frames.

00:43:20.630 --> 00:43:22.720
We've stitched
them all together.

00:43:22.720 --> 00:43:23.720
Well, let me back up.

00:43:23.720 --> 00:43:25.303
We haven't stitched
them all together.

00:43:25.303 --> 00:43:27.490
So we've extracted
all the frames.

00:43:27.490 --> 00:43:30.580
And we've put them into some
kind of temporary storage.

00:43:30.580 --> 00:43:31.760
But we run into a problem.

00:43:31.760 --> 00:43:35.294
And the problem is every
time an extractor is done,

00:43:35.294 --> 00:43:37.460
it's putting a stitch message
into the stitch queue.

00:43:37.460 --> 00:43:39.970
So the stitcher is constantly
getting something saying, hey,

00:43:39.970 --> 00:43:41.340
stitch it together.

00:43:41.340 --> 00:43:42.740
But it's getting that 20 times.

00:43:42.740 --> 00:43:44.198
Because it's all
happening randomly

00:43:44.198 --> 00:43:47.690
and in parallel, it's hard
for it to actually know,

00:43:47.690 --> 00:43:51.730
when do I have all 20 frames?

00:43:51.730 --> 00:43:53.810
So you can't just
wait till camera 20

00:43:53.810 --> 00:43:56.109
is done because camera
20 could finish first.

00:43:56.109 --> 00:43:57.400
And then it only has one frame.

00:43:57.400 --> 00:43:59.024
And it can't stitch
one frame together.

00:43:59.024 --> 00:44:01.762
So we have a database
also using Firebase

00:44:01.762 --> 00:44:04.220
that keeps track of all the
frames and whether they're done

00:44:04.220 --> 00:44:05.110
or not.

00:44:05.110 --> 00:44:10.080
So once each extractor is
done-- so frame 1 is done,

00:44:10.080 --> 00:44:11.760
frame 2 is done,
frame 8, frame 10,

00:44:11.760 --> 00:44:13.900
and so forth-- it will get
updated in the database

00:44:13.900 --> 00:44:15.870
and set its status to Ready.

00:44:15.870 --> 00:44:19.440
Then when the stitcher gets its
message, it checks the database

00:44:19.440 --> 00:44:21.010
and says, hey, are 20 done?

00:44:21.010 --> 00:44:21.770
Yes or no?

00:44:21.770 --> 00:44:24.890
So the first one is
no, the second one, no,

00:44:24.890 --> 00:44:25.600
third, et cetera.

00:44:25.600 --> 00:44:27.310
Once it gets to 20,
are all 20 done?

00:44:27.310 --> 00:44:28.450
Yes.

00:44:28.450 --> 00:44:31.570
It goes and pulls images out of
temporary storage and stitches

00:44:31.570 --> 00:44:34.166
them together into
an animated GIF.

00:44:34.166 --> 00:44:35.865
Hooray!

00:44:35.865 --> 00:44:37.740
All right, so let me
run through the problems

00:44:37.740 --> 00:44:39.820
that we're going to solve.

00:44:39.820 --> 00:44:43.110
How do we get all the
cameras to take a photo

00:44:43.110 --> 00:44:44.370
at the exact same moment?

00:44:44.370 --> 00:44:46.350
We record a video,
and we play a beep

00:44:46.350 --> 00:44:50.750
that plays at the exact
moment across all the phones.

00:44:50.750 --> 00:44:52.490
How do we coordinate
all the phones?

00:44:52.490 --> 00:44:54.370
Error messages,
status, so forth.

00:44:54.370 --> 00:44:56.607
We use Firebase--
real-time database.

00:44:56.607 --> 00:44:57.690
Where do we put the files?

00:44:57.690 --> 00:44:59.370
Google Cloud Storage.

00:44:59.370 --> 00:45:00.190
How do we scale?

00:45:00.190 --> 00:45:02.432
We're using Pub/Sub
as a message queue

00:45:02.432 --> 00:45:03.640
to absorb all those messages.

00:45:03.640 --> 00:45:05.765
And then we're using Compute
Engine instance groups

00:45:05.765 --> 00:45:08.160
to autoscale our
compute resources.

00:45:08.160 --> 00:45:09.620
Where do we process our images?

00:45:09.620 --> 00:45:13.480
A Compute Engine virtual machine
running our Python scripts.

00:45:13.480 --> 00:45:15.050
How do we control costs?

00:45:15.050 --> 00:45:19.770
We use the managed
instance groups

00:45:19.770 --> 00:45:25.480
to keep our virtual machine
count as low as possible

00:45:25.480 --> 00:45:28.140
until it needs to scale up.

00:45:28.140 --> 00:45:30.120
How do we create
multiple versions?

00:45:30.120 --> 00:45:31.010
We use Cloud Pub/Sub.

00:45:31.010 --> 00:45:32.320
And we could have
different subscribers

00:45:32.320 --> 00:45:34.194
listening to the same
events and then working

00:45:34.194 --> 00:45:36.615
on different versions of
the final animated GIF.

00:45:36.615 --> 00:45:38.240
And then I didn't
really talk about it,

00:45:38.240 --> 00:45:40.165
but we can use
Google Cloud Logging

00:45:40.165 --> 00:45:42.189
to keep track of everything.

00:45:42.189 --> 00:45:44.480
So we've got a bunch of
different pieces of the system.

00:45:44.480 --> 00:45:47.460
And they can all log to one
central logging location,

00:45:47.460 --> 00:45:48.824
which is Google Cloud Logging.

00:45:48.824 --> 00:45:50.240
So we have one
place to see what's

00:45:50.240 --> 00:45:52.335
going on with our system.

00:45:52.335 --> 00:45:56.220
All right, so I have a demo of
Cloud Spin in action, a video.

00:45:56.220 --> 00:45:59.520
But as luck would
have it, we actually

00:45:59.520 --> 00:46:00.880
have the rig right here.

00:46:00.880 --> 00:46:04.192
So why don't we do an
untested live demo?

00:46:04.192 --> 00:46:06.400
I say untested because we
had it working this morning

00:46:06.400 --> 00:46:07.920
and we literally
haven't touched it.

00:46:07.920 --> 00:46:11.990
So here's hoping
that it still works.

00:46:11.990 --> 00:46:16.350
All right, Mark, you want
to be our guinea pig?

00:46:16.350 --> 00:46:17.310
All right.

00:46:17.310 --> 00:46:18.700
This my colleague Mark.

00:46:18.700 --> 00:46:20.582
Give him a hand everyone, yes.

00:46:20.582 --> 00:46:22.058
[APPLAUSE]

00:46:23.700 --> 00:46:25.115
All right, would you like a toy?

00:46:25.115 --> 00:46:26.490
Do you know what
you're going to?

00:46:26.490 --> 00:46:27.394
MARK: I have no idea.

00:46:27.394 --> 00:46:30.590
BRETT MCGOWEN: All
right, just wing it.

00:46:30.590 --> 00:46:32.173
Tara, are you ready?

00:46:32.173 --> 00:46:33.622
MARK: Might as well jump, yes.

00:46:33.622 --> 00:46:37.486
TARA: All right,
whenever you're ready.

00:46:37.486 --> 00:46:42.316
On the word go.

00:46:42.316 --> 00:46:45.230
And go.

00:46:45.230 --> 00:46:46.940
BRETT MCGOWEN: All right.

00:46:46.940 --> 00:46:49.150
So we have this handy
dandy little visualizer.

00:46:49.150 --> 00:46:50.651
So we can see what's happening.

00:46:50.651 --> 00:46:52.400
It's going to walk us
through the process.

00:46:52.400 --> 00:46:53.740
So this represents each camera.

00:46:53.740 --> 00:46:55.073
So right now, they're uploading.

00:46:55.073 --> 00:46:55.620
They're gray.

00:46:55.620 --> 00:46:57.600
This is the where we
pray to the gods of Wi-Fi

00:46:57.600 --> 00:47:00.020
that they don't hose me over.

00:47:00.020 --> 00:47:01.060
So it's uploading.

00:47:01.060 --> 00:47:01.870
All right, come on.

00:47:01.870 --> 00:47:03.210
Show me the first one.

00:47:03.210 --> 00:47:06.202
Show me the first one.

00:47:06.202 --> 00:47:08.410
All right, I wish I had some
jokes to tell right now.

00:47:08.410 --> 00:47:09.240
Oh, here we go.

00:47:09.240 --> 00:47:10.680
Yes.

00:47:10.680 --> 00:47:13.000
So once it starts spinning,
that means it has now

00:47:13.000 --> 00:47:14.120
made it into the cloud.

00:47:14.120 --> 00:47:17.820
And it's actually processing
and extracting that one frame.

00:47:17.820 --> 00:47:19.786
So, again, it's looking
through the whole video

00:47:19.786 --> 00:47:21.910
and it's finding the frame
where that beep existed.

00:47:21.910 --> 00:47:24.005
This is going to be a good one.

00:47:24.005 --> 00:47:26.380
So you can see, again, it's
all happening asynchronously,

00:47:26.380 --> 00:47:28.220
just random times
that it finishes

00:47:28.220 --> 00:47:30.940
uploading and random times
it actually gets the image.

00:47:30.940 --> 00:47:32.950
And then once we
have them all, it's

00:47:32.950 --> 00:47:34.745
going to go to that
stitcher process

00:47:34.745 --> 00:47:36.790
to stitch them all together.

00:47:36.790 --> 00:47:38.360
All right, only
three more to go.

00:47:38.360 --> 00:47:39.030
Just one.

00:47:42.030 --> 00:47:46.980
[GROANS] Come on, here we go.

00:47:46.980 --> 00:47:47.970
There we go.

00:47:47.970 --> 00:47:48.840
Yay!

00:47:48.840 --> 00:47:49.490
All right.

00:47:49.490 --> 00:47:50.513
Thanks, Mark.

00:47:50.513 --> 00:47:51.902
[APPLAUSE]

00:47:56.080 --> 00:47:59.720
And thank you, Tara, for
driving the control app.

00:47:59.720 --> 00:48:03.500
All right, so we built a
lot in just three weeks.

00:48:03.500 --> 00:48:05.660
And we focused a lot
of the time on coding.

00:48:05.660 --> 00:48:10.030
Almost everything I showed
you from a cloud perspective

00:48:10.030 --> 00:48:12.060
is a managed service by Google.

00:48:12.060 --> 00:48:14.680
So the least managed bit
of that is Compute Engine,

00:48:14.680 --> 00:48:17.030
which is our actual
virtual machine

00:48:17.030 --> 00:48:18.850
that we installed
the Python scripts on

00:48:18.850 --> 00:48:20.940
to process the image.

00:48:20.940 --> 00:48:23.540
Most of our time was
either in the Android app

00:48:23.540 --> 00:48:26.200
working on that experience
or working on the code

00:48:26.200 --> 00:48:28.540
to extract the images,
to analyze the video,

00:48:28.540 --> 00:48:31.010
so in other words,
sort of the core

00:48:31.010 --> 00:48:32.681
features of our application.

00:48:32.681 --> 00:48:34.430
And that's the message
I want to leave you

00:48:34.430 --> 00:48:36.721
with is that we have a lot
of managed services in cloud

00:48:36.721 --> 00:48:39.404
at Google for the
Google Cloud platform.

00:48:39.404 --> 00:48:40.820
That means you
don't have to worry

00:48:40.820 --> 00:48:42.790
about a lot of that
infrastructure.

00:48:42.790 --> 00:48:44.210
It can scale for you.

00:48:44.210 --> 00:48:48.220
It can handle network
traffic for you.

00:48:48.220 --> 00:48:49.579
It can absorb those in a queue.

00:48:49.579 --> 00:48:51.120
There's a lot of
stuff that you don't

00:48:51.120 --> 00:48:52.578
have to worry--
that you don't want

00:48:52.578 --> 00:48:53.880
to worry about as a developer.

00:48:53.880 --> 00:48:56.630
You want to spend your time
sort of like this Android

00:48:56.630 --> 00:49:00.070
guy working on that app
and in image processing.

00:49:00.070 --> 00:49:01.730
So there's a whole
bunch of stuff

00:49:01.730 --> 00:49:03.550
that I threw at you
just pretty much

00:49:03.550 --> 00:49:05.022
like half of what we offer.

00:49:05.022 --> 00:49:07.230
So if you have any more
questions about any of those,

00:49:07.230 --> 00:49:09.063
myself and a bunch of
my teammates are here.

00:49:09.063 --> 00:49:12.210
We would love to talk to you,
answer any of your questions,

00:49:12.210 --> 00:49:15.230
and most importantly, come
get your own Cloud Spin.

00:49:15.230 --> 00:49:18.390
We will have this running from
the minute I finish, which

00:49:18.390 --> 00:49:21.450
is almost here, till
this evening sometime

00:49:21.450 --> 00:49:24.250
kind of when it dies
down in the after party.

00:49:24.250 --> 00:49:26.590
So thank you so much.

00:49:26.590 --> 00:49:28.508
[APPLAUSE]

00:49:31.135 --> 00:49:33.260
And I maybe have a couple
of minutes for questions,

00:49:33.260 --> 00:49:33.700
actually.

00:49:33.700 --> 00:49:34.658
Anybody have questions?

00:49:34.658 --> 00:49:35.740
Yeah.

00:49:35.740 --> 00:49:37.490
AUDIENCE: So I've
noticed in some of them,

00:49:37.490 --> 00:49:39.680
like the sample you
did just a moment ago,

00:49:39.680 --> 00:49:41.560
there is still some jitter.

00:49:41.560 --> 00:49:46.936
So do you think that
given enough tuning time,

00:49:46.936 --> 00:49:48.560
you'd be able to get
rid of the jitter?

00:49:48.560 --> 00:49:48.970
BRETT MCGOWEN: Yeah.

00:49:48.970 --> 00:49:51.856
So the question is there's still
a little bit of jitter in that.

00:49:51.856 --> 00:49:53.530
And that can be
caused by two things.

00:49:53.530 --> 00:49:55.670
One is alignment of the cameras.

00:49:55.670 --> 00:49:58.016
So it is a very manual
process that we align them.

00:49:58.016 --> 00:50:00.390
We literally-- actually, we
took two tables, stacked them

00:50:00.390 --> 00:50:01.265
on top of each other.

00:50:01.265 --> 00:50:02.390
We marked a pole.

00:50:02.390 --> 00:50:05.530
And on the viewfinder, there's
like these cross hairs.

00:50:05.530 --> 00:50:08.060
And we aligned the cross
hairs, literally manually,

00:50:08.060 --> 00:50:10.520
like moving the phone in
the mount to line them up.

00:50:10.520 --> 00:50:12.190
So that's pretty imperfect.

00:50:12.190 --> 00:50:13.730
The second is the
video we're taking

00:50:13.730 --> 00:50:17.710
is 30 frames per second,
which is actually

00:50:17.710 --> 00:50:20.510
less than 20 seconds--
it's worse than 20 seconds

00:50:20.510 --> 00:50:21.010
difference.

00:50:21.010 --> 00:50:23.630
So we actually still can
end up with some jitter.

00:50:23.630 --> 00:50:25.520
So what we could do
is actually record

00:50:25.520 --> 00:50:27.000
a 60 frame per second video.

00:50:27.000 --> 00:50:28.750
That would get us
more precision to find

00:50:28.750 --> 00:50:31.530
that one frame more precisely.

00:50:31.530 --> 00:50:33.870
Realistically, the main
reason we didn't do that is it

00:50:33.870 --> 00:50:36.724
takes a while to upload
on the Wi-Fi as it is.

00:50:36.724 --> 00:50:39.140
So if we doubled the file size,
it would take a long time.

00:50:39.140 --> 00:50:40.500
So there's some of that.

00:50:40.500 --> 00:50:44.470
We also have some sort of image
smoothing, image stabilization

00:50:44.470 --> 00:50:46.571
algorithms that we
can run on that.

00:50:46.571 --> 00:50:49.070
We're still fiddling with that
because what that tends to do

00:50:49.070 --> 00:50:52.380
is it finds all the
common areas of the images

00:50:52.380 --> 00:50:55.270
and then overlays them
and then crops out

00:50:55.270 --> 00:50:58.570
anything that is outside
of the area that's

00:50:58.570 --> 00:50:59.610
common to everything.

00:50:59.610 --> 00:51:02.150
But what that tends to do
is zoom in way on the image.

00:51:02.150 --> 00:51:04.722
So you end up with a lot of
Cloud Spins with people's heads

00:51:04.722 --> 00:51:05.930
cut off and things like that.

00:51:05.930 --> 00:51:08.870
So that's an algorithmic
thing that we're working on

00:51:08.870 --> 00:51:12.266
to make it a little bit better.

00:51:12.266 --> 00:51:17.570
So mostly, it's
precision in the number

00:51:17.570 --> 00:51:20.060
of frames in the video and
then just manual alignment.

00:51:20.060 --> 00:51:22.890
I mean, people bump the rig
and that moves the cameras

00:51:22.890 --> 00:51:24.910
and things like that.

00:51:24.910 --> 00:51:27.355
There are more aggressive
ways we can smooth that.

00:51:27.355 --> 00:51:29.480
But it also tends to
introduce a lot of artifacting

00:51:29.480 --> 00:51:31.650
into the image
where there's things

00:51:31.650 --> 00:51:33.610
like your elbow
is like super-long

00:51:33.610 --> 00:51:36.890
or whatever to get that going.

00:51:36.890 --> 00:51:38.190
Any other questions?

00:51:38.190 --> 00:51:39.392
Yeah?

00:51:39.392 --> 00:51:43.360
AUDIENCE: What are the
best case and worst case

00:51:43.360 --> 00:51:47.478
and conventional latency
you get on the Firebase

00:51:47.478 --> 00:51:48.787
synchronization?

00:51:48.787 --> 00:51:49.620
BRETT MCGOWEN: Yeah.

00:51:49.620 --> 00:51:51.950
So the question is
latency in Firebase.

00:51:51.950 --> 00:51:53.530
What's the best
case, worst case?

00:51:56.430 --> 00:51:57.760
I don't want to promise you.

00:51:57.760 --> 00:52:00.190
But I feel like typically,
it's around 100 milliseconds,

00:52:00.190 --> 00:52:01.060
maybe a little less.

00:52:01.060 --> 00:52:03.530
That's if you're
looking for something

00:52:03.530 --> 00:52:08.640
to ballpark what it
feels like normally,

00:52:08.640 --> 00:52:09.680
which is pretty quick.

00:52:09.680 --> 00:52:13.480
So it's not necessarily fast
enough to tell all these phones

00:52:13.480 --> 00:52:15.850
with Firebase,
take a picture now.

00:52:15.850 --> 00:52:16.600
But it gets close.

00:52:16.600 --> 00:52:17.950
So a lot of games are
written with Firebase.

00:52:17.950 --> 00:52:19.450
And latency, of
course, as you know,

00:52:19.450 --> 00:52:22.980
is super-important
in that respect.

00:52:22.980 --> 00:52:27.630
So we have collaborative
drawing apps and things.

00:52:27.630 --> 00:52:30.195
And as you draw, you
could see it translate

00:52:30.195 --> 00:52:31.320
on someone else's computer.

00:52:31.320 --> 00:52:32.824
So it's pretty quick.

00:52:32.824 --> 00:52:33.657
Any other questions?

00:52:36.150 --> 00:52:36.650
All right.

00:52:36.650 --> 00:52:37.899
Again, thank you guys so much.

00:52:37.899 --> 00:52:39.250
And come get a Cloud Spin.

00:52:39.250 --> 00:52:41.650
[APPLAUSE]

00:52:41.650 --> 00:52:44.700
[MUSIC  PLAYING]

