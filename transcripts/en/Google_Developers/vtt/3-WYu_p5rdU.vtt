WEBVTT
Kind: captions
Language: en

00:00:05.616 --> 00:00:06.870
MATT DELANEY: Hi, everyone.

00:00:06.870 --> 00:00:08.780
So to start off this performance
talk, welcome to

00:00:08.780 --> 00:00:10.810
potentially the juiciest
talk of the day.

00:00:10.810 --> 00:00:13.900
You have people who are nice and
hangry before lunch here.

00:00:13.900 --> 00:00:18.310
So just to be clear, there were
some kind of questions in

00:00:18.310 --> 00:00:21.910
our moderation tool for this
panel that were kind of

00:00:21.910 --> 00:00:23.430
overlapping with some
previous talks.

00:00:23.430 --> 00:00:25.440
Because performance is
everywhere, right?

00:00:25.440 --> 00:00:29.870
So if you look at some of the
questions relating to strictly

00:00:29.870 --> 00:00:32.330
kind of network performance
things, those are mostly

00:00:32.330 --> 00:00:33.280
covered in previous talks.

00:00:33.280 --> 00:00:34.800
We'll mostly skip over those.

00:00:34.800 --> 00:00:37.610
So now is your moment to put in
any juicier questions for

00:00:37.610 --> 00:00:40.890
front end things, especially
graphics, and all the kind of

00:00:40.890 --> 00:00:42.790
client side related performance

00:00:42.790 --> 00:00:44.480
concerns you guys have.

00:00:44.480 --> 00:00:45.990
So very quickly, I'm going
to run through.

00:00:45.990 --> 00:00:49.105
We've got our opening speaker
here, Shane O'Sullivan.

00:00:49.105 --> 00:00:51.595
So he's from Facebook,
a UI engineer.

00:00:51.595 --> 00:00:53.540
He'll introduce himself
a little bit more.

00:00:53.540 --> 00:00:56.720
We have Pavel Feldman
from Google.

00:00:56.720 --> 00:00:59.150
He has worked on Chrome
dev tools.

00:00:59.150 --> 00:01:02.426
And we have Rowan Beesje?

00:01:02.426 --> 00:01:03.530
ROWAN BEENJE: Beenje.

00:01:03.530 --> 00:01:04.720
MATT DELANEY: OK.

00:01:04.720 --> 00:01:05.900
Knew I was going to
mess that one up.

00:01:05.900 --> 00:01:08.945
So he works at FT Labs
with Andrew, and is

00:01:08.945 --> 00:01:11.370
known for FT Scroller.

00:01:11.370 --> 00:01:14.010
And then we have Chris Lord
from Mozilla, who is a

00:01:14.010 --> 00:01:19.340
platform engineer for
Firefox mobile, so

00:01:19.340 --> 00:01:21.430
primarily on Android.

00:01:21.430 --> 00:01:23.840
So to start, Shane has a little
opening talk for us to

00:01:23.840 --> 00:01:25.870
give us a bit of the
lay of the land of

00:01:25.870 --> 00:01:27.120
performance at the moment.

00:01:35.370 --> 00:01:38.620
SHANE O'SULLIVAN:
So hi, everyone.

00:01:38.620 --> 00:01:39.670
I'm Shane O'Sullivan.

00:01:39.670 --> 00:01:42.840
I work as a UI engineer
at Facebook.

00:01:42.840 --> 00:01:44.220
I spent a couple of years
on the mobile site.

00:01:44.220 --> 00:01:47.810
And now I work on our
business interfaces.

00:01:47.810 --> 00:01:51.890
As he said, I'm here with
Ron, Chris, and Pavel.

00:01:51.890 --> 00:01:55.520
And we're going to talk a bit
about some of the potholes

00:01:55.520 --> 00:01:59.670
that are in the road to actually
having a performant

00:01:59.670 --> 00:02:04.410
and fast and non-stuttery
website.

00:02:04.410 --> 00:02:06.930
The two main things I'm really
going to talk about are

00:02:06.930 --> 00:02:13.480
scrolling performance of complex
content, which is more

00:02:13.480 --> 00:02:14.780
or less a stress test
for all rendering

00:02:14.780 --> 00:02:16.260
platforms, not just web.

00:02:16.260 --> 00:02:18.160
People also have a problem
with this on iOS.

00:02:18.160 --> 00:02:21.140
God knows they have a problem
with it on Android.

00:02:21.140 --> 00:02:23.560
And it more or less
forces us to solve

00:02:23.560 --> 00:02:24.910
all the other problems.

00:02:24.910 --> 00:02:26.610
And second one is memory
management,

00:02:26.610 --> 00:02:29.560
which is quite related.

00:02:29.560 --> 00:02:30.950
So to start off, let's
say what the goal is.

00:02:30.950 --> 00:02:33.270
The goal is 60 frames per
second animation with no

00:02:33.270 --> 00:02:35.070
dropped frames.

00:02:35.070 --> 00:02:36.220
This is kind of the panacea.

00:02:36.220 --> 00:02:37.470
Everybody wants to get here.

00:02:40.580 --> 00:02:42.880
But it's not always possible.

00:02:42.880 --> 00:02:45.310
So let's have a fallback goal.

00:02:45.310 --> 00:02:49.480
And say, if we can get to 30
frames per second animations.

00:02:49.480 --> 00:02:50.820
Make this reliable.

00:02:50.820 --> 00:02:53.390
Make it have no stuttering.

00:02:53.390 --> 00:02:55.390
This often is achievable.

00:02:55.390 --> 00:02:59.900
And in a lot of user tests that
we've done, this tends to

00:02:59.900 --> 00:03:01.890
perform a lot better than having
something that runs at

00:03:01.890 --> 00:03:05.305
60 frames per second some of the
time, and even 40 frames

00:03:05.305 --> 00:03:06.920
per second some of the time.

00:03:06.920 --> 00:03:11.000
So if it goes from some 60 down
to 40, back up to 60,

00:03:11.000 --> 00:03:12.990
people often see that as being
worse than just having a

00:03:12.990 --> 00:03:14.498
steady 30 frames per
second animation.

00:03:17.730 --> 00:03:19.920
So nice to have 60.

00:03:19.920 --> 00:03:21.960
If we can get a steady 30,
you're generally in a fairly

00:03:21.960 --> 00:03:24.300
good place.

00:03:24.300 --> 00:03:25.740
So what's stopping
us getting there?

00:03:25.740 --> 00:03:27.880
There's a whole bunch
of things.

00:03:27.880 --> 00:03:30.130
To start of with is the
large DOM size.

00:03:30.130 --> 00:03:32.670
If you want to take something
like Facebook newsfeed, you

00:03:32.670 --> 00:03:36.950
have variable height rows made
up of large images, small

00:03:36.950 --> 00:03:39.720
images, no images, variable
length text, everything

00:03:39.720 --> 00:03:42.490
changes size, and you don't
know what size it is until

00:03:42.490 --> 00:03:43.740
you're trying to show
it to somebody.

00:03:46.120 --> 00:03:48.630
And also, if you have thousands
of these, which you

00:03:48.630 --> 00:03:52.470
technically could, the browser
just starts running into

00:03:52.470 --> 00:03:54.010
serious memory problems.

00:03:54.010 --> 00:03:55.290
So you have to decide things.

00:03:55.290 --> 00:03:55.910
When do you create it?

00:03:55.910 --> 00:03:59.150
Do you create it up front
and take an upfront hit?

00:03:59.150 --> 00:04:03.610
Do you create it lazily, and
take a hit as people are using

00:04:03.610 --> 00:04:05.040
your application?

00:04:05.040 --> 00:04:07.230
That often depends on what
you're trying to build.

00:04:07.230 --> 00:04:09.760
For example, Gmail takes
a hit up front.

00:04:09.760 --> 00:04:12.820
Because they expect you to leave
the tab open for weeks.

00:04:12.820 --> 00:04:15.520
Facebook goes the other way,
because it's more of a random

00:04:15.520 --> 00:04:16.529
browsing experience.

00:04:16.529 --> 00:04:20.600
And they try to make the upfront
hit very small, and

00:04:20.600 --> 00:04:21.850
render later.

00:04:25.260 --> 00:04:25.660
OK.

00:04:25.660 --> 00:04:28.972
So one of the main problems we
have is, if you want to keep

00:04:28.972 --> 00:04:32.240
the DOM small, that basically
means you've got to change it

00:04:32.240 --> 00:04:32.830
on the fly.

00:04:32.830 --> 00:04:34.460
If you have a lot of data to
show, and you don't want to

00:04:34.460 --> 00:04:36.920
have a big tree, you've got
to change it on the fly.

00:04:36.920 --> 00:04:38.960
And that basically is great.

00:04:38.960 --> 00:04:40.550
You've got a nice, small DOM.

00:04:40.550 --> 00:04:42.680
But that introduces a whole
bunch of other problems, which

00:04:42.680 --> 00:04:44.670
we're going to get into.

00:04:44.670 --> 00:04:46.710
One solution people come up
with is have a pool of

00:04:46.710 --> 00:04:48.830
reusable DOM elements.

00:04:48.830 --> 00:04:50.380
Say you have 20 different
types of

00:04:50.380 --> 00:04:51.770
rows you want to show.

00:04:51.770 --> 00:04:53.670
Have a pool of each of
them, and reuse them.

00:04:53.670 --> 00:04:57.690
So that way you don't go from a
small image to a big image,

00:04:57.690 --> 00:04:58.940
back to a small image.

00:04:58.940 --> 00:05:02.630
Something with no images,
something with text only.

00:05:02.630 --> 00:05:04.770
So this can help.

00:05:04.770 --> 00:05:07.740
But you still end up with
kicking off page reflows if

00:05:07.740 --> 00:05:08.990
you're not careful.

00:05:11.670 --> 00:05:15.630
Also, when you do start changing
things, say you go

00:05:15.630 --> 00:05:18.255
from a small bit of text to a
long bit of text, even inside

00:05:18.255 --> 00:05:19.900
of something that you haven't
technically changed the

00:05:19.900 --> 00:05:21.830
structure of, you can change
the height of it, you can

00:05:21.830 --> 00:05:23.590
change the width of it.

00:05:23.590 --> 00:05:24.990
And often, you need
to know this.

00:05:24.990 --> 00:05:27.420
If you haven't measured
everything ahead of time, then

00:05:27.420 --> 00:05:29.390
you need to know how
big something is.

00:05:29.390 --> 00:05:31.620
For example, if you want to show
somebody a scroll bar,

00:05:31.620 --> 00:05:34.010
they have to know
what size it is.

00:05:34.010 --> 00:05:37.880
But the main problem with this
is that touching the

00:05:37.880 --> 00:05:39.550
DOM makes Ryan sad.

00:05:39.550 --> 00:05:41.020
It makes him very, very sad.

00:05:41.020 --> 00:05:43.200
And you don't want
to make Ryan sad.

00:05:43.200 --> 00:05:48.630
So measuring the size of a DOM
load, it basically stops

00:05:48.630 --> 00:05:49.030
everything.

00:05:49.030 --> 00:05:53.110
Makes the browser flush all its
pending operations, and

00:05:53.110 --> 00:05:54.790
slows everything down.

00:05:54.790 --> 00:05:56.670
So what do we do?

00:05:56.670 --> 00:05:58.090
We'd like to keep it
off the UI thread.

00:05:58.090 --> 00:06:00.310
This is possible in native.

00:06:00.310 --> 00:06:02.810
For example, the Facebook for
iOS app has a completely

00:06:02.810 --> 00:06:04.930
separate thread that more or
less does everything the UI

00:06:04.930 --> 00:06:07.050
thread does, but does it
off the UI thread.

00:06:07.050 --> 00:06:08.710
Measures everything, renders
everything, and then just

00:06:08.710 --> 00:06:09.450
passes it over.

00:06:09.450 --> 00:06:10.690
That would be lovely.

00:06:10.690 --> 00:06:12.690
We can't do that.

00:06:12.690 --> 00:06:15.640
One reason is we don't
always have workers

00:06:15.640 --> 00:06:16.530
on the latest iOS.

00:06:16.530 --> 00:06:19.380
We do on Android.

00:06:19.380 --> 00:06:20.900
But we don't always.

00:06:20.900 --> 00:06:22.950
Also workers on a single
CPU are slow.

00:06:22.950 --> 00:06:25.190
If you're trying to run a worker
on iPhone 4, which only

00:06:25.190 --> 00:06:28.400
has a single core, you're not
really getting any gain.

00:06:28.400 --> 00:06:30.070
I mean yes, it's different
thread.

00:06:30.070 --> 00:06:32.660
But it runs on the same CPU.

00:06:32.660 --> 00:06:34.250
And anyway, workers
can't be DOM.

00:06:34.250 --> 00:06:35.500
So this doesn't really
help you.

00:06:38.740 --> 00:06:40.510
So what can we do?

00:06:40.510 --> 00:06:41.190
Hide the scroll bar.

00:06:41.190 --> 00:06:42.910
Don't tell people how
much stuff's there.

00:06:42.910 --> 00:06:46.710
It's a dirty hack,
but it works.

00:06:46.710 --> 00:06:49.170
You don't have to measure a
thousand rows, because just

00:06:49.170 --> 00:06:49.570
don't tell them.

00:06:49.570 --> 00:06:51.670
Just tell them keep scrolling.

00:06:51.670 --> 00:06:53.170
But some people like
scroll bars.

00:06:53.170 --> 00:06:56.100
So another thing you can do
is measure when not busy.

00:06:56.100 --> 00:06:57.570
This can be fairly tricky.

00:06:57.570 --> 00:06:59.030
Because when are you not busy?

00:06:59.030 --> 00:07:00.160
You're not touching it now.

00:07:00.160 --> 00:07:03.010
What if you start measuring,
you say, I'm going to spend

00:07:03.010 --> 00:07:06.595
100 milliseconds measuring
the next X things.

00:07:06.595 --> 00:07:08.385
Then in the middle of that 100
milliseconds, someone touches

00:07:08.385 --> 00:07:12.350
a page and you miss it because
your JavaScript is running.

00:07:12.350 --> 00:07:15.410
You can try and measure in the
middle of a frame, which we've

00:07:15.410 --> 00:07:18.145
done before, where we figured,
I spent five milliseconds out

00:07:18.145 --> 00:07:21.230
of the 16 or 32 millisecond
frame.

00:07:21.230 --> 00:07:24.520
And I'm going to use the
rest to render ahead.

00:07:24.520 --> 00:07:25.540
That can work.

00:07:25.540 --> 00:07:27.370
But it's really tricky to do.

00:07:27.370 --> 00:07:29.350
Something that we're starting to
play with now a bit as well

00:07:29.350 --> 00:07:33.165
is measuring on the server,
which is just something we're

00:07:33.165 --> 00:07:34.230
only prototyping
at the moment.

00:07:34.230 --> 00:07:37.650
But we figure in our use case,
we have at max a few thousand

00:07:37.650 --> 00:07:42.660
different ways to arrange all
the individual types of things

00:07:42.660 --> 00:07:43.140
on the newsfeed.

00:07:43.140 --> 00:07:45.490
And if you have an app like
that, then you can technically

00:07:45.490 --> 00:07:46.520
the DOM ahead of time.

00:07:46.520 --> 00:07:47.970
Figure out what you fit into.

00:07:47.970 --> 00:07:51.340
And just never measure
the DOM at all.

00:07:51.340 --> 00:07:52.680
I'm hopeful this might help.

00:07:52.680 --> 00:07:55.530
But it doesn't fit
every use case.

00:07:55.530 --> 00:07:58.750
But if it does, then measure
things once, and then never

00:07:58.750 --> 00:08:00.000
measure them again.

00:08:02.820 --> 00:08:05.770
Another annoying thing
is repaints.

00:08:05.770 --> 00:08:08.640
Most of this comes in because
images are unpredictable.

00:08:08.640 --> 00:08:10.950
They load when you don't want
them to load, like when you're

00:08:10.950 --> 00:08:12.620
in the middle of an animation.

00:08:12.620 --> 00:08:14.410
They load the wrong size, so
you end up clipping them,

00:08:14.410 --> 00:08:15.980
which has its own cost.

00:08:15.980 --> 00:08:18.190
Or you end up resizing them,
and it has a massive cost,

00:08:18.190 --> 00:08:19.860
which some of the people were
talking about earlier.

00:08:19.860 --> 00:08:22.390
Not just network costs, but
obviously performance cost.

00:08:22.390 --> 00:08:24.660
And finally, they have
to be decoded.

00:08:24.660 --> 00:08:27.340
As we just heard, WebP takes
longer to decode than JPEG,

00:08:27.340 --> 00:08:29.640
and JPEG is bad enough
as it is.

00:08:29.640 --> 00:08:31.640
So if you're decoding things in
the middle of an animation,

00:08:31.640 --> 00:08:35.280
then you're going to
have a bad time.

00:08:35.280 --> 00:08:36.299
So what do you do?

00:08:36.299 --> 00:08:38.210
Some people defer all
image loading until

00:08:38.210 --> 00:08:40.059
you finish an animation.

00:08:40.059 --> 00:08:41.370
This is for new images.

00:08:41.370 --> 00:08:42.020
That can work.

00:08:42.020 --> 00:08:44.680
But it looks bad.

00:08:44.680 --> 00:08:47.150
You have a big, empty thing
scrolling by with a little bit

00:08:47.150 --> 00:08:48.480
of black text and a
couple of links.

00:08:48.480 --> 00:08:50.820
And when you stop, everything
pops in.

00:08:50.820 --> 00:08:51.620
It works.

00:08:51.620 --> 00:08:52.870
You get nice animation.

00:08:52.870 --> 00:08:55.090
And as a start, it's good.

00:08:55.090 --> 00:08:57.440
Other people use low res images,
which have a lower

00:08:57.440 --> 00:08:58.210
decode cost.

00:08:58.210 --> 00:09:02.010
But it still costs paint.

00:09:02.010 --> 00:09:06.590
And what we're doing now, or
trying to do, is figure out

00:09:06.590 --> 00:09:08.990
how much time each particular
operation, including text

00:09:08.990 --> 00:09:12.310
changes and image changes,
take per animation frame.

00:09:12.310 --> 00:09:15.790
And we figure we have a 16
millisecond animation frame.

00:09:15.790 --> 00:09:17.500
We have used 10 milliseconds.

00:09:17.500 --> 00:09:19.710
It normally takes 6
milliseconds to

00:09:19.710 --> 00:09:20.740
draw a small image.

00:09:20.740 --> 00:09:22.110
So we still have time.

00:09:22.110 --> 00:09:23.330
And if we don't, then
we defer it.

00:09:23.330 --> 00:09:24.660
And you do get a blank image.

00:09:24.660 --> 00:09:27.300
And that gives you the nice
effect of, sometimes you'll

00:09:27.300 --> 00:09:30.000
see images scrolling past or
images popping in in the

00:09:30.000 --> 00:09:30.890
middle of a scroll.

00:09:30.890 --> 00:09:34.240
Sometimes, you don't get to
it, but it tends to look

00:09:34.240 --> 00:09:36.180
better than the first one.

00:09:36.180 --> 00:09:36.720
That's very hard.

00:09:36.720 --> 00:09:38.100
You've got to write
that yourself.

00:09:38.100 --> 00:09:40.590
You've got to write
it in JavaScript.

00:09:40.590 --> 00:09:42.680
Would be nice if browsers did
these things for you.

00:09:42.680 --> 00:09:45.450
But hopefully, we might get
there at some point.

00:09:45.450 --> 00:09:47.360
And another one is resizing.

00:09:47.360 --> 00:09:49.650
A lot of people think that
resizing images, like just

00:09:49.650 --> 00:09:50.300
don't resize.

00:09:50.300 --> 00:09:52.700
Don't do it, just clip them.

00:09:52.700 --> 00:09:55.100
Often, you can't, as people were
talking about earlier.

00:09:55.100 --> 00:09:57.360
Like Jackson was mentioning
at Facebook, we have four

00:09:57.360 --> 00:09:58.980
different sizes of images
that we use.

00:09:58.980 --> 00:10:00.860
And if you clip them too much,
then it just looks terrible.

00:10:00.860 --> 00:10:03.370
You cut off people's heads,
and that kind of thing.

00:10:03.370 --> 00:10:07.030
And saying OK, just ship
the right size.

00:10:07.030 --> 00:10:08.270
Shipping the right
size is hard.

00:10:08.270 --> 00:10:10.330
You've got massive
server costs.

00:10:10.330 --> 00:10:14.320
It helps you to be a large
corporation, where you can

00:10:14.320 --> 00:10:18.760
tell like Akamai, we really,
really need a solution here.

00:10:18.760 --> 00:10:19.820
And they will help you.

00:10:19.820 --> 00:10:20.980
If you're not a large
corporation,

00:10:20.980 --> 00:10:22.480
you can't do that.

00:10:22.480 --> 00:10:26.710
It's very hard to say that if
say I want a 57 by 57 pixel

00:10:26.710 --> 00:10:29.170
image, you must serve
it to me.

00:10:29.170 --> 00:10:31.930
So one thing you can do is get
designers to calm down a

00:10:31.930 --> 00:10:33.180
little bit.

00:10:33.180 --> 00:10:36.970
And just tell them, don't try
loading images in subtly

00:10:36.970 --> 00:10:38.525
different pixel sizes.

00:10:38.525 --> 00:10:41.800
Do you really need a 50
and a 52 pixel image?

00:10:41.800 --> 00:10:43.860
Maybe you don't.

00:10:43.860 --> 00:10:47.890
Then just have a single 50 pixel
image and you're done.

00:10:47.890 --> 00:10:49.800
Designers like to have a free
hand in everything.

00:10:49.800 --> 00:10:51.900
But reality has to come into
play at some point.

00:10:54.460 --> 00:10:57.590
So one of the final things
is decoding JPEGs.

00:10:57.590 --> 00:10:59.370
A lot of people don't
think about this.

00:10:59.370 --> 00:11:03.910
A lot of people, they look at
the timeline on Chrome.

00:11:03.910 --> 00:11:05.880
And you see a lot of paints
and that kind of thing.

00:11:05.880 --> 00:11:08.940
But decoding JPEGs can be a very
large hit, almost as much

00:11:08.940 --> 00:11:10.960
as painting sometimes.

00:11:10.960 --> 00:11:12.520
One thing we're playing
with is doing

00:11:12.520 --> 00:11:13.810
it in a worker thread.

00:11:13.810 --> 00:11:16.120
Doing XHR to the server, get
down the data for a JPEG.

00:11:16.120 --> 00:11:19.000
Decode it in JavaScript on a
worker thread, ship the data

00:11:19.000 --> 00:11:21.280
UI off to the image
on the UI thread.

00:11:21.280 --> 00:11:23.000
And then you're only paying
for the paint.

00:11:23.000 --> 00:11:24.190
In some cases, that works.

00:11:24.190 --> 00:11:25.410
In some cases, it doesn't.

00:11:25.410 --> 00:11:26.630
We've only rolled out a test.

00:11:26.630 --> 00:11:29.410
But for large images,
it seems to work.

00:11:29.410 --> 00:11:30.770
For small images, it doesn't.

00:11:30.770 --> 00:11:31.380
It's horrible.

00:11:31.380 --> 00:11:33.920
And I wish we could have off
thread JPEG decoding.

00:11:33.920 --> 00:11:38.495
But such as it is, it still
slows down our scrolling.

00:11:38.495 --> 00:11:39.745
Alex looks thoughtful.

00:11:43.100 --> 00:11:44.920
Obviously, there are other
good solutions to this.

00:11:44.920 --> 00:11:46.980
But hopefully, the guys will
know some of them.

00:11:46.980 --> 00:11:49.820
And the last one that we're
probably going to end up

00:11:49.820 --> 00:11:53.440
mentioning is GC, which
everybody knows stands for

00:11:53.440 --> 00:11:56.410
Gremlin Carnage.

00:11:56.410 --> 00:11:57.800
OK, it really stands for
garbage collection.

00:11:57.800 --> 00:11:59.570
But it might as well stand
for Gremlin Carnage.

00:11:59.570 --> 00:12:01.640
Because it's just this random
little monster that runs

00:12:01.640 --> 00:12:04.270
around, and makes
you very sad.

00:12:04.270 --> 00:12:06.040
Unless when he looks really
cute like that, and then

00:12:06.040 --> 00:12:07.870
everything's good.

00:12:07.870 --> 00:12:11.740
So with garbage collection, you
put all this effort into

00:12:11.740 --> 00:12:15.140
having a fantastically good,
smooth animation.

00:12:15.140 --> 00:12:17.500
And then something random comes
in and takes up 100

00:12:17.500 --> 00:12:19.180
milliseconds and kills
everything.

00:12:19.180 --> 00:12:21.660
V8 has, in the last
year or so--

00:12:21.660 --> 00:12:25.090
year, 18 months-- come up with
incremental GC, which spreads

00:12:25.090 --> 00:12:25.720
the load a bit.

00:12:25.720 --> 00:12:28.790
But you still get hit by these
large mark sweep things that

00:12:28.790 --> 00:12:31.330
can still take a large
amount of time.

00:12:31.330 --> 00:12:33.460
One thing you can do is just
go through your whole code,

00:12:33.460 --> 00:12:36.060
and micro-optimize absolutely
every tiny little piece to not

00:12:36.060 --> 00:12:40.220
use memory, to reuse events, to
reuse all sorts of things.

00:12:40.220 --> 00:12:40.970
It's painstaking.

00:12:40.970 --> 00:12:42.620
It takes forever.

00:12:42.620 --> 00:12:44.540
And I don't know of
a silver bullet.

00:12:44.540 --> 00:12:48.910
But we will be discussing this,
and hopefully somebody

00:12:48.910 --> 00:12:51.920
has a silver bullet,
because I want one.

00:12:51.920 --> 00:12:52.160
All right.

00:12:52.160 --> 00:12:54.628
And with that, let's get
on with the questions.

00:12:54.628 --> 00:12:55.880
MATT DELANEY: Thanks, Shane.

00:13:02.910 --> 00:13:05.020
So I'm not sure exactly where,
but somewhere out there

00:13:05.020 --> 00:13:05.530
there's another mic.

00:13:05.530 --> 00:13:08.310
So just keep in mind for this
panel, we have a roving mic

00:13:08.310 --> 00:13:10.650
that will magically appear
as you need it.

00:13:10.650 --> 00:13:14.140
So we're hoping for even more
people talking in this talk

00:13:14.140 --> 00:13:15.650
from the audience, because
everyone deals with

00:13:15.650 --> 00:13:17.350
performance.

00:13:17.350 --> 00:13:17.600
OK.

00:13:17.600 --> 00:13:19.390
So the first question here.

00:13:24.510 --> 00:13:27.360
So from our very own Andrew
Betts, we have the first

00:13:27.360 --> 00:13:30.605
question which is, with longer
and longer lived pages, will

00:13:30.605 --> 00:13:33.170
web developers start having
to spend time on memory

00:13:33.170 --> 00:13:33.900
management?

00:13:33.900 --> 00:13:35.500
And is that a good thing?

00:13:35.500 --> 00:13:38.774
And I'd like to start off Rowan
with this question.

00:13:38.774 --> 00:13:40.490
ROWAN BEENJE: Well, I
think Shane, you've

00:13:40.490 --> 00:13:43.250
covered some of it there.

00:13:43.250 --> 00:13:44.890
I think Shane did cover
some of it there.

00:13:44.890 --> 00:13:47.270
We are going to have to worry
a lot more about memory,

00:13:47.270 --> 00:13:48.620
especially on memory constraint

00:13:48.620 --> 00:13:50.890
stuff like mobile devices.

00:13:50.890 --> 00:13:54.715
And the tooling has
got better.

00:13:54.715 --> 00:13:57.090
Garbage collection
has got better.

00:13:57.090 --> 00:13:58.040
I don't know how much--

00:13:58.040 --> 00:14:00.550
AUDIENCE: You had the
mic [INAUDIBLE].

00:14:00.550 --> 00:14:03.155
ROWAN BEENJE: I don't know how
much everyone knows about--

00:14:05.830 --> 00:14:08.540
I don't know how much everyone
knows about the current memory

00:14:08.540 --> 00:14:08.910
implementations.

00:14:08.910 --> 00:14:10.950
But it's no longer retain
release stuff.

00:14:10.950 --> 00:14:13.140
It's all very nice.

00:14:13.140 --> 00:14:15.570
Is anything still attached
to the documents?

00:14:15.570 --> 00:14:18.350
So no longer cycles
to worry about.

00:14:18.350 --> 00:14:22.090
But you do still have to keep
very careful track of objects,

00:14:22.090 --> 00:14:24.440
and make sure you don't have
to attach DOM trees.

00:14:24.440 --> 00:14:26.810
Massive memory loss there.

00:14:26.810 --> 00:14:29.610
And Chrome tools have got
a lot better in this.

00:14:29.610 --> 00:14:30.870
You can do heap snapshots.

00:14:30.870 --> 00:14:31.900
You can dip your
heap snapshots.

00:14:31.900 --> 00:14:37.070
You can work out where you're
leaking objects in your

00:14:37.070 --> 00:14:38.530
application life cycle.

00:14:38.530 --> 00:14:40.835
But we are going to have to
worry about a lot more.

00:14:40.835 --> 00:14:43.410
As Shane said, reuse isn't
silver bullet.

00:14:43.410 --> 00:14:45.520
But it's what we have to work
with for the time being.

00:14:48.304 --> 00:14:50.140
MATT DELANEY: Anyone else?

00:14:50.140 --> 00:14:52.450
PAVEL FELDMAN: It's a bad thing
that we need to care

00:14:52.450 --> 00:14:52.940
about memory.

00:14:52.940 --> 00:14:54.110
But it's inevitable.

00:14:54.110 --> 00:14:56.530
We'll need to take
care of memory.

00:14:56.530 --> 00:14:59.990
And we need to make it a
standard part of our

00:14:59.990 --> 00:15:01.440
development practice.

00:15:01.440 --> 00:15:03.670
And not only we should care
about the present state, but

00:15:03.670 --> 00:15:06.060
about the regressions as well.

00:15:06.060 --> 00:15:08.100
Because you don't want to fix
everything, and then lose it

00:15:08.100 --> 00:15:10.570
all with some regression bug.

00:15:10.570 --> 00:15:14.260
And on the tools front, we are
working on exposing better and

00:15:14.260 --> 00:15:14.990
better pictures.

00:15:14.990 --> 00:15:18.290
We're currently working on
native memory instrumentation,

00:15:18.290 --> 00:15:22.110
so that you saw how much DOM and
strings and resources and

00:15:22.110 --> 00:15:24.760
images and decoded images
are taking.

00:15:24.760 --> 00:15:27.560
But what we can see is
that apps [? model ?]

00:15:27.560 --> 00:15:32.110
is most likely a source of the
memory leak and involved with

00:15:32.110 --> 00:15:32.830
memory growth.

00:15:32.830 --> 00:15:36.260
So you should be using heap
profiler for that.

00:15:36.260 --> 00:15:37.510
And yes, it's complex.

00:15:37.510 --> 00:15:42.550
And yes, heap profiling and
memory leak hunting is kind of

00:15:42.550 --> 00:15:43.120
a last resort.

00:15:43.120 --> 00:15:44.300
You don't want to do that.

00:15:44.300 --> 00:15:46.900
But you end up doing it.

00:15:46.900 --> 00:15:50.070
And you end up doing it not
only for web, but in any

00:15:50.070 --> 00:15:51.000
development platform.

00:15:51.000 --> 00:15:53.420
So just make it a standard
practice.

00:15:58.219 --> 00:16:00.980
SHANE O'SULLIVAN: One thing that
we've run into is that

00:16:00.980 --> 00:16:03.740
often, you know when your app
is not doing anything.

00:16:03.740 --> 00:16:06.110
And you know that, for example,
right after someone

00:16:06.110 --> 00:16:07.860
finishes scrolling, they're
going to stop and read

00:16:07.860 --> 00:16:10.410
something for at least 100
milliseconds before they start

00:16:10.410 --> 00:16:12.040
doing interactions again.

00:16:12.040 --> 00:16:14.740
And one of the things that would
be fantastic is if you

00:16:14.740 --> 00:16:18.730
could just say, I know my app
state Now clean it up.

00:16:18.730 --> 00:16:20.660
But don't do it in two
seconds time when

00:16:20.660 --> 00:16:22.040
they're scrolling again.

00:16:22.040 --> 00:16:22.970
Clean up now.

00:16:22.970 --> 00:16:24.930
And I know this has been
brought up before, too.

00:16:24.930 --> 00:16:28.770
Everybody who ever built a
garbage collector, and they

00:16:28.770 --> 00:16:32.655
always say, it's always best
guess, or maybe that isn't the

00:16:32.655 --> 00:16:35.630
best time to do it, and all
that kind of stuff.

00:16:35.630 --> 00:16:37.350
But being someone who doesn't
actually know how the

00:16:37.350 --> 00:16:41.696
internals work, why is that?

00:16:41.696 --> 00:16:43.850
PAVEL FELDMAN: I'm not
commenting on the GC,

00:16:43.850 --> 00:16:45.460
controlling GC questions.

00:16:45.460 --> 00:16:46.790
It's a tough area.

00:16:46.790 --> 00:16:49.570
And you should be really
talking to the

00:16:49.570 --> 00:16:51.530
virtual machine engineers.

00:16:51.530 --> 00:16:53.940
And they have the
official story.

00:16:53.940 --> 00:16:56.474
Paul, what is our
official story?

00:16:56.474 --> 00:16:58.442
PAUL: I have no idea.

00:16:58.442 --> 00:17:01.130
PAVEL FELDMAN: So the answer
that you get from the

00:17:01.130 --> 00:17:05.480
[? vendors ?] is always, we are
going to do best for you.

00:17:05.480 --> 00:17:07.140
You don't want to control it.

00:17:07.140 --> 00:17:09.420
Or otherwise, you will
lead us into trouble.

00:17:09.420 --> 00:17:12.480
But you really need to go into
the details, and talk to the

00:17:12.480 --> 00:17:14.670
actual engineers.

00:17:14.670 --> 00:17:16.514
SHANE O'SULLIVAN: Do we have
any of them in the room?

00:17:22.425 --> 00:17:23.609
MATT DELANEY: This relates
directly to the

00:17:23.609 --> 00:17:24.609
next question, it's--

00:17:24.609 --> 00:17:26.780
SHANE O'SULLIVAN: Or a dozen of
next questions like that.

00:17:26.780 --> 00:17:26.960
MATT DELANEY: What's that?

00:17:26.960 --> 00:17:29.830
SHANE O'SULLIVAN: Or a dozen
of next questions on this.

00:17:29.830 --> 00:17:30.600
MATT DELANEY: Right.

00:17:30.600 --> 00:17:32.980
So this is kind of an
interesting thing from a

00:17:32.980 --> 00:17:36.180
standpoint of perhaps getting
the answer from them.

00:17:36.180 --> 00:17:40.300
But the next person asks, which
is Shapir from Israel,

00:17:40.300 --> 00:17:43.000
is, should JavaScript be allowed
to explicitly trigger

00:17:43.000 --> 00:17:45.640
garbage collection when you
the app is idling, say?

00:17:45.640 --> 00:17:48.650
Or if the app knows when
it's OK to do so?

00:17:48.650 --> 00:17:51.740
Or should it be allowed to
prevent GC when actually

00:17:51.740 --> 00:17:53.890
performing time critical
operations?

00:17:53.890 --> 00:17:55.370
So this is currently something
that people don't really have

00:17:55.370 --> 00:17:55.970
control over.

00:17:55.970 --> 00:17:57.530
But, hear your take on it.

00:18:00.476 --> 00:18:02.840
ROWAN BEENJE: I think the only
other thing to bear in mind is

00:18:02.840 --> 00:18:05.720
that there are occasions when
the browser is going to have

00:18:05.720 --> 00:18:07.570
to garbage collect if it's
running out of memory.

00:18:07.570 --> 00:18:08.780
So there's always going
to be points where you

00:18:08.780 --> 00:18:09.520
can't control it.

00:18:09.520 --> 00:18:12.150
But perhaps we could hint,
I'd like the next 16

00:18:12.150 --> 00:18:13.150
milliseconds, perhaps.

00:18:13.150 --> 00:18:15.812
Please don't garbage collect
during that time.

00:18:15.812 --> 00:18:19.450
AUDIENCE: So do you see
observability as a

00:18:19.450 --> 00:18:20.860
major issue at TC39?

00:18:20.860 --> 00:18:23.450
So one of the things that I
wind up doing is one of

00:18:23.450 --> 00:18:25.480
Google's representatives to
the standards body for

00:18:25.480 --> 00:18:26.430
JavaScript.

00:18:26.430 --> 00:18:30.740
And so being able to know
exactly when garbage

00:18:30.740 --> 00:18:34.100
collection happens has
potentially very serious side

00:18:34.100 --> 00:18:38.620
effects for cross-document and
cross-origin communication,

00:18:38.620 --> 00:18:39.910
which are not friendly.

00:18:39.910 --> 00:18:45.110
There's also the concern that
exposing GC will bake into the

00:18:45.110 --> 00:18:49.200
web heuristics which are likely
to be proven wrong

00:18:49.200 --> 00:18:49.910
anytime now.

00:18:49.910 --> 00:18:54.750
So in the history of V8, we've
gone from having a

00:18:54.750 --> 00:18:58.960
generational GC to having
many, many, many other

00:18:58.960 --> 00:19:00.840
variance of generational GC.

00:19:00.840 --> 00:19:04.760
And if you bake in invariants
in your code based on V8,

00:19:04.760 --> 00:19:07.390
they'll be wrong under Nitro.

00:19:07.390 --> 00:19:10.810
And they'll be wrong under
IonMonkey, or whatever the

00:19:10.810 --> 00:19:13.052
next thing is out of
the next vendor.

00:19:13.052 --> 00:19:15.530
And so the optimizations you'll
employ are likely to

00:19:15.530 --> 00:19:17.310
get you into a place where not
only will you be wrong in the

00:19:17.310 --> 00:19:20.710
future version of the VM that
you're currently attempting to

00:19:20.710 --> 00:19:23.080
tickle in the right way, you'll
certainly be wrong on

00:19:23.080 --> 00:19:24.050
the other VMs, too.

00:19:24.050 --> 00:19:26.890
So it's a nasty place to
end your code base up.

00:19:34.000 --> 00:19:36.080
CHRIS LORD: I don't have
anything to add to that.

00:19:36.080 --> 00:19:38.060
MATT DELANEY: Have you guys run
into any situations where

00:19:38.060 --> 00:19:39.900
you felt like it would be a much
better thing to be able

00:19:39.900 --> 00:19:41.325
have control over these?

00:19:41.325 --> 00:19:43.520
Because in a lot of native
platforms, you have, of

00:19:43.520 --> 00:19:46.430
course, different controls over
the VMs, like say in JVM

00:19:46.430 --> 00:19:47.020
and whatnot.

00:19:47.020 --> 00:19:49.690
Are there any other times in
your experience where you've

00:19:49.690 --> 00:19:51.560
dealt with wanting something
like this?

00:19:55.422 --> 00:19:56.380
SHANE O'SULLIVAN: Yeah.

00:19:56.380 --> 00:19:59.500
It's more from an extremely
high level, rather than be

00:19:59.500 --> 00:20:02.110
able to observe specific things,
or even know when it's

00:20:02.110 --> 00:20:03.330
going to run.

00:20:03.330 --> 00:20:07.430
More from a point of view of
telling it, like you said, I'm

00:20:07.430 --> 00:20:09.580
starting to do something
really complicated now.

00:20:09.580 --> 00:20:10.800
Just calm down.

00:20:10.800 --> 00:20:14.350
And if my memory grows by
another 20 megabytes while

00:20:14.350 --> 00:20:17.080
you're waiting to GC, please
wait until I'm finished.

00:20:17.080 --> 00:20:19.770
And then feel free to hit
me with a big thing.

00:20:19.770 --> 00:20:21.080
I know, it may not
be possible.

00:20:21.080 --> 00:20:21.865
But--

00:20:21.865 --> 00:20:23.140
AUDIENCE: It can't
be that simple.

00:20:23.140 --> 00:20:27.610
Because we're trying to balance
the interests of the

00:20:27.610 --> 00:20:31.020
user, who may have triggered
your page to allocate those 20

00:20:31.020 --> 00:20:33.430
megabytes, versus, should
they go to swap now?

00:20:33.430 --> 00:20:35.670
What else should they be doing
here in order to--

00:20:35.670 --> 00:20:38.250
what's the most valuable thing
to do with those 20 megabytes?

00:20:38.250 --> 00:20:40.110
And the answer may
not be your app.

00:20:40.110 --> 00:20:41.110
You may think it is.

00:20:41.110 --> 00:20:43.780
But you may not have a global
view on what the user agent is

00:20:43.780 --> 00:20:45.575
doing for the user.

00:20:45.575 --> 00:20:48.350
CHRIS LORD: And I think to some
extent here, we're kind

00:20:48.350 --> 00:20:50.840
of trying to have our
cake and eat it.

00:20:50.840 --> 00:20:53.680
You kind of do have some
control over GC to some

00:20:53.680 --> 00:20:57.130
extent, in that you can just not
write things in a way that

00:20:57.130 --> 00:21:00.820
will end up with objects
to collect.

00:21:00.820 --> 00:21:03.060
It sounds kind of silly.

00:21:03.060 --> 00:21:08.220
But that's how like in Java on
Firefox mobile for Android, we

00:21:08.220 --> 00:21:11.470
have these problems in a lot
of our codes, like while

00:21:11.470 --> 00:21:14.060
you're panning and so
on is Java code.

00:21:14.060 --> 00:21:17.970
And if we create a load of
objects during those frames,

00:21:17.970 --> 00:21:20.940
then at some point, GC will
comes along at a completely

00:21:20.940 --> 00:21:24.890
random time and take more
than a frame's worth of

00:21:24.890 --> 00:21:26.850
time to do its work.

00:21:26.850 --> 00:21:28.380
And the way we work around
that is just

00:21:28.380 --> 00:21:29.890
by not doing that.

00:21:29.890 --> 00:21:31.870
We can't change the
garbage collector.

00:21:31.870 --> 00:21:34.200
And we probably wouldn't
want to anyway, really.

00:21:34.200 --> 00:21:36.740
Because then other things are
going to break, and other

00:21:36.740 --> 00:21:39.270
assumptions we've made
are going to break.

00:21:39.270 --> 00:21:42.950
You can just write your code
in such a way that it won't

00:21:42.950 --> 00:21:44.200
cause a lot of GC.

00:21:47.445 --> 00:21:49.630
SHANE O'SULLIVAN:
No, that's true.

00:21:49.630 --> 00:21:50.190
Yeah, that's true.

00:21:50.190 --> 00:21:51.580
And you should be doing
that anyway.

00:21:51.580 --> 00:21:53.980
But it does just get to the
point at some point.

00:21:53.980 --> 00:21:55.510
I mean, if you're trying to do
things like I was saying

00:21:55.510 --> 00:21:58.160
there, or keep your DOM small,
and have some sort of complex

00:21:58.160 --> 00:22:00.600
controller that does all these
things and recycles views and

00:22:00.600 --> 00:22:01.850
all that kind of stuff.

00:22:04.976 --> 00:22:07.070
You're doing all this to get
around the problem of large

00:22:07.070 --> 00:22:10.614
DOM and to avoid repaint, and
get as much reuse as you can.

00:22:10.614 --> 00:22:13.850
That inevitably leads to
large memory usage.

00:22:13.850 --> 00:22:17.375
If you have static content, like
buttons and icons, and

00:22:17.375 --> 00:22:18.190
you're swiping through those.

00:22:18.190 --> 00:22:18.890
Absolutely.

00:22:18.890 --> 00:22:22.010
But if you simply have megabytes
of data that, as a

00:22:22.010 --> 00:22:23.850
person scrolls through, you've
got to show them a piece at a

00:22:23.850 --> 00:22:27.900
time, it gets fairly difficult
to start avoiding things.

00:22:27.900 --> 00:22:32.280
Even when you cut it down
as much as possible.

00:22:32.280 --> 00:22:34.700
CHRIS LORD: I guess you kind
of want to balance the two.

00:22:38.468 --> 00:22:39.600
MATT DELANEY: I'm moving on.

00:22:39.600 --> 00:22:42.450
So we've got a third question
here, from Jonno

00:22:42.450 --> 00:22:43.740
from London, or Yonno?

00:22:43.740 --> 00:22:45.860
Is that a person in here?

00:22:45.860 --> 00:22:46.840
Yonno?

00:22:46.840 --> 00:22:47.760
Anyway.

00:22:47.760 --> 00:22:51.230
So we've got a very talked about
topic here, but with

00:22:51.230 --> 00:22:52.690
respect to tooling this time.

00:22:52.690 --> 00:22:54.880
So when you're using CSS to
manually trigger hardware

00:22:54.880 --> 00:22:58.050
acceleration of DOM elements for
animations, for example,

00:22:58.050 --> 00:23:01.280
the hack of using translateZ(0),
is there a tool

00:23:01.280 --> 00:23:05.770
or any way to measure how this
impacts the users and GPU?

00:23:05.770 --> 00:23:06.770
They ask.

00:23:06.770 --> 00:23:09.550
Let's start with Feldman.

00:23:09.550 --> 00:23:10.110
PAVEL FELDMAN: Yeah.

00:23:10.110 --> 00:23:13.620
So you measure it
using timeline.

00:23:13.620 --> 00:23:17.640
And I won't comment on whether
it's a good practice or not to

00:23:17.640 --> 00:23:18.440
force the hardware

00:23:18.440 --> 00:23:19.850
acceleration using that technique.

00:23:19.850 --> 00:23:22.460
And Paul can cover that one.

00:23:22.460 --> 00:23:28.660
But once you've done that, you
can, in Chrome, and it covers

00:23:28.660 --> 00:23:34.460
good part of WebKit, you can use
timeline to measure both

00:23:34.460 --> 00:23:38.270
paints times, and just
compare those.

00:23:38.270 --> 00:23:42.020
That will obviously depend
on whether you are using

00:23:42.020 --> 00:23:42.370
[? retna ?]

00:23:42.370 --> 00:23:45.960
or not, size of the screen,
[? whatever, ?]

00:23:45.960 --> 00:23:46.550
accelerator.

00:23:46.550 --> 00:23:48.770
But you can do that.

00:23:48.770 --> 00:23:50.420
You'll need to have an
inventory for that.

00:23:50.420 --> 00:23:52.160
Because equipment differs.

00:23:52.160 --> 00:23:54.250
And do you want to comment
on the translating?

00:23:58.731 --> 00:23:59.190
[? PAUL: ?]

00:23:59.190 --> 00:24:06.460
Just one thing about the
translate zed for me is that

00:24:06.460 --> 00:24:09.155
the way, certainly in Chrome,
it's handled is that it

00:24:09.155 --> 00:24:10.770
creates you a new layer,
but also a layer

00:24:10.770 --> 00:24:13.700
with a backing surface.

00:24:13.700 --> 00:24:17.340
So that effectively really maps
down to a texture that

00:24:17.340 --> 00:24:20.110
needs to be uploaded
to the GPU.

00:24:20.110 --> 00:24:22.380
So the net result of this is
that if you've got a translate

00:24:22.380 --> 00:24:24.810
zed or across a lot of
elements, on desktop

00:24:24.810 --> 00:24:25.630
you might be fine.

00:24:25.630 --> 00:24:28.350
Because you've got a lot
more VRAM to play with.

00:24:28.350 --> 00:24:30.220
But on mobile, you're going
to get punished.

00:24:30.220 --> 00:24:31.930
Because now you've got a lot of
textures that needs to be

00:24:31.930 --> 00:24:33.660
uploaded to your GPU.

00:24:33.660 --> 00:24:36.330
And the upload time might be
quite slow to get those

00:24:36.330 --> 00:24:39.460
textures from the CPU up to
the GPU, depending on the

00:24:39.460 --> 00:24:40.400
actual hardware you're
running on.

00:24:40.400 --> 00:24:43.240
So it's one of these things
that it's sort

00:24:43.240 --> 00:24:45.600
of used with caution.

00:24:45.600 --> 00:24:48.500
And it may be that in your
specific implementation it

00:24:48.500 --> 00:24:51.130
speeds things up, because you've
got enough VRAM to kind

00:24:51.130 --> 00:24:54.460
of cover that debt that you're
kind of creating for yourself.

00:24:54.460 --> 00:24:58.140
And it also is good because,
again, in Chrome, if it's

00:24:58.140 --> 00:25:00.670
possible, switch the rendering
mode over to thread

00:25:00.670 --> 00:25:03.080
compositing, which is often a
good thing, especially if

00:25:03.080 --> 00:25:04.700
you've got a lot
of animations.

00:25:04.700 --> 00:25:08.360
But you might just see, as
again, a mobile, you might see

00:25:08.360 --> 00:25:11.210
it crush your performance
if you do it too much.

00:25:11.210 --> 00:25:13.870
CHRIS LORD: Yeah, this is the
same case in Firefox, as well,

00:25:13.870 --> 00:25:17.740
where if you add any kind of
transformation, then it will

00:25:17.740 --> 00:25:21.620
end up not optimizing it, but
sort of making it appear on

00:25:21.620 --> 00:25:23.340
its own layer.

00:25:23.340 --> 00:25:25.040
There are other things to
consider, as well, when you're

00:25:25.040 --> 00:25:28.260
forcing layers and elements
and that.

00:25:28.260 --> 00:25:30.810
If you force something to become
a new layer, you're

00:25:30.810 --> 00:25:33.830
also forcing layers to be
underneath it and over it,

00:25:33.830 --> 00:25:36.000
depending on the structure
of the document.

00:25:36.000 --> 00:25:38.750
And again, depending on the
structure of the document,

00:25:38.750 --> 00:25:41.810
you'd also be forcing things
like alpha blending to happen.

00:25:41.810 --> 00:25:44.700
You're forcing things like
increased overdraw to happen,

00:25:44.700 --> 00:25:46.250
all of these.

00:25:46.250 --> 00:25:47.480
And you'd have memory
hit, you'd have

00:25:47.480 --> 00:25:50.660
GPU time hit as well.

00:25:50.660 --> 00:25:54.240
And at some point, like
translateZ(0) might end up

00:25:54.240 --> 00:25:56.596
just being a null op anyway.

00:25:56.596 --> 00:25:58.400
ROWAN BEENJE: It is
already on WebKit.

00:25:58.400 --> 00:26:00.520
It's been kind of deprecated
[INAUDIBLE].

00:26:00.520 --> 00:26:02.930
PAUL: Yeah, they may be like--

00:26:02.930 --> 00:26:05.710
there are other ways to trigger
the same behavior so

00:26:05.710 --> 00:26:06.890
that the warning [? shot ?]

00:26:06.890 --> 00:26:08.810
is, this one might
become null.

00:26:08.810 --> 00:26:13.930
But developers might gravitate
towards an alternative way of

00:26:13.930 --> 00:26:15.200
triggering the same effect.

00:26:15.200 --> 00:26:16.240
It is exactly what
you're saying.

00:26:16.240 --> 00:26:18.850
It depends on the context of
when you're using it as to

00:26:18.850 --> 00:26:21.880
whether it's actually a suitable
thing to do, really.

00:26:21.880 --> 00:26:23.250
MATT DELANEY: So there's really
a lot of knowledge

00:26:23.250 --> 00:26:25.030
here, and a lot of gotchas,
depending upon the platform

00:26:25.030 --> 00:26:27.300
and what they fall down into
doing, what actual rendering

00:26:27.300 --> 00:26:28.450
paths, right?

00:26:28.450 --> 00:26:30.090
But I guess for this question,
it'd be really interesting to

00:26:30.090 --> 00:26:32.490
point out maybe, especially
with people in the more

00:26:32.490 --> 00:26:35.490
constrained environments on
mobile, what do you guys see

00:26:35.490 --> 00:26:38.930
out there for tooling to measure
the impact of their

00:26:38.930 --> 00:26:42.280
apps usage of this hack upon
what they're doing?

00:26:42.280 --> 00:26:44.010
CHRIS LORD: This is quite
a difficult thing.

00:26:44.010 --> 00:26:50.320
Because GPU behavior is wildly
different, depending on what

00:26:50.320 --> 00:26:51.310
vendor you have.

00:26:51.310 --> 00:26:55.070
So Firefox does have a profiling
tool built in, which

00:26:55.070 --> 00:27:00.710
will profile at the native level
where time is spent.

00:27:00.710 --> 00:27:02.470
And it goes into JavaScript,
as well.

00:27:02.470 --> 00:27:06.100
So if you run your page or
your web GL app, and you

00:27:06.100 --> 00:27:09.720
scroll around with the profiler
enabled and you stop,

00:27:09.720 --> 00:27:12.330
you can see where time
is being spent.

00:27:12.330 --> 00:27:15.390
But in terms of getting really
granular results,

00:27:15.390 --> 00:27:16.250
that's quite hard.

00:27:16.250 --> 00:27:21.430
Like GL drivers quite often,
they'll defer work to the

00:27:21.430 --> 00:27:22.660
latest point possible.

00:27:22.660 --> 00:27:26.210
So you might find that although
you're doing a load

00:27:26.210 --> 00:27:30.100
of vertex upload or something,
you're uploading a load of

00:27:30.100 --> 00:27:34.830
data to the GPU, or you're
uploading a load of things,

00:27:34.830 --> 00:27:37.360
you might find that actually all
of that takes zero time.

00:27:37.360 --> 00:27:40.040
And swap takes all
of your time.

00:27:40.040 --> 00:27:43.040
Or clear takes all of your time,
or flush, or some other

00:27:43.040 --> 00:27:46.260
command where the GPU's like,
right, OK, we can't defer

00:27:46.260 --> 00:27:47.010
things any longer.

00:27:47.010 --> 00:27:49.500
We have to flush out
all the work.

00:27:49.500 --> 00:27:54.200
And we can't really counteract
that without doing, I guess,

00:27:54.200 --> 00:27:57.870
other clever things like having
a shim for the GL

00:27:57.870 --> 00:28:00.460
functions and the JavaScript,
so that we can log what

00:28:00.460 --> 00:28:04.030
commands you are using, and use
some kind of context to

00:28:04.030 --> 00:28:06.930
say, well, maybe you shouldn't
be doing all of this.

00:28:06.930 --> 00:28:08.670
Maybe you shouldn't be uploading
all of this data

00:28:08.670 --> 00:28:16.310
here, or maybe you should think
of using more VPOs and

00:28:16.310 --> 00:28:19.210
batching your drawing, rather
than doing lots of separate

00:28:19.210 --> 00:28:21.146
drawing and things like this.

00:28:21.146 --> 00:28:24.060
But I think it's going to be
quite difficult, nigh on

00:28:24.060 --> 00:28:29.530
impossible, to have a really
granular general profiler when

00:28:29.530 --> 00:28:33.725
it comes to GPU use.

00:28:33.725 --> 00:28:37.040
But yeah, Firefox has
a built in profiler.

00:28:37.040 --> 00:28:40.183
If it's not in the current
release, it's probably in 19

00:28:40.183 --> 00:28:41.960
or 20, I forget.

00:28:41.960 --> 00:28:44.580
And also for the record,
we have incremental GC

00:28:44.580 --> 00:28:47.970
also in 19 or 20.

00:28:47.970 --> 00:28:50.460
PAVEL FELDMAN: So before
it gets to Firefox,

00:28:50.460 --> 00:28:53.510
we have it in Chrome.

00:28:53.510 --> 00:28:58.230
And the way you look at it-- so
there is no GPU profiling.

00:28:58.230 --> 00:29:01.240
But there are interesting cases
on the timeline where

00:29:01.240 --> 00:29:05.430
you see your CPU time spent
for just JavaScript

00:29:05.430 --> 00:29:06.560
[? layer ?] painting.

00:29:06.560 --> 00:29:09.440
And it all adds up to some
reasonable amount.

00:29:09.440 --> 00:29:11.115
And then there is this
transparent bar.

00:29:11.115 --> 00:29:14.550
And you don't know why your
frame has been skipped.

00:29:14.550 --> 00:29:19.560
And the reason for that is the
browser was waiting for GPU.

00:29:19.560 --> 00:29:23.070
We don't really see that
happening a lot in practice,

00:29:23.070 --> 00:29:26.870
on non-heavy 3D apps
whatsoever.

00:29:26.870 --> 00:29:30.530
So in most cases, first thing
you check is timeline.

00:29:30.530 --> 00:29:32.370
And you're most likely OK.

00:29:32.370 --> 00:29:35.950
And the detailed GPU profiling
is still ahead

00:29:35.950 --> 00:29:37.133
for Chrome, as well.

00:29:37.133 --> 00:29:37.820
CHRIS LORD: Yeah.

00:29:37.820 --> 00:29:40.260
It's much better on desktop
than it is on mobile.

00:29:40.260 --> 00:29:42.480
And most of my experience is
mobile, so I'm probably going

00:29:42.480 --> 00:29:45.680
to be speaking from
that perspective.

00:29:45.680 --> 00:29:46.330
You worry less.

00:29:46.330 --> 00:29:49.530
I guess everything is
better on desktop.

00:29:49.530 --> 00:29:54.620
The state of mobile GPUs, at
least certainly on Android,

00:29:54.620 --> 00:29:58.120
although it's getting better,
is like Android-based system

00:29:58.120 --> 00:29:59.900
tends to use GPUs more.

00:29:59.900 --> 00:30:04.860
Like, drivers have some pretty
awful and incorrect behavior,

00:30:04.860 --> 00:30:09.990
and just flat out bugs that will
cause things like this.

00:30:09.990 --> 00:30:12.570
You'll have hitches that will
be very hard to trace.

00:30:12.570 --> 00:30:16.140
And it will come down to
something like, you've

00:30:16.140 --> 00:30:18.270
triggered something
which might do--

00:30:18.270 --> 00:30:20.640
like it might update
part of a texture.

00:30:20.640 --> 00:30:24.150
And that GPU driver subimage
uploads are

00:30:24.150 --> 00:30:24.980
actually just terrible.

00:30:24.980 --> 00:30:26.300
And you should never do them.

00:30:26.300 --> 00:30:29.200
We try and work around these
things, but I don't know.

00:30:29.200 --> 00:30:30.280
It's on mobile it's hard.

00:30:30.280 --> 00:30:33.410
But on desktop, it's less
of a concern, I guess.

00:30:33.410 --> 00:30:34.700
MATT DELANEY: Also we
have a question from

00:30:34.700 --> 00:30:35.980
the audience here.

00:30:35.980 --> 00:30:37.030
What's your name?

00:30:37.030 --> 00:30:38.485
AUDIENCE: Hi, I'm
DJ Fazzyfist.

00:30:38.485 --> 00:30:39.490
No, I'm kidding.

00:30:39.490 --> 00:30:39.920
[INAUDIBLE]

00:30:39.920 --> 00:30:40.980
from Google.

00:30:40.980 --> 00:30:43.670
It's also worth noting that for
those of you daring souls

00:30:43.670 --> 00:30:46.490
in here who compile Chromium,
that there is access to the

00:30:46.490 --> 00:30:50.450
Skia debugger, which is actually
sort of the hardware

00:30:50.450 --> 00:30:51.650
GPU compositor.

00:30:51.650 --> 00:30:53.070
It's actually amazing
the insight you can

00:30:53.070 --> 00:30:54.040
get from Skia debugger.

00:30:54.040 --> 00:30:56.780
You can actually see the GPU
performance for each CSS

00:30:56.780 --> 00:30:57.580
element on your page.

00:30:57.580 --> 00:31:00.730
You can actually see what your
DOM is doing, and what each

00:31:00.730 --> 00:31:03.200
button and how long that's
taking on the GPU.

00:31:03.200 --> 00:31:05.940
It's amazing insight if you're
seeing problems in this area,

00:31:05.940 --> 00:31:07.870
and definitely worth checking
out if you're willing to

00:31:07.870 --> 00:31:08.880
compile Chromium.

00:31:08.880 --> 00:31:09.540
AUDIENCE: How do you spell it?

00:31:09.540 --> 00:31:10.080
AUDIENCE: Skia?

00:31:10.080 --> 00:31:15.800
S-K-I-A. Skia debugger,
check it out.

00:31:15.800 --> 00:31:16.511
Hi.

00:31:16.511 --> 00:31:19.220
MATT DELANEY: Sounds
pretty good.

00:31:19.220 --> 00:31:22.405
PAVEL FELDMAN: Does it already
provide traceability from DOM

00:31:22.405 --> 00:31:23.650
and CSS literally?

00:31:23.650 --> 00:31:26.040
Because it was bound
to instructions.

00:31:26.040 --> 00:31:28.130
And you couldn't really trace
it into particular

00:31:28.130 --> 00:31:28.615
[? selector ?]

00:31:28.615 --> 00:31:32.035
and/or CSS property.

00:31:32.035 --> 00:31:34.380
I don't believe you can now.

00:31:34.380 --> 00:31:36.204
AUDIENCE: [INAUDIBLE].

00:31:36.204 --> 00:31:38.940
PETE: Mic?

00:31:38.940 --> 00:31:40.390
AUDIENCE: Thanks, Pete.

00:31:40.390 --> 00:31:42.490
The latest one that I was
playing with had some

00:31:42.490 --> 00:31:43.100
abilities there.

00:31:43.100 --> 00:31:45.190
Obviously, the tooling needs to
get better across the board

00:31:45.190 --> 00:31:48.240
for getting GPU insight for
these sorts of things.

00:31:48.240 --> 00:31:51.040
Since kind of the future of web
compositing performance is

00:31:51.040 --> 00:31:52.230
on the GPU anyway.

00:31:52.230 --> 00:31:54.480
So for those of you who want
to kind of try out and give

00:31:54.480 --> 00:31:56.620
feedback for this early stuff,
definitely check out Skia

00:31:56.620 --> 00:31:59.100
debugger and kind of get a
chance to chart where these

00:31:59.100 --> 00:32:01.290
tools are going in the future.

00:32:01.290 --> 00:32:04.060
PAVEL FELDMAN: So the way it
works pretty much, if I

00:32:04.060 --> 00:32:06.140
remember it correctly,
is it logs

00:32:06.140 --> 00:32:07.210
everything that is happening.

00:32:07.210 --> 00:32:08.480
And then it replays it.

00:32:08.480 --> 00:32:12.800
And while replaying, you can
assess the performance of the

00:32:12.800 --> 00:32:15.430
instructions that were made.

00:32:15.430 --> 00:32:16.990
So basic idea.

00:32:16.990 --> 00:32:19.500
CHRIS LORD: I think we do
actually, I remember now, on

00:32:19.500 --> 00:32:20.490
the [INAUDIBLE]

00:32:20.490 --> 00:32:24.760
last year, we have a similar
tool for recording GPU

00:32:24.760 --> 00:32:26.080
behavior and then
playing it back.

00:32:26.080 --> 00:32:29.550
But I can't tell you
anything about it.

00:32:29.550 --> 00:32:31.620
I've just forgotten, and
it's not finished.

00:32:31.620 --> 00:32:34.230
So I think that sounds
really cool.

00:32:34.230 --> 00:32:37.090
You're definitely well
ahead there.

00:32:37.090 --> 00:32:39.070
ROWAN BEENJE: And I think the
Chrome dev tools are just

00:32:39.070 --> 00:32:41.170
starting to expose the
amounts of GP memory

00:32:41.170 --> 00:32:42.530
used, is that correct?

00:32:42.530 --> 00:32:43.450
That's coming up?

00:32:43.450 --> 00:32:44.480
PAVEL FELDMAN: Not yet.

00:32:44.480 --> 00:32:45.240
ROWAN BEENJE: But it's coming?

00:32:45.240 --> 00:32:46.130
PAVEL FELDMAN: It's
coming, yes.

00:32:46.130 --> 00:32:47.050
ROWAN BEENJE: Very soon.

00:32:47.050 --> 00:32:50.030
PAVEL FELDMAN: So native memory
instrumentation started

00:32:50.030 --> 00:32:51.680
with the renderer.

00:32:51.680 --> 00:32:56.310
And the GPU for us is outside
of the renderer.

00:32:56.310 --> 00:32:57.430
CHRIS LORD: I'm not sure if--

00:32:57.430 --> 00:33:00.970
like, we have, if you go to
About Memory in Firefox,

00:33:00.970 --> 00:33:02.960
you'll see lots of details
about where your memory's

00:33:02.960 --> 00:33:03.980
being used.

00:33:03.980 --> 00:33:07.260
I'm not sure if that goes
to GPU memory, though.

00:33:07.260 --> 00:33:08.210
That also works--

00:33:08.210 --> 00:33:10.110
I think it works, it should
work-- on mobile.

00:33:13.140 --> 00:33:13.310
MATT DELANEY: Great.

00:33:13.310 --> 00:33:14.510
So that's quite a bit
about the tooling.

00:33:14.510 --> 00:33:17.240
So how about we move over to
the next question, which is

00:33:17.240 --> 00:33:19.140
related and kind of touched on a
bit in the beginning of this

00:33:19.140 --> 00:33:22.860
one, was, how do you guys feel
about frame developers and

00:33:22.860 --> 00:33:25.470
their understanding of which
performance metrics they

00:33:25.470 --> 00:33:27.895
should actually be looking
at these days?

00:33:27.895 --> 00:33:31.360
Say both, of course on a
desktop, but more importantly

00:33:31.360 --> 00:33:33.055
mobile, the more constrained
environment.

00:33:33.055 --> 00:33:35.260
Should they be looking,
rendering,

00:33:35.260 --> 00:33:37.470
compositing, layout?

00:33:37.470 --> 00:33:38.720
How should they be used
in the tools?

00:33:42.230 --> 00:33:44.570
CHRIS LORD: I guess there
aren't too many.

00:33:44.570 --> 00:33:48.600
We've not done as good a job
as we should have, in that

00:33:48.600 --> 00:33:51.410
there aren't tools to measure
certain things that you'd

00:33:51.410 --> 00:33:52.350
really want to know.

00:33:52.350 --> 00:33:56.340
Or at least, the tools are
things like, oh, just use an

00:33:56.340 --> 00:34:00.010
HDMI video capture unit and do
frame analysis, which is

00:34:00.010 --> 00:34:03.530
obviously not feasible for
most people, I would say.

00:34:07.400 --> 00:34:09.620
PAVEL FELDMAN: Can we turn that
to the audience, and may

00:34:09.620 --> 00:34:12.940
I ask, how many of you have
experienced issues,

00:34:12.940 --> 00:34:16.659
challenges, profiling, fighting
for rendering

00:34:16.659 --> 00:34:17.370
performance?

00:34:17.370 --> 00:34:18.850
If you could raise your hand.

00:34:18.850 --> 00:34:21.719
Rendering performance?

00:34:21.719 --> 00:34:22.310
OK.

00:34:22.310 --> 00:34:27.040
And how many of you were
using timeline to

00:34:27.040 --> 00:34:29.670
capture what's happening?

00:34:29.670 --> 00:34:32.409
OK, so it's pretty much
half of [? us. ?]

00:34:32.409 --> 00:34:33.969
So that's your answer.

00:34:33.969 --> 00:34:39.580
So half of us realize what needs
to be done tooling wise.

00:34:42.905 --> 00:34:44.155
AUDIENCE: [INAUDIBLE].

00:34:48.130 --> 00:34:51.219
So how would it help me
in a web view iOS?

00:34:51.219 --> 00:34:53.770
It's great that we have all
these tools in our browsers,

00:34:53.770 --> 00:34:55.830
but a lot of performance
of HTML5 is

00:34:55.830 --> 00:34:57.200
in the closed platforms.

00:34:57.200 --> 00:35:00.060
So what can we do to get those
closed platforms to get the

00:35:00.060 --> 00:35:02.370
cool tools that we're
building?

00:35:02.370 --> 00:35:05.810
PAVEL FELDMAN: So those
platforms diverge, especially

00:35:05.810 --> 00:35:06.815
on the rendering front.

00:35:06.815 --> 00:35:08.820
It is truth.

00:35:08.820 --> 00:35:12.090
On the CPU front, though, they
are very much alike.

00:35:12.090 --> 00:35:14.940
So you have a good clue on
what's happening in iOS web

00:35:14.940 --> 00:35:19.800
view when looking at Chrome,
unless you enable threaded

00:35:19.800 --> 00:35:22.160
compositing or something
like that.

00:35:22.160 --> 00:35:25.570
And it often gives
you a good clue.

00:35:25.570 --> 00:35:28.860
And image decode time will
be proportional.

00:35:28.860 --> 00:35:32.730
Because what you're assessing
is basically the CPU and the

00:35:32.730 --> 00:35:35.260
architecture of what
you're running on.

00:35:35.260 --> 00:35:36.380
So you have some clue.

00:35:36.380 --> 00:35:38.450
You have some good
clue on that.

00:35:38.450 --> 00:35:41.530
But it is not precise.

00:35:41.530 --> 00:35:44.570
SHANE O'SULLIVAN: But also what
you should care about, I

00:35:44.570 --> 00:35:48.450
don't think should be what any
one tool gives you, or any one

00:35:48.450 --> 00:35:49.240
performance metric--

00:35:49.240 --> 00:35:52.220
I mean, performance is
not a goal in itself.

00:35:52.220 --> 00:35:55.670
Performance should be there to
get you to increase whatever

00:35:55.670 --> 00:35:57.510
metric matters to you.

00:35:57.510 --> 00:35:59.780
So for example, in Facebook,
the reason we care so much

00:35:59.780 --> 00:36:03.120
about scrolling is that we did
a test where we artificially

00:36:03.120 --> 00:36:06.500
introduced for some small
number of people, 20, 30

00:36:06.500 --> 00:36:10.110
million or something, where
we said, we'll have your

00:36:10.110 --> 00:36:13.650
scrolling framework on Android
and iOS, just artificially.

00:36:13.650 --> 00:36:16.100
We know you can do 60
FPS on an iPhone 5.

00:36:16.100 --> 00:36:17.290
We will give you 30 FPS.

00:36:17.290 --> 00:36:19.080
And engagement collapsed.

00:36:19.080 --> 00:36:20.970
You would still get--

00:36:20.970 --> 00:36:22.380
we didn't introduce jerking,
we just slowed

00:36:22.380 --> 00:36:23.850
down the frame rate.

00:36:23.850 --> 00:36:25.130
And engagement dropped.

00:36:25.130 --> 00:36:28.280
So we said, OK, therefore,
scrolling matters to

00:36:28.280 --> 00:36:28.950
engagement.

00:36:28.950 --> 00:36:30.390
And engagement is
what matters.

00:36:30.390 --> 00:36:33.360
So if what you care about--

00:36:33.360 --> 00:36:34.980
test all the different
things for your app

00:36:34.980 --> 00:36:35.960
that actually matter.

00:36:35.960 --> 00:36:40.230
If speed, time to interaction
is what's important to you,

00:36:40.230 --> 00:36:41.330
emphasize for that.

00:36:41.330 --> 00:36:44.500
If scrolling is important to
you, and you do stuff like

00:36:44.500 --> 00:36:49.160
newsfeed, or any kind of image
heavy thing, then optimize for

00:36:49.160 --> 00:36:50.400
not resizing images.

00:36:50.400 --> 00:36:58.900
Optimize for not doing paint
reflows on complex content.

00:36:58.900 --> 00:37:01.192
If you really care about
TTI, do server render.

00:37:01.192 --> 00:37:02.490
It's faster.

00:37:02.490 --> 00:37:05.560
So try out 10 different
things.

00:37:05.560 --> 00:37:06.520
I know it's time consuming.

00:37:06.520 --> 00:37:09.440
But the metric you should
be looking at is

00:37:09.440 --> 00:37:10.640
what matters to you.

00:37:10.640 --> 00:37:13.440
Do you care that people look
at 50 photos in an hour?

00:37:13.440 --> 00:37:16.960
You're a photo app, fine,
optimize for that.

00:37:16.960 --> 00:37:19.360
So yeah, I don't think there's
any one sole [? rebuttal ?]

00:37:19.360 --> 00:37:20.226
for this stuff.

00:37:20.226 --> 00:37:21.880
PAVEL FELDMAN: So the same
happened to Chrome.

00:37:21.880 --> 00:37:23.800
We consider scrolling
very important.

00:37:23.800 --> 00:37:29.060
And there is actually a tooling
to detect regressions

00:37:29.060 --> 00:37:30.290
on that front.

00:37:30.290 --> 00:37:33.770
So there is a telemetry, the
remote control for Chrome.

00:37:33.770 --> 00:37:36.250
And the rendering team
is using it in

00:37:36.250 --> 00:37:36.930
the following matter.

00:37:36.930 --> 00:37:41.470
This tool can connect to remote
devices such as Android

00:37:41.470 --> 00:37:44.610
phones and Chrome OS and
desktops, different builds,

00:37:44.610 --> 00:37:45.630
different versions of builds.

00:37:45.630 --> 00:37:49.290
So it connects to those, runs
regression testing, uses

00:37:49.290 --> 00:37:53.250
timeline to get raw data back,
and builds the graphs.

00:37:53.250 --> 00:37:57.450
And any degrade in that graph
is a show stopper, and we

00:37:57.450 --> 00:37:58.640
change that.

00:37:58.640 --> 00:37:59.430
[? Regressions ?]

00:37:59.430 --> 00:38:00.600
gets rolled out [? of them. ?]

00:38:00.600 --> 00:38:04.070
So the same thing that happens
on the vendor front should be

00:38:04.070 --> 00:38:05.060
happening on that app front.

00:38:05.060 --> 00:38:06.790
And I'm sure it does.

00:38:06.790 --> 00:38:11.220
So the metric is scrolling
matches here.

00:38:11.220 --> 00:38:15.070
CHRIS LORD: I think, on a slight
tangent, there are some

00:38:15.070 --> 00:38:16.840
practical things that are worth

00:38:16.840 --> 00:38:20.520
knowing before you even--

00:38:20.520 --> 00:38:21.760
MATT DELANEY: 30 seconds.

00:38:21.760 --> 00:38:24.290
CHRIS LORD: While you're
making a site.

00:38:24.290 --> 00:38:26.000
You should take these things
into consideration.

00:38:26.000 --> 00:38:31.150
So it's worth knowing to some
extent what things cause new

00:38:31.150 --> 00:38:33.940
stacking context to be
created, for example.

00:38:33.940 --> 00:38:36.860
Because if you create a new
stacking context, likelihood

00:38:36.860 --> 00:38:38.880
is you're going to create
a new layer, as well.

00:38:38.880 --> 00:38:43.230
Not necessarily, but it's a
reasonable kind of rule of

00:38:43.230 --> 00:38:44.900
thumb to go by.

00:38:44.900 --> 00:38:47.720
Try and reduce the amount
of stacking context.

00:38:47.720 --> 00:38:55.650
Try to reduce the amount of, for
example, if you have text,

00:38:55.650 --> 00:38:57.920
not having it on a solid
background means that you're

00:38:57.920 --> 00:38:59.970
going to force alpha blending,
and you're going to force that

00:38:59.970 --> 00:39:01.650
text to be rendered twice.

00:39:01.650 --> 00:39:03.970
First optics or anti-aliasing,
maybe not on mobile.

00:39:03.970 --> 00:39:05.450
We'd probably just
use grayscale.

00:39:05.450 --> 00:39:08.870
But there are lots of little
things like this.

00:39:08.870 --> 00:39:12.970
Like if you're going to have
gradients in your backgrounds,

00:39:12.970 --> 00:39:15.770
CSS gradients, don't change
them all the time.

00:39:15.770 --> 00:39:19.330
Don't resize them if
you can help it.

00:39:19.330 --> 00:39:22.120
Try and avoid fixed
backgrounds.

00:39:22.120 --> 00:39:24.900
Because again, you're going to
force the foreground layers to

00:39:24.900 --> 00:39:28.460
have an alpha channel and force
blending and so on.

00:39:28.460 --> 00:39:30.805
Just sort of small tips that--

00:39:30.805 --> 00:39:34.090
MATT DELANEY: Lots of good
strategic advice there.

00:39:34.090 --> 00:39:35.400
Move on to the next
one here, sorry.

00:39:35.400 --> 00:39:38.030
So we've got a pretty
interesting question, I think,

00:39:38.030 --> 00:39:39.840
from James Ford.

00:39:39.840 --> 00:39:42.070
Kind of an age old question,
perhaps, but does using SVGs

00:39:42.070 --> 00:39:45.150
and font icons for graphics over
GIFs and PINGs have an

00:39:45.150 --> 00:39:47.975
impact on the performance
of a web page?

00:39:47.975 --> 00:39:50.560
How about more from your actual

00:39:50.560 --> 00:39:53.760
experience of using such?

00:39:53.760 --> 00:39:58.040
CHRIS LORD: I was going to say
recently, we switched SVG to

00:39:58.040 --> 00:40:01.980
rather than going from like a
single node in our display

00:40:01.980 --> 00:40:05.520
list to using all of our
display list nodes.

00:40:05.520 --> 00:40:12.190
So if you have an SVG that's
got like 1,000 different

00:40:12.190 --> 00:40:15.960
render nodes in it, then that
will be represented in our

00:40:15.960 --> 00:40:17.130
display list.

00:40:17.130 --> 00:40:19.150
And we have open bugs.

00:40:19.150 --> 00:40:20.910
This did cause performance
issues.

00:40:20.910 --> 00:40:23.060
Because as you scroll through
the page and you expose new

00:40:23.060 --> 00:40:27.790
areas of SVG, we have to iterate
that whole list, and

00:40:27.790 --> 00:40:30.200
render it and sort it into
layers, decide which bits have

00:40:30.200 --> 00:40:33.190
changed and which haven't
and so on.

00:40:33.190 --> 00:40:36.820
So yeah, SVGs are
going to be--

00:40:36.820 --> 00:40:38.040
you can cache them.

00:40:38.040 --> 00:40:40.970
But assuming that you're
using them for a reason

00:40:40.970 --> 00:40:41.910
and you're not just--

00:40:41.910 --> 00:40:45.980
I mean, if you weren't going
to plan on showing them at

00:40:45.980 --> 00:40:48.105
different sizes or a site.

00:40:51.860 --> 00:40:53.910
Assuming that you are using
SVG for a reason and you

00:40:53.910 --> 00:40:56.930
couldn't have just used a static
image kind of thing,

00:40:56.930 --> 00:41:00.010
they are more expensive to use
than just static images.

00:41:00.010 --> 00:41:01.380
And the same with
fonts, as well.

00:41:01.380 --> 00:41:05.290
Fonts are quite expensive
to render.

00:41:05.290 --> 00:41:08.190
So the answer is
yeah, I guess.

00:41:08.190 --> 00:41:09.550
They're more expensive.

00:41:09.550 --> 00:41:11.840
AUDIENCE: So maybe one example
that I found recently,

00:41:11.840 --> 00:41:16.680
actually the Apple site uses
SVGs quite well and badly.

00:41:16.680 --> 00:41:19.230
Well in the sense that they
use them everywhere, for

00:41:19.230 --> 00:41:20.890
example for the logo
and all the rest.

00:41:20.890 --> 00:41:23.930
But I think what a lot of people
miss is a complex SVG

00:41:23.930 --> 00:41:29.260
with a lot of paths is actually
very expensive, even

00:41:29.260 --> 00:41:30.570
in network bytes.

00:41:30.570 --> 00:41:34.130
If you look at the complexity of
the SVGs that they use, you

00:41:34.130 --> 00:41:37.610
can get like a 5x improvement if
you just save it as a PNG.

00:41:37.610 --> 00:41:41.180
So it's retina friendly, which
is what Apple wants.

00:41:41.180 --> 00:41:44.450
But it's actually worse off for
like render time of your

00:41:44.450 --> 00:41:46.980
page and network performance.

00:41:46.980 --> 00:41:48.735
CHRIS LORD: Yeah.

00:41:48.735 --> 00:41:51.520
ROWAN BEENJE: Does anyone have
any comparative information

00:41:51.520 --> 00:41:56.160
about icon fonts versus SVG?

00:41:56.160 --> 00:41:57.190
PAVEL FELDMAN: We
need to measure.

00:41:57.190 --> 00:41:59.050
And if we can't measure
it, we need to

00:41:59.050 --> 00:42:00.740
make sure we can measure.

00:42:00.740 --> 00:42:02.700
MATT DELANEY: [INAUDIBLE]

00:42:02.700 --> 00:42:03.950
in the back?

00:42:11.030 --> 00:42:12.280
Never mind.

00:42:17.410 --> 00:42:18.660
No experience from
Facebook on this?

00:42:21.260 --> 00:42:22.530
SHANE O'SULLIVAN: No experience
by me at Facebook

00:42:22.530 --> 00:42:25.780
at the very least, no.

00:42:25.780 --> 00:42:27.050
MATT DELANEY: All right, so
let's move on to the next

00:42:27.050 --> 00:42:27.965
question then.

00:42:27.965 --> 00:42:29.640
A little bit of time
here left.

00:42:29.640 --> 00:42:32.458
How much on the clock?

00:42:32.458 --> 00:42:33.950
15?

00:42:33.950 --> 00:42:40.450
So kind of a bit of a loaded
question, but how can I find

00:42:40.450 --> 00:42:43.970
which CSS rules and properties
are expensive to render on a

00:42:43.970 --> 00:42:45.370
particular page?

00:42:45.370 --> 00:42:49.920
Is a next question, a little
bit of clarification.

00:42:49.920 --> 00:42:51.110
PAVEL FELDMAN: We are
working on that.

00:42:51.110 --> 00:42:52.960
But it's a hard one.

00:42:52.960 --> 00:42:56.910
You need to trace it all the way
from the CSS property to

00:42:56.910 --> 00:43:00.290
the GL instruction or paint
instruction, Skia instruction.

00:43:00.290 --> 00:43:02.810
And it's a long way to go.

00:43:02.810 --> 00:43:05.250
There is a permanent solution,
though, that we've introduced

00:43:05.250 --> 00:43:07.670
recently as an experiment.

00:43:07.670 --> 00:43:11.550
We can now put browser into the
continuous repaint mode,

00:43:11.550 --> 00:43:14.670
where it continuously repaints,
even if it doesn't

00:43:14.670 --> 00:43:18.530
need to, and it shows you the
frame rate it can do it at.

00:43:18.530 --> 00:43:23.380
And if you're not touching a
page, you can see that OK,

00:43:23.380 --> 00:43:25.590
where it says number
of milliseconds,

00:43:25.590 --> 00:43:26.990
it's paints per frame.

00:43:26.990 --> 00:43:29.020
So it says, 3 milliseconds
per frame.

00:43:29.020 --> 00:43:29.920
That's a good frame.

00:43:29.920 --> 00:43:32.380
You'll achieve 60
FPS with that.

00:43:32.380 --> 00:43:37.530
If it shows you 60, or 100
milliseconds, then you can go

00:43:37.530 --> 00:43:38.630
and bisect your DOM.

00:43:38.630 --> 00:43:40.930
So that's the best we can
offer at the moment.

00:43:40.930 --> 00:43:43.710
You go through DOM,
you hide things.

00:43:43.710 --> 00:43:45.530
It toggles visibility
to [INAUDIBLE].

00:43:45.530 --> 00:43:47.620
And the number of milliseconds
reduce.

00:43:47.620 --> 00:43:51.090
And then you figure out what
is the part that was

00:43:51.090 --> 00:43:54.420
statically positioned, or had
a complex background, or had

00:43:54.420 --> 00:43:57.340
some gradient whatsoever.

00:43:57.340 --> 00:43:59.210
It's a manual process.

00:43:59.210 --> 00:44:02.715
But it is already way
better than nothing.

00:44:02.715 --> 00:44:06.170
SHANE O'SULLIVAN: Will this help
in the case where you're

00:44:06.170 --> 00:44:08.520
showing and hiding things, but
let's say I modify something

00:44:08.520 --> 00:44:11.140
that will trigger both a
repaint and a reflow.

00:44:11.140 --> 00:44:14.400
Does this capture it
in that second?

00:44:14.400 --> 00:44:16.970
PAVEL FELDMAN: So this one
is only about paint.

00:44:16.970 --> 00:44:19.040
And paint meaning layout
does not change.

00:44:19.040 --> 00:44:20.330
DOM does not change.

00:44:20.330 --> 00:44:22.960
So it's only about CSS
and DOM that you have

00:44:22.960 --> 00:44:25.190
presented on the screen.

00:44:25.190 --> 00:44:26.720
For the rest of the
information,

00:44:26.720 --> 00:44:29.030
you go to the timeline.

00:44:29.030 --> 00:44:33.310
There are similar techniques
on figuring out the recalc

00:44:33.310 --> 00:44:35.590
style or layout performance.

00:44:35.590 --> 00:44:38.170
They often end up
with bisecting,

00:44:38.170 --> 00:44:39.700
unfortunately, as well.

00:44:39.700 --> 00:44:41.110
And we're working on
improving that.

00:44:43.792 --> 00:44:46.830
SHANE O'SULLIVAN: Anything cool
coming up in Firefox?

00:44:46.830 --> 00:44:49.460
CHRIS LORD: Not much
to add, really.

00:44:49.460 --> 00:44:55.040
On mobile, I guess, it's worth
considering that certain pages

00:44:55.040 --> 00:44:58.470
and complex pages, and on
certain mobile devices, it's

00:44:58.470 --> 00:45:02.410
really not feasible to expect
the page to render very

00:45:02.410 --> 00:45:07.310
quickly, as in within a
reasonable 60 hertz or 30

00:45:07.310 --> 00:45:09.080
hertz time frame.

00:45:09.080 --> 00:45:12.240
But we have asynchronous
compositing to counter that.

00:45:12.240 --> 00:45:16.460
And what your goal then really
is to kind of do your work at

00:45:16.460 --> 00:45:20.230
clever times, and partition it
in clever ways so that you

00:45:20.230 --> 00:45:23.620
don't interrupt the asynchronous
compositing at

00:45:23.620 --> 00:45:25.630
inopportune times,
or for too long.

00:45:31.318 --> 00:45:32.690
MATT DELANEY: We're on to
the next question here.

00:45:32.690 --> 00:45:36.930
So this is perhaps a little
bit redundant, but it's

00:45:36.930 --> 00:45:38.640
interesting to get the
perspective real quick from

00:45:38.640 --> 00:45:41.240
both the Chrome and
Firefox person.

00:45:41.240 --> 00:45:45.430
So we use translateZ(0) to
trigger hardware rendering, as

00:45:45.430 --> 00:45:46.560
people think.

00:45:46.560 --> 00:45:48.350
Should we have an API to
explicitly do this?

00:45:48.350 --> 00:45:51.670
So this is obviously
a bit tough.

00:45:51.670 --> 00:45:53.800
And I think we can get some
audience input to this.

00:45:53.800 --> 00:45:57.930
But should there be, perhaps in
general, any feedback from

00:45:57.930 --> 00:46:03.680
the app side to get a little
bit of hopeful kick into

00:46:03.680 --> 00:46:04.460
acceleration?

00:46:04.460 --> 00:46:06.050
Because if people are using
this, and they're finding it

00:46:06.050 --> 00:46:10.280
to good effect, is it something
that maybe we want

00:46:10.280 --> 00:46:12.090
to make more real?

00:46:12.090 --> 00:46:14.840
PAVEL FELDMAN: So I think Paul
and Alex have already covered

00:46:14.840 --> 00:46:18.280
this one from the platform
perspective.

00:46:18.280 --> 00:46:20.790
When you were talking to GC,
many things applied to this

00:46:20.790 --> 00:46:22.040
thing as well.

00:46:24.150 --> 00:46:24.510
CHRIS LORD: Yeah.

00:46:24.510 --> 00:46:28.730
This has come up a few times,
really, like do we want apps

00:46:28.730 --> 00:46:31.080
to be able to hint to
GC when to collect?

00:46:31.080 --> 00:46:33.890
And do we want--

00:46:33.890 --> 00:46:38.900
it's like every bit of control
that you add is kind of--

00:46:38.900 --> 00:46:41.060
MATT DELANEY: From your work
on Android, have you found

00:46:41.060 --> 00:46:42.580
times where it would've been
more useful for the app

00:46:42.580 --> 00:46:46.440
developer to give you a hint
that they need that?

00:46:46.440 --> 00:46:49.370
CHRIS LORD: Not really,
I guess.

00:46:49.370 --> 00:46:51.770
I think really, we should
just be cleverer

00:46:51.770 --> 00:46:53.680
about doing these things.

00:46:53.680 --> 00:46:56.680
I think if you put that kind of
control into users' hands,

00:46:56.680 --> 00:46:59.670
things are going to change too
much pretty quickly, to the

00:46:59.670 --> 00:47:01.220
point where it would
just force bad

00:47:01.220 --> 00:47:02.560
behavior in future versions.

00:47:06.390 --> 00:47:07.820
SHANE O'SULLIVAN: From the point
of view of people who

00:47:07.820 --> 00:47:11.430
write apps, yes, it
would be lovely.

00:47:11.430 --> 00:47:13.620
I don't know if it's
feasible or not.

00:47:13.620 --> 00:47:16.830
It's just that on the web, as
everybody knows, one of the

00:47:16.830 --> 00:47:19.110
reasons we're sitting here right
now is that performance

00:47:19.110 --> 00:47:21.060
is a problem.

00:47:21.060 --> 00:47:24.340
And on some of the platforms,
you do have the option of

00:47:24.340 --> 00:47:28.360
dropping down to a lower level
if you need to, and if you

00:47:28.360 --> 00:47:29.600
have people who are
sufficiently good

00:47:29.600 --> 00:47:31.680
enough to do so.

00:47:31.680 --> 00:47:34.510
And I don't know if that's
feasible on the web.

00:47:34.510 --> 00:47:36.020
It would be nice if it was.

00:47:36.020 --> 00:47:37.590
I admit, things change
all the time.

00:47:37.590 --> 00:47:39.680
We're constantly updating our
browsers, or even updating

00:47:39.680 --> 00:47:40.790
them in the background now.

00:47:40.790 --> 00:47:41.990
So things do change
all the time.

00:47:41.990 --> 00:47:45.620
And even on iOS, things
change once a year.

00:47:45.620 --> 00:47:48.460
So yes, it would probably
break everything.

00:47:48.460 --> 00:47:56.630
But when you try to do smart
things in general, often

00:47:56.630 --> 00:47:59.530
you're going to be missing
an edge case.

00:47:59.530 --> 00:48:02.940
And an edge case could be 25%
of all implementations.

00:48:02.940 --> 00:48:04.310
So I don't know.

00:48:04.310 --> 00:48:06.510
If there was a way to drop down
lower and just say look,

00:48:06.510 --> 00:48:09.610
I know what I'm doing, trust
me, it would be great.

00:48:09.610 --> 00:48:12.930
Like I said, you can do it
on native platforms.

00:48:12.930 --> 00:48:15.360
CHRIS LORD: I guess you've
got Canvas and WebGL.

00:48:15.360 --> 00:48:17.854
You can do it like that.

00:48:17.854 --> 00:48:19.104
SHANE O'SULLIVAN: True.

00:48:21.710 --> 00:48:22.860
MATT DELANEY: Is there
maybe time for one

00:48:22.860 --> 00:48:25.040
more question here?

00:48:25.040 --> 00:48:29.220
So the question from Christina
Auckland, from Hampshire, is

00:48:29.220 --> 00:48:31.840
there an overhead to using
media queries, especially

00:48:31.840 --> 00:48:33.800
bubbling media queries in
your experience, guys?

00:48:37.090 --> 00:48:39.130
PAVEL FELDMAN: I don't know.

00:48:39.130 --> 00:48:40.700
CHRIS LORD: No idea.

00:48:40.700 --> 00:48:42.500
SHANE O'SULLIVAN: Not a clue.

00:48:42.500 --> 00:48:43.750
MATT DELANEY: Then one
more question.

00:48:48.560 --> 00:48:49.610
Oh man.

00:48:49.610 --> 00:48:50.860
Nope.

00:48:52.690 --> 00:48:55.430
We talked about this question
for about five hours last

00:48:55.430 --> 00:48:59.130
night, off and on, like
beating a dead horse.

00:48:59.130 --> 00:49:02.800
Would it be possible to
accelerate reflows, hardware

00:49:02.800 --> 00:49:03.720
accelerate?

00:49:03.720 --> 00:49:06.470
So I think this question's a
bit confused into what it's

00:49:06.470 --> 00:49:07.870
asking, perhaps.

00:49:07.870 --> 00:49:09.760
But it did bring up some
interesting things last night.

00:49:09.760 --> 00:49:12.820
So give you a moment to just
talk about what reflows are,

00:49:12.820 --> 00:49:16.990
perhaps from you guys, and how
that may possibly be hardware

00:49:16.990 --> 00:49:17.990
accelerated.

00:49:17.990 --> 00:49:19.470
PAVEL FELDMAN: I think Google
is definitely hiring.

00:49:19.470 --> 00:49:22.350
So if someone has some bright
ideas on that, they'd be

00:49:22.350 --> 00:49:23.656
definitely interested.

00:49:23.656 --> 00:49:26.230
CHRIS LORD: Ditto.

00:49:26.230 --> 00:49:27.940
I guess, yeah, I think
the question

00:49:27.940 --> 00:49:29.240
might be slightly confused.

00:49:29.240 --> 00:49:33.630
So to kind of go to semi-fast
principles, I'm going to

00:49:33.630 --> 00:49:37.885
assume that DOM tree is
something that we all know.

00:49:37.885 --> 00:49:40.330
But browsers tend to, after you
get a DOM tree, it will

00:49:40.330 --> 00:49:42.530
get passed into a frame tree,
which is a better

00:49:42.530 --> 00:49:45.340
representation of how
it will get drawn.

00:49:45.340 --> 00:49:48.310
And then the frame tree will get
processed, where it will

00:49:48.310 --> 00:49:51.080
calculate where the position
and size of things are.

00:49:51.080 --> 00:49:53.900
And that bit is the reflow.

00:49:53.900 --> 00:49:56.930
So when you change something
that causes a size to change,

00:49:56.930 --> 00:49:58.730
then reflow needs to happen.

00:49:58.730 --> 00:50:00.960
Because the size of certain
elements will be dependent on

00:50:00.960 --> 00:50:02.080
the other elements.

00:50:02.080 --> 00:50:03.770
I say elements, that's
not quite true.

00:50:03.770 --> 00:50:06.590
Because we're in the
frame tree now, but

00:50:06.590 --> 00:50:08.540
for the most part.

00:50:08.540 --> 00:50:12.070
So that's not something
you could put on--

00:50:12.070 --> 00:50:13.900
I mean, you could put it
on the GPU, I guess.

00:50:13.900 --> 00:50:16.220
But it'd be pretty pointless.

00:50:16.220 --> 00:50:17.400
All of that is in
system memory.

00:50:17.400 --> 00:50:20.740
So you'd be shoving that over
to GP memory, and writing a

00:50:20.740 --> 00:50:25.430
really complex set of shaders,
I guess, to work on it.

00:50:25.430 --> 00:50:27.820
And then shovel it back.

00:50:27.820 --> 00:50:29.962
Basically, the answer is no.

00:50:29.962 --> 00:50:34.040
But maybe there are some other
things that we're not

00:50:34.040 --> 00:50:36.470
accelerating right now that we
could, which might be an

00:50:36.470 --> 00:50:37.440
interesting question.

00:50:37.440 --> 00:50:42.840
So from the frame tree, Firefox,
or Gecko rather, will

00:50:42.840 --> 00:50:45.080
make a display list which
represents how it

00:50:45.080 --> 00:50:46.160
would draw the page.

00:50:46.160 --> 00:50:48.470
And then it processes the
display list to create the

00:50:48.470 --> 00:50:49.200
layer tree.

00:50:49.200 --> 00:50:52.580
And I think a similar process
happens in WebKit, possibly

00:50:52.580 --> 00:50:55.030
minus display list or depending
on what fork you're

00:50:55.030 --> 00:51:00.020
using, judging from the
conversation last night.

00:51:00.020 --> 00:51:03.110
Are there other things that
we could accelerate, maybe

00:51:03.110 --> 00:51:05.870
between those things or like
during that thing?

00:51:05.870 --> 00:51:09.390
So for Firefox, most of
the rendering will

00:51:09.390 --> 00:51:11.050
happen on your CPU.

00:51:11.050 --> 00:51:14.700
Certain things will be hardware
accelerated, like

00:51:14.700 --> 00:51:15.660
drawing a big image.

00:51:15.660 --> 00:51:18.390
That might end up being uploaded
to the GPU and

00:51:18.390 --> 00:51:20.740
scaled, for example,
in the GPU.

00:51:20.740 --> 00:51:23.340
Or transforms happen on GPU.

00:51:23.340 --> 00:51:24.790
Blending happens on the GPU.

00:51:24.790 --> 00:51:26.350
But maybe there are other
things that could

00:51:26.350 --> 00:51:27.360
happen on the GPU.

00:51:27.360 --> 00:51:30.640
Like we don't draw gradients
on the GPU at the moment.

00:51:30.640 --> 00:51:32.540
And gradients are a huge hit.

00:51:32.540 --> 00:51:34.460
That's something we
could do, maybe.

00:51:34.460 --> 00:51:36.020
And other elements as well.

00:51:36.020 --> 00:51:39.750
There might be other element
types that would be able to

00:51:39.750 --> 00:51:43.960
take advantage of hardware
accelerated rendering.

00:51:43.960 --> 00:51:46.360
PAVEL FELDMAN: Another hint is
that if you're experiencing

00:51:46.360 --> 00:51:50.060
really slowly, most likely you
are doing a total reflow.

00:51:50.060 --> 00:51:53.110
And in WebKit, you are doing
total reflow if your layout

00:51:53.110 --> 00:51:55.250
root is root of the document.

00:51:55.250 --> 00:51:58.990
Which means in this very
message, you mutated two ports

00:51:58.990 --> 00:52:01.720
of non-intersecting DOMs.

00:52:01.720 --> 00:52:05.010
And they ended up being
the root layout.

00:52:05.010 --> 00:52:09.530
So you figure out what
your layout root is.

00:52:09.530 --> 00:52:12.580
There are simple rules to follow
to make your element

00:52:12.580 --> 00:52:13.150
layout root.

00:52:13.150 --> 00:52:15.140
And make sure you
don't screw it.

00:52:21.500 --> 00:52:23.440
CHRIS LORD: I think we've kind
of mentioned this already.

00:52:23.440 --> 00:52:28.580
But just in case, a lot of the
optimizations that happen on

00:52:28.580 --> 00:52:33.110
the kind of rendering process
are to do with delaying tasks

00:52:33.110 --> 00:52:34.170
and splitting them up.

00:52:34.170 --> 00:52:39.860
So things like, if you can make
everything like a set

00:52:39.860 --> 00:52:43.792
width and height, and never move
it, that would be great.

00:52:43.792 --> 00:52:48.710
But if you do have need to
change something, like if you

00:52:48.710 --> 00:52:52.800
change the width of something,
that is going to trigger a

00:52:52.800 --> 00:52:55.310
reflow probably at some point.

00:52:55.310 --> 00:52:58.900
But that point could be any time
between the time you do

00:52:58.900 --> 00:53:00.410
it and the time that
the frame comes.

00:53:00.410 --> 00:53:02.210
And stuff might happen
in between.

00:53:02.210 --> 00:53:06.370
And if possible, we'll coalesce
these reflows.

00:53:06.370 --> 00:53:08.540
On the other hand, if you change
a width, and then you

00:53:08.540 --> 00:53:11.570
immediately read back the
width of an element that

00:53:11.570 --> 00:53:14.570
depended on that width, you're
forcing that reflow to happen

00:53:14.570 --> 00:53:15.740
immediately.

00:53:15.740 --> 00:53:18.980
And then if you change something
after that, then

00:53:18.980 --> 00:53:21.410
you've got a double
reflow situation.

00:53:21.410 --> 00:53:26.240
So I guess an attempt to maybe
batch stuff is a sort of

00:53:26.240 --> 00:53:27.922
general tip to avoid that.

00:53:27.922 --> 00:53:32.090
PAVEL FELDMAN: Yeah, so to add
to that, we've often seen five

00:53:32.090 --> 00:53:34.660
total reflows happen
within a frame.

00:53:34.660 --> 00:53:36.500
So it's not that the
reflow is slow.

00:53:36.500 --> 00:53:38.070
It's that it's continuously
happening

00:53:38.070 --> 00:53:39.860
within the same message.

00:53:39.860 --> 00:53:42.410
And we have good
tools for that.

00:53:42.410 --> 00:53:45.320
We will show you all the
layouts, and we will show you

00:53:45.320 --> 00:53:48.000
[INAUDIBLE] stacks that
invalidated re-layout, and

00:53:48.000 --> 00:53:49.120
that forced it.

00:53:49.120 --> 00:53:51.560
And you can see a continuous
invocation of

00:53:51.560 --> 00:53:52.700
like five of them.

00:53:52.700 --> 00:53:56.170
And you cut it into a single
one, and all of a sudden your

00:53:56.170 --> 00:54:00.015
performance is OK again.

00:54:00.015 --> 00:54:03.010
MATT DELANEY: So actually, real
final question here from

00:54:03.010 --> 00:54:06.970
the audience is from Paul
Kinlan, he says, yes, does

00:54:06.970 --> 00:54:09.560
scrolling performance in
client-side performance affect

00:54:09.560 --> 00:54:11.620
the time on the site, balance
rate, et cetera?

00:54:11.620 --> 00:54:12.940
And Shane was actually talking
about something pretty

00:54:12.940 --> 00:54:16.120
interesting last night about
what he's seen from Facebook's

00:54:16.120 --> 00:54:16.930
perspective.

00:54:16.930 --> 00:54:19.000
SHANE O'SULLIVAN: Yeah, I kind
of mentioned it a bit earlier.

00:54:19.000 --> 00:54:20.990
But yeah, it absolutely does.

00:54:20.990 --> 00:54:24.910
What we find on Facebook is that
regardless of what you

00:54:24.910 --> 00:54:27.260
do, people have kind of assigned
a certain amount of

00:54:27.260 --> 00:54:29.830
time every day to spend
on the site.

00:54:29.830 --> 00:54:35.740
And the more things that you can
get them to do within say,

00:54:35.740 --> 00:54:37.330
they only spend 20
minutes a day.

00:54:37.330 --> 00:54:41.580
And if you can show them twice
as many pages during that day,

00:54:41.580 --> 00:54:43.510
then it will do twice
as many things.

00:54:43.510 --> 00:54:48.560
The same goes for if people tend
to scroll down, we found

00:54:48.560 --> 00:54:50.650
that when they scroll more,
they see more stories.

00:54:50.650 --> 00:54:53.420
They click like more, they
comment on more things.

00:54:53.420 --> 00:54:55.010
They see people's faces,
and the site

00:54:55.010 --> 00:54:56.920
sends them more messages.

00:54:56.920 --> 00:55:02.440
And when we did add friction
to scrolling, when we added

00:55:02.440 --> 00:55:05.910
varying scroll rates, or when
we added consistently slow

00:55:05.910 --> 00:55:09.505
scroll rates, as soon as we made
anything non-optimal when

00:55:09.505 --> 00:55:13.200
it comes to scrolling, then
people often might stay on the

00:55:13.200 --> 00:55:14.020
site as long.

00:55:14.020 --> 00:55:15.330
So it didn't really affect
bounce rates.

00:55:15.330 --> 00:55:19.910
But they would do far fewer
things, which is why we spend

00:55:19.910 --> 00:55:23.100
so much time obsessing
about scroll rates.

00:55:23.100 --> 00:55:27.590
So scroll rates directly affect
user engagement on

00:55:27.590 --> 00:55:31.330
native, on wave,
on everything.

00:55:31.330 --> 00:55:34.800
Which means our basic site,
which only serves HTML and

00:55:34.800 --> 00:55:37.230
goes on to Nokia phones, gets
fantastic engagement if you

00:55:37.230 --> 00:55:39.280
put it on an iPhone.

00:55:39.280 --> 00:55:40.440
It's extremely fast.

00:55:40.440 --> 00:55:41.050
It's tiny.

00:55:41.050 --> 00:55:41.980
It looks ugly.

00:55:41.980 --> 00:55:44.950
And people engage with it
really, really quickly.

00:55:44.950 --> 00:55:45.640
And you know what?

00:55:45.640 --> 00:55:47.760
It scrolls at 60 frames
per second.

00:55:47.760 --> 00:55:49.010
Because there's no JavaScript.

00:55:51.860 --> 00:55:54.895
Yeah, who knew?

00:55:54.895 --> 00:55:56.145
MATT DELANEY: Any
last thoughts?

00:55:59.420 --> 00:56:01.140
CHRIS LORD: Not really.

00:56:01.140 --> 00:56:04.000
Maybe it'd be nice, like
we're talking a lot

00:56:04.000 --> 00:56:04.830
about scrolling here.

00:56:04.830 --> 00:56:06.710
It's obviously very important.

00:56:06.710 --> 00:56:10.470
And scroll behavior differs
between basically every mobile

00:56:10.470 --> 00:56:14.210
browser in quite big ways.

00:56:14.210 --> 00:56:16.530
Maybe this is something we
should be, or should have been

00:56:16.530 --> 00:56:20.350
collaborating on before.

00:56:20.350 --> 00:56:22.920
Maybe there should be an API
for that, like some kind of

00:56:22.920 --> 00:56:25.090
meta tag or something.

00:56:25.090 --> 00:56:27.540
SHANE O'SULLIVAN: I heard Chrome
team were going to

00:56:27.540 --> 00:56:31.240
start looking at scroll
performance as something to

00:56:31.240 --> 00:56:33.550
instrument, or something
like that.

00:56:33.550 --> 00:56:35.890
PAVEL FELDMAN: Yeah, so that
telemeter that I was talking

00:56:35.890 --> 00:56:38.730
about is the regression testing
for the scrolling

00:56:38.730 --> 00:56:39.220
performance.

00:56:39.220 --> 00:56:42.720
And there is a huge scrolling
effort that, among other

00:56:42.720 --> 00:56:47.850
things, moved the painting to
the impulse side, including

00:56:47.850 --> 00:56:49.880
the image decode and resize.

00:56:49.880 --> 00:56:53.480
And that's already available
on Chrome for Android now.

00:56:53.480 --> 00:56:56.320
Yeah, it's already enabled
for Chrome for Android.

00:56:56.320 --> 00:56:58.980
It's in the About Flags
on the desktop Chrome.

00:56:58.980 --> 00:57:01.940
So you can take a
look at that.

00:57:01.940 --> 00:57:04.040
CHRIS LORD: Sorry, and
one last thing I just

00:57:04.040 --> 00:57:05.160
remembered as well.

00:57:05.160 --> 00:57:09.850
In the Firefox built in profile,
we have a mode that

00:57:09.850 --> 00:57:13.350
we call junk mode, the
like ticker box.

00:57:13.350 --> 00:57:15.900
And then when you start the
profiler and you do some

00:57:15.900 --> 00:57:19.180
stuff, and you stop it, it
will basically show you--

00:57:19.180 --> 00:57:21.570
it will highlight on
the profile exactly

00:57:21.570 --> 00:57:23.420
any hitches in panning.

00:57:23.420 --> 00:57:27.090
So any frame that took longer
than 16 milliseconds or

00:57:27.090 --> 00:57:28.300
whatever to draw.

00:57:28.300 --> 00:57:31.440
You can drill down into just the
operations that were going

00:57:31.440 --> 00:57:32.790
on during that frame.

00:57:32.790 --> 00:57:36.930
And I think, no yeah,
I'm sure, that

00:57:36.930 --> 00:57:41.550
profiler works over ADB.

00:57:41.550 --> 00:57:44.660
So you can run it on your phone
and profile it on the

00:57:44.660 --> 00:57:46.470
desktop, which is
pretty handy.

00:57:46.470 --> 00:57:48.370
So just letting you know.

00:57:51.440 --> 00:57:51.870
MATT DELANEY: So thanks.

00:57:51.870 --> 00:57:53.300
That was Performance Channel.

