WEBVTT
Kind: captions
Language: en

00:00:02.033 --> 00:00:04.000
My name's Steve Souders,
I work at Google.

00:00:04.000 --> 00:00:05.901
And I work on web performance.

00:00:05.901 --> 00:00:07.767
I try to make web sites faster.

00:00:07.767 --> 00:00:10.367
I've been doing this
for about four or five years.

00:00:10.367 --> 00:00:12.334
I've been at Google
about a year and a half.

00:00:12.334 --> 00:00:15.167
Before that, I was
at Yahoo for eight years.

00:00:15.167 --> 00:00:20.300
And all the talks--I do about
15 or 20 conferences a year.

00:00:20.300 --> 00:00:23.133
And for the last year,
all the talks

00:00:23.133 --> 00:00:25.868
have been titled
"Even Faster Web Sites."

00:00:25.868 --> 00:00:28.501
But it doesn't mean
all the talks are identical.

00:00:28.501 --> 00:00:30.667
And in fact,
today is the first time--

00:00:30.667 --> 00:00:35.067
So I have, you know, 20 or 30
different performance tips.

00:00:35.067 --> 00:00:38.801
And I talk about a different
set, depending on the audience,

00:00:38.801 --> 00:00:41.434
or what I haven't
talked about recently.

00:00:41.434 --> 00:00:46.267
And I've been saving back
one set of--one performance tip

00:00:46.267 --> 00:00:49.901
for Google I/O because it was
researched by my office mate,

00:00:49.901 --> 00:00:51.634
Tony Gentilcore at Google.

00:00:51.634 --> 00:00:54.400
So I really wanted to set
that aside for Google I/O

00:00:54.400 --> 00:00:58.734
and, you know, pay tribute
to Google by releasing it--

00:00:58.734 --> 00:01:01.200
revealing it first here.

00:01:01.200 --> 00:01:04.834
So the talk today
is three parts.

00:01:04.834 --> 00:01:07.601
I preamble a little bit
about performance,

00:01:07.601 --> 00:01:09.868
and where I focus on
performance,

00:01:09.868 --> 00:01:11.334
where I think
you really need to focus

00:01:11.334 --> 00:01:15.167
to make a big dent
in page load time.

00:01:15.167 --> 00:01:18.634
And then I dive into these
performance best practices.

00:01:18.634 --> 00:01:20.234
Today I'll be
covering three of them.

00:01:20.234 --> 00:01:24.267
And then I wind up with a little
punch to get us motivated

00:01:24.267 --> 00:01:26.501
to go home and
make our web sites faster.

00:01:26.501 --> 00:01:30.067
And here's the URL, I'll have it
on the last slide as well.

00:01:30.067 --> 00:01:32.267
Or you could just
go to stevesouders.com,

00:01:32.267 --> 00:01:35.033
and you'll see a link next
to Google I/O to these slides.

00:01:35.033 --> 00:01:37.367
So you don't have
to take mad notes or anything.

00:01:39.067 --> 00:01:42.100
So I think one of the biggest
things that I've contributed

00:01:42.100 --> 00:01:45.934
to the world of web performance
is getting people to focus

00:01:45.934 --> 00:01:48.000
more on the front end
than the back end.

00:01:48.000 --> 00:01:52.267
When I started my career
at Yahoo, and before Yahoo

00:01:52.267 --> 00:01:55.667
I was mostly building big
backend architectures--

00:01:55.667 --> 00:02:01.701
databases, data feed systems,
large web sites--

00:02:01.701 --> 00:02:03.901
I ran my Yahoo team
for three years.

00:02:03.901 --> 00:02:08.968
And about four or five years
ago, the folks at Yahoo

00:02:08.968 --> 00:02:12.834
asked me to start a group to
look at making web sites faster.

00:02:12.834 --> 00:02:15.467
And that, I'm embarrassed
to say, was one of the--

00:02:15.467 --> 00:02:16.801
Well, it wasn't
the first time,

00:02:16.801 --> 00:02:18.234
it was maybe
the third or fourth time 

00:02:18.234 --> 00:02:19.868
that I fired up
a packet sniffer.

00:02:19.868 --> 00:02:23.534
So here's a packet sniffer
called IBM Page Detailer.

00:02:23.534 --> 00:02:26.200
And you can get
a limited version for free.

00:02:28.734 --> 00:02:30.801
And the horizontal axis is time.

00:02:30.801 --> 00:02:35.334
And the vertical axis
are HTTP requests.

00:02:35.334 --> 00:02:37.267
And so we can see,
we start with--

00:02:37.267 --> 00:02:40.834
of course the first HTTP request
is for the HTML document.

00:02:40.834 --> 00:02:42.467
And we have these
little icons over here

00:02:42.467 --> 00:02:45.000
that give us a clue
of what's being downloaded.

00:02:45.000 --> 00:02:48.334
And a style sheet, a script,
and a bunch of images.

00:02:48.334 --> 00:02:51.601
And what I noticed, when I first
fired this up on my Yahoo

00:02:51.601 --> 00:02:53.200
about four or five years ago,

00:02:53.200 --> 00:02:57.934
was that a disproportionally
small amount of time was spent

00:02:57.934 --> 00:03:00.868
on what I call the backend part
of this page load.

00:03:00.868 --> 00:03:04.167
So the biggest, most backend
intensive part

00:03:04.167 --> 00:03:07.434
of fetching a page is generating
that HTML document--

00:03:07.434 --> 00:03:10.400
the HTML,
and the other components

00:03:10.400 --> 00:03:11.834
that are inside of that.

00:03:11.834 --> 00:03:13.767
And so that's where
in all of my career

00:03:13.767 --> 00:03:15.934
when I was trying
to make web sites faster,

00:03:15.934 --> 00:03:17.834
that was the portion
of the page load time

00:03:17.834 --> 00:03:20.133
that I had been focusing
all my attention on.

00:03:20.133 --> 00:03:21.601
And really--
Like in this case

00:03:21.601 --> 00:03:23.234
with iGoogle
with an empty cache,

00:03:23.234 --> 00:03:26.734
91% of the time is
what I call the frontend time.

00:03:26.734 --> 00:03:29.267
So this is where
the browser is parsing

00:03:29.267 --> 00:03:31.701
the HTML, the CSS,
the JavaScript,

00:03:31.701 --> 00:03:34.133
applying styles,
executing JavaScript,

00:03:34.133 --> 00:03:37.400
and also
doing more HTTP requests.

00:03:37.400 --> 00:03:40.133
So there is network time, maybe
a little bit of backend time.

00:03:40.133 --> 00:03:43.000
But not that much, because
these are typically static files

00:03:43.000 --> 00:03:46.501
that are being read off a disk
or out of memory cache.

00:03:46.501 --> 00:03:50.834
So we see 91% of
the time in this situation--

00:03:50.834 --> 00:03:54.767
iGoogle with an empty cache--is
spent on this "frontend" part.

00:03:54.767 --> 00:03:58.167
So, you know,
maybe four or five years ago,

00:03:58.167 --> 00:04:00.868
a lot of attention
in making web sites faster was

00:04:00.868 --> 00:04:03.267
in improving, you know,
your Apache handlers,

00:04:03.267 --> 00:04:06.000
your C++ code,
your database indices.

00:04:06.000 --> 00:04:09.334
And really, that is
just improving this 9% chunk.

00:04:09.334 --> 00:04:12.400
So when I noticed this, I said,
"Hm, well maybe this, you know,

00:04:12.400 --> 00:04:15.200
longer pole in the tent is the
place we should be focusing."

00:04:15.200 --> 00:04:16.767
So I looked at this
a little bit more.

00:04:16.767 --> 00:04:19.133
I said, "Well, what if--
what if the cache was primed?"

00:04:19.133 --> 00:04:22.000
'Cause really about 80%
of page views for any web site

00:04:22.000 --> 00:04:24.667
are done with users
that have a primed cache.

00:04:24.667 --> 00:04:27.701
And we still see
that only 17% is getting

00:04:27.701 --> 00:04:30.801
this HTML document, which
involves the most intensive

00:04:30.801 --> 00:04:32.067
part of the backend work.

00:04:32.067 --> 00:04:35.501
And 83% is the frontend part.

00:04:35.501 --> 00:04:37.267
So this big white gap
is where there's

00:04:37.267 --> 00:04:38.968
no network requests going on

00:04:38.968 --> 00:04:42.334
because all these resources
have been cached to disk,

00:04:42.334 --> 00:04:46.133
But the browser still has to
read those files off disk.

00:04:46.133 --> 00:04:47.901
And if
they're CSS or JavaScript,

00:04:47.901 --> 00:04:50.334
parse them, execute them,
apply them, et cetera.

00:04:50.334 --> 00:04:53.367
And this isn't just true
with iGoogle or myYahoo,

00:04:53.367 --> 00:04:55.400
like I
discovered five years ago.

00:04:55.400 --> 00:04:57.033
Here's the Alexa Top Ten.

00:04:57.033 --> 00:05:00.734
And we see,
for a majority of these,

00:05:00.734 --> 00:05:04.567
less than 10 or 20%
of the end user wait time

00:05:04.567 --> 00:05:06.901
is spent
getting the HTML document.

00:05:06.901 --> 00:05:09.334
And that actually
includes the request going up,

00:05:09.334 --> 00:05:11.167
the backend
stitching it all together,

00:05:11.167 --> 00:05:13.934
and all of the packets--
the response coming back.

00:05:13.934 --> 00:05:15.968
So that is less than 10 or 20%

00:05:15.968 --> 00:05:18.200
of the overall time
that the user is waiting.

00:05:18.200 --> 00:05:21.300
So really, if you want
to make web sites faster,

00:05:21.300 --> 00:05:23.434
you've got to focus
on this frontend part.

00:05:23.434 --> 00:05:25.000
I think that's one of
the biggest things

00:05:25.000 --> 00:05:27.234
that I've tried
to promote, evangelize

00:05:27.234 --> 00:05:28.868
among
the web development community.

00:05:28.868 --> 00:05:32.100
That's having
some positive effect.

00:05:32.100 --> 00:05:34.601
So I call that
the performance golden rule.

00:05:34.601 --> 00:05:36.167
If you want
to make web sites faster,

00:05:36.167 --> 00:05:39.133
you got to focus on this
frontend part, because that's

00:05:39.133 --> 00:05:43.267
where 80 to 90% of the page load
time is being consumed.

00:05:43.267 --> 00:05:45.667
And there's three
kind of lessons learned

00:05:45.667 --> 00:05:49.300
for why, you know, that
you should keep that in mind.

00:05:49.300 --> 00:05:51.467
Just a priori probability

00:05:51.467 --> 00:05:53.667
there's a greater chance
of making an impact.

00:05:53.667 --> 00:05:56.267
You can cut
that backend time in half,

00:05:56.267 --> 00:05:59.400
you'd only do a 5 or 10% dent
in the load time,

00:05:59.400 --> 00:06:02.033
whereas if you could cut
this frontend time in half,

00:06:02.033 --> 00:06:04.100
that's 40 to 50%.

00:06:04.100 --> 00:06:06.133
So it's going to be
much more noticeable by users.

00:06:06.133 --> 00:06:08.133
The changes are simpler.

00:06:08.133 --> 00:06:10.067
If you want to cut
the backend time down,

00:06:10.067 --> 00:06:12.467
you've got to replicate
your application logic

00:06:12.467 --> 00:06:15.934
across multiple data centers--
database replication.

00:06:15.934 --> 00:06:20.667
You've got to, you know,
analyze your database queries

00:06:20.667 --> 00:06:22.400
in your indices,
and improve those.

00:06:22.400 --> 00:06:25.834
Maybe change your code design,

00:06:25.834 --> 00:06:28.701
the way your compiler
options--things like that.

00:06:28.701 --> 00:06:31.767
These are multi-month,
multi-year sorts of projects.

00:06:31.767 --> 00:06:34.868
Whereas the things
that I evangelize changing

00:06:34.868 --> 00:06:37.868
are things like turn on
compression in your web server,

00:06:37.868 --> 00:06:41.334
move a script from up here
to down here in the page--

00:06:41.334 --> 00:06:43.400
these are changes
that take a person hours,

00:06:43.400 --> 00:06:44.968
person days at the most.

00:06:44.968 --> 00:06:47.667
So they're simpler changes,
and they're proven to work.

00:06:47.667 --> 00:06:50.167
So every week,
I get two or three emails,

00:06:50.167 --> 00:06:52.400
at conferences like this,
people come up,

00:06:52.400 --> 00:06:54.767
and the typical feedback is,

00:06:54.767 --> 00:06:59.167
"I applied--or at my job,
we applied three or four

00:06:59.167 --> 00:07:02.601
of your performance best
practices and cut 25% off."

00:07:02.601 --> 00:07:06.033
So if you find the ones--
for example, reported by YSlow--

00:07:06.033 --> 00:07:09.834
that are
the most important ones to fix,

00:07:09.834 --> 00:07:11.367
and you fix
those three or four,

00:07:11.367 --> 00:07:14.300
it's pretty easy
to get a 25% speedup.

00:07:14.300 --> 00:07:18.334
And I've seen sites get as much
as a 50 or 60% speedup.

00:07:18.334 --> 00:07:22.968
So those are the reasons why you
should focus on the front end.

00:07:22.968 --> 00:07:25.567
So as I started
this work at Yahoo,

00:07:25.567 --> 00:07:27.734
investigating this area--
so now I knew,

00:07:27.734 --> 00:07:29.601
okay, well, we want
to focus on making

00:07:29.601 --> 00:07:32.167
the frontend time faster.

00:07:32.167 --> 00:07:34.267
So where's that time
being consumed?

00:07:34.267 --> 00:07:37.033
And what can we do
to cut that time down?

00:07:37.033 --> 00:07:38.567
I came up
with this list of rules.

00:07:41.767 --> 00:07:43.200
So this was
from doing research,

00:07:43.200 --> 00:07:44.934
going around
and talking to other teams.

00:07:44.934 --> 00:07:47.467
I found that the same mistakes
were being made

00:07:47.467 --> 00:07:49.100
over and over and over again.

00:07:49.100 --> 00:07:51.167
I started--as
we fixed these, and we saw

00:07:51.167 --> 00:07:52.701
how much of
an improvement it made,

00:07:52.701 --> 00:07:54.767
I started
keeping a list of the ones

00:07:54.767 --> 00:07:57.868
that most consistently
improved web sites,

00:07:57.868 --> 00:08:01.334
and I ordered them in order
of having the highest impact.

00:08:01.334 --> 00:08:03.567
So for example,
if you can reduce the number

00:08:03.567 --> 00:08:05.868
of HTTP requests,
that's the most important thing

00:08:05.868 --> 00:08:08.767
you can do to speed up
your web site in most cases.

00:08:08.767 --> 00:08:11.234
So I had these rules,
and I would go around

00:08:11.234 --> 00:08:14.634
and do consulting with
different teams within Yahoo,

00:08:14.634 --> 00:08:17.701
and there just wasn't
enough time to reach everybody.

00:08:17.701 --> 00:08:20.701
So I wanted to make--
capture this logic in a way

00:08:20.701 --> 00:08:24.067
that teams could
analyze web sites themselves

00:08:24.067 --> 00:08:26.901
and find the best advice
of what to work on.

00:08:26.901 --> 00:08:29.267
So I built
this tool called YSlow.

00:08:29.267 --> 00:08:32.801
And it started off as
a bookmarklet,

00:08:32.801 --> 00:08:35.033
then a Greasemonkey script, 

00:08:35.033 --> 00:08:37.534
and finally became
an extension to Firebug

00:08:37.534 --> 00:08:38.734
with Joe Hewitt's help.

00:08:38.734 --> 00:08:40.801
And this is YSlow 1.0.

00:08:40.801 --> 00:08:43.033
I haven't updated the screen
dump; I should do that.

00:08:43.033 --> 00:08:45.601
And basically, you can run it
on any web site,

00:08:45.601 --> 00:08:50.334
and it tells you--it gives you
a grade for each of these rules.

00:08:50.334 --> 00:08:52.434
Each of the rules is a link,
so you can click on it

00:08:52.434 --> 00:08:54.267
and see a one-page description

00:08:54.267 --> 00:08:58.601
of what that rule
is trying to point out.

00:08:58.601 --> 00:09:01.234
And then it
analyzes the web page

00:09:01.234 --> 00:09:03.667
and tells you
exactly what needs to be fixed

00:09:03.667 --> 00:09:07.434
on the web page to raise
the score for that rule.

00:09:09.067 --> 00:09:10.367
And so this is really good.

00:09:10.367 --> 00:09:11.801
Now people can run this

00:09:11.801 --> 00:09:14.767
and get specific lists
of improvements to make.

00:09:14.767 --> 00:09:18.934
It's almost like a "to do" list
for your project.

00:09:18.934 --> 00:09:22.634
And going a little bit
out of order here,

00:09:22.634 --> 00:09:26.300
I started going around
and evangelizing YSlow

00:09:26.300 --> 00:09:30.067
and these best practices, going
to companies and giving talks--

00:09:30.067 --> 00:09:33.400
Amazon, Microsoft, Zillo--
companies like that.

00:09:33.400 --> 00:09:38.300
And what I found was there was
this community of web developers

00:09:38.300 --> 00:09:41.133
that really were
passionate about performance

00:09:41.133 --> 00:09:42.901
and making
the user experience faster.

00:09:42.901 --> 00:09:45.300
And so I talked
to Tim O'Reilly about the need

00:09:45.300 --> 00:09:48.300
to create a community for these
engineers to come together.

00:09:48.300 --> 00:09:52.033
And that was the start
of the Velocity conference.

00:09:52.033 --> 00:09:54.200
Jesse Robbins and I
co-chair that.

00:09:54.200 --> 00:09:57.167
I work on the performance part.
He works on the operations part.

00:09:57.167 --> 00:09:59.534
And so we had
our first year last year.

00:09:59.534 --> 00:10:00.767
It was extremely successful.

00:10:00.767 --> 00:10:02.801
Twice as many people
showed up as expected.

00:10:02.801 --> 00:10:04.701
And we're doing
that again next month.

00:10:04.701 --> 00:10:08.100
And there's a 15% discount code
if you want to go.

00:10:08.100 --> 00:10:09.767
And I've got some flyers
up here on stage,

00:10:09.767 --> 00:10:12.367
if you want to take something
with you when you leave.

00:10:12.367 --> 00:10:15.467
So that's coming up.
So I evangelize there.

00:10:15.467 --> 00:10:18.334
Also last fall,
I taught a course at Stanford

00:10:18.334 --> 00:10:20.400
called
"High Performance Web Sites."

00:10:20.400 --> 00:10:23.868
So I've got 30 hours of slides

00:10:23.868 --> 00:10:28.200
that we could go over
in more detail at some point.

00:10:28.200 --> 00:10:29.901
And actually,
they just put the--

00:10:29.901 --> 00:10:31.400
last week they put the video--

00:10:31.400 --> 00:10:34.734
all 30 hours of video of
the lectures are now available

00:10:34.734 --> 00:10:37.634
up on the SCPD web site.

00:10:39.667 --> 00:10:45.834
In September 2007,
I got my first book published,

00:10:45.834 --> 00:10:48.267
"High Performance Web Sites."
It did really well.

00:10:48.267 --> 00:10:50.567
It climbed
to the number one spot

00:10:50.567 --> 00:10:52.968
on Amazon's
Computer and Internet Category.

00:10:52.968 --> 00:10:55.834
And it's
still doing pretty well.

00:10:55.834 --> 00:10:58.167
And it's a good book.
I've got it here.

00:10:58.167 --> 00:11:00.734
I carry it with me because
I'm a little absent-minded,

00:11:00.734 --> 00:11:02.267
and people
ask me questions about it

00:11:02.267 --> 00:11:03.501
and I have to look it up.

00:11:03.501 --> 00:11:05.801
And one of the things
I felt bad about when

00:11:05.801 --> 00:11:08.100
I got the first bound copy
was how thin it was.

00:11:08.100 --> 00:11:09.534
I felt a little wimpy.

00:11:09.534 --> 00:11:12.133
And I've gotten
nothing but positive feedback

00:11:12.133 --> 00:11:15.100
on how easy it is
to read and get through it.

00:11:15.100 --> 00:11:16.601
Some people read it
in one sitting.

00:11:16.601 --> 00:11:19.334
And so I haven't
been sitting idle since then.

00:11:19.334 --> 00:11:20.901
I've been
working on a follow-up book,

00:11:20.901 --> 00:11:23.167
called "Even Faster Web Sites."

00:11:23.167 --> 00:11:27.901
And that should be coming out
in just a few weeks, June 15th.

00:11:29.300 --> 00:11:31.200
And these are the chapters
that I wrote for it.

00:11:31.200 --> 00:11:34.501
And as much as I like thin
books, and I hope you do too,

00:11:34.501 --> 00:11:36.501
this would be a very thin book.

00:11:36.501 --> 00:11:38.868
And I had other chapters
I wanted to write,

00:11:38.868 --> 00:11:42.701
but I found I was
just reiterating things

00:11:42.701 --> 00:11:45.968
that other experts in the field
had already been talking about.

00:11:45.968 --> 00:11:47.901
So I just asked
these people if they would

00:11:47.901 --> 00:11:49.701
contribute chapters to the book.

00:11:49.701 --> 00:11:51.501
And luckily they said yes.

00:11:51.501 --> 00:11:54.467
So we have Doug Crockford
talking about at a high level

00:11:54.467 --> 00:11:55.934
the importance of performance

00:11:55.934 --> 00:11:58.801
with regards to Ajax,
and JavaScript, and JSON.

00:11:58.801 --> 00:12:01.100
Ben and Dion talking about

00:12:01.100 --> 00:12:05.567
creating responsive
user interfaces with Ajax.

00:12:05.567 --> 00:12:09.167
Nicholas Zakas at Yahoo--
a big JavaScript guru author--

00:12:09.167 --> 00:12:12.033
talking about
some more fine grain

00:12:12.033 --> 00:12:14.968
performance optimizations
to be made with JavaScript.

00:12:14.968 --> 00:12:18.067
Dylan Schiemann runs
Sitepen, the Dojo Project,

00:12:18.067 --> 00:12:19.667
and also Comet Daily Blog.

00:12:19.667 --> 00:12:20.901
He's here to talk about Comet.

00:12:20.901 --> 00:12:23.834
And we're talk--my office mate,
Tony Gentilcore,

00:12:23.834 --> 00:12:26.334
wrote the chapter
on "Going Beyond Gzip,"

00:12:26.334 --> 00:12:27.834
which today
will be the first time

00:12:27.834 --> 00:12:29.767
it's been discussed publicly.

00:12:29.767 --> 00:12:32.834
And Nicole and Stoyan,
of course the industry experts

00:12:32.834 --> 00:12:36.567
on image optimization, wrote
theimage optimization chapter.

00:12:36.567 --> 00:12:38.400
So today
I'm going to talk about

00:12:38.400 --> 00:12:40.534
flushing the document early,

00:12:40.534 --> 00:12:43.767
simplifying CSS selectors,
and going beyond gzipping.

00:12:43.767 --> 00:12:45.734
Okay, so that
was the first part of

00:12:45.734 --> 00:12:48.334
the three parts
of the talk--the preamble.

00:12:48.334 --> 00:12:49.767
So now we'll get into the meat.

00:12:49.767 --> 00:12:52.267
And...
flushing the document early--

00:12:52.267 --> 00:12:57.234
or the potty humor rule,
as I like to call it.

00:12:57.234 --> 00:13:01.868
So here's a typical waterfall
chart that you might see

00:13:01.868 --> 00:13:03.601
for some HTML page.

00:13:03.601 --> 00:13:06.000
The first request
is an HTML document,

00:13:06.000 --> 00:13:09.067
and it has
some images and a script.

00:13:09.067 --> 00:13:12.200
And this is the way
you would normally expect

00:13:12.200 --> 00:13:13.868
to see it load, right?

00:13:13.868 --> 00:13:16.434
The HTML document comes back,
the browser parses that,

00:13:16.434 --> 00:13:19.267
figures out what resources
it has to download,

00:13:19.267 --> 00:13:21.868
downloads those resources,
and renders the page.

00:13:21.868 --> 00:13:24.601
And the bad thing is that
when the user clicks

00:13:24.601 --> 00:13:27.667
on the link right here,
there's nothing that happens

00:13:27.667 --> 00:13:30.501
in the browser
until right here, right?

00:13:30.501 --> 00:13:34.501
This stuff is coming back,
and all that time

00:13:34.501 --> 00:13:37.000
the user is waiting
and the browser is idle,

00:13:37.000 --> 00:13:38.334
not really doing anything.

00:13:38.334 --> 00:13:40.801
So is there a way
that we can take advantage

00:13:40.801 --> 00:13:42.234
of that idle time?

00:13:42.234 --> 00:13:43.567
It turns out there is.

00:13:43.567 --> 00:13:45.834
In PHP, there's
this function called flush.

00:13:45.834 --> 00:13:49.501
In this case, this example is my
web site that's written in PHP.

00:13:49.501 --> 00:13:51.534
So at this point in the page--

00:13:51.534 --> 00:13:55.234
after I had assembled
the head of the HTML document

00:13:55.234 --> 00:13:57.234
and a couple images up
at the top

00:13:57.234 --> 00:13:58.801
and a script
that was in the head--

00:13:58.801 --> 00:14:01.234
I called PHP's flush function.

00:14:01.234 --> 00:14:05.767
And that sends normally, as
you're echoing output from PHP,

00:14:05.767 --> 00:14:07.834
it gets queued up
and standard out.

00:14:07.834 --> 00:14:09.367
And then finally at some point--

00:14:09.367 --> 00:14:12.033
typically depending
on the size of your document--

00:14:12.033 --> 00:14:13.434
but typically
when you're done with

00:14:13.434 --> 00:14:15.968
your PHP template or script,

00:14:15.968 --> 00:14:18.033
then it gets flushed
to the user.

00:14:18.033 --> 00:14:19.834
But by calling flush explicitly,

00:14:19.834 --> 00:14:21.601
I can get
all of those characters

00:14:21.601 --> 00:14:23.367
that have been
buffered and standard out

00:14:23.367 --> 00:14:25.767
sent over the wire
right at that point.

00:14:25.767 --> 00:14:29.033
And all browsers
will take that partial response

00:14:29.033 --> 00:14:31.501
and start parsing it
and acting on it.

00:14:31.501 --> 00:14:35.234
So we can actually get
the browser to start downloading

00:14:35.234 --> 00:14:39.234
and rendering resources even
before the entire HTML document

00:14:39.234 --> 00:14:42.501
has been finished being stitched
together by the backend server.

00:14:42.501 --> 00:14:46.200
So this is really powerful,
but there are a lot of gotchas.

00:14:46.200 --> 00:14:49.601
If you read the manpa--
the document page for flush

00:14:49.601 --> 00:14:53.667
on PHP's web site, you'll
see a lot of people complaining

00:14:53.667 --> 00:14:56.033
about not being able
to get it to work.

00:14:56.033 --> 00:14:58.801
And so here are
some of the typical problems.

00:14:58.801 --> 00:15:00.534
If you have
output buffering on--

00:15:00.534 --> 00:15:04.601
That's actually another layer of
buffers on top of standard out.

00:15:04.601 --> 00:15:06.834
And so, if you just call flush,

00:15:06.834 --> 00:15:08.667
there isn't anything
in standard out to flush

00:15:08.667 --> 00:15:10.601
'cause it's been buffered
in this output buffer.

00:15:10.601 --> 00:15:12.767
So you have
to call the OB functions,

00:15:12.767 --> 00:15:16.501
like ob_flush, to actually flush
that to standard out

00:15:16.501 --> 00:15:18.067
and then call flush again.

00:15:18.067 --> 00:15:20.734
I go into more detail on this
in the book

00:15:20.734 --> 00:15:22.767
and a blog post
I wrote about it.

00:15:22.767 --> 00:15:26.267
Typically, you have
to have transfer encoding--

00:15:26.267 --> 00:15:28.033
chunked encoding enabled.

00:15:28.033 --> 00:15:30.234
And most web servers--
IIS and Apache--

00:15:30.234 --> 00:15:31.667
will take care of this for you.

00:15:31.667 --> 00:15:33.734
But if you ever
see that it's not working,

00:15:33.734 --> 00:15:35.367
if you're
trying to get this to work

00:15:35.367 --> 00:15:36.934
and it
doesn't seem to be working,

00:15:36.934 --> 00:15:40.200
look for that
transfer encoded chunked--

00:15:40.200 --> 00:15:42.734
encoding chunked header
in the response.

00:15:42.734 --> 00:15:44.868
If you don't see it,
you've got to get that working

00:15:44.868 --> 00:15:47.300
to make it function properly.

00:15:47.300 --> 00:15:50.200
If you're gzipping
your response,

00:15:50.200 --> 00:15:52.434
which hopefully you are,
and you're using Apache

00:15:52.434 --> 00:15:57.634
earlier than 2.2.8,
there's an 8K gzip buffer--

00:15:57.634 --> 00:16:00.934
the deflate buffer size is--
is 8K by default.

00:16:00.934 --> 00:16:04.901
So you either need to lower that
or have 8K of compressed content

00:16:04.901 --> 00:16:08.934
when you call flush, otherwise
it actually won't get flushed.

00:16:08.934 --> 00:16:12.267
If you're running anti-virus
software, security software

00:16:12.267 --> 00:16:16.968
on your client, or you're going
through an intermediate proxy,

00:16:16.968 --> 00:16:21.934
many of them will
not honor the flushing--

00:16:21.934 --> 00:16:23.334
the chunked responses.

00:16:23.334 --> 00:16:25.834
It'll queue them all up
and hand them all off

00:16:25.834 --> 00:16:30.067
to the browser in one chunk.

00:16:30.067 --> 00:16:32.100
So you have to check for that
and make sure that

00:16:32.100 --> 00:16:36.634
those intermediaries aren't
stopping flushing from working.

00:16:36.634 --> 00:16:39.400
And then finally
you'll get through all of these,

00:16:39.400 --> 00:16:41.567
and it will work on
IE or Firefox

00:16:41.567 --> 00:16:43.300
but not on Safari or Chrome.

00:16:43.300 --> 00:16:45.634
And that is if you're chunked--

00:16:45.634 --> 00:16:48.067
if your flush chunk
is too small--

00:16:48.067 --> 00:16:50.501
and in the case of Safari
if it's under 1K,

00:16:50.501 --> 00:16:54.601
or Chrome if it's under 2K,
and in IE it's 255 bytes--

00:16:54.601 --> 00:16:57.868
then the browser actually
won't start acting on it.

00:16:57.868 --> 00:17:01.367
So you might need
to get over those thresholds

00:17:01.367 --> 00:17:04.000
to actually see flushing work.

00:17:04.000 --> 00:17:06.434
And it's flush in PHP,

00:17:06.434 --> 00:17:08.901
but most other backend
templating language

00:17:08.901 --> 00:17:11.467
have a function that
has flush somewhere in the name.

00:17:11.467 --> 00:17:13.834
In Perl,
there's autoflush.

00:17:13.834 --> 00:17:16.033
Python, flush. Ruby, flush.

00:17:16.033 --> 00:17:18.701
So you can probably
find something like flush

00:17:18.701 --> 00:17:20.300
in whatever language
you're using.

00:17:20.300 --> 00:17:26.100
One other gotcha that
I've tripped across before

00:17:26.100 --> 00:17:30.901
is where--here I'm using IE 7,

00:17:30.901 --> 00:17:33.968
which will open two connections
per server name.

00:17:33.968 --> 00:17:37.634
And this script down here at the
bottom is on a different domain.

00:17:37.634 --> 00:17:39.667
But these two images are on

00:17:39.667 --> 00:17:42.033
the same domain
as the HTML document.

00:17:42.033 --> 00:17:44.801
And so when I called flush,
I expected all three

00:17:44.801 --> 00:17:47.400
of the resources--
the two images and the script--

00:17:47.400 --> 00:17:49.267
to all start downloading early.

00:17:49.267 --> 00:17:51.701
But one of them didn't,
and I couldn't figure out why

00:17:51.701 --> 00:17:53.000
because
there's only two images

00:17:53.000 --> 00:17:54.667
and it
should open two connections.

00:17:54.667 --> 00:17:57.367
I forgot the first
connection to that server

00:17:57.367 --> 00:17:59.901
was still being used
by the HTML document.

00:17:59.901 --> 00:18:02.367
So until
the HTML document finished,

00:18:02.367 --> 00:18:04.234
this image was blocked.

00:18:04.234 --> 00:18:07.367
So if you are trying
to get multiple resources

00:18:07.367 --> 00:18:09.501
downloaded as
part of your flushing,

00:18:09.501 --> 00:18:11.200
make sure that
you're not getting blocking

00:18:11.200 --> 00:18:14.634
with the main
HTML document request.

00:18:14.634 --> 00:18:18.267
So if I move that image to be
on a different domain name,

00:18:18.267 --> 00:18:20.868
then I get all three
of them downloading early.

00:18:22.200 --> 00:18:24.934
So I looked across
at the Alexa Top Ten,

00:18:24.934 --> 00:18:29.133
and found--I was glad
to see that Google Search

00:18:29.133 --> 00:18:31.901
was the only one
that was doing flushing

00:18:31.901 --> 00:18:34.467
that was
very obvious in the download.

00:18:34.467 --> 00:18:36.100
And so here,
we see we're downloading--

00:18:36.100 --> 00:18:38.267
I'm downloading
a Google Search results page.

00:18:38.267 --> 00:18:42.100
And we get this image request
that actually starts downloading

00:18:42.100 --> 00:18:44.133
even before
the finished search results

00:18:44.133 --> 00:18:45.901
have arrived to the browser.

00:18:45.901 --> 00:18:49.033
And what this is,
this is the nav logo image,

00:18:49.033 --> 00:18:50.567
which is a sprite.

00:18:50.567 --> 00:18:53.100
And this is really great that
this is being downloaded early

00:18:53.100 --> 00:18:56.200
because that word "Google"
is displayed at the top.

00:18:56.200 --> 00:18:59.400
So by flushing it right after
that point in the page,

00:18:59.400 --> 00:19:04.133
it start--it kicks off
that image download earlier than

00:19:04.133 --> 00:19:06.667
it would've otherwise,
and it allows the browser

00:19:06.667 --> 00:19:10.133
to render that top part
of the page, giving the user,

00:19:10.133 --> 00:19:11.601
you know,
progressive rendering--

00:19:11.601 --> 00:19:13.367
that feeling that the page is

00:19:13.367 --> 00:19:16.467
responding to them faster
than it would've otherwise.

00:19:18.334 --> 00:19:22.567
So this is a great success story
of how flushing works.

00:19:22.567 --> 00:19:24.701
We get resources
downloading earlier

00:19:24.701 --> 00:19:26.467
and the page rendering earlier.

00:19:26.467 --> 00:19:30.000
So it really promotes
a faster user experience.

00:19:30.000 --> 00:19:31.901
Okay, this one's
a little bit longer.

00:19:31.901 --> 00:19:34.767
Simplifying CSS Selectors.

00:19:34.767 --> 00:19:37.501
So, I didn't pay too--
like, I didn't talk about CSS

00:19:37.501 --> 00:19:39.200
hardly at all in the first book.

00:19:39.200 --> 00:19:41.467
And up until
about six, eight months ago,

00:19:41.467 --> 00:19:44.300
I hadn't spent too much time
researching CSS.

00:19:44.300 --> 00:19:46.200
But about eight months ago,

00:19:46.200 --> 00:19:48.067
there started
to be more and more discussion

00:19:48.067 --> 00:19:51.934
on the popular blogs
about CSS and performance.

00:19:51.934 --> 00:19:55.334
And so for this book, I wanted
to dedicate a chapter to that.

00:19:55.334 --> 00:19:58.300
And I think the main performance
problem that gets discussed

00:19:58.300 --> 00:20:00.400
is the performance
of CSS selectors.

00:20:00.400 --> 00:20:02.234
So let me dig into that
a little bit.

00:20:02.234 --> 00:20:04.100
So this is a CSS rule.

00:20:04.100 --> 00:20:07.934
And we have the selector part:
TOC greater than LI.

00:20:07.934 --> 00:20:10.501
The other part--
the actual styles,

00:20:10.501 --> 00:20:12.100
is the declaration block.

00:20:12.100 --> 00:20:15.267
Each part of the selector
is a simple selector.

00:20:15.267 --> 00:20:17.734
And here we have
the greater than combinator.

00:20:17.734 --> 00:20:20.267
And I'll talk about these
combinators a little bit more.

00:20:20.267 --> 00:20:23.501
So there's different
types of those CSS selectors.

00:20:23.501 --> 00:20:25.734
So I'm just going to focus
on that first part of the rule,

00:20:25.734 --> 00:20:27.701
the matching part,
the selector part.

00:20:27.701 --> 00:20:30.968
And these are in order
from simplest to more complex.

00:20:30.968 --> 00:20:32.501
So there's ID selectors.

00:20:32.501 --> 00:20:36.267
So this will match the element
with ID equals the toc.

00:20:36.267 --> 00:20:38.200
There should be only
one of those in the page.

00:20:38.200 --> 00:20:40.234
So this would be very easy
for the browser to match,

00:20:40.234 --> 00:20:41.734
should be very fast.

00:20:41.734 --> 00:20:43.701
Class selectors--
any element that has

00:20:43.701 --> 00:20:46.434
class equals chapter
this rule will match.

00:20:46.434 --> 00:20:51.901
Any element that's an anchor
this CSS rule will match.

00:20:54.133 --> 00:20:56.501
Now we get into
some more complex ones.

00:20:56.501 --> 00:20:58.801
So here we're
using the plus combinator.

00:20:58.801 --> 00:21:00.667
These are
adjacent sibling selectors,

00:21:00.667 --> 00:21:04.167
so two elements that are
previous next to each other.

00:21:04.167 --> 00:21:08.634
If we have an H1,
and the next sibling element

00:21:08.634 --> 00:21:12.834
is one with ID TOC,
then this styling will match.

00:21:12.834 --> 00:21:16.167
Child selectors--
any list item that is

00:21:16.167 --> 00:21:20.501
a child whose parent is TOC,
this rule will match.

00:21:20.501 --> 00:21:23.100
This is kind of like
a child selector,

00:21:23.100 --> 00:21:27.167
but it goes--
it matches any ancestor.

00:21:27.167 --> 00:21:30.367
So any anchor
at any depth under TOC

00:21:30.367 --> 00:21:32.033
will be matched
by this selector.

00:21:32.033 --> 00:21:33.501
And there's more.

00:21:33.501 --> 00:21:35.400
Universal selectors,
very painful.

00:21:35.400 --> 00:21:37.601
The star
will match all elements.

00:21:37.601 --> 00:21:41.634
Attribute selectors--the
browser actually has to check

00:21:41.634 --> 00:21:43.300
for elements
that have this attribute.

00:21:43.300 --> 00:21:45.901
And if a value is specified,
does the attribute

00:21:45.901 --> 00:21:47.801
match the value
in the selector?

00:21:47.801 --> 00:21:51.534
And then these
aren't really selectors,

00:21:51.534 --> 00:21:52.934
but I wanted to mention them,

00:21:52.934 --> 00:21:56.200
and they do carry
a pretty heavy cost frequently.

00:21:56.200 --> 00:21:58.067
Pseudo classes
and pseudo elements.

00:21:58.067 --> 00:22:01.901
So these are
for customizing rules

00:22:01.901 --> 00:22:06.300
for behavior that's not captured
in the DOM, like hover.

00:22:07.801 --> 00:22:10.667
So probably the most popular--

00:22:10.667 --> 00:22:13.300
If you do a search
for efficient CSS selectors,

00:22:13.300 --> 00:22:16.367
you'll get this result
as the number one result.

00:22:16.367 --> 00:22:20.801
And the first sentence reveals,
I think, what previously

00:22:20.801 --> 00:22:22.601
had been a little-known fact.

00:22:22.601 --> 00:22:25.767
That the way all browsers
match CSS selectors

00:22:25.767 --> 00:22:28.501
is not left to right,
as many of us English readers

00:22:28.501 --> 00:22:29.834
would've expected.

00:22:29.834 --> 00:22:33.234
It actually matches
right to left.

00:22:33.234 --> 00:22:34.901
So now,
when we look at these rules

00:22:34.901 --> 00:22:36.501
that at first
seemed like they wouldn't

00:22:36.501 --> 00:22:38.000
be much of
a performance problem,

00:22:38.000 --> 00:22:40.200
we can see that
this could really challenge

00:22:40.200 --> 00:22:42.901
the browser's performance
in the loading of the page.

00:22:42.901 --> 00:22:46.067
So here, instead of--
like,I have a TOC element

00:22:46.067 --> 00:22:47.667
that has six LIs in it.

00:22:47.667 --> 00:22:50.400
I'm thinking, "Okay, well,
the browser finds the TOC,

00:22:50.400 --> 00:22:51.968
"and then
finds the six elements that--

00:22:51.968 --> 00:22:53.934
list item elements,
that's easy."

00:22:53.934 --> 00:22:55.200
Instead it's the other way.

00:22:55.200 --> 00:22:57.601
The browser has to look
at every LI in the page

00:22:57.601 --> 00:23:01.501
and look at its parent
to see if its ID equals TOC.

00:23:01.501 --> 00:23:03.367
So depending
on how many lists you have,

00:23:03.367 --> 00:23:05.067
that could be
a pretty expensive match.

00:23:05.067 --> 00:23:08.634
This one's even worse.

00:23:08.634 --> 00:23:10.601
Again, TOC
only had six anchors,

00:23:10.601 --> 00:23:12.200
so I think,
"Okay, what's the big deal?"

00:23:12.200 --> 00:23:14.701
Find TOC, find the six children
that are anchors.

00:23:14.701 --> 00:23:16.200
Instead,
it's the other way around.

00:23:16.200 --> 00:23:18.367
The browser has to find
all the anchors in the page.

00:23:18.367 --> 00:23:20.033
And not just look
at the parent,

00:23:20.033 --> 00:23:22.634
but climb all the way up
the ancestor tree

00:23:22.634 --> 00:23:25.501
until it either
finds "ID equals toc",

00:23:25.501 --> 00:23:27.234
or it reaches
the document root.

00:23:27.234 --> 00:23:28.634
So this is really--it could be

00:23:28.634 --> 00:23:31.067
a real performance problem
for browsers.

00:23:32.868 --> 00:23:35.300
So this document gives
some advice.

00:23:35.300 --> 00:23:36.667
I'll go over
these pretty quickly

00:23:36.667 --> 00:23:39.634
for improving the efficiency
of this matching--

00:23:39.634 --> 00:23:41.968
CSS matching challenge.

00:23:43.501 --> 00:23:45.033
Avoid universal selectors,

00:23:45.033 --> 00:23:46.868
that is going
to have a lot of matching.

00:23:46.868 --> 00:23:49.834
There's no point
in qualifying ID selectors,

00:23:49.834 --> 00:23:52.701
'cause it should only
match one element in the page.

00:23:52.701 --> 00:23:58.534
Similarly, you
could customize classes

00:23:58.534 --> 00:24:01.367
associated with tags
into a new class.

00:24:01.367 --> 00:24:02.601
There's a little
trade-off here.

00:24:02.601 --> 00:24:04.000
This is going
to add page weight

00:24:04.000 --> 00:24:07.100
and reduce the flexibility
of your CSS a little bit.

00:24:07.100 --> 00:24:09.334
So you have to take
that into consideration as well.

00:24:09.334 --> 00:24:11.534
A couple of these do that.

00:24:11.534 --> 00:24:15.267
So here again,
create a custom class...

00:24:15.267 --> 00:24:17.434
a lot of times when
we use descendant selectors,

00:24:17.434 --> 00:24:18.968
we really
know that we mean child.

00:24:18.968 --> 00:24:21.267
And child is going
to be a little more efficient.

00:24:21.267 --> 00:24:23.934
So look at
your descendant selectors,

00:24:23.934 --> 00:24:26.601
and see if they
can really be child selectors.

00:24:26.601 --> 00:24:29.033
But then again, do we
really need child selectors?

00:24:29.033 --> 00:24:30.133
Could you figure out a way

00:24:30.133 --> 00:24:32.901
to create a custom class
in that case?

00:24:32.901 --> 00:24:36.934
And finally, you might not need
all the rules that you have

00:24:36.934 --> 00:24:41.100
if you relied
on inheritance of styles.

00:24:41.100 --> 00:24:44.968
So all of this
is mentioned in this document

00:24:44.968 --> 00:24:46.901
which really, I hadn't--
you know, I'd been doing

00:24:46.901 --> 00:24:48.601
performance stuff
for four or five years.

00:24:48.601 --> 00:24:51.434
I hadn't seen this until
about six or eight months ago,

00:24:51.434 --> 00:24:53.033
and I wondered why.

00:24:53.033 --> 00:24:55.801
And if you look at the title,
this document was actually

00:24:55.801 --> 00:24:57.767
written by David Hyatt
for people

00:24:57.767 --> 00:25:00.100
working on the Mozilla Chrome.

00:25:00.100 --> 00:25:03.434
And I think what's happened is
he wrote this in 2000--

00:25:03.434 --> 00:25:05.534
nine years ago--
I think what's happened is

00:25:05.534 --> 00:25:07.033
we're finally
getting to the point

00:25:07.033 --> 00:25:10.267
where our web 2.0 apps
are getting so big,

00:25:10.267 --> 00:25:11.801
and having so much CSS,

00:25:11.801 --> 00:25:15.033
and having such
a longer session life

00:25:15.033 --> 00:25:17.033
that we're getting
into the same problems

00:25:17.033 --> 00:25:19.434
that were happening
nine years ago with Mozilla.

00:25:19.434 --> 00:25:22.334
Where we're getting so much--
so many rules

00:25:22.334 --> 00:25:25.234
and so many elements in the page
that have to be matched,

00:25:25.234 --> 00:25:27.367
that we're starting
to know the performance problems

00:25:27.367 --> 00:25:30.167
of the CSS selector matching.

00:25:30.167 --> 00:25:32.934
So there were some tests
published by Jon Sykes

00:25:32.934 --> 00:25:34.234
about six months ago.

00:25:34.234 --> 00:25:36.033
He's since taken them down,
I think.

00:25:36.033 --> 00:25:39.968
But he created these tests
that had 20,000 anchor elements

00:25:39.968 --> 00:25:42.267
into different levels of CSS.

00:25:42.267 --> 00:25:44.667
No styling, had no CSS at all.

00:25:44.667 --> 00:25:48.534
The tag test just had one rule.

00:25:48.534 --> 00:25:50.567
The class test had 20,000 rules.

00:25:50.567 --> 00:25:54.734
So each anchor
had its own class rule.

00:25:54.734 --> 00:25:56.968
And then
he took those class rules

00:25:56.968 --> 00:25:59.033
and put them
into a descendant selector

00:25:59.033 --> 00:26:02.000
and also into a child selector.

00:26:02.000 --> 00:26:04.334
And what we see
is for some browsers,

00:26:04.334 --> 00:26:06.534
like Safari is the yellow one,

00:26:06.534 --> 00:26:10.400
it got, you know,
five times slower, right?

00:26:10.400 --> 00:26:11.767
So this is pretty scary.

00:26:11.767 --> 00:26:13.734
And IE also did pretty poorly.

00:26:13.734 --> 00:26:16.067
But what happens when you
do things at a massive scale

00:26:16.067 --> 00:26:18.501
like that, you have
to take into consideration

00:26:18.501 --> 00:26:21.300
if the results that
you're looking at are linear

00:26:21.300 --> 00:26:23.601
to what you might expect
in the real world.

00:26:23.601 --> 00:26:27.200
And here we see that in IE,
there's a cliff at 18,000 rules.

00:26:27.200 --> 00:26:28.667
And since these tests were on

00:26:28.667 --> 00:26:30.934
the right-hand side
of that cliff--

00:26:30.934 --> 00:26:33.400
or from your perspective, the
right-hand side of that cliff--

00:26:33.400 --> 00:26:36.234
it really
isn't a realistic test.

00:26:36.234 --> 00:26:38.968
So I looked
at the popular web sites.

00:26:38.968 --> 00:26:40.501
And for these sites

00:26:40.501 --> 00:26:43.100
there are about 1,000 rules
and 1,000 elements.

00:26:43.100 --> 00:26:45.501
So I redid the test
at that level,

00:26:45.501 --> 00:26:49.467
and we see that there's only
about a 30 millisecond penalty

00:26:49.467 --> 00:26:51.534
in having these
more expensive rules.

00:26:51.534 --> 00:26:54.334
So that made me think,
"Well, then, are CSS selectors

00:26:54.334 --> 00:26:55.467
"really not a problem?

00:26:55.467 --> 00:26:58.167
Do we not
have to worry about this?"

00:26:58.167 --> 00:27:01.033
And it's--it really is something
that we do have to think about.

00:27:01.033 --> 00:27:05.234
But we need to focus on--
what are the types of selectors

00:27:05.234 --> 00:27:07.033
that we should be working on?

00:27:07.033 --> 00:27:12.734
So the reason that the "DIV
DIV DIV P A. CLASS 0007" rule

00:27:12.734 --> 00:27:15.501
isn't that painful--even though
it looks painful, right?

00:27:15.501 --> 00:27:18.000
It's five levels
of descendant checking.

00:27:18.000 --> 00:27:22.901
This part is only going to match
one element in the page.

00:27:22.901 --> 00:27:24.968
Whereas this one,
which actually looks simpler--

00:27:24.968 --> 00:27:27.601
Now that we know
they're parsed right to left,

00:27:27.601 --> 00:27:30.534
we're going to start with this
part, called the "key selector."

00:27:30.534 --> 00:27:33.501
And it's going to match
a lot of elements in the page,

00:27:33.501 --> 00:27:35.667
so the browser's going
to have a lot of work to do.

00:27:35.667 --> 00:27:38.434
Whereas this one, that might
actually look more expensive

00:27:38.434 --> 00:27:40.167
is much faster

00:27:40.167 --> 00:27:42.434
because there's only one element
that's going to match.

00:27:42.434 --> 00:27:46.033
So the browser really quickly
can discount some of the work

00:27:46.033 --> 00:27:49.367
that it's going to have
to do with this one up here.

00:27:49.367 --> 00:27:52.767
So I created some--So
here are some other examples.

00:27:52.767 --> 00:27:54.534
If you have a lot of DIVs--

00:27:54.534 --> 00:27:56.200
Basically, you
want to look at your rules,

00:27:56.200 --> 00:27:58.033
focus your
performance optimization

00:27:58.033 --> 00:28:03.567
on rules where the rightmost
simple selector--DIV, A...

00:28:03.567 --> 00:28:07.968
here it's an attribute,
here it's a pseudo class.

00:28:07.968 --> 00:28:09.767
You want
to focus on the rules where

00:28:09.767 --> 00:28:12.267
that rightmost key selector
is going

00:28:12.267 --> 00:28:13.934
to have the most ambiguity.

00:28:13.934 --> 00:28:16.634
It's going to be--require
the most work from the browser

00:28:16.634 --> 00:28:19.133
to match it
to elements in the page.

00:28:19.133 --> 00:28:25.634
So...all of those tests
focused on how

00:28:25.634 --> 00:28:27.634
this matching
would affect load time.

00:28:27.634 --> 00:28:29.167
What about reflow times?

00:28:29.167 --> 00:28:31.601
That's the time when you change
something in the page,

00:28:31.601 --> 00:28:33.701
and then the browser
has to repaint the page,

00:28:33.701 --> 00:28:36.133
rerender the elements.

00:28:36.133 --> 00:28:38.534
So this we
see happening now again

00:28:38.534 --> 00:28:41.434
in the Web 2.0, Ajax,
the DHTML world--

00:28:41.434 --> 00:28:43.334
is happening more and
more because we're doing

00:28:43.334 --> 00:28:45.934
these DHTML
actions in JavaScript.

00:28:45.934 --> 00:28:49.634
And these will trigger
a reflow in most browsers.

00:28:49.634 --> 00:28:53.567
So I wanted to look at...

00:28:53.567 --> 00:28:58.634
how--what--which of these DHTML
actions would trigger a reflow?

00:28:58.634 --> 00:29:01.767
And how painful was that reflow
in different browsers?

00:29:01.767 --> 00:29:05.067
And so here's
a list of about a dozen

00:29:05.067 --> 00:29:07.534
DHTML actions
that I came up with.

00:29:07.534 --> 00:29:09.567
And I tested them
across these browsers.

00:29:09.567 --> 00:29:13.501
I haven't done this in a--
in an apples to apples way,

00:29:13.501 --> 00:29:16.067
so I didn't want to show
absolute time values here.

00:29:16.067 --> 00:29:18.767
So I just used
this 1x placeholder.

00:29:18.767 --> 00:29:21.100
So, like, we might
look at IE 6 and 7--

00:29:21.100 --> 00:29:23.100
there's a certain amount
of time it takes

00:29:23.100 --> 00:29:25.868
if you change
the class name of, say,

00:29:25.868 --> 00:29:29.033
a high ancestor element,
like document body.

00:29:29.033 --> 00:29:30.901
If you change the class name,
it's going to take

00:29:30.901 --> 00:29:34.868
1x amount of time
for the reflow to happen.

00:29:34.868 --> 00:29:39.067
But if you change the padding,
it's 4x as long.

00:29:39.067 --> 00:29:44.000
And in these tests,
the value of 1x

00:29:44.000 --> 00:29:46.367
is somewhere
between 1 and 6 seconds.

00:29:46.367 --> 00:29:49.634
So that--changing
the padding in IE 6 and 7

00:29:49.634 --> 00:29:52.300
is going to be somewhere
between 4 and 24 seconds.

00:29:52.300 --> 00:29:53.868
And this was on this laptop.

00:29:53.868 --> 00:29:55.901
So these things
can be pretty painful.

00:29:55.901 --> 00:29:58.834
And this wasn't at 20,000
elements or 20,000 rules.

00:29:58.834 --> 00:30:00.701
This is at the real world levels

00:30:00.701 --> 00:30:02.834
of 1,000 rules
and 1,000 elements.

00:30:02.834 --> 00:30:05.801
So the CSS selector
matching and reflow

00:30:05.801 --> 00:30:08.000
is something we need
to pay more attention to,

00:30:08.000 --> 00:30:10.767
especially the reflow
as we do more Web 2.0 work.

00:30:10.767 --> 00:30:14.667
The sad thing is, we see some
browsers, like Opera,

00:30:14.667 --> 00:30:17.767
are doing
something really advanced

00:30:17.767 --> 00:30:20.868
in how they determine when
they have to do a reflow or not.

00:30:20.868 --> 00:30:23.367
And the ones that do the most,

00:30:23.367 --> 00:30:26.367
kind of,
willy-nilly shotgun rerendering

00:30:26.367 --> 00:30:29.033
are the most popular browsers--
Firefox and IE.

00:30:29.033 --> 00:30:30.667
So we need to figure out
what's happening

00:30:30.667 --> 00:30:32.467
in Safari, and Webkit,
and Opera.

00:30:32.467 --> 00:30:34.734
And try to get
the Firefox and IE teams

00:30:34.734 --> 00:30:37.300
to adopt
some of those advances in

00:30:37.300 --> 00:30:39.167
doing
more intelligent rendering.

00:30:41.000 --> 00:30:42.434
So the wrap-up here--

00:30:42.434 --> 00:30:46.000
here's a plot of
reflow time versus total rules.

00:30:46.000 --> 00:30:48.167
And I have
a tool that classifies

00:30:48.167 --> 00:30:49.701
the painfulness of rules.

00:30:49.701 --> 00:30:51.634
Like, is there a key select
something that's going to

00:30:51.634 --> 00:30:54.334
match a lot or
just a few elements in the page.

00:30:54.334 --> 00:30:58.234
And there's a high correlation
between reflow time

00:30:58.234 --> 00:31:00.133
and both of these variables.

00:31:00.133 --> 00:31:03.701
So you want to look
at these improvements.

00:31:03.701 --> 00:31:05.367
You're going
to have to do some trade-offs

00:31:05.367 --> 00:31:06.801
for some of these suggestions.

00:31:06.801 --> 00:31:08.467
You might actually
add page weight.

00:31:08.467 --> 00:31:09.834
That could slow down the page.

00:31:09.834 --> 00:31:12.767
So to really try to focus
on the selectors that have

00:31:12.767 --> 00:31:16.300
that most ambiguous
key selector in it.

00:31:16.300 --> 00:31:17.901
So don't
change them all willy-nilly.

00:31:17.901 --> 00:31:19.434
Focus on the ones
that are going to have

00:31:19.434 --> 00:31:22.567
the biggest performance impact.

00:31:22.567 --> 00:31:25.968
And you might also want to look

00:31:25.968 --> 00:31:28.200
at reducing
the total number of rules

00:31:28.200 --> 00:31:29.901
or the total number
of selectors.

00:31:29.901 --> 00:31:31.501
That's going
to affect your reflow time

00:31:31.501 --> 00:31:33.033
and page load time as well.

00:31:34.367 --> 00:31:36.567
All right,
going beyond gzipping.

00:31:38.667 --> 00:31:41.868
So Tony's my office mate,
and he wrote this chapter--

00:31:41.868 --> 00:31:44.534
Chapter nine of my book
that's coming out.

00:31:44.534 --> 00:31:47.901
So in my first book,
"High Performance Web Sites,"

00:31:47.901 --> 00:31:50.734
rule four
is gzip components, right?

00:31:50.734 --> 00:31:55.367
And accept encoding
and content encoding

00:31:55.367 --> 00:31:57.534
were added in HTTP/1.1.

00:31:57.534 --> 00:32:00.601
And so what you get is you get
web clients that say,

00:32:00.601 --> 00:32:02.567
"I accept gzip, and deflate,

00:32:02.567 --> 00:32:04.934
and possibly
other compression encodings."

00:32:04.934 --> 00:32:08.334
And then if the server supports
any of those encodings--

00:32:08.334 --> 00:32:09.734
those compression encodings--

00:32:09.734 --> 00:32:13.467
it can compress the response,
and then send back this

00:32:13.467 --> 00:32:16.000
content encoding,
telling the client

00:32:16.000 --> 00:32:17.567
which encoding was used,

00:32:17.567 --> 00:32:20.634
and the client can
then uncompress that response.

00:32:20.634 --> 00:32:22.968
So that all works well, right?

00:32:22.968 --> 00:32:24.534
And it's really easy
to turn on.

00:32:24.534 --> 00:32:28.767
Here's the line you would add to
your config file in Apache 2.x.

00:32:28.767 --> 00:32:32.834
And this would cause all of your
HTML, CSS, and JavaScript

00:32:32.834 --> 00:32:35.834
responses to be compressed.

00:32:35.834 --> 00:32:38.701
And that's kind of
the main point that I made

00:32:38.701 --> 00:32:42.868
in "High Performance Web Sites"
was compression is--

00:32:42.868 --> 00:32:46.200
really reduces the transfer size
of these text responses.

00:32:46.200 --> 00:32:48.834
It's typically about 70%.

00:32:48.834 --> 00:32:51.167
So if you add
a 100K JavaScript file,

00:32:51.167 --> 00:32:52.968
it'll drop down to 30K.

00:32:52.968 --> 00:32:54.501
All right,
so that's a big savings.

00:32:54.501 --> 00:32:57.033
But typically,
three or four years ago,

00:32:57.033 --> 00:33:00.434
you would only see
HTML responses being compressed.

00:33:00.434 --> 00:33:03.100
But really, any text response
should be compressed.

00:33:03.100 --> 00:33:07.267
JSON, XML, CSS, JavaScript--

00:33:07.267 --> 00:33:09.501
all of those should have
compression turned on.

00:33:09.501 --> 00:33:12.534
But you don't want to do it
with binary files.

00:33:12.534 --> 00:33:15.167
It could actually increase
the size of the files.

00:33:15.167 --> 00:33:17.634
And this is a chart
I'll show again at the end.

00:33:17.634 --> 00:33:19.968
This is a friend of mine,
Bill Scott--

00:33:19.968 --> 00:33:22.033
formally from Yahoo,
now over at Netflix--

00:33:22.033 --> 00:33:25.868
where on one day, he finally
convinced the folks there

00:33:25.868 --> 00:33:29.667
to turn on compression
for HTML, CSS, and JavaScript.

00:33:29.667 --> 00:33:32.467
And when they turned it on,
the outbound traffic dropped

00:33:32.467 --> 00:33:34.667
in half,
leaving their data center.

00:33:34.667 --> 00:33:36.901
And the Ops guys thought
that the site was down,

00:33:36.901 --> 00:33:38.834
and everyone was
just getting an error page.

00:33:38.834 --> 00:33:40.334
And they paged him.

00:33:40.334 --> 00:33:42.200
They said, "The site's down,
the site's down!"

00:33:42.200 --> 00:33:44.167
He said, "Nope,
we just turned on compression."

00:33:44.167 --> 00:33:48.334
And so you can imagine the
speedup that this results in,

00:33:48.334 --> 00:33:50.100
and also the cost savings
that you'd have

00:33:50.100 --> 00:33:51.634
from a change like this.

00:33:51.634 --> 00:33:53.467
So anyway, everyone's sold.

00:33:53.467 --> 00:33:55.100
You know,
let's turn on compression.

00:33:55.100 --> 00:33:57.167
So what's the big issue?

00:33:57.167 --> 00:34:00.534
The problem is that about 15%
of the people in the world--

00:34:00.534 --> 00:34:03.868
even if you turn on
compression in your web server--

00:34:03.868 --> 00:34:06.267
aren't going
to get compressed responses.

00:34:06.267 --> 00:34:07.501
Why is that?

00:34:07.501 --> 00:34:09.300
I just want to
point out here I intentionally

00:34:09.300 --> 00:34:10.767
misspelled the word "surprise,"

00:34:10.767 --> 00:34:12.501
'cause I think
it's more fun with a "Z".

00:34:12.501 --> 00:34:14.367
Like something
that has a prize in it.

00:34:14.367 --> 00:34:16.734
You know,
surprise should be happy.

00:34:16.734 --> 00:34:18.100
So, this and performant.

00:34:18.100 --> 00:34:22.200
"Performant" is not a word,
but I use it all the time.

00:34:22.200 --> 00:34:26.567
So I had my spell checker accept
that as a proper spelling.

00:34:26.567 --> 00:34:28.567
So, you know,
how is this possible?

00:34:28.567 --> 00:34:31.200
How can 15% of the people
coming into your web site

00:34:31.200 --> 00:34:33.534
not get
gzip compressed responses?

00:34:33.534 --> 00:34:36.334
Well, maybe they're coming in
on old browsers

00:34:36.334 --> 00:34:39.267
that don't support
gzip compression, right?

00:34:39.267 --> 00:34:40.968
So here's the top four browsers

00:34:40.968 --> 00:34:42.868
that don't support
gzip compression.

00:34:42.868 --> 00:34:48.467
And maybe they add up to 0.1 or
0.2% of total internet traffic.

00:34:48.467 --> 00:34:52.601
So we're still off by 14%--
14.8, 14.9%.

00:34:52.601 --> 00:34:54.701
What are all these users
that aren't giving--

00:34:54.701 --> 00:34:56.767
getting compressed responses?

00:34:56.767 --> 00:34:58.501
So I'll give you a clue.

00:34:58.501 --> 00:35:02.133
If you broke this out
by region, most of the people

00:35:02.133 --> 00:35:04.067
who aren't getting
these compressed responses

00:35:04.067 --> 00:35:06.934
are coming from the Middle East.

00:35:06.934 --> 00:35:10.767
Any guesses?

00:35:10.767 --> 00:35:13.968
Proxies and anti-virus software.

00:35:13.968 --> 00:35:15.634
The other one is the Vatican.

00:35:15.634 --> 00:35:19.133
It's like 100% of the traffic
in the Vatican doesn't get--

00:35:19.133 --> 00:35:21.100
coming from the Vatican
doesn't get compression.

00:35:21.100 --> 00:35:25.200
So what we see
for these requests coming in

00:35:25.200 --> 00:35:27.634
from browsers that
we know support compression--

00:35:27.634 --> 00:35:30.367
IE 8, Firefox 3,
Firefox 2, IE 6, IE 7--

00:35:30.367 --> 00:35:32.801
there's no
Accept-Encoding header.

00:35:32.801 --> 00:35:36.167
Or there's not
an Accept-Encoding header,

00:35:36.167 --> 00:35:38.767
but there's something
that looks very close to it.

00:35:38.767 --> 00:35:40.968
But it's been munged
in some way.

00:35:40.968 --> 00:35:44.167
So you can see here,
"X" was added here.

00:35:44.167 --> 00:35:46.601
And you'll see this,
where the total byte size--

00:35:46.601 --> 00:35:49.467
these proxies
or other intermediaries

00:35:49.467 --> 00:35:52.367
want to maintain
the same byte size,

00:35:52.367 --> 00:35:55.734
so they won't remove it totally,
they'll just mung it

00:35:55.734 --> 00:35:59.100
so servers won't
return a compressed response.

00:35:59.100 --> 00:36:02.601
And the reason they do that
is these intermediaries

00:36:02.601 --> 00:36:06.100
are trying to filter
the responses for some purpose

00:36:06.100 --> 00:36:08.968
to look for, you know,
phishing attempts,

00:36:08.968 --> 00:36:12.367
or security,
or undesirable content.

00:36:12.367 --> 00:36:14.501
And it's just easier
for them, right?

00:36:14.501 --> 00:36:16.501
To look at
an uncompressed response,

00:36:16.501 --> 00:36:19.534
then to write that,
you know, include that library

00:36:19.534 --> 00:36:21.801
that is going
to handle gzip responses,

00:36:21.801 --> 00:36:24.167
and uncompress it,
and then analyze it.

00:36:24.167 --> 00:36:27.267
And the thing is
that uncompressing is,

00:36:27.267 --> 00:36:30.067
I don't know, five to ten times
faster than compression.

00:36:30.067 --> 00:36:32.434
So it's not like it's going
to be a big performance hit

00:36:32.434 --> 00:36:34.534
if you have
to uncompress the responses.

00:36:34.534 --> 00:36:36.234
And if you looked
at the time it would take

00:36:36.234 --> 00:36:38.234
to uncompress the response
versus the time

00:36:38.234 --> 00:36:39.667
to download
something that's going

00:36:39.667 --> 00:36:41.167
to be three times bigger,

00:36:41.167 --> 00:36:44.100
it's a huge win
to have compression turned on.

00:36:44.100 --> 00:36:45.868
So I see this all the time.

00:36:45.868 --> 00:36:47.868
I don't believe
that the developers

00:36:47.868 --> 00:36:51.467
who built these proxies
or anti-virus software programs

00:36:51.467 --> 00:36:54.834
intentionally want to
slow down the user experience.

00:36:54.834 --> 00:36:57.601
In my experience,
they just aren't aware of

00:36:57.601 --> 00:37:00.534
the performance degradation
that they're inflicting on

00:37:00.534 --> 00:37:03.100
this group of users.

00:37:03.100 --> 00:37:05.033
And so we need
to raise awareness of this

00:37:05.033 --> 00:37:07.834
and try to get them
to enhance their products

00:37:07.834 --> 00:37:10.067
to not strip out
Accept-Encoding.

00:37:11.567 --> 00:37:15.100
So you know, I encourage you
to go back and send me an email.

00:37:15.100 --> 00:37:16.467
Check your site.

00:37:16.467 --> 00:37:19.834
How much of this
do you see on your web site?

00:37:19.834 --> 00:37:22.367
Do you see about 15%?
Is it more?

00:37:22.367 --> 00:37:24.434
Are you--Do you
have some way to detect,

00:37:24.434 --> 00:37:27.267
you know, what the cause is?

00:37:27.267 --> 00:37:30.567
'Cause we could start reaching
out to specific vendors--

00:37:30.567 --> 00:37:32.000
especially
the most popular ones--

00:37:32.000 --> 00:37:34.400
and ask them to,
you know, address this,

00:37:34.400 --> 00:37:37.667
to add compression support
in their software product.

00:37:37.667 --> 00:37:41.667
So I looked at my site,
stevesouders,

00:37:41.667 --> 00:37:46.934
and I turned on,
for 500 unique users,

00:37:46.934 --> 00:37:53.167
this beacon that recorded
not just their headers,

00:37:53.167 --> 00:37:55.167
but also some behavior
in their page.

00:37:55.167 --> 00:37:59.567
And what I found was
it was around 15%--I got 14%--

00:37:59.567 --> 00:38:01.934
were missing
the Accept-Encoding headers.

00:38:01.934 --> 00:38:03.834
And of those ones
that were missing it,

00:38:03.834 --> 00:38:06.367
they had some munged
version of the header.

00:38:06.367 --> 00:38:09.834
1% of them had
a munged version of the header.

00:38:09.834 --> 00:38:12.601
And I tried to see
if I could tie this

00:38:12.601 --> 00:38:14.300
to proxies or some other tool.

00:38:14.300 --> 00:38:16.667
So here are some headers
that I used to do that.

00:38:16.667 --> 00:38:20.033
But I want to--really quick...

00:38:20.033 --> 00:38:21.901
Let's see, okay.

00:38:24.000 --> 00:38:25.133
Yeah, here we go.

00:38:25.133 --> 00:38:27.934
Boom, boom, boom, boom, boom.

00:38:27.934 --> 00:38:32.667
I wanted to show you this thing
that I think is kind of fun.

00:38:34.367 --> 00:38:37.133
And it's locked down,
so you won't be able to...

00:38:41.434 --> 00:38:44.234
get into it.

00:38:44.234 --> 00:38:45.934
So I call it "Dinoquery."

00:38:45.934 --> 00:38:47.367
So I think
the most important thing

00:38:47.367 --> 00:38:51.400
about any software project is
a cool picture and a cool name.

00:38:51.400 --> 00:38:55.033
And so, don't tell
Bam Bam and Fred about this.

00:38:55.033 --> 00:38:57.000
But you know, every time
you reload the page,

00:38:57.000 --> 00:38:59.734
you get different pictures
of Dino.

00:38:59.734 --> 00:39:01.734
But it's
supposed to be "DynoQuery,"

00:39:01.734 --> 00:39:02.868
like dynamic queries.

00:39:02.868 --> 00:39:06.567
And so it's very crude.

00:39:06.567 --> 00:39:07.934
I hope to open sour--you know,

00:39:07.934 --> 00:39:09.801
improve this a little bit
and open source it.

00:39:09.801 --> 00:39:11.701
But I wanted to show it off
a little bit.

00:39:11.701 --> 00:39:13.167
So basically what I do--

00:39:13.167 --> 00:39:15.901
Those 500 users, I just dump
their headers and some other

00:39:15.901 --> 00:39:19.133
attributes of their experience
into a MySQL database.

00:39:19.133 --> 00:39:21.734
And then this Dinoquery
is a PHP script

00:39:21.734 --> 00:39:23.968
that's maybe 300 lines of code.

00:39:23.968 --> 00:39:26.868
And you can drop it
on top of any MySQL database,

00:39:26.868 --> 00:39:28.400
any MySQL table.

00:39:28.400 --> 00:39:30.501
And it basically
just enumerates the fields

00:39:30.501 --> 00:39:33.133
in the table, and lets you, you
know, poke at them a little bit.

00:39:33.133 --> 00:39:35.501
So let's poke at
the Accept-Encoding header.

00:39:35.501 --> 00:39:37.834
And we see that
out of these 500 requests,

00:39:37.834 --> 00:39:41.968
about 14% of them are missing
the Accept-Encoding header.

00:39:41.968 --> 00:39:45.067
And if we
look at another version--

00:39:45.067 --> 00:39:48.234
another dimension on
this data--like the user agent.

00:39:48.234 --> 00:39:51.133
You can see that these are
perfectly normal user agents

00:39:51.133 --> 00:39:54.100
that we would expect
to support compression.

00:39:54.100 --> 00:39:56.767
So why don't they have
the Accept-Encoding header?

00:39:56.767 --> 00:39:59.834
So one thing we can do--
it's kind of hard to look for

00:39:59.834 --> 00:40:01.467
munged Accept-Encoding headers,

00:40:01.467 --> 00:40:03.667
'cause you don't know
what they're going to look like.

00:40:03.667 --> 00:40:06.067
So basically, any header
that I didn't recognize

00:40:06.067 --> 00:40:09.167
that looked weird,
I put into this other category.

00:40:09.167 --> 00:40:11.634
And so here
we can see examples of

00:40:11.634 --> 00:40:15.734
where they've munged the
Accept-Encoding header, right?

00:40:15.734 --> 00:40:18.300
So how can
I try to correlate this

00:40:18.300 --> 00:40:21.300
to proxies
or anti-virus software?

00:40:21.300 --> 00:40:25.167
So there are some headers
that are most prevalent

00:40:25.167 --> 00:40:27.467
with proxies--like Via.

00:40:27.467 --> 00:40:29.767
And so, whereas--and this
is another thing

00:40:29.767 --> 00:40:31.767
I wish all plotting tools
would do.

00:40:31.767 --> 00:40:34.400
Is I always want
to compare plots side by side.

00:40:34.400 --> 00:40:36.901
I hate having
to open up two different pages.

00:40:36.901 --> 00:40:39.133
So I can look
at my overall population--

00:40:39.133 --> 00:40:41.234
what's the distribution
of the Via header?

00:40:41.234 --> 00:40:45.701
In my overall population,
I have about...

00:40:45.701 --> 00:40:47.133
What would that be? 50.

00:40:47.133 --> 00:40:50.767
So I have about 10% of my users
coming in with a Via header.

00:40:50.767 --> 00:40:53.901
Here, of these ones that have
a null Accept-Encoding header,

00:40:53.901 --> 00:40:55.234
it's about 40%.

00:40:55.234 --> 00:40:58.334
So clearly, a much higher
percentage of these users

00:40:58.334 --> 00:41:00.133
are coming in through proxies.

00:41:00.133 --> 00:41:03.133
Another one we could look at
is proxy connection.

00:41:03.133 --> 00:41:06.901
So here,
12 of them have Keepalive.

00:41:06.901 --> 00:41:11.400
In the overall population...
it's also 12.

00:41:11.400 --> 00:41:14.501
So all 12 of these users
that are coming in

00:41:14.501 --> 00:41:17.834
with a proxy connection header
have a missing

00:41:17.834 --> 00:41:19.300
Accept-Encoding header.

00:41:19.300 --> 00:41:22.767
So this is really clearly
tied--I don't have a good way

00:41:22.767 --> 00:41:26.200
with headers
to detect anti-virus programs.

00:41:26.200 --> 00:41:27.534
Or if you know a way,
let me know.

00:41:27.534 --> 00:41:30.434
But clearly,
this is very correlated

00:41:30.434 --> 00:41:32.467
to users coming in
through proxies.

00:41:36.467 --> 00:41:38.868
So...

00:41:38.868 --> 00:41:40.734
dun, dun, dun, dun.

00:41:40.734 --> 00:41:41.767
Okay.

00:41:41.767 --> 00:41:44.501
So what can we do about it,
right?

00:41:44.501 --> 00:41:46.534
There are some things
that we can do.

00:41:46.534 --> 00:41:50.467
And we're talk--Tony
in his chapter talks about

00:41:50.467 --> 00:41:53.200
three different
approaches to take.

00:41:53.200 --> 00:41:54.667
But I'm going to talk about
one of those--

00:41:54.667 --> 00:41:56.234
is basically as developers,

00:41:56.234 --> 00:41:59.400
to not assume that compression
is going to happen.

00:41:59.400 --> 00:42:00.801
'Cause this is pretty tricky.

00:42:00.801 --> 00:42:03.701
If you look at this
15% of your audience

00:42:03.701 --> 00:42:05.234
that isn't getting compression,

00:42:05.234 --> 00:42:09.133
and you try--and you, you know,
average that across

00:42:09.133 --> 00:42:12.634
your entire user population,
the slowdown

00:42:12.634 --> 00:42:14.167
isn't going
to be that significant.

00:42:14.167 --> 00:42:16.634
But the problem
is that this penalty

00:42:16.634 --> 00:42:18.801
isn't distributed
across all your users.

00:42:18.801 --> 00:42:22.868
Those 15% of your users
100% of the time

00:42:22.868 --> 00:42:24.467
are not
getting compressed responses.

00:42:24.467 --> 00:42:29.100
So they're getting a very,
very much slower page load.

00:42:29.100 --> 00:42:30.634
So what can we do about that?

00:42:30.634 --> 00:42:32.400
So we can't assume
that we're always going

00:42:32.400 --> 00:42:33.834
to have compression on.

00:42:33.834 --> 00:42:35.100
So there are things
that we can do

00:42:35.100 --> 00:42:36.601
that we've
talked about before

00:42:36.601 --> 00:42:39.267
but even in my first book
I didn't emphasize that much.

00:42:39.267 --> 00:42:40.434
Because I kind of thought,

00:42:40.434 --> 00:42:42.400
"Well, compression
will take care of this."

00:42:42.400 --> 00:42:45.701
So we can go that extra mile
and do more work

00:42:45.701 --> 00:42:48.901
for this 15% of our users,
like minifying.

00:42:48.901 --> 00:42:51.601
Like, a lot of times I don't
minify my JavaScript

00:42:51.601 --> 00:42:53.634
'cause I know
I have compression turned on.

00:42:53.634 --> 00:42:55.667
But for those users,
minification--

00:42:55.667 --> 00:42:58.501
If you turn on compression,
you get 70% reduction.

00:42:58.501 --> 00:43:00.801
If you minify it
before compression,

00:43:00.801 --> 00:43:03.033
you'll get
maybe another 2 to 5%.

00:43:03.033 --> 00:43:04.434
So it's not that much.

00:43:04.434 --> 00:43:07.033
Well, for these users
that don't get any compression,

00:43:07.033 --> 00:43:11.400
the minification will reduce it
by about 30%--30 to 40%.

00:43:11.400 --> 00:43:12.734
So that can be significant.

00:43:12.734 --> 00:43:14.300
Now let's do it
to not just JavaScript,

00:43:14.300 --> 00:43:16.267
but CSS and HTML as well.

00:43:16.267 --> 00:43:19.834
Instead of inline styles,
which will add more characters,

00:43:19.834 --> 00:43:22.334
try to use rules.

00:43:22.334 --> 00:43:24.267
If you have
long JavaScript names--

00:43:24.267 --> 00:43:26.067
we see this a lot in the
JavaScript frameworks

00:43:26.067 --> 00:43:27.501
like jQuery.

00:43:27.501 --> 00:43:29.467
Instead of
document.getElementById

00:43:29.467 --> 00:43:30.734
everywhere,

00:43:30.734 --> 00:43:32.234
alias that to something
that's shorter.

00:43:32.234 --> 00:43:34.467
And if you use that function
again and again and again,

00:43:34.467 --> 00:43:36.300
you're going
to reduce characters.

00:43:36.300 --> 00:43:38.868
If we had compression,
that would just be an entry

00:43:38.868 --> 00:43:39.968
in the dictionary.

00:43:39.968 --> 00:43:41.467
It wouldn't matter
how long it is.

00:43:41.467 --> 00:43:42.901
But for people
who don't have compression,

00:43:42.901 --> 00:43:44.167
it's going to add up.

00:43:44.167 --> 00:43:47.701
And we can shorten our URLs
by using relative URLs.

00:43:47.701 --> 00:43:49.334
So there are
a couple other techniques

00:43:49.334 --> 00:43:50.868
that Tony talks about.

00:43:50.868 --> 00:43:53.834
And he's giving a talk,
a philosophy on this topic

00:43:53.834 --> 00:43:55.567
with more of the information,

00:43:55.567 --> 00:43:57.834
if you want to come
check it out.

00:43:57.834 --> 00:44:01.367
Okay, and we're start--So that
ends the second of three parts,

00:44:01.367 --> 00:44:04.100
the nitty-gritty
best practices.

00:44:04.100 --> 00:44:07.400
So I'm going to start
wrapping it up now.

00:44:07.400 --> 00:44:11.334
You know, if you want to make
your web pages more scalable,

00:44:11.334 --> 00:44:14.634
reduce your hardware costs,
focus on the backend--

00:44:14.634 --> 00:44:16.901
figure out
how to handle more requests

00:44:16.901 --> 00:44:18.367
with the servers
that you have.

00:44:18.367 --> 00:44:22.801
But if what you want to focus on
is the user experience,

00:44:22.801 --> 00:44:26.100
how fast your pages are, and
how they're perceived by users,

00:44:26.100 --> 00:44:28.300
you got
to focus on the frontend.

00:44:28.300 --> 00:44:30.100
That's the long pole
in the tent.

00:44:30.100 --> 00:44:31.667
You can run YSlow,

00:44:31.667 --> 00:44:34.267
and it'll give you
specific advice on what to fix.

00:44:34.267 --> 00:44:36.334
It's usually the place to start.

00:44:36.334 --> 00:44:38.567
There's more you can do
beyond YSlow.

00:44:38.567 --> 00:44:40.400
But those are the basics
that are going to have

00:44:40.400 --> 00:44:43.901
typically the biggest impact
and are the easiest to rule out.

00:44:43.901 --> 00:44:46.300
Speed really does matter.

00:44:46.300 --> 00:44:49.000
It improves your company,
your user experience--

00:44:49.000 --> 00:44:51.501
I've got a couple slides
that touches on that.

00:44:51.501 --> 00:44:55.400
One is faster web pages
affect revenue.

00:44:55.400 --> 00:44:58.734
We have three data points
that are kicked around

00:44:58.734 --> 00:45:02.300
among my talks and other people
doing performance talks.

00:45:02.300 --> 00:45:04.567
There's this
one from Marissa Mayer

00:45:04.567 --> 00:45:07.133
where Google--
the Google Search page

00:45:07.133 --> 00:45:12.300
became 500 milliseconds slower
and lost 20% of its traffic--

00:45:12.300 --> 00:45:14.734
which is
directly related to revenue.

00:45:14.734 --> 00:45:17.901
At Yahoo, they just published
this one a couple months ago--

00:45:17.901 --> 00:45:21.167
four months ago, they did
an experiment where they

00:45:21.167 --> 00:45:23.801
introduced
a 400 millisecond slowdown.

00:45:23.801 --> 00:45:27.000
And they saw a 5 to 9% drop-off
in page traffic.

00:45:27.000 --> 00:45:31.868
And then Amazon--a former Amazon
employee released this stat.

00:45:31.868 --> 00:45:35.133
They determined that
for every 100 milliseconds

00:45:35.133 --> 00:45:37.667
of latency that
was introduced in the page,

00:45:37.667 --> 00:45:41.300
they lost 1% of sales--
1% of conversions.

00:45:41.300 --> 00:45:43.334
So this really
does have an impact on

00:45:43.334 --> 00:45:45.000
how your brand is perceived,

00:45:45.000 --> 00:45:46.767
and how your web site is used,

00:45:46.767 --> 00:45:50.234
and how users are going
to engage with your web site.

00:45:50.234 --> 00:45:52.300
And that's going
to impact revenue.

00:45:52.300 --> 00:45:56.868
It also affects your operating
costs--your hardware costs,

00:45:56.868 --> 00:45:58.634
your data center costs,
your network costs.

00:45:58.634 --> 00:46:02.400
So you can imagine if you don't
use a far future expires header,

00:46:02.400 --> 00:46:04.234
then you're going
to have many more requests

00:46:04.234 --> 00:46:05.934
for those static resources.

00:46:05.934 --> 00:46:09.567
But if you fix your expires
header, if you remove ETags,

00:46:09.567 --> 00:46:12.901
it's going to greatly
reduce the number of hits.

00:46:12.901 --> 00:46:15.868
There's a very big web site,
I won't mention the name,

00:46:15.868 --> 00:46:18.300
that didn't have
a far future expires header.

00:46:18.300 --> 00:46:21.434
They turned that on and
they saw and 80% drop-off

00:46:21.434 --> 00:46:23.434
in the number of requests
hitting their servers.

00:46:23.434 --> 00:46:27.033
So you could bypass their next
two hardware purchase cycles

00:46:27.033 --> 00:46:29.267
with the servers that
they already had deployed.

00:46:29.267 --> 00:46:33.033
And then I showed this one
before about bandwidth costs.

00:46:33.033 --> 00:46:38.067
Doing things like adding
compression are going to reduce

00:46:38.067 --> 00:46:41.367
the usage of network that you
have in your data centers.

00:46:41.367 --> 00:46:44.167
And that will translate
into cost savings.

00:46:44.167 --> 00:46:48.534
So...if you want
a better user experience--

00:46:48.534 --> 00:46:51.934
how many people want that?

00:46:51.934 --> 00:46:56.501
More revenue?

00:46:56.501 --> 00:46:59.000
Reduce operating expenses?
Okay, I'll take that.

00:46:59.000 --> 00:47:02.267
The strategy is clear--
even faster web sites.

00:47:03.667 --> 00:47:04.801
All right, that's it.

00:47:04.801 --> 00:47:10.734
[applause]

00:47:12.801 --> 00:47:14.868
So we have about ten minutes.

00:47:14.868 --> 00:47:18.434
I'll take questions until
about half the people leave.

00:47:18.434 --> 00:47:19.801
And then I'll stop

00:47:19.801 --> 00:47:22.367
and I'll hang out
for as long as you guys want

00:47:22.367 --> 00:47:23.901
to talk about other stuff.

00:47:23.901 --> 00:47:28.534
So are there--or I guess
let's try to use the mics.

00:47:28.534 --> 00:47:33.467
[man speaking indistinctly]

00:48:12.133 --> 00:48:14.467
Souders:
Yeah. Yeah.

00:48:14.467 --> 00:48:17.100
So the question was,
what about other kind of

00:48:17.100 --> 00:48:19.367
crawlers or screen scrapers?

00:48:19.367 --> 00:48:21.634
Could they
be contributing to that 15%?

00:48:21.634 --> 00:48:26.100
So, you know, I think,
I know in my studies,

00:48:26.100 --> 00:48:29.801
I stripped out all of those
bots, and crawlers, and spiders.

00:48:29.801 --> 00:48:31.968
And I think Tony did too.

00:48:31.968 --> 00:48:35.000
So these are, like, real users
who are logged-in users.

00:48:35.000 --> 00:48:37.801
So those people
could be contributing.

00:48:37.801 --> 00:48:40.801
But they're probably, in many
cases, not affecting the us--

00:48:40.801 --> 00:48:42.767
it's not real users
who are blocked,

00:48:42.767 --> 00:48:44.234
waiting on those responses.

00:48:44.234 --> 00:48:45.968
So...

00:48:45.968 --> 00:48:47.534
Any other questions?

00:48:47.534 --> 00:48:48.834
Yeah.

00:48:48.834 --> 00:48:51.467
Yeah, use the mic if you would,
that'd be great.

00:48:51.467 --> 00:48:53.734
And can you introduce yourself
and say where you're from?

00:48:53.734 --> 00:48:55.300
Shepperton: Yeah, hello.

00:48:55.300 --> 00:48:57.901
Yeah, I'm Dave Shepperton with
Traction Software in Providence.

00:48:57.901 --> 00:49:00.334
And we build a web-based app--

00:49:00.334 --> 00:49:02.334
It's actually
a hypertext journaling system

00:49:02.334 --> 00:49:05.033
on the model
of Vannevar Bush's memex.

00:49:05.033 --> 00:49:08.067
At any rate,
as to your gzip issue--

00:49:08.067 --> 00:49:11.434
or your gzip observation, and
what Tony was talking about,

00:49:11.434 --> 00:49:15.200
we saw exactly--we saw
this whole munged header thing.

00:49:15.200 --> 00:49:17.634
We saw that--we actually have
an article in our knowledge base

00:49:17.634 --> 00:49:19.100
about this,
explaining to customers

00:49:19.100 --> 00:49:21.200
why gzip
wasn't working for them.

00:49:21.200 --> 00:49:24.701
And we also saw
the phenomenon of a gzip buffer

00:49:24.701 --> 00:49:26.734
not filling up, and
therefore the page load times--

00:49:26.734 --> 00:49:28.133
when we shut off--

00:49:28.133 --> 00:49:30.901
actually, it wasn't exactly
the right thing to do.

00:49:30.901 --> 00:49:32.634
I guess we could've
shrunk the buffer

00:49:32.634 --> 00:49:34.234
for the gzip output stream.

00:49:34.234 --> 00:49:37.133
But when we shut off gzip
compression for HTML documents,

00:49:37.133 --> 00:49:39.968
suddenly all these imaginary
performance problems went away.

00:49:39.968 --> 00:49:41.434
So that was great.
Anyway.

00:49:41.434 --> 00:49:44.367
So my question:
Do you have any information

00:49:44.367 --> 00:49:47.634
on how the GWT framework,
you know, uses all this

00:49:47.634 --> 00:49:49.434
great performance advice
that you're using?

00:49:49.434 --> 00:49:51.100
We're--we're
beginning to use that,

00:49:51.100 --> 00:49:53.834
'cause we want a really nice,
rich, interactive environment.

00:49:53.834 --> 00:49:55.133
I'm just wondering if you know

00:49:55.133 --> 00:49:57.200
what the GW team
has done with that.

00:49:57.200 --> 00:49:59.334
And you can speak that
and take my answer off the air.

00:49:59.334 --> 00:50:00.567
Souder: Yeah.

00:50:00.567 --> 00:50:04.834
So I, you know,
meet fairly regularly

00:50:04.834 --> 00:50:07.434
with the GWT team--
I call them GWT--

00:50:07.434 --> 00:50:09.701
with the GWT team.

00:50:09.701 --> 00:50:11.334
And, you know,
they're familiar with

00:50:11.334 --> 00:50:12.801
these
performance best practices.

00:50:12.801 --> 00:50:16.868
Some of them are kind of outside
the scope of what GWT does.

00:50:16.868 --> 00:50:21.133
And so it's still going to fall
to the responsibility of you,

00:50:21.133 --> 00:50:23.834
the web developer,
to adopt some of those.

00:50:23.834 --> 00:50:27.234
For example,
like creating CSS sprites.

00:50:27.234 --> 00:50:28.901
I doubt that
GWT will ever do that.

00:50:28.901 --> 00:50:31.934
They might, like, recommend
a tool, or build a tool

00:50:31.934 --> 00:50:33.601
that you could use to do that.

00:50:33.601 --> 00:50:35.434
But it's probably
going to be something that--

00:50:35.434 --> 00:50:37.801
something that you have to do--
Excuse me?

00:50:37.801 --> 00:50:39.300
Oh, really?

00:50:39.300 --> 00:50:42.033
So, and I know, like, another
one that I think is coming,

00:50:42.033 --> 00:50:46.467
or already in GWT is--
at the talk I did last year,

00:50:46.467 --> 00:50:49.334
I talked about the first three
or four chapters of my book,

00:50:49.334 --> 00:50:51.067
about loading scripts
asynchronously.

00:50:51.067 --> 00:50:56.567
And so most of the frameworks
have functions you can call

00:50:56.567 --> 00:50:58.501
to achieve that--
to get scripts to load

00:50:58.501 --> 00:51:00.567
without blocking the other
resources in the page.

00:51:00.567 --> 00:51:03.901
And so I think GWT
has support for that as well.

00:51:03.901 --> 00:51:07.334
So I know
that they're very, you know,

00:51:07.334 --> 00:51:10.267
in touch with
making web sites faster.

00:51:10.267 --> 00:51:11.934
And they want
to do everything they can.

00:51:11.934 --> 00:51:14.501
I don't have the specific list
of what they've done.

00:51:14.501 --> 00:51:17.701
And I know they're--I think
Bruce is doing a talk here

00:51:17.701 --> 00:51:19.534
about GWT and performance.

00:51:19.534 --> 00:51:23.367
I think it's on my schedule
this afternoon to go to.

00:51:23.367 --> 00:51:25.000
So you could go and ask him.

00:51:25.000 --> 00:51:26.834
I'm sure he's going to talk
about the specifics.

00:51:26.834 --> 00:51:29.901
But yeah, they're very motivated
to try to do that.

00:51:29.901 --> 00:51:32.033
And that's one of the benefits
of having a framework--

00:51:32.033 --> 00:51:34.901
is the more we can get these
performance best practices

00:51:34.901 --> 00:51:40.300
evangelized in jQuery, Dojo,
GWT, Wordpress, Blogger--

00:51:40.300 --> 00:51:43.934
all these frameworks
that developers

00:51:43.934 --> 00:51:45.400
and non-developers are using.

00:51:45.400 --> 00:51:47.601
If we can just make web pages
fast by default--

00:51:47.601 --> 00:51:49.434
you don't have to do anything
to make it happen.

00:51:49.434 --> 00:51:53.234
That's going to
have the biggest increase

00:51:53.234 --> 00:51:56.200
in these performance--adoption
of these best practices.

00:51:58.100 --> 00:52:00.200
Williams: Jeff Williams,
University of Minnesota.

00:52:00.200 --> 00:52:03.667
What do you think of that tool
that they showed this morning--

00:52:03.667 --> 00:52:05.033
the performance tool?

00:52:05.033 --> 00:52:07.968
I saw you and
your buddies at the keynote.

00:52:07.968 --> 00:52:10.234
Anything you can tell any
of the rest of us about it or?

00:52:10.234 --> 00:52:12.133
Souders: Yeah,
I think it's amazing.

00:52:12.133 --> 00:52:14.601
And I
just mentioned to the fellow

00:52:14.601 --> 00:52:17.734
in the front row
who's from Minneapolis

00:52:17.734 --> 00:52:20.934
that I'm heading there
over the Fourth of July, so...

00:52:20.934 --> 00:52:23.601
You know,
maybe we'll see you there.

00:52:23.601 --> 00:52:25.934
Yeah, I think--Well, one,
it's a beautiful tool.

00:52:25.934 --> 00:52:27.667
I mean, I love Firebug.

00:52:27.667 --> 00:52:30.901
But, you know, it's kind of
showing its age a little bit.

00:52:30.901 --> 00:52:34.367
And you know,
Web Inspector, I think, 

00:52:34.367 --> 00:52:36.367
you know, in Safari,
is a beautiful tool.

00:52:36.367 --> 00:52:40.334
And the tool that we saw today
as part of Chrome

00:52:40.334 --> 00:52:41.701
is just amazing.

00:52:41.701 --> 00:52:44.767
I mean, even ignoring the fact
that they built it on,

00:52:44.767 --> 00:52:49.501
you know, kind of standard
web tools--CSS and JavaScript--

00:52:49.501 --> 00:52:51.567
is amazing, but
just the work they've done

00:52:51.567 --> 00:52:53.000
with the user interface.

00:52:53.000 --> 00:52:56.167
And I think that
the thing I appreciate most

00:52:56.167 --> 00:53:00.234
about what they showed is...

00:53:00.234 --> 00:53:04.834
You know, the YSlow
best practices were great

00:53:04.834 --> 00:53:06.634
to focus on
two or three years ago.

00:53:06.634 --> 00:53:08.200
Like, turn on compression,

00:53:08.200 --> 00:53:09.968
add
a far future expires header...

00:53:09.968 --> 00:53:12.834
But you know, people
who are into web development--

00:53:12.834 --> 00:53:14.601
that's kind of old hat.

00:53:14.601 --> 00:53:16.534
You know, my guess is
people here who are,

00:53:16.534 --> 00:53:18.767
you know, really focused
on a faster user experience

00:53:18.767 --> 00:53:20.300
have those things done already.

00:53:20.300 --> 00:53:22.434
And so what is it
that, you know,

00:53:22.434 --> 00:53:24.167
the advanced developers
are working on?

00:53:24.167 --> 00:53:25.767
Well, we're all working on
JavaScript,

00:53:25.767 --> 00:53:28.567
and we have a heck of a lot
of CSS in our pages.

00:53:28.567 --> 00:53:31.634
And yet, these tools that we
have don't give us much

00:53:31.634 --> 00:53:34.200
visibility
into how the performance

00:53:34.200 --> 00:53:37.267
of JavaScript, and CSS,
and even HTML parsing--

00:53:37.267 --> 00:53:39.300
how that is affecting our pages.

00:53:39.300 --> 00:53:42.934
In IE 8, there's
some visibility into that.

00:53:42.934 --> 00:53:44.434
But there's no
GUI around it.

00:53:44.434 --> 00:53:45.801
So that's really painful.

00:53:45.801 --> 00:53:48.467
So I think what they've
done there to actually show,

00:53:48.467 --> 00:53:52.067
you know,
JavaScript execution timelines--

00:53:52.067 --> 00:53:55.300
So not just how much time
was spent doing JavaScript,

00:53:55.300 --> 00:53:57.234
but where did it
happen in the page?

00:53:57.234 --> 00:53:59.901
I mean, in Firebug,
you can turn on the profiler,

00:53:59.901 --> 00:54:01.701
and when you stop it,
you can be told

00:54:01.701 --> 00:54:04.067
how much time
it took to execute JavaScript.

00:54:04.067 --> 00:54:05.567
But was that at the beginning?

00:54:05.567 --> 00:54:07.968
Did it block the rendering
of stuff I care about?

00:54:07.968 --> 00:54:10.267
Was it at the end, where I might
prefer to have it happen?

00:54:10.267 --> 00:54:11.534
I have no idea.

00:54:11.534 --> 00:54:13.801
So yeah, I think
that's an amazing tool.

00:54:13.801 --> 00:54:16.534
We're going to see
more tools like that

00:54:16.534 --> 00:54:18.501
announced at Velocity.

00:54:18.501 --> 00:54:20.667
And I think that's
what web developers really need,

00:54:20.667 --> 00:54:22.367
is we need visibility
into this stuff

00:54:22.367 --> 00:54:24.334
that we're really
trying to optimize now.

00:54:26.634 --> 00:54:29.334
Yeah.
Ed: I'm Ed from Filemaker.

00:54:29.334 --> 00:54:33.801
Do you have any further data
about how that 15% breaks down

00:54:33.801 --> 00:54:38.133
by region for United States,
Europe, Asia, et cetera?

00:54:38.133 --> 00:54:40.300
Souders: Yeah, Tony's
going to talk about that more

00:54:40.300 --> 00:54:42.167
at his talk
and in the chapter.

00:54:42.167 --> 00:54:46.000
But I'll tell you that
in the U.S., it's actually

00:54:46.000 --> 00:54:48.667
surprisingly a little higher
than you would think.

00:54:48.667 --> 00:54:51.033
So the worldwide average
is 15%.

00:54:51.033 --> 00:54:52.934
I think in the U.S. it's 20%.

00:54:52.934 --> 00:54:56.400
And it's very high
in the Middle East.

00:54:56.400 --> 00:54:58.501
And actually, you know,
I was kind of surprised,

00:54:58.501 --> 00:55:02.167
in Asia is where
it's a little lower than 15%.

00:55:02.167 --> 00:55:04.634
But beyond that,
I don't have, like,

00:55:04.634 --> 00:55:08.267
a specific, you know,
country by country breakdown.

00:55:08.267 --> 00:55:10.601
I'll ask Tony
if maybe he can throw up

00:55:10.601 --> 00:55:13.033
a slide like that at his talk.

00:55:13.033 --> 00:55:15.501
Hi, huh?

00:55:15.501 --> 00:55:17.901
Kyle: I'm Kyle
from UC Santa Barbara.

00:55:17.901 --> 00:55:19.534
What are your thoughts

00:55:19.534 --> 00:55:21.300
on CSS frameworks
like Blueprint?

00:55:21.300 --> 00:55:27.667
How much of a performance
hit or gain are they?

00:55:27.667 --> 00:55:31.767
Souder: Yeah, someone asked
me about the YUI reset stuff

00:55:31.767 --> 00:55:33.767
at the last conference
I was at.

00:55:33.767 --> 00:55:36.234
And I'll be honest
with you, I don't use--

00:55:36.234 --> 00:55:39.801
use reset or use
these other CSS frameworks.

00:55:39.801 --> 00:55:43.834
So you know, if you email me,
I've got cards.

00:55:43.834 --> 00:55:47.367
Email me
something specific to look at.

00:55:47.367 --> 00:55:48.767
Like, if you have a web site.

00:55:48.767 --> 00:55:50.300
And I'll shoot you back
an email.

00:55:50.300 --> 00:55:53.501
I'll, you know, run YSlow,
and fire up my packet sniffer,

00:55:53.501 --> 00:55:55.334
and spend an hour looking at it.

00:55:55.334 --> 00:55:58.267
And maybe that's something that
we should be focusing on more.

00:55:58.267 --> 00:56:01.667
But I don't have
an answer for you on that.

00:56:01.667 --> 00:56:04.467
Any more?

00:56:04.467 --> 00:56:05.667
Okay, last one.

00:56:05.667 --> 00:56:06.667
Oh, two.
Two more.

00:56:06.667 --> 00:56:09.200
Go ahead.

00:56:09.200 --> 00:56:11.234
Zachary: Brandon Zachary,
Demand Media.

00:56:11.234 --> 00:56:12.667
Souders: Where are you from?

00:56:12.667 --> 00:56:14.200
Zachary: Demand Media...

00:56:14.200 --> 00:56:18.634
eHow, LIVESTRONG, Trails.com,
and a bunch of other stuff.

00:56:18.634 --> 00:56:20.067
[nervous laughing]

00:56:20.067 --> 00:56:23.067
Is there--have you ever saw,
like, a threshold between,

00:56:23.067 --> 00:56:27.801
you know, moving something from
inline CSS to a separate file?

00:56:27.801 --> 00:56:29.234
Or would you
just recommend putting

00:56:29.234 --> 00:56:30.701
everything in a single file?

00:56:30.701 --> 00:56:33.334
Or maybe just
page specific files?

00:56:33.334 --> 00:56:35.400
Souders: Yeah, that's
a question I get a lot.

00:56:35.400 --> 00:56:37.968
And I think the,
you know, best site

00:56:37.968 --> 00:56:39.501
that has struggled with that--

00:56:39.501 --> 00:56:42.667
and I don't think has found
the right answer is Facebook.

00:56:42.667 --> 00:56:45.300
You know,
I know a year or two ago,

00:56:45.300 --> 00:56:47.767
they basically
took all the scripts

00:56:47.767 --> 00:56:50.534
that were loaded
on any page in their site

00:56:50.534 --> 00:56:52.033
and loaded them on every page.

00:56:52.033 --> 00:56:54.534
So if you went to the front
page, you downloaded a megabyte

00:56:54.534 --> 00:56:58.033
of JavaScript
across 35 separate script files.

00:56:58.033 --> 00:57:01.167
And, you know,
so the advice I give

00:57:01.167 --> 00:57:03.367
in high performance
web sites is,

00:57:03.367 --> 00:57:05.934
you know,
there's no single answer.

00:57:05.934 --> 00:57:09.000
I suggest that if you have--

00:57:09.000 --> 00:57:12.400
And, you know, so it depends
on how many pages you have,

00:57:12.400 --> 00:57:15.501
and what CSS and JavaScript
is included in which pages.

00:57:15.501 --> 00:57:17.601
But it also depends
a lot on user metrics.

00:57:17.601 --> 00:57:20.267
Like, if you're
a page like MyYahoo,

00:57:20.267 --> 00:57:23.100
where people only come in and
they do one page view, right?

00:57:23.100 --> 00:57:24.234
There's only
one page view per session.

00:57:24.234 --> 00:57:25.601
MyYahoo doesn't have--

00:57:25.601 --> 00:57:27.534
unless you're editing,
or something like that,

00:57:27.534 --> 00:57:29.000
or unless
you have multiple pages,

00:57:29.000 --> 00:57:30.334
which most people don't.

00:57:30.334 --> 00:57:33.534
You know, you go
to your MyYahoo or iGoogle page,

00:57:33.534 --> 00:57:35.834
you view your modules
that are on there,

00:57:35.834 --> 00:57:37.367
and then you
go somewhere else, right?

00:57:37.367 --> 00:57:39.567
So really,
you only have one chance

00:57:39.567 --> 00:57:41.267
of serving
that page to that user,

00:57:41.267 --> 00:57:43.934
so I would inline
the CSS and JavaScript.

00:57:43.934 --> 00:57:45.434
'Cause for that--
You know, the reason

00:57:45.434 --> 00:57:47.367
to make it external
is for caching.

00:57:47.367 --> 00:57:49.501
Well, maybe that user
is going to come back today,

00:57:49.501 --> 00:57:50.968
but if they
come back tomorrow,

00:57:50.968 --> 00:57:53.367
or certainly if they don't come
back for three or four days,

00:57:53.367 --> 00:57:54.801
they're probably
not going to have

00:57:54.801 --> 00:57:56.701
those external resources
cached anymore.

00:57:56.701 --> 00:58:01.434
So what I recommend is, you
know, look at the user metrics.

00:58:01.434 --> 00:58:03.534
If it's, like,
a very small number

00:58:03.534 --> 00:58:07.467
of page views per session,
or page--or sessions per month,

00:58:07.467 --> 00:58:09.434
lean towards inlining.

00:58:09.434 --> 00:58:11.667
But if you have a site like,
you know, Calendar,

00:58:11.667 --> 00:58:13.601
or Facebook, or something
like that where people

00:58:13.601 --> 00:58:15.934
are doing multiple page views
per session,

00:58:15.934 --> 00:58:18.801
and multiple sessions--
a lot of sessions per month,

00:58:18.801 --> 00:58:23.601
Then you might want to make them
external to benefit caching.

00:58:23.601 --> 00:58:26.133
And then as far as, like,
when to concatenate or not,

00:58:26.133 --> 00:58:28.601
you don't want
to do what Facebook did

00:58:28.601 --> 00:58:31.300
and basically include
every file on every page.

00:58:31.300 --> 00:58:34.200
And you also don't want to
combine them all into one file.

00:58:34.200 --> 00:58:36.300
So you're going to
have to look at the pattern 

00:58:36.300 --> 00:58:39.467
or what's used and try to
figure out some middle ground.

00:58:39.467 --> 00:58:41.734
Last question.

00:58:41.734 --> 00:58:46.067
Ovsankin: Hi.
Sasha Ovsankin, IMshopping.

00:58:46.067 --> 00:58:49.267
So the question--
I'm coming from kind of

00:58:49.267 --> 00:58:51.434
a regular programming
engineering background.

00:58:51.434 --> 00:58:54.167
You know C++,
yeah, whatever.

00:58:54.167 --> 00:58:55.767
And I'm just
looking at you guys,

00:58:55.767 --> 00:58:58.033
you know, working
with all this CSS is--

00:58:58.033 --> 00:59:00.634
and it's kind of hard.

00:59:00.634 --> 00:59:04.400
You know, handcrafting all
these little details, all that.

00:59:04.400 --> 00:59:07.701
It kind of reminds
the working assembly language

00:59:07.701 --> 00:59:10.234
when you were, you know,
just working with

00:59:10.234 --> 00:59:13.334
calculating the pipelines
of the processor, and the--

00:59:13.334 --> 00:59:14.567
Souders: So we're actually
out of time.

00:59:14.567 --> 00:59:15.968
Ovsankin: Right.

00:59:15.968 --> 00:59:17.200
Souders: Do you want to ask
the question really quick?

00:59:17.200 --> 00:59:19.267
Ovsankin: Okay, so...
Souders: Sorry.

00:59:19.267 --> 00:59:20.701
Ovsankin:
The question is this:

00:59:20.701 --> 00:59:22.501
Are you aware of any efforts

00:59:22.501 --> 00:59:25.767
to do this
more on a higher level,

00:59:25.767 --> 00:59:28.033
more automatically, so that
you would just, just, just--

00:59:28.033 --> 00:59:29.667
Souders: Yeah. Yeah.

00:59:29.667 --> 00:59:31.801
So let me answer really quick,
'cause we're out of time,

00:59:31.801 --> 00:59:33.601
and then I'll stay after
and we can talk more.

00:59:33.601 --> 00:59:35.267
There's two companies that,
you know,

00:59:35.267 --> 00:59:37.033
I talk about quite a bit
that are doing that.

00:59:37.033 --> 00:59:38.767
One is Strangeloop Networks.

00:59:38.767 --> 00:59:40.434
They actually
have a hardware appliance

00:59:40.434 --> 00:59:43.234
that I think right now
only works with IIS.

00:59:43.234 --> 00:59:46.701
But you put it between
your web server and your VIP,

00:59:46.701 --> 00:59:50.767
and it actually changes the
HTML document as it comes out.

00:59:50.767 --> 00:59:52.601
It creates sprites on the fly,

00:59:52.601 --> 00:59:54.667
concatenates scripts
into single scripts,

00:59:54.667 --> 00:59:58.100
changes, you know, your CSS
to use background position,

00:59:58.100 --> 00:59:59.334
et cetera, for sprites.

00:59:59.334 --> 01:00:01.167
And then
there's a software solution

01:00:01.167 --> 01:00:03.400
from a company
called Aptomize.

01:00:03.400 --> 01:00:06.667
Their project is called
Runtime Page Optimizer.

01:00:06.667 --> 01:00:10.100
And it exists
for IIS and Apache.

01:00:10.100 --> 01:00:12.467
And it's a module that you add,
and it will do the same thing.

01:00:12.467 --> 01:00:17.000
Before the HTML leaves
the server, it's modified,

01:00:17.000 --> 01:00:18.501
and they
actually change the markup

01:00:18.501 --> 01:00:21.501
to adopt many of these
performance best practices.

01:00:21.501 --> 01:00:22.901
And then they
do also simple things,

01:00:22.901 --> 01:00:25.734
like just change
your config to turn on gzipping.

01:00:25.734 --> 01:00:27.634
Okay, thanks again.

01:00:27.634 --> 01:00:29.200
I'll stay
for any other questions.

01:00:29.200 --> 01:00:32.067
[applause]

