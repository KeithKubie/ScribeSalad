WEBVTT
Kind: captions
Language: en

00:00:05.640 --> 00:00:08.130
VINCENT SCHEIB: Hi, I'm Vince.

00:00:08.130 --> 00:00:09.960
I used to work on some
console games.

00:00:09.960 --> 00:00:12.510
Then, I worked on a game engine
called Gamebryo, did

00:00:12.510 --> 00:00:14.170
that for about five years.

00:00:14.170 --> 00:00:19.420
And now, I work at Google on
the web browser, Chrome.

00:00:19.420 --> 00:00:21.980
I'm going to talk to you for
about an hour on the bleeding

00:00:21.980 --> 00:00:23.950
edge of open web tech.

00:00:23.950 --> 00:00:27.610
So let's define open
web technologies.

00:00:27.610 --> 00:00:30.830
The open tech is basically APIs
is that are available for

00:00:30.830 --> 00:00:34.000
you as a developer that is
implemented by one or more

00:00:34.000 --> 00:00:36.670
browser vendors, or at least
could be implemented by

00:00:36.670 --> 00:00:39.550
another browser vendor if only
one browser vendor is

00:00:39.550 --> 00:00:41.820
implementing it at this time.

00:00:41.820 --> 00:00:43.770
Often, these technologies
go through a

00:00:43.770 --> 00:00:45.570
standardization process.

00:00:45.570 --> 00:00:49.790
For web technologies, that's
frequently the W3C.

00:00:49.790 --> 00:00:53.180
That offers benefits for
gathering feedback in a

00:00:53.180 --> 00:00:56.820
central location and going
through a very formal process

00:00:56.820 --> 00:01:01.360
of hardening and stabilizing
of specifications.

00:01:01.360 --> 00:01:03.900
Sometimes, this technology
is also open source.

00:01:03.900 --> 00:01:06.380
It's available for you to look
at the source code and include

00:01:06.380 --> 00:01:09.720
in your own projects as well.

00:01:09.720 --> 00:01:13.470
There's several benefits of
using open web technology.

00:01:13.470 --> 00:01:16.120
Basically, they come down
to being a free

00:01:16.120 --> 00:01:18.270
economy or a free market.

00:01:18.270 --> 00:01:20.190
Because multiple browser vendors
are implementing a

00:01:20.190 --> 00:01:24.270
technology, there's motivation
to compete for implementation

00:01:24.270 --> 00:01:27.830
quality and speed to
implement APIs.

00:01:27.830 --> 00:01:29.940
That benefits you, the
developer, who wants the

00:01:29.940 --> 00:01:33.940
highest quality APIs possible.

00:01:33.940 --> 00:01:36.240
In the open environment, it's
also easier for you, as a

00:01:36.240 --> 00:01:39.220
developer, to influence that
technology and the progress

00:01:39.220 --> 00:01:40.840
that it makes.

00:01:40.840 --> 00:01:42.560
And the individual browsers
that are making those

00:01:42.560 --> 00:01:46.090
technologies are more keen to
pay attention to actual

00:01:46.090 --> 00:01:49.440
application needs, because if
they don't pay attention,

00:01:49.440 --> 00:01:54.070
another browser vendor will, and
they'll lose market share.

00:01:54.070 --> 00:01:57.830
Open tech also helps
technologies live longer.

00:01:57.830 --> 00:02:00.800
You have more trust in the
longevity of a technology when

00:02:00.800 --> 00:02:03.260
there are multiple
implementations, when you have

00:02:03.260 --> 00:02:07.420
the ability to even implement
it yourself if needed.

00:02:07.420 --> 00:02:10.199
So in this presentation, I'm
going to be focusing on the

00:02:10.199 --> 00:02:13.470
bleeding edge of open web
tech, specifically

00:02:13.470 --> 00:02:15.220
with a lens for games.

00:02:15.220 --> 00:02:17.860
Now, a year ago at Game
Developers Conference, I gave

00:02:17.860 --> 00:02:21.190
a presentation doing a survey
of all the technology that I

00:02:21.190 --> 00:02:22.800
thought was relevant
for games.

00:02:22.800 --> 00:02:25.580
And I went through all the
basics and went through a lot

00:02:25.580 --> 00:02:26.930
of examples.

00:02:26.930 --> 00:02:28.780
A lot has happened in the
last year, and in this

00:02:28.780 --> 00:02:31.600
presentation, I'm going to try
to focus on what's happened

00:02:31.600 --> 00:02:35.780
recently in about the last six
months, and also focus on the

00:02:35.780 --> 00:02:38.570
current discussions and possible
futures for these

00:02:38.570 --> 00:02:39.820
technologies.

00:02:41.490 --> 00:02:43.310
To do that, I'm going to have
to jump through a lot of

00:02:43.310 --> 00:02:44.310
different technologies.

00:02:44.310 --> 00:02:46.990
So I've got an overview here
mentioning graphics,

00:02:46.990 --> 00:02:49.260
networking, audio, et cetera.

00:02:49.260 --> 00:02:50.780
We're just going to bounce
around through all these

00:02:50.780 --> 00:02:51.920
technologies.

00:02:51.920 --> 00:02:54.600
And at times, it can be
a little bit janky,

00:02:54.600 --> 00:02:55.930
but bear with me.

00:02:55.930 --> 00:02:58.370
We're going to just cover all
the news that I could find

00:02:58.370 --> 00:03:01.110
that I thought was interesting
for game developers.

00:03:01.110 --> 00:03:02.990
At the end, I'm going to talk
a little bit about apps,

00:03:02.990 --> 00:03:05.830
stores, and browsers.

00:03:05.830 --> 00:03:09.170
The takeaways I hope you're
going to have are new

00:03:09.170 --> 00:03:11.920
awareness of technologies and
the future direction of those

00:03:11.920 --> 00:03:16.120
technologies, an idea of the
current state of the platform,

00:03:16.120 --> 00:03:18.650
and I'm going to do that through
some demos of actual

00:03:18.650 --> 00:03:22.610
commercial games running
on technologies today.

00:03:22.610 --> 00:03:24.840
With this information, you
should be able to go back,

00:03:24.840 --> 00:03:27.630
work on current games that
can deploy today.

00:03:27.630 --> 00:03:30.070
But some of the technologies I
talk about aren't going to be

00:03:30.070 --> 00:03:33.110
ready for shipping a
game stable today.

00:03:33.110 --> 00:03:35.880
But they're definitely ready for
you to do R&amp;D work on and

00:03:35.880 --> 00:03:38.800
plan for the future, and also to
influence the direction of

00:03:38.800 --> 00:03:40.860
the open web platform.

00:03:40.860 --> 00:03:44.020
So with all that said, let's
get started with a demo.

00:03:44.020 --> 00:03:45.800
This is SKiD Racer.

00:03:45.800 --> 00:03:49.200
And let me bring up.

00:03:49.200 --> 00:03:53.120
All right, so this game
is currently shipping.

00:03:53.120 --> 00:03:55.500
It's available in the
Chrome web store.

00:03:55.500 --> 00:03:58.270
It's been implemented
in JavaScript.

00:03:58.270 --> 00:04:02.640
It uses WebGL, the
Web Audio API.

00:04:02.640 --> 00:04:05.674
And let me just try to race
it along a little bit.

00:04:09.083 --> 00:04:13.470
[GAME SOUND EFFECTS]

00:04:13.470 --> 00:04:16.940
So a caveat of all of my demos,
it's a little bit

00:04:16.940 --> 00:04:20.110
tricky to demo on the spot.

00:04:20.110 --> 00:04:22.840
And I'm not always
the best player.

00:04:22.840 --> 00:04:26.730
But I hope you get a sense of,
hey, wow, a 3D game looking

00:04:26.730 --> 00:04:29.020
like this running
in JavaScript?

00:04:29.020 --> 00:04:30.290
That's awesome.

00:04:30.290 --> 00:04:32.805
If you had shown me this three
years ago, it really would

00:04:32.805 --> 00:04:34.370
have blown my mind.

00:04:34.370 --> 00:04:37.580
It's awesome that web browsers
are becoming a platform so

00:04:37.580 --> 00:04:42.570
capable for this level of
quality of games today.

00:04:42.570 --> 00:04:46.400
And I'm really excited about the
future of getting higher

00:04:46.400 --> 00:04:49.930
and higher quality games
available in the web browser.

00:04:49.930 --> 00:04:53.906
So let's get into the meat
of the presentation.

00:04:53.906 --> 00:04:57.800
What I'm going to talk about
first is performance.

00:04:57.800 --> 00:05:00.780
For myself at least, I always
used to think about the web

00:05:00.780 --> 00:05:04.290
platform as a fairly
low-performing platform.

00:05:04.290 --> 00:05:06.580
JavaScript was pretty slow.

00:05:06.580 --> 00:05:08.330
I didn't think a lot of it.

00:05:08.330 --> 00:05:09.625
I was a console game
developer.

00:05:09.625 --> 00:05:12.790
It was all about optimized
C and C++, doing assembly

00:05:12.790 --> 00:05:15.930
coding, doing shaders,
and things like that.

00:05:15.930 --> 00:05:19.820
Well, there's a lot of movement
across all vendors to

00:05:19.820 --> 00:05:21.580
improve the quality
of performance.

00:05:21.580 --> 00:05:24.600
And let's hit some
of those topics.

00:05:24.600 --> 00:05:27.950
One important concept is
going multi-threaded.

00:05:27.950 --> 00:05:30.900
Web Workers provides the ability
for JavaScript to run

00:05:30.900 --> 00:05:32.280
in parallel.

00:05:32.280 --> 00:05:35.580
And a traditional web page is
just one thread of JavaScript

00:05:35.580 --> 00:05:38.280
that is modifying the contents
of the page for display.

00:05:38.280 --> 00:05:41.100
And it competes with several
other things the browser

00:05:41.100 --> 00:05:43.870
itself implements to
display that page.

00:05:43.870 --> 00:05:47.350
Web Workers allows you to have
JavaScript code that runs in

00:05:47.350 --> 00:05:49.710
parallel on another thread.

00:05:49.710 --> 00:05:52.680
Some recent news there is that
Internet Explorer is adding

00:05:52.680 --> 00:05:54.300
them into IE10.

00:05:54.300 --> 00:05:56.200
So that's great because that'll
bring them to all the

00:05:56.200 --> 00:05:58.840
major browsers on the desktop.

00:05:58.840 --> 00:06:02.050
In Chrome, there's been recent
improvements as well.

00:06:02.050 --> 00:06:05.070
For example, they've been moved
into the same process as

00:06:05.070 --> 00:06:08.110
the main thread, lowering
the memory footprint.

00:06:08.110 --> 00:06:10.840
Chrome uses multi-processes
for part of its sandboxing

00:06:10.840 --> 00:06:14.470
technology, which is why they
were in one per process

00:06:14.470 --> 00:06:16.430
previously.

00:06:16.430 --> 00:06:19.900
In Web Workers, there is a
method you can call called

00:06:19.900 --> 00:06:23.340
postMessage() and this is the
synchronization primitive of

00:06:23.340 --> 00:06:24.430
Web Workers.

00:06:24.430 --> 00:06:26.270
There is no Mutex or other

00:06:26.270 --> 00:06:28.050
synchronization primitive available.

00:06:28.050 --> 00:06:30.520
There's really just
message passing.

00:06:30.520 --> 00:06:33.000
Previously, passing messages
always meant

00:06:33.000 --> 00:06:34.860
copying your data.

00:06:34.860 --> 00:06:37.330
Copying the data is fine when
it's small, but when you're

00:06:37.330 --> 00:06:40.810
dealing with a game, you might
be trying to, for example,

00:06:40.810 --> 00:06:43.620
take your physics simulation and
run it in the background

00:06:43.620 --> 00:06:47.020
thread and then push updates to
the main thread for display

00:06:47.020 --> 00:06:49.300
through, for example, WebGL.

00:06:49.300 --> 00:06:50.720
You might be updating
quite a bit of data.

00:06:50.720 --> 00:06:52.580
It could even be a
couple megabytes.

00:06:52.580 --> 00:06:55.650
So making a copy of all
that is a poor choice.

00:06:55.650 --> 00:06:59.690
postMessage() now includes the
ability to transfer ownership.

00:06:59.690 --> 00:07:03.730
So on the background thread,
for example, you can update

00:07:03.730 --> 00:07:07.000
and prepare your world state,
and that can be quite large.

00:07:07.000 --> 00:07:09.880
You would call postMessage(),
and on that object, you would

00:07:09.880 --> 00:07:11.860
lose visibility on the
background thread, and it

00:07:11.860 --> 00:07:13.440
would gain visibility
on the main thread.

00:07:13.440 --> 00:07:16.890
It would just transfer
the ownership.

00:07:16.890 --> 00:07:19.480
Eric Bidelman from Chrome
Dev [? World ?]

00:07:19.480 --> 00:07:22.880
did a quick check of, for
example, transferring 32

00:07:22.880 --> 00:07:24.720
megabytes between threads.

00:07:24.720 --> 00:07:28.220
And on one machine, he saw
an improvement of 300

00:07:28.220 --> 00:07:30.640
milliseconds down to
7 milliseconds.

00:07:30.640 --> 00:07:32.680
That's almost two orders of
magnitude performance

00:07:32.680 --> 00:07:35.900
improvement for transferring
large blocks of data.

00:07:35.900 --> 00:07:39.260
So that's pretty cool.

00:07:39.260 --> 00:07:41.780
Along the lines of performance,
another thing

00:07:41.780 --> 00:07:45.400
game developers have been asking
for is vector support

00:07:45.400 --> 00:07:47.170
and matrix support
as first class

00:07:47.170 --> 00:07:49.270
citizens of the language.

00:07:49.270 --> 00:07:52.860
The good news is this is in
discussion now on the public

00:07:52.860 --> 00:07:56.810
effects working group list.
Matrix4x4 looks like it's

00:07:56.810 --> 00:08:02.480
going to be the first class
to be implemented into

00:08:02.480 --> 00:08:03.390
JavaScript.

00:08:03.390 --> 00:08:08.260
And it's just a beginning step
for linear algebra types being

00:08:08.260 --> 00:08:10.460
available in JavaScript.

00:08:10.460 --> 00:08:16.040
But it's a great start because
as we move forward, I expect

00:08:16.040 --> 00:08:19.170
we'll be able to see more and
more types and classes

00:08:19.170 --> 00:08:22.000
available, which can lead to
better optimizations in the

00:08:22.000 --> 00:08:25.780
JavaScript virtual machines and
easier utility for game

00:08:25.780 --> 00:08:27.030
developers.

00:08:29.520 --> 00:08:32.250
JavaScript in general
is always improving.

00:08:32.250 --> 00:08:35.179
Mozilla has a great phrase, Are
we fast yet? where they've

00:08:35.179 --> 00:08:37.980
been tracking the speed of
their performance for

00:08:37.980 --> 00:08:38.840
JavaScript.

00:08:38.840 --> 00:08:41.490
And they've been making
improvements year over year.

00:08:41.490 --> 00:08:43.960
Chrome, when it launched, was
notable for its inclusion of

00:08:43.960 --> 00:08:46.960
the V8 engine, which has
excellent performance.

00:08:46.960 --> 00:08:49.650
And it's been improving
well over time also.

00:08:49.650 --> 00:08:52.640
Some recent news is that
incremental garbage collection

00:08:52.640 --> 00:08:55.630
has been introduced in both
Chrome and Firefox.

00:08:55.630 --> 00:08:59.200
That reduces the occasional
pauses that garbage collection

00:08:59.200 --> 00:09:00.800
would introduce into apps.

00:09:00.800 --> 00:09:03.610
In games, that's a really poor
scenario because it causes you

00:09:03.610 --> 00:09:07.230
to drop frames or have a
stuttery frame rate.

00:09:07.230 --> 00:09:10.660
Now that it's incremental, that
problem has largely been

00:09:10.660 --> 00:09:13.440
diminished, and there's more
of just the simple constant

00:09:13.440 --> 00:09:16.450
tax of garbage collection
instead of postponing it, and

00:09:16.450 --> 00:09:20.220
then having a stuttering frame
rate for your users.

00:09:20.220 --> 00:09:22.530
Type inference is also
now available.

00:09:22.530 --> 00:09:25.670
Type inference allows for more
aggressive optimizations.

00:09:25.670 --> 00:09:27.390
JavaScript is--

00:09:27.390 --> 00:09:31.610
when you pass in data
to functions, it

00:09:31.610 --> 00:09:32.410
could be of any type.

00:09:32.410 --> 00:09:33.420
It could be a string.

00:09:33.420 --> 00:09:35.040
It could be a number.

00:09:35.040 --> 00:09:36.620
And that's a problem when
you're trying to

00:09:36.620 --> 00:09:38.730
optimize that code.

00:09:38.730 --> 00:09:41.820
Both Firefox and Chrome are
doing optimizations based on

00:09:41.820 --> 00:09:42.980
type inference.

00:09:42.980 --> 00:09:46.550
And they are realizing, hey,
this inner loop is really only

00:09:46.550 --> 00:09:47.830
running off of numbers.

00:09:47.830 --> 00:09:51.630
And specific machine code can be
highly optimized for that.

00:09:51.630 --> 00:09:54.330
In Chrome, there's a technology
call Crankshaft

00:09:54.330 --> 00:09:57.365
that does this with stochastic
profiling in real-time of

00:09:57.365 --> 00:09:59.750
where the hot spots are in your
code and aggressively

00:09:59.750 --> 00:10:02.040
optimizing those.

00:10:02.040 --> 00:10:04.860
A recent Firefox report
indicated that they had a 2x

00:10:04.860 --> 00:10:07.860
improvement in their box 2D
performance over the last

00:10:07.860 --> 00:10:09.740
year, which is pretty cool.

00:10:09.740 --> 00:10:13.070
It's now about six times
slower than native

00:10:13.070 --> 00:10:16.050
hand-optimized C and C++ code.

00:10:16.050 --> 00:10:19.430
So JavaScript is definitely
getting faster.

00:10:19.430 --> 00:10:21.960
Another component to talk about
in performance is the

00:10:21.960 --> 00:10:24.670
use of typed arrays and
how they're spreading.

00:10:24.670 --> 00:10:26.710
These were initially introduced
in WebGL.

00:10:26.710 --> 00:10:31.190
They've been used for vertex
buffers, textures, et cetera.

00:10:31.190 --> 00:10:34.960
You specifically were able to
specify the format of data

00:10:34.960 --> 00:10:38.200
that you were placing into these
arrays, which helps with

00:10:38.200 --> 00:10:41.640
your code being optimal and
accessing that data.

00:10:41.640 --> 00:10:43.950
They're now available
for transferring

00:10:43.950 --> 00:10:45.220
objects between threads.

00:10:45.220 --> 00:10:47.900
As I mentioned earlier in Web
Workers, typed array's one of

00:10:47.900 --> 00:10:51.040
the object types that can be
transferred and have the

00:10:51.040 --> 00:10:53.110
ownership transferred.

00:10:53.110 --> 00:10:56.350
They're also used in networking
with web sockets.

00:10:56.350 --> 00:10:58.295
When you're sending binary data,
you can do it through a

00:10:58.295 --> 00:11:00.720
typed array.

00:11:00.720 --> 00:11:05.990
XML HTTP request, or XHR, is
also supporting loading data

00:11:05.990 --> 00:11:07.960
directly into a typed array.

00:11:07.960 --> 00:11:11.530
So when you fetch your assets
from a web server, you often

00:11:11.530 --> 00:11:13.540
are doing so with XHR.

00:11:13.540 --> 00:11:17.570
And previously, you had to
re-process that data in order

00:11:17.570 --> 00:11:19.980
to prepare it for
use with WebGL.

00:11:19.980 --> 00:11:22.620
Now you're able to, if you
choose, optimize the

00:11:22.620 --> 00:11:24.950
client-side processing by
loading it directly into a

00:11:24.950 --> 00:11:27.190
typed array.

00:11:27.190 --> 00:11:29.270
And the last thing I want to
mention in performance is

00:11:29.270 --> 00:11:31.010
Intel's Rivertrail.

00:11:31.010 --> 00:11:35.050
So this is a pretty cool project
that they announced.

00:11:35.050 --> 00:11:37.300
It is open source and
available on GitHub.

00:11:37.300 --> 00:11:42.220
And they have a demo that you
can try out in Firefox.

00:11:42.220 --> 00:11:45.110
Their goal here is to enable you
to take advantage of more

00:11:45.110 --> 00:11:46.990
and more CPU power.

00:11:46.990 --> 00:11:49.040
They want you to be able to
take your embarrassingly

00:11:49.040 --> 00:11:51.890
parallel applications
and implement them

00:11:51.890 --> 00:11:53.760
in JavaScript easily.

00:11:53.760 --> 00:11:56.080
So they have a concept called
parallel arrays.

00:11:56.080 --> 00:11:58.480
And what you can do is implement
a function in

00:11:58.480 --> 00:12:00.890
JavaScript that's a
kernel operation.

00:12:00.890 --> 00:12:03.060
And you implement that function
in the context of

00:12:03.060 --> 00:12:06.710
just a single element in an
array or, for example, a pair.

00:12:06.710 --> 00:12:11.740
Say the i-th offset of
both array a and b.

00:12:11.740 --> 00:12:14.530
That kernel then composes
a new result

00:12:14.530 --> 00:12:16.060
based on those inputs.

00:12:16.060 --> 00:12:18.430
And it can do so in parallel.

00:12:18.430 --> 00:12:21.750
The framework itself can spread
it out based on the

00:12:21.750 --> 00:12:25.560
number of processors on the
machine to take advantage of

00:12:25.560 --> 00:12:26.960
all the hardware.

00:12:26.960 --> 00:12:28.140
It's pretty cool.

00:12:28.140 --> 00:12:31.740
It's probably still a ways off
from actually being considered

00:12:31.740 --> 00:12:34.290
into a stable shipping
browser.

00:12:34.290 --> 00:12:38.370
But it's nice to see the
research work being done to

00:12:38.370 --> 00:12:42.430
bring massively parallel
operations to JavaScript.

00:12:42.430 --> 00:12:43.880
So that wraps up performance.

00:12:43.880 --> 00:12:46.586
Let's move on to graphics.

00:12:46.586 --> 00:12:50.050
In graphics, we're going to
start from the beginning.

00:12:50.050 --> 00:12:52.840
How do you get your
content on screen?

00:12:52.840 --> 00:12:55.600
Traditionally, you do
this with a timer.

00:12:55.600 --> 00:13:00.170
You would update your state of
your web page and hope it's

00:13:00.170 --> 00:13:01.220
displayed to the user.

00:13:01.220 --> 00:13:04.320
If you want an animation, you
would set a timer and try to

00:13:04.320 --> 00:13:09.060
update 10 times a second or
maybe 100 times a second.

00:13:09.060 --> 00:13:11.580
The problem is you might be
running ahead of what the

00:13:11.580 --> 00:13:13.720
browser can actually display
to the user.

00:13:13.720 --> 00:13:14.490
You have no idea.

00:13:14.490 --> 00:13:17.190
You're out of control
in this situation.

00:13:17.190 --> 00:13:20.180
Request animation frame
understands that the browser

00:13:20.180 --> 00:13:23.600
is compositing all the content
of a web page and the browser

00:13:23.600 --> 00:13:25.780
UI and displaying
it to the user.

00:13:25.780 --> 00:13:29.550
It knows what rate things
can be displayed.

00:13:29.550 --> 00:13:33.590
By using this function, you take
your JavaScript code and

00:13:33.590 --> 00:13:36.720
provide a callback that the
browser recalls as soon as it

00:13:36.720 --> 00:13:38.700
can to display the next frame.

00:13:38.700 --> 00:13:41.700
You'll be called once every time
the browser is going to

00:13:41.700 --> 00:13:43.430
display content on the page.

00:13:43.430 --> 00:13:46.900
So it gives you the ability to
render at 60 Hertz without

00:13:46.900 --> 00:13:49.990
doing too much or
too little work.

00:13:49.990 --> 00:13:52.060
It has some other benefits
as well.

00:13:52.060 --> 00:13:53.680
If the user tabs away--

00:13:53.680 --> 00:13:56.040
for example, to check their
email or anything else--

00:13:56.040 --> 00:13:59.560
request animation frame will
stop calling your draw calls

00:13:59.560 --> 00:14:01.010
on tabs that are not visible.

00:14:01.010 --> 00:14:04.680
So that helps you be a better
citizen by not consuming

00:14:04.680 --> 00:14:07.490
computing resources that are
going to go to waste.

00:14:07.490 --> 00:14:10.260
It does the same thing if you
have a particular element on a

00:14:10.260 --> 00:14:13.800
web page and that element
is scrolled out of view.

00:14:13.800 --> 00:14:16.160
So if you have a very long page
that has a lot of dynamic

00:14:16.160 --> 00:14:20.100
content, that content is only
being rendered and updated

00:14:20.100 --> 00:14:23.690
when it's going to be
visible on page.

00:14:23.690 --> 00:14:27.830
So now that we've got our cycle
of draws in place, let's

00:14:27.830 --> 00:14:30.250
try to show them on screen
and make them

00:14:30.250 --> 00:14:31.530
as pretty as possible.

00:14:31.530 --> 00:14:33.390
I've got another demo in
fullscreen that, I think,

00:14:33.390 --> 00:14:35.570
shows this off well.

00:14:35.570 --> 00:14:37.380
Previously, browsers allowed
you to go into

00:14:37.380 --> 00:14:38.520
presentation mode.

00:14:38.520 --> 00:14:41.780
And you could make the browser
fullscreen and take the whole

00:14:41.780 --> 00:14:43.200
web page contents up.

00:14:43.200 --> 00:14:45.380
But in this case, we've got a
game that's basically in a

00:14:45.380 --> 00:14:46.410
little box.

00:14:46.410 --> 00:14:49.130
And what we want instead is, on
the web page, we want the

00:14:49.130 --> 00:14:53.110
ability to click a button and
bring a portion of that page

00:14:53.110 --> 00:14:54.540
fullscreen.

00:14:54.540 --> 00:14:57.640
We don't have to tell the user
how to interact with the

00:14:57.640 --> 00:15:00.890
browser's specific user
interface for going

00:15:00.890 --> 00:15:01.490
fullscreen.

00:15:01.490 --> 00:15:04.920
We can just put the controls
directly into a web page or

00:15:04.920 --> 00:15:08.210
into a game and allow transition
into fullscreen.

00:15:08.210 --> 00:15:12.660
So very useful, especially for
games where we want to really

00:15:12.660 --> 00:15:14.480
take over the entire
monitor display.

00:15:18.700 --> 00:15:21.000
And now, I'm going to talk about
WebGL, which is really

00:15:21.000 --> 00:15:22.470
the meat of graphics.

00:15:22.470 --> 00:15:23.880
There's quite a bit
of news here.

00:15:23.880 --> 00:15:27.780
So some recent things, first of
all, if you're not familiar

00:15:27.780 --> 00:15:31.660
with WebGL, it's OpenGL
ES brought

00:15:31.660 --> 00:15:33.740
to JavaScript bindings.

00:15:33.740 --> 00:15:37.800
OpenGL is a long-term graphics
API available on the desktop.

00:15:37.800 --> 00:15:39.020
It was fairly large.

00:15:39.020 --> 00:15:42.190
And when mobile platforms
started to support 3D, they

00:15:42.190 --> 00:15:45.520
wanted to minimize it to just
the recent high-quality

00:15:45.520 --> 00:15:47.590
feature set without
any redundancy.

00:15:47.590 --> 00:15:50.470
And that became OpenGL ES.

00:15:50.470 --> 00:15:52.130
WebGL exposes that
to JavaScript.

00:15:55.840 --> 00:16:00.540
So some recent news in WebGL is
that texture compression is

00:16:00.540 --> 00:16:02.930
becoming available through
an extension.

00:16:02.930 --> 00:16:06.900
And that provides S3TC, or more
commonly known as DXT,

00:16:06.900 --> 00:16:08.320
compression formats.

00:16:08.320 --> 00:16:10.140
So that's great to know.

00:16:10.140 --> 00:16:13.390
In Chrome, we've recently made
it so that errors are

00:16:13.390 --> 00:16:16.070
automatically reported to the
console without performing any

00:16:16.070 --> 00:16:18.940
special operation for any of
the error checking that we

00:16:18.940 --> 00:16:21.730
have to do as just part of
normal security checking,

00:16:21.730 --> 00:16:24.960
which is a fair amount of error
checking in OpenGL.

00:16:24.960 --> 00:16:27.780
If you want absolutely all error
checking to be done, you

00:16:27.780 --> 00:16:31.660
can use a command line switch,
enable GPU debugging, which

00:16:31.660 --> 00:16:37.050
will call glGetError after every
call that you make, and

00:16:37.050 --> 00:16:40.030
that will help you find
any errors rapidly.

00:16:40.030 --> 00:16:43.220
Firefox, I believe, has
always had an option--

00:16:43.220 --> 00:16:45.690
although you have to enable
it-- to display errors in

00:16:45.690 --> 00:16:48.050
their console.

00:16:48.050 --> 00:16:51.930
Some of the upcoming features
in WebGL are the support of

00:16:51.930 --> 00:16:54.170
32-bit index buffers.

00:16:54.170 --> 00:16:57.140
Currently, they're are only
supporting 16-bit.

00:16:57.140 --> 00:17:02.220
Also, an extension to offer
instanced drawing.

00:17:02.220 --> 00:17:05.339
And finally, shared resources
across canvases.

00:17:05.339 --> 00:17:10.130
So in WebGL, a canvas is the
area of a web page that you

00:17:10.130 --> 00:17:12.410
can send your 3D content to.

00:17:12.410 --> 00:17:14.700
For games, you're probably going
to have just one canvas.

00:17:14.700 --> 00:17:16.829
But it's possible that you might
want to have multiple

00:17:16.829 --> 00:17:20.710
view ports interspersed with
other web page content.

00:17:20.710 --> 00:17:23.640
If you do that today, you can't
share vertex or texture

00:17:23.640 --> 00:17:25.510
data between those canvases.

00:17:25.510 --> 00:17:28.630
And so work is underway to
enable you to do that.

00:17:28.630 --> 00:17:29.810
That's somewhat interesting.

00:17:29.810 --> 00:17:33.320
But where it becomes more
interesting is in the somewhat

00:17:33.320 --> 00:17:36.160
longer-term future of WebGL.

00:17:36.160 --> 00:17:38.760
At that time, we're hoping to
share resources across Web

00:17:38.760 --> 00:17:40.150
Workers as well.

00:17:40.150 --> 00:17:42.640
So I mentioned earlier, for
example, performing a physics

00:17:42.640 --> 00:17:45.320
update on a background
Web Worker.

00:17:45.320 --> 00:17:48.150
When you do that, you'll have
to transfer that data to the

00:17:48.150 --> 00:17:50.290
main thread for submission
to WebGL.

00:17:50.290 --> 00:17:52.290
But it would be great if,
directly from the background

00:17:52.290 --> 00:17:56.000
thread, you could update
resources, send them to the

00:17:56.000 --> 00:17:58.140
GPU, and have them ready for
the main thread without

00:17:58.140 --> 00:18:00.580
blocking that main thread.

00:18:00.580 --> 00:18:02.710
Other things coming a little bit
further down the road are

00:18:02.710 --> 00:18:07.270
anisotropic filtering and also
depth textures, which has a

00:18:07.270 --> 00:18:10.210
little bit more of a dicey
implementation question,

00:18:10.210 --> 00:18:14.830
especially around supporting
DX9, but is solvable.

00:18:14.830 --> 00:18:16.580
So because I'm talking
about graphics, it's

00:18:16.580 --> 00:18:18.700
great to have demos.

00:18:18.700 --> 00:18:21.235
Many of the demos that are
available on the web now are

00:18:21.235 --> 00:18:22.110
tech demos.

00:18:22.110 --> 00:18:24.930
There's a few commercial games
like the one I showed earlier.

00:18:24.930 --> 00:18:28.280
This is just a ship viewer for
EVE, which I think is great

00:18:28.280 --> 00:18:32.970
because it ties in WebGL as
utilized in an auxiliary means

00:18:32.970 --> 00:18:36.430
for a large and well-known
commercial game.

00:18:36.430 --> 00:18:39.090
So they just have a ship viewer,
but it's pretty cool.

00:18:39.090 --> 00:18:42.590
You can see these high-quality
assets, fly in, zoom around a

00:18:42.590 --> 00:18:43.090
little bit.

00:18:43.090 --> 00:18:47.550
And it's nice to see other
games that have been

00:18:47.550 --> 00:18:50.560
longstanding for some time
starting to use WebGL in

00:18:50.560 --> 00:18:51.840
situations such as this.

00:18:54.800 --> 00:18:57.090
One more, cool.

00:18:57.090 --> 00:19:01.140
All right, so now, we're going
to switch gears, talk a little

00:19:01.140 --> 00:19:03.710
bit about networking.

00:19:03.710 --> 00:19:06.760
On the internet, networking has
always been around, right?

00:19:06.760 --> 00:19:09.350
But it's always been in a
client-server model, and it's

00:19:09.350 --> 00:19:10.865
been more about fetching
resources.

00:19:13.950 --> 00:19:17.290
So typically, a web browser
says, hey, server, can you

00:19:17.290 --> 00:19:18.300
give me that web page?

00:19:18.300 --> 00:19:21.190
Can you give me that image
or that audio file?

00:19:21.190 --> 00:19:25.040
For games, we want something
much more rapid

00:19:25.040 --> 00:19:26.430
to enable game play.

00:19:26.430 --> 00:19:32.090
So Web Sockets is a technology
that supports that.

00:19:32.090 --> 00:19:34.130
It's client-server
still, but it's

00:19:34.130 --> 00:19:37.480
bi-directional and low latency.

00:19:37.480 --> 00:19:39.750
Previously, to support
bi-directional or to allow the

00:19:39.750 --> 00:19:43.070
server to push data to a client,
the client had to open

00:19:43.070 --> 00:19:45.430
up a connection to the server
and leave it hanging.

00:19:45.430 --> 00:19:47.400
It was kind of awkward, and it
definitely didn't solve the

00:19:47.400 --> 00:19:49.740
low latency problem.

00:19:49.740 --> 00:19:51.730
Web Sockets does, and
it's available to

00:19:51.730 --> 00:19:53.610
work with in Chrome.

00:19:53.610 --> 00:19:57.190
It's also being unprefixed in
Firefox 11, so it'll be

00:19:57.190 --> 00:19:59.680
available for production
games there.

00:19:59.680 --> 00:20:03.760
And Internet Explorer 10 is
bringing support as well.

00:20:03.760 --> 00:20:06.300
Initially, it supported
just text transfers.

00:20:06.300 --> 00:20:09.670
But binary data is
also on board.

00:20:09.670 --> 00:20:13.400
And so you can optimize
your bandwidth usage

00:20:13.400 --> 00:20:15.600
considerably now.

00:20:15.600 --> 00:20:18.550
So if we're talking about
networking, Web Sockets is

00:20:18.550 --> 00:20:21.070
only going to solve the
client-server problem.

00:20:21.070 --> 00:20:25.840
You also want to solve peer to
peer problems. So to do that,

00:20:25.840 --> 00:20:27.760
I need to talk about WebRTC.

00:20:27.760 --> 00:20:29.490
But this is a large
project, so let me

00:20:29.490 --> 00:20:31.130
start at the beginning.

00:20:31.130 --> 00:20:34.940
The goal of WebRTC is to bring
video conferencing

00:20:34.940 --> 00:20:38.840
capabilities and technologies
natively into the browser with

00:20:38.840 --> 00:20:41.210
APIs so that developers
can use them in any

00:20:41.210 --> 00:20:42.850
way they see fit.

00:20:42.850 --> 00:20:46.200
So this includes codecs for
audio and video, real-time

00:20:46.200 --> 00:20:50.760
encoding and decoding, echo
cancellation, noise reduction

00:20:50.760 --> 00:20:53.650
for both the audio and video,
automatic gain control for the

00:20:53.650 --> 00:20:56.740
audio, network jitter
management, again for both

00:20:56.740 --> 00:20:58.310
audio, video.

00:20:58.310 --> 00:21:00.800
And also, because they're peer
to peer connections, it

00:21:00.800 --> 00:21:03.680
includes a solution for NAT
and firewall traversal

00:21:03.680 --> 00:21:05.500
technology.

00:21:05.500 --> 00:21:06.990
So that's a great start.

00:21:06.990 --> 00:21:10.300
And basically, you'll be able to
get things like Google Chat

00:21:10.300 --> 00:21:13.820
working on your own web page
or game with APIs that are

00:21:13.820 --> 00:21:17.110
going to be built directly
into the browser.

00:21:17.110 --> 00:21:18.890
However, that's just
video chat.

00:21:18.890 --> 00:21:21.900
And while a lot of games are
going to use video, or even

00:21:21.900 --> 00:21:24.910
just the audio portion of that,
it's still not what you

00:21:24.910 --> 00:21:25.750
really want.

00:21:25.750 --> 00:21:28.280
What you really want
is the data API.

00:21:28.280 --> 00:21:31.270
So this is currently
under discussion.

00:21:31.270 --> 00:21:33.980
The data API's goal is to allow
you to have multiple

00:21:33.980 --> 00:21:37.060
channels of application-specific
data

00:21:37.060 --> 00:21:40.280
piggybacking on one of these
peer to peer connections.

00:21:40.280 --> 00:21:43.680
It can be reliable or
unreliable, and it will allow

00:21:43.680 --> 00:21:46.240
you to send strings,
binary blobs,

00:21:46.240 --> 00:21:48.660
array buffers, et cetera.

00:21:48.660 --> 00:21:50.640
It will also allow your
application to check to see if

00:21:50.640 --> 00:21:53.590
that data's being buffered so
you can adjust your send rate

00:21:53.590 --> 00:21:55.770
based on the bandwidth
available.

00:21:55.770 --> 00:21:58.040
So that's basically
the holy grail for

00:21:58.040 --> 00:21:59.780
games and peer to peer.

00:21:59.780 --> 00:22:02.620
It's the closest thing we're
likely to get to UDP through

00:22:02.620 --> 00:22:04.560
web standards.

00:22:04.560 --> 00:22:09.020
It's still in discussion right
now, but the rest of WebRTC

00:22:09.020 --> 00:22:12.140
has gotten into technology
preview in at least Chrome and

00:22:12.140 --> 00:22:14.340
Opera at this point.

00:22:14.340 --> 00:22:18.570
So one portion of WebRTC is
just the audio and video.

00:22:18.570 --> 00:22:21.870
And there's a method called
getUserMedia() which allows

00:22:21.870 --> 00:22:24.150
you to gain access to that even
if you're not going to

00:22:24.150 --> 00:22:25.760
send it over the network.

00:22:25.760 --> 00:22:29.450
So I've got a demo I want to
show you for that as well.

00:22:29.450 --> 00:22:31.580
Let me launch that up.

00:22:31.580 --> 00:22:35.010
So basically, you can say,
hey, is there a camera

00:22:35.010 --> 00:22:35.950
attached to this computer?

00:22:35.950 --> 00:22:37.530
Let's load it up.

00:22:37.530 --> 00:22:41.290
And here, I've got a WebGL
application that has got me.

00:22:41.290 --> 00:22:42.160
Hi, me!

00:22:42.160 --> 00:22:43.420
How's it going?

00:22:43.420 --> 00:22:48.020
And I can watch TV on TV,
which is kind of cool.

00:22:48.020 --> 00:22:50.330
This came from learning
three.js.

00:22:50.330 --> 00:22:53.290
So it's accessing my webcam
with no plug-ins, just

00:22:53.290 --> 00:22:58.090
directly through the
getUserMedia() API.

00:22:58.090 --> 00:23:00.560
So very cool, and definitely
appropriate for

00:23:00.560 --> 00:23:01.810
certain types of games.

00:23:03.930 --> 00:23:08.220
On Chrome right now, it's behind
a media stream flag.

00:23:08.220 --> 00:23:10.310
All right, so we've already
started getting off the topic

00:23:10.310 --> 00:23:12.590
of networking and talking
about video and audio.

00:23:12.590 --> 00:23:14.810
So let's just switch directly
into audio.

00:23:17.320 --> 00:23:20.610
Audio has been available in web
browsers for some time.

00:23:20.610 --> 00:23:24.180
The early history
is unpleasant.

00:23:24.180 --> 00:23:27.220
In HTML5, the audio
tag arrived.

00:23:27.220 --> 00:23:30.050
The goal there was to make
including audio on a web page

00:23:30.050 --> 00:23:31.590
as simple as including
an image.

00:23:31.590 --> 00:23:33.870
You just put a tag
on the web page.

00:23:33.870 --> 00:23:37.420
Game developers noticed this tag
for audio and said, hey,

00:23:37.420 --> 00:23:38.700
that's great.

00:23:38.700 --> 00:23:39.950
Let's try using it.

00:23:39.950 --> 00:23:43.230
The problem was it was initially
designed and

00:23:43.230 --> 00:23:46.570
implemented in the context of
including a song or maybe a

00:23:46.570 --> 00:23:49.610
streaming presentation
onto a web page.

00:23:49.610 --> 00:23:52.010
Controls are optional and can
be displayed to the users so

00:23:52.010 --> 00:23:55.260
they can seek around and
pause the audio stream.

00:23:55.260 --> 00:23:58.610
You can create multiple hidden
audio tags to have a sound

00:23:58.610 --> 00:24:00.620
bank in the background
and use that for

00:24:00.620 --> 00:24:02.090
sound effects in games.

00:24:02.090 --> 00:24:04.330
But this has been fraught
with peril.

00:24:04.330 --> 00:24:07.300
A couple months ago there was
a conference call New Game.

00:24:07.300 --> 00:24:10.280
They had several presentations,
and I think

00:24:10.280 --> 00:24:14.140
every presentation had
complaints about the state of

00:24:14.140 --> 00:24:16.510
audio today in the audio tag.

00:24:16.510 --> 00:24:18.200
There are definitely some
problems there.

00:24:18.200 --> 00:24:21.160
The good news is there's been
significant progress in all

00:24:21.160 --> 00:24:25.050
browsers improving the
performance and the quality of

00:24:25.050 --> 00:24:26.520
that implementation.

00:24:26.520 --> 00:24:28.930
But in the long run, it's still
going to be an overly

00:24:28.930 --> 00:24:32.470
limited mechanism to implement
audio in your games.

00:24:32.470 --> 00:24:37.430
So there are some other APIs
that are worth talking about.

00:24:37.430 --> 00:24:42.110
A while ago, Mozilla presented
the Audio Data API, which took

00:24:42.110 --> 00:24:45.430
the audio tag and it built on it
a little bit by offering a

00:24:45.430 --> 00:24:49.800
JavaScript source for
that streaming data.

00:24:49.800 --> 00:24:53.830
Basically, every time the
audio needed additional

00:24:53.830 --> 00:24:57.440
samples, they could be produced
in JavaScript.

00:24:57.440 --> 00:25:00.210
This project has been sunset by
Mozilla in favor of another

00:25:00.210 --> 00:25:02.540
API, which I'll describe
a little bit later.

00:25:02.540 --> 00:25:06.700
But it also suffers from some
problems, in that requiring

00:25:06.700 --> 00:25:09.960
JavaScript implementation of all
your audio processing is

00:25:09.960 --> 00:25:12.370
pretty heavy-handed when much
of it could be heavily

00:25:12.370 --> 00:25:15.250
optimized directly
in the browser.

00:25:15.250 --> 00:25:18.910
That's the route of this
API, the Web Audio API.

00:25:18.910 --> 00:25:21.955
The Web Audio API is recently
available in Chrome.

00:25:21.955 --> 00:25:26.220
It started shipping last fall,
and can be used today in

00:25:26.220 --> 00:25:27.750
stable versions of
the browser.

00:25:27.750 --> 00:25:30.010
It has ongoing work.

00:25:30.010 --> 00:25:33.880
In November, Intel jumped on
board in WebKit and started

00:25:33.880 --> 00:25:36.020
doing some additional
optimization.

00:25:36.020 --> 00:25:42.040
And recently, in January, we
added support for sourcing

00:25:42.040 --> 00:25:44.420
audio channels directly
from audio tags.

00:25:44.420 --> 00:25:47.510
The audio tag has a couple of
good properties, including a

00:25:47.510 --> 00:25:48.740
streaming capability.

00:25:48.740 --> 00:25:51.690
So you don't have to entirely
pre-load your audio data.

00:25:51.690 --> 00:25:55.400
So that's recently available
in the Web Audio API.

00:25:55.400 --> 00:25:58.130
And there's been a lot of
background or back-end work

00:25:58.130 --> 00:26:01.350
and optimization being
done there.

00:26:01.350 --> 00:26:06.070
Angry Birds, which was a game
that was ported to HTML5 tech

00:26:06.070 --> 00:26:09.940
and runs on Chrome, last year,
it has recently been

00:26:09.940 --> 00:26:11.960
transitioned over to
Web Audio API.

00:26:11.960 --> 00:26:14.600
So there's that and a few other
examples of production

00:26:14.600 --> 00:26:17.060
games using this API.

00:26:17.060 --> 00:26:23.070
The API was initially designed
using FMOD, and Wwise, and

00:26:23.070 --> 00:26:25.910
Miles, I believe, from the game
industry as inspiration

00:26:25.910 --> 00:26:29.160
for a lot of the use cases and
needs that developers would

00:26:29.160 --> 00:26:32.590
have. So it's very suitable
API for games.

00:26:32.590 --> 00:26:35.900
Moving forward, there are
several things yet to be done

00:26:35.900 --> 00:26:36.945
with this API.

00:26:36.945 --> 00:26:40.180
It could be tied in more
tightly with WebRTC--

00:26:40.180 --> 00:26:43.490
for example, getting access to
your audio stream coming in

00:26:43.490 --> 00:26:44.570
from your webcam.

00:26:44.570 --> 00:26:47.490
Or let's say you want to plug
your guitar directly into your

00:26:47.490 --> 00:26:51.150
computer and then process
that as well.

00:26:51.150 --> 00:26:53.080
It's also a question of
multi-channel sound.

00:26:53.080 --> 00:26:55.050
Now, that's multifaceted.

00:26:55.050 --> 00:26:58.400
Today, you can load surround
sound through an audio tag,

00:26:58.400 --> 00:27:00.680
and you can render that out
to your speakers, and

00:27:00.680 --> 00:27:01.620
it works all right.

00:27:01.620 --> 00:27:05.920
But what you can't do is
separate those channels and

00:27:05.920 --> 00:27:09.090
manipulate them independently.

00:27:09.090 --> 00:27:10.990
Being able to support
that would be great.

00:27:10.990 --> 00:27:14.520
So that's decoding multi-channel
audio, and then

00:27:14.520 --> 00:27:17.750
also re-encoding that when
outputting to speaker

00:27:17.750 --> 00:27:19.190
configurations.

00:27:19.190 --> 00:27:21.770
That would provide the ability
to also do the 3D

00:27:21.770 --> 00:27:24.700
specialization that the Web
Audio API offers, but on

00:27:24.700 --> 00:27:27.410
multi-channel audio as well.

00:27:27.410 --> 00:27:29.920
There's also a scenario
for multi-bus audio.

00:27:29.920 --> 00:27:32.310
So consider, for
example, a DJ.

00:27:32.310 --> 00:27:34.450
They're playing some music, and
that's going out to the

00:27:34.450 --> 00:27:36.010
house speakers.

00:27:36.010 --> 00:27:37.900
But they also want to
preview what they

00:27:37.900 --> 00:27:39.390
want to queue up next.

00:27:39.390 --> 00:27:42.690
So they want both of those
to be, say, in stereo.

00:27:42.690 --> 00:27:45.860
And so it's multi-channel, but
it's not all the same music.

00:27:45.860 --> 00:27:47.510
It's not all synchronized
together.

00:27:47.510 --> 00:27:49.695
That would be great to support
through this API, as well, and

00:27:49.695 --> 00:27:52.390
is being discussed.

00:27:52.390 --> 00:27:54.620
There's another question about
device discoverability.

00:27:54.620 --> 00:27:58.050
So what kinds of speakers are
on this computer, and what

00:27:58.050 --> 00:28:01.120
kinds of audio inputs are
available, providing that

00:28:01.120 --> 00:28:02.630
through the API somehow.

00:28:02.630 --> 00:28:06.030
That, again, is still in early
discussion and is also related

00:28:06.030 --> 00:28:09.610
to the device API's
working group.

00:28:09.610 --> 00:28:13.670
And finally, allowing parallel
processing of audio.

00:28:13.670 --> 00:28:16.370
Right now, if you perform
JavaScript processing using

00:28:16.370 --> 00:28:19.360
the Web Audio API, you have to
do it on the main thread.

00:28:19.360 --> 00:28:21.620
But it'd be great to offer
something like an

00:28:21.620 --> 00:28:25.540
onAudioProcess call that could
be made on a worker thread

00:28:25.540 --> 00:28:27.680
instead of on the main thread.

00:28:27.680 --> 00:28:33.080
So I've got some demos that are
worth throwing off here.

00:28:33.080 --> 00:28:35.500
Let's launch some of those.

00:28:35.500 --> 00:28:37.010
There's quite a bit to cover.

00:28:37.010 --> 00:28:38.930
So the first thing I'm going
to do is something simple.

00:28:38.930 --> 00:28:39.330
[MUSIC - "BLACKBIRD"
BY THE BEATLES]

00:28:39.330 --> 00:28:44.650
Let's just show rendering out an
FFT of an audio stream, and

00:28:44.650 --> 00:28:47.430
also playing with convolution
providing

00:28:47.430 --> 00:28:48.990
pre-recorded reverb plate.

00:28:57.650 --> 00:28:59.816
Bring it back to dry.

00:28:59.816 --> 00:29:02.256
Bring it up to the
full reverb.

00:29:07.640 --> 00:29:10.090
All right, we can also
do multi-track.

00:29:10.090 --> 00:29:13.200
So here's a demo that has
several tracks all being

00:29:13.200 --> 00:29:15.305
independently visualized and
controlled with sliders.

00:29:15.305 --> 00:29:17.790
[MUSIC -  "1901" BY PHOENIX]

00:29:17.790 --> 00:29:20.050
We can bring levels
down and up.

00:29:24.800 --> 00:29:26.650
And we can solo out channels.

00:29:32.714 --> 00:29:34.100
Cool, all right.

00:29:34.100 --> 00:29:36.590
And sample accurate scheduling,
very critical for

00:29:36.590 --> 00:29:40.190
games, and one of the largest
efficiencies of the audio tag.

00:29:40.190 --> 00:29:43.144
Here's a simple tech demo
showing very tight

00:29:43.144 --> 00:29:43.642
synchronization.

00:29:43.642 --> 00:29:56.100
[MUSIC PLAYING]

00:29:56.100 --> 00:29:57.350
And just along the lines of

00:29:57.350 --> 00:29:59.150
synchronization and hopping around--

00:29:59.150 --> 00:29:59.996
[MUSIC - "BOHEMIAN RHAPSODY"
BY QUEEN]

00:29:59.996 --> 00:30:02.950
--here, we've got a song broken
up into the fundamental

00:30:02.950 --> 00:30:04.970
components, just little
short snippets.

00:30:04.970 --> 00:30:10.400
And as I mouse over, I can queue
them up in any order

00:30:10.400 --> 00:30:11.650
that I feel.

00:30:15.695 --> 00:30:21.250
All right, and let's switch
over to synthesizing some

00:30:21.250 --> 00:30:23.430
sound in JavaScript.

00:30:23.430 --> 00:30:26.500
ByteBeats are a cool little toy,
especially if you're into

00:30:26.500 --> 00:30:27.890
demo [UNINTELLIGIBLE]
type things.

00:30:27.890 --> 00:30:31.040
You take an equation, you get
an input for time, and you

00:30:31.040 --> 00:30:32.320
just output a number.

00:30:32.320 --> 00:30:33.830
And we interpret that
directly for audio.

00:30:33.830 --> 00:30:35.010
[MUSIC PLAYING]

00:30:35.010 --> 00:30:37.600
Very cool, and just an example
of what you can do in

00:30:37.600 --> 00:30:38.490
JavaScript.

00:30:38.490 --> 00:30:41.440
This demo can be live-edited.

00:30:41.440 --> 00:30:43.000
All right, so let's move on.

00:30:46.240 --> 00:30:48.585
So another thing you
need in audio is--

00:30:48.585 --> 00:30:49.240
oh, I'm sorry.

00:30:49.240 --> 00:30:51.950
So another API that has been
proposed-- and this is what

00:30:51.950 --> 00:30:56.380
Mozilla is currently stating
as their hope for future

00:30:56.380 --> 00:30:57.010
implementation--

00:30:57.010 --> 00:30:59.680
is the MediaStream
processing API.

00:30:59.680 --> 00:31:02.920
This API shares a lot in common
with the previous API.

00:31:02.920 --> 00:31:07.060
They're both graft-based APIs
where you configure from

00:31:07.060 --> 00:31:10.150
JavaScript a series of nodes
for leveling, reverb,

00:31:10.150 --> 00:31:12.240
convolution, et cetera.

00:31:12.240 --> 00:31:15.340
They have a very syntactically
different approach here, but

00:31:15.340 --> 00:31:19.250
the underlying concept
is quite the same.

00:31:19.250 --> 00:31:21.710
It's at early days
for this API.

00:31:21.710 --> 00:31:24.720
It'll be interesting to see
how it moves forward.

00:31:24.720 --> 00:31:26.510
And for more details,
you really have to

00:31:26.510 --> 00:31:27.570
read through the spec.

00:31:27.570 --> 00:31:31.180
And if you're an audiophile and
a developer, I definitely

00:31:31.180 --> 00:31:34.240
encourage you to get into the
audio working group and

00:31:34.240 --> 00:31:37.260
express some opinions about
the pros and cons of those

00:31:37.260 --> 00:31:40.110
APIs so that we can start to
hone things down into a

00:31:40.110 --> 00:31:42.970
unified API.

00:31:42.970 --> 00:31:46.230
One last thing in audio is the
MediaController, a fairly

00:31:46.230 --> 00:31:49.340
simplistic API that allows you
to tie multiple sources

00:31:49.340 --> 00:31:51.520
together so that they're
synchronized.

00:31:51.520 --> 00:31:55.110
Consider having a video
and two audio tracks.

00:31:55.110 --> 00:31:59.160
They could be streaming live, or
perhaps one audio track is

00:31:59.160 --> 00:32:01.360
already downloaded by you,
but the other sources are

00:32:01.360 --> 00:32:02.350
streaming live.

00:32:02.350 --> 00:32:05.030
They could be streaming from
multiple sources, say.

00:32:05.030 --> 00:32:07.980
You want to make sure that
they all stay in sync and

00:32:07.980 --> 00:32:09.380
never get out of sync.

00:32:09.380 --> 00:32:12.220
The MediaController allows
you to tie them together.

00:32:12.220 --> 00:32:14.840
In the event that one stalls,
it'll hold all of them

00:32:14.840 --> 00:32:16.750
together and things like that.

00:32:16.750 --> 00:32:20.300
So, small but very useful API.

00:32:20.300 --> 00:32:24.780
All right, let's move
on to controls.

00:32:24.780 --> 00:32:29.220
The web has a fairly
straightforward keyboard and

00:32:29.220 --> 00:32:32.980
mouse control scheme, but it can
handle some improvements.

00:32:32.980 --> 00:32:36.080
Personally, I'm working on
the Pointer Lock API.

00:32:36.080 --> 00:32:39.820
This is basically Mouse Lock,
and again, probably easiest to

00:32:39.820 --> 00:32:42.760
show off with a demo.

00:32:42.760 --> 00:32:45.830
You have a mouse cursor on your
computer, and move it

00:32:45.830 --> 00:32:47.060
around with your mouse.

00:32:47.060 --> 00:32:48.690
But that's kind of frustrating
for games,

00:32:48.690 --> 00:32:50.030
especially in first person.

00:32:50.030 --> 00:32:52.560
So I move into fullscreen here,
and I try moving around.

00:32:52.560 --> 00:32:54.340
But I have to keep dragging
with the mouse.

00:32:54.340 --> 00:32:57.060
And I can hit, for example,
the edge of the screen.

00:32:57.060 --> 00:32:59.840
Or if I wasn't fullscreen,
I'd fall off an element.

00:32:59.840 --> 00:33:02.150
I can disable the
mouse cursor.

00:33:02.150 --> 00:33:04.220
So here, my JavaScript
requested it.

00:33:04.220 --> 00:33:06.700
I clicked on OK at the
top of the screen.

00:33:06.700 --> 00:33:08.660
And now, there's no
more mouse cursor.

00:33:08.660 --> 00:33:10.800
I can move around freely the
same way you would in any

00:33:10.800 --> 00:33:12.260
first person game.

00:33:12.260 --> 00:33:13.915
I can exit and re-enter
that mode.

00:33:13.915 --> 00:33:16.190
And because I've already given
it permission, the permission

00:33:16.190 --> 00:33:20.047
is remembered, and it's just
the kind of experience that

00:33:20.047 --> 00:33:23.410
you want for games.

00:33:23.410 --> 00:33:25.210
So, fairly simplistic.

00:33:25.210 --> 00:33:27.950
It's great to have it
moving forward.

00:33:27.950 --> 00:33:30.450
I've got an implementation in
Chrome that's available behind

00:33:30.450 --> 00:33:32.170
a flag for JavaScript.

00:33:32.170 --> 00:33:36.020
It's available for shipping
Native Client games right now.

00:33:36.020 --> 00:33:38.800
And on the Firefox
browser, there is

00:33:38.800 --> 00:33:40.310
work underway as well.

00:33:40.310 --> 00:33:44.030
It's available in special builds
that they have also, so

00:33:44.030 --> 00:33:45.940
good stuff.

00:33:45.940 --> 00:33:47.840
Hey, now that we're talking
about games and controlling

00:33:47.840 --> 00:33:49.560
them, let's talk
about gamepads.

00:33:49.560 --> 00:33:54.000
So right here I've got an
Xbox 360 controller.

00:33:54.000 --> 00:33:56.900
Some games I prefer to
play with a gamepad.

00:33:56.900 --> 00:34:00.790
So in this case, that
wasn't previously

00:34:00.790 --> 00:34:02.490
available on the internet.

00:34:02.490 --> 00:34:06.620
But an API is under way in
Chrome and Firefox again to

00:34:06.620 --> 00:34:08.409
offer this support.

00:34:08.409 --> 00:34:12.179
So here, I can push buttons on
my gamepad controller and read

00:34:12.179 --> 00:34:14.000
them on a web app.

00:34:14.000 --> 00:34:17.870
Very cool, very useful, some
games are just going to be

00:34:17.870 --> 00:34:19.120
best with gamepads.

00:34:22.620 --> 00:34:23.870
Great.

00:34:27.690 --> 00:34:31.380
All right, so we're going
to cover a few remaining

00:34:31.380 --> 00:34:35.150
miscellaneous items. Page
visibility, I mentioned

00:34:35.150 --> 00:34:37.790
request animation frame and how
you can be a good citizen

00:34:37.790 --> 00:34:41.170
by using that and allowing the
browser to not call your code

00:34:41.170 --> 00:34:42.880
when you're not visible.

00:34:42.880 --> 00:34:45.820
That's not necessarily the only
hook that you're going to

00:34:45.820 --> 00:34:47.190
have for doing processing
work.

00:34:47.190 --> 00:34:49.409
You might be doing other
processing on a timer, or on a

00:34:49.409 --> 00:34:51.210
background thread,
for example.

00:34:51.210 --> 00:34:55.580
The Page Visibility API gives
you a direct notification that

00:34:55.580 --> 00:35:00.720
you can check for, is this
tab visible or not?

00:35:00.720 --> 00:35:05.590
Also, IndexDB, this is
one of many local

00:35:05.590 --> 00:35:09.370
storage options in HTML5.

00:35:09.370 --> 00:35:12.680
For game developers, the File
System API is going to be very

00:35:12.680 --> 00:35:15.280
relevant because files and
directories are a very good

00:35:15.280 --> 00:35:16.660
way to manage assets.

00:35:16.660 --> 00:35:19.890
You can cache them locally,
et cetera.

00:35:19.890 --> 00:35:21.300
That is great.

00:35:21.300 --> 00:35:23.520
IndexDB has some recent
news, though.

00:35:23.520 --> 00:35:27.150
IndexDB is a little bit more
of a database approach.

00:35:27.150 --> 00:35:30.430
It does have efficient
searching, but it's not really

00:35:30.430 --> 00:35:32.020
structured in a file system.

00:35:32.020 --> 00:35:34.960
It does have fairly wide
support, though.

00:35:34.960 --> 00:35:37.580
Internet Explorer 10 is
offering support.

00:35:37.580 --> 00:35:38.570
Mozilla has support.

00:35:38.570 --> 00:35:42.230
They're adding blobs and files
into IndexDB as well.

00:35:42.230 --> 00:35:46.070
Basically, it's on all the major
browsers with the one

00:35:46.070 --> 00:35:48.880
exception of Safari so far.

00:35:48.880 --> 00:35:51.890
It is even, as well, included
on Chrome for Android.

00:35:51.890 --> 00:35:56.580
So that's good to have it
available, and it is a very

00:35:56.580 --> 00:35:59.960
good option for the broadest
support of sophisticated,

00:35:59.960 --> 00:36:02.580
local storage for your game.

00:36:02.580 --> 00:36:06.460
All right, so transitioning
out of some of the raw

00:36:06.460 --> 00:36:08.810
platform capabilities, I'm
going to talk about some

00:36:08.810 --> 00:36:10.860
language options.

00:36:10.860 --> 00:36:13.320
Everything I've shown you so
far has all been done with

00:36:13.320 --> 00:36:16.480
just straight-up JavaScript
implemented directly.

00:36:16.480 --> 00:36:20.010
But that's not the only
option available.

00:36:20.010 --> 00:36:22.730
There are two projects,
Emscripten and Mandreel that

00:36:22.730 --> 00:36:24.690
are interesting in that
they use LLVM.

00:36:24.690 --> 00:36:29.590
Now, LLVM, if you're not aware
of it, is basically a

00:36:29.590 --> 00:36:32.500
low-level virtual machine,
which is a misnomer.

00:36:32.500 --> 00:36:37.000
It's more of a cross-compiler
or compiler middle-end that

00:36:37.000 --> 00:36:39.210
can do optimization work.

00:36:39.210 --> 00:36:41.180
It can have multiple front-ends,
for example,

00:36:41.180 --> 00:36:47.550
GCC-based, so you can read in
source code from C, C++, C#,

00:36:47.550 --> 00:36:50.950
and others, and bring it
into this compiler.

00:36:50.950 --> 00:36:53.090
It can do optimization work,
and it can have different

00:36:53.090 --> 00:36:54.660
back-ends as well.

00:36:54.660 --> 00:36:57.790
So Emscripten and Mandreel
output to

00:36:57.790 --> 00:36:59.890
JavaScript as a back-end.

00:36:59.890 --> 00:37:02.570
The JavaScript they generate
isn't really human readable.

00:37:02.570 --> 00:37:06.360
It's essentially a
byte code format.

00:37:06.360 --> 00:37:10.170
That is interesting because it
provides access to large code

00:37:10.170 --> 00:37:12.850
bases that are implemented in
these other languages and

00:37:12.850 --> 00:37:14.790
bring them over to JavaScript.

00:37:14.790 --> 00:37:17.580
It's also interesting because
those other languages have,

00:37:17.580 --> 00:37:21.750
perhaps, more strongly typed
scenarios or don't have

00:37:21.750 --> 00:37:23.690
concepts of garbage
collection.

00:37:23.690 --> 00:37:26.260
When they're implemented through
this technology on the

00:37:26.260 --> 00:37:30.280
back-end, you end up
treating large

00:37:30.280 --> 00:37:31.970
arrays as memory directly.

00:37:31.970 --> 00:37:34.870
And it can significantly reduce
pressure on the garbage

00:37:34.870 --> 00:37:39.440
collection system inside
JavaScript virtual machines.

00:37:39.440 --> 00:37:42.720
So Emscripten is an open
source project.

00:37:42.720 --> 00:37:46.520
But I mentioned Mandreel
because, although it is a

00:37:46.520 --> 00:37:50.410
proprietary solution, it has
some really interesting demos

00:37:50.410 --> 00:37:52.510
and games that have been
ported onto it.

00:37:52.510 --> 00:37:57.906
So I want to show you this one,
GT Racing Motor Academy.

00:37:57.906 --> 00:37:59.403
[ENGINES REVVING]

00:37:59.403 --> 00:38:06.389
This was initially made
available on iOS, and here is

00:38:06.389 --> 00:38:10.370
running in JavaScript with
WebGL, Web Audio API.

00:38:12.970 --> 00:38:17.300
It's using the HTML5 storage
options to cache assets.

00:38:17.300 --> 00:38:20.110
So if users return to the
application later, they don't

00:38:20.110 --> 00:38:21.610
have to have significant
load times.

00:38:24.550 --> 00:38:28.830
And it's just great to see the
possibility of bringing such a

00:38:28.830 --> 00:38:34.060
large library of high-quality
game content over to the web

00:38:34.060 --> 00:38:36.910
platform rapidly,
so very cool.

00:38:36.910 --> 00:38:39.620
Another thing that both
Emscripten and Mandreel do is

00:38:39.620 --> 00:38:46.440
offer basically library shims
for software packages that

00:38:46.440 --> 00:38:48.780
original applications might
have been using.

00:38:48.780 --> 00:38:53.610
For example, if you were using
OpenGL ES 1.1 or 2.0 in your

00:38:53.610 --> 00:38:57.820
C++ code, when you convert
them using these tools,

00:38:57.820 --> 00:39:02.550
they're converted for you
automatically onto WebGL.

00:39:02.550 --> 00:39:04.460
All right, so that gets you
from a lot of languages.

00:39:04.460 --> 00:39:07.660
There's another project worth
pointing out called PlayN.

00:39:07.660 --> 00:39:12.680
PlayN is built on top of
the Google Web Toolkit.

00:39:12.680 --> 00:39:17.370
And it allows you to take large
Java applications and

00:39:17.370 --> 00:39:19.980
port them onto JavaScript
as well.

00:39:19.980 --> 00:39:23.195
PlayN can support multiple
targets, but JavaScript is the

00:39:23.195 --> 00:39:25.830
one of interest to
me right now.

00:39:25.830 --> 00:39:28.890
Angry Birds is a good example of
a commercial game that has

00:39:28.890 --> 00:39:30.630
used this technology.

00:39:30.630 --> 00:39:32.620
PlayN includes a little bit
more than just language

00:39:32.620 --> 00:39:33.190
conversion.

00:39:33.190 --> 00:39:36.600
It does also have a framework
that is utilized and then

00:39:36.600 --> 00:39:39.860
ported onto those multiple
targets.

00:39:39.860 --> 00:39:43.480
So that being said, those are
the options to convert or

00:39:43.480 --> 00:39:46.990
transcode your games
onto JavaScript.

00:39:46.990 --> 00:39:49.400
But there's another option
available as well.

00:39:49.400 --> 00:39:52.130
There's an open source project
called Native Client.

00:39:52.130 --> 00:39:53.480
It is done by Google.

00:39:53.480 --> 00:39:57.020
And its goal is to allow you
to take native applications

00:39:57.020 --> 00:40:00.310
and deploy them safely and
securely on the web.

00:40:00.310 --> 00:40:02.760
Today, when you browse on the
internet, you download

00:40:02.760 --> 00:40:05.560
JavaScript code all
the time, and it's

00:40:05.560 --> 00:40:06.740
running in your browser.

00:40:06.740 --> 00:40:09.240
And you trust that it
can't harm you.

00:40:09.240 --> 00:40:12.200
If you just downloaded
executable files onto your

00:40:12.200 --> 00:40:15.310
computer, you wouldn't have the
same level of reassurance.

00:40:15.310 --> 00:40:18.280
Native Client is a sandboxing
technology that lets you get

00:40:18.280 --> 00:40:19.990
very close to that, though.

00:40:19.990 --> 00:40:24.100
It downloads code in machine
format and does a very

00:40:24.100 --> 00:40:28.020
efficient static analysis to
ensure that it will conform to

00:40:28.020 --> 00:40:32.270
the sandboxing rules that
Native Client enforces.

00:40:32.270 --> 00:40:35.400
This means that code can be very
high performance because

00:40:35.400 --> 00:40:39.320
it can be optimized, for
example, from C++ and run in

00:40:39.320 --> 00:40:42.860
machine code without going
through a virtual machine.

00:40:42.860 --> 00:40:45.820
So it's been shipping in
Chrome since last fall.

00:40:45.820 --> 00:40:49.650
And it supports C, C++,
C#, and others.

00:40:49.650 --> 00:40:52.080
It has a lot of games that have
already shipped, or are

00:40:52.080 --> 00:40:53.630
shipping soon on it.

00:40:53.630 --> 00:40:58.360
Some examples include Bastion,
Mini Ninjas, Moon Breakers,

00:40:58.360 --> 00:41:02.600
some MMOs, Pocket Legends and
Star Legends, Cordy, Muffin

00:41:02.600 --> 00:41:04.220
Knight, AirMech, et cetera.

00:41:04.220 --> 00:41:07.910
Some cool things coming in the
future, Dark Legends, From

00:41:07.910 --> 00:41:10.400
Dust, and more.

00:41:10.400 --> 00:41:15.640
So I'm going to show you
a demo of AirMech,

00:41:15.640 --> 00:41:16.890
which is kind of cool.

00:41:19.500 --> 00:41:23.760
All right, so this is basically
an RTS-style game.

00:41:23.760 --> 00:41:30.812
I can move units around, drop
them off, get into dog fights.

00:41:30.812 --> 00:41:36.096
And because it's AirMech, of
course, I'm also a mech.

00:41:36.096 --> 00:41:38.770
I can land and engage
in combat.

00:41:38.770 --> 00:41:48.960
[BATTLE SOUNDS]

00:41:48.960 --> 00:41:52.670
So Native Client, I
think, is awesome.

00:41:52.670 --> 00:41:55.930
It brings really high-quality
games from these other

00:41:55.930 --> 00:41:58.140
languages at a very
high performance

00:41:58.140 --> 00:41:59.790
onto the web platform.

00:41:59.790 --> 00:42:02.620
And it really opens up your
options for what technologies

00:42:02.620 --> 00:42:03.530
you're going to use.

00:42:03.530 --> 00:42:06.390
As a game developer from the
middleware industry, I was

00:42:06.390 --> 00:42:09.100
aware of a large amount of
awesome options that can get

00:42:09.100 --> 00:42:10.630
developers producing
the high-quality

00:42:10.630 --> 00:42:12.430
games they want faster.

00:42:12.430 --> 00:42:14.960
Well, a lot of high-quality
middleware solutions have

00:42:14.960 --> 00:42:17.050
signed up for Native
Client as well.

00:42:17.050 --> 00:42:22.090
They include Havok, Unity,
FMOD, Wwise, SDL, Bullet

00:42:22.090 --> 00:42:25.390
Physics, BlitzTech, and
Ogre, among others,

00:42:25.390 --> 00:42:28.500
so very cool stuff.

00:42:28.500 --> 00:42:31.960
All right, so just a few more
things to talk about that are

00:42:31.960 --> 00:42:34.760
a little bit more
in the future.

00:42:34.760 --> 00:42:38.140
Device discovery, I mentioned
in audio it'd be great to

00:42:38.140 --> 00:42:40.570
know, hey, what's connected
to this computer?

00:42:40.570 --> 00:42:42.810
But from your controls,
it would be, too.

00:42:42.810 --> 00:42:45.570
Does this computer have a
touch pad or a mouse?

00:42:45.570 --> 00:42:47.710
It's going to change how I want
you to interact with it.

00:42:47.710 --> 00:42:51.390
Maybe it's a touch-based
device.

00:42:51.390 --> 00:42:52.770
What's the general performance

00:42:52.770 --> 00:42:54.900
characteristic of this machine?

00:42:54.900 --> 00:42:59.150
Am I on a phone, or a tablet, a
netbook, a high-end laptop,

00:42:59.150 --> 00:43:02.100
a workstation, or an
awesome gaming rig?

00:43:02.100 --> 00:43:04.770
I will send different assets
down from the server based on

00:43:04.770 --> 00:43:07.760
the general performance
of this platform.

00:43:07.760 --> 00:43:10.520
These bring challenges, though,
for privacy of users.

00:43:10.520 --> 00:43:13.220
If you're not familiar with the
fingerprinting concept,

00:43:13.220 --> 00:43:15.360
it's something we have to
be concerned about.

00:43:15.360 --> 00:43:17.950
When a user browses the internet
with a web browser,

00:43:17.950 --> 00:43:23.700
they expect a certain level
of being anonymous.

00:43:23.700 --> 00:43:28.030
And the more information a web
page can just pull about a

00:43:28.030 --> 00:43:30.680
user, the more of a fingerprint
they can build up

00:43:30.680 --> 00:43:35.270
and uniquely identify that user,
which is not desired.

00:43:35.270 --> 00:43:37.260
Another thing we could use
on the platform is better

00:43:37.260 --> 00:43:38.380
time-handling.

00:43:38.380 --> 00:43:44.250
So examples include, right now,
you can call newDate, and

00:43:44.250 --> 00:43:47.400
you can get the time, but only
up to one millisecond.

00:43:47.400 --> 00:43:49.760
So one millisecond is pretty
granular when you're dealing

00:43:49.760 --> 00:43:51.880
with a game trying to
run at about 16

00:43:51.880 --> 00:43:54.140
milliseconds per frame.

00:43:54.140 --> 00:43:57.490
Chrome has a command line flag,
EnableBenchmarking, that

00:43:57.490 --> 00:44:01.120
allows you to get microseconds
and could be great, especially

00:44:01.120 --> 00:44:03.750
in the profiling nature
of your game.

00:44:03.750 --> 00:44:06.630
The other issue with time that
we have is when time stamps

00:44:06.630 --> 00:44:10.340
are applied and the latency
related to that.

00:44:10.340 --> 00:44:13.520
So for example, in Chrome, when
a button pressed on a

00:44:13.520 --> 00:44:17.820
gamepad or when the mouse is
moved, those events are

00:44:17.820 --> 00:44:22.610
eventually dispatched to
you via Webkit code.

00:44:22.610 --> 00:44:25.720
And the time stamp given to
those events is the time stamp

00:44:25.720 --> 00:44:28.450
that we got to dispatching
them in WebKit, but not

00:44:28.450 --> 00:44:32.070
necessarily when the operating
system actually informed us at

00:44:32.070 --> 00:44:33.230
the browser level.

00:44:33.230 --> 00:44:36.740
So there can be latency there
that is made even worse-- for

00:44:36.740 --> 00:44:39.995
example, if we're waiting with
requestAnimationFrame before

00:44:39.995 --> 00:44:41.990
we're delivering
certain events.

00:44:41.990 --> 00:44:45.750
So it would be good to mark the
actual time on events with

00:44:45.750 --> 00:44:48.210
the closest value we can
get to the time that

00:44:48.210 --> 00:44:50.450
they actually happened.

00:44:50.450 --> 00:44:52.390
And I work on Pointer Lock.

00:44:52.390 --> 00:44:54.440
There's some other kinds of
lock that would be great.

00:44:54.440 --> 00:44:56.560
For example, Keyboard
Lock is a good one.

00:44:56.560 --> 00:44:59.040
In a first-person shooter, if
I want to crouch and walk

00:44:59.040 --> 00:45:02.710
forward, I'm probably going to
press Control-W instinctively.

00:45:02.710 --> 00:45:04.840
The bad news is, in a lot of
browsers, that's going to

00:45:04.840 --> 00:45:06.170
close the current tab.

00:45:06.170 --> 00:45:08.900
And that's not what I wanted
to have happen.

00:45:08.900 --> 00:45:10.500
Another thing we could
do is Orientation

00:45:10.500 --> 00:45:12.510
Lock on a mobile phone.

00:45:12.510 --> 00:45:15.900
If I want a game that is using
accelerometers, I want to be

00:45:15.900 --> 00:45:18.530
moving it left and right, I
don't want it to reflow

00:45:18.530 --> 00:45:21.270
between portrait mode and
landscape mode just because

00:45:21.270 --> 00:45:22.450
I'm changing the orientation.

00:45:22.450 --> 00:45:26.770
I want to lock that down
and not have it change.

00:45:26.770 --> 00:45:30.520
All right, so let's wrap up
a little bit with a quick

00:45:30.520 --> 00:45:33.560
discussion about apps
and stores.

00:45:33.560 --> 00:45:36.480
Chrome has been offering an
application store for a little

00:45:36.480 --> 00:45:39.620
while now, inspired by the
success of a lot of the mobile

00:45:39.620 --> 00:45:42.900
platforms where users are
getting very familiar with the

00:45:42.900 --> 00:45:45.640
concept of an app, giving the
app a certain amount of

00:45:45.640 --> 00:45:50.060
permission, and using that for
discovery and replayability.

00:45:50.060 --> 00:45:52.640
This is coming to other
browsers as well.

00:45:52.640 --> 00:45:55.400
Windows 8 has announced that
they're going to have a store,

00:45:55.400 --> 00:45:57.700
and it's going to host
HTML content.

00:45:57.700 --> 00:45:59.510
So that's pretty cool.

00:45:59.510 --> 00:46:03.510
Mozilla also has announced an
app marketplace, and they have

00:46:03.510 --> 00:46:06.240
another concept they've
announced called WebRT.

00:46:06.240 --> 00:46:09.480
The WebRT is for Web Run Time,
and the goal there is to allow

00:46:09.480 --> 00:46:12.310
applications to get as close
as possible to having a

00:46:12.310 --> 00:46:13.510
native-like feel.

00:46:13.510 --> 00:46:16.710
They should have nice icons that
look just like any other

00:46:16.710 --> 00:46:20.610
icon, and they should have more
availability to APIs that

00:46:20.610 --> 00:46:23.970
are native on the system that
they're running on.

00:46:23.970 --> 00:46:26.670
All right, we're going to
transition over to just a

00:46:26.670 --> 00:46:29.360
quick summary of the
state of browsers.

00:46:29.360 --> 00:46:33.740
Desktop share right now is
really dominated by the top

00:46:33.740 --> 00:46:37.680
three of Internet Explorer,
Chrome, and Firefox.

00:46:37.680 --> 00:46:41.350
And on the mobile space, still
really just three strong

00:46:41.350 --> 00:46:45.950
leaders, Opera, Android,
and Safari.

00:46:45.950 --> 00:46:48.860
A little bit of mobile
news, Firefox has a

00:46:48.860 --> 00:46:50.050
beta version available.

00:46:50.050 --> 00:46:52.870
And Chrome recently announced
a beta version available on

00:46:52.870 --> 00:46:54.030
Android as well.

00:46:54.030 --> 00:46:56.280
So very cool, worth checking
those out and

00:46:56.280 --> 00:46:57.680
seeing how they perform.

00:46:57.680 --> 00:47:01.370
They bring a lot of HTML5 and a
lot of these standards that

00:47:01.370 --> 00:47:04.950
I've been talking about onto
the mobile platform.

00:47:04.950 --> 00:47:09.600
Also, IE10, Internet Explorer
has been doing great things in

00:47:09.600 --> 00:47:11.800
catching up to HTML5.

00:47:11.800 --> 00:47:15.520
Some other recent news, I
already mentioned IndexDB, Web

00:47:15.520 --> 00:47:17.550
Workers and Web Sockets.

00:47:17.550 --> 00:47:22.430
They also will be bringing CSS3
3D transformations and

00:47:22.430 --> 00:47:23.680
also animations.

00:47:23.680 --> 00:47:26.680
So, good to see that
there as well.

00:47:26.680 --> 00:47:28.850
So let's wrap up.

00:47:28.850 --> 00:47:32.320
I really hope that you saw some
tech that inspired you,

00:47:32.320 --> 00:47:35.350
and that if you have any
problems or any concerns about

00:47:35.350 --> 00:47:37.110
where we're going in the
future, that you will

00:47:37.110 --> 00:47:38.630
participate.

00:47:38.630 --> 00:47:41.630
The easiest way for you to do
that is to come to the W3C

00:47:41.630 --> 00:47:42.940
games group.

00:47:42.940 --> 00:47:44.500
This group doesn't perform any

00:47:44.500 --> 00:47:46.390
standardization work in itself.

00:47:46.390 --> 00:47:49.180
However, it's a meeting point
for everyone with the common

00:47:49.180 --> 00:47:52.130
interest of making sure that the
open web platform supports

00:47:52.130 --> 00:47:55.580
games as well as it can.

00:47:55.580 --> 00:47:58.050
And they understand the context
and other working

00:47:58.050 --> 00:48:00.530
groups where standards actually
are being developed.

00:48:00.530 --> 00:48:02.530
So come there.

00:48:02.530 --> 00:48:03.460
Communicate with people.

00:48:03.460 --> 00:48:06.880
Let us know your needs, and we
can get you into the right

00:48:06.880 --> 00:48:10.180
direction for communicating
with the people developing

00:48:10.180 --> 00:48:14.150
specifications as we move
the platform forward.

00:48:14.150 --> 00:48:18.550
And with that, I'll say
thank you very much.

00:48:18.550 --> 00:48:21.220
There are notes from this
presentation available at the

00:48:21.220 --> 00:48:22.320
link I have here.

00:48:22.320 --> 00:48:25.110
So all of the demos that I
showed, the command line

00:48:25.110 --> 00:48:28.200
switches that I mentioned, they
can all be found in the

00:48:28.200 --> 00:48:29.460
presentation notes.

00:48:29.460 --> 00:48:30.710
Thank you very much.

