WEBVTT
Kind: captions
Language: en

00:00:00.600 --> 00:00:03.560
DAN SANDERSON: All right.

00:00:03.560 --> 00:00:04.280
Let's get started.

00:00:04.280 --> 00:00:07.500
It is 1:40.

00:00:07.500 --> 00:00:10.460
This is "Building
developers.google.com on

00:00:10.460 --> 00:00:12.370
Google App Engine." This
is an App Engine talk.

00:00:12.370 --> 00:00:14.320
Make sure you're in
the right place.

00:00:14.320 --> 00:00:15.190
I'm Dan Sanderson.

00:00:15.190 --> 00:00:17.700
I'm a developer programs
engineer at Google.

00:00:17.700 --> 00:00:20.250
I've been at Google for about
six and a half years.

00:00:20.250 --> 00:00:22.880
I worked on the App Engine team
for a few years, from

00:00:22.880 --> 00:00:24.770
2008 to 2011.

00:00:24.770 --> 00:00:26.990
And since 2011, I've been
working on the Google

00:00:26.990 --> 00:00:27.890
Developers website.

00:00:27.890 --> 00:00:29.316
That's developers.google.com.

00:00:29.316 --> 00:00:32.100
How many of you have seen the
Google Developers website?

00:00:32.100 --> 00:00:32.460
Excellent.

00:00:32.460 --> 00:00:33.580
I thought so.

00:00:33.580 --> 00:00:36.020
I've also written this book,
"Programming Google App

00:00:36.020 --> 00:00:37.800
Engine," published by O'Reilly,
currently in its

00:00:37.800 --> 00:00:38.420
second edition.

00:00:38.420 --> 00:00:40.480
The second edition came
out last October.

00:00:40.480 --> 00:00:43.300
I hope you get a chance to
take a look at that.

00:00:43.300 --> 00:00:45.460
I want to talk about Google
Developers today.

00:00:45.460 --> 00:00:48.920
The Google Developers website is
an App Engine application.

00:00:48.920 --> 00:00:49.980
It's written in Python.

00:00:49.980 --> 00:00:54.285
In the last two years, from 2011
to today, we've built out

00:00:54.285 --> 00:00:55.710
a website with a bunch of
different features.

00:00:55.710 --> 00:00:58.580
We have a content management
system that hosts all the

00:00:58.580 --> 00:01:00.980
technical documentation
that's on the website.

00:01:00.980 --> 00:01:03.690
We have an events calendar, the
developer showcase, the

00:01:03.690 --> 00:01:06.370
Google Developer Groups
homepages, Google Developers

00:01:06.370 --> 00:01:08.570
Live, with all the live
streaming video, and of

00:01:08.570 --> 00:01:12.030
course, the Google
I/O website.

00:01:12.030 --> 00:01:14.230
I want to talk about
how we built this

00:01:14.230 --> 00:01:15.270
website on App Engine.

00:01:15.270 --> 00:01:16.510
But I want it to get
pretty specific.

00:01:16.510 --> 00:01:18.610
I want to talk about the
App Engine details.

00:01:18.610 --> 00:01:20.030
And so I'm going to
focus on a very

00:01:20.030 --> 00:01:21.940
specific part of the website.

00:01:21.940 --> 00:01:23.800
We're going to talk about just
a piece of the content

00:01:23.800 --> 00:01:24.520
management system.

00:01:24.520 --> 00:01:26.715
Of course, content management
has a bunch of

00:01:26.715 --> 00:01:27.820
different parts to it--

00:01:27.820 --> 00:01:30.180
the static content build,
publishing workflows, that

00:01:30.180 --> 00:01:31.300
sort of thing.

00:01:31.300 --> 00:01:33.690
But I want to talk about kind
of the App-Engine-specific

00:01:33.690 --> 00:01:34.300
parts of that.

00:01:34.300 --> 00:01:36.340
So we're going to just take
a part of that and

00:01:36.340 --> 00:01:37.440
talk about it today.

00:01:37.440 --> 00:01:39.510
The design that I want to talk
about is the design we

00:01:39.510 --> 00:01:40.630
actually use.

00:01:40.630 --> 00:01:42.910
It's a pretty straightforward
design pattern you've probably

00:01:42.910 --> 00:01:43.870
seen before.

00:01:43.870 --> 00:01:44.770
And we'll talk about
how that gets

00:01:44.770 --> 00:01:46.840
implemented on App Engine.

00:01:46.840 --> 00:01:51.120
And I'm going to focus on the
App Engine-y bits with regards

00:01:51.120 --> 00:01:54.010
to the implementation so we
don't get distracted by other

00:01:54.010 --> 00:01:54.340
parts of it.

00:01:54.340 --> 00:01:56.530
If you have any questions about
anything that I haven't

00:01:56.530 --> 00:01:58.700
talked about, feel free to
find me later, and we

00:01:58.700 --> 00:01:59.230
can talk about it.

00:01:59.230 --> 00:02:02.620
I'm happy to talk about
the implementation.

00:02:02.620 --> 00:02:05.020
We'll also talk about how this
is implemented, what tools we

00:02:05.020 --> 00:02:06.950
use, what libraries we use.

00:02:06.950 --> 00:02:10.259
And here, I'm a little
bit conflicted.

00:02:10.259 --> 00:02:13.020
We have been working on this
website for a couple of years.

00:02:13.020 --> 00:02:14.940
And App Engine has changed
quite a bit in

00:02:14.940 --> 00:02:15.860
the last two years.

00:02:15.860 --> 00:02:18.580
There are quite a few new tools,
libraries, and services

00:02:18.580 --> 00:02:20.830
that have changed some of the
best practices on how you

00:02:20.830 --> 00:02:22.730
actually build these things
with App Engine.

00:02:22.730 --> 00:02:25.840
So many of the things we
actually do with real code are

00:02:25.840 --> 00:02:28.130
a little bit out of date in
terms of best practices.

00:02:28.130 --> 00:02:29.770
I would love to just show
you the real thing,

00:02:29.770 --> 00:02:31.190
the real-world code--

00:02:31.190 --> 00:02:31.780
it's messy.

00:02:31.780 --> 00:02:32.820
It's long.

00:02:32.820 --> 00:02:35.600
But it's also been tested
and runs the real thing.

00:02:35.600 --> 00:02:37.730
But I think I would be doing
a disservice if I didn't

00:02:37.730 --> 00:02:39.585
acknowledge the new libraries
and tools

00:02:39.585 --> 00:02:40.440
that have been developed.

00:02:40.440 --> 00:02:42.040
So we're going to take a hybrid

00:02:42.040 --> 00:02:43.160
approach with this talk.

00:02:43.160 --> 00:02:45.500
And we're going to take the
design I actually use, but

00:02:45.500 --> 00:02:46.435
we'll use a modern
implementation.

00:02:46.435 --> 00:02:48.770
We'll talk about how to build
it with the modern stuff.

00:02:48.770 --> 00:02:51.910
We'll use examples in Python.

00:02:51.910 --> 00:02:54.870
And I'll try to call out
discrepancies between the real

00:02:54.870 --> 00:02:57.420
implementation and what I'm
talking about as I have time.

00:02:57.420 --> 00:02:58.850
Again, if you have questions--

00:02:58.850 --> 00:03:01.356
more about like what we actually
do and the sort of

00:03:01.356 --> 00:03:02.180
hairy details--

00:03:02.180 --> 00:03:03.450
just let me know.

00:03:03.450 --> 00:03:05.550
And I'll try to call out
alternative designs as we can.

00:03:05.550 --> 00:03:07.150
But we have a lot of material
to go through.

00:03:07.150 --> 00:03:10.060
So I'm probably going to be
rushing through a lot of it.

00:03:10.060 --> 00:03:12.250
So let's sketch out a content
management system just

00:03:12.250 --> 00:03:13.780
to work with here.

00:03:13.780 --> 00:03:16.380
We want the content managed
separately from other parts of

00:03:16.380 --> 00:03:16.850
the website.

00:03:16.850 --> 00:03:19.300
That's kind of what a content
management system means, is

00:03:19.300 --> 00:03:20.990
that there's other stuff going
on on the website.

00:03:20.990 --> 00:03:22.880
So this is software built
into the app.

00:03:22.880 --> 00:03:25.750
And content publishers, content
developers, are going

00:03:25.750 --> 00:03:28.940
to be interacting with the
software to get the content

00:03:28.940 --> 00:03:29.960
onto the website.

00:03:29.960 --> 00:03:32.310
This is going to be
a file-based CMS.

00:03:32.310 --> 00:03:34.250
A lot of people, when they think
of CMS, they think of

00:03:34.250 --> 00:03:37.450
editing text in text areas
in a web form.

00:03:37.450 --> 00:03:39.750
For technical documentation,
we have content developers

00:03:39.750 --> 00:03:42.420
that are editing lots of
different files with lots of

00:03:42.420 --> 00:03:43.440
regular structure.

00:03:43.440 --> 00:03:45.870
And so they're going to be using
local files for that and

00:03:45.870 --> 00:03:48.650
then uploading them to the
website using a client tool.

00:03:48.650 --> 00:03:50.600
So there's going to be a
client-server interaction in

00:03:50.600 --> 00:03:53.570
this design.

00:03:53.570 --> 00:03:55.950
Content developers are making a
lot of changes all at once.

00:03:55.950 --> 00:03:58.460
Basically, they're
developing--

00:03:58.460 --> 00:04:00.950
writing the content for a new
release of a new feature, and

00:04:00.950 --> 00:04:02.380
then they want all of
it to go up at once.

00:04:02.380 --> 00:04:05.360
They have a lot of changes to
represent, potentially over

00:04:05.360 --> 00:04:09.090
many files, possibly hundreds
or even thousands of files.

00:04:09.090 --> 00:04:11.010
We don't want just anyone
publishing to our website.

00:04:11.010 --> 00:04:12.560
So of course, we have access
controls for this

00:04:12.560 --> 00:04:14.010
client-server interaction.

00:04:14.010 --> 00:04:15.950
When we think about the design,
we're going to try to

00:04:15.950 --> 00:04:17.300
accommodate fast file serving.

00:04:17.300 --> 00:04:18.529
Obviously, that's
just a general

00:04:18.529 --> 00:04:19.760
requirement that we want.

00:04:19.760 --> 00:04:21.550
But we're going to need to think
about that when we do

00:04:21.550 --> 00:04:24.430
our data modeling and
things like that.

00:04:24.430 --> 00:04:28.050
Most importantly, the usage
model here is we have many

00:04:28.050 --> 00:04:30.290
content developers working on
different parts of the website

00:04:30.290 --> 00:04:30.850
concurrently.

00:04:30.850 --> 00:04:33.580
So we're going to need to
accommodate that as we work

00:04:33.580 --> 00:04:35.490
through this.

00:04:35.490 --> 00:04:39.160
So if we just imagine a client
of some kind, let's say a

00:04:39.160 --> 00:04:41.260
command line tool that's
passed a set of files.

00:04:41.260 --> 00:04:44.090
I've got my files on my desktop,
and I want to get

00:04:44.090 --> 00:04:44.830
them to the website.

00:04:44.830 --> 00:04:46.670
So let's just start with here.

00:04:46.670 --> 00:04:47.700
I've got a Publish command.

00:04:47.700 --> 00:04:49.530
And I want this Publish command
to get these files

00:04:49.530 --> 00:04:50.450
onto the website.

00:04:50.450 --> 00:04:52.750
Well, we've got a client-server
interaction.

00:04:52.750 --> 00:04:54.100
Why don't we just do this?

00:04:54.100 --> 00:04:56.540
The client tool uploads the
files to the server.

00:04:56.540 --> 00:04:57.670
It could do it one at a time.

00:04:57.670 --> 00:05:00.480
It can call an upload endpoint
on the server.

00:05:00.480 --> 00:05:02.660
And then the server takes those
things and puts them on

00:05:02.660 --> 00:05:03.370
the website.

00:05:03.370 --> 00:05:06.860
The payload would just be a URL
path and a content type

00:05:06.860 --> 00:05:07.620
and the data block.

00:05:07.620 --> 00:05:09.850
And then the server installs
it so that when people come

00:05:09.850 --> 00:05:13.000
and ask for that URL path, they
serve that data with that

00:05:13.000 --> 00:05:13.790
content type.

00:05:13.790 --> 00:05:15.780
I'll wave my hand over the part
where the client figures

00:05:15.780 --> 00:05:18.090
out what the URL path and
the content type are.

00:05:18.090 --> 00:05:20.290
You can imagine different
ways of doing that.

00:05:20.290 --> 00:05:23.260
Internally, we just use
directory structure

00:05:23.260 --> 00:05:26.100
conventions for that in our
revision control repository to

00:05:26.100 --> 00:05:29.570
figure out what the
content root is.

00:05:29.570 --> 00:05:30.480
So this is great, actually.

00:05:30.480 --> 00:05:31.940
This gets us most of what
we want, right?

00:05:31.940 --> 00:05:33.350
We can get files onto
the website.

00:05:33.350 --> 00:05:34.770
We can create new paths.

00:05:34.770 --> 00:05:37.190
We can update existing paths.

00:05:37.190 --> 00:05:39.750
Now, usually with data, you
want to do a third thing.

00:05:39.750 --> 00:05:40.410
You've got Create.

00:05:40.410 --> 00:05:41.360
You've got Update.

00:05:41.360 --> 00:05:43.090
And of course, we are going to
want to be able to delete

00:05:43.090 --> 00:05:43.720
paths as well.

00:05:43.720 --> 00:05:46.260
You can imagine that maybe the
client can just issue Delete

00:05:46.260 --> 00:05:48.370
commands in addition
to Upload commands.

00:05:48.370 --> 00:05:50.460
But that would require that
the client has to maintain

00:05:50.460 --> 00:05:53.030
some kind of internal notion
of what is on the server.

00:05:53.030 --> 00:05:55.120
It has to know what to delete
in order to do that.

00:05:55.120 --> 00:05:57.330
And that's a lot of work and
can get kind of messy.

00:05:57.330 --> 00:05:59.320
So the client knows
what it has.

00:05:59.320 --> 00:06:00.790
The server knows what it has.

00:06:00.790 --> 00:06:02.320
Why don't we just make the
server do the work?

00:06:02.320 --> 00:06:04.510
So the client just needs to
say, this is what I have.

00:06:04.510 --> 00:06:06.280
Do what is necessary.

00:06:06.280 --> 00:06:09.070
And so we'll just add a new
request in here, a new call.

00:06:09.070 --> 00:06:09.840
It's a Start call.

00:06:09.840 --> 00:06:12.620
It says, OK, this
is what I have.

00:06:12.620 --> 00:06:13.560
Please do what you need to do.

00:06:13.560 --> 00:06:15.170
And also, these are the
files I'm uploading.

00:06:15.170 --> 00:06:17.530
So this is the client's
opportunity to say that.

00:06:17.530 --> 00:06:19.320
And then the server can turn
around and figure out what it

00:06:19.320 --> 00:06:19.750
needs to do.

00:06:19.750 --> 00:06:22.660
Now, each content developer is
working on a different part of

00:06:22.660 --> 00:06:23.500
the website.

00:06:23.500 --> 00:06:26.040
So they're probably not going
to have a complete view,

00:06:26.040 --> 00:06:28.960
up-to-date view of the entire
website in their local files.

00:06:28.960 --> 00:06:31.940
So it's not quite sufficient
to say, this is what I have

00:06:31.940 --> 00:06:32.930
for the entire website.

00:06:32.930 --> 00:06:34.390
Do what's necessary.

00:06:34.390 --> 00:06:35.820
So we have a notion
of projects.

00:06:35.820 --> 00:06:37.490
And in this case, projects
are just subpaths.

00:06:37.490 --> 00:06:40.230
So if I'm a content developer
working on, say, the App

00:06:40.230 --> 00:06:42.490
Engine documentation,
I've got local files

00:06:42.490 --> 00:06:44.070
under slash App Engine.

00:06:44.070 --> 00:06:46.830
And I have a complete up-to-date
view of what App

00:06:46.830 --> 00:06:47.880
Engine Docs look like.

00:06:47.880 --> 00:06:49.120
And that's what I
want to upload.

00:06:49.120 --> 00:06:51.880
So our protocol, the Start
Request says, this is the

00:06:51.880 --> 00:06:52.800
project that I'm working on.

00:06:52.800 --> 00:06:54.020
These are the project roots.

00:06:54.020 --> 00:06:56.300
And these are the files that I
have in this project root.

00:06:56.300 --> 00:06:57.410
Please do the right thing.

00:06:57.410 --> 00:06:59.980
Then the server says, oh, you've
got A, B, and D. Well,

00:06:59.980 --> 00:07:02.530
I've got A, B, and C. So I guess
I should be deleting C

00:07:02.530 --> 00:07:06.650
and you'll be giving me the
uploads for A, B, and D later.

00:07:06.650 --> 00:07:07.190
So great.

00:07:07.190 --> 00:07:10.770
We've got a way to synchronize
the state of the client onto

00:07:10.770 --> 00:07:12.110
the server.

00:07:12.110 --> 00:07:14.680
I'm not entirely happy with this
diagram, mostly because

00:07:14.680 --> 00:07:16.880
the client's doing a lot
of the driving here.

00:07:16.880 --> 00:07:19.360
It's trying to get everything
onto the website.

00:07:19.360 --> 00:07:21.890
And of course, if the client
gets interrupted, there's

00:07:21.890 --> 00:07:23.920
going to be a problem, or at
least a problem by our

00:07:23.920 --> 00:07:25.170
definition.

00:07:25.170 --> 00:07:28.250
We decided that as a requirement
for us, we don't

00:07:28.250 --> 00:07:30.830
want this state where you can
leave the server in an

00:07:30.830 --> 00:07:31.550
inconsistent state.

00:07:31.550 --> 00:07:33.990
If the server is just going to
start doing stuff with the

00:07:33.990 --> 00:07:37.080
live website, with the live
data, as the client is issuing

00:07:37.080 --> 00:07:39.460
these requests, then if the
client gets interrupted, it

00:07:39.460 --> 00:07:41.780
could get this inconsistent
state, this incomplete version

00:07:41.780 --> 00:07:42.350
of the website.

00:07:42.350 --> 00:07:43.400
So we don't want that.

00:07:43.400 --> 00:07:46.060
What we want is a notion of
transactionality for these

00:07:46.060 --> 00:07:46.790
publish events.

00:07:46.790 --> 00:07:49.900
Either the publish event
happens or it doesn't.

00:07:49.900 --> 00:07:52.310
That means we want either the
before state, which is if

00:07:52.310 --> 00:07:54.290
anything goes wrong on either
the client side or the server

00:07:54.290 --> 00:07:57.610
side, we want the website to
look like it did before,

00:07:57.610 --> 00:07:59.390
before we did anything to it.

00:07:59.390 --> 00:08:01.430
And then if it succeeds, it
should succeed completely.

00:08:01.430 --> 00:08:03.570
All of the changes go up.

00:08:03.570 --> 00:08:06.340
So to do that, the server needs
to know when the client

00:08:06.340 --> 00:08:08.110
has finished a complete
description of what it's

00:08:08.110 --> 00:08:08.970
talking about.

00:08:08.970 --> 00:08:10.240
So we need one more
request in here.

00:08:10.240 --> 00:08:11.640
And we'll call it Commit.

00:08:11.640 --> 00:08:14.360
The client issues a
Start Request that

00:08:14.360 --> 00:08:15.250
describes what it has.

00:08:15.250 --> 00:08:18.220
It uploads all the files,
potentially hundreds of files.

00:08:18.220 --> 00:08:20.610
And then at the end, it
says, OK, I'm done.

00:08:20.610 --> 00:08:22.010
Do what you need to do.

00:08:22.010 --> 00:08:24.990
And then the server, instead
of doing things live to the

00:08:24.990 --> 00:08:27.700
live data all along the way,
it's just going to store these

00:08:27.700 --> 00:08:28.020
things away.

00:08:28.020 --> 00:08:29.660
It's going to store away a
change in description.

00:08:29.660 --> 00:08:32.070
And it's going to store away the
things that get uploaded.

00:08:32.070 --> 00:08:34.710
And then once the Commit comes
in, then the server knows that

00:08:34.710 --> 00:08:37.530
it can start making changes
to the live website.

00:08:37.530 --> 00:08:40.299
I'm going to make one minor
modification to this diagram.

00:08:40.299 --> 00:08:41.590
I'm going to make it
look like this.

00:08:41.590 --> 00:08:44.179
App Engine makes a distinction
between user requests, which

00:08:44.179 --> 00:08:46.360
in this case, is requests
coming in from the

00:08:46.360 --> 00:08:48.660
command-line tool, and
background tasks.

00:08:48.660 --> 00:08:51.160
They're both executed in
your app instances.

00:08:51.160 --> 00:08:53.800
They're both handled by Request
Handler-like things.

00:08:53.800 --> 00:08:56.070
But user requests are expected
to return quickly.

00:08:56.070 --> 00:08:58.170
And so they have a time
limit of 60 seconds.

00:08:58.170 --> 00:08:59.680
Background tasks have
up to 10 minutes.

00:08:59.680 --> 00:09:01.910
And of course, they can spawn
other background tasks and do

00:09:01.910 --> 00:09:03.410
an arbitrary amount of work.

00:09:03.410 --> 00:09:05.145
So most of the work we're going
to do, especially if

00:09:05.145 --> 00:09:08.140
we're acting on thousands of
different files, thousands of

00:09:08.140 --> 00:09:10.130
different datastore entries or
whatever you might want to be

00:09:10.130 --> 00:09:11.910
doing, it's going
to take a while.

00:09:11.910 --> 00:09:13.836
And so we need to do it
as background work.

00:09:13.836 --> 00:09:16.260
One of the things to note here
is that each of these arrows

00:09:16.260 --> 00:09:17.580
is an opportunity for
the server to

00:09:17.580 --> 00:09:18.800
return an error code.

00:09:18.800 --> 00:09:21.920
So if anything goes wrong-- if
there's a bad request, the

00:09:21.920 --> 00:09:25.240
client made an invalid request,
or there's some kind

00:09:25.240 --> 00:09:27.410
of inconsistency or there's a
transient error on the server

00:09:27.410 --> 00:09:30.290
side-- the server can say just
bail, and say, look, client, I

00:09:30.290 --> 00:09:31.580
don't know what to
do with this.

00:09:31.580 --> 00:09:32.380
I'm bailing on this.

00:09:32.380 --> 00:09:34.510
And then the client can then
report that error code to the

00:09:34.510 --> 00:09:36.990
user, the content developer, and
see, oh, nothing is going

00:09:36.990 --> 00:09:38.870
to happen on the website
because of this.

00:09:38.870 --> 00:09:41.410
And I'm going to have to fix it
or wait for it to be fixed

00:09:41.410 --> 00:09:44.740
or file a bug report
or whatever.

00:09:44.740 --> 00:09:47.300
And so each of these is an
opportunity for the server to

00:09:47.300 --> 00:09:50.300
return an error without having
any changes going live.

00:09:50.300 --> 00:09:53.050
Nothing has changed the live
website until the very end.

00:09:53.050 --> 00:09:55.660
But the other important thing
there is that the Commit

00:09:55.660 --> 00:09:57.840
Request is the last opportunity
for the server to

00:09:57.840 --> 00:09:58.620
return an error code.

00:09:58.620 --> 00:10:01.090
So if it's going to kick off
some background work, it has

00:10:01.090 --> 00:10:02.350
to be pretty sure that
that background

00:10:02.350 --> 00:10:03.290
work is going to succeed.

00:10:03.290 --> 00:10:07.280
Once the Commit is in, the
change is committed and the

00:10:07.280 --> 00:10:10.710
client is just told, oh, OK,
the Commit is successful.

00:10:10.710 --> 00:10:11.760
I don't have to worry
about it.

00:10:11.760 --> 00:10:13.150
It will eventually go
live on the website.

00:10:13.150 --> 00:10:15.050
So we need to accommodate
that as well.

00:10:15.050 --> 00:10:17.290
So to summarize the publishing
protocol, we have a Start

00:10:17.290 --> 00:10:19.300
Request that starts a change
with the change description.

00:10:19.300 --> 00:10:20.640
We upload the files we need.

00:10:20.640 --> 00:10:22.650
And we have a Commit Request
that says, OK,

00:10:22.650 --> 00:10:23.720
this is what we need.

00:10:23.720 --> 00:10:26.400
You might want an Abort
Request in there, too.

00:10:26.400 --> 00:10:28.600
In our case, abort just
means clean up all

00:10:28.600 --> 00:10:29.560
that stuff you stored.

00:10:29.560 --> 00:10:32.410
It's not really going to impact
things to have an

00:10:32.410 --> 00:10:33.990
uncommitted change just
sitting around.

00:10:33.990 --> 00:10:35.460
It's just going to be
some extra data.

00:10:35.460 --> 00:10:36.300
But it's a nice clean up.

00:10:36.300 --> 00:10:38.460
And sometimes the client does
have the opportunity to issue

00:10:38.460 --> 00:10:39.630
an Abort Request.

00:10:39.630 --> 00:10:42.070
Of course, it doesn't always
have the opportunity to issue

00:10:42.070 --> 00:10:42.980
an Abort Request.

00:10:42.980 --> 00:10:45.180
It could be failing because
of a power outage or

00:10:45.180 --> 00:10:46.260
a bug in the client.

00:10:46.260 --> 00:10:47.780
That sometimes happens.

00:10:47.780 --> 00:10:50.580
And so it's good to have a
scheduled task, a cron job,

00:10:50.580 --> 00:10:54.110
that goes in and aborts
stale changes as well.

00:10:54.110 --> 00:10:56.070
So we've got client-server
interaction.

00:10:56.070 --> 00:10:57.520
We said we wanted it to
be authenticated.

00:10:57.520 --> 00:10:59.130
Let's talk about that part.

00:10:59.130 --> 00:11:02.260
There are a bunch of different
ways of doing authentication.

00:11:02.260 --> 00:11:05.610
App Engine has had, for a long
time, server-side capabilities

00:11:05.610 --> 00:11:09.100
to make it easy to implement
web services with OAuth for

00:11:09.100 --> 00:11:10.910
authentication.

00:11:10.910 --> 00:11:12.120
There's a new way,
though, that's--

00:11:12.120 --> 00:11:14.310
I think really cool and
really important.

00:11:14.310 --> 00:11:17.100
It makes it really easy to do
this very common thing of

00:11:17.100 --> 00:11:19.250
setting up a web service
in different ways.

00:11:19.250 --> 00:11:21.020
And it's called Google
Cloud Endpoints.

00:11:21.020 --> 00:11:23.150
The difference between writing
your own and using Google

00:11:23.150 --> 00:11:26.290
Cloud Endpoints is that you get
all of the features that

00:11:26.290 --> 00:11:29.050
normally accompany any other
Google web service, using the

00:11:29.050 --> 00:11:30.230
same infrastructure.

00:11:30.230 --> 00:11:33.020
It can apply to your web
service, whatever it may be.

00:11:33.020 --> 00:11:35.090
And you just set that up as an
App Engine application, and

00:11:35.090 --> 00:11:38.300
you get all of that
infrastructure built into it.

00:11:38.300 --> 00:11:40.560
So it's got server libraries
for the Python and Java

00:11:40.560 --> 00:11:43.110
runtime libraries-- we're going
to use Python today--

00:11:43.110 --> 00:11:45.480
and client libraries for
practically everything.

00:11:45.480 --> 00:11:47.680
If you've called a Google web
service before, you've

00:11:47.680 --> 00:11:49.210
probably use the client
libraries.

00:11:49.210 --> 00:11:51.550
You've seen we have a dozen
or so of them in all these

00:11:51.550 --> 00:11:52.550
different languages.

00:11:52.550 --> 00:11:55.190
And you can use the very same
client libraries to make

00:11:55.190 --> 00:11:57.390
authenticated requests to
your own web services.

00:11:57.390 --> 00:11:59.380
So that's what we're
going to do today.

00:11:59.380 --> 00:12:03.170
This makes it especially easy to
set up backends for mobile

00:12:03.170 --> 00:12:04.940
applications, both
Android and iOS.

00:12:04.940 --> 00:12:08.050
They have a full libraries and
documentation for making these

00:12:08.050 --> 00:12:08.920
authenticated requests.

00:12:08.920 --> 00:12:10.220
It makes it really easy.

00:12:10.220 --> 00:12:12.410
And also for rich web
applications, if you've got a

00:12:12.410 --> 00:12:14.230
rich JavaScript app that's
making requests

00:12:14.230 --> 00:12:15.890
back to your server.

00:12:15.890 --> 00:12:19.410
So those are especially easy
with the given documentation

00:12:19.410 --> 00:12:20.440
and libraries.

00:12:20.440 --> 00:12:22.130
We're going to be doing
something slightly different

00:12:22.130 --> 00:12:24.670
but still entirely possible,
which is to use a command-line

00:12:24.670 --> 00:12:27.120
tool to make the same kind of
authenticated requests.

00:12:27.120 --> 00:12:29.280
And we're going to write
that in Python.

00:12:29.280 --> 00:12:31.620
So I have a lot of slides here
on Endpoints just because it's

00:12:31.620 --> 00:12:32.710
kind of the new thing.

00:12:32.710 --> 00:12:34.260
I'm going to speed through
them really quickly.

00:12:34.260 --> 00:12:36.390
Let me know later if
you have questions.

00:12:36.390 --> 00:12:37.530
I have other things
I want to get to.

00:12:37.530 --> 00:12:40.060
But basically, you're
setting up a server.

00:12:40.060 --> 00:12:42.770
A service has methods.

00:12:42.770 --> 00:12:46.210
And methods pass these messages
back and forth.

00:12:46.210 --> 00:12:48.270
They get a request in
and a response out.

00:12:48.270 --> 00:12:50.930
So you can just set up these
messages as ProtoRPCs in sort

00:12:50.930 --> 00:12:52.360
of a general purpose way here.

00:12:52.360 --> 00:12:54.450
You can see they're modeled--
if you've done any work with

00:12:54.450 --> 00:12:58.560
ext.db or ndb for modeling data
in the datastore, this is

00:12:58.560 --> 00:12:59.490
a similar kind of thing.

00:12:59.490 --> 00:13:01.450
You're modeling these
messages.

00:13:01.450 --> 00:13:04.590
And you get typed fields
and things like that.

00:13:04.590 --> 00:13:06.250
In this case, the word
"start" here is

00:13:06.250 --> 00:13:07.230
just our Start Request.

00:13:07.230 --> 00:13:08.900
It's the name of our method.

00:13:08.900 --> 00:13:11.370
And so I've got a StartRequest
and a StartResponse that we

00:13:11.370 --> 00:13:13.680
pass in the project prefixes
and the upload paths.

00:13:13.680 --> 00:13:16.090
And we get back a change ID,
which we can use in further

00:13:16.090 --> 00:13:18.340
interaction with the server as
we go through the change

00:13:18.340 --> 00:13:23.210
protocol for uploading
the change.

00:13:23.210 --> 00:13:25.330
So messages can be defined
as ProtoRPCs.

00:13:25.330 --> 00:13:27.730
I did want to call out here that
a really common thing to

00:13:27.730 --> 00:13:31.840
do with these messages is either
a message is coming in

00:13:31.840 --> 00:13:33.410
that describes a data structure
that you end up

00:13:33.410 --> 00:13:34.740
storing in the datastore.

00:13:34.740 --> 00:13:38.440
Or oftentimes, the user has made
a request for some data

00:13:38.440 --> 00:13:41.390
in the datastore, and that's
coming back out in its

00:13:41.390 --> 00:13:44.110
basically identical structure is
the way you're storing it.

00:13:44.110 --> 00:13:47.100
So if you're doing that just
with ProtoRPCs, you've got

00:13:47.100 --> 00:13:48.190
some redundant code in there.

00:13:48.190 --> 00:13:50.910
You're describing the data
structure for the datastore.

00:13:50.910 --> 00:13:52.210
And then you're describing
the exact same

00:13:52.210 --> 00:13:53.070
thing in your message.

00:13:53.070 --> 00:13:54.940
There's an open source library
called Endpoints Proto

00:13:54.940 --> 00:13:58.470
Datastore that lets you just
take the ndb model and use

00:13:58.470 --> 00:13:59.670
that as your message
structure.

00:13:59.670 --> 00:14:01.850
So definitely look at that, if
that's what you're doing.

00:14:01.850 --> 00:14:03.560
And you usually are.

00:14:03.560 --> 00:14:05.850
I'm not going to use it in my
demo today, just because I'm

00:14:05.850 --> 00:14:08.060
going to do something slightly
different in the way we create

00:14:08.060 --> 00:14:08.900
the datastore entities.

00:14:08.900 --> 00:14:11.170
But it's a really
useful library.

00:14:11.170 --> 00:14:12.860
So here's the service.

00:14:12.860 --> 00:14:14.340
Again, I won't go into
too much detail.

00:14:14.340 --> 00:14:16.365
But you can see a service
is just a class.

00:14:16.365 --> 00:14:17.620
It extends a service class.

00:14:17.620 --> 00:14:20.590
We have a decorator that adds
some information about it.

00:14:20.590 --> 00:14:22.620
We'll talk about client
IDs in a moment.

00:14:22.620 --> 00:14:25.500
The service class has methods
that just represent the

00:14:25.500 --> 00:14:26.250
methods of the service.

00:14:26.250 --> 00:14:29.220
So here's how you do the Start
method of our service.

00:14:29.220 --> 00:14:31.410
Again, we've got a decorator
describing the request and

00:14:31.410 --> 00:14:33.300
response data structures.

00:14:33.300 --> 00:14:35.290
And then the method
implementation just gets a

00:14:35.290 --> 00:14:36.900
request object, builds
a response

00:14:36.900 --> 00:14:39.790
object, and returns it.

00:14:39.790 --> 00:14:42.490
Here is how we do
authorization.

00:14:42.490 --> 00:14:44.750
So at this point, because we
haven't authenticated API--

00:14:44.750 --> 00:14:46.830
and we'll talk more
about that.

00:14:46.830 --> 00:14:49.270
But by this point on the server
code, we already know

00:14:49.270 --> 00:14:50.020
who the user is.

00:14:50.020 --> 00:14:52.330
So the user has authenticated
with the client.

00:14:52.330 --> 00:14:54.070
The client has grabbed
credentials to act on the

00:14:54.070 --> 00:14:55.060
user's behalf.

00:14:55.060 --> 00:14:57.470
And now this message already
has the user information

00:14:57.470 --> 00:14:58.230
associated with it.

00:14:58.230 --> 00:15:00.940
So that's really easy to get out
of the library and start

00:15:00.940 --> 00:15:01.300
doing this.

00:15:01.300 --> 00:15:03.580
I'm comparing the email address
with a fixed list of

00:15:03.580 --> 00:15:05.020
known content developers,
in this case.

00:15:05.020 --> 00:15:06.550
You can get as fancy
as you want with

00:15:06.550 --> 00:15:07.980
access control lists.

00:15:07.980 --> 00:15:10.370
If there's an error, I just
raise an exception.

00:15:10.370 --> 00:15:11.990
And this is one of the
exceptions that comes with the

00:15:11.990 --> 00:15:13.180
Endpoints library.

00:15:13.180 --> 00:15:16.920
Notice that when we modeled the
response message, we did

00:15:16.920 --> 00:15:18.550
not even think about errors.

00:15:18.550 --> 00:15:20.670
Errors are handled entirely
by the library.

00:15:20.670 --> 00:15:23.100
So when you just raise one of
these exceptions, Endpoints

00:15:23.100 --> 00:15:25.980
knows to set the HTTP status
code appropriately.

00:15:25.980 --> 00:15:28.280
You can add arbitrary text
messages to that.

00:15:28.280 --> 00:15:30.450
You can define your own
exception classes.

00:15:30.450 --> 00:15:32.490
It's all built in.

00:15:32.490 --> 00:15:34.500
And here's just an example of
building a response and

00:15:34.500 --> 00:15:36.500
returning it.

00:15:36.500 --> 00:15:37.930
To actually set this
up in the server,

00:15:37.930 --> 00:15:39.010
we're going to create--

00:15:39.010 --> 00:15:41.530
this is basically the
equivalent of a WSGI

00:15:41.530 --> 00:15:42.550
application.

00:15:42.550 --> 00:15:45.880
If you're using web app or
anything else in Python to set

00:15:45.880 --> 00:15:47.040
up an app, you're going
to create the same

00:15:47.040 --> 00:15:47.720
kind of thing here.

00:15:47.720 --> 00:15:50.330
This is how you get that from
the Endpoints library.

00:15:50.330 --> 00:15:53.060
And this is how you map it
into your app.yaml file.

00:15:53.060 --> 00:15:55.820
The URL here has to
be exactly this.

00:15:55.820 --> 00:15:59.040
It's underscore ah, slash
spi, slash dot star.

00:15:59.040 --> 00:15:59.830
That's not a typo.

00:15:59.830 --> 00:16:02.870
That's S-P-I. You'll see
AH API in a few places.

00:16:02.870 --> 00:16:04.080
But here, it has to be SPI.

00:16:04.080 --> 00:16:07.640
And that's just referring to
that app variable that we set

00:16:07.640 --> 00:16:10.030
the module global.

00:16:10.030 --> 00:16:11.780
OK, so client IDs--

00:16:11.780 --> 00:16:14.260
every client uses an ID.

00:16:14.260 --> 00:16:16.730
And not to be confused with
user IDs, of course.

00:16:16.730 --> 00:16:17.450
This is the client ID.

00:16:17.450 --> 00:16:18.740
We're going to have one
client, which is the

00:16:18.740 --> 00:16:20.160
command-line tool.

00:16:20.160 --> 00:16:22.470
The client has to identify
itself in order to act on

00:16:22.470 --> 00:16:24.130
behalf of the user.

00:16:24.130 --> 00:16:26.690
So the user signs in and gets
permission and so forth.

00:16:26.690 --> 00:16:29.860
To get these client IDs, you
use the Google API Console,

00:16:29.860 --> 00:16:33.490
again, just like with any
other Google API.

00:16:33.490 --> 00:16:35.510
And so here's one way
to get to it--

00:16:35.510 --> 00:16:38.090
developers.google.com/console.

00:16:38.090 --> 00:16:38.990
Here's what it looks like.

00:16:38.990 --> 00:16:40.710
I'm not going to go through
a full console demo.

00:16:40.710 --> 00:16:43.070
But I will just really quickly
talk through the process.

00:16:43.070 --> 00:16:44.510
You create a project.

00:16:44.510 --> 00:16:46.480
Under API Access, you
create a client.

00:16:46.480 --> 00:16:48.330
And when you do this, it'll give
you some options as to

00:16:48.330 --> 00:16:50.140
which kind of client
you want to create.

00:16:50.140 --> 00:16:51.670
All the clients are basically
the same.

00:16:51.670 --> 00:16:53.450
It just sort of changes
the way the console

00:16:53.450 --> 00:16:54.680
interacts with you.

00:16:54.680 --> 00:16:56.470
And in this case, even though
it's a command-line tool,

00:16:56.470 --> 00:16:58.920
we're going to create a web
application client.

00:16:58.920 --> 00:17:00.640
It's a little bit confusing,
but we need that, because

00:17:00.640 --> 00:17:03.890
we're going to edit the
settings, and we're going to

00:17:03.890 --> 00:17:10.700
set the authorized redirect
URIs like so.

00:17:10.700 --> 00:17:12.930
We do this because we want it
to interoperate with the

00:17:12.930 --> 00:17:14.819
development server as we're
doing local development.

00:17:14.819 --> 00:17:16.599
So this is an easy
way to do that.

00:17:16.599 --> 00:17:21.490
Just add localhost 8080 and
localhost 8090 to the redirect

00:17:21.490 --> 00:17:23.319
URIs, and that will get it
to work with your local

00:17:23.319 --> 00:17:24.150
development server.

00:17:24.150 --> 00:17:26.849
Don't forget to add your
actual website as well.

00:17:26.849 --> 00:17:28.930
And so on the server side, we've
got those client IDs in

00:17:28.930 --> 00:17:29.870
that annotation.

00:17:29.870 --> 00:17:31.120
We're just going to set
that client ID.

00:17:31.120 --> 00:17:34.180
That's the client ID that comes
out of the APIs Console

00:17:34.180 --> 00:17:35.810
when you create it.

00:17:35.810 --> 00:17:37.880
I've also added a second
client ID here.

00:17:37.880 --> 00:17:39.850
This is for the API Explorer.

00:17:39.850 --> 00:17:43.250
This is a feature of Endpoints
that it makes it really easy

00:17:43.250 --> 00:17:46.660
to test your service without
writing any client code.

00:17:46.660 --> 00:17:48.790
This is a built-in,
general-purpose client for

00:17:48.790 --> 00:17:51.150
experimentation and
trying things out.

00:17:51.150 --> 00:17:53.100
So you add this ID to the
list of clients that

00:17:53.100 --> 00:17:55.880
the service is expecting.

00:17:55.880 --> 00:17:58.120
And you can use this really
powerful tool.

00:17:58.120 --> 00:17:59.570
And it's so powerful I want
to demonstrate it.

00:17:59.570 --> 00:18:01.720
So here's the URL you
would normally use.

00:18:01.720 --> 00:18:03.280
This is for a development
server.

00:18:03.280 --> 00:18:04.530
It's _ah/api/explorer.

00:18:06.650 --> 00:18:08.980
I've got a development server
running for a little service

00:18:08.980 --> 00:18:10.600
right here.

00:18:10.600 --> 00:18:12.840
Going to open a browser.

00:18:12.840 --> 00:18:17.515
Go to localhost 8080,
API Explorer--

00:18:17.515 --> 00:18:20.400
did I get that right?

00:18:20.400 --> 00:18:22.800
This does require an internet
connection because it's

00:18:22.800 --> 00:18:25.160
getting the API explorer
JavaScript

00:18:25.160 --> 00:18:26.920
code from a live service.

00:18:26.920 --> 00:18:28.230
But what it then does-- the

00:18:28.230 --> 00:18:31.190
JavaScript then calls localhost.

00:18:31.190 --> 00:18:33.190
You saw there were some
requests there.

00:18:33.190 --> 00:18:34.290
And what it's actually
fetching is

00:18:34.290 --> 00:18:35.420
the discovery document.

00:18:35.420 --> 00:18:38.600
You might have seen discovery
documents in interacting with

00:18:38.600 --> 00:18:39.430
Google APIs.

00:18:39.430 --> 00:18:43.310
It's a machine-readable
description of the API that it

00:18:43.310 --> 00:18:44.730
can fetch directly
from the service.

00:18:44.730 --> 00:18:47.850
And so it knows from the
Endpoints annotations, the

00:18:47.850 --> 00:18:50.190
decorations that we made to
the class and the methods,

00:18:50.190 --> 00:18:52.920
that we have a Site
Publish API.

00:18:52.920 --> 00:18:54.210
I can click on this.

00:18:54.210 --> 00:18:55.010
And here are the methods.

00:18:55.010 --> 00:18:57.570
I've got a Start, an Upload,
and a Commit.

00:18:57.570 --> 00:18:59.580
I didn't implement Abort
in this case.

00:18:59.580 --> 00:19:00.520
I'll click on Start.

00:19:00.520 --> 00:19:02.850
And I get this cool little
request editor.

00:19:02.850 --> 00:19:06.290
It already knows the structure
of the request fields.

00:19:06.290 --> 00:19:08.020
And so I can just do this.

00:19:08.020 --> 00:19:12.890
And let's add some
upload paths--

00:19:12.890 --> 00:19:18.730
var, HTML, maybe add
one more, vaz.png.

00:19:18.730 --> 00:19:20.700
And so we're creating a
change description.

00:19:20.700 --> 00:19:21.910
This is calling the
Start method.

00:19:21.910 --> 00:19:23.230
And I click Execute.

00:19:23.230 --> 00:19:25.410
And you can see it's called
the service locally.

00:19:25.410 --> 00:19:26.490
And it's sent it this request.

00:19:26.490 --> 00:19:27.730
And I got back this response--

00:19:27.730 --> 00:19:29.240
Not Authorized.

00:19:29.240 --> 00:19:32.910
Because I have not authorized
this client to act on my

00:19:32.910 --> 00:19:34.820
behalf when interacting
with the service.

00:19:34.820 --> 00:19:36.510
So I go back-- you
can do that.

00:19:36.510 --> 00:19:38.170
Go back up here.

00:19:38.170 --> 00:19:39.720
Click this little switch.

00:19:39.720 --> 00:19:42.130
And I say, yes, authorize
for these scopes.

00:19:42.130 --> 00:19:44.040
And now it's going to make me
go through the sign-in flow.

00:19:44.040 --> 00:19:45.450
It's opened up a little
browser window.

00:19:45.450 --> 00:19:47.740
I'm going to sign in with
my Google account.

00:19:53.080 --> 00:19:54.650
And I am using two-factor
authentication.

00:19:54.650 --> 00:19:55.900
I hope you are, too.

00:20:03.570 --> 00:20:04.150
Now it's signed in.

00:20:04.150 --> 00:20:05.550
That little switch
has turned blue.

00:20:05.550 --> 00:20:06.160
It's turned on.

00:20:06.160 --> 00:20:07.410
Now I can click Execute.

00:20:10.010 --> 00:20:11.320
And there's the request again.

00:20:11.320 --> 00:20:13.040
And I get a response
with the change ID.

00:20:13.040 --> 00:20:16.350
So it is now interacting on my
behalf with the service on the

00:20:16.350 --> 00:20:17.600
local development server.

00:20:23.340 --> 00:20:26.120
And these are screenshots in
case that didn't work.

00:20:26.120 --> 00:20:27.420
All right.

00:20:27.420 --> 00:20:29.470
So the client-- we're going
to use the Python Client.

00:20:29.470 --> 00:20:30.370
This is where you go to get all

00:20:30.370 --> 00:20:33.270
those cool client libraries.

00:20:33.270 --> 00:20:34.880
I mentioned the discovery
document.

00:20:34.880 --> 00:20:37.390
And for the command-line tool,
we're actually going to

00:20:37.390 --> 00:20:40.640
generate the discovery document
locally and then just

00:20:40.640 --> 00:20:42.690
have that discovery document
in a file, so the client

00:20:42.690 --> 00:20:45.940
doesn't actually have to hit any
service to figure out what

00:20:45.940 --> 00:20:48.800
service it's interacting with.

00:20:48.800 --> 00:20:50.980
The client library is then
going to generate a

00:20:50.980 --> 00:20:54.130
language-native API to the
client code based on that

00:20:54.130 --> 00:20:55.180
discovery document.

00:20:55.180 --> 00:20:57.020
And then the library, of course,
includes some extra

00:20:57.020 --> 00:20:58.540
tools to make OAuth easy.

00:20:58.540 --> 00:20:59.665
So we're going to see that.

00:20:59.665 --> 00:21:01.680
So here's how you generate
a discovery document.

00:21:01.680 --> 00:21:03.480
I won't talk about
too much detail.

00:21:03.480 --> 00:21:05.660
This tool is included in
the App Engine SDK.

00:21:05.660 --> 00:21:06.910
It's called Endpoints Config.

00:21:06.910 --> 00:21:08.610
I do want to point out you're
probably going to want to make

00:21:08.610 --> 00:21:11.060
two discovery documents-- one
for localhost and one for your

00:21:11.060 --> 00:21:12.270
actual server.

00:21:12.270 --> 00:21:13.530
And when you do that, there's
a little bit of a

00:21:13.530 --> 00:21:14.240
sharp corner here.

00:21:14.240 --> 00:21:16.590
You have to manually edit the
localhost version of the

00:21:16.590 --> 00:21:19.790
discovery document to replace
HTTPS with HTTP.

00:21:19.790 --> 00:21:22.330
That's how you get it to
work with localhost.

00:21:22.330 --> 00:21:24.550
But that host name parameter
is how you can generate

00:21:24.550 --> 00:21:26.240
different versions.

00:21:26.240 --> 00:21:27.845
And so this is client
code now.

00:21:27.845 --> 00:21:29.240
It's Python, but it's
client code.

00:21:29.240 --> 00:21:30.850
We're loading the discovery
document.

00:21:30.850 --> 00:21:35.590
And then we're just passing
it to the client API.

00:21:35.590 --> 00:21:37.910
You get the service
object out of it.

00:21:37.910 --> 00:21:40.600
To do the authentication, we
can do something like this.

00:21:40.600 --> 00:21:42.570
What this is going to
do is it's going to

00:21:42.570 --> 00:21:43.840
prompt me to sign in.

00:21:43.840 --> 00:21:45.740
It'll go get credentials
from the service.

00:21:45.740 --> 00:21:48.360
And then it's going to save
those credentials in a file.

00:21:48.360 --> 00:21:50.520
And then subsequent runs of the
command-line tool, I'm not

00:21:50.520 --> 00:21:51.500
going to have to
sign in again.

00:21:51.500 --> 00:21:52.760
It's already authorized
to do that.

00:21:52.760 --> 00:21:55.010
So I can use the tool multiple
times without having to sign

00:21:55.010 --> 00:21:55.990
in over and over again.

00:21:55.990 --> 00:21:59.190
I get this wrapped HTTP
object at the end.

00:21:59.190 --> 00:22:01.500
And then when I actually call
the service, I just call the

00:22:01.500 --> 00:22:03.650
start method, which is,
again, generated from

00:22:03.650 --> 00:22:04.450
the discovery document.

00:22:04.450 --> 00:22:05.840
That is my Start method.

00:22:05.840 --> 00:22:08.530
Off the service object, I get
this request out of it.

00:22:08.530 --> 00:22:09.990
And then I can execute
the request with our

00:22:09.990 --> 00:22:11.420
wrapped HTTP object.

00:22:11.420 --> 00:22:12.660
I get back a response.

00:22:12.660 --> 00:22:15.590
And I can access the change
ID like that.

00:22:15.590 --> 00:22:18.230
And so real quick for that.

00:22:18.230 --> 00:22:21.435
Here's the server on the left
and my command over here.

00:22:24.260 --> 00:22:26.160
Notice that when I ran the
command-line tool, it went

00:22:26.160 --> 00:22:27.050
back to the browser.

00:22:27.050 --> 00:22:28.590
This is how it prompts
me to sign in.

00:22:28.590 --> 00:22:31.190
It is actually sending me
to Google to sign in.

00:22:31.190 --> 00:22:33.630
You also notice that I've
already signed in, because

00:22:33.630 --> 00:22:36.670
signed in to Google, for
the previous demo.

00:22:36.670 --> 00:22:38.340
But I still need to authorize
this client

00:22:38.340 --> 00:22:39.340
to act on my behalf.

00:22:39.340 --> 00:22:40.350
So I am prompted to do that.

00:22:40.350 --> 00:22:43.350
I click Allow Access.

00:22:43.350 --> 00:22:46.670
And control returns back to
the command-line tool.

00:22:46.670 --> 00:22:47.770
And it finishes what
it's doing.

00:22:47.770 --> 00:22:48.930
And then it gets back
a change ID.

00:22:48.930 --> 00:22:51.620
So now the command-line tool
is interacting on my behalf

00:22:51.620 --> 00:22:53.520
with the service locally.

00:22:53.520 --> 00:22:56.330
And the only change I need to
make there to use the live

00:22:56.330 --> 00:22:59.260
service is to use a different
discovery document.

00:22:59.260 --> 00:23:02.350
OK, so we have a change
description

00:23:02.350 --> 00:23:03.570
getting to the service.

00:23:03.570 --> 00:23:06.460
We have a way of communicating
with the service and doing the

00:23:06.460 --> 00:23:08.940
Start, Upload, and
Commit calls.

00:23:08.940 --> 00:23:10.550
Now we need to figure
out what to do next.

00:23:10.550 --> 00:23:12.940
We need to store that change
in description somehow.

00:23:12.940 --> 00:23:15.220
So let's store it in
the datastore.

00:23:15.220 --> 00:23:16.470
The datastore is schema-less.

00:23:16.470 --> 00:23:19.180
We're going to use the ndb
library to actually model this

00:23:19.180 --> 00:23:21.230
data so it's got a consistent
structure.

00:23:21.230 --> 00:23:22.640
And this is the structure
we're going to use.

00:23:22.640 --> 00:23:24.540
Basically, we store our project
prefixes and our

00:23:24.540 --> 00:23:25.300
upload paths.

00:23:25.300 --> 00:23:26.120
And we have some extra fields.

00:23:26.120 --> 00:23:28.590
We definitely want to record
who does what.

00:23:28.590 --> 00:23:30.650
You're going to want to go
back and see who's made

00:23:30.650 --> 00:23:33.310
changes to your website,
I'm very sure.

00:23:33.310 --> 00:23:35.010
And then we're going to keep
track of whether this change

00:23:35.010 --> 00:23:38.460
has been explicitly committed
or aborted.

00:23:38.460 --> 00:23:41.640
One specific thing we want to
talk about with changes.

00:23:41.640 --> 00:23:44.750
Later on, we're going to need
some way of ordering changes.

00:23:44.750 --> 00:23:47.450
What we want is to promise to
the user the changes show up

00:23:47.450 --> 00:23:50.030
on the website on a first come,
first served basis.

00:23:50.030 --> 00:23:53.690
And so to do that, we need to
know who came first when these

00:23:53.690 --> 00:23:56.620
changes have been created.

00:23:56.620 --> 00:23:58.360
A couple ways you might try
to think to do that.

00:23:58.360 --> 00:23:59.520
Maybe we use a datetime.

00:23:59.520 --> 00:24:02.190
We generate the datetime that
it comes in as a field and

00:24:02.190 --> 00:24:03.800
then we order by datetime.

00:24:03.800 --> 00:24:05.960
That's probably not the best
idea if you really need strict

00:24:05.960 --> 00:24:08.600
ordering, because the datetime
is actually set from the

00:24:08.600 --> 00:24:10.130
system clock of the
app instance.

00:24:10.130 --> 00:24:11.730
And different app instances
are going to

00:24:11.730 --> 00:24:12.520
have different clocks.

00:24:12.520 --> 00:24:15.330
There's going to be a clock
skew of as many as minutes

00:24:15.330 --> 00:24:16.090
when you do it that way.

00:24:16.090 --> 00:24:17.280
So you probably don't
want datetimes if

00:24:17.280 --> 00:24:18.370
you want strict ordering.

00:24:18.370 --> 00:24:20.750
Another option is to let the
datastore come up with a

00:24:20.750 --> 00:24:23.740
system ID when you create
the change record.

00:24:23.740 --> 00:24:24.350
It can do this.

00:24:24.350 --> 00:24:26.280
If you don't set a key name,
it'll come up with its own

00:24:26.280 --> 00:24:27.440
numeric ID.

00:24:27.440 --> 00:24:29.980
These are generally
increasing IDs.

00:24:29.980 --> 00:24:32.180
But especially if you've got two
entities that are not in

00:24:32.180 --> 00:24:37.100
the same entity group, the
system IDs are not guaranteed

00:24:37.100 --> 00:24:39.930
to be in monotonically
increasing order.

00:24:39.930 --> 00:24:42.540
The different shards of the
datastore are going to have

00:24:42.540 --> 00:24:44.070
different allocated ID ranges.

00:24:44.070 --> 00:24:47.520
So it'll be guaranteed to assign
unique system IDs, but

00:24:47.520 --> 00:24:49.550
not necessarily increasing
system IDs.

00:24:49.550 --> 00:24:51.400
If they're in the same entity
group, you get something

00:24:51.400 --> 00:24:53.550
closer to monotonically
increasing, but it's still not

00:24:53.550 --> 00:24:54.730
guaranteed by the datastore.

00:24:54.730 --> 00:24:59.350
So our idea here is to keep
track of our own change IDs.

00:24:59.350 --> 00:25:01.220
We are going to store
the next change ID.

00:25:01.220 --> 00:25:03.280
And then we're going to update
it whenever we create one of

00:25:03.280 --> 00:25:04.060
these things.

00:25:04.060 --> 00:25:05.720
Of course, we need to update
it transactionally.

00:25:05.720 --> 00:25:07.680
And we're going to need to use
a transactional primitive of

00:25:07.680 --> 00:25:10.840
the datastore in order to make
sure that two changes don't

00:25:10.840 --> 00:25:13.860
get created with the
same change ID.

00:25:13.860 --> 00:25:16.600
So there's going to be a
singleton datastore entity

00:25:16.600 --> 00:25:18.950
holding the change ID
in the datastore.

00:25:18.950 --> 00:25:20.360
This is a really nice
opportunity.

00:25:20.360 --> 00:25:22.660
We do need a transaction here.

00:25:22.660 --> 00:25:24.970
This would be a great use for a
feature that came out about

00:25:24.970 --> 00:25:27.590
a year ago or so ago called
cross-group transactions.

00:25:27.590 --> 00:25:29.400
Now, you might be familiar
with how datastore

00:25:29.400 --> 00:25:30.550
transactions work.

00:25:30.550 --> 00:25:32.860
Entities are created
in entity groups.

00:25:32.860 --> 00:25:36.440
And a transaction can execute
over multiple entities, but

00:25:36.440 --> 00:25:38.510
all those entities have to be
in the same entity group.

00:25:38.510 --> 00:25:40.780
You have to know that ahead of
time as you're modeling your

00:25:40.780 --> 00:25:42.890
data what is going to be
changed in the same

00:25:42.890 --> 00:25:44.840
transaction.

00:25:44.840 --> 00:25:47.900
And so this new feature allows
you to actually use up to five

00:25:47.900 --> 00:25:50.140
entity groups in a single
transaction.

00:25:50.140 --> 00:25:53.150
Now, in terms of scalability,
five isn't a much

00:25:53.150 --> 00:25:54.450
different from one.

00:25:54.450 --> 00:25:57.490
But the cool thing about
cross-group transactions is

00:25:57.490 --> 00:25:59.040
they don't have to be the
same five every time.

00:25:59.040 --> 00:26:01.250
You can actually decide which
entity groups are involved.

00:26:01.250 --> 00:26:03.050
And the datastore will take a
little bit of extra time.

00:26:03.050 --> 00:26:04.010
It's a little bit slower.

00:26:04.010 --> 00:26:06.260
But it'll make sure it can
meet all its consistency

00:26:06.260 --> 00:26:09.150
guarantees as it's making
changes of up to five entity

00:26:09.150 --> 00:26:10.000
groups when it does that.

00:26:10.000 --> 00:26:12.720
So you can have the change
ID in one entity group.

00:26:12.720 --> 00:26:14.620
You can create new changes in
other entity groups and then

00:26:14.620 --> 00:26:16.450
just sort of loop those two
together in a single

00:26:16.450 --> 00:26:18.280
transaction as you're updating
these things.

00:26:18.280 --> 00:26:20.090
And you get basically
the same effect.

00:26:20.090 --> 00:26:22.120
But in our case, it's not going
to make that much of a

00:26:22.120 --> 00:26:22.780
difference.

00:26:22.780 --> 00:26:25.510
You do have to think about your
actual throughput needs

00:26:25.510 --> 00:26:27.310
and how complicated these
things are going to be.

00:26:27.310 --> 00:26:29.760
And in our case, we're talking
hundreds of content

00:26:29.760 --> 00:26:32.190
developers, not hundreds
of thousands.

00:26:32.190 --> 00:26:34.300
So we just said, OK, let's just
put everything in the

00:26:34.300 --> 00:26:36.010
same entity group, and then we
don't have to worry about

00:26:36.010 --> 00:26:37.380
cross-group transactions.

00:26:37.380 --> 00:26:39.520
In our case, that turned
out to be fine.

00:26:39.520 --> 00:26:42.190
We have to basically serialize
updates to this entity group

00:26:42.190 --> 00:26:44.290
now, because there will be
contention for this entity

00:26:44.290 --> 00:26:46.420
group as people are
making changes.

00:26:46.420 --> 00:26:47.360
But that's going
to work for us.

00:26:47.360 --> 00:26:48.750
So we're just going to do it.

00:26:48.750 --> 00:26:52.530
If you're doing custom keys,
remember you're using a string

00:26:52.530 --> 00:26:54.230
value, not an numeric value.

00:26:54.230 --> 00:26:56.760
And so in our case, we pad with
zeros so that the strings

00:26:56.760 --> 00:26:59.950
will be orderable and
ASCIIbetical order and

00:26:59.950 --> 00:27:02.940
represent the actual
change orders.

00:27:02.940 --> 00:27:04.670
This is how you'd
model with ndb.

00:27:04.670 --> 00:27:06.840
No surprises here-- these
are just the fields.

00:27:06.840 --> 00:27:09.850
I'm going to skip past this.

00:27:09.850 --> 00:27:13.160
So the content-- we now have to
store the content somehow.

00:27:13.160 --> 00:27:16.320
Couple things to think about
when modeling the content.

00:27:16.320 --> 00:27:18.210
Remember, we've got this View
Request that needs to be

00:27:18.210 --> 00:27:18.910
pretty fast.

00:27:18.910 --> 00:27:21.150
We want the View Request
to come in, grab the

00:27:21.150 --> 00:27:21.940
data, and serve it.

00:27:21.940 --> 00:27:24.870
And we don't want to think too
hard about how that happens.

00:27:24.870 --> 00:27:28.670
So as a general rule of thumb,
we decided to say, OK, this

00:27:28.670 --> 00:27:29.590
View Request is coming in.

00:27:29.590 --> 00:27:31.170
It has some information
it knows.

00:27:31.170 --> 00:27:33.570
It should be able to get
everything it needs from the

00:27:33.570 --> 00:27:35.960
datastore and then return
it to the user without

00:27:35.960 --> 00:27:37.340
performing a query.

00:27:37.340 --> 00:27:39.880
It's not strictly necessary,
but it's kind of a

00:27:39.880 --> 00:27:41.600
nice rule of thumb.

00:27:41.600 --> 00:27:44.390
So in this case, the View
Request knows the URL path.

00:27:44.390 --> 00:27:46.090
And so that means at some point,
we're going to need

00:27:46.090 --> 00:27:48.730
some datastore entity keyed off
of the URL path so it can

00:27:48.730 --> 00:27:50.800
get that thing and then figure
out whatever else it needs to

00:27:50.800 --> 00:27:54.320
do, as opposed to performing
some kind of a query.

00:27:54.320 --> 00:27:57.240
One of the nice things about
this rule of thumb is that

00:27:57.240 --> 00:27:59.370
it's really easy to imagine
what the Memcache layer is

00:27:59.370 --> 00:27:59.970
going to look like.

00:27:59.970 --> 00:28:02.460
If you're going to add in
caching, then you can just

00:28:02.460 --> 00:28:04.550
cache these entities directly
into Memcache.

00:28:04.550 --> 00:28:07.280
And then those same Gets can
occur on the Memcache just as

00:28:07.280 --> 00:28:09.640
they would on the datastore.

00:28:09.640 --> 00:28:11.670
But we also have to remember
that publishing needs to be

00:28:11.670 --> 00:28:13.280
able to store new content
separately

00:28:13.280 --> 00:28:14.330
from the live content.

00:28:14.330 --> 00:28:17.080
So if it's just a single entity
keyed off of the URL

00:28:17.080 --> 00:28:20.390
path, then when you're creating
another one of those,

00:28:20.390 --> 00:28:23.170
that has to live side by side
with that before it gets

00:28:23.170 --> 00:28:24.340
switched into the right thing.

00:28:24.340 --> 00:28:27.060
So one idea-- again, there are
many ways of doing this.

00:28:27.060 --> 00:28:30.940
But the one we went with was
to use a separate entity

00:28:30.940 --> 00:28:33.850
called the Path entity keyed
off of the URL path.

00:28:33.850 --> 00:28:35.940
And then that contains a pointer
to a Content entity.

00:28:35.940 --> 00:28:38.770
So it looks something
like this.

00:28:38.770 --> 00:28:42.780
One obvious disadvantage with
this is that the View Request

00:28:42.780 --> 00:28:47.080
now has to make two datastore
calls, which you may not want.

00:28:47.080 --> 00:28:48.850
Not only that, but it has
to make them in series.

00:28:48.850 --> 00:28:52.800
It has to get the path
from the URL path.

00:28:52.800 --> 00:28:55.210
And then it has to wait for that
to come back to know how

00:28:55.210 --> 00:28:57.210
to get to the content object.

00:28:57.210 --> 00:28:58.380
There are going to
be advantages

00:28:58.380 --> 00:28:59.160
to this design later.

00:28:59.160 --> 00:29:01.370
So this was actually something
that we lived with.

00:29:01.370 --> 00:29:06.350
But that is a disadvantage if
you go do something like that.

00:29:06.350 --> 00:29:07.540
So what about entity grouping?

00:29:07.540 --> 00:29:09.380
Do we need to think about
transactionality for

00:29:09.380 --> 00:29:10.570
anything like this?

00:29:10.570 --> 00:29:13.160
So one idea, the one that
we used, is to have

00:29:13.160 --> 00:29:14.640
one group per path.

00:29:14.640 --> 00:29:17.340
And then that group contains
the path and

00:29:17.340 --> 00:29:19.120
multiple content objects.

00:29:19.120 --> 00:29:21.150
And that allows us to
set the content key.

00:29:21.150 --> 00:29:24.800
We can change that pointer and
manipulate content objects in

00:29:24.800 --> 00:29:26.750
a single transaction.

00:29:26.750 --> 00:29:27.650
So it looks something
like this.

00:29:27.650 --> 00:29:28.400
Here's your entity group.

00:29:28.400 --> 00:29:29.940
It's pointing to the
old content.

00:29:29.940 --> 00:29:31.010
New content comes in.

00:29:31.010 --> 00:29:32.960
And then in a single
transaction, we can flip that

00:29:32.960 --> 00:29:35.340
pointer and delete the old
content, all at the same time

00:29:35.340 --> 00:29:37.480
to make sure that that's
guaranteed to work together in

00:29:37.480 --> 00:29:38.680
a single transaction.

00:29:38.680 --> 00:29:39.540
Here's the model for that.

00:29:39.540 --> 00:29:41.960
Not a big deal.

00:29:41.960 --> 00:29:46.530
So let's talk about the Apply
phase a little bit here.

00:29:46.530 --> 00:29:48.470
This Commit comes in, and we've
got some work to do.

00:29:48.470 --> 00:29:50.040
So what exactly happens?

00:29:50.040 --> 00:29:51.640
Well, the client calls
the Commit method.

00:29:51.640 --> 00:29:53.290
It's got a change ID
so we know what

00:29:53.290 --> 00:29:56.480
change we're applying.

00:29:56.480 --> 00:29:58.450
The server has two things to
do in response to this.

00:29:58.450 --> 00:30:00.690
It has to update the change
record to say, yes, this is

00:30:00.690 --> 00:30:01.540
now committed.

00:30:01.540 --> 00:30:04.760
And it also has to kick off
some background work.

00:30:04.760 --> 00:30:08.550
Now, if those two things happen
separately, there's

00:30:08.550 --> 00:30:11.460
always a potential for one of
them to succeed and the other

00:30:11.460 --> 00:30:12.930
one to fail.

00:30:12.930 --> 00:30:14.800
So if you're updating the change
record first, then

00:30:14.800 --> 00:30:17.210
maybe you update the change
record and the server now

00:30:17.210 --> 00:30:19.360
believes that change is
committed successfully.

00:30:19.360 --> 00:30:22.950
But it hasn't actually
successfully added a task to

00:30:22.950 --> 00:30:24.710
the task queue.

00:30:24.710 --> 00:30:26.920
Or if you did it the other way
around, then it could be

00:30:26.920 --> 00:30:28.980
applying the change but not
realize that it's actually

00:30:28.980 --> 00:30:30.290
committed it.

00:30:30.290 --> 00:30:31.860
So what we can do here--

00:30:31.860 --> 00:30:34.610
this is the justification for a
really important feature of

00:30:34.610 --> 00:30:35.460
task queues.

00:30:35.460 --> 00:30:39.000
You can add a task to a task
queue as part of a datastore

00:30:39.000 --> 00:30:40.070
transaction.

00:30:40.070 --> 00:30:41.890
So we are going to change
the Change record.

00:30:41.890 --> 00:30:44.190
We're going to update the Change
record and set the

00:30:44.190 --> 00:30:45.840
Apply Task in a transaction.

00:30:45.840 --> 00:30:48.490
That means if the transaction
succeeds, both of those things

00:30:48.490 --> 00:30:48.990
have happened.

00:30:48.990 --> 00:30:51.190
If it fails, neither
of them have.

00:30:51.190 --> 00:30:53.400
And then we can return an
error to the client.

00:30:53.400 --> 00:30:55.385
And the client knows that
nothing is going to be changed

00:30:55.385 --> 00:30:57.140
to the live website.

00:30:57.140 --> 00:30:59.640
So the Apply Task-- and then if
it needs to, it can spawn

00:30:59.640 --> 00:31:00.660
more tasks.

00:31:00.660 --> 00:31:02.500
And then you've got all these
tasks on the website.

00:31:02.500 --> 00:31:04.420
What guarantees that those tasks
are actually going to

00:31:04.420 --> 00:31:05.110
complete successfully?

00:31:05.110 --> 00:31:06.930
Well, the task queue does.

00:31:06.930 --> 00:31:09.670
The task queue actually will
drive and retry those tasks

00:31:09.670 --> 00:31:11.230
until they succeed.

00:31:11.230 --> 00:31:13.270
So that's basically
our guarantee.

00:31:13.270 --> 00:31:16.540
Once we have committed the
change and told the client

00:31:16.540 --> 00:31:18.910
it's committed, the task is
already on the task queue.

00:31:18.910 --> 00:31:21.050
And the task queue can figure
out how to make sure

00:31:21.050 --> 00:31:23.850
everything works the way
it's supposed to.

00:31:23.850 --> 00:31:26.160
One more thing we need
to talk about.

00:31:26.160 --> 00:31:29.100
Say change one comes in and
then queues some tasks.

00:31:29.100 --> 00:31:31.960
And change two comes in,
modifying the same file that

00:31:31.960 --> 00:31:33.470
change one does.

00:31:33.470 --> 00:31:36.240
And both of those getting queued
to the task queue.

00:31:36.240 --> 00:31:38.910
The task queue does not
guarantee a first come, first

00:31:38.910 --> 00:31:40.780
serve order when it's
executing tasks.

00:31:40.780 --> 00:31:44.860
So it's possible for the apply
phase of change one to happen

00:31:44.860 --> 00:31:45.880
after change two.

00:31:45.880 --> 00:31:48.690
And that's going to violate
our expectation.

00:31:48.690 --> 00:31:51.580
So what happens when these
things happen out of order?

00:31:51.580 --> 00:31:53.930
Well, we take care of that
by ordering the changes.

00:31:53.930 --> 00:31:57.030
This is why we ordered the
changes in a strict order.

00:31:57.030 --> 00:32:00.490
Because now, we can store the
last change ID that's affected

00:32:00.490 --> 00:32:01.890
a path with the path.

00:32:01.890 --> 00:32:05.780
When change two comes in,
it updates a path.

00:32:05.780 --> 00:32:08.180
And as part of that, it
says, I am change two.

00:32:08.180 --> 00:32:10.000
Change two was the last
person to touch this.

00:32:10.000 --> 00:32:11.950
So when change one comes in,
says, I also need to touch

00:32:11.950 --> 00:32:14.470
this-- oh, wait, change two
has already been here.

00:32:14.470 --> 00:32:16.080
I'm going to just return
success without

00:32:16.080 --> 00:32:17.690
actually doing anything.

00:32:17.690 --> 00:32:19.170
And then change two
continues to win.

00:32:19.170 --> 00:32:20.910
It sticks.

00:32:20.910 --> 00:32:23.440
In this way, the apply phase
only rolls forward in our

00:32:23.440 --> 00:32:24.370
change history.

00:32:24.370 --> 00:32:26.580
And so that's how we
ensure that these

00:32:26.580 --> 00:32:27.860
things are going forward.

00:32:27.860 --> 00:32:29.500
One minor design detail
we need to

00:32:29.500 --> 00:32:31.740
account for is deletes.

00:32:31.740 --> 00:32:34.040
Normally, you would think, oh,
well, if something comes in,

00:32:34.040 --> 00:32:35.250
wants something deleted,
you can delete the

00:32:35.250 --> 00:32:36.370
path and the content.

00:32:36.370 --> 00:32:38.440
But in this case, we actually
need to remember which change

00:32:38.440 --> 00:32:39.410
made that delete.

00:32:39.410 --> 00:32:41.620
And so we're going to have
deletes represented in the

00:32:41.620 --> 00:32:42.910
system as tombstones.

00:32:42.910 --> 00:32:44.320
The content objects
can go away, but

00:32:44.320 --> 00:32:45.700
the path object can't.

00:32:45.700 --> 00:32:47.780
The path object is going to
stick around and say, yep, I

00:32:47.780 --> 00:32:50.120
am deleted, and this is the
change that deleted me.

00:32:50.120 --> 00:32:52.690
And that way, we can make
sure that deletes

00:32:52.690 --> 00:32:55.910
stick in the same way.

00:32:55.910 --> 00:32:58.720
So to summarize what
we've seen so far--

00:32:58.720 --> 00:33:00.620
and that's basically all
the time we have.

00:33:00.620 --> 00:33:03.570
So I'm just going to summarize
what we have.

00:33:03.570 --> 00:33:04.740
We have a content management
system.

00:33:04.740 --> 00:33:07.830
We've got this remote publishing
capability with

00:33:07.830 --> 00:33:10.490
this general transactional
guarantee with eventual

00:33:10.490 --> 00:33:12.870
consistency of application
of changes.

00:33:12.870 --> 00:33:16.360
So when things go up, they're
as guaranteed as possible to

00:33:16.360 --> 00:33:17.820
go onto the website.

00:33:17.820 --> 00:33:20.390
We can have arbitrary change
sizes, so we can have many

00:33:20.390 --> 00:33:21.820
thousands of files.

00:33:21.820 --> 00:33:24.180
I want to put a little asterisk
next to that.

00:33:24.180 --> 00:33:26.320
Because if you do implement
something like this, you're

00:33:26.320 --> 00:33:27.580
going to find bottlenecks.

00:33:27.580 --> 00:33:30.690
You're going to have various
places where change sizes are

00:33:30.690 --> 00:33:31.610
going to be limited.

00:33:31.610 --> 00:33:33.990
I'll give you one example from
what we've just seen.

00:33:33.990 --> 00:33:37.770
We are creating these change
records in the datastore.

00:33:37.770 --> 00:33:41.350
And they describe every
file in a project.

00:33:41.350 --> 00:33:43.440
That change record is stored in
the datastore, which means

00:33:43.440 --> 00:33:44.820
it has a 1 megabyte limit.

00:33:44.820 --> 00:33:46.620
And so that's going
to be a limiting

00:33:46.620 --> 00:33:47.780
factor on change size.

00:33:47.780 --> 00:33:50.040
And if we get to the point where
we need changes larger

00:33:50.040 --> 00:33:53.220
than that, we could engineer
around that.

00:33:53.220 --> 00:33:55.530
We could figure out other ways
to represent changes in the

00:33:55.530 --> 00:33:57.390
system, that sort of thing.

00:33:57.390 --> 00:33:59.060
And you engineer around
any bottleneck.

00:33:59.060 --> 00:34:00.900
But you usually do it-- you
wait until you hit the

00:34:00.900 --> 00:34:01.360
bottleneck.

00:34:01.360 --> 00:34:03.460
You wait until you need
something more before

00:34:03.460 --> 00:34:05.250
building around it.

00:34:05.250 --> 00:34:08.340
We are able to get easy
authenticated web services

00:34:08.340 --> 00:34:09.659
using Google Cloud Endpoints.

00:34:09.659 --> 00:34:12.130
We use the datastore for
transactional data storage.

00:34:12.130 --> 00:34:14.659
We use the transactional
primitives to implement the

00:34:14.659 --> 00:34:15.690
full protocol.

00:34:15.690 --> 00:34:19.199
We used ndb for Python for
modeling the data.

00:34:19.199 --> 00:34:21.510
And we used the task queue
for background tasks.

00:34:21.510 --> 00:34:23.650
We didn't really talk about
caching that much, but you can

00:34:23.650 --> 00:34:25.670
use Memcache as your
caching layer.

00:34:25.670 --> 00:34:27.080
It's a service of App Engine.

00:34:27.080 --> 00:34:29.360
But more importantly, ndb can
take care of it for you.

00:34:29.360 --> 00:34:32.030
You don't have to think about
the caching interactions.

00:34:32.030 --> 00:34:35.100
You just set a cache policy on
your datastore entities, and

00:34:35.100 --> 00:34:37.710
ndb will figure out what goes in
the Memcache and how it can

00:34:37.710 --> 00:34:39.850
manage all that stuff
quickly and easily.

00:34:39.850 --> 00:34:41.880
We didn't say anything about
large object storage, but I

00:34:41.880 --> 00:34:44.030
did mention the datastore
objects are

00:34:44.030 --> 00:34:45.239
limited to one megabyte.

00:34:45.239 --> 00:34:47.139
On the website, we do have
document objects

00:34:47.139 --> 00:34:48.750
larger than a megabyte.

00:34:48.750 --> 00:34:49.880
And so what do we
do with that?

00:34:49.880 --> 00:34:51.090
Well, we put them in
cloud storage.

00:34:51.090 --> 00:34:53.510
And the feature of
cloud storage--

00:34:53.510 --> 00:34:56.199
also known as Blobstore--

00:34:56.199 --> 00:34:58.690
makes this actually generally
invisible to both the content

00:34:58.690 --> 00:34:59.850
developer and the end user.

00:34:59.850 --> 00:35:03.320
I can handle that all
inside the protocol

00:35:03.320 --> 00:35:04.560
implementation details.

00:35:04.560 --> 00:35:06.400
And then the View
Request is just

00:35:06.400 --> 00:35:08.920
another URL on your website.

00:35:08.920 --> 00:35:11.920
And it just knows internally
to go to the Google Cloud

00:35:11.920 --> 00:35:14.010
Storage to serve those things.

00:35:14.010 --> 00:35:18.430
So you know the URL for
developers.google.com.

00:35:18.430 --> 00:35:21.880
I did put together a small demo
of this protocol in a

00:35:21.880 --> 00:35:22.740
little project in GitHub.

00:35:22.740 --> 00:35:24.690
I actually do not have
the finished code

00:35:24.690 --> 00:35:25.390
uploaded there yet.

00:35:25.390 --> 00:35:27.450
But check back in a few days,
and I'll have the full thing

00:35:27.450 --> 00:35:29.270
there, if you want to try
experimenting with that.

00:35:29.270 --> 00:35:30.450
It is demo code.

00:35:30.450 --> 00:35:31.860
I want to stress that.

00:35:31.860 --> 00:35:32.970
There may be bugs and things.

00:35:32.970 --> 00:35:34.760
Please feel free to
file bug reports.

00:35:34.760 --> 00:35:35.720
I'll try to brush it up.

00:35:35.720 --> 00:35:37.275
I actually do kind of
want a nice open

00:35:37.275 --> 00:35:38.170
source version of this.

00:35:38.170 --> 00:35:39.850
But there's that.

00:35:39.850 --> 00:35:41.820
If you want to go to the book's
website and see more

00:35:41.820 --> 00:35:43.770
information about the book,
that's the URL there.

00:35:43.770 --> 00:35:45.150
I also have a Plus page
for the book.

00:35:45.150 --> 00:35:46.690
And I can also be followed
on Google+.

00:35:46.690 --> 00:35:49.440
One more thing about
the book--

00:35:49.440 --> 00:35:51.570
I am doing a book signing
at 3:00 PM today out

00:35:51.570 --> 00:35:52.380
in the cloud area.

00:35:52.380 --> 00:35:54.430
We have a limited number of
free books to give away.

00:35:54.430 --> 00:35:57.240
So if you want to show up at
3:00 PM, we'll see if we can

00:35:57.240 --> 00:35:57.836
accommodate you.

00:35:57.836 --> 00:35:59.210
I'd be just happy to meet you.

00:35:59.210 --> 00:36:01.330
And I'd love to hear what you're
building on App Engine.

00:36:01.330 --> 00:36:02.890
If you have any questions,
we have four

00:36:02.890 --> 00:36:03.820
minutes left for questions.

00:36:03.820 --> 00:36:05.310
So we have microphones.

00:36:05.310 --> 00:36:07.275
You can come up to the
microphones and ask questions.

00:36:07.275 --> 00:36:08.380
Otherwise, thank you very much.

00:36:08.380 --> 00:36:14.828
[APPLAUSE]

00:36:26.240 --> 00:36:28.140
DAN SANDERSON: Hi, I'll take the
one in the back row first.

00:36:28.140 --> 00:36:28.730
AUDIENCE: Hi.

00:36:28.730 --> 00:36:31.580
You mentioned that you can have
a clock skew of up to

00:36:31.580 --> 00:36:35.910
several minutes between various
App Engine instances.

00:36:35.910 --> 00:36:37.910
DAN SANDERSON: Yeah, there
can be a clock skew.

00:36:37.910 --> 00:36:40.360
I picked the term several
minutes kind of off

00:36:40.360 --> 00:36:41.110
the top of my head.

00:36:41.110 --> 00:36:42.840
It's sort of what I've
been told in the

00:36:42.840 --> 00:36:44.590
distant past about it.

00:36:44.590 --> 00:36:49.180
I think the main thing is that
there's really no guarantee of

00:36:49.180 --> 00:36:51.190
synchronicity of the clocks
between them.

00:36:51.190 --> 00:36:53.270
AUDIENCE: The question I really
had is how the logging

00:36:53.270 --> 00:36:55.150
service deals with that.

00:36:55.150 --> 00:36:56.580
DAN SANDERSON: That's
a good question.

00:36:56.580 --> 00:36:58.170
I could look into
that for you.

00:36:58.170 --> 00:36:59.900
I don't know if there's like
a separate service that's

00:36:59.900 --> 00:37:01.650
actually logging that,
or if it's getting

00:37:01.650 --> 00:37:02.520
the system time from--

00:37:02.520 --> 00:37:04.310
AUDIENCE: Seems like kind
of an important--

00:37:04.310 --> 00:37:05.310
DAN SANDERSON: No, exactly.

00:37:05.310 --> 00:37:08.610
That is very interesting.

00:37:08.610 --> 00:37:10.990
We can ask at the Cloud Booth
and I'll get a definitive

00:37:10.990 --> 00:37:11.510
answer for you.

00:37:11.510 --> 00:37:15.460
But I know a lot of the logs
are managed by a service.

00:37:15.460 --> 00:37:18.811
So that can come up with
its own source of

00:37:18.811 --> 00:37:21.460
time, but I'm not sure.

00:37:21.460 --> 00:37:22.240
AUDIENCE: Great job.

00:37:22.240 --> 00:37:22.940
This stuff is awesome.

00:37:22.940 --> 00:37:25.320
But the question for you-- are
you using the App Engine

00:37:25.320 --> 00:37:27.810
full-text search service?

00:37:27.810 --> 00:37:28.950
DAN SANDERSON: That was
something I did not have time

00:37:28.950 --> 00:37:29.420
to talk about.

00:37:29.420 --> 00:37:31.060
Yeah, absolutely, if you're
building a content

00:37:31.060 --> 00:37:31.580
management--

00:37:31.580 --> 00:37:34.170
AUDIENCE: Is that going to
be in the sample code?

00:37:34.170 --> 00:37:35.730
DAN SANDERSON: I would like to
add it to the sample code.

00:37:35.730 --> 00:37:36.440
It's not in yet.

00:37:36.440 --> 00:37:37.690
AUDIENCE: OK, cool.

00:37:37.690 --> 00:37:40.240
So were there any challenges
that you found with using

00:37:40.240 --> 00:37:41.950
full-text search API?

00:37:41.950 --> 00:37:42.960
DAN SANDERSON: Not
really, actually.

00:37:42.960 --> 00:37:45.465
It worked pretty much the way
you would expect it to.

00:37:45.465 --> 00:37:48.480
They do a really good job of
synchronizing datastore

00:37:48.480 --> 00:37:52.290
entities with the documents
in the search index.

00:37:52.290 --> 00:37:55.510
We have a couple of basic ways
to get our documents into the

00:37:55.510 --> 00:37:56.620
search service.

00:37:56.620 --> 00:37:58.270
But it was pretty
straightforward kind of to the

00:37:58.270 --> 00:37:59.820
terms of the search API.

00:37:59.820 --> 00:38:02.550
AUDIENCE: As far as your
method for indexing the

00:38:02.550 --> 00:38:06.030
documents, did you fire off a
task after the Commit phase to

00:38:06.030 --> 00:38:07.840
add it to the search index?

00:38:07.840 --> 00:38:11.440
Or did you do it as part of
the entire transaction?

00:38:11.440 --> 00:38:12.550
Or did you do it separately
from the

00:38:12.550 --> 00:38:13.720
transaction, from the Commit?

00:38:13.720 --> 00:38:15.260
DAN SANDERSON: Well, one of
the nice things about the

00:38:15.260 --> 00:38:16.800
Apply phase is you can
do basically an

00:38:16.800 --> 00:38:17.900
arbitrary amount of work.

00:38:17.900 --> 00:38:20.160
And it gets driven to completion
by the task queue.

00:38:20.160 --> 00:38:25.730
So yeah, we do, at some point in
the Apply phase, manage the

00:38:25.730 --> 00:38:27.850
updating of the search
indexes.

00:38:27.850 --> 00:38:29.400
AUDIENCE: But I'm asking,
is it separate from that

00:38:29.400 --> 00:38:29.750
transaction?

00:38:29.750 --> 00:38:33.660
So in case search fails,
indexing fails, does that

00:38:33.660 --> 00:38:34.560
block the transaction?

00:38:34.560 --> 00:38:37.180
Or is it a completely
separate task?

00:38:37.180 --> 00:38:39.920
DAN SANDERSON: You can define
those parameters yourself

00:38:39.920 --> 00:38:41.880
based on how you
write the task.

00:38:41.880 --> 00:38:45.420
If the API call fails for
whatever reason, you can

00:38:45.420 --> 00:38:46.970
decide whether that's
fatal to the task

00:38:46.970 --> 00:38:48.190
and needs to be retried.

00:38:48.190 --> 00:38:49.690
AUDIENCE: Right, I was just
wondering what you guys did,

00:38:49.690 --> 00:38:50.570
as far as--

00:38:50.570 --> 00:38:53.540
did you decide to fail the task
or fail the transaction,

00:38:53.540 --> 00:38:55.480
or just let it slide?

00:38:55.480 --> 00:38:56.080
DAN SANDERSON: We have
a bunch of--

00:38:56.080 --> 00:38:58.000
I don't know about the search
API specifically.

00:38:58.000 --> 00:39:00.630
But there are a couple of cases
where we had to make

00:39:00.630 --> 00:39:06.130
that call and say, OK, the task
is successful even if

00:39:06.130 --> 00:39:08.020
that one thing didn't happen.

00:39:08.020 --> 00:39:10.620
There are a couple of sort of
residual changes we make to

00:39:10.620 --> 00:39:12.840
our data structures that
work kind of like that.

00:39:12.840 --> 00:39:13.180
AUDIENCE: Awesome.

00:39:13.180 --> 00:39:13.850
Thanks.

00:39:13.850 --> 00:39:14.790
DAN SANDERSON: Yeah.

00:39:14.790 --> 00:39:15.340
Go ahead.

00:39:15.340 --> 00:39:17.730
AUDIENCE: Sorry, I'm back.

00:39:17.730 --> 00:39:19.470
Did you just say that
the Blobstore is

00:39:19.470 --> 00:39:21.050
really cloud storage?

00:39:21.050 --> 00:39:22.360
DAN SANDERSON: They
are separate.

00:39:22.360 --> 00:39:24.270
But the APIs are similar.

00:39:24.270 --> 00:39:25.990
So that's why I didn't want to
make much of a distinction

00:39:25.990 --> 00:39:26.710
between them.

00:39:26.710 --> 00:39:30.070
The implementation we used
predates the cloud storage

00:39:30.070 --> 00:39:32.320
that has the same API as the
Blobstore, so we use Blobstore

00:39:32.320 --> 00:39:33.470
for the actual thing.

00:39:33.470 --> 00:39:35.820
But you could easily use
cloud storage for that.

00:39:35.820 --> 00:39:36.090
AUDIENCE: OK.

00:39:36.090 --> 00:39:37.340
Thank you.

00:39:40.000 --> 00:39:42.320
DAN SANDERSON: Anyone else?

00:39:42.320 --> 00:39:42.860
OK, cool.

00:39:42.860 --> 00:39:43.410
See you out there.

00:39:43.410 --> 00:39:44.660
Thanks very much.

