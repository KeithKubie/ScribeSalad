WEBVTT
Kind: captions
Language: en

00:00:01.120 --> 00:00:03.010
LEON NICHOLLS: Have
you ever wished

00:00:03.010 --> 00:00:06.420
that you could click on
things in the real world

00:00:06.420 --> 00:00:08.470
to find out more about them?

00:00:08.470 --> 00:00:10.700
What if you could learn
about things around you

00:00:10.700 --> 00:00:13.095
in the real world
without doing a search?

00:00:15.750 --> 00:00:17.350
You're at a bus stop.

00:00:17.350 --> 00:00:22.190
What if you could click on the
stop to get the bus schedule?

00:00:22.190 --> 00:00:25.000
You see a poster.

00:00:25.000 --> 00:00:26.870
What if you could
click on the poster

00:00:26.870 --> 00:00:29.200
so you can get more information?

00:00:29.200 --> 00:00:34.240
What if the real world
behaved like the web?

00:00:34.240 --> 00:00:35.400
Well, it can.

00:00:35.400 --> 00:00:38.240
It's called the physical web.

00:00:38.240 --> 00:00:38.990
So I'm curious.

00:00:38.990 --> 00:00:41.590
How many of you have heard of
the physical web before today?

00:00:41.590 --> 00:00:43.450
Just a show of hands.

00:00:43.450 --> 00:00:44.990
OK, that's pretty
good, actually,

00:00:44.990 --> 00:00:48.060
because the physical web
is still kind of new.

00:00:48.060 --> 00:00:51.210
So what is this physical web?

00:00:51.210 --> 00:00:56.308
It's a bridge between
physical things and the web.

00:00:56.308 --> 00:01:01.720
It allows you to walk up to
anything and just use it.

00:01:01.720 --> 00:01:04.379
So that sounds a little
magical, doesn't it?

00:01:04.379 --> 00:01:07.110
How does this actually work?

00:01:07.110 --> 00:01:12.470
So it starts with a beacon,
something like this.

00:01:12.470 --> 00:01:16.260
It's broadcasting a URL.

00:01:16.260 --> 00:01:18.880
The Chrome browser
on your mobile device

00:01:18.880 --> 00:01:21.870
is scanning for URLs nearby.

00:01:21.870 --> 00:01:25.310
When it finds one, it
creates a notification.

00:01:25.310 --> 00:01:27.370
The user can then click
on the notification

00:01:27.370 --> 00:01:31.290
and load the web page
associated with that URL.

00:01:31.290 --> 00:01:35.020
The web page can present
some information,

00:01:35.020 --> 00:01:38.020
and that web page also
connects to the device,

00:01:38.020 --> 00:01:38.878
the beacon itself.

00:01:42.390 --> 00:01:43.950
Let's look at an example.

00:01:43.950 --> 00:01:46.020
So here we have a
vending machine.

00:01:46.020 --> 00:01:49.220
We have a beacon associated
with this vending machine.

00:01:49.220 --> 00:01:52.200
And the beacon is
broadcasting a URL,

00:01:52.200 --> 00:01:55.790
and a notification is
displayed to the user

00:01:55.790 --> 00:01:57.780
on the mobile
device for that URL.

00:01:57.780 --> 00:02:00.830
It tells the user, hey, there's
a vending machine nearby.

00:02:00.830 --> 00:02:02.760
You can buy candy.

00:02:02.760 --> 00:02:05.640
So the user clicks
on the notification,

00:02:05.640 --> 00:02:09.460
it loads this web page
with a big Buy button,

00:02:09.460 --> 00:02:13.100
and the user can then
click on the Buy button.

00:02:13.100 --> 00:02:15.300
When that happens, the
web page can communicate

00:02:15.300 --> 00:02:17.660
with the vending machine
and say, hey, give

00:02:17.660 --> 00:02:19.218
some candy to this guy.

00:02:22.870 --> 00:02:25.390
So that's the user experience.

00:02:25.390 --> 00:02:28.750
But how do you, as a developer,
implement the physical web

00:02:28.750 --> 00:02:29.590
solution?

00:02:29.590 --> 00:02:31.980
That's what this talk is about.

00:02:31.980 --> 00:02:34.410
So I'm going to cover
several topics-- firstly,

00:02:34.410 --> 00:02:38.970
how to configure and deploy
the beacons in the real world;

00:02:38.970 --> 00:02:41.450
how to provide the metadata
from the notifications that

00:02:41.450 --> 00:02:45.740
are displayed to the user; how
you can use progressive web

00:02:45.740 --> 00:02:49.000
apps to create
native experiences;

00:02:49.000 --> 00:02:52.802
and then how to use the Web
Bluetooth API to control

00:02:52.802 --> 00:02:53.510
physical devices.

00:02:56.620 --> 00:02:58.150
So let's start at the beginning.

00:02:58.150 --> 00:03:01.640
So how do you actually
configure and deploy

00:03:01.640 --> 00:03:02.994
a beacon in the real world?

00:03:02.994 --> 00:03:04.910
So we're going to look
at some of the details,

00:03:04.910 --> 00:03:07.170
and some of this is based
on our own experiences

00:03:07.170 --> 00:03:09.250
with deploying beacons
in the real world.

00:03:09.250 --> 00:03:11.670
In fact, one of my colleagues,
Scott, just recently

00:03:11.670 --> 00:03:14.470
deployed some beacons at the
Computer History Museum, which

00:03:14.470 --> 00:03:16.170
is somewhere in that direction.

00:03:16.170 --> 00:03:18.542
And we learned some
valuable lessons from that.

00:03:21.620 --> 00:03:24.700
Firstly, let's talk
about Eddystone.

00:03:24.700 --> 00:03:30.000
So Eddystone is an open protocol
specification for beacons.

00:03:30.000 --> 00:03:33.650
It defines a Bluetooth
Low Energy messaging

00:03:33.650 --> 00:03:36.010
format for beacons.

00:03:36.010 --> 00:03:39.520
So the beacons are
broadcasting URLs regularly,

00:03:39.520 --> 00:03:43.750
and any nearby
applications can use that.

00:03:43.750 --> 00:03:46.270
So Eddystone defines
several different types,

00:03:46.270 --> 00:03:50.190
frame types that you can use
individually or in combination.

00:03:50.190 --> 00:03:54.000
One of those frame types
is called Eddystone URL.

00:03:54.000 --> 00:03:56.190
It allows you to
broadcast a URL.

00:03:56.190 --> 00:04:00.112
That's what makes the physical
web possible with a beacon.

00:04:03.920 --> 00:04:06.970
Now, Eddystone is
supported by all

00:04:06.970 --> 00:04:10.570
the major beacon manufacturers,
and it's growing.

00:04:10.570 --> 00:04:15.370
And Eddystone is also compatible
with Apple's iBeacon format.

00:04:18.290 --> 00:04:20.269
OK, let's look at some
of the gory details.

00:04:20.269 --> 00:04:22.690
So this is an advertising
packet, the actual bytes

00:04:22.690 --> 00:04:26.270
that make up the advertisement
packets for the Eddystone URL

00:04:26.270 --> 00:04:27.090
frame.

00:04:27.090 --> 00:04:29.210
So this is what gets
broadcast by the beacon

00:04:29.210 --> 00:04:30.670
on a regular basis.

00:04:30.670 --> 00:04:33.240
So you can see that
we're broadcasting

00:04:33.240 --> 00:04:36.330
a URL from the
Google URL shortener,

00:04:36.330 --> 00:04:38.510
but you can use any shortener.

00:04:38.510 --> 00:04:42.170
The URL is compressed to fit
within the limited advertising

00:04:42.170 --> 00:04:46.862
packet size, which is
only 18 bytes for the URL.

00:04:46.862 --> 00:04:49.170
Now, these advertising
packets are broadcast,

00:04:49.170 --> 00:04:51.850
and any devices or
applications nearby

00:04:51.850 --> 00:04:54.302
can extract useful
information from that.

00:04:58.900 --> 00:05:00.760
So let's talk about Chrome.

00:05:00.760 --> 00:05:03.450
Now, as I said, Chrome
in the background

00:05:03.450 --> 00:05:05.980
is scanning for URLs nearby.

00:05:05.980 --> 00:05:09.190
When it gets the
URL, it sends it up

00:05:09.190 --> 00:05:12.280
to the cloud to a proxy service.

00:05:12.280 --> 00:05:14.790
The proxy service
does several things.

00:05:14.790 --> 00:05:20.170
Firstly, it eliminates the
duplicates, it avoids spam,

00:05:20.170 --> 00:05:24.559
and it also does some
ranking of the URLs.

00:05:24.559 --> 00:05:26.350
Now, the scanning is
done in the background

00:05:26.350 --> 00:05:27.474
in a very efficient manner.

00:05:27.474 --> 00:05:30.750
It doesn't drain your battery
for your mobile device.

00:05:30.750 --> 00:05:32.480
And once the proxy
server has actually

00:05:32.480 --> 00:05:35.890
processed all these URLs,
they are sent back to Chrome,

00:05:35.890 --> 00:05:39.170
and then Chrome makes a
notification out of that.

00:05:39.170 --> 00:05:42.280
Other browser vendors are also
working on their own scanners

00:05:42.280 --> 00:05:43.310
to do something similar.

00:05:46.480 --> 00:05:50.230
OK, you've bought
an Eddystone beacon

00:05:50.230 --> 00:05:53.210
from any of the manufacturers
that support the standard.

00:05:53.210 --> 00:05:55.050
How do you actually
configure that beacon

00:05:55.050 --> 00:05:58.060
for the physical web?

00:05:58.060 --> 00:06:01.790
Well, you start by
configuring the frame type.

00:06:01.790 --> 00:06:04.140
So typically, a beacon
vendor will give you

00:06:04.140 --> 00:06:06.290
a native app that
allows you to configure

00:06:06.290 --> 00:06:08.000
their particular beacons.

00:06:08.000 --> 00:06:10.120
So you open that app.

00:06:10.120 --> 00:06:12.050
You configure the frame type.

00:06:12.050 --> 00:06:15.490
You will then get prompted
to specify the URL.

00:06:15.490 --> 00:06:18.230
There are some
requirements for the URL.

00:06:18.230 --> 00:06:20.360
In particular, for the
physical web on Chrome,

00:06:20.360 --> 00:06:25.100
we only support HTTPS,
for security reasons.

00:06:25.100 --> 00:06:27.219
And as I mentioned
before, you've

00:06:27.219 --> 00:06:29.260
got to use a URL shortener,
because there is only

00:06:29.260 --> 00:06:31.010
a limited number of
bytes that you can put

00:06:31.010 --> 00:06:33.230
into the advertising packet.

00:06:33.230 --> 00:06:35.520
Now, the other advantage
of using a URL shortener

00:06:35.520 --> 00:06:37.770
is that you can
do URL redirects.

00:06:37.770 --> 00:06:39.690
So you can configure
all your beacons

00:06:39.690 --> 00:06:42.780
with this shortened version of
the URL, and then at any time

00:06:42.780 --> 00:06:45.227
go to the cloud and
change the URL redirect

00:06:45.227 --> 00:06:47.810
without having to go back to the
beacons and reconfigure them.

00:06:47.810 --> 00:06:49.220
So it's very valuable.

00:06:52.550 --> 00:06:54.760
A few more parameters you
need to configure, again,

00:06:54.760 --> 00:06:56.540
using the configuration app.

00:06:56.540 --> 00:06:58.860
The first one is the
transmission power.

00:06:58.860 --> 00:07:00.670
Now, we recommend
a value somewhere

00:07:00.670 --> 00:07:04.320
between negative 35db
and negative 35db.

00:07:04.320 --> 00:07:07.650
And so that's a low setting
for the transmission power.

00:07:07.650 --> 00:07:09.620
It has two advantages.

00:07:09.620 --> 00:07:12.110
One, it helps to
prolong the life

00:07:12.110 --> 00:07:14.460
of the battery for the beacon.

00:07:14.460 --> 00:07:17.640
Secondly, it ensures that
users only see the beacons when

00:07:17.640 --> 00:07:19.820
they're close to the beacon.

00:07:19.820 --> 00:07:23.870
So this gives the user a much
more contextual experience.

00:07:23.870 --> 00:07:25.870
Now, of course, there are
going to be situations

00:07:25.870 --> 00:07:28.810
where you need to extend
the transmission power,

00:07:28.810 --> 00:07:30.040
have a higher value.

00:07:30.040 --> 00:07:33.436
And I'll talk about some
of those use cases later.

00:07:33.436 --> 00:07:35.060
The next parameter
that you need to set

00:07:35.060 --> 00:07:36.840
is the advertising frequency.

00:07:36.840 --> 00:07:40.070
We recommend a value
of 700 milliseconds.

00:07:40.070 --> 00:07:42.790
So that means every
700 milliseconds,

00:07:42.790 --> 00:07:45.850
the beacon is
advertising the data.

00:07:45.850 --> 00:07:48.450
Now, scanning applications
such as Chrome

00:07:48.450 --> 00:07:52.080
might not reliably show
these URLs as notifications

00:07:52.080 --> 00:07:56.500
if this frequency is
slower than a second.

00:07:56.500 --> 00:07:58.720
So this is really important.

00:07:58.720 --> 00:08:01.220
What you need to do is, once
you've configured your beacons,

00:08:01.220 --> 00:08:04.590
is go and actually try this
under real-world conditions,

00:08:04.590 --> 00:08:07.350
and you might have to tweak
some of these parameters.

00:08:07.350 --> 00:08:10.380
If these beacons are not
configured correctly,

00:08:10.380 --> 00:08:12.500
the user experience
might not be good.

00:08:12.500 --> 00:08:15.190
They might walk past your beacon
and never get a notification.

00:08:19.540 --> 00:08:20.072
OK.

00:08:20.072 --> 00:08:21.280
You've configured the beacon.

00:08:21.280 --> 00:08:23.210
How do you actually
physically deploy

00:08:23.210 --> 00:08:26.100
the beacon in the real world?

00:08:26.100 --> 00:08:27.970
Now, the complexity
of your deployment

00:08:27.970 --> 00:08:30.420
will depend on two
things-- firstly,

00:08:30.420 --> 00:08:33.440
how many beacons you need
to deploy; and secondly,

00:08:33.440 --> 00:08:35.990
how many distinct URLs
you need to support

00:08:35.990 --> 00:08:38.100
for your particular application.

00:08:38.100 --> 00:08:40.320
So this table shows the
various combinations,

00:08:40.320 --> 00:08:41.760
and we'll go through those.

00:08:41.760 --> 00:08:44.400
The first one is
really the easiest one.

00:08:44.400 --> 00:08:47.870
It's where you've got
one beacon and one URL.

00:08:47.870 --> 00:08:49.990
So that's like a
poster, and the poster

00:08:49.990 --> 00:08:54.090
has a link to a trailer
for the movie, for example.

00:08:54.090 --> 00:08:57.000
We recommend a low setting
for the transmission power.

00:08:57.000 --> 00:08:58.560
Put the beacon at
a high altitude,

00:08:58.560 --> 00:09:00.202
so there is less interference.

00:09:00.202 --> 00:09:01.410
Also try and avoid any metal.

00:09:04.920 --> 00:09:07.450
The next one is many
beacons, one URL.

00:09:07.450 --> 00:09:10.140
So that's like having an
agenda at a conference.

00:09:10.140 --> 00:09:13.170
That's exactly what
we've done here at I/O.

00:09:13.170 --> 00:09:15.420
So I'm sure you've
seen on your phone

00:09:15.420 --> 00:09:18.920
that there's notifications
coming up for the I/O agenda.

00:09:18.920 --> 00:09:20.520
Now, of course, this
is a large area,

00:09:20.520 --> 00:09:22.750
so we need a lot of
beacons to cover the area.

00:09:22.750 --> 00:09:25.340
So here we recommend
you actually increase

00:09:25.340 --> 00:09:29.430
the transmission power for the
beacon to cover a larger area.

00:09:29.430 --> 00:09:32.300
Now, for physical web
scanners like Chrome,

00:09:32.300 --> 00:09:35.690
when they see multiple
URLs in the same area,

00:09:35.690 --> 00:09:36.960
it will be de-duplicated.

00:09:36.960 --> 00:09:39.370
So even if there's overlap
between the transmissions,

00:09:39.370 --> 00:09:41.130
the user will only see one URL.

00:09:46.240 --> 00:09:50.110
So the next one is many
beacons, many URLs.

00:09:50.110 --> 00:09:52.590
Now, the use case for this
is like an exhibition,

00:09:52.590 --> 00:09:53.780
maybe like a museum.

00:09:53.780 --> 00:09:57.220
So you've got a large building,
but a lot of individual items.

00:09:57.220 --> 00:10:00.839
And you want to give
each item its own URL.

00:10:00.839 --> 00:10:02.380
So in this case,
you want to restrict

00:10:02.380 --> 00:10:04.120
the range in which
the user will actually

00:10:04.120 --> 00:10:07.350
discover the URL for every
object as they walk around.

00:10:07.350 --> 00:10:09.930
So you can do this by
lowering the transmission

00:10:09.930 --> 00:10:11.280
power of the beacon.

00:10:14.500 --> 00:10:15.600
OK.

00:10:15.600 --> 00:10:17.080
You've configured the beacons.

00:10:17.080 --> 00:10:18.820
You've deployed the beacons.

00:10:18.820 --> 00:10:21.540
Now, how do you actually
provide the metadata

00:10:21.540 --> 00:10:24.970
for those notifications that
get displayed to the user?

00:10:24.970 --> 00:10:27.910
Now, the physical web
is an open ecosystem,

00:10:27.910 --> 00:10:30.434
so any browser can
implement support for it.

00:10:30.434 --> 00:10:32.600
But we're going to focus
on Chrome's implementation.

00:10:35.520 --> 00:10:38.320
So let's take a look
at the notifications.

00:10:38.320 --> 00:10:42.380
You can see that for
every URL discovered,

00:10:42.380 --> 00:10:44.620
we see an icon,
some kind of image.

00:10:44.620 --> 00:10:47.790
We see a title, we
see a description,

00:10:47.790 --> 00:10:50.441
and of course, the URL
that was discovered.

00:10:50.441 --> 00:10:51.690
But where is this coming from?

00:10:55.820 --> 00:10:59.560
Well, remember, after Chrome
has collected the URLs nearby,

00:10:59.560 --> 00:11:04.910
it's taking the shortened URL,
expands it into the full URL,

00:11:04.910 --> 00:11:07.090
sends it up to
the proxy service.

00:11:07.090 --> 00:11:09.070
The proxy service
actually goes and visits

00:11:09.070 --> 00:11:11.040
every one of those URLs.

00:11:11.040 --> 00:11:13.860
It then extracts the
metadata it needs.

00:11:13.860 --> 00:11:16.760
And I'll go into the
details of what that is.

00:11:16.760 --> 00:11:20.180
Once it's got the metadata, it
sends it back down to Chrome.

00:11:20.180 --> 00:11:23.110
And then Chrome caches it
locally on the mobile device

00:11:23.110 --> 00:11:27.440
and uses that for the
notification presentation.

00:11:27.440 --> 00:11:31.200
One note that on, for Chrome, at
least, the physical web is not

00:11:31.200 --> 00:11:34.950
enabled by default. So the
first time Chrome discovers

00:11:34.950 --> 00:11:38.136
a physical web URL nearby, it
actually shows an introduction

00:11:38.136 --> 00:11:38.760
to the feature.

00:11:38.760 --> 00:11:40.750
It tells the user
about the physical web,

00:11:40.750 --> 00:11:44.010
and it also asks permission
to enable the feature.

00:11:44.010 --> 00:11:46.470
So only if the user
says yes, then they

00:11:46.470 --> 00:11:48.130
will get subsequent
notifications

00:11:48.130 --> 00:11:49.293
about nearby URLs.

00:11:56.280 --> 00:11:56.780
OK.

00:11:56.780 --> 00:11:59.760
So how do you
optimize your website

00:11:59.760 --> 00:12:02.500
for these notifications
for the metadata?

00:12:02.500 --> 00:12:06.190
Now, these are all based
on standard HTML concepts,

00:12:06.190 --> 00:12:08.740
and I'm going to show you
an example of this, too.

00:12:08.740 --> 00:12:12.420
Firstly, you need an HTML title.

00:12:12.420 --> 00:12:16.320
You're going to need a
description meta tag.

00:12:16.320 --> 00:12:18.700
You need an icon of at
least 96 by 96 pixels.

00:12:18.700 --> 00:12:20.200
So where is that
number coming from?

00:12:20.200 --> 00:12:22.764
Well, we've done some
testing, and anything lower

00:12:22.764 --> 00:12:24.180
than that doesn't
really look good

00:12:24.180 --> 00:12:27.090
as a notification on
most mobile devices.

00:12:27.090 --> 00:12:29.080
So at least that dimension.

00:12:29.080 --> 00:12:31.610
Now, if you don't provide the
title or the description meta

00:12:31.610 --> 00:12:34.180
tag, you can also use
Schema.org or Open Graph

00:12:34.180 --> 00:12:37.750
tags to provide that metadata.

00:12:37.750 --> 00:12:39.980
We're also considering
the use of a web app

00:12:39.980 --> 00:12:41.950
manifest for some
of the metadata.

00:12:41.950 --> 00:12:44.220
It's not there yet, but
will be coming soon.

00:12:46.760 --> 00:12:48.570
OK, so what does this mean?

00:12:48.570 --> 00:12:51.810
Well, here's the most basic
HTML to provide all the metadata

00:12:51.810 --> 00:12:53.180
we need for a notification.

00:12:53.180 --> 00:12:54.620
It's really quite simple.

00:12:54.620 --> 00:12:57.690
So you can see we have the
title, we have the description,

00:12:57.690 --> 00:13:00.740
we have a reference to the icon
and a reference to the web app

00:13:00.740 --> 00:13:01.690
manifest.

00:13:01.690 --> 00:13:03.184
This is standard web stuff.

00:13:05.850 --> 00:13:08.600
Let's look at the app manifest.

00:13:08.600 --> 00:13:11.980
In particular, we are interested
in two of those values,

00:13:11.980 --> 00:13:13.710
the name and the set of icons.

00:13:13.710 --> 00:13:16.800
So this is just a JSON
file that shows you

00:13:16.800 --> 00:13:18.785
the metadata about the web app.

00:13:18.785 --> 00:13:20.410
This is not particular
to physical web.

00:13:20.410 --> 00:13:23.435
This is just part of
the web standards.

00:13:23.435 --> 00:13:24.810
The nice thing
about the icons is

00:13:24.810 --> 00:13:26.465
that it shows
multiple resolutions,

00:13:26.465 --> 00:13:30.400
so that are very useful with
showing different resolutions

00:13:30.400 --> 00:13:31.451
on the mobile devices.

00:13:36.450 --> 00:13:37.560
OK.

00:13:37.560 --> 00:13:40.470
So now you've got your website
ready for the notification,

00:13:40.470 --> 00:13:40.970
right?

00:13:40.970 --> 00:13:43.050
You threw out all the metadata.

00:13:43.050 --> 00:13:45.040
When the user clicks
on their notification,

00:13:45.040 --> 00:13:47.580
your web page is then loaded.

00:13:47.580 --> 00:13:51.610
Now, one of the
criticisms of web apps

00:13:51.610 --> 00:13:54.950
is that the user experience
and the set of features

00:13:54.950 --> 00:13:56.790
that are possible
from a web page

00:13:56.790 --> 00:13:58.840
might not match that
of a native app.

00:13:58.840 --> 00:14:00.490
In particular, when
it comes to things

00:14:00.490 --> 00:14:02.580
like usability or
responsiveness,

00:14:02.580 --> 00:14:05.690
it might not be as
good as native apps.

00:14:05.690 --> 00:14:08.825
Well, that's actually
no longer true.

00:14:08.825 --> 00:14:11.200
And we're going to look at
how we can use progressive web

00:14:11.200 --> 00:14:13.920
apps to create native
experiences for users.

00:14:16.490 --> 00:14:19.720
So let's take just a quick
look at what progressive web

00:14:19.720 --> 00:14:20.850
apps are.

00:14:20.850 --> 00:14:23.270
Firstly, it supports
a full-screen mode

00:14:23.270 --> 00:14:24.177
for your web app.

00:14:26.690 --> 00:14:29.210
Your app can be added as
an icon to the home screen.

00:14:29.210 --> 00:14:30.780
So the user can
launch it directly

00:14:30.780 --> 00:14:32.970
without using the
browser directly.

00:14:32.970 --> 00:14:35.980
It supports push notifications.

00:14:35.980 --> 00:14:37.980
It has an application cache.

00:14:37.980 --> 00:14:40.620
In fact, you can cache
the entire application--

00:14:40.620 --> 00:14:43.180
the framework, the data,
everything-- locally

00:14:43.180 --> 00:14:45.124
on the mobile device.

00:14:45.124 --> 00:14:47.040
And that's great, because
you can do something

00:14:47.040 --> 00:14:48.110
called offline support.

00:14:48.110 --> 00:14:50.980
So literally, when your
mobile device is not

00:14:50.980 --> 00:14:52.890
connected to the
internet in any way,

00:14:52.890 --> 00:14:55.260
you'll still be able
to launch this app,

00:14:55.260 --> 00:14:57.670
and the user will not see
any error messages, no

00:14:57.670 --> 00:14:59.010
HTTP error codes.

00:14:59.010 --> 00:15:03.180
It will launch like it is
connected to the internet.

00:15:03.180 --> 00:15:04.940
So support for
progressive web apps

00:15:04.940 --> 00:15:10.380
are being implemented by
Chrome, Firefox, and Opera.

00:15:10.380 --> 00:15:13.100
Progressive web apps are
a really great example

00:15:13.100 --> 00:15:15.970
of leveraging existing web
technologies for a new use

00:15:15.970 --> 00:15:18.650
case.

00:15:18.650 --> 00:15:22.130
OK, let's take a
look at an example.

00:15:22.130 --> 00:15:23.430
This is a progressive web app.

00:15:23.430 --> 00:15:27.670
You can see that the user
is loading it from a URL.

00:15:27.670 --> 00:15:31.130
Then it's added to the
home screen as an icon.

00:15:31.130 --> 00:15:36.910
And once you launch it from that
icon, it launches full screen.

00:15:36.910 --> 00:15:39.120
There's no address
bar, and to the user,

00:15:39.120 --> 00:15:42.460
it actually looks
like a native app.

00:15:42.460 --> 00:15:44.970
So that's quite different
from a normal web page.

00:15:44.970 --> 00:15:47.850
So this is an example of
a great progressive web

00:15:47.850 --> 00:15:49.790
app from a physical-web
point of view.

00:15:49.790 --> 00:15:52.120
And the reason is that
this particular app

00:15:52.120 --> 00:15:54.069
is single-purpose.

00:15:54.069 --> 00:15:56.485
So in this case, it actually
allows you to press a button.

00:15:59.100 --> 00:16:03.780
Now, ideally, when you design a
web page for the physical web,

00:16:03.780 --> 00:16:06.800
you should cater
to a single action.

00:16:06.800 --> 00:16:09.380
Remember, the user just
clicked on the notification

00:16:09.380 --> 00:16:10.340
for that beacon.

00:16:10.340 --> 00:16:12.660
The user has shown
an intent to interact

00:16:12.660 --> 00:16:14.640
with that beacon or device.

00:16:14.640 --> 00:16:16.690
So the user is not
browsing to this page,

00:16:16.690 --> 00:16:19.110
or won't be browsing
inside the page.

00:16:19.110 --> 00:16:22.840
So ideally, focus on providing
either a simple action

00:16:22.840 --> 00:16:26.240
or a single page of content that
is associated with that beacon

00:16:26.240 --> 00:16:26.740
or device.

00:16:31.310 --> 00:16:32.280
OK.

00:16:32.280 --> 00:16:33.370
So you have a web app.

00:16:33.370 --> 00:16:35.147
How do you make it progressive?

00:16:35.147 --> 00:16:37.230
There's actually just three
things you need to do.

00:16:37.230 --> 00:16:39.167
It's quite simple.

00:16:39.167 --> 00:16:41.292
Firstly, you need to add
something called a service

00:16:41.292 --> 00:16:42.500
worker.

00:16:42.500 --> 00:16:45.200
So has any of you heard of
a service worker before?

00:16:45.200 --> 00:16:47.270
OK, just some of you.

00:16:47.270 --> 00:16:47.840
OK.

00:16:47.840 --> 00:16:50.850
A service worker is
something quite new.

00:16:50.850 --> 00:16:53.070
A very exciting
technology, though.

00:16:53.070 --> 00:16:55.560
What it does-- it's like running
a script in the background

00:16:55.560 --> 00:16:56.960
for your website.

00:16:56.960 --> 00:16:59.220
Chrome does this on your behalf.

00:16:59.220 --> 00:17:01.560
Now, the main use case
for a service worker,

00:17:01.560 --> 00:17:04.760
or one of the main use
cases, is to do caching.

00:17:04.760 --> 00:17:07.200
So once you've configured
the service worker,

00:17:07.200 --> 00:17:09.210
you can configure it
so it can automatically

00:17:09.210 --> 00:17:13.079
cache your framework and
data behind the scenes.

00:17:13.079 --> 00:17:15.450
And that makes the
offline support possible.

00:17:15.450 --> 00:17:17.450
Now, there are various
libraries and frameworks,

00:17:17.450 --> 00:17:19.339
like Polymer, that
allows you to easily add

00:17:19.339 --> 00:17:23.166
this to existing web app,
so this is not a big effort.

00:17:23.166 --> 00:17:27.069
The second requirement--
you have to use HTTPS.

00:17:27.069 --> 00:17:29.840
Now, as I mentioned before,
for the physical web scan

00:17:29.840 --> 00:17:31.700
on Chrome, we only
support HTTPS,

00:17:31.700 --> 00:17:34.642
so you have to do that anyhow.

00:17:34.642 --> 00:17:36.100
Then the third
thing you have to do

00:17:36.100 --> 00:17:38.650
is you have to provide
the web app manifest.

00:17:38.650 --> 00:17:40.572
So again, as I
mentioned earlier,

00:17:40.572 --> 00:17:43.030
we're looking into supporting
the web app manifest for some

00:17:43.030 --> 00:17:44.130
of the metadata.

00:17:44.130 --> 00:17:46.660
So there's a nice overlap
between the requirements

00:17:46.660 --> 00:17:49.220
of the physical web and
progressive web apps.

00:17:54.432 --> 00:17:56.140
Now, those are just
the basics, actually.

00:17:56.140 --> 00:17:57.890
There's a lot more
to progressive apps.

00:17:57.890 --> 00:18:00.630
But that's basically all you
need for this particular use

00:18:00.630 --> 00:18:03.250
case for the physical web.

00:18:03.250 --> 00:18:06.210
There are things that you
can provide for configuring

00:18:06.210 --> 00:18:08.220
the offline support.

00:18:08.220 --> 00:18:10.770
There's more things you can
do with the service worker.

00:18:10.770 --> 00:18:13.770
There's a growing number
of libraries and frameworks

00:18:13.770 --> 00:18:14.990
and some great sample apps.

00:18:14.990 --> 00:18:16.781
In fact, there's been
several sessions here

00:18:16.781 --> 00:18:18.640
at I/O about
progressive web apps.

00:18:18.640 --> 00:18:22.320
So if you're interested
in exploring opportunities

00:18:22.320 --> 00:18:24.690
to make your web
app be more native,

00:18:24.690 --> 00:18:27.100
then definitely go and
look at those resources.

00:18:27.100 --> 00:18:29.680
We've also announced
more frameworks that

00:18:29.680 --> 00:18:32.610
support progressive
web apps and also

00:18:32.610 --> 00:18:36.040
a lot more content partners
that are now developing

00:18:36.040 --> 00:18:36.980
progressive web apps.

00:18:41.420 --> 00:18:42.980
OK.

00:18:42.980 --> 00:18:45.230
So we've configured beacons.

00:18:45.230 --> 00:18:46.420
We've deployed beacons.

00:18:46.420 --> 00:18:47.830
We've got the metadata.

00:18:47.830 --> 00:18:50.410
The user is clicking
on our notification,

00:18:50.410 --> 00:18:52.560
because we've got
something that is enticing,

00:18:52.560 --> 00:18:54.976
and the user wants to interact
with that particular device

00:18:54.976 --> 00:18:55.620
or beacon.

00:18:55.620 --> 00:18:58.260
So now that the user has
actually loaded the web page

00:18:58.260 --> 00:19:00.870
from a Bluetooth
device, your page

00:19:00.870 --> 00:19:04.830
can actually communicate back
to that Bluetooth device.

00:19:04.830 --> 00:19:08.562
And you can do that using an API
called the Web Bluetooth API.

00:19:11.830 --> 00:19:15.870
So I'm going to show you my
very first Web Bluetooth API

00:19:15.870 --> 00:19:17.170
application.

00:19:17.170 --> 00:19:18.794
Can we play the video, please?

00:19:22.070 --> 00:19:23.280
So here's my Chromebook.

00:19:23.280 --> 00:19:26.990
I've got a web app there,
and there's a control panel.

00:19:32.960 --> 00:19:36.130
And there's Grumpy.

00:19:36.130 --> 00:19:41.200
Grumpy is attached to
some helium balloons,

00:19:41.200 --> 00:19:46.550
and I've got a little
Bluetooth controller on there.

00:19:46.550 --> 00:19:48.780
And this controller is
interesting in that it

00:19:48.780 --> 00:19:52.178
has a little propeller.

00:19:52.178 --> 00:19:53.675
[LAUGHTER]

00:19:58.589 --> 00:20:00.630
And we're going to see if
we can make Grumpy fly.

00:20:03.670 --> 00:20:07.200
So this particular
device has a way for you

00:20:07.200 --> 00:20:11.790
to control the speed of the
propeller and the rudder.

00:20:11.790 --> 00:20:13.980
You control the
direction left and right.

00:20:13.980 --> 00:20:16.711
So here I'm first
connecting to the device.

00:20:20.490 --> 00:20:26.241
Now that it's connected, I
can make Grumpy do stuff.

00:20:26.241 --> 00:20:27.240
What are we going to do?

00:20:31.120 --> 00:20:34.810
So I'm just setting
the rudder, and I'm

00:20:34.810 --> 00:20:36.200
starting the little engine.

00:20:36.200 --> 00:20:38.220
And you should see
Grumpy start moving.

00:20:38.220 --> 00:20:40.283
Can you see the little
propeller going there?

00:20:45.750 --> 00:20:49.730
It was really tricky
controlling this.

00:20:49.730 --> 00:20:53.160
It's not that easy
to move it around.

00:20:53.160 --> 00:20:54.750
But there you get the idea.

00:20:54.750 --> 00:20:55.690
Poor Grumpy.

00:20:55.690 --> 00:20:57.296
Grumpy is flying.

00:21:00.740 --> 00:21:04.710
So that's all doing basically
Bluetooth from a web page

00:21:04.710 --> 00:21:05.615
directly to a device.

00:21:09.355 --> 00:21:10.840
[APPLAUSE]

00:21:16.751 --> 00:21:17.250
OK.

00:21:17.250 --> 00:21:18.630
So let's talk about this magic.

00:21:18.630 --> 00:21:21.070
What is the Web Bluetooth API?

00:21:21.070 --> 00:21:23.620
So the Web Bluetooth
API is a specification

00:21:23.620 --> 00:21:26.150
that allows you to
talk from a web page

00:21:26.150 --> 00:21:29.000
to a device in a
very secured way.

00:21:29.000 --> 00:21:34.950
And secondly, it allows you to
communicate and control devices

00:21:34.950 --> 00:21:37.347
using Bluetooth Low Energy.

00:21:37.347 --> 00:21:39.180
So this is a standard,
Bluetooth Low Energy,

00:21:39.180 --> 00:21:41.310
that that's been
around for a while.

00:21:41.310 --> 00:21:44.120
Now, on web pages
that use this API,

00:21:44.120 --> 00:21:47.000
the user actually gets
prompted to select a device

00:21:47.000 --> 00:21:48.960
to connect to.

00:21:48.960 --> 00:21:51.590
Now, that's a little awkward
for the physical web use case--

00:21:51.590 --> 00:21:54.090
because remember, the user has
clicked on the notification--

00:21:54.090 --> 00:21:56.599
if they go to a page, and
then we prompt the user again

00:21:56.599 --> 00:21:58.140
to connect, when
the user has already

00:21:58.140 --> 00:22:01.290
kind of indicated an intent
to talk to that device.

00:22:01.290 --> 00:22:03.590
So we're working on
a solution for that,

00:22:03.590 --> 00:22:06.350
an update that will come soon
that will actually avoid that.

00:22:06.350 --> 00:22:08.390
So if the notification
launches a page that

00:22:08.390 --> 00:22:11.470
then goes to the web
page or to the device,

00:22:11.470 --> 00:22:13.740
we won't show that
chooser to the user.

00:22:13.740 --> 00:22:15.230
So it's a seamless experience.

00:22:15.230 --> 00:22:16.805
But at the moment,
it does show that.

00:22:16.805 --> 00:22:18.870
Now, this is actually
a very exciting API.

00:22:18.870 --> 00:22:20.630
It's a lot of fun to play with.

00:22:20.630 --> 00:22:22.770
And previously, the only
way you could do Bluetooth

00:22:22.770 --> 00:22:23.929
is to have a native app.

00:22:23.929 --> 00:22:25.220
Now you can do it from the web.

00:22:30.850 --> 00:22:31.670
OK.

00:22:31.670 --> 00:22:33.190
So previously,
remember I told you

00:22:33.190 --> 00:22:35.190
that when you had to
configure a beacon,

00:22:35.190 --> 00:22:38.130
you had to use the configuration
app from the beacon

00:22:38.130 --> 00:22:38.830
manufacturer.

00:22:38.830 --> 00:22:40.630
It's a native app, typically.

00:22:40.630 --> 00:22:42.870
Well, now that we have
the Web Bluetooth API,

00:22:42.870 --> 00:22:45.350
can't we use that to
configure the beacon?

00:22:45.350 --> 00:22:47.140
And the answer is
yes, we can, actually.

00:22:47.140 --> 00:22:50.340
So there is something called
the Eddystone URL Configuration

00:22:50.340 --> 00:22:51.070
Service.

00:22:51.070 --> 00:22:54.720
It allows you to set the
Eddystone URL parameters

00:22:54.720 --> 00:22:58.360
and transmission characteristics
that we looked at earlier.

00:22:58.360 --> 00:23:01.110
This web app here at that
URL was written by one

00:23:01.110 --> 00:23:02.840
of my colleagues, Francois.

00:23:02.840 --> 00:23:06.950
And it lets you fully configure
all the parameters you

00:23:06.950 --> 00:23:08.450
need for the physical
web, and it's

00:23:08.450 --> 00:23:10.870
using the Web Bluetooth API.

00:23:10.870 --> 00:23:13.730
So this is really great, because
now you can use this single web

00:23:13.730 --> 00:23:16.060
app to go and
configure any beacon

00:23:16.060 --> 00:23:19.040
from any manufacturer that
supports this configuration

00:23:19.040 --> 00:23:19.940
service.

00:23:19.940 --> 00:23:20.618
Very nice.

00:23:20.618 --> 00:23:21.992
[APPLAUSE]

00:23:27.590 --> 00:23:29.860
Now, the Web Bluetooth
API in this particular app

00:23:29.860 --> 00:23:32.030
works on Chrome OS.

00:23:32.030 --> 00:23:33.875
It works on Chrome
for Android M.

00:23:33.875 --> 00:23:36.170
It works on Chrome for Linux.

00:23:36.170 --> 00:23:38.110
And we're working on
support for Windows

00:23:38.110 --> 00:23:40.370
and Mac OS X. We want
this to work everywhere.

00:23:43.560 --> 00:23:45.290
OK, let's look at code.

00:23:45.290 --> 00:23:46.400
So how do you use the API?

00:23:46.400 --> 00:23:48.360
The API is actually very easy.

00:23:48.360 --> 00:23:51.594
So the first
section of the code,

00:23:51.594 --> 00:23:53.260
we're providing what's
called a faulter.

00:23:53.260 --> 00:23:56.000
And we're basically telling
the scanner for the Bluetooth

00:23:56.000 --> 00:23:58.890
devices that we're
interested in a device nearby

00:23:58.890 --> 00:24:02.440
that's supporting a service
called the warp engine service.

00:24:02.440 --> 00:24:03.380
OK?

00:24:03.380 --> 00:24:05.280
So Chrome will find it.

00:24:05.280 --> 00:24:06.930
It'll show a list to the user.

00:24:06.930 --> 00:24:09.350
The user picks it
from the chooser.

00:24:09.350 --> 00:24:13.280
And once the user has selected
it, the rest of the code

00:24:13.280 --> 00:24:16.230
is run asynchronously.

00:24:16.230 --> 00:24:20.290
The first thing we need to do
is actually make the connection.

00:24:20.290 --> 00:24:21.970
And then we do two more things.

00:24:21.970 --> 00:24:24.120
We try and find a service.

00:24:24.120 --> 00:24:27.820
In this case, we are trying to
find the warp engine service.

00:24:27.820 --> 00:24:29.850
And once we've got the
warp engine service,

00:24:29.850 --> 00:24:33.112
we can get the warp
factor characteristic.

00:24:33.112 --> 00:24:34.570
Now, the terminology
I'm using here

00:24:34.570 --> 00:24:36.740
is all standard Bluetooth
Low Energy concepts.

00:24:36.740 --> 00:24:38.870
This is not particular
to the Web Bluetooth API.

00:24:38.870 --> 00:24:41.250
Of course, the warp engine
is not a standard service.

00:24:44.050 --> 00:24:46.200
Once we've got the
characteristic,

00:24:46.200 --> 00:24:48.660
we can read values from
that characteristic.

00:24:48.660 --> 00:24:51.630
In this case, we are reading
the warp factor value

00:24:51.630 --> 00:24:53.220
from that characteristic.

00:24:53.220 --> 00:24:56.480
The API also allows you to
write values to the beacon.

00:24:56.480 --> 00:25:01.000
And it has a mechanism to
notify your code asynchronously

00:25:01.000 --> 00:25:04.080
when values change.

00:25:04.080 --> 00:25:05.500
So as you can see, very simple.

00:25:05.500 --> 00:25:06.320
This is it.

00:25:06.320 --> 00:25:07.650
This is the working code.

00:25:07.650 --> 00:25:09.690
The rest of it is
just making the UI.

00:25:09.690 --> 00:25:12.240
So it's very simple,
but very powerful.

00:25:12.240 --> 00:25:17.727
And this works with any
device that supports BLE.

00:25:17.727 --> 00:25:19.060
Let's look at another cool demo.

00:25:19.060 --> 00:25:21.110
So I wrote a sample
app that allows you

00:25:21.110 --> 00:25:23.510
to control a [INAUDIBLE] toy.

00:25:23.510 --> 00:25:25.270
And one of my
colleagues, Matthew,

00:25:25.270 --> 00:25:28.010
took this to the next level with
this really awesome web app.

00:25:28.010 --> 00:25:29.130
So I'm going to do a demo.

00:25:29.130 --> 00:25:30.726
Can we switch to
the demo, please?

00:25:43.570 --> 00:25:44.330
OK.

00:25:44.330 --> 00:25:47.480
If we can make that out?

00:25:47.480 --> 00:25:48.290
OK.

00:25:48.290 --> 00:25:51.400
So this is a web page.

00:25:51.400 --> 00:25:53.152
And when you load
the page, it actually

00:25:53.152 --> 00:25:54.610
prompts you to
connect to a device.

00:25:54.610 --> 00:25:56.100
So let's try and do that.

00:25:58.940 --> 00:26:01.190
And there is the chooser.

00:26:01.190 --> 00:26:02.370
And what are we choosing?

00:26:02.370 --> 00:26:06.250
Well, we're choosing Ali.

00:26:06.250 --> 00:26:08.940
So Ali is a Bluetooth device.

00:26:08.940 --> 00:26:11.699
So that it happens to be its ID.

00:26:11.699 --> 00:26:12.990
And now we're going to pair it.

00:26:12.990 --> 00:26:15.650
So we are pairing it, and
then the code is connecting.

00:26:15.650 --> 00:26:18.191
It's running basically that code
that I showed you, of course

00:26:18.191 --> 00:26:20.390
not the same characteristics.

00:26:20.390 --> 00:26:24.970
And so to show you this,
I'm going to put it here,

00:26:24.970 --> 00:26:26.890
and hopefully you can see it.

00:26:26.890 --> 00:26:32.130
So I'm going to use the UI to do
some interesting things to Ali.

00:26:32.130 --> 00:26:33.505
So there I'm
changing the colors.

00:26:39.196 --> 00:26:41.070
And I'm going to do
something very dangerous.

00:26:41.070 --> 00:26:42.695
I'm going to actually
try and move Ali.

00:26:48.780 --> 00:26:50.716
Scary.

00:26:50.716 --> 00:26:51.690
OK.

00:26:51.690 --> 00:26:52.674
Hope you get the idea.

00:26:55.400 --> 00:26:57.470
So Ali is actually
designed to run around,

00:26:57.470 --> 00:26:59.136
but I'm not going to
make it run around.

00:26:59.136 --> 00:27:01.860
I think I'm going to
freak out the cameraman.

00:27:01.860 --> 00:27:05.850
So what I did there was
just use the controller here

00:27:05.850 --> 00:27:06.930
to move Ali.

00:27:06.930 --> 00:27:08.840
And so it's turning
around as I'm

00:27:08.840 --> 00:27:11.510
adjusting the controller
and then the color.

00:27:11.510 --> 00:27:13.650
There's a little color
wheel to go and change

00:27:13.650 --> 00:27:15.230
the color of the device.

00:27:20.430 --> 00:27:21.000
OK.

00:27:21.000 --> 00:27:22.587
Can we go back to
the slides, please?

00:27:22.587 --> 00:27:23.988
[APPLAUSE]

00:27:29.950 --> 00:27:33.130
Here are some other
Web Bluetooth API

00:27:33.130 --> 00:27:34.550
apps that I created.

00:27:34.550 --> 00:27:36.270
They're all
open-source on GitHub.

00:27:36.270 --> 00:27:37.350
So there's a racing car.

00:27:37.350 --> 00:27:42.730
There's a little printer
and a little LED device.

00:27:42.730 --> 00:27:44.780
Now, these are all
off-the-shelf devices.

00:27:44.780 --> 00:27:47.050
No hacking required.

00:27:47.050 --> 00:27:48.520
They support BLE.

00:27:48.520 --> 00:27:49.414
Go and have fun.

00:27:52.430 --> 00:27:53.240
OK.

00:27:53.240 --> 00:27:57.770
So now you know how to implement
a physical web solution, right?

00:27:57.770 --> 00:27:59.990
We've covered all
the aspects of it.

00:27:59.990 --> 00:28:00.890
But why?

00:28:00.890 --> 00:28:02.987
Why would you want to do
a physical web solution?

00:28:02.987 --> 00:28:05.070
What are the opportunities
for you as a developer?

00:28:07.580 --> 00:28:11.030
Now, remember, Eddystone
is an open protocol.

00:28:11.030 --> 00:28:13.230
Everything about Eddystone
and the physical web

00:28:13.230 --> 00:28:14.760
has been open-sourced.

00:28:14.760 --> 00:28:17.020
All of our code is
sitting on GitHub.

00:28:17.020 --> 00:28:18.720
Go and take a look.

00:28:18.720 --> 00:28:22.400
The physical web works
across multiple beacons,

00:28:22.400 --> 00:28:25.780
multiple browsers,
multiple operating systems.

00:28:25.780 --> 00:28:27.960
Everything that I
showed you today

00:28:27.960 --> 00:28:31.970
doesn't require you to
use anything from Google.

00:28:31.970 --> 00:28:34.300
Now, the physical
web is also ideal

00:28:34.300 --> 00:28:36.610
for long-tail applications.

00:28:36.610 --> 00:28:39.560
Your user doesn't have to
download an app and install it.

00:28:39.560 --> 00:28:42.740
You don't have to
maintain that native app.

00:28:42.740 --> 00:28:45.630
The user experience for the
physical is also consistent.

00:28:45.630 --> 00:28:47.480
It's always, there's
a notification,

00:28:47.480 --> 00:28:49.060
the user clicks on
the notification,

00:28:49.060 --> 00:28:50.340
it loads a web page.

00:28:50.340 --> 00:28:53.050
The web page can do
amazing things now.

00:28:53.050 --> 00:28:56.060
So that's great from a user
education point of view.

00:28:58.970 --> 00:29:01.280
Now, since you can do
Bluetooth from a web page,

00:29:01.280 --> 00:29:03.660
now you have opportunities
you didn't have before,

00:29:03.660 --> 00:29:07.350
because it opens up the whole
growing IoT market to you now,

00:29:07.350 --> 00:29:09.360
as a developer.

00:29:09.360 --> 00:29:12.760
You don't need to build
native apps to control

00:29:12.760 --> 00:29:14.052
embedded devices anymore.

00:29:16.650 --> 00:29:19.670
So let's do a recap.

00:29:19.670 --> 00:29:26.120
The physical web is an open,
new, intuitive ecosystem.

00:29:26.120 --> 00:29:28.990
It's all based on
open standards.

00:29:28.990 --> 00:29:33.480
We have Eddystone, which is an
open beacon messaging format.

00:29:33.480 --> 00:29:39.510
You can control Bluetooth
devices, Bluetooth LE.

00:29:39.510 --> 00:29:42.220
Eddystone beacons can be
configured to support URLs.

00:29:42.220 --> 00:29:44.460
They broadcast in the
URLs, and anybody around it

00:29:44.460 --> 00:29:46.850
can pick it up and do
what they want with that.

00:29:46.850 --> 00:29:50.130
That makes the
physical web possible.

00:29:50.130 --> 00:29:51.960
Various browsers and
operating systems

00:29:51.960 --> 00:29:55.200
are implementing support for
this and scan for the URLs

00:29:55.200 --> 00:29:58.180
nearby.

00:29:58.180 --> 00:30:02.260
And when the user clicks on
notifications for those URLs,

00:30:02.260 --> 00:30:03.500
it loads a web page.

00:30:03.500 --> 00:30:06.772
That web page can be loaded by
any browser, not just Chrome.

00:30:09.880 --> 00:30:12.340
So this is really a
very exciting area

00:30:12.340 --> 00:30:14.350
to explore and very
easy to get started.

00:30:17.360 --> 00:30:19.000
So what's next?

00:30:19.000 --> 00:30:21.310
Well, go and play.

00:30:21.310 --> 00:30:23.180
It's a lot of fun.

00:30:23.180 --> 00:30:25.920
You have everything you
need to be able to do

00:30:25.920 --> 00:30:27.710
this yourself right now.

00:30:27.710 --> 00:30:29.650
So here are some useful links.

00:30:29.650 --> 00:30:32.050
We've got a lot of
stuff on GitHub.

00:30:32.050 --> 00:30:34.750
It's still very early
days for this technology,

00:30:34.750 --> 00:30:37.952
so we'd love to
get your feedback.

00:30:37.952 --> 00:30:39.660
Your feedback can
actually have an impact

00:30:39.660 --> 00:30:42.206
on the direction in which
this technology will go.

00:30:45.230 --> 00:30:47.360
And now the main reason
you're here, of course,

00:30:47.360 --> 00:30:49.580
is the free stuff.

00:30:49.580 --> 00:30:52.150
So we're handing out some
test beacons this afternoon.

00:30:52.150 --> 00:30:54.180
It's in the Mobile Web Sandbox.

00:30:54.180 --> 00:30:56.317
It's somewhere in
that direction.

00:30:56.317 --> 00:30:57.900
So these are test
beacons, and they've

00:30:57.900 --> 00:31:01.270
been loaded with firmware
that supports that Eddystone

00:31:01.270 --> 00:31:03.410
configuration service
that I mentioned before.

00:31:03.410 --> 00:31:05.840
So you can go to that web
page and go and configure

00:31:05.840 --> 00:31:08.720
that beacon.

00:31:08.720 --> 00:31:13.220
[APPLAUSE]

00:31:15.320 --> 00:31:20.470
[MUSIC PLAYING]

