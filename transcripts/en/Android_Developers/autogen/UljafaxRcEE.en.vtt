WEBVTT
Kind: captions
Language: en

00:18:55.462 --> 00:18:59.888
  Hey, good morning, everyone.  
We invite you to take your 

00:19:00.198 --> 00:19:06.304
seats.  As a courtesy to the 
presenters, we ask everyone to 

00:19:06.610 --> 00:19:09.639
mute their devices at this time.
Good morning.  And, welcome 

00:19:35.987 --> 00:19:37.987
back. 

00:24:25.948 --> 00:24:32.957
  Everyone, good morning.  Will 
you please welcome back to the 

00:24:34.354 --> 00:24:36.354
stage, dan

00:24:37.400 --> 00:24:40.629
DPAN dan. 
  Thank you for getting here 

00:24:40.630 --> 00:24:44.391
bright and early in the morning.
We said things were starting a 

00:24:44.392 --> 00:24:48.459
half an hour early.  Welcome to 
everyone on the livestream and 

00:24:48.460 --> 00:24:52.984
all the people who were watching
on our viewing parties.  One is 

00:24:52.985 --> 00:24:56.960
we do not have lightning talks 
today.  Please, you know, try to

00:24:56.961 --> 00:25:02.703
stay for both 20-minute 
sessions, if you can.  Check the

00:25:04.023 --> 00:25:07.637
schedule, one more time, to make
sure you don't miss your 

00:25:07.927 --> 00:25:11.932
favorite.  
As you noticed, there was a 

00:25:12.604 --> 00:25:19.591
schedule change.  The D8 and R8 
talk is not happening.  

00:25:19.592 --> 00:25:23.392
Mr. Wharton has a special 
project and we congratulate him 

00:25:23.393 --> 00:25:30.513
on that.  Instead, we'll have 
Trash Talk.  

00:25:30.514 --> 00:25:39.758
But, the exciting part, right 
now, is we have an esteemed 

00:25:40.194 --> 00:25:44.697
group talking about foldable.

00:25:52.642 --> 00:25:57.618
[Applause]
  Good morning, everyone.  My 

00:25:57.879 --> 00:26:02.440
name is Adrian Roos.  I'm a 
software engineer.

00:26:02.441 --> 00:26:07.722
I'm Andrii and I work on 
multi-display. 

00:26:07.723 --> 00:26:11.505
I'm Jisun, I'm engineering 
director.

00:26:11.506 --> 00:26:18.547
By now, I'm sure you've seen the
announcement that we're 

00:26:18.801 --> 00:26:21.848
partnering with Samsung and 
we're diving deeper into what 

00:26:22.433 --> 00:26:29.306
that means, what we're doing to 
support developers for foldable 

00:26:29.762 --> 00:26:34.873
devices.  Jisun is here to talk 
more about what Samsung is 

00:26:35.188 --> 00:26:41.026
doing.  So, with that, I'm going
to hand it over to Jisun.

00:26:41.027 --> 00:26:47.133
Thank you.  So, again, I'm Jisun
from Samsung Mobile and I'm 

00:26:47.134 --> 00:26:52.414
going to talk about the new form
factor device, which you 

00:26:54.555 --> 00:27:01.952
announced at the Samsung 
Developer Conference.  Okay.  

00:27:02.412 --> 00:27:05.926
So, I will cover more 
information about the device, 

00:27:06.235 --> 00:27:10.657
itself, and also, we'll talk 
about the experience, the new 

00:27:11.029 --> 00:27:14.286
foldable device will bring to 
the users.  

00:27:14.287 --> 00:27:17.911
We all know that the smartphone 
has been providing new 

00:27:18.323 --> 00:27:22.991
experiences for the last 10 
years.  And it actually changes 

00:27:22.992 --> 00:27:28.648
the way people think, act and 
also communicate.  Additionally,

00:27:29.007 --> 00:27:32.484
it also opened up a lot of new 
opportunities for the 

00:27:32.886 --> 00:27:37.665
developers.  Now, we believe a 
foldable phone is one of the 

00:27:38.864 --> 00:27:40.864
next game-changers, which will 
provide a very unique experience

00:27:41.080 --> 00:27:46.370
to the users and also new 
opportunities for the developers

00:27:46.620 --> 00:27:54.079
to drive innovations.  
Okay.  So, now let's talk about 

00:27:54.693 --> 00:27:57.076
the first Samsung foldable 
phone.  The first

00:28:00.918 --> 00:28:02.503
Samsung foldable phone is 
designed to be multi-display 

00:28:02.504 --> 00:28:09.167
with two screens and also 
supports multi-activity window. 

00:28:09.538 --> 00:28:16.275
So, let's take a first look at 
what the actual configuration on

00:28:16.539 --> 00:28:21.030
the display actually looks like.
So, this is the main display, 

00:28:21.031 --> 00:28:25.763
when the device is unfolded.  
The main display is large enough

00:28:25.764 --> 00:28:33.955
to provide a very unique 
experience.  The experience 

00:28:34.372 --> 00:28:38.343
becomes richer and more 
immersive.  The experience was 

00:28:38.878 --> 00:28:47.774
hardly achievable, even from the
larger screen smartphones.  

00:28:47.775 --> 00:28:55.019
In addition to the experience 
from a single larger screen, two

00:28:56.608 --> 00:29:00.331
multi-tasking will become 
available to utilize this larger

00:29:01.312 --> 00:29:07.373
screen with up to three 
multi-active windows.  

00:29:07.374 --> 00:29:11.866
When the phone is actually 
folded, we still have very 

00:29:12.225 --> 00:29:16.565
useful and portable cover 
display to use.  In this mode, 

00:29:17.103 --> 00:29:21.205
the experience is very similar 
to your daily smartphone use, 

00:29:22.004 --> 00:29:27.670
but compared to the main 
display, the experience is more 

00:29:29.538 --> 00:29:35.837
to be focused and handy and 
quick interaction, to actually 

00:29:36.528 --> 00:29:40.240
leverage the small screen.  
So, having said that, here are 

00:29:40.558 --> 00:29:46.079
some numbers that you may be 
interested in.  This is the 

00:29:46.371 --> 00:29:53.215
specs and the dimensions of the 
actual screens.  So, 4.5-inch 

00:29:53.216 --> 00:30:02.862
cover display provides 21:9HD 
plus resolution and a 

00:30:05.501 --> 00:30:13.200
320DP.  
7.3-inch main display 4.2 plus 

00:30:13.812 --> 00:30:22.363
resolution with the same 420DP 
with 585DP is the smallest 

00:30:22.364 --> 00:30:27.382
width.  These are the numbers 
you may need to know.  

00:30:27.383 --> 00:30:31.871
Now I will show you some 
expected user experience with 

00:30:32.557 --> 00:30:38.885
some examples. So, comparing the
experience between the existing 

00:30:39.179 --> 00:30:45.312
smartphone and fold main 
display, the foldable is 

00:30:45.893 --> 00:30:50.126
foldable and can locate larger 
to the application and it 

00:30:50.538 --> 00:30:54.382
actually enables the contents, 
on the screen, to be richer and 

00:30:54.383 --> 00:31:02.243
more detailed, as you can see 
from the screen.  

00:31:02.244 --> 00:31:06.549
On the cover screen, when device
is folded, I said the experience

00:31:06.885 --> 00:31:12.410
can be optimized to provide 
quick and easy access and 

00:31:12.411 --> 00:31:17.722
interaction.  While the device 
is fully-functional, like a 

00:31:18.041 --> 00:31:24.281
normal smartphone.  
Access to the quick panel or 

00:31:25.875 --> 00:31:29.152
notification or call or 
messaging is good to highlight 

00:31:29.764 --> 00:31:33.505
the cover display.  We know that
you may not want to unfold your 

00:31:33.506 --> 00:31:37.220
phone to take an incoming call. 

00:31:40.826 --> 00:31:47.268
While the cover display and main
display, each one provides its 

00:31:48.175 --> 00:31:53.825
own very unique experience.  It 
is between them, not separate 

00:31:53.826 --> 00:31:59.263
nor disconnected.  Rather, the 
user experience, between the 

00:31:59.533 --> 00:32:04.541
display, is very continuous and 
connected seamlessly. 

00:32:08.598 --> 00:32:13.712
As an example, if you want to 
search for the location of the 

00:32:14.029 --> 00:32:17.496
center from a map, you can do 
that with your phone folded.  

00:32:18.643 --> 00:32:22.304
However, if you unfold your 
phone, the application still 

00:32:22.607 --> 00:32:27.204
continues to run.  Even more, 
unfolding the phone actually 

00:32:28.023 --> 00:32:32.987
provide more information with 
more visual cues, like what's 

00:32:33.958 --> 00:32:39.472
nearby and what's the location 
to the other point of interest. 

00:32:41.039 --> 00:32:44.557
Using the gallery app is 
similar.  The app experience 

00:32:45.089 --> 00:32:52.849
continues between the folded 
mode and also the unfolded mode.

00:32:52.850 --> 00:32:58.055
Multi-active windows for 
multi-tasking is also one of the

00:32:58.583 --> 00:33:03.013
key features.  So, while 
watching a YouTube video, if you

00:33:03.014 --> 00:33:05.652
want to browse a website, you 
can just

00:33:08.993 --> 00:33:15.950
open up a browser and browse the
website while your video keeps 

00:33:16.238 --> 00:33:20.647
playing.  
Moreover, if your friend sends 

00:33:20.940 --> 00:33:25.923
messages and the notification 
pops up, it can grab the 

00:33:26.426 --> 00:33:30.611
notification and drag it to a 
third window, like this, to 

00:33:30.612 --> 00:33:35.362
continue chatting and browsing, 
while your video still keeps 

00:33:35.772 --> 00:33:40.390
playing.  
So, we have this expected 

00:33:40.391 --> 00:33:44.689
experience with the new foldable
device, so now Adrian, from 

00:33:45.938 --> 00:33:50.246
Google, will talk about 
developer guide and also some 

00:33:50.247 --> 00:33:54.525
Android support to make your 
applications better-fit for the 

00:33:54.526 --> 00:33:58.490
foldables.
  Thanks for sharing that, 

00:33:59.358 --> 00:34:01.358
Jisun.

00:34:02.802 --> 00:34:06.052
[Applause]
  So, let's talk a bit more 

00:34:06.676 --> 00:34:10.777
about how you can take advantage
of foldables in your apps and 

00:34:10.778 --> 00:34:16.334
kind of the guidelines we could 
recommend to do so.  So, first 

00:34:17.637 --> 00:34:22.702
up is screen continuity.  It's 
what we call the concept of 

00:34:23.392 --> 00:34:25.889
continuing what you're currently
doing after you fold or unfold 

00:34:26.593 --> 00:34:31.951
the device.  And, an example 
here, we have -- you have a map.

00:34:31.952 --> 00:34:36.014
You're looking at on a folded 
device.  And, you would like to 

00:34:36.015 --> 00:34:39.110
see maybe a bit more about the 
surroundings of the place you're

00:34:39.420 --> 00:34:45.496
looking at.  So, as a user, you 
unfold the phone and with the 

00:34:46.180 --> 00:34:49.066
continuous experience, we're 
still looking at the same place,

00:34:49.067 --> 00:34:54.294
your state is maintained and the
phone can take a bit more 

00:34:54.295 --> 00:34:58.786
advantage of the form factor.  
And this is actually not really 

00:34:58.787 --> 00:35:02.198
a new thing in Android, right?  
We've had to deal with similar 

00:35:02.493 --> 00:35:08.186
situations before, with things 
like screen rotation or changing

00:35:08.187 --> 00:35:15.487
-- changing screen sizes or -- 
sorry.  Changing window sizes in

00:35:16.574 --> 00:35:20.091
multi-window.  
So, why should you care about 

00:35:20.678 --> 00:35:23.249
continuity when you build your 
app?  Well users unfold their 

00:35:24.719 --> 00:35:28.648
devices for a reason and usually
that's because they want to dive

00:35:28.649 --> 00:35:32.912
deeper into the task they're 
currently doing.  So, that 

00:35:33.314 --> 00:35:36.626
really works best when they are 
not interrupted in their 

00:35:37.134 --> 00:35:40.365
experience when doing so and can
continue where they left off 

00:35:40.366 --> 00:35:45.625
before unfolding.  
So, for a satisfying user 

00:35:46.208 --> 00:35:48.296
experience, it's really 
important that this works well. 

00:35:48.627 --> 00:35:51.980
That seems great.  Now, how do 
you actually pull this off?  

00:35:52.272 --> 00:35:56.242
Well, as I said, Android is 
familiar with this and we've 

00:35:56.725 --> 00:35:59.876
built a system to deal with 
that.  Folding and unfolding the

00:36:00.888 --> 00:36:04.198
device will be treated as a 
configuration change in the 

00:36:04.503 --> 00:36:08.759
screen size and screen layout 
categories.  And, to support you

00:36:08.760 --> 00:36:14.223
with that, the Android system, 
by default, re-creates your 

00:36:14.851 --> 00:36:18.173
activities when a configuration 
change happens.  

00:36:18.174 --> 00:36:22.716
This has the advantage of taking
care of any layout changes you 

00:36:23.247 --> 00:36:25.247
might want to make when taking 
advantage of the new 

00:36:26.237 --> 00:36:30.310
configuration.  But it also 
means that you, as the app, are 

00:36:31.634 --> 00:36:34.965
responsible for restoring the 
state the user was in after that

00:36:34.966 --> 00:36:42.506
activity's re-created.  
To support with that, we have a 

00:36:42.954 --> 00:36:46.370
state facility and introducing a
new Jetpack library called 

00:36:46.632 --> 00:36:48.858
ViewModel to support you with 
that.  

00:36:48.859 --> 00:36:51.830
Alternatively, you could also 
decide to handle the 

00:36:52.632 --> 00:36:57.189
configuration change yourself by
just applying it and adjusting 

00:36:57.190 --> 00:37:00.702
your layout.  To do that, you 
can declare that you can handle 

00:37:01.664 --> 00:37:08.304
the configuration change in your
manifest, but that means you'll 

00:37:09.560 --> 00:37:13.798
have to manually adjust the 
screen size. 

00:37:13.799 --> 00:37:19.847
Make sure to correctly implement
multi-window and declare your 

00:37:20.608 --> 00:37:24.485
activity as resizable.  
Now, next up, we're making some 

00:37:24.820 --> 00:37:29.692
changes to the lifecycle in 
multi-window.  You can see the 

00:37:29.970 --> 00:37:33.651
current behavior on the left.  
That is that only the activity 

00:37:34.130 --> 00:37:38.662
that the user last touched is in
the resumed state while all the 

00:37:38.932 --> 00:37:43.107
other are in the paused state.  
That's a bit confusing to users 

00:37:44.053 --> 00:37:51.523
because it's not immediately 
able to see why some are in a 

00:37:51.524 --> 00:37:54.835
less interactive state and it's 
one more thing you have to keep 

00:37:57.122 --> 00:38:03.054
in mind, as a developer, when 
you target multi-window.  We're 

00:38:03.317 --> 00:38:06.892
introducing multi-resume mode.  
It's pretty simple, really.  All

00:38:07.182 --> 00:38:11.541
the activities in multi-window 
that are at the top and are 

00:38:12.403 --> 00:38:16.621
visible are all in the resume 
state.  

00:38:16.622 --> 00:38:20.050
Now, Android Pie didn't ship 
with this behavior originally 

00:38:20.700 --> 00:38:24.227
and so we're making this an 
opt-in behavior in Android Pie. 

00:38:24.483 --> 00:38:30.224
It will only be applied with the
app developer ops in and the 

00:38:30.860 --> 00:38:33.605
device manufacturer actually 
implements this feature 

00:38:33.966 --> 00:38:40.220
according to our spec.  
But note that in future versions

00:38:40.635 --> 00:38:50.352
of Android, we're expecting to 
make this mandatory behavior.  

00:38:50.834 --> 00:38:54.467
So, let's say you have an app 
and want to take advantage of 

00:38:55.517 --> 00:39:03.017
this simplified lifecycle, how 
do you opt in?  Again, you add 

00:39:03.310 --> 00:39:08.097
one flag to your Android 
manifest.  There's one caveat, 

00:39:08.430 --> 00:39:13.714
though, because there are 
multiple activities that can be 

00:39:13.715 --> 00:39:18.716
resumed at the same time.  Be 
really cautious around code that

00:39:19.200 --> 00:39:24.762
stores the one resumed activity 
because there might now be more 

00:39:25.110 --> 00:39:29.610
than one of those.  Be cautious 
around libraries and frameworks 

00:39:30.107 --> 00:39:32.678
that might make the same 
assumptions.  

00:39:32.679 --> 00:39:40.163
And with, that I'm going to hand
it over to Andrii, who is going 

00:39:42.294 --> 00:39:45.068
to talk about 
multi-window/multi-display.

00:39:45.826 --> 00:39:54.591
So, let's talk a bit more about 
multi-screen devices.  A

00:39:56.522 --> 00:39:59.889
an activity can be launched on a
display.  Let's see what it 

00:40:00.181 --> 00:40:03.742
actually means for your 
activity.  First of all, when an

00:40:04.532 --> 00:40:09.114
activity is on a non-default 
display, the activity context is

00:40:09.115 --> 00:40:12.273
different from non-visual 
application context, also 

00:40:12.474 --> 00:40:15.663
available from broadcast 
receivers and content providers.

00:40:15.939 --> 00:40:21.485
The context of a visible entity 
will be adjusted for the display

00:40:21.760 --> 00:40:25.488
area where it is shown.  If you 
use the same API to get the 

00:40:25.752 --> 00:40:29.124
current display and use a 
different context type to ask 

00:40:29.125 --> 00:40:33.348
for it, you will get different 
results.  The current display, 

00:40:33.349 --> 00:40:36.959
you can get, is from the 
activity and the application 

00:40:37.142 --> 00:40:43.076
context will always give you the
default display.  

00:40:43.077 --> 00:40:48.316
Different context also mean 
different resources and 

00:40:48.317 --> 00:40:51.048
configurations.  It will be 
automatically updated for you.  

00:40:51.373 --> 00:40:56.149
All you need to do is request 
them from the correct context.  

00:40:56.150 --> 00:41:04.187
When you want to adjust your UX,
you should be using an activity.

00:41:04.188 --> 00:41:07.157
Keep in mind that the user may 
move your activity from one 

00:41:07.506 --> 00:41:12.427
screen to another at any point. 
In most cases, you can expect 

00:41:12.704 --> 00:41:15.406
this place to have different 
sizes, densities and 

00:41:15.712 --> 00:41:20.414
resolutions.  This means the 
activity that was muted will get

00:41:20.415 --> 00:41:24.673
the configuration change.  If it
is declared to handle the 

00:41:24.674 --> 00:41:30.231
change, it will be notified with
the new config.  If not, it'll 

00:41:30.955 --> 00:41:35.168
be launched.  
To deliver the best experience, 

00:41:35.169 --> 00:41:40.962
we encourage you to handle 
configuration changes whenever 

00:41:40.963 --> 00:41:48.917
it's possible and if your app 
needs to know what display, you 

00:41:48.918 --> 00:41:53.858
can find it on ondisplay.  
What if you want to take 

00:41:54.151 --> 00:41:57.134
advantage of these additional 
screens?  How do you use them?  

00:41:58.827 --> 00:42:00.827
The first step is

00:42:02.911 --> 00:42:05.416
to get information about the 
displays. 

00:42:05.417 --> 00:42:10.947
You can check their flags, 
metrics and states. For example,

00:42:11.807 --> 00:42:16.209
you can look for live screen to 
provide media content or filter 

00:42:16.210 --> 00:42:20.453
out the displays that are 
currently off.  

00:42:20.454 --> 00:42:23.222
Once you have determined what 
display you want to use, you can

00:42:23.223 --> 00:42:29.540
launch your activity there using
the activity options API, 

00:42:32.470 --> 00:42:36.250
available in Android I/O.  If 
you want a new instance of an 

00:42:38.090 --> 00:42:43.143
activity, you may want to use 
corresponding flags and use new 

00:42:43.947 --> 00:42:46.667
task for this launch.  
Sometimes the system may 

00:42:47.898 --> 00:42:51.406
restrict activity launches to 
some certain displays, for 

00:42:52.159 --> 00:43:01.315
example, private displays.  You 
can expect this. 

00:43:03.172 --> 00:43:07.676
Remember that there are several 
platforms that actually have 

00:43:08.100 --> 00:43:12.398
multi-display devices.  Phones 
is one example we have covered 

00:43:12.399 --> 00:43:15.006
today.  
Next, there is desktop mode.  

00:43:15.207 --> 00:43:19.610
When you connect your phone to a
larger screen for improved 

00:43:20.033 --> 00:43:23.313
productivity or entertainment.  
Android apps running on Chrome 

00:43:23.593 --> 00:43:27.899
OS.  In both of these cases, the
apps are usually running in 

00:43:28.186 --> 00:43:31.966
free-form mode and the user 
expects them to be freely and 

00:43:31.967 --> 00:43:37.394
smoothly resizable.  
Last but not least is automotive

00:43:38.292 --> 00:43:43.101
Android.  There may be many 
screens in a car.  For example, 

00:43:43.102 --> 00:43:46.484
kids in the back seats may be 
playing same or different games 

00:43:47.144 --> 00:43:50.603
while the driver is using 
navigation.  

00:43:50.604 --> 00:43:54.400
For apps, in general, there 
shouldn't be too many 

00:43:54.826 --> 00:43:59.497
differents.  To verify your app 
behavior, on any Android device 

00:43:59.803 --> 00:44:03.827
running O or above, you can 
create a simulated display and 

00:44:04.121 --> 00:44:09.774
launch your activity there.  
At this moment, simulated 

00:44:09.950 --> 00:44:13.562
display does not handle touch.  
We are working on improving this

00:44:13.563 --> 00:44:17.996
and we are going to be adding 
new developer tools.  

00:44:17.997 --> 00:44:24.084
With all this new and existing 
platforms, you can choose to 

00:44:24.476 --> 00:44:30.476
optimize your app and build a 
multi-screen experience.  You 

00:44:30.785 --> 00:44:34.352
can test your app and set 
corresponding launch modes.  

00:44:34.353 --> 00:44:39.832
Don't forget that in this case, 
multiple activities may be 

00:44:40.164 --> 00:44:46.470
focused.  Also consider using 
the shared data and take 

00:44:47.030 --> 00:44:54.456
advantage of other Architecture 
Components.

00:44:54.457 --> 00:44:59.276
[Applause]
  So, we've talked about what's 

00:44:59.649 --> 00:45:03.615
available today.  Let's look 
more at what's going to be in 

00:45:03.616 --> 00:45:09.387
the future with foldables and 
multi-display devices.  In the 

00:45:09.680 --> 00:45:13.510
short-term, for Android Pie, 
we're working on developer 

00:45:13.511 --> 00:45:20.811
guidelines and we're going to 
show you how to best-target 

00:45:21.529 --> 00:45:25.185
foldables and multi-display 
devices.  We're also working on 

00:45:25.186 --> 00:45:28.745
a blog post that's going to go 
live, which will have more 

00:45:29.074 --> 00:45:31.892
information about everything we 
talked about.  And we're also 

00:45:32.176 --> 00:45:35.935
working with Samsung to release 
an emulator where we can develop

00:45:35.936 --> 00:45:40.690
and test your apps against the 
configuration change behaviors 

00:45:41.565 --> 00:45:46.653
and the multi-resume behaviors 
that their device is going to 

00:45:47.017 --> 00:45:50.979
have.  
Looking a bit more into the 

00:45:51.256 --> 00:45:56.467
future, with future versions of 
Android, we're implementing 

00:45:58.041 --> 00:46:00.405
support for foldables and 
multi-display devices and as 

00:46:00.675 --> 00:46:05.587
part of this, we're also going 
to improve the emulator, so it 

00:46:05.985 --> 00:46:10.347
will have support for simulating
all those foldable and 

00:46:12.274 --> 00:46:17.782
multi-display behaviors, as 
Andrii also mentioned.  

00:46:17.783 --> 00:46:24.963
Finally, some pointers on where 
you can find more information.  

00:46:25.633 --> 00:46:29.721
In the following days, we'll 
have this blog post up.  There's

00:46:29.722 --> 00:46:32.428
a Samsung developer site where 
you will find more information 

00:46:32.720 --> 00:46:37.435
about Samsung's devices and 
their guidelines and for testing

00:46:37.436 --> 00:46:41.677
your apps, the Samsung emulator 
will also be available on their 

00:46:42.410 --> 00:46:47.900
website some time in Q4.  
Okay.  At this point, I would 

00:46:48.237 --> 00:46:52.949
also like to thank you for all 
the amazing experiences you 

00:46:53.282 --> 00:46:55.845
developers are building for 
Android and we're really excited

00:46:56.438 --> 00:46:59.677
to see what you will do next and
what you will do next on this 

00:47:00.719 --> 00:47:05.970
next form factor of foldable 
devices.  Thank you.

00:47:15.731 --> 00:47:17.638
[Applause]
be in the Q&amp;A area where you can

00:47:17.639 --> 00:47:20.660
talk to us later, in the next 
break.  

00:47:34.033 --> 00:47:38.272
  All right.  I just wanted to 
have a few minor things.  One is

00:47:38.759 --> 00:47:44.684
that you noticed that we're 
going to have these Q&amp;A slides. 

00:47:44.976 --> 00:47:49.576
These have these QR codes and 
those allow you to rate all of 

00:47:50.831 --> 00:47:56.659
the sessions here at the Android
Dev Summit.  Please let us know.

00:47:56.660 --> 00:48:02.443
We did a lot of experimentation 
with content this time.  

00:48:02.444 --> 00:48:10.111
Second thing is, I know we 
didn't have the D8 and R8 talk, 

00:48:10.112 --> 00:48:16.398
but we have the engineering lead
out in the sandbox area.  If 

00:48:17.320 --> 00:48:22.212
you're interested in R8, please 
go out and ask questions in the 

00:48:22.537 --> 00:48:26.208
sandbox area.  You can rate all 
the sessions, all day long, 

00:48:26.865 --> 00:48:34.773
today, from the single QR code. 
So, thank you very much.  Enjoy 

00:48:34.774 --> 00:48:36.774
the rest of your day. 

00:48:39.938 --> 00:48:45.594
  Everyone, the next session, in
this room, will commence at 

00:48:46.167 --> 00:48:48.169
10:20 a.m.  Thank you. 

01:11:29.416 --> 01:11:36.261
  Everyone, welcome back.  We 
invite you to take your seats.  

01:11:36.262 --> 01:11:43.675
Our program is going to be under
way in three minutes.  As a 

01:11:44.355 --> 01:11:48.793
courtesy to our presenters, 
please mute your devices.  

01:11:48.794 --> 01:11:50.794
Welcome, everyone.  Please be 

01:12:29.553 --> 01:12:31.553
seated. 

01:15:20.078 --> 01:15:27.290
[Applause]
  Good morning.  I'm Chris.

01:15:27.291 --> 01:15:32.197
And I'm Alan. 
  We're here to talk about 

01:15:32.198 --> 01:15:40.007
pixels.  We need to think about 
the actual technologies.  There 

01:15:40.700 --> 01:15:48.916
are two prevailing technologies,
LCD.  The majority of devices 

01:15:48.917 --> 01:15:51.690
are screens, from the mid-level 
to the 

01:15:55.510 --> 01:15:58.134
high-level.  And even in 
platforms, they're moving to 

01:15:58.135 --> 01:16:04.529
that, as well.  
LCD stands for liquid crystal 

01:16:06.134 --> 01:16:10.462
display.  They work with what 
they call liquid crystals so 

01:16:11.202 --> 01:16:13.824
each pixel is made up of a color
channel.  They require a 

01:16:15.238 --> 01:16:20.968
backlite.  So, those liquid 
crystals don't illuminate 

01:16:20.969 --> 01:16:26.811
themselves.  Now, most of the 
power for an LCD display goes 

01:16:27.713 --> 01:16:34.704
into that backlite.  So, more 
brightness is more power.  

01:16:34.705 --> 01:16:42.350
Olet displays are diodes, which 
actually emit light themselves 

01:16:42.628 --> 01:16:46.509
so there's no need for a 
backlight.  The good thing, 

01:16:46.915 --> 01:16:52.127
here, is that they allow a true 
black.  So, with LCD, the way 

01:16:52.128 --> 01:16:57.956
you achieve black is by turning 
all the crystals on so you can 

01:16:58.487 --> 01:17:00.487
never really get that dark 
black.  

01:17:00.488 --> 01:17:04.655
Olets are different.  They don't
turn the pixel on and that's how

01:17:04.656 --> 01:17:07.978
you get black.  That's where the
power is.  

01:17:07.979 --> 01:17:09.979
And the

01:17:11.453 --> 01:17:16.997
power is powered by emitting 
light.  

01:17:16.998 --> 01:17:23.023
Now, there's a number of 

01:17:28.012 --> 01:17:35.770
arrangements, you have R, G and 
B.  So, let's more 

01:17:36.451 --> 01:17:38.451
straightforward

01:17:39.552 --> 01:17:46.739
and mentally simple.  There's 
more complex ones, like RGBR.  

01:17:46.740 --> 01:17:51.534
Each pixel only has two 
channels.  It's a way of 

01:17:51.898 --> 01:17:55.866
expanding pixel size without 
fitting as many LEDs in it.  

01:17:56.133 --> 01:18:04.906
In terms of power, more LEDs 
equal more power usage.  We've 

01:18:05.819 --> 01:18:10.116
done stats over the last year or
two and the display tends to be 

01:18:13.617 --> 01:18:19.512
the biggest power user of your 
device.  You see a chart, the 

01:18:19.869 --> 01:18:24.619
display, the more power it uses.
Everyone assumes this is the 

01:18:24.620 --> 01:18:28.730
case.  But the thing is, it's 
actually quite linear.  Again, 

01:18:29.537 --> 01:18:33.330
kind of simple.  
But then we start comparing oled

01:18:34.414 --> 01:18:39.628
devices versus LCD screens and 
it's the pixel versus that.  We 

01:18:39.968 --> 01:18:43.937
have a screenshot of maps in a 
normal day mode and a night 

01:18:44.298 --> 01:18:48.176
mode.  The reason we use a 
screenshot is because we didn't 

01:18:48.581 --> 01:18:55.620
want the differences been iOS or

01:18:58.588 --> 01:19:03.395
Android to show it.  
The actually amperage on night 

01:19:04.110 --> 01:19:07.675
and day is the same.  That 
doesn't change because it's an 

01:19:09.888 --> 01:19:18.136
LCD screen.  But on the pixel 
itself, because it's an oled 

01:19:18.407 --> 01:19:24.006
display, the power drops down by
63%.  The biggest power user on 

01:19:24.007 --> 01:19:26.474
your device, by using a dark 
theme. 

01:19:26.475 --> 01:19:29.338
Going more into it, when you 
have individual pixel colors -- 

01:19:29.630 --> 01:19:33.611
so, we did a test where we 
displayed one color on the 

01:19:34.273 --> 01:19:38.703
display.  And, the actual color,
itself, makes a difference in 

01:19:39.419 --> 01:19:46.619
power.  Blue is 24% more power 
than, say, green or red.  And 

01:19:46.792 --> 01:19:51.148
then, another chart, which is 
pretty much a summary of the 

01:19:51.734 --> 01:19:55.145
previous chart, but you can see 
the black is using the least 

01:19:55.611 --> 01:20:00.792
amount of power.  It goes up and
up until we get white.  Because 

01:20:01.183 --> 01:20:05.935
white uses channels for every 
one, it's full red, full green, 

01:20:06.224 --> 01:20:10.472
full blue, it requires the most 
amount of color and guess which 

01:20:11.522 --> 01:20:15.477
color we've been pushing you 
towards?  We changed from hollow

01:20:17.983 --> 01:20:22.870
to this white theme and we shot 
ourselves in the foot in terms 

01:20:23.297 --> 01:20:26.420
of power.  
Let's look at Google apps over 

01:20:27.336 --> 01:20:33.409
the last year and the power 
savings they've been able to 

01:20:34.536 --> 01:20:36.536
have.  Here

01:20:39.838 --> 01:20:44.740
's YouTube, full brightness.  
You save 43% of your battery 

01:20:44.982 --> 01:20:47.686
usage.  When you're playing a 
video, it doesn't matter 

01:20:48.530 --> 01:20:51.231
anyways.  
Now when it's paused, we save 

01:20:51.440 --> 01:20:55.658
even more, it's 60%.  My guess, 
here, is because the overlay of 

01:20:56.026 --> 01:21:01.377
the video actually darkens the 
video, you know, we use an even 

01:21:01.378 --> 01:21:05.497
more dark color so we save more 
power.  This test, itself, 

01:21:06.110 --> 01:21:09.221
depends very much on the video 
content.  If you have a video 

01:21:09.534 --> 01:21:15.576
that is fully white, you're not 
going to save so much.  

01:21:15.577 --> 01:21:21.434
Gboard is a good example.  Users
can control this and save 20% of

01:21:21.435 --> 01:21:27.445
your battery or the display use 
of the battery, just by 

01:21:27.718 --> 01:21:33.267
switching to a dark theme.  
Finally, on Maps, this is the 

01:21:33.268 --> 01:21:37.207
example of dark theme and where 
it is really great because it 

01:21:37.556 --> 01:21:43.929
has the obvious benefits of the 
battery.  You don't want Maps 

01:21:44.329 --> 01:21:47.918
being a really white theme when 
you're driving at night.  So 

01:21:47.919 --> 01:21:51.447
dark theme, here, makes the app 
more usable in a nighttime 

01:21:52.320 --> 01:21:54.810
setting.  
And now Alan's going to talk.

01:21:55.062 --> 01:22:00.333
  All right.  So, how can we 
embrace the dark side some 

01:22:00.612 --> 01:22:04.714
implement dark mode in our apps?
Going into dark theme.  Which 

01:22:04.961 --> 01:22:07.442
will not save us any battery 
here, but it will on your 

01:22:08.211 --> 01:22:13.040
devices.  So, you may remember 
Night Mode from the developer 

01:22:13.350 --> 01:22:16.250
preview of Android last year or 
the year before that or the year

01:22:16.671 --> 01:22:22.299
before that or the year before 
that.  But, we released 

01:22:23.654 --> 01:22:26.318
Day/Night support in app 
compats.  There's a great blog 

01:22:26.833 --> 01:22:31.216
article about it.  Our 
recommended way to implement 

01:22:31.651 --> 01:22:35.770
Dark Mode in your app and 
basically get it for free is 

01:22:36.971 --> 01:22:40.567
Day/Night.  You can get this 
almost for free.  The stock 

01:22:41.073 --> 01:22:45.356
widgets will respond to the 
changes in the device's Night 

01:22:45.619 --> 01:22:49.992
Mode and you can toggle between 
Light and Dark mode.  This is 

01:22:51.571 --> 01:22:57.935
the demo from the AndroidX 
checkout.  If you have it from 

01:22:58.827 --> 01:23:02.428
AOSP, you can take a look.  
It's one line of code to switch 

01:23:02.980 --> 01:23:07.291
between whatever theme you're 
using before and app compat.  

01:23:07.543 --> 01:23:12.435
You simply take whatever your 
app theme is and have it 

01:23:12.823 --> 01:23:18.640
inherent from one of the 
day/night themes.  Everything 

01:23:18.641 --> 01:23:23.873
might just work.  
You can also apply a overlay 

01:23:24.196 --> 01:23:28.177
theme dynamically at runtime.  
So if you want to have a pure 

01:23:28.635 --> 01:23:32.505
black oled themes, there are 
some apps that already do this 

01:23:32.506 --> 01:23:42.027
or a pink Hello Kitty theme, you
can do it at runtime.  If you

01:23:42.596 --> 01:23:46.801
want to learn more about overlay
themes, Chris and I talked about

01:23:47.060 --> 01:23:52.853
those at I/O a few years ago.  
This ensures any time a theme is

01:23:54.115 --> 01:23:58.243
set, you will then immediately 
overlay it with the black theme 

01:23:58.681 --> 01:24:02.949
or a Hello Kitty theme and any 
views that get inflated will be 

01:24:03.678 --> 01:24:08.900
using that theme correctly.  
All right.  Either, way, you're 

01:24:09.170 --> 01:24:13.885
going to want to structure your 
app on theme attributes.  All of

01:24:13.886 --> 01:24:17.941
the platform drawables 
heavily-rely on theme attributes

01:24:18.213 --> 01:24:24.655
to obtain their colors.  Color 
foreground, color control 

01:24:25.433 --> 01:24:31.701
normal, color accent.  The thumb
-- sorry, the switch that you 

01:24:31.702 --> 01:24:35.176
can drag left and right, the 
thing that sits under that is 

01:24:35.413 --> 01:24:38.480
colored light gray when it's 
enabled.  And dark gray when 

01:24:38.787 --> 01:24:42.850
it's disabled.  The 
implementation of that is just a

01:24:43.420 --> 01:24:48.462
color selector, a color state 
list that refers to the color 

01:24:48.872 --> 01:24:54.176
attribute, which is white under 
a light theme.  Black on a dark 

01:24:54.177 --> 01:24:59.139
theme and an alpha.  We vary 
that based on light and dark 

01:24:59.485 --> 01:25:03.071
themes.  
There are no colors hard-coded 

01:25:03.072 --> 01:25:06.958
here.  We'll talk about this 
more, later today, in a talk 

01:25:07.935 --> 01:25:09.348
with Nick Butcher about themes 
and styles.  

01:25:09.349 --> 01:25:17.183
All right.  So, I mentioned 
night mode showed up.  The 

01:25:18.454 --> 01:25:22.835
qualifier has been there since 
SDK 8.  It was opened up for 

01:25:23.084 --> 01:25:28.694
general use in Android N, so the
ability to set the night 

01:25:28.944 --> 01:25:35.732
qualifier system-wide, there are
some apps that accidentally set 

01:25:36.483 --> 01:25:40.749
it.  Messenger has been doing 
that recently, it has been 

01:25:41.014 --> 01:25:43.884
fixed.  
It's a research qualifier 

01:25:44.333 --> 01:25:48.354
similar to portrait or 
landscape.  You just create a 

01:25:49.027 --> 01:25:52.987
drawable/night and if you have 
resources that are difficult to 

01:25:52.988 --> 01:26:00.886
extract theme colors out of, say
you have a welcome splash image 

01:26:02.261 --> 01:26:08.543
that is complicated, you can get
a dark version of that and it's 

01:26:08.958 --> 01:26:15.168
too complicated to put in a 
vector drawable, you can drop it

01:26:15.169 --> 01:26:20.264
in drawable night.  You'll pick 
up that drawable automatically. 

01:26:20.265 --> 01:26:25.486
Same thing for colors, if there 
are colors you want to switch, 

01:26:25.487 --> 01:26:29.240
say your accent color is darker,
you can extract that to a named 

01:26:29.651 --> 01:26:35.198
color resource, have one version
in colors, one version in values

01:26:35.517 --> 01:26:38.181
night.  
So, here's what the theme 

01:26:38.399 --> 01:26:42.770
implementation can look like.  
If you want to switch your 

01:26:43.476 --> 01:26:49.043
parent theme based on night 
qualifier, you define it once in

01:26:49.044 --> 01:26:52.475
values and once in values night 
and give it a different parent. 

01:26:52.476 --> 01:26:56.185
When it is non-night mode, 
you'll pick up the light theme 

01:26:56.186 --> 01:27:02.238
when it's referenced under night
mode, when the night qualifier 

01:27:02.530 --> 01:27:05.612
is on, you'll pick up the night 
theme.  

01:27:05.613 --> 01:27:09.951
We have the same color 
referenced two different ways.  

01:27:11.495 --> 01:27:17.992
It will pick up black under 
non-night mode.  It would pick 

01:27:18.414 --> 01:27:22.207
up white under night mode.  
When you can do update your app,

01:27:22.447 --> 01:27:27.000
maybe do a little bit of 
restructuring.  Take a 

01:27:27.350 --> 01:27:31.652
screenshot of your app, invert 
it, see how it looks.  Get a 

01:27:31.837 --> 01:27:35.139
sense of whether there are 
images you'll need to have an 

01:27:36.650 --> 01:27:40.300
alturnive version of.  We have 
avatars, maybe we want to change

01:27:40.473 --> 01:27:47.715
the background colors a little 
bit, so that may mean extracting

01:27:47.967 --> 01:27:52.641
theme attributes or different 
sets of PNGs to drop into 

01:27:52.961 --> 01:27:55.764
drawables night.  
Next, you want to take a survey 

01:27:55.765 --> 01:28:02.718
of the usage of colors in your 
layout XML and in your styles.  

01:28:03.411 --> 01:28:08.082
Set the parent of your theme to 
be something dark, 

01:28:11.119 --> 01:28:17.021
theme.appcompat or 
theme.material.  You'll want to 

01:28:17.530 --> 01:28:20.954
look and see if you're losing 
contrast.  What you

01:28:24.259 --> 01:28:31.098
you  see should look like it.  
All the background colors and 

01:28:31.099 --> 01:28:34.538
foreground colors were 
hard-coded to be light theme.  

01:28:34.539 --> 01:28:37.741
The one thing that wasn't 
hard-coded -- and you can almost

01:28:38.134 --> 01:28:41.104
see it here -- is the label for 
first name, which is now 

01:28:41.105 --> 01:28:45.792
invisible because it's the only 
thing that's correctly pulling 

01:28:45.793 --> 01:28:48.588
in the dark theme color 
attributes.  So, this is going 

01:28:48.925 --> 01:28:51.371
to require a lot of work.  
The hard part is doing that 

01:28:51.667 --> 01:28:55.009
work.  So, you'll want to 
refactor your colors as much as 

01:28:55.372 --> 01:29:00.931
possible.  Take any hard-coded 
layouts in your XMLs and move 

01:29:01.113 --> 01:29:04.246
them to named color resources.  
You can base those on 

01:29:05.251 --> 01:29:10.907
values/values night.  If you 
want to do more than one theme, 

01:29:11.340 --> 01:29:15.322
you'll want to extract those to 
color attributes that have some 

01:29:15.586 --> 01:29:18.631
sort of meaning in your 
application.  We have text color

01:29:19.615 --> 01:29:24.567
primary, we have color ax sent, 
we have color primary.  You 

01:29:25.411 --> 01:29:28.279
should be using those as much as
possible and certainly take 

01:29:29.297 --> 01:29:32.425
advantage of theme attributes 
for specifying colors, 

01:29:32.683 --> 01:29:35.734
propagating those into your 
lists and layouts.  

01:29:35.735 --> 01:29:42.906
You can convert your PNGs to 
alpha masks and convert tinting.

01:29:43.890 --> 01:29:51.933
You can wrap those where a bit 
map.  We'll talk, again, a

01:29:54.574 --> 01:29:58.215
little bit more about this at 
the themes and styles talk 

01:29:58.719 --> 01:30:03.220
today.  
Next, you move over and

01:30:07.598 --> 01:30:12.961
get automatic switching in night
mode.  Here, we have the Twitter

01:30:14.019 --> 01:30:17.778
app, which has a very obvious 
affordance for switching between

01:30:18.034 --> 01:30:25.251
day and night.  So, if you tap 
this, it goes into dark mode. 

01:30:26.246 --> 01:30:35.008
There is a platform specified 
dark node so you may have a

01:30:36.408 --> 01:30:40.844
tristate.  
You  you'll also want to test 

01:30:41.565 --> 01:30:46.692
that your application works when
Night Mode changes.  You can use

01:30:46.693 --> 01:30:52.078
ABD, open your app, once you've 
implemented the day/night theme,

01:30:52.596 --> 01:30:58.765
toggle it into night yes.  It is
going to go through a full 

01:30:59.778 --> 01:31:04.957
on-display and re-creation and 
preserve using data.  

01:31:04.958 --> 01:31:13.855
On pixel 3 devices running P, 
night mode will switch and it 

01:31:15.477 --> 01:31:17.738
enters battery-saving mode.  You
can toggle it from developer 

01:31:18.237 --> 01:31:21.773
options and push might node to 
be always on, always off or one 

01:31:22.226 --> 01:31:26.475
of the legacy things we have is 
switching based upon time of 

01:31:26.785 --> 01:31:30.241
day.  
You can learn more in the themes

01:31:30.637 --> 01:31:34.788
and styles talk that I'll be 
giving with Nick Butcher later 

01:31:34.789 --> 01:31:38.784
today.  If you want to learn 
more about the lower-level 

01:31:38.785 --> 01:31:43.209
things, Chris and I gave a great
talk at Google I/O.  So that 

01:31:43.378 --> 01:31:48.346
covers anything you want to 
know, but have been afraid to 

01:31:48.801 --> 01:31:54.255
ask about themes and styles.  
We will be outside in the 

01:31:54.512 --> 01:31:58.422
Android Lounge to answer any of 
your questions.  

01:31:58.423 --> 01:32:07.442
Thanks, everybody, for coming.  
Please embrace the dark side.

01:32:29.659 --> 01:32:31.659
[Applause]

01:33:02.270 --> 01:33:06.285
  Hello, welcome to Improving 
Battery Life with Restrictions. 

01:33:06.286 --> 01:33:13.701
My name is Jingyu Shi, I'm a 
partner developer.

01:33:14.196 --> 01:33:19.435
Hi, I'm Amith Yamasani.
  Today, we want to start with 

01:33:19.436 --> 01:33:22.576
this notification we've all 
received, hopefully never around

01:33:22.842 --> 01:33:28.185
this time of day.  Knowing that 
our battery's running out can be

01:33:28.186 --> 01:33:32.735
really frustraing and sometimes 
scary depending on where we are 

01:33:32.736 --> 01:33:36.326
and what we're doing at this 
time. These days, we rely so 

01:33:36.723 --> 01:33:39.092
much on our devices for 
navigation, talking to our 

01:33:39.687 --> 01:33:42.273
friends and family, taking 
pictures and even translate for 

01:33:42.568 --> 01:33:46.921
us when we are traveling in a 
foreign country.  

01:33:46.922 --> 01:33:51.341
But all these cool features and 
amazing apps that you built 

01:33:52.859 --> 01:33:55.395
cannot help the user if their 
battery is dead.  So that's why 

01:33:55.670 --> 01:33:59.881
today, we're talking about how 
we're going to improve battery, 

01:33:59.882 --> 01:34:02.758
with your help, hopefully.  And 
this is what we're going to 

01:34:02.915 --> 01:34:07.823
cover.  First, we'll talk about 
what's consuming power and how 

01:34:08.479 --> 01:34:12.416
we measure power consumption and
then we're going to go through 

01:34:12.417 --> 01:34:18.470
the power-saving features we've 
introduced in feature years and 

01:34:18.775 --> 01:34:22.471
how your app will be affected by
these restrictions.  

01:34:22.472 --> 01:34:27.533
Next, I'll pass it over to Amith
to talk about what's consuming 

01:34:27.823 --> 01:34:30.019
power. 
  Hi.  Quickly walk through how 

01:34:30.406 --> 01:34:33.617
we actually estimate how an app 
consumes power, how much power 

01:34:33.891 --> 01:34:37.563
it's consuming on the device.  
These are the typical 

01:34:38.264 --> 01:34:44.850
components, hardware components 
that are consuming power.  I've 

01:34:45.166 --> 01:34:53.142
highlighted the top consumers.  
You got an earfull of display.  

01:34:53.603 --> 01:34:57.976
Running at high frequencies is 
also pretty expensive and 

01:34:58.388 --> 01:35:02.227
transferring data over the cell 
network is quite expensive, as 

01:35:02.561 --> 01:35:05.376
well.  
So, when each device is 

01:35:06.783 --> 01:35:11.663
manufactured, the OEM has a 
power profile.  What it contains

01:35:12.299 --> 01:35:17.445
is the average current drawn by 
various subsystems we want to 

01:35:18.635 --> 01:35:23.109
measure in realtime and, for 
example, if you turn the screen 

01:35:23.380 --> 01:35:28.052
on, at minimum brightness, it 
might be about 100.  If you 

01:35:28.316 --> 01:35:34.358
crank it up to full brightness, 
let's say it add another 300.  

01:35:34.359 --> 01:35:41.313
So, we keep track of that in 
realtime.  CPU has different 

01:35:41.590 --> 01:35:46.353
power consumptions.  
At runtime, what we do is, 

01:35:46.837 --> 01:35:51.589
there's a subsystem called 
battery stats.  It tracks what 

01:35:51.881 --> 01:35:56.192
each app is doing.  It measures 
how long it's consuming each of 

01:35:56.193 --> 01:36:00.720
these resources, like, how much 
CPU time, at what frequency, how

01:36:01.062 --> 01:36:06.062
many data packets it's 
transferring and so on and we 

01:36:06.592 --> 01:36:12.309
multiply with the power cost for
each of those and we get an 

01:36:12.594 --> 01:36:17.888
approximate estimate of how many
hours the particular app has 

01:36:18.179 --> 01:36:21.704
drained and we rank the apps, 
presented to the user, so they 

01:36:22.313 --> 01:36:25.392
can see that in settings and 
learn for themselves what is 

01:36:25.874 --> 01:36:29.325
really draining their battery.  
So, let's talk about how the OS 

01:36:29.634 --> 01:36:34.673
is trying to help the user 
extend their battery life.  But,

01:36:35.208 --> 01:36:38.937
first, broadly-speaking, there 
are two reasons why the app 

01:36:39.484 --> 01:36:44.680
runs, the user's launching it, 
it's running in the foreground, 

01:36:44.950 --> 01:36:48.573
user's actively using the app.  
As developers, that's something 

01:36:48.923 --> 01:36:51.811
you don't want them to not do, 
but that's a whole different 

01:36:52.466 --> 01:36:55.694
topic about digital well-being 
and trying to, you know, help 

01:36:55.950 --> 01:36:59.672
users control how much time they
spend on apps.  

01:36:59.673 --> 01:37:04.006
But one note I want to leave 
here is there's a concept about 

01:37:04.351 --> 01:37:07.459
suspending apps and that's 
something you might want to read

01:37:07.460 --> 01:37:12.457
about and how that impacts your 
app if the user suspends the app

01:37:12.458 --> 01:37:15.100
for, let's say, the rest of the 
day.  

01:37:15.101 --> 01:37:19.416
But we'll focus on how we try to
limit background activity from 

01:37:19.417 --> 01:37:25.076
an app.  An app can schedule 
background work by using jobs or

01:37:25.866 --> 01:37:33.491
alarms.  It can also register 
for call-backs for external 

01:37:33.749 --> 01:37:37.704
triggers like push messages or 
walking past a geofence.  

01:37:37.705 --> 01:37:44.941
Over the years, we've introduced
several features, in the OS, to 

01:37:44.942 --> 01:37:49.117
save battery.  First, in 
Marshmallow, we introduced Doze.

01:37:49.118 --> 01:37:53.634
It puts the device on a deep 
sleep.  Let's say you left it on

01:37:53.885 --> 01:37:57.473
your desk or nightstand, it 
basically shuts down a lot of 

01:37:57.474 --> 01:38:02.038
the background activity so that 
you can really extend your 

01:38:02.293 --> 01:38:05.455
battery life.  
But this is not really how we 

01:38:05.456 --> 01:38:12.593
use our daily phones, right.  
We're walking around with it.  

01:38:12.861 --> 01:38:22.823
So we came up with Doze on The 
Go.  It 

01:38:23.375 --> 01:38:29.568
puts it to sleep lightly.  It's 
not in front of you, you're not 

01:38:29.569 --> 01:38:33.309
using the screen so it can shut 
down some of the background 

01:38:33.944 --> 01:38:35.697
work.  
You're probably all familiar 

01:38:35.698 --> 01:38:37.698
with the Oreo 

01:38:41.458 --> 01:38:46.869
restrictions on background 
services.  As of this month, 

01:38:46.870 --> 01:38:52.415
everyone needs to target Android
Oreo above.  

01:38:52.416 --> 01:38:59.987
But we'll focus more on what's 
new in 

01:39:02.852 --> 01:39:09.017
P, Adaptive Battery, Battery 
Saver.  Adaptive Battery is a 

01:39:09.018 --> 01:39:16.664
revolution of App Standby that 
was introduced.  It put app in 

01:39:16.665 --> 01:39:24.261
two possible states, active or 
non-active.  Adaptive Battery 

01:39:24.262 --> 01:39:29.434
extends this into four buckets. 
Based on usage, we move it to 

01:39:29.435 --> 01:39:33.568
some other buckets.  For 
instance, if you are Google I/O 

01:39:34.425 --> 01:39:38.309
and you install the I/O app, it 
should go to the rare app 

01:39:38.713 --> 01:39:40.751
because you haven't been using 
it.  

01:39:40.752 --> 01:39:45.867
So, how does the OS assign these
buckets to each app?  It starts 

01:39:46.282 --> 01:39:49.598
off when you're installing the 
app in another bucket, it's not 

01:39:49.907 --> 01:39:53.427
shown here, it's really not that
relevant.  Once you launch the 

01:39:53.428 --> 01:39:58.288
app -- or every time you launch 
the app or any kind of strong 

01:39:58.289 --> 01:40:03.837
interaction, like clicking on a 
notification, the app goes the 

01:40:03.838 --> 01:40:07.127
app bucket and it stays there 
for awhile, maybe in a few hours

01:40:07.472 --> 01:40:10.877
it comes down and starts 
applying restrictions.  And a 

01:40:11.948 --> 01:40:16.730
little later, most frequent and 
then to rare and then we 

01:40:17.071 --> 01:40:23.257
uninstall your app.  I'm just 
kidding.  We don't do that.

01:40:23.258 --> 01:40:25.114
[Laughter]
If you're looking at a 

01:40:25.115 --> 01:40:28.090
notification, it's not a clear 
indication that it's an active 

01:40:28.364 --> 01:40:32.708
usage of the app, so we put it 
in a slightly-restricted state, 

01:40:32.953 --> 01:40:37.587
which is the working set.  What 
is actually adaptive about this 

01:40:38.225 --> 01:40:43.163
is if the device has a machine 
learning algorithm, it watches 

01:40:44.173 --> 01:40:47.917
your usage patterns, learns over
time and decides, okay, this app

01:40:47.918 --> 01:40:51.032
is probably going to be used in 
the next couple of hours, let me

01:40:51.457 --> 01:40:57.559
put it in the active set and 
maybe it can freshen up its 

01:40:57.841 --> 01:41:01.447
data.  And once it feels that 
maybe the app is not going to be

01:41:01.768 --> 01:41:05.272
used for awhile, it might move 
it down in to one of the lower 

01:41:05.448 --> 01:41:07.448
buckets so this really 

01:41:09.576 --> 01:41:13.977
approves your ability of the 
amount of apps it uses in the 

01:41:14.621 --> 01:41:16.596
background. 
It's not your fault, you don't 

01:41:16.597 --> 01:41:21.082
know when the user's going to 
launch you so we're trying to 

01:41:21.482 --> 01:41:25.936
help with that.  
Restrictions is another feature.

01:41:26.373 --> 01:41:30.304
We limit what the app can do in 
the background.  It's mostly met

01:41:30.570 --> 01:41:33.897
for apps you want to do in 
theforegrounds.  There are two 

01:41:33.898 --> 01:41:37.955
ways the app can go into this 
state.  The user might see, in 

01:41:38.296 --> 01:41:43.313
settings, that your app is 
draining battery and decides to 

01:41:44.172 --> 01:41:48.958
manually restrict the app.  The 
system is monitoring certain 

01:41:49.274 --> 01:41:55.350
criteria and if it feels it is 
doing anything excessive, it 

01:41:55.746 --> 01:41:58.662
suggests to the user, do you 
want to restrict this app 

01:41:59.788 --> 01:42:03.665
because it is draining your 
battery in the background.  

01:42:03.666 --> 01:42:13.644
These are things we will improve
and OEMs are able to add 

01:42:14.053 --> 01:42:17.852
this.  
The usual jobs, alarms, 

01:42:19.149 --> 01:42:24.680
full-ground service.  As far as 
the user's concerned, it is a 

01:42:24.977 --> 01:42:27.165
background thing if you see 
something happening with a 

01:42:27.465 --> 01:42:32.378
notification and it's doing work
in the background.  FCM, as of 

01:42:32.639 --> 01:42:36.423
January, will be restricted as 
well.  So you won't get any 

01:42:36.703 --> 01:42:40.428
messages when your app is in the
rest state.  You don't get 

01:42:40.692 --> 01:42:44.536
location updates and one thing 
that's unique about app 

01:42:44.537 --> 01:42:50.456
restrictions is even while the 
device the chargeing, we don't 

01:42:50.457 --> 01:42:54.712
let you run in the background.  
The reason is, this is not just 

01:42:55.134 --> 01:43:02.801
about saving battery, it's also 
aboutabout annoyances and maybe 

01:43:03.313 --> 01:43:07.784
privacy concerns.  
It's very similar to how 

01:43:08.081 --> 01:43:10.081
restrictions work.  Some of the

01:43:15.469 --> 01:43:19.517
differences are foreground is 
fine to run on Battery Saver.  

01:43:19.518 --> 01:43:25.021
There are no restrictions on 
push notifications.  

01:43:25.022 --> 01:43:29.946
And, one thing that's new, in 
Pie, is we turn off location 

01:43:29.947 --> 01:43:39.944
services completely, at least on
pixel devices, OEMs might not

01:43:41.185 --> 01:43:45.924
choose to do that.  
You can ask user stats, what is 

01:43:45.925 --> 01:43:50.171
your current standby bucket, at 
this moment.  If you want to 

01:43:50.338 --> 01:43:53.349
debug something, you can also 
get historical information about

01:43:54.895 --> 01:44:01.498
your standby bucket changes. You
can check if you're 

01:44:01.499 --> 01:44:03.664
background-restricted right now 
and maybe you want to tell the 

01:44:03.926 --> 01:44:07.007
user something about that.  
Please don't nag the user.  If 

01:44:07.008 --> 01:44:10.110
they don't want you to run, they
don't want you to run.  

01:44:10.111 --> 01:44:15.532
And, you can also check if 
Battery Saver's on, internally, 

01:44:15.533 --> 01:44:21.226
it's called power saver mode.
  Thank you, Amith.  

01:44:21.227 --> 01:44:27.897
So, how is your app affected?  
So, any time to the system, your

01:44:28.173 --> 01:44:31.105
app will be one of these two 
states.  It will be either in 

01:44:31.704 --> 01:44:37.278
the foreground or the 
background.  And whenever your 

01:44:37.570 --> 01:44:40.708
app is considered to be in 
foreground, all these 

01:44:40.979 --> 01:44:43.966
restrictions are lifted so you 
can run whenever you need to.  

01:44:44.232 --> 01:44:48.146
When your app is in background 
and the device is not charging 

01:44:48.629 --> 01:44:51.905
all of the Battery Saver 
features that Amith just talked 

01:44:52.173 --> 01:44:55.634
about, any of them could be 
enabled, which means your jobs, 

01:44:56.360 --> 01:45:01.334
alarms, network access and FCM 
messages could be restricted.  

01:45:01.335 --> 01:45:04.140
Next, we have some really 
beautiful diagrams, which will 

01:45:04.503 --> 01:45:12.324
show you how they are affected. 
First let's do scheduled jobs.  

01:45:12.696 --> 01:45:19.481
Given all the constraints you 
have on the job is satisfied 

01:45:20.725 --> 01:45:25.589
ified, these are the things that
will affect how it runs.  If it 

01:45:25.887 --> 01:45:29.559
goes, your job will defer to the
maintenance window.  If the user

01:45:30.632 --> 01:45:33.689
decides to turn on Battery Saver
or app restrictions, meaning 

01:45:33.954 --> 01:45:38.155
restrict your app from that 
battery setting, your job will 

01:45:38.692 --> 01:45:45.616
be deferred until the user opens
the app or the app is in the 

01:45:47.992 --> 01:45:51.431
foreground.  
Your job could be deferred up to

01:45:51.723 --> 01:45:55.994
24 hours, that's when your app 
belongs to the rare bucket and 

01:45:56.278 --> 01:45:59.043
that's the worst case, which 
means that even in the 

01:46:00.437 --> 01:46:04.122
worst-case, your job will still 
get run every day.  

01:46:04.123 --> 01:46:11.843
So, similarly, for alarm manager
alarms, it will affect when your

01:46:12.327 --> 01:46:16.855
alarms fire.  When it's in Doze,
your alarm will be deferred to 

01:46:17.423 --> 01:46:20.604
maintenance window.  If the user
turns on Battery Saver or 

01:46:20.880 --> 01:46:24.417
restrict your app, your alarm 
will be deferred until your app 

01:46:25.340 --> 01:46:29.996
is in foreground.  And finally, 
to the app standby bucket, your 

01:46:30.787 --> 01:46:37.499
alarm could be delayed up to two
hours if your app belongs to 

01:46:37.500 --> 01:46:40.750
that rare bucket.  
If your use case requires that 

01:46:41.865 --> 01:46:45.588
exact time execution, then, for 
example, if you want to remind a

01:46:45.589 --> 01:46:50.414
user they need to take 
medication or a TV program that 

01:46:50.671 --> 01:46:54.860
they subscribe to is about to 
start, so for these use cases, 

01:46:55.744 --> 01:47:01.594
you can use this idol method so 
your alarm will fire on time.  

01:47:02.000 --> 01:47:06.763
But you are using alarm manager 
to wake up the device frequently

01:47:07.082 --> 01:47:10.873
and imagine that every app is 
doing that at a different time, 

01:47:11.172 --> 01:47:15.380
you're draining a lot of 
battery.  That's why we have the

01:47:16.440 --> 01:47:20.677
excessive wake-up on your vitals
page.  If you see it on vitals 

01:47:21.042 --> 01:47:26.102
pages, it's caused by alarm 
manager, I would recommend you 

01:47:26.448 --> 01:47:32.178
think about maybe you migrate to
other APIs.  

01:47:32.179 --> 01:47:36.399
If you are sending push 
notifications, you are probably 

01:47:38.700 --> 01:47:45.208
already using Firebase Cloud 
Messaging.  When the device is 

01:47:46.053 --> 01:47:53.296
in Doze, your priority messages 
will be deferred to the 

01:47:54.134 --> 01:47:57.957
maintenance window.  
This is because high-priority 

01:48:01.300 --> 01:48:03.300
FC

01:48:06.481 --> 01:48:08.481
FCM message, they're triggered 
to send a notification to the 

01:48:08.848 --> 01:48:11.763
user.  If they turn on Battery 
Saver, still your messages will 

01:48:12.264 --> 01:48:17.262
be delivered, as it is.  
As Amith mentioned earlier, if 

01:48:17.263 --> 01:48:22.815
the user restricted your [no 
audio]

01:49:27.596 --> 01:49:29.709
audio]. 
They will apply on any app 

01:49:30.432 --> 01:49:34.351
that's running on Android 
device, no matter which target 

01:49:34.638 --> 01:49:39.797
SDK you're targeting.  So, our 
first advice to you is please 

01:49:40.366 --> 01:49:47.883
test your app.  We have ABD 
command.  You can use to put all

01:49:48.726 --> 01:49:56.058
your apps in this features to 
see if your push notifications 

01:49:56.343 --> 01:50:04.261
are coming through.  
Except for the high-priority FCM

01:50:06.037 --> 01:50:09.107
restrictions, none of them are 
knew.  If your app works well 

01:50:09.446 --> 01:50:12.589
under Doze, it's very likely 
that you don't need to change 

01:50:13.183 --> 01:50:16.466
much to work with these 
features.  

01:50:16.467 --> 01:50:19.448
Our second advice to you is 
whenever you're running task in 

01:50:19.738 --> 01:50:25.124
the background, please keep in 
mind to use this Lazy first 

01:50:27.095 --> 01:50:29.095
design principle.  Try to reduce
the work

01:50:31.435 --> 01:50:37.722
KROUR  -- you're doing in the 
background.  Can this wait until

01:50:37.977 --> 01:50:41.990
my app is in the background?  If
you really need to run in the 

01:50:42.536 --> 01:50:45.788
background, try to defer that 
work to a later time, say, when 

01:50:45.789 --> 01:50:50.268
device is plugged in or think 
about that exact alarm.

01:50:50.269 --> 01:50:56.894
Does it have to happen at that 
exact time?  Can it wait?  

01:50:56.895 --> 01:51:00.291
Finally, try to do the work in 
the background.  In Lollipop, we

01:51:01.639 --> 01:51:04.146
introduced Job Scheduler, which 
is a way for you to help the 

01:51:04.609 --> 01:51:07.435
system to intelligently batch 
all the background work and this

01:51:08.121 --> 01:51:13.440
year, we introduced WorkManager 
in Jetpack, which makes running 

01:51:13.441 --> 01:51:16.833
background work better.  When it
is stable, it will be the 

01:51:17.573 --> 01:51:22.716
recommended way to do background
work.  So, with that in mind, 

01:51:22.955 --> 01:51:28.167
let's look at this upgraded view
of how you do things in the 

01:51:28.620 --> 01:51:30.620
background.  
If

01:51:33.227 --> 01:51:38.950
you need to execute a work that 
is deferable locally, 

01:51:38.951 --> 01:51:42.938
WorkManager is your answer.  If 
this work is triggered online, 

01:51:43.216 --> 01:51:48.488
then you would use an FCM 
message with WorkManager.  

01:51:48.489 --> 01:51:53.411
Meaning you would want to use 
FCM message to notify your app 

01:51:54.187 --> 01:51:58.037
there is work you need to do and
the in message handler, you 

01:51:58.310 --> 01:52:02.884
queue that work.  If your user 
case doesn't fit with either of 

01:52:02.885 --> 01:52:07.318
these cases and you need to run 
something at that exact time, 

01:52:07.319 --> 01:52:11.830
then you would want to use alarm
manager.  

01:52:11.831 --> 01:52:17.562
If this is something that the 
user started, user is aware it 

01:52:18.099 --> 01:52:21.687
is happening and it must happen 
immediately, you would use 

01:52:22.114 --> 01:52:26.355
foreground service.  But please,
whenever you are using this 

01:52:27.080 --> 01:52:30.457
foreground service, add that 
notification because there's 

01:52:30.675 --> 01:52:34.119
nothing more frustrating about 
seeing a bunch of notifications 

01:52:34.120 --> 01:52:37.617
and there's nothing I can do 
about it.  Please add that 

01:52:37.907 --> 01:52:41.005
action in a notification for 
user to stop this service and 

01:52:41.218 --> 01:52:44.995
notification is dismissed.  
If you reach the end, I would 

01:52:44.996 --> 01:52:49.859
say go back to the top or you 
should wait until your app is 

01:52:50.341 --> 01:52:54.923
inforegrounds.  
So, we have a talk later today, 

01:52:55.732 --> 01:53:01.586
at 1:00 p.m., please go to that 
to learn how to use WorkManager 

01:53:01.587 --> 01:53:05.578
to do background work.  We also 
have a lot of best practices and

01:53:06.008 --> 01:53:10.050
guidance, how you can help us to
help users save battery.  Please

01:53:10.416 --> 01:53:13.995
visit to learn more.  
And, we will be in the office 

01:53:14.329 --> 01:53:20.134
hours this afternoon for any 
questions.  Thank you.

01:53:20.135 --> 01:53:22.135
Thank you.

01:53:26.151 --> 01:53:29.638
[Applause]
  Everyone, the next session in 

01:53:29.639 --> 01:53:36.055
this room will begin in 10 
minutes.  Thank you. 

03:41:38.117 --> 03:41:42.876
. 
Welcome Android Dev Summit.  

03:41:43.179 --> 03:41:48.971
We'll be back at 1:00 p.m. 

04:00:13.061 --> 04:00:17.785
  Cool.  Thanks for coming.  
Welcome to Working with 

04:00:18.323 --> 04:00:22.596
WorkManager.  My name is Sumir 
Kataria. 

04:00:22.597 --> 04:00:27.368
I'm Rahul Ravikumar.
  We both work on Android 

04:00:28.071 --> 04:00:31.216
Architecture Components, 
particularly, WorkManager.  Let 

04:00:32.193 --> 04:00:34.295
me grab my -- 
[Laughter]

04:00:34.296 --> 04:00:39.605
All right.  We're going to give 
you a state of the union about 

04:00:39.606 --> 04:00:43.176
WorkManager.  I want to give you
an abbreviated guide to 

04:00:43.709 --> 04:00:49.119
WorkManager.  So for those of 
you who haven't used WorkManager

04:00:49.120 --> 04:00:53.849
before, we want to give you the 
basic APIs.  We're going to talk

04:00:54.192 --> 04:00:58.316
about WorkManager, the things 
you've asked and also the new 

04:00:58.729 --> 04:01:02.794
changes we've made since I/O.  
So, let's talk about the state 

04:01:03.081 --> 04:01:08.262
of the union.  There have been 
11 releases of WorkManager since

04:01:09.130 --> 04:01:13.175
Google I/O and these are alpha 
releases.  Today was the one -- 

04:01:13.542 --> 04:01:19.057
was the 11th one.  And, beta's 
coming soon so those of you who 

04:01:19.058 --> 04:01:24.766
watched the keynote yesterday 
may have heard beta's coming 

04:01:24.767 --> 04:01:29.984
this month.  This was news to 
us, too.

04:01:29.985 --> 04:01:32.189
[Laughter]
So, we want to give you an 

04:01:32.884 --> 04:01:36.861
abbreviated guide to WorkManager
and what is it, for those of you

04:01:36.862 --> 04:01:40.450
who are completely new to this? 
It is

04:01:43.613 --> 04:01:50.748
a library.  It wraps alarm 
manager and those of you who 

04:01:50.749 --> 04:01:53.592
have used Job Scheduler will 
find the concepts very familiar.

04:01:54.034 --> 04:01:58.746
So, let's talk about work.  
You've got a unit of background 

04:01:58.747 --> 04:02:02.555
work -- and we'll talk about how
we create it.  You've got it and

04:02:02.902 --> 04:02:05.664
how does WorkManager execute 
this work?  This is a graph that

04:02:06.837 --> 04:02:10.851
might help you.  While your 
process is up and running, we'll

04:02:11.102 --> 04:02:15.103
feed to this executor that we 
have.  You can customize this 

04:02:16.165 --> 04:02:20.620
thing.  But your process may be 
killed and WorkManager is 

04:02:20.911 --> 04:02:27.236
guaranteed to do work.  It may 
defer it, but it will do it when

04:02:27.612 --> 04:02:33.885
the constraints are met.  If 
you're API 23+, we used Job 

04:02:33.886 --> 04:02:37.709
Scheduler and before that we 
used alarm manager.  Whenever 

04:02:38.021 --> 04:02:43.377
the signals are met, let's say 
you put in a two-hour time delay

04:02:44.236 --> 04:02:48.335
when you have network.  When all
those conditions are met, it 

04:02:48.544 --> 04:02:51.047
will still go to the same 
executor.

04:02:51.048 --> 04:02:57.226
All right.  Let's do a quick API
walkthrough.  So, the 

04:02:57.702 --> 04:03:00.330
fundamental unit of work, in 
WorkManager, is a Worker.  Here,

04:03:00.619 --> 04:03:07.033
I'm defining a calculation 
Worker.  It extends the Worker 

04:03:07.365 --> 04:03:12.149
type.  The only thing you need 
to do is extend do work.  Here, 

04:03:12.666 --> 04:03:16.286
I'm returning a success.  You 
can also return a retry or a 

04:03:16.937 --> 04:03:20.093
fail.  I'm doing some expensive 
calculation on the background 

04:03:20.094 --> 04:03:23.576
thread so you don't have to 
worry about threading here 

04:03:23.880 --> 04:03:25.900
because WorkManager is 
guaranteed to schedule your 

04:03:26.334 --> 04:03:31.974
work.  
Here, I'm returning a result of 

04:03:33.246 --> 04:03:35.786
success synchronously.  How do 
you make that work run?  So, for

04:03:36.527 --> 04:03:44.143
that, you need to inqueue a work
request.  One is a one-time and 

04:03:44.851 --> 04:03:50.330
one is a periodic work request. 
I'm using a one-time and 

04:03:51.925 --> 04:03:56.907
building it with the 
calculation.  I'm telling it 

04:03:57.753 --> 04:04:01.953
initial delay.  This tells 
WorkManager to only run the work

04:04:02.250 --> 04:04:08.609
after two hours has passed since
the point of inqueue.  I'm 

04:04:08.821 --> 04:04:13.139
setting the charging constraint.
It is only eligible to run when 

04:04:13.140 --> 04:04:16.969
the device is connected to or 
charger -- when the device is 

04:04:17.354 --> 04:04:20.258
actually charging.  
I'll talk about tags in more 

04:04:20.831 --> 04:04:29.152
detail and I'm calling .build.  
Now I need to do is call get- 

04:04:29.517 --> 04:04:36.087
instance and get the work.  And 
it -- if you want to keep track 

04:04:36.405 --> 04:04:41.569
of what state your work is in, 
you want to call get work info 

04:04:41.570 --> 04:04:48.992
by LiveData.  This returns a 
LiveData of a work info.  That 

04:04:49.435 --> 04:04:53.730
is the state of your work and 
LiveData here is a lifecycle of 

04:04:54.051 --> 04:05:02.814
observable.  So once you attach 
it to a LiveData owner, once

04:05:04.173 --> 04:05:07.593
you inqueue the work, once the 
constraints are met, it'll go 

04:05:08.484 --> 04:05:14.542
into running and then finally, 
it will go into succeeded state.

04:05:15.678 --> 04:05:21.183
Remember the tag we added when 
we built the one-time work 

04:05:22.018 --> 04:05:25.466
request, you can get it with 
data.  You associate it with a 

04:05:25.902 --> 04:05:30.737
work request and there can be 
one or many.  You can assign the

04:05:30.738 --> 04:05:36.248
same tag to multiple things.  It
is by tag, LiveData.  LiveData 

04:05:36.670 --> 04:05:40.174
again.  A list of work info.  
And again, I can do the same 

04:05:40.465 --> 04:05:42.529
things I did in the previous 
slide.  

04:05:42.530 --> 04:05:46.127
So, one of the coolest features 
of WorkManager is the ability to

04:05:46.713 --> 04:05:51.895
chain work.  So, that helps you 
define a graph of work and here,

04:05:52.325 --> 04:05:59.000
I'm asking WorkManager to begin 
with A, B and C and they're work

04:06:00.175 --> 04:06:06.282
requests.  D and E are only 
eligible to run once A, B and C 

04:06:06.598 --> 04:06:15.039
are done.  I'm asking 
WorkManager to run A, B and C to

04:06:16.551 --> 04:06:24.195
run in parallel.  And, finally, 
I'm calling on this again.  FGNH

04:06:24.778 --> 04:06:29.438
will only run once all the 
proceeding runs are done.  Don't

04:06:29.862 --> 04:06:34.272
forget to call 

04:06:39.024 --> 04:06:42.707
inqueue.  
Returns are work continuation.  

04:06:42.708 --> 04:06:49.113
The work continuation is a node 
in your graph.  This lends to a 

04:06:49.988 --> 04:06:53.792
very fluent API.  Every time you
call it, it calls a new instance

04:06:54.076 --> 04:06:59.284
of another continuation.  
Finally, don't forget to call 

04:06:59.285 --> 04:07:03.275
inqueue.  When you chain work, 
the outputs of the parent work 

04:07:03.604 --> 04:07:08.086
request become inputs to your 
descending work request or your 

04:07:08.554 --> 04:07:12.722
children.  This helps you manage
and send state from parent work 

04:07:13.248 --> 04:07:17.922
to the descendant work.  
Now, finally, there's 

04:07:20.021 --> 04:07:22.246
WorkManager that also exposes 
the API to cancel.  If you want 

04:07:22.671 --> 04:07:26.866
to do that, you can cancel work 
by ID and every work request has

04:07:27.363 --> 04:07:31.190
a unique ID.  Here, we are 
canceling work by that ID and 

04:07:31.191 --> 04:07:34.835
you can also cancel work by tag.
So, those are the two APIs.  

04:07:36.443 --> 04:07:39.374
And, that's it.
  And I want to point out that 

04:07:39.762 --> 04:07:43.481
all the things -- all the APIs 
we've been showing are for alpha

04:07:43.915 --> 04:07:48.348
11.  You may notice some slight 
changes for those of you who 

04:07:48.349 --> 04:07:51.809
have been using this API before.
But everything is live today.  

04:07:52.124 --> 04:07:56.566
So, let's talk about how to get 
the most out of WorkManager.  It

04:07:57.363 --> 04:08:02.573
includes, how do I do a certain 
type of task?  And the biggest 

04:08:02.574 --> 04:08:06.429
one that we get a question about
is threading.  How does 

04:08:07.104 --> 04:08:12.136
threading work in WorkManager?  
So, we talked about a work 

04:08:12.451 --> 04:08:17.227
request, Rahul just mentioned 
that.  You inqueue it.  We have 

04:08:17.228 --> 04:08:22.903
an internal task executor.  It 
is a single-threaded executor.  

04:08:23.663 --> 04:08:27.965
The inqueue goes to that.  Every
app that the uses WorkManager 

04:08:28.268 --> 04:08:33.271
has a WorkManager database.  
This is the source of truth.  

04:08:33.529 --> 04:08:39.822
This is where we keep track of 
your inputs, outputs, dependency

04:08:39.823 --> 04:08:45.173
chains.  After it's been 
inqueued, sometime later, your 

04:08:45.829 --> 04:08:49.164
constraints have been met.  If 
you have no constraints, it runs

04:08:49.165 --> 04:08:54.331
right away.  If there are 
constraints, the OS will tell 

04:08:54.596 --> 04:09:01.637
you.  Same task executor using a
Worker factory to create a 

04:09:01.988 --> 04:09:05.086
Worker.  It's a factory for 
Workers and you can make your 

04:09:05.501 --> 04:09:09.647
own.  You can customize and do 
things with it.  

04:09:09.648 --> 04:09:15.095
After the Worker's created, we 
execute it on an executor.  This

04:09:15.382 --> 04:09:18.328
is actually a thing you can 
customize.  We'll talk more 

04:09:18.648 --> 04:09:22.859
about that, later, as well.  
What if you don't want to 

04:09:23.306 --> 04:09:28.016
execute something on that 
executor?  What if you're using 

04:09:28.306 --> 04:09:31.077
RxJava or Coroutine?  What if 
you have your own solution you 

04:09:31.343 --> 04:09:35.247
want to use to run things in the
background?  This was a request 

04:09:35.537 --> 04:09:38.614
that came up quite a lot when we
first released WorkManager.  

04:09:39.044 --> 04:09:44.977
So, to do this, we want to 
provide you an API to let you do

04:09:45.416 --> 04:09:54.751
work, on your own, and just tell
us when it's done.  You want to 

04:09:55.358 --> 04:10:03.305
do async when you're done.  We 
split it out the Guava team has 

04:10:03.627 --> 04:10:07.905
worked on this so you don't need
a full dependency for this.  

04:10:08.195 --> 04:10:12.189
It's literally one or two 
classes now.  It's a feature 

04:10:12.483 --> 04:10:15.568
that can have one or more 
listeners and those listeners 

04:10:15.569 --> 04:10:20.703
can be envoked on a spec feed 
executor.  

04:10:20.704 --> 04:10:22.704
So using

04:10:24.526 --> 04:10:29.501
this, we made listenable worker.
You need to override start work.

04:10:30.257 --> 04:10:34.570
You give us a listable feature. 
You do whatever work you want 

04:10:34.571 --> 04:10:39.666
and when you're done, set the 
result on the feature and we'll 

04:10:39.667 --> 04:10:43.154
be able to listen to it and 
react to it.  

04:10:43.155 --> 04:10:48.030
So the actual threading model, 
in WorkManager, it goes to the 

04:10:48.031 --> 04:10:53.317
task executor, which uses the 
Worker factory to create a 

04:10:55.155 --> 04:10:58.412
listen Worker.  We call start 
work on it and we attach a 

04:10:58.753 --> 04:11:03.464
listener so we can listen to 
whenever you're done.  The 

04:11:03.968 --> 04:11:08.770
Worker class is a simple 
listenable worker.  We have the 

04:11:09.068 --> 04:11:12.571
do work method we talked about. 
We override the start work for 

04:11:13.500 --> 04:11:17.695
you.  We create a feature.  On 
the background executor, we 

04:11:17.946 --> 04:11:22.566
execute the work.  And we, of 
course, return the feature.  

04:11:23.023 --> 04:11:32.124
So, now we have two classes, 
Worker and listenable Workers. 

04:11:34.465 --> 04:11:38.740
Workers are a simpler class.  A 
class that runs synchronously 

04:11:39.475 --> 04:11:42.523
and on a background thread.  
Listenable runs runs 

04:11:44.201 --> 04:11:49.947
asynchronously on an unspecified
background thread.  You're 

04:11:50.488 --> 04:11:54.557
expected to do what you're 
finishing there.  

04:11:54.558 --> 04:12:02.491
You may to return a listenable 
feature.  If you have access to 

04:12:03.809 --> 04:12:07.378
Guava, you have access to 
listeners.  If you don't, it is 

04:12:08.022 --> 04:12:13.852
a light-weight implementation we
provide in AndroidX concurrent 

04:12:14.518 --> 04:12:17.372
features.  
One of the things that a lot of 

04:12:17.656 --> 04:12:25.378
people are trying -- and doing 
incorrectly with work Workers is

04:12:25.379 --> 04:12:32.912
they're trying to do locations. 
If you listen to the Kotlin 

04:12:32.913 --> 04:12:37.757
suspenders talk, they talked 
about it.  Remember that a 

04:12:38.300 --> 04:12:43.182
Worker class is synchronous.  If
you attach a call-back but 

04:12:43.684 --> 04:12:46.500
return success, your work is 
already completed.  It's not 

04:12:46.501 --> 04:12:48.985
going to work the way you think 
it is.  

04:12:48.986 --> 04:12:53.518
So, first thing we do here, 
we're using a listener Worker, 

04:12:53.519 --> 04:12:57.448
this is the feature we'll return
and do our bookkeeping on.  In 

04:12:57.449 --> 04:13:00.330
the start work method, we'll 
check to see if we have 

04:13:01.473 --> 04:13:05.075
permissions.  If we don't, we'll
set a failure on the feature.  

04:13:05.426 --> 04:13:08.920
Otherwise, what we'll do is 
we'll get that provider's last 

04:13:09.285 --> 04:13:16.879
location.  This is like a 
feature in GMS core or Google 

04:13:17.649 --> 04:13:24.023
Pay Services world.  And then we
return to feature.  That is the 

04:13:24.931 --> 04:13:28.576
high-level start work.  
In the get location method, 

04:13:28.855 --> 04:13:32.413
we'll use that task and add a 
listener to it.  If the task is 

04:13:33.558 --> 04:13:38.163
successful, we'll pass that back
with a success status.  

04:13:38.164 --> 04:13:40.604
Otherwise, we'll set an 
exception.  We have addressed 

04:13:40.900 --> 04:13:44.376
the three cases where we want to
have a successful or an 

04:13:44.847 --> 04:13:48.383
unsuccessful task or if we don't
have permissions and WorkManager

04:13:49.019 --> 04:13:52.404
will attach that listener, it'll
listen to the success and 

04:13:52.650 --> 04:13:56.780
failure of the task and do the 
bookkeeping as necessary.  

04:13:56.781 --> 04:14:02.603
All right.
  Let's talk about operations.  

04:14:03.669 --> 04:14:06.697
Sumir mentioned WorkManager uses
database as a source of truth.  

04:14:07.169 --> 04:14:11.082
When you inqueue or do work, we 
have to do some 

04:14:14.300 --> 04:14:17.300
bookkeeping.  
These are a database and we have

04:14:17.687 --> 04:14:22.683
to do them on a background 
thread.  As a result, they're 

04:14:22.684 --> 04:14:24.765
asynchronous.  What if you 
wanted to do something after the

04:14:26.091 --> 04:14:29.975
inqueue happened or the cancel 
happened?  You want to make sure

04:14:30.891 --> 04:14:34.800
they completed before you want 
to do more stuff?  We've 

04:14:35.273 --> 04:14:40.095
introduced a new API.  Inqueue 
and cancel have Operations.  

04:14:40.480 --> 04:14:43.972
Operation is a very simple 
interface.  It has two methods. 

04:14:44.285 --> 04:14:51.589
A get state API, which returns a
LiveData.  If you attach an 

04:14:52.151 --> 04:14:57.892
observer, you will asea it 
transitions from an in-progress 

04:14:58.792 --> 04:15:01.715
to a success or failure.  The 
other one returns the feature 

04:15:02.057 --> 04:15:06.898
type.  Remember this API will 
only return the terminal state 

04:15:07.402 --> 04:15:11.169
of the operation.  If you're 
attaching a listener, you will 

04:15:11.170 --> 04:15:16.239
get a success or failed and what
the exception is and telling you

04:15:16.595 --> 04:15:21.841
why the failure happened.
  Another question a lot of 

04:15:22.378 --> 04:15:26.104
people have is, when is work 
stopped, what happens when you 

04:15:26.105 --> 04:15:33.443
stop work on behalf of 
WorkManager?  So, there's three 

04:15:33.444 --> 04:15:37.809
cases when work is stopped.  The
first is very simple, your 

04:15:37.810 --> 04:15:41.850
constraints are no longer met.  
You said I neat a network to do 

04:15:42.481 --> 04:15:47.289
this upload task but your 
network got lost.  A second case

04:15:47.290 --> 04:15:51.011
is that the OS 

04:16:00.468 --> 04:16:04.076
pre-emted your work.  The third 
reason is you canceled your work

04:16:04.393 --> 04:16:08.248
somewhere else in your app.  How
do we stop work?  There's a 

04:16:08.249 --> 04:16:14.078
method listener Worker 
on-stopped.  You override this 

04:16:14.079 --> 04:16:18.203
and you get your stop signal.  
We cancel that feature so you 

04:16:18.204 --> 04:16:21.008
can add your own listener and 
look for that.  

04:16:21.009 --> 04:16:25.154
So, this is your -- when one of 
these two things happen for you,

04:16:25.371 --> 04:16:28.727
this is your signal to be a good
citizen and clean up because 

04:16:28.728 --> 04:16:32.102
after this is called, the 
process may be killed by the OS.

04:16:32.953 --> 04:16:37.421
So, if the OS woke up your app's
process just to run this work, 

04:16:38.109 --> 04:16:42.753
it could actually kill it when 
it decides that the work should 

04:16:42.754 --> 04:16:48.127
stop and if you happen to return
something after this signal, 

04:16:48.935 --> 04:16:52.296
say, you returned a success, we 
ignored it because as far as 

04:16:53.074 --> 04:16:55.947
we're concerned, your work has 
been stopped.  

04:16:55.948 --> 04:17:00.530
You can also pull from stoppages
in your Worker so you can call 

04:17:01.080 --> 04:17:04.783
the isstopped method.  That will
tell you whether you've been 

04:17:05.083 --> 04:17:08.681
signaled for stopping.  So, 
let's look at how you can be a 

04:17:09.252 --> 04:17:15.552
good citizen and clean up.  
Let's say we're parsing a file 

04:17:15.553 --> 04:17:21.237
asynchronously and you're doing 
it in a Worker.  You've got this

04:17:21.628 --> 04:17:24.780
input stream so you're reading a
file.  In start work, you say 

04:17:25.072 --> 04:17:30.090
parse file.  This is doing 
something asynchronously and you

04:17:30.722 --> 04:17:36.860
return to feature.  Here's parse
file.  You've got some executor,

04:17:36.861 --> 04:17:42.193
whatever, a Coroutine, you're 
asynchronously doing that.  

04:17:42.194 --> 04:17:45.520
You're opening a file, you're 
reading each byte out of the 

04:17:45.837 --> 04:17:50.115
file, doing something with that 
byte and when you're done, you 

04:17:50.754 --> 04:17:54.050
set a success because you're 
done and you have the necessary 

04:17:54.472 --> 04:17:57.356
tricatch finally after that so 
you can clean up after youself. 

04:17:57.924 --> 04:18:06.424
So, how do we handle when your 
work gets stopped while this is 

04:18:06.725 --> 04:18:10.040
executing?  Let's say we want to
finish what we're doing, we 

04:18:10.639 --> 04:18:14.160
could easily close that input 
file stream.  Okay.  So, what 

04:18:14.479 --> 04:18:17.772
happens now?  You've done that. 
Let's go back to the code.  

04:18:17.773 --> 04:18:22.652
Well, if you're in the middle of
that read loop and you close a 

04:18:22.892 --> 04:18:27.002
file, it throws an exception.  
The next time you try to read 

04:18:27.465 --> 04:18:34.888
something, fortunately, you're 
already handling that exception 

04:18:35.221 --> 04:18:39.335
there.  There's one more case 
you forgot about here which is, 

04:18:39.604 --> 04:18:44.203
what if the on-stop happens 
before you open the file?  

04:18:44.204 --> 04:18:47.063
You're not looking for that 
because it never got that signal

04:18:47.280 --> 04:18:50.868
and you'll read that file 
because it opened before you 

04:18:51.167 --> 04:18:55.769
tried to close it.  You'll do 
all this work and how you fix it

04:18:56.593 --> 04:19:04.923
is use that is-stop method.  
This is a good example of how 

04:19:05.121 --> 04:19:09.158
you would honor the OS's signal 
to you that you should stop and 

04:19:09.537 --> 04:19:14.274
be a good citizen.
  So every time you inqueue a 

04:19:14.524 --> 04:19:21.398
method or every time you inqueue
a work request, it goes through 

04:19:21.691 --> 04:19:26.201
several transitions.  Let's look
at life of a one-time work 

04:19:26.908 --> 04:19:34.455
request.  It can be blocked, if 
it's blocked on another request 

04:19:34.456 --> 04:19:36.456
or 

04:19:38.367 --> 04:19:43.016
inqueued.  Once it is met, it 
goes into running.  Once -- 

04:19:43.017 --> 04:19:47.139
depending on the result you 
return, we'll take it to one of 

04:19:47.140 --> 04:19:52.476
the terminal states.  If the 
Worker returns success, then 

04:19:53.354 --> 04:19:56.549
it's -- we'll terminate it with 
a succeeded state.  If it 

04:19:56.847 --> 04:20:02.618
returns a failure, then we'll 
mark it as a failure.  At any 

04:20:03.110 --> 04:20:07.616
point in time, while the Worker 
was in a non-terminating state, 

04:20:08.030 --> 04:20:11.808
if you actually retry, then 
we'll apply the back-off policy 

04:20:12.829 --> 04:20:17.024
and retry.  So the Worker will 
go back to the inqueued state.  

04:20:17.436 --> 04:20:21.734
If you have a non-terminating 
state and you call cancel, it'll

04:20:23.084 --> 04:20:29.143
end up in cancel.  
Now let's look at periodic work.

04:20:29.144 --> 04:20:34.586
It's almost the same.  Because 
it can be chained, there's no 

04:20:34.587 --> 04:20:40.630
blocked state.  It all ends up 
in the inqueue state.  So, 

04:20:40.868 --> 04:20:43.526
whether you succeed or you 
retry, it'll go back into the 

04:20:45.077 --> 04:20:49.012
inqueued state.  This might seem
confusing.  If you succeed, it 

04:20:49.643 --> 04:20:54.264
is done.  We'll wait for the 
next interval.  If you fail and 

04:20:54.265 --> 04:20:58.976
ask us to retry, we'll apply the
appropriate back-off policy.  

04:20:59.360 --> 04:21:01.789
We'll tell you this is the 
second time you're trying to run

04:21:02.071 --> 04:21:07.136
it for that last period.  
And, if you mark your work as 

04:21:08.247 --> 04:21:12.438
failed, then we'll transition it
to the fail state.  At that 

04:21:13.383 --> 04:21:18.351
point, your periodic work won't 
run again.  When it's in a 

04:21:19.634 --> 04:21:22.230
non-terminal state and you 
cancel it, we'll mark it as 

04:21:23.046 --> 04:21:25.084
canceled.  
Let's apply that to life of a 

04:21:25.085 --> 04:21:29.180
chain.  Here is the parent of 
all Workers.  So, when you 

04:21:30.029 --> 04:21:32.040
inqueue this chain of work,

04:21:35.388 --> 04:21:40.334
all descendants are blocked now.
Constraints are met and it goes 

04:21:40.684 --> 04:21:44.563
into running state.  Once it is 
done, let's assume you succeeded

04:21:45.382 --> 04:21:49.710
so it unlocks B and C now and 
they go into running and for the

04:21:50.359 --> 04:21:57.400
sake of the argument, let's 
assume that B succeeds and C 

04:21:57.805 --> 04:22:03.486
fails.  B unlocks D so D goes 
into the inqueued state.  Notice

04:22:03.758 --> 04:22:13.404
what happens to E, F, and G, 
they all failed.  If a unit

04:22:14.142 --> 04:22:21.303
gets canceled, all of its 
descendants are also marked 

04:22:21.532 --> 04:22:24.894
canceled.
  So I'm going to talk about 

04:22:25.184 --> 04:22:28.495
unique work and let's start with
a little question here.  What's 

04:22:28.496 --> 04:22:32.920
wrong with this code?  You've 
got an application object in the

04:22:33.905 --> 04:22:37.598
on-create.  The problem here -- 
and I've seen this in a few bugs

04:22:37.599 --> 04:22:41.845
-- is that this inqueues 
periodic work every time your 

04:22:42.304 --> 04:22:45.578
app process starts.  That's 
probably not what you're trying 

04:22:45.808 --> 04:22:51.043
to do.  You're trying to set up 
a sync here.  If you call this 

04:22:51.044 --> 04:22:54.462
code every time the app starts, 
every time you've got another 

04:22:54.950 --> 04:23:00.244
thing that's syncing your code, 
you really only want one of 

04:23:01.017 --> 04:23:03.017
them.  So unique

04:23:04.308 --> 04:23:08.809
work lets you -- if you insert 
the same key into a database 

04:23:08.810 --> 04:23:13.825
again, do you want to overwrite 
and ignore what you're trying to

04:23:14.283 --> 04:23:17.208
do?  
That's what unique work does, 

04:23:17.568 --> 04:23:21.121
it's a conflict policy for 
WorkManager.  Here's the syntax.

04:23:21.427 --> 04:23:27.520
Unique is that name, that key.  
Something that uniquely 

04:23:27.708 --> 04:23:32.080
identifies that chain of work.  
Policy is the existing work 

04:23:32.382 --> 04:23:35.728
policy or the conflict policies 
and then you obviously have your

04:23:36.814 --> 04:23:42.850
requests.  
So, the existing work policies, 

04:23:43.191 --> 04:23:46.871
there's three of them.  The 
first one is keep.  If you have 

04:23:47.712 --> 04:23:53.814
things in blocked, running or 
inqueuedinqueued, it will keep 

04:23:53.815 --> 04:23:58.250
them.  If the work is finished 
or not sent, it will inqueue 

04:23:58.251 --> 04:24:00.772
what you sent.  The next one is 
replace. 

04:24:00.773 --> 04:24:04.089
It always replaces the work 
request in the database.  If 

04:24:04.090 --> 04:24:08.042
your work is running, it'll get 
stopped as I described a few 

04:24:08.255 --> 04:24:13.974
minutes earlier.  It cancels the
old work and it stops it.  A 

04:24:14.436 --> 04:24:17.975
pend is a special one.  It 
appends to that chain of work.  

04:24:18.164 --> 04:24:22.081
This is useful if you're trying 
to do something, in order, for 

04:24:22.516 --> 04:24:26.757
example, you're trying to build 
a messagng app and you're 

04:24:27.064 --> 04:24:30.318
sending messages in order, you 
may have a unique chain of work 

04:24:30.319 --> 04:24:34.929
for sending messages and you 
want to append new messages at 

04:24:35.425 --> 04:24:39.215
the end of it so it's basically 
creating a tree for you.

04:24:39.216 --> 04:24:44.525
Sumir mentioned that one of his 
previous slides on how you can 

04:24:44.526 --> 04:24:48.267
customize WorkManager, so, let's
look at all the things you can 

04:24:48.634 --> 04:24:54.564
do.  You can actually specify a 
worker factory that can be used 

04:24:54.565 --> 04:24:59.215
to use your Workers.
This is useful in the context of

04:24:59.216 --> 04:25:04.099
-- if you're using Dagger and 
you want to inject something, 

04:25:04.858 --> 04:25:07.926
this is a good place to do that.
You can specify the default 

04:25:08.216 --> 04:25:13.058
executor that you want all 
WorkerWorkers to use.  You can 

04:25:13.388 --> 04:25:17.918
specify the Login if you want to
distinguish between a build and 

04:25:18.385 --> 04:25:23.433
release build and log more 
information to diagnose your 

04:25:23.784 --> 04:25:26.886
problems and do Job Scheduler 
parameters, like number of jobs 

04:25:26.887 --> 04:25:30.759
you want us to send to Job 
Scheduler, the IDs you want us 

04:25:31.083 --> 04:25:33.699
to know in case you're already 
using Job Scheduler before.  

04:25:34.171 --> 04:25:38.481
If you want to customize 
WorkManager, then you have to 

04:25:38.482 --> 04:25:45.213
disable the default and add this
entry to your man

04:25:48.798 --> 04:25:52.787
ifest.  So now that you've 
disabled it, you need to 

04:25:52.788 --> 04:25:57.738
actually create a new instance 
of configuration.  

04:25:57.739 --> 04:26:01.331
Here, I'm using the 
configuration building and 

04:26:02.381 --> 04:26:08.436
overwriting it.  I can call it 
to initialize.  

04:26:08.437 --> 04:26:13.659
So, make sure you do this in 
your application on-create.  

04:26:13.883 --> 04:26:20.273
Because the system -- the 
operating system can actually 

04:26:20.564 --> 04:26:23.632
envoke job sources on your 
behalf.  WorkManager needs to be

04:26:27.634 --> 04:26:29.342
initialized.
  Finally, the last thing we 

04:26:29.343 --> 04:26:33.821
want to talk about, before we 
wrap-up, is some tips for all 

04:26:34.208 --> 04:26:37.618
library developers out there.  
If you're using WorkManager in 

04:26:37.619 --> 04:26:40.094
your library, you have some 
special use cases we want to 

04:26:40.443 --> 04:26:43.640
think about.  So the general 
advice we give is because 

04:26:43.933 --> 04:26:49.109
WorkManager's a single and the 
application initializes it, as 

04:26:49.110 --> 04:26:54.790
Rahul just showed you, you're 
not really in control of what's 

04:26:55.103 --> 04:26:59.849
there.  The default Worker 
factory creates Workers and 

04:27:02.121 --> 04:27:05.694
listenlistenable Workers.  If 
you need a particular dependency

04:27:06.351 --> 04:27:09.343
injection or anything else of 
that sort, you'll have to have a

04:27:10.175 --> 04:27:14.232
contract with the app.  
Silo your work with tags.  Rahul

04:27:14.233 --> 04:27:20.712
showed you how to tag your work.
If you silo all your work, put 

04:27:21.322 --> 04:27:24.823
your prefix or your package name
or library name in your tags, 

04:27:24.824 --> 04:27:27.412
you can easily identify all the 
work that's yours.  You don't 

04:27:27.927 --> 04:27:33.696
have to worry about other people
-- other people's work.  

04:27:33.697 --> 04:27:38.738
You can get your work and 
operate on that.  Finally, we do

04:27:39.564 --> 04:27:44.448
provide the ability for apps to 
wipe away all work.  This is 

04:27:44.794 --> 04:27:48.784
generally for privacy reasons.  
It's for that sort of critical 

04:27:48.785 --> 04:27:51.852
use case where you have to wipe 
user data, for some reason.  

04:27:52.666 --> 04:27:57.665
So, as a library developer, how 
do you find out if your work's 

04:27:58.257 --> 04:28:03.731
been gone from under you.  Look 
at get last cancel all time -- 

04:28:04.013 --> 04:28:09.970
sorry, it's very confusing.  
Okay.  Next steps.  So, get 

04:28:10.292 --> 04:28:13.886
WorkManager if you haven't 
already.  For those of you who 

04:28:14.392 --> 04:28:18.178
have, thank you very much.  
We're up to alpha 11, so there's

04:28:18.969 --> 04:28:28.643
three general categories of 
artifacts, there's one and KPX 

04:28:28.919 --> 04:28:34.000
and testing support as well.  
These are some helpful links.  

04:28:34.839 --> 04:28:40.313
Schedule task with WorkManager 
is the developer.Android.com.  

04:28:40.314 --> 04:28:43.468
There's the YouTube -- on 
YouTube, there's the Google I/O 

04:28:43.469 --> 04:28:46.725
2018 talks which talks about the
basics. Some of those APIs have 

04:28:47.011 --> 04:28:50.969
changed a little bit, but it's 
still broadly a good thing to 

04:28:50.970 --> 04:28:55.806
read -- or to listen to.  
And, also, please file your 

04:28:56.429 --> 04:29:03.076
feedback at our publish issue 
tracker.  Beta is coming, we 

04:29:03.706 --> 04:29:09.118
were told yesterday morning. We 
have to get back to work.

04:29:09.119 --> 04:29:11.654
[Laughter]
Thanks a lot.  Please visit all 

04:29:12.287 --> 04:29:15.489
the Jetpack libraries on the web
and we'll be outside for any 

04:29:15.918 --> 04:29:19.637
questions you might have.  
Thanks.

04:29:20.308 --> 04:29:22.308
Thanks.
[Applause]

04:29:29.533 --> 04:29:35.843
Everyone, the next session, in 
this room, will begin at 1:55 

04:50:12.178 --> 04:50:14.178
p.m.  Thank you. 
[Applause]

04:50:15.468 --> 04:50:24.597
Hi, everyone.  Thank you for 
joining us for Best Practices 

04:50:24.881 --> 04:50:27.275
for Themes and Styles. 
  And I'm Alan Viverette. 

04:50:27.276 --> 04:50:31.884
We will take about designing 
themes and styles for your 

04:50:31.885 --> 04:50:38.421
appplication.  The way that 
designers create mocks.  Here's 

04:50:38.422 --> 04:50:43.080
the latest iteration of the 
Material Design theme pallet.  

04:50:43.487 --> 04:50:47.261
If you're not using if for 
Android yet, you might recognize

04:50:48.416 --> 04:50:51.681
primary from the Material 
Theming in the platform.  It is 

04:50:53.898 --> 04:50:57.641
like color primary dark.  And, 
when you get a mock from I 

04:50:58.562 --> 04:51:05.070
designer, you may doing a mental
mapping, this is going to be my 

04:51:05.418 --> 04:51:10.049
darker color, this is going to 
be my primary color.  It's 

04:51:10.360 --> 04:51:16.519
important to make sure your 
designers understands there are 

04:51:18.535 --> 04:51:20.535
canonical atattributes.  It can 
be helpful to push back a little

04:51:20.883 --> 04:51:26.321
bit and say, let's call this the
primary variance or primary 

04:51:26.767 --> 04:51:29.771
color and it's great that we all
of these pre-designed theme 

04:51:30.191 --> 04:51:35.387
colors with meaningful names and
meaningful contrast ratios that 

04:51:35.663 --> 04:51:39.835
have to exist between foreground
and background.  

04:51:39.836 --> 04:51:43.075
Occasionally, you will get a 
brand-new color that doesn't 

04:51:43.717 --> 04:51:47.457
exist anywhere and finding a 
name for this may be difficult. 

04:51:47.855 --> 04:51:51.744
Here we have a purple color 
that's lighter than our primary 

04:51:52.023 --> 04:51:54.834
variance and it has contrast 
against while so we're going to 

04:51:55.070 --> 04:51:57.997
be displaying white text on top 
of it.  If we want to come up 

04:51:57.998 --> 04:52:02.506
with a name for this, we should 
find something that can 

04:52:03.249 --> 04:52:05.678
generalize but is 
self-capturing.  If we decide we

04:52:06.025 --> 04:52:09.844
had a purple theme, now we need 
a blue theme, we can reuse the 

04:52:09.845 --> 04:52:14.807
name of the color and reuse 
those constraints.  

04:52:14.808 --> 04:52:19.669
So, what are we going to call 
that?  Well, over in the pallet,

04:52:19.958 --> 04:52:23.572
we have these on color.  
On-primary means this is a 

04:52:23.905 --> 04:52:29.382
foreground color displayed on a 
primary background and ensure 

04:52:29.715 --> 04:52:33.928
it's going to meet accessibility
ratios. You'll be able to read 

04:52:33.929 --> 04:52:37.321
the foreground text color 
against the background.  We have

04:52:37.905 --> 04:52:46.299
secondary, if we have something 
on the blue color, it would be 

04:52:46.300 --> 04:52:51.886
white.  We can generate a new 
name for the lighter color.  

04:52:52.247 --> 04:52:56.480
We're going to use on-primary.  
That determines the foreground 

04:52:57.114 --> 04:52:59.241
color protection.  For 
background color protection, we 

04:52:59.469 --> 04:53:06.093
want to make sure it contrasts 
with primary.  We can call it 

04:53:06.494 --> 04:53:09.309
primary light, which seems 
incredibly straightforward and 

04:53:09.310 --> 04:53:12.291
it is.  So, you can tell your 
designer, every time we're 

04:53:13.116 --> 04:53:17.998
talking about this lighter 
version of our primary color, 

04:53:18.917 --> 04:53:23.741
let's refer to it as primary 
light and it'll have these 

04:53:23.742 --> 04:53:26.027
constraints.  
If your designer decides we want

04:53:26.442 --> 04:53:31.921
it to be blue instead of purple,
we can continue to use the same 

04:53:31.922 --> 04:53:36.029
constraints and use our 
semantically-designed color 

04:53:36.030 --> 04:53:41.624
theme.  Similarly, we provide 
common patterns for text 

04:53:43.135 --> 04:53:52.488
appearance.  We have headline, 
overline, body.  These are 

04:53:53.717 --> 04:53:57.460
names from where they are going 
to be used.  That determines the

04:53:57.675 --> 04:54:00.063
pixel size, the weight and the 
color. 

04:54:00.064 --> 04:54:04.928
On the right, we see what that 
map to.  In this case, headline 

04:54:05.201 --> 04:54:12.670
is going to be roboto.  However,
if we decided we wanted to use, 

04:54:12.671 --> 04:54:16.968
let's say, comic sans, we 
wouldn't have to go through and 

04:54:17.745 --> 04:54:22.577
create a new style everywhere in
our application because we do 

04:54:22.853 --> 04:54:26.980
have these names that imply how 
they're used.  

04:54:26.981 --> 04:54:32.973
Use meaningful name when you're 
extracting from your mocks.  

04:54:33.933 --> 04:54:37.769
Learn the Material Design 
attributes. They are at 

04:54:38.911 --> 04:54:43.177
material.io.  Use this as a 
commoncommon language when 

04:54:43.178 --> 04:54:47.147
you're looking at mocks or 
looking at something new that 

04:54:47.148 --> 04:54:50.975
has a random gray color in it.  
Make sure it has a name you can 

04:54:51.242 --> 04:54:54.591
use.  If you are implementing 
dark mode, if you attended that 

04:54:54.592 --> 04:54:58.308
talk earlier today, you know 
this gray needs to turn into a 

04:54:58.309 --> 04:55:01.905
light white because it needs 
contrast against a certain text 

04:55:01.906 --> 04:55:06.821
color or background color.  
Use meaningful attribute names. 

04:55:07.114 --> 04:55:12.013
They should be more or less 
self-documenting.  Something 

04:55:12.742 --> 04:55:16.225
like primary light has more 
constraints than it looks like 

04:55:16.522 --> 04:55:20.877
primary color.  Go ahead and 
document these somewhere.  Start

04:55:21.724 --> 04:55:24.093
an internal site you share with 
your designers to make sure 

04:55:24.592 --> 04:55:28.767
you're always using a common 
language when talking about the 

04:55:29.074 --> 04:55:36.930
components, the colors, the 
reusable texts.  That's a good 

04:55:37.268 --> 04:55:41.078
starting place on how to name 
them and how to talk about them.

04:55:41.079 --> 04:55:46.360
When you get a mock that says, 
this is the hex color

04:55:49.709 --> 04:55:52.454
4836Ef, push back on that and 
say, this isn't a hex color.  It

04:55:52.622 --> 04:55:55.892
has meaning and we need to be 
able to smoothly-transition from

04:55:56.092 --> 04:56:01.350
this hex color to a hex color 
with similar constraints. 

04:56:01.351 --> 04:56:05.304
So, now Nick is going to talk a 
little bit more about what this 

04:56:05.728 --> 04:56:10.217
means in implementation. 
  Thank you.  Right.  So, we 

04:56:11.338 --> 04:56:13.338
talked a lot about 

04:56:17.533 --> 04:56:21.062
supporting different 
semantically-named values.  It 

04:56:21.063 --> 04:56:25.022
can be implemented as theme 
attributes.  What happens if 

04:56:25.023 --> 04:56:29.452
your design changes and all of a
sudden, instead of a purple 

04:56:29.453 --> 04:56:33.551
theme, you have a blue theme.  
These semantic names protect you

04:56:34.401 --> 04:56:39.469
and it's more wide-spread than 
you might realize.  So, if you 

04:56:39.470 --> 04:56:43.166
want to have areas which can 
support these kind of theming, 

04:56:43.167 --> 04:56:48.821
there are different ways you can
achieve this.  One way might be,

04:56:48.822 --> 04:56:52.218
define different styles.  I'm 
going to set up a style and call

04:56:52.219 --> 04:56:56.575
that style 1 and then I want to 
to look different so I'll give 

04:56:56.576 --> 04:57:02.779
it style 2.  The problem with 
this approach is there's going 

04:57:02.780 --> 04:57:07.965
to be a lot of duplication and 
there's 2 places for you to 

04:57:07.966 --> 04:57:14.254
maintain or bug fix or refactor.
Using the semantical pointers to

04:57:14.545 --> 04:57:20.077
describe what it should look 
like or a theme attribute 

04:57:20.612 --> 04:57:24.231
protects you against this.  It 
might be more work to establish 

04:57:24.232 --> 04:57:27.384
this language and set up your 
styles to refer back to theme 

04:57:27.779 --> 04:57:31.429
attributes, what it does is it 
ends up with a single place, a 

04:57:31.430 --> 04:57:34.435
single style, that will refer 
back to the theme attributes 

04:57:34.436 --> 04:57:37.603
defined for a given theme.  
And the benefits of this is

04:57:41.006 --> 04:57:45.382
it's going to duplicate the 
style.  

04:57:45.383 --> 04:57:48.721
And also localizes the 
modeifications.  So that means 

04:57:48.999 --> 04:57:52.258
it you need to change an 
attribute, you go to that one 

04:57:52.539 --> 04:57:56.008
place where it's defined rather 
than have to track it down where

04:57:56.487 --> 04:57:59.961
it's leaked out.  
It also has the benefit, I 

04:58:00.264 --> 04:58:04.290
think, of consolidation.  How 
many times have you opened your 

04:58:05.043 --> 04:58:08.589
colors XML files and found 50 
shades of similarly-looking 

04:58:08.905 --> 04:58:13.193
colors and you see a mock and 
you say, okay, I'll just create 

04:58:13.556 --> 04:58:18.203
another color resource.  It 
protects you against this.  You 

04:58:18.204 --> 04:58:22.782
want to condense it down to this
small pallet.  You have a nice 

04:58:23.074 --> 04:58:25.195
look and feel.  
Basically, this approach really,

04:58:25.196 --> 04:58:30.200
really helps you with the 
maintainability of your app.  I 

04:58:30.619 --> 04:58:34.822
urge you to prefer theme 
attributes where possible.  If 

04:58:35.438 --> 04:58:38.948
you write code like the top 
line, the text color should be 

04:58:39.924 --> 04:58:43.545
this color resource, think of it
as a code smell.  Is this 

04:58:44.127 --> 04:58:47.287
layout, is there a chance this 
might appear in a different 

04:58:47.629 --> 04:58:50.495
theme?  Could it be included in 
a different area of the 

04:58:51.012 --> 04:58:55.979
application?  If so, should I be
looking at the bottom form, 

04:58:56.713 --> 04:58:59.524
looking at the question mark 
syntax, which is how you refer 

04:58:59.795 --> 04:59:05.554
to these theme attributes?  
So, we talked about the 

04:59:06.088 --> 04:59:09.482
importance of the semantical 
parts.  You can set a theme 

04:59:09.762 --> 04:59:17.942
directly on an activity and 
these are using components, 

04:59:18.237 --> 04:59:25.789
which is a doc theme or maybe 
you're using a night mode.  So, 

04:59:26.218 --> 04:59:29.942
this is a theme which will 
change between dark and light 

04:59:30.207 --> 04:59:34.507
depending on the time of day.  
What happens if you have a 

04:59:34.508 --> 04:59:38.937
screen like this, this is a 
Google I/O app.  Most of these 

04:59:39.685 --> 04:59:45.432
list items are the same but the 
designed called for some to be 

04:59:45.808 --> 04:59:48.761
light on dark and some dark on 
light.  You can do separate 

04:59:49.147 --> 04:59:52.327
layouts or separating text 
colors.  Both of those basically

04:59:52.913 --> 04:59:55.589
either leak out the information 
beyond where you want it to lead

04:59:55.988 --> 04:59:59.159
to an explosion of more 
maintenance.  Instead, what you 

04:59:59.471 --> 05:00:03.243
probably want to do is look at 
applying themes at the view 

05:00:03.589 --> 05:00:11.178
level rather than at the whole 
activity level.  The attribute 

05:00:12.004 --> 05:00:17.107
theme was added in API 21.  So, 
in this, you can set a theme on 

05:00:17.697 --> 05:00:21.072
a view or a view group and apply
a different theme to a 

05:00:21.259 --> 05:00:25.752
subsection of your view hiarkry.
So, in these example, you might 

05:00:26.301 --> 05:00:30.509
say you have a light theme and 
apply a dark version of it, or 

05:00:30.785 --> 05:00:35.240
vice versa.  You can do the same
thing in code by using the 

05:00:35.739 --> 05:00:40.048
wrapper.  You take the existing 
theme and it overlays a style on

05:00:40.366 --> 05:00:44.682
top of it.  
It is overlaid.  That means that

05:00:45.496 --> 05:00:48.771
you have an existing theme and 
any values from the theme you 

05:00:48.772 --> 05:00:51.553
set on top of are going to be 
applied on top so you need to be

05:00:51.819 --> 05:00:56.640
a little bit conscious of this 
fact.  Either you don't want to 

05:00:57.130 --> 05:01:01.261
overlay a theme which supplies 
too many values.  If I was using

05:01:02.591 --> 05:01:04.591
material component

05:01:06.856 --> 05:01:13.262
s light and then doc, you might 
overwrite too much.  You want to

05:01:13.768 --> 05:01:18.172
make sure the theme you're 
overwriting expresses the theme 

05:01:18.173 --> 05:01:21.299
you need.  
You might want to take a look at

05:01:22.585 --> 05:01:28.961
the theme overlays just to theme
the attributes you want such 

05:01:28.962 --> 05:01:33.918
that when it's overlaid, you get
the resulting combination of 

05:01:34.401 --> 05:01:37.784
themes.  
While the context theme wrapper 

05:01:38.055 --> 05:01:42.706
approach looks close to dynamic 
theming, it's not.  You have to 

05:01:42.892 --> 05:01:47.085
apply a theme which you've 
defined at compile time.  You 

05:01:47.708 --> 05:01:53.688
can't use this to take color 
values and create a dynamic 

05:01:54.137 --> 05:01:56.480
theme.  This is ahead of time 
thinking.

05:01:56.481 --> 05:02:01.726
So, before you start setting a 
bunch of theme attributes, it's 

05:02:01.727 --> 05:02:03.825
important to understand how 
they're applied through the 

05:02:03.826 --> 05:02:12.156
platform.  We're going to do a 
whirlwind tour that occur on 

05:02:12.441 --> 05:02:15.549
screen and your application 
themes.  At any point in your 

05:02:15.854 --> 05:02:19.612
application, it's good to have a
background understanding that 

05:02:19.878 --> 05:02:23.128
you can point to something on 
the screen and understand the 

05:02:23.455 --> 05:02:26.358
layer direction and theme 
attributes and styles applied to

05:02:27.064 --> 05:02:30.015
render it this way on screen.  
If we want to set this color for

05:02:30.016 --> 05:02:35.281
a single button, how would we do
that?  Well, let's dive into the

05:02:35.572 --> 05:02:45.313
way that this gets resolved at 
runtime.  We have button in XML.

05:02:45.314 --> 05:02:48.962
If you watch the demystifying 
themes and styles talk, you have

05:02:48.963 --> 05:02:52.155
a complete understanding of how 
this works.  If you haven't 

05:02:52.438 --> 05:02:56.402
watched that, go watch it.  The 
button style that you see here 

05:02:57.091 --> 05:03:00.460
is pulled from the theme -- the 
theme of the context in which 

05:03:00.461 --> 05:03:05.546
the button is inflated.  So, 
relevant button-style attribute 

05:03:05.547 --> 05:03:08.279
here at the bottom of the 
screen.  

05:03:08.280 --> 05:03:16.515
Next, where is that button style
designed?  It is on the material

05:03:17.789 --> 05:03:22.215
theme there is widget.material 
button.  Where do we find the 

05:03:22.408 --> 05:03:26.869
definition?  Over in styles 
material.  So, we can see here, 

05:03:27.508 --> 05:03:33.427
the background is this button 
default drawable.  Right below 

05:03:33.853 --> 05:03:38.725
that bordered ink button style, 
we have another style.  We 

05:03:38.925 --> 05:03:41.939
realize it's going to be a 
little bit closer because it 

05:03:42.202 --> 05:03:45.643
provides a color in the button. 
So, let's dive into the 

05:03:45.644 --> 05:03:51.781
background that's used, there, 
to see what gets pulled from our

05:03:51.782 --> 05:03:56.083
theme.  
In the buttoncolor.XML, it 

05:03:56.487 --> 05:03:58.899
matches up with the drawable 
names so there's an easy chain 

05:03:59.381 --> 05:04:02.952
you can follow.  We have a 
shape, it's a rectangle, it is 

05:04:03.230 --> 05:04:06.961
colored with a tint, which is 
our button-colored background 

05:04:07.229 --> 05:04:10.919
material.  This gets applied to 
the white color of the shape so 

05:04:12.062 --> 05:04:15.945
it's got a solid white color 
here.  Let's dig into the tint. 

05:04:16.349 --> 05:04:20.418
It is our color accent.  It is

05:04:26.424 --> 05:04:28.793
named buttoncoloredmaterialXML. 
A very clear line of 

05:04:29.050 --> 05:04:34.193
indirection.  So, where does 
this color accent from come?  

05:04:34.692 --> 05:04:39.154
It's going to come from whatever
exists in our application theme.

05:04:39.913 --> 05:04:45.123
That inherits from material and 
it will be the default teal.  

05:04:45.492 --> 05:04:48.328
So here are all the levels of 
indirection we've looked at.  

05:04:48.676 --> 05:04:51.683
Some of the important ones are 
if we want to change the style 

05:04:51.913 --> 05:04:55.946
for all buttons that get 
inflated, that's our button 

05:04:55.947 --> 05:05:00.020
style theme.  The button style 
that we're getting by default is

05:05:02.414 --> 05:05:05.012
widget.materialbutton.  We can 
change that to button.colored if

05:05:05.013 --> 05:05:11.272
we wanted color buttons 
everywhere.  We can also change 

05:05:11.433 --> 05:05:15.385
our color accent.  If we set 
that in our theme, that gets 

05:05:15.728 --> 05:05:19.315
used everywhere.  We'll see that
color everywhere.  

05:05:19.316 --> 05:05:23.063
But what we want to do is one 
button.  So, what would happen 

05:05:23.670 --> 05:05:25.670
if we set

05:05:27.329 --> 05:05:36.882
bet  button on our activity?  We
could see it everywhere.  What

05:05:37.385 --> 05:05:40.059
about in XML? 
How can we fix that?  Well, what

05:05:40.348 --> 05:05:45.364
if we set color accents on our 
activity theme, now we're 

05:05:45.635 --> 05:05:50.276
getting that blue button, but 
we're also getting blue switches

05:05:50.432 --> 05:05:55.961
and everything else.  If you do 
a search over XML files, you'll 

05:05:56.241 --> 05:06:00.521
see it in a lot of places. We 
could try setting it in 

05:06:01.632 --> 05:06:04.570
layoutXML.  This does absolutely
nothing because it's a theme 

05:06:05.339 --> 05:06:14.878
attribute and you shouldn't try 
to set it in Layout KWM  

05:06:16.305 --> 05:06:19.011
XML.  
We'll create a theme XML and 

05:06:19.310 --> 05:06:22.210
apply that to the button and 
we'll get what we wanted.  

05:06:22.211 --> 05:06:25.293
So, back to Nick for more 
implementation.

05:06:25.294 --> 05:06:28.322
Cheers.  
So, I said you should prefer 

05:06:28.323 --> 05:06:30.977
theme attributes where you can. 
But to do so, you kind of need 

05:06:31.407 --> 05:06:35.279
to know what is out there, what 
exists.  Honestly, I don't have 

05:06:35.500 --> 05:06:38.248
a great answer for you, other 
than looking through the file --

05:06:38.597 --> 05:06:42.999
this is from the Android 
platform or from appcompat or 

05:06:44.780 --> 05:06:49.267
material components.  They're 
not that long and you can see 

05:06:49.268 --> 05:06:53.238
what's available.  You can look 
at themes.material and see which

05:06:53.239 --> 05:07:00.245
theme attributes they set and as
such, you are able to reference 

05:07:00.246 --> 05:07:03.930
or overwrite yourselves.  
One note is that you might see 

05:07:04.760 --> 05:07:07.793
that some theme attributes are 
double-defined.  The platform 

05:07:07.794 --> 05:07:13.106
defines an Android color control
highlight and then appcompat 

05:07:13.401 --> 05:07:17.577
defines its own.  So, which do 
you use?  The answer is if there

05:07:17.578 --> 05:07:23.111
is one defined in the appcompat,
prefer that because it will set 

05:07:23.112 --> 05:07:26.604
the platform one for you and be 
available for backwards 

05:07:26.973 --> 05:07:29.742
compatibility.  
You can refer to these in code, 

05:07:30.026 --> 05:07:35.790
using something like this and 
uses KTX to make it more 

05:07:36.095 --> 05:07:40.085
convenient.  
So, so far, we've talked about 

05:07:40.446 --> 05:07:43.718
using platform theme attributes,
and you absolutely should.  But 

05:07:43.719 --> 05:07:49.734
you can also create your own.  
Let's walk through an example.  

05:07:50.187 --> 05:07:54.404
We have two screens, which 
display very similar layouts.  A

05:07:54.764 --> 05:07:59.142
list of schedule and speaker 
details.  They only differ in 

05:07:59.143 --> 05:08:01.681
the how far with the space on 
the space and the key line we 

05:08:02.381 --> 05:08:05.526
want to align it to.  You need 
to leave room for the sticky 

05:08:05.849 --> 05:08:10.415
header time things.  To 
accomplish this, we defined our 

05:08:10.416 --> 05:08:15.284
own theme attribute.  This is 
called sessionless keyline.  In 

05:08:15.285 --> 05:08:18.140
the different activity themes, 
we can provide different 

05:08:18.467 --> 05:08:20.612
dimension values for that 
keyline.  

05:08:20.613 --> 05:08:24.226
And then RGS we just have to 
have a single layout, which 

05:08:24.431 --> 05:08:30.123
references that -- that theme 
attribute using the question 

05:08:30.124 --> 05:08:34.152
mark syntax to vary it without 
having to maintain it, et 

05:08:34.562 --> 05:08:37.784
cetera.  
Another place that theming comes

05:08:37.785 --> 05:08:42.339
into handy is drawables.  We 
looked at the platform button 

05:08:42.636 --> 05:08:47.536
from API 21 onwards, all 
drawable support tint and tint 

05:08:47.890 --> 05:08:53.038
modes.  You can also do this in 
vectors where they support theme

05:08:53.039 --> 05:08:57.001
attributes for tints, as well as
for fills and strokes.  So you 

05:08:57.285 --> 05:09:03.039
can use this not just in 21, but
in the backwards compatibility 

05:09:03.497 --> 05:09:10.753
library as well.  If you need 
the backwards compatibility, you

05:09:10.754 --> 05:09:15.654
can use backwards.  
There is an override which lets 

05:09:15.655 --> 05:09:19.729
you set a tint list to be 
applied, which is something 

05:09:20.610 --> 05:09:25.406
we've learned to be extremely 
handy.  It provides different 

05:09:25.407 --> 05:09:28.528
tints and all colors for 
different states.  This is taken

05:09:28.941 --> 05:09:32.161
from text primary.  One of the 
things I love about colors like 

05:09:32.467 --> 05:09:37.045
this is some of the improvements
that arrived in Marshmallow 23, 

05:09:37.411 --> 05:09:41.293
which allowed you to separate 
out the color and alpha 

05:09:41.572 --> 05:09:45.923
component.  This protects you 
against the explosion of 20 

05:09:46.586 --> 05:09:49.900
different capacities of black.  
Actually separating out the -- 

05:09:50.192 --> 05:09:52.951
kind of the color information 
from the alpha information 

05:09:53.215 --> 05:09:57.321
allows you to define more 
specifically what you want.  

05:09:57.322 --> 05:10:02.019
Here, it was saying it's a light
screen and the foreground will 

05:10:02.020 --> 05:10:07.085
be ground.  You can say the text
will be black and have alphas.  

05:10:07.569 --> 05:10:11.772
So you don't have to define all 
the combinations, you define the

05:10:13.890 --> 05:10:18.156
semantically-named things.  And 
then they get combined by the 

05:10:18.429 --> 05:10:21.841
color state lists.  
I've cheated here and changed 

05:10:22.545 --> 05:10:27.840
the Android alpha to app alpha 
because appcompat back ports 

05:10:27.841 --> 05:10:33.052
this to added color state list, 
but it requires you to use App 

05:10:33.502 --> 05:10:37.404
Alpha.  
The alpha channel of the color 

05:10:38.194 --> 05:10:42.755
and the alpha are combined.  
Don't do this.  If you specify 

05:10:42.756 --> 05:10:47.821
-- this is a 50% white text if 
you don't speak heck and a 50% 

05:10:48.554 --> 05:10:52.637
alpha.  You'll end up with 20% 
alpha white.  You want to refer 

05:10:52.638 --> 05:11:01.472
to colors with full alphas.  
Like I said, appcompat has this 

05:11:01.473 --> 05:11:06.727
and use resources to get the 
backwards compatible behavior.  

05:11:07.072 --> 05:11:11.139
So, overall, if you apply this 
theming, you can get a state 

05:11:11.140 --> 05:11:15.534
like this.  So, on the left, 
these look quite similar.  On 

05:11:15.535 --> 05:11:21.949
the left, we have the Google 
I/O.  And to retheme it, to fit 

05:11:21.950 --> 05:11:26.743
in with the look and feel with 
this conference, rather than 

05:11:27.544 --> 05:11:29.544
I/O, this is the diffance.  We 
had to change the 

05:11:30.059 --> 05:11:34.367
semantically-named colors.  It 
ripples outwards, the bottom nav

05:11:34.368 --> 05:11:39.090
changes, some of the tints on 
drawables changes.  Think about 

05:11:39.638 --> 05:11:44.991
if your product manager comes to
you and says, we're changing all

05:11:45.452 --> 05:11:51.319
the colors.  Wouldn't you rather
have this rather than going 

05:11:51.989 --> 05:11:54.872
through all the XMLs and where 
is it?  You really want to limit

05:11:55.139 --> 05:11:59.166
the changes to these semantic 
names.  

05:11:59.167 --> 05:12:02.647
So, as a summary of this, 
really, really, like, theme 

05:12:02.990 --> 05:12:05.966
attribute all the things 
essentially.  Use them as just 

05:12:05.967 --> 05:12:08.723
kind of like protection and you 
should probably push that 

05:12:09.072 --> 05:12:12.622
semantic system back upwards to 
your designers so they are 

05:12:12.898 --> 05:12:17.340
giving you values that work with
this.  

05:12:17.341 --> 05:12:22.036
XML is the preferred syntax or 
be careful when you're not 

05:12:22.297 --> 05:12:25.042
writing this and thinking, is 
this a smell?  With your 

05:12:25.557 --> 05:12:31.343
drawables, think about using 
tints to protect yourself.  If 

05:12:31.766 --> 05:12:35.096
all these drawables had been 
pings instead and we had to 

05:12:35.097 --> 05:12:39.711
rebrand, am I going to have to 
regenerate all of these?  Ignore

05:12:40.112 --> 05:12:42.935
that, don't do that.  Use tints 
instead.  

05:12:42.936 --> 05:12:51.646
Basically, if every time you use
a PNG, think, should this be a 

05:12:52.300 --> 05:12:58.251
PNG.  Pretty much the only time 
you should be using PNG is for 

05:12:58.622 --> 05:13:03.540
matches.  So, that's a summary. 
Protect yourselves and have fun 

05:13:03.941 --> 05:13:08.419
with attributes and styles.  
Cheers.

05:13:29.825 --> 05:13:31.825
[Applause]

05:13:49.626 --> 05:13:54.698
  Hi, everyone.  Today, I'm 
going to be sharing some best 

05:13:55.106 --> 05:14:02.189
practices when using the 
AndroidX library.  I'm going to 

05:14:03.264 --> 05:14:10.933
be taking about preferences and 
shared preferences.  And I'm 

05:14:11.204 --> 05:14:18.298
going to cover how you can use 
multiple setting screens.  

05:14:18.299 --> 05:14:20.299
First some background.  What are

05:14:22.739 --> 05:14:26.613
preferences?  The preference 
library is for interactive 

05:14:26.914 --> 05:14:29.625
screens. All you need to do is 
find a list of settings to be 

05:14:29.914 --> 05:14:35.593
displayed to the user and it 
also handles interacting with 

05:14:35.594 --> 05:14:40.061
the device storage so any value 
the user changes would be 

05:14:41.858 --> 05:14:46.593
uploaded to the device.  
First, the framework preference 

05:14:46.947 --> 05:14:53.539
API.  This has been bundled with
the first Android framework. 

05:14:53.804 --> 05:14:57.276
Since it is part of the 
framework, any new features and 

05:14:57.277 --> 05:15:00.542
bug fixes we add only make their
way to the newer versions of 

05:15:00.840 --> 05:15:04.908
Android.  Given the design has 
changed, the framework API is 

05:15:05.267 --> 05:15:09.848
themed differently depending on 
which version of Android.  We're

05:15:12.585 --> 05:15:15.313
no longer maintaining the 
framework API and recommend 

05:15:16.045 --> 05:15:25.994
using the AndroidX library.  It 
was the V7 and V14.  It with be

05:15:26.961 --> 05:15:30.119
updated.  The library is 
backwards compatible down to API

05:15:30.745 --> 05:15:34.911
14 and uses the same updated 
material theme.  

05:15:34.912 --> 05:15:42.440
This results in a consistent 
experiences with your users.  

05:15:42.441 --> 05:15:47.380
How does it relate to shared 
preferences, you can have key 

05:15:47.759 --> 05:15:54.175
data.  They are used internally 
to save and retrieve any values 

05:15:55.132 --> 05:16:02.174
but aren't part of the library. 
We'll load the simple hierarchy 

05:16:03.072 --> 05:16:06.968
on the right.  We have a 
preference to

05:16:10.295 --> 05:16:15.965
toggling and one for text.  
So, we're going to start at the 

05:16:16.238 --> 05:16:23.588
top with a simple activity that 
acts as a container this should 

05:16:25.723 --> 05:16:29.117
have an appcompat theme.  This 
is the main entry point when 

05:16:29.392 --> 05:16:32.346
uses the preference library.  
All the interesting preferences 

05:16:32.347 --> 05:16:35.747
and configuration will happen in
here.  This fragment, itself, 

05:16:36.164 --> 05:16:39.198
just wraps a hierarchy of 
individual preferences, which 

05:16:40.165 --> 05:16:43.339
can be defined in an XML 
resource or programatically in 

05:16:43.564 --> 05:16:45.815
runtime.  We're going to focus 
on XML.  

05:16:45.816 --> 05:16:50.128
So, the activity, itself, is 
just a simple container for our 

05:16:50.524 --> 05:16:54.779
fragment.  We have fragment 
boilerplate and show the 

05:16:55.597 --> 05:16:59.735
fragment. The fragment, again, 
fairly simple.  All you need to 

05:17:00.564 --> 05:17:06.856
do is overwrite this and set up 
the hierarchy. The interesting 

05:17:07.530 --> 05:17:12.023
definition happens in the XML.  
So, this is our XML file.  We 

05:17:12.024 --> 05:17:15.121
start with a root preference 
screen object and this is the 

05:17:16.611 --> 05:17:20.890
main container for the 
hierarchy.  Note that you should

05:17:21.708 --> 05:17:29.026
also place your preference XML 
in the XML directary.  This is a

05:17:29.027 --> 05:17:32.254
basic preference, it doesn't 
have any widget associated with 

05:17:32.950 --> 05:17:39.121
it and we have three important 
attributes here.  The title and 

05:17:39.336 --> 05:17:42.987
summary are displayed to the 
user.  The key is pretty 

05:17:43.357 --> 05:17:46.017
important.  If this preference 
were to persist any state to the

05:17:46.018 --> 05:17:49.252
device, then this is the key 
that the shared preference would

05:17:49.573 --> 05:17:55.369
use.  This key allows you to 
interact with this preference 

05:17:55.909 --> 05:18:00.252
later on in the lifecycle.  
Now we can add a switch 

05:18:01.064 --> 05:18:03.894
preference compat.  This is 
similar to before, but now we 

05:18:04.097 --> 05:18:13.336
have a switch widget.  Whenever 
the user toggles it, it will go 

05:18:13.337 --> 05:18:19.922
to the key defined here.  
Here's the hierarchy we're going

05:18:19.923 --> 05:18:25.892
to end up here.  We're going to 
take is step-by-step.  I'm going

05:18:25.893 --> 05:18:30.016
to cover categories to split up 
complex groups and preferences 

05:18:30.323 --> 05:18:34.626
that open dialogues which allow 
for more complex configuration. 

05:18:34.954 --> 05:18:40.082
I'm going to talk about dynamic 
summaries and also cover 

05:18:40.411 --> 05:18:42.932
dependencies.  
So, continuing from where we 

05:18:43.194 --> 05:18:49.140
left off before, these are the 
same preferences we had before, 

05:18:49.554 --> 05:18:54.348
one of these controls syncing 
some one displays static 

05:18:55.867 --> 05:18:57.979
information about the 
application.  The more we add to

05:18:57.980 --> 05:19:04.555
this hierarchy, the harder it's 
going to be for the user to see 

05:19:05.487 --> 05:19:10.813
what does what.  We can set this
up in logical subsections.  We 

05:19:10.814 --> 05:19:16.510
wrap it with a preference 
category tag.  It adds an 

05:19:16.719 --> 05:19:20.053
accented title above the groups.
It's important to set a key for 

05:19:20.368 --> 05:19:23.942
these so it will be a 
correctly-persisted state.  Same

05:19:24.345 --> 05:19:28.444
as before, same attribute, just 
displayed slightly differently. 

05:19:28.970 --> 05:19:34.807
Next we're going to add an edit 
text preference.  This 

05:19:35.096 --> 05:19:38.273
preference uses a dialogue to 
allow persisting a string value 

05:19:38.544 --> 05:19:42.342
when a user taps on this 
preference, we open a dialogue 

05:19:42.644 --> 05:19:48.044
for you which contains an 
editable text field.  However, 

05:19:48.674 --> 05:19:52.013
this gives us some interesting 
questions.  What do we set for 

05:19:52.014 --> 05:19:54.847
the summary here?  Right now, 
there's no summary so it's quite

05:19:54.848 --> 05:19:59.844
hard for the user to see what 
the current state is and we'd 

05:20:00.355 --> 05:20:05.066
like to let the user see what 
they've saved.  

05:20:05.067 --> 05:20:08.166
The answer here is to use simple
summary provider.  This is added

05:20:08.975 --> 05:20:13.127
recently in the 1.1 alpha 
release and it's part of a broad

05:20:14.117 --> 05:20:18.377
category of things we call 
dynamic summaries.  This simple 

05:20:19.062 --> 05:20:23.464
attribute, when set to true, 
will mean the preference summary

05:20:23.718 --> 05:20:28.826
will show the preference or the 
text set.  We have a way for the

05:20:29.183 --> 05:20:34.851
user to set a sync code and see 
it automatically.  However, it 

05:20:35.139 --> 05:20:38.233
doesn't make sense for the user 
to be able to change this field 

05:20:38.539 --> 05:20:42.785
if syncing isn't enabled.  We 
can use a dependency here to fix

05:20:43.188 --> 05:20:45.334
that.  
Essentially, setting a 

05:20:45.749 --> 05:20:48.238
dependency allows another 
preference to control the state 

05:20:48.239 --> 05:20:53.877
of this preference.  So, we set 
the key of the switch prefance 

05:20:54.273 --> 05:20:57.946
compat.  Whenever the switch 
prefance is turned off, it is 

05:20:58.624 --> 05:21:03.326
grayed out and can no longer be 
interacted with.  When it is 

05:21:04.051 --> 05:21:10.332
turned on, it goes back to 
normal.  

05:21:10.333 --> 05:21:15.752
Or hierarchy is almost complete.
Enable periodic syncing is on, 

05:21:15.753 --> 05:21:21.780
but what does that mean?  Have 
we synced recently?  We can use 

05:21:21.781 --> 05:21:26.464
a custom dynamic summary to 
display when we've lost sync, 

05:21:26.801 --> 05:21:32.562
providing more useful context.  
Dynamic summaries are good if 

05:21:32.825 --> 05:21:38.327
you'd like to provide the user 
with more context.  So, in this 

05:21:38.328 --> 05:21:41.568
case, we'd like to tell them 
when we last synced their device

05:21:41.948 --> 05:21:44.631
or when you want to display 
dynamic

05:21:48.980 --> 05:21:53.322
information.  This could be 
version information or an

05:21:56.439 --> 05:22:02.134
ID address.  
We can use this to react or do a

05:22:02.523 --> 05:22:09.092
summary from external state.  We
switch this.  When the 

05:22:09.304 --> 05:22:13.447
preference is checked, when 
syncing enabled, we want to 

05:22:13.716 --> 05:22:16.298
display the last time we 
successfully synced.  Otherwise,

05:22:16.706 --> 05:22:21.207
we're going to say it's 
disabled.  All we need to do now

05:22:21.208 --> 05:22:26.121
is set this on the preference.  
So, to do that, we call 

05:22:29.083 --> 05:22:35.315
find-preference.  And then we 
just set the summary.  This 

05:22:35.776 --> 05:22:37.776
should be done in 

05:22:40.373 --> 05:22:44.716
oncreate.  The summary will be 
updated based on the constraints

05:22:45.116 --> 05:22:51.216
we've designed. 
I'm going do use separate 

05:22:52.014 --> 05:22:56.132
hierarchies in separate screens.
A lot of times you'll want to 

05:22:56.410 --> 05:23:01.130
separate complex hierarchies in 
separate screens.  If you're 

05:23:01.873 --> 05:23:04.965
already using the framework API,
there are some different ways 

05:23:04.966 --> 05:23:08.099
you have structured your 
separate screens.  If you're 

05:23:08.613 --> 05:23:13.956
starting fresh, you may be 
wondering what the best way of 

05:23:14.250 --> 05:23:17.804
handling this is.  We have our 
activity at the top, which will 

05:23:18.668 --> 05:23:24.505
internally wrap a fragment, 
which contains the hierarchy.  

05:23:24.694 --> 05:23:30.083
We can consider it to be a 
screen of settings.  We have an 

05:23:31.472 --> 05:23:34.688
activity who loads a setting 
screen.  This looks fine when we

05:23:34.973 --> 05:23:40.901
have one screen.  What if our 
hierarchy looks like this?  We 

05:23:40.902 --> 05:23:46.552
have links to other screens.  
And messages will link to some 

05:23:47.089 --> 05:23:50.088
more specific messages 
preferences.  How does this look

05:23:50.363 --> 05:23:53.930
like with our architecture?  
It's very simple to what we've 

05:23:54.195 --> 05:23:57.641
done previously with a single 
screen.  

05:23:57.642 --> 05:24:01.057
The initial setting screen will 
be compat with a hierarchy.  And

05:24:01.339 --> 05:24:05.569
then the sync-scanning screen 
will be fragment with a 

05:24:06.143 --> 05:24:10.506
hierarchy and so on for any 
other screens you have.  All we 

05:24:10.797 --> 05:24:15.249
need to do is the final link 
between the preference.  So 

05:24:17.598 --> 05:24:19.598
whenever the

05:24:21.598 --> 05:24:27.807
user can load the screen.  And 
they tap a preference, we're 

05:24:27.808 --> 05:24:30.740
going to swap out the screen 
from underneath. 

05:24:30.741 --> 05:24:35.012
Because we're using preferences,
the initial settings

05:24:38.222 --> 05:24:42.364
hierarchy is going to be as 
we've done before.  We have two 

05:24:42.640 --> 05:24:46.610
preferences, one for syncing and
one for messages. 

05:24:46.611 --> 05:24:51.440
You may want to add an icon here
to provide more context to the 

05:24:51.653 --> 05:24:54.511
user.  This is just done by 
defining a drawable with the 

05:24:55.555 --> 05:24:59.886
icon attribute.  So this will be
something like a drawable 

05:25:01.603 --> 05:25:05.140
directary.  So to do this, we 
use the fragment attribute and 

05:25:05.404 --> 05:25:09.082
set the class name of the 
fragment.  

05:25:09.083 --> 05:25:13.673
If your fragment is nested in a 
class, you'll need to use a 

05:25:13.923 --> 05:25:16.196
dollar sign and that's it for 
the hierarchy. 

05:25:22.351 --> 05:25:27.083
The activity is similar to 
before.  We should implement 

05:25:27.084 --> 05:25:30.090
this preference.  This is called
when a user tapped on a 

05:25:30.091 --> 05:25:36.452
preference and allows you to 
customize anything.  There is a 

05:25:41.594 --> 05:25:43.927
default implementation.  
And the fragments are going to 

05:25:43.928 --> 05:25:50.469
be exactly the same as before.  
Again, we overwrite oncreate 

05:25:51.198 --> 05:25:54.984
preferences and that's really it
now.  When they tap on the 

05:25:55.716 --> 05:25:58.905
message, the fragment will be 
automatically displayed to the 

05:25:59.278 --> 05:26:03.232
user.  
So, to wrap some things, we've 

05:26:03.233 --> 05:26:10.640
released 1.1 alpha 1, please, if
you haven't already, get it.  

05:26:11.448 --> 05:26:16.961
Please file any bugs on 
issuetracker.Google.com.  We've 

05:26:18.129 --> 05:26:21.732
updated the Android settings 
guide.  Please check it out for 

05:26:22.009 --> 05:26:26.066
further infermation on some of 
the things I've talked about in 

05:26:26.067 --> 05:26:31.293
this talk and we're working on 
template and public samples, 

05:26:31.878 --> 05:26:33.963
demonstrating this library, 
coming soon.  

05:26:33.964 --> 05:26:38.797
For more information on Android 
Jetpack, you can go to 

05:26:41.027 --> 05:26:45.228
developer.com/developer.  
And, thank you for listening.

05:26:49.671 --> 05:26:52.363
[Applause]
  Everyone, our next session 

05:26:52.364 --> 05:26:56.790
will begin in just over 10 
minutes.  Thank you. 

05:39:55.195 --> 05:40:00.911
  Hey, my name is Cameron 
Ketcham.  I work on the material

05:40:01.414 --> 05:40:07.962
design components team and I 
work out of the New York City.

05:40:08.851 --> 05:40:12.553
  I'm Gautham Sajith and I'm 
based in San Francisco. 

05:40:12.554 --> 05:40:16.557
We are going to talk about 
Material Design components.  So,

05:40:16.961 --> 05:40:21.621
quickly, what we're going to 
discuss, a brief history of 

05:40:22.218 --> 05:40:26.963
Material Design, what Material 
Theming is, using Material 

05:40:27.594 --> 05:40:30.372
Design components, the color 
type and shape subsystems and 

05:40:30.958 --> 05:40:33.921
how to apply these subsystems, 
as well as our release process 

05:40:34.547 --> 05:40:39.190
and a little bit about 
contributing.  Quickly, just a 

05:40:40.686 --> 05:40:45.608
brief history, Material Design 
was announced in 2014 and there 

05:40:46.401 --> 05:40:50.147
wasn't a Material Design 
library.  At I/O, a year later, 

05:40:50.148 --> 05:40:53.227
Google announced the support 
library, which helped bring a 

05:40:54.062 --> 05:41:01.814
lot of code for certain 
componentcomponents, including 

05:41:02.292 --> 05:41:06.322
navigation drawer, but there 
still wasn't that much.  

05:41:06.323 --> 05:41:11.024
This year, we announced Material
Theming to have a larger 

05:41:11.517 --> 05:41:14.598
engineering team behind it so 
we're working on implementing a 

05:41:15.748 --> 05:41:20.699
lot of the components based on 
the Material Design spec.  

05:41:20.700 --> 05:41:24.302
So Material Theming, what was 
the original problem with 

05:41:24.534 --> 05:41:28.153
Material Design?  Well it was a 
great initial version of a 

05:41:29.248 --> 05:41:32.550
design system.  It fell short 
with the expression of brand.  

05:41:32.760 --> 05:41:37.494
So, here's an example of an 
email app and it looks kind of 

05:41:37.495 --> 05:41:40.972
like every other app that use 
Material Design and it's hard to

05:41:42.413 --> 05:41:47.242
tell it's even an email app, in 
my opinion.  Here's an example 

05:41:47.542 --> 05:41:50.589
of the kinds of things you can 
do with Material Theming to make

05:41:51.130 --> 05:41:54.234
your apps stand out and we're 
going to get into those details 

05:41:54.528 --> 05:41:59.344
in a bit.  
So, quickly, how does theming 

05:41:59.507 --> 05:42:03.662
work?  Basically, theming is a 
system that we've designed to 

05:42:03.904 --> 05:42:07.265
help you create a unique design 
for your app.  You need to 

05:42:07.527 --> 05:42:13.406
decide on fonts, colors, shapes,
et cetera and this is a Material

05:42:13.835 --> 05:42:19.533
Design sketch plugin that can be
used, which can help you create 

05:42:19.534 --> 05:42:25.970
design ideas.  Take a look at 
material.io for more information

05:42:26.823 --> 05:42:32.777
on that tool.  
These are material theming and 

05:42:33.359 --> 05:42:37.689
they all look quit different and
there's also a lot more of these

05:42:38.082 --> 05:42:45.506
on material.io.
  Cool, so now let's talk about 

05:42:45.507 --> 05:42:49.768
how to get started using the 
material components library.  

05:42:50.038 --> 05:42:56.139
So, imagine this scenario, you 
got this fairly-plain app and 

05:42:56.438 --> 05:43:03.301
your teammate asked you to 
redesign it.  So, you may be 

05:43:03.565 --> 05:43:09.204
familiar with the support 
library design package, the V 28

05:43:09.205 --> 05:43:12.768
version and you can use this.  
However, this is no longer being

05:43:13.794 --> 05:43:21.516
updated so you should use the 
AndroidX.  One thing to note, 

05:43:22.683 --> 05:43:26.361
you can't use the com.Android.  
If you want to switch over to 

05:43:26.819 --> 05:43:29.529
AndroidX, there's a nice 
refactor tool on the site 

05:43:30.009 --> 05:43:32.638
that'll help you refactor your 
app.  

05:43:32.639 --> 05:43:38.433
And then the next thing you'll 
need to do is use our material 

05:43:38.434 --> 05:43:41.458
themes that correspond to the

05:43:48.614 --> 05:43:51.852
Appcompat themes.  It helps you 
with default styles you can use 

05:43:53.517 --> 05:44:00.779
across all of our components.  
If you use 

05:44:04.101 --> 05:44:09.275
appcompat.lite, you should have 
all our attributes and component

05:44:10.067 --> 05:44:15.318
styles.  If you use our 
components without these 

05:44:15.319 --> 05:44:19.922
defined, you'll get an error at 
runtime.  If they don't exist, 

05:44:19.923 --> 05:44:24.406
it will crash at runtime.  Use 
our theme, it'll give you all 

05:44:24.407 --> 05:44:27.715
the attributes.  If you're not 
quite ready to switch over to 

05:44:28.268 --> 05:44:32.389
our full theme, you want to get 
the attributes, you can use the 

05:44:33.230 --> 05:44:36.387
bridge themes and what these 
bridge themes do is provide you 

05:44:37.110 --> 05:44:39.446
all the attributes but they 
don't give you any of the 

05:44:39.807 --> 05:44:44.890
default styles so you can opt in
to use our components one by 

05:44:44.891 --> 05:44:47.490
one.  
If you're extending from a 

05:44:47.491 --> 05:44:52.195
bridge theme and you want to opt
in, you would define in your 

05:44:52.457 --> 05:44:58.039
theme and then all of your 
bottom app bars would get the 

05:44:58.774 --> 05:45:00.774
component style.
  So, now, we're just going to 

05:45:01.284 --> 05:45:04.667
talk a little bit about some new
components.  With Material 

05:45:04.668 --> 05:45:09.059
Theming, we introduced a few new
things, such as the bottom app 

05:45:09.345 --> 05:45:12.736
bar.  The bottom app bar 
displays navigation and key 

05:45:13.013 --> 05:45:16.481
actions at the bottom of mobile 
screens, which are great for 

05:45:16.971 --> 05:45:21.423
people who are one-handed, using
their thumb to interact with the

05:45:21.424 --> 05:45:24.797
device.  It uses a coordinator 
layout to coordinate the motion 

05:45:25.036 --> 05:45:28.405
between a bottom app bar and a 
floating action button.  

05:45:28.406 --> 05:45:33.718
So, here, we just have simple 
XML for the bottom map bar.  A 

05:45:34.216 --> 05:45:40.386
few of the things you can do is 
set the vertical off-set and set

05:45:40.879 --> 05:45:44.936
the fab cradle margin, which is 
the distance between the fab and

05:45:45.202 --> 05:45:50.999
the bottom app bar and the 
rounded corner radius, which is 

05:45:51.464 --> 05:45:56.237
the corner where the bottom 
meets the fab.  You can have the

05:45:56.849 --> 05:46:00.492
bottom app bar hide on scroll 
and set this alignment mode.  It

05:46:00.493 --> 05:46:07.427
will animate the fab for you.  
And it's useful if you're going 

05:46:07.751 --> 05:46:10.964
between different screens.  
If you're already using a 

05:46:11.695 --> 05:46:15.574
toolbar, it's super easy to 
start using the bottom app bar. 

05:46:15.882 --> 05:46:18.993
If you're setting the support 
action bar, set it for the 

05:46:19.281 --> 05:46:23.535
bottom app bar instead and 
everything else works the same 

05:46:23.536 --> 05:46:29.177
way.  You can use an on-menu 
click listener directly on the 

05:46:29.391 --> 05:46:33.890
bottom app bar.
  We also have what's revamped 

05:46:35.037 --> 05:46:41.198
version of the button to make 
styling much simpler.  So, if 

05:46:41.613 --> 05:46:46.089
you just put this material 
button component in your XML, 

05:46:46.445 --> 05:46:50.664
you'll get a styled button.  If 
you're using our full theme, you

05:46:50.665 --> 05:46:52.665
can use the button tag

05:46:55.011 --> 05:46:57.011
in your XML and we do custom 
view inflation where this will 

05:46:57.238 --> 05:47:00.623
inflate into a material button 
tag and you can see the disabled

05:47:00.931 --> 05:47:04.961
state on this button and all the
states will transfer over.  You 

05:47:05.353 --> 05:47:08.939
can set an icon on this button 
by setting the icon attribute as

05:47:08.940 --> 05:47:12.949
well as this icon style and this
style's optional, but what it'll

05:47:13.346 --> 05:47:17.467
do is it'll adjust the padding 
slightly to

05:47:20.537 --> 05:47:24.416
achieve more balance on the 
button.  

05:47:24.417 --> 05:47:30.874
You can set the outline button 
to get the hairline button.  You

05:47:31.473 --> 05:47:35.897
can set the background tint of 
the button by sitting the 

05:47:36.157 --> 05:47:38.782
background tint attribute and 

05:47:41.869 --> 05:47:44.450
provide a color state list.  
You can set some other 

05:47:45.236 --> 05:47:48.373
attributes, such as stroke 
width, stroke color, corner 

05:47:49.790 --> 05:47:56.497
radius on this button.  You can 
also create just an icon-only 

05:47:56.927 --> 05:47:59.780
button.  We're setting the icon 
and setting the padding to zero 

05:48:00.348 --> 05:48:04.244
so the icon is centered in the 
button and we set the content 

05:48:04.591 --> 05:48:07.726
description on this button.  
Since there's no text, you 

05:48:08.155 --> 05:48:10.155
should set a

05:48:11.974 --> 05:48:14.125
description.  
You can set the ripple color on 

05:48:14.880 --> 05:48:19.714
the button.  If you set a purple
ripple on here and apply it to 

05:48:20.067 --> 05:48:26.272
the button, you can do a color 
state list or hex color here.  

05:48:26.865 --> 05:48:34.502
It's a purple ripple, it's on 
top of a green button.  

05:48:34.503 --> 05:48:38.320
And these are some of the 
examples.  We have several 

05:48:38.589 --> 05:48:46.804
different styles of chips, text 
fields, password show and hide 

05:48:47.314 --> 05:48:49.965
functionality and layouts, as 
well.

05:48:50.282 --> 05:48:58.071
Okay.  Now, a little bit about 
theming.  MDC replies on the 

05:48:58.629 --> 05:49:03.470
theming of Android so here's a 
quick refresher of how themes 

05:49:03.791 --> 05:49:10.608
and styles work.  Anything 
applied directly to a view in 

05:49:11.294 --> 05:49:17.983
XML will only change the single 
view.  You can also update the 

05:49:18.358 --> 05:49:24.599
style.  So, if you set an 
attribute in a style, changing 

05:49:24.886 --> 05:49:30.262
this here will affect any fews 
that are using this style.  

05:49:30.263 --> 05:49:34.729
If it's not to define a style or
there's no style set, it'll go 

05:49:34.906 --> 05:49:40.777
back to the default style.  So, 
here, if you want to change the 

05:49:40.778 --> 05:49:45.968
way a whole group of components 
look, you can set the default 

05:49:46.251 --> 05:49:49.342
style.  And then finally, if 
that attribute isn't defined 

05:49:49.710 --> 05:49:52.811
anywhere else, it'll look in the
theme.  The way Material Theming

05:49:53.476 --> 05:49:57.444
works is there's a set of 
top-level attributes you should 

05:49:57.832 --> 05:50:02.606
overwrite for tipography, 
colors, shapes and the default 

05:50:02.607 --> 05:50:05.687
styles.  If you need more 
fine-grain control, you can hook

05:50:05.688 --> 05:50:11.225
in, in any of these layers, and 
change just the color of a 

05:50:11.501 --> 05:50:17.427
single view or the color of all 
a certain component.  

05:50:17.428 --> 05:50:24.453
Here's an example from our 
library of the chip.  It comes 

05:50:24.454 --> 05:50:28.511
from the fact that other styles,
in our library, can reference 

05:50:29.771 --> 05:50:33.380
these same attributes.  Here's 
an example of a button.  They 

05:50:33.381 --> 05:50:36.348
have the same shape appearance, 
which is the small component 

05:50:36.602 --> 05:50:40.579
shape appearance.  If we want to
update the look and feel of our 

05:50:40.811 --> 05:50:46.086
app for these small components, 
all we have to do is update this

05:50:46.087 --> 05:50:51.145
attribute in one place in our 
theme and we'll show you an 

05:50:52.373 --> 05:50:57.524
example in a little bit.  
What are the affects of these 

05:50:57.910 --> 05:51:01.319
attributes?  We try to apply 
theme attributes in a way that 

05:51:01.713 --> 05:51:04.869
would make sense, but it's 
definitely possible for you to 

05:51:07.291 --> 05:51:10.184
pick values for different colors
that may not look great 

05:51:10.597 --> 05:51:14.590
together.  You should check out 
material.io to see how it'll 

05:51:15.199 --> 05:51:22.178
react.  Another simple solution 
that you could do is to make a 

05:51:22.613 --> 05:51:27.812
debug theme which sets whacky 
values and see how things look. 

05:51:27.813 --> 05:51:33.023
Here's the bottom map bar on the
material.io site and you can 

05:51:34.447 --> 05:51:40.103
see, there, that the container 
itself is, like, a surface and 

05:51:40.383 --> 05:51:46.766
the icons are the on-surface.  
And, we'll talk about which 

05:51:47.159 --> 05:51:50.261
attributes you can modify, as 
well as things to look at for in

05:51:50.470 --> 05:51:54.728
the next section. 
So, theming subsystems.  We 

05:51:55.128 --> 05:51:59.514
currently have type, color and 
shape.  These are the ones you 

05:52:00.305 --> 05:52:04.277
should tweak in order to theme 
your app.  Hopefully most of you

05:52:04.278 --> 05:52:08.457
are familiar with text 
appearances.  But we've 

05:52:09.156 --> 05:52:12.609
incorporated Material Theming, 
which using theme attributes, to

05:52:12.610 --> 05:52:15.971
reference these text 
appearances.  So, here's an 

05:52:16.284 --> 05:52:21.798
example of a toolbar, which uses
the headline six attribute 

05:52:22.772 --> 05:52:27.653
rather than a style directly.  
And here are some copy that uses

05:52:27.850 --> 05:52:31.065
the body one attribute.  These 
are the type attributes that 

05:52:32.070 --> 05:52:34.712
we've defined so if you 
overwrite any of these in your 

05:52:35.396 --> 05:52:42.683
theme, you can set the style and
look of your app.  

05:52:42.684 --> 05:52:47.992
Color's another one and you're 
probably familiar with primary 

05:52:48.201 --> 05:52:53.114
color and primary accents.  We 
have a wider range of colors so 

05:52:53.411 --> 05:52:58.528
you have more control.  These 
are the semantic names of the 

05:52:59.405 --> 05:53:04.996
pallet of colors that work with 
cullerative theming.  We have 

05:53:05.804 --> 05:53:10.872
primary, primary veryiants.  
Those are the things you should 

05:53:11.121 --> 05:53:14.709
generally theme to be the stale 
of your app.  There's also a 

05:53:15.179 --> 05:53:18.351
background surface and error 
colors.  You can style those, 

05:53:18.611 --> 05:53:23.881
but you don't necessarily have 
to.  And then the on-primary, 

05:53:25.821 --> 05:53:28.106
the on-secondary, those need to 
be accessible when they're drawn

05:53:28.393 --> 05:53:33.006
on top of the other colors.  
On-primary, that will be drawn 

05:53:33.287 --> 05:53:37.121
on top of the primary color.  If
you have text shown on top of 

05:53:37.414 --> 05:53:43.485
the primary background, it 
should be the on-primary color. 

05:53:43.847 --> 05:53:46.871
These are the color attributes 
that we've defined.  You can see

05:53:47.229 --> 05:53:50.986
that there's a lot of new ones. 
We tried to reuse some that came

05:53:51.293 --> 05:53:54.947
from appcompat and we have 
Android color background that we

05:53:54.948 --> 05:53:58.348
use, which is just the regular 
Android version of that 

05:53:58.695 --> 05:54:02.226
attribute.  
Shape is another subsystem that 

05:54:02.458 --> 05:54:06.155
you can theme.  And it all 
happens with material shape 

05:54:06.488 --> 05:54:11.082
drawable.  So, we're adding 
material shape drawable as the 

05:54:11.501 --> 05:54:13.501
background for buttons, 

05:54:16.638 --> 05:54:20.735
cards, fab, bottom map bar.  It 
works with edge and corner 

05:54:21.316 --> 05:54:23.391
treatments.
We have edge and corner 

05:54:24.608 --> 05:54:30.624
treatments defined for rounded 
and cut corner, which is every 

05:54:30.972 --> 05:54:34.131
component you're going to find. 
You can always create your own, 

05:54:34.370 --> 05:54:38.021
as well.  
So, here's an example of Kotlin 

05:54:38.851 --> 05:54:42.399
code, which defines a rounded 
corner, treatment and sets that 

05:54:42.663 --> 05:54:46.878
to the material shape drawable, 
to apply rounded corners to 

05:54:48.091 --> 05:54:52.705
everything.  Here is the XML 
version, as well.  So, if you 

05:54:52.907 --> 05:54:57.915
want to do it in XML, we have 
shape appearance and it's 

05:54:58.884 --> 05:55:01.953
similar to text appearance.  The
attributes, here, are the corner

05:55:03.094 --> 05:55:08.334
family and the corner size and 
this sets it to be a rounded 

05:55:09.052 --> 05:55:14.104
corner with 24Dd radius.  You 
can overwrite individual 

05:55:14.493 --> 05:55:19.711
corners.  We are overwriting the
top left to be cut and you can 

05:55:20.023 --> 05:55:23.391
do the same thing in XML.  One 
thing to notice is that we're 

05:55:23.596 --> 05:55:27.848
using a shape appearance overlay
here, which is basically the 

05:55:29.163 --> 05:55:32.680
same thing except for we only 
define the attributes that we 

05:55:34.199 --> 05:55:41.987
want to override.  The material 
button has a shape appearance 

05:55:42.325 --> 05:55:46.515
some here, we're setting the top
right corner to be cut.  

05:55:46.516 --> 05:55:49.803
Everything else will be 
inherited from the style of the 

05:55:50.465 --> 05:55:52.960
material button.  
One key

05:55:55.974 --> 05:56:00.840
idea of Material Theming is to 
add mapping.  This can help give

05:56:01.048 --> 05:56:06.066
your app a more consistent look 
and feel by connecting surfaces 

05:56:06.067 --> 05:56:11.085
through shape.  There's small, 
medium and large components and 

05:56:11.086 --> 05:56:14.112
these are the attributes you can
set in your theme.  If you want 

05:56:14.113 --> 05:56:17.882
to restyle all the small 
components to have a cut right 

05:56:18.233 --> 05:56:25.372
corner, you can do that.  
Here's an example where, just 

05:56:25.373 --> 05:56:32.507
like I said, overriding the 
small component style.  So, we 

05:56:32.892 --> 05:56:36.581
redefine the small appearance, 
the small component shape 

05:56:37.034 --> 05:56:40.706
appearance, in the theme, to our
style.  And here, we're setting 

05:56:40.707 --> 05:56:44.330
the top-right corner to be cut 
and we're also setting the 

05:56:44.720 --> 05:56:48.436
parent here so that will inherit
all of the other -- the rounded 

05:56:48.931 --> 05:56:54.634
corners for the other parts.  
Shadow is something we want to 

05:56:54.914 --> 05:56:58.860
mention, as well.  Native 
elevation is supported for 

05:56:59.231 --> 05:57:03.757
shapes on Lollipop.  For API 21 
and up.  But we're back porting 

05:57:04.838 --> 05:57:10.128
shadows to API 15 for both 
concave and convex shapes for 

05:57:10.842 --> 05:57:15.012
common cases, such as rounded or
cut corners, as well as for the 

05:57:15.281 --> 05:57:19.992
bottom map bar because this has 
the cut-out inside of it.  It 

05:57:20.264 --> 05:57:27.823
won't get native shadow, so we 
fake the shadow with a gradient.

05:57:27.824 --> 05:57:33.607
  Now that we've heard about our
theming subsystem, how do you 

05:57:33.962 --> 05:57:39.587
apply those to your app?  You 
have this appcompat app, we'll 

05:57:39.832 --> 05:57:43.974
be building something that looks
a little bit like this.  When 

05:57:44.280 --> 05:57:50.186
you build your own apps, it will
look much more beautiful and 

05:57:50.187 --> 05:57:54.552
cohesive than this.  So, first 
thing you'd have to do is, if 

05:57:54.826 --> 05:57:59.076
you're using action bar theme, 
you can switch over to material 

05:57:59.284 --> 05:58:01.816
components theme.  We're using 
the bridge theme because we want

05:58:02.149 --> 05:58:07.263
to opt-in to using those one by 
one.  Generally we recommend you

05:58:07.952 --> 05:58:12.168
switch to the full theme, the 
regular theme before trying out 

05:58:12.169 --> 05:58:16.082
the bridge theme.  
So, let's say you set these 

05:58:17.049 --> 05:58:22.517
theme color attributes.  Some of
the existing ones you know are 

05:58:22.791 --> 05:58:29.271
primary and secondary.  There is
primary on-secondary.  You'll 

05:58:30.230 --> 05:58:34.452
see this color secondary doesn't
show up anywhere in your app 

05:58:34.782 --> 05:58:38.782
yet, but it will.  
Next thing we want to do is get 

05:58:39.359 --> 05:58:41.995
material buttons.  If you set 
the material button style in 

05:58:42.289 --> 05:58:45.981
your theme, all of your buttons 
should turn into material 

05:58:46.255 --> 05:58:52.085
buttons when you change the XML 
tag.  If you're using our full 

05:58:52.357 --> 05:58:56.187
theme, this happens 
automatically.  

05:58:56.188 --> 05:59:03.666
We have a bunch of other default
styles we've laid out here, all 

05:59:04.363 --> 05:59:12.203
it's component name, plus style.
For example, if you would set

05:59:16.070 --> 05:59:18.468
material card style in your 
theme.  And then we're going to 

05:59:18.776 --> 05:59:25.624
be applying some attributes to 
these cards.  You can sent card 

05:59:25.900 --> 05:59:33.417
elevation, stroke color and 
stroke width.  

05:59:33.418 --> 05:59:35.465
And then say you wanted to 
change the base style of all the

05:59:36.534 --> 05:59:39.378
buttons, you would define your 
own button style and set the 

05:59:39.793 --> 05:59:43.997
parents of it to outline button 
and then all of your buttons 

05:59:44.271 --> 05:59:48.225
change into outline buttons.  
We can now apply some shape 

05:59:48.408 --> 05:59:53.511
theming to all of your buttons. 
So, we're going define the shape

05:59:55.163 --> 05:59:58.433
appearance and set the right 
corners to be cut and the left 

05:59:59.105 --> 06:00:02.689
corners to be rounded and set 
the corner size and now you have

06:00:02.910 --> 06:00:07.657
this arrow-shaped button.  You 
can also do this using a shape 

06:00:07.919 --> 06:00:11.814
appearance overlay, since 
buttons have a rounded corner by

06:00:11.815 --> 06:00:15.987
default.  You don't have to set 
it for the left side.  You deset

06:00:15.988 --> 06:00:20.959
what you're changing and it'll 
take effect as normal.  

06:00:20.960 --> 06:00:24.283
And then say we wanted to have 
some icon buttons, you would 

06:00:24.822 --> 06:00:28.449
define this icon button style.  
Set the paddings and minwidths 

06:00:29.006 --> 06:00:33.318
as you want and then apply this 
to your button directly in the 

06:00:33.319 --> 06:00:37.172
XML, as well as setting that 
icon in content description and 

06:00:37.173 --> 06:00:41.565
then you have the share icon 
button instead of that share 

06:00:41.919 --> 06:00:45.532
text button.  
You can also switch over to the 

06:00:45.876 --> 06:00:50.016
bottom map bar.  So for this, 
you'd have to set it in your 

06:00:50.017 --> 06:00:55.055
theme and then remove the top 
app bar from your XML layout and

06:00:55.056 --> 06:01:00.910
add this bottom app bar here.  
You can add a floating action 

06:01:01.189 --> 06:01:03.746
button by adding the floating 
action button to your layout and

06:01:04.942 --> 06:01:08.682
setting the layout anchor 
attribute to point to the app 

06:01:09.104 --> 06:01:13.093
bar.  This fab has that teal 
color and that's because we 

06:01:13.558 --> 06:01:17.308
haven't set the default floating
action button style yet.  So, 

06:01:17.586 --> 06:01:21.145
once that's set, you'll see it's
using color seg

06:01:26.014 --> 06:01:28.318
secondary.  
Then we can do some text styling

06:01:28.579 --> 06:01:32.843
for the content of our cards.  
Say you want all of your text to

06:01:33.132 --> 06:01:38.183
be color on-surface, we're going
to be using a material theme 

06:01:38.580 --> 06:01:43.970
overlay, which I'll talk about 
in just a second.  It sets the 

06:01:45.070 --> 06:01:51.426
theme for all the contents of 
that components.  We're setting 

06:01:52.446 --> 06:01:57.999
it tertiary.  So material theme 
overlay, you might have heard of

06:01:58.689 --> 06:02:02.936
Android theme, you can style a 
subsection.  You can style a 

06:02:03.908 --> 06:02:08.814
dark-colored toolbar in your 
app.  The shortcoming is it 

06:02:10.378 --> 06:02:15.511
doesn't work in default style.  
You can't set Android theme.  

06:02:15.512 --> 06:02:18.076
Material Theming attribute is 
supported by our components and 

06:02:18.374 --> 06:02:22.703
it does work in default styles 
so you can set this for your 

06:02:22.975 --> 06:02:27.192
components and have it theme -- 
the subviews of your components.

06:02:27.193 --> 06:02:30.010
Lastly, we'll do some text 
appearance theming.  So, 

06:02:32.196 --> 06:02:39.221
previously, the title was 
hard-coded text appearance 

06:02:39.222 --> 06:02:44.266
style.  And similarly, for the 
text -- note body, as well.  

06:02:44.267 --> 06:02:49.433
And then we can apply some 
styling to this.  So, for 

06:02:50.845 --> 06:02:58.799
example, if you change headline 
six to be comic sans, it should 

06:02:59.182 --> 06:03:02.866
now look like this.  
So, why go through the trouble 

06:03:02.867 --> 06:03:07.475
of doing this?  Like, why go 
through the trouble of using 

06:03:07.868 --> 06:03:10.904
top-level attributes for your 
style?  Generally, we do this 

06:03:11.184 --> 06:03:15.033
because we want to be able to 
style your entire app using 

06:03:15.209 --> 06:03:21.415
these top-level attributes.  Say
your teammate said, hey, our 

06:03:21.696 --> 06:03:26.037
brand colors are changing and we
want this maroon color instead 

06:03:26.695 --> 06:03:32.349
of these blues we have.  You 
switch the top-color attributes 

06:03:32.350 --> 06:03:36.469
and your whole app is rethemed. 
If you want a dark theme or fake

06:03:36.761 --> 06:03:43.199
dark theme, you change the color
attributes and they should 

06:03:44.623 --> 06:03:49.763
respond appropriately to that.
  Now we're going to talk about 

06:03:49.764 --> 06:03:54.069
custom components and how you 
can use some of your styles.  

06:03:54.584 --> 06:03:57.321
There's really nothing magical 
about the way our components use

06:03:58.246 --> 06:04:01.719
theming.  It's all just basic 
Android theming, so you can use 

06:04:03.890 --> 06:04:07.572
it in your components, as well. 
You just have to create a 

06:04:07.844 --> 06:04:13.205
default style and pass it into 
your constructer.  So, let's go 

06:04:13.468 --> 06:04:19.553
through that.  Here we have a 
definition of a theme and some 

06:04:19.936 --> 06:04:22.445
attributes.  Here, we're 
creating a default style 

06:04:23.087 --> 06:04:25.752
attribute and setting it in our 
theme so we have my custom view 

06:04:27.229 --> 06:04:32.589
style and we're setting it to 
this widget.mycustomview style. 

06:04:33.025 --> 06:04:37.829
So, this will mean that any 
components that use this 

06:04:40.441 --> 06:04:43.284
mycustomview will use this style
by default.  

06:04:43.285 --> 06:04:49.502
You also can create a styleable,
which holds a few different 

06:04:50.221 --> 06:04:54.034
attributes.  And then you just 
need to use these in the 

06:04:54.035 --> 06:04:58.136
constructer.  Here's an example 
for a view.  Here, we pass in 

06:04:58.137 --> 06:05:02.850
the default style, which we 
created previously.  And, we 

06:05:02.851 --> 06:05:08.321
pass this in here so that it can
pick up that default style if 

06:05:08.587 --> 06:05:13.204
nothing else is set.  And then, 
raising attributes and pass in 

06:05:13.630 --> 06:05:20.031
the styleable that we just 
created, as well as the one 

06:05:20.032 --> 06:05:25.092
passed into the constructer and 
a fall-back style as a last 

06:05:25.360 --> 06:05:29.515
resort for finding attribute and
read those in.  That's basically

06:05:30.014 --> 06:05:33.557
how our components work.  So, 
you can definitely do it 

06:05:33.920 --> 06:05:36.758
yourself, as well.  
And also, extend the systems for

06:05:37.022 --> 06:05:40.876
your use cases.  Like, if you 
have the need for more 

06:05:41.775 --> 06:05:45.552
attributes in some case, you can
definitely add those in.  It 

06:05:45.908 --> 06:05:49.923
might be a little bit more work 
on your part because you'll have

06:05:50.190 --> 06:05:55.080
to update styles for all of the 
components you're using since 

06:05:55.888 --> 06:05:58.305
our components aren't going to 
be referencing them.  But if you

06:05:58.666 --> 06:06:03.156
need if, you can definitely do 
that.  

06:06:03.157 --> 06:06:08.608
Here's an example.  Just like an
attribute.  Create it and define

06:06:10.830 --> 06:06:15.089
it in your theme and reference 
it in styles or elsewhere.  

06:06:15.090 --> 06:06:20.777
Now, a little bit about our 
process.  We've had a few 

06:06:21.880 --> 06:06:27.567
releases.  The 1.0 went out -- 
was cut on July 20th and it's 

06:06:28.480 --> 06:06:32.036
been a little while.  But now 
with the Android Jetpack re

06:06:33.649 --> 06:06:39.456
refactor finish, we can release 
more frequently so we're trying 

06:06:39.725 --> 06:06:47.138
to ramp up our releases and we 
cut 1.1 alpha 1 October 

06:06:49.904 --> 06:06:55.666
31s t and we're trying to do 
this more frequently.  There was

06:06:55.667 --> 06:07:01.806
type theming, color theming and 
dark theming, plus lots of bug 

06:07:01.807 --> 06:07:04.864
fixes and performance 
improvements.  

06:07:04.865 --> 06:07:10.307
In the upcoming releases, there 
will be shape theming.  1.1 

06:07:10.684 --> 06:07:13.877
alpha, the shape theming 
subsystem exists, but none of 

06:07:14.551 --> 06:07:17.406
the components are actually 
responding to those themed 

06:07:17.687 --> 06:07:21.054
attributes yet.  But with the 
next release, it should.  

06:07:21.055 --> 06:07:29.115
We also updated some styling for
dialogues, bottom sheet, menus, 

06:07:29.116 --> 06:07:31.185
those sorts of things are all 
coming.  

06:07:31.186 --> 06:07:38.184
As far as contribuing and filing
issues, GitHub is where it is.  

06:07:38.536 --> 06:07:41.358
Go on GitHub and you can take a 
look at all our code.  It's open

06:07:42.222 --> 06:07:46.305
source.  And also check -- you 
can check GitHub for 

06:07:46.756 --> 06:07:52.360
instructions on how to submit 
bug reports.  We're taking bug 

06:07:53.349 --> 06:07:57.290
reportess at 
issuetracking.Google.  But, 

06:07:57.470 --> 06:08:00.777
we're looking at different ways 
to make it more obviiously what 

06:08:00.970 --> 06:08:05.009
we're working on and trying to 
integrate more with the 

06:08:05.010 --> 06:08:08.235
community.  
And here's a few more resources.

06:08:09.977 --> 06:08:13.020
Material.io site is great, 
especially the Android section. 

06:08:13.716 --> 06:08:18.691
Definitely check us out on 
Discord if you're interested in 

06:08:18.938 --> 06:08:23.035
chatting with us or are 
interested in helping us have an

06:08:23.642 --> 06:08:28.529
idea for anything.  Come and 
chat with us.  We have a tag on 

06:08:28.530 --> 06:08:31.594
Stack Overflow, so if you have 
questions about implementation, 

06:08:31.595 --> 06:08:34.770
you can ask something there, 
we're watching that and we'll 

06:08:35.498 --> 06:08:39.403
respond.  And then we have a few
codelabs, you can find the link 

06:08:39.858 --> 06:08:43.746
to those codelabs on this GitHub
page.  

06:08:43.747 --> 06:08:48.500
And, that's pretty much it.  
Thanks for coming.  We're going 

06:08:48.772 --> 06:08:54.969
to be available for questions 
and answers at the break that's 

06:08:58.231 --> 06:09:00.231
happening now.
  Thank you.

06:09:10.535 --> 06:09:12.535
[Applause]

06:50:04.004 --> 06:50:08.683
[Applause]
  Hi, everyone.  My name is Ian 

06:50:08.946 --> 06:50:13.276
Lake.  I'm a developer on the 
Android team.  And I work on 

06:50:13.277 --> 06:50:19.427
quite a few projects, but most 
notably the Navigation 

06:50:19.724 --> 06:50:24.440
Architecture Component, as well 
as fragments and the AndroidX 

06:50:25.505 --> 06:50:28.298
artifact and loaders.  And 
today, I want to talk to you 

06:50:29.162 --> 06:50:33.318
about single activity, why, when
and how.  And really try to 

06:50:33.319 --> 06:50:37.271
share the best practices from 
the Android treme and from the 

06:50:37.726 --> 06:50:40.003
Architecture Component team on 
what actually is going on in 

06:50:40.004 --> 06:50:45.015
this world.  There's been a lot 
of questions, way back, from 

06:50:45.888 --> 06:50:51.716
2014, 16 and even here in 2018, 
so we're here, today, to kind of

06:50:51.717 --> 06:50:58.692
talk over all of those wonderful
things that make up what are 

06:50:58.915 --> 06:51:01.246
activities. 
Activities are really a 

06:51:04.305 --> 06:51:09.888
component ant, at the same level
of content providers, broadcast 

06:51:11.034 --> 06:51:16.041
receives and they are the 
UI-facing pieces of your app.  

06:51:16.303 --> 06:51:19.635
So when the Android framework 
goes to start your application 

06:51:19.636 --> 06:51:24.188
from a launch icon or an app 
shortcut or what we see when 

06:51:24.463 --> 06:51:28.704
you're doing multi-window, those
are all activities, right?  So 

06:51:28.990 --> 06:51:33.071
they are the entry points into 
apps.  When the user goes to 

06:51:33.072 --> 06:51:37.428
launch your app, they're 
launching an activity.  

06:51:37.429 --> 06:51:42.822
And, we had a very interest 
quote from Diane Hackborn back 

06:51:42.823 --> 06:51:50.951
in 2016, once we've gotten into 
this entry point, we really 

06:51:50.952 --> 06:51:56.972
don't care how you organize the 
flow inside.  This was 2016 and 

06:51:56.973 --> 06:52:03.834
I think it was controversial, I 
guess, in 2016.  It had 77 

06:52:04.199 --> 06:52:09.509
comments on Google+, all right? 
[Laughter]

06:52:09.510 --> 06:52:15.749
A lot of people were very 
enthusiastic about this post.  

06:52:16.029 --> 06:52:19.295
Well, what does it mean?  Well, 
what I think it means is that 

06:52:20.225 --> 06:52:23.083
the framework shouldn't care.  
The framework shouldn't care 

06:52:23.607 --> 06:52:26.515
about your application's 
architecture.  It needs to 

06:52:26.800 --> 06:52:32.622
provide the hooks needed for the
Android framework to start your 

06:52:33.125 --> 06:52:37.784
application.  But, you should 
probably care about the 

06:52:37.785 --> 06:52:40.049
architecture of your app and 
that's why you're all here today

06:52:40.319 --> 06:52:45.018
and I love having you here.  
So, the biggest problem is that 

06:52:46.127 --> 06:52:50.059
you really don't know what 
activity's actually going to do.

06:52:50.468 --> 06:52:56.958
So, what's the default animation
for an activity?  It depends on 

06:52:57.419 --> 06:53:00.431
the version of Android, what 
manufacturer you're on and what 

06:53:00.432 --> 06:53:08.690
themes the user has selected.  
Right.  So, similarly, we had 

06:53:08.691 --> 06:53:15.579
property animations added in API
11 and they're much superior to 

06:53:15.809 --> 06:53:20.454
view animations.  And the thing 
is, is that while these new 

06:53:20.730 --> 06:53:24.061
things become possible on new 
versions of Android, they're not

06:53:24.062 --> 06:53:28.151
always applied to everything and
things like activities, they 

06:53:28.440 --> 06:53:32.942
don't support property 
animations, at all, even today. 

06:53:33.133 --> 06:53:40.527
And even if we were to add them,
in the next version of Android, 

06:53:40.904 --> 06:53:43.631
maybe the letter after P, we 
wouldn't be able to backport 

06:53:43.885 --> 06:53:46.661
them because they're part of the
framework. 

06:53:46.662 --> 06:53:50.192
Thinking about all these things 
it's like, well, okay, what 

06:53:50.470 --> 06:53:54.832
should an activity be used for? 
Why do we even have activities? 

06:53:55.830 --> 06:53:59.601
They're useful as this entry 
point and beyond that, you're in

06:53:59.861 --> 06:54:03.236
your realm of what your app 
needs to do and you don't 

06:54:03.920 --> 06:54:08.352
necessarily need to rely on 
activities being the thing that 

06:54:08.353 --> 06:54:15.527
you have to work with.  
So, let's take an example.  

06:54:15.528 --> 06:54:20.323
We're calling start activity and
we have to use activitycompat 

06:54:20.324 --> 06:54:25.254
because we want to do a shared 
element transition.  We say, oh,

06:54:25.517 --> 06:54:31.965
we want to have this one element
shared.  Well what do APIs work 

06:54:32.307 --> 06:54:37.049
on?  It depends on what you mean
by, work.  It launches an 

06:54:37.354 --> 06:54:42.285
activity, that's true.  It's 
only going to do a share 

06:54:42.661 --> 06:54:50.289
transition on newer editions, 
21+.  It technically works, 

06:54:50.715 --> 06:54:54.829
you're saving some API checks.  
But really, this isn't the 

06:54:55.309 --> 06:55:01.309
prettiest code to look at.  Are 
there any hidden gotchas?  If 

06:55:01.810 --> 06:55:04.822
you tested on an older version 
of Android, are you actually 

06:55:05.096 --> 06:55:08.876
going to get the same 
experience?  In this example, I 

06:55:09.165 --> 06:55:15.218
actually ran into this and I was
like, oh, things are fading in 

06:55:15.535 --> 06:55:18.628
and out.  You need to exclude 
things like the status bar and 

06:55:19.130 --> 06:55:23.508
navigation bar, otherwise 
they'll flicker and I was like, 

06:55:23.778 --> 06:55:28.247
well, okay, well that's fun.  I 
wouldn't have ever known that 

06:55:28.248 --> 06:55:31.985
unless I tried it once and I 
tried it on all a whole bunch of

06:55:32.174 --> 06:55:34.174
have

06:55:36.271 --> 06:55:44.205
of devices.  There are a lot of 
hiten gotchas you can't control.

06:55:45.654 --> 06:55:52.693
Another example where we have 
different activities and it's 

06:55:52.898 --> 06:55:59.036
its own component.  If you have 
two and you want to share data 

06:56:00.044 --> 06:56:08.481
between them, there isn't a 
scope for that.  It is served by

06:56:08.482 --> 06:56:11.896
services.  You want a shared 
scope within a couple of 

06:56:12.693 --> 06:56:14.693
components.  
So, this is the structure that 

06:56:15.013 --> 06:56:20.336
Android provides, but it's maybe
not the one you actually want to

06:56:20.337 --> 06:56:26.915
use.  What you actually want is 
you want to build the layering 

06:56:27.321 --> 06:56:31.672
you needs.  We can have multiple
destinations within an activity 

06:56:33.246 --> 06:56:37.201
and share information across 
each of these destinations by 

06:56:37.808 --> 06:56:41.875
using the activity scope as an 
actual useful element now.  So, 

06:56:41.876 --> 06:56:45.756
for example, you could have a 
shared view element, a ViewModel

06:56:46.148 --> 06:56:51.980
that both destinations talk to. 
One destination could put data 

06:56:51.981 --> 06:56:55.810
in and one could observe changes
to that data.  You don't need to

06:56:56.362 --> 06:57:00.783
work at the application scope 
level for this to work. 

06:57:00.784 --> 06:57:04.542
So, I mentioned this word, 
destination.  So, what is a 

06:57:04.543 --> 06:57:09.234
destination?  Well, really, it's
just a subsection of your UI.  

06:57:09.510 --> 06:57:12.110
So, for most destinations, 
they're going to take over

06:57:15.558 --> 06:57:16.107
the majority of your screen.  
Right.

06:57:16.108 --> 06:57:19.818
Like, when you move from screen 
to the next screen in your app, 

06:57:19.819 --> 06:57:24.718
it's going to change the vast 
majority of your screen.  Maybe 

06:57:24.719 --> 06:57:29.401
you have global navigation, like
a bottom nav.  The rest of this 

06:57:29.942 --> 06:57:34.223
is all in a destination.  So, 
the subsection of your UI, we 

06:57:34.558 --> 06:57:40.796
have a word for this called a 
fragment.  But a fragment's one 

06:57:41.083 --> 06:57:43.481
implementation of this idea of 
having separate destinations for

06:57:44.061 --> 06:57:49.008
each screen in your app.  
And really, this fragment is 

06:57:49.284 --> 06:57:52.821
serving as the view controller, 
right.  The thing that isn't a 

06:57:53.340 --> 06:57:57.084
view itself, but something that 
owns and changes those views, 

06:57:57.679 --> 06:57:59.833
which are really more about 
display.  

06:57:59.834 --> 06:58:04.198
All right.  So, really, the 
activity, instead of owning all 

06:58:04.543 --> 06:58:11.188
of this business logic and 
things like that, is really as 

06:58:11.189 --> 06:58:14.340
small as physically possible and
working on that shared UI that's

06:58:14.341 --> 06:58:20.275
shared across all destinations. 
So, when we're thinking about 

06:58:20.553 --> 06:58:26.076
this, like, if we're moving from
this activity world to a 

06:58:26.343 --> 06:58:30.253
destination world, we want to 
make that world as easy as 

06:58:30.716 --> 06:58:34.418
possible, otherwise, why would 
we move?  We focused on two 

06:58:35.176 --> 06:58:38.913
things.  One was the global UI 
kind of thing.  Like, how can we

06:58:39.079 --> 06:58:44.887
make that part easy?  It's 
something that every app has the

06:58:45.882 --> 06:58:48.885
same kind of patterns and we 
don't want that to be something 

06:58:49.178 --> 06:58:53.859
that takes a lot of effort to 
do.  Also, the navigating 

06:58:54.789 --> 06:58:59.793
between destinations, right.  
Activity, activitycompat thing, 

06:59:00.152 --> 06:59:04.001
can we make that even easier?  
We started the Navigation 

06:59:04.959 --> 06:59:08.754
Architecture Component and 
reintroduced it to you all at 

06:59:08.755 --> 06:59:11.794
I/O.  It is still in alpha right
now and we're looking to fill 

06:59:12.076 --> 06:59:18.112
out all the feature gaps before 
taking it to 1.0 here soon.  

06:59:18.571 --> 06:59:23.155
But really what this allows us 
to do is take a super simple 

06:59:24.121 --> 06:59:27.281
activity like this, set content 
view, we'll set an action bar 

06:59:27.557 --> 06:59:35.689
because that's a thing, right?  
And, we want to make this smart 

06:59:35.690 --> 06:59:40.784
but we still want it to fit on 
this one code slide.  So, some 

06:59:41.197 --> 06:59:43.197
of this is we need a nav

06:59:47.989 --> 06:59:52.968
controller.  It knows how your 
app works via a navigation 

06:59:53.263 --> 07:00:00.252
graph.  We can get one.  We're 
using Kotlin here and call 

07:00:00.253 --> 07:00:03.407
findnavcontroller.  We're giving
it the ID of a nav host 

07:00:03.408 --> 07:00:07.076
fragment.  It is that part of 
your UI that's going to change 

07:00:07.316 --> 07:00:12.158
when' ever you change 
destinations.  We'll add an app 

07:00:12.524 --> 07:00:15.142
bar configuration.  This 
controls the up action and what 

07:00:15.372 --> 07:00:19.690
needs to happen when you move up
from a destination.  And how do 

07:00:19.965 --> 07:00:24.132
we hook that up?  We have a nice
one-liner that says set up the 

07:00:24.428 --> 07:00:27.851
action bar, gives it a nav 
controller and an app bar 

07:00:28.292 --> 07:00:31.379
configuration.  
Now because we're using a drawer

07:00:31.752 --> 07:00:35.636
layout here in our app bar 
configuration, we also want to 

07:00:35.919 --> 07:00:40.976
open and shut the drawer when 
you hit the button.  We'll call 

07:00:41.605 --> 07:00:45.766
navigate up in our support 
navigate up.  We've set up our 

07:00:45.767 --> 07:00:50.723
whole action bar and now it 
changes titles as our 

07:00:51.033 --> 07:00:55.380
destination changes.  We're 
good.  If we want to add the 

07:00:55.897 --> 07:00:59.784
navigation view so we can click 
on the side nav, that's one 

07:01:00.131 --> 07:01:03.032
line.  We can do this all 
because the nav controller knows

07:01:03.033 --> 07:01:05.744
about our destinations in our 
app.  

07:01:05.745 --> 07:01:09.760
So, then how do we actually do 
navigate actions if we're not 

07:01:10.437 --> 07:01:17.290
doing fancy one-liner stuff?  We
can get a nav controller from 

07:01:18.401 --> 07:01:22.610
anywhere.  It's even easier from
a fragment, we can do 

07:01:24.543 --> 07:01:26.948
findnavcontroller and we've 
built a Kotlin extension for 

07:01:27.410 --> 07:01:33.678
this.  Any view that's created 
by any fragment in your 

07:01:33.997 --> 07:01:37.177
navigation graph can call find. 
So, you have this reference to 

07:01:37.178 --> 07:01:41.855
it from basically anywhere.  
And, we really tried to think, 

07:01:42.051 --> 07:01:46.201
like, all right, well, if you 
have arguments to something, how

07:01:46.202 --> 07:01:51.832
do we make this nice?  So, we 
built a Gradle plugin

07:01:55.861 --> 07:02:01.904
.  We generate a directions 
object, which has a nice, simple

07:02:02.194 --> 07:02:06.496
show profile method, which gives
you a directions object with 

07:02:06.497 --> 07:02:11.596
typesafe arguments you define in
your navigation graph and then 

07:02:13.671 --> 07:02:19.783
you just call to navigate.  
So, this makes it a lot easier 

07:02:20.717 --> 07:02:25.685
but we can go a lot farther with
navigation.  Has any one ever 

07:02:25.686 --> 07:02:31.049
built an intent filter before?  
Deep-linking in your app?  Has 

07:02:31.368 --> 07:02:34.478
anyone enjoyed that experience? 
[Laughter]

07:02:34.479 --> 07:02:38.232
Great!  One person enjoyed that 
experience.  This is what the 

07:02:38.520 --> 07:02:42.888
Android framework knows.  It 
knows, I can parse an intent 

07:02:43.145 --> 07:02:47.027
filter and start an activity.  
But in so often times, that's 

07:02:47.476 --> 07:02:51.301
not quite enough.  You need to 
go a little bit farther.  So 

07:02:52.038 --> 07:02:55.221
what we've done, in navigation, 
is for any one of your 

07:02:56.352 --> 07:02:59.712
fragments, any destination in 
your graph, you can add a deep 

07:02:59.713 --> 07:03:04.667
link.  It's a simple one-liner 
and you can add arguments right 

07:03:04.946 --> 07:03:09.932
here and we'll parse those out 
for query parameters and give 

07:03:10.179 --> 07:03:14.722
them to you as arguments to your
destination.  Because no one 

07:03:14.723 --> 07:03:20.043
likes writing intent filters, 
we'll generate the intent 

07:03:20.372 --> 07:03:24.830
filters for you.  We added this 
to manifest merger to generate 

07:03:24.831 --> 07:03:28.515
that for you.  
So, all this layering helps us 

07:03:29.764 --> 07:03:34.838
build nicer APIs.  But, it also 
makes it easier to test your 

07:03:34.839 --> 07:03:38.189
application.  Right.  If you're 
testing at the activity level, 

07:03:38.452 --> 07:03:43.712
all of a sudden, that means, 
okay, well, how do I test, start

07:03:43.713 --> 07:03:47.761
activity actually did the right 
intent and we have to build 

07:03:49.603 --> 07:03:54.564
extra testing frameworks on top 
of testing frameworks to mockup 

07:03:55.379 --> 07:04:00.862
these things.  If we're moving 
into a single activity model, we

07:04:01.153 --> 07:04:04.224
want to test all those things.  
We want that to be easy to test.

07:04:05.356 --> 07:04:08.740
So, rule number one for testing 
things at the destination level 

07:04:08.741 --> 07:04:14.424
is, don't test at the 
destination level.  It's really 

07:04:14.425 --> 07:04:17.226
the number one thing with 
testing, right, is making things

07:04:17.227 --> 07:04:20.838
nice and separate and extracting
some of that business logic out 

07:04:21.107 --> 07:04:24.138
of a destination and into 
something you can test in 

07:04:24.413 --> 07:04:31.075
isolation.  Right.  So example, 
a ViewModel is a great place 

07:04:31.599 --> 07:04:35.012
because you can test it in 
isolation.  We have a ViewModel 

07:04:37.163 --> 07:04:43.611
providerprovider factory where 
you can inject it and test it 

07:04:43.612 --> 07:04:46.732
separate from your UI.  But that
doesn't mean you don't want to 

07:04:46.733 --> 07:04:51.380
test any of your UI stuff at 
all.  Right.

07:04:51.381 --> 07:04:55.044
We have Espresso test for a 
reason.  We want to make sure 

07:04:55.391 --> 07:04:58.416
all parts of our app work well 
and are testable.  

07:04:58.417 --> 07:05:03.600
So, how can we do this?  So, 
last -- this Monday, we released

07:05:03.967 --> 07:05:09.597
fragment 1.1, the first alpha.  
And with this became a new 

07:05:09.794 --> 07:05:12.788
artifact called fragment 
testing, which is about six 

07:05:12.789 --> 07:05:14.019
years overdue.
[Laughter]

07:05:14.020 --> 07:05:19.328
And it's really around being 
able to test your AndroidX 

07:05:20.094 --> 07:05:24.571
fragments in isolation.  Right. 
Separate from an activity.  

07:05:24.572 --> 07:05:28.503
Separate frem everything else 
and being able to test and 

07:05:29.141 --> 07:05:33.068
verify that that fragment is 
doing the right thing.  Super 

07:05:33.359 --> 07:05:40.294
useful for Epress so test.  Your
business lodge, separate.  Your 

07:05:40.898 --> 07:05:44.920
UI is still something that we 
want to verify is correct.  

07:05:44.921 --> 07:05:49.768
Now, the nice part about this, 
it's called fragment scenario 

07:05:50.375 --> 07:05:54.669
because it's built on activity 
scenario, which is part of the 

07:05:54.973 --> 07:05:58.652
AndroidX testing team and the 
testing team was instrumental in

07:05:58.653 --> 07:06:01.714
getting fragments out there.  
But the best part about this 

07:06:01.715 --> 07:06:05.932
whole scenario is that it works 
both on instrumentation tests, 

07:06:06.318 --> 07:06:12.032
tests on your actual device and 
on robo electric.  You get one 

07:06:12.579 --> 07:06:15.330
test framework that works on 
both of these.  Really exciting 

07:06:16.141 --> 07:06:19.161
opportunity and something that 
now you can test with fragments.

07:06:20.101 --> 07:06:24.545
So, what does this look like?  
Let's say we want to test our 

07:06:25.124 --> 07:06:32.391
profile fragment.  We did a fake
user ID here and we call launch 

07:06:32.594 --> 07:06:39.016
fragment in container.  That's 
it.  This one line has both 

07:06:39.017 --> 07:06:44.016
created an empty activity, added
a fragment to it and waited for 

07:06:44.317 --> 07:06:48.238
it to be resumed and now it's 
ready.  You can now use this 

07:06:48.239 --> 07:06:53.932
fragment.  If you want to call 
onfragment and run some code and

07:06:54.551 --> 07:06:57.912
say is the fragment in the right
state, great, you can do that.  

07:06:58.635 --> 07:07:02.918
Here, we're going to see if it 
is what we think they are.  We 

07:07:03.293 --> 07:07:13.014
passed a user ID, we can use the
ARGs class and say, is the user 

07:07:14.097 --> 07:07:17.535
ID equal to the user ID we 
passed in?  You can see, you can

07:07:17.935 --> 07:07:25.573
run any logic, any method on 
your fragment right from here or

07:07:26.303 --> 07:07:32.651
we run Espresso  OE test.  When 
we click the subscribe button, 

07:07:32.652 --> 07:07:36.440
does it change the text to 
subscribed?  Does it do its 

07:07:36.918 --> 07:07:41.629
thing?  We can do this with that
one line of launch fragment in 

07:07:42.119 --> 07:07:46.316
container.  
For Java users, it'll be 

07:07:47.406 --> 07:07:51.348
fragment scenario.  They make it
nicer for you guys. 

07:07:51.349 --> 07:07:56.237
But, you don't test a fragment 
in isolation because, you know, 

07:07:57.032 --> 07:08:00.358
fragments do talk to other 
fragments, right.  I work on 

07:08:00.656 --> 07:08:04.537
navigation, so there's that 
other bit of testing how can we 

07:08:05.267 --> 07:08:10.821
test the links between different
destinations, between different 

07:08:11.914 --> 07:08:15.222
fragments?  The nice part, here,
that we have, because we're 

07:08:15.588 --> 07:08:19.160
using these higher-level 
components, and not something 

07:08:19.161 --> 07:08:22.847
like activity, is we have a 
mockable layer.  Right.  One of 

07:08:24.901 --> 07:08:28.406
the things that we found, which 
building navigation is most 

07:08:29.549 --> 07:08:34.765
companies, once they got to a 
certain point and they're like, 

07:08:35.124 --> 07:08:39.748
well, we should add testing.  
They added navigator to mock out

07:08:40.024 --> 07:08:47.153
the start activity calls.  That 
layer is handled for you.  What 

07:08:47.400 --> 07:08:52.737
we can do, in our activities, is
just mock out that nav 

07:08:53.100 --> 07:08:57.304
controller and confirm that, 
yes, you're calling the right 

07:08:58.594 --> 07:09:00.831
navigate calls. 
Here, we have our profile 

07:09:01.272 --> 07:09:05.875
fragment again and it's getting 
our user ID and what we want to 

07:09:05.876 --> 07:09:10.821
test is this on view subscribers
button.  We click this and it's 

07:09:11.613 --> 07:09:15.463
doing something complicated in 
the fragment.  How are we going 

07:09:15.464 --> 07:09:20.094
to test this?  It's calling 
navigate.  How can we make sure 

07:09:20.589 --> 07:09:23.198
this is actually doing what we 
want it to do?  Well, it's 

07:09:23.564 --> 07:09:28.171
pretty easy.  We can do our 
scenario thing just the same, 

07:09:28.172 --> 07:09:32.330
launch fragment.  And now we can
mock out our nav controller and 

07:09:32.639 --> 07:09:36.817
now you call onfragment and what
we're doing here is actually 

07:09:36.818 --> 07:09:41.037
just creating our own nav 
controller.  Like, there's no 

07:09:41.038 --> 07:09:47.260
nav host here.  But we can just 
inject one.  This is what nav 

07:09:47.261 --> 07:09:53.408
host fragment is doing under the
covers.  It's calling set nav 

07:09:54.763 --> 07:09:57.671
controller on a view.  Now what 
we've done is from this 

07:09:58.015 --> 07:10:02.741
fragments point of view, it has 
a navigation controller.  All 

07:10:02.742 --> 07:10:07.748
those nav controller calls that 
normally you'd have to inject 

07:10:09.677 --> 07:10:12.938
something, now it just works.  
They're in there.  And now we 

07:10:13.533 --> 07:10:20.782
can just run Espresso tests and 
click on the subscribers view 

07:10:20.952 --> 07:10:24.810
button.  We can use them also in
our tests.  And because they 

07:10:25.264 --> 07:10:29.679
implement equals, we can just do
a simple verify and say, verify.

07:10:30.087 --> 07:10:34.043
Did you actually navigate to 
where we think you're 

07:10:34.514 --> 07:10:40.740
navigating?  Even if there's a 
lot of parameters in there, we 

07:10:40.741 --> 07:10:44.617
can now just verify and this 
makes it so much easier to test 

07:10:44.618 --> 07:10:50.848
those interconnections between 
each destination.  

07:10:50.849 --> 07:10:52.849
So, nav 

07:10:55.287 --> 07:10:58.873
controller's kind of a special 
thing.  So many other things 

07:10:58.874 --> 07:11:02.968
aren't a service locator kind of
pattern.  We need to inject in 

07:11:02.969 --> 07:11:06.713
those dependancies and this is 
another one of those, like, six 

07:11:06.714 --> 07:11:10.527
years too late kind of a thing. 
But, we're finally working on 

07:11:10.952 --> 07:11:16.489
it.  
So, there's a class in Android P

07:11:16.965 --> 07:11:23.031
called app component factors 
that allows you to construct 

07:11:24.511 --> 07:11:28.025
activity all via dependency 
injection.  You get a chance of 

07:11:28.741 --> 07:11:33.401
caller the constructer instead 
of the system calling it.  Same 

07:11:33.402 --> 07:11:39.113
thing here with fragments.  Now 
you can do conSTRUTH

07:11:43.459 --> 07:11:48.581
structer into fragments.  You 
can use a fragment factory.  

07:11:48.582 --> 07:11:53.423
So, this is really useful, also,
for cases where your fragment 

07:11:53.424 --> 07:11:57.576
was, like, casting your activity
to something.  I know we 

07:11:57.848 --> 07:12:01.621
probably still have a template 
that does this.  We'll fix that.

07:12:01.939 --> 07:12:07.789
And, there's a lot of ways where
really want to inject in all of 

07:12:08.599 --> 07:12:13.986
those external dependancies so 
we can test in isolation and 

07:12:14.725 --> 07:12:17.412
fragment works great with our 
fragment scenario.  

07:12:17.413 --> 07:12:24.057
We know how to test a ViewModel,
right.  It's just an object, it 

07:12:24.518 --> 07:12:28.883
has a real method called 
subscribe.  Really, we want to 

07:12:29.095 --> 07:12:33.629
test our fragment.  And our 
fragment has an onsubscribe 

07:12:34.071 --> 07:12:37.208
fragment and it does its thing. 
How do we get this ViewModel?  

07:12:37.612 --> 07:12:46.975
Well, we can inject the factory 
itself, inject the ViewModel 

07:12:47.263 --> 07:12:53.260
factory.  Here we're using the 
by ViewModels, a property that 

07:12:53.261 --> 07:12:56.904
does all that ViewModel 
providers of kind of stuff for 

07:12:56.905 --> 07:12:59.771
you.  
But, we now have a fragment that

07:13:00.101 --> 07:13:03.944
we've injected something, but 
then we still need to test, 

07:13:04.480 --> 07:13:07.728
like, okay, did it actually call

07:13:10.985 --> 07:13:14.233
subscribe?  
So, we can build a navigation 

07:13:14.436 --> 07:13:17.173
activity.  This is what it's 
going to look like in real life.

07:13:17.564 --> 07:13:21.940
Right.  We're going to inject 
our ViewModel factory and then 

07:13:22.500 --> 07:13:26.314
because code is hard and I 
wanted to write things on 

07:13:26.315 --> 07:13:32.152
slides, I built a helper class 
call initializer and you call 

07:13:33.202 --> 07:13:38.250
add initializer for each 
fragment and we call that method

07:13:38.725 --> 07:13:43.724
to construct.  So, a little bit 
of magic.  There's a link here 

07:13:43.725 --> 07:13:48.644
if you want to check it out.  
We're looking at trying to 

07:13:48.945 --> 07:13:52.260
integrate this more deeply into 
the library.  

07:13:52.261 --> 07:13:59.058
Once you've called this fragment
factory, it creates a profile 

07:13:59.059 --> 07:14:03.402
fragment.  It's going to use 
this constructer and pass in our

07:14:03.403 --> 07:14:09.415
ViewModel factory.  Great.  So, 
our activity looks fine.  But, 

07:14:10.104 --> 07:14:14.406
our tests, how does that look?  
We create a mock of our profile 

07:14:14.755 --> 07:14:18.860
ViewModel and then we can set up
a factory for it and then again,

07:14:19.434 --> 07:14:24.680
kind of use a fragment factory 
here that, again, does the same 

07:14:24.681 --> 07:14:29.825
type of thing where we're 
passing in our mock ViewModel 

07:14:30.118 --> 07:14:34.063
factry and our scenario looks 
the same.  We add it in and 

07:14:34.327 --> 07:14:38.716
instead of just the argurements,
also the fragment factory.  

07:14:38.717 --> 07:14:42.833
Now we can do our same thing on 
view, perform the click and then

07:14:42.834 --> 07:14:49.600
verify that, yes, our mocked 
ViewModel did the subscribe 

07:14:50.141 --> 07:14:55.858
call.  We have a testable 
fragment, a testable ViewModel. 

07:14:55.859 --> 07:14:59.251
We have a testable thing.  
Now, we are looking at some 

07:14:59.792 --> 07:15:02.768
improvements to this API 
because, you know, we want to 

07:15:02.769 --> 07:15:07.389
make this even easier.  So, in 
this case, because we know your 

07:15:07.390 --> 07:15:12.005
constructing a profile fragment,
we want to change this into 

07:15:12.006 --> 07:15:16.626
something that looks like this. 
Where you can say launch and 

07:15:16.816 --> 07:15:21.527
then give it a method saying, 
oh, like, you launched this 

07:15:21.923 --> 07:15:26.580
fragment and specifically give 
it the constructed-out instance 

07:15:27.090 --> 07:15:30.707
of your fragment so you don't 
have to actually know that it's 

07:15:31.073 --> 07:15:33.073
using a fragment factory on

07:15:36.417 --> 07:15:39.009
under the hood.  
There are a few cases where you 

07:15:39.275 --> 07:15:45.849
might think, oh, man, maybe I do
need multiple activities.  And, 

07:15:45.850 --> 07:15:50.637
there's got to be reasons to use
multiple activities besides just

07:15:50.638 --> 07:15:53.883
momentum.  Right.  I understand 
that a lot of apps, if you have 

07:15:54.692 --> 07:15:57.561
multiple activities right now, 
this isn't actually an easy 

07:15:57.835 --> 07:16:02.247
sell.  Right.  So, there are a 
few cases where even, today, we 

07:16:02.468 --> 07:16:08.235
do recommend using multiple 
activities.  Not a lot though.  

07:16:08.236 --> 07:16:13.138
So, what I'd like to say is, you
don't actually need multiple 

07:16:13.436 --> 07:16:20.056
activities.  What you need are 
multiple tasks.  So, what are 

07:16:20.515 --> 07:16:23.833
tasks?  Tasks are actually the 
thing that users are actually 

07:16:24.298 --> 07:16:29.571
interacting with.  So, a task is
a stack of activities and each 

07:16:29.750 --> 07:16:34.154
task has a backstack.  So, in 
your overview menu here, each 

07:16:34.557 --> 07:16:40.819
one of these entries isn't just 
an activity.  It's actually a 

07:16:40.820 --> 07:16:44.253
whole task stack, right.  So 
you're only just seeing the top 

07:16:45.342 --> 07:16:50.399
most activity of that stack.  So
each element here is a stack.  

07:16:50.692 --> 07:16:54.847
Right.  When you're doing 
split-screen multi-window, 

07:16:54.848 --> 07:16:59.869
that's two tasks side-by-side.  
Right.  On Chrome OS devices, 

07:17:00.605 --> 07:17:04.705
things that support floating 
multi-window, each one of these 

07:17:04.706 --> 07:17:13.863
tasks is a window.  One to one 
between windows and tasks.  Not 

07:17:13.864 --> 07:17:17.420
activities ties and windows, 
tasks and windows.  

07:17:17.421 --> 07:17:22.924
So, launching a new task on one 
of these Chrome OS devices gives

07:17:23.771 --> 07:17:30.250
you a new window.  Right.  So, 
your app, maybe it doesn't need 

07:17:30.985 --> 07:17:35.585
multiple activities, but maybe 
it wants multiple windows.  

07:17:35.586 --> 07:17:39.761
Right.  So, this is the case 
where, yes, you need to use 

07:17:39.974 --> 07:17:42.852
activities under the hood, each 
one of these tasks is going to 

07:17:44.145 --> 07:17:48.290
be a separate activity.  But, 
you may not use some of the 

07:17:48.709 --> 07:17:55.169
other things, such as a stack of
activities in one task.  So, 

07:17:55.381 --> 07:17:58.204
what does this actually look 
like?  A lot of this is that 

07:17:58.642 --> 07:18:01.533
there are a lot of different 
ways of saying new task.  Right.

07:18:01.534 --> 07:18:06.509
Has anyone looked at all those 
wonderful launch mode flags and 

07:18:07.102 --> 07:18:12.779
all that fun?  Yeah.  How many 
people of you are still sane?  

07:18:13.296 --> 07:18:17.601
Okay.  Well, I'll say that there
were a lot of good flags out 

07:18:18.029 --> 07:18:21.607
there, in Android 1.
[Laughter]

07:18:21.608 --> 07:18:27.889
They were great back in Android 
1.  In today, in 2018, they're 

07:18:28.243 --> 07:18:31.595
maybe not the best thing to use.
What you actually want to use is

07:18:32.071 --> 07:18:38.304
document launch mode.  Document 
launch mode was added, actually,

07:18:38.638 --> 07:18:42.907
in API 21.  If you're thinking 
about pre-API 21 first, what are

07:18:43.226 --> 07:18:47.237
you doing?  And, second, 
probably try and steer aware 

07:18:47.831 --> 07:18:50.982
from hackie solutions.  Maybe 
it's just not worth it for those

07:18:52.515 --> 07:18:57.828
users.  But try and avoid things
like launch mode flags and task 

07:18:58.019 --> 07:19:01.027
affinity and those types of 
things because while the 

07:19:01.773 --> 07:19:04.624
framework does honor those, it 
maybe doesn't honor them in the 

07:19:04.625 --> 07:19:11.970
way you want them to honor it.  
There's certainly very different

07:19:12.640 --> 07:19:19.019
types of thing.  With document 
launch mode, there's 

07:19:19.411 --> 07:19:22.413
multi-tasking, if you can have 
multiple tasks, you can multiple

07:19:23.522 --> 07:19:26.223
windows.  You have multiple 
entries in your overview screen.

07:19:26.610 --> 07:19:31.391
So the first way of doing 
multi-tasking is into existing. 

07:19:32.244 --> 07:19:36.675
Into existing means whenever I 
launch this activity, that 

07:19:38.064 --> 07:19:41.676
activity has its own task.  
Every time you launch this 

07:19:41.964 --> 07:19:47.927
activity, it has its own task.  
But if we have already launched 

07:19:48.223 --> 07:19:54.130
that task, don't create a second
and a third copy.  This is good 

07:19:54.561 --> 07:20:00.028
for documents, conversations and
things someone might want to 

07:20:00.441 --> 07:20:06.890
side-by-side compare.  They're 
not going to exit out of one 

07:20:06.891 --> 07:20:11.277
doc, open another one and copy 
it there.  It's taking the 

07:20:13.425 --> 07:20:16.215
multi-tasking model that is 
Android and making it so your 

07:20:16.216 --> 07:20:22.320
app actually gets to use this.  
Now of course, the into existing

07:20:22.321 --> 07:20:27.039
assumes you have some notion of 
uniqueness.  It does assume from

07:20:27.040 --> 07:20:31.375
an intent fitter equals point of
view, if you're using the data 

07:20:31.664 --> 07:20:36.543
UI on your activity, that there 
is some sort of unique ID, a 

07:20:36.544 --> 07:20:39.947
conversation ID, a document ID, 

07:20:44.112 --> 07:20:45.692
something to uniquely-define 
that task.  

07:20:45.693 --> 07:20:49.847
One great example is Google

07:20:54.324 --> 07:20:59.130
Docs.  It launches it in another
task.  You can load them up, 

07:20:59.406 --> 07:21:01.961
side-by-side on a phone.  Two 
different windows on a Chrome OS

07:21:02.576 --> 07:21:07.609
device.  And it just works.  
Even though it's one app, it can

07:21:08.003 --> 07:21:13.409
have multiple windows and really
allow a different level of 

07:21:13.721 --> 07:21:15.517
multi-tasking between different 
things.  

07:21:15.518 --> 07:21:19.709
So another big one is creating 
new content.  So new content's a

07:21:19.710 --> 07:21:26.511
little different because there's
not really any unique ID but you

07:21:26.813 --> 07:21:32.079
want that multi-tasking behavior
are you can reference existing 

07:21:32.545 --> 07:21:35.693
material while you're creating 
something new.  The always flag 

07:21:35.952 --> 07:21:39.953
is similar to into existing, but
it always creates something new.

07:21:40.728 --> 07:21:45.352
It's like self-descriptive 
names.  We can do this, guys.  

07:21:46.346 --> 07:21:52.426
It allows you to do multiple 
things at one.  One example is 

07:21:53.143 --> 07:21:56.517
Gmail, it uses this kind of mode
when you create a new email.  

07:21:56.518 --> 07:21:59.694
This allows you to create a new 
email and reference your 

07:21:59.989 --> 07:22:06.845
existing email at the same time.
It's magic, right?  This is the 

07:22:07.645 --> 07:22:11.304
equivalents, on mobile, of when 
you do it on a web and it pops 

07:22:11.874 --> 07:22:15.515
up a little mole that's separate
from the other one.  You still 

07:22:15.819 --> 07:22:18.124
need that other material as 
reference.  

07:22:18.125 --> 07:22:23.300
On a phone or an a tablet, it 
looks slightly different.  The 

07:22:23.768 --> 07:22:30.482
other case is 
picture-in-picture, it has two 

07:22:31.378 --> 07:22:34.888
entirely separate modes.  One is
using a separate task.  Right.  

07:22:35.207 --> 07:22:38.154
So, this would be a separate 
activity, just for your 

07:22:38.155 --> 07:22:40.155
playback.  So, this is really 

07:22:43.654 --> 07:22:46.575
common on Android TV.  TV uses 
this approach so you can 

07:22:46.834 --> 07:22:50.803
actually put things into 
picture-in-picture mode and 

07:22:51.207 --> 07:22:56.023
browse through other movies.  
So, in this mode, it's very much

07:22:56.890 --> 07:23:01.294
that you have a specific 
picture-in picture button in 

07:23:01.596 --> 07:23:06.656
your UI.  The other mode is 
using just a single task, one 

07:23:06.954 --> 07:23:12.598
activity.  You don't need 
anything at all.  This is Duo 

07:23:12.941 --> 07:23:16.431
and Google Maps where your whole
task is becoming the 

07:23:18.186 --> 07:23:20.677
picture-in-picture activity.  
Right.  So, when would you want 

07:23:20.678 --> 07:23:24.338
to choose one or the other?  
It's really this case where once

07:23:24.870 --> 07:23:29.275
I'm in picture-in-picture mode, 
if they were to click my 

07:23:29.575 --> 07:23:33.046
launcher icon, what would 
happen?  Because the launcher 

07:23:33.612 --> 07:23:38.027
icon always launches the default
task of your app.  So, in Duo's 

07:23:38.286 --> 07:23:43.404
case, where they only have one 
task, when you launch that Duo 

07:23:43.795 --> 07:23:47.194
from your launcher icon, it's 
just going to pop open the 

07:23:50.614 --> 07:23:54.316
picture-in-picture.  Because it 
doesn't make sense to have 

07:23:54.560 --> 07:23:57.135
multiple conversations going at 
the same time.  You're never 

07:23:57.136 --> 07:24:00.503
going to replace one with the 
other.  You're never going to 

07:24:01.207 --> 07:24:05.199
continue to reference something 
even though something is already

07:24:05.200 --> 07:24:13.824
going.  That's kind of the 
differentiator here.  Do you 

07:24:13.825 --> 07:24:14.820
want to browse 
picture-in-picture that the same

07:24:14.821 --> 07:24:18.032
time.  If you do want to, yes, 
you're using the Android 

07:24:18.372 --> 07:24:22.767
framework and they need to 
position those separately.  

07:24:22.768 --> 07:24:26.495
Separate tasks.  Separate 
activitiesactivities. 

07:24:26.496 --> 07:24:29.959
But, that's kind of it.  The one
thing I didn't mention are 

07:24:30.381 --> 07:24:34.781
things like instant apps.  
Instant apps kind of works at 

07:24:34.782 --> 07:24:39.336
the activity level.  Right.  You
call start-activity.  But 

07:24:39.337 --> 07:24:42.057
there's actually some really 
exciting things that are being 

07:24:42.058 --> 07:24:46.350
worked on by the Play team.  I 
think there was a talk here at 

07:24:46.717 --> 07:24:50.154
Android Dev Summit.  A lot of it
is around the instance 

07:24:50.489 --> 07:24:54.620
experience for your App Bundle, 
making your whole app instant 

07:24:54.621 --> 07:24:58.662
and also dynamic feature 
modules.  These are really 

07:24:59.094 --> 07:25:02.977
interesting ways of adding 
things on to the thing, that 

07:25:04.204 --> 07:25:08.228
don't require a specific app 
architecture to implement.  We 

07:25:08.580 --> 07:25:11.660
can actually do more things with
this.  

07:25:11.661 --> 07:25:15.084
For the instant experience, it's
added

07:25:18.400 --> 07:25:22.784
equals means true.  They can try
your entire app, your entire 

07:25:22.785 --> 07:25:28.077
base module totally instant and 
this works really well with 

07:25:28.397 --> 07:25:32.250
things like app links.
So those deep links that I said 

07:25:32.973 --> 07:25:35.395
you could add to any 
destination, you can also make 

07:25:35.707 --> 07:25:41.111
them into app links by adding 
the auto verify equals true.  

07:25:41.899 --> 07:25:45.795
When someone launches your deep 
link on the web, they're going 

07:25:46.464 --> 07:25:50.058
to open up your instant app 
experience and download that 

07:25:50.059 --> 07:25:53.289
whole base module for you and 
your whole navigation graph is 

07:25:53.495 --> 07:25:59.127
already there, ready to go.  
But, this doesants work if your 

07:25:59.395 --> 07:26:04.137
app is too large so you want to 
dynamically deliver things that 

07:26:04.410 --> 07:26:08.297
are not used very often or 
rather big things.  That's what 

07:26:08.643 --> 07:26:13.087
dynamic feature modules are all 
about.  

07:26:13.088 --> 07:26:17.959
About being able to download 
them on-demand.  The interesting

07:26:17.960 --> 07:26:21.708
thing about dynamic feature 
modules is you're adding 

07:26:22.086 --> 07:26:27.050
classes.  You don't need to add 
activities. You can add just 

07:26:27.051 --> 07:26:30.727
destinations, just the number of
fragments.  In this case, you 

07:26:31.134 --> 07:26:37.975
can add new destinations, 
on-demand.  Just because you've 

07:26:38.467 --> 07:26:42.806
built out an XML file, each one 
of these dynamic feature modules

07:26:42.807 --> 07:26:46.443
can add their own navigation 
graph.  So, this means that 

07:26:46.724 --> 07:26:50.321
we're not tied to separate 
activities.  We can now actually

07:26:50.811 --> 07:26:55.603
still use one activity.  
Now, there's still more to be 

07:26:56.356 --> 07:27:00.048
done here, both on the Play side
and on the navigation side.  But

07:27:00.270 --> 07:27:04.609
we want to make this really easy
for developers to use.  So, what

07:27:04.610 --> 07:27:10.037
we want to get to is where you 
can add something to your 

07:27:10.312 --> 07:27:13.593
navigation graph with a feature 
tag, just like you'd add a 

07:27:13.953 --> 07:27:16.949
fragment tag and when you 
navigate to this destination, 

07:27:17.792 --> 07:27:22.907
that's actually going to do all 
of the downloading and making 

07:27:23.382 --> 07:27:26.126
your feature module available 
from whatever your split name 

07:27:26.127 --> 07:27:29.052
is.  So, that's the world we 
want to get into where you can 

07:27:31.056 --> 07:27:37.198
use a single activity.  Where 
you can use a lot of the useful 

07:27:37.721 --> 07:27:43.327
things, like deep-linking in 
navigation, without contorting 

07:27:43.328 --> 07:27:46.679
your app architecture.  
So, I'd really like to end this 

07:27:46.932 --> 07:27:50.373
with one note.  A lot of you 
have existing apps that have 

07:27:50.374 --> 07:27:54.029
very different kind of 
experiences and I'd like to say,

07:27:54.438 --> 07:27:59.628
do what's right for your app.  I
think single activity's great.  

07:27:59.859 --> 07:28:05.584
I was writing a new activity, it
would also be single activity 

07:28:05.872 --> 07:28:07.872
but I

07:28:08.872 --> 07:28:13.061
realize that doing and saying, 
hey, let's rip the whole app 

07:28:13.381 --> 07:28:17.676
apart, is sometimes a hard sell.
Some of them don't like your 

07:28:17.677 --> 07:28:21.713
current app.  So maybe you'll 
actually get some, yeah, okay, 

07:28:21.714 --> 07:28:26.805
good for it.  Really depends on 
your own experiencement if you 

07:28:26.806 --> 07:28:30.004
find yourself contorting your 
own experience and it's not 

07:28:30.005 --> 07:28:32.371
making sense to you, don't do 
it.  

07:28:32.372 --> 07:28:36.735
Right.  If something is working,
that's good.  Keep it working.  

07:28:36.736 --> 07:28:40.971
Right.  But if you're finding 
you're running into issues, 

07:28:42.544 --> 07:28:47.710
you're having inconsistent 
behavior or you want to do share

07:28:48.111 --> 07:28:54.497
ViewModel, maybe that's the time
to think about moving toward a 

07:28:55.174 --> 07:28:59.898
single activity. 
Thank you.  Q&amp;A outside.  Really

07:29:00.971 --> 07:29:05.084
appreciate you all coming.
[Applause]

07:29:05.904 --> 07:29:10.915
Everyone, the next session, in 
this room, will begin in 10 

07:29:13.246 --> 07:29:15.246
minutes.  Thank you. 

07:40:14.219 --> 07:40:16.219
[Applause]

07:40:21.138 --> 07:40:25.472
  Hello.  And, welcome to the 
last session of Android Dev 

07:40:26.240 --> 07:40:32.335
Summit, over the ultimate, I 
think.  The is called Get 

07:40:33.377 --> 07:40:40.067
Animated.  I'm Nick Butcher. 
  I'm Doris Liu.  I'm 

07:40:40.326 --> 07:40:42.326
responsible for Android API. 
  I'm

07:40:44.453 --> 07:40:50.219
Nicolas Roard.
  John Hoford, working on 

07:40:50.220 --> 07:40:55.223
MotionLayout, and design tools.
  Great.  So, let's get started.

07:40:55.571 --> 07:41:01.459
So, Android has always had 
animation APIs.  The number of 

07:41:01.759 --> 07:41:07.403
APIs has grown as the system has
grown and become kind of more 

07:41:07.404 --> 07:41:09.765
fully-featured.  There are a 
variety of different APIs for 

07:41:10.561 --> 07:41:12.984
different situations that have 
been added over the different 

07:41:13.566 --> 07:41:17.988
API releases, as well as to the 
new support libraries, like 

07:41:18.156 --> 07:41:21.347
AndroidX.  
But, sometimes, we hear that the

07:41:21.861 --> 07:41:25.326
variety, the range of animation 
systems can be overwhelming.  

07:41:25.633 --> 07:41:28.423
That you don't know which one to
reach for or which is the best 

07:41:28.704 --> 07:41:31.556
for a certain use case.  So

07:41:34.574 --> 07:41:37.885
our goal is to give you an 
overview, tell you what they're 

07:41:37.886 --> 07:41:41.454
good for, what they might not be
good for and give you there 

07:41:41.455 --> 07:41:47.389
confidence for what to reach 
for.  We're going to spend more 

07:41:47.390 --> 07:41:52.093
time on MotionLayout, as well.  
First up is Android's oldest and

07:41:52.094 --> 07:41:57.919
original animation API, which is
Android view animation.  I would

07:41:58.214 --> 07:42:03.319
urge you to consider it 
deprecated.  It's not actually 

07:42:05.006 --> 07:42:07.096
deprecatedeprecated.  But maybe 
just think of it in that way.  

07:42:07.097 --> 07:42:13.823
So, this, like, I say, an older 
animation API, was kind of -- 

07:42:14.156 --> 07:42:19.427
runs in a certain phase of the 
system.  Most views have a 

07:42:19.619 --> 07:42:23.685
measure layout and a draw.  
Because the animations only run 

07:42:23.902 --> 07:42:27.690
in the draw pass, it means that 
we can't do certain things like 

07:42:28.282 --> 07:42:31.005
deferring a rendering when we 
don't need it.  It also leads to

07:42:31.492 --> 07:42:35.961
certain things to where because 
only the animation is only 

07:42:37.015 --> 07:42:41.527
applied the draw pass, maybe 
you've animated a button, the 

07:42:41.804 --> 07:42:47.527
views haven't challenge.  They 
only exist with the viewing draw

07:42:49.460 --> 07:42:55.838
system basically, consider it 
deprecateddeprecated.  It 

07:42:56.836 --> 07:43:01.487
belongs in a MUSEUM.
[Laughter]

07:43:01.488 --> 07:43:09.254
I'd say deprecated except there 
is one single use case and that 

07:43:09.511 --> 07:43:13.894
is when you're doing window 
animations. When a new activity 

07:43:14.588 --> 07:43:19.186
launches, this API only accepts 
this type of window animation 

07:43:19.475 --> 07:43:23.999
because it existed from API 1.  
But also because these window 

07:43:24.276 --> 07:43:28.339
animations have to state all the
information to perform the 

07:43:28.742 --> 07:43:32.740
animation.  The fact that runs 
in the draw pass is useful.  

07:43:33.028 --> 07:43:38.827
That allows it to define certain
things like, here, we're seeing 

07:43:38.828 --> 07:43:44.982
a wide animation, 10% of the y 
position.  Because it's 

07:43:45.260 --> 07:43:48.773
guaranteed to be measured, this 
can be useful.  

07:43:48.774 --> 07:43:52.596
The only other place is when 
you're doing fragment 

07:43:53.282 --> 07:44:00.004
transactions.  You can supply 
this Android view animation.  

07:44:00.276 --> 07:44:03.570
But the app accepts the newer 
Android animator so I urge you 

07:44:03.571 --> 07:44:08.980
to use the newer one if you can.
So, that was view animations, 

07:44:09.392 --> 07:44:14.473
basically only really use it for
wind oanimations or if you need 

07:44:14.474 --> 07:44:18.995
to rely on that part.  
Otherwise, think it's 

07:44:19.268 --> 07:44:26.103
deprecated.  
Next up.  Animator.

07:44:26.104 --> 07:44:34.045
All right.  Didn't change.  
Oops. All right.  So, Nick has 

07:44:34.534 --> 07:44:38.537
talked about view animation, now
let's take a look at the new 

07:44:38.754 --> 07:44:44.718
animator that was introduced in 
API 11.  So, the new animator 

07:44:44.719 --> 07:44:48.797
API's is much more versatile 
because it allows you to animate

07:44:49.675 --> 07:44:56.591
more than view property.  You 
can even animate any value, not 

07:44:57.234 --> 07:45:01.130
necessarily associated with any 
property at all, using the value

07:45:01.538 --> 07:45:04.760
animator API.  
And since the introduction of 

07:45:05.179 --> 07:45:10.380
animator, we've built a bunch of
higher-level animator 

07:45:13.005 --> 07:45:18.078
constructs, such as animator 
drawable, transition and the 

07:45:20.241 --> 07:45:22.153
default item animator in 
RecyclerView.  

07:45:22.154 --> 07:45:26.456
People always ask me, between 
animation and animator, which 

07:45:26.917 --> 07:45:30.556
animation API should I use?  And
the answer is, definitely the 

07:45:30.846 --> 07:45:35.298
animator API.  Because it's just
much more capable.  And in this 

07:45:35.299 --> 07:45:42.670
section, we're going to look at 
a few animators.  We're going to

07:45:42.946 --> 07:45:47.864
look at value animators and 
object animator, which not only 

07:45:48.276 --> 07:45:52.808
animates the value, but can 
assess that value.  We're going 

07:45:53.091 --> 07:45:56.372
to look at animator set.  And 
then, we're also going to take a

07:45:56.653 --> 07:45:59.607
look at the view property 
animator.  It is not an 

07:45:59.928 --> 07:46:03.539
animator, but backed by a value 
animator.  We'll talk a little 

07:46:03.943 --> 07:46:08.366
bit more about that in a minute.
And then, also, we're going to 

07:46:08.367 --> 07:46:14.560
look at property values holder, 
which you can use in conjunction

07:46:15.000 --> 07:46:19.251
with value animator.  Here's an 
interesting animation with a 

07:46:19.581 --> 07:46:23.640
juggling man.  That can be 
achieved with the animator 

07:46:23.641 --> 07:46:29.890
drawable, which Nick will talk 
about in the next section.  But 

07:46:30.316 --> 07:46:34.188
now let's look past that and on 
top of this little man, there 

07:46:34.377 --> 07:46:39.262
are texts being animated in and 
out.  So, in order to achieve 

07:46:39.263 --> 07:46:43.876
that, we can simply create an 
object animator to animator.  

07:46:44.895 --> 07:46:49.758
The alpha property of this view,
pretty straightforward.  I'm 

07:46:50.148 --> 07:46:53.560
supplying an alpha string and 
that is a bad idea because when 

07:46:53.561 --> 07:46:58.017
a property string is being 
passed to the object animator, 

07:46:58.474 --> 07:47:02.883
we have to prefix that string 
with a set and get to use 

07:47:03.435 --> 07:47:07.960
reflection to find the setter 
and getter in the target 

07:47:08.309 --> 07:47:12.606
object's class and that's more 
costly.  What we recommend, 

07:47:14.693 --> 07:47:18.488
instead, is using this property 
object.  It is introduced in API

07:47:19.782 --> 07:47:26.910
14.  Along with a bunch of other
properties.  What happens is 

07:47:27.305 --> 07:47:31.993
whenever the animation value 
gets updated, the set value will

07:47:31.994 --> 07:47:38.652
be called and from there, the 
set alpha will be called on the 

07:47:39.029 --> 07:47:41.002
view.  Must more efficient than 
reflection.  

07:47:41.003 --> 07:47:49.332
If we take a closer look at this
animation, we can see that the 

07:47:49.611 --> 07:47:53.688
text blows up, so there are 
three properties being animated.

07:47:54.054 --> 07:47:59.980
The alpha scale X and scale y. 
Here's how we can do that.  We 

07:48:00.278 --> 07:48:04.112
can create three property value 
holders, one for each property 

07:48:04.387 --> 07:48:08.855
and then we can specify the 
start value and end value and 

07:48:09.347 --> 07:48:12.846
once we have all these property 
value holders defined, we can 

07:48:13.748 --> 07:48:19.071
set this on the object animator.
Then the object animator can 

07:48:19.464 --> 07:48:22.853
drive the change of the property
values.  

07:48:22.854 --> 07:48:26.879
One caveat is when you use 
multiple property value holders 

07:48:27.425 --> 07:48:32.931
on one object animator, you are 
essentially animating all these 

07:48:33.844 --> 07:48:38.247
properties with the same in 
turpulator, using the same 

07:48:38.591 --> 07:48:43.378
duration on the same object.  A 
lot of times, we want to animate

07:48:44.489 --> 07:48:48.399
scale X and scale y 
simultaneously, that's what you 

07:48:48.615 --> 07:48:53.137
need.  If you want to define 
that in XML with the property 

07:48:53.751 --> 07:48:57.799
values holder, it looks pretty 
straightforward.  

07:48:57.800 --> 07:49:01.660
If you take a look at the bottom
of this animation, there's a 

07:49:02.092 --> 07:49:05.568
button fading in.  To coordinate
these different animations 

07:49:05.847 --> 07:49:11.680
together, we can create an 
animator set and then with the 

07:49:11.681 --> 07:49:15.692
-- with the Play method, it 
would return a building and we 

07:49:16.120 --> 07:49:20.910
want to play the fade-in after 
the fade-out.  So -- and then, 

07:49:21.316 --> 07:49:25.761
while the text is fitting in, we
also want to blow it up so we're

07:49:25.985 --> 07:49:29.010
going to play the fade-in with 
the scale animation and then we 

07:49:29.329 --> 07:49:33.340
want to play all the text 
animations before the button 

07:49:33.341 --> 07:49:35.961
fades in.  
So, that's pretty 

07:49:36.784 --> 07:49:42.014
straightforward API and 
powerful, too.  

07:49:42.015 --> 07:49:46.828
Now we've seen how we can 
animate different properties 

07:49:47.601 --> 07:49:52.532
unconjunction with object 
animator.  If they happen to be 

07:49:54.642 --> 07:50:00.014
view properties, you can call 
this to create a view property 

07:50:00.015 --> 07:50:04.169
animator and then there are a 
bunch of methods for various 

07:50:04.170 --> 07:50:11.183
properties and then you set an 
end value and optionly, you can 

07:50:12.564 --> 07:50:19.908
set an in turpulator and stop.  
It doesn't get more beautiful 

07:50:20.304 --> 07:50:23.005
and concise than this.  
View property is backed by a 

07:50:23.439 --> 07:50:27.004
value animator.  It's not an 
animator so you can't really 

07:50:27.272 --> 07:50:30.917
coordinate with the other types 
of animators.  You can't reverse

07:50:31.733 --> 07:50:36.152
it or repeat it.  Some people --
some people ask me, is view 

07:50:36.474 --> 07:50:40.851
property animator as efficient 
as object animator?  I can 

07:50:41.640 --> 07:50:44.486
assure you, it's actually 
slightly more efficient than 

07:50:44.706 --> 07:50:48.971
object animator.  The reason for
that, is view property animator 

07:50:48.972 --> 07:50:53.709
has been optimized for animating
view properties and it ensures 

07:50:54.491 --> 07:51:00.581
that for all the view propties, 
there's one pass of validation 

07:51:01.158 --> 07:51:06.073
gets triggered.  Whereas if you 
use object animator to animate 

07:51:06.353 --> 07:51:09.186
various properties, each 
property change is going to 

07:51:09.631 --> 07:51:13.752
trigger its own set of 
validation pass.  

07:51:13.753 --> 07:51:18.907
View property animator is more 
for fire and forget kind of use 

07:51:19.840 --> 07:51:25.878
case where you start animation 
and just forget about it.  

07:51:25.879 --> 07:51:32.349
Now, you might have seen this 
animation before, in the 

07:51:32.642 --> 07:51:35.978
previous slides.  Did you notice
there's three little dots 

07:51:36.283 --> 07:51:41.576
animating at the end of the 
text?  And these little dots are

07:51:41.892 --> 07:51:46.945
not really a property for the 
text view.  So, here, we're 

07:51:47.457 --> 07:51:52.346
going to create a value animator
to animate the number of dots.  

07:51:52.639 --> 07:51:59.789
We're going to type an 
integer-type.  There's a repeat 

07:52:00.202 --> 07:52:04.854
count.  And with value animator,
you almost always want to use an

07:52:05.135 --> 07:52:09.599
update listener because value 
animator is going to animate on 

07:52:09.885 --> 07:52:17.563
its own.  So, here, with value 
-- with the update listener, 

07:52:17.564 --> 07:52:20.953
we're going to read the value 
out of the value animator and 

07:52:20.954 --> 07:52:24.704
use it as the number of dots we 
want to show. 

07:52:24.705 --> 07:52:28.923
And then we're going to have a 
spanable string from the text 

07:52:29.211 --> 07:52:35.575
view.  We're going to set a span
for the -- we're going to set a 

07:52:35.850 --> 07:52:38.422
transparent color span on -- 
rather on the dots that 

07:52:39.487 --> 07:52:42.628
shouldn't be showing.  And -- 
which with each animation 

07:52:43.165 --> 07:52:47.168
update, we will update the 
number of dots that should be 

07:52:47.460 --> 07:52:50.123
showing and then 
correspondingly, change the 

07:52:50.450 --> 07:52:55.992
range to hide the dots that we 
want to not show.  

07:52:55.993 --> 07:53:00.642
So, to recap, when should we use
what kind of animator?  Object 

07:53:00.950 --> 07:53:03.692
animator is kind of this 
all-purpose animator that, as 

07:53:03.980 --> 07:53:06.675
long as you have a property you 
want to animate, you can use 

07:53:06.676 --> 07:53:13.109
that.  Value animator is for 
animating a more customized kind

07:53:13.877 --> 07:53:18.005
of animation where you want to 
animate this value and then use 

07:53:18.277 --> 07:53:23.520
that value to apply it to 
something else in your UI.  View

07:53:23.521 --> 07:53:27.520
property animator is the best 
use when you have multiple view 

07:53:27.521 --> 07:53:32.657
properties that you need to 
animate simultaneously on the 

07:53:32.658 --> 07:53:36.559
same view and because you can't 
really coordinate this view 

07:53:36.560 --> 07:53:42.334
property animator with anything 
else, it's only good it for the 

07:53:42.877 --> 07:53:45.552
fire and forget use case. 
And then property values 

07:53:46.061 --> 07:53:52.167
holders, with property values 
holder, you can define multiple 

07:53:52.895 --> 07:53:58.560
properties and make them using 
an object animator.  The nice 

07:53:59.736 --> 07:54:03.920
thing about property values 
holder is that it not only 

07:54:04.331 --> 07:54:07.885
allows you to animate multiple 
properties simultaneously 

07:54:07.886 --> 07:54:13.189
because it's really being set on
the object animator, you can 

07:54:13.628 --> 07:54:17.340
then coordinate that or seek or 
reverse, so it's more powerful. 

07:54:17.710 --> 07:54:21.486
Animator set, you have multiple 
animations you want to 

07:54:21.707 --> 07:54:25.217
coordinate, animator set would 
be a good choice.

07:54:25.218 --> 07:54:29.682
Thank you very much.  Next up, 
we have animated vector 

07:54:30.199 --> 07:54:33.502
drawable.  These are great for 
doing graphic animations like 

07:54:33.503 --> 07:54:40.075
the wonderful icons you see in 
the Google Fit appplication.  It

07:54:40.076 --> 07:54:43.851
basically connects together a 
vector drawable to one or 

07:54:44.261 --> 07:54:47.565
multiple object animators and 
runs animations on them.  It has

07:54:48.147 --> 07:54:54.523
a very kind of small focused 
API, it basically implements the

07:54:56.696 --> 07:55:01.062
animator.  You can get a 
drawable like this and call 

07:55:01.481 --> 07:55:05.898
start.  It is great for, like, 
performance critical and vector 

07:55:07.113 --> 07:55:13.424
graphic information, especially 
where drawable was reimplemented

07:55:13.952 --> 07:55:22.942
in code.  Even if you're doing 
the UI thread, it will keep 

07:55:23.234 --> 07:55:27.826
playing.  There is more time for
you to do your code rather than 

07:55:28.086 --> 07:55:32.621
running the animation code.  
When you need to animate icons 

07:55:32.622 --> 07:55:36.912
or animate graphics, when it 
needs to be this fire and 

07:55:38.561 --> 07:55:41.901
forget.  You can't seek through 
it.  You can't control the 

07:55:42.432 --> 07:55:51.347
progress for it.  I urge you to 
look at Kirye drawable.  It is 

07:55:51.724 --> 07:55:58.098
good for anything that's 
performance critical.

07:55:59.143 --> 07:56:04.641
Now, physics animation.  Who 
doesn't love physics?  It is 

07:56:05.079 --> 07:56:09.789
perfect for a highly-interactive
use case where you have lots of 

07:56:10.062 --> 07:56:13.783
gestures going on and you want 
to carry on that momentum of 

07:56:13.784 --> 07:56:19.061
that gesture into a UI to create
this sense of continuity.  

07:56:19.062 --> 07:56:23.579
Because when they allow gestures
in flight, you could then 

07:56:24.112 --> 07:56:26.551
potentially interrupt the 
existing ongoing animation.  I'm

07:56:27.041 --> 07:56:30.987
sure you've seen animations 
where you want the animation -- 

07:56:31.486 --> 07:56:37.100
you want the view to move from 
one location to the other and 

07:56:37.383 --> 07:56:41.936
then there's just some from the 
users and the ending location 

07:56:41.937 --> 07:56:45.679
would have changed.  And in this
case, if you use physic space 

07:56:46.286 --> 07:56:51.635
animation, that would simply 
change some physics force and 

07:56:51.912 --> 07:56:56.891
then as a result, the course 
correction would be really 

07:56:56.892 --> 07:57:04.320
smooth.  
So, here, I have an example of 

07:57:04.647 --> 07:57:09.343
this little bubble with my cat's
picture on it.  And it's in an 

07:57:09.629 --> 07:57:13.050
application overlay window so it
sits on top of other 

07:57:13.510 --> 07:57:17.727
applications.  And in this case,
that is the beautiful Timely 

07:57:18.330 --> 07:57:23.415
app.  My goal is, is I drag this
little bubble around.  When I 

07:57:24.101 --> 07:57:29.459
let go, it should rest on either
side of the screen and -- so to 

07:57:30.572 --> 07:57:37.732
achieve this, we obviously need 
to start with a listener and use

07:57:38.391 --> 07:57:41.897
velocity listener to track the 
movement and track the positions

07:57:42.748 --> 07:57:47.112
and in the subsequent events, 
we'll need to calculate how much

07:57:47.392 --> 07:57:53.305
your finger has moved since that
down event and update the 

07:57:53.595 --> 07:57:57.329
bubble's position accordingly 
and then when there's an action 

07:57:58.179 --> 07:58:02.523
up, that's where the interesting
thing comes up.  We're going to 

07:58:03.285 --> 07:58:09.966
calculate the velocity and then 
here, for simplification, for 

07:58:10.433 --> 07:58:14.287
the demo, we're just going to 
say, when the velocity is 

07:58:14.471 --> 07:58:17.325
greater than zero, we're going 
to move to the right side of the

07:58:17.760 --> 07:58:21.693
screen.  Otherwise, left side.  
Now that we have the final 

07:58:22.481 --> 07:58:26.451
position where we want the 
bubble to rest on, we can create

07:58:26.452 --> 07:58:29.576
a string animation.  That is a 
custom property, which I will 

07:58:29.857 --> 07:58:33.339
explain in the next slide.  
Before we start the animation, 

07:58:33.875 --> 07:58:37.451
we also want to set the start 
velocity and this is critical to

07:58:38.595 --> 07:58:43.586
ensure that that transition from
gesture to the animation is 

07:58:43.874 --> 07:58:46.458
seamless.  
So, this is my custom property 

07:58:46.885 --> 07:58:50.234
and the whole point of this 
custom property is really just 

07:58:50.496 --> 07:58:55.081
to associate the animation value
with the position of that 

07:58:55.282 --> 07:58:59.229
bubble.  Whenever the animation 
value changes, we get this -- we

07:58:59.901 --> 07:59:05.036
get this set value call.  We're 
then going to set the animation 

07:59:05.389 --> 07:59:07.389
value on to the layout 

07:59:10.571 --> 07:59:14.875
params.X because it is animating
in an application overview 

07:59:14.876 --> 07:59:20.303
window and have window manager 
update view layout to reflect 

07:59:20.304 --> 07:59:24.058
that change and similarly, in 
get value, we're just going to 

07:59:24.059 --> 07:59:26.059
return the 

07:59:28.186 --> 07:59:31.039
layout params.X. 
  Thank you.  Next up is the 

07:59:32.036 --> 07:59:36.551
transitions API.  Now, 
transitions are about looking at

07:59:36.847 --> 07:59:42.767
two different layout states and 
saying what has changed between 

07:59:43.232 --> 07:59:49.420
between them.  Really, you can 
think of transitions as a 

07:59:49.949 --> 07:59:54.843
factory.  Awhile ago, I talked 
about how it's great for doing 

07:59:54.844 --> 07:59:58.300
things like this, two different 
constraint sets and using 

07:59:58.301 --> 08:00:01.277
transition manager.  I think 
this is 

08:00:04.552 --> 08:00:11.223
better-solved MotionLayout.  I 
wouldn't consider it is good for

08:00:12.269 --> 08:00:16.293
that.  
You call this and make changes 

08:00:16.294 --> 08:00:20.664
to the view hierarchy and magic 
happens.  It looks at the two 

08:00:21.045 --> 08:00:24.107
different states of the UI, 
works out what's changed, 

08:00:24.652 --> 08:00:30.338
creates an animator.  There's an
overlay where you can control 

08:00:31.192 --> 08:00:33.915
those transition.  What I love 
about transitions is what it 

08:00:34.206 --> 08:00:38.304
does to the code base.  Here's a
change where I moved it out of 

08:00:38.744 --> 08:00:44.729
the view layer into transitions.
Sometimes it can look gnarly 

08:00:44.730 --> 08:00:48.941
like this.  Pre-draw listeners 
and poking around to the view 

08:00:49.399 --> 08:00:52.833
hierarchy.  By moving it to 
transitions, we move it to this

08:00:56.913 --> 08:01:00.997
declarative architecture.  It is
composed with some of the 

08:01:01.271 --> 08:01:04.872
transitions in a more composable
manner.  Yet, you might have to 

08:01:06.557 --> 08:01:11.755
write some transitions youself. 
But, that code ends up being 

08:01:11.756 --> 08:01:14.785
much more -- I don't know -- 
nicer to work with and much more

08:01:15.785 --> 08:01:19.230
focused and found it like a 
really good change to the 

08:01:19.231 --> 08:01:21.231
codebase. 
Transitions, which should you 

08:01:21.354 --> 08:01:26.621
use them?  For me, there's one 
strong use case which is shared.

08:01:27.393 --> 08:01:31.549
It's pretty much the only thing 
you can use to achieve this 

08:01:31.819 --> 08:01:35.561
unless you go super custom.  
There's actually two transitions

08:01:35.807 --> 08:01:41.854
going on here.  There's the 
shared element between the 2 AK 

08:01:42.537 --> 08:01:45.442
activities and then there's a 
window content transition.  When

08:01:46.547 --> 08:01:50.390
the window launches or exits, 
run these animations on the 

08:01:50.613 --> 08:01:53.811
content.  When the viewer 
arrives, the rest of the content

08:01:54.962 --> 08:01:58.545
animates upwards.  
So, when should you use 

08:01:58.760 --> 08:02:00.760
transition API?  Shared element

08:02:03.384 --> 08:02:08.606
elements, for me.  Also, if you 
are looking to modularize and 

08:02:08.607 --> 08:02:12.176
compose your animation code, 
transitions can be helpful.  As 

08:02:12.702 --> 08:02:19.004
well as simple transitions, 
using the begin delay method.  

08:02:20.904 --> 08:02:26.317
MotionLayouts.
  All right.  So far we've been 

08:02:26.318 --> 08:02:30.193
talking about coding.  It's 
super powerful.  The APIs are 

08:02:30.356 --> 08:02:36.790
really, really complete.  On 24 
the other hand, it's quite 

08:02:38.147 --> 08:02:43.525
time-consuming.  What can we do 
to help that?  We want to make 

08:02:43.819 --> 08:02:50.715
you more productive, let you 
iterate faster.  We want to make

08:02:52.082 --> 08:02:56.867
the motion design a lot more 
accessible.  So one thing that 

08:02:58.096 --> 08:03:02.293
we introduced is the helpers 
object.  And in fact, helpers 

08:03:02.888 --> 08:03:09.889
object is something that you've 
been using.  We used for 

08:03:10.702 --> 08:03:14.560
guidelines.  Not really part of 
your view, your hierarchy in the

08:03:14.561 --> 08:03:17.570
sense that it doesn't show up on
screen but they are here to help

08:03:17.571 --> 08:03:23.358
you create those layouts.  To 
bring additional concepts to 

08:03:23.359 --> 08:03:27.727
make it easier.  In 2.0, we 
exposed them so you can, 

08:03:28.043 --> 08:03:34.877
yourself, create helpers just by
narrating the class.  It's a way

08:03:35.170 --> 08:03:42.013
of doing code and putting into a
helper, we support the user, so 

08:03:42.415 --> 08:03:50.399
it's easy to add and you can 
think about it as a way of 

08:03:50.885 --> 08:03:53.353
tagging with a specific 
behavior.  In the case of 

08:03:53.661 --> 08:03:57.964
animation, that's really nice 
because, you know, you get the 

08:03:58.233 --> 08:04:01.705
code.  You have your helper 
built and we have all the wealth

08:04:01.957 --> 08:04:05.001
of the Android animation APIs 
and you can do stuff like that. 

08:04:05.561 --> 08:04:10.227
Right.  For example, you know, 
pretty well-known animation.  

08:04:10.679 --> 08:04:13.800
The only thing I really needed 
to do here is define this piece 

08:04:14.140 --> 08:04:18.408
of code and really what I'm 
talking about -- okay.  What -- 

08:04:18.689 --> 08:04:24.227
what I only need to do here is 
this code that you see on the 

08:04:24.519 --> 08:04:32.239
screen, I'm simply calling.  I'm
not reinventing the wheel here. 

08:04:33.137 --> 08:04:36.135
I'm not coming up with a new 
way.  But that's the only thing 

08:04:36.584 --> 08:04:40.362
I need to do for my helper and 
then in your layout file, you 

08:04:40.673 --> 08:04:45.260
only need to declare that helper
and specify the IDs of the 

08:04:45.487 --> 08:04:50.529
widgets you want to apply to.  
So, it makes basically -- it's a

08:04:51.054 --> 08:04:55.775
lot easier for you to package 
blocks of usable code and, you 

08:04:56.244 --> 08:04:58.962
know, use them in your 
application.  

08:04:58.963 --> 08:05:05.851
So, going back to the code 
stuff.  So, the other way we 

08:05:05.852 --> 08:05:09.797
thought about making your life 
easier, letting you build 

08:05:10.083 --> 08:05:13.497
reasonable bricks is by moving 
to declarative way for 

08:05:13.498 --> 08:05:18.459
animation.  So, you can think 
about it as a specification for 

08:05:18.718 --> 08:05:23.191
motion.  And, we interpret this 
specification with a motion 

08:05:23.349 --> 08:05:26.572
engine and on top of that, we 
are building a graphical motion 

08:05:26.787 --> 08:05:30.965
editor.  So, it's something we 
introduced at Google I/O.  We 

08:05:31.321 --> 08:05:35.688
are still working on it.  We 
decided to focus on the library 

08:05:35.934 --> 08:05:40.096
side.  Because kind of want to 
make sure it's right for you and

08:05:40.380 --> 08:05:45.461
for your needs.  But just a 
quick overview on the current 

08:05:45.462 --> 08:05:53.115
build, it's coming along and 
hopefully it will come soon, in 

08:05:53.893 --> 08:05:55.893
a version

08:05:57.271 --> 08:05:59.865
of Studio.  
So, that's kind of like the 

08:05:59.866 --> 08:06:05.276
overall approach we have for 
helping you.  So, the helper on 

08:06:05.995 --> 08:06:08.924
one hand and this motion 
specification on the other.  

08:06:09.190 --> 08:06:15.464
The thing that's kind of nice, 
if I look at this, is that you 

08:06:16.899 --> 08:06:19.663
can specify this motion and 
we'll then take care of it.  You

08:06:20.286 --> 08:06:26.369
don't really have to write code 
for it.  

08:06:26.370 --> 08:06:30.165
So, the one we implemented is 
through MotionLayout.  So, what 

08:06:30.662 --> 08:06:34.019
is MotionLayout?  It's a view 
group.  So, one caveat is that 

08:06:34.020 --> 08:06:37.929
it means you can only animate 
the children of that view group 

08:06:38.609 --> 08:06:42.380
and it's a subclass.  If you 
know ConstraintLayout, it's 

08:06:42.381 --> 08:06:46.804
great.  You can directly use 
MotionLayout.  On the flip side,

08:06:48.279 --> 08:06:50.333
you do have to use 
ConstraintLayout.  But it does a

08:06:51.945 --> 08:06:59.520
lot.  So, we do transitions, 
properties, we have a really 

08:06:59.521 --> 08:07:05.587
good support for touch-driven 
motion.  So it's kind of like 

08:07:06.373 --> 08:07:09.715
thinking values of animation and
packaging it into a single 

08:07:10.027 --> 08:07:13.918
place.  
So, roughly-speaking, the only 

08:07:14.219 --> 08:07:16.806
thing you have to understand is 
we are animating between two 

08:07:18.530 --> 08:07:22.154
states.  We have a start state 
and an end state and we 

08:07:22.456 --> 08:07:27.281
interpret between those two 
things.  So, in addition to 

08:07:27.755 --> 08:07:33.809
basically supporting layout 
changes, essentially you have 

08:07:33.810 --> 08:07:38.265
two virg  versions of the 
layout, we support custom 

08:07:38.625 --> 08:07:41.289
properties if you want to 
animate color and key frames and

08:07:41.290 --> 08:07:47.396
you can think about key frame as
a modifier on that, you know, 

08:07:47.732 --> 08:07:50.295
transformed between the start 
and the end.  

08:07:50.296 --> 08:07:56.000
So, to kind of summarize, with 
MotionLayouts, it tells you to 

08:07:56.288 --> 08:08:00.738
think about your animation, your
transition, your motion as a 

08:08:01.406 --> 08:08:05.962
declaration.  You just specify 
what it should do and we take 

08:08:06.292 --> 08:08:09.378
care of it.  It specifically is 
great when you want to do 

08:08:11.772 --> 08:08:15.851
fine-tuned animation.  So, it's 
very specific what you want to 

08:08:16.398 --> 08:08:20.840
do, it's about coordinating 
together in a very specific way 

08:08:21.220 --> 08:08:26.853
and finally, it's really nice, 
as well, for the touch-driven 

08:08:26.854 --> 08:08:28.274
motion. 
motion.

08:08:28.275 --> 08:08:36.760
I don't think I need the mic.
  So, I want to just kind of, 

08:08:36.988 --> 08:08:41.743
like, show you guys a lot of 
things and be a little more 

08:08:42.013 --> 08:08:47.526
visual from here on in.  So, 
this is the way you want to 

08:08:48.375 --> 08:08:50.375
create -- carefully

08:08:53.526 --> 08:09:00.925
craft custom coordinated, crazy,
cool animation.  You can do 

08:09:00.926 --> 08:09:04.413
stuff like that.
[Laughter]

08:09:04.414 --> 08:09:10.080
[Applause]
  So, how did we do that?  It's 

08:09:11.116 --> 08:09:16.431
just two -- two chains.  The 
change into one chain and each 

08:09:17.090 --> 08:09:20.192
letter's a view and we use a 
stagger and a color change and a

08:09:20.583 --> 08:09:23.877
custom match view.  It's fairly 
simple to view.  It took me a 

08:09:24.144 --> 08:09:27.327
view minutes, it looks cool.  
And that's kind of what this 

08:09:29.333 --> 08:09:33.859
stuff is all about.  
So, the first thing, you can 

08:09:34.160 --> 08:09:39.664
drive stuff out with touch.  It 
will handle swipes.  If you 

08:09:39.941 --> 08:09:44.348
flick, it'll go across quickly. 
It understands velocity and 

08:09:44.706 --> 08:09:49.062
manages that.  The next thing to
understand is we're starting 

08:09:49.272 --> 08:09:52.499
from two constraint sets but we 
have key frames and in this 

08:09:52.852 --> 08:09:56.435
case, here, I'm starting with 
two constraint sets and I'm not 

08:09:56.809 --> 08:10:00.985
having any key frames and you 
see how it crosses right there? 

08:10:01.981 --> 08:10:07.568
Right there, they overlap.  So 
what you do is you add some key 

08:10:07.826 --> 08:10:11.370
position, key frames, and you 
accelerate in the X -- you 

08:10:11.705 --> 08:10:16.949
finish the X part of the motion,
halfway through and that gives 

08:10:17.156 --> 08:10:22.498
you a kind of smooth, you know 
-- you've seen this.  It's your 

08:10:23.530 --> 08:10:25.337
settings menu.
[Laughter]

08:10:25.338 --> 08:10:29.691
So, the more extreme end of what
we can do with key frames are 

08:10:29.971 --> 08:10:33.205
key cycles and here, you can see
a bunch of different kind of 

08:10:33.529 --> 08:10:36.843
effects that we can do.  
Essentially, anything that's 

08:10:37.266 --> 08:10:40.723
oscillating, it's shaking, it's 
bouncing around, you don't want 

08:10:40.724 --> 08:10:45.599
to actually go and build out 
complex paths with key frames.  

08:10:45.600 --> 08:10:52.644
This solves it.  In alpha 2, we 
are introduing time cycles.  

08:10:52.867 --> 08:10:56.082
This is a crazy animation you 
can do with it.  Of course, this

08:10:56.660 --> 08:11:02.094
is way too over-the-top and 
please don't use this in 

08:11:03.310 --> 08:11:04.135
product.
[Laughter]

08:11:04.136 --> 08:11:10.468
But -- so, let's get into how to
use it.

08:11:10.469 --> 08:11:16.564
Right.  So -- so, first of all, 
there's information that we 

08:11:16.565 --> 08:11:20.532
created so I'm going to go 
quickly.  Please look at those 

08:11:20.951 --> 08:11:26.967
articles.  There is also a 
GitHub with examples.  

08:11:26.968 --> 08:11:30.783
One thing you may ask yourself 
is, okay, this is great.  How do

08:11:31.619 --> 08:11:35.547
you use this in my application? 
There's an example where you 

08:11:36.106 --> 08:11:42.053
have a collapsible toolbar and 
to this kind of things with the 

08:11:42.314 --> 08:11:48.262
normal collapsible toolbar, you 
can simply use a MotionLayout 

08:11:48.435 --> 08:11:51.707
instead.  You don't really 
change anything else in your 

08:11:52.009 --> 08:11:56.042
code, but collapsible becomes a 
MotionLayout and take all the 

08:11:56.375 --> 08:11:59.629
advantages of it.  
Similarly, you don't have to use

08:12:00.953 --> 08:12:05.317
a new class, you can use 
MotionLayout for it.  Same thing

08:12:05.674 --> 08:12:09.934
for view page.  You can easily 
plug MotionLayout into it.  

08:12:09.935 --> 08:12:16.601
The last example is interesting.
It's -- it really looks -- 

08:12:16.602 --> 08:12:19.208
actually, this is pure 
MotionLayout.  And what's nice 

08:12:19.485 --> 08:12:26.477
about it is that it actually is 
too MotionLayouts nested and we 

08:12:26.676 --> 08:12:31.939
have one for collapsible to the 
bar, it's the exact same one I 

08:12:32.848 --> 08:12:37.151
used before.  And it's simply 
nested into a MotionLayout.  

08:12:37.842 --> 08:12:43.794
What's really nice is that in 
order to specify this overall 

08:12:43.795 --> 08:12:47.412
screen, I just need to create 
those two states, the start and 

08:12:48.121 --> 08:12:54.791
end.  You see that in the end, I
simply make the MotionLayout 

08:12:55.045 --> 08:12:59.340
that's for the toolbar smaller 
and basically, we take care of 

08:12:59.660 --> 08:13:01.872
all of it.  
So, to summarize for the current

08:13:02.165 --> 08:13:08.222
state, we're working on the 
graphical editor.  But for the 

08:13:09.569 --> 08:13:13.764
library, we did Google I/O and 
we did an alpha 2.  And, you 

08:13:13.951 --> 08:13:19.615
know, even in alpha, it's built 
on 1.1 so it's actually pretty 

08:13:19.919 --> 08:13:24.168
stable.  And in fact, because 
it's pretty stable, quite a few 

08:13:24.734 --> 08:13:27.881
people started to build stuff 
with it and we'll go through 

08:13:28.498 --> 08:13:33.301
some examples just to give you a
little taste of what you can do 

08:13:33.711 --> 08:13:37.661
with MotionLayout.
  So, I looked on the Twitter a 

08:13:38.064 --> 08:13:42.229
lot.  I checked MotionLayout on 
Twitter all the time and I 

08:13:42.230 --> 08:13:47.629
thought I would just share a few
interesting animations that 

08:13:48.500 --> 08:13:52.937
people have published.  Most of 
these, you can actually find in 

08:13:52.938 --> 08:13:58.865
GitHubs.  These people publish 
them as videos and show them.  

08:13:59.151 --> 08:14:02.548
This guy's been doing quite a 
few pieces of work with it.  

08:14:02.862 --> 08:14:05.488
It's kind of interesting to see 
what he did here. 

08:14:05.489 --> 08:14:10.576
And this one is particularly 
interesting.  Basically, you 

08:14:11.047 --> 08:14:14.882
maybe notice in the previous 
one, there was a motion.  Very 

08:14:15.197 --> 08:14:20.728
nice.  In this particular 
example, what's nice is that 

08:14:21.152 --> 08:14:25.108
it's kind of like a view pager. 
He added a way to drive it from 

08:14:25.109 --> 08:14:30.722
code and that's a very 
interesting, you know, future 

08:14:30.900 --> 08:14:36.984
avenue for us.  It's a little 
bit -- how can your code reuse 

08:14:36.985 --> 08:14:39.454
some this previously-defined 
behavior?

08:14:40.773 --> 08:14:45.604
So, another one by him, the 
interesting thing here is it's 

08:14:45.605 --> 08:14:51.063
sort of mixing what is a normal 
RecyclerView and then sort of a 

08:14:51.537 --> 08:14:57.982
reveal detail view.  But it's 
interesting MotionLayout. 

08:14:57.983 --> 08:15:01.718
It is super easy to come up with
your own ways of doing these 

08:15:01.719 --> 08:15:06.984
kinds of transitions.  
You're not limited anymore.

08:15:06.985 --> 08:15:13.415
This guy implemented a material 
design animation spec, but just 

08:15:13.416 --> 08:15:19.901
using MotionLayout and a custom 
view that he built.  It was a 

08:15:19.902 --> 08:15:23.232
quite nice piece of work. 
One of the things I liked about 

08:15:23.584 --> 08:15:27.832
this one is it's so original.  
You see view pages.  Okay.  This

08:15:28.114 --> 08:15:36.364
is taking a whole new twist on 
it or spin on it, actually.

08:15:36.365 --> 08:15:40.333
[Laughter]
But you can see, it's original. 

08:15:40.601 --> 08:15:45.574
You can sort of explore your own
creativity or your team's 

08:15:46.205 --> 08:15:52.015
createty with what they like and
what they do.  

08:15:52.016 --> 08:15:58.063
This one is interesting because 
it's kind of like a typical 

08:15:58.280 --> 08:16:01.856
coordinator layout stuff.  You 
see it's transparent and there's

08:16:02.807 --> 08:16:05.934
special effects going on with 
things fading.  It produces a 

08:16:06.370 --> 08:16:11.031
unique, you know, custom view of
the whole thing.  

08:16:11.032 --> 08:16:16.298
And this is our Chris Banes.
[Laughter]

08:16:16.299 --> 08:16:22.171
And, he did a very interesting 
one and it's a whole app.  All 

08:16:22.858 --> 08:16:29.205
the codes involved is out there.
It is very custom.  So, let's 

08:16:29.830 --> 08:16:34.887
take a closer look at it. 
  So, what's great with it is 

08:16:35.588 --> 08:16:38.888
this is the type of motion that 
is purely by code.  There's a 

08:16:39.162 --> 08:16:42.276
lot of subtle coordination 
across so many elements.  The 

08:16:42.871 --> 08:16:46.518
text is fading, that poster is 
actually rotating,

08:16:49.699 --> 08:16:54.848
but actually matching.  That's 
what we mean when we are talking

08:16:55.303 --> 08:16:57.981
about motion or fine-tuned 
crafted motion.  

08:16:57.982 --> 08:17:02.863
This is the type of example that
we hope we encourage you to 

08:17:03.926 --> 08:17:07.185
build.
  As a small sneak peek at what 

08:17:07.453 --> 08:17:11.558
we'll be having in alpha 3, 
it'll support multiple states 

08:17:11.997 --> 08:17:15.474
and allow you to interact with 
the multiple states purely from 

08:17:15.874 --> 08:17:23.312
touch.  So, this is one single 
MotionLayout, but in fact, it's 

08:17:23.313 --> 08:17:30.190
handling transitions between 
three transitions from a blank 

08:17:30.612 --> 08:17:33.967
page to swiping the bottom to 
swiping a little bit, to swiping

08:17:34.547 --> 08:17:38.611
more.  It's all one page, one 
MotionLayout and it can produce 

08:17:39.627 --> 08:17:45.004
a fairly sphistticated custom 
view. 

08:17:45.005 --> 08:17:50.693
This touch behavior, zero from 
your end.  It's all

08:17:55.238 --> 08:17:57.238
declarative.

08:17:58.408 --> 08:18:01.513
[Applause and cheers]
  Pretty awesome.  Cool.  So, 

08:18:02.406 --> 08:18:09.132
today, hopefully we've given you
a guided tour from animated API 

08:18:09.557 --> 08:18:12.174
and our goal was to make you 
more familiar with what they're 

08:18:12.450 --> 08:18:15.538
good at and what they're not so 
good at so I'm going to try to 

08:18:16.170 --> 08:18:21.159
summarize that as a takeaway.  
The complex coordinated layout 

08:18:21.160 --> 08:18:25.301
and for that nice hand-off 
between gesture and animation, 

08:18:25.676 --> 08:18:27.505
really do check out 
MotionLayout.  

08:18:27.506 --> 08:18:32.650
If you need to build 
interruptable animations or 

08:18:33.376 --> 08:18:38.324
gesture with the velocity 
tracking, look at the physics 

08:18:38.325 --> 08:18:40.535
layout system. 
If you need to do

08:18:43.623 --> 08:18:47.477
shared transitions, transitions 
is for you.  

08:18:47.478 --> 08:18:51.325
If you need to do vectors, do 
vector drawable.  

08:18:51.326 --> 08:18:55.592
If you need to do window 
animations, the original SDK 1 

08:18:56.054 --> 08:18:58.173
view animation system should be 
used.  

08:18:58.174 --> 08:19:01.672
If you need to animate 
properties of views, look at the

08:19:02.273 --> 08:19:07.158
view property animator.  
If you need to do, like, custom 

08:19:07.159 --> 08:19:10.340
view animation or driven by an 
amimation

08:19:14.361 --> 08:19:19.427
pulse, look at the animator.  
Animator is your go-to default 

08:19:19.785 --> 08:19:23.251
for general purpose animation.  
Next time you have to build 

08:19:23.564 --> 08:19:25.890
something, you won't be 
paralyzed by choice of the 

08:19:26.175 --> 08:19:30.030
different animation APIs. So, I 
thank you very much for joining 

08:19:30.031 --> 08:19:36.653
us and we'll be outside.  Thanks
very much.

08:19:51.060 --> 08:19:54.302
[Applause]
  Hello?  So, now it's time for 

08:19:54.303 --> 08:19:57.173
a completely different session 
that will last about two minutes

08:19:57.644 --> 08:20:00.801
long.  We're just closing out 
the day here.  I was personally 

08:20:01.084 --> 08:20:06.460
curious whether you liked it or 
not.  How many people liked the 

08:20:06.779 --> 08:20:07.471
dev summit?  
[Applause]

08:20:07.472 --> 08:20:11.019
How many people didn't like the 
dev summit and what are you 

08:20:11.308 --> 08:20:14.678
doing here still, at the end of 
the second day?  

08:20:14.679 --> 08:20:16.768
[Laughter]
So maybe it worked.  That would 

08:20:17.044 --> 08:20:21.637
be cool.  I think the people 
from my team and Google liked 

08:20:21.638 --> 08:20:26.757
what happened.  A community 
aspect hearing from you and 

08:20:27.340 --> 08:20:29.841
being able to communicate the 
content.  Hopefully we will hold

08:20:30.326 --> 08:20:34.038
this again.  Hopefully it'll be 
a little less than three years 

08:20:34.335 --> 08:20:37.570
next time.  We have to convince 
the people that write the checks

08:20:38.135 --> 08:20:42.534
there Some of the favorite 
things you saw this week?  Just 

08:20:42.535 --> 08:20:46.397
shout out? 
Don't make it awkward.  

08:20:46.398 --> 08:20:49.064
MotionLayout all right.  What 
else?  Preferences.  Nice.  All 

08:20:49.359 --> 08:20:55.169
right.  Yeah, new little bit of 
thing coming out of the toolkit 

08:20:55.541 --> 08:21:01.334
area.  LiveData, yes.  Very 
cool.  Low latency audio.  Yes 

08:21:03.503 --> 08:21:09.124
and live-coding C++ in a 
five-minute lightning talk.  App

08:21:09.781 --> 08:21:12.965
Bundles, yes.  Kotlin native.  
All right.  Very interesting 

08:21:13.374 --> 08:21:19.535
coming online.  
What else?  I heard paraside 

08:21:20.556 --> 08:21:23.937
chat, which doesn't -- fireside,
I heard of that one.  Actually, 

08:21:24.422 --> 08:21:29.914
that was really fun today.  Did 
you like the chat?  Good.  

08:21:29.915 --> 08:21:32.302
Awesome.  
There is everything available, 

08:21:32.639 --> 08:21:36.787
now, almost online already.  Day
one is already posted to 

08:21:36.788 --> 08:21:41.049
YouTube.  I heard earlier that 
day two is going to be live as 

08:21:41.315 --> 08:21:43.549
early as 8:00 or 

08:21:46.680 --> 08:21:49.803
9:00 tonight.  
Go back to your hotels or homes 

08:21:49.955 --> 08:21:52.851
and watch it.  
Also, you will be getting a 

08:21:53.260 --> 08:22:00.520
survey, maybe it's in your inbox
right now.  Please do fill out. 

08:22:00.521 --> 08:22:06.887
We do actually read this stuff 
and pay very close attention to 

08:22:07.314 --> 08:22:11.405
it.  Tell us what worked, tell 
us what didn't and we will do 

08:22:11.601 --> 08:22:14.736
those things for you because you
are the reason that we're doing 

08:22:14.737 --> 08:22:17.114
this.  
Let's see.  Anything else?  I 

08:22:17.321 --> 08:22:21.669
think that's about it.  I am 
looking forward to doing another

08:22:22.078 --> 08:22:26.176
one of these. Hopefully we'll 
see you in 2021.  

08:22:26.177 --> 08:22:28.286
In the meantime -- 
[Laughter]

08:22:28.287 --> 08:22:31.745
In case you missed everything 
that happened, we tried to 

08:22:32.064 --> 08:22:38.877
capture it in 90 seconds.
  Welcome to the 2018 Android 

08:22:39.162 --> 08:22:45.017
Dev Summit.  This is an event 
for developers, by developers. 

08:22:50.200 --> 08:22:54.430
  With over two billion devices,
three-quarters of a trillion 

08:22:55.293 --> 08:23:02.731
apps downloaded every year.  
Android's developer community is

08:23:02.732 --> 08:23:04.732
growing. 

08:23:17.684 --> 08:23:19.165
growing.
  So, the Android App Bundle 

08:23:19.166 --> 08:23:23.085
makes it much simpler.  With no 
additional developer work 

08:23:23.642 --> 08:23:29.204
needed, the App Bundle now makes
apps an average of 8% smaller to

08:23:29.955 --> 08:23:33.483
download for devices.
  We simply could not do this 

08:23:34.824 --> 08:23:37.964
without you, so thank you.  

08:23:42.961 --> 08:23:44.961
[Applause and cheers]
  As Dave just said, thank you. 

08:23:45.929 --> 08:23:48.938
Thanks for coming.  

