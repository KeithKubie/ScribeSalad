WEBVTT
Kind: captions
Language: en

00:00:01.070 --> 00:00:03.787
Now I want to take some time to
show you how to use variables and

00:00:03.787 --> 00:00:05.520
constants in a playground.

00:00:05.520 --> 00:00:08.652
I've gone ahead and
opened this empty playground,

00:00:08.652 --> 00:00:11.865
and we'll get started by
declaring some variables.

00:00:11.865 --> 00:00:15.782
We know to create a variable that we
need to use something like the following

00:00:15.782 --> 00:00:16.285
syntax.

00:00:16.285 --> 00:00:20.560
We have the keyword var, then some
name for the variable, and its value.

00:00:21.600 --> 00:00:22.150
For example,

00:00:22.150 --> 00:00:26.350
I'll create this variable called
mJerseyNumber with the value of five.

00:00:26.350 --> 00:00:31.280
This creates or declares a variable
with the name myJerseyNumber, and

00:00:31.280 --> 00:00:34.330
when we write this code,
Swift works behind the scenes and

00:00:34.330 --> 00:00:39.990
infers that myJerseyNumber's type is
an integer, because five is an integer.

00:00:39.990 --> 00:00:45.320
And we can check this if we
hold down the option key, and

00:00:45.320 --> 00:00:46.970
we go up to the variable name, and

00:00:46.970 --> 00:00:50.690
we click it, we can see that it's
been declared as an int value.

00:00:51.970 --> 00:00:55.780
When Swift automatically infers
the type of the variable,

00:00:55.780 --> 00:00:59.650
in this case the int,
We call this inferred typing.

00:00:59.650 --> 00:01:00.690
So let's do another example.

00:01:01.870 --> 00:01:04.519
So we'll create this variable
called myCoolVariable and

00:01:04.519 --> 00:01:07.860
give it a value of a in double quotes.

00:01:07.860 --> 00:01:10.810
So if you've created a variable like
this before where you used the double

00:01:10.810 --> 00:01:16.410
quotes, you may already know what Swift
may infer this to be, but we can check.

00:01:16.410 --> 00:01:20.330
And it looks like Swift has interpreted
this as a string variable, so

00:01:20.330 --> 00:01:22.820
myCoolVariable contains a string,
and that makes sense.

00:01:22.820 --> 00:01:24.680
That's what these double quotes mean.

00:01:24.680 --> 00:01:26.370
That means a string.

00:01:26.370 --> 00:01:28.760
But this string is just one character.

00:01:28.760 --> 00:01:31.100
What if we wanted the variable
to be of character type,

00:01:31.100 --> 00:01:34.940
because it represents a single
character instead of a string type,

00:01:34.940 --> 00:01:37.060
which can represent multiple characters.

00:01:37.060 --> 00:01:39.080
Is there a way that we
can help Swift do this?

00:01:40.110 --> 00:01:42.480
Actually, there is, and here's how.

00:01:42.480 --> 00:01:44.650
We'll modify our
variable declaration and

00:01:44.650 --> 00:01:48.180
add a colon after the name, and
then specify the type that we want.

00:01:49.260 --> 00:01:52.710
So this is a slightly different
syntax than we saw before, but

00:01:52.710 --> 00:01:53.930
it removes the need for

00:01:53.930 --> 00:01:57.810
Swift to guess the variable's type
because we're explicitly stating it.

00:01:57.810 --> 00:01:59.270
In this case,
we want it to be a character.

00:01:59.270 --> 00:02:02.660
And when we take the guesswork
out of typing for

00:02:02.660 --> 00:02:06.040
Swift, we call this explicit typing.

00:02:06.040 --> 00:02:10.030
And if I use the option click, we can
see that this is now a character and

00:02:10.030 --> 00:02:10.850
no longer a string.

00:02:12.670 --> 00:02:16.340
In general, Swift does a great job at
inferring the types of our variables, so

00:02:16.340 --> 00:02:19.480
explicit typing is
usually not necessary.

00:02:19.480 --> 00:02:23.070
However, in some cases like this one,
you want to use explicit typing so

00:02:23.070 --> 00:02:26.610
that the compiler knows exactly what
type you intend for the variable.

