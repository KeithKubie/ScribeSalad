WEBVTT
Kind: captions
Language: en

00:00:00.750 --> 00:00:02.319
Welcome to this episode of UXD.

00:00:02.319 --> 00:00:04.610
This is the second episode
of a three-part series where

00:00:04.610 --> 00:00:07.330
we will focus on how to make
location-based information

00:00:07.330 --> 00:00:10.200
client simple and easy to
consume for users on the go who

00:00:10.200 --> 00:00:13.560
are using location-based
apps that use Maps.

00:00:13.560 --> 00:00:15.600
I'm your host, Nazmul
Idris, a developer

00:00:15.600 --> 00:00:18.360
advocate passionate
about design and mobile.

00:00:18.360 --> 00:00:20.240
In part one, I talked
about how important

00:00:20.240 --> 00:00:22.590
it is to understand
the user context when

00:00:22.590 --> 00:00:25.770
building and designing
location-based applications.

00:00:25.770 --> 00:00:27.710
Typically, research
and planning tasks

00:00:27.710 --> 00:00:29.430
are done on tablets and laptops.

00:00:29.430 --> 00:00:33.005
And smartphones tend to be used
on the go for execution tasks.

00:00:33.005 --> 00:00:34.380
And those users
using smartphones

00:00:34.380 --> 00:00:36.970
tend to be quite busy
doing other things,

00:00:36.970 --> 00:00:40.019
and they can be very
distracted as a result.

00:00:40.019 --> 00:00:42.310
Not only do we have to take
the human hand into account

00:00:42.310 --> 00:00:45.020
and optimize these interactions,
or the interaction designed

00:00:45.020 --> 00:00:47.220
for single-handed
use, we also have

00:00:47.220 --> 00:00:49.340
to take the user's
brain into account.

00:00:49.340 --> 00:00:51.810
We have to make sure that
our designs minimize,

00:00:51.810 --> 00:00:56.470
or reduce, the cognitive
load they place on the user.

00:00:56.470 --> 00:00:57.940
To get in the
right mindset, just

00:00:57.940 --> 00:01:00.440
picture yourself at an airport,
pulling a bag with one hand,

00:01:00.440 --> 00:01:02.440
trying to find a place
to get coffee on the way

00:01:02.440 --> 00:01:05.209
to your gate using
your smartphone.

00:01:05.209 --> 00:01:06.960
Now, let's pick
apart this use case.

00:01:06.960 --> 00:01:09.850
Let's say that you use
a location-based app

00:01:09.850 --> 00:01:12.200
at the airport to
search for coffee shops.

00:01:12.200 --> 00:01:14.990
And it returns too many
results that are nearby.

00:01:14.990 --> 00:01:16.820
How do you quickly
absorb this information

00:01:16.820 --> 00:01:19.070
and then select the right
coffee place for you?

00:01:19.070 --> 00:01:20.520
I mean, you're not just
using this application

00:01:20.520 --> 00:01:22.020
because you're bored
at the airport.

00:01:22.020 --> 00:01:24.974
You want your coffee now.

00:01:24.974 --> 00:01:26.890
So this is where managing
the user's attention

00:01:26.890 --> 00:01:27.730
comes into play.

00:01:27.730 --> 00:01:30.570
Their attention is a very
limited resource to begin with.

00:01:30.570 --> 00:01:33.100
And in this context-- which
is, they're distracted,

00:01:33.100 --> 00:01:35.390
there's a time crunch, and
they're in an airport--

00:01:35.390 --> 00:01:38.860
you can use even less of
it than you normally can.

00:01:38.860 --> 00:01:41.605
So to this end, don't clutter
the map with too many results.

00:01:41.605 --> 00:01:43.230
That is, don't present
too many results

00:01:43.230 --> 00:01:45.920
by showing too many
markers in the map view.

00:01:45.920 --> 00:01:47.780
The user has limited attention.

00:01:47.780 --> 00:01:50.010
They're distracted,
and so they should not

00:01:50.010 --> 00:01:51.780
be overwhelmed with
too many results

00:01:51.780 --> 00:01:54.580
that they will have
a hard time parsing.

00:01:54.580 --> 00:01:57.170
You don't want to confuse
abundance with choice.

00:01:57.170 --> 00:02:00.360
Choice is good--
abundance, not so much.

00:02:00.360 --> 00:02:02.020
If you have different
types of markers,

00:02:02.020 --> 00:02:03.900
make sure to give
a way for users

00:02:03.900 --> 00:02:05.380
to understand the differences.

00:02:05.380 --> 00:02:07.070
It's important to
give the user context

00:02:07.070 --> 00:02:10.669
around what each type of
marker actually means.

00:02:10.669 --> 00:02:13.470
And also, don't put too much
information on the map itself.

00:02:13.470 --> 00:02:14.970
This makes it
difficult for the user

00:02:14.970 --> 00:02:18.070
to touch a specific marker,
especially with thumbs.

00:02:18.070 --> 00:02:20.570
The minimum touch
target should be 48 dps,

00:02:20.570 --> 00:02:24.280
but also allocate some space
for padding around each marker.

00:02:24.280 --> 00:02:26.020
And don't pack too
much information

00:02:26.020 --> 00:02:27.410
into an info window.

00:02:27.410 --> 00:02:28.970
The info window
shows the details

00:02:28.970 --> 00:02:32.690
of a place represented
by a pushpin on the map.

00:02:32.690 --> 00:02:35.480
So how do you balance the
need to display many results

00:02:35.480 --> 00:02:37.940
with the need to consume as
little of the user's attention

00:02:37.940 --> 00:02:39.400
as possible?

00:02:39.400 --> 00:02:41.370
Now, allowing the
user to filter results

00:02:41.370 --> 00:02:43.370
is a great way to give
them the information they

00:02:43.370 --> 00:02:45.620
need without overwhelming
their divided

00:02:45.620 --> 00:02:48.280
attention with too many results.

00:02:48.280 --> 00:02:51.000
For example, let's say you have
a location-based travel app.

00:02:51.000 --> 00:02:54.470
Some filtering fields might
include price, proximity,

00:02:54.470 --> 00:02:55.810
availability, and rating.

00:02:55.810 --> 00:02:58.670
So you might have to adapt
what these fields are based

00:02:58.670 --> 00:03:02.350
on the type of location-based
app that you're building.

00:03:02.350 --> 00:03:05.430
You can use the action bar
to provide them with access

00:03:05.430 --> 00:03:07.030
to this filtering capability.

00:03:07.030 --> 00:03:09.730
And this allows them to
slice and dice the results

00:03:09.730 --> 00:03:14.000
by their desired fields, which
gives them choice and control.

00:03:14.000 --> 00:03:16.300
This also frees up the
application service area

00:03:16.300 --> 00:03:19.180
for content and allows you
to present as large of a map

00:03:19.180 --> 00:03:21.814
as possible, which
is a good thing.

00:03:21.814 --> 00:03:23.230
Yet another advantage
of filtering

00:03:23.230 --> 00:03:25.210
is that it restricts
the number of markers

00:03:25.210 --> 00:03:26.760
that are displayed on the map.

00:03:26.760 --> 00:03:29.760
This makes it possible for a
user to actually see the map

00:03:29.760 --> 00:03:31.950
and visually recognize
where they are

00:03:31.950 --> 00:03:35.280
and where places on the
map are in the real world.

00:03:35.280 --> 00:03:39.910
Big maps work hand in
hand with this as well.

00:03:39.910 --> 00:03:42.660
Finally, reducing
the number of markers

00:03:42.660 --> 00:03:45.760
removes the occlusion of
underlying info in the base

00:03:45.760 --> 00:03:50.010
map, like streets, bridges,
neighborhoods and so on.

00:03:50.010 --> 00:03:52.570
Another way to reduce clutter
and respect the user's

00:03:52.570 --> 00:03:55.330
attention is to sort
the results by relevance

00:03:55.330 --> 00:03:57.550
and emphasize the
most relevant ones

00:03:57.550 --> 00:04:00.780
while deemphasizing the
less important ones.

00:04:00.780 --> 00:04:02.780
For example, the user
searches for coffee shops

00:04:02.780 --> 00:04:04.050
in your location-based app.

00:04:04.050 --> 00:04:06.130
You can sort the
results by proximity,

00:04:06.130 --> 00:04:11.650
and then highlight the
top result in a big way.

00:04:11.650 --> 00:04:14.200
And then the next 10 results
might be clumped together

00:04:14.200 --> 00:04:18.240
and shown with smaller markers,
so deemphasized a little bit.

00:04:18.240 --> 00:04:19.740
And finally, the
rest of the results

00:04:19.740 --> 00:04:21.420
might be shown with
really small markers

00:04:21.420 --> 00:04:23.170
to really deemphasize them.

00:04:23.170 --> 00:04:24.920
So while these results
are irrelevant,

00:04:24.920 --> 00:04:28.210
they might be useful for
context around the search.

00:04:28.210 --> 00:04:30.030
So a user can
deduce, for example,

00:04:30.030 --> 00:04:32.280
that there's a lot of
shops at the location where

00:04:32.280 --> 00:04:34.940
the results are clumped.

00:04:34.940 --> 00:04:37.320
You can also allow the user
to provide their own criteria

00:04:37.320 --> 00:04:41.020
for sorting as well, similar
to what you do for filtering.

00:04:41.020 --> 00:04:42.860
The difference between
sorting and filtering

00:04:42.860 --> 00:04:45.150
is that sorting does
not remove any results,

00:04:45.150 --> 00:04:47.310
whereas filtering might.

00:04:47.310 --> 00:04:48.820
So you want to use both.

00:04:48.820 --> 00:04:52.470
So additionally, when the
user selects a result,

00:04:52.470 --> 00:04:55.510
try using a ViewPager to
display more information

00:04:55.510 --> 00:04:56.570
on that marker.

00:04:56.570 --> 00:04:59.390
This is better than popping up
an info window or a dialogue

00:04:59.390 --> 00:05:01.775
that hovers in front
of the UI and obscures

00:05:01.775 --> 00:05:04.800
the results behind it.

00:05:04.800 --> 00:05:07.310
In this ViewPager, you can
allow the user to cycle

00:05:07.310 --> 00:05:09.770
through the results simply
by swiping back and forth

00:05:09.770 --> 00:05:11.290
on the bottom of the screen.

00:05:11.290 --> 00:05:14.280
And this makes it really easy
to navigate the sorted results.

00:05:14.280 --> 00:05:17.990
And as a bonus, it works for
single-handed use as well.

00:05:17.990 --> 00:05:20.580
One other way to reduce
clutter and deliver

00:05:20.580 --> 00:05:23.290
glanceable information to the
user is to use clustering.

00:05:23.290 --> 00:05:24.469
What's clustering?

00:05:24.469 --> 00:05:26.260
This is where nearby
and overlapping places

00:05:26.260 --> 00:05:28.510
are actually combined
together into a single icon

00:05:28.510 --> 00:05:30.650
showing the number of
results contained in it

00:05:30.650 --> 00:05:34.460
rather than drawing
one marker per result.

00:05:34.460 --> 00:05:37.880
It's a visual cue to the user
to drill down into and get more

00:05:37.880 --> 00:05:39.917
information on the
individual results.

00:05:39.917 --> 00:05:42.250
And this has the added benefit
of not obscuring the base

00:05:42.250 --> 00:05:45.140
map and the detailed information
the base map contains,

00:05:45.140 --> 00:05:47.100
which is a good thing.

00:05:47.100 --> 00:05:50.050
This is great for showing the
user where these results are

00:05:50.050 --> 00:05:52.219
tightly correlated to
an actual location.

00:05:52.219 --> 00:05:53.760
For example, if you
search for hotels

00:05:53.760 --> 00:05:56.404
in San Francisco in a
location-based travel app,

00:05:56.404 --> 00:05:58.070
you will see lots of
grouping of results

00:05:58.070 --> 00:06:00.000
in North Beach, which
might signal to the user

00:06:00.000 --> 00:06:02.430
that it's a good tourist spot.

00:06:02.430 --> 00:06:04.850
Now, clustering does
not replace the need

00:06:04.850 --> 00:06:08.290
for emphasizing or deemphasizing
or sorting and filtering.

00:06:08.290 --> 00:06:10.570
All these techniques
should be used together.

00:06:10.570 --> 00:06:13.860
And as a bonus, you can use the
Google Maps Android API utility

00:06:13.860 --> 00:06:17.780
library in order to
implement clustering.

00:06:17.780 --> 00:06:19.960
Finally, you can use a
variety of different marker

00:06:19.960 --> 00:06:22.960
types, colors, and even overlays
to convey extra information

00:06:22.960 --> 00:06:24.524
to your users at a glance.

00:06:24.524 --> 00:06:26.690
You can use colors and
objects to convey information

00:06:26.690 --> 00:06:27.935
about a place.

00:06:27.935 --> 00:06:30.060
You can provide information
overlaid on the markers

00:06:30.060 --> 00:06:30.710
themselves.

00:06:30.710 --> 00:06:34.480
For example, in a
location-based travel app,

00:06:34.480 --> 00:06:36.530
you can actually display
the price of hotel rooms

00:06:36.530 --> 00:06:41.050
nearby by actually writing that
on top of the marker itself.

00:06:41.050 --> 00:06:44.940
Now, make sure to provide
a key that the users can

00:06:44.940 --> 00:06:47.370
use to understand what these
different colors and objects

00:06:47.370 --> 00:06:49.504
actually mean.

00:06:49.504 --> 00:06:50.920
That's all the
time we have today.

00:06:50.920 --> 00:06:52.642
In the next episode,
part three, I'll

00:06:52.642 --> 00:06:54.350
talk about the
environmental factors that

00:06:54.350 --> 00:06:57.370
might affect the UX that
you should keep in mind when

00:06:57.370 --> 00:07:01.300
designing and building great
location-based applications.

00:07:01.300 --> 00:07:03.660
If you haven't already,
please be sure to join our UX

00:07:03.660 --> 00:07:05.170
community on Google+.

00:07:05.170 --> 00:07:07.297
It's a place where we can
continue this discussion,

00:07:07.297 --> 00:07:09.630
and you can meet other people
who are just as passionate

00:07:09.630 --> 00:07:11.500
at user experience as you are.

00:07:11.500 --> 00:07:13.294
Thanks for watching and goodbye.

