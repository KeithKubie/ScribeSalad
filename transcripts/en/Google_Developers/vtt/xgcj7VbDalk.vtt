WEBVTT
Kind: captions
Language: en

00:00:07.412 --> 00:00:08.370
WALEED KADOUS: Welcome.

00:00:08.370 --> 00:00:11.179
My name's Waleed Kadous, and
with me is Marc Stogaitis.

00:00:11.179 --> 00:00:13.470
We're members of the Android
Location and Context team,

00:00:13.470 --> 00:00:15.990
and we're super excited to
be talking to you, today,

00:00:15.990 --> 00:00:18.580
about how to make your
apps context aware.

00:00:18.580 --> 00:00:21.350
And we're going to explain why
we think now is the right time

00:00:21.350 --> 00:00:24.050
to do it, some of the tools
that are available to help you

00:00:24.050 --> 00:00:26.140
do it, some things
to watch out for,

00:00:26.140 --> 00:00:27.600
and, finally,
something I'm really

00:00:27.600 --> 00:00:29.750
excited to do with
you, today, which

00:00:29.750 --> 00:00:31.890
is to share a vision of
what the future will hold

00:00:31.890 --> 00:00:33.056
as far as this is concerned.

00:00:36.410 --> 00:00:38.040
Next slide.

00:00:38.040 --> 00:00:40.140
I want you to
imagine that, instead

00:00:40.140 --> 00:00:42.480
of presenting at
Google I/O 2015,

00:00:42.480 --> 00:00:45.240
I'm presenting at
Google I/O 2020.

00:00:45.240 --> 00:00:48.030
I want to describe to you
what my day so far has

00:00:48.030 --> 00:00:53.020
been like making it here
to go Google I/O 2020.

00:00:53.020 --> 00:00:55.760
I'm sleeping comfortably
in my bed in my house.

00:00:55.760 --> 00:00:57.650
And my phone alarm goes off.

00:00:57.650 --> 00:00:59.390
And it's not that I
programmed my phone

00:00:59.390 --> 00:01:01.200
to go off at that
particular time,

00:01:01.200 --> 00:01:03.540
it just knew that was the
right time to wake me up.

00:01:03.540 --> 00:01:05.489
It knew I had a
late night before.

00:01:05.489 --> 00:01:08.054
It knows the traffic it
will take to get to Moscone.

00:01:08.054 --> 00:01:10.220
It knows that I like to
have showers in the morning.

00:01:10.220 --> 00:01:12.790
So all I said to it the
night before was wake me up

00:01:12.790 --> 00:01:14.086
in the morning.

00:01:14.086 --> 00:01:15.710
Now I pick up my
phone, and, of course,

00:01:15.710 --> 00:01:18.430
it's automatically unlocked
because it knows exactly who I

00:01:18.430 --> 00:01:20.340
am, and it knew that it
spent the whole night

00:01:20.340 --> 00:01:21.210
next to the bed.

00:01:21.210 --> 00:01:24.200
But even before
I've got out of bed,

00:01:24.200 --> 00:01:26.020
the house has started
to come alive.

00:01:26.020 --> 00:01:30.150
My room has decided to warm
up to a comfy 72 degrees.

00:01:30.150 --> 00:01:33.364
The lights are slowly coming
up to welcome me into the day.

00:01:33.364 --> 00:01:34.780
And of course, the
coffee maker is

00:01:34.780 --> 00:01:36.988
going because who knows
where we'd be without coffee.

00:01:39.490 --> 00:01:42.250
As I sit down in
front of my breakfast,

00:01:42.250 --> 00:01:44.050
my tablet is there
waiting for me.

00:01:44.050 --> 00:01:47.110
As soon as I sit down in front
of it, the content for the day

00:01:47.110 --> 00:01:49.520
appears, all my events,
all the exciting talks

00:01:49.520 --> 00:01:52.360
I'm looking forward to at
Google I/O. And not just

00:01:52.360 --> 00:01:54.300
that, it's suggested
some activities for me

00:01:54.300 --> 00:01:56.880
that it knows about
what I'm interested in.

00:01:56.880 --> 00:01:58.732
So for example, it
knows I love Asian art.

00:01:58.732 --> 00:02:00.190
It knows that I'm
in San Francisco.

00:02:00.190 --> 00:02:02.460
And it knows that
the Asian Art Museum

00:02:02.460 --> 00:02:04.890
is open late on Thursday
nights, which it is.

00:02:04.890 --> 00:02:07.500
You guys should go check it out.

00:02:07.500 --> 00:02:09.919
But it put all of
that together for me

00:02:09.919 --> 00:02:12.430
so that I can just see
the day ahead of me.

00:02:12.430 --> 00:02:15.580
And just as I'm finishing
checking out stuff,

00:02:15.580 --> 00:02:16.670
my housemate joins me.

00:02:16.670 --> 00:02:19.020
And he's also enjoying
his morning coffee.

00:02:19.020 --> 00:02:20.830
And as we're sitting
there, just as we're

00:02:20.830 --> 00:02:22.800
finishing the cup
of coffee, we get

00:02:22.800 --> 00:02:26.340
a buzz that says that our car
is waiting for us downstairs.

00:02:26.340 --> 00:02:27.810
And sure enough,
we go downstairs,

00:02:27.810 --> 00:02:30.220
and waiting for us is
our self-driving car.

00:02:30.220 --> 00:02:33.810
We hop inside, excited about
where we're going to go, today.

00:02:33.810 --> 00:02:35.730
And we notice that
the music comes on.

00:02:35.730 --> 00:02:37.770
And the music is
specially selected.

00:02:37.770 --> 00:02:41.380
It just happens to be the music
that both me and my housemate

00:02:41.380 --> 00:02:42.070
like.

00:02:42.070 --> 00:02:46.130
And to be frank, that level
of overlap is not so large.

00:02:46.130 --> 00:02:47.970
We'll talk about
that another time.

00:02:47.970 --> 00:02:51.960
And then just as soon
as it gets to Moscone,

00:02:51.960 --> 00:02:54.090
I notice that my watch buzzes.

00:02:54.090 --> 00:02:56.090
And on my watch, I
notice that there's

00:02:56.090 --> 00:02:59.557
a map that takes me
directly from the curbside

00:02:59.557 --> 00:03:01.390
in through the front
door, which of course I

00:03:01.390 --> 00:03:03.820
don't need to swipe my badge
or anything because my watch

00:03:03.820 --> 00:03:05.810
already knows who I am,
and I can share that

00:03:05.810 --> 00:03:08.020
with the devices around me.

00:03:08.020 --> 00:03:12.030
And it takes me up the
stairs, turn left, turn right.

00:03:12.030 --> 00:03:14.144
And as I come to
the auditorium, I

00:03:14.144 --> 00:03:16.060
get a buzz from my friend
that says that she's

00:03:16.060 --> 00:03:17.000
sitting in the audience.

00:03:17.000 --> 00:03:18.124
She's coming from New York.

00:03:18.124 --> 00:03:20.030
I don't get a chance
to see her very often.

00:03:20.030 --> 00:03:22.940
And my phone guides me directly
to where she's sitting down.

00:03:22.940 --> 00:03:24.040
I sit down next to her.

00:03:24.040 --> 00:03:25.670
We get a chance to catch up.

00:03:25.670 --> 00:03:27.949
And we're ready to take
in a day full of knowledge

00:03:27.949 --> 00:03:29.490
and exciting
information about what's

00:03:29.490 --> 00:03:33.140
happening at Google I/O 2020.

00:03:33.140 --> 00:03:36.490
Now the question
in all of this is,

00:03:36.490 --> 00:03:39.710
that sounds a little bit
sci-fi, a little bit crazy,

00:03:39.710 --> 00:03:41.920
but I want you to
disassemble that.

00:03:41.920 --> 00:03:44.830
And I want you to think
about the interactions

00:03:44.830 --> 00:03:47.440
between the device and the
user as this whole experience

00:03:47.440 --> 00:03:48.440
happened.

00:03:48.440 --> 00:03:51.300
I want you to think about how
many unnecessary interactions

00:03:51.300 --> 00:03:52.470
were avoided.

00:03:52.470 --> 00:03:55.750
I want you to think
about how many times

00:03:55.750 --> 00:03:59.760
the system reminded
me, in context, when

00:03:59.760 --> 00:04:02.120
it was useful to me; and
how it brought new knowledge

00:04:02.120 --> 00:04:04.570
to my fingertips that I
didn't really even ask for,

00:04:04.570 --> 00:04:07.040
but I knew that it
was very useful;

00:04:07.040 --> 00:04:08.790
and how it was able
to enrich my life,

00:04:08.790 --> 00:04:11.320
by letting me sleep in
for the maximum amount

00:04:11.320 --> 00:04:13.890
by making me feel more
comfortable in the morning

00:04:13.890 --> 00:04:16.390
instead of a rude awakening.

00:04:16.390 --> 00:04:18.790
So I really think that
those components there

00:04:18.790 --> 00:04:22.050
that we mentioned, that type
of simplification of a person's

00:04:22.050 --> 00:04:25.520
life, that simplification of
interactions, those things we

00:04:25.520 --> 00:04:28.370
can build, today-- there's
no obstacle to us doing that.

00:04:28.370 --> 00:04:30.380
And what I'm going to
try to convince you of

00:04:30.380 --> 00:04:33.000
is that, not only
is it possible,

00:04:33.000 --> 00:04:35.530
we already have some
applications that we've built,

00:04:35.530 --> 00:04:37.090
and some other
people have built,

00:04:37.090 --> 00:04:39.970
that show these type of
contextual experiences.

00:04:39.970 --> 00:04:42.150
And let me explain to
you why I think now

00:04:42.150 --> 00:04:45.220
is the perfect time to do it.

00:04:45.220 --> 00:04:48.065
We have in our pockets
an amazing platform.

00:04:50.637 --> 00:04:52.970
Sometimes we're so involved
in the day to day of things,

00:04:52.970 --> 00:04:55.160
we don't take a step
back to just think

00:04:55.160 --> 00:04:58.160
about how amazingly
powerful our platforms are.

00:04:58.160 --> 00:05:01.490
So inside your
phone is a processor

00:05:01.490 --> 00:05:05.070
that can process 8 billion
computations a second.

00:05:05.070 --> 00:05:07.510
Not only that, but
it's full of sensors.

00:05:07.510 --> 00:05:10.490
It's got accelerometers, and
gyroscopes, and barometer,

00:05:10.490 --> 00:05:12.600
and magnetometers.

00:05:12.600 --> 00:05:14.930
Some phones even have
humidity sensors.

00:05:14.930 --> 00:05:17.450
But that's never really
happened before-- that we've

00:05:17.450 --> 00:05:19.740
had that level of
sensors available with us

00:05:19.740 --> 00:05:22.662
in that way in an
always-on fashion.

00:05:22.662 --> 00:05:24.870
And we can use those sensors,
like the accelerometer,

00:05:24.870 --> 00:05:26.810
to determine things
about the user's context,

00:05:26.810 --> 00:05:28.810
like if they're running,
or walking, or driving,

00:05:28.810 --> 00:05:29.960
or cycling.

00:05:29.960 --> 00:05:31.730
There's also other
rich sensors on there,

00:05:31.730 --> 00:05:33.896
like the camera and the
microphone, that can pick up

00:05:33.896 --> 00:05:35.790
cues that we can use.

00:05:35.790 --> 00:05:39.800
And combine that with the
huge variety of techniques

00:05:39.800 --> 00:05:42.400
available for
communication, like cell,

00:05:42.400 --> 00:05:46.172
and Bluetooth, and
Wi-Fi, and GPS.

00:05:46.172 --> 00:05:48.630
And GPS, when you think about
it, it's kind of a little bit

00:05:48.630 --> 00:05:49.230
crazy.

00:05:49.230 --> 00:05:51.030
It allows us to talk
to a satellite that's

00:05:51.030 --> 00:05:54.350
20,000 kilometers away
to work out where we are.

00:05:54.350 --> 00:05:56.960
So we have to ask ourselves,
have we really taken

00:05:56.960 --> 00:06:00.610
full advantage of this platform
in terms of really relieving

00:06:00.610 --> 00:06:03.440
the pressure off the
user in terms of memory,

00:06:03.440 --> 00:06:05.390
in terms of simplifying
their lives,

00:06:05.390 --> 00:06:07.330
and easing the interaction?

00:06:07.330 --> 00:06:09.270
And I think the answer
is that, right now, we

00:06:09.270 --> 00:06:13.980
have this very, very large
opportunity ahead of us.

00:06:13.980 --> 00:06:16.070
Basically, in the
history of computing,

00:06:16.070 --> 00:06:19.250
we've never had this
combination of sensors,

00:06:19.250 --> 00:06:21.220
communication, and
computing power.

00:06:21.220 --> 00:06:24.110
And we can use that power,
those sensors, that ability

00:06:24.110 --> 00:06:28.571
to talk to devices nearby, to
understand the user's context.

00:06:28.571 --> 00:06:30.570
I think all of you can
think back to the keynote

00:06:30.570 --> 00:06:32.778
and what [? Aparna ?] was
telling us about Google Now

00:06:32.778 --> 00:06:34.330
as an example of this.

00:06:34.330 --> 00:06:36.830
And we can use this idea
of understanding the user's

00:06:36.830 --> 00:06:39.110
context to simplify
interactions,

00:06:39.110 --> 00:06:41.280
to augment human
memory, and knowledge,

00:06:41.280 --> 00:06:46.040
and also, to make people's
lives just a little bit better.

00:06:46.040 --> 00:06:47.740
When I think about
simpler interaction,

00:06:47.740 --> 00:06:50.710
I just think back to the
broken model we have.

00:06:50.710 --> 00:06:53.640
One of our primary means of
interactions with devices

00:06:53.640 --> 00:06:55.870
is that we took a 19th
century technology, which

00:06:55.870 --> 00:06:59.830
is the typewriter, which
was used to bang letters

00:06:59.830 --> 00:07:02.680
onto a page, and we
shrunk it down, and tried

00:07:02.680 --> 00:07:04.550
to get it into a phone.

00:07:04.550 --> 00:07:06.050
And that's the
metaphor that we use.

00:07:06.050 --> 00:07:07.280
There's got to be a better way.

00:07:07.280 --> 00:07:09.590
And we should be able to use
the sensors on the device

00:07:09.590 --> 00:07:14.400
to help take that load to use
those keyboards off the user.

00:07:14.400 --> 00:07:16.260
So where we're going
to go from here

00:07:16.260 --> 00:07:19.140
is we want to walk you through
our experiences building

00:07:19.140 --> 00:07:21.380
these types of systems.

00:07:21.380 --> 00:07:23.864
But this technology
is still very new.

00:07:23.864 --> 00:07:25.530
So there's a couple
of things-- in fact,

00:07:25.530 --> 00:07:26.946
to be exact, three
things that you

00:07:26.946 --> 00:07:29.140
need to pay very
careful attention to.

00:07:29.140 --> 00:07:31.980
And finally, I want to map
out what the future might

00:07:31.980 --> 00:07:34.850
look like between
here and 2020--

00:07:34.850 --> 00:07:37.140
that Google I/O talk that
I hope to see all of you

00:07:37.140 --> 00:07:39.787
at in the future and be
here, presenting again.

00:07:39.787 --> 00:07:41.370
And with that, I'll
hand over to Marc,

00:07:41.370 --> 00:07:45.950
who will walk us through
some of these experiences.

00:07:45.950 --> 00:07:47.610
MARC STOGAITIS: Thanks, Waleed.

00:07:47.610 --> 00:07:49.770
So Waleed described the
power of modern cellphones.

00:07:49.770 --> 00:07:52.810
And he also set the stage for
what 2020 might look like.

00:07:52.810 --> 00:07:55.670
What I'm hoping to do is to
show you what's possible, today.

00:07:55.670 --> 00:07:57.711
I think a good example is
something that happened

00:07:57.711 --> 00:07:59.326
to me a couple of months ago.

00:07:59.326 --> 00:08:00.700
As I was driving
to a restaurant,

00:08:00.700 --> 00:08:03.110
I used Google Maps
to help me navigate.

00:08:03.110 --> 00:08:05.450
And after I parked, I
walked over to the building.

00:08:05.450 --> 00:08:07.250
And just as I walked
in, I realized

00:08:07.250 --> 00:08:09.545
that I didn't pay attention
to where I parked my car.

00:08:09.545 --> 00:08:11.670
That's a terrible feeling
that I'm sure some of you

00:08:11.670 --> 00:08:13.266
have experienced before.

00:08:13.266 --> 00:08:14.640
Luckily, I was
able to swipe over

00:08:14.640 --> 00:08:17.790
to Google Now, which had a card
indicating the last location

00:08:17.790 --> 00:08:19.570
of where I parked my car.

00:08:19.570 --> 00:08:21.320
I think that's a great
example of the type

00:08:21.320 --> 00:08:23.830
of contextual experiences
that can be built, today.

00:08:23.830 --> 00:08:26.914
And I'd like to show
you how to build these.

00:08:26.914 --> 00:08:29.080
So usually context is broken
down into three layers.

00:08:29.080 --> 00:08:30.650
We start by taking
sensor data, like

00:08:30.650 --> 00:08:32.669
that of an
accelerometer or Wi-Fi,

00:08:32.669 --> 00:08:35.780
and then build algorithms on top
of these, which take raw sensor

00:08:35.780 --> 00:08:37.770
data, and turn it into
higher level signals,

00:08:37.770 --> 00:08:40.006
like location or user activity.

00:08:40.006 --> 00:08:41.380
And finally, we
use those signals

00:08:41.380 --> 00:08:42.825
to build features in apps.

00:08:42.825 --> 00:08:44.950
So let's look at these
three layers in a little bit

00:08:44.950 --> 00:08:47.100
more details.

00:08:47.100 --> 00:08:49.240
Context starts with sensors.

00:08:49.240 --> 00:08:51.240
Sensors are what allow
our devices to understand

00:08:51.240 --> 00:08:52.339
the world around them.

00:08:52.339 --> 00:08:54.380
They allow them to break
out of the digital world

00:08:54.380 --> 00:08:57.605
and into the physical world, the
world that you and I live in.

00:08:57.605 --> 00:08:59.480
And I think a good way
to think about context

00:08:59.480 --> 00:09:02.254
and sensors in general is
to think about human senses,

00:09:02.254 --> 00:09:03.920
since we're really
good at understanding

00:09:03.920 --> 00:09:05.775
the environment around us.

00:09:05.775 --> 00:09:07.400
And building up the
strong mental model

00:09:07.400 --> 00:09:09.970
of how sensors work is important
because a lot of context

00:09:09.970 --> 00:09:11.332
is built on top of these.

00:09:11.332 --> 00:09:13.040
So something that's
helped me with this--

00:09:13.040 --> 00:09:14.456
it's also a little
bit of fun-- is

00:09:14.456 --> 00:09:17.510
to ask myself, what if I
had Android sensors instead

00:09:17.510 --> 00:09:19.000
of human senses.

00:09:19.000 --> 00:09:21.830
How would I perceive
the world around me?

00:09:21.830 --> 00:09:25.330
Well, I'd see with a camera, a
light, and a proximity sensor.

00:09:25.330 --> 00:09:26.970
I'd hear with a microphone.

00:09:26.970 --> 00:09:30.090
And I'd keep my balance with an
accelerometer and a gyroscope.

00:09:30.090 --> 00:09:32.960
And I would use these sensors to
understand the world around me

00:09:32.960 --> 00:09:35.770
and make decisions
based on what I see.

00:09:35.770 --> 00:09:37.170
As a human, I'm pretty lucky.

00:09:37.170 --> 00:09:39.610
My brain takes care of all
this sensor processing for me.

00:09:39.610 --> 00:09:42.960
But how could we
do it on Android?

00:09:42.960 --> 00:09:45.590
Well, algorithms need to be
built on top of raw sensor data

00:09:45.590 --> 00:09:47.900
to make sense of what's
happening in the real world.

00:09:47.900 --> 00:09:49.600
And there are many
challenges here.

00:09:49.600 --> 00:09:52.058
We have to come up with ways
of fusing noisy, and sometimes

00:09:52.058 --> 00:09:53.762
conflicting, sensor data.

00:09:53.762 --> 00:09:55.970
We have to put together
large data sets that allow us

00:09:55.970 --> 00:09:57.802
to train and fine tune models.

00:09:57.802 --> 00:10:00.260
We also have to come up with
ways of enabling and disabling

00:10:00.260 --> 00:10:04.280
different sensors so that we
can manage power consumption.

00:10:04.280 --> 00:10:06.750
Luckily, we've tried to make
this as easy as possible.

00:10:06.750 --> 00:10:08.460
So we've built several
Android services

00:10:08.460 --> 00:10:10.300
that take raw sensor
data and turn it

00:10:10.300 --> 00:10:12.600
into contextual information.

00:10:12.600 --> 00:10:14.770
These include the Activity
Recognition, Places,

00:10:14.770 --> 00:10:17.277
Geofencing, the the Fused
Location Provider APIs.

00:10:17.277 --> 00:10:19.360
I'll talk about these in
a little bit more details

00:10:19.360 --> 00:10:20.690
in just a little while.

00:10:20.690 --> 00:10:22.070
So the key takeaway
is that these

00:10:22.070 --> 00:10:25.120
allow you to receive context
information in your apps

00:10:25.120 --> 00:10:27.060
with just a few lines of code.

00:10:27.060 --> 00:10:29.140
All the processing is
handled under the hood

00:10:29.140 --> 00:10:31.890
so you get to focus on what
really matters, which is a user

00:10:31.890 --> 00:10:34.170
experience in your apps.

00:10:34.170 --> 00:10:36.380
A context can sometimes
be a little bit abstract,

00:10:36.380 --> 00:10:39.084
so my goal for today is to make
it as concrete as possible.

00:10:39.084 --> 00:10:40.500
And to do that,
I'll try something

00:10:40.500 --> 00:10:42.290
we haven't done before,
which is to take

00:10:42.290 --> 00:10:44.850
launched Google products
that make use of context

00:10:44.850 --> 00:10:47.260
and show you a behind the
scenes look at how they work,

00:10:47.260 --> 00:10:49.980
so which APIs they use,
how those APIs work,

00:10:49.980 --> 00:10:51.172
even which sensors they use.

00:10:51.172 --> 00:10:53.380
Hopefully, this will help
illustrate what's possible,

00:10:53.380 --> 00:10:55.350
today.

00:10:55.350 --> 00:10:56.707
So let's start with Smart Lock.

00:10:56.707 --> 00:10:58.290
When I went home for
Christmas, my mom

00:10:58.290 --> 00:11:00.940
asked me to enable a
password on her device.

00:11:00.940 --> 00:11:04.062
She saw that I was using a
swipe to unlock my phone.

00:11:04.062 --> 00:11:05.520
And after about a
couple of months,

00:11:05.520 --> 00:11:09.197
she emailed me and said,
how do I disable this.

00:11:09.197 --> 00:11:10.780
Basically, she found
that having to do

00:11:10.780 --> 00:11:12.904
this every single time she
needed to use her device

00:11:12.904 --> 00:11:14.580
was just too cumbersome.

00:11:14.580 --> 00:11:16.840
So everyone will weigh the
pros and cons of security

00:11:16.840 --> 00:11:18.970
versus convenience a
little bit differently.

00:11:18.970 --> 00:11:20.956
But this exposed an
underlying problem.

00:11:20.956 --> 00:11:22.580
When it comes to
unlocking your device,

00:11:22.580 --> 00:11:24.020
there are only
really two options.

00:11:24.020 --> 00:11:26.000
You either disable
security completely,

00:11:26.000 --> 00:11:28.350
or you enable it and have to
perform some kind of action

00:11:28.350 --> 00:11:30.610
every single time
you use your phone.

00:11:30.610 --> 00:11:34.469
So is there something-- can we
sensors to make this better?

00:11:34.469 --> 00:11:36.510
It turns out there's a
lot that can be done here.

00:11:36.510 --> 00:11:38.930
And one example is
on-body detection.

00:11:38.930 --> 00:11:40.660
So the idea behind
this is pretty simple.

00:11:40.660 --> 00:11:42.951
If you're using your phone,
and you put in your pocket,

00:11:42.951 --> 00:11:45.600
and you walk around for a while,
when you take it out again,

00:11:45.600 --> 00:11:46.900
it should still be unlocked.

00:11:46.900 --> 00:11:48.274
Your phone should
be smart enough

00:11:48.274 --> 00:11:51.020
to know it's been in your
continuous possession.

00:11:51.020 --> 00:11:54.060
So how do we make
something like that work?

00:11:54.060 --> 00:11:55.800
Well, it starts with
accelerometer data.

00:11:55.800 --> 00:11:58.650
So as you see here, on the
left is the accelerometer

00:11:58.650 --> 00:12:00.764
coming from a phone
that's in a user's pocket.

00:12:00.764 --> 00:12:02.680
On the right is a phone
that's just on a desk,

00:12:02.680 --> 00:12:03.900
not on the user.

00:12:03.900 --> 00:12:06.600
So you can visually tell that
they're pretty different.

00:12:06.600 --> 00:12:08.370
Even if a person is
sitting fairly still,

00:12:08.370 --> 00:12:09.745
there will still
be micro-motions

00:12:09.745 --> 00:12:11.777
that can be detected over time.

00:12:11.777 --> 00:12:13.360
But is this enough
to build something,

00:12:13.360 --> 00:12:15.200
like on-body detection?

00:12:15.200 --> 00:12:16.280
Well, not quite.

00:12:16.280 --> 00:12:18.750
When it comes to context, there
are usually many real world

00:12:18.750 --> 00:12:20.650
variations to deal with.

00:12:20.650 --> 00:12:22.260
One of the problems
that came up was

00:12:22.260 --> 00:12:24.032
that, let's say you're
sitting in a cab

00:12:24.032 --> 00:12:25.740
and your phone slides
out of your pocket,

00:12:25.740 --> 00:12:27.573
we need to know that
it's not on you anymore

00:12:27.573 --> 00:12:29.000
so that we can lock it.

00:12:29.000 --> 00:12:32.472
But the Excel that comes out
of a phone that's in the car

00:12:32.472 --> 00:12:34.680
looks extremely different
than that of a phone that's

00:12:34.680 --> 00:12:36.132
just sitting on a desk.

00:12:36.132 --> 00:12:37.840
So we needed something
that could tell us

00:12:37.840 --> 00:12:40.090
that the phone was in a
vehicle so that we could train

00:12:40.090 --> 00:12:42.750
situation specific models.

00:12:42.750 --> 00:12:44.370
In comes the Activity
Recognition API.

00:12:44.370 --> 00:12:46.830
And it's the first context
API I'd like to introduce.

00:12:46.830 --> 00:12:49.210
It works by fusing
sensor data to detect

00:12:49.210 --> 00:12:52.060
the user's current activity.

00:12:52.060 --> 00:12:56.070
The way it works-- we took
some accelerometer data

00:12:56.070 --> 00:12:58.290
and used machine learning
on top of that data

00:12:58.290 --> 00:13:00.627
to try and predict the
user's current activity.

00:13:00.627 --> 00:13:02.210
We've also added new
signals recently,

00:13:02.210 --> 00:13:04.580
like the use of Bluetooth,
and trained new models

00:13:04.580 --> 00:13:06.100
to make the
detections run faster

00:13:06.100 --> 00:13:08.249
and also improve the accuracy.

00:13:08.249 --> 00:13:10.790
So let's look a little bit at
how it works behind the scenes.

00:13:10.790 --> 00:13:13.206
So what we did is we asked
Google employees to record over

00:13:13.206 --> 00:13:15.162
65,000 sensor traces
where they would

00:13:15.162 --> 00:13:16.620
label the activity
they were doing,

00:13:16.620 --> 00:13:18.380
as well as the carry position.

00:13:18.380 --> 00:13:20.120
So they'd say
something like, I'm

00:13:20.120 --> 00:13:22.400
on a motorcycle and the
phone's in my backpack,

00:13:22.400 --> 00:13:25.320
and label and
gather sensor data.

00:13:25.320 --> 00:13:27.750
And we then extracted
features from that sensor data

00:13:27.750 --> 00:13:29.870
and trained machine
learning models

00:13:29.870 --> 00:13:32.740
that could predict the
user's current activity.

00:13:32.740 --> 00:13:35.685
After that, we took
those models and made

00:13:35.685 --> 00:13:38.060
them run directly on the phone
without needing any server

00:13:38.060 --> 00:13:38.990
interaction.

00:13:38.990 --> 00:13:40.820
This saves battery,
bandwidth, and also

00:13:40.820 --> 00:13:42.153
makes the detections run faster.

00:13:44.132 --> 00:13:45.090
So this is kind of fun.

00:13:45.090 --> 00:13:46.506
So Kevin, an
engineer on our team,

00:13:46.506 --> 00:13:48.660
went out and recorded
sensor data along

00:13:48.660 --> 00:13:50.440
with videos of
what he was doing.

00:13:50.440 --> 00:13:52.090
And the goals is to basically
look at the sensor data and try

00:13:52.090 --> 00:13:54.550
and figure out was he
walking, was he on a bicycle,

00:13:54.550 --> 00:13:55.725
or was in a vehicle.

00:13:55.725 --> 00:13:57.400
And if you look
at this one-- this

00:13:57.400 --> 00:13:59.842
is coming from the accelerometer
data from his phone.

00:13:59.842 --> 00:14:02.050
So you can see there's kind
of a couple of big spikes

00:14:02.050 --> 00:14:02.682
that happen.

00:14:02.682 --> 00:14:04.640
Those are usually an
indication that somebody's

00:14:04.640 --> 00:14:05.310
moving their legs.

00:14:05.310 --> 00:14:06.970
Either they're walking, and
each time they hit the ground,

00:14:06.970 --> 00:14:08.870
there's a big spike that
happens or maybe they're biking.

00:14:08.870 --> 00:14:10.430
Each time they cycle
around, there's

00:14:10.430 --> 00:14:12.230
a big spike that happens.

00:14:12.230 --> 00:14:16.480
If you add another sensor,
like the watch accelerometer,

00:14:16.480 --> 00:14:18.152
all we see here are
a lot of vibrations.

00:14:18.152 --> 00:14:19.610
We don't really
see any big spikes,

00:14:19.610 --> 00:14:22.660
like you'd expect to see
if somebody was walking.

00:14:22.660 --> 00:14:24.312
So these types of
vibrations, you'd

00:14:24.312 --> 00:14:25.770
usually expect to
see if somebody's

00:14:25.770 --> 00:14:27.644
holding on to the steering
wheel of a bicycle

00:14:27.644 --> 00:14:30.061
and just kind of feeling
the bumps in the road.

00:14:30.061 --> 00:14:31.810
So let's take a look
at what he was doing.

00:14:31.810 --> 00:14:33.856
Well, he was, in fact, biking.

00:14:33.856 --> 00:14:36.230
So this goes to show that, if
you use accelerometer data,

00:14:36.230 --> 00:14:37.896
it's a pretty good
indication as to what

00:14:37.896 --> 00:14:40.230
the user's activity might be.

00:14:40.230 --> 00:14:41.970
Let's take a look
at another one.

00:14:41.970 --> 00:14:43.914
So this one-- it looks
a lot like walking.

00:14:43.914 --> 00:14:45.830
The top graph, which is
coming from his phone,

00:14:45.830 --> 00:14:46.930
has a lot of these spikes.

00:14:46.930 --> 00:14:48.410
They're pretty periodic.

00:14:48.410 --> 00:14:50.667
And the watch also has very
similarly timed spikes.

00:14:50.667 --> 00:14:51.750
So he's basically walking.

00:14:51.750 --> 00:14:53.460
That's what it looks like.

00:14:53.460 --> 00:14:55.305
So that'd be my first
guess as the activity.

00:14:55.305 --> 00:14:58.110
But if we add one more
sensor, which is a barometer.

00:14:58.110 --> 00:14:59.820
Things get pretty interesting.

00:14:59.820 --> 00:15:02.830
So a barometer senses
atmospheric pressure.

00:15:02.830 --> 00:15:04.960
And basically, the
way it works is

00:15:04.960 --> 00:15:07.569
the lower you go down in
altitude, the more atmosphere

00:15:07.569 --> 00:15:09.860
there's on top of you, and
the more pressure your phone

00:15:09.860 --> 00:15:10.361
will sense.

00:15:10.361 --> 00:15:12.193
It's a little bit like
if you go underwater.

00:15:12.193 --> 00:15:14.800
The deeper you go underwater,
the more pressure you'll feel.

00:15:14.800 --> 00:15:17.600
The same thing happens here,
and your phone can sense that.

00:15:17.600 --> 00:15:19.740
So here, there's a
continuous upward spike

00:15:19.740 --> 00:15:21.840
in the barometer, which
means the user is actually

00:15:21.840 --> 00:15:24.280
decreasing in elevation.

00:15:24.280 --> 00:15:27.050
So we have somebody who's
decreasing in elevation

00:15:27.050 --> 00:15:29.070
and also doing
something like walking.

00:15:29.070 --> 00:15:31.200
So what activity is he doing?

00:15:31.200 --> 00:15:33.116
Well, he's going
down some stairs.

00:15:33.116 --> 00:15:34.660
So I think it's a
good example of,

00:15:34.660 --> 00:15:36.610
if you add another sensor,
like the barometer,

00:15:36.610 --> 00:15:39.596
you can better detect what's
happening in the real world.

00:15:39.596 --> 00:15:40.720
Let's look at one last one.

00:15:40.720 --> 00:15:42.894
So Kevin, when he
showed me this one,

00:15:42.894 --> 00:15:44.060
I had no idea what this was.

00:15:44.060 --> 00:15:45.810
I've never seen something
quite like this.

00:15:45.810 --> 00:15:47.710
So he told me, well, OK
I'll give you a hint.

00:15:47.710 --> 00:15:49.376
I was playing a game
and I had a gamepad

00:15:49.376 --> 00:15:50.531
that I was playing with.

00:15:50.531 --> 00:15:52.030
So, OK, well, the
first part of this

00:15:52.030 --> 00:15:53.500
looks a little bit like running.

00:15:53.500 --> 00:15:54.570
But then there are
these huge spikes

00:15:54.570 --> 00:15:56.486
that happen in the middle
graph that I've just

00:15:56.486 --> 00:15:57.390
never seen before.

00:15:57.390 --> 00:15:58.723
Let's look at what he was doing.

00:15:58.723 --> 00:16:00.450
He's playing on a gamepad.

00:16:00.450 --> 00:16:02.647
And then, oh, he
starts using his first.

00:16:02.647 --> 00:16:03.480
Now, it makes sense.

00:16:03.480 --> 00:16:05.086
He's cheating.

00:16:05.086 --> 00:16:06.710
If you've ever played
this game before,

00:16:06.710 --> 00:16:08.357
you've probably
tried that yourself.

00:16:08.357 --> 00:16:10.190
But it's a good example
of why we introduced

00:16:10.190 --> 00:16:11.636
an activity called Unknown.

00:16:11.636 --> 00:16:13.510
This basically allows
are classifiers to say,

00:16:13.510 --> 00:16:15.229
you know what, this
kind of sensor data,

00:16:15.229 --> 00:16:16.520
I've just never seen it before.

00:16:16.520 --> 00:16:17.710
And I don't want to
make the wrong thing

00:16:17.710 --> 00:16:19.584
and say, oh, you're
biking or you're running.

00:16:19.584 --> 00:16:22.670
So I'm just going
to guess, Unknown.

00:16:22.670 --> 00:16:24.820
So in summary, on-body
detection works

00:16:24.820 --> 00:16:27.210
by taking accelerometer
data, as well as the Activity

00:16:27.210 --> 00:16:29.610
Recognition API, to detect
that a phone was in a user's

00:16:29.610 --> 00:16:31.060
continuous possession.

00:16:31.060 --> 00:16:34.010
It saves users over
20 unlocks per day.

00:16:34.010 --> 00:16:35.480
But can we save
even more unlocks

00:16:35.480 --> 00:16:38.090
by using other context signals?

00:16:38.090 --> 00:16:39.690
Well, the answer is yes.

00:16:39.690 --> 00:16:41.440
So for me, personally,
if I'm at home,

00:16:41.440 --> 00:16:43.920
I'm comfortable having
my device stay unlocked.

00:16:43.920 --> 00:16:45.440
But if I go to an
airport, I want

00:16:45.440 --> 00:16:47.072
it to lock in case I lose it.

00:16:47.072 --> 00:16:48.780
So different places
have different levels

00:16:48.780 --> 00:16:50.220
of trust for different people.

00:16:50.220 --> 00:16:51.910
And the Trusted
Places feature allows

00:16:51.910 --> 00:16:54.800
you to keep your device unlocked
in places that you trust.

00:16:54.800 --> 00:16:56.284
So let's see how it works.

00:16:56.284 --> 00:16:58.950
Well, it makes use of the second
context API I'd like introduce,

00:16:58.950 --> 00:17:00.490
which is the Places API.

00:17:00.490 --> 00:17:02.990
This API makes it really
simple to get information

00:17:02.990 --> 00:17:04.846
about the places
around your users.

00:17:04.846 --> 00:17:06.220
And also, it
contains a component

00:17:06.220 --> 00:17:07.894
called a Place
Picker, which makes

00:17:07.894 --> 00:17:10.310
it easy to launch an interactive
map that allows your user

00:17:10.310 --> 00:17:12.357
to select a nearby place.

00:17:12.357 --> 00:17:14.190
So let's take a look
at a little bit of code

00:17:14.190 --> 00:17:16.349
to see how it works.

00:17:16.349 --> 00:17:18.390
Well, to use the
Place Picker API,

00:17:18.390 --> 00:17:20.589
you simply create a
PlacePicker Builder.

00:17:20.589 --> 00:17:23.209
And then, you call
startActivityForResult. When

00:17:23.209 --> 00:17:24.750
the user has selected
a place, you'll

00:17:24.750 --> 00:17:27.069
get a callback with the
details of the place,

00:17:27.069 --> 00:17:28.590
like its name and address.

00:17:28.590 --> 00:17:31.820
It's really that simple.

00:17:31.820 --> 00:17:34.850
And the other API used by
this Trusted Places feature

00:17:34.850 --> 00:17:37.410
is called the Geofencing API.

00:17:37.410 --> 00:17:39.910
This API fuses location
as well as activity

00:17:39.910 --> 00:17:43.220
to detect and to give your apps
a callback whenever it leaves

00:17:43.220 --> 00:17:45.350
or enters a particular region.

00:17:45.350 --> 00:17:47.140
It allows your apps
to respond to changes

00:17:47.140 --> 00:17:49.480
in the user's location while
keeping battery consumption

00:17:49.480 --> 00:17:50.461
to a minimum.

00:17:50.461 --> 00:17:52.710
For this feature, it was
used to unlock my device just

00:17:52.710 --> 00:17:56.450
as I arrived home, and
lock it again when I leave.

00:17:56.450 --> 00:17:59.467
So to use it, you set a
circular region around an area.

00:17:59.467 --> 00:18:01.800
And then you decide if you
want to be told about entries

00:18:01.800 --> 00:18:04.300
or exits of a particular area.

00:18:04.300 --> 00:18:07.100
We also added a new
transition type called Dwell.

00:18:07.100 --> 00:18:09.270
This allows you to say, I
want to be notified only

00:18:09.270 --> 00:18:11.728
when the user's been inside of
the geofence for a specified

00:18:11.728 --> 00:18:12.637
amount of time.

00:18:12.637 --> 00:18:14.720
It makes it easier to
distinguish between the case

00:18:14.720 --> 00:18:16.261
where somebody walks
by your geofence

00:18:16.261 --> 00:18:20.417
or actually stops at the place
that you're interested in.

00:18:20.417 --> 00:18:22.500
So in summary, we have the
Trusted Places feature,

00:18:22.500 --> 00:18:25.080
which uses the Place Picker,
as well as Geofencing,

00:18:25.080 --> 00:18:27.080
to make sure to unlock
your device in places

00:18:27.080 --> 00:18:28.344
that you trust.

00:18:28.344 --> 00:18:30.010
And we had this feature
which uses a lot

00:18:30.010 --> 00:18:31.959
of very kind of location based.

00:18:31.959 --> 00:18:33.500
And we had the on-off
body detection,

00:18:33.500 --> 00:18:35.340
which is using
accelerometers quite a bit.

00:18:35.340 --> 00:18:38.520
What happens if we use
these two sensors together?

00:18:38.520 --> 00:18:40.830
We could build a feature
called Where Did I

00:18:40.830 --> 00:18:43.219
Park My Car, which is
one I mentioned earlier.

00:18:43.219 --> 00:18:45.510
What I love about it is that
it's completely automatic.

00:18:45.510 --> 00:18:47.926
I don't have to remember to
take my phone out of my pocket

00:18:47.926 --> 00:18:50.575
and press a button every single
time I get out of my car.

00:18:50.575 --> 00:18:53.190
So how does it work?

00:18:53.190 --> 00:18:55.850
It makes use of the Fused
Location Provider API,

00:18:55.850 --> 00:18:59.190
which is an Android service
that uses Wi-Fi, cell, GPS,

00:18:59.190 --> 00:19:02.220
accelerometers, gyroscopes,
magnetometers-- so basically

00:19:02.220 --> 00:19:04.620
a huge, huge amount of
sensors to try and figure out

00:19:04.620 --> 00:19:08.382
the location of your device
if it's indoors or outdoors.

00:19:08.382 --> 00:19:10.590
And it also provides multiple
controls for developers

00:19:10.590 --> 00:19:13.170
to allow you to tune for higher
accuracy or better battery

00:19:13.170 --> 00:19:14.334
consumption.

00:19:14.334 --> 00:19:15.750
So let's take a
look at how it was

00:19:15.750 --> 00:19:16.958
used as part of this feature.

00:19:19.610 --> 00:19:22.360
Well, we started with the
Activity Recognition API

00:19:22.360 --> 00:19:24.930
and looked for whether or not
the user was in a vehicle.

00:19:24.930 --> 00:19:26.990
Once you detect the
user's in a vehicle,

00:19:26.990 --> 00:19:28.990
then register for the
Android Tilt Sensor.

00:19:28.990 --> 00:19:31.700
This is a sensor that can
really, at super low latency,

00:19:31.700 --> 00:19:33.767
detect that a user went
from sitting to standing.

00:19:33.767 --> 00:19:35.350
And it helps reduce
the amount of time

00:19:35.350 --> 00:19:38.514
it takes to detect that a
user came out of a vehicle.

00:19:38.514 --> 00:19:40.430
And then finally, once
we detect the user just

00:19:40.430 --> 00:19:43.352
got out of a vehicle, we use
the Fused Location Provider API.

00:19:43.352 --> 00:19:45.060
And then, there you
have it, the location

00:19:45.060 --> 00:19:47.268
of where you parked your
car, automatically detected.

00:19:50.880 --> 00:19:52.782
I'm a huge fan of the
quantified self idea.

00:19:52.782 --> 00:19:54.490
And that's why I love
the Google Fit app.

00:19:54.490 --> 00:19:55.835
It tracks my steps.

00:19:55.835 --> 00:19:59.130
It tracks my bike rides,
as well as my runs.

00:19:59.130 --> 00:20:00.880
And it does this
completely automatically.

00:20:00.880 --> 00:20:03.421
I don't have to remember to push
a button every time I go out

00:20:03.421 --> 00:20:05.540
for a bike ride.

00:20:05.540 --> 00:20:07.310
And to do this, it
makes use of many APIs.

00:20:07.310 --> 00:20:09.570
It makes us of the Activity
Recognition API, the Fused

00:20:09.570 --> 00:20:12.040
Location Provider API,
and even the Sensors API

00:20:12.040 --> 00:20:14.121
to track things like heart rate.

00:20:14.121 --> 00:20:16.120
And after using it for
about a couple of months,

00:20:16.120 --> 00:20:18.220
I noticed that, on
weekends, I would routinely

00:20:18.220 --> 00:20:19.277
miss my step goal.

00:20:19.277 --> 00:20:21.860
So I thought this was a really
interesting insight for me that

00:20:21.860 --> 00:20:23.855
allowed me to adjust my routine.

00:20:23.855 --> 00:20:25.980
And once I did, I noticed
a significant improvement

00:20:25.980 --> 00:20:28.280
in my skating stride
whenever I played hockey.

00:20:28.280 --> 00:20:30.024
So I thought that was great.

00:20:30.024 --> 00:20:31.690
But now, after my
legs were super strong

00:20:31.690 --> 00:20:34.080
from all that hard
walking, there

00:20:34.080 --> 00:20:36.390
was a new limiting factor
for me, which were my lungs.

00:20:36.390 --> 00:20:38.810
They would just burn
after a really hard state.

00:20:38.810 --> 00:20:40.320
That kind of high
level of intensity

00:20:40.320 --> 00:20:41.570
just isn't reached by walking.

00:20:43.850 --> 00:20:45.350
So we asked ourselves,
what could we

00:20:45.350 --> 00:20:48.110
do to make fitness a bit better?

00:20:48.110 --> 00:20:50.420
Well, new devices bring
up new possibilities.

00:20:50.420 --> 00:20:52.507
Android Wear is
great for context,

00:20:52.507 --> 00:20:54.840
since it's packed with sensors,
it's always on the user,

00:20:54.840 --> 00:20:57.280
and it's at a known,
fixed location.

00:20:57.280 --> 00:20:59.050
So we decided to
study sensor data

00:20:59.050 --> 00:21:01.050
to see if we could detect
some of these commonly

00:21:01.050 --> 00:21:03.258
known activities, like push
ups, sit ups, and squats,

00:21:03.258 --> 00:21:06.619
which have a really
high level of intensity.

00:21:06.619 --> 00:21:07.910
Well, it turns out it's doable.

00:21:07.910 --> 00:21:10.100
So here's an accelerometer
graph of what

00:21:10.100 --> 00:21:11.470
doing a squat looks like.

00:21:11.470 --> 00:21:12.928
So each time the
user does a squat,

00:21:12.928 --> 00:21:14.910
you can see this huge
spike that happens.

00:21:14.910 --> 00:21:17.118
And basically, we can write
algorithms on top of this

00:21:17.118 --> 00:21:18.359
to detect it.

00:21:18.359 --> 00:21:20.150
So I love starting at
accelerometer graphs,

00:21:20.150 --> 00:21:21.120
and I could do it all day.

00:21:21.120 --> 00:21:23.000
But I think a live demo would be
a little bit more interesting.

00:21:23.000 --> 00:21:24.999
So please welcome, Barbara,
the Engineering Lead

00:21:24.999 --> 00:21:27.978
of this project onto the stage
to show us this in action.

00:21:27.978 --> 00:21:30.912
[APPLAUSE]

00:21:32.380 --> 00:21:33.505
BARBARA WANG: Thanks, Marc.

00:21:33.505 --> 00:21:36.171
MARC STOGAITIS: Could you switch
over to the [INAUDIBLE] vision,

00:21:36.171 --> 00:21:37.450
please.

00:21:37.450 --> 00:21:39.840
BARBARA WANG: So today, I'm
going to do some work out

00:21:39.840 --> 00:21:43.600
on the stage, and show you
how Activity Recognition can

00:21:43.600 --> 00:21:46.580
automatically detect what
work out you're doing

00:21:46.580 --> 00:21:48.790
and also how many
reps you've done.

00:21:48.790 --> 00:21:50.950
First, I'm going
to do some squats.

00:21:50.950 --> 00:21:52.480
And while I'm doing
it, you should

00:21:52.480 --> 00:21:54.500
be able to see the
count on the big screen.

00:21:59.670 --> 00:22:09.120
One, two, three, four, five.

00:22:09.120 --> 00:22:09.620
Cool.

00:22:14.290 --> 00:22:16.620
As you can see, I
did five squats.

00:22:16.620 --> 00:22:19.140
And while I was doing
squats, the count

00:22:19.140 --> 00:22:20.960
incremented one by one.

00:22:20.960 --> 00:22:23.860
The count you see here
is synced from my watch

00:22:23.860 --> 00:22:26.010
directly over Bluetooth.

00:22:26.010 --> 00:22:30.540
So the detection is all
happening on the watch.

00:22:30.540 --> 00:22:34.100
You may also notice, we only
started showing the count

00:22:34.100 --> 00:22:35.940
after I've done three squats.

00:22:35.940 --> 00:22:38.380
This is because we
want to differentiate

00:22:38.380 --> 00:22:42.720
between a real squat
versus a random arm swing.

00:22:42.720 --> 00:22:45.080
The accuracy for
squats is pretty great.

00:22:45.080 --> 00:22:46.790
Now, let's take a
look at sit ups.

00:22:50.193 --> 00:22:51.984
WALEED KADOUS: You want
to move back a bit?

00:22:58.380 --> 00:23:08.387
BARBARA WANG: One,
two, three, four, five.

00:23:08.387 --> 00:23:09.365
[APPLAUSE]

00:23:09.365 --> 00:23:10.832
Awesome.

00:23:10.832 --> 00:23:11.810
Thanks.

00:23:11.810 --> 00:23:14.750
Back to Marc.

00:23:14.750 --> 00:23:17.557
MARC STOGAITIS: Thanks, Barbara.

00:23:17.557 --> 00:23:19.140
Can we switch back
over to the slides?

00:23:19.140 --> 00:23:21.710
Thank you.

00:23:21.710 --> 00:23:23.420
That was a really
cool demo, by the way.

00:23:23.420 --> 00:23:26.340
So we saw how Smart
Lock, Find My Car,

00:23:26.340 --> 00:23:28.210
and the Google Fit app
make use of context

00:23:28.210 --> 00:23:30.400
to improve their app experience.

00:23:30.400 --> 00:23:32.130
Now these are Google
specific use cases,

00:23:32.130 --> 00:23:34.680
which were useful to use as
examples since we could really

00:23:34.680 --> 00:23:36.125
dive into the details.

00:23:36.125 --> 00:23:37.750
But what I'd like to
leave you with now

00:23:37.750 --> 00:23:39.430
are a few examples of
how you can use context

00:23:39.430 --> 00:23:40.210
in your own apps.

00:23:46.920 --> 00:23:49.552
Context can be used to simplify
interactions with the device.

00:23:49.552 --> 00:23:51.260
So Waleed mentioned
earlier how keyboards

00:23:51.260 --> 00:23:53.030
are really small
and hard to type on.

00:23:53.030 --> 00:23:55.140
One example would be that,
if you have a chat app,

00:23:55.140 --> 00:23:57.240
you can automatically fill
in the name of a nearby place

00:23:57.240 --> 00:23:59.281
as a user is typing to
save them some keystrokes.

00:24:03.000 --> 00:24:05.570
You can also write a
feature that would simplify

00:24:05.570 --> 00:24:07.110
the output of the device.

00:24:07.110 --> 00:24:09.170
So if a user's driving,
you could automatically

00:24:09.170 --> 00:24:10.976
read text messages
out loud to make

00:24:10.976 --> 00:24:12.100
driving a little bit safer.

00:24:19.319 --> 00:24:20.485
Slides are being a bit slow.

00:24:26.640 --> 00:24:32.584
So you can also do
things like-- OK.

00:24:32.584 --> 00:24:33.750
We'll go without the slides.

00:24:36.590 --> 00:24:38.260
Other ways of
simplifying interactions

00:24:38.260 --> 00:24:40.770
would be if, say, your
user arrives home,

00:24:40.770 --> 00:24:43.980
you could automatically
turned on the lights.

00:24:43.980 --> 00:24:46.450
You can also use it
to simplify sharing.

00:24:46.450 --> 00:24:49.170
So one example would be that,
if you have a text messaging

00:24:49.170 --> 00:24:51.775
app, as your user
is driving, you

00:24:51.775 --> 00:24:53.400
could let other users
know that they're

00:24:53.400 --> 00:24:55.539
driving by putting a
little icon that says,

00:24:55.539 --> 00:24:56.830
this user is currently driving.

00:24:56.830 --> 00:24:59.461
And then it can save them from
having send out a text message

00:24:59.461 --> 00:25:00.710
when that user's already busy.

00:25:04.410 --> 00:25:06.850
It can also be used
to-- let's say,

00:25:06.850 --> 00:25:08.720
your user just
went out for a run.

00:25:08.720 --> 00:25:11.300
You could say, all
right, let me fill out

00:25:11.300 --> 00:25:14.592
a post with the distance
that you've traveled.

00:25:14.592 --> 00:25:16.300
That way you don't
have to actually go in

00:25:16.300 --> 00:25:19.390
and, say, OK, I just
ran 10 kilometers.

00:25:19.390 --> 00:25:21.080
So you make sharing
a little bit easier.

00:25:24.610 --> 00:25:26.930
And another example would
be an activity leaderboard.

00:25:26.930 --> 00:25:28.660
So something that I like a
lot from some of these fitness

00:25:28.660 --> 00:25:30.960
products is that they me
here's how much you've walked

00:25:30.960 --> 00:25:31.990
versus other users.

00:25:31.990 --> 00:25:33.442
You could do a lot more of that.

00:25:33.442 --> 00:25:34.900
For bike rides,
you could show this

00:25:34.900 --> 00:25:38.040
is how many miles your
friends have biked versus you.

00:25:38.040 --> 00:25:41.540
And basically, keep things a
little bit more interesting

00:25:41.540 --> 00:25:44.140
in terms of challenging
for your friends.

00:25:44.140 --> 00:25:45.760
You can also use it
for use cases that

00:25:45.760 --> 00:25:47.850
are related to entertainment.

00:25:47.850 --> 00:25:51.320
So let's say that
I go out for a run.

00:25:51.320 --> 00:25:54.390
Well, if I hit a really
tough part of a run,

00:25:54.390 --> 00:25:56.420
maybe you could play the
song, Eye of the Tiger,

00:25:56.420 --> 00:25:57.545
to keep things interesting.

00:26:00.990 --> 00:26:02.297
It can also be used for games.

00:26:02.297 --> 00:26:03.880
So for example, you
could write a game

00:26:03.880 --> 00:26:06.130
that's a treasure hunt based
on activity and location.

00:26:09.971 --> 00:26:11.470
We're getting stage
directions as to

00:26:11.470 --> 00:26:12.560
whether or not we'll
get the slides back.

00:26:12.560 --> 00:26:14.830
It's OK, this part is
actually pretty non-visual.

00:26:14.830 --> 00:26:18.210
The next part, I think
we'll need the slides back.

00:26:18.210 --> 00:26:19.820
So other entertainment
use cases.

00:26:19.820 --> 00:26:23.860
For example, you could
do movie recommendations.

00:26:23.860 --> 00:26:27.010
So if I go out and
I go to a ballpark.

00:26:27.010 --> 00:26:29.030
And then, I get home,
you could recommend hey,

00:26:29.030 --> 00:26:32.950
you might want to watch
the movie, Field of Dreams.

00:26:32.950 --> 00:26:35.486
And it can also be used in
quantified self use cases.

00:26:35.486 --> 00:26:36.860
So I mentioned
how the Google Fit

00:26:36.860 --> 00:26:38.160
app was great for
quantified self,

00:26:38.160 --> 00:26:39.350
especially around fitness.

00:26:39.350 --> 00:26:41.100
I think there's a lot more
that can be done here.

00:26:41.100 --> 00:26:43.475
For example, you can show
users this is how much time you

00:26:43.475 --> 00:26:44.589
spend on commuting.

00:26:44.589 --> 00:26:46.130
And here's how much
it was this week.

00:26:46.130 --> 00:26:48.040
Here's how much
it was last week.

00:26:48.040 --> 00:26:48.860
Hey, we're back.

00:26:48.860 --> 00:26:50.604
All right.

00:26:50.604 --> 00:26:52.020
Here's a quantified
self use case.

00:26:52.020 --> 00:26:53.190
So basically, you
show your users,

00:26:53.190 --> 00:26:55.273
this is how much you've
done in terms of commuting

00:26:55.273 --> 00:26:56.830
this month and last month.

00:26:56.830 --> 00:27:00.060
And then, show, hey, maybe if
you left a little bit early

00:27:00.060 --> 00:27:01.850
on this day or this
day, you'd actually

00:27:01.850 --> 00:27:04.300
be able to save extra time.

00:27:04.300 --> 00:27:06.850
You can also show it
for restaurant visits.

00:27:06.850 --> 00:27:09.102
So let's say you
show me a summary

00:27:09.102 --> 00:27:11.310
of this month how many times
I've visited restaurants

00:27:11.310 --> 00:27:13.518
versus last month, I can
use that to compare or maybe

00:27:13.518 --> 00:27:15.710
optimize my life a little bit.

00:27:15.710 --> 00:27:17.870
And finally, it can be used
to explore and discover

00:27:17.870 --> 00:27:22.240
the world around your users,
like showing nearby events,

00:27:22.240 --> 00:27:24.290
or even, just as I walk
up to a restaurant,

00:27:24.290 --> 00:27:26.498
you can show me this is the
menu for this restaurant,

00:27:26.498 --> 00:27:29.301
here are the best items
so that I can compare.

00:27:29.301 --> 00:27:33.070
And of course, the best
examples will come from you.

00:27:33.070 --> 00:27:34.010
So there you have it.

00:27:34.010 --> 00:27:35.676
I hope that going
through these examples

00:27:35.676 --> 00:27:38.190
has helped to illustrate the
type of contextual experience

00:27:38.190 --> 00:27:39.500
that could be built, today.

00:27:39.500 --> 00:27:41.790
And I look forward to
seeing these in your apps.

00:27:41.790 --> 00:27:43.956
Now, Waleed will speak to
the challenges of building

00:27:43.956 --> 00:27:46.510
contextual experiences.

00:27:46.510 --> 00:27:48.830
WALEED KADOUS: Thank you, Marc.

00:27:48.830 --> 00:27:52.530
So it's important to realize
that these technologies

00:27:52.530 --> 00:27:55.570
and the ideas that
Marc presented to us

00:27:55.570 --> 00:27:56.770
are really in their infancy.

00:27:56.770 --> 00:27:59.085
So at a very critical
stage, you can really

00:27:59.085 --> 00:28:00.460
build some awesome
stuff, but you

00:28:00.460 --> 00:28:03.010
need to pay very close
attention to a couple of things

00:28:03.010 --> 00:28:05.110
because the
technology is so new.

00:28:05.110 --> 00:28:07.070
It's not like, say,
graphical user interfaces

00:28:07.070 --> 00:28:09.092
that have been around
for quite a while.

00:28:09.092 --> 00:28:11.050
So it's really important
that you pay attention

00:28:11.050 --> 00:28:12.150
to a few things.

00:28:12.150 --> 00:28:15.120
And those three things are
user trust-- in other words,

00:28:15.120 --> 00:28:17.260
you need to establish a
relationship with your user

00:28:17.260 --> 00:28:20.530
to help them understand
how you're using sensors

00:28:20.530 --> 00:28:23.040
and what the application
is doing for them.

00:28:23.040 --> 00:28:25.890
Secondly, recovering gracefully
when things don't go right.

00:28:25.890 --> 00:28:27.980
And finally, and perhaps
most challengingly

00:28:27.980 --> 00:28:31.040
in the current
age, battery life.

00:28:31.040 --> 00:28:33.190
So let's talk about user trust.

00:28:33.190 --> 00:28:34.790
Really here, there
are two key rules.

00:28:34.790 --> 00:28:37.290
The first one is to
collect only what you use.

00:28:37.290 --> 00:28:39.085
It's so tempting
with the huge range

00:28:39.085 --> 00:28:41.210
of sensors available to
say something like, give me

00:28:41.210 --> 00:28:42.430
everything you got.

00:28:42.430 --> 00:28:45.090
But really, what that leads to
is it leads to user confusion.

00:28:45.090 --> 00:28:46.339
And we've seen that ourselves.

00:28:46.339 --> 00:28:48.680
We've seen flashlight
apps that require

00:28:48.680 --> 00:28:52.420
fine grained location, which
doesn't make any sense at all.

00:28:52.420 --> 00:28:54.920
And the other really
important principle

00:28:54.920 --> 00:28:58.220
is to explain how
you're using the context

00:28:58.220 --> 00:28:59.580
to benefit the user.

00:28:59.580 --> 00:29:01.310
And generally,
what we've seen is,

00:29:01.310 --> 00:29:04.820
if you can present to the user
the benefits of sharing these

00:29:04.820 --> 00:29:10.529
like GPS and accelerometer with
you, then they will understand,

00:29:10.529 --> 00:29:12.320
and they will come with
you on the journey,

00:29:12.320 --> 00:29:15.430
as you launch the app.

00:29:15.430 --> 00:29:17.900
So let's go through
some examples

00:29:17.900 --> 00:29:20.740
that we have in our
own products in Google.

00:29:20.740 --> 00:29:23.910
The first one on the left
shows the trusted places.

00:29:23.910 --> 00:29:25.780
So what happens is
the first time that

00:29:25.780 --> 00:29:28.950
trusted places triggers,
after you've installed it

00:29:28.950 --> 00:29:31.500
and enabled it, is it will
have an interstitial here

00:29:31.500 --> 00:29:35.470
that explains, by the way, we're
unlocked right now because we

00:29:35.470 --> 00:29:36.520
knew where you were.

00:29:36.520 --> 00:29:38.080
You were in a particular place.

00:29:38.080 --> 00:29:39.860
And now, we've
communicated to the user

00:29:39.860 --> 00:29:42.950
how we're using location
to make their lives better.

00:29:42.950 --> 00:29:45.680
The second example comes
from the on-body detection

00:29:45.680 --> 00:29:47.250
that we mentioned earlier.

00:29:47.250 --> 00:29:49.760
And that's really about
explaining to users how

00:29:49.760 --> 00:29:51.340
we're using the accelerometer.

00:29:51.340 --> 00:29:53.880
And we have a short explanation
with cute little graphics

00:29:53.880 --> 00:29:56.120
that say, hey, this
is what we're doing.

00:29:56.120 --> 00:29:59.770
And we've really found that
this helps users to understand

00:29:59.770 --> 00:30:01.700
and come along with
us on the journey

00:30:01.700 --> 00:30:04.700
as we make apps more contextual.

00:30:04.700 --> 00:30:08.140
The second principle
that we have to adhere to

00:30:08.140 --> 00:30:09.926
is really recovering gracefully.

00:30:09.926 --> 00:30:11.800
Now as Marc showed you,
these are all machine

00:30:11.800 --> 00:30:12.930
learning algorithms.

00:30:12.930 --> 00:30:14.980
No machine learning
algorithm is perfect.

00:30:14.980 --> 00:30:17.590
So for example, if you're
driving really slowly,

00:30:17.590 --> 00:30:21.310
it's going to be very hard
to tell that from cycling.

00:30:21.310 --> 00:30:23.480
For example, if you think
about choosing a place,

00:30:23.480 --> 00:30:25.990
maybe we won't get you at
exactly the right restaurant,

00:30:25.990 --> 00:30:27.870
but we'll get you next door.

00:30:27.870 --> 00:30:30.390
So we have to
design with the idea

00:30:30.390 --> 00:30:32.970
and change the user
interface and interaction

00:30:32.970 --> 00:30:34.810
to have capability for that.

00:30:34.810 --> 00:30:37.550
So for example, when
you look at Google Fit,

00:30:37.550 --> 00:30:40.240
although we automatically detect
the start and end of things,

00:30:40.240 --> 00:30:43.410
it's really important to provide
the user a way to correct that.

00:30:43.410 --> 00:30:44.866
Or think about the Place Picker.

00:30:44.866 --> 00:30:46.240
When you look at
the Place Picker

00:30:46.240 --> 00:30:48.912
and we're giving people a bunch
of options to choose from,

00:30:48.912 --> 00:30:51.120
ideally we wouldn't even
give them the option, right?

00:30:51.120 --> 00:30:53.820
We'd just say, you're
definitely at this place.

00:30:53.820 --> 00:30:56.500
But what we do is we offer
a couple of other options

00:30:56.500 --> 00:30:58.880
so that the user can choose
the correct one in case

00:30:58.880 --> 00:31:02.250
we didn't quite get it
right, but we were close.

00:31:02.250 --> 00:31:05.220
And then the third
example is to think back

00:31:05.220 --> 00:31:08.380
to on-off-body detection
and trusted places,

00:31:08.380 --> 00:31:10.930
and really contemplate
what we did there.

00:31:10.930 --> 00:31:12.360
What happens if we get it wrong?

00:31:12.360 --> 00:31:18.005
What happens if we think
that the phone was on a desk,

00:31:18.005 --> 00:31:19.590
but was actually
in their pocket.

00:31:19.590 --> 00:31:21.530
Well, what might happen
is that we might ask

00:31:21.530 --> 00:31:23.480
them to unlock one more time.

00:31:23.480 --> 00:31:24.920
And is that so bad?

00:31:24.920 --> 00:31:26.630
At least we've had
the benefit of being

00:31:26.630 --> 00:31:28.980
able to reduce the
number unlocks that they

00:31:28.980 --> 00:31:32.490
have to do on a regular basis.

00:31:32.490 --> 00:31:34.240
This is perhaps the
most challenging thing

00:31:34.240 --> 00:31:37.530
that you will face as you try to
make your apps more contextual.

00:31:37.530 --> 00:31:39.500
And I think it's important
to us to recognize

00:31:39.500 --> 00:31:41.875
the difference between the
way that these contextual apps

00:31:41.875 --> 00:31:43.770
work and normal apps work.

00:31:43.770 --> 00:31:46.000
Most of the apps we develop,
but not all of them,

00:31:46.000 --> 00:31:48.010
are basically
foreground applications.

00:31:48.010 --> 00:31:50.289
And when you're a
foreground application, what

00:31:50.289 --> 00:31:51.830
you do as far as
power doesn't really

00:31:51.830 --> 00:31:53.288
matter so much
because the screen's

00:31:53.288 --> 00:31:56.470
going to be the dominant factor
in your power consumption.

00:31:56.470 --> 00:31:59.170
And so what that means-- and
in addition, most of our apps,

00:31:59.170 --> 00:32:01.630
maybe, the user used
it for 10 minutes a day

00:32:01.630 --> 00:32:03.170
or 15 minutes a day.

00:32:03.170 --> 00:32:06.289
It's not like they're using
it for 15 hours a day.

00:32:06.289 --> 00:32:08.080
And in fact, if you
look at the statistics,

00:32:08.080 --> 00:32:10.910
the average phone is
on for 4% of the time.

00:32:10.910 --> 00:32:12.840
Now we have to switch
our mental model.

00:32:12.840 --> 00:32:15.470
And we have to think of,
instead of these huge spikes

00:32:15.470 --> 00:32:17.510
for short intervals,
we have to think

00:32:17.510 --> 00:32:20.220
about sipping a little
bit of power all the time.

00:32:20.220 --> 00:32:23.300
And that means we have to
adopt some new metaphors

00:32:23.300 --> 00:32:25.680
and ways of thinking
about things and, in fact,

00:32:25.680 --> 00:32:27.980
change the way the hardware
is designed to facilitate

00:32:27.980 --> 00:32:30.480
that particular use case.

00:32:30.480 --> 00:32:33.640
The great thing with Android
is just how flexible it is.

00:32:33.640 --> 00:32:35.289
It's an amazingly
flexible system.

00:32:35.289 --> 00:32:37.330
And you can do things on
Android that aren't even

00:32:37.330 --> 00:32:39.060
possible on other platforms.

00:32:39.060 --> 00:32:41.424
But it also means that that
gives you a lot of rope

00:32:41.424 --> 00:32:42.340
to hang yourself with.

00:32:42.340 --> 00:32:44.340
So you have to be
super, super careful

00:32:44.340 --> 00:32:45.990
in how you use these things.

00:32:45.990 --> 00:32:49.810
So what we've tried to do with
the APIs that we've provided

00:32:49.810 --> 00:32:53.250
is that we've tried to give
you powerful abstractions that

00:32:53.250 --> 00:32:55.140
aren't very power hungry.

00:32:55.140 --> 00:32:57.660
And that gives you
a lot of capability

00:32:57.660 --> 00:32:59.000
to address the common cases.

00:32:59.000 --> 00:33:01.180
But as I mentioned,
the beauty of Android

00:33:01.180 --> 00:33:02.442
is just its flexibility.

00:33:02.442 --> 00:33:03.900
And you can always
go off and build

00:33:03.900 --> 00:33:06.720
your own contextual experiences.

00:33:06.720 --> 00:33:10.540
So just to give you an idea
of what we do in our labs,

00:33:10.540 --> 00:33:13.390
we're designing APIs for
the entire ecosystem.

00:33:13.390 --> 00:33:15.720
So we put a little bit
of effort into this.

00:33:15.720 --> 00:33:18.107
This shows our power
regression testing lab.

00:33:18.107 --> 00:33:20.440
And what you can see there
is a bunch of [? monsoons ?].

00:33:20.440 --> 00:33:23.520
Those are devices for measuring
power very accurately.

00:33:23.520 --> 00:33:26.950
And what we do is, every time
we make a change to the code

00:33:26.950 --> 00:33:30.220
that we make available to you,
we run it against these devices

00:33:30.220 --> 00:33:31.910
to make sure there
are no regressions.

00:33:31.910 --> 00:33:33.590
Now again, I want to
emphasize that you can always

00:33:33.590 --> 00:33:34.390
do your own thing.

00:33:34.390 --> 00:33:36.639
But you do need to pay
attention to power because it's

00:33:36.639 --> 00:33:39.110
one of the greatest challenges.

00:33:39.110 --> 00:33:41.670
So if you want to
get power right,

00:33:41.670 --> 00:33:44.009
there are two key
principles that we've seen.

00:33:44.009 --> 00:33:46.050
The first one is you have
to make the hardware do

00:33:46.050 --> 00:33:47.570
the heavy lifting for you.

00:33:47.570 --> 00:33:50.030
And we'll talk a little bit
about the design patterns,

00:33:50.030 --> 00:33:51.450
the subcategories there.

00:33:51.450 --> 00:33:53.260
And the second thing
is to really think

00:33:53.260 --> 00:33:55.020
about what does your
application really

00:33:55.020 --> 00:33:58.100
need in terms of quality.

00:33:58.100 --> 00:34:00.840
So to really understand
making the hardware do

00:34:00.840 --> 00:34:04.047
the hard work for you, we
need to step in and understand

00:34:04.047 --> 00:34:05.880
a little bit about how
things used to happen

00:34:05.880 --> 00:34:07.170
and what happens now.

00:34:07.170 --> 00:34:08.900
So traditionally
the model in Android

00:34:08.900 --> 00:34:10.730
was that you had
sensors that themselves

00:34:10.730 --> 00:34:13.449
might be quite power efficient,
like a accelerometer,

00:34:13.449 --> 00:34:15.969
it's pretty power efficient.

00:34:15.969 --> 00:34:17.510
But your application
processor that

00:34:17.510 --> 00:34:20.449
actually does those 8 billion
calculations, and renders

00:34:20.449 --> 00:34:22.560
the screen, and
makes your game run,

00:34:22.560 --> 00:34:25.120
and gives you no jank, and
all of that kind of stuff,

00:34:25.120 --> 00:34:27.380
that thing is actually
pretty power hungry.

00:34:27.380 --> 00:34:29.719
In fact, it consumes a very,
very substantial amount

00:34:29.719 --> 00:34:30.909
of power.

00:34:30.909 --> 00:34:33.469
So the game here is to keep
that application processor

00:34:33.469 --> 00:34:35.639
on for as little
time as possible.

00:34:35.639 --> 00:34:38.560
Now the issue is that if
you have a sensor, even

00:34:38.560 --> 00:34:40.830
if the sensor is low
power-- let's take you back

00:34:40.830 --> 00:34:45.179
to your college days and draw
one of these sequence diagrams.

00:34:45.179 --> 00:34:47.190
What happens is that the
sensor sends the update

00:34:47.190 --> 00:34:49.420
to the. processor.

00:34:49.420 --> 00:34:51.500
The processor sends
it to your app.

00:34:51.500 --> 00:34:53.719
So each sensor measurement
you get-- and you

00:34:53.719 --> 00:34:57.116
might be getting 25 or 100
sensor measurements a second--

00:34:57.116 --> 00:34:58.990
the processor has to
stay awake, and it never

00:34:58.990 --> 00:35:00.710
gets a chance to go to sleep.

00:35:00.710 --> 00:35:02.740
So what we did is we
changed the design

00:35:02.740 --> 00:35:04.210
of the internals of Android.

00:35:04.210 --> 00:35:06.180
And we said, what if we
can put some low power

00:35:06.180 --> 00:35:10.079
hardware in between the sensors
and the application process.

00:35:10.079 --> 00:35:11.870
This will give us a
mechanism to really get

00:35:11.870 --> 00:35:13.550
to low power possibilities.

00:35:13.550 --> 00:35:16.400
So effectively, what we
have is something like this.

00:35:16.400 --> 00:35:19.090
You send the sensor data to this
little low power thing, which

00:35:19.090 --> 00:35:21.990
we will call a hub for now,
and instead of it waking up

00:35:21.990 --> 00:35:23.860
the main application
processor, it's

00:35:23.860 --> 00:35:26.260
going to bunch together
a bunch of measurements,

00:35:26.260 --> 00:35:28.820
send them as one package
to the processor,

00:35:28.820 --> 00:35:31.560
and the package then
delivers that to your app.

00:35:31.560 --> 00:35:33.350
In the case of
accelerometer data,

00:35:33.350 --> 00:35:36.240
we've seen this cut
our power by 80%.

00:35:36.240 --> 00:35:39.670
So using this feature is
very, very power advantageous.

00:35:39.670 --> 00:35:41.360
And in fact, this
is what we rely

00:35:41.360 --> 00:35:43.310
on for Activity
Recognition to make

00:35:43.310 --> 00:35:46.020
it even more power efficient.

00:35:46.020 --> 00:35:48.980
Now we already put
this low power hardware

00:35:48.980 --> 00:35:50.222
box in the middle of it.

00:35:50.222 --> 00:35:51.930
But what if, instead
of just gathering up

00:35:51.930 --> 00:35:54.430
a bunch of measurements and
shipping them off in one go,

00:35:54.430 --> 00:35:56.490
we actually put more
intelligence on there,

00:35:56.490 --> 00:35:58.660
and ask that the hardware
check for conditions

00:35:58.660 --> 00:36:00.910
to be true or false,
and actually start

00:36:00.910 --> 00:36:02.212
to put programs in there.

00:36:02.212 --> 00:36:04.170
Then what's possible is
that you could actually

00:36:04.170 --> 00:36:06.350
check for the Geofences
in the hardware.

00:36:06.350 --> 00:36:09.490
And some of the Android
devices in your pockets

00:36:09.490 --> 00:36:11.490
actually do hardware
Geofencing, which

00:36:11.490 --> 00:36:14.356
is much more power efficient
than software Geofencing.

00:36:14.356 --> 00:36:15.980
And think back to
the keynote, where we

00:36:15.980 --> 00:36:17.710
were talking about Doze mode.

00:36:17.710 --> 00:36:20.360
Doze mode is built on something
called significant motion,

00:36:20.360 --> 00:36:22.510
which watches the
accelerometer all the time

00:36:22.510 --> 00:36:24.110
to see if the
position of the device

00:36:24.110 --> 00:36:26.290
might have changed
in a significant way.

00:36:26.290 --> 00:36:27.850
And by using that
sensor, we were

00:36:27.850 --> 00:36:30.730
able to really extend the
battery life of the device.

00:36:30.730 --> 00:36:32.310
And it's really
enabled us to build

00:36:32.310 --> 00:36:35.090
some very impressive features.

00:36:35.090 --> 00:36:37.050
So we talked before
about design patterns

00:36:37.050 --> 00:36:39.632
and making the hardware
do the heavy lifting,

00:36:39.632 --> 00:36:41.340
but the other thing
to think about really

00:36:41.340 --> 00:36:44.510
carefully is what does your
application really need.

00:36:44.510 --> 00:36:46.680
And I want you to think
about a weather app

00:36:46.680 --> 00:36:48.430
and an indoor navigation app.

00:36:48.430 --> 00:36:51.600
Clearly, for a weather app, I
don't need the most accurate

00:36:51.600 --> 00:36:52.220
location.

00:36:52.220 --> 00:36:56.130
I just need city level
location to get what I want.

00:36:56.130 --> 00:36:57.800
The Fused Location
Provider gives you

00:36:57.800 --> 00:37:00.250
options as far as power,
high quality, balanced,

00:37:00.250 --> 00:37:01.390
and low power.

00:37:01.390 --> 00:37:03.250
And in this case, we
would choose low power.

00:37:03.250 --> 00:37:05.480
But compare that to an
indoor navigation app.

00:37:05.480 --> 00:37:07.490
The user's looking
right at the device.

00:37:07.490 --> 00:37:09.420
I want the highest
quality I possibly can.

00:37:09.420 --> 00:37:11.470
So then, I would
ask for high power.

00:37:11.470 --> 00:37:13.780
And not only does this
apply to accuracy, but also

00:37:13.780 --> 00:37:14.940
to timeliness.

00:37:14.940 --> 00:37:17.600
For example, if we have
the same situation,

00:37:17.600 --> 00:37:20.730
do I really care if I show
the city for five minutes

00:37:20.730 --> 00:37:22.360
or 10 minutes after
I've left that city

00:37:22.360 --> 00:37:25.120
and moved on to, say, Berkeley
instead of San Francisco?

00:37:25.120 --> 00:37:27.200
We think we can
probably tolerate that.

00:37:27.200 --> 00:37:29.110
But if you show
the user's location

00:37:29.110 --> 00:37:31.170
50 seconds after
they were there,

00:37:31.170 --> 00:37:33.170
that's going to be a
pretty horrible experience.

00:37:33.170 --> 00:37:35.590
So it's really about you
telling the system what

00:37:35.590 --> 00:37:38.090
you need in terms of features.

00:37:38.090 --> 00:37:41.230
So those were the difficulties
we have to overcome.

00:37:41.230 --> 00:37:42.730
But what I'm really
excited to share

00:37:42.730 --> 00:37:44.460
with you in our last
few minutes together

00:37:44.460 --> 00:37:46.660
is what I think is going
to happen in the future

00:37:46.660 --> 00:37:50.040
because I really think we're
on a good track to 2020.

00:37:50.040 --> 00:37:52.260
So there's, of course,
going to be a large range

00:37:52.260 --> 00:37:54.410
of incremental improvements.

00:37:54.410 --> 00:37:56.070
Location will get more accurate.

00:37:56.070 --> 00:37:58.929
And the range of activities we
detect is going to get broader.

00:37:58.929 --> 00:38:00.470
We're going to detect
going upstairs,

00:38:00.470 --> 00:38:03.140
and downstairs, and up
elevators, and maybe even

00:38:03.140 --> 00:38:06.450
more extreme things, like
playing golf or cooking dinner.

00:38:06.450 --> 00:38:08.590
But there's also three
critical step functions

00:38:08.590 --> 00:38:10.350
that I want to
outline to you folks.

00:38:10.350 --> 00:38:12.850
The first of those is
improvements to location.

00:38:12.850 --> 00:38:15.810
The second one is moving
to a multi-device world.

00:38:15.810 --> 00:38:17.560
I think you remember
Sundar's conversation

00:38:17.560 --> 00:38:19.960
today about Brillo, and
the Internet of Things,

00:38:19.960 --> 00:38:22.370
and finally opening
up that low power

00:38:22.370 --> 00:38:24.410
subsystem that we've
just been talking about.

00:38:24.410 --> 00:38:26.280
So let's dive right in.

00:38:26.280 --> 00:38:29.500
So I really think that location
will get very, very much better

00:38:29.500 --> 00:38:30.386
in the coming while.

00:38:30.386 --> 00:38:32.760
I think one of the biggest
weaknesses with location right

00:38:32.760 --> 00:38:34.980
now is it's not
available indoors.

00:38:34.980 --> 00:38:38.630
And I think we have some
ways we can improve that.

00:38:38.630 --> 00:38:40.630
What I want to highlight
is-- in the next slide,

00:38:40.630 --> 00:38:41.977
I'm going to show you a video.

00:38:41.977 --> 00:38:43.310
This is not close to production.

00:38:43.310 --> 00:38:49.480
It's way too power hungry,
and too flaky, and too

00:38:49.480 --> 00:38:50.872
lab-like to [INAUDIBLE] launch.

00:38:50.872 --> 00:38:52.330
But I wanted to
show you what we've

00:38:52.330 --> 00:38:53.830
been working on in our lab.

00:38:53.830 --> 00:38:56.810
What you can see here is a
diagram of one of our labs.

00:38:56.810 --> 00:38:59.530
And the green line
shows ground truth.

00:38:59.530 --> 00:39:00.930
And the blue dot
shows what we're

00:39:00.930 --> 00:39:04.390
able to compute in
terms of location.

00:39:04.390 --> 00:39:06.510
And the most impressive
thing about this

00:39:06.510 --> 00:39:09.290
is we don't use any sensors that
aren't already on your device,

00:39:09.290 --> 00:39:10.006
today.

00:39:10.006 --> 00:39:12.130
You can see it's tracking
pretty bloody accurately.

00:39:12.130 --> 00:39:14.702
It's about 2 or 3 meters off.

00:39:14.702 --> 00:39:15.910
And that's pretty impressive.

00:39:15.910 --> 00:39:17.640
And we're really
excited about working

00:39:17.640 --> 00:39:20.212
to make this a reality
in most people's devices.

00:39:20.212 --> 00:39:22.170
Imagine what you could
do in terms of Geofences

00:39:22.170 --> 00:39:23.378
with something this accurate.

00:39:26.090 --> 00:39:28.980
The second point we talked about
is multi-device, the Internet

00:39:28.980 --> 00:39:30.310
of Things, and Brillo.

00:39:30.310 --> 00:39:33.170
So we've already started to talk
about what you can do on Wear

00:39:33.170 --> 00:39:34.600
and what you can
do on your phone.

00:39:34.600 --> 00:39:37.440
But what happens when you add
Auto, and Nest, and Brillo

00:39:37.440 --> 00:39:38.360
into the mix.

00:39:38.360 --> 00:39:40.240
Two really interesting
things happen.

00:39:40.240 --> 00:39:42.760
Number one, the ways that
you can sense the environment

00:39:42.760 --> 00:39:43.860
can change.

00:39:43.860 --> 00:39:46.670
And that means that our
ability to understand context

00:39:46.670 --> 00:39:49.780
becomes much more richer, and
we can do a much better job.

00:39:49.780 --> 00:39:52.880
Secondly, you have a
much greater surface area

00:39:52.880 --> 00:39:56.810
to surface the benefits of
location and other contextual

00:39:56.810 --> 00:39:57.640
signals.

00:39:57.640 --> 00:40:01.479
So imagine, for example, that
you say, turn on the lights.

00:40:01.479 --> 00:40:03.020
Well, we can answer
that question now

00:40:03.020 --> 00:40:05.274
because what you can do is
you can know exactly which

00:40:05.274 --> 00:40:07.440
lights to turn on because
we know your location very

00:40:07.440 --> 00:40:08.350
accurately.

00:40:08.350 --> 00:40:10.122
So that's a really
exciting thing.

00:40:10.122 --> 00:40:11.830
The final thing that
I want to talk about

00:40:11.830 --> 00:40:16.830
is opening up that flexible,
always-on computing platform.

00:40:16.830 --> 00:40:18.560
So through this
talk, we've talked

00:40:18.560 --> 00:40:22.299
about this analogy between the
human brain and human sensors.

00:40:22.299 --> 00:40:24.340
And I really want to talk
a little bit about what

00:40:24.340 --> 00:40:25.830
we might be able to do.

00:40:25.830 --> 00:40:28.730
So historically, what
happens with the human brain

00:40:28.730 --> 00:40:30.530
is we have the cerebrum
and the cerebellum.

00:40:30.530 --> 00:40:32.552
And they're our
powerhouse processors.

00:40:32.552 --> 00:40:34.260
That's what we use to
understand language

00:40:34.260 --> 00:40:37.030
and what you're using right now
to understand what I'm saying.

00:40:37.030 --> 00:40:39.363
But there's this other part
of the brain that many of us

00:40:39.363 --> 00:40:41.080
are not aware of
called the brainstem.

00:40:41.080 --> 00:40:42.210
And the brainstem
is the thing that

00:40:42.210 --> 00:40:44.751
makes sure that you're breathing
when you're asleep and wakes

00:40:44.751 --> 00:40:47.009
you up when there's a
loud noise, like an alarm,

00:40:47.009 --> 00:40:49.550
and wakes you up when the lights
are bright, and wakes you up

00:40:49.550 --> 00:40:50.810
when you fall out of bed.

00:40:50.810 --> 00:40:54.252
That system is always running,
even if you're sleeping.

00:40:54.252 --> 00:40:56.460
This should look familiar
to you because it's exactly

00:40:56.460 --> 00:40:59.090
the same diagram that
I mentioned earlier.

00:40:59.090 --> 00:41:00.690
You have this low
power subsystem

00:41:00.690 --> 00:41:03.840
that gives you the capability
to process signals,

00:41:03.840 --> 00:41:05.490
and it's always on.

00:41:05.490 --> 00:41:07.110
But what's incredible
to me is just

00:41:07.110 --> 00:41:10.510
how capable these low power
subsystems are becoming.

00:41:10.510 --> 00:41:14.520
So what I did is I compared
what's called a sensor hub,

00:41:14.520 --> 00:41:16.910
and in this particular case,
it has the romantic name

00:41:16.910 --> 00:41:19.430
STM32F411.

00:41:19.430 --> 00:41:22.170
This is just one example
of one of these devices

00:41:22.170 --> 00:41:24.590
that can provide this low
power hybrid capabilities.

00:41:24.590 --> 00:41:26.582
There's lots of
different designs.

00:41:26.582 --> 00:41:28.290
Sometimes, it's in
the sensors, sometimes

00:41:28.290 --> 00:41:30.664
it's in the same piece of
silicon as the main application

00:41:30.664 --> 00:41:31.390
processor.

00:41:31.390 --> 00:41:32.970
But what I did is
I wanted to compare

00:41:32.970 --> 00:41:34.840
with a Pentium of 20 years ago.

00:41:34.840 --> 00:41:37.320
Now believe it or not, the
Pentium of 20 years ago

00:41:37.320 --> 00:41:40.340
has about the same computing
power as one of these low power

00:41:40.340 --> 00:41:41.730
hardware processors.

00:41:41.730 --> 00:41:43.970
I got to remind you that
20 years ago, we still

00:41:43.970 --> 00:41:46.100
had the internet,
we still sent email,

00:41:46.100 --> 00:41:48.950
we still browsed the web, we
still put together documents.

00:41:48.950 --> 00:41:50.950
And so this chip,
at 100 MIPS, was

00:41:50.950 --> 00:41:53.730
able to provide a pretty
good user experience.

00:41:53.730 --> 00:41:56.030
Now we have that
same amount of power

00:41:56.030 --> 00:41:57.970
just to process the
sensor measurements, which

00:41:57.970 --> 00:42:00.145
is really mind blowing to me.

00:42:00.145 --> 00:42:01.770
And then the other
thing to think about

00:42:01.770 --> 00:42:04.210
is just how much
lower power they are.

00:42:04.210 --> 00:42:06.590
Let's imagine that I
could shoehorn a Pentium

00:42:06.590 --> 00:42:07.890
into your phone.

00:42:07.890 --> 00:42:10.390
Do you know how long would take
to [INAUDIBLE] your battery?

00:42:10.390 --> 00:42:12.640
You do the math and it's
like 30 minutes max.

00:42:12.640 --> 00:42:17.620
But you take one of these
STM32F411-- that's a mouthful.

00:42:17.620 --> 00:42:19.910
And you plunk it in there.

00:42:19.910 --> 00:42:22.600
It's so low power that you
can basically just keep

00:42:22.600 --> 00:42:23.600
it running all the time.

00:42:23.600 --> 00:42:25.100
And if it was the
only thing running

00:42:25.100 --> 00:42:27.320
on the phone in typical
mode, your phone battery life

00:42:27.320 --> 00:42:29.150
would last for 60 days.

00:42:29.150 --> 00:42:31.090
Now I want to remind you
again, I think we all

00:42:31.090 --> 00:42:33.340
know what Moore's
Law is, but it's

00:42:33.340 --> 00:42:35.380
just fun to look at this again.

00:42:35.380 --> 00:42:37.590
So this is the Intel
Pentium from 20 years ago.

00:42:37.590 --> 00:42:42.170
And this is STM32F411 that's in
some of your phones right now.

00:42:42.170 --> 00:42:44.740
And it's crazy how the
difference in size works.

00:42:44.740 --> 00:42:47.270
But here's what I'm
super excited about.

00:42:47.270 --> 00:42:50.542
What happens when, instead of
this processor being a fixed

00:42:50.542 --> 00:42:52.500
function that the developer
who makes the phone

00:42:52.500 --> 00:42:54.530
gets to decide
what runs on there,

00:42:54.530 --> 00:42:56.570
and we open it up
to third parties

00:42:56.570 --> 00:42:59.310
and allow us to develop
the code in a dynamic way.

00:42:59.310 --> 00:43:01.944
Think about what happened
with GPUs in the '90s

00:43:01.944 --> 00:43:04.360
when, all of a sudden, instead
of having a fixed pipeline,

00:43:04.360 --> 00:43:05.990
you could do flexible
things and render

00:43:05.990 --> 00:43:07.335
really interesting things.

00:43:07.335 --> 00:43:09.710
What if we connected, not just
accelerometers, and gyros,

00:43:09.710 --> 00:43:11.860
and compasses, but
entire systems so

00:43:11.860 --> 00:43:14.970
that even when the phone
is in low power mode,

00:43:14.970 --> 00:43:17.310
it can communicate with
nearby devices using

00:43:17.310 --> 00:43:18.800
Bluetooth low energy.

00:43:18.800 --> 00:43:21.350
This is something that I'm
incredibly excited about.

00:43:21.350 --> 00:43:24.130
And just to convey the power
of what this idea means,

00:43:24.130 --> 00:43:26.620
let's look at some
concrete examples.

00:43:26.620 --> 00:43:30.600
Suddenly, think about
it-- this whole discussion

00:43:30.600 --> 00:43:33.170
that I'm having with you
about lower power would almost

00:43:33.170 --> 00:43:34.910
become irrelevant
because you now

00:43:34.910 --> 00:43:37.630
have a platform to make things
really, really low power.

00:43:37.630 --> 00:43:40.210
And what you could do is you
could take that indoor location

00:43:40.210 --> 00:43:42.260
system and, even in
a deployed phone,

00:43:42.260 --> 00:43:45.990
make it run at low enough that
you could have it always on.

00:43:45.990 --> 00:43:49.671
Not only that, but you
could even detect sensors

00:43:49.671 --> 00:43:51.670
the same way that we
talked about the brainstem.

00:43:51.670 --> 00:43:53.930
You could detect falls like
when you fall out of bed.

00:43:53.930 --> 00:43:55.340
You could detect earthquakes.

00:43:55.340 --> 00:43:57.000
You could detect
even car crashes,

00:43:57.000 --> 00:43:59.280
and be able to
offer the user help.

00:43:59.280 --> 00:44:00.280
Now that's in the phone.

00:44:00.280 --> 00:44:03.290
But when we come to wear, it
becomes even more incredible

00:44:03.290 --> 00:44:05.040
because what we can
do is-- you might

00:44:05.040 --> 00:44:07.260
be able to walk up to a
door and just knock on it,

00:44:07.260 --> 00:44:08.930
and your phone would
detect your knock.

00:44:08.930 --> 00:44:11.346
And it would talk to the device
of [INAUDIBLE] [INAUDIBLE]

00:44:11.346 --> 00:44:12.660
and unlock it magically.

00:44:12.660 --> 00:44:14.160
You could even do weird things.

00:44:14.160 --> 00:44:17.050
Like imagine that you're into
juggling, any time you could

00:44:17.050 --> 00:44:18.830
juggle, we could detect
that, and give you

00:44:18.830 --> 00:44:21.780
statistics about how often you
juggle and something like that.

00:44:21.780 --> 00:44:24.090
And perhaps, just to twist
your brain a little bit,

00:44:24.090 --> 00:44:26.173
one of the really interesting
implications for me,

00:44:26.173 --> 00:44:28.380
as an old-time RPG
guy, is that we

00:44:28.380 --> 00:44:30.780
could build a location based
game where you literally

00:44:30.780 --> 00:44:31.700
cast spells.

00:44:31.700 --> 00:44:35.300
So as I do things like this
or like some other symbol,

00:44:35.300 --> 00:44:37.990
we could build a game around
recognizing when you make

00:44:37.990 --> 00:44:39.270
those symbols in real life.

00:44:39.270 --> 00:44:41.750
It really does open up
the exciting possibilities

00:44:41.750 --> 00:44:43.497
to be able to access
that platform.

00:44:43.497 --> 00:44:46.080
And with that, I'd really like
to thank you for your attention

00:44:46.080 --> 00:44:46.960
today.

00:44:46.960 --> 00:44:50.190
I think we're at a unique part
of the history of computing now

00:44:50.190 --> 00:44:54.080
with these ability to combine
the sensing, the computing,

00:44:54.080 --> 00:44:55.690
and communications ability.

00:44:55.690 --> 00:44:57.890
And we can use these to
simplify users' interactions

00:44:57.890 --> 00:44:58.610
with the device.

00:44:58.610 --> 00:45:00.310
We've added a
bunch of rich APIs.

00:45:00.310 --> 00:45:02.180
We hope that you use them.

00:45:02.180 --> 00:45:05.070
We can't wait to see what
you folks will build to make

00:45:05.070 --> 00:45:06.537
your apps context aware.

00:45:06.537 --> 00:45:08.370
Finally, Marc and I
will be standing outside

00:45:08.370 --> 00:45:10.530
to answer questions after this.

00:45:10.530 --> 00:45:13.080
And we have some special
talks about the Places API

00:45:13.080 --> 00:45:14.770
and Activity APIs tomorrow.

00:45:14.770 --> 00:45:17.220
And we'd love to hear
your feedback and thoughts

00:45:17.220 --> 00:45:18.120
at this page.

00:45:18.120 --> 00:45:20.480
Thank you, very
much, for your time.

