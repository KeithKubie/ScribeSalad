WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.880
[MUSIC PLAYING]

00:00:06.885 --> 00:00:07.760
JEROME DOCHEZ: Hello.

00:00:07.760 --> 00:00:08.560
Welcome.

00:00:08.560 --> 00:00:09.640
I'm Jerome Dochez.

00:00:09.640 --> 00:00:11.765
I'm a software
engineer at Google.

00:00:11.765 --> 00:00:13.390
CHRIS WARRINGTON:
I'm Chris Warrington.

00:00:13.390 --> 00:00:14.720
I'm also a software engineer.

00:00:14.720 --> 00:00:15.970
IZABELA ORLOWSKA: And I'm Iza.

00:00:15.970 --> 00:00:17.682
I'm also a software engineer.

00:00:17.682 --> 00:00:18.390
LEO SEI: Hi guys.

00:00:18.390 --> 00:00:19.030
I'm Leo.

00:00:19.030 --> 00:00:22.330
I'm a product manager.

00:00:22.330 --> 00:00:25.310
So we're here to talk
about the Gradle plugin.

00:00:25.310 --> 00:00:28.616
But, first, I want to
talk about build speed.

00:00:28.616 --> 00:00:30.490
You've already heard
from Karen this morning,

00:00:30.490 --> 00:00:32.946
who recently looked
at our data and had

00:00:32.946 --> 00:00:35.320
some interesting findings that
I wanted to share with you

00:00:35.320 --> 00:00:38.350
today in all transparency.

00:00:38.350 --> 00:00:41.050
The metrics that
you're going to see

00:00:41.050 --> 00:00:43.360
comes from developers
who opt in into sharing

00:00:43.360 --> 00:00:44.500
their data with us.

00:00:44.500 --> 00:00:46.780
So if that's your case,
thank you very much.

00:00:49.360 --> 00:00:52.060
So, first, we
looked at build time

00:00:52.060 --> 00:00:54.130
change a little
bit across a couple

00:00:54.130 --> 00:00:58.070
build times before and right
after an Android Gradle plugin

00:00:58.070 --> 00:00:59.310
upgrade.

00:00:59.310 --> 00:01:03.740
And so what you see here is
the immediate improvement

00:01:03.740 --> 00:01:05.500
in speed and percent.

00:01:05.500 --> 00:01:09.620
And you can see that, outside
of a minor regression in 3.1.2,

00:01:09.620 --> 00:01:12.290
we've been pretty
consistent at 7% or 8%

00:01:12.290 --> 00:01:16.490
and even 20% with 3.2.0.

00:01:16.490 --> 00:01:21.070
So we thought, OK, if everyone
upgrades to the latest

00:01:21.070 --> 00:01:25.300
3.2 or the latest release,
build speed should be getting

00:01:25.300 --> 00:01:28.630
faster and faster, right?

00:01:28.630 --> 00:01:30.760
Well, not exactly.

00:01:30.760 --> 00:01:34.240
Turns out that, when we looked
at build speed over time,

00:01:34.240 --> 00:01:37.810
it is getting slower and slower.

00:01:37.810 --> 00:01:40.330
And I don't want to call this
the build speed conundrum,

00:01:40.330 --> 00:01:43.150
but it got us a
little bit puzzled.

00:01:43.150 --> 00:01:44.990
How is it possible
that, on one end,

00:01:44.990 --> 00:01:49.730
we keep improving with every
release, and on the other end,

00:01:49.730 --> 00:01:54.050
we keep seeing build speed
gets slower and slower?

00:01:54.050 --> 00:01:55.700
After some exploration,
we realized

00:01:55.700 --> 00:01:58.850
that the build ecosystem
is very complex.

00:01:58.850 --> 00:02:01.160
And I'm a new guy at
Android, so I can tell you

00:02:01.160 --> 00:02:03.620
it is very complex for me.

00:02:03.620 --> 00:02:05.990
And it's rapidly evolving
with so many things

00:02:05.990 --> 00:02:08.435
that can impact your build.

00:02:08.435 --> 00:02:12.261
For example, your
apps are growing.

00:02:12.261 --> 00:02:13.260
You're adding more code.

00:02:13.260 --> 00:02:14.040
That's great.

00:02:14.040 --> 00:02:16.440
It can slow down your
build a little bit,

00:02:16.440 --> 00:02:19.550
but that's not the lion's share.

00:02:19.550 --> 00:02:23.960
Turns out that 96% of you use
some form of Gradle plugin

00:02:23.960 --> 00:02:26.180
outside of the
Android Gradle plugin,

00:02:26.180 --> 00:02:28.436
whether it's another Google
plugin or third party

00:02:28.436 --> 00:02:29.810
plugin or even
something that you

00:02:29.810 --> 00:02:32.470
wrote for your own app
or your own company.

00:02:32.470 --> 00:02:35.120
And when we took a look
at some of those plugins,

00:02:35.120 --> 00:02:38.760
they were not all
super optimized.

00:02:38.760 --> 00:02:42.420
There's also a lot of
annotation processors out there,

00:02:42.420 --> 00:02:44.880
and they sometimes
lack incrementality.

00:02:44.880 --> 00:02:48.510
So when you do a tiny change,
it has to recompile everything,

00:02:48.510 --> 00:02:51.660
and your build speed goes away.

00:02:51.660 --> 00:02:55.620
Some new languages-- like Java
8, for example, or Kotlin--

00:02:55.620 --> 00:02:57.690
can have some impact
on your speed.

00:02:57.690 --> 00:02:59.910
With Java 8, we mitigated
some of the impact

00:02:59.910 --> 00:03:02.040
by merging the dexing
and the desugaring

00:03:02.040 --> 00:03:05.730
together in one step with the 8
and working a lot with JetBrain

00:03:05.730 --> 00:03:10.720
to improve the Kotlin compiler
and annotation processor.

00:03:10.720 --> 00:03:13.170
There's also some
resource scaling issues

00:03:13.170 --> 00:03:14.570
if you have a lot of modules.

00:03:14.570 --> 00:03:16.610
Some of our existing
resource pipeline

00:03:16.610 --> 00:03:18.860
is not necessarily optimized.

00:03:18.860 --> 00:03:21.370
So you can see
that that's a lot.

00:03:21.370 --> 00:03:23.810
And when you add
all of this, it can

00:03:23.810 --> 00:03:27.290
have a pretty significant
impact on your build.

00:03:27.290 --> 00:03:29.870
And to top it off, a
recent survey that we did

00:03:29.870 --> 00:03:33.350
showed that 60% of
developers either do not

00:03:33.350 --> 00:03:37.400
analyze build speed at
all or do not know how to.

00:03:37.400 --> 00:03:40.650
So there's definitely an
awareness problem, as well,

00:03:40.650 --> 00:03:44.570
around what can cause
delay to your build.

00:03:44.570 --> 00:03:45.070
All right.

00:03:45.070 --> 00:03:46.980
So what can we do?

00:03:46.980 --> 00:03:49.520
Well, first, I want
to recognize that some

00:03:49.520 --> 00:03:52.160
of what I just
mentioned comes directly

00:03:52.160 --> 00:03:54.084
from us, Google at large.

00:03:54.084 --> 00:03:56.000
And we're really serious
about improving this.

00:03:56.000 --> 00:03:59.210
We're taking steps internally
to improve existing features, as

00:03:59.210 --> 00:04:01.355
well as the new one.

00:04:01.355 --> 00:04:04.350
But as I mentioned, there's
also an awareness problem

00:04:04.350 --> 00:04:07.140
and tooling issue.

00:04:07.140 --> 00:04:11.127
And we want to launch new
features and new attribution

00:04:11.127 --> 00:04:12.960
features that can help
you better understand

00:04:12.960 --> 00:04:14.910
what's going on with
your build and what

00:04:14.910 --> 00:04:17.260
is really impacting your build.

00:04:17.260 --> 00:04:20.539
And we'll cover this
in a little bit.

00:04:20.539 --> 00:04:24.800
We're also really doubling
down on performance features,

00:04:24.800 --> 00:04:27.320
working together with
Gradle, and there's

00:04:27.320 --> 00:04:30.115
a lot of new features that I'll
let Jerome, Chris, and Izabela

00:04:30.115 --> 00:04:30.740
share with you.

00:04:34.780 --> 00:04:36.845
JEROME DOCHEZ: Thank you.

00:04:36.845 --> 00:04:37.920
So let's get started.

00:04:37.920 --> 00:04:42.550
What did we add in the
latest 3.2 release?

00:04:42.550 --> 00:04:44.050
The first thing I
want to talk about

00:04:44.050 --> 00:04:46.810
is incrementality in
annotation processor

00:04:46.810 --> 00:04:50.010
that Leo, you did before.

00:04:50.010 --> 00:04:52.810
As you probably know,
Java C and even Kotlin C

00:04:52.810 --> 00:04:55.013
has been incremental
for quite some time.

00:04:55.013 --> 00:04:57.460
However, if you have
annotation processors,

00:04:57.460 --> 00:05:00.550
all of this incrementality
goes out of the door,

00:05:00.550 --> 00:05:02.960
and so it's a big problem.

00:05:02.960 --> 00:05:05.240
And so it has enormous
performance ramifications,

00:05:05.240 --> 00:05:07.240
because when we look at
our internal dashboards,

00:05:07.240 --> 00:05:09.730
we can see that the
JVM bytecode production

00:05:09.730 --> 00:05:12.820
tasks are the most consuming
task of all build time.

00:05:12.820 --> 00:05:14.320
So, basically, being
non-incremental

00:05:14.320 --> 00:05:16.010
is a huge problem.

00:05:16.010 --> 00:05:19.390
So Gradle, with [? Groupon ?]
and with Google,

00:05:19.390 --> 00:05:23.410
has come up with INCAP, which
is aimed at making annotation

00:05:23.410 --> 00:05:25.060
processors incremental.

00:05:25.060 --> 00:05:27.190
Now, there's really
two levels of support

00:05:27.190 --> 00:05:28.594
that we are aiming for.

00:05:28.594 --> 00:05:30.760
The first one is called
aggregating, which basically

00:05:30.760 --> 00:05:33.850
means that, if you change
a class, which is annotated

00:05:33.850 --> 00:05:36.640
with an annotation
of interest, we

00:05:36.640 --> 00:05:39.310
will have to recompile all the
classes which are annotated

00:05:39.310 --> 00:05:40.490
with the same annotations.

00:05:40.490 --> 00:05:42.490
So it's not exactly
incremental, but it's better

00:05:42.490 --> 00:05:45.280
than recompiling everything.

00:05:45.280 --> 00:05:47.110
The other one, which
is called isolating,

00:05:47.110 --> 00:05:49.990
which is much better,
much more fine grained,

00:05:49.990 --> 00:05:53.390
will allow you to recompile
only what has changed.

00:05:53.390 --> 00:05:55.390
So there is this different
levels of support.

00:05:55.390 --> 00:05:57.400
What is important to
realize for some of you

00:05:57.400 --> 00:06:01.030
is that, if you have annotation
processors yourself that you

00:06:01.030 --> 00:06:03.610
developed in-house, it
would be your responsibility

00:06:03.610 --> 00:06:07.490
to make those annotation
processors INCAP compliant.

00:06:07.490 --> 00:06:09.190
We are working hard
internally to make

00:06:09.190 --> 00:06:12.437
the most popular annotation
processors INCAP compliant,

00:06:12.437 --> 00:06:14.020
so we're going to
do Dagger, and we're

00:06:14.020 --> 00:06:16.190
going to do data binding
and all this kind of stuff.

00:06:16.190 --> 00:06:17.773
But if you have your
own, you're going

00:06:17.773 --> 00:06:20.610
to have to work on it yourself.

00:06:20.610 --> 00:06:24.280
And if you don't, we also plan
to make it very, very clear

00:06:24.280 --> 00:06:27.550
that, if we have to
revert our compilation

00:06:27.550 --> 00:06:29.370
to not be incremental,
we're going

00:06:29.370 --> 00:06:32.980
to make it very clear which
annotation processors are

00:06:32.980 --> 00:06:34.750
forcing us to not
be incremental,

00:06:34.750 --> 00:06:37.180
so if you're providing
those, expect

00:06:37.180 --> 00:06:39.520
to have some bad publicity
coming from us saying, yep,

00:06:39.520 --> 00:06:42.019
we are running a non-incremental
because of those annotation

00:06:42.019 --> 00:06:44.430
processes.

00:06:44.430 --> 00:06:47.340
The second thing I want to
talk about is App Bundle.

00:06:47.340 --> 00:06:49.480
So you must have
heard about it by now.

00:06:49.480 --> 00:06:52.330
In the past, when people
wanted to reduce the APK size,

00:06:52.330 --> 00:06:55.630
they had to do multi
APK, which resulted

00:06:55.630 --> 00:06:58.910
in a lot of manual steps
related to deployments.

00:06:58.910 --> 00:07:00.200
Was very complicated.

00:07:00.200 --> 00:07:02.330
So now what you can do is
basically create this App

00:07:02.330 --> 00:07:06.400
Bundle, which is a glorified
zip file with a universal APK

00:07:06.400 --> 00:07:10.600
in a specific format, which
cannot be immediately installed

00:07:10.600 --> 00:07:14.860
on a device but can be used by
the Play Store to precreate all

00:07:14.860 --> 00:07:17.910
these different APKs for all
the different devices that

00:07:17.910 --> 00:07:18.850
you're targeting.

00:07:18.850 --> 00:07:21.790
So you have got, fast delivery,
all these nice features

00:07:21.790 --> 00:07:23.407
without having to
do it yourself.

00:07:23.407 --> 00:07:25.240
Now, one of the thing
you need to understand

00:07:25.240 --> 00:07:29.002
as a developer using the
Android Gradle plugin

00:07:29.002 --> 00:07:30.460
is that there are
things which have

00:07:30.460 --> 00:07:31.751
changed because of that, right?

00:07:31.751 --> 00:07:33.430
For instance, you
know, you can define--

00:07:33.430 --> 00:07:35.909
if you use modularity, and
you have feature modules,

00:07:35.909 --> 00:07:37.450
for instance, you
can define a number

00:07:37.450 --> 00:07:41.110
of things inside of
those feature modules,

00:07:41.110 --> 00:07:45.070
yet the base module is
the one that will actually

00:07:45.070 --> 00:07:49.490
be providing some information,
even for the feature modules.

00:07:49.490 --> 00:07:52.480
So, for instance, the
application ID, the version

00:07:52.480 --> 00:07:56.230
code, soon the sign in
information, all of those

00:07:56.230 --> 00:07:57.730
comes from the base ID.

00:07:57.730 --> 00:08:01.600
In theory, we would want to
reduce the DSL [INAUDIBLE] type

00:08:01.600 --> 00:08:05.600
so that you could only
provide on the [INAUDIBLE]

00:08:05.600 --> 00:08:07.570
Gradle of each of
these feature modules

00:08:07.570 --> 00:08:10.950
the exact information that
we know we would be using,

00:08:10.950 --> 00:08:11.930
but we don't have time.

00:08:11.930 --> 00:08:13.720
So it's the same DSL
everywhere, and you

00:08:13.720 --> 00:08:16.540
have to be aware that some of it
will be ignored in the feature

00:08:16.540 --> 00:08:17.860
modules.

00:08:17.860 --> 00:08:20.170
Also, for instance, the
mapping file for a Bundle file

00:08:20.170 --> 00:08:24.590
will also be for
the base module.

00:08:24.590 --> 00:08:29.000
Now, when you add modularity
inside your application,

00:08:29.000 --> 00:08:32.500
it's relatively easier to build
[? level. ?] All you have to do

00:08:32.500 --> 00:08:35.229
is to use the right plugin,
as I described in this slide.

00:08:35.229 --> 00:08:38.500
At the base module, you
have the base functionality,

00:08:38.500 --> 00:08:41.710
and then you apply the
application plugin,

00:08:41.710 --> 00:08:43.120
which you have used for years.

00:08:43.120 --> 00:08:47.620
In a feature module, you can
apply the dynamic feature.

00:08:47.620 --> 00:08:51.040
Now, we have to declare
what special dependency

00:08:51.040 --> 00:08:54.220
from the base module to all
of the different features,

00:08:54.220 --> 00:08:56.600
and I will explain you
later why this is necessary,

00:08:56.600 --> 00:08:57.430
but it is something
that you need

00:08:57.430 --> 00:08:59.080
to understand is
that, obviously, you

00:08:59.080 --> 00:09:01.330
have a dependency from the
feature module to the base,

00:09:01.330 --> 00:09:02.913
but you also need
to make a dependency

00:09:02.913 --> 00:09:04.165
from the base to the features.

00:09:07.600 --> 00:09:12.550
As an example here, we've got
the [INAUDIBLE] shrinking flow,

00:09:12.550 --> 00:09:15.550
and I'm going to show how
this changes when you start

00:09:15.550 --> 00:09:18.070
introducing feature
modules and modularity

00:09:18.070 --> 00:09:19.490
inside your application.

00:09:19.490 --> 00:09:21.130
So, here, you've got
a simple example.

00:09:21.130 --> 00:09:22.420
You've got a base module.

00:09:22.420 --> 00:09:24.340
You've got three feature
modules, module A,

00:09:24.340 --> 00:09:26.920
module B, module C. So far,
nothing's too specific.

00:09:26.920 --> 00:09:30.320
Of course, each of these feature
modules depend on the base.

00:09:30.320 --> 00:09:33.220
Now, by adding this
DSL declaration,

00:09:33.220 --> 00:09:35.590
we are declaring that the
dependency, or the fact

00:09:35.590 --> 00:09:37.780
that those features--

00:09:37.780 --> 00:09:39.950
those module A, B and
C-- are feature modules.

00:09:39.950 --> 00:09:40.450
OK?

00:09:40.450 --> 00:09:42.580
So far, simple, but
you can see that now we

00:09:42.580 --> 00:09:45.190
have this dependency
going both ways.

00:09:47.700 --> 00:09:50.830
So when we go through the build
flow, the first thing that we

00:09:50.830 --> 00:09:54.621
do, obviously, is that we build
normally all the Java source

00:09:54.621 --> 00:09:55.120
files.

00:09:55.120 --> 00:09:58.210
We compile all the Java
source files into classes.jar.

00:09:58.210 --> 00:09:59.180
That's normal.

00:09:59.180 --> 00:10:01.090
That's the normal
process that we

00:10:01.090 --> 00:10:04.360
go through when we build each
of these different modules.

00:10:04.360 --> 00:10:07.450
But the thing that really
starts to differ when you're

00:10:07.450 --> 00:10:11.890
dealing with feature modules
is that we are publishing back

00:10:11.890 --> 00:10:16.410
all of these JAR files
back to the main module.

00:10:16.410 --> 00:10:18.574
And that's absolutely
necessary, because when

00:10:18.574 --> 00:10:19.990
we do the code
shrinking, you need

00:10:19.990 --> 00:10:21.910
to have a global view
of the application.

00:10:21.910 --> 00:10:24.490
You can't do a shrinking
just on the feature module,

00:10:24.490 --> 00:10:28.210
because you will not know how
and what the use of the base

00:10:28.210 --> 00:10:31.190
class is, for instance.

00:10:31.190 --> 00:10:33.790
So once you have those
published to the base,

00:10:33.790 --> 00:10:37.300
you can feed it to the
shrinker and the splitter,

00:10:37.300 --> 00:10:41.930
and, eventually, it's going to
create equivalent dex files.

00:10:41.930 --> 00:10:44.710
As you can guess, there is
more or less a one to one

00:10:44.710 --> 00:10:48.160
mapping between the original JAR
file containing the class files

00:10:48.160 --> 00:10:50.600
and the dex files
containing the dexes,

00:10:50.600 --> 00:10:52.511
but it's not exactly
a one to one.

00:10:52.511 --> 00:10:54.010
So, for instance,
let's say that you

00:10:54.010 --> 00:10:56.530
had classes that were
in your base module

00:10:56.530 --> 00:10:59.380
that you thought would be
shared by different features

00:10:59.380 --> 00:11:02.200
but only end up being
used by, say, Module B,

00:11:02.200 --> 00:11:04.870
then it's perfectly
legal for the splitter

00:11:04.870 --> 00:11:08.650
to decide that it wants to move
those classes into the dexB.jar

00:11:08.650 --> 00:11:11.909
instead of keeping them
inside the main dex.jar

00:11:11.909 --> 00:11:12.700
of the main module.

00:11:15.117 --> 00:11:17.200
Otherwise, you can more
or less imagine that there

00:11:17.200 --> 00:11:18.440
is a one to one mapping.

00:11:18.440 --> 00:11:21.010
So once this is done,
you've got all these dex

00:11:21.010 --> 00:11:24.770
files, which are still
residing in the base module.

00:11:24.770 --> 00:11:29.680
Now they're going to flow back
into the originating module,

00:11:29.680 --> 00:11:31.120
dynamic feature module.

00:11:31.120 --> 00:11:33.340
And we do that so
that you can have

00:11:33.340 --> 00:11:34.900
as much parallelism
in your build.

00:11:34.900 --> 00:11:37.630
So as you can see,
at the beginning,

00:11:37.630 --> 00:11:39.490
we had the
compilation happening.

00:11:39.490 --> 00:11:43.159
In each of the same modules, it
was potentially parallelized--

00:11:43.159 --> 00:11:44.950
depends on the machine
you have, but if you

00:11:44.950 --> 00:11:47.500
have a powerful machine, all
of those would run in parallel.

00:11:47.500 --> 00:11:49.750
Then we moved
everything to the base.

00:11:49.750 --> 00:11:51.280
Then it becomes
kind of a bottleneck

00:11:51.280 --> 00:11:54.400
for the build system, because it
has to wait for all the modules

00:11:54.400 --> 00:11:56.950
to be ready to be able
to do the shrinking.

00:11:56.950 --> 00:12:00.610
Well, once this is done, we
can move back the processing

00:12:00.610 --> 00:12:02.230
to each of the
[? same ?] modules.

00:12:02.230 --> 00:12:06.074
So you can see that adding
modularity to your application

00:12:06.074 --> 00:12:07.990
may be a good software
practice, but it's also

00:12:07.990 --> 00:12:10.406
a good practice in terms of
the build, because we're going

00:12:10.406 --> 00:12:12.250
to get much faster over time.

00:12:12.250 --> 00:12:16.810
We move as much stuff as we
can toward the lifts of all

00:12:16.810 --> 00:12:19.720
of these modules, and we can
run all of those in parallel

00:12:19.720 --> 00:12:20.620
as much as possible.

00:12:23.220 --> 00:12:26.340
Once this is done in parallel--
once this is pushed back

00:12:26.340 --> 00:12:28.294
to whichever feature
module, we can then

00:12:28.294 --> 00:12:30.210
resume the normal
processing, and, eventually,

00:12:30.210 --> 00:12:33.660
we will create all the
necessary APKs or all

00:12:33.660 --> 00:12:37.780
the necessary artifacts to be
able to create the App Bundle.

00:12:37.780 --> 00:12:38.280
All right?

00:12:38.280 --> 00:12:40.020
So all of those,
again, is in parallel.

00:12:40.020 --> 00:12:42.840
Now, obviously, the shrinker--
the fact it's a little bit

00:12:42.840 --> 00:12:44.640
of a bottleneck, like
I explained earlier,

00:12:44.640 --> 00:12:46.530
is usually not a
problem, because--

00:12:46.530 --> 00:12:48.360
not a problem for
debug build, at least,

00:12:48.360 --> 00:12:51.420
because, usually, people do not
use shrinker-- code shrinking

00:12:51.420 --> 00:12:52.660
during the debug builds.

00:12:52.660 --> 00:12:55.180
It's only done for
the release builds.

00:12:55.180 --> 00:12:59.370
But we really try to limit these
bottlenecks as much as we can,

00:12:59.370 --> 00:13:01.110
and Chris will
explain also how we

00:13:01.110 --> 00:13:04.400
have enhanced a lot
the resource processing

00:13:04.400 --> 00:13:09.660
with this type of improvements.

00:13:09.660 --> 00:13:12.630
Another thing that we
added in 3.2 was D8.

00:13:12.630 --> 00:13:18.010
So D8 is the new JVM byte
codes to dex file translator.

00:13:18.010 --> 00:13:21.500
We will eventually remove the
old one, which was called DX.

00:13:21.500 --> 00:13:23.960
If you still are
using DX, you really

00:13:23.960 --> 00:13:25.790
need to stop
[INAUDIBLE],, because we

00:13:25.790 --> 00:13:26.990
are going to remove it.

00:13:26.990 --> 00:13:28.490
And once we removed
it, you will not

00:13:28.490 --> 00:13:30.210
be able to upgrade any longer.

00:13:30.210 --> 00:13:34.040
So if you are using DX because
you have issues with D8,

00:13:34.040 --> 00:13:36.740
you must file a bug
immediately and follow through

00:13:36.740 --> 00:13:39.110
to figure out what is wrong,
if it's with your build

00:13:39.110 --> 00:13:41.340
or if it's with D8 itself.

00:13:41.340 --> 00:13:43.656
Otherwise, you're going
to get stuck in the past.

00:13:43.656 --> 00:13:45.380
R8 is going to
follow more or less

00:13:45.380 --> 00:13:47.480
the same path,
meaning, like, it's

00:13:47.480 --> 00:13:49.340
available right now to try.

00:13:49.340 --> 00:13:53.300
We are very happy with the
results we are getting so far,

00:13:53.300 --> 00:13:54.440
so it's very stable.

00:13:54.440 --> 00:13:56.780
You should definitely try it.

00:13:56.780 --> 00:13:59.047
Eventually, it
will become stable,

00:13:59.047 --> 00:14:01.380
and you can guess what's going
to happen to the old code

00:14:01.380 --> 00:14:02.930
shrinker to plug out.

00:14:02.930 --> 00:14:05.270
Eventually, we will also
remove it and completely

00:14:05.270 --> 00:14:07.502
replace it with R8.

00:14:07.502 --> 00:14:09.710
If you want more details,
there is a session tomorrow

00:14:09.710 --> 00:14:12.410
that will give you a lot more
technical details about how

00:14:12.410 --> 00:14:16.341
these two libraries
are implemented.

00:14:16.341 --> 00:14:16.840
OK.

00:14:16.840 --> 00:14:20.730
Let's talk a little bit
about what's next in 3.3.

00:14:20.730 --> 00:14:26.770
So the first thing I want
to talk about is lazy tasks.

00:14:26.770 --> 00:14:29.560
So Gradle has introduced
the concept of lazy task,

00:14:29.560 --> 00:14:32.800
and the lazy task is-- you
should really understand it

00:14:32.800 --> 00:14:36.340
as a task that will only get
initialized and configured

00:14:36.340 --> 00:14:39.450
if it is on the
execution task graph.

00:14:39.450 --> 00:14:42.779
So that means, for instance, if
you got-- let's keep it simple.

00:14:42.779 --> 00:14:45.070
You've got two variants, the
debug variant, the release

00:14:45.070 --> 00:14:46.360
variant.

00:14:46.360 --> 00:14:49.120
And if you're coding
assemble debug,

00:14:49.120 --> 00:14:54.065
there's no need to initialize
or to configure any of the tasks

00:14:54.065 --> 00:14:56.640
for later to the
release variant.

00:14:56.640 --> 00:14:59.270
And so what we used
to do, unfortunately--

00:14:59.270 --> 00:15:02.320
so this was done before in
this particular example, where

00:15:02.320 --> 00:15:04.390
we used to create all
the tasks-- we still

00:15:04.390 --> 00:15:06.430
have to do that-- but
at the creation time,

00:15:06.430 --> 00:15:08.060
we were also configuring them.

00:15:08.060 --> 00:15:10.330
So we were ending up
configuring all the tasks

00:15:10.330 --> 00:15:13.150
for debug variants and all the
tasks for release variants,

00:15:13.150 --> 00:15:15.550
even though only the
debug were eventually

00:15:15.550 --> 00:15:17.670
going to be executed.

00:15:17.670 --> 00:15:19.930
With lazy task,
Gradle is giving us

00:15:19.930 --> 00:15:24.490
the tool to basically delay
all of this initialization

00:15:24.490 --> 00:15:27.950
until it knows that those
tasks will be executed.

00:15:27.950 --> 00:15:30.250
Now, when I say executed,
it's not entirely true,

00:15:30.250 --> 00:15:33.970
because what it really
means is that it's

00:15:33.970 --> 00:15:35.980
going to be up to
date checked, meaning

00:15:35.980 --> 00:15:39.100
it's going to look if
the task needs to be run

00:15:39.100 --> 00:15:41.260
or not by running its
up to date checks.

00:15:41.260 --> 00:15:43.030
But potentially,
at least, the task

00:15:43.030 --> 00:15:45.070
is on the execution
task graph and may be

00:15:45.070 --> 00:15:49.050
executed if it's out of date.

00:15:49.050 --> 00:15:53.170
So how do you do lazy tasks?

00:15:53.170 --> 00:15:56.040
It's basically very
similar to the old style.

00:15:56.040 --> 00:15:58.230
Instead of doing create,
you call register.

00:15:58.230 --> 00:16:00.949
But you can see that now the
configuration code, which

00:16:00.949 --> 00:16:02.490
is in blue here,
where you initialize

00:16:02.490 --> 00:16:04.500
the input for the
value, will only

00:16:04.500 --> 00:16:08.100
be called if the task is on
the execution task graph.

00:16:08.100 --> 00:16:11.580
Now, we used to really
pay a lot of attention

00:16:11.580 --> 00:16:13.950
for all of our
configuration tasks

00:16:13.950 --> 00:16:17.274
to make this configuration
block as lean as possible,

00:16:17.274 --> 00:16:18.690
because they were
always executed,

00:16:18.690 --> 00:16:20.564
so if you were to do,
you know, Gradle tasks,

00:16:20.564 --> 00:16:23.200
it would always execute
all of this configuration.

00:16:23.200 --> 00:16:25.230
So we tried to keep
it as lean as possible

00:16:25.230 --> 00:16:28.440
with no access to disk,
no access to network,

00:16:28.440 --> 00:16:29.430
for instance.

00:16:29.430 --> 00:16:31.410
Now it's probably
a little bit more

00:16:31.410 --> 00:16:36.230
OK to do more work in
those configurations

00:16:36.230 --> 00:16:39.050
if you really have to, but you
have to remember two things.

00:16:39.050 --> 00:16:44.440
First, if you do real
work, it will still

00:16:44.440 --> 00:16:48.550
impact your build time, because
the configuration time is still

00:16:48.550 --> 00:16:50.565
a mono threaded event
in Gradle, meaning

00:16:50.565 --> 00:16:52.940
all of the configuration will
happen one after the other.

00:16:52.940 --> 00:16:55.030
So the more you do, the
longer it will take.

00:16:55.030 --> 00:16:56.890
And you already know
today that, you know,

00:16:56.890 --> 00:16:58.980
configuration time
happens all the time.

00:16:58.980 --> 00:17:00.640
It's very annoying.

00:17:00.640 --> 00:17:02.890
We are really trying to
reduce it to the bare minimum,

00:17:02.890 --> 00:17:05.540
but any time is really annoying.

00:17:05.540 --> 00:17:09.349
The second thing is to
not look up tasks anymore.

00:17:09.349 --> 00:17:11.890
So when you have, like, build
a Gradle customization--

00:17:11.890 --> 00:17:15.190
a lot of people are, like,
doing project, get task by name,

00:17:15.190 --> 00:17:16.770
or kind of stuff like that--

00:17:16.770 --> 00:17:19.329
this will actually
look up the task

00:17:19.329 --> 00:17:22.530
and initialize it
and configure it.

00:17:22.530 --> 00:17:24.160
And if you do that,
it will not only

00:17:24.160 --> 00:17:25.720
do that for the
task itself, but all

00:17:25.720 --> 00:17:27.490
of its transitive
dependencies, as well,

00:17:27.490 --> 00:17:29.465
all the tasks its users
and all the output

00:17:29.465 --> 00:17:30.590
and all this kind of stuff.

00:17:30.590 --> 00:17:32.048
So you basically
have a good chance

00:17:32.048 --> 00:17:34.210
of initializing
your entire world.

00:17:34.210 --> 00:17:37.980
Instead of doing that,
you should get a provider

00:17:37.980 --> 00:17:41.200
and get a lazy
object of the task

00:17:41.200 --> 00:17:44.540
itself and use that to
register your dependency.

00:17:44.540 --> 00:17:47.950
Now, what you can also do
if you want to have access

00:17:47.950 --> 00:17:52.690
to the output of a task is
use that provider and map

00:17:52.690 --> 00:17:57.190
the output using this type
of API to get a provider,

00:17:57.190 --> 00:17:59.650
so it's basically a
promise on the folder

00:17:59.650 --> 00:18:01.090
or a promise out
of a regular file

00:18:01.090 --> 00:18:03.670
that a task that may
execute will give you later.

00:18:03.670 --> 00:18:05.470
You can see how the
level of interactions

00:18:05.470 --> 00:18:06.406
you are getting here.

00:18:06.406 --> 00:18:07.780
But, eventually,
it will give you

00:18:07.780 --> 00:18:11.230
the idea that you can get
an object which represents

00:18:11.230 --> 00:18:14.620
the output of a task,
and that object does not

00:18:14.620 --> 00:18:15.910
initialize the task itself.

00:18:15.910 --> 00:18:18.820
Getting this provider does
not initialize the task,

00:18:18.820 --> 00:18:22.300
does not force it to run,
and it's really lazy.

00:18:22.300 --> 00:18:24.992
And it contains also the
dependency information,

00:18:24.992 --> 00:18:26.950
which means you don't
have to register yourself

00:18:26.950 --> 00:18:30.370
as a dependent of the task,
producing this output folder.

00:18:30.370 --> 00:18:32.800
Just holding the object
itself, the provider,

00:18:32.800 --> 00:18:34.780
will allow you to not
only get the object,

00:18:34.780 --> 00:18:36.400
but also register
your dependency

00:18:36.400 --> 00:18:38.020
on whatever is producing it.

00:18:38.020 --> 00:18:41.020
Eventually, you can do a
get, and that will give you

00:18:41.020 --> 00:18:43.330
the actual task and
the actual object

00:18:43.330 --> 00:18:45.580
that you can use to
configure your own task.

00:18:45.580 --> 00:18:47.660
So, here, when Bar is
getting configured,

00:18:47.660 --> 00:18:49.634
Food gets configured,
and, eventually,

00:18:49.634 --> 00:18:51.550
all the dependency of
Food will get configured

00:18:51.550 --> 00:18:52.840
and so on and so forth.

00:18:52.840 --> 00:18:54.970
So you can see how
lazy this is becoming.

00:18:54.970 --> 00:18:56.470
We are retrofitting
all of our tasks

00:18:56.470 --> 00:18:59.900
to become [INAUDIBLE]
providers and stuff like that.

00:18:59.900 --> 00:19:01.900
So if you use
customization a lot,

00:19:01.900 --> 00:19:05.510
you really need to look
into these two APIs in 3.3.

00:19:05.510 --> 00:19:08.260
And now Chris will talk about
some of the other improvements

00:19:08.260 --> 00:19:10.254
we've made.

00:19:10.254 --> 00:19:11.170
CHRIS WARRINGTON: Yes.

00:19:11.170 --> 00:19:16.090
Another optimisation to the
build process coming up in 3.3

00:19:16.090 --> 00:19:18.640
is Light R classes.

00:19:18.640 --> 00:19:20.560
Previously, the
Android Gradle plugin

00:19:20.560 --> 00:19:23.020
would generate an R.java
for every single dependency

00:19:23.020 --> 00:19:25.450
in every subproject
and then compile them

00:19:25.450 --> 00:19:27.910
alongside your actual classes.

00:19:27.910 --> 00:19:29.830
In Android Gradle
plugin 3.3, it just

00:19:29.830 --> 00:19:33.790
generates a JAR containing
the class directly.

00:19:33.790 --> 00:19:36.130
Especially for builds with
many library subprojects,

00:19:36.130 --> 00:19:39.400
and lots of dependencies, this
avoids a lot of compilation,

00:19:39.400 --> 00:19:44.230
a lot of I/O. For some
large multi module builds,

00:19:44.230 --> 00:19:46.630
we actually saw double
digit percentage and speed

00:19:46.630 --> 00:19:50.930
ups when building from
clean due to this change.

00:19:50.930 --> 00:19:54.350
So the R class system
in Android Studio 3.3

00:19:54.350 --> 00:19:56.880
has been rewritten to simulate
all of these R classes

00:19:56.880 --> 00:20:00.700
in memory rather than
relying on the ones on disk.

00:20:00.700 --> 00:20:04.560
Having this, as well as enabling
this optimization of the build,

00:20:04.560 --> 00:20:06.750
it actually speeds up
indexing in Android Studio,

00:20:06.750 --> 00:20:11.130
as well, even for projects
with all the Gradle plugins.

00:20:11.130 --> 00:20:13.980
This does, however, break
some Gradle plugins that

00:20:13.980 --> 00:20:15.990
depend on reading
the R file directly,

00:20:15.990 --> 00:20:19.610
including [? Butter Knife, ?]
which I'm working on fixing,

00:20:19.610 --> 00:20:22.530
and it's implemented
for library use in 3.3,

00:20:22.530 --> 00:20:24.030
and we're working
on implementing it

00:20:24.030 --> 00:20:27.770
for applications and tests, too.

00:20:27.770 --> 00:20:30.510
As Jerome mentioned
earlier, Gradle [INAUDIBLE]

00:20:30.510 --> 00:20:33.010
for incremental
annotation processing,

00:20:33.010 --> 00:20:34.770
but it does need
support from annotation

00:20:34.770 --> 00:20:36.820
processes themselves.

00:20:36.820 --> 00:20:39.360
And he said that we're
working to support

00:20:39.360 --> 00:20:41.430
the most popular annotation
processes, including

00:20:41.430 --> 00:20:45.810
Dagger, room, glide, auto
value, and some others.

00:20:45.810 --> 00:20:47.880
We're also working to
re-architect data mining

00:20:47.880 --> 00:20:49.950
to allow it to be an
isolated annotation

00:20:49.950 --> 00:20:53.010
processor, speeding up your
incremental [INAUDIBLE] even

00:20:53.010 --> 00:20:54.270
more.

00:20:54.270 --> 00:20:56.610
We also want to help you
understand that build time

00:20:56.610 --> 00:20:58.770
impact of annotation processes.

00:20:58.770 --> 00:21:01.220
So we want to
report to you, like,

00:21:01.220 --> 00:21:03.930
which annotation processes
was time spent in,

00:21:03.930 --> 00:21:06.862
and how much did they cost?

00:21:06.862 --> 00:21:09.760
On that theme, there
are several other areas

00:21:09.760 --> 00:21:12.040
we want to give you better
insight into your builds,

00:21:12.040 --> 00:21:13.590
easily and simply.

00:21:13.590 --> 00:21:16.640
So if you're using
annotation processes,

00:21:16.640 --> 00:21:18.640
it's really critical that
you have that insight,

00:21:18.640 --> 00:21:20.920
because they're
often a bottleneck

00:21:20.920 --> 00:21:24.660
for incremental builds, for
a lot of builds that we see.

00:21:24.660 --> 00:21:26.530
When a Gradle task
causes you trouble,

00:21:26.530 --> 00:21:29.490
it's really helpful to know the
Gradle plugin or the scripts

00:21:29.490 --> 00:21:32.520
where it was created and
what triggered it to run,

00:21:32.520 --> 00:21:37.618
and we're working to make
finding that out more easy.

00:21:37.618 --> 00:21:40.610
We also want to help you
find these types of issues,

00:21:40.610 --> 00:21:42.850
even if you're not
actively looking for them.

00:21:42.850 --> 00:21:46.130
So longer term, we want
Android Studio to flag

00:21:46.130 --> 00:21:48.620
if there is an issue
or if something

00:21:48.620 --> 00:21:50.480
changed and regressed.

00:21:50.480 --> 00:21:52.090
And we'll point you
towards the Gradle

00:21:52.090 --> 00:21:55.152
build scan, which is a
powerful tool for getting

00:21:55.152 --> 00:21:57.110
a bit of insight into
how your build's working.

00:21:59.740 --> 00:22:00.240
OK.

00:22:00.240 --> 00:22:05.010
So on from these kind of better
insights to complete rewrites,

00:22:05.010 --> 00:22:08.480
Android resource namespacing.

00:22:08.480 --> 00:22:11.120
Resource namespacing is
a completely new pipeline

00:22:11.120 --> 00:22:13.610
for compiling and linking
Android resources.

00:22:13.610 --> 00:22:16.170
So we're actually doing
this for two reasons.

00:22:16.170 --> 00:22:20.962
Firstly, speed up the build and
make it easier to understand.

00:22:20.962 --> 00:22:23.170
Secondly, we want to better
support dynamic features.

00:22:26.160 --> 00:22:28.890
Looking at how things work
now, in the existing resource

00:22:28.890 --> 00:22:31.080
pipeline, there are two
namespaces, the Android

00:22:31.080 --> 00:22:33.393
platform and everything else.

00:22:33.393 --> 00:22:36.234
That means that, if you
have two libraries--

00:22:36.234 --> 00:22:38.650
the defining resource of the
same name and the same type--

00:22:38.650 --> 00:22:41.100
the resource manager
has to pick one,

00:22:41.100 --> 00:22:43.930
and it's not always clear
what the right thing to do is

00:22:43.930 --> 00:22:46.592
or even that it's
happening at all.

00:22:46.592 --> 00:22:49.320
This actually also makes
splitting your APK up

00:22:49.320 --> 00:22:52.320
into several dynamic
features much more difficult.

00:22:52.320 --> 00:22:54.960
As each dynamic feature
is shipped separately,

00:22:54.960 --> 00:22:56.820
where those resources
come from and where

00:22:56.820 --> 00:22:59.960
they go is really important.

00:22:59.960 --> 00:23:02.070
With resource
namespacing, each library

00:23:02.070 --> 00:23:04.260
is compiled and linked
separately, and then

00:23:04.260 --> 00:23:07.492
linked together
into the final APKs.

00:23:07.492 --> 00:23:11.680
The R class in applications
would no longer have final IDs.

00:23:11.680 --> 00:23:14.190
And then when you're using
resources from both XML

00:23:14.190 --> 00:23:16.830
and from Java, you need
to be explicit about where

00:23:16.830 --> 00:23:18.070
they came from.

00:23:18.070 --> 00:23:20.195
So each resource is only
listed in the archives

00:23:20.195 --> 00:23:21.570
from the library
that defined it,

00:23:21.570 --> 00:23:24.450
and in XML, you need to use
the namespace of the resource

00:23:24.450 --> 00:23:26.316
to refer to it.

00:23:26.316 --> 00:23:29.770
This also means the resources
no longer implicitly override

00:23:29.770 --> 00:23:32.770
one another just because
they have the same name.

00:23:32.770 --> 00:23:35.560
For cases where you needed these
overrides in the application,

00:23:35.560 --> 00:23:39.100
we're working a new way
to do that explicitly.

00:23:39.100 --> 00:23:41.400
AARs that we generate
from namespace libraries

00:23:41.400 --> 00:23:42.990
will be backwards
compatible, so you

00:23:42.990 --> 00:23:45.930
can have all the benefits
of namespacing yourself

00:23:45.930 --> 00:23:47.580
but not impose it
on your consumers

00:23:47.580 --> 00:23:48.830
until they're ready to switch.

00:23:51.235 --> 00:23:51.735
OK.

00:23:51.735 --> 00:23:54.350
Passing onto Izabela to tell you
a bit more about the details.

00:23:54.350 --> 00:23:55.810
IZABELA ORLOWSKA: Thank you.

00:23:55.810 --> 00:23:59.650
OK, now that we know what
resource namespacing is, let's

00:23:59.650 --> 00:24:02.080
move on to how
to, in the future,

00:24:02.080 --> 00:24:04.570
namespace your app or library.

00:24:04.570 --> 00:24:07.810
You might find yourself
asking questions like, where's

00:24:07.810 --> 00:24:09.100
that resource coming from?

00:24:09.100 --> 00:24:12.250
Or, what is the proper syntax?

00:24:12.250 --> 00:24:15.940
Or, how do I even
namespace my dependencies?

00:24:15.940 --> 00:24:17.740
Well, the answer to
all these questions

00:24:17.740 --> 00:24:19.720
is, we'll fix it for you.

00:24:24.190 --> 00:24:27.510
So the solution is automatic
namespacing or auto

00:24:27.510 --> 00:24:29.260
namespacing, for short.

00:24:29.260 --> 00:24:31.090
There are two main parts here.

00:24:31.090 --> 00:24:33.910
First is the automatic
rewriting tool

00:24:33.910 --> 00:24:37.660
in the IDE, which will help
you migrate your local modules

00:24:37.660 --> 00:24:39.030
to be namespaced.

00:24:39.030 --> 00:24:43.320
And the second one are
the transforms and tasks

00:24:43.320 --> 00:24:45.680
in the Gradle plugin
that will rewrite

00:24:45.680 --> 00:24:51.660
your remote dependencies under
the hood, no action required.

00:24:51.660 --> 00:24:54.980
Here is an example
dependency graph.

00:24:54.980 --> 00:24:58.300
The blue notes are
local modules that

00:24:58.300 --> 00:25:01.650
can be rewritten
using the IDE tool.

00:25:01.650 --> 00:25:04.660
The three orange notes
are not namespaced,

00:25:04.660 --> 00:25:09.010
classic remote libraries that
will be automatically rewritten

00:25:09.010 --> 00:25:10.420
by the AGP.

00:25:10.420 --> 00:25:13.270
This means all the
resources, classes,

00:25:13.270 --> 00:25:16.660
the manifests will be rewritten
to use the full resource

00:25:16.660 --> 00:25:18.220
namespace.

00:25:18.220 --> 00:25:21.010
And, finally, the
green notes are--

00:25:21.010 --> 00:25:23.980
they represent dependencies
that are already namespaced,

00:25:23.980 --> 00:25:27.920
so they will not
be modified at all.

00:25:27.920 --> 00:25:29.510
Let's see what
types of changes we

00:25:29.510 --> 00:25:32.500
can see after this
migration takes place.

00:25:32.500 --> 00:25:35.940
In the bytecode or
Kotlin and Java sources,

00:25:35.940 --> 00:25:38.090
you can see that,
now, there will

00:25:38.090 --> 00:25:40.340
be different R classes present.

00:25:40.340 --> 00:25:43.160
If a resource was defined
in a different module

00:25:43.160 --> 00:25:46.700
or a remote library, you will
see the package of the R class

00:25:46.700 --> 00:25:50.630
will change to
match that package.

00:25:50.630 --> 00:25:52.830
In the XML resource references--

00:25:52.830 --> 00:25:55.820
like in the values files
or in the manifest--

00:25:55.820 --> 00:25:57.500
you will see the
new namespace appear

00:25:57.500 --> 00:26:00.110
between the at symbol and
the type of the resource,

00:26:00.110 --> 00:26:03.020
similar to the
Android namespace.

00:26:03.020 --> 00:26:05.260
And, finally,
another way resources

00:26:05.260 --> 00:26:08.680
can be referenced is in
attributes-- for example,

00:26:08.680 --> 00:26:09.880
in layouts.

00:26:09.880 --> 00:26:12.760
Here, the XML namespace
will be modified

00:26:12.760 --> 00:26:16.840
to point to the correct
package, instead of res auto,

00:26:16.840 --> 00:26:20.990
and the attribute will use
this new namespace, as well.

00:26:20.990 --> 00:26:23.670
And since we're already
on the topic of resources,

00:26:23.670 --> 00:26:26.310
let's talk about
resource visibility.

00:26:26.310 --> 00:26:30.170
So probably many of you
created an Android library

00:26:30.170 --> 00:26:32.540
with a lot of effort into
declaring which resources

00:26:32.540 --> 00:26:37.043
are public and then published
this AAR with a public.txt,

00:26:37.043 --> 00:26:40.700
only for consumers to ignore it.

00:26:40.700 --> 00:26:44.470
This currently is
only a Lint Warning.

00:26:44.470 --> 00:26:47.890
This code compiles and
runs fine at runtime,

00:26:47.890 --> 00:26:51.880
completely ignoring the intended
visibility of the resource.

00:26:51.880 --> 00:26:56.450
I'm sure many of you actually
ignore these warnings, as well.

00:26:56.450 --> 00:26:56.950
Great.

00:26:56.950 --> 00:27:00.300
So to combat this, we want to
introduce stricter resource

00:27:00.300 --> 00:27:01.020
visibility.

00:27:01.020 --> 00:27:05.990
So these violations will now
become build errors instead,

00:27:05.990 --> 00:27:09.050
so it will catch them
early, and we will introduce

00:27:09.050 --> 00:27:11.270
three levels of visibility--

00:27:11.270 --> 00:27:12.740
one, public.

00:27:12.740 --> 00:27:14.990
This means these
resources will be present

00:27:14.990 --> 00:27:18.020
both in the public R
classes of the consumers

00:27:18.020 --> 00:27:22.490
and the private R classes
for that local module.

00:27:22.490 --> 00:27:27.290
Private resources only
present in private R classes.

00:27:27.290 --> 00:27:31.050
And, last, private
XML only resources.

00:27:31.050 --> 00:27:35.040
They will be not present
in any R classes at all.

00:27:35.040 --> 00:27:41.840
Instead, you can only reference
them from other XML files

00:27:41.840 --> 00:27:44.180
within that module.

00:27:44.180 --> 00:27:47.420
This will result in
smaller R classes, both

00:27:47.420 --> 00:27:52.960
compile and runtime, and also
resource hermetization similar

00:27:52.960 --> 00:27:55.960
to the class or method
of hermetization

00:27:55.960 --> 00:27:58.240
currently in Java or Kotlin.

00:27:58.240 --> 00:28:00.050
So with that, Leo?

00:28:00.050 --> 00:28:01.450
LEO SEI: Thank you.

00:28:01.450 --> 00:28:03.800
[APPLAUSE]

00:28:05.680 --> 00:28:06.490
All right.

00:28:06.490 --> 00:28:09.790
So, as you can see, we're
working on a lot of things,

00:28:09.790 --> 00:28:13.710
and many of which we hope
would help with build speed.

00:28:13.710 --> 00:28:15.984
Going back to my point
about awareness and tooling,

00:28:15.984 --> 00:28:17.400
I want to share
some of the things

00:28:17.400 --> 00:28:21.270
that you can do today to
understand your build better

00:28:21.270 --> 00:28:24.560
and improve its performances.

00:28:24.560 --> 00:28:27.335
The first things is to upgrade.

00:28:27.335 --> 00:28:31.860
If you recall my first graph, we
do improve with every release,

00:28:31.860 --> 00:28:34.430
and so if you really care
about your build speed,

00:28:34.430 --> 00:28:37.730
the best thing to do is
to upgrade to the latest--

00:28:37.730 --> 00:28:41.370
Stable, Beta, Canary, whichever
you feel most comfortable with.

00:28:45.018 --> 00:28:46.486
Down to toolings.

00:28:46.486 --> 00:28:48.110
There are some tools
out there that you

00:28:48.110 --> 00:28:52.020
can start leveraging to
better understand your builds.

00:28:52.020 --> 00:28:55.540
One that I really
like is --scan.

00:28:55.540 --> 00:28:57.590
It's a free tool from Gradle.

00:28:57.590 --> 00:29:01.480
It uploads some of your build
data into Gradle servers

00:29:01.480 --> 00:29:04.760
and then provides very
comprehensive dashboards

00:29:04.760 --> 00:29:08.380
around task durations,
plugins, dependencies,

00:29:08.380 --> 00:29:09.941
and many, many more things.

00:29:09.941 --> 00:29:12.190
So if you're trying to
understand what's going on with

00:29:12.190 --> 00:29:13.810
your build-- why is it slow?--

00:29:13.810 --> 00:29:17.020
this is a very, very
useful resource to use.

00:29:20.107 --> 00:29:22.380
If sharing some of your
build data with Gradle

00:29:22.380 --> 00:29:25.020
is not something you
feel comfortable doing,

00:29:25.020 --> 00:29:29.210
here's the poor man's version
of it, which is --profile.

00:29:29.210 --> 00:29:32.640
--profile would create
a local HTML file

00:29:32.640 --> 00:29:34.680
that you can open
in a browser to show

00:29:34.680 --> 00:29:37.035
some information
about your build.

00:29:37.035 --> 00:29:39.600
It's definitely not
as rich as the --scan,

00:29:39.600 --> 00:29:43.290
but it provides some
information and remains local.

00:29:43.290 --> 00:29:47.760
You can combine it with --info,
which gives you information

00:29:47.760 --> 00:29:49.330
on why a given task ran.

00:29:51.840 --> 00:29:55.160
Another tip, which is more
of a continuous request,

00:29:55.160 --> 00:29:57.666
is to file a bug.

00:29:57.666 --> 00:30:00.930
We really try to test
all of our releases

00:30:00.930 --> 00:30:04.184
on as many environments
and use cases that we can,

00:30:04.184 --> 00:30:06.600
but there's always edge cases
and different configurations

00:30:06.600 --> 00:30:07.840
out there.

00:30:07.840 --> 00:30:11.310
So please file bugs when
you encounter issues.

00:30:11.310 --> 00:30:15.080
And when you do file a bug,
please include a scan with it.

00:30:15.080 --> 00:30:18.939
It really helps us go
deeper into the issue

00:30:18.939 --> 00:30:20.230
and understand what's going on.

00:30:23.850 --> 00:30:26.880
Last but not least, if
you're writing plugins,

00:30:26.880 --> 00:30:31.410
whether it's for you, to publish
them, or even just customize

00:30:31.410 --> 00:30:33.110
a little bit your
build file, here

00:30:33.110 --> 00:30:36.650
is a set of tips to follow.

00:30:36.650 --> 00:30:40.870
First, as Jerome alluded
to, configuration

00:30:40.870 --> 00:30:45.020
is really just to set up tasks,
not really do anything else.

00:30:45.020 --> 00:30:47.180
And as we mentioned
earlier, remember,

00:30:47.180 --> 00:30:50.660
if you need to compute
things for up to date checks,

00:30:50.660 --> 00:30:52.790
you can always use
provider and suppliers

00:30:52.790 --> 00:30:54.740
to only run those
checks if your task is

00:30:54.740 --> 00:30:58.130
part of the active graph.

00:30:58.130 --> 00:31:01.310
For example, in
configuration, you

00:31:01.310 --> 00:31:06.260
should not do things like
query get, read a file,

00:31:06.260 --> 00:31:10.100
search for a connected
device, or compute anything.

00:31:10.100 --> 00:31:13.200
Configuration is really just
a place to set up tasks,

00:31:13.200 --> 00:31:16.764
and it's the place
to set up all tasks,

00:31:16.764 --> 00:31:18.647
because build
doesn't really know

00:31:18.647 --> 00:31:20.480
what paths it's going
to take in advance, so

00:31:20.480 --> 00:31:21.910
really try to set
up all of your tasks

00:31:21.910 --> 00:31:22.993
in the configuration step.

00:31:26.160 --> 00:31:32.380
Regarding tasks, make sure that
each tasks declare all input

00:31:32.380 --> 00:31:35.170
and outputs, even if
it's non-file ones,

00:31:35.170 --> 00:31:39.280
and make sure that they're
incremental and cacheable.

00:31:39.280 --> 00:31:42.640
If you're working
with a complex step,

00:31:42.640 --> 00:31:46.120
try to split it
into multiple tasks.

00:31:46.120 --> 00:31:48.370
This really helps with
the incrementally,

00:31:48.370 --> 00:31:52.220
because some tasks could be up
to date while others do work.

00:31:52.220 --> 00:31:55.330
And if you have multiple tasks,
they could run in parallel.

00:31:55.330 --> 00:31:57.986
So it helps with
incrementality and parallelism.

00:32:00.962 --> 00:32:03.770
This third best
practice sounds obvious,

00:32:03.770 --> 00:32:05.750
but I still want to
put it out there.

00:32:05.750 --> 00:32:08.761
Make sure your tasks don't write
into or delete any other tasks'

00:32:08.761 --> 00:32:09.260
output.

00:32:13.160 --> 00:32:19.620
When you write tasks, use Java
and Kotlin instead of Groovy,

00:32:19.620 --> 00:32:25.540
and put them in a
plugin/buildSrc folder.

00:32:25.540 --> 00:32:28.420
And last but not least, as
you've heard from Jerome,

00:32:28.420 --> 00:32:31.270
leverage the new worker API--

00:32:31.270 --> 00:32:34.290
we didn't talk about this, but
leverage the new worker API.

00:32:34.290 --> 00:32:37.710
JEROME DOCHEZ: I did talk
about parallel stuff.

00:32:37.710 --> 00:32:40.910
LEO SEI: That really
helps with parallelism.

00:32:40.910 --> 00:32:41.410
All right.

00:32:41.410 --> 00:32:45.670
If you didn't get clear pictures
of all of what I just said,

00:32:45.670 --> 00:32:46.840
don't worry.

00:32:46.840 --> 00:32:48.580
We're working on
a full write up,

00:32:48.580 --> 00:32:50.260
covering everything
that we talked

00:32:50.260 --> 00:32:53.020
about around speed, around
the findings that I shared,

00:32:53.020 --> 00:32:55.100
the tooling, the best
practices, and more.

00:32:55.100 --> 00:32:55.690
So stay tuned.

00:32:58.672 --> 00:33:04.420
To recap, here's the take
away from this session.

00:33:04.420 --> 00:33:07.270
First, we shared some
findings on speed

00:33:07.270 --> 00:33:09.040
and that we're
basically a little bit

00:33:09.040 --> 00:33:11.780
outpaced by some of the
features, the plugins, and all

00:33:11.780 --> 00:33:13.780
the other things that are
impacting build speed,

00:33:13.780 --> 00:33:16.490
but we're taking
this very seriously.

00:33:16.490 --> 00:33:18.160
And so we're doubling
down our effort

00:33:18.160 --> 00:33:20.590
on better tooling and
attribution that you heard,

00:33:20.590 --> 00:33:24.390
as well as continuing
to improve performances.

00:33:24.390 --> 00:33:27.690
We shared the new
features in 3.2,

00:33:27.690 --> 00:33:30.340
and I definitely encourage
you to upgrade to 3.2,

00:33:30.340 --> 00:33:32.062
if you haven't already.

00:33:32.062 --> 00:33:33.970
And we mentioned some
of the things that

00:33:33.970 --> 00:33:36.100
are working for 3.3 and beyond.

00:33:36.100 --> 00:33:39.790
And, by the way, 3.3
beta is available,

00:33:39.790 --> 00:33:41.557
so I encourage you to try it.

00:33:41.557 --> 00:33:43.390
It has some of the
things that we mentioned,

00:33:43.390 --> 00:33:45.820
like lazy tasks and others.

00:33:49.590 --> 00:33:52.230
Last, I talked about some of
the tools that you can use--

00:33:52.230 --> 00:33:54.750
--scan, --profile--

00:33:54.750 --> 00:33:57.390
today to understand your build,
and shared some of the best

00:33:57.390 --> 00:33:59.670
practice if you're writing
plugins or customizing

00:33:59.670 --> 00:34:02.515
your build speed.

00:34:02.515 --> 00:34:03.645
That's it for today.

00:34:03.645 --> 00:34:06.530
I want to make a bad
joke, but, unlike build,

00:34:06.530 --> 00:34:09.560
we finished earlier
than expected, so.

00:34:09.560 --> 00:34:13.210
[MUSIC PLAYING]

