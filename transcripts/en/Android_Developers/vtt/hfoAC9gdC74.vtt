WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.440
[MUSIC PLAYING]

00:00:04.800 --> 00:00:06.250
CHIU-KI CHAN: Welcome.

00:00:06.250 --> 00:00:08.660
My name is Chiu-Ki
Chan, and today we

00:00:08.660 --> 00:00:12.380
are going to talk about
Advanced Android Espresso.

00:00:12.380 --> 00:00:14.430
In case you do
not know, Espresso

00:00:14.430 --> 00:00:16.000
is a testing framework.

00:00:16.000 --> 00:00:18.980
So let me just back up a
little bit and ask all of you,

00:00:18.980 --> 00:00:22.651
how many of you do
Android testing?

00:00:22.651 --> 00:00:23.150
Oh.

00:00:23.150 --> 00:00:23.870
OK.

00:00:23.870 --> 00:00:24.550
More than half.

00:00:24.550 --> 00:00:25.770
That's excellent.

00:00:25.770 --> 00:00:29.990
And how many of you have
written Espresso tests?

00:00:29.990 --> 00:00:31.170
Little bit less than a half.

00:00:31.170 --> 00:00:32.759
So cool.

00:00:32.759 --> 00:00:34.700
So this is Advanced
Android Espresso,

00:00:34.700 --> 00:00:38.070
so I'll be going through the
beginning stuff pretty quickly.

00:00:38.070 --> 00:00:40.690
But hopefully, for those of you
who have not done it before,

00:00:40.690 --> 00:00:42.160
you'll still get a
good enough overview

00:00:42.160 --> 00:00:44.285
so then when I explain more
advanced techniques you

00:00:44.285 --> 00:00:45.950
can follow along.

00:00:45.950 --> 00:00:48.920
Well first, what is Espresso?

00:00:48.920 --> 00:00:52.860
In short, Espresso is an
automated UI testing framework,

00:00:52.860 --> 00:00:56.870
meaning that you write
some code and then

00:00:56.870 --> 00:00:59.730
you can let go of your
hand, because Espresso

00:00:59.730 --> 00:01:02.290
will click buttons and type
text and do all these user

00:01:02.290 --> 00:01:05.260
actions for you, and then you
can verify the state of the app

00:01:05.260 --> 00:01:09.840
to make sure that's behaving
the way you expect it to behave.

00:01:09.840 --> 00:01:13.390
And what's nice about Espresso
is that, well, first of all,

00:01:13.390 --> 00:01:15.130
it's a first party library.

00:01:15.130 --> 00:01:17.610
It is written by
people at Google.

00:01:17.610 --> 00:01:21.110
It gets delivered through
the Android Testing Support

00:01:21.110 --> 00:01:22.110
Library.

00:01:22.110 --> 00:01:26.077
And like I said, it simulates
user action, so people--

00:01:26.077 --> 00:01:27.910
not people, I guess--
the program's actually

00:01:27.910 --> 00:01:31.330
cutting the button and
exercising your app that way.

00:01:31.330 --> 00:01:33.920
But the most interesting
thing about Espresso

00:01:33.920 --> 00:01:37.920
is that it does automatic
synchronization.

00:01:37.920 --> 00:01:40.800
That sounds really fancy,
and whatever that means.

00:01:40.800 --> 00:01:44.440
So I can tell you what happened
before Espresso came along.

00:01:44.440 --> 00:01:46.390
Before Espresso
came along, there

00:01:46.390 --> 00:01:50.520
is already a way to do all these
things, like click on buttons

00:01:50.520 --> 00:01:51.520
and verify.

00:01:51.520 --> 00:01:55.500
But the problem is that
the click action that

00:01:55.500 --> 00:01:57.960
comes from your test
app is not synchronized

00:01:57.960 --> 00:01:59.060
with your main app.

00:01:59.060 --> 00:02:03.230
Meaning that your app
may or may not be ready.

00:02:03.230 --> 00:02:07.658
So for us human, it's
instantaneous, right?

00:02:07.658 --> 00:02:09.699
Like, you open the app
and the buttons are there.

00:02:09.699 --> 00:02:12.630
But it actually takes a
few hundred milliseconds

00:02:12.630 --> 00:02:14.100
for the rendering to happen.

00:02:14.100 --> 00:02:15.840
And your test thread
is super fast.

00:02:15.840 --> 00:02:17.923
So when I was running tests
with my Espresso, what

00:02:17.923 --> 00:02:20.759
would happen is that I would
say, go click the button.

00:02:20.759 --> 00:02:23.050
And my test code was, like,
there's no button to click.

00:02:23.050 --> 00:02:24.758
And that's not because
there's no button.

00:02:24.758 --> 00:02:25.984
It is because I was too fast.

00:02:25.984 --> 00:02:27.650
So that's all I mean
by synchronization,

00:02:27.650 --> 00:02:29.890
is that Espresso
actually have watches.

00:02:29.890 --> 00:02:31.930
It will watch over the
UI thread and make sure

00:02:31.930 --> 00:02:34.990
that it's idle-- it's
done rendering before it

00:02:34.990 --> 00:02:36.770
goes try to click a button.

00:02:36.770 --> 00:02:39.505
I mean, it also watches
the AsyncTask thread pool,

00:02:39.505 --> 00:02:42.130
so if you are doing something in
the background with AsyncTask,

00:02:42.130 --> 00:02:43.500
it will wait for that as well.

00:02:43.500 --> 00:02:47.615
So that's what's nice about
automatic synchronization.

00:02:47.615 --> 00:02:48.990
Another way to
put it is, I don't

00:02:48.990 --> 00:02:50.660
know if you have
written tests before,

00:02:50.660 --> 00:02:53.010
and you have to make it
sleep to make it pass.

00:02:53.010 --> 00:02:55.374
To do the synchronization.

00:02:55.374 --> 00:02:56.862
I mean, I make it
sound like magic,

00:02:56.862 --> 00:02:59.320
but actually, behind the scenes,
that's what Espresso does.

00:02:59.320 --> 00:03:00.700
But it sleeps for you.

00:03:00.700 --> 00:03:02.800
It's not-- this doesn't
blindly sleep for, like,

00:03:02.800 --> 00:03:04.000
500 milliseconds.

00:03:04.000 --> 00:03:07.510
It's like, sleep, and wake
up and say, hey, UI thread,

00:03:07.510 --> 00:03:08.367
are you done?

00:03:08.367 --> 00:03:09.200
Oh, you're not done.

00:03:09.200 --> 00:03:09.970
Oh, OK, I'll sleep again.

00:03:09.970 --> 00:03:11.860
So it makes it a little
more intelligent, sleeping,

00:03:11.860 --> 00:03:13.710
so that you don't have
to worry about it.

00:03:13.710 --> 00:03:15.465
So behind the scenes, there's
still some sleeping going on,

00:03:15.465 --> 00:03:17.100
but at least you are
not the one that's

00:03:17.100 --> 00:03:19.266
randomly guessing some
random number of milliseconds

00:03:19.266 --> 00:03:21.264
to sleep.

00:03:21.264 --> 00:03:23.680
So I'm going to go through
Halliwell, for those of you who

00:03:23.680 --> 00:03:25.640
have not done this before.

00:03:25.640 --> 00:03:27.670
Espresso kind of
have a formula--

00:03:27.670 --> 00:03:30.860
that is, I think what
people call a Fluent API,

00:03:30.860 --> 00:03:35.120
so there's three parts to this--
onView, Perform, and Check.

00:03:35.120 --> 00:03:38.870
onView is the way to
find a view on your app.

00:03:38.870 --> 00:03:41.630
So for instance, while we
have this Halliwell app,

00:03:41.630 --> 00:03:44.200
we have this button
called Greet.

00:03:44.200 --> 00:03:48.320
To look for this button, we
can use the withid function,

00:03:48.320 --> 00:03:51.691
and we can give it the ID that
says look for the greet button.

00:03:51.691 --> 00:03:52.190
OK?

00:03:52.190 --> 00:03:54.231
So now, at this point we
have located the button.

00:03:54.231 --> 00:03:57.030
Now we need to do
something to it.

00:03:57.030 --> 00:03:58.860
With that, it's viewAction.

00:03:58.860 --> 00:04:02.390
We can ask Espresso to
then click on this button,

00:04:02.390 --> 00:04:05.420
and afterwards, we'll
verify something.

00:04:05.420 --> 00:04:08.250
In our case, for some reason,
you can only Greet once.

00:04:08.250 --> 00:04:10.910
Once you Greet, the
button will be disabled.

00:04:10.910 --> 00:04:13.820
So once I click on the Greet
button, I want to check that.

00:04:13.820 --> 00:04:17.170
It says, check
matches not enabled.

00:04:17.170 --> 00:04:21.197
So in Espresso, you can also
combine different viewActions

00:04:21.197 --> 00:04:21.905
and reassertions.

00:04:21.905 --> 00:04:24.130
So in this case, there's
a built-in function

00:04:24.130 --> 00:04:26.385
called "it's enabled,"
that I can use to verify

00:04:26.385 --> 00:04:28.330
that the button is enabled.

00:04:28.330 --> 00:04:30.790
There's no function
called "it's not enabled."

00:04:30.790 --> 00:04:33.230
What you do is, you negate that.

00:04:33.230 --> 00:04:37.680
And I have actually published
this on the GitHub repository,

00:04:37.680 --> 00:04:40.459
and like I said, the whole
slide deck is already shared.

00:04:40.459 --> 00:04:42.250
If you go on Twitter,
you can click through

00:04:42.250 --> 00:04:43.230
and find all these examples.

00:04:43.230 --> 00:04:44.396
There are a lot more coming.

00:04:44.396 --> 00:04:47.240
So don't frantically
write down URLs.

00:04:47.240 --> 00:04:50.450
That is just not the best
use of your time right now.

00:04:50.450 --> 00:04:53.420
So like I said a
little bit earlier,

00:04:53.420 --> 00:04:56.650
the withid is something
that Espresso provides

00:04:56.650 --> 00:04:58.337
for you to look for a view.

00:04:58.337 --> 00:05:00.170
There are other things,
like click, matches,

00:05:00.170 --> 00:05:03.883
and it's enabled, so almost
everything here is coming out

00:05:03.883 --> 00:05:05.340
of the Espresso library.

00:05:05.340 --> 00:05:08.650
But the "not" part
is from Hamcrest.

00:05:08.650 --> 00:05:10.780
It's still bundled with
the Espresso Library,

00:05:10.780 --> 00:05:13.500
but it's not written
by the folks at Google.

00:05:13.500 --> 00:05:15.760
It's a Java-specific
library that you

00:05:15.760 --> 00:05:18.240
can do different things.

00:05:18.240 --> 00:05:22.590
So these are all the Espresso
viewMatches, viewActions,

00:05:22.590 --> 00:05:26.300
viewAssertions, and we are
going to sit here the whole talk

00:05:26.300 --> 00:05:28.710
to go through each one
of them, and then--

00:05:28.710 --> 00:05:30.480
until you fall asleep.

00:05:30.480 --> 00:05:31.750
No, no, that's not the agenda.

00:05:31.750 --> 00:05:34.250
I'm just going to show you this
because that's a cheat sheet

00:05:34.250 --> 00:05:36.880
online that you can go check
if you are wondering what

00:05:36.880 --> 00:05:39.400
is the capability of Espresso.

00:05:39.400 --> 00:05:42.550
On top of that, like I mentioned
earlier, there's Hamcrest.

00:05:42.550 --> 00:05:44.050
Again, cheat sheets.

00:05:44.050 --> 00:05:45.400
Function galore.

00:05:45.400 --> 00:05:47.400
I'm not going to go through
that, but you can go

00:05:47.400 --> 00:05:48.650
and you can take a quick look.

00:05:48.650 --> 00:05:52.352
And there's things like
what I did already--

00:05:52.352 --> 00:05:54.060
"not" is one of it,
and then you can also

00:05:54.060 --> 00:05:57.370
do other things that is an
instance of, so basically

00:05:57.370 --> 00:06:02.120
Java-level matching, rather
than Android matching.

00:06:02.120 --> 00:06:05.360
So with this, you can
actually combine them,

00:06:05.360 --> 00:06:07.210
and it's going to become
much more powerful

00:06:07.210 --> 00:06:09.560
and stuff than
just a single one.

00:06:09.560 --> 00:06:12.180
Let's go through one example.

00:06:12.180 --> 00:06:15.330
Suppose I have an app
that uses the Toolbar.

00:06:15.330 --> 00:06:18.606
I mean, you have an app that
uses the Toolbar, right?

00:06:18.606 --> 00:06:22.850
Did you supply the
layout to the Toolbar?

00:06:22.850 --> 00:06:23.440
No.

00:06:23.440 --> 00:06:26.220
So we are not going to
be able to use withid

00:06:26.220 --> 00:06:29.900
to find the Toolbar, to
verify what the title is.

00:06:29.900 --> 00:06:32.300
So what are we going to
do if we want to verify

00:06:32.300 --> 00:06:35.220
that I set the title properly?

00:06:35.220 --> 00:06:37.450
Well, we're going to bust
our Hierarchy Viewer.

00:06:37.450 --> 00:06:40.350
How many of you have
used Hierarchy Viewer?

00:06:40.350 --> 00:06:41.560
Great.

00:06:41.560 --> 00:06:43.540
What this is, is
you can take a look

00:06:43.540 --> 00:06:45.432
at not just the part
of the UI that you

00:06:45.432 --> 00:06:47.265
set-- so sometimes when
you run an activity,

00:06:47.265 --> 00:06:49.010
you do set contentView.

00:06:49.010 --> 00:06:51.590
And then you're given
Layout, and that's the part

00:06:51.590 --> 00:06:52.340
that you designed.

00:06:52.340 --> 00:06:55.840
It actually shows the whole
UI that's being rendered.

00:06:55.840 --> 00:06:59.080
So you can see things that
are beyond your control.

00:06:59.080 --> 00:07:03.210
In our case, we can see that
there is the TextView, which

00:07:03.210 --> 00:07:04.987
has my awesome title
in it, and that's

00:07:04.987 --> 00:07:06.320
the view that we want to verify.

00:07:06.320 --> 00:07:09.490
But the problem is, this
guy doesn't have an ID.

00:07:09.490 --> 00:07:11.760
So how are we going
to look for it?

00:07:11.760 --> 00:07:13.750
Well, fortunately,
we can see that this

00:07:13.750 --> 00:07:18.780
is a child of a class that
is of the type Toolbar.

00:07:18.780 --> 00:07:23.260
So we can combine matches
to pinpoint this view.

00:07:23.260 --> 00:07:25.030
Let's see how we are
going to do this.

00:07:25.030 --> 00:07:27.540
Well, first of all, I have
a helper function that

00:07:27.540 --> 00:07:30.790
help me find the Toolbar title.

00:07:30.790 --> 00:07:33.320
And the reason why I have
this helper function that

00:07:33.320 --> 00:07:36.130
match Toolbar title
is because that way,

00:07:36.130 --> 00:07:37.150
I can reuse it, right?

00:07:37.150 --> 00:07:40.800
If I have multiple tasks that I
want to find the Toolbar title

00:07:40.800 --> 00:07:43.910
and match it, I just
need to write it once.

00:07:43.910 --> 00:07:46.960
So here is half the magic,
where alloff, that's

00:07:46.960 --> 00:07:48.570
the Hamcrest matcher.

00:07:48.570 --> 00:07:50.010
And then I will
look for something

00:07:50.010 --> 00:07:52.270
that isAssignableFrom
TextView meaning I'm

00:07:52.270 --> 00:07:55.207
looking for a class that
is a TextView, or a child

00:07:55.207 --> 00:07:57.540
of TextView, like, maybe it's
a button, but in our case,

00:07:57.540 --> 00:07:58.838
it's a TextView.

00:07:58.838 --> 00:08:01.780
And then, because
we have an all of,

00:08:01.780 --> 00:08:04.150
so we have to satisfy
two conditions.

00:08:04.150 --> 00:08:07.630
The first condition is the
view itself is a TextView.

00:08:07.630 --> 00:08:10.350
The second condition
is that that view also

00:08:10.350 --> 00:08:13.780
has a parent that
is of type Toolbar.

00:08:13.780 --> 00:08:18.000
So we are trying to translate
what we see in Hierarchy Viewer

00:08:18.000 --> 00:08:19.160
into the matches.

00:08:19.160 --> 00:08:22.920
So with all that, we will
find that particular TextView,

00:08:22.920 --> 00:08:26.464
and then we can go ahead
and do the match with text,

00:08:26.464 --> 00:08:28.630
so that we can verify that
the Toolbar is displaying

00:08:28.630 --> 00:08:30.755
what we expect it to display.

00:08:30.755 --> 00:08:31.380
So far so good?

00:08:33.900 --> 00:08:34.429
OK, good.

00:08:34.429 --> 00:08:38.059
Exercise this much of your body.

00:08:38.059 --> 00:08:40.272
But even though there's
a lot of matches

00:08:40.272 --> 00:08:41.730
and you can combine
them, there are

00:08:41.730 --> 00:08:44.510
times that we want to
write a custom matcher.

00:08:44.510 --> 00:08:46.290
In fact, we're going
to change this code

00:08:46.290 --> 00:08:47.940
to use a custom matcher.

00:08:47.940 --> 00:08:50.210
And it's not just
for demoing purposes.

00:08:50.210 --> 00:08:51.660
The reason why I
want to change it

00:08:51.660 --> 00:08:54.620
is because, when you're doing
that check that I showed you,

00:08:54.620 --> 00:08:57.100
that you use the Hierarchy
Viewer to look deep

00:08:57.100 --> 00:08:59.560
into a view, it may change.

00:08:59.560 --> 00:09:00.060
Right?

00:09:00.060 --> 00:09:01.250
This is not your code.

00:09:01.250 --> 00:09:03.410
This is probably
the Support Library,

00:09:03.410 --> 00:09:05.480
if you are using
App Compat, right?

00:09:05.480 --> 00:09:10.090
Today, the Toolbar display it
by having one single layer,

00:09:10.090 --> 00:09:13.520
so you can use it with
parent to pinpoint your view.

00:09:13.520 --> 00:09:14.850
Tomorrow things may change.

00:09:14.850 --> 00:09:16.740
It may get nested
inside linear layout,

00:09:16.740 --> 00:09:18.990
because-- well, they don't
have to explain to you why,

00:09:18.990 --> 00:09:20.450
they just want to do it, right?

00:09:20.450 --> 00:09:22.990
So to protect yourself
from those changes,

00:09:22.990 --> 00:09:25.980
it's much better to use
a published API, right?

00:09:25.980 --> 00:09:28.964
Because when you are sneaking
into their viewHeirarchy,

00:09:28.964 --> 00:09:30.380
that's not part
of the public API,

00:09:30.380 --> 00:09:32.390
and they allowed to change it.

00:09:32.390 --> 00:09:35.260
Whereas, for example, here,
we are actually going to use

00:09:35.260 --> 00:09:37.400
the toolbar.getTitle() function.

00:09:37.400 --> 00:09:40.470
That is a part of the public
API of the Toolbar object.

00:09:40.470 --> 00:09:43.620
So instead of using all those
matched parents, and alloff,

00:09:43.620 --> 00:09:45.360
and whatnot, what
we're going to do is,

00:09:45.360 --> 00:09:46.490
this one is very similar.

00:09:46.490 --> 00:09:49.900
So on the-- well, this is
actually just a function--

00:09:49.900 --> 00:09:51.850
ViewToolbarTitle.

00:09:51.850 --> 00:09:55.550
But what we have is that I have
written a custom thing called

00:09:55.550 --> 00:09:58.480
withToolbarTitle.

00:09:58.480 --> 00:10:00.870
This is the dense code coming.

00:10:00.870 --> 00:10:02.580
Can everybody see it?

00:10:02.580 --> 00:10:03.520
OK, that's good.

00:10:03.520 --> 00:10:06.140
So what we have
here is something

00:10:06.140 --> 00:10:07.590
called BoundedMatcher.

00:10:07.590 --> 00:10:11.080
This is, again-- I think
it's actually Hamcrest.

00:10:11.080 --> 00:10:13.490
What happened here
is that I'm saying

00:10:13.490 --> 00:10:16.730
that I want a
viewMatcher that is

00:10:16.730 --> 00:10:19.870
specific to a Toolbar-- which
is why there's a generic that I

00:10:19.870 --> 00:10:21.560
pass into Toolbar class.

00:10:21.560 --> 00:10:28.450
And when I want to see
whether this matches safely,

00:10:28.450 --> 00:10:31.250
I will go ahead and
call the Toolbar, which

00:10:31.250 --> 00:10:33.360
is passed in to me in
this function because

00:10:33.360 --> 00:10:36.610
of this generic, and I'll
call the functions GetTitle,

00:10:36.610 --> 00:10:39.470
and then I will match
it with the TextMatcher.

00:10:39.470 --> 00:10:44.250
So TextMatcher, if you can
see here, is of Matcher Class.

00:10:44.250 --> 00:10:50.760
So the previous slide--
the if-- that's the-- this

00:10:50.760 --> 00:10:52.790
is kind of confusing-- "if."

00:10:52.790 --> 00:10:54.384
That's the Matcher.

00:10:54.384 --> 00:10:56.300
So we're passing a
TextMatcher, and the reason

00:10:56.300 --> 00:10:58.310
why I did it this way
is because you can also

00:10:58.310 --> 00:11:00.860
pass in a different Matcher,
so you can also do something

00:11:00.860 --> 00:11:03.684
like "starts with,"
"ends with," "contains"--

00:11:03.684 --> 00:11:05.600
so it's much more powerful
than if you're just

00:11:05.600 --> 00:11:06.770
passing a string.

00:11:06.770 --> 00:11:09.355
So those are all, again,
Hamcrest Matchers.

00:11:09.355 --> 00:11:11.980
You don't actually have to write
what the function starts with.

00:11:11.980 --> 00:11:13.700
You can just pass it in.

00:11:13.700 --> 00:11:18.430
So with this, since I just swap
it in to my helper function,

00:11:18.430 --> 00:11:19.725
then I'm done, right?

00:11:19.725 --> 00:11:23.500
All the code I'm trying to
verify the Toolbar title will

00:11:23.500 --> 00:11:27.350
now use get.Title() function.

00:11:27.350 --> 00:11:30.620
So this is how you
write a custom matcher.

00:11:30.620 --> 00:11:33.040
Well, this is [INAUDIBLE]
case, because what I want to do

00:11:33.040 --> 00:11:34.930
is, I want to verify
the Toolbar object.

00:11:34.930 --> 00:11:37.780
So by giving it as a
generic, I can have access

00:11:37.780 --> 00:11:38.520
to the function.

00:11:38.520 --> 00:11:39.630
So I can verify.

00:11:39.630 --> 00:11:45.250
So I've also written matches,
for example, that I can verify

00:11:45.250 --> 00:11:47.395
the text color of a TextView.

00:11:47.395 --> 00:11:48.770
So if I [INAUDIBLE]
Espresso, you

00:11:48.770 --> 00:11:51.870
can do the WithText to find
out what is printed out,

00:11:51.870 --> 00:11:53.482
but I want to know
what color it is.

00:11:53.482 --> 00:11:54.440
TextView provides that.

00:11:54.440 --> 00:11:57.570
You can use the-- you can ask
it to get you the current color.

00:11:57.570 --> 00:11:58.070
All right?

00:11:58.070 --> 00:12:00.090
So, OK, then wrap it
inside a BoundedMatcher

00:12:00.090 --> 00:12:01.950
and then in the
matchbase function,

00:12:01.950 --> 00:12:04.830
called the
getCurrentColor function.

00:12:08.311 --> 00:12:08.810
Yes.

00:12:08.810 --> 00:12:11.210
I already covered that.

00:12:11.210 --> 00:12:13.550
Again, that's the full example
that even the blog post,

00:12:13.550 --> 00:12:17.580
if you want to read again what,
actually, what I just said.

00:12:17.580 --> 00:12:19.260
But if you want to
read it in prose,

00:12:19.260 --> 00:12:22.110
you can go ahead and do that.

00:12:22.110 --> 00:12:24.090
Now, something more interesting.

00:12:24.090 --> 00:12:27.020
onData-- has anyone
used this matcher?

00:12:27.020 --> 00:12:28.340
What does this do?

00:12:28.340 --> 00:12:29.256
AUDIENCE: [INAUDIBLE].

00:12:32.396 --> 00:12:33.770
CHIU-KI CHAN: You
are half right.

00:12:33.770 --> 00:12:37.550
It checks the List View,
but not Recycler View.

00:12:37.550 --> 00:12:38.800
So we'll get to that.

00:12:38.800 --> 00:12:41.769
So, yeah, so onData allows
you to check on the List View.

00:12:41.769 --> 00:12:43.560
So for those of you
who have not written it

00:12:43.560 --> 00:12:44.934
before, you may
be wondering, why

00:12:44.934 --> 00:12:47.250
do you need a different thing?

00:12:47.250 --> 00:12:50.040
So the problem with-- what
the problem is, the way List

00:12:50.040 --> 00:12:54.660
View is done is that the views
comes in and out as you scroll,

00:12:54.660 --> 00:12:57.260
because it's using
the same views,

00:12:57.260 --> 00:12:59.596
but just swapping in
new data to the space.

00:12:59.596 --> 00:13:02.220
So you cannot just say. oh, I'm
going to look for the view with

00:13:02.220 --> 00:13:03.350
ID list items.

00:13:03.350 --> 00:13:05.890
That is not going to work.

00:13:05.890 --> 00:13:10.210
So the formula for using onData
is similar to the onView,

00:13:10.210 --> 00:13:12.600
if you compare it side by side.

00:13:12.600 --> 00:13:16.010
Except you have some extra
things, like CallDataOption.

00:13:16.010 --> 00:13:17.860
We're going to
get to an example,

00:13:17.860 --> 00:13:19.520
and it's much easier
to understand.

00:13:19.520 --> 00:13:21.790
So one next thing is,
instead of a ViewMatcher,

00:13:21.790 --> 00:13:23.300
you have an ObjectMatcher.

00:13:23.300 --> 00:13:26.100
So the way onData
works is that it

00:13:26.100 --> 00:13:28.510
will, instead of
look for a view,

00:13:28.510 --> 00:13:29.972
it will look into the data.

00:13:29.972 --> 00:13:31.680
Essentially you're
already-- for example,

00:13:31.680 --> 00:13:33.575
if you're displaying
an array of strings,

00:13:33.575 --> 00:13:38.386
it will look for strings rather
than views, like TextViews.

00:13:38.386 --> 00:13:41.350
And the Data Options--
I hope you can see it--

00:13:41.350 --> 00:13:43.280
is things like in AdaptAView.

00:13:43.280 --> 00:13:45.469
So for example, even if
you just-- if you just

00:13:45.469 --> 00:13:47.010
look [INAUDIBLE] on
the data, but you

00:13:47.010 --> 00:13:51.060
have multiple AdaptAView,
multiple ListViews in your app,

00:13:51.060 --> 00:13:53.310
then it doesn't know which
one you're trying to match.

00:13:53.310 --> 00:13:55.750
So you can give it a Matcher,
so this time you can do,

00:13:55.750 --> 00:14:01.350
for example, in onData view
with ID list-- [INAUDIBLE].list.

00:14:01.350 --> 00:14:03.900
And you can also do
things like onChildView.

00:14:03.900 --> 00:14:07.750
So maybe you pinpoint
that particular list item,

00:14:07.750 --> 00:14:11.940
but then it has two TextViews,
and an ImageView inside,

00:14:11.940 --> 00:14:15.890
so you can use
onChildView with ID,

00:14:15.890 --> 00:14:18.390
or the id.image, or
something like that,

00:14:18.390 --> 00:14:20.860
to do further Matching.

00:14:20.860 --> 00:14:21.970
Here's an example.

00:14:21.970 --> 00:14:25.050
I have a pretty
benign-looking ListView.

00:14:25.050 --> 00:14:29.300
And what I'm going to do is that
I'm going to look for item 27,

00:14:29.300 --> 00:14:32.014
and verify that it says 27.

00:14:32.014 --> 00:14:33.930
So right off the bat,
that's a problem, right?

00:14:33.930 --> 00:14:37.440
I can't see item 27.

00:14:37.440 --> 00:14:40.150
But the beauty of onData is
that it will scroll for you.

00:14:40.150 --> 00:14:45.120
So there is yet another reason
why you want to use onData.

00:14:45.120 --> 00:14:48.095
Here's a very quick power
play how the app is set up.

00:14:48.095 --> 00:14:54.470
I have a array that is the
data-- that is a type item.

00:14:54.470 --> 00:14:57.660
Besides, I made 30 of them,
and I iterate it, fill it in,

00:14:57.660 --> 00:15:00.950
and I use that to
initialize my List adaptor.

00:15:00.950 --> 00:15:03.620
And the item is pretty simple.

00:15:03.620 --> 00:15:06.305
It has an integer, and then
when it needs to be displayed,

00:15:06.305 --> 00:15:09.270
it displays the
value of the integer.

00:15:09.270 --> 00:15:13.740
So now, when-- this is, I
guess, more complicated than I

00:15:13.740 --> 00:15:14.470
initially said.

00:15:14.470 --> 00:15:15.970
So that's also an
onClick listeners.

00:15:15.970 --> 00:15:19.570
When I click on an item, it's
going to display in the footer.

00:15:19.570 --> 00:15:23.250
Just because we are
writing a demo app.

00:15:23.250 --> 00:15:26.140
So now, we go back
to the test, and say,

00:15:26.140 --> 00:15:28.240
let's run a test to verify that.

00:15:28.240 --> 00:15:32.630
Before I click on any list item,
the footer is not displayed.

00:15:32.630 --> 00:15:34.500
I click on one of
them, and then it

00:15:34.500 --> 00:15:36.750
will display with
a matching number.

00:15:36.750 --> 00:15:41.360
So that's English, and
translated into Espresso,

00:15:41.360 --> 00:15:43.990
I said, before I click
anything, so in the beginning

00:15:43.990 --> 00:15:46.910
of the function, I want to
find-- this is the footer

00:15:46.910 --> 00:15:52.710
textView, onView with ID
text, check that it matches

00:15:52.710 --> 00:15:53.761
that it is not displayed.

00:15:53.761 --> 00:15:54.260
OK?

00:15:54.260 --> 00:15:57.810
So it's very similar to what we
did earlier of the notEnabled.

00:15:57.810 --> 00:15:59.410
Not is enabled.

00:15:59.410 --> 00:16:03.190
Next we're going to use the
onData with a value of 27

00:16:03.190 --> 00:16:05.810
to pinpoint that
particular item.

00:16:05.810 --> 00:16:07.680
In this particular
AdaptAView, in case there

00:16:07.680 --> 00:16:11.650
are multiple of them, and
then we perform click on it.

00:16:11.650 --> 00:16:14.526
Once we are there, we'll
repeat what we did earlier,

00:16:14.526 --> 00:16:15.900
except this time
we actually want

00:16:15.900 --> 00:16:19.420
to make sure that it
has the proper text

00:16:19.420 --> 00:16:22.270
and it is displayed.

00:16:22.270 --> 00:16:24.570
So so far, everything
looks pretty good.

00:16:24.570 --> 00:16:29.510
Just one tiny thing. withValue
is not an Espresso function.

00:16:29.510 --> 00:16:30.890
You have to write it.

00:16:30.890 --> 00:16:34.260
Ah, our best friend
BoundedMatch are here again.

00:16:34.260 --> 00:16:37.320
This time, instead of
bounding it to a Toolbar,

00:16:37.320 --> 00:16:41.260
we're binding it to a item.

00:16:41.260 --> 00:16:45.580
So I pass it in at value
27, that I'm looking for.

00:16:45.580 --> 00:16:47.740
And then in
matchSafely, I'm going

00:16:47.740 --> 00:16:51.529
to see that it
matches to the item.

00:16:51.529 --> 00:16:53.070
So that's what
Espresso goes through.

00:16:53.070 --> 00:16:55.285
It looks for an item and
say, hey, are you 27?

00:16:55.285 --> 00:16:56.450
Are you 27?

00:16:56.450 --> 00:16:59.170
And if it's not, it just keeps
scrolling and keep looking.

00:16:59.170 --> 00:17:00.560
Good?

00:17:00.560 --> 00:17:01.810
All right.

00:17:01.810 --> 00:17:03.360
RecyclerView.

00:17:03.360 --> 00:17:07.650
So yeah, I've-- a gentleman
here already mentioned it.

00:17:07.650 --> 00:17:10.460
So this RecyclerView will
look pretty much the same

00:17:10.460 --> 00:17:12.119
at our ListView.

00:17:12.119 --> 00:17:15.940
However, you cannot
use onData with it.

00:17:15.940 --> 00:17:16.970
Does anybody know why?

00:17:19.700 --> 00:17:20.200
Good.

00:17:20.200 --> 00:17:22.540
I'm going to teach
you something.

00:17:22.540 --> 00:17:26.280
The reason why you cannot do
it is that RecyclerView is

00:17:26.280 --> 00:17:29.790
actually a ViewGroup,
not an AdaptorView.

00:17:29.790 --> 00:17:32.515
And even though it looks
surprisingly similar,

00:17:32.515 --> 00:17:35.300
under the hood they are
actually very, very different.

00:17:35.300 --> 00:17:37.440
So when you're working
with RecyclerView,

00:17:37.440 --> 00:17:40.030
you're actually going
to go back to use

00:17:40.030 --> 00:17:42.980
onView, instead of onData.

00:17:42.980 --> 00:17:45.420
So let's go through an example.

00:17:45.420 --> 00:17:48.910
Here is the same "test"
kind of functionally, right?

00:17:48.910 --> 00:17:51.050
We verify that the
footer is not displayed,

00:17:51.050 --> 00:17:52.841
and then we are going
to click on the item

00:17:52.841 --> 00:17:54.340
and then verify
that it's displayed.

00:17:54.340 --> 00:17:57.870
However, the meat of it
is completely different.

00:17:57.870 --> 00:18:01.790
We start with onView,
with ID RecyclerView.

00:18:01.790 --> 00:18:03.020
So after we find the parent.

00:18:03.020 --> 00:18:05.480
And then we go ahead and
perform this really, really long

00:18:05.480 --> 00:18:09.670
function, which is available
to you in Espresso,

00:18:09.670 --> 00:18:11.820
so in the RecyclerView
actions, you

00:18:11.820 --> 00:18:13.810
can use these to pinpoint items.

00:18:13.810 --> 00:18:17.600
So in our case, we are
calling the one atPosition,

00:18:17.600 --> 00:18:20.842
so we say, atPosition
27, click on it.

00:18:20.842 --> 00:18:22.300
So that's already
different, right,

00:18:22.300 --> 00:18:24.758
because before we were actually
looking inside, and looking

00:18:24.758 --> 00:18:25.950
at the item.

00:18:25.950 --> 00:18:28.300
There are other things
that you can use.

00:18:28.300 --> 00:18:33.695
So instead of using
the position one-- oh.

00:18:33.695 --> 00:18:34.770
OK, I'm one slide ahead.

00:18:34.770 --> 00:18:37.390
So anyway, this
is the equivalent

00:18:37.390 --> 00:18:40.485
of the other-- of
an onData case when

00:18:40.485 --> 00:18:42.650
you're using it in a ListView.

00:18:42.650 --> 00:18:43.670
Ah, here.

00:18:43.670 --> 00:18:44.960
I hope it's not too low.

00:18:44.960 --> 00:18:47.027
So besides using
this function, there

00:18:47.027 --> 00:18:50.420
are other matches that--
otherView actions that's

00:18:50.420 --> 00:18:53.810
provided for you in the
RecyclerView actions.

00:18:53.810 --> 00:18:55.990
So instead of
matching the position,

00:18:55.990 --> 00:18:58.950
you can also match it
in the Holder position,

00:18:58.950 --> 00:19:05.330
or in the item itself,
with a Matcher.

00:19:05.330 --> 00:19:07.180
So this gets a
little bit confusing,

00:19:07.180 --> 00:19:10.150
because here we are
looking at the position,

00:19:10.150 --> 00:19:12.220
but here what we're
doing is still

00:19:12.220 --> 00:19:15.840
going through all the views, and
then trying to match the view.

00:19:15.840 --> 00:19:20.650
So you'll probably want to
go through the RecyclerView

00:19:20.650 --> 00:19:23.530
documentation and
just see what it does.

00:19:23.530 --> 00:19:25.500
Again, examples.

00:19:25.500 --> 00:19:27.174
I love putting on
examples, because I

00:19:27.174 --> 00:19:29.840
want you to go home and actually
download this and muck with it,

00:19:29.840 --> 00:19:32.520
and change it a little bit,
like try a different viewAction

00:19:32.520 --> 00:19:33.820
and see what happens.

00:19:33.820 --> 00:19:36.420
So this is available.

00:19:36.420 --> 00:19:37.830
Idling Resource.

00:19:37.830 --> 00:19:41.420
Who has used an Idling
Resource before?

00:19:41.420 --> 00:19:42.150
Three hands.

00:19:42.150 --> 00:19:42.750
OK.

00:19:42.750 --> 00:19:44.720
So we are really
getting to the point

00:19:44.720 --> 00:19:46.380
where I am showing
you something new.

00:19:46.380 --> 00:19:47.075
That's cool.

00:19:47.075 --> 00:19:48.190
So Idling Resource.

00:19:48.190 --> 00:19:50.600
If you remember, very,
very early in the talk,

00:19:50.600 --> 00:19:52.680
when I was telling
you that Espresso

00:19:52.680 --> 00:19:57.030
knows to wait for the UI
thread to be idle before it

00:19:57.030 --> 00:19:58.525
goes and clicks buttons.

00:19:58.525 --> 00:20:00.775
But there are other things
that's happening in the app

00:20:00.775 --> 00:20:02.620
that you may want
it to wait as well.

00:20:02.620 --> 00:20:04.340
How do you tell Espresso?

00:20:04.340 --> 00:20:05.910
Another resource
is the interface

00:20:05.910 --> 00:20:07.250
that you need to implement.

00:20:07.250 --> 00:20:09.940
And for some reason it's
really confusing to people.

00:20:09.940 --> 00:20:12.654
So I have done blog posts on it.

00:20:12.654 --> 00:20:14.320
So we're going to go
through one example

00:20:14.320 --> 00:20:16.010
in this particular case.

00:20:16.010 --> 00:20:17.910
Again, that's what
I said-- Espresso

00:20:17.910 --> 00:20:20.420
has a notion of idling, and
these two things are the things

00:20:20.420 --> 00:20:23.690
that Espresso is watching for.

00:20:23.690 --> 00:20:26.265
We are going to go through an
example where, say you have

00:20:26.265 --> 00:20:28.870
an IntentService,
and you want Espresso

00:20:28.870 --> 00:20:31.580
to wait until it's done.

00:20:31.580 --> 00:20:34.420
So what happens is this.

00:20:34.420 --> 00:20:37.870
In your app, you have a button
that says, do something.

00:20:37.870 --> 00:20:40.090
And instead of doing
it in the activity,

00:20:40.090 --> 00:20:42.820
because it's long
running, it goes off

00:20:42.820 --> 00:20:44.239
to ask the
IntentService to do it,

00:20:44.239 --> 00:20:46.280
and then the IntentService
has come back and say,

00:20:46.280 --> 00:20:49.860
yay, I'm done, and
you can update the UI.

00:20:49.860 --> 00:20:50.820
That will stand up.

00:20:50.820 --> 00:20:53.910
And this is the code for
the actual Idling Resource.

00:20:53.910 --> 00:20:56.570
So it's an interface, and
there are three functions

00:20:56.570 --> 00:20:57.990
that you need to override.

00:20:57.990 --> 00:20:59.605
The first two are
kind of boilerplate.

00:20:59.605 --> 00:21:01.810
It needs to get a
name, because when

00:21:01.810 --> 00:21:03.240
you're registering
your resource,

00:21:03.240 --> 00:21:06.090
it needs a key, basically, so
that it can keep track of them.

00:21:06.090 --> 00:21:09.920
So usually I just
give it a class name.

00:21:09.920 --> 00:21:12.516
And then there's this Callback.

00:21:12.516 --> 00:21:14.890
You are just dashing away the
Callback that at some point

00:21:14.890 --> 00:21:16.765
Espresso will give you
a Callback so that you

00:21:16.765 --> 00:21:17.835
can use in this function.

00:21:17.835 --> 00:21:21.860
And so ifIdle, now, is the
meat of your IdlingResource.

00:21:21.860 --> 00:21:25.330
You are going to-- basically,
Espresso's-- after you register

00:21:25.330 --> 00:21:29.020
the IdlingResource, Espresso
is going to come along and say,

00:21:29.020 --> 00:21:32.790
hey, are you idle, by calling
the ifIdleNow function,

00:21:32.790 --> 00:21:34.650
and you return true or false.

00:21:34.650 --> 00:21:36.950
In our particular
case, we are trying

00:21:36.950 --> 00:21:40.514
to make sure that the
IntentService is not running.

00:21:40.514 --> 00:21:42.180
So in the next slide
that's going to be,

00:21:42.180 --> 00:21:43.556
actually,
implementation of this.

00:21:43.556 --> 00:21:45.638
But let's say we have these
magic helper functions

00:21:45.638 --> 00:21:47.860
that will tell us whether
my IntentService is running

00:21:47.860 --> 00:21:48.460
or not.

00:21:48.460 --> 00:21:51.710
And I say, if it's not
running, then it's idle.

00:21:51.710 --> 00:21:55.410
When it's idle, I can go
ahead and call this Callback

00:21:55.410 --> 00:21:58.440
that I stashed away here, so
that I can notify Espresso

00:21:58.440 --> 00:22:00.170
and say, it's idle.

00:22:00.170 --> 00:22:02.310
Go ahead and do your things.

00:22:02.310 --> 00:22:06.510
So that's how IdlingResource
is structured.

00:22:06.510 --> 00:22:09.502
But like I said, this is
the magic helper function.

00:22:09.502 --> 00:22:11.085
Basically, what we're
doing is that we

00:22:11.085 --> 00:22:13.260
are querying the
Activity Manager

00:22:13.260 --> 00:22:16.970
for the particular name,
and make sure that the ones

00:22:16.970 --> 00:22:20.649
that we are looking for--
well, if it's there,

00:22:20.649 --> 00:22:21.690
then it's running, right?

00:22:21.690 --> 00:22:22.970
If it's not there,
then it's not running.

00:22:22.970 --> 00:22:23.450
It's a little bit
confusing, right,

00:22:23.450 --> 00:22:25.710
because then one level
later we negate it.

00:22:25.710 --> 00:22:28.120
So this is-- if it's
running, if I can find it,

00:22:28.120 --> 00:22:31.060
then it's running.

00:22:31.060 --> 00:22:34.870
So once you have defined
your IdlingResource, then

00:22:34.870 --> 00:22:38.274
you need to register it, so that
Espresso knows to actually ask

00:22:38.274 --> 00:22:39.940
this particular item
resource, say, hey,

00:22:39.940 --> 00:22:43.430
are you idle now,
before it moves on.

00:22:43.430 --> 00:22:45.560
Like I said, very
confusing topic, so I've

00:22:45.560 --> 00:22:46.920
written a lot about it.

00:22:46.920 --> 00:22:50.310
One other thing that I want to
mention, because even I forgot,

00:22:50.310 --> 00:22:54.070
is that Espresso only
check the IdlingResource

00:22:54.070 --> 00:22:56.320
if it's trying to do a
viewAction, or a viewer

00:22:56.320 --> 00:22:57.100
session.

00:22:57.100 --> 00:23:00.540
So I have done things
where I am, like, oh,

00:23:00.540 --> 00:23:02.610
I registered an
IdlingResource, and then

00:23:02.610 --> 00:23:06.800
I'm going to go check
some Java-level thing.

00:23:06.800 --> 00:23:10.570
And then it was not actually
waiting for stuff to finish.

00:23:10.570 --> 00:23:14.340
Because what happens is
that it inserts itself

00:23:14.340 --> 00:23:16.580
in the viewAction and
the viewer session.

00:23:16.580 --> 00:23:19.260
So things like
onView, and click,

00:23:19.260 --> 00:23:22.450
and matches-- those are
what I'm talking about.

00:23:22.450 --> 00:23:28.020
So make sure that you are
"waiting" at those points.

00:23:28.020 --> 00:23:30.540
If you think Espresso's
waiting and it's not waiting,

00:23:30.540 --> 00:23:32.360
it could be because
that you are not

00:23:32.360 --> 00:23:35.710
at the point when it's acting
on the viewAction or a viewer

00:23:35.710 --> 00:23:36.930
session.

00:23:36.930 --> 00:23:37.730
Good?

00:23:37.730 --> 00:23:38.230
OK.

00:23:41.170 --> 00:23:41.890
All right.

00:23:41.890 --> 00:23:43.650
So now, this is the
point where I think

00:23:43.650 --> 00:23:45.360
things get really interesting.

00:23:45.360 --> 00:23:49.330
Espresso alone allow you to
click on things and exercise

00:23:49.330 --> 00:23:51.520
co-paths, and verify things.

00:23:51.520 --> 00:23:54.440
But a lot of times,
as Android developers,

00:23:54.440 --> 00:23:57.840
when we want to test, it's more
often architecture problem.

00:23:57.840 --> 00:24:00.590
For example, we are going
to go through an example

00:24:00.590 --> 00:24:05.440
where your app depends
on the current date.

00:24:05.440 --> 00:24:07.357
How am I going to verify things?

00:24:07.357 --> 00:24:08.940
It's going to change
every single day.

00:24:08.940 --> 00:24:11.540
So Dagger and Mockito
allows you to send out

00:24:11.540 --> 00:24:15.620
a test environment that's
predictable and repeatable.

00:24:15.620 --> 00:24:18.360
Dagger-- that's dependency
injection-- that's

00:24:18.360 --> 00:24:19.380
a fancy term.

00:24:19.380 --> 00:24:22.880
All it means is that
in your constructors,

00:24:22.880 --> 00:24:24.660
it's going to have
a central repository

00:24:24.660 --> 00:24:26.620
to grab objects from.

00:24:26.620 --> 00:24:28.932
This way, you can
have one repository

00:24:28.932 --> 00:24:34.220
of objects for your app, and
a different one for your test.

00:24:34.220 --> 00:24:35.080
Oh, wow.

00:24:35.080 --> 00:24:37.630
I just sent what I
wrote on my site.

00:24:37.630 --> 00:24:39.990
That's pretty amazing.

00:24:39.990 --> 00:24:43.806
And Mockito is what you can
use to provide those objects

00:24:43.806 --> 00:24:45.430
in your tests, so
that you can control,

00:24:45.430 --> 00:24:48.410
for example, today's date.

00:24:48.410 --> 00:24:51.920
So this is the basic
formula for Dagger 2.

00:24:51.920 --> 00:24:53.630
Dagger 1 is different.

00:24:53.630 --> 00:24:55.650
What we need to
do is, when I say

00:24:55.650 --> 00:24:57.900
a repository of objects,
what I'm talking about

00:24:57.900 --> 00:24:59.180
is the component.

00:24:59.180 --> 00:25:01.000
So here I have
defined the component,

00:25:01.000 --> 00:25:06.340
and it knows that it can inject
fields into the mainActivity.

00:25:06.340 --> 00:25:08.580
And I have two
different subclauses--

00:25:08.580 --> 00:25:11.100
the ApplicationComponent,
which is empty,

00:25:11.100 --> 00:25:13.660
meaning that it only
rejects-- it only

00:25:13.660 --> 00:25:16.100
injects into the mainActivity.

00:25:16.100 --> 00:25:18.230
And there's a
TestComponent, that it

00:25:18.230 --> 00:25:21.570
will inject also into the test.

00:25:21.570 --> 00:25:24.400
And they are
singletons, because we

00:25:24.400 --> 00:25:28.900
want the same object to
be used in app and test,

00:25:28.900 --> 00:25:30.870
so that when you
change it in your test,

00:25:30.870 --> 00:25:33.620
your app is actually
using that object.

00:25:33.620 --> 00:25:37.860
And here, the way you define
what's inside your component

00:25:37.860 --> 00:25:40.090
is by these annotations.

00:25:40.090 --> 00:25:41.690
So for the application,
we will have

00:25:41.690 --> 00:25:44.810
a clock module that will
actually give you today's date.

00:25:44.810 --> 00:25:47.230
And in the
TestComponent, we will

00:25:47.230 --> 00:25:49.280
provide a mock
ClockModule, so that I can

00:25:49.280 --> 00:25:53.220
control what dates get used.

00:25:53.220 --> 00:25:56.450
And I have given you also
a beautiful diagram in case

00:25:56.450 --> 00:25:58.825
these doesn't make sense, and
what my explanation doesn't

00:25:58.825 --> 00:25:59.390
make sense.

00:25:59.390 --> 00:25:59.890
OK.

00:25:59.890 --> 00:26:01.640
This is just a
graphic representation

00:26:01.640 --> 00:26:03.020
of what I just said, right?

00:26:03.020 --> 00:26:05.900
So here, I have an
ApplicationComponent

00:26:05.900 --> 00:26:10.320
which injects into mainActivity,
and it has a ClockModule that

00:26:10.320 --> 00:26:12.750
knows how to provide a clock.

00:26:12.750 --> 00:26:15.560
And then in Test,
we have a Mock one,

00:26:15.560 --> 00:26:19.660
and it will be injecting into
both the test and the app.

00:26:19.660 --> 00:26:23.790
In the application, in
your onCreate function,

00:26:23.790 --> 00:26:26.230
we are going to go
ahead and instantiate

00:26:26.230 --> 00:26:28.730
one of these
application components.

00:26:28.730 --> 00:26:30.550
The reason why it
has such a funky name

00:26:30.550 --> 00:26:33.260
is that what you
define the application

00:26:33.260 --> 00:26:36.030
components is actually
just an implementation.

00:26:36.030 --> 00:26:40.800
Dagger will go ahead and do some
co-generation behind the scenes

00:26:40.800 --> 00:26:43.440
and generate this class for you.

00:26:43.440 --> 00:26:45.590
Then you can go ahead
and use this class,

00:26:45.590 --> 00:26:47.620
and create an
ApplicationComponent

00:26:47.620 --> 00:26:51.610
and stash it in this variable.

00:26:51.610 --> 00:26:53.580
And then we are
actually also going

00:26:53.580 --> 00:26:55.830
to have a setComponent
function, because we're

00:26:55.830 --> 00:26:57.500
going to use it in Test.

00:26:57.500 --> 00:27:00.350
So what happen is that
when it tests-- actually,

00:27:00.350 --> 00:27:02.413
it's probably going to
be in the slide-- just,

00:27:02.413 --> 00:27:04.412
you know, maybe I shouldn't
get ahead of myself,

00:27:04.412 --> 00:27:06.820
so let me just get
into the next slide.

00:27:06.820 --> 00:27:11.590
So here, what we are going
to do is that-- so stash away

00:27:11.590 --> 00:27:15.316
what I just said-- the part
that we have an app component

00:27:15.316 --> 00:27:17.190
and then we also have
a setComponent function

00:27:17.190 --> 00:27:18.525
which is used in Test.

00:27:18.525 --> 00:27:22.320
So in Test we are going to
have something different

00:27:22.320 --> 00:27:24.460
for the function getNow.

00:27:24.460 --> 00:27:27.780
So in the app-- have
you used joda-time?

00:27:27.780 --> 00:27:31.400
That's a really nice
date and time library

00:27:31.400 --> 00:27:33.400
for Android and for Java.

00:27:33.400 --> 00:27:36.110
So DateTime is what the
joda-time will provide you.

00:27:36.110 --> 00:27:38.700
If you just give it
with no parameters,

00:27:38.700 --> 00:27:42.420
it will give you today's
date and this exact moment.

00:27:42.420 --> 00:27:45.180
In the test, what we
are going to do is,

00:27:45.180 --> 00:27:49.090
we are going to go to the view
that has the ID date-- this

00:27:49.090 --> 00:27:50.550
is actually a TextView.

00:27:50.550 --> 00:27:55.150
And then we're going to verify
that it will display the text

00:27:55.150 --> 00:27:59.200
2008-09-23.

00:27:59.200 --> 00:28:00.930
If you don't use
Mockito and you don't

00:28:00.930 --> 00:28:03.390
have control over
the clock, well,

00:28:03.390 --> 00:28:05.220
then every day that
you run this test

00:28:05.220 --> 00:28:07.330
it's going to display
a different string.

00:28:07.330 --> 00:28:09.365
So you can't really test that.

00:28:09.365 --> 00:28:12.750
So that's the power of
using Mockito and Dagger.

00:28:12.750 --> 00:28:15.130
Dagger allows you to
provide different components

00:28:15.130 --> 00:28:17.140
to your app and your
test, and Mockito

00:28:17.140 --> 00:28:21.000
allows you to mock the
behavior of that class.

00:28:21.000 --> 00:28:23.580
So if you look at it
again, so syntax is, like,

00:28:23.580 --> 00:28:25.460
when this function
is called, then

00:28:25.460 --> 00:28:26.710
return this particular object.

00:28:26.710 --> 00:28:31.570
You don't actually need to write
a function to define things.

00:28:31.570 --> 00:28:33.510
They're, like, all
very fluent, and you

00:28:33.510 --> 00:28:37.800
can define a lot of
different things in Mockito.

00:28:37.800 --> 00:28:40.090
Again, blog post.

00:28:40.090 --> 00:28:41.097
Repository.

00:28:41.097 --> 00:28:43.180
This one is slightly
different, because I actually

00:28:43.180 --> 00:28:46.580
have a course, a video
course that's pre-recorded,

00:28:46.580 --> 00:28:48.835
that I actually step through
one particular example.

00:28:48.835 --> 00:28:51.711
The example is using
shared preferences.

00:28:51.711 --> 00:28:53.710
Because when you think
about shared preferences,

00:28:53.710 --> 00:28:57.040
it changes the state of
your application, right?

00:28:57.040 --> 00:28:59.280
So maybe first time
you open this app,

00:28:59.280 --> 00:29:01.685
someone say that my
favorite animal is cat.

00:29:01.685 --> 00:29:03.060
And then the second
time you come

00:29:03.060 --> 00:29:05.287
back, you want to
show that it's a cat,

00:29:05.287 --> 00:29:07.370
but you don't know whether
it was provided or not.

00:29:07.370 --> 00:29:12.030
And you don't want your test
to modify the state of the app.

00:29:12.030 --> 00:29:12.530
Right?

00:29:12.530 --> 00:29:15.090
Because then it's persisting,
and the next time you run,

00:29:15.090 --> 00:29:17.840
you don't know whether
it's going to be

00:29:17.840 --> 00:29:19.350
having an initial state or not.

00:29:19.350 --> 00:29:23.200
So using Dagger and Mockito, you
can also do things like that.

00:29:23.200 --> 00:29:26.440
You can provide an in-memory
shared preferences,

00:29:26.440 --> 00:29:29.080
which, every time you run it,
it's going to start from fresh.

00:29:29.080 --> 00:29:32.710
[INAUDIBLE] go and delete
your database of the app.

00:29:32.710 --> 00:29:36.660
So that is actually a
course that you have to pay,

00:29:36.660 --> 00:29:40.770
but since you are all here,
there's a coupon called BABBQ.

00:29:40.770 --> 00:29:42.330
If you go there
and you check out,

00:29:42.330 --> 00:29:45.750
you can put that
in for a discount.

00:29:45.750 --> 00:29:47.950
So in summary, we have
gone through a lot.

00:29:47.950 --> 00:29:50.660
Hopefully you still remember,
despite all the drama

00:29:50.660 --> 00:29:54.120
of what we learned today,
this is the basic formula

00:29:54.120 --> 00:29:58.280
of Espresso, where we have
a Matcher, a ViewAction,

00:29:58.280 --> 00:30:00.560
and a ViewAssertion.

00:30:00.560 --> 00:30:03.500
With that, you can combine them
to pinpoint a particular view.

00:30:03.500 --> 00:30:05.790
We were using the
example of a Toolbar.

00:30:05.790 --> 00:30:07.810
And then we actually
used the same example,

00:30:07.810 --> 00:30:10.330
but this time write a Custom
Matcher, because we actually

00:30:10.330 --> 00:30:13.974
want to use the
toolbar.getTitle function.

00:30:13.974 --> 00:30:15.390
After that, we
went through how do

00:30:15.390 --> 00:30:16.806
you test something
in the ListView

00:30:16.806 --> 00:30:18.834
and the RecyclerView,
which, surprisingly,

00:30:18.834 --> 00:30:20.500
is very different,
even though they look

00:30:20.500 --> 00:30:23.080
very similar on the surface.

00:30:23.080 --> 00:30:24.790
Then I went through
an example with you

00:30:24.790 --> 00:30:26.380
on the Idling Resource.

00:30:26.380 --> 00:30:30.990
And finally, I think
most applications will

00:30:30.990 --> 00:30:33.510
need to go beyond
just using Espresso,

00:30:33.510 --> 00:30:35.910
and Dagger and Mockito
are two other libraries

00:30:35.910 --> 00:30:37.970
that is often used in
conjunction, so that you

00:30:37.970 --> 00:30:41.505
can set up your test environment
and have control over the data.

00:30:44.010 --> 00:30:45.620
This is some bonus.

00:30:45.620 --> 00:30:49.570
I actually wrote this app and
open sourced it in August.

00:30:49.570 --> 00:30:53.299
It uses the nearby API, and
it's completely on GitHub.

00:30:53.299 --> 00:30:55.090
You can also download
it on the Play Store,

00:30:55.090 --> 00:30:56.650
if you wanted to just
check out what it does.

00:30:56.650 --> 00:30:57.983
But I'm going to explain to you.

00:30:57.983 --> 00:31:01.040
What it does is that you will
click on that button that says

00:31:01.040 --> 00:31:04.890
Google+ sign-in, and you will
sign in, and then you will open

00:31:04.890 --> 00:31:09.730
this screen to find Nearby
Devices that also has this app.

00:31:09.730 --> 00:31:12.760
And then you exchange
some information.

00:31:12.760 --> 00:31:14.630
How on earth are
we gonna test that?

00:31:14.630 --> 00:31:16.720
How are we going to
test Google+ log in?

00:31:16.720 --> 00:31:18.762
How are we going to
test Nearby Devices?

00:31:18.762 --> 00:31:19.470
Well, guess what?

00:31:19.470 --> 00:31:22.650
This app has really,
really high test coverage,

00:31:22.650 --> 00:31:25.390
because of all the
techniques that I showed you.

00:31:25.390 --> 00:31:27.770
I use Dagger and
Mockito, so I actually

00:31:27.770 --> 00:31:30.280
have a bridge, what I call.

00:31:30.280 --> 00:31:34.067
So instead of calling the
Google API client directly,

00:31:34.067 --> 00:31:35.150
I call through the bridge.

00:31:35.150 --> 00:31:39.760
So I call onConnect--
onConnect?--

00:31:39.760 --> 00:31:44.889
the connect function of my
function through the bridge,

00:31:44.889 --> 00:31:46.555
and then I can use
Mockito, so that, oh,

00:31:46.555 --> 00:31:48.480
if someone call the
connect function,

00:31:48.480 --> 00:31:53.120
then I'm going to capture it,
and then call the onConnected

00:31:53.120 --> 00:31:56.040
function and spit it right
out back and run the Callback

00:31:56.040 --> 00:31:56.860
for them.

00:31:56.860 --> 00:31:58.390
So it's actually
really advanced.

00:31:58.390 --> 00:32:00.765
Much more advanced than what
we have gone through before.

00:32:00.765 --> 00:32:03.160
But it's completely open,
so go ahead and study it.

00:32:03.160 --> 00:32:06.130
And they are also-- beyond that,
we've got Espresso testing.

00:32:06.130 --> 00:32:07.920
It also has JUnit
testing, which is

00:32:07.920 --> 00:32:12.000
testing on the pure Java level,
mostly on the models, right?

00:32:12.000 --> 00:32:16.810
So by model, I mean, in a
Pojo, like a Java object, like,

00:32:16.810 --> 00:32:18.370
stores, different
fields in there,

00:32:18.370 --> 00:32:21.410
so you can make sure that if you
initialize it this certain way,

00:32:21.410 --> 00:32:23.650
it has certain data in it.

00:32:23.650 --> 00:32:26.980
And now I also have what I
call UI-less Instrumentation,

00:32:26.980 --> 00:32:28.930
meaning that it's
instrumentation in the sense

00:32:28.930 --> 00:32:30.400
that you still have contact.

00:32:30.400 --> 00:32:36.830
You still have access to your
standard Android libraries.

00:32:36.830 --> 00:32:39.270
Where, you know, when you do
JUnit, you cannot do bundle,

00:32:39.270 --> 00:32:40.510
you can do all these things.

00:32:40.510 --> 00:32:41.980
But there is no UI.

00:32:41.980 --> 00:32:45.680
So what I'm using that for is
exercising the database code,

00:32:45.680 --> 00:32:46.470
essentially.

00:32:46.470 --> 00:32:48.480
So I'm creating a test
database, and then I'm

00:32:48.480 --> 00:32:49.989
storing things in
it, and then I'm

00:32:49.989 --> 00:32:52.030
calling some function that
will read the database

00:32:52.030 --> 00:32:57.620
and then give me some-- I'm
trying not to kick anything--

00:32:57.620 --> 00:33:00.570
give me some statistics back.

00:33:00.570 --> 00:33:03.280
So that's that
example there as well.

00:33:03.280 --> 00:33:05.640
And then, of course, there's
a lot of Espresso going on.

00:33:05.640 --> 00:33:08.040
So go ahead and
play with the app.

00:33:08.040 --> 00:33:12.230
Again, download it, change
it, and see what it does.

00:33:12.230 --> 00:33:14.530
And if you don't
think this is awesome

00:33:14.530 --> 00:33:16.030
and you don't trust
my word, I have

00:33:16.030 --> 00:33:19.800
someone who said that there are
some seriously badass testing

00:33:19.800 --> 00:33:22.170
kung fu on display.

00:33:22.170 --> 00:33:23.010
Thank you.

00:33:23.010 --> 00:33:24.640
I agree with him,
so-- but you have

00:33:24.640 --> 00:33:26.806
to go check it out and see
if you agree that there's

00:33:26.806 --> 00:33:28.936
some serious badass
testing kung fu

00:33:28.936 --> 00:33:31.960
on display in this repository.

00:33:31.960 --> 00:33:33.940
With that, thank you very much.

00:33:33.940 --> 00:33:36.340
And these are a lot of
the different resources

00:33:36.340 --> 00:33:37.800
that we've covered already.

00:33:37.800 --> 00:33:40.590
The first one is the slide deck.

00:33:40.590 --> 00:33:43.090
And then the rest
are the example code

00:33:43.090 --> 00:33:44.540
that you can find on GitHub.

00:33:44.540 --> 00:33:48.500
And also, I actually also
authored video classes

00:33:48.500 --> 00:33:51.544
on Pluralsight, which is a
subscription-based service.

00:33:51.544 --> 00:33:52.960
You can also check
the [INAUDIBLE]

00:33:52.960 --> 00:33:54.830
other things I teach.

00:33:54.830 --> 00:33:56.716
And then other places
you can find me

00:33:56.716 --> 00:33:58.840
onto the internet-- sorry,
the list is really long.

00:33:58.840 --> 00:34:02.173
I have two newsletters, I
have a blog, I have Twitter,

00:34:02.173 --> 00:34:03.706
I have Google+.

00:34:03.706 --> 00:34:05.690
So plenty of ways to find me.

00:34:05.690 --> 00:34:07.440
So one other thing
that I didn't have time

00:34:07.440 --> 00:34:10.940
to have slide for is
that a lot of people

00:34:10.940 --> 00:34:14.065
tell me that there is so
much effort in doing testing,

00:34:14.065 --> 00:34:15.685
like, why would you bother?

00:34:15.685 --> 00:34:17.060
So I just want to
give you, like,

00:34:17.060 --> 00:34:20.130
one reason why I do it myself.

00:34:20.130 --> 00:34:21.656
I work with startups.

00:34:21.656 --> 00:34:23.989
And a lot of the times they
will have a server team that

00:34:23.989 --> 00:34:25.610
needs to implement
some server change

00:34:25.610 --> 00:34:28.270
before I can implement
the Android UI change.

00:34:28.270 --> 00:34:29.650
And they are slow.

00:34:29.650 --> 00:34:32.009
They're usually slower
than-- well, you know, we

00:34:32.009 --> 00:34:33.280
will do a sprint, and
then they'll say, oh,

00:34:33.280 --> 00:34:34.880
let's go and implement
that, and I'm

00:34:34.880 --> 00:34:36.500
supposed to be implementing
that in that sprint,

00:34:36.500 --> 00:34:38.760
and I'm, like, holding my
breath and waiting for them

00:34:38.760 --> 00:34:40.360
to implement the server change.

00:34:40.360 --> 00:34:41.239
Well, no more.

00:34:41.239 --> 00:34:43.190
Because I have Mockito.

00:34:43.190 --> 00:34:44.880
I actually use Mock Web Server.

00:34:44.880 --> 00:34:47.300
So what I do is
that I have my test,

00:34:47.300 --> 00:34:50.270
and all I need to do is agree
on the Java-- not the Java,

00:34:50.270 --> 00:34:52.997
the JSON format--
with my server team,

00:34:52.997 --> 00:34:54.580
and then I will just
mock out whatever

00:34:54.580 --> 00:34:58.510
I expect the response from
the server is going to be.

00:34:58.510 --> 00:35:02.380
And I can go ahead and write the
UI code before they are ready.

00:35:02.380 --> 00:35:04.430
And I can even test
bad cases, right?

00:35:04.430 --> 00:35:06.900
What if I get a 500 error?

00:35:06.900 --> 00:35:08.510
Like, what would my app behave?

00:35:08.510 --> 00:35:10.120
You don't usually
test a happy path.

00:35:10.120 --> 00:35:11.703
And it's really
difficult. How are you

00:35:11.703 --> 00:35:13.412
going to do that in
a real life scenario?

00:35:13.412 --> 00:35:15.786
Are you going to ask them to
shut down the server so they

00:35:15.786 --> 00:35:17.090
can test your 500 case?

00:35:17.090 --> 00:35:18.020
No, right?

00:35:18.020 --> 00:35:21.120
But in our case, if I have set
up my testing infrastructure,

00:35:21.120 --> 00:35:24.530
I have complete control of what
my mock server is going to do,

00:35:24.530 --> 00:35:27.475
and I can go ahead and write
my app without the server

00:35:27.475 --> 00:35:29.132
ready by "testing."

00:35:29.132 --> 00:35:30.090
So "testing" in quotes.

00:35:30.090 --> 00:35:31.920
So that's actually
how I use testing.

00:35:31.920 --> 00:35:33.760
Which, of course,
then the side benefit

00:35:33.760 --> 00:35:37.020
is that it is actually
automatically running, right?

00:35:37.020 --> 00:35:38.570
So I can also catch regressions.

00:35:38.570 --> 00:35:41.270
So sometimes I will change
one thing in my style,

00:35:41.270 --> 00:35:43.920
thinking that will be all
good, but then Espresso

00:35:43.920 --> 00:35:45.670
will be, like, yeah,
you said the color is

00:35:45.670 --> 00:35:48.260
supposed to be gray, um,
it's actually purple now.

00:35:48.260 --> 00:35:51.080
So I can also catch regression
because I have written my test.

00:35:51.080 --> 00:35:54.170
So I almost look at
that as a side benefit

00:35:54.170 --> 00:35:55.296
of, like, the testing part.

00:35:55.296 --> 00:35:56.961
Like, the part I
really like is the fact

00:35:56.961 --> 00:35:58.750
that I can mock out
a server, and then I

00:35:58.750 --> 00:36:01.270
can go ahead and write my
app without my server team

00:36:01.270 --> 00:36:02.980
being ready.

00:36:02.980 --> 00:36:05.800
So with that, thank
you very much.

00:36:05.800 --> 00:36:09.345
Thank you for tolerating
with my kicking of the sand.

00:36:09.345 --> 00:36:10.090
Thank you.

00:36:10.090 --> 00:36:11.521
[APPLAUSE]

00:36:16.770 --> 00:36:17.640
Feel free to leave.

00:36:17.640 --> 00:36:20.022
But I can also take some
questions right now.

00:36:20.022 --> 00:36:20.522
Yeah.

00:36:20.522 --> 00:36:21.438
AUDIENCE: [INAUDIBLE].

00:36:29.200 --> 00:36:31.450
CHIU-KI CHAN: OK.

00:36:31.450 --> 00:36:34.580
So the question was, because
of technical difficulty,

00:36:34.580 --> 00:36:36.280
we were interrupted
right at the Dagger

00:36:36.280 --> 00:36:37.720
point, which is kind of tricky.

00:36:37.720 --> 00:36:40.520
So he wants to know how
you can set up Dagger 2.

00:36:40.520 --> 00:36:44.120
If you go to my
GitHub repository,

00:36:44.120 --> 00:36:49.950
there is a sample project that
is called Android-test-demo.

00:36:49.950 --> 00:36:52.995
It uses Dagger 2,
Mockito, and Espresso 2.

00:36:52.995 --> 00:36:55.020
And that's a blog
post that's linked

00:36:55.020 --> 00:36:57.261
from there, in the written.

00:36:57.261 --> 00:37:00.530
So I hope that the blog post
will explain pretty well how,

00:37:00.530 --> 00:37:03.090
step-by-step, how you set it up.

00:37:03.090 --> 00:37:05.051
Yeah, you can refer to that.

00:37:05.051 --> 00:37:05.550
Yes.

00:37:05.550 --> 00:37:06.435
Question.

00:37:06.435 --> 00:37:07.425
AUDIENCE: Yeah.

00:37:07.425 --> 00:37:10.395
When you discussed the
custom IdlingResource,

00:37:10.395 --> 00:37:11.880
I had a question.

00:37:11.880 --> 00:37:15.015
It may be due to bad application
design, or something like that,

00:37:15.015 --> 00:37:18.005
but it seems like there's a
potential for a race condition

00:37:18.005 --> 00:37:20.463
if you're checking for whether
or not a service is running,

00:37:20.463 --> 00:37:24.720
and that service has been built
multiple times from the test

00:37:24.720 --> 00:37:25.670
client.

00:37:25.670 --> 00:37:29.090
Is there a way to have, like,
a named task on the items

00:37:29.090 --> 00:37:32.450
resource, so you can see whether
or not the IntentService has

00:37:32.450 --> 00:37:35.542
completed its specific
request to fulfill action,

00:37:35.542 --> 00:37:37.750
as opposed to whether or
not you want to get general?

00:37:37.750 --> 00:37:38.458
CHIU-KI CHAN: OK.

00:37:38.458 --> 00:37:41.480
The question was, can I
improve the IdlingResource

00:37:41.480 --> 00:37:42.855
for the IntentService,
so instead

00:37:42.855 --> 00:37:45.170
of checking whether the whole
IntentService is running,

00:37:45.170 --> 00:37:47.200
can I check a specific task?

00:37:47.200 --> 00:37:47.825
AUDIENCE: Yeah.

00:37:47.825 --> 00:37:50.390
CHIU-KI CHAN: I don't know
off the top of my head

00:37:50.390 --> 00:37:53.490
whether IntentService
is queryable,

00:37:53.490 --> 00:37:54.540
if that makes any sense.

00:37:54.540 --> 00:37:56.690
I can ask it what it's running.

00:37:56.690 --> 00:38:00.420
And it's kind of not really
Espresso-specific, right?

00:38:00.420 --> 00:38:02.639
Because it's basically
IntentService-specific.

00:38:02.639 --> 00:38:04.930
You're trying to detect
whether your particular task is

00:38:04.930 --> 00:38:05.910
running.

00:38:05.910 --> 00:38:06.680
So, sorry.

00:38:06.680 --> 00:38:08.640
I don't know.

00:38:08.640 --> 00:38:10.508
Sorry.

00:38:10.508 --> 00:38:11.008
Question.

00:38:11.008 --> 00:38:11.924
AUDIENCE: [INAUDIBLE].

00:38:41.784 --> 00:38:43.200
CHIU-KI CHAN: So
the question was,

00:38:43.200 --> 00:38:46.920
he has a ViewPager that
has multiple RecyclerView

00:38:46.920 --> 00:38:49.170
on the different
pages, essentially.

00:38:49.170 --> 00:38:52.220
And he will swipe
and said that, OK,

00:38:52.220 --> 00:38:53.550
this one is the visible one.

00:38:53.550 --> 00:38:56.030
I want to test it,
but differently.

00:38:56.030 --> 00:38:58.349
The other [INAUDIBLE]
is still hanging out,

00:38:58.349 --> 00:39:00.140
because that's how he
can slide it back in.

00:39:00.140 --> 00:39:02.720
And he's asking,
how can I make sure

00:39:02.720 --> 00:39:05.791
that I'm verifying the
one that I want to verify.

00:39:05.791 --> 00:39:06.290
Right?

00:39:06.290 --> 00:39:07.806
Does that sound good?

00:39:07.806 --> 00:39:08.805
Give them different IDs?

00:39:11.660 --> 00:39:12.310
Does that work?

00:39:12.310 --> 00:39:13.652
AUDIENCE: Uh, yeah. [INAUDIBLE].

00:39:17.020 --> 00:39:18.020
CHIU-KI CHAN: Oh, I see.

00:39:18.020 --> 00:39:22.045
So they're dynamically-- So
they're dynamically attached,

00:39:22.045 --> 00:39:24.330
so it's not going to
be using the IDs that

00:39:24.330 --> 00:39:25.645
is from the XML file.

00:39:25.645 --> 00:39:26.561
AUDIENCE: [INAUDIBLE].

00:39:32.840 --> 00:39:34.710
CHIU-KI CHAN: OK.

00:39:34.710 --> 00:39:36.560
He said he uses dynamic tests.

00:39:36.560 --> 00:39:37.680
I think that's reasonable.

00:39:37.680 --> 00:39:40.060
I mean, I was going to suggest
something similar, right?

00:39:40.060 --> 00:39:43.032
You can just issue new
UIDs, essentially, to them,

00:39:43.032 --> 00:39:44.240
and then you can verify them.

00:39:44.240 --> 00:39:46.020
But that's going to
be random, though.

00:39:46.020 --> 00:39:47.853
So if you have something
that's predictable,

00:39:47.853 --> 00:39:49.440
then you can go look for them.

00:39:49.440 --> 00:39:53.335
So I think you are doing
something quite reasonable.

00:39:53.335 --> 00:39:54.710
I mean, there may
be better ways,

00:39:54.710 --> 00:39:57.600
but I cannot think
of it right now.

00:39:57.600 --> 00:39:58.100
Yeah.

00:40:01.028 --> 00:40:02.004
Another question.

00:40:02.004 --> 00:40:02.920
AUDIENCE: [INAUDIBLE].

00:40:15.200 --> 00:40:17.350
CHIU-KI CHAN: So the
question was, get real, now.

00:40:17.350 --> 00:40:21.000
How much time did you spend
on writing all your tests?

00:40:21.000 --> 00:40:22.640
So it's true.

00:40:22.640 --> 00:40:23.690
Like, the set up.

00:40:23.690 --> 00:40:25.560
Like, you actually
add some complexity

00:40:25.560 --> 00:40:28.090
by using Dagger,
and making it so

00:40:28.090 --> 00:40:30.200
that you can mock and whatnot.

00:40:30.200 --> 00:40:34.019
I have not clocked the
hours that I'm strictly

00:40:34.019 --> 00:40:36.310
writing tests versus when
I'm strictly writing the app,

00:40:36.310 --> 00:40:38.400
because the way I
describe I work, right?

00:40:38.400 --> 00:40:40.370
I use the test to drive my app.

00:40:40.370 --> 00:40:42.550
I will mock out the
server response,

00:40:42.550 --> 00:40:44.820
and then go implement
something in a test and run it.

00:40:44.820 --> 00:40:49.430
So for me, it's a very integral
part of my development habit,

00:40:49.430 --> 00:40:50.350
essentially.

00:40:50.350 --> 00:40:53.010
So I can't really tell you
specifically how much time.

00:40:53.010 --> 00:40:55.606
But what I can tell you is this.

00:40:55.606 --> 00:40:59.150
There are times when it
caught things that I would not

00:40:59.150 --> 00:41:00.930
caught on my own.

00:41:00.930 --> 00:41:05.460
For example, what I did
was, I did a map fragment

00:41:05.460 --> 00:41:07.660
which I was inflating
dynamically, rather than

00:41:07.660 --> 00:41:10.100
statically, for some reason.

00:41:10.100 --> 00:41:12.900
And when I upgrade from
Google Play Services--

00:41:12.900 --> 00:41:15.400
I don't know, 6.5
to 7 or something,

00:41:15.400 --> 00:41:17.940
some version-- it broke.

00:41:17.940 --> 00:41:20.500
And usually I don't go
to the part of my app

00:41:20.500 --> 00:41:23.020
that has the map on it,
because it's kind of not

00:41:23.020 --> 00:41:26.090
on the main use case, but my
test caught it right away,

00:41:26.090 --> 00:41:27.490
because it crashed.

00:41:27.490 --> 00:41:32.450
So I feel like the value
is very hard to quantify.

00:41:32.450 --> 00:41:35.377
Like, when I didn't
have the test,

00:41:35.377 --> 00:41:37.910
then it would probably be
launched with that crash,

00:41:37.910 --> 00:41:40.420
and people will yell at
me from the internet,

00:41:40.420 --> 00:41:42.030
and then I have to go find out.

00:41:42.030 --> 00:41:44.850
So I don't really have
a hard number for you.

00:41:44.850 --> 00:41:47.320
But I find it very--
it's worth doing.

00:41:47.320 --> 00:41:49.060
I mean, I think that's
the short answer.

00:41:49.060 --> 00:41:50.435
And you have to
check me on that,

00:41:50.435 --> 00:41:53.390
because I don't
have data for you.

00:41:53.390 --> 00:41:54.030
Cool.

00:41:54.030 --> 00:41:55.180
Well, thank you very much.

00:41:55.180 --> 00:41:57.740
I'm going to stay
around a bit, so we

00:41:57.740 --> 00:41:59.170
can chat off-stage as well.

00:41:59.170 --> 00:41:59.700
OK?

00:41:59.700 --> 00:42:00.200
Thank you.

00:42:00.200 --> 00:42:01.400
[APPLAUSE]

00:42:01.400 --> 00:42:03.550
[MUSIC PLAYING]

