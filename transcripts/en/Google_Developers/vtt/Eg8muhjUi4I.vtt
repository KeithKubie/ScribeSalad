WEBVTT
Kind: captions
Language: en

00:00:02.687 --> 00:00:05.020
MANDY WAITE: We're going to
be talking for about an hour

00:00:05.020 --> 00:00:08.720
or so on how to design, build
a [INAUDIBLE] application.

00:00:08.720 --> 00:00:12.440
We're going to use an
example application, one

00:00:12.440 --> 00:00:15.750
that we wrote specifically
for a specific purpose.

00:00:15.750 --> 00:00:18.010
I'm going to walk through
the kind of design decisions

00:00:18.010 --> 00:00:20.093
that we made when it came
to build an application.

00:00:21.100 --> 00:00:24.680
Why we made them, if there
are any other drawbacks,

00:00:24.680 --> 00:00:26.920
any other pitfalls,
and just basically

00:00:26.920 --> 00:00:28.795
drill down into the
application architecture.

00:00:29.840 --> 00:00:33.400
And so how many of you
either went to Google I/O,

00:00:33.400 --> 00:00:35.230
or went to Google I/O Extended?

00:00:37.110 --> 00:00:38.070
OK, a few of you.

00:00:38.070 --> 00:00:38.570
OK.

00:00:38.570 --> 00:00:42.545
So those of you that
did see the talks.

00:00:42.545 --> 00:00:45.540
And if you saw the cloud
stuff specifically,

00:00:45.540 --> 00:00:48.330
the keynote and the
track that contained

00:00:48.330 --> 00:00:51.020
the cloud specific
talks, you may

00:00:51.020 --> 00:00:53.360
have seen this application
called, WalkShare.

00:00:53.360 --> 00:00:56.110
So what we decided to
do for the whole event

00:00:56.110 --> 00:00:59.610
was to have one application as
a theme for all of the talks.

00:00:59.610 --> 00:01:01.140
Well, at least
half of the talks.

00:01:01.140 --> 00:01:02.640
Some talks didn't
really go anywhere

00:01:02.640 --> 00:01:05.110
near WalkShare, where
they could've done.

00:01:05.110 --> 00:01:07.014
So a couple of months
before Google I/O,

00:01:07.014 --> 00:01:08.930
we took the decision to
build this application

00:01:08.930 --> 00:01:09.638
called WalkShare.

00:01:10.590 --> 00:01:12.015
Anybody guess what it does?

00:01:12.015 --> 00:01:12.514
Yeah?

00:01:13.840 --> 00:01:17.710
So basically, it gathers data,
GPS track data from your phone

00:01:17.710 --> 00:01:21.050
as you're walking along,
as you're doing a fun walk.

00:01:21.050 --> 00:01:23.440
And at the end of the
walk, you can then

00:01:23.440 --> 00:01:26.320
upload it to the internet and
share it with your friends.

00:01:26.320 --> 00:01:28.589
Your friends can
then comment on it.

00:01:28.589 --> 00:01:29.880
This is an Android application.

00:01:29.880 --> 00:01:31.590
We don't have iOS support.

00:01:31.590 --> 00:01:33.830
We were demonstrating
the features of Android

00:01:33.830 --> 00:01:34.550
specifically.

00:01:34.550 --> 00:01:37.400
But we also had a web
front end as well.

00:01:37.400 --> 00:01:38.910
And this is the web front end.

00:01:38.910 --> 00:01:41.320
This effectively allow people
to go and look at walks

00:01:41.320 --> 00:01:43.240
and make comments on the walks.

00:01:43.240 --> 00:01:46.020
So here's an example
here of a walk.

00:01:46.020 --> 00:01:48.680
Sorry, can we
switch to the demo?

00:01:54.166 --> 00:01:56.605
So this is an example walk.

00:01:56.605 --> 00:01:58.480
One of the guys who
wrote this did this walk.

00:01:58.480 --> 00:01:59.470
This is the Googleplex.

00:02:00.770 --> 00:02:04.390
And basically what we're
doing, as the walk progresses,

00:02:04.390 --> 00:02:09.380
we're recording GPS tracks, GPS
positions at certain places,

00:02:09.380 --> 00:02:10.949
at certain points
within the walk,

00:02:10.949 --> 00:02:12.590
then uploading
them to the cloud.

00:02:12.590 --> 00:02:15.080
Then we have this
web user interface

00:02:15.080 --> 00:02:17.184
that can actually
display the walk.

00:02:17.184 --> 00:02:18.600
And what it's doing
is effectively

00:02:18.600 --> 00:02:20.540
looking at the lat-long
of the GPS track,

00:02:20.540 --> 00:02:23.252
and finding the appropriate
Street View image

00:02:23.252 --> 00:02:24.960
to effectively show
you what the walk was

00:02:24.960 --> 00:02:26.447
like using Street View.

00:02:29.250 --> 00:02:30.690
So that's the Googleplex.

00:02:33.990 --> 00:02:36.130
You can always make
comments, and so there's

00:02:36.130 --> 00:02:37.435
some comments on here.

00:02:37.435 --> 00:02:38.950
And I can add another comment.

00:02:40.139 --> 00:02:40.805
Let's say Mandy.

00:02:42.830 --> 00:02:46.848
And, hey, that was a long walk.

00:02:48.415 --> 00:02:49.790
And just to
highlight something--

00:02:49.790 --> 00:02:51.415
I meant to delete
this comment earlier.

00:02:51.415 --> 00:02:53.690
But if I put a smiley
face in there--

00:02:53.690 --> 00:02:57.470
there's a bug in our
code-- and hit Return,

00:02:57.470 --> 00:02:58.372
I get double smilies.

00:02:58.372 --> 00:03:00.080
And this is a Unicode
conversion problem.

00:03:00.080 --> 00:03:01.980
There's a bug in the
code that we'd really

00:03:01.980 --> 00:03:03.180
like to fix at some point.

00:03:03.180 --> 00:03:04.959
So I've added comments.

00:03:04.959 --> 00:03:06.500
Can we go back to
the slides, please?

00:03:11.370 --> 00:03:13.120
So that was a demo.

00:03:14.380 --> 00:03:17.650
So we basically have two
major user interfaces

00:03:17.650 --> 00:03:18.850
for our application.

00:03:18.850 --> 00:03:21.780
We have a web application
that allows us to view walks,

00:03:21.780 --> 00:03:23.970
and we have the Android
application itself.

00:03:23.970 --> 00:03:26.197
So obviously we need
some point, some place

00:03:26.197 --> 00:03:28.280
where we can actually share
data between these two

00:03:28.280 --> 00:03:30.320
instances of the user interface.

00:03:30.320 --> 00:03:34.124
And for that, we need
to supply an API.

00:03:34.124 --> 00:03:35.540
For a traditional
web application,

00:03:35.540 --> 00:03:37.470
we don't actually need an API.

00:03:37.470 --> 00:03:40.010
For a mobile device,
you really do.

00:03:40.010 --> 00:03:42.170
But in this case, we're
using the same API

00:03:42.170 --> 00:03:44.210
to read the same kind of data.

00:03:44.210 --> 00:03:46.840
And in the best practices
of micro services.

00:03:46.840 --> 00:03:49.190
And we'll talk more about
modular application design

00:03:49.190 --> 00:03:50.041
later.

00:03:50.041 --> 00:03:51.665
We chose to make a
modular application.

00:03:51.665 --> 00:03:54.160
And the modules were Tracks.

00:03:54.160 --> 00:03:57.060
This is effectively gathering
track data from the mobile app,

00:03:57.060 --> 00:04:00.330
and also pushing that track data
out to the web user interface.

00:04:01.630 --> 00:04:04.220
A Comment module
that allows to handle

00:04:04.220 --> 00:04:06.790
all the aspects of
commenting, and a Leaderboard

00:04:06.790 --> 00:04:09.040
module, because we
wanted to display the top

00:04:09.040 --> 00:04:11.790
walks-- or not necessarily
a top walks in this case.

00:04:11.790 --> 00:04:13.860
I'm not quite sure why
we designed it this way.

00:04:13.860 --> 00:04:16.650
But we basically
have the top users,

00:04:16.650 --> 00:04:18.525
the ones whose walks
had the most comments.

00:04:20.659 --> 00:04:22.950
In order to make this work,
we need persistent storage.

00:04:22.950 --> 00:04:25.099
We need persistent
storage or free modules

00:04:25.099 --> 00:04:25.890
of the application.

00:04:25.890 --> 00:04:29.120
And we also need temporary
storage, which we'll see later.

00:04:29.120 --> 00:04:31.482
So we're going to go into
architecture in detail.

00:04:31.482 --> 00:04:32.940
Quickly running
through the agenda,

00:04:32.940 --> 00:04:34.240
this is what we're going to do.

00:04:34.240 --> 00:04:36.156
Architectural decisions,
plan for getting big,

00:04:36.156 --> 00:04:38.340
scaling, running the
app in production,

00:04:38.340 --> 00:04:40.110
which we may not get to.

00:04:40.110 --> 00:04:42.830
This talk generally runs
for about 75 minutes.

00:04:42.830 --> 00:04:44.570
So we're going to
drop something.

00:04:44.570 --> 00:04:46.236
So I'm going to try
and be a bit dynamic

00:04:46.236 --> 00:04:47.410
in the way we present it.

00:04:47.410 --> 00:04:48.740
And then finally,
I'm definitely going

00:04:48.740 --> 00:04:50.240
to go through the
coming soon stuff.

00:04:51.630 --> 00:04:53.190
So architecture decisions.

00:04:53.190 --> 00:04:57.710
This is our shopping list for
our WalkShare application.

00:04:57.710 --> 00:05:00.530
We wanted somewhere to store
the data from the mobile device.

00:05:00.530 --> 00:05:02.090
So it had to be
persistent, and it

00:05:02.090 --> 00:05:03.631
had to be accessible
from the mobile.

00:05:04.440 --> 00:05:10.356
We also needed a modular,
autoscaling, frontend, and API.

00:05:10.356 --> 00:05:11.980
We needed things to
be easy to develop.

00:05:11.980 --> 00:05:13.189
After all, we work at Google.

00:05:13.189 --> 00:05:15.604
We're really busy, and we don't
have a huge amount of time

00:05:15.604 --> 00:05:17.590
to spend developing
applications at Google I/O.

00:05:17.590 --> 00:05:19.740
And also, because it's likely
to break during the keynote,

00:05:19.740 --> 00:05:21.680
it needs to be very easy to
maintain so we can go up there

00:05:21.680 --> 00:05:23.388
on stage and fix it
and look really cool.

00:05:24.460 --> 00:05:26.610
We also need robust
commenting system.

00:05:26.610 --> 00:05:29.100
We'll talk about
that more shortly.

00:05:29.100 --> 00:05:31.520
And we also need a database
for temp/summary data.

00:05:31.520 --> 00:05:34.140
And again, the reasons why
we need another database

00:05:34.140 --> 00:05:36.700
for storing temporary data,
we'll talk about later.

00:05:38.600 --> 00:05:41.027
So the first question is,
where do we store our walks?

00:05:41.027 --> 00:05:42.235
[INAUDIBLE] these GPS tracks.

00:05:43.540 --> 00:05:46.240
So for this, on
our shopping list

00:05:46.240 --> 00:05:50.490
is storage that's available
to us from a mobile device.

00:05:50.490 --> 00:05:52.400
So we can upload
data from a mobile,

00:05:52.400 --> 00:05:54.483
and access it through the
rest of the application.

00:05:55.580 --> 00:05:57.860
So for this, we chose
Cloud Datastore.

00:05:57.860 --> 00:05:59.360
And the Cloud
Datastore, we're going

00:05:59.360 --> 00:06:03.720
to get into the
details of why and what

00:06:03.720 --> 00:06:06.330
the Cloud Datastore
does shortly.

00:06:06.330 --> 00:06:07.960
Why did we choose
the Cloud Datastore?

00:06:09.250 --> 00:06:11.770
So this is the Cloud Datastore.

00:06:11.770 --> 00:06:14.180
It's something that we
use internally, and is

00:06:14.180 --> 00:06:15.986
exposed externally as a service.

00:06:15.986 --> 00:06:18.652
We're going to get more into the
details and the history of that

00:06:18.652 --> 00:06:19.970
in the next slide.

00:06:19.970 --> 00:06:22.749
It's effectively an
NoSQL Store, a key value

00:06:22.749 --> 00:06:24.040
store that can scale massively.

00:06:25.240 --> 00:06:29.400
It has ACID transactions,
support for ACID transactions,

00:06:29.400 --> 00:06:31.530
strong consistency on
reads and these things

00:06:31.530 --> 00:06:34.075
called ancestor queries,
where we can group data,

00:06:34.075 --> 00:06:36.590
or make queries along
that group of data,

00:06:36.590 --> 00:06:38.370
and get extremely
good performance,

00:06:38.370 --> 00:06:41.630
and also strong
consistency across-- which

00:06:41.630 --> 00:06:44.220
is where our temporary
data problem comes along

00:06:44.220 --> 00:06:47.867
across these entity groups,
these ancestor groups,

00:06:47.867 --> 00:06:49.450
we have a bit more
of a problem, which

00:06:49.450 --> 00:06:50.949
is why we need a
temporary database.

00:06:51.750 --> 00:06:53.320
It's completely schemaless.

00:06:53.320 --> 00:06:55.900
You don't need to think about
the underlying data structure,

00:06:55.900 --> 00:06:57.440
although, our
abstraction libraries.

00:06:57.440 --> 00:07:01.340
So we have the Java, which
includes JDO and JPA.

00:07:01.340 --> 00:07:03.250
Might force you down
that route anyway.

00:07:03.250 --> 00:07:05.630
And you can also
use Python as well,

00:07:05.630 --> 00:07:10.040
and you can also create models
from those abstractions.

00:07:10.040 --> 00:07:11.690
So you don't have to
have a data model,

00:07:11.690 --> 00:07:13.231
but you can through
the abstractions.

00:07:14.260 --> 00:07:16.310
And as mentioned, it
scales automatically.

00:07:16.310 --> 00:07:17.560
You don't have to do anything.

00:07:17.560 --> 00:07:19.200
There's nothing you need to
do in terms of provisioning

00:07:19.200 --> 00:07:21.140
infrastructure, just
like with BigQuery.

00:07:21.140 --> 00:07:23.305
It's completely
managed for you shard

00:07:23.305 --> 00:07:25.420
and replication all
taken care of for you.

00:07:25.420 --> 00:07:27.600
And there were some shortcuts
we might mention later

00:07:27.600 --> 00:07:29.517
that might help you with that.

00:07:29.517 --> 00:07:31.600
But generally, you don't
have to worry about scale

00:07:31.600 --> 00:07:33.120
at all with Cloud Datastore.

00:07:34.990 --> 00:07:37.666
So back in the day, we invented
this thing called, BigTable.

00:07:37.666 --> 00:07:39.040
We published a
white paper on it.

00:07:39.040 --> 00:07:42.010
And BigTable is this
massively scalable

00:07:42.010 --> 00:07:43.920
NoSQL data store that
we use internally

00:07:43.920 --> 00:07:46.050
for services such as Gmail.

00:07:46.050 --> 00:07:50.867
And when we built App Engine to
service our needs for something

00:07:50.867 --> 00:07:52.700
that would serve web
applications internally

00:07:52.700 --> 00:07:55.020
within Google, we
decided to build

00:07:55.020 --> 00:07:58.114
App Engine around BigTable--
added a layer on top of it.

00:07:58.114 --> 00:07:59.530
Since then, another
layer has been

00:07:59.530 --> 00:08:00.830
added in between those layers.

00:08:00.830 --> 00:08:02.820
But we have BigTable,
Megastore, and then

00:08:02.820 --> 00:08:04.630
we have the Datastore
on top of it.

00:08:04.630 --> 00:08:06.660
So we're effectively
accessing this BigTable

00:08:06.660 --> 00:08:10.010
through Datastore, and
that was tied to App Engine

00:08:10.010 --> 00:08:12.230
for quite awhile,
for about five years.

00:08:12.230 --> 00:08:14.710
But now it's available
everywhere as an API.

00:08:14.710 --> 00:08:16.880
So we've opened it up
completely, no longer just

00:08:16.880 --> 00:08:18.170
requires App Engine.

00:08:18.170 --> 00:08:21.260
You can access it as an
API-- either a restful API,

00:08:21.260 --> 00:08:22.690
or a protocol buffers API.

00:08:23.932 --> 00:08:25.390
One of the great
things about it is

00:08:25.390 --> 00:08:29.144
if you run a query on a data
set within the Datastore,

00:08:29.144 --> 00:08:31.310
if it's 100 megabytes,
you're running the same query

00:08:31.310 --> 00:08:32.910
across 100 megabytes
or 100 gigabytes.

00:08:32.910 --> 00:08:36.520
It will take the same amount
of time to come back to you.

00:08:36.520 --> 00:08:38.590
So the data set,
the size of data,

00:08:38.590 --> 00:08:41.690
it doesn't matter when it
comes to running queries.

00:08:41.690 --> 00:08:44.230
Data, of course, is replicated
across multiple data centers

00:08:44.230 --> 00:08:45.479
in a region.

00:08:45.479 --> 00:08:46.395
The stage is creaking.

00:08:47.680 --> 00:08:50.240
And you can use it from any
application and language.

00:08:50.240 --> 00:08:51.650
It's a restful API.

00:08:51.650 --> 00:08:54.460
We have client library
support for most

00:08:54.460 --> 00:08:57.510
of the major popular
programming engines.

00:08:57.510 --> 00:09:00.930
At the time of writing, and it's
probably increased since then,

00:09:00.930 --> 00:09:03.399
we were serving about 4 and
1/2 trillion requests per month

00:09:03.399 --> 00:09:04.440
with the Cloud Datastore.

00:09:07.342 --> 00:09:09.601
What about other situations
that might arise?

00:09:09.601 --> 00:09:10.600
What about alternatives?

00:09:12.100 --> 00:09:15.872
So if you have an application--
and this planes well-- decision

00:09:15.872 --> 00:09:18.330
making process, we were never
going to build this with SQL.

00:09:18.330 --> 00:09:20.670
But if you have an
application of your own

00:09:20.670 --> 00:09:24.570
that already uses SQL, and you
want to pull it into the cloud,

00:09:24.570 --> 00:09:28.019
and run it in the cloud, and
make use of managed Cloud SQL

00:09:28.019 --> 00:09:30.060
resources, then you could
do this with Cloud SQL.

00:09:31.650 --> 00:09:34.255
Cloud SQL is effectively
MySQL in the Cloud.

00:09:34.255 --> 00:09:38.670
It offers you managed instances
of MySQL, up to 16 GB of RAM,

00:09:38.670 --> 00:09:42.150
and 100 GB storage, and
fully managed for you.

00:09:42.150 --> 00:09:44.230
All you have to do
is create a databases

00:09:44.230 --> 00:09:47.875
and add and manage your
data in the form of tables.

00:09:49.390 --> 00:09:52.890
Again, data is replicated
in many geographic locations

00:09:52.890 --> 00:09:55.630
within a region,
and all the failover

00:09:55.630 --> 00:09:57.750
handled automatically for you.

00:09:57.750 --> 00:09:59.799
And we have a scheduling
mechanism for backups

00:09:59.799 --> 00:10:01.340
as well, so we can
do backups for you

00:10:01.340 --> 00:10:05.820
on your behalf-- schedule those
backups via user interface.

00:10:06.990 --> 00:10:09.190
It also is very
easy to get access

00:10:09.190 --> 00:10:12.870
to, easy to migrate data
from and to Cloud SQL.

00:10:12.870 --> 00:10:14.650
It support things
like MySQL dump.

00:10:14.650 --> 00:10:17.190
It supports the
MySQL wire protocol,

00:10:17.190 --> 00:10:19.440
which means you can
use the MySQL client.

00:10:19.440 --> 00:10:20.790
And it supports JDBC.

00:10:20.790 --> 00:10:23.149
So it's just like MySQL,
except when in the Cloud,

00:10:23.149 --> 00:10:24.440
[INAUDIBLE] is managed for you.

00:10:27.000 --> 00:10:28.780
It has a flexible
challenging model.

00:10:28.780 --> 00:10:31.430
So you can either
choose for pay per use,

00:10:31.430 --> 00:10:33.420
pay as you go to
effectively with MySQL,

00:10:33.420 --> 00:10:35.750
of you can choose
a package option.

00:10:35.750 --> 00:10:40.270
It's available in EU, US,
and Asia data centers.

00:10:40.270 --> 00:10:42.340
And if you're using
App Engine and you

00:10:42.340 --> 00:10:46.060
want to use a Cloud SQL, you
will co-locate your MySQL

00:10:46.060 --> 00:10:50.680
instances with the application--
either be in EU or US.

00:10:50.680 --> 00:10:54.700
We don't have App Engine
support within Asia currently,

00:10:54.700 --> 00:10:57.180
although you can run AccessApps
from App Engine in Asia.

00:10:57.180 --> 00:10:58.200
Not in China though.

00:11:00.350 --> 00:11:01.800
So what about files?

00:11:01.800 --> 00:11:03.770
What about large blob data?

00:11:03.770 --> 00:11:06.380
Images, videos, backups,
those kind of things?

00:11:06.380 --> 00:11:08.185
So for that, we
have cloud storage.

00:11:08.185 --> 00:11:10.990
And cloud storage is a bucket
based storage, an objects

00:11:10.990 --> 00:11:11.705
store.

00:11:11.705 --> 00:11:13.121
It allows you to
store pretty much

00:11:13.121 --> 00:11:16.190
any amount of data-- up
to 5 terabytes per object.

00:11:16.190 --> 00:11:18.030
It supports full object version.

00:11:18.030 --> 00:11:20.510
So you can turn versioning on
and support multiple versions

00:11:20.510 --> 00:11:23.050
of your objects, keep
a history of them.

00:11:23.050 --> 00:11:24.710
It supports notifications.

00:11:24.710 --> 00:11:28.070
So you effectively register
notifications on a bucket

00:11:28.070 --> 00:11:30.530
and you basically say,
whenever something

00:11:30.530 --> 00:11:33.230
changes within this
bucket to the data in it,

00:11:33.230 --> 00:11:35.915
data's added or updated,
I want you to fire off

00:11:35.915 --> 00:11:39.040
a request or a web hook, a URL
that we can then do something

00:11:39.040 --> 00:11:39.579
with.

00:11:39.579 --> 00:11:40.995
Might be an App
Engine application

00:11:40.995 --> 00:11:43.589
that handles this URL for us.

00:11:43.589 --> 00:11:45.380
In fact, if anybody
saw my Google I/O talk,

00:11:45.380 --> 00:11:47.930
that's exactly what we
did for my demonstration.

00:11:49.730 --> 00:11:53.570
It also, if you have 5 terabytes
for object potentially,

00:11:53.570 --> 00:11:55.935
you really do need resumable
uploads and downloads.

00:11:57.990 --> 00:12:02.280
It has a free 9s SLA through
things like high availability,

00:12:02.280 --> 00:12:05.400
georedundancy, the
full replication system

00:12:05.400 --> 00:12:08.370
that we've talked about already
with Datastore and cloud SQL.

00:12:08.370 --> 00:12:10.680
It also features strong
read after write consistency

00:12:10.680 --> 00:12:11.890
for objects.

00:12:11.890 --> 00:12:13.960
So basically, if
you add an object

00:12:13.960 --> 00:12:17.380
or change an object,
and that completes,

00:12:17.380 --> 00:12:18.955
anybody who then
subsequently reads

00:12:18.955 --> 00:12:21.275
that object will see
your changes, guaranteed.

00:12:21.275 --> 00:12:23.310
They'd read that
object specifically,

00:12:23.310 --> 00:12:24.370
always guaranteed.

00:12:24.370 --> 00:12:27.909
And that's pretty powerful
for this kind of object store.

00:12:27.909 --> 00:12:29.200
It's not the same for listings.

00:12:29.200 --> 00:12:30.870
If you do a list
on the bucket, that

00:12:30.870 --> 00:12:32.294
will be eventually consistent.

00:12:32.294 --> 00:12:34.710
So you may see different results
if you were just listing.

00:12:34.710 --> 00:12:36.930
But it's strongly consistent
for object updates.

00:12:38.060 --> 00:12:40.790
And as with all of our services,
data is encrypted at rest,

00:12:40.790 --> 00:12:42.290
and we give you all
of the tools you

00:12:42.290 --> 00:12:45.440
need to provide
access to your data.

00:12:45.440 --> 00:12:48.130
You can make data in cloud
storage publicly available.

00:12:48.130 --> 00:12:49.860
You can even deploy
entire websites

00:12:49.860 --> 00:12:51.770
on cloud storage
using static content.

00:12:54.090 --> 00:12:55.704
And I need to drink some water.

00:12:55.704 --> 00:12:57.370
I'll be drinking water
quite constantly.

00:13:00.130 --> 00:13:01.855
Oh, gone past that.

00:13:01.855 --> 00:13:03.430
So that solved
our first problem.

00:13:03.430 --> 00:13:06.060
We've chosen the Datastore
to store data from mobile.

00:13:07.560 --> 00:13:09.385
And how do we share walks?

00:13:10.390 --> 00:13:13.790
So for this, we need this
modular frontend and API,

00:13:13.790 --> 00:13:14.680
a comment missing.

00:13:14.680 --> 00:13:16.180
There's a comment
missing from this.

00:13:16.860 --> 00:13:18.790
Unfortunately,
forgot to update it.

00:13:18.790 --> 00:13:21.464
A modular autoscaling
frontend and API.

00:13:21.464 --> 00:13:23.755
And we also want it to be
easy to develop and maintain.

00:13:25.250 --> 00:13:26.350
So we chose App Engine.

00:13:26.350 --> 00:13:28.058
How many of you have
heard of App Engine?

00:13:29.899 --> 00:13:30.940
Yeah, quite a few of you.

00:13:32.140 --> 00:13:34.460
So App Engine, we love
App Engine at Google.

00:13:35.920 --> 00:13:37.160
Why do we love App Engine?

00:13:37.160 --> 00:13:39.050
Let's talk about App Engine.

00:13:39.050 --> 00:13:42.460
So App Engine effectively
allows you, as a developer,

00:13:42.460 --> 00:13:44.060
to focus on
developing your code,

00:13:44.060 --> 00:13:46.620
developing your application,
and not have to worry about all

00:13:46.620 --> 00:13:50.080
of your stuff like
this-- building software

00:13:50.080 --> 00:13:53.530
stacks, provisioning machines,
installing databases,

00:13:53.530 --> 00:13:56.160
installing software
stacks like LAMP stamps,

00:13:56.160 --> 00:13:57.168
that kind of thing.

00:13:59.410 --> 00:14:00.910
It supports managed
software stacks.

00:14:00.910 --> 00:14:03.615
And these are fully managed
software stacks for Python,

00:14:03.615 --> 00:14:06.520
for Java, for PHP, and
Go, with more on the way.

00:14:10.810 --> 00:14:13.845
With App Engine, one thing we
always talk about is Autoscale.

00:14:13.845 --> 00:14:15.394
App Engine's Autoscale
was legendary.

00:14:15.394 --> 00:14:16.810
I'd like to call
it best of breed,

00:14:16.810 --> 00:14:18.185
but probably the
marketing people

00:14:18.185 --> 00:14:19.650
would jump on me if I said that.

00:14:19.650 --> 00:14:22.180
But Autoscale is what App
Engine is really famous for.

00:14:22.180 --> 00:14:25.150
It can scale out very rapidly,
and scale down very quickly

00:14:25.150 --> 00:14:27.650
to make sure you always have
the resources you need when you

00:14:27.650 --> 00:14:29.524
need them, but you only
pay for what you use.

00:14:30.360 --> 00:14:32.410
It's also very easy
to develop, and that

00:14:32.410 --> 00:14:33.760
was one of the things
on our shopping list.

00:14:33.760 --> 00:14:35.135
We want it to be
easy to develop.

00:14:35.790 --> 00:14:37.830
It's free to get started.

00:14:37.830 --> 00:14:40.100
You don't have to enter
any credit card information

00:14:40.100 --> 00:14:41.820
at the moment to use App Engine.

00:14:41.820 --> 00:14:43.870
And you get some quota--
a reasonable amount

00:14:43.870 --> 00:14:46.486
of quota per day, and
it cycles every day

00:14:46.486 --> 00:14:48.235
that you can use to
run your applications.

00:14:48.235 --> 00:14:50.360
So if you have a small
application you want to run,

00:14:50.360 --> 00:14:52.300
you can run it on App
Engine free of charge.

00:14:53.164 --> 00:14:55.330
You also have the ability
to build and test locally.

00:14:55.330 --> 00:14:57.487
And we'll look at
that in more detail.

00:14:57.487 --> 00:14:59.320
And again, it comes
back to the whole point,

00:14:59.320 --> 00:15:01.528
you see, you can focus on
developing your application

00:15:01.528 --> 00:15:03.730
code, and not worry about
building software stacks.

00:15:04.860 --> 00:15:06.860
Trivial to manage, that
was another item one

00:15:06.860 --> 00:15:08.370
on our shopping list.

00:15:08.370 --> 00:15:12.290
It's fully managed, all of these
instances that run your code,

00:15:12.290 --> 00:15:13.659
or all these software stacks.

00:15:13.659 --> 00:15:15.700
We applied appaches, we
apply all of the updates.

00:15:16.820 --> 00:15:19.530
And they're maintained
24/7 by the guys

00:15:19.530 --> 00:15:23.040
that Julia mentioned earlier,
these SRAs, Site Reliability

00:15:23.040 --> 00:15:23.540
Engineers.

00:15:25.410 --> 00:15:27.560
So yet we don't need
to worry about that.

00:15:27.560 --> 00:15:31.360
And you can handle these things
is in demand for Autoscale.

00:15:31.360 --> 00:15:33.670
So the different
traffic patterns

00:15:33.670 --> 00:15:36.850
that we see on a regular basis,
things like spikes in traffic,

00:15:36.850 --> 00:15:39.940
which is the bottom
one here, computes

00:15:39.940 --> 00:15:44.790
the linear scalability,
the exponential scale,

00:15:44.790 --> 00:15:46.060
logarithmic scale.

00:15:46.060 --> 00:15:48.000
It can handle all
those kind of changes.

00:15:48.000 --> 00:15:50.208
And most importantly, even
if you have an application

00:15:50.208 --> 00:15:51.620
that has periods of inactivity.

00:15:51.620 --> 00:15:53.203
These could be on a
daily basis, maybe

00:15:53.203 --> 00:15:55.290
at night in the
location where you're

00:15:55.290 --> 00:15:58.350
running the application on a
weekly basis, a monthly basis,

00:15:58.350 --> 00:16:00.760
on a yearly basis, maybe
in summer holidays,

00:16:00.760 --> 00:16:02.600
then you won't be
consuming any resources.

00:16:02.600 --> 00:16:04.100
So you won't be
paying for anything,

00:16:04.100 --> 00:16:06.850
which is really important, and
a huge difference from when

00:16:06.850 --> 00:16:08.392
it comes to buying
in premise servers

00:16:08.392 --> 00:16:09.974
and putting them
next to your machine,

00:16:09.974 --> 00:16:11.370
next to your desk
in your garage,

00:16:11.370 --> 00:16:14.890
or buying space in a co-lo,
or something like that.

00:16:14.890 --> 00:16:16.937
So App Engine is
extremely flexible

00:16:16.937 --> 00:16:18.770
when it comes to handling
changes in demand.

00:16:19.980 --> 00:16:22.740
Local development environment
is also really important.

00:16:22.740 --> 00:16:27.250
This is the ability to really
build and test your application

00:16:27.250 --> 00:16:29.680
before you ultimately
deploy it to production.

00:16:29.680 --> 00:16:32.840
And we use the
Cloud SDK for this.

00:16:32.840 --> 00:16:34.800
Example code, there's
gcloud app run.

00:16:34.800 --> 00:16:36.800
You run this on your
laptop or on your desktop.

00:16:36.800 --> 00:16:38.300
It will run the
application locally.

00:16:38.300 --> 00:16:40.984
It effectively runs
App Engine locally,

00:16:40.984 --> 00:16:43.400
including the Cloud Datastore,
which we looked at earlier.

00:16:43.400 --> 00:16:45.000
So it has its own data store.

00:16:45.000 --> 00:16:48.250
When you shut the environment
down, start it again,

00:16:48.250 --> 00:16:50.250
it had the same data
stored in the Datastore.

00:16:50.250 --> 00:16:53.860
So you can test, iteratively,
your entire application.

00:16:53.860 --> 00:16:55.485
And once you're done,
you can deploy it

00:16:55.485 --> 00:16:57.220
to production using
the same command.

00:16:57.220 --> 00:17:00.640
In this case, it would
just be gcloud app deploy,

00:17:00.640 --> 00:17:02.600
with a dot, which is
the current directory.

00:17:04.030 --> 00:17:07.589
And there's some example
output as well from the console

00:17:07.589 --> 00:17:09.420
showing us the Dev
app server, which

00:17:09.420 --> 00:17:10.922
is what we call it internally.

00:17:10.922 --> 00:17:11.630
It's not running.

00:17:14.292 --> 00:17:15.875
App Engine architecture,
I'm not going

00:17:15.875 --> 00:17:17.445
to spend too much time on this.

00:17:17.445 --> 00:17:20.266
But it's important to realize
we have a pending queue.

00:17:20.266 --> 00:17:21.849
And we have instances
that are spun up

00:17:21.849 --> 00:17:24.302
to handle requests coming
into that pending queue.

00:17:24.302 --> 00:17:26.510
And we have a scheduler that
will monitor the pending

00:17:26.510 --> 00:17:28.940
requests and spin up
new instances on demand,

00:17:28.940 --> 00:17:31.239
or remove instances
when there is no demand.

00:17:31.239 --> 00:17:33.530
And we have other services
like Task Queue, which we'll

00:17:33.530 --> 00:17:36.650
look at shortly, and the
Datastore, which I mentioned,

00:17:36.650 --> 00:17:38.608
and memcache, which we'll
also look at shortly.

00:17:38.662 --> 00:17:40.120
We have another
interactive version

00:17:40.120 --> 00:17:42.020
with this diagram
coming up soon as well.

00:17:44.520 --> 00:17:46.310
So we did talk
about this earlier,

00:17:46.310 --> 00:17:49.220
the touch on the idea of modular
development for applications.

00:17:49.220 --> 00:17:51.760
And this is also really,
really important as well.

00:17:51.760 --> 00:17:53.680
This allows us to
effectively take

00:17:53.680 --> 00:17:56.640
a large application, a large
monolithic application,

00:17:56.640 --> 00:18:00.050
and allow us to factor it out
into small logical components

00:18:00.050 --> 00:18:01.650
called modules.

00:18:01.650 --> 00:18:04.080
And modules are a top
level of App Engine.

00:18:05.460 --> 00:18:07.475
They can be in any language.

00:18:10.369 --> 00:18:11.910
WalkShare, for
example, was developed

00:18:11.910 --> 00:18:13.610
in Python, Go, and Java.

00:18:13.610 --> 00:18:15.970
You add free modules, the
free modules you saw earlier,

00:18:15.970 --> 00:18:18.200
and they were written in
three different languages.

00:18:18.200 --> 00:18:20.754
So if you have guys who are
specialists in Go developing

00:18:20.754 --> 00:18:23.045
backend code, they can be
developing the Go application

00:18:23.045 --> 00:18:24.229
as a module.

00:18:24.229 --> 00:18:26.270
And other people can be
doing the front end stuff

00:18:26.270 --> 00:18:27.770
in Java or Python.

00:18:27.770 --> 00:18:30.175
And all of that stuff can be
merged into one application.

00:18:31.480 --> 00:18:32.980
Modules have versions.

00:18:32.980 --> 00:18:35.590
So we can deploy
versions of the module.

00:18:35.590 --> 00:18:38.810
Different versions-- versions
1, version 3, the test version.

00:18:38.810 --> 00:18:41.880
And we can switch between those
modules, as we'll see shortly.

00:18:43.120 --> 00:18:46.530
Modules also can be
backed by Compute Engine

00:18:46.530 --> 00:18:47.400
virtual machines.

00:18:47.400 --> 00:18:50.695
And I think Julia spent a
lot of time on Compute Engine

00:18:50.695 --> 00:18:52.590
earlier, so you
know what they are.

00:18:52.590 --> 00:18:54.450
We'll talk about
them more shortly.

00:18:54.450 --> 00:18:57.850
But basically, the module
will be an App Engine module.

00:18:57.850 --> 00:19:02.150
But instead of being backed by
these traditional App Engine

00:19:02.150 --> 00:19:05.240
instances, they will be
backed by Compute Engine

00:19:05.240 --> 00:19:05.960
virtual machines.

00:19:07.020 --> 00:19:11.700
Modules can share state
across the entire application.

00:19:11.700 --> 00:19:13.570
So each module has
access to state

00:19:13.570 --> 00:19:15.285
stored in Memcache
and Datastore.

00:19:16.660 --> 00:19:19.420
They have their own performance
settings, their own versions.

00:19:19.420 --> 00:19:22.800
They can be deployed and updated
independently of each other.

00:19:26.530 --> 00:19:29.380
So we need an API.

00:19:29.380 --> 00:19:31.214
And that's the whole
point of this one.

00:19:31.214 --> 00:19:32.880
In order to share
walks, we need an API.

00:19:35.230 --> 00:19:38.030
Without the API, the application
would be stuck on the phone.

00:19:38.030 --> 00:19:39.630
We couldn't actually
share that data

00:19:39.630 --> 00:19:42.510
with the other front end,
the web user interface.

00:19:43.580 --> 00:19:44.980
So we need to build an API.

00:19:44.980 --> 00:19:49.400
So in this case, we chose to
build an API from scratch.

00:19:49.400 --> 00:19:50.880
And it looks
something like this.

00:19:50.880 --> 00:19:55.050
So this is a standard kind
of restful example of an API.

00:19:55.050 --> 00:19:57.420
This is one call, obviously.

00:19:57.420 --> 00:19:59.220
This is so comments--
and effectively,

00:19:59.220 --> 00:20:03.590
for this user, called userbob,
we want to see walk 1.

00:20:03.590 --> 00:20:07.800
And basically, our API will
suck in JSON, and return JSON.

00:20:07.800 --> 00:20:09.482
Everybody know what JSON is?

00:20:09.482 --> 00:20:10.490
I guess you probably do.

00:20:11.930 --> 00:20:14.800
So here's an example of the
output from that request we

00:20:14.800 --> 00:20:17.175
call gets on that URL,
which is a restful URL

00:20:17.175 --> 00:20:20.355
And it returns back a JSON
object representing that data.

00:20:21.440 --> 00:20:22.975
And I think we can
show a demo now.

00:20:22.975 --> 00:20:25.440
Can we switch back
to the laptop?

00:20:31.291 --> 00:20:31.790
OK.

00:20:33.880 --> 00:20:37.030
Just want to refresh this.

00:20:41.340 --> 00:20:41.940
I'm in Chrome.

00:20:41.940 --> 00:20:45.327
I'm in the Chrome
developer's console,

00:20:45.327 --> 00:20:47.285
and what I'm interested
in is looking for calls

00:20:47.285 --> 00:20:49.850
to the comment API.

00:20:49.850 --> 00:20:53.100
I was going to refresh that and
let it load the whole thing.

00:20:53.100 --> 00:20:54.560
But because we're
using the filter,

00:20:54.560 --> 00:20:57.600
we can see-- our call to
comment/userbob/walk1.

00:21:01.030 --> 00:21:02.155
That's what it looked like.

00:21:04.030 --> 00:21:07.340
And response was JSON back.

00:21:07.340 --> 00:21:09.420
So again, we could be
actually updating a comment

00:21:09.420 --> 00:21:10.128
or adding a walk.

00:21:10.128 --> 00:21:13.880
And in that case, it would be
post request with a post body.

00:21:13.880 --> 00:21:15.290
We could be updating
a walk using

00:21:15.290 --> 00:21:17.040
put requests, those
kind of things.

00:21:17.040 --> 00:21:18.890
So it's a very simple API.

00:21:18.890 --> 00:21:20.920
We can also do tricky
things like this as well.

00:21:24.245 --> 00:21:25.730
I'll get rid of this.

00:21:25.730 --> 00:21:26.880
Oh, help.

00:21:28.959 --> 00:21:29.750
What happened then?

00:21:31.641 --> 00:21:33.932
Yeah, I don't want to report
inappropriate street view.

00:21:35.620 --> 00:21:38.310
This is the Googleplex,
nothing inappropriate about it.

00:21:40.100 --> 00:21:44.749
So we have an
interface that allows

00:21:44.749 --> 00:21:46.790
us to show you the output
from the restful cause.

00:21:46.790 --> 00:21:49.700
So this case, we made a call
to comment userbob, walk1,

00:21:49.700 --> 00:21:51.690
which we saw an example.

00:21:51.690 --> 00:21:54.420
And we can also look at
the actual route as well.

00:21:56.340 --> 00:22:00.520
And as the GPS coordinates
for all steps in that walk.

00:22:00.520 --> 00:22:03.080
So these are the GPS
traces that were sent back.

00:22:03.080 --> 00:22:06.430
So this is just a useful way
of querying the API for us.

00:22:08.351 --> 00:22:08.850
OK.

00:22:08.850 --> 00:22:10.225
So you can go back
to the slides?

00:22:14.010 --> 00:22:16.460
So building your own API.

00:22:16.460 --> 00:22:18.850
And I'll talk about why we
built our own API shortly.

00:22:18.850 --> 00:22:21.560
But you don't have to
build your own API.

00:22:21.560 --> 00:22:24.219
I think Jerome already
mentioned it, Cloud Endpoints.

00:22:24.219 --> 00:22:26.260
We have this thing called
Google Cloud Endpoints.

00:22:26.260 --> 00:22:30.260
Allows you to simplify the whole
process of building an API,

00:22:30.260 --> 00:22:33.920
and exposing it to clients,
clients such as mobile devices,

00:22:33.920 --> 00:22:37.690
to gaming applications,
to web applications.

00:22:38.700 --> 00:22:41.780
And basically, the
whole idea is-- well,

00:22:41.780 --> 00:22:43.570
there's two approaches
to doing this.

00:22:43.570 --> 00:22:46.194
That's kind of free, but the two
we're going to talk about are.

00:22:46.194 --> 00:22:49.214
You can take your existing
client interface application

00:22:49.214 --> 00:22:51.005
code which may be part
of a web application

00:22:51.005 --> 00:22:52.450
that you have already.

00:22:52.450 --> 00:22:55.005
And you can decorate
it, add decorators to it

00:22:55.005 --> 00:22:56.130
in the form of annotations.

00:22:56.130 --> 00:22:57.790
And we have an
example coming up.

00:22:58.910 --> 00:23:02.500
And that will effectively
instruct App Engine

00:23:02.500 --> 00:23:05.040
and the underlying cloud
endpoint's run time.

00:23:05.040 --> 00:23:07.402
Do you want to
expose this method?

00:23:07.402 --> 00:23:08.860
And again, I'll
look at the example

00:23:08.860 --> 00:23:11.285
shortly, as an API call?

00:23:11.285 --> 00:23:12.300
It's very, very simple.

00:23:13.570 --> 00:23:16.550
Alternatively, you can
take a model class,

00:23:16.550 --> 00:23:17.870
like a comment or a walk.

00:23:17.870 --> 00:23:19.500
You've already defined a model.

00:23:19.500 --> 00:23:21.610
And it doesn't
have an API for it.

00:23:21.610 --> 00:23:23.830
But using tooling--
it's available in things

00:23:23.830 --> 00:23:26.210
like Android Studio, or Eclipse.

00:23:26.210 --> 00:23:29.399
You can basically generate an
endpoint class from that model.

00:23:29.399 --> 00:23:31.190
So all you have to do
is right click on it,

00:23:31.190 --> 00:23:33.620
say generate endpoint
class, and it

00:23:33.620 --> 00:23:35.550
will generate the class for you.

00:23:35.550 --> 00:23:37.930
And this will allow
you to perform

00:23:37.930 --> 00:23:41.170
all of the standard type
restful calls on that resource.

00:23:41.170 --> 00:23:42.480
So I think of it as a resource.

00:23:42.480 --> 00:23:44.420
[INAUDIBLE] a comment or a walk.

00:23:44.420 --> 00:23:46.440
You can do lists,
you can do gets.

00:23:46.440 --> 00:23:47.705
You can do puts.

00:23:48.820 --> 00:23:51.390
All of the kind of things you
would do with a restful API.

00:23:51.390 --> 00:23:53.430
And this is all generated
automatically for you.

00:23:53.430 --> 00:23:55.096
You don't have to
write any code at all.

00:23:55.596 --> 00:23:58.240
The APIs that App Engine
creates are effectively

00:23:58.240 --> 00:24:01.095
implemented on top of the
exact same infrastructure

00:24:01.095 --> 00:24:02.810
that we use for our own APIs.

00:24:02.810 --> 00:24:05.190
So for maps, and for YouTube.

00:24:05.190 --> 00:24:06.442
Completely discoverable.

00:24:06.442 --> 00:24:08.400
And obviously, you get
all of the kind of scale

00:24:08.400 --> 00:24:10.220
that we have for our own APIs.

00:24:11.630 --> 00:24:15.250
We also provide tours
that are required

00:24:15.250 --> 00:24:19.830
for generating effectively
mobile optimized client

00:24:19.830 --> 00:24:21.010
libraries.

00:24:21.010 --> 00:24:22.664
So effectively, we
have an API here.

00:24:22.664 --> 00:24:24.080
We want to be able
to consume that

00:24:24.080 --> 00:24:28.720
from an application running on
a device, or running a web app.

00:24:28.720 --> 00:24:31.250
What we need is
a client library,

00:24:31.250 --> 00:24:35.010
something that understands
how to envoke that API.

00:24:35.010 --> 00:24:38.200
And we can generate that
straight from the application

00:24:38.200 --> 00:24:40.750
code, straight from the end
points that we generated.

00:24:40.750 --> 00:24:44.006
And we have tools for
Android, iOS, and web,

00:24:44.006 --> 00:24:45.380
and these are
available in things

00:24:45.380 --> 00:24:47.620
like Android studio
and Eclipse, also

00:24:47.620 --> 00:24:51.981
for Objective-C on a command
line, and also for JavaScript

00:24:51.981 --> 00:24:52.480
as well.

00:24:53.903 --> 00:24:56.277
Because this is going through
Google and the Google front

00:24:56.277 --> 00:25:01.930
end, we have full out of the box
denial of service protection.

00:25:01.930 --> 00:25:04.644
It supports OAuth2 as
well, authentication,

00:25:04.644 --> 00:25:06.310
and also supports
client key management.

00:25:07.370 --> 00:25:09.770
As an example, I kind of
hacked this together earlier,

00:25:09.770 --> 00:25:11.270
because my example
wasn't WalkShare.

00:25:12.280 --> 00:25:14.880
So this is basically
a WalkShare method,

00:25:14.880 --> 00:25:18.950
say, get comments that would
return a list of comments.

00:25:18.950 --> 00:25:21.660
And what we've done
is we've annotated it.

00:25:21.660 --> 00:25:23.620
We've annotated the
class initially.

00:25:23.620 --> 00:25:25.660
We're at API.

00:25:26.670 --> 00:25:28.660
Name equals comment
is effectively saying,

00:25:28.660 --> 00:25:30.462
we want this API to
be called comment.

00:25:30.462 --> 00:25:31.670
We want the version to be v1.

00:25:32.730 --> 00:25:34.710
And then we've
annotated the method,

00:25:34.710 --> 00:25:37.460
a bit of indentation
problems there.

00:25:37.460 --> 00:25:40.880
And we've said, we want
this to be a get request.

00:25:40.880 --> 00:25:43.490
That could be inferred by
the system from the fact

00:25:43.490 --> 00:25:44.957
that this is a get request.

00:25:44.957 --> 00:25:46.790
So we don't have to
actually put this there.

00:25:46.790 --> 00:25:49.800
But we did anyway just to
show it and highlight it.

00:25:49.800 --> 00:25:52.030
And also, the path
for this method,

00:25:52.030 --> 00:25:54.420
what it will be when we
make a REST call to it.

00:25:55.580 --> 00:25:58.570
Then we can also annotate the
parameters of the method call.

00:25:58.570 --> 00:26:01.030
In this case, walk
ID and user ID.

00:26:01.030 --> 00:26:03.200
And then the body of the
code, effective just some

00:26:03.200 --> 00:26:04.890
kind of query on
a comment system,

00:26:04.890 --> 00:26:07.370
and returns back
matching results.

00:26:07.370 --> 00:26:10.350
And in the comments there at
the bottom of the first box

00:26:10.350 --> 00:26:13.350
is what the REST call like,
slash comment slash v1 userid,

00:26:13.350 --> 00:26:13.850
walkid.

00:26:15.310 --> 00:26:18.100
And then after we've generated
a client library for this,

00:26:18.100 --> 00:26:20.120
we could then consume
that from Android.

00:26:20.120 --> 00:26:23.390
Basically we have to get
a version of the endpoint.

00:26:23.390 --> 00:26:25.520
And here, we say
service.comment endpoint.

00:26:25.520 --> 00:26:28.920
This is available from
the client library call

00:26:28.920 --> 00:26:31.980
get comments, passing the userid
and the walkid, which we've

00:26:31.980 --> 00:26:34.180
gathered from the user
interface, and call execute.

00:26:34.180 --> 00:26:35.929
And that will get the
results back for us.

00:26:38.509 --> 00:26:40.300
So why didn't we just
start with endpoints?

00:26:40.300 --> 00:26:42.860
Well, we talked about
managed virtual machines

00:26:42.860 --> 00:26:45.030
a couple of times
already in the keynote,

00:26:45.030 --> 00:26:48.160
and also in Julia's talk.

00:26:48.160 --> 00:26:50.750
And when we started
developing this application,

00:26:50.750 --> 00:26:52.130
we wanted to use managed VMs.

00:26:52.130 --> 00:26:54.510
But they didn't have
all of the plumbing

00:26:54.510 --> 00:26:57.140
because it was still
early in their life cycle.

00:26:57.140 --> 00:26:58.850
And they're not
fully released yet,

00:26:58.850 --> 00:27:00.690
they're still in
limited preview.

00:27:00.690 --> 00:27:01.780
They didn't have all
of the plumbing that

00:27:01.780 --> 00:27:03.910
was required to actually
support Cloud Endpoints.

00:27:03.910 --> 00:27:05.250
So we couldn't use them.

00:27:05.250 --> 00:27:10.460
So we had to actually build
the API from scratch by hand.

00:27:11.680 --> 00:27:13.040
Sorry, it's been a long day.

00:27:16.768 --> 00:27:18.840
What about other situations?

00:27:18.840 --> 00:27:22.310
So we didn't use Memcache
for this application,

00:27:22.310 --> 00:27:23.280
but we could do.

00:27:23.280 --> 00:27:25.670
A Memcache is extremely
important for most people.

00:27:25.670 --> 00:27:28.310
It saves having to do
those expensive wreaths

00:27:28.310 --> 00:27:31.385
from the backing store,
be it the Cloud Datastore,

00:27:31.385 --> 00:27:32.660
or be it Cloud SQL.

00:27:32.660 --> 00:27:34.867
You don't want to go back
and get the same data

00:27:34.867 --> 00:27:36.700
all of the time once
you've already have it.

00:27:36.700 --> 00:27:38.270
So you store it in Memcache.

00:27:38.270 --> 00:27:41.040
And here we have an example
of three applications,

00:27:41.040 --> 00:27:42.950
all accessing a shared Memcache.

00:27:42.950 --> 00:27:45.740
This is a Memcache that's shared
across all applications run

00:27:45.740 --> 00:27:46.721
in the region.

00:27:46.721 --> 00:27:49.220
So we have a shared Memcache
for applications one in the US,

00:27:49.220 --> 00:27:52.220
the shared memache for
applications running in the EU,

00:27:52.220 --> 00:27:53.360
in Europe.

00:27:53.360 --> 00:27:57.350
And it's a large shared
cache, and we make it bigger,

00:27:57.350 --> 00:27:58.770
the more applications we have.

00:27:58.770 --> 00:28:01.040
But it's still the possibility
that your data maybe

00:28:01.040 --> 00:28:03.100
be evicted by
somebody else's data.

00:28:03.100 --> 00:28:07.140
So there's no predictability or
deterministic nature about it.

00:28:08.480 --> 00:28:11.680
We also have an option called
dedicated Memcache, which

00:28:11.680 --> 00:28:16.210
allows you to reserve
specific size of Memcache

00:28:16.210 --> 00:28:18.170
for your application
specifically.

00:28:18.170 --> 00:28:21.170
So it's reserved
by per gigabyte,

00:28:21.170 --> 00:28:23.110
and you pay per gigabyte.

00:28:23.110 --> 00:28:24.810
So this would
effectively allow you

00:28:24.810 --> 00:28:27.795
to control the way data
is evicted from Memcache.

00:28:29.852 --> 00:28:32.310
Task Queues-- how many people
have heard of App Engine Task

00:28:32.310 --> 00:28:32.390
Queues?

00:28:32.390 --> 00:28:33.681
Because most people loved them.

00:28:33.681 --> 00:28:34.830
So somebody here?

00:28:34.830 --> 00:28:35.550
Yep?

00:28:35.550 --> 00:28:36.395
So these are really popular.

00:28:36.395 --> 00:28:37.630
Now, people love Task Queues.

00:28:37.630 --> 00:28:40.010
Whenever anybody gets involved
in App Engine development,

00:28:40.010 --> 00:28:41.936
they love using Task Queues.

00:28:41.936 --> 00:28:43.310
What it effectively
does is allow

00:28:43.310 --> 00:28:45.160
us to make incoming
requests from users.

00:28:46.460 --> 00:28:48.190
And then because
we had to respond

00:28:48.190 --> 00:28:49.970
to the user at a
reasonably quick time,

00:28:49.970 --> 00:28:51.580
we don't wait 60 seconds.

00:28:51.580 --> 00:28:53.480
There was a deadline
on respondencies

00:28:53.480 --> 00:28:55.660
as of 60 seconds in App Engine.

00:28:55.660 --> 00:28:57.460
We don't want to wait
that length of time.

00:28:57.460 --> 00:28:59.570
We may need to do stuff
in the background.

00:28:59.570 --> 00:29:03.430
So what we can do is while
we're processing the request,

00:29:03.430 --> 00:29:06.220
we'll generate a task
to say, do this stuff.

00:29:06.220 --> 00:29:07.442
Put it onto a Task Queue.

00:29:07.442 --> 00:29:09.775
And then we can go back to
the user and say, we're done.

00:29:09.775 --> 00:29:13.312
So this could be generating
email, processing a tax return

00:29:13.312 --> 00:29:14.520
form, or something like that.

00:29:14.520 --> 00:29:15.436
Something complicated.

00:29:16.790 --> 00:29:22.920
And the Task Queue, effectively,
has tasks which are web hooks.

00:29:22.920 --> 00:29:28.010
And they're handle by
other App Engine instances,

00:29:28.010 --> 00:29:30.990
instances specifically written
to handle those requests.

00:29:30.990 --> 00:29:33.250
And these can run for
longer than 60 seconds.

00:29:33.250 --> 00:29:35.080
They can run
continuously, or they

00:29:35.080 --> 00:29:37.520
can run for a longer
period of time,

00:29:37.520 --> 00:29:40.630
but not necessarily 60 seconds.

00:29:40.630 --> 00:29:43.590
And what they can do is process
all of these jobs outside

00:29:43.590 --> 00:29:45.930
of the user request
in the background.

00:29:45.930 --> 00:29:49.060
They can access all of the
services, other instances

00:29:49.060 --> 00:29:52.550
an App Engine can run,
things like Cloud Datastore,

00:29:52.550 --> 00:29:54.380
Google Cloud Storage, email.

00:29:54.380 --> 00:29:58.460
We have a mail API, and other
external APIs, APIs external

00:29:58.460 --> 00:29:59.510
to Google.

00:29:59.510 --> 00:30:01.390
So this is a really
effective way

00:30:01.390 --> 00:30:05.580
of actually managing background
processing on App Engine.

00:30:05.580 --> 00:30:07.210
But it also allows
us surplus workout

00:30:07.210 --> 00:30:09.610
to things like Compute
Engine or to anything else.

00:30:09.610 --> 00:30:13.225
We can have Compute Engine
reading tasks from these cues,

00:30:13.225 --> 00:30:16.246
and slightly
different type of cue,

00:30:16.246 --> 00:30:21.150
and process that data offline,
outside the user request,

00:30:21.150 --> 00:30:22.490
but also outside of App Engine.

00:30:25.185 --> 00:30:27.060
You could also build
the whole thing yourself

00:30:27.060 --> 00:30:27.810
on Compute Engine.

00:30:27.810 --> 00:30:29.330
But why would you
want to do that?

00:30:29.330 --> 00:30:31.204
We'll talk about Compute
Engine more shortly.

00:30:32.740 --> 00:30:35.400
So that's covered the
next two bullet points.

00:30:36.730 --> 00:30:39.360
Let's go onto the next
one, which is comment SPAM.

00:30:39.360 --> 00:30:42.500
So I've never really
built a web form recently,

00:30:42.500 --> 00:30:44.590
but I know what the
horror stories are.

00:30:44.590 --> 00:30:46.390
As soon as you create
a formal on the web

00:30:46.390 --> 00:30:48.790
and you put it
onto your website,

00:30:48.790 --> 00:30:50.920
there are spam bots out
there that will say, ha!

00:30:50.920 --> 00:30:51.764
A form!

00:30:51.764 --> 00:30:53.722
And they would go in it,
and they would fill it

00:30:53.722 --> 00:30:55.040
in to their heart's content.

00:30:55.040 --> 00:30:59.530
And you will have spam, lots and
lots of spam in your comments.

00:30:59.530 --> 00:31:03.700
So generally, people
protect their comments,

00:31:03.700 --> 00:31:07.810
their commenting system either
via requiring to use a login

00:31:07.810 --> 00:31:09.190
or using captures.

00:31:10.690 --> 00:31:12.620
So we need a robust
commenting system.

00:31:13.699 --> 00:31:14.490
So we use captures.

00:31:15.616 --> 00:31:16.535
Who likes captures?

00:31:19.710 --> 00:31:21.232
You like captures?

00:31:21.232 --> 00:31:22.520
Right, nobody likes captures.

00:31:22.520 --> 00:31:24.890
But they are effective,
particularly when

00:31:24.890 --> 00:31:26.320
your user has not logged in.

00:31:26.320 --> 00:31:29.202
But captures actually require
you do some image processing.

00:31:29.202 --> 00:31:30.660
And as Julia has
already mentioned,

00:31:30.660 --> 00:31:33.070
image processing on App Engine
is a little bit difficult.

00:31:33.070 --> 00:31:35.070
We don't have the libraries
in place [INAUDIBLE]

00:31:35.070 --> 00:31:35.830
to make it work.

00:31:35.830 --> 00:31:39.480
And for our Java component of
our application, a Java module,

00:31:39.480 --> 00:31:42.530
we didn't have the java.awt
library-- java.awt!

00:31:44.641 --> 00:31:46.640
My colleague added this
slide, and I hadn't even

00:31:46.640 --> 00:31:49.730
really given thought to
java.awt for a long, long time.

00:31:49.730 --> 00:31:51.080
[INAUDIBLE] back in my past.

00:31:51.080 --> 00:31:56.720
But you can use java.awt to
process images, image data.

00:31:56.720 --> 00:31:58.760
So App Engine doesn't
have this library.

00:31:58.760 --> 00:31:59.674
It's been removed.

00:31:59.674 --> 00:32:01.590
It's a big overhead,
it's a big chunk of stuff

00:32:01.590 --> 00:32:02.890
that we don't need.

00:32:02.890 --> 00:32:04.870
So what are we going to do?

00:32:04.870 --> 00:32:06.320
We'll use managed VMs.

00:32:06.320 --> 00:32:09.562
So we talked about managed
VMs already quite extensively.

00:32:09.562 --> 00:32:10.270
Laptops gone off.

00:32:11.217 --> 00:32:13.050
And I'm not going to
go into anymore detail.

00:32:13.050 --> 00:32:14.425
But basically, we
can use managed

00:32:14.425 --> 00:32:16.780
VMs to effectively break
the glass, as Julia said.

00:32:16.780 --> 00:32:19.572
We can break the glass and say,
this won't run on App Engine.

00:32:19.572 --> 00:32:21.280
We can run this on
Compute Engine, that's

00:32:21.280 --> 00:32:24.480
fine-- modular application
design, no problem at all.

00:32:24.480 --> 00:32:26.750
We can just have to
managed virtual machines

00:32:26.750 --> 00:32:29.380
running that aspect
of our application.

00:32:29.380 --> 00:32:32.160
And the capture system
looks something like that.

00:32:32.160 --> 00:32:34.160
Let me show you what it
looks like in real life.

00:32:36.100 --> 00:32:38.300
Can you go to the
laptop, please?

00:32:43.070 --> 00:32:43.640
OK.

00:32:43.640 --> 00:32:53.425
So going back, I actually have
a better walk we can work with.

00:32:54.880 --> 00:32:56.200
I kind of recognize that place.

00:32:57.566 --> 00:32:58.940
I love Times
Square, I really do.

00:32:58.940 --> 00:33:01.000
I don't know why I love
Times Square, but I do.

00:33:01.000 --> 00:33:04.670
And we're going to tragically
run out of time, aren't we?

00:33:04.670 --> 00:33:07.299
So in a moment,
with comments, we

00:33:07.299 --> 00:33:08.590
don't have any captures, right?

00:33:08.590 --> 00:33:10.000
We've already looked at this.

00:33:10.000 --> 00:33:11.980
So we click on this.

00:33:11.980 --> 00:33:24.420
I can just type
in-- so anybody can

00:33:24.420 --> 00:33:25.720
come along and make comments.

00:33:25.720 --> 00:33:28.800
They can put URLs in
there to send me to places

00:33:28.800 --> 00:33:30.552
where I really don't want to go.

00:33:30.552 --> 00:33:31.510
So I want to stop this.

00:33:31.510 --> 00:33:32.770
So how do I do it?

00:33:32.770 --> 00:33:36.720
So fortunately, and also
covering this issue here

00:33:36.720 --> 00:33:41.790
with the two smiley
faces, the tech-op guys

00:33:41.790 --> 00:33:44.459
have just called me on
my secret earpiece here

00:33:44.459 --> 00:33:46.000
to tell me that
they've just deployed

00:33:46.000 --> 00:33:47.522
version 2 of the application.

00:33:47.522 --> 00:33:49.730
And we can actually just
switch over to that version,

00:33:49.730 --> 00:33:51.188
and it will fix
our problem source,

00:33:51.188 --> 00:33:53.790
add captures, and also
fix that problem there.

00:33:53.790 --> 00:34:00.040
So what I need to do is find my
WalkShare stating application,

00:34:00.040 --> 00:34:00.730
go to Versions.

00:34:05.350 --> 00:34:10.710
And after a little while,
nobody demos on Wi-Fi.

00:34:10.710 --> 00:34:13.414
Really-- seriously,
never do demos on Wi-Fi.

00:34:13.414 --> 00:34:16.030
So at the moment, we can
see for our default module--

00:34:16.030 --> 00:34:18.844
and again, we have a
notion of a default module.

00:34:18.844 --> 00:34:20.510
We could've given
this a name, but we're

00:34:20.510 --> 00:34:21.593
using this as the default.

00:34:21.593 --> 00:34:24.260
This is the one that
handles our comment stuff.

00:34:24.260 --> 00:34:27.429
And at the moment, the
version for that is version 1.

00:34:28.500 --> 00:34:30.000
I can also look at
the comments one,

00:34:30.000 --> 00:34:31.500
and that is also
going to be version

00:34:31.500 --> 00:34:33.449
1-- think that's about it.

00:34:46.389 --> 00:34:47.830
It's the Wi-Fi.

00:34:47.830 --> 00:34:49.716
[INAUDIBLE] where are you?

00:34:49.716 --> 00:34:50.730
If you see somewhere.

00:34:51.830 --> 00:34:53.699
So we could see version
1 there as well.

00:34:53.699 --> 00:34:55.949
And the tech-ops guys have
said version 2 has actually

00:34:55.949 --> 00:34:58.700
got support for captures,
and it fixes our problem.

00:34:58.700 --> 00:35:01.300
So I'm going to make
version 2 of the comments

00:35:01.300 --> 00:35:02.105
module the default.

00:35:05.314 --> 00:35:07.650
I was thinking about
it, that's done.

00:35:08.165 --> 00:35:10.040
I'm also going to do
that for the default one

00:35:10.040 --> 00:35:11.081
to fix the other problem.

00:35:14.610 --> 00:35:15.370
Change that.

00:35:16.960 --> 00:35:17.900
Make default.

00:35:17.900 --> 00:35:19.840
And the user interface
has a problem here,

00:35:19.840 --> 00:35:22.980
because I even saw my colleague,
Brian, do this as well.

00:35:22.980 --> 00:35:26.150
Your first instinct is to
go to the Delete button,

00:35:26.150 --> 00:35:27.720
and I don't know why.

00:35:27.720 --> 00:35:30.200
But there's something about
the user interface and the way

00:35:30.200 --> 00:35:33.250
it's designed that attracts
you immediately to delete,

00:35:33.250 --> 00:35:35.171
and so we need to fix that.

00:35:35.171 --> 00:35:36.920
So now, we can go back
to our application.

00:35:38.680 --> 00:35:42.252
We want to refresh
that, because we

00:35:42.252 --> 00:35:44.210
want to see the new
version of the application.

00:35:44.210 --> 00:35:45.870
So let's go onto comments now.

00:35:47.047 --> 00:35:47.880
We'll add a comment.

00:35:49.272 --> 00:35:50.640
Ah, OK.

00:35:50.640 --> 00:35:55.310
So my name is Mandy, and
this is a test comment.

00:35:55.310 --> 00:35:57.039
Aw, can't you think
of anything better

00:35:57.039 --> 00:35:58.080
to say than test comment?

00:35:59.115 --> 00:35:59.615
And Android.

00:36:02.020 --> 00:36:03.440
Then I can post my comment.

00:36:05.520 --> 00:36:09.156
And if I don't
answer it correctly,

00:36:09.156 --> 00:36:13.895
I do foobar, more foo.

00:36:17.440 --> 00:36:18.320
It won't let me post.

00:36:19.420 --> 00:36:21.230
OK, so now we've protected it.

00:36:21.230 --> 00:36:24.400
We can also check as well to
see if we've fixed our issue.

00:36:41.332 --> 00:36:42.660
And post a comment.

00:36:42.660 --> 00:36:48.030
Oh, I didn't do--
very interactive.

00:36:57.120 --> 00:36:58.162
I really can't type.

00:37:03.470 --> 00:37:05.970
Obviously, the implementation
would have a different capture

00:37:05.970 --> 00:37:08.590
every time, [INAUDIBLE]
might be quite easy to learn.

00:37:11.370 --> 00:37:12.120
So now you see it.

00:37:12.120 --> 00:37:12.744
We've fixed it.

00:37:12.744 --> 00:37:14.660
We now have captures,
and we've also

00:37:14.660 --> 00:37:17.956
fixed the bug with
the smiley face.

00:37:17.956 --> 00:37:19.330
And in the actual
WalkShare demos

00:37:19.330 --> 00:37:21.350
that we did during
Google I/I, we actually

00:37:21.350 --> 00:37:24.530
showed them going live into
the code, and fixing that bug,

00:37:24.530 --> 00:37:28.022
and updating it while they're
in production, which is great.

00:37:28.022 --> 00:37:28.980
That was really clever.

00:37:28.980 --> 00:37:31.188
That's not really available
yet, but it will be soon.

00:37:32.000 --> 00:37:33.860
So can you go back to
the slides, please?

00:37:36.820 --> 00:37:37.320
All right.

00:37:37.320 --> 00:37:38.630
So we're getting there.

00:37:40.230 --> 00:37:42.490
We have a robust
commenting system.

00:37:42.490 --> 00:37:46.650
Now what we need is a database
for our comments leaderboard,

00:37:46.650 --> 00:37:50.404
a database, effectively, for
temporary and summary data.

00:37:50.404 --> 00:37:52.820
Now, we've already talked about
this problem that we have.

00:37:52.820 --> 00:37:54.530
We have data that's
like [INAUDIBLE].

00:37:54.530 --> 00:37:58.480
It's stored in tables, it's
stored as rows in databases.

00:37:58.480 --> 00:38:00.740
When we want to do things
across an entire data set,

00:38:00.740 --> 00:38:03.025
would count as specifically,
becomes a bigger problem,

00:38:03.025 --> 00:38:05.730
a much more difficult problem.

00:38:05.730 --> 00:38:08.380
And the Datastore's
not ideally suited

00:38:08.380 --> 00:38:10.030
for doing those operations.

00:38:10.030 --> 00:38:11.150
It is possible to do them.

00:38:11.150 --> 00:38:13.904
We do have things like
sharded counters and suchlike.

00:38:13.904 --> 00:38:15.820
But we wanted to do
something more interesting

00:38:15.820 --> 00:38:17.251
and really stood out.

00:38:17.251 --> 00:38:18.750
How many of you
have heard of Redis?

00:38:20.890 --> 00:38:21.600
OK, a few of you.

00:38:21.600 --> 00:38:22.100
Good.

00:38:22.862 --> 00:38:24.820
And we're going to run
Redis on Compute Engine.

00:38:24.820 --> 00:38:27.040
So we can't run
Redis on App Engine.

00:38:27.040 --> 00:38:28.830
So we can easily run
it on Compute Engine

00:38:28.830 --> 00:38:30.830
and just have the two
talk to each other.

00:38:30.830 --> 00:38:33.176
So effectively, our
leaderboard will show us

00:38:33.176 --> 00:38:35.550
which users are getting the
most comments on their walks.

00:38:35.550 --> 00:38:38.470
[INAUDIBLE] time, I'll show you
what leaderboard looks like.

00:38:38.470 --> 00:38:39.720
So why did we use Redis?

00:38:39.720 --> 00:38:41.990
So using the right
tool for the job.

00:38:41.990 --> 00:38:43.575
Redis, for those
of you who know it,

00:38:43.575 --> 00:38:45.200
and for those of you
who don't know it,

00:38:45.200 --> 00:38:48.280
is effectively an
in-memory key value store.

00:38:48.280 --> 00:38:50.500
It's extremely powerful,
extremely fast.

00:38:50.500 --> 00:38:52.690
One of the great features
that make it stand out

00:38:52.690 --> 00:38:56.600
is the fact that values--
keys can be big things.

00:38:56.600 --> 00:38:59.850
They can be images,
long strings.

00:38:59.850 --> 00:39:02.340
But values can be objects.

00:39:02.340 --> 00:39:03.930
They can be structured data.

00:39:03.930 --> 00:39:06.400
They can be sorted sets.

00:39:06.400 --> 00:39:08.720
And having a sorted set for
a value for a leaderboard

00:39:08.720 --> 00:39:10.650
is perfect, exactly
what we need.

00:39:10.650 --> 00:39:14.430
We can make updates to that
object whenever we need to,

00:39:14.430 --> 00:39:16.710
and we can store and
extract it whenever

00:39:16.710 --> 00:39:18.162
we want to back from Redis.

00:39:18.162 --> 00:39:20.370
So Redis is perfectly suited
for this particular job.

00:39:22.540 --> 00:39:23.624
So why Compute Engine?

00:39:23.624 --> 00:39:25.290
Let's quickly go
through Compute Engine.

00:39:25.290 --> 00:39:27.081
I think we've covered
it quite a bit today.

00:39:28.040 --> 00:39:31.750
So Compute Engine effectively
gives us compute resources,

00:39:31.750 --> 00:39:34.405
virtual machines, networking,
persistent discs--

00:39:34.405 --> 00:39:36.730
all of the other things you
need to wire them together,

00:39:36.730 --> 00:39:39.830
creating virtual private
networks, that kind of thing.

00:39:39.830 --> 00:39:42.860
It's supported in US,
Europe, and Asia zones.

00:39:42.860 --> 00:39:45.300
It adds this amazingly
fast software

00:39:45.300 --> 00:39:47.620
defined networking based
backbone that it runs on,

00:39:47.620 --> 00:39:49.500
which is exactly
the same network

00:39:49.500 --> 00:39:51.010
that we use for our own stuff.

00:39:52.110 --> 00:39:54.019
It features sub-hour billing.

00:39:54.019 --> 00:39:56.310
Permanent billing, I think
Jerome covered that earlier.

00:39:57.470 --> 00:40:00.740
There's no iOPS charges
for block storage.

00:40:00.740 --> 00:40:02.880
So with some
providers, you actually

00:40:02.880 --> 00:40:06.270
have to pay by the iOPS,
as well as the size.

00:40:06.270 --> 00:40:08.211
For us, we only charge
you by the amount,

00:40:08.211 --> 00:40:10.710
the size of your position disk,
and the size of your blocked

00:40:10.710 --> 00:40:11.210
storage.

00:40:12.046 --> 00:40:13.920
And we don't need to
provide virtual machines

00:40:13.920 --> 00:40:15.190
for load balancing.

00:40:15.190 --> 00:40:17.560
So again, in some
cases, you have

00:40:17.560 --> 00:40:19.360
to provide a virtual machine.

00:40:19.360 --> 00:40:21.592
With HAProxy, all this
can be automated for you.

00:40:21.592 --> 00:40:23.300
But you have to spin
up a virtual machine

00:40:23.300 --> 00:40:24.175
to do load balancing.

00:40:24.175 --> 00:40:25.870
And if you want to
go big, you have

00:40:25.870 --> 00:40:27.560
to have lots of virtual machines
to do the load balancing

00:40:27.560 --> 00:40:28.430
for you.

00:40:28.430 --> 00:40:30.220
That requires a
warm-up period, so it

00:40:30.220 --> 00:40:32.160
could be quite expensive
to warm those up.

00:40:32.160 --> 00:40:33.590
For us, we don't
have to do that.

00:40:33.590 --> 00:40:35.260
We have effectively
what's called

00:40:35.260 --> 00:40:37.260
cloud native load balancing.

00:40:37.260 --> 00:40:40.400
Load balancing is inherent
in our infrastructure.

00:40:40.400 --> 00:40:43.430
And so it's very easy
for us to load balance

00:40:43.430 --> 00:40:45.450
across a huge
number of instances.

00:40:45.450 --> 00:40:47.590
And I have an example
of that coming up.

00:40:49.260 --> 00:40:51.750
Consistently fast, very
quick VM provisioning--

00:40:51.750 --> 00:40:54.880
less than 20 seconds
or around 20 seconds

00:40:54.880 --> 00:40:56.020
for a single instance.

00:40:56.020 --> 00:41:00.960
Probably about less than two
minutes for 1000 instances.

00:41:00.960 --> 00:41:02.410
Consistent
performance-- now this

00:41:02.410 --> 00:41:05.000
is extremely important
to us with our services,

00:41:05.000 --> 00:41:05.957
things like YouTube.

00:41:05.957 --> 00:41:07.790
Really when you're
watching a YouTube video,

00:41:07.790 --> 00:41:10.040
you don't want the fact that
somebody else is watching

00:41:10.040 --> 00:41:12.026
a YouTube video to
affect your experience.

00:41:12.026 --> 00:41:13.442
So it's extremely
important for us

00:41:13.442 --> 00:41:17.160
to actually prevent
one person's activity

00:41:17.160 --> 00:41:18.461
from impacting another.

00:41:18.461 --> 00:41:19.960
And we get that
with cloud platform.

00:41:21.320 --> 00:41:23.160
Also, cloud native
load balancing--

00:41:23.160 --> 00:41:24.827
want to mention that.

00:41:24.827 --> 00:41:27.035
This is the architecture of
a Compute Engine project.

00:41:27.035 --> 00:41:29.000
I'm not going to go into this.

00:41:29.000 --> 00:41:32.440
We support Debian,
CentOS, virtual machines,

00:41:32.440 --> 00:41:35.650
but also for paid options,
we have SUSE, Red Hat Linux,

00:41:35.650 --> 00:41:37.960
and in limited preview
we have Windows.

00:41:37.960 --> 00:41:42.250
You can also run things like
Core OS, SE Linux, anything

00:41:42.250 --> 00:41:44.342
you want to you can
run, but you may

00:41:44.342 --> 00:41:45.550
have to build your own image.

00:41:46.820 --> 00:41:50.440
Shared cores-- up to 16
shared core instances,

00:41:50.440 --> 00:41:52.220
instances that share cores.

00:41:52.220 --> 00:41:54.890
You'll have multiple of
these instances sharing

00:41:54.890 --> 00:41:57.750
a core very cheap,
very, very cheap.

00:41:58.905 --> 00:42:02.520
Perfect for experimenting or
just a weekend of hacking.

00:42:03.681 --> 00:42:06.055
Anything up to 16 cores for
our biggest virtual machines.

00:42:07.190 --> 00:42:11.780
After 60 gigabytes of RAM, I
know this is what we offer.

00:42:11.780 --> 00:42:14.650
We have free memory
configurations-- high CPU,

00:42:14.650 --> 00:42:16.440
standard, and high memory.

00:42:16.440 --> 00:42:19.030
Standard has a certain
amount of memory for CPU.

00:42:19.030 --> 00:42:20.831
High memory has more.

00:42:20.831 --> 00:42:23.080
I can't remember what the
exact numbers are currently.

00:42:23.080 --> 00:42:24.570
And high CPU has less.

00:42:24.570 --> 00:42:28.200
So high CPU is perfectly
suited for compute intensive

00:42:28.200 --> 00:42:30.410
workloads, and high
memory is perfectly

00:42:30.410 --> 00:42:32.030
suited for
memory-hungry workloads.

00:42:34.610 --> 00:42:36.470
Persistent Disk--
again I'll have

00:42:36.470 --> 00:42:39.640
to sacrifice some
things to be expedient.

00:42:39.640 --> 00:42:41.610
We only have about
15 minutes left.

00:42:41.610 --> 00:42:45.530
But Persistent Disk, we
have standard disk or SSD.

00:42:45.530 --> 00:42:48.827
You can effectively
attach this on demand,

00:42:48.827 --> 00:42:50.910
if it's a data partition,
to your virtual machine.

00:42:50.910 --> 00:42:52.743
So you can attach it
to one virtual machine,

00:42:52.743 --> 00:42:55.360
disconnect it, and attach it
to another in read-write mode.

00:42:55.360 --> 00:42:58.310
Or you can even attach it
to multiple virtual machines

00:42:58.310 --> 00:42:59.060
in read-only mode.

00:43:00.350 --> 00:43:03.290
Consistent I/O
performance, and I'm

00:43:03.290 --> 00:43:05.140
going to skip forward there.

00:43:05.140 --> 00:43:06.390
You can see the bullet points.

00:43:06.390 --> 00:43:09.014
If you have any questions about
it, come and see me afterwards.

00:43:10.500 --> 00:43:12.390
Local SSD is
something that's new.

00:43:13.226 --> 00:43:15.600
It has some commonalities with
our standard position disk

00:43:15.600 --> 00:43:20.680
offering-- per gigabyte pricing,
no I/O charges, performance

00:43:20.680 --> 00:43:24.260
is consistent, office
encryption [INAUDIBLE].

00:43:24.260 --> 00:43:26.434
Everything is encrypted at
rest, and live migration,

00:43:26.434 --> 00:43:27.725
which we'll talk about shortly.

00:43:27.725 --> 00:43:29.860
Kind of jumping the gun on that.

00:43:29.860 --> 00:43:32.900
The difference is in
terms of reliability,

00:43:32.900 --> 00:43:36.320
local SSD has nothing to offer.

00:43:36.320 --> 00:43:38.200
The storage
redundancy, checksums,

00:43:38.200 --> 00:43:40.820
and snapshots that persistent
disk offer are not available.

00:43:40.820 --> 00:43:42.350
You have to do
all that yourself.

00:43:42.350 --> 00:43:45.460
But what you get instead
is sub-millisecond latency.

00:43:45.460 --> 00:43:49.890
So local SSD is like having
disks attached to your machine.

00:43:49.890 --> 00:43:51.590
And it's very, very, very fast.

00:43:53.230 --> 00:43:56.040
And in terms of flexibility,
up to 10 terabytes

00:43:56.040 --> 00:44:03.060
of persistent disk, or one up
to four 375-gigabyte partitions

00:44:03.060 --> 00:44:05.580
attached to any virtual
machine for local SSD.

00:44:05.580 --> 00:44:07.080
And again, if you
want to know more,

00:44:07.080 --> 00:44:08.205
come and see me afterwards.

00:44:09.500 --> 00:44:14.090
Networking-- standard networking
stuff, TCP, UDP, static

00:44:14.090 --> 00:44:16.165
and ephemeral IP addresses
for public interfaces.

00:44:17.440 --> 00:44:20.270
Ephemeral IP addresses for
internal virtual machines,

00:44:20.270 --> 00:44:23.397
but we have this thing called
automatic DNS, internal DNS,

00:44:23.397 --> 00:44:25.730
which effectively allows you
to address virtual machines

00:44:25.730 --> 00:44:29.490
by their name, and other things
like firewalls and such like.

00:44:29.490 --> 00:44:32.810
I'm going to skip ahead, and I
apologize for skipping ahead.

00:44:32.810 --> 00:44:36.580
But I want to go ahead and
get as much as possible done.

00:44:36.580 --> 00:44:38.440
Live migration--
in the old days,

00:44:38.440 --> 00:44:41.110
when I first joined
the cloud team,

00:44:41.110 --> 00:44:43.960
we had to explain to people why
every now and again we would

00:44:43.960 --> 00:44:47.680
take a zone down, a complete
zone like us-central1-a.

00:44:47.680 --> 00:44:49.861
And you would have to
move all of your stuff.

00:44:49.861 --> 00:44:51.860
We would have to take all
your virtual machines,

00:44:51.860 --> 00:44:53.443
all your persistent
disks, and move it

00:44:53.443 --> 00:44:56.250
from one zone to another
while we took this zone down.

00:44:56.250 --> 00:44:58.790
What we would do when the
zone was down, we would update

00:44:58.790 --> 00:45:02.000
the firmware, update the
software, we would get a broom,

00:45:02.000 --> 00:45:04.695
and we would go and sweep out
the mouse crap from the racks.

00:45:05.900 --> 00:45:08.300
All that stuff, and we would
have a lovely shiny zone

00:45:08.300 --> 00:45:09.980
at the end of it, and then
you could but all your stuff

00:45:09.980 --> 00:45:11.146
back again if you wanted to.

00:45:12.310 --> 00:45:13.900
These days we have
live migration,

00:45:13.900 --> 00:45:15.790
so we don't do an entire zone.

00:45:15.790 --> 00:45:17.660
We do part of a zone at a time.

00:45:17.660 --> 00:45:20.100
So what we do, we schedule
a maintenance event

00:45:20.100 --> 00:45:21.090
on part of a zone.

00:45:21.090 --> 00:45:23.130
Anything that's in
that part of a zone--

00:45:23.130 --> 00:45:25.650
virtual machines or
persistent disks-- we move.

00:45:25.650 --> 00:45:27.540
We move it to a different
part of the zone.

00:45:27.540 --> 00:45:30.350
It's protected from
the [INAUDIBLE] then.

00:45:30.350 --> 00:45:32.500
And we effectively
do a memory copy.

00:45:32.500 --> 00:45:36.110
We do copies of all of data,
and you don't lose anything.

00:45:36.110 --> 00:45:38.430
Effectively, for most people,
what you're going to see

00:45:38.430 --> 00:45:41.770
is an entry in a log file
saying, we moved your stuff.

00:45:43.140 --> 00:45:46.150
For latency-sensitive
applications,

00:45:46.150 --> 00:45:49.060
maybe like mediastreaming,
it may be possible

00:45:49.060 --> 00:45:52.390
that this brief interruption,
very, very brief interruption--

00:45:52.390 --> 00:45:55.100
two milliseconds,
sub-millisecond even--

00:45:55.100 --> 00:45:58.210
may be important to you, and
we do offer you the ability

00:45:58.210 --> 00:46:00.360
to take your instances
down and move them.

00:46:04.630 --> 00:46:06.666
GCE and Docker
have been covered.

00:46:06.666 --> 00:46:08.040
But again, we can
talk about that

00:46:08.040 --> 00:46:11.962
more later if you want to
during the drink stuff, which

00:46:11.962 --> 00:46:12.920
I'm looking forward to.

00:46:12.920 --> 00:46:14.380
Should be fun.

00:46:14.380 --> 00:46:16.150
GCE is a great
place to run Redis.

00:46:16.150 --> 00:46:18.740
So we've already established
we want to run Redis.

00:46:18.740 --> 00:46:21.240
We've already established we
want to run our Compute Engine.

00:46:21.430 --> 00:46:22.970
So our leaderboard
application is

00:46:22.970 --> 00:46:24.595
going to make use of
temporary storage.

00:46:25.170 --> 00:46:28.080
And that kind of looks
something like that.

00:46:28.080 --> 00:46:33.260
When we have Compute Engine
with all register deployment,

00:46:33.260 --> 00:46:36.720
ultimately you'll have an
option in Compute Engine

00:46:36.720 --> 00:46:40.600
in the developer's console to
deploy everybody's clusters.

00:46:40.600 --> 00:46:41.570
Just click to deploy.

00:46:42.104 --> 00:46:44.520
At the moment, you have to do
that configuration yourself,

00:46:44.520 --> 00:46:48.025
but you can use scripts
and other things as well.

00:46:48.025 --> 00:46:49.926
Other things aren't
completely available yet

00:46:49.926 --> 00:46:51.800
or available in limited
preview that I really

00:46:51.800 --> 00:46:52.674
shouldn't talk about.

00:46:52.674 --> 00:46:54.810
But we could talk
about that later.

00:46:54.810 --> 00:46:56.910
But it is quite easy to
provision a Redis cluster

00:46:56.910 --> 00:46:58.930
currently on Google
Compute Engine.

00:46:58.930 --> 00:47:00.710
It's just that those
tools that we have

00:47:00.710 --> 00:47:02.530
are not completely
available yet.

00:47:02.530 --> 00:47:05.165
They're in limited preview,
and we're not really

00:47:05.165 --> 00:47:07.040
supposed to talk about
limited preview stuff.

00:47:08.140 --> 00:47:11.420
So that's what a Redis
cluster looks like.

00:47:11.420 --> 00:47:11.935
Sorry.

00:47:11.935 --> 00:47:13.310
I knew this was
going to be hard.

00:47:15.896 --> 00:47:16.860
And we have millions.

00:47:18.604 --> 00:47:19.895
We should always have millions.

00:47:20.994 --> 00:47:23.160
And naturally I always have
my own millions as well.

00:47:24.440 --> 00:47:26.429
So we've solved that
problem with Redis.

00:47:26.429 --> 00:47:28.470
We have a database for
our template summary data.

00:47:28.470 --> 00:47:28.969
That's cool.

00:47:28.969 --> 00:47:30.320
And we're done, really.

00:47:30.320 --> 00:47:31.969
That's the
architectural decisions.

00:47:31.969 --> 00:47:34.010
These are the kind of
crises we went through when

00:47:34.010 --> 00:47:35.854
designing and building
this application.

00:47:35.854 --> 00:47:37.770
We didn't cover Android
or anything like that,

00:47:37.770 --> 00:47:39.300
and we didn't
cover the libraries

00:47:39.300 --> 00:47:41.030
we use for the user
interface, which

00:47:41.030 --> 00:47:44.450
were, if you noticed based
on material design, what we

00:47:44.450 --> 00:47:46.550
announced at Google
I/O is in Polymer.

00:47:48.290 --> 00:47:49.900
What about planning
for getting big?

00:47:49.900 --> 00:47:51.691
This is something I
know quite a bit about.

00:47:52.380 --> 00:47:54.600
So back in November, I
worked on this project.

00:47:54.600 --> 00:47:56.500
In fact, I led this
project to build

00:47:56.500 --> 00:47:58.492
an application
for One Direction.

00:47:58.492 --> 00:48:00.325
How many of you have
heard of One Direction?

00:48:02.560 --> 00:48:03.690
So I get this all the time.

00:48:03.690 --> 00:48:05.181
You've all heard
of One Direction.

00:48:05.181 --> 00:48:06.180
You just won't admit it.

00:48:08.080 --> 00:48:09.020
Right?

00:48:09.020 --> 00:48:10.699
But they're a huge band.

00:48:10.699 --> 00:48:11.490
They're a boy band.

00:48:11.490 --> 00:48:12.580
They're huge.

00:48:12.580 --> 00:48:15.929
They have 17 million Twitter
followers when I last checked.

00:48:15.929 --> 00:48:17.970
They are one of the biggest
social media entities

00:48:17.970 --> 00:48:19.010
on the planet.

00:48:19.010 --> 00:48:21.100
And on the 23rd
of November, they

00:48:21.100 --> 00:48:23.830
did a seven-hour live
stream on YouTube.

00:48:23.830 --> 00:48:27.500
And they wanted, or
Sony Psycho Music

00:48:27.500 --> 00:48:30.780
wanted to have a second
screen application that

00:48:30.780 --> 00:48:33.360
would allow people watching
live stream to interact

00:48:33.360 --> 00:48:34.910
with the whole thing.

00:48:34.910 --> 00:48:38.180
They were basically asking
questions, six questions

00:48:38.180 --> 00:48:41.040
every hour, 42
questions in total.

00:48:41.040 --> 00:48:43.030
And they would get
rewards, badges,

00:48:43.030 --> 00:48:44.880
and such like for
getting questions right.

00:48:44.880 --> 00:48:45.712
And they could share
it with their friends

00:48:45.712 --> 00:48:46.752
and say, hey, look.

00:48:46.752 --> 00:48:47.460
I got this badge.

00:48:47.460 --> 00:48:48.100
You didn't get it.

00:48:48.100 --> 00:48:48.599
Ha ha ha.

00:48:50.440 --> 00:48:55.970
But we estimated that probably
about 620,000 concurrent users

00:48:55.970 --> 00:48:58.680
would access this application,
which is quite a large number.

00:49:00.050 --> 00:49:01.550
This is what it
kind of looked like.

00:49:02.620 --> 00:49:04.830
We saw-- again I don't want
to go into the details--

00:49:04.830 --> 00:49:06.665
again, if you look
at my I/O talk

00:49:06.665 --> 00:49:09.999
on making your cloud
services Google fast,

00:49:09.999 --> 00:49:11.290
we go into more detail on this.

00:49:11.290 --> 00:49:13.780
But basically we saw this
traffic pattern-- spikes

00:49:13.780 --> 00:49:16.224
of up to 750 queries per second.

00:49:16.224 --> 00:49:17.890
They're effectively
requests per second.

00:49:17.890 --> 00:49:19.810
Think of them as
requests per second,

00:49:19.810 --> 00:49:22.470
and that just carried
on for the seven hours.

00:49:22.470 --> 00:49:25.250
Apart from when this happened,
when somebody actually

00:49:25.250 --> 00:49:28.129
made an announcement on the live
stream about the application,

00:49:28.129 --> 00:49:29.670
suddenly we were a
little bit nervous

00:49:29.670 --> 00:49:31.795
about the application maybe
not being able to cope,

00:49:31.795 --> 00:49:33.690
so we didn't really
talk about it too much.

00:49:33.690 --> 00:49:35.065
But at some point
in live stream,

00:49:35.065 --> 00:49:37.140
probably about four hours
in, they mentioned it,

00:49:37.140 --> 00:49:40.700
and we saw this
huge uptake in users

00:49:40.700 --> 00:49:42.021
accessing the application.

00:49:42.021 --> 00:49:43.270
We would have a peak later on.

00:49:44.207 --> 00:49:45.790
You have to handle
that kind of scale.

00:49:45.790 --> 00:49:47.890
You never know when you're
going to be tech-crunched.

00:49:47.890 --> 00:49:49.800
You never know when you're
going to make it on to slashdot.

00:49:49.800 --> 00:49:52.216
And everybody's going to come
and access your application.

00:49:52.910 --> 00:49:54.410
If I was building
Walkshare, I would

00:49:54.410 --> 00:49:56.140
expect Walkshare to
be extremely popular.

00:49:56.140 --> 00:49:58.680
I would expect it to be the
most downloaded application

00:49:58.680 --> 00:50:01.250
on the Android Play Store.

00:50:01.250 --> 00:50:03.110
You've got to be
prepared for scale.

00:50:06.090 --> 00:50:07.700
So let's talk about
scaling modules.

00:50:07.700 --> 00:50:10.700
We looked at modules
earlier with App Engine.

00:50:10.700 --> 00:50:11.660
AUDIENCE: [INAUDIBLE].

00:50:11.660 --> 00:50:12.070
MANDY WAITE: Sorry?

00:50:12.070 --> 00:50:13.696
AUDIENCE: Is that
one of their songs?

00:50:13.696 --> 00:50:14.654
MANDY WAITE: I'm sorry.

00:50:14.654 --> 00:50:17.074
AUDIENCE: Be Prepared
to Scale-- is that?

00:50:18.942 --> 00:50:20.775
MANDY WAITE: It's hard
to see who's talking.

00:50:20.775 --> 00:50:21.110
Sorry.

00:50:21.110 --> 00:50:21.610
But yeah.

00:50:22.580 --> 00:50:25.320
So scaling for success
or something like that.

00:50:26.340 --> 00:50:28.360
So modules, we looked
at modules earlier.

00:50:28.360 --> 00:50:30.910
They have free options
when it comes to scaling.

00:50:30.910 --> 00:50:33.670
The classic auto-scaling
option, which is basically

00:50:33.670 --> 00:50:35.180
based on a very,
very complicated

00:50:35.180 --> 00:50:36.700
algorithm that we have.

00:50:36.700 --> 00:50:39.461
And basic scaling or manual
scaling, so basic scaling

00:50:39.461 --> 00:50:41.210
basically says, this
is the maximum number

00:50:41.210 --> 00:50:45.990
of instances while just using a
very, very crude way of scaling

00:50:45.990 --> 00:50:47.570
within that boundary.

00:50:47.570 --> 00:50:49.130
The manual scaling
effectively allows

00:50:49.130 --> 00:50:50.425
you to add instances yourself.

00:50:52.190 --> 00:50:53.410
Sorry.

00:50:53.410 --> 00:50:55.590
Requires that you add
instances yourself.

00:50:55.590 --> 00:50:57.490
So you're going to add
an instance manually

00:50:57.490 --> 00:50:58.282
to make it scale.

00:50:58.282 --> 00:50:59.990
Well, that's not
particularly responsive.

00:51:01.590 --> 00:51:04.150
And App Engine Autoscale
looks something like this.

00:51:05.210 --> 00:51:06.620
So I like this.

00:51:06.620 --> 00:51:07.670
We have lots of requests.

00:51:07.670 --> 00:51:09.440
They go into a
pending request queue.

00:51:09.440 --> 00:51:12.000
We have an instance that's been
created to service requests.

00:51:12.000 --> 00:51:14.780
This forwards busy, has
probably got 10,000 parts in it,

00:51:14.780 --> 00:51:16.180
not just free.

00:51:16.180 --> 00:51:18.240
So we spin up a new
instance very, very rapidly

00:51:18.240 --> 00:51:20.720
to handle the requests,
and we move the requests

00:51:20.720 --> 00:51:22.612
from the pending queue
onto the new instance.

00:51:22.612 --> 00:51:25.070
Then we create a new instance
to handle the other requests.

00:51:25.070 --> 00:51:26.980
This goes on ad infinitum.

00:51:26.980 --> 00:51:29.810
As long as we have requests in
the pending queue, App Engine,

00:51:29.810 --> 00:51:31.910
the scheduler itself
will be making decisions

00:51:31.910 --> 00:51:33.230
about what to do.

00:51:33.230 --> 00:51:36.705
Should I leave it in the
pending request queue

00:51:36.705 --> 00:51:38.580
and wait for an instance
to become available,

00:51:38.580 --> 00:51:41.080
or is it quicker for me
to spin up a new instance?

00:51:41.080 --> 00:51:43.490
They have to make those
decisions in real time very,

00:51:43.490 --> 00:51:44.600
very quickly.

00:51:44.600 --> 00:51:47.747
But we all know that making
decisions pragmatically

00:51:47.747 --> 00:51:50.330
is extremely quick, much quicker
than spinning up an instance.

00:51:50.330 --> 00:51:51.080
So it can do that.

00:51:51.080 --> 00:51:52.350
And it does it constantly.

00:51:52.350 --> 00:51:54.710
That's basically saying,
do I need a new instance,

00:51:54.710 --> 00:51:56.570
or can I just stay
in the pending queue?

00:51:56.570 --> 00:51:59.250
You have a little bit of
control about how this works.

00:51:59.250 --> 00:52:01.560
You can say, my
pending request latency

00:52:01.560 --> 00:52:04.720
can be 900 milliseconds, say.

00:52:04.720 --> 00:52:07.150
So don't do anything until
it's been in the queue for that

00:52:07.150 --> 00:52:07.650
long.

00:52:09.150 --> 00:52:11.940
If it goes over 900
milliseconds, take some action.

00:52:11.940 --> 00:52:13.670
Maybe spin up a new instance.

00:52:13.670 --> 00:52:16.310
And we also have these things
called idle instances as well,

00:52:16.310 --> 00:52:19.060
so if an instance is not
available to service a request,

00:52:19.060 --> 00:52:21.410
those requests will
be serviced-- sorry--

00:52:21.410 --> 00:52:25.080
routed to the idle instance
which will service them,

00:52:25.080 --> 00:52:28.290
while in the background spinning
up a new dynamic instance.

00:52:28.290 --> 00:52:30.540
It's all very clever, and
it all works extremely well.

00:52:32.710 --> 00:52:35.480
For modules such as
manual scale modules,

00:52:35.480 --> 00:52:38.330
we have the option as I think
Julia showed you earlier

00:52:38.330 --> 00:52:41.570
to control scalability
pragmatically by saying

00:52:41.570 --> 00:52:42.875
modules.set_num_instances.

00:52:42.875 --> 00:52:44.700
We want 42 of them.

00:52:44.700 --> 00:52:45.860
And that's very easy to do.

00:52:48.060 --> 00:52:51.610
Replica Pools-- Julia
mentioned Replica Pools before.

00:52:51.610 --> 00:52:54.470
This is where we can create--
I love this term-- homogeneous

00:52:54.470 --> 00:52:56.410
fleets of virtual machines.

00:52:56.410 --> 00:52:57.190
All identical.

00:52:57.190 --> 00:52:59.620
No snowflakes are all
absolutely identical.

00:52:59.620 --> 00:53:02.300
Based on the template, and the
templates is on the left hand.

00:53:02.300 --> 00:53:03.850
We basically define
the template,

00:53:03.850 --> 00:53:05.842
feed into this mechanism
called Replica Pool,

00:53:05.842 --> 00:53:07.550
and it will then go
and create this thing

00:53:07.550 --> 00:53:10.360
called a resource view, which
contains a load balancer

00:53:10.360 --> 00:53:12.240
and all of our virtual machines.

00:53:12.240 --> 00:53:13.800
So if you want 10
virtual machines,

00:53:13.800 --> 00:53:15.730
you will create 10
virtual machines,

00:53:15.730 --> 00:53:17.530
and then we have a
load balance endpoint

00:53:17.530 --> 00:53:19.260
we can send all
of our traffic to.

00:53:19.260 --> 00:53:21.089
So we can create
pools into size.

00:53:21.089 --> 00:53:22.630
In a moment we can't
auto-scale them,

00:53:22.630 --> 00:53:24.046
but we'll talk
about that shortly.

00:53:24.827 --> 00:53:26.660
Also monitors the health
of these instances,

00:53:26.660 --> 00:53:29.034
so if the instance goes away,
we can speed back up again.

00:53:32.020 --> 00:53:34.050
Load balancing--
load balancing scale.

00:53:34.050 --> 00:53:37.060
We talked about load
balancer earlier.

00:53:37.060 --> 00:53:39.040
So we did some tests
back in November again,

00:53:39.040 --> 00:53:42.190
I think, probably
about time of 1D Day

00:53:42.190 --> 00:53:45.570
where we load balanced one
million requests per second

00:53:45.570 --> 00:53:47.830
across a pool of
virtual machines,

00:53:47.830 --> 00:53:51.350
and it really didn't take
any kind of ramp up time.

00:53:51.350 --> 00:53:54.825
I think it took four seconds to
get ramped up and 120 seconds

00:53:54.825 --> 00:53:56.140
to stabilize.

00:53:56.140 --> 00:53:58.590
But very, very quickly, we
were able to load balance

00:53:58.590 --> 00:54:01.880
one million requests across
a pool of virtual machines.

00:54:01.880 --> 00:54:04.370
And it cost about
$10 to do that test.

00:54:04.370 --> 00:54:06.110
Now the requests that
were being serviced

00:54:06.110 --> 00:54:08.040
weren't particularly
complicated,

00:54:08.040 --> 00:54:11.009
but it shows you
can scale massively.

00:54:11.009 --> 00:54:12.800
This is a lot more than
the 10,000 requests

00:54:12.800 --> 00:54:14.454
we saw with the
One Direction app.

00:54:16.150 --> 00:54:18.870
When it comes to Redis,
the Redis solution we had

00:54:18.870 --> 00:54:20.660
was based on Replica Pools.

00:54:20.660 --> 00:54:23.640
So we have a load balancer--
oh, I missed a couple of errors

00:54:23.640 --> 00:54:24.140
there.

00:54:24.140 --> 00:54:25.550
I missed one error.

00:54:25.550 --> 00:54:27.410
Basically our
leaderboard application

00:54:27.410 --> 00:54:33.380
will talk to read-only
minions of Redis.

00:54:33.380 --> 00:54:36.067
All updates, all write-up
dates are sent to the master,

00:54:36.067 --> 00:54:37.900
and they're pushed out
to the millions which

00:54:37.900 --> 00:54:39.816
service our requests
from the leaderboard app.

00:54:42.620 --> 00:54:44.010
So do I have time for this?

00:54:45.325 --> 00:54:46.700
Nobody's telling
me, so I'm going

00:54:46.700 --> 00:54:47.908
to go ahead and do it anyway.

00:54:54.810 --> 00:55:00.745
So when our application's
working, let me refresh that.

00:55:03.620 --> 00:55:05.495
What I'm going to do is
go to Compute Engine.

00:55:06.620 --> 00:55:14.150
So because we know
that one of our modules

00:55:14.150 --> 00:55:17.760
has a load balancer
and a Replica Pool,

00:55:17.760 --> 00:55:21.230
we can go and look at the
load balancer configuration.

00:55:21.230 --> 00:55:23.470
We have a forwarding
rule, one IP address,

00:55:23.470 --> 00:55:26.190
so all of the requests will
go to this one IP address,

00:55:26.190 --> 00:55:30.230
and they will be routed
to a load balance pool

00:55:30.230 --> 00:55:32.340
virtual machines,
which are these ones.

00:55:33.601 --> 00:55:34.100
OK.

00:55:34.100 --> 00:55:38.600
So we have six virtual machines
currently, and now six minions,

00:55:38.600 --> 00:55:39.752
six Redis minions.

00:55:39.752 --> 00:55:41.210
We should have a
picture of minions

00:55:41.210 --> 00:55:42.459
here in the cloud [INAUDIBLE].

00:55:43.620 --> 00:55:46.030
So I'm going to have a look
at this one particularly.

00:55:47.620 --> 00:55:49.620
So that's been quite busy,
been doing some work.

00:55:49.620 --> 00:55:50.930
I'm going to SSH into it.

00:55:52.230 --> 00:55:53.585
And we have browser-based SSH.

00:55:53.585 --> 00:55:56.049
It allows us to effectively
click a button and lot

00:55:56.049 --> 00:55:57.090
into the virtual machine.

00:56:00.260 --> 00:56:02.280
It transfers the SSH
keys and ultimately makes

00:56:02.280 --> 00:56:02.905
the connection.

00:56:05.240 --> 00:56:07.650
And again, it's dependent
on the Wi-Fi access

00:56:07.650 --> 00:56:09.950
and also onto the mood
of the demo gods, which

00:56:09.950 --> 00:56:12.920
we know are not very
happy at the moment.

00:56:12.920 --> 00:56:15.280
And I can do PS
minus EF on here.

00:56:15.280 --> 00:56:16.610
Ooh, end up bigger.

00:56:20.380 --> 00:56:22.147
Maybe make the window smaller.

00:56:29.880 --> 00:56:30.380
Yay.

00:56:30.380 --> 00:56:30.880
Oh, wait.

00:56:33.730 --> 00:56:37.002
So here-- I'm probably going to
need to scale out here a bit.

00:56:44.720 --> 00:56:47.590
We can see these same
process on our Redis

00:56:47.590 --> 00:56:49.980
stuff, the stuff we care about.

00:56:49.980 --> 00:56:53.340
I want to come back out,
because I can't see it.

00:56:53.340 --> 00:56:57.750
We have 12339, 13234.

00:56:57.750 --> 00:57:01.230
And we're going to want to
kill the child process, which

00:57:01.230 --> 00:57:07.330
is going to be 13229.

00:57:07.330 --> 00:57:12.452
So I'm-- interesting.

00:57:32.170 --> 00:57:34.124
So I'll kill those
processes off now.

00:57:37.410 --> 00:57:37.910
Come on.

00:57:46.999 --> 00:57:48.790
Like I said, the demon
processes don't win,

00:57:48.790 --> 00:57:53.260
but it should be dead as far
as Compute Engine is concerned.

00:57:56.140 --> 00:57:57.460
Back to our load balance pool.

00:58:00.889 --> 00:58:01.680
And then we see it.

00:58:01.680 --> 00:58:02.179
It's gone.

00:58:03.095 --> 00:58:04.220
But it's not actually gone.

00:58:04.220 --> 00:58:06.450
It's been marked as unhealthy
by the load balancer.

00:58:06.450 --> 00:58:07.930
And we have a
health check set up

00:58:07.930 --> 00:58:12.340
that will actually
detect the-- really?

00:58:12.340 --> 00:58:12.990
Seriously?

00:58:12.990 --> 00:58:13.650
Going to stop?

00:58:14.315 --> 00:58:15.690
We have to get
this timing right.

00:58:15.690 --> 00:58:16.870
This is such a great talk.

00:58:16.870 --> 00:58:18.990
I could carry on talking
for another 20 minutes,

00:58:18.990 --> 00:58:21.800
and you miss so
much great stuff.

00:58:21.800 --> 00:58:23.590
But we'll get this
right next time.

00:58:24.710 --> 00:58:29.400
And basically yes, we had this
health check that effectively

00:58:29.400 --> 00:58:33.595
is a little go application
that has responded on port 8082

00:58:33.595 --> 00:58:37.520
to slash check, and if that
doesn't respond on that port,

00:58:37.520 --> 00:58:41.110
then it will effectively
mark that instance as bad

00:58:41.110 --> 00:58:42.880
and no longer send
traffic to it.

00:58:42.880 --> 00:58:45.750
So one of the other
instances in the target pool

00:58:45.750 --> 00:58:48.840
will continue to receive
traffic as before,

00:58:48.840 --> 00:58:52.110
but that one won't until
we bring it back up again.

00:58:52.110 --> 00:58:54.750
Once it comes back up again, it
will be added back to the pool

00:58:54.750 --> 00:58:56.410
and continue to
service requests.

00:58:56.410 --> 00:58:58.660
And basically just, a wrap
up because Tom's telling me

00:58:58.660 --> 00:58:59.220
I have to.

00:59:00.437 --> 00:59:01.645
Go back to the slides please.

00:59:05.450 --> 00:59:06.520
So basically that's it.

00:59:06.520 --> 00:59:09.800
So we've gone through all
of the design decisions.

00:59:09.800 --> 00:59:11.660
These last ones,
these last sections

00:59:11.660 --> 00:59:14.645
I'm just going to drop anyway
for expediency effectively.

00:59:14.645 --> 00:59:17.020
Because we just don't have
enough time to deliver it all.

00:59:18.520 --> 00:59:21.027
The last couple of things
I wanted to mention,

00:59:21.027 --> 00:59:23.360
and regard to Tom, you'll
have to come up and physically

00:59:23.360 --> 00:59:24.318
throw me off the stage.

00:59:26.380 --> 00:59:29.080
Coming soon, beyond
those virtual machines,

00:59:29.080 --> 00:59:32.069
we have Docker support for
managed virtual machines.

00:59:32.069 --> 00:59:33.610
Effectively managed
virtual machines,

00:59:33.610 --> 00:59:36.020
instead of being just managed
virtual machines will also

00:59:36.020 --> 00:59:36.912
run Docker.

00:59:36.912 --> 00:59:38.590
And it'll look
something like this.

00:59:38.590 --> 00:59:39.940
You'll provide a Docker file.

00:59:39.940 --> 00:59:41.840
You'll provide your
configuration file,

00:59:41.840 --> 00:59:45.070
and we will effectively register
your Docker image in a Docker

00:59:45.070 --> 00:59:49.390
registry, and create a container
on a virtual machine for you,

00:59:49.390 --> 00:59:52.450
and that will be what managed
virtual machines is based on.

00:59:52.450 --> 00:59:55.164
Replica pools will
auto-scale eventually.

00:59:55.164 --> 00:59:56.705
We already have that
limited preview.

00:59:56.705 --> 00:59:58.620
If you're interested
in that, let me know.

00:59:58.620 --> 01:00:01.477
We're looking for interest
in use cases for auto-scale,

01:00:01.477 --> 01:00:03.810
because the guys are really
looking at how they can best

01:00:03.810 --> 01:00:06.060
develop this kind of
technology, because

01:00:06.060 --> 01:00:08.450
auto-scaling virtual
machines is interesting.

01:00:08.450 --> 01:00:10.060
[INAUDIBLE] the
containers, maybe we

01:00:10.060 --> 01:00:12.075
should be focusing more
on scaling containers

01:00:12.075 --> 01:00:14.150
and not virtual machines.

01:00:14.150 --> 01:00:16.120
And finally, saving mobile data.

01:00:16.797 --> 01:00:19.380
We have this thing called Google
Cloud Save for Android, which

01:00:19.380 --> 01:00:21.088
will simply by the
process of saving data

01:00:21.088 --> 01:00:23.540
from your mobile app,
from Walkshare, just

01:00:23.540 --> 01:00:25.830
by sending it
straight to an API.

01:00:25.830 --> 01:00:27.890
You'll say, store this
data for this user,

01:00:27.890 --> 01:00:31.400
and that user anywhere can go
back and retrieve that data.

01:00:31.400 --> 01:00:32.470
And we're done.

01:00:32.470 --> 01:00:34.660
So thank you.

