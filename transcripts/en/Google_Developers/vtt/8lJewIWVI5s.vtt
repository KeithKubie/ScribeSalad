WEBVTT
Kind: captions
Language: en

00:00:03.750 --> 00:00:06.110
DREW CSILLAG: Hi.

00:00:06.110 --> 00:00:08.740
Wow, that's loud.

00:00:08.740 --> 00:00:10.650
I'm Drew Csillag, and welcome
to storing data

00:00:10.650 --> 00:00:12.160
in Google Apps Script.

00:00:12.160 --> 00:00:14.800
If everything goes to plan and
everything works, we're going

00:00:14.800 --> 00:00:17.990
to be going on a tour of the
four main storage systems

00:00:17.990 --> 00:00:19.740
available within Apps Script.

00:00:19.740 --> 00:00:21.660
Three of them you're probably
already aware of if you've

00:00:21.660 --> 00:00:23.830
used Apps Script
at all before.

00:00:23.830 --> 00:00:26.380
The other one, if you've been
to any of the other Apps

00:00:26.380 --> 00:00:29.150
Script talks so far, they've
totally leaked it.

00:00:29.150 --> 00:00:30.820
And so it won't be
a big surprise.

00:00:30.820 --> 00:00:37.170
However, they were at least nice
enough to plug this talk.

00:00:37.170 --> 00:00:41.570
A lot of useful scripts need
storage in some form or other.

00:00:41.570 --> 00:00:45.550
And in most usages of script
today, the storage is often

00:00:45.550 --> 00:00:47.080
related to the spreadsheet
that you

00:00:47.080 --> 00:00:48.930
embedded the script in.

00:00:48.930 --> 00:00:52.600
Since we now have scripts
in Google Drive and at

00:00:52.600 --> 00:00:56.350
script.google.com, it's
important to know what storage

00:00:56.350 --> 00:00:58.840
systems you have available to
you so you know which one is

00:00:58.840 --> 00:01:01.450
most appropriate for
your use case.

00:01:01.450 --> 00:01:04.610
But before we start, it always
helps to have a use case to

00:01:04.610 --> 00:01:08.750
help illustrate the concepts
that I'm going to show you.

00:01:08.750 --> 00:01:11.390
Google has loved LEGOs since
way back in the beginning,

00:01:11.390 --> 00:01:13.710
when Larry and Sergey decided
that they needed to build a

00:01:13.710 --> 00:01:16.670
hard drive enclosure for the
servers they were building.

00:01:16.670 --> 00:01:18.160
One of these originals
is actually

00:01:18.160 --> 00:01:20.010
on display at Stanford.

00:01:20.010 --> 00:01:22.910
Since then, some offices,
notably the New York City

00:01:22.910 --> 00:01:27.240
office, have LEGO areas, where
we can experiment or play or

00:01:27.240 --> 00:01:29.460
blow off work or that kind of
thing, to help us with our

00:01:29.460 --> 00:01:30.380
creativity.

00:01:30.380 --> 00:01:32.460
Or at least, that's
what we're told.

00:01:32.460 --> 00:01:35.560
I myself have a number of
bins of LEGOs at home.

00:01:35.560 --> 00:01:36.620
Actually, that's not
entirely true.

00:01:36.620 --> 00:01:38.790
My daughter has a number of
bins of LEGOs at home.

00:01:38.790 --> 00:01:41.000
She just lets me play with
them, because she's cool.

00:01:41.000 --> 00:01:43.600
Anyway, there have been a number
of times where we've

00:01:43.600 --> 00:01:46.330
been building something,
and you run short of

00:01:46.330 --> 00:01:47.060
the number of LEGOs.

00:01:47.060 --> 00:01:49.095
You're, like, 12 bricks shy of
being able to finish the thing

00:01:49.095 --> 00:01:50.540
that you wanted to build.

00:01:50.540 --> 00:01:52.790
And I thought that having an
inventory of the bricks that I

00:01:52.790 --> 00:01:55.960
had would be really handy, so
I can either design around

00:01:55.960 --> 00:01:58.100
what I have or at least know
that I'm going to run into

00:01:58.100 --> 00:02:00.800
trouble before I'm done.

00:02:00.800 --> 00:02:02.680
So I decided to start cataloging
the bricks.

00:02:02.680 --> 00:02:05.320
And I figured, hey, I work
on the Apps Script team.

00:02:05.320 --> 00:02:08.720
It might not be a
bad tool to use.

00:02:08.720 --> 00:02:11.260
So my plan was to start and
keep things really simple

00:02:11.260 --> 00:02:12.760
because I don't want to
have to do any more

00:02:12.760 --> 00:02:13.960
work than I have to.

00:02:13.960 --> 00:02:16.460
And so I decided to start
working with the simplest of

00:02:16.460 --> 00:02:18.580
storage systems we have
in Apps Script.

00:02:18.580 --> 00:02:21.250
And that's ScriptProperties.

00:02:21.250 --> 00:02:24.290
ScriptProperties is a simple,
string-based key value store

00:02:24.290 --> 00:02:27.080
that's tied to your Apps
Script project.

00:02:27.080 --> 00:02:29.510
Now, what exactly
does that mean?

00:02:29.510 --> 00:02:32.540
This means that a given script
project can only see the

00:02:32.540 --> 00:02:34.510
properties that belong to it.

00:02:34.510 --> 00:02:36.870
It cannot directly see any of
the script properties that

00:02:36.870 --> 00:02:41.010
belong to any scripts that you
might reference through the

00:02:41.010 --> 00:02:44.390
Script Libraries feature
that we have.

00:02:44.390 --> 00:02:47.730
Because you might store things
like JDBC connect strings or

00:02:47.730 --> 00:02:50.360
URLs or things that have
authorization credentials, and

00:02:50.360 --> 00:02:53.280
you don't want those going
all over the place.

00:02:53.280 --> 00:02:54.380
If you want to share
them with the other

00:02:54.380 --> 00:02:55.520
ones, you can do that.

00:02:55.520 --> 00:02:56.770
It's just a manual affair.

00:02:56.770 --> 00:02:58.970
It's not going to
be automatic.

00:02:58.970 --> 00:03:01.020
ScriptProperties works best
when you're dealing with

00:03:01.020 --> 00:03:04.210
smallish amounts of data that
the script needs that don't

00:03:04.210 --> 00:03:07.070
change terribly often.

00:03:07.070 --> 00:03:08.370
When I said that
ScriptProperties is the

00:03:08.370 --> 00:03:10.400
simplest of all storage systems
in Apps Script, I

00:03:10.400 --> 00:03:12.370
wasn't kidding.

00:03:12.370 --> 00:03:15.060
It's got exactly two methods,
one to get the string value by

00:03:15.060 --> 00:03:17.960
key, and the other
one to set it.

00:03:17.960 --> 00:03:20.120
One thing that's really nice
about ScriptProperties is that

00:03:20.120 --> 00:03:22.650
if you don't want to write
code-- because I prefer to

00:03:22.650 --> 00:03:24.490
write as little code
as possible--

00:03:24.490 --> 00:03:26.990
that if you don't want to write
code and have to fill

00:03:26.990 --> 00:03:30.460
the store up with the values
or build a UI to do it, you

00:03:30.460 --> 00:03:31.090
don't have to.

00:03:31.090 --> 00:03:33.320
In fact, it's completely
reasonable to never call that

00:03:33.320 --> 00:03:38.540
second method, because in the
File, Project Properties menu,

00:03:38.540 --> 00:03:41.440
there's a Project Properties
tab, where you can edit, list,

00:03:41.440 --> 00:03:43.830
add key value pairs.

00:03:43.830 --> 00:03:46.780
And they're immediately
accessible through the UI.

00:03:46.780 --> 00:03:49.130
You may notice that the API is
called ScriptProperties, but

00:03:49.130 --> 00:03:52.190
the dialogue says Project
Properties.

00:03:52.190 --> 00:03:53.830
This is mostly a historical
artifact.

00:03:53.830 --> 00:03:55.920
Originally, because Apps Script
didn't originally have

00:03:55.920 --> 00:03:58.250
the notion of a project, there
was the spreadsheet and the

00:03:58.250 --> 00:03:59.630
script that you embedded
in it.

00:03:59.630 --> 00:04:01.230
And that's all there was.

00:04:01.230 --> 00:04:07.280
Fast forward a couple of years
now, and between being able to

00:04:07.280 --> 00:04:09.930
have multiple scripts, and now
we've got HTML resources and

00:04:09.930 --> 00:04:14.630
other things, it evolved into
the project as it has now.

00:04:14.630 --> 00:04:17.350
But we didn't change the name of
the API, because we didn't

00:04:17.350 --> 00:04:19.790
want to break people's scripts
unnecessarily for something

00:04:19.790 --> 00:04:22.660
that was basically a
cosmetic change.

00:04:22.660 --> 00:04:25.360
For my LEGO brick inventory,
I made my keys to be very

00:04:25.360 --> 00:04:28.160
simple, the shorter side, x, and
the longer side, and the

00:04:28.160 --> 00:04:31.760
value was the number of
bricks that I had.

00:04:31.760 --> 00:04:34.020
And it was really simple to
find out for a given brick

00:04:34.020 --> 00:04:35.280
what I had.

00:04:35.280 --> 00:04:37.740
Basically, you get the property
with two-by-four if I

00:04:37.740 --> 00:04:39.180
want two-by-four bricks,
convert it to a

00:04:39.180 --> 00:04:40.990
number, and I'm done.

00:04:40.990 --> 00:04:43.020
Easy-peasy, lemon-squeezy.

00:04:43.020 --> 00:04:46.300
Well, ScriptProperties has some
really nice advantages.

00:04:46.300 --> 00:04:48.400
Again, the API couldn't
be simpler.

00:04:48.400 --> 00:04:50.180
There's two methods, one of
which you may never have to

00:04:50.180 --> 00:04:53.490
use because of the
built-in UI.

00:04:53.490 --> 00:04:55.800
Another great advantage is
that, in order to use

00:04:55.800 --> 00:04:58.060
ScriptProperties, you need
to do exactly bupkis to

00:04:58.060 --> 00:04:58.940
set this thing up.

00:04:58.940 --> 00:05:01.930
You just start using it.

00:05:01.930 --> 00:05:04.380
Lastly, and it's best when it's
used for its intended

00:05:04.380 --> 00:05:07.110
purpose, for settings
related to a script.

00:05:07.110 --> 00:05:09.950
That is, in other development
environments, you might have a

00:05:09.950 --> 00:05:12.400
,ini file or an XML
configuration file or

00:05:12.400 --> 00:05:14.260
something like that.

00:05:14.260 --> 00:05:15.930
For Apps Script,
ScriptProperties

00:05:15.930 --> 00:05:18.990
is how you do that.

00:05:18.990 --> 00:05:21.120
There are some things that
ScriptProperties is not a

00:05:21.120 --> 00:05:23.100
particularly good choice for.

00:05:23.100 --> 00:05:25.700
If your data is going to change
frequently, like more

00:05:25.700 --> 00:05:27.830
than once per second or so, then
ScriptProperties is not

00:05:27.830 --> 00:05:29.830
your best bet.

00:05:29.830 --> 00:05:31.710
Also, as I said earlier,
ScriptProperties is for

00:05:31.710 --> 00:05:32.840
smallish amounts of data.

00:05:32.840 --> 00:05:36.050
And this is more specifically
what I meant by here.

00:05:36.050 --> 00:05:39.830
And so if your data's expected
to grow to a decent size,

00:05:39.830 --> 00:05:42.980
you're going to run into that
ceiling before very long.

00:05:42.980 --> 00:05:45.670
And now that we have Script as
a web app, where we can use

00:05:45.670 --> 00:05:47.830
the user's credentials, if
you're going to store user

00:05:47.830 --> 00:05:50.100
preferences in there, and your
web app becomes extremely

00:05:50.100 --> 00:05:52.790
popular, you're more than likely
to run into that size

00:05:52.790 --> 00:05:55.170
limitation, as well.

00:05:55.170 --> 00:05:58.390
And while in this LEGO example
I'm kind of doing this, and

00:05:58.390 --> 00:06:01.710
we've seen a number of cases
where you guys and even my

00:06:01.710 --> 00:06:04.610
boss has done this,
ScriptProperties is not a

00:06:04.610 --> 00:06:07.860
generalized database.

00:06:07.860 --> 00:06:09.820
It doesn't provide any built-in
search facilities.

00:06:09.820 --> 00:06:12.360
And from what we've seen when
we've seen people do this, is

00:06:12.360 --> 00:06:15.400
that they have to write and roll
up their own search and

00:06:15.400 --> 00:06:17.440
query facilities.

00:06:17.440 --> 00:06:20.650
And lastly, structured values
don't do particularly well

00:06:20.650 --> 00:06:22.610
when you're using
ScriptProperties.

00:06:22.610 --> 00:06:25.230
You can use JSON and CSV in the
cases where you need it.

00:06:25.230 --> 00:06:27.280
And for one-off here and
there, that works OK.

00:06:27.280 --> 00:06:30.030
But if you're going to be
storing lots of data that way,

00:06:30.030 --> 00:06:32.920
it doesn't work especially
well.

00:06:32.920 --> 00:06:36.910
So now that I had my bricks
cataloged by size, I decided

00:06:36.910 --> 00:06:41.150
that I also wanted to track how
many of each color I had.

00:06:41.150 --> 00:06:44.100
So I had a couple of choices
of how I wanted to do this.

00:06:44.100 --> 00:06:48.270
First, I could try putting the
color into the key, like this.

00:06:48.270 --> 00:06:51.430
But then it becomes extremely
difficult to find out how many

00:06:51.430 --> 00:06:54.100
two-by-four blocks overall,
because I have to know every

00:06:54.100 --> 00:06:56.470
color that I might
possibly have.

00:06:56.470 --> 00:06:59.030
Alternatively, I could keep the
color out of the key and

00:06:59.030 --> 00:07:02.270
make the value a CSV of the
color in the count.

00:07:02.270 --> 00:07:04.890
But if I want to find out how
many blue bricks I have,

00:07:04.890 --> 00:07:10.300
obviously I have to know all the
brick sizes I ever have.

00:07:10.300 --> 00:07:12.890
Ultimately, what I wanted to
do has now outgrown what

00:07:12.890 --> 00:07:14.105
ScriptProperties is
really good for.

00:07:14.105 --> 00:07:18.470
And the next obvious one
is spreadsheets.

00:07:18.470 --> 00:07:20.960
Spreadsheets can be used for all
the kinds of things that

00:07:20.960 --> 00:07:24.110
ScriptProperties can, but
handles things like structured

00:07:24.110 --> 00:07:26.650
data with ease.

00:07:26.650 --> 00:07:28.700
Like ScriptProperties, it has
a high-functioning user

00:07:28.700 --> 00:07:31.220
interface, the spreadsheet
editor.

00:07:31.220 --> 00:07:33.530
For doing data entry, you've
got the spreadsheet editor,

00:07:33.530 --> 00:07:35.150
which allows you to do all
sorts of things, like

00:07:35.150 --> 00:07:37.430
including formulas and such.

00:07:37.430 --> 00:07:40.140
But we also have Google Forms
to do data entry, which is

00:07:40.140 --> 00:07:41.990
really, really handy.

00:07:41.990 --> 00:07:44.730
Also, if you need to copy or
export and convert your data

00:07:44.730 --> 00:07:47.670
to different formats, with
spreadsheets you can do that

00:07:47.670 --> 00:07:48.560
very, very easily.

00:07:48.560 --> 00:07:52.200
You can copy them, as well as
import and export the data.

00:07:52.200 --> 00:07:55.470
For the LEGO brick inventory
sheet, you can set it up

00:07:55.470 --> 00:07:56.840
something like this.

00:07:56.840 --> 00:07:59.600
And as you can see, we get the
nice colors, we get fonts.

00:07:59.600 --> 00:08:01.790
I used formulas to compute
the totals.

00:08:01.790 --> 00:08:03.810
And it was actually
pretty simple.

00:08:03.810 --> 00:08:06.260
And if I get another color
brick, it's just adding

00:08:06.260 --> 00:08:06.990
another column.

00:08:06.990 --> 00:08:09.570
If I get another brick size,
it's just adding another row.

00:08:09.570 --> 00:08:11.330
It's really simple.

00:08:11.330 --> 00:08:14.270
However, this flexibility
comes at a cost.

00:08:14.270 --> 00:08:17.420
The API for spreadsheets is
necessarily more complicated.

00:08:17.420 --> 00:08:21.220
If we look at the sample, the
function getBrickRow takes in

00:08:21.220 --> 00:08:23.100
a description of the brick,
like two-by-four or

00:08:23.100 --> 00:08:26.160
one-by-two, and returns the
row in the sheet for that

00:08:26.160 --> 00:08:27.770
brick type.

00:08:27.770 --> 00:08:29.810
So first, we get the
active spreadsheet.

00:08:29.810 --> 00:08:32.730
And then I always get the sheet
by name that I want,

00:08:32.730 --> 00:08:35.789
because who knows what people do
with these things, because

00:08:35.789 --> 00:08:37.669
I've messed up my spreadsheet
before.

00:08:37.669 --> 00:08:39.929
So if I get the one by name, I
make sure I always get the

00:08:39.929 --> 00:08:42.500
right sheet in the
spreadsheet.

00:08:42.500 --> 00:08:46.450
From there, I get a range of
the second row, one column

00:08:46.450 --> 00:08:49.180
wide, down to the bottom
of the sheet.

00:08:49.180 --> 00:08:50.570
And then we get the values.

00:08:50.570 --> 00:08:53.880
The data array that we get back
is a list of rows within

00:08:53.880 --> 00:08:55.640
the range that we chose.

00:08:55.640 --> 00:08:58.740
The elements in that array are
going to be single-element

00:08:58.740 --> 00:09:01.870
arrays, each containing
one-by-two, two-by-three, that

00:09:01.870 --> 00:09:03.120
kind of stuff.

00:09:05.100 --> 00:09:07.930
Well, here, then we go and
iterate over that array,

00:09:07.930 --> 00:09:10.300
looking for the brick
that they asked for.

00:09:10.300 --> 00:09:13.260
And then when we find it, we
return the index in the array

00:09:13.260 --> 00:09:14.680
that we found it at.

00:09:14.680 --> 00:09:17.750
You'll notice it says I+2.

00:09:17.750 --> 00:09:20.250
One of those two comes from the
fact that we started from

00:09:20.250 --> 00:09:22.790
the second row in the
spreadsheet, so we have to

00:09:22.790 --> 00:09:24.840
have one to compensate
for that.

00:09:24.840 --> 00:09:27.890
The other thing is also arrays
in JavaScript are zero-based.

00:09:27.890 --> 00:09:29.680
Spreadsheets, the rows
are one-based.

00:09:29.680 --> 00:09:32.390
So we had to add an extra one
to compensate for that.

00:09:32.390 --> 00:09:36.580
And if all else fails, we just
say, sorry, too bad, so sad.

00:09:36.580 --> 00:09:39.900
We couldn't find what
you're looking for.

00:09:39.900 --> 00:09:42.300
Now, for a moment, pretend that
we have a getColorColumn

00:09:42.300 --> 00:09:45.410
that does basically the same
thing, but returns the column

00:09:45.410 --> 00:09:47.740
for the color.

00:09:47.740 --> 00:09:50.220
With this, we can find out the
number of bricks of the given

00:09:50.220 --> 00:09:52.580
type and color with the
getBricksByColor function that

00:09:52.580 --> 00:09:53.640
we have here.

00:09:53.640 --> 00:09:56.870
Here, we get the sheet the
same way we did before.

00:09:56.870 --> 00:10:00.130
And then we get a range of the
row and the column from those

00:10:00.130 --> 00:10:01.760
two functions that we called
with the color and the

00:10:01.760 --> 00:10:02.710
description.

00:10:02.710 --> 00:10:04.910
And we get the value from it.

00:10:04.910 --> 00:10:07.470
This allows us to answer
questions very simply to say,

00:10:07.470 --> 00:10:09.890
how many blue bricks
do I have total?

00:10:09.890 --> 00:10:11.660
Since we've got the total
columns, we can use those

00:10:11.660 --> 00:10:14.900
column headings to find those
rows and columns.

00:10:14.900 --> 00:10:17.950
So we can get all two-by-two
bricks, all blue bricks, or

00:10:17.950 --> 00:10:20.640
all two-by-two blue bricks.

00:10:23.520 --> 00:10:25.420
So as you can see, spreadsheets
have some of

00:10:25.420 --> 00:10:27.540
their own advantages compared
to ScriptProperties.

00:10:27.540 --> 00:10:30.450
As I said, it has a built-in,
high-functioning UI and

00:10:30.450 --> 00:10:33.850
handles structured data much
more easily than you can in

00:10:33.850 --> 00:10:35.140
ScriptProperties.

00:10:35.140 --> 00:10:37.590
However, again, this
comes at a cost.

00:10:37.590 --> 00:10:40.010
Specifically, if you're fetching
lots of cell values

00:10:40.010 --> 00:10:42.020
from spreadsheets, you'll notice
it's a whole lot slower

00:10:42.020 --> 00:10:44.830
than ScriptProperties is.

00:10:44.830 --> 00:10:47.940
When you're dealing with
fetching data from a

00:10:47.940 --> 00:10:49.340
spreadsheet, you want
to try to fetch a

00:10:49.340 --> 00:10:51.380
rectangle of it at a time.

00:10:51.380 --> 00:10:52.310
That'll be much faster.

00:10:52.310 --> 00:10:54.740
If you want to illustrate this
to yourself, what you can do

00:10:54.740 --> 00:10:57.730
is you can write a script that
fills in 10 cells one by one,

00:10:57.730 --> 00:11:00.880
and then one that writes
10 cells all at once.

00:11:00.880 --> 00:11:02.550
And you'll notice how--

00:11:02.550 --> 00:11:03.580
you can watch it happen.

00:11:03.580 --> 00:11:04.930
And it's very much--

00:11:04.930 --> 00:11:08.260
so the upshot of this is that
you want to try to get and

00:11:08.260 --> 00:11:11.510
manipulate data in
large chunks.

00:11:11.510 --> 00:11:15.650
There's also some limits that
you need to be aware of.

00:11:15.650 --> 00:11:19.620
There's at most 50,000 rows in a
sheet and at most 200 sheets

00:11:19.620 --> 00:11:20.730
in a spreadsheet.

00:11:20.730 --> 00:11:22.980
If it gets anywhere near this
size, you'll probably

00:11:22.980 --> 00:11:25.010
experience lots of
pain anyway.

00:11:25.010 --> 00:11:29.010
They do get slower to load as
the more data you put in them.

00:11:29.010 --> 00:11:32.940
So in any case, for what we
were doing so far, the

00:11:32.940 --> 00:11:35.790
spreadsheet handles what
we're doing OK.

00:11:35.790 --> 00:11:38.490
But how do we expand it when
we start adding things like

00:11:38.490 --> 00:11:39.180
LEGO plates?

00:11:39.180 --> 00:11:42.230
LEGO plates, they look like LEGO
bricks, but they're about

00:11:42.230 --> 00:11:43.700
a third as thick.

00:11:43.700 --> 00:11:46.830
Well, in this case, we've
literally added a third

00:11:46.830 --> 00:11:48.280
dimension to the data.

00:11:48.280 --> 00:11:50.580
And while we could put it in a
spreadsheet, we've already had

00:11:50.580 --> 00:11:52.620
to write a bunch of search code
to be able to do what

00:11:52.620 --> 00:11:54.160
we're doing so far.

00:11:54.160 --> 00:11:56.860
And I didn't want to have to
write any more search code,

00:11:56.860 --> 00:11:58.350
because I've done enough.

00:11:58.350 --> 00:12:01.550
Well, what else could we do?

00:12:01.550 --> 00:12:03.950
Next one was JDBC.

00:12:03.950 --> 00:12:06.830
Using JDBC allows us to do
all this quite nicely.

00:12:06.830 --> 00:12:09.200
And our search code just becomes
comparatively brief

00:12:09.200 --> 00:12:10.870
SQL statements.

00:12:10.870 --> 00:12:12.330
We can now add the
height attribute.

00:12:12.330 --> 00:12:15.080
And the table would look
something like this.

00:12:15.080 --> 00:12:18.270
Since the plates are one third
as thick, I figure I'll keep

00:12:18.270 --> 00:12:20.910
the standard height brick
as now three.

00:12:20.910 --> 00:12:22.940
Well, how do we use this
from Apps Script?

00:12:22.940 --> 00:12:25.250
Well, here's an example.

00:12:25.250 --> 00:12:27.730
To get anywhere, you need to
get a database connection.

00:12:27.730 --> 00:12:30.350
And here, we're using a standard
JDBC connect string

00:12:30.350 --> 00:12:33.100
to connect to a MySQL
database.

00:12:33.100 --> 00:12:38.080
Apps Script supports MySQL,
SQL Server, and Oracle.

00:12:38.080 --> 00:12:41.760
And since database connection
strings contain authentication

00:12:41.760 --> 00:12:43.810
credentials, you might not want
this in your code, plus

00:12:43.810 --> 00:12:46.980
the fact that database servers
do move from time to time as

00:12:46.980 --> 00:12:48.120
things happen.

00:12:48.120 --> 00:12:51.980
So here, I used ScriptProperties
exactly for

00:12:51.980 --> 00:12:53.110
its intended purpose.

00:12:53.110 --> 00:12:55.720
And so we keep the JDBC URL in
a ScriptProperties and just

00:12:55.720 --> 00:12:57.930
reference it here.

00:12:57.930 --> 00:13:00.770
Once we've got the connection,
we create a statement, give

00:13:00.770 --> 00:13:06.240
our SQL statement over to it,
and get the result set out.

00:13:06.240 --> 00:13:08.690
And then we iterate over
the results set.

00:13:08.690 --> 00:13:11.820
Results, they have the getObject
method here.

00:13:11.820 --> 00:13:13.920
But they also have a bunch
of get and then type.

00:13:13.920 --> 00:13:16.520
They have getFloat, getDouble,
those kinds of things.

00:13:16.520 --> 00:13:18.930
So if you want to try to do type
coercion on the fly as

00:13:18.930 --> 00:13:21.140
you're extracting these from the
result cursor, you can do

00:13:21.140 --> 00:13:23.340
that there.

00:13:23.340 --> 00:13:24.650
If you notice, there's
numbers and

00:13:24.650 --> 00:13:26.390
comments after these lines.

00:13:26.390 --> 00:13:28.680
You can call them either with
the column number of the

00:13:28.680 --> 00:13:32.550
result or with the name of
the column in the result.

00:13:32.550 --> 00:13:35.410
Generally speaking, I've found
it's a good best practice to

00:13:35.410 --> 00:13:38.070
always use the name, for
a couple of reasons.

00:13:38.070 --> 00:13:40.600
First, the name makes it much
more obvious to the reader of

00:13:40.600 --> 00:13:43.130
this thing what column you're
referring to, because that's a

00:13:43.130 --> 00:13:45.970
whole lot easier to
read than this.

00:13:45.970 --> 00:13:48.610
Second, if you're doing things
like SELECT *, and somebody

00:13:48.610 --> 00:13:51.360
decides to add another column
to your table and then drop

00:13:51.360 --> 00:13:53.520
another one, then all
your numbers change.

00:13:53.520 --> 00:13:57.550
And then this loop
stops working.

00:13:57.550 --> 00:14:00.690
Now, once we've extracted all
these things, we build the

00:14:00.690 --> 00:14:04.530
result object, throw it in
an array, and return it.

00:14:04.530 --> 00:14:06.860
But getting all the bricks is
not a terribly useful thing

00:14:06.860 --> 00:14:08.480
all by itself.

00:14:08.480 --> 00:14:10.950
Let's say we want to find
all the blue bricks.

00:14:10.950 --> 00:14:13.020
Something that I've seen over
the course of my career is

00:14:13.020 --> 00:14:15.532
code that looks something
like this.

00:14:15.532 --> 00:14:18.670
All I will tell you right now,
and I will explain why, is

00:14:18.670 --> 00:14:20.195
never do this.

00:14:23.280 --> 00:14:26.400
The potential problem is
actually with every SQL

00:14:26.400 --> 00:14:28.390
database API in every
platform everywhere.

00:14:28.390 --> 00:14:32.020
This is not at all unique
to Google Apps Script.

00:14:32.020 --> 00:14:32.710
What's the big deal?

00:14:32.710 --> 00:14:33.340
It works, right?

00:14:33.340 --> 00:14:36.090
If you substitute in blue, you
do the query, you get all the

00:14:36.090 --> 00:14:37.510
blue bricks.

00:14:37.510 --> 00:14:38.880
And it will return exactly
what you want.

00:14:38.880 --> 00:14:40.540
And that's good.

00:14:40.540 --> 00:14:43.510
But if some user of the function
can pass in some

00:14:43.510 --> 00:14:46.940
nefarious value for color,
bad things can happen.

00:14:46.940 --> 00:14:48.590
There's actually a cartoon
that covers this.

00:14:48.590 --> 00:14:52.150
If you plunk in the term "Bobby
Tables" into your

00:14:52.150 --> 00:14:53.530
favorite search engine,
you will find it.

00:14:53.530 --> 00:14:55.310
It's very funny.

00:14:55.310 --> 00:14:58.410
But I'll illustrate the
problem to explain it.

00:14:58.410 --> 00:15:03.200
So if you call the function this
way, yes, you will get no

00:15:03.200 --> 00:15:06.180
rows from this when you
do execute this query.

00:15:06.180 --> 00:15:08.160
However, you will no longer
have a table with which to

00:15:08.160 --> 00:15:12.160
query after you're done, because
when you take that

00:15:12.160 --> 00:15:14.900
statement, and you add that
argument to it, the SQL you

00:15:14.900 --> 00:15:19.350
get there is what you
wind up with.

00:15:19.350 --> 00:15:22.880
So now that I've told you
exactly how not to do this--

00:15:22.880 --> 00:15:24.650
actually, let me back
up a second.

00:15:24.650 --> 00:15:27.700
If you learn nothing else from
this whole session--

00:15:27.700 --> 00:15:29.390
and as much as I want you to
remember the rest of it, if

00:15:29.390 --> 00:15:31.920
you remember nothing else,
remember this, because you

00:15:31.920 --> 00:15:34.490
never, ever, ever want
to do this--

00:15:34.490 --> 00:15:36.650
so now that I've told you how to
do it wrong, here's how you

00:15:36.650 --> 00:15:37.900
do it right.

00:15:40.650 --> 00:15:44.140
All the databases that Apps
Script supports support the

00:15:44.140 --> 00:15:45.850
notion of something called
bind variables.

00:15:45.850 --> 00:15:47.610
And here, we're using
question mark.

00:15:47.610 --> 00:15:49.780
And this is basically a
placeholder for the value you

00:15:49.780 --> 00:15:52.680
actually want to pass in.

00:15:52.680 --> 00:15:55.600
And much like the get methods
that were on the result

00:15:55.600 --> 00:15:57.640
object, on the statement object,
there are a bunch of

00:15:57.640 --> 00:16:00.230
set methods, which allow you to
set the value of what those

00:16:00.230 --> 00:16:01.840
placeholders are.

00:16:01.840 --> 00:16:03.370
And they are numbered
from one.

00:16:03.370 --> 00:16:06.150
In this case, we've got just
the one, so we're good.

00:16:06.150 --> 00:16:11.000
And then the loop follows
as it was before.

00:16:11.000 --> 00:16:12.120
JDBC has some nice advantages.

00:16:12.120 --> 00:16:13.630
First, it's SQL.

00:16:13.630 --> 00:16:15.850
And pretty much, these days,
a lot of people know SQL.

00:16:15.850 --> 00:16:18.010
So it's not that hard.

00:16:18.010 --> 00:16:20.000
Second, if you use reporting
software in an existing

00:16:20.000 --> 00:16:22.520
database you have, you can
continue to use that.

00:16:22.520 --> 00:16:24.850
Apps Script is just
another client.

00:16:24.850 --> 00:16:27.590
And third, you've got the
transaction and consistency

00:16:27.590 --> 00:16:30.710
guarantees and all those kinds
of things that you're used to.

00:16:30.710 --> 00:16:34.640
However, it's not all rainbows
and unicorns.

00:16:34.640 --> 00:16:37.330
Unlike ScriptProperties and
spreadsheets, you have to have

00:16:37.330 --> 00:16:40.110
this database hosted someplace,
with all the

00:16:40.110 --> 00:16:42.520
provisioning and setup headaches
that that implies.

00:16:42.520 --> 00:16:44.900
It can also be slow.

00:16:44.900 --> 00:16:47.430
And actually, this delay,
depending upon where things

00:16:47.430 --> 00:16:49.360
are, can actually be built in.

00:16:49.360 --> 00:16:53.030
The problem here is that, say,
if the Apps Script server that

00:16:53.030 --> 00:16:55.160
happens to go to try to talk to
your database lives in New

00:16:55.160 --> 00:16:58.130
York, and your database is in
LA, even if everything was

00:16:58.130 --> 00:17:00.070
traveling at the speed of
light, it would take 24

00:17:00.070 --> 00:17:02.450
milliseconds to make
the round-trip.

00:17:02.450 --> 00:17:05.310
And that's before you've routed
any packets and oh,

00:17:05.310 --> 00:17:07.609
yeah, even executed
your query.

00:17:07.609 --> 00:17:09.589
So talk about the importance
of data locality.

00:17:12.869 --> 00:17:15.390
And also, as I said before, if
you remember nothing else, be

00:17:15.390 --> 00:17:17.369
careful about SQL injection,
or you will have

00:17:17.369 --> 00:17:19.369
a really bad day.

00:17:19.369 --> 00:17:21.980
Another thing also that we
noticed, if you looked at the

00:17:21.980 --> 00:17:25.089
code sample, is that you spend
a lot of time shoving things

00:17:25.089 --> 00:17:25.950
in and out of SQL.

00:17:25.950 --> 00:17:27.990
And it's kind of a
pain in the neck.

00:17:27.990 --> 00:17:32.230
A lot of other languages, Java
and C# and those, they have

00:17:32.230 --> 00:17:34.070
all these frameworks that
basically handle the

00:17:34.070 --> 00:17:37.510
marshaling aspect, using either
data access objects or

00:17:37.510 --> 00:17:39.400
object relational mappings.

00:17:39.400 --> 00:17:41.450
A lot of what they're doing is
really just handling the data

00:17:41.450 --> 00:17:43.260
conversion between them.

00:17:43.260 --> 00:17:46.960
And again, you have to
plan a bit up front.

00:17:46.960 --> 00:17:48.320
You can't just kind
of do it ad hoc.

00:17:48.320 --> 00:17:50.810
You can't really kind of wing
it, because the expression

00:17:50.810 --> 00:17:53.600
I've heard before is that data
comes and goes, but schemas

00:17:53.600 --> 00:17:55.930
live forever.

00:17:55.930 --> 00:17:58.740
So to illustrate, as we move
to cataloging more of these

00:17:58.740 --> 00:18:01.800
LEGO parts that I have, I had
a bit of a dilemma, because

00:18:01.800 --> 00:18:04.310
not all LEGO parts are
easily describable

00:18:04.310 --> 00:18:05.850
the way we did bricks.

00:18:05.850 --> 00:18:08.930
Not all of them are
rectangular.

00:18:08.930 --> 00:18:11.180
They have the ones where the
number of studs on the top is

00:18:11.180 --> 00:18:13.110
different than the number of
little holes on the bottom.

00:18:13.110 --> 00:18:15.330
We have LEGO minifigs, which
are the little people-- and

00:18:15.330 --> 00:18:17.740
they look nothing at all like a
brick-- and satellite dishes

00:18:17.740 --> 00:18:19.350
and everything else.

00:18:19.350 --> 00:18:22.830
So how do we represent these
sanely in the SQL database?

00:18:22.830 --> 00:18:26.150
You've got a few choices, none
of them I particularly like.

00:18:26.150 --> 00:18:27.920
But you can have one
table that's got,

00:18:27.920 --> 00:18:29.300
like, 5 million columns.

00:18:29.300 --> 00:18:31.930
And each item has some subset
of those filled in.

00:18:31.930 --> 00:18:33.290
And I hope you know what--

00:18:33.290 --> 00:18:35.350
you'd better be careful which
ones you fill in.

00:18:35.350 --> 00:18:38.820
You can try to partition the
parts into things that sort of

00:18:38.820 --> 00:18:41.380
look the same and then
try to basically do

00:18:41.380 --> 00:18:42.740
the same thing there.

00:18:42.740 --> 00:18:45.210
But you have a granularity
challenge, like how narrowly

00:18:45.210 --> 00:18:48.020
do you do these.

00:18:48.020 --> 00:18:51.030
And then another option that
I've seen before is you

00:18:51.030 --> 00:18:53.260
compose an attribute
value table.

00:18:53.260 --> 00:18:56.740
But those tend to be a bit
of a bear to query.

00:18:56.740 --> 00:18:57.490
Actually, in some cases--

00:18:57.490 --> 00:18:59.050
I think I was talking to
somebody who said they wound

00:18:59.050 --> 00:19:01.150
up basically implementing their
own query optimizer to

00:19:01.150 --> 00:19:03.130
be able to do it.

00:19:03.130 --> 00:19:06.450
So for this LEGO example, it
turned out that the SQL

00:19:06.450 --> 00:19:09.660
database is probably not
our best choice.

00:19:09.660 --> 00:19:12.370
Well, today, I'm not really
announcing it because it's

00:19:12.370 --> 00:19:14.400
already been announced, but--

00:19:14.400 --> 00:19:15.650
ta-da!

00:19:18.790 --> 00:19:21.790
We're launching something
that's even easier.

00:19:21.790 --> 00:19:24.190
And it simplifies the way that
you can manage data within

00:19:24.190 --> 00:19:25.630
Apps Script.

00:19:25.630 --> 00:19:28.310
It's sort of like if I do
everything right, it'll kind

00:19:28.310 --> 00:19:29.980
of change the way that
you think about ways

00:19:29.980 --> 00:19:32.430
that data is organized.

00:19:32.430 --> 00:19:33.930
We're calling it ScriptDb.

00:19:33.930 --> 00:19:35.440
And this is kind of a big
deal, because it's a

00:19:35.440 --> 00:19:37.780
JavaScript object database.

00:19:37.780 --> 00:19:38.670
You're working in Apps Script.

00:19:38.670 --> 00:19:41.580
You're working with JavaScript
objects and data all the time.

00:19:41.580 --> 00:19:45.180
Why not just deal with all that
marshaling stuff and make

00:19:45.180 --> 00:19:47.270
it so that you don't have to
deal with it, you just save

00:19:47.270 --> 00:19:48.520
what you want?

00:19:51.430 --> 00:19:53.540
And the other nice thing is that
the query syntax is very,

00:19:53.540 --> 00:19:54.440
very simple.

00:19:54.440 --> 00:19:56.950
The basic premise is what we
call a query by example.

00:19:56.950 --> 00:19:58.890
Sometimes, we refer
to it as QBE.

00:19:58.890 --> 00:20:01.430
The idea is that when you call a
query, you give it an object

00:20:01.430 --> 00:20:03.470
that looks sort of like what
you want to come back.

00:20:03.470 --> 00:20:06.480
And we go ahead and figure out
what that means and return you

00:20:06.480 --> 00:20:08.310
the objects that make sense.

00:20:08.310 --> 00:20:11.960
ScriptDb is really convenient
because it comes ready to use,

00:20:11.960 --> 00:20:13.680
which means that there's nothing
to host, there's

00:20:13.680 --> 00:20:18.130
nothing to set up, there's
nothing to configure, there's

00:20:18.130 --> 00:20:19.916
no installation.

00:20:19.916 --> 00:20:22.230
All you've got to do
is use the API, and

00:20:22.230 --> 00:20:23.400
you're good to go.

00:20:23.400 --> 00:20:24.460
All right.

00:20:24.460 --> 00:20:26.320
So how do we do that?

00:20:26.320 --> 00:20:28.780
Well, let's start simple,
and we'll go from there.

00:20:28.780 --> 00:20:32.100
All access to the database
is via a database object.

00:20:32.100 --> 00:20:36.690
And in ScriptDb, you get it by
calling ScriptDb.getMyDb.

00:20:36.690 --> 00:20:39.990
Like the way ScriptProperties
works, this database object is

00:20:39.990 --> 00:20:41.420
tied to your script project.

00:20:41.420 --> 00:20:43.930
That means that other projects
that may use yours as a

00:20:43.930 --> 00:20:46.850
library don't have direct
access to it.

00:20:46.850 --> 00:20:49.450
However, you can pass this
database object to other

00:20:49.450 --> 00:20:52.100
libraries that you may be using,
and they can access it

00:20:52.100 --> 00:20:53.060
the same way.

00:20:53.060 --> 00:20:56.110
But a good best practice is to
locate all of your database

00:20:56.110 --> 00:20:58.960
code in one library and then
export functions that

00:20:58.960 --> 00:21:02.670
manipulate it through the
libraries feature.

00:21:06.500 --> 00:21:09.240
Saving objects in ScriptDb is
actually kind of simple.

00:21:09.240 --> 00:21:11.610
Here, we make a part that's just
a two-by-three standard

00:21:11.610 --> 00:21:12.330
height brick.

00:21:12.330 --> 00:21:13.480
We've got 52 of them.

00:21:13.480 --> 00:21:14.170
And they're blue.

00:21:14.170 --> 00:21:16.510
And we say save.

00:21:16.510 --> 00:21:20.420
The object that's returned
by save is almost exactly

00:21:20.420 --> 00:21:24.700
identical to the argument to
save, except that it's got a

00:21:24.700 --> 00:21:26.510
getId method on it.

00:21:29.730 --> 00:21:32.240
It's the internal ID that allows
us to be able to access

00:21:32.240 --> 00:21:35.470
this thing later.

00:21:35.470 --> 00:21:38.200
And one of the things that's not
illustrated on the slide,

00:21:38.200 --> 00:21:41.970
but when you save things in
ScriptDb, like we have, it's a

00:21:41.970 --> 00:21:42.960
fairly flat object.

00:21:42.960 --> 00:21:44.730
It's just got attribute at
value, attribute, value,

00:21:44.730 --> 00:21:45.630
attribute, value.

00:21:45.630 --> 00:21:49.070
But the values themselves can be
objects themselves, whether

00:21:49.070 --> 00:21:54.470
it be arrays or nulls or
Booleans, numbers, strings.

00:21:54.470 --> 00:21:58.240
The only main JavaScript type
we don't currently support

00:21:58.240 --> 00:22:00.850
directly is Date objects.

00:22:00.850 --> 00:22:03.640
But what you can do is you can
call getTime on it, get the

00:22:03.640 --> 00:22:06.010
milliseconds as epoch value,
and then save that instead.

00:22:10.050 --> 00:22:14.260
So the other thing, also, that
the saved object allows us to

00:22:14.260 --> 00:22:17.450
know is whether or not this
is an existing object

00:22:17.450 --> 00:22:18.620
in ScriptDb or not.

00:22:18.620 --> 00:22:20.320
And this allows us
to do updates.

00:22:20.320 --> 00:22:22.110
And here, we're taking the
object we just saved.

00:22:22.110 --> 00:22:24.425
We say we're setting a
Boolean flag on it.

00:22:24.425 --> 00:22:25.450
We're updating the count.

00:22:25.450 --> 00:22:28.900
And we just save it again.

00:22:28.900 --> 00:22:30.640
The idea that we had is actually
useful because you

00:22:30.640 --> 00:22:32.440
can just say, I want
to load it.

00:22:32.440 --> 00:22:35.190
Or if you have an array of IDs,
you could just load the

00:22:35.190 --> 00:22:36.870
whole array.

00:22:36.870 --> 00:22:40.350
Now, if the object with that
ID doesn't exist, you get

00:22:40.350 --> 00:22:43.160
nulls back.

00:22:43.160 --> 00:22:45.360
The array of parts that you get
back is going to be the

00:22:45.360 --> 00:22:49.420
same length as the
array of IDs.

00:22:49.420 --> 00:22:51.240
For any one of those IDs that
doesn't exist, there's a null

00:22:51.240 --> 00:22:52.190
in that spot instead.

00:22:52.190 --> 00:22:54.140
So this way, you can identify
which ones are which.

00:22:56.800 --> 00:22:58.790
We can also delete
things by ID.

00:22:58.790 --> 00:23:01.050
Or if we already have the object
in hand, we can just

00:23:01.050 --> 00:23:03.430
say, delete the part.

00:23:03.430 --> 00:23:05.215
But the interesting thing is
when we get to queries.

00:23:10.770 --> 00:23:12.725
Now that the data is there, how
do we find what we want?

00:23:12.725 --> 00:23:15.710
Well, we'll start with
a basic query.

00:23:15.710 --> 00:23:18.040
First, we get the database.

00:23:18.040 --> 00:23:20.000
And this is how we do queries.

00:23:20.000 --> 00:23:22.010
In this case, we're saying, give
me all the objects in the

00:23:22.010 --> 00:23:25.702
database where the short side
attribute is equal to two.

00:23:25.702 --> 00:23:27.140
That's pretty simple.

00:23:27.140 --> 00:23:28.920
And then the result
object looks a

00:23:28.920 --> 00:23:29.980
lot like a Java iterator.

00:23:29.980 --> 00:23:33.640
If you've seen Java iterators
before, it's the same pattern.

00:23:33.640 --> 00:23:36.140
Basically, while the result
still has a next item, we get

00:23:36.140 --> 00:23:37.600
the next item out of
it, we process it,

00:23:37.600 --> 00:23:40.440
do whatever we like.

00:23:40.440 --> 00:23:43.020
Now, if we want to find all
two-by-four bricks, we just

00:23:43.020 --> 00:23:45.610
add another attribute into the
query object to do it.

00:23:45.610 --> 00:23:46.860
It's pretty simple.

00:23:49.090 --> 00:23:51.630
We can also query sub-objects
the same way that we query the

00:23:51.630 --> 00:23:52.710
top-level items.

00:23:52.710 --> 00:23:54.610
So this case, say I've got--

00:23:54.610 --> 00:23:58.670
my LEGOs, actually, I keep track
as to which ones are in

00:23:58.670 --> 00:24:00.260
which bins in a bag.

00:24:00.260 --> 00:24:02.610
You can query these
sub-attributes of these

00:24:02.610 --> 00:24:05.010
objects, as well.

00:24:05.010 --> 00:24:07.500
We also support doing
alternation or OR.

00:24:07.500 --> 00:24:10.030
In this case, we're saying,
give me all the LEGOs that

00:24:10.030 --> 00:24:12.800
I've got where the short side is
two and the color is either

00:24:12.800 --> 00:24:15.560
green or blue.

00:24:15.560 --> 00:24:16.580
So far, so good.

00:24:16.580 --> 00:24:18.050
But what if I want the
ones where the

00:24:18.050 --> 00:24:19.490
long side isn't three?

00:24:19.490 --> 00:24:22.090
We also have NOT.

00:24:22.090 --> 00:24:23.810
Now we get a little trickier.

00:24:23.810 --> 00:24:25.330
I've got more than
just LEGO bricks.

00:24:25.330 --> 00:24:28.170
I've got those little LEGO
men, the minifigs.

00:24:28.170 --> 00:24:30.850
And they have various parts and
colors and decorations of

00:24:30.850 --> 00:24:33.270
their own, like heads and
torsos and legs and

00:24:33.270 --> 00:24:35.270
accessories and equipment.

00:24:35.270 --> 00:24:39.860
So what I want to do is, how do
I format these things so I

00:24:39.860 --> 00:24:42.500
can find all black
minifig parts?

00:24:42.500 --> 00:24:46.480
So if we have minifig parts laid
out, like up there on the

00:24:46.480 --> 00:24:51.260
top, you can use any value
just to say that this

00:24:51.260 --> 00:24:53.180
attribute exists at
all in the object.

00:24:56.730 --> 00:24:59.820
We also support things like, as
your database gets bigger,

00:24:59.820 --> 00:25:01.690
you might not want to deal
with them all at once.

00:25:01.690 --> 00:25:04.790
We allow you to say, like a
limit query, this is just like

00:25:04.790 --> 00:25:05.690
the way it would work in SQL .

00:25:05.690 --> 00:25:08.610
You just say, I want 20.

00:25:08.610 --> 00:25:10.820
Limits on their own are not
terribly useful until you can

00:25:10.820 --> 00:25:12.500
do ordering.

00:25:12.500 --> 00:25:16.140
By default, when you sort, it'll
sort them lexically,

00:25:16.140 --> 00:25:17.080
like it does on the left.

00:25:17.080 --> 00:25:20.240
However, when you're sorting
numbers, you'd probably prefer

00:25:20.240 --> 00:25:23.150
that 2 sorts before 10 instead
of afterwards, so you can pass

00:25:23.150 --> 00:25:25.510
the DB numeric argument as
the second argument.

00:25:25.510 --> 00:25:27.540
And that'll take care
of sorting it the

00:25:27.540 --> 00:25:30.630
way that you want.

00:25:30.630 --> 00:25:33.320
Now, in the course of my career,
when I'm dealing with

00:25:33.320 --> 00:25:35.720
databases and building a UI,
oftentimes, you're building

00:25:35.720 --> 00:25:38.600
some kind of paginated
display.

00:25:38.600 --> 00:25:40.555
And so here, you've got your
ordering criteria.

00:25:40.555 --> 00:25:43.900
You're saying, start at
page number times page

00:25:43.900 --> 00:25:45.850
size, limit page size.

00:25:45.850 --> 00:25:48.100
So like in our case, our
page size is 20.

00:25:48.100 --> 00:25:52.680
So give me the second
page of 20 results.

00:25:52.680 --> 00:25:54.640
And every time I've done this
ever in my life, I always seem

00:25:54.640 --> 00:25:56.810
to manage to screw it up.

00:25:56.810 --> 00:25:58.980
And so I decided when I was
doing this that I was finally

00:25:58.980 --> 00:26:03.130
going to capture the pattern
so I never have to get it

00:26:03.130 --> 00:26:03.820
wrong ever again.

00:26:03.820 --> 00:26:06.420
And so I added the
paginate option.

00:26:06.420 --> 00:26:08.790
You still can you "start at"
and "limit" if you choose.

00:26:08.790 --> 00:26:10.040
But you don't have to.

00:26:14.270 --> 00:26:16.890
Like JavaScript double equals,
we also support the same kinds

00:26:16.890 --> 00:26:19.750
of type equivalences
in our queries.

00:26:19.750 --> 00:26:22.930
So if you have saved something
as numeric 3, you can query it

00:26:22.930 --> 00:26:26.560
with string 3 or Boolean true.

00:26:26.560 --> 00:26:28.500
I won't read the slide.

00:26:28.500 --> 00:26:31.360
I assume you all can read
because you're here.

00:26:31.360 --> 00:26:34.080
But as another example, if you
save an item with a string

00:26:34.080 --> 00:26:37.320
value of 2, you can find with
querying for the numeric value

00:26:37.320 --> 00:26:39.270
of 2 or true.

00:26:39.270 --> 00:26:42.080
If you query it with the Boolean
true, that'll match

00:26:42.080 --> 00:26:42.920
any true value.

00:26:42.920 --> 00:26:46.520
So you'll obviously get things
other than 2 as a value.

00:26:49.590 --> 00:26:52.110
Now, this is the question that
almost always gets asked when

00:26:52.110 --> 00:26:53.360
I get this far.

00:27:00.270 --> 00:27:03.240
When you're using data stores,
you need to partition your

00:27:03.240 --> 00:27:06.050
data into logical subsets
of related data.

00:27:06.050 --> 00:27:08.020
For example, if you're in a file
system, they have, then,

00:27:08.020 --> 00:27:09.610
this notion of directories
and sub-directories.

00:27:09.610 --> 00:27:11.630
So you don't have to deal with
all your data at once.

00:27:11.630 --> 00:27:14.290
You can just deal with, say, the
photos from the last time

00:27:14.290 --> 00:27:18.380
you went to Chicago or a bunch
of salary letters or

00:27:18.380 --> 00:27:20.050
anything like that.

00:27:20.050 --> 00:27:24.820
In database land, you have silos
like all the HR data or

00:27:24.820 --> 00:27:27.840
all the data that corresponds to
some subsidiary corporation

00:27:27.840 --> 00:27:29.720
that you have.

00:27:29.720 --> 00:27:32.990
In a finer grained data silo,
it might be the table of

00:27:32.990 --> 00:27:35.710
current employee compensation
or the data for SKUs in

00:27:35.710 --> 00:27:37.670
department 29.

00:27:37.670 --> 00:27:41.310
The mechanism for siloing data
in database land is either by

00:27:41.310 --> 00:27:44.520
the server, the cluster it's in,
the database instance, the

00:27:44.520 --> 00:27:47.060
database within the instance,
the tables, and even to a

00:27:47.060 --> 00:27:48.310
certain extent, the columns.

00:27:50.740 --> 00:27:52.790
Data silos come in a couple
different flavors--

00:27:52.790 --> 00:27:54.180
actually, exactly two--

00:27:54.180 --> 00:27:56.290
disjoint and conjoined.

00:27:56.290 --> 00:27:59.500
Disjoint silos are silos where
a record can be in, at most,

00:27:59.500 --> 00:28:01.990
one silo of the given type.

00:28:01.990 --> 00:28:04.780
An example of disjoint silos are
things that are cars and

00:28:04.780 --> 00:28:05.580
things that are people.

00:28:05.580 --> 00:28:07.500
There's obviously no overlap
between those two.

00:28:07.500 --> 00:28:10.990
Or people that are 20 years of
age or people that are 21

00:28:10.990 --> 00:28:13.410
years of age.

00:28:13.410 --> 00:28:15.580
In traditional databases, these
are often implemented

00:28:15.580 --> 00:28:18.140
with tables, since while a given
row, you may have copies

00:28:18.140 --> 00:28:20.960
of it in other tables, a given
row is actually only in one

00:28:20.960 --> 00:28:22.810
table at a time.

00:28:22.810 --> 00:28:25.070
Conjoined silos, on the other
hand, are silos where things

00:28:25.070 --> 00:28:27.380
can be in more than one
silo at a time.

00:28:27.380 --> 00:28:30.480
An example is things that have
email addresses and things

00:28:30.480 --> 00:28:33.330
that have postal addresses.

00:28:33.330 --> 00:28:36.100
You can have any of the four
different combinations of

00:28:36.100 --> 00:28:38.210
having these or not, and
they're all valid.

00:28:38.210 --> 00:28:39.550
And in traditional databases,
you can

00:28:39.550 --> 00:28:42.070
represent these using views.

00:28:42.070 --> 00:28:45.170
So let's apply these
to ScriptDb.

00:28:45.170 --> 00:28:47.420
With ScriptDb, you could silo by
the script using the Script

00:28:47.420 --> 00:28:49.980
Libraries feature, and then by
different combinations of

00:28:49.980 --> 00:28:52.420
attribute presence or value.

00:28:52.420 --> 00:28:56.570
A simple way to do disjoints
sets is like we do up top in

00:28:56.570 --> 00:28:58.840
what I call a table attribute.

00:28:58.840 --> 00:29:01.090
Since an attribute can have,
at most, one value at any

00:29:01.090 --> 00:29:04.150
given time, that kind of fits
the definition of a disjoint

00:29:04.150 --> 00:29:05.950
silo quite nicely.

00:29:05.950 --> 00:29:08.180
One point to make here is that
there's nothing magical about

00:29:08.180 --> 00:29:10.510
the name "table." We could have
called it "tableau" or

00:29:10.510 --> 00:29:14.390
"mesa" or "Fred." ScriptDb
doesn't know

00:29:14.390 --> 00:29:15.100
what "table" means.

00:29:15.100 --> 00:29:18.880
So you can use whatever
you want.

00:29:18.880 --> 00:29:20.850
In a way, the silo and conjoined
sets is what I call

00:29:20.850 --> 00:29:23.380
an implicit or an inferred one,
in this case, something

00:29:23.380 --> 00:29:25.950
like minifig type, just checking
for the presence of

00:29:25.950 --> 00:29:28.060
an attribute.

00:29:28.060 --> 00:29:31.320
But sometimes, there's no way
to after the fact infer a

00:29:31.320 --> 00:29:34.450
particular conjoined data silo
that you're looking for.

00:29:34.450 --> 00:29:36.730
In such cases, you can add
explicit flags to the data,

00:29:36.730 --> 00:29:38.630
like we do on the third case.

00:29:38.630 --> 00:29:40.870
If you have the mental model of
how Gmail labels work, this

00:29:40.870 --> 00:29:44.430
is very, very similar to that.

00:29:44.430 --> 00:29:46.850
When you're choosing how to
lay out your objects in

00:29:46.850 --> 00:29:49.560
ScriptDb, something that's a
really good idea is to name

00:29:49.560 --> 00:29:52.550
things consistently within
the objects.

00:29:52.550 --> 00:29:54.800
Within a silo that you've
preplanned ahead of time, it's

00:29:54.800 --> 00:29:55.945
kind of obvious.

00:29:55.945 --> 00:29:58.720
If we're storing LEGOs, and we
want to know colors, we don't

00:29:58.720 --> 00:30:01.000
want to store it sometimes as
color, sometimes as brick

00:30:01.000 --> 00:30:03.700
color, and sometimes as color
brick, because it makes the

00:30:03.700 --> 00:30:05.740
queries kind of ugly.

00:30:05.740 --> 00:30:09.310
However, even across your data,
it's a good idea to

00:30:09.310 --> 00:30:12.790
always call the same thing
by the same attribute.

00:30:12.790 --> 00:30:15.110
For example, in the examples in
this session, the color is

00:30:15.110 --> 00:30:18.320
always the attribute
simply named color.

00:30:18.320 --> 00:30:20.570
If we stick to that, when we add
things like axles or moon

00:30:20.570 --> 00:30:22.895
plates or roofing bricks or
whatever other LEGO parts we

00:30:22.895 --> 00:30:25.570
can come up with, we can always
pull all things of a

00:30:25.570 --> 00:30:29.290
particular color just by
querying a color attribute.

00:30:29.290 --> 00:30:31.510
How about another example?

00:30:31.510 --> 00:30:33.910
Say you have a database
containing your organizational

00:30:33.910 --> 00:30:37.522
information, like the org
chart Expense Reporting.

00:30:37.522 --> 00:30:40.760
If you always call the
department ID department_ID in

00:30:40.760 --> 00:30:44.800
your data, you can, in one
query, pull all of the stuff

00:30:44.800 --> 00:30:48.040
relating to department ID,
whichever one you choose, all

00:30:48.040 --> 00:30:50.680
in one pull.

00:30:50.680 --> 00:30:53.310
Now, eventually, it's going
to happen where you don't

00:30:53.310 --> 00:30:55.190
actually follow through with
this, and things don't go

00:30:55.190 --> 00:30:58.490
right, and things weren't
named consistently.

00:30:58.490 --> 00:31:00.300
After all, to err is human.

00:31:00.300 --> 00:31:01.650
Are you doomed?

00:31:01.650 --> 00:31:02.940
Fortunately not.

00:31:02.940 --> 00:31:05.190
One query feature that I haven't
mentioned yet is what

00:31:05.190 --> 00:31:07.350
we call attribute OR.

00:31:07.350 --> 00:31:10.640
Much like we have db.anyOf for
values, we also have a syntax

00:31:10.640 --> 00:31:13.070
to represent the query where
this or that attribute is

00:31:13.070 --> 00:31:15.270
equal to some value.

00:31:15.270 --> 00:31:17.210
Instead of having an unquoted
attribute, like I've had in

00:31:17.210 --> 00:31:21.440
all the examples so far, you
have the attribute be a

00:31:21.440 --> 00:31:23.970
quoted, comma delimited
list of attributes.

00:31:23.970 --> 00:31:26.470
So in this case, it would return
all the ones where the

00:31:26.470 --> 00:31:28.800
color was black, irrespective of
whether or not you spelled

00:31:28.800 --> 00:31:31.510
"color" with a U or not,
or which side of the

00:31:31.510 --> 00:31:33.980
Atlantic you live on.

00:31:33.980 --> 00:31:37.400
If you noticed earlier, I used
the term "preplanned silos."

00:31:37.400 --> 00:31:44.450
Some silos are very intentional,
like the table

00:31:44.450 --> 00:31:48.450
attributes or the flag-based
silos I mentioned earlier.

00:31:48.450 --> 00:31:50.470
But if you name things
consistently, often useful

00:31:50.470 --> 00:31:54.250
silos can be discovered in
your data after the fact.

00:31:54.250 --> 00:31:57.200
I've already been using a few
of them already in the talk.

00:31:57.200 --> 00:31:58.570
The one about color I've
already mentioned.

00:31:58.570 --> 00:32:00.850
But there are a few
others, as well.

00:32:00.850 --> 00:32:04.070
One silo is the bricks siloed by
one of their sides, whether

00:32:04.070 --> 00:32:05.910
the long side or
the short side.

00:32:05.910 --> 00:32:08.550
And if you look across your
data, you'll find that useful

00:32:08.550 --> 00:32:10.912
silos turn up in a bunch
of different places.

00:32:10.912 --> 00:32:13.690
Even if you're using SQL
databases, it's actually a

00:32:13.690 --> 00:32:16.610
good idea to do this, too, for
a lot of the same reasons.

00:32:16.610 --> 00:32:18.460
Well, so far, so good.

00:32:18.460 --> 00:32:22.170
The only thing left over that
I can think of now is joins.

00:32:22.170 --> 00:32:23.960
Well, what about joins?

00:32:23.960 --> 00:32:27.860
Well, first, joins are needed
less often, because if you

00:32:27.860 --> 00:32:30.770
name things consistently, you
can avoid a lot of them.

00:32:30.770 --> 00:32:33.960
In a traditional database, you
can't really cut across your

00:32:33.960 --> 00:32:36.565
data in quite the same way that
you can here because if

00:32:36.565 --> 00:32:38.645
you're crossing multiple tables,
you either need to do

00:32:38.645 --> 00:32:41.960
a union query or a
join for that.

00:32:41.960 --> 00:32:44.870
Second, multiple queries
in ScriptDb are

00:32:44.870 --> 00:32:46.390
not that big a deal.

00:32:46.390 --> 00:32:49.760
ScriptDb queries are
comparatively cheap, often in

00:32:49.760 --> 00:32:53.390
the neighborhood of 30 to 50
milliseconds, a little bit

00:32:53.390 --> 00:32:55.460
more expensive than the speed
of light round-trip from New

00:32:55.460 --> 00:32:57.790
York to LA and back.

00:32:57.790 --> 00:32:59.960
Your first database operation
in the script will take a

00:32:59.960 --> 00:33:01.960
little bit longer, because
we do have to load some

00:33:01.960 --> 00:33:03.150
information about your database

00:33:03.150 --> 00:33:06.120
before we can proceed.

00:33:06.120 --> 00:33:08.920
Traditionally, when working with
SQL databases, I've seen

00:33:08.920 --> 00:33:11.600
people go to somewhat extreme
lengths to formulate the query

00:33:11.600 --> 00:33:14.210
so that they can get the
data in one pull.

00:33:14.210 --> 00:33:16.530
But in ScriptDb, multiple
queries are actually just fine

00:33:16.530 --> 00:33:19.500
because they are, again,
fairly inexpensive.

00:33:19.500 --> 00:33:23.770
So say we want to find what
color of standard height brick

00:33:23.770 --> 00:33:27.340
we have, that we have at least
50 of them, and they're

00:33:27.340 --> 00:33:30.460
two-by-two bricks, and then to
make sure that we have a torso

00:33:30.460 --> 00:33:33.030
that's the same color.

00:33:33.030 --> 00:33:35.480
So first, what we do is we query
our two-by-two bricks,

00:33:35.480 --> 00:33:36.380
standard height.

00:33:36.380 --> 00:33:39.420
And we say, give me the ones
where we have at least 50 or

00:33:39.420 --> 00:33:39.960
more of them.

00:33:39.960 --> 00:33:43.620
We'd loop through the results
here, storing the colors in

00:33:43.620 --> 00:33:45.300
the color variable.

00:33:45.300 --> 00:33:48.510
And then, secondly, we just
query for minifig torsos,

00:33:48.510 --> 00:33:51.440
where the color is any of the
colors that we found.

00:33:51.440 --> 00:33:53.370
So it's actually not
that difficult.

00:33:53.370 --> 00:33:55.870
We are looking for common
patterns that we can make

00:33:55.870 --> 00:33:57.340
these kinds of things
simpler for.

00:34:00.540 --> 00:34:01.670
There are some limits
that you need to

00:34:01.670 --> 00:34:03.180
be aware of in ScriptDb.

00:34:03.180 --> 00:34:06.500
Query results can be at
most 50,000 rows.

00:34:06.500 --> 00:34:08.230
Though the size of your
actual data set can be

00:34:08.230 --> 00:34:09.070
much larger than that.

00:34:09.070 --> 00:34:10.290
It's only governed
by the quota.

00:34:10.290 --> 00:34:11.870
And the quota limits
are given here.

00:34:14.960 --> 00:34:18.260
So hopefully, you've got now the
information that you need

00:34:18.260 --> 00:34:20.380
when developing your next Apps
Script program as to choose

00:34:20.380 --> 00:34:22.389
which storage system
is best for you.

00:34:22.389 --> 00:34:27.449
To summarize, ScriptProperties
is a simple key value based

00:34:27.449 --> 00:34:30.989
store with a built-in UI,
spreadsheets when you need

00:34:30.989 --> 00:34:35.219
more structure and a more
advanced built-in UI, JDBC for

00:34:35.219 --> 00:34:37.630
interacting with existing legacy
databases you have or

00:34:37.630 --> 00:34:41.679
when SQL is important to you,
and ScriptDb for a zero setup

00:34:41.679 --> 00:34:43.690
JavaScript object store.

00:34:43.690 --> 00:34:45.570
If you want for more information
about Google Apps

00:34:45.570 --> 00:34:48.520
Script, ScriptDb, you can
go to the respective

00:34:48.520 --> 00:34:51.170
URLs in this slide.

00:34:51.170 --> 00:34:53.530
Yes, we've now got some time
for questions if you want.

00:34:53.530 --> 00:34:55.460
Please go up to either one of
the microphones so that the

00:34:55.460 --> 00:34:57.789
people on YouTube
can hear you.

00:34:57.789 --> 00:34:59.039
Great, thanks.

00:35:08.500 --> 00:35:09.766
AUDIENCE: Hi.

00:35:09.766 --> 00:35:14.660
Is the ScriptDb one instance
per script, or we can have

00:35:14.660 --> 00:35:17.070
different instances
for each user

00:35:17.070 --> 00:35:18.320
that's running the script?

00:35:20.790 --> 00:35:22.480
DREW CSILLAG: It's tied to the
script project itself.

00:35:22.480 --> 00:35:25.950
So there is one per script.

00:35:25.950 --> 00:35:27.290
Did I answer your
question right?

00:35:27.290 --> 00:35:31.930
AUDIENCE: OK, but the quota then
stays script owner then?

00:35:31.930 --> 00:35:34.526
DREW CSILLAG: Yes, the quota's
charged to the script owner.

00:35:34.526 --> 00:35:35.776
AUDIENCE: All right, thanks.

00:35:38.580 --> 00:35:41.530
AUDIENCE: You mentioned a best
practice around making a store

00:35:41.530 --> 00:35:43.350
available to multiple scripts.

00:35:43.350 --> 00:35:45.150
Would you mind just
reviewing that?

00:35:45.150 --> 00:35:46.400
DREW CSILLAG: Yes, sure.

00:35:51.510 --> 00:35:53.070
Actually, if you watched
Saurabh's talk the other day,

00:35:53.070 --> 00:35:54.670
you can kind of get an
idea of what he did.

00:35:54.670 --> 00:35:57.550
But basically, the idea is you
put all the database access

00:35:57.550 --> 00:36:00.070
that you need for your ScriptDb
database into one

00:36:00.070 --> 00:36:01.280
script project.

00:36:01.280 --> 00:36:04.357
And then the projects that need
it can then reference it

00:36:04.357 --> 00:36:05.990
as a library.

00:36:05.990 --> 00:36:08.760
And you could do it that way.

00:36:08.760 --> 00:36:11.280
Or again, you can pass the
database object between the

00:36:11.280 --> 00:36:13.230
libraries as well, if you
want to do it that way.

00:36:13.230 --> 00:36:17.093
But the best practice is to
co-locate it all in one spot.

00:36:17.093 --> 00:36:18.820
Hi, go ahead.

00:36:18.820 --> 00:36:25.100
AUDIENCE: So you talked about
doing a query with a comma

00:36:25.100 --> 00:36:28.540
separator for two different
words, where effectively, they

00:36:28.540 --> 00:36:30.090
mean the same thing.

00:36:30.090 --> 00:36:35.930
So you have some limitations,
it seems, on what the--

00:36:35.930 --> 00:36:36.700
DREW CSILLAG: What
the keys can be.

00:36:36.700 --> 00:36:37.950
AUDIENCE: --what the
keys can be.

00:36:37.950 --> 00:36:38.360
DREW CSILLAG: Yes.

00:36:38.360 --> 00:36:40.660
Currently, they are limited to
what you can put into a normal

00:36:40.660 --> 00:36:44.250
JavaScript identifier.

00:36:44.250 --> 00:36:45.300
AUDIENCE: Identifier.

00:36:45.300 --> 00:36:46.020
OK.

00:36:46.020 --> 00:36:49.230
Not an object key.

00:36:49.230 --> 00:36:52.130
Because you could have the
comma in an object key.

00:36:52.130 --> 00:36:52.810
DREW CSILLAG: Right, yeah.

00:36:52.810 --> 00:36:55.930
But these are--

00:36:55.930 --> 00:36:58.640
I'm drawing a blank on
what the thing--

00:36:58.640 --> 00:37:01.530
it's a JavaScript identifier is
what the allowed characters

00:37:01.530 --> 00:37:03.090
set for a key.

00:37:03.090 --> 00:37:04.760
But the values can
contain whatever.

00:37:04.760 --> 00:37:05.070
AUDIENCE: OK.

00:37:05.070 --> 00:37:09.400
And the other question is, when
you're returning multiple

00:37:09.400 --> 00:37:13.390
values, you return null
to indicate that the

00:37:13.390 --> 00:37:15.910
value wasn't there.

00:37:15.910 --> 00:37:17.140
DREW CSILLAG: Yes, when you're
loading with an array.

00:37:17.140 --> 00:37:17.990
Yes.

00:37:17.990 --> 00:37:19.690
AUDIENCE: But that means
that you can't--

00:37:19.690 --> 00:37:23.240
is there a way to distinguish
whether the value was there,

00:37:23.240 --> 00:37:25.890
but its value was null?

00:37:25.890 --> 00:37:26.170
DREW CSILLAG: OK.

00:37:26.170 --> 00:37:28.080
Yeah, something I didn't mention
is that when you're

00:37:28.080 --> 00:37:30.140
storing objects in Apps Script,
they have to be

00:37:30.140 --> 00:37:31.210
regular, full-on--

00:37:31.210 --> 00:37:33.680
like an object with attributes
and values.

00:37:33.680 --> 00:37:36.100
I can't just store the
number 3 directly.

00:37:36.100 --> 00:37:39.460
So all the things that come
back from a load will be

00:37:39.460 --> 00:37:43.780
JavaScript objects with key
value pairs in them.

00:37:43.780 --> 00:37:45.250
If I'm explaining that--

00:37:45.250 --> 00:37:46.330
AUDIENCE: OK.

00:37:46.330 --> 00:37:47.170
DREW CSILLAG: That make sense?

00:37:47.170 --> 00:37:47.600
AUDIENCE: Thank you.

00:37:47.600 --> 00:37:49.800
DREW CSILLAG: OK.

00:37:49.800 --> 00:37:54.220
AUDIENCE: What is the limit,
how many records or--

00:37:54.220 --> 00:37:54.840
what can I store?

00:37:54.840 --> 00:37:57.020
Can I store millions
of records?

00:37:57.020 --> 00:37:58.150
Or is there a limit?

00:37:58.150 --> 00:38:00.010
DREW CSILLAG: It's limited
by the size of the

00:38:00.010 --> 00:38:01.350
stuff you put in there.

00:38:01.350 --> 00:38:04.900
It's not based upon a row
limit or a row count.

00:38:04.900 --> 00:38:06.110
AUDIENCE: You mean limited
by the total

00:38:06.110 --> 00:38:07.580
size of what I store?

00:38:07.580 --> 00:38:09.230
DREW CSILLAG: Yeah, by the
total size of the store.

00:38:09.230 --> 00:38:10.160
It's a size limitation.

00:38:10.160 --> 00:38:11.150
It's not the number of rows.

00:38:11.150 --> 00:38:15.230
AUDIENCE: And what's the size
limit for the store?

00:38:15.230 --> 00:38:18.620
For a paid customer?

00:38:18.620 --> 00:38:20.410
DREW CSILLAG: Consumers,
50 meg.

00:38:20.410 --> 00:38:22.390
Google Apps customers
are 100 megs.

00:38:22.390 --> 00:38:23.390
And--

00:38:23.390 --> 00:38:26.306
AUDIENCE: Apps for
business, 200.

00:38:26.306 --> 00:38:26.760
OK.

00:38:26.760 --> 00:38:30.920
And is this still in beta,
or is it production?

00:38:30.920 --> 00:38:32.900
DREW CSILLAG: I think it's still
tagged as experimental.

00:38:32.900 --> 00:38:33.210
AUDIENCE: Experimental.

00:38:33.210 --> 00:38:33.680
OK.

00:38:33.680 --> 00:38:34.930
DREW CSILLAG: Yeah.

00:38:36.840 --> 00:38:37.770
AUDIENCE: This was
asked earlier.

00:38:37.770 --> 00:38:40.620
But yesterday, you talked about
standalone scripts that

00:38:40.620 --> 00:38:42.300
run with user quota.

00:38:42.300 --> 00:38:45.540
And somebody asked a few minutes
ago about the storage.

00:38:45.540 --> 00:38:46.590
You said it's per--

00:38:46.590 --> 00:38:48.860
can you review again?

00:38:48.860 --> 00:38:51.080
Are all the database structures
per script, or are

00:38:51.080 --> 00:38:53.820
there any that are per user?

00:38:53.820 --> 00:38:55.930
DREW CSILLAG: Things like
ScriptProperties and ScriptDb,

00:38:55.930 --> 00:38:58.440
those are charged to
the script owner.

00:38:58.440 --> 00:39:02.290
But all the other quotas I can
think of are all charged to

00:39:02.290 --> 00:39:04.150
the user accessing
the thing if you

00:39:04.150 --> 00:39:06.090
publish it as a web app.

00:39:06.090 --> 00:39:08.930
AUDIENCE: I have another
question about the quota.

00:39:08.930 --> 00:39:11.800
Is the quota tied to the
script or to the owner?

00:39:11.800 --> 00:39:12.800
DREW CSILLAG: To the owner.

00:39:12.800 --> 00:39:14.050
AUDIENCE: OK.

00:39:19.380 --> 00:39:19.890
AUDIENCE: Hi.

00:39:19.890 --> 00:39:24.880
Is there a way that two users
with two different scripts can

00:39:24.880 --> 00:39:26.810
use the same database?

00:39:26.810 --> 00:39:28.350
DREW CSILLAG: Yes.

00:39:28.350 --> 00:39:30.320
Using the script libraries
feature that we talked about

00:39:30.320 --> 00:39:34.545
earlier, what you can do is you
can make it so that, say,

00:39:34.545 --> 00:39:38.080
the included library, its sole
function may be returning the

00:39:38.080 --> 00:39:40.100
database object that's
associated with that common

00:39:40.100 --> 00:39:42.620
script project that they're
both using.

00:39:51.380 --> 00:39:52.480
AUDIENCE: So I'm
still grappling

00:39:52.480 --> 00:39:56.200
with the quota issue.

00:39:56.200 --> 00:39:59.910
Is there a way to--

00:39:59.910 --> 00:40:06.980
if I create a library that
accesses ScriptDb, can I now

00:40:06.980 --> 00:40:13.070
have individual users who want
to have their own separate

00:40:13.070 --> 00:40:21.280
databases use that library and
have three users, three

00:40:21.280 --> 00:40:24.030
separate databases, three
separate quotas?

00:40:24.030 --> 00:40:25.140
DREW CSILLAG: Yes.

00:40:25.140 --> 00:40:28.780
Basically, what you would do
is, in the three separate

00:40:28.780 --> 00:40:31.720
scripts, what they would do is
they would pass their database

00:40:31.720 --> 00:40:35.650
instance into the common library
that manipulates them.

00:40:35.650 --> 00:40:36.130
That make sense?

00:40:36.130 --> 00:40:36.510
AUDIENCE: Yep.

00:40:36.510 --> 00:40:37.760
DREW CSILLAG: OK.

00:40:40.820 --> 00:40:42.050
AUDIENCE: I've just got
a quick question.

00:40:42.050 --> 00:40:43.780
You said there's a
50k [INAUDIBLE]

00:40:43.780 --> 00:40:44.090
limit.

00:40:44.090 --> 00:40:45.130
I think it's returned.

00:40:45.130 --> 00:40:46.850
DREW CSILLAG: That's just
on the query size, yeah.

00:40:46.850 --> 00:40:49.600
AUDIENCE: So how did--

00:40:49.600 --> 00:40:51.380
DREW CSILLAG: If you need more
than 50,000 rows, you'd have

00:40:51.380 --> 00:40:53.540
to find some way of breaking
it into chunks.

00:40:53.540 --> 00:40:54.950
AUDIENCE: OK.

00:40:54.950 --> 00:40:57.440
Is there a way to see how
many you would get?

00:40:57.440 --> 00:40:59.415
Because what if I want
all bricks, and

00:40:59.415 --> 00:41:00.840
there's 70,000 blue?

00:41:00.840 --> 00:41:05.580
I'd have to know what
IDs are in there.

00:41:05.580 --> 00:41:08.200
Like I didn't know if there was
a way to get first 2,000

00:41:08.200 --> 00:41:09.490
on the query or whatever.

00:41:09.490 --> 00:41:11.010
DREW CSILLAG: I'm going to say
talk to me afterwards.

00:41:11.010 --> 00:41:12.690
Off the top of my head,
I don't remember.

00:41:12.690 --> 00:41:13.940
I'd have to look it up.

00:41:17.570 --> 00:41:19.210
Pagination might do it.

00:41:19.210 --> 00:41:20.460
Like I said, I'll have
to double-check.

00:41:23.671 --> 00:41:25.570
AUDIENCE: Is there
a count feature?

00:41:25.570 --> 00:41:27.840
In other words, can I count
how many bricks I have?

00:41:27.840 --> 00:41:28.180
DREW CSILLAG: Yes.

00:41:28.180 --> 00:41:30.230
Actually, there is a method
in the DB object

00:41:30.230 --> 00:41:30.870
that I didn't mention.

00:41:30.870 --> 00:41:31.780
It's db.Count.

00:41:31.780 --> 00:41:33.370
And it takes the same
kind of query object

00:41:33.370 --> 00:41:34.620
that the query does.

00:41:39.130 --> 00:41:41.760
Anything else?

00:41:41.760 --> 00:41:42.490
Well, thanks for coming.

00:41:42.490 --> 00:41:42.790
Great.

00:41:42.790 --> 00:41:47.138
[APPLAUSE]

