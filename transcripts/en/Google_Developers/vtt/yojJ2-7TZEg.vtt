WEBVTT
Kind: captions
Language: en

00:00:04.590 --> 00:00:09.390
Welcome to Getting Started with
Google Shopping APIs.

00:00:09.390 --> 00:00:12.290
I'm Danny Hermes, a Developer
Programs Engineer on the

00:00:12.290 --> 00:00:14.720
Google Commerce team
here at Google.

00:00:14.720 --> 00:00:19.030
I specialize in the two shopping
APIs, the Content API

00:00:19.030 --> 00:00:22.590
for Shopping, and the Search
API for Shopping.

00:00:22.590 --> 00:00:25.680
Today, we're first going to
talk about Google Product

00:00:25.680 --> 00:00:28.280
Search and how it relates
to these APIs.

00:00:28.280 --> 00:00:31.600
Then we'll discuss each
API at a high level.

00:00:31.600 --> 00:00:34.890
And finally, we'll review the
technical resources available,

00:00:34.890 --> 00:00:37.620
get our hands dirty, and write
some code using client

00:00:37.620 --> 00:00:40.240
libraries provided
for these APIs.

00:00:40.240 --> 00:00:42.930
Before we can talk about the
shopping APIs, we need to talk

00:00:42.930 --> 00:00:45.220
about Google Product Search.

00:00:45.220 --> 00:00:48.860
On May 31, 2012, we announced
a change on the Google

00:00:48.860 --> 00:00:52.080
Commerce blog that will begin
to take place this summer.

00:00:52.080 --> 00:00:56.270
Later this week, on June 27,
2012 Google Product Search

00:00:56.270 --> 00:00:59.070
will be renamed to Google
Shopping in the US.

00:00:59.070 --> 00:01:01.790
Throughout this talk, I will
still use the term Google

00:01:01.790 --> 00:01:02.850
Product Search.

00:01:02.850 --> 00:01:06.250
Here we see google.com/shopping,
the

00:01:06.250 --> 00:01:08.370
Google Product Search
landing page.

00:01:08.370 --> 00:01:10.900
On this page, we try to bring
the shopping experience to the

00:01:10.900 --> 00:01:14.080
web by making it visually
pleasing and fun.

00:01:14.080 --> 00:01:19.440
By typing for a query like
remote-control car, we see

00:01:19.440 --> 00:01:22.230
results listing the most
relevant RC cars.

00:01:22.230 --> 00:01:25.180
What's more, we can customize
our search based on many other

00:01:25.180 --> 00:01:28.300
properties directly relevant
to remote-control cars.

00:01:28.300 --> 00:01:31.830
For example, we can filter on
the type of engine that powers

00:01:31.830 --> 00:01:34.150
the car, such as gas
or electric.

00:01:34.150 --> 00:01:38.270
We can filter on style of the
vehicle, not just RC cars, but

00:01:38.270 --> 00:01:40.720
also trucks, buggies,
and other models.

00:01:40.720 --> 00:01:44.090
As we scroll down, we also see
the drive type of the car,

00:01:44.090 --> 00:01:47.370
four wheel or two wheel, and
even the scale to real life.

00:01:47.370 --> 00:01:49.700
All these features are made
possible by collecting as much

00:01:49.700 --> 00:01:52.570
data as possible from merchants
and using it to

00:01:52.570 --> 00:01:55.250
provide as much useful choices
to the end user--

00:01:55.250 --> 00:01:56.330
the shopper--

00:01:56.330 --> 00:01:57.170
as possible.

00:01:57.170 --> 00:01:59.690
In order for an offering to show
up in Search results, a

00:01:59.690 --> 00:02:02.710
merchant first must upload the
product and all the associated

00:02:02.710 --> 00:02:04.870
data to the Google
Merchant Center.

00:02:04.870 --> 00:02:08.350
Once this data is uploaded, it
can be used to power Google

00:02:08.350 --> 00:02:10.820
Product Search, to drive traffic
through the Google

00:02:10.820 --> 00:02:13.550
Affiliate Network, or to power
a merchant's site through

00:02:13.550 --> 00:02:15.410
Google Commerce Search.

00:02:15.410 --> 00:02:17.620
This data can be made available
on all Google

00:02:17.620 --> 00:02:19.910
Shopping sites, depending on
the preferences of the

00:02:19.910 --> 00:02:22.370
merchant and the programs
they're involved in.

00:02:22.370 --> 00:02:25.120
So where do the Shopping
APIs come into play?

00:02:25.120 --> 00:02:28.850
First, the Search API is just
one of the many destinations

00:02:28.850 --> 00:02:31.050
that product data
can end up in.

00:02:31.050 --> 00:02:33.820
It allows developers to
submit search queries

00:02:33.820 --> 00:02:36.430
programmatically and receive
detailed results.

00:02:36.430 --> 00:02:39.910
Second, the Content API for
Shopping is one of the primary

00:02:39.910 --> 00:02:41.940
methods for uploading
product data to the

00:02:41.940 --> 00:02:44.460
Google Merchant Center.

00:02:44.460 --> 00:02:47.370
Merchants can submit their
data in two ways.

00:02:47.370 --> 00:02:50.350
They can upload via Product
Feeds, which are flat feed

00:02:50.350 --> 00:02:53.440
files that can be uploaded in
many ways, including directly

00:02:53.440 --> 00:02:55.180
through a web interface.

00:02:55.180 --> 00:02:58.250
Or merchants can upload product
data programmatically

00:02:58.250 --> 00:03:00.330
through the Content API.

00:03:00.330 --> 00:03:02.890
We won't compare the two methods
in depth today, but

00:03:02.890 --> 00:03:06.070
simply note that each has its
own merits and the Content API

00:03:06.070 --> 00:03:07.520
will be our focus.

00:03:07.520 --> 00:03:10.400
As I mentioned before, product
data can surface in many

00:03:10.400 --> 00:03:13.100
different Google properties, and
this manifests itself to

00:03:13.100 --> 00:03:15.970
some degree in the Search
API as well.

00:03:15.970 --> 00:03:18.530
There are three distinct use
cases for the Search API for

00:03:18.530 --> 00:03:21.680
Shopping, one of which must be
specified with every search

00:03:21.680 --> 00:03:23.070
query made.

00:03:23.070 --> 00:03:25.300
The first is the public
use case.

00:03:25.300 --> 00:03:28.490
This most closely mirrors live
results on google.com or

00:03:28.490 --> 00:03:30.180
Google Product Search.

00:03:30.180 --> 00:03:33.410
The second is the Google
Affiliate Network, or GAN.

00:03:33.410 --> 00:03:35.750
This allows publishers to
partner with developers to

00:03:35.750 --> 00:03:37.710
bring them qualified traffic.

00:03:37.710 --> 00:03:40.180
A GAN search query will contain
results only from

00:03:40.180 --> 00:03:42.600
those merchants affiliated
with the GAN

00:03:42.600 --> 00:03:44.530
account making the query.

00:03:44.530 --> 00:03:46.810
The product links in the search
results provide a way

00:03:46.810 --> 00:03:49.190
to track this qualified
traffic.

00:03:49.190 --> 00:03:52.220
And if a shopper navigates to
such links, the affiliate

00:03:52.220 --> 00:03:54.540
sending the traffic
can profit.

00:03:54.540 --> 00:03:56.580
The third and final
use case is Google

00:03:56.580 --> 00:03:58.930
Commerce Search, or GCS.

00:03:58.930 --> 00:04:01.500
Google Commerce Search allows
merchants to have the power of

00:04:01.500 --> 00:04:04.220
Google Search directly
on their website.

00:04:04.220 --> 00:04:07.280
By using the Search API, they
can send queries from their

00:04:07.280 --> 00:04:10.630
site to Google, and the most
relevant results from their

00:04:10.630 --> 00:04:13.550
own submitted product data
will be returned.

00:04:13.550 --> 00:04:16.450
Now that we know what
the APIs do, let's

00:04:16.450 --> 00:04:18.680
discuss how they do it.

00:04:18.680 --> 00:04:22.480
Let's first start with the
Content API for Shopping.

00:04:22.480 --> 00:04:25.590
In order to deliver relevant
results, we allow merchants to

00:04:25.590 --> 00:04:28.680
send as much data about each
individual product as

00:04:28.680 --> 00:04:30.060
they can think of.

00:04:30.060 --> 00:04:33.200
This allows for the enhanced
experience we saw, such as

00:04:33.200 --> 00:04:36.310
allowing relevant and helpful
search result filters.

00:04:36.310 --> 00:04:40.070
As seen here, this data is
format as XML, and has data

00:04:40.070 --> 00:04:43.060
specific to each attribute
to the product.

00:04:43.060 --> 00:04:46.630
For example, we have a title, a
description, a price, and a

00:04:46.630 --> 00:04:48.920
tax rule, among other things.

00:04:48.920 --> 00:04:50.470
All of this data and more--

00:04:50.470 --> 00:04:52.070
if the merchant desires--

00:04:52.070 --> 00:04:56.470
must be contained in a parent
entry element as we see here.

00:04:56.470 --> 00:05:00.120
The entry element comes from the
Atom XML namespace, as do

00:05:00.120 --> 00:05:02.030
some other attributes
like title.

00:05:02.030 --> 00:05:03.950
But the majority of the
attributes are defined in

00:05:03.950 --> 00:05:09.010
other namespaces defined
as SC and SCP here.

00:05:09.010 --> 00:05:12.120
As we'll see later, by using a
Client Library, we can worry

00:05:12.120 --> 00:05:14.780
about the data we send and let
the library worry about

00:05:14.780 --> 00:05:17.290
creating the correct
XML representation.

00:05:17.290 --> 00:05:20.025
Once you've constructed the
product entry, you can insert

00:05:20.025 --> 00:05:22.530
or upload the data by
submitting a POST

00:05:22.530 --> 00:05:24.610
request, as seen here.

00:05:24.610 --> 00:05:28.420
The API allows you to update,
delete, and retrieve products

00:05:28.420 --> 00:05:31.960
as well by submitting PUT,
DELETE, and GET requests,

00:05:31.960 --> 00:05:33.720
respectively.

00:05:33.720 --> 00:05:36.890
Each request sent must follow
some basic rules.

00:05:36.890 --> 00:05:40.980
First, each is made to a URI
based off the same root and

00:05:40.980 --> 00:05:44.240
must include the Account ID to
identify who or what owns the

00:05:44.240 --> 00:05:46.300
product data being sent.

00:05:46.300 --> 00:05:49.980
This ID is associated with the
Merchant Center account.

00:05:49.980 --> 00:05:53.130
In addition to a shared root for
the URI, each request must

00:05:53.130 --> 00:05:55.710
be signed with an authorization
token.

00:05:55.710 --> 00:05:58.860
This verifies that the user
sending the request truly has

00:05:58.860 --> 00:06:01.050
access to the Merchant Center
account in which they are

00:06:01.050 --> 00:06:03.390
changing inventory.

00:06:03.390 --> 00:06:05.980
Finally, the header of the
request must identify the type

00:06:05.980 --> 00:06:07.990
of the data being exchanged.

00:06:07.990 --> 00:06:11.460
Here, we are sending XML in the
body of the request and

00:06:11.460 --> 00:06:15.190
must identify it as such
to Google servers.

00:06:15.190 --> 00:06:17.305
Upon success, we receive
a 201 HTTP status

00:06:17.305 --> 00:06:21.890
code indicating success.

00:06:21.890 --> 00:06:24.840
In addition to this, we also
see that Google servers

00:06:24.840 --> 00:06:28.150
identify the response they're
returning as XML.

00:06:28.150 --> 00:06:30.940
As we will see shortly, the
response is formatted very

00:06:30.940 --> 00:06:33.150
similar to the request.

00:06:33.150 --> 00:06:37.750
Finally, the header location is
set to the same URI we made

00:06:37.750 --> 00:06:40.990
the request to, plus a
colon-delimited identifier

00:06:40.990 --> 00:06:44.210
tacked on at the end.

00:06:44.210 --> 00:06:47.790
The location is composed
of five basic parts.

00:06:47.790 --> 00:06:49.220
The first is the root--

00:06:49.220 --> 00:06:52.960
content.googleapis.com/v1.

00:06:52.960 --> 00:06:55.260
And the second is the Account
ID associated with

00:06:55.260 --> 00:06:57.090
the data being set.

00:06:57.090 --> 00:06:59.030
The next part is the path.

00:06:59.030 --> 00:07:01.820
When dealing explicitly with
product data, the path is

00:07:01.820 --> 00:07:03.680
items/products.

00:07:03.680 --> 00:07:07.230
However, the API also allows
operations on other data, such

00:07:07.230 --> 00:07:09.545
as allowing you to
programmatically add new users

00:07:09.545 --> 00:07:11.960
to your Merchant
Center account.

00:07:11.960 --> 00:07:14.970
For this talk, we will simply
concentrate on the case where

00:07:14.970 --> 00:07:17.570
product data is sent.

00:07:17.570 --> 00:07:20.010
After the path, we have
the projection.

00:07:20.010 --> 00:07:23.320
This is specific to the case
where product is being sent

00:07:23.320 --> 00:07:26.330
and can be either generic
or schema.

00:07:26.330 --> 00:07:28.400
The value dictates the format
of the response

00:07:28.400 --> 00:07:31.260
returned from Google.

00:07:31.260 --> 00:07:34.350
The final piece to the URI
is the Product ID.

00:07:34.350 --> 00:07:37.660
This is a colon-delimited string
composed of the channel

00:07:37.660 --> 00:07:39.090
where the sale will occur.

00:07:39.090 --> 00:07:43.350
Here we have online, but local
is also allowed, followed by

00:07:43.350 --> 00:07:45.910
the language of the product,
and the target country of

00:07:45.910 --> 00:07:48.370
sale, and finally
by the Product

00:07:48.370 --> 00:07:50.830
ID sent in the request.

00:07:50.830 --> 00:07:53.840
In addition to the headers, such
as the successful status

00:07:53.840 --> 00:07:58.450
code and location, we receive
a body in the API response.

00:07:58.450 --> 00:08:02.610
This is also XML, formatted
identically as the request and

00:08:02.610 --> 00:08:05.770
containing the same information
and then some.

00:08:05.770 --> 00:08:09.760
We can see the same title,
description, ID, et cetera, as

00:08:09.760 --> 00:08:12.330
well as some new information,
like when the product entry

00:08:12.330 --> 00:08:15.460
was published and when
it was last edited.

00:08:15.460 --> 00:08:18.260
Now that we have seen how the
Content API works, let's

00:08:18.260 --> 00:08:20.990
investigate the Search
API for Shopping.

00:08:20.990 --> 00:08:24.510
The Search API, intended to be
a programmatic relative to

00:08:24.510 --> 00:08:27.510
Google Product Search, allows
submitting queries for

00:08:27.510 --> 00:08:29.400
shopping data as well
as submitting

00:08:29.400 --> 00:08:31.180
filters on that data.

00:08:31.180 --> 00:08:34.539
As a result, this API has a
smaller set of operations than

00:08:34.539 --> 00:08:37.289
the Content API for Shopping.

00:08:37.289 --> 00:08:41.230
Since each query is only
retrieving data, the only HTTP

00:08:41.230 --> 00:08:45.400
verb used is a GET request, and
the response is returned

00:08:45.400 --> 00:08:48.310
from the API nearly instantly.

00:08:48.310 --> 00:08:51.920
Each request sent consists of
the exact same route URI--

00:08:51.920 --> 00:09:01.130
www.googleapis.com/ shoppinh/
search/ v1/ public/ products.

00:09:01.130 --> 00:09:04.900
Rather than specifying an
Account ID in the URI, an API

00:09:04.900 --> 00:09:07.470
key is sent with the
key parameter.

00:09:07.470 --> 00:09:11.370
The query, filters, and other
settings are sent as URI query

00:09:11.370 --> 00:09:13.370
parameters as well.

00:09:13.370 --> 00:09:16.780
Since product data is divided
by country, the country URI

00:09:16.780 --> 00:09:19.560
parameter is required.

00:09:19.560 --> 00:09:22.520
As I mentioned earlier, there
are three use cases, one of

00:09:22.520 --> 00:09:23.860
which is public.

00:09:23.860 --> 00:09:27.650
The route URI ends with
public/products.

00:09:27.650 --> 00:09:30.200
This indicates that we are
making queries against the

00:09:30.200 --> 00:09:32.040
public source.

00:09:32.040 --> 00:09:35.320
Google Affiliate Network and
Commerce Search queries use a

00:09:35.320 --> 00:09:38.550
different value in place of
public, and this value will

00:09:38.550 --> 00:09:42.980
depend on the GAN or
GCS Account ID.

00:09:42.980 --> 00:09:46.540
Finally, unlike the Content API
for Shopping, responses

00:09:46.540 --> 00:09:50.390
can be in either XML format
or JSON format.

00:09:50.390 --> 00:09:54.630
By default, responses are in
JSON format, but a specific

00:09:54.630 --> 00:09:57.980
format can be requested by
simply adding the ALT query

00:09:57.980 --> 00:10:02.170
parameter to the request with
a value of ATOM for XML and

00:10:02.170 --> 00:10:05.530
JSON for JSON.

00:10:05.530 --> 00:10:08.670
When filtering results from a
Search query, we can use the

00:10:08.670 --> 00:10:11.940
great deal of data associated
with each product.

00:10:11.940 --> 00:10:15.430
We can define filters by using
the brand of the product, the

00:10:15.430 --> 00:10:19.290
category of the product, for
example, shoes, as well as the

00:10:19.290 --> 00:10:22.480
condition, description,
price, and title.

00:10:22.480 --> 00:10:25.580
We can even query based on the
Account ID of the merchant

00:10:25.580 --> 00:10:28.310
selling the product, the
Global Trade ID of the

00:10:28.310 --> 00:10:30.540
product, or the link to
the web page where

00:10:30.540 --> 00:10:32.290
the product is listed.

00:10:32.290 --> 00:10:35.610
These attributes can be used in
simple filters to specify

00:10:35.610 --> 00:10:38.980
that the product must have a
certain brand or must not be

00:10:38.980 --> 00:10:41.180
from a certain Account ID.

00:10:41.180 --> 00:10:44.020
These attributes can also be
used in more complex filters,

00:10:44.020 --> 00:10:45.780
as we'll see in the
next slide.

00:10:45.780 --> 00:10:48.900
In addition to using product
attributes, by specifying

00:10:48.900 --> 00:10:52.380
certain URI query parameters,
we can define and

00:10:52.380 --> 00:10:54.810
then refine our query.

00:10:54.810 --> 00:10:57.050
First, is the most
basic parameter--

00:10:57.050 --> 00:10:58.700
Q for query.

00:10:58.700 --> 00:11:01.730
This allows full-text search
and follows the same query

00:11:01.730 --> 00:11:04.330
rules that google.com
Search does.

00:11:04.330 --> 00:11:08.150
Next, the restrictBy parameter
helps to construct filters

00:11:08.150 --> 00:11:10.800
that match a certain
restriction, such as setting a

00:11:10.800 --> 00:11:13.830
price between $10 and $20.

00:11:13.830 --> 00:11:17.360
Using the crowdBy parameter, we
can create in effect nearly

00:11:17.360 --> 00:11:19.150
the opposite of restricting.

00:11:19.150 --> 00:11:21.450
Rather than ensuring all
results returned have a

00:11:21.450 --> 00:11:24.980
specific attribute, we limit the
number of results from a

00:11:24.980 --> 00:11:26.220
given attribute.

00:11:26.220 --> 00:11:30.290
For example, by crowding by
Account ID and specifying 3,

00:11:30.290 --> 00:11:33.000
we ensure that no account will
have more than three results

00:11:33.000 --> 00:11:36.940
in our product listings
returned from the API.

00:11:36.940 --> 00:11:40.250
By sending the rankBy query
parameter, we can rank results

00:11:40.250 --> 00:11:42.950
according to some preset
ranking rules.

00:11:42.950 --> 00:11:47.630
By specifying
rankBy=price:ascending, we can

00:11:47.630 --> 00:11:50.580
ensure that the first result
is the least expensive and

00:11:50.580 --> 00:11:53.500
prices increase as we
go down the list.

00:11:53.500 --> 00:11:56.460
Unfortunately, there are no
relevant ascending or

00:11:56.460 --> 00:11:59.230
descending ranking rules
associated with many of the

00:11:59.230 --> 00:12:02.970
available attributes such as
title and description, and so

00:12:02.970 --> 00:12:06.260
they're not supported
with rankBy.

00:12:06.260 --> 00:12:09.280
By using facets, you can divide
Search results into

00:12:09.280 --> 00:12:12.170
descriptive buckets, creating
a histogram based on the

00:12:12.170 --> 00:12:14.480
restrictions you provide.

00:12:14.480 --> 00:12:17.740
By specifying
facets.enabled=true, the

00:12:17.740 --> 00:12:20.810
results returned from the API
will be facets rather than

00:12:20.810 --> 00:12:22.800
individual products.

00:12:22.800 --> 00:12:25.660
Each facet has a count
identifying the total number

00:12:25.660 --> 00:12:28.820
of products as well as some
other data points identifying

00:12:28.820 --> 00:12:30.930
the rules which define
the bucket.

00:12:30.930 --> 00:12:35.180
To partition results into two
buckets, one of products less

00:12:35.180 --> 00:12:39.560
than $10, and one of products
costing $10 or more, we need

00:12:39.560 --> 00:12:43.070
to specify the facets.include
parameter with the value

00:12:43.070 --> 00:12:47.290
price, followed by a colon and
a list of price intervals.

00:12:47.290 --> 00:12:51.960
Here, our list of intervals is
the interval from star to 10,

00:12:51.960 --> 00:12:55.780
and from 10 to star, where star
is a wild card indicating

00:12:55.780 --> 00:12:59.260
the minimum when used as the
left value and maximum when

00:12:59.260 --> 00:13:00.650
used as the right.

00:13:00.650 --> 00:13:03.820
As you can see here, the search
results we have from

00:13:03.820 --> 00:13:06.610
the filters we defined in the
previous slide are in a

00:13:06.610 --> 00:13:08.710
dictionary JSON format.

00:13:08.710 --> 00:13:11.280
The products themselves are
in the Items key of this

00:13:11.280 --> 00:13:12.030
dictionary.

00:13:12.030 --> 00:13:13.890
But before that, we also
have the total

00:13:13.890 --> 00:13:15.070
number of items returned--

00:13:15.070 --> 00:13:16.630
129--

00:13:16.630 --> 00:13:18.490
as well as the current
item count--

00:13:18.490 --> 00:13:21.390
25 returned in this query.

00:13:21.390 --> 00:13:22.870
The title of the
first result--

00:13:22.870 --> 00:13:26.580
RC Fast Wheels Car-- indicates
the name of the product.

00:13:26.580 --> 00:13:30.420
And we see further on that
we have the price of $10.

00:13:30.420 --> 00:13:34.780
Going to the next result, we
see a price of $10.07, and

00:13:34.780 --> 00:13:38.070
even further, $10.99.

00:13:38.070 --> 00:13:42.760
So as we requested, the price
comes in an ascending order.

00:13:42.760 --> 00:13:45.360
Now that we have some context
and understanding of how the

00:13:45.360 --> 00:13:47.770
APIs work, let's dig
in and check

00:13:47.770 --> 00:13:50.080
out the Client Libraries.

00:13:50.080 --> 00:13:52.530
For the Content API for
Shopping, we have Client

00:13:52.530 --> 00:13:55.440
Library Support in four
programming languages--

00:13:55.440 --> 00:13:59.420
Java, Python, PHP, and .NET.

00:13:59.420 --> 00:14:02.440
These libraries are all open
source and maintained in large

00:14:02.440 --> 00:14:05.860
part by Google engineers, but
also by other members of the

00:14:05.860 --> 00:14:08.300
open source community.

00:14:08.300 --> 00:14:10.790
For each library, we have a
comprehensive developer's

00:14:10.790 --> 00:14:13.850
guide that outlines all the
actions you can carry out with

00:14:13.850 --> 00:14:15.410
the library.

00:14:15.410 --> 00:14:17.720
Each guide can be found in
our Documentation at

00:14:17.720 --> 00:14:19.840
developers.google.com.

00:14:19.840 --> 00:14:22.250
For example, the Python
Guide can be found at

00:14:22.250 --> 00:14:26.240
developers.google.com/
shopping-content/

00:14:26.240 --> 00:14:28.890
developers-guide-python.

00:14:28.890 --> 00:14:31.630
And the other three libraries
can be found at similar links

00:14:31.630 --> 00:14:33.920
simply by replacing the
word Python with

00:14:33.920 --> 00:14:36.400
Java, PHP, or dotnet--

00:14:36.400 --> 00:14:41.130
and that's spelled
out D-O-T-N-E-T.

00:14:41.130 --> 00:14:44.280
For the samples, we're going to
using a dynamic language--

00:14:44.280 --> 00:14:45.230
Python--

00:14:45.230 --> 00:14:49.100
to demonstrate use of these
libraries in real time.

00:14:49.100 --> 00:14:52.560
The repository for the Python
Client Library is hosted on

00:14:52.560 --> 00:14:57.270
Google Code Hosting at
code.google.com/ p/

00:14:57.270 --> 00:14:58.520
gdata-python-client.

00:15:00.210 --> 00:15:04.570
The PyDocs Auto-Generated
Documentation can be found at

00:15:04.570 --> 00:15:10.850
gdata-python-cli
ent.googlecode.com/ Don't

00:15:10.850 --> 00:15:13.120
worry about writing these links
down, they're in the

00:15:13.120 --> 00:15:15.290
video description.

00:15:15.290 --> 00:15:19.390
The gdata in gdata-python-client
refers to

00:15:19.390 --> 00:15:22.970
the Google Data Protocol
and family of APIs.

00:15:22.970 --> 00:15:26.330
The Content API for Shopping is
a member of the gdata API

00:15:26.330 --> 00:15:29.310
family and so follows
the protocol.

00:15:29.310 --> 00:15:32.780
As we'll see further on, the
Search API for Shopping is not

00:15:32.780 --> 00:15:36.590
a member of the set of APIs and
so uses a different set of

00:15:36.590 --> 00:15:38.340
Client Libraries.

00:15:38.340 --> 00:15:41.640
The first thing we'll do is
install on a Linux system.

00:15:41.640 --> 00:15:44.530
The project uses Mercurial
for version control,

00:15:44.530 --> 00:15:46.230
so we can use hg--

00:15:46.230 --> 00:15:48.030
the Mercurial command
line tool--

00:15:48.030 --> 00:15:50.050
to clone the repository.

00:15:50.050 --> 00:15:59.100
So we're going to run hg clone
http://code.google.com/ p/

00:15:59.100 --> 00:16:06.520
gdata-python-client to clone
to the local machine in the

00:16:06.520 --> 00:16:09.630
gdata-python-client directory.

00:16:09.630 --> 00:16:15.000
After cloning, we're going to
enter the directory, and we'll

00:16:15.000 --> 00:16:18.590
install the gdata library
by executing sudo

00:16:18.590 --> 00:16:20.340
python setup.py install.

00:16:23.200 --> 00:16:25.470
And let me type in my
password real quick.

00:16:28.290 --> 00:16:31.380
You may not need root to
install, but it helps to just

00:16:31.380 --> 00:16:34.530
add sudo to the command,
just in case.

00:16:34.530 --> 00:16:37.460
The client library in Python,
as well as in the other

00:16:37.460 --> 00:16:41.330
supported languages, defines a
special class that handles all

00:16:41.330 --> 00:16:45.040
the dirty work of creating
requests, obeying the HTTP

00:16:45.040 --> 00:16:48.440
protocol, and creating
well-formed XML.

00:16:48.440 --> 00:16:51.330
In the Python library, this
is called a client.

00:16:51.330 --> 00:16:54.740
And we need a client before
we can do anything else.

00:16:54.740 --> 00:16:57.740
To instantiate a client,
we import the

00:16:57.740 --> 00:17:05.030
gdata.contentforshopping.client
module.

00:17:05.030 --> 00:17:07.920
This module defines a class
custom tailored for the

00:17:07.920 --> 00:17:10.910
Content API for Shopping
called Content

00:17:10.910 --> 00:17:12.579
for Shopping Client.

00:17:12.579 --> 00:17:16.130
Among other things, this client
is used to create the

00:17:16.130 --> 00:17:18.690
unique URI endpoints
to make API

00:17:18.690 --> 00:17:21.560
requests and to sign requests.

00:17:21.560 --> 00:17:24.710
When instantiating an instance
of the class, we need to pass

00:17:24.710 --> 00:17:27.500
our Account ID in to
the constructor.

00:17:27.500 --> 00:17:34.500
So here, we have a client, which
is going to be equal to

00:17:34.500 --> 00:17:34.660
gdata.contentfor
shopping.client.

00:17:34.660 --> 00:17:41.750
contentforshoppingclient, the
name of the class itself.

00:17:41.750 --> 00:17:45.200
And we're passing in Account
ID, the keyword to the

00:17:45.200 --> 00:17:49.880
constructor, with the
Account ID 8721349.

00:17:49.880 --> 00:17:53.210
And this an Account ID of my
sample account that we're

00:17:53.210 --> 00:17:55.280
going to be using.

00:17:55.280 --> 00:17:57.260
In order to authenticate,
we will use

00:17:57.260 --> 00:17:59.340
the OAuth 2.0 protocol.

00:17:59.340 --> 00:18:01.600
This protocol has three
main parts.

00:18:01.600 --> 00:18:04.920
First, an application asks a
user permission and gets a

00:18:04.920 --> 00:18:06.310
short-lived code.

00:18:06.310 --> 00:18:09.790
Second, the application uses
that code to exchange for an

00:18:09.790 --> 00:18:12.940
access token and a long-lived
refresh token.

00:18:12.940 --> 00:18:16.410
And third, when the access token
expires, the application

00:18:16.410 --> 00:18:19.610
uses the refresh token
to obtain a new one.

00:18:19.610 --> 00:18:22.210
In order to carry out this
exchange to authenticate with

00:18:22.210 --> 00:18:26.490
Google, the application will
need a Client Secret and ID.

00:18:26.490 --> 00:18:30.160
To obtain a token, we need to
visit the Google API console,

00:18:30.160 --> 00:18:32.910
as seen here, and create
a project.

00:18:32.910 --> 00:18:36.650
So we're just going to
click Create project.

00:18:36.650 --> 00:18:39.480
So we're in a new API project.

00:18:39.480 --> 00:18:41.440
After creating the project,
we see a list of

00:18:41.440 --> 00:18:43.260
services we can access.

00:18:43.260 --> 00:18:46.620
APIs from the gdata family are
not on this list, so we need

00:18:46.620 --> 00:18:49.680
not worry about the Content API
for Shopping, but we can

00:18:49.680 --> 00:18:52.830
select the Search API for
Shopping for our second demo.

00:18:52.830 --> 00:18:54.490
So let's scroll down
to find that.

00:18:54.490 --> 00:18:54.910
There it is--

00:18:54.910 --> 00:19:01.360
Search API for Shopping,
terms, Accept.

00:19:01.360 --> 00:19:05.060
And now, it's been turned on.

00:19:05.060 --> 00:19:08.430
After selecting a service, we
need to click the API Access

00:19:08.430 --> 00:19:12.380
tab to create our Client
Secret and ID.

00:19:12.380 --> 00:19:14.424
In our new project, we can click
Create an OAuth Client

00:19:14.424 --> 00:19:19.440
ID to get these values.

00:19:19.440 --> 00:19:21.260
We enter product name--

00:19:21.260 --> 00:19:22.510
here Shopping-Apis-Demo--

00:19:26.240 --> 00:19:28.580
and then proceed to
the next step.

00:19:28.580 --> 00:19:31.930
Here, we specify installed
application since we'll be

00:19:31.930 --> 00:19:34.390
running our demo from the
Interpreter rather

00:19:34.390 --> 00:19:35.640
than from the web.

00:19:38.490 --> 00:19:41.270
From there, we can copy
and retrieve our

00:19:41.270 --> 00:19:43.020
Client ID and Secret.

00:19:43.020 --> 00:19:47.860
You see here, 723174, et cetera,
is our Client ID.

00:19:47.860 --> 00:19:51.210
And lowercase kg uppercase
K, et cetera,

00:19:51.210 --> 00:19:53.530
is the Client Secret.

00:19:53.530 --> 00:19:57.330
To use our Secret and ID for
the OAuth 2.0 protocol, we

00:19:57.330 --> 00:20:04.140
import the gdata.gauth module
and create a new OAuth 2.0

00:20:04.140 --> 00:20:07.710
token providing the ID and
Secret, the scope of access

00:20:07.710 --> 00:20:10.370
we're requesting for the user's
account, and a user

00:20:10.370 --> 00:20:12.950
agent which identifies
our application.

00:20:12.950 --> 00:20:17.380
So here as the client_ID
keyword, we provide the Client

00:20:17.380 --> 00:20:19.030
ID from the browser.

00:20:19.030 --> 00:20:22.180
As the client_secret keyword,
we provide the

00:20:22.180 --> 00:20:23.790
Secret from the browser.

00:20:23.790 --> 00:20:28.150
And for the scope, we provide
googleapis.com/ auth/

00:20:28.150 --> 00:20:30.680
structuredcontent.

00:20:30.680 --> 00:20:34.510
With this token, we generate
an authorization URI by

00:20:34.510 --> 00:20:44.170
executing auth_token.gener
ate_authorize_url that we can

00:20:44.170 --> 00:20:47.080
visit in the browser to begin
the authentication process.

00:20:47.080 --> 00:20:50.350
So here, I'll just copy that
and go over to my browser.

00:20:50.350 --> 00:20:54.790
When you, or a user, visit the
authorization URI, they'll be

00:20:54.790 --> 00:20:56.910
prompted with the name
of the application--

00:20:56.910 --> 00:20:59.150
Shopping APIs Demo here--

00:20:59.150 --> 00:21:01.740
and a list of all the access
scopes requested.

00:21:01.740 --> 00:21:06.150
Since we only specified
googleapis.com/ auth/

00:21:06.150 --> 00:21:09.960
structuredcontent in our scope,
we only see Manage Your

00:21:09.960 --> 00:21:12.410
Product Data in the request.

00:21:12.410 --> 00:21:16.110
Clicking Allow Access will
authorize the application and

00:21:16.110 --> 00:21:19.690
provide the short-lived code
in that first step.

00:21:19.690 --> 00:21:23.580
We copy this code, and we use
it to an exchange for an

00:21:23.580 --> 00:21:25.060
access token.

00:21:25.060 --> 00:21:28.030
Passing the code to the OAuth
2.0 token object, we can

00:21:28.030 --> 00:21:30.280
complete the exchange
by executing

00:21:30.280 --> 00:21:40.170
auth_token.get_access_token
with the string 4/-4, et

00:21:40.170 --> 00:21:43.500
cetera, that we received
as the argument.

00:21:43.500 --> 00:21:45.640
And there we have success.

00:21:45.640 --> 00:21:48.480
Once we've done this, we must
authorize the Client with the

00:21:48.480 --> 00:21:52.740
token so the Client can use
it to sign requests.

00:21:52.740 --> 00:21:54.140
So we'll execute
auth_token.authorizeclient.

00:21:58.990 --> 00:22:02.160
And from there, our Client
is now ready to execute

00:22:02.160 --> 00:22:06.390
authenticated requests to the
Content API for Shopping.

00:22:06.390 --> 00:22:09.430
Recall the basic attributes
needed to define a product

00:22:09.430 --> 00:22:14.200
entry, such as title,
description, ID, and price.

00:22:14.200 --> 00:22:17.410
As I mentioned before, the
Client Library abstracts away

00:22:17.410 --> 00:22:21.000
all the XML creation and allows
you to just concentrate

00:22:21.000 --> 00:22:23.630
on the product data.

00:22:23.630 --> 00:22:26.120
The
gdata.contentforshopping.data

00:22:26.120 --> 00:22:30.420
module defines custom data
classes, which aid the Client

00:22:30.420 --> 00:22:32.820
in the creation of
well-formed XML.

00:22:32.820 --> 00:22:39.290
So if we import
gdata.contentforshopping.data,

00:22:39.290 --> 00:22:42.070
we'll have access to all
of those classes.

00:22:42.070 --> 00:22:45.350
To create a product, we start
out with an empty member of

00:22:45.350 --> 00:22:50.081
the product entry class, entry
= gdata.contentfor

00:22:50.081 --> 00:22:56.330
shopping.data.ProductEntry,
with no arguments in the

00:22:56.330 --> 00:22:57.910
constructor.

00:22:57.910 --> 00:23:02.070
From there, we can set the
Product ID attribute using a

00:23:02.070 --> 00:23:04.830
member of the Product ID class,
which comes from that

00:23:04.830 --> 00:23:05.550
same module.

00:23:05.550 --> 00:23:09.422
So entry.product_ID
= gdata.contentfor

00:23:09.422 --> 00:23:10.672
shopping.data.ProductId.

00:23:14.440 --> 00:23:19.170
And we're going to give it the
value SKU123 as a string.

00:23:19.170 --> 00:23:22.280
For simple elements like Product
ID, passing in the

00:23:22.280 --> 00:23:25.260
value to the constructor
is all that's needed.

00:23:25.260 --> 00:23:29.410
To set attributes that are
shared across all gdata APIs,

00:23:29.410 --> 00:23:32.360
such as title and description,
we're going to use the

00:23:32.360 --> 00:23:35.240
Atom.data module, which
is also installed

00:23:35.240 --> 00:23:36.480
with the Client Library.

00:23:36.480 --> 00:23:40.180
So we need to import
atom.data.

00:23:40.180 --> 00:23:43.785
And to set the title, we're just
going to set entry.title

00:23:43.785 --> 00:23:51.890
= atom.data.Title, SwissChamp
Swiss Army Knife, which is the

00:23:51.890 --> 00:23:54.330
title of that sample
product we saw.

00:23:56.830 --> 00:23:58.710
So there that is.

00:23:58.710 --> 00:24:01.970
For properties like price,
which also use an XML

00:24:01.970 --> 00:24:04.770
attribute, we can specify
the attribute

00:24:04.770 --> 00:24:06.970
using a keyword argument.

00:24:06.970 --> 00:24:10.668
So to set the price similar to
how we did with the Product

00:24:10.668 --> 00:24:13.545
ID, entry.price =
gdata.contentfor

00:24:13.545 --> 00:24:14.795
shopping.data.Price.

00:24:18.040 --> 00:24:22.730
And we give the value $66.95 and
use the keyword argument

00:24:22.730 --> 00:24:27.900
unit to specify US dollars.

00:24:27.900 --> 00:24:31.010
As you can see here in this
merchant account, we have no

00:24:31.010 --> 00:24:32.440
products at this time.

00:24:32.440 --> 00:24:35.680
This is the same account that
we instantiated the Client

00:24:35.680 --> 00:24:39.420
with, ID 8721349.

00:24:39.420 --> 00:24:42.360
Once you've set all the product
attributes, you can

00:24:42.360 --> 00:24:46.620
insert by feeding the entry to
the Insert Product Method of

00:24:46.620 --> 00:24:48.110
the Shopping Client.

00:24:48.110 --> 00:24:51.980
So here, we're going to get an
entry back, inserted_entry

00:24:51.980 --> 00:24:56.490
equals client.InsertProduct,
and we're

00:24:56.490 --> 00:24:58.120
going to pass it entry.

00:24:58.120 --> 00:25:00.200
The return value-- inserted
product--

00:25:00.200 --> 00:25:03.530
will have the same values we
sent, plus a few more.

00:25:03.530 --> 00:25:06.730
But it's still a member of
the Product Entry class.

00:25:06.730 --> 00:25:10.420
As you can see, if we ask for
the type of inserted entry, we

00:25:10.420 --> 00:25:11.670
get gdata.contentfor
shopping.data.productentry.

00:25:15.710 --> 00:25:19.010
Now that we've inserted it, we
can go back to the Merchant

00:25:19.010 --> 00:25:20.820
Center account.

00:25:20.820 --> 00:25:24.150
After executing this request,
we can see our Product

00:25:24.150 --> 00:25:27.070
Inventory now includes
the Swiss Army

00:25:27.070 --> 00:25:29.840
Knife that we inserted.

00:25:29.840 --> 00:25:32.790
We can use the existing inserted
entry object to

00:25:32.790 --> 00:25:35.020
update the product
in our inventory.

00:25:35.020 --> 00:25:38.600
For example, if we want to
change the name, we can set

00:25:38.600 --> 00:25:47.640
inserted_entry.title equals
atom.data.title Swiss Champ

00:25:47.640 --> 00:25:51.355
Awesome Swiss Army Knife rather
than just a regular

00:25:51.355 --> 00:25:54.210
Swiss Army Knife.

00:25:54.210 --> 00:25:57.810
And we can update by calling the
update product method with

00:25:57.810 --> 00:25:59.540
the insert entry as
the argument.

00:25:59.540 --> 00:26:03.220
So we'll get an updated entry,
and that will be equal to

00:26:03.220 --> 00:26:08.460
client.updateproduct,
and we'll pass in

00:26:08.460 --> 00:26:10.760
the inserted entry.

00:26:10.760 --> 00:26:14.240
Returning to the Merchant
Center, we can see the product

00:26:14.240 --> 00:26:15.520
name has changed.

00:26:15.520 --> 00:26:19.650
So we now have Swiss Champ
Awesome Swiss Army Knife.

00:26:19.650 --> 00:26:23.170
Finally, to delete this product,
we can call the

00:26:23.170 --> 00:26:26.450
delete product method on
the Shopping Client.

00:26:26.450 --> 00:26:30.030
So we'll get a response back,
delete_response equals

00:26:30.030 --> 00:26:37.750
client.deleteproduct, and we'll
pass it (updated_entry).

00:26:37.750 --> 00:26:41.910
Unlike inserts and updates,
the response is an HTTP

00:26:41.910 --> 00:26:45.500
response object rather
than a product entry.

00:26:45.500 --> 00:26:48.160
To make sure the delete
succeeded, we can check the

00:26:48.160 --> 00:26:49.950
HTTP status.

00:26:49.950 --> 00:26:53.630
So we'll first try to see
what is in the status,

00:26:53.630 --> 00:26:57.090
delete_response.status,
and we got 200,

00:26:57.090 --> 00:26:58.400
so that means success.

00:26:58.400 --> 00:27:00.720
And we'll just check the reason
as well to see what the

00:27:00.720 --> 00:27:03.140
reason was, so it's OK.

00:27:03.140 --> 00:27:07.010
Just as the specification for
the content API is bigger, the

00:27:07.010 --> 00:27:09.620
Client Library has more material
than the Client

00:27:09.620 --> 00:27:12.020
Library for the Search API.

00:27:12.020 --> 00:27:15.520
Client Library support for the
Search API for Shopping comes

00:27:15.520 --> 00:27:22.190
in Python, .NET, Java, PHP,
Objective-C, Ruby, JavaScript,

00:27:22.190 --> 00:27:23.850
and more to come.

00:27:23.850 --> 00:27:26.970
As I mentioned before, the
Search API for Shopping is not

00:27:26.970 --> 00:27:30.070
a member of Google's gdata
family of APIs.

00:27:30.070 --> 00:27:34.030
As a result, it's one of many
APIs supported by the google

00:27:34.030 --> 00:27:38.760
dash API dash insert language
here dash client family of

00:27:38.760 --> 00:27:40.490
Client Libraries.

00:27:40.490 --> 00:27:43.660
These Client Libraries take
advantage of an API feature

00:27:43.660 --> 00:27:46.060
called the Discovery document,
which lists all the

00:27:46.060 --> 00:27:49.940
functionality of the API in
a well-defined format.

00:27:49.940 --> 00:27:53.020
The Content API for Shopping
does not have a Discovery

00:27:53.020 --> 00:27:56.360
document, but the Search
API for Shopping does.

00:27:56.360 --> 00:27:59.150
As you can see here, this
document lists the fields that

00:27:59.150 --> 00:28:03.760
the API supports, describes how
authentication works, and

00:28:03.760 --> 00:28:06.140
even describes the schema
for the API.

00:28:06.140 --> 00:28:09.860
Fields here you see are
query, for example.

00:28:09.860 --> 00:28:12.865
Again, we'll start by installing
the Python Library

00:28:12.865 --> 00:28:14.640
on a Linux system.

00:28:14.640 --> 00:28:17.490
This repository has been
registered with PyPi, the

00:28:17.490 --> 00:28:25.280
Python Package Manager, so we
can execute sudo easy_install

00:28:25.280 --> 00:28:31.810
google dash API dash Python dash
Client, just like that.

00:28:34.470 --> 00:28:37.520
Before we can begin requests,
we need to create something

00:28:37.520 --> 00:28:40.300
similar to the Shopping
Client we saw for the

00:28:40.300 --> 00:28:42.850
Content API for Shopping.

00:28:42.850 --> 00:28:44.560
So we'll start up the
Python Terminal.

00:28:47.590 --> 00:28:49.960
Such an object can be
created on the fly

00:28:49.960 --> 00:28:51.910
from a Discovery document.

00:28:51.910 --> 00:28:54.000
In order to create it,
we simply need

00:28:54.000 --> 00:28:55.710
the name of the API.

00:28:55.710 --> 00:28:59.170
The Search API is named
Shopping, so we'll set API

00:28:59.170 --> 00:29:02.010
name equals the string
shopping.

00:29:02.010 --> 00:29:04.990
The Content API, on
the other hand, is

00:29:04.990 --> 00:29:07.070
called structured content.

00:29:07.070 --> 00:29:09.390
And we also need the
version of the API.

00:29:09.390 --> 00:29:13.500
Both shopping APIs here are v1,
so we'll set version equal

00:29:13.500 --> 00:29:16.570
the string v1.

00:29:16.570 --> 00:29:20.180
In addition, for the Search API,
we need a developer key,

00:29:20.180 --> 00:29:22.820
which was created for us at
the same time our Client

00:29:22.820 --> 00:29:24.840
Secret and ID were.

00:29:24.840 --> 00:29:27.200
Since we specified in that
project that we wanted to

00:29:27.200 --> 00:29:30.170
activate the Search API for
Shopping service, our

00:29:30.170 --> 00:29:33.650
developer key will be activated
and ready to go.

00:29:33.650 --> 00:29:38.080
If we see here the API Access
tab, we can copy

00:29:38.080 --> 00:29:39.870
our developer key--

00:29:39.870 --> 00:29:44.750
A-I-Z-A-S-Y, et cetera.

00:29:44.750 --> 00:29:47.860
And we'll paste it into the
variable Developer Key.

00:29:47.860 --> 00:29:54.110
So developer_key equals the
string that we pasted.

00:29:54.110 --> 00:29:57.910
From the newly installed
apiclient.discovery module, we

00:29:57.910 --> 00:30:01.780
can use the Build function
to create our service.

00:30:01.780 --> 00:30:03.010
So we're going to from

00:30:03.010 --> 00:30:08.840
apiclient.discovery import build.

00:30:08.840 --> 00:30:14.760
And we can execute client =
build, and we're going to pass

00:30:14.760 --> 00:30:18.430
in first the API name, which
was shopping, as we recall,

00:30:18.430 --> 00:30:19.430
then the version.

00:30:19.430 --> 00:30:23.510
And we're going to use the
keyword argument Developer

00:30:23.510 --> 00:30:26.260
Key, and we're going to pass in
the developer key that we

00:30:26.260 --> 00:30:28.300
got from the API console.

00:30:28.300 --> 00:30:31.840
Now you'll notice developer key,
the variable name of the

00:30:31.840 --> 00:30:37.470
argument is in camelCase,
but usually in

00:30:37.470 --> 00:30:38.860
Python, we don't do this.

00:30:38.860 --> 00:30:41.360
Well, the reason for that is
because in the Discovery doc,

00:30:41.360 --> 00:30:42.760
it's defined that way.

00:30:42.760 --> 00:30:46.920
So, after creating this client,
we call the products

00:30:46.920 --> 00:30:50.480
method to get a resource that
allows us to make API calls.

00:30:50.480 --> 00:30:55.360
So we'll say resource =
client.products, and we'll

00:30:55.360 --> 00:30:58.360
call that method with
no arguments.

00:30:58.360 --> 00:31:01.080
To motivate why we're doing
this, notice that in the

00:31:01.080 --> 00:31:04.870
specification in the Discovery
doc, the API actions are

00:31:04.870 --> 00:31:06.820
listed in the products key.

00:31:06.820 --> 00:31:10.210
So we're actually accessing
the actions available in a

00:31:10.210 --> 00:31:12.430
corresponding fashion.

00:31:12.430 --> 00:31:16.670
To make queries, we use the list
method on this resource

00:31:16.670 --> 00:31:18.570
and pass in our URI query

00:31:18.570 --> 00:31:21.830
parameters as keyword arguments.

00:31:21.830 --> 00:31:25.290
To search the public source
in the United States for a

00:31:25.290 --> 00:31:32.430
remote-control car, we call
response = resource.list, and

00:31:32.430 --> 00:31:37.550
we're going to pass in
country='US', source='public',

00:31:37.550 --> 00:31:39.280
and then q-- for our query--

00:31:39.280 --> 00:31:44.540
equals 'Remote Control Car.'
And we're going to execute

00:31:44.540 --> 00:31:47.420
that request.

00:31:47.420 --> 00:31:49.650
For your viewing pleasure,
we'll Prettyprint this

00:31:49.650 --> 00:31:51.470
dictionary to examine
its contents.

00:31:51.470 --> 00:31:53.910
So I'm going to import pprint
for Prettyprint.

00:31:53.910 --> 00:31:59.380
And then I'm going to
pprint.pprint the response

00:31:59.380 --> 00:32:01.520
that we receive from the API.

00:32:01.520 --> 00:32:04.900
And as you can see, it's much
larger than this screen, but

00:32:04.900 --> 00:32:09.040
it's very similar to what we saw
when we made the request

00:32:09.040 --> 00:32:11.570
through the browser.

00:32:11.570 --> 00:32:15.900
To restrict this query to cars
between $10 and $20, we can

00:32:15.900 --> 00:32:18.100
just add another keyword.

00:32:18.100 --> 00:32:20.890
So we have the same command
from before, response =

00:32:20.890 --> 00:32:25.520
resource.list and pass in the
argument, country='US',

00:32:25.520 --> 00:32:29.310
source='public', q='Remote
Control Car', and we add

00:32:29.310 --> 00:32:38.530
another argument, restrictBy=
the string price= the open

00:32:38.530 --> 00:32:42.280
square paren 10, and then 20,
and we close the string.

00:32:42.280 --> 00:32:45.170
And then we execute
that same request.

00:32:45.170 --> 00:32:49.020
And what we see, if we
Prettyprint that, results very

00:32:49.020 --> 00:32:51.100
similar to what we had before.

00:32:51.100 --> 00:32:53.380
Except now, our prices
are going to be

00:32:53.380 --> 00:32:55.960
between $10 and $20.

00:32:55.960 --> 00:33:01.840
So you see here, we have
a price of $19.19.

00:33:01.840 --> 00:33:05.760
Going up to the next one, we
see a price of $17.99.

00:33:05.760 --> 00:33:07.760
So you see, the prices
are within that

00:33:07.760 --> 00:33:09.470
range that we've defined.

00:33:09.470 --> 00:33:13.260
Finally, to rank these by price
from lowest to highest,

00:33:13.260 --> 00:33:15.160
we submit the same request

00:33:15.160 --> 00:33:17.980
resource.list=country, et cetera.

00:33:17.980 --> 00:33:21.500
And we add the rankBy parameter
with the value

00:33:21.500 --> 00:33:24.100
price:ascending.

00:33:24.100 --> 00:33:27.370
This is the same request that
we submitted in the browser.

00:33:27.370 --> 00:33:31.540
If we Prettyprint this, we see
now starting from the bottom,

00:33:31.540 --> 00:33:35.310
we'll get the item with the
highest price in the list.

00:33:35.310 --> 00:33:36.300
So we start.

00:33:36.300 --> 00:33:38.470
We see $12.99.

00:33:38.470 --> 00:33:43.780
Then the next one up has a price
of $12.99, same value,

00:33:43.780 --> 00:33:44.920
but not bigger.

00:33:44.920 --> 00:33:48.920
Then we have $12.95, and we go
up one higher, another $12.95,

00:33:48.920 --> 00:33:49.580
and one higher--

00:33:49.580 --> 00:33:49.980
OK.

00:33:49.980 --> 00:33:53.880
So as you can see,
it's ascending.

00:33:53.880 --> 00:33:56.040
And there's an exact
correspondence with the

00:33:56.040 --> 00:33:58.870
keyword parameters that we're
using here and the query

00:33:58.870 --> 00:34:04.260
parameters that get tacked on to
the URI in the API request.

00:34:04.260 --> 00:34:07.510
So using the Client Library
amounts to understanding the

00:34:07.510 --> 00:34:09.650
filter parameters.

00:34:09.650 --> 00:34:11.389
Thank you for watching
this video.

00:34:11.389 --> 00:34:14.179
I enjoyed introducing you to
these APIs, and I hope you

00:34:14.179 --> 00:34:15.580
enjoyed it, too.

00:34:15.580 --> 00:34:17.870
For more on these APIs, check
out our developer

00:34:17.870 --> 00:34:19.185
documentation at
developers.googl

00:34:19.185 --> 00:34:22.950
e.com/shopping-content,
and developers.googl

00:34:22.950 --> 00:34:26.080
e.com/shopping-search.

00:34:26.080 --> 00:34:29.480
For questions, we're always at
the ready on the forums at

00:34:29.480 --> 00:34:29.686
groups.google.co
m/group/content-

00:34:29.686 --> 00:34:30.936
api-for-shopping.

00:34:35.610 --> 00:34:35.970
And groups.google.co
m/group/search-a

00:34:35.970 --> 00:34:37.220
pi-for-shopping.

00:34:41.710 --> 00:34:43.830
And, of course, no need
to memorize these.

00:34:43.830 --> 00:34:46.020
They are in the video
description.

00:34:46.020 --> 00:34:47.430
Thanks and have a nice day.

